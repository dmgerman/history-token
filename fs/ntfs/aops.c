multiline_comment|/**&n; * aops.c - NTFS kernel address space operations and page cache handling.&n; *&t;    Part of the Linux-NTFS project.&n; *&n; * Copyright (c) 2001-2004 Anton Altaparmakov&n; * Copyright (c) 2002 Richard Russon&n; *&n; * This program/include file is free software; you can redistribute it and/or&n; * modify it under the terms of the GNU General Public License as published&n; * by the Free Software Foundation; either version 2 of the License, or&n; * (at your option) any later version.&n; *&n; * This program/include file is distributed in the hope that it will be&n; * useful, but WITHOUT ANY WARRANTY; without even the implied warranty&n; * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; * GNU General Public License for more details.&n; *&n; * You should have received a copy of the GNU General Public License&n; * along with this program (in the main directory of the Linux-NTFS&n; * distribution in the file COPYING); if not, write to the Free Software&n; * Foundation,Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA&n; */
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/pagemap.h&gt;
macro_line|#include &lt;linux/swap.h&gt;
macro_line|#include &lt;linux/buffer_head.h&gt;
macro_line|#include &quot;ntfs.h&quot;
multiline_comment|/**&n; * ntfs_end_buffer_async_read - async io completion for reading attributes&n; * @bh:&t;&t;buffer head on which io is completed&n; * @uptodate:&t;whether @bh is now uptodate or not&n; *&n; * Asynchronous I/O completion handler for reading pages belonging to the&n; * attribute address space of an inode. The inodes can either be files or&n; * directories or they can be fake inodes describing some attribute.&n; *&n; * If NInoMstProtected(), perform the post read mst fixups when all IO on the&n; * page has been completed and mark the page uptodate or set the error bit on&n; * the page. To determine the size of the records that need fixing up, we cheat&n; * a little bit by setting the index_block_size in ntfs_inode to the ntfs&n; * record size, and index_block_size_bits, to the log(base 2) of the ntfs&n; * record size.&n; */
DECL|function|ntfs_end_buffer_async_read
r_static
r_void
id|ntfs_end_buffer_async_read
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
comma
r_int
id|uptodate
)paren
(brace
r_static
id|spinlock_t
id|page_uptodate_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|buffer_head
op_star
id|tmp
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
id|ntfs_inode
op_star
id|ni
suffix:semicolon
r_int
id|page_uptodate
op_assign
l_int|1
suffix:semicolon
id|page
op_assign
id|bh-&gt;b_page
suffix:semicolon
id|ni
op_assign
id|NTFS_I
c_func
(paren
id|page-&gt;mapping-&gt;host
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
id|uptodate
)paren
)paren
(brace
id|s64
id|file_ofs
suffix:semicolon
id|set_buffer_uptodate
c_func
(paren
id|bh
)paren
suffix:semicolon
id|file_ofs
op_assign
(paren
id|page-&gt;index
op_lshift
id|PAGE_CACHE_SHIFT
)paren
op_plus
id|bh_offset
c_func
(paren
id|bh
)paren
suffix:semicolon
multiline_comment|/* Check for the current buffer head overflowing. */
r_if
c_cond
(paren
id|file_ofs
op_plus
id|bh-&gt;b_size
OG
id|ni-&gt;initialized_size
)paren
(brace
r_char
op_star
id|addr
suffix:semicolon
r_int
id|ofs
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|file_ofs
OL
id|ni-&gt;initialized_size
)paren
id|ofs
op_assign
id|ni-&gt;initialized_size
op_minus
id|file_ofs
suffix:semicolon
id|addr
op_assign
id|kmap_atomic
c_func
(paren
id|page
comma
id|KM_BIO_SRC_IRQ
)paren
suffix:semicolon
id|memset
c_func
(paren
id|addr
op_plus
id|bh_offset
c_func
(paren
id|bh
)paren
op_plus
id|ofs
comma
l_int|0
comma
id|bh-&gt;b_size
op_minus
id|ofs
)paren
suffix:semicolon
id|flush_dcache_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|kunmap_atomic
c_func
(paren
id|addr
comma
id|KM_BIO_SRC_IRQ
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|clear_buffer_uptodate
c_func
(paren
id|bh
)paren
suffix:semicolon
id|ntfs_error
c_func
(paren
id|ni-&gt;vol-&gt;sb
comma
l_string|&quot;Buffer I/O error, logical block %Lu.&quot;
comma
(paren
r_int
r_int
r_int
)paren
id|bh-&gt;b_blocknr
)paren
suffix:semicolon
id|SetPageError
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|page_uptodate_lock
comma
id|flags
)paren
suffix:semicolon
id|clear_buffer_async_read
c_func
(paren
id|bh
)paren
suffix:semicolon
id|unlock_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
id|tmp
op_assign
id|bh
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|tmp
)paren
)paren
id|page_uptodate
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|buffer_async_read
c_func
(paren
id|tmp
)paren
)paren
(brace
r_if
c_cond
(paren
id|likely
c_func
(paren
id|buffer_locked
c_func
(paren
id|tmp
)paren
)paren
)paren
r_goto
id|still_busy
suffix:semicolon
multiline_comment|/* Async buffers must be locked. */
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
id|tmp
op_assign
id|tmp-&gt;b_this_page
suffix:semicolon
)brace
r_while
c_loop
(paren
id|tmp
op_ne
id|bh
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|page_uptodate_lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If none of the buffers had errors then we can set the page uptodate,&n;&t; * but we first have to perform the post read mst fixups, if the&n;&t; * attribute is mst protected, i.e. if NInoMstProteced(ni) is true.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|NInoMstProtected
c_func
(paren
id|ni
)paren
)paren
(brace
r_if
c_cond
(paren
id|likely
c_func
(paren
id|page_uptodate
op_logical_and
op_logical_neg
id|PageError
c_func
(paren
id|page
)paren
)paren
)paren
id|SetPageUptodate
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
r_else
(brace
r_char
op_star
id|addr
suffix:semicolon
r_int
r_int
id|i
comma
id|recs
comma
id|nr_err
suffix:semicolon
id|u32
id|rec_size
suffix:semicolon
id|rec_size
op_assign
id|ni-&gt;itype.index.block_size
suffix:semicolon
id|recs
op_assign
id|PAGE_CACHE_SIZE
op_div
id|rec_size
suffix:semicolon
id|addr
op_assign
id|kmap_atomic
c_func
(paren
id|page
comma
id|KM_BIO_SRC_IRQ
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|nr_err
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|recs
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|likely
c_func
(paren
op_logical_neg
id|post_read_mst_fixup
c_func
(paren
(paren
id|NTFS_RECORD
op_star
)paren
(paren
id|addr
op_plus
id|i
op_star
id|rec_size
)paren
comma
id|rec_size
)paren
)paren
)paren
r_continue
suffix:semicolon
id|nr_err
op_increment
suffix:semicolon
id|ntfs_error
c_func
(paren
id|ni-&gt;vol-&gt;sb
comma
l_string|&quot;post_read_mst_fixup() failed, &quot;
l_string|&quot;corrupt %s record 0x%Lx. Run chkdsk.&quot;
comma
id|ni-&gt;mft_no
ques
c_cond
l_string|&quot;index&quot;
suffix:colon
l_string|&quot;mft&quot;
comma
(paren
r_int
r_int
)paren
(paren
(paren
(paren
id|s64
)paren
id|page-&gt;index
op_lshift
id|PAGE_CACHE_SHIFT
op_rshift
id|ni-&gt;itype.index.block_size_bits
)paren
op_plus
id|i
)paren
)paren
suffix:semicolon
)brace
id|flush_dcache_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|kunmap_atomic
c_func
(paren
id|addr
comma
id|KM_BIO_SRC_IRQ
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
op_logical_neg
id|PageError
c_func
(paren
id|page
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|likely
c_func
(paren
op_logical_neg
id|nr_err
op_logical_and
id|recs
)paren
)paren
(brace
r_if
c_cond
(paren
id|likely
c_func
(paren
id|page_uptodate
)paren
)paren
id|SetPageUptodate
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
r_else
(brace
id|ntfs_error
c_func
(paren
id|ni-&gt;vol-&gt;sb
comma
l_string|&quot;Setting page error, &quot;
l_string|&quot;index 0x%lx.&quot;
comma
id|page-&gt;index
)paren
suffix:semicolon
id|SetPageError
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
)brace
)brace
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
suffix:semicolon
id|still_busy
suffix:colon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|page_uptodate_lock
comma
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_read_block - fill a @page of an address space with data&n; * @page:&t;page cache page to fill with data&n; *&n; * Fill the page @page of the address space belonging to the @page-&gt;host inode.&n; * We read each buffer asynchronously and when all buffers are read in, our io&n; * completion handler ntfs_end_buffer_read_async(), if required, automatically&n; * applies the mst fixups to the page before finally marking it uptodate and&n; * unlocking it.&n; *&n; * We only enforce allocated_size limit because i_size is checked for in&n; * generic_file_read().&n; *&n; * Return 0 on success and -errno on error.&n; *&n; * Contains an adapted version of fs/buffer.c::block_read_full_page().&n; */
DECL|function|ntfs_read_block
r_static
r_int
id|ntfs_read_block
c_func
(paren
r_struct
id|page
op_star
id|page
)paren
(brace
id|VCN
id|vcn
suffix:semicolon
id|LCN
id|lcn
suffix:semicolon
id|ntfs_inode
op_star
id|ni
suffix:semicolon
id|ntfs_volume
op_star
id|vol
suffix:semicolon
id|run_list_element
op_star
id|rl
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
comma
op_star
id|head
comma
op_star
id|arr
(braket
id|MAX_BUF_PER_PAGE
)braket
suffix:semicolon
id|sector_t
id|iblock
comma
id|lblock
comma
id|zblock
suffix:semicolon
r_int
r_int
id|blocksize
comma
id|vcn_ofs
suffix:semicolon
r_int
id|i
comma
id|nr
suffix:semicolon
r_int
r_char
id|blocksize_bits
suffix:semicolon
id|ni
op_assign
id|NTFS_I
c_func
(paren
id|page-&gt;mapping-&gt;host
)paren
suffix:semicolon
id|vol
op_assign
id|ni-&gt;vol
suffix:semicolon
id|blocksize_bits
op_assign
id|VFS_I
c_func
(paren
id|ni
)paren
op_member_access_from_pointer
id|i_blkbits
suffix:semicolon
id|blocksize
op_assign
l_int|1
op_lshift
id|blocksize_bits
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page_has_buffers
c_func
(paren
id|page
)paren
)paren
id|create_empty_buffers
c_func
(paren
id|page
comma
id|blocksize
comma
l_int|0
)paren
suffix:semicolon
id|bh
op_assign
id|head
op_assign
id|page_buffers
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|bh
)paren
)paren
(brace
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|iblock
op_assign
id|page-&gt;index
op_lshift
(paren
id|PAGE_CACHE_SHIFT
op_minus
id|blocksize_bits
)paren
suffix:semicolon
id|lblock
op_assign
(paren
id|ni-&gt;allocated_size
op_plus
id|blocksize
op_minus
l_int|1
)paren
op_rshift
id|blocksize_bits
suffix:semicolon
id|zblock
op_assign
(paren
id|ni-&gt;initialized_size
op_plus
id|blocksize
op_minus
l_int|1
)paren
op_rshift
id|blocksize_bits
suffix:semicolon
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|ni-&gt;run_list.rl
op_logical_and
op_logical_neg
id|ni-&gt;mft_no
op_logical_and
op_logical_neg
id|NInoAttr
c_func
(paren
id|ni
)paren
)paren
)paren
id|panic
c_func
(paren
l_string|&quot;NTFS: $MFT/$DATA run list has been unmapped! This is a &quot;
l_string|&quot;very serious bug! Cannot continue...&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Loop through all the buffers in the page. */
id|rl
op_assign
l_int|NULL
suffix:semicolon
id|nr
op_assign
id|i
op_assign
l_int|0
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|buffer_uptodate
c_func
(paren
id|bh
)paren
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|buffer_mapped
c_func
(paren
id|bh
)paren
)paren
)paren
(brace
id|arr
(braket
id|nr
op_increment
)braket
op_assign
id|bh
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|bh-&gt;b_bdev
op_assign
id|vol-&gt;sb-&gt;s_bdev
suffix:semicolon
multiline_comment|/* Is the block within the allowed limits? */
r_if
c_cond
(paren
id|iblock
OL
id|lblock
)paren
(brace
id|BOOL
id|is_retry
op_assign
id|FALSE
suffix:semicolon
multiline_comment|/* Convert iblock into corresponding vcn and offset. */
id|vcn
op_assign
(paren
id|VCN
)paren
id|iblock
op_lshift
id|blocksize_bits
op_rshift
id|vol-&gt;cluster_size_bits
suffix:semicolon
id|vcn_ofs
op_assign
(paren
(paren
id|VCN
)paren
id|iblock
op_lshift
id|blocksize_bits
)paren
op_amp
id|vol-&gt;cluster_size_mask
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rl
)paren
(brace
id|lock_retry_remap
suffix:colon
id|down_read
c_func
(paren
op_amp
id|ni-&gt;run_list.lock
)paren
suffix:semicolon
id|rl
op_assign
id|ni-&gt;run_list.rl
suffix:semicolon
)brace
r_if
c_cond
(paren
id|likely
c_func
(paren
id|rl
op_ne
l_int|NULL
)paren
)paren
(brace
multiline_comment|/* Seek to element containing target vcn. */
r_while
c_loop
(paren
id|rl-&gt;length
op_logical_and
id|rl
(braket
l_int|1
)braket
dot
id|vcn
op_le
id|vcn
)paren
id|rl
op_increment
suffix:semicolon
id|lcn
op_assign
id|vcn_to_lcn
c_func
(paren
id|rl
comma
id|vcn
)paren
suffix:semicolon
)brace
r_else
id|lcn
op_assign
(paren
id|LCN
)paren
id|LCN_RL_NOT_MAPPED
suffix:semicolon
multiline_comment|/* Successful remap. */
r_if
c_cond
(paren
id|lcn
op_ge
l_int|0
)paren
(brace
multiline_comment|/* Setup buffer head to correct block. */
id|bh-&gt;b_blocknr
op_assign
(paren
(paren
id|lcn
op_lshift
id|vol-&gt;cluster_size_bits
)paren
op_plus
id|vcn_ofs
)paren
op_rshift
id|blocksize_bits
suffix:semicolon
id|set_buffer_mapped
c_func
(paren
id|bh
)paren
suffix:semicolon
multiline_comment|/* Only read initialized data blocks. */
r_if
c_cond
(paren
id|iblock
OL
id|zblock
)paren
(brace
id|arr
(braket
id|nr
op_increment
)braket
op_assign
id|bh
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* Fully non-initialized data block, zero it. */
r_goto
id|handle_zblock
suffix:semicolon
)brace
multiline_comment|/* It is a hole, need to zero it. */
r_if
c_cond
(paren
id|lcn
op_eq
id|LCN_HOLE
)paren
r_goto
id|handle_hole
suffix:semicolon
multiline_comment|/* If first try and run list unmapped, map and retry. */
r_if
c_cond
(paren
op_logical_neg
id|is_retry
op_logical_and
id|lcn
op_eq
id|LCN_RL_NOT_MAPPED
)paren
(brace
id|is_retry
op_assign
id|TRUE
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * Attempt to map run list, dropping lock for&n;&t;&t;&t;&t; * the duration.&n;&t;&t;&t;&t; */
id|up_read
c_func
(paren
op_amp
id|ni-&gt;run_list.lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|map_run_list
c_func
(paren
id|ni
comma
id|vcn
)paren
)paren
r_goto
id|lock_retry_remap
suffix:semicolon
id|rl
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Hard error, zero out region. */
id|SetPageError
c_func
(paren
id|page
)paren
suffix:semicolon
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;vcn_to_lcn(vcn = 0x%Lx) failed &quot;
l_string|&quot;with error code 0x%Lx%s.&quot;
comma
(paren
r_int
r_int
)paren
id|vcn
comma
(paren
r_int
r_int
)paren
op_minus
id|lcn
comma
id|is_retry
ques
c_cond
l_string|&quot; even after retrying&quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
singleline_comment|// FIXME: Depending on vol-&gt;on_errors, do something.
)brace
multiline_comment|/*&n;&t;&t; * Either iblock was outside lblock limits or vcn_to_lcn()&n;&t;&t; * returned error. Just zero that portion of the page and set&n;&t;&t; * the buffer uptodate.&n;&t;&t; */
id|handle_hole
suffix:colon
id|bh-&gt;b_blocknr
op_assign
op_minus
l_int|1UL
suffix:semicolon
id|clear_buffer_mapped
c_func
(paren
id|bh
)paren
suffix:semicolon
id|handle_zblock
suffix:colon
id|memset
c_func
(paren
id|kmap
c_func
(paren
id|page
)paren
op_plus
id|i
op_star
id|blocksize
comma
l_int|0
comma
id|blocksize
)paren
suffix:semicolon
id|flush_dcache_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|kunmap
c_func
(paren
id|page
)paren
suffix:semicolon
id|set_buffer_uptodate
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|i
op_increment
comma
id|iblock
op_increment
comma
(paren
id|bh
op_assign
id|bh-&gt;b_this_page
)paren
op_ne
id|head
)paren
suffix:semicolon
multiline_comment|/* Release the lock if we took it. */
r_if
c_cond
(paren
id|rl
)paren
id|up_read
c_func
(paren
op_amp
id|ni-&gt;run_list.lock
)paren
suffix:semicolon
multiline_comment|/* Check we have at least one buffer ready for i/o. */
r_if
c_cond
(paren
id|nr
)paren
(brace
r_struct
id|buffer_head
op_star
id|tbh
suffix:semicolon
multiline_comment|/* Lock the buffers. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr
suffix:semicolon
id|i
op_increment
)paren
(brace
id|tbh
op_assign
id|arr
(braket
id|i
)braket
suffix:semicolon
id|lock_buffer
c_func
(paren
id|tbh
)paren
suffix:semicolon
id|tbh-&gt;b_end_io
op_assign
id|ntfs_end_buffer_async_read
suffix:semicolon
id|set_buffer_async_read
c_func
(paren
id|tbh
)paren
suffix:semicolon
)brace
multiline_comment|/* Finally, start i/o on the buffers. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr
suffix:semicolon
id|i
op_increment
)paren
(brace
id|tbh
op_assign
id|arr
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|tbh
)paren
)paren
)paren
id|submit_bh
c_func
(paren
id|READ
comma
id|tbh
)paren
suffix:semicolon
r_else
id|ntfs_end_buffer_async_read
c_func
(paren
id|tbh
comma
l_int|1
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* No i/o was scheduled on any of the buffers. */
r_if
c_cond
(paren
id|likely
c_func
(paren
op_logical_neg
id|PageError
c_func
(paren
id|page
)paren
)paren
)paren
id|SetPageUptodate
c_func
(paren
id|page
)paren
suffix:semicolon
r_else
multiline_comment|/* Signal synchronous i/o error. */
id|nr
op_assign
op_minus
id|EIO
suffix:semicolon
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
id|nr
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_readpage - fill a @page of a @file with data from the device&n; * @file:&t;open file to which the page @page belongs or NULL&n; * @page:&t;page cache page to fill with data&n; *&n; * For non-resident attributes, ntfs_readpage() fills the @page of the open&n; * file @file by calling the ntfs version of the generic block_read_full_page()&n; * function, ntfs_read_block(), which in turn creates and reads in the buffers&n; * associated with the page asynchronously.&n; *&n; * For resident attributes, OTOH, ntfs_readpage() fills @page by copying the&n; * data from the mft record (which at this stage is most likely in memory) and&n; * fills the remainder with zeroes. Thus, in this case, I/O is synchronous, as&n; * even if the mft record is not cached at this point in time, we need to wait&n; * for it to be read in before we can do the copy.&n; *&n; * Return 0 on success and -errno on error.&n; *&n; * WARNING: Do not make this function static! It is used by mft.c!&n; */
DECL|function|ntfs_readpage
r_int
id|ntfs_readpage
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_struct
id|page
op_star
id|page
)paren
(brace
id|s64
id|attr_pos
suffix:semicolon
id|ntfs_inode
op_star
id|ni
comma
op_star
id|base_ni
suffix:semicolon
r_char
op_star
id|addr
suffix:semicolon
id|attr_search_context
op_star
id|ctx
suffix:semicolon
id|MFT_RECORD
op_star
id|mrec
suffix:semicolon
id|u32
id|attr_len
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|PageLocked
c_func
(paren
id|page
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * This can potentially happen because we clear PageUptodate() during&n;&t; * ntfs_writepage() of MstProtected() attributes.&n;&t; */
r_if
c_cond
(paren
id|PageUptodate
c_func
(paren
id|page
)paren
)paren
(brace
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|ni
op_assign
id|NTFS_I
c_func
(paren
id|page-&gt;mapping-&gt;host
)paren
suffix:semicolon
r_if
c_cond
(paren
id|NInoNonResident
c_func
(paren
id|ni
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * Only unnamed $DATA attributes can be compressed or&n;&t;&t; * encrypted.&n;&t;&t; */
r_if
c_cond
(paren
id|ni-&gt;type
op_eq
id|AT_DATA
op_logical_and
op_logical_neg
id|ni-&gt;name_len
)paren
(brace
multiline_comment|/* If file is encrypted, deny access, just like NT4. */
r_if
c_cond
(paren
id|NInoEncrypted
c_func
(paren
id|ni
)paren
)paren
(brace
id|err
op_assign
op_minus
id|EACCES
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
multiline_comment|/* Compressed data streams are handled in compress.c. */
r_if
c_cond
(paren
id|NInoCompressed
c_func
(paren
id|ni
)paren
)paren
r_return
id|ntfs_read_compressed_block
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
multiline_comment|/* Normal data stream. */
r_return
id|ntfs_read_block
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
multiline_comment|/* Attribute is resident, implying it is not compressed or encrypted. */
r_if
c_cond
(paren
op_logical_neg
id|NInoAttr
c_func
(paren
id|ni
)paren
)paren
id|base_ni
op_assign
id|ni
suffix:semicolon
r_else
id|base_ni
op_assign
id|ni-&gt;ext.base_ntfs_ino
suffix:semicolon
multiline_comment|/* Map, pin, and lock the mft record. */
id|mrec
op_assign
id|map_mft_record
c_func
(paren
id|base_ni
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|IS_ERR
c_func
(paren
id|mrec
)paren
)paren
)paren
(brace
id|err
op_assign
id|PTR_ERR
c_func
(paren
id|mrec
)paren
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
id|ctx
op_assign
id|get_attr_search_ctx
c_func
(paren
id|base_ni
comma
id|mrec
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|ctx
)paren
)paren
(brace
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|lookup_attr
c_func
(paren
id|ni-&gt;type
comma
id|ni-&gt;name
comma
id|ni-&gt;name_len
comma
id|IGNORE_CASE
comma
l_int|0
comma
l_int|NULL
comma
l_int|0
comma
id|ctx
)paren
)paren
)paren
(brace
id|err
op_assign
op_minus
id|ENOENT
suffix:semicolon
r_goto
id|put_unm_err_out
suffix:semicolon
)brace
multiline_comment|/* Starting position of the page within the attribute value. */
id|attr_pos
op_assign
id|page-&gt;index
op_lshift
id|PAGE_CACHE_SHIFT
suffix:semicolon
multiline_comment|/* The total length of the attribute value. */
id|attr_len
op_assign
id|le32_to_cpu
c_func
(paren
id|ctx-&gt;attr-&gt;data.resident.value_length
)paren
suffix:semicolon
id|addr
op_assign
id|kmap
c_func
(paren
id|page
)paren
suffix:semicolon
multiline_comment|/* Copy over in bounds data, zeroing the remainder of the page. */
r_if
c_cond
(paren
id|attr_pos
OL
id|attr_len
)paren
(brace
id|u32
id|bytes
op_assign
id|attr_len
op_minus
id|attr_pos
suffix:semicolon
r_if
c_cond
(paren
id|bytes
OG
id|PAGE_CACHE_SIZE
)paren
id|bytes
op_assign
id|PAGE_CACHE_SIZE
suffix:semicolon
r_else
r_if
c_cond
(paren
id|bytes
OL
id|PAGE_CACHE_SIZE
)paren
id|memset
c_func
(paren
id|addr
op_plus
id|bytes
comma
l_int|0
comma
id|PAGE_CACHE_SIZE
op_minus
id|bytes
)paren
suffix:semicolon
multiline_comment|/* Copy the data to the page. */
id|memcpy
c_func
(paren
id|addr
comma
id|attr_pos
op_plus
(paren
r_char
op_star
)paren
id|ctx-&gt;attr
op_plus
id|le16_to_cpu
c_func
(paren
id|ctx-&gt;attr-&gt;data.resident.value_offset
)paren
comma
id|bytes
)paren
suffix:semicolon
)brace
r_else
id|memset
c_func
(paren
id|addr
comma
l_int|0
comma
id|PAGE_CACHE_SIZE
)paren
suffix:semicolon
id|flush_dcache_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|kunmap
c_func
(paren
id|page
)paren
suffix:semicolon
id|SetPageUptodate
c_func
(paren
id|page
)paren
suffix:semicolon
id|put_unm_err_out
suffix:colon
id|put_attr_search_ctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
id|unm_err_out
suffix:colon
id|unmap_mft_record
c_func
(paren
id|base_ni
)paren
suffix:semicolon
id|err_out
suffix:colon
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
macro_line|#ifdef NTFS_RW
multiline_comment|/**&n; * ntfs_write_block - write a @page to the backing store&n; * @page:&t;page cache page to write out&n; *&n; * This function is for writing pages belonging to non-resident, non-mst&n; * protected attributes to their backing store.&n; *&n; * For a page with buffers, map and write the dirty buffers asynchronously&n; * under page writeback. For a page without buffers, create buffers for the&n; * page, then proceed as above.&n; *&n; * If a page doesn&squot;t have buffers the page dirty state is definitive. If a page&n; * does have buffers, the page dirty state is just a hint, and the buffer dirty&n; * state is definitive. (A hint which has rules: dirty buffers against a clean&n; * page is illegal. Other combinations are legal and need to be handled. In&n; * particular a dirty page containing clean buffers for example.)&n; *&n; * Return 0 on success and -errno on error.&n; *&n; * Based on ntfs_read_block() and __block_write_full_page().&n; */
DECL|function|ntfs_write_block
r_static
r_int
id|ntfs_write_block
c_func
(paren
r_struct
id|writeback_control
op_star
id|wbc
comma
r_struct
id|page
op_star
id|page
)paren
(brace
id|VCN
id|vcn
suffix:semicolon
id|LCN
id|lcn
suffix:semicolon
id|sector_t
id|block
comma
id|dblock
comma
id|iblock
suffix:semicolon
r_struct
id|inode
op_star
id|vi
suffix:semicolon
id|ntfs_inode
op_star
id|ni
suffix:semicolon
id|ntfs_volume
op_star
id|vol
suffix:semicolon
id|run_list_element
op_star
id|rl
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
comma
op_star
id|head
suffix:semicolon
r_int
r_int
id|blocksize
comma
id|vcn_ofs
suffix:semicolon
r_int
id|err
suffix:semicolon
id|BOOL
id|need_end_writeback
suffix:semicolon
r_int
r_char
id|blocksize_bits
suffix:semicolon
id|vi
op_assign
id|page-&gt;mapping-&gt;host
suffix:semicolon
id|ni
op_assign
id|NTFS_I
c_func
(paren
id|vi
)paren
suffix:semicolon
id|vol
op_assign
id|ni-&gt;vol
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Entering for inode %li, attribute type 0x%x, page index &quot;
l_string|&quot;0x%lx.&bslash;n&quot;
comma
id|vi-&gt;i_ino
comma
id|ni-&gt;type
comma
id|page-&gt;index
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|NInoNonResident
c_func
(paren
id|ni
)paren
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|NInoMstProtected
c_func
(paren
id|ni
)paren
)paren
suffix:semicolon
id|blocksize_bits
op_assign
id|vi-&gt;i_blkbits
suffix:semicolon
id|blocksize
op_assign
l_int|1
op_lshift
id|blocksize_bits
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page_has_buffers
c_func
(paren
id|page
)paren
)paren
(brace
id|BUG_ON
c_func
(paren
op_logical_neg
id|PageUptodate
c_func
(paren
id|page
)paren
)paren
suffix:semicolon
id|create_empty_buffers
c_func
(paren
id|page
comma
id|blocksize
comma
(paren
l_int|1
op_lshift
id|BH_Uptodate
)paren
op_or
(paren
l_int|1
op_lshift
id|BH_Dirty
)paren
)paren
suffix:semicolon
)brace
id|bh
op_assign
id|head
op_assign
id|page_buffers
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|bh
)paren
)paren
(brace
id|ntfs_warning
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Error allocating page buffers. &quot;
l_string|&quot;Redirtying page so we try again later.&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Put the page back on mapping-&gt;dirty_pages, but leave its&n;&t;&t; * buffer&squot;s dirty state as-is.&n;&t;&t; */
id|redirty_page_for_writepage
c_func
(paren
id|wbc
comma
id|page
)paren
suffix:semicolon
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* NOTE: Different naming scheme to ntfs_read_block()! */
multiline_comment|/* The first block in the page. */
id|block
op_assign
id|page-&gt;index
op_lshift
(paren
id|PAGE_CACHE_SHIFT
op_minus
id|blocksize_bits
)paren
suffix:semicolon
multiline_comment|/* The first out of bounds block for the data size. */
id|dblock
op_assign
(paren
id|vi-&gt;i_size
op_plus
id|blocksize
op_minus
l_int|1
)paren
op_rshift
id|blocksize_bits
suffix:semicolon
multiline_comment|/* The last (fully or partially) initialized block. */
id|iblock
op_assign
id|ni-&gt;initialized_size
op_rshift
id|blocksize_bits
suffix:semicolon
multiline_comment|/*&n;&t; * Be very careful.  We have no exclusion from __set_page_dirty_buffers&n;&t; * here, and the (potentially unmapped) buffers may become dirty at&n;&t; * any time.  If a buffer becomes dirty here after we&squot;ve inspected it&n;&t; * then we just miss that fact, and the page stays dirty.&n;&t; *&n;&t; * Buffers outside i_size may be dirtied by __set_page_dirty_buffers;&n;&t; * handle that here by just cleaning them.&n;&t; */
multiline_comment|/*&n;&t; * Loop through all the buffers in the page, mapping all the dirty&n;&t; * buffers to disk addresses and handling any aliases from the&n;&t; * underlying block device&squot;s mapping.&n;&t; */
id|rl
op_assign
l_int|NULL
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
r_do
(brace
id|BOOL
id|is_retry
op_assign
id|FALSE
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|block
op_ge
id|dblock
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Mapped buffers outside i_size will occur, because&n;&t;&t;&t; * this page can be outside i_size when there is a&n;&t;&t;&t; * truncate in progress. The contents of such buffers&n;&t;&t;&t; * were zeroed by ntfs_writepage().&n;&t;&t;&t; *&n;&t;&t;&t; * FIXME: What about the small race window where&n;&t;&t;&t; * ntfs_writepage() has not done any clearing because&n;&t;&t;&t; * the page was within i_size but before we get here,&n;&t;&t;&t; * vmtruncate() modifies i_size?&n;&t;&t;&t; */
id|clear_buffer_dirty
c_func
(paren
id|bh
)paren
suffix:semicolon
id|set_buffer_uptodate
c_func
(paren
id|bh
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* Clean buffers are not written out, so no need to map them. */
r_if
c_cond
(paren
op_logical_neg
id|buffer_dirty
c_func
(paren
id|bh
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/* Make sure we have enough initialized size. */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
(paren
id|block
op_ge
id|iblock
)paren
op_logical_and
(paren
id|ni-&gt;initialized_size
OL
id|vi-&gt;i_size
)paren
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * If this page is fully outside initialized size, zero&n;&t;&t;&t; * out all pages between the current initialized size&n;&t;&t;&t; * and the current page. Just use ntfs_readpage() to do&n;&t;&t;&t; * the zeroing transparently.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|block
OG
id|iblock
)paren
(brace
singleline_comment|// TODO:
singleline_comment|// For each page do:
singleline_comment|// - read_cache_page()
singleline_comment|// Again for each page do:
singleline_comment|// - wait_on_page_locked()
singleline_comment|// - Check (PageUptodate(page) &amp;&amp;
singleline_comment|//&t;&t;&t;!PageError(page))
singleline_comment|// Update initialized size in the attribute and
singleline_comment|// in the inode.
singleline_comment|// Again, for each page do:
singleline_comment|//&t;__set_page_dirty_buffers();
singleline_comment|// page_cache_release()
singleline_comment|// We don&squot;t need to wait on the writes.
singleline_comment|// Update iblock.
)brace
multiline_comment|/*&n;&t;&t;&t; * The current page straddles initialized size. Zero&n;&t;&t;&t; * all non-uptodate buffers and set them uptodate (and&n;&t;&t;&t; * dirty?). Note, there aren&squot;t any non-uptodate buffers&n;&t;&t;&t; * if the page is uptodate.&n;&t;&t;&t; * FIXME: For an uptodate page, the buffers may need to&n;&t;&t;&t; * be written out because they were not initialized on&n;&t;&t;&t; * disk before.&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|PageUptodate
c_func
(paren
id|page
)paren
)paren
(brace
singleline_comment|// TODO:
singleline_comment|// Zero any non-uptodate buffers up to i_size.
singleline_comment|// Set them uptodate and dirty.
)brace
singleline_comment|// TODO:
singleline_comment|// Update initialized size in the attribute and in the
singleline_comment|// inode (up to i_size).
singleline_comment|// Update iblock.
singleline_comment|// FIXME: This is inefficient. Try to batch the two
singleline_comment|// size changes to happen in one go.
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Writing beyond initialized size &quot;
l_string|&quot;is not supported yet. Sorry.&quot;
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EOPNOTSUPP
suffix:semicolon
r_break
suffix:semicolon
singleline_comment|// Do NOT set_buffer_new() BUT DO clear buffer range
singleline_comment|// outside write request range.
singleline_comment|// set_buffer_uptodate() on complete buffers as well as
singleline_comment|// set_buffer_dirty().
)brace
multiline_comment|/* No need to map buffers that are already mapped. */
r_if
c_cond
(paren
id|buffer_mapped
c_func
(paren
id|bh
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/* Unmapped, dirty buffer. Need to map it. */
id|bh-&gt;b_bdev
op_assign
id|vol-&gt;sb-&gt;s_bdev
suffix:semicolon
multiline_comment|/* Convert block into corresponding vcn and offset. */
id|vcn
op_assign
(paren
id|VCN
)paren
id|block
op_lshift
id|blocksize_bits
op_rshift
id|vol-&gt;cluster_size_bits
suffix:semicolon
id|vcn_ofs
op_assign
(paren
(paren
id|VCN
)paren
id|block
op_lshift
id|blocksize_bits
)paren
op_amp
id|vol-&gt;cluster_size_mask
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rl
)paren
(brace
id|lock_retry_remap
suffix:colon
id|down_read
c_func
(paren
op_amp
id|ni-&gt;run_list.lock
)paren
suffix:semicolon
id|rl
op_assign
id|ni-&gt;run_list.rl
suffix:semicolon
)brace
r_if
c_cond
(paren
id|likely
c_func
(paren
id|rl
op_ne
l_int|NULL
)paren
)paren
(brace
multiline_comment|/* Seek to element containing target vcn. */
r_while
c_loop
(paren
id|rl-&gt;length
op_logical_and
id|rl
(braket
l_int|1
)braket
dot
id|vcn
op_le
id|vcn
)paren
id|rl
op_increment
suffix:semicolon
id|lcn
op_assign
id|vcn_to_lcn
c_func
(paren
id|rl
comma
id|vcn
)paren
suffix:semicolon
)brace
r_else
id|lcn
op_assign
(paren
id|LCN
)paren
id|LCN_RL_NOT_MAPPED
suffix:semicolon
multiline_comment|/* Successful remap. */
r_if
c_cond
(paren
id|lcn
op_ge
l_int|0
)paren
(brace
multiline_comment|/* Setup buffer head to point to correct block. */
id|bh-&gt;b_blocknr
op_assign
(paren
(paren
id|lcn
op_lshift
id|vol-&gt;cluster_size_bits
)paren
op_plus
id|vcn_ofs
)paren
op_rshift
id|blocksize_bits
suffix:semicolon
id|set_buffer_mapped
c_func
(paren
id|bh
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* It is a hole, need to instantiate it. */
r_if
c_cond
(paren
id|lcn
op_eq
id|LCN_HOLE
)paren
(brace
singleline_comment|// TODO: Instantiate the hole.
singleline_comment|// clear_buffer_new(bh);
singleline_comment|// unmap_underlying_metadata(bh-&gt;b_bdev, bh-&gt;b_blocknr);
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Writing into sparse regions is &quot;
l_string|&quot;not supported yet. Sorry.&quot;
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EOPNOTSUPP
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* If first try and run list unmapped, map and retry. */
r_if
c_cond
(paren
op_logical_neg
id|is_retry
op_logical_and
id|lcn
op_eq
id|LCN_RL_NOT_MAPPED
)paren
(brace
id|is_retry
op_assign
id|TRUE
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Attempt to map run list, dropping lock for&n;&t;&t;&t; * the duration.&n;&t;&t;&t; */
id|up_read
c_func
(paren
op_amp
id|ni-&gt;run_list.lock
)paren
suffix:semicolon
id|err
op_assign
id|map_run_list
c_func
(paren
id|ni
comma
id|vcn
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
op_logical_neg
id|err
)paren
)paren
r_goto
id|lock_retry_remap
suffix:semicolon
id|rl
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Failed to map the buffer, even after retrying. */
id|bh-&gt;b_blocknr
op_assign
op_minus
l_int|1UL
suffix:semicolon
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;vcn_to_lcn(vcn = 0x%Lx) failed &quot;
l_string|&quot;with error code 0x%Lx%s.&quot;
comma
(paren
r_int
r_int
)paren
id|vcn
comma
(paren
r_int
r_int
)paren
op_minus
id|lcn
comma
id|is_retry
ques
c_cond
l_string|&quot; even after retrying&quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
singleline_comment|// FIXME: Depending on vol-&gt;on_errors, do something.
r_if
c_cond
(paren
op_logical_neg
id|err
)paren
id|err
op_assign
op_minus
id|EIO
suffix:semicolon
r_break
suffix:semicolon
)brace
r_while
c_loop
(paren
id|block
op_increment
comma
(paren
id|bh
op_assign
id|bh-&gt;b_this_page
)paren
op_ne
id|head
)paren
suffix:semicolon
multiline_comment|/* Release the lock if we took it. */
r_if
c_cond
(paren
id|rl
)paren
id|up_read
c_func
(paren
op_amp
id|ni-&gt;run_list.lock
)paren
suffix:semicolon
multiline_comment|/* For the error case, need to reset bh to the beginning. */
id|bh
op_assign
id|head
suffix:semicolon
multiline_comment|/* Just an optimization, so -&gt;readpage() isn&squot;t called later. */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|PageUptodate
c_func
(paren
id|page
)paren
)paren
)paren
(brace
r_int
id|uptodate
op_assign
l_int|1
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|bh
)paren
)paren
(brace
id|uptodate
op_assign
l_int|0
suffix:semicolon
id|bh
op_assign
id|head
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
(paren
id|bh
op_assign
id|bh-&gt;b_this_page
)paren
op_ne
id|head
)paren
suffix:semicolon
r_if
c_cond
(paren
id|uptodate
)paren
id|SetPageUptodate
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
multiline_comment|/* Setup all mapped, dirty buffers for async write i/o. */
r_do
(brace
id|get_bh
c_func
(paren
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buffer_mapped
c_func
(paren
id|bh
)paren
op_logical_and
id|buffer_dirty
c_func
(paren
id|bh
)paren
)paren
(brace
id|lock_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|test_clear_buffer_dirty
c_func
(paren
id|bh
)paren
)paren
(brace
id|BUG_ON
c_func
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|bh
)paren
)paren
suffix:semicolon
id|mark_buffer_async_write
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
r_else
id|unlock_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|err
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * For the error case. The buffer may have been set&n;&t;&t;&t; * dirty during attachment to a dirty page.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|err
op_ne
op_minus
id|ENOMEM
)paren
id|clear_buffer_dirty
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
(paren
id|bh
op_assign
id|bh-&gt;b_this_page
)paren
op_ne
id|head
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|err
)paren
)paren
(brace
singleline_comment|// TODO: Remove the -EOPNOTSUPP check later on...
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|err
op_eq
op_minus
id|EOPNOTSUPP
)paren
)paren
id|err
op_assign
l_int|0
suffix:semicolon
r_else
r_if
c_cond
(paren
id|err
op_eq
op_minus
id|ENOMEM
)paren
(brace
id|ntfs_warning
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Error allocating memory. &quot;
l_string|&quot;Redirtying page so we try again &quot;
l_string|&quot;later.&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Put the page back on mapping-&gt;dirty_pages, but&n;&t;&t;&t; * leave its buffer&squot;s dirty state as-is.&n;&t;&t;&t; */
id|redirty_page_for_writepage
c_func
(paren
id|wbc
comma
id|page
)paren
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
)brace
r_else
id|SetPageError
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
id|BUG_ON
c_func
(paren
id|PageWriteback
c_func
(paren
id|page
)paren
)paren
suffix:semicolon
id|set_page_writeback
c_func
(paren
id|page
)paren
suffix:semicolon
multiline_comment|/* Keeps try_to_free_buffers() away. */
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Submit the prepared buffers for i/o. Note the page is unlocked,&n;&t; * and the async write i/o completion handler can end_page_writeback()&n;&t; * at any time after the *first* submit_bh(). So the buffers can then&n;&t; * disappear...&n;&t; */
id|need_end_writeback
op_assign
id|TRUE
suffix:semicolon
r_do
(brace
r_struct
id|buffer_head
op_star
id|next
op_assign
id|bh-&gt;b_this_page
suffix:semicolon
r_if
c_cond
(paren
id|buffer_async_write
c_func
(paren
id|bh
)paren
)paren
(brace
id|submit_bh
c_func
(paren
id|WRITE
comma
id|bh
)paren
suffix:semicolon
id|need_end_writeback
op_assign
id|FALSE
suffix:semicolon
)brace
id|put_bh
c_func
(paren
id|bh
)paren
suffix:semicolon
id|bh
op_assign
id|next
suffix:semicolon
)brace
r_while
c_loop
(paren
id|bh
op_ne
id|head
)paren
suffix:semicolon
multiline_comment|/* If no i/o was started, need to end_page_writeback(). */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|need_end_writeback
)paren
)paren
id|end_page_writeback
c_func
(paren
id|page
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Done.&quot;
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_writepage - write a @page to the backing store&n; * @page:&t;page cache page to write out&n; *&n; * For non-resident attributes, ntfs_writepage() writes the @page by calling&n; * the ntfs version of the generic block_write_full_page() function,&n; * ntfs_write_block(), which in turn if necessary creates and writes the&n; * buffers associated with the page asynchronously.&n; *&n; * For resident attributes, OTOH, ntfs_writepage() writes the @page by copying&n; * the data to the mft record (which at this stage is most likely in memory).&n; * Thus, in this case, I/O is synchronous, as even if the mft record is not&n; * cached at this point in time, we need to wait for it to be read in before we&n; * can do the copy.&n; *&n; * Note the caller clears the page dirty flag before calling ntfs_writepage().&n; *&n; * Based on ntfs_readpage() and fs/buffer.c::block_write_full_page().&n; *&n; * Return 0 on success and -errno on error.&n; */
DECL|function|ntfs_writepage
r_static
r_int
id|ntfs_writepage
c_func
(paren
r_struct
id|page
op_star
id|page
comma
r_struct
id|writeback_control
op_star
id|wbc
)paren
(brace
id|s64
id|attr_pos
suffix:semicolon
r_struct
id|inode
op_star
id|vi
suffix:semicolon
id|ntfs_inode
op_star
id|ni
comma
op_star
id|base_ni
suffix:semicolon
r_char
op_star
id|kaddr
suffix:semicolon
id|attr_search_context
op_star
id|ctx
suffix:semicolon
id|MFT_RECORD
op_star
id|m
suffix:semicolon
id|u32
id|attr_len
comma
id|bytes
suffix:semicolon
r_int
id|err
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|PageLocked
c_func
(paren
id|page
)paren
)paren
suffix:semicolon
id|vi
op_assign
id|page-&gt;mapping-&gt;host
suffix:semicolon
multiline_comment|/* Is the page fully outside i_size? (truncate in progress) */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|page-&gt;index
op_ge
(paren
id|vi-&gt;i_size
op_plus
id|PAGE_CACHE_SIZE
op_minus
l_int|1
)paren
op_rshift
id|PAGE_CACHE_SHIFT
)paren
)paren
(brace
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Write outside i_size - truncated?&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|ni
op_assign
id|NTFS_I
c_func
(paren
id|vi
)paren
suffix:semicolon
r_if
c_cond
(paren
id|NInoNonResident
c_func
(paren
id|ni
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * Only unnamed $DATA attributes can be compressed, encrypted,&n;&t;&t; * and/or sparse.&n;&t;&t; */
r_if
c_cond
(paren
id|ni-&gt;type
op_eq
id|AT_DATA
op_logical_and
op_logical_neg
id|ni-&gt;name_len
)paren
(brace
multiline_comment|/* If file is encrypted, deny access, just like NT4. */
r_if
c_cond
(paren
id|NInoEncrypted
c_func
(paren
id|ni
)paren
)paren
(brace
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Denying write access to encrypted &quot;
l_string|&quot;file.&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EACCES
suffix:semicolon
)brace
multiline_comment|/* Compressed data streams are handled in compress.c. */
r_if
c_cond
(paren
id|NInoCompressed
c_func
(paren
id|ni
)paren
)paren
(brace
singleline_comment|// TODO: Implement and replace this check with
singleline_comment|// return ntfs_write_compressed_block(page);
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Writing to compressed &quot;
l_string|&quot;files is not supported yet. &quot;
l_string|&quot;Sorry.&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
singleline_comment|// TODO: Implement and remove this check.
r_if
c_cond
(paren
id|NInoSparse
c_func
(paren
id|ni
)paren
)paren
(brace
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Writing to sparse files &quot;
l_string|&quot;is not supported yet. Sorry.&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
)brace
multiline_comment|/* We have to zero every time due to mmap-at-end-of-file. */
r_if
c_cond
(paren
id|page-&gt;index
op_ge
(paren
id|vi-&gt;i_size
op_rshift
id|PAGE_CACHE_SHIFT
)paren
)paren
(brace
multiline_comment|/* The page straddles i_size. */
r_int
r_int
id|ofs
op_assign
id|vi-&gt;i_size
op_amp
op_complement
id|PAGE_CACHE_MASK
suffix:semicolon
id|kaddr
op_assign
id|kmap_atomic
c_func
(paren
id|page
comma
id|KM_USER0
)paren
suffix:semicolon
id|memset
c_func
(paren
id|kaddr
op_plus
id|ofs
comma
l_int|0
comma
id|PAGE_CACHE_SIZE
op_minus
id|ofs
)paren
suffix:semicolon
id|flush_dcache_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|kunmap_atomic
c_func
(paren
id|kaddr
comma
id|KM_USER0
)paren
suffix:semicolon
)brace
singleline_comment|// TODO: Implement and remove this check.
r_if
c_cond
(paren
id|NInoMstProtected
c_func
(paren
id|ni
)paren
)paren
(brace
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Writing to MST protected &quot;
l_string|&quot;attributes is not supported yet. &quot;
l_string|&quot;Sorry.&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
multiline_comment|/* Normal data stream. */
r_return
id|ntfs_write_block
c_func
(paren
id|wbc
comma
id|page
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Attribute is resident, implying it is not compressed, encrypted, or&n;&t; * mst protected.&n;&t; */
id|BUG_ON
c_func
(paren
id|page_has_buffers
c_func
(paren
id|page
)paren
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|PageUptodate
c_func
(paren
id|page
)paren
)paren
suffix:semicolon
singleline_comment|// TODO: Consider using PageWriteback() + unlock_page() in 2.5 once the
singleline_comment|// &quot;VM fiddling has ended&quot;. Note, don&squot;t forget to replace all the
singleline_comment|// unlock_page() calls further below with end_page_writeback() ones.
singleline_comment|// FIXME: Make sure it is ok to SetPageError() on unlocked page under
singleline_comment|// writeback before doing the change!
macro_line|#if 0
id|set_page_writeback
c_func
(paren
id|page
)paren
suffix:semicolon
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|NInoAttr
c_func
(paren
id|ni
)paren
)paren
id|base_ni
op_assign
id|ni
suffix:semicolon
r_else
id|base_ni
op_assign
id|ni-&gt;ext.base_ntfs_ino
suffix:semicolon
multiline_comment|/* Map, pin, and lock the mft record. */
id|m
op_assign
id|map_mft_record
c_func
(paren
id|base_ni
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|IS_ERR
c_func
(paren
id|m
)paren
)paren
)paren
(brace
id|err
op_assign
id|PTR_ERR
c_func
(paren
id|m
)paren
suffix:semicolon
id|m
op_assign
l_int|NULL
suffix:semicolon
id|ctx
op_assign
l_int|NULL
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
id|ctx
op_assign
id|get_attr_search_ctx
c_func
(paren
id|base_ni
comma
id|m
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|ctx
)paren
)paren
(brace
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|lookup_attr
c_func
(paren
id|ni-&gt;type
comma
id|ni-&gt;name
comma
id|ni-&gt;name_len
comma
id|IGNORE_CASE
comma
l_int|0
comma
l_int|NULL
comma
l_int|0
comma
id|ctx
)paren
)paren
)paren
(brace
id|err
op_assign
op_minus
id|ENOENT
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
multiline_comment|/* Starting position of the page within the attribute value. */
id|attr_pos
op_assign
id|page-&gt;index
op_lshift
id|PAGE_CACHE_SHIFT
suffix:semicolon
multiline_comment|/* The total length of the attribute value. */
id|attr_len
op_assign
id|le32_to_cpu
c_func
(paren
id|ctx-&gt;attr-&gt;data.resident.value_length
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|vi-&gt;i_size
op_ne
id|attr_len
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;BUG()! i_size (0x%Lx) doesn&squot;t match &quot;
l_string|&quot;attr_len (0x%x). Aborting write.&quot;
comma
id|vi-&gt;i_size
comma
id|attr_len
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|attr_pos
op_ge
id|attr_len
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;BUG()! attr_pos (0x%Lx) &gt; attr_len (0x%x)&quot;
l_string|&quot;. Aborting write.&quot;
comma
id|attr_pos
comma
id|attr_len
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
id|bytes
op_assign
id|attr_len
op_minus
id|attr_pos
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|bytes
OG
id|PAGE_CACHE_SIZE
)paren
)paren
id|bytes
op_assign
id|PAGE_CACHE_SIZE
suffix:semicolon
multiline_comment|/*&n;&t; * Here, we don&squot;t need to zero the out of bounds area everytime because&n;&t; * the below memcpy() already takes care of the mmap-at-end-of-file&n;&t; * requirements. If the file is converted to a non-resident one, then&n;&t; * the code path use is switched to the non-resident one where the&n;&t; * zeroing happens on each ntfs_writepage() invocation.&n;&t; *&n;&t; * The above also applies nicely when i_size is decreased.&n;&t; *&n;&t; * When i_size is increased, the memory between the old and new i_size&n;&t; * _must_ be zeroed (or overwritten with new data). Otherwise we will&n;&t; * expose data to userspace/disk which should never have been exposed.&n;&t; *&n;&t; * FIXME: Ensure that i_size increases do the zeroing/overwriting and&n;&t; * if we cannot guarantee that, then enable the zeroing below.&n;&t; */
id|kaddr
op_assign
id|kmap_atomic
c_func
(paren
id|page
comma
id|KM_USER0
)paren
suffix:semicolon
multiline_comment|/* Copy the data from the page to the mft record. */
id|memcpy
c_func
(paren
(paren
id|u8
op_star
)paren
id|ctx-&gt;attr
op_plus
id|le16_to_cpu
c_func
(paren
id|ctx-&gt;attr-&gt;data.resident.value_offset
)paren
op_plus
id|attr_pos
comma
id|kaddr
comma
id|bytes
)paren
suffix:semicolon
id|flush_dcache_mft_record_page
c_func
(paren
id|ctx-&gt;ntfs_ino
)paren
suffix:semicolon
macro_line|#if 0
multiline_comment|/* Zero out of bounds area. */
r_if
c_cond
(paren
id|likely
c_func
(paren
id|bytes
OL
id|PAGE_CACHE_SIZE
)paren
)paren
(brace
id|memset
c_func
(paren
id|kaddr
op_plus
id|bytes
comma
l_int|0
comma
id|PAGE_CACHE_SIZE
op_minus
id|bytes
)paren
suffix:semicolon
id|flush_dcache_page
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
macro_line|#endif
id|kunmap_atomic
c_func
(paren
id|kaddr
comma
id|KM_USER0
)paren
suffix:semicolon
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
singleline_comment|// TODO: Mark mft record dirty so it gets written back.
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Writing to resident files is not supported yet. &quot;
l_string|&quot;Wrote to memory only...&quot;
)paren
suffix:semicolon
id|put_attr_search_ctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
id|unmap_mft_record
c_func
(paren
id|base_ni
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|err_out
suffix:colon
r_if
c_cond
(paren
id|err
op_eq
op_minus
id|ENOMEM
)paren
(brace
id|ntfs_warning
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Error allocating memory. Redirtying &quot;
l_string|&quot;page so we try again later.&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Put the page back on mapping-&gt;dirty_pages, but leave its&n;&t;&t; * buffer&squot;s dirty state as-is.&n;&t;&t; */
id|redirty_page_for_writepage
c_func
(paren
id|wbc
comma
id|page
)paren
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Resident attribute write failed with &quot;
l_string|&quot;error %i. Setting page error flag.&quot;
comma
op_minus
id|err
)paren
suffix:semicolon
id|SetPageError
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ctx
)paren
id|put_attr_search_ctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|m
)paren
id|unmap_mft_record
c_func
(paren
id|base_ni
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_prepare_nonresident_write -&n; *&n; */
DECL|function|ntfs_prepare_nonresident_write
r_static
r_int
id|ntfs_prepare_nonresident_write
c_func
(paren
r_struct
id|page
op_star
id|page
comma
r_int
id|from
comma
r_int
id|to
)paren
(brace
id|VCN
id|vcn
suffix:semicolon
id|LCN
id|lcn
suffix:semicolon
id|sector_t
id|block
comma
id|ablock
comma
id|iblock
suffix:semicolon
r_struct
id|inode
op_star
id|vi
suffix:semicolon
id|ntfs_inode
op_star
id|ni
suffix:semicolon
id|ntfs_volume
op_star
id|vol
suffix:semicolon
id|run_list_element
op_star
id|rl
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
comma
op_star
id|head
comma
op_star
id|wait
(braket
l_int|2
)braket
comma
op_star
op_star
id|wait_bh
op_assign
id|wait
suffix:semicolon
r_int
r_int
id|vcn_ofs
comma
id|block_start
comma
id|block_end
comma
id|blocksize
suffix:semicolon
r_int
id|err
suffix:semicolon
id|BOOL
id|is_retry
suffix:semicolon
r_int
r_char
id|blocksize_bits
suffix:semicolon
id|vi
op_assign
id|page-&gt;mapping-&gt;host
suffix:semicolon
id|ni
op_assign
id|NTFS_I
c_func
(paren
id|vi
)paren
suffix:semicolon
id|vol
op_assign
id|ni-&gt;vol
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Entering for inode %li, attribute type 0x%x, page index &quot;
l_string|&quot;0x%lx, from = %u, to = %u.&quot;
comma
id|vi-&gt;i_ino
comma
id|ni-&gt;type
comma
id|page-&gt;index
comma
id|from
comma
id|to
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|NInoNonResident
c_func
(paren
id|ni
)paren
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|NInoMstProtected
c_func
(paren
id|ni
)paren
)paren
suffix:semicolon
id|blocksize_bits
op_assign
id|vi-&gt;i_blkbits
suffix:semicolon
id|blocksize
op_assign
l_int|1
op_lshift
id|blocksize_bits
suffix:semicolon
multiline_comment|/*&n;&t; * create_empty_buffers() will create uptodate/dirty buffers if the&n;&t; * page is uptodate/dirty.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|page_has_buffers
c_func
(paren
id|page
)paren
)paren
id|create_empty_buffers
c_func
(paren
id|page
comma
id|blocksize
comma
l_int|0
)paren
suffix:semicolon
id|bh
op_assign
id|head
op_assign
id|page_buffers
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|bh
)paren
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
multiline_comment|/* The first block in the page. */
id|block
op_assign
id|page-&gt;index
op_lshift
(paren
id|PAGE_CACHE_SHIFT
op_minus
id|blocksize_bits
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * The first out of bounds block for the allocated size. No need to&n;&t; * round up as allocated_size is in multiples of cluster size and the&n;&t; * minimum cluster size is 512 bytes, which is equal to the smallest&n;&t; * blocksize.&n;&t; */
id|ablock
op_assign
id|ni-&gt;allocated_size
op_rshift
id|blocksize_bits
suffix:semicolon
multiline_comment|/* The last (fully or partially) initialized block. */
id|iblock
op_assign
id|ni-&gt;initialized_size
op_rshift
id|blocksize_bits
suffix:semicolon
multiline_comment|/* Loop through all the buffers in the page. */
id|block_start
op_assign
l_int|0
suffix:semicolon
id|rl
op_assign
l_int|NULL
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
r_do
(brace
id|block_end
op_assign
id|block_start
op_plus
id|blocksize
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If buffer @bh is outside the write, just mark it uptodate&n;&t;&t; * if the page is uptodate and continue with the next buffer.&n;&t;&t; */
r_if
c_cond
(paren
id|block_end
op_le
id|from
op_logical_or
id|block_start
op_ge
id|to
)paren
(brace
r_if
c_cond
(paren
id|PageUptodate
c_func
(paren
id|page
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|bh
)paren
)paren
id|set_buffer_uptodate
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * @bh is at least partially being written to.&n;&t;&t; * Make sure it is not marked as new.&n;&t;&t; */
singleline_comment|//if (buffer_new(bh))
singleline_comment|//&t;clear_buffer_new(bh);
r_if
c_cond
(paren
id|block
op_ge
id|ablock
)paren
(brace
singleline_comment|// TODO: block is above allocated_size, need to
singleline_comment|// allocate it. Best done in one go to accommodate not
singleline_comment|// only block but all above blocks up to and including:
singleline_comment|// ((page-&gt;index &lt;&lt; PAGE_CACHE_SHIFT) + to + blocksize
singleline_comment|// - 1) &gt;&gt; blobksize_bits. Obviously will need to round
singleline_comment|// up to next cluster boundary, too. This should be
singleline_comment|// done with a helper function, so it can be reused.
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Writing beyond allocated size &quot;
l_string|&quot;is not supported yet. Sorry.&quot;
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EOPNOTSUPP
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
singleline_comment|// Need to update ablock.
singleline_comment|// Need to set_buffer_new() on all block bhs that are
singleline_comment|// newly allocated.
)brace
multiline_comment|/*&n;&t;&t; * Now we have enough allocated size to fulfill the whole&n;&t;&t; * request, i.e. block &lt; ablock is true.&n;&t;&t; */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
(paren
id|block
op_ge
id|iblock
)paren
op_logical_and
(paren
id|ni-&gt;initialized_size
OL
id|vi-&gt;i_size
)paren
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * If this page is fully outside initialized size, zero&n;&t;&t;&t; * out all pages between the current initialized size&n;&t;&t;&t; * and the current page. Just use ntfs_readpage() to do&n;&t;&t;&t; * the zeroing transparently.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|block
OG
id|iblock
)paren
(brace
singleline_comment|// TODO:
singleline_comment|// For each page do:
singleline_comment|// - read_cache_page()
singleline_comment|// Again for each page do:
singleline_comment|// - wait_on_page_locked()
singleline_comment|// - Check (PageUptodate(page) &amp;&amp;
singleline_comment|//&t;&t;&t;!PageError(page))
singleline_comment|// Update initialized size in the attribute and
singleline_comment|// in the inode.
singleline_comment|// Again, for each page do:
singleline_comment|//&t;__set_page_dirty_buffers();
singleline_comment|// page_cache_release()
singleline_comment|// We don&squot;t need to wait on the writes.
singleline_comment|// Update iblock.
)brace
multiline_comment|/*&n;&t;&t;&t; * The current page straddles initialized size. Zero&n;&t;&t;&t; * all non-uptodate buffers and set them uptodate (and&n;&t;&t;&t; * dirty?). Note, there aren&squot;t any non-uptodate buffers&n;&t;&t;&t; * if the page is uptodate.&n;&t;&t;&t; * FIXME: For an uptodate page, the buffers may need to&n;&t;&t;&t; * be written out because they were not initialized on&n;&t;&t;&t; * disk before.&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|PageUptodate
c_func
(paren
id|page
)paren
)paren
(brace
singleline_comment|// TODO:
singleline_comment|// Zero any non-uptodate buffers up to i_size.
singleline_comment|// Set them uptodate and dirty.
)brace
singleline_comment|// TODO:
singleline_comment|// Update initialized size in the attribute and in the
singleline_comment|// inode (up to i_size).
singleline_comment|// Update iblock.
singleline_comment|// FIXME: This is inefficient. Try to batch the two
singleline_comment|// size changes to happen in one go.
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Writing beyond initialized size &quot;
l_string|&quot;is not supported yet. Sorry.&quot;
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EOPNOTSUPP
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
singleline_comment|// Do NOT set_buffer_new() BUT DO clear buffer range
singleline_comment|// outside write request range.
singleline_comment|// set_buffer_uptodate() on complete buffers as well as
singleline_comment|// set_buffer_dirty().
)brace
multiline_comment|/* Need to map unmapped buffers. */
r_if
c_cond
(paren
op_logical_neg
id|buffer_mapped
c_func
(paren
id|bh
)paren
)paren
(brace
multiline_comment|/* Unmapped buffer. Need to map it. */
id|bh-&gt;b_bdev
op_assign
id|vol-&gt;sb-&gt;s_bdev
suffix:semicolon
multiline_comment|/* Convert block into corresponding vcn and offset. */
id|vcn
op_assign
(paren
id|VCN
)paren
id|block
op_lshift
id|blocksize_bits
op_rshift
id|vol-&gt;cluster_size_bits
suffix:semicolon
id|vcn_ofs
op_assign
(paren
(paren
id|VCN
)paren
id|block
op_lshift
id|blocksize_bits
)paren
op_amp
id|vol-&gt;cluster_size_mask
suffix:semicolon
id|is_retry
op_assign
id|FALSE
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rl
)paren
(brace
id|lock_retry_remap
suffix:colon
id|down_read
c_func
(paren
op_amp
id|ni-&gt;run_list.lock
)paren
suffix:semicolon
id|rl
op_assign
id|ni-&gt;run_list.rl
suffix:semicolon
)brace
r_if
c_cond
(paren
id|likely
c_func
(paren
id|rl
op_ne
l_int|NULL
)paren
)paren
(brace
multiline_comment|/* Seek to element containing target vcn. */
r_while
c_loop
(paren
id|rl-&gt;length
op_logical_and
id|rl
(braket
l_int|1
)braket
dot
id|vcn
op_le
id|vcn
)paren
id|rl
op_increment
suffix:semicolon
id|lcn
op_assign
id|vcn_to_lcn
c_func
(paren
id|rl
comma
id|vcn
)paren
suffix:semicolon
)brace
r_else
id|lcn
op_assign
(paren
id|LCN
)paren
id|LCN_RL_NOT_MAPPED
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|lcn
OL
l_int|0
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * We extended the attribute allocation above.&n;&t;&t;&t;&t; * If we hit an ENOENT here it means that the&n;&t;&t;&t;&t; * allocation was insufficient which is a bug.&n;&t;&t;&t;&t; */
id|BUG_ON
c_func
(paren
id|lcn
op_eq
id|LCN_ENOENT
)paren
suffix:semicolon
multiline_comment|/* It is a hole, need to instantiate it. */
r_if
c_cond
(paren
id|lcn
op_eq
id|LCN_HOLE
)paren
(brace
singleline_comment|// TODO: Instantiate the hole.
singleline_comment|// clear_buffer_new(bh);
singleline_comment|// unmap_underlying_metadata(bh-&gt;b_bdev,
singleline_comment|//&t;&t;bh-&gt;b_blocknr);
singleline_comment|// For non-uptodate buffers, need to
singleline_comment|// zero out the region outside the
singleline_comment|// request in this bh or all bhs,
singleline_comment|// depending on what we implemented
singleline_comment|// above.
singleline_comment|// Need to flush_dcache_page().
singleline_comment|// Or could use set_buffer_new()
singleline_comment|// instead?
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Writing into &quot;
l_string|&quot;sparse regions is &quot;
l_string|&quot;not supported yet. &quot;
l_string|&quot;Sorry.&quot;
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EOPNOTSUPP
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|is_retry
op_logical_and
id|lcn
op_eq
id|LCN_RL_NOT_MAPPED
)paren
(brace
id|is_retry
op_assign
id|TRUE
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t;&t; * Attempt to map run list, dropping&n;&t;&t;&t;&t;&t; * lock for the duration.&n;&t;&t;&t;&t;&t; */
id|up_read
c_func
(paren
op_amp
id|ni-&gt;run_list.lock
)paren
suffix:semicolon
id|err
op_assign
id|map_run_list
c_func
(paren
id|ni
comma
id|vcn
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
op_logical_neg
id|err
)paren
)paren
r_goto
id|lock_retry_remap
suffix:semicolon
id|rl
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t;&t; * Failed to map the buffer, even after&n;&t;&t;&t;&t; * retrying.&n;&t;&t;&t;&t; */
id|bh-&gt;b_blocknr
op_assign
op_minus
l_int|1UL
suffix:semicolon
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;vcn_to_lcn(vcn = 0x%Lx) &quot;
l_string|&quot;failed with error code &quot;
l_string|&quot;0x%Lx%s.&quot;
comma
(paren
r_int
r_int
)paren
id|vcn
comma
(paren
r_int
r_int
)paren
op_minus
id|lcn
comma
id|is_retry
ques
c_cond
l_string|&quot; even after retrying&quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
singleline_comment|// FIXME: Depending on vol-&gt;on_errors, do
singleline_comment|// something.
r_if
c_cond
(paren
op_logical_neg
id|err
)paren
id|err
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
multiline_comment|/* We now have a successful remap, i.e. lcn &gt;= 0. */
multiline_comment|/* Setup buffer head to correct block. */
id|bh-&gt;b_blocknr
op_assign
(paren
(paren
id|lcn
op_lshift
id|vol-&gt;cluster_size_bits
)paren
op_plus
id|vcn_ofs
)paren
op_rshift
id|blocksize_bits
suffix:semicolon
id|set_buffer_mapped
c_func
(paren
id|bh
)paren
suffix:semicolon
singleline_comment|// FIXME: Something analogous to this is needed for
singleline_comment|// each newly allocated block, i.e. BH_New.
singleline_comment|// FIXME: Might need to take this out of the
singleline_comment|// if (!buffer_mapped(bh)) {}, depending on how we
singleline_comment|// implement things during the allocated_size and
singleline_comment|// initialized_size extension code above.
r_if
c_cond
(paren
id|buffer_new
c_func
(paren
id|bh
)paren
)paren
(brace
id|clear_buffer_new
c_func
(paren
id|bh
)paren
suffix:semicolon
id|unmap_underlying_metadata
c_func
(paren
id|bh-&gt;b_bdev
comma
id|bh-&gt;b_blocknr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PageUptodate
c_func
(paren
id|page
)paren
)paren
(brace
id|set_buffer_uptodate
c_func
(paren
id|bh
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t;&t; * Page is _not_ uptodate, zero surrounding&n;&t;&t;&t;&t; * region. NOTE: This is how we decide if to&n;&t;&t;&t;&t; * zero or not!&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|block_end
OG
id|to
op_logical_or
id|block_start
OL
id|from
)paren
(brace
r_void
op_star
id|kaddr
suffix:semicolon
id|kaddr
op_assign
id|kmap_atomic
c_func
(paren
id|page
comma
id|KM_USER0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|block_end
OG
id|to
)paren
id|memset
c_func
(paren
id|kaddr
op_plus
id|to
comma
l_int|0
comma
id|block_end
op_minus
id|to
)paren
suffix:semicolon
r_if
c_cond
(paren
id|block_start
OL
id|from
)paren
id|memset
c_func
(paren
id|kaddr
op_plus
id|block_start
comma
l_int|0
comma
id|from
op_minus
id|block_start
)paren
suffix:semicolon
id|flush_dcache_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|kunmap_atomic
c_func
(paren
id|kaddr
comma
id|KM_USER0
)paren
suffix:semicolon
)brace
r_continue
suffix:semicolon
)brace
)brace
multiline_comment|/* @bh is mapped, set it uptodate if the page is uptodate. */
r_if
c_cond
(paren
id|PageUptodate
c_func
(paren
id|page
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|bh
)paren
)paren
id|set_buffer_uptodate
c_func
(paren
id|bh
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * The page is not uptodate. The buffer is mapped. If it is not&n;&t;&t; * uptodate, and it is only partially being written to, we need&n;&t;&t; * to read the buffer in before the write, i.e. right now.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|bh
)paren
op_logical_and
(paren
id|block_start
template_param
id|to
)paren
)paren
(brace
id|ll_rw_block
c_func
(paren
id|READ
comma
l_int|1
comma
op_amp
id|bh
)paren
suffix:semicolon
op_star
id|wait_bh
op_increment
op_assign
id|bh
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|block
op_increment
comma
id|block_start
op_assign
id|block_end
comma
(paren
id|bh
op_assign
id|bh-&gt;b_this_page
)paren
op_ne
id|head
)paren
suffix:semicolon
multiline_comment|/* Release the lock if we took it. */
r_if
c_cond
(paren
id|rl
)paren
(brace
id|up_read
c_func
(paren
op_amp
id|ni-&gt;run_list.lock
)paren
suffix:semicolon
id|rl
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* If we issued read requests, let them complete. */
r_while
c_loop
(paren
id|wait_bh
OG
id|wait
)paren
(brace
id|wait_on_buffer
c_func
(paren
op_star
op_decrement
id|wait_bh
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
op_star
id|wait_bh
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Done.&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|err_out
suffix:colon
multiline_comment|/*&n;&t; * Zero out any newly allocated blocks to avoid exposing stale data.&n;&t; * If BH_New is set, we know that the block was newly allocated in the&n;&t; * above loop.&n;&t; * FIXME: What about initialized_size increments? Have we done all the&n;&t; * required zeroing above? If not this error handling is broken, and&n;&t; * in particular the if (block_end &lt;= from) check is completely bogus.&n;&t; */
id|bh
op_assign
id|head
suffix:semicolon
id|block_start
op_assign
l_int|0
suffix:semicolon
id|is_retry
op_assign
id|FALSE
suffix:semicolon
r_do
(brace
id|block_end
op_assign
id|block_start
op_plus
id|blocksize
suffix:semicolon
r_if
c_cond
(paren
id|block_end
op_le
id|from
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|block_start
op_ge
id|to
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|buffer_new
c_func
(paren
id|bh
)paren
)paren
(brace
r_void
op_star
id|kaddr
suffix:semicolon
id|clear_buffer_new
c_func
(paren
id|bh
)paren
suffix:semicolon
id|kaddr
op_assign
id|kmap_atomic
c_func
(paren
id|page
comma
id|KM_USER0
)paren
suffix:semicolon
id|memset
c_func
(paren
id|kaddr
op_plus
id|block_start
comma
l_int|0
comma
id|bh-&gt;b_size
)paren
suffix:semicolon
id|kunmap_atomic
c_func
(paren
id|kaddr
comma
id|KM_USER0
)paren
suffix:semicolon
id|set_buffer_uptodate
c_func
(paren
id|bh
)paren
suffix:semicolon
id|mark_buffer_dirty
c_func
(paren
id|bh
)paren
suffix:semicolon
id|is_retry
op_assign
id|TRUE
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|block_start
op_assign
id|block_end
comma
(paren
id|bh
op_assign
id|bh-&gt;b_this_page
)paren
op_ne
id|head
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_retry
)paren
id|flush_dcache_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rl
)paren
id|up_read
c_func
(paren
op_amp
id|ni-&gt;run_list.lock
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_prepare_write - prepare a page for receiving data&n; *&n; * This is called from generic_file_write() with i_sem held on the inode&n; * (@page-&gt;mapping-&gt;host). The @page is locked and kmap()ped so page_address()&n; * can simply be used. The source data has not yet been copied into the @page.&n; *&n; * Need to extend the attribute/fill in holes if necessary, create blocks and&n; * make partially overwritten blocks uptodate,&n; *&n; * i_size is not to be modified yet.&n; *&n; * Return 0 on success or -errno on error.&n; *&n; * Should be using block_prepare_write() [support for sparse files] or&n; * cont_prepare_write() [no support for sparse files]. Can&squot;t do that due to&n; * ntfs specifics but can look at them for implementation guidancea.&n; *&n; * Note: In the range, @from is inclusive and @to is exclusive, i.e. @from is&n; * the first byte in the page that will be written to and @to is the first byte&n; * after the last byte that will be written to.&n; */
DECL|function|ntfs_prepare_write
r_static
r_int
id|ntfs_prepare_write
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_struct
id|page
op_star
id|page
comma
r_int
id|from
comma
r_int
id|to
)paren
(brace
r_struct
id|inode
op_star
id|vi
op_assign
id|page-&gt;mapping-&gt;host
suffix:semicolon
id|ntfs_inode
op_star
id|ni
op_assign
id|NTFS_I
c_func
(paren
id|vi
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Entering for inode %li, attribute type 0x%x, page index &quot;
l_string|&quot;0x%lx, from = %u, to = %u.&quot;
comma
id|vi-&gt;i_ino
comma
id|ni-&gt;type
comma
id|page-&gt;index
comma
id|from
comma
id|to
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|PageLocked
c_func
(paren
id|page
)paren
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|from
OG
id|PAGE_CACHE_SIZE
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|to
OG
id|PAGE_CACHE_SIZE
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|from
OG
id|to
)paren
suffix:semicolon
r_if
c_cond
(paren
id|NInoNonResident
c_func
(paren
id|ni
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * Only unnamed $DATA attributes can be compressed, encrypted,&n;&t;&t; * and/or sparse.&n;&t;&t; */
r_if
c_cond
(paren
id|ni-&gt;type
op_eq
id|AT_DATA
op_logical_and
op_logical_neg
id|ni-&gt;name_len
)paren
(brace
multiline_comment|/* If file is encrypted, deny access, just like NT4. */
r_if
c_cond
(paren
id|NInoEncrypted
c_func
(paren
id|ni
)paren
)paren
(brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Denying write access to encrypted &quot;
l_string|&quot;file.&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EACCES
suffix:semicolon
)brace
multiline_comment|/* Compressed data streams are handled in compress.c. */
r_if
c_cond
(paren
id|NInoCompressed
c_func
(paren
id|ni
)paren
)paren
(brace
singleline_comment|// TODO: Implement and replace this check with
singleline_comment|// return ntfs_write_compressed_block(page);
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Writing to compressed &quot;
l_string|&quot;files is not supported yet. &quot;
l_string|&quot;Sorry.&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
singleline_comment|// TODO: Implement and remove this check.
r_if
c_cond
(paren
id|NInoSparse
c_func
(paren
id|ni
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Writing to sparse files &quot;
l_string|&quot;is not supported yet. Sorry.&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
)brace
singleline_comment|// TODO: Implement and remove this check.
r_if
c_cond
(paren
id|NInoMstProtected
c_func
(paren
id|ni
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Writing to MST protected &quot;
l_string|&quot;attributes is not supported yet. &quot;
l_string|&quot;Sorry.&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
multiline_comment|/* Normal data stream. */
r_return
id|ntfs_prepare_nonresident_write
c_func
(paren
id|page
comma
id|from
comma
id|to
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Attribute is resident, implying it is not compressed, encrypted, or&n;&t; * mst protected.&n;&t; */
id|BUG_ON
c_func
(paren
id|page_has_buffers
c_func
(paren
id|page
)paren
)paren
suffix:semicolon
multiline_comment|/* Do we need to resize the attribute? */
r_if
c_cond
(paren
(paren
(paren
id|s64
)paren
id|page-&gt;index
op_lshift
id|PAGE_CACHE_SHIFT
)paren
op_plus
id|to
OG
id|vi-&gt;i_size
)paren
(brace
singleline_comment|// TODO: Implement resize...
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Writing beyond the existing file size is &quot;
l_string|&quot;not supported yet. Sorry.&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Because resident attributes are handled by memcpy() to/from the&n;&t; * corresponding MFT record, and because this form of i/o is byte&n;&t; * aligned rather than block aligned, there is no need to bring the&n;&t; * page uptodate here as in the non-resident case where we need to&n;&t; * bring the buffers straddled by the write uptodate before&n;&t; * generic_file_write() does the copying from userspace.&n;&t; *&n;&t; * We thus defer the uptodate bringing of the page region outside the&n;&t; * region written to to ntfs_commit_write(). The reason for doing this&n;&t; * is that we save one round of:&n;&t; *&t;map_mft_record(), get_attr_search_ctx(), lookup_attr(),&n;&t; *&t;kmap_atomic(), kunmap_atomic(), put_attr_search_ctx(),&n;&t; *&t;unmap_mft_record().&n;&t; * Which is obviously a very worthwhile save.&n;&t; *&n;&t; * Thus we just return success now...&n;&t; */
id|ntfs_debug
c_func
(paren
l_string|&quot;Done.&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * NOTES: There is a disparity between the apparent need to extend the&n; * attribute in prepare write but to update i_size only in commit write.&n; * Need to make sure i_sem protection is sufficient. And if not will need to&n; * handle this in some way or another.&n; */
multiline_comment|/**&n; * ntfs_commit_nonresident_write -&n; *&n; */
DECL|function|ntfs_commit_nonresident_write
r_static
r_int
id|ntfs_commit_nonresident_write
c_func
(paren
r_struct
id|page
op_star
id|page
comma
r_int
id|from
comma
r_int
id|to
)paren
(brace
id|s64
id|pos
op_assign
(paren
(paren
id|s64
)paren
id|page-&gt;index
op_lshift
id|PAGE_CACHE_SHIFT
)paren
op_plus
id|to
suffix:semicolon
r_struct
id|inode
op_star
id|vi
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
comma
op_star
id|head
suffix:semicolon
r_int
r_int
id|block_start
comma
id|block_end
comma
id|blocksize
suffix:semicolon
id|BOOL
id|partial
suffix:semicolon
id|vi
op_assign
id|page-&gt;mapping-&gt;host
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Entering for inode %li, attribute type 0x%x, page index &quot;
l_string|&quot;0x%lx, from = %u, to = %u.&quot;
comma
id|vi-&gt;i_ino
comma
id|NTFS_I
c_func
(paren
id|vi
)paren
op_member_access_from_pointer
id|type
comma
id|page-&gt;index
comma
id|from
comma
id|to
)paren
suffix:semicolon
id|blocksize
op_assign
l_int|1
op_lshift
id|vi-&gt;i_blkbits
suffix:semicolon
singleline_comment|// FIXME: We need a whole slew of special cases in here for MST
singleline_comment|// protected attributes for example. For compressed files, too...
singleline_comment|// For now, we know ntfs_prepare_write() would have failed so we can&squot;t
singleline_comment|// get here in any of the cases which we have to special case, so we
singleline_comment|// are just a ripped off unrolled generic_commit_write() at present.
id|bh
op_assign
id|head
op_assign
id|page_buffers
c_func
(paren
id|page
)paren
suffix:semicolon
id|block_start
op_assign
l_int|0
suffix:semicolon
id|partial
op_assign
id|FALSE
suffix:semicolon
r_do
(brace
id|block_end
op_assign
id|block_start
op_plus
id|blocksize
suffix:semicolon
r_if
c_cond
(paren
id|block_end
op_le
id|from
op_logical_or
id|block_start
op_ge
id|to
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|bh
)paren
)paren
id|partial
op_assign
id|TRUE
suffix:semicolon
)brace
r_else
(brace
id|set_buffer_uptodate
c_func
(paren
id|bh
)paren
suffix:semicolon
id|mark_buffer_dirty
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|block_start
op_assign
id|block_end
comma
(paren
id|bh
op_assign
id|bh-&gt;b_this_page
)paren
op_ne
id|head
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If this is a partial write which happened to make all buffers&n;&t; * uptodate then we can optimize away a bogus -&gt;readpage() for the next&n;&t; * read(). Here we &squot;discover&squot; whether the page went uptodate as a&n;&t; * result of this (potentially partial) write.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|partial
)paren
id|SetPageUptodate
c_func
(paren
id|page
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Not convinced about this at all. See disparity comment above. For&n;&t; * now we know ntfs_prepare_write() would have failed in the write&n;&t; * exceeds i_size case, so this will never trigger which is fine.&n;&t; */
r_if
c_cond
(paren
id|pos
OG
id|vi-&gt;i_size
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Writing beyond the existing file size is &quot;
l_string|&quot;not supported yet. Sorry.&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
singleline_comment|// vi-&gt;i_size = pos;
singleline_comment|// mark_inode_dirty(vi);
)brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Done.&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_commit_write - commit the received data&n; *&n; * This is called from generic_file_write() with i_sem held on the inode&n; * (@page-&gt;mapping-&gt;host). The @page is locked and kmap()ped so page_address()&n; * can simply be used. The source data has already been copied into the @page.&n; *&n; * Need to mark modified blocks dirty so they get written out later when&n; * ntfs_writepage() is invoked by the VM.&n; *&n; * Return 0 on success or -errno on error.&n; *&n; * Should be using generic_commit_write(). This marks buffers uptodate and&n; * dirty, sets the page uptodate if all buffers in the page are uptodate, and&n; * updates i_size if the end of io is beyond i_size. In that case, it also&n; * marks the inode dirty. - We could still use this (obviously except for&n; * NInoMstProtected() attributes, where we will need to duplicate the core code&n; * because we need our own async_io completion handler) but we could just do&n; * the i_size update in prepare write, when we resize the attribute. Then&n; * we would avoid the i_size update and mark_inode_dirty() happening here.&n; *&n; * Can&squot;t use generic_commit_write() due to ntfs specialities but can look at&n; * it for implementation guidance.&n; *&n; * If things have gone as outlined in ntfs_prepare_write(), then we do not&n; * need to do any page content modifications here at all, except in the write&n; * to resident attribute case, where we need to do the uptodate bringing here&n; * which we combine with the copying into the mft record which means we only&n; * need to map the mft record and find the attribute record in it only once.&n; */
DECL|function|ntfs_commit_write
r_static
r_int
id|ntfs_commit_write
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_struct
id|page
op_star
id|page
comma
r_int
id|from
comma
r_int
id|to
)paren
(brace
id|s64
id|attr_pos
suffix:semicolon
r_struct
id|inode
op_star
id|vi
suffix:semicolon
id|ntfs_inode
op_star
id|ni
comma
op_star
id|base_ni
suffix:semicolon
r_char
op_star
id|kaddr
comma
op_star
id|kattr
suffix:semicolon
id|attr_search_context
op_star
id|ctx
suffix:semicolon
id|MFT_RECORD
op_star
id|m
suffix:semicolon
id|u32
id|attr_len
comma
id|bytes
suffix:semicolon
r_int
id|err
suffix:semicolon
id|vi
op_assign
id|page-&gt;mapping-&gt;host
suffix:semicolon
id|ni
op_assign
id|NTFS_I
c_func
(paren
id|vi
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Entering for inode %li, attribute type 0x%x, page index &quot;
l_string|&quot;0x%lx, from = %u, to = %u.&quot;
comma
id|vi-&gt;i_ino
comma
id|ni-&gt;type
comma
id|page-&gt;index
comma
id|from
comma
id|to
)paren
suffix:semicolon
r_if
c_cond
(paren
id|NInoNonResident
c_func
(paren
id|ni
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * Only unnamed $DATA attributes can be compressed, encrypted,&n;&t;&t; * and/or sparse.&n;&t;&t; */
r_if
c_cond
(paren
id|ni-&gt;type
op_eq
id|AT_DATA
op_logical_and
op_logical_neg
id|ni-&gt;name_len
)paren
(brace
multiline_comment|/* If file is encrypted, deny access, just like NT4. */
r_if
c_cond
(paren
id|NInoEncrypted
c_func
(paren
id|ni
)paren
)paren
(brace
singleline_comment|// Should never get here!
id|ntfs_debug
c_func
(paren
l_string|&quot;Denying write access to encrypted &quot;
l_string|&quot;file.&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EACCES
suffix:semicolon
)brace
multiline_comment|/* Compressed data streams are handled in compress.c. */
r_if
c_cond
(paren
id|NInoCompressed
c_func
(paren
id|ni
)paren
)paren
(brace
singleline_comment|// TODO: Implement and replace this check with
singleline_comment|// return ntfs_write_compressed_block(page);
singleline_comment|// Should never get here!
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Writing to compressed &quot;
l_string|&quot;files is not supported yet. &quot;
l_string|&quot;Sorry.&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
singleline_comment|// TODO: Implement and remove this check.
r_if
c_cond
(paren
id|NInoSparse
c_func
(paren
id|ni
)paren
)paren
(brace
singleline_comment|// Should never get here!
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Writing to sparse files &quot;
l_string|&quot;is not supported yet. Sorry.&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
)brace
singleline_comment|// TODO: Implement and remove this check.
r_if
c_cond
(paren
id|NInoMstProtected
c_func
(paren
id|ni
)paren
)paren
(brace
singleline_comment|// Should never get here!
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Writing to MST protected &quot;
l_string|&quot;attributes is not supported yet. &quot;
l_string|&quot;Sorry.&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
multiline_comment|/* Normal data stream. */
r_return
id|ntfs_commit_nonresident_write
c_func
(paren
id|page
comma
id|from
comma
id|to
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Attribute is resident, implying it is not compressed, encrypted, or&n;&t; * mst protected.&n;&t; */
multiline_comment|/* Do we need to resize the attribute? */
r_if
c_cond
(paren
(paren
(paren
id|s64
)paren
id|page-&gt;index
op_lshift
id|PAGE_CACHE_SHIFT
)paren
op_plus
id|to
OG
id|vi-&gt;i_size
)paren
(brace
singleline_comment|// TODO: Implement resize...
singleline_comment|// pos = ((s64)page-&gt;index &lt;&lt; PAGE_CACHE_SHIFT) + to;
singleline_comment|// vi-&gt;i_size = pos;
singleline_comment|// mark_inode_dirty(vi);
singleline_comment|// Should never get here!
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Writing beyond the existing file size is &quot;
l_string|&quot;not supported yet. Sorry.&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|NInoAttr
c_func
(paren
id|ni
)paren
)paren
id|base_ni
op_assign
id|ni
suffix:semicolon
r_else
id|base_ni
op_assign
id|ni-&gt;ext.base_ntfs_ino
suffix:semicolon
multiline_comment|/* Map, pin, and lock the mft record. */
id|m
op_assign
id|map_mft_record
c_func
(paren
id|base_ni
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|IS_ERR
c_func
(paren
id|m
)paren
)paren
)paren
(brace
id|err
op_assign
id|PTR_ERR
c_func
(paren
id|m
)paren
suffix:semicolon
id|m
op_assign
l_int|NULL
suffix:semicolon
id|ctx
op_assign
l_int|NULL
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
id|ctx
op_assign
id|get_attr_search_ctx
c_func
(paren
id|base_ni
comma
id|m
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|ctx
)paren
)paren
(brace
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|lookup_attr
c_func
(paren
id|ni-&gt;type
comma
id|ni-&gt;name
comma
id|ni-&gt;name_len
comma
id|IGNORE_CASE
comma
l_int|0
comma
l_int|NULL
comma
l_int|0
comma
id|ctx
)paren
)paren
)paren
(brace
id|err
op_assign
op_minus
id|ENOENT
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
multiline_comment|/* Starting position of the page within the attribute value. */
id|attr_pos
op_assign
id|page-&gt;index
op_lshift
id|PAGE_CACHE_SHIFT
suffix:semicolon
multiline_comment|/* The total length of the attribute value. */
id|attr_len
op_assign
id|le32_to_cpu
c_func
(paren
id|ctx-&gt;attr-&gt;data.resident.value_length
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|vi-&gt;i_size
op_ne
id|attr_len
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;BUG()! i_size (0x%Lx) doesn&squot;t match &quot;
l_string|&quot;attr_len (0x%x). Aborting write.&quot;
comma
id|vi-&gt;i_size
comma
id|attr_len
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|attr_pos
op_ge
id|attr_len
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;BUG()! attr_pos (0x%Lx) &gt; attr_len (0x%x)&quot;
l_string|&quot;. Aborting write.&quot;
comma
id|attr_pos
comma
id|attr_len
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
id|bytes
op_assign
id|attr_len
op_minus
id|attr_pos
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|bytes
OG
id|PAGE_CACHE_SIZE
)paren
)paren
id|bytes
op_assign
id|PAGE_CACHE_SIZE
suffix:semicolon
multiline_comment|/*&n;&t; * Calculate the address of the attribute value corresponding to the&n;&t; * beginning of the current data @page.&n;&t; */
id|kattr
op_assign
(paren
id|u8
op_star
)paren
id|ctx-&gt;attr
op_plus
id|le16_to_cpu
c_func
(paren
id|ctx-&gt;attr-&gt;data.resident.value_offset
)paren
op_plus
id|attr_pos
suffix:semicolon
id|kaddr
op_assign
id|kmap_atomic
c_func
(paren
id|page
comma
id|KM_USER0
)paren
suffix:semicolon
multiline_comment|/* Copy the received data from the page to the mft record. */
id|memcpy
c_func
(paren
id|kattr
op_plus
id|from
comma
id|kaddr
op_plus
id|from
comma
id|to
op_minus
id|from
)paren
suffix:semicolon
id|flush_dcache_mft_record_page
c_func
(paren
id|ctx-&gt;ntfs_ino
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|PageUptodate
c_func
(paren
id|page
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * Bring the out of bounds area(s) uptodate by copying data&n;&t;&t; * from the mft record to the page.&n;&t;&t; */
r_if
c_cond
(paren
id|from
OG
l_int|0
)paren
id|memcpy
c_func
(paren
id|kaddr
comma
id|kattr
comma
id|from
)paren
suffix:semicolon
r_if
c_cond
(paren
id|to
OL
id|bytes
)paren
id|memcpy
c_func
(paren
id|kaddr
op_plus
id|to
comma
id|kattr
op_plus
id|to
comma
id|bytes
op_minus
id|to
)paren
suffix:semicolon
multiline_comment|/* Zero the region outside the end of the attribute value. */
r_if
c_cond
(paren
id|likely
c_func
(paren
id|bytes
OL
id|PAGE_CACHE_SIZE
)paren
)paren
id|memset
c_func
(paren
id|kaddr
op_plus
id|bytes
comma
l_int|0
comma
id|PAGE_CACHE_SIZE
op_minus
id|bytes
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * The probability of not having done any of the above is&n;&t;&t; * extremely small, so we just flush unconditionally.&n;&t;&t; */
id|flush_dcache_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|SetPageUptodate
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
id|kunmap_atomic
c_func
(paren
id|kaddr
comma
id|KM_USER0
)paren
suffix:semicolon
singleline_comment|// TODO: Mark mft record dirty so it gets written back.
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Writing to resident files is not supported yet. &quot;
l_string|&quot;Wrote to memory only...&quot;
)paren
suffix:semicolon
id|put_attr_search_ctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
id|unmap_mft_record
c_func
(paren
id|base_ni
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Done.&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|err_out
suffix:colon
r_if
c_cond
(paren
id|err
op_eq
op_minus
id|ENOMEM
)paren
(brace
id|ntfs_warning
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Error allocating memory required to &quot;
l_string|&quot;commit the write.&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PageUptodate
c_func
(paren
id|page
)paren
)paren
(brace
id|ntfs_warning
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Page is uptodate, setting &quot;
l_string|&quot;dirty so the write will be retried &quot;
l_string|&quot;later on by the VM.&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Put the page on mapping-&gt;dirty_pages, but leave its&n;&t;&t;&t; * buffer&squot;s dirty state as-is.&n;&t;&t;&t; */
id|__set_page_dirty_nobuffers
c_func
(paren
id|page
)paren
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
)brace
r_else
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Page is not uptodate. Written &quot;
l_string|&quot;data has been lost. )-:&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Resident attribute write failed with &quot;
l_string|&quot;error %i. Setting page error flag.&quot;
comma
op_minus
id|err
)paren
suffix:semicolon
id|SetPageError
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ctx
)paren
id|put_attr_search_ctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|m
)paren
id|unmap_mft_record
c_func
(paren
id|base_ni
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
macro_line|#endif&t;/* NTFS_RW */
multiline_comment|/**&n; * ntfs_aops - general address space operations for inodes and attributes&n; */
DECL|variable|ntfs_aops
r_struct
id|address_space_operations
id|ntfs_aops
op_assign
(brace
dot
id|readpage
op_assign
id|ntfs_readpage
comma
multiline_comment|/* Fill page with data. */
dot
id|sync_page
op_assign
id|block_sync_page
comma
multiline_comment|/* Currently, just unplugs the&n;&t;&t;&t;&t;&t;&t;   disk request queue. */
macro_line|#ifdef NTFS_RW
dot
id|writepage
op_assign
id|ntfs_writepage
comma
multiline_comment|/* Write dirty page to disk. */
dot
id|prepare_write
op_assign
id|ntfs_prepare_write
comma
multiline_comment|/* Prepare page and buffers&n;&t;&t;&t;&t;&t;&t;   ready to receive data. */
dot
id|commit_write
op_assign
id|ntfs_commit_write
comma
multiline_comment|/* Commit received data. */
macro_line|#endif
)brace
suffix:semicolon
eof
