multiline_comment|/*&n; * index.h - Defines for NTFS kernel index handling.  Part of the Linux-NTFS&n; *&t;     project.&n; *&n; * Copyright (c) 2004 Anton Altaparmakov&n; *&n; * This program/include file is free software; you can redistribute it and/or&n; * modify it under the terms of the GNU General Public License as published&n; * by the Free Software Foundation; either version 2 of the License, or&n; * (at your option) any later version.&n; *&n; * This program/include file is distributed in the hope that it will be&n; * useful, but WITHOUT ANY WARRANTY; without even the implied warranty&n; * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; * GNU General Public License for more details.&n; *&n; * You should have received a copy of the GNU General Public License&n; * along with this program (in the main directory of the Linux-NTFS&n; * distribution in the file COPYING); if not, write to the Free Software&n; * Foundation,Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA&n; */
macro_line|#ifndef _LINUX_NTFS_INDEX_H
DECL|macro|_LINUX_NTFS_INDEX_H
mdefine_line|#define _LINUX_NTFS_INDEX_H
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &quot;types.h&quot;
macro_line|#include &quot;layout.h&quot;
macro_line|#include &quot;inode.h&quot;
macro_line|#include &quot;attrib.h&quot;
macro_line|#include &quot;mft.h&quot;
macro_line|#include &quot;aops.h&quot;
multiline_comment|/**&n; * @idx_ni:&t;index inode containing the @entry described by this context&n; * @entry:&t;index entry (points into @ir or @ia)&n; * @data:&t;index entry data (points into @entry)&n; * @data_len:&t;length in bytes of @data&n; * @is_in_root:&t;TRUE if @entry is in @ir and FALSE if it is in @ia&n; * @ir:&t;&t;index root if @is_in_root and NULL otherwise&n; * @actx:&t;attribute search context if @is_in_root and NULL otherwise&n; * @base_ni:&t;base inode if @is_in_root and NULL otherwise&n; * @ia:&t;&t;index block if @is_in_root is FALSE and NULL otherwise&n; * @page:&t;page if @is_in_root is FALSE and NULL otherwise&n; *&n; * @idx_ni is the index inode this context belongs to.&n; *&n; * @entry is the index entry described by this context.  @data and @data_len&n; * are the index entry data and its length in bytes, respectively.  @data&n; * simply points into @entry.  This is probably what the user is interested in.&n; *&n; * If @is_in_root is TRUE, @entry is in the index root attribute @ir described&n; * by the attribute search context @actx and the base inode @base_ni.  @ia and&n; * @page are NULL in this case.&n; *&n; * If @is_in_root is FALSE, @entry is in the index allocation attribute and @ia&n; * and @page point to the index allocation block and the mapped, locked page it&n; * is in, respectively.  @ir, @actx and @base_ni are NULL in this case.&n; *&n; * To obtain a context call ntfs_index_ctx_get().&n; *&n; * We use this context to allow ntfs_index_lookup() to return the found index&n; * @entry and its @data without having to allocate a buffer and copy the @entry&n; * and/or its @data into it.&n; *&n; * When finished with the @entry and its @data, call ntfs_index_ctx_put() to&n; * free the context and other associated resources.&n; *&n; * If the index entry was modified, call flush_dcache_index_entry_page()&n; * immediately after the modification and either ntfs_index_entry_mark_dirty()&n; * or ntfs_index_entry_write() before the call to ntfs_index_ctx_put() to&n; * ensure that the changes are written to disk.&n; */
r_typedef
r_struct
(brace
DECL|member|idx_ni
id|ntfs_inode
op_star
id|idx_ni
suffix:semicolon
DECL|member|entry
id|INDEX_ENTRY
op_star
id|entry
suffix:semicolon
DECL|member|data
r_void
op_star
id|data
suffix:semicolon
DECL|member|data_len
id|u16
id|data_len
suffix:semicolon
DECL|member|is_in_root
id|BOOL
id|is_in_root
suffix:semicolon
DECL|member|ir
id|INDEX_ROOT
op_star
id|ir
suffix:semicolon
DECL|member|actx
id|ntfs_attr_search_ctx
op_star
id|actx
suffix:semicolon
DECL|member|base_ni
id|ntfs_inode
op_star
id|base_ni
suffix:semicolon
DECL|member|ia
id|INDEX_ALLOCATION
op_star
id|ia
suffix:semicolon
DECL|member|page
r_struct
id|page
op_star
id|page
suffix:semicolon
DECL|typedef|ntfs_index_context
)brace
id|ntfs_index_context
suffix:semicolon
r_extern
id|ntfs_index_context
op_star
id|ntfs_index_ctx_get
c_func
(paren
id|ntfs_inode
op_star
id|idx_ni
)paren
suffix:semicolon
r_extern
r_void
id|ntfs_index_ctx_put
c_func
(paren
id|ntfs_index_context
op_star
id|ictx
)paren
suffix:semicolon
r_extern
r_int
id|ntfs_index_lookup
c_func
(paren
r_const
r_void
op_star
id|key
comma
r_const
r_int
id|key_len
comma
id|ntfs_index_context
op_star
id|ictx
)paren
suffix:semicolon
macro_line|#ifdef NTFS_RW
multiline_comment|/**&n; * ntfs_index_entry_flush_dcache_page - flush_dcache_page() for index entries&n; * @ictx:&t;ntfs index context describing the index entry&n; *&n; * Call flush_dcache_page() for the page in which an index entry resides.&n; *&n; * This must be called every time an index entry is modified, just after the&n; * modification.&n; *&n; * If the index entry is in the index root attribute, simply flush the page&n; * containing the mft record containing the index root attribute.&n; *&n; * If the index entry is in an index block belonging to the index allocation&n; * attribute, simply flush the page cache page containing the index block.&n; */
DECL|function|ntfs_index_entry_flush_dcache_page
r_static
r_inline
r_void
id|ntfs_index_entry_flush_dcache_page
c_func
(paren
id|ntfs_index_context
op_star
id|ictx
)paren
(brace
r_if
c_cond
(paren
id|ictx-&gt;is_in_root
)paren
id|flush_dcache_mft_record_page
c_func
(paren
id|ictx-&gt;actx-&gt;ntfs_ino
)paren
suffix:semicolon
r_else
id|flush_dcache_page
c_func
(paren
id|ictx-&gt;page
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_index_entry_mark_dirty - mark an index entry dirty&n; * @ictx:&t;ntfs index context describing the index entry&n; *&n; * Mark the index entry described by the index entry context @ictx dirty.&n; *&n; * If the index entry is in the index root attribute, simply mark the mft&n; * record containing the index root attribute dirty.  This ensures the mft&n; * record, and hence the index root attribute, will be written out to disk&n; * later.&n; *&n; * If the index entry is in an index block belonging to the index allocation&n; * attribute, mark the buffers belonging to the index record as well as the&n; * page cache page the index block is in dirty.  This automatically marks the&n; * VFS inode of the ntfs index inode to which the index entry belongs dirty,&n; * too (I_DIRTY_PAGES) and this in turn ensures the page buffers, and hence the&n; * dirty index block, will be written out to disk later.&n; */
DECL|function|ntfs_index_entry_mark_dirty
r_static
r_inline
r_void
id|ntfs_index_entry_mark_dirty
c_func
(paren
id|ntfs_index_context
op_star
id|ictx
)paren
(brace
r_if
c_cond
(paren
id|ictx-&gt;is_in_root
)paren
id|mark_mft_record_dirty
c_func
(paren
id|ictx-&gt;actx-&gt;ntfs_ino
)paren
suffix:semicolon
r_else
id|mark_ntfs_record_dirty
c_func
(paren
id|ictx-&gt;idx_ni
comma
id|ictx-&gt;page
comma
(paren
id|u8
op_star
)paren
id|ictx-&gt;ia
op_minus
(paren
id|u8
op_star
)paren
id|page_address
c_func
(paren
id|ictx-&gt;page
)paren
)paren
suffix:semicolon
)brace
macro_line|#endif /* NTFS_RW */
macro_line|#endif /* _LINUX_NTFS_INDEX_H */
eof
