multiline_comment|/*&n; * logfile.c - NTFS kernel journal handling. Part of the Linux-NTFS project.&n; *&n; * Copyright (c) 2002-2004 Anton Altaparmakov&n; *&n; * This program/include file is free software; you can redistribute it and/or&n; * modify it under the terms of the GNU General Public License as published&n; * by the Free Software Foundation; either version 2 of the License, or&n; * (at your option) any later version.&n; *&n; * This program/include file is distributed in the hope that it will be&n; * useful, but WITHOUT ANY WARRANTY; without even the implied warranty&n; * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; * GNU General Public License for more details.&n; *&n; * You should have received a copy of the GNU General Public License&n; * along with this program (in the main directory of the Linux-NTFS&n; * distribution in the file COPYING); if not, write to the Free Software&n; * Foundation,Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA&n; */
macro_line|#ifdef NTFS_RW
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/highmem.h&gt;
macro_line|#include &lt;linux/buffer_head.h&gt;
macro_line|#include &lt;linux/bitops.h&gt;
macro_line|#include &quot;logfile.h&quot;
macro_line|#include &quot;volume.h&quot;
macro_line|#include &quot;ntfs.h&quot;
macro_line|#include &quot;debug.h&quot;
multiline_comment|/**&n; * ntfs_check_restart_page_header - check the page header for consistency&n; * @vi:&t;&t;$LogFile inode to which the restart page header belongs&n; * @rp:&t;&t;restart page header to check&n; * @pos:&t;position in @vi at which the restart page header resides&n; *&n; * Check the restart page header @rp for consistency and return TRUE if it is&n; * consistent and FALSE otherwise.&n; *&n; * This function only needs NTFS_BLOCK_SIZE bytes in @rp, i.e. it does not&n; * require the full restart page.&n; */
DECL|function|ntfs_check_restart_page_header
r_static
id|BOOL
id|ntfs_check_restart_page_header
c_func
(paren
r_struct
id|inode
op_star
id|vi
comma
id|RESTART_PAGE_HEADER
op_star
id|rp
comma
id|s64
id|pos
)paren
(brace
id|u32
id|logfile_system_page_size
comma
id|logfile_log_page_size
suffix:semicolon
id|u16
id|usa_count
comma
id|usa_ofs
comma
id|usa_end
comma
id|ra_ofs
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Entering.&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If the system or log page sizes are smaller than the ntfs block size&n;&t; * or either is not a power of 2 we cannot handle this log file.&n;&t; */
id|logfile_system_page_size
op_assign
id|le32_to_cpu
c_func
(paren
id|rp-&gt;system_page_size
)paren
suffix:semicolon
id|logfile_log_page_size
op_assign
id|le32_to_cpu
c_func
(paren
id|rp-&gt;log_page_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|logfile_system_page_size
OL
id|NTFS_BLOCK_SIZE
op_logical_or
id|logfile_log_page_size
OL
id|NTFS_BLOCK_SIZE
op_logical_or
id|logfile_system_page_size
op_amp
(paren
id|logfile_system_page_size
op_minus
l_int|1
)paren
op_logical_or
id|logfile_log_page_size
op_amp
(paren
id|logfile_log_page_size
op_minus
l_int|1
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;$LogFile uses unsupported page size.&quot;
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * We must be either at !pos (1st restart page) or at pos = system page&n;&t; * size (2nd restart page).&n;&t; */
r_if
c_cond
(paren
id|pos
op_logical_and
id|pos
op_ne
id|logfile_system_page_size
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Found restart area in incorrect &quot;
l_string|&quot;position in $LogFile.&quot;
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
multiline_comment|/* We only know how to handle version 1.1. */
r_if
c_cond
(paren
id|sle16_to_cpu
c_func
(paren
id|rp-&gt;major_ver
)paren
op_ne
l_int|1
op_logical_or
id|sle16_to_cpu
c_func
(paren
id|rp-&gt;minor_ver
)paren
op_ne
l_int|1
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;$LogFile version %i.%i is not &quot;
l_string|&quot;supported.  (This driver supports version &quot;
l_string|&quot;1.1 only.)&quot;
comma
(paren
r_int
)paren
id|sle16_to_cpu
c_func
(paren
id|rp-&gt;major_ver
)paren
comma
(paren
r_int
)paren
id|sle16_to_cpu
c_func
(paren
id|rp-&gt;minor_ver
)paren
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
multiline_comment|/* Verify the size of the update sequence array. */
id|usa_count
op_assign
l_int|1
op_plus
(paren
id|logfile_system_page_size
op_rshift
id|NTFS_BLOCK_SIZE_BITS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|usa_count
op_ne
id|le16_to_cpu
c_func
(paren
id|rp-&gt;usa_count
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;$LogFile restart page specifies &quot;
l_string|&quot;inconsistent update sequence array count.&quot;
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
multiline_comment|/* Verify the position of the update sequence array. */
id|usa_ofs
op_assign
id|le16_to_cpu
c_func
(paren
id|rp-&gt;usa_ofs
)paren
suffix:semicolon
id|usa_end
op_assign
id|usa_ofs
op_plus
id|usa_count
op_star
r_sizeof
(paren
id|u16
)paren
suffix:semicolon
r_if
c_cond
(paren
id|usa_ofs
template_param
id|NTFS_BLOCK_SIZE
op_minus
r_sizeof
(paren
id|u16
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;$LogFile restart page specifies &quot;
l_string|&quot;inconsistent update sequence array offset.&quot;
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Verify the position of the restart area.  It must be:&n;&t; *&t;- aligned to 8-byte boundary,&n;&t; *&t;- after the update sequence array, and&n;&t; *&t;- within the system page size.&n;&t; */
id|ra_ofs
op_assign
id|le16_to_cpu
c_func
(paren
id|rp-&gt;restart_area_offset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ra_ofs
op_amp
l_int|7
op_logical_or
id|ra_ofs
template_param
id|logfile_system_page_size
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;$LogFile restart page specifies &quot;
l_string|&quot;inconsistent restart area offset.&quot;
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Only restart pages modified by chkdsk are allowed to have chkdsk_lsn&n;&t; * set.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|ntfs_is_chkd_record
c_func
(paren
id|rp-&gt;magic
)paren
op_logical_and
id|sle64_to_cpu
c_func
(paren
id|rp-&gt;chkdsk_lsn
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;$LogFile restart page is not modified &quot;
l_string|&quot;chkdsk but a chkdsk LSN is specified.&quot;
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Done.&quot;
)paren
suffix:semicolon
r_return
id|TRUE
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_check_restart_area - check the restart area for consistency&n; * @vi:&t;&t;$LogFile inode to which the restart page belongs&n; * @rp:&t;&t;restart page whose restart area to check&n; *&n; * Check the restart area of the restart page @rp for consistency and return&n; * TRUE if it is consistent and FALSE otherwise.&n; *&n; * This function assumes that the restart page header has already been&n; * consistency checked.&n; *&n; * This function only needs NTFS_BLOCK_SIZE bytes in @rp, i.e. it does not&n; * require the full restart page.&n; */
DECL|function|ntfs_check_restart_area
r_static
id|BOOL
id|ntfs_check_restart_area
c_func
(paren
r_struct
id|inode
op_star
id|vi
comma
id|RESTART_PAGE_HEADER
op_star
id|rp
)paren
(brace
id|u64
id|file_size
suffix:semicolon
id|RESTART_AREA
op_star
id|ra
suffix:semicolon
id|u16
id|ra_ofs
comma
id|ra_len
comma
id|ca_ofs
suffix:semicolon
id|u8
id|fs_bits
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Entering.&quot;
)paren
suffix:semicolon
id|ra_ofs
op_assign
id|le16_to_cpu
c_func
(paren
id|rp-&gt;restart_area_offset
)paren
suffix:semicolon
id|ra
op_assign
(paren
id|RESTART_AREA
op_star
)paren
(paren
(paren
id|u8
op_star
)paren
id|rp
op_plus
id|ra_ofs
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Everything before ra-&gt;file_size must be before the first word&n;&t; * protected by an update sequence number.  This ensures that it is&n;&t; * safe to access ra-&gt;client_array_offset.&n;&t; */
r_if
c_cond
(paren
id|ra_ofs
op_plus
m_offsetof
(paren
id|RESTART_AREA
comma
id|file_size
)paren
OG
id|NTFS_BLOCK_SIZE
op_minus
r_sizeof
(paren
id|u16
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;$LogFile restart area specifies &quot;
l_string|&quot;inconsistent file offset.&quot;
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Now that we can access ra-&gt;client_array_offset, make sure everything&n;&t; * up to the log client array is before the first word protected by an&n;&t; * update sequence number.  This ensures we can access all of the&n;&t; * restart area elements safely.  Also, the client array offset must be&n;&t; * aligned to an 8-byte boundary.&n;&t; */
id|ca_ofs
op_assign
id|le16_to_cpu
c_func
(paren
id|ra-&gt;client_array_offset
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|ca_ofs
op_plus
l_int|7
)paren
op_amp
op_complement
l_int|7
)paren
op_ne
id|ca_ofs
op_logical_or
id|ra_ofs
op_plus
id|ca_ofs
OG
id|NTFS_BLOCK_SIZE
op_minus
r_sizeof
(paren
id|u16
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;$LogFile restart area specifies &quot;
l_string|&quot;inconsistent client array offset.&quot;
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * The restart area must end within the system page size both when&n;&t; * calculated manually and as specified by ra-&gt;restart_area_length.&n;&t; * Also, the calculated length must not exceed the specified length.&n;&t; */
id|ra_len
op_assign
id|ca_ofs
op_plus
id|le16_to_cpu
c_func
(paren
id|ra-&gt;log_clients
)paren
op_star
r_sizeof
(paren
id|LOG_CLIENT_RECORD
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ra_ofs
op_plus
id|ra_len
OG
id|le32_to_cpu
c_func
(paren
id|rp-&gt;system_page_size
)paren
op_logical_or
id|ra_ofs
op_plus
id|le16_to_cpu
c_func
(paren
id|ra-&gt;restart_area_length
)paren
OG
id|le32_to_cpu
c_func
(paren
id|rp-&gt;system_page_size
)paren
op_logical_or
id|ra_len
OG
id|le16_to_cpu
c_func
(paren
id|ra-&gt;restart_area_length
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;$LogFile restart area is out of bounds &quot;
l_string|&quot;of the system page size specified by the &quot;
l_string|&quot;restart page header and/or the specified &quot;
l_string|&quot;restart area length is inconsistent.&quot;
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * The ra-&gt;client_free_list and ra-&gt;client_in_use_list must be either&n;&t; * LOGFILE_NO_CLIENT or less than ra-&gt;log_clients or they are&n;&t; * overflowing the client array.&n;&t; */
r_if
c_cond
(paren
(paren
id|ra-&gt;client_free_list
op_ne
id|LOGFILE_NO_CLIENT
op_logical_and
id|le16_to_cpu
c_func
(paren
id|ra-&gt;client_free_list
)paren
op_ge
id|le16_to_cpu
c_func
(paren
id|ra-&gt;log_clients
)paren
)paren
op_logical_or
(paren
id|ra-&gt;client_in_use_list
op_ne
id|LOGFILE_NO_CLIENT
op_logical_and
id|le16_to_cpu
c_func
(paren
id|ra-&gt;client_in_use_list
)paren
op_ge
id|le16_to_cpu
c_func
(paren
id|ra-&gt;log_clients
)paren
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;$LogFile restart area specifies &quot;
l_string|&quot;overflowing client free and/or in use lists.&quot;
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Check ra-&gt;seq_number_bits against ra-&gt;file_size for consistency.&n;&t; * We cannot just use ffs() because the file size is not a power of 2.&n;&t; */
id|file_size
op_assign
(paren
id|u64
)paren
id|sle64_to_cpu
c_func
(paren
id|ra-&gt;file_size
)paren
suffix:semicolon
id|fs_bits
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|file_size
)paren
(brace
id|file_size
op_rshift_assign
l_int|1
suffix:semicolon
id|fs_bits
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|le32_to_cpu
c_func
(paren
id|ra-&gt;seq_number_bits
)paren
op_ne
l_int|67
op_minus
id|fs_bits
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;$LogFile restart area specifies &quot;
l_string|&quot;inconsistent sequence number bits.&quot;
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
multiline_comment|/* The log record header length must be a multiple of 8. */
r_if
c_cond
(paren
(paren
(paren
id|le16_to_cpu
c_func
(paren
id|ra-&gt;log_record_header_length
)paren
op_plus
l_int|7
)paren
op_amp
op_complement
l_int|7
)paren
op_ne
id|le16_to_cpu
c_func
(paren
id|ra-&gt;log_record_header_length
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;$LogFile restart area specifies &quot;
l_string|&quot;inconsistent log record header length.&quot;
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
multiline_comment|/* Dito for the log page data offset. */
r_if
c_cond
(paren
(paren
(paren
id|le16_to_cpu
c_func
(paren
id|ra-&gt;log_page_data_offset
)paren
op_plus
l_int|7
)paren
op_amp
op_complement
l_int|7
)paren
op_ne
id|le16_to_cpu
c_func
(paren
id|ra-&gt;log_page_data_offset
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;$LogFile restart area specifies &quot;
l_string|&quot;inconsistent log page data offset.&quot;
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Done.&quot;
)paren
suffix:semicolon
r_return
id|TRUE
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_check_log_client_array - check the log client array for consistency&n; * @vi:&t;&t;$LogFile inode to which the restart page belongs&n; * @rp:&t;&t;restart page whose log client array to check&n; *&n; * Check the log client array of the restart page @rp for consistency and&n; * return TRUE if it is consistent and FALSE otherwise.&n; *&n; * This function assumes that the restart page header and the restart area have&n; * already been consistency checked.&n; *&n; * Unlike ntfs_check_restart_page_header() and ntfs_check_restart_area(), this&n; * function needs @rp-&gt;system_page_size bytes in @rp, i.e. it requires the full&n; * restart page and the page must be multi sector transfer deprotected.&n; */
DECL|function|ntfs_check_log_client_array
r_static
id|BOOL
id|ntfs_check_log_client_array
c_func
(paren
r_struct
id|inode
op_star
id|vi
comma
id|RESTART_PAGE_HEADER
op_star
id|rp
)paren
(brace
id|RESTART_AREA
op_star
id|ra
suffix:semicolon
id|LOG_CLIENT_RECORD
op_star
id|ca
comma
op_star
id|cr
suffix:semicolon
id|u16
id|nr_clients
comma
id|idx
suffix:semicolon
id|BOOL
id|in_free_list
comma
id|idx_is_first
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Entering.&quot;
)paren
suffix:semicolon
id|ra
op_assign
(paren
id|RESTART_AREA
op_star
)paren
(paren
(paren
id|u8
op_star
)paren
id|rp
op_plus
id|le16_to_cpu
c_func
(paren
id|rp-&gt;restart_area_offset
)paren
)paren
suffix:semicolon
id|ca
op_assign
(paren
id|LOG_CLIENT_RECORD
op_star
)paren
(paren
(paren
id|u8
op_star
)paren
id|ra
op_plus
id|le16_to_cpu
c_func
(paren
id|ra-&gt;client_array_offset
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Check the ra-&gt;client_free_list first and then check the&n;&t; * ra-&gt;client_in_use_list.  Check each of the log client records in&n;&t; * each of the lists and check that the array does not overflow the&n;&t; * ra-&gt;log_clients value.  Also keep track of the number of records&n;&t; * visited as there cannot be more than ra-&gt;log_clients records and&n;&t; * that way we detect eventual loops in within a list.&n;&t; */
id|nr_clients
op_assign
id|le16_to_cpu
c_func
(paren
id|ra-&gt;log_clients
)paren
suffix:semicolon
id|idx
op_assign
id|le16_to_cpu
c_func
(paren
id|ra-&gt;client_free_list
)paren
suffix:semicolon
id|in_free_list
op_assign
id|TRUE
suffix:semicolon
id|check_list
suffix:colon
r_for
c_loop
(paren
id|idx_is_first
op_assign
id|TRUE
suffix:semicolon
id|idx
op_ne
id|LOGFILE_NO_CLIENT_CPU
suffix:semicolon
id|nr_clients
op_decrement
comma
id|idx
op_assign
id|le16_to_cpu
c_func
(paren
id|cr-&gt;next_client
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|nr_clients
op_logical_or
id|idx
op_ge
id|le16_to_cpu
c_func
(paren
id|ra-&gt;log_clients
)paren
)paren
r_goto
id|err_out
suffix:semicolon
multiline_comment|/* Set @cr to the current log client record. */
id|cr
op_assign
id|ca
op_plus
id|idx
suffix:semicolon
multiline_comment|/* The first log client record must not have a prev_client. */
r_if
c_cond
(paren
id|idx_is_first
)paren
(brace
r_if
c_cond
(paren
id|cr-&gt;prev_client
op_ne
id|LOGFILE_NO_CLIENT
)paren
r_goto
id|err_out
suffix:semicolon
id|idx_is_first
op_assign
id|FALSE
suffix:semicolon
)brace
)brace
multiline_comment|/* Switch to and check the in use list if we just did the free list. */
r_if
c_cond
(paren
id|in_free_list
)paren
(brace
id|in_free_list
op_assign
id|FALSE
suffix:semicolon
id|idx
op_assign
id|le16_to_cpu
c_func
(paren
id|ra-&gt;client_in_use_list
)paren
suffix:semicolon
r_goto
id|check_list
suffix:semicolon
)brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Done.&quot;
)paren
suffix:semicolon
r_return
id|TRUE
suffix:semicolon
id|err_out
suffix:colon
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;$LogFile log client array is corrupt.&quot;
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_check_and_load_restart_page - check the restart page for consistency&n; * @vi:&t;&t;$LogFile inode to which the restart page belongs&n; * @rp:&t;&t;restart page to check&n; * @pos:&t;position in @vi at which the restart page resides&n; * @wrp:&t;copy of the multi sector transfer deprotected restart page&n; *&n; * Check the restart page @rp for consistency and return TRUE if it is&n; * consistent and FALSE otherwise.&n; *&n; * This function only needs NTFS_BLOCK_SIZE bytes in @rp, i.e. it does not&n; * require the full restart page.&n; *&n; * If @wrp is not NULL, on success, *@wrp will point to a buffer containing a&n; * copy of the complete multi sector transfer deprotected page.  On failure,&n; * *@wrp is undefined.&n; */
DECL|function|ntfs_check_and_load_restart_page
r_static
id|BOOL
id|ntfs_check_and_load_restart_page
c_func
(paren
r_struct
id|inode
op_star
id|vi
comma
id|RESTART_PAGE_HEADER
op_star
id|rp
comma
id|s64
id|pos
comma
id|RESTART_PAGE_HEADER
op_star
op_star
id|wrp
)paren
(brace
id|RESTART_AREA
op_star
id|ra
suffix:semicolon
id|RESTART_PAGE_HEADER
op_star
id|trp
suffix:semicolon
r_int
id|size
suffix:semicolon
id|BOOL
id|ret
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Entering.&quot;
)paren
suffix:semicolon
multiline_comment|/* Check the restart page header for consistency. */
r_if
c_cond
(paren
op_logical_neg
id|ntfs_check_restart_page_header
c_func
(paren
id|vi
comma
id|rp
comma
id|pos
)paren
)paren
(brace
multiline_comment|/* Error output already done inside the function. */
r_return
id|FALSE
suffix:semicolon
)brace
multiline_comment|/* Check the restart area for consistency. */
r_if
c_cond
(paren
op_logical_neg
id|ntfs_check_restart_area
c_func
(paren
id|vi
comma
id|rp
)paren
)paren
(brace
multiline_comment|/* Error output already done inside the function. */
r_return
id|FALSE
suffix:semicolon
)brace
id|ra
op_assign
(paren
id|RESTART_AREA
op_star
)paren
(paren
(paren
id|u8
op_star
)paren
id|rp
op_plus
id|le16_to_cpu
c_func
(paren
id|rp-&gt;restart_area_offset
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Allocate a buffer to store the whole restart page so we can multi&n;&t; * sector transfer deprotect it.&n;&t; */
id|trp
op_assign
id|ntfs_malloc_nofs
c_func
(paren
id|le32_to_cpu
c_func
(paren
id|rp-&gt;system_page_size
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|trp
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Failed to allocate memory for $LogFile &quot;
l_string|&quot;restart page buffer.&quot;
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Read the whole of the restart page into the buffer.  If it fits&n;&t; * completely inside @rp, just copy it from there.  Otherwise map all&n;&t; * the required pages and copy the data from them.&n;&t; */
id|size
op_assign
id|PAGE_CACHE_SIZE
op_minus
(paren
id|pos
op_amp
op_complement
id|PAGE_CACHE_MASK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|size
op_ge
id|le32_to_cpu
c_func
(paren
id|rp-&gt;system_page_size
)paren
)paren
(brace
id|memcpy
c_func
(paren
id|trp
comma
id|rp
comma
id|le32_to_cpu
c_func
(paren
id|rp-&gt;system_page_size
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|pgoff_t
id|idx
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
r_int
id|have_read
comma
id|to_read
suffix:semicolon
multiline_comment|/* First copy what we already have in @rp. */
id|memcpy
c_func
(paren
id|trp
comma
id|rp
comma
id|size
)paren
suffix:semicolon
multiline_comment|/* Copy the remaining data one page at a time. */
id|have_read
op_assign
id|size
suffix:semicolon
id|to_read
op_assign
id|le32_to_cpu
c_func
(paren
id|rp-&gt;system_page_size
)paren
op_minus
id|size
suffix:semicolon
id|idx
op_assign
(paren
id|pos
op_plus
id|size
)paren
op_rshift
id|PAGE_CACHE_SHIFT
suffix:semicolon
id|BUG_ON
c_func
(paren
(paren
id|pos
op_plus
id|size
)paren
op_amp
op_complement
id|PAGE_CACHE_MASK
)paren
suffix:semicolon
r_do
(brace
id|page
op_assign
id|ntfs_map_page
c_func
(paren
id|vi-&gt;i_mapping
comma
id|idx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|page
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Error mapping $LogFile &quot;
l_string|&quot;page (index %lu).&quot;
comma
id|idx
)paren
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
id|size
op_assign
id|min_t
c_func
(paren
r_int
comma
id|to_read
comma
id|PAGE_CACHE_SIZE
)paren
suffix:semicolon
id|memcpy
c_func
(paren
(paren
id|u8
op_star
)paren
id|trp
op_plus
id|have_read
comma
id|page_address
c_func
(paren
id|page
)paren
comma
id|size
)paren
suffix:semicolon
id|ntfs_unmap_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|have_read
op_add_assign
id|size
suffix:semicolon
id|to_read
op_sub_assign
id|size
suffix:semicolon
id|idx
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
id|to_read
OG
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* Perform the multi sector transfer deprotection on the buffer. */
r_if
c_cond
(paren
id|post_read_mst_fixup
c_func
(paren
(paren
id|NTFS_RECORD
op_star
)paren
id|trp
comma
id|le32_to_cpu
c_func
(paren
id|rp-&gt;system_page_size
)paren
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Multi sector transfer error detected in &quot;
l_string|&quot;$LogFile restart page.&quot;
)paren
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
multiline_comment|/* Check the log client records for consistency. */
id|ret
op_assign
id|ntfs_check_log_client_array
c_func
(paren
id|vi
comma
id|trp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_logical_and
id|wrp
)paren
op_star
id|wrp
op_assign
id|trp
suffix:semicolon
r_else
id|ntfs_free
c_func
(paren
id|trp
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Done.&quot;
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
id|err_out
suffix:colon
id|ntfs_free
c_func
(paren
id|trp
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_ckeck_logfile - check in the journal if the volume is consistent&n; * @log_vi:&t;struct inode of loaded journal $LogFile to check&n; *&n; * Check the $LogFile journal for consistency and return TRUE if it is&n; * consistent and FALSE if not.&n; *&n; * At present we only check the two restart pages and ignore the log record&n; * pages.&n; *&n; * Note that the MstProtected flag is not set on the $LogFile inode and hence&n; * when reading pages they are not deprotected.  This is because we do not know&n; * if the $LogFile was created on a system with a different page size to ours&n; * yet and mst deprotection would fail if our page size is smaller.&n; */
DECL|function|ntfs_check_logfile
id|BOOL
id|ntfs_check_logfile
c_func
(paren
r_struct
id|inode
op_star
id|log_vi
)paren
(brace
id|s64
id|size
comma
id|pos
comma
id|rstr1_pos
comma
id|rstr2_pos
suffix:semicolon
id|ntfs_volume
op_star
id|vol
op_assign
id|NTFS_SB
c_func
(paren
id|log_vi-&gt;i_sb
)paren
suffix:semicolon
r_struct
id|address_space
op_star
id|mapping
op_assign
id|log_vi-&gt;i_mapping
suffix:semicolon
r_struct
id|page
op_star
id|page
op_assign
l_int|NULL
suffix:semicolon
id|u8
op_star
id|kaddr
op_assign
l_int|NULL
suffix:semicolon
id|RESTART_PAGE_HEADER
op_star
id|rstr1_ph
op_assign
l_int|NULL
suffix:semicolon
id|RESTART_PAGE_HEADER
op_star
id|rstr2_ph
op_assign
l_int|NULL
suffix:semicolon
r_int
id|log_page_size
comma
id|log_page_mask
comma
id|ofs
suffix:semicolon
id|BOOL
id|logfile_is_empty
op_assign
id|TRUE
suffix:semicolon
id|BOOL
id|rstr1_found
op_assign
id|FALSE
suffix:semicolon
id|BOOL
id|rstr2_found
op_assign
id|FALSE
suffix:semicolon
id|u8
id|log_page_bits
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Entering.&quot;
)paren
suffix:semicolon
multiline_comment|/* An empty $LogFile must have been clean before it got emptied. */
r_if
c_cond
(paren
id|NVolLogFileEmpty
c_func
(paren
id|vol
)paren
)paren
r_goto
id|is_empty
suffix:semicolon
id|size
op_assign
id|log_vi-&gt;i_size
suffix:semicolon
multiline_comment|/* Make sure the file doesn&squot;t exceed the maximum allowed size. */
r_if
c_cond
(paren
id|size
OG
id|MaxLogFileSize
)paren
id|size
op_assign
id|MaxLogFileSize
suffix:semicolon
multiline_comment|/*&n;&t; * Truncate size to a multiple of the page cache size or the default&n;&t; * log page size if the page cache size is between the default log page&n;&t; * log page size if the page cache size is between the default log page&n;&t; * size and twice that.&n;&t; */
r_if
c_cond
(paren
id|PAGE_CACHE_SIZE
op_ge
id|DefaultLogPageSize
op_logical_and
id|PAGE_CACHE_SIZE
op_le
id|DefaultLogPageSize
op_star
l_int|2
)paren
id|log_page_size
op_assign
id|DefaultLogPageSize
suffix:semicolon
r_else
id|log_page_size
op_assign
id|PAGE_CACHE_SIZE
suffix:semicolon
id|log_page_mask
op_assign
id|log_page_size
op_minus
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * Use generic_ffs() instead of ffs() to enable the compiler to&n;&t; * optimize log_page_size and log_page_bits into constants.&n;&t; */
id|log_page_bits
op_assign
id|generic_ffs
c_func
(paren
id|log_page_size
)paren
op_minus
l_int|1
suffix:semicolon
id|size
op_and_assign
op_complement
(paren
id|log_page_size
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Ensure the log file is big enough to store at least the two restart&n;&t; * pages and the minimum number of log record pages.&n;&t; */
r_if
c_cond
(paren
id|size
OL
id|log_page_size
op_star
l_int|2
op_logical_or
(paren
id|size
op_minus
id|log_page_size
op_star
l_int|2
)paren
op_rshift
id|log_page_bits
OL
id|MinLogRecordPages
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;$LogFile is too small.&quot;
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Read through the file looking for a restart page.  Since the restart&n;&t; * page header is at the beginning of a page we only need to search at&n;&t; * what could be the beginning of a page (for each page size) rather&n;&t; * than scanning the whole file byte by byte.  If all potential places&n;&t; * contain empty and uninitialzed records, the log file can be assumed&n;&t; * to be empty.&n;&t; */
r_for
c_loop
(paren
id|pos
op_assign
l_int|0
suffix:semicolon
id|pos
OL
id|size
suffix:semicolon
id|pos
op_lshift_assign
l_int|1
)paren
(brace
id|pgoff_t
id|idx
op_assign
id|pos
op_rshift
id|PAGE_CACHE_SHIFT
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page
op_logical_or
id|page-&gt;index
op_ne
id|idx
)paren
(brace
r_if
c_cond
(paren
id|page
)paren
id|ntfs_unmap_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|page
op_assign
id|ntfs_map_page
c_func
(paren
id|mapping
comma
id|idx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|page
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Error mapping $LogFile &quot;
l_string|&quot;page (index %lu).&quot;
comma
id|idx
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
)brace
id|kaddr
op_assign
(paren
id|u8
op_star
)paren
id|page_address
c_func
(paren
id|page
)paren
op_plus
(paren
id|pos
op_amp
op_complement
id|PAGE_CACHE_MASK
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * A non-empty block means the logfile is not empty while an&n;&t;&t; * empty block after a non-empty block has been encountered&n;&t;&t; * means we are done.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|ntfs_is_empty_recordp
c_func
(paren
id|kaddr
)paren
)paren
id|logfile_is_empty
op_assign
id|FALSE
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|logfile_is_empty
)paren
r_break
suffix:semicolon
multiline_comment|/*&n;&t;&t; * A log record page means there cannot be a restart page after&n;&t;&t; * this so no need to continue searching.&n;&t;&t; */
r_if
c_cond
(paren
id|ntfs_is_rcrd_recordp
c_func
(paren
id|kaddr
)paren
)paren
r_break
suffix:semicolon
multiline_comment|/*&n;&t;&t; * A modified by chkdsk restart page means we cannot handle&n;&t;&t; * this log file.&n;&t;&t; */
r_if
c_cond
(paren
id|ntfs_is_chkd_recordp
c_func
(paren
id|kaddr
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;$LogFile has been modified by &quot;
l_string|&quot;chkdsk.  Mount this volume in &quot;
l_string|&quot;Windows.&quot;
)paren
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
multiline_comment|/* If not a restart page, continue. */
r_if
c_cond
(paren
op_logical_neg
id|ntfs_is_rstr_recordp
c_func
(paren
id|kaddr
)paren
)paren
(brace
multiline_comment|/* Skip to the minimum page size for the next one. */
r_if
c_cond
(paren
op_logical_neg
id|pos
)paren
id|pos
op_assign
id|NTFS_BLOCK_SIZE
op_rshift
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* We now know we have a restart page. */
r_if
c_cond
(paren
op_logical_neg
id|pos
)paren
(brace
id|rstr1_found
op_assign
id|TRUE
suffix:semicolon
id|rstr1_pos
op_assign
id|pos
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|rstr2_found
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Found more than two &quot;
l_string|&quot;restart pages in $LogFile.&quot;
)paren
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
id|rstr2_found
op_assign
id|TRUE
suffix:semicolon
id|rstr2_pos
op_assign
id|pos
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Check the restart page for consistency and get a copy of the&n;&t;&t; * complete multi sector transfer deprotected restart page.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|ntfs_check_and_load_restart_page
c_func
(paren
id|log_vi
comma
(paren
id|RESTART_PAGE_HEADER
op_star
)paren
id|kaddr
comma
id|pos
comma
op_logical_neg
id|pos
ques
c_cond
op_amp
id|rstr1_ph
suffix:colon
op_amp
id|rstr2_ph
)paren
)paren
(brace
multiline_comment|/* Error output already done inside the function. */
r_goto
id|err_out
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * We have a valid restart page.  The next one must be after&n;&t;&t; * a whole system page size as specified by the valid restart&n;&t;&t; * page.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|pos
)paren
id|pos
op_assign
id|le32_to_cpu
c_func
(paren
id|rstr1_ph-&gt;system_page_size
)paren
op_rshift
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|page
)paren
(brace
id|ntfs_unmap_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|page
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|logfile_is_empty
)paren
(brace
id|NVolSetLogFileEmpty
c_func
(paren
id|vol
)paren
suffix:semicolon
id|is_empty
suffix:colon
id|ntfs_debug
c_func
(paren
l_string|&quot;Done.  ($LogFile is empty.)&quot;
)paren
suffix:semicolon
r_return
id|TRUE
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|rstr1_found
op_logical_or
op_logical_neg
id|rstr2_found
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Did not find two restart pages in &quot;
l_string|&quot;$LogFile.&quot;
)paren
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * The two restart areas must be identical except for the update&n;&t; * sequence number.&n;&t; */
id|ofs
op_assign
id|le16_to_cpu
c_func
(paren
id|rstr1_ph-&gt;usa_ofs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|rstr1_ph
comma
id|rstr2_ph
comma
id|ofs
)paren
op_logical_or
(paren
id|ofs
op_add_assign
r_sizeof
(paren
id|u16
)paren
comma
id|memcmp
c_func
(paren
(paren
id|u8
op_star
)paren
id|rstr1_ph
op_plus
id|ofs
comma
(paren
id|u8
op_star
)paren
id|rstr2_ph
op_plus
id|ofs
comma
id|le32_to_cpu
c_func
(paren
id|rstr1_ph-&gt;system_page_size
)paren
op_minus
id|ofs
)paren
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;The two restart pages in $LogFile do not &quot;
l_string|&quot;match.&quot;
)paren
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
id|ntfs_free
c_func
(paren
id|rstr1_ph
)paren
suffix:semicolon
id|ntfs_free
c_func
(paren
id|rstr2_ph
)paren
suffix:semicolon
multiline_comment|/* All consistency checks passed. */
id|ntfs_debug
c_func
(paren
l_string|&quot;Done.&quot;
)paren
suffix:semicolon
r_return
id|TRUE
suffix:semicolon
id|err_out
suffix:colon
r_if
c_cond
(paren
id|page
)paren
id|ntfs_unmap_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rstr1_ph
)paren
id|ntfs_free
c_func
(paren
id|rstr1_ph
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rstr2_ph
)paren
id|ntfs_free
c_func
(paren
id|rstr2_ph
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_is_logfile_clean - check in the journal if the volume is clean&n; * @log_vi:&t;struct inode of loaded journal $LogFile to check&n; *&n; * Analyze the $LogFile journal and return TRUE if it indicates the volume was&n; * shutdown cleanly and FALSE if not.&n; *&n; * At present we only look at the two restart pages and ignore the log record&n; * pages.  This is a little bit crude in that there will be a very small number&n; * of cases where we think that a volume is dirty when in fact it is clean.&n; * This should only affect volumes that have not been shutdown cleanly but did&n; * not have any pending, non-check-pointed i/o, i.e. they were completely idle&n; * at least for the five seconds preceeding the unclean shutdown.&n; *&n; * This function assumes that the $LogFile journal has already been consistency&n; * checked by a call to ntfs_check_logfile() and in particular if the $LogFile&n; * is empty this function requires that NVolLogFileEmpty() is true otherwise an&n; * empty volume will be reported as dirty.&n; */
DECL|function|ntfs_is_logfile_clean
id|BOOL
id|ntfs_is_logfile_clean
c_func
(paren
r_struct
id|inode
op_star
id|log_vi
)paren
(brace
id|ntfs_volume
op_star
id|vol
op_assign
id|NTFS_SB
c_func
(paren
id|log_vi-&gt;i_sb
)paren
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
id|RESTART_PAGE_HEADER
op_star
id|rp
suffix:semicolon
id|RESTART_AREA
op_star
id|ra
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Entering.&quot;
)paren
suffix:semicolon
multiline_comment|/* An empty $LogFile must have been clean before it got emptied. */
r_if
c_cond
(paren
id|NVolLogFileEmpty
c_func
(paren
id|vol
)paren
)paren
(brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Done.  ($LogFile is empty.)&quot;
)paren
suffix:semicolon
r_return
id|TRUE
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Read the first restart page.  It will be possibly incomplete and&n;&t; * will not be multi sector transfer deprotected but we only need the&n;&t; * first NTFS_BLOCK_SIZE bytes so it does not matter.&n;&t; */
id|page
op_assign
id|ntfs_map_page
c_func
(paren
id|log_vi-&gt;i_mapping
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|page
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Error mapping $LogFile page (index 0).&quot;
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
id|rp
op_assign
(paren
id|RESTART_PAGE_HEADER
op_star
)paren
id|page_address
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ntfs_is_rstr_record
c_func
(paren
id|rp-&gt;magic
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;No restart page found at offset zero in &quot;
l_string|&quot;$LogFile.  This is probably a bug in that &quot;
l_string|&quot;the $LogFile should have been consistency &quot;
l_string|&quot;checked before calling this function.&quot;
)paren
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
id|ra
op_assign
(paren
id|RESTART_AREA
op_star
)paren
(paren
(paren
id|u8
op_star
)paren
id|rp
op_plus
id|le16_to_cpu
c_func
(paren
id|rp-&gt;restart_area_offset
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If the $LogFile has active clients, i.e. it is open, and we do not&n;&t; * have the RESTART_VOLUME_IS_CLEAN bit set in the restart area flags,&n;&t; * we assume there was an unclean shutdown.&n;&t; */
r_if
c_cond
(paren
id|ra-&gt;client_in_use_list
op_ne
id|LOGFILE_NO_CLIENT
op_logical_and
op_logical_neg
(paren
id|ra-&gt;flags
op_amp
id|RESTART_VOLUME_IS_CLEAN
)paren
)paren
(brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Done.  $LogFile indicates a dirty shutdown.&quot;
)paren
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
id|ntfs_unmap_page
c_func
(paren
id|page
)paren
suffix:semicolon
multiline_comment|/* $LogFile indicates a clean shutdown. */
id|ntfs_debug
c_func
(paren
l_string|&quot;Done.  $LogFile indicates a clean shutdown.&quot;
)paren
suffix:semicolon
r_return
id|TRUE
suffix:semicolon
id|err_out
suffix:colon
id|ntfs_unmap_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_empty_logfile - empty the contents of the $LogFile journal&n; * @log_vi:&t;struct inode of loaded journal $LogFile to empty&n; *&n; * Empty the contents of the $LogFile journal @log_vi and return TRUE on&n; * success FALSE on error.&n; *&n; * This function assumes that the $LogFile journal has already been consistency&n; * checked by a call to ntfs_check_logfile() and that ntfs_is_logfile_clean()&n; * has been used to ensure that the $LogFile is clean.&n; */
DECL|function|ntfs_empty_logfile
id|BOOL
id|ntfs_empty_logfile
c_func
(paren
r_struct
id|inode
op_star
id|log_vi
)paren
(brace
id|ntfs_volume
op_star
id|vol
op_assign
id|NTFS_SB
c_func
(paren
id|log_vi-&gt;i_sb
)paren
suffix:semicolon
r_struct
id|address_space
op_star
id|mapping
suffix:semicolon
id|pgoff_t
id|idx
comma
id|end
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Entering.&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|NVolLogFileEmpty
c_func
(paren
id|vol
)paren
)paren
r_goto
id|done
suffix:semicolon
id|mapping
op_assign
id|log_vi-&gt;i_mapping
suffix:semicolon
id|end
op_assign
(paren
id|log_vi-&gt;i_size
op_plus
id|PAGE_CACHE_SIZE
op_minus
l_int|1
)paren
op_rshift
id|PAGE_CACHE_SHIFT
suffix:semicolon
r_for
c_loop
(paren
id|idx
op_assign
l_int|0
suffix:semicolon
id|idx
OL
id|end
suffix:semicolon
op_increment
id|idx
)paren
(brace
r_struct
id|page
op_star
id|page
suffix:semicolon
id|u8
op_star
id|kaddr
suffix:semicolon
multiline_comment|/* Find or create the current page.  (The page is locked.) */
id|page
op_assign
id|grab_cache_page
c_func
(paren
id|mapping
comma
id|idx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|page
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Insufficient memory to grab &quot;
l_string|&quot;$LogFile page (index %lu).&quot;
comma
id|idx
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Set all bytes in the page to 0xff.  It doesn&squot;t matter if we&n;&t;&t; * go beyond i_size, because ntfs_writepage() will take care of&n;&t;&t; * that for us.&n;&t;&t; */
id|kaddr
op_assign
(paren
id|u8
op_star
)paren
id|kmap_atomic
c_func
(paren
id|page
comma
id|KM_USER0
)paren
suffix:semicolon
id|memset
c_func
(paren
id|kaddr
comma
l_int|0xff
comma
id|PAGE_CACHE_SIZE
)paren
suffix:semicolon
id|flush_dcache_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|kunmap_atomic
c_func
(paren
id|kaddr
comma
id|KM_USER0
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If the page has buffers, mark them uptodate since buffer&n;&t;&t; * state and not page state is definitive in 2.6 kernels.&n;&t;&t; */
r_if
c_cond
(paren
id|page_has_buffers
c_func
(paren
id|page
)paren
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
comma
op_star
id|head
suffix:semicolon
id|bh
op_assign
id|head
op_assign
id|page_buffers
c_func
(paren
id|page
)paren
suffix:semicolon
r_do
(brace
id|set_buffer_uptodate
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|bh
op_assign
id|bh-&gt;b_this_page
)paren
op_ne
id|head
)paren
suffix:semicolon
)brace
multiline_comment|/* Now that buffers are uptodate, set the page uptodate, too. */
id|SetPageUptodate
c_func
(paren
id|page
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Set the page and all its buffers dirty and mark the inode&n;&t;&t; * dirty, too. The VM will write the page later on.&n;&t;&t; */
id|set_page_dirty
c_func
(paren
id|page
)paren
suffix:semicolon
multiline_comment|/* Finally unlock and release the page. */
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
multiline_comment|/* We set the flag so we do not clear the log file again on remount. */
id|NVolSetLogFileEmpty
c_func
(paren
id|vol
)paren
suffix:semicolon
id|done
suffix:colon
id|ntfs_debug
c_func
(paren
l_string|&quot;Done.&quot;
)paren
suffix:semicolon
r_return
id|TRUE
suffix:semicolon
)brace
macro_line|#endif /* NTFS_RW */
eof
