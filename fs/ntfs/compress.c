multiline_comment|/**&n; * compress.c - NTFS kernel compressed attributes handling.&n; *&t;&t;Part of the Linux-NTFS project.&n; *&n; * Copyright (c) 2001,2002 Anton Altaparmakov.&n; * Copyright (C) 2002 Richard Russon.&n; *&n; * This program/include file is free software; you can redistribute it and/or&n; * modify it under the terms of the GNU General Public License as published&n; * by the Free Software Foundation; either version 2 of the License, or&n; * (at your option) any later version.&n; *&n; * This program/include file is distributed in the hope that it will be &n; * useful, but WITHOUT ANY WARRANTY; without even the implied warranty &n; * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; * GNU General Public License for more details.&n; *&n; * You should have received a copy of the GNU General Public License&n; * along with this program (in the main directory of the Linux-NTFS &n; * distribution in the file COPYING); if not, write to the Free Software&n; * Foundation,Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA&n; */
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/buffer_head.h&gt;
macro_line|#include &quot;ntfs.h&quot;
multiline_comment|/**&n; * ntfs_compression_constants - enum of constants used in the compression code&n; */
r_typedef
r_enum
(brace
multiline_comment|/* Token types and access mask. */
DECL|enumerator|NTFS_SYMBOL_TOKEN
id|NTFS_SYMBOL_TOKEN
op_assign
l_int|0
comma
DECL|enumerator|NTFS_PHRASE_TOKEN
id|NTFS_PHRASE_TOKEN
op_assign
l_int|1
comma
DECL|enumerator|NTFS_TOKEN_MASK
id|NTFS_TOKEN_MASK
op_assign
l_int|1
comma
multiline_comment|/* Compression sub-block constants. */
DECL|enumerator|NTFS_SB_SIZE_MASK
id|NTFS_SB_SIZE_MASK
op_assign
l_int|0x0fff
comma
DECL|enumerator|NTFS_SB_SIZE
id|NTFS_SB_SIZE
op_assign
l_int|0x1000
comma
DECL|enumerator|NTFS_SB_IS_COMPRESSED
id|NTFS_SB_IS_COMPRESSED
op_assign
l_int|0x8000
comma
multiline_comment|/*&n;&t; * The maximum compression block size is by definition 16 * the cluster&n;&t; * size, with the maximum supported cluster size being 4kiB. Thus the&n;&t; * maximum compression buffer size is 64kiB, so we use this when&n;&t; * initializing the per-CPU buffers.&n;&t; */
DECL|enumerator|NTFS_MAX_CB_SIZE
id|NTFS_MAX_CB_SIZE
op_assign
l_int|64
op_star
l_int|1024
comma
DECL|typedef|ntfs_compression_constants
)brace
id|ntfs_compression_constants
suffix:semicolon
multiline_comment|/**&n; * ntfs_compression_buffer - one buffer for the decompression engine&n; */
DECL|variable|ntfs_compression_buffer
r_static
id|u8
op_star
id|ntfs_compression_buffer
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/**&n; * ntfs_cb_lock - spinlock which protects ntfs_compression_buffer&n; */
DECL|variable|ntfs_cb_lock
r_static
id|spinlock_t
id|ntfs_cb_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
multiline_comment|/**&n; * allocate_compression_buffers - allocate the decompression buffers&n; *&n; * Caller has to hold the ntfs_lock semaphore.&n; *&n; * Return 0 on success or -ENOMEM if the allocations failed.&n; */
DECL|function|allocate_compression_buffers
r_int
id|allocate_compression_buffers
c_func
(paren
r_void
)paren
(brace
id|BUG_ON
c_func
(paren
id|ntfs_compression_buffer
)paren
suffix:semicolon
id|ntfs_compression_buffer
op_assign
id|vmalloc
c_func
(paren
id|NTFS_MAX_CB_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ntfs_compression_buffer
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * free_compression_buffers - free the decompression buffers&n; *&n; * Caller has to hold the ntfs_lock semaphore.&n; */
DECL|function|free_compression_buffers
r_void
id|free_compression_buffers
c_func
(paren
r_void
)paren
(brace
id|BUG_ON
c_func
(paren
op_logical_neg
id|ntfs_compression_buffer
)paren
suffix:semicolon
id|vfree
c_func
(paren
id|ntfs_compression_buffer
)paren
suffix:semicolon
id|ntfs_compression_buffer
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_decompress - decompress a compression block into an array of pages&n; * @dest_pages:&t;&t;destination array of pages&n; * @dest_index:&t;&t;current index into @dest_pages (IN/OUT)&n; * @dest_ofs:&t;&t;current offset within @dest_pages[@dest_index] (IN/OUT)&n; * @dest_max_index:&t;maximum index into @dest_pages (IN)&n; * @dest_max_ofs:&t;maximum offset within @dest_pages[@dest_max_index] (IN)&n; * @xpage:&t;&t;the target page (-1 if none) (IN)&n; * @xpage_done:&t;&t;set to 1 if xpage was completed successfully (IN/OUT)&n; * @cb_start:&t;&t;compression block to decompress (IN)&n; * @cb_size:&t;&t;size of compression block @cb_start in bytes (IN)&n; *&n; * The caller must have disabled preemption. ntfs_decompress() reenables it when&n; * the critical section is finished.&n; *&n; * This decompresses the compression block @cb_start into the array of&n; * destination pages @dest_pages starting at index @dest_index into @dest_pages&n; * and at offset @dest_pos into the page @dest_pages[@dest_index].&n; *&n; * When the page @dest_pages[@xpage] is completed, @xpage_done is set to 1.&n; * If xpage is -1 or @xpage has not been completed, @xpage_done is not modified.&n; *&n; * @cb_start is a pointer to the compression block which needs decompressing&n; * and @cb_size is the size of @cb_start in bytes (8-64kiB).&n; *&n; * Return 0 if success or -EOVERFLOW on error in the compressed stream.&n; * @xpage_done indicates whether the target page (@dest_pages[@xpage]) was&n; * completed during the decompression of the compression block (@cb_start).&n; *&n; * Warning: This function *REQUIRES* PAGE_CACHE_SIZE &gt;= 4096 or it will blow up&n; * unpredicatbly! You have been warned!&n; *&n; * Note to hackers: This function may not sleep until it has finished accessing&n; * the compression block @cb_start as it is a per-CPU buffer.&n; */
DECL|function|ntfs_decompress
r_static
r_int
id|ntfs_decompress
c_func
(paren
r_struct
id|page
op_star
id|dest_pages
(braket
)braket
comma
r_int
op_star
id|dest_index
comma
r_int
op_star
id|dest_ofs
comma
r_const
r_int
id|dest_max_index
comma
r_const
r_int
id|dest_max_ofs
comma
r_const
r_int
id|xpage
comma
r_char
op_star
id|xpage_done
comma
id|u8
op_star
r_const
id|cb_start
comma
r_const
id|u32
id|cb_size
)paren
(brace
multiline_comment|/*&n;&t; * Pointers into the compressed data, i.e. the compression block (cb),&n;&t; * and the therein contained sub-blocks (sb).&n;&t; */
id|u8
op_star
id|cb_end
op_assign
id|cb_start
op_plus
id|cb_size
suffix:semicolon
multiline_comment|/* End of cb. */
id|u8
op_star
id|cb
op_assign
id|cb_start
suffix:semicolon
multiline_comment|/* Current position in cb. */
id|u8
op_star
id|cb_sb_start
op_assign
id|cb
suffix:semicolon
multiline_comment|/* Beginning of the current sb in the cb. */
id|u8
op_star
id|cb_sb_end
suffix:semicolon
multiline_comment|/* End of current sb / beginning of next sb. */
multiline_comment|/* Variables for uncompressed data / destination. */
r_struct
id|page
op_star
id|dp
suffix:semicolon
multiline_comment|/* Current destination page being worked on. */
id|u8
op_star
id|dp_addr
suffix:semicolon
multiline_comment|/* Current pointer into dp. */
id|u8
op_star
id|dp_sb_start
suffix:semicolon
multiline_comment|/* Start of current sub-block in dp. */
id|u8
op_star
id|dp_sb_end
suffix:semicolon
multiline_comment|/* End of current sb in dp (dp_sb_start +&n;&t;&t;&t;&t;   NTFS_SB_SIZE). */
id|u16
id|do_sb_start
suffix:semicolon
multiline_comment|/* @dest_ofs when starting this sub-block. */
id|u16
id|do_sb_end
suffix:semicolon
multiline_comment|/* @dest_ofs of end of this sb (do_sb_start +&n;&t;&t;&t;&t;   NTFS_SB_SIZE). */
multiline_comment|/* Variables for tag and token parsing. */
id|u8
id|tag
suffix:semicolon
multiline_comment|/* Current tag. */
r_int
id|token
suffix:semicolon
multiline_comment|/* Loop counter for the eight tokens in tag. */
multiline_comment|/* Need this because we can&squot;t sleep, so need two stages. */
r_int
id|completed_pages
(braket
id|dest_max_index
op_minus
op_star
id|dest_index
op_plus
l_int|1
)braket
suffix:semicolon
r_int
id|nr_completed_pages
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Default error code. */
r_int
id|err
op_assign
op_minus
id|EOVERFLOW
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Entering, cb_size = 0x%x.&quot;
comma
id|cb_size
)paren
suffix:semicolon
id|do_next_sb
suffix:colon
id|ntfs_debug
c_func
(paren
l_string|&quot;Beginning sub-block at offset = 0x%x in the cb.&quot;
comma
id|cb
op_minus
id|cb_start
)paren
suffix:semicolon
multiline_comment|/* Have we reached the end of the compression block? */
r_if
c_cond
(paren
id|cb
op_eq
id|cb_end
op_logical_or
op_logical_neg
id|le16_to_cpup
c_func
(paren
id|cb
)paren
)paren
(brace
r_int
id|i
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Completed. Returning success (0).&quot;
)paren
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
id|return_error
suffix:colon
multiline_comment|/* We can sleep from now on, so we drop lock. */
id|spin_unlock
c_func
(paren
op_amp
id|ntfs_cb_lock
)paren
suffix:semicolon
multiline_comment|/* Second stage: finalize completed pages. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr_completed_pages
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|di
op_assign
id|completed_pages
(braket
id|i
)braket
suffix:semicolon
id|dp
op_assign
id|dest_pages
(braket
id|di
)braket
suffix:semicolon
id|flush_dcache_page
c_func
(paren
id|dp
)paren
suffix:semicolon
id|kunmap
c_func
(paren
id|dp
)paren
suffix:semicolon
id|SetPageUptodate
c_func
(paren
id|dp
)paren
suffix:semicolon
id|unlock_page
c_func
(paren
id|dp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|di
op_eq
id|xpage
)paren
op_star
id|xpage_done
op_assign
l_int|1
suffix:semicolon
r_else
id|page_cache_release
c_func
(paren
id|dp
)paren
suffix:semicolon
id|dest_pages
(braket
id|di
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/* Setup offsets for the current sub-block destination. */
id|do_sb_start
op_assign
op_star
id|dest_ofs
suffix:semicolon
id|do_sb_end
op_assign
id|do_sb_start
op_plus
id|NTFS_SB_SIZE
suffix:semicolon
multiline_comment|/* Check that we are still within allowed boundaries. */
r_if
c_cond
(paren
op_star
id|dest_index
op_eq
id|dest_max_index
op_logical_and
id|do_sb_end
OG
id|dest_max_ofs
)paren
r_goto
id|return_overflow
suffix:semicolon
multiline_comment|/* Does the minimum size of a compressed sb overflow valid range? */
r_if
c_cond
(paren
id|cb
op_plus
l_int|6
OG
id|cb_end
)paren
r_goto
id|return_overflow
suffix:semicolon
multiline_comment|/* Setup the current sub-block source pointers and validate range. */
id|cb_sb_start
op_assign
id|cb
suffix:semicolon
id|cb_sb_end
op_assign
id|cb_sb_start
op_plus
(paren
id|le16_to_cpup
c_func
(paren
id|cb
)paren
op_amp
id|NTFS_SB_SIZE_MASK
)paren
op_plus
l_int|3
suffix:semicolon
r_if
c_cond
(paren
id|cb_sb_end
OG
id|cb_end
)paren
r_goto
id|return_overflow
suffix:semicolon
multiline_comment|/* Get the current destination page. */
id|dp
op_assign
id|dest_pages
(braket
op_star
id|dest_index
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dp
)paren
(brace
multiline_comment|/* No page present. Skip decompression of this sub-block. */
id|cb
op_assign
id|cb_sb_end
suffix:semicolon
multiline_comment|/* Advance destination position to next sub-block. */
op_star
id|dest_ofs
op_assign
(paren
op_star
id|dest_ofs
op_plus
id|NTFS_SB_SIZE
)paren
op_amp
op_complement
id|PAGE_CACHE_MASK
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_star
id|dest_ofs
op_logical_and
(paren
op_increment
op_star
id|dest_index
OG
id|dest_max_index
)paren
)paren
r_goto
id|return_overflow
suffix:semicolon
r_goto
id|do_next_sb
suffix:semicolon
)brace
multiline_comment|/* We have a valid destination page. Setup the destination pointers. */
id|dp_addr
op_assign
(paren
id|u8
op_star
)paren
id|page_address
c_func
(paren
id|dp
)paren
op_plus
id|do_sb_start
suffix:semicolon
multiline_comment|/* Now, we are ready to process the current sub-block (sb). */
r_if
c_cond
(paren
op_logical_neg
(paren
id|le16_to_cpup
c_func
(paren
id|cb
)paren
op_amp
id|NTFS_SB_IS_COMPRESSED
)paren
)paren
(brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Found uncompressed sub-block.&quot;
)paren
suffix:semicolon
multiline_comment|/* This sb is not compressed, just copy it into destination. */
multiline_comment|/* Advance source position to first data byte. */
id|cb
op_add_assign
l_int|2
suffix:semicolon
multiline_comment|/* An uncompressed sb must be full size. */
r_if
c_cond
(paren
id|cb_sb_end
op_minus
id|cb
op_ne
id|NTFS_SB_SIZE
)paren
r_goto
id|return_overflow
suffix:semicolon
multiline_comment|/* Copy the block and advance the source position. */
id|memcpy
c_func
(paren
id|dp_addr
comma
id|cb
comma
id|NTFS_SB_SIZE
)paren
suffix:semicolon
id|cb
op_add_assign
id|NTFS_SB_SIZE
suffix:semicolon
multiline_comment|/* Advance destination position to next sub-block. */
op_star
id|dest_ofs
op_add_assign
id|NTFS_SB_SIZE
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
op_star
id|dest_ofs
op_and_assign
op_complement
id|PAGE_CACHE_MASK
)paren
)paren
(brace
id|finalize_page
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * First stage: add current page index to array of&n;&t;&t;&t; * completed pages.&n;&t;&t;&t; */
id|completed_pages
(braket
id|nr_completed_pages
op_increment
)braket
op_assign
op_star
id|dest_index
suffix:semicolon
r_if
c_cond
(paren
op_increment
op_star
id|dest_index
OG
id|dest_max_index
)paren
r_goto
id|return_overflow
suffix:semicolon
)brace
r_goto
id|do_next_sb
suffix:semicolon
)brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Found compressed sub-block.&quot;
)paren
suffix:semicolon
multiline_comment|/* This sb is compressed, decompress it into destination. */
multiline_comment|/* Setup destination pointers. */
id|dp_sb_start
op_assign
id|dp_addr
suffix:semicolon
id|dp_sb_end
op_assign
id|dp_sb_start
op_plus
id|NTFS_SB_SIZE
suffix:semicolon
multiline_comment|/* Forward to the first tag in the sub-block. */
id|cb
op_add_assign
l_int|2
suffix:semicolon
id|do_next_tag
suffix:colon
r_if
c_cond
(paren
id|cb
op_eq
id|cb_sb_end
)paren
(brace
multiline_comment|/* Check if the decompressed sub-block was not full-length. */
r_if
c_cond
(paren
id|dp_addr
OL
id|dp_sb_end
)paren
(brace
r_int
id|nr_bytes
op_assign
id|do_sb_end
op_minus
op_star
id|dest_ofs
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Filling incomplete sub-block with &quot;
l_string|&quot;zeroes.&quot;
)paren
suffix:semicolon
multiline_comment|/* Zero remainder and update destination position. */
id|memset
c_func
(paren
id|dp_addr
comma
l_int|0
comma
id|nr_bytes
)paren
suffix:semicolon
op_star
id|dest_ofs
op_add_assign
id|nr_bytes
suffix:semicolon
)brace
multiline_comment|/* We have finished the current sub-block. */
r_if
c_cond
(paren
op_logical_neg
(paren
op_star
id|dest_ofs
op_and_assign
op_complement
id|PAGE_CACHE_MASK
)paren
)paren
r_goto
id|finalize_page
suffix:semicolon
r_goto
id|do_next_sb
suffix:semicolon
)brace
multiline_comment|/* Check we are still in range. */
r_if
c_cond
(paren
id|cb
OG
id|cb_sb_end
op_logical_or
id|dp_addr
OG
id|dp_sb_end
)paren
r_goto
id|return_overflow
suffix:semicolon
multiline_comment|/* Get the next tag and advance to first token. */
id|tag
op_assign
op_star
id|cb
op_increment
suffix:semicolon
multiline_comment|/* Parse the eight tokens described by the tag. */
r_for
c_loop
(paren
id|token
op_assign
l_int|0
suffix:semicolon
id|token
OL
l_int|8
suffix:semicolon
id|token
op_increment
comma
id|tag
op_rshift_assign
l_int|1
)paren
(brace
id|u16
id|lg
comma
id|pt
comma
id|length
comma
id|max_non_overlap
suffix:semicolon
r_register
id|u16
id|i
suffix:semicolon
id|u8
op_star
id|dp_back_addr
suffix:semicolon
multiline_comment|/* Check if we are done / still in range. */
r_if
c_cond
(paren
id|cb
op_ge
id|cb_sb_end
op_logical_or
id|dp_addr
OG
id|dp_sb_end
)paren
r_break
suffix:semicolon
multiline_comment|/* Determine token type and parse appropriately.*/
r_if
c_cond
(paren
(paren
id|tag
op_amp
id|NTFS_TOKEN_MASK
)paren
op_eq
id|NTFS_SYMBOL_TOKEN
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * We have a symbol token, copy the symbol across, and&n;&t;&t;&t; * advance the source and destination positions.&n;&t;&t;&t; */
op_star
id|dp_addr
op_increment
op_assign
op_star
id|cb
op_increment
suffix:semicolon
op_increment
op_star
id|dest_ofs
suffix:semicolon
multiline_comment|/* Continue with the next token. */
r_continue
suffix:semicolon
)brace
multiline_comment|/* &n;&t;&t; * We have a phrase token. Make sure it is not the first tag in&n;&t;&t; * the sb as this is illegal and would confuse the code below.&n;&t;&t; */
r_if
c_cond
(paren
id|dp_addr
op_eq
id|dp_sb_start
)paren
r_goto
id|return_overflow
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Determine the number of bytes to go back (p) and the number&n;&t;&t; * of bytes to copy (l). We use an optimized algorithm in which&n;&t;&t; * we first calculate log2(current destination position in sb),&n;&t;&t; * which allows determination of l and p in O(1) rather than&n;&t;&t; * O(n). We just need an arch-optimized log2() function now.&n;&t;&t; */
id|lg
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
op_star
id|dest_ofs
op_minus
id|do_sb_start
op_minus
l_int|1
suffix:semicolon
id|i
op_ge
l_int|0x10
suffix:semicolon
id|i
op_rshift_assign
l_int|1
)paren
id|lg
op_increment
suffix:semicolon
multiline_comment|/* Get the phrase token into i. */
id|pt
op_assign
id|le16_to_cpup
c_func
(paren
id|cb
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Calculate starting position of the byte sequence in&n;&t;&t; * the destination using the fact that p = (pt &gt;&gt; (12 - lg)) + 1&n;&t;&t; * and make sure we don&squot;t go too far back.&n;&t;&t; */
id|dp_back_addr
op_assign
id|dp_addr
op_minus
(paren
id|pt
op_rshift
(paren
l_int|12
op_minus
id|lg
)paren
)paren
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|dp_back_addr
OL
id|dp_sb_start
)paren
r_goto
id|return_overflow
suffix:semicolon
multiline_comment|/* Now calculate the length of the byte sequence. */
id|length
op_assign
(paren
id|pt
op_amp
(paren
l_int|0xfff
op_rshift
id|lg
)paren
)paren
op_plus
l_int|3
suffix:semicolon
multiline_comment|/* Advance destination position and verify it is in range. */
op_star
id|dest_ofs
op_add_assign
id|length
suffix:semicolon
r_if
c_cond
(paren
op_star
id|dest_ofs
OG
id|do_sb_end
)paren
r_goto
id|return_overflow
suffix:semicolon
multiline_comment|/* The number of non-overlapping bytes. */
id|max_non_overlap
op_assign
id|dp_addr
op_minus
id|dp_back_addr
suffix:semicolon
r_if
c_cond
(paren
id|length
op_le
id|max_non_overlap
)paren
(brace
multiline_comment|/* The byte sequence doesn&squot;t overlap, just copy it. */
id|memcpy
c_func
(paren
id|dp_addr
comma
id|dp_back_addr
comma
id|length
)paren
suffix:semicolon
multiline_comment|/* Advance destination pointer. */
id|dp_addr
op_add_assign
id|length
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; * The byte sequence does overlap, copy non-overlapping&n;&t;&t;&t; * part and then do a slow byte by byte copy for the&n;&t;&t;&t; * overlapping part. Also, advance the destination&n;&t;&t;&t; * pointer.&n;&t;&t;&t; */
id|memcpy
c_func
(paren
id|dp_addr
comma
id|dp_back_addr
comma
id|max_non_overlap
)paren
suffix:semicolon
id|dp_addr
op_add_assign
id|max_non_overlap
suffix:semicolon
id|dp_back_addr
op_add_assign
id|max_non_overlap
suffix:semicolon
id|length
op_sub_assign
id|max_non_overlap
suffix:semicolon
r_while
c_loop
(paren
id|length
op_decrement
)paren
op_star
id|dp_addr
op_increment
op_assign
op_star
id|dp_back_addr
op_increment
suffix:semicolon
)brace
multiline_comment|/* Advance source position and continue with the next token. */
id|cb
op_add_assign
l_int|2
suffix:semicolon
)brace
multiline_comment|/* No tokens left in the current tag. Continue with the next tag. */
r_goto
id|do_next_tag
suffix:semicolon
id|return_overflow
suffix:colon
id|ntfs_error
c_func
(paren
l_int|NULL
comma
l_string|&quot;Failed. Returning -EOVERFLOW.&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|return_error
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_read_compressed_block - read a compressed block into the page cache&n; * @page:&t;locked page in the compression block(s) we need to read&n; *&n; * When we are called the page has already been verified to be locked and the&n; * attribute is known to be non-resident, not encrypted, but compressed.&n; *&n; * 1. Determine which compression block(s) @page is in.&n; * 2. Get hold of all pages corresponding to this/these compression block(s).&n; * 3. Read the (first) compression block.&n; * 4. Decompress it into the corresponding pages.&n; * 5. Throw the compressed data away and proceed to 3. for the next compression&n; *    block or return success if no more compression blocks left.&n; *&n; * Warning: We have to be careful what we do about existing pages. They might&n; * have been written to so that we would lose data if we were to just overwrite&n; * them with the out-of-date uncompressed data.&n; *&n; * FIXME: For PAGE_CACHE_SIZE &gt; cb_size we are not doing the Right Thing(TM) at&n; * the end of the file I think. We need to detect this case and zero the out&n; * of bounds remainder of the page in question and mark it as handled. At the&n; * moment we would just return -EIO on such a page. This bug will only become&n; * apparent if pages are above 8kiB and the NTFS volume only uses 512 byte&n; * clusters so is probably not going to be seen by anyone. Still this should&n; * be fixed. (AIA)&n; *&n; * FIXME: Again for PAGE_CACHE_SIZE &gt; cb_size we are screwing up both in&n; * handling sparse and compressed cbs. (AIA)&n; *&n; * FIXME: At the moment we don&squot;t do any zeroing out in the case that&n; * initialized_size is less than data_size. This should be safe because of the&n; * nature of the compression algorithm used. Just in case we check and output&n; * an error message in read inode if the two sizes are not equal for a&n; * compressed file. (AIA)&n; */
DECL|function|ntfs_read_compressed_block
r_int
id|ntfs_read_compressed_block
c_func
(paren
r_struct
id|page
op_star
id|page
)paren
(brace
r_struct
id|address_space
op_star
id|mapping
op_assign
id|page-&gt;mapping
suffix:semicolon
id|ntfs_inode
op_star
id|ni
op_assign
id|NTFS_I
c_func
(paren
id|mapping-&gt;host
)paren
suffix:semicolon
id|ntfs_volume
op_star
id|vol
op_assign
id|ni-&gt;vol
suffix:semicolon
r_struct
id|super_block
op_star
id|sb
op_assign
id|vol-&gt;sb
suffix:semicolon
id|run_list_element
op_star
id|rl
suffix:semicolon
r_int
r_int
id|block_size
op_assign
id|sb-&gt;s_blocksize
suffix:semicolon
r_int
r_char
id|block_size_bits
op_assign
id|sb-&gt;s_blocksize_bits
suffix:semicolon
id|u8
op_star
id|cb
comma
op_star
id|cb_pos
comma
op_star
id|cb_end
suffix:semicolon
r_struct
id|buffer_head
op_star
op_star
id|bhs
suffix:semicolon
r_int
r_int
id|offset
comma
id|index
op_assign
id|page-&gt;index
suffix:semicolon
id|u32
id|cb_size
op_assign
id|ni
op_member_access_from_pointer
id|_ICF
c_func
(paren
id|compression_block_size
)paren
suffix:semicolon
id|u64
id|cb_size_mask
op_assign
id|cb_size
op_minus
l_int|1UL
suffix:semicolon
id|VCN
id|vcn
suffix:semicolon
id|LCN
id|lcn
suffix:semicolon
multiline_comment|/* The first wanted vcn (minimum alignment is PAGE_CACHE_SIZE). */
id|VCN
id|start_vcn
op_assign
(paren
(paren
(paren
id|s64
)paren
id|index
op_lshift
id|PAGE_CACHE_SHIFT
)paren
op_amp
op_complement
id|cb_size_mask
)paren
op_rshift
id|vol-&gt;cluster_size_bits
suffix:semicolon
multiline_comment|/*&n;&t; * The first vcn after the last wanted vcn (minumum alignment is again&n;&t; * PAGE_CACHE_SIZE.&n;&t; */
id|VCN
id|end_vcn
op_assign
(paren
(paren
(paren
(paren
id|s64
)paren
(paren
id|index
op_plus
l_int|1UL
)paren
op_lshift
id|PAGE_CACHE_SHIFT
)paren
op_plus
id|cb_size
op_minus
l_int|1
)paren
op_amp
op_complement
id|cb_size_mask
)paren
op_rshift
id|vol-&gt;cluster_size_bits
suffix:semicolon
multiline_comment|/* Number of compression blocks (cbs) in the wanted vcn range. */
r_int
r_int
id|nr_cbs
op_assign
(paren
id|end_vcn
op_minus
id|start_vcn
)paren
op_lshift
id|vol-&gt;cluster_size_bits
op_rshift
id|ni
op_member_access_from_pointer
id|_ICF
c_func
(paren
id|compression_block_size_bits
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Number of pages required to store the uncompressed data from all&n;&t; * compression blocks (cbs) overlapping @page. Due to alignment&n;&t; * guarantees of start_vcn and end_vcn, no need to round up here.&n;&t; */
r_int
r_int
id|nr_pages
op_assign
(paren
id|end_vcn
op_minus
id|start_vcn
)paren
op_lshift
id|vol-&gt;cluster_size_bits
op_rshift
id|PAGE_CACHE_SHIFT
suffix:semicolon
r_int
r_int
id|xpage
comma
id|max_page
comma
id|cur_page
comma
id|cur_ofs
comma
id|i
suffix:semicolon
r_int
r_int
id|cb_clusters
comma
id|cb_max_ofs
suffix:semicolon
r_int
id|block
comma
id|max_block
comma
id|cb_max_page
comma
id|bhs_size
comma
id|nr_bhs
comma
id|err
op_assign
l_int|0
suffix:semicolon
r_struct
id|page
op_star
op_star
id|pages
suffix:semicolon
r_int
r_char
id|xpage_done
op_assign
l_int|0
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Entering, page-&gt;index = 0x%lx, cb_size = 0x%x, nr_pages = &quot;
l_string|&quot;%i.&quot;
comma
id|index
comma
id|cb_size
comma
id|nr_pages
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Bad things happen if we get here for anything that is not an&n;&t; * unnamed $DATA attribute.&n;&t; */
id|BUG_ON
c_func
(paren
id|ni-&gt;type
op_ne
id|AT_DATA
op_logical_or
id|ni-&gt;name_len
)paren
suffix:semicolon
id|pages
op_assign
id|kmalloc
c_func
(paren
id|nr_pages
op_star
r_sizeof
(paren
r_struct
id|page
op_star
)paren
comma
id|GFP_NOFS
)paren
suffix:semicolon
multiline_comment|/* Allocate memory to store the buffer heads we need. */
id|bhs_size
op_assign
id|cb_size
op_div
id|block_size
op_star
r_sizeof
(paren
r_struct
id|buffer_head
op_star
)paren
suffix:semicolon
id|bhs
op_assign
id|kmalloc
c_func
(paren
id|bhs_size
comma
id|GFP_NOFS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|pages
op_logical_or
op_logical_neg
id|bhs
)paren
)paren
(brace
id|kfree
c_func
(paren
id|bhs
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|pages
)paren
suffix:semicolon
id|SetPageError
c_func
(paren
id|page
)paren
suffix:semicolon
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Failed to allocate internal buffers.&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * We have already been given one page, this is the one we must do.&n;&t; * Once again, the alignment guarantees keep it simple.&n;&t; */
id|offset
op_assign
id|start_vcn
op_lshift
id|vol-&gt;cluster_size_bits
op_rshift
id|PAGE_CACHE_SHIFT
suffix:semicolon
id|xpage
op_assign
id|index
op_minus
id|offset
suffix:semicolon
id|pages
(braket
id|xpage
)braket
op_assign
id|page
suffix:semicolon
multiline_comment|/*&n;&t; * The remaining pages need to be allocated and inserted into the page&n;&t; * cache, alignment guarantees keep all the below much simpler. (-8&n;&t; */
id|max_page
op_assign
(paren
(paren
id|VFS_I
c_func
(paren
id|ni
)paren
op_member_access_from_pointer
id|i_size
op_plus
id|PAGE_CACHE_SIZE
op_minus
l_int|1
)paren
op_rshift
id|PAGE_CACHE_SHIFT
)paren
op_minus
id|offset
suffix:semicolon
r_if
c_cond
(paren
id|nr_pages
OL
id|max_page
)paren
id|max_page
op_assign
id|nr_pages
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|max_page
suffix:semicolon
id|i
op_increment
comma
id|offset
op_increment
)paren
(brace
r_if
c_cond
(paren
id|i
op_ne
id|xpage
)paren
id|pages
(braket
id|i
)braket
op_assign
id|grab_cache_page_nowait
c_func
(paren
id|mapping
comma
id|offset
)paren
suffix:semicolon
id|page
op_assign
id|pages
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|page
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * We only (re)read the page if it isn&squot;t already read&n;&t;&t;&t; * in and/or dirty or we would be losing data or at&n;&t;&t;&t; * least wasting our time.&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|PageDirty
c_func
(paren
id|page
)paren
op_logical_and
(paren
op_logical_neg
id|PageUptodate
c_func
(paren
id|page
)paren
op_logical_or
id|PageError
c_func
(paren
id|page
)paren
)paren
)paren
(brace
id|ClearPageError
c_func
(paren
id|page
)paren
suffix:semicolon
id|kmap
c_func
(paren
id|page
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
id|pages
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * We have the run list, and all the destination pages we need to fill.&n;&t; * Now read the first compression block.&n;&t; */
id|cur_page
op_assign
l_int|0
suffix:semicolon
id|cur_ofs
op_assign
l_int|0
suffix:semicolon
id|cb_clusters
op_assign
id|ni
op_member_access_from_pointer
id|_ICF
c_func
(paren
id|compression_block_clusters
)paren
suffix:semicolon
id|do_next_cb
suffix:colon
id|nr_cbs
op_decrement
suffix:semicolon
id|nr_bhs
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Read all cb buffer heads one cluster at a time. */
id|rl
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|vcn
op_assign
id|start_vcn
comma
id|start_vcn
op_add_assign
id|cb_clusters
suffix:semicolon
id|vcn
OL
id|start_vcn
suffix:semicolon
id|vcn
op_increment
)paren
(brace
id|BOOL
id|is_retry
op_assign
id|FALSE
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rl
)paren
(brace
id|lock_retry_remap
suffix:colon
id|down_read
c_func
(paren
op_amp
id|ni-&gt;run_list.lock
)paren
suffix:semicolon
id|rl
op_assign
id|ni-&gt;run_list.rl
suffix:semicolon
)brace
r_if
c_cond
(paren
id|likely
c_func
(paren
id|rl
op_ne
l_int|NULL
)paren
)paren
(brace
multiline_comment|/* Seek to element containing target vcn. */
r_while
c_loop
(paren
id|rl-&gt;length
op_logical_and
id|rl
(braket
l_int|1
)braket
dot
id|vcn
op_le
id|vcn
)paren
id|rl
op_increment
suffix:semicolon
id|lcn
op_assign
id|vcn_to_lcn
c_func
(paren
id|rl
comma
id|vcn
)paren
suffix:semicolon
)brace
r_else
id|lcn
op_assign
(paren
id|LCN
)paren
id|LCN_RL_NOT_MAPPED
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Reading vcn = 0x%Lx, lcn = 0x%Lx.&quot;
comma
(paren
r_int
r_int
)paren
id|vcn
comma
(paren
r_int
r_int
)paren
id|lcn
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lcn
OL
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * When we reach the first sparse cluster we have&n;&t;&t;&t; * finished with the cb.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|lcn
op_eq
id|LCN_HOLE
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|is_retry
op_logical_or
id|lcn
op_ne
id|LCN_RL_NOT_MAPPED
)paren
r_goto
id|rl_err
suffix:semicolon
id|is_retry
op_assign
id|TRUE
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Attempt to map run list, dropping lock for the&n;&t;&t;&t; * duration.&n;&t;&t;&t; */
id|up_read
c_func
(paren
op_amp
id|ni-&gt;run_list.lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|map_run_list
c_func
(paren
id|ni
comma
id|vcn
)paren
)paren
r_goto
id|lock_retry_remap
suffix:semicolon
r_goto
id|map_rl_err
suffix:semicolon
)brace
id|block
op_assign
id|lcn
op_lshift
id|vol-&gt;cluster_size_bits
op_rshift
id|block_size_bits
suffix:semicolon
multiline_comment|/* Read the lcn from device in chunks of block_size bytes. */
id|max_block
op_assign
id|block
op_plus
(paren
id|vol-&gt;cluster_size
op_rshift
id|block_size_bits
)paren
suffix:semicolon
r_do
(brace
id|ntfs_debug
c_func
(paren
l_string|&quot;block = 0x%x.&quot;
comma
id|block
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
(paren
id|bhs
(braket
id|nr_bhs
)braket
op_assign
id|sb_getblk
c_func
(paren
id|sb
comma
id|block
)paren
)paren
)paren
)paren
r_goto
id|getblk_err
suffix:semicolon
id|nr_bhs
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
op_increment
id|block
OL
id|max_block
)paren
suffix:semicolon
)brace
multiline_comment|/* Release the lock if we took it. */
r_if
c_cond
(paren
id|rl
)paren
id|up_read
c_func
(paren
op_amp
id|ni-&gt;run_list.lock
)paren
suffix:semicolon
multiline_comment|/* Setup and initiate io on all buffer heads. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr_bhs
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|buffer_head
op_star
id|tbh
op_assign
id|bhs
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|test_set_buffer_locked
c_func
(paren
id|tbh
)paren
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|buffer_uptodate
c_func
(paren
id|tbh
)paren
)paren
)paren
(brace
id|unlock_buffer
c_func
(paren
id|tbh
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|atomic_inc
c_func
(paren
op_amp
id|tbh-&gt;b_count
)paren
suffix:semicolon
id|tbh-&gt;b_end_io
op_assign
id|end_buffer_io_sync
suffix:semicolon
id|submit_bh
c_func
(paren
id|READ
comma
id|tbh
)paren
suffix:semicolon
)brace
multiline_comment|/* Wait for io completion on all buffer heads. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr_bhs
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|buffer_head
op_star
id|tbh
op_assign
id|bhs
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|buffer_uptodate
c_func
(paren
id|tbh
)paren
)paren
r_continue
suffix:semicolon
id|wait_on_buffer
c_func
(paren
id|tbh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|tbh
)paren
)paren
)paren
r_goto
id|read_err
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Get the compression buffer. We must not sleep any more&n;&t; * until we are finished with it.&n;&t; */
id|spin_lock
c_func
(paren
op_amp
id|ntfs_cb_lock
)paren
suffix:semicolon
id|cb
op_assign
id|ntfs_compression_buffer
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|cb
)paren
suffix:semicolon
id|cb_pos
op_assign
id|cb
suffix:semicolon
id|cb_end
op_assign
id|cb
op_plus
id|cb_size
suffix:semicolon
multiline_comment|/* Copy the buffer heads into the contiguous buffer. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr_bhs
suffix:semicolon
id|i
op_increment
)paren
(brace
id|memcpy
c_func
(paren
id|cb_pos
comma
id|bhs
(braket
id|i
)braket
op_member_access_from_pointer
id|b_data
comma
id|block_size
)paren
suffix:semicolon
id|cb_pos
op_add_assign
id|block_size
suffix:semicolon
)brace
multiline_comment|/* Just a precaution. */
r_if
c_cond
(paren
id|cb_pos
op_plus
l_int|2
op_le
id|cb
op_plus
id|cb_size
)paren
op_star
(paren
id|u16
op_star
)paren
id|cb_pos
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Reset cb_pos back to the beginning. */
id|cb_pos
op_assign
id|cb
suffix:semicolon
multiline_comment|/* We now have both source (if present) and destination. */
id|ntfs_debug
c_func
(paren
l_string|&quot;Successfully read the compression block.&quot;
)paren
suffix:semicolon
multiline_comment|/* The last page and maximum offset within it for the current cb. */
id|cb_max_page
op_assign
(paren
id|cur_page
op_lshift
id|PAGE_CACHE_SHIFT
)paren
op_plus
id|cur_ofs
op_plus
id|cb_size
suffix:semicolon
id|cb_max_ofs
op_assign
id|cb_max_page
op_amp
op_complement
id|PAGE_CACHE_MASK
suffix:semicolon
id|cb_max_page
op_rshift_assign
id|PAGE_CACHE_SHIFT
suffix:semicolon
multiline_comment|/* Catch end of file inside a compression block. */
r_if
c_cond
(paren
id|cb_max_page
OG
id|max_page
)paren
id|cb_max_page
op_assign
id|max_page
suffix:semicolon
r_if
c_cond
(paren
id|vcn
op_eq
id|start_vcn
op_minus
id|cb_clusters
)paren
(brace
multiline_comment|/* Sparse cb, zero out page range overlapping the cb. */
id|ntfs_debug
c_func
(paren
l_string|&quot;Found sparse compression block.&quot;
)paren
suffix:semicolon
multiline_comment|/* We can sleep from now on, so we drop lock. */
id|spin_unlock
c_func
(paren
op_amp
id|ntfs_cb_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cb_max_ofs
)paren
id|cb_max_page
op_decrement
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|cur_page
OL
id|cb_max_page
suffix:semicolon
id|cur_page
op_increment
)paren
(brace
id|page
op_assign
id|pages
(braket
id|cur_page
)braket
suffix:semicolon
r_if
c_cond
(paren
id|page
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * FIXME: Using clear_page() will become wrong&n;&t;&t;&t;&t; * when we get PAGE_CACHE_SIZE != PAGE_SIZE but&n;&t;&t;&t;&t; * for now there is no problem.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|likely
c_func
(paren
op_logical_neg
id|cur_ofs
)paren
)paren
id|clear_page
c_func
(paren
id|page_address
c_func
(paren
id|page
)paren
)paren
suffix:semicolon
r_else
id|memset
c_func
(paren
id|page_address
c_func
(paren
id|page
)paren
op_plus
id|cur_ofs
comma
l_int|0
comma
id|PAGE_CACHE_SIZE
op_minus
id|cur_ofs
)paren
suffix:semicolon
id|flush_dcache_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|kunmap
c_func
(paren
id|page
)paren
suffix:semicolon
id|SetPageUptodate
c_func
(paren
id|page
)paren
suffix:semicolon
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cur_page
op_eq
id|xpage
)paren
id|xpage_done
op_assign
l_int|1
suffix:semicolon
r_else
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
id|pages
(braket
id|cur_page
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
id|cb_pos
op_add_assign
id|PAGE_CACHE_SIZE
op_minus
id|cur_ofs
suffix:semicolon
id|cur_ofs
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|cb_pos
op_ge
id|cb_end
)paren
r_break
suffix:semicolon
)brace
multiline_comment|/* If we have a partial final page, deal with it now. */
r_if
c_cond
(paren
id|cb_max_ofs
op_logical_and
id|cb_pos
OL
id|cb_end
)paren
(brace
id|page
op_assign
id|pages
(braket
id|cur_page
)braket
suffix:semicolon
r_if
c_cond
(paren
id|page
)paren
id|memset
c_func
(paren
id|page_address
c_func
(paren
id|page
)paren
op_plus
id|cur_ofs
comma
l_int|0
comma
id|cb_max_ofs
op_minus
id|cur_ofs
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * No need to update cb_pos at this stage:&n;&t;&t;&t; *&t;cb_pos += cb_max_ofs - cur_ofs;&n;&t;&t;&t; */
id|cur_ofs
op_assign
id|cb_max_ofs
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|vcn
op_eq
id|start_vcn
)paren
(brace
multiline_comment|/* We can&squot;t sleep so we need two stages. */
r_int
r_int
id|cur2_page
op_assign
id|cur_page
suffix:semicolon
r_int
r_int
id|cur_ofs2
op_assign
id|cur_ofs
suffix:semicolon
id|u8
op_star
id|cb_pos2
op_assign
id|cb_pos
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Found uncompressed compression block.&quot;
)paren
suffix:semicolon
multiline_comment|/* Uncompressed cb, copy it to the destination pages. */
multiline_comment|/*&n;&t;&t; * TODO: As a big optimization, we could detect this case&n;&t;&t; * before we read all the pages and use block_read_full_page()&n;&t;&t; * on all full pages instead (we still have to treat partial&n;&t;&t; * pages especially but at least we are getting rid of the&n;&t;&t; * synchronous io for the majority of pages.&n;&t;&t; * Or if we choose not to do the read-ahead/-behind stuff, we&n;&t;&t; * could just return block_read_full_page(pages[xpage]) as long&n;&t;&t; * as PAGE_CACHE_SIZE &lt;= cb_size.&n;&t;&t; */
r_if
c_cond
(paren
id|cb_max_ofs
)paren
id|cb_max_page
op_decrement
suffix:semicolon
multiline_comment|/* First stage: copy data into destination pages. */
r_for
c_loop
(paren
suffix:semicolon
id|cur_page
OL
id|cb_max_page
suffix:semicolon
id|cur_page
op_increment
)paren
(brace
id|page
op_assign
id|pages
(braket
id|cur_page
)braket
suffix:semicolon
r_if
c_cond
(paren
id|page
)paren
id|memcpy
c_func
(paren
id|page_address
c_func
(paren
id|page
)paren
op_plus
id|cur_ofs
comma
id|cb_pos
comma
id|PAGE_CACHE_SIZE
op_minus
id|cur_ofs
)paren
suffix:semicolon
id|cb_pos
op_add_assign
id|PAGE_CACHE_SIZE
op_minus
id|cur_ofs
suffix:semicolon
id|cur_ofs
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|cb_pos
op_ge
id|cb_end
)paren
r_break
suffix:semicolon
)brace
multiline_comment|/* If we have a partial final page, deal with it now. */
r_if
c_cond
(paren
id|cb_max_ofs
op_logical_and
id|cb_pos
OL
id|cb_end
)paren
(brace
id|page
op_assign
id|pages
(braket
id|cur_page
)braket
suffix:semicolon
r_if
c_cond
(paren
id|page
)paren
id|memcpy
c_func
(paren
id|page_address
c_func
(paren
id|page
)paren
op_plus
id|cur_ofs
comma
id|cb_pos
comma
id|cb_max_ofs
op_minus
id|cur_ofs
)paren
suffix:semicolon
id|cb_pos
op_add_assign
id|cb_max_ofs
op_minus
id|cur_ofs
suffix:semicolon
id|cur_ofs
op_assign
id|cb_max_ofs
suffix:semicolon
)brace
multiline_comment|/* We can sleep from now on, so drop lock. */
id|spin_unlock
c_func
(paren
op_amp
id|ntfs_cb_lock
)paren
suffix:semicolon
multiline_comment|/* Second stage: finalize pages. */
r_for
c_loop
(paren
suffix:semicolon
id|cur2_page
OL
id|cb_max_page
suffix:semicolon
id|cur2_page
op_increment
)paren
(brace
id|page
op_assign
id|pages
(braket
id|cur2_page
)braket
suffix:semicolon
r_if
c_cond
(paren
id|page
)paren
(brace
id|flush_dcache_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|kunmap
c_func
(paren
id|page
)paren
suffix:semicolon
id|SetPageUptodate
c_func
(paren
id|page
)paren
suffix:semicolon
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cur2_page
op_eq
id|xpage
)paren
id|xpage_done
op_assign
l_int|1
suffix:semicolon
r_else
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
id|pages
(braket
id|cur2_page
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
id|cb_pos2
op_add_assign
id|PAGE_CACHE_SIZE
op_minus
id|cur_ofs2
suffix:semicolon
id|cur_ofs2
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|cb_pos2
op_ge
id|cb_end
)paren
r_break
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* Compressed cb, decompress it into the destination page(s). */
r_int
r_int
id|prev_cur_page
op_assign
id|cur_page
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Found compressed compression block.&quot;
)paren
suffix:semicolon
id|err
op_assign
id|ntfs_decompress
c_func
(paren
id|pages
comma
op_amp
id|cur_page
comma
op_amp
id|cur_ofs
comma
id|cb_max_page
comma
id|cb_max_ofs
comma
id|xpage
comma
op_amp
id|xpage_done
comma
id|cb_pos
comma
id|cb_size
op_minus
(paren
id|cb_pos
op_minus
id|cb
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * We can sleep from now on, lock already dropped by&n;&t;&t; * ntfs_decompress().&n;&t;&t; */
r_if
c_cond
(paren
id|err
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;ntfs_decompress() failed in inode &quot;
l_string|&quot;0x%lx with error code %i. Skipping &quot;
l_string|&quot;this compression block.&bslash;n&quot;
comma
id|ni-&gt;mft_no
comma
op_minus
id|err
)paren
suffix:semicolon
multiline_comment|/* Release the unfinished pages. */
r_for
c_loop
(paren
suffix:semicolon
id|prev_cur_page
OL
id|cur_page
suffix:semicolon
id|prev_cur_page
op_increment
)paren
(brace
id|page
op_assign
id|pages
(braket
id|prev_cur_page
)braket
suffix:semicolon
r_if
c_cond
(paren
id|page
)paren
(brace
r_if
c_cond
(paren
id|prev_cur_page
op_eq
id|xpage
op_logical_and
op_logical_neg
id|xpage_done
)paren
id|SetPageError
c_func
(paren
id|page
)paren
suffix:semicolon
id|flush_dcache_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|kunmap
c_func
(paren
id|page
)paren
suffix:semicolon
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|prev_cur_page
op_ne
id|xpage
)paren
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
id|pages
(braket
id|prev_cur_page
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
)brace
)brace
multiline_comment|/* Release the buffer heads. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr_bhs
suffix:semicolon
id|i
op_increment
)paren
id|brelse
c_func
(paren
id|bhs
(braket
id|i
)braket
)paren
suffix:semicolon
multiline_comment|/* Do we have more work to do? */
r_if
c_cond
(paren
id|nr_cbs
)paren
r_goto
id|do_next_cb
suffix:semicolon
multiline_comment|/* We no longer need the list of buffer heads. */
id|kfree
c_func
(paren
id|bhs
)paren
suffix:semicolon
multiline_comment|/* Clean up if we have any pages left. Should never happen. */
r_for
c_loop
(paren
id|cur_page
op_assign
l_int|0
suffix:semicolon
id|cur_page
OL
id|max_page
suffix:semicolon
id|cur_page
op_increment
)paren
(brace
id|page
op_assign
id|pages
(braket
id|cur_page
)braket
suffix:semicolon
r_if
c_cond
(paren
id|page
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Still have pages left! &quot;
l_string|&quot;Terminating them with extreme &quot;
l_string|&quot;prejudice.&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cur_page
op_eq
id|xpage
op_logical_and
op_logical_neg
id|xpage_done
)paren
id|SetPageError
c_func
(paren
id|page
)paren
suffix:semicolon
id|flush_dcache_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|kunmap
c_func
(paren
id|page
)paren
suffix:semicolon
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cur_page
op_ne
id|xpage
)paren
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
id|pages
(braket
id|cur_page
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
multiline_comment|/* We no longer need the list of pages. */
id|kfree
c_func
(paren
id|pages
)paren
suffix:semicolon
multiline_comment|/* If we have completed the requested page, we return success. */
r_if
c_cond
(paren
id|likely
c_func
(paren
id|xpage_done
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Failed. Returning error code %s.&quot;
comma
id|err
op_eq
op_minus
id|EOVERFLOW
ques
c_cond
l_string|&quot;EOVERFLOW&quot;
suffix:colon
(paren
op_logical_neg
id|err
ques
c_cond
l_string|&quot;EIO&quot;
suffix:colon
l_string|&quot;unkown error&quot;
)paren
)paren
suffix:semicolon
r_return
id|err
OL
l_int|0
ques
c_cond
id|err
suffix:colon
op_minus
id|EIO
suffix:semicolon
id|read_err
suffix:colon
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;IO error while reading compressed data.&quot;
)paren
suffix:semicolon
multiline_comment|/* Release the buffer heads. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr_bhs
suffix:semicolon
id|i
op_increment
)paren
id|brelse
c_func
(paren
id|bhs
(braket
id|i
)braket
)paren
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
id|map_rl_err
suffix:colon
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;map_run_list() failed. Cannot read compression &quot;
l_string|&quot;block.&quot;
)paren
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
id|rl_err
suffix:colon
id|up_read
c_func
(paren
op_amp
id|ni-&gt;run_list.lock
)paren
suffix:semicolon
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;vcn_to_lcn() failed. Cannot read compression &quot;
l_string|&quot;block.&quot;
)paren
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
id|getblk_err
suffix:colon
id|up_read
c_func
(paren
op_amp
id|ni-&gt;run_list.lock
)paren
suffix:semicolon
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;getblk() failed. Cannot read compression block.&quot;
)paren
suffix:semicolon
id|err_out
suffix:colon
id|kfree
c_func
(paren
id|bhs
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|cur_page
suffix:semicolon
id|i
OL
id|max_page
suffix:semicolon
id|i
op_increment
)paren
(brace
id|page
op_assign
id|pages
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|page
)paren
(brace
r_if
c_cond
(paren
id|i
op_eq
id|xpage
op_logical_and
op_logical_neg
id|xpage_done
)paren
id|SetPageError
c_func
(paren
id|page
)paren
suffix:semicolon
id|flush_dcache_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|kunmap
c_func
(paren
id|page
)paren
suffix:semicolon
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_ne
id|xpage
)paren
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
)brace
id|kfree
c_func
(paren
id|pages
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
eof
