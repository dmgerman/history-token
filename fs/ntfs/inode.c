multiline_comment|/*  inode.c&n; *&n; *  Copyright (C) 1995-1999 Martin von L&#xfffd;wis&n; *  Copyright (C) 1996 Albert D. Cahalan&n; *  Copyright (C) 1996-1997 R&#xfffd;gis Duchesne&n; *  Copyright (C) 1998 Joseph Malicki&n; *  Copyright (C) 1999 Steve Dodd&n; *  Copyright (C) 2000-2001 Anton Altaparmakov (AIA)&n; */
macro_line|#include &quot;ntfstypes.h&quot;
macro_line|#include &quot;ntfsendian.h&quot;
macro_line|#include &quot;struct.h&quot;
macro_line|#include &quot;inode.h&quot;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &quot;macros.h&quot;
macro_line|#include &quot;attr.h&quot;
macro_line|#include &quot;super.h&quot;
macro_line|#include &quot;dir.h&quot;
macro_line|#include &quot;support.h&quot;
macro_line|#include &quot;util.h&quot;
r_typedef
r_struct
(brace
DECL|member|recno
r_int
id|recno
suffix:semicolon
DECL|member|record
r_int
r_char
op_star
id|record
suffix:semicolon
DECL|typedef|ntfs_mft_record
)brace
id|ntfs_mft_record
suffix:semicolon
r_typedef
r_struct
(brace
DECL|member|size
r_int
id|size
suffix:semicolon
DECL|member|count
r_int
id|count
suffix:semicolon
DECL|member|records
id|ntfs_mft_record
op_star
id|records
suffix:semicolon
DECL|typedef|ntfs_disk_inode
)brace
id|ntfs_disk_inode
suffix:semicolon
DECL|function|ntfs_fill_mft_header
r_void
id|ntfs_fill_mft_header
c_func
(paren
id|ntfs_u8
op_star
id|mft
comma
r_int
id|record_size
comma
r_int
id|blocksize
comma
r_int
id|sequence_number
)paren
(brace
r_int
id|fixup_count
op_assign
id|record_size
op_div
id|blocksize
op_plus
l_int|1
suffix:semicolon
r_int
id|attr_offset
op_assign
(paren
l_int|0x2a
op_plus
(paren
l_int|2
op_star
id|fixup_count
)paren
op_plus
l_int|7
)paren
op_amp
op_complement
l_int|7
suffix:semicolon
r_int
id|fixup_offset
op_assign
l_int|0x2a
suffix:semicolon
id|NTFS_PUTU32
c_func
(paren
id|mft
op_plus
l_int|0x00
comma
l_int|0x454c4946
)paren
suffix:semicolon
multiline_comment|/* FILE */
id|NTFS_PUTU16
c_func
(paren
id|mft
op_plus
l_int|0x04
comma
l_int|0x2a
)paren
suffix:semicolon
multiline_comment|/* Offset to fixup. */
id|NTFS_PUTU16
c_func
(paren
id|mft
op_plus
l_int|0x06
comma
id|fixup_count
)paren
suffix:semicolon
multiline_comment|/* Number of fixups. */
id|NTFS_PUTU16
c_func
(paren
id|mft
op_plus
l_int|0x10
comma
id|sequence_number
)paren
suffix:semicolon
multiline_comment|/* Sequence number. */
id|NTFS_PUTU16
c_func
(paren
id|mft
op_plus
l_int|0x12
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Hard link count. */
id|NTFS_PUTU16
c_func
(paren
id|mft
op_plus
l_int|0x14
comma
id|attr_offset
)paren
suffix:semicolon
multiline_comment|/* Offset to attributes. */
id|NTFS_PUTU16
c_func
(paren
id|mft
op_plus
l_int|0x16
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Flags: 1 = In use,&n;&t;&t;&t;&t;&t;&t;&t;       2 = Directory. */
id|NTFS_PUTU32
c_func
(paren
id|mft
op_plus
l_int|0x18
comma
id|attr_offset
op_plus
l_int|0x08
)paren
suffix:semicolon
multiline_comment|/* Bytes in use. */
id|NTFS_PUTU32
c_func
(paren
id|mft
op_plus
l_int|0x1c
comma
id|record_size
)paren
suffix:semicolon
multiline_comment|/* Total allocated size. */
id|NTFS_PUTU16
c_func
(paren
id|mft
op_plus
id|fixup_offset
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Fixup word. */
id|NTFS_PUTU32
c_func
(paren
id|mft
op_plus
id|attr_offset
comma
l_int|0xffffffff
)paren
suffix:semicolon
multiline_comment|/* End marker. */
)brace
multiline_comment|/* Search in an inode an attribute by type and name. &n; * FIXME: Check that when attributes are inserted all attribute list&n; * attributes are expanded otherwise need to modify this function to deal&n; * with attribute lists. (AIA) */
DECL|function|ntfs_find_attr
id|ntfs_attribute
op_star
id|ntfs_find_attr
c_func
(paren
id|ntfs_inode
op_star
id|ino
comma
r_int
id|type
comma
r_char
op_star
id|name
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ino
)paren
(brace
id|ntfs_error
c_func
(paren
l_string|&quot;ntfs_find_attr: NO INODE!&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ino-&gt;attr_count
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|type
OL
id|ino-&gt;attrs
(braket
id|i
)braket
dot
id|type
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|type
op_eq
id|ino-&gt;attrs
(braket
id|i
)braket
dot
id|type
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|name
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ino-&gt;attrs
(braket
id|i
)braket
dot
id|name
)paren
r_return
id|ino-&gt;attrs
op_plus
id|i
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ino-&gt;attrs
(braket
id|i
)braket
dot
id|name
op_logical_and
op_logical_neg
id|ntfs_ua_strncmp
c_func
(paren
id|ino-&gt;attrs
(braket
id|i
)braket
dot
id|name
comma
id|name
comma
id|strlen
c_func
(paren
id|name
)paren
)paren
)paren
r_return
id|ino-&gt;attrs
op_plus
id|i
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* FIXME: Need better strategy to extend the MFT. */
DECL|function|ntfs_extend_mft
r_static
r_int
id|ntfs_extend_mft
c_func
(paren
id|ntfs_volume
op_star
id|vol
)paren
(brace
multiline_comment|/* Try to allocate at least 0.1% of the remaining disk space for&n;&t; * inodes. If the disk is almost full, make sure at least one inode is&n;&t; * requested. */
r_int
id|size
comma
id|rcount
comma
id|error
comma
id|block
suffix:semicolon
id|ntfs_attribute
op_star
id|mdata
comma
op_star
id|bmp
suffix:semicolon
id|ntfs_u8
op_star
id|buf
suffix:semicolon
id|ntfs_io
id|io
suffix:semicolon
id|mdata
op_assign
id|ntfs_find_attr
c_func
(paren
id|vol-&gt;mft_ino
comma
id|vol-&gt;at_data
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* First check whether there is uninitialized space. */
r_if
c_cond
(paren
id|mdata-&gt;allocated
OL
id|mdata-&gt;size
op_plus
id|vol-&gt;mft_recordsize
)paren
(brace
id|size
op_assign
id|ntfs_get_free_cluster_count
c_func
(paren
id|vol-&gt;bitmap
)paren
op_star
id|vol-&gt;clustersize
suffix:semicolon
id|block
op_assign
id|vol-&gt;mft_recordsize
suffix:semicolon
id|size
op_assign
id|max
c_func
(paren
id|size
op_div
l_int|1000
comma
id|mdata-&gt;size
op_plus
id|vol-&gt;mft_recordsize
)paren
suffix:semicolon
id|size
op_assign
(paren
(paren
id|size
op_plus
id|block
op_minus
l_int|1
)paren
op_div
id|block
)paren
op_star
id|block
suffix:semicolon
multiline_comment|/* Require this to be a single chunk. */
id|error
op_assign
id|ntfs_extend_attr
c_func
(paren
id|vol-&gt;mft_ino
comma
id|mdata
comma
op_amp
id|size
comma
id|ALLOC_REQUIRE_SIZE
)paren
suffix:semicolon
multiline_comment|/* Try again, now we have the largest available fragment. */
r_if
c_cond
(paren
id|error
op_eq
op_minus
id|ENOSPC
)paren
(brace
multiline_comment|/* Round down to multiple of mft record size. */
id|size
op_assign
(paren
id|size
op_div
id|vol-&gt;mft_recordsize
)paren
op_star
id|vol-&gt;mft_recordsize
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|size
)paren
r_return
op_minus
id|ENOSPC
suffix:semicolon
id|error
op_assign
id|ntfs_extend_attr
c_func
(paren
id|vol-&gt;mft_ino
comma
id|mdata
comma
op_amp
id|size
comma
id|ALLOC_REQUIRE_SIZE
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/* Even though we might have allocated more than needed, we initialize&n;&t; * only one record. */
id|mdata-&gt;size
op_add_assign
id|vol-&gt;mft_recordsize
suffix:semicolon
multiline_comment|/* Now extend the bitmap if necessary. */
id|rcount
op_assign
id|mdata-&gt;size
op_div
id|vol-&gt;mft_recordsize
suffix:semicolon
id|bmp
op_assign
id|ntfs_find_attr
c_func
(paren
id|vol-&gt;mft_ino
comma
id|vol-&gt;at_bitmap
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bmp-&gt;size
op_star
l_int|8
OL
id|rcount
)paren
(brace
multiline_comment|/* Less bits than MFT records. */
id|ntfs_u8
id|buf
(braket
l_int|1
)braket
suffix:semicolon
multiline_comment|/* Extend bitmap by one byte. */
id|error
op_assign
id|ntfs_resize_attr
c_func
(paren
id|vol-&gt;mft_ino
comma
id|bmp
comma
id|bmp-&gt;size
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
multiline_comment|/* Write the single byte. */
id|buf
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|io.fn_put
op_assign
id|ntfs_put
suffix:semicolon
id|io.fn_get
op_assign
id|ntfs_get
suffix:semicolon
id|io.param
op_assign
id|buf
suffix:semicolon
id|io.size
op_assign
l_int|1
suffix:semicolon
id|error
op_assign
id|ntfs_write_attr
c_func
(paren
id|vol-&gt;mft_ino
comma
id|vol-&gt;at_bitmap
comma
l_int|0
comma
id|bmp-&gt;size
op_minus
l_int|1
comma
op_amp
id|io
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
r_if
c_cond
(paren
id|io.size
op_ne
l_int|1
)paren
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/* Now fill in the MFT header for the new block. */
id|buf
op_assign
id|ntfs_calloc
c_func
(paren
id|vol-&gt;mft_recordsize
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buf
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|ntfs_fill_mft_header
c_func
(paren
id|buf
comma
id|vol-&gt;mft_recordsize
comma
id|vol-&gt;blocksize
comma
l_int|0
)paren
suffix:semicolon
id|ntfs_insert_fixups
c_func
(paren
id|buf
comma
id|vol-&gt;blocksize
)paren
suffix:semicolon
id|io.param
op_assign
id|buf
suffix:semicolon
id|io.size
op_assign
id|vol-&gt;mft_recordsize
suffix:semicolon
id|io.fn_put
op_assign
id|ntfs_put
suffix:semicolon
id|io.fn_get
op_assign
id|ntfs_get
suffix:semicolon
id|error
op_assign
id|ntfs_write_attr
c_func
(paren
id|vol-&gt;mft_ino
comma
id|vol-&gt;at_data
comma
l_int|0
comma
(paren
id|rcount
op_minus
l_int|1
)paren
op_star
id|vol-&gt;mft_recordsize
comma
op_amp
id|io
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
r_if
c_cond
(paren
id|io.size
op_ne
id|vol-&gt;mft_recordsize
)paren
r_return
op_minus
id|EIO
suffix:semicolon
id|error
op_assign
id|ntfs_update_inode
c_func
(paren
id|vol-&gt;mft_ino
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Insert all attributes from the record mftno of the MFT in the inode ino.&n; * FIXME: We should be performing structural consistency checks. (AIA)&n; * Return 0 on success or -errno on error. */
DECL|function|ntfs_insert_mft_attributes
r_static
r_int
id|ntfs_insert_mft_attributes
c_func
(paren
id|ntfs_inode
op_star
id|ino
comma
r_char
op_star
id|mft
comma
r_int
id|mftno
)paren
(brace
r_int
id|i
comma
id|error
comma
id|type
comma
id|len
suffix:semicolon
r_char
op_star
id|it
suffix:semicolon
multiline_comment|/* Check for duplicate. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ino-&gt;record_count
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|ino-&gt;records
(braket
id|i
)braket
op_eq
id|mftno
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* (re-)allocate space if necessary. */
r_if
c_cond
(paren
id|ino-&gt;record_count
op_mod
l_int|8
op_eq
l_int|0
)paren
(brace
r_int
op_star
r_new
suffix:semicolon
r_new
op_assign
id|ntfs_malloc
c_func
(paren
(paren
id|ino-&gt;record_count
op_plus
l_int|8
)paren
op_star
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
r_new
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
id|ino-&gt;records
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ino-&gt;record_count
suffix:semicolon
id|i
op_increment
)paren
r_new
(braket
id|i
)braket
op_assign
id|ino-&gt;records
(braket
id|i
)braket
suffix:semicolon
id|ntfs_free
c_func
(paren
id|ino-&gt;records
)paren
suffix:semicolon
)brace
id|ino-&gt;records
op_assign
r_new
suffix:semicolon
)brace
id|ino-&gt;records
(braket
id|ino-&gt;record_count
)braket
op_assign
id|mftno
suffix:semicolon
id|ino-&gt;record_count
op_increment
suffix:semicolon
id|it
op_assign
id|mft
op_plus
id|NTFS_GETU16
c_func
(paren
id|mft
op_plus
l_int|0x14
)paren
suffix:semicolon
r_do
(brace
id|type
op_assign
id|NTFS_GETU32
c_func
(paren
id|it
)paren
suffix:semicolon
id|len
op_assign
id|NTFS_GETU32
c_func
(paren
id|it
op_plus
l_int|4
)paren
suffix:semicolon
r_if
c_cond
(paren
id|type
op_ne
op_minus
l_int|1
)paren
(brace
id|error
op_assign
id|ntfs_insert_attribute
c_func
(paren
id|ino
comma
id|it
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
)brace
id|it
op_add_assign
id|len
suffix:semicolon
)brace
r_while
c_loop
(paren
id|type
op_ne
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Attribute list ends with type -1. */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Read and insert all the attributes of an &squot;attribute list&squot; attribute.&n; * Return the number of remaining bytes in *plen. */
DECL|function|parse_attributes
r_static
r_int
id|parse_attributes
c_func
(paren
id|ntfs_inode
op_star
id|ino
comma
id|ntfs_u8
op_star
id|alist
comma
r_int
op_star
id|plen
)paren
(brace
r_char
op_star
id|mft
suffix:semicolon
r_int
id|mftno
comma
id|l
comma
id|error
suffix:semicolon
r_int
id|last_mft
op_assign
op_minus
l_int|1
suffix:semicolon
r_int
id|len
op_assign
op_star
id|plen
suffix:semicolon
id|mft
op_assign
id|ntfs_malloc
c_func
(paren
id|ino-&gt;vol-&gt;mft_recordsize
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mft
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_while
c_loop
(paren
id|len
OG
l_int|8
)paren
(brace
id|l
op_assign
id|NTFS_GETU16
c_func
(paren
id|alist
op_plus
l_int|4
)paren
suffix:semicolon
r_if
c_cond
(paren
id|l
OG
id|len
)paren
r_break
suffix:semicolon
multiline_comment|/* Process an attribute description. */
id|mftno
op_assign
id|NTFS_GETU32
c_func
(paren
id|alist
op_plus
l_int|0x10
)paren
suffix:semicolon
multiline_comment|/* FIXME: The mft reference (alist + 0x10) is __u64.&n;&t;&t;&t;* - Not a problem unless we encounter a huge partition.&n;&t;&t;&t;* - Should be consistency checking the sequence numbers&n;&t;&t;&t;*   though! This should maybe happen in &n;&t;&t;&t;*   ntfs_read_mft_record() itself and a hotfix could&n;&t;&t;&t;*   then occur there or the user notified to run&n;&t;&t;&t;*   ntfsck. (AIA) */
r_if
c_cond
(paren
id|mftno
op_ne
id|last_mft
)paren
(brace
id|last_mft
op_assign
id|mftno
suffix:semicolon
multiline_comment|/* FIXME: Avoid loading record if it&squot;s already&n;&t;&t;&t; * processed. */
id|error
op_assign
id|ntfs_read_mft_record
c_func
(paren
id|ino-&gt;vol
comma
id|mftno
comma
id|mft
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
id|error
op_assign
id|ntfs_insert_mft_attributes
c_func
(paren
id|ino
comma
id|mft
comma
id|mftno
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
)brace
id|len
op_sub_assign
id|l
suffix:semicolon
id|alist
op_add_assign
id|l
suffix:semicolon
)brace
id|ntfs_free
c_func
(paren
id|mft
)paren
suffix:semicolon
op_star
id|plen
op_assign
id|len
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ntfs_load_attributes
r_static
r_void
id|ntfs_load_attributes
c_func
(paren
id|ntfs_inode
op_star
id|ino
)paren
(brace
id|ntfs_attribute
op_star
id|alist
suffix:semicolon
r_int
id|datasize
suffix:semicolon
r_int
id|offset
comma
id|len
comma
id|delta
suffix:semicolon
r_char
op_star
id|buf
suffix:semicolon
id|ntfs_volume
op_star
id|vol
op_assign
id|ino-&gt;vol
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_FILE2
comma
l_string|&quot;load_attributes %x 1&bslash;n&quot;
comma
id|ino-&gt;i_number
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ntfs_insert_mft_attributes
c_func
(paren
id|ino
comma
id|ino-&gt;attr
comma
id|ino-&gt;i_number
)paren
)paren
r_return
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_FILE2
comma
l_string|&quot;load_attributes %x 2&bslash;n&quot;
comma
id|ino-&gt;i_number
)paren
suffix:semicolon
id|alist
op_assign
id|ntfs_find_attr
c_func
(paren
id|ino
comma
id|vol-&gt;at_attribute_list
comma
l_int|0
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_FILE2
comma
l_string|&quot;load_attributes %x 3&bslash;n&quot;
comma
id|ino-&gt;i_number
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|alist
)paren
r_return
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_FILE2
comma
l_string|&quot;load_attributes %x 4&bslash;n&quot;
comma
id|ino-&gt;i_number
)paren
suffix:semicolon
id|datasize
op_assign
id|alist-&gt;size
suffix:semicolon
r_if
c_cond
(paren
id|alist-&gt;resident
)paren
(brace
id|parse_attributes
c_func
(paren
id|ino
comma
id|alist-&gt;d.data
comma
op_amp
id|datasize
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|buf
op_assign
id|ntfs_malloc
c_func
(paren
l_int|1024
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buf
)paren
multiline_comment|/* FIXME: Should be passing error code to caller. (AIA) */
r_return
suffix:semicolon
id|delta
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|offset
op_assign
l_int|0
suffix:semicolon
id|datasize
suffix:semicolon
id|datasize
op_sub_assign
id|len
comma
id|offset
op_add_assign
id|len
)paren
(brace
id|ntfs_io
id|io
suffix:semicolon
id|io.fn_put
op_assign
id|ntfs_put
suffix:semicolon
id|io.fn_get
op_assign
l_int|0
suffix:semicolon
id|io.param
op_assign
id|buf
op_plus
id|delta
suffix:semicolon
id|io.size
op_assign
id|len
op_assign
id|min
c_func
(paren
id|datasize
comma
l_int|1024
op_minus
id|delta
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ntfs_read_attr
c_func
(paren
id|ino
comma
id|vol-&gt;at_attribute_list
comma
l_int|0
comma
id|offset
comma
op_amp
id|io
)paren
)paren
id|ntfs_error
c_func
(paren
l_string|&quot;error in load_attributes&bslash;n&quot;
)paren
suffix:semicolon
id|delta
op_add_assign
id|len
suffix:semicolon
id|parse_attributes
c_func
(paren
id|ino
comma
id|buf
comma
op_amp
id|delta
)paren
suffix:semicolon
r_if
c_cond
(paren
id|delta
)paren
multiline_comment|/* Move remaining bytes to buffer start. */
id|ntfs_memmove
c_func
(paren
id|buf
comma
id|buf
op_plus
id|len
op_minus
id|delta
comma
id|delta
)paren
suffix:semicolon
)brace
id|ntfs_debug
c_func
(paren
id|DEBUG_FILE2
comma
l_string|&quot;load_attributes %x 5&bslash;n&quot;
comma
id|ino-&gt;i_number
)paren
suffix:semicolon
id|ntfs_free
c_func
(paren
id|buf
)paren
suffix:semicolon
)brace
DECL|function|ntfs_init_inode
r_int
id|ntfs_init_inode
c_func
(paren
id|ntfs_inode
op_star
id|ino
comma
id|ntfs_volume
op_star
id|vol
comma
r_int
id|inum
)paren
(brace
r_char
op_star
id|buf
suffix:semicolon
r_int
id|error
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_FILE1
comma
l_string|&quot;Initializing inode %x&bslash;n&quot;
comma
id|inum
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vol
)paren
id|ntfs_error
c_func
(paren
l_string|&quot;NO VOLUME!&bslash;n&quot;
)paren
suffix:semicolon
id|ino-&gt;i_number
op_assign
id|inum
suffix:semicolon
id|ino-&gt;vol
op_assign
id|vol
suffix:semicolon
id|ino-&gt;attr
op_assign
id|buf
op_assign
id|ntfs_malloc
c_func
(paren
id|vol-&gt;mft_recordsize
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buf
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|error
op_assign
id|ntfs_read_mft_record
c_func
(paren
id|vol
comma
id|inum
comma
id|ino-&gt;attr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
l_string|&quot;Init inode: %x failed&bslash;n&quot;
comma
id|inum
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
id|ntfs_debug
c_func
(paren
id|DEBUG_FILE2
comma
l_string|&quot;Init inode: got mft %x&bslash;n&quot;
comma
id|inum
)paren
suffix:semicolon
id|ino-&gt;sequence_number
op_assign
id|NTFS_GETU16
c_func
(paren
id|buf
op_plus
l_int|0x10
)paren
suffix:semicolon
id|ino-&gt;attr_count
op_assign
l_int|0
suffix:semicolon
id|ino-&gt;record_count
op_assign
l_int|0
suffix:semicolon
id|ino-&gt;records
op_assign
l_int|0
suffix:semicolon
id|ino-&gt;attrs
op_assign
l_int|0
suffix:semicolon
id|ntfs_load_attributes
c_func
(paren
id|ino
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_FILE2
comma
l_string|&quot;Init inode: done %x&bslash;n&quot;
comma
id|inum
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ntfs_clear_inode
r_void
id|ntfs_clear_inode
c_func
(paren
id|ntfs_inode
op_star
id|ino
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ino-&gt;attr
)paren
(brace
id|ntfs_error
c_func
(paren
l_string|&quot;ntfs_clear_inode: double free&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|ntfs_free
c_func
(paren
id|ino-&gt;attr
)paren
suffix:semicolon
id|ino-&gt;attr
op_assign
l_int|0
suffix:semicolon
id|ntfs_free
c_func
(paren
id|ino-&gt;records
)paren
suffix:semicolon
id|ino-&gt;records
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ino-&gt;attr_count
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|ino-&gt;attrs
(braket
id|i
)braket
dot
id|name
)paren
id|ntfs_free
c_func
(paren
id|ino-&gt;attrs
(braket
id|i
)braket
dot
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ino-&gt;attrs
(braket
id|i
)braket
dot
id|resident
)paren
(brace
r_if
c_cond
(paren
id|ino-&gt;attrs
(braket
id|i
)braket
dot
id|d.data
)paren
id|ntfs_free
c_func
(paren
id|ino-&gt;attrs
(braket
id|i
)braket
dot
id|d.data
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|ino-&gt;attrs
(braket
id|i
)braket
dot
id|d.r.runlist
)paren
id|ntfs_free
c_func
(paren
id|ino-&gt;attrs
(braket
id|i
)braket
dot
id|d.r.runlist
)paren
suffix:semicolon
)brace
)brace
id|ntfs_free
c_func
(paren
id|ino-&gt;attrs
)paren
suffix:semicolon
id|ino-&gt;attrs
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Check and fixup a MFT record. */
DECL|function|ntfs_check_mft_record
r_int
id|ntfs_check_mft_record
c_func
(paren
id|ntfs_volume
op_star
id|vol
comma
r_char
op_star
id|record
)paren
(brace
r_return
id|ntfs_fixup_record
c_func
(paren
id|vol
comma
id|record
comma
l_string|&quot;FILE&quot;
comma
id|vol-&gt;mft_recordsize
)paren
suffix:semicolon
)brace
multiline_comment|/* Return (in result) the value indicating the next available attribute &n; * chunk number. Works for inodes w/o extension records only. */
DECL|function|ntfs_allocate_attr_number
r_int
id|ntfs_allocate_attr_number
c_func
(paren
id|ntfs_inode
op_star
id|ino
comma
r_int
op_star
id|result
)paren
(brace
r_if
c_cond
(paren
id|ino-&gt;record_count
op_ne
l_int|1
)paren
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
op_star
id|result
op_assign
id|NTFS_GETU16
c_func
(paren
id|ino-&gt;attr
op_plus
l_int|0x28
)paren
suffix:semicolon
id|NTFS_PUTU16
c_func
(paren
id|ino-&gt;attr
op_plus
l_int|0x28
comma
(paren
op_star
id|result
)paren
op_plus
l_int|1
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Find the location of an attribute in the inode. A name of NULL indicates&n; * unnamed attributes. Return pointer to attribute or NULL if not found. */
DECL|function|ntfs_get_attr
r_char
op_star
id|ntfs_get_attr
c_func
(paren
id|ntfs_inode
op_star
id|ino
comma
r_int
id|attr
comma
r_char
op_star
id|name
)paren
(brace
multiline_comment|/* Location of first attribute. */
r_char
op_star
id|it
op_assign
id|ino-&gt;attr
op_plus
id|NTFS_GETU16
c_func
(paren
id|ino-&gt;attr
op_plus
l_int|0x14
)paren
suffix:semicolon
r_int
id|type
suffix:semicolon
r_int
id|len
suffix:semicolon
multiline_comment|/* Only check for magic DWORD here, fixup should have happened before.*/
r_if
c_cond
(paren
op_logical_neg
id|IS_MFT_RECORD
c_func
(paren
id|ino-&gt;attr
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_do
(brace
id|type
op_assign
id|NTFS_GETU32
c_func
(paren
id|it
)paren
suffix:semicolon
id|len
op_assign
id|NTFS_GETU16
c_func
(paren
id|it
op_plus
l_int|4
)paren
suffix:semicolon
multiline_comment|/* We found the attribute type. Is the name correct, too? */
r_if
c_cond
(paren
id|type
op_eq
id|attr
)paren
(brace
r_int
id|namelen
op_assign
id|NTFS_GETU8
c_func
(paren
id|it
op_plus
l_int|9
)paren
suffix:semicolon
r_char
op_star
id|name_it
comma
op_star
id|n
op_assign
id|name
suffix:semicolon
multiline_comment|/* Match given name and attribute name if present.&n;&t;&t;&t;   Make sure attribute name is Unicode. */
r_if
c_cond
(paren
op_logical_neg
id|name
)paren
(brace
r_goto
id|check_namelen
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|namelen
)paren
(brace
r_for
c_loop
(paren
id|name_it
op_assign
id|it
op_plus
id|NTFS_GETU16
c_func
(paren
id|it
op_plus
l_int|10
)paren
suffix:semicolon
id|namelen
suffix:semicolon
id|n
op_increment
comma
id|name_it
op_add_assign
l_int|2
comma
id|namelen
op_decrement
)paren
r_if
c_cond
(paren
op_star
id|name_it
op_ne
op_star
id|n
op_logical_or
id|name_it
(braket
l_int|1
)braket
)paren
r_break
suffix:semicolon
id|check_namelen
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|namelen
)paren
r_break
suffix:semicolon
)brace
)brace
id|it
op_add_assign
id|len
suffix:semicolon
)brace
r_while
c_loop
(paren
id|type
op_ne
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* List of attributes ends with type -1. */
r_if
c_cond
(paren
id|type
op_eq
op_minus
l_int|1
)paren
r_return
l_int|0
suffix:semicolon
r_return
id|it
suffix:semicolon
)brace
DECL|function|ntfs_get_attr_size
r_int
id|ntfs_get_attr_size
c_func
(paren
id|ntfs_inode
op_star
id|ino
comma
r_int
id|type
comma
r_char
op_star
id|name
)paren
(brace
id|ntfs_attribute
op_star
id|attr
op_assign
id|ntfs_find_attr
c_func
(paren
id|ino
comma
id|type
comma
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|attr
)paren
r_return
l_int|0
suffix:semicolon
r_return
id|attr-&gt;size
suffix:semicolon
)brace
DECL|function|ntfs_attr_is_resident
r_int
id|ntfs_attr_is_resident
c_func
(paren
id|ntfs_inode
op_star
id|ino
comma
r_int
id|type
comma
r_char
op_star
id|name
)paren
(brace
id|ntfs_attribute
op_star
id|attr
op_assign
id|ntfs_find_attr
c_func
(paren
id|ino
comma
id|type
comma
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|attr
)paren
r_return
l_int|0
suffix:semicolon
r_return
id|attr-&gt;resident
suffix:semicolon
)brace
multiline_comment|/*&n; * A run is coded as a type indicator, an unsigned length, and a signed cluster&n; * offset.&n; * . To save space, length and offset are fields of variable length. The low&n; *   nibble of the type indicates the width of the length :), the high nibble&n; *   the width of the offset.&n; * . The first offset is relative to cluster 0, later offsets are relative to&n; *   the previous cluster.&n; *&n; * This function decodes a run. Length is an output parameter, data and cluster&n; * are in/out parameters.&n; */
DECL|function|ntfs_decompress_run
r_int
id|ntfs_decompress_run
c_func
(paren
r_int
r_char
op_star
op_star
id|data
comma
r_int
op_star
id|length
comma
id|ntfs_cluster_t
op_star
id|cluster
comma
r_int
op_star
id|ctype
)paren
(brace
r_int
r_char
id|type
op_assign
op_star
(paren
op_star
id|data
)paren
op_increment
suffix:semicolon
op_star
id|ctype
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|type
op_amp
l_int|0xF
)paren
(brace
r_case
l_int|1
suffix:colon
op_star
id|length
op_assign
id|NTFS_GETS8
c_func
(paren
op_star
id|data
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
op_star
id|length
op_assign
id|NTFS_GETS16
c_func
(paren
op_star
id|data
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
op_star
id|length
op_assign
id|NTFS_GETS24
c_func
(paren
op_star
id|data
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
op_star
id|length
op_assign
id|NTFS_GETS32
c_func
(paren
op_star
id|data
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* Note: cases 5-8 are probably pointless to code, since how&n;&t;&t; * many runs &gt; 4GB of length are there? At the most, cases 5&n;&t;&t; * and 6 are probably necessary, and would also require making&n;&t;&t; * length 64-bit throughout. */
r_default
suffix:colon
id|ntfs_error
c_func
(paren
l_string|&quot;Can&squot;t decode run type field %x&bslash;n&quot;
comma
id|type
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|length
OL
l_int|0
)paren
(brace
id|ntfs_error
c_func
(paren
l_string|&quot;Negative run length decoded&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
op_star
id|data
op_add_assign
(paren
id|type
op_amp
l_int|0xF
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|type
op_amp
l_int|0xF0
)paren
(brace
r_case
l_int|0
suffix:colon
op_star
id|ctype
op_assign
l_int|2
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x10
suffix:colon
op_star
id|cluster
op_add_assign
id|NTFS_GETS8
c_func
(paren
op_star
id|data
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x20
suffix:colon
op_star
id|cluster
op_add_assign
id|NTFS_GETS16
c_func
(paren
op_star
id|data
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x30
suffix:colon
op_star
id|cluster
op_add_assign
id|NTFS_GETS24
c_func
(paren
op_star
id|data
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x40
suffix:colon
op_star
id|cluster
op_add_assign
id|NTFS_GETS32
c_func
(paren
op_star
id|data
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#if 0 /* Keep for future, in case ntfs_cluster_t ever becomes 64bit. */
r_case
l_int|0x50
suffix:colon
op_star
id|cluster
op_add_assign
id|NTFS_GETS40
c_func
(paren
op_star
id|data
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x60
suffix:colon
op_star
id|cluster
op_add_assign
id|NTFS_GETS48
c_func
(paren
op_star
id|data
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x70
suffix:colon
op_star
id|cluster
op_add_assign
id|NTFS_GETS56
c_func
(paren
op_star
id|data
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x80
suffix:colon
op_star
id|cluster
op_add_assign
id|NTFS_GETS64
c_func
(paren
op_star
id|data
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
r_default
suffix:colon
id|ntfs_error
c_func
(paren
l_string|&quot;Can&squot;t decode run type field %x&bslash;n&quot;
comma
id|type
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
op_star
id|data
op_add_assign
(paren
id|type
op_rshift
l_int|4
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * FIXME: ntfs_readwrite_attr() has the effect of writing @dest to @offset of&n; * the attribute value of the attribute @attr in the in memory inode @ino.&n; * If the attribute value of @attr is non-resident the value&squot;s contents at&n; * @offset are actually written to disk (from @dest). The on disk mft record&n; * describing the non-resident attribute value is not updated!&n; * If the attribute value is resident then the value is written only in&n; * memory. The on disk mft record containing the value is not written to disk.&n; * A possible fix would be to call ntfs_update_inode() before returning. (AIA)&n; */
multiline_comment|/* Reads l bytes of the attribute (attr, name) of ino starting at offset on&n; * vol into buf. Returns the number of bytes read in the ntfs_io struct.&n; * Returns 0 on success, errno on failure */
DECL|function|ntfs_readwrite_attr
r_int
id|ntfs_readwrite_attr
c_func
(paren
id|ntfs_inode
op_star
id|ino
comma
id|ntfs_attribute
op_star
id|attr
comma
r_int
id|offset
comma
id|ntfs_io
op_star
id|dest
)paren
(brace
r_int
id|rnum
suffix:semicolon
id|ntfs_cluster_t
id|cluster
comma
id|s_cluster
comma
id|vcn
comma
id|len
suffix:semicolon
r_int
id|l
comma
id|chunk
comma
id|copied
suffix:semicolon
r_int
id|s_vcn
suffix:semicolon
r_int
id|clustersize
suffix:semicolon
r_int
id|error
suffix:semicolon
id|clustersize
op_assign
id|ino-&gt;vol-&gt;clustersize
suffix:semicolon
id|l
op_assign
id|dest-&gt;size
suffix:semicolon
r_if
c_cond
(paren
id|l
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|dest-&gt;do_read
)paren
(brace
multiline_comment|/* If read _starts_ beyond end of stream, return nothing. */
r_if
c_cond
(paren
id|offset
op_ge
id|attr-&gt;size
)paren
(brace
id|dest-&gt;size
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* If read _extends_ beyond end of stream, return as much&n;&t;&t; * initialised data as we have. */
r_if
c_cond
(paren
id|offset
op_plus
id|l
op_ge
id|attr-&gt;size
)paren
id|l
op_assign
id|dest-&gt;size
op_assign
id|attr-&gt;size
op_minus
id|offset
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Fixed by CSA: If writing beyond end, extend attribute. */
multiline_comment|/* If write extends beyond _allocated_ size, extend attrib. */
r_if
c_cond
(paren
id|offset
op_plus
id|l
OG
id|attr-&gt;allocated
)paren
(brace
id|error
op_assign
id|ntfs_resize_attr
c_func
(paren
id|ino
comma
id|attr
comma
id|offset
op_plus
id|l
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/* The amount of initialised data has increased: update. */
multiline_comment|/* FIXME: Shouldn&squot;t we zero-out the section between the old&n;&t;&t; * &t;  initialised length and the write start? */
r_if
c_cond
(paren
id|offset
op_plus
id|l
OG
id|attr-&gt;initialized
)paren
(brace
id|attr-&gt;initialized
op_assign
id|offset
op_plus
id|l
suffix:semicolon
id|attr-&gt;size
op_assign
id|offset
op_plus
id|l
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|attr-&gt;resident
)paren
(brace
r_if
c_cond
(paren
id|dest-&gt;do_read
)paren
id|dest
op_member_access_from_pointer
id|fn_put
c_func
(paren
id|dest
comma
(paren
id|ntfs_u8
op_star
)paren
id|attr-&gt;d.data
op_plus
id|offset
comma
id|l
)paren
suffix:semicolon
r_else
id|dest
op_member_access_from_pointer
id|fn_get
c_func
(paren
(paren
id|ntfs_u8
op_star
)paren
id|attr-&gt;d.data
op_plus
id|offset
comma
id|dest
comma
id|l
)paren
suffix:semicolon
id|dest-&gt;size
op_assign
id|l
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Read uninitialized data. */
r_if
c_cond
(paren
id|offset
op_ge
id|attr-&gt;initialized
op_logical_and
id|dest-&gt;do_read
)paren
r_return
id|ntfs_read_zero
c_func
(paren
id|dest
comma
id|l
)paren
suffix:semicolon
r_if
c_cond
(paren
id|offset
op_plus
id|l
OG
id|attr-&gt;initialized
op_logical_and
id|dest-&gt;do_read
)paren
(brace
id|dest-&gt;size
op_assign
id|chunk
op_assign
id|offset
op_plus
id|l
op_minus
id|attr-&gt;initialized
suffix:semicolon
id|error
op_assign
id|ntfs_readwrite_attr
c_func
(paren
id|ino
comma
id|attr
comma
id|offset
comma
id|dest
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
r_return
id|ntfs_read_zero
c_func
(paren
id|dest
comma
id|l
op_minus
id|chunk
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|attr-&gt;compressed
)paren
(brace
r_if
c_cond
(paren
id|dest-&gt;do_read
)paren
r_return
id|ntfs_read_compressed
c_func
(paren
id|ino
comma
id|attr
comma
id|offset
comma
id|dest
)paren
suffix:semicolon
r_else
r_return
id|ntfs_write_compressed
c_func
(paren
id|ino
comma
id|attr
comma
id|offset
comma
id|dest
)paren
suffix:semicolon
)brace
id|vcn
op_assign
l_int|0
suffix:semicolon
id|s_vcn
op_assign
id|offset
op_div
id|clustersize
suffix:semicolon
r_for
c_loop
(paren
id|rnum
op_assign
l_int|0
suffix:semicolon
id|rnum
OL
id|attr-&gt;d.r.len
op_logical_and
id|vcn
op_plus
id|attr-&gt;d.r.runlist
(braket
id|rnum
)braket
dot
id|len
op_le
id|s_vcn
suffix:semicolon
id|rnum
op_increment
)paren
id|vcn
op_add_assign
id|attr-&gt;d.r.runlist
(braket
id|rnum
)braket
dot
id|len
suffix:semicolon
r_if
c_cond
(paren
id|rnum
op_eq
id|attr-&gt;d.r.len
)paren
multiline_comment|/*FIXME: Should extend runlist. */
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
id|copied
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|l
)paren
(brace
id|s_vcn
op_assign
id|offset
op_div
id|clustersize
suffix:semicolon
id|cluster
op_assign
id|attr-&gt;d.r.runlist
(braket
id|rnum
)braket
dot
id|cluster
suffix:semicolon
id|len
op_assign
id|attr-&gt;d.r.runlist
(braket
id|rnum
)braket
dot
id|len
suffix:semicolon
id|s_cluster
op_assign
id|cluster
op_plus
id|s_vcn
op_minus
id|vcn
suffix:semicolon
id|chunk
op_assign
id|min
c_func
(paren
(paren
id|vcn
op_plus
id|len
)paren
op_star
id|clustersize
op_minus
id|offset
comma
id|l
)paren
suffix:semicolon
id|dest-&gt;size
op_assign
id|chunk
suffix:semicolon
id|error
op_assign
id|ntfs_getput_clusters
c_func
(paren
id|ino-&gt;vol
comma
id|s_cluster
comma
id|offset
op_minus
id|s_vcn
op_star
id|clustersize
comma
id|dest
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|ntfs_error
c_func
(paren
l_string|&quot;Read/write error&bslash;n&quot;
)paren
suffix:semicolon
id|dest-&gt;size
op_assign
id|copied
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
id|l
op_sub_assign
id|chunk
suffix:semicolon
id|copied
op_add_assign
id|chunk
suffix:semicolon
id|offset
op_add_assign
id|chunk
suffix:semicolon
r_if
c_cond
(paren
id|l
op_logical_and
id|offset
op_ge
(paren
(paren
id|vcn
op_plus
id|len
)paren
op_star
id|clustersize
)paren
)paren
(brace
id|rnum
op_increment
suffix:semicolon
id|vcn
op_add_assign
id|len
suffix:semicolon
id|cluster
op_assign
id|attr-&gt;d.r.runlist
(braket
id|rnum
)braket
dot
id|cluster
suffix:semicolon
id|len
op_assign
id|attr-&gt;d.r.runlist
(braket
id|rnum
)braket
dot
id|len
suffix:semicolon
)brace
)brace
id|dest-&gt;size
op_assign
id|copied
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ntfs_read_attr
r_int
id|ntfs_read_attr
c_func
(paren
id|ntfs_inode
op_star
id|ino
comma
r_int
id|type
comma
r_char
op_star
id|name
comma
r_int
id|offset
comma
id|ntfs_io
op_star
id|buf
)paren
(brace
id|ntfs_attribute
op_star
id|attr
suffix:semicolon
id|buf-&gt;do_read
op_assign
l_int|1
suffix:semicolon
id|attr
op_assign
id|ntfs_find_attr
c_func
(paren
id|ino
comma
id|type
comma
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|attr
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_return
id|ntfs_readwrite_attr
c_func
(paren
id|ino
comma
id|attr
comma
id|offset
comma
id|buf
)paren
suffix:semicolon
)brace
DECL|function|ntfs_write_attr
r_int
id|ntfs_write_attr
c_func
(paren
id|ntfs_inode
op_star
id|ino
comma
r_int
id|type
comma
r_char
op_star
id|name
comma
r_int
id|offset
comma
id|ntfs_io
op_star
id|buf
)paren
(brace
id|ntfs_attribute
op_star
id|attr
suffix:semicolon
id|buf-&gt;do_read
op_assign
l_int|0
suffix:semicolon
id|attr
op_assign
id|ntfs_find_attr
c_func
(paren
id|ino
comma
id|type
comma
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|attr
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_return
id|ntfs_readwrite_attr
c_func
(paren
id|ino
comma
id|attr
comma
id|offset
comma
id|buf
)paren
suffix:semicolon
)brace
DECL|function|ntfs_vcn_to_lcn
r_int
id|ntfs_vcn_to_lcn
c_func
(paren
id|ntfs_inode
op_star
id|ino
comma
r_int
id|vcn
)paren
(brace
r_int
id|rnum
suffix:semicolon
id|ntfs_attribute
op_star
id|data
suffix:semicolon
id|data
op_assign
id|ntfs_find_attr
c_func
(paren
id|ino
comma
id|ino-&gt;vol-&gt;at_data
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* It&squot;s hard to give an error code. */
r_if
c_cond
(paren
op_logical_neg
id|data
op_logical_or
id|data-&gt;resident
op_logical_or
id|data-&gt;compressed
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|data-&gt;size
op_le
id|vcn
op_star
id|ino-&gt;vol-&gt;clustersize
)paren
r_return
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* For Linux, block number 0 represents a hole.&n;&t; * Hopefully, nobody will attempt to bmap $Boot. */
r_if
c_cond
(paren
id|data-&gt;initialized
op_le
id|vcn
op_star
id|ino-&gt;vol-&gt;clustersize
)paren
r_return
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|rnum
op_assign
l_int|0
suffix:semicolon
id|rnum
OL
id|data-&gt;d.r.len
op_logical_and
id|vcn
op_ge
id|data-&gt;d.r.runlist
(braket
id|rnum
)braket
dot
id|len
suffix:semicolon
id|rnum
op_increment
)paren
id|vcn
op_sub_assign
id|data-&gt;d.r.runlist
(braket
id|rnum
)braket
dot
id|len
suffix:semicolon
r_return
id|data-&gt;d.r.runlist
(braket
id|rnum
)braket
dot
id|cluster
op_plus
id|vcn
suffix:semicolon
)brace
DECL|function|allocate_store
r_static
r_int
id|allocate_store
c_func
(paren
id|ntfs_volume
op_star
id|vol
comma
id|ntfs_disk_inode
op_star
id|store
comma
r_int
id|count
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|store-&gt;count
OG
id|count
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|store-&gt;size
OL
id|count
)paren
(brace
id|ntfs_mft_record
op_star
id|n
op_assign
id|ntfs_malloc
c_func
(paren
(paren
id|count
op_plus
l_int|4
)paren
op_star
r_sizeof
(paren
id|ntfs_mft_record
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|n
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
id|store-&gt;size
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|store-&gt;size
suffix:semicolon
id|i
op_increment
)paren
id|n
(braket
id|i
)braket
op_assign
id|store-&gt;records
(braket
id|i
)braket
suffix:semicolon
id|ntfs_free
c_func
(paren
id|store-&gt;records
)paren
suffix:semicolon
)brace
id|store-&gt;size
op_assign
id|count
op_plus
l_int|4
suffix:semicolon
id|store-&gt;records
op_assign
id|n
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
id|store-&gt;count
suffix:semicolon
id|i
OL
id|count
suffix:semicolon
id|i
op_increment
)paren
(brace
id|store-&gt;records
(braket
id|i
)braket
dot
id|record
op_assign
id|ntfs_malloc
c_func
(paren
id|vol-&gt;mft_recordsize
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|store-&gt;records
(braket
id|i
)braket
dot
id|record
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|store-&gt;count
op_increment
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|deallocate_store
r_static
r_void
id|deallocate_store
c_func
(paren
id|ntfs_disk_inode
op_star
id|store
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|store-&gt;count
suffix:semicolon
id|i
op_increment
)paren
id|ntfs_free
c_func
(paren
id|store-&gt;records
(braket
id|i
)braket
dot
id|record
)paren
suffix:semicolon
id|ntfs_free
c_func
(paren
id|store-&gt;records
)paren
suffix:semicolon
id|store-&gt;count
op_assign
id|store-&gt;size
op_assign
l_int|0
suffix:semicolon
id|store-&gt;records
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * layout_runs - compress runlist into mapping pairs array&n; * @attr:&t;attribute containing the runlist to compress&n; * @rec:&t;destination buffer to hold the mapping pairs array&n; * @offs:&t;current position in @rec (in/out variable)&n; * @size:&t;size of the buffer @rec&n; *&n; * layout_runs walks the runlist in @attr, compresses it and writes it out the&n; * resulting mapping pairs array into @rec (up to a maximum of @size bytes are&n; * written). On entry @offs is the offset in @rec at which to begin writting the&n; * mapping pairs array. On exit, it contains the offset in @rec of the first&n; * byte after the end of the mapping pairs array.&n; */
DECL|function|layout_runs
r_static
r_int
id|layout_runs
c_func
(paren
id|ntfs_attribute
op_star
id|attr
comma
r_char
op_star
id|rec
comma
r_int
op_star
id|offs
comma
r_int
id|size
)paren
(brace
r_int
id|i
comma
id|len
comma
id|offset
comma
id|coffs
suffix:semicolon
id|ntfs_cluster_t
id|cluster
comma
id|rclus
suffix:semicolon
id|ntfs_runlist
op_star
id|rl
op_assign
id|attr-&gt;d.r.runlist
suffix:semicolon
id|cluster
op_assign
l_int|0
suffix:semicolon
id|offset
op_assign
op_star
id|offs
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|attr-&gt;d.r.len
suffix:semicolon
id|i
op_increment
)paren
(brace
id|rclus
op_assign
id|rl
(braket
id|i
)braket
dot
id|cluster
op_minus
id|cluster
suffix:semicolon
id|len
op_assign
id|rl
(braket
id|i
)braket
dot
id|len
suffix:semicolon
id|rec
(braket
id|offset
)braket
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|offset
op_plus
l_int|9
OG
id|size
)paren
r_return
op_minus
id|E2BIG
suffix:semicolon
multiline_comment|/* It might still fit, but this&n;&t;&t;&t;&t;&t;* simplifies testing. */
multiline_comment|/* Run length is stored as signed number. */
r_if
c_cond
(paren
id|len
op_le
l_int|0x7F
)paren
(brace
id|NTFS_PUTU8
c_func
(paren
id|rec
op_plus
id|offset
op_plus
l_int|1
comma
id|len
)paren
suffix:semicolon
id|coffs
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|len
op_le
l_int|0x7FFF
)paren
(brace
id|NTFS_PUTU16
c_func
(paren
id|rec
op_plus
id|offset
op_plus
l_int|1
comma
id|len
)paren
suffix:semicolon
id|coffs
op_assign
l_int|2
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|len
op_le
l_int|0x7FFFFF
)paren
(brace
id|NTFS_PUTU24
c_func
(paren
id|rec
op_plus
id|offset
op_plus
l_int|1
comma
id|len
)paren
suffix:semicolon
id|coffs
op_assign
l_int|3
suffix:semicolon
)brace
r_else
(brace
id|NTFS_PUTU32
c_func
(paren
id|rec
op_plus
id|offset
op_plus
l_int|1
comma
id|len
)paren
suffix:semicolon
id|coffs
op_assign
l_int|4
suffix:semicolon
)brace
op_star
(paren
id|rec
op_plus
id|offset
)paren
op_or_assign
id|coffs
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|rl
(braket
id|i
)braket
dot
id|cluster
op_eq
id|MAX_CLUSTER_T
)paren
multiline_comment|/* Compressed run. */
multiline_comment|/* Nothing */
suffix:semicolon
r_else
r_if
c_cond
(paren
id|rclus
op_ge
op_minus
l_int|0x80
op_logical_and
id|rclus
op_le
l_int|0x7F
)paren
(brace
op_star
(paren
id|rec
op_plus
id|offset
)paren
op_or_assign
l_int|0x10
suffix:semicolon
id|NTFS_PUTS8
c_func
(paren
id|rec
op_plus
id|offset
op_plus
id|coffs
comma
id|rclus
)paren
suffix:semicolon
id|coffs
op_add_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|rclus
op_ge
op_minus
l_int|0x8000
op_logical_and
id|rclus
op_le
l_int|0x7FFF
)paren
(brace
op_star
(paren
id|rec
op_plus
id|offset
)paren
op_or_assign
l_int|0x20
suffix:semicolon
id|NTFS_PUTS16
c_func
(paren
id|rec
op_plus
id|offset
op_plus
id|coffs
comma
id|rclus
)paren
suffix:semicolon
id|coffs
op_add_assign
l_int|2
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|rclus
op_ge
op_minus
l_int|0x800000
op_logical_and
id|rclus
op_le
l_int|0x7FFFFF
)paren
(brace
op_star
(paren
id|rec
op_plus
id|offset
)paren
op_or_assign
l_int|0x30
suffix:semicolon
id|NTFS_PUTS24
c_func
(paren
id|rec
op_plus
id|offset
op_plus
id|coffs
comma
id|rclus
)paren
suffix:semicolon
id|coffs
op_add_assign
l_int|3
suffix:semicolon
)brace
r_else
macro_line|#if 0 /* In case ntfs_cluster_t ever becomes 64bit. */
r_if
c_cond
(paren
id|rclus
op_ge
op_minus
l_int|0x80000000LL
op_logical_and
id|rclus
op_le
l_int|0x7FFFFFFF
)paren
macro_line|#endif
(brace
op_star
(paren
id|rec
op_plus
id|offset
)paren
op_or_assign
l_int|0x40
suffix:semicolon
id|NTFS_PUTS32
c_func
(paren
id|rec
op_plus
id|offset
op_plus
id|coffs
comma
id|rclus
)paren
suffix:semicolon
id|coffs
op_add_assign
l_int|4
suffix:semicolon
)brace
macro_line|#if 0 /* For 64-bit ntfs_cluster_t */
r_else
r_if
c_cond
(paren
id|rclus
op_ge
op_minus
l_int|0x8000000000
op_logical_and
id|rclus
op_le
l_int|0x7FFFFFFFFF
)paren
(brace
op_star
(paren
id|rec
op_plus
id|offset
)paren
op_or_assign
l_int|0x50
suffix:semicolon
id|NTFS_PUTS40
c_func
(paren
id|rec
op_plus
id|offset
op_plus
id|coffs
comma
id|rclus
)paren
suffix:semicolon
id|coffs
op_add_assign
l_int|5
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|rclus
op_ge
op_minus
l_int|0x800000000000
op_logical_and
id|rclus
op_le
l_int|0x7FFFFFFFFFFF
)paren
(brace
op_star
(paren
id|rec
op_plus
id|offset
)paren
op_or_assign
l_int|0x60
suffix:semicolon
id|NTFS_PUTS48
c_func
(paren
id|rec
op_plus
id|offset
op_plus
id|coffs
comma
id|rclus
)paren
suffix:semicolon
id|coffs
op_add_assign
l_int|6
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|rclus
op_ge
op_minus
l_int|0x80000000000000
op_logical_and
id|rclus
op_le
l_int|0x7FFFFFFFFFFFFF
)paren
(brace
op_star
(paren
id|rec
op_plus
id|offset
)paren
op_or_assign
l_int|0x70
suffix:semicolon
id|NTFS_PUTS56
c_func
(paren
id|rec
op_plus
id|offset
op_plus
id|coffs
comma
id|rclus
)paren
suffix:semicolon
id|coffs
op_add_assign
l_int|7
suffix:semicolon
)brace
r_else
(brace
op_star
(paren
id|rec
op_plus
id|offset
)paren
op_or_assign
l_int|0x80
suffix:semicolon
id|NTFS_PUTS64
c_func
(paren
id|rec
op_plus
id|offset
op_plus
id|coffs
comma
id|rclus
)paren
suffix:semicolon
id|coffs
op_add_assign
l_int|8
suffix:semicolon
)brace
macro_line|#endif
id|offset
op_add_assign
id|coffs
suffix:semicolon
r_if
c_cond
(paren
id|rl
(braket
id|i
)braket
dot
id|cluster
)paren
id|cluster
op_assign
id|rl
(braket
id|i
)braket
dot
id|cluster
suffix:semicolon
)brace
r_if
c_cond
(paren
id|offset
op_ge
id|size
)paren
r_return
op_minus
id|E2BIG
suffix:semicolon
multiline_comment|/* Terminating null. */
op_star
(paren
id|rec
op_plus
id|offset
op_increment
)paren
op_assign
l_int|0
suffix:semicolon
op_star
id|offs
op_assign
id|offset
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|count_runs
r_static
r_void
id|count_runs
c_func
(paren
id|ntfs_attribute
op_star
id|attr
comma
r_char
op_star
id|buf
)paren
(brace
id|ntfs_u32
id|first
comma
id|count
comma
id|last
comma
id|i
suffix:semicolon
id|first
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|count
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|attr-&gt;d.r.len
suffix:semicolon
id|i
op_increment
)paren
id|count
op_add_assign
id|attr-&gt;d.r.runlist
(braket
id|i
)braket
dot
id|len
suffix:semicolon
id|last
op_assign
id|first
op_plus
id|count
op_minus
l_int|1
suffix:semicolon
id|NTFS_PUTU64
c_func
(paren
id|buf
op_plus
l_int|0x10
comma
id|first
)paren
suffix:semicolon
id|NTFS_PUTU64
c_func
(paren
id|buf
op_plus
l_int|0x18
comma
id|last
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * layout_attr - convert in memory attribute to on disk attribute record&n; * @attr:&t;in memory attribute to convert&n; * @buf:&t;destination buffer for on disk attribute record&n; * @size:&t;size of the destination buffer&n; * @psize:&t;size of converted on disk attribute record (out variable)&n; *&n; * layout_attr takes the attribute @attr and converts it into the appropriate&n; * on disk structure, writing it into @buf (up to @size bytes are written).&n; * On return, @psize contains the actual size of the on disk attribute written&n; * into @buf.&n; */
DECL|function|layout_attr
r_static
r_int
id|layout_attr
c_func
(paren
id|ntfs_attribute
op_star
id|attr
comma
r_char
op_star
id|buf
comma
r_int
id|size
comma
r_int
op_star
id|psize
)paren
(brace
r_int
id|asize
comma
id|error
suffix:semicolon
r_if
c_cond
(paren
id|size
OL
l_int|10
)paren
r_return
op_minus
id|E2BIG
suffix:semicolon
id|NTFS_PUTU32
c_func
(paren
id|buf
comma
id|attr-&gt;type
)paren
suffix:semicolon
multiline_comment|/* Fill in length later. */
id|NTFS_PUTU8
c_func
(paren
id|buf
op_plus
l_int|8
comma
id|attr-&gt;resident
ques
c_cond
l_int|0
suffix:colon
l_int|1
)paren
suffix:semicolon
id|NTFS_PUTU8
c_func
(paren
id|buf
op_plus
l_int|9
comma
id|attr-&gt;namelen
)paren
suffix:semicolon
multiline_comment|/* Fill in offset to name later. */
id|NTFS_PUTU16
c_func
(paren
id|buf
op_plus
l_int|0xA
comma
l_int|0
)paren
suffix:semicolon
id|NTFS_PUTU16
c_func
(paren
id|buf
op_plus
l_int|0xC
comma
id|attr-&gt;compressed
)paren
suffix:semicolon
multiline_comment|/* Assign attribute instance. */
id|NTFS_PUTU16
c_func
(paren
id|buf
op_plus
l_int|0xE
comma
id|attr-&gt;attrno
)paren
suffix:semicolon
r_if
c_cond
(paren
id|attr-&gt;resident
)paren
(brace
r_if
c_cond
(paren
id|size
OL
id|attr-&gt;size
op_plus
l_int|0x18
op_plus
id|attr-&gt;namelen
)paren
r_return
op_minus
id|E2BIG
suffix:semicolon
id|asize
op_assign
l_int|0x18
suffix:semicolon
id|NTFS_PUTU32
c_func
(paren
id|buf
op_plus
l_int|0x10
comma
id|attr-&gt;size
)paren
suffix:semicolon
id|NTFS_PUTU16
c_func
(paren
id|buf
op_plus
l_int|0x16
comma
id|attr-&gt;indexed
)paren
suffix:semicolon
r_if
c_cond
(paren
id|attr-&gt;name
)paren
(brace
id|ntfs_memcpy
c_func
(paren
id|buf
op_plus
id|asize
comma
id|attr-&gt;name
comma
l_int|2
op_star
id|attr-&gt;namelen
)paren
suffix:semicolon
id|NTFS_PUTU16
c_func
(paren
id|buf
op_plus
l_int|0xA
comma
id|asize
)paren
suffix:semicolon
id|asize
op_add_assign
l_int|2
op_star
id|attr-&gt;namelen
suffix:semicolon
id|asize
op_assign
(paren
id|asize
op_plus
l_int|7
)paren
op_amp
op_complement
l_int|7
suffix:semicolon
)brace
id|NTFS_PUTU16
c_func
(paren
id|buf
op_plus
l_int|0x14
comma
id|asize
)paren
suffix:semicolon
id|ntfs_memcpy
c_func
(paren
id|buf
op_plus
id|asize
comma
id|attr-&gt;d.data
comma
id|attr-&gt;size
)paren
suffix:semicolon
id|asize
op_add_assign
id|attr-&gt;size
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* FIXME: fragments */
id|count_runs
c_func
(paren
id|attr
comma
id|buf
)paren
suffix:semicolon
multiline_comment|/* Offset to data is added later. */
id|NTFS_PUTU16
c_func
(paren
id|buf
op_plus
l_int|0x22
comma
id|attr-&gt;cengine
)paren
suffix:semicolon
id|NTFS_PUTU32
c_func
(paren
id|buf
op_plus
l_int|0x24
comma
l_int|0
)paren
suffix:semicolon
id|NTFS_PUTU64
c_func
(paren
id|buf
op_plus
l_int|0x28
comma
id|attr-&gt;allocated
)paren
suffix:semicolon
id|NTFS_PUTU64
c_func
(paren
id|buf
op_plus
l_int|0x30
comma
id|attr-&gt;size
)paren
suffix:semicolon
id|NTFS_PUTU64
c_func
(paren
id|buf
op_plus
l_int|0x38
comma
id|attr-&gt;initialized
)paren
suffix:semicolon
r_if
c_cond
(paren
id|attr-&gt;compressed
)paren
(brace
id|NTFS_PUTU64
c_func
(paren
id|buf
op_plus
l_int|0x40
comma
id|attr-&gt;compsize
)paren
suffix:semicolon
id|asize
op_assign
l_int|0x48
suffix:semicolon
)brace
r_else
id|asize
op_assign
l_int|0x40
suffix:semicolon
r_if
c_cond
(paren
id|attr-&gt;name
)paren
(brace
id|NTFS_PUTU16
c_func
(paren
id|buf
op_plus
l_int|0xA
comma
id|asize
)paren
suffix:semicolon
id|ntfs_memcpy
c_func
(paren
id|buf
op_plus
id|asize
comma
id|attr-&gt;name
comma
l_int|2
op_star
id|attr-&gt;namelen
)paren
suffix:semicolon
id|asize
op_add_assign
l_int|2
op_star
id|attr-&gt;namelen
suffix:semicolon
multiline_comment|/* SRD: you whaaa? - AIA: Align to next 8 byte boundary&n;&t;&t;&t; * as required by NTFS design and implementation. */
id|asize
op_assign
(paren
id|asize
op_plus
l_int|7
)paren
op_amp
op_complement
l_int|7
suffix:semicolon
)brace
multiline_comment|/* asize points at the beginning of the data. */
id|NTFS_PUTU16
c_func
(paren
id|buf
op_plus
l_int|0x20
comma
id|asize
)paren
suffix:semicolon
id|error
op_assign
id|layout_runs
c_func
(paren
id|attr
comma
id|buf
comma
op_amp
id|asize
comma
id|size
)paren
suffix:semicolon
multiline_comment|/* Now asize points at the end of the data. */
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
)brace
id|asize
op_assign
(paren
id|asize
op_plus
l_int|7
)paren
op_amp
op_complement
l_int|7
suffix:semicolon
id|NTFS_PUTU32
c_func
(paren
id|buf
op_plus
l_int|4
comma
id|asize
)paren
suffix:semicolon
op_star
id|psize
op_assign
id|asize
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * layout_inode - convert an in memory inode into on disk mft record(s)&n; * @ino:&t;in memory inode to convert&n; * @store:&t;on disk inode, contain buffers for the on disk mft record(s)&n; *&n; * layout_inode takes the in memory inode @ino, converts it into a (sequence of)&n; * mft record(s) and writes them to the appropriate buffers in the @store.&n; *&n; * Return 0 on success,&n; * the required mft record count (&gt;0) if the inode does not fit,&n; * -ENOMEM if memory allocation problem or&n; * -EOPNOTSUP if beyond our capabilities.&n; */
DECL|function|layout_inode
r_int
id|layout_inode
c_func
(paren
id|ntfs_inode
op_star
id|ino
comma
id|ntfs_disk_inode
op_star
id|store
)paren
(brace
r_int
id|offset
comma
id|i
suffix:semicolon
id|ntfs_attribute
op_star
id|attr
suffix:semicolon
r_int
r_char
op_star
id|rec
suffix:semicolon
r_int
id|size
comma
id|psize
suffix:semicolon
r_int
id|error
suffix:semicolon
r_if
c_cond
(paren
id|ino-&gt;record_count
OG
l_int|1
)paren
(brace
id|ntfs_error
c_func
(paren
l_string|&quot;layout_inode: attribute lists not supported&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
id|error
op_assign
id|allocate_store
c_func
(paren
id|ino-&gt;vol
comma
id|store
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
id|rec
op_assign
id|store-&gt;records
(braket
l_int|0
)braket
dot
id|record
suffix:semicolon
id|size
op_assign
id|ino-&gt;vol-&gt;mft_recordsize
suffix:semicolon
id|store-&gt;records
(braket
l_int|0
)braket
dot
id|recno
op_assign
id|ino-&gt;records
(braket
l_int|0
)braket
suffix:semicolon
multiline_comment|/* Copy header. */
id|offset
op_assign
id|NTFS_GETU16
c_func
(paren
id|ino-&gt;attr
op_plus
l_int|0x14
)paren
suffix:semicolon
id|ntfs_memcpy
c_func
(paren
id|rec
comma
id|ino-&gt;attr
comma
id|offset
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ino-&gt;attr_count
suffix:semicolon
id|i
op_increment
)paren
(brace
id|attr
op_assign
id|ino-&gt;attrs
op_plus
id|i
suffix:semicolon
id|error
op_assign
id|layout_attr
c_func
(paren
id|attr
comma
id|rec
op_plus
id|offset
comma
id|size
op_minus
id|offset
comma
op_amp
id|psize
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
id|offset
op_add_assign
id|psize
suffix:semicolon
)brace
multiline_comment|/* Terminating attribute. */
r_if
c_cond
(paren
id|offset
op_plus
l_int|8
OL
id|size
)paren
(brace
id|NTFS_PUTU32
c_func
(paren
id|rec
op_plus
id|offset
comma
l_int|0xFFFFFFFF
)paren
suffix:semicolon
id|offset
op_add_assign
l_int|4
suffix:semicolon
id|NTFS_PUTU32
c_func
(paren
id|rec
op_plus
id|offset
comma
l_int|0
)paren
suffix:semicolon
id|offset
op_add_assign
l_int|4
suffix:semicolon
)brace
r_else
r_return
op_minus
id|E2BIG
suffix:semicolon
id|NTFS_PUTU32
c_func
(paren
id|rec
op_plus
l_int|0x18
comma
id|offset
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * FIXME: ntfs_update_inode() calls layout_inode() to create the mft record on&n; * disk structure corresponding to the inode @ino. After that, ntfs_write_attr()&n; * is called to write out the created mft record to disk.&n; * We shouldn&squot;t need to re-layout every single time we are updating an mft&n; * record. No wonder the ntfs driver is slow like hell. (AIA)&n; */
DECL|function|ntfs_update_inode
r_int
id|ntfs_update_inode
c_func
(paren
id|ntfs_inode
op_star
id|ino
)paren
(brace
r_int
id|error
suffix:semicolon
id|ntfs_disk_inode
id|store
suffix:semicolon
id|ntfs_io
id|io
suffix:semicolon
r_int
id|i
suffix:semicolon
id|store.count
op_assign
id|store.size
op_assign
l_int|0
suffix:semicolon
id|store.records
op_assign
l_int|0
suffix:semicolon
id|error
op_assign
id|layout_inode
c_func
(paren
id|ino
comma
op_amp
id|store
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_eq
op_minus
id|E2BIG
)paren
(brace
id|error
op_assign
id|ntfs_split_indexroot
c_func
(paren
id|ino
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
id|error
op_assign
id|layout_inode
c_func
(paren
id|ino
comma
op_amp
id|store
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|error
op_eq
op_minus
id|E2BIG
)paren
(brace
id|error
op_assign
id|ntfs_attr_allnonresident
c_func
(paren
id|ino
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
id|error
op_assign
id|layout_inode
c_func
(paren
id|ino
comma
op_amp
id|store
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|error
op_eq
op_minus
id|E2BIG
)paren
(brace
multiline_comment|/* FIXME: should try: introduce extension records */
id|ntfs_error
c_func
(paren
l_string|&quot;cannot handle saving inode %x&bslash;n&quot;
comma
id|ino-&gt;i_number
)paren
suffix:semicolon
id|deallocate_store
c_func
(paren
op_amp
id|store
)paren
suffix:semicolon
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
r_if
c_cond
(paren
id|error
)paren
(brace
id|deallocate_store
c_func
(paren
op_amp
id|store
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
id|io.fn_get
op_assign
id|ntfs_get
suffix:semicolon
id|io.fn_put
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|store.count
suffix:semicolon
id|i
op_increment
)paren
(brace
id|ntfs_insert_fixups
c_func
(paren
id|store.records
(braket
id|i
)braket
dot
id|record
comma
id|ino-&gt;vol-&gt;blocksize
)paren
suffix:semicolon
id|io.param
op_assign
id|store.records
(braket
id|i
)braket
dot
id|record
suffix:semicolon
id|io.size
op_assign
id|ino-&gt;vol-&gt;mft_recordsize
suffix:semicolon
multiline_comment|/* FIXME: Is this the right way? */
id|error
op_assign
id|ntfs_write_attr
c_func
(paren
id|ino-&gt;vol-&gt;mft_ino
comma
id|ino-&gt;vol-&gt;at_data
comma
l_int|0
comma
id|store.records
(braket
id|i
)braket
dot
id|recno
op_star
id|ino-&gt;vol-&gt;mft_recordsize
comma
op_amp
id|io
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_logical_or
id|io.size
op_ne
id|ino-&gt;vol-&gt;mft_recordsize
)paren
(brace
multiline_comment|/* Big trouble, partially written file. */
id|ntfs_error
c_func
(paren
l_string|&quot;Please unmount: Write error in inode %x&bslash;n&quot;
comma
id|ino-&gt;i_number
)paren
suffix:semicolon
id|deallocate_store
c_func
(paren
op_amp
id|store
)paren
suffix:semicolon
r_return
id|error
ques
c_cond
id|error
suffix:colon
op_minus
id|EIO
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ntfs_decompress
r_void
id|ntfs_decompress
c_func
(paren
r_int
r_char
op_star
id|dest
comma
r_int
r_char
op_star
id|src
comma
id|ntfs_size_t
id|l
)paren
(brace
r_int
id|head
comma
id|comp
suffix:semicolon
r_int
id|copied
op_assign
l_int|0
suffix:semicolon
r_int
r_char
op_star
id|stop
suffix:semicolon
r_int
id|bits
suffix:semicolon
r_int
id|tag
op_assign
l_int|0
suffix:semicolon
r_int
id|clear_pos
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|head
op_assign
id|NTFS_GETU16
c_func
(paren
id|src
)paren
op_amp
l_int|0xFFF
suffix:semicolon
multiline_comment|/* High bit indicates that compression was performed. */
id|comp
op_assign
id|NTFS_GETU16
c_func
(paren
id|src
)paren
op_amp
l_int|0x8000
suffix:semicolon
id|src
op_add_assign
l_int|2
suffix:semicolon
id|stop
op_assign
id|src
op_plus
id|head
suffix:semicolon
id|bits
op_assign
l_int|0
suffix:semicolon
id|clear_pos
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|head
op_eq
l_int|0
)paren
multiline_comment|/* Block is not used. */
r_return
suffix:semicolon
multiline_comment|/* FIXME: copied */
r_if
c_cond
(paren
op_logical_neg
id|comp
)paren
(brace
multiline_comment|/* uncompressible */
id|ntfs_memcpy
c_func
(paren
id|dest
comma
id|src
comma
l_int|0x1000
)paren
suffix:semicolon
id|dest
op_add_assign
l_int|0x1000
suffix:semicolon
id|copied
op_add_assign
l_int|0x1000
suffix:semicolon
id|src
op_add_assign
l_int|0x1000
suffix:semicolon
r_if
c_cond
(paren
id|l
op_eq
id|copied
)paren
r_return
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_while
c_loop
(paren
id|src
op_le
id|stop
)paren
(brace
r_if
c_cond
(paren
id|clear_pos
OG
l_int|4096
)paren
(brace
id|ntfs_error
c_func
(paren
l_string|&quot;Error 1 in decompress&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|bits
)paren
(brace
id|tag
op_assign
id|NTFS_GETU8
c_func
(paren
id|src
)paren
suffix:semicolon
id|bits
op_assign
l_int|8
suffix:semicolon
id|src
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|src
OG
id|stop
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tag
op_amp
l_int|1
)paren
(brace
r_int
id|i
comma
id|len
comma
id|delta
comma
id|code
comma
id|lmask
comma
id|dshift
suffix:semicolon
id|code
op_assign
id|NTFS_GETU16
c_func
(paren
id|src
)paren
suffix:semicolon
id|src
op_add_assign
l_int|2
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|clear_pos
)paren
(brace
id|ntfs_error
c_func
(paren
l_string|&quot;Error 2 in decompress&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
id|clear_pos
op_minus
l_int|1
comma
id|lmask
op_assign
l_int|0xFFF
comma
id|dshift
op_assign
l_int|12
suffix:semicolon
id|i
op_ge
l_int|0x10
suffix:semicolon
id|i
op_rshift_assign
l_int|1
)paren
(brace
id|lmask
op_rshift_assign
l_int|1
suffix:semicolon
id|dshift
op_decrement
suffix:semicolon
)brace
id|delta
op_assign
id|code
op_rshift
id|dshift
suffix:semicolon
id|len
op_assign
(paren
id|code
op_amp
id|lmask
)paren
op_plus
l_int|3
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
suffix:semicolon
id|i
op_increment
)paren
(brace
id|dest
(braket
id|clear_pos
)braket
op_assign
id|dest
(braket
id|clear_pos
op_minus
id|delta
op_minus
l_int|1
)braket
suffix:semicolon
id|clear_pos
op_increment
suffix:semicolon
id|copied
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|copied
op_eq
id|l
)paren
r_return
suffix:semicolon
)brace
)brace
r_else
(brace
id|dest
(braket
id|clear_pos
op_increment
)braket
op_assign
id|NTFS_GETU8
c_func
(paren
id|src
)paren
suffix:semicolon
id|src
op_increment
suffix:semicolon
id|copied
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|copied
op_eq
id|l
)paren
r_return
suffix:semicolon
)brace
id|tag
op_rshift_assign
l_int|1
suffix:semicolon
id|bits
op_decrement
suffix:semicolon
)brace
id|dest
op_add_assign
id|clear_pos
suffix:semicolon
)brace
)brace
multiline_comment|/* Caveat: No range checking in either ntfs_set_bit or ntfs_clear_bit. */
DECL|function|ntfs_set_bit
r_void
id|ntfs_set_bit
c_func
(paren
r_int
r_char
op_star
id|byte
comma
r_int
id|bit
)paren
(brace
id|byte
op_add_assign
(paren
id|bit
op_rshift
l_int|3
)paren
suffix:semicolon
id|bit
op_and_assign
l_int|7
suffix:semicolon
op_star
id|byte
op_or_assign
(paren
l_int|1
op_lshift
id|bit
)paren
suffix:semicolon
)brace
DECL|function|ntfs_clear_bit
r_void
id|ntfs_clear_bit
c_func
(paren
r_int
r_char
op_star
id|byte
comma
r_int
id|bit
)paren
(brace
id|byte
op_add_assign
(paren
id|bit
op_rshift
l_int|3
)paren
suffix:semicolon
id|bit
op_and_assign
l_int|7
suffix:semicolon
op_star
id|byte
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|bit
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_new_inode - allocate an mft record&n; * @vol:&t;volume to allocate an mft record on&n; * @result:&t;the mft record number allocated&n; *&n; * Allocate a new mft record on disk by finding the first free mft record&n; * and allocating it in the mft bitmap.&n; * Return 0 on success or -ERRNO on error.&n; *&n; * TODO(AIA): Implement mft bitmap caching. Replace function by race safe one.&n; */
DECL|function|ntfs_new_inode
r_static
r_int
id|ntfs_new_inode
c_func
(paren
id|ntfs_volume
op_star
id|vol
comma
r_int
op_star
id|result
)paren
(brace
r_int
id|byte
comma
id|error
suffix:semicolon
r_int
id|bit
suffix:semicolon
r_int
id|size
comma
id|length
suffix:semicolon
r_int
r_char
id|value
suffix:semicolon
id|ntfs_u8
op_star
id|buffer
suffix:semicolon
id|ntfs_io
id|io
suffix:semicolon
id|ntfs_attribute
op_star
id|data
suffix:semicolon
id|buffer
op_assign
id|ntfs_malloc
c_func
(paren
l_int|2048
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buffer
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|io.fn_put
op_assign
id|ntfs_put
suffix:semicolon
id|io.fn_get
op_assign
id|ntfs_get
suffix:semicolon
id|io.param
op_assign
id|buffer
suffix:semicolon
multiline_comment|/* FIXME: Bitmaps larger than 2048 bytes. */
id|io.size
op_assign
l_int|2048
suffix:semicolon
id|error
op_assign
id|ntfs_read_attr
c_func
(paren
id|vol-&gt;mft_ino
comma
id|vol-&gt;at_bitmap
comma
l_int|0
comma
l_int|0
comma
op_amp
id|io
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|ntfs_free
c_func
(paren
id|buffer
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
id|size
op_assign
id|io.size
suffix:semicolon
id|data
op_assign
id|ntfs_find_attr
c_func
(paren
id|vol-&gt;mft_ino
comma
id|vol-&gt;at_data
comma
l_int|0
)paren
suffix:semicolon
id|length
op_assign
id|data-&gt;size
op_div
id|vol-&gt;mft_recordsize
suffix:semicolon
multiline_comment|/* SRD: Start at byte 0: bits for system files _are_ already set in &n;&t; * bitmap. AIA: This includes the reserved entries as well. */
r_for
c_loop
(paren
id|byte
op_assign
l_int|0
suffix:semicolon
l_int|8
op_star
id|byte
OL
id|length
suffix:semicolon
id|byte
op_increment
)paren
(brace
id|value
op_assign
id|buffer
(braket
id|byte
)braket
suffix:semicolon
r_if
c_cond
(paren
id|value
op_eq
l_int|0xFF
)paren
r_continue
suffix:semicolon
r_for
c_loop
(paren
id|bit
op_assign
l_int|0
suffix:semicolon
(paren
id|bit
OL
l_int|8
)paren
op_logical_and
(paren
l_int|8
op_star
id|byte
op_plus
id|bit
OL
id|length
)paren
suffix:semicolon
id|bit
op_increment
comma
id|value
op_rshift_assign
l_int|1
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|value
op_amp
l_int|1
)paren
)paren
(brace
op_star
id|result
op_assign
id|byte
op_star
l_int|8
op_plus
id|bit
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* There is no free space. We must first extend the MFT. */
r_return
op_minus
id|ENOSPC
suffix:semicolon
)brace
DECL|function|add_mft_header
r_static
r_int
id|add_mft_header
c_func
(paren
id|ntfs_inode
op_star
id|ino
)paren
(brace
r_int
r_char
op_star
id|mft
suffix:semicolon
id|ntfs_volume
op_star
id|vol
op_assign
id|ino-&gt;vol
suffix:semicolon
id|mft
op_assign
id|ino-&gt;attr
suffix:semicolon
id|ntfs_bzero
c_func
(paren
id|mft
comma
id|vol-&gt;mft_recordsize
)paren
suffix:semicolon
id|ntfs_fill_mft_header
c_func
(paren
id|mft
comma
id|vol-&gt;mft_recordsize
comma
id|vol-&gt;blocksize
comma
id|ino-&gt;sequence_number
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* We need 0x48 bytes in total. */
DECL|function|add_standard_information
r_static
r_int
id|add_standard_information
c_func
(paren
id|ntfs_inode
op_star
id|ino
)paren
(brace
id|ntfs_time64_t
id|now
suffix:semicolon
r_char
id|data
(braket
l_int|0x30
)braket
suffix:semicolon
r_char
op_star
id|position
op_assign
id|data
suffix:semicolon
r_int
id|error
suffix:semicolon
id|ntfs_attribute
op_star
id|si
suffix:semicolon
id|now
op_assign
id|ntfs_now
c_func
(paren
)paren
suffix:semicolon
id|NTFS_PUTU64
c_func
(paren
id|position
op_plus
l_int|0x00
comma
id|now
)paren
suffix:semicolon
multiline_comment|/* File creation */
id|NTFS_PUTU64
c_func
(paren
id|position
op_plus
l_int|0x08
comma
id|now
)paren
suffix:semicolon
multiline_comment|/* Last modification */
id|NTFS_PUTU64
c_func
(paren
id|position
op_plus
l_int|0x10
comma
id|now
)paren
suffix:semicolon
multiline_comment|/* Last mod for MFT */
id|NTFS_PUTU64
c_func
(paren
id|position
op_plus
l_int|0x18
comma
id|now
)paren
suffix:semicolon
multiline_comment|/* Last access */
id|NTFS_PUTU64
c_func
(paren
id|position
op_plus
l_int|0x20
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* MSDOS file perms */
id|NTFS_PUTU64
c_func
(paren
id|position
op_plus
l_int|0x28
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* unknown */
id|error
op_assign
id|ntfs_create_attr
c_func
(paren
id|ino
comma
id|ino-&gt;vol-&gt;at_standard_information
comma
l_int|0
comma
id|data
comma
r_sizeof
(paren
id|data
)paren
comma
op_amp
id|si
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/* FIXME: Need to pass in the size of the file (Data size) as well as the&n; * allocated size for file data on disk (Allocated size). (AIA) */
DECL|function|add_filename
r_static
r_int
id|add_filename
c_func
(paren
id|ntfs_inode
op_star
id|ino
comma
id|ntfs_inode
op_star
id|dir
comma
r_const
r_int
r_char
op_star
id|filename
comma
r_int
id|length
comma
id|ntfs_u32
id|flags
)paren
(brace
r_int
r_char
op_star
id|position
suffix:semicolon
r_int
r_int
id|size
suffix:semicolon
id|ntfs_time64_t
id|now
suffix:semicolon
r_int
id|count
comma
id|error
suffix:semicolon
r_int
r_char
op_star
id|data
suffix:semicolon
id|ntfs_attribute
op_star
id|fn
suffix:semicolon
multiline_comment|/* Work out the size. */
id|size
op_assign
l_int|0x42
op_plus
l_int|2
op_star
id|length
suffix:semicolon
id|data
op_assign
id|ntfs_malloc
c_func
(paren
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|data
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|ntfs_bzero
c_func
(paren
id|data
comma
id|size
)paren
suffix:semicolon
multiline_comment|/* Search for a position. */
id|position
op_assign
id|data
suffix:semicolon
id|NTFS_PUTINUM
c_func
(paren
id|position
comma
id|dir
)paren
suffix:semicolon
multiline_comment|/* Inode num of dir */
id|now
op_assign
id|ntfs_now
c_func
(paren
)paren
suffix:semicolon
id|NTFS_PUTU64
c_func
(paren
id|position
op_plus
l_int|0x08
comma
id|now
)paren
suffix:semicolon
multiline_comment|/* File creation */
id|NTFS_PUTU64
c_func
(paren
id|position
op_plus
l_int|0x10
comma
id|now
)paren
suffix:semicolon
multiline_comment|/* Last modification */
id|NTFS_PUTU64
c_func
(paren
id|position
op_plus
l_int|0x18
comma
id|now
)paren
suffix:semicolon
multiline_comment|/* Last mod for MFT */
id|NTFS_PUTU64
c_func
(paren
id|position
op_plus
l_int|0x20
comma
id|now
)paren
suffix:semicolon
multiline_comment|/* Last access */
multiline_comment|/*NTFS_PUTU64(position + 0x28, 0);*/
multiline_comment|/* Allocated size */
multiline_comment|/*NTFS_PUTU64(position + 0x30, 0);*/
multiline_comment|/* Data size */
id|NTFS_PUTU32
c_func
(paren
id|position
op_plus
l_int|0x38
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* File flags */
multiline_comment|/*NTFS_PUTU32(position + 0x3c, 0);*/
multiline_comment|/* We don&squot;t use these&n;&t;&t;&t;&t;&t;&t;&t; * features yet. */
id|NTFS_PUTU8
c_func
(paren
id|position
op_plus
l_int|0x40
comma
id|length
)paren
suffix:semicolon
multiline_comment|/* Filename length */
id|NTFS_PUTU8
c_func
(paren
id|position
op_plus
l_int|0x41
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Only long name */
multiline_comment|/* FIXME: This is madness. We are defining the POSIX namespace&n;&t;&t; * for the filename here which can mean that the file will be&n;&t;&t; * invisible when in Windows NT/2k! )-: (AIA) */
id|position
op_add_assign
l_int|0x42
suffix:semicolon
r_for
c_loop
(paren
id|count
op_assign
l_int|0
suffix:semicolon
id|count
OL
id|length
suffix:semicolon
id|count
op_increment
)paren
(brace
id|NTFS_PUTU16
c_func
(paren
id|position
op_plus
l_int|2
op_star
id|count
comma
id|filename
(braket
id|count
)braket
)paren
suffix:semicolon
)brace
id|error
op_assign
id|ntfs_create_attr
c_func
(paren
id|ino
comma
id|ino-&gt;vol-&gt;at_file_name
comma
l_int|0
comma
id|data
comma
id|size
comma
op_amp
id|fn
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
id|error
op_assign
id|ntfs_dir_add
c_func
(paren
id|dir
comma
id|ino
comma
id|fn
)paren
suffix:semicolon
id|ntfs_free
c_func
(paren
id|data
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
DECL|function|add_security
r_int
id|add_security
c_func
(paren
id|ntfs_inode
op_star
id|ino
comma
id|ntfs_inode
op_star
id|dir
)paren
(brace
r_int
id|error
suffix:semicolon
r_char
op_star
id|buf
suffix:semicolon
r_int
id|size
suffix:semicolon
id|ntfs_attribute
op_star
id|attr
suffix:semicolon
id|ntfs_io
id|io
suffix:semicolon
id|ntfs_attribute
op_star
id|se
suffix:semicolon
id|attr
op_assign
id|ntfs_find_attr
c_func
(paren
id|dir
comma
id|ino-&gt;vol-&gt;at_security_descriptor
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|attr
)paren
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
multiline_comment|/* Need security in directory. */
id|size
op_assign
id|attr-&gt;size
suffix:semicolon
r_if
c_cond
(paren
id|size
OG
l_int|512
)paren
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
id|buf
op_assign
id|ntfs_malloc
c_func
(paren
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buf
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|io.fn_get
op_assign
id|ntfs_get
suffix:semicolon
id|io.fn_put
op_assign
id|ntfs_put
suffix:semicolon
id|io.param
op_assign
id|buf
suffix:semicolon
id|io.size
op_assign
id|size
suffix:semicolon
id|error
op_assign
id|ntfs_read_attr
c_func
(paren
id|dir
comma
id|ino-&gt;vol-&gt;at_security_descriptor
comma
l_int|0
comma
l_int|0
comma
op_amp
id|io
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
op_logical_and
id|io.size
op_ne
id|size
)paren
id|ntfs_error
c_func
(paren
l_string|&quot;wrong size in add_security&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|ntfs_free
c_func
(paren
id|buf
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/* FIXME: Consider ACL inheritance. */
id|error
op_assign
id|ntfs_create_attr
c_func
(paren
id|ino
comma
id|ino-&gt;vol-&gt;at_security_descriptor
comma
l_int|0
comma
id|buf
comma
id|size
comma
op_amp
id|se
)paren
suffix:semicolon
id|ntfs_free
c_func
(paren
id|buf
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
DECL|function|add_data
r_static
r_int
id|add_data
c_func
(paren
id|ntfs_inode
op_star
id|ino
comma
r_int
r_char
op_star
id|data
comma
r_int
id|length
)paren
(brace
r_int
id|error
suffix:semicolon
id|ntfs_attribute
op_star
id|da
suffix:semicolon
id|error
op_assign
id|ntfs_create_attr
c_func
(paren
id|ino
comma
id|ino-&gt;vol-&gt;at_data
comma
l_int|0
comma
id|data
comma
id|length
comma
op_amp
id|da
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/* We _could_ use &squot;dir&squot; to help optimise inode allocation. */
DECL|function|ntfs_alloc_inode
r_int
id|ntfs_alloc_inode
c_func
(paren
id|ntfs_inode
op_star
id|dir
comma
id|ntfs_inode
op_star
id|result
comma
r_const
r_char
op_star
id|filename
comma
r_int
id|namelen
comma
id|ntfs_u32
id|flags
)paren
(brace
id|ntfs_io
id|io
suffix:semicolon
r_int
id|error
suffix:semicolon
id|ntfs_u8
id|buffer
(braket
l_int|2
)braket
suffix:semicolon
id|ntfs_volume
op_star
id|vol
op_assign
id|dir-&gt;vol
suffix:semicolon
r_int
id|byte
comma
id|bit
suffix:semicolon
id|error
op_assign
id|ntfs_new_inode
c_func
(paren
id|vol
comma
op_amp
(paren
id|result-&gt;i_number
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_eq
op_minus
id|ENOSPC
)paren
(brace
id|error
op_assign
id|ntfs_extend_mft
c_func
(paren
id|vol
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
id|error
op_assign
id|ntfs_new_inode
c_func
(paren
id|vol
comma
op_amp
(paren
id|result-&gt;i_number
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|error
)paren
(brace
id|ntfs_error
c_func
(paren
l_string|&quot;ntfs_get_empty_inode: no free inodes&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
id|byte
op_assign
id|result-&gt;i_number
op_div
l_int|8
suffix:semicolon
id|bit
op_assign
id|result-&gt;i_number
op_amp
l_int|7
suffix:semicolon
id|io.fn_put
op_assign
id|ntfs_put
suffix:semicolon
id|io.fn_get
op_assign
id|ntfs_get
suffix:semicolon
id|io.param
op_assign
id|buffer
suffix:semicolon
id|io.size
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Set a single bit. */
id|error
op_assign
id|ntfs_read_attr
c_func
(paren
id|vol-&gt;mft_ino
comma
id|vol-&gt;at_bitmap
comma
l_int|0
comma
id|byte
comma
op_amp
id|io
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
r_if
c_cond
(paren
id|io.size
op_ne
l_int|1
)paren
r_return
op_minus
id|EIO
suffix:semicolon
id|ntfs_set_bit
c_func
(paren
id|buffer
comma
id|bit
)paren
suffix:semicolon
id|io.param
op_assign
id|buffer
suffix:semicolon
id|io.size
op_assign
l_int|1
suffix:semicolon
id|error
op_assign
id|ntfs_write_attr
c_func
(paren
id|vol-&gt;mft_ino
comma
id|vol-&gt;at_bitmap
comma
l_int|0
comma
id|byte
comma
op_amp
id|io
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
r_if
c_cond
(paren
id|io.size
op_ne
l_int|1
)paren
r_return
op_minus
id|EIO
suffix:semicolon
multiline_comment|/* FIXME: Should change $Mft on disk.&n;&t; * error = ntfs_update_inode(vol-&gt;mft_ino);&n;&t; * if (error)&n;&t; * &t;return error; &n;&t; * FIXME: And don&squot;t forget $MftMirr, though this probably belongs&n;&t; * in ntfs_update_inode() (or even deeper). (AIA) */
multiline_comment|/* Get the sequence number. */
id|io.param
op_assign
id|buffer
suffix:semicolon
id|io.size
op_assign
l_int|2
suffix:semicolon
id|error
op_assign
id|ntfs_read_attr
c_func
(paren
id|vol-&gt;mft_ino
comma
id|vol-&gt;at_data
comma
l_int|0
comma
id|result-&gt;i_number
op_star
id|vol-&gt;mft_recordsize
op_plus
l_int|0x10
comma
op_amp
id|io
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
multiline_comment|/* Increment the sequence number skipping zero. */
r_if
c_cond
(paren
id|NTFS_GETU16
c_func
(paren
id|buffer
)paren
op_eq
l_int|0xffff
)paren
id|result-&gt;sequence_number
op_assign
l_int|1
suffix:semicolon
r_else
id|result-&gt;sequence_number
op_assign
id|NTFS_GETU16
c_func
(paren
id|buffer
)paren
op_plus
l_int|1
suffix:semicolon
id|result-&gt;vol
op_assign
id|vol
suffix:semicolon
id|result-&gt;attr
op_assign
id|ntfs_malloc
c_func
(paren
id|vol-&gt;mft_recordsize
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|result-&gt;attr
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|result-&gt;attr_count
op_assign
l_int|0
suffix:semicolon
id|result-&gt;attrs
op_assign
l_int|0
suffix:semicolon
id|result-&gt;record_count
op_assign
l_int|1
suffix:semicolon
id|result-&gt;records
op_assign
id|ntfs_malloc
c_func
(paren
l_int|8
op_star
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|result-&gt;records
)paren
(brace
id|ntfs_free
c_func
(paren
id|result-&gt;attr
)paren
suffix:semicolon
id|result-&gt;attr
op_assign
l_int|0
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|result-&gt;records
(braket
l_int|0
)braket
op_assign
id|result-&gt;i_number
suffix:semicolon
id|error
op_assign
id|add_mft_header
c_func
(paren
id|result
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
id|error
op_assign
id|add_standard_information
c_func
(paren
id|result
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
id|error
op_assign
id|add_filename
c_func
(paren
id|result
comma
id|dir
comma
id|filename
comma
id|namelen
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
id|error
op_assign
id|add_security
c_func
(paren
id|result
comma
id|dir
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ntfs_alloc_file
r_int
id|ntfs_alloc_file
c_func
(paren
id|ntfs_inode
op_star
id|dir
comma
id|ntfs_inode
op_star
id|result
comma
r_char
op_star
id|filename
comma
r_int
id|namelen
)paren
(brace
r_int
id|error
op_assign
id|ntfs_alloc_inode
c_func
(paren
id|dir
comma
id|result
comma
id|filename
comma
id|namelen
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
id|error
op_assign
id|add_data
c_func
(paren
id|result
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
eof
