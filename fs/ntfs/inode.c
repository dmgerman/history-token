multiline_comment|/**&n; * inode.c - NTFS kernel inode handling. Part of the Linux-NTFS project.&n; *&n; * Copyright (c) 2001,2002 Anton Altaparmakov.&n; *&n; * This program/include file is free software; you can redistribute it and/or&n; * modify it under the terms of the GNU General Public License as published&n; * by the Free Software Foundation; either version 2 of the License, or&n; * (at your option) any later version.&n; *&n; * This program/include file is distributed in the hope that it will be &n; * useful, but WITHOUT ANY WARRANTY; without even the implied warranty &n; * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; * GNU General Public License for more details.&n; *&n; * You should have received a copy of the GNU General Public License&n; * along with this program (in the main directory of the Linux-NTFS &n; * distribution in the file COPYING); if not, write to the Free Software&n; * Foundation,Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA&n; */
macro_line|#include &lt;linux/pagemap.h&gt;
macro_line|#include &quot;ntfs.h&quot;
DECL|function|ntfs_alloc_big_inode
r_struct
id|inode
op_star
id|ntfs_alloc_big_inode
c_func
(paren
r_struct
id|super_block
op_star
id|sb
)paren
(brace
id|ntfs_inode
op_star
id|ni
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Entering.&quot;
)paren
suffix:semicolon
id|ni
op_assign
(paren
id|ntfs_inode
op_star
)paren
id|kmem_cache_alloc
c_func
(paren
id|ntfs_big_inode_cache
comma
id|SLAB_NOFS
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ni
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Allocation of NTFS big inode structure &quot;
l_string|&quot;failed.&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_return
id|VFS_I
c_func
(paren
id|ni
)paren
suffix:semicolon
)brace
DECL|function|ntfs_destroy_big_inode
r_void
id|ntfs_destroy_big_inode
c_func
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
id|ntfs_inode
op_star
id|ni
op_assign
id|NTFS_I
c_func
(paren
id|inode
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Entering.&quot;
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|atomic_read
c_func
(paren
op_amp
id|ni-&gt;mft_count
)paren
op_logical_or
op_logical_neg
id|atomic_dec_and_test
c_func
(paren
op_amp
id|ni-&gt;count
)paren
)paren
suffix:semicolon
id|kmem_cache_free
c_func
(paren
id|ntfs_big_inode_cache
comma
id|NTFS_I
c_func
(paren
id|inode
)paren
)paren
suffix:semicolon
)brace
DECL|function|ntfs_alloc_inode
id|ntfs_inode
op_star
id|ntfs_alloc_inode
c_func
(paren
r_void
)paren
(brace
id|ntfs_inode
op_star
id|ni
op_assign
(paren
id|ntfs_inode
op_star
)paren
id|kmem_cache_alloc
c_func
(paren
id|ntfs_inode_cache
comma
id|SLAB_NOFS
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Entering.&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|ni
)paren
)paren
id|ntfs_error
c_func
(paren
l_int|NULL
comma
l_string|&quot;Allocation of NTFS inode structure failed.&quot;
)paren
suffix:semicolon
r_return
id|ni
suffix:semicolon
)brace
DECL|function|ntfs_destroy_inode
r_void
id|ntfs_destroy_inode
c_func
(paren
id|ntfs_inode
op_star
id|ni
)paren
(brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Entering.&quot;
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|atomic_read
c_func
(paren
op_amp
id|ni-&gt;mft_count
)paren
op_logical_or
op_logical_neg
id|atomic_dec_and_test
c_func
(paren
op_amp
id|ni-&gt;count
)paren
)paren
suffix:semicolon
id|kmem_cache_free
c_func
(paren
id|ntfs_inode_cache
comma
id|ni
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * __ntfs_init_inode - initialize ntfs specific part of an inode&n; *&n; * Initialize an ntfs inode to defaults.&n; *&n; * Return zero on success and -ENOMEM on error.&n; */
DECL|function|__ntfs_init_inode
r_static
r_void
id|__ntfs_init_inode
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
id|ntfs_inode
op_star
id|ni
)paren
(brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Entering.&quot;
)paren
suffix:semicolon
id|memset
c_func
(paren
id|ni
comma
l_int|0
comma
r_sizeof
(paren
id|ntfs_inode
)paren
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|ni-&gt;count
comma
l_int|1
)paren
suffix:semicolon
id|ni-&gt;vol
op_assign
l_int|NULL
suffix:semicolon
id|init_run_list
c_func
(paren
op_amp
id|ni-&gt;run_list
)paren
suffix:semicolon
id|init_rwsem
c_func
(paren
op_amp
id|ni-&gt;mrec_lock
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|ni-&gt;mft_count
comma
l_int|0
)paren
suffix:semicolon
id|ni-&gt;page
op_assign
l_int|NULL
suffix:semicolon
id|ni-&gt;attr_list
op_assign
l_int|NULL
suffix:semicolon
id|init_run_list
c_func
(paren
op_amp
id|ni-&gt;attr_list_rl
)paren
suffix:semicolon
id|init_run_list
c_func
(paren
op_amp
id|ni
op_member_access_from_pointer
id|_IDM
c_func
(paren
id|bmp_rl
)paren
)paren
suffix:semicolon
id|init_MUTEX
c_func
(paren
op_amp
id|ni-&gt;extent_lock
)paren
suffix:semicolon
id|ni
op_member_access_from_pointer
id|_INE
c_func
(paren
id|base_ntfs_ino
)paren
op_assign
l_int|NULL
suffix:semicolon
id|ni-&gt;vol
op_assign
id|NTFS_SB
c_func
(paren
id|sb
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|function|ntfs_init_big_inode
r_static
r_void
id|ntfs_init_big_inode
c_func
(paren
r_struct
id|inode
op_star
id|vi
)paren
(brace
id|ntfs_inode
op_star
id|ni
op_assign
id|NTFS_I
c_func
(paren
id|vi
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Entering.&quot;
)paren
suffix:semicolon
id|__ntfs_init_inode
c_func
(paren
id|vi-&gt;i_sb
comma
id|ni
)paren
suffix:semicolon
id|ni-&gt;mft_no
op_assign
id|vi-&gt;i_ino
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|function|ntfs_new_inode
id|ntfs_inode
op_star
id|ntfs_new_inode
c_func
(paren
r_struct
id|super_block
op_star
id|sb
)paren
(brace
id|ntfs_inode
op_star
id|ni
op_assign
id|ntfs_alloc_inode
c_func
(paren
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Entering.&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ni
)paren
id|__ntfs_init_inode
c_func
(paren
id|sb
comma
id|ni
)paren
suffix:semicolon
r_return
id|ni
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_is_extended_system_file - check if a file is in the $Extend directory&n; * @ctx:&t;initialized attribute search context&n; *&n; * Search all file name attributes in the inode described by the attribute&n; * search context @ctx and check if any of the names are in the $Extend system&n; * directory.&n; * &n; * Return values:&n; *&t;   1: file is in $Extend directory&n; *&t;   0: file is not in $Extend directory&n; *&t;-EIO: file is corrupt&n; */
DECL|function|ntfs_is_extended_system_file
r_static
r_int
id|ntfs_is_extended_system_file
c_func
(paren
id|attr_search_context
op_star
id|ctx
)paren
(brace
r_int
id|nr_links
suffix:semicolon
multiline_comment|/* Restart search. */
id|reinit_attr_search_ctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
multiline_comment|/* Get number of hard links. */
id|nr_links
op_assign
id|le16_to_cpu
c_func
(paren
id|ctx-&gt;mrec-&gt;link_count
)paren
suffix:semicolon
multiline_comment|/* Loop through all hard links. */
r_while
c_loop
(paren
id|lookup_attr
c_func
(paren
id|AT_FILE_NAME
comma
l_int|NULL
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|NULL
comma
l_int|0
comma
id|ctx
)paren
)paren
(brace
id|FILE_NAME_ATTR
op_star
id|file_name_attr
suffix:semicolon
id|ATTR_RECORD
op_star
id|attr
op_assign
id|ctx-&gt;attr
suffix:semicolon
id|u8
op_star
id|p
comma
op_star
id|p2
suffix:semicolon
id|nr_links
op_decrement
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Maximum sanity checking as we are called on an inode that&n;&t;&t; * we suspect might be corrupt.&n;&t;&t; */
id|p
op_assign
(paren
id|u8
op_star
)paren
id|attr
op_plus
id|le32_to_cpu
c_func
(paren
id|attr-&gt;length
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
template_param
(paren
id|u8
op_star
)paren
id|ctx-&gt;mrec
op_plus
id|le32_to_cpu
c_func
(paren
id|ctx-&gt;mrec-&gt;bytes_in_use
)paren
)paren
(brace
id|err_corrupt_attr
suffix:colon
id|ntfs_error
c_func
(paren
id|ctx-&gt;ntfs_ino-&gt;vol-&gt;sb
comma
l_string|&quot;Corrupt file name &quot;
l_string|&quot;attribute. You should run chkdsk.&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_if
c_cond
(paren
id|attr-&gt;non_resident
)paren
(brace
id|ntfs_error
c_func
(paren
id|ctx-&gt;ntfs_ino-&gt;vol-&gt;sb
comma
l_string|&quot;Non-resident file &quot;
l_string|&quot;name. You should run chkdsk.&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_if
c_cond
(paren
id|attr-&gt;flags
)paren
(brace
id|ntfs_error
c_func
(paren
id|ctx-&gt;ntfs_ino-&gt;vol-&gt;sb
comma
l_string|&quot;File name with &quot;
l_string|&quot;invalid flags. You should run &quot;
l_string|&quot;chkdsk.&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|attr
op_member_access_from_pointer
id|_ARA
c_func
(paren
id|resident_flags
)paren
op_amp
id|RESIDENT_ATTR_IS_INDEXED
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|ctx-&gt;ntfs_ino-&gt;vol-&gt;sb
comma
l_string|&quot;Unindexed file &quot;
l_string|&quot;name. You should run chkdsk.&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|file_name_attr
op_assign
(paren
id|FILE_NAME_ATTR
op_star
)paren
(paren
(paren
id|u8
op_star
)paren
id|attr
op_plus
id|le16_to_cpu
c_func
(paren
id|attr
op_member_access_from_pointer
id|_ARA
c_func
(paren
id|value_offset
)paren
)paren
)paren
suffix:semicolon
id|p2
op_assign
(paren
id|u8
op_star
)paren
id|attr
op_plus
id|le32_to_cpu
c_func
(paren
id|attr
op_member_access_from_pointer
id|_ARA
c_func
(paren
id|value_length
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p2
template_param
id|p
)paren
r_goto
id|err_corrupt_attr
suffix:semicolon
multiline_comment|/* This attribute is ok, but is it in the $Extend directory? */
r_if
c_cond
(paren
id|MREF_LE
c_func
(paren
id|file_name_attr-&gt;parent_directory
)paren
op_eq
id|FILE_Extend
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* YES, it&squot;s an extended system file. */
)brace
r_if
c_cond
(paren
id|nr_links
)paren
(brace
id|ntfs_error
c_func
(paren
id|ctx-&gt;ntfs_ino-&gt;vol-&gt;sb
comma
l_string|&quot;Inode hard link count &quot;
l_string|&quot;doesn&squot;t match number of name attributes. You &quot;
l_string|&quot;should run chkdsk.&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
multiline_comment|/* NO, it is not an extended system file. */
)brace
multiline_comment|/**&n; * ntfs_read_inode - read an inode from its device&n; * @vi:&t;&t;inode to read&n; *&n; * ntfs_read_inode() is called from the VFS iget() function to read the inode&n; * described by @vi into memory from the device.&n; *&n; * The only fields in @vi that we need to/can look at when the function is&n; * called are i_sb, pointing to the mounted device&squot;s super block, and i_ino,&n; * the number of the inode to load.&n; *&n; * ntfs_read_inode() maps, pins and locks the mft record number i_ino for&n; * reading and sets up the necessary @vi fields as well as initializing&n; * the ntfs inode.&n; *&n; * Q: What locks are held when the function is called?&n; * A: i_state has I_LOCK set, hence the inode is locked, also&n; *    i_count is set to 1, so it is not going to go away&n; *    i_flags is set to 0 and we have no business touching it. Only an ioctl()&n; *    is allowed to write to them. We should of course be honouring them but&n; *    we need to do that using the IS_* macros defined in include/linux/fs.h.&n; *    In any case ntfs_read_inode() has nothing to do with i_flags at all.&n; */
DECL|function|ntfs_read_inode
r_void
id|ntfs_read_inode
c_func
(paren
r_struct
id|inode
op_star
id|vi
)paren
(brace
id|ntfs_volume
op_star
id|vol
op_assign
id|NTFS_SB
c_func
(paren
id|vi-&gt;i_sb
)paren
suffix:semicolon
id|ntfs_inode
op_star
id|ni
suffix:semicolon
id|MFT_RECORD
op_star
id|m
suffix:semicolon
id|STANDARD_INFORMATION
op_star
id|si
suffix:semicolon
id|attr_search_context
op_star
id|ctx
suffix:semicolon
r_int
id|err
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Entering for i_ino 0x%lx.&quot;
comma
id|vi-&gt;i_ino
)paren
suffix:semicolon
multiline_comment|/* Setup the generic vfs inode parts now. */
multiline_comment|/* This is the optimal IO size (for stat), not the fs block size. */
id|vi-&gt;i_blksize
op_assign
id|PAGE_CACHE_SIZE
suffix:semicolon
multiline_comment|/*&n;&t; * This is for checking whether an inode has changed w.r.t. a file so&n;&t; * that the file can be updated if necessary (compare with f_version).&n;&t; */
id|vi-&gt;i_version
op_assign
op_increment
id|event
suffix:semicolon
multiline_comment|/* Set uid and gid from the mount options. */
id|vi-&gt;i_uid
op_assign
id|vol-&gt;uid
suffix:semicolon
id|vi-&gt;i_gid
op_assign
id|vol-&gt;gid
suffix:semicolon
multiline_comment|/* Set to zero so we can use logical operations on it from here on. */
id|vi-&gt;i_mode
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Initialize the ntfs specific part of @vi special casing&n;&t; * FILE_MFT which we need to do at mount time.&n;&t; */
r_if
c_cond
(paren
id|vi-&gt;i_ino
op_ne
id|FILE_MFT
)paren
id|ntfs_init_big_inode
c_func
(paren
id|vi
)paren
suffix:semicolon
id|ni
op_assign
id|NTFS_I
c_func
(paren
id|vi
)paren
suffix:semicolon
multiline_comment|/* Map, pin and lock the mft record for reading. */
id|m
op_assign
id|map_mft_record
c_func
(paren
id|READ
comma
id|ni
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|m
)paren
)paren
(brace
id|err
op_assign
id|PTR_ERR
c_func
(paren
id|m
)paren
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
multiline_comment|/* Is the record in use? */
r_if
c_cond
(paren
op_logical_neg
(paren
id|m-&gt;flags
op_amp
id|MFT_RECORD_IN_USE
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Inode is not in use! You should &quot;
l_string|&quot;run chkdsk.&quot;
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
multiline_comment|/* Is this an extent mft record / inode? Treat same as if not in use. */
r_if
c_cond
(paren
id|m-&gt;base_mft_record
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Inode is an extent inode! iget() &quot;
l_string|&quot;not possible. You should run chkdsk.&quot;
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
multiline_comment|/* Transfer information from mft record into vfs and ntfs inodes. */
multiline_comment|/* Cache the sequence number in the ntfs inode. */
id|ni-&gt;seq_no
op_assign
id|le16_to_cpu
c_func
(paren
id|m-&gt;sequence_number
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * FIXME: Keep in mind that link_count is two for files which have both&n;&t; * a long file name and a short file name as separate entries, so if&n;&t; * we are hiding short file names this will be too high. Either we need&n;&t; * to account for the short file names by subtracting them or we need&n;&t; * to make sure we delete files even though i_nlink is not zero which&n;&t; * might be tricky due to vfs interactions. Need to think about this&n;&t; * some more when implementing the unlink command.&n;&t; */
id|vi-&gt;i_nlink
op_assign
id|le16_to_cpu
c_func
(paren
id|m-&gt;link_count
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * FIXME: Reparse points can have the directory bit set even though&n;&t; * they would be S_IFLNK. Need to deal with this further below when we&n;&t; * implement reparse points / symbolic links but it will do for now.&n;&t; * Also if not a directory, it could be something else, rather than&n;&t; * a regular file. But again, will do for now.&n;&t; */
r_if
c_cond
(paren
id|m-&gt;flags
op_amp
id|MFT_RECORD_IS_DIRECTORY
)paren
(brace
id|vi-&gt;i_mode
op_or_assign
id|S_IFDIR
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Linux/Unix do not support directory hard links and things&n;&t;&t; * break without this kludge.&n;&t;&t; */
r_if
c_cond
(paren
id|vi-&gt;i_nlink
OG
l_int|1
)paren
id|vi-&gt;i_nlink
op_assign
l_int|1
suffix:semicolon
)brace
r_else
id|vi-&gt;i_mode
op_or_assign
id|S_IFREG
suffix:semicolon
id|err
op_assign
id|get_attr_search_ctx
c_func
(paren
op_amp
id|ctx
comma
id|ni
comma
id|m
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|unm_err_out
suffix:semicolon
multiline_comment|/*&n;&t; * Find the standard information attribute in the mft record. At this&n;&t; * stage we haven&squot;t setup the attribute list stuff yet, so this could&n;&t; * in fact fail if the standard information is in an extent record, but&n;&t; * I don&squot;t think this actually ever happens.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|lookup_attr
c_func
(paren
id|AT_STANDARD_INFORMATION
comma
l_int|NULL
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|NULL
comma
l_int|0
comma
id|ctx
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * TODO: We should be performing a hot fix here (if the recover&n;&t;&t; * mount option is set) by creating a new attribute.&n;&t;&t; */
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;$STANDARD_INFORMATION attribute is &quot;
l_string|&quot;missing.&quot;
)paren
suffix:semicolon
r_goto
id|put_unm_err_out
suffix:semicolon
)brace
multiline_comment|/* Get the standard information attribute value. */
id|si
op_assign
(paren
id|STANDARD_INFORMATION
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|ctx-&gt;attr
op_plus
id|le16_to_cpu
c_func
(paren
id|ctx-&gt;attr
op_member_access_from_pointer
id|_ARA
c_func
(paren
id|value_offset
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/* Transfer information from the standard information into vfs_ino. */
multiline_comment|/*&n;&t; * Note: The i_?times do not quite map perfectly onto the NTFS times,&n;&t; * but they are close enough, and in the end it doesn&squot;t really matter&n;&t; * that much...&n;&t; */
multiline_comment|/*&n;&t; * mtime is the last change of the data within the file. Not changed&n;&t; * when only metadata is changed, e.g. a rename doesn&squot;t affect mtime.&n;&t; */
id|vi-&gt;i_mtime
op_assign
id|ntfs2utc
c_func
(paren
id|si-&gt;last_data_change_time
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * ctime is the last change of the metadata of the file. This obviously&n;&t; * always changes, when mtime is changed. ctime can be changed on its&n;&t; * own, mtime is then not changed, e.g. when a file is renamed.&n;&t; */
id|vi-&gt;i_ctime
op_assign
id|ntfs2utc
c_func
(paren
id|si-&gt;last_mft_change_time
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Last access to the data within the file. Not changed during a rename&n;&t; * for example but changed whenever the file is written to.&n;&t; */
id|vi-&gt;i_atime
op_assign
id|ntfs2utc
c_func
(paren
id|si-&gt;last_access_time
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Find the attribute list attribute and set the corresponding bit in&n;&t; * ntfs_ino-&gt;state.&n;&t; */
id|reinit_attr_search_ctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lookup_attr
c_func
(paren
id|AT_ATTRIBUTE_LIST
comma
l_int|NULL
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|NULL
comma
l_int|0
comma
id|ctx
)paren
)paren
(brace
r_if
c_cond
(paren
id|vi-&gt;i_ino
op_eq
id|FILE_MFT
)paren
r_goto
id|skip_attr_list_load
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Attribute list found in inode %li (0x%lx).&quot;
comma
id|vi-&gt;i_ino
comma
id|vi-&gt;i_ino
)paren
suffix:semicolon
id|ni-&gt;state
op_or_assign
l_int|1
op_lshift
id|NI_AttrList
suffix:semicolon
r_if
c_cond
(paren
id|ctx-&gt;attr-&gt;flags
op_amp
id|ATTR_IS_ENCRYPTED
op_logical_or
id|ctx-&gt;attr-&gt;flags
op_amp
id|ATTR_COMPRESSION_MASK
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Attribute list attribute is &quot;
l_string|&quot;compressed/encrypted. Not allowed. &quot;
l_string|&quot;Corrupt inode. You should run &quot;
l_string|&quot;chkdsk.&quot;
)paren
suffix:semicolon
r_goto
id|put_unm_err_out
suffix:semicolon
)brace
multiline_comment|/* Now allocate memory for the attribute list. */
id|ni-&gt;attr_list_size
op_assign
(paren
id|u32
)paren
id|attribute_value_length
c_func
(paren
id|ctx-&gt;attr
)paren
suffix:semicolon
id|ni-&gt;attr_list
op_assign
id|ntfs_malloc_nofs
c_func
(paren
id|ni-&gt;attr_list_size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ni-&gt;attr_list
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Not enough memory to allocate &quot;
l_string|&quot;buffer for attribute list.&quot;
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|ec_put_unm_err_out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ctx-&gt;attr-&gt;non_resident
)paren
(brace
id|ni-&gt;state
op_or_assign
l_int|1
op_lshift
id|NI_AttrListNonResident
suffix:semicolon
r_if
c_cond
(paren
id|ctx-&gt;attr
op_member_access_from_pointer
id|_ANR
c_func
(paren
id|lowest_vcn
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Attribute list has non &quot;
l_string|&quot;zero lowest_vcn. Inode is &quot;
l_string|&quot;corrupt. You should run &quot;
l_string|&quot;chkdsk.&quot;
)paren
suffix:semicolon
r_goto
id|put_unm_err_out
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * Setup the run list. No need for locking as we have&n;&t;&t;&t; * exclusive access to the inode at this time.&n;&t;&t;&t; */
id|ni-&gt;attr_list_rl.rl
op_assign
id|decompress_mapping_pairs
c_func
(paren
id|vol
comma
id|ctx-&gt;attr
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|ni-&gt;attr_list_rl.rl
)paren
)paren
(brace
id|err
op_assign
id|PTR_ERR
c_func
(paren
id|ni-&gt;attr_list_rl.rl
)paren
suffix:semicolon
id|ni-&gt;attr_list_rl.rl
op_assign
l_int|NULL
suffix:semicolon
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Mapping pairs &quot;
l_string|&quot;decompression failed with &quot;
l_string|&quot;error code %i. Corrupt &quot;
l_string|&quot;attribute list in inode.&quot;
comma
op_minus
id|err
)paren
suffix:semicolon
r_goto
id|ec_put_unm_err_out
suffix:semicolon
)brace
multiline_comment|/* Now load the attribute list. */
r_if
c_cond
(paren
(paren
id|err
op_assign
id|load_attribute_list
c_func
(paren
id|vol
comma
op_amp
id|ni-&gt;attr_list_rl
comma
id|ni-&gt;attr_list
comma
id|ni-&gt;attr_list_size
comma
id|sle64_to_cpu
c_func
(paren
id|ctx-&gt;attr
op_member_access_from_pointer
id|_ANR
c_func
(paren
id|initialized_size
)paren
)paren
)paren
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Failed to load &quot;
l_string|&quot;attribute list attribute.&quot;
)paren
suffix:semicolon
r_goto
id|ec_put_unm_err_out
suffix:semicolon
)brace
)brace
r_else
multiline_comment|/* if (!ctx.attr-&gt;non_resident) */
(brace
r_if
c_cond
(paren
(paren
id|u8
op_star
)paren
id|ctx-&gt;attr
op_plus
id|le16_to_cpu
c_func
(paren
id|ctx-&gt;attr
op_member_access_from_pointer
id|_ARA
c_func
(paren
id|value_offset
)paren
)paren
op_plus
id|le32_to_cpu
c_func
(paren
id|ctx-&gt;attr
op_member_access_from_pointer
id|_ARA
c_func
(paren
id|value_length
)paren
)paren
OG
(paren
id|u8
op_star
)paren
id|ctx-&gt;mrec
op_plus
id|vol-&gt;mft_record_size
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Corrupt attribute list &quot;
l_string|&quot;in inode.&quot;
)paren
suffix:semicolon
r_goto
id|put_unm_err_out
suffix:semicolon
)brace
multiline_comment|/* Now copy the attribute list. */
id|memcpy
c_func
(paren
id|ni-&gt;attr_list
comma
(paren
id|u8
op_star
)paren
id|ctx-&gt;attr
op_plus
id|le16_to_cpu
c_func
(paren
id|ctx-&gt;attr
op_member_access_from_pointer
id|_ARA
c_func
(paren
id|value_offset
)paren
)paren
comma
id|le32_to_cpu
c_func
(paren
id|ctx-&gt;attr
op_member_access_from_pointer
id|_ARA
c_func
(paren
id|value_length
)paren
)paren
)paren
suffix:semicolon
)brace
)brace
id|skip_attr_list_load
suffix:colon
multiline_comment|/*&n;&t; * If an attribute list is present we now have the attribute list value&n;&t; * in ntfs_ino-&gt;attr_list and it is ntfs_ino-&gt;attr_list_size bytes.&n;&t; */
r_if
c_cond
(paren
id|S_ISDIR
c_func
(paren
id|vi-&gt;i_mode
)paren
)paren
(brace
id|INDEX_ROOT
op_star
id|ir
suffix:semicolon
r_char
op_star
id|ir_end
comma
op_star
id|index_end
suffix:semicolon
multiline_comment|/* It is a directory, find index root attribute. */
id|reinit_attr_search_ctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|lookup_attr
c_func
(paren
id|AT_INDEX_ROOT
comma
id|I30
comma
l_int|4
comma
id|CASE_SENSITIVE
comma
l_int|0
comma
l_int|NULL
comma
l_int|0
comma
id|ctx
)paren
)paren
(brace
singleline_comment|// FIXME: File is corrupt! Hot-fix with empty index
singleline_comment|// root attribute if recovery option is set.
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;$INDEX_ROOT attribute is &quot;
l_string|&quot;missing.&quot;
)paren
suffix:semicolon
r_goto
id|put_unm_err_out
suffix:semicolon
)brace
multiline_comment|/* Set up the state. */
r_if
c_cond
(paren
id|ctx-&gt;attr-&gt;non_resident
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;$INDEX_ROOT attribute is &quot;
l_string|&quot;not resident. Not allowed.&quot;
)paren
suffix:semicolon
r_goto
id|put_unm_err_out
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Compressed/encrypted index root just means that the newly&n;&t;&t; * created files in that directory should be created compressed/&n;&t;&t; * encrypted. However index root cannot be both compressed and&n;&t;&t; * encrypted.&n;&t;&t; */
r_if
c_cond
(paren
id|ctx-&gt;attr-&gt;flags
op_amp
id|ATTR_COMPRESSION_MASK
)paren
id|ni-&gt;state
op_or_assign
l_int|1
op_lshift
id|NI_Compressed
suffix:semicolon
r_if
c_cond
(paren
id|ctx-&gt;attr-&gt;flags
op_amp
id|ATTR_IS_ENCRYPTED
)paren
(brace
r_if
c_cond
(paren
id|ctx-&gt;attr-&gt;flags
op_amp
id|ATTR_COMPRESSION_MASK
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Found encrypted and &quot;
l_string|&quot;compressed attribute. Not &quot;
l_string|&quot;allowed.&quot;
)paren
suffix:semicolon
r_goto
id|put_unm_err_out
suffix:semicolon
)brace
id|ni-&gt;state
op_or_assign
l_int|1
op_lshift
id|NI_Encrypted
suffix:semicolon
)brace
id|ir
op_assign
(paren
id|INDEX_ROOT
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|ctx-&gt;attr
op_plus
id|le16_to_cpu
c_func
(paren
id|ctx-&gt;attr
op_member_access_from_pointer
id|_ARA
c_func
(paren
id|value_offset
)paren
)paren
)paren
suffix:semicolon
id|ir_end
op_assign
(paren
r_char
op_star
)paren
id|ir
op_plus
id|le32_to_cpu
c_func
(paren
id|ctx-&gt;attr
op_member_access_from_pointer
id|_ARA
c_func
(paren
id|value_length
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ir_end
OG
(paren
r_char
op_star
)paren
id|ctx-&gt;mrec
op_plus
id|vol-&gt;mft_record_size
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;$INDEX_ROOT attribute is &quot;
l_string|&quot;corrupt.&quot;
)paren
suffix:semicolon
r_goto
id|put_unm_err_out
suffix:semicolon
)brace
id|index_end
op_assign
(paren
r_char
op_star
)paren
op_amp
id|ir-&gt;index
op_plus
id|le32_to_cpu
c_func
(paren
id|ir-&gt;index.index_length
)paren
suffix:semicolon
r_if
c_cond
(paren
id|index_end
OG
id|ir_end
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Directory index is corrupt.&quot;
)paren
suffix:semicolon
r_goto
id|put_unm_err_out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ir-&gt;type
op_ne
id|AT_FILE_NAME
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
id|__FUNCTION__
l_string|&quot;(): Indexed &quot;
l_string|&quot;attribute is not $FILE_NAME. Not &quot;
l_string|&quot;allowed.&quot;
)paren
suffix:semicolon
r_goto
id|put_unm_err_out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ir-&gt;collation_rule
op_ne
id|COLLATION_FILE_NAME
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Index collation rule is not &quot;
l_string|&quot;COLLATION_FILE_NAME. Not allowed.&quot;
)paren
suffix:semicolon
r_goto
id|put_unm_err_out
suffix:semicolon
)brace
id|ni
op_member_access_from_pointer
id|_IDM
c_func
(paren
id|index_block_size
)paren
op_assign
id|le32_to_cpu
c_func
(paren
id|ir-&gt;index_block_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ni
op_member_access_from_pointer
id|_IDM
c_func
(paren
id|index_block_size
)paren
op_amp
(paren
id|ni
op_member_access_from_pointer
id|_IDM
c_func
(paren
id|index_block_size
)paren
op_minus
l_int|1
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Index block size (%u) is not a &quot;
l_string|&quot;power of two.&quot;
comma
id|ni
op_member_access_from_pointer
id|_IDM
c_func
(paren
id|index_block_size
)paren
)paren
suffix:semicolon
r_goto
id|put_unm_err_out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ni
op_member_access_from_pointer
id|_IDM
c_func
(paren
id|index_block_size
)paren
OG
id|PAGE_CACHE_SIZE
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Index block size (%u) &gt; &quot;
l_string|&quot;PAGE_CACHE_SIZE (%ld) is not &quot;
l_string|&quot;supported. Sorry.&quot;
comma
id|ni
op_member_access_from_pointer
id|_IDM
c_func
(paren
id|index_block_size
)paren
comma
id|PAGE_CACHE_SIZE
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EOPNOTSUPP
suffix:semicolon
r_goto
id|ec_put_unm_err_out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ni
op_member_access_from_pointer
id|_IDM
c_func
(paren
id|index_block_size
)paren
OL
id|NTFS_BLOCK_SIZE
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Index block size (%u) &lt; &quot;
l_string|&quot;NTFS_BLOCK_SIZE (%i) is not &quot;
l_string|&quot;supported. Sorry.&quot;
comma
id|ni
op_member_access_from_pointer
id|_IDM
c_func
(paren
id|index_block_size
)paren
comma
id|NTFS_BLOCK_SIZE
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EOPNOTSUPP
suffix:semicolon
r_goto
id|ec_put_unm_err_out
suffix:semicolon
)brace
id|ni
op_member_access_from_pointer
id|_IDM
c_func
(paren
id|index_block_size_bits
)paren
op_assign
id|ffs
c_func
(paren
id|ni
op_member_access_from_pointer
id|_IDM
c_func
(paren
id|index_block_size
)paren
)paren
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* Determine the size of a vcn in the directory index. */
r_if
c_cond
(paren
id|vol-&gt;cluster_size
op_le
id|ni
op_member_access_from_pointer
id|_IDM
c_func
(paren
id|index_block_size
)paren
)paren
(brace
id|ni
op_member_access_from_pointer
id|_IDM
c_func
(paren
id|index_vcn_size
)paren
op_assign
id|vol-&gt;cluster_size
suffix:semicolon
id|ni
op_member_access_from_pointer
id|_IDM
c_func
(paren
id|index_vcn_size_bits
)paren
op_assign
id|vol-&gt;cluster_size_bits
suffix:semicolon
)brace
r_else
(brace
id|ni
op_member_access_from_pointer
id|_IDM
c_func
(paren
id|index_vcn_size
)paren
op_assign
id|vol-&gt;sector_size
suffix:semicolon
id|ni
op_member_access_from_pointer
id|_IDM
c_func
(paren
id|index_vcn_size_bits
)paren
op_assign
id|vol-&gt;sector_size_bits
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|ir-&gt;index.flags
op_amp
id|LARGE_INDEX
)paren
)paren
(brace
multiline_comment|/* No index allocation. */
id|vi-&gt;i_size
op_assign
id|ni-&gt;initialized_size
op_assign
l_int|0
suffix:semicolon
r_goto
id|skip_large_dir_stuff
suffix:semicolon
)brace
multiline_comment|/* LARGE_INDEX: Index allocation present. Setup state. */
id|ni-&gt;state
op_or_assign
l_int|1
op_lshift
id|NI_NonResident
suffix:semicolon
multiline_comment|/* Find index allocation attribute. */
id|reinit_attr_search_ctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|lookup_attr
c_func
(paren
id|AT_INDEX_ALLOCATION
comma
id|I30
comma
l_int|4
comma
id|CASE_SENSITIVE
comma
l_int|0
comma
l_int|NULL
comma
l_int|0
comma
id|ctx
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;$INDEX_ALLOCATION attribute &quot;
l_string|&quot;is not present but $INDEX_ROOT &quot;
l_string|&quot;indicated it is.&quot;
)paren
suffix:semicolon
r_goto
id|put_unm_err_out
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|ctx-&gt;attr-&gt;non_resident
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;$INDEX_ALLOCATION attribute &quot;
l_string|&quot;is resident.&quot;
)paren
suffix:semicolon
r_goto
id|put_unm_err_out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ctx-&gt;attr-&gt;flags
op_amp
id|ATTR_IS_ENCRYPTED
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;$INDEX_ALLOCATION attribute &quot;
l_string|&quot;is encrypted.&quot;
)paren
suffix:semicolon
r_goto
id|put_unm_err_out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ctx-&gt;attr-&gt;flags
op_amp
id|ATTR_COMPRESSION_MASK
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;$INDEX_ALLOCATION attribute &quot;
l_string|&quot;is compressed.&quot;
)paren
suffix:semicolon
r_goto
id|put_unm_err_out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ctx-&gt;attr
op_member_access_from_pointer
id|_ANR
c_func
(paren
id|lowest_vcn
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;First extent of &quot;
l_string|&quot;$INDEX_ALLOCATION attribute has non &quot;
l_string|&quot;zero lowest_vcn. Inode is corrupt. &quot;
l_string|&quot;You should run chkdsk.&quot;
)paren
suffix:semicolon
r_goto
id|put_unm_err_out
suffix:semicolon
)brace
id|vi-&gt;i_size
op_assign
id|sle64_to_cpu
c_func
(paren
id|ctx-&gt;attr
op_member_access_from_pointer
id|_ANR
c_func
(paren
id|data_size
)paren
)paren
suffix:semicolon
id|ni-&gt;initialized_size
op_assign
id|sle64_to_cpu
c_func
(paren
id|ctx-&gt;attr
op_member_access_from_pointer
id|_ANR
c_func
(paren
id|initialized_size
)paren
)paren
suffix:semicolon
id|ni-&gt;allocated_size
op_assign
id|sle64_to_cpu
c_func
(paren
id|ctx-&gt;attr
op_member_access_from_pointer
id|_ANR
c_func
(paren
id|allocated_size
)paren
)paren
suffix:semicolon
multiline_comment|/* Find bitmap attribute. */
id|reinit_attr_search_ctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|lookup_attr
c_func
(paren
id|AT_BITMAP
comma
id|I30
comma
l_int|4
comma
id|CASE_SENSITIVE
comma
l_int|0
comma
l_int|NULL
comma
l_int|0
comma
id|ctx
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;$BITMAP attribute is not &quot;
l_string|&quot;present but it must be.&quot;
)paren
suffix:semicolon
r_goto
id|put_unm_err_out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ctx-&gt;attr-&gt;flags
op_amp
(paren
id|ATTR_COMPRESSION_MASK
op_or
id|ATTR_IS_ENCRYPTED
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;$BITMAP attribute is compressed &quot;
l_string|&quot;and/or encrypted.&quot;
)paren
suffix:semicolon
r_goto
id|put_unm_err_out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ctx-&gt;attr-&gt;non_resident
)paren
(brace
id|ni-&gt;state
op_or_assign
l_int|1
op_lshift
id|NI_BmpNonResident
suffix:semicolon
r_if
c_cond
(paren
id|ctx-&gt;attr
op_member_access_from_pointer
id|_ANR
c_func
(paren
id|lowest_vcn
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;First extent of $BITMAP &quot;
l_string|&quot;attribute has non zero &quot;
l_string|&quot;lowest_vcn. Inode is corrupt. &quot;
l_string|&quot;You should run chkdsk.&quot;
)paren
suffix:semicolon
r_goto
id|put_unm_err_out
suffix:semicolon
)brace
id|ni
op_member_access_from_pointer
id|_IDM
c_func
(paren
id|bmp_size
)paren
op_assign
id|sle64_to_cpu
c_func
(paren
id|ctx-&gt;attr
op_member_access_from_pointer
id|_ANR
c_func
(paren
id|data_size
)paren
)paren
suffix:semicolon
id|ni
op_member_access_from_pointer
id|_IDM
c_func
(paren
id|bmp_initialized_size
)paren
op_assign
id|sle64_to_cpu
c_func
(paren
id|ctx-&gt;attr
op_member_access_from_pointer
id|_ANR
c_func
(paren
id|initialized_size
)paren
)paren
suffix:semicolon
id|ni
op_member_access_from_pointer
id|_IDM
c_func
(paren
id|bmp_allocated_size
)paren
op_assign
id|sle64_to_cpu
c_func
(paren
id|ctx-&gt;attr
op_member_access_from_pointer
id|_ANR
c_func
(paren
id|allocated_size
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Setup the run list. No need for locking as we have&n;&t;&t;&t; * exclusive access to the inode at this time.&n;&t;&t;&t; */
id|ni
op_member_access_from_pointer
id|_IDM
c_func
(paren
id|bmp_rl
)paren
dot
id|rl
op_assign
id|decompress_mapping_pairs
c_func
(paren
id|vol
comma
id|ctx-&gt;attr
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|ni
op_member_access_from_pointer
id|_IDM
c_func
(paren
id|bmp_rl
)paren
dot
id|rl
)paren
)paren
(brace
id|err
op_assign
id|PTR_ERR
c_func
(paren
id|ni
op_member_access_from_pointer
id|_IDM
c_func
(paren
id|bmp_rl
)paren
dot
id|rl
)paren
suffix:semicolon
id|ni
op_member_access_from_pointer
id|_IDM
c_func
(paren
id|bmp_rl
)paren
dot
id|rl
op_assign
l_int|NULL
suffix:semicolon
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Mapping pairs &quot;
l_string|&quot;decompression failed with &quot;
l_string|&quot;error code %i.&quot;
comma
op_minus
id|err
)paren
suffix:semicolon
r_goto
id|ec_put_unm_err_out
suffix:semicolon
)brace
)brace
r_else
id|ni
op_member_access_from_pointer
id|_IDM
c_func
(paren
id|bmp_size
)paren
op_assign
id|ni
op_member_access_from_pointer
id|_IDM
c_func
(paren
id|bmp_initialized_size
)paren
op_assign
id|ni
op_member_access_from_pointer
id|_IDM
c_func
(paren
id|bmp_allocated_size
)paren
op_assign
id|le32_to_cpu
c_func
(paren
id|ctx-&gt;attr
op_member_access_from_pointer
id|_ARA
c_func
(paren
id|value_length
)paren
)paren
suffix:semicolon
multiline_comment|/* Consistency check bitmap size vs. index allocation size. */
r_if
c_cond
(paren
id|ni
op_member_access_from_pointer
id|_IDM
c_func
(paren
id|bmp_size
)paren
op_lshift
l_int|3
OL
id|vi-&gt;i_size
op_rshift
id|ni
op_member_access_from_pointer
id|_IDM
c_func
(paren
id|index_block_size_bits
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;$I30 bitmap too small (0x%Lx) &quot;
l_string|&quot;for index allocation (0x%Lx).&quot;
comma
(paren
r_int
r_int
)paren
id|ni
op_member_access_from_pointer
id|_IDM
c_func
(paren
id|bmp_size
)paren
op_lshift
l_int|3
comma
id|vi-&gt;i_size
)paren
suffix:semicolon
r_goto
id|put_unm_err_out
suffix:semicolon
)brace
id|skip_large_dir_stuff
suffix:colon
multiline_comment|/* Everyone gets read and scan permissions. */
id|vi-&gt;i_mode
op_or_assign
id|S_IRUGO
op_or
id|S_IXUGO
suffix:semicolon
multiline_comment|/* If not read-only, set write permissions. */
r_if
c_cond
(paren
op_logical_neg
id|IS_RDONLY
c_func
(paren
id|vi
)paren
)paren
id|vi-&gt;i_mode
op_or_assign
id|S_IWUGO
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Apply the directory permissions mask set in the mount&n;&t;&t; * options.&n;&t;&t; */
id|vi-&gt;i_mode
op_and_assign
op_complement
id|vol-&gt;dmask
suffix:semicolon
multiline_comment|/* Setup the operations for this inode. */
id|vi-&gt;i_op
op_assign
op_amp
id|ntfs_dir_inode_ops
suffix:semicolon
id|vi-&gt;i_fop
op_assign
op_amp
id|ntfs_dir_ops
suffix:semicolon
id|vi-&gt;i_mapping-&gt;a_ops
op_assign
op_amp
id|ntfs_dir_aops
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* It is a file: find first extent of unnamed data attribute. */
id|reinit_attr_search_ctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|lookup_attr
c_func
(paren
id|AT_DATA
comma
l_int|NULL
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|NULL
comma
l_int|0
comma
id|ctx
)paren
)paren
(brace
id|vi-&gt;i_size
op_assign
id|ni-&gt;initialized_size
op_assign
id|ni-&gt;allocated_size
op_assign
l_int|0LL
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * FILE_Secure does not have an unnamed $DATA&n;&t;&t;&t; * attribute, so we special case it here.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|vi-&gt;i_ino
op_eq
id|FILE_Secure
)paren
r_goto
id|no_data_attr_special_case
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Most if not all the system files in the $Extend&n;&t;&t;&t; * system directory do not have unnamed data&n;&t;&t;&t; * attributes so we need to check if the parent&n;&t;&t;&t; * directory of the file is FILE_Extend and if it is&n;&t;&t;&t; * ignore this error. To do this we need to get the&n;&t;&t;&t; * name of this inode from the mft record as the name&n;&t;&t;&t; * contains the back reference to the parent directory.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|ntfs_is_extended_system_file
c_func
(paren
id|ctx
)paren
OG
l_int|0
)paren
r_goto
id|no_data_attr_special_case
suffix:semicolon
singleline_comment|// FIXME: File is corrupt! Hot-fix with empty data
singleline_comment|// attribute if recovery option is set.
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;$DATA attribute is &quot;
l_string|&quot;missing.&quot;
)paren
suffix:semicolon
r_goto
id|put_unm_err_out
suffix:semicolon
)brace
multiline_comment|/* Setup the state. */
r_if
c_cond
(paren
id|ctx-&gt;attr-&gt;non_resident
)paren
(brace
id|ni-&gt;state
op_or_assign
l_int|1
op_lshift
id|NI_NonResident
suffix:semicolon
r_if
c_cond
(paren
id|ctx-&gt;attr-&gt;flags
op_amp
id|ATTR_COMPRESSION_MASK
)paren
(brace
id|ni-&gt;state
op_or_assign
l_int|1
op_lshift
id|NI_Compressed
suffix:semicolon
r_if
c_cond
(paren
id|vol-&gt;cluster_size
OG
l_int|4096
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Found &quot;
l_string|&quot;compressed data but &quot;
l_string|&quot;compression is disabled due &quot;
l_string|&quot;to cluster size (%i) &gt; 4kiB.&quot;
comma
id|vol-&gt;cluster_size
)paren
suffix:semicolon
r_goto
id|put_unm_err_out
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|ctx-&gt;attr-&gt;flags
op_amp
id|ATTR_COMPRESSION_MASK
)paren
op_ne
id|ATTR_IS_COMPRESSED
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Found &quot;
l_string|&quot;unknown compression method or &quot;
l_string|&quot;corrupt file.&quot;
)paren
suffix:semicolon
r_goto
id|put_unm_err_out
suffix:semicolon
)brace
id|ni
op_member_access_from_pointer
id|_ICF
c_func
(paren
id|compression_block_clusters
)paren
op_assign
l_int|1U
op_lshift
id|ctx-&gt;attr
op_member_access_from_pointer
id|_ANR
c_func
(paren
id|compression_unit
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ctx-&gt;attr
op_member_access_from_pointer
id|_ANR
c_func
(paren
id|compression_unit
)paren
op_ne
l_int|4
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Found &quot;
l_string|&quot;nonstandard compression unit &quot;
l_string|&quot;(%u instead of 4). Cannot &quot;
l_string|&quot;handle this. This might &quot;
l_string|&quot;indicate corruption so you &quot;
l_string|&quot;should run chkdsk.&quot;
comma
id|ctx-&gt;attr
op_member_access_from_pointer
id|_ANR
c_func
(paren
id|compression_unit
)paren
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EOPNOTSUPP
suffix:semicolon
r_goto
id|ec_put_unm_err_out
suffix:semicolon
)brace
id|ni
op_member_access_from_pointer
id|_ICF
c_func
(paren
id|compression_block_size
)paren
op_assign
l_int|1U
op_lshift
(paren
id|ctx-&gt;attr
op_member_access_from_pointer
id|_ANR
c_func
(paren
id|compression_unit
)paren
op_plus
id|vol-&gt;cluster_size_bits
)paren
suffix:semicolon
id|ni
op_member_access_from_pointer
id|_ICF
c_func
(paren
id|compression_block_size_bits
)paren
op_assign
id|ffs
c_func
(paren
id|ni
op_member_access_from_pointer
id|_ICF
c_func
(paren
id|compression_block_size
)paren
)paren
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ctx-&gt;attr-&gt;flags
op_amp
id|ATTR_IS_ENCRYPTED
)paren
(brace
r_if
c_cond
(paren
id|ctx-&gt;attr-&gt;flags
op_amp
id|ATTR_COMPRESSION_MASK
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Found encrypted &quot;
l_string|&quot;and compressed data.&quot;
)paren
suffix:semicolon
r_goto
id|put_unm_err_out
suffix:semicolon
)brace
id|ni-&gt;state
op_or_assign
l_int|1
op_lshift
id|NI_Encrypted
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ctx-&gt;attr
op_member_access_from_pointer
id|_ANR
c_func
(paren
id|lowest_vcn
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;First extent of $DATA &quot;
l_string|&quot;attribute has non zero &quot;
l_string|&quot;lowest_vcn. Inode is corrupt. &quot;
l_string|&quot;You should run chkdsk.&quot;
)paren
suffix:semicolon
r_goto
id|put_unm_err_out
suffix:semicolon
)brace
multiline_comment|/* Setup all the sizes. */
id|vi-&gt;i_size
op_assign
id|sle64_to_cpu
c_func
(paren
id|ctx-&gt;attr
op_member_access_from_pointer
id|_ANR
c_func
(paren
id|data_size
)paren
)paren
suffix:semicolon
id|ni-&gt;initialized_size
op_assign
id|sle64_to_cpu
c_func
(paren
id|ctx-&gt;attr
op_member_access_from_pointer
id|_ANR
c_func
(paren
id|initialized_size
)paren
)paren
suffix:semicolon
id|ni-&gt;allocated_size
op_assign
id|sle64_to_cpu
c_func
(paren
id|ctx-&gt;attr
op_member_access_from_pointer
id|_ANR
c_func
(paren
id|allocated_size
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|NInoCompressed
c_func
(paren
id|ni
)paren
)paren
(brace
id|ni
op_member_access_from_pointer
id|_ICF
c_func
(paren
id|compressed_size
)paren
op_assign
id|sle64_to_cpu
c_func
(paren
id|ctx-&gt;attr
op_member_access_from_pointer
id|_ANR
c_func
(paren
id|compressed_size
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vi-&gt;i_size
op_ne
id|ni-&gt;initialized_size
)paren
id|ntfs_warning
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Compressed &quot;
l_string|&quot;file with data_size &quot;
l_string|&quot;unequal to &quot;
l_string|&quot;initialized size &quot;
l_string|&quot;found. This will &quot;
l_string|&quot;probably cause &quot;
l_string|&quot;problems when trying &quot;
l_string|&quot;to access the file. &quot;
l_string|&quot;Please notify &quot;
l_string|&quot;linux-ntfs-dev@&quot;
l_string|&quot;lists.sf.net that you&quot;
l_string|&quot;saw this message.&quot;
l_string|&quot;Thanks!&quot;
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* Resident attribute. */
multiline_comment|/*&n;&t;&t;&t; * Make all sizes equal for simplicity in read code&n;&t;&t;&t; * paths. FIXME: Need to keep this in mind when&n;&t;&t;&t; * converting to non-resident attribute in write code&n;&t;&t;&t; * path. (Probably only affects truncate().)&n;&t;&t;&t; */
id|vi-&gt;i_size
op_assign
id|ni-&gt;initialized_size
op_assign
id|ni-&gt;allocated_size
op_assign
id|le32_to_cpu
c_func
(paren
id|ctx-&gt;attr
op_member_access_from_pointer
id|_ARA
c_func
(paren
id|value_length
)paren
)paren
suffix:semicolon
)brace
id|no_data_attr_special_case
suffix:colon
multiline_comment|/* Everyone gets read permissions. */
id|vi-&gt;i_mode
op_or_assign
id|S_IRUGO
suffix:semicolon
multiline_comment|/* If not read-only, set write permissions. */
r_if
c_cond
(paren
op_logical_neg
id|IS_RDONLY
c_func
(paren
id|vi
)paren
)paren
id|vi-&gt;i_mode
op_or_assign
id|S_IWUGO
suffix:semicolon
multiline_comment|/* Apply the file permissions mask set in the mount options. */
id|vi-&gt;i_mode
op_and_assign
op_complement
id|vol-&gt;fmask
suffix:semicolon
singleline_comment|// FIXME: Encrypted files should probably get their rw bits
singleline_comment|// taken away here.
multiline_comment|/* Setup the operations for this inode. */
id|vi-&gt;i_op
op_assign
op_amp
id|ntfs_file_inode_ops
suffix:semicolon
id|vi-&gt;i_fop
op_assign
op_amp
id|ntfs_file_ops
suffix:semicolon
id|vi-&gt;i_mapping-&gt;a_ops
op_assign
op_amp
id|ntfs_file_aops
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * The number of 512-byte blocks used on disk (for stat). This is in so&n;&t; * far inaccurate as it doesn&squot;t account for any named streams or other&n;&t; * special non-resident attributes, but that is how Windows works, too,&n;&t; * so we are at least consistent with Windows, if not entirely&n;&t; * consistent with the Linux Way. Doing it the Linux Way would cause a&n;&t; * significant slowdown as it would involve iterating over all&n;&t; * attributes in the mft record and adding the allocated/compressed&n;&t; * sizes of all non-resident attributes present to give us the Linux&n;&t; * correct size that should go into i_blocks (after division by 512).&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|NInoCompressed
c_func
(paren
id|ni
)paren
)paren
id|vi-&gt;i_blocks
op_assign
id|ni-&gt;allocated_size
op_rshift
l_int|9
suffix:semicolon
r_else
id|vi-&gt;i_blocks
op_assign
id|ni
op_member_access_from_pointer
id|_ICF
c_func
(paren
id|compressed_size
)paren
op_rshift
l_int|9
suffix:semicolon
multiline_comment|/* Done. */
id|put_attr_search_ctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
id|unmap_mft_record
c_func
(paren
id|READ
comma
id|ni
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Done.&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
id|ec_put_unm_err_out
suffix:colon
id|put_attr_search_ctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
r_goto
id|ec_unm_err_out
suffix:semicolon
id|put_unm_err_out
suffix:colon
id|put_attr_search_ctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
id|unm_err_out
suffix:colon
id|err
op_assign
op_minus
id|EIO
suffix:semicolon
id|ec_unm_err_out
suffix:colon
id|unmap_mft_record
c_func
(paren
id|READ
comma
id|ni
)paren
suffix:semicolon
id|err_out
suffix:colon
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Failed with error code %i. Marking inode &quot;
l_string|&quot;%li (0x%lx) as bad.&quot;
comma
op_minus
id|err
comma
id|vi-&gt;i_ino
comma
id|vi-&gt;i_ino
)paren
suffix:semicolon
id|make_bad_inode
c_func
(paren
id|vi
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_read_inode_mount - special read_inode for mount time use only&n; * @vi:&t;&t;inode to read&n; *&n; * Read inode FILE_MFT at mount time, only called with super_block lock&n; * held from within the read_super() code path.&n; *&n; * This function exists because when it is called the page cache for $MFT/$DATA&n; * is not initialized and hence we cannot get at the contents of mft records&n; * by calling map_mft_record*().&n; *&n; * Further it needs to cope with the circular references problem, i.e. can&squot;t&n; * load any attributes other than $ATTRIBUTE_LIST until $DATA is loaded, because&n; * we don&squot;t know where the other extent mft records are yet and again, because&n; * we cannot call map_mft_record*() yet. Obviously this applies only when an&n; * attribute list is actually present in $MFT inode.&n; *&n; * We solve these problems by starting with the $DATA attribute before anything&n; * else and iterating using lookup_attr($DATA) over all extents. As each extent&n; * is found, we decompress_mapping_pairs() including the implied&n; * merge_run_lists(). Each step of the iteration necessarily provides&n; * sufficient information for the next step to complete.&n; *&n; * This should work but there are two possible pit falls (see inline comments&n; * below), but only time will tell if they are real pits or just smoke...&n; */
DECL|function|ntfs_read_inode_mount
r_void
id|ntfs_read_inode_mount
c_func
(paren
r_struct
id|inode
op_star
id|vi
)paren
(brace
id|VCN
id|next_vcn
comma
id|last_vcn
comma
id|highest_vcn
suffix:semicolon
id|s64
id|block
suffix:semicolon
r_struct
id|super_block
op_star
id|sb
op_assign
id|vi-&gt;i_sb
suffix:semicolon
id|ntfs_volume
op_star
id|vol
op_assign
id|NTFS_SB
c_func
(paren
id|sb
)paren
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
id|ntfs_inode
op_star
id|ni
suffix:semicolon
id|MFT_RECORD
op_star
id|m
op_assign
l_int|NULL
suffix:semicolon
id|ATTR_RECORD
op_star
id|attr
suffix:semicolon
id|attr_search_context
op_star
id|ctx
suffix:semicolon
r_int
r_int
id|i
comma
id|nr_blocks
suffix:semicolon
r_int
id|err
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Entering.&quot;
)paren
suffix:semicolon
multiline_comment|/* Initialize the ntfs specific part of @vi. */
id|ntfs_init_big_inode
c_func
(paren
id|vi
)paren
suffix:semicolon
id|ni
op_assign
id|NTFS_I
c_func
(paren
id|vi
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vi-&gt;i_ino
op_ne
id|FILE_MFT
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Called for inode %ld but only inode %d &quot;
l_string|&quot;allowed.&quot;
comma
id|vi-&gt;i_ino
comma
id|FILE_MFT
)paren
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * This sets up our little cheat allowing us to reuse the async io&n;&t; * completion handler for directories.&n;&t; */
id|ni
op_member_access_from_pointer
id|_IDM
c_func
(paren
id|index_block_size
)paren
op_assign
id|vol-&gt;mft_record_size
suffix:semicolon
id|ni
op_member_access_from_pointer
id|_IDM
c_func
(paren
id|index_block_size_bits
)paren
op_assign
id|vol-&gt;mft_record_size_bits
suffix:semicolon
multiline_comment|/* Very important! Needed to be able to call map_mft_record*(). */
id|vol-&gt;mft_ino
op_assign
id|vi
suffix:semicolon
multiline_comment|/* Allocate enough memory to read the first mft record. */
r_if
c_cond
(paren
id|vol-&gt;mft_record_size
OG
l_int|64
op_star
l_int|1024
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Unsupported mft record size %i (max 64kiB).&quot;
comma
id|vol-&gt;mft_record_size
)paren
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
id|i
op_assign
id|vol-&gt;mft_record_size
suffix:semicolon
r_if
c_cond
(paren
id|i
OL
id|sb-&gt;s_blocksize
)paren
id|i
op_assign
id|sb-&gt;s_blocksize
suffix:semicolon
id|m
op_assign
(paren
id|MFT_RECORD
op_star
)paren
id|ntfs_malloc_nofs
c_func
(paren
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|m
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Failed to allocate buffer for $MFT record 0.&quot;
)paren
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
multiline_comment|/* Determine the first block of the $MFT/$DATA attribute. */
id|block
op_assign
id|vol-&gt;mft_lcn
op_lshift
id|vol-&gt;cluster_size_bits
op_rshift
id|sb-&gt;s_blocksize_bits
suffix:semicolon
id|nr_blocks
op_assign
id|vol-&gt;mft_record_size
op_rshift
id|sb-&gt;s_blocksize_bits
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|nr_blocks
)paren
id|nr_blocks
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Load $MFT/$DATA&squot;s first mft record. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr_blocks
suffix:semicolon
id|i
op_increment
)paren
(brace
id|bh
op_assign
id|sb_bread
c_func
(paren
id|sb
comma
id|block
op_increment
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bh
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Device read failed.&quot;
)paren
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
id|memcpy
c_func
(paren
(paren
r_char
op_star
)paren
id|m
op_plus
(paren
id|i
op_lshift
id|sb-&gt;s_blocksize_bits
)paren
comma
id|bh-&gt;b_data
comma
id|sb-&gt;s_blocksize
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
multiline_comment|/* Apply the mst fixups. */
r_if
c_cond
(paren
id|post_read_mst_fixup
c_func
(paren
(paren
id|NTFS_RECORD
op_star
)paren
id|m
comma
id|vol-&gt;mft_record_size
)paren
)paren
(brace
multiline_comment|/* FIXME: Try to use the $MFTMirr now. */
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;MST fixup failed. $MFT is corrupt.&quot;
)paren
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
multiline_comment|/* Need this to sanity check attribute list references to $MFT. */
id|ni-&gt;seq_no
op_assign
id|le16_to_cpu
c_func
(paren
id|m-&gt;sequence_number
)paren
suffix:semicolon
multiline_comment|/* Provides readpage() and sync_page() for map_mft_record(READ). */
id|vi-&gt;i_mapping-&gt;a_ops
op_assign
op_amp
id|ntfs_mft_aops
suffix:semicolon
id|err
op_assign
id|get_attr_search_ctx
c_func
(paren
op_amp
id|ctx
comma
id|ni
comma
id|m
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|err_out
suffix:semicolon
multiline_comment|/* Find the attribute list attribute if present. */
r_if
c_cond
(paren
id|lookup_attr
c_func
(paren
id|AT_ATTRIBUTE_LIST
comma
l_int|NULL
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|NULL
comma
l_int|0
comma
id|ctx
)paren
)paren
(brace
id|ATTR_LIST_ENTRY
op_star
id|al_entry
comma
op_star
id|next_al_entry
suffix:semicolon
id|u8
op_star
id|al_end
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Attribute list attribute found in $MFT.&quot;
)paren
suffix:semicolon
id|ni-&gt;state
op_or_assign
l_int|1
op_lshift
id|NI_AttrList
suffix:semicolon
r_if
c_cond
(paren
id|ctx-&gt;attr-&gt;flags
op_amp
id|ATTR_IS_ENCRYPTED
op_logical_or
id|ctx-&gt;attr-&gt;flags
op_amp
id|ATTR_COMPRESSION_MASK
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Attribute list attribute is &quot;
l_string|&quot;compressed/encrypted. Not allowed. &quot;
l_string|&quot;$MFT is corrupt. You should run &quot;
l_string|&quot;chkdsk.&quot;
)paren
suffix:semicolon
r_goto
id|put_err_out
suffix:semicolon
)brace
multiline_comment|/* Now allocate memory for the attribute list. */
id|ni-&gt;attr_list_size
op_assign
(paren
id|u32
)paren
id|attribute_value_length
c_func
(paren
id|ctx-&gt;attr
)paren
suffix:semicolon
id|ni-&gt;attr_list
op_assign
id|ntfs_malloc_nofs
c_func
(paren
id|ni-&gt;attr_list_size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ni-&gt;attr_list
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Not enough memory to allocate buffer &quot;
l_string|&quot;for attribute list.&quot;
)paren
suffix:semicolon
r_goto
id|put_err_out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ctx-&gt;attr-&gt;non_resident
)paren
(brace
id|ni-&gt;state
op_or_assign
l_int|1
op_lshift
id|NI_AttrListNonResident
suffix:semicolon
r_if
c_cond
(paren
id|ctx-&gt;attr
op_member_access_from_pointer
id|_ANR
c_func
(paren
id|lowest_vcn
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Attribute list has non zero &quot;
l_string|&quot;lowest_vcn. $MFT is corrupt. &quot;
l_string|&quot;You should run chkdsk.&quot;
)paren
suffix:semicolon
r_goto
id|put_err_out
suffix:semicolon
)brace
multiline_comment|/* Setup the run list. */
id|ni-&gt;attr_list_rl.rl
op_assign
id|decompress_mapping_pairs
c_func
(paren
id|vol
comma
id|ctx-&gt;attr
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|ni-&gt;attr_list_rl.rl
)paren
)paren
(brace
id|err
op_assign
id|PTR_ERR
c_func
(paren
id|ni-&gt;attr_list_rl.rl
)paren
suffix:semicolon
id|ni-&gt;attr_list_rl.rl
op_assign
l_int|NULL
suffix:semicolon
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Mapping pairs decompression &quot;
l_string|&quot;failed with error code %i.&quot;
comma
op_minus
id|err
)paren
suffix:semicolon
r_goto
id|put_err_out
suffix:semicolon
)brace
multiline_comment|/* Now load the attribute list. */
r_if
c_cond
(paren
(paren
id|err
op_assign
id|load_attribute_list
c_func
(paren
id|vol
comma
op_amp
id|ni-&gt;attr_list_rl
comma
id|ni-&gt;attr_list
comma
id|ni-&gt;attr_list_size
comma
id|sle64_to_cpu
c_func
(paren
id|ctx-&gt;attr
op_member_access_from_pointer
id|_ANR
c_func
(paren
id|initialized_size
)paren
)paren
)paren
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Failed to load attribute list &quot;
l_string|&quot;attribute with error code %i.&quot;
comma
op_minus
id|err
)paren
suffix:semicolon
r_goto
id|put_err_out
suffix:semicolon
)brace
)brace
r_else
multiline_comment|/* if (!ctx.attr-&gt;non_resident) */
(brace
r_if
c_cond
(paren
(paren
id|u8
op_star
)paren
id|ctx-&gt;attr
op_plus
id|le16_to_cpu
c_func
(paren
id|ctx-&gt;attr
op_member_access_from_pointer
id|_ARA
c_func
(paren
id|value_offset
)paren
)paren
op_plus
id|le32_to_cpu
c_func
(paren
id|ctx-&gt;attr
op_member_access_from_pointer
id|_ARA
c_func
(paren
id|value_length
)paren
)paren
OG
(paren
id|u8
op_star
)paren
id|ctx-&gt;mrec
op_plus
id|vol-&gt;mft_record_size
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Corrupt attribute list &quot;
l_string|&quot;attribute.&quot;
)paren
suffix:semicolon
r_goto
id|put_err_out
suffix:semicolon
)brace
multiline_comment|/* Now copy the attribute list. */
id|memcpy
c_func
(paren
id|ni-&gt;attr_list
comma
(paren
id|u8
op_star
)paren
id|ctx-&gt;attr
op_plus
id|le16_to_cpu
c_func
(paren
id|ctx-&gt;attr
op_member_access_from_pointer
id|_ARA
c_func
(paren
id|value_offset
)paren
)paren
comma
id|le32_to_cpu
c_func
(paren
id|ctx-&gt;attr
op_member_access_from_pointer
id|_ARA
c_func
(paren
id|value_length
)paren
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* The attribute list is now setup in memory. */
multiline_comment|/*&n;&t;&t; * FIXME: I don&squot;t know if this case is actually possible.&n;&t;&t; * According to logic it is not possible but I have seen too&n;&t;&t; * many weird things in MS software to rely on logic... Thus we&n;&t;&t; * perform a manual search and make sure the first $MFT/$DATA&n;&t;&t; * extent is in the base inode. If it is not we abort with an&n;&t;&t; * error and if we ever see a report of this error we will need&n;&t;&t; * to do some magic in order to have the necessary mft record&n;&t;&t; * loaded and in the right place in the page cache. But&n;&t;&t; * hopefully logic will prevail and this never happens...&n;&t;&t; */
id|al_entry
op_assign
(paren
id|ATTR_LIST_ENTRY
op_star
)paren
id|ni-&gt;attr_list
suffix:semicolon
id|al_end
op_assign
(paren
id|u8
op_star
)paren
id|al_entry
op_plus
id|ni-&gt;attr_list_size
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
id|al_entry
op_assign
id|next_al_entry
)paren
(brace
multiline_comment|/* Out of bounds check. */
r_if
c_cond
(paren
(paren
id|u8
op_star
)paren
id|al_entry
template_param
id|al_end
)paren
r_goto
id|em_put_err_out
suffix:semicolon
multiline_comment|/* Catch the end of the attribute list. */
r_if
c_cond
(paren
(paren
id|u8
op_star
)paren
id|al_entry
op_eq
id|al_end
)paren
r_goto
id|em_put_err_out
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|al_entry-&gt;length
)paren
r_goto
id|em_put_err_out
suffix:semicolon
r_if
c_cond
(paren
(paren
id|u8
op_star
)paren
id|al_entry
op_plus
l_int|6
OG
id|al_end
op_logical_or
(paren
id|u8
op_star
)paren
id|al_entry
op_plus
id|le16_to_cpu
c_func
(paren
id|al_entry-&gt;length
)paren
OG
id|al_end
)paren
r_goto
id|em_put_err_out
suffix:semicolon
id|next_al_entry
op_assign
(paren
id|ATTR_LIST_ENTRY
op_star
)paren
(paren
(paren
id|u8
op_star
)paren
id|al_entry
op_plus
id|le16_to_cpu
c_func
(paren
id|al_entry-&gt;length
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|le32_to_cpu
c_func
(paren
id|al_entry-&gt;type
)paren
OG
id|const_le32_to_cpu
c_func
(paren
id|AT_DATA
)paren
)paren
r_goto
id|em_put_err_out
suffix:semicolon
r_if
c_cond
(paren
id|AT_DATA
op_ne
id|al_entry-&gt;type
)paren
r_continue
suffix:semicolon
multiline_comment|/* We want an unnamed attribute. */
r_if
c_cond
(paren
id|al_entry-&gt;name_length
)paren
r_goto
id|em_put_err_out
suffix:semicolon
multiline_comment|/* Want the first entry, i.e. lowest_vcn == 0. */
r_if
c_cond
(paren
id|al_entry-&gt;lowest_vcn
)paren
r_goto
id|em_put_err_out
suffix:semicolon
multiline_comment|/* First entry has to be in the base mft record. */
r_if
c_cond
(paren
id|MREF_LE
c_func
(paren
id|al_entry-&gt;mft_reference
)paren
op_ne
id|ni-&gt;mft_no
)paren
(brace
multiline_comment|/* MFT references do not match, logic fails. */
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;BUG: The first $DATA extent &quot;
l_string|&quot;of $MFT is not in the base &quot;
l_string|&quot;mft record. Please report &quot;
l_string|&quot;you saw this message to &quot;
l_string|&quot;linux-ntfs-dev@lists.sf.net&quot;
)paren
suffix:semicolon
r_goto
id|put_err_out
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Sequence numbers must match. */
r_if
c_cond
(paren
id|MSEQNO_LE
c_func
(paren
id|al_entry-&gt;mft_reference
)paren
op_ne
id|ni-&gt;seq_no
)paren
r_goto
id|em_put_err_out
suffix:semicolon
multiline_comment|/* Got it. All is ok. We can stop now. */
r_break
suffix:semicolon
)brace
)brace
)brace
id|reinit_attr_search_ctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
multiline_comment|/* Now load all attribute extents. */
id|attr
op_assign
l_int|NULL
suffix:semicolon
id|next_vcn
op_assign
id|last_vcn
op_assign
id|highest_vcn
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|lookup_attr
c_func
(paren
id|AT_DATA
comma
l_int|NULL
comma
l_int|0
comma
l_int|0
comma
id|next_vcn
comma
l_int|NULL
comma
l_int|0
comma
id|ctx
)paren
)paren
(brace
id|run_list_element
op_star
id|nrl
suffix:semicolon
multiline_comment|/* Cache the current attribute. */
id|attr
op_assign
id|ctx-&gt;attr
suffix:semicolon
multiline_comment|/* $MFT must be non-resident. */
r_if
c_cond
(paren
op_logical_neg
id|attr-&gt;non_resident
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;$MFT must be non-resident but a &quot;
l_string|&quot;resident extent was found. $MFT is &quot;
l_string|&quot;corrupt. Run chkdsk.&quot;
)paren
suffix:semicolon
r_goto
id|put_err_out
suffix:semicolon
)brace
multiline_comment|/* $MFT must be uncompressed and unencrypted. */
r_if
c_cond
(paren
id|attr-&gt;flags
op_amp
id|ATTR_COMPRESSION_MASK
op_logical_or
id|attr-&gt;flags
op_amp
id|ATTR_IS_ENCRYPTED
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;$MFT must be uncompressed and &quot;
l_string|&quot;unencrypted but a compressed/&quot;
l_string|&quot;encrypted extent was found. &quot;
l_string|&quot;$MFT is corrupt. Run chkdsk.&quot;
)paren
suffix:semicolon
r_goto
id|put_err_out
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Decompress the mapping pairs array of this extent and merge&n;&t;&t; * the result into the existing run list. No need for locking&n;&t;&t; * as we have exclusive access to the inode at this time and we&n;&t;&t; * are a mount in progress task, too.&n;&t;&t; */
id|nrl
op_assign
id|decompress_mapping_pairs
c_func
(paren
id|vol
comma
id|attr
comma
id|ni-&gt;run_list.rl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|nrl
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;decompress_mapping_pairs() failed with &quot;
l_string|&quot;error code %ld. $MFT is corrupt.&quot;
comma
id|PTR_ERR
c_func
(paren
id|nrl
)paren
)paren
suffix:semicolon
r_goto
id|put_err_out
suffix:semicolon
)brace
id|ni-&gt;run_list.rl
op_assign
id|nrl
suffix:semicolon
multiline_comment|/* Are we in the first extent? */
r_if
c_cond
(paren
op_logical_neg
id|next_vcn
)paren
(brace
r_if
c_cond
(paren
id|attr
op_member_access_from_pointer
id|_ANR
c_func
(paren
id|lowest_vcn
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;First extent of $DATA &quot;
l_string|&quot;attribute has non zero &quot;
l_string|&quot;lowest_vcn. $MFT is corrupt. &quot;
l_string|&quot;You should run chkdsk.&quot;
)paren
suffix:semicolon
r_goto
id|put_err_out
suffix:semicolon
)brace
multiline_comment|/* Get the last vcn in the $DATA attribute. */
id|last_vcn
op_assign
id|sle64_to_cpu
c_func
(paren
id|attr
op_member_access_from_pointer
id|_ANR
c_func
(paren
id|allocated_size
)paren
)paren
op_rshift
id|vol-&gt;cluster_size_bits
suffix:semicolon
multiline_comment|/* Fill in the inode size. */
id|vi-&gt;i_size
op_assign
id|sle64_to_cpu
c_func
(paren
id|attr
op_member_access_from_pointer
id|_ANR
c_func
(paren
id|data_size
)paren
)paren
suffix:semicolon
id|ni-&gt;initialized_size
op_assign
id|sle64_to_cpu
c_func
(paren
id|attr
op_member_access_from_pointer
id|_ANR
c_func
(paren
id|initialized_size
)paren
)paren
suffix:semicolon
id|ni-&gt;allocated_size
op_assign
id|sle64_to_cpu
c_func
(paren
id|attr
op_member_access_from_pointer
id|_ANR
c_func
(paren
id|allocated_size
)paren
)paren
suffix:semicolon
multiline_comment|/* Set the number of mft records. */
id|vol
op_member_access_from_pointer
id|_VMM
c_func
(paren
id|nr_mft_records
)paren
op_assign
id|vi-&gt;i_size
op_rshift
id|vol-&gt;mft_record_size_bits
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * We have got the first extent of the run_list for&n;&t;&t;&t; * $MFT which means it is now relatively safe to call&n;&t;&t;&t; * the normal ntfs_read_inode() function. Thus, take&n;&t;&t;&t; * us out of the calling chain. Also we need to do this&n;&t;&t;&t; * now because we need ntfs_read_inode() in place to&n;&t;&t;&t; * get at subsequent extents.&n;&t;&t;&t; */
id|sb-&gt;s_op
op_assign
op_amp
id|ntfs_sops
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Complete reading the inode, this will actually&n;&t;&t;&t; * re-read the mft record for $MFT, this time entering&n;&t;&t;&t; * it into the page cache with which we complete the&n;&t;&t;&t; * kick start of the volume. It should be safe to do&n;&t;&t;&t; * this now as the first extent of $MFT/$DATA is&n;&t;&t;&t; * already known and we would hope that we don&squot;t need&n;&t;&t;&t; * further extents in order to find the other&n;&t;&t;&t; * attributes belonging to $MFT. Only time will tell if&n;&t;&t;&t; * this is really the case. If not we will have to play&n;&t;&t;&t; * magic at this point, possibly duplicating a lot of&n;&t;&t;&t; * ntfs_read_inode() at this point. We will need to&n;&t;&t;&t; * ensure we do enough of its work to be able to call&n;&t;&t;&t; * ntfs_read_inode() on extents of $MFT/$DATA. But lets&n;&t;&t;&t; * hope this never happens...&n;&t;&t;&t; */
id|ntfs_read_inode
c_func
(paren
id|vi
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_bad_inode
c_func
(paren
id|vi
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;ntfs_read_inode() of $MFT &quot;
l_string|&quot;failed. BUG or corrupt $MFT. &quot;
l_string|&quot;Run chkdsk and if no errors &quot;
l_string|&quot;are found, please report you &quot;
l_string|&quot;saw this message to &quot;
l_string|&quot;linux-ntfs-dev@lists.sf.net&quot;
)paren
suffix:semicolon
id|put_attr_search_ctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
multiline_comment|/* Revert to the safe super operations. */
id|sb-&gt;s_op
op_assign
op_amp
id|ntfs_mount_sops
suffix:semicolon
r_goto
id|out_now
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * Re-initialize some specifics about $MFT&squot;s inode as&n;&t;&t;&t; * ntfs_read_inode() will have set up the default ones.&n;&t;&t;&t; */
multiline_comment|/* Set uid and gid to root. */
id|vi-&gt;i_uid
op_assign
id|vi-&gt;i_gid
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Regular file. No access for anyone. */
id|vi-&gt;i_mode
op_assign
id|S_IFREG
suffix:semicolon
multiline_comment|/* No VFS initiated operations allowed for $MFT. */
id|vi-&gt;i_op
op_assign
op_amp
id|ntfs_empty_inode_ops
suffix:semicolon
id|vi-&gt;i_fop
op_assign
op_amp
id|ntfs_empty_file_ops
suffix:semicolon
multiline_comment|/* Put back our special address space operations. */
id|vi-&gt;i_mapping-&gt;a_ops
op_assign
op_amp
id|ntfs_mft_aops
suffix:semicolon
)brace
multiline_comment|/* Get the lowest vcn for the next extent. */
id|highest_vcn
op_assign
id|sle64_to_cpu
c_func
(paren
id|attr
op_member_access_from_pointer
id|_ANR
c_func
(paren
id|highest_vcn
)paren
)paren
suffix:semicolon
id|next_vcn
op_assign
id|highest_vcn
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* Only one extent or error, which we catch below. */
r_if
c_cond
(paren
id|next_vcn
op_le
l_int|0
)paren
r_break
suffix:semicolon
multiline_comment|/* Avoid endless loops due to corruption. */
r_if
c_cond
(paren
id|next_vcn
OL
id|sle64_to_cpu
c_func
(paren
id|attr
op_member_access_from_pointer
id|_ANR
c_func
(paren
id|lowest_vcn
)paren
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;$MFT has corrupt attribute list &quot;
l_string|&quot;attribute. Run chkdsk.&quot;
)paren
suffix:semicolon
r_goto
id|put_err_out
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|attr
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;$MFT/$DATA attribute not found. $MFT is &quot;
l_string|&quot;corrupt. Run chkdsk.&quot;
)paren
suffix:semicolon
r_goto
id|put_err_out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|highest_vcn
op_logical_and
id|highest_vcn
op_ne
id|last_vcn
op_minus
l_int|1
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Failed to load the complete run list &quot;
l_string|&quot;for $MFT/$DATA. Driver bug or &quot;
l_string|&quot;corrupt $MFT. Run chkdsk.&quot;
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;highest_vcn = 0x%Lx, last_vcn - 1 = 0x%Lx&quot;
comma
(paren
r_int
r_int
)paren
id|highest_vcn
comma
(paren
r_int
r_int
)paren
id|last_vcn
op_minus
l_int|1
)paren
suffix:semicolon
r_goto
id|put_err_out
suffix:semicolon
)brace
id|put_attr_search_ctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Done.&quot;
)paren
suffix:semicolon
id|out_now
suffix:colon
id|ntfs_free
c_func
(paren
id|m
)paren
suffix:semicolon
r_return
suffix:semicolon
id|em_put_err_out
suffix:colon
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Couldn&squot;t find first extent of $DATA attribute in &quot;
l_string|&quot;attribute list. $MFT is corrupt. Run chkdsk.&quot;
)paren
suffix:semicolon
id|put_err_out
suffix:colon
id|put_attr_search_ctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
id|err_out
suffix:colon
multiline_comment|/* Make sure we revert to the safe super operations. */
id|sb-&gt;s_op
op_assign
op_amp
id|ntfs_mount_sops
suffix:semicolon
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Failed. Marking inode as bad.&quot;
)paren
suffix:semicolon
id|make_bad_inode
c_func
(paren
id|vi
)paren
suffix:semicolon
r_goto
id|out_now
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_dirty_inode - mark the inode&squot;s metadata dirty&n; * @vi:&t;&t;inode to mark dirty&n; *&n; * This is called from fs/inode.c::__mark_inode_dirty(), when the inode itself&n; * is being marked dirty. An example is when UPDATE_ATIME() is invoked.&n; *&n; * We mark the inode dirty by setting both the page in which the mft record&n; * resides and the buffer heads in that page which correspond to the mft record&n; * dirty. This ensures that the changes will eventually be propagated to disk&n; * when the inode is set dirty.&n; *&n; * FIXME: Can we do that with the buffer heads? I am not too sure. Because if we&n; * do that we need to make sure that the kernel will not write out those buffer&n; * heads or we are screwed as it will write corrupt data to disk. The only way&n; * a mft record can be written correctly is by mst protecting it, writting it&n; * synchronously and fast mst deprotecting it. During this period, obviously,&n; * the mft record must be marked as not uptodate, be locked for writing or&n; * whatever, so that nobody attempts anything stupid.&n; *&n; * FIXME: Do we need to check that the fs is not mounted read only? And what&n; * about the inode? Anything else?&n; *&n; * FIXME: As we are only a read only driver it is safe to just return here for&n; * the moment.&n; */
DECL|function|ntfs_dirty_inode
r_void
id|ntfs_dirty_inode
c_func
(paren
r_struct
id|inode
op_star
id|vi
)paren
(brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Entering for inode 0x%lx.&quot;
comma
id|vi-&gt;i_ino
)paren
suffix:semicolon
id|NInoSetDirty
c_func
(paren
id|NTFS_I
c_func
(paren
id|vi
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_commit_inode - write out a dirty inode&n; * @ni:&t;&t;inode to write out&n; *&n; */
DECL|function|ntfs_commit_inode
r_int
id|ntfs_commit_inode
c_func
(paren
id|ntfs_inode
op_star
id|ni
)paren
(brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Entering for inode 0x%Lx.&quot;
comma
(paren
r_int
r_int
r_int
)paren
id|ni-&gt;mft_no
)paren
suffix:semicolon
id|NInoClearDirty
c_func
(paren
id|ni
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|__ntfs_clear_inode
r_void
id|__ntfs_clear_inode
c_func
(paren
id|ntfs_inode
op_star
id|ni
)paren
(brace
r_int
id|err
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Entering for inode 0x%Lx.&quot;
comma
(paren
r_int
r_int
r_int
)paren
id|ni-&gt;mft_no
)paren
suffix:semicolon
r_if
c_cond
(paren
id|NInoDirty
c_func
(paren
id|ni
)paren
)paren
(brace
id|err
op_assign
id|ntfs_commit_inode
c_func
(paren
id|ni
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|ntfs_error
c_func
(paren
id|ni-&gt;vol-&gt;sb
comma
l_string|&quot;Failed to commit dirty &quot;
l_string|&quot;inode synchronously.&quot;
)paren
suffix:semicolon
singleline_comment|// FIXME: Do something!!!
)brace
)brace
multiline_comment|/* Synchronize with ntfs_commit_inode(). */
id|down_write
c_func
(paren
op_amp
id|ni-&gt;mrec_lock
)paren
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|ni-&gt;mrec_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|NInoDirty
c_func
(paren
id|ni
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|ni-&gt;vol-&gt;sb
comma
l_string|&quot;Failed to commit dirty inode &quot;
l_string|&quot;asynchronously.&quot;
)paren
suffix:semicolon
singleline_comment|// FIXME: Do something!!!
)brace
multiline_comment|/* No need to lock at this stage as no one else has a reference. */
r_if
c_cond
(paren
id|ni-&gt;nr_extents
OG
l_int|0
)paren
(brace
r_int
id|i
suffix:semicolon
singleline_comment|// FIXME: Handle dirty case for each extent inode!
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ni-&gt;nr_extents
suffix:semicolon
id|i
op_increment
)paren
id|ntfs_destroy_inode
c_func
(paren
id|ni
op_member_access_from_pointer
id|_INE
c_func
(paren
id|extent_ntfs_inos
)paren
(braket
id|i
)braket
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|ni
op_member_access_from_pointer
id|_INE
c_func
(paren
id|extent_ntfs_inos
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Free all alocated memory. */
id|down_write
c_func
(paren
op_amp
id|ni-&gt;run_list.lock
)paren
suffix:semicolon
id|ntfs_free
c_func
(paren
id|ni-&gt;run_list.rl
)paren
suffix:semicolon
id|ni-&gt;run_list.rl
op_assign
l_int|NULL
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|ni-&gt;run_list.lock
)paren
suffix:semicolon
id|ntfs_free
c_func
(paren
id|ni-&gt;attr_list
)paren
suffix:semicolon
id|down_write
c_func
(paren
op_amp
id|ni-&gt;attr_list_rl.lock
)paren
suffix:semicolon
id|ntfs_free
c_func
(paren
id|ni-&gt;attr_list_rl.rl
)paren
suffix:semicolon
id|ni-&gt;attr_list_rl.rl
op_assign
l_int|NULL
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|ni-&gt;attr_list_rl.lock
)paren
suffix:semicolon
)brace
DECL|function|ntfs_clear_inode
r_void
id|ntfs_clear_inode
c_func
(paren
id|ntfs_inode
op_star
id|ni
)paren
(brace
id|__ntfs_clear_inode
c_func
(paren
id|ni
)paren
suffix:semicolon
multiline_comment|/* Bye, bye... */
id|ntfs_destroy_inode
c_func
(paren
id|ni
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_clear_big_inode - clean up the ntfs specific part of an inode&n; * @vi:&t;&t;vfs inode pending annihilation&n; *&n; * When the VFS is going to remove an inode from memory, ntfs_clear_big_inode()&n; * is called, which deallocates all memory belonging to the NTFS specific part&n; * of the inode and returns.&n; *&n; * If the MFT record is dirty, we commit it before doing anything else.&n; */
DECL|function|ntfs_clear_big_inode
r_void
id|ntfs_clear_big_inode
c_func
(paren
r_struct
id|inode
op_star
id|vi
)paren
(brace
id|ntfs_inode
op_star
id|ni
op_assign
id|NTFS_I
c_func
(paren
id|vi
)paren
suffix:semicolon
id|__ntfs_clear_inode
c_func
(paren
id|ni
)paren
suffix:semicolon
r_if
c_cond
(paren
id|S_ISDIR
c_func
(paren
id|vi-&gt;i_mode
)paren
)paren
(brace
id|down_write
c_func
(paren
op_amp
id|ni
op_member_access_from_pointer
id|_IDM
c_func
(paren
id|bmp_rl
)paren
dot
id|lock
)paren
suffix:semicolon
id|ntfs_free
c_func
(paren
id|ni
op_member_access_from_pointer
id|_IDM
c_func
(paren
id|bmp_rl
)paren
dot
id|rl
)paren
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|ni
op_member_access_from_pointer
id|_IDM
c_func
(paren
id|bmp_rl
)paren
dot
id|lock
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
DECL|variable|si_readdir_opts_arr
r_static
r_const
id|option_t
id|si_readdir_opts_arr
(braket
)braket
op_assign
(brace
(brace
id|SHOW_SYSTEM
comma
l_string|&quot;system&quot;
)brace
comma
(brace
id|SHOW_WIN32
comma
l_string|&quot;win32&quot;
)brace
comma
(brace
id|SHOW_DOS
comma
l_string|&quot;dos&quot;
)brace
comma
(brace
l_int|0
comma
l_int|NULL
)brace
)brace
suffix:semicolon
multiline_comment|/**&n; * ntfs_show_options - show mount options in /proc/mounts&n; * @sf:&t;&t;seq_file in which to write our mount options&n; * @mnt:&t;vfs mount whose mount options to display&n; *&n; * Called by the VFS once for each mounted ntfs volume when someone reads&n; * /proc/mounts in order to display the NTFS specific mount options of each&n; * mount. The mount options of the vfs mount @mnt are written to the seq file&n; * @sf and success is returned.&n; */
DECL|function|ntfs_show_options
r_int
id|ntfs_show_options
c_func
(paren
r_struct
id|seq_file
op_star
id|sf
comma
r_struct
id|vfsmount
op_star
id|mnt
)paren
(brace
id|ntfs_volume
op_star
id|vol
op_assign
id|NTFS_SB
c_func
(paren
id|mnt-&gt;mnt_sb
)paren
suffix:semicolon
r_int
id|i
suffix:semicolon
id|seq_printf
c_func
(paren
id|sf
comma
l_string|&quot;,uid=%i&quot;
comma
id|vol-&gt;uid
)paren
suffix:semicolon
id|seq_printf
c_func
(paren
id|sf
comma
l_string|&quot;,gid=%i&quot;
comma
id|vol-&gt;gid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vol-&gt;fmask
op_eq
id|vol-&gt;dmask
)paren
id|seq_printf
c_func
(paren
id|sf
comma
l_string|&quot;,umask=0%o&quot;
comma
id|vol-&gt;fmask
)paren
suffix:semicolon
r_else
(brace
id|seq_printf
c_func
(paren
id|sf
comma
l_string|&quot;,fmask=0%o&quot;
comma
id|vol-&gt;fmask
)paren
suffix:semicolon
id|seq_printf
c_func
(paren
id|sf
comma
l_string|&quot;,dmask=0%o&quot;
comma
id|vol-&gt;dmask
)paren
suffix:semicolon
)brace
id|seq_printf
c_func
(paren
id|sf
comma
l_string|&quot;,nls=%s&quot;
comma
id|vol-&gt;nls_map-&gt;charset
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|vol-&gt;readdir_opts
)paren
(brace
r_case
id|SHOW_ALL
suffix:colon
id|seq_printf
c_func
(paren
id|sf
comma
l_string|&quot;,show_inodes=all&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SHOW_POSIX
suffix:colon
id|seq_printf
c_func
(paren
id|sf
comma
l_string|&quot;,show_inodes=posix&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|si_readdir_opts_arr
(braket
id|i
)braket
dot
id|val
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|si_readdir_opts_arr
(braket
id|i
)braket
dot
id|val
op_amp
id|vol-&gt;readdir_opts
)paren
id|seq_printf
c_func
(paren
id|sf
comma
l_string|&quot;,show_inodes=%s&quot;
comma
id|si_readdir_opts_arr
(braket
id|i
)braket
dot
id|str
)paren
suffix:semicolon
)brace
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|on_errors_arr
(braket
id|i
)braket
dot
id|val
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|on_errors_arr
(braket
id|i
)braket
dot
id|val
op_amp
id|vol-&gt;on_errors
)paren
id|seq_printf
c_func
(paren
id|sf
comma
l_string|&quot;,errors=%s&quot;
comma
id|on_errors_arr
(braket
id|i
)braket
dot
id|str
)paren
suffix:semicolon
)brace
id|seq_printf
c_func
(paren
id|sf
comma
l_string|&quot;,mft_zone_multiplier=%i&quot;
comma
id|vol-&gt;mft_zone_multiplier
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
eof
