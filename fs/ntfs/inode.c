multiline_comment|/*&n; * inode.c&n; *&n; * Copyright (C) 1995-1999 Martin von L&#xfffd;wis&n; * Copyright (C) 1996 Albert D. Cahalan&n; * Copyright (C) 1996-1997 R&#xfffd;gis Duchesne&n; * Copyright (C) 1998 Joseph Malicki&n; * Copyright (C) 1999 Steve Dodd&n; * Copyright (C) 2000-2001 Anton Altaparmakov (AIA)&n; */
macro_line|#include &quot;ntfstypes.h&quot;
macro_line|#include &quot;ntfsendian.h&quot;
macro_line|#include &quot;struct.h&quot;
macro_line|#include &quot;inode.h&quot;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &quot;macros.h&quot;
macro_line|#include &quot;attr.h&quot;
macro_line|#include &quot;super.h&quot;
macro_line|#include &quot;dir.h&quot;
macro_line|#include &quot;support.h&quot;
macro_line|#include &quot;util.h&quot;
macro_line|#include &lt;linux/ntfs_fs.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
r_typedef
r_struct
(brace
DECL|member|recno
r_int
id|recno
suffix:semicolon
DECL|member|record
r_int
r_char
op_star
id|record
suffix:semicolon
DECL|typedef|ntfs_mft_record
)brace
id|ntfs_mft_record
suffix:semicolon
r_typedef
r_struct
(brace
DECL|member|size
r_int
id|size
suffix:semicolon
DECL|member|count
r_int
id|count
suffix:semicolon
DECL|member|records
id|ntfs_mft_record
op_star
id|records
suffix:semicolon
DECL|typedef|ntfs_disk_inode
)brace
id|ntfs_disk_inode
suffix:semicolon
DECL|function|ntfs_fill_mft_header
r_void
id|ntfs_fill_mft_header
c_func
(paren
id|ntfs_u8
op_star
id|mft
comma
r_int
id|record_size
comma
r_int
id|blocksize
comma
r_int
id|sequence_number
)paren
(brace
r_int
id|fixup_count
op_assign
id|record_size
op_div
id|blocksize
op_plus
l_int|1
suffix:semicolon
r_int
id|attr_offset
op_assign
(paren
l_int|0x2a
op_plus
(paren
l_int|2
op_star
id|fixup_count
)paren
op_plus
l_int|7
)paren
op_amp
op_complement
l_int|7
suffix:semicolon
r_int
id|fixup_offset
op_assign
l_int|0x2a
suffix:semicolon
id|NTFS_PUTU32
c_func
(paren
id|mft
op_plus
l_int|0x00
comma
l_int|0x454c4946
)paren
suffix:semicolon
multiline_comment|/* FILE */
id|NTFS_PUTU16
c_func
(paren
id|mft
op_plus
l_int|0x04
comma
l_int|0x2a
)paren
suffix:semicolon
multiline_comment|/* Offset to fixup. */
id|NTFS_PUTU16
c_func
(paren
id|mft
op_plus
l_int|0x06
comma
id|fixup_count
)paren
suffix:semicolon
multiline_comment|/* Number of fixups. */
id|NTFS_PUTU16
c_func
(paren
id|mft
op_plus
l_int|0x10
comma
id|sequence_number
)paren
suffix:semicolon
multiline_comment|/* Sequence number. */
id|NTFS_PUTU16
c_func
(paren
id|mft
op_plus
l_int|0x12
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Hard link count. */
id|NTFS_PUTU16
c_func
(paren
id|mft
op_plus
l_int|0x14
comma
id|attr_offset
)paren
suffix:semicolon
multiline_comment|/* Offset to attributes. */
id|NTFS_PUTU16
c_func
(paren
id|mft
op_plus
l_int|0x16
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Flags: 1 = In use,&n;&t;&t;&t;&t;&t;&t;&t;       2 = Directory. */
id|NTFS_PUTU32
c_func
(paren
id|mft
op_plus
l_int|0x18
comma
id|attr_offset
op_plus
l_int|0x08
)paren
suffix:semicolon
multiline_comment|/* Bytes in use. */
id|NTFS_PUTU32
c_func
(paren
id|mft
op_plus
l_int|0x1c
comma
id|record_size
)paren
suffix:semicolon
multiline_comment|/* Total allocated size. */
id|NTFS_PUTU16
c_func
(paren
id|mft
op_plus
id|fixup_offset
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Fixup word. */
id|NTFS_PUTU32
c_func
(paren
id|mft
op_plus
id|attr_offset
comma
l_int|0xffffffff
)paren
suffix:semicolon
multiline_comment|/* End marker. */
)brace
multiline_comment|/* Search in an inode an attribute by type and name. &n; * FIXME: Check that when attributes are inserted all attribute list&n; * attributes are expanded otherwise need to modify this function to deal&n; * with attribute lists. (AIA) */
DECL|function|ntfs_find_attr
id|ntfs_attribute
op_star
id|ntfs_find_attr
c_func
(paren
id|ntfs_inode
op_star
id|ino
comma
r_int
id|type
comma
r_char
op_star
id|name
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ino
)paren
(brace
id|ntfs_error
c_func
(paren
l_string|&quot;ntfs_find_attr: NO INODE!&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ino-&gt;attr_count
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|type
OL
id|ino-&gt;attrs
(braket
id|i
)braket
dot
id|type
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|type
op_eq
id|ino-&gt;attrs
(braket
id|i
)braket
dot
id|type
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|name
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ino-&gt;attrs
(braket
id|i
)braket
dot
id|name
)paren
r_return
id|ino-&gt;attrs
op_plus
id|i
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ino-&gt;attrs
(braket
id|i
)braket
dot
id|name
op_logical_and
op_logical_neg
id|ntfs_ua_strncmp
c_func
(paren
id|ino-&gt;attrs
(braket
id|i
)braket
dot
id|name
comma
id|name
comma
id|strlen
c_func
(paren
id|name
)paren
)paren
)paren
r_return
id|ino-&gt;attrs
op_plus
id|i
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* FIXME: Need better strategy to extend the MFT. */
DECL|function|ntfs_extend_mft
r_static
r_int
id|ntfs_extend_mft
c_func
(paren
id|ntfs_volume
op_star
id|vol
)paren
(brace
multiline_comment|/* Try to allocate at least 0.1% of the remaining disk space for&n;&t; * inodes. If the disk is almost full, make sure at least one inode is&n;&t; * requested. */
r_int
id|rcount
comma
id|error
comma
id|mft_rec_size
suffix:semicolon
id|__s64
id|size
suffix:semicolon
id|ntfs_attribute
op_star
id|mdata
comma
op_star
id|bmp
suffix:semicolon
id|ntfs_u8
op_star
id|buf
suffix:semicolon
id|ntfs_io
id|io
suffix:semicolon
id|mdata
op_assign
id|ntfs_find_attr
c_func
(paren
id|vol-&gt;mft_ino
comma
id|vol-&gt;at_data
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mdata
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|mft_rec_size
op_assign
id|vol-&gt;mft_record_size
suffix:semicolon
multiline_comment|/* First check whether there is uninitialized space. */
r_if
c_cond
(paren
id|mdata-&gt;allocated
OL
id|mdata-&gt;size
op_plus
id|mft_rec_size
)paren
(brace
id|size
op_assign
(paren
id|__s64
)paren
id|ntfs_get_free_cluster_count
c_func
(paren
id|vol-&gt;bitmap
)paren
op_lshift
id|vol-&gt;cluster_size_bits
op_rshift
l_int|10
suffix:semicolon
multiline_comment|/* On error, size will be negative. We can ignore this as we&n;&t;&t; * will fall back to the minimal size allocation below. (AIA) */
r_if
c_cond
(paren
id|size
OL
id|mdata-&gt;size
op_plus
id|mft_rec_size
)paren
id|size
op_assign
id|mdata-&gt;size
op_plus
id|mft_rec_size
suffix:semicolon
id|size
op_add_assign
id|mft_rec_size
op_minus
l_int|1
suffix:semicolon
id|size
op_and_assign
op_complement
(paren
id|__s64
)paren
(paren
id|mft_rec_size
op_minus
l_int|1
)paren
suffix:semicolon
id|error
op_assign
id|ntfs_extend_attr
c_func
(paren
id|vol-&gt;mft_ino
comma
id|mdata
comma
op_amp
id|size
comma
id|ALLOC_REQUIRE_SIZE
)paren
suffix:semicolon
multiline_comment|/* Try again, now we have the largest available fragment. */
r_if
c_cond
(paren
id|error
op_eq
op_minus
id|ENOSPC
)paren
(brace
multiline_comment|/* Round down to multiple of mft record size. */
id|size
op_and_assign
op_complement
(paren
id|__s64
)paren
(paren
id|mft_rec_size
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|size
)paren
r_return
op_minus
id|ENOSPC
suffix:semicolon
id|error
op_assign
id|ntfs_extend_attr
c_func
(paren
id|vol-&gt;mft_ino
comma
id|mdata
comma
op_amp
id|size
comma
id|ALLOC_REQUIRE_SIZE
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/* Even though we might have allocated more than needed, we initialize&n;&t; * only one record. */
id|mdata-&gt;size
op_add_assign
id|mft_rec_size
suffix:semicolon
multiline_comment|/* Now extend the bitmap if necessary. */
id|rcount
op_assign
id|mdata-&gt;size
op_rshift
id|vol-&gt;mft_record_size_bits
suffix:semicolon
id|bmp
op_assign
id|ntfs_find_attr
c_func
(paren
id|vol-&gt;mft_ino
comma
id|vol-&gt;at_bitmap
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bmp
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|bmp-&gt;size
op_star
l_int|8
OL
id|rcount
)paren
(brace
multiline_comment|/* Less bits than MFT records. */
id|ntfs_u8
id|buf
(braket
l_int|1
)braket
suffix:semicolon
multiline_comment|/* Extend bitmap by one byte. */
id|error
op_assign
id|ntfs_resize_attr
c_func
(paren
id|vol-&gt;mft_ino
comma
id|bmp
comma
id|bmp-&gt;size
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
multiline_comment|/* Write the single byte. */
id|buf
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|io.fn_put
op_assign
id|ntfs_put
suffix:semicolon
id|io.fn_get
op_assign
id|ntfs_get
suffix:semicolon
id|io.param
op_assign
id|buf
suffix:semicolon
id|io.size
op_assign
l_int|1
suffix:semicolon
id|error
op_assign
id|ntfs_write_attr
c_func
(paren
id|vol-&gt;mft_ino
comma
id|vol-&gt;at_bitmap
comma
l_int|0
comma
id|bmp-&gt;size
op_minus
l_int|1
comma
op_amp
id|io
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
r_if
c_cond
(paren
id|io.size
op_ne
l_int|1
)paren
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/* Now fill in the MFT header for the new block. */
id|buf
op_assign
id|ntfs_calloc
c_func
(paren
id|mft_rec_size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buf
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|ntfs_fill_mft_header
c_func
(paren
id|buf
comma
id|mft_rec_size
comma
id|vol-&gt;sector_size
comma
l_int|0
)paren
suffix:semicolon
id|error
op_assign
id|ntfs_insert_fixups
c_func
(paren
id|buf
comma
id|mft_rec_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|printk
c_func
(paren
id|KERN_ALERT
l_string|&quot;NTFS: ntfs_extend_mft() caught corrupt &quot;
l_string|&quot;mtf record ntfs record header. Refusing to &quot;
l_string|&quot;write corrupt data to disk. Unmount and run &quot;
l_string|&quot;chkdsk immediately!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|io.param
op_assign
id|buf
suffix:semicolon
id|io.size
op_assign
id|mft_rec_size
suffix:semicolon
id|io.fn_put
op_assign
id|ntfs_put
suffix:semicolon
id|io.fn_get
op_assign
id|ntfs_get
suffix:semicolon
id|error
op_assign
id|ntfs_write_attr
c_func
(paren
id|vol-&gt;mft_ino
comma
id|vol-&gt;at_data
comma
l_int|0
comma
(paren
id|__s64
)paren
(paren
id|rcount
op_minus
l_int|1
)paren
op_lshift
id|vol-&gt;mft_record_size_bits
comma
op_amp
id|io
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
r_if
c_cond
(paren
id|io.size
op_ne
id|mft_rec_size
)paren
r_return
op_minus
id|EIO
suffix:semicolon
id|error
op_assign
id|ntfs_update_inode
c_func
(paren
id|vol-&gt;mft_ino
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Insert all attributes from the record mftno of the MFT in the inode ino.&n; * If mftno is a base mft record we abort as soon as we find the attribute&n; * list, but only on the first pass. We will get called later when the attribute&n; * list attribute is being parsed so we need to distinguish the two cases.&n; * FIXME: We should be performing structural consistency checks. (AIA)&n; * Return 0 on success or -errno on error.&n; */
DECL|function|ntfs_insert_mft_attributes
r_static
r_int
id|ntfs_insert_mft_attributes
c_func
(paren
id|ntfs_inode
op_star
id|ino
comma
r_char
op_star
id|mft
comma
r_int
id|mftno
)paren
(brace
r_int
id|i
comma
id|error
comma
id|type
comma
id|len
comma
id|present
op_assign
l_int|0
suffix:semicolon
r_char
op_star
id|it
suffix:semicolon
multiline_comment|/* Check for duplicate extension record. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ino-&gt;record_count
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|ino-&gt;records
(braket
id|i
)braket
op_eq
id|mftno
)paren
(brace
r_if
c_cond
(paren
id|i
)paren
r_return
l_int|0
suffix:semicolon
id|present
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|present
)paren
(brace
multiline_comment|/* (re-)allocate space if necessary. */
r_if
c_cond
(paren
id|ino-&gt;record_count
op_mod
l_int|8
op_eq
l_int|0
)paren
(brace
r_int
op_star
r_new
suffix:semicolon
r_new
op_assign
id|ntfs_malloc
c_func
(paren
(paren
id|ino-&gt;record_count
op_plus
l_int|8
)paren
op_star
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
r_new
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
id|ino-&gt;records
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ino-&gt;record_count
suffix:semicolon
id|i
op_increment
)paren
r_new
(braket
id|i
)braket
op_assign
id|ino-&gt;records
(braket
id|i
)braket
suffix:semicolon
id|ntfs_free
c_func
(paren
id|ino-&gt;records
)paren
suffix:semicolon
)brace
id|ino-&gt;records
op_assign
r_new
suffix:semicolon
)brace
id|ino-&gt;records
(braket
id|ino-&gt;record_count
)braket
op_assign
id|mftno
suffix:semicolon
id|ino-&gt;record_count
op_increment
suffix:semicolon
)brace
id|it
op_assign
id|mft
op_plus
id|NTFS_GETU16
c_func
(paren
id|mft
op_plus
l_int|0x14
)paren
suffix:semicolon
multiline_comment|/* mft-&gt;attrs_offset */
r_do
(brace
id|type
op_assign
id|NTFS_GETU32
c_func
(paren
id|it
)paren
suffix:semicolon
id|len
op_assign
id|NTFS_GETU32
c_func
(paren
id|it
op_plus
l_int|4
)paren
suffix:semicolon
r_if
c_cond
(paren
id|type
op_ne
op_minus
l_int|1
)paren
(brace
id|error
op_assign
id|ntfs_insert_attribute
c_func
(paren
id|ino
comma
id|it
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/* If we have just processed the attribute list and this is&n;&t;&t; * the first time we are parsing this (base) mft record then we&n;&t;&t; * are done so that the attribute list gets parsed before the&n;&t;&t; * entries in the base mft record. Otherwise we run into&n;&t;&t; * problems with encountering attributes out of order and when&n;&t;&t; * this happens with different attribute extents we die. )-:&n;&t;&t; * This way we are ok as the attribute list is always sorted&n;&t;&t; * fully and correctly. (-: */
r_if
c_cond
(paren
id|type
op_eq
l_int|0x20
op_logical_and
op_logical_neg
id|present
)paren
r_return
l_int|0
suffix:semicolon
id|it
op_add_assign
id|len
suffix:semicolon
)brace
r_while
c_loop
(paren
id|type
op_ne
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Attribute listing ends with type -1. */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Insert a single specific attribute from the record mftno of the MFT in the&n; * inode ino. We disregard the attribute list assuming we have already parsed&n; * it.&n; * FIXME: We should be performing structural consistency checks. (AIA)&n; * Return 0 on success or -errno on error.&n; */
DECL|function|ntfs_insert_mft_attribute
r_static
r_int
id|ntfs_insert_mft_attribute
c_func
(paren
id|ntfs_inode
op_star
id|ino
comma
r_int
id|mftno
comma
id|ntfs_u8
op_star
id|attr
)paren
(brace
r_int
id|i
comma
id|error
comma
id|present
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Check for duplicate extension record. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ino-&gt;record_count
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|ino-&gt;records
(braket
id|i
)braket
op_eq
id|mftno
)paren
(brace
id|present
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|present
)paren
(brace
multiline_comment|/* (re-)allocate space if necessary. */
r_if
c_cond
(paren
id|ino-&gt;record_count
op_mod
l_int|8
op_eq
l_int|0
)paren
(brace
r_int
op_star
r_new
suffix:semicolon
r_new
op_assign
id|ntfs_malloc
c_func
(paren
(paren
id|ino-&gt;record_count
op_plus
l_int|8
)paren
op_star
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
r_new
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
id|ino-&gt;records
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ino-&gt;record_count
suffix:semicolon
id|i
op_increment
)paren
r_new
(braket
id|i
)braket
op_assign
id|ino-&gt;records
(braket
id|i
)braket
suffix:semicolon
id|ntfs_free
c_func
(paren
id|ino-&gt;records
)paren
suffix:semicolon
)brace
id|ino-&gt;records
op_assign
r_new
suffix:semicolon
)brace
id|ino-&gt;records
(braket
id|ino-&gt;record_count
)braket
op_assign
id|mftno
suffix:semicolon
id|ino-&gt;record_count
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|NTFS_GETU32
c_func
(paren
id|attr
)paren
op_eq
op_minus
l_int|1
)paren
(brace
id|ntfs_debug
c_func
(paren
id|DEBUG_FILE3
comma
l_string|&quot;ntfs_insert_mft_attribute: attribute &quot;
l_string|&quot;type is -1.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|error
op_assign
id|ntfs_insert_attribute
c_func
(paren
id|ino
comma
id|attr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Read and insert all the attributes of an &squot;attribute list&squot; attribute.&n; * Return the number of remaining bytes in *plen. */
DECL|function|parse_attributes
r_static
r_int
id|parse_attributes
c_func
(paren
id|ntfs_inode
op_star
id|ino
comma
id|ntfs_u8
op_star
id|alist
comma
r_int
op_star
id|plen
)paren
(brace
id|ntfs_u8
op_star
id|mft
comma
op_star
id|attr
suffix:semicolon
r_int
id|mftno
comma
id|l
comma
id|error
suffix:semicolon
r_int
id|last_mft
op_assign
op_minus
l_int|1
suffix:semicolon
r_int
id|len
op_assign
op_star
id|plen
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ino-&gt;attr
)paren
(brace
id|ntfs_error
c_func
(paren
l_string|&quot;parse_attributes: called on inode 0x%x without a &quot;
l_string|&quot;loaded base mft record.&bslash;n&quot;
comma
id|ino-&gt;i_number
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|mft
op_assign
id|ntfs_malloc
c_func
(paren
id|ino-&gt;vol-&gt;mft_record_size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mft
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_while
c_loop
(paren
id|len
OG
l_int|8
)paren
(brace
id|l
op_assign
id|NTFS_GETU16
c_func
(paren
id|alist
op_plus
l_int|4
)paren
suffix:semicolon
r_if
c_cond
(paren
id|l
OG
id|len
)paren
r_break
suffix:semicolon
multiline_comment|/* Process an attribute description. */
id|mftno
op_assign
id|NTFS_GETU32
c_func
(paren
id|alist
op_plus
l_int|0x10
)paren
suffix:semicolon
multiline_comment|/* FIXME: The mft reference (alist + 0x10) is __s64.&n;&t;&t;&t;* - Not a problem unless we encounter a huge partition.&n;&t;&t;&t;* - Should be consistency checking the sequence numbers&n;&t;&t;&t;*   though! This should maybe happen in &n;&t;&t;&t;*   ntfs_read_mft_record() itself and a hotfix could&n;&t;&t;&t;*   then occur there or the user notified to run&n;&t;&t;&t;*   ntfsck. (AIA) */
r_if
c_cond
(paren
id|mftno
op_ne
id|ino-&gt;i_number
op_logical_and
id|mftno
op_ne
id|last_mft
)paren
(brace
id|last_mft
op_assign
id|mftno
suffix:semicolon
id|error
op_assign
id|ntfs_read_mft_record
c_func
(paren
id|ino-&gt;vol
comma
id|mftno
comma
id|mft
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|ntfs_debug
c_func
(paren
id|DEBUG_FILE3
comma
l_string|&quot;parse_attributes: &quot;
l_string|&quot;ntfs_read_mft_record(mftno = 0x%x) &quot;
l_string|&quot;failed&bslash;n&quot;
comma
id|mftno
)paren
suffix:semicolon
id|ntfs_free
c_func
(paren
id|mft
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
)brace
id|attr
op_assign
id|ntfs_find_attr_in_mft_rec
c_func
(paren
id|ino-&gt;vol
comma
multiline_comment|/* ntfs volume */
id|mftno
op_eq
id|ino-&gt;i_number
ques
c_cond
multiline_comment|/* mft record is: */
id|ino-&gt;attr
suffix:colon
multiline_comment|/*   base record */
id|mft
comma
multiline_comment|/*   extension record */
id|NTFS_GETU32
c_func
(paren
id|alist
op_plus
l_int|0
)paren
comma
multiline_comment|/* type */
(paren
m_wchar_t
op_star
)paren
(paren
id|alist
op_plus
id|alist
(braket
l_int|7
)braket
)paren
comma
multiline_comment|/* name */
id|alist
(braket
l_int|6
)braket
comma
multiline_comment|/* name length */
l_int|1
comma
multiline_comment|/* ignore case */
id|NTFS_GETU16
c_func
(paren
id|alist
op_plus
l_int|24
)paren
multiline_comment|/* instance number */
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|attr
)paren
(brace
id|ntfs_error
c_func
(paren
l_string|&quot;parse_attributes: mft records 0x%x and/or &quot;
l_string|&quot;0x%x corrupt!&bslash;n&quot;
comma
id|ino-&gt;i_number
comma
id|mftno
)paren
suffix:semicolon
id|ntfs_free
c_func
(paren
id|mft
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* FIXME: Better error code? (AIA) */
)brace
id|error
op_assign
id|ntfs_insert_mft_attribute
c_func
(paren
id|ino
comma
id|mftno
comma
id|attr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|ntfs_debug
c_func
(paren
id|DEBUG_FILE3
comma
l_string|&quot;parse_attributes: &quot;
l_string|&quot;ntfs_insert_mft_attribute(mftno 0x%x, &quot;
l_string|&quot;attribute type 0x%x) failed&bslash;n&quot;
comma
id|mftno
comma
id|NTFS_GETU32
c_func
(paren
id|alist
op_plus
l_int|0
)paren
)paren
suffix:semicolon
id|ntfs_free
c_func
(paren
id|mft
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
id|len
op_sub_assign
id|l
suffix:semicolon
id|alist
op_add_assign
id|l
suffix:semicolon
)brace
id|ntfs_free
c_func
(paren
id|mft
)paren
suffix:semicolon
op_star
id|plen
op_assign
id|len
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ntfs_load_attributes
r_static
r_void
id|ntfs_load_attributes
c_func
(paren
id|ntfs_inode
op_star
id|ino
)paren
(brace
id|ntfs_attribute
op_star
id|alist
suffix:semicolon
r_int
id|datasize
suffix:semicolon
r_int
id|offset
comma
id|len
comma
id|delta
suffix:semicolon
r_char
op_star
id|buf
suffix:semicolon
id|ntfs_volume
op_star
id|vol
op_assign
id|ino-&gt;vol
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_FILE2
comma
l_string|&quot;load_attributes %x 1&bslash;n&quot;
comma
id|ino-&gt;i_number
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ntfs_insert_mft_attributes
c_func
(paren
id|ino
comma
id|ino-&gt;attr
comma
id|ino-&gt;i_number
)paren
)paren
r_return
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_FILE2
comma
l_string|&quot;load_attributes %x 2&bslash;n&quot;
comma
id|ino-&gt;i_number
)paren
suffix:semicolon
id|alist
op_assign
id|ntfs_find_attr
c_func
(paren
id|ino
comma
id|vol-&gt;at_attribute_list
comma
l_int|0
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_FILE2
comma
l_string|&quot;load_attributes %x 3&bslash;n&quot;
comma
id|ino-&gt;i_number
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|alist
)paren
r_return
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_FILE2
comma
l_string|&quot;load_attributes %x 4&bslash;n&quot;
comma
id|ino-&gt;i_number
)paren
suffix:semicolon
id|datasize
op_assign
id|alist-&gt;size
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_FILE2
comma
l_string|&quot;load_attributes %x: alist-&gt;size = 0x%x&bslash;n&quot;
comma
id|ino-&gt;i_number
comma
id|alist-&gt;size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|alist-&gt;resident
)paren
(brace
id|parse_attributes
c_func
(paren
id|ino
comma
id|alist-&gt;d.data
comma
op_amp
id|datasize
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|ntfs_debug
c_func
(paren
id|DEBUG_FILE2
comma
l_string|&quot;load_attributes %x 5&bslash;n&quot;
comma
id|ino-&gt;i_number
)paren
suffix:semicolon
id|buf
op_assign
id|ntfs_malloc
c_func
(paren
l_int|1024
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buf
)paren
multiline_comment|/* FIXME: Should be passing error code to caller. (AIA) */
r_return
suffix:semicolon
id|delta
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|offset
op_assign
l_int|0
suffix:semicolon
id|datasize
suffix:semicolon
id|datasize
op_sub_assign
id|len
comma
id|offset
op_add_assign
id|len
)paren
(brace
id|ntfs_io
id|io
suffix:semicolon
id|io.fn_put
op_assign
id|ntfs_put
suffix:semicolon
id|io.fn_get
op_assign
l_int|0
suffix:semicolon
id|io.param
op_assign
id|buf
op_plus
id|delta
suffix:semicolon
id|len
op_assign
l_int|1024
op_minus
id|delta
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|datasize
)paren
id|len
op_assign
id|datasize
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_FILE2
comma
l_string|&quot;load_attributes %x: len = %i&bslash;n&quot;
comma
id|ino-&gt;i_number
comma
id|len
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_FILE2
comma
l_string|&quot;load_attributes %x: delta = %i&bslash;n&quot;
comma
id|ino-&gt;i_number
comma
id|delta
)paren
suffix:semicolon
id|io.size
op_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
id|ntfs_read_attr
c_func
(paren
id|ino
comma
id|vol-&gt;at_attribute_list
comma
l_int|0
comma
id|offset
comma
op_amp
id|io
)paren
)paren
id|ntfs_error
c_func
(paren
l_string|&quot;error in load_attributes&bslash;n&quot;
)paren
suffix:semicolon
id|delta
op_add_assign
id|len
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_FILE2
comma
l_string|&quot;load_attributes %x: after += len, &quot;
l_string|&quot;delta = %i&bslash;n&quot;
comma
id|ino-&gt;i_number
comma
id|delta
)paren
suffix:semicolon
id|parse_attributes
c_func
(paren
id|ino
comma
id|buf
comma
op_amp
id|delta
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_FILE2
comma
l_string|&quot;load_attributes %x: after parse_attr, &quot;
l_string|&quot;delta = %i&bslash;n&quot;
comma
id|ino-&gt;i_number
comma
id|delta
)paren
suffix:semicolon
r_if
c_cond
(paren
id|delta
)paren
multiline_comment|/* Move remaining bytes to buffer start. */
id|ntfs_memmove
c_func
(paren
id|buf
comma
id|buf
op_plus
id|len
op_minus
id|delta
comma
id|delta
)paren
suffix:semicolon
)brace
id|ntfs_debug
c_func
(paren
id|DEBUG_FILE2
comma
l_string|&quot;load_attributes %x 6&bslash;n&quot;
comma
id|ino-&gt;i_number
)paren
suffix:semicolon
id|ntfs_free
c_func
(paren
id|buf
)paren
suffix:semicolon
)brace
DECL|function|ntfs_init_inode
r_int
id|ntfs_init_inode
c_func
(paren
id|ntfs_inode
op_star
id|ino
comma
id|ntfs_volume
op_star
id|vol
comma
r_int
id|inum
)paren
(brace
r_char
op_star
id|buf
suffix:semicolon
r_int
id|error
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_FILE1
comma
l_string|&quot;Initializing inode %x&bslash;n&quot;
comma
id|inum
)paren
suffix:semicolon
id|ino-&gt;i_number
op_assign
id|inum
suffix:semicolon
id|ino-&gt;vol
op_assign
id|vol
suffix:semicolon
id|ino-&gt;attr
op_assign
id|buf
op_assign
id|ntfs_malloc
c_func
(paren
id|vol-&gt;mft_record_size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buf
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|error
op_assign
id|ntfs_read_mft_record
c_func
(paren
id|vol
comma
id|inum
comma
id|ino-&gt;attr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
l_string|&quot;Init inode: %x failed&bslash;n&quot;
comma
id|inum
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
id|ntfs_debug
c_func
(paren
id|DEBUG_FILE2
comma
l_string|&quot;Init inode: got mft %x&bslash;n&quot;
comma
id|inum
)paren
suffix:semicolon
id|ino-&gt;sequence_number
op_assign
id|NTFS_GETU16
c_func
(paren
id|buf
op_plus
l_int|0x10
)paren
suffix:semicolon
id|ino-&gt;attr_count
op_assign
l_int|0
suffix:semicolon
id|ino-&gt;record_count
op_assign
l_int|0
suffix:semicolon
id|ino-&gt;records
op_assign
l_int|0
suffix:semicolon
id|ino-&gt;attrs
op_assign
l_int|0
suffix:semicolon
id|ntfs_load_attributes
c_func
(paren
id|ino
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_FILE2
comma
l_string|&quot;Init inode: done %x&bslash;n&quot;
comma
id|inum
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ntfs_clear_inode
r_void
id|ntfs_clear_inode
c_func
(paren
id|ntfs_inode
op_star
id|ino
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ino-&gt;attr
)paren
(brace
id|ntfs_error
c_func
(paren
l_string|&quot;ntfs_clear_inode: double free&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|ntfs_free
c_func
(paren
id|ino-&gt;attr
)paren
suffix:semicolon
id|ino-&gt;attr
op_assign
l_int|0
suffix:semicolon
id|ntfs_free
c_func
(paren
id|ino-&gt;records
)paren
suffix:semicolon
id|ino-&gt;records
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ino-&gt;attr_count
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|ino-&gt;attrs
(braket
id|i
)braket
dot
id|name
)paren
id|ntfs_free
c_func
(paren
id|ino-&gt;attrs
(braket
id|i
)braket
dot
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ino-&gt;attrs
(braket
id|i
)braket
dot
id|resident
)paren
(brace
r_if
c_cond
(paren
id|ino-&gt;attrs
(braket
id|i
)braket
dot
id|d.data
)paren
id|ntfs_free
c_func
(paren
id|ino-&gt;attrs
(braket
id|i
)braket
dot
id|d.data
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|ino-&gt;attrs
(braket
id|i
)braket
dot
id|d.r.runlist
)paren
id|ntfs_vfree
c_func
(paren
id|ino-&gt;attrs
(braket
id|i
)braket
dot
id|d.r.runlist
)paren
suffix:semicolon
)brace
)brace
id|ntfs_free
c_func
(paren
id|ino-&gt;attrs
)paren
suffix:semicolon
id|ino-&gt;attrs
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Check and fixup a MFT record. */
DECL|function|ntfs_check_mft_record
r_int
id|ntfs_check_mft_record
c_func
(paren
id|ntfs_volume
op_star
id|vol
comma
r_char
op_star
id|record
)paren
(brace
r_return
id|ntfs_fixup_record
c_func
(paren
id|record
comma
l_string|&quot;FILE&quot;
comma
id|vol-&gt;mft_record_size
)paren
suffix:semicolon
)brace
multiline_comment|/* Return (in result) the value indicating the next available attribute &n; * chunk number. Works for inodes w/o extension records only. */
DECL|function|ntfs_allocate_attr_number
r_int
id|ntfs_allocate_attr_number
c_func
(paren
id|ntfs_inode
op_star
id|ino
comma
r_int
op_star
id|result
)paren
(brace
r_if
c_cond
(paren
id|ino-&gt;record_count
op_ne
l_int|1
)paren
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
op_star
id|result
op_assign
id|NTFS_GETU16
c_func
(paren
id|ino-&gt;attr
op_plus
l_int|0x28
)paren
suffix:semicolon
id|NTFS_PUTU16
c_func
(paren
id|ino-&gt;attr
op_plus
l_int|0x28
comma
(paren
op_star
id|result
)paren
op_plus
l_int|1
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Find the location of an attribute in the inode. A name of NULL indicates&n; * unnamed attributes. Return pointer to attribute or NULL if not found. */
DECL|function|ntfs_get_attr
r_char
op_star
id|ntfs_get_attr
c_func
(paren
id|ntfs_inode
op_star
id|ino
comma
r_int
id|attr
comma
r_char
op_star
id|name
)paren
(brace
multiline_comment|/* Location of first attribute. */
r_char
op_star
id|it
op_assign
id|ino-&gt;attr
op_plus
id|NTFS_GETU16
c_func
(paren
id|ino-&gt;attr
op_plus
l_int|0x14
)paren
suffix:semicolon
r_int
id|type
suffix:semicolon
r_int
id|len
suffix:semicolon
multiline_comment|/* Only check for magic DWORD here, fixup should have happened before.*/
r_if
c_cond
(paren
op_logical_neg
id|IS_MFT_RECORD
c_func
(paren
id|ino-&gt;attr
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_do
(brace
id|type
op_assign
id|NTFS_GETU32
c_func
(paren
id|it
)paren
suffix:semicolon
id|len
op_assign
id|NTFS_GETU16
c_func
(paren
id|it
op_plus
l_int|4
)paren
suffix:semicolon
multiline_comment|/* We found the attribute type. Is the name correct, too? */
r_if
c_cond
(paren
id|type
op_eq
id|attr
)paren
(brace
r_int
id|namelen
op_assign
id|NTFS_GETU8
c_func
(paren
id|it
op_plus
l_int|9
)paren
suffix:semicolon
r_char
op_star
id|name_it
comma
op_star
id|n
op_assign
id|name
suffix:semicolon
multiline_comment|/* Match given name and attribute name if present.&n;&t;&t;&t;   Make sure attribute name is Unicode. */
r_if
c_cond
(paren
op_logical_neg
id|name
)paren
(brace
r_goto
id|check_namelen
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|namelen
)paren
(brace
r_for
c_loop
(paren
id|name_it
op_assign
id|it
op_plus
id|NTFS_GETU16
c_func
(paren
id|it
op_plus
l_int|10
)paren
suffix:semicolon
id|namelen
suffix:semicolon
id|n
op_increment
comma
id|name_it
op_add_assign
l_int|2
comma
id|namelen
op_decrement
)paren
r_if
c_cond
(paren
op_star
id|name_it
op_ne
op_star
id|n
op_logical_or
id|name_it
(braket
l_int|1
)braket
)paren
r_break
suffix:semicolon
id|check_namelen
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|namelen
)paren
r_break
suffix:semicolon
)brace
)brace
id|it
op_add_assign
id|len
suffix:semicolon
)brace
r_while
c_loop
(paren
id|type
op_ne
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* List of attributes ends with type -1. */
r_if
c_cond
(paren
id|type
op_eq
op_minus
l_int|1
)paren
r_return
l_int|0
suffix:semicolon
r_return
id|it
suffix:semicolon
)brace
DECL|function|ntfs_get_attr_size
id|__s64
id|ntfs_get_attr_size
c_func
(paren
id|ntfs_inode
op_star
id|ino
comma
r_int
id|type
comma
r_char
op_star
id|name
)paren
(brace
id|ntfs_attribute
op_star
id|attr
op_assign
id|ntfs_find_attr
c_func
(paren
id|ino
comma
id|type
comma
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|attr
)paren
r_return
l_int|0
suffix:semicolon
r_return
id|attr-&gt;size
suffix:semicolon
)brace
DECL|function|ntfs_attr_is_resident
r_int
id|ntfs_attr_is_resident
c_func
(paren
id|ntfs_inode
op_star
id|ino
comma
r_int
id|type
comma
r_char
op_star
id|name
)paren
(brace
id|ntfs_attribute
op_star
id|attr
op_assign
id|ntfs_find_attr
c_func
(paren
id|ino
comma
id|type
comma
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|attr
)paren
r_return
l_int|0
suffix:semicolon
r_return
id|attr-&gt;resident
suffix:semicolon
)brace
multiline_comment|/*&n; * A run is coded as a type indicator, an unsigned length, and a signed cluster&n; * offset.&n; * . To save space, length and offset are fields of variable length. The low&n; *   nibble of the type indicates the width of the length :), the high nibble&n; *   the width of the offset.&n; * . The first offset is relative to cluster 0, later offsets are relative to&n; *   the previous cluster.&n; *&n; * This function decodes a run. Length is an output parameter, data and cluster&n; * are in/out parameters.&n; */
DECL|function|ntfs_decompress_run
r_int
id|ntfs_decompress_run
c_func
(paren
r_int
r_char
op_star
op_star
id|data
comma
r_int
op_star
id|length
comma
id|ntfs_cluster_t
op_star
id|cluster
comma
r_int
op_star
id|ctype
)paren
(brace
r_int
r_char
id|type
op_assign
op_star
(paren
op_star
id|data
)paren
op_increment
suffix:semicolon
op_star
id|ctype
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|type
op_amp
l_int|0xF
)paren
(brace
r_case
l_int|1
suffix:colon
op_star
id|length
op_assign
id|NTFS_GETS8
c_func
(paren
op_star
id|data
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
op_star
id|length
op_assign
id|NTFS_GETS16
c_func
(paren
op_star
id|data
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
op_star
id|length
op_assign
id|NTFS_GETS24
c_func
(paren
op_star
id|data
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
op_star
id|length
op_assign
id|NTFS_GETS32
c_func
(paren
op_star
id|data
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* Note: cases 5-8 are probably pointless to code, since how&n;&t;&t; * many runs &gt; 4GB of length are there? At the most, cases 5&n;&t;&t; * and 6 are probably necessary, and would also require making&n;&t;&t; * length 64-bit throughout. */
r_default
suffix:colon
id|ntfs_error
c_func
(paren
l_string|&quot;Can&squot;t decode run type field %x&bslash;n&quot;
comma
id|type
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
singleline_comment|//&t;ntfs_debug(DEBUG_FILE3, &quot;ntfs_decompress_run: length = 0x%x&bslash;n&quot;,*length);
r_if
c_cond
(paren
op_star
id|length
OL
l_int|0
)paren
(brace
id|ntfs_error
c_func
(paren
l_string|&quot;Negative run length decoded&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
op_star
id|data
op_add_assign
(paren
id|type
op_amp
l_int|0xF
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|type
op_amp
l_int|0xF0
)paren
(brace
r_case
l_int|0
suffix:colon
op_star
id|ctype
op_assign
l_int|2
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x10
suffix:colon
op_star
id|cluster
op_add_assign
id|NTFS_GETS8
c_func
(paren
op_star
id|data
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x20
suffix:colon
op_star
id|cluster
op_add_assign
id|NTFS_GETS16
c_func
(paren
op_star
id|data
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x30
suffix:colon
op_star
id|cluster
op_add_assign
id|NTFS_GETS24
c_func
(paren
op_star
id|data
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x40
suffix:colon
op_star
id|cluster
op_add_assign
id|NTFS_GETS32
c_func
(paren
op_star
id|data
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#if 0 /* Keep for future, in case ntfs_cluster_t ever becomes 64bit. */
r_case
l_int|0x50
suffix:colon
op_star
id|cluster
op_add_assign
id|NTFS_GETS40
c_func
(paren
op_star
id|data
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x60
suffix:colon
op_star
id|cluster
op_add_assign
id|NTFS_GETS48
c_func
(paren
op_star
id|data
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x70
suffix:colon
op_star
id|cluster
op_add_assign
id|NTFS_GETS56
c_func
(paren
op_star
id|data
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x80
suffix:colon
op_star
id|cluster
op_add_assign
id|NTFS_GETS64
c_func
(paren
op_star
id|data
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
r_default
suffix:colon
id|ntfs_error
c_func
(paren
l_string|&quot;Can&squot;t decode run type field %x&bslash;n&quot;
comma
id|type
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
singleline_comment|//&t;ntfs_debug(DEBUG_FILE3, &quot;ntfs_decompress_run: cluster = 0x%x&bslash;n&quot;,
singleline_comment|//&t;&t;&t;&t;&t;&t;&t;&t;*cluster);
op_star
id|data
op_add_assign
(paren
id|type
op_rshift
l_int|4
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * FIXME: ntfs_readwrite_attr() has the effect of writing @dest to @offset of&n; * the attribute value of the attribute @attr in the in memory inode @ino.&n; * If the attribute value of @attr is non-resident the value&squot;s contents at&n; * @offset are actually written to disk (from @dest). The on disk mft record&n; * describing the non-resident attribute value is not updated!&n; * If the attribute value is resident then the value is written only in&n; * memory. The on disk mft record containing the value is not written to disk.&n; * A possible fix would be to call ntfs_update_inode() before returning. (AIA)&n; */
multiline_comment|/* Reads l bytes of the attribute (attr, name) of ino starting at offset on&n; * vol into buf. Returns the number of bytes read in the ntfs_io struct.&n; * Returns 0 on success, errno on failure */
DECL|function|ntfs_readwrite_attr
r_int
id|ntfs_readwrite_attr
c_func
(paren
id|ntfs_inode
op_star
id|ino
comma
id|ntfs_attribute
op_star
id|attr
comma
id|__s64
id|offset
comma
id|ntfs_io
op_star
id|dest
)paren
(brace
r_int
id|rnum
suffix:semicolon
id|ntfs_cluster_t
id|cluster
comma
id|s_cluster
comma
id|vcn
comma
id|len
suffix:semicolon
id|__s64
id|l
comma
id|chunk
comma
id|copied
suffix:semicolon
r_int
id|s_vcn
suffix:semicolon
r_int
id|error
comma
id|clustersizebits
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_FILE3
comma
l_string|&quot;ntfs_readwrite_attr 0: inode = 0x%x, attr-&gt;&quot;
l_string|&quot;type = 0x%x, offset = 0x%Lx, dest-&gt;size = 0x%x&bslash;n&quot;
comma
id|ino-&gt;i_number
comma
id|attr-&gt;type
comma
id|offset
comma
id|dest-&gt;size
)paren
suffix:semicolon
id|l
op_assign
id|dest-&gt;size
suffix:semicolon
r_if
c_cond
(paren
id|l
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|dest-&gt;do_read
)paren
(brace
multiline_comment|/* If read _starts_ beyond end of stream, return nothing. */
r_if
c_cond
(paren
id|offset
op_ge
id|attr-&gt;size
)paren
(brace
id|dest-&gt;size
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* If read _extends_ beyond end of stream, return as much&n;&t;&t; * initialised data as we have. */
r_if
c_cond
(paren
id|offset
op_plus
id|l
op_ge
id|attr-&gt;size
)paren
id|l
op_assign
id|dest-&gt;size
op_assign
id|attr-&gt;size
op_minus
id|offset
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Fixed by CSA: If writing beyond end, extend attribute. */
multiline_comment|/* If write extends beyond _allocated_ size, extend attrib. */
r_if
c_cond
(paren
id|offset
op_plus
id|l
OG
id|attr-&gt;allocated
)paren
(brace
id|error
op_assign
id|ntfs_resize_attr
c_func
(paren
id|ino
comma
id|attr
comma
id|offset
op_plus
id|l
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/* The amount of initialised data has increased: update. */
multiline_comment|/* FIXME: Shouldn&squot;t we zero-out the section between the old&n;&t;&t; * &t;  initialised length and the write start? */
r_if
c_cond
(paren
id|offset
op_plus
id|l
OG
id|attr-&gt;initialized
)paren
(brace
id|attr-&gt;initialized
op_assign
id|offset
op_plus
id|l
suffix:semicolon
id|attr-&gt;size
op_assign
id|offset
op_plus
id|l
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|attr-&gt;resident
)paren
(brace
r_if
c_cond
(paren
id|dest-&gt;do_read
)paren
id|dest
op_member_access_from_pointer
id|fn_put
c_func
(paren
id|dest
comma
(paren
id|ntfs_u8
op_star
)paren
id|attr-&gt;d.data
op_plus
id|offset
comma
id|l
)paren
suffix:semicolon
r_else
id|dest
op_member_access_from_pointer
id|fn_get
c_func
(paren
(paren
id|ntfs_u8
op_star
)paren
id|attr-&gt;d.data
op_plus
id|offset
comma
id|dest
comma
id|l
)paren
suffix:semicolon
id|dest-&gt;size
op_assign
id|l
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dest-&gt;do_read
)paren
(brace
multiline_comment|/* Read uninitialized data. */
r_if
c_cond
(paren
id|offset
op_ge
id|attr-&gt;initialized
)paren
r_return
id|ntfs_read_zero
c_func
(paren
id|dest
comma
id|l
)paren
suffix:semicolon
r_if
c_cond
(paren
id|offset
op_plus
id|l
OG
id|attr-&gt;initialized
)paren
(brace
id|dest-&gt;size
op_assign
id|chunk
op_assign
id|offset
op_plus
id|l
op_minus
id|attr-&gt;initialized
suffix:semicolon
id|error
op_assign
id|ntfs_readwrite_attr
c_func
(paren
id|ino
comma
id|attr
comma
id|offset
comma
id|dest
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
r_return
id|ntfs_read_zero
c_func
(paren
id|dest
comma
id|l
op_minus
id|chunk
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|attr-&gt;flags
op_amp
id|ATTR_IS_COMPRESSED
)paren
r_return
id|ntfs_read_compressed
c_func
(paren
id|ino
comma
id|attr
comma
id|offset
comma
id|dest
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|attr-&gt;flags
op_amp
id|ATTR_IS_COMPRESSED
)paren
r_return
id|ntfs_write_compressed
c_func
(paren
id|ino
comma
id|attr
comma
id|offset
comma
id|dest
)paren
suffix:semicolon
)brace
id|vcn
op_assign
l_int|0
suffix:semicolon
id|clustersizebits
op_assign
id|ino-&gt;vol-&gt;cluster_size_bits
suffix:semicolon
id|s_vcn
op_assign
id|offset
op_rshift
id|clustersizebits
suffix:semicolon
r_for
c_loop
(paren
id|rnum
op_assign
l_int|0
suffix:semicolon
id|rnum
OL
id|attr-&gt;d.r.len
op_logical_and
id|vcn
op_plus
id|attr-&gt;d.r.runlist
(braket
id|rnum
)braket
dot
id|len
op_le
id|s_vcn
suffix:semicolon
id|rnum
op_increment
)paren
(brace
id|vcn
op_add_assign
id|attr-&gt;d.r.runlist
(braket
id|rnum
)braket
dot
id|len
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rnum
op_eq
id|attr-&gt;d.r.len
)paren
(brace
id|ntfs_debug
c_func
(paren
id|DEBUG_FILE3
comma
l_string|&quot;ntfs_readwrite_attr: EOPNOTSUPP: &quot;
l_string|&quot;inode = 0x%x, rnum = %i, offset = 0x%Lx, vcn = , 0x%x&quot;
l_string|&quot;s_vcn = 0x%x&bslash;n&quot;
comma
id|ino-&gt;i_number
comma
id|rnum
comma
id|offset
comma
id|vcn
comma
id|s_vcn
)paren
suffix:semicolon
multiline_comment|/*FIXME: Should extend run list. */
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
id|copied
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|l
)paren
(brace
id|s_vcn
op_assign
id|offset
op_rshift
id|clustersizebits
suffix:semicolon
id|cluster
op_assign
id|attr-&gt;d.r.runlist
(braket
id|rnum
)braket
dot
id|cluster
suffix:semicolon
id|len
op_assign
id|attr-&gt;d.r.runlist
(braket
id|rnum
)braket
dot
id|len
suffix:semicolon
id|s_cluster
op_assign
id|cluster
op_plus
id|s_vcn
op_minus
id|vcn
suffix:semicolon
id|chunk
op_assign
(paren
(paren
id|__s64
)paren
(paren
id|vcn
op_plus
id|len
)paren
op_lshift
id|clustersizebits
)paren
op_minus
id|offset
suffix:semicolon
r_if
c_cond
(paren
id|chunk
OG
id|l
)paren
id|chunk
op_assign
id|l
suffix:semicolon
id|dest-&gt;size
op_assign
id|chunk
suffix:semicolon
id|error
op_assign
id|ntfs_getput_clusters
c_func
(paren
id|ino-&gt;vol
comma
id|s_cluster
comma
id|offset
op_minus
(paren
(paren
id|__s64
)paren
id|s_vcn
op_lshift
id|clustersizebits
)paren
comma
id|dest
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|ntfs_error
c_func
(paren
l_string|&quot;Read/write error&bslash;n&quot;
)paren
suffix:semicolon
id|dest-&gt;size
op_assign
id|copied
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
id|l
op_sub_assign
id|chunk
suffix:semicolon
id|copied
op_add_assign
id|chunk
suffix:semicolon
id|offset
op_add_assign
id|chunk
suffix:semicolon
r_if
c_cond
(paren
id|l
op_logical_and
id|offset
op_ge
(paren
(paren
id|__s64
)paren
(paren
id|vcn
op_plus
id|len
)paren
op_lshift
id|clustersizebits
)paren
)paren
(brace
id|rnum
op_increment
suffix:semicolon
id|vcn
op_add_assign
id|len
suffix:semicolon
id|cluster
op_assign
id|attr-&gt;d.r.runlist
(braket
id|rnum
)braket
dot
id|cluster
suffix:semicolon
id|len
op_assign
id|attr-&gt;d.r.runlist
(braket
id|rnum
)braket
dot
id|len
suffix:semicolon
)brace
)brace
id|dest-&gt;size
op_assign
id|copied
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ntfs_read_attr
r_int
id|ntfs_read_attr
c_func
(paren
id|ntfs_inode
op_star
id|ino
comma
r_int
id|type
comma
r_char
op_star
id|name
comma
id|__s64
id|offset
comma
id|ntfs_io
op_star
id|buf
)paren
(brace
id|ntfs_attribute
op_star
id|attr
suffix:semicolon
id|buf-&gt;do_read
op_assign
l_int|1
suffix:semicolon
id|attr
op_assign
id|ntfs_find_attr
c_func
(paren
id|ino
comma
id|type
comma
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|attr
)paren
(brace
id|ntfs_debug
c_func
(paren
id|DEBUG_FILE3
comma
l_string|&quot;ntfs_read_attr: attr 0x%x not found &quot;
l_string|&quot;in inode 0x%x&bslash;n&quot;
comma
id|type
comma
id|ino-&gt;i_number
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
id|ntfs_readwrite_attr
c_func
(paren
id|ino
comma
id|attr
comma
id|offset
comma
id|buf
)paren
suffix:semicolon
)brace
DECL|function|ntfs_write_attr
r_int
id|ntfs_write_attr
c_func
(paren
id|ntfs_inode
op_star
id|ino
comma
r_int
id|type
comma
r_char
op_star
id|name
comma
id|__s64
id|offset
comma
id|ntfs_io
op_star
id|buf
)paren
(brace
id|ntfs_attribute
op_star
id|attr
suffix:semicolon
id|buf-&gt;do_read
op_assign
l_int|0
suffix:semicolon
id|attr
op_assign
id|ntfs_find_attr
c_func
(paren
id|ino
comma
id|type
comma
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|attr
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_return
id|ntfs_readwrite_attr
c_func
(paren
id|ino
comma
id|attr
comma
id|offset
comma
id|buf
)paren
suffix:semicolon
)brace
DECL|function|ntfs_vcn_to_lcn
r_int
id|ntfs_vcn_to_lcn
c_func
(paren
id|ntfs_inode
op_star
id|ino
comma
r_int
id|vcn
)paren
(brace
r_int
id|rnum
suffix:semicolon
id|ntfs_attribute
op_star
id|data
suffix:semicolon
id|data
op_assign
id|ntfs_find_attr
c_func
(paren
id|ino
comma
id|ino-&gt;vol-&gt;at_data
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* It&squot;s hard to give an error code. */
r_if
c_cond
(paren
op_logical_neg
id|data
op_logical_or
id|data-&gt;resident
op_logical_or
id|data-&gt;flags
op_amp
(paren
id|ATTR_IS_COMPRESSED
op_or
id|ATTR_IS_ENCRYPTED
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|data-&gt;size
op_le
(paren
id|__s64
)paren
id|vcn
op_lshift
id|ino-&gt;vol-&gt;cluster_size_bits
)paren
r_return
op_minus
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * For Linux, block number 0 represents a hole. Hopefully, nobody will&n;&t; * attempt to bmap $Boot. FIXME: Hopes are not good enough! We need to&n;&t; * fix this properly before reenabling mmap-ed stuff. (AIA)&n;&t; */
r_if
c_cond
(paren
id|data-&gt;initialized
op_le
(paren
id|__s64
)paren
id|vcn
op_lshift
id|ino-&gt;vol-&gt;cluster_size_bits
)paren
r_return
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|rnum
op_assign
l_int|0
suffix:semicolon
id|rnum
OL
id|data-&gt;d.r.len
op_logical_and
id|vcn
op_ge
id|data-&gt;d.r.runlist
(braket
id|rnum
)braket
dot
id|len
suffix:semicolon
id|rnum
op_increment
)paren
id|vcn
op_sub_assign
id|data-&gt;d.r.runlist
(braket
id|rnum
)braket
dot
id|len
suffix:semicolon
multiline_comment|/* We need to cope with sparse runs. (AIA) */
r_return
id|data-&gt;d.r.runlist
(braket
id|rnum
)braket
dot
id|cluster
op_plus
id|vcn
suffix:semicolon
)brace
DECL|function|allocate_store
r_static
r_int
id|allocate_store
c_func
(paren
id|ntfs_volume
op_star
id|vol
comma
id|ntfs_disk_inode
op_star
id|store
comma
r_int
id|count
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|store-&gt;count
OG
id|count
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|store-&gt;size
OL
id|count
)paren
(brace
id|ntfs_mft_record
op_star
id|n
op_assign
id|ntfs_malloc
c_func
(paren
(paren
id|count
op_plus
l_int|4
)paren
op_star
r_sizeof
(paren
id|ntfs_mft_record
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|n
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
id|store-&gt;size
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|store-&gt;size
suffix:semicolon
id|i
op_increment
)paren
id|n
(braket
id|i
)braket
op_assign
id|store-&gt;records
(braket
id|i
)braket
suffix:semicolon
id|ntfs_free
c_func
(paren
id|store-&gt;records
)paren
suffix:semicolon
)brace
id|store-&gt;size
op_assign
id|count
op_plus
l_int|4
suffix:semicolon
id|store-&gt;records
op_assign
id|n
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
id|store-&gt;count
suffix:semicolon
id|i
OL
id|count
suffix:semicolon
id|i
op_increment
)paren
(brace
id|store-&gt;records
(braket
id|i
)braket
dot
id|record
op_assign
id|ntfs_malloc
c_func
(paren
id|vol-&gt;mft_record_size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|store-&gt;records
(braket
id|i
)braket
dot
id|record
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|store-&gt;count
op_increment
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|deallocate_store
r_static
r_void
id|deallocate_store
c_func
(paren
id|ntfs_disk_inode
op_star
id|store
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|store-&gt;count
suffix:semicolon
id|i
op_increment
)paren
id|ntfs_free
c_func
(paren
id|store-&gt;records
(braket
id|i
)braket
dot
id|record
)paren
suffix:semicolon
id|ntfs_free
c_func
(paren
id|store-&gt;records
)paren
suffix:semicolon
id|store-&gt;count
op_assign
id|store-&gt;size
op_assign
l_int|0
suffix:semicolon
id|store-&gt;records
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * layout_runs - compress run list into mapping pairs array&n; * @attr:&t;attribute containing the run list to compress&n; * @rec:&t;destination buffer to hold the mapping pairs array&n; * @offs:&t;current position in @rec (in/out variable)&n; * @size:&t;size of the buffer @rec&n; *&n; * layout_runs walks the run list in @attr, compresses it and writes it out the&n; * resulting mapping pairs array into @rec (up to a maximum of @size bytes are&n; * written). On entry @offs is the offset in @rec at which to begin writing the&n; * mapping pairs array. On exit, it contains the offset in @rec of the first&n; * byte after the end of the mapping pairs array.&n; */
DECL|function|layout_runs
r_static
r_int
id|layout_runs
c_func
(paren
id|ntfs_attribute
op_star
id|attr
comma
r_char
op_star
id|rec
comma
r_int
op_star
id|offs
comma
r_int
id|size
)paren
(brace
r_int
id|i
comma
id|len
comma
id|offset
comma
id|coffs
suffix:semicolon
multiline_comment|/* ntfs_cluster_t MUST be signed! (AIA) */
id|ntfs_cluster_t
id|cluster
comma
id|rclus
suffix:semicolon
id|ntfs_runlist
op_star
id|rl
op_assign
id|attr-&gt;d.r.runlist
suffix:semicolon
id|cluster
op_assign
l_int|0
suffix:semicolon
id|offset
op_assign
op_star
id|offs
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|attr-&gt;d.r.len
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/*&n;&t;&t; * We cheat with this check on the basis that cluster will never&n;&t;&t; * be less than -1 and the cluster delta will fit in signed&n;&t;&t; * 32-bits (ntfs_cluster_t). (AIA)&n;&t;&t; */
r_if
c_cond
(paren
id|rl
(braket
id|i
)braket
dot
id|cluster
OL
(paren
id|ntfs_cluster_t
)paren
op_minus
l_int|1
)paren
(brace
id|ntfs_error
c_func
(paren
l_string|&quot;layout_runs() encountered an out of bounds &quot;
l_string|&quot;cluster delta!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ERANGE
suffix:semicolon
)brace
id|rclus
op_assign
id|rl
(braket
id|i
)braket
dot
id|cluster
op_minus
id|cluster
suffix:semicolon
id|len
op_assign
id|rl
(braket
id|i
)braket
dot
id|len
suffix:semicolon
id|rec
(braket
id|offset
)braket
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|offset
op_plus
l_int|9
OG
id|size
)paren
r_return
op_minus
id|E2BIG
suffix:semicolon
multiline_comment|/* It might still fit, but this&n;&t;&t;&t;&t;&t;* simplifies testing. */
multiline_comment|/*&n;&t;&t; * Run length is stored as signed number, so deal with it&n;&t;&t; * properly, i.e. observe that a negative number will have all&n;&t;&t; * its most significant bits set to 1 but we don&squot;t store that&n;&t;&t; * in the mapping pairs array. We store the smallest type of&n;&t;&t; * negative number required, thus in the first if we check&n;&t;&t; * whether len fits inside a signed byte and if so we store it&n;&t;&t; * as such, the next ifs check for a signed short, then a signed&n;&t;&t; * 24-bit and finally the full blown signed 32-bit. Same goes&n;&t;&t; * for rlus below. (AIA)&n;&t;&t; */
r_if
c_cond
(paren
id|len
op_ge
op_minus
l_int|0x80
op_logical_and
id|len
op_le
l_int|0x7f
)paren
(brace
id|NTFS_PUTU8
c_func
(paren
id|rec
op_plus
id|offset
op_plus
l_int|1
comma
id|len
op_amp
l_int|0xff
)paren
suffix:semicolon
id|coffs
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|len
op_ge
op_minus
l_int|0x8000
op_logical_and
id|len
op_le
l_int|0x7fff
)paren
(brace
id|NTFS_PUTU16
c_func
(paren
id|rec
op_plus
id|offset
op_plus
l_int|1
comma
id|len
op_amp
l_int|0xffff
)paren
suffix:semicolon
id|coffs
op_assign
l_int|2
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|len
op_ge
op_minus
l_int|0x800000
op_logical_and
id|len
op_le
l_int|0x7fffff
)paren
(brace
id|NTFS_PUTU24
c_func
(paren
id|rec
op_plus
id|offset
op_plus
l_int|1
comma
id|len
op_amp
l_int|0xffffff
)paren
suffix:semicolon
id|coffs
op_assign
l_int|3
suffix:semicolon
)brace
r_else
multiline_comment|/* if (len &gt;= -0x80000000LL &amp;&amp; len &lt;= 0x7fffffff */
(brace
id|NTFS_PUTU32
c_func
(paren
id|rec
op_plus
id|offset
op_plus
l_int|1
comma
id|len
)paren
suffix:semicolon
id|coffs
op_assign
l_int|4
suffix:semicolon
)brace
multiline_comment|/* else ... FIXME: When len becomes 64-bit we need to extend&n;&t;&t;   * &t;&t;     the else if () statements. (AIA) */
op_star
(paren
id|rec
op_plus
id|offset
)paren
op_or_assign
id|coffs
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|rl
(braket
id|i
)braket
dot
id|cluster
op_eq
(paren
id|ntfs_cluster_t
)paren
op_minus
l_int|1
)paren
multiline_comment|/* Compressed run. */
multiline_comment|/* Nothing */
suffix:semicolon
r_else
r_if
c_cond
(paren
id|rclus
op_ge
op_minus
l_int|0x80
op_logical_and
id|rclus
op_le
l_int|0x7f
)paren
(brace
op_star
(paren
id|rec
op_plus
id|offset
)paren
op_or_assign
l_int|0x10
suffix:semicolon
id|NTFS_PUTS8
c_func
(paren
id|rec
op_plus
id|offset
op_plus
id|coffs
comma
id|rclus
op_amp
l_int|0xff
)paren
suffix:semicolon
id|coffs
op_add_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|rclus
op_ge
op_minus
l_int|0x8000
op_logical_and
id|rclus
op_le
l_int|0x7fff
)paren
(brace
op_star
(paren
id|rec
op_plus
id|offset
)paren
op_or_assign
l_int|0x20
suffix:semicolon
id|NTFS_PUTS16
c_func
(paren
id|rec
op_plus
id|offset
op_plus
id|coffs
comma
id|rclus
op_amp
l_int|0xffff
)paren
suffix:semicolon
id|coffs
op_add_assign
l_int|2
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|rclus
op_ge
op_minus
l_int|0x800000
op_logical_and
id|rclus
op_le
l_int|0x7fffff
)paren
(brace
op_star
(paren
id|rec
op_plus
id|offset
)paren
op_or_assign
l_int|0x30
suffix:semicolon
id|NTFS_PUTS24
c_func
(paren
id|rec
op_plus
id|offset
op_plus
id|coffs
comma
id|rclus
op_amp
l_int|0xffffff
)paren
suffix:semicolon
id|coffs
op_add_assign
l_int|3
suffix:semicolon
)brace
r_else
multiline_comment|/* if (rclus &gt;= -0x80000000LL &amp;&amp; rclus &lt;= 0x7fffffff)*/
(brace
op_star
(paren
id|rec
op_plus
id|offset
)paren
op_or_assign
l_int|0x40
suffix:semicolon
id|NTFS_PUTS32
c_func
(paren
id|rec
op_plus
id|offset
op_plus
id|coffs
comma
id|rclus
multiline_comment|/* &amp; 0xffffffffLL */
)paren
suffix:semicolon
id|coffs
op_add_assign
l_int|4
suffix:semicolon
)brace
multiline_comment|/* FIXME: When rclus becomes 64-bit.&n;&t;&t;else if (rclus &gt;= -0x8000000000 &amp;&amp; rclus &lt;= 0x7FFFFFFFFF) {&n;&t;&t;&t;*(rec + offset) |= 0x50;&n;&t;&t;&t;NTFS_PUTS40(rec + offset + coffs, rclus &amp;&n;&t;&t;&t;&t;&t;&t;&t;0xffffffffffLL);&n;&t;&t;&t;coffs += 5;&n;&t;&t;} else if (rclus &gt;= -0x800000000000 &amp;&amp; &n;&t;&t;&t;&t;&t;&t;rclus &lt;= 0x7FFFFFFFFFFF) {&n;&t;&t;&t;*(rec + offset) |= 0x60;&n;&t;&t;&t;NTFS_PUTS48(rec + offset + coffs, rclus &amp;&n;&t;&t;&t;&t;&t;&t;&t;0xffffffffffffLL);&n;&t;&t;&t;coffs += 6;&n;&t;&t;} else if (rclus &gt;= -0x80000000000000 &amp;&amp; &n;&t;&t;&t;&t;&t;&t;rclus &lt;= 0x7FFFFFFFFFFFFF) {&n;&t;&t;&t;*(rec + offset) |= 0x70;&n;&t;&t;&t;NTFS_PUTS56(rec + offset + coffs, rclus &amp;&n;&t;&t;&t;&t;&t;&t;&t;0xffffffffffffffLL);&n;&t;&t;&t;coffs += 7;&n;&t;&t;} else {&n;&t;&t;&t;*(rec + offset) |= 0x80;&n;&t;&t;&t;NTFS_PUTS64(rec + offset + coffs, rclus);&n;&t;&t;&t;coffs += 8;&n;&t;&t;} */
id|offset
op_add_assign
id|coffs
suffix:semicolon
r_if
c_cond
(paren
id|rl
(braket
id|i
)braket
dot
id|cluster
)paren
id|cluster
op_assign
id|rl
(braket
id|i
)braket
dot
id|cluster
suffix:semicolon
)brace
r_if
c_cond
(paren
id|offset
op_ge
id|size
)paren
r_return
op_minus
id|E2BIG
suffix:semicolon
multiline_comment|/* Terminating null. */
op_star
(paren
id|rec
op_plus
id|offset
op_increment
)paren
op_assign
l_int|0
suffix:semicolon
op_star
id|offs
op_assign
id|offset
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|count_runs
r_static
r_void
id|count_runs
c_func
(paren
id|ntfs_attribute
op_star
id|attr
comma
r_char
op_star
id|buf
)paren
(brace
id|ntfs_u32
id|first
comma
id|count
comma
id|last
comma
id|i
suffix:semicolon
id|first
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|count
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|attr-&gt;d.r.len
suffix:semicolon
id|i
op_increment
)paren
id|count
op_add_assign
id|attr-&gt;d.r.runlist
(braket
id|i
)braket
dot
id|len
suffix:semicolon
id|last
op_assign
id|first
op_plus
id|count
op_minus
l_int|1
suffix:semicolon
id|NTFS_PUTU64
c_func
(paren
id|buf
op_plus
l_int|0x10
comma
id|first
)paren
suffix:semicolon
id|NTFS_PUTU64
c_func
(paren
id|buf
op_plus
l_int|0x18
comma
id|last
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * layout_attr - convert in memory attribute to on disk attribute record&n; * @attr:&t;in memory attribute to convert&n; * @buf:&t;destination buffer for on disk attribute record&n; * @size:&t;size of the destination buffer&n; * @psize:&t;size of converted on disk attribute record (out variable)&n; *&n; * layout_attr takes the attribute @attr and converts it into the appropriate&n; * on disk structure, writing it into @buf (up to @size bytes are written).&n; * On return, @psize contains the actual size of the on disk attribute written&n; * into @buf.&n; */
DECL|function|layout_attr
r_static
r_int
id|layout_attr
c_func
(paren
id|ntfs_attribute
op_star
id|attr
comma
r_char
op_star
id|buf
comma
r_int
id|size
comma
r_int
op_star
id|psize
)paren
(brace
r_int
id|nameoff
comma
id|hdrsize
comma
id|asize
suffix:semicolon
r_if
c_cond
(paren
id|attr-&gt;resident
)paren
(brace
id|nameoff
op_assign
l_int|0x18
suffix:semicolon
id|hdrsize
op_assign
(paren
id|nameoff
op_plus
l_int|2
op_star
id|attr-&gt;namelen
op_plus
l_int|7
)paren
op_amp
op_complement
l_int|7
suffix:semicolon
id|asize
op_assign
(paren
id|hdrsize
op_plus
id|attr-&gt;size
op_plus
l_int|7
)paren
op_amp
op_complement
l_int|7
suffix:semicolon
r_if
c_cond
(paren
id|size
OL
id|asize
)paren
r_return
op_minus
id|E2BIG
suffix:semicolon
id|NTFS_PUTU32
c_func
(paren
id|buf
op_plus
l_int|0x10
comma
id|attr-&gt;size
)paren
suffix:semicolon
id|NTFS_PUTU8
c_func
(paren
id|buf
op_plus
l_int|0x16
comma
id|attr-&gt;indexed
)paren
suffix:semicolon
id|NTFS_PUTU16
c_func
(paren
id|buf
op_plus
l_int|0x14
comma
id|hdrsize
)paren
suffix:semicolon
r_if
c_cond
(paren
id|attr-&gt;size
)paren
id|ntfs_memcpy
c_func
(paren
id|buf
op_plus
id|hdrsize
comma
id|attr-&gt;d.data
comma
id|attr-&gt;size
)paren
suffix:semicolon
)brace
r_else
(brace
r_int
id|error
suffix:semicolon
r_if
c_cond
(paren
id|attr-&gt;flags
op_amp
id|ATTR_IS_COMPRESSED
)paren
id|nameoff
op_assign
l_int|0x48
suffix:semicolon
r_else
id|nameoff
op_assign
l_int|0x40
suffix:semicolon
id|hdrsize
op_assign
(paren
id|nameoff
op_plus
l_int|2
op_star
id|attr-&gt;namelen
op_plus
l_int|7
)paren
op_amp
op_complement
l_int|7
suffix:semicolon
r_if
c_cond
(paren
id|size
OL
id|hdrsize
)paren
r_return
op_minus
id|E2BIG
suffix:semicolon
multiline_comment|/* Make asize point at the end of the attribute record header,&n;&t;&t;   i.e. at the beginning of the mapping pairs array. */
id|asize
op_assign
id|hdrsize
suffix:semicolon
id|error
op_assign
id|layout_runs
c_func
(paren
id|attr
comma
id|buf
comma
op_amp
id|asize
comma
id|size
)paren
suffix:semicolon
multiline_comment|/* Now, asize points one byte beyond the end of the mapping&n;&t;&t;   pairs array. */
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
multiline_comment|/* The next attribute has to begin on 8-byte boundary. */
id|asize
op_assign
(paren
id|asize
op_plus
l_int|7
)paren
op_amp
op_complement
l_int|7
suffix:semicolon
multiline_comment|/* FIXME: fragments */
id|count_runs
c_func
(paren
id|attr
comma
id|buf
)paren
suffix:semicolon
id|NTFS_PUTU16
c_func
(paren
id|buf
op_plus
l_int|0x20
comma
id|hdrsize
)paren
suffix:semicolon
id|NTFS_PUTU16
c_func
(paren
id|buf
op_plus
l_int|0x22
comma
id|attr-&gt;cengine
)paren
suffix:semicolon
id|NTFS_PUTU32
c_func
(paren
id|buf
op_plus
l_int|0x24
comma
l_int|0
)paren
suffix:semicolon
id|NTFS_PUTS64
c_func
(paren
id|buf
op_plus
l_int|0x28
comma
id|attr-&gt;allocated
)paren
suffix:semicolon
id|NTFS_PUTS64
c_func
(paren
id|buf
op_plus
l_int|0x30
comma
id|attr-&gt;size
)paren
suffix:semicolon
id|NTFS_PUTS64
c_func
(paren
id|buf
op_plus
l_int|0x38
comma
id|attr-&gt;initialized
)paren
suffix:semicolon
r_if
c_cond
(paren
id|attr-&gt;flags
op_amp
id|ATTR_IS_COMPRESSED
)paren
id|NTFS_PUTS64
c_func
(paren
id|buf
op_plus
l_int|0x40
comma
id|attr-&gt;compsize
)paren
suffix:semicolon
)brace
id|NTFS_PUTU32
c_func
(paren
id|buf
comma
id|attr-&gt;type
)paren
suffix:semicolon
id|NTFS_PUTU32
c_func
(paren
id|buf
op_plus
l_int|4
comma
id|asize
)paren
suffix:semicolon
id|NTFS_PUTU8
c_func
(paren
id|buf
op_plus
l_int|8
comma
id|attr-&gt;resident
ques
c_cond
l_int|0
suffix:colon
l_int|1
)paren
suffix:semicolon
id|NTFS_PUTU8
c_func
(paren
id|buf
op_plus
l_int|9
comma
id|attr-&gt;namelen
)paren
suffix:semicolon
id|NTFS_PUTU16
c_func
(paren
id|buf
op_plus
l_int|0xa
comma
id|nameoff
)paren
suffix:semicolon
id|NTFS_PUTU16
c_func
(paren
id|buf
op_plus
l_int|0xc
comma
id|attr-&gt;flags
)paren
suffix:semicolon
id|NTFS_PUTU16
c_func
(paren
id|buf
op_plus
l_int|0xe
comma
id|attr-&gt;attrno
)paren
suffix:semicolon
r_if
c_cond
(paren
id|attr-&gt;namelen
)paren
id|ntfs_memcpy
c_func
(paren
id|buf
op_plus
id|nameoff
comma
id|attr-&gt;name
comma
l_int|2
op_star
id|attr-&gt;namelen
)paren
suffix:semicolon
op_star
id|psize
op_assign
id|asize
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * layout_inode - convert an in memory inode into on disk mft record(s)&n; * @ino:&t;in memory inode to convert&n; * @store:&t;on disk inode, contain buffers for the on disk mft record(s)&n; *&n; * layout_inode takes the in memory inode @ino, converts it into a (sequence of)&n; * mft record(s) and writes them to the appropriate buffers in the @store.&n; *&n; * Return 0 on success,&n; * the required mft record count (&gt;0) if the inode does not fit,&n; * -ENOMEM if memory allocation problem or&n; * -EOPNOTSUP if beyond our capabilities.&n; */
DECL|function|layout_inode
r_int
id|layout_inode
c_func
(paren
id|ntfs_inode
op_star
id|ino
comma
id|ntfs_disk_inode
op_star
id|store
)paren
(brace
r_int
id|offset
comma
id|i
comma
id|size
comma
id|psize
comma
id|error
comma
id|count
comma
id|recno
suffix:semicolon
id|ntfs_attribute
op_star
id|attr
suffix:semicolon
r_int
r_char
op_star
id|rec
suffix:semicolon
id|error
op_assign
id|allocate_store
c_func
(paren
id|ino-&gt;vol
comma
id|store
comma
id|ino-&gt;record_count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
id|size
op_assign
id|ino-&gt;vol-&gt;mft_record_size
suffix:semicolon
id|count
op_assign
id|i
op_assign
l_int|0
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|count
OL
id|ino-&gt;record_count
)paren
(brace
id|recno
op_assign
id|ino-&gt;records
(braket
id|count
)braket
suffix:semicolon
)brace
r_else
(brace
id|error
op_assign
id|allocate_store
c_func
(paren
id|ino-&gt;vol
comma
id|store
comma
id|count
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
id|recno
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * FIXME: We need to support extension records properly.&n;&t;&t; * At the moment they wouldn&squot;t work. Probably would &quot;just&quot; get&n;&t;&t; * corrupted if we write to them... (AIA)&n;&t;&t; */
id|store-&gt;records
(braket
id|count
)braket
dot
id|recno
op_assign
id|recno
suffix:semicolon
id|rec
op_assign
id|store-&gt;records
(braket
id|count
)braket
dot
id|record
suffix:semicolon
id|count
op_increment
suffix:semicolon
multiline_comment|/* Copy header. */
id|offset
op_assign
id|NTFS_GETU16
c_func
(paren
id|ino-&gt;attr
op_plus
l_int|0x14
)paren
suffix:semicolon
id|ntfs_memcpy
c_func
(paren
id|rec
comma
id|ino-&gt;attr
comma
id|offset
)paren
suffix:semicolon
multiline_comment|/* Copy attributes. */
r_while
c_loop
(paren
id|i
OL
id|ino-&gt;attr_count
)paren
(brace
id|attr
op_assign
id|ino-&gt;attrs
op_plus
id|i
suffix:semicolon
id|error
op_assign
id|layout_attr
c_func
(paren
id|attr
comma
id|rec
op_plus
id|offset
comma
id|size
op_minus
id|offset
op_minus
l_int|8
comma
op_amp
id|psize
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_eq
op_minus
id|E2BIG
op_logical_and
id|offset
op_ne
id|NTFS_GETU16
c_func
(paren
id|ino-&gt;attr
op_plus
l_int|0x14
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
id|offset
op_add_assign
id|psize
suffix:semicolon
id|i
op_increment
suffix:semicolon
)brace
multiline_comment|/* Terminating attribute. */
id|NTFS_PUTU32
c_func
(paren
id|rec
op_plus
id|offset
comma
l_int|0xFFFFFFFF
)paren
suffix:semicolon
id|offset
op_add_assign
l_int|4
suffix:semicolon
id|NTFS_PUTU32
c_func
(paren
id|rec
op_plus
id|offset
comma
l_int|0
)paren
suffix:semicolon
id|offset
op_add_assign
l_int|4
suffix:semicolon
id|NTFS_PUTU32
c_func
(paren
id|rec
op_plus
l_int|0x18
comma
id|offset
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|i
OL
id|ino-&gt;attr_count
op_logical_or
id|count
OL
id|ino-&gt;record_count
)paren
suffix:semicolon
r_return
id|count
op_minus
id|ino-&gt;record_count
suffix:semicolon
)brace
multiline_comment|/*&n; * FIXME: ntfs_update_inode() calls layout_inode() to create the mft record on&n; * disk structure corresponding to the inode @ino. After that, ntfs_write_attr()&n; * is called to write out the created mft record to disk.&n; * We shouldn&squot;t need to re-layout every single time we are updating an mft&n; * record. No wonder the ntfs driver is slow like hell. (AIA)&n; */
DECL|function|ntfs_update_inode
r_int
id|ntfs_update_inode
c_func
(paren
id|ntfs_inode
op_star
id|ino
)paren
(brace
r_int
id|error
comma
id|i
suffix:semicolon
id|ntfs_disk_inode
id|store
suffix:semicolon
id|ntfs_io
id|io
suffix:semicolon
id|ntfs_bzero
c_func
(paren
op_amp
id|store
comma
r_sizeof
(paren
id|store
)paren
)paren
suffix:semicolon
id|error
op_assign
id|layout_inode
c_func
(paren
id|ino
comma
op_amp
id|store
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_eq
op_minus
id|E2BIG
)paren
(brace
id|error
op_assign
id|ntfs_split_indexroot
c_func
(paren
id|ino
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
id|error
op_assign
id|layout_inode
c_func
(paren
id|ino
comma
op_amp
id|store
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|error
op_eq
op_minus
id|E2BIG
)paren
(brace
id|error
op_assign
id|ntfs_attr_allnonresident
c_func
(paren
id|ino
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
id|error
op_assign
id|layout_inode
c_func
(paren
id|ino
comma
op_amp
id|store
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|error
OG
l_int|0
)paren
(brace
multiline_comment|/* FIXME: Introduce extension records. */
id|error
op_assign
op_minus
id|E2BIG
suffix:semicolon
)brace
r_if
c_cond
(paren
id|error
)paren
(brace
r_if
c_cond
(paren
id|error
op_eq
op_minus
id|E2BIG
)paren
id|ntfs_error
c_func
(paren
l_string|&quot;cannot handle saving inode %x&bslash;n&quot;
comma
id|ino-&gt;i_number
)paren
suffix:semicolon
id|deallocate_store
c_func
(paren
op_amp
id|store
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
id|io.fn_get
op_assign
id|ntfs_get
suffix:semicolon
id|io.fn_put
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|store.count
suffix:semicolon
id|i
op_increment
)paren
(brace
id|error
op_assign
id|ntfs_insert_fixups
c_func
(paren
id|store.records
(braket
id|i
)braket
dot
id|record
comma
id|ino-&gt;vol-&gt;mft_record_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|printk
c_func
(paren
id|KERN_ALERT
l_string|&quot;NTFS: ntfs_update_inode() caught &quot;
l_string|&quot;corrupt %s mtf record ntfs record &quot;
l_string|&quot;header. Refusing to write corrupt &quot;
l_string|&quot;data to disk. Unmount and run chkdsk &quot;
l_string|&quot;immediately!&bslash;n&quot;
comma
id|i
ques
c_cond
l_string|&quot;extension&quot;
suffix:colon
l_string|&quot;base&quot;
)paren
suffix:semicolon
id|deallocate_store
c_func
(paren
op_amp
id|store
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|io.param
op_assign
id|store.records
(braket
id|i
)braket
dot
id|record
suffix:semicolon
id|io.size
op_assign
id|ino-&gt;vol-&gt;mft_record_size
suffix:semicolon
multiline_comment|/* FIXME: Is this the right way? */
id|error
op_assign
id|ntfs_write_attr
c_func
(paren
id|ino-&gt;vol-&gt;mft_ino
comma
id|ino-&gt;vol-&gt;at_data
comma
l_int|0
comma
(paren
id|__s64
)paren
id|store.records
(braket
id|i
)braket
dot
id|recno
op_lshift
id|ino-&gt;vol-&gt;mft_record_size_bits
comma
op_amp
id|io
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_logical_or
id|io.size
op_ne
id|ino-&gt;vol-&gt;mft_record_size
)paren
(brace
multiline_comment|/* Big trouble, partially written file. */
id|ntfs_error
c_func
(paren
l_string|&quot;Please unmount: Write error in inode &quot;
l_string|&quot;0x%x&bslash;n&quot;
comma
id|ino-&gt;i_number
)paren
suffix:semicolon
id|deallocate_store
c_func
(paren
op_amp
id|store
)paren
suffix:semicolon
r_return
id|error
ques
c_cond
id|error
suffix:colon
op_minus
id|EIO
suffix:semicolon
)brace
)brace
id|deallocate_store
c_func
(paren
op_amp
id|store
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ntfs_decompress
r_void
id|ntfs_decompress
c_func
(paren
r_int
r_char
op_star
id|dest
comma
r_int
r_char
op_star
id|src
comma
id|ntfs_size_t
id|l
)paren
(brace
r_int
id|head
comma
id|comp
suffix:semicolon
r_int
id|copied
op_assign
l_int|0
suffix:semicolon
r_int
r_char
op_star
id|stop
suffix:semicolon
r_int
id|bits
suffix:semicolon
r_int
id|tag
op_assign
l_int|0
suffix:semicolon
r_int
id|clear_pos
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|head
op_assign
id|NTFS_GETU16
c_func
(paren
id|src
)paren
op_amp
l_int|0xFFF
suffix:semicolon
multiline_comment|/* High bit indicates that compression was performed. */
id|comp
op_assign
id|NTFS_GETU16
c_func
(paren
id|src
)paren
op_amp
l_int|0x8000
suffix:semicolon
id|src
op_add_assign
l_int|2
suffix:semicolon
id|stop
op_assign
id|src
op_plus
id|head
suffix:semicolon
id|bits
op_assign
l_int|0
suffix:semicolon
id|clear_pos
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|head
op_eq
l_int|0
)paren
multiline_comment|/* Block is not used. */
r_return
suffix:semicolon
multiline_comment|/* FIXME: copied */
r_if
c_cond
(paren
op_logical_neg
id|comp
)paren
(brace
multiline_comment|/* uncompressible */
id|ntfs_memcpy
c_func
(paren
id|dest
comma
id|src
comma
l_int|0x1000
)paren
suffix:semicolon
id|dest
op_add_assign
l_int|0x1000
suffix:semicolon
id|copied
op_add_assign
l_int|0x1000
suffix:semicolon
id|src
op_add_assign
l_int|0x1000
suffix:semicolon
r_if
c_cond
(paren
id|l
op_eq
id|copied
)paren
r_return
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_while
c_loop
(paren
id|src
op_le
id|stop
)paren
(brace
r_if
c_cond
(paren
id|clear_pos
OG
l_int|4096
)paren
(brace
id|ntfs_error
c_func
(paren
l_string|&quot;Error 1 in decompress&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|bits
)paren
(brace
id|tag
op_assign
id|NTFS_GETU8
c_func
(paren
id|src
)paren
suffix:semicolon
id|bits
op_assign
l_int|8
suffix:semicolon
id|src
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|src
OG
id|stop
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tag
op_amp
l_int|1
)paren
(brace
r_int
id|i
comma
id|len
comma
id|delta
comma
id|code
comma
id|lmask
comma
id|dshift
suffix:semicolon
id|code
op_assign
id|NTFS_GETU16
c_func
(paren
id|src
)paren
suffix:semicolon
id|src
op_add_assign
l_int|2
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|clear_pos
)paren
(brace
id|ntfs_error
c_func
(paren
l_string|&quot;Error 2 in decompress&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
id|clear_pos
op_minus
l_int|1
comma
id|lmask
op_assign
l_int|0xFFF
comma
id|dshift
op_assign
l_int|12
suffix:semicolon
id|i
op_ge
l_int|0x10
suffix:semicolon
id|i
op_rshift_assign
l_int|1
)paren
(brace
id|lmask
op_rshift_assign
l_int|1
suffix:semicolon
id|dshift
op_decrement
suffix:semicolon
)brace
id|delta
op_assign
id|code
op_rshift
id|dshift
suffix:semicolon
id|len
op_assign
(paren
id|code
op_amp
id|lmask
)paren
op_plus
l_int|3
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
suffix:semicolon
id|i
op_increment
)paren
(brace
id|dest
(braket
id|clear_pos
)braket
op_assign
id|dest
(braket
id|clear_pos
op_minus
id|delta
op_minus
l_int|1
)braket
suffix:semicolon
id|clear_pos
op_increment
suffix:semicolon
id|copied
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|copied
op_eq
id|l
)paren
r_return
suffix:semicolon
)brace
)brace
r_else
(brace
id|dest
(braket
id|clear_pos
op_increment
)braket
op_assign
id|NTFS_GETU8
c_func
(paren
id|src
)paren
suffix:semicolon
id|src
op_increment
suffix:semicolon
id|copied
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|copied
op_eq
id|l
)paren
r_return
suffix:semicolon
)brace
id|tag
op_rshift_assign
l_int|1
suffix:semicolon
id|bits
op_decrement
suffix:semicolon
)brace
id|dest
op_add_assign
id|clear_pos
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * NOTE: Neither of the ntfs_*_bit functions are atomic! But we don&squot;t need&n; * them atomic at present as we never operate on shared/cached bitmaps.&n; */
DECL|function|ntfs_get_bit
r_static
id|__inline__
r_int
id|ntfs_get_bit
c_func
(paren
r_int
r_char
op_star
id|byte
comma
r_const
r_int
id|bit
)paren
(brace
r_return
id|byte
(braket
id|bit
op_rshift
l_int|3
)braket
op_amp
(paren
l_int|1
op_lshift
(paren
id|bit
op_amp
l_int|7
)paren
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
)brace
DECL|function|ntfs_set_bit
r_static
id|__inline__
r_void
id|ntfs_set_bit
c_func
(paren
r_int
r_char
op_star
id|byte
comma
r_const
r_int
id|bit
)paren
(brace
id|byte
(braket
id|bit
op_rshift
l_int|3
)braket
op_or_assign
l_int|1
op_lshift
(paren
id|bit
op_amp
l_int|7
)paren
suffix:semicolon
)brace
DECL|function|ntfs_clear_bit
r_static
id|__inline__
r_void
id|ntfs_clear_bit
c_func
(paren
r_int
r_char
op_star
id|byte
comma
r_const
r_int
id|bit
)paren
(brace
id|byte
(braket
id|bit
op_rshift
l_int|3
)braket
op_and_assign
op_complement
(paren
l_int|1
op_lshift
(paren
id|bit
op_amp
l_int|7
)paren
)paren
suffix:semicolon
)brace
DECL|function|ntfs_test_and_set_bit
id|__inline__
r_int
id|ntfs_test_and_set_bit
c_func
(paren
r_int
r_char
op_star
id|byte
comma
r_const
r_int
id|bit
)paren
(brace
r_int
r_char
op_star
id|ptr
op_assign
id|byte
op_plus
(paren
id|bit
op_rshift
l_int|3
)paren
suffix:semicolon
r_int
id|b
op_assign
l_int|1
op_lshift
(paren
id|bit
op_amp
l_int|7
)paren
suffix:semicolon
r_int
id|oldbit
op_assign
op_star
id|ptr
op_amp
id|b
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
op_star
id|ptr
op_or_assign
id|b
suffix:semicolon
r_return
id|oldbit
suffix:semicolon
)brace
DECL|function|ntfs_test_and_clear_bit
r_static
id|__inline__
r_int
id|ntfs_test_and_clear_bit
c_func
(paren
r_int
r_char
op_star
id|byte
comma
r_const
r_int
id|bit
)paren
(brace
r_int
r_char
op_star
id|ptr
op_assign
id|byte
op_plus
(paren
id|bit
op_rshift
l_int|3
)paren
suffix:semicolon
r_int
id|b
op_assign
l_int|1
op_lshift
(paren
id|bit
op_amp
l_int|7
)paren
suffix:semicolon
r_int
id|oldbit
op_assign
op_star
id|ptr
op_amp
id|b
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
op_star
id|ptr
op_and_assign
op_complement
id|b
suffix:semicolon
r_return
id|oldbit
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_new_inode - allocate an mft record&n; * @vol:&t;volume to allocate an mft record on&n; * @result:&t;the mft record number allocated&n; *&n; * Allocate a new mft record on disk by finding the first free mft record&n; * and allocating it in the mft bitmap.&n; * Return 0 on success or -ERRNO on error.&n; *&n; * TODO(AIA): Implement mft bitmap caching.&n; */
DECL|function|ntfs_new_inode
r_static
r_int
id|ntfs_new_inode
c_func
(paren
id|ntfs_volume
op_star
id|vol
comma
r_int
r_int
op_star
id|result
)paren
(brace
r_int
id|byte
comma
id|bit
comma
id|error
comma
id|size
comma
id|length
suffix:semicolon
r_int
r_char
id|value
suffix:semicolon
id|ntfs_u8
op_star
id|buffer
suffix:semicolon
id|ntfs_io
id|io
suffix:semicolon
id|ntfs_attribute
op_star
id|data
suffix:semicolon
op_star
id|result
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Determine the number of mft records in the mft. */
id|data
op_assign
id|ntfs_find_attr
c_func
(paren
id|vol-&gt;mft_ino
comma
id|vol-&gt;at_data
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|data
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|length
op_assign
id|data-&gt;size
op_rshift
id|vol-&gt;mft_record_size_bits
suffix:semicolon
multiline_comment|/* Allocate sufficient space for the mft bitmap attribute value,&n;&t;   inferring it from the number of mft records. */
id|buffer
op_assign
id|ntfs_malloc
c_func
(paren
(paren
id|length
op_plus
l_int|7
)paren
op_rshift
l_int|3
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buffer
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|io.fn_put
op_assign
id|ntfs_put
suffix:semicolon
id|io.fn_get
op_assign
id|ntfs_get
suffix:semicolon
id|try_again
suffix:colon
id|io.param
op_assign
id|buffer
suffix:semicolon
id|io.size
op_assign
(paren
id|length
op_plus
l_int|7
)paren
op_rshift
l_int|3
suffix:semicolon
id|error
op_assign
id|ntfs_read_attr
c_func
(paren
id|vol-&gt;mft_ino
comma
id|vol-&gt;at_bitmap
comma
l_int|0
comma
l_int|0
comma
op_amp
id|io
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|err_out
suffix:semicolon
id|size
op_assign
id|io.size
suffix:semicolon
multiline_comment|/* Start at byte 0, as the bits for all 16 system files are already&n;&t;   set in the bitmap. */
r_for
c_loop
(paren
id|bit
op_assign
id|byte
op_assign
l_int|0
suffix:semicolon
(paren
id|byte
op_lshift
l_int|3
)paren
OL
id|length
suffix:semicolon
id|byte
op_increment
)paren
(brace
id|value
op_assign
id|buffer
(braket
id|byte
)braket
suffix:semicolon
r_if
c_cond
(paren
id|value
op_eq
l_int|0xFF
)paren
r_continue
suffix:semicolon
id|bit
op_assign
id|ffz
c_func
(paren
id|value
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bit
OL
l_int|8
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|byte
op_lshift
l_int|3
)paren
op_plus
id|bit
op_ge
id|length
)paren
(brace
multiline_comment|/* No free space left. Need to extend the mft. */
id|error
op_assign
op_minus
id|ENOSPC
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
multiline_comment|/* Get the byte containing our bit again, now taking the BKL. */
id|io.param
op_assign
id|buffer
suffix:semicolon
id|io.size
op_assign
l_int|1
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|error
op_assign
id|ntfs_read_attr
c_func
(paren
id|vol-&gt;mft_ino
comma
id|vol-&gt;at_bitmap
comma
l_int|0
comma
id|byte
comma
op_amp
id|io
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_logical_or
(paren
id|io.size
op_ne
l_int|1
op_logical_and
(paren
id|error
op_assign
op_minus
id|EIO
comma
l_int|1
)paren
)paren
)paren
r_goto
id|err_unl_out
suffix:semicolon
r_if
c_cond
(paren
id|ntfs_test_and_set_bit
c_func
(paren
id|buffer
comma
id|bit
)paren
)paren
(brace
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Give other process(es) a chance to finish. */
id|schedule
c_func
(paren
)paren
suffix:semicolon
r_goto
id|try_again
suffix:semicolon
)brace
id|io.param
op_assign
id|buffer
suffix:semicolon
id|error
op_assign
id|ntfs_write_attr
c_func
(paren
id|vol-&gt;mft_ino
comma
id|vol-&gt;at_bitmap
comma
l_int|0
comma
id|byte
comma
op_amp
id|io
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_logical_or
(paren
id|io.size
op_ne
l_int|1
op_logical_and
(paren
id|error
op_assign
op_minus
id|EIO
comma
l_int|1
)paren
)paren
)paren
r_goto
id|err_unl_out
suffix:semicolon
multiline_comment|/* Change mft on disk, required when mft bitmap is resident. */
id|error
op_assign
id|ntfs_update_inode
c_func
(paren
id|vol-&gt;mft_ino
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
op_star
id|result
op_assign
(paren
id|byte
op_lshift
l_int|3
)paren
op_plus
id|bit
suffix:semicolon
id|err_unl_out
suffix:colon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
id|err_out
suffix:colon
id|ntfs_free
c_func
(paren
id|buffer
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
id|error
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ntfs_new_inode() failed to allocate an &quot;
l_string|&quot;mft record. Error = %i&bslash;n&quot;
comma
id|error
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ntfs_new_inode() allocated mft record number &quot;
l_string|&quot;0x%lx&bslash;n&quot;
comma
op_star
id|result
)paren
suffix:semicolon
macro_line|#endif
r_return
id|error
suffix:semicolon
multiline_comment|/*&n;&t; * FIXME: Don&squot;t forget $MftMirr, though this probably belongs&n;&t; * in ntfs_update_inode() (or even deeper). (AIA)&n;&t; */
)brace
DECL|function|add_mft_header
r_static
r_int
id|add_mft_header
c_func
(paren
id|ntfs_inode
op_star
id|ino
)paren
(brace
r_int
r_char
op_star
id|mft
suffix:semicolon
id|ntfs_volume
op_star
id|vol
op_assign
id|ino-&gt;vol
suffix:semicolon
id|mft
op_assign
id|ino-&gt;attr
suffix:semicolon
id|ntfs_bzero
c_func
(paren
id|mft
comma
id|vol-&gt;mft_record_size
)paren
suffix:semicolon
id|ntfs_fill_mft_header
c_func
(paren
id|mft
comma
id|vol-&gt;mft_record_size
comma
id|vol-&gt;sector_size
comma
id|ino-&gt;sequence_number
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* We need 0x48 bytes in total. */
DECL|function|add_standard_information
r_static
r_int
id|add_standard_information
c_func
(paren
id|ntfs_inode
op_star
id|ino
)paren
(brace
id|ntfs_time64_t
id|now
suffix:semicolon
r_char
id|data
(braket
l_int|0x30
)braket
suffix:semicolon
r_char
op_star
id|position
op_assign
id|data
suffix:semicolon
r_int
id|error
suffix:semicolon
id|ntfs_attribute
op_star
id|si
suffix:semicolon
id|now
op_assign
id|ntfs_now
c_func
(paren
)paren
suffix:semicolon
id|NTFS_PUTU64
c_func
(paren
id|position
op_plus
l_int|0x00
comma
id|now
)paren
suffix:semicolon
multiline_comment|/* File creation */
id|NTFS_PUTU64
c_func
(paren
id|position
op_plus
l_int|0x08
comma
id|now
)paren
suffix:semicolon
multiline_comment|/* Last modification */
id|NTFS_PUTU64
c_func
(paren
id|position
op_plus
l_int|0x10
comma
id|now
)paren
suffix:semicolon
multiline_comment|/* Last mod for MFT */
id|NTFS_PUTU64
c_func
(paren
id|position
op_plus
l_int|0x18
comma
id|now
)paren
suffix:semicolon
multiline_comment|/* Last access */
id|NTFS_PUTU64
c_func
(paren
id|position
op_plus
l_int|0x20
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* MSDOS file perms */
id|NTFS_PUTU64
c_func
(paren
id|position
op_plus
l_int|0x28
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* unknown */
id|error
op_assign
id|ntfs_create_attr
c_func
(paren
id|ino
comma
id|ino-&gt;vol-&gt;at_standard_information
comma
l_int|0
comma
id|data
comma
r_sizeof
(paren
id|data
)paren
comma
op_amp
id|si
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
DECL|function|add_filename
r_static
r_int
id|add_filename
c_func
(paren
id|ntfs_inode
op_star
id|ino
comma
id|ntfs_inode
op_star
id|dir
comma
r_const
r_int
r_char
op_star
id|filename
comma
r_int
id|length
comma
id|ntfs_u32
id|flags
)paren
(brace
r_int
r_char
op_star
id|position
suffix:semicolon
r_int
r_int
id|size
suffix:semicolon
id|ntfs_time64_t
id|now
suffix:semicolon
r_int
id|count
comma
id|error
suffix:semicolon
r_int
r_char
op_star
id|data
suffix:semicolon
id|ntfs_attribute
op_star
id|fn
suffix:semicolon
multiline_comment|/* Work out the size. */
id|size
op_assign
l_int|0x42
op_plus
l_int|2
op_star
id|length
suffix:semicolon
id|data
op_assign
id|ntfs_malloc
c_func
(paren
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|data
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
multiline_comment|/* Search for a position. */
id|position
op_assign
id|data
suffix:semicolon
id|NTFS_PUTINUM
c_func
(paren
id|position
comma
id|dir
)paren
suffix:semicolon
multiline_comment|/* Inode num of dir */
id|now
op_assign
id|ntfs_now
c_func
(paren
)paren
suffix:semicolon
id|NTFS_PUTU64
c_func
(paren
id|position
op_plus
l_int|0x08
comma
id|now
)paren
suffix:semicolon
multiline_comment|/* File creation */
id|NTFS_PUTU64
c_func
(paren
id|position
op_plus
l_int|0x10
comma
id|now
)paren
suffix:semicolon
multiline_comment|/* Last modification */
id|NTFS_PUTU64
c_func
(paren
id|position
op_plus
l_int|0x18
comma
id|now
)paren
suffix:semicolon
multiline_comment|/* Last mod for MFT */
id|NTFS_PUTU64
c_func
(paren
id|position
op_plus
l_int|0x20
comma
id|now
)paren
suffix:semicolon
multiline_comment|/* Last access */
multiline_comment|/* FIXME: Get the following two sizes by finding the data attribute&n;&t; * in ino-&gt;attr and copying the corresponding fields from there.&n;&t; * If no data present then set to zero. In current implementation&n;&t; * add_data is called after add_filename so zero is correct on&n;&t; * creation. Need to change when we have hard links / support different&n;&t; * filename namespaces. (AIA) */
id|NTFS_PUTS64
c_func
(paren
id|position
op_plus
l_int|0x28
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Allocated size */
id|NTFS_PUTS64
c_func
(paren
id|position
op_plus
l_int|0x30
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Data size */
id|NTFS_PUTU32
c_func
(paren
id|position
op_plus
l_int|0x38
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* File flags */
id|NTFS_PUTU32
c_func
(paren
id|position
op_plus
l_int|0x3c
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* We don&squot;t use these&n;&t;&t;&t;&t;&t;&t;&t; * features yet. */
id|NTFS_PUTU8
c_func
(paren
id|position
op_plus
l_int|0x40
comma
id|length
)paren
suffix:semicolon
multiline_comment|/* Filename length */
id|NTFS_PUTU8
c_func
(paren
id|position
op_plus
l_int|0x41
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Only long name */
multiline_comment|/* FIXME: This is madness. We are defining the POSIX namespace&n;&t;&t; * for the filename here which can mean that the file will be&n;&t;&t; * invisible when in Windows NT/2k! )-: (AIA) */
id|position
op_add_assign
l_int|0x42
suffix:semicolon
r_for
c_loop
(paren
id|count
op_assign
l_int|0
suffix:semicolon
id|count
OL
id|length
suffix:semicolon
id|count
op_increment
)paren
(brace
id|NTFS_PUTU16
c_func
(paren
id|position
op_plus
l_int|2
op_star
id|count
comma
id|filename
(braket
id|count
)braket
)paren
suffix:semicolon
)brace
id|error
op_assign
id|ntfs_create_attr
c_func
(paren
id|ino
comma
id|ino-&gt;vol-&gt;at_file_name
comma
l_int|0
comma
id|data
comma
id|size
comma
op_amp
id|fn
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
id|error
op_assign
id|ntfs_dir_add
c_func
(paren
id|dir
comma
id|ino
comma
id|fn
)paren
suffix:semicolon
id|ntfs_free
c_func
(paren
id|data
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
DECL|function|add_security
r_int
id|add_security
c_func
(paren
id|ntfs_inode
op_star
id|ino
comma
id|ntfs_inode
op_star
id|dir
)paren
(brace
r_int
id|error
suffix:semicolon
r_char
op_star
id|buf
suffix:semicolon
r_int
id|size
suffix:semicolon
id|ntfs_attribute
op_star
id|attr
suffix:semicolon
id|ntfs_io
id|io
suffix:semicolon
id|ntfs_attribute
op_star
id|se
suffix:semicolon
id|attr
op_assign
id|ntfs_find_attr
c_func
(paren
id|dir
comma
id|ino-&gt;vol-&gt;at_security_descriptor
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|attr
)paren
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
multiline_comment|/* Need security in directory. */
id|size
op_assign
id|attr-&gt;size
suffix:semicolon
r_if
c_cond
(paren
id|size
OG
l_int|512
)paren
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
id|buf
op_assign
id|ntfs_malloc
c_func
(paren
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buf
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|io.fn_get
op_assign
id|ntfs_get
suffix:semicolon
id|io.fn_put
op_assign
id|ntfs_put
suffix:semicolon
id|io.param
op_assign
id|buf
suffix:semicolon
id|io.size
op_assign
id|size
suffix:semicolon
id|error
op_assign
id|ntfs_read_attr
c_func
(paren
id|dir
comma
id|ino-&gt;vol-&gt;at_security_descriptor
comma
l_int|0
comma
l_int|0
comma
op_amp
id|io
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
op_logical_and
id|io.size
op_ne
id|size
)paren
id|ntfs_error
c_func
(paren
l_string|&quot;wrong size in add_security&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|ntfs_free
c_func
(paren
id|buf
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/* FIXME: Consider ACL inheritance. */
id|error
op_assign
id|ntfs_create_attr
c_func
(paren
id|ino
comma
id|ino-&gt;vol-&gt;at_security_descriptor
comma
l_int|0
comma
id|buf
comma
id|size
comma
op_amp
id|se
)paren
suffix:semicolon
id|ntfs_free
c_func
(paren
id|buf
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
DECL|function|add_data
r_static
r_int
id|add_data
c_func
(paren
id|ntfs_inode
op_star
id|ino
comma
r_int
r_char
op_star
id|data
comma
r_int
id|length
)paren
(brace
r_int
id|error
suffix:semicolon
id|ntfs_attribute
op_star
id|da
suffix:semicolon
id|error
op_assign
id|ntfs_create_attr
c_func
(paren
id|ino
comma
id|ino-&gt;vol-&gt;at_data
comma
l_int|0
comma
id|data
comma
id|length
comma
op_amp
id|da
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/* We _could_ use &squot;dir&squot; to help optimise inode allocation. */
DECL|function|ntfs_alloc_inode
r_int
id|ntfs_alloc_inode
c_func
(paren
id|ntfs_inode
op_star
id|dir
comma
id|ntfs_inode
op_star
id|result
comma
r_const
r_char
op_star
id|filename
comma
r_int
id|namelen
comma
id|ntfs_u32
id|flags
)paren
(brace
r_int
id|error
suffix:semicolon
id|ntfs_volume
op_star
id|vol
op_assign
id|dir-&gt;vol
suffix:semicolon
id|ntfs_u8
id|buffer
(braket
l_int|2
)braket
suffix:semicolon
id|ntfs_io
id|io
suffix:semicolon
id|error
op_assign
id|ntfs_new_inode
c_func
(paren
id|vol
comma
op_amp
(paren
id|result-&gt;i_number
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_eq
op_minus
id|ENOSPC
)paren
(brace
id|error
op_assign
id|ntfs_extend_mft
c_func
(paren
id|vol
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
id|error
op_assign
id|ntfs_new_inode
c_func
(paren
id|vol
comma
op_amp
(paren
id|result-&gt;i_number
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|error
)paren
(brace
r_if
c_cond
(paren
id|error
op_eq
op_minus
id|ENOSPC
)paren
id|ntfs_error
c_func
(paren
l_string|&quot;ntfs_get_empty_inode: no free inodes&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/* Get the sequence number. */
id|io.fn_put
op_assign
id|ntfs_put
suffix:semicolon
id|io.fn_get
op_assign
id|ntfs_get
suffix:semicolon
id|io.param
op_assign
id|buffer
suffix:semicolon
id|io.size
op_assign
l_int|2
suffix:semicolon
id|error
op_assign
id|ntfs_read_attr
c_func
(paren
id|vol-&gt;mft_ino
comma
id|vol-&gt;at_data
comma
l_int|0
comma
(paren
(paren
id|__s64
)paren
id|result-&gt;i_number
op_lshift
id|vol-&gt;mft_record_size_bits
)paren
op_plus
l_int|0x10
comma
op_amp
id|io
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
multiline_comment|/* Increment the sequence number skipping zero. */
id|result-&gt;sequence_number
op_assign
(paren
id|NTFS_GETU16
c_func
(paren
id|buffer
)paren
op_plus
l_int|1
)paren
op_amp
l_int|0xffff
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|result-&gt;sequence_number
)paren
id|result-&gt;sequence_number
op_increment
suffix:semicolon
id|result-&gt;vol
op_assign
id|vol
suffix:semicolon
id|result-&gt;attr
op_assign
id|ntfs_malloc
c_func
(paren
id|vol-&gt;mft_record_size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|result-&gt;attr
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|result-&gt;attr_count
op_assign
l_int|0
suffix:semicolon
id|result-&gt;attrs
op_assign
l_int|0
suffix:semicolon
id|result-&gt;record_count
op_assign
l_int|1
suffix:semicolon
id|result-&gt;records
op_assign
id|ntfs_malloc
c_func
(paren
l_int|8
op_star
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|result-&gt;records
)paren
(brace
id|ntfs_free
c_func
(paren
id|result-&gt;attr
)paren
suffix:semicolon
id|result-&gt;attr
op_assign
l_int|0
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|result-&gt;records
(braket
l_int|0
)braket
op_assign
id|result-&gt;i_number
suffix:semicolon
id|error
op_assign
id|add_mft_header
c_func
(paren
id|result
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
id|error
op_assign
id|add_standard_information
c_func
(paren
id|result
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
id|error
op_assign
id|add_filename
c_func
(paren
id|result
comma
id|dir
comma
id|filename
comma
id|namelen
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
id|error
op_assign
id|add_security
c_func
(paren
id|result
comma
id|dir
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ntfs_alloc_file
r_int
id|ntfs_alloc_file
c_func
(paren
id|ntfs_inode
op_star
id|dir
comma
id|ntfs_inode
op_star
id|result
comma
r_char
op_star
id|filename
comma
r_int
id|namelen
)paren
(brace
r_int
id|error
op_assign
id|ntfs_alloc_inode
c_func
(paren
id|dir
comma
id|result
comma
id|filename
comma
id|namelen
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
id|error
op_assign
id|add_data
c_func
(paren
id|result
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
eof
