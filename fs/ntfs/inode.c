multiline_comment|/**&n; * inode.c - NTFS kernel inode handling. Part of the Linux-NTFS project.&n; *&n; * Copyright (c) 2001-2004 Anton Altaparmakov&n; *&n; * This program/include file is free software; you can redistribute it and/or&n; * modify it under the terms of the GNU General Public License as published&n; * by the Free Software Foundation; either version 2 of the License, or&n; * (at your option) any later version.&n; *&n; * This program/include file is distributed in the hope that it will be&n; * useful, but WITHOUT ANY WARRANTY; without even the implied warranty&n; * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; * GNU General Public License for more details.&n; *&n; * You should have received a copy of the GNU General Public License&n; * along with this program (in the main directory of the Linux-NTFS&n; * distribution in the file COPYING); if not, write to the Free Software&n; * Foundation,Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA&n; */
macro_line|#include &lt;linux/pagemap.h&gt;
macro_line|#include &lt;linux/buffer_head.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/quotaops.h&gt;
macro_line|#include &lt;linux/mount.h&gt;
macro_line|#include &quot;aops.h&quot;
macro_line|#include &quot;dir.h&quot;
macro_line|#include &quot;debug.h&quot;
macro_line|#include &quot;inode.h&quot;
macro_line|#include &quot;attrib.h&quot;
macro_line|#include &quot;malloc.h&quot;
macro_line|#include &quot;mft.h&quot;
macro_line|#include &quot;time.h&quot;
macro_line|#include &quot;ntfs.h&quot;
multiline_comment|/**&n; * ntfs_test_inode - compare two (possibly fake) inodes for equality&n; * @vi:&t;&t;vfs inode which to test&n; * @na:&t;&t;ntfs attribute which is being tested with&n; *&n; * Compare the ntfs attribute embedded in the ntfs specific part of the vfs&n; * inode @vi for equality with the ntfs attribute @na.&n; *&n; * If searching for the normal file/directory inode, set @na-&gt;type to AT_UNUSED.&n; * @na-&gt;name and @na-&gt;name_len are then ignored.&n; *&n; * Return 1 if the attributes match and 0 if not.&n; *&n; * NOTE: This function runs with the inode_lock spin lock held so it is not&n; * allowed to sleep.&n; */
DECL|function|ntfs_test_inode
r_int
id|ntfs_test_inode
c_func
(paren
r_struct
id|inode
op_star
id|vi
comma
id|ntfs_attr
op_star
id|na
)paren
(brace
id|ntfs_inode
op_star
id|ni
suffix:semicolon
r_if
c_cond
(paren
id|vi-&gt;i_ino
op_ne
id|na-&gt;mft_no
)paren
r_return
l_int|0
suffix:semicolon
id|ni
op_assign
id|NTFS_I
c_func
(paren
id|vi
)paren
suffix:semicolon
multiline_comment|/* If !NInoAttr(ni), @vi is a normal file or directory inode. */
r_if
c_cond
(paren
id|likely
c_func
(paren
op_logical_neg
id|NInoAttr
c_func
(paren
id|ni
)paren
)paren
)paren
(brace
multiline_comment|/* If not looking for a normal inode this is a mismatch. */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|na-&gt;type
op_ne
id|AT_UNUSED
)paren
)paren
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* A fake inode describing an attribute. */
r_if
c_cond
(paren
id|ni-&gt;type
op_ne
id|na-&gt;type
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ni-&gt;name_len
op_ne
id|na-&gt;name_len
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|na-&gt;name_len
op_logical_and
id|memcmp
c_func
(paren
id|ni-&gt;name
comma
id|na-&gt;name
comma
id|na-&gt;name_len
op_star
r_sizeof
(paren
id|ntfschar
)paren
)paren
)paren
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Match! */
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_init_locked_inode - initialize an inode&n; * @vi:&t;&t;vfs inode to initialize&n; * @na:&t;&t;ntfs attribute which to initialize @vi to&n; *&n; * Initialize the vfs inode @vi with the values from the ntfs attribute @na in&n; * order to enable ntfs_test_inode() to do its work.&n; *&n; * If initializing the normal file/directory inode, set @na-&gt;type to AT_UNUSED.&n; * In that case, @na-&gt;name and @na-&gt;name_len should be set to NULL and 0,&n; * respectively. Although that is not strictly necessary as&n; * ntfs_read_inode_locked() will fill them in later.&n; *&n; * Return 0 on success and -errno on error.&n; *&n; * NOTE: This function runs with the inode_lock spin lock held so it is not&n; * allowed to sleep. (Hence the GFP_ATOMIC allocation.)&n; */
DECL|function|ntfs_init_locked_inode
r_static
r_int
id|ntfs_init_locked_inode
c_func
(paren
r_struct
id|inode
op_star
id|vi
comma
id|ntfs_attr
op_star
id|na
)paren
(brace
id|ntfs_inode
op_star
id|ni
op_assign
id|NTFS_I
c_func
(paren
id|vi
)paren
suffix:semicolon
id|vi-&gt;i_ino
op_assign
id|na-&gt;mft_no
suffix:semicolon
id|ni-&gt;type
op_assign
id|na-&gt;type
suffix:semicolon
r_if
c_cond
(paren
id|na-&gt;type
op_eq
id|AT_INDEX_ALLOCATION
)paren
id|NInoSetMstProtected
c_func
(paren
id|ni
)paren
suffix:semicolon
id|ni-&gt;name
op_assign
id|na-&gt;name
suffix:semicolon
id|ni-&gt;name_len
op_assign
id|na-&gt;name_len
suffix:semicolon
multiline_comment|/* If initializing a normal inode, we are done. */
r_if
c_cond
(paren
id|likely
c_func
(paren
id|na-&gt;type
op_eq
id|AT_UNUSED
)paren
)paren
(brace
id|BUG_ON
c_func
(paren
id|na-&gt;name
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|na-&gt;name_len
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* It is a fake inode. */
id|NInoSetAttr
c_func
(paren
id|ni
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We have I30 global constant as an optimization as it is the name&n;&t; * in &gt;99.9% of named attributes! The other &lt;0.1% incur a GFP_ATOMIC&n;&t; * allocation but that is ok. And most attributes are unnamed anyway,&n;&t; * thus the fraction of named attributes with name != I30 is actually&n;&t; * absolutely tiny.&n;&t; */
r_if
c_cond
(paren
id|na-&gt;name_len
op_logical_and
id|na-&gt;name
op_ne
id|I30
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|na-&gt;name
)paren
suffix:semicolon
id|i
op_assign
id|na-&gt;name_len
op_star
r_sizeof
(paren
id|ntfschar
)paren
suffix:semicolon
id|ni-&gt;name
op_assign
(paren
id|ntfschar
op_star
)paren
id|kmalloc
c_func
(paren
id|i
op_plus
r_sizeof
(paren
id|ntfschar
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ni-&gt;name
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|memcpy
c_func
(paren
id|ni-&gt;name
comma
id|na-&gt;name
comma
id|i
)paren
suffix:semicolon
id|ni-&gt;name
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|typedef|set_t
r_typedef
r_int
(paren
op_star
id|set_t
)paren
(paren
r_struct
id|inode
op_star
comma
r_void
op_star
)paren
suffix:semicolon
r_static
r_int
id|ntfs_read_locked_inode
c_func
(paren
r_struct
id|inode
op_star
id|vi
)paren
suffix:semicolon
r_static
r_int
id|ntfs_read_locked_attr_inode
c_func
(paren
r_struct
id|inode
op_star
id|base_vi
comma
r_struct
id|inode
op_star
id|vi
)paren
suffix:semicolon
r_static
r_int
id|ntfs_read_locked_index_inode
c_func
(paren
r_struct
id|inode
op_star
id|base_vi
comma
r_struct
id|inode
op_star
id|vi
)paren
suffix:semicolon
multiline_comment|/**&n; * ntfs_iget - obtain a struct inode corresponding to a specific normal inode&n; * @sb:&t;&t;super block of mounted volume&n; * @mft_no:&t;mft record number / inode number to obtain&n; *&n; * Obtain the struct inode corresponding to a specific normal inode (i.e. a&n; * file or directory).&n; *&n; * If the inode is in the cache, it is just returned with an increased&n; * reference count. Otherwise, a new struct inode is allocated and initialized,&n; * and finally ntfs_read_locked_inode() is called to read in the inode and&n; * fill in the remainder of the inode structure.&n; *&n; * Return the struct inode on success. Check the return value with IS_ERR() and&n; * if true, the function failed and the error code is obtained from PTR_ERR().&n; */
DECL|function|ntfs_iget
r_struct
id|inode
op_star
id|ntfs_iget
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_int
r_int
id|mft_no
)paren
(brace
r_struct
id|inode
op_star
id|vi
suffix:semicolon
id|ntfs_attr
id|na
suffix:semicolon
r_int
id|err
suffix:semicolon
id|na.mft_no
op_assign
id|mft_no
suffix:semicolon
id|na.type
op_assign
id|AT_UNUSED
suffix:semicolon
id|na.name
op_assign
l_int|NULL
suffix:semicolon
id|na.name_len
op_assign
l_int|0
suffix:semicolon
id|vi
op_assign
id|iget5_locked
c_func
(paren
id|sb
comma
id|mft_no
comma
(paren
id|test_t
)paren
id|ntfs_test_inode
comma
(paren
id|set_t
)paren
id|ntfs_init_locked_inode
comma
op_amp
id|na
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vi
)paren
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* If this is a freshly allocated inode, need to read it now. */
r_if
c_cond
(paren
id|vi-&gt;i_state
op_amp
id|I_NEW
)paren
(brace
id|err
op_assign
id|ntfs_read_locked_inode
c_func
(paren
id|vi
)paren
suffix:semicolon
id|unlock_new_inode
c_func
(paren
id|vi
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * There is no point in keeping bad inodes around if the failure was&n;&t; * due to ENOMEM. We want to be able to retry again later.&n;&t; */
r_if
c_cond
(paren
id|err
op_eq
op_minus
id|ENOMEM
)paren
(brace
id|iput
c_func
(paren
id|vi
)paren
suffix:semicolon
id|vi
op_assign
id|ERR_PTR
c_func
(paren
id|err
)paren
suffix:semicolon
)brace
r_return
id|vi
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_attr_iget - obtain a struct inode corresponding to an attribute&n; * @base_vi:&t;vfs base inode containing the attribute&n; * @type:&t;attribute type&n; * @name:&t;Unicode name of the attribute (NULL if unnamed)&n; * @name_len:&t;length of @name in Unicode characters (0 if unnamed)&n; *&n; * Obtain the (fake) struct inode corresponding to the attribute specified by&n; * @type, @name, and @name_len, which is present in the base mft record&n; * specified by the vfs inode @base_vi.&n; *&n; * If the attribute inode is in the cache, it is just returned with an&n; * increased reference count. Otherwise, a new struct inode is allocated and&n; * initialized, and finally ntfs_read_locked_attr_inode() is called to read the&n; * attribute and fill in the inode structure.&n; *&n; * Note, for index allocation attributes, you need to use ntfs_index_iget()&n; * instead of ntfs_attr_iget() as working with indices is a lot more complex.&n; *&n; * Return the struct inode of the attribute inode on success. Check the return&n; * value with IS_ERR() and if true, the function failed and the error code is&n; * obtained from PTR_ERR().&n; */
DECL|function|ntfs_attr_iget
r_struct
id|inode
op_star
id|ntfs_attr_iget
c_func
(paren
r_struct
id|inode
op_star
id|base_vi
comma
id|ATTR_TYPE
id|type
comma
id|ntfschar
op_star
id|name
comma
id|u32
id|name_len
)paren
(brace
r_struct
id|inode
op_star
id|vi
suffix:semicolon
id|ntfs_attr
id|na
suffix:semicolon
r_int
id|err
suffix:semicolon
multiline_comment|/* Make sure no one calls ntfs_attr_iget() for indices. */
id|BUG_ON
c_func
(paren
id|type
op_eq
id|AT_INDEX_ALLOCATION
)paren
suffix:semicolon
id|na.mft_no
op_assign
id|base_vi-&gt;i_ino
suffix:semicolon
id|na.type
op_assign
id|type
suffix:semicolon
id|na.name
op_assign
id|name
suffix:semicolon
id|na.name_len
op_assign
id|name_len
suffix:semicolon
id|vi
op_assign
id|iget5_locked
c_func
(paren
id|base_vi-&gt;i_sb
comma
id|na.mft_no
comma
(paren
id|test_t
)paren
id|ntfs_test_inode
comma
(paren
id|set_t
)paren
id|ntfs_init_locked_inode
comma
op_amp
id|na
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vi
)paren
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* If this is a freshly allocated inode, need to read it now. */
r_if
c_cond
(paren
id|vi-&gt;i_state
op_amp
id|I_NEW
)paren
(brace
id|err
op_assign
id|ntfs_read_locked_attr_inode
c_func
(paren
id|base_vi
comma
id|vi
)paren
suffix:semicolon
id|unlock_new_inode
c_func
(paren
id|vi
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * There is no point in keeping bad attribute inodes around. This also&n;&t; * simplifies things in that we never need to check for bad attribute&n;&t; * inodes elsewhere.&n;&t; */
r_if
c_cond
(paren
id|err
)paren
(brace
id|iput
c_func
(paren
id|vi
)paren
suffix:semicolon
id|vi
op_assign
id|ERR_PTR
c_func
(paren
id|err
)paren
suffix:semicolon
)brace
r_return
id|vi
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_index_iget - obtain a struct inode corresponding to an index&n; * @base_vi:&t;vfs base inode containing the index related attributes&n; * @name:&t;Unicode name of the index&n; * @name_len:&t;length of @name in Unicode characters&n; *&n; * Obtain the (fake) struct inode corresponding to the index specified by @name&n; * and @name_len, which is present in the base mft record specified by the vfs&n; * inode @base_vi.&n; *&n; * If the index inode is in the cache, it is just returned with an increased&n; * reference count.  Otherwise, a new struct inode is allocated and&n; * initialized, and finally ntfs_read_locked_index_inode() is called to read&n; * the index related attributes and fill in the inode structure.&n; *&n; * Return the struct inode of the index inode on success. Check the return&n; * value with IS_ERR() and if true, the function failed and the error code is&n; * obtained from PTR_ERR().&n; */
DECL|function|ntfs_index_iget
r_struct
id|inode
op_star
id|ntfs_index_iget
c_func
(paren
r_struct
id|inode
op_star
id|base_vi
comma
id|ntfschar
op_star
id|name
comma
id|u32
id|name_len
)paren
(brace
r_struct
id|inode
op_star
id|vi
suffix:semicolon
id|ntfs_attr
id|na
suffix:semicolon
r_int
id|err
suffix:semicolon
id|na.mft_no
op_assign
id|base_vi-&gt;i_ino
suffix:semicolon
id|na.type
op_assign
id|AT_INDEX_ALLOCATION
suffix:semicolon
id|na.name
op_assign
id|name
suffix:semicolon
id|na.name_len
op_assign
id|name_len
suffix:semicolon
id|vi
op_assign
id|iget5_locked
c_func
(paren
id|base_vi-&gt;i_sb
comma
id|na.mft_no
comma
(paren
id|test_t
)paren
id|ntfs_test_inode
comma
(paren
id|set_t
)paren
id|ntfs_init_locked_inode
comma
op_amp
id|na
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vi
)paren
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* If this is a freshly allocated inode, need to read it now. */
r_if
c_cond
(paren
id|vi-&gt;i_state
op_amp
id|I_NEW
)paren
(brace
id|err
op_assign
id|ntfs_read_locked_index_inode
c_func
(paren
id|base_vi
comma
id|vi
)paren
suffix:semicolon
id|unlock_new_inode
c_func
(paren
id|vi
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * There is no point in keeping bad index inodes around.  This also&n;&t; * simplifies things in that we never need to check for bad index&n;&t; * inodes elsewhere.&n;&t; */
r_if
c_cond
(paren
id|err
)paren
(brace
id|iput
c_func
(paren
id|vi
)paren
suffix:semicolon
id|vi
op_assign
id|ERR_PTR
c_func
(paren
id|err
)paren
suffix:semicolon
)brace
r_return
id|vi
suffix:semicolon
)brace
DECL|function|ntfs_alloc_big_inode
r_struct
id|inode
op_star
id|ntfs_alloc_big_inode
c_func
(paren
r_struct
id|super_block
op_star
id|sb
)paren
(brace
id|ntfs_inode
op_star
id|ni
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Entering.&quot;
)paren
suffix:semicolon
id|ni
op_assign
(paren
id|ntfs_inode
op_star
)paren
id|kmem_cache_alloc
c_func
(paren
id|ntfs_big_inode_cache
comma
id|SLAB_NOFS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
id|ni
op_ne
l_int|NULL
)paren
)paren
(brace
id|ni-&gt;state
op_assign
l_int|0
suffix:semicolon
r_return
id|VFS_I
c_func
(paren
id|ni
)paren
suffix:semicolon
)brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Allocation of NTFS big inode structure failed.&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|ntfs_destroy_big_inode
r_void
id|ntfs_destroy_big_inode
c_func
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
id|ntfs_inode
op_star
id|ni
op_assign
id|NTFS_I
c_func
(paren
id|inode
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Entering.&quot;
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|ni-&gt;page
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|atomic_dec_and_test
c_func
(paren
op_amp
id|ni-&gt;count
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|kmem_cache_free
c_func
(paren
id|ntfs_big_inode_cache
comma
id|NTFS_I
c_func
(paren
id|inode
)paren
)paren
suffix:semicolon
)brace
DECL|function|ntfs_alloc_extent_inode
r_static
r_inline
id|ntfs_inode
op_star
id|ntfs_alloc_extent_inode
c_func
(paren
r_void
)paren
(brace
id|ntfs_inode
op_star
id|ni
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Entering.&quot;
)paren
suffix:semicolon
id|ni
op_assign
(paren
id|ntfs_inode
op_star
)paren
id|kmem_cache_alloc
c_func
(paren
id|ntfs_inode_cache
comma
id|SLAB_NOFS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
id|ni
op_ne
l_int|NULL
)paren
)paren
(brace
id|ni-&gt;state
op_assign
l_int|0
suffix:semicolon
r_return
id|ni
suffix:semicolon
)brace
id|ntfs_error
c_func
(paren
l_int|NULL
comma
l_string|&quot;Allocation of NTFS inode structure failed.&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|ntfs_destroy_extent_inode
r_static
r_void
id|ntfs_destroy_extent_inode
c_func
(paren
id|ntfs_inode
op_star
id|ni
)paren
(brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Entering.&quot;
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|ni-&gt;page
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|atomic_dec_and_test
c_func
(paren
op_amp
id|ni-&gt;count
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|kmem_cache_free
c_func
(paren
id|ntfs_inode_cache
comma
id|ni
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * __ntfs_init_inode - initialize ntfs specific part of an inode&n; * @sb:&t;&t;super block of mounted volume&n; * @ni:&t;&t;freshly allocated ntfs inode which to initialize&n; *&n; * Initialize an ntfs inode to defaults.&n; *&n; * NOTE: ni-&gt;mft_no, ni-&gt;state, ni-&gt;type, ni-&gt;name, and ni-&gt;name_len are left&n; * untouched. Make sure to initialize them elsewhere.&n; *&n; * Return zero on success and -ENOMEM on error.&n; */
DECL|function|__ntfs_init_inode
r_void
id|__ntfs_init_inode
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
id|ntfs_inode
op_star
id|ni
)paren
(brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Entering.&quot;
)paren
suffix:semicolon
id|ni-&gt;initialized_size
op_assign
id|ni-&gt;allocated_size
op_assign
l_int|0
suffix:semicolon
id|ni-&gt;seq_no
op_assign
l_int|0
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|ni-&gt;count
comma
l_int|1
)paren
suffix:semicolon
id|ni-&gt;vol
op_assign
id|NTFS_SB
c_func
(paren
id|sb
)paren
suffix:semicolon
id|ntfs_init_runlist
c_func
(paren
op_amp
id|ni-&gt;runlist
)paren
suffix:semicolon
id|init_MUTEX
c_func
(paren
op_amp
id|ni-&gt;mrec_lock
)paren
suffix:semicolon
id|ni-&gt;page
op_assign
l_int|NULL
suffix:semicolon
id|ni-&gt;page_ofs
op_assign
l_int|0
suffix:semicolon
id|ni-&gt;attr_list_size
op_assign
l_int|0
suffix:semicolon
id|ni-&gt;attr_list
op_assign
l_int|NULL
suffix:semicolon
id|ntfs_init_runlist
c_func
(paren
op_amp
id|ni-&gt;attr_list_rl
)paren
suffix:semicolon
id|ni-&gt;itype.index.bmp_ino
op_assign
l_int|NULL
suffix:semicolon
id|ni-&gt;itype.index.block_size
op_assign
l_int|0
suffix:semicolon
id|ni-&gt;itype.index.vcn_size
op_assign
l_int|0
suffix:semicolon
id|ni-&gt;itype.index.collation_rule
op_assign
l_int|0
suffix:semicolon
id|ni-&gt;itype.index.block_size_bits
op_assign
l_int|0
suffix:semicolon
id|ni-&gt;itype.index.vcn_size_bits
op_assign
l_int|0
suffix:semicolon
id|init_MUTEX
c_func
(paren
op_amp
id|ni-&gt;extent_lock
)paren
suffix:semicolon
id|ni-&gt;nr_extents
op_assign
l_int|0
suffix:semicolon
id|ni-&gt;ext.base_ntfs_ino
op_assign
l_int|NULL
suffix:semicolon
)brace
DECL|function|ntfs_new_extent_inode
r_inline
id|ntfs_inode
op_star
id|ntfs_new_extent_inode
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_int
r_int
id|mft_no
)paren
(brace
id|ntfs_inode
op_star
id|ni
op_assign
id|ntfs_alloc_extent_inode
c_func
(paren
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Entering.&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
id|ni
op_ne
l_int|NULL
)paren
)paren
(brace
id|__ntfs_init_inode
c_func
(paren
id|sb
comma
id|ni
)paren
suffix:semicolon
id|ni-&gt;mft_no
op_assign
id|mft_no
suffix:semicolon
id|ni-&gt;type
op_assign
id|AT_UNUSED
suffix:semicolon
id|ni-&gt;name
op_assign
l_int|NULL
suffix:semicolon
id|ni-&gt;name_len
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|ni
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_is_extended_system_file - check if a file is in the $Extend directory&n; * @ctx:&t;initialized attribute search context&n; *&n; * Search all file name attributes in the inode described by the attribute&n; * search context @ctx and check if any of the names are in the $Extend system&n; * directory.&n; *&n; * Return values:&n; *&t;   1: file is in $Extend directory&n; *&t;   0: file is not in $Extend directory&n; *    -errno: failed to determine if the file is in the $Extend directory&n; */
DECL|function|ntfs_is_extended_system_file
r_static
r_int
id|ntfs_is_extended_system_file
c_func
(paren
id|ntfs_attr_search_ctx
op_star
id|ctx
)paren
(brace
r_int
id|nr_links
comma
id|err
suffix:semicolon
multiline_comment|/* Restart search. */
id|ntfs_attr_reinit_search_ctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
multiline_comment|/* Get number of hard links. */
id|nr_links
op_assign
id|le16_to_cpu
c_func
(paren
id|ctx-&gt;mrec-&gt;link_count
)paren
suffix:semicolon
multiline_comment|/* Loop through all hard links. */
r_while
c_loop
(paren
op_logical_neg
(paren
id|err
op_assign
id|ntfs_attr_lookup
c_func
(paren
id|AT_FILE_NAME
comma
l_int|NULL
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|NULL
comma
l_int|0
comma
id|ctx
)paren
)paren
)paren
(brace
id|FILE_NAME_ATTR
op_star
id|file_name_attr
suffix:semicolon
id|ATTR_RECORD
op_star
id|attr
op_assign
id|ctx-&gt;attr
suffix:semicolon
id|u8
op_star
id|p
comma
op_star
id|p2
suffix:semicolon
id|nr_links
op_decrement
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Maximum sanity checking as we are called on an inode that&n;&t;&t; * we suspect might be corrupt.&n;&t;&t; */
id|p
op_assign
(paren
id|u8
op_star
)paren
id|attr
op_plus
id|le32_to_cpu
c_func
(paren
id|attr-&gt;length
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
template_param
(paren
id|u8
op_star
)paren
id|ctx-&gt;mrec
op_plus
id|le32_to_cpu
c_func
(paren
id|ctx-&gt;mrec-&gt;bytes_in_use
)paren
)paren
(brace
id|err_corrupt_attr
suffix:colon
id|ntfs_error
c_func
(paren
id|ctx-&gt;ntfs_ino-&gt;vol-&gt;sb
comma
l_string|&quot;Corrupt file name &quot;
l_string|&quot;attribute. You should run chkdsk.&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_if
c_cond
(paren
id|attr-&gt;non_resident
)paren
(brace
id|ntfs_error
c_func
(paren
id|ctx-&gt;ntfs_ino-&gt;vol-&gt;sb
comma
l_string|&quot;Non-resident file &quot;
l_string|&quot;name. You should run chkdsk.&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_if
c_cond
(paren
id|attr-&gt;flags
)paren
(brace
id|ntfs_error
c_func
(paren
id|ctx-&gt;ntfs_ino-&gt;vol-&gt;sb
comma
l_string|&quot;File name with &quot;
l_string|&quot;invalid flags. You should run &quot;
l_string|&quot;chkdsk.&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|attr-&gt;data.resident.flags
op_amp
id|RESIDENT_ATTR_IS_INDEXED
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|ctx-&gt;ntfs_ino-&gt;vol-&gt;sb
comma
l_string|&quot;Unindexed file &quot;
l_string|&quot;name. You should run chkdsk.&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|file_name_attr
op_assign
(paren
id|FILE_NAME_ATTR
op_star
)paren
(paren
(paren
id|u8
op_star
)paren
id|attr
op_plus
id|le16_to_cpu
c_func
(paren
id|attr-&gt;data.resident.value_offset
)paren
)paren
suffix:semicolon
id|p2
op_assign
(paren
id|u8
op_star
)paren
id|attr
op_plus
id|le32_to_cpu
c_func
(paren
id|attr-&gt;data.resident.value_length
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p2
template_param
id|p
)paren
r_goto
id|err_corrupt_attr
suffix:semicolon
multiline_comment|/* This attribute is ok, but is it in the $Extend directory? */
r_if
c_cond
(paren
id|MREF_LE
c_func
(paren
id|file_name_attr-&gt;parent_directory
)paren
op_eq
id|FILE_Extend
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* YES, it&squot;s an extended system file. */
)brace
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|err
op_ne
op_minus
id|ENOENT
)paren
)paren
r_return
id|err
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|nr_links
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|ctx-&gt;ntfs_ino-&gt;vol-&gt;sb
comma
l_string|&quot;Inode hard link count &quot;
l_string|&quot;doesn&squot;t match number of name attributes. You &quot;
l_string|&quot;should run chkdsk.&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
multiline_comment|/* NO, it is not an extended system file. */
)brace
multiline_comment|/**&n; * ntfs_read_locked_inode - read an inode from its device&n; * @vi:&t;&t;inode to read&n; *&n; * ntfs_read_locked_inode() is called from ntfs_iget() to read the inode&n; * described by @vi into memory from the device.&n; *&n; * The only fields in @vi that we need to/can look at when the function is&n; * called are i_sb, pointing to the mounted device&squot;s super block, and i_ino,&n; * the number of the inode to load.&n; *&n; * ntfs_read_locked_inode() maps, pins and locks the mft record number i_ino&n; * for reading and sets up the necessary @vi fields as well as initializing&n; * the ntfs inode.&n; *&n; * Q: What locks are held when the function is called?&n; * A: i_state has I_LOCK set, hence the inode is locked, also&n; *    i_count is set to 1, so it is not going to go away&n; *    i_flags is set to 0 and we have no business touching it.  Only an ioctl()&n; *    is allowed to write to them. We should of course be honouring them but&n; *    we need to do that using the IS_* macros defined in include/linux/fs.h.&n; *    In any case ntfs_read_locked_inode() has nothing to do with i_flags.&n; *&n; * Return 0 on success and -errno on error.  In the error case, the inode will&n; * have had make_bad_inode() executed on it.&n; */
DECL|function|ntfs_read_locked_inode
r_static
r_int
id|ntfs_read_locked_inode
c_func
(paren
r_struct
id|inode
op_star
id|vi
)paren
(brace
id|ntfs_volume
op_star
id|vol
op_assign
id|NTFS_SB
c_func
(paren
id|vi-&gt;i_sb
)paren
suffix:semicolon
id|ntfs_inode
op_star
id|ni
suffix:semicolon
id|MFT_RECORD
op_star
id|m
suffix:semicolon
id|STANDARD_INFORMATION
op_star
id|si
suffix:semicolon
id|ntfs_attr_search_ctx
op_star
id|ctx
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Entering for i_ino 0x%lx.&quot;
comma
id|vi-&gt;i_ino
)paren
suffix:semicolon
multiline_comment|/* Setup the generic vfs inode parts now. */
multiline_comment|/* This is the optimal IO size (for stat), not the fs block size. */
id|vi-&gt;i_blksize
op_assign
id|PAGE_CACHE_SIZE
suffix:semicolon
multiline_comment|/*&n;&t; * This is for checking whether an inode has changed w.r.t. a file so&n;&t; * that the file can be updated if necessary (compare with f_version).&n;&t; */
id|vi-&gt;i_version
op_assign
l_int|1
suffix:semicolon
id|vi-&gt;i_uid
op_assign
id|vol-&gt;uid
suffix:semicolon
id|vi-&gt;i_gid
op_assign
id|vol-&gt;gid
suffix:semicolon
id|vi-&gt;i_mode
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Initialize the ntfs specific part of @vi special casing&n;&t; * FILE_MFT which we need to do at mount time.&n;&t; */
r_if
c_cond
(paren
id|vi-&gt;i_ino
op_ne
id|FILE_MFT
)paren
id|ntfs_init_big_inode
c_func
(paren
id|vi
)paren
suffix:semicolon
id|ni
op_assign
id|NTFS_I
c_func
(paren
id|vi
)paren
suffix:semicolon
id|m
op_assign
id|map_mft_record
c_func
(paren
id|ni
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|m
)paren
)paren
(brace
id|err
op_assign
id|PTR_ERR
c_func
(paren
id|m
)paren
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
id|ctx
op_assign
id|ntfs_attr_get_search_ctx
c_func
(paren
id|ni
comma
id|m
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ctx
)paren
(brace
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|m-&gt;flags
op_amp
id|MFT_RECORD_IN_USE
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Inode is not in use!&quot;
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|m-&gt;base_mft_record
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Inode is an extent inode!&quot;
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
multiline_comment|/* Transfer information from mft record into vfs and ntfs inodes. */
id|vi-&gt;i_generation
op_assign
id|ni-&gt;seq_no
op_assign
id|le16_to_cpu
c_func
(paren
id|m-&gt;sequence_number
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * FIXME: Keep in mind that link_count is two for files which have both&n;&t; * a long file name and a short file name as separate entries, so if&n;&t; * we are hiding short file names this will be too high. Either we need&n;&t; * to account for the short file names by subtracting them or we need&n;&t; * to make sure we delete files even though i_nlink is not zero which&n;&t; * might be tricky due to vfs interactions. Need to think about this&n;&t; * some more when implementing the unlink command.&n;&t; */
id|vi-&gt;i_nlink
op_assign
id|le16_to_cpu
c_func
(paren
id|m-&gt;link_count
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * FIXME: Reparse points can have the directory bit set even though&n;&t; * they would be S_IFLNK. Need to deal with this further below when we&n;&t; * implement reparse points / symbolic links but it will do for now.&n;&t; * Also if not a directory, it could be something else, rather than&n;&t; * a regular file. But again, will do for now.&n;&t; */
multiline_comment|/* Everyone gets all permissions. */
id|vi-&gt;i_mode
op_or_assign
id|S_IRWXUGO
suffix:semicolon
multiline_comment|/* If read-only, noone gets write permissions. */
r_if
c_cond
(paren
id|IS_RDONLY
c_func
(paren
id|vi
)paren
)paren
id|vi-&gt;i_mode
op_and_assign
op_complement
id|S_IWUGO
suffix:semicolon
r_if
c_cond
(paren
id|m-&gt;flags
op_amp
id|MFT_RECORD_IS_DIRECTORY
)paren
(brace
id|vi-&gt;i_mode
op_or_assign
id|S_IFDIR
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Apply the directory permissions mask set in the mount&n;&t;&t; * options.&n;&t;&t; */
id|vi-&gt;i_mode
op_and_assign
op_complement
id|vol-&gt;dmask
suffix:semicolon
multiline_comment|/* Things break without this kludge! */
r_if
c_cond
(paren
id|vi-&gt;i_nlink
OG
l_int|1
)paren
id|vi-&gt;i_nlink
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|vi-&gt;i_mode
op_or_assign
id|S_IFREG
suffix:semicolon
multiline_comment|/* Apply the file permissions mask set in the mount options. */
id|vi-&gt;i_mode
op_and_assign
op_complement
id|vol-&gt;fmask
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Find the standard information attribute in the mft record. At this&n;&t; * stage we haven&squot;t setup the attribute list stuff yet, so this could&n;&t; * in fact fail if the standard information is in an extent record, but&n;&t; * I don&squot;t think this actually ever happens.&n;&t; */
id|err
op_assign
id|ntfs_attr_lookup
c_func
(paren
id|AT_STANDARD_INFORMATION
comma
l_int|NULL
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|NULL
comma
l_int|0
comma
id|ctx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|err
)paren
)paren
(brace
r_if
c_cond
(paren
id|err
op_eq
op_minus
id|ENOENT
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * TODO: We should be performing a hot fix here (if the&n;&t;&t;&t; * recover mount option is set) by creating a new&n;&t;&t;&t; * attribute.&n;&t;&t;&t; */
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;$STANDARD_INFORMATION attribute &quot;
l_string|&quot;is missing.&quot;
)paren
suffix:semicolon
)brace
r_goto
id|unm_err_out
suffix:semicolon
)brace
multiline_comment|/* Get the standard information attribute value. */
id|si
op_assign
(paren
id|STANDARD_INFORMATION
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|ctx-&gt;attr
op_plus
id|le16_to_cpu
c_func
(paren
id|ctx-&gt;attr-&gt;data.resident.value_offset
)paren
)paren
suffix:semicolon
multiline_comment|/* Transfer information from the standard information into vi. */
multiline_comment|/*&n;&t; * Note: The i_?times do not quite map perfectly onto the NTFS times,&n;&t; * but they are close enough, and in the end it doesn&squot;t really matter&n;&t; * that much...&n;&t; */
multiline_comment|/*&n;&t; * mtime is the last change of the data within the file. Not changed&n;&t; * when only metadata is changed, e.g. a rename doesn&squot;t affect mtime.&n;&t; */
id|vi-&gt;i_mtime
op_assign
id|ntfs2utc
c_func
(paren
id|si-&gt;last_data_change_time
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * ctime is the last change of the metadata of the file. This obviously&n;&t; * always changes, when mtime is changed. ctime can be changed on its&n;&t; * own, mtime is then not changed, e.g. when a file is renamed.&n;&t; */
id|vi-&gt;i_ctime
op_assign
id|ntfs2utc
c_func
(paren
id|si-&gt;last_mft_change_time
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Last access to the data within the file. Not changed during a rename&n;&t; * for example but changed whenever the file is written to.&n;&t; */
id|vi-&gt;i_atime
op_assign
id|ntfs2utc
c_func
(paren
id|si-&gt;last_access_time
)paren
suffix:semicolon
multiline_comment|/* Find the attribute list attribute if present. */
id|ntfs_attr_reinit_search_ctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
id|err
op_assign
id|ntfs_attr_lookup
c_func
(paren
id|AT_ATTRIBUTE_LIST
comma
l_int|NULL
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|NULL
comma
l_int|0
comma
id|ctx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|err
op_ne
op_minus
id|ENOENT
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Failed to lookup attribute list &quot;
l_string|&quot;attribute.&quot;
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
)brace
r_else
multiline_comment|/* if (!err) */
(brace
r_if
c_cond
(paren
id|vi-&gt;i_ino
op_eq
id|FILE_MFT
)paren
r_goto
id|skip_attr_list_load
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Attribute list found in inode 0x%lx.&quot;
comma
id|vi-&gt;i_ino
)paren
suffix:semicolon
id|NInoSetAttrList
c_func
(paren
id|ni
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ctx-&gt;attr-&gt;flags
op_amp
id|ATTR_IS_ENCRYPTED
op_logical_or
id|ctx-&gt;attr-&gt;flags
op_amp
id|ATTR_COMPRESSION_MASK
op_logical_or
id|ctx-&gt;attr-&gt;flags
op_amp
id|ATTR_IS_SPARSE
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Attribute list attribute is &quot;
l_string|&quot;compressed/encrypted/sparse.&quot;
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
multiline_comment|/* Now allocate memory for the attribute list. */
id|ni-&gt;attr_list_size
op_assign
(paren
id|u32
)paren
id|ntfs_attr_size
c_func
(paren
id|ctx-&gt;attr
)paren
suffix:semicolon
id|ni-&gt;attr_list
op_assign
id|ntfs_malloc_nofs
c_func
(paren
id|ni-&gt;attr_list_size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ni-&gt;attr_list
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Not enough memory to allocate &quot;
l_string|&quot;buffer for attribute list.&quot;
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ctx-&gt;attr-&gt;non_resident
)paren
(brace
id|NInoSetAttrListNonResident
c_func
(paren
id|ni
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ctx-&gt;attr-&gt;data.non_resident.lowest_vcn
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Attribute list has non &quot;
l_string|&quot;zero lowest_vcn.&quot;
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * Setup the runlist. No need for locking as we have&n;&t;&t;&t; * exclusive access to the inode at this time.&n;&t;&t;&t; */
id|ni-&gt;attr_list_rl.rl
op_assign
id|ntfs_mapping_pairs_decompress
c_func
(paren
id|vol
comma
id|ctx-&gt;attr
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|ni-&gt;attr_list_rl.rl
)paren
)paren
(brace
id|err
op_assign
id|PTR_ERR
c_func
(paren
id|ni-&gt;attr_list_rl.rl
)paren
suffix:semicolon
id|ni-&gt;attr_list_rl.rl
op_assign
l_int|NULL
suffix:semicolon
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Mapping pairs &quot;
l_string|&quot;decompression failed.&quot;
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
multiline_comment|/* Now load the attribute list. */
r_if
c_cond
(paren
(paren
id|err
op_assign
id|load_attribute_list
c_func
(paren
id|vol
comma
op_amp
id|ni-&gt;attr_list_rl
comma
id|ni-&gt;attr_list
comma
id|ni-&gt;attr_list_size
comma
id|sle64_to_cpu
c_func
(paren
id|ctx-&gt;attr-&gt;data
dot
id|non_resident.initialized_size
)paren
)paren
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Failed to load &quot;
l_string|&quot;attribute list attribute.&quot;
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
)brace
r_else
multiline_comment|/* if (!ctx.attr-&gt;non_resident) */
(brace
r_if
c_cond
(paren
(paren
id|u8
op_star
)paren
id|ctx-&gt;attr
op_plus
id|le16_to_cpu
c_func
(paren
id|ctx-&gt;attr-&gt;data.resident.value_offset
)paren
op_plus
id|le32_to_cpu
c_func
(paren
id|ctx-&gt;attr-&gt;data.resident.value_length
)paren
OG
(paren
id|u8
op_star
)paren
id|ctx-&gt;mrec
op_plus
id|vol-&gt;mft_record_size
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Corrupt attribute list &quot;
l_string|&quot;in inode.&quot;
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
multiline_comment|/* Now copy the attribute list. */
id|memcpy
c_func
(paren
id|ni-&gt;attr_list
comma
(paren
id|u8
op_star
)paren
id|ctx-&gt;attr
op_plus
id|le16_to_cpu
c_func
(paren
id|ctx-&gt;attr-&gt;data.resident.value_offset
)paren
comma
id|le32_to_cpu
c_func
(paren
id|ctx-&gt;attr-&gt;data.resident.value_length
)paren
)paren
suffix:semicolon
)brace
)brace
id|skip_attr_list_load
suffix:colon
multiline_comment|/*&n;&t; * If an attribute list is present we now have the attribute list value&n;&t; * in ntfs_ino-&gt;attr_list and it is ntfs_ino-&gt;attr_list_size bytes.&n;&t; */
r_if
c_cond
(paren
id|S_ISDIR
c_func
(paren
id|vi-&gt;i_mode
)paren
)paren
(brace
r_struct
id|inode
op_star
id|bvi
suffix:semicolon
id|ntfs_inode
op_star
id|bni
suffix:semicolon
id|INDEX_ROOT
op_star
id|ir
suffix:semicolon
r_char
op_star
id|ir_end
comma
op_star
id|index_end
suffix:semicolon
multiline_comment|/* It is a directory, find index root attribute. */
id|ntfs_attr_reinit_search_ctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
id|err
op_assign
id|ntfs_attr_lookup
c_func
(paren
id|AT_INDEX_ROOT
comma
id|I30
comma
l_int|4
comma
id|CASE_SENSITIVE
comma
l_int|0
comma
l_int|NULL
comma
l_int|0
comma
id|ctx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|err
)paren
)paren
(brace
r_if
c_cond
(paren
id|err
op_eq
op_minus
id|ENOENT
)paren
(brace
singleline_comment|// FIXME: File is corrupt! Hot-fix with empty
singleline_comment|// index root attribute if recovery option is
singleline_comment|// set.
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;$INDEX_ROOT attribute &quot;
l_string|&quot;is missing.&quot;
)paren
suffix:semicolon
)brace
r_goto
id|unm_err_out
suffix:semicolon
)brace
multiline_comment|/* Set up the state. */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|ctx-&gt;attr-&gt;non_resident
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;$INDEX_ROOT attribute is not &quot;
l_string|&quot;resident.&quot;
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
multiline_comment|/* Ensure the attribute name is placed before the value. */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|ctx-&gt;attr-&gt;name_length
op_logical_and
(paren
id|le16_to_cpu
c_func
(paren
id|ctx-&gt;attr-&gt;name_offset
)paren
op_ge
id|le16_to_cpu
c_func
(paren
id|ctx-&gt;attr-&gt;data.resident
dot
id|value_offset
)paren
)paren
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;$INDEX_ROOT attribute name is &quot;
l_string|&quot;placed after the attribute value.&quot;
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Compressed/encrypted index root just means that the newly&n;&t;&t; * created files in that directory should be created compressed/&n;&t;&t; * encrypted. However index root cannot be both compressed and&n;&t;&t; * encrypted.&n;&t;&t; */
r_if
c_cond
(paren
id|ctx-&gt;attr-&gt;flags
op_amp
id|ATTR_COMPRESSION_MASK
)paren
id|NInoSetCompressed
c_func
(paren
id|ni
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ctx-&gt;attr-&gt;flags
op_amp
id|ATTR_IS_ENCRYPTED
)paren
(brace
r_if
c_cond
(paren
id|ctx-&gt;attr-&gt;flags
op_amp
id|ATTR_COMPRESSION_MASK
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Found encrypted and &quot;
l_string|&quot;compressed attribute.&quot;
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
id|NInoSetEncrypted
c_func
(paren
id|ni
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ctx-&gt;attr-&gt;flags
op_amp
id|ATTR_IS_SPARSE
)paren
id|NInoSetSparse
c_func
(paren
id|ni
)paren
suffix:semicolon
id|ir
op_assign
(paren
id|INDEX_ROOT
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|ctx-&gt;attr
op_plus
id|le16_to_cpu
c_func
(paren
id|ctx-&gt;attr-&gt;data.resident.value_offset
)paren
)paren
suffix:semicolon
id|ir_end
op_assign
(paren
r_char
op_star
)paren
id|ir
op_plus
id|le32_to_cpu
c_func
(paren
id|ctx-&gt;attr-&gt;data.resident.value_length
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ir_end
OG
(paren
r_char
op_star
)paren
id|ctx-&gt;mrec
op_plus
id|vol-&gt;mft_record_size
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;$INDEX_ROOT attribute is &quot;
l_string|&quot;corrupt.&quot;
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
id|index_end
op_assign
(paren
r_char
op_star
)paren
op_amp
id|ir-&gt;index
op_plus
id|le32_to_cpu
c_func
(paren
id|ir-&gt;index.index_length
)paren
suffix:semicolon
r_if
c_cond
(paren
id|index_end
OG
id|ir_end
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Directory index is corrupt.&quot;
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ir-&gt;type
op_ne
id|AT_FILE_NAME
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Indexed attribute is not &quot;
l_string|&quot;$FILE_NAME.&quot;
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ir-&gt;collation_rule
op_ne
id|COLLATION_FILE_NAME
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Index collation rule is not &quot;
l_string|&quot;COLLATION_FILE_NAME.&quot;
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
id|ni-&gt;itype.index.collation_rule
op_assign
id|ir-&gt;collation_rule
suffix:semicolon
id|ni-&gt;itype.index.block_size
op_assign
id|le32_to_cpu
c_func
(paren
id|ir-&gt;index_block_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ni-&gt;itype.index.block_size
op_amp
(paren
id|ni-&gt;itype.index.block_size
op_minus
l_int|1
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Index block size (%u) is not a &quot;
l_string|&quot;power of two.&quot;
comma
id|ni-&gt;itype.index.block_size
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ni-&gt;itype.index.block_size
OG
id|PAGE_CACHE_SIZE
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Index block size (%u) &gt; &quot;
l_string|&quot;PAGE_CACHE_SIZE (%ld) is not &quot;
l_string|&quot;supported.  Sorry.&quot;
comma
id|ni-&gt;itype.index.block_size
comma
id|PAGE_CACHE_SIZE
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EOPNOTSUPP
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ni-&gt;itype.index.block_size
OL
id|NTFS_BLOCK_SIZE
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Index block size (%u) &lt; &quot;
l_string|&quot;NTFS_BLOCK_SIZE (%i) is not &quot;
l_string|&quot;supported.  Sorry.&quot;
comma
id|ni-&gt;itype.index.block_size
comma
id|NTFS_BLOCK_SIZE
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EOPNOTSUPP
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
id|ni-&gt;itype.index.block_size_bits
op_assign
id|ffs
c_func
(paren
id|ni-&gt;itype.index.block_size
)paren
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* Determine the size of a vcn in the directory index. */
r_if
c_cond
(paren
id|vol-&gt;cluster_size
op_le
id|ni-&gt;itype.index.block_size
)paren
(brace
id|ni-&gt;itype.index.vcn_size
op_assign
id|vol-&gt;cluster_size
suffix:semicolon
id|ni-&gt;itype.index.vcn_size_bits
op_assign
id|vol-&gt;cluster_size_bits
suffix:semicolon
)brace
r_else
(brace
id|ni-&gt;itype.index.vcn_size
op_assign
id|vol-&gt;sector_size
suffix:semicolon
id|ni-&gt;itype.index.vcn_size_bits
op_assign
id|vol-&gt;sector_size_bits
suffix:semicolon
)brace
multiline_comment|/* Setup the index allocation attribute, even if not present. */
id|NInoSetMstProtected
c_func
(paren
id|ni
)paren
suffix:semicolon
id|ni-&gt;type
op_assign
id|AT_INDEX_ALLOCATION
suffix:semicolon
id|ni-&gt;name
op_assign
id|I30
suffix:semicolon
id|ni-&gt;name_len
op_assign
l_int|4
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|ir-&gt;index.flags
op_amp
id|LARGE_INDEX
)paren
)paren
(brace
multiline_comment|/* No index allocation. */
id|vi-&gt;i_size
op_assign
id|ni-&gt;initialized_size
op_assign
id|ni-&gt;allocated_size
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* We are done with the mft record, so we release it. */
id|ntfs_attr_put_search_ctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
id|unmap_mft_record
c_func
(paren
id|ni
)paren
suffix:semicolon
id|m
op_assign
l_int|NULL
suffix:semicolon
id|ctx
op_assign
l_int|NULL
suffix:semicolon
r_goto
id|skip_large_dir_stuff
suffix:semicolon
)brace
multiline_comment|/* LARGE_INDEX: Index allocation present. Setup state. */
id|NInoSetIndexAllocPresent
c_func
(paren
id|ni
)paren
suffix:semicolon
multiline_comment|/* Find index allocation attribute. */
id|ntfs_attr_reinit_search_ctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
id|err
op_assign
id|ntfs_attr_lookup
c_func
(paren
id|AT_INDEX_ALLOCATION
comma
id|I30
comma
l_int|4
comma
id|CASE_SENSITIVE
comma
l_int|0
comma
l_int|NULL
comma
l_int|0
comma
id|ctx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|err
)paren
)paren
(brace
r_if
c_cond
(paren
id|err
op_eq
op_minus
id|ENOENT
)paren
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;$INDEX_ALLOCATION &quot;
l_string|&quot;attribute is not present but &quot;
l_string|&quot;$INDEX_ROOT indicated it is.&quot;
)paren
suffix:semicolon
r_else
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Failed to lookup &quot;
l_string|&quot;$INDEX_ALLOCATION &quot;
l_string|&quot;attribute.&quot;
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|ctx-&gt;attr-&gt;non_resident
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;$INDEX_ALLOCATION attribute &quot;
l_string|&quot;is resident.&quot;
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Ensure the attribute name is placed before the mapping pairs&n;&t;&t; * array.&n;&t;&t; */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|ctx-&gt;attr-&gt;name_length
op_logical_and
(paren
id|le16_to_cpu
c_func
(paren
id|ctx-&gt;attr-&gt;name_offset
)paren
op_ge
id|le16_to_cpu
c_func
(paren
id|ctx-&gt;attr-&gt;data.non_resident
dot
id|mapping_pairs_offset
)paren
)paren
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;$INDEX_ALLOCATION attribute name &quot;
l_string|&quot;is placed after the mapping pairs &quot;
l_string|&quot;array.&quot;
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ctx-&gt;attr-&gt;flags
op_amp
id|ATTR_IS_ENCRYPTED
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;$INDEX_ALLOCATION attribute &quot;
l_string|&quot;is encrypted.&quot;
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ctx-&gt;attr-&gt;flags
op_amp
id|ATTR_IS_SPARSE
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;$INDEX_ALLOCATION attribute &quot;
l_string|&quot;is sparse.&quot;
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ctx-&gt;attr-&gt;flags
op_amp
id|ATTR_COMPRESSION_MASK
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;$INDEX_ALLOCATION attribute &quot;
l_string|&quot;is compressed.&quot;
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ctx-&gt;attr-&gt;data.non_resident.lowest_vcn
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;First extent of &quot;
l_string|&quot;$INDEX_ALLOCATION attribute has non &quot;
l_string|&quot;zero lowest_vcn.&quot;
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
id|vi-&gt;i_size
op_assign
id|sle64_to_cpu
c_func
(paren
id|ctx-&gt;attr-&gt;data.non_resident.data_size
)paren
suffix:semicolon
id|ni-&gt;initialized_size
op_assign
id|sle64_to_cpu
c_func
(paren
id|ctx-&gt;attr-&gt;data.non_resident.initialized_size
)paren
suffix:semicolon
id|ni-&gt;allocated_size
op_assign
id|sle64_to_cpu
c_func
(paren
id|ctx-&gt;attr-&gt;data.non_resident.allocated_size
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * We are done with the mft record, so we release it. Otherwise&n;&t;&t; * we would deadlock in ntfs_attr_iget().&n;&t;&t; */
id|ntfs_attr_put_search_ctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
id|unmap_mft_record
c_func
(paren
id|ni
)paren
suffix:semicolon
id|m
op_assign
l_int|NULL
suffix:semicolon
id|ctx
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Get the index bitmap attribute inode. */
id|bvi
op_assign
id|ntfs_attr_iget
c_func
(paren
id|vi
comma
id|AT_BITMAP
comma
id|I30
comma
l_int|4
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|bvi
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Failed to get bitmap attribute.&quot;
)paren
suffix:semicolon
id|err
op_assign
id|PTR_ERR
c_func
(paren
id|bvi
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
id|ni-&gt;itype.index.bmp_ino
op_assign
id|bvi
suffix:semicolon
id|bni
op_assign
id|NTFS_I
c_func
(paren
id|bvi
)paren
suffix:semicolon
r_if
c_cond
(paren
id|NInoCompressed
c_func
(paren
id|bni
)paren
op_logical_or
id|NInoEncrypted
c_func
(paren
id|bni
)paren
op_logical_or
id|NInoSparse
c_func
(paren
id|bni
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;$BITMAP attribute is compressed &quot;
l_string|&quot;and/or encrypted and/or sparse.&quot;
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
multiline_comment|/* Consistency check bitmap size vs. index allocation size. */
r_if
c_cond
(paren
(paren
id|bvi-&gt;i_size
op_lshift
l_int|3
)paren
OL
(paren
id|vi-&gt;i_size
op_rshift
id|ni-&gt;itype.index.block_size_bits
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Index bitmap too small (0x%llx) &quot;
l_string|&quot;for index allocation (0x%llx).&quot;
comma
id|bvi-&gt;i_size
op_lshift
l_int|3
comma
id|vi-&gt;i_size
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
id|skip_large_dir_stuff
suffix:colon
multiline_comment|/* Setup the operations for this inode. */
id|vi-&gt;i_op
op_assign
op_amp
id|ntfs_dir_inode_ops
suffix:semicolon
id|vi-&gt;i_fop
op_assign
op_amp
id|ntfs_dir_ops
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* It is a file. */
id|ntfs_attr_reinit_search_ctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
multiline_comment|/* Setup the data attribute, even if not present. */
id|ni-&gt;type
op_assign
id|AT_DATA
suffix:semicolon
id|ni-&gt;name
op_assign
l_int|NULL
suffix:semicolon
id|ni-&gt;name_len
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Find first extent of the unnamed data attribute. */
id|err
op_assign
id|ntfs_attr_lookup
c_func
(paren
id|AT_DATA
comma
l_int|NULL
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|NULL
comma
l_int|0
comma
id|ctx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|err
)paren
)paren
(brace
id|vi-&gt;i_size
op_assign
id|ni-&gt;initialized_size
op_assign
id|ni-&gt;allocated_size
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|err
op_ne
op_minus
id|ENOENT
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Failed to lookup $DATA &quot;
l_string|&quot;attribute.&quot;
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * FILE_Secure does not have an unnamed $DATA&n;&t;&t;&t; * attribute, so we special case it here.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|vi-&gt;i_ino
op_eq
id|FILE_Secure
)paren
r_goto
id|no_data_attr_special_case
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Most if not all the system files in the $Extend&n;&t;&t;&t; * system directory do not have unnamed data&n;&t;&t;&t; * attributes so we need to check if the parent&n;&t;&t;&t; * directory of the file is FILE_Extend and if it is&n;&t;&t;&t; * ignore this error. To do this we need to get the&n;&t;&t;&t; * name of this inode from the mft record as the name&n;&t;&t;&t; * contains the back reference to the parent directory.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|ntfs_is_extended_system_file
c_func
(paren
id|ctx
)paren
OG
l_int|0
)paren
r_goto
id|no_data_attr_special_case
suffix:semicolon
singleline_comment|// FIXME: File is corrupt! Hot-fix with empty data
singleline_comment|// attribute if recovery option is set.
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;$DATA attribute is missing.&quot;
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
multiline_comment|/* Setup the state. */
r_if
c_cond
(paren
id|ctx-&gt;attr-&gt;non_resident
)paren
(brace
id|NInoSetNonResident
c_func
(paren
id|ni
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ctx-&gt;attr-&gt;flags
op_amp
id|ATTR_COMPRESSION_MASK
)paren
(brace
id|NInoSetCompressed
c_func
(paren
id|ni
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vol-&gt;cluster_size
OG
l_int|4096
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Found &quot;
l_string|&quot;compressed data but &quot;
l_string|&quot;compression is disabled due &quot;
l_string|&quot;to cluster size (%i) &gt; 4kiB.&quot;
comma
id|vol-&gt;cluster_size
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|ctx-&gt;attr-&gt;flags
op_amp
id|ATTR_COMPRESSION_MASK
)paren
op_ne
id|ATTR_IS_COMPRESSED
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Found &quot;
l_string|&quot;unknown compression method or &quot;
l_string|&quot;corrupt file.&quot;
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
id|ni-&gt;itype.compressed.block_clusters
op_assign
l_int|1U
op_lshift
id|ctx-&gt;attr-&gt;data.non_resident
dot
id|compression_unit
suffix:semicolon
r_if
c_cond
(paren
id|ctx-&gt;attr-&gt;data.non_resident
dot
id|compression_unit
op_ne
l_int|4
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Found &quot;
l_string|&quot;nonstandard compression unit &quot;
l_string|&quot;(%u instead of 4).  Cannot &quot;
l_string|&quot;handle this.&quot;
comma
id|ctx-&gt;attr-&gt;data.non_resident
dot
id|compression_unit
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EOPNOTSUPP
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
id|ni-&gt;itype.compressed.block_size
op_assign
l_int|1U
op_lshift
(paren
id|ctx-&gt;attr-&gt;data.non_resident
dot
id|compression_unit
op_plus
id|vol-&gt;cluster_size_bits
)paren
suffix:semicolon
id|ni-&gt;itype.compressed.block_size_bits
op_assign
id|ffs
c_func
(paren
id|ni-&gt;itype.compressed.block_size
)paren
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ctx-&gt;attr-&gt;flags
op_amp
id|ATTR_IS_ENCRYPTED
)paren
(brace
r_if
c_cond
(paren
id|ctx-&gt;attr-&gt;flags
op_amp
id|ATTR_COMPRESSION_MASK
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Found encrypted &quot;
l_string|&quot;and compressed data.&quot;
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
id|NInoSetEncrypted
c_func
(paren
id|ni
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ctx-&gt;attr-&gt;flags
op_amp
id|ATTR_IS_SPARSE
)paren
id|NInoSetSparse
c_func
(paren
id|ni
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ctx-&gt;attr-&gt;data.non_resident.lowest_vcn
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;First extent of $DATA &quot;
l_string|&quot;attribute has non zero &quot;
l_string|&quot;lowest_vcn.&quot;
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
multiline_comment|/* Setup all the sizes. */
id|vi-&gt;i_size
op_assign
id|sle64_to_cpu
c_func
(paren
id|ctx-&gt;attr-&gt;data.non_resident.data_size
)paren
suffix:semicolon
id|ni-&gt;initialized_size
op_assign
id|sle64_to_cpu
c_func
(paren
id|ctx-&gt;attr-&gt;data.non_resident
dot
id|initialized_size
)paren
suffix:semicolon
id|ni-&gt;allocated_size
op_assign
id|sle64_to_cpu
c_func
(paren
id|ctx-&gt;attr-&gt;data.non_resident
dot
id|allocated_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|NInoCompressed
c_func
(paren
id|ni
)paren
)paren
(brace
id|ni-&gt;itype.compressed.size
op_assign
id|sle64_to_cpu
c_func
(paren
id|ctx-&gt;attr-&gt;data.non_resident
dot
id|compressed_size
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* Resident attribute. */
multiline_comment|/*&n;&t;&t;&t; * Make all sizes equal for simplicity in read code&n;&t;&t;&t; * paths. FIXME: Need to keep this in mind when&n;&t;&t;&t; * converting to non-resident attribute in write code&n;&t;&t;&t; * path. (Probably only affects truncate().)&n;&t;&t;&t; */
id|vi-&gt;i_size
op_assign
id|ni-&gt;initialized_size
op_assign
id|ni-&gt;allocated_size
op_assign
id|le32_to_cpu
c_func
(paren
id|ctx-&gt;attr-&gt;data.resident.value_length
)paren
suffix:semicolon
)brace
id|no_data_attr_special_case
suffix:colon
multiline_comment|/* We are done with the mft record, so we release it. */
id|ntfs_attr_put_search_ctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
id|unmap_mft_record
c_func
(paren
id|ni
)paren
suffix:semicolon
id|m
op_assign
l_int|NULL
suffix:semicolon
id|ctx
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Setup the operations for this inode. */
id|vi-&gt;i_op
op_assign
op_amp
id|ntfs_file_inode_ops
suffix:semicolon
id|vi-&gt;i_fop
op_assign
op_amp
id|ntfs_file_ops
suffix:semicolon
)brace
r_if
c_cond
(paren
id|NInoMstProtected
c_func
(paren
id|ni
)paren
)paren
id|vi-&gt;i_mapping-&gt;a_ops
op_assign
op_amp
id|ntfs_mst_aops
suffix:semicolon
r_else
id|vi-&gt;i_mapping-&gt;a_ops
op_assign
op_amp
id|ntfs_aops
suffix:semicolon
multiline_comment|/*&n;&t; * The number of 512-byte blocks used on disk (for stat). This is in so&n;&t; * far inaccurate as it doesn&squot;t account for any named streams or other&n;&t; * special non-resident attributes, but that is how Windows works, too,&n;&t; * so we are at least consistent with Windows, if not entirely&n;&t; * consistent with the Linux Way. Doing it the Linux Way would cause a&n;&t; * significant slowdown as it would involve iterating over all&n;&t; * attributes in the mft record and adding the allocated/compressed&n;&t; * sizes of all non-resident attributes present to give us the Linux&n;&t; * correct size that should go into i_blocks (after division by 512).&n;&t; */
r_if
c_cond
(paren
id|S_ISDIR
c_func
(paren
id|vi-&gt;i_mode
)paren
op_logical_or
op_logical_neg
id|NInoCompressed
c_func
(paren
id|ni
)paren
)paren
id|vi-&gt;i_blocks
op_assign
id|ni-&gt;allocated_size
op_rshift
l_int|9
suffix:semicolon
r_else
id|vi-&gt;i_blocks
op_assign
id|ni-&gt;itype.compressed.size
op_rshift
l_int|9
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Done.&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|unm_err_out
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|err
)paren
id|err
op_assign
op_minus
id|EIO
suffix:semicolon
r_if
c_cond
(paren
id|ctx
)paren
id|ntfs_attr_put_search_ctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|m
)paren
id|unmap_mft_record
c_func
(paren
id|ni
)paren
suffix:semicolon
id|err_out
suffix:colon
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Failed with error code %i.  Marking corrupt &quot;
l_string|&quot;inode 0x%lx as bad.  Run chkdsk.&quot;
comma
id|err
comma
id|vi-&gt;i_ino
)paren
suffix:semicolon
id|make_bad_inode
c_func
(paren
id|vi
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_ne
op_minus
id|EOPNOTSUPP
op_logical_and
id|err
op_ne
op_minus
id|ENOMEM
)paren
id|NVolSetErrors
c_func
(paren
id|vol
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_read_locked_attr_inode - read an attribute inode from its base inode&n; * @base_vi:&t;base inode&n; * @vi:&t;&t;attribute inode to read&n; *&n; * ntfs_read_locked_attr_inode() is called from ntfs_attr_iget() to read the&n; * attribute inode described by @vi into memory from the base mft record&n; * described by @base_ni.&n; *&n; * ntfs_read_locked_attr_inode() maps, pins and locks the base inode for&n; * reading and looks up the attribute described by @vi before setting up the&n; * necessary fields in @vi as well as initializing the ntfs inode.&n; *&n; * Q: What locks are held when the function is called?&n; * A: i_state has I_LOCK set, hence the inode is locked, also&n; *    i_count is set to 1, so it is not going to go away&n; *&n; * Return 0 on success and -errno on error.  In the error case, the inode will&n; * have had make_bad_inode() executed on it.&n; */
DECL|function|ntfs_read_locked_attr_inode
r_static
r_int
id|ntfs_read_locked_attr_inode
c_func
(paren
r_struct
id|inode
op_star
id|base_vi
comma
r_struct
id|inode
op_star
id|vi
)paren
(brace
id|ntfs_volume
op_star
id|vol
op_assign
id|NTFS_SB
c_func
(paren
id|vi-&gt;i_sb
)paren
suffix:semicolon
id|ntfs_inode
op_star
id|ni
comma
op_star
id|base_ni
suffix:semicolon
id|MFT_RECORD
op_star
id|m
suffix:semicolon
id|ntfs_attr_search_ctx
op_star
id|ctx
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Entering for i_ino 0x%lx.&quot;
comma
id|vi-&gt;i_ino
)paren
suffix:semicolon
id|ntfs_init_big_inode
c_func
(paren
id|vi
)paren
suffix:semicolon
id|ni
op_assign
id|NTFS_I
c_func
(paren
id|vi
)paren
suffix:semicolon
id|base_ni
op_assign
id|NTFS_I
c_func
(paren
id|base_vi
)paren
suffix:semicolon
multiline_comment|/* Just mirror the values from the base inode. */
id|vi-&gt;i_blksize
op_assign
id|base_vi-&gt;i_blksize
suffix:semicolon
id|vi-&gt;i_version
op_assign
id|base_vi-&gt;i_version
suffix:semicolon
id|vi-&gt;i_uid
op_assign
id|base_vi-&gt;i_uid
suffix:semicolon
id|vi-&gt;i_gid
op_assign
id|base_vi-&gt;i_gid
suffix:semicolon
id|vi-&gt;i_nlink
op_assign
id|base_vi-&gt;i_nlink
suffix:semicolon
id|vi-&gt;i_mtime
op_assign
id|base_vi-&gt;i_mtime
suffix:semicolon
id|vi-&gt;i_ctime
op_assign
id|base_vi-&gt;i_ctime
suffix:semicolon
id|vi-&gt;i_atime
op_assign
id|base_vi-&gt;i_atime
suffix:semicolon
id|vi-&gt;i_generation
op_assign
id|ni-&gt;seq_no
op_assign
id|base_ni-&gt;seq_no
suffix:semicolon
multiline_comment|/* Set inode type to zero but preserve permissions. */
id|vi-&gt;i_mode
op_assign
id|base_vi-&gt;i_mode
op_amp
op_complement
id|S_IFMT
suffix:semicolon
id|m
op_assign
id|map_mft_record
c_func
(paren
id|base_ni
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|m
)paren
)paren
(brace
id|err
op_assign
id|PTR_ERR
c_func
(paren
id|m
)paren
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
id|ctx
op_assign
id|ntfs_attr_get_search_ctx
c_func
(paren
id|base_ni
comma
id|m
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ctx
)paren
(brace
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
multiline_comment|/* Find the attribute. */
id|err
op_assign
id|ntfs_attr_lookup
c_func
(paren
id|ni-&gt;type
comma
id|ni-&gt;name
comma
id|ni-&gt;name_len
comma
id|CASE_SENSITIVE
comma
l_int|0
comma
l_int|NULL
comma
l_int|0
comma
id|ctx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|err
)paren
)paren
r_goto
id|unm_err_out
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ctx-&gt;attr-&gt;non_resident
)paren
(brace
multiline_comment|/* Ensure the attribute name is placed before the value. */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|ctx-&gt;attr-&gt;name_length
op_logical_and
(paren
id|le16_to_cpu
c_func
(paren
id|ctx-&gt;attr-&gt;name_offset
)paren
op_ge
id|le16_to_cpu
c_func
(paren
id|ctx-&gt;attr-&gt;data.resident
dot
id|value_offset
)paren
)paren
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Attribute name is placed after &quot;
l_string|&quot;the attribute value.&quot;
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|NInoMstProtected
c_func
(paren
id|ni
)paren
op_logical_or
id|ctx-&gt;attr-&gt;flags
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Found mst protected attribute &quot;
l_string|&quot;or attribute with non-zero flags but &quot;
l_string|&quot;the attribute is resident.  Please &quot;
l_string|&quot;report you saw this message to &quot;
l_string|&quot;linux-ntfs-dev@lists.sourceforge.net&quot;
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Resident attribute. Make all sizes equal for simplicity in&n;&t;&t; * read code paths.&n;&t;&t; */
id|vi-&gt;i_size
op_assign
id|ni-&gt;initialized_size
op_assign
id|ni-&gt;allocated_size
op_assign
id|le32_to_cpu
c_func
(paren
id|ctx-&gt;attr-&gt;data.resident.value_length
)paren
suffix:semicolon
)brace
r_else
(brace
id|NInoSetNonResident
c_func
(paren
id|ni
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Ensure the attribute name is placed before the mapping pairs&n;&t;&t; * array.&n;&t;&t; */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|ctx-&gt;attr-&gt;name_length
op_logical_and
(paren
id|le16_to_cpu
c_func
(paren
id|ctx-&gt;attr-&gt;name_offset
)paren
op_ge
id|le16_to_cpu
c_func
(paren
id|ctx-&gt;attr-&gt;data.non_resident
dot
id|mapping_pairs_offset
)paren
)paren
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Attribute name is placed after &quot;
l_string|&quot;the mapping pairs array.&quot;
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ctx-&gt;attr-&gt;flags
op_amp
id|ATTR_COMPRESSION_MASK
)paren
(brace
r_if
c_cond
(paren
id|NInoMstProtected
c_func
(paren
id|ni
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Found mst protected &quot;
l_string|&quot;attribute but the attribute &quot;
l_string|&quot;is compressed.  Please report &quot;
l_string|&quot;you saw this message to &quot;
l_string|&quot;linux-ntfs-dev@lists.&quot;
l_string|&quot;sourceforge.net&quot;
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
id|NInoSetCompressed
c_func
(paren
id|ni
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ni-&gt;type
op_ne
id|AT_DATA
)paren
op_logical_or
(paren
id|ni-&gt;type
op_eq
id|AT_DATA
op_logical_and
id|ni-&gt;name_len
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Found compressed &quot;
l_string|&quot;non-data or named data &quot;
l_string|&quot;attribute.  Please report &quot;
l_string|&quot;you saw this message to &quot;
l_string|&quot;linux-ntfs-dev@lists.&quot;
l_string|&quot;sourceforge.net&quot;
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|vol-&gt;cluster_size
OG
l_int|4096
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Found compressed &quot;
l_string|&quot;attribute but compression is &quot;
l_string|&quot;disabled due to cluster size &quot;
l_string|&quot;(%i) &gt; 4kiB.&quot;
comma
id|vol-&gt;cluster_size
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|ctx-&gt;attr-&gt;flags
op_amp
id|ATTR_COMPRESSION_MASK
)paren
op_ne
id|ATTR_IS_COMPRESSED
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Found unknown &quot;
l_string|&quot;compression method.&quot;
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
id|ni-&gt;itype.compressed.block_clusters
op_assign
l_int|1U
op_lshift
id|ctx-&gt;attr-&gt;data.non_resident
dot
id|compression_unit
suffix:semicolon
r_if
c_cond
(paren
id|ctx-&gt;attr-&gt;data.non_resident.compression_unit
op_ne
l_int|4
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Found nonstandard &quot;
l_string|&quot;compression unit (%u instead &quot;
l_string|&quot;of 4).  Cannot handle this.&quot;
comma
id|ctx-&gt;attr-&gt;data.non_resident
dot
id|compression_unit
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EOPNOTSUPP
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
id|ni-&gt;itype.compressed.block_size
op_assign
l_int|1U
op_lshift
(paren
id|ctx-&gt;attr-&gt;data.non_resident
dot
id|compression_unit
op_plus
id|vol-&gt;cluster_size_bits
)paren
suffix:semicolon
id|ni-&gt;itype.compressed.block_size_bits
op_assign
id|ffs
c_func
(paren
id|ni-&gt;itype.compressed.block_size
)paren
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ctx-&gt;attr-&gt;flags
op_amp
id|ATTR_IS_ENCRYPTED
)paren
(brace
r_if
c_cond
(paren
id|ctx-&gt;attr-&gt;flags
op_amp
id|ATTR_COMPRESSION_MASK
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Found encrypted &quot;
l_string|&quot;and compressed data.&quot;
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|NInoMstProtected
c_func
(paren
id|ni
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Found mst protected &quot;
l_string|&quot;attribute but the attribute &quot;
l_string|&quot;is encrypted.  Please report &quot;
l_string|&quot;you saw this message to &quot;
l_string|&quot;linux-ntfs-dev@lists.&quot;
l_string|&quot;sourceforge.net&quot;
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
id|NInoSetEncrypted
c_func
(paren
id|ni
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ctx-&gt;attr-&gt;flags
op_amp
id|ATTR_IS_SPARSE
)paren
(brace
r_if
c_cond
(paren
id|NInoMstProtected
c_func
(paren
id|ni
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Found mst protected &quot;
l_string|&quot;attribute but the attribute &quot;
l_string|&quot;is sparse.  Please report &quot;
l_string|&quot;you saw this message to &quot;
l_string|&quot;linux-ntfs-dev@lists.&quot;
l_string|&quot;sourceforge.net&quot;
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
id|NInoSetSparse
c_func
(paren
id|ni
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ctx-&gt;attr-&gt;data.non_resident.lowest_vcn
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;First extent of attribute has &quot;
l_string|&quot;non-zero lowest_vcn.&quot;
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
multiline_comment|/* Setup all the sizes. */
id|vi-&gt;i_size
op_assign
id|sle64_to_cpu
c_func
(paren
id|ctx-&gt;attr-&gt;data.non_resident.data_size
)paren
suffix:semicolon
id|ni-&gt;initialized_size
op_assign
id|sle64_to_cpu
c_func
(paren
id|ctx-&gt;attr-&gt;data.non_resident.initialized_size
)paren
suffix:semicolon
id|ni-&gt;allocated_size
op_assign
id|sle64_to_cpu
c_func
(paren
id|ctx-&gt;attr-&gt;data.non_resident.allocated_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|NInoCompressed
c_func
(paren
id|ni
)paren
)paren
(brace
id|ni-&gt;itype.compressed.size
op_assign
id|sle64_to_cpu
c_func
(paren
id|ctx-&gt;attr-&gt;data.non_resident
dot
id|compressed_size
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Setup the operations for this attribute inode. */
id|vi-&gt;i_op
op_assign
l_int|NULL
suffix:semicolon
id|vi-&gt;i_fop
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|NInoMstProtected
c_func
(paren
id|ni
)paren
)paren
id|vi-&gt;i_mapping-&gt;a_ops
op_assign
op_amp
id|ntfs_mst_aops
suffix:semicolon
r_else
id|vi-&gt;i_mapping-&gt;a_ops
op_assign
op_amp
id|ntfs_aops
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|NInoCompressed
c_func
(paren
id|ni
)paren
)paren
id|vi-&gt;i_blocks
op_assign
id|ni-&gt;allocated_size
op_rshift
l_int|9
suffix:semicolon
r_else
id|vi-&gt;i_blocks
op_assign
id|ni-&gt;itype.compressed.size
op_rshift
l_int|9
suffix:semicolon
multiline_comment|/*&n;&t; * Make sure the base inode doesn&squot;t go away and attach it to the&n;&t; * attribute inode.&n;&t; */
id|igrab
c_func
(paren
id|base_vi
)paren
suffix:semicolon
id|ni-&gt;ext.base_ntfs_ino
op_assign
id|base_ni
suffix:semicolon
id|ni-&gt;nr_extents
op_assign
op_minus
l_int|1
suffix:semicolon
id|ntfs_attr_put_search_ctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
id|unmap_mft_record
c_func
(paren
id|base_ni
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Done.&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|unm_err_out
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|err
)paren
id|err
op_assign
op_minus
id|EIO
suffix:semicolon
r_if
c_cond
(paren
id|ctx
)paren
id|ntfs_attr_put_search_ctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
id|unmap_mft_record
c_func
(paren
id|base_ni
)paren
suffix:semicolon
id|err_out
suffix:colon
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Failed with error code %i while reading attribute &quot;
l_string|&quot;inode (mft_no 0x%lx, type 0x%x, name_len %i).  &quot;
l_string|&quot;Marking corrupt inode and base inode 0x%lx as bad.  &quot;
l_string|&quot;Run chkdsk.&quot;
comma
id|err
comma
id|vi-&gt;i_ino
comma
id|ni-&gt;type
comma
id|ni-&gt;name_len
comma
id|base_vi-&gt;i_ino
)paren
suffix:semicolon
id|make_bad_inode
c_func
(paren
id|vi
)paren
suffix:semicolon
id|make_bad_inode
c_func
(paren
id|base_vi
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_ne
op_minus
id|ENOMEM
)paren
id|NVolSetErrors
c_func
(paren
id|vol
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_read_locked_index_inode - read an index inode from its base inode&n; * @base_vi:&t;base inode&n; * @vi:&t;&t;index inode to read&n; *&n; * ntfs_read_locked_index_inode() is called from ntfs_index_iget() to read the&n; * index inode described by @vi into memory from the base mft record described&n; * by @base_ni.&n; *&n; * ntfs_read_locked_index_inode() maps, pins and locks the base inode for&n; * reading and looks up the attributes relating to the index described by @vi&n; * before setting up the necessary fields in @vi as well as initializing the&n; * ntfs inode.&n; *&n; * Note, index inodes are essentially attribute inodes (NInoAttr() is true)&n; * with the attribute type set to AT_INDEX_ALLOCATION.  Apart from that, they&n; * are setup like directory inodes since directories are a special case of&n; * indices ao they need to be treated in much the same way.  Most importantly,&n; * for small indices the index allocation attribute might not actually exist.&n; * However, the index root attribute always exists but this does not need to&n; * have an inode associated with it and this is why we define a new inode type&n; * index.  Also, like for directories, we need to have an attribute inode for&n; * the bitmap attribute corresponding to the index allocation attribute and we&n; * can store this in the appropriate field of the inode, just like we do for&n; * normal directory inodes.&n; *&n; * Q: What locks are held when the function is called?&n; * A: i_state has I_LOCK set, hence the inode is locked, also&n; *    i_count is set to 1, so it is not going to go away&n; *&n; * Return 0 on success and -errno on error.  In the error case, the inode will&n; * have had make_bad_inode() executed on it.&n; */
DECL|function|ntfs_read_locked_index_inode
r_static
r_int
id|ntfs_read_locked_index_inode
c_func
(paren
r_struct
id|inode
op_star
id|base_vi
comma
r_struct
id|inode
op_star
id|vi
)paren
(brace
id|ntfs_volume
op_star
id|vol
op_assign
id|NTFS_SB
c_func
(paren
id|vi-&gt;i_sb
)paren
suffix:semicolon
id|ntfs_inode
op_star
id|ni
comma
op_star
id|base_ni
comma
op_star
id|bni
suffix:semicolon
r_struct
id|inode
op_star
id|bvi
suffix:semicolon
id|MFT_RECORD
op_star
id|m
suffix:semicolon
id|ntfs_attr_search_ctx
op_star
id|ctx
suffix:semicolon
id|INDEX_ROOT
op_star
id|ir
suffix:semicolon
id|u8
op_star
id|ir_end
comma
op_star
id|index_end
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Entering for i_ino 0x%lx.&quot;
comma
id|vi-&gt;i_ino
)paren
suffix:semicolon
id|ntfs_init_big_inode
c_func
(paren
id|vi
)paren
suffix:semicolon
id|ni
op_assign
id|NTFS_I
c_func
(paren
id|vi
)paren
suffix:semicolon
id|base_ni
op_assign
id|NTFS_I
c_func
(paren
id|base_vi
)paren
suffix:semicolon
multiline_comment|/* Just mirror the values from the base inode. */
id|vi-&gt;i_blksize
op_assign
id|base_vi-&gt;i_blksize
suffix:semicolon
id|vi-&gt;i_version
op_assign
id|base_vi-&gt;i_version
suffix:semicolon
id|vi-&gt;i_uid
op_assign
id|base_vi-&gt;i_uid
suffix:semicolon
id|vi-&gt;i_gid
op_assign
id|base_vi-&gt;i_gid
suffix:semicolon
id|vi-&gt;i_nlink
op_assign
id|base_vi-&gt;i_nlink
suffix:semicolon
id|vi-&gt;i_mtime
op_assign
id|base_vi-&gt;i_mtime
suffix:semicolon
id|vi-&gt;i_ctime
op_assign
id|base_vi-&gt;i_ctime
suffix:semicolon
id|vi-&gt;i_atime
op_assign
id|base_vi-&gt;i_atime
suffix:semicolon
id|vi-&gt;i_generation
op_assign
id|ni-&gt;seq_no
op_assign
id|base_ni-&gt;seq_no
suffix:semicolon
multiline_comment|/* Set inode type to zero but preserve permissions. */
id|vi-&gt;i_mode
op_assign
id|base_vi-&gt;i_mode
op_amp
op_complement
id|S_IFMT
suffix:semicolon
multiline_comment|/* Map the mft record for the base inode. */
id|m
op_assign
id|map_mft_record
c_func
(paren
id|base_ni
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|m
)paren
)paren
(brace
id|err
op_assign
id|PTR_ERR
c_func
(paren
id|m
)paren
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
id|ctx
op_assign
id|ntfs_attr_get_search_ctx
c_func
(paren
id|base_ni
comma
id|m
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ctx
)paren
(brace
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
multiline_comment|/* Find the index root attribute. */
id|err
op_assign
id|ntfs_attr_lookup
c_func
(paren
id|AT_INDEX_ROOT
comma
id|ni-&gt;name
comma
id|ni-&gt;name_len
comma
id|CASE_SENSITIVE
comma
l_int|0
comma
l_int|NULL
comma
l_int|0
comma
id|ctx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|err
)paren
)paren
(brace
r_if
c_cond
(paren
id|err
op_eq
op_minus
id|ENOENT
)paren
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;$INDEX_ROOT attribute is &quot;
l_string|&quot;missing.&quot;
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
multiline_comment|/* Set up the state. */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|ctx-&gt;attr-&gt;non_resident
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;$INDEX_ROOT attribute is not resident.&quot;
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
multiline_comment|/* Ensure the attribute name is placed before the value. */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|ctx-&gt;attr-&gt;name_length
op_logical_and
(paren
id|le16_to_cpu
c_func
(paren
id|ctx-&gt;attr-&gt;name_offset
)paren
op_ge
id|le16_to_cpu
c_func
(paren
id|ctx-&gt;attr-&gt;data.resident
dot
id|value_offset
)paren
)paren
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;$INDEX_ROOT attribute name is placed &quot;
l_string|&quot;after the attribute value.&quot;
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
multiline_comment|/* Compressed/encrypted/sparse index root is not allowed. */
r_if
c_cond
(paren
id|ctx-&gt;attr-&gt;flags
op_amp
(paren
id|ATTR_COMPRESSION_MASK
op_or
id|ATTR_IS_ENCRYPTED
op_or
id|ATTR_IS_SPARSE
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Found compressed/encrypted/sparse index &quot;
l_string|&quot;root attribute.&quot;
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
id|ir
op_assign
(paren
id|INDEX_ROOT
op_star
)paren
(paren
(paren
id|u8
op_star
)paren
id|ctx-&gt;attr
op_plus
id|le16_to_cpu
c_func
(paren
id|ctx-&gt;attr-&gt;data.resident.value_offset
)paren
)paren
suffix:semicolon
id|ir_end
op_assign
(paren
id|u8
op_star
)paren
id|ir
op_plus
id|le32_to_cpu
c_func
(paren
id|ctx-&gt;attr-&gt;data.resident.value_length
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ir_end
OG
(paren
id|u8
op_star
)paren
id|ctx-&gt;mrec
op_plus
id|vol-&gt;mft_record_size
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;$INDEX_ROOT attribute is corrupt.&quot;
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
id|index_end
op_assign
(paren
id|u8
op_star
)paren
op_amp
id|ir-&gt;index
op_plus
id|le32_to_cpu
c_func
(paren
id|ir-&gt;index.index_length
)paren
suffix:semicolon
r_if
c_cond
(paren
id|index_end
OG
id|ir_end
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Index is corrupt.&quot;
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ir-&gt;type
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Index type is not 0 (type is 0x%x).&quot;
comma
id|le32_to_cpu
c_func
(paren
id|ir-&gt;type
)paren
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
id|ni-&gt;itype.index.collation_rule
op_assign
id|ir-&gt;collation_rule
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Index collation rule is 0x%x.&quot;
comma
id|le32_to_cpu
c_func
(paren
id|ir-&gt;collation_rule
)paren
)paren
suffix:semicolon
id|ni-&gt;itype.index.block_size
op_assign
id|le32_to_cpu
c_func
(paren
id|ir-&gt;index_block_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ni-&gt;itype.index.block_size
op_amp
(paren
id|ni-&gt;itype.index.block_size
op_minus
l_int|1
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Index block size (%u) is not a power of &quot;
l_string|&quot;two.&quot;
comma
id|ni-&gt;itype.index.block_size
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ni-&gt;itype.index.block_size
OG
id|PAGE_CACHE_SIZE
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Index block size (%u) &gt; PAGE_CACHE_SIZE &quot;
l_string|&quot;(%ld) is not supported.  Sorry.&quot;
comma
id|ni-&gt;itype.index.block_size
comma
id|PAGE_CACHE_SIZE
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EOPNOTSUPP
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ni-&gt;itype.index.block_size
OL
id|NTFS_BLOCK_SIZE
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Index block size (%u) &lt; NTFS_BLOCK_SIZE &quot;
l_string|&quot;(%i) is not supported.  Sorry.&quot;
comma
id|ni-&gt;itype.index.block_size
comma
id|NTFS_BLOCK_SIZE
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EOPNOTSUPP
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
id|ni-&gt;itype.index.block_size_bits
op_assign
id|ffs
c_func
(paren
id|ni-&gt;itype.index.block_size
)paren
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* Determine the size of a vcn in the index. */
r_if
c_cond
(paren
id|vol-&gt;cluster_size
op_le
id|ni-&gt;itype.index.block_size
)paren
(brace
id|ni-&gt;itype.index.vcn_size
op_assign
id|vol-&gt;cluster_size
suffix:semicolon
id|ni-&gt;itype.index.vcn_size_bits
op_assign
id|vol-&gt;cluster_size_bits
suffix:semicolon
)brace
r_else
(brace
id|ni-&gt;itype.index.vcn_size
op_assign
id|vol-&gt;sector_size
suffix:semicolon
id|ni-&gt;itype.index.vcn_size_bits
op_assign
id|vol-&gt;sector_size_bits
suffix:semicolon
)brace
multiline_comment|/* Check for presence of index allocation attribute. */
r_if
c_cond
(paren
op_logical_neg
(paren
id|ir-&gt;index.flags
op_amp
id|LARGE_INDEX
)paren
)paren
(brace
multiline_comment|/* No index allocation. */
id|vi-&gt;i_size
op_assign
id|ni-&gt;initialized_size
op_assign
id|ni-&gt;allocated_size
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* We are done with the mft record, so we release it. */
id|ntfs_attr_put_search_ctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
id|unmap_mft_record
c_func
(paren
id|base_ni
)paren
suffix:semicolon
id|m
op_assign
l_int|NULL
suffix:semicolon
id|ctx
op_assign
l_int|NULL
suffix:semicolon
r_goto
id|skip_large_index_stuff
suffix:semicolon
)brace
multiline_comment|/* LARGE_INDEX:  Index allocation present.  Setup state. */
id|NInoSetIndexAllocPresent
c_func
(paren
id|ni
)paren
suffix:semicolon
multiline_comment|/* Find index allocation attribute. */
id|ntfs_attr_reinit_search_ctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
id|err
op_assign
id|ntfs_attr_lookup
c_func
(paren
id|AT_INDEX_ALLOCATION
comma
id|ni-&gt;name
comma
id|ni-&gt;name_len
comma
id|CASE_SENSITIVE
comma
l_int|0
comma
l_int|NULL
comma
l_int|0
comma
id|ctx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|err
)paren
)paren
(brace
r_if
c_cond
(paren
id|err
op_eq
op_minus
id|ENOENT
)paren
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;$INDEX_ALLOCATION attribute is &quot;
l_string|&quot;not present but $INDEX_ROOT &quot;
l_string|&quot;indicated it is.&quot;
)paren
suffix:semicolon
r_else
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Failed to lookup &quot;
l_string|&quot;$INDEX_ALLOCATION attribute.&quot;
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|ctx-&gt;attr-&gt;non_resident
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;$INDEX_ALLOCATION attribute is &quot;
l_string|&quot;resident.&quot;
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Ensure the attribute name is placed before the mapping pairs array.&n;&t; */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|ctx-&gt;attr-&gt;name_length
op_logical_and
(paren
id|le16_to_cpu
c_func
(paren
id|ctx-&gt;attr-&gt;name_offset
)paren
op_ge
id|le16_to_cpu
c_func
(paren
id|ctx-&gt;attr-&gt;data.non_resident.mapping_pairs_offset
)paren
)paren
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;$INDEX_ALLOCATION attribute name is &quot;
l_string|&quot;placed after the mapping pairs array.&quot;
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ctx-&gt;attr-&gt;flags
op_amp
id|ATTR_IS_ENCRYPTED
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;$INDEX_ALLOCATION attribute is &quot;
l_string|&quot;encrypted.&quot;
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ctx-&gt;attr-&gt;flags
op_amp
id|ATTR_IS_SPARSE
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;$INDEX_ALLOCATION attribute is sparse.&quot;
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ctx-&gt;attr-&gt;flags
op_amp
id|ATTR_COMPRESSION_MASK
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;$INDEX_ALLOCATION attribute is &quot;
l_string|&quot;compressed.&quot;
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ctx-&gt;attr-&gt;data.non_resident.lowest_vcn
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;First extent of $INDEX_ALLOCATION &quot;
l_string|&quot;attribute has non zero lowest_vcn.&quot;
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
id|vi-&gt;i_size
op_assign
id|sle64_to_cpu
c_func
(paren
id|ctx-&gt;attr-&gt;data.non_resident.data_size
)paren
suffix:semicolon
id|ni-&gt;initialized_size
op_assign
id|sle64_to_cpu
c_func
(paren
id|ctx-&gt;attr-&gt;data.non_resident.initialized_size
)paren
suffix:semicolon
id|ni-&gt;allocated_size
op_assign
id|sle64_to_cpu
c_func
(paren
id|ctx-&gt;attr-&gt;data.non_resident.allocated_size
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We are done with the mft record, so we release it.  Otherwise&n;&t; * we would deadlock in ntfs_attr_iget().&n;&t; */
id|ntfs_attr_put_search_ctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
id|unmap_mft_record
c_func
(paren
id|base_ni
)paren
suffix:semicolon
id|m
op_assign
l_int|NULL
suffix:semicolon
id|ctx
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Get the index bitmap attribute inode. */
id|bvi
op_assign
id|ntfs_attr_iget
c_func
(paren
id|base_vi
comma
id|AT_BITMAP
comma
id|ni-&gt;name
comma
id|ni-&gt;name_len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|bvi
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Failed to get bitmap attribute.&quot;
)paren
suffix:semicolon
id|err
op_assign
id|PTR_ERR
c_func
(paren
id|bvi
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
id|bni
op_assign
id|NTFS_I
c_func
(paren
id|bvi
)paren
suffix:semicolon
r_if
c_cond
(paren
id|NInoCompressed
c_func
(paren
id|bni
)paren
op_logical_or
id|NInoEncrypted
c_func
(paren
id|bni
)paren
op_logical_or
id|NInoSparse
c_func
(paren
id|bni
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;$BITMAP attribute is compressed and/or &quot;
l_string|&quot;encrypted and/or sparse.&quot;
)paren
suffix:semicolon
r_goto
id|iput_unm_err_out
suffix:semicolon
)brace
multiline_comment|/* Consistency check bitmap size vs. index allocation size. */
r_if
c_cond
(paren
(paren
id|bvi-&gt;i_size
op_lshift
l_int|3
)paren
OL
(paren
id|vi-&gt;i_size
op_rshift
id|ni-&gt;itype.index.block_size_bits
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Index bitmap too small (0x%llx) for &quot;
l_string|&quot;index allocation (0x%llx).&quot;
comma
id|bvi-&gt;i_size
op_lshift
l_int|3
comma
id|vi-&gt;i_size
)paren
suffix:semicolon
r_goto
id|iput_unm_err_out
suffix:semicolon
)brace
id|ni-&gt;itype.index.bmp_ino
op_assign
id|bvi
suffix:semicolon
id|skip_large_index_stuff
suffix:colon
multiline_comment|/* Setup the operations for this index inode. */
id|vi-&gt;i_op
op_assign
l_int|NULL
suffix:semicolon
id|vi-&gt;i_fop
op_assign
l_int|NULL
suffix:semicolon
id|vi-&gt;i_mapping-&gt;a_ops
op_assign
op_amp
id|ntfs_mst_aops
suffix:semicolon
id|vi-&gt;i_blocks
op_assign
id|ni-&gt;allocated_size
op_rshift
l_int|9
suffix:semicolon
multiline_comment|/*&n;&t; * Make sure the base inode doesn&squot;t go away and attach it to the&n;&t; * index inode.&n;&t; */
id|igrab
c_func
(paren
id|base_vi
)paren
suffix:semicolon
id|ni-&gt;ext.base_ntfs_ino
op_assign
id|base_ni
suffix:semicolon
id|ni-&gt;nr_extents
op_assign
op_minus
l_int|1
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Done.&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|iput_unm_err_out
suffix:colon
id|iput
c_func
(paren
id|bvi
)paren
suffix:semicolon
id|unm_err_out
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|err
)paren
id|err
op_assign
op_minus
id|EIO
suffix:semicolon
r_if
c_cond
(paren
id|ctx
)paren
id|ntfs_attr_put_search_ctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|m
)paren
id|unmap_mft_record
c_func
(paren
id|base_ni
)paren
suffix:semicolon
id|err_out
suffix:colon
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Failed with error code %i while reading index &quot;
l_string|&quot;inode (mft_no 0x%lx, name_len %i.&quot;
comma
id|err
comma
id|vi-&gt;i_ino
comma
id|ni-&gt;name_len
)paren
suffix:semicolon
id|make_bad_inode
c_func
(paren
id|vi
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_ne
op_minus
id|EOPNOTSUPP
op_logical_and
id|err
op_ne
op_minus
id|ENOMEM
)paren
id|NVolSetErrors
c_func
(paren
id|vol
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_read_inode_mount - special read_inode for mount time use only&n; * @vi:&t;&t;inode to read&n; *&n; * Read inode FILE_MFT at mount time, only called with super_block lock&n; * held from within the read_super() code path.&n; *&n; * This function exists because when it is called the page cache for $MFT/$DATA&n; * is not initialized and hence we cannot get at the contents of mft records&n; * by calling map_mft_record*().&n; *&n; * Further it needs to cope with the circular references problem, i.e. cannot&n; * load any attributes other than $ATTRIBUTE_LIST until $DATA is loaded, because&n; * we do not know where the other extent mft records are yet and again, because&n; * we cannot call map_mft_record*() yet.  Obviously this applies only when an&n; * attribute list is actually present in $MFT inode.&n; *&n; * We solve these problems by starting with the $DATA attribute before anything&n; * else and iterating using ntfs_attr_lookup($DATA) over all extents.  As each&n; * extent is found, we ntfs_mapping_pairs_decompress() including the implied&n; * ntfs_runlists_merge().  Each step of the iteration necessarily provides&n; * sufficient information for the next step to complete.&n; *&n; * This should work but there are two possible pit falls (see inline comments&n; * below), but only time will tell if they are real pits or just smoke...&n; */
DECL|function|ntfs_read_inode_mount
r_int
id|ntfs_read_inode_mount
c_func
(paren
r_struct
id|inode
op_star
id|vi
)paren
(brace
id|VCN
id|next_vcn
comma
id|last_vcn
comma
id|highest_vcn
suffix:semicolon
id|s64
id|block
suffix:semicolon
r_struct
id|super_block
op_star
id|sb
op_assign
id|vi-&gt;i_sb
suffix:semicolon
id|ntfs_volume
op_star
id|vol
op_assign
id|NTFS_SB
c_func
(paren
id|sb
)paren
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
id|ntfs_inode
op_star
id|ni
suffix:semicolon
id|MFT_RECORD
op_star
id|m
op_assign
l_int|NULL
suffix:semicolon
id|ATTR_RECORD
op_star
id|attr
suffix:semicolon
id|ntfs_attr_search_ctx
op_star
id|ctx
suffix:semicolon
r_int
r_int
id|i
comma
id|nr_blocks
suffix:semicolon
r_int
id|err
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Entering.&quot;
)paren
suffix:semicolon
multiline_comment|/* Initialize the ntfs specific part of @vi. */
id|ntfs_init_big_inode
c_func
(paren
id|vi
)paren
suffix:semicolon
id|ni
op_assign
id|NTFS_I
c_func
(paren
id|vi
)paren
suffix:semicolon
multiline_comment|/* Setup the data attribute. It is special as it is mst protected. */
id|NInoSetNonResident
c_func
(paren
id|ni
)paren
suffix:semicolon
id|NInoSetMstProtected
c_func
(paren
id|ni
)paren
suffix:semicolon
id|ni-&gt;type
op_assign
id|AT_DATA
suffix:semicolon
id|ni-&gt;name
op_assign
l_int|NULL
suffix:semicolon
id|ni-&gt;name_len
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * This sets up our little cheat allowing us to reuse the async read io&n;&t; * completion handler for directories.&n;&t; */
id|ni-&gt;itype.index.block_size
op_assign
id|vol-&gt;mft_record_size
suffix:semicolon
id|ni-&gt;itype.index.block_size_bits
op_assign
id|vol-&gt;mft_record_size_bits
suffix:semicolon
multiline_comment|/* Very important! Needed to be able to call map_mft_record*(). */
id|vol-&gt;mft_ino
op_assign
id|vi
suffix:semicolon
multiline_comment|/* Allocate enough memory to read the first mft record. */
r_if
c_cond
(paren
id|vol-&gt;mft_record_size
OG
l_int|64
op_star
l_int|1024
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Unsupported mft record size %i (max 64kiB).&quot;
comma
id|vol-&gt;mft_record_size
)paren
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
id|i
op_assign
id|vol-&gt;mft_record_size
suffix:semicolon
r_if
c_cond
(paren
id|i
OL
id|sb-&gt;s_blocksize
)paren
id|i
op_assign
id|sb-&gt;s_blocksize
suffix:semicolon
id|m
op_assign
(paren
id|MFT_RECORD
op_star
)paren
id|ntfs_malloc_nofs
c_func
(paren
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|m
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Failed to allocate buffer for $MFT record 0.&quot;
)paren
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
multiline_comment|/* Determine the first block of the $MFT/$DATA attribute. */
id|block
op_assign
id|vol-&gt;mft_lcn
op_lshift
id|vol-&gt;cluster_size_bits
op_rshift
id|sb-&gt;s_blocksize_bits
suffix:semicolon
id|nr_blocks
op_assign
id|vol-&gt;mft_record_size
op_rshift
id|sb-&gt;s_blocksize_bits
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|nr_blocks
)paren
id|nr_blocks
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Load $MFT/$DATA&squot;s first mft record. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr_blocks
suffix:semicolon
id|i
op_increment
)paren
(brace
id|bh
op_assign
id|sb_bread
c_func
(paren
id|sb
comma
id|block
op_increment
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bh
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Device read failed.&quot;
)paren
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
id|memcpy
c_func
(paren
(paren
r_char
op_star
)paren
id|m
op_plus
(paren
id|i
op_lshift
id|sb-&gt;s_blocksize_bits
)paren
comma
id|bh-&gt;b_data
comma
id|sb-&gt;s_blocksize
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
multiline_comment|/* Apply the mst fixups. */
r_if
c_cond
(paren
id|post_read_mst_fixup
c_func
(paren
(paren
id|NTFS_RECORD
op_star
)paren
id|m
comma
id|vol-&gt;mft_record_size
)paren
)paren
(brace
multiline_comment|/* FIXME: Try to use the $MFTMirr now. */
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;MST fixup failed. $MFT is corrupt.&quot;
)paren
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
multiline_comment|/* Need this to sanity check attribute list references to $MFT. */
id|vi-&gt;i_generation
op_assign
id|ni-&gt;seq_no
op_assign
id|le16_to_cpu
c_func
(paren
id|m-&gt;sequence_number
)paren
suffix:semicolon
multiline_comment|/* Provides readpage() and sync_page() for map_mft_record(). */
id|vi-&gt;i_mapping-&gt;a_ops
op_assign
op_amp
id|ntfs_mst_aops
suffix:semicolon
id|ctx
op_assign
id|ntfs_attr_get_search_ctx
c_func
(paren
id|ni
comma
id|m
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ctx
)paren
(brace
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
multiline_comment|/* Find the attribute list attribute if present. */
id|err
op_assign
id|ntfs_attr_lookup
c_func
(paren
id|AT_ATTRIBUTE_LIST
comma
l_int|NULL
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|NULL
comma
l_int|0
comma
id|ctx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|err
op_ne
op_minus
id|ENOENT
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Failed to lookup attribute list &quot;
l_string|&quot;attribute. You should run chkdsk.&quot;
)paren
suffix:semicolon
r_goto
id|put_err_out
suffix:semicolon
)brace
)brace
r_else
multiline_comment|/* if (!err) */
(brace
id|ATTR_LIST_ENTRY
op_star
id|al_entry
comma
op_star
id|next_al_entry
suffix:semicolon
id|u8
op_star
id|al_end
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Attribute list attribute found in $MFT.&quot;
)paren
suffix:semicolon
id|NInoSetAttrList
c_func
(paren
id|ni
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ctx-&gt;attr-&gt;flags
op_amp
id|ATTR_IS_ENCRYPTED
op_logical_or
id|ctx-&gt;attr-&gt;flags
op_amp
id|ATTR_COMPRESSION_MASK
op_logical_or
id|ctx-&gt;attr-&gt;flags
op_amp
id|ATTR_IS_SPARSE
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Attribute list attribute is &quot;
l_string|&quot;compressed/encrypted/sparse. Not &quot;
l_string|&quot;allowed. $MFT is corrupt. You should &quot;
l_string|&quot;run chkdsk.&quot;
)paren
suffix:semicolon
r_goto
id|put_err_out
suffix:semicolon
)brace
multiline_comment|/* Now allocate memory for the attribute list. */
id|ni-&gt;attr_list_size
op_assign
(paren
id|u32
)paren
id|ntfs_attr_size
c_func
(paren
id|ctx-&gt;attr
)paren
suffix:semicolon
id|ni-&gt;attr_list
op_assign
id|ntfs_malloc_nofs
c_func
(paren
id|ni-&gt;attr_list_size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ni-&gt;attr_list
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Not enough memory to allocate buffer &quot;
l_string|&quot;for attribute list.&quot;
)paren
suffix:semicolon
r_goto
id|put_err_out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ctx-&gt;attr-&gt;non_resident
)paren
(brace
id|NInoSetAttrListNonResident
c_func
(paren
id|ni
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ctx-&gt;attr-&gt;data.non_resident.lowest_vcn
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Attribute list has non zero &quot;
l_string|&quot;lowest_vcn. $MFT is corrupt. &quot;
l_string|&quot;You should run chkdsk.&quot;
)paren
suffix:semicolon
r_goto
id|put_err_out
suffix:semicolon
)brace
multiline_comment|/* Setup the runlist. */
id|ni-&gt;attr_list_rl.rl
op_assign
id|ntfs_mapping_pairs_decompress
c_func
(paren
id|vol
comma
id|ctx-&gt;attr
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|ni-&gt;attr_list_rl.rl
)paren
)paren
(brace
id|err
op_assign
id|PTR_ERR
c_func
(paren
id|ni-&gt;attr_list_rl.rl
)paren
suffix:semicolon
id|ni-&gt;attr_list_rl.rl
op_assign
l_int|NULL
suffix:semicolon
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Mapping pairs decompression &quot;
l_string|&quot;failed with error code %i.&quot;
comma
op_minus
id|err
)paren
suffix:semicolon
r_goto
id|put_err_out
suffix:semicolon
)brace
multiline_comment|/* Now load the attribute list. */
r_if
c_cond
(paren
(paren
id|err
op_assign
id|load_attribute_list
c_func
(paren
id|vol
comma
op_amp
id|ni-&gt;attr_list_rl
comma
id|ni-&gt;attr_list
comma
id|ni-&gt;attr_list_size
comma
id|sle64_to_cpu
c_func
(paren
id|ctx-&gt;attr-&gt;data
dot
id|non_resident.initialized_size
)paren
)paren
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Failed to load attribute list &quot;
l_string|&quot;attribute with error code %i.&quot;
comma
op_minus
id|err
)paren
suffix:semicolon
r_goto
id|put_err_out
suffix:semicolon
)brace
)brace
r_else
multiline_comment|/* if (!ctx.attr-&gt;non_resident) */
(brace
r_if
c_cond
(paren
(paren
id|u8
op_star
)paren
id|ctx-&gt;attr
op_plus
id|le16_to_cpu
c_func
(paren
id|ctx-&gt;attr-&gt;data.resident.value_offset
)paren
op_plus
id|le32_to_cpu
c_func
(paren
id|ctx-&gt;attr-&gt;data.resident.value_length
)paren
OG
(paren
id|u8
op_star
)paren
id|ctx-&gt;mrec
op_plus
id|vol-&gt;mft_record_size
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Corrupt attribute list &quot;
l_string|&quot;attribute.&quot;
)paren
suffix:semicolon
r_goto
id|put_err_out
suffix:semicolon
)brace
multiline_comment|/* Now copy the attribute list. */
id|memcpy
c_func
(paren
id|ni-&gt;attr_list
comma
(paren
id|u8
op_star
)paren
id|ctx-&gt;attr
op_plus
id|le16_to_cpu
c_func
(paren
id|ctx-&gt;attr-&gt;data.resident.value_offset
)paren
comma
id|le32_to_cpu
c_func
(paren
id|ctx-&gt;attr-&gt;data.resident.value_length
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* The attribute list is now setup in memory. */
multiline_comment|/*&n;&t;&t; * FIXME: I don&squot;t know if this case is actually possible.&n;&t;&t; * According to logic it is not possible but I have seen too&n;&t;&t; * many weird things in MS software to rely on logic... Thus we&n;&t;&t; * perform a manual search and make sure the first $MFT/$DATA&n;&t;&t; * extent is in the base inode. If it is not we abort with an&n;&t;&t; * error and if we ever see a report of this error we will need&n;&t;&t; * to do some magic in order to have the necessary mft record&n;&t;&t; * loaded and in the right place in the page cache. But&n;&t;&t; * hopefully logic will prevail and this never happens...&n;&t;&t; */
id|al_entry
op_assign
(paren
id|ATTR_LIST_ENTRY
op_star
)paren
id|ni-&gt;attr_list
suffix:semicolon
id|al_end
op_assign
(paren
id|u8
op_star
)paren
id|al_entry
op_plus
id|ni-&gt;attr_list_size
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
id|al_entry
op_assign
id|next_al_entry
)paren
(brace
multiline_comment|/* Out of bounds check. */
r_if
c_cond
(paren
(paren
id|u8
op_star
)paren
id|al_entry
template_param
id|al_end
)paren
r_goto
id|em_put_err_out
suffix:semicolon
multiline_comment|/* Catch the end of the attribute list. */
r_if
c_cond
(paren
(paren
id|u8
op_star
)paren
id|al_entry
op_eq
id|al_end
)paren
r_goto
id|em_put_err_out
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|al_entry-&gt;length
)paren
r_goto
id|em_put_err_out
suffix:semicolon
r_if
c_cond
(paren
(paren
id|u8
op_star
)paren
id|al_entry
op_plus
l_int|6
OG
id|al_end
op_logical_or
(paren
id|u8
op_star
)paren
id|al_entry
op_plus
id|le16_to_cpu
c_func
(paren
id|al_entry-&gt;length
)paren
OG
id|al_end
)paren
r_goto
id|em_put_err_out
suffix:semicolon
id|next_al_entry
op_assign
(paren
id|ATTR_LIST_ENTRY
op_star
)paren
(paren
(paren
id|u8
op_star
)paren
id|al_entry
op_plus
id|le16_to_cpu
c_func
(paren
id|al_entry-&gt;length
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|le32_to_cpu
c_func
(paren
id|al_entry-&gt;type
)paren
OG
id|const_le32_to_cpu
c_func
(paren
id|AT_DATA
)paren
)paren
r_goto
id|em_put_err_out
suffix:semicolon
r_if
c_cond
(paren
id|AT_DATA
op_ne
id|al_entry-&gt;type
)paren
r_continue
suffix:semicolon
multiline_comment|/* We want an unnamed attribute. */
r_if
c_cond
(paren
id|al_entry-&gt;name_length
)paren
r_goto
id|em_put_err_out
suffix:semicolon
multiline_comment|/* Want the first entry, i.e. lowest_vcn == 0. */
r_if
c_cond
(paren
id|al_entry-&gt;lowest_vcn
)paren
r_goto
id|em_put_err_out
suffix:semicolon
multiline_comment|/* First entry has to be in the base mft record. */
r_if
c_cond
(paren
id|MREF_LE
c_func
(paren
id|al_entry-&gt;mft_reference
)paren
op_ne
id|vi-&gt;i_ino
)paren
(brace
multiline_comment|/* MFT references do not match, logic fails. */
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;BUG: The first $DATA extent &quot;
l_string|&quot;of $MFT is not in the base &quot;
l_string|&quot;mft record. Please report &quot;
l_string|&quot;you saw this message to &quot;
l_string|&quot;linux-ntfs-dev@lists.&quot;
l_string|&quot;sourceforge.net&quot;
)paren
suffix:semicolon
r_goto
id|put_err_out
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Sequence numbers must match. */
r_if
c_cond
(paren
id|MSEQNO_LE
c_func
(paren
id|al_entry-&gt;mft_reference
)paren
op_ne
id|ni-&gt;seq_no
)paren
r_goto
id|em_put_err_out
suffix:semicolon
multiline_comment|/* Got it. All is ok. We can stop now. */
r_break
suffix:semicolon
)brace
)brace
)brace
id|ntfs_attr_reinit_search_ctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
multiline_comment|/* Now load all attribute extents. */
id|attr
op_assign
l_int|NULL
suffix:semicolon
id|next_vcn
op_assign
id|last_vcn
op_assign
id|highest_vcn
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
(paren
id|err
op_assign
id|ntfs_attr_lookup
c_func
(paren
id|AT_DATA
comma
l_int|NULL
comma
l_int|0
comma
l_int|0
comma
id|next_vcn
comma
l_int|NULL
comma
l_int|0
comma
id|ctx
)paren
)paren
)paren
(brace
id|runlist_element
op_star
id|nrl
suffix:semicolon
multiline_comment|/* Cache the current attribute. */
id|attr
op_assign
id|ctx-&gt;attr
suffix:semicolon
multiline_comment|/* $MFT must be non-resident. */
r_if
c_cond
(paren
op_logical_neg
id|attr-&gt;non_resident
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;$MFT must be non-resident but a &quot;
l_string|&quot;resident extent was found. $MFT is &quot;
l_string|&quot;corrupt. Run chkdsk.&quot;
)paren
suffix:semicolon
r_goto
id|put_err_out
suffix:semicolon
)brace
multiline_comment|/* $MFT must be uncompressed and unencrypted. */
r_if
c_cond
(paren
id|attr-&gt;flags
op_amp
id|ATTR_COMPRESSION_MASK
op_logical_or
id|attr-&gt;flags
op_amp
id|ATTR_IS_ENCRYPTED
op_logical_or
id|attr-&gt;flags
op_amp
id|ATTR_IS_SPARSE
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;$MFT must be uncompressed, &quot;
l_string|&quot;non-sparse, and unencrypted but a &quot;
l_string|&quot;compressed/sparse/encrypted extent &quot;
l_string|&quot;was found. $MFT is corrupt. Run &quot;
l_string|&quot;chkdsk.&quot;
)paren
suffix:semicolon
r_goto
id|put_err_out
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Decompress the mapping pairs array of this extent and merge&n;&t;&t; * the result into the existing runlist. No need for locking&n;&t;&t; * as we have exclusive access to the inode at this time and we&n;&t;&t; * are a mount in progress task, too.&n;&t;&t; */
id|nrl
op_assign
id|ntfs_mapping_pairs_decompress
c_func
(paren
id|vol
comma
id|attr
comma
id|ni-&gt;runlist.rl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|nrl
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;ntfs_mapping_pairs_decompress() &quot;
l_string|&quot;failed with error code %ld.  $MFT is &quot;
l_string|&quot;corrupt.&quot;
comma
id|PTR_ERR
c_func
(paren
id|nrl
)paren
)paren
suffix:semicolon
r_goto
id|put_err_out
suffix:semicolon
)brace
id|ni-&gt;runlist.rl
op_assign
id|nrl
suffix:semicolon
multiline_comment|/* Are we in the first extent? */
r_if
c_cond
(paren
op_logical_neg
id|next_vcn
)paren
(brace
r_if
c_cond
(paren
id|attr-&gt;data.non_resident.lowest_vcn
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;First extent of $DATA &quot;
l_string|&quot;attribute has non zero &quot;
l_string|&quot;lowest_vcn. $MFT is corrupt. &quot;
l_string|&quot;You should run chkdsk.&quot;
)paren
suffix:semicolon
r_goto
id|put_err_out
suffix:semicolon
)brace
multiline_comment|/* Get the last vcn in the $DATA attribute. */
id|last_vcn
op_assign
id|sle64_to_cpu
c_func
(paren
id|attr-&gt;data.non_resident.allocated_size
)paren
op_rshift
id|vol-&gt;cluster_size_bits
suffix:semicolon
multiline_comment|/* Fill in the inode size. */
id|vi-&gt;i_size
op_assign
id|sle64_to_cpu
c_func
(paren
id|attr-&gt;data.non_resident.data_size
)paren
suffix:semicolon
id|ni-&gt;initialized_size
op_assign
id|sle64_to_cpu
c_func
(paren
id|attr-&gt;data
dot
id|non_resident.initialized_size
)paren
suffix:semicolon
id|ni-&gt;allocated_size
op_assign
id|sle64_to_cpu
c_func
(paren
id|attr-&gt;data.non_resident.allocated_size
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Verify the number of mft records does not exceed&n;&t;&t;&t; * 2^32 - 1.&n;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|vi-&gt;i_size
op_rshift
id|vol-&gt;mft_record_size_bits
)paren
op_ge
(paren
l_int|1ULL
op_lshift
l_int|32
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;$MFT is too big! Aborting.&quot;
)paren
suffix:semicolon
r_goto
id|put_err_out
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * We have got the first extent of the runlist for&n;&t;&t;&t; * $MFT which means it is now relatively safe to call&n;&t;&t;&t; * the normal ntfs_read_inode() function.&n;&t;&t;&t; * Complete reading the inode, this will actually&n;&t;&t;&t; * re-read the mft record for $MFT, this time entering&n;&t;&t;&t; * it into the page cache with which we complete the&n;&t;&t;&t; * kick start of the volume. It should be safe to do&n;&t;&t;&t; * this now as the first extent of $MFT/$DATA is&n;&t;&t;&t; * already known and we would hope that we don&squot;t need&n;&t;&t;&t; * further extents in order to find the other&n;&t;&t;&t; * attributes belonging to $MFT. Only time will tell if&n;&t;&t;&t; * this is really the case. If not we will have to play&n;&t;&t;&t; * magic at this point, possibly duplicating a lot of&n;&t;&t;&t; * ntfs_read_inode() at this point. We will need to&n;&t;&t;&t; * ensure we do enough of its work to be able to call&n;&t;&t;&t; * ntfs_read_inode() on extents of $MFT/$DATA. But lets&n;&t;&t;&t; * hope this never happens...&n;&t;&t;&t; */
id|ntfs_read_locked_inode
c_func
(paren
id|vi
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_bad_inode
c_func
(paren
id|vi
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;ntfs_read_inode() of $MFT &quot;
l_string|&quot;failed. BUG or corrupt $MFT. &quot;
l_string|&quot;Run chkdsk and if no errors &quot;
l_string|&quot;are found, please report you &quot;
l_string|&quot;saw this message to &quot;
l_string|&quot;linux-ntfs-dev@lists.&quot;
l_string|&quot;sourceforge.net&quot;
)paren
suffix:semicolon
id|ntfs_attr_put_search_ctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
multiline_comment|/* Revert to the safe super operations. */
id|ntfs_free
c_func
(paren
id|m
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * Re-initialize some specifics about $MFT&squot;s inode as&n;&t;&t;&t; * ntfs_read_inode() will have set up the default ones.&n;&t;&t;&t; */
multiline_comment|/* Set uid and gid to root. */
id|vi-&gt;i_uid
op_assign
id|vi-&gt;i_gid
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Regular file. No access for anyone. */
id|vi-&gt;i_mode
op_assign
id|S_IFREG
suffix:semicolon
multiline_comment|/* No VFS initiated operations allowed for $MFT. */
id|vi-&gt;i_op
op_assign
op_amp
id|ntfs_empty_inode_ops
suffix:semicolon
id|vi-&gt;i_fop
op_assign
op_amp
id|ntfs_empty_file_ops
suffix:semicolon
)brace
multiline_comment|/* Get the lowest vcn for the next extent. */
id|highest_vcn
op_assign
id|sle64_to_cpu
c_func
(paren
id|attr-&gt;data.non_resident.highest_vcn
)paren
suffix:semicolon
id|next_vcn
op_assign
id|highest_vcn
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* Only one extent or error, which we catch below. */
r_if
c_cond
(paren
id|next_vcn
op_le
l_int|0
)paren
r_break
suffix:semicolon
multiline_comment|/* Avoid endless loops due to corruption. */
r_if
c_cond
(paren
id|next_vcn
OL
id|sle64_to_cpu
c_func
(paren
id|attr-&gt;data.non_resident.lowest_vcn
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;$MFT has corrupt attribute list &quot;
l_string|&quot;attribute. Run chkdsk.&quot;
)paren
suffix:semicolon
r_goto
id|put_err_out
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|err
op_ne
op_minus
id|ENOENT
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Failed to lookup $MFT/$DATA attribute extent. &quot;
l_string|&quot;$MFT is corrupt. Run chkdsk.&quot;
)paren
suffix:semicolon
r_goto
id|put_err_out
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|attr
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;$MFT/$DATA attribute not found. $MFT is &quot;
l_string|&quot;corrupt. Run chkdsk.&quot;
)paren
suffix:semicolon
r_goto
id|put_err_out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|highest_vcn
op_logical_and
id|highest_vcn
op_ne
id|last_vcn
op_minus
l_int|1
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Failed to load the complete runlist for &quot;
l_string|&quot;$MFT/$DATA. Driver bug or corrupt $MFT. &quot;
l_string|&quot;Run chkdsk.&quot;
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;highest_vcn = 0x%llx, last_vcn - 1 = 0x%llx&quot;
comma
(paren
r_int
r_int
r_int
)paren
id|highest_vcn
comma
(paren
r_int
r_int
r_int
)paren
id|last_vcn
op_minus
l_int|1
)paren
suffix:semicolon
r_goto
id|put_err_out
suffix:semicolon
)brace
id|ntfs_attr_put_search_ctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Done.&quot;
)paren
suffix:semicolon
id|ntfs_free
c_func
(paren
id|m
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|em_put_err_out
suffix:colon
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Couldn&squot;t find first extent of $DATA attribute in &quot;
l_string|&quot;attribute list. $MFT is corrupt. Run chkdsk.&quot;
)paren
suffix:semicolon
id|put_err_out
suffix:colon
id|ntfs_attr_put_search_ctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
id|err_out
suffix:colon
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Failed. Marking inode as bad.&quot;
)paren
suffix:semicolon
id|make_bad_inode
c_func
(paren
id|vi
)paren
suffix:semicolon
id|ntfs_free
c_func
(paren
id|m
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_put_inode - handler for when the inode reference count is decremented&n; * @vi:&t;&t;vfs inode&n; *&n; * The VFS calls ntfs_put_inode() every time the inode reference count (i_count)&n; * is about to be decremented (but before the decrement itself.&n; *&n; * If the inode @vi is a directory with two references, one of which is being&n; * dropped, we need to put the attribute inode for the directory index bitmap,&n; * if it is present, otherwise the directory inode would remain pinned for&n; * ever.&n; */
DECL|function|ntfs_put_inode
r_void
id|ntfs_put_inode
c_func
(paren
r_struct
id|inode
op_star
id|vi
)paren
(brace
r_if
c_cond
(paren
id|S_ISDIR
c_func
(paren
id|vi-&gt;i_mode
)paren
op_logical_and
id|atomic_read
c_func
(paren
op_amp
id|vi-&gt;i_count
)paren
op_eq
l_int|2
)paren
(brace
id|ntfs_inode
op_star
id|ni
op_assign
id|NTFS_I
c_func
(paren
id|vi
)paren
suffix:semicolon
r_if
c_cond
(paren
id|NInoIndexAllocPresent
c_func
(paren
id|ni
)paren
)paren
(brace
r_struct
id|inode
op_star
id|bvi
op_assign
l_int|NULL
suffix:semicolon
id|down
c_func
(paren
op_amp
id|vi-&gt;i_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|vi-&gt;i_count
)paren
op_eq
l_int|2
)paren
(brace
id|bvi
op_assign
id|ni-&gt;itype.index.bmp_ino
suffix:semicolon
r_if
c_cond
(paren
id|bvi
)paren
id|ni-&gt;itype.index.bmp_ino
op_assign
l_int|NULL
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|vi-&gt;i_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bvi
)paren
id|iput
c_func
(paren
id|bvi
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|function|__ntfs_clear_inode
r_static
r_void
id|__ntfs_clear_inode
c_func
(paren
id|ntfs_inode
op_star
id|ni
)paren
(brace
multiline_comment|/* Free all alocated memory. */
id|down_write
c_func
(paren
op_amp
id|ni-&gt;runlist.lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ni-&gt;runlist.rl
)paren
(brace
id|ntfs_free
c_func
(paren
id|ni-&gt;runlist.rl
)paren
suffix:semicolon
id|ni-&gt;runlist.rl
op_assign
l_int|NULL
suffix:semicolon
)brace
id|up_write
c_func
(paren
op_amp
id|ni-&gt;runlist.lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ni-&gt;attr_list
)paren
(brace
id|ntfs_free
c_func
(paren
id|ni-&gt;attr_list
)paren
suffix:semicolon
id|ni-&gt;attr_list
op_assign
l_int|NULL
suffix:semicolon
)brace
id|down_write
c_func
(paren
op_amp
id|ni-&gt;attr_list_rl.lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ni-&gt;attr_list_rl.rl
)paren
(brace
id|ntfs_free
c_func
(paren
id|ni-&gt;attr_list_rl.rl
)paren
suffix:semicolon
id|ni-&gt;attr_list_rl.rl
op_assign
l_int|NULL
suffix:semicolon
)brace
id|up_write
c_func
(paren
op_amp
id|ni-&gt;attr_list_rl.lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ni-&gt;name_len
op_logical_and
id|ni-&gt;name
op_ne
id|I30
)paren
(brace
multiline_comment|/* Catch bugs... */
id|BUG_ON
c_func
(paren
op_logical_neg
id|ni-&gt;name
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|ni-&gt;name
)paren
suffix:semicolon
)brace
)brace
DECL|function|ntfs_clear_extent_inode
r_void
id|ntfs_clear_extent_inode
c_func
(paren
id|ntfs_inode
op_star
id|ni
)paren
(brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Entering for inode 0x%lx.&quot;
comma
id|ni-&gt;mft_no
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|NInoAttr
c_func
(paren
id|ni
)paren
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|ni-&gt;nr_extents
op_ne
op_minus
l_int|1
)paren
suffix:semicolon
macro_line|#ifdef NTFS_RW
r_if
c_cond
(paren
id|NInoDirty
c_func
(paren
id|ni
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|is_bad_inode
c_func
(paren
id|VFS_I
c_func
(paren
id|ni-&gt;ext.base_ntfs_ino
)paren
)paren
)paren
id|ntfs_error
c_func
(paren
id|ni-&gt;vol-&gt;sb
comma
l_string|&quot;Clearing dirty extent inode!  &quot;
l_string|&quot;Losing data!  This is a BUG!!!&quot;
)paren
suffix:semicolon
singleline_comment|// FIXME:  Do something!!!
)brace
macro_line|#endif /* NTFS_RW */
id|__ntfs_clear_inode
c_func
(paren
id|ni
)paren
suffix:semicolon
multiline_comment|/* Bye, bye... */
id|ntfs_destroy_extent_inode
c_func
(paren
id|ni
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_clear_big_inode - clean up the ntfs specific part of an inode&n; * @vi:&t;&t;vfs inode pending annihilation&n; *&n; * When the VFS is going to remove an inode from memory, ntfs_clear_big_inode()&n; * is called, which deallocates all memory belonging to the NTFS specific part&n; * of the inode and returns.&n; *&n; * If the MFT record is dirty, we commit it before doing anything else.&n; */
DECL|function|ntfs_clear_big_inode
r_void
id|ntfs_clear_big_inode
c_func
(paren
r_struct
id|inode
op_star
id|vi
)paren
(brace
id|ntfs_inode
op_star
id|ni
op_assign
id|NTFS_I
c_func
(paren
id|vi
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If the inode @vi is an index inode we need to put the attribute&n;&t; * inode for the index bitmap, if it is present, otherwise the index&n;&t; * inode would disappear and the attribute inode for the index bitmap&n;&t; * would no longer be referenced from anywhere and thus it would remain&n;&t; * pinned for ever.&n;&t; */
r_if
c_cond
(paren
id|NInoAttr
c_func
(paren
id|ni
)paren
op_logical_and
(paren
id|ni-&gt;type
op_eq
id|AT_INDEX_ALLOCATION
)paren
op_logical_and
id|NInoIndexAllocPresent
c_func
(paren
id|ni
)paren
op_logical_and
id|ni-&gt;itype.index.bmp_ino
)paren
(brace
id|iput
c_func
(paren
id|ni-&gt;itype.index.bmp_ino
)paren
suffix:semicolon
id|ni-&gt;itype.index.bmp_ino
op_assign
l_int|NULL
suffix:semicolon
)brace
macro_line|#ifdef NTFS_RW
r_if
c_cond
(paren
id|NInoDirty
c_func
(paren
id|ni
)paren
)paren
(brace
id|BOOL
id|was_bad
op_assign
(paren
id|is_bad_inode
c_func
(paren
id|vi
)paren
)paren
suffix:semicolon
multiline_comment|/* Committing the inode also commits all extent inodes. */
id|ntfs_commit_inode
c_func
(paren
id|vi
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|was_bad
op_logical_and
(paren
id|is_bad_inode
c_func
(paren
id|vi
)paren
op_logical_or
id|NInoDirty
c_func
(paren
id|ni
)paren
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Failed to commit dirty inode &quot;
l_string|&quot;0x%lx.  Losing data!&quot;
comma
id|vi-&gt;i_ino
)paren
suffix:semicolon
singleline_comment|// FIXME:  Do something!!!
)brace
)brace
macro_line|#endif /* NTFS_RW */
multiline_comment|/* No need to lock at this stage as no one else has a reference. */
r_if
c_cond
(paren
id|ni-&gt;nr_extents
OG
l_int|0
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ni-&gt;nr_extents
suffix:semicolon
id|i
op_increment
)paren
id|ntfs_clear_extent_inode
c_func
(paren
id|ni-&gt;ext.extent_ntfs_inos
(braket
id|i
)braket
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|ni-&gt;ext.extent_ntfs_inos
)paren
suffix:semicolon
)brace
id|__ntfs_clear_inode
c_func
(paren
id|ni
)paren
suffix:semicolon
r_if
c_cond
(paren
id|NInoAttr
c_func
(paren
id|ni
)paren
)paren
(brace
multiline_comment|/* Release the base inode if we are holding it. */
r_if
c_cond
(paren
id|ni-&gt;nr_extents
op_eq
op_minus
l_int|1
)paren
(brace
id|iput
c_func
(paren
id|VFS_I
c_func
(paren
id|ni-&gt;ext.base_ntfs_ino
)paren
)paren
suffix:semicolon
id|ni-&gt;nr_extents
op_assign
l_int|0
suffix:semicolon
id|ni-&gt;ext.base_ntfs_ino
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_show_options - show mount options in /proc/mounts&n; * @sf:&t;&t;seq_file in which to write our mount options&n; * @mnt:&t;vfs mount whose mount options to display&n; *&n; * Called by the VFS once for each mounted ntfs volume when someone reads&n; * /proc/mounts in order to display the NTFS specific mount options of each&n; * mount. The mount options of the vfs mount @mnt are written to the seq file&n; * @sf and success is returned.&n; */
DECL|function|ntfs_show_options
r_int
id|ntfs_show_options
c_func
(paren
r_struct
id|seq_file
op_star
id|sf
comma
r_struct
id|vfsmount
op_star
id|mnt
)paren
(brace
id|ntfs_volume
op_star
id|vol
op_assign
id|NTFS_SB
c_func
(paren
id|mnt-&gt;mnt_sb
)paren
suffix:semicolon
r_int
id|i
suffix:semicolon
id|seq_printf
c_func
(paren
id|sf
comma
l_string|&quot;,uid=%i&quot;
comma
id|vol-&gt;uid
)paren
suffix:semicolon
id|seq_printf
c_func
(paren
id|sf
comma
l_string|&quot;,gid=%i&quot;
comma
id|vol-&gt;gid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vol-&gt;fmask
op_eq
id|vol-&gt;dmask
)paren
id|seq_printf
c_func
(paren
id|sf
comma
l_string|&quot;,umask=0%o&quot;
comma
id|vol-&gt;fmask
)paren
suffix:semicolon
r_else
(brace
id|seq_printf
c_func
(paren
id|sf
comma
l_string|&quot;,fmask=0%o&quot;
comma
id|vol-&gt;fmask
)paren
suffix:semicolon
id|seq_printf
c_func
(paren
id|sf
comma
l_string|&quot;,dmask=0%o&quot;
comma
id|vol-&gt;dmask
)paren
suffix:semicolon
)brace
id|seq_printf
c_func
(paren
id|sf
comma
l_string|&quot;,nls=%s&quot;
comma
id|vol-&gt;nls_map-&gt;charset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|NVolCaseSensitive
c_func
(paren
id|vol
)paren
)paren
id|seq_printf
c_func
(paren
id|sf
comma
l_string|&quot;,case_sensitive&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|NVolShowSystemFiles
c_func
(paren
id|vol
)paren
)paren
id|seq_printf
c_func
(paren
id|sf
comma
l_string|&quot;,show_sys_files&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|on_errors_arr
(braket
id|i
)braket
dot
id|val
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|on_errors_arr
(braket
id|i
)braket
dot
id|val
op_amp
id|vol-&gt;on_errors
)paren
id|seq_printf
c_func
(paren
id|sf
comma
l_string|&quot;,errors=%s&quot;
comma
id|on_errors_arr
(braket
id|i
)braket
dot
id|str
)paren
suffix:semicolon
)brace
id|seq_printf
c_func
(paren
id|sf
comma
l_string|&quot;,mft_zone_multiplier=%i&quot;
comma
id|vol-&gt;mft_zone_multiplier
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef NTFS_RW
multiline_comment|/**&n; * ntfs_truncate - called when the i_size of an ntfs inode is changed&n; * @vi:&t;&t;inode for which the i_size was changed&n; *&n; * We do not support i_size changes yet.&n; *&n; * The kernel guarantees that @vi is a regular file (S_ISREG() is true) and&n; * that the change is allowed.&n; *&n; * This implies for us that @vi is a file inode rather than a directory, index,&n; * or attribute inode as well as that @vi is a base inode.&n; *&n; * Returns 0 on success or -errno on error.&n; *&n; * Called with -&gt;i_sem held.  In all but one case -&gt;i_alloc_sem is held for&n; * writing.  The only case where -&gt;i_alloc_sem is not held is&n; * mm/filemap.c::generic_file_buffered_write() where vmtruncate() is called&n; * with the current i_size as the offset which means that it is a noop as far&n; * as ntfs_truncate() is concerned.&n; */
DECL|function|ntfs_truncate
r_int
id|ntfs_truncate
c_func
(paren
r_struct
id|inode
op_star
id|vi
)paren
(brace
id|ntfs_inode
op_star
id|ni
op_assign
id|NTFS_I
c_func
(paren
id|vi
)paren
suffix:semicolon
id|ntfs_volume
op_star
id|vol
op_assign
id|ni-&gt;vol
suffix:semicolon
id|ntfs_attr_search_ctx
op_star
id|ctx
suffix:semicolon
id|MFT_RECORD
op_star
id|m
suffix:semicolon
r_const
r_char
op_star
id|te
op_assign
l_string|&quot;  Leaving file length out of sync with i_size.&quot;
suffix:semicolon
r_int
id|err
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Entering for inode 0x%lx.&quot;
comma
id|vi-&gt;i_ino
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|NInoAttr
c_func
(paren
id|ni
)paren
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|ni-&gt;nr_extents
OL
l_int|0
)paren
suffix:semicolon
id|m
op_assign
id|map_mft_record
c_func
(paren
id|ni
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|m
)paren
)paren
(brace
id|err
op_assign
id|PTR_ERR
c_func
(paren
id|m
)paren
suffix:semicolon
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Failed to map mft record for inode 0x%lx &quot;
l_string|&quot;(error code %d).%s&quot;
comma
id|vi-&gt;i_ino
comma
id|err
comma
id|te
)paren
suffix:semicolon
id|ctx
op_assign
l_int|NULL
suffix:semicolon
id|m
op_assign
l_int|NULL
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
id|ctx
op_assign
id|ntfs_attr_get_search_ctx
c_func
(paren
id|ni
comma
id|m
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|ctx
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Failed to allocate a search context for &quot;
l_string|&quot;inode 0x%lx (not enough memory).%s&quot;
comma
id|vi-&gt;i_ino
comma
id|te
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
id|err
op_assign
id|ntfs_attr_lookup
c_func
(paren
id|ni-&gt;type
comma
id|ni-&gt;name
comma
id|ni-&gt;name_len
comma
id|CASE_SENSITIVE
comma
l_int|0
comma
l_int|NULL
comma
l_int|0
comma
id|ctx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|err
)paren
)paren
(brace
r_if
c_cond
(paren
id|err
op_eq
op_minus
id|ENOENT
)paren
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Open attribute is missing from &quot;
l_string|&quot;mft record.  Inode 0x%lx is corrupt.  &quot;
l_string|&quot;Run chkdsk.&quot;
comma
id|vi-&gt;i_ino
)paren
suffix:semicolon
r_else
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Failed to lookup attribute in &quot;
l_string|&quot;inode 0x%lx (error code %d).&quot;
comma
id|vi-&gt;i_ino
comma
id|err
)paren
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
multiline_comment|/* If the size has not changed there is nothing to do. */
r_if
c_cond
(paren
id|ntfs_attr_size
c_func
(paren
id|ctx-&gt;attr
)paren
op_eq
id|i_size_read
c_func
(paren
id|vi
)paren
)paren
r_goto
id|done
suffix:semicolon
singleline_comment|// TODO: Implement the truncate...
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Inode size has changed but this is not &quot;
l_string|&quot;implemented yet.  Resetting inode size to old value. &quot;
l_string|&quot; This is most likely a bug in the ntfs driver!&quot;
)paren
suffix:semicolon
id|i_size_write
c_func
(paren
id|vi
comma
id|ntfs_attr_size
c_func
(paren
id|ctx-&gt;attr
)paren
)paren
suffix:semicolon
id|done
suffix:colon
id|ntfs_attr_put_search_ctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
id|unmap_mft_record
c_func
(paren
id|ni
)paren
suffix:semicolon
id|NInoClearTruncateFailed
c_func
(paren
id|ni
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Done.&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|err_out
suffix:colon
r_if
c_cond
(paren
id|err
op_ne
op_minus
id|ENOMEM
)paren
(brace
id|NVolSetErrors
c_func
(paren
id|vol
)paren
suffix:semicolon
id|make_bad_inode
c_func
(paren
id|vi
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ctx
)paren
id|ntfs_attr_put_search_ctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|m
)paren
id|unmap_mft_record
c_func
(paren
id|ni
)paren
suffix:semicolon
id|NInoSetTruncateFailed
c_func
(paren
id|ni
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_truncate_vfs - wrapper for ntfs_truncate() that has no return value&n; * @vi:&t;&t;inode for which the i_size was changed&n; *&n; * Wrapper for ntfs_truncate() that has no return value.&n; *&n; * See ntfs_truncate() description above for details.&n; */
DECL|function|ntfs_truncate_vfs
r_void
id|ntfs_truncate_vfs
c_func
(paren
r_struct
id|inode
op_star
id|vi
)paren
(brace
id|ntfs_truncate
c_func
(paren
id|vi
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_setattr - called from notify_change() when an attribute is being changed&n; * @dentry:&t;dentry whose attributes to change&n; * @attr:&t;structure describing the attributes and the changes&n; *&n; * We have to trap VFS attempts to truncate the file described by @dentry as&n; * soon as possible, because we do not implement changes in i_size yet.  So we&n; * abort all i_size changes here.&n; *&n; * We also abort all changes of user, group, and mode as we do not implement&n; * the NTFS ACLs yet.&n; *&n; * Called with -&gt;i_sem held.  For the ATTR_SIZE (i.e. -&gt;truncate) case, also&n; * called with -&gt;i_alloc_sem held for writing.&n; *&n; * Basically this is a copy of generic notify_change() and inode_setattr()&n; * functionality, except we intercept and abort changes in i_size.&n; */
DECL|function|ntfs_setattr
r_int
id|ntfs_setattr
c_func
(paren
r_struct
id|dentry
op_star
id|dentry
comma
r_struct
id|iattr
op_star
id|attr
)paren
(brace
r_struct
id|inode
op_star
id|vi
op_assign
id|dentry-&gt;d_inode
suffix:semicolon
r_int
id|err
suffix:semicolon
r_int
r_int
id|ia_valid
op_assign
id|attr-&gt;ia_valid
suffix:semicolon
id|err
op_assign
id|inode_change_ok
c_func
(paren
id|vi
comma
id|attr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
multiline_comment|/* We do not support NTFS ACLs yet. */
r_if
c_cond
(paren
id|ia_valid
op_amp
(paren
id|ATTR_UID
op_or
id|ATTR_GID
op_or
id|ATTR_MODE
)paren
)paren
(brace
id|ntfs_warning
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Changes in user/group/mode are not &quot;
l_string|&quot;supported yet, ignoring.&quot;
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EOPNOTSUPP
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ia_valid
op_amp
id|ATTR_SIZE
)paren
(brace
r_if
c_cond
(paren
id|attr-&gt;ia_size
op_ne
id|i_size_read
c_func
(paren
id|vi
)paren
)paren
(brace
id|ntfs_warning
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Changes in inode size are not &quot;
l_string|&quot;supported yet, ignoring.&quot;
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EOPNOTSUPP
suffix:semicolon
singleline_comment|// TODO: Implement...
singleline_comment|// err = vmtruncate(vi, attr-&gt;ia_size);
r_if
c_cond
(paren
id|err
op_logical_or
id|ia_valid
op_eq
id|ATTR_SIZE
)paren
r_goto
id|out
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; * We skipped the truncate but must still update&n;&t;&t;&t; * timestamps.&n;&t;&t;&t; */
id|ia_valid
op_or_assign
id|ATTR_MTIME
op_or
id|ATTR_CTIME
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|ia_valid
op_amp
id|ATTR_ATIME
)paren
id|vi-&gt;i_atime
op_assign
id|attr-&gt;ia_atime
suffix:semicolon
r_if
c_cond
(paren
id|ia_valid
op_amp
id|ATTR_MTIME
)paren
id|vi-&gt;i_mtime
op_assign
id|attr-&gt;ia_mtime
suffix:semicolon
r_if
c_cond
(paren
id|ia_valid
op_amp
id|ATTR_CTIME
)paren
id|vi-&gt;i_ctime
op_assign
id|attr-&gt;ia_ctime
suffix:semicolon
id|mark_inode_dirty
c_func
(paren
id|vi
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_write_inode - write out a dirty inode&n; * @vi:&t;&t;inode to write out&n; * @sync:&t;if true, write out synchronously&n; *&n; * Write out a dirty inode to disk including any extent inodes if present.&n; *&n; * If @sync is true, commit the inode to disk and wait for io completion.  This&n; * is done using write_mft_record().&n; *&n; * If @sync is false, just schedule the write to happen but do not wait for i/o&n; * completion.  In 2.6 kernels, scheduling usually happens just by virtue of&n; * marking the page (and in this case mft record) dirty but we do not implement&n; * this yet as write_mft_record() largely ignores the @sync parameter and&n; * always performs synchronous writes.&n; *&n; * Return 0 on success and -errno on error.&n; */
DECL|function|ntfs_write_inode
r_int
id|ntfs_write_inode
c_func
(paren
r_struct
id|inode
op_star
id|vi
comma
r_int
id|sync
)paren
(brace
id|sle64
id|nt
suffix:semicolon
id|ntfs_inode
op_star
id|ni
op_assign
id|NTFS_I
c_func
(paren
id|vi
)paren
suffix:semicolon
id|ntfs_attr_search_ctx
op_star
id|ctx
suffix:semicolon
id|MFT_RECORD
op_star
id|m
suffix:semicolon
id|STANDARD_INFORMATION
op_star
id|si
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
id|BOOL
id|modified
op_assign
id|FALSE
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Entering for %sinode 0x%lx.&quot;
comma
id|NInoAttr
c_func
(paren
id|ni
)paren
ques
c_cond
l_string|&quot;attr &quot;
suffix:colon
l_string|&quot;&quot;
comma
id|vi-&gt;i_ino
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Dirty attribute inodes are written via their real inodes so just&n;&t; * clean them here.  Access time updates are taken care off when the&n;&t; * real inode is written.&n;&t; */
r_if
c_cond
(paren
id|NInoAttr
c_func
(paren
id|ni
)paren
)paren
(brace
id|NInoClearDirty
c_func
(paren
id|ni
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Done.&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Map, pin, and lock the mft record belonging to the inode. */
id|m
op_assign
id|map_mft_record
c_func
(paren
id|ni
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|m
)paren
)paren
(brace
id|err
op_assign
id|PTR_ERR
c_func
(paren
id|m
)paren
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
multiline_comment|/* Update the access times in the standard information attribute. */
id|ctx
op_assign
id|ntfs_attr_get_search_ctx
c_func
(paren
id|ni
comma
id|m
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|ctx
)paren
)paren
(brace
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
id|err
op_assign
id|ntfs_attr_lookup
c_func
(paren
id|AT_STANDARD_INFORMATION
comma
l_int|NULL
comma
l_int|0
comma
id|CASE_SENSITIVE
comma
l_int|0
comma
l_int|NULL
comma
l_int|0
comma
id|ctx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|err
)paren
)paren
(brace
id|ntfs_attr_put_search_ctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
id|si
op_assign
(paren
id|STANDARD_INFORMATION
op_star
)paren
(paren
(paren
id|u8
op_star
)paren
id|ctx-&gt;attr
op_plus
id|le16_to_cpu
c_func
(paren
id|ctx-&gt;attr-&gt;data.resident.value_offset
)paren
)paren
suffix:semicolon
multiline_comment|/* Update the access times if they have changed. */
id|nt
op_assign
id|utc2ntfs
c_func
(paren
id|vi-&gt;i_mtime
)paren
suffix:semicolon
r_if
c_cond
(paren
id|si-&gt;last_data_change_time
op_ne
id|nt
)paren
(brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Updating mtime for inode 0x%lx: old = 0x%llx, &quot;
l_string|&quot;new = 0x%llx&quot;
comma
id|vi-&gt;i_ino
comma
id|sle64_to_cpu
c_func
(paren
id|si-&gt;last_data_change_time
)paren
comma
id|sle64_to_cpu
c_func
(paren
id|nt
)paren
)paren
suffix:semicolon
id|si-&gt;last_data_change_time
op_assign
id|nt
suffix:semicolon
id|modified
op_assign
id|TRUE
suffix:semicolon
)brace
id|nt
op_assign
id|utc2ntfs
c_func
(paren
id|vi-&gt;i_ctime
)paren
suffix:semicolon
r_if
c_cond
(paren
id|si-&gt;last_mft_change_time
op_ne
id|nt
)paren
(brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Updating ctime for inode 0x%lx: old = 0x%llx, &quot;
l_string|&quot;new = 0x%llx&quot;
comma
id|vi-&gt;i_ino
comma
id|sle64_to_cpu
c_func
(paren
id|si-&gt;last_mft_change_time
)paren
comma
id|sle64_to_cpu
c_func
(paren
id|nt
)paren
)paren
suffix:semicolon
id|si-&gt;last_mft_change_time
op_assign
id|nt
suffix:semicolon
id|modified
op_assign
id|TRUE
suffix:semicolon
)brace
id|nt
op_assign
id|utc2ntfs
c_func
(paren
id|vi-&gt;i_atime
)paren
suffix:semicolon
r_if
c_cond
(paren
id|si-&gt;last_access_time
op_ne
id|nt
)paren
(brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Updating atime for inode 0x%lx: old = 0x%llx, &quot;
l_string|&quot;new = 0x%llx&quot;
comma
id|vi-&gt;i_ino
comma
id|sle64_to_cpu
c_func
(paren
id|si-&gt;last_access_time
)paren
comma
id|sle64_to_cpu
c_func
(paren
id|nt
)paren
)paren
suffix:semicolon
id|si-&gt;last_access_time
op_assign
id|nt
suffix:semicolon
id|modified
op_assign
id|TRUE
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If we just modified the standard information attribute we need to&n;&t; * mark the mft record it is in dirty.  We do this manually so that&n;&t; * mark_inode_dirty() is not called which would redirty the inode and&n;&t; * hence result in an infinite loop of trying to write the inode.&n;&t; * There is no need to mark the base inode nor the base mft record&n;&t; * dirty, since we are going to write this mft record below in any case&n;&t; * and the base mft record may actually not have been modified so it&n;&t; * might not need to be written out.&n;&t; * NOTE: It is not a problem when the inode for $MFT itself is being&n;&t; * written out as mark_ntfs_record_dirty() will only set I_DIRTY_PAGES&n;&t; * on the $MFT inode and hence ntfs_write_inode() will not be&n;&t; * re-invoked because of it which in turn is ok since the dirtied mft&n;&t; * record will be cleaned and written out to disk below, i.e. before&n;&t; * this function returns.&n;&t; */
r_if
c_cond
(paren
id|modified
op_logical_and
op_logical_neg
id|NInoTestSetDirty
c_func
(paren
id|ctx-&gt;ntfs_ino
)paren
)paren
id|mark_ntfs_record_dirty
c_func
(paren
id|ctx-&gt;ntfs_ino-&gt;page
comma
id|ctx-&gt;ntfs_ino-&gt;page_ofs
)paren
suffix:semicolon
id|ntfs_attr_put_search_ctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
multiline_comment|/* Now the access times are updated, write the base mft record. */
r_if
c_cond
(paren
id|NInoDirty
c_func
(paren
id|ni
)paren
)paren
id|err
op_assign
id|write_mft_record
c_func
(paren
id|ni
comma
id|m
comma
id|sync
)paren
suffix:semicolon
multiline_comment|/* Write all attached extent mft records. */
id|down
c_func
(paren
op_amp
id|ni-&gt;extent_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ni-&gt;nr_extents
OG
l_int|0
)paren
(brace
id|ntfs_inode
op_star
op_star
id|extent_nis
op_assign
id|ni-&gt;ext.extent_ntfs_inos
suffix:semicolon
r_int
id|i
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Writing %i extent inodes.&quot;
comma
id|ni-&gt;nr_extents
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ni-&gt;nr_extents
suffix:semicolon
id|i
op_increment
)paren
(brace
id|ntfs_inode
op_star
id|tni
op_assign
id|extent_nis
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|NInoDirty
c_func
(paren
id|tni
)paren
)paren
(brace
id|MFT_RECORD
op_star
id|tm
op_assign
id|map_mft_record
c_func
(paren
id|tni
)paren
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|tm
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|err
op_logical_or
id|err
op_eq
op_minus
id|ENOMEM
)paren
id|err
op_assign
id|PTR_ERR
c_func
(paren
id|tm
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|ret
op_assign
id|write_mft_record
c_func
(paren
id|tni
comma
id|tm
comma
id|sync
)paren
suffix:semicolon
id|unmap_mft_record
c_func
(paren
id|tni
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|ret
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|err
op_logical_or
id|err
op_eq
op_minus
id|ENOMEM
)paren
id|err
op_assign
id|ret
suffix:semicolon
)brace
)brace
)brace
)brace
id|up
c_func
(paren
op_amp
id|ni-&gt;extent_lock
)paren
suffix:semicolon
id|unmap_mft_record
c_func
(paren
id|ni
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|err
)paren
)paren
r_goto
id|err_out
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Done.&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|unm_err_out
suffix:colon
id|unmap_mft_record
c_func
(paren
id|ni
)paren
suffix:semicolon
id|err_out
suffix:colon
r_if
c_cond
(paren
id|err
op_eq
op_minus
id|ENOMEM
)paren
(brace
id|ntfs_warning
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Not enough memory to write inode.  &quot;
l_string|&quot;Marking the inode dirty again, so the VFS &quot;
l_string|&quot;retries later.&quot;
)paren
suffix:semicolon
id|mark_inode_dirty
c_func
(paren
id|vi
)paren
suffix:semicolon
)brace
r_else
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Failed (error code %i):  Marking inode &quot;
l_string|&quot;as bad.  You should run chkdsk.&quot;
comma
op_minus
id|err
)paren
suffix:semicolon
id|make_bad_inode
c_func
(paren
id|vi
)paren
suffix:semicolon
id|NVolSetErrors
c_func
(paren
id|ni-&gt;vol
)paren
suffix:semicolon
)brace
r_return
id|err
suffix:semicolon
)brace
macro_line|#endif /* NTFS_RW */
eof
