multiline_comment|/**&n; * inode.c - NTFS kernel inode handling. Part of the Linux-NTFS project.&n; *&n; * Copyright (c) 2001,2002 Anton Altaparmakov.&n; *&n; * This program/include file is free software; you can redistribute it and/or&n; * modify it under the terms of the GNU General Public License as published&n; * by the Free Software Foundation; either version 2 of the License, or&n; * (at your option) any later version.&n; *&n; * This program/include file is distributed in the hope that it will be &n; * useful, but WITHOUT ANY WARRANTY; without even the implied warranty &n; * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; * GNU General Public License for more details.&n; *&n; * You should have received a copy of the GNU General Public License&n; * along with this program (in the main directory of the Linux-NTFS &n; * distribution in the file COPYING); if not, write to the Free Software&n; * Foundation,Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA&n; */
macro_line|#include &lt;linux/pagemap.h&gt;
macro_line|#include &lt;linux/buffer_head.h&gt;
macro_line|#include &quot;ntfs.h&quot;
macro_line|#include &quot;dir.h&quot;
macro_line|#include &quot;inode.h&quot;
macro_line|#include &quot;attrib.h&quot;
multiline_comment|/**&n; * ntfs_attr - ntfs in memory attribute structure&n; * @mft_no:&t;mft record number of the base mft record of this attribute&n; * @name:&t;Unicode name of the attribute (NULL if unnamed)&n; * @name_len:&t;length of @name in Unicode characters (0 if unnamed)&n; * @type:&t;attribute type (see layout.h)&n; *&n; * This structure exists only to provide a small structure for the&n; * ntfs_{attr_}iget()/ntfs_test_inode()/ntfs_init_locked_inode() mechanism.&n; *&n; * NOTE: Elements are ordered by size to make the structure as compact as&n; * possible on all architectures.&n; */
r_typedef
r_struct
(brace
DECL|member|mft_no
r_int
r_int
id|mft_no
suffix:semicolon
DECL|member|name
id|uchar_t
op_star
id|name
suffix:semicolon
DECL|member|name_len
id|u32
id|name_len
suffix:semicolon
DECL|member|type
id|ATTR_TYPES
id|type
suffix:semicolon
DECL|typedef|ntfs_attr
)brace
id|ntfs_attr
suffix:semicolon
multiline_comment|/**&n; * ntfs_test_inode - compare two (possibly fake) inodes for equality&n; * @vi:&t;&t;vfs inode which to test&n; * @na:&t;&t;ntfs attribute which is being tested with&n; *&n; * Compare the ntfs attribute embedded in the ntfs specific part of the vfs&n; * inode @vi for equality with the ntfs attribute @na.&n; *&n; * If searching for the normal file/directory inode, set @na-&gt;type to AT_UNUSED.&n; * @na-&gt;name and @na-&gt;name_len are then ignored.&n; *&n; * Return 1 if the attributes match and 0 if not.&n; *&n; * NOTE: This function runs with the inode_lock spin lock held so it is not&n; * allowed to sleep.&n; */
DECL|function|ntfs_test_inode
r_static
r_int
id|ntfs_test_inode
c_func
(paren
r_struct
id|inode
op_star
id|vi
comma
id|ntfs_attr
op_star
id|na
)paren
(brace
id|ntfs_inode
op_star
id|ni
suffix:semicolon
r_if
c_cond
(paren
id|vi-&gt;i_ino
op_ne
id|na-&gt;mft_no
)paren
r_return
l_int|0
suffix:semicolon
id|ni
op_assign
id|NTFS_I
c_func
(paren
id|vi
)paren
suffix:semicolon
multiline_comment|/* If !NInoAttr(ni), @vi is a normal file or directory inode. */
r_if
c_cond
(paren
id|likely
c_func
(paren
op_logical_neg
id|NInoAttr
c_func
(paren
id|ni
)paren
)paren
)paren
(brace
multiline_comment|/* If not looking for a normal inode this is a mismatch. */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|na-&gt;type
op_ne
id|AT_UNUSED
)paren
)paren
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* A fake inode describing an attribute. */
r_if
c_cond
(paren
id|ni-&gt;type
op_ne
id|na-&gt;type
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ni-&gt;name_len
op_ne
id|na-&gt;name_len
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|na-&gt;name_len
op_logical_and
id|memcmp
c_func
(paren
id|ni-&gt;name
comma
id|na-&gt;name
comma
id|na-&gt;name_len
op_star
r_sizeof
(paren
id|uchar_t
)paren
)paren
)paren
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Match! */
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_init_locked_inode - initialize an inode&n; * @vi:&t;&t;vfs inode to initialize&n; * @na:&t;&t;ntfs attribute which to initialize @vi to&n; *&n; * Initialize the vfs inode @vi with the values from the ntfs attribute @na in&n; * order to enable ntfs_test_inode() to do its work.&n; *&n; * If initializing the normal file/directory inode, set @na-&gt;type to AT_UNUSED.&n; * In that case, @na-&gt;name and @na-&gt;name_len should be set to NULL and 0,&n; * respectively. Although that is not strictly necessary as&n; * ntfs_read_inode_locked() will fill them in later.&n; *&n; * Return 0 on success and -errno on error.&n; *&n; * NOTE: This function runs with the inode_lock spin lock held so it is not&n; * allowed to sleep. (Hence the GFP_ATOMIC allocation.)&n; */
DECL|function|ntfs_init_locked_inode
r_static
r_int
id|ntfs_init_locked_inode
c_func
(paren
r_struct
id|inode
op_star
id|vi
comma
id|ntfs_attr
op_star
id|na
)paren
(brace
id|ntfs_inode
op_star
id|ni
op_assign
id|NTFS_I
c_func
(paren
id|vi
)paren
suffix:semicolon
id|vi-&gt;i_ino
op_assign
id|na-&gt;mft_no
suffix:semicolon
id|ni-&gt;type
op_assign
id|na-&gt;type
suffix:semicolon
r_if
c_cond
(paren
id|na-&gt;type
op_eq
id|AT_INDEX_ALLOCATION
)paren
id|NInoSetMstProtected
c_func
(paren
id|ni
)paren
suffix:semicolon
id|ni-&gt;name
op_assign
id|na-&gt;name
suffix:semicolon
id|ni-&gt;name_len
op_assign
id|na-&gt;name_len
suffix:semicolon
multiline_comment|/* If initializing a normal inode, we are done. */
r_if
c_cond
(paren
id|likely
c_func
(paren
id|na-&gt;type
op_eq
id|AT_UNUSED
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* It is a fake inode. */
id|NInoSetAttr
c_func
(paren
id|ni
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We have I30 global constant as an optimization as it is the name&n;&t; * in &gt;99.9% of named attributes! The other &lt;0.1% incur a GFP_ATOMIC&n;&t; * allocation but that is ok. And most attributes are unnamed anyway,&n;&t; * thus the fraction of named attributes with name != I30 is actually&n;&t; * absolutely tiny.&n;&t; */
r_if
c_cond
(paren
id|na-&gt;name
op_logical_and
id|na-&gt;name_len
op_logical_and
id|na-&gt;name
op_ne
id|I30
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
id|i
op_assign
id|na-&gt;name_len
op_star
r_sizeof
(paren
id|uchar_t
)paren
suffix:semicolon
id|ni-&gt;name
op_assign
(paren
id|uchar_t
op_star
)paren
id|kmalloc
c_func
(paren
id|i
op_plus
r_sizeof
(paren
id|uchar_t
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ni-&gt;name
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|memcpy
c_func
(paren
id|ni-&gt;name
comma
id|na-&gt;name
comma
id|i
)paren
suffix:semicolon
id|ni-&gt;name
(braket
id|i
)braket
op_assign
id|cpu_to_le16
c_func
(paren
l_char|&squot;&bslash;0&squot;
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|typedef|test_t
r_typedef
r_int
(paren
op_star
id|test_t
)paren
(paren
r_struct
id|inode
op_star
comma
r_void
op_star
)paren
suffix:semicolon
DECL|typedef|set_t
r_typedef
r_int
(paren
op_star
id|set_t
)paren
(paren
r_struct
id|inode
op_star
comma
r_void
op_star
)paren
suffix:semicolon
r_static
r_int
id|ntfs_read_locked_inode
c_func
(paren
r_struct
id|inode
op_star
id|vi
)paren
suffix:semicolon
r_static
r_int
id|ntfs_read_locked_attr_inode
c_func
(paren
r_struct
id|inode
op_star
id|base_vi
comma
r_struct
id|inode
op_star
id|vi
)paren
suffix:semicolon
multiline_comment|/**&n; * ntfs_iget - obtain a struct inode corresponding to a specific normal inode&n; * @sb:&t;&t;super block of mounted volume&n; * @mft_no:&t;mft record number / inode number to obtain&n; *&n; * Obtain the struct inode corresponding to a specific normal inode (i.e. a&n; * file or directory).&n; *&n; * If the inode is in the cache, it is just returned with an increased&n; * reference count. Otherwise, a new struct inode is allocated and initialized,&n; * and finally ntfs_read_locked_inode() is called to read in the inode and&n; * fill in the remainder of the inode structure.&n; *&n; * Return the struct inode on success. Check the return value with IS_ERR() and&n; * if true, the function failed and the error code is obtained from PTR_ERR().&n; */
DECL|function|ntfs_iget
r_struct
id|inode
op_star
id|ntfs_iget
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_int
r_int
id|mft_no
)paren
(brace
r_struct
id|inode
op_star
id|vi
suffix:semicolon
id|ntfs_attr
id|na
suffix:semicolon
r_int
id|err
suffix:semicolon
id|na.mft_no
op_assign
id|mft_no
suffix:semicolon
id|na.type
op_assign
id|AT_UNUSED
suffix:semicolon
id|na.name
op_assign
l_int|NULL
suffix:semicolon
id|na.name_len
op_assign
l_int|0
suffix:semicolon
id|vi
op_assign
id|iget5_locked
c_func
(paren
id|sb
comma
id|mft_no
comma
(paren
id|test_t
)paren
id|ntfs_test_inode
comma
(paren
id|set_t
)paren
id|ntfs_init_locked_inode
comma
op_amp
id|na
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vi
)paren
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* If this is a freshly allocated inode, need to read it now. */
r_if
c_cond
(paren
id|vi-&gt;i_state
op_amp
id|I_NEW
)paren
(brace
id|err
op_assign
id|ntfs_read_locked_inode
c_func
(paren
id|vi
)paren
suffix:semicolon
id|unlock_new_inode
c_func
(paren
id|vi
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * There is no point in keeping bad inodes around if the failure was&n;&t; * due to ENOMEM. We want to be able to retry again layer.&n;&t; */
r_if
c_cond
(paren
id|err
op_eq
op_minus
id|ENOMEM
)paren
(brace
id|iput
c_func
(paren
id|vi
)paren
suffix:semicolon
id|vi
op_assign
id|ERR_PTR
c_func
(paren
id|err
)paren
suffix:semicolon
)brace
r_return
id|vi
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_attr_iget - obtain a struct inode corresponding to an attribute&n; * @base_vi:&t;vfs base inode containing the attribute&n; * @type:&t;attribute type&n; * @name:&t;Unicode name of the attribute (NULL if unnamed)&n; * @name_len:&t;length of @name in Unicode characters (0 if unnamed)&n; *&n; * Obtain the (fake) struct inode corresponding to the attribute specified by&n; * @type, @name, and @name_len, which is present in the base mft record&n; * specified by the vfs inode @base_vi.&n; *&n; * If the attribute inode is in the cache, it is just returned with an&n; * increased reference count. Otherwise, a new struct inode is allocated and&n; * initialized, and finally ntfs_read_locked_attr_inode() is called to read the&n; * attribute and fill in the inode structure.&n; *&n; * Return the struct inode of the attribute inode on success. Check the return&n; * value with IS_ERR() and if true, the function failed and the error code is&n; * obtained from PTR_ERR().&n; */
DECL|function|ntfs_attr_iget
r_struct
id|inode
op_star
id|ntfs_attr_iget
c_func
(paren
r_struct
id|inode
op_star
id|base_vi
comma
id|ATTR_TYPES
id|type
comma
id|uchar_t
op_star
id|name
comma
id|u32
id|name_len
)paren
(brace
r_struct
id|inode
op_star
id|vi
suffix:semicolon
id|ntfs_attr
id|na
suffix:semicolon
r_int
id|err
suffix:semicolon
id|na.mft_no
op_assign
id|base_vi-&gt;i_ino
suffix:semicolon
id|na.type
op_assign
id|type
suffix:semicolon
id|na.name
op_assign
id|name
suffix:semicolon
id|na.name_len
op_assign
id|name_len
suffix:semicolon
id|vi
op_assign
id|iget5_locked
c_func
(paren
id|base_vi-&gt;i_sb
comma
id|na.mft_no
comma
(paren
id|test_t
)paren
id|ntfs_test_inode
comma
(paren
id|set_t
)paren
id|ntfs_init_locked_inode
comma
op_amp
id|na
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vi
)paren
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* If this is a freshly allocated inode, need to read it now. */
r_if
c_cond
(paren
id|vi-&gt;i_state
op_amp
id|I_NEW
)paren
(brace
id|err
op_assign
id|ntfs_read_locked_attr_inode
c_func
(paren
id|base_vi
comma
id|vi
)paren
suffix:semicolon
id|unlock_new_inode
c_func
(paren
id|vi
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * There is no point in keeping bad attribute inodes around. This also&n;&t; * simplifies things in that we never need to check for bad attribute&n;&t; * inodes elsewhere.&n;&t; */
r_if
c_cond
(paren
id|err
)paren
(brace
id|iput
c_func
(paren
id|vi
)paren
suffix:semicolon
id|vi
op_assign
id|ERR_PTR
c_func
(paren
id|err
)paren
suffix:semicolon
)brace
r_return
id|vi
suffix:semicolon
)brace
DECL|function|ntfs_alloc_big_inode
r_struct
id|inode
op_star
id|ntfs_alloc_big_inode
c_func
(paren
r_struct
id|super_block
op_star
id|sb
)paren
(brace
id|ntfs_inode
op_star
id|ni
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Entering.&quot;
)paren
suffix:semicolon
id|ni
op_assign
(paren
id|ntfs_inode
op_star
)paren
id|kmem_cache_alloc
c_func
(paren
id|ntfs_big_inode_cache
comma
id|SLAB_NOFS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
id|ni
op_ne
l_int|NULL
)paren
)paren
(brace
id|ni-&gt;state
op_assign
l_int|0
suffix:semicolon
r_return
id|VFS_I
c_func
(paren
id|ni
)paren
suffix:semicolon
)brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Allocation of NTFS big inode structure failed.&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|ntfs_destroy_big_inode
r_void
id|ntfs_destroy_big_inode
c_func
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
id|ntfs_inode
op_star
id|ni
op_assign
id|NTFS_I
c_func
(paren
id|inode
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Entering.&quot;
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|atomic_read
c_func
(paren
op_amp
id|ni-&gt;mft_count
)paren
op_logical_or
op_logical_neg
id|atomic_dec_and_test
c_func
(paren
op_amp
id|ni-&gt;count
)paren
)paren
suffix:semicolon
id|kmem_cache_free
c_func
(paren
id|ntfs_big_inode_cache
comma
id|NTFS_I
c_func
(paren
id|inode
)paren
)paren
suffix:semicolon
)brace
DECL|function|ntfs_alloc_extent_inode
r_static
id|ntfs_inode
op_star
id|ntfs_alloc_extent_inode
c_func
(paren
r_void
)paren
(brace
id|ntfs_inode
op_star
id|ni
op_assign
(paren
id|ntfs_inode
op_star
)paren
id|kmem_cache_alloc
c_func
(paren
id|ntfs_inode_cache
comma
id|SLAB_NOFS
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Entering.&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
id|ni
op_ne
l_int|NULL
)paren
)paren
(brace
id|ni-&gt;state
op_assign
l_int|0
suffix:semicolon
r_return
id|ni
suffix:semicolon
)brace
id|ntfs_error
c_func
(paren
l_int|NULL
comma
l_string|&quot;Allocation of NTFS inode structure failed.&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|ntfs_destroy_extent_inode
r_void
id|ntfs_destroy_extent_inode
c_func
(paren
id|ntfs_inode
op_star
id|ni
)paren
(brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Entering.&quot;
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|atomic_read
c_func
(paren
op_amp
id|ni-&gt;mft_count
)paren
op_logical_or
op_logical_neg
id|atomic_dec_and_test
c_func
(paren
op_amp
id|ni-&gt;count
)paren
)paren
suffix:semicolon
id|kmem_cache_free
c_func
(paren
id|ntfs_inode_cache
comma
id|ni
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * __ntfs_init_inode - initialize ntfs specific part of an inode&n; * @sb:&t;&t;super block of mounted volume&n; * @ni:&t;&t;freshly allocated ntfs inode which to initialize&n; *&n; * Initialize an ntfs inode to defaults.&n; *&n; * NOTE: ni-&gt;mft_no, ni-&gt;state, ni-&gt;type, ni-&gt;name, and ni-&gt;name_len are left&n; * untouched. Make sure to initialize them elsewhere.&n; *&n; * Return zero on success and -ENOMEM on error.&n; */
DECL|function|__ntfs_init_inode
r_static
r_void
id|__ntfs_init_inode
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
id|ntfs_inode
op_star
id|ni
)paren
(brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Entering.&quot;
)paren
suffix:semicolon
id|ni-&gt;initialized_size
op_assign
id|ni-&gt;allocated_size
op_assign
l_int|0
suffix:semicolon
id|ni-&gt;seq_no
op_assign
l_int|0
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|ni-&gt;count
comma
l_int|1
)paren
suffix:semicolon
id|ni-&gt;vol
op_assign
id|NTFS_SB
c_func
(paren
id|sb
)paren
suffix:semicolon
id|init_run_list
c_func
(paren
op_amp
id|ni-&gt;run_list
)paren
suffix:semicolon
id|init_rwsem
c_func
(paren
op_amp
id|ni-&gt;mrec_lock
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|ni-&gt;mft_count
comma
l_int|0
)paren
suffix:semicolon
id|ni-&gt;page
op_assign
l_int|NULL
suffix:semicolon
id|ni-&gt;page_ofs
op_assign
l_int|0
suffix:semicolon
id|ni-&gt;attr_list_size
op_assign
l_int|0
suffix:semicolon
id|ni-&gt;attr_list
op_assign
l_int|NULL
suffix:semicolon
id|init_run_list
c_func
(paren
op_amp
id|ni-&gt;attr_list_rl
)paren
suffix:semicolon
id|ni
op_member_access_from_pointer
id|_IDM
c_func
(paren
id|index_block_size
)paren
op_assign
l_int|0
suffix:semicolon
id|ni
op_member_access_from_pointer
id|_IDM
c_func
(paren
id|index_vcn_size
)paren
op_assign
l_int|0
suffix:semicolon
id|ni
op_member_access_from_pointer
id|_IDM
c_func
(paren
id|bmp_size
)paren
op_assign
l_int|0
suffix:semicolon
id|ni
op_member_access_from_pointer
id|_IDM
c_func
(paren
id|bmp_initialized_size
)paren
op_assign
l_int|0
suffix:semicolon
id|ni
op_member_access_from_pointer
id|_IDM
c_func
(paren
id|bmp_allocated_size
)paren
op_assign
l_int|0
suffix:semicolon
id|init_run_list
c_func
(paren
op_amp
id|ni
op_member_access_from_pointer
id|_IDM
c_func
(paren
id|bmp_rl
)paren
)paren
suffix:semicolon
id|ni
op_member_access_from_pointer
id|_IDM
c_func
(paren
id|index_block_size_bits
)paren
op_assign
l_int|0
suffix:semicolon
id|ni
op_member_access_from_pointer
id|_IDM
c_func
(paren
id|index_vcn_size_bits
)paren
op_assign
l_int|0
suffix:semicolon
id|init_MUTEX
c_func
(paren
op_amp
id|ni-&gt;extent_lock
)paren
suffix:semicolon
id|ni-&gt;nr_extents
op_assign
l_int|0
suffix:semicolon
id|ni
op_member_access_from_pointer
id|_INE
c_func
(paren
id|base_ntfs_ino
)paren
op_assign
l_int|NULL
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|function|ntfs_init_big_inode
r_static
r_void
id|ntfs_init_big_inode
c_func
(paren
r_struct
id|inode
op_star
id|vi
)paren
(brace
id|ntfs_inode
op_star
id|ni
op_assign
id|NTFS_I
c_func
(paren
id|vi
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Entering.&quot;
)paren
suffix:semicolon
id|__ntfs_init_inode
c_func
(paren
id|vi-&gt;i_sb
comma
id|ni
)paren
suffix:semicolon
id|ni-&gt;mft_no
op_assign
id|vi-&gt;i_ino
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|function|ntfs_new_extent_inode
id|ntfs_inode
op_star
id|ntfs_new_extent_inode
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_int
r_int
id|mft_no
)paren
(brace
id|ntfs_inode
op_star
id|ni
op_assign
id|ntfs_alloc_extent_inode
c_func
(paren
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Entering.&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
id|ni
op_ne
l_int|NULL
)paren
)paren
(brace
id|__ntfs_init_inode
c_func
(paren
id|sb
comma
id|ni
)paren
suffix:semicolon
id|ni-&gt;mft_no
op_assign
id|mft_no
suffix:semicolon
id|ni-&gt;type
op_assign
id|AT_UNUSED
suffix:semicolon
id|ni-&gt;name
op_assign
l_int|NULL
suffix:semicolon
id|ni-&gt;name_len
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|ni
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_is_extended_system_file - check if a file is in the $Extend directory&n; * @ctx:&t;initialized attribute search context&n; *&n; * Search all file name attributes in the inode described by the attribute&n; * search context @ctx and check if any of the names are in the $Extend system&n; * directory.&n; * &n; * Return values:&n; *&t;   1: file is in $Extend directory&n; *&t;   0: file is not in $Extend directory&n; *&t;-EIO: file is corrupt&n; */
DECL|function|ntfs_is_extended_system_file
r_static
r_int
id|ntfs_is_extended_system_file
c_func
(paren
id|attr_search_context
op_star
id|ctx
)paren
(brace
r_int
id|nr_links
suffix:semicolon
multiline_comment|/* Restart search. */
id|reinit_attr_search_ctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
multiline_comment|/* Get number of hard links. */
id|nr_links
op_assign
id|le16_to_cpu
c_func
(paren
id|ctx-&gt;mrec-&gt;link_count
)paren
suffix:semicolon
multiline_comment|/* Loop through all hard links. */
r_while
c_loop
(paren
id|lookup_attr
c_func
(paren
id|AT_FILE_NAME
comma
l_int|NULL
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|NULL
comma
l_int|0
comma
id|ctx
)paren
)paren
(brace
id|FILE_NAME_ATTR
op_star
id|file_name_attr
suffix:semicolon
id|ATTR_RECORD
op_star
id|attr
op_assign
id|ctx-&gt;attr
suffix:semicolon
id|u8
op_star
id|p
comma
op_star
id|p2
suffix:semicolon
id|nr_links
op_decrement
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Maximum sanity checking as we are called on an inode that&n;&t;&t; * we suspect might be corrupt.&n;&t;&t; */
id|p
op_assign
(paren
id|u8
op_star
)paren
id|attr
op_plus
id|le32_to_cpu
c_func
(paren
id|attr-&gt;length
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
template_param
(paren
id|u8
op_star
)paren
id|ctx-&gt;mrec
op_plus
id|le32_to_cpu
c_func
(paren
id|ctx-&gt;mrec-&gt;bytes_in_use
)paren
)paren
(brace
id|err_corrupt_attr
suffix:colon
id|ntfs_error
c_func
(paren
id|ctx-&gt;ntfs_ino-&gt;vol-&gt;sb
comma
l_string|&quot;Corrupt file name &quot;
l_string|&quot;attribute. You should run chkdsk.&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_if
c_cond
(paren
id|attr-&gt;non_resident
)paren
(brace
id|ntfs_error
c_func
(paren
id|ctx-&gt;ntfs_ino-&gt;vol-&gt;sb
comma
l_string|&quot;Non-resident file &quot;
l_string|&quot;name. You should run chkdsk.&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_if
c_cond
(paren
id|attr-&gt;flags
)paren
(brace
id|ntfs_error
c_func
(paren
id|ctx-&gt;ntfs_ino-&gt;vol-&gt;sb
comma
l_string|&quot;File name with &quot;
l_string|&quot;invalid flags. You should run &quot;
l_string|&quot;chkdsk.&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|attr
op_member_access_from_pointer
id|_ARA
c_func
(paren
id|resident_flags
)paren
op_amp
id|RESIDENT_ATTR_IS_INDEXED
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|ctx-&gt;ntfs_ino-&gt;vol-&gt;sb
comma
l_string|&quot;Unindexed file &quot;
l_string|&quot;name. You should run chkdsk.&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|file_name_attr
op_assign
(paren
id|FILE_NAME_ATTR
op_star
)paren
(paren
(paren
id|u8
op_star
)paren
id|attr
op_plus
id|le16_to_cpu
c_func
(paren
id|attr
op_member_access_from_pointer
id|_ARA
c_func
(paren
id|value_offset
)paren
)paren
)paren
suffix:semicolon
id|p2
op_assign
(paren
id|u8
op_star
)paren
id|attr
op_plus
id|le32_to_cpu
c_func
(paren
id|attr
op_member_access_from_pointer
id|_ARA
c_func
(paren
id|value_length
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p2
template_param
id|p
)paren
r_goto
id|err_corrupt_attr
suffix:semicolon
multiline_comment|/* This attribute is ok, but is it in the $Extend directory? */
r_if
c_cond
(paren
id|MREF_LE
c_func
(paren
id|file_name_attr-&gt;parent_directory
)paren
op_eq
id|FILE_Extend
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* YES, it&squot;s an extended system file. */
)brace
r_if
c_cond
(paren
id|nr_links
)paren
(brace
id|ntfs_error
c_func
(paren
id|ctx-&gt;ntfs_ino-&gt;vol-&gt;sb
comma
l_string|&quot;Inode hard link count &quot;
l_string|&quot;doesn&squot;t match number of name attributes. You &quot;
l_string|&quot;should run chkdsk.&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
multiline_comment|/* NO, it is not an extended system file. */
)brace
multiline_comment|/**&n; * ntfs_read_locked_inode - read an inode from its device&n; * @vi:&t;&t;inode to read&n; *&n; * ntfs_read_locked_inode() is called from the ntfs_iget() to read the inode&n; * described by @vi into memory from the device.&n; *&n; * The only fields in @vi that we need to/can look at when the function is&n; * called are i_sb, pointing to the mounted device&squot;s super block, and i_ino,&n; * the number of the inode to load. If this is a fake inode, i.e. NInoAttr(),&n; * then the fields type, name, and name_len are also valid, and describe the&n; * attribute which this fake inode represents.&n; *&n; * ntfs_read_locked_inode() maps, pins and locks the mft record number i_ino&n; * for reading and sets up the necessary @vi fields as well as initializing&n; * the ntfs inode.&n; *&n; * Q: What locks are held when the function is called?&n; * A: i_state has I_LOCK set, hence the inode is locked, also&n; *    i_count is set to 1, so it is not going to go away&n; *    i_flags is set to 0 and we have no business touching it. Only an ioctl()&n; *    is allowed to write to them. We should of course be honouring them but&n; *    we need to do that using the IS_* macros defined in include/linux/fs.h.&n; *    In any case ntfs_read_locked_inode() has nothing to do with i_flags.&n; *&n; * Return 0 on success and -errno on error. In the error case, the inode will&n; * have had make_bad_inode() executed on it.&n; */
DECL|function|ntfs_read_locked_inode
r_static
r_int
id|ntfs_read_locked_inode
c_func
(paren
r_struct
id|inode
op_star
id|vi
)paren
(brace
id|ntfs_volume
op_star
id|vol
op_assign
id|NTFS_SB
c_func
(paren
id|vi-&gt;i_sb
)paren
suffix:semicolon
id|ntfs_inode
op_star
id|ni
suffix:semicolon
id|MFT_RECORD
op_star
id|m
suffix:semicolon
id|STANDARD_INFORMATION
op_star
id|si
suffix:semicolon
id|attr_search_context
op_star
id|ctx
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Entering for i_ino 0x%lx.&quot;
comma
id|vi-&gt;i_ino
)paren
suffix:semicolon
multiline_comment|/* Setup the generic vfs inode parts now. */
multiline_comment|/* This is the optimal IO size (for stat), not the fs block size. */
id|vi-&gt;i_blksize
op_assign
id|PAGE_CACHE_SIZE
suffix:semicolon
multiline_comment|/*&n;&t; * This is for checking whether an inode has changed w.r.t. a file so&n;&t; * that the file can be updated if necessary (compare with f_version).&n;&t; */
id|vi-&gt;i_version
op_assign
op_increment
id|event
suffix:semicolon
id|vi-&gt;i_uid
op_assign
id|vol-&gt;uid
suffix:semicolon
id|vi-&gt;i_gid
op_assign
id|vol-&gt;gid
suffix:semicolon
id|vi-&gt;i_mode
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Initialize the ntfs specific part of @vi special casing&n;&t; * FILE_MFT which we need to do at mount time.&n;&t; */
r_if
c_cond
(paren
id|vi-&gt;i_ino
op_ne
id|FILE_MFT
)paren
id|ntfs_init_big_inode
c_func
(paren
id|vi
)paren
suffix:semicolon
id|ni
op_assign
id|NTFS_I
c_func
(paren
id|vi
)paren
suffix:semicolon
id|m
op_assign
id|map_mft_record
c_func
(paren
id|READ
comma
id|ni
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|m
)paren
)paren
(brace
id|err
op_assign
id|PTR_ERR
c_func
(paren
id|m
)paren
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
id|ctx
op_assign
id|get_attr_search_ctx
c_func
(paren
id|ni
comma
id|m
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ctx
)paren
(brace
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|m-&gt;flags
op_amp
id|MFT_RECORD_IN_USE
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Inode is not in use! You should &quot;
l_string|&quot;run chkdsk.&quot;
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|m-&gt;base_mft_record
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Inode is an extent inode! You should &quot;
l_string|&quot;run chkdsk.&quot;
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
multiline_comment|/* Transfer information from mft record into vfs and ntfs inodes. */
id|ni-&gt;seq_no
op_assign
id|le16_to_cpu
c_func
(paren
id|m-&gt;sequence_number
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * FIXME: Keep in mind that link_count is two for files which have both&n;&t; * a long file name and a short file name as separate entries, so if&n;&t; * we are hiding short file names this will be too high. Either we need&n;&t; * to account for the short file names by subtracting them or we need&n;&t; * to make sure we delete files even though i_nlink is not zero which&n;&t; * might be tricky due to vfs interactions. Need to think about this&n;&t; * some more when implementing the unlink command.&n;&t; */
id|vi-&gt;i_nlink
op_assign
id|le16_to_cpu
c_func
(paren
id|m-&gt;link_count
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * FIXME: Reparse points can have the directory bit set even though&n;&t; * they would be S_IFLNK. Need to deal with this further below when we&n;&t; * implement reparse points / symbolic links but it will do for now.&n;&t; * Also if not a directory, it could be something else, rather than&n;&t; * a regular file. But again, will do for now.&n;&t; */
r_if
c_cond
(paren
id|m-&gt;flags
op_amp
id|MFT_RECORD_IS_DIRECTORY
)paren
(brace
id|vi-&gt;i_mode
op_or_assign
id|S_IFDIR
suffix:semicolon
multiline_comment|/* Things break without this kludge! */
r_if
c_cond
(paren
id|vi-&gt;i_nlink
OG
l_int|1
)paren
id|vi-&gt;i_nlink
op_assign
l_int|1
suffix:semicolon
)brace
r_else
id|vi-&gt;i_mode
op_or_assign
id|S_IFREG
suffix:semicolon
multiline_comment|/*&n;&t; * Find the standard information attribute in the mft record. At this&n;&t; * stage we haven&squot;t setup the attribute list stuff yet, so this could&n;&t; * in fact fail if the standard information is in an extent record, but&n;&t; * I don&squot;t think this actually ever happens.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|lookup_attr
c_func
(paren
id|AT_STANDARD_INFORMATION
comma
l_int|NULL
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|NULL
comma
l_int|0
comma
id|ctx
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * TODO: We should be performing a hot fix here (if the recover&n;&t;&t; * mount option is set) by creating a new attribute.&n;&t;&t; */
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;$STANDARD_INFORMATION attribute is &quot;
l_string|&quot;missing.&quot;
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
multiline_comment|/* Get the standard information attribute value. */
id|si
op_assign
(paren
id|STANDARD_INFORMATION
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|ctx-&gt;attr
op_plus
id|le16_to_cpu
c_func
(paren
id|ctx-&gt;attr
op_member_access_from_pointer
id|_ARA
c_func
(paren
id|value_offset
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/* Transfer information from the standard information into vfs_ino. */
multiline_comment|/*&n;&t; * Note: The i_?times do not quite map perfectly onto the NTFS times,&n;&t; * but they are close enough, and in the end it doesn&squot;t really matter&n;&t; * that much...&n;&t; */
multiline_comment|/*&n;&t; * mtime is the last change of the data within the file. Not changed&n;&t; * when only metadata is changed, e.g. a rename doesn&squot;t affect mtime.&n;&t; */
id|vi-&gt;i_mtime
op_assign
id|ntfs2utc
c_func
(paren
id|si-&gt;last_data_change_time
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * ctime is the last change of the metadata of the file. This obviously&n;&t; * always changes, when mtime is changed. ctime can be changed on its&n;&t; * own, mtime is then not changed, e.g. when a file is renamed.&n;&t; */
id|vi-&gt;i_ctime
op_assign
id|ntfs2utc
c_func
(paren
id|si-&gt;last_mft_change_time
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Last access to the data within the file. Not changed during a rename&n;&t; * for example but changed whenever the file is written to.&n;&t; */
id|vi-&gt;i_atime
op_assign
id|ntfs2utc
c_func
(paren
id|si-&gt;last_access_time
)paren
suffix:semicolon
multiline_comment|/* Find the attribute list attribute if present. */
id|reinit_attr_search_ctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lookup_attr
c_func
(paren
id|AT_ATTRIBUTE_LIST
comma
l_int|NULL
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|NULL
comma
l_int|0
comma
id|ctx
)paren
)paren
(brace
r_if
c_cond
(paren
id|vi-&gt;i_ino
op_eq
id|FILE_MFT
)paren
r_goto
id|skip_attr_list_load
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Attribute list found in inode 0x%lx.&quot;
comma
id|vi-&gt;i_ino
)paren
suffix:semicolon
id|NInoSetAttrList
c_func
(paren
id|ni
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ctx-&gt;attr-&gt;flags
op_amp
id|ATTR_IS_ENCRYPTED
op_logical_or
id|ctx-&gt;attr-&gt;flags
op_amp
id|ATTR_COMPRESSION_MASK
op_logical_or
id|ctx-&gt;attr-&gt;flags
op_amp
id|ATTR_IS_SPARSE
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Attribute list attribute is &quot;
l_string|&quot;compressed/encrypted/sparse. Not &quot;
l_string|&quot;allowed. Corrupt inode. You should &quot;
l_string|&quot;run chkdsk.&quot;
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
multiline_comment|/* Now allocate memory for the attribute list. */
id|ni-&gt;attr_list_size
op_assign
(paren
id|u32
)paren
id|attribute_value_length
c_func
(paren
id|ctx-&gt;attr
)paren
suffix:semicolon
id|ni-&gt;attr_list
op_assign
id|ntfs_malloc_nofs
c_func
(paren
id|ni-&gt;attr_list_size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ni-&gt;attr_list
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Not enough memory to allocate &quot;
l_string|&quot;buffer for attribute list.&quot;
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ctx-&gt;attr-&gt;non_resident
)paren
(brace
id|NInoSetAttrListNonResident
c_func
(paren
id|ni
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ctx-&gt;attr
op_member_access_from_pointer
id|_ANR
c_func
(paren
id|lowest_vcn
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Attribute list has non &quot;
l_string|&quot;zero lowest_vcn. Inode is &quot;
l_string|&quot;corrupt. You should run &quot;
l_string|&quot;chkdsk.&quot;
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * Setup the run list. No need for locking as we have&n;&t;&t;&t; * exclusive access to the inode at this time.&n;&t;&t;&t; */
id|ni-&gt;attr_list_rl.rl
op_assign
id|decompress_mapping_pairs
c_func
(paren
id|vol
comma
id|ctx-&gt;attr
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|ni-&gt;attr_list_rl.rl
)paren
)paren
(brace
id|err
op_assign
id|PTR_ERR
c_func
(paren
id|ni-&gt;attr_list_rl.rl
)paren
suffix:semicolon
id|ni-&gt;attr_list_rl.rl
op_assign
l_int|NULL
suffix:semicolon
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Mapping pairs &quot;
l_string|&quot;decompression failed with &quot;
l_string|&quot;error code %i. Corrupt &quot;
l_string|&quot;attribute list in inode.&quot;
comma
op_minus
id|err
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
multiline_comment|/* Now load the attribute list. */
r_if
c_cond
(paren
(paren
id|err
op_assign
id|load_attribute_list
c_func
(paren
id|vol
comma
op_amp
id|ni-&gt;attr_list_rl
comma
id|ni-&gt;attr_list
comma
id|ni-&gt;attr_list_size
comma
id|sle64_to_cpu
c_func
(paren
id|ctx-&gt;attr
op_member_access_from_pointer
id|_ANR
c_func
(paren
id|initialized_size
)paren
)paren
)paren
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Failed to load &quot;
l_string|&quot;attribute list attribute.&quot;
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
)brace
r_else
multiline_comment|/* if (!ctx.attr-&gt;non_resident) */
(brace
r_if
c_cond
(paren
(paren
id|u8
op_star
)paren
id|ctx-&gt;attr
op_plus
id|le16_to_cpu
c_func
(paren
id|ctx-&gt;attr
op_member_access_from_pointer
id|_ARA
c_func
(paren
id|value_offset
)paren
)paren
op_plus
id|le32_to_cpu
c_func
(paren
id|ctx-&gt;attr
op_member_access_from_pointer
id|_ARA
c_func
(paren
id|value_length
)paren
)paren
OG
(paren
id|u8
op_star
)paren
id|ctx-&gt;mrec
op_plus
id|vol-&gt;mft_record_size
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Corrupt attribute list &quot;
l_string|&quot;in inode.&quot;
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
multiline_comment|/* Now copy the attribute list. */
id|memcpy
c_func
(paren
id|ni-&gt;attr_list
comma
(paren
id|u8
op_star
)paren
id|ctx-&gt;attr
op_plus
id|le16_to_cpu
c_func
(paren
id|ctx-&gt;attr
op_member_access_from_pointer
id|_ARA
c_func
(paren
id|value_offset
)paren
)paren
comma
id|le32_to_cpu
c_func
(paren
id|ctx-&gt;attr
op_member_access_from_pointer
id|_ARA
c_func
(paren
id|value_length
)paren
)paren
)paren
suffix:semicolon
)brace
)brace
id|skip_attr_list_load
suffix:colon
multiline_comment|/*&n;&t; * If an attribute list is present we now have the attribute list value&n;&t; * in ntfs_ino-&gt;attr_list and it is ntfs_ino-&gt;attr_list_size bytes.&n;&t; */
r_if
c_cond
(paren
id|S_ISDIR
c_func
(paren
id|vi-&gt;i_mode
)paren
)paren
(brace
id|INDEX_ROOT
op_star
id|ir
suffix:semicolon
r_char
op_star
id|ir_end
comma
op_star
id|index_end
suffix:semicolon
multiline_comment|/* It is a directory, find index root attribute. */
id|reinit_attr_search_ctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|lookup_attr
c_func
(paren
id|AT_INDEX_ROOT
comma
id|I30
comma
l_int|4
comma
id|CASE_SENSITIVE
comma
l_int|0
comma
l_int|NULL
comma
l_int|0
comma
id|ctx
)paren
)paren
(brace
singleline_comment|// FIXME: File is corrupt! Hot-fix with empty index
singleline_comment|// root attribute if recovery option is set.
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;$INDEX_ROOT attribute is &quot;
l_string|&quot;missing.&quot;
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
multiline_comment|/* Set up the state. */
r_if
c_cond
(paren
id|ctx-&gt;attr-&gt;non_resident
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;$INDEX_ROOT attribute is &quot;
l_string|&quot;not resident. Not allowed.&quot;
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Compressed/encrypted index root just means that the newly&n;&t;&t; * created files in that directory should be created compressed/&n;&t;&t; * encrypted. However index root cannot be both compressed and&n;&t;&t; * encrypted.&n;&t;&t; */
r_if
c_cond
(paren
id|ctx-&gt;attr-&gt;flags
op_amp
id|ATTR_COMPRESSION_MASK
)paren
id|NInoSetCompressed
c_func
(paren
id|ni
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ctx-&gt;attr-&gt;flags
op_amp
id|ATTR_IS_ENCRYPTED
)paren
(brace
r_if
c_cond
(paren
id|ctx-&gt;attr-&gt;flags
op_amp
id|ATTR_COMPRESSION_MASK
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Found encrypted and &quot;
l_string|&quot;compressed attribute. Not &quot;
l_string|&quot;allowed.&quot;
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
id|NInoSetEncrypted
c_func
(paren
id|ni
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ctx-&gt;attr-&gt;flags
op_amp
id|ATTR_IS_SPARSE
)paren
id|NInoSetSparse
c_func
(paren
id|ni
)paren
suffix:semicolon
id|ir
op_assign
(paren
id|INDEX_ROOT
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|ctx-&gt;attr
op_plus
id|le16_to_cpu
c_func
(paren
id|ctx-&gt;attr
op_member_access_from_pointer
id|_ARA
c_func
(paren
id|value_offset
)paren
)paren
)paren
suffix:semicolon
id|ir_end
op_assign
(paren
r_char
op_star
)paren
id|ir
op_plus
id|le32_to_cpu
c_func
(paren
id|ctx-&gt;attr
op_member_access_from_pointer
id|_ARA
c_func
(paren
id|value_length
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ir_end
OG
(paren
r_char
op_star
)paren
id|ctx-&gt;mrec
op_plus
id|vol-&gt;mft_record_size
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;$INDEX_ROOT attribute is &quot;
l_string|&quot;corrupt.&quot;
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
id|index_end
op_assign
(paren
r_char
op_star
)paren
op_amp
id|ir-&gt;index
op_plus
id|le32_to_cpu
c_func
(paren
id|ir-&gt;index.index_length
)paren
suffix:semicolon
r_if
c_cond
(paren
id|index_end
OG
id|ir_end
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Directory index is corrupt.&quot;
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ir-&gt;type
op_ne
id|AT_FILE_NAME
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Indexed attribute is not &quot;
l_string|&quot;$FILE_NAME. Not allowed.&quot;
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ir-&gt;collation_rule
op_ne
id|COLLATION_FILE_NAME
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Index collation rule is not &quot;
l_string|&quot;COLLATION_FILE_NAME. Not allowed.&quot;
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
id|ni
op_member_access_from_pointer
id|_IDM
c_func
(paren
id|index_block_size
)paren
op_assign
id|le32_to_cpu
c_func
(paren
id|ir-&gt;index_block_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ni
op_member_access_from_pointer
id|_IDM
c_func
(paren
id|index_block_size
)paren
op_amp
(paren
id|ni
op_member_access_from_pointer
id|_IDM
c_func
(paren
id|index_block_size
)paren
op_minus
l_int|1
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Index block size (%u) is not a &quot;
l_string|&quot;power of two.&quot;
comma
id|ni
op_member_access_from_pointer
id|_IDM
c_func
(paren
id|index_block_size
)paren
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ni
op_member_access_from_pointer
id|_IDM
c_func
(paren
id|index_block_size
)paren
OG
id|PAGE_CACHE_SIZE
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Index block size (%u) &gt; &quot;
l_string|&quot;PAGE_CACHE_SIZE (%ld) is not &quot;
l_string|&quot;supported. Sorry.&quot;
comma
id|ni
op_member_access_from_pointer
id|_IDM
c_func
(paren
id|index_block_size
)paren
comma
id|PAGE_CACHE_SIZE
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EOPNOTSUPP
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ni
op_member_access_from_pointer
id|_IDM
c_func
(paren
id|index_block_size
)paren
OL
id|NTFS_BLOCK_SIZE
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Index block size (%u) &lt; &quot;
l_string|&quot;NTFS_BLOCK_SIZE (%i) is not &quot;
l_string|&quot;supported. Sorry.&quot;
comma
id|ni
op_member_access_from_pointer
id|_IDM
c_func
(paren
id|index_block_size
)paren
comma
id|NTFS_BLOCK_SIZE
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EOPNOTSUPP
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
id|ni
op_member_access_from_pointer
id|_IDM
c_func
(paren
id|index_block_size_bits
)paren
op_assign
id|ffs
c_func
(paren
id|ni
op_member_access_from_pointer
id|_IDM
c_func
(paren
id|index_block_size
)paren
)paren
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* Determine the size of a vcn in the directory index. */
r_if
c_cond
(paren
id|vol-&gt;cluster_size
op_le
id|ni
op_member_access_from_pointer
id|_IDM
c_func
(paren
id|index_block_size
)paren
)paren
(brace
id|ni
op_member_access_from_pointer
id|_IDM
c_func
(paren
id|index_vcn_size
)paren
op_assign
id|vol-&gt;cluster_size
suffix:semicolon
id|ni
op_member_access_from_pointer
id|_IDM
c_func
(paren
id|index_vcn_size_bits
)paren
op_assign
id|vol-&gt;cluster_size_bits
suffix:semicolon
)brace
r_else
(brace
id|ni
op_member_access_from_pointer
id|_IDM
c_func
(paren
id|index_vcn_size
)paren
op_assign
id|vol-&gt;sector_size
suffix:semicolon
id|ni
op_member_access_from_pointer
id|_IDM
c_func
(paren
id|index_vcn_size_bits
)paren
op_assign
id|vol-&gt;sector_size_bits
suffix:semicolon
)brace
multiline_comment|/* Setup the index allocation attribute, even if not present. */
id|NInoSetMstProtected
c_func
(paren
id|ni
)paren
suffix:semicolon
id|ni-&gt;type
op_assign
id|AT_INDEX_ALLOCATION
suffix:semicolon
id|ni-&gt;name
op_assign
id|I30
suffix:semicolon
id|ni-&gt;name_len
op_assign
l_int|4
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|ir-&gt;index.flags
op_amp
id|LARGE_INDEX
)paren
)paren
(brace
multiline_comment|/* No index allocation. */
id|vi-&gt;i_size
op_assign
id|ni-&gt;initialized_size
op_assign
l_int|0
suffix:semicolon
r_goto
id|skip_large_dir_stuff
suffix:semicolon
)brace
multiline_comment|/* LARGE_INDEX: Index allocation present. Setup state. */
id|NInoSetIndexAllocPresent
c_func
(paren
id|ni
)paren
suffix:semicolon
multiline_comment|/* Find index allocation attribute. */
id|reinit_attr_search_ctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|lookup_attr
c_func
(paren
id|AT_INDEX_ALLOCATION
comma
id|I30
comma
l_int|4
comma
id|CASE_SENSITIVE
comma
l_int|0
comma
l_int|NULL
comma
l_int|0
comma
id|ctx
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;$INDEX_ALLOCATION attribute &quot;
l_string|&quot;is not present but $INDEX_ROOT &quot;
l_string|&quot;indicated it is.&quot;
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|ctx-&gt;attr-&gt;non_resident
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;$INDEX_ALLOCATION attribute &quot;
l_string|&quot;is resident.&quot;
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ctx-&gt;attr-&gt;flags
op_amp
id|ATTR_IS_ENCRYPTED
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;$INDEX_ALLOCATION attribute &quot;
l_string|&quot;is encrypted.&quot;
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ctx-&gt;attr-&gt;flags
op_amp
id|ATTR_IS_SPARSE
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;$INDEX_ALLOCATION attribute &quot;
l_string|&quot;is sparse.&quot;
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ctx-&gt;attr-&gt;flags
op_amp
id|ATTR_COMPRESSION_MASK
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;$INDEX_ALLOCATION attribute &quot;
l_string|&quot;is compressed.&quot;
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ctx-&gt;attr
op_member_access_from_pointer
id|_ANR
c_func
(paren
id|lowest_vcn
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;First extent of &quot;
l_string|&quot;$INDEX_ALLOCATION attribute has non &quot;
l_string|&quot;zero lowest_vcn. Inode is corrupt. &quot;
l_string|&quot;You should run chkdsk.&quot;
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
id|vi-&gt;i_size
op_assign
id|sle64_to_cpu
c_func
(paren
id|ctx-&gt;attr
op_member_access_from_pointer
id|_ANR
c_func
(paren
id|data_size
)paren
)paren
suffix:semicolon
id|ni-&gt;initialized_size
op_assign
id|sle64_to_cpu
c_func
(paren
id|ctx-&gt;attr
op_member_access_from_pointer
id|_ANR
c_func
(paren
id|initialized_size
)paren
)paren
suffix:semicolon
id|ni-&gt;allocated_size
op_assign
id|sle64_to_cpu
c_func
(paren
id|ctx-&gt;attr
op_member_access_from_pointer
id|_ANR
c_func
(paren
id|allocated_size
)paren
)paren
suffix:semicolon
multiline_comment|/* Find bitmap attribute. */
id|reinit_attr_search_ctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|lookup_attr
c_func
(paren
id|AT_BITMAP
comma
id|I30
comma
l_int|4
comma
id|CASE_SENSITIVE
comma
l_int|0
comma
l_int|NULL
comma
l_int|0
comma
id|ctx
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;$BITMAP attribute is not &quot;
l_string|&quot;present but it must be.&quot;
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ctx-&gt;attr-&gt;flags
op_amp
(paren
id|ATTR_COMPRESSION_MASK
op_or
id|ATTR_IS_ENCRYPTED
op_or
id|ATTR_IS_SPARSE
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;$BITMAP attribute is compressed &quot;
l_string|&quot;and/or encrypted and/or sparse.&quot;
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ctx-&gt;attr-&gt;non_resident
)paren
(brace
id|NInoSetBmpNonResident
c_func
(paren
id|ni
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ctx-&gt;attr
op_member_access_from_pointer
id|_ANR
c_func
(paren
id|lowest_vcn
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;First extent of $BITMAP &quot;
l_string|&quot;attribute has non zero &quot;
l_string|&quot;lowest_vcn. Inode is corrupt. &quot;
l_string|&quot;You should run chkdsk.&quot;
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
id|ni
op_member_access_from_pointer
id|_IDM
c_func
(paren
id|bmp_size
)paren
op_assign
id|sle64_to_cpu
c_func
(paren
id|ctx-&gt;attr
op_member_access_from_pointer
id|_ANR
c_func
(paren
id|data_size
)paren
)paren
suffix:semicolon
id|ni
op_member_access_from_pointer
id|_IDM
c_func
(paren
id|bmp_initialized_size
)paren
op_assign
id|sle64_to_cpu
c_func
(paren
id|ctx-&gt;attr
op_member_access_from_pointer
id|_ANR
c_func
(paren
id|initialized_size
)paren
)paren
suffix:semicolon
id|ni
op_member_access_from_pointer
id|_IDM
c_func
(paren
id|bmp_allocated_size
)paren
op_assign
id|sle64_to_cpu
c_func
(paren
id|ctx-&gt;attr
op_member_access_from_pointer
id|_ANR
c_func
(paren
id|allocated_size
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Setup the run list. No need for locking as we have&n;&t;&t;&t; * exclusive access to the inode at this time.&n;&t;&t;&t; */
id|ni
op_member_access_from_pointer
id|_IDM
c_func
(paren
id|bmp_rl
)paren
dot
id|rl
op_assign
id|decompress_mapping_pairs
c_func
(paren
id|vol
comma
id|ctx-&gt;attr
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|ni
op_member_access_from_pointer
id|_IDM
c_func
(paren
id|bmp_rl
)paren
dot
id|rl
)paren
)paren
(brace
id|err
op_assign
id|PTR_ERR
c_func
(paren
id|ni
op_member_access_from_pointer
id|_IDM
c_func
(paren
id|bmp_rl
)paren
dot
id|rl
)paren
suffix:semicolon
id|ni
op_member_access_from_pointer
id|_IDM
c_func
(paren
id|bmp_rl
)paren
dot
id|rl
op_assign
l_int|NULL
suffix:semicolon
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Mapping pairs &quot;
l_string|&quot;decompression failed with &quot;
l_string|&quot;error code %i.&quot;
comma
op_minus
id|err
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
)brace
r_else
id|ni
op_member_access_from_pointer
id|_IDM
c_func
(paren
id|bmp_size
)paren
op_assign
id|ni
op_member_access_from_pointer
id|_IDM
c_func
(paren
id|bmp_initialized_size
)paren
op_assign
id|ni
op_member_access_from_pointer
id|_IDM
c_func
(paren
id|bmp_allocated_size
)paren
op_assign
id|le32_to_cpu
c_func
(paren
id|ctx-&gt;attr
op_member_access_from_pointer
id|_ARA
c_func
(paren
id|value_length
)paren
)paren
suffix:semicolon
multiline_comment|/* Consistency check bitmap size vs. index allocation size. */
r_if
c_cond
(paren
id|ni
op_member_access_from_pointer
id|_IDM
c_func
(paren
id|bmp_size
)paren
op_lshift
l_int|3
OL
id|vi-&gt;i_size
op_rshift
id|ni
op_member_access_from_pointer
id|_IDM
c_func
(paren
id|index_block_size_bits
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;$I30 bitmap too small (0x%Lx) &quot;
l_string|&quot;for index allocation (0x%Lx).&quot;
comma
(paren
r_int
r_int
)paren
id|ni
op_member_access_from_pointer
id|_IDM
c_func
(paren
id|bmp_size
)paren
op_lshift
l_int|3
comma
id|vi-&gt;i_size
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
id|skip_large_dir_stuff
suffix:colon
multiline_comment|/* Everyone gets read and scan permissions. */
id|vi-&gt;i_mode
op_or_assign
id|S_IRUGO
op_or
id|S_IXUGO
suffix:semicolon
multiline_comment|/* If not read-only, set write permissions. */
r_if
c_cond
(paren
op_logical_neg
id|IS_RDONLY
c_func
(paren
id|vi
)paren
)paren
id|vi-&gt;i_mode
op_or_assign
id|S_IWUGO
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Apply the directory permissions mask set in the mount&n;&t;&t; * options.&n;&t;&t; */
id|vi-&gt;i_mode
op_and_assign
op_complement
id|vol-&gt;dmask
suffix:semicolon
multiline_comment|/* Setup the operations for this inode. */
id|vi-&gt;i_op
op_assign
op_amp
id|ntfs_dir_inode_ops
suffix:semicolon
id|vi-&gt;i_fop
op_assign
op_amp
id|ntfs_dir_ops
suffix:semicolon
id|vi-&gt;i_mapping-&gt;a_ops
op_assign
op_amp
id|ntfs_aops
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* It is a file. */
id|reinit_attr_search_ctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
multiline_comment|/* Setup the data attribute, even if not present. */
id|ni-&gt;type
op_assign
id|AT_DATA
suffix:semicolon
id|ni-&gt;name
op_assign
l_int|NULL
suffix:semicolon
id|ni-&gt;name_len
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Find first extent of the unnamed data attribute. */
r_if
c_cond
(paren
op_logical_neg
id|lookup_attr
c_func
(paren
id|AT_DATA
comma
l_int|NULL
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|NULL
comma
l_int|0
comma
id|ctx
)paren
)paren
(brace
id|vi-&gt;i_size
op_assign
id|ni-&gt;initialized_size
op_assign
id|ni-&gt;allocated_size
op_assign
l_int|0LL
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * FILE_Secure does not have an unnamed $DATA&n;&t;&t;&t; * attribute, so we special case it here.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|vi-&gt;i_ino
op_eq
id|FILE_Secure
)paren
r_goto
id|no_data_attr_special_case
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Most if not all the system files in the $Extend&n;&t;&t;&t; * system directory do not have unnamed data&n;&t;&t;&t; * attributes so we need to check if the parent&n;&t;&t;&t; * directory of the file is FILE_Extend and if it is&n;&t;&t;&t; * ignore this error. To do this we need to get the&n;&t;&t;&t; * name of this inode from the mft record as the name&n;&t;&t;&t; * contains the back reference to the parent directory.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|ntfs_is_extended_system_file
c_func
(paren
id|ctx
)paren
OG
l_int|0
)paren
r_goto
id|no_data_attr_special_case
suffix:semicolon
singleline_comment|// FIXME: File is corrupt! Hot-fix with empty data
singleline_comment|// attribute if recovery option is set.
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;$DATA attribute is &quot;
l_string|&quot;missing.&quot;
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
multiline_comment|/* Setup the state. */
r_if
c_cond
(paren
id|ctx-&gt;attr-&gt;non_resident
)paren
(brace
id|NInoSetNonResident
c_func
(paren
id|ni
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ctx-&gt;attr-&gt;flags
op_amp
id|ATTR_COMPRESSION_MASK
)paren
(brace
id|NInoSetCompressed
c_func
(paren
id|ni
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vol-&gt;cluster_size
OG
l_int|4096
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Found &quot;
l_string|&quot;compressed data but &quot;
l_string|&quot;compression is disabled due &quot;
l_string|&quot;to cluster size (%i) &gt; 4kiB.&quot;
comma
id|vol-&gt;cluster_size
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|ctx-&gt;attr-&gt;flags
op_amp
id|ATTR_COMPRESSION_MASK
)paren
op_ne
id|ATTR_IS_COMPRESSED
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Found &quot;
l_string|&quot;unknown compression method or &quot;
l_string|&quot;corrupt file.&quot;
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
id|ni
op_member_access_from_pointer
id|_ICF
c_func
(paren
id|compression_block_clusters
)paren
op_assign
l_int|1U
op_lshift
id|ctx-&gt;attr
op_member_access_from_pointer
id|_ANR
c_func
(paren
id|compression_unit
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ctx-&gt;attr
op_member_access_from_pointer
id|_ANR
c_func
(paren
id|compression_unit
)paren
op_ne
l_int|4
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Found &quot;
l_string|&quot;nonstandard compression unit &quot;
l_string|&quot;(%u instead of 4). Cannot &quot;
l_string|&quot;handle this. This might &quot;
l_string|&quot;indicate corruption so you &quot;
l_string|&quot;should run chkdsk.&quot;
comma
id|ctx-&gt;attr
op_member_access_from_pointer
id|_ANR
c_func
(paren
id|compression_unit
)paren
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EOPNOTSUPP
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
id|ni
op_member_access_from_pointer
id|_ICF
c_func
(paren
id|compression_block_size
)paren
op_assign
l_int|1U
op_lshift
(paren
id|ctx-&gt;attr
op_member_access_from_pointer
id|_ANR
c_func
(paren
id|compression_unit
)paren
op_plus
id|vol-&gt;cluster_size_bits
)paren
suffix:semicolon
id|ni
op_member_access_from_pointer
id|_ICF
c_func
(paren
id|compression_block_size_bits
)paren
op_assign
id|ffs
c_func
(paren
id|ni
op_member_access_from_pointer
id|_ICF
c_func
(paren
id|compression_block_size
)paren
)paren
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ctx-&gt;attr-&gt;flags
op_amp
id|ATTR_IS_ENCRYPTED
)paren
(brace
r_if
c_cond
(paren
id|ctx-&gt;attr-&gt;flags
op_amp
id|ATTR_COMPRESSION_MASK
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Found encrypted &quot;
l_string|&quot;and compressed data.&quot;
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
id|NInoSetEncrypted
c_func
(paren
id|ni
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ctx-&gt;attr-&gt;flags
op_amp
id|ATTR_IS_SPARSE
)paren
id|NInoSetSparse
c_func
(paren
id|ni
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ctx-&gt;attr
op_member_access_from_pointer
id|_ANR
c_func
(paren
id|lowest_vcn
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;First extent of $DATA &quot;
l_string|&quot;attribute has non zero &quot;
l_string|&quot;lowest_vcn. Inode is corrupt. &quot;
l_string|&quot;You should run chkdsk.&quot;
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
multiline_comment|/* Setup all the sizes. */
id|vi-&gt;i_size
op_assign
id|sle64_to_cpu
c_func
(paren
id|ctx-&gt;attr
op_member_access_from_pointer
id|_ANR
c_func
(paren
id|data_size
)paren
)paren
suffix:semicolon
id|ni-&gt;initialized_size
op_assign
id|sle64_to_cpu
c_func
(paren
id|ctx-&gt;attr
op_member_access_from_pointer
id|_ANR
c_func
(paren
id|initialized_size
)paren
)paren
suffix:semicolon
id|ni-&gt;allocated_size
op_assign
id|sle64_to_cpu
c_func
(paren
id|ctx-&gt;attr
op_member_access_from_pointer
id|_ANR
c_func
(paren
id|allocated_size
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|NInoCompressed
c_func
(paren
id|ni
)paren
)paren
(brace
id|ni
op_member_access_from_pointer
id|_ICF
c_func
(paren
id|compressed_size
)paren
op_assign
id|sle64_to_cpu
c_func
(paren
id|ctx-&gt;attr
op_member_access_from_pointer
id|_ANR
c_func
(paren
id|compressed_size
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vi-&gt;i_size
op_ne
id|ni-&gt;initialized_size
)paren
id|ntfs_warning
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;BUG: Found &quot;
l_string|&quot;compressed file with &quot;
l_string|&quot;data_size not equal to &quot;
l_string|&quot;initialized_size. This will &quot;
l_string|&quot;probably cause problems when &quot;
l_string|&quot;trying to access the file. &quot;
l_string|&quot;Please notify linux-ntfs-dev@&quot;
l_string|&quot;lists.sf.net that you saw &quot;
l_string|&quot;this message. Thanks!&quot;
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* Resident attribute. */
multiline_comment|/*&n;&t;&t;&t; * Make all sizes equal for simplicity in read code&n;&t;&t;&t; * paths. FIXME: Need to keep this in mind when&n;&t;&t;&t; * converting to non-resident attribute in write code&n;&t;&t;&t; * path. (Probably only affects truncate().)&n;&t;&t;&t; */
id|vi-&gt;i_size
op_assign
id|ni-&gt;initialized_size
op_assign
id|ni-&gt;allocated_size
op_assign
id|le32_to_cpu
c_func
(paren
id|ctx-&gt;attr
op_member_access_from_pointer
id|_ARA
c_func
(paren
id|value_length
)paren
)paren
suffix:semicolon
)brace
id|no_data_attr_special_case
suffix:colon
multiline_comment|/* Everyone gets all permissions. */
id|vi-&gt;i_mode
op_or_assign
id|S_IRWXUGO
suffix:semicolon
multiline_comment|/* If read-only, noone gets write permissions. */
r_if
c_cond
(paren
id|IS_RDONLY
c_func
(paren
id|vi
)paren
)paren
id|vi-&gt;i_mode
op_and_assign
op_complement
id|S_IWUGO
suffix:semicolon
multiline_comment|/* Apply the file permissions mask set in the mount options. */
id|vi-&gt;i_mode
op_and_assign
op_complement
id|vol-&gt;fmask
suffix:semicolon
multiline_comment|/* Setup the operations for this inode. */
id|vi-&gt;i_op
op_assign
op_amp
id|ntfs_file_inode_ops
suffix:semicolon
id|vi-&gt;i_fop
op_assign
op_amp
id|ntfs_file_ops
suffix:semicolon
id|vi-&gt;i_mapping-&gt;a_ops
op_assign
op_amp
id|ntfs_aops
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * The number of 512-byte blocks used on disk (for stat). This is in so&n;&t; * far inaccurate as it doesn&squot;t account for any named streams or other&n;&t; * special non-resident attributes, but that is how Windows works, too,&n;&t; * so we are at least consistent with Windows, if not entirely&n;&t; * consistent with the Linux Way. Doing it the Linux Way would cause a&n;&t; * significant slowdown as it would involve iterating over all&n;&t; * attributes in the mft record and adding the allocated/compressed&n;&t; * sizes of all non-resident attributes present to give us the Linux&n;&t; * correct size that should go into i_blocks (after division by 512).&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|NInoCompressed
c_func
(paren
id|ni
)paren
)paren
id|vi-&gt;i_blocks
op_assign
id|ni-&gt;allocated_size
op_rshift
l_int|9
suffix:semicolon
r_else
id|vi-&gt;i_blocks
op_assign
id|ni
op_member_access_from_pointer
id|_ICF
c_func
(paren
id|compressed_size
)paren
op_rshift
l_int|9
suffix:semicolon
id|put_attr_search_ctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
id|unmap_mft_record
c_func
(paren
id|READ
comma
id|ni
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Done.&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|unm_err_out
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|err
)paren
id|err
op_assign
op_minus
id|EIO
suffix:semicolon
r_if
c_cond
(paren
id|ctx
)paren
id|put_attr_search_ctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
id|unmap_mft_record
c_func
(paren
id|READ
comma
id|ni
)paren
suffix:semicolon
id|err_out
suffix:colon
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Failed with error code %i. Marking inode 0x%lx &quot;
l_string|&quot;as bad.&quot;
comma
op_minus
id|err
comma
id|vi-&gt;i_ino
)paren
suffix:semicolon
id|make_bad_inode
c_func
(paren
id|vi
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_read_locked_attr_inode - read an attribute inode from its base inode&n; * @base_vi:&t;base inode&n; * @vi:&t;&t;attribute inode to read&n; *&n; * ntfs_read_locked_attr_inode() is called from the ntfs_attr_iget() to read&n; * the attribute inode described by @vi into memory from the base mft record&n; * described by @base_ni.&n; *&n; * ntfs_read_locked_attr_inode() maps, pins and locks the base inode for&n; * reading and looks up the attribute described by @vi before setting up the&n; * necessary fields in @vi as well as initializing the ntfs inode.&n; *&n; * Q: What locks are held when the function is called?&n; * A: i_state has I_LOCK set, hence the inode is locked, also&n; *    i_count is set to 1, so it is not going to go away&n; */
DECL|function|ntfs_read_locked_attr_inode
r_static
r_int
id|ntfs_read_locked_attr_inode
c_func
(paren
r_struct
id|inode
op_star
id|base_vi
comma
r_struct
id|inode
op_star
id|vi
)paren
(brace
id|ntfs_volume
op_star
id|vol
op_assign
id|NTFS_SB
c_func
(paren
id|vi-&gt;i_sb
)paren
suffix:semicolon
id|ntfs_inode
op_star
id|ni
comma
op_star
id|base_ni
suffix:semicolon
id|MFT_RECORD
op_star
id|m
suffix:semicolon
id|attr_search_context
op_star
id|ctx
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Entering for i_ino 0x%lx.&quot;
comma
id|vi-&gt;i_ino
)paren
suffix:semicolon
id|ntfs_init_big_inode
c_func
(paren
id|vi
)paren
suffix:semicolon
id|ni
op_assign
id|NTFS_I
c_func
(paren
id|vi
)paren
suffix:semicolon
id|base_ni
op_assign
id|NTFS_I
c_func
(paren
id|base_vi
)paren
suffix:semicolon
multiline_comment|/* Just mirror the values from the base inode. */
id|vi-&gt;i_blksize
op_assign
id|base_vi-&gt;i_blksize
suffix:semicolon
id|vi-&gt;i_version
op_assign
id|base_vi-&gt;i_version
suffix:semicolon
id|vi-&gt;i_uid
op_assign
id|base_vi-&gt;i_uid
suffix:semicolon
id|vi-&gt;i_gid
op_assign
id|base_vi-&gt;i_gid
suffix:semicolon
id|vi-&gt;i_nlink
op_assign
id|base_vi-&gt;i_nlink
suffix:semicolon
id|vi-&gt;i_mtime
op_assign
id|base_vi-&gt;i_mtime
suffix:semicolon
id|vi-&gt;i_ctime
op_assign
id|base_vi-&gt;i_ctime
suffix:semicolon
id|vi-&gt;i_atime
op_assign
id|base_vi-&gt;i_atime
suffix:semicolon
id|ni-&gt;seq_no
op_assign
id|base_ni-&gt;seq_no
suffix:semicolon
multiline_comment|/* Set inode type to zero but preserve permissions. */
id|vi-&gt;i_mode
op_assign
id|base_vi-&gt;i_mode
op_amp
op_complement
id|S_IFMT
suffix:semicolon
id|m
op_assign
id|map_mft_record
c_func
(paren
id|READ
comma
id|base_ni
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|m
)paren
)paren
(brace
id|err
op_assign
id|PTR_ERR
c_func
(paren
id|m
)paren
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
id|ctx
op_assign
id|get_attr_search_ctx
c_func
(paren
id|base_ni
comma
id|m
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ctx
)paren
(brace
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
multiline_comment|/* Find the attribute. */
r_if
c_cond
(paren
op_logical_neg
id|lookup_attr
c_func
(paren
id|ni-&gt;type
comma
id|ni-&gt;name
comma
id|ni-&gt;name_len
comma
id|IGNORE_CASE
comma
l_int|0
comma
l_int|NULL
comma
l_int|0
comma
id|ctx
)paren
)paren
r_goto
id|unm_err_out
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ctx-&gt;attr-&gt;non_resident
)paren
(brace
r_if
c_cond
(paren
id|NInoMstProtected
c_func
(paren
id|ni
)paren
op_logical_or
id|ctx-&gt;attr-&gt;flags
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Found mst protected attribute &quot;
l_string|&quot;or attribute with non-zero flags but &quot;
l_string|&quot;the attribute is resident (mft_no &quot;
l_string|&quot;0x%lx, type 0x%x, name_len %i). &quot;
l_string|&quot;Please report you saw this message &quot;
l_string|&quot;to linux-ntfs-dev@lists.sf.net&quot;
comma
id|vi-&gt;i_ino
comma
id|ni-&gt;type
comma
id|ni-&gt;name_len
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Resident attribute. Make all sizes equal for simplicity in&n;&t;&t; * read code paths.&n;&t;&t; */
id|vi-&gt;i_size
op_assign
id|ni-&gt;initialized_size
op_assign
id|ni-&gt;allocated_size
op_assign
id|le32_to_cpu
c_func
(paren
id|ctx-&gt;attr
op_member_access_from_pointer
id|_ARA
c_func
(paren
id|value_length
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|NInoSetNonResident
c_func
(paren
id|ni
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ctx-&gt;attr-&gt;flags
op_amp
id|ATTR_COMPRESSION_MASK
)paren
(brace
r_if
c_cond
(paren
id|NInoMstProtected
c_func
(paren
id|ni
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Found mst protected &quot;
l_string|&quot;attribute but the attribute &quot;
l_string|&quot;is compressed (mft_no 0x%lx, &quot;
l_string|&quot;type 0x%x, name_len %i). &quot;
l_string|&quot;Please report you saw this &quot;
l_string|&quot;message to linux-ntfs-dev@&quot;
l_string|&quot;lists.sf.net&quot;
comma
id|vi-&gt;i_ino
comma
id|ni-&gt;type
comma
id|ni-&gt;name_len
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
id|NInoSetCompressed
c_func
(paren
id|ni
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ni-&gt;type
op_ne
id|AT_DATA
)paren
op_logical_or
(paren
id|ni-&gt;type
op_eq
id|AT_DATA
op_logical_and
id|ni-&gt;name_len
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Found compressed non-&quot;
l_string|&quot;data or named data attribute &quot;
l_string|&quot;(mft_no 0x%lx, type 0x%x, &quot;
l_string|&quot;name_len %i). Please report &quot;
l_string|&quot;you saw this message to &quot;
l_string|&quot;linux-ntfs-dev@lists.sf.net&quot;
comma
id|vi-&gt;i_ino
comma
id|ni-&gt;type
comma
id|ni-&gt;name_len
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|vol-&gt;cluster_size
OG
l_int|4096
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Found &quot;
l_string|&quot;compressed attribute but &quot;
l_string|&quot;compression is disabled due &quot;
l_string|&quot;to cluster size (%i) &gt; 4kiB.&quot;
comma
id|vol-&gt;cluster_size
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|ctx-&gt;attr-&gt;flags
op_amp
id|ATTR_COMPRESSION_MASK
)paren
op_ne
id|ATTR_IS_COMPRESSED
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Found unknown &quot;
l_string|&quot;compression method or &quot;
l_string|&quot;corrupt file.&quot;
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
id|ni
op_member_access_from_pointer
id|_ICF
c_func
(paren
id|compression_block_clusters
)paren
op_assign
l_int|1U
op_lshift
id|ctx-&gt;attr
op_member_access_from_pointer
id|_ANR
c_func
(paren
id|compression_unit
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ctx-&gt;attr
op_member_access_from_pointer
id|_ANR
c_func
(paren
id|compression_unit
)paren
op_ne
l_int|4
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Found &quot;
l_string|&quot;nonstandard compression unit &quot;
l_string|&quot;(%u instead of 4). Cannot &quot;
l_string|&quot;handle this. This might &quot;
l_string|&quot;indicate corruption so you &quot;
l_string|&quot;should run chkdsk.&quot;
comma
id|ctx-&gt;attr
op_member_access_from_pointer
id|_ANR
c_func
(paren
id|compression_unit
)paren
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EOPNOTSUPP
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
id|ni
op_member_access_from_pointer
id|_ICF
c_func
(paren
id|compression_block_size
)paren
op_assign
l_int|1U
op_lshift
(paren
id|ctx-&gt;attr
op_member_access_from_pointer
id|_ANR
c_func
(paren
id|compression_unit
)paren
op_plus
id|vol-&gt;cluster_size_bits
)paren
suffix:semicolon
id|ni
op_member_access_from_pointer
id|_ICF
c_func
(paren
id|compression_block_size_bits
)paren
op_assign
id|ffs
c_func
(paren
id|ni
op_member_access_from_pointer
id|_ICF
c_func
(paren
id|compression_block_size
)paren
)paren
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ctx-&gt;attr-&gt;flags
op_amp
id|ATTR_IS_ENCRYPTED
)paren
(brace
r_if
c_cond
(paren
id|ctx-&gt;attr-&gt;flags
op_amp
id|ATTR_COMPRESSION_MASK
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Found encrypted &quot;
l_string|&quot;and compressed data.&quot;
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|NInoMstProtected
c_func
(paren
id|ni
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Found mst protected &quot;
l_string|&quot;attribute but the attribute &quot;
l_string|&quot;is encrypted (mft_no 0x%lx, &quot;
l_string|&quot;type 0x%x, name_len %i). &quot;
l_string|&quot;Please report you saw this &quot;
l_string|&quot;message to linux-ntfs-dev@&quot;
l_string|&quot;lists.sf.net&quot;
comma
id|vi-&gt;i_ino
comma
id|ni-&gt;type
comma
id|ni-&gt;name_len
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
id|NInoSetEncrypted
c_func
(paren
id|ni
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ctx-&gt;attr-&gt;flags
op_amp
id|ATTR_IS_SPARSE
)paren
(brace
r_if
c_cond
(paren
id|NInoMstProtected
c_func
(paren
id|ni
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Found mst protected &quot;
l_string|&quot;attribute but the attribute &quot;
l_string|&quot;is sparse (mft_no 0x%lx, &quot;
l_string|&quot;type 0x%x, name_len %i). &quot;
l_string|&quot;Please report you saw this &quot;
l_string|&quot;message to linux-ntfs-dev@&quot;
l_string|&quot;lists.sf.net&quot;
comma
id|vi-&gt;i_ino
comma
id|ni-&gt;type
comma
id|ni-&gt;name_len
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
id|NInoSetSparse
c_func
(paren
id|ni
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ctx-&gt;attr
op_member_access_from_pointer
id|_ANR
c_func
(paren
id|lowest_vcn
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;First extent of attribute has &quot;
l_string|&quot;non-zero lowest_vcn. Inode is &quot;
l_string|&quot;corrupt. You should run chkdsk.&quot;
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
multiline_comment|/* Setup all the sizes. */
id|vi-&gt;i_size
op_assign
id|sle64_to_cpu
c_func
(paren
id|ctx-&gt;attr
op_member_access_from_pointer
id|_ANR
c_func
(paren
id|data_size
)paren
)paren
suffix:semicolon
id|ni-&gt;initialized_size
op_assign
id|sle64_to_cpu
c_func
(paren
id|ctx-&gt;attr
op_member_access_from_pointer
id|_ANR
c_func
(paren
id|initialized_size
)paren
)paren
suffix:semicolon
id|ni-&gt;allocated_size
op_assign
id|sle64_to_cpu
c_func
(paren
id|ctx-&gt;attr
op_member_access_from_pointer
id|_ANR
c_func
(paren
id|allocated_size
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|NInoCompressed
c_func
(paren
id|ni
)paren
)paren
(brace
id|ni
op_member_access_from_pointer
id|_ICF
c_func
(paren
id|compressed_size
)paren
op_assign
id|sle64_to_cpu
c_func
(paren
id|ctx-&gt;attr
op_member_access_from_pointer
id|_ANR
c_func
(paren
id|compressed_size
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vi-&gt;i_size
op_ne
id|ni-&gt;initialized_size
)paren
id|ntfs_warning
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Compressed attribute &quot;
l_string|&quot;with data_size unequal to &quot;
l_string|&quot;initialized size found. This &quot;
l_string|&quot;will probably cause problems &quot;
l_string|&quot;when trying to access the &quot;
l_string|&quot;file. Please notify &quot;
l_string|&quot;linux-ntfs-dev@ lists.sf.net &quot;
l_string|&quot;that you saw this message.&quot;
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Setup the operations for this attribute inode. */
id|vi-&gt;i_op
op_assign
l_int|NULL
suffix:semicolon
id|vi-&gt;i_fop
op_assign
l_int|NULL
suffix:semicolon
id|vi-&gt;i_mapping-&gt;a_ops
op_assign
op_amp
id|ntfs_aops
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|NInoCompressed
c_func
(paren
id|ni
)paren
)paren
id|vi-&gt;i_blocks
op_assign
id|ni-&gt;allocated_size
op_rshift
l_int|9
suffix:semicolon
r_else
id|vi-&gt;i_blocks
op_assign
id|ni
op_member_access_from_pointer
id|_ICF
c_func
(paren
id|compressed_size
)paren
op_rshift
l_int|9
suffix:semicolon
multiline_comment|/*&n;&t; * Make sure the base inode doesn&squot;t go away and attach it to the&n;&t; * attribute inode.&n;&t; */
id|igrab
c_func
(paren
id|base_vi
)paren
suffix:semicolon
id|ni
op_member_access_from_pointer
id|_INE
c_func
(paren
id|base_ntfs_ino
)paren
op_assign
id|base_ni
suffix:semicolon
id|ni-&gt;nr_extents
op_assign
op_minus
l_int|1
suffix:semicolon
id|put_attr_search_ctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
id|unmap_mft_record
c_func
(paren
id|READ
comma
id|base_ni
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Done.&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|unm_err_out
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|err
)paren
id|err
op_assign
op_minus
id|EIO
suffix:semicolon
r_if
c_cond
(paren
id|ctx
)paren
id|put_attr_search_ctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
id|unmap_mft_record
c_func
(paren
id|READ
comma
id|base_ni
)paren
suffix:semicolon
id|err_out
suffix:colon
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Failed with error code %i while reading &quot;
l_string|&quot;attribute inode (mft_no 0x%lx, type 0x%x, name_len &quot;
l_string|&quot;%i.&quot;
comma
op_minus
id|err
comma
id|vi-&gt;i_ino
comma
id|ni-&gt;type
comma
id|ni-&gt;name_len
)paren
suffix:semicolon
id|make_bad_inode
c_func
(paren
id|vi
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_read_inode_mount - special read_inode for mount time use only&n; * @vi:&t;&t;inode to read&n; *&n; * Read inode FILE_MFT at mount time, only called with super_block lock&n; * held from within the read_super() code path.&n; *&n; * This function exists because when it is called the page cache for $MFT/$DATA&n; * is not initialized and hence we cannot get at the contents of mft records&n; * by calling map_mft_record*().&n; *&n; * Further it needs to cope with the circular references problem, i.e. can&squot;t&n; * load any attributes other than $ATTRIBUTE_LIST until $DATA is loaded, because&n; * we don&squot;t know where the other extent mft records are yet and again, because&n; * we cannot call map_mft_record*() yet. Obviously this applies only when an&n; * attribute list is actually present in $MFT inode.&n; *&n; * We solve these problems by starting with the $DATA attribute before anything&n; * else and iterating using lookup_attr($DATA) over all extents. As each extent&n; * is found, we decompress_mapping_pairs() including the implied&n; * merge_run_lists(). Each step of the iteration necessarily provides&n; * sufficient information for the next step to complete.&n; *&n; * This should work but there are two possible pit falls (see inline comments&n; * below), but only time will tell if they are real pits or just smoke...&n; */
DECL|function|ntfs_read_inode_mount
r_void
id|ntfs_read_inode_mount
c_func
(paren
r_struct
id|inode
op_star
id|vi
)paren
(brace
id|VCN
id|next_vcn
comma
id|last_vcn
comma
id|highest_vcn
suffix:semicolon
id|s64
id|block
suffix:semicolon
r_struct
id|super_block
op_star
id|sb
op_assign
id|vi-&gt;i_sb
suffix:semicolon
id|ntfs_volume
op_star
id|vol
op_assign
id|NTFS_SB
c_func
(paren
id|sb
)paren
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
id|ntfs_inode
op_star
id|ni
suffix:semicolon
id|MFT_RECORD
op_star
id|m
op_assign
l_int|NULL
suffix:semicolon
id|ATTR_RECORD
op_star
id|attr
suffix:semicolon
id|attr_search_context
op_star
id|ctx
suffix:semicolon
r_int
r_int
id|i
comma
id|nr_blocks
suffix:semicolon
r_int
id|err
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Entering.&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vi-&gt;i_ino
op_ne
id|FILE_MFT
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Called for inode 0x%lx but only inode %d &quot;
l_string|&quot;allowed.&quot;
comma
id|vi-&gt;i_ino
comma
id|FILE_MFT
)paren
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
multiline_comment|/* Initialize the ntfs specific part of @vi. */
id|ntfs_init_big_inode
c_func
(paren
id|vi
)paren
suffix:semicolon
id|ni
op_assign
id|NTFS_I
c_func
(paren
id|vi
)paren
suffix:semicolon
multiline_comment|/* Setup the data attribute. It is special as it is mst protected. */
id|NInoSetNonResident
c_func
(paren
id|ni
)paren
suffix:semicolon
id|NInoSetMstProtected
c_func
(paren
id|ni
)paren
suffix:semicolon
id|ni-&gt;type
op_assign
id|AT_DATA
suffix:semicolon
id|ni-&gt;name
op_assign
l_int|NULL
suffix:semicolon
id|ni-&gt;name_len
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * This sets up our little cheat allowing us to reuse the async io&n;&t; * completion handler for directories.&n;&t; */
id|ni
op_member_access_from_pointer
id|_IDM
c_func
(paren
id|index_block_size
)paren
op_assign
id|vol-&gt;mft_record_size
suffix:semicolon
id|ni
op_member_access_from_pointer
id|_IDM
c_func
(paren
id|index_block_size_bits
)paren
op_assign
id|vol-&gt;mft_record_size_bits
suffix:semicolon
multiline_comment|/* Very important! Needed to be able to call map_mft_record*(). */
id|vol-&gt;mft_ino
op_assign
id|vi
suffix:semicolon
multiline_comment|/* Allocate enough memory to read the first mft record. */
r_if
c_cond
(paren
id|vol-&gt;mft_record_size
OG
l_int|64
op_star
l_int|1024
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Unsupported mft record size %i (max 64kiB).&quot;
comma
id|vol-&gt;mft_record_size
)paren
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
id|i
op_assign
id|vol-&gt;mft_record_size
suffix:semicolon
r_if
c_cond
(paren
id|i
OL
id|sb-&gt;s_blocksize
)paren
id|i
op_assign
id|sb-&gt;s_blocksize
suffix:semicolon
id|m
op_assign
(paren
id|MFT_RECORD
op_star
)paren
id|ntfs_malloc_nofs
c_func
(paren
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|m
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Failed to allocate buffer for $MFT record 0.&quot;
)paren
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
multiline_comment|/* Determine the first block of the $MFT/$DATA attribute. */
id|block
op_assign
id|vol-&gt;mft_lcn
op_lshift
id|vol-&gt;cluster_size_bits
op_rshift
id|sb-&gt;s_blocksize_bits
suffix:semicolon
id|nr_blocks
op_assign
id|vol-&gt;mft_record_size
op_rshift
id|sb-&gt;s_blocksize_bits
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|nr_blocks
)paren
id|nr_blocks
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Load $MFT/$DATA&squot;s first mft record. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr_blocks
suffix:semicolon
id|i
op_increment
)paren
(brace
id|bh
op_assign
id|sb_bread
c_func
(paren
id|sb
comma
id|block
op_increment
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bh
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Device read failed.&quot;
)paren
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
id|memcpy
c_func
(paren
(paren
r_char
op_star
)paren
id|m
op_plus
(paren
id|i
op_lshift
id|sb-&gt;s_blocksize_bits
)paren
comma
id|bh-&gt;b_data
comma
id|sb-&gt;s_blocksize
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
multiline_comment|/* Apply the mst fixups. */
r_if
c_cond
(paren
id|post_read_mst_fixup
c_func
(paren
(paren
id|NTFS_RECORD
op_star
)paren
id|m
comma
id|vol-&gt;mft_record_size
)paren
)paren
(brace
multiline_comment|/* FIXME: Try to use the $MFTMirr now. */
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;MST fixup failed. $MFT is corrupt.&quot;
)paren
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
multiline_comment|/* Need this to sanity check attribute list references to $MFT. */
id|ni-&gt;seq_no
op_assign
id|le16_to_cpu
c_func
(paren
id|m-&gt;sequence_number
)paren
suffix:semicolon
multiline_comment|/* Provides readpage() and sync_page() for map_mft_record(READ). */
id|vi-&gt;i_mapping-&gt;a_ops
op_assign
op_amp
id|ntfs_mft_aops
suffix:semicolon
id|ctx
op_assign
id|get_attr_search_ctx
c_func
(paren
id|ni
comma
id|m
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ctx
)paren
(brace
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
multiline_comment|/* Find the attribute list attribute if present. */
r_if
c_cond
(paren
id|lookup_attr
c_func
(paren
id|AT_ATTRIBUTE_LIST
comma
l_int|NULL
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|NULL
comma
l_int|0
comma
id|ctx
)paren
)paren
(brace
id|ATTR_LIST_ENTRY
op_star
id|al_entry
comma
op_star
id|next_al_entry
suffix:semicolon
id|u8
op_star
id|al_end
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Attribute list attribute found in $MFT.&quot;
)paren
suffix:semicolon
id|NInoSetAttrList
c_func
(paren
id|ni
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ctx-&gt;attr-&gt;flags
op_amp
id|ATTR_IS_ENCRYPTED
op_logical_or
id|ctx-&gt;attr-&gt;flags
op_amp
id|ATTR_COMPRESSION_MASK
op_logical_or
id|ctx-&gt;attr-&gt;flags
op_amp
id|ATTR_IS_SPARSE
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Attribute list attribute is &quot;
l_string|&quot;compressed/encrypted/sparse. Not &quot;
l_string|&quot;allowed. $MFT is corrupt. You should &quot;
l_string|&quot;run chkdsk.&quot;
)paren
suffix:semicolon
r_goto
id|put_err_out
suffix:semicolon
)brace
multiline_comment|/* Now allocate memory for the attribute list. */
id|ni-&gt;attr_list_size
op_assign
(paren
id|u32
)paren
id|attribute_value_length
c_func
(paren
id|ctx-&gt;attr
)paren
suffix:semicolon
id|ni-&gt;attr_list
op_assign
id|ntfs_malloc_nofs
c_func
(paren
id|ni-&gt;attr_list_size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ni-&gt;attr_list
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Not enough memory to allocate buffer &quot;
l_string|&quot;for attribute list.&quot;
)paren
suffix:semicolon
r_goto
id|put_err_out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ctx-&gt;attr-&gt;non_resident
)paren
(brace
id|NInoSetAttrListNonResident
c_func
(paren
id|ni
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ctx-&gt;attr
op_member_access_from_pointer
id|_ANR
c_func
(paren
id|lowest_vcn
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Attribute list has non zero &quot;
l_string|&quot;lowest_vcn. $MFT is corrupt. &quot;
l_string|&quot;You should run chkdsk.&quot;
)paren
suffix:semicolon
r_goto
id|put_err_out
suffix:semicolon
)brace
multiline_comment|/* Setup the run list. */
id|ni-&gt;attr_list_rl.rl
op_assign
id|decompress_mapping_pairs
c_func
(paren
id|vol
comma
id|ctx-&gt;attr
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|ni-&gt;attr_list_rl.rl
)paren
)paren
(brace
id|err
op_assign
id|PTR_ERR
c_func
(paren
id|ni-&gt;attr_list_rl.rl
)paren
suffix:semicolon
id|ni-&gt;attr_list_rl.rl
op_assign
l_int|NULL
suffix:semicolon
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Mapping pairs decompression &quot;
l_string|&quot;failed with error code %i.&quot;
comma
op_minus
id|err
)paren
suffix:semicolon
r_goto
id|put_err_out
suffix:semicolon
)brace
multiline_comment|/* Now load the attribute list. */
r_if
c_cond
(paren
(paren
id|err
op_assign
id|load_attribute_list
c_func
(paren
id|vol
comma
op_amp
id|ni-&gt;attr_list_rl
comma
id|ni-&gt;attr_list
comma
id|ni-&gt;attr_list_size
comma
id|sle64_to_cpu
c_func
(paren
id|ctx-&gt;attr
op_member_access_from_pointer
id|_ANR
c_func
(paren
id|initialized_size
)paren
)paren
)paren
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Failed to load attribute list &quot;
l_string|&quot;attribute with error code %i.&quot;
comma
op_minus
id|err
)paren
suffix:semicolon
r_goto
id|put_err_out
suffix:semicolon
)brace
)brace
r_else
multiline_comment|/* if (!ctx.attr-&gt;non_resident) */
(brace
r_if
c_cond
(paren
(paren
id|u8
op_star
)paren
id|ctx-&gt;attr
op_plus
id|le16_to_cpu
c_func
(paren
id|ctx-&gt;attr
op_member_access_from_pointer
id|_ARA
c_func
(paren
id|value_offset
)paren
)paren
op_plus
id|le32_to_cpu
c_func
(paren
id|ctx-&gt;attr
op_member_access_from_pointer
id|_ARA
c_func
(paren
id|value_length
)paren
)paren
OG
(paren
id|u8
op_star
)paren
id|ctx-&gt;mrec
op_plus
id|vol-&gt;mft_record_size
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Corrupt attribute list &quot;
l_string|&quot;attribute.&quot;
)paren
suffix:semicolon
r_goto
id|put_err_out
suffix:semicolon
)brace
multiline_comment|/* Now copy the attribute list. */
id|memcpy
c_func
(paren
id|ni-&gt;attr_list
comma
(paren
id|u8
op_star
)paren
id|ctx-&gt;attr
op_plus
id|le16_to_cpu
c_func
(paren
id|ctx-&gt;attr
op_member_access_from_pointer
id|_ARA
c_func
(paren
id|value_offset
)paren
)paren
comma
id|le32_to_cpu
c_func
(paren
id|ctx-&gt;attr
op_member_access_from_pointer
id|_ARA
c_func
(paren
id|value_length
)paren
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* The attribute list is now setup in memory. */
multiline_comment|/*&n;&t;&t; * FIXME: I don&squot;t know if this case is actually possible.&n;&t;&t; * According to logic it is not possible but I have seen too&n;&t;&t; * many weird things in MS software to rely on logic... Thus we&n;&t;&t; * perform a manual search and make sure the first $MFT/$DATA&n;&t;&t; * extent is in the base inode. If it is not we abort with an&n;&t;&t; * error and if we ever see a report of this error we will need&n;&t;&t; * to do some magic in order to have the necessary mft record&n;&t;&t; * loaded and in the right place in the page cache. But&n;&t;&t; * hopefully logic will prevail and this never happens...&n;&t;&t; */
id|al_entry
op_assign
(paren
id|ATTR_LIST_ENTRY
op_star
)paren
id|ni-&gt;attr_list
suffix:semicolon
id|al_end
op_assign
(paren
id|u8
op_star
)paren
id|al_entry
op_plus
id|ni-&gt;attr_list_size
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
id|al_entry
op_assign
id|next_al_entry
)paren
(brace
multiline_comment|/* Out of bounds check. */
r_if
c_cond
(paren
(paren
id|u8
op_star
)paren
id|al_entry
template_param
id|al_end
)paren
r_goto
id|em_put_err_out
suffix:semicolon
multiline_comment|/* Catch the end of the attribute list. */
r_if
c_cond
(paren
(paren
id|u8
op_star
)paren
id|al_entry
op_eq
id|al_end
)paren
r_goto
id|em_put_err_out
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|al_entry-&gt;length
)paren
r_goto
id|em_put_err_out
suffix:semicolon
r_if
c_cond
(paren
(paren
id|u8
op_star
)paren
id|al_entry
op_plus
l_int|6
OG
id|al_end
op_logical_or
(paren
id|u8
op_star
)paren
id|al_entry
op_plus
id|le16_to_cpu
c_func
(paren
id|al_entry-&gt;length
)paren
OG
id|al_end
)paren
r_goto
id|em_put_err_out
suffix:semicolon
id|next_al_entry
op_assign
(paren
id|ATTR_LIST_ENTRY
op_star
)paren
(paren
(paren
id|u8
op_star
)paren
id|al_entry
op_plus
id|le16_to_cpu
c_func
(paren
id|al_entry-&gt;length
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|le32_to_cpu
c_func
(paren
id|al_entry-&gt;type
)paren
OG
id|const_le32_to_cpu
c_func
(paren
id|AT_DATA
)paren
)paren
r_goto
id|em_put_err_out
suffix:semicolon
r_if
c_cond
(paren
id|AT_DATA
op_ne
id|al_entry-&gt;type
)paren
r_continue
suffix:semicolon
multiline_comment|/* We want an unnamed attribute. */
r_if
c_cond
(paren
id|al_entry-&gt;name_length
)paren
r_goto
id|em_put_err_out
suffix:semicolon
multiline_comment|/* Want the first entry, i.e. lowest_vcn == 0. */
r_if
c_cond
(paren
id|al_entry-&gt;lowest_vcn
)paren
r_goto
id|em_put_err_out
suffix:semicolon
multiline_comment|/* First entry has to be in the base mft record. */
r_if
c_cond
(paren
id|MREF_LE
c_func
(paren
id|al_entry-&gt;mft_reference
)paren
op_ne
id|vi-&gt;i_ino
)paren
(brace
multiline_comment|/* MFT references do not match, logic fails. */
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;BUG: The first $DATA extent &quot;
l_string|&quot;of $MFT is not in the base &quot;
l_string|&quot;mft record. Please report &quot;
l_string|&quot;you saw this message to &quot;
l_string|&quot;linux-ntfs-dev@lists.sf.net&quot;
)paren
suffix:semicolon
r_goto
id|put_err_out
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Sequence numbers must match. */
r_if
c_cond
(paren
id|MSEQNO_LE
c_func
(paren
id|al_entry-&gt;mft_reference
)paren
op_ne
id|ni-&gt;seq_no
)paren
r_goto
id|em_put_err_out
suffix:semicolon
multiline_comment|/* Got it. All is ok. We can stop now. */
r_break
suffix:semicolon
)brace
)brace
)brace
id|reinit_attr_search_ctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
multiline_comment|/* Now load all attribute extents. */
id|attr
op_assign
l_int|NULL
suffix:semicolon
id|next_vcn
op_assign
id|last_vcn
op_assign
id|highest_vcn
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|lookup_attr
c_func
(paren
id|AT_DATA
comma
l_int|NULL
comma
l_int|0
comma
l_int|0
comma
id|next_vcn
comma
l_int|NULL
comma
l_int|0
comma
id|ctx
)paren
)paren
(brace
id|run_list_element
op_star
id|nrl
suffix:semicolon
multiline_comment|/* Cache the current attribute. */
id|attr
op_assign
id|ctx-&gt;attr
suffix:semicolon
multiline_comment|/* $MFT must be non-resident. */
r_if
c_cond
(paren
op_logical_neg
id|attr-&gt;non_resident
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;$MFT must be non-resident but a &quot;
l_string|&quot;resident extent was found. $MFT is &quot;
l_string|&quot;corrupt. Run chkdsk.&quot;
)paren
suffix:semicolon
r_goto
id|put_err_out
suffix:semicolon
)brace
multiline_comment|/* $MFT must be uncompressed and unencrypted. */
r_if
c_cond
(paren
id|attr-&gt;flags
op_amp
id|ATTR_COMPRESSION_MASK
op_logical_or
id|attr-&gt;flags
op_amp
id|ATTR_IS_ENCRYPTED
op_logical_or
id|attr-&gt;flags
op_amp
id|ATTR_IS_SPARSE
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;$MFT must be uncompressed, &quot;
l_string|&quot;non-sparse, and unencrypted but a &quot;
l_string|&quot;compressed/sparse/encrypted extent &quot;
l_string|&quot;was found. $MFT is corrupt. Run &quot;
l_string|&quot;chkdsk.&quot;
)paren
suffix:semicolon
r_goto
id|put_err_out
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Decompress the mapping pairs array of this extent and merge&n;&t;&t; * the result into the existing run list. No need for locking&n;&t;&t; * as we have exclusive access to the inode at this time and we&n;&t;&t; * are a mount in progress task, too.&n;&t;&t; */
id|nrl
op_assign
id|decompress_mapping_pairs
c_func
(paren
id|vol
comma
id|attr
comma
id|ni-&gt;run_list.rl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|nrl
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;decompress_mapping_pairs() failed with &quot;
l_string|&quot;error code %ld. $MFT is corrupt.&quot;
comma
id|PTR_ERR
c_func
(paren
id|nrl
)paren
)paren
suffix:semicolon
r_goto
id|put_err_out
suffix:semicolon
)brace
id|ni-&gt;run_list.rl
op_assign
id|nrl
suffix:semicolon
multiline_comment|/* Are we in the first extent? */
r_if
c_cond
(paren
op_logical_neg
id|next_vcn
)paren
(brace
id|u64
id|ll
suffix:semicolon
r_if
c_cond
(paren
id|attr
op_member_access_from_pointer
id|_ANR
c_func
(paren
id|lowest_vcn
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;First extent of $DATA &quot;
l_string|&quot;attribute has non zero &quot;
l_string|&quot;lowest_vcn. $MFT is corrupt. &quot;
l_string|&quot;You should run chkdsk.&quot;
)paren
suffix:semicolon
r_goto
id|put_err_out
suffix:semicolon
)brace
multiline_comment|/* Get the last vcn in the $DATA attribute. */
id|last_vcn
op_assign
id|sle64_to_cpu
c_func
(paren
id|attr
op_member_access_from_pointer
id|_ANR
c_func
(paren
id|allocated_size
)paren
)paren
op_rshift
id|vol-&gt;cluster_size_bits
suffix:semicolon
multiline_comment|/* Fill in the inode size. */
id|vi-&gt;i_size
op_assign
id|sle64_to_cpu
c_func
(paren
id|attr
op_member_access_from_pointer
id|_ANR
c_func
(paren
id|data_size
)paren
)paren
suffix:semicolon
id|ni-&gt;initialized_size
op_assign
id|sle64_to_cpu
c_func
(paren
id|attr
op_member_access_from_pointer
id|_ANR
c_func
(paren
id|initialized_size
)paren
)paren
suffix:semicolon
id|ni-&gt;allocated_size
op_assign
id|sle64_to_cpu
c_func
(paren
id|attr
op_member_access_from_pointer
id|_ANR
c_func
(paren
id|allocated_size
)paren
)paren
suffix:semicolon
multiline_comment|/* Set the number of mft records. */
id|ll
op_assign
id|vi-&gt;i_size
op_rshift
id|vol-&gt;mft_record_size_bits
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Verify the number of mft records does not exceed&n;&t;&t;&t; * 2^32 - 1.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|ll
op_ge
(paren
l_int|1ULL
op_lshift
l_int|32
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;$MFT is too big! Aborting.&quot;
)paren
suffix:semicolon
r_goto
id|put_err_out
suffix:semicolon
)brace
id|vol-&gt;nr_mft_records
op_assign
id|ll
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * We have got the first extent of the run_list for&n;&t;&t;&t; * $MFT which means it is now relatively safe to call&n;&t;&t;&t; * the normal ntfs_read_inode() function. Thus, take&n;&t;&t;&t; * us out of the calling chain. Also we need to do this&n;&t;&t;&t; * now because we need ntfs_read_inode() in place to&n;&t;&t;&t; * get at subsequent extents.&n;&t;&t;&t; */
id|sb-&gt;s_op
op_assign
op_amp
id|ntfs_sops
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Complete reading the inode, this will actually&n;&t;&t;&t; * re-read the mft record for $MFT, this time entering&n;&t;&t;&t; * it into the page cache with which we complete the&n;&t;&t;&t; * kick start of the volume. It should be safe to do&n;&t;&t;&t; * this now as the first extent of $MFT/$DATA is&n;&t;&t;&t; * already known and we would hope that we don&squot;t need&n;&t;&t;&t; * further extents in order to find the other&n;&t;&t;&t; * attributes belonging to $MFT. Only time will tell if&n;&t;&t;&t; * this is really the case. If not we will have to play&n;&t;&t;&t; * magic at this point, possibly duplicating a lot of&n;&t;&t;&t; * ntfs_read_inode() at this point. We will need to&n;&t;&t;&t; * ensure we do enough of its work to be able to call&n;&t;&t;&t; * ntfs_read_inode() on extents of $MFT/$DATA. But lets&n;&t;&t;&t; * hope this never happens...&n;&t;&t;&t; */
id|ntfs_read_locked_inode
c_func
(paren
id|vi
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_bad_inode
c_func
(paren
id|vi
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;ntfs_read_inode() of $MFT &quot;
l_string|&quot;failed. BUG or corrupt $MFT. &quot;
l_string|&quot;Run chkdsk and if no errors &quot;
l_string|&quot;are found, please report you &quot;
l_string|&quot;saw this message to &quot;
l_string|&quot;linux-ntfs-dev@lists.sf.net&quot;
)paren
suffix:semicolon
id|put_attr_search_ctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
multiline_comment|/* Revert to the safe super operations. */
id|sb-&gt;s_op
op_assign
op_amp
id|ntfs_mount_sops
suffix:semicolon
r_goto
id|out_now
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * Re-initialize some specifics about $MFT&squot;s inode as&n;&t;&t;&t; * ntfs_read_inode() will have set up the default ones.&n;&t;&t;&t; */
multiline_comment|/* Set uid and gid to root. */
id|vi-&gt;i_uid
op_assign
id|vi-&gt;i_gid
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Regular file. No access for anyone. */
id|vi-&gt;i_mode
op_assign
id|S_IFREG
suffix:semicolon
multiline_comment|/* No VFS initiated operations allowed for $MFT. */
id|vi-&gt;i_op
op_assign
op_amp
id|ntfs_empty_inode_ops
suffix:semicolon
id|vi-&gt;i_fop
op_assign
op_amp
id|ntfs_empty_file_ops
suffix:semicolon
multiline_comment|/* Put back our special address space operations. */
id|vi-&gt;i_mapping-&gt;a_ops
op_assign
op_amp
id|ntfs_mft_aops
suffix:semicolon
)brace
multiline_comment|/* Get the lowest vcn for the next extent. */
id|highest_vcn
op_assign
id|sle64_to_cpu
c_func
(paren
id|attr
op_member_access_from_pointer
id|_ANR
c_func
(paren
id|highest_vcn
)paren
)paren
suffix:semicolon
id|next_vcn
op_assign
id|highest_vcn
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* Only one extent or error, which we catch below. */
r_if
c_cond
(paren
id|next_vcn
op_le
l_int|0
)paren
r_break
suffix:semicolon
multiline_comment|/* Avoid endless loops due to corruption. */
r_if
c_cond
(paren
id|next_vcn
OL
id|sle64_to_cpu
c_func
(paren
id|attr
op_member_access_from_pointer
id|_ANR
c_func
(paren
id|lowest_vcn
)paren
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;$MFT has corrupt attribute list &quot;
l_string|&quot;attribute. Run chkdsk.&quot;
)paren
suffix:semicolon
r_goto
id|put_err_out
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|attr
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;$MFT/$DATA attribute not found. $MFT is &quot;
l_string|&quot;corrupt. Run chkdsk.&quot;
)paren
suffix:semicolon
r_goto
id|put_err_out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|highest_vcn
op_logical_and
id|highest_vcn
op_ne
id|last_vcn
op_minus
l_int|1
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Failed to load the complete run list &quot;
l_string|&quot;for $MFT/$DATA. Driver bug or &quot;
l_string|&quot;corrupt $MFT. Run chkdsk.&quot;
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;highest_vcn = 0x%Lx, last_vcn - 1 = 0x%Lx&quot;
comma
(paren
r_int
r_int
)paren
id|highest_vcn
comma
(paren
r_int
r_int
)paren
id|last_vcn
op_minus
l_int|1
)paren
suffix:semicolon
r_goto
id|put_err_out
suffix:semicolon
)brace
id|put_attr_search_ctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Done.&quot;
)paren
suffix:semicolon
id|out_now
suffix:colon
id|ntfs_free
c_func
(paren
id|m
)paren
suffix:semicolon
r_return
suffix:semicolon
id|em_put_err_out
suffix:colon
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Couldn&squot;t find first extent of $DATA attribute in &quot;
l_string|&quot;attribute list. $MFT is corrupt. Run chkdsk.&quot;
)paren
suffix:semicolon
id|put_err_out
suffix:colon
id|put_attr_search_ctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
id|err_out
suffix:colon
multiline_comment|/* Make sure we revert to the safe super operations. */
id|sb-&gt;s_op
op_assign
op_amp
id|ntfs_mount_sops
suffix:semicolon
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Failed. Marking inode as bad.&quot;
)paren
suffix:semicolon
id|make_bad_inode
c_func
(paren
id|vi
)paren
suffix:semicolon
r_goto
id|out_now
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_dirty_inode - mark the inode&squot;s metadata dirty&n; * @vi:&t;&t;inode to mark dirty&n; *&n; * This is called from fs/inode.c::__mark_inode_dirty(), when the inode itself&n; * is being marked dirty. An example is when UPDATE_ATIME() is invoked.&n; *&n; * We mark the inode dirty by setting both the page in which the mft record&n; * resides and the buffer heads in that page which correspond to the mft record&n; * dirty. This ensures that the changes will eventually be propagated to disk&n; * when the inode is set dirty.&n; *&n; * FIXME: Can we do that with the buffer heads? I am not too sure. Because if we&n; * do that we need to make sure that the kernel will not write out those buffer&n; * heads or we are screwed as it will write corrupt data to disk. The only way&n; * a mft record can be written correctly is by mst protecting it, writting it&n; * synchronously and fast mst deprotecting it. During this period, obviously,&n; * the mft record must be marked as not uptodate, be locked for writing or&n; * whatever, so that nobody attempts anything stupid.&n; *&n; * FIXME: Do we need to check that the fs is not mounted read only? And what&n; * about the inode? Anything else?&n; *&n; * FIXME: As we are only a read only driver it is safe to just return here for&n; * the moment.&n; */
DECL|function|ntfs_dirty_inode
r_void
id|ntfs_dirty_inode
c_func
(paren
r_struct
id|inode
op_star
id|vi
)paren
(brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Entering for inode 0x%lx.&quot;
comma
id|vi-&gt;i_ino
)paren
suffix:semicolon
id|NInoSetDirty
c_func
(paren
id|NTFS_I
c_func
(paren
id|vi
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_commit_inode - write out a dirty inode&n; * @ni:&t;&t;inode to write out&n; *&n; */
DECL|function|ntfs_commit_inode
r_int
id|ntfs_commit_inode
c_func
(paren
id|ntfs_inode
op_star
id|ni
)paren
(brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Entering for inode 0x%lx.&quot;
comma
id|ni-&gt;mft_no
)paren
suffix:semicolon
id|NInoClearDirty
c_func
(paren
id|ni
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|__ntfs_clear_inode
r_void
id|__ntfs_clear_inode
c_func
(paren
id|ntfs_inode
op_star
id|ni
)paren
(brace
r_int
id|err
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Entering for inode 0x%lx.&quot;
comma
id|ni-&gt;mft_no
)paren
suffix:semicolon
r_if
c_cond
(paren
id|NInoDirty
c_func
(paren
id|ni
)paren
)paren
(brace
id|err
op_assign
id|ntfs_commit_inode
c_func
(paren
id|ni
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|ntfs_error
c_func
(paren
id|ni-&gt;vol-&gt;sb
comma
l_string|&quot;Failed to commit dirty &quot;
l_string|&quot;inode synchronously.&quot;
)paren
suffix:semicolon
singleline_comment|// FIXME: Do something!!!
)brace
)brace
multiline_comment|/* Synchronize with ntfs_commit_inode(). */
id|down_write
c_func
(paren
op_amp
id|ni-&gt;mrec_lock
)paren
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|ni-&gt;mrec_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|NInoDirty
c_func
(paren
id|ni
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|ni-&gt;vol-&gt;sb
comma
l_string|&quot;Failed to commit dirty inode &quot;
l_string|&quot;asynchronously.&quot;
)paren
suffix:semicolon
singleline_comment|// FIXME: Do something!!!
)brace
multiline_comment|/* No need to lock at this stage as no one else has a reference. */
r_if
c_cond
(paren
id|ni-&gt;nr_extents
OG
l_int|0
)paren
(brace
r_int
id|i
suffix:semicolon
singleline_comment|// FIXME: Handle dirty case for each extent inode!
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ni-&gt;nr_extents
suffix:semicolon
id|i
op_increment
)paren
id|ntfs_clear_extent_inode
c_func
(paren
id|ni
op_member_access_from_pointer
id|_INE
c_func
(paren
id|extent_ntfs_inos
)paren
(braket
id|i
)braket
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|ni
op_member_access_from_pointer
id|_INE
c_func
(paren
id|extent_ntfs_inos
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Free all alocated memory. */
id|down_write
c_func
(paren
op_amp
id|ni-&gt;run_list.lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ni-&gt;run_list.rl
)paren
(brace
id|ntfs_free
c_func
(paren
id|ni-&gt;run_list.rl
)paren
suffix:semicolon
id|ni-&gt;run_list.rl
op_assign
l_int|NULL
suffix:semicolon
)brace
id|up_write
c_func
(paren
op_amp
id|ni-&gt;run_list.lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ni-&gt;attr_list
)paren
(brace
id|ntfs_free
c_func
(paren
id|ni-&gt;attr_list
)paren
suffix:semicolon
id|ni-&gt;attr_list
op_assign
l_int|NULL
suffix:semicolon
)brace
id|down_write
c_func
(paren
op_amp
id|ni-&gt;attr_list_rl.lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ni-&gt;attr_list_rl.rl
)paren
(brace
id|ntfs_free
c_func
(paren
id|ni-&gt;attr_list_rl.rl
)paren
suffix:semicolon
id|ni-&gt;attr_list_rl.rl
op_assign
l_int|NULL
suffix:semicolon
)brace
id|up_write
c_func
(paren
op_amp
id|ni-&gt;attr_list_rl.lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ni-&gt;name_len
op_logical_and
id|ni-&gt;name
op_ne
id|I30
)paren
(brace
multiline_comment|/* Catch bugs... */
id|BUG_ON
c_func
(paren
op_logical_neg
id|ni-&gt;name
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|ni-&gt;name
)paren
suffix:semicolon
)brace
)brace
DECL|function|ntfs_clear_extent_inode
r_void
id|ntfs_clear_extent_inode
c_func
(paren
id|ntfs_inode
op_star
id|ni
)paren
(brace
id|__ntfs_clear_inode
c_func
(paren
id|ni
)paren
suffix:semicolon
multiline_comment|/* Bye, bye... */
id|ntfs_destroy_extent_inode
c_func
(paren
id|ni
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_clear_big_inode - clean up the ntfs specific part of an inode&n; * @vi:&t;&t;vfs inode pending annihilation&n; *&n; * When the VFS is going to remove an inode from memory, ntfs_clear_big_inode()&n; * is called, which deallocates all memory belonging to the NTFS specific part&n; * of the inode and returns.&n; *&n; * If the MFT record is dirty, we commit it before doing anything else.&n; */
DECL|function|ntfs_clear_big_inode
r_void
id|ntfs_clear_big_inode
c_func
(paren
r_struct
id|inode
op_star
id|vi
)paren
(brace
id|ntfs_inode
op_star
id|ni
op_assign
id|NTFS_I
c_func
(paren
id|vi
)paren
suffix:semicolon
id|__ntfs_clear_inode
c_func
(paren
id|ni
)paren
suffix:semicolon
r_if
c_cond
(paren
id|S_ISDIR
c_func
(paren
id|vi-&gt;i_mode
)paren
)paren
(brace
id|down_write
c_func
(paren
op_amp
id|ni
op_member_access_from_pointer
id|_IDM
c_func
(paren
id|bmp_rl
)paren
dot
id|lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ni
op_member_access_from_pointer
id|_IDM
c_func
(paren
id|bmp_rl
)paren
dot
id|rl
)paren
id|ntfs_free
c_func
(paren
id|ni
op_member_access_from_pointer
id|_IDM
c_func
(paren
id|bmp_rl
)paren
dot
id|rl
)paren
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|ni
op_member_access_from_pointer
id|_IDM
c_func
(paren
id|bmp_rl
)paren
dot
id|lock
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|NInoAttr
c_func
(paren
id|ni
)paren
)paren
(brace
multiline_comment|/* Release the base inode if we are holding it. */
r_if
c_cond
(paren
id|ni-&gt;nr_extents
op_eq
op_minus
l_int|1
)paren
(brace
id|iput
c_func
(paren
id|VFS_I
c_func
(paren
id|ni
op_member_access_from_pointer
id|_INE
c_func
(paren
id|base_ntfs_ino
)paren
)paren
)paren
suffix:semicolon
id|ni-&gt;nr_extents
op_assign
l_int|0
suffix:semicolon
id|ni
op_member_access_from_pointer
id|_INE
c_func
(paren
id|base_ntfs_ino
)paren
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_show_options - show mount options in /proc/mounts&n; * @sf:&t;&t;seq_file in which to write our mount options&n; * @mnt:&t;vfs mount whose mount options to display&n; *&n; * Called by the VFS once for each mounted ntfs volume when someone reads&n; * /proc/mounts in order to display the NTFS specific mount options of each&n; * mount. The mount options of the vfs mount @mnt are written to the seq file&n; * @sf and success is returned.&n; */
DECL|function|ntfs_show_options
r_int
id|ntfs_show_options
c_func
(paren
r_struct
id|seq_file
op_star
id|sf
comma
r_struct
id|vfsmount
op_star
id|mnt
)paren
(brace
id|ntfs_volume
op_star
id|vol
op_assign
id|NTFS_SB
c_func
(paren
id|mnt-&gt;mnt_sb
)paren
suffix:semicolon
r_int
id|i
suffix:semicolon
id|seq_printf
c_func
(paren
id|sf
comma
l_string|&quot;,uid=%i&quot;
comma
id|vol-&gt;uid
)paren
suffix:semicolon
id|seq_printf
c_func
(paren
id|sf
comma
l_string|&quot;,gid=%i&quot;
comma
id|vol-&gt;gid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vol-&gt;fmask
op_eq
id|vol-&gt;dmask
)paren
id|seq_printf
c_func
(paren
id|sf
comma
l_string|&quot;,umask=0%o&quot;
comma
id|vol-&gt;fmask
)paren
suffix:semicolon
r_else
(brace
id|seq_printf
c_func
(paren
id|sf
comma
l_string|&quot;,fmask=0%o&quot;
comma
id|vol-&gt;fmask
)paren
suffix:semicolon
id|seq_printf
c_func
(paren
id|sf
comma
l_string|&quot;,dmask=0%o&quot;
comma
id|vol-&gt;dmask
)paren
suffix:semicolon
)brace
id|seq_printf
c_func
(paren
id|sf
comma
l_string|&quot;,nls=%s&quot;
comma
id|vol-&gt;nls_map-&gt;charset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|NVolCaseSensitive
c_func
(paren
id|vol
)paren
)paren
id|seq_printf
c_func
(paren
id|sf
comma
l_string|&quot;,case_sensitive&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|NVolShowSystemFiles
c_func
(paren
id|vol
)paren
)paren
id|seq_printf
c_func
(paren
id|sf
comma
l_string|&quot;,show_sys_files&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|on_errors_arr
(braket
id|i
)braket
dot
id|val
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|on_errors_arr
(braket
id|i
)braket
dot
id|val
op_amp
id|vol-&gt;on_errors
)paren
id|seq_printf
c_func
(paren
id|sf
comma
l_string|&quot;,errors=%s&quot;
comma
id|on_errors_arr
(braket
id|i
)braket
dot
id|str
)paren
suffix:semicolon
)brace
id|seq_printf
c_func
(paren
id|sf
comma
l_string|&quot;,mft_zone_multiplier=%i&quot;
comma
id|vol-&gt;mft_zone_multiplier
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
eof
