multiline_comment|/*&n; * inode.c&n; *&n; * Copyright (C) 1995-1999 Martin von L&#xfffd;wis&n; * Copyright (C) 1996 Albert D. Cahalan&n; * Copyright (C) 1996-1997 R&#xfffd;gis Duchesne&n; * Copyright (C) 1998 Joseph Malicki&n; * Copyright (C) 1999 Steve Dodd&n; * Copyright (C) 2000-2001 Anton Altaparmakov (AIA)&n; */
macro_line|#include &quot;ntfstypes.h&quot;
macro_line|#include &quot;ntfsendian.h&quot;
macro_line|#include &quot;struct.h&quot;
macro_line|#include &quot;inode.h&quot;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &quot;macros.h&quot;
macro_line|#include &quot;attr.h&quot;
macro_line|#include &quot;super.h&quot;
macro_line|#include &quot;dir.h&quot;
macro_line|#include &quot;support.h&quot;
macro_line|#include &quot;util.h&quot;
macro_line|#include &lt;linux/ntfs_fs.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
r_typedef
r_struct
(brace
DECL|member|recno
r_int
id|recno
suffix:semicolon
DECL|member|record
r_int
r_char
op_star
id|record
suffix:semicolon
DECL|typedef|ntfs_mft_record
)brace
id|ntfs_mft_record
suffix:semicolon
r_typedef
r_struct
(brace
DECL|member|size
r_int
id|size
suffix:semicolon
DECL|member|count
r_int
id|count
suffix:semicolon
DECL|member|records
id|ntfs_mft_record
op_star
id|records
suffix:semicolon
DECL|typedef|ntfs_disk_inode
)brace
id|ntfs_disk_inode
suffix:semicolon
DECL|function|ntfs_fill_mft_header
r_static
r_void
id|ntfs_fill_mft_header
c_func
(paren
id|ntfs_u8
op_star
id|mft
comma
r_int
id|rec_size
comma
r_int
id|seq_no
comma
r_int
id|links
comma
r_int
id|flags
)paren
(brace
r_int
id|fixup_ofs
op_assign
l_int|0x2a
suffix:semicolon
r_int
id|fixup_cnt
op_assign
id|rec_size
op_div
id|NTFS_SECTOR_SIZE
op_plus
l_int|1
suffix:semicolon
r_int
id|attr_ofs
op_assign
(paren
id|fixup_ofs
op_plus
l_int|2
op_star
id|fixup_cnt
op_plus
l_int|7
)paren
op_amp
op_complement
l_int|7
suffix:semicolon
id|NTFS_PUTU32
c_func
(paren
id|mft
op_plus
l_int|0x00
comma
l_int|0x454c4946
)paren
suffix:semicolon
multiline_comment|/* FILE */
id|NTFS_PUTU16
c_func
(paren
id|mft
op_plus
l_int|0x04
comma
id|fixup_ofs
)paren
suffix:semicolon
multiline_comment|/* Offset to fixup. */
id|NTFS_PUTU16
c_func
(paren
id|mft
op_plus
l_int|0x06
comma
id|fixup_cnt
)paren
suffix:semicolon
multiline_comment|/* Number of fixups. */
id|NTFS_PUTU64
c_func
(paren
id|mft
op_plus
l_int|0x08
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Logical sequence number. */
id|NTFS_PUTU16
c_func
(paren
id|mft
op_plus
l_int|0x10
comma
id|seq_no
)paren
suffix:semicolon
multiline_comment|/* Sequence number. */
id|NTFS_PUTU16
c_func
(paren
id|mft
op_plus
l_int|0x12
comma
id|links
)paren
suffix:semicolon
multiline_comment|/* Hard link count. */
id|NTFS_PUTU16
c_func
(paren
id|mft
op_plus
l_int|0x14
comma
id|attr_ofs
)paren
suffix:semicolon
multiline_comment|/* Offset to attributes. */
id|NTFS_PUTU16
c_func
(paren
id|mft
op_plus
l_int|0x16
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* Flags: 1 = In use,&n;&t;&t;&t;&t;&t;&t;&t;  2 = Directory. */
id|NTFS_PUTU32
c_func
(paren
id|mft
op_plus
l_int|0x18
comma
id|attr_ofs
op_plus
l_int|8
)paren
suffix:semicolon
multiline_comment|/* Bytes in use. */
id|NTFS_PUTU32
c_func
(paren
id|mft
op_plus
l_int|0x1c
comma
id|rec_size
)paren
suffix:semicolon
multiline_comment|/* Total allocated size. */
id|NTFS_PUTU64
c_func
(paren
id|mft
op_plus
l_int|0x20
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Base mft record. */
id|NTFS_PUTU16
c_func
(paren
id|mft
op_plus
l_int|0x28
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Next attr instance. */
id|NTFS_PUTU16
c_func
(paren
id|mft
op_plus
id|fixup_ofs
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Fixup word. */
id|NTFS_PUTU32
c_func
(paren
id|mft
op_plus
id|attr_ofs
comma
(paren
id|__u32
)paren
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* End of attributes marker. */
)brace
multiline_comment|/*&n; * Search in an inode an attribute by type and name. &n; * FIXME: Check that when attributes are inserted all attribute list&n; * attributes are expanded otherwise need to modify this function to deal&n; * with attribute lists. (AIA)&n; */
DECL|function|ntfs_find_attr
id|ntfs_attribute
op_star
id|ntfs_find_attr
c_func
(paren
id|ntfs_inode
op_star
id|ino
comma
r_int
id|type
comma
r_char
op_star
id|name
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ino
)paren
(brace
id|ntfs_error
c_func
(paren
l_string|&quot;ntfs_find_attr: NO INODE!&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ino-&gt;attr_count
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|type
OL
id|ino-&gt;attrs
(braket
id|i
)braket
dot
id|type
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|type
op_eq
id|ino-&gt;attrs
(braket
id|i
)braket
dot
id|type
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|name
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ino-&gt;attrs
(braket
id|i
)braket
dot
id|name
)paren
r_return
id|ino-&gt;attrs
op_plus
id|i
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ino-&gt;attrs
(braket
id|i
)braket
dot
id|name
op_logical_and
op_logical_neg
id|ntfs_ua_strncmp
c_func
(paren
id|ino-&gt;attrs
(braket
id|i
)braket
dot
id|name
comma
id|name
comma
id|strlen
c_func
(paren
id|name
)paren
)paren
)paren
r_return
id|ino-&gt;attrs
op_plus
id|i
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Insert all attributes from the record mftno of the MFT in the inode ino.&n; * If mftno is a base mft record we abort as soon as we find the attribute&n; * list, but only on the first pass. We will get called later when the attribute&n; * list attribute is being parsed so we need to distinguish the two cases.&n; * FIXME: We should be performing structural consistency checks. (AIA)&n; * Return 0 on success or -errno on error.&n; */
DECL|function|ntfs_insert_mft_attributes
r_static
r_int
id|ntfs_insert_mft_attributes
c_func
(paren
id|ntfs_inode
op_star
id|ino
comma
r_char
op_star
id|mft
comma
r_int
id|mftno
)paren
(brace
r_int
id|i
comma
id|error
comma
id|type
comma
id|len
comma
id|present
op_assign
l_int|0
suffix:semicolon
r_char
op_star
id|it
suffix:semicolon
multiline_comment|/* Check for duplicate extension record. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ino-&gt;record_count
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|ino-&gt;records
(braket
id|i
)braket
op_eq
id|mftno
)paren
(brace
r_if
c_cond
(paren
id|i
)paren
r_return
l_int|0
suffix:semicolon
id|present
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|present
)paren
(brace
multiline_comment|/* (re-)allocate space if necessary. */
r_if
c_cond
(paren
id|ino-&gt;record_count
op_mod
l_int|8
op_eq
l_int|0
)paren
(brace
r_int
op_star
r_new
suffix:semicolon
r_new
op_assign
id|ntfs_malloc
c_func
(paren
(paren
id|ino-&gt;record_count
op_plus
l_int|8
)paren
op_star
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
r_new
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
id|ino-&gt;records
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ino-&gt;record_count
suffix:semicolon
id|i
op_increment
)paren
r_new
(braket
id|i
)braket
op_assign
id|ino-&gt;records
(braket
id|i
)braket
suffix:semicolon
id|ntfs_free
c_func
(paren
id|ino-&gt;records
)paren
suffix:semicolon
)brace
id|ino-&gt;records
op_assign
r_new
suffix:semicolon
)brace
id|ino-&gt;records
(braket
id|ino-&gt;record_count
)braket
op_assign
id|mftno
suffix:semicolon
id|ino-&gt;record_count
op_increment
suffix:semicolon
)brace
id|it
op_assign
id|mft
op_plus
id|NTFS_GETU16
c_func
(paren
id|mft
op_plus
l_int|0x14
)paren
suffix:semicolon
multiline_comment|/* mft-&gt;attrs_offset */
r_do
(brace
id|type
op_assign
id|NTFS_GETU32
c_func
(paren
id|it
)paren
suffix:semicolon
id|len
op_assign
id|NTFS_GETU32
c_func
(paren
id|it
op_plus
l_int|4
)paren
suffix:semicolon
r_if
c_cond
(paren
id|type
op_ne
op_minus
l_int|1
)paren
(brace
id|error
op_assign
id|ntfs_insert_attribute
c_func
(paren
id|ino
comma
id|it
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/* If we have just processed the attribute list and this is&n;&t;&t; * the first time we are parsing this (base) mft record then we&n;&t;&t; * are done so that the attribute list gets parsed before the&n;&t;&t; * entries in the base mft record. Otherwise we run into&n;&t;&t; * problems with encountering attributes out of order and when&n;&t;&t; * this happens with different attribute extents we die. )-:&n;&t;&t; * This way we are ok as the attribute list is always sorted&n;&t;&t; * fully and correctly. (-: */
r_if
c_cond
(paren
id|type
op_eq
l_int|0x20
op_logical_and
op_logical_neg
id|present
)paren
r_return
l_int|0
suffix:semicolon
id|it
op_add_assign
id|len
suffix:semicolon
)brace
r_while
c_loop
(paren
id|type
op_ne
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Attribute listing ends with type -1. */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Insert a single specific attribute from the record mftno of the MFT in the&n; * inode ino. We disregard the attribute list assuming we have already parsed&n; * it.&n; * FIXME: We should be performing structural consistency checks. (AIA)&n; * Return 0 on success or -errno on error.&n; */
DECL|function|ntfs_insert_mft_attribute
r_static
r_int
id|ntfs_insert_mft_attribute
c_func
(paren
id|ntfs_inode
op_star
id|ino
comma
r_int
id|mftno
comma
id|ntfs_u8
op_star
id|attr
)paren
(brace
r_int
id|i
comma
id|error
comma
id|present
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Check for duplicate extension record. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ino-&gt;record_count
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|ino-&gt;records
(braket
id|i
)braket
op_eq
id|mftno
)paren
(brace
id|present
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|present
)paren
(brace
multiline_comment|/* (re-)allocate space if necessary. */
r_if
c_cond
(paren
id|ino-&gt;record_count
op_mod
l_int|8
op_eq
l_int|0
)paren
(brace
r_int
op_star
r_new
suffix:semicolon
r_new
op_assign
id|ntfs_malloc
c_func
(paren
(paren
id|ino-&gt;record_count
op_plus
l_int|8
)paren
op_star
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
r_new
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
id|ino-&gt;records
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ino-&gt;record_count
suffix:semicolon
id|i
op_increment
)paren
r_new
(braket
id|i
)braket
op_assign
id|ino-&gt;records
(braket
id|i
)braket
suffix:semicolon
id|ntfs_free
c_func
(paren
id|ino-&gt;records
)paren
suffix:semicolon
)brace
id|ino-&gt;records
op_assign
r_new
suffix:semicolon
)brace
id|ino-&gt;records
(braket
id|ino-&gt;record_count
)braket
op_assign
id|mftno
suffix:semicolon
id|ino-&gt;record_count
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|NTFS_GETU32
c_func
(paren
id|attr
)paren
op_eq
op_minus
l_int|1
)paren
(brace
id|ntfs_debug
c_func
(paren
id|DEBUG_FILE3
comma
l_string|&quot;ntfs_insert_mft_attribute: attribute &quot;
l_string|&quot;type is -1.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|error
op_assign
id|ntfs_insert_attribute
c_func
(paren
id|ino
comma
id|attr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Read and insert all the attributes of an &squot;attribute list&squot; attribute.&n; * Return the number of remaining bytes in *plen. */
DECL|function|parse_attributes
r_static
r_int
id|parse_attributes
c_func
(paren
id|ntfs_inode
op_star
id|ino
comma
id|ntfs_u8
op_star
id|alist
comma
r_int
op_star
id|plen
)paren
(brace
id|ntfs_u8
op_star
id|mft
comma
op_star
id|attr
suffix:semicolon
r_int
id|mftno
comma
id|l
comma
id|error
suffix:semicolon
r_int
id|last_mft
op_assign
op_minus
l_int|1
suffix:semicolon
r_int
id|len
op_assign
op_star
id|plen
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ino-&gt;attr
)paren
(brace
id|ntfs_error
c_func
(paren
l_string|&quot;parse_attributes: called on inode 0x%x without a &quot;
l_string|&quot;loaded base mft record.&bslash;n&quot;
comma
id|ino-&gt;i_number
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|mft
op_assign
id|ntfs_malloc
c_func
(paren
id|ino-&gt;vol-&gt;mft_record_size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mft
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_while
c_loop
(paren
id|len
OG
l_int|8
)paren
(brace
id|l
op_assign
id|NTFS_GETU16
c_func
(paren
id|alist
op_plus
l_int|4
)paren
suffix:semicolon
r_if
c_cond
(paren
id|l
OG
id|len
)paren
r_break
suffix:semicolon
multiline_comment|/* Process an attribute description. */
id|mftno
op_assign
id|NTFS_GETU32
c_func
(paren
id|alist
op_plus
l_int|0x10
)paren
suffix:semicolon
multiline_comment|/* FIXME: The mft reference (alist + 0x10) is __s64.&n;&t;&t;&t;* - Not a problem unless we encounter a huge partition.&n;&t;&t;&t;* - Should be consistency checking the sequence numbers&n;&t;&t;&t;*   though! This should maybe happen in &n;&t;&t;&t;*   ntfs_read_mft_record() itself and a hotfix could&n;&t;&t;&t;*   then occur there or the user notified to run&n;&t;&t;&t;*   ntfsck. (AIA) */
r_if
c_cond
(paren
id|mftno
op_ne
id|ino-&gt;i_number
op_logical_and
id|mftno
op_ne
id|last_mft
)paren
(brace
id|last_mft
op_assign
id|mftno
suffix:semicolon
id|error
op_assign
id|ntfs_read_mft_record
c_func
(paren
id|ino-&gt;vol
comma
id|mftno
comma
id|mft
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|ntfs_debug
c_func
(paren
id|DEBUG_FILE3
comma
l_string|&quot;parse_attributes: &quot;
l_string|&quot;ntfs_read_mft_record(mftno = 0x%x) &quot;
l_string|&quot;failed&bslash;n&quot;
comma
id|mftno
)paren
suffix:semicolon
id|ntfs_free
c_func
(paren
id|mft
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
)brace
id|attr
op_assign
id|ntfs_find_attr_in_mft_rec
c_func
(paren
id|ino-&gt;vol
comma
multiline_comment|/* ntfs volume */
id|mftno
op_eq
id|ino-&gt;i_number
ques
c_cond
multiline_comment|/* mft record is: */
id|ino-&gt;attr
suffix:colon
multiline_comment|/*   base record */
id|mft
comma
multiline_comment|/*   extension record */
id|NTFS_GETU32
c_func
(paren
id|alist
op_plus
l_int|0
)paren
comma
multiline_comment|/* type */
(paren
m_wchar_t
op_star
)paren
(paren
id|alist
op_plus
id|alist
(braket
l_int|7
)braket
)paren
comma
multiline_comment|/* name */
id|alist
(braket
l_int|6
)braket
comma
multiline_comment|/* name length */
l_int|1
comma
multiline_comment|/* ignore case */
id|NTFS_GETU16
c_func
(paren
id|alist
op_plus
l_int|24
)paren
multiline_comment|/* instance number */
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|attr
)paren
(brace
id|ntfs_error
c_func
(paren
l_string|&quot;parse_attributes: mft records 0x%x and/or &quot;
l_string|&quot;0x%x corrupt!&bslash;n&quot;
comma
id|ino-&gt;i_number
comma
id|mftno
)paren
suffix:semicolon
id|ntfs_free
c_func
(paren
id|mft
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* FIXME: Better error code? (AIA) */
)brace
id|error
op_assign
id|ntfs_insert_mft_attribute
c_func
(paren
id|ino
comma
id|mftno
comma
id|attr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|ntfs_debug
c_func
(paren
id|DEBUG_FILE3
comma
l_string|&quot;parse_attributes: &quot;
l_string|&quot;ntfs_insert_mft_attribute(mftno 0x%x, &quot;
l_string|&quot;attribute type 0x%x) failed&bslash;n&quot;
comma
id|mftno
comma
id|NTFS_GETU32
c_func
(paren
id|alist
op_plus
l_int|0
)paren
)paren
suffix:semicolon
id|ntfs_free
c_func
(paren
id|mft
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
id|len
op_sub_assign
id|l
suffix:semicolon
id|alist
op_add_assign
id|l
suffix:semicolon
)brace
id|ntfs_free
c_func
(paren
id|mft
)paren
suffix:semicolon
op_star
id|plen
op_assign
id|len
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ntfs_load_attributes
r_static
r_void
id|ntfs_load_attributes
c_func
(paren
id|ntfs_inode
op_star
id|ino
)paren
(brace
id|ntfs_attribute
op_star
id|alist
suffix:semicolon
r_int
id|datasize
suffix:semicolon
r_int
id|offset
comma
id|len
comma
id|delta
suffix:semicolon
r_char
op_star
id|buf
suffix:semicolon
id|ntfs_volume
op_star
id|vol
op_assign
id|ino-&gt;vol
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_FILE2
comma
l_string|&quot;load_attributes 0x%x 1&bslash;n&quot;
comma
id|ino-&gt;i_number
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ntfs_insert_mft_attributes
c_func
(paren
id|ino
comma
id|ino-&gt;attr
comma
id|ino-&gt;i_number
)paren
)paren
r_return
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_FILE2
comma
l_string|&quot;load_attributes 0x%x 2&bslash;n&quot;
comma
id|ino-&gt;i_number
)paren
suffix:semicolon
id|alist
op_assign
id|ntfs_find_attr
c_func
(paren
id|ino
comma
id|vol-&gt;at_attribute_list
comma
l_int|0
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_FILE2
comma
l_string|&quot;load_attributes 0x%x 3&bslash;n&quot;
comma
id|ino-&gt;i_number
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|alist
)paren
r_return
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_FILE2
comma
l_string|&quot;load_attributes 0x%x 4&bslash;n&quot;
comma
id|ino-&gt;i_number
)paren
suffix:semicolon
id|datasize
op_assign
id|alist-&gt;size
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_FILE2
comma
l_string|&quot;load_attributes 0x%x: alist-&gt;size = 0x%x&bslash;n&quot;
comma
id|ino-&gt;i_number
comma
id|alist-&gt;size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|alist-&gt;resident
)paren
(brace
id|parse_attributes
c_func
(paren
id|ino
comma
id|alist-&gt;d.data
comma
op_amp
id|datasize
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|ntfs_debug
c_func
(paren
id|DEBUG_FILE2
comma
l_string|&quot;load_attributes 0x%x 5&bslash;n&quot;
comma
id|ino-&gt;i_number
)paren
suffix:semicolon
id|buf
op_assign
id|ntfs_malloc
c_func
(paren
l_int|1024
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buf
)paren
multiline_comment|/* FIXME: Should be passing error code to caller. (AIA) */
r_return
suffix:semicolon
id|delta
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|offset
op_assign
l_int|0
suffix:semicolon
id|datasize
suffix:semicolon
id|datasize
op_sub_assign
id|len
comma
id|offset
op_add_assign
id|len
)paren
(brace
id|ntfs_io
id|io
suffix:semicolon
id|io.fn_put
op_assign
id|ntfs_put
suffix:semicolon
id|io.fn_get
op_assign
l_int|0
suffix:semicolon
id|io.param
op_assign
id|buf
op_plus
id|delta
suffix:semicolon
id|len
op_assign
l_int|1024
op_minus
id|delta
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|datasize
)paren
id|len
op_assign
id|datasize
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_FILE2
comma
l_string|&quot;load_attributes 0x%x: len = %i&bslash;n&quot;
comma
id|ino-&gt;i_number
comma
id|len
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_FILE2
comma
l_string|&quot;load_attributes 0x%x: delta = %i&bslash;n&quot;
comma
id|ino-&gt;i_number
comma
id|delta
)paren
suffix:semicolon
id|io.size
op_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
id|ntfs_read_attr
c_func
(paren
id|ino
comma
id|vol-&gt;at_attribute_list
comma
l_int|0
comma
id|offset
comma
op_amp
id|io
)paren
)paren
id|ntfs_error
c_func
(paren
l_string|&quot;error in load_attributes&bslash;n&quot;
)paren
suffix:semicolon
id|delta
op_add_assign
id|len
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_FILE2
comma
l_string|&quot;load_attributes 0x%x: after += len, &quot;
l_string|&quot;delta = %i&bslash;n&quot;
comma
id|ino-&gt;i_number
comma
id|delta
)paren
suffix:semicolon
id|parse_attributes
c_func
(paren
id|ino
comma
id|buf
comma
op_amp
id|delta
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_FILE2
comma
l_string|&quot;load_attributes 0x%x: after &quot;
l_string|&quot;parse_attr, delta = %i&bslash;n&quot;
comma
id|ino-&gt;i_number
comma
id|delta
)paren
suffix:semicolon
r_if
c_cond
(paren
id|delta
)paren
multiline_comment|/* Move remaining bytes to buffer start. */
id|ntfs_memmove
c_func
(paren
id|buf
comma
id|buf
op_plus
id|len
op_minus
id|delta
comma
id|delta
)paren
suffix:semicolon
)brace
id|ntfs_debug
c_func
(paren
id|DEBUG_FILE2
comma
l_string|&quot;load_attributes 0x%x 6&bslash;n&quot;
comma
id|ino-&gt;i_number
)paren
suffix:semicolon
id|ntfs_free
c_func
(paren
id|buf
)paren
suffix:semicolon
)brace
DECL|function|ntfs_init_inode
r_int
id|ntfs_init_inode
c_func
(paren
id|ntfs_inode
op_star
id|ino
comma
id|ntfs_volume
op_star
id|vol
comma
r_int
id|inum
)paren
(brace
r_char
op_star
id|buf
suffix:semicolon
r_int
id|error
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_FILE1
comma
l_string|&quot;Initializing inode 0x%x&bslash;n&quot;
comma
id|inum
)paren
suffix:semicolon
id|ino-&gt;i_number
op_assign
id|inum
suffix:semicolon
id|ino-&gt;vol
op_assign
id|vol
suffix:semicolon
id|ino-&gt;attr
op_assign
id|buf
op_assign
id|ntfs_malloc
c_func
(paren
id|vol-&gt;mft_record_size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buf
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|error
op_assign
id|ntfs_read_mft_record
c_func
(paren
id|vol
comma
id|inum
comma
id|ino-&gt;attr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
l_string|&quot;Init inode: 0x%x failed&bslash;n&quot;
comma
id|inum
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
id|ntfs_debug
c_func
(paren
id|DEBUG_FILE2
comma
l_string|&quot;Init inode: got mft 0x%x&bslash;n&quot;
comma
id|inum
)paren
suffix:semicolon
id|ino-&gt;sequence_number
op_assign
id|NTFS_GETU16
c_func
(paren
id|buf
op_plus
l_int|0x10
)paren
suffix:semicolon
id|ino-&gt;attr_count
op_assign
l_int|0
suffix:semicolon
id|ino-&gt;record_count
op_assign
l_int|0
suffix:semicolon
id|ino-&gt;records
op_assign
l_int|0
suffix:semicolon
id|ino-&gt;attrs
op_assign
l_int|0
suffix:semicolon
id|ntfs_load_attributes
c_func
(paren
id|ino
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_FILE2
comma
l_string|&quot;Init inode: done 0x%x&bslash;n&quot;
comma
id|inum
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ntfs_clear_inode
r_void
id|ntfs_clear_inode
c_func
(paren
id|ntfs_inode
op_star
id|ino
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ino-&gt;attr
)paren
(brace
id|ntfs_error
c_func
(paren
l_string|&quot;ntfs_clear_inode: double free&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|ntfs_free
c_func
(paren
id|ino-&gt;attr
)paren
suffix:semicolon
id|ino-&gt;attr
op_assign
l_int|0
suffix:semicolon
id|ntfs_free
c_func
(paren
id|ino-&gt;records
)paren
suffix:semicolon
id|ino-&gt;records
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ino-&gt;attr_count
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|ino-&gt;attrs
(braket
id|i
)braket
dot
id|name
)paren
id|ntfs_free
c_func
(paren
id|ino-&gt;attrs
(braket
id|i
)braket
dot
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ino-&gt;attrs
(braket
id|i
)braket
dot
id|resident
)paren
(brace
r_if
c_cond
(paren
id|ino-&gt;attrs
(braket
id|i
)braket
dot
id|d.data
)paren
id|ntfs_free
c_func
(paren
id|ino-&gt;attrs
(braket
id|i
)braket
dot
id|d.data
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|ino-&gt;attrs
(braket
id|i
)braket
dot
id|d.r.runlist
)paren
id|ntfs_vfree
c_func
(paren
id|ino-&gt;attrs
(braket
id|i
)braket
dot
id|d.r.runlist
)paren
suffix:semicolon
)brace
)brace
id|ntfs_free
c_func
(paren
id|ino-&gt;attrs
)paren
suffix:semicolon
id|ino-&gt;attrs
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Check and fixup a MFT record. */
DECL|function|ntfs_check_mft_record
r_int
id|ntfs_check_mft_record
c_func
(paren
id|ntfs_volume
op_star
id|vol
comma
r_char
op_star
id|record
)paren
(brace
r_return
id|ntfs_fixup_record
c_func
(paren
id|record
comma
l_string|&quot;FILE&quot;
comma
id|vol-&gt;mft_record_size
)paren
suffix:semicolon
)brace
multiline_comment|/* Return (in result) the value indicating the next available attribute &n; * chunk number. Works for inodes w/o extension records only. */
DECL|function|ntfs_allocate_attr_number
r_int
id|ntfs_allocate_attr_number
c_func
(paren
id|ntfs_inode
op_star
id|ino
comma
r_int
op_star
id|result
)paren
(brace
r_if
c_cond
(paren
id|ino-&gt;record_count
op_ne
l_int|1
)paren
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
op_star
id|result
op_assign
id|NTFS_GETU16
c_func
(paren
id|ino-&gt;attr
op_plus
l_int|0x28
)paren
suffix:semicolon
id|NTFS_PUTU16
c_func
(paren
id|ino-&gt;attr
op_plus
l_int|0x28
comma
(paren
op_star
id|result
)paren
op_plus
l_int|1
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Find the location of an attribute in the inode. A name of NULL indicates&n; * unnamed attributes. Return pointer to attribute or NULL if not found. */
DECL|function|ntfs_get_attr
r_char
op_star
id|ntfs_get_attr
c_func
(paren
id|ntfs_inode
op_star
id|ino
comma
r_int
id|attr
comma
r_char
op_star
id|name
)paren
(brace
multiline_comment|/* Location of first attribute. */
r_char
op_star
id|it
op_assign
id|ino-&gt;attr
op_plus
id|NTFS_GETU16
c_func
(paren
id|ino-&gt;attr
op_plus
l_int|0x14
)paren
suffix:semicolon
r_int
id|type
suffix:semicolon
r_int
id|len
suffix:semicolon
multiline_comment|/* Only check for magic DWORD here, fixup should have happened before.*/
r_if
c_cond
(paren
op_logical_neg
id|IS_MFT_RECORD
c_func
(paren
id|ino-&gt;attr
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_do
(brace
id|type
op_assign
id|NTFS_GETU32
c_func
(paren
id|it
)paren
suffix:semicolon
id|len
op_assign
id|NTFS_GETU16
c_func
(paren
id|it
op_plus
l_int|4
)paren
suffix:semicolon
multiline_comment|/* We found the attribute type. Is the name correct, too? */
r_if
c_cond
(paren
id|type
op_eq
id|attr
)paren
(brace
r_int
id|namelen
op_assign
id|NTFS_GETU8
c_func
(paren
id|it
op_plus
l_int|9
)paren
suffix:semicolon
r_char
op_star
id|name_it
comma
op_star
id|n
op_assign
id|name
suffix:semicolon
multiline_comment|/* Match given name and attribute name if present.&n;&t;&t;&t;   Make sure attribute name is Unicode. */
r_if
c_cond
(paren
op_logical_neg
id|name
)paren
(brace
r_goto
id|check_namelen
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|namelen
)paren
(brace
r_for
c_loop
(paren
id|name_it
op_assign
id|it
op_plus
id|NTFS_GETU16
c_func
(paren
id|it
op_plus
l_int|10
)paren
suffix:semicolon
id|namelen
suffix:semicolon
id|n
op_increment
comma
id|name_it
op_add_assign
l_int|2
comma
id|namelen
op_decrement
)paren
r_if
c_cond
(paren
op_star
id|name_it
op_ne
op_star
id|n
op_logical_or
id|name_it
(braket
l_int|1
)braket
)paren
r_break
suffix:semicolon
id|check_namelen
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|namelen
)paren
r_break
suffix:semicolon
)brace
)brace
id|it
op_add_assign
id|len
suffix:semicolon
)brace
r_while
c_loop
(paren
id|type
op_ne
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* List of attributes ends with type -1. */
r_if
c_cond
(paren
id|type
op_eq
op_minus
l_int|1
)paren
r_return
l_int|0
suffix:semicolon
r_return
id|it
suffix:semicolon
)brace
DECL|function|ntfs_get_attr_size
id|__s64
id|ntfs_get_attr_size
c_func
(paren
id|ntfs_inode
op_star
id|ino
comma
r_int
id|type
comma
r_char
op_star
id|name
)paren
(brace
id|ntfs_attribute
op_star
id|attr
op_assign
id|ntfs_find_attr
c_func
(paren
id|ino
comma
id|type
comma
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|attr
)paren
r_return
l_int|0
suffix:semicolon
r_return
id|attr-&gt;size
suffix:semicolon
)brace
DECL|function|ntfs_attr_is_resident
r_int
id|ntfs_attr_is_resident
c_func
(paren
id|ntfs_inode
op_star
id|ino
comma
r_int
id|type
comma
r_char
op_star
id|name
)paren
(brace
id|ntfs_attribute
op_star
id|attr
op_assign
id|ntfs_find_attr
c_func
(paren
id|ino
comma
id|type
comma
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|attr
)paren
r_return
l_int|0
suffix:semicolon
r_return
id|attr-&gt;resident
suffix:semicolon
)brace
multiline_comment|/*&n; * A run is coded as a type indicator, an unsigned length, and a signed cluster&n; * offset.&n; * . To save space, length and offset are fields of variable length. The low&n; *   nibble of the type indicates the width of the length :), the high nibble&n; *   the width of the offset.&n; * . The first offset is relative to cluster 0, later offsets are relative to&n; *   the previous cluster.&n; *&n; * This function decodes a run. Length is an output parameter, data and cluster&n; * are in/out parameters.&n; */
DECL|function|ntfs_decompress_run
r_int
id|ntfs_decompress_run
c_func
(paren
r_int
r_char
op_star
op_star
id|data
comma
r_int
op_star
id|length
comma
id|ntfs_cluster_t
op_star
id|cluster
comma
r_int
op_star
id|ctype
)paren
(brace
r_int
r_char
id|type
op_assign
op_star
(paren
op_star
id|data
)paren
op_increment
suffix:semicolon
op_star
id|ctype
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|type
op_amp
l_int|0xF
)paren
(brace
r_case
l_int|1
suffix:colon
op_star
id|length
op_assign
id|NTFS_GETS8
c_func
(paren
op_star
id|data
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
op_star
id|length
op_assign
id|NTFS_GETS16
c_func
(paren
op_star
id|data
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
op_star
id|length
op_assign
id|NTFS_GETS24
c_func
(paren
op_star
id|data
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
op_star
id|length
op_assign
id|NTFS_GETS32
c_func
(paren
op_star
id|data
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* Note: cases 5-8 are probably pointless to code, since how&n;&t;&t; * many runs &gt; 4GB of length are there? At the most, cases 5&n;&t;&t; * and 6 are probably necessary, and would also require making&n;&t;&t; * length 64-bit throughout. */
r_default
suffix:colon
id|ntfs_error
c_func
(paren
l_string|&quot;Can&squot;t decode run type field 0x%x&bslash;n&quot;
comma
id|type
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
singleline_comment|//&t;ntfs_debug(DEBUG_FILE3, &quot;ntfs_decompress_run: length = 0x%x&bslash;n&quot;,*length);
r_if
c_cond
(paren
op_star
id|length
OL
l_int|0
)paren
(brace
id|ntfs_error
c_func
(paren
l_string|&quot;Negative run length decoded&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
op_star
id|data
op_add_assign
(paren
id|type
op_amp
l_int|0xF
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|type
op_amp
l_int|0xF0
)paren
(brace
r_case
l_int|0
suffix:colon
op_star
id|ctype
op_assign
l_int|2
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x10
suffix:colon
op_star
id|cluster
op_add_assign
id|NTFS_GETS8
c_func
(paren
op_star
id|data
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x20
suffix:colon
op_star
id|cluster
op_add_assign
id|NTFS_GETS16
c_func
(paren
op_star
id|data
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x30
suffix:colon
op_star
id|cluster
op_add_assign
id|NTFS_GETS24
c_func
(paren
op_star
id|data
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x40
suffix:colon
op_star
id|cluster
op_add_assign
id|NTFS_GETS32
c_func
(paren
op_star
id|data
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#if 0 /* Keep for future, in case ntfs_cluster_t ever becomes 64bit. */
r_case
l_int|0x50
suffix:colon
op_star
id|cluster
op_add_assign
id|NTFS_GETS40
c_func
(paren
op_star
id|data
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x60
suffix:colon
op_star
id|cluster
op_add_assign
id|NTFS_GETS48
c_func
(paren
op_star
id|data
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x70
suffix:colon
op_star
id|cluster
op_add_assign
id|NTFS_GETS56
c_func
(paren
op_star
id|data
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x80
suffix:colon
op_star
id|cluster
op_add_assign
id|NTFS_GETS64
c_func
(paren
op_star
id|data
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
r_default
suffix:colon
id|ntfs_error
c_func
(paren
l_string|&quot;Can&squot;t decode run type field 0x%x&bslash;n&quot;
comma
id|type
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
singleline_comment|//&t;ntfs_debug(DEBUG_FILE3, &quot;ntfs_decompress_run: cluster = 0x%x&bslash;n&quot;,
singleline_comment|//&t;&t;&t;&t;&t;&t;&t;&t;*cluster);
op_star
id|data
op_add_assign
(paren
id|type
op_rshift
l_int|4
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_void
id|dump_runlist
c_func
(paren
r_const
id|ntfs_runlist
op_star
id|rl
comma
r_const
r_int
id|rlen
)paren
suffix:semicolon
multiline_comment|/*&n; * FIXME: ntfs_readwrite_attr() has the effect of writing @dest to @offset of&n; * the attribute value of the attribute @attr in the in memory inode @ino.&n; * If the attribute value of @attr is non-resident the value&squot;s contents at&n; * @offset are actually written to disk (from @dest). The on disk mft record&n; * describing the non-resident attribute value is not updated!&n; * If the attribute value is resident then the value is written only in&n; * memory. The on disk mft record containing the value is not written to disk.&n; * A possible fix would be to call ntfs_update_inode() before returning. (AIA)&n; */
multiline_comment|/* Reads l bytes of the attribute (attr, name) of ino starting at offset on&n; * vol into buf. Returns the number of bytes read in the ntfs_io struct.&n; * Returns 0 on success, errno on failure */
DECL|function|ntfs_readwrite_attr
r_int
id|ntfs_readwrite_attr
c_func
(paren
id|ntfs_inode
op_star
id|ino
comma
id|ntfs_attribute
op_star
id|attr
comma
id|__s64
id|offset
comma
id|ntfs_io
op_star
id|dest
)paren
(brace
r_int
id|rnum
comma
id|s_vcn
comma
id|error
comma
id|clustersizebits
suffix:semicolon
id|ntfs_cluster_t
id|cluster
comma
id|s_cluster
comma
id|vcn
comma
id|len
suffix:semicolon
id|__s64
id|l
comma
id|chunk
comma
id|copied
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_FILE3
comma
id|__FUNCTION__
l_string|&quot;(): %s 0x%x bytes at offset &quot;
l_string|&quot;0x%Lx %s inode 0x%x, attr type 0x%x.&bslash;n&quot;
comma
id|dest-&gt;do_read
ques
c_cond
l_string|&quot;Read&quot;
suffix:colon
l_string|&quot;Write&quot;
comma
id|dest-&gt;size
comma
id|offset
comma
id|dest-&gt;do_read
ques
c_cond
l_string|&quot;from&quot;
suffix:colon
l_string|&quot;to&quot;
comma
id|ino-&gt;i_number
comma
id|attr-&gt;type
)paren
suffix:semicolon
id|l
op_assign
id|dest-&gt;size
suffix:semicolon
r_if
c_cond
(paren
id|l
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|dest-&gt;do_read
)paren
(brace
multiline_comment|/* If read _starts_ beyond end of stream, return nothing. */
r_if
c_cond
(paren
id|offset
op_ge
id|attr-&gt;size
)paren
(brace
id|dest-&gt;size
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* If read _extends_ beyond end of stream, return as much&n;&t;&t; * initialised data as we have. */
r_if
c_cond
(paren
id|offset
op_plus
id|l
op_ge
id|attr-&gt;size
)paren
id|l
op_assign
id|dest-&gt;size
op_assign
id|attr-&gt;size
op_minus
id|offset
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * If write extends beyond _allocated_ size, extend attribute,&n;&t;&t; * updating attr-&gt;allocated and attr-&gt;size in the process. (AIA)&n;&t;&t; */
r_if
c_cond
(paren
(paren
op_logical_neg
id|attr-&gt;resident
op_logical_and
id|offset
op_plus
id|l
OG
id|attr-&gt;allocated
)paren
op_logical_or
(paren
id|attr-&gt;resident
op_logical_and
id|offset
op_plus
id|l
OG
id|attr-&gt;size
)paren
)paren
(brace
id|error
op_assign
id|ntfs_resize_attr
c_func
(paren
id|ino
comma
id|attr
comma
id|offset
op_plus
id|l
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|attr-&gt;resident
)paren
(brace
multiline_comment|/* Has amount of data increased? */
r_if
c_cond
(paren
id|offset
op_plus
id|l
OG
id|attr-&gt;size
)paren
id|attr-&gt;size
op_assign
id|offset
op_plus
id|l
suffix:semicolon
multiline_comment|/* Has amount of initialised data increased? */
r_if
c_cond
(paren
id|offset
op_plus
id|l
OG
id|attr-&gt;initialized
)paren
(brace
multiline_comment|/* FIXME: Clear the section between the old&n;&t;&t;&t; &t; * initialised length and the write start.&n;&t;&t;&t;&t; * (AIA) */
id|attr-&gt;initialized
op_assign
id|offset
op_plus
id|l
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|attr-&gt;resident
)paren
(brace
r_if
c_cond
(paren
id|dest-&gt;do_read
)paren
id|dest
op_member_access_from_pointer
id|fn_put
c_func
(paren
id|dest
comma
(paren
id|ntfs_u8
op_star
)paren
id|attr-&gt;d.data
op_plus
id|offset
comma
id|l
)paren
suffix:semicolon
r_else
id|dest
op_member_access_from_pointer
id|fn_get
c_func
(paren
(paren
id|ntfs_u8
op_star
)paren
id|attr-&gt;d.data
op_plus
id|offset
comma
id|dest
comma
id|l
)paren
suffix:semicolon
id|dest-&gt;size
op_assign
id|l
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dest-&gt;do_read
)paren
(brace
multiline_comment|/* Read uninitialized data. */
r_if
c_cond
(paren
id|offset
op_ge
id|attr-&gt;initialized
)paren
r_return
id|ntfs_read_zero
c_func
(paren
id|dest
comma
id|l
)paren
suffix:semicolon
r_if
c_cond
(paren
id|offset
op_plus
id|l
OG
id|attr-&gt;initialized
)paren
(brace
id|dest-&gt;size
op_assign
id|chunk
op_assign
id|attr-&gt;initialized
op_minus
id|offset
suffix:semicolon
id|error
op_assign
id|ntfs_readwrite_attr
c_func
(paren
id|ino
comma
id|attr
comma
id|offset
comma
id|dest
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_logical_or
(paren
id|dest-&gt;size
op_ne
id|chunk
op_logical_and
(paren
id|error
op_assign
op_minus
id|EIO
comma
l_int|1
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
id|dest-&gt;size
op_add_assign
id|l
op_minus
id|chunk
suffix:semicolon
r_return
id|ntfs_read_zero
c_func
(paren
id|dest
comma
id|l
op_minus
id|chunk
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|attr-&gt;flags
op_amp
id|ATTR_IS_COMPRESSED
)paren
r_return
id|ntfs_read_compressed
c_func
(paren
id|ino
comma
id|attr
comma
id|offset
comma
id|dest
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|attr-&gt;flags
op_amp
id|ATTR_IS_COMPRESSED
)paren
r_return
id|ntfs_write_compressed
c_func
(paren
id|ino
comma
id|attr
comma
id|offset
comma
id|dest
)paren
suffix:semicolon
)brace
id|vcn
op_assign
l_int|0
suffix:semicolon
id|clustersizebits
op_assign
id|ino-&gt;vol-&gt;cluster_size_bits
suffix:semicolon
id|s_vcn
op_assign
id|offset
op_rshift
id|clustersizebits
suffix:semicolon
r_for
c_loop
(paren
id|rnum
op_assign
l_int|0
suffix:semicolon
id|rnum
OL
id|attr-&gt;d.r.len
op_logical_and
id|vcn
op_plus
id|attr-&gt;d.r.runlist
(braket
id|rnum
)braket
dot
id|len
op_le
id|s_vcn
suffix:semicolon
id|rnum
op_increment
)paren
id|vcn
op_add_assign
id|attr-&gt;d.r.runlist
(braket
id|rnum
)braket
dot
id|len
suffix:semicolon
r_if
c_cond
(paren
id|rnum
op_eq
id|attr-&gt;d.r.len
)paren
(brace
id|ntfs_debug
c_func
(paren
id|DEBUG_FILE3
comma
id|__FUNCTION__
l_string|&quot;(): EOPNOTSUPP: &quot;
l_string|&quot;inode = 0x%x, rnum = %i, offset = 0x%Lx, vcn = 0x%x, &quot;
l_string|&quot;s_vcn = 0x%x.&bslash;n&quot;
comma
id|ino-&gt;i_number
comma
id|rnum
comma
id|offset
comma
id|vcn
comma
id|s_vcn
)paren
suffix:semicolon
id|dump_runlist
c_func
(paren
id|attr-&gt;d.r.runlist
comma
id|attr-&gt;d.r.len
)paren
suffix:semicolon
multiline_comment|/*FIXME: Should extend runlist. */
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
id|copied
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|l
)paren
(brace
id|s_vcn
op_assign
id|offset
op_rshift
id|clustersizebits
suffix:semicolon
id|cluster
op_assign
id|attr-&gt;d.r.runlist
(braket
id|rnum
)braket
dot
id|lcn
suffix:semicolon
id|len
op_assign
id|attr-&gt;d.r.runlist
(braket
id|rnum
)braket
dot
id|len
suffix:semicolon
id|s_cluster
op_assign
id|cluster
op_plus
id|s_vcn
op_minus
id|vcn
suffix:semicolon
id|chunk
op_assign
(paren
(paren
id|__s64
)paren
(paren
id|vcn
op_plus
id|len
)paren
op_lshift
id|clustersizebits
)paren
op_minus
id|offset
suffix:semicolon
r_if
c_cond
(paren
id|chunk
OG
id|l
)paren
id|chunk
op_assign
id|l
suffix:semicolon
id|dest-&gt;size
op_assign
id|chunk
suffix:semicolon
id|error
op_assign
id|ntfs_getput_clusters
c_func
(paren
id|ino-&gt;vol
comma
id|s_cluster
comma
id|offset
op_minus
(paren
(paren
id|__s64
)paren
id|s_vcn
op_lshift
id|clustersizebits
)paren
comma
id|dest
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|ntfs_error
c_func
(paren
l_string|&quot;Read/write error.&bslash;n&quot;
)paren
suffix:semicolon
id|dest-&gt;size
op_assign
id|copied
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
id|l
op_sub_assign
id|chunk
suffix:semicolon
id|copied
op_add_assign
id|chunk
suffix:semicolon
id|offset
op_add_assign
id|chunk
suffix:semicolon
r_if
c_cond
(paren
id|l
op_logical_and
id|offset
op_ge
(paren
(paren
id|__s64
)paren
(paren
id|vcn
op_plus
id|len
)paren
op_lshift
id|clustersizebits
)paren
)paren
(brace
id|rnum
op_increment
suffix:semicolon
id|vcn
op_add_assign
id|len
suffix:semicolon
id|cluster
op_assign
id|attr-&gt;d.r.runlist
(braket
id|rnum
)braket
dot
id|lcn
suffix:semicolon
id|len
op_assign
id|attr-&gt;d.r.runlist
(braket
id|rnum
)braket
dot
id|len
suffix:semicolon
)brace
)brace
id|dest-&gt;size
op_assign
id|copied
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ntfs_read_attr
r_int
id|ntfs_read_attr
c_func
(paren
id|ntfs_inode
op_star
id|ino
comma
r_int
id|type
comma
r_char
op_star
id|name
comma
id|__s64
id|offset
comma
id|ntfs_io
op_star
id|buf
)paren
(brace
id|ntfs_attribute
op_star
id|attr
suffix:semicolon
id|buf-&gt;do_read
op_assign
l_int|1
suffix:semicolon
id|attr
op_assign
id|ntfs_find_attr
c_func
(paren
id|ino
comma
id|type
comma
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|attr
)paren
(brace
id|ntfs_debug
c_func
(paren
id|DEBUG_FILE3
comma
id|__FUNCTION__
l_string|&quot;(): attr 0x%x not found &quot;
l_string|&quot;in inode 0x%x&bslash;n&quot;
comma
id|type
comma
id|ino-&gt;i_number
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
id|ntfs_readwrite_attr
c_func
(paren
id|ino
comma
id|attr
comma
id|offset
comma
id|buf
)paren
suffix:semicolon
)brace
DECL|function|ntfs_write_attr
r_int
id|ntfs_write_attr
c_func
(paren
id|ntfs_inode
op_star
id|ino
comma
r_int
id|type
comma
r_char
op_star
id|name
comma
id|__s64
id|offset
comma
id|ntfs_io
op_star
id|buf
)paren
(brace
id|ntfs_attribute
op_star
id|attr
suffix:semicolon
id|buf-&gt;do_read
op_assign
l_int|0
suffix:semicolon
id|attr
op_assign
id|ntfs_find_attr
c_func
(paren
id|ino
comma
id|type
comma
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|attr
)paren
(brace
id|ntfs_debug
c_func
(paren
id|DEBUG_FILE3
comma
id|__FUNCTION__
l_string|&quot;(): attr 0x%x not found &quot;
l_string|&quot;in inode 0x%x&bslash;n&quot;
comma
id|type
comma
id|ino-&gt;i_number
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
id|ntfs_readwrite_attr
c_func
(paren
id|ino
comma
id|attr
comma
id|offset
comma
id|buf
)paren
suffix:semicolon
)brace
multiline_comment|/* -2 = error, -1 = hole, &gt;= 0 means real disk cluster (lcn). */
DECL|function|ntfs_vcn_to_lcn
r_int
id|ntfs_vcn_to_lcn
c_func
(paren
id|ntfs_inode
op_star
id|ino
comma
r_int
id|vcn
)paren
(brace
r_int
id|rnum
suffix:semicolon
id|ntfs_attribute
op_star
id|data
suffix:semicolon
id|data
op_assign
id|ntfs_find_attr
c_func
(paren
id|ino
comma
id|ino-&gt;vol-&gt;at_data
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|data
op_logical_or
id|data-&gt;resident
op_logical_or
id|data-&gt;flags
op_amp
(paren
id|ATTR_IS_COMPRESSED
op_or
id|ATTR_IS_ENCRYPTED
)paren
)paren
r_return
op_minus
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|data-&gt;size
op_le
(paren
id|__s64
)paren
id|vcn
op_lshift
id|ino-&gt;vol-&gt;cluster_size_bits
)paren
r_return
op_minus
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|data-&gt;initialized
op_le
(paren
id|__s64
)paren
id|vcn
op_lshift
id|ino-&gt;vol-&gt;cluster_size_bits
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|rnum
op_assign
l_int|0
suffix:semicolon
id|rnum
OL
id|data-&gt;d.r.len
op_logical_and
id|vcn
op_ge
id|data-&gt;d.r.runlist
(braket
id|rnum
)braket
dot
id|len
suffix:semicolon
id|rnum
op_increment
)paren
id|vcn
op_sub_assign
id|data-&gt;d.r.runlist
(braket
id|rnum
)braket
dot
id|len
suffix:semicolon
r_if
c_cond
(paren
id|data-&gt;d.r.runlist
(braket
id|rnum
)braket
dot
id|lcn
op_ge
l_int|0
)paren
r_return
id|data-&gt;d.r.runlist
(braket
id|rnum
)braket
dot
id|lcn
op_plus
id|vcn
suffix:semicolon
r_return
id|data-&gt;d.r.runlist
(braket
id|rnum
)braket
dot
id|lcn
op_plus
id|vcn
suffix:semicolon
)brace
DECL|function|allocate_store
r_static
r_int
id|allocate_store
c_func
(paren
id|ntfs_volume
op_star
id|vol
comma
id|ntfs_disk_inode
op_star
id|store
comma
r_int
id|count
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|store-&gt;count
OG
id|count
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|store-&gt;size
OL
id|count
)paren
(brace
id|ntfs_mft_record
op_star
id|n
op_assign
id|ntfs_malloc
c_func
(paren
(paren
id|count
op_plus
l_int|4
)paren
op_star
r_sizeof
(paren
id|ntfs_mft_record
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|n
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
id|store-&gt;size
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|store-&gt;size
suffix:semicolon
id|i
op_increment
)paren
id|n
(braket
id|i
)braket
op_assign
id|store-&gt;records
(braket
id|i
)braket
suffix:semicolon
id|ntfs_free
c_func
(paren
id|store-&gt;records
)paren
suffix:semicolon
)brace
id|store-&gt;size
op_assign
id|count
op_plus
l_int|4
suffix:semicolon
id|store-&gt;records
op_assign
id|n
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
id|store-&gt;count
suffix:semicolon
id|i
OL
id|count
suffix:semicolon
id|i
op_increment
)paren
(brace
id|store-&gt;records
(braket
id|i
)braket
dot
id|record
op_assign
id|ntfs_malloc
c_func
(paren
id|vol-&gt;mft_record_size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|store-&gt;records
(braket
id|i
)braket
dot
id|record
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|store-&gt;count
op_increment
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|deallocate_store
r_static
r_void
id|deallocate_store
c_func
(paren
id|ntfs_disk_inode
op_star
id|store
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|store-&gt;count
suffix:semicolon
id|i
op_increment
)paren
id|ntfs_free
c_func
(paren
id|store-&gt;records
(braket
id|i
)braket
dot
id|record
)paren
suffix:semicolon
id|ntfs_free
c_func
(paren
id|store-&gt;records
)paren
suffix:semicolon
id|store-&gt;count
op_assign
id|store-&gt;size
op_assign
l_int|0
suffix:semicolon
id|store-&gt;records
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * layout_runs - compress runlist into mapping pairs array&n; * @attr:&t;attribute containing the runlist to compress&n; * @rec:&t;destination buffer to hold the mapping pairs array&n; * @offs:&t;current position in @rec (in/out variable)&n; * @size:&t;size of the buffer @rec&n; *&n; * layout_runs walks the runlist in @attr, compresses it and writes it out the&n; * resulting mapping pairs array into @rec (up to a maximum of @size bytes are&n; * written). On entry @offs is the offset in @rec at which to begin writing the&n; * mapping pairs array. On exit, it contains the offset in @rec of the first&n; * byte after the end of the mapping pairs array.&n; */
DECL|function|layout_runs
r_static
r_int
id|layout_runs
c_func
(paren
id|ntfs_attribute
op_star
id|attr
comma
r_char
op_star
id|rec
comma
r_int
op_star
id|offs
comma
r_int
id|size
)paren
(brace
r_int
id|i
comma
id|len
comma
id|offset
comma
id|coffs
suffix:semicolon
multiline_comment|/* ntfs_cluster_t MUST be signed! (AIA) */
id|ntfs_cluster_t
id|cluster
comma
id|rclus
suffix:semicolon
id|ntfs_runlist
op_star
id|rl
op_assign
id|attr-&gt;d.r.runlist
suffix:semicolon
id|cluster
op_assign
l_int|0
suffix:semicolon
id|offset
op_assign
op_star
id|offs
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|attr-&gt;d.r.len
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/*&n;&t;&t; * We cheat with this check on the basis that lcn will never&n;&t;&t; * be less than -1 and the lcn delta will fit in signed&n;&t;&t; * 32-bits (ntfs_cluster_t). (AIA)&n;&t;&t; */
r_if
c_cond
(paren
id|rl
(braket
id|i
)braket
dot
id|lcn
OL
(paren
id|ntfs_cluster_t
)paren
op_minus
l_int|1
)paren
(brace
id|ntfs_error
c_func
(paren
l_string|&quot;layout_runs() encountered an out of bounds &quot;
l_string|&quot;cluster delta, lcn = %i.&bslash;n&quot;
comma
id|rl
(braket
id|i
)braket
dot
id|lcn
)paren
suffix:semicolon
r_return
op_minus
id|ERANGE
suffix:semicolon
)brace
id|rclus
op_assign
id|rl
(braket
id|i
)braket
dot
id|lcn
op_minus
id|cluster
suffix:semicolon
id|len
op_assign
id|rl
(braket
id|i
)braket
dot
id|len
suffix:semicolon
id|rec
(braket
id|offset
)braket
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|offset
op_plus
l_int|9
OG
id|size
)paren
r_return
op_minus
id|E2BIG
suffix:semicolon
multiline_comment|/* It might still fit, but this&n;&t;&t;&t;&t;&t;* simplifies testing. */
multiline_comment|/*&n;&t;&t; * Run length is stored as signed number, so deal with it&n;&t;&t; * properly, i.e. observe that a negative number will have all&n;&t;&t; * its most significant bits set to 1 but we don&squot;t store that&n;&t;&t; * in the mapping pairs array. We store the smallest type of&n;&t;&t; * negative number required, thus in the first if we check&n;&t;&t; * whether len fits inside a signed byte and if so we store it&n;&t;&t; * as such, the next ifs check for a signed short, then a signed&n;&t;&t; * 24-bit and finally the full blown signed 32-bit. Same goes&n;&t;&t; * for rlus below. (AIA)&n;&t;&t; */
r_if
c_cond
(paren
id|len
op_ge
op_minus
l_int|0x80
op_logical_and
id|len
op_le
l_int|0x7f
)paren
(brace
id|NTFS_PUTU8
c_func
(paren
id|rec
op_plus
id|offset
op_plus
l_int|1
comma
id|len
op_amp
l_int|0xff
)paren
suffix:semicolon
id|coffs
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|len
op_ge
op_minus
l_int|0x8000
op_logical_and
id|len
op_le
l_int|0x7fff
)paren
(brace
id|NTFS_PUTU16
c_func
(paren
id|rec
op_plus
id|offset
op_plus
l_int|1
comma
id|len
op_amp
l_int|0xffff
)paren
suffix:semicolon
id|coffs
op_assign
l_int|2
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|len
op_ge
op_minus
l_int|0x800000
op_logical_and
id|len
op_le
l_int|0x7fffff
)paren
(brace
id|NTFS_PUTU24
c_func
(paren
id|rec
op_plus
id|offset
op_plus
l_int|1
comma
id|len
op_amp
l_int|0xffffff
)paren
suffix:semicolon
id|coffs
op_assign
l_int|3
suffix:semicolon
)brace
r_else
multiline_comment|/* if (len &gt;= -0x80000000LL &amp;&amp; len &lt;= 0x7fffffff */
(brace
id|NTFS_PUTU32
c_func
(paren
id|rec
op_plus
id|offset
op_plus
l_int|1
comma
id|len
)paren
suffix:semicolon
id|coffs
op_assign
l_int|4
suffix:semicolon
)brace
multiline_comment|/* else ... FIXME: When len becomes 64-bit we need to extend&n;&t;&t;   * &t;&t;     the else if () statements. (AIA) */
op_star
(paren
id|rec
op_plus
id|offset
)paren
op_or_assign
id|coffs
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|rl
(braket
id|i
)braket
dot
id|lcn
op_eq
(paren
id|ntfs_cluster_t
)paren
op_minus
l_int|1
)paren
multiline_comment|/* Compressed run. */
multiline_comment|/* Nothing */
suffix:semicolon
r_else
r_if
c_cond
(paren
id|rclus
op_ge
op_minus
l_int|0x80
op_logical_and
id|rclus
op_le
l_int|0x7f
)paren
(brace
op_star
(paren
id|rec
op_plus
id|offset
)paren
op_or_assign
l_int|0x10
suffix:semicolon
id|NTFS_PUTS8
c_func
(paren
id|rec
op_plus
id|offset
op_plus
id|coffs
comma
id|rclus
op_amp
l_int|0xff
)paren
suffix:semicolon
id|coffs
op_add_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|rclus
op_ge
op_minus
l_int|0x8000
op_logical_and
id|rclus
op_le
l_int|0x7fff
)paren
(brace
op_star
(paren
id|rec
op_plus
id|offset
)paren
op_or_assign
l_int|0x20
suffix:semicolon
id|NTFS_PUTS16
c_func
(paren
id|rec
op_plus
id|offset
op_plus
id|coffs
comma
id|rclus
op_amp
l_int|0xffff
)paren
suffix:semicolon
id|coffs
op_add_assign
l_int|2
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|rclus
op_ge
op_minus
l_int|0x800000
op_logical_and
id|rclus
op_le
l_int|0x7fffff
)paren
(brace
op_star
(paren
id|rec
op_plus
id|offset
)paren
op_or_assign
l_int|0x30
suffix:semicolon
id|NTFS_PUTS24
c_func
(paren
id|rec
op_plus
id|offset
op_plus
id|coffs
comma
id|rclus
op_amp
l_int|0xffffff
)paren
suffix:semicolon
id|coffs
op_add_assign
l_int|3
suffix:semicolon
)brace
r_else
multiline_comment|/* if (rclus &gt;= -0x80000000LL &amp;&amp; rclus &lt;= 0x7fffffff)*/
(brace
op_star
(paren
id|rec
op_plus
id|offset
)paren
op_or_assign
l_int|0x40
suffix:semicolon
id|NTFS_PUTS32
c_func
(paren
id|rec
op_plus
id|offset
op_plus
id|coffs
comma
id|rclus
multiline_comment|/* &amp; 0xffffffffLL */
)paren
suffix:semicolon
id|coffs
op_add_assign
l_int|4
suffix:semicolon
)brace
multiline_comment|/* FIXME: When rclus becomes 64-bit.&n;&t;&t;else if (rclus &gt;= -0x8000000000 &amp;&amp; rclus &lt;= 0x7FFFFFFFFF) {&n;&t;&t;&t;*(rec + offset) |= 0x50;&n;&t;&t;&t;NTFS_PUTS40(rec + offset + coffs, rclus &amp;&n;&t;&t;&t;&t;&t;&t;&t;0xffffffffffLL);&n;&t;&t;&t;coffs += 5;&n;&t;&t;} else if (rclus &gt;= -0x800000000000 &amp;&amp; &n;&t;&t;&t;&t;&t;&t;rclus &lt;= 0x7FFFFFFFFFFF) {&n;&t;&t;&t;*(rec + offset) |= 0x60;&n;&t;&t;&t;NTFS_PUTS48(rec + offset + coffs, rclus &amp;&n;&t;&t;&t;&t;&t;&t;&t;0xffffffffffffLL);&n;&t;&t;&t;coffs += 6;&n;&t;&t;} else if (rclus &gt;= -0x80000000000000 &amp;&amp; &n;&t;&t;&t;&t;&t;&t;rclus &lt;= 0x7FFFFFFFFFFFFF) {&n;&t;&t;&t;*(rec + offset) |= 0x70;&n;&t;&t;&t;NTFS_PUTS56(rec + offset + coffs, rclus &amp;&n;&t;&t;&t;&t;&t;&t;&t;0xffffffffffffffLL);&n;&t;&t;&t;coffs += 7;&n;&t;&t;} else {&n;&t;&t;&t;*(rec + offset) |= 0x80;&n;&t;&t;&t;NTFS_PUTS64(rec + offset + coffs, rclus);&n;&t;&t;&t;coffs += 8;&n;&t;&t;} */
id|offset
op_add_assign
id|coffs
suffix:semicolon
r_if
c_cond
(paren
id|rl
(braket
id|i
)braket
dot
id|lcn
)paren
id|cluster
op_assign
id|rl
(braket
id|i
)braket
dot
id|lcn
suffix:semicolon
)brace
r_if
c_cond
(paren
id|offset
op_ge
id|size
)paren
r_return
op_minus
id|E2BIG
suffix:semicolon
multiline_comment|/* Terminating null. */
op_star
(paren
id|rec
op_plus
id|offset
op_increment
)paren
op_assign
l_int|0
suffix:semicolon
op_star
id|offs
op_assign
id|offset
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|count_runs
r_static
r_void
id|count_runs
c_func
(paren
id|ntfs_attribute
op_star
id|attr
comma
r_char
op_star
id|buf
)paren
(brace
id|ntfs_u32
id|first
comma
id|count
comma
id|last
comma
id|i
suffix:semicolon
id|first
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|count
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|attr-&gt;d.r.len
suffix:semicolon
id|i
op_increment
)paren
id|count
op_add_assign
id|attr-&gt;d.r.runlist
(braket
id|i
)braket
dot
id|len
suffix:semicolon
id|last
op_assign
id|first
op_plus
id|count
op_minus
l_int|1
suffix:semicolon
id|NTFS_PUTU64
c_func
(paren
id|buf
op_plus
l_int|0x10
comma
id|first
)paren
suffix:semicolon
id|NTFS_PUTU64
c_func
(paren
id|buf
op_plus
l_int|0x18
comma
id|last
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * layout_attr - convert in memory attribute to on disk attribute record&n; * @attr:&t;in memory attribute to convert&n; * @buf:&t;destination buffer for on disk attribute record&n; * @size:&t;size of the destination buffer&n; * @psize:&t;size of converted on disk attribute record (out variable)&n; *&n; * layout_attr() takes the attribute @attr and converts it into the appropriate&n; * on disk structure, writing it into @buf (up to @size bytes are written).&n; *&n; * On success we return 0 and set @*psize to the actual byte size of the on-&n; * disk attribute that was written into @buf.&n; */
DECL|function|layout_attr
r_static
r_int
id|layout_attr
c_func
(paren
id|ntfs_attribute
op_star
id|attr
comma
r_char
op_star
id|buf
comma
r_int
id|size
comma
r_int
op_star
id|psize
)paren
(brace
r_int
id|nameoff
comma
id|hdrsize
comma
id|asize
suffix:semicolon
r_if
c_cond
(paren
id|attr-&gt;resident
)paren
(brace
id|nameoff
op_assign
l_int|0x18
suffix:semicolon
id|hdrsize
op_assign
(paren
id|nameoff
op_plus
l_int|2
op_star
id|attr-&gt;namelen
op_plus
l_int|7
)paren
op_amp
op_complement
l_int|7
suffix:semicolon
id|asize
op_assign
(paren
id|hdrsize
op_plus
id|attr-&gt;size
op_plus
l_int|7
)paren
op_amp
op_complement
l_int|7
suffix:semicolon
r_if
c_cond
(paren
id|size
OL
id|asize
)paren
r_return
op_minus
id|E2BIG
suffix:semicolon
id|NTFS_PUTU32
c_func
(paren
id|buf
op_plus
l_int|0x10
comma
id|attr-&gt;size
)paren
suffix:semicolon
id|NTFS_PUTU8
c_func
(paren
id|buf
op_plus
l_int|0x16
comma
id|attr-&gt;indexed
)paren
suffix:semicolon
id|NTFS_PUTU16
c_func
(paren
id|buf
op_plus
l_int|0x14
comma
id|hdrsize
)paren
suffix:semicolon
r_if
c_cond
(paren
id|attr-&gt;size
)paren
id|ntfs_memcpy
c_func
(paren
id|buf
op_plus
id|hdrsize
comma
id|attr-&gt;d.data
comma
id|attr-&gt;size
)paren
suffix:semicolon
)brace
r_else
(brace
r_int
id|error
suffix:semicolon
r_if
c_cond
(paren
id|attr-&gt;flags
op_amp
id|ATTR_IS_COMPRESSED
)paren
id|nameoff
op_assign
l_int|0x48
suffix:semicolon
r_else
id|nameoff
op_assign
l_int|0x40
suffix:semicolon
id|hdrsize
op_assign
(paren
id|nameoff
op_plus
l_int|2
op_star
id|attr-&gt;namelen
op_plus
l_int|7
)paren
op_amp
op_complement
l_int|7
suffix:semicolon
r_if
c_cond
(paren
id|size
OL
id|hdrsize
)paren
r_return
op_minus
id|E2BIG
suffix:semicolon
multiline_comment|/* Make asize point at the end of the attribute record header,&n;&t;&t;   i.e. at the beginning of the mapping pairs array. */
id|asize
op_assign
id|hdrsize
suffix:semicolon
id|error
op_assign
id|layout_runs
c_func
(paren
id|attr
comma
id|buf
comma
op_amp
id|asize
comma
id|size
)paren
suffix:semicolon
multiline_comment|/* Now, asize points one byte beyond the end of the mapping&n;&t;&t;   pairs array. */
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
multiline_comment|/* The next attribute has to begin on 8-byte boundary. */
id|asize
op_assign
(paren
id|asize
op_plus
l_int|7
)paren
op_amp
op_complement
l_int|7
suffix:semicolon
multiline_comment|/* FIXME: fragments */
id|count_runs
c_func
(paren
id|attr
comma
id|buf
)paren
suffix:semicolon
id|NTFS_PUTU16
c_func
(paren
id|buf
op_plus
l_int|0x20
comma
id|hdrsize
)paren
suffix:semicolon
id|NTFS_PUTU16
c_func
(paren
id|buf
op_plus
l_int|0x22
comma
id|attr-&gt;cengine
)paren
suffix:semicolon
id|NTFS_PUTU32
c_func
(paren
id|buf
op_plus
l_int|0x24
comma
l_int|0
)paren
suffix:semicolon
id|NTFS_PUTS64
c_func
(paren
id|buf
op_plus
l_int|0x28
comma
id|attr-&gt;allocated
)paren
suffix:semicolon
id|NTFS_PUTS64
c_func
(paren
id|buf
op_plus
l_int|0x30
comma
id|attr-&gt;size
)paren
suffix:semicolon
id|NTFS_PUTS64
c_func
(paren
id|buf
op_plus
l_int|0x38
comma
id|attr-&gt;initialized
)paren
suffix:semicolon
r_if
c_cond
(paren
id|attr-&gt;flags
op_amp
id|ATTR_IS_COMPRESSED
)paren
id|NTFS_PUTS64
c_func
(paren
id|buf
op_plus
l_int|0x40
comma
id|attr-&gt;compsize
)paren
suffix:semicolon
)brace
id|NTFS_PUTU32
c_func
(paren
id|buf
comma
id|attr-&gt;type
)paren
suffix:semicolon
id|NTFS_PUTU32
c_func
(paren
id|buf
op_plus
l_int|4
comma
id|asize
)paren
suffix:semicolon
id|NTFS_PUTU8
c_func
(paren
id|buf
op_plus
l_int|8
comma
id|attr-&gt;resident
ques
c_cond
l_int|0
suffix:colon
l_int|1
)paren
suffix:semicolon
id|NTFS_PUTU8
c_func
(paren
id|buf
op_plus
l_int|9
comma
id|attr-&gt;namelen
)paren
suffix:semicolon
id|NTFS_PUTU16
c_func
(paren
id|buf
op_plus
l_int|0xa
comma
id|nameoff
)paren
suffix:semicolon
id|NTFS_PUTU16
c_func
(paren
id|buf
op_plus
l_int|0xc
comma
id|attr-&gt;flags
)paren
suffix:semicolon
id|NTFS_PUTU16
c_func
(paren
id|buf
op_plus
l_int|0xe
comma
id|attr-&gt;attrno
)paren
suffix:semicolon
r_if
c_cond
(paren
id|attr-&gt;namelen
)paren
id|ntfs_memcpy
c_func
(paren
id|buf
op_plus
id|nameoff
comma
id|attr-&gt;name
comma
l_int|2
op_star
id|attr-&gt;namelen
)paren
suffix:semicolon
op_star
id|psize
op_assign
id|asize
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * layout_inode - convert an in-memory inode into on disk mft record(s)&n; * @ino:&t;in memory inode to convert&n; * @store:&t;on disk inode, contain buffers for the on disk mft record(s)&n; *&n; * layout_inode takes the in memory inode @ino, converts it into a (sequence of)&n; * mft record(s) and writes them to the appropriate buffers in the @store.&n; *&n; * Return 0 on success,&n; * the required mft record count (&gt;0) if the inode does not fit,&n; * -ENOMEM if memory allocation problem, or&n; * -EOPNOTSUP if beyond our capabilities.&n; *&n; * TODO: We at the moment do not support extension mft records. (AIA)&n; */
DECL|function|layout_inode
r_int
id|layout_inode
c_func
(paren
id|ntfs_inode
op_star
id|ino
comma
id|ntfs_disk_inode
op_star
id|store
)paren
(brace
r_int
id|offset
comma
id|i
comma
id|size
comma
id|psize
comma
id|error
comma
id|count
comma
id|recno
suffix:semicolon
id|ntfs_attribute
op_star
id|attr
suffix:semicolon
r_int
r_char
op_star
id|rec
suffix:semicolon
id|error
op_assign
id|allocate_store
c_func
(paren
id|ino-&gt;vol
comma
id|store
comma
id|ino-&gt;record_count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
id|size
op_assign
id|ino-&gt;vol-&gt;mft_record_size
suffix:semicolon
id|count
op_assign
id|i
op_assign
l_int|0
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|count
OL
id|ino-&gt;record_count
)paren
(brace
id|recno
op_assign
id|ino-&gt;records
(braket
id|count
)braket
suffix:semicolon
)brace
r_else
(brace
id|error
op_assign
id|allocate_store
c_func
(paren
id|ino-&gt;vol
comma
id|store
comma
id|count
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
id|recno
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * FIXME: We need to support extension records properly.&n;&t;&t; * At the moment they wouldn&squot;t work. Probably would &quot;just&quot; get&n;&t;&t; * corrupted if we write to them... (AIA)&n;&t;&t; */
id|store-&gt;records
(braket
id|count
)braket
dot
id|recno
op_assign
id|recno
suffix:semicolon
id|rec
op_assign
id|store-&gt;records
(braket
id|count
)braket
dot
id|record
suffix:semicolon
id|count
op_increment
suffix:semicolon
multiline_comment|/* Copy mft record header. */
id|offset
op_assign
id|NTFS_GETU16
c_func
(paren
id|ino-&gt;attr
op_plus
l_int|0x14
)paren
suffix:semicolon
multiline_comment|/* attrs_offset */
id|ntfs_memcpy
c_func
(paren
id|rec
comma
id|ino-&gt;attr
comma
id|offset
)paren
suffix:semicolon
multiline_comment|/* Copy attributes. */
r_while
c_loop
(paren
id|i
OL
id|ino-&gt;attr_count
)paren
(brace
id|attr
op_assign
id|ino-&gt;attrs
op_plus
id|i
suffix:semicolon
id|error
op_assign
id|layout_attr
c_func
(paren
id|attr
comma
id|rec
op_plus
id|offset
comma
id|size
op_minus
id|offset
op_minus
l_int|8
comma
op_amp
id|psize
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_eq
op_minus
id|E2BIG
op_logical_and
id|offset
op_ne
id|NTFS_GETU16
c_func
(paren
id|ino-&gt;attr
op_plus
l_int|0x14
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
id|offset
op_add_assign
id|psize
suffix:semicolon
id|i
op_increment
suffix:semicolon
)brace
multiline_comment|/* Terminating attribute. */
id|NTFS_PUTU32
c_func
(paren
id|rec
op_plus
id|offset
comma
l_int|0xFFFFFFFF
)paren
suffix:semicolon
id|offset
op_add_assign
l_int|4
suffix:semicolon
id|NTFS_PUTU32
c_func
(paren
id|rec
op_plus
id|offset
comma
l_int|0
)paren
suffix:semicolon
id|offset
op_add_assign
l_int|4
suffix:semicolon
id|NTFS_PUTU32
c_func
(paren
id|rec
op_plus
l_int|0x18
comma
id|offset
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|i
OL
id|ino-&gt;attr_count
op_logical_or
id|count
OL
id|ino-&gt;record_count
)paren
suffix:semicolon
r_return
id|count
op_minus
id|ino-&gt;record_count
suffix:semicolon
)brace
multiline_comment|/*&n; * FIXME: ntfs_update_inode() calls layout_inode() to create the mft record on&n; * disk structure corresponding to the inode @ino. After that, ntfs_write_attr()&n; * is called to write out the created mft record to disk.&n; * We shouldn&squot;t need to re-layout every single time we are updating an mft&n; * record. No wonder the ntfs driver is slow like hell. (AIA)&n; */
DECL|function|ntfs_update_inode
r_int
id|ntfs_update_inode
c_func
(paren
id|ntfs_inode
op_star
id|ino
)paren
(brace
r_int
id|error
comma
id|i
suffix:semicolon
id|ntfs_disk_inode
id|store
suffix:semicolon
id|ntfs_io
id|io
suffix:semicolon
id|ntfs_bzero
c_func
(paren
op_amp
id|store
comma
r_sizeof
(paren
id|store
)paren
)paren
suffix:semicolon
id|error
op_assign
id|layout_inode
c_func
(paren
id|ino
comma
op_amp
id|store
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_eq
op_minus
id|E2BIG
)paren
(brace
id|i
op_assign
id|ntfs_split_indexroot
c_func
(paren
id|ino
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_ne
op_minus
id|ENOTDIR
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|i
)paren
id|i
op_assign
id|layout_inode
c_func
(paren
id|ino
comma
op_amp
id|store
)paren
suffix:semicolon
id|error
op_assign
id|i
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|error
op_eq
op_minus
id|E2BIG
)paren
(brace
id|error
op_assign
id|ntfs_attr_allnonresident
c_func
(paren
id|ino
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
id|error
op_assign
id|layout_inode
c_func
(paren
id|ino
comma
op_amp
id|store
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|error
OG
l_int|0
)paren
(brace
multiline_comment|/* FIXME: Introduce extension records. */
id|error
op_assign
op_minus
id|E2BIG
suffix:semicolon
)brace
r_if
c_cond
(paren
id|error
)paren
(brace
r_if
c_cond
(paren
id|error
op_eq
op_minus
id|E2BIG
)paren
id|ntfs_error
c_func
(paren
l_string|&quot;Cannot handle saving inode 0x%x.&bslash;n&quot;
comma
id|ino-&gt;i_number
)paren
suffix:semicolon
id|deallocate_store
c_func
(paren
op_amp
id|store
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
id|io.fn_get
op_assign
id|ntfs_get
suffix:semicolon
id|io.fn_put
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|store.count
suffix:semicolon
id|i
op_increment
)paren
(brace
id|error
op_assign
id|ntfs_insert_fixups
c_func
(paren
id|store.records
(braket
id|i
)braket
dot
id|record
comma
id|ino-&gt;vol-&gt;mft_record_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|printk
c_func
(paren
id|KERN_ALERT
l_string|&quot;NTFS: ntfs_update_inode() caught &quot;
l_string|&quot;corrupt %s mtf record ntfs record &quot;
l_string|&quot;header. Refusing to write corrupt &quot;
l_string|&quot;data to disk. Unmount and run chkdsk &quot;
l_string|&quot;immediately!&bslash;n&quot;
comma
id|i
ques
c_cond
l_string|&quot;extension&quot;
suffix:colon
l_string|&quot;base&quot;
)paren
suffix:semicolon
id|deallocate_store
c_func
(paren
op_amp
id|store
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|io.param
op_assign
id|store.records
(braket
id|i
)braket
dot
id|record
suffix:semicolon
id|io.size
op_assign
id|ino-&gt;vol-&gt;mft_record_size
suffix:semicolon
id|error
op_assign
id|ntfs_write_attr
c_func
(paren
id|ino-&gt;vol-&gt;mft_ino
comma
id|ino-&gt;vol-&gt;at_data
comma
l_int|0
comma
(paren
id|__s64
)paren
id|store.records
(braket
id|i
)braket
dot
id|recno
op_lshift
id|ino-&gt;vol-&gt;mft_record_size_bits
comma
op_amp
id|io
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_logical_or
id|io.size
op_ne
id|ino-&gt;vol-&gt;mft_record_size
)paren
(brace
multiline_comment|/* Big trouble, partially written file. */
id|ntfs_error
c_func
(paren
l_string|&quot;Please unmount: Write error in inode &quot;
l_string|&quot;0x%x&bslash;n&quot;
comma
id|ino-&gt;i_number
)paren
suffix:semicolon
id|deallocate_store
c_func
(paren
op_amp
id|store
)paren
suffix:semicolon
r_return
id|error
ques
c_cond
id|error
suffix:colon
op_minus
id|EIO
suffix:semicolon
)brace
)brace
id|deallocate_store
c_func
(paren
op_amp
id|store
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ntfs_decompress
r_void
id|ntfs_decompress
c_func
(paren
r_int
r_char
op_star
id|dest
comma
r_int
r_char
op_star
id|src
comma
id|ntfs_size_t
id|l
)paren
(brace
r_int
id|head
comma
id|comp
suffix:semicolon
r_int
id|copied
op_assign
l_int|0
suffix:semicolon
r_int
r_char
op_star
id|stop
suffix:semicolon
r_int
id|bits
suffix:semicolon
r_int
id|tag
op_assign
l_int|0
suffix:semicolon
r_int
id|clear_pos
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|head
op_assign
id|NTFS_GETU16
c_func
(paren
id|src
)paren
op_amp
l_int|0xFFF
suffix:semicolon
multiline_comment|/* High bit indicates that compression was performed. */
id|comp
op_assign
id|NTFS_GETU16
c_func
(paren
id|src
)paren
op_amp
l_int|0x8000
suffix:semicolon
id|src
op_add_assign
l_int|2
suffix:semicolon
id|stop
op_assign
id|src
op_plus
id|head
suffix:semicolon
id|bits
op_assign
l_int|0
suffix:semicolon
id|clear_pos
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|head
op_eq
l_int|0
)paren
multiline_comment|/* Block is not used. */
r_return
suffix:semicolon
multiline_comment|/* FIXME: copied */
r_if
c_cond
(paren
op_logical_neg
id|comp
)paren
(brace
multiline_comment|/* uncompressible */
id|ntfs_memcpy
c_func
(paren
id|dest
comma
id|src
comma
l_int|0x1000
)paren
suffix:semicolon
id|dest
op_add_assign
l_int|0x1000
suffix:semicolon
id|copied
op_add_assign
l_int|0x1000
suffix:semicolon
id|src
op_add_assign
l_int|0x1000
suffix:semicolon
r_if
c_cond
(paren
id|l
op_eq
id|copied
)paren
r_return
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_while
c_loop
(paren
id|src
op_le
id|stop
)paren
(brace
r_if
c_cond
(paren
id|clear_pos
OG
l_int|4096
)paren
(brace
id|ntfs_error
c_func
(paren
l_string|&quot;Error 1 in decompress&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|bits
)paren
(brace
id|tag
op_assign
id|NTFS_GETU8
c_func
(paren
id|src
)paren
suffix:semicolon
id|bits
op_assign
l_int|8
suffix:semicolon
id|src
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|src
OG
id|stop
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tag
op_amp
l_int|1
)paren
(brace
r_int
id|i
comma
id|len
comma
id|delta
comma
id|code
comma
id|lmask
comma
id|dshift
suffix:semicolon
id|code
op_assign
id|NTFS_GETU16
c_func
(paren
id|src
)paren
suffix:semicolon
id|src
op_add_assign
l_int|2
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|clear_pos
)paren
(brace
id|ntfs_error
c_func
(paren
l_string|&quot;Error 2 in decompress&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
id|clear_pos
op_minus
l_int|1
comma
id|lmask
op_assign
l_int|0xFFF
comma
id|dshift
op_assign
l_int|12
suffix:semicolon
id|i
op_ge
l_int|0x10
suffix:semicolon
id|i
op_rshift_assign
l_int|1
)paren
(brace
id|lmask
op_rshift_assign
l_int|1
suffix:semicolon
id|dshift
op_decrement
suffix:semicolon
)brace
id|delta
op_assign
id|code
op_rshift
id|dshift
suffix:semicolon
id|len
op_assign
(paren
id|code
op_amp
id|lmask
)paren
op_plus
l_int|3
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
suffix:semicolon
id|i
op_increment
)paren
(brace
id|dest
(braket
id|clear_pos
)braket
op_assign
id|dest
(braket
id|clear_pos
op_minus
id|delta
op_minus
l_int|1
)braket
suffix:semicolon
id|clear_pos
op_increment
suffix:semicolon
id|copied
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|copied
op_eq
id|l
)paren
r_return
suffix:semicolon
)brace
)brace
r_else
(brace
id|dest
(braket
id|clear_pos
op_increment
)braket
op_assign
id|NTFS_GETU8
c_func
(paren
id|src
)paren
suffix:semicolon
id|src
op_increment
suffix:semicolon
id|copied
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|copied
op_eq
id|l
)paren
r_return
suffix:semicolon
)brace
id|tag
op_rshift_assign
l_int|1
suffix:semicolon
id|bits
op_decrement
suffix:semicolon
)brace
id|dest
op_add_assign
id|clear_pos
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * NOTE: Neither of the ntfs_*_bit functions are atomic! But we don&squot;t need&n; * them atomic at present as we never operate on shared/cached bitmaps.&n; */
DECL|function|ntfs_test_bit
r_static
id|__inline__
r_int
id|ntfs_test_bit
c_func
(paren
r_int
r_char
op_star
id|byte
comma
r_const
r_int
id|bit
)paren
(brace
r_return
id|byte
(braket
id|bit
op_rshift
l_int|3
)braket
op_amp
(paren
l_int|1
op_lshift
(paren
id|bit
op_amp
l_int|7
)paren
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
)brace
DECL|function|ntfs_set_bit
r_static
id|__inline__
r_void
id|ntfs_set_bit
c_func
(paren
r_int
r_char
op_star
id|byte
comma
r_const
r_int
id|bit
)paren
(brace
id|byte
(braket
id|bit
op_rshift
l_int|3
)braket
op_or_assign
l_int|1
op_lshift
(paren
id|bit
op_amp
l_int|7
)paren
suffix:semicolon
)brace
DECL|function|ntfs_clear_bit
r_static
id|__inline__
r_void
id|ntfs_clear_bit
c_func
(paren
r_int
r_char
op_star
id|byte
comma
r_const
r_int
id|bit
)paren
(brace
id|byte
(braket
id|bit
op_rshift
l_int|3
)braket
op_and_assign
op_complement
(paren
l_int|1
op_lshift
(paren
id|bit
op_amp
l_int|7
)paren
)paren
suffix:semicolon
)brace
DECL|function|ntfs_test_and_clear_bit
r_static
id|__inline__
r_int
id|ntfs_test_and_clear_bit
c_func
(paren
r_int
r_char
op_star
id|byte
comma
r_const
r_int
id|bit
)paren
(brace
r_int
r_char
op_star
id|ptr
op_assign
id|byte
op_plus
(paren
id|bit
op_rshift
l_int|3
)paren
suffix:semicolon
r_int
id|b
op_assign
l_int|1
op_lshift
(paren
id|bit
op_amp
l_int|7
)paren
suffix:semicolon
r_int
id|oldbit
op_assign
op_star
id|ptr
op_amp
id|b
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
op_star
id|ptr
op_and_assign
op_complement
id|b
suffix:semicolon
r_return
id|oldbit
suffix:semicolon
)brace
DECL|function|dump_runlist
r_static
r_void
id|dump_runlist
c_func
(paren
r_const
id|ntfs_runlist
op_star
id|rl
comma
r_const
r_int
id|rlen
)paren
(brace
macro_line|#ifdef DEBUG
r_int
id|i
suffix:semicolon
id|ntfs_cluster_t
id|ct
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): rlen = %i.&bslash;n&quot;
comma
id|rlen
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
l_string|&quot;VCN        LCN        Run length&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|ct
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|rlen
suffix:semicolon
id|ct
op_add_assign
id|rl
(braket
id|i
op_increment
)braket
dot
id|len
)paren
(brace
r_if
c_cond
(paren
id|rl
(braket
id|i
)braket
dot
id|lcn
op_eq
(paren
id|ntfs_cluster_t
)paren
op_minus
l_int|1
)paren
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
l_string|&quot;0x%-8x LCN_HOLE   0x%-8x &quot;
l_string|&quot;(%s)&bslash;n&quot;
comma
id|ct
comma
id|rl
(braket
id|i
)braket
dot
id|len
comma
id|rl
(braket
id|i
)braket
dot
id|len
ques
c_cond
l_string|&quot;sparse run&quot;
suffix:colon
l_string|&quot;run list end&quot;
)paren
suffix:semicolon
r_else
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
l_string|&quot;0x%-8x 0x%-8x 0x%-8x%s&bslash;n&quot;
comma
id|ct
comma
id|rl
(braket
id|i
)braket
dot
id|lcn
comma
id|rl
(braket
id|i
)braket
dot
id|len
comma
id|rl
(braket
id|i
)braket
dot
id|len
op_logical_and
id|i
op_plus
l_int|1
OL
id|rlen
ques
c_cond
l_string|&quot;&quot;
suffix:colon
l_string|&quot; (run list end)&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rl
(braket
id|i
)braket
dot
id|len
)paren
r_break
suffix:semicolon
)brace
macro_line|#endif
)brace
multiline_comment|/**&n; * splice_runlists - splice two run lists into one&n; * @rl1:&t;pointer to address of first run list&n; * @r1len:&t;number of elementfs in first run list&n; * @rl2:&t;pointer to second run list&n; * @r2len:&t;number of elements in second run list&n; *&n; * Append the run list @rl2 to the run list *@rl1 and return the result in&n; * *@rl1 and *@r1len.&n; *&n; * Return 0 on success or -errno on error, in which case *@rl1 and *@r1len are&n; * left untouched.&n; *&n; * The only possible error code at the moment is -ENOMEM and only happens if&n; * there is insufficient memory to allocate the new run list (only happens&n; * when size of (rl1 + rl2) &gt; allocated size of rl1).&n; */
DECL|function|splice_runlists
r_int
id|splice_runlists
c_func
(paren
id|ntfs_runlist
op_star
op_star
id|rl1
comma
r_int
op_star
id|r1len
comma
r_const
id|ntfs_runlist
op_star
id|rl2
comma
r_int
id|r2len
)paren
(brace
id|ntfs_runlist
op_star
id|rl
suffix:semicolon
r_int
id|rlen
comma
id|rl_size
comma
id|rl2_pos
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): Entering with *r1len = %i, &quot;
l_string|&quot;r2len = %i.&bslash;n&quot;
comma
op_star
id|r1len
comma
id|r2len
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): Dumping 1st runlist.&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|rl1
)paren
id|dump_runlist
c_func
(paren
op_star
id|rl1
comma
op_star
id|r1len
)paren
suffix:semicolon
r_else
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): Not present.&bslash;n&quot;
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): Dumping 2nd runlist.&bslash;n&quot;
)paren
suffix:semicolon
id|dump_runlist
c_func
(paren
id|rl2
comma
id|r2len
)paren
suffix:semicolon
id|rlen
op_assign
op_star
id|r1len
op_plus
id|r2len
op_plus
l_int|1
suffix:semicolon
id|rl_size
op_assign
(paren
id|rlen
op_star
r_sizeof
(paren
id|ntfs_runlist
)paren
op_plus
id|PAGE_SIZE
op_minus
l_int|1
)paren
op_amp
id|PAGE_MASK
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): rlen = %i, rl_size = %i.&bslash;n&quot;
comma
id|rlen
comma
id|rl_size
)paren
suffix:semicolon
multiline_comment|/* Do we have enough space? */
r_if
c_cond
(paren
id|rl_size
op_le
(paren
(paren
op_star
id|r1len
op_star
r_sizeof
(paren
id|ntfs_runlist
)paren
op_plus
id|PAGE_SIZE
op_minus
l_int|1
)paren
op_amp
id|PAGE_MASK
)paren
)paren
(brace
multiline_comment|/* Have enough space already. */
id|rl
op_assign
op_star
id|rl1
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): Have enough space &quot;
l_string|&quot;already.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Need more space. Reallocate. */
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): Need more space.&bslash;n&quot;
)paren
suffix:semicolon
id|rl
op_assign
id|ntfs_vmalloc
c_func
(paren
id|rlen
op_lshift
r_sizeof
(paren
id|ntfs_runlist
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rl
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
multiline_comment|/* Copy over rl1. */
id|ntfs_memcpy
c_func
(paren
id|rl
comma
op_star
id|rl1
comma
op_star
id|r1len
op_star
r_sizeof
(paren
id|ntfs_runlist
)paren
)paren
suffix:semicolon
id|ntfs_vfree
c_func
(paren
op_star
id|rl1
)paren
suffix:semicolon
op_star
id|rl1
op_assign
id|rl
suffix:semicolon
)brace
multiline_comment|/* Reuse rl_size as the current position index into rl. */
id|rl_size
op_assign
op_star
id|r1len
op_minus
l_int|1
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): rl_size = %i.&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Coalesce neighbouring elements, if present. */
id|rl2_pos
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|rl
(braket
id|rl_size
)braket
dot
id|lcn
op_plus
id|rl
(braket
id|rl_size
)braket
dot
id|len
op_eq
id|rl2
(braket
id|rl2_pos
)braket
dot
id|lcn
)paren
(brace
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): Coalescing adjacent &quot;
l_string|&quot;runs.&bslash;n&quot;
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): Before: &quot;
l_string|&quot;rl[rl_size].len = %i.&bslash;n&quot;
comma
id|rl
(braket
id|rl_size
)braket
dot
id|len
)paren
suffix:semicolon
id|rl
(braket
id|rl_size
)braket
dot
id|len
op_add_assign
id|rl2
(braket
id|rl2_pos
)braket
dot
id|len
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): After: &quot;
l_string|&quot;rl[rl_size].len = %i.&bslash;n&quot;
comma
id|rl
(braket
id|rl_size
)braket
dot
id|len
)paren
suffix:semicolon
id|rl2_pos
op_increment
suffix:semicolon
id|r2len
op_decrement
suffix:semicolon
id|rlen
op_decrement
suffix:semicolon
)brace
id|rl_size
op_increment
suffix:semicolon
multiline_comment|/* Copy over rl2. */
id|ntfs_memcpy
c_func
(paren
id|rl
op_plus
id|rl_size
comma
id|rl2
op_plus
id|rl2_pos
comma
id|r2len
op_star
r_sizeof
(paren
id|ntfs_runlist
)paren
)paren
suffix:semicolon
id|rlen
op_decrement
suffix:semicolon
id|rl
(braket
id|rlen
)braket
dot
id|lcn
op_assign
(paren
id|ntfs_cluster_t
)paren
op_minus
l_int|1
suffix:semicolon
id|rl
(braket
id|rlen
)braket
dot
id|len
op_assign
(paren
id|ntfs_cluster_t
)paren
l_int|0
suffix:semicolon
op_star
id|r1len
op_assign
id|rlen
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): Dumping result runlist.&bslash;n&quot;
)paren
suffix:semicolon
id|dump_runlist
c_func
(paren
op_star
id|rl1
comma
op_star
id|r1len
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): Returning with *r1len = &quot;
l_string|&quot;%i.&bslash;n&quot;
comma
id|rlen
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_alloc_mft_record - allocate an mft record&n; * @vol:&t;volume to allocate an mft record on&n; * @result:&t;the mft record number allocated&n; *&n; * Allocate a new mft record on disk. Return 0 on success or -ERRNO on error.&n; * On success, *@result contains the allocated mft record number. On error,&n; * *@result is -1UL.&n; *&n; * Note, this function doesn&squot;t actually set the mft record to be in use. This&n; * is done by the caller, which at the moment is only ntfs_alloc_inode().&n; *&n; * To find a free mft record, we scan the mft bitmap for a zero bit. To&n; * optimize this we start scanning at the place where we last stopped and we&n; * perform wrap around when we reach the end. Note, we do not try to allocate&n; * mft records below number 24 because numbers 0 to 15 are the defined system&n; * files anyway and 16 to 24 are special in that they are used for storing&n; * extension mft records for $MFT&squot;s $DATA attribute. This is required to avoid&n; * the possibility of creating a run list with a circular dependence which once&n; * written to disk can never be read in again. Windows will only use records&n; * 16 to 24 for normal files if the volume is completely out of space. We never&n; * use them which means that when the volume is really out of space we cannot&n; * create any more files while Windows can still create up to 8 small files. We&n; * can start doing this at some later time, doesn&squot;t matter much for now.&n; *&n; * When scanning the mft bitmap, we only search up to the last allocated mft&n; * record. If there are no free records left in the range 24 to number of&n; * allocated mft records, then we extend the mft data in order to create free&n; * mft records. We extend the allocated size of $MFT/$DATA by 16 records at a&n; * time or one cluster, if cluster size is above 16kiB. If there isn&squot;t&n; * sufficient space to do this, we try to extend by a single mft record or one&n; * cluster, if cluster size is above mft record size, but we only do this if&n; * there is enough free space, which we know from the values returned by the&n; * failed cluster allocation function when we tried to do the first allocation.&n; *&n; * No matter how many mft records we allocate, we initialize only the first&n; * allocated mft record (incrementing mft data size and initialized size) and&n; * return its number to the caller in @*result, unless there are less than 24&n; * mft records, in which case we allocate and initialize mft records until we&n; * reach record 24 which we consider as the first free mft record for use by&n; * normal files.&n; *&n; * If during any stage we overflow the initialized data in the mft bitmap, we&n; * extend the initialized size (and data size) by 8 bytes, allocating another&n; * cluster if required. The bitmap data size has to be at least equal to the&n; * number of mft records in the mft, but it can be bigger, in which case the&n; * superflous bits are padded with zeroes.&n; *&n; * Thus, when we return successfully (return value 0), we will have:&n; *&t;- initialized / extended the mft bitmap if necessary,&n; *&t;- initialized / extended the mft data if necessary,&n; *&t;- set the bit corresponding to the mft record being allocated in the&n; *&t;  mft bitmap, and we will&n; *&t;- return the mft record number in @*result.&n; *&n; * On error (return value below zero), nothing will have changed. If we had&n; * changed anything before the error occured, we will have reverted back to&n; * the starting state before returning to the caller. Thus, except for bugs,&n; * we should always leave the volume in a consitents state when returning from&n; * this function. NOTE: Small exception to this is that we set the bit in the&n; * mft bitmap but we do not mark the mft record in use, which is inconsistent.&n; * However, the caller will immediately add the wanted attributes to the mft&n; * record, set it in use and write it out to disk, so there should be no&n; * problem.&n; *&n; * Note, this function cannot make use of most of the normal functions, like&n; * for example for attribute resizing, etc, because when the run list overflows&n; * the base mft record and an attribute list is used, it is very important&n; * that the extension mft records used to store the $DATA attribute of $MFT&n; * can be reached without having to read the information contained inside&n; * them, as this would make it impossible to find them in the first place&n; * after the volume is dismounted. $MFT/$BITMAP probably doesn&squot;t need to&n; * follow this rule because the bitmap is not essential for finding the mft&n; * records, but on the other hand, handling the bitmap in this special way&n; * would make life easier because otherwise there might be circular invocations&n; * of functions when reading the bitmap but if we are careful, we should be&n; * able to avoid all problems.&n; *&n; * FIXME: Don&squot;t forget $MftMirr, though this probably belongs in&n; *&t;  ntfs_update_inode() (or even deeper). (AIA)&n; *&n; * FIXME: Want finer grained locking. (AIA)&n; */
DECL|function|ntfs_alloc_mft_record
r_static
r_int
id|ntfs_alloc_mft_record
c_func
(paren
id|ntfs_volume
op_star
id|vol
comma
r_int
r_int
op_star
id|result
)paren
(brace
r_int
r_int
id|nr_mft_records
comma
id|buf_size
comma
id|buf_pos
comma
id|pass_start
comma
id|pass_end
suffix:semicolon
r_int
r_int
id|last_read_pos
comma
id|mft_rec_size
comma
id|bit
comma
id|l
suffix:semicolon
id|ntfs_attribute
op_star
id|data
comma
op_star
id|bmp
suffix:semicolon
id|__u8
op_star
id|buf
comma
op_star
id|byte
comma
id|pass
comma
id|b
comma
id|have_allocated_mftbmp
op_assign
l_int|0
suffix:semicolon
r_int
id|rlen
comma
id|rl_size
op_assign
l_int|0
comma
id|r2len
comma
id|rl2_size
comma
id|old_data_rlen
comma
id|err
op_assign
l_int|0
suffix:semicolon
id|ntfs_runlist
op_star
id|rl
comma
op_star
id|rl2
suffix:semicolon
id|ntfs_cluster_t
id|lcn
op_assign
l_int|0
comma
id|old_data_len
suffix:semicolon
id|ntfs_io
id|io
suffix:semicolon
id|__s64
id|ll
comma
id|old_data_allocated
comma
id|old_data_initialized
comma
id|old_data_size
suffix:semicolon
op_star
id|result
op_assign
op_minus
l_int|1UL
suffix:semicolon
multiline_comment|/* Allocate a buffer and setup the io structure. */
id|buf
op_assign
(paren
id|__u8
op_star
)paren
id|__get_free_page
c_func
(paren
id|GFP_NOFS
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buf
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Get the $DATA and $BITMAP attributes of $MFT. */
id|data
op_assign
id|ntfs_find_attr
c_func
(paren
id|vol-&gt;mft_ino
comma
id|vol-&gt;at_data
comma
l_int|0
)paren
suffix:semicolon
id|bmp
op_assign
id|ntfs_find_attr
c_func
(paren
id|vol-&gt;mft_ino
comma
id|vol-&gt;at_bitmap
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|data
op_logical_or
op_logical_neg
id|bmp
)paren
(brace
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|err_ret
suffix:semicolon
)brace
multiline_comment|/* Determine the number of allocated mft records in the mft. */
id|pass_end
op_assign
id|nr_mft_records
op_assign
id|data-&gt;allocated
op_rshift
id|vol-&gt;mft_record_size_bits
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): nr_mft_records = %lu.&bslash;n&quot;
comma
id|nr_mft_records
)paren
suffix:semicolon
multiline_comment|/* Make sure we don&squot;t overflow the bitmap. */
id|l
op_assign
id|bmp-&gt;initialized
op_lshift
l_int|3
suffix:semicolon
r_if
c_cond
(paren
id|l
OL
id|nr_mft_records
)paren
singleline_comment|// FIXME: It might be a good idea to extend the bitmap instead.
id|pass_end
op_assign
id|l
suffix:semicolon
id|pass
op_assign
l_int|1
suffix:semicolon
id|buf_pos
op_assign
id|vol-&gt;mft_data_pos
suffix:semicolon
r_if
c_cond
(paren
id|buf_pos
op_ge
id|pass_end
)paren
(brace
id|buf_pos
op_assign
l_int|24UL
suffix:semicolon
id|pass
op_assign
l_int|2
suffix:semicolon
)brace
id|pass_start
op_assign
id|buf_pos
suffix:semicolon
id|rl
op_assign
id|bmp-&gt;d.r.runlist
suffix:semicolon
id|rlen
op_assign
id|bmp-&gt;d.r.len
op_minus
l_int|1
suffix:semicolon
id|lcn
op_assign
id|rl
(braket
id|rlen
)braket
dot
id|lcn
op_plus
id|rl
(braket
id|rlen
)braket
dot
id|len
suffix:semicolon
id|io.fn_put
op_assign
id|ntfs_put
suffix:semicolon
id|io.fn_get
op_assign
id|ntfs_get
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): Starting bitmap search.&bslash;n&quot;
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): pass = %i, pass_start = %lu, &quot;
l_string|&quot;pass_end = %lu.&bslash;n&quot;
comma
id|pass
comma
id|pass_start
comma
id|pass_end
)paren
suffix:semicolon
id|byte
op_assign
l_int|NULL
suffix:semicolon
singleline_comment|// FIXME: For debugging only.
multiline_comment|/* Loop until a free mft record is found. */
id|io.size
op_assign
(paren
id|nr_mft_records
op_rshift
l_int|3
)paren
op_amp
op_complement
id|PAGE_MASK
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
id|io.size
op_assign
id|PAGE_SIZE
)paren
(brace
id|io.param
op_assign
id|buf
suffix:semicolon
id|io.do_read
op_assign
l_int|1
suffix:semicolon
id|last_read_pos
op_assign
id|buf_pos
op_rshift
l_int|3
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): Before: &quot;
l_string|&quot;bmp-&gt;allocated = 0x%Lx, bmp-&gt;size = 0x%Lx, &quot;
l_string|&quot;bmp-&gt;initialized = 0x%Lx.&bslash;n&quot;
comma
id|bmp-&gt;allocated
comma
id|bmp-&gt;size
comma
id|bmp-&gt;initialized
)paren
suffix:semicolon
id|err
op_assign
id|ntfs_readwrite_attr
c_func
(paren
id|vol-&gt;mft_ino
comma
id|bmp
comma
id|last_read_pos
comma
op_amp
id|io
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|err_ret
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): Read %lu bytes.&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|io.size
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): After: &quot;
l_string|&quot;bmp-&gt;allocated = 0x%Lx, bmp-&gt;size = 0x%Lx, &quot;
l_string|&quot;bmp-&gt;initialized = 0x%Lx.&bslash;n&quot;
comma
id|bmp-&gt;allocated
comma
id|bmp-&gt;size
comma
id|bmp-&gt;initialized
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|io.size
)paren
r_goto
id|pass_done
suffix:semicolon
id|buf_size
op_assign
id|io.size
op_lshift
l_int|3
suffix:semicolon
id|bit
op_assign
id|buf_pos
op_amp
l_int|7UL
suffix:semicolon
id|buf_pos
op_and_assign
op_complement
l_int|7UL
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): Before loop: &quot;
l_string|&quot;buf_size = %lu, buf_pos = %lu, bit = %lu, &quot;
l_string|&quot;*byte = 0x%x, b = %u.&bslash;n&quot;
comma
id|buf_size
comma
id|buf_pos
comma
id|bit
comma
id|byte
ques
c_cond
op_star
id|byte
suffix:colon
op_minus
l_int|1
comma
id|b
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|bit
OL
id|buf_size
op_logical_and
id|bit
op_plus
id|buf_pos
OL
id|pass_end
suffix:semicolon
id|bit
op_and_assign
op_complement
l_int|7UL
comma
id|bit
op_add_assign
l_int|8UL
)paren
(brace
id|byte
op_assign
id|buf
op_plus
(paren
id|bit
op_rshift
l_int|3
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|byte
op_eq
l_int|0xff
)paren
r_continue
suffix:semicolon
id|b
op_assign
id|ffz
c_func
(paren
(paren
r_int
r_int
)paren
op_star
id|byte
)paren
suffix:semicolon
r_if
c_cond
(paren
id|b
OL
(paren
id|__u8
)paren
l_int|8
op_logical_and
id|b
op_ge
(paren
id|bit
op_amp
l_int|7UL
)paren
)paren
(brace
id|bit
op_assign
id|b
op_plus
(paren
id|bit
op_amp
op_complement
l_int|7UL
)paren
op_plus
id|buf_pos
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): &quot;
l_string|&quot;Found free rec in for loop. &quot;
l_string|&quot;bit = %lu&bslash;n&quot;
comma
id|bit
)paren
suffix:semicolon
r_goto
id|found_free_rec
suffix:semicolon
)brace
)brace
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): After loop: &quot;
l_string|&quot;buf_size = %lu, buf_pos = %lu, bit = %lu, &quot;
l_string|&quot;*byte = 0x%x, b = %u.&bslash;n&quot;
comma
id|buf_size
comma
id|buf_pos
comma
id|bit
comma
id|byte
ques
c_cond
op_star
id|byte
suffix:colon
op_minus
l_int|1
comma
id|b
)paren
suffix:semicolon
id|buf_pos
op_add_assign
id|buf_size
suffix:semicolon
r_if
c_cond
(paren
id|buf_pos
OL
id|pass_end
)paren
r_continue
suffix:semicolon
id|pass_done
suffix:colon
multiline_comment|/* Finished with the current pass. */
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): At pass_done.&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pass
op_eq
l_int|1
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Now do pass 2, scanning the first part of the zone&n;&t;&t;&t; * we omitted in pass 1.&n;&t;&t;&t; */
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): Done pass &quot;
l_string|&quot;1.&bslash;n&quot;
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): Pass = 2.&bslash;n&quot;
)paren
suffix:semicolon
id|pass
op_assign
l_int|2
suffix:semicolon
id|pass_end
op_assign
id|pass_start
suffix:semicolon
id|buf_pos
op_assign
id|pass_start
op_assign
l_int|24UL
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): pass = %i, &quot;
l_string|&quot;pass_start = %lu, pass_end = %lu.&bslash;n&quot;
comma
id|pass
comma
id|pass_start
comma
id|pass_end
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* pass == 2 */
multiline_comment|/* No free records left. */
r_if
c_cond
(paren
id|bmp-&gt;initialized
op_lshift
l_int|3
OG
id|nr_mft_records
op_logical_and
id|bmp-&gt;initialized
OG
l_int|3
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * The mft bitmap is already bigger but the space is&n;&t;&t;&t; * not covered by mft records, this implies that the&n;&t;&t;&t; * next records are all free, so we already have found&n;&t;&t;&t; * a free record.&n;&t;&t;&t; */
id|bit
op_assign
id|nr_mft_records
suffix:semicolon
r_if
c_cond
(paren
id|bit
OL
l_int|24UL
)paren
id|bit
op_assign
l_int|24UL
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): Found free &quot;
l_string|&quot;record bit (#1) = 0x%lx.&bslash;n&quot;
comma
id|bit
)paren
suffix:semicolon
r_goto
id|found_free_rec
suffix:semicolon
)brace
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): Done pass 2.&bslash;n&quot;
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): Before: &quot;
l_string|&quot;bmp-&gt;allocated = 0x%Lx, bmp-&gt;size = 0x%Lx, &quot;
l_string|&quot;bmp-&gt;initialized = 0x%Lx.&bslash;n&quot;
comma
id|bmp-&gt;allocated
comma
id|bmp-&gt;size
comma
id|bmp-&gt;initialized
)paren
suffix:semicolon
multiline_comment|/* Need to extend the mft bitmap. */
r_if
c_cond
(paren
id|bmp-&gt;initialized
op_plus
l_int|8LL
OG
id|bmp-&gt;allocated
)paren
(brace
id|ntfs_io
id|io2
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): Initialized &quot;
l_string|&quot;&gt; allocated.&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Need to extend bitmap by one more cluster. */
id|rl
op_assign
id|bmp-&gt;d.r.runlist
suffix:semicolon
id|rlen
op_assign
id|bmp-&gt;d.r.len
op_minus
l_int|1
suffix:semicolon
id|lcn
op_assign
id|rl
(braket
id|rlen
)braket
dot
id|lcn
op_plus
id|rl
(braket
id|rlen
)braket
dot
id|len
suffix:semicolon
id|io2.fn_put
op_assign
id|ntfs_put
suffix:semicolon
id|io2.fn_get
op_assign
id|ntfs_get
suffix:semicolon
id|io2.param
op_assign
op_amp
id|b
suffix:semicolon
id|io2.size
op_assign
l_int|1
suffix:semicolon
id|io2.do_read
op_assign
l_int|1
suffix:semicolon
id|err
op_assign
id|ntfs_readwrite_attr
c_func
(paren
id|vol-&gt;bitmap
comma
id|data
comma
id|lcn
op_rshift
l_int|3
comma
op_amp
id|io2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|err_ret
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): Read %lu &quot;
l_string|&quot;bytes.&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|io2.size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|io2.size
op_eq
l_int|1
op_logical_and
id|b
op_ne
l_int|0xff
)paren
(brace
id|__u8
id|tb
op_assign
l_int|1
op_lshift
(paren
id|lcn
op_amp
(paren
id|ntfs_cluster_t
)paren
l_int|7
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|b
op_amp
id|tb
)paren
)paren
(brace
multiline_comment|/* Next cluster is free. Allocate it. */
id|b
op_or_assign
id|tb
suffix:semicolon
id|io2.param
op_assign
op_amp
id|b
suffix:semicolon
id|io2.do_read
op_assign
l_int|0
suffix:semicolon
id|err
op_assign
id|ntfs_readwrite_attr
c_func
(paren
id|vol-&gt;bitmap
comma
id|data
comma
id|lcn
op_rshift
l_int|3
comma
op_amp
id|io2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_logical_or
id|io.size
op_ne
l_int|1
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|err
)paren
id|err
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|err_ret
suffix:semicolon
)brace
id|append_mftbmp_simple
suffix:colon
id|rl
(braket
id|rlen
)braket
dot
id|len
op_increment
suffix:semicolon
id|have_allocated_mftbmp
op_or_assign
l_int|1
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): Appending one &quot;
l_string|&quot;cluster to mftbmp.&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|have_allocated_mftbmp
)paren
(brace
multiline_comment|/* Allocate a cluster from the DATA_ZONE. */
id|ntfs_cluster_t
id|lcn2
op_assign
id|lcn
suffix:semicolon
id|ntfs_cluster_t
id|count
op_assign
l_int|1
suffix:semicolon
id|err
op_assign
id|ntfs_allocate_clusters
c_func
(paren
id|vol
comma
op_amp
id|lcn2
comma
op_amp
id|count
comma
op_amp
id|rl2
comma
op_amp
id|r2len
comma
id|DATA_ZONE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|err_ret
suffix:semicolon
r_if
c_cond
(paren
id|count
op_ne
l_int|1
op_logical_or
id|lcn2
op_le
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|count
OG
l_int|0
)paren
(brace
id|rl2_dealloc_err_out
suffix:colon
r_if
c_cond
(paren
id|ntfs_deallocate_clusters
c_func
(paren
id|vol
comma
id|rl2
comma
id|r2len
)paren
)paren
id|ntfs_error
c_func
(paren
id|__FUNCTION__
l_string|&quot;(): Cluster &quot;
l_string|&quot;deallocation in error &quot;
l_string|&quot;code path failed! You &quot;
l_string|&quot;should run chkdsk.&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|ntfs_vfree
c_func
(paren
id|rl2
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|err
)paren
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|err_ret
suffix:semicolon
)brace
r_if
c_cond
(paren
id|lcn2
op_eq
id|lcn
)paren
(brace
id|ntfs_vfree
c_func
(paren
id|rl2
)paren
suffix:semicolon
r_goto
id|append_mftbmp_simple
suffix:semicolon
)brace
multiline_comment|/* We need to append a new run. */
id|rl_size
op_assign
(paren
id|rlen
op_star
r_sizeof
(paren
id|ntfs_runlist
)paren
op_plus
id|PAGE_SIZE
op_minus
l_int|1
)paren
op_amp
id|PAGE_MASK
suffix:semicolon
multiline_comment|/* Reallocate memory if necessary. */
r_if
c_cond
(paren
(paren
id|rlen
op_plus
l_int|2
)paren
op_star
r_sizeof
(paren
id|ntfs_runlist
)paren
op_ge
id|rl_size
)paren
(brace
id|ntfs_runlist
op_star
id|rlt
suffix:semicolon
id|rl_size
op_add_assign
id|PAGE_SIZE
suffix:semicolon
id|rlt
op_assign
id|ntfs_vmalloc
c_func
(paren
id|rl_size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rlt
)paren
(brace
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|rl2_dealloc_err_out
suffix:semicolon
)brace
id|ntfs_memcpy
c_func
(paren
id|rlt
comma
id|rl
comma
id|rl_size
op_minus
id|PAGE_SIZE
)paren
suffix:semicolon
id|ntfs_vfree
c_func
(paren
id|rl
)paren
suffix:semicolon
id|bmp-&gt;d.r.runlist
op_assign
id|rl
op_assign
id|rlt
suffix:semicolon
)brace
id|ntfs_vfree
c_func
(paren
id|rl2
)paren
suffix:semicolon
id|rl
(braket
id|rlen
)braket
dot
id|lcn
op_assign
id|lcn
op_assign
id|lcn2
suffix:semicolon
id|rl
(braket
id|rlen
)braket
dot
id|len
op_assign
id|count
suffix:semicolon
id|bmp-&gt;d.r.len
op_assign
op_increment
id|rlen
suffix:semicolon
id|have_allocated_mftbmp
op_or_assign
l_int|2
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): &quot;
l_string|&quot;Adding run to mftbmp. &quot;
l_string|&quot;LCN = %i, len = %i&bslash;n&quot;
comma
id|lcn
comma
id|count
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * We now have extended the mft bitmap allocated size&n;&t;&t;&t; * by one cluster. Reflect this in the attribute.&n;&t;&t;&t; */
id|bmp-&gt;allocated
op_add_assign
(paren
id|__s64
)paren
id|vol-&gt;cluster_size
suffix:semicolon
)brace
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): After: &quot;
l_string|&quot;bmp-&gt;allocated = 0x%Lx, bmp-&gt;size = 0x%Lx, &quot;
l_string|&quot;bmp-&gt;initialized = 0x%Lx.&bslash;n&quot;
comma
id|bmp-&gt;allocated
comma
id|bmp-&gt;size
comma
id|bmp-&gt;initialized
)paren
suffix:semicolon
multiline_comment|/* We now have sufficient allocated space. */
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): Now have sufficient &quot;
l_string|&quot;allocated space in mftbmp.&bslash;n&quot;
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): Before: &quot;
l_string|&quot;bmp-&gt;allocated = 0x%Lx, bmp-&gt;size = 0x%Lx, &quot;
l_string|&quot;bmp-&gt;initialized = 0x%Lx.&bslash;n&quot;
comma
id|bmp-&gt;allocated
comma
id|bmp-&gt;size
comma
id|bmp-&gt;initialized
)paren
suffix:semicolon
id|buf_pos
op_assign
id|bmp-&gt;initialized
suffix:semicolon
id|bmp-&gt;initialized
op_add_assign
l_int|8LL
suffix:semicolon
r_if
c_cond
(paren
id|bmp-&gt;initialized
OG
id|bmp-&gt;size
)paren
id|bmp-&gt;size
op_assign
id|bmp-&gt;initialized
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): After: &quot;
l_string|&quot;bmp-&gt;allocated = 0x%Lx, bmp-&gt;size = 0x%Lx, &quot;
l_string|&quot;bmp-&gt;initialized = 0x%Lx.&bslash;n&quot;
comma
id|bmp-&gt;allocated
comma
id|bmp-&gt;size
comma
id|bmp-&gt;initialized
)paren
suffix:semicolon
id|have_allocated_mftbmp
op_or_assign
l_int|4
suffix:semicolon
multiline_comment|/* Update the mft bitmap attribute value. */
id|memset
c_func
(paren
id|buf
comma
l_int|0
comma
l_int|8
)paren
suffix:semicolon
id|io.param
op_assign
id|buf
suffix:semicolon
id|io.size
op_assign
l_int|8
suffix:semicolon
id|io.do_read
op_assign
l_int|0
suffix:semicolon
id|err
op_assign
id|ntfs_readwrite_attr
c_func
(paren
id|vol-&gt;mft_ino
comma
id|bmp
comma
id|buf_pos
comma
op_amp
id|io
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_logical_or
id|io.size
op_ne
l_int|8
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|err
)paren
id|err
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|shrink_mftbmp_err_ret
suffix:semicolon
)brace
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): Wrote extended &quot;
l_string|&quot;mftbmp bytes %lu.&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|io.size
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): After write: &quot;
l_string|&quot;bmp-&gt;allocated = 0x%Lx, bmp-&gt;size = 0x%Lx, &quot;
l_string|&quot;bmp-&gt;initialized = 0x%Lx.&bslash;n&quot;
comma
id|bmp-&gt;allocated
comma
id|bmp-&gt;size
comma
id|bmp-&gt;initialized
)paren
suffix:semicolon
id|bit
op_assign
id|buf_pos
op_lshift
l_int|3
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): Found free record &quot;
l_string|&quot;bit (#2) = 0x%lx.&bslash;n&quot;
comma
id|bit
)paren
suffix:semicolon
r_goto
id|found_free_rec
suffix:semicolon
)brace
id|found_free_rec
suffix:colon
multiline_comment|/* bit is the found free mft record. Allocate it in the mft bitmap. */
id|vol-&gt;mft_data_pos
op_assign
id|bit
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): At found_free_rec.&bslash;n&quot;
)paren
suffix:semicolon
id|io.param
op_assign
id|buf
suffix:semicolon
id|io.size
op_assign
l_int|1
suffix:semicolon
id|io.do_read
op_assign
l_int|1
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): Before update: &quot;
l_string|&quot;bmp-&gt;allocated = 0x%Lx, bmp-&gt;size = 0x%Lx, &quot;
l_string|&quot;bmp-&gt;initialized = 0x%Lx.&bslash;n&quot;
comma
id|bmp-&gt;allocated
comma
id|bmp-&gt;size
comma
id|bmp-&gt;initialized
)paren
suffix:semicolon
id|err
op_assign
id|ntfs_readwrite_attr
c_func
(paren
id|vol-&gt;mft_ino
comma
id|bmp
comma
id|bit
op_rshift
l_int|3
comma
op_amp
id|io
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_logical_or
id|io.size
op_ne
l_int|1
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|err
)paren
id|err
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|shrink_mftbmp_err_ret
suffix:semicolon
)brace
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): Read %lu bytes.&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|io.size
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
multiline_comment|/* Check our bit is really zero! */
r_if
c_cond
(paren
op_star
id|buf
op_amp
(paren
l_int|1
op_lshift
(paren
id|bit
op_amp
l_int|7
)paren
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
op_star
id|buf
op_or_assign
l_int|1
op_lshift
(paren
id|bit
op_amp
l_int|7
)paren
suffix:semicolon
id|io.param
op_assign
id|buf
suffix:semicolon
id|io.do_read
op_assign
l_int|0
suffix:semicolon
id|err
op_assign
id|ntfs_readwrite_attr
c_func
(paren
id|vol-&gt;mft_ino
comma
id|bmp
comma
id|bit
op_rshift
l_int|3
comma
op_amp
id|io
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_logical_or
id|io.size
op_ne
l_int|1
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|err
)paren
id|err
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|shrink_mftbmp_err_ret
suffix:semicolon
)brace
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): Wrote %lu bytes.&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|io.size
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): After update: &quot;
l_string|&quot;bmp-&gt;allocated = 0x%Lx, bmp-&gt;size = 0x%Lx, &quot;
l_string|&quot;bmp-&gt;initialized = 0x%Lx.&bslash;n&quot;
comma
id|bmp-&gt;allocated
comma
id|bmp-&gt;size
comma
id|bmp-&gt;initialized
)paren
suffix:semicolon
multiline_comment|/* The mft bitmap is now uptodate. Deal with mft data attribute now. */
id|ll
op_assign
(paren
id|__s64
)paren
(paren
id|bit
op_plus
l_int|1
)paren
op_lshift
id|vol-&gt;mft_record_size_bits
suffix:semicolon
r_if
c_cond
(paren
id|ll
op_le
id|data-&gt;initialized
)paren
(brace
multiline_comment|/* The allocated record is already initialized. We are done! */
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): Allocated mft record &quot;
l_string|&quot;already initialized!&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|done_ret
suffix:semicolon
)brace
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): Allocated mft record needs &quot;
l_string|&quot;to be initialized.&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* The mft record is outside the initialized data. */
id|mft_rec_size
op_assign
(paren
r_int
r_int
)paren
id|vol-&gt;mft_record_size
suffix:semicolon
multiline_comment|/* Preserve old values for undo purposes. */
id|old_data_allocated
op_assign
id|data-&gt;allocated
suffix:semicolon
id|old_data_rlen
op_assign
id|data-&gt;d.r.len
op_minus
l_int|1
suffix:semicolon
id|old_data_len
op_assign
id|data-&gt;d.r.runlist
(braket
id|old_data_rlen
)braket
dot
id|len
suffix:semicolon
multiline_comment|/*&n;&t; * If necessary, extend the mft until it covers the allocated record.&n;&t; * The loop is only actually used when a freshly formatted volume is&n;&t; * first written to. But it optimizes away nicely in the common case.&n;&t; */
r_while
c_loop
(paren
id|ll
OG
id|data-&gt;allocated
)paren
(brace
id|ntfs_cluster_t
id|lcn2
comma
id|nr_lcn2
comma
id|nr
comma
id|min_nr
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): Extending mft &quot;
l_string|&quot;data allocation, data-&gt;allocated = 0x%Lx, &quot;
l_string|&quot;data-&gt;size = 0x%Lx, data-&gt;initialized = &quot;
l_string|&quot;0x%Lx.&bslash;n&quot;
comma
id|data-&gt;allocated
comma
id|data-&gt;size
comma
id|data-&gt;initialized
)paren
suffix:semicolon
multiline_comment|/* Minimum allocation is one mft record worth of clusters. */
r_if
c_cond
(paren
id|mft_rec_size
op_le
id|vol-&gt;cluster_size
)paren
id|min_nr
op_assign
(paren
id|ntfs_cluster_t
)paren
l_int|1
suffix:semicolon
r_else
id|min_nr
op_assign
id|mft_rec_size
op_rshift
id|vol-&gt;cluster_size_bits
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): min_nr = %i.&bslash;n&quot;
comma
id|min_nr
)paren
suffix:semicolon
multiline_comment|/* Allocate 16 mft records worth of clusters. */
id|nr
op_assign
id|mft_rec_size
op_lshift
l_int|4
op_rshift
id|vol-&gt;cluster_size_bits
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|nr
)paren
id|nr
op_assign
(paren
id|ntfs_cluster_t
)paren
l_int|1
suffix:semicolon
multiline_comment|/* Determine the preferred allocation location. */
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): nr = %i.&bslash;n&quot;
comma
id|nr
)paren
suffix:semicolon
id|rl2
op_assign
id|data-&gt;d.r.runlist
suffix:semicolon
id|r2len
op_assign
id|data-&gt;d.r.len
suffix:semicolon
id|lcn2
op_assign
id|rl2
(braket
id|r2len
op_minus
l_int|1
)braket
dot
id|lcn
op_plus
id|rl2
(braket
id|r2len
op_minus
l_int|1
)braket
dot
id|len
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): rl2[r2len - 1].lcn &quot;
l_string|&quot;= %i, .len = %i.&bslash;n&quot;
comma
id|rl2
(braket
id|r2len
op_minus
l_int|1
)braket
dot
id|lcn
comma
id|rl2
(braket
id|r2len
op_minus
l_int|1
)braket
dot
id|len
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): lcn2 = %i, r2len = &quot;
l_string|&quot;%i.&bslash;n&quot;
comma
id|lcn2
comma
id|r2len
)paren
suffix:semicolon
id|retry_mft_data_allocation
suffix:colon
id|nr_lcn2
op_assign
id|nr
suffix:semicolon
id|err
op_assign
id|ntfs_allocate_clusters
c_func
(paren
id|vol
comma
op_amp
id|lcn2
comma
op_amp
id|nr_lcn2
comma
op_amp
id|rl2
comma
op_amp
id|r2len
comma
id|MFT_ZONE
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
op_logical_neg
id|err
op_logical_and
id|nr_lcn2
OL
id|min_nr
)paren
multiline_comment|/* Allocated less than minimum needed. Weird! */
id|BUG
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|err
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * If there isn&squot;t enough space to do the wanted&n;&t;&t;&t; * allocation, but there is enough space to do a&n;&t;&t;&t; * minimal allocation, then try that, unless the wanted&n;&t;&t;&t; * allocation was already the minimal allocation.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|err
op_eq
op_minus
id|ENOSPC
op_logical_and
id|nr
OG
id|min_nr
op_logical_and
id|nr_lcn2
op_ge
id|min_nr
)paren
(brace
id|nr
op_assign
id|min_nr
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): &quot;
l_string|&quot;Retrying mft data &quot;
l_string|&quot;allocation, nr = min_nr = %i&quot;
l_string|&quot;.&bslash;n&quot;
comma
id|nr
)paren
suffix:semicolon
r_goto
id|retry_mft_data_allocation
suffix:semicolon
)brace
r_goto
id|undo_mftbmp_alloc_err_ret
suffix:semicolon
)brace
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): Allocated %i &quot;
l_string|&quot;clusters starting at LCN %i.&bslash;n&quot;
comma
id|nr_lcn2
comma
id|lcn2
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): Allocated &quot;
l_string|&quot;runlist:&bslash;n&quot;
)paren
suffix:semicolon
id|dump_runlist
c_func
(paren
id|rl2
comma
id|r2len
)paren
suffix:semicolon
multiline_comment|/* Append rl2 to the mft data attribute&squot;s run list. */
id|err
op_assign
id|splice_runlists
c_func
(paren
op_amp
id|data-&gt;d.r.runlist
comma
(paren
r_int
op_star
)paren
op_amp
id|data-&gt;d.r.len
comma
id|rl2
comma
id|r2len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): &quot;
l_string|&quot;splice_runlists failed with error &quot;
l_string|&quot;code %i.&bslash;n&quot;
comma
op_minus
id|err
)paren
suffix:semicolon
r_goto
id|undo_partial_data_alloc_err_ret
suffix:semicolon
)brace
multiline_comment|/* Reflect the allocated clusters in the mft allocated data. */
id|data-&gt;allocated
op_add_assign
id|nr_lcn2
op_lshift
id|vol-&gt;cluster_size_bits
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): After extending mft &quot;
l_string|&quot;data allocation, data-&gt;allocated = 0x%Lx, &quot;
l_string|&quot;data-&gt;size = 0x%Lx, data-&gt;initialized = &quot;
l_string|&quot;0x%Lx.&bslash;n&quot;
comma
id|data-&gt;allocated
comma
id|data-&gt;size
comma
id|data-&gt;initialized
)paren
suffix:semicolon
)brace
multiline_comment|/* Prepare a formatted (empty) mft record. */
id|memset
c_func
(paren
id|buf
comma
l_int|0
comma
id|mft_rec_size
)paren
suffix:semicolon
id|ntfs_fill_mft_header
c_func
(paren
id|buf
comma
id|mft_rec_size
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|err
op_assign
id|ntfs_insert_fixups
c_func
(paren
id|buf
comma
id|mft_rec_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|undo_data_alloc_err_ret
suffix:semicolon
multiline_comment|/*&n;&t; * Extend mft data initialized size to reach the allocated mft record&n;&t; * and write the formatted mft record buffer to each mft record being&n;&t; * initialized. Note, that ntfs_readwrite_attr extends both&n;&t; * data-&gt;initialized and data-&gt;size, so no need for us to touch them.&n;&t; */
id|old_data_initialized
op_assign
id|data-&gt;initialized
suffix:semicolon
id|old_data_size
op_assign
id|data-&gt;size
suffix:semicolon
r_while
c_loop
(paren
id|ll
OG
id|data-&gt;initialized
)paren
(brace
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): Initializing mft &quot;
l_string|&quot;record 0x%Lx.&bslash;n&quot;
comma
id|data-&gt;initialized
op_rshift
id|vol-&gt;mft_record_size_bits
)paren
suffix:semicolon
id|io.param
op_assign
id|buf
suffix:semicolon
id|io.size
op_assign
id|mft_rec_size
suffix:semicolon
id|io.do_read
op_assign
l_int|0
suffix:semicolon
id|err
op_assign
id|ntfs_readwrite_attr
c_func
(paren
id|vol-&gt;mft_ino
comma
id|data
comma
id|data-&gt;initialized
comma
op_amp
id|io
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_logical_or
id|io.size
op_ne
id|mft_rec_size
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|err
)paren
id|err
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|undo_data_init_err_ret
suffix:semicolon
)brace
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): Wrote %i bytes to &quot;
l_string|&quot;mft data.&bslash;n&quot;
comma
id|io.size
)paren
suffix:semicolon
)brace
multiline_comment|/* Update the VFS inode size as well. */
id|VFS_I
c_func
(paren
id|vol-&gt;mft_ino
)paren
op_member_access_from_pointer
id|i_size
op_assign
id|data-&gt;size
suffix:semicolon
macro_line|#ifdef DEBUG
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): After mft record &quot;
l_string|&quot;initialization: data-&gt;allocated = 0x%Lx, data-&gt;size &quot;
l_string|&quot;= 0x%Lx, data-&gt;initialized = 0x%Lx.&bslash;n&quot;
comma
id|data-&gt;allocated
comma
id|data-&gt;size
comma
id|data-&gt;initialized
)paren
suffix:semicolon
multiline_comment|/* Sanity checks. */
r_if
c_cond
(paren
id|data-&gt;size
OG
id|data-&gt;allocated
op_logical_or
id|data-&gt;size
template_param
id|data-&gt;allocated
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
id|done_ret
suffix:colon
multiline_comment|/* Return the number of the allocated mft record. */
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): At done_ret. *result = bit = &quot;
l_string|&quot;0x%lx.&bslash;n&quot;
comma
id|bit
)paren
suffix:semicolon
op_star
id|result
op_assign
id|bit
suffix:semicolon
id|vol-&gt;mft_data_pos
op_assign
id|bit
op_plus
l_int|1
suffix:semicolon
id|err_ret
suffix:colon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
id|free_page
c_func
(paren
(paren
r_int
r_int
)paren
id|buf
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): Syncing inode $MFT.&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ntfs_update_inode
c_func
(paren
id|vol-&gt;mft_ino
)paren
)paren
id|ntfs_error
c_func
(paren
id|__FUNCTION__
l_string|&quot;(): Failed to sync inode $MFT. &quot;
l_string|&quot;Continuing anyway.&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|err
)paren
(brace
id|ntfs_debug
c_func
(paren
id|DEBUG_FILE3
comma
id|__FUNCTION__
l_string|&quot;(): Done. Allocated mft &quot;
l_string|&quot;record number *result = 0x%lx.&bslash;n&quot;
comma
op_star
id|result
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|err
op_ne
op_minus
id|ENOSPC
)paren
id|ntfs_error
c_func
(paren
id|__FUNCTION__
l_string|&quot;(): Failed to allocate an mft &quot;
l_string|&quot;record. Returning error code %i.&bslash;n&quot;
comma
op_minus
id|err
)paren
suffix:semicolon
r_else
id|ntfs_debug
c_func
(paren
id|DEBUG_FILE3
comma
id|__FUNCTION__
l_string|&quot;(): Failed to allocate &quot;
l_string|&quot;an mft record due to lack of free space.&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
id|undo_data_init_err_ret
suffix:colon
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): At &quot;
l_string|&quot;undo_data_init_err_ret.&bslash;n&quot;
)paren
suffix:semicolon
id|data-&gt;initialized
op_assign
id|old_data_initialized
suffix:semicolon
id|data-&gt;size
op_assign
id|old_data_size
suffix:semicolon
id|undo_data_alloc_err_ret
suffix:colon
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): At undo_data_alloc_err_ret.&quot;
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|data-&gt;allocated
op_assign
id|old_data_allocated
suffix:semicolon
id|undo_partial_data_alloc_err_ret
suffix:colon
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): At &quot;
l_string|&quot;undo_partial_data_alloc_err_ret.&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Deallocate the clusters. */
r_if
c_cond
(paren
id|ntfs_deallocate_clusters
c_func
(paren
id|vol
comma
id|rl2
comma
id|r2len
)paren
)paren
id|ntfs_error
c_func
(paren
id|__FUNCTION__
l_string|&quot;(): Error deallocating clusters in &quot;
l_string|&quot;error code path. You should run chkdsk.&bslash;n&quot;
)paren
suffix:semicolon
id|ntfs_vfree
c_func
(paren
id|rl2
)paren
suffix:semicolon
multiline_comment|/* Revert the run list back to what it was before. */
id|r2len
op_assign
id|data-&gt;d.r.len
suffix:semicolon
id|rl2
op_assign
id|data-&gt;d.r.runlist
suffix:semicolon
id|rl2
(braket
id|old_data_rlen
op_increment
)braket
dot
id|len
op_assign
id|old_data_len
suffix:semicolon
id|rl2
(braket
id|old_data_rlen
)braket
dot
id|lcn
op_assign
(paren
id|ntfs_cluster_t
)paren
op_minus
l_int|1
suffix:semicolon
id|rl2
(braket
id|old_data_rlen
)braket
dot
id|len
op_assign
(paren
id|ntfs_cluster_t
)paren
l_int|0
suffix:semicolon
id|data-&gt;d.r.len
op_assign
id|old_data_rlen
suffix:semicolon
id|rl2_size
op_assign
(paren
(paren
id|old_data_rlen
op_plus
l_int|1
)paren
op_star
r_sizeof
(paren
id|ntfs_runlist
)paren
op_plus
id|PAGE_SIZE
op_minus
l_int|1
)paren
op_amp
id|PAGE_MASK
suffix:semicolon
multiline_comment|/* Reallocate memory freeing any extra memory allocated. */
r_if
c_cond
(paren
id|rl2_size
OL
(paren
(paren
id|r2len
op_star
r_sizeof
(paren
id|ntfs_runlist
)paren
op_plus
id|PAGE_SIZE
op_minus
l_int|1
)paren
op_amp
id|PAGE_MASK
)paren
)paren
(brace
id|rl2
op_assign
id|ntfs_vmalloc
c_func
(paren
id|rl2_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rl2
)paren
(brace
id|ntfs_memcpy
c_func
(paren
id|rl2
comma
id|data-&gt;d.r.runlist
comma
id|rl2_size
)paren
suffix:semicolon
id|ntfs_vfree
c_func
(paren
id|data-&gt;d.r.runlist
)paren
suffix:semicolon
id|data-&gt;d.r.runlist
op_assign
id|rl2
suffix:semicolon
)brace
r_else
id|ntfs_error
c_func
(paren
id|__FUNCTION__
l_string|&quot;(): Error reallocating &quot;
l_string|&quot;memory in error code path. This &quot;
l_string|&quot;should be harmless.&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|undo_mftbmp_alloc_err_ret
suffix:colon
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): At &quot;
l_string|&quot;undo_mftbmp_alloc_err_ret.&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Deallocate the allocated bit in the mft bitmap. */
id|io.param
op_assign
id|buf
suffix:semicolon
id|io.size
op_assign
l_int|1
suffix:semicolon
id|io.do_read
op_assign
l_int|1
suffix:semicolon
id|err
op_assign
id|ntfs_readwrite_attr
c_func
(paren
id|vol-&gt;mft_ino
comma
id|bmp
comma
id|bit
op_rshift
l_int|3
comma
op_amp
id|io
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|err
op_logical_and
id|io.size
op_eq
l_int|1
)paren
(brace
op_star
id|buf
op_and_assign
op_complement
(paren
l_int|1
op_lshift
(paren
id|bit
op_amp
l_int|7
)paren
)paren
suffix:semicolon
id|io.param
op_assign
id|buf
suffix:semicolon
id|io.do_read
op_assign
l_int|0
suffix:semicolon
id|err
op_assign
id|ntfs_readwrite_attr
c_func
(paren
id|vol-&gt;mft_ino
comma
id|bmp
comma
id|bit
op_rshift
l_int|3
comma
op_amp
id|io
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|err
op_logical_or
id|io.size
op_ne
l_int|1
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|err
)paren
id|err
op_assign
op_minus
id|EIO
suffix:semicolon
id|ntfs_error
c_func
(paren
id|__FUNCTION__
l_string|&quot;(): Error deallocating mft record in &quot;
l_string|&quot;error code path. You should run chkdsk.&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|shrink_mftbmp_err_ret
suffix:colon
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): At shrink_mftbmp_err_ret.&bslash;n&quot;
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): have_allocated_mftbmp = &quot;
l_string|&quot;%i.&bslash;n&quot;
comma
id|have_allocated_mftbmp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|have_allocated_mftbmp
)paren
r_goto
id|err_ret
suffix:semicolon
multiline_comment|/* Shrink the mftbmp back to previous size. */
r_if
c_cond
(paren
id|bmp-&gt;size
op_eq
id|bmp-&gt;initialized
)paren
id|bmp-&gt;size
op_sub_assign
l_int|8LL
suffix:semicolon
id|bmp-&gt;initialized
op_sub_assign
l_int|8LL
suffix:semicolon
id|have_allocated_mftbmp
op_and_assign
op_complement
l_int|4
suffix:semicolon
multiline_comment|/* If no allocation occured then we are done. */
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): have_allocated_mftbmp = &quot;
l_string|&quot;%i.&bslash;n&quot;
comma
id|have_allocated_mftbmp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|have_allocated_mftbmp
)paren
r_goto
id|err_ret
suffix:semicolon
multiline_comment|/* Deallocate the allocated cluster. */
id|bmp-&gt;allocated
op_sub_assign
(paren
id|__s64
)paren
id|vol-&gt;cluster_size
suffix:semicolon
r_if
c_cond
(paren
id|ntfs_deallocate_cluster_run
c_func
(paren
id|vol
comma
id|lcn
comma
(paren
id|ntfs_cluster_t
)paren
l_int|1
)paren
)paren
id|ntfs_error
c_func
(paren
id|__FUNCTION__
l_string|&quot;(): Error deallocating cluster in &quot;
l_string|&quot;error code path. You should run chkdsk.&bslash;n&quot;
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|have_allocated_mftbmp
op_amp
l_int|3
)paren
(brace
r_case
l_int|1
suffix:colon
multiline_comment|/* Delete the last lcn from the last run of mftbmp. */
id|rl
(braket
id|rlen
op_minus
l_int|1
)braket
dot
id|len
op_decrement
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
multiline_comment|/* Delete the last run of mftbmp. */
id|bmp-&gt;d.r.len
op_assign
op_decrement
id|rlen
suffix:semicolon
multiline_comment|/* Reallocate memory if necessary. */
r_if
c_cond
(paren
(paren
id|rlen
op_plus
l_int|1
)paren
op_star
r_sizeof
(paren
id|ntfs_runlist
)paren
op_le
id|rl_size
op_minus
id|PAGE_SIZE
)paren
(brace
id|ntfs_runlist
op_star
id|rlt
suffix:semicolon
id|rl_size
op_sub_assign
id|PAGE_SIZE
suffix:semicolon
id|rlt
op_assign
id|ntfs_vmalloc
c_func
(paren
id|rl_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rlt
)paren
(brace
id|ntfs_memcpy
c_func
(paren
id|rlt
comma
id|rl
comma
id|rl_size
)paren
suffix:semicolon
id|ntfs_vfree
c_func
(paren
id|rl
)paren
suffix:semicolon
id|bmp-&gt;d.r.runlist
op_assign
id|rl
op_assign
id|rlt
suffix:semicolon
)brace
r_else
id|ntfs_error
c_func
(paren
id|__FUNCTION__
l_string|&quot;(): Error &quot;
l_string|&quot;reallocating memory in error &quot;
l_string|&quot;code path. This should be &quot;
l_string|&quot;harmless.&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|bmp-&gt;d.r.runlist
(braket
id|bmp-&gt;d.r.len
)braket
dot
id|lcn
op_assign
(paren
id|ntfs_cluster_t
)paren
op_minus
l_int|1
suffix:semicolon
id|bmp-&gt;d.r.runlist
(braket
id|bmp-&gt;d.r.len
)braket
dot
id|len
op_assign
(paren
id|ntfs_cluster_t
)paren
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
r_goto
id|err_ret
suffix:semicolon
)brace
multiline_comment|/* We need 0x48 bytes in total. */
DECL|function|add_standard_information
r_static
r_int
id|add_standard_information
c_func
(paren
id|ntfs_inode
op_star
id|ino
)paren
(brace
id|ntfs_time64_t
id|now
suffix:semicolon
r_char
id|data
(braket
l_int|0x30
)braket
suffix:semicolon
r_char
op_star
id|position
op_assign
id|data
suffix:semicolon
id|ntfs_attribute
op_star
id|si
suffix:semicolon
id|now
op_assign
id|ntfs_now
c_func
(paren
)paren
suffix:semicolon
id|NTFS_PUTU64
c_func
(paren
id|position
op_plus
l_int|0x00
comma
id|now
)paren
suffix:semicolon
multiline_comment|/* File creation */
id|NTFS_PUTU64
c_func
(paren
id|position
op_plus
l_int|0x08
comma
id|now
)paren
suffix:semicolon
multiline_comment|/* Last modification */
id|NTFS_PUTU64
c_func
(paren
id|position
op_plus
l_int|0x10
comma
id|now
)paren
suffix:semicolon
multiline_comment|/* Last mod for MFT */
id|NTFS_PUTU64
c_func
(paren
id|position
op_plus
l_int|0x18
comma
id|now
)paren
suffix:semicolon
multiline_comment|/* Last access */
id|NTFS_PUTU64
c_func
(paren
id|position
op_plus
l_int|0x20
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* MSDOS file perms */
id|NTFS_PUTU64
c_func
(paren
id|position
op_plus
l_int|0x28
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* unknown */
r_return
id|ntfs_create_attr
c_func
(paren
id|ino
comma
id|ino-&gt;vol-&gt;at_standard_information
comma
l_int|0
comma
id|data
comma
r_sizeof
(paren
id|data
)paren
comma
op_amp
id|si
)paren
suffix:semicolon
)brace
DECL|function|add_filename
r_static
r_int
id|add_filename
c_func
(paren
id|ntfs_inode
op_star
id|ino
comma
id|ntfs_inode
op_star
id|dir
comma
r_const
r_int
r_char
op_star
id|filename
comma
r_int
id|length
comma
id|ntfs_u32
id|flags
)paren
(brace
r_int
r_char
op_star
id|position
suffix:semicolon
r_int
r_int
id|size
suffix:semicolon
id|ntfs_time64_t
id|now
suffix:semicolon
r_int
id|count
comma
id|error
suffix:semicolon
r_int
r_char
op_star
id|data
suffix:semicolon
id|ntfs_attribute
op_star
id|fn
suffix:semicolon
multiline_comment|/* Work out the size. */
id|size
op_assign
l_int|0x42
op_plus
l_int|2
op_star
id|length
suffix:semicolon
id|data
op_assign
id|ntfs_malloc
c_func
(paren
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|data
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
multiline_comment|/* Search for a position. */
id|position
op_assign
id|data
suffix:semicolon
id|NTFS_PUTINUM
c_func
(paren
id|position
comma
id|dir
)paren
suffix:semicolon
multiline_comment|/* Inode num of dir */
id|now
op_assign
id|ntfs_now
c_func
(paren
)paren
suffix:semicolon
id|NTFS_PUTU64
c_func
(paren
id|position
op_plus
l_int|0x08
comma
id|now
)paren
suffix:semicolon
multiline_comment|/* File creation */
id|NTFS_PUTU64
c_func
(paren
id|position
op_plus
l_int|0x10
comma
id|now
)paren
suffix:semicolon
multiline_comment|/* Last modification */
id|NTFS_PUTU64
c_func
(paren
id|position
op_plus
l_int|0x18
comma
id|now
)paren
suffix:semicolon
multiline_comment|/* Last mod for MFT */
id|NTFS_PUTU64
c_func
(paren
id|position
op_plus
l_int|0x20
comma
id|now
)paren
suffix:semicolon
multiline_comment|/* Last access */
multiline_comment|/* FIXME: Get the following two sizes by finding the data attribute&n;&t; * in ino-&gt;attr and copying the corresponding fields from there.&n;&t; * If no data present then set to zero. In current implementation&n;&t; * add_data is called after add_filename so zero is correct on&n;&t; * creation. Need to change when we have hard links / support different&n;&t; * filename namespaces. (AIA) */
id|NTFS_PUTS64
c_func
(paren
id|position
op_plus
l_int|0x28
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Allocated size */
id|NTFS_PUTS64
c_func
(paren
id|position
op_plus
l_int|0x30
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Data size */
id|NTFS_PUTU32
c_func
(paren
id|position
op_plus
l_int|0x38
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* File flags */
id|NTFS_PUTU32
c_func
(paren
id|position
op_plus
l_int|0x3c
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* We don&squot;t use these&n;&t;&t;&t;&t;&t;&t;&t; * features yet. */
id|NTFS_PUTU8
c_func
(paren
id|position
op_plus
l_int|0x40
comma
id|length
)paren
suffix:semicolon
multiline_comment|/* Filename length */
id|NTFS_PUTU8
c_func
(paren
id|position
op_plus
l_int|0x41
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Only long name */
multiline_comment|/* FIXME: This is madness. We are defining the POSIX namespace&n;&t;&t; * for the filename here which can mean that the file will be&n;&t;&t; * invisible when in Windows NT/2k! )-: (AIA) */
id|position
op_add_assign
l_int|0x42
suffix:semicolon
r_for
c_loop
(paren
id|count
op_assign
l_int|0
suffix:semicolon
id|count
OL
id|length
suffix:semicolon
id|count
op_increment
)paren
(brace
id|NTFS_PUTU16
c_func
(paren
id|position
op_plus
l_int|2
op_star
id|count
comma
id|filename
(braket
id|count
)braket
)paren
suffix:semicolon
)brace
id|error
op_assign
id|ntfs_create_attr
c_func
(paren
id|ino
comma
id|ino-&gt;vol-&gt;at_file_name
comma
l_int|0
comma
id|data
comma
id|size
comma
op_amp
id|fn
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
id|error
op_assign
id|ntfs_dir_add
c_func
(paren
id|dir
comma
id|ino
comma
id|fn
)paren
suffix:semicolon
id|ntfs_free
c_func
(paren
id|data
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
DECL|function|add_security
r_int
id|add_security
c_func
(paren
id|ntfs_inode
op_star
id|ino
comma
id|ntfs_inode
op_star
id|dir
)paren
(brace
r_int
id|error
suffix:semicolon
r_char
op_star
id|buf
suffix:semicolon
r_int
id|size
suffix:semicolon
id|ntfs_attribute
op_star
id|attr
suffix:semicolon
id|ntfs_io
id|io
suffix:semicolon
id|ntfs_attribute
op_star
id|se
suffix:semicolon
id|attr
op_assign
id|ntfs_find_attr
c_func
(paren
id|dir
comma
id|ino-&gt;vol-&gt;at_security_descriptor
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|attr
)paren
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
multiline_comment|/* Need security in directory. */
id|size
op_assign
id|attr-&gt;size
suffix:semicolon
r_if
c_cond
(paren
id|size
OG
l_int|512
)paren
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
id|buf
op_assign
id|ntfs_malloc
c_func
(paren
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buf
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|io.fn_get
op_assign
id|ntfs_get
suffix:semicolon
id|io.fn_put
op_assign
id|ntfs_put
suffix:semicolon
id|io.param
op_assign
id|buf
suffix:semicolon
id|io.size
op_assign
id|size
suffix:semicolon
id|error
op_assign
id|ntfs_read_attr
c_func
(paren
id|dir
comma
id|ino-&gt;vol-&gt;at_security_descriptor
comma
l_int|0
comma
l_int|0
comma
op_amp
id|io
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
op_logical_and
id|io.size
op_ne
id|size
)paren
id|ntfs_error
c_func
(paren
l_string|&quot;wrong size in add_security&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|ntfs_free
c_func
(paren
id|buf
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/* FIXME: Consider ACL inheritance. */
id|error
op_assign
id|ntfs_create_attr
c_func
(paren
id|ino
comma
id|ino-&gt;vol-&gt;at_security_descriptor
comma
l_int|0
comma
id|buf
comma
id|size
comma
op_amp
id|se
)paren
suffix:semicolon
id|ntfs_free
c_func
(paren
id|buf
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
DECL|function|add_data
r_static
r_int
id|add_data
c_func
(paren
id|ntfs_inode
op_star
id|ino
comma
r_int
r_char
op_star
id|data
comma
r_int
id|length
)paren
(brace
id|ntfs_attribute
op_star
id|da
suffix:semicolon
r_return
id|ntfs_create_attr
c_func
(paren
id|ino
comma
id|ino-&gt;vol-&gt;at_data
comma
l_int|0
comma
id|data
comma
id|length
comma
op_amp
id|da
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * We _could_ use &squot;dir&squot; to help optimise inode allocation.&n; *&n; * FIXME: Need to undo what we do in ntfs_alloc_mft_record if we get an error&n; * further on in ntfs_alloc_inode. Either fold the two functions to allow&n; * proper undo or just deallocate the record from the mft bitmap. (AIA)&n; */
DECL|function|ntfs_alloc_inode
r_int
id|ntfs_alloc_inode
c_func
(paren
id|ntfs_inode
op_star
id|dir
comma
id|ntfs_inode
op_star
id|result
comma
r_const
r_char
op_star
id|filename
comma
r_int
id|namelen
comma
id|ntfs_u32
id|flags
)paren
(brace
id|ntfs_volume
op_star
id|vol
op_assign
id|dir-&gt;vol
suffix:semicolon
r_int
id|err
suffix:semicolon
id|ntfs_u8
id|buffer
(braket
l_int|2
)braket
suffix:semicolon
id|ntfs_io
id|io
suffix:semicolon
id|err
op_assign
id|ntfs_alloc_mft_record
c_func
(paren
id|vol
comma
op_amp
(paren
id|result-&gt;i_number
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
r_if
c_cond
(paren
id|err
op_eq
op_minus
id|ENOSPC
)paren
id|ntfs_error
c_func
(paren
id|__FUNCTION__
l_string|&quot;(): No free inodes.&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/* Get the sequence number. */
id|io.fn_put
op_assign
id|ntfs_put
suffix:semicolon
id|io.fn_get
op_assign
id|ntfs_get
suffix:semicolon
id|io.param
op_assign
id|buffer
suffix:semicolon
id|io.size
op_assign
l_int|2
suffix:semicolon
id|err
op_assign
id|ntfs_read_attr
c_func
(paren
id|vol-&gt;mft_ino
comma
id|vol-&gt;at_data
comma
l_int|0
comma
(paren
(paren
id|__s64
)paren
id|result-&gt;i_number
op_lshift
id|vol-&gt;mft_record_size_bits
)paren
op_plus
l_int|0x10
comma
op_amp
id|io
)paren
suffix:semicolon
singleline_comment|// FIXME: We are leaving the MFT in inconsistent state! (AIA)
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
multiline_comment|/* Increment the sequence number skipping zero. */
id|result-&gt;sequence_number
op_assign
(paren
id|NTFS_GETU16
c_func
(paren
id|buffer
)paren
op_plus
l_int|1
)paren
op_amp
l_int|0xffff
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|result-&gt;sequence_number
)paren
id|result-&gt;sequence_number
op_increment
suffix:semicolon
id|result-&gt;vol
op_assign
id|vol
suffix:semicolon
id|result-&gt;attr_count
op_assign
l_int|0
suffix:semicolon
id|result-&gt;attrs
op_assign
l_int|0
suffix:semicolon
id|result-&gt;record_count
op_assign
l_int|1
suffix:semicolon
id|result-&gt;records
op_assign
id|ntfs_calloc
c_func
(paren
l_int|8
op_star
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|result-&gt;records
)paren
r_goto
id|mem_err_out
suffix:semicolon
id|result-&gt;records
(braket
l_int|0
)braket
op_assign
id|result-&gt;i_number
suffix:semicolon
id|result-&gt;attr
op_assign
id|ntfs_calloc
c_func
(paren
id|vol-&gt;mft_record_size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|result-&gt;attr
)paren
(brace
id|ntfs_free
c_func
(paren
id|result-&gt;records
)paren
suffix:semicolon
id|result-&gt;records
op_assign
l_int|NULL
suffix:semicolon
r_goto
id|mem_err_out
suffix:semicolon
)brace
id|ntfs_fill_mft_header
c_func
(paren
id|result-&gt;attr
comma
id|vol-&gt;mft_record_size
comma
id|result-&gt;sequence_number
comma
l_int|1
comma
l_int|1
)paren
suffix:semicolon
id|err
op_assign
id|add_standard_information
c_func
(paren
id|result
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|err
)paren
id|err
op_assign
id|add_filename
c_func
(paren
id|result
comma
id|dir
comma
id|filename
comma
id|namelen
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|err
)paren
id|err
op_assign
id|add_security
c_func
(paren
id|result
comma
id|dir
)paren
suffix:semicolon
singleline_comment|// FIXME: We are leaving the MFT in inconsistent state on error! (AIA)
r_return
id|err
suffix:semicolon
id|mem_err_out
suffix:colon
singleline_comment|// FIXME: We are leaving the MFT in inconsistent state! (AIA)
id|result-&gt;record_count
op_assign
l_int|0
suffix:semicolon
id|result-&gt;attr
op_assign
l_int|NULL
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
DECL|function|ntfs_alloc_file
r_int
id|ntfs_alloc_file
c_func
(paren
id|ntfs_inode
op_star
id|dir
comma
id|ntfs_inode
op_star
id|result
comma
r_char
op_star
id|filename
comma
r_int
id|namelen
)paren
(brace
r_int
id|err
suffix:semicolon
id|err
op_assign
id|ntfs_alloc_inode
c_func
(paren
id|dir
comma
id|result
comma
id|filename
comma
id|namelen
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|err
)paren
id|err
op_assign
id|add_data
c_func
(paren
id|result
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
eof
