multiline_comment|/**&n; * runlist.c - NTFS runlist handling code.  Part of the Linux-NTFS project.&n; *&n; * Copyright (c) 2001-2004 Anton Altaparmakov&n; * Copyright (c) 2002 Richard Russon&n; *&n; * This program/include file is free software; you can redistribute it and/or&n; * modify it under the terms of the GNU General Public License as published&n; * by the Free Software Foundation; either version 2 of the License, or&n; * (at your option) any later version.&n; *&n; * This program/include file is distributed in the hope that it will be&n; * useful, but WITHOUT ANY WARRANTY; without even the implied warranty&n; * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; * GNU General Public License for more details.&n; *&n; * You should have received a copy of the GNU General Public License&n; * along with this program (in the main directory of the Linux-NTFS&n; * distribution in the file COPYING); if not, write to the Free Software&n; * Foundation,Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA&n; */
macro_line|#include &quot;debug.h&quot;
macro_line|#include &quot;dir.h&quot;
macro_line|#include &quot;endian.h&quot;
macro_line|#include &quot;malloc.h&quot;
macro_line|#include &quot;ntfs.h&quot;
multiline_comment|/**&n; * ntfs_rl_mm - runlist memmove&n; *&n; * It is up to the caller to serialize access to the runlist @base.&n; */
DECL|function|ntfs_rl_mm
r_static
r_inline
r_void
id|ntfs_rl_mm
c_func
(paren
id|runlist_element
op_star
id|base
comma
r_int
id|dst
comma
r_int
id|src
comma
r_int
id|size
)paren
(brace
r_if
c_cond
(paren
id|likely
c_func
(paren
(paren
id|dst
op_ne
id|src
)paren
op_logical_and
(paren
id|size
OG
l_int|0
)paren
)paren
)paren
id|memmove
c_func
(paren
id|base
op_plus
id|dst
comma
id|base
op_plus
id|src
comma
id|size
op_star
r_sizeof
(paren
op_star
id|base
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_rl_mc - runlist memory copy&n; *&n; * It is up to the caller to serialize access to the runlists @dstbase and&n; * @srcbase.&n; */
DECL|function|ntfs_rl_mc
r_static
r_inline
r_void
id|ntfs_rl_mc
c_func
(paren
id|runlist_element
op_star
id|dstbase
comma
r_int
id|dst
comma
id|runlist_element
op_star
id|srcbase
comma
r_int
id|src
comma
r_int
id|size
)paren
(brace
r_if
c_cond
(paren
id|likely
c_func
(paren
id|size
OG
l_int|0
)paren
)paren
id|memcpy
c_func
(paren
id|dstbase
op_plus
id|dst
comma
id|srcbase
op_plus
id|src
comma
id|size
op_star
r_sizeof
(paren
op_star
id|dstbase
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_rl_realloc - Reallocate memory for runlists&n; * @rl:&t;&t;original runlist&n; * @old_size:&t;number of runlist elements in the original runlist @rl&n; * @new_size:&t;number of runlist elements we need space for&n; *&n; * As the runlists grow, more memory will be required.  To prevent the&n; * kernel having to allocate and reallocate large numbers of small bits of&n; * memory, this function returns and entire page of memory.&n; *&n; * It is up to the caller to serialize access to the runlist @rl.&n; *&n; * N.B.  If the new allocation doesn&squot;t require a different number of pages in&n; *       memory, the function will return the original pointer.&n; *&n; * On success, return a pointer to the newly allocated, or recycled, memory.&n; * On error, return -errno. The following error codes are defined:&n; *&t;-ENOMEM&t;- Not enough memory to allocate runlist array.&n; *&t;-EINVAL&t;- Invalid parameters were passed in.&n; */
DECL|function|ntfs_rl_realloc
r_static
r_inline
id|runlist_element
op_star
id|ntfs_rl_realloc
c_func
(paren
id|runlist_element
op_star
id|rl
comma
r_int
id|old_size
comma
r_int
id|new_size
)paren
(brace
id|runlist_element
op_star
id|new_rl
suffix:semicolon
id|old_size
op_assign
id|PAGE_ALIGN
c_func
(paren
id|old_size
op_star
r_sizeof
(paren
op_star
id|rl
)paren
)paren
suffix:semicolon
id|new_size
op_assign
id|PAGE_ALIGN
c_func
(paren
id|new_size
op_star
r_sizeof
(paren
op_star
id|rl
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|old_size
op_eq
id|new_size
)paren
r_return
id|rl
suffix:semicolon
id|new_rl
op_assign
id|ntfs_malloc_nofs
c_func
(paren
id|new_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|new_rl
)paren
)paren
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
id|rl
op_ne
l_int|NULL
)paren
)paren
(brace
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|old_size
OG
id|new_size
)paren
)paren
id|old_size
op_assign
id|new_size
suffix:semicolon
id|memcpy
c_func
(paren
id|new_rl
comma
id|rl
comma
id|old_size
)paren
suffix:semicolon
id|ntfs_free
c_func
(paren
id|rl
)paren
suffix:semicolon
)brace
r_return
id|new_rl
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_are_rl_mergeable - test if two runlists can be joined together&n; * @dst:&t;original runlist&n; * @src:&t;new runlist to test for mergeability with @dst&n; *&n; * Test if two runlists can be joined together. For this, their VCNs and LCNs&n; * must be adjacent.&n; *&n; * It is up to the caller to serialize access to the runlists @dst and @src.&n; *&n; * Return: TRUE   Success, the runlists can be merged.&n; *&t;   FALSE  Failure, the runlists cannot be merged.&n; */
DECL|function|ntfs_are_rl_mergeable
r_static
r_inline
id|BOOL
id|ntfs_are_rl_mergeable
c_func
(paren
id|runlist_element
op_star
id|dst
comma
id|runlist_element
op_star
id|src
)paren
(brace
id|BUG_ON
c_func
(paren
op_logical_neg
id|dst
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|src
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|dst-&gt;lcn
OL
l_int|0
)paren
op_logical_or
(paren
id|src-&gt;lcn
OL
l_int|0
)paren
)paren
multiline_comment|/* Are we merging holes? */
r_return
id|FALSE
suffix:semicolon
r_if
c_cond
(paren
(paren
id|dst-&gt;lcn
op_plus
id|dst-&gt;length
)paren
op_ne
id|src-&gt;lcn
)paren
multiline_comment|/* Are the runs contiguous? */
r_return
id|FALSE
suffix:semicolon
r_if
c_cond
(paren
(paren
id|dst-&gt;vcn
op_plus
id|dst-&gt;length
)paren
op_ne
id|src-&gt;vcn
)paren
multiline_comment|/* Are the runs misaligned? */
r_return
id|FALSE
suffix:semicolon
r_return
id|TRUE
suffix:semicolon
)brace
multiline_comment|/**&n; * __ntfs_rl_merge - merge two runlists without testing if they can be merged&n; * @dst:&t;original, destination runlist&n; * @src:&t;new runlist to merge with @dst&n; *&n; * Merge the two runlists, writing into the destination runlist @dst. The&n; * caller must make sure the runlists can be merged or this will corrupt the&n; * destination runlist.&n; *&n; * It is up to the caller to serialize access to the runlists @dst and @src.&n; */
DECL|function|__ntfs_rl_merge
r_static
r_inline
r_void
id|__ntfs_rl_merge
c_func
(paren
id|runlist_element
op_star
id|dst
comma
id|runlist_element
op_star
id|src
)paren
(brace
id|dst-&gt;length
op_add_assign
id|src-&gt;length
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_rl_append - append a runlist after a given element&n; * @dst:&t;original runlist to be worked on&n; * @dsize:&t;number of elements in @dst (including end marker)&n; * @src:&t;runlist to be inserted into @dst&n; * @ssize:&t;number of elements in @src (excluding end marker)&n; * @loc:&t;append the new runlist @src after this element in @dst&n; *&n; * Append the runlist @src after element @loc in @dst.  Merge the right end of&n; * the new runlist, if necessary. Adjust the size of the hole before the&n; * appended runlist.&n; *&n; * It is up to the caller to serialize access to the runlists @dst and @src.&n; *&n; * On success, return a pointer to the new, combined, runlist. Note, both&n; * runlists @dst and @src are deallocated before returning so you cannot use&n; * the pointers for anything any more. (Strictly speaking the returned runlist&n; * may be the same as @dst but this is irrelevant.)&n; *&n; * On error, return -errno. Both runlists are left unmodified. The following&n; * error codes are defined:&n; *&t;-ENOMEM&t;- Not enough memory to allocate runlist array.&n; *&t;-EINVAL&t;- Invalid parameters were passed in.&n; */
DECL|function|ntfs_rl_append
r_static
r_inline
id|runlist_element
op_star
id|ntfs_rl_append
c_func
(paren
id|runlist_element
op_star
id|dst
comma
r_int
id|dsize
comma
id|runlist_element
op_star
id|src
comma
r_int
id|ssize
comma
r_int
id|loc
)paren
(brace
id|BOOL
id|right
suffix:semicolon
r_int
id|magic
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|dst
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|src
)paren
suffix:semicolon
multiline_comment|/* First, check if the right hand end needs merging. */
id|right
op_assign
id|ntfs_are_rl_mergeable
c_func
(paren
id|src
op_plus
id|ssize
op_minus
l_int|1
comma
id|dst
op_plus
id|loc
op_plus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Space required: @dst size + @src size, less one if we merged. */
id|dst
op_assign
id|ntfs_rl_realloc
c_func
(paren
id|dst
comma
id|dsize
comma
id|dsize
op_plus
id|ssize
op_minus
id|right
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|dst
)paren
)paren
r_return
id|dst
suffix:semicolon
multiline_comment|/*&n;&t; * We are guaranteed to succeed from here so can start modifying the&n;&t; * original runlists.&n;&t; */
multiline_comment|/* First, merge the right hand end, if necessary. */
r_if
c_cond
(paren
id|right
)paren
id|__ntfs_rl_merge
c_func
(paren
id|src
op_plus
id|ssize
op_minus
l_int|1
comma
id|dst
op_plus
id|loc
op_plus
l_int|1
)paren
suffix:semicolon
id|magic
op_assign
id|loc
op_plus
id|ssize
suffix:semicolon
multiline_comment|/* Move the tail of @dst out of the way, then copy in @src. */
id|ntfs_rl_mm
c_func
(paren
id|dst
comma
id|magic
op_plus
l_int|1
comma
id|loc
op_plus
l_int|1
op_plus
id|right
comma
id|dsize
op_minus
id|loc
op_minus
l_int|1
op_minus
id|right
)paren
suffix:semicolon
id|ntfs_rl_mc
c_func
(paren
id|dst
comma
id|loc
op_plus
l_int|1
comma
id|src
comma
l_int|0
comma
id|ssize
)paren
suffix:semicolon
multiline_comment|/* Adjust the size of the preceding hole. */
id|dst
(braket
id|loc
)braket
dot
id|length
op_assign
id|dst
(braket
id|loc
op_plus
l_int|1
)braket
dot
id|vcn
op_minus
id|dst
(braket
id|loc
)braket
dot
id|vcn
suffix:semicolon
multiline_comment|/* We may have changed the length of the file, so fix the end marker */
r_if
c_cond
(paren
id|dst
(braket
id|magic
op_plus
l_int|1
)braket
dot
id|lcn
op_eq
id|LCN_ENOENT
)paren
id|dst
(braket
id|magic
op_plus
l_int|1
)braket
dot
id|vcn
op_assign
id|dst
(braket
id|magic
)braket
dot
id|vcn
op_plus
id|dst
(braket
id|magic
)braket
dot
id|length
suffix:semicolon
r_return
id|dst
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_rl_insert - insert a runlist into another&n; * @dst:&t;original runlist to be worked on&n; * @dsize:&t;number of elements in @dst (including end marker)&n; * @src:&t;new runlist to be inserted&n; * @ssize:&t;number of elements in @src (excluding end marker)&n; * @loc:&t;insert the new runlist @src before this element in @dst&n; *&n; * Insert the runlist @src before element @loc in the runlist @dst. Merge the&n; * left end of the new runlist, if necessary. Adjust the size of the hole&n; * after the inserted runlist.&n; *&n; * It is up to the caller to serialize access to the runlists @dst and @src.&n; *&n; * On success, return a pointer to the new, combined, runlist. Note, both&n; * runlists @dst and @src are deallocated before returning so you cannot use&n; * the pointers for anything any more. (Strictly speaking the returned runlist&n; * may be the same as @dst but this is irrelevant.)&n; *&n; * On error, return -errno. Both runlists are left unmodified. The following&n; * error codes are defined:&n; *&t;-ENOMEM&t;- Not enough memory to allocate runlist array.&n; *&t;-EINVAL&t;- Invalid parameters were passed in.&n; */
DECL|function|ntfs_rl_insert
r_static
r_inline
id|runlist_element
op_star
id|ntfs_rl_insert
c_func
(paren
id|runlist_element
op_star
id|dst
comma
r_int
id|dsize
comma
id|runlist_element
op_star
id|src
comma
r_int
id|ssize
comma
r_int
id|loc
)paren
(brace
id|BOOL
id|left
op_assign
id|FALSE
suffix:semicolon
id|BOOL
id|disc
op_assign
id|FALSE
suffix:semicolon
multiline_comment|/* Discontinuity */
id|BOOL
id|hole
op_assign
id|FALSE
suffix:semicolon
multiline_comment|/* Following a hole */
r_int
id|magic
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|dst
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|src
)paren
suffix:semicolon
multiline_comment|/* disc =&gt; Discontinuity between the end of @dst and the start of @src.&n;&t; *&t;   This means we might need to insert a hole.&n;&t; * hole =&gt; @dst ends with a hole or an unmapped region which we can&n;&t; *&t;   extend to match the discontinuity. */
r_if
c_cond
(paren
id|loc
op_eq
l_int|0
)paren
id|disc
op_assign
(paren
id|src
(braket
l_int|0
)braket
dot
id|vcn
OG
l_int|0
)paren
suffix:semicolon
r_else
(brace
id|s64
id|merged_length
suffix:semicolon
id|left
op_assign
id|ntfs_are_rl_mergeable
c_func
(paren
id|dst
op_plus
id|loc
op_minus
l_int|1
comma
id|src
)paren
suffix:semicolon
id|merged_length
op_assign
id|dst
(braket
id|loc
op_minus
l_int|1
)braket
dot
id|length
suffix:semicolon
r_if
c_cond
(paren
id|left
)paren
id|merged_length
op_add_assign
id|src-&gt;length
suffix:semicolon
id|disc
op_assign
(paren
id|src
(braket
l_int|0
)braket
dot
id|vcn
OG
id|dst
(braket
id|loc
op_minus
l_int|1
)braket
dot
id|vcn
op_plus
id|merged_length
)paren
suffix:semicolon
r_if
c_cond
(paren
id|disc
)paren
id|hole
op_assign
(paren
id|dst
(braket
id|loc
op_minus
l_int|1
)braket
dot
id|lcn
op_eq
id|LCN_HOLE
)paren
suffix:semicolon
)brace
multiline_comment|/* Space required: @dst size + @src size, less one if we merged, plus&n;&t; * one if there was a discontinuity, less one for a trailing hole. */
id|dst
op_assign
id|ntfs_rl_realloc
c_func
(paren
id|dst
comma
id|dsize
comma
id|dsize
op_plus
id|ssize
op_minus
id|left
op_plus
id|disc
op_minus
id|hole
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|dst
)paren
)paren
r_return
id|dst
suffix:semicolon
multiline_comment|/*&n;&t; * We are guaranteed to succeed from here so can start modifying the&n;&t; * original runlist.&n;&t; */
r_if
c_cond
(paren
id|left
)paren
id|__ntfs_rl_merge
c_func
(paren
id|dst
op_plus
id|loc
op_minus
l_int|1
comma
id|src
)paren
suffix:semicolon
id|magic
op_assign
id|loc
op_plus
id|ssize
op_minus
id|left
op_plus
id|disc
op_minus
id|hole
suffix:semicolon
multiline_comment|/* Move the tail of @dst out of the way, then copy in @src. */
id|ntfs_rl_mm
c_func
(paren
id|dst
comma
id|magic
comma
id|loc
comma
id|dsize
op_minus
id|loc
)paren
suffix:semicolon
id|ntfs_rl_mc
c_func
(paren
id|dst
comma
id|loc
op_plus
id|disc
op_minus
id|hole
comma
id|src
comma
id|left
comma
id|ssize
op_minus
id|left
)paren
suffix:semicolon
multiline_comment|/* Adjust the VCN of the last run ... */
r_if
c_cond
(paren
id|dst
(braket
id|magic
)braket
dot
id|lcn
op_le
id|LCN_HOLE
)paren
id|dst
(braket
id|magic
)braket
dot
id|vcn
op_assign
id|dst
(braket
id|magic
op_minus
l_int|1
)braket
dot
id|vcn
op_plus
id|dst
(braket
id|magic
op_minus
l_int|1
)braket
dot
id|length
suffix:semicolon
multiline_comment|/* ... and the length. */
r_if
c_cond
(paren
id|dst
(braket
id|magic
)braket
dot
id|lcn
op_eq
id|LCN_HOLE
op_logical_or
id|dst
(braket
id|magic
)braket
dot
id|lcn
op_eq
id|LCN_RL_NOT_MAPPED
)paren
id|dst
(braket
id|magic
)braket
dot
id|length
op_assign
id|dst
(braket
id|magic
op_plus
l_int|1
)braket
dot
id|vcn
op_minus
id|dst
(braket
id|magic
)braket
dot
id|vcn
suffix:semicolon
multiline_comment|/* Writing beyond the end of the file and there&squot;s a discontinuity. */
r_if
c_cond
(paren
id|disc
)paren
(brace
r_if
c_cond
(paren
id|hole
)paren
id|dst
(braket
id|loc
op_minus
l_int|1
)braket
dot
id|length
op_assign
id|dst
(braket
id|loc
)braket
dot
id|vcn
op_minus
id|dst
(braket
id|loc
op_minus
l_int|1
)braket
dot
id|vcn
suffix:semicolon
r_else
(brace
r_if
c_cond
(paren
id|loc
OG
l_int|0
)paren
(brace
id|dst
(braket
id|loc
)braket
dot
id|vcn
op_assign
id|dst
(braket
id|loc
op_minus
l_int|1
)braket
dot
id|vcn
op_plus
id|dst
(braket
id|loc
op_minus
l_int|1
)braket
dot
id|length
suffix:semicolon
id|dst
(braket
id|loc
)braket
dot
id|length
op_assign
id|dst
(braket
id|loc
op_plus
l_int|1
)braket
dot
id|vcn
op_minus
id|dst
(braket
id|loc
)braket
dot
id|vcn
suffix:semicolon
)brace
r_else
(brace
id|dst
(braket
id|loc
)braket
dot
id|vcn
op_assign
l_int|0
suffix:semicolon
id|dst
(braket
id|loc
)braket
dot
id|length
op_assign
id|dst
(braket
id|loc
op_plus
l_int|1
)braket
dot
id|vcn
suffix:semicolon
)brace
id|dst
(braket
id|loc
)braket
dot
id|lcn
op_assign
id|LCN_RL_NOT_MAPPED
suffix:semicolon
)brace
id|magic
op_add_assign
id|hole
suffix:semicolon
r_if
c_cond
(paren
id|dst
(braket
id|magic
)braket
dot
id|lcn
op_eq
id|LCN_ENOENT
)paren
id|dst
(braket
id|magic
)braket
dot
id|vcn
op_assign
id|dst
(braket
id|magic
op_minus
l_int|1
)braket
dot
id|vcn
op_plus
id|dst
(braket
id|magic
op_minus
l_int|1
)braket
dot
id|length
suffix:semicolon
)brace
r_return
id|dst
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_rl_replace - overwrite a runlist element with another runlist&n; * @dst:&t;original runlist to be worked on&n; * @dsize:&t;number of elements in @dst (including end marker)&n; * @src:&t;new runlist to be inserted&n; * @ssize:&t;number of elements in @src (excluding end marker)&n; * @loc:&t;index in runlist @dst to overwrite with @src&n; *&n; * Replace the runlist element @dst at @loc with @src. Merge the left and&n; * right ends of the inserted runlist, if necessary.&n; *&n; * It is up to the caller to serialize access to the runlists @dst and @src.&n; *&n; * On success, return a pointer to the new, combined, runlist. Note, both&n; * runlists @dst and @src are deallocated before returning so you cannot use&n; * the pointers for anything any more. (Strictly speaking the returned runlist&n; * may be the same as @dst but this is irrelevant.)&n; *&n; * On error, return -errno. Both runlists are left unmodified. The following&n; * error codes are defined:&n; *&t;-ENOMEM&t;- Not enough memory to allocate runlist array.&n; *&t;-EINVAL&t;- Invalid parameters were passed in.&n; */
DECL|function|ntfs_rl_replace
r_static
r_inline
id|runlist_element
op_star
id|ntfs_rl_replace
c_func
(paren
id|runlist_element
op_star
id|dst
comma
r_int
id|dsize
comma
id|runlist_element
op_star
id|src
comma
r_int
id|ssize
comma
r_int
id|loc
)paren
(brace
id|BOOL
id|left
op_assign
id|FALSE
suffix:semicolon
id|BOOL
id|right
suffix:semicolon
r_int
id|magic
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|dst
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|src
)paren
suffix:semicolon
multiline_comment|/* First, merge the left and right ends, if necessary. */
id|right
op_assign
id|ntfs_are_rl_mergeable
c_func
(paren
id|src
op_plus
id|ssize
op_minus
l_int|1
comma
id|dst
op_plus
id|loc
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|loc
OG
l_int|0
)paren
id|left
op_assign
id|ntfs_are_rl_mergeable
c_func
(paren
id|dst
op_plus
id|loc
op_minus
l_int|1
comma
id|src
)paren
suffix:semicolon
multiline_comment|/* Allocate some space. We&squot;ll need less if the left, right, or both&n;&t; * ends were merged. */
id|dst
op_assign
id|ntfs_rl_realloc
c_func
(paren
id|dst
comma
id|dsize
comma
id|dsize
op_plus
id|ssize
op_minus
id|left
op_minus
id|right
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|dst
)paren
)paren
r_return
id|dst
suffix:semicolon
multiline_comment|/*&n;&t; * We are guaranteed to succeed from here so can start modifying the&n;&t; * original runlists.&n;&t; */
r_if
c_cond
(paren
id|right
)paren
id|__ntfs_rl_merge
c_func
(paren
id|src
op_plus
id|ssize
op_minus
l_int|1
comma
id|dst
op_plus
id|loc
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|left
)paren
id|__ntfs_rl_merge
c_func
(paren
id|dst
op_plus
id|loc
op_minus
l_int|1
comma
id|src
)paren
suffix:semicolon
multiline_comment|/* FIXME: What does this mean? (AIA) */
id|magic
op_assign
id|loc
op_plus
id|ssize
op_minus
id|left
suffix:semicolon
multiline_comment|/* Move the tail of @dst out of the way, then copy in @src. */
id|ntfs_rl_mm
c_func
(paren
id|dst
comma
id|magic
comma
id|loc
op_plus
id|right
op_plus
l_int|1
comma
id|dsize
op_minus
id|loc
op_minus
id|right
op_minus
l_int|1
)paren
suffix:semicolon
id|ntfs_rl_mc
c_func
(paren
id|dst
comma
id|loc
comma
id|src
comma
id|left
comma
id|ssize
op_minus
id|left
)paren
suffix:semicolon
multiline_comment|/* We may have changed the length of the file, so fix the end marker */
r_if
c_cond
(paren
id|dst
(braket
id|magic
)braket
dot
id|lcn
op_eq
id|LCN_ENOENT
)paren
id|dst
(braket
id|magic
)braket
dot
id|vcn
op_assign
id|dst
(braket
id|magic
op_minus
l_int|1
)braket
dot
id|vcn
op_plus
id|dst
(braket
id|magic
op_minus
l_int|1
)braket
dot
id|length
suffix:semicolon
r_return
id|dst
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_rl_split - insert a runlist into the centre of a hole&n; * @dst:&t;original runlist to be worked on&n; * @dsize:&t;number of elements in @dst (including end marker)&n; * @src:&t;new runlist to be inserted&n; * @ssize:&t;number of elements in @src (excluding end marker)&n; * @loc:&t;index in runlist @dst at which to split and insert @src&n; *&n; * Split the runlist @dst at @loc into two and insert @new in between the two&n; * fragments. No merging of runlists is necessary. Adjust the size of the&n; * holes either side.&n; *&n; * It is up to the caller to serialize access to the runlists @dst and @src.&n; *&n; * On success, return a pointer to the new, combined, runlist. Note, both&n; * runlists @dst and @src are deallocated before returning so you cannot use&n; * the pointers for anything any more. (Strictly speaking the returned runlist&n; * may be the same as @dst but this is irrelevant.)&n; *&n; * On error, return -errno. Both runlists are left unmodified. The following&n; * error codes are defined:&n; *&t;-ENOMEM&t;- Not enough memory to allocate runlist array.&n; *&t;-EINVAL&t;- Invalid parameters were passed in.&n; */
DECL|function|ntfs_rl_split
r_static
r_inline
id|runlist_element
op_star
id|ntfs_rl_split
c_func
(paren
id|runlist_element
op_star
id|dst
comma
r_int
id|dsize
comma
id|runlist_element
op_star
id|src
comma
r_int
id|ssize
comma
r_int
id|loc
)paren
(brace
id|BUG_ON
c_func
(paren
op_logical_neg
id|dst
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|src
)paren
suffix:semicolon
multiline_comment|/* Space required: @dst size + @src size + one new hole. */
id|dst
op_assign
id|ntfs_rl_realloc
c_func
(paren
id|dst
comma
id|dsize
comma
id|dsize
op_plus
id|ssize
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|dst
)paren
)paren
r_return
id|dst
suffix:semicolon
multiline_comment|/*&n;&t; * We are guaranteed to succeed from here so can start modifying the&n;&t; * original runlists.&n;&t; */
multiline_comment|/* Move the tail of @dst out of the way, then copy in @src. */
id|ntfs_rl_mm
c_func
(paren
id|dst
comma
id|loc
op_plus
l_int|1
op_plus
id|ssize
comma
id|loc
comma
id|dsize
op_minus
id|loc
)paren
suffix:semicolon
id|ntfs_rl_mc
c_func
(paren
id|dst
comma
id|loc
op_plus
l_int|1
comma
id|src
comma
l_int|0
comma
id|ssize
)paren
suffix:semicolon
multiline_comment|/* Adjust the size of the holes either size of @src. */
id|dst
(braket
id|loc
)braket
dot
id|length
op_assign
id|dst
(braket
id|loc
op_plus
l_int|1
)braket
dot
id|vcn
op_minus
id|dst
(braket
id|loc
)braket
dot
id|vcn
suffix:semicolon
id|dst
(braket
id|loc
op_plus
id|ssize
op_plus
l_int|1
)braket
dot
id|vcn
op_assign
id|dst
(braket
id|loc
op_plus
id|ssize
)braket
dot
id|vcn
op_plus
id|dst
(braket
id|loc
op_plus
id|ssize
)braket
dot
id|length
suffix:semicolon
id|dst
(braket
id|loc
op_plus
id|ssize
op_plus
l_int|1
)braket
dot
id|length
op_assign
id|dst
(braket
id|loc
op_plus
id|ssize
op_plus
l_int|2
)braket
dot
id|vcn
op_minus
id|dst
(braket
id|loc
op_plus
id|ssize
op_plus
l_int|1
)braket
dot
id|vcn
suffix:semicolon
r_return
id|dst
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_runlists_merge - merge two runlists into one&n; * @drl:&t;original runlist to be worked on&n; * @srl:&t;new runlist to be merged into @drl&n; *&n; * First we sanity check the two runlists @srl and @drl to make sure that they&n; * are sensible and can be merged. The runlist @srl must be either after the&n; * runlist @drl or completely within a hole (or unmapped region) in @drl.&n; *&n; * It is up to the caller to serialize access to the runlists @drl and @srl.&n; *&n; * Merging of runlists is necessary in two cases:&n; *   1. When attribute lists are used and a further extent is being mapped.&n; *   2. When new clusters are allocated to fill a hole or extend a file.&n; *&n; * There are four possible ways @srl can be merged. It can:&n; *&t;- be inserted at the beginning of a hole,&n; *&t;- split the hole in two and be inserted between the two fragments,&n; *&t;- be appended at the end of a hole, or it can&n; *&t;- replace the whole hole.&n; * It can also be appended to the end of the runlist, which is just a variant&n; * of the insert case.&n; *&n; * On success, return a pointer to the new, combined, runlist. Note, both&n; * runlists @drl and @srl are deallocated before returning so you cannot use&n; * the pointers for anything any more. (Strictly speaking the returned runlist&n; * may be the same as @dst but this is irrelevant.)&n; *&n; * On error, return -errno. Both runlists are left unmodified. The following&n; * error codes are defined:&n; *&t;-ENOMEM&t;- Not enough memory to allocate runlist array.&n; *&t;-EINVAL&t;- Invalid parameters were passed in.&n; *&t;-ERANGE&t;- The runlists overlap and cannot be merged.&n; */
DECL|function|ntfs_runlists_merge
id|runlist_element
op_star
id|ntfs_runlists_merge
c_func
(paren
id|runlist_element
op_star
id|drl
comma
id|runlist_element
op_star
id|srl
)paren
(brace
r_int
id|di
comma
id|si
suffix:semicolon
multiline_comment|/* Current index into @[ds]rl. */
r_int
id|sstart
suffix:semicolon
multiline_comment|/* First index with lcn &gt; LCN_RL_NOT_MAPPED. */
r_int
id|dins
suffix:semicolon
multiline_comment|/* Index into @drl at which to insert @srl. */
r_int
id|dend
comma
id|send
suffix:semicolon
multiline_comment|/* Last index into @[ds]rl. */
r_int
id|dfinal
comma
id|sfinal
suffix:semicolon
multiline_comment|/* The last index into @[ds]rl with&n;&t;&t;&t;&t;   lcn &gt;= LCN_HOLE. */
r_int
id|marker
op_assign
l_int|0
suffix:semicolon
id|VCN
id|marker_vcn
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef DEBUG
id|ntfs_debug
c_func
(paren
l_string|&quot;dst:&quot;
)paren
suffix:semicolon
id|ntfs_debug_dump_runlist
c_func
(paren
id|drl
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;src:&quot;
)paren
suffix:semicolon
id|ntfs_debug_dump_runlist
c_func
(paren
id|srl
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Check for silly calling... */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|srl
)paren
)paren
r_return
id|drl
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|srl
)paren
op_logical_or
id|IS_ERR
c_func
(paren
id|drl
)paren
)paren
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
multiline_comment|/* Check for the case where the first mapping is being done now. */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|drl
)paren
)paren
(brace
id|drl
op_assign
id|srl
suffix:semicolon
multiline_comment|/* Complete the source runlist if necessary. */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|drl
(braket
l_int|0
)braket
dot
id|vcn
)paren
)paren
(brace
multiline_comment|/* Scan to the end of the source runlist. */
r_for
c_loop
(paren
id|dend
op_assign
l_int|0
suffix:semicolon
id|likely
c_func
(paren
id|drl
(braket
id|dend
)braket
dot
id|length
)paren
suffix:semicolon
id|dend
op_increment
)paren
suffix:semicolon
id|drl
op_assign
id|ntfs_rl_realloc
c_func
(paren
id|drl
comma
id|dend
comma
id|dend
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|drl
)paren
)paren
r_return
id|drl
suffix:semicolon
multiline_comment|/* Insert start element at the front of the runlist. */
id|ntfs_rl_mm
c_func
(paren
id|drl
comma
l_int|1
comma
l_int|0
comma
id|dend
)paren
suffix:semicolon
id|drl
(braket
l_int|0
)braket
dot
id|vcn
op_assign
l_int|0
suffix:semicolon
id|drl
(braket
l_int|0
)braket
dot
id|lcn
op_assign
id|LCN_RL_NOT_MAPPED
suffix:semicolon
id|drl
(braket
l_int|0
)braket
dot
id|length
op_assign
id|drl
(braket
l_int|1
)braket
dot
id|vcn
suffix:semicolon
)brace
r_goto
id|finished
suffix:semicolon
)brace
id|si
op_assign
id|di
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Skip any unmapped start element(s) in the source runlist. */
r_while
c_loop
(paren
id|srl
(braket
id|si
)braket
dot
id|length
op_logical_and
id|srl
(braket
id|si
)braket
dot
id|lcn
OL
id|LCN_HOLE
)paren
id|si
op_increment
suffix:semicolon
multiline_comment|/* Can&squot;t have an entirely unmapped source runlist. */
id|BUG_ON
c_func
(paren
op_logical_neg
id|srl
(braket
id|si
)braket
dot
id|length
)paren
suffix:semicolon
multiline_comment|/* Record the starting points. */
id|sstart
op_assign
id|si
suffix:semicolon
multiline_comment|/*&n;&t; * Skip forward in @drl until we reach the position where @srl needs to&n;&t; * be inserted. If we reach the end of @drl, @srl just needs to be&n;&t; * appended to @drl.&n;&t; */
r_for
c_loop
(paren
suffix:semicolon
id|drl
(braket
id|di
)braket
dot
id|length
suffix:semicolon
id|di
op_increment
)paren
(brace
r_if
c_cond
(paren
id|drl
(braket
id|di
)braket
dot
id|vcn
op_plus
id|drl
(braket
id|di
)braket
dot
id|length
OG
id|srl
(braket
id|sstart
)braket
dot
id|vcn
)paren
r_break
suffix:semicolon
)brace
id|dins
op_assign
id|di
suffix:semicolon
multiline_comment|/* Sanity check for illegal overlaps. */
r_if
c_cond
(paren
(paren
id|drl
(braket
id|di
)braket
dot
id|vcn
op_eq
id|srl
(braket
id|si
)braket
dot
id|vcn
)paren
op_logical_and
(paren
id|drl
(braket
id|di
)braket
dot
id|lcn
op_ge
l_int|0
)paren
op_logical_and
(paren
id|srl
(braket
id|si
)braket
dot
id|lcn
op_ge
l_int|0
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
l_int|NULL
comma
l_string|&quot;Run lists overlap. Cannot merge!&quot;
)paren
suffix:semicolon
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|ERANGE
)paren
suffix:semicolon
)brace
multiline_comment|/* Scan to the end of both runlists in order to know their sizes. */
r_for
c_loop
(paren
id|send
op_assign
id|si
suffix:semicolon
id|srl
(braket
id|send
)braket
dot
id|length
suffix:semicolon
id|send
op_increment
)paren
suffix:semicolon
r_for
c_loop
(paren
id|dend
op_assign
id|di
suffix:semicolon
id|drl
(braket
id|dend
)braket
dot
id|length
suffix:semicolon
id|dend
op_increment
)paren
suffix:semicolon
r_if
c_cond
(paren
id|srl
(braket
id|send
)braket
dot
id|lcn
op_eq
id|LCN_ENOENT
)paren
id|marker_vcn
op_assign
id|srl
(braket
id|marker
op_assign
id|send
)braket
dot
id|vcn
suffix:semicolon
multiline_comment|/* Scan to the last element with lcn &gt;= LCN_HOLE. */
r_for
c_loop
(paren
id|sfinal
op_assign
id|send
suffix:semicolon
id|sfinal
op_ge
l_int|0
op_logical_and
id|srl
(braket
id|sfinal
)braket
dot
id|lcn
OL
id|LCN_HOLE
suffix:semicolon
id|sfinal
op_decrement
)paren
suffix:semicolon
r_for
c_loop
(paren
id|dfinal
op_assign
id|dend
suffix:semicolon
id|dfinal
op_ge
l_int|0
op_logical_and
id|drl
(braket
id|dfinal
)braket
dot
id|lcn
OL
id|LCN_HOLE
suffix:semicolon
id|dfinal
op_decrement
)paren
suffix:semicolon
(brace
id|BOOL
id|start
suffix:semicolon
id|BOOL
id|finish
suffix:semicolon
r_int
id|ds
op_assign
id|dend
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* Number of elements in drl &amp; srl */
r_int
id|ss
op_assign
id|sfinal
op_minus
id|sstart
op_plus
l_int|1
suffix:semicolon
id|start
op_assign
(paren
(paren
id|drl
(braket
id|dins
)braket
dot
id|lcn
OL
id|LCN_RL_NOT_MAPPED
)paren
op_logical_or
multiline_comment|/* End of file   */
(paren
id|drl
(braket
id|dins
)braket
dot
id|vcn
op_eq
id|srl
(braket
id|sstart
)braket
dot
id|vcn
)paren
)paren
suffix:semicolon
multiline_comment|/* Start of hole */
id|finish
op_assign
(paren
(paren
id|drl
(braket
id|dins
)braket
dot
id|lcn
op_ge
id|LCN_RL_NOT_MAPPED
)paren
op_logical_and
multiline_comment|/* End of file   */
(paren
(paren
id|drl
(braket
id|dins
)braket
dot
id|vcn
op_plus
id|drl
(braket
id|dins
)braket
dot
id|length
)paren
op_le
multiline_comment|/* End of hole   */
(paren
id|srl
(braket
id|send
op_minus
l_int|1
)braket
dot
id|vcn
op_plus
id|srl
(braket
id|send
op_minus
l_int|1
)braket
dot
id|length
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/* Or we&squot;ll lose an end marker */
r_if
c_cond
(paren
id|start
op_logical_and
id|finish
op_logical_and
(paren
id|drl
(braket
id|dins
)braket
dot
id|length
op_eq
l_int|0
)paren
)paren
id|ss
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|marker
op_logical_and
(paren
id|drl
(braket
id|dins
)braket
dot
id|vcn
op_plus
id|drl
(braket
id|dins
)braket
dot
id|length
OG
id|srl
(braket
id|send
op_minus
l_int|1
)braket
dot
id|vcn
)paren
)paren
id|finish
op_assign
id|FALSE
suffix:semicolon
macro_line|#if 0
id|ntfs_debug
c_func
(paren
l_string|&quot;dfinal = %i, dend = %i&quot;
comma
id|dfinal
comma
id|dend
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;sstart = %i, sfinal = %i, send = %i&quot;
comma
id|sstart
comma
id|sfinal
comma
id|send
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;start = %i, finish = %i&quot;
comma
id|start
comma
id|finish
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;ds = %i, ss = %i, dins = %i&quot;
comma
id|ds
comma
id|ss
comma
id|dins
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|start
)paren
(brace
r_if
c_cond
(paren
id|finish
)paren
id|drl
op_assign
id|ntfs_rl_replace
c_func
(paren
id|drl
comma
id|ds
comma
id|srl
op_plus
id|sstart
comma
id|ss
comma
id|dins
)paren
suffix:semicolon
r_else
id|drl
op_assign
id|ntfs_rl_insert
c_func
(paren
id|drl
comma
id|ds
comma
id|srl
op_plus
id|sstart
comma
id|ss
comma
id|dins
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|finish
)paren
id|drl
op_assign
id|ntfs_rl_append
c_func
(paren
id|drl
comma
id|ds
comma
id|srl
op_plus
id|sstart
comma
id|ss
comma
id|dins
)paren
suffix:semicolon
r_else
id|drl
op_assign
id|ntfs_rl_split
c_func
(paren
id|drl
comma
id|ds
comma
id|srl
op_plus
id|sstart
comma
id|ss
comma
id|dins
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|drl
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
l_int|NULL
comma
l_string|&quot;Merge failed.&quot;
)paren
suffix:semicolon
r_return
id|drl
suffix:semicolon
)brace
id|ntfs_free
c_func
(paren
id|srl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|marker
)paren
(brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Triggering marker code.&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|ds
op_assign
id|dend
suffix:semicolon
id|drl
(braket
id|ds
)braket
dot
id|length
suffix:semicolon
id|ds
op_increment
)paren
suffix:semicolon
multiline_comment|/* We only need to care if @srl ended after @drl. */
r_if
c_cond
(paren
id|drl
(braket
id|ds
)braket
dot
id|vcn
op_le
id|marker_vcn
)paren
(brace
r_int
id|slots
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|drl
(braket
id|ds
)braket
dot
id|vcn
op_eq
id|marker_vcn
)paren
(brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Old marker = 0x%llx, replacing &quot;
l_string|&quot;with LCN_ENOENT.&quot;
comma
(paren
r_int
r_int
r_int
)paren
id|drl
(braket
id|ds
)braket
dot
id|lcn
)paren
suffix:semicolon
id|drl
(braket
id|ds
)braket
dot
id|lcn
op_assign
id|LCN_ENOENT
suffix:semicolon
r_goto
id|finished
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * We need to create an unmapped runlist element in&n;&t;&t;&t; * @drl or extend an existing one before adding the&n;&t;&t;&t; * ENOENT terminator.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|drl
(braket
id|ds
)braket
dot
id|lcn
op_eq
id|LCN_ENOENT
)paren
(brace
id|ds
op_decrement
suffix:semicolon
id|slots
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|drl
(braket
id|ds
)braket
dot
id|lcn
op_ne
id|LCN_RL_NOT_MAPPED
)paren
(brace
multiline_comment|/* Add an unmapped runlist element. */
r_if
c_cond
(paren
op_logical_neg
id|slots
)paren
(brace
multiline_comment|/* FIXME/TODO: We need to have the&n;&t;&t;&t;&t;&t; * extra memory already! (AIA) */
id|drl
op_assign
id|ntfs_rl_realloc
c_func
(paren
id|drl
comma
id|ds
comma
id|ds
op_plus
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|drl
)paren
r_goto
id|critical_error
suffix:semicolon
id|slots
op_assign
l_int|2
suffix:semicolon
)brace
id|ds
op_increment
suffix:semicolon
multiline_comment|/* Need to set vcn if it isn&squot;t set already. */
r_if
c_cond
(paren
id|slots
op_ne
l_int|1
)paren
id|drl
(braket
id|ds
)braket
dot
id|vcn
op_assign
id|drl
(braket
id|ds
op_minus
l_int|1
)braket
dot
id|vcn
op_plus
id|drl
(braket
id|ds
op_minus
l_int|1
)braket
dot
id|length
suffix:semicolon
id|drl
(braket
id|ds
)braket
dot
id|lcn
op_assign
id|LCN_RL_NOT_MAPPED
suffix:semicolon
multiline_comment|/* We now used up a slot. */
id|slots
op_decrement
suffix:semicolon
)brace
id|drl
(braket
id|ds
)braket
dot
id|length
op_assign
id|marker_vcn
op_minus
id|drl
(braket
id|ds
)braket
dot
id|vcn
suffix:semicolon
multiline_comment|/* Finally add the ENOENT terminator. */
id|ds
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|slots
)paren
(brace
multiline_comment|/* FIXME/TODO: We need to have the extra&n;&t;&t;&t;&t; * memory already! (AIA) */
id|drl
op_assign
id|ntfs_rl_realloc
c_func
(paren
id|drl
comma
id|ds
comma
id|ds
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|drl
)paren
r_goto
id|critical_error
suffix:semicolon
)brace
id|drl
(braket
id|ds
)braket
dot
id|vcn
op_assign
id|marker_vcn
suffix:semicolon
id|drl
(braket
id|ds
)braket
dot
id|lcn
op_assign
id|LCN_ENOENT
suffix:semicolon
id|drl
(braket
id|ds
)braket
dot
id|length
op_assign
(paren
id|s64
)paren
l_int|0
suffix:semicolon
)brace
)brace
)brace
id|finished
suffix:colon
multiline_comment|/* The merge was completed successfully. */
id|ntfs_debug
c_func
(paren
l_string|&quot;Merged runlist:&quot;
)paren
suffix:semicolon
id|ntfs_debug_dump_runlist
c_func
(paren
id|drl
)paren
suffix:semicolon
r_return
id|drl
suffix:semicolon
id|critical_error
suffix:colon
multiline_comment|/* Critical error! We cannot afford to fail here. */
id|ntfs_error
c_func
(paren
l_int|NULL
comma
l_string|&quot;Critical error! Not enough memory.&quot;
)paren
suffix:semicolon
id|panic
c_func
(paren
l_string|&quot;NTFS: Cannot continue.&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_mapping_pairs_decompress - convert mapping pairs array to runlist&n; * @vol:&t;ntfs volume on which the attribute resides&n; * @attr:&t;attribute record whose mapping pairs array to decompress&n; * @old_rl:&t;optional runlist in which to insert @attr&squot;s runlist&n; *&n; * It is up to the caller to serialize access to the runlist @old_rl.&n; *&n; * Decompress the attribute @attr&squot;s mapping pairs array into a runlist. On&n; * success, return the decompressed runlist.&n; *&n; * If @old_rl is not NULL, decompressed runlist is inserted into the&n; * appropriate place in @old_rl and the resultant, combined runlist is&n; * returned. The original @old_rl is deallocated.&n; *&n; * On error, return -errno. @old_rl is left unmodified in that case.&n; *&n; * The following error codes are defined:&n; *&t;-ENOMEM&t;- Not enough memory to allocate runlist array.&n; *&t;-EIO&t;- Corrupt runlist.&n; *&t;-EINVAL&t;- Invalid parameters were passed in.&n; *&t;-ERANGE&t;- The two runlists overlap.&n; *&n; * FIXME: For now we take the conceptionally simplest approach of creating the&n; * new runlist disregarding the already existing one and then splicing the&n; * two into one, if that is possible (we check for overlap and discard the new&n; * runlist if overlap present before returning ERR_PTR(-ERANGE)).&n; */
DECL|function|ntfs_mapping_pairs_decompress
id|runlist_element
op_star
id|ntfs_mapping_pairs_decompress
c_func
(paren
r_const
id|ntfs_volume
op_star
id|vol
comma
r_const
id|ATTR_RECORD
op_star
id|attr
comma
id|runlist_element
op_star
id|old_rl
)paren
(brace
id|VCN
id|vcn
suffix:semicolon
multiline_comment|/* Current vcn. */
id|LCN
id|lcn
suffix:semicolon
multiline_comment|/* Current lcn. */
id|s64
id|deltaxcn
suffix:semicolon
multiline_comment|/* Change in [vl]cn. */
id|runlist_element
op_star
id|rl
suffix:semicolon
multiline_comment|/* The output runlist. */
id|u8
op_star
id|buf
suffix:semicolon
multiline_comment|/* Current position in mapping pairs array. */
id|u8
op_star
id|attr_end
suffix:semicolon
multiline_comment|/* End of attribute. */
r_int
id|rlsize
suffix:semicolon
multiline_comment|/* Size of runlist buffer. */
id|u16
id|rlpos
suffix:semicolon
multiline_comment|/* Current runlist position in units of&n;&t;&t;&t;&t;   runlist_elements. */
id|u8
id|b
suffix:semicolon
multiline_comment|/* Current byte offset in buf. */
macro_line|#ifdef DEBUG
multiline_comment|/* Make sure attr exists and is non-resident. */
r_if
c_cond
(paren
op_logical_neg
id|attr
op_logical_or
op_logical_neg
id|attr-&gt;non_resident
op_logical_or
id|sle64_to_cpu
c_func
(paren
id|attr-&gt;data.non_resident.lowest_vcn
)paren
OL
(paren
id|VCN
)paren
l_int|0
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Invalid arguments.&quot;
)paren
suffix:semicolon
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* Start at vcn = lowest_vcn and lcn 0. */
id|vcn
op_assign
id|sle64_to_cpu
c_func
(paren
id|attr-&gt;data.non_resident.lowest_vcn
)paren
suffix:semicolon
id|lcn
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Get start of the mapping pairs array. */
id|buf
op_assign
(paren
id|u8
op_star
)paren
id|attr
op_plus
id|le16_to_cpu
c_func
(paren
id|attr-&gt;data.non_resident.mapping_pairs_offset
)paren
suffix:semicolon
id|attr_end
op_assign
(paren
id|u8
op_star
)paren
id|attr
op_plus
id|le32_to_cpu
c_func
(paren
id|attr-&gt;length
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|buf
template_param
id|attr_end
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Corrupt attribute.&quot;
)paren
suffix:semicolon
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|EIO
)paren
suffix:semicolon
)brace
multiline_comment|/* Current position in runlist array. */
id|rlpos
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Allocate first page and set current runlist size to one page. */
id|rl
op_assign
id|ntfs_malloc_nofs
c_func
(paren
id|rlsize
op_assign
id|PAGE_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|rl
)paren
)paren
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
multiline_comment|/* Insert unmapped starting element if necessary. */
r_if
c_cond
(paren
id|vcn
)paren
(brace
id|rl-&gt;vcn
op_assign
l_int|0
suffix:semicolon
id|rl-&gt;lcn
op_assign
id|LCN_RL_NOT_MAPPED
suffix:semicolon
id|rl-&gt;length
op_assign
id|vcn
suffix:semicolon
id|rlpos
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
id|buf
OL
id|attr_end
op_logical_and
op_star
id|buf
)paren
(brace
multiline_comment|/*&n;&t;&t; * Allocate more memory if needed, including space for the&n;&t;&t; * not-mapped and terminator elements. ntfs_malloc_nofs()&n;&t;&t; * operates on whole pages only.&n;&t;&t; */
r_if
c_cond
(paren
(paren
(paren
id|rlpos
op_plus
l_int|3
)paren
op_star
r_sizeof
(paren
op_star
id|old_rl
)paren
)paren
OG
id|rlsize
)paren
(brace
id|runlist_element
op_star
id|rl2
suffix:semicolon
id|rl2
op_assign
id|ntfs_malloc_nofs
c_func
(paren
id|rlsize
op_plus
(paren
r_int
)paren
id|PAGE_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|rl2
)paren
)paren
(brace
id|ntfs_free
c_func
(paren
id|rl
)paren
suffix:semicolon
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|rl2
comma
id|rl
comma
id|rlsize
)paren
suffix:semicolon
id|ntfs_free
c_func
(paren
id|rl
)paren
suffix:semicolon
id|rl
op_assign
id|rl2
suffix:semicolon
id|rlsize
op_add_assign
id|PAGE_SIZE
suffix:semicolon
)brace
multiline_comment|/* Enter the current vcn into the current runlist element. */
id|rl
(braket
id|rlpos
)braket
dot
id|vcn
op_assign
id|vcn
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Get the change in vcn, i.e. the run length in clusters.&n;&t;&t; * Doing it this way ensures that we signextend negative values.&n;&t;&t; * A negative run length doesn&squot;t make any sense, but hey, I&n;&t;&t; * didn&squot;t make up the NTFS specs and Windows NT4 treats the run&n;&t;&t; * length as a signed value so that&squot;s how it is...&n;&t;&t; */
id|b
op_assign
op_star
id|buf
op_amp
l_int|0xf
suffix:semicolon
r_if
c_cond
(paren
id|b
)paren
(brace
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|buf
op_plus
id|b
OG
id|attr_end
)paren
)paren
r_goto
id|io_error
suffix:semicolon
r_for
c_loop
(paren
id|deltaxcn
op_assign
(paren
id|s8
)paren
id|buf
(braket
id|b
op_decrement
)braket
suffix:semicolon
id|b
suffix:semicolon
id|b
op_decrement
)paren
id|deltaxcn
op_assign
(paren
id|deltaxcn
op_lshift
l_int|8
)paren
op_plus
id|buf
(braket
id|b
)braket
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* The length entry is compulsory. */
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Missing length entry in mapping &quot;
l_string|&quot;pairs array.&quot;
)paren
suffix:semicolon
id|deltaxcn
op_assign
(paren
id|s64
)paren
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Assume a negative length to indicate data corruption and&n;&t;&t; * hence clean-up and return NULL.&n;&t;&t; */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|deltaxcn
OL
l_int|0
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Invalid length in mapping pairs &quot;
l_string|&quot;array.&quot;
)paren
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Enter the current run length into the current runlist&n;&t;&t; * element.&n;&t;&t; */
id|rl
(braket
id|rlpos
)braket
dot
id|length
op_assign
id|deltaxcn
suffix:semicolon
multiline_comment|/* Increment the current vcn by the current run length. */
id|vcn
op_add_assign
id|deltaxcn
suffix:semicolon
multiline_comment|/*&n;&t;&t; * There might be no lcn change at all, as is the case for&n;&t;&t; * sparse clusters on NTFS 3.0+, in which case we set the lcn&n;&t;&t; * to LCN_HOLE.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
op_star
id|buf
op_amp
l_int|0xf0
)paren
)paren
id|rl
(braket
id|rlpos
)braket
dot
id|lcn
op_assign
id|LCN_HOLE
suffix:semicolon
r_else
(brace
multiline_comment|/* Get the lcn change which really can be negative. */
id|u8
id|b2
op_assign
op_star
id|buf
op_amp
l_int|0xf
suffix:semicolon
id|b
op_assign
id|b2
op_plus
(paren
(paren
op_star
id|buf
op_rshift
l_int|4
)paren
op_amp
l_int|0xf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buf
op_plus
id|b
OG
id|attr_end
)paren
r_goto
id|io_error
suffix:semicolon
r_for
c_loop
(paren
id|deltaxcn
op_assign
(paren
id|s8
)paren
id|buf
(braket
id|b
op_decrement
)braket
suffix:semicolon
id|b
OG
id|b2
suffix:semicolon
id|b
op_decrement
)paren
id|deltaxcn
op_assign
(paren
id|deltaxcn
op_lshift
l_int|8
)paren
op_plus
id|buf
(braket
id|b
)braket
suffix:semicolon
multiline_comment|/* Change the current lcn to its new value. */
id|lcn
op_add_assign
id|deltaxcn
suffix:semicolon
macro_line|#ifdef DEBUG
multiline_comment|/*&n;&t;&t;&t; * On NTFS 1.2-, apparently can have lcn == -1 to&n;&t;&t;&t; * indicate a hole. But we haven&squot;t verified ourselves&n;&t;&t;&t; * whether it is really the lcn or the deltaxcn that is&n;&t;&t;&t; * -1. So if either is found give us a message so we&n;&t;&t;&t; * can investigate it further!&n;&t;&t;&t; */
r_if
c_cond
(paren
id|vol-&gt;major_ver
OL
l_int|3
)paren
(brace
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|deltaxcn
op_eq
(paren
id|LCN
)paren
op_minus
l_int|1
)paren
)paren
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;lcn delta == -1&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|lcn
op_eq
(paren
id|LCN
)paren
op_minus
l_int|1
)paren
)paren
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;lcn == -1&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* Check lcn is not below -1. */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|lcn
OL
(paren
id|LCN
)paren
op_minus
l_int|1
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Invalid LCN &lt; -1 in &quot;
l_string|&quot;mapping pairs array.&quot;
)paren
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
multiline_comment|/* Enter the current lcn into the runlist element. */
id|rl
(braket
id|rlpos
)braket
dot
id|lcn
op_assign
id|lcn
suffix:semicolon
)brace
multiline_comment|/* Get to the next runlist element. */
id|rlpos
op_increment
suffix:semicolon
multiline_comment|/* Increment the buffer position to the next mapping pair. */
id|buf
op_add_assign
(paren
op_star
id|buf
op_amp
l_int|0xf
)paren
op_plus
(paren
(paren
op_star
id|buf
op_rshift
l_int|4
)paren
op_amp
l_int|0xf
)paren
op_plus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|buf
op_ge
id|attr_end
)paren
)paren
r_goto
id|io_error
suffix:semicolon
multiline_comment|/*&n;&t; * If there is a highest_vcn specified, it must be equal to the final&n;&t; * vcn in the runlist - 1, or something has gone badly wrong.&n;&t; */
id|deltaxcn
op_assign
id|sle64_to_cpu
c_func
(paren
id|attr-&gt;data.non_resident.highest_vcn
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|deltaxcn
op_logical_and
id|vcn
op_minus
l_int|1
op_ne
id|deltaxcn
)paren
)paren
(brace
id|mpa_err
suffix:colon
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Corrupt mapping pairs array in &quot;
l_string|&quot;non-resident attribute.&quot;
)paren
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
multiline_comment|/* Setup not mapped runlist element if this is the base extent. */
r_if
c_cond
(paren
op_logical_neg
id|attr-&gt;data.non_resident.lowest_vcn
)paren
(brace
id|VCN
id|max_cluster
suffix:semicolon
id|max_cluster
op_assign
(paren
id|sle64_to_cpu
c_func
(paren
id|attr-&gt;data.non_resident.allocated_size
)paren
op_plus
id|vol-&gt;cluster_size
op_minus
l_int|1
)paren
op_rshift
id|vol-&gt;cluster_size_bits
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If there is a difference between the highest_vcn and the&n;&t;&t; * highest cluster, the runlist is either corrupt or, more&n;&t;&t; * likely, there are more extents following this one.&n;&t;&t; */
r_if
c_cond
(paren
id|deltaxcn
OL
op_decrement
id|max_cluster
)paren
(brace
id|ntfs_debug
c_func
(paren
l_string|&quot;More extents to follow; deltaxcn = 0x%llx, &quot;
l_string|&quot;max_cluster = 0x%llx&quot;
comma
(paren
r_int
r_int
r_int
)paren
id|deltaxcn
comma
(paren
r_int
r_int
r_int
)paren
id|max_cluster
)paren
suffix:semicolon
id|rl
(braket
id|rlpos
)braket
dot
id|vcn
op_assign
id|vcn
suffix:semicolon
id|vcn
op_add_assign
id|rl
(braket
id|rlpos
)braket
dot
id|length
op_assign
id|max_cluster
op_minus
id|deltaxcn
suffix:semicolon
id|rl
(braket
id|rlpos
)braket
dot
id|lcn
op_assign
id|LCN_RL_NOT_MAPPED
suffix:semicolon
id|rlpos
op_increment
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|deltaxcn
OG
id|max_cluster
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Corrupt attribute. deltaxcn = &quot;
l_string|&quot;0x%llx, max_cluster = 0x%llx&quot;
comma
(paren
r_int
r_int
r_int
)paren
id|deltaxcn
comma
(paren
r_int
r_int
r_int
)paren
id|max_cluster
)paren
suffix:semicolon
r_goto
id|mpa_err
suffix:semicolon
)brace
id|rl
(braket
id|rlpos
)braket
dot
id|lcn
op_assign
id|LCN_ENOENT
suffix:semicolon
)brace
r_else
multiline_comment|/* Not the base extent. There may be more extents to follow. */
id|rl
(braket
id|rlpos
)braket
dot
id|lcn
op_assign
id|LCN_RL_NOT_MAPPED
suffix:semicolon
multiline_comment|/* Setup terminating runlist element. */
id|rl
(braket
id|rlpos
)braket
dot
id|vcn
op_assign
id|vcn
suffix:semicolon
id|rl
(braket
id|rlpos
)braket
dot
id|length
op_assign
(paren
id|s64
)paren
l_int|0
suffix:semicolon
multiline_comment|/* If no existing runlist was specified, we are done. */
r_if
c_cond
(paren
op_logical_neg
id|old_rl
)paren
(brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Mapping pairs array successfully decompressed:&quot;
)paren
suffix:semicolon
id|ntfs_debug_dump_runlist
c_func
(paren
id|rl
)paren
suffix:semicolon
r_return
id|rl
suffix:semicolon
)brace
multiline_comment|/* Now combine the new and old runlists checking for overlaps. */
id|old_rl
op_assign
id|ntfs_runlists_merge
c_func
(paren
id|old_rl
comma
id|rl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
op_logical_neg
id|IS_ERR
c_func
(paren
id|old_rl
)paren
)paren
)paren
r_return
id|old_rl
suffix:semicolon
id|ntfs_free
c_func
(paren
id|rl
)paren
suffix:semicolon
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Failed to merge runlists.&quot;
)paren
suffix:semicolon
r_return
id|old_rl
suffix:semicolon
id|io_error
suffix:colon
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Corrupt attribute.&quot;
)paren
suffix:semicolon
id|err_out
suffix:colon
id|ntfs_free
c_func
(paren
id|rl
)paren
suffix:semicolon
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|EIO
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_rl_vcn_to_lcn - convert a vcn into a lcn given a runlist&n; * @rl:&t;&t;runlist to use for conversion&n; * @vcn:&t;vcn to convert&n; *&n; * Convert the virtual cluster number @vcn of an attribute into a logical&n; * cluster number (lcn) of a device using the runlist @rl to map vcns to their&n; * corresponding lcns.&n; *&n; * It is up to the caller to serialize access to the runlist @rl.&n; *&n; * Since lcns must be &gt;= 0, we use negative return values with special meaning:&n; *&n; * Return value&t;&t;&t;Meaning / Description&n; * ==================================================&n; *  -1 = LCN_HOLE&t;&t;Hole / not allocated on disk.&n; *  -2 = LCN_RL_NOT_MAPPED&t;This is part of the runlist which has not been&n; *&t;&t;&t;&t;inserted into the runlist yet.&n; *  -3 = LCN_ENOENT&t;&t;There is no such vcn in the attribute.&n; *&n; * Locking: - The caller must have locked the runlist (for reading or writing).&n; *&t;    - This function does not touch the lock.&n; */
DECL|function|ntfs_rl_vcn_to_lcn
id|LCN
id|ntfs_rl_vcn_to_lcn
c_func
(paren
r_const
id|runlist_element
op_star
id|rl
comma
r_const
id|VCN
id|vcn
)paren
(brace
r_int
id|i
suffix:semicolon
id|BUG_ON
c_func
(paren
id|vcn
OL
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If rl is NULL, assume that we have found an unmapped runlist. The&n;&t; * caller can then attempt to map it and fail appropriately if&n;&t; * necessary.&n;&t; */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|rl
)paren
)paren
r_return
id|LCN_RL_NOT_MAPPED
suffix:semicolon
multiline_comment|/* Catch out of lower bounds vcn. */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|vcn
OL
id|rl
(braket
l_int|0
)braket
dot
id|vcn
)paren
)paren
r_return
id|LCN_ENOENT
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|likely
c_func
(paren
id|rl
(braket
id|i
)braket
dot
id|length
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|vcn
OL
id|rl
(braket
id|i
op_plus
l_int|1
)braket
dot
id|vcn
)paren
)paren
(brace
r_if
c_cond
(paren
id|likely
c_func
(paren
id|rl
(braket
id|i
)braket
dot
id|lcn
op_ge
(paren
id|LCN
)paren
l_int|0
)paren
)paren
r_return
id|rl
(braket
id|i
)braket
dot
id|lcn
op_plus
(paren
id|vcn
op_minus
id|rl
(braket
id|i
)braket
dot
id|vcn
)paren
suffix:semicolon
r_return
id|rl
(braket
id|i
)braket
dot
id|lcn
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * The terminator element is setup to the correct value, i.e. one of&n;&t; * LCN_HOLE, LCN_RL_NOT_MAPPED, or LCN_ENOENT.&n;&t; */
r_if
c_cond
(paren
id|likely
c_func
(paren
id|rl
(braket
id|i
)braket
dot
id|lcn
OL
(paren
id|LCN
)paren
l_int|0
)paren
)paren
r_return
id|rl
(braket
id|i
)braket
dot
id|lcn
suffix:semicolon
multiline_comment|/* Just in case... We could replace this with BUG() some day. */
r_return
id|LCN_ENOENT
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_get_nr_significant_bytes - get number of bytes needed to store a number&n; * @n:&t;&t;number for which to get the number of bytes for&n; *&n; * Return the number of bytes required to store @n unambiguously as&n; * a signed number.&n; *&n; * This is used in the context of the mapping pairs array to determine how&n; * many bytes will be needed in the array to store a given logical cluster&n; * number (lcn) or a specific run length.&n; *&n; * Return the number of bytes written.  This function cannot fail.&n; */
DECL|function|ntfs_get_nr_significant_bytes
r_static
r_inline
r_int
id|ntfs_get_nr_significant_bytes
c_func
(paren
r_const
id|s64
id|n
)paren
(brace
id|s64
id|l
op_assign
id|n
suffix:semicolon
r_int
id|i
suffix:semicolon
id|s8
id|j
suffix:semicolon
id|i
op_assign
l_int|0
suffix:semicolon
r_do
(brace
id|l
op_rshift_assign
l_int|8
suffix:semicolon
id|i
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
id|l
op_ne
l_int|0
op_logical_and
id|l
op_ne
op_minus
l_int|1
)paren
suffix:semicolon
id|j
op_assign
(paren
id|n
op_rshift
l_int|8
op_star
(paren
id|i
op_minus
l_int|1
)paren
)paren
op_amp
l_int|0xff
suffix:semicolon
multiline_comment|/* If the sign bit is wrong, we need an extra byte. */
r_if
c_cond
(paren
(paren
id|n
OL
l_int|0
op_logical_and
id|j
op_ge
l_int|0
)paren
op_logical_or
(paren
id|n
OG
l_int|0
op_logical_and
id|j
OL
l_int|0
)paren
)paren
id|i
op_increment
suffix:semicolon
r_return
id|i
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_get_size_for_mapping_pairs - get bytes needed for mapping pairs array&n; * @vol:&t;ntfs volume (needed for the ntfs version)&n; * @rl:&t;&t;locked runlist to determine the size of the mapping pairs of&n; * @start_vcn:&t;vcn at which to start the mapping pairs array&n; *&n; * Walk the locked runlist @rl and calculate the size in bytes of the mapping&n; * pairs array corresponding to the runlist @rl, starting at vcn @start_vcn.&n; * This for example allows us to allocate a buffer of the right size when&n; * building the mapping pairs array.&n; *&n; * If @rl is NULL, just return 1 (for the single terminator byte).&n; *&n; * Return the calculated size in bytes on success.  On error, return -errno.&n; * The following error codes are defined:&n; *&t;-EINVAL&t;- Run list contains unmapped elements.  Make sure to only pass&n; *&t;&t;  fully mapped runlists to this function.&n; *&t;-EIO&t;- The runlist is corrupt.&n; *&n; * Locking: @rl must be locked on entry (either for reading or writing), it&n; *&t;    remains locked throughout, and is left locked upon return.&n; */
DECL|function|ntfs_get_size_for_mapping_pairs
r_int
id|ntfs_get_size_for_mapping_pairs
c_func
(paren
r_const
id|ntfs_volume
op_star
id|vol
comma
r_const
id|runlist_element
op_star
id|rl
comma
r_const
id|VCN
id|start_vcn
)paren
(brace
id|LCN
id|prev_lcn
suffix:semicolon
r_int
id|rls
suffix:semicolon
id|BUG_ON
c_func
(paren
id|start_vcn
OL
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rl
)paren
(brace
id|BUG_ON
c_func
(paren
id|start_vcn
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Skip to runlist element containing @start_vcn. */
r_while
c_loop
(paren
id|rl-&gt;length
op_logical_and
id|start_vcn
op_ge
id|rl
(braket
l_int|1
)braket
dot
id|vcn
)paren
id|rl
op_increment
suffix:semicolon
r_if
c_cond
(paren
(paren
op_logical_neg
id|rl-&gt;length
op_logical_and
id|start_vcn
OG
id|rl-&gt;vcn
)paren
op_logical_or
id|start_vcn
OL
id|rl-&gt;vcn
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|prev_lcn
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Always need the termining zero byte. */
id|rls
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Do the first partial run if present. */
r_if
c_cond
(paren
id|start_vcn
OG
id|rl-&gt;vcn
)paren
(brace
id|s64
id|delta
suffix:semicolon
multiline_comment|/* We know rl-&gt;length != 0 already. */
r_if
c_cond
(paren
id|rl-&gt;length
OL
l_int|0
op_logical_or
id|rl-&gt;lcn
OL
id|LCN_HOLE
)paren
r_goto
id|err_out
suffix:semicolon
id|delta
op_assign
id|start_vcn
op_minus
id|rl-&gt;vcn
suffix:semicolon
multiline_comment|/* Header byte + length. */
id|rls
op_add_assign
l_int|1
op_plus
id|ntfs_get_nr_significant_bytes
c_func
(paren
id|rl-&gt;length
op_minus
id|delta
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If the logical cluster number (lcn) denotes a hole and we&n;&t;&t; * are on NTFS 3.0+, we don&squot;t store it at all, i.e. we need&n;&t;&t; * zero space.  On earlier NTFS versions we just store the lcn.&n;&t;&t; * Note: this assumes that on NTFS 1.2-, holes are stored with&n;&t;&t; * an lcn of -1 and not a delta_lcn of -1 (unless both are -1).&n;&t;&t; */
r_if
c_cond
(paren
id|rl-&gt;lcn
op_ge
l_int|0
op_logical_or
id|vol-&gt;major_ver
OL
l_int|3
)paren
(brace
id|prev_lcn
op_assign
id|rl-&gt;lcn
suffix:semicolon
r_if
c_cond
(paren
id|rl-&gt;lcn
op_ge
l_int|0
)paren
id|prev_lcn
op_add_assign
id|delta
suffix:semicolon
multiline_comment|/* Change in lcn. */
id|rls
op_add_assign
id|ntfs_get_nr_significant_bytes
c_func
(paren
id|prev_lcn
)paren
suffix:semicolon
)brace
multiline_comment|/* Go to next runlist element. */
id|rl
op_increment
suffix:semicolon
)brace
multiline_comment|/* Do the full runs. */
r_for
c_loop
(paren
suffix:semicolon
id|rl-&gt;length
suffix:semicolon
id|rl
op_increment
)paren
(brace
r_if
c_cond
(paren
id|rl-&gt;length
OL
l_int|0
op_logical_or
id|rl-&gt;lcn
OL
id|LCN_HOLE
)paren
r_goto
id|err_out
suffix:semicolon
multiline_comment|/* Header byte + length. */
id|rls
op_add_assign
l_int|1
op_plus
id|ntfs_get_nr_significant_bytes
c_func
(paren
id|rl-&gt;length
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If the logical cluster number (lcn) denotes a hole and we&n;&t;&t; * are on NTFS 3.0+, we don&squot;t store it at all, i.e. we need&n;&t;&t; * zero space.  On earlier NTFS versions we just store the lcn.&n;&t;&t; * Note: this assumes that on NTFS 1.2-, holes are stored with&n;&t;&t; * an lcn of -1 and not a delta_lcn of -1 (unless both are -1).&n;&t;&t; */
r_if
c_cond
(paren
id|rl-&gt;lcn
op_ge
l_int|0
op_logical_or
id|vol-&gt;major_ver
OL
l_int|3
)paren
(brace
multiline_comment|/* Change in lcn. */
id|rls
op_add_assign
id|ntfs_get_nr_significant_bytes
c_func
(paren
id|rl-&gt;lcn
op_minus
id|prev_lcn
)paren
suffix:semicolon
id|prev_lcn
op_assign
id|rl-&gt;lcn
suffix:semicolon
)brace
)brace
r_return
id|rls
suffix:semicolon
id|err_out
suffix:colon
r_if
c_cond
(paren
id|rl-&gt;lcn
op_eq
id|LCN_RL_NOT_MAPPED
)paren
id|rls
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_else
id|rls
op_assign
op_minus
id|EIO
suffix:semicolon
r_return
id|rls
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_write_significant_bytes - write the significant bytes of a number&n; * @dst:&t;destination buffer to write to&n; * @dst_max:&t;pointer to last byte of destination buffer for bounds checking&n; * @n:&t;&t;number whose significant bytes to write&n; *&n; * Store in @dst, the minimum bytes of the number @n which are required to&n; * identify @n unambiguously as a signed number, taking care not to exceed&n; * @dest_max, the maximum position within @dst to which we are allowed to&n; * write.&n; *&n; * This is used when building the mapping pairs array of a runlist to compress&n; * a given logical cluster number (lcn) or a specific run length to the minumum&n; * size possible.&n; *&n; * Return the number of bytes written on success.  On error, i.e. the&n; * destination buffer @dst is too small, return -ENOSPC.&n; */
DECL|function|ntfs_write_significant_bytes
r_static
r_inline
r_int
id|ntfs_write_significant_bytes
c_func
(paren
id|s8
op_star
id|dst
comma
r_const
id|s8
op_star
id|dst_max
comma
r_const
id|s64
id|n
)paren
(brace
id|s64
id|l
op_assign
id|n
suffix:semicolon
r_int
id|i
suffix:semicolon
id|s8
id|j
suffix:semicolon
id|i
op_assign
l_int|0
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|dst
OG
id|dst_max
)paren
r_goto
id|err_out
suffix:semicolon
op_star
id|dst
op_increment
op_assign
id|l
op_amp
l_int|0xffll
suffix:semicolon
id|l
op_rshift_assign
l_int|8
suffix:semicolon
id|i
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
id|l
op_ne
l_int|0
op_logical_and
id|l
op_ne
op_minus
l_int|1
)paren
suffix:semicolon
id|j
op_assign
(paren
id|n
op_rshift
l_int|8
op_star
(paren
id|i
op_minus
l_int|1
)paren
)paren
op_amp
l_int|0xff
suffix:semicolon
multiline_comment|/* If the sign bit is wrong, we need an extra byte. */
r_if
c_cond
(paren
id|n
OL
l_int|0
op_logical_and
id|j
op_ge
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|dst
OG
id|dst_max
)paren
r_goto
id|err_out
suffix:semicolon
id|i
op_increment
suffix:semicolon
op_star
id|dst
op_assign
(paren
id|s8
)paren
op_minus
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|n
OG
l_int|0
op_logical_and
id|j
OL
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|dst
OG
id|dst_max
)paren
r_goto
id|err_out
suffix:semicolon
id|i
op_increment
suffix:semicolon
op_star
id|dst
op_assign
(paren
id|s8
)paren
l_int|0
suffix:semicolon
)brace
r_return
id|i
suffix:semicolon
id|err_out
suffix:colon
r_return
op_minus
id|ENOSPC
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_mapping_pairs_build - build the mapping pairs array from a runlist&n; * @vol:&t;ntfs volume (needed for the ntfs version)&n; * @dst:&t;destination buffer to which to write the mapping pairs array&n; * @dst_len:&t;size of destination buffer @dst in bytes&n; * @rl:&t;&t;locked runlist for which to build the mapping pairs array&n; * @start_vcn:&t;vcn at which to start the mapping pairs array&n; * @stop_vcn:&t;first vcn outside destination buffer on success or -ENOSPC&n; *&n; * Create the mapping pairs array from the locked runlist @rl, starting at vcn&n; * @start_vcn and save the array in @dst.  @dst_len is the size of @dst in&n; * bytes and it should be at least equal to the value obtained by calling&n; * ntfs_get_size_for_mapping_pairs().&n; *&n; * If @rl is NULL, just write a single terminator byte to @dst.&n; *&n; * On success or -ENOSPC error, if @stop_vcn is not NULL, *@stop_vcn is set to&n; * the first vcn outside the destination buffer.  Note that on error, @dst has&n; * been filled with all the mapping pairs that will fit, thus it can be treated&n; * as partial success, in that a new attribute extent needs to be created or&n; * the next extent has to be used and the mapping pairs build has to be&n; * continued with @start_vcn set to *@stop_vcn.&n; *&n; * Return 0 on success and -errno on error.  The following error codes are&n; * defined:&n; *&t;-EINVAL&t;- Run list contains unmapped elements.  Make sure to only pass&n; *&t;&t;  fully mapped runlists to this function.&n; *&t;-EIO&t;- The runlist is corrupt.&n; *&t;-ENOSPC&t;- The destination buffer is too small.&n; *&n; * Locking: @rl must be locked on entry (either for reading or writing), it&n; *&t;    remains locked throughout, and is left locked upon return.&n; */
DECL|function|ntfs_mapping_pairs_build
r_int
id|ntfs_mapping_pairs_build
c_func
(paren
r_const
id|ntfs_volume
op_star
id|vol
comma
id|s8
op_star
id|dst
comma
r_const
r_int
id|dst_len
comma
r_const
id|runlist_element
op_star
id|rl
comma
r_const
id|VCN
id|start_vcn
comma
id|VCN
op_star
r_const
id|stop_vcn
)paren
(brace
id|LCN
id|prev_lcn
suffix:semicolon
id|s8
op_star
id|dst_max
comma
op_star
id|dst_next
suffix:semicolon
r_int
id|err
op_assign
op_minus
id|ENOSPC
suffix:semicolon
id|s8
id|len_len
comma
id|lcn_len
suffix:semicolon
id|BUG_ON
c_func
(paren
id|start_vcn
OL
l_int|0
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|dst_len
OL
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rl
)paren
(brace
id|BUG_ON
c_func
(paren
id|start_vcn
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stop_vcn
)paren
op_star
id|stop_vcn
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Terminator byte. */
op_star
id|dst
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Skip to runlist element containing @start_vcn. */
r_while
c_loop
(paren
id|rl-&gt;length
op_logical_and
id|start_vcn
op_ge
id|rl
(braket
l_int|1
)braket
dot
id|vcn
)paren
id|rl
op_increment
suffix:semicolon
r_if
c_cond
(paren
(paren
op_logical_neg
id|rl-&gt;length
op_logical_and
id|start_vcn
OG
id|rl-&gt;vcn
)paren
op_logical_or
id|start_vcn
OL
id|rl-&gt;vcn
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/*&n;&t; * @dst_max is used for bounds checking in&n;&t; * ntfs_write_significant_bytes().&n;&t; */
id|dst_max
op_assign
id|dst
op_plus
id|dst_len
op_minus
l_int|1
suffix:semicolon
id|prev_lcn
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Do the first partial run if present. */
r_if
c_cond
(paren
id|start_vcn
OG
id|rl-&gt;vcn
)paren
(brace
id|s64
id|delta
suffix:semicolon
multiline_comment|/* We know rl-&gt;length != 0 already. */
r_if
c_cond
(paren
id|rl-&gt;length
OL
l_int|0
op_logical_or
id|rl-&gt;lcn
OL
id|LCN_HOLE
)paren
r_goto
id|err_out
suffix:semicolon
id|delta
op_assign
id|start_vcn
op_minus
id|rl-&gt;vcn
suffix:semicolon
multiline_comment|/* Write length. */
id|len_len
op_assign
id|ntfs_write_significant_bytes
c_func
(paren
id|dst
op_plus
l_int|1
comma
id|dst_max
comma
id|rl-&gt;length
op_minus
id|delta
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len_len
OL
l_int|0
)paren
r_goto
id|size_err
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If the logical cluster number (lcn) denotes a hole and we&n;&t;&t; * are on NTFS 3.0+, we don&squot;t store it at all, i.e. we need&n;&t;&t; * zero space.  On earlier NTFS versions we just write the lcn&n;&t;&t; * change.  FIXME: Do we need to write the lcn change or just&n;&t;&t; * the lcn in that case?  Not sure as I have never seen this&n;&t;&t; * case on NT4. - We assume that we just need to write the lcn&n;&t;&t; * change until someone tells us otherwise... (AIA)&n;&t;&t; */
r_if
c_cond
(paren
id|rl-&gt;lcn
op_ge
l_int|0
op_logical_or
id|vol-&gt;major_ver
OL
l_int|3
)paren
(brace
id|prev_lcn
op_assign
id|rl-&gt;lcn
suffix:semicolon
r_if
c_cond
(paren
id|rl-&gt;lcn
op_ge
l_int|0
)paren
id|prev_lcn
op_add_assign
id|delta
suffix:semicolon
multiline_comment|/* Write change in lcn. */
id|lcn_len
op_assign
id|ntfs_write_significant_bytes
c_func
(paren
id|dst
op_plus
l_int|1
op_plus
id|len_len
comma
id|dst_max
comma
id|prev_lcn
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lcn_len
OL
l_int|0
)paren
r_goto
id|size_err
suffix:semicolon
)brace
r_else
id|lcn_len
op_assign
l_int|0
suffix:semicolon
id|dst_next
op_assign
id|dst
op_plus
id|len_len
op_plus
id|lcn_len
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|dst_next
OG
id|dst_max
)paren
r_goto
id|size_err
suffix:semicolon
multiline_comment|/* Update header byte. */
op_star
id|dst
op_assign
id|lcn_len
op_lshift
l_int|4
op_or
id|len_len
suffix:semicolon
multiline_comment|/* Position at next mapping pairs array element. */
id|dst
op_assign
id|dst_next
suffix:semicolon
multiline_comment|/* Go to next runlist element. */
id|rl
op_increment
suffix:semicolon
)brace
multiline_comment|/* Do the full runs. */
r_for
c_loop
(paren
suffix:semicolon
id|rl-&gt;length
suffix:semicolon
id|rl
op_increment
)paren
(brace
r_if
c_cond
(paren
id|rl-&gt;length
OL
l_int|0
op_logical_or
id|rl-&gt;lcn
OL
id|LCN_HOLE
)paren
r_goto
id|err_out
suffix:semicolon
multiline_comment|/* Write length. */
id|len_len
op_assign
id|ntfs_write_significant_bytes
c_func
(paren
id|dst
op_plus
l_int|1
comma
id|dst_max
comma
id|rl-&gt;length
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len_len
OL
l_int|0
)paren
r_goto
id|size_err
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If the logical cluster number (lcn) denotes a hole and we&n;&t;&t; * are on NTFS 3.0+, we don&squot;t store it at all, i.e. we need&n;&t;&t; * zero space.  On earlier NTFS versions we just write the lcn&n;&t;&t; * change.  FIXME: Do we need to write the lcn change or just&n;&t;&t; * the lcn in that case?  Not sure as I have never seen this&n;&t;&t; * case on NT4. - We assume that we just need to write the lcn&n;&t;&t; * change until someone tells us otherwise... (AIA)&n;&t;&t; */
r_if
c_cond
(paren
id|rl-&gt;lcn
op_ge
l_int|0
op_logical_or
id|vol-&gt;major_ver
OL
l_int|3
)paren
(brace
multiline_comment|/* Write change in lcn. */
id|lcn_len
op_assign
id|ntfs_write_significant_bytes
c_func
(paren
id|dst
op_plus
l_int|1
op_plus
id|len_len
comma
id|dst_max
comma
id|rl-&gt;lcn
op_minus
id|prev_lcn
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lcn_len
OL
l_int|0
)paren
r_goto
id|size_err
suffix:semicolon
id|prev_lcn
op_assign
id|rl-&gt;lcn
suffix:semicolon
)brace
r_else
id|lcn_len
op_assign
l_int|0
suffix:semicolon
id|dst_next
op_assign
id|dst
op_plus
id|len_len
op_plus
id|lcn_len
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|dst_next
OG
id|dst_max
)paren
r_goto
id|size_err
suffix:semicolon
multiline_comment|/* Update header byte. */
op_star
id|dst
op_assign
id|lcn_len
op_lshift
l_int|4
op_or
id|len_len
suffix:semicolon
multiline_comment|/* Position at next mapping pairs array element. */
id|dst
op_assign
id|dst_next
suffix:semicolon
)brace
multiline_comment|/* Success. */
id|err
op_assign
l_int|0
suffix:semicolon
id|size_err
suffix:colon
multiline_comment|/* Set stop vcn. */
r_if
c_cond
(paren
id|stop_vcn
)paren
op_star
id|stop_vcn
op_assign
id|rl-&gt;vcn
suffix:semicolon
multiline_comment|/* Add terminator byte. */
op_star
id|dst
op_assign
l_int|0
suffix:semicolon
r_return
id|err
suffix:semicolon
id|err_out
suffix:colon
r_if
c_cond
(paren
id|rl-&gt;lcn
op_eq
id|LCN_RL_NOT_MAPPED
)paren
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_else
id|err
op_assign
op_minus
id|EIO
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_rl_truncate_nolock - truncate a runlist starting at a specified vcn&n; * @runlist:&t;runlist to truncate&n; * @new_length:&t;the new length of the runlist in VCNs&n; *&n; * Truncate the runlist described by @runlist as well as the memory buffer&n; * holding the runlist elements to a length of @new_length VCNs.&n; *&n; * If @new_length lies within the runlist, the runlist elements with VCNs of&n; * @new_length and above are discarded.&n; *&n; * If @new_length lies beyond the runlist, a sparse runlist element is added to&n; * the end of the runlist @runlist or if the last runlist element is a sparse&n; * one already, this is extended.&n; *&n; * Return 0 on success and -errno on error.&n; *&n; * Locking: The caller must hold @runlist-&gt;lock for writing.&n; */
DECL|function|ntfs_rl_truncate_nolock
r_int
id|ntfs_rl_truncate_nolock
c_func
(paren
r_const
id|ntfs_volume
op_star
id|vol
comma
id|runlist
op_star
r_const
id|runlist
comma
r_const
id|s64
id|new_length
)paren
(brace
id|runlist_element
op_star
id|rl
suffix:semicolon
r_int
id|old_size
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Entering for new_length 0x%llx.&quot;
comma
(paren
r_int
r_int
)paren
id|new_length
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|runlist
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|new_length
OL
l_int|0
)paren
suffix:semicolon
id|rl
op_assign
id|runlist-&gt;rl
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|rl
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * Create a runlist consisting of a sparse runlist element of&n;&t;&t; * length @new_length followed by a terminator runlist element.&n;&t;&t; */
id|rl
op_assign
id|ntfs_malloc_nofs
c_func
(paren
id|PAGE_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|rl
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Not enough memory to allocate &quot;
l_string|&quot;runlist element buffer.&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|runlist-&gt;rl
op_assign
id|rl
suffix:semicolon
id|rl
(braket
l_int|1
)braket
dot
id|length
op_assign
id|rl-&gt;vcn
op_assign
l_int|0
suffix:semicolon
id|rl-&gt;lcn
op_assign
id|LCN_HOLE
suffix:semicolon
id|rl
(braket
l_int|1
)braket
dot
id|vcn
op_assign
id|rl-&gt;length
op_assign
id|new_length
suffix:semicolon
id|rl
(braket
l_int|1
)braket
dot
id|lcn
op_assign
id|LCN_ENOENT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|BUG_ON
c_func
(paren
id|new_length
OL
id|rl-&gt;vcn
)paren
suffix:semicolon
multiline_comment|/* Find @new_length in the runlist. */
r_while
c_loop
(paren
id|likely
c_func
(paren
id|rl-&gt;length
op_logical_and
id|new_length
op_ge
id|rl
(braket
l_int|1
)braket
dot
id|vcn
)paren
)paren
id|rl
op_increment
suffix:semicolon
multiline_comment|/*&n;&t; * If not at the end of the runlist we need to shrink it.&n;&t; * If at the end of the runlist we need to expand it.&n;&t; */
r_if
c_cond
(paren
id|rl-&gt;length
)paren
(brace
id|runlist_element
op_star
id|trl
suffix:semicolon
id|BOOL
id|is_end
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Shrinking runlist.&quot;
)paren
suffix:semicolon
multiline_comment|/* Determine the runlist size. */
id|trl
op_assign
id|rl
op_plus
l_int|1
suffix:semicolon
r_while
c_loop
(paren
id|likely
c_func
(paren
id|trl-&gt;length
)paren
)paren
id|trl
op_increment
suffix:semicolon
id|old_size
op_assign
id|trl
op_minus
id|runlist-&gt;rl
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* Truncate the run. */
id|rl-&gt;length
op_assign
id|new_length
op_minus
id|rl-&gt;vcn
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If a run was partially truncated, make the following runlist&n;&t;&t; * element a terminator.&n;&t;&t; */
id|is_end
op_assign
id|FALSE
suffix:semicolon
r_if
c_cond
(paren
id|rl-&gt;length
)paren
(brace
id|rl
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rl-&gt;length
)paren
id|is_end
op_assign
id|TRUE
suffix:semicolon
id|rl-&gt;vcn
op_assign
id|new_length
suffix:semicolon
id|rl-&gt;length
op_assign
l_int|0
suffix:semicolon
)brace
id|rl-&gt;lcn
op_assign
id|LCN_ENOENT
suffix:semicolon
multiline_comment|/* Reallocate memory if necessary. */
r_if
c_cond
(paren
op_logical_neg
id|is_end
)paren
(brace
r_int
id|new_size
op_assign
id|rl
op_minus
id|runlist-&gt;rl
op_plus
l_int|1
suffix:semicolon
id|rl
op_assign
id|ntfs_rl_realloc
c_func
(paren
id|runlist-&gt;rl
comma
id|old_size
comma
id|new_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|rl
)paren
)paren
id|ntfs_warning
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Failed to shrink &quot;
l_string|&quot;runlist buffer.  This just &quot;
l_string|&quot;wastes a bit of memory &quot;
l_string|&quot;temporarily so we ignore it &quot;
l_string|&quot;and return success.&quot;
)paren
suffix:semicolon
r_else
id|runlist-&gt;rl
op_assign
id|rl
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|likely
c_func
(paren
multiline_comment|/* !rl-&gt;length &amp;&amp; */
id|new_length
OG
id|rl-&gt;vcn
)paren
)paren
(brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Expanding runlist.&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If there is a previous runlist element and it is a sparse&n;&t;&t; * one, extend it.  Otherwise need to add a new, sparse runlist&n;&t;&t; * element.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|rl
OG
id|runlist-&gt;rl
)paren
op_logical_and
(paren
(paren
id|rl
op_minus
l_int|1
)paren
op_member_access_from_pointer
id|lcn
op_eq
id|LCN_HOLE
)paren
)paren
(paren
id|rl
op_minus
l_int|1
)paren
op_member_access_from_pointer
id|length
op_assign
id|new_length
op_minus
(paren
id|rl
op_minus
l_int|1
)paren
op_member_access_from_pointer
id|vcn
suffix:semicolon
r_else
(brace
multiline_comment|/* Determine the runlist size. */
id|old_size
op_assign
id|rl
op_minus
id|runlist-&gt;rl
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* Reallocate memory if necessary. */
id|rl
op_assign
id|ntfs_rl_realloc
c_func
(paren
id|runlist-&gt;rl
comma
id|old_size
comma
id|old_size
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|rl
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Failed to expand runlist &quot;
l_string|&quot;buffer, aborting.&quot;
)paren
suffix:semicolon
r_return
id|PTR_ERR
c_func
(paren
id|rl
)paren
suffix:semicolon
)brace
id|runlist-&gt;rl
op_assign
id|rl
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Set @rl to the same runlist element in the new&n;&t;&t;&t; * runlist as before in the old runlist.&n;&t;&t;&t; */
id|rl
op_add_assign
id|old_size
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* Add a new, sparse runlist element. */
id|rl-&gt;lcn
op_assign
id|LCN_HOLE
suffix:semicolon
id|rl-&gt;length
op_assign
id|new_length
op_minus
id|rl-&gt;vcn
suffix:semicolon
multiline_comment|/* Add a new terminator runlist element. */
id|rl
op_increment
suffix:semicolon
id|rl-&gt;length
op_assign
l_int|0
suffix:semicolon
)brace
id|rl-&gt;vcn
op_assign
id|new_length
suffix:semicolon
id|rl-&gt;lcn
op_assign
id|LCN_ENOENT
suffix:semicolon
)brace
r_else
multiline_comment|/* if (unlikely(!rl-&gt;length &amp;&amp; new_length == rl-&gt;vcn)) */
(brace
multiline_comment|/* Runlist already has same size as requested. */
id|rl-&gt;lcn
op_assign
id|LCN_ENOENT
suffix:semicolon
)brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Done.&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
eof
