multiline_comment|/**&n; * runlist.c - NTFS runlist handling code.  Part of the Linux-NTFS project.&n; *&n; * Copyright (c) 2001-2004 Anton Altaparmakov&n; * Copyright (c) 2002 Richard Russon&n; *&n; * This program/include file is free software; you can redistribute it and/or&n; * modify it under the terms of the GNU General Public License as published&n; * by the Free Software Foundation; either version 2 of the License, or&n; * (at your option) any later version.&n; *&n; * This program/include file is distributed in the hope that it will be&n; * useful, but WITHOUT ANY WARRANTY; without even the implied warranty&n; * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; * GNU General Public License for more details.&n; *&n; * You should have received a copy of the GNU General Public License&n; * along with this program (in the main directory of the Linux-NTFS&n; * distribution in the file COPYING); if not, write to the Free Software&n; * Foundation,Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA&n; */
macro_line|#include &quot;ntfs.h&quot;
macro_line|#include &quot;dir.h&quot;
multiline_comment|/**&n; * ntfs_rl_mm - runlist memmove&n; *&n; * It is up to the caller to serialize access to the runlist @base.&n; */
DECL|function|ntfs_rl_mm
r_static
r_inline
r_void
id|ntfs_rl_mm
c_func
(paren
id|runlist_element
op_star
id|base
comma
r_int
id|dst
comma
r_int
id|src
comma
r_int
id|size
)paren
(brace
r_if
c_cond
(paren
id|likely
c_func
(paren
(paren
id|dst
op_ne
id|src
)paren
op_logical_and
(paren
id|size
OG
l_int|0
)paren
)paren
)paren
id|memmove
c_func
(paren
id|base
op_plus
id|dst
comma
id|base
op_plus
id|src
comma
id|size
op_star
r_sizeof
(paren
op_star
id|base
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_rl_mc - runlist memory copy&n; *&n; * It is up to the caller to serialize access to the runlists @dstbase and&n; * @srcbase.&n; */
DECL|function|ntfs_rl_mc
r_static
r_inline
r_void
id|ntfs_rl_mc
c_func
(paren
id|runlist_element
op_star
id|dstbase
comma
r_int
id|dst
comma
id|runlist_element
op_star
id|srcbase
comma
r_int
id|src
comma
r_int
id|size
)paren
(brace
r_if
c_cond
(paren
id|likely
c_func
(paren
id|size
OG
l_int|0
)paren
)paren
id|memcpy
c_func
(paren
id|dstbase
op_plus
id|dst
comma
id|srcbase
op_plus
id|src
comma
id|size
op_star
r_sizeof
(paren
op_star
id|dstbase
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_rl_realloc - Reallocate memory for runlists&n; * @rl:&t;&t;original runlist&n; * @old_size:&t;number of runlist elements in the original runlist @rl&n; * @new_size:&t;number of runlist elements we need space for&n; *&n; * As the runlists grow, more memory will be required.  To prevent the&n; * kernel having to allocate and reallocate large numbers of small bits of&n; * memory, this function returns and entire page of memory.&n; *&n; * It is up to the caller to serialize access to the runlist @rl.&n; *&n; * N.B.  If the new allocation doesn&squot;t require a different number of pages in&n; *       memory, the function will return the original pointer.&n; *&n; * On success, return a pointer to the newly allocated, or recycled, memory.&n; * On error, return -errno. The following error codes are defined:&n; *&t;-ENOMEM&t;- Not enough memory to allocate runlist array.&n; *&t;-EINVAL&t;- Invalid parameters were passed in.&n; */
DECL|function|ntfs_rl_realloc
r_static
r_inline
id|runlist_element
op_star
id|ntfs_rl_realloc
c_func
(paren
id|runlist_element
op_star
id|rl
comma
r_int
id|old_size
comma
r_int
id|new_size
)paren
(brace
id|runlist_element
op_star
id|new_rl
suffix:semicolon
id|old_size
op_assign
id|PAGE_ALIGN
c_func
(paren
id|old_size
op_star
r_sizeof
(paren
op_star
id|rl
)paren
)paren
suffix:semicolon
id|new_size
op_assign
id|PAGE_ALIGN
c_func
(paren
id|new_size
op_star
r_sizeof
(paren
op_star
id|rl
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|old_size
op_eq
id|new_size
)paren
r_return
id|rl
suffix:semicolon
id|new_rl
op_assign
id|ntfs_malloc_nofs
c_func
(paren
id|new_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|new_rl
)paren
)paren
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
id|rl
op_ne
l_int|NULL
)paren
)paren
(brace
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|old_size
OG
id|new_size
)paren
)paren
id|old_size
op_assign
id|new_size
suffix:semicolon
id|memcpy
c_func
(paren
id|new_rl
comma
id|rl
comma
id|old_size
)paren
suffix:semicolon
id|ntfs_free
c_func
(paren
id|rl
)paren
suffix:semicolon
)brace
r_return
id|new_rl
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_are_rl_mergeable - test if two runlists can be joined together&n; * @dst:&t;original runlist&n; * @src:&t;new runlist to test for mergeability with @dst&n; *&n; * Test if two runlists can be joined together. For this, their VCNs and LCNs&n; * must be adjacent.&n; *&n; * It is up to the caller to serialize access to the runlists @dst and @src.&n; *&n; * Return: TRUE   Success, the runlists can be merged.&n; *&t;   FALSE  Failure, the runlists cannot be merged.&n; */
DECL|function|ntfs_are_rl_mergeable
r_static
r_inline
id|BOOL
id|ntfs_are_rl_mergeable
c_func
(paren
id|runlist_element
op_star
id|dst
comma
id|runlist_element
op_star
id|src
)paren
(brace
id|BUG_ON
c_func
(paren
op_logical_neg
id|dst
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|src
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|dst-&gt;lcn
OL
l_int|0
)paren
op_logical_or
(paren
id|src-&gt;lcn
OL
l_int|0
)paren
)paren
multiline_comment|/* Are we merging holes? */
r_return
id|FALSE
suffix:semicolon
r_if
c_cond
(paren
(paren
id|dst-&gt;lcn
op_plus
id|dst-&gt;length
)paren
op_ne
id|src-&gt;lcn
)paren
multiline_comment|/* Are the runs contiguous? */
r_return
id|FALSE
suffix:semicolon
r_if
c_cond
(paren
(paren
id|dst-&gt;vcn
op_plus
id|dst-&gt;length
)paren
op_ne
id|src-&gt;vcn
)paren
multiline_comment|/* Are the runs misaligned? */
r_return
id|FALSE
suffix:semicolon
r_return
id|TRUE
suffix:semicolon
)brace
multiline_comment|/**&n; * __ntfs_rl_merge - merge two runlists without testing if they can be merged&n; * @dst:&t;original, destination runlist&n; * @src:&t;new runlist to merge with @dst&n; *&n; * Merge the two runlists, writing into the destination runlist @dst. The&n; * caller must make sure the runlists can be merged or this will corrupt the&n; * destination runlist.&n; *&n; * It is up to the caller to serialize access to the runlists @dst and @src.&n; */
DECL|function|__ntfs_rl_merge
r_static
r_inline
r_void
id|__ntfs_rl_merge
c_func
(paren
id|runlist_element
op_star
id|dst
comma
id|runlist_element
op_star
id|src
)paren
(brace
id|dst-&gt;length
op_add_assign
id|src-&gt;length
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_rl_merge - test if two runlists can be joined together and merge them&n; * @dst:&t;original, destination runlist&n; * @src:&t;new runlist to merge with @dst&n; *&n; * Test if two runlists can be joined together. For this, their VCNs and LCNs&n; * must be adjacent. If they can be merged, perform the merge, writing into&n; * the destination runlist @dst.&n; *&n; * It is up to the caller to serialize access to the runlists @dst and @src.&n; *&n; * Return: TRUE   Success, the runlists have been merged.&n; *&t;   FALSE  Failure, the runlists cannot be merged and have not been&n; *&t;&t;  modified.&n; */
DECL|function|ntfs_rl_merge
r_static
r_inline
id|BOOL
id|ntfs_rl_merge
c_func
(paren
id|runlist_element
op_star
id|dst
comma
id|runlist_element
op_star
id|src
)paren
(brace
id|BOOL
id|merge
op_assign
id|ntfs_are_rl_mergeable
c_func
(paren
id|dst
comma
id|src
)paren
suffix:semicolon
r_if
c_cond
(paren
id|merge
)paren
id|__ntfs_rl_merge
c_func
(paren
id|dst
comma
id|src
)paren
suffix:semicolon
r_return
id|merge
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_rl_append - append a runlist after a given element&n; * @dst:&t;original runlist to be worked on&n; * @dsize:&t;number of elements in @dst (including end marker)&n; * @src:&t;runlist to be inserted into @dst&n; * @ssize:&t;number of elements in @src (excluding end marker)&n; * @loc:&t;append the new runlist @src after this element in @dst&n; *&n; * Append the runlist @src after element @loc in @dst.  Merge the right end of&n; * the new runlist, if necessary. Adjust the size of the hole before the&n; * appended runlist.&n; *&n; * It is up to the caller to serialize access to the runlists @dst and @src.&n; *&n; * On success, return a pointer to the new, combined, runlist. Note, both&n; * runlists @dst and @src are deallocated before returning so you cannot use&n; * the pointers for anything any more. (Strictly speaking the returned runlist&n; * may be the same as @dst but this is irrelevant.)&n; *&n; * On error, return -errno. Both runlists are left unmodified. The following&n; * error codes are defined:&n; *&t;-ENOMEM&t;- Not enough memory to allocate runlist array.&n; *&t;-EINVAL&t;- Invalid parameters were passed in.&n; */
DECL|function|ntfs_rl_append
r_static
r_inline
id|runlist_element
op_star
id|ntfs_rl_append
c_func
(paren
id|runlist_element
op_star
id|dst
comma
r_int
id|dsize
comma
id|runlist_element
op_star
id|src
comma
r_int
id|ssize
comma
r_int
id|loc
)paren
(brace
id|BOOL
id|right
suffix:semicolon
r_int
id|magic
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|dst
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|src
)paren
suffix:semicolon
multiline_comment|/* First, check if the right hand end needs merging. */
id|right
op_assign
id|ntfs_are_rl_mergeable
c_func
(paren
id|src
op_plus
id|ssize
op_minus
l_int|1
comma
id|dst
op_plus
id|loc
op_plus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Space required: @dst size + @src size, less one if we merged. */
id|dst
op_assign
id|ntfs_rl_realloc
c_func
(paren
id|dst
comma
id|dsize
comma
id|dsize
op_plus
id|ssize
op_minus
id|right
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|dst
)paren
)paren
r_return
id|dst
suffix:semicolon
multiline_comment|/*&n;&t; * We are guaranteed to succeed from here so can start modifying the&n;&t; * original runlists.&n;&t; */
multiline_comment|/* First, merge the right hand end, if necessary. */
r_if
c_cond
(paren
id|right
)paren
id|__ntfs_rl_merge
c_func
(paren
id|src
op_plus
id|ssize
op_minus
l_int|1
comma
id|dst
op_plus
id|loc
op_plus
l_int|1
)paren
suffix:semicolon
id|magic
op_assign
id|loc
op_plus
id|ssize
suffix:semicolon
multiline_comment|/* Move the tail of @dst out of the way, then copy in @src. */
id|ntfs_rl_mm
c_func
(paren
id|dst
comma
id|magic
op_plus
l_int|1
comma
id|loc
op_plus
l_int|1
op_plus
id|right
comma
id|dsize
op_minus
id|loc
op_minus
l_int|1
op_minus
id|right
)paren
suffix:semicolon
id|ntfs_rl_mc
c_func
(paren
id|dst
comma
id|loc
op_plus
l_int|1
comma
id|src
comma
l_int|0
comma
id|ssize
)paren
suffix:semicolon
multiline_comment|/* Adjust the size of the preceding hole. */
id|dst
(braket
id|loc
)braket
dot
id|length
op_assign
id|dst
(braket
id|loc
op_plus
l_int|1
)braket
dot
id|vcn
op_minus
id|dst
(braket
id|loc
)braket
dot
id|vcn
suffix:semicolon
multiline_comment|/* We may have changed the length of the file, so fix the end marker */
r_if
c_cond
(paren
id|dst
(braket
id|magic
op_plus
l_int|1
)braket
dot
id|lcn
op_eq
id|LCN_ENOENT
)paren
id|dst
(braket
id|magic
op_plus
l_int|1
)braket
dot
id|vcn
op_assign
id|dst
(braket
id|magic
)braket
dot
id|vcn
op_plus
id|dst
(braket
id|magic
)braket
dot
id|length
suffix:semicolon
r_return
id|dst
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_rl_insert - insert a runlist into another&n; * @dst:&t;original runlist to be worked on&n; * @dsize:&t;number of elements in @dst (including end marker)&n; * @src:&t;new runlist to be inserted&n; * @ssize:&t;number of elements in @src (excluding end marker)&n; * @loc:&t;insert the new runlist @src before this element in @dst&n; *&n; * Insert the runlist @src before element @loc in the runlist @dst. Merge the&n; * left end of the new runlist, if necessary. Adjust the size of the hole&n; * after the inserted runlist.&n; *&n; * It is up to the caller to serialize access to the runlists @dst and @src.&n; *&n; * On success, return a pointer to the new, combined, runlist. Note, both&n; * runlists @dst and @src are deallocated before returning so you cannot use&n; * the pointers for anything any more. (Strictly speaking the returned runlist&n; * may be the same as @dst but this is irrelevant.)&n; *&n; * On error, return -errno. Both runlists are left unmodified. The following&n; * error codes are defined:&n; *&t;-ENOMEM&t;- Not enough memory to allocate runlist array.&n; *&t;-EINVAL&t;- Invalid parameters were passed in.&n; */
DECL|function|ntfs_rl_insert
r_static
r_inline
id|runlist_element
op_star
id|ntfs_rl_insert
c_func
(paren
id|runlist_element
op_star
id|dst
comma
r_int
id|dsize
comma
id|runlist_element
op_star
id|src
comma
r_int
id|ssize
comma
r_int
id|loc
)paren
(brace
id|BOOL
id|left
op_assign
id|FALSE
suffix:semicolon
id|BOOL
id|disc
op_assign
id|FALSE
suffix:semicolon
multiline_comment|/* Discontinuity */
id|BOOL
id|hole
op_assign
id|FALSE
suffix:semicolon
multiline_comment|/* Following a hole */
r_int
id|magic
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|dst
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|src
)paren
suffix:semicolon
multiline_comment|/* disc =&gt; Discontinuity between the end of @dst and the start of @src.&n;&t; *&t;   This means we might need to insert a hole.&n;&t; * hole =&gt; @dst ends with a hole or an unmapped region which we can&n;&t; *&t;   extend to match the discontinuity. */
r_if
c_cond
(paren
id|loc
op_eq
l_int|0
)paren
id|disc
op_assign
(paren
id|src
(braket
l_int|0
)braket
dot
id|vcn
OG
l_int|0
)paren
suffix:semicolon
r_else
(brace
id|s64
id|merged_length
suffix:semicolon
id|left
op_assign
id|ntfs_are_rl_mergeable
c_func
(paren
id|dst
op_plus
id|loc
op_minus
l_int|1
comma
id|src
)paren
suffix:semicolon
id|merged_length
op_assign
id|dst
(braket
id|loc
op_minus
l_int|1
)braket
dot
id|length
suffix:semicolon
r_if
c_cond
(paren
id|left
)paren
id|merged_length
op_add_assign
id|src-&gt;length
suffix:semicolon
id|disc
op_assign
(paren
id|src
(braket
l_int|0
)braket
dot
id|vcn
OG
id|dst
(braket
id|loc
op_minus
l_int|1
)braket
dot
id|vcn
op_plus
id|merged_length
)paren
suffix:semicolon
r_if
c_cond
(paren
id|disc
)paren
id|hole
op_assign
(paren
id|dst
(braket
id|loc
op_minus
l_int|1
)braket
dot
id|lcn
op_eq
id|LCN_HOLE
)paren
suffix:semicolon
)brace
multiline_comment|/* Space required: @dst size + @src size, less one if we merged, plus&n;&t; * one if there was a discontinuity, less one for a trailing hole. */
id|dst
op_assign
id|ntfs_rl_realloc
c_func
(paren
id|dst
comma
id|dsize
comma
id|dsize
op_plus
id|ssize
op_minus
id|left
op_plus
id|disc
op_minus
id|hole
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|dst
)paren
)paren
r_return
id|dst
suffix:semicolon
multiline_comment|/*&n;&t; * We are guaranteed to succeed from here so can start modifying the&n;&t; * original runlist.&n;&t; */
r_if
c_cond
(paren
id|left
)paren
id|__ntfs_rl_merge
c_func
(paren
id|dst
op_plus
id|loc
op_minus
l_int|1
comma
id|src
)paren
suffix:semicolon
id|magic
op_assign
id|loc
op_plus
id|ssize
op_minus
id|left
op_plus
id|disc
op_minus
id|hole
suffix:semicolon
multiline_comment|/* Move the tail of @dst out of the way, then copy in @src. */
id|ntfs_rl_mm
c_func
(paren
id|dst
comma
id|magic
comma
id|loc
comma
id|dsize
op_minus
id|loc
)paren
suffix:semicolon
id|ntfs_rl_mc
c_func
(paren
id|dst
comma
id|loc
op_plus
id|disc
op_minus
id|hole
comma
id|src
comma
id|left
comma
id|ssize
op_minus
id|left
)paren
suffix:semicolon
multiline_comment|/* Adjust the VCN of the last run ... */
r_if
c_cond
(paren
id|dst
(braket
id|magic
)braket
dot
id|lcn
op_le
id|LCN_HOLE
)paren
id|dst
(braket
id|magic
)braket
dot
id|vcn
op_assign
id|dst
(braket
id|magic
op_minus
l_int|1
)braket
dot
id|vcn
op_plus
id|dst
(braket
id|magic
op_minus
l_int|1
)braket
dot
id|length
suffix:semicolon
multiline_comment|/* ... and the length. */
r_if
c_cond
(paren
id|dst
(braket
id|magic
)braket
dot
id|lcn
op_eq
id|LCN_HOLE
op_logical_or
id|dst
(braket
id|magic
)braket
dot
id|lcn
op_eq
id|LCN_RL_NOT_MAPPED
)paren
id|dst
(braket
id|magic
)braket
dot
id|length
op_assign
id|dst
(braket
id|magic
op_plus
l_int|1
)braket
dot
id|vcn
op_minus
id|dst
(braket
id|magic
)braket
dot
id|vcn
suffix:semicolon
multiline_comment|/* Writing beyond the end of the file and there&squot;s a discontinuity. */
r_if
c_cond
(paren
id|disc
)paren
(brace
r_if
c_cond
(paren
id|hole
)paren
id|dst
(braket
id|loc
op_minus
l_int|1
)braket
dot
id|length
op_assign
id|dst
(braket
id|loc
)braket
dot
id|vcn
op_minus
id|dst
(braket
id|loc
op_minus
l_int|1
)braket
dot
id|vcn
suffix:semicolon
r_else
(brace
r_if
c_cond
(paren
id|loc
OG
l_int|0
)paren
(brace
id|dst
(braket
id|loc
)braket
dot
id|vcn
op_assign
id|dst
(braket
id|loc
op_minus
l_int|1
)braket
dot
id|vcn
op_plus
id|dst
(braket
id|loc
op_minus
l_int|1
)braket
dot
id|length
suffix:semicolon
id|dst
(braket
id|loc
)braket
dot
id|length
op_assign
id|dst
(braket
id|loc
op_plus
l_int|1
)braket
dot
id|vcn
op_minus
id|dst
(braket
id|loc
)braket
dot
id|vcn
suffix:semicolon
)brace
r_else
(brace
id|dst
(braket
id|loc
)braket
dot
id|vcn
op_assign
l_int|0
suffix:semicolon
id|dst
(braket
id|loc
)braket
dot
id|length
op_assign
id|dst
(braket
id|loc
op_plus
l_int|1
)braket
dot
id|vcn
suffix:semicolon
)brace
id|dst
(braket
id|loc
)braket
dot
id|lcn
op_assign
id|LCN_RL_NOT_MAPPED
suffix:semicolon
)brace
id|magic
op_add_assign
id|hole
suffix:semicolon
r_if
c_cond
(paren
id|dst
(braket
id|magic
)braket
dot
id|lcn
op_eq
id|LCN_ENOENT
)paren
id|dst
(braket
id|magic
)braket
dot
id|vcn
op_assign
id|dst
(braket
id|magic
op_minus
l_int|1
)braket
dot
id|vcn
op_plus
id|dst
(braket
id|magic
op_minus
l_int|1
)braket
dot
id|length
suffix:semicolon
)brace
r_return
id|dst
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_rl_replace - overwrite a runlist element with another runlist&n; * @dst:&t;original runlist to be worked on&n; * @dsize:&t;number of elements in @dst (including end marker)&n; * @src:&t;new runlist to be inserted&n; * @ssize:&t;number of elements in @src (excluding end marker)&n; * @loc:&t;index in runlist @dst to overwrite with @src&n; *&n; * Replace the runlist element @dst at @loc with @src. Merge the left and&n; * right ends of the inserted runlist, if necessary.&n; *&n; * It is up to the caller to serialize access to the runlists @dst and @src.&n; *&n; * On success, return a pointer to the new, combined, runlist. Note, both&n; * runlists @dst and @src are deallocated before returning so you cannot use&n; * the pointers for anything any more. (Strictly speaking the returned runlist&n; * may be the same as @dst but this is irrelevant.)&n; *&n; * On error, return -errno. Both runlists are left unmodified. The following&n; * error codes are defined:&n; *&t;-ENOMEM&t;- Not enough memory to allocate runlist array.&n; *&t;-EINVAL&t;- Invalid parameters were passed in.&n; */
DECL|function|ntfs_rl_replace
r_static
r_inline
id|runlist_element
op_star
id|ntfs_rl_replace
c_func
(paren
id|runlist_element
op_star
id|dst
comma
r_int
id|dsize
comma
id|runlist_element
op_star
id|src
comma
r_int
id|ssize
comma
r_int
id|loc
)paren
(brace
id|BOOL
id|left
op_assign
id|FALSE
suffix:semicolon
id|BOOL
id|right
suffix:semicolon
r_int
id|magic
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|dst
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|src
)paren
suffix:semicolon
multiline_comment|/* First, merge the left and right ends, if necessary. */
id|right
op_assign
id|ntfs_are_rl_mergeable
c_func
(paren
id|src
op_plus
id|ssize
op_minus
l_int|1
comma
id|dst
op_plus
id|loc
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|loc
OG
l_int|0
)paren
id|left
op_assign
id|ntfs_are_rl_mergeable
c_func
(paren
id|dst
op_plus
id|loc
op_minus
l_int|1
comma
id|src
)paren
suffix:semicolon
multiline_comment|/* Allocate some space. We&squot;ll need less if the left, right, or both&n;&t; * ends were merged. */
id|dst
op_assign
id|ntfs_rl_realloc
c_func
(paren
id|dst
comma
id|dsize
comma
id|dsize
op_plus
id|ssize
op_minus
id|left
op_minus
id|right
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|dst
)paren
)paren
r_return
id|dst
suffix:semicolon
multiline_comment|/*&n;&t; * We are guaranteed to succeed from here so can start modifying the&n;&t; * original runlists.&n;&t; */
r_if
c_cond
(paren
id|right
)paren
id|__ntfs_rl_merge
c_func
(paren
id|src
op_plus
id|ssize
op_minus
l_int|1
comma
id|dst
op_plus
id|loc
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|left
)paren
id|__ntfs_rl_merge
c_func
(paren
id|dst
op_plus
id|loc
op_minus
l_int|1
comma
id|src
)paren
suffix:semicolon
multiline_comment|/* FIXME: What does this mean? (AIA) */
id|magic
op_assign
id|loc
op_plus
id|ssize
op_minus
id|left
suffix:semicolon
multiline_comment|/* Move the tail of @dst out of the way, then copy in @src. */
id|ntfs_rl_mm
c_func
(paren
id|dst
comma
id|magic
comma
id|loc
op_plus
id|right
op_plus
l_int|1
comma
id|dsize
op_minus
id|loc
op_minus
id|right
op_minus
l_int|1
)paren
suffix:semicolon
id|ntfs_rl_mc
c_func
(paren
id|dst
comma
id|loc
comma
id|src
comma
id|left
comma
id|ssize
op_minus
id|left
)paren
suffix:semicolon
multiline_comment|/* We may have changed the length of the file, so fix the end marker */
r_if
c_cond
(paren
id|dst
(braket
id|magic
)braket
dot
id|lcn
op_eq
id|LCN_ENOENT
)paren
id|dst
(braket
id|magic
)braket
dot
id|vcn
op_assign
id|dst
(braket
id|magic
op_minus
l_int|1
)braket
dot
id|vcn
op_plus
id|dst
(braket
id|magic
op_minus
l_int|1
)braket
dot
id|length
suffix:semicolon
r_return
id|dst
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_rl_split - insert a runlist into the centre of a hole&n; * @dst:&t;original runlist to be worked on&n; * @dsize:&t;number of elements in @dst (including end marker)&n; * @src:&t;new runlist to be inserted&n; * @ssize:&t;number of elements in @src (excluding end marker)&n; * @loc:&t;index in runlist @dst at which to split and insert @src&n; *&n; * Split the runlist @dst at @loc into two and insert @new in between the two&n; * fragments. No merging of runlists is necessary. Adjust the size of the&n; * holes either side.&n; *&n; * It is up to the caller to serialize access to the runlists @dst and @src.&n; *&n; * On success, return a pointer to the new, combined, runlist. Note, both&n; * runlists @dst and @src are deallocated before returning so you cannot use&n; * the pointers for anything any more. (Strictly speaking the returned runlist&n; * may be the same as @dst but this is irrelevant.)&n; *&n; * On error, return -errno. Both runlists are left unmodified. The following&n; * error codes are defined:&n; *&t;-ENOMEM&t;- Not enough memory to allocate runlist array.&n; *&t;-EINVAL&t;- Invalid parameters were passed in.&n; */
DECL|function|ntfs_rl_split
r_static
r_inline
id|runlist_element
op_star
id|ntfs_rl_split
c_func
(paren
id|runlist_element
op_star
id|dst
comma
r_int
id|dsize
comma
id|runlist_element
op_star
id|src
comma
r_int
id|ssize
comma
r_int
id|loc
)paren
(brace
id|BUG_ON
c_func
(paren
op_logical_neg
id|dst
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|src
)paren
suffix:semicolon
multiline_comment|/* Space required: @dst size + @src size + one new hole. */
id|dst
op_assign
id|ntfs_rl_realloc
c_func
(paren
id|dst
comma
id|dsize
comma
id|dsize
op_plus
id|ssize
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|dst
)paren
)paren
r_return
id|dst
suffix:semicolon
multiline_comment|/*&n;&t; * We are guaranteed to succeed from here so can start modifying the&n;&t; * original runlists.&n;&t; */
multiline_comment|/* Move the tail of @dst out of the way, then copy in @src. */
id|ntfs_rl_mm
c_func
(paren
id|dst
comma
id|loc
op_plus
l_int|1
op_plus
id|ssize
comma
id|loc
comma
id|dsize
op_minus
id|loc
)paren
suffix:semicolon
id|ntfs_rl_mc
c_func
(paren
id|dst
comma
id|loc
op_plus
l_int|1
comma
id|src
comma
l_int|0
comma
id|ssize
)paren
suffix:semicolon
multiline_comment|/* Adjust the size of the holes either size of @src. */
id|dst
(braket
id|loc
)braket
dot
id|length
op_assign
id|dst
(braket
id|loc
op_plus
l_int|1
)braket
dot
id|vcn
op_minus
id|dst
(braket
id|loc
)braket
dot
id|vcn
suffix:semicolon
id|dst
(braket
id|loc
op_plus
id|ssize
op_plus
l_int|1
)braket
dot
id|vcn
op_assign
id|dst
(braket
id|loc
op_plus
id|ssize
)braket
dot
id|vcn
op_plus
id|dst
(braket
id|loc
op_plus
id|ssize
)braket
dot
id|length
suffix:semicolon
id|dst
(braket
id|loc
op_plus
id|ssize
op_plus
l_int|1
)braket
dot
id|length
op_assign
id|dst
(braket
id|loc
op_plus
id|ssize
op_plus
l_int|2
)braket
dot
id|vcn
op_minus
id|dst
(braket
id|loc
op_plus
id|ssize
op_plus
l_int|1
)braket
dot
id|vcn
suffix:semicolon
r_return
id|dst
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_merge_runlists - merge two runlists into one&n; * @drl:&t;original runlist to be worked on&n; * @srl:&t;new runlist to be merged into @drl&n; *&n; * First we sanity check the two runlists @srl and @drl to make sure that they&n; * are sensible and can be merged. The runlist @srl must be either after the&n; * runlist @drl or completely within a hole (or unmapped region) in @drl.&n; *&n; * It is up to the caller to serialize access to the runlists @drl and @srl.&n; *&n; * Merging of runlists is necessary in two cases:&n; *   1. When attribute lists are used and a further extent is being mapped.&n; *   2. When new clusters are allocated to fill a hole or extend a file.&n; *&n; * There are four possible ways @srl can be merged. It can:&n; *&t;- be inserted at the beginning of a hole,&n; *&t;- split the hole in two and be inserted between the two fragments,&n; *&t;- be appended at the end of a hole, or it can&n; *&t;- replace the whole hole.&n; * It can also be appended to the end of the runlist, which is just a variant&n; * of the insert case.&n; *&n; * On success, return a pointer to the new, combined, runlist. Note, both&n; * runlists @drl and @srl are deallocated before returning so you cannot use&n; * the pointers for anything any more. (Strictly speaking the returned runlist&n; * may be the same as @dst but this is irrelevant.)&n; *&n; * On error, return -errno. Both runlists are left unmodified. The following&n; * error codes are defined:&n; *&t;-ENOMEM&t;- Not enough memory to allocate runlist array.&n; *&t;-EINVAL&t;- Invalid parameters were passed in.&n; *&t;-ERANGE&t;- The runlists overlap and cannot be merged.&n; */
DECL|function|ntfs_merge_runlists
id|runlist_element
op_star
id|ntfs_merge_runlists
c_func
(paren
id|runlist_element
op_star
id|drl
comma
id|runlist_element
op_star
id|srl
)paren
(brace
r_int
id|di
comma
id|si
suffix:semicolon
multiline_comment|/* Current index into @[ds]rl. */
r_int
id|sstart
suffix:semicolon
multiline_comment|/* First index with lcn &gt; LCN_RL_NOT_MAPPED. */
r_int
id|dins
suffix:semicolon
multiline_comment|/* Index into @drl at which to insert @srl. */
r_int
id|dend
comma
id|send
suffix:semicolon
multiline_comment|/* Last index into @[ds]rl. */
r_int
id|dfinal
comma
id|sfinal
suffix:semicolon
multiline_comment|/* The last index into @[ds]rl with&n;&t;&t;&t;&t;   lcn &gt;= LCN_HOLE. */
r_int
id|marker
op_assign
l_int|0
suffix:semicolon
id|VCN
id|marker_vcn
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef DEBUG
id|ntfs_debug
c_func
(paren
l_string|&quot;dst:&quot;
)paren
suffix:semicolon
id|ntfs_debug_dump_runlist
c_func
(paren
id|drl
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;src:&quot;
)paren
suffix:semicolon
id|ntfs_debug_dump_runlist
c_func
(paren
id|srl
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Check for silly calling... */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|srl
)paren
)paren
r_return
id|drl
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|srl
)paren
op_logical_or
id|IS_ERR
c_func
(paren
id|drl
)paren
)paren
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
multiline_comment|/* Check for the case where the first mapping is being done now. */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|drl
)paren
)paren
(brace
id|drl
op_assign
id|srl
suffix:semicolon
multiline_comment|/* Complete the source runlist if necessary. */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|drl
(braket
l_int|0
)braket
dot
id|vcn
)paren
)paren
(brace
multiline_comment|/* Scan to the end of the source runlist. */
r_for
c_loop
(paren
id|dend
op_assign
l_int|0
suffix:semicolon
id|likely
c_func
(paren
id|drl
(braket
id|dend
)braket
dot
id|length
)paren
suffix:semicolon
id|dend
op_increment
)paren
suffix:semicolon
id|drl
op_assign
id|ntfs_rl_realloc
c_func
(paren
id|drl
comma
id|dend
comma
id|dend
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|drl
)paren
)paren
r_return
id|drl
suffix:semicolon
multiline_comment|/* Insert start element at the front of the runlist. */
id|ntfs_rl_mm
c_func
(paren
id|drl
comma
l_int|1
comma
l_int|0
comma
id|dend
)paren
suffix:semicolon
id|drl
(braket
l_int|0
)braket
dot
id|vcn
op_assign
l_int|0
suffix:semicolon
id|drl
(braket
l_int|0
)braket
dot
id|lcn
op_assign
id|LCN_RL_NOT_MAPPED
suffix:semicolon
id|drl
(braket
l_int|0
)braket
dot
id|length
op_assign
id|drl
(braket
l_int|1
)braket
dot
id|vcn
suffix:semicolon
)brace
r_goto
id|finished
suffix:semicolon
)brace
id|si
op_assign
id|di
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Skip any unmapped start element(s) in the source runlist. */
r_while
c_loop
(paren
id|srl
(braket
id|si
)braket
dot
id|length
op_logical_and
id|srl
(braket
id|si
)braket
dot
id|lcn
OL
(paren
id|LCN
)paren
id|LCN_HOLE
)paren
id|si
op_increment
suffix:semicolon
multiline_comment|/* Can&squot;t have an entirely unmapped source runlist. */
id|BUG_ON
c_func
(paren
op_logical_neg
id|srl
(braket
id|si
)braket
dot
id|length
)paren
suffix:semicolon
multiline_comment|/* Record the starting points. */
id|sstart
op_assign
id|si
suffix:semicolon
multiline_comment|/*&n;&t; * Skip forward in @drl until we reach the position where @srl needs to&n;&t; * be inserted. If we reach the end of @drl, @srl just needs to be&n;&t; * appended to @drl.&n;&t; */
r_for
c_loop
(paren
suffix:semicolon
id|drl
(braket
id|di
)braket
dot
id|length
suffix:semicolon
id|di
op_increment
)paren
(brace
r_if
c_cond
(paren
id|drl
(braket
id|di
)braket
dot
id|vcn
op_plus
id|drl
(braket
id|di
)braket
dot
id|length
OG
id|srl
(braket
id|sstart
)braket
dot
id|vcn
)paren
r_break
suffix:semicolon
)brace
id|dins
op_assign
id|di
suffix:semicolon
multiline_comment|/* Sanity check for illegal overlaps. */
r_if
c_cond
(paren
(paren
id|drl
(braket
id|di
)braket
dot
id|vcn
op_eq
id|srl
(braket
id|si
)braket
dot
id|vcn
)paren
op_logical_and
(paren
id|drl
(braket
id|di
)braket
dot
id|lcn
op_ge
l_int|0
)paren
op_logical_and
(paren
id|srl
(braket
id|si
)braket
dot
id|lcn
op_ge
l_int|0
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
l_int|NULL
comma
l_string|&quot;Run lists overlap. Cannot merge!&quot;
)paren
suffix:semicolon
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|ERANGE
)paren
suffix:semicolon
)brace
multiline_comment|/* Scan to the end of both runlists in order to know their sizes. */
r_for
c_loop
(paren
id|send
op_assign
id|si
suffix:semicolon
id|srl
(braket
id|send
)braket
dot
id|length
suffix:semicolon
id|send
op_increment
)paren
suffix:semicolon
r_for
c_loop
(paren
id|dend
op_assign
id|di
suffix:semicolon
id|drl
(braket
id|dend
)braket
dot
id|length
suffix:semicolon
id|dend
op_increment
)paren
suffix:semicolon
r_if
c_cond
(paren
id|srl
(braket
id|send
)braket
dot
id|lcn
op_eq
(paren
id|LCN
)paren
id|LCN_ENOENT
)paren
id|marker_vcn
op_assign
id|srl
(braket
id|marker
op_assign
id|send
)braket
dot
id|vcn
suffix:semicolon
multiline_comment|/* Scan to the last element with lcn &gt;= LCN_HOLE. */
r_for
c_loop
(paren
id|sfinal
op_assign
id|send
suffix:semicolon
id|sfinal
op_ge
l_int|0
op_logical_and
id|srl
(braket
id|sfinal
)braket
dot
id|lcn
OL
id|LCN_HOLE
suffix:semicolon
id|sfinal
op_decrement
)paren
suffix:semicolon
r_for
c_loop
(paren
id|dfinal
op_assign
id|dend
suffix:semicolon
id|dfinal
op_ge
l_int|0
op_logical_and
id|drl
(braket
id|dfinal
)braket
dot
id|lcn
OL
id|LCN_HOLE
suffix:semicolon
id|dfinal
op_decrement
)paren
suffix:semicolon
(brace
id|BOOL
id|start
suffix:semicolon
id|BOOL
id|finish
suffix:semicolon
r_int
id|ds
op_assign
id|dend
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* Number of elements in drl &amp; srl */
r_int
id|ss
op_assign
id|sfinal
op_minus
id|sstart
op_plus
l_int|1
suffix:semicolon
id|start
op_assign
(paren
(paren
id|drl
(braket
id|dins
)braket
dot
id|lcn
OL
id|LCN_RL_NOT_MAPPED
)paren
op_logical_or
multiline_comment|/* End of file   */
(paren
id|drl
(braket
id|dins
)braket
dot
id|vcn
op_eq
id|srl
(braket
id|sstart
)braket
dot
id|vcn
)paren
)paren
suffix:semicolon
multiline_comment|/* Start of hole */
id|finish
op_assign
(paren
(paren
id|drl
(braket
id|dins
)braket
dot
id|lcn
op_ge
id|LCN_RL_NOT_MAPPED
)paren
op_logical_and
multiline_comment|/* End of file   */
(paren
(paren
id|drl
(braket
id|dins
)braket
dot
id|vcn
op_plus
id|drl
(braket
id|dins
)braket
dot
id|length
)paren
op_le
multiline_comment|/* End of hole   */
(paren
id|srl
(braket
id|send
op_minus
l_int|1
)braket
dot
id|vcn
op_plus
id|srl
(braket
id|send
op_minus
l_int|1
)braket
dot
id|length
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/* Or we&squot;ll lose an end marker */
r_if
c_cond
(paren
id|start
op_logical_and
id|finish
op_logical_and
(paren
id|drl
(braket
id|dins
)braket
dot
id|length
op_eq
l_int|0
)paren
)paren
id|ss
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|marker
op_logical_and
(paren
id|drl
(braket
id|dins
)braket
dot
id|vcn
op_plus
id|drl
(braket
id|dins
)braket
dot
id|length
OG
id|srl
(braket
id|send
op_minus
l_int|1
)braket
dot
id|vcn
)paren
)paren
id|finish
op_assign
id|FALSE
suffix:semicolon
macro_line|#if 0
id|ntfs_debug
c_func
(paren
l_string|&quot;dfinal = %i, dend = %i&quot;
comma
id|dfinal
comma
id|dend
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;sstart = %i, sfinal = %i, send = %i&quot;
comma
id|sstart
comma
id|sfinal
comma
id|send
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;start = %i, finish = %i&quot;
comma
id|start
comma
id|finish
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;ds = %i, ss = %i, dins = %i&quot;
comma
id|ds
comma
id|ss
comma
id|dins
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|start
)paren
(brace
r_if
c_cond
(paren
id|finish
)paren
id|drl
op_assign
id|ntfs_rl_replace
c_func
(paren
id|drl
comma
id|ds
comma
id|srl
op_plus
id|sstart
comma
id|ss
comma
id|dins
)paren
suffix:semicolon
r_else
id|drl
op_assign
id|ntfs_rl_insert
c_func
(paren
id|drl
comma
id|ds
comma
id|srl
op_plus
id|sstart
comma
id|ss
comma
id|dins
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|finish
)paren
id|drl
op_assign
id|ntfs_rl_append
c_func
(paren
id|drl
comma
id|ds
comma
id|srl
op_plus
id|sstart
comma
id|ss
comma
id|dins
)paren
suffix:semicolon
r_else
id|drl
op_assign
id|ntfs_rl_split
c_func
(paren
id|drl
comma
id|ds
comma
id|srl
op_plus
id|sstart
comma
id|ss
comma
id|dins
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|drl
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
l_int|NULL
comma
l_string|&quot;Merge failed.&quot;
)paren
suffix:semicolon
r_return
id|drl
suffix:semicolon
)brace
id|ntfs_free
c_func
(paren
id|srl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|marker
)paren
(brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Triggering marker code.&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|ds
op_assign
id|dend
suffix:semicolon
id|drl
(braket
id|ds
)braket
dot
id|length
suffix:semicolon
id|ds
op_increment
)paren
suffix:semicolon
multiline_comment|/* We only need to care if @srl ended after @drl. */
r_if
c_cond
(paren
id|drl
(braket
id|ds
)braket
dot
id|vcn
op_le
id|marker_vcn
)paren
(brace
r_int
id|slots
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|drl
(braket
id|ds
)braket
dot
id|vcn
op_eq
id|marker_vcn
)paren
(brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Old marker = 0x%llx, replacing &quot;
l_string|&quot;with LCN_ENOENT.&quot;
comma
(paren
r_int
r_int
r_int
)paren
id|drl
(braket
id|ds
)braket
dot
id|lcn
)paren
suffix:semicolon
id|drl
(braket
id|ds
)braket
dot
id|lcn
op_assign
(paren
id|LCN
)paren
id|LCN_ENOENT
suffix:semicolon
r_goto
id|finished
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * We need to create an unmapped runlist element in&n;&t;&t;&t; * @drl or extend an existing one before adding the&n;&t;&t;&t; * ENOENT terminator.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|drl
(braket
id|ds
)braket
dot
id|lcn
op_eq
(paren
id|LCN
)paren
id|LCN_ENOENT
)paren
(brace
id|ds
op_decrement
suffix:semicolon
id|slots
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|drl
(braket
id|ds
)braket
dot
id|lcn
op_ne
(paren
id|LCN
)paren
id|LCN_RL_NOT_MAPPED
)paren
(brace
multiline_comment|/* Add an unmapped runlist element. */
r_if
c_cond
(paren
op_logical_neg
id|slots
)paren
(brace
multiline_comment|/* FIXME/TODO: We need to have the&n;&t;&t;&t;&t;&t; * extra memory already! (AIA) */
id|drl
op_assign
id|ntfs_rl_realloc
c_func
(paren
id|drl
comma
id|ds
comma
id|ds
op_plus
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|drl
)paren
r_goto
id|critical_error
suffix:semicolon
id|slots
op_assign
l_int|2
suffix:semicolon
)brace
id|ds
op_increment
suffix:semicolon
multiline_comment|/* Need to set vcn if it isn&squot;t set already. */
r_if
c_cond
(paren
id|slots
op_ne
l_int|1
)paren
id|drl
(braket
id|ds
)braket
dot
id|vcn
op_assign
id|drl
(braket
id|ds
op_minus
l_int|1
)braket
dot
id|vcn
op_plus
id|drl
(braket
id|ds
op_minus
l_int|1
)braket
dot
id|length
suffix:semicolon
id|drl
(braket
id|ds
)braket
dot
id|lcn
op_assign
(paren
id|LCN
)paren
id|LCN_RL_NOT_MAPPED
suffix:semicolon
multiline_comment|/* We now used up a slot. */
id|slots
op_decrement
suffix:semicolon
)brace
id|drl
(braket
id|ds
)braket
dot
id|length
op_assign
id|marker_vcn
op_minus
id|drl
(braket
id|ds
)braket
dot
id|vcn
suffix:semicolon
multiline_comment|/* Finally add the ENOENT terminator. */
id|ds
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|slots
)paren
(brace
multiline_comment|/* FIXME/TODO: We need to have the extra&n;&t;&t;&t;&t; * memory already! (AIA) */
id|drl
op_assign
id|ntfs_rl_realloc
c_func
(paren
id|drl
comma
id|ds
comma
id|ds
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|drl
)paren
r_goto
id|critical_error
suffix:semicolon
)brace
id|drl
(braket
id|ds
)braket
dot
id|vcn
op_assign
id|marker_vcn
suffix:semicolon
id|drl
(braket
id|ds
)braket
dot
id|lcn
op_assign
(paren
id|LCN
)paren
id|LCN_ENOENT
suffix:semicolon
id|drl
(braket
id|ds
)braket
dot
id|length
op_assign
(paren
id|s64
)paren
l_int|0
suffix:semicolon
)brace
)brace
)brace
id|finished
suffix:colon
multiline_comment|/* The merge was completed successfully. */
id|ntfs_debug
c_func
(paren
l_string|&quot;Merged runlist:&quot;
)paren
suffix:semicolon
id|ntfs_debug_dump_runlist
c_func
(paren
id|drl
)paren
suffix:semicolon
r_return
id|drl
suffix:semicolon
id|critical_error
suffix:colon
multiline_comment|/* Critical error! We cannot afford to fail here. */
id|ntfs_error
c_func
(paren
l_int|NULL
comma
l_string|&quot;Critical error! Not enough memory.&quot;
)paren
suffix:semicolon
id|panic
c_func
(paren
l_string|&quot;NTFS: Cannot continue.&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_mapping_pairs_decompress - convert mapping pairs array to runlist&n; * @vol:&t;ntfs volume on which the attribute resides&n; * @attr:&t;attribute record whose mapping pairs array to decompress&n; * @old_rl:&t;optional runlist in which to insert @attr&squot;s runlist&n; *&n; * It is up to the caller to serialize access to the runlist @old_rl.&n; *&n; * Decompress the attribute @attr&squot;s mapping pairs array into a runlist. On&n; * success, return the decompressed runlist.&n; *&n; * If @old_rl is not NULL, decompressed runlist is inserted into the&n; * appropriate place in @old_rl and the resultant, combined runlist is&n; * returned. The original @old_rl is deallocated.&n; *&n; * On error, return -errno. @old_rl is left unmodified in that case.&n; *&n; * The following error codes are defined:&n; *&t;-ENOMEM&t;- Not enough memory to allocate runlist array.&n; *&t;-EIO&t;- Corrupt runlist.&n; *&t;-EINVAL&t;- Invalid parameters were passed in.&n; *&t;-ERANGE&t;- The two runlists overlap.&n; *&n; * FIXME: For now we take the conceptionally simplest approach of creating the&n; * new runlist disregarding the already existing one and then splicing the&n; * two into one, if that is possible (we check for overlap and discard the new&n; * runlist if overlap present before returning ERR_PTR(-ERANGE)).&n; */
DECL|function|ntfs_mapping_pairs_decompress
id|runlist_element
op_star
id|ntfs_mapping_pairs_decompress
c_func
(paren
r_const
id|ntfs_volume
op_star
id|vol
comma
r_const
id|ATTR_RECORD
op_star
id|attr
comma
id|runlist_element
op_star
id|old_rl
)paren
(brace
id|VCN
id|vcn
suffix:semicolon
multiline_comment|/* Current vcn. */
id|LCN
id|lcn
suffix:semicolon
multiline_comment|/* Current lcn. */
id|s64
id|deltaxcn
suffix:semicolon
multiline_comment|/* Change in [vl]cn. */
id|runlist_element
op_star
id|rl
suffix:semicolon
multiline_comment|/* The output runlist. */
id|u8
op_star
id|buf
suffix:semicolon
multiline_comment|/* Current position in mapping pairs array. */
id|u8
op_star
id|attr_end
suffix:semicolon
multiline_comment|/* End of attribute. */
r_int
id|rlsize
suffix:semicolon
multiline_comment|/* Size of runlist buffer. */
id|u16
id|rlpos
suffix:semicolon
multiline_comment|/* Current runlist position in units of&n;&t;&t;&t;&t;   runlist_elements. */
id|u8
id|b
suffix:semicolon
multiline_comment|/* Current byte offset in buf. */
macro_line|#ifdef DEBUG
multiline_comment|/* Make sure attr exists and is non-resident. */
r_if
c_cond
(paren
op_logical_neg
id|attr
op_logical_or
op_logical_neg
id|attr-&gt;non_resident
op_logical_or
id|sle64_to_cpu
c_func
(paren
id|attr-&gt;data.non_resident.lowest_vcn
)paren
OL
(paren
id|VCN
)paren
l_int|0
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Invalid arguments.&quot;
)paren
suffix:semicolon
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* Start at vcn = lowest_vcn and lcn 0. */
id|vcn
op_assign
id|sle64_to_cpu
c_func
(paren
id|attr-&gt;data.non_resident.lowest_vcn
)paren
suffix:semicolon
id|lcn
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Get start of the mapping pairs array. */
id|buf
op_assign
(paren
id|u8
op_star
)paren
id|attr
op_plus
id|le16_to_cpu
c_func
(paren
id|attr-&gt;data.non_resident.mapping_pairs_offset
)paren
suffix:semicolon
id|attr_end
op_assign
(paren
id|u8
op_star
)paren
id|attr
op_plus
id|le32_to_cpu
c_func
(paren
id|attr-&gt;length
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|buf
template_param
id|attr_end
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Corrupt attribute.&quot;
)paren
suffix:semicolon
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|EIO
)paren
suffix:semicolon
)brace
multiline_comment|/* Current position in runlist array. */
id|rlpos
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Allocate first page and set current runlist size to one page. */
id|rl
op_assign
id|ntfs_malloc_nofs
c_func
(paren
id|rlsize
op_assign
id|PAGE_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|rl
)paren
)paren
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
multiline_comment|/* Insert unmapped starting element if necessary. */
r_if
c_cond
(paren
id|vcn
)paren
(brace
id|rl-&gt;vcn
op_assign
(paren
id|VCN
)paren
l_int|0
suffix:semicolon
id|rl-&gt;lcn
op_assign
(paren
id|LCN
)paren
id|LCN_RL_NOT_MAPPED
suffix:semicolon
id|rl-&gt;length
op_assign
id|vcn
suffix:semicolon
id|rlpos
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
id|buf
OL
id|attr_end
op_logical_and
op_star
id|buf
)paren
(brace
multiline_comment|/*&n;&t;&t; * Allocate more memory if needed, including space for the&n;&t;&t; * not-mapped and terminator elements. ntfs_malloc_nofs()&n;&t;&t; * operates on whole pages only.&n;&t;&t; */
r_if
c_cond
(paren
(paren
(paren
id|rlpos
op_plus
l_int|3
)paren
op_star
r_sizeof
(paren
op_star
id|old_rl
)paren
)paren
OG
id|rlsize
)paren
(brace
id|runlist_element
op_star
id|rl2
suffix:semicolon
id|rl2
op_assign
id|ntfs_malloc_nofs
c_func
(paren
id|rlsize
op_plus
(paren
r_int
)paren
id|PAGE_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|rl2
)paren
)paren
(brace
id|ntfs_free
c_func
(paren
id|rl
)paren
suffix:semicolon
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|rl2
comma
id|rl
comma
id|rlsize
)paren
suffix:semicolon
id|ntfs_free
c_func
(paren
id|rl
)paren
suffix:semicolon
id|rl
op_assign
id|rl2
suffix:semicolon
id|rlsize
op_add_assign
id|PAGE_SIZE
suffix:semicolon
)brace
multiline_comment|/* Enter the current vcn into the current runlist element. */
id|rl
(braket
id|rlpos
)braket
dot
id|vcn
op_assign
id|vcn
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Get the change in vcn, i.e. the run length in clusters.&n;&t;&t; * Doing it this way ensures that we signextend negative values.&n;&t;&t; * A negative run length doesn&squot;t make any sense, but hey, I&n;&t;&t; * didn&squot;t make up the NTFS specs and Windows NT4 treats the run&n;&t;&t; * length as a signed value so that&squot;s how it is...&n;&t;&t; */
id|b
op_assign
op_star
id|buf
op_amp
l_int|0xf
suffix:semicolon
r_if
c_cond
(paren
id|b
)paren
(brace
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|buf
op_plus
id|b
OG
id|attr_end
)paren
)paren
r_goto
id|io_error
suffix:semicolon
r_for
c_loop
(paren
id|deltaxcn
op_assign
(paren
id|s8
)paren
id|buf
(braket
id|b
op_decrement
)braket
suffix:semicolon
id|b
suffix:semicolon
id|b
op_decrement
)paren
id|deltaxcn
op_assign
(paren
id|deltaxcn
op_lshift
l_int|8
)paren
op_plus
id|buf
(braket
id|b
)braket
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* The length entry is compulsory. */
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Missing length entry in mapping &quot;
l_string|&quot;pairs array.&quot;
)paren
suffix:semicolon
id|deltaxcn
op_assign
(paren
id|s64
)paren
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Assume a negative length to indicate data corruption and&n;&t;&t; * hence clean-up and return NULL.&n;&t;&t; */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|deltaxcn
OL
l_int|0
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Invalid length in mapping pairs &quot;
l_string|&quot;array.&quot;
)paren
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Enter the current run length into the current runlist&n;&t;&t; * element.&n;&t;&t; */
id|rl
(braket
id|rlpos
)braket
dot
id|length
op_assign
id|deltaxcn
suffix:semicolon
multiline_comment|/* Increment the current vcn by the current run length. */
id|vcn
op_add_assign
id|deltaxcn
suffix:semicolon
multiline_comment|/*&n;&t;&t; * There might be no lcn change at all, as is the case for&n;&t;&t; * sparse clusters on NTFS 3.0+, in which case we set the lcn&n;&t;&t; * to LCN_HOLE.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
op_star
id|buf
op_amp
l_int|0xf0
)paren
)paren
id|rl
(braket
id|rlpos
)braket
dot
id|lcn
op_assign
(paren
id|LCN
)paren
id|LCN_HOLE
suffix:semicolon
r_else
(brace
multiline_comment|/* Get the lcn change which really can be negative. */
id|u8
id|b2
op_assign
op_star
id|buf
op_amp
l_int|0xf
suffix:semicolon
id|b
op_assign
id|b2
op_plus
(paren
(paren
op_star
id|buf
op_rshift
l_int|4
)paren
op_amp
l_int|0xf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buf
op_plus
id|b
OG
id|attr_end
)paren
r_goto
id|io_error
suffix:semicolon
r_for
c_loop
(paren
id|deltaxcn
op_assign
(paren
id|s8
)paren
id|buf
(braket
id|b
op_decrement
)braket
suffix:semicolon
id|b
OG
id|b2
suffix:semicolon
id|b
op_decrement
)paren
id|deltaxcn
op_assign
(paren
id|deltaxcn
op_lshift
l_int|8
)paren
op_plus
id|buf
(braket
id|b
)braket
suffix:semicolon
multiline_comment|/* Change the current lcn to its new value. */
id|lcn
op_add_assign
id|deltaxcn
suffix:semicolon
macro_line|#ifdef DEBUG
multiline_comment|/*&n;&t;&t;&t; * On NTFS 1.2-, apparently can have lcn == -1 to&n;&t;&t;&t; * indicate a hole. But we haven&squot;t verified ourselves&n;&t;&t;&t; * whether it is really the lcn or the deltaxcn that is&n;&t;&t;&t; * -1. So if either is found give us a message so we&n;&t;&t;&t; * can investigate it further!&n;&t;&t;&t; */
r_if
c_cond
(paren
id|vol-&gt;major_ver
OL
l_int|3
)paren
(brace
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|deltaxcn
op_eq
(paren
id|LCN
)paren
op_minus
l_int|1
)paren
)paren
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;lcn delta == -1&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|lcn
op_eq
(paren
id|LCN
)paren
op_minus
l_int|1
)paren
)paren
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;lcn == -1&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* Check lcn is not below -1. */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|lcn
OL
(paren
id|LCN
)paren
op_minus
l_int|1
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Invalid LCN &lt; -1 in &quot;
l_string|&quot;mapping pairs array.&quot;
)paren
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
multiline_comment|/* Enter the current lcn into the runlist element. */
id|rl
(braket
id|rlpos
)braket
dot
id|lcn
op_assign
id|lcn
suffix:semicolon
)brace
multiline_comment|/* Get to the next runlist element. */
id|rlpos
op_increment
suffix:semicolon
multiline_comment|/* Increment the buffer position to the next mapping pair. */
id|buf
op_add_assign
(paren
op_star
id|buf
op_amp
l_int|0xf
)paren
op_plus
(paren
(paren
op_star
id|buf
op_rshift
l_int|4
)paren
op_amp
l_int|0xf
)paren
op_plus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|buf
op_ge
id|attr_end
)paren
)paren
r_goto
id|io_error
suffix:semicolon
multiline_comment|/*&n;&t; * If there is a highest_vcn specified, it must be equal to the final&n;&t; * vcn in the runlist - 1, or something has gone badly wrong.&n;&t; */
id|deltaxcn
op_assign
id|sle64_to_cpu
c_func
(paren
id|attr-&gt;data.non_resident.highest_vcn
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|deltaxcn
op_logical_and
id|vcn
op_minus
l_int|1
op_ne
id|deltaxcn
)paren
)paren
(brace
id|mpa_err
suffix:colon
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Corrupt mapping pairs array in &quot;
l_string|&quot;non-resident attribute.&quot;
)paren
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
multiline_comment|/* Setup not mapped runlist element if this is the base extent. */
r_if
c_cond
(paren
op_logical_neg
id|attr-&gt;data.non_resident.lowest_vcn
)paren
(brace
id|VCN
id|max_cluster
suffix:semicolon
id|max_cluster
op_assign
(paren
id|sle64_to_cpu
c_func
(paren
id|attr-&gt;data.non_resident.allocated_size
)paren
op_plus
id|vol-&gt;cluster_size
op_minus
l_int|1
)paren
op_rshift
id|vol-&gt;cluster_size_bits
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If there is a difference between the highest_vcn and the&n;&t;&t; * highest cluster, the runlist is either corrupt or, more&n;&t;&t; * likely, there are more extents following this one.&n;&t;&t; */
r_if
c_cond
(paren
id|deltaxcn
OL
op_decrement
id|max_cluster
)paren
(brace
id|ntfs_debug
c_func
(paren
l_string|&quot;More extents to follow; deltaxcn = 0x%llx, &quot;
l_string|&quot;max_cluster = 0x%llx&quot;
comma
(paren
r_int
r_int
r_int
)paren
id|deltaxcn
comma
(paren
r_int
r_int
r_int
)paren
id|max_cluster
)paren
suffix:semicolon
id|rl
(braket
id|rlpos
)braket
dot
id|vcn
op_assign
id|vcn
suffix:semicolon
id|vcn
op_add_assign
id|rl
(braket
id|rlpos
)braket
dot
id|length
op_assign
id|max_cluster
op_minus
id|deltaxcn
suffix:semicolon
id|rl
(braket
id|rlpos
)braket
dot
id|lcn
op_assign
(paren
id|LCN
)paren
id|LCN_RL_NOT_MAPPED
suffix:semicolon
id|rlpos
op_increment
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|deltaxcn
OG
id|max_cluster
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Corrupt attribute. deltaxcn = &quot;
l_string|&quot;0x%llx, max_cluster = 0x%llx&quot;
comma
(paren
r_int
r_int
r_int
)paren
id|deltaxcn
comma
(paren
r_int
r_int
r_int
)paren
id|max_cluster
)paren
suffix:semicolon
r_goto
id|mpa_err
suffix:semicolon
)brace
id|rl
(braket
id|rlpos
)braket
dot
id|lcn
op_assign
(paren
id|LCN
)paren
id|LCN_ENOENT
suffix:semicolon
)brace
r_else
multiline_comment|/* Not the base extent. There may be more extents to follow. */
id|rl
(braket
id|rlpos
)braket
dot
id|lcn
op_assign
(paren
id|LCN
)paren
id|LCN_RL_NOT_MAPPED
suffix:semicolon
multiline_comment|/* Setup terminating runlist element. */
id|rl
(braket
id|rlpos
)braket
dot
id|vcn
op_assign
id|vcn
suffix:semicolon
id|rl
(braket
id|rlpos
)braket
dot
id|length
op_assign
(paren
id|s64
)paren
l_int|0
suffix:semicolon
multiline_comment|/* If no existing runlist was specified, we are done. */
r_if
c_cond
(paren
op_logical_neg
id|old_rl
)paren
(brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Mapping pairs array successfully decompressed:&quot;
)paren
suffix:semicolon
id|ntfs_debug_dump_runlist
c_func
(paren
id|rl
)paren
suffix:semicolon
r_return
id|rl
suffix:semicolon
)brace
multiline_comment|/* Now combine the new and old runlists checking for overlaps. */
id|old_rl
op_assign
id|ntfs_merge_runlists
c_func
(paren
id|old_rl
comma
id|rl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
op_logical_neg
id|IS_ERR
c_func
(paren
id|old_rl
)paren
)paren
)paren
r_return
id|old_rl
suffix:semicolon
id|ntfs_free
c_func
(paren
id|rl
)paren
suffix:semicolon
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Failed to merge runlists.&quot;
)paren
suffix:semicolon
r_return
id|old_rl
suffix:semicolon
id|io_error
suffix:colon
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Corrupt attribute.&quot;
)paren
suffix:semicolon
id|err_out
suffix:colon
id|ntfs_free
c_func
(paren
id|rl
)paren
suffix:semicolon
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|EIO
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_rl_vcn_to_lcn - convert a vcn into a lcn given a runlist&n; * @rl:&t;&t;runlist to use for conversion&n; * @vcn:&t;vcn to convert&n; *&n; * Convert the virtual cluster number @vcn of an attribute into a logical&n; * cluster number (lcn) of a device using the runlist @rl to map vcns to their&n; * corresponding lcns.&n; *&n; * It is up to the caller to serialize access to the runlist @rl.&n; *&n; * Since lcns must be &gt;= 0, we use negative return values with special meaning:&n; *&n; * Return value&t;&t;&t;Meaning / Description&n; * ==================================================&n; *  -1 = LCN_HOLE&t;&t;Hole / not allocated on disk.&n; *  -2 = LCN_RL_NOT_MAPPED&t;This is part of the runlist which has not been&n; *&t;&t;&t;&t;inserted into the runlist yet.&n; *  -3 = LCN_ENOENT&t;&t;There is no such vcn in the attribute.&n; *&n; * Locking: - The caller must have locked the runlist (for reading or writing).&n; *&t;    - This function does not touch the lock.&n; */
DECL|function|ntfs_rl_vcn_to_lcn
id|LCN
id|ntfs_rl_vcn_to_lcn
c_func
(paren
r_const
id|runlist_element
op_star
id|rl
comma
r_const
id|VCN
id|vcn
)paren
(brace
r_int
id|i
suffix:semicolon
id|BUG_ON
c_func
(paren
id|vcn
OL
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If rl is NULL, assume that we have found an unmapped runlist. The&n;&t; * caller can then attempt to map it and fail appropriately if&n;&t; * necessary.&n;&t; */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|rl
)paren
)paren
r_return
(paren
id|LCN
)paren
id|LCN_RL_NOT_MAPPED
suffix:semicolon
multiline_comment|/* Catch out of lower bounds vcn. */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|vcn
OL
id|rl
(braket
l_int|0
)braket
dot
id|vcn
)paren
)paren
r_return
(paren
id|LCN
)paren
id|LCN_ENOENT
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|likely
c_func
(paren
id|rl
(braket
id|i
)braket
dot
id|length
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|vcn
OL
id|rl
(braket
id|i
op_plus
l_int|1
)braket
dot
id|vcn
)paren
)paren
(brace
r_if
c_cond
(paren
id|likely
c_func
(paren
id|rl
(braket
id|i
)braket
dot
id|lcn
op_ge
(paren
id|LCN
)paren
l_int|0
)paren
)paren
r_return
id|rl
(braket
id|i
)braket
dot
id|lcn
op_plus
(paren
id|vcn
op_minus
id|rl
(braket
id|i
)braket
dot
id|vcn
)paren
suffix:semicolon
r_return
id|rl
(braket
id|i
)braket
dot
id|lcn
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * The terminator element is setup to the correct value, i.e. one of&n;&t; * LCN_HOLE, LCN_RL_NOT_MAPPED, or LCN_ENOENT.&n;&t; */
r_if
c_cond
(paren
id|likely
c_func
(paren
id|rl
(braket
id|i
)braket
dot
id|lcn
OL
(paren
id|LCN
)paren
l_int|0
)paren
)paren
r_return
id|rl
(braket
id|i
)braket
dot
id|lcn
suffix:semicolon
multiline_comment|/* Just in case... We could replace this with BUG() some day. */
r_return
(paren
id|LCN
)paren
id|LCN_ENOENT
suffix:semicolon
)brace
eof
