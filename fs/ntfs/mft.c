multiline_comment|/**&n; * mft.c - NTFS kernel mft record operations. Part of the Linux-NTFS project.&n; *&n; * Copyright (c) 2001-2004 Anton Altaparmakov&n; * Copyright (c) 2002 Richard Russon&n; *&n; * This program/include file is free software; you can redistribute it and/or&n; * modify it under the terms of the GNU General Public License as published&n; * by the Free Software Foundation; either version 2 of the License, or&n; * (at your option) any later version.&n; *&n; * This program/include file is distributed in the hope that it will be&n; * useful, but WITHOUT ANY WARRANTY; without even the implied warranty&n; * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; * GNU General Public License for more details.&n; *&n; * You should have received a copy of the GNU General Public License&n; * along with this program (in the main directory of the Linux-NTFS&n; * distribution in the file COPYING); if not, write to the Free Software&n; * Foundation,Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA&n; */
macro_line|#include &lt;linux/buffer_head.h&gt;
macro_line|#include &lt;linux/swap.h&gt;
macro_line|#include &quot;bitmap.h&quot;
macro_line|#include &quot;lcnalloc.h&quot;
macro_line|#include &quot;aops.h&quot;
macro_line|#include &quot;debug.h&quot;
macro_line|#include &quot;mft.h&quot;
macro_line|#include &quot;malloc.h&quot;
macro_line|#include &quot;ntfs.h&quot;
multiline_comment|/**&n; * __format_mft_record - initialize an empty mft record&n; * @m:&t;&t;mapped, pinned and locked for writing mft record&n; * @size:&t;size of the mft record&n; * @rec_no:&t;mft record number / inode number&n; *&n; * Private function to initialize an empty mft record. Use one of the two&n; * provided format_mft_record() functions instead.&n; */
DECL|function|__format_mft_record
r_static
r_void
id|__format_mft_record
c_func
(paren
id|MFT_RECORD
op_star
id|m
comma
r_const
r_int
id|size
comma
r_const
r_int
r_int
id|rec_no
)paren
(brace
id|ATTR_RECORD
op_star
id|a
suffix:semicolon
id|memset
c_func
(paren
id|m
comma
l_int|0
comma
id|size
)paren
suffix:semicolon
id|m-&gt;magic
op_assign
id|magic_FILE
suffix:semicolon
multiline_comment|/* Aligned to 2-byte boundary. */
id|m-&gt;usa_ofs
op_assign
id|cpu_to_le16
c_func
(paren
(paren
r_sizeof
(paren
id|MFT_RECORD
)paren
op_plus
l_int|1
)paren
op_amp
op_complement
l_int|1
)paren
suffix:semicolon
id|m-&gt;usa_count
op_assign
id|cpu_to_le16
c_func
(paren
id|size
op_div
id|NTFS_BLOCK_SIZE
op_plus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Set the update sequence number to 1. */
op_star
(paren
id|le16
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|m
op_plus
(paren
(paren
r_sizeof
(paren
id|MFT_RECORD
)paren
op_plus
l_int|1
)paren
op_amp
op_complement
l_int|1
)paren
)paren
op_assign
id|cpu_to_le16
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|m-&gt;lsn
op_assign
id|cpu_to_le64
c_func
(paren
l_int|0LL
)paren
suffix:semicolon
id|m-&gt;sequence_number
op_assign
id|cpu_to_le16
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|m-&gt;link_count
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Aligned to 8-byte boundary. */
id|m-&gt;attrs_offset
op_assign
id|cpu_to_le16
c_func
(paren
(paren
id|le16_to_cpu
c_func
(paren
id|m-&gt;usa_ofs
)paren
op_plus
(paren
id|le16_to_cpu
c_func
(paren
id|m-&gt;usa_count
)paren
op_lshift
l_int|1
)paren
op_plus
l_int|7
)paren
op_amp
op_complement
l_int|7
)paren
suffix:semicolon
id|m-&gt;flags
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Using attrs_offset plus eight bytes (for the termination attribute),&n;&t; * aligned to 8-byte boundary.&n;&t; */
id|m-&gt;bytes_in_use
op_assign
id|cpu_to_le32
c_func
(paren
(paren
id|le16_to_cpu
c_func
(paren
id|m-&gt;attrs_offset
)paren
op_plus
l_int|8
op_plus
l_int|7
)paren
op_amp
op_complement
l_int|7
)paren
suffix:semicolon
id|m-&gt;bytes_allocated
op_assign
id|cpu_to_le32
c_func
(paren
id|size
)paren
suffix:semicolon
id|m-&gt;base_mft_record
op_assign
id|cpu_to_le64
c_func
(paren
(paren
id|MFT_REF
)paren
l_int|0
)paren
suffix:semicolon
id|m-&gt;next_attr_instance
op_assign
l_int|0
suffix:semicolon
id|a
op_assign
(paren
id|ATTR_RECORD
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|m
op_plus
id|le16_to_cpu
c_func
(paren
id|m-&gt;attrs_offset
)paren
)paren
suffix:semicolon
id|a-&gt;type
op_assign
id|AT_END
suffix:semicolon
id|a-&gt;length
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * format_mft_record - initialize an empty mft record&n; * @ni:&t;&t;ntfs inode of mft record&n; * @mft_rec:&t;mapped, pinned and locked mft record (optional)&n; *&n; * Initialize an empty mft record. This is used when extending the MFT.&n; *&n; * If @mft_rec is NULL, we call map_mft_record() to obtain the&n; * record and we unmap it again when finished.&n; *&n; * We return 0 on success or -errno on error.&n; */
DECL|function|format_mft_record
r_int
id|format_mft_record
c_func
(paren
id|ntfs_inode
op_star
id|ni
comma
id|MFT_RECORD
op_star
id|mft_rec
)paren
(brace
id|MFT_RECORD
op_star
id|m
suffix:semicolon
r_if
c_cond
(paren
id|mft_rec
)paren
id|m
op_assign
id|mft_rec
suffix:semicolon
r_else
(brace
id|m
op_assign
id|map_mft_record
c_func
(paren
id|ni
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|m
)paren
)paren
r_return
id|PTR_ERR
c_func
(paren
id|m
)paren
suffix:semicolon
)brace
id|__format_mft_record
c_func
(paren
id|m
comma
id|ni-&gt;vol-&gt;mft_record_size
comma
id|ni-&gt;mft_no
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mft_rec
)paren
(brace
singleline_comment|// FIXME: Need to set the mft record dirty!
id|unmap_mft_record
c_func
(paren
id|ni
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_readpage - external declaration, function is in fs/ntfs/aops.c&n; */
r_extern
r_int
id|ntfs_readpage
c_func
(paren
r_struct
id|file
op_star
comma
r_struct
id|page
op_star
)paren
suffix:semicolon
macro_line|#ifdef NTFS_RW
multiline_comment|/**&n; * ntfs_mft_writepage - forward declaration, function is further below&n; */
r_static
r_int
id|ntfs_mft_writepage
c_func
(paren
r_struct
id|page
op_star
id|page
comma
r_struct
id|writeback_control
op_star
id|wbc
)paren
suffix:semicolon
macro_line|#endif /* NTFS_RW */
multiline_comment|/**&n; * ntfs_mft_aops - address space operations for access to $MFT&n; *&n; * Address space operations for access to $MFT. This allows us to simply use&n; * ntfs_map_page() in map_mft_record_page().&n; */
DECL|variable|ntfs_mft_aops
r_struct
id|address_space_operations
id|ntfs_mft_aops
op_assign
(brace
dot
id|readpage
op_assign
id|ntfs_readpage
comma
multiline_comment|/* Fill page with data. */
dot
id|sync_page
op_assign
id|block_sync_page
comma
multiline_comment|/* Currently, just unplugs the&n;&t;&t;&t;&t;&t;&t;   disk request queue. */
macro_line|#ifdef NTFS_RW
dot
id|writepage
op_assign
id|ntfs_mft_writepage
comma
multiline_comment|/* Write out the dirty mft&n;&t;&t;&t;&t;&t;&t;   records in a page. */
dot
id|set_page_dirty
op_assign
id|__set_page_dirty_nobuffers
comma
multiline_comment|/* Set the page dirty&n;&t;&t;&t;&t;&t;&t;   without touching the buffers&n;&t;&t;&t;&t;&t;&t;   belonging to the page. */
macro_line|#endif /* NTFS_RW */
)brace
suffix:semicolon
multiline_comment|/**&n; * map_mft_record_page - map the page in which a specific mft record resides&n; * @ni:&t;&t;ntfs inode whose mft record page to map&n; *&n; * This maps the page in which the mft record of the ntfs inode @ni is situated&n; * and returns a pointer to the mft record within the mapped page.&n; *&n; * Return value needs to be checked with IS_ERR() and if that is true PTR_ERR()&n; * contains the negative error code returned.&n; */
DECL|function|map_mft_record_page
r_static
r_inline
id|MFT_RECORD
op_star
id|map_mft_record_page
c_func
(paren
id|ntfs_inode
op_star
id|ni
)paren
(brace
id|ntfs_volume
op_star
id|vol
op_assign
id|ni-&gt;vol
suffix:semicolon
r_struct
id|inode
op_star
id|mft_vi
op_assign
id|vol-&gt;mft_ino
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
r_int
r_int
id|index
comma
id|ofs
comma
id|end_index
suffix:semicolon
id|BUG_ON
c_func
(paren
id|ni-&gt;page
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * The index into the page cache and the offset within the page cache&n;&t; * page of the wanted mft record. FIXME: We need to check for&n;&t; * overflowing the unsigned long, but I don&squot;t think we would ever get&n;&t; * here if the volume was that big...&n;&t; */
id|index
op_assign
id|ni-&gt;mft_no
op_lshift
id|vol-&gt;mft_record_size_bits
op_rshift
id|PAGE_CACHE_SHIFT
suffix:semicolon
id|ofs
op_assign
(paren
id|ni-&gt;mft_no
op_lshift
id|vol-&gt;mft_record_size_bits
)paren
op_amp
op_complement
id|PAGE_CACHE_MASK
suffix:semicolon
multiline_comment|/* The maximum valid index into the page cache for $MFT&squot;s data. */
id|end_index
op_assign
id|mft_vi-&gt;i_size
op_rshift
id|PAGE_CACHE_SHIFT
suffix:semicolon
multiline_comment|/* If the wanted index is out of bounds the mft record doesn&squot;t exist. */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|index
op_ge
id|end_index
)paren
)paren
(brace
r_if
c_cond
(paren
id|index
OG
id|end_index
op_logical_or
(paren
id|mft_vi-&gt;i_size
op_amp
op_complement
id|PAGE_CACHE_MASK
)paren
OL
id|ofs
op_plus
id|vol-&gt;mft_record_size
)paren
(brace
id|page
op_assign
id|ERR_PTR
c_func
(paren
op_minus
id|ENOENT
)paren
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
)brace
multiline_comment|/* Read, map, and pin the page. */
id|page
op_assign
id|ntfs_map_page
c_func
(paren
id|mft_vi-&gt;i_mapping
comma
id|index
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
op_logical_neg
id|IS_ERR
c_func
(paren
id|page
)paren
)paren
)paren
(brace
id|ni-&gt;page
op_assign
id|page
suffix:semicolon
id|ni-&gt;page_ofs
op_assign
id|ofs
suffix:semicolon
r_return
id|page_address
c_func
(paren
id|page
)paren
op_plus
id|ofs
suffix:semicolon
)brace
id|err_out
suffix:colon
id|ni-&gt;page
op_assign
l_int|NULL
suffix:semicolon
id|ni-&gt;page_ofs
op_assign
l_int|0
suffix:semicolon
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Failed with error code %lu.&quot;
comma
op_minus
id|PTR_ERR
c_func
(paren
id|page
)paren
)paren
suffix:semicolon
r_return
(paren
r_void
op_star
)paren
id|page
suffix:semicolon
)brace
multiline_comment|/**&n; * map_mft_record - map, pin and lock an mft record&n; * @ni:&t;&t;ntfs inode whose MFT record to map&n; *&n; * First, take the mrec_lock semaphore. We might now be sleeping, while waiting&n; * for the semaphore if it was already locked by someone else.&n; *&n; * The page of the record is mapped using map_mft_record_page() before being&n; * returned to the caller.&n; *&n; * This in turn uses ntfs_map_page() to get the page containing the wanted mft&n; * record (it in turn calls read_cache_page() which reads it in from disk if&n; * necessary, increments the use count on the page so that it cannot disappear&n; * under us and returns a reference to the page cache page).&n; *&n; * If read_cache_page() invokes ntfs_readpage() to load the page from disk, it&n; * sets PG_locked and clears PG_uptodate on the page. Once I/O has completed&n; * and the post-read mst fixups on each mft record in the page have been&n; * performed, the page gets PG_uptodate set and PG_locked cleared (this is done&n; * in our asynchronous I/O completion handler end_buffer_read_mft_async()).&n; * ntfs_map_page() waits for PG_locked to become clear and checks if&n; * PG_uptodate is set and returns an error code if not. This provides&n; * sufficient protection against races when reading/using the page.&n; *&n; * However there is the write mapping to think about. Doing the above described&n; * checking here will be fine, because when initiating the write we will set&n; * PG_locked and clear PG_uptodate making sure nobody is touching the page&n; * contents. Doing the locking this way means that the commit to disk code in&n; * the page cache code paths is automatically sufficiently locked with us as&n; * we will not touch a page that has been locked or is not uptodate. The only&n; * locking problem then is them locking the page while we are accessing it.&n; *&n; * So that code will end up having to own the mrec_lock of all mft&n; * records/inodes present in the page before I/O can proceed. In that case we&n; * wouldn&squot;t need to bother with PG_locked and PG_uptodate as nobody will be&n; * accessing anything without owning the mrec_lock semaphore. But we do need&n; * to use them because of the read_cache_page() invocation and the code becomes&n; * so much simpler this way that it is well worth it.&n; *&n; * The mft record is now ours and we return a pointer to it. You need to check&n; * the returned pointer with IS_ERR() and if that is true, PTR_ERR() will return&n; * the error code.&n; *&n; * NOTE: Caller is responsible for setting the mft record dirty before calling&n; * unmap_mft_record(). This is obviously only necessary if the caller really&n; * modified the mft record...&n; * Q: Do we want to recycle one of the VFS inode state bits instead?&n; * A: No, the inode ones mean we want to change the mft record, not we want to&n; * write it out.&n; */
DECL|function|map_mft_record
id|MFT_RECORD
op_star
id|map_mft_record
c_func
(paren
id|ntfs_inode
op_star
id|ni
)paren
(brace
id|MFT_RECORD
op_star
id|m
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Entering for mft_no 0x%lx.&quot;
comma
id|ni-&gt;mft_no
)paren
suffix:semicolon
multiline_comment|/* Make sure the ntfs inode doesn&squot;t go away. */
id|atomic_inc
c_func
(paren
op_amp
id|ni-&gt;count
)paren
suffix:semicolon
multiline_comment|/* Serialize access to this mft record. */
id|down
c_func
(paren
op_amp
id|ni-&gt;mrec_lock
)paren
suffix:semicolon
id|m
op_assign
id|map_mft_record_page
c_func
(paren
id|ni
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
op_logical_neg
id|IS_ERR
c_func
(paren
id|m
)paren
)paren
)paren
r_return
id|m
suffix:semicolon
id|up
c_func
(paren
op_amp
id|ni-&gt;mrec_lock
)paren
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|ni-&gt;count
)paren
suffix:semicolon
id|ntfs_error
c_func
(paren
id|ni-&gt;vol-&gt;sb
comma
l_string|&quot;Failed with error code %lu.&quot;
comma
op_minus
id|PTR_ERR
c_func
(paren
id|m
)paren
)paren
suffix:semicolon
r_return
id|m
suffix:semicolon
)brace
multiline_comment|/**&n; * unmap_mft_record_page - unmap the page in which a specific mft record resides&n; * @ni:&t;&t;ntfs inode whose mft record page to unmap&n; *&n; * This unmaps the page in which the mft record of the ntfs inode @ni is&n; * situated and returns. This is a NOOP if highmem is not configured.&n; *&n; * The unmap happens via ntfs_unmap_page() which in turn decrements the use&n; * count on the page thus releasing it from the pinned state.&n; *&n; * We do not actually unmap the page from memory of course, as that will be&n; * done by the page cache code itself when memory pressure increases or&n; * whatever.&n; */
DECL|function|unmap_mft_record_page
r_static
r_inline
r_void
id|unmap_mft_record_page
c_func
(paren
id|ntfs_inode
op_star
id|ni
)paren
(brace
id|BUG_ON
c_func
(paren
op_logical_neg
id|ni-&gt;page
)paren
suffix:semicolon
singleline_comment|// TODO: If dirty, blah...
id|ntfs_unmap_page
c_func
(paren
id|ni-&gt;page
)paren
suffix:semicolon
id|ni-&gt;page
op_assign
l_int|NULL
suffix:semicolon
id|ni-&gt;page_ofs
op_assign
l_int|0
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/**&n; * unmap_mft_record - release a mapped mft record&n; * @ni:&t;&t;ntfs inode whose MFT record to unmap&n; *&n; * We release the page mapping and the mrec_lock mutex which unmaps the mft&n; * record and releases it for others to get hold of. We also release the ntfs&n; * inode by decrementing the ntfs inode reference count.&n; *&n; * NOTE: If caller has modified the mft record, it is imperative to set the mft&n; * record dirty BEFORE calling unmap_mft_record().&n; */
DECL|function|unmap_mft_record
r_void
id|unmap_mft_record
c_func
(paren
id|ntfs_inode
op_star
id|ni
)paren
(brace
r_struct
id|page
op_star
id|page
op_assign
id|ni-&gt;page
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|page
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Entering for mft_no 0x%lx.&quot;
comma
id|ni-&gt;mft_no
)paren
suffix:semicolon
id|unmap_mft_record_page
c_func
(paren
id|ni
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|ni-&gt;mrec_lock
)paren
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|ni-&gt;count
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If pure ntfs_inode, i.e. no vfs inode attached, we leave it to&n;&t; * ntfs_clear_extent_inode() in the extent inode case, and to the&n;&t; * caller in the non-extent, yet pure ntfs inode case, to do the actual&n;&t; * tear down of all structures and freeing of all allocated memory.&n;&t; */
r_return
suffix:semicolon
)brace
multiline_comment|/**&n; * map_extent_mft_record - load an extent inode and attach it to its base&n; * @base_ni:&t;base ntfs inode&n; * @mref:&t;mft reference of the extent inode to load&n; * @ntfs_ino:&t;on successful return, pointer to the ntfs_inode structure&n; *&n; * Load the extent mft record @mref and attach it to its base inode @base_ni.&n; * Return the mapped extent mft record if IS_ERR(result) is false.  Otherwise&n; * PTR_ERR(result) gives the negative error code.&n; *&n; * On successful return, @ntfs_ino contains a pointer to the ntfs_inode&n; * structure of the mapped extent inode.&n; */
DECL|function|map_extent_mft_record
id|MFT_RECORD
op_star
id|map_extent_mft_record
c_func
(paren
id|ntfs_inode
op_star
id|base_ni
comma
id|MFT_REF
id|mref
comma
id|ntfs_inode
op_star
op_star
id|ntfs_ino
)paren
(brace
id|MFT_RECORD
op_star
id|m
suffix:semicolon
id|ntfs_inode
op_star
id|ni
op_assign
l_int|NULL
suffix:semicolon
id|ntfs_inode
op_star
op_star
id|extent_nis
op_assign
l_int|NULL
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
r_int
id|mft_no
op_assign
id|MREF
c_func
(paren
id|mref
)paren
suffix:semicolon
id|u16
id|seq_no
op_assign
id|MSEQNO
c_func
(paren
id|mref
)paren
suffix:semicolon
id|BOOL
id|destroy_ni
op_assign
id|FALSE
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Mapping extent mft record 0x%lx (base mft record 0x%lx).&quot;
comma
id|mft_no
comma
id|base_ni-&gt;mft_no
)paren
suffix:semicolon
multiline_comment|/* Make sure the base ntfs inode doesn&squot;t go away. */
id|atomic_inc
c_func
(paren
op_amp
id|base_ni-&gt;count
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Check if this extent inode has already been added to the base inode,&n;&t; * in which case just return it. If not found, add it to the base&n;&t; * inode before returning it.&n;&t; */
id|down
c_func
(paren
op_amp
id|base_ni-&gt;extent_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|base_ni-&gt;nr_extents
OG
l_int|0
)paren
(brace
id|extent_nis
op_assign
id|base_ni-&gt;ext.extent_ntfs_inos
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|base_ni-&gt;nr_extents
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|mft_no
op_ne
id|extent_nis
(braket
id|i
)braket
op_member_access_from_pointer
id|mft_no
)paren
r_continue
suffix:semicolon
id|ni
op_assign
id|extent_nis
(braket
id|i
)braket
suffix:semicolon
multiline_comment|/* Make sure the ntfs inode doesn&squot;t go away. */
id|atomic_inc
c_func
(paren
op_amp
id|ni-&gt;count
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|likely
c_func
(paren
id|ni
op_ne
l_int|NULL
)paren
)paren
(brace
id|up
c_func
(paren
op_amp
id|base_ni-&gt;extent_lock
)paren
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|base_ni-&gt;count
)paren
suffix:semicolon
multiline_comment|/* We found the record; just have to map and return it. */
id|m
op_assign
id|map_mft_record
c_func
(paren
id|ni
)paren
suffix:semicolon
multiline_comment|/* map_mft_record() has incremented this on success. */
id|atomic_dec
c_func
(paren
op_amp
id|ni-&gt;count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
op_logical_neg
id|IS_ERR
c_func
(paren
id|m
)paren
)paren
)paren
(brace
multiline_comment|/* Verify the sequence number. */
r_if
c_cond
(paren
id|likely
c_func
(paren
id|le16_to_cpu
c_func
(paren
id|m-&gt;sequence_number
)paren
op_eq
id|seq_no
)paren
)paren
(brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Done 1.&quot;
)paren
suffix:semicolon
op_star
id|ntfs_ino
op_assign
id|ni
suffix:semicolon
r_return
id|m
suffix:semicolon
)brace
id|unmap_mft_record
c_func
(paren
id|ni
)paren
suffix:semicolon
id|ntfs_error
c_func
(paren
id|base_ni-&gt;vol-&gt;sb
comma
l_string|&quot;Found stale extent mft &quot;
l_string|&quot;reference! Corrupt file system. &quot;
l_string|&quot;Run chkdsk.&quot;
)paren
suffix:semicolon
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|EIO
)paren
suffix:semicolon
)brace
id|map_err_out
suffix:colon
id|ntfs_error
c_func
(paren
id|base_ni-&gt;vol-&gt;sb
comma
l_string|&quot;Failed to map extent &quot;
l_string|&quot;mft record, error code %ld.&quot;
comma
op_minus
id|PTR_ERR
c_func
(paren
id|m
)paren
)paren
suffix:semicolon
r_return
id|m
suffix:semicolon
)brace
multiline_comment|/* Record wasn&squot;t there. Get a new ntfs inode and initialize it. */
id|ni
op_assign
id|ntfs_new_extent_inode
c_func
(paren
id|base_ni-&gt;vol-&gt;sb
comma
id|mft_no
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|ni
)paren
)paren
(brace
id|up
c_func
(paren
op_amp
id|base_ni-&gt;extent_lock
)paren
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|base_ni-&gt;count
)paren
suffix:semicolon
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
)brace
id|ni-&gt;vol
op_assign
id|base_ni-&gt;vol
suffix:semicolon
id|ni-&gt;seq_no
op_assign
id|seq_no
suffix:semicolon
id|ni-&gt;nr_extents
op_assign
op_minus
l_int|1
suffix:semicolon
id|ni-&gt;ext.base_ntfs_ino
op_assign
id|base_ni
suffix:semicolon
multiline_comment|/* Now map the record. */
id|m
op_assign
id|map_mft_record
c_func
(paren
id|ni
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|m
)paren
)paren
(brace
id|up
c_func
(paren
op_amp
id|base_ni-&gt;extent_lock
)paren
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|base_ni-&gt;count
)paren
suffix:semicolon
id|ntfs_clear_extent_inode
c_func
(paren
id|ni
)paren
suffix:semicolon
r_goto
id|map_err_out
suffix:semicolon
)brace
multiline_comment|/* Verify the sequence number. */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|le16_to_cpu
c_func
(paren
id|m-&gt;sequence_number
)paren
op_ne
id|seq_no
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|base_ni-&gt;vol-&gt;sb
comma
l_string|&quot;Found stale extent mft &quot;
l_string|&quot;reference! Corrupt file system. Run chkdsk.&quot;
)paren
suffix:semicolon
id|destroy_ni
op_assign
id|TRUE
suffix:semicolon
id|m
op_assign
id|ERR_PTR
c_func
(paren
op_minus
id|EIO
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
multiline_comment|/* Attach extent inode to base inode, reallocating memory if needed. */
r_if
c_cond
(paren
op_logical_neg
(paren
id|base_ni-&gt;nr_extents
op_amp
l_int|3
)paren
)paren
(brace
id|ntfs_inode
op_star
op_star
id|tmp
suffix:semicolon
r_int
id|new_size
op_assign
(paren
id|base_ni-&gt;nr_extents
op_plus
l_int|4
)paren
op_star
r_sizeof
(paren
id|ntfs_inode
op_star
)paren
suffix:semicolon
id|tmp
op_assign
(paren
id|ntfs_inode
op_star
op_star
)paren
id|kmalloc
c_func
(paren
id|new_size
comma
id|GFP_NOFS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|tmp
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|base_ni-&gt;vol-&gt;sb
comma
l_string|&quot;Failed to allocate &quot;
l_string|&quot;internal buffer.&quot;
)paren
suffix:semicolon
id|destroy_ni
op_assign
id|TRUE
suffix:semicolon
id|m
op_assign
id|ERR_PTR
c_func
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|base_ni-&gt;nr_extents
)paren
(brace
id|BUG_ON
c_func
(paren
op_logical_neg
id|base_ni-&gt;ext.extent_ntfs_inos
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|tmp
comma
id|base_ni-&gt;ext.extent_ntfs_inos
comma
id|new_size
op_minus
l_int|4
op_star
r_sizeof
(paren
id|ntfs_inode
op_star
)paren
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|base_ni-&gt;ext.extent_ntfs_inos
)paren
suffix:semicolon
)brace
id|base_ni-&gt;ext.extent_ntfs_inos
op_assign
id|tmp
suffix:semicolon
)brace
id|base_ni-&gt;ext.extent_ntfs_inos
(braket
id|base_ni-&gt;nr_extents
op_increment
)braket
op_assign
id|ni
suffix:semicolon
id|up
c_func
(paren
op_amp
id|base_ni-&gt;extent_lock
)paren
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|base_ni-&gt;count
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Done 2.&quot;
)paren
suffix:semicolon
op_star
id|ntfs_ino
op_assign
id|ni
suffix:semicolon
r_return
id|m
suffix:semicolon
id|unm_err_out
suffix:colon
id|unmap_mft_record
c_func
(paren
id|ni
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|base_ni-&gt;extent_lock
)paren
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|base_ni-&gt;count
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If the extent inode was not attached to the base inode we need to&n;&t; * release it or we will leak memory.&n;&t; */
r_if
c_cond
(paren
id|destroy_ni
)paren
id|ntfs_clear_extent_inode
c_func
(paren
id|ni
)paren
suffix:semicolon
r_return
id|m
suffix:semicolon
)brace
macro_line|#ifdef NTFS_RW
multiline_comment|/**&n; * __mark_mft_record_dirty - set the mft record and the page containing it dirty&n; * @ni:&t;&t;ntfs inode describing the mapped mft record&n; *&n; * Internal function.  Users should call mark_mft_record_dirty() instead.&n; *&n; * Set the mapped (extent) mft record of the (base or extent) ntfs inode @ni,&n; * as well as the page containing the mft record, dirty.  Also, mark the base&n; * vfs inode dirty.  This ensures that any changes to the mft record are&n; * written out to disk.&n; *&n; * NOTE:  We only set I_DIRTY_SYNC and I_DIRTY_DATASYNC (and not I_DIRTY_PAGES)&n; * on the base vfs inode, because even though file data may have been modified,&n; * it is dirty in the inode meta data rather than the data page cache of the&n; * inode, and thus there are no data pages that need writing out.  Therefore, a&n; * full mark_inode_dirty() is overkill.  A mark_inode_dirty_sync(), on the&n; * other hand, is not sufficient, because I_DIRTY_DATASYNC needs to be set to&n; * ensure -&gt;write_inode is called from generic_osync_inode() and this needs to&n; * happen or the file data would not necessarily hit the device synchronously,&n; * even though the vfs inode has the O_SYNC flag set.  Also, I_DIRTY_DATASYNC&n; * simply &quot;feels&quot; better than just I_DIRTY_SYNC, since the file data has not&n; * actually hit the block device yet, which is not what I_DIRTY_SYNC on its own&n; * would suggest.&n; */
DECL|function|__mark_mft_record_dirty
r_void
id|__mark_mft_record_dirty
c_func
(paren
id|ntfs_inode
op_star
id|ni
)paren
(brace
r_struct
id|page
op_star
id|page
op_assign
id|ni-&gt;page
suffix:semicolon
id|ntfs_inode
op_star
id|base_ni
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Entering for inode 0x%lx.&quot;
comma
id|ni-&gt;mft_no
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|page
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|NInoAttr
c_func
(paren
id|ni
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Set the page containing the mft record dirty.  This also marks the&n;&t; * $MFT inode dirty (I_DIRTY_PAGES).&n;&t; */
id|__set_page_dirty_nobuffers
c_func
(paren
id|page
)paren
suffix:semicolon
multiline_comment|/* Determine the base vfs inode and mark it dirty, too. */
id|down
c_func
(paren
op_amp
id|ni-&gt;extent_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
id|ni-&gt;nr_extents
op_ge
l_int|0
)paren
)paren
id|base_ni
op_assign
id|ni
suffix:semicolon
r_else
id|base_ni
op_assign
id|ni-&gt;ext.base_ntfs_ino
suffix:semicolon
id|up
c_func
(paren
op_amp
id|ni-&gt;extent_lock
)paren
suffix:semicolon
id|__mark_inode_dirty
c_func
(paren
id|VFS_I
c_func
(paren
id|base_ni
)paren
comma
id|I_DIRTY_SYNC
op_or
id|I_DIRTY_DATASYNC
)paren
suffix:semicolon
)brace
DECL|variable|ntfs_please_email
r_static
r_const
r_char
op_star
id|ntfs_please_email
op_assign
l_string|&quot;Please email &quot;
l_string|&quot;linux-ntfs-dev@lists.sourceforge.net and say that you saw &quot;
l_string|&quot;this message.  Thank you.&quot;
suffix:semicolon
multiline_comment|/**&n; * sync_mft_mirror_umount - synchronise an mft record to the mft mirror&n; * @ni:&t;&t;ntfs inode whose mft record to synchronize&n; * @m:&t;&t;mapped, mst protected (extent) mft record to synchronize&n; *&n; * Write the mapped, mst protected (extent) mft record @m described by the&n; * (regular or extent) ntfs inode @ni to the mft mirror ($MFTMirr) bypassing&n; * the page cache and the $MFTMirr inode itself.&n; *&n; * This function is only for use at umount time when the mft mirror inode has&n; * already been disposed off.  We BUG() if we are called while the mft mirror&n; * inode is still attached to the volume.&n; *&n; * On success return 0.  On error return -errno.&n; *&n; * NOTE:  This function is not implemented yet as I am not convinced it can&n; * actually be triggered considering the sequence of commits we do in super.c::&n; * ntfs_put_super().  But just in case we provide this place holder as the&n; * alternative would be either to BUG() or to get a NULL pointer dereference&n; * and Oops.&n; */
DECL|function|sync_mft_mirror_umount
r_static
r_int
id|sync_mft_mirror_umount
c_func
(paren
id|ntfs_inode
op_star
id|ni
comma
id|MFT_RECORD
op_star
id|m
)paren
(brace
id|ntfs_volume
op_star
id|vol
op_assign
id|ni-&gt;vol
suffix:semicolon
id|BUG_ON
c_func
(paren
id|vol-&gt;mftmirr_ino
)paren
suffix:semicolon
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Umount time mft mirror syncing is not &quot;
l_string|&quot;implemented yet.  %s&quot;
comma
id|ntfs_please_email
)paren
suffix:semicolon
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
multiline_comment|/**&n; * sync_mft_mirror - synchronize an mft record to the mft mirror&n; * @ni:&t;&t;ntfs inode whose mft record to synchronize&n; * @m:&t;&t;mapped, mst protected (extent) mft record to synchronize&n; * @sync:&t;if true, wait for i/o completion&n; *&n; * Write the mapped, mst protected (extent) mft record @m described by the&n; * (regular or extent) ntfs inode @ni to the mft mirror ($MFTMirr).&n; *&n; * On success return 0.  On error return -errno and set the volume errors flag&n; * in the ntfs_volume to which @ni belongs.&n; *&n; * NOTE:  We always perform synchronous i/o and ignore the @sync parameter.&n; *&n; * TODO:  If @sync is false, want to do truly asynchronous i/o, i.e. just&n; * schedule i/o via -&gt;writepage or do it via kntfsd or whatever.&n; */
DECL|function|sync_mft_mirror
r_static
r_int
id|sync_mft_mirror
c_func
(paren
id|ntfs_inode
op_star
id|ni
comma
id|MFT_RECORD
op_star
id|m
comma
r_int
id|sync
)paren
(brace
id|ntfs_volume
op_star
id|vol
op_assign
id|ni-&gt;vol
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
r_int
r_int
id|blocksize
op_assign
id|vol-&gt;sb-&gt;s_blocksize
suffix:semicolon
r_int
id|max_bhs
op_assign
id|vol-&gt;mft_record_size
op_div
id|blocksize
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bhs
(braket
id|max_bhs
)braket
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
comma
op_star
id|head
suffix:semicolon
id|u8
op_star
id|kmirr
suffix:semicolon
r_int
r_int
id|block_start
comma
id|block_end
comma
id|m_start
comma
id|m_end
suffix:semicolon
r_int
id|i_bhs
comma
id|nr_bhs
comma
id|err
op_assign
l_int|0
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Entering for inode 0x%lx.&quot;
comma
id|ni-&gt;mft_no
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|max_bhs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|vol-&gt;mftmirr_ino
)paren
)paren
(brace
multiline_comment|/* This could happen during umount... */
id|err
op_assign
id|sync_mft_mirror_umount
c_func
(paren
id|ni
comma
id|m
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
op_logical_neg
id|err
)paren
)paren
r_return
id|err
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
multiline_comment|/* Get the page containing the mirror copy of the mft record @m. */
id|page
op_assign
id|ntfs_map_page
c_func
(paren
id|vol-&gt;mftmirr_ino-&gt;i_mapping
comma
id|ni-&gt;mft_no
op_rshift
(paren
id|PAGE_CACHE_SHIFT
op_minus
id|vol-&gt;mft_record_size_bits
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|page
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Failed to map mft mirror page.&quot;
)paren
suffix:semicolon
id|err
op_assign
id|PTR_ERR
c_func
(paren
id|page
)paren
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Exclusion against other writers.   This should never be a problem&n;&t; * since the page in which the mft record @m resides is also locked and&n;&t; * hence any other writers would be held up there but it is better to&n;&t; * make sure no one is writing from elsewhere.&n;&t; */
id|lock_page
c_func
(paren
id|page
)paren
suffix:semicolon
multiline_comment|/* The address in the page of the mirror copy of the mft record @m. */
id|kmirr
op_assign
id|page_address
c_func
(paren
id|page
)paren
op_plus
(paren
(paren
id|ni-&gt;mft_no
op_lshift
id|vol-&gt;mft_record_size_bits
)paren
op_amp
op_complement
id|PAGE_CACHE_MASK
)paren
suffix:semicolon
multiline_comment|/* Copy the mst protected mft record to the mirror. */
id|memcpy
c_func
(paren
id|kmirr
comma
id|m
comma
id|vol-&gt;mft_record_size
)paren
suffix:semicolon
multiline_comment|/* Make sure we have mapped buffers. */
r_if
c_cond
(paren
op_logical_neg
id|page_has_buffers
c_func
(paren
id|page
)paren
)paren
(brace
id|no_buffers_err_out
suffix:colon
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Writing mft mirror records without &quot;
l_string|&quot;existing buffers is not implemented yet.  %s&quot;
comma
id|ntfs_please_email
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EOPNOTSUPP
suffix:semicolon
r_goto
id|unlock_err_out
suffix:semicolon
)brace
id|bh
op_assign
id|head
op_assign
id|page_buffers
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bh
)paren
r_goto
id|no_buffers_err_out
suffix:semicolon
id|nr_bhs
op_assign
l_int|0
suffix:semicolon
id|block_start
op_assign
l_int|0
suffix:semicolon
id|m_start
op_assign
id|kmirr
op_minus
(paren
id|u8
op_star
)paren
id|page_address
c_func
(paren
id|page
)paren
suffix:semicolon
id|m_end
op_assign
id|m_start
op_plus
id|vol-&gt;mft_record_size
suffix:semicolon
r_do
(brace
id|block_end
op_assign
id|block_start
op_plus
id|blocksize
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If the buffer is outside the mft record, just skip it,&n;&t;&t; * clearing it if it is dirty to make sure it is not written&n;&t;&t; * out.  It should never be marked dirty but better be safe.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|block_end
op_le
id|m_start
)paren
op_logical_or
(paren
id|block_start
op_ge
id|m_end
)paren
)paren
(brace
r_if
c_cond
(paren
id|buffer_dirty
c_func
(paren
id|bh
)paren
)paren
(brace
id|ntfs_warning
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Clearing dirty mft &quot;
l_string|&quot;record page buffer.  %s&quot;
comma
id|ntfs_please_email
)paren
suffix:semicolon
id|clear_buffer_dirty
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|buffer_mapped
c_func
(paren
id|bh
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Writing mft mirror records &quot;
l_string|&quot;without existing mapped buffers is &quot;
l_string|&quot;not implemented yet.  %s&quot;
comma
id|ntfs_please_email
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EOPNOTSUPP
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|bh
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Writing mft mirror records &quot;
l_string|&quot;without existing uptodate buffers is &quot;
l_string|&quot;not implemented yet.  %s&quot;
comma
id|ntfs_please_email
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EOPNOTSUPP
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|BUG_ON
c_func
(paren
op_logical_neg
id|nr_bhs
op_logical_and
(paren
id|m_start
op_ne
id|block_start
)paren
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|nr_bhs
op_ge
id|max_bhs
)paren
suffix:semicolon
id|bhs
(braket
id|nr_bhs
op_increment
)braket
op_assign
id|bh
suffix:semicolon
id|BUG_ON
c_func
(paren
(paren
id|nr_bhs
op_ge
id|max_bhs
)paren
op_logical_and
(paren
id|m_end
op_ne
id|block_end
)paren
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|block_start
op_assign
id|block_end
comma
(paren
id|bh
op_assign
id|bh-&gt;b_this_page
)paren
op_ne
id|head
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
op_logical_neg
id|err
)paren
)paren
(brace
multiline_comment|/* Lock buffers and start synchronous write i/o on them. */
r_for
c_loop
(paren
id|i_bhs
op_assign
l_int|0
suffix:semicolon
id|i_bhs
OL
id|nr_bhs
suffix:semicolon
id|i_bhs
op_increment
)paren
(brace
r_struct
id|buffer_head
op_star
id|tbh
op_assign
id|bhs
(braket
id|i_bhs
)braket
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|test_set_buffer_locked
c_func
(paren
id|tbh
)paren
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|tbh
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buffer_dirty
c_func
(paren
id|tbh
)paren
)paren
id|clear_buffer_dirty
c_func
(paren
id|tbh
)paren
suffix:semicolon
id|get_bh
c_func
(paren
id|tbh
)paren
suffix:semicolon
id|tbh-&gt;b_end_io
op_assign
id|end_buffer_write_sync
suffix:semicolon
id|submit_bh
c_func
(paren
id|WRITE
comma
id|tbh
)paren
suffix:semicolon
)brace
multiline_comment|/* Wait on i/o completion of buffers. */
r_for
c_loop
(paren
id|i_bhs
op_assign
l_int|0
suffix:semicolon
id|i_bhs
OL
id|nr_bhs
suffix:semicolon
id|i_bhs
op_increment
)paren
(brace
r_struct
id|buffer_head
op_star
id|tbh
op_assign
id|bhs
(braket
id|i_bhs
)braket
suffix:semicolon
id|wait_on_buffer
c_func
(paren
id|tbh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|tbh
)paren
)paren
)paren
(brace
id|err
op_assign
op_minus
id|EIO
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * Set the buffer uptodate so the page &amp; buffer&n;&t;&t;&t;&t; * states don&squot;t become out of sync.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|PageUptodate
c_func
(paren
id|page
)paren
)paren
id|set_buffer_uptodate
c_func
(paren
id|tbh
)paren
suffix:semicolon
)brace
)brace
)brace
r_else
multiline_comment|/* if (unlikely(err)) */
(brace
multiline_comment|/* Clean the buffers. */
r_for
c_loop
(paren
id|i_bhs
op_assign
l_int|0
suffix:semicolon
id|i_bhs
OL
id|nr_bhs
suffix:semicolon
id|i_bhs
op_increment
)paren
id|clear_buffer_dirty
c_func
(paren
id|bhs
(braket
id|i_bhs
)braket
)paren
suffix:semicolon
)brace
id|unlock_err_out
suffix:colon
multiline_comment|/* Current state: all buffers are clean, unlocked, and uptodate. */
multiline_comment|/* Remove the mst protection fixups again. */
id|post_write_mst_fixup
c_func
(paren
(paren
id|NTFS_RECORD
op_star
)paren
id|kmirr
)paren
suffix:semicolon
id|flush_dcache_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|ntfs_unmap_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|err
)paren
)paren
(brace
multiline_comment|/* I/O error during writing.  This is really bad! */
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;I/O error while writing mft mirror &quot;
l_string|&quot;record 0x%lx!  You should unmount the volume &quot;
l_string|&quot;and run chkdsk or ntfsfix.&quot;
comma
id|ni-&gt;mft_no
)paren
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Done.&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|err_out
suffix:colon
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Failed to synchronize $MFTMirr (error code %i).  &quot;
l_string|&quot;Volume will be left marked dirty on umount.  Run &quot;
l_string|&quot;ntfsfix on the partition after umounting to correct &quot;
l_string|&quot;this.&quot;
comma
op_minus
id|err
)paren
suffix:semicolon
multiline_comment|/* We don&squot;t want to clear the dirty bit on umount. */
id|NVolSetErrors
c_func
(paren
id|vol
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/**&n; * write_mft_record_nolock - write out a mapped (extent) mft record&n; * @ni:&t;&t;ntfs inode describing the mapped (extent) mft record&n; * @m:&t;&t;mapped (extent) mft record to write&n; * @sync:&t;if true, wait for i/o completion&n; *&n; * Write the mapped (extent) mft record @m described by the (regular or extent)&n; * ntfs inode @ni to backing store.  If the mft record @m has a counterpart in&n; * the mft mirror, that is also updated.&n; *&n; * On success, clean the mft record and return 0.  On error, leave the mft&n; * record dirty and return -errno.  The caller should call make_bad_inode() on&n; * the base inode to ensure no more access happens to this inode.  We do not do&n; * it here as the caller may want to finish writing other extent mft records&n; * first to minimize on-disk metadata inconsistencies.&n; *&n; * NOTE:  We always perform synchronous i/o and ignore the @sync parameter.&n; * However, if the mft record has a counterpart in the mft mirror and @sync is&n; * true, we write the mft record, wait for i/o completion, and only then write&n; * the mft mirror copy.  This ensures that if the system crashes either the mft&n; * or the mft mirror will contain a self-consistent mft record @m.  If @sync is&n; * false on the other hand, we start i/o on both and then wait for completion&n; * on them.  This provides a speedup but no longer guarantees that you will end&n; * up with a self-consistent mft record in the case of a crash but if you asked&n; * for asynchronous writing you probably do not care about that anyway.&n; *&n; * TODO:  If @sync is false, want to do truly asynchronous i/o, i.e. just&n; * schedule i/o via -&gt;writepage or do it via kntfsd or whatever.&n; */
DECL|function|write_mft_record_nolock
r_int
id|write_mft_record_nolock
c_func
(paren
id|ntfs_inode
op_star
id|ni
comma
id|MFT_RECORD
op_star
id|m
comma
r_int
id|sync
)paren
(brace
id|ntfs_volume
op_star
id|vol
op_assign
id|ni-&gt;vol
suffix:semicolon
r_struct
id|page
op_star
id|page
op_assign
id|ni-&gt;page
suffix:semicolon
r_int
r_int
id|blocksize
op_assign
id|vol-&gt;sb-&gt;s_blocksize
suffix:semicolon
r_int
id|max_bhs
op_assign
id|vol-&gt;mft_record_size
op_div
id|blocksize
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bhs
(braket
id|max_bhs
)braket
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
comma
op_star
id|head
suffix:semicolon
r_int
r_int
id|block_start
comma
id|block_end
comma
id|m_start
comma
id|m_end
suffix:semicolon
r_int
id|i_bhs
comma
id|nr_bhs
comma
id|err
op_assign
l_int|0
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Entering for inode 0x%lx.&quot;
comma
id|ni-&gt;mft_no
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|NInoAttr
c_func
(paren
id|ni
)paren
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|max_bhs
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|PageLocked
c_func
(paren
id|page
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If the ntfs_inode is clean no need to do anything.  If it is dirty,&n;&t; * mark it as clean now so that it can be redirtied later on if needed.&n;&t; * There is no danger of races since the caller is holding the locks&n;&t; * for the mft record @m and the page it is in.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|NInoTestClearDirty
c_func
(paren
id|ni
)paren
)paren
r_goto
id|done
suffix:semicolon
multiline_comment|/* Make sure we have mapped buffers. */
r_if
c_cond
(paren
op_logical_neg
id|page_has_buffers
c_func
(paren
id|page
)paren
)paren
(brace
id|no_buffers_err_out
suffix:colon
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Writing mft records without existing &quot;
l_string|&quot;buffers is not implemented yet.  %s&quot;
comma
id|ntfs_please_email
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EOPNOTSUPP
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
id|bh
op_assign
id|head
op_assign
id|page_buffers
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bh
)paren
r_goto
id|no_buffers_err_out
suffix:semicolon
id|nr_bhs
op_assign
l_int|0
suffix:semicolon
id|block_start
op_assign
l_int|0
suffix:semicolon
id|m_start
op_assign
id|ni-&gt;page_ofs
suffix:semicolon
id|m_end
op_assign
id|m_start
op_plus
id|vol-&gt;mft_record_size
suffix:semicolon
r_do
(brace
id|block_end
op_assign
id|block_start
op_plus
id|blocksize
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If the buffer is outside the mft record, just skip it,&n;&t;&t; * clearing it if it is dirty to make sure it is not written&n;&t;&t; * out.  It should never be marked dirty but better be safe.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|block_end
op_le
id|m_start
)paren
op_logical_or
(paren
id|block_start
op_ge
id|m_end
)paren
)paren
(brace
r_if
c_cond
(paren
id|buffer_dirty
c_func
(paren
id|bh
)paren
)paren
(brace
id|ntfs_warning
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Clearing dirty mft &quot;
l_string|&quot;record page buffer.  %s&quot;
comma
id|ntfs_please_email
)paren
suffix:semicolon
id|clear_buffer_dirty
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|buffer_mapped
c_func
(paren
id|bh
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Writing mft records without &quot;
l_string|&quot;existing mapped buffers is not &quot;
l_string|&quot;implemented yet.  %s&quot;
comma
id|ntfs_please_email
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EOPNOTSUPP
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|bh
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Writing mft records without &quot;
l_string|&quot;existing uptodate buffers is not &quot;
l_string|&quot;implemented yet.  %s&quot;
comma
id|ntfs_please_email
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EOPNOTSUPP
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|BUG_ON
c_func
(paren
op_logical_neg
id|nr_bhs
op_logical_and
(paren
id|m_start
op_ne
id|block_start
)paren
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|nr_bhs
op_ge
id|max_bhs
)paren
suffix:semicolon
id|bhs
(braket
id|nr_bhs
op_increment
)braket
op_assign
id|bh
suffix:semicolon
id|BUG_ON
c_func
(paren
(paren
id|nr_bhs
op_ge
id|max_bhs
)paren
op_logical_and
(paren
id|m_end
op_ne
id|block_end
)paren
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|block_start
op_assign
id|block_end
comma
(paren
id|bh
op_assign
id|bh-&gt;b_this_page
)paren
op_ne
id|head
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|err
)paren
)paren
r_goto
id|cleanup_out
suffix:semicolon
multiline_comment|/* Apply the mst protection fixups. */
id|err
op_assign
id|pre_write_mst_fixup
c_func
(paren
(paren
id|NTFS_RECORD
op_star
)paren
id|m
comma
id|vol-&gt;mft_record_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Failed to apply mst fixups!&quot;
)paren
suffix:semicolon
r_goto
id|cleanup_out
suffix:semicolon
)brace
id|flush_dcache_mft_record_page
c_func
(paren
id|ni
)paren
suffix:semicolon
multiline_comment|/* Lock buffers and start synchronous write i/o on them. */
r_for
c_loop
(paren
id|i_bhs
op_assign
l_int|0
suffix:semicolon
id|i_bhs
OL
id|nr_bhs
suffix:semicolon
id|i_bhs
op_increment
)paren
(brace
r_struct
id|buffer_head
op_star
id|tbh
op_assign
id|bhs
(braket
id|i_bhs
)braket
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|test_set_buffer_locked
c_func
(paren
id|tbh
)paren
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|tbh
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buffer_dirty
c_func
(paren
id|tbh
)paren
)paren
id|clear_buffer_dirty
c_func
(paren
id|tbh
)paren
suffix:semicolon
id|get_bh
c_func
(paren
id|tbh
)paren
suffix:semicolon
id|tbh-&gt;b_end_io
op_assign
id|end_buffer_write_sync
suffix:semicolon
id|submit_bh
c_func
(paren
id|WRITE
comma
id|tbh
)paren
suffix:semicolon
)brace
multiline_comment|/* Synchronize the mft mirror now if not @sync. */
r_if
c_cond
(paren
op_logical_neg
id|sync
op_logical_and
id|ni-&gt;mft_no
OL
id|vol-&gt;mftmirr_size
)paren
id|sync_mft_mirror
c_func
(paren
id|ni
comma
id|m
comma
id|sync
)paren
suffix:semicolon
multiline_comment|/* Wait on i/o completion of buffers. */
r_for
c_loop
(paren
id|i_bhs
op_assign
l_int|0
suffix:semicolon
id|i_bhs
OL
id|nr_bhs
suffix:semicolon
id|i_bhs
op_increment
)paren
(brace
r_struct
id|buffer_head
op_star
id|tbh
op_assign
id|bhs
(braket
id|i_bhs
)braket
suffix:semicolon
id|wait_on_buffer
c_func
(paren
id|tbh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|tbh
)paren
)paren
)paren
(brace
id|err
op_assign
op_minus
id|EIO
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Set the buffer uptodate so the page &amp; buffer states&n;&t;&t;&t; * don&squot;t become out of sync.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|PageUptodate
c_func
(paren
id|page
)paren
)paren
id|set_buffer_uptodate
c_func
(paren
id|tbh
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* If @sync, now synchronize the mft mirror. */
r_if
c_cond
(paren
id|sync
op_logical_and
id|ni-&gt;mft_no
OL
id|vol-&gt;mftmirr_size
)paren
id|sync_mft_mirror
c_func
(paren
id|ni
comma
id|m
comma
id|sync
)paren
suffix:semicolon
multiline_comment|/* Remove the mst protection fixups again. */
id|post_write_mst_fixup
c_func
(paren
(paren
id|NTFS_RECORD
op_star
)paren
id|m
)paren
suffix:semicolon
id|flush_dcache_mft_record_page
c_func
(paren
id|ni
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|err
)paren
)paren
(brace
multiline_comment|/* I/O error during writing.  This is really bad! */
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;I/O error while writing mft record &quot;
l_string|&quot;0x%lx!  Marking base inode as bad.  You &quot;
l_string|&quot;should unmount the volume and run chkdsk.&quot;
comma
id|ni-&gt;mft_no
)paren
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
id|done
suffix:colon
id|ntfs_debug
c_func
(paren
l_string|&quot;Done.&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|cleanup_out
suffix:colon
multiline_comment|/* Clean the buffers. */
r_for
c_loop
(paren
id|i_bhs
op_assign
l_int|0
suffix:semicolon
id|i_bhs
OL
id|nr_bhs
suffix:semicolon
id|i_bhs
op_increment
)paren
id|clear_buffer_dirty
c_func
(paren
id|bhs
(braket
id|i_bhs
)braket
)paren
suffix:semicolon
id|err_out
suffix:colon
multiline_comment|/*&n;&t; * Current state: all buffers are clean, unlocked, and uptodate.&n;&t; * The caller should mark the base inode as bad so that no more i/o&n;&t; * happens.  -&gt;clear_inode() will still be invoked so all extent inodes&n;&t; * and other allocated memory will be freed.&n;&t; */
r_if
c_cond
(paren
id|err
op_eq
op_minus
id|ENOMEM
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Not enough memory to write mft record.  &quot;
l_string|&quot;Redirtying so the write is retried later.&quot;
)paren
suffix:semicolon
id|mark_mft_record_dirty
c_func
(paren
id|ni
)paren
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_mft_writepage - check if a metadata page contains dirty mft records&n; * @page:&t;metadata page possibly containing dirty mft records&n; * @wbc:&t;writeback control structure&n; *&n; * This is called from the VM when it wants to have a dirty $MFT/$DATA metadata&n; * page cache page cleaned.  The VM has already locked the page and marked it&n; * clean.  Instead of writing the page as a conventional -&gt;writepage function&n; * would do, we check if the page still contains any dirty mft records (it must&n; * have done at some point in the past since the page was marked dirty) and if&n; * none are found, i.e. all mft records are clean, we unlock the page and&n; * return.  The VM is then free to do with the page as it pleases.  If on the&n; * other hand we do find any dirty mft records in the page, we redirty the page&n; * before unlocking it and returning so the VM knows that the page is still&n; * busy and cannot be thrown out.&n; *&n; * Note, we do not actually write any dirty mft records here because they are&n; * dirty inodes and hence will be written by the VFS inode dirty code paths.&n; * There is no need to write them from the VM page dirty code paths, too and in&n; * fact once we implement journalling it would be a complete nightmare having&n; * two code paths leading to mft record writeout.&n; */
DECL|function|ntfs_mft_writepage
r_static
r_int
id|ntfs_mft_writepage
c_func
(paren
r_struct
id|page
op_star
id|page
comma
r_struct
id|writeback_control
op_star
id|wbc
)paren
(brace
r_struct
id|inode
op_star
id|mft_vi
op_assign
id|page-&gt;mapping-&gt;host
suffix:semicolon
r_struct
id|super_block
op_star
id|sb
op_assign
id|mft_vi-&gt;i_sb
suffix:semicolon
id|ntfs_volume
op_star
id|vol
op_assign
id|NTFS_SB
c_func
(paren
id|sb
)paren
suffix:semicolon
id|u8
op_star
id|maddr
suffix:semicolon
id|MFT_RECORD
op_star
id|m
suffix:semicolon
id|ntfs_inode
op_star
op_star
id|extent_nis
suffix:semicolon
r_int
r_int
id|mft_no
suffix:semicolon
r_int
id|nr
comma
id|i
comma
id|j
suffix:semicolon
id|BOOL
id|is_dirty
op_assign
id|FALSE
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|PageLocked
c_func
(paren
id|page
)paren
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|PageWriteback
c_func
(paren
id|page
)paren
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|mft_vi
op_ne
id|vol-&gt;mft_ino
)paren
suffix:semicolon
multiline_comment|/* The first mft record number in the page. */
id|mft_no
op_assign
id|page-&gt;index
op_lshift
(paren
id|PAGE_CACHE_SHIFT
op_minus
id|vol-&gt;mft_record_size_bits
)paren
suffix:semicolon
multiline_comment|/* Number of mft records in the page. */
id|nr
op_assign
id|PAGE_CACHE_SIZE
op_rshift
id|vol-&gt;mft_record_size_bits
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|nr
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Entering for %i inodes starting at 0x%lx.&quot;
comma
id|nr
comma
id|mft_no
)paren
suffix:semicolon
multiline_comment|/* Iterate over the mft records in the page looking for a dirty one. */
id|maddr
op_assign
(paren
id|u8
op_star
)paren
id|kmap
c_func
(paren
id|page
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr
suffix:semicolon
op_increment
id|i
comma
op_increment
id|mft_no
comma
id|maddr
op_add_assign
id|vol-&gt;mft_record_size
)paren
(brace
r_struct
id|inode
op_star
id|vi
suffix:semicolon
id|ntfs_inode
op_star
id|ni
comma
op_star
id|eni
suffix:semicolon
id|ntfs_attr
id|na
suffix:semicolon
id|na.mft_no
op_assign
id|mft_no
suffix:semicolon
id|na.name
op_assign
l_int|NULL
suffix:semicolon
id|na.name_len
op_assign
l_int|0
suffix:semicolon
id|na.type
op_assign
id|AT_UNUSED
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Check if the inode corresponding to this mft record is in&n;&t;&t; * the VFS inode cache and obtain a reference to it if it is.&n;&t;&t; */
id|ntfs_debug
c_func
(paren
l_string|&quot;Looking for inode 0x%lx in icache.&quot;
comma
id|mft_no
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * For inode 0, i.e. $MFT itself, we cannot use ilookup5() from&n;&t;&t; * here or we deadlock because the inode is already locked by&n;&t;&t; * the kernel (fs/fs-writeback.c::__sync_single_inode()) and&n;&t;&t; * ilookup5() waits until the inode is unlocked before&n;&t;&t; * returning it and it never gets unlocked because&n;&t;&t; * ntfs_mft_writepage() never returns.  )-:  Fortunately, we&n;&t;&t; * have inode 0 pinned in icache for the duration of the mount&n;&t;&t; * so we can access it directly.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|mft_no
)paren
(brace
multiline_comment|/* Balance the below iput(). */
id|vi
op_assign
id|igrab
c_func
(paren
id|mft_vi
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|vi
op_ne
id|mft_vi
)paren
suffix:semicolon
)brace
r_else
id|vi
op_assign
id|ilookup5
c_func
(paren
id|sb
comma
id|mft_no
comma
(paren
id|test_t
)paren
id|ntfs_test_inode
comma
op_amp
id|na
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vi
)paren
(brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Inode 0x%lx is in icache.&quot;
comma
id|mft_no
)paren
suffix:semicolon
multiline_comment|/* The inode is in icache.  Check if it is dirty. */
id|ni
op_assign
id|NTFS_I
c_func
(paren
id|vi
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|NInoDirty
c_func
(paren
id|ni
)paren
)paren
(brace
multiline_comment|/* The inode is not dirty, skip this record. */
id|ntfs_debug
c_func
(paren
l_string|&quot;Inode 0x%lx is not dirty, &quot;
l_string|&quot;continuing search.&quot;
comma
id|mft_no
)paren
suffix:semicolon
id|iput
c_func
(paren
id|vi
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Inode 0x%lx is dirty, aborting search.&quot;
comma
id|mft_no
)paren
suffix:semicolon
multiline_comment|/* The inode is dirty, no need to search further. */
id|iput
c_func
(paren
id|vi
)paren
suffix:semicolon
id|is_dirty
op_assign
id|TRUE
suffix:semicolon
r_break
suffix:semicolon
)brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Inode 0x%lx is not in icache.&quot;
comma
id|mft_no
)paren
suffix:semicolon
multiline_comment|/* The inode is not in icache. */
multiline_comment|/* Skip the record if it is not a mft record (type &quot;FILE&quot;). */
r_if
c_cond
(paren
op_logical_neg
id|ntfs_is_mft_recordp
c_func
(paren
(paren
id|le32
op_star
)paren
id|maddr
)paren
)paren
(brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Mft record 0x%lx is not a FILE record, &quot;
l_string|&quot;continuing search.&quot;
comma
id|mft_no
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|m
op_assign
(paren
id|MFT_RECORD
op_star
)paren
id|maddr
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Skip the mft record if it is not in use.  FIXME:  What about&n;&t;&t; * deleted/deallocated (extent) inodes?  (AIA)&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|m-&gt;flags
op_amp
id|MFT_RECORD_IN_USE
)paren
)paren
(brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Mft record 0x%lx is not in use, &quot;
l_string|&quot;continuing search.&quot;
comma
id|mft_no
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* Skip the mft record if it is a base inode. */
r_if
c_cond
(paren
op_logical_neg
id|m-&gt;base_mft_record
)paren
(brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Mft record 0x%lx is a base record, &quot;
l_string|&quot;continuing search.&quot;
comma
id|mft_no
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * This is an extent mft record.  Check if the inode&n;&t;&t; * corresponding to its base mft record is in icache.&n;&t;&t; */
id|na.mft_no
op_assign
id|MREF_LE
c_func
(paren
id|m-&gt;base_mft_record
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Mft record 0x%lx is an extent record.  Looking &quot;
l_string|&quot;for base inode 0x%lx in icache.&quot;
comma
id|mft_no
comma
id|na.mft_no
)paren
suffix:semicolon
id|vi
op_assign
id|ilookup5
c_func
(paren
id|sb
comma
id|na.mft_no
comma
(paren
id|test_t
)paren
id|ntfs_test_inode
comma
op_amp
id|na
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vi
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * The base inode is not in icache.  Skip this extent&n;&t;&t;&t; * mft record.&n;&t;&t;&t; */
id|ntfs_debug
c_func
(paren
l_string|&quot;Base inode 0x%lx is not in icache, &quot;
l_string|&quot;continuing search.&quot;
comma
id|na.mft_no
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Base inode 0x%lx is in icache.&quot;
comma
id|na.mft_no
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * The base inode is in icache.  Check if it has the extent&n;&t;&t; * inode corresponding to this extent mft record attached.&n;&t;&t; */
id|ni
op_assign
id|NTFS_I
c_func
(paren
id|vi
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|ni-&gt;extent_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ni-&gt;nr_extents
op_le
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * The base inode has no attached extent inodes.  Skip&n;&t;&t;&t; * this extent mft record.&n;&t;&t;&t; */
id|up
c_func
(paren
op_amp
id|ni-&gt;extent_lock
)paren
suffix:semicolon
id|iput
c_func
(paren
id|vi
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* Iterate over the attached extent inodes. */
id|extent_nis
op_assign
id|ni-&gt;ext.extent_ntfs_inos
suffix:semicolon
r_for
c_loop
(paren
id|eni
op_assign
l_int|NULL
comma
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|ni-&gt;nr_extents
suffix:semicolon
op_increment
id|j
)paren
(brace
r_if
c_cond
(paren
id|mft_no
op_eq
id|extent_nis
(braket
id|j
)braket
op_member_access_from_pointer
id|mft_no
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * Found the extent inode corresponding to this&n;&t;&t;&t;&t; * extent mft record.&n;&t;&t;&t;&t; */
id|eni
op_assign
id|extent_nis
(braket
id|j
)braket
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t; * If the extent inode was not attached to the base inode, skip&n;&t;&t; * this extent mft record.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|eni
)paren
(brace
id|up
c_func
(paren
op_amp
id|ni-&gt;extent_lock
)paren
suffix:semicolon
id|iput
c_func
(paren
id|vi
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Found the extent inode corrsponding to this extent mft&n;&t;&t; * record.  If it is dirty, no need to search further.&n;&t;&t; */
r_if
c_cond
(paren
id|NInoDirty
c_func
(paren
id|eni
)paren
)paren
(brace
id|up
c_func
(paren
op_amp
id|ni-&gt;extent_lock
)paren
suffix:semicolon
id|iput
c_func
(paren
id|vi
)paren
suffix:semicolon
id|is_dirty
op_assign
id|TRUE
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* The extent inode is not dirty, so do the next record. */
id|up
c_func
(paren
op_amp
id|ni-&gt;extent_lock
)paren
suffix:semicolon
id|iput
c_func
(paren
id|vi
)paren
suffix:semicolon
)brace
id|kunmap
c_func
(paren
id|page
)paren
suffix:semicolon
multiline_comment|/* If a dirty mft record was found, redirty the page. */
r_if
c_cond
(paren
id|is_dirty
)paren
(brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Inode 0x%lx is dirty.  Redirtying the page &quot;
l_string|&quot;starting at inode 0x%lx.&quot;
comma
id|mft_no
comma
id|page-&gt;index
op_lshift
(paren
id|PAGE_CACHE_SHIFT
op_minus
id|vol-&gt;mft_record_size_bits
)paren
)paren
suffix:semicolon
id|redirty_page_for_writepage
c_func
(paren
id|wbc
comma
id|page
)paren
suffix:semicolon
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * Keep the VM happy.  This must be done otherwise the&n;&t;&t; * radix-tree tag PAGECACHE_TAG_DIRTY remains set even though&n;&t;&t; * the page is clean.&n;&t;&t; */
id|BUG_ON
c_func
(paren
id|PageWriteback
c_func
(paren
id|page
)paren
)paren
suffix:semicolon
id|set_page_writeback
c_func
(paren
id|page
)paren
suffix:semicolon
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|end_page_writeback
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Done.&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|es
r_static
r_const
r_char
op_star
id|es
op_assign
l_string|&quot;  Leaving inconsistent metadata.  Unmount and run &quot;
l_string|&quot;chkdsk.&quot;
suffix:semicolon
multiline_comment|/**&n; * ntfs_extent_mft_record_free - free an extent mft record on an ntfs volume&n; * @ni:&t;&t;ntfs inode of the mapped extent mft record to free&n; * @m:&t;&t;mapped extent mft record of the ntfs inode @ni&n; *&n; * Free the mapped extent mft record @m of the extent ntfs inode @ni.&n; *&n; * Note that this function unmaps the mft record and closes and destroys @ni&n; * internally and hence you cannot use either @ni nor @m any more after this&n; * function returns success.&n; *&n; * On success return 0 and on error return -errno.  @ni and @m are still valid&n; * in this case and have not been freed.&n; *&n; * For some errors an error message is displayed and the success code 0 is&n; * returned and the volume is then left dirty on umount.  This makes sense in&n; * case we could not rollback the changes that were already done since the&n; * caller no longer wants to reference this mft record so it does not matter to&n; * the caller if something is wrong with it as long as it is properly detached&n; * from the base inode.&n; */
DECL|function|ntfs_extent_mft_record_free
r_int
id|ntfs_extent_mft_record_free
c_func
(paren
id|ntfs_inode
op_star
id|ni
comma
id|MFT_RECORD
op_star
id|m
)paren
(brace
r_int
r_int
id|mft_no
op_assign
id|ni-&gt;mft_no
suffix:semicolon
id|ntfs_volume
op_star
id|vol
op_assign
id|ni-&gt;vol
suffix:semicolon
id|ntfs_inode
op_star
id|base_ni
suffix:semicolon
id|ntfs_inode
op_star
op_star
id|extent_nis
suffix:semicolon
r_int
id|i
comma
id|err
suffix:semicolon
id|le16
id|old_seq_no
suffix:semicolon
id|u16
id|seq_no
suffix:semicolon
id|BUG_ON
c_func
(paren
id|NInoAttr
c_func
(paren
id|ni
)paren
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|ni-&gt;nr_extents
op_ne
op_minus
l_int|1
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|ni-&gt;extent_lock
)paren
suffix:semicolon
id|base_ni
op_assign
id|ni-&gt;ext.base_ntfs_ino
suffix:semicolon
id|up
c_func
(paren
op_amp
id|ni-&gt;extent_lock
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|base_ni-&gt;nr_extents
op_le
l_int|0
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Entering for extent inode 0x%lx, base inode 0x%lx.&bslash;n&quot;
comma
id|mft_no
comma
id|base_ni-&gt;mft_no
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|base_ni-&gt;extent_lock
)paren
suffix:semicolon
multiline_comment|/* Make sure we are holding the only reference to the extent inode. */
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|ni-&gt;count
)paren
OG
l_int|2
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Tried to free busy extent inode 0x%lx, &quot;
l_string|&quot;not freeing.&quot;
comma
id|base_ni-&gt;mft_no
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|base_ni-&gt;extent_lock
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
multiline_comment|/* Dissociate the ntfs inode from the base inode. */
id|extent_nis
op_assign
id|base_ni-&gt;ext.extent_ntfs_inos
suffix:semicolon
id|err
op_assign
op_minus
id|ENOENT
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|base_ni-&gt;nr_extents
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|ni
op_ne
id|extent_nis
(braket
id|i
)braket
)paren
r_continue
suffix:semicolon
id|extent_nis
op_add_assign
id|i
suffix:semicolon
id|base_ni-&gt;nr_extents
op_decrement
suffix:semicolon
id|memmove
c_func
(paren
id|extent_nis
comma
id|extent_nis
op_plus
l_int|1
comma
(paren
id|base_ni-&gt;nr_extents
op_minus
id|i
)paren
op_star
r_sizeof
(paren
id|ntfs_inode
op_star
)paren
)paren
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|base_ni-&gt;extent_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|err
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Extent inode 0x%lx is not attached to &quot;
l_string|&quot;its base inode 0x%lx.&quot;
comma
id|mft_no
comma
id|base_ni-&gt;mft_no
)paren
suffix:semicolon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * The extent inode is no longer attached to the base inode so no one&n;&t; * can get a reference to it any more.&n;&t; */
multiline_comment|/* Mark the mft record as not in use. */
id|m-&gt;flags
op_and_assign
id|const_cpu_to_le16
c_func
(paren
op_complement
id|const_le16_to_cpu
c_func
(paren
id|MFT_RECORD_IN_USE
)paren
)paren
suffix:semicolon
multiline_comment|/* Increment the sequence number, skipping zero, if it is not zero. */
id|old_seq_no
op_assign
id|m-&gt;sequence_number
suffix:semicolon
id|seq_no
op_assign
id|le16_to_cpu
c_func
(paren
id|old_seq_no
)paren
suffix:semicolon
r_if
c_cond
(paren
id|seq_no
op_eq
l_int|0xffff
)paren
id|seq_no
op_assign
l_int|1
suffix:semicolon
r_else
r_if
c_cond
(paren
id|seq_no
)paren
id|seq_no
op_increment
suffix:semicolon
id|m-&gt;sequence_number
op_assign
id|cpu_to_le16
c_func
(paren
id|seq_no
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Set the ntfs inode dirty and write it out.  We do not need to worry&n;&t; * about the base inode here since whatever caused the extent mft&n;&t; * record to be freed is guaranteed to do it already.&n;&t; */
id|NInoSetDirty
c_func
(paren
id|ni
)paren
suffix:semicolon
id|err
op_assign
id|write_mft_record
c_func
(paren
id|ni
comma
id|m
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|err
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Failed to write mft record 0x%lx, not &quot;
l_string|&quot;freeing.&quot;
comma
id|mft_no
)paren
suffix:semicolon
r_goto
id|rollback
suffix:semicolon
)brace
id|rollback_error
suffix:colon
multiline_comment|/* Unmap and throw away the now freed extent inode. */
id|unmap_extent_mft_record
c_func
(paren
id|ni
)paren
suffix:semicolon
id|ntfs_clear_extent_inode
c_func
(paren
id|ni
)paren
suffix:semicolon
multiline_comment|/* Clear the bit in the $MFT/$BITMAP corresponding to this record. */
id|down_write
c_func
(paren
op_amp
id|vol-&gt;mftbmp_lock
)paren
suffix:semicolon
id|err
op_assign
id|ntfs_bitmap_clear_bit
c_func
(paren
id|vol-&gt;mftbmp_ino
comma
id|mft_no
)paren
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|vol-&gt;mftbmp_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|err
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * The extent inode is gone but we failed to deallocate it in&n;&t;&t; * the mft bitmap.  Just emit a warning and leave the volume&n;&t;&t; * dirty on umount.&n;&t;&t; */
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Failed to clear bit in mft bitmap.%s&quot;
comma
id|es
)paren
suffix:semicolon
id|NVolSetErrors
c_func
(paren
id|vol
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
id|rollback
suffix:colon
multiline_comment|/* Rollback what we did... */
id|down
c_func
(paren
op_amp
id|base_ni-&gt;extent_lock
)paren
suffix:semicolon
id|extent_nis
op_assign
id|base_ni-&gt;ext.extent_ntfs_inos
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|base_ni-&gt;nr_extents
op_amp
l_int|3
)paren
)paren
(brace
r_int
id|new_size
op_assign
(paren
id|base_ni-&gt;nr_extents
op_plus
l_int|4
)paren
op_star
r_sizeof
(paren
id|ntfs_inode
op_star
)paren
suffix:semicolon
id|extent_nis
op_assign
(paren
id|ntfs_inode
op_star
op_star
)paren
id|kmalloc
c_func
(paren
id|new_size
comma
id|GFP_NOFS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|extent_nis
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Failed to allocate internal &quot;
l_string|&quot;buffer during rollback.%s&quot;
comma
id|es
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|base_ni-&gt;extent_lock
)paren
suffix:semicolon
id|NVolSetErrors
c_func
(paren
id|vol
)paren
suffix:semicolon
r_goto
id|rollback_error
suffix:semicolon
)brace
r_if
c_cond
(paren
id|base_ni-&gt;nr_extents
)paren
(brace
id|BUG_ON
c_func
(paren
op_logical_neg
id|base_ni-&gt;ext.extent_ntfs_inos
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|extent_nis
comma
id|base_ni-&gt;ext.extent_ntfs_inos
comma
id|new_size
op_minus
l_int|4
op_star
r_sizeof
(paren
id|ntfs_inode
op_star
)paren
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|base_ni-&gt;ext.extent_ntfs_inos
)paren
suffix:semicolon
)brace
id|base_ni-&gt;ext.extent_ntfs_inos
op_assign
id|extent_nis
suffix:semicolon
)brace
id|m-&gt;flags
op_or_assign
id|MFT_RECORD_IN_USE
suffix:semicolon
id|m-&gt;sequence_number
op_assign
id|old_seq_no
suffix:semicolon
id|extent_nis
(braket
id|base_ni-&gt;nr_extents
op_increment
)braket
op_assign
id|ni
suffix:semicolon
id|up
c_func
(paren
op_amp
id|base_ni-&gt;extent_lock
)paren
suffix:semicolon
id|mark_mft_record_dirty
c_func
(paren
id|ni
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
macro_line|#endif /* NTFS_RW */
eof
