multiline_comment|/**&n; * mft.c - NTFS kernel mft record operations. Part of the Linux-NTFS project.&n; *&n; * Copyright (c) 2001,2002 Anton Altaparmakov.&n; * Copyright (C) 2002 Richard Russon.&n; *&n; * This program/include file is free software; you can redistribute it and/or&n; * modify it under the terms of the GNU General Public License as published&n; * by the Free Software Foundation; either version 2 of the License, or&n; * (at your option) any later version.&n; *&n; * This program/include file is distributed in the hope that it will be &n; * useful, but WITHOUT ANY WARRANTY; without even the implied warranty &n; * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; * GNU General Public License for more details.&n; *&n; * You should have received a copy of the GNU General Public License&n; * along with this program (in the main directory of the Linux-NTFS &n; * distribution in the file COPYING); if not, write to the Free Software&n; * Foundation,Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA&n; */
macro_line|#include &lt;linux/locks.h&gt;
macro_line|#include &lt;linux/swap.h&gt;
macro_line|#include &quot;ntfs.h&quot;
DECL|macro|MAX_BUF_PER_PAGE
mdefine_line|#define MAX_BUF_PER_PAGE (PAGE_CACHE_SIZE / 512)
multiline_comment|/**&n; * __format_mft_record - initialize an empty mft record&n; * @m:&t;&t;mapped, pinned and locked for writing mft record&n; * @size:&t;size of the mft record&n; * @rec_no:&t;mft record number / inode number&n; *&n; * Private function to initialize an empty mft record. Use one of the two&n; * provided format_mft_record() functions instead.&n; */
DECL|function|__format_mft_record
r_static
r_void
id|__format_mft_record
c_func
(paren
id|MFT_RECORD
op_star
id|m
comma
r_const
r_int
id|size
comma
r_const
r_int
r_int
id|rec_no
)paren
(brace
id|ATTR_RECORD
op_star
id|a
suffix:semicolon
id|memset
c_func
(paren
id|m
comma
l_int|0
comma
id|size
)paren
suffix:semicolon
id|m
op_member_access_from_pointer
id|_MNR
c_func
(paren
id|magic
)paren
op_assign
id|magic_FILE
suffix:semicolon
multiline_comment|/* Aligned to 2-byte boundary. */
id|m
op_member_access_from_pointer
id|_MNR
c_func
(paren
id|usa_ofs
)paren
op_assign
id|cpu_to_le16
c_func
(paren
(paren
r_sizeof
(paren
id|MFT_RECORD
)paren
op_plus
l_int|1
)paren
op_amp
op_complement
l_int|1
)paren
suffix:semicolon
id|m
op_member_access_from_pointer
id|_MNR
c_func
(paren
id|usa_count
)paren
op_assign
id|cpu_to_le16
c_func
(paren
id|size
op_div
id|NTFS_BLOCK_SIZE
op_plus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Set the update sequence number to 1. */
op_star
(paren
id|u16
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|m
op_plus
(paren
(paren
r_sizeof
(paren
id|MFT_RECORD
)paren
op_plus
l_int|1
)paren
op_amp
op_complement
l_int|1
)paren
)paren
op_assign
id|cpu_to_le16
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|m-&gt;lsn
op_assign
id|cpu_to_le64
c_func
(paren
l_int|0LL
)paren
suffix:semicolon
id|m-&gt;sequence_number
op_assign
id|cpu_to_le16
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|m-&gt;link_count
op_assign
id|cpu_to_le16
c_func
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Aligned to 8-byte boundary. */
id|m-&gt;attrs_offset
op_assign
id|cpu_to_le16
c_func
(paren
(paren
id|le16_to_cpu
c_func
(paren
id|m
op_member_access_from_pointer
id|_MNR
c_func
(paren
id|usa_ofs
)paren
)paren
op_plus
(paren
id|le16_to_cpu
c_func
(paren
id|m
op_member_access_from_pointer
id|_MNR
c_func
(paren
id|usa_count
)paren
)paren
op_lshift
l_int|1
)paren
op_plus
l_int|7
)paren
op_amp
op_complement
l_int|7
)paren
suffix:semicolon
id|m-&gt;flags
op_assign
id|cpu_to_le16
c_func
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Using attrs_offset plus eight bytes (for the termination attribute),&n;&t; * aligned to 8-byte boundary.&n;&t; */
id|m-&gt;bytes_in_use
op_assign
id|cpu_to_le32
c_func
(paren
(paren
id|le16_to_cpu
c_func
(paren
id|m-&gt;attrs_offset
)paren
op_plus
l_int|8
op_plus
l_int|7
)paren
op_amp
op_complement
l_int|7
)paren
suffix:semicolon
id|m-&gt;bytes_allocated
op_assign
id|cpu_to_le32
c_func
(paren
id|size
)paren
suffix:semicolon
id|m-&gt;base_mft_record
op_assign
id|cpu_to_le64
c_func
(paren
(paren
id|MFT_REF
)paren
l_int|0
)paren
suffix:semicolon
id|m-&gt;next_attr_instance
op_assign
id|cpu_to_le16
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|a
op_assign
(paren
id|ATTR_RECORD
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|m
op_plus
id|le16_to_cpu
c_func
(paren
id|m-&gt;attrs_offset
)paren
)paren
suffix:semicolon
id|a-&gt;type
op_assign
id|AT_END
suffix:semicolon
id|a-&gt;length
op_assign
id|cpu_to_le32
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * format_mft_record2 - initialize an empty mft record&n; * @vfs_sb:&t;vfs super block of volume&n; * @inum:&t;mft record number / inode number to format&n; * @mft_rec:&t;mapped, pinned and locked mft record (optional)&n; *&n; * Initialize an empty mft record. This is used when extending the MFT.&n; *&n; * If @mft_rec is NULL, we call map_mft_record() to obtain the record and we&n; * unmap it again when finished.&n; *&n; * We return 0 on success or -errno on error.&n; */
macro_line|#if 0
singleline_comment|// Can&squot;t do this as iget_map_mft_record no longer exists...
r_int
id|format_mft_record2
c_func
(paren
r_struct
id|super_block
op_star
id|vfs_sb
comma
r_const
r_int
r_int
id|inum
comma
id|MFT_RECORD
op_star
id|mft_rec
)paren
(brace
id|MFT_RECORD
op_star
id|m
suffix:semicolon
id|ntfs_inode
op_star
id|ni
suffix:semicolon
r_if
c_cond
(paren
id|mft_rec
)paren
id|m
op_assign
id|mft_rec
suffix:semicolon
r_else
(brace
id|m
op_assign
id|iget_map_mft_record
c_func
(paren
id|WRITE
comma
id|vfs_sb
comma
id|inum
comma
op_amp
id|ni
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|m
)paren
)paren
r_return
id|PTR_ERR
c_func
(paren
id|m
)paren
suffix:semicolon
)brace
id|__format_mft_record
c_func
(paren
id|m
comma
id|NTFS_SB
c_func
(paren
id|vfs_sb
)paren
op_member_access_from_pointer
id|mft_record_size
comma
id|inum
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mft_rec
)paren
(brace
singleline_comment|// TODO: dirty mft record
id|unmap_mft_record
c_func
(paren
id|WRITE
comma
id|ni
)paren
suffix:semicolon
singleline_comment|// TODO: Do stuff to get rid of the ntfs_inode
)brace
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/**&n; * format_mft_record - initialize an empty mft record&n; * @ni:&t;&t;ntfs inode of mft record&n; * @mft_rec:&t;mapped, pinned and locked mft record (optional)&n; *&n; * Initialize an empty mft record. This is used when extending the MFT.&n; *&n; * If @mft_rec is NULL, we call map_mft_record() to obtain the&n; * record and we unmap it again when finished.&n; *&n; * We return 0 on success or -errno on error.&n; */
DECL|function|format_mft_record
r_int
id|format_mft_record
c_func
(paren
id|ntfs_inode
op_star
id|ni
comma
id|MFT_RECORD
op_star
id|mft_rec
)paren
(brace
id|MFT_RECORD
op_star
id|m
suffix:semicolon
r_if
c_cond
(paren
id|mft_rec
)paren
id|m
op_assign
id|mft_rec
suffix:semicolon
r_else
(brace
id|m
op_assign
id|map_mft_record
c_func
(paren
id|WRITE
comma
id|ni
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|m
)paren
)paren
r_return
id|PTR_ERR
c_func
(paren
id|m
)paren
suffix:semicolon
)brace
id|__format_mft_record
c_func
(paren
id|m
comma
id|ni-&gt;vol-&gt;mft_record_size
comma
id|ni-&gt;mft_no
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mft_rec
)paren
id|unmap_mft_record
c_func
(paren
id|WRITE
comma
id|ni
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_mft_readpage - read a page of the data attribute of $MFT&n; * @file:&t;open file to which the page @page belongs or NULL&n; * @page:&t;page cache page to fill with data&n; *&n; * Readpage method for the VFS address space operations.&n; *&n; * ntfs_mft_readpage() reads the page specified by @page and returns 0 on&n; * success or -EIO on error.&n; *&n; * Note, we only setup asynchronous I/O on the page and return. I/O completion&n; * is signalled via our asynchronous I/O completion handler&n; * end_buffer_read_index_async(). We also take care of the nitty gritty&n; * details towards the end of the file and zero out non-initialized regions.&n; *&n; * TODO:/FIXME: The current implementation is simple but wasteful as we perform&n; * actual i/o from disk for all data up to allocated size completely ignoring&n; * the fact that initialized size, and data size for that matter, may well be&n; * lower and hence there is no point in reading them in. We can just zero the&n; * page range, which is what is currently done in our async i/o completion&n; * handler anyway once the read from disk completes. However, I am not sure how&n; * to setup the buffer heads in that case, so for now we do the pointless i/o.&n; * Any help with this would be appreciated...&n; */
DECL|function|ntfs_mft_readpage
r_static
r_int
id|ntfs_mft_readpage
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_struct
id|page
op_star
id|page
)paren
(brace
id|VCN
id|vcn
suffix:semicolon
id|LCN
id|lcn
suffix:semicolon
r_struct
id|inode
op_star
id|vi
suffix:semicolon
id|ntfs_inode
op_star
id|ni
suffix:semicolon
r_struct
id|super_block
op_star
id|sb
suffix:semicolon
id|ntfs_volume
op_star
id|vol
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
comma
op_star
id|head
comma
op_star
id|arr
(braket
id|MAX_BUF_PER_PAGE
)braket
suffix:semicolon
id|sector_t
id|iblock
comma
id|lblock
suffix:semicolon
r_int
r_int
id|blocksize
comma
id|blocks
comma
id|vcn_ofs
suffix:semicolon
r_int
id|i
comma
id|nr
suffix:semicolon
r_int
r_char
id|blocksize_bits
suffix:semicolon
multiline_comment|/* The page must be locked. */
r_if
c_cond
(paren
op_logical_neg
id|PageLocked
c_func
(paren
id|page
)paren
)paren
id|PAGE_BUG
c_func
(paren
id|page
)paren
suffix:semicolon
multiline_comment|/* Get the VFS and ntfs inodes as well as the super blocks for page. */
id|vi
op_assign
id|page-&gt;mapping-&gt;host
suffix:semicolon
id|ni
op_assign
id|NTFS_I
c_func
(paren
id|vi
)paren
suffix:semicolon
id|sb
op_assign
id|vi-&gt;i_sb
suffix:semicolon
id|vol
op_assign
id|NTFS_SB
c_func
(paren
id|sb
)paren
suffix:semicolon
id|blocksize
op_assign
id|sb-&gt;s_blocksize
suffix:semicolon
id|blocksize_bits
op_assign
id|sb-&gt;s_blocksize_bits
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page-&gt;buffers
)paren
id|create_empty_buffers
c_func
(paren
id|page
comma
id|blocksize
)paren
suffix:semicolon
id|blocks
op_assign
id|PAGE_CACHE_SIZE
op_rshift
id|blocksize_bits
suffix:semicolon
id|iblock
op_assign
id|page-&gt;index
op_lshift
(paren
id|PAGE_CACHE_SHIFT
op_minus
id|blocksize_bits
)paren
suffix:semicolon
id|lblock
op_assign
(paren
id|ni-&gt;allocated_size
op_plus
id|blocksize
op_minus
l_int|1
)paren
op_rshift
id|blocksize_bits
suffix:semicolon
id|bh
op_assign
id|head
op_assign
id|page-&gt;buffers
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|bh
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
op_logical_neg
id|ni-&gt;run_list.rl
)paren
id|panic
c_func
(paren
l_string|&quot;NTFS: $MFT/$DATA run list has been unmapped! This is a &quot;
l_string|&quot;very serious bug! Cannot continue...&quot;
)paren
suffix:semicolon
macro_line|#endif
id|nr
op_assign
id|i
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Loop through all the buffers in the page. */
r_do
(brace
r_if
c_cond
(paren
id|buffer_mapped
c_func
(paren
id|bh
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Is the block within the allowed limits? */
r_if
c_cond
(paren
id|iblock
OL
id|lblock
)paren
(brace
multiline_comment|/* Convert iblock into corresponding vcn and offset. */
id|vcn
op_assign
(paren
id|VCN
)paren
id|iblock
op_lshift
id|blocksize_bits
op_rshift
id|vol-&gt;cluster_size_bits
suffix:semicolon
id|vcn_ofs
op_assign
(paren
(paren
id|VCN
)paren
id|iblock
op_lshift
id|blocksize_bits
)paren
op_amp
id|vol-&gt;cluster_size_mask
suffix:semicolon
multiline_comment|/* Convert the vcn to the corresponding lcn. */
id|down_read
c_func
(paren
op_amp
id|ni-&gt;run_list.lock
)paren
suffix:semicolon
id|lcn
op_assign
id|vcn_to_lcn
c_func
(paren
id|ni-&gt;run_list.rl
comma
id|vcn
)paren
suffix:semicolon
id|up_read
c_func
(paren
op_amp
id|ni-&gt;run_list.lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lcn
op_ge
l_int|0
)paren
(brace
multiline_comment|/* Setup buffer head to correct block. */
id|bh-&gt;b_dev
op_assign
id|vi-&gt;i_dev
suffix:semicolon
id|bh-&gt;b_blocknr
op_assign
(paren
(paren
id|lcn
op_lshift
id|vol-&gt;cluster_size_bits
)paren
op_plus
id|vcn_ofs
)paren
op_rshift
id|blocksize_bits
suffix:semicolon
id|bh-&gt;b_state
op_or_assign
(paren
l_int|1UL
op_lshift
id|BH_Mapped
)paren
suffix:semicolon
id|arr
(braket
id|nr
op_increment
)braket
op_assign
id|bh
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;vcn_to_lcn(vcn = 0x%Lx) failed with &quot;
l_string|&quot;error code 0x%Lx.&quot;
comma
(paren
r_int
r_int
)paren
id|vcn
comma
(paren
r_int
r_int
)paren
op_minus
id|lcn
)paren
suffix:semicolon
singleline_comment|// FIXME: Depending on vol-&gt;on_errors, do something.
)brace
multiline_comment|/*&n;&t;&t; * Either iblock was outside lblock limits or vcn_to_lcn()&n;&t;&t; * returned error. Just zero that portion of the page and set&n;&t;&t; * the buffer uptodate.&n;&t;&t; */
id|bh-&gt;b_dev
op_assign
id|vi-&gt;i_dev
suffix:semicolon
id|bh-&gt;b_blocknr
op_assign
op_minus
l_int|1UL
suffix:semicolon
id|bh-&gt;b_state
op_and_assign
op_complement
(paren
l_int|1UL
op_lshift
id|BH_Mapped
)paren
suffix:semicolon
id|memset
c_func
(paren
id|kmap
c_func
(paren
id|page
)paren
op_plus
id|i
op_star
id|blocksize
comma
l_int|0
comma
id|blocksize
)paren
suffix:semicolon
id|flush_dcache_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|kunmap
c_func
(paren
id|page
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|BH_Uptodate
comma
op_amp
id|bh-&gt;b_state
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|i
op_increment
comma
id|iblock
op_increment
comma
(paren
id|bh
op_assign
id|bh-&gt;b_this_page
)paren
op_ne
id|head
)paren
suffix:semicolon
multiline_comment|/* Check we have at least one buffer ready for io. */
r_if
c_cond
(paren
id|nr
)paren
(brace
multiline_comment|/* Lock the buffers. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|buffer_head
op_star
id|tbh
op_assign
id|arr
(braket
id|i
)braket
suffix:semicolon
id|lock_buffer
c_func
(paren
id|tbh
)paren
suffix:semicolon
id|tbh-&gt;b_end_io
op_assign
id|end_buffer_read_index_async
suffix:semicolon
id|mark_buffer_async
c_func
(paren
id|tbh
comma
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* And start io on the buffers. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr
suffix:semicolon
id|i
op_increment
)paren
id|submit_bh
c_func
(paren
id|READ
comma
id|arr
(braket
id|i
)braket
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* We didn&squot;t schedule any io on any of the buffers. */
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;No I/O was scheduled on any buffers. Page I/O error.&quot;
)paren
suffix:semicolon
id|SetPageError
c_func
(paren
id|page
)paren
suffix:semicolon
id|UnlockPage
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_mft_aops - address space operations for access to $MFT&n; *&n; * Address space operations for access to $MFT. This allows us to simply use&n; * read_cache_page() in map_mft_record().&n; */
DECL|variable|ntfs_mft_aops
r_struct
id|address_space_operations
id|ntfs_mft_aops
op_assign
(brace
id|writepage
suffix:colon
l_int|NULL
comma
multiline_comment|/* Write dirty page to disk. */
id|readpage
suffix:colon
id|ntfs_mft_readpage
comma
multiline_comment|/* Fill page with data. */
id|sync_page
suffix:colon
id|block_sync_page
comma
multiline_comment|/* Currently, just unplugs the&n;&t;&t;&t;&t;&t;&t;   disk request queue. */
id|prepare_write
suffix:colon
l_int|NULL
comma
multiline_comment|/* . */
id|commit_write
suffix:colon
l_int|NULL
comma
multiline_comment|/* . */
id|bmap
suffix:colon
l_int|NULL
comma
multiline_comment|/* Needed for FIBMAP.&n;&t;&t;&t;&t;&t;&t;   Don&squot;t use it. */
id|flushpage
suffix:colon
l_int|NULL
comma
multiline_comment|/* . */
id|releasepage
suffix:colon
l_int|NULL
comma
multiline_comment|/* . */
macro_line|#ifdef KERNEL_HAS_O_DIRECT
id|direct_IO
suffix:colon
l_int|NULL
comma
multiline_comment|/* . */
macro_line|#endif
)brace
suffix:semicolon
multiline_comment|/**&n; * map_mft_record_page - map the page in which a specific mft record resides&n; * @ni:&t;&t;ntfs inode whose mft record page to map&n; *&n; * This maps the page in which the mft record of the ntfs inode @ni is situated&n; * and returns a pointer to the mft record within the mapped page.&n; *&n; * Return value needs to be checked with IS_ERR() and if that is true PTR_ERR()&n; * contains the negative error code returned.&n; */
DECL|function|map_mft_record_page
r_static
r_inline
id|MFT_RECORD
op_star
id|map_mft_record_page
c_func
(paren
id|ntfs_inode
op_star
id|ni
)paren
(brace
id|ntfs_volume
op_star
id|vol
op_assign
id|ni-&gt;vol
suffix:semicolon
r_struct
id|inode
op_star
id|mft_vi
op_assign
id|vol-&gt;mft_ino
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
r_int
r_int
id|index
comma
id|ofs
comma
id|end_index
suffix:semicolon
id|BUG_ON
c_func
(paren
id|atomic_read
c_func
(paren
op_amp
id|ni-&gt;mft_count
)paren
op_logical_or
id|ni-&gt;page
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * The index into the page cache and the offset within the page cache&n;&t; * page of the wanted mft record. FIXME: We need to check for&n;&t; * overflowing the unsigned long, but I don&squot;t think we would ever get&n;&t; * here if the volume was that big...&n;&t; */
id|index
op_assign
id|ni-&gt;mft_no
op_lshift
id|vol-&gt;mft_record_size_bits
op_rshift
id|PAGE_CACHE_SHIFT
suffix:semicolon
id|ofs
op_assign
(paren
id|ni-&gt;mft_no
op_lshift
id|vol-&gt;mft_record_size_bits
)paren
op_amp
op_complement
id|PAGE_CACHE_MASK
suffix:semicolon
multiline_comment|/* The maximum valid index into the page cache for $MFT&squot;s data. */
id|end_index
op_assign
id|mft_vi-&gt;i_size
op_rshift
id|PAGE_CACHE_SHIFT
suffix:semicolon
multiline_comment|/* If the wanted index is out of bounds the mft record doesn&squot;t exist. */
r_if
c_cond
(paren
id|index
op_ge
id|end_index
)paren
(brace
r_if
c_cond
(paren
id|index
OG
id|end_index
op_logical_or
(paren
id|mft_vi-&gt;i_size
op_amp
op_complement
id|PAGE_CACHE_MASK
)paren
OL
id|ofs
op_plus
id|vol-&gt;mft_record_size
)paren
(brace
id|page
op_assign
id|ERR_PTR
c_func
(paren
op_minus
id|ENOENT
)paren
suffix:semicolon
r_goto
id|up_err_out
suffix:semicolon
)brace
)brace
multiline_comment|/* Read, map, and pin the page. */
id|page
op_assign
id|ntfs_map_page
c_func
(paren
id|mft_vi-&gt;i_mapping
comma
id|index
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|IS_ERR
c_func
(paren
id|page
)paren
)paren
(brace
multiline_comment|/* Pin the mft record mapping in the ntfs_inode. */
id|atomic_inc
c_func
(paren
op_amp
id|ni-&gt;mft_count
)paren
suffix:semicolon
multiline_comment|/* Setup the references in the ntfs_inode. */
id|ni-&gt;page
op_assign
id|page
suffix:semicolon
id|ni-&gt;page_ofs
op_assign
id|ofs
suffix:semicolon
r_return
id|page_address
c_func
(paren
id|page
)paren
op_plus
id|ofs
suffix:semicolon
)brace
id|up_err_out
suffix:colon
multiline_comment|/* Just in case... */
id|ni-&gt;page
op_assign
l_int|NULL
suffix:semicolon
id|ni-&gt;page_ofs
op_assign
l_int|0
suffix:semicolon
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Failed with error code %lu.&quot;
comma
op_minus
id|PTR_ERR
c_func
(paren
id|page
)paren
)paren
suffix:semicolon
r_return
(paren
r_void
op_star
)paren
id|page
suffix:semicolon
)brace
multiline_comment|/**&n; * unmap_mft_record_page - unmap the page in which a specific mft record resides&n; * @ni:&t;&t;ntfs inode whose mft record page to unmap&n; *&n; * This unmaps the page in which the mft record of the ntfs inode @ni is&n; * situated and returns. This is a NOOP if highmem is not configured.&n; *&n; * The unmap happens via ntfs_unmap_page() which in turn decrements the use&n; * count on the page thus releasing it from the pinned state.&n; *&n; * We do not actually unmap the page from memory of course, as that will be&n; * done by the page cache code itself when memory pressure increases or&n; * whatever.&n; */
DECL|function|unmap_mft_record_page
r_static
r_inline
r_void
id|unmap_mft_record_page
c_func
(paren
id|ntfs_inode
op_star
id|ni
)paren
(brace
id|BUG_ON
c_func
(paren
id|atomic_read
c_func
(paren
op_amp
id|ni-&gt;mft_count
)paren
op_logical_or
op_logical_neg
id|ni-&gt;page
)paren
suffix:semicolon
singleline_comment|// TODO: If dirty, blah...
id|ntfs_unmap_page
c_func
(paren
id|ni-&gt;page
)paren
suffix:semicolon
id|ni-&gt;page
op_assign
l_int|NULL
suffix:semicolon
id|ni-&gt;page_ofs
op_assign
l_int|0
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/**&n; * map_mft_record - map, pin and lock an mft record&n; * @rw:&t;&t;map for read (rw = READ) or write (rw = WRITE)&n; * @ni:&t;&t;ntfs inode whose MFT record to map&n; *&n; * First, take the mrec_lock semaphore for reading or writing, depending on&n; * the value or @rw. We might now be sleeping, while waiting for the semaphore&n; * if it was already locked by someone else.&n; *&n; * Then increment the map reference count and return the mft. If this is the&n; * first invocation, the page of the record is first mapped using&n; * map_mft_record_page().&n; *&n; * This in turn uses ntfs_map_page() to get the page containing the wanted mft&n; * record (it in turn calls read_cache_page() which reads it in from disk if&n; * necessary, increments the use count on the page so that it cannot disappear&n; * under us and returns a reference to the page cache page).&n; *&n; * If read_cache_page() invokes ntfs_mft_readpage() to load the page from disk,&n; * it sets PG_locked and clears PG_uptodate on the page. Once I/O has&n; * completed and the post-read mst fixups on each mft record in the page have&n; * been performed, the page gets PG_uptodate set and PG_locked cleared (this is&n; * done in our asynchronous I/O completion handler end_buffer_read_mft_async()).&n; * ntfs_map_page() waits for PG_locked to become clear and checks if&n; * PG_uptodate is set and returns an error code if not. This provides&n; * sufficient protection against races when reading/using the page.&n; *&n; * However there is the write mapping to think about. Doing the above described&n; * checking here will be fine, because when initiating the write we will set&n; * PG_locked and clear PG_uptodate making sure nobody is touching the page&n; * contents. Doing the locking this way means that the commit to disk code in&n; * the page cache code paths is automatically sufficiently locked with us as&n; * we will not touch a page that has been locked or is not uptodate. The only&n; * locking problem then is them locking the page while we are accessing it.&n; *&n; * So that code will end up having to own the mrec_lock of all mft&n; * records/inodes present in the page before I/O can proceed. Grr. In that&n; * case we wouldn&squot;t need need to bother with PG_locked and PG_uptodate as&n; * nobody will be accessing anything without owning the mrec_lock semaphore.&n; * But we do need to use them because of the read_cache_page() invokation and&n; * the code becomes so much simpler this way that it is well worth it.&n; *&n; * The mft record is now ours and we return a pointer to it. You need to check&n; * the returned pointer with IS_ERR() and if that is true, PTR_ERR() will return&n; * the error code. The following error codes are defined:&n; * &t;TODO: Fill in the possible error codes.&n; *&n; * NOTE: Caller is responsible for setting the mft record dirty before calling&n; * unmap_mft_record(). This is obviously only necessary if the caller really&n; * modified the mft record...&n; * Q: Do we want to recycle one of the VFS inode state bits instead?&n; * A: No, the inode ones mean we want to change the mft record, not we want to&n; * write it out.&n; */
DECL|function|map_mft_record
id|MFT_RECORD
op_star
id|map_mft_record
c_func
(paren
r_const
r_int
id|rw
comma
id|ntfs_inode
op_star
id|ni
)paren
(brace
id|MFT_RECORD
op_star
id|m
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Entering for i_ino 0x%Lx, mapping for %s.&quot;
comma
(paren
r_int
r_int
r_int
)paren
id|ni-&gt;mft_no
comma
id|rw
op_eq
id|READ
ques
c_cond
l_string|&quot;READ&quot;
suffix:colon
l_string|&quot;WRITE&quot;
)paren
suffix:semicolon
multiline_comment|/* Make sure the ntfs inode doesn&squot;t go away. */
id|atomic_inc
c_func
(paren
op_amp
id|ni-&gt;count
)paren
suffix:semicolon
multiline_comment|/* Serialize access to this mft record. */
r_if
c_cond
(paren
id|rw
op_eq
id|READ
)paren
id|down_read
c_func
(paren
op_amp
id|ni-&gt;mrec_lock
)paren
suffix:semicolon
r_else
id|down_write
c_func
(paren
op_amp
id|ni-&gt;mrec_lock
)paren
suffix:semicolon
multiline_comment|/* If already mapped, bump reference count and return the mft record. */
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|ni-&gt;mft_count
)paren
)paren
(brace
id|BUG_ON
c_func
(paren
op_logical_neg
id|ni-&gt;page
)paren
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|ni-&gt;mft_count
)paren
suffix:semicolon
r_return
id|page_address
c_func
(paren
id|ni-&gt;page
)paren
op_plus
id|ni-&gt;page_ofs
suffix:semicolon
)brace
multiline_comment|/* Wasn&squot;t mapped. Map it now and return it if all was ok. */
id|m
op_assign
id|map_mft_record_page
c_func
(paren
id|ni
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|IS_ERR
c_func
(paren
id|m
)paren
)paren
r_return
id|m
suffix:semicolon
multiline_comment|/* Mapping failed. Release the mft record lock. */
r_if
c_cond
(paren
id|rw
op_eq
id|READ
)paren
id|up_read
c_func
(paren
op_amp
id|ni-&gt;mrec_lock
)paren
suffix:semicolon
r_else
id|up_write
c_func
(paren
op_amp
id|ni-&gt;mrec_lock
)paren
suffix:semicolon
id|ntfs_error
c_func
(paren
id|ni-&gt;vol-&gt;sb
comma
l_string|&quot;Failed with error code %lu.&quot;
comma
op_minus
id|PTR_ERR
c_func
(paren
id|m
)paren
)paren
suffix:semicolon
multiline_comment|/* Release the ntfs inode and return the error code. */
id|atomic_dec
c_func
(paren
op_amp
id|ni-&gt;count
)paren
suffix:semicolon
r_return
id|m
suffix:semicolon
)brace
multiline_comment|/**&n; * iget_map_mft_record - iget, map, pin, lock an mft record&n; * @rw:&t;&t;map for read (rw = READ) or write (rw = WRITE)&n; * @vfs_sb:&t;vfs super block of mounted volume&n; * @inum:&t;inode number / MFT record number whose mft record to map&n; * @vfs_ino:&t;output parameter which we set to the inode on successful return&n; *&n; * Does the same as map_mft_record(), except that it starts out only with the&n; * knowledge of the super block (@vfs_sb) and the mft record number which is of&n; * course the same as the inode number (@inum).&n; *&n; * On success, *@vfs_ino will contain a pointer to the inode structure of the&n; * mft record on return. On error return, *@vfs_ino is undefined.&n; *&n; * See map_mft_record() description for details and for a description of how&n; * errors are returned and what error codes are defined.&n; *&n; * IMPROTANT: The caller is responsible for calling iput(@vfs_ino) when&n; * finished with the inode, i.e. after unmap_mft_record() has been called. If&n; * that is omitted you will get busy inodes upon umount...&n; */
macro_line|#if 0
singleline_comment|// this is no longer possible. iget() cannot be called as we may be loading
singleline_comment|// an ntfs inode which will never have a corresponding vfs inode counter part.
singleline_comment|// this is not going to be pretty. )-:
singleline_comment|// we need our own hash for ntfs inodes now, ugh. )-:
singleline_comment|// not having vfs inodes associated with all ntfs inodes is a bad mistake I am
singleline_comment|// getting the impression. this will in the end turn out uglier than just
singleline_comment|// having iget_no_wait().
singleline_comment|// my only hope is that we can get away without this functionality in the driver
singleline_comment|// altogether. we are ok for extent inodes already because we only handle them
singleline_comment|// via map_extent_mft_record().
singleline_comment|// if we really need it, we could have a list or hash of &quot;pure ntfs inodes&quot;
singleline_comment|// to cope with this situation, so the lookup would be:
singleline_comment|// look for the inode and if not present look for pure ntfs inode and if not
singleline_comment|// present add a new pure ntfs inode. under this scheme extent inodes have to
singleline_comment|// also be added to the list/hash of pure inodes.
id|MFT_RECORD
op_star
id|iget_map_mft_record
c_func
(paren
r_const
r_int
id|rw
comma
r_struct
id|super_block
op_star
id|vfs_sb
comma
r_const
r_int
r_int
id|inum
comma
r_struct
id|inode
op_star
op_star
id|vfs_ino
)paren
(brace
r_struct
id|inode
op_star
id|inode
suffix:semicolon
id|MFT_RECORD
op_star
id|mrec
suffix:semicolon
multiline_comment|/*&n;&t; * The corresponding iput() happens when clear_inode() is called on the&n;&t; * base mft record of this extent mft record.&n;&t; * When used on base mft records, caller has to perform the iput().&n;&t; */
id|inode
op_assign
id|iget
c_func
(paren
id|vfs_sb
comma
id|inum
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inode
op_logical_and
op_logical_neg
id|is_bad_inode
c_func
(paren
id|inode
)paren
)paren
(brace
id|mrec
op_assign
id|map_mft_record
c_func
(paren
id|rw
comma
id|inode
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|IS_ERR
c_func
(paren
id|mrec
)paren
)paren
(brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Success for i_ino 0x%lx.&quot;
comma
id|inum
)paren
suffix:semicolon
op_star
id|vfs_ino
op_assign
id|inode
suffix:semicolon
r_return
id|mrec
suffix:semicolon
)brace
)brace
r_else
id|mrec
op_assign
id|ERR_PTR
c_func
(paren
op_minus
id|EIO
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inode
)paren
id|iput
c_func
(paren
id|inode
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Failed for i_ino 0x%lx.&quot;
comma
id|inum
)paren
suffix:semicolon
r_return
id|mrec
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/**&n; * unmap_mft_record - release a mapped mft record&n; * @rw:&t;&t;unmap from read (@rw = READ) or write (@rw = WRITE)&n; * @ni:&t;&t;ntfs inode whose MFT record to unmap&n; *&n; * First, decrement the mapping count and when it reaches zero unmap the mft&n; * record.&n; *&n; * Second, release the mrec_lock semaphore.&n; *&n; * The mft record is now released for others to get hold of.&n; *&n; * Finally, release the ntfs inode by decreasing the ntfs inode reference count.&n; *&n; * NOTE: If caller had the mft record mapped for write and has modified it, it&n; * is imperative to set the mft record dirty BEFORE calling unmap_mft_record().&n; *&n; * NOTE: This has to be done both for &squot;normal&squot; mft records, and for extent mft&n; * records.&n; */
DECL|function|unmap_mft_record
r_void
id|unmap_mft_record
c_func
(paren
r_const
r_int
id|rw
comma
id|ntfs_inode
op_star
id|ni
)paren
(brace
r_struct
id|page
op_star
id|page
op_assign
id|ni-&gt;page
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|atomic_read
c_func
(paren
op_amp
id|ni-&gt;mft_count
)paren
op_logical_or
op_logical_neg
id|page
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Entering for mft_no 0x%Lx, unmapping from %s.&quot;
comma
(paren
r_int
r_int
r_int
)paren
id|ni-&gt;mft_no
comma
id|rw
op_eq
id|READ
ques
c_cond
l_string|&quot;READ&quot;
suffix:colon
l_string|&quot;WRITE&quot;
)paren
suffix:semicolon
multiline_comment|/* Only release the actual page mapping if this is the last one. */
r_if
c_cond
(paren
id|atomic_dec_and_test
c_func
(paren
op_amp
id|ni-&gt;mft_count
)paren
)paren
id|unmap_mft_record_page
c_func
(paren
id|ni
)paren
suffix:semicolon
multiline_comment|/* Release the semaphore. */
r_if
c_cond
(paren
id|rw
op_eq
id|READ
)paren
id|up_read
c_func
(paren
op_amp
id|ni-&gt;mrec_lock
)paren
suffix:semicolon
r_else
id|up_write
c_func
(paren
op_amp
id|ni-&gt;mrec_lock
)paren
suffix:semicolon
multiline_comment|/* Release the ntfs inode. */
id|atomic_dec
c_func
(paren
op_amp
id|ni-&gt;count
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If pure ntfs_inode, i.e. no vfs inode attached, we leave it to&n;&t; * ntfs_clear_inode() in the extent inode case, and to the caller in&n;&t; * the non-extent, yet pure ntfs inode case, to do the actual tear&n;&t; * down of all structures and freeing of all allocated memory.&n;&t; */
r_return
suffix:semicolon
)brace
multiline_comment|/**&n; * map_extent_mft_record - load an extent inode and attach it to its base&n; * @base_ni:&t;base ntfs inode&n; * @mref:&t;mft reference of the extent inode to load (in little endian)&n; * @ntfs_ino:&t;on successful return, pointer to the ntfs_inode structure&n; *&n; * Load the extent mft record @mref and attach it to its base inode @base_ni.&n; * Return the mapped extent mft record if IS_ERR(result) is false. Otherwise&n; * PTR_ERR(result) gives the negative error code.&n; *&n; * On successful return, @ntfs_ino contains a pointer to the ntfs_inode&n; * structure of the mapped extent inode.&n; *&n; * Note, we always map for READ. We consider this lock as irrelevant because&n; * the base inode will be write locked in all cases when we want to write to&n; * an extent inode which already gurantees that there is no-one else accessing&n; * the extent inode.&n; */
DECL|function|map_extent_mft_record
id|MFT_RECORD
op_star
id|map_extent_mft_record
c_func
(paren
id|ntfs_inode
op_star
id|base_ni
comma
id|MFT_REF
id|mref
comma
id|ntfs_inode
op_star
op_star
id|ntfs_ino
)paren
(brace
id|MFT_RECORD
op_star
id|m
suffix:semicolon
id|ntfs_inode
op_star
id|ni
op_assign
l_int|NULL
suffix:semicolon
id|ntfs_inode
op_star
op_star
id|extent_nis
op_assign
l_int|NULL
suffix:semicolon
r_int
id|i
suffix:semicolon
id|u64
id|mft_no
op_assign
id|MREF_LE
c_func
(paren
id|mref
)paren
suffix:semicolon
id|u16
id|seq_no
op_assign
id|MSEQNO_LE
c_func
(paren
id|mref
)paren
suffix:semicolon
id|BOOL
id|destroy_ni
op_assign
id|FALSE
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Mapping extent mft record 0x%Lx (base mft record 0x%Lx).&quot;
comma
(paren
r_int
r_int
r_int
)paren
id|mft_no
comma
(paren
r_int
r_int
r_int
)paren
id|base_ni-&gt;mft_no
)paren
suffix:semicolon
multiline_comment|/* Make sure the base ntfs inode doesn&squot;t go away. */
id|atomic_inc
c_func
(paren
op_amp
id|base_ni-&gt;count
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Check if this extent inode has already been added to the base inode,&n;&t; * in which case just return it. If not found, add it to the base&n;&t; * inode before returning it.&n;&t; */
id|down
c_func
(paren
op_amp
id|base_ni-&gt;extent_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|base_ni-&gt;nr_extents
OG
l_int|0
)paren
(brace
id|extent_nis
op_assign
id|base_ni
op_member_access_from_pointer
id|_INE
c_func
(paren
id|extent_ntfs_inos
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|base_ni-&gt;nr_extents
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|mft_no
op_ne
id|extent_nis
(braket
id|i
)braket
op_member_access_from_pointer
id|mft_no
)paren
r_continue
suffix:semicolon
id|ni
op_assign
id|extent_nis
(braket
id|i
)braket
suffix:semicolon
multiline_comment|/* Make sure the ntfs inode doesn&squot;t go away. */
id|atomic_inc
c_func
(paren
op_amp
id|ni-&gt;count
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|ni
)paren
(brace
id|up
c_func
(paren
op_amp
id|base_ni-&gt;extent_lock
)paren
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|base_ni-&gt;count
)paren
suffix:semicolon
multiline_comment|/* We found the record; just have to map and return it. */
id|m
op_assign
id|map_mft_record
c_func
(paren
id|READ
comma
id|ni
)paren
suffix:semicolon
multiline_comment|/* Map mft record increments this on success. */
id|atomic_dec
c_func
(paren
op_amp
id|ni-&gt;count
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|IS_ERR
c_func
(paren
id|m
)paren
)paren
(brace
multiline_comment|/* Verify the sequence number. */
r_if
c_cond
(paren
id|le16_to_cpu
c_func
(paren
id|m-&gt;sequence_number
)paren
op_eq
id|seq_no
)paren
(brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Done 1.&quot;
)paren
suffix:semicolon
op_star
id|ntfs_ino
op_assign
id|ni
suffix:semicolon
r_return
id|m
suffix:semicolon
)brace
id|unmap_mft_record
c_func
(paren
id|READ
comma
id|ni
)paren
suffix:semicolon
id|ntfs_error
c_func
(paren
id|base_ni-&gt;vol-&gt;sb
comma
l_string|&quot;Found stale extent mft &quot;
l_string|&quot;reference! Corrupt file system. &quot;
l_string|&quot;Run chkdsk.&quot;
)paren
suffix:semicolon
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|EIO
)paren
suffix:semicolon
)brace
id|map_err_out
suffix:colon
id|ntfs_error
c_func
(paren
id|base_ni-&gt;vol-&gt;sb
comma
l_string|&quot;Failed to map extent &quot;
l_string|&quot;mft record, error code %ld.&quot;
comma
op_minus
id|PTR_ERR
c_func
(paren
id|m
)paren
)paren
suffix:semicolon
r_return
id|m
suffix:semicolon
)brace
multiline_comment|/* Record wasn&squot;t there. Get a new ntfs inode and initialize it. */
id|ni
op_assign
id|ntfs_new_inode
c_func
(paren
id|base_ni-&gt;vol-&gt;sb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ni
)paren
(brace
id|up
c_func
(paren
op_amp
id|base_ni-&gt;extent_lock
)paren
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|base_ni-&gt;count
)paren
suffix:semicolon
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
)brace
id|ni-&gt;vol
op_assign
id|base_ni-&gt;vol
suffix:semicolon
id|ni-&gt;mft_no
op_assign
id|mft_no
suffix:semicolon
id|ni-&gt;seq_no
op_assign
id|seq_no
suffix:semicolon
id|ni-&gt;nr_extents
op_assign
op_minus
l_int|1
suffix:semicolon
id|ni
op_member_access_from_pointer
id|_INE
c_func
(paren
id|base_ntfs_ino
)paren
op_assign
id|base_ni
suffix:semicolon
multiline_comment|/* Now map the record. */
id|m
op_assign
id|map_mft_record
c_func
(paren
id|READ
comma
id|ni
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|m
)paren
)paren
(brace
id|up
c_func
(paren
op_amp
id|base_ni-&gt;extent_lock
)paren
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|base_ni-&gt;count
)paren
suffix:semicolon
id|ntfs_clear_inode
c_func
(paren
id|ni
)paren
suffix:semicolon
r_goto
id|map_err_out
suffix:semicolon
)brace
multiline_comment|/* Verify the sequence number. */
r_if
c_cond
(paren
id|le16_to_cpu
c_func
(paren
id|m-&gt;sequence_number
)paren
op_ne
id|seq_no
)paren
(brace
id|ntfs_error
c_func
(paren
id|base_ni-&gt;vol-&gt;sb
comma
l_string|&quot;Found stale extent mft &quot;
l_string|&quot;reference! Corrupt file system. Run chkdsk.&quot;
)paren
suffix:semicolon
id|destroy_ni
op_assign
id|TRUE
suffix:semicolon
id|m
op_assign
id|ERR_PTR
c_func
(paren
op_minus
id|EIO
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
multiline_comment|/* Attach extent inode to base inode, reallocating memory if needed. */
r_if
c_cond
(paren
op_logical_neg
(paren
id|base_ni-&gt;nr_extents
op_amp
op_complement
l_int|3
)paren
)paren
(brace
id|ntfs_inode
op_star
op_star
id|tmp
suffix:semicolon
r_int
id|new_size
op_assign
(paren
id|base_ni-&gt;nr_extents
op_plus
l_int|4
)paren
op_star
r_sizeof
(paren
id|ntfs_inode
op_star
)paren
suffix:semicolon
id|tmp
op_assign
(paren
id|ntfs_inode
op_star
op_star
)paren
id|kmalloc
c_func
(paren
id|new_size
comma
id|GFP_NOFS
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tmp
)paren
(brace
id|ntfs_error
c_func
(paren
id|base_ni-&gt;vol-&gt;sb
comma
l_string|&quot;Failed to allocate &quot;
l_string|&quot;internal buffer.&quot;
)paren
suffix:semicolon
id|destroy_ni
op_assign
id|TRUE
suffix:semicolon
id|m
op_assign
id|ERR_PTR
c_func
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|base_ni
op_member_access_from_pointer
id|_INE
c_func
(paren
id|extent_ntfs_inos
)paren
)paren
(brace
id|memcpy
c_func
(paren
id|tmp
comma
id|base_ni
op_member_access_from_pointer
id|_INE
c_func
(paren
id|extent_ntfs_inos
)paren
comma
id|new_size
op_minus
l_int|4
op_star
r_sizeof
(paren
id|ntfs_inode
op_star
)paren
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|base_ni
op_member_access_from_pointer
id|_INE
c_func
(paren
id|extent_ntfs_inos
)paren
)paren
suffix:semicolon
)brace
id|base_ni
op_member_access_from_pointer
id|_INE
c_func
(paren
id|extent_ntfs_inos
)paren
op_assign
id|tmp
suffix:semicolon
)brace
id|base_ni
op_member_access_from_pointer
id|_INE
c_func
(paren
id|extent_ntfs_inos
)paren
(braket
id|base_ni-&gt;nr_extents
op_increment
)braket
op_assign
id|ni
suffix:semicolon
id|up
c_func
(paren
op_amp
id|base_ni-&gt;extent_lock
)paren
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|base_ni-&gt;count
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Done 2.&quot;
)paren
suffix:semicolon
op_star
id|ntfs_ino
op_assign
id|ni
suffix:semicolon
r_return
id|m
suffix:semicolon
id|unm_err_out
suffix:colon
id|unmap_mft_record
c_func
(paren
id|READ
comma
id|ni
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|base_ni-&gt;extent_lock
)paren
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|base_ni-&gt;count
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If the extent inode was not attached to the base inode we need to&n;&t; * release it or we will leak memory.&n;&t; */
r_if
c_cond
(paren
id|destroy_ni
)paren
id|ntfs_clear_inode
c_func
(paren
id|ni
)paren
suffix:semicolon
r_return
id|m
suffix:semicolon
)brace
eof
