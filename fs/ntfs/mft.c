multiline_comment|/**&n; * mft.c - NTFS kernel mft record operations. Part of the Linux-NTFS project.&n; *&n; * Copyright (c) 2001-2004 Anton Altaparmakov&n; * Copyright (c) 2002 Richard Russon&n; *&n; * This program/include file is free software; you can redistribute it and/or&n; * modify it under the terms of the GNU General Public License as published&n; * by the Free Software Foundation; either version 2 of the License, or&n; * (at your option) any later version.&n; *&n; * This program/include file is distributed in the hope that it will be&n; * useful, but WITHOUT ANY WARRANTY; without even the implied warranty&n; * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; * GNU General Public License for more details.&n; *&n; * You should have received a copy of the GNU General Public License&n; * along with this program (in the main directory of the Linux-NTFS&n; * distribution in the file COPYING); if not, write to the Free Software&n; * Foundation,Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA&n; */
macro_line|#include &lt;linux/buffer_head.h&gt;
macro_line|#include &lt;linux/swap.h&gt;
macro_line|#include &quot;attrib.h&quot;
macro_line|#include &quot;aops.h&quot;
macro_line|#include &quot;bitmap.h&quot;
macro_line|#include &quot;debug.h&quot;
macro_line|#include &quot;dir.h&quot;
macro_line|#include &quot;lcnalloc.h&quot;
macro_line|#include &quot;malloc.h&quot;
macro_line|#include &quot;mft.h&quot;
macro_line|#include &quot;ntfs.h&quot;
multiline_comment|/**&n; * map_mft_record_page - map the page in which a specific mft record resides&n; * @ni:&t;&t;ntfs inode whose mft record page to map&n; *&n; * This maps the page in which the mft record of the ntfs inode @ni is situated&n; * and returns a pointer to the mft record within the mapped page.&n; *&n; * Return value needs to be checked with IS_ERR() and if that is true PTR_ERR()&n; * contains the negative error code returned.&n; */
DECL|function|map_mft_record_page
r_static
r_inline
id|MFT_RECORD
op_star
id|map_mft_record_page
c_func
(paren
id|ntfs_inode
op_star
id|ni
)paren
(brace
id|ntfs_volume
op_star
id|vol
op_assign
id|ni-&gt;vol
suffix:semicolon
r_struct
id|inode
op_star
id|mft_vi
op_assign
id|vol-&gt;mft_ino
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
r_int
r_int
id|index
comma
id|ofs
comma
id|end_index
suffix:semicolon
id|BUG_ON
c_func
(paren
id|ni-&gt;page
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * The index into the page cache and the offset within the page cache&n;&t; * page of the wanted mft record. FIXME: We need to check for&n;&t; * overflowing the unsigned long, but I don&squot;t think we would ever get&n;&t; * here if the volume was that big...&n;&t; */
id|index
op_assign
id|ni-&gt;mft_no
op_lshift
id|vol-&gt;mft_record_size_bits
op_rshift
id|PAGE_CACHE_SHIFT
suffix:semicolon
id|ofs
op_assign
(paren
id|ni-&gt;mft_no
op_lshift
id|vol-&gt;mft_record_size_bits
)paren
op_amp
op_complement
id|PAGE_CACHE_MASK
suffix:semicolon
multiline_comment|/* The maximum valid index into the page cache for $MFT&squot;s data. */
id|end_index
op_assign
id|mft_vi-&gt;i_size
op_rshift
id|PAGE_CACHE_SHIFT
suffix:semicolon
multiline_comment|/* If the wanted index is out of bounds the mft record doesn&squot;t exist. */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|index
op_ge
id|end_index
)paren
)paren
(brace
r_if
c_cond
(paren
id|index
OG
id|end_index
op_logical_or
(paren
id|mft_vi-&gt;i_size
op_amp
op_complement
id|PAGE_CACHE_MASK
)paren
OL
id|ofs
op_plus
id|vol-&gt;mft_record_size
)paren
(brace
id|page
op_assign
id|ERR_PTR
c_func
(paren
op_minus
id|ENOENT
)paren
suffix:semicolon
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Attemt to read mft record 0x%lx, &quot;
l_string|&quot;which is beyond the end of the mft.  &quot;
l_string|&quot;This is probably a bug in the ntfs &quot;
l_string|&quot;driver.&quot;
comma
id|ni-&gt;mft_no
)paren
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
)brace
multiline_comment|/* Read, map, and pin the page. */
id|page
op_assign
id|ntfs_map_page
c_func
(paren
id|mft_vi-&gt;i_mapping
comma
id|index
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
op_logical_neg
id|IS_ERR
c_func
(paren
id|page
)paren
)paren
)paren
(brace
multiline_comment|/* Catch multi sector transfer fixup errors. */
r_if
c_cond
(paren
id|likely
c_func
(paren
id|ntfs_is_mft_recordp
c_func
(paren
(paren
id|le32
op_star
)paren
(paren
id|page_address
c_func
(paren
id|page
)paren
op_plus
id|ofs
)paren
)paren
)paren
)paren
(brace
id|ni-&gt;page
op_assign
id|page
suffix:semicolon
id|ni-&gt;page_ofs
op_assign
id|ofs
suffix:semicolon
r_return
id|page_address
c_func
(paren
id|page
)paren
op_plus
id|ofs
suffix:semicolon
)brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Mft record 0x%lx is corrupt.  &quot;
l_string|&quot;Run chkdsk.&quot;
comma
id|ni-&gt;mft_no
)paren
suffix:semicolon
id|ntfs_unmap_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|page
op_assign
id|ERR_PTR
c_func
(paren
op_minus
id|EIO
)paren
suffix:semicolon
)brace
id|err_out
suffix:colon
id|ni-&gt;page
op_assign
l_int|NULL
suffix:semicolon
id|ni-&gt;page_ofs
op_assign
l_int|0
suffix:semicolon
r_return
(paren
r_void
op_star
)paren
id|page
suffix:semicolon
)brace
multiline_comment|/**&n; * map_mft_record - map, pin and lock an mft record&n; * @ni:&t;&t;ntfs inode whose MFT record to map&n; *&n; * First, take the mrec_lock semaphore. We might now be sleeping, while waiting&n; * for the semaphore if it was already locked by someone else.&n; *&n; * The page of the record is mapped using map_mft_record_page() before being&n; * returned to the caller.&n; *&n; * This in turn uses ntfs_map_page() to get the page containing the wanted mft&n; * record (it in turn calls read_cache_page() which reads it in from disk if&n; * necessary, increments the use count on the page so that it cannot disappear&n; * under us and returns a reference to the page cache page).&n; *&n; * If read_cache_page() invokes ntfs_readpage() to load the page from disk, it&n; * sets PG_locked and clears PG_uptodate on the page. Once I/O has completed&n; * and the post-read mst fixups on each mft record in the page have been&n; * performed, the page gets PG_uptodate set and PG_locked cleared (this is done&n; * in our asynchronous I/O completion handler end_buffer_read_mft_async()).&n; * ntfs_map_page() waits for PG_locked to become clear and checks if&n; * PG_uptodate is set and returns an error code if not. This provides&n; * sufficient protection against races when reading/using the page.&n; *&n; * However there is the write mapping to think about. Doing the above described&n; * checking here will be fine, because when initiating the write we will set&n; * PG_locked and clear PG_uptodate making sure nobody is touching the page&n; * contents. Doing the locking this way means that the commit to disk code in&n; * the page cache code paths is automatically sufficiently locked with us as&n; * we will not touch a page that has been locked or is not uptodate. The only&n; * locking problem then is them locking the page while we are accessing it.&n; *&n; * So that code will end up having to own the mrec_lock of all mft&n; * records/inodes present in the page before I/O can proceed. In that case we&n; * wouldn&squot;t need to bother with PG_locked and PG_uptodate as nobody will be&n; * accessing anything without owning the mrec_lock semaphore. But we do need&n; * to use them because of the read_cache_page() invocation and the code becomes&n; * so much simpler this way that it is well worth it.&n; *&n; * The mft record is now ours and we return a pointer to it. You need to check&n; * the returned pointer with IS_ERR() and if that is true, PTR_ERR() will return&n; * the error code.&n; *&n; * NOTE: Caller is responsible for setting the mft record dirty before calling&n; * unmap_mft_record(). This is obviously only necessary if the caller really&n; * modified the mft record...&n; * Q: Do we want to recycle one of the VFS inode state bits instead?&n; * A: No, the inode ones mean we want to change the mft record, not we want to&n; * write it out.&n; */
DECL|function|map_mft_record
id|MFT_RECORD
op_star
id|map_mft_record
c_func
(paren
id|ntfs_inode
op_star
id|ni
)paren
(brace
id|MFT_RECORD
op_star
id|m
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Entering for mft_no 0x%lx.&quot;
comma
id|ni-&gt;mft_no
)paren
suffix:semicolon
multiline_comment|/* Make sure the ntfs inode doesn&squot;t go away. */
id|atomic_inc
c_func
(paren
op_amp
id|ni-&gt;count
)paren
suffix:semicolon
multiline_comment|/* Serialize access to this mft record. */
id|down
c_func
(paren
op_amp
id|ni-&gt;mrec_lock
)paren
suffix:semicolon
id|m
op_assign
id|map_mft_record_page
c_func
(paren
id|ni
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
op_logical_neg
id|IS_ERR
c_func
(paren
id|m
)paren
)paren
)paren
r_return
id|m
suffix:semicolon
id|up
c_func
(paren
op_amp
id|ni-&gt;mrec_lock
)paren
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|ni-&gt;count
)paren
suffix:semicolon
id|ntfs_error
c_func
(paren
id|ni-&gt;vol-&gt;sb
comma
l_string|&quot;Failed with error code %lu.&quot;
comma
op_minus
id|PTR_ERR
c_func
(paren
id|m
)paren
)paren
suffix:semicolon
r_return
id|m
suffix:semicolon
)brace
multiline_comment|/**&n; * unmap_mft_record_page - unmap the page in which a specific mft record resides&n; * @ni:&t;&t;ntfs inode whose mft record page to unmap&n; *&n; * This unmaps the page in which the mft record of the ntfs inode @ni is&n; * situated and returns. This is a NOOP if highmem is not configured.&n; *&n; * The unmap happens via ntfs_unmap_page() which in turn decrements the use&n; * count on the page thus releasing it from the pinned state.&n; *&n; * We do not actually unmap the page from memory of course, as that will be&n; * done by the page cache code itself when memory pressure increases or&n; * whatever.&n; */
DECL|function|unmap_mft_record_page
r_static
r_inline
r_void
id|unmap_mft_record_page
c_func
(paren
id|ntfs_inode
op_star
id|ni
)paren
(brace
id|BUG_ON
c_func
(paren
op_logical_neg
id|ni-&gt;page
)paren
suffix:semicolon
singleline_comment|// TODO: If dirty, blah...
id|ntfs_unmap_page
c_func
(paren
id|ni-&gt;page
)paren
suffix:semicolon
id|ni-&gt;page
op_assign
l_int|NULL
suffix:semicolon
id|ni-&gt;page_ofs
op_assign
l_int|0
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/**&n; * unmap_mft_record - release a mapped mft record&n; * @ni:&t;&t;ntfs inode whose MFT record to unmap&n; *&n; * We release the page mapping and the mrec_lock mutex which unmaps the mft&n; * record and releases it for others to get hold of. We also release the ntfs&n; * inode by decrementing the ntfs inode reference count.&n; *&n; * NOTE: If caller has modified the mft record, it is imperative to set the mft&n; * record dirty BEFORE calling unmap_mft_record().&n; */
DECL|function|unmap_mft_record
r_void
id|unmap_mft_record
c_func
(paren
id|ntfs_inode
op_star
id|ni
)paren
(brace
r_struct
id|page
op_star
id|page
op_assign
id|ni-&gt;page
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|page
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Entering for mft_no 0x%lx.&quot;
comma
id|ni-&gt;mft_no
)paren
suffix:semicolon
id|unmap_mft_record_page
c_func
(paren
id|ni
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|ni-&gt;mrec_lock
)paren
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|ni-&gt;count
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If pure ntfs_inode, i.e. no vfs inode attached, we leave it to&n;&t; * ntfs_clear_extent_inode() in the extent inode case, and to the&n;&t; * caller in the non-extent, yet pure ntfs inode case, to do the actual&n;&t; * tear down of all structures and freeing of all allocated memory.&n;&t; */
r_return
suffix:semicolon
)brace
multiline_comment|/**&n; * map_extent_mft_record - load an extent inode and attach it to its base&n; * @base_ni:&t;base ntfs inode&n; * @mref:&t;mft reference of the extent inode to load&n; * @ntfs_ino:&t;on successful return, pointer to the ntfs_inode structure&n; *&n; * Load the extent mft record @mref and attach it to its base inode @base_ni.&n; * Return the mapped extent mft record if IS_ERR(result) is false.  Otherwise&n; * PTR_ERR(result) gives the negative error code.&n; *&n; * On successful return, @ntfs_ino contains a pointer to the ntfs_inode&n; * structure of the mapped extent inode.&n; */
DECL|function|map_extent_mft_record
id|MFT_RECORD
op_star
id|map_extent_mft_record
c_func
(paren
id|ntfs_inode
op_star
id|base_ni
comma
id|MFT_REF
id|mref
comma
id|ntfs_inode
op_star
op_star
id|ntfs_ino
)paren
(brace
id|MFT_RECORD
op_star
id|m
suffix:semicolon
id|ntfs_inode
op_star
id|ni
op_assign
l_int|NULL
suffix:semicolon
id|ntfs_inode
op_star
op_star
id|extent_nis
op_assign
l_int|NULL
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
r_int
id|mft_no
op_assign
id|MREF
c_func
(paren
id|mref
)paren
suffix:semicolon
id|u16
id|seq_no
op_assign
id|MSEQNO
c_func
(paren
id|mref
)paren
suffix:semicolon
id|BOOL
id|destroy_ni
op_assign
id|FALSE
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Mapping extent mft record 0x%lx (base mft record 0x%lx).&quot;
comma
id|mft_no
comma
id|base_ni-&gt;mft_no
)paren
suffix:semicolon
multiline_comment|/* Make sure the base ntfs inode doesn&squot;t go away. */
id|atomic_inc
c_func
(paren
op_amp
id|base_ni-&gt;count
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Check if this extent inode has already been added to the base inode,&n;&t; * in which case just return it. If not found, add it to the base&n;&t; * inode before returning it.&n;&t; */
id|down
c_func
(paren
op_amp
id|base_ni-&gt;extent_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|base_ni-&gt;nr_extents
OG
l_int|0
)paren
(brace
id|extent_nis
op_assign
id|base_ni-&gt;ext.extent_ntfs_inos
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|base_ni-&gt;nr_extents
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|mft_no
op_ne
id|extent_nis
(braket
id|i
)braket
op_member_access_from_pointer
id|mft_no
)paren
r_continue
suffix:semicolon
id|ni
op_assign
id|extent_nis
(braket
id|i
)braket
suffix:semicolon
multiline_comment|/* Make sure the ntfs inode doesn&squot;t go away. */
id|atomic_inc
c_func
(paren
op_amp
id|ni-&gt;count
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|likely
c_func
(paren
id|ni
op_ne
l_int|NULL
)paren
)paren
(brace
id|up
c_func
(paren
op_amp
id|base_ni-&gt;extent_lock
)paren
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|base_ni-&gt;count
)paren
suffix:semicolon
multiline_comment|/* We found the record; just have to map and return it. */
id|m
op_assign
id|map_mft_record
c_func
(paren
id|ni
)paren
suffix:semicolon
multiline_comment|/* map_mft_record() has incremented this on success. */
id|atomic_dec
c_func
(paren
op_amp
id|ni-&gt;count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
op_logical_neg
id|IS_ERR
c_func
(paren
id|m
)paren
)paren
)paren
(brace
multiline_comment|/* Verify the sequence number. */
r_if
c_cond
(paren
id|likely
c_func
(paren
id|le16_to_cpu
c_func
(paren
id|m-&gt;sequence_number
)paren
op_eq
id|seq_no
)paren
)paren
(brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Done 1.&quot;
)paren
suffix:semicolon
op_star
id|ntfs_ino
op_assign
id|ni
suffix:semicolon
r_return
id|m
suffix:semicolon
)brace
id|unmap_mft_record
c_func
(paren
id|ni
)paren
suffix:semicolon
id|ntfs_error
c_func
(paren
id|base_ni-&gt;vol-&gt;sb
comma
l_string|&quot;Found stale extent mft &quot;
l_string|&quot;reference! Corrupt file system. &quot;
l_string|&quot;Run chkdsk.&quot;
)paren
suffix:semicolon
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|EIO
)paren
suffix:semicolon
)brace
id|map_err_out
suffix:colon
id|ntfs_error
c_func
(paren
id|base_ni-&gt;vol-&gt;sb
comma
l_string|&quot;Failed to map extent &quot;
l_string|&quot;mft record, error code %ld.&quot;
comma
op_minus
id|PTR_ERR
c_func
(paren
id|m
)paren
)paren
suffix:semicolon
r_return
id|m
suffix:semicolon
)brace
multiline_comment|/* Record wasn&squot;t there. Get a new ntfs inode and initialize it. */
id|ni
op_assign
id|ntfs_new_extent_inode
c_func
(paren
id|base_ni-&gt;vol-&gt;sb
comma
id|mft_no
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|ni
)paren
)paren
(brace
id|up
c_func
(paren
op_amp
id|base_ni-&gt;extent_lock
)paren
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|base_ni-&gt;count
)paren
suffix:semicolon
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
)brace
id|ni-&gt;vol
op_assign
id|base_ni-&gt;vol
suffix:semicolon
id|ni-&gt;seq_no
op_assign
id|seq_no
suffix:semicolon
id|ni-&gt;nr_extents
op_assign
op_minus
l_int|1
suffix:semicolon
id|ni-&gt;ext.base_ntfs_ino
op_assign
id|base_ni
suffix:semicolon
multiline_comment|/* Now map the record. */
id|m
op_assign
id|map_mft_record
c_func
(paren
id|ni
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|m
)paren
)paren
(brace
id|up
c_func
(paren
op_amp
id|base_ni-&gt;extent_lock
)paren
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|base_ni-&gt;count
)paren
suffix:semicolon
id|ntfs_clear_extent_inode
c_func
(paren
id|ni
)paren
suffix:semicolon
r_goto
id|map_err_out
suffix:semicolon
)brace
multiline_comment|/* Verify the sequence number if it is present. */
r_if
c_cond
(paren
id|seq_no
op_logical_and
(paren
id|le16_to_cpu
c_func
(paren
id|m-&gt;sequence_number
)paren
op_ne
id|seq_no
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|base_ni-&gt;vol-&gt;sb
comma
l_string|&quot;Found stale extent mft &quot;
l_string|&quot;reference! Corrupt file system. Run chkdsk.&quot;
)paren
suffix:semicolon
id|destroy_ni
op_assign
id|TRUE
suffix:semicolon
id|m
op_assign
id|ERR_PTR
c_func
(paren
op_minus
id|EIO
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
multiline_comment|/* Attach extent inode to base inode, reallocating memory if needed. */
r_if
c_cond
(paren
op_logical_neg
(paren
id|base_ni-&gt;nr_extents
op_amp
l_int|3
)paren
)paren
(brace
id|ntfs_inode
op_star
op_star
id|tmp
suffix:semicolon
r_int
id|new_size
op_assign
(paren
id|base_ni-&gt;nr_extents
op_plus
l_int|4
)paren
op_star
r_sizeof
(paren
id|ntfs_inode
op_star
)paren
suffix:semicolon
id|tmp
op_assign
(paren
id|ntfs_inode
op_star
op_star
)paren
id|kmalloc
c_func
(paren
id|new_size
comma
id|GFP_NOFS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|tmp
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|base_ni-&gt;vol-&gt;sb
comma
l_string|&quot;Failed to allocate &quot;
l_string|&quot;internal buffer.&quot;
)paren
suffix:semicolon
id|destroy_ni
op_assign
id|TRUE
suffix:semicolon
id|m
op_assign
id|ERR_PTR
c_func
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|base_ni-&gt;nr_extents
)paren
(brace
id|BUG_ON
c_func
(paren
op_logical_neg
id|base_ni-&gt;ext.extent_ntfs_inos
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|tmp
comma
id|base_ni-&gt;ext.extent_ntfs_inos
comma
id|new_size
op_minus
l_int|4
op_star
r_sizeof
(paren
id|ntfs_inode
op_star
)paren
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|base_ni-&gt;ext.extent_ntfs_inos
)paren
suffix:semicolon
)brace
id|base_ni-&gt;ext.extent_ntfs_inos
op_assign
id|tmp
suffix:semicolon
)brace
id|base_ni-&gt;ext.extent_ntfs_inos
(braket
id|base_ni-&gt;nr_extents
op_increment
)braket
op_assign
id|ni
suffix:semicolon
id|up
c_func
(paren
op_amp
id|base_ni-&gt;extent_lock
)paren
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|base_ni-&gt;count
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Done 2.&quot;
)paren
suffix:semicolon
op_star
id|ntfs_ino
op_assign
id|ni
suffix:semicolon
r_return
id|m
suffix:semicolon
id|unm_err_out
suffix:colon
id|unmap_mft_record
c_func
(paren
id|ni
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|base_ni-&gt;extent_lock
)paren
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|base_ni-&gt;count
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If the extent inode was not attached to the base inode we need to&n;&t; * release it or we will leak memory.&n;&t; */
r_if
c_cond
(paren
id|destroy_ni
)paren
id|ntfs_clear_extent_inode
c_func
(paren
id|ni
)paren
suffix:semicolon
r_return
id|m
suffix:semicolon
)brace
macro_line|#ifdef NTFS_RW
multiline_comment|/**&n; * __mark_mft_record_dirty - set the mft record and the page containing it dirty&n; * @ni:&t;&t;ntfs inode describing the mapped mft record&n; *&n; * Internal function.  Users should call mark_mft_record_dirty() instead.&n; *&n; * Set the mapped (extent) mft record of the (base or extent) ntfs inode @ni,&n; * as well as the page containing the mft record, dirty.  Also, mark the base&n; * vfs inode dirty.  This ensures that any changes to the mft record are&n; * written out to disk.&n; *&n; * NOTE:  We only set I_DIRTY_SYNC and I_DIRTY_DATASYNC (and not I_DIRTY_PAGES)&n; * on the base vfs inode, because even though file data may have been modified,&n; * it is dirty in the inode meta data rather than the data page cache of the&n; * inode, and thus there are no data pages that need writing out.  Therefore, a&n; * full mark_inode_dirty() is overkill.  A mark_inode_dirty_sync(), on the&n; * other hand, is not sufficient, because I_DIRTY_DATASYNC needs to be set to&n; * ensure -&gt;write_inode is called from generic_osync_inode() and this needs to&n; * happen or the file data would not necessarily hit the device synchronously,&n; * even though the vfs inode has the O_SYNC flag set.  Also, I_DIRTY_DATASYNC&n; * simply &quot;feels&quot; better than just I_DIRTY_SYNC, since the file data has not&n; * actually hit the block device yet, which is not what I_DIRTY_SYNC on its own&n; * would suggest.&n; */
DECL|function|__mark_mft_record_dirty
r_void
id|__mark_mft_record_dirty
c_func
(paren
id|ntfs_inode
op_star
id|ni
)paren
(brace
id|ntfs_inode
op_star
id|base_ni
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Entering for inode 0x%lx.&quot;
comma
id|ni-&gt;mft_no
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|NInoAttr
c_func
(paren
id|ni
)paren
)paren
suffix:semicolon
id|mark_ntfs_record_dirty
c_func
(paren
id|ni-&gt;page
comma
id|ni-&gt;page_ofs
)paren
suffix:semicolon
multiline_comment|/* Determine the base vfs inode and mark it dirty, too. */
id|down
c_func
(paren
op_amp
id|ni-&gt;extent_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
id|ni-&gt;nr_extents
op_ge
l_int|0
)paren
)paren
id|base_ni
op_assign
id|ni
suffix:semicolon
r_else
id|base_ni
op_assign
id|ni-&gt;ext.base_ntfs_ino
suffix:semicolon
id|up
c_func
(paren
op_amp
id|ni-&gt;extent_lock
)paren
suffix:semicolon
id|__mark_inode_dirty
c_func
(paren
id|VFS_I
c_func
(paren
id|base_ni
)paren
comma
id|I_DIRTY_SYNC
op_or
id|I_DIRTY_DATASYNC
)paren
suffix:semicolon
)brace
DECL|variable|ntfs_please_email
r_static
r_const
r_char
op_star
id|ntfs_please_email
op_assign
l_string|&quot;Please email &quot;
l_string|&quot;linux-ntfs-dev@lists.sourceforge.net and say that you saw &quot;
l_string|&quot;this message.  Thank you.&quot;
suffix:semicolon
multiline_comment|/**&n; * ntfs_sync_mft_mirror_umount - synchronise an mft record to the mft mirror&n; * @vol:&t;ntfs volume on which the mft record to synchronize resides&n; * @mft_no:&t;mft record number of mft record to synchronize&n; * @m:&t;&t;mapped, mst protected (extent) mft record to synchronize&n; *&n; * Write the mapped, mst protected (extent) mft record @m with mft record&n; * number @mft_no to the mft mirror ($MFTMirr) of the ntfs volume @vol,&n; * bypassing the page cache and the $MFTMirr inode itself.&n; *&n; * This function is only for use at umount time when the mft mirror inode has&n; * already been disposed off.  We BUG() if we are called while the mft mirror&n; * inode is still attached to the volume.&n; *&n; * On success return 0.  On error return -errno.&n; *&n; * NOTE:  This function is not implemented yet as I am not convinced it can&n; * actually be triggered considering the sequence of commits we do in super.c::&n; * ntfs_put_super().  But just in case we provide this place holder as the&n; * alternative would be either to BUG() or to get a NULL pointer dereference&n; * and Oops.&n; */
DECL|function|ntfs_sync_mft_mirror_umount
r_static
r_int
id|ntfs_sync_mft_mirror_umount
c_func
(paren
id|ntfs_volume
op_star
id|vol
comma
r_const
r_int
r_int
id|mft_no
comma
id|MFT_RECORD
op_star
id|m
)paren
(brace
id|BUG_ON
c_func
(paren
id|vol-&gt;mftmirr_ino
)paren
suffix:semicolon
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Umount time mft mirror syncing is not &quot;
l_string|&quot;implemented yet.  %s&quot;
comma
id|ntfs_please_email
)paren
suffix:semicolon
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_sync_mft_mirror - synchronize an mft record to the mft mirror&n; * @vol:&t;ntfs volume on which the mft record to synchronize resides&n; * @mft_no:&t;mft record number of mft record to synchronize&n; * @m:&t;&t;mapped, mst protected (extent) mft record to synchronize&n; * @sync:&t;if true, wait for i/o completion&n; *&n; * Write the mapped, mst protected (extent) mft record @m with mft record&n; * number @mft_no to the mft mirror ($MFTMirr) of the ntfs volume @vol.&n; *&n; * On success return 0.  On error return -errno and set the volume errors flag&n; * in the ntfs volume @vol.&n; *&n; * NOTE:  We always perform synchronous i/o and ignore the @sync parameter.&n; *&n; * TODO:  If @sync is false, want to do truly asynchronous i/o, i.e. just&n; * schedule i/o via -&gt;writepage or do it via kntfsd or whatever.&n; */
DECL|function|ntfs_sync_mft_mirror
r_int
id|ntfs_sync_mft_mirror
c_func
(paren
id|ntfs_volume
op_star
id|vol
comma
r_const
r_int
r_int
id|mft_no
comma
id|MFT_RECORD
op_star
id|m
comma
r_int
id|sync
)paren
(brace
r_struct
id|page
op_star
id|page
suffix:semicolon
r_int
r_int
id|blocksize
op_assign
id|vol-&gt;sb-&gt;s_blocksize
suffix:semicolon
r_int
id|max_bhs
op_assign
id|vol-&gt;mft_record_size
op_div
id|blocksize
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bhs
(braket
id|max_bhs
)braket
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
comma
op_star
id|head
suffix:semicolon
id|u8
op_star
id|kmirr
suffix:semicolon
id|runlist_element
op_star
id|rl
suffix:semicolon
r_int
r_int
id|block_start
comma
id|block_end
comma
id|m_start
comma
id|m_end
comma
id|page_ofs
suffix:semicolon
r_int
id|i_bhs
comma
id|nr_bhs
comma
id|err
op_assign
l_int|0
suffix:semicolon
r_int
r_char
id|blocksize_bits
op_assign
id|vol-&gt;mftmirr_ino-&gt;i_blkbits
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Entering for inode 0x%lx.&quot;
comma
id|mft_no
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|max_bhs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|vol-&gt;mftmirr_ino
)paren
)paren
(brace
multiline_comment|/* This could happen during umount... */
id|err
op_assign
id|ntfs_sync_mft_mirror_umount
c_func
(paren
id|vol
comma
id|mft_no
comma
id|m
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
op_logical_neg
id|err
)paren
)paren
r_return
id|err
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
multiline_comment|/* Get the page containing the mirror copy of the mft record @m. */
id|page
op_assign
id|ntfs_map_page
c_func
(paren
id|vol-&gt;mftmirr_ino-&gt;i_mapping
comma
id|mft_no
op_rshift
(paren
id|PAGE_CACHE_SHIFT
op_minus
id|vol-&gt;mft_record_size_bits
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|page
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Failed to map mft mirror page.&quot;
)paren
suffix:semicolon
id|err
op_assign
id|PTR_ERR
c_func
(paren
id|page
)paren
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
id|lock_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|PageUptodate
c_func
(paren
id|page
)paren
)paren
suffix:semicolon
id|ClearPageUptodate
c_func
(paren
id|page
)paren
suffix:semicolon
multiline_comment|/* Offset of the mft mirror record inside the page. */
id|page_ofs
op_assign
(paren
id|mft_no
op_lshift
id|vol-&gt;mft_record_size_bits
)paren
op_amp
op_complement
id|PAGE_CACHE_MASK
suffix:semicolon
multiline_comment|/* The address in the page of the mirror copy of the mft record @m. */
id|kmirr
op_assign
id|page_address
c_func
(paren
id|page
)paren
op_plus
id|page_ofs
suffix:semicolon
multiline_comment|/* Copy the mst protected mft record to the mirror. */
id|memcpy
c_func
(paren
id|kmirr
comma
id|m
comma
id|vol-&gt;mft_record_size
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Create buffers if not present and mark the ones belonging to the mft&n;&t; * mirror record dirty.&n;&t; */
id|mark_ntfs_record_dirty
c_func
(paren
id|page
comma
id|page_ofs
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|page_has_buffers
c_func
(paren
id|page
)paren
)paren
suffix:semicolon
id|bh
op_assign
id|head
op_assign
id|page_buffers
c_func
(paren
id|page
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|bh
)paren
suffix:semicolon
id|rl
op_assign
l_int|NULL
suffix:semicolon
id|nr_bhs
op_assign
l_int|0
suffix:semicolon
id|block_start
op_assign
l_int|0
suffix:semicolon
id|m_start
op_assign
id|kmirr
op_minus
(paren
id|u8
op_star
)paren
id|page_address
c_func
(paren
id|page
)paren
suffix:semicolon
id|m_end
op_assign
id|m_start
op_plus
id|vol-&gt;mft_record_size
suffix:semicolon
r_do
(brace
id|block_end
op_assign
id|block_start
op_plus
id|blocksize
suffix:semicolon
multiline_comment|/* If the buffer is outside the mft record, skip it. */
r_if
c_cond
(paren
id|block_end
op_le
id|m_start
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|block_start
op_ge
id|m_end
)paren
)paren
r_break
suffix:semicolon
multiline_comment|/* Need to map the buffer if it is not mapped already. */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|buffer_mapped
c_func
(paren
id|bh
)paren
)paren
)paren
(brace
id|VCN
id|vcn
suffix:semicolon
id|LCN
id|lcn
suffix:semicolon
r_int
r_int
id|vcn_ofs
suffix:semicolon
multiline_comment|/* Obtain the vcn and offset of the current block. */
id|vcn
op_assign
(paren
(paren
id|VCN
)paren
id|mft_no
op_lshift
id|vol-&gt;mft_record_size_bits
)paren
op_plus
(paren
id|block_start
op_minus
id|m_start
)paren
suffix:semicolon
id|vcn_ofs
op_assign
id|vcn
op_amp
id|vol-&gt;cluster_size_mask
suffix:semicolon
id|vcn
op_rshift_assign
id|vol-&gt;cluster_size_bits
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rl
)paren
(brace
id|down_read
c_func
(paren
op_amp
id|NTFS_I
c_func
(paren
id|vol-&gt;mftmirr_ino
)paren
op_member_access_from_pointer
id|runlist.lock
)paren
suffix:semicolon
id|rl
op_assign
id|NTFS_I
c_func
(paren
id|vol-&gt;mftmirr_ino
)paren
op_member_access_from_pointer
id|runlist.rl
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * $MFTMirr always has the whole of its runlist&n;&t;&t;&t;&t; * in memory.&n;&t;&t;&t;&t; */
id|BUG_ON
c_func
(paren
op_logical_neg
id|rl
)paren
suffix:semicolon
)brace
multiline_comment|/* Seek to element containing target vcn. */
r_while
c_loop
(paren
id|rl-&gt;length
op_logical_and
id|rl
(braket
l_int|1
)braket
dot
id|vcn
op_le
id|vcn
)paren
id|rl
op_increment
suffix:semicolon
id|lcn
op_assign
id|ntfs_rl_vcn_to_lcn
c_func
(paren
id|rl
comma
id|vcn
)paren
suffix:semicolon
multiline_comment|/* For $MFTMirr, only lcn &gt;= 0 is a successful remap. */
r_if
c_cond
(paren
id|likely
c_func
(paren
id|lcn
op_ge
l_int|0
)paren
)paren
(brace
multiline_comment|/* Setup buffer head to correct block. */
id|bh-&gt;b_blocknr
op_assign
(paren
(paren
id|lcn
op_lshift
id|vol-&gt;cluster_size_bits
)paren
op_plus
id|vcn_ofs
)paren
op_rshift
id|blocksize_bits
suffix:semicolon
id|set_buffer_mapped
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
r_else
(brace
id|bh-&gt;b_blocknr
op_assign
op_minus
l_int|1
suffix:semicolon
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Cannot write mft mirror &quot;
l_string|&quot;record 0x%lx because its &quot;
l_string|&quot;location on disk could not &quot;
l_string|&quot;be determined (error code &quot;
l_string|&quot;%lli).&quot;
comma
id|mft_no
comma
(paren
r_int
r_int
)paren
id|lcn
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
)brace
id|BUG_ON
c_func
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|bh
)paren
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|nr_bhs
op_logical_and
(paren
id|m_start
op_ne
id|block_start
)paren
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|nr_bhs
op_ge
id|max_bhs
)paren
suffix:semicolon
id|bhs
(braket
id|nr_bhs
op_increment
)braket
op_assign
id|bh
suffix:semicolon
id|BUG_ON
c_func
(paren
(paren
id|nr_bhs
op_ge
id|max_bhs
)paren
op_logical_and
(paren
id|m_end
op_ne
id|block_end
)paren
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|block_start
op_assign
id|block_end
comma
(paren
id|bh
op_assign
id|bh-&gt;b_this_page
)paren
op_ne
id|head
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|rl
)paren
)paren
id|up_read
c_func
(paren
op_amp
id|NTFS_I
c_func
(paren
id|vol-&gt;mftmirr_ino
)paren
op_member_access_from_pointer
id|runlist.lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
op_logical_neg
id|err
)paren
)paren
(brace
multiline_comment|/* Lock buffers and start synchronous write i/o on them. */
r_for
c_loop
(paren
id|i_bhs
op_assign
l_int|0
suffix:semicolon
id|i_bhs
OL
id|nr_bhs
suffix:semicolon
id|i_bhs
op_increment
)paren
(brace
r_struct
id|buffer_head
op_star
id|tbh
op_assign
id|bhs
(braket
id|i_bhs
)braket
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|test_set_buffer_locked
c_func
(paren
id|tbh
)paren
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|tbh
)paren
)paren
suffix:semicolon
id|clear_buffer_dirty
c_func
(paren
id|tbh
)paren
suffix:semicolon
id|get_bh
c_func
(paren
id|tbh
)paren
suffix:semicolon
id|tbh-&gt;b_end_io
op_assign
id|end_buffer_write_sync
suffix:semicolon
id|submit_bh
c_func
(paren
id|WRITE
comma
id|tbh
)paren
suffix:semicolon
)brace
multiline_comment|/* Wait on i/o completion of buffers. */
r_for
c_loop
(paren
id|i_bhs
op_assign
l_int|0
suffix:semicolon
id|i_bhs
OL
id|nr_bhs
suffix:semicolon
id|i_bhs
op_increment
)paren
(brace
r_struct
id|buffer_head
op_star
id|tbh
op_assign
id|bhs
(braket
id|i_bhs
)braket
suffix:semicolon
id|wait_on_buffer
c_func
(paren
id|tbh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|tbh
)paren
)paren
)paren
(brace
id|err
op_assign
op_minus
id|EIO
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * Set the buffer uptodate so the page and&n;&t;&t;&t;&t; * buffer states do not become out of sync.&n;&t;&t;&t;&t; */
id|set_buffer_uptodate
c_func
(paren
id|tbh
)paren
suffix:semicolon
)brace
)brace
)brace
r_else
multiline_comment|/* if (unlikely(err)) */
(brace
multiline_comment|/* Clean the buffers. */
r_for
c_loop
(paren
id|i_bhs
op_assign
l_int|0
suffix:semicolon
id|i_bhs
OL
id|nr_bhs
suffix:semicolon
id|i_bhs
op_increment
)paren
id|clear_buffer_dirty
c_func
(paren
id|bhs
(braket
id|i_bhs
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/* Current state: all buffers are clean, unlocked, and uptodate. */
multiline_comment|/* Remove the mst protection fixups again. */
id|post_write_mst_fixup
c_func
(paren
(paren
id|NTFS_RECORD
op_star
)paren
id|kmirr
)paren
suffix:semicolon
id|flush_dcache_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|SetPageUptodate
c_func
(paren
id|page
)paren
suffix:semicolon
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|ntfs_unmap_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
op_logical_neg
id|err
)paren
)paren
(brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Done.&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;I/O error while writing mft mirror &quot;
l_string|&quot;record 0x%lx!&quot;
comma
id|mft_no
)paren
suffix:semicolon
id|err_out
suffix:colon
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Failed to synchronize $MFTMirr (error &quot;
l_string|&quot;code %i).  Volume will be left marked dirty &quot;
l_string|&quot;on umount.  Run ntfsfix on the partition &quot;
l_string|&quot;after umounting to correct this.&quot;
comma
op_minus
id|err
)paren
suffix:semicolon
id|NVolSetErrors
c_func
(paren
id|vol
)paren
suffix:semicolon
)brace
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/**&n; * write_mft_record_nolock - write out a mapped (extent) mft record&n; * @ni:&t;&t;ntfs inode describing the mapped (extent) mft record&n; * @m:&t;&t;mapped (extent) mft record to write&n; * @sync:&t;if true, wait for i/o completion&n; *&n; * Write the mapped (extent) mft record @m described by the (regular or extent)&n; * ntfs inode @ni to backing store.  If the mft record @m has a counterpart in&n; * the mft mirror, that is also updated.&n; *&n; * We only write the mft record if the ntfs inode @ni is dirty and the first&n; * buffer belonging to its mft record is dirty, too.  We ignore the dirty state&n; * of subsequent buffers because we could have raced with&n; * fs/ntfs/aops.c::mark_ntfs_record_dirty().&n; *&n; * On success, clean the mft record and return 0.  On error, leave the mft&n; * record dirty and return -errno.  The caller should call make_bad_inode() on&n; * the base inode to ensure no more access happens to this inode.  We do not do&n; * it here as the caller may want to finish writing other extent mft records&n; * first to minimize on-disk metadata inconsistencies.&n; *&n; * NOTE:  We always perform synchronous i/o and ignore the @sync parameter.&n; * However, if the mft record has a counterpart in the mft mirror and @sync is&n; * true, we write the mft record, wait for i/o completion, and only then write&n; * the mft mirror copy.  This ensures that if the system crashes either the mft&n; * or the mft mirror will contain a self-consistent mft record @m.  If @sync is&n; * false on the other hand, we start i/o on both and then wait for completion&n; * on them.  This provides a speedup but no longer guarantees that you will end&n; * up with a self-consistent mft record in the case of a crash but if you asked&n; * for asynchronous writing you probably do not care about that anyway.&n; *&n; * TODO:  If @sync is false, want to do truly asynchronous i/o, i.e. just&n; * schedule i/o via -&gt;writepage or do it via kntfsd or whatever.&n; */
DECL|function|write_mft_record_nolock
r_int
id|write_mft_record_nolock
c_func
(paren
id|ntfs_inode
op_star
id|ni
comma
id|MFT_RECORD
op_star
id|m
comma
r_int
id|sync
)paren
(brace
id|ntfs_volume
op_star
id|vol
op_assign
id|ni-&gt;vol
suffix:semicolon
r_struct
id|page
op_star
id|page
op_assign
id|ni-&gt;page
suffix:semicolon
r_int
r_char
id|blocksize_bits
op_assign
id|vol-&gt;mft_ino-&gt;i_blkbits
suffix:semicolon
r_int
r_int
id|blocksize
op_assign
l_int|1
op_lshift
id|blocksize_bits
suffix:semicolon
r_int
id|max_bhs
op_assign
id|vol-&gt;mft_record_size
op_div
id|blocksize
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bhs
(braket
id|max_bhs
)braket
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
comma
op_star
id|head
suffix:semicolon
id|runlist_element
op_star
id|rl
suffix:semicolon
r_int
r_int
id|block_start
comma
id|block_end
comma
id|m_start
comma
id|m_end
suffix:semicolon
r_int
id|i_bhs
comma
id|nr_bhs
comma
id|err
op_assign
l_int|0
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Entering for inode 0x%lx.&quot;
comma
id|ni-&gt;mft_no
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|NInoAttr
c_func
(paren
id|ni
)paren
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|max_bhs
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|PageLocked
c_func
(paren
id|page
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If the ntfs_inode is clean no need to do anything.  If it is dirty,&n;&t; * mark it as clean now so that it can be redirtied later on if needed.&n;&t; * There is no danger of races since the caller is holding the locks&n;&t; * for the mft record @m and the page it is in.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|NInoTestClearDirty
c_func
(paren
id|ni
)paren
)paren
r_goto
id|done
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|page_has_buffers
c_func
(paren
id|page
)paren
)paren
suffix:semicolon
id|bh
op_assign
id|head
op_assign
id|page_buffers
c_func
(paren
id|page
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|bh
)paren
suffix:semicolon
id|rl
op_assign
l_int|NULL
suffix:semicolon
id|nr_bhs
op_assign
l_int|0
suffix:semicolon
id|block_start
op_assign
l_int|0
suffix:semicolon
id|m_start
op_assign
id|ni-&gt;page_ofs
suffix:semicolon
id|m_end
op_assign
id|m_start
op_plus
id|vol-&gt;mft_record_size
suffix:semicolon
r_do
(brace
id|block_end
op_assign
id|block_start
op_plus
id|blocksize
suffix:semicolon
multiline_comment|/* If the buffer is outside the mft record, skip it. */
r_if
c_cond
(paren
id|block_end
op_le
id|m_start
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|block_start
op_ge
id|m_end
)paren
)paren
r_break
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If this block is not the first one in the record, we ignore&n;&t;&t; * the buffer&squot;s dirty state because we could have raced with a&n;&t;&t; * parallel mark_ntfs_record_dirty().&n;&t;&t; */
r_if
c_cond
(paren
id|block_start
op_eq
id|m_start
)paren
(brace
multiline_comment|/* This block is the first one in the record. */
r_if
c_cond
(paren
op_logical_neg
id|buffer_dirty
c_func
(paren
id|bh
)paren
)paren
(brace
id|BUG_ON
c_func
(paren
id|nr_bhs
)paren
suffix:semicolon
multiline_comment|/* Clean records are not written out. */
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* Need to map the buffer if it is not mapped already. */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|buffer_mapped
c_func
(paren
id|bh
)paren
)paren
)paren
(brace
id|VCN
id|vcn
suffix:semicolon
id|LCN
id|lcn
suffix:semicolon
r_int
r_int
id|vcn_ofs
suffix:semicolon
multiline_comment|/* Obtain the vcn and offset of the current block. */
id|vcn
op_assign
(paren
(paren
id|VCN
)paren
id|ni-&gt;mft_no
op_lshift
id|vol-&gt;mft_record_size_bits
)paren
op_plus
(paren
id|block_start
op_minus
id|m_start
)paren
suffix:semicolon
id|vcn_ofs
op_assign
id|vcn
op_amp
id|vol-&gt;cluster_size_mask
suffix:semicolon
id|vcn
op_rshift_assign
id|vol-&gt;cluster_size_bits
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rl
)paren
(brace
id|down_read
c_func
(paren
op_amp
id|NTFS_I
c_func
(paren
id|vol-&gt;mft_ino
)paren
op_member_access_from_pointer
id|runlist.lock
)paren
suffix:semicolon
id|rl
op_assign
id|NTFS_I
c_func
(paren
id|vol-&gt;mft_ino
)paren
op_member_access_from_pointer
id|runlist.rl
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|rl
)paren
suffix:semicolon
)brace
multiline_comment|/* Seek to element containing target vcn. */
r_while
c_loop
(paren
id|rl-&gt;length
op_logical_and
id|rl
(braket
l_int|1
)braket
dot
id|vcn
op_le
id|vcn
)paren
id|rl
op_increment
suffix:semicolon
id|lcn
op_assign
id|ntfs_rl_vcn_to_lcn
c_func
(paren
id|rl
comma
id|vcn
)paren
suffix:semicolon
multiline_comment|/* For $MFT, only lcn &gt;= 0 is a successful remap. */
r_if
c_cond
(paren
id|likely
c_func
(paren
id|lcn
op_ge
l_int|0
)paren
)paren
(brace
multiline_comment|/* Setup buffer head to correct block. */
id|bh-&gt;b_blocknr
op_assign
(paren
(paren
id|lcn
op_lshift
id|vol-&gt;cluster_size_bits
)paren
op_plus
id|vcn_ofs
)paren
op_rshift
id|blocksize_bits
suffix:semicolon
id|set_buffer_mapped
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
r_else
(brace
id|bh-&gt;b_blocknr
op_assign
op_minus
l_int|1
suffix:semicolon
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Cannot write mft record &quot;
l_string|&quot;0x%lx because its location &quot;
l_string|&quot;on disk could not be &quot;
l_string|&quot;determined (error code %lli).&quot;
comma
id|ni-&gt;mft_no
comma
(paren
r_int
r_int
)paren
id|lcn
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
)brace
id|BUG_ON
c_func
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|bh
)paren
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|nr_bhs
op_logical_and
(paren
id|m_start
op_ne
id|block_start
)paren
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|nr_bhs
op_ge
id|max_bhs
)paren
suffix:semicolon
id|bhs
(braket
id|nr_bhs
op_increment
)braket
op_assign
id|bh
suffix:semicolon
id|BUG_ON
c_func
(paren
(paren
id|nr_bhs
op_ge
id|max_bhs
)paren
op_logical_and
(paren
id|m_end
op_ne
id|block_end
)paren
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|block_start
op_assign
id|block_end
comma
(paren
id|bh
op_assign
id|bh-&gt;b_this_page
)paren
op_ne
id|head
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|rl
)paren
)paren
id|up_read
c_func
(paren
op_amp
id|NTFS_I
c_func
(paren
id|vol-&gt;mft_ino
)paren
op_member_access_from_pointer
id|runlist.lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|nr_bhs
)paren
r_goto
id|done
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|err
)paren
)paren
r_goto
id|cleanup_out
suffix:semicolon
multiline_comment|/* Apply the mst protection fixups. */
id|err
op_assign
id|pre_write_mst_fixup
c_func
(paren
(paren
id|NTFS_RECORD
op_star
)paren
id|m
comma
id|vol-&gt;mft_record_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Failed to apply mst fixups!&quot;
)paren
suffix:semicolon
r_goto
id|cleanup_out
suffix:semicolon
)brace
id|flush_dcache_mft_record_page
c_func
(paren
id|ni
)paren
suffix:semicolon
multiline_comment|/* Lock buffers and start synchronous write i/o on them. */
r_for
c_loop
(paren
id|i_bhs
op_assign
l_int|0
suffix:semicolon
id|i_bhs
OL
id|nr_bhs
suffix:semicolon
id|i_bhs
op_increment
)paren
(brace
r_struct
id|buffer_head
op_star
id|tbh
op_assign
id|bhs
(braket
id|i_bhs
)braket
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|test_set_buffer_locked
c_func
(paren
id|tbh
)paren
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|tbh
)paren
)paren
suffix:semicolon
id|clear_buffer_dirty
c_func
(paren
id|tbh
)paren
suffix:semicolon
id|get_bh
c_func
(paren
id|tbh
)paren
suffix:semicolon
id|tbh-&gt;b_end_io
op_assign
id|end_buffer_write_sync
suffix:semicolon
id|submit_bh
c_func
(paren
id|WRITE
comma
id|tbh
)paren
suffix:semicolon
)brace
multiline_comment|/* Synchronize the mft mirror now if not @sync. */
r_if
c_cond
(paren
op_logical_neg
id|sync
op_logical_and
id|ni-&gt;mft_no
OL
id|vol-&gt;mftmirr_size
)paren
id|ntfs_sync_mft_mirror
c_func
(paren
id|vol
comma
id|ni-&gt;mft_no
comma
id|m
comma
id|sync
)paren
suffix:semicolon
multiline_comment|/* Wait on i/o completion of buffers. */
r_for
c_loop
(paren
id|i_bhs
op_assign
l_int|0
suffix:semicolon
id|i_bhs
OL
id|nr_bhs
suffix:semicolon
id|i_bhs
op_increment
)paren
(brace
r_struct
id|buffer_head
op_star
id|tbh
op_assign
id|bhs
(braket
id|i_bhs
)braket
suffix:semicolon
id|wait_on_buffer
c_func
(paren
id|tbh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|tbh
)paren
)paren
)paren
(brace
id|err
op_assign
op_minus
id|EIO
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Set the buffer uptodate so the page and buffer&n;&t;&t;&t; * states do not become out of sync.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|PageUptodate
c_func
(paren
id|page
)paren
)paren
id|set_buffer_uptodate
c_func
(paren
id|tbh
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* If @sync, now synchronize the mft mirror. */
r_if
c_cond
(paren
id|sync
op_logical_and
id|ni-&gt;mft_no
OL
id|vol-&gt;mftmirr_size
)paren
id|ntfs_sync_mft_mirror
c_func
(paren
id|vol
comma
id|ni-&gt;mft_no
comma
id|m
comma
id|sync
)paren
suffix:semicolon
multiline_comment|/* Remove the mst protection fixups again. */
id|post_write_mst_fixup
c_func
(paren
(paren
id|NTFS_RECORD
op_star
)paren
id|m
)paren
suffix:semicolon
id|flush_dcache_mft_record_page
c_func
(paren
id|ni
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|err
)paren
)paren
(brace
multiline_comment|/* I/O error during writing.  This is really bad! */
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;I/O error while writing mft record &quot;
l_string|&quot;0x%lx!  Marking base inode as bad.  You &quot;
l_string|&quot;should unmount the volume and run chkdsk.&quot;
comma
id|ni-&gt;mft_no
)paren
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
id|done
suffix:colon
id|ntfs_debug
c_func
(paren
l_string|&quot;Done.&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|cleanup_out
suffix:colon
multiline_comment|/* Clean the buffers. */
r_for
c_loop
(paren
id|i_bhs
op_assign
l_int|0
suffix:semicolon
id|i_bhs
OL
id|nr_bhs
suffix:semicolon
id|i_bhs
op_increment
)paren
id|clear_buffer_dirty
c_func
(paren
id|bhs
(braket
id|i_bhs
)braket
)paren
suffix:semicolon
id|err_out
suffix:colon
multiline_comment|/*&n;&t; * Current state: all buffers are clean, unlocked, and uptodate.&n;&t; * The caller should mark the base inode as bad so that no more i/o&n;&t; * happens.  -&gt;clear_inode() will still be invoked so all extent inodes&n;&t; * and other allocated memory will be freed.&n;&t; */
r_if
c_cond
(paren
id|err
op_eq
op_minus
id|ENOMEM
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Not enough memory to write mft record.  &quot;
l_string|&quot;Redirtying so the write is retried later.&quot;
)paren
suffix:semicolon
id|mark_mft_record_dirty
c_func
(paren
id|ni
)paren
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
)brace
r_else
id|NVolSetErrors
c_func
(paren
id|vol
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_may_write_mft_record - check if an mft record may be written out&n; * @vol:&t;[IN]  ntfs volume on which the mft record to check resides&n; * @mft_no:&t;[IN]  mft record number of the mft record to check&n; * @m:&t;&t;[IN]  mapped mft record to check&n; * @locked_ni:&t;[OUT] caller has to unlock this ntfs inode if one is returned&n; *&n; * Check if the mapped (base or extent) mft record @m with mft record number&n; * @mft_no belonging to the ntfs volume @vol may be written out.  If necessary&n; * and possible the ntfs inode of the mft record is locked and the base vfs&n; * inode is pinned.  The locked ntfs inode is then returned in @locked_ni.  The&n; * caller is responsible for unlocking the ntfs inode and unpinning the base&n; * vfs inode.&n; *&n; * Return TRUE if the mft record may be written out and FALSE if not.&n; *&n; * The caller has locked the page and cleared the uptodate flag on it which&n; * means that we can safely write out any dirty mft records that do not have&n; * their inodes in icache as determined by ilookup5() as anyone&n; * opening/creating such an inode would block when attempting to map the mft&n; * record in read_cache_page() until we are finished with the write out.&n; *&n; * Here is a description of the tests we perform:&n; *&n; * If the inode is found in icache we know the mft record must be a base mft&n; * record.  If it is dirty, we do not write it and return FALSE as the vfs&n; * inode write paths will result in the access times being updated which would&n; * cause the base mft record to be redirtied and written out again.  (We know&n; * the access time update will modify the base mft record because Windows&n; * chkdsk complains if the standard information attribute is not in the base&n; * mft record.)&n; *&n; * If the inode is in icache and not dirty, we attempt to lock the mft record&n; * and if we find the lock was already taken, it is not safe to write the mft&n; * record and we return FALSE.&n; *&n; * If we manage to obtain the lock we have exclusive access to the mft record,&n; * which also allows us safe writeout of the mft record.  We then set&n; * @locked_ni to the locked ntfs inode and return TRUE.&n; *&n; * Note we cannot just lock the mft record and sleep while waiting for the lock&n; * because this would deadlock due to lock reversal (normally the mft record is&n; * locked before the page is locked but we already have the page locked here&n; * when we try to lock the mft record).&n; *&n; * If the inode is not in icache we need to perform further checks.&n; *&n; * If the mft record is not a FILE record or it is a base mft record, we can&n; * safely write it and return TRUE.&n; *&n; * We now know the mft record is an extent mft record.  We check if the inode&n; * corresponding to its base mft record is in icache and obtain a reference to&n; * it if it is.  If it is not, we can safely write it and return TRUE.&n; *&n; * We now have the base inode for the extent mft record.  We check if it has an&n; * ntfs inode for the extent mft record attached and if not it is safe to write&n; * the extent mft record and we return TRUE.&n; *&n; * The ntfs inode for the extent mft record is attached to the base inode so we&n; * attempt to lock the extent mft record and if we find the lock was already&n; * taken, it is not safe to write the extent mft record and we return FALSE.&n; *&n; * If we manage to obtain the lock we have exclusive access to the extent mft&n; * record, which also allows us safe writeout of the extent mft record.  We&n; * set the ntfs inode of the extent mft record clean and then set @locked_ni to&n; * the now locked ntfs inode and return TRUE.&n; *&n; * Note, the reason for actually writing dirty mft records here and not just&n; * relying on the vfs inode dirty code paths is that we can have mft records&n; * modified without them ever having actual inodes in memory.  Also we can have&n; * dirty mft records with clean ntfs inodes in memory.  None of the described&n; * cases would result in the dirty mft records being written out if we only&n; * relied on the vfs inode dirty code paths.  And these cases can really occur&n; * during allocation of new mft records and in particular when the&n; * initialized_size of the $MFT/$DATA attribute is extended and the new space&n; * is initialized using ntfs_mft_record_format().  The clean inode can then&n; * appear if the mft record is reused for a new inode before it got written&n; * out.&n; */
DECL|function|ntfs_may_write_mft_record
id|BOOL
id|ntfs_may_write_mft_record
c_func
(paren
id|ntfs_volume
op_star
id|vol
comma
r_const
r_int
r_int
id|mft_no
comma
r_const
id|MFT_RECORD
op_star
id|m
comma
id|ntfs_inode
op_star
op_star
id|locked_ni
)paren
(brace
r_struct
id|super_block
op_star
id|sb
op_assign
id|vol-&gt;sb
suffix:semicolon
r_struct
id|inode
op_star
id|mft_vi
op_assign
id|vol-&gt;mft_ino
suffix:semicolon
r_struct
id|inode
op_star
id|vi
suffix:semicolon
id|ntfs_inode
op_star
id|ni
comma
op_star
id|eni
comma
op_star
op_star
id|extent_nis
suffix:semicolon
r_int
id|i
suffix:semicolon
id|ntfs_attr
id|na
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Entering for inode 0x%lx.&quot;
comma
id|mft_no
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Normally we do not return a locked inode so set @locked_ni to NULL.&n;&t; */
id|BUG_ON
c_func
(paren
op_logical_neg
id|locked_ni
)paren
suffix:semicolon
op_star
id|locked_ni
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * Check if the inode corresponding to this mft record is in the VFS&n;&t; * inode cache and obtain a reference to it if it is.&n;&t; */
id|ntfs_debug
c_func
(paren
l_string|&quot;Looking for inode 0x%lx in icache.&quot;
comma
id|mft_no
)paren
suffix:semicolon
id|na.mft_no
op_assign
id|mft_no
suffix:semicolon
id|na.name
op_assign
l_int|NULL
suffix:semicolon
id|na.name_len
op_assign
l_int|0
suffix:semicolon
id|na.type
op_assign
id|AT_UNUSED
suffix:semicolon
multiline_comment|/*&n;&t; * For inode 0, i.e. $MFT itself, we cannot use ilookup5() from here or&n;&t; * we deadlock because the inode is already locked by the kernel&n;&t; * (fs/fs-writeback.c::__sync_single_inode()) and ilookup5() waits&n;&t; * until the inode is unlocked before returning it and it never gets&n;&t; * unlocked because ntfs_should_write_mft_record() never returns.  )-:&n;&t; * Fortunately, we have inode 0 pinned in icache for the duration of&n;&t; * the mount so we can access it directly.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|mft_no
)paren
(brace
multiline_comment|/* Balance the below iput(). */
id|vi
op_assign
id|igrab
c_func
(paren
id|mft_vi
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|vi
op_ne
id|mft_vi
)paren
suffix:semicolon
)brace
r_else
id|vi
op_assign
id|ilookup5
c_func
(paren
id|sb
comma
id|mft_no
comma
(paren
id|test_t
)paren
id|ntfs_test_inode
comma
op_amp
id|na
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vi
)paren
(brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Base inode 0x%lx is in icache.&quot;
comma
id|mft_no
)paren
suffix:semicolon
multiline_comment|/* The inode is in icache. */
id|ni
op_assign
id|NTFS_I
c_func
(paren
id|vi
)paren
suffix:semicolon
multiline_comment|/* Take a reference to the ntfs inode. */
id|atomic_inc
c_func
(paren
op_amp
id|ni-&gt;count
)paren
suffix:semicolon
multiline_comment|/* If the inode is dirty, do not write this record. */
r_if
c_cond
(paren
id|NInoDirty
c_func
(paren
id|ni
)paren
)paren
(brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Inode 0x%lx is dirty, do not write it.&quot;
comma
id|mft_no
)paren
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|ni-&gt;count
)paren
suffix:semicolon
id|iput
c_func
(paren
id|vi
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Inode 0x%lx is not dirty.&quot;
comma
id|mft_no
)paren
suffix:semicolon
multiline_comment|/* The inode is not dirty, try to take the mft record lock. */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|down_trylock
c_func
(paren
op_amp
id|ni-&gt;mrec_lock
)paren
)paren
)paren
(brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Mft record 0x%lx is already locked, do &quot;
l_string|&quot;not write it.&quot;
comma
id|mft_no
)paren
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|ni-&gt;count
)paren
suffix:semicolon
id|iput
c_func
(paren
id|vi
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Managed to lock mft record 0x%lx, write it.&quot;
comma
id|mft_no
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * The write has to occur while we hold the mft record lock so&n;&t;&t; * return the locked ntfs inode.&n;&t;&t; */
op_star
id|locked_ni
op_assign
id|ni
suffix:semicolon
r_return
id|TRUE
suffix:semicolon
)brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Inode 0x%lx is not in icache.&quot;
comma
id|mft_no
)paren
suffix:semicolon
multiline_comment|/* The inode is not in icache. */
multiline_comment|/* Write the record if it is not a mft record (type &quot;FILE&quot;). */
r_if
c_cond
(paren
op_logical_neg
id|ntfs_is_mft_record
c_func
(paren
id|m-&gt;magic
)paren
)paren
(brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Mft record 0x%lx is not a FILE record, write it.&quot;
comma
id|mft_no
)paren
suffix:semicolon
r_return
id|TRUE
suffix:semicolon
)brace
multiline_comment|/* Write the mft record if it is a base inode. */
r_if
c_cond
(paren
op_logical_neg
id|m-&gt;base_mft_record
)paren
(brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Mft record 0x%lx is a base record, write it.&quot;
comma
id|mft_no
)paren
suffix:semicolon
r_return
id|TRUE
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * This is an extent mft record.  Check if the inode corresponding to&n;&t; * its base mft record is in icache and obtain a reference to it if it&n;&t; * is.&n;&t; */
id|na.mft_no
op_assign
id|MREF_LE
c_func
(paren
id|m-&gt;base_mft_record
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Mft record 0x%lx is an extent record.  Looking for base &quot;
l_string|&quot;inode 0x%lx in icache.&quot;
comma
id|mft_no
comma
id|na.mft_no
)paren
suffix:semicolon
id|vi
op_assign
id|ilookup5
c_func
(paren
id|sb
comma
id|na.mft_no
comma
(paren
id|test_t
)paren
id|ntfs_test_inode
comma
op_amp
id|na
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vi
)paren
(brace
multiline_comment|/*&n;&t;&t; * The base inode is not in icache, write this extent mft&n;&t;&t; * record.&n;&t;&t; */
id|ntfs_debug
c_func
(paren
l_string|&quot;Base inode 0x%lx is not in icache, write the &quot;
l_string|&quot;extent record.&quot;
comma
id|na.mft_no
)paren
suffix:semicolon
r_return
id|TRUE
suffix:semicolon
)brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Base inode 0x%lx is in icache.&quot;
comma
id|na.mft_no
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * The base inode is in icache.  Check if it has the extent inode&n;&t; * corresponding to this extent mft record attached.&n;&t; */
id|ni
op_assign
id|NTFS_I
c_func
(paren
id|vi
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|ni-&gt;extent_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ni-&gt;nr_extents
op_le
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * The base inode has no attached extent inodes, write this&n;&t;&t; * extent mft record.&n;&t;&t; */
id|up
c_func
(paren
op_amp
id|ni-&gt;extent_lock
)paren
suffix:semicolon
id|iput
c_func
(paren
id|vi
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Base inode 0x%lx has no attached extent inodes, &quot;
l_string|&quot;write the extent record.&quot;
comma
id|na.mft_no
)paren
suffix:semicolon
r_return
id|TRUE
suffix:semicolon
)brace
multiline_comment|/* Iterate over the attached extent inodes. */
id|extent_nis
op_assign
id|ni-&gt;ext.extent_ntfs_inos
suffix:semicolon
r_for
c_loop
(paren
id|eni
op_assign
l_int|NULL
comma
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ni-&gt;nr_extents
suffix:semicolon
op_increment
id|i
)paren
(brace
r_if
c_cond
(paren
id|mft_no
op_eq
id|extent_nis
(braket
id|i
)braket
op_member_access_from_pointer
id|mft_no
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Found the extent inode corresponding to this extent&n;&t;&t;&t; * mft record.&n;&t;&t;&t; */
id|eni
op_assign
id|extent_nis
(braket
id|i
)braket
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * If the extent inode was not attached to the base inode, write this&n;&t; * extent mft record.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|eni
)paren
(brace
id|up
c_func
(paren
op_amp
id|ni-&gt;extent_lock
)paren
suffix:semicolon
id|iput
c_func
(paren
id|vi
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Extent inode 0x%lx is not attached to its base &quot;
l_string|&quot;inode 0x%lx, write the extent record.&quot;
comma
id|mft_no
comma
id|na.mft_no
)paren
suffix:semicolon
r_return
id|TRUE
suffix:semicolon
)brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Extent inode 0x%lx is attached to its base inode 0x%lx.&quot;
comma
id|mft_no
comma
id|na.mft_no
)paren
suffix:semicolon
multiline_comment|/* Take a reference to the extent ntfs inode. */
id|atomic_inc
c_func
(paren
op_amp
id|eni-&gt;count
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|ni-&gt;extent_lock
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Found the extent inode coresponding to this extent mft record.&n;&t; * Try to take the mft record lock.&n;&t; */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|down_trylock
c_func
(paren
op_amp
id|eni-&gt;mrec_lock
)paren
)paren
)paren
(brace
id|atomic_dec
c_func
(paren
op_amp
id|eni-&gt;count
)paren
suffix:semicolon
id|iput
c_func
(paren
id|vi
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Extent mft record 0x%lx is already locked, do &quot;
l_string|&quot;not write it.&quot;
comma
id|mft_no
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Managed to lock extent mft record 0x%lx, write it.&quot;
comma
id|mft_no
)paren
suffix:semicolon
r_if
c_cond
(paren
id|NInoTestClearDirty
c_func
(paren
id|eni
)paren
)paren
id|ntfs_debug
c_func
(paren
l_string|&quot;Extent inode 0x%lx is dirty, marking it clean.&quot;
comma
id|mft_no
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * The write has to occur while we hold the mft record lock so return&n;&t; * the locked extent ntfs inode.&n;&t; */
op_star
id|locked_ni
op_assign
id|eni
suffix:semicolon
r_return
id|TRUE
suffix:semicolon
)brace
DECL|variable|es
r_static
r_const
r_char
op_star
id|es
op_assign
l_string|&quot;  Leaving inconsistent metadata.  Unmount and run &quot;
l_string|&quot;chkdsk.&quot;
suffix:semicolon
multiline_comment|/**&n; * ntfs_mft_bitmap_find_and_alloc_free_rec_nolock - see name&n; * @vol:&t;volume on which to search for a free mft record&n; * @base_ni:&t;open base inode if allocating an extent mft record or NULL&n; *&n; * Search for a free mft record in the mft bitmap attribute on the ntfs volume&n; * @vol.&n; *&n; * If @base_ni is NULL start the search at the default allocator position.&n; *&n; * If @base_ni is not NULL start the search at the mft record after the base&n; * mft record @base_ni.&n; *&n; * Return the free mft record on success and -errno on error.  An error code of&n; * -ENOSPC means that there are no free mft records in the currently&n; * initialized mft bitmap.&n; *&n; * Locking: Caller must hold vol-&gt;mftbmp_lock for writing.&n; */
DECL|function|ntfs_mft_bitmap_find_and_alloc_free_rec_nolock
r_static
r_int
id|ntfs_mft_bitmap_find_and_alloc_free_rec_nolock
c_func
(paren
id|ntfs_volume
op_star
id|vol
comma
id|ntfs_inode
op_star
id|base_ni
)paren
(brace
id|s64
id|pass_end
comma
id|ll
comma
id|data_pos
comma
id|pass_start
comma
id|ofs
comma
id|bit
suffix:semicolon
r_struct
id|address_space
op_star
id|mftbmp_mapping
suffix:semicolon
id|u8
op_star
id|buf
comma
op_star
id|byte
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
r_int
r_int
id|page_ofs
comma
id|size
suffix:semicolon
id|u8
id|pass
comma
id|b
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Searching for free mft record in the currently &quot;
l_string|&quot;initialized mft bitmap.&quot;
)paren
suffix:semicolon
id|mftbmp_mapping
op_assign
id|vol-&gt;mftbmp_ino-&gt;i_mapping
suffix:semicolon
multiline_comment|/*&n;&t; * Set the end of the pass making sure we do not overflow the mft&n;&t; * bitmap.&n;&t; */
id|pass_end
op_assign
id|NTFS_I
c_func
(paren
id|vol-&gt;mft_ino
)paren
op_member_access_from_pointer
id|allocated_size
op_rshift
id|vol-&gt;mft_record_size_bits
suffix:semicolon
id|ll
op_assign
id|NTFS_I
c_func
(paren
id|vol-&gt;mftbmp_ino
)paren
op_member_access_from_pointer
id|initialized_size
op_lshift
l_int|3
suffix:semicolon
r_if
c_cond
(paren
id|pass_end
OG
id|ll
)paren
id|pass_end
op_assign
id|ll
suffix:semicolon
id|pass
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|base_ni
)paren
id|data_pos
op_assign
id|vol-&gt;mft_data_pos
suffix:semicolon
r_else
id|data_pos
op_assign
id|base_ni-&gt;mft_no
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|data_pos
OL
l_int|24
)paren
id|data_pos
op_assign
l_int|24
suffix:semicolon
r_if
c_cond
(paren
id|data_pos
op_ge
id|pass_end
)paren
(brace
id|data_pos
op_assign
l_int|24
suffix:semicolon
id|pass
op_assign
l_int|2
suffix:semicolon
multiline_comment|/* This happens on a freshly formatted volume. */
r_if
c_cond
(paren
id|data_pos
op_ge
id|pass_end
)paren
r_return
op_minus
id|ENOSPC
suffix:semicolon
)brace
id|pass_start
op_assign
id|data_pos
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Starting bitmap search: pass %u, pass_start 0x%llx, &quot;
l_string|&quot;pass_end 0x%llx, data_pos 0x%llx.&quot;
comma
id|pass
comma
(paren
r_int
r_int
)paren
id|pass_start
comma
(paren
r_int
r_int
)paren
id|pass_end
comma
(paren
r_int
r_int
)paren
id|data_pos
)paren
suffix:semicolon
multiline_comment|/* Loop until a free mft record is found. */
r_for
c_loop
(paren
suffix:semicolon
id|pass
op_le
l_int|2
suffix:semicolon
)paren
(brace
multiline_comment|/* Cap size to pass_end. */
id|ofs
op_assign
id|data_pos
op_rshift
l_int|3
suffix:semicolon
id|page_ofs
op_assign
id|ofs
op_amp
op_complement
id|PAGE_CACHE_MASK
suffix:semicolon
id|size
op_assign
id|PAGE_CACHE_SIZE
op_minus
id|page_ofs
suffix:semicolon
id|ll
op_assign
(paren
(paren
id|pass_end
op_plus
l_int|7
)paren
op_rshift
l_int|3
)paren
op_minus
id|ofs
suffix:semicolon
r_if
c_cond
(paren
id|size
OG
id|ll
)paren
id|size
op_assign
id|ll
suffix:semicolon
id|size
op_lshift_assign
l_int|3
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If we are still within the active pass, search the next page&n;&t;&t; * for a zero bit.&n;&t;&t; */
r_if
c_cond
(paren
id|size
)paren
(brace
id|page
op_assign
id|ntfs_map_page
c_func
(paren
id|mftbmp_mapping
comma
id|ofs
op_rshift
id|PAGE_CACHE_SHIFT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|IS_ERR
c_func
(paren
id|page
)paren
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Failed to read mft &quot;
l_string|&quot;bitmap, aborting.&quot;
)paren
suffix:semicolon
r_return
id|PTR_ERR
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
id|buf
op_assign
(paren
id|u8
op_star
)paren
id|page_address
c_func
(paren
id|page
)paren
op_plus
id|page_ofs
suffix:semicolon
id|bit
op_assign
id|data_pos
op_amp
l_int|7
suffix:semicolon
id|data_pos
op_and_assign
op_complement
l_int|7ull
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Before inner for loop: size 0x%x, &quot;
l_string|&quot;data_pos 0x%llx, bit 0x%llx&quot;
comma
id|size
comma
(paren
r_int
r_int
)paren
id|data_pos
comma
(paren
r_int
r_int
)paren
id|bit
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|bit
OL
id|size
op_logical_and
id|data_pos
op_plus
id|bit
OL
id|pass_end
suffix:semicolon
id|bit
op_and_assign
op_complement
l_int|7ull
comma
id|bit
op_add_assign
l_int|8
)paren
(brace
id|byte
op_assign
id|buf
op_plus
(paren
id|bit
op_rshift
l_int|3
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|byte
op_eq
l_int|0xff
)paren
r_continue
suffix:semicolon
id|b
op_assign
id|ffz
c_func
(paren
(paren
r_int
r_int
)paren
op_star
id|byte
)paren
suffix:semicolon
r_if
c_cond
(paren
id|b
OL
l_int|8
op_logical_and
id|b
op_ge
(paren
id|bit
op_amp
l_int|7
)paren
)paren
(brace
id|ll
op_assign
id|data_pos
op_plus
(paren
id|bit
op_amp
op_complement
l_int|7ull
)paren
op_plus
id|b
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|ll
OG
(paren
l_int|1ll
op_lshift
l_int|32
)paren
)paren
)paren
(brace
id|ntfs_unmap_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
op_minus
id|ENOSPC
suffix:semicolon
)brace
op_star
id|byte
op_or_assign
l_int|1
op_lshift
id|b
suffix:semicolon
id|flush_dcache_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|set_page_dirty
c_func
(paren
id|page
)paren
suffix:semicolon
id|ntfs_unmap_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Done.  (Found and &quot;
l_string|&quot;allocated mft record &quot;
l_string|&quot;0x%llx.)&quot;
comma
(paren
r_int
r_int
)paren
id|ll
)paren
suffix:semicolon
r_return
id|ll
suffix:semicolon
)brace
)brace
id|ntfs_debug
c_func
(paren
l_string|&quot;After inner for loop: size 0x%x, &quot;
l_string|&quot;data_pos 0x%llx, bit 0x%llx&quot;
comma
id|size
comma
(paren
r_int
r_int
)paren
id|data_pos
comma
(paren
r_int
r_int
)paren
id|bit
)paren
suffix:semicolon
id|data_pos
op_add_assign
id|size
suffix:semicolon
id|ntfs_unmap_page
c_func
(paren
id|page
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * If the end of the pass has not been reached yet,&n;&t;&t;&t; * continue searching the mft bitmap for a zero bit.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|data_pos
OL
id|pass_end
)paren
r_continue
suffix:semicolon
)brace
multiline_comment|/* Do the next pass. */
r_if
c_cond
(paren
op_increment
id|pass
op_eq
l_int|2
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Starting the second pass, in which we scan the first&n;&t;&t;&t; * part of the zone which we omitted earlier.&n;&t;&t;&t; */
id|pass_end
op_assign
id|pass_start
suffix:semicolon
id|data_pos
op_assign
id|pass_start
op_assign
l_int|24
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;pass %i, pass_start 0x%llx, pass_end &quot;
l_string|&quot;0x%llx.&quot;
comma
id|pass
comma
(paren
r_int
r_int
)paren
id|pass_start
comma
(paren
r_int
r_int
)paren
id|pass_end
)paren
suffix:semicolon
r_if
c_cond
(paren
id|data_pos
op_ge
id|pass_end
)paren
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* No free mft records in currently initialized mft bitmap. */
id|ntfs_debug
c_func
(paren
l_string|&quot;Done.  (No free mft records left in currently initialized &quot;
l_string|&quot;mft bitmap.)&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOSPC
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_mft_bitmap_extend_allocation_nolock - extend mft bitmap by a cluster&n; * @vol:&t;volume on which to extend the mft bitmap attribute&n; *&n; * Extend the mft bitmap attribute on the ntfs volume @vol by one cluster.&n; *&n; * Note: Only changes allocated_size, i.e. does not touch initialized_size or&n; * data_size.&n; *&n; * Return 0 on success and -errno on error.&n; *&n; * Locking: - Caller must hold vol-&gt;mftbmp_lock for writing.&n; *&t;    - This function takes NTFS_I(vol-&gt;mftbmp_ino)-&gt;runlist.lock for&n; *&t;      writing and releases it before returning.&n; *&t;    - This function takes vol-&gt;lcnbmp_lock for writing and releases it&n; *&t;      before returning.&n; */
DECL|function|ntfs_mft_bitmap_extend_allocation_nolock
r_static
r_int
id|ntfs_mft_bitmap_extend_allocation_nolock
c_func
(paren
id|ntfs_volume
op_star
id|vol
)paren
(brace
id|LCN
id|lcn
suffix:semicolon
id|s64
id|ll
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
id|ntfs_inode
op_star
id|mft_ni
comma
op_star
id|mftbmp_ni
suffix:semicolon
id|runlist_element
op_star
id|rl
comma
op_star
id|rl2
op_assign
l_int|NULL
suffix:semicolon
id|ntfs_attr_search_ctx
op_star
id|ctx
op_assign
l_int|NULL
suffix:semicolon
id|MFT_RECORD
op_star
id|mrec
suffix:semicolon
id|ATTR_RECORD
op_star
id|a
op_assign
l_int|NULL
suffix:semicolon
r_int
id|ret
comma
id|mp_size
suffix:semicolon
id|u32
id|old_alen
op_assign
l_int|0
suffix:semicolon
id|u8
op_star
id|b
comma
id|tb
suffix:semicolon
r_struct
(brace
id|u8
id|added_cluster
suffix:colon
l_int|1
suffix:semicolon
id|u8
id|added_run
suffix:colon
l_int|1
suffix:semicolon
id|u8
id|mp_rebuilt
suffix:colon
l_int|1
suffix:semicolon
)brace
id|status
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Extending mft bitmap allocation.&quot;
)paren
suffix:semicolon
id|mft_ni
op_assign
id|NTFS_I
c_func
(paren
id|vol-&gt;mft_ino
)paren
suffix:semicolon
id|mftbmp_ni
op_assign
id|NTFS_I
c_func
(paren
id|vol-&gt;mftbmp_ino
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Determine the last lcn of the mft bitmap.  The allocated size of the&n;&t; * mft bitmap cannot be zero so we are ok to do this.&n;&t; * ntfs_find_vcn() returns the runlist locked on success.&n;&t; */
id|rl
op_assign
id|ntfs_find_vcn
c_func
(paren
id|mftbmp_ni
comma
(paren
id|mftbmp_ni-&gt;allocated_size
op_minus
l_int|1
)paren
op_rshift
id|vol-&gt;cluster_size_bits
comma
id|TRUE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|IS_ERR
c_func
(paren
id|rl
)paren
op_logical_or
op_logical_neg
id|rl-&gt;length
op_logical_or
id|rl-&gt;lcn
OL
l_int|0
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Failed to determine last allocated &quot;
l_string|&quot;cluster of mft bitmap attribute.&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|IS_ERR
c_func
(paren
id|rl
)paren
)paren
(brace
id|up_write
c_func
(paren
op_amp
id|mftbmp_ni-&gt;runlist.lock
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
r_else
id|ret
op_assign
id|PTR_ERR
c_func
(paren
id|rl
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
id|lcn
op_assign
id|rl-&gt;lcn
op_plus
id|rl-&gt;length
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Last lcn of mft bitmap attribute is 0x%llx.&quot;
comma
(paren
r_int
r_int
)paren
id|lcn
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Attempt to get the cluster following the last allocated cluster by&n;&t; * hand as it may be in the MFT zone so the allocator would not give it&n;&t; * to us.&n;&t; */
id|ll
op_assign
id|lcn
op_rshift
l_int|3
suffix:semicolon
id|page
op_assign
id|ntfs_map_page
c_func
(paren
id|vol-&gt;lcnbmp_ino-&gt;i_mapping
comma
id|ll
op_rshift
id|PAGE_CACHE_SHIFT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|page
)paren
)paren
(brace
id|up_write
c_func
(paren
op_amp
id|mftbmp_ni-&gt;runlist.lock
)paren
suffix:semicolon
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Failed to read from lcn bitmap.&quot;
)paren
suffix:semicolon
r_return
id|PTR_ERR
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
id|b
op_assign
(paren
id|u8
op_star
)paren
id|page_address
c_func
(paren
id|page
)paren
op_plus
(paren
id|ll
op_amp
op_complement
id|PAGE_CACHE_MASK
)paren
suffix:semicolon
id|tb
op_assign
l_int|1
op_lshift
(paren
id|lcn
op_amp
l_int|7ull
)paren
suffix:semicolon
id|down_write
c_func
(paren
op_amp
id|vol-&gt;lcnbmp_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|b
op_ne
l_int|0xff
op_logical_and
op_logical_neg
(paren
op_star
id|b
op_amp
id|tb
)paren
)paren
(brace
multiline_comment|/* Next cluster is free, allocate it. */
op_star
id|b
op_or_assign
id|tb
suffix:semicolon
id|flush_dcache_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|set_page_dirty
c_func
(paren
id|page
)paren
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|vol-&gt;lcnbmp_lock
)paren
suffix:semicolon
id|ntfs_unmap_page
c_func
(paren
id|page
)paren
suffix:semicolon
multiline_comment|/* Update the mft bitmap runlist. */
id|rl-&gt;length
op_increment
suffix:semicolon
id|rl
(braket
l_int|1
)braket
dot
id|vcn
op_increment
suffix:semicolon
id|status.added_cluster
op_assign
l_int|1
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Appending one cluster to mft bitmap.&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|up_write
c_func
(paren
op_amp
id|vol-&gt;lcnbmp_lock
)paren
suffix:semicolon
id|ntfs_unmap_page
c_func
(paren
id|page
)paren
suffix:semicolon
multiline_comment|/* Allocate a cluster from the DATA_ZONE. */
id|rl2
op_assign
id|ntfs_cluster_alloc
c_func
(paren
id|vol
comma
id|rl
(braket
l_int|1
)braket
dot
id|vcn
comma
l_int|1
comma
id|lcn
comma
id|DATA_ZONE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|rl2
)paren
)paren
(brace
id|up_write
c_func
(paren
op_amp
id|mftbmp_ni-&gt;runlist.lock
)paren
suffix:semicolon
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Failed to allocate a cluster for &quot;
l_string|&quot;the mft bitmap.&quot;
)paren
suffix:semicolon
r_return
id|PTR_ERR
c_func
(paren
id|rl2
)paren
suffix:semicolon
)brace
id|rl
op_assign
id|ntfs_runlists_merge
c_func
(paren
id|mftbmp_ni-&gt;runlist.rl
comma
id|rl2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|rl
)paren
)paren
(brace
id|up_write
c_func
(paren
op_amp
id|mftbmp_ni-&gt;runlist.lock
)paren
suffix:semicolon
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Failed to merge runlists for mft &quot;
l_string|&quot;bitmap.&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ntfs_cluster_free_from_rl
c_func
(paren
id|vol
comma
id|rl2
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Failed to dealocate &quot;
l_string|&quot;allocated cluster.%s&quot;
comma
id|es
)paren
suffix:semicolon
id|NVolSetErrors
c_func
(paren
id|vol
)paren
suffix:semicolon
)brace
id|ntfs_free
c_func
(paren
id|rl2
)paren
suffix:semicolon
r_return
id|PTR_ERR
c_func
(paren
id|rl
)paren
suffix:semicolon
)brace
id|mftbmp_ni-&gt;runlist.rl
op_assign
id|rl
suffix:semicolon
id|status.added_run
op_assign
l_int|1
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Adding one run to mft bitmap.&quot;
)paren
suffix:semicolon
multiline_comment|/* Find the last run in the new runlist. */
r_for
c_loop
(paren
suffix:semicolon
id|rl
(braket
l_int|1
)braket
dot
id|length
suffix:semicolon
id|rl
op_increment
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Update the attribute record as well.  Note: @rl is the last&n;&t; * (non-terminator) runlist element of mft bitmap.&n;&t; */
id|mrec
op_assign
id|map_mft_record
c_func
(paren
id|mft_ni
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|mrec
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Failed to map mft record.&quot;
)paren
suffix:semicolon
id|ret
op_assign
id|PTR_ERR
c_func
(paren
id|mrec
)paren
suffix:semicolon
r_goto
id|undo_alloc
suffix:semicolon
)brace
id|ctx
op_assign
id|ntfs_attr_get_search_ctx
c_func
(paren
id|mft_ni
comma
id|mrec
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|ctx
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Failed to get search context.&quot;
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|undo_alloc
suffix:semicolon
)brace
id|ret
op_assign
id|ntfs_attr_lookup
c_func
(paren
id|mftbmp_ni-&gt;type
comma
id|mftbmp_ni-&gt;name
comma
id|mftbmp_ni-&gt;name_len
comma
id|CASE_SENSITIVE
comma
id|rl
(braket
l_int|1
)braket
dot
id|vcn
comma
l_int|NULL
comma
l_int|0
comma
id|ctx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|ret
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Failed to find last attribute extent of &quot;
l_string|&quot;mft bitmap attribute.&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
op_minus
id|ENOENT
)paren
id|ret
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|undo_alloc
suffix:semicolon
)brace
id|a
op_assign
id|ctx-&gt;attr
suffix:semicolon
id|ll
op_assign
id|sle64_to_cpu
c_func
(paren
id|a-&gt;data.non_resident.lowest_vcn
)paren
suffix:semicolon
multiline_comment|/* Search back for the previous last allocated cluster of mft bitmap. */
r_for
c_loop
(paren
id|rl2
op_assign
id|rl
suffix:semicolon
id|rl2
OG
id|mftbmp_ni-&gt;runlist.rl
suffix:semicolon
id|rl2
op_decrement
)paren
(brace
r_if
c_cond
(paren
id|ll
op_ge
id|rl2-&gt;vcn
)paren
r_break
suffix:semicolon
)brace
id|BUG_ON
c_func
(paren
id|ll
OL
id|rl2-&gt;vcn
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|ll
op_ge
id|rl2-&gt;vcn
op_plus
id|rl2-&gt;length
)paren
suffix:semicolon
multiline_comment|/* Get the size for the new mapping pairs array for this extent. */
id|mp_size
op_assign
id|ntfs_get_size_for_mapping_pairs
c_func
(paren
id|vol
comma
id|rl2
comma
id|ll
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|mp_size
op_le
l_int|0
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Get size for mapping pairs failed for &quot;
l_string|&quot;mft bitmap attribute extent.&quot;
)paren
suffix:semicolon
id|ret
op_assign
id|mp_size
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
id|ret
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|undo_alloc
suffix:semicolon
)brace
multiline_comment|/* Expand the attribute record if necessary. */
id|old_alen
op_assign
id|le32_to_cpu
c_func
(paren
id|a-&gt;length
)paren
suffix:semicolon
id|ret
op_assign
id|ntfs_attr_record_resize
c_func
(paren
id|ctx-&gt;mrec
comma
id|a
comma
id|mp_size
op_plus
id|le16_to_cpu
c_func
(paren
id|a-&gt;data.non_resident.mapping_pairs_offset
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|ret
)paren
)paren
(brace
r_if
c_cond
(paren
id|ret
op_ne
op_minus
id|ENOSPC
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Failed to resize attribute &quot;
l_string|&quot;record for mft bitmap attribute.&quot;
)paren
suffix:semicolon
r_goto
id|undo_alloc
suffix:semicolon
)brace
singleline_comment|// TODO: Deal with this by moving this extent to a new mft
singleline_comment|// record or by starting a new extent in a new mft record or by
singleline_comment|// moving other attributes out of this mft record.
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Not enough space in this mft record to &quot;
l_string|&quot;accomodate extended mft bitmap attribute &quot;
l_string|&quot;extent.  Cannot handle this yet.&quot;
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EOPNOTSUPP
suffix:semicolon
r_goto
id|undo_alloc
suffix:semicolon
)brace
id|status.mp_rebuilt
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Generate the mapping pairs array directly into the attr record. */
id|ret
op_assign
id|ntfs_mapping_pairs_build
c_func
(paren
id|vol
comma
(paren
id|u8
op_star
)paren
id|a
op_plus
id|le16_to_cpu
c_func
(paren
id|a-&gt;data.non_resident.mapping_pairs_offset
)paren
comma
id|mp_size
comma
id|rl2
comma
id|ll
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|ret
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Failed to build mapping pairs array for &quot;
l_string|&quot;mft bitmap attribute.&quot;
)paren
suffix:semicolon
r_goto
id|undo_alloc
suffix:semicolon
)brace
multiline_comment|/* Update the highest_vcn. */
id|a-&gt;data.non_resident.highest_vcn
op_assign
id|cpu_to_sle64
c_func
(paren
id|rl
(braket
l_int|1
)braket
dot
id|vcn
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We now have extended the mft bitmap allocated_size by one cluster.&n;&t; * Reflect this in the ntfs_inode structure and the attribute record.&n;&t; */
r_if
c_cond
(paren
id|a-&gt;data.non_resident.lowest_vcn
)paren
(brace
multiline_comment|/*&n;&t;&t; * We are not in the first attribute extent, switch to it, but&n;&t;&t; * first ensure the changes will make it to disk later.&n;&t;&t; */
id|flush_dcache_mft_record_page
c_func
(paren
id|ctx-&gt;ntfs_ino
)paren
suffix:semicolon
id|mark_mft_record_dirty
c_func
(paren
id|ctx-&gt;ntfs_ino
)paren
suffix:semicolon
id|ntfs_attr_reinit_search_ctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
id|ret
op_assign
id|ntfs_attr_lookup
c_func
(paren
id|mftbmp_ni-&gt;type
comma
id|mftbmp_ni-&gt;name
comma
id|mftbmp_ni-&gt;name_len
comma
id|CASE_SENSITIVE
comma
l_int|0
comma
l_int|NULL
comma
l_int|0
comma
id|ctx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|ret
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Failed to find first attribute &quot;
l_string|&quot;extent of mft bitmap attribute.&quot;
)paren
suffix:semicolon
r_goto
id|restore_undo_alloc
suffix:semicolon
)brace
id|a
op_assign
id|ctx-&gt;attr
suffix:semicolon
)brace
id|mftbmp_ni-&gt;allocated_size
op_add_assign
id|vol-&gt;cluster_size
suffix:semicolon
id|a-&gt;data.non_resident.allocated_size
op_assign
id|cpu_to_sle64
c_func
(paren
id|mftbmp_ni-&gt;allocated_size
)paren
suffix:semicolon
multiline_comment|/* Ensure the changes make it to disk. */
id|flush_dcache_mft_record_page
c_func
(paren
id|ctx-&gt;ntfs_ino
)paren
suffix:semicolon
id|mark_mft_record_dirty
c_func
(paren
id|ctx-&gt;ntfs_ino
)paren
suffix:semicolon
id|ntfs_attr_put_search_ctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
id|unmap_mft_record
c_func
(paren
id|mft_ni
)paren
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|mftbmp_ni-&gt;runlist.lock
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Done.&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|restore_undo_alloc
suffix:colon
id|ntfs_attr_reinit_search_ctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ntfs_attr_lookup
c_func
(paren
id|mftbmp_ni-&gt;type
comma
id|mftbmp_ni-&gt;name
comma
id|mftbmp_ni-&gt;name_len
comma
id|CASE_SENSITIVE
comma
id|rl
(braket
l_int|1
)braket
dot
id|vcn
comma
l_int|NULL
comma
l_int|0
comma
id|ctx
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Failed to find last attribute extent of &quot;
l_string|&quot;mft bitmap attribute.%s&quot;
comma
id|es
)paren
suffix:semicolon
id|mftbmp_ni-&gt;allocated_size
op_add_assign
id|vol-&gt;cluster_size
suffix:semicolon
id|ntfs_attr_put_search_ctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
id|unmap_mft_record
c_func
(paren
id|mft_ni
)paren
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|mftbmp_ni-&gt;runlist.lock
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * The only thing that is now wrong is -&gt;allocated_size of the&n;&t;&t; * base attribute extent which chkdsk should be able to fix.&n;&t;&t; */
id|NVolSetErrors
c_func
(paren
id|vol
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
id|a
op_assign
id|ctx-&gt;attr
suffix:semicolon
id|a-&gt;data.non_resident.highest_vcn
op_assign
id|cpu_to_sle64
c_func
(paren
id|rl
(braket
l_int|1
)braket
dot
id|vcn
op_minus
l_int|2
)paren
suffix:semicolon
id|undo_alloc
suffix:colon
r_if
c_cond
(paren
id|status.added_cluster
)paren
(brace
multiline_comment|/* Truncate the last run in the runlist by one cluster. */
id|rl-&gt;length
op_decrement
suffix:semicolon
id|rl
(braket
l_int|1
)braket
dot
id|vcn
op_decrement
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|status.added_run
)paren
(brace
id|lcn
op_assign
id|rl-&gt;lcn
suffix:semicolon
multiline_comment|/* Remove the last run from the runlist. */
id|rl-&gt;lcn
op_assign
id|rl
(braket
l_int|1
)braket
dot
id|lcn
suffix:semicolon
id|rl-&gt;length
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Deallocate the cluster. */
id|down_write
c_func
(paren
op_amp
id|vol-&gt;lcnbmp_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ntfs_bitmap_clear_bit
c_func
(paren
id|vol-&gt;lcnbmp_ino
comma
id|lcn
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Failed to free allocated cluster.%s&quot;
comma
id|es
)paren
suffix:semicolon
id|NVolSetErrors
c_func
(paren
id|vol
)paren
suffix:semicolon
)brace
id|up_write
c_func
(paren
op_amp
id|vol-&gt;lcnbmp_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status.mp_rebuilt
)paren
(brace
r_if
c_cond
(paren
id|ntfs_mapping_pairs_build
c_func
(paren
id|vol
comma
(paren
id|u8
op_star
)paren
id|a
op_plus
id|le16_to_cpu
c_func
(paren
id|a-&gt;data.non_resident.mapping_pairs_offset
)paren
comma
id|old_alen
op_minus
id|le16_to_cpu
c_func
(paren
id|a-&gt;data.non_resident.mapping_pairs_offset
)paren
comma
id|rl2
comma
id|ll
comma
l_int|NULL
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Failed to restore mapping pairs &quot;
l_string|&quot;array.%s&quot;
comma
id|es
)paren
suffix:semicolon
id|NVolSetErrors
c_func
(paren
id|vol
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ntfs_attr_record_resize
c_func
(paren
id|ctx-&gt;mrec
comma
id|a
comma
id|old_alen
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Failed to restore attribute &quot;
l_string|&quot;record.%s&quot;
comma
id|es
)paren
suffix:semicolon
id|NVolSetErrors
c_func
(paren
id|vol
)paren
suffix:semicolon
)brace
id|flush_dcache_mft_record_page
c_func
(paren
id|ctx-&gt;ntfs_ino
)paren
suffix:semicolon
id|mark_mft_record_dirty
c_func
(paren
id|ctx-&gt;ntfs_ino
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ctx
)paren
id|ntfs_attr_put_search_ctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|IS_ERR
c_func
(paren
id|mrec
)paren
)paren
id|unmap_mft_record
c_func
(paren
id|mft_ni
)paren
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|mftbmp_ni-&gt;runlist.lock
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_mft_bitmap_extend_initialized_nolock - extend mftbmp initialized data&n; * @vol:&t;volume on which to extend the mft bitmap attribute&n; *&n; * Extend the initialized portion of the mft bitmap attribute on the ntfs&n; * volume @vol by 8 bytes.&n; *&n; * Note:  Only changes initialized_size and data_size, i.e. requires that&n; * allocated_size is big enough to fit the new initialized_size.&n; *&n; * Return 0 on success and -error on error.&n; *&n; * Locking: Caller must hold vol-&gt;mftbmp_lock for writing.&n; */
DECL|function|ntfs_mft_bitmap_extend_initialized_nolock
r_static
r_int
id|ntfs_mft_bitmap_extend_initialized_nolock
c_func
(paren
id|ntfs_volume
op_star
id|vol
)paren
(brace
id|s64
id|old_data_size
comma
id|old_initialized_size
suffix:semicolon
r_struct
id|inode
op_star
id|mftbmp_vi
suffix:semicolon
id|ntfs_inode
op_star
id|mft_ni
comma
op_star
id|mftbmp_ni
suffix:semicolon
id|ntfs_attr_search_ctx
op_star
id|ctx
suffix:semicolon
id|MFT_RECORD
op_star
id|mrec
suffix:semicolon
id|ATTR_RECORD
op_star
id|a
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Extending mft bitmap initiailized (and data) size.&quot;
)paren
suffix:semicolon
id|mft_ni
op_assign
id|NTFS_I
c_func
(paren
id|vol-&gt;mft_ino
)paren
suffix:semicolon
id|mftbmp_vi
op_assign
id|vol-&gt;mftbmp_ino
suffix:semicolon
id|mftbmp_ni
op_assign
id|NTFS_I
c_func
(paren
id|mftbmp_vi
)paren
suffix:semicolon
multiline_comment|/* Get the attribute record. */
id|mrec
op_assign
id|map_mft_record
c_func
(paren
id|mft_ni
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|mrec
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Failed to map mft record.&quot;
)paren
suffix:semicolon
r_return
id|PTR_ERR
c_func
(paren
id|mrec
)paren
suffix:semicolon
)brace
id|ctx
op_assign
id|ntfs_attr_get_search_ctx
c_func
(paren
id|mft_ni
comma
id|mrec
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|ctx
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Failed to get search context.&quot;
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
id|ret
op_assign
id|ntfs_attr_lookup
c_func
(paren
id|mftbmp_ni-&gt;type
comma
id|mftbmp_ni-&gt;name
comma
id|mftbmp_ni-&gt;name_len
comma
id|CASE_SENSITIVE
comma
l_int|0
comma
l_int|NULL
comma
l_int|0
comma
id|ctx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|ret
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Failed to find first attribute extent of &quot;
l_string|&quot;mft bitmap attribute.&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
op_minus
id|ENOENT
)paren
id|ret
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|put_err_out
suffix:semicolon
)brace
id|a
op_assign
id|ctx-&gt;attr
suffix:semicolon
id|old_data_size
op_assign
id|mftbmp_vi-&gt;i_size
suffix:semicolon
id|old_initialized_size
op_assign
id|mftbmp_ni-&gt;initialized_size
suffix:semicolon
multiline_comment|/*&n;&t; * We can simply update the initialized_size before filling the space&n;&t; * with zeroes because the caller is holding the mft bitmap lock for&n;&t; * writing which ensures that no one else is trying to access the data.&n;&t; */
id|mftbmp_ni-&gt;initialized_size
op_add_assign
l_int|8
suffix:semicolon
id|a-&gt;data.non_resident.initialized_size
op_assign
id|cpu_to_sle64
c_func
(paren
id|mftbmp_ni-&gt;initialized_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mftbmp_ni-&gt;initialized_size
OG
id|mftbmp_vi-&gt;i_size
)paren
(brace
id|mftbmp_vi-&gt;i_size
op_assign
id|mftbmp_ni-&gt;initialized_size
suffix:semicolon
id|a-&gt;data.non_resident.data_size
op_assign
id|cpu_to_sle64
c_func
(paren
id|mftbmp_vi-&gt;i_size
)paren
suffix:semicolon
)brace
multiline_comment|/* Ensure the changes make it to disk. */
id|flush_dcache_mft_record_page
c_func
(paren
id|ctx-&gt;ntfs_ino
)paren
suffix:semicolon
id|mark_mft_record_dirty
c_func
(paren
id|ctx-&gt;ntfs_ino
)paren
suffix:semicolon
id|ntfs_attr_put_search_ctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
id|unmap_mft_record
c_func
(paren
id|mft_ni
)paren
suffix:semicolon
multiline_comment|/* Initialize the mft bitmap attribute value with zeroes. */
id|ret
op_assign
id|ntfs_attr_set
c_func
(paren
id|mftbmp_ni
comma
id|old_initialized_size
comma
l_int|8
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
op_logical_neg
id|ret
)paren
)paren
(brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Done.  (Wrote eight initialized bytes to mft &quot;
l_string|&quot;bitmap.&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Failed to write to mft bitmap.&quot;
)paren
suffix:semicolon
multiline_comment|/* Try to recover from the error. */
id|mrec
op_assign
id|map_mft_record
c_func
(paren
id|mft_ni
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|mrec
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Failed to map mft record.%s&quot;
comma
id|es
)paren
suffix:semicolon
id|NVolSetErrors
c_func
(paren
id|vol
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
id|ctx
op_assign
id|ntfs_attr_get_search_ctx
c_func
(paren
id|mft_ni
comma
id|mrec
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|ctx
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Failed to get search context.%s&quot;
comma
id|es
)paren
suffix:semicolon
id|NVolSetErrors
c_func
(paren
id|vol
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ntfs_attr_lookup
c_func
(paren
id|mftbmp_ni-&gt;type
comma
id|mftbmp_ni-&gt;name
comma
id|mftbmp_ni-&gt;name_len
comma
id|CASE_SENSITIVE
comma
l_int|0
comma
l_int|NULL
comma
l_int|0
comma
id|ctx
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Failed to find first attribute extent of &quot;
l_string|&quot;mft bitmap attribute.%s&quot;
comma
id|es
)paren
suffix:semicolon
id|NVolSetErrors
c_func
(paren
id|vol
)paren
suffix:semicolon
id|put_err_out
suffix:colon
id|ntfs_attr_put_search_ctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
id|unm_err_out
suffix:colon
id|unmap_mft_record
c_func
(paren
id|mft_ni
)paren
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
id|a
op_assign
id|ctx-&gt;attr
suffix:semicolon
id|mftbmp_ni-&gt;initialized_size
op_assign
id|old_initialized_size
suffix:semicolon
id|a-&gt;data.non_resident.initialized_size
op_assign
id|cpu_to_sle64
c_func
(paren
id|old_initialized_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mftbmp_vi-&gt;i_size
op_ne
id|old_data_size
)paren
(brace
id|mftbmp_vi-&gt;i_size
op_assign
id|old_data_size
suffix:semicolon
id|a-&gt;data.non_resident.data_size
op_assign
id|cpu_to_sle64
c_func
(paren
id|old_data_size
)paren
suffix:semicolon
)brace
id|flush_dcache_mft_record_page
c_func
(paren
id|ctx-&gt;ntfs_ino
)paren
suffix:semicolon
id|mark_mft_record_dirty
c_func
(paren
id|ctx-&gt;ntfs_ino
)paren
suffix:semicolon
id|ntfs_attr_put_search_ctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
id|unmap_mft_record
c_func
(paren
id|mft_ni
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Restored status of mftbmp: allocated_size 0x%llx, &quot;
l_string|&quot;data_size 0x%llx, initialized_size 0x%llx.&quot;
comma
(paren
r_int
r_int
)paren
id|mftbmp_ni-&gt;allocated_size
comma
(paren
r_int
r_int
)paren
id|mftbmp_vi-&gt;i_size
comma
(paren
r_int
r_int
)paren
id|mftbmp_ni-&gt;initialized_size
)paren
suffix:semicolon
id|err_out
suffix:colon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_mft_data_extend_allocation_nolock - extend mft data attribute&n; * @vol:&t;volume on which to extend the mft data attribute&n; *&n; * Extend the mft data attribute on the ntfs volume @vol by 16 mft records&n; * worth of clusters or if not enough space for this by one mft record worth&n; * of clusters.&n; *&n; * Note:  Only changes allocated_size, i.e. does not touch initialized_size or&n; * data_size.&n; *&n; * Return 0 on success and -errno on error.&n; *&n; * Locking: - Caller must hold vol-&gt;mftbmp_lock for writing.&n; *&t;    - This function takes NTFS_I(vol-&gt;mft_ino)-&gt;runlist.lock for&n; *&t;      writing and releases it before returning.&n; *&t;    - This function calls functions which take vol-&gt;lcnbmp_lock for&n; *&t;      writing and release it before returning.&n; */
DECL|function|ntfs_mft_data_extend_allocation_nolock
r_static
r_int
id|ntfs_mft_data_extend_allocation_nolock
c_func
(paren
id|ntfs_volume
op_star
id|vol
)paren
(brace
id|LCN
id|lcn
suffix:semicolon
id|VCN
id|old_last_vcn
suffix:semicolon
id|s64
id|min_nr
comma
id|nr
comma
id|ll
op_assign
l_int|0
suffix:semicolon
id|ntfs_inode
op_star
id|mft_ni
suffix:semicolon
id|runlist_element
op_star
id|rl
comma
op_star
id|rl2
suffix:semicolon
id|ntfs_attr_search_ctx
op_star
id|ctx
op_assign
l_int|NULL
suffix:semicolon
id|MFT_RECORD
op_star
id|mrec
suffix:semicolon
id|ATTR_RECORD
op_star
id|a
op_assign
l_int|NULL
suffix:semicolon
r_int
id|ret
comma
id|mp_size
suffix:semicolon
id|u32
id|old_alen
op_assign
l_int|0
suffix:semicolon
id|BOOL
id|mp_rebuilt
op_assign
id|FALSE
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Extending mft data allocation.&quot;
)paren
suffix:semicolon
id|mft_ni
op_assign
id|NTFS_I
c_func
(paren
id|vol-&gt;mft_ino
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Determine the preferred allocation location, i.e. the last lcn of&n;&t; * the mft data attribute.  The allocated size of the mft data&n;&t; * attribute cannot be zero so we are ok to do this.&n;&t; * ntfs_find_vcn() returns the runlist locked on success.&n;&t; */
id|rl
op_assign
id|ntfs_find_vcn
c_func
(paren
id|mft_ni
comma
(paren
id|mft_ni-&gt;allocated_size
op_minus
l_int|1
)paren
op_rshift
id|vol-&gt;cluster_size_bits
comma
id|TRUE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|IS_ERR
c_func
(paren
id|rl
)paren
op_logical_or
op_logical_neg
id|rl-&gt;length
op_logical_or
id|rl-&gt;lcn
OL
l_int|0
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Failed to determine last allocated &quot;
l_string|&quot;cluster of mft data attribute.&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|IS_ERR
c_func
(paren
id|rl
)paren
)paren
(brace
id|up_write
c_func
(paren
op_amp
id|mft_ni-&gt;runlist.lock
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
r_else
id|ret
op_assign
id|PTR_ERR
c_func
(paren
id|rl
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
id|lcn
op_assign
id|rl-&gt;lcn
op_plus
id|rl-&gt;length
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Last lcn of mft data attribute is 0x%llx.&quot;
comma
(paren
r_int
r_int
)paren
id|lcn
)paren
suffix:semicolon
multiline_comment|/* Minimum allocation is one mft record worth of clusters. */
id|min_nr
op_assign
id|vol-&gt;mft_record_size
op_rshift
id|vol-&gt;cluster_size_bits
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|min_nr
)paren
id|min_nr
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Want to allocate 16 mft records worth of clusters. */
id|nr
op_assign
id|vol-&gt;mft_record_size
op_lshift
l_int|4
op_rshift
id|vol-&gt;cluster_size_bits
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|nr
)paren
id|nr
op_assign
id|min_nr
suffix:semicolon
multiline_comment|/* Ensure we do not go above 2^32-1 mft records. */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
(paren
id|mft_ni-&gt;allocated_size
op_plus
(paren
id|nr
op_lshift
id|vol-&gt;cluster_size_bits
)paren
)paren
op_rshift
id|vol-&gt;mft_record_size_bits
op_ge
(paren
l_int|1ll
op_lshift
l_int|32
)paren
)paren
)paren
(brace
id|nr
op_assign
id|min_nr
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
(paren
id|mft_ni-&gt;allocated_size
op_plus
(paren
id|nr
op_lshift
id|vol-&gt;cluster_size_bits
)paren
)paren
op_rshift
id|vol-&gt;mft_record_size_bits
op_ge
(paren
l_int|1ll
op_lshift
l_int|32
)paren
)paren
)paren
(brace
id|ntfs_warning
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Cannot allocate mft record &quot;
l_string|&quot;because the maximum number of inodes &quot;
l_string|&quot;(2^32) has already been reached.&quot;
)paren
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|mft_ni-&gt;runlist.lock
)paren
suffix:semicolon
r_return
op_minus
id|ENOSPC
suffix:semicolon
)brace
)brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Trying mft data allocation with %s cluster count %lli.&quot;
comma
id|nr
OG
id|min_nr
ques
c_cond
l_string|&quot;default&quot;
suffix:colon
l_string|&quot;minimal&quot;
comma
(paren
r_int
r_int
)paren
id|nr
)paren
suffix:semicolon
id|old_last_vcn
op_assign
id|rl
(braket
l_int|1
)braket
dot
id|vcn
suffix:semicolon
r_do
(brace
id|rl2
op_assign
id|ntfs_cluster_alloc
c_func
(paren
id|vol
comma
id|old_last_vcn
comma
id|nr
comma
id|lcn
comma
id|MFT_ZONE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
op_logical_neg
id|IS_ERR
c_func
(paren
id|rl2
)paren
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|PTR_ERR
c_func
(paren
id|rl2
)paren
op_ne
op_minus
id|ENOSPC
op_logical_or
id|nr
op_eq
id|min_nr
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Failed to allocate the minimal &quot;
l_string|&quot;number of clusters (%lli) for the &quot;
l_string|&quot;mft data attribute.&quot;
comma
(paren
r_int
r_int
)paren
id|nr
)paren
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|mft_ni-&gt;runlist.lock
)paren
suffix:semicolon
r_return
id|PTR_ERR
c_func
(paren
id|rl2
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * There is not enough space to do the allocation, but there&n;&t;&t; * might be enough space to do a minimal allocation so try that&n;&t;&t; * before failing.&n;&t;&t; */
id|nr
op_assign
id|min_nr
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Retrying mft data allocation with minimal cluster &quot;
l_string|&quot;count %lli.&quot;
comma
(paren
r_int
r_int
)paren
id|nr
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
l_int|1
)paren
suffix:semicolon
id|rl
op_assign
id|ntfs_runlists_merge
c_func
(paren
id|mft_ni-&gt;runlist.rl
comma
id|rl2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|rl
)paren
)paren
(brace
id|up_write
c_func
(paren
op_amp
id|mft_ni-&gt;runlist.lock
)paren
suffix:semicolon
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Failed to merge runlists for mft data &quot;
l_string|&quot;attribute.&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ntfs_cluster_free_from_rl
c_func
(paren
id|vol
comma
id|rl2
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Failed to dealocate clusters &quot;
l_string|&quot;from the mft data attribute.%s&quot;
comma
id|es
)paren
suffix:semicolon
id|NVolSetErrors
c_func
(paren
id|vol
)paren
suffix:semicolon
)brace
id|ntfs_free
c_func
(paren
id|rl2
)paren
suffix:semicolon
r_return
id|PTR_ERR
c_func
(paren
id|rl
)paren
suffix:semicolon
)brace
id|mft_ni-&gt;runlist.rl
op_assign
id|rl
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Allocated %lli clusters.&quot;
comma
id|nr
)paren
suffix:semicolon
multiline_comment|/* Find the last run in the new runlist. */
r_for
c_loop
(paren
suffix:semicolon
id|rl
(braket
l_int|1
)braket
dot
id|length
suffix:semicolon
id|rl
op_increment
)paren
suffix:semicolon
multiline_comment|/* Update the attribute record as well. */
id|mrec
op_assign
id|map_mft_record
c_func
(paren
id|mft_ni
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|mrec
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Failed to map mft record.&quot;
)paren
suffix:semicolon
id|ret
op_assign
id|PTR_ERR
c_func
(paren
id|mrec
)paren
suffix:semicolon
r_goto
id|undo_alloc
suffix:semicolon
)brace
id|ctx
op_assign
id|ntfs_attr_get_search_ctx
c_func
(paren
id|mft_ni
comma
id|mrec
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|ctx
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Failed to get search context.&quot;
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|undo_alloc
suffix:semicolon
)brace
id|ret
op_assign
id|ntfs_attr_lookup
c_func
(paren
id|mft_ni-&gt;type
comma
id|mft_ni-&gt;name
comma
id|mft_ni-&gt;name_len
comma
id|CASE_SENSITIVE
comma
id|rl
(braket
l_int|1
)braket
dot
id|vcn
comma
l_int|NULL
comma
l_int|0
comma
id|ctx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|ret
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Failed to find last attribute extent of &quot;
l_string|&quot;mft data attribute.&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
op_minus
id|ENOENT
)paren
id|ret
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|undo_alloc
suffix:semicolon
)brace
id|a
op_assign
id|ctx-&gt;attr
suffix:semicolon
id|ll
op_assign
id|sle64_to_cpu
c_func
(paren
id|a-&gt;data.non_resident.lowest_vcn
)paren
suffix:semicolon
multiline_comment|/* Search back for the previous last allocated cluster of mft bitmap. */
r_for
c_loop
(paren
id|rl2
op_assign
id|rl
suffix:semicolon
id|rl2
OG
id|mft_ni-&gt;runlist.rl
suffix:semicolon
id|rl2
op_decrement
)paren
(brace
r_if
c_cond
(paren
id|ll
op_ge
id|rl2-&gt;vcn
)paren
r_break
suffix:semicolon
)brace
id|BUG_ON
c_func
(paren
id|ll
OL
id|rl2-&gt;vcn
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|ll
op_ge
id|rl2-&gt;vcn
op_plus
id|rl2-&gt;length
)paren
suffix:semicolon
multiline_comment|/* Get the size for the new mapping pairs array for this extent. */
id|mp_size
op_assign
id|ntfs_get_size_for_mapping_pairs
c_func
(paren
id|vol
comma
id|rl2
comma
id|ll
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|mp_size
op_le
l_int|0
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Get size for mapping pairs failed for &quot;
l_string|&quot;mft data attribute extent.&quot;
)paren
suffix:semicolon
id|ret
op_assign
id|mp_size
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
id|ret
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|undo_alloc
suffix:semicolon
)brace
multiline_comment|/* Expand the attribute record if necessary. */
id|old_alen
op_assign
id|le32_to_cpu
c_func
(paren
id|a-&gt;length
)paren
suffix:semicolon
id|ret
op_assign
id|ntfs_attr_record_resize
c_func
(paren
id|ctx-&gt;mrec
comma
id|a
comma
id|mp_size
op_plus
id|le16_to_cpu
c_func
(paren
id|a-&gt;data.non_resident.mapping_pairs_offset
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|ret
)paren
)paren
(brace
r_if
c_cond
(paren
id|ret
op_ne
op_minus
id|ENOSPC
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Failed to resize attribute &quot;
l_string|&quot;record for mft data attribute.&quot;
)paren
suffix:semicolon
r_goto
id|undo_alloc
suffix:semicolon
)brace
singleline_comment|// TODO: Deal with this by moving this extent to a new mft
singleline_comment|// record or by starting a new extent in a new mft record or by
singleline_comment|// moving other attributes out of this mft record.
singleline_comment|// Note: Use the special reserved mft records and ensure that
singleline_comment|// this extent is not required to find the mft record in
singleline_comment|// question.
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Not enough space in this mft record to &quot;
l_string|&quot;accomodate extended mft data attribute &quot;
l_string|&quot;extent.  Cannot handle this yet.&quot;
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EOPNOTSUPP
suffix:semicolon
r_goto
id|undo_alloc
suffix:semicolon
)brace
id|mp_rebuilt
op_assign
id|TRUE
suffix:semicolon
multiline_comment|/* Generate the mapping pairs array directly into the attr record. */
id|ret
op_assign
id|ntfs_mapping_pairs_build
c_func
(paren
id|vol
comma
(paren
id|u8
op_star
)paren
id|a
op_plus
id|le16_to_cpu
c_func
(paren
id|a-&gt;data.non_resident.mapping_pairs_offset
)paren
comma
id|mp_size
comma
id|rl2
comma
id|ll
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|ret
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Failed to build mapping pairs array of &quot;
l_string|&quot;mft data attribute.&quot;
)paren
suffix:semicolon
r_goto
id|undo_alloc
suffix:semicolon
)brace
multiline_comment|/* Update the highest_vcn. */
id|a-&gt;data.non_resident.highest_vcn
op_assign
id|cpu_to_sle64
c_func
(paren
id|rl
(braket
l_int|1
)braket
dot
id|vcn
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We now have extended the mft data allocated_size by nr clusters.&n;&t; * Reflect this in the ntfs_inode structure and the attribute record.&n;&t; * @rl is the last (non-terminator) runlist element of mft data&n;&t; * attribute.&n;&t; */
r_if
c_cond
(paren
id|a-&gt;data.non_resident.lowest_vcn
)paren
(brace
multiline_comment|/*&n;&t;&t; * We are not in the first attribute extent, switch to it, but&n;&t;&t; * first ensure the changes will make it to disk later.&n;&t;&t; */
id|flush_dcache_mft_record_page
c_func
(paren
id|ctx-&gt;ntfs_ino
)paren
suffix:semicolon
id|mark_mft_record_dirty
c_func
(paren
id|ctx-&gt;ntfs_ino
)paren
suffix:semicolon
id|ntfs_attr_reinit_search_ctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
id|ret
op_assign
id|ntfs_attr_lookup
c_func
(paren
id|mft_ni-&gt;type
comma
id|mft_ni-&gt;name
comma
id|mft_ni-&gt;name_len
comma
id|CASE_SENSITIVE
comma
l_int|0
comma
l_int|NULL
comma
l_int|0
comma
id|ctx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|ret
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Failed to find first attribute &quot;
l_string|&quot;extent of mft data attribute.&quot;
)paren
suffix:semicolon
r_goto
id|restore_undo_alloc
suffix:semicolon
)brace
id|a
op_assign
id|ctx-&gt;attr
suffix:semicolon
)brace
id|mft_ni-&gt;allocated_size
op_add_assign
id|nr
op_lshift
id|vol-&gt;cluster_size_bits
suffix:semicolon
id|a-&gt;data.non_resident.allocated_size
op_assign
id|cpu_to_sle64
c_func
(paren
id|mft_ni-&gt;allocated_size
)paren
suffix:semicolon
multiline_comment|/* Ensure the changes make it to disk. */
id|flush_dcache_mft_record_page
c_func
(paren
id|ctx-&gt;ntfs_ino
)paren
suffix:semicolon
id|mark_mft_record_dirty
c_func
(paren
id|ctx-&gt;ntfs_ino
)paren
suffix:semicolon
id|ntfs_attr_put_search_ctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
id|unmap_mft_record
c_func
(paren
id|mft_ni
)paren
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|mft_ni-&gt;runlist.lock
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Done.&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|restore_undo_alloc
suffix:colon
id|ntfs_attr_reinit_search_ctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ntfs_attr_lookup
c_func
(paren
id|mft_ni-&gt;type
comma
id|mft_ni-&gt;name
comma
id|mft_ni-&gt;name_len
comma
id|CASE_SENSITIVE
comma
id|rl
(braket
l_int|1
)braket
dot
id|vcn
comma
l_int|NULL
comma
l_int|0
comma
id|ctx
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Failed to find last attribute extent of &quot;
l_string|&quot;mft data attribute.%s&quot;
comma
id|es
)paren
suffix:semicolon
id|mft_ni-&gt;allocated_size
op_add_assign
id|nr
op_lshift
id|vol-&gt;cluster_size_bits
suffix:semicolon
id|ntfs_attr_put_search_ctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
id|unmap_mft_record
c_func
(paren
id|mft_ni
)paren
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|mft_ni-&gt;runlist.lock
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * The only thing that is now wrong is -&gt;allocated_size of the&n;&t;&t; * base attribute extent which chkdsk should be able to fix.&n;&t;&t; */
id|NVolSetErrors
c_func
(paren
id|vol
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
id|a
op_assign
id|ctx-&gt;attr
suffix:semicolon
id|a-&gt;data.non_resident.highest_vcn
op_assign
id|cpu_to_sle64
c_func
(paren
id|old_last_vcn
op_minus
l_int|1
)paren
suffix:semicolon
id|undo_alloc
suffix:colon
r_if
c_cond
(paren
id|ntfs_cluster_free
c_func
(paren
id|vol-&gt;mft_ino
comma
id|old_last_vcn
comma
op_minus
l_int|1
)paren
OL
l_int|0
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Failed to free clusters from mft data &quot;
l_string|&quot;attribute.%s&quot;
comma
id|es
)paren
suffix:semicolon
id|NVolSetErrors
c_func
(paren
id|vol
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ntfs_rl_truncate_nolock
c_func
(paren
id|vol
comma
op_amp
id|mft_ni-&gt;runlist
comma
id|old_last_vcn
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Failed to truncate mft data attribute &quot;
l_string|&quot;runlist.%s&quot;
comma
id|es
)paren
suffix:semicolon
id|NVolSetErrors
c_func
(paren
id|vol
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mp_rebuilt
)paren
(brace
r_if
c_cond
(paren
id|ntfs_mapping_pairs_build
c_func
(paren
id|vol
comma
(paren
id|u8
op_star
)paren
id|a
op_plus
id|le16_to_cpu
c_func
(paren
id|a-&gt;data.non_resident.mapping_pairs_offset
)paren
comma
id|old_alen
op_minus
id|le16_to_cpu
c_func
(paren
id|a-&gt;data.non_resident.mapping_pairs_offset
)paren
comma
id|rl2
comma
id|ll
comma
l_int|NULL
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Failed to restore mapping pairs &quot;
l_string|&quot;array.%s&quot;
comma
id|es
)paren
suffix:semicolon
id|NVolSetErrors
c_func
(paren
id|vol
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ntfs_attr_record_resize
c_func
(paren
id|ctx-&gt;mrec
comma
id|a
comma
id|old_alen
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Failed to restore attribute &quot;
l_string|&quot;record.%s&quot;
comma
id|es
)paren
suffix:semicolon
id|NVolSetErrors
c_func
(paren
id|vol
)paren
suffix:semicolon
)brace
id|flush_dcache_mft_record_page
c_func
(paren
id|ctx-&gt;ntfs_ino
)paren
suffix:semicolon
id|mark_mft_record_dirty
c_func
(paren
id|ctx-&gt;ntfs_ino
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ctx
)paren
id|ntfs_attr_put_search_ctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|IS_ERR
c_func
(paren
id|mrec
)paren
)paren
id|unmap_mft_record
c_func
(paren
id|mft_ni
)paren
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|mft_ni-&gt;runlist.lock
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_mft_record_layout - layout an mft record into a memory buffer&n; * @vol:&t;volume to which the mft record will belong&n; * @mft_no:&t;mft reference specifying the mft record number&n; * @m:&t;&t;destination buffer of size &gt;= @vol-&gt;mft_record_size bytes&n; *&n; * Layout an empty, unused mft record with the mft record number @mft_no into&n; * the buffer @m.  The volume @vol is needed because the mft record structure&n; * was modified in NTFS 3.1 so we need to know which volume version this mft&n; * record will be used on.&n; *&n; * Return 0 on success and -errno on error.&n; */
DECL|function|ntfs_mft_record_layout
r_static
r_int
id|ntfs_mft_record_layout
c_func
(paren
r_const
id|ntfs_volume
op_star
id|vol
comma
r_const
id|s64
id|mft_no
comma
id|MFT_RECORD
op_star
id|m
)paren
(brace
id|ATTR_RECORD
op_star
id|a
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Entering for mft record 0x%llx.&quot;
comma
(paren
r_int
r_int
)paren
id|mft_no
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mft_no
op_ge
(paren
l_int|1ll
op_lshift
l_int|32
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Mft record number 0x%llx exceeds &quot;
l_string|&quot;maximum of 2^32.&quot;
comma
(paren
r_int
r_int
)paren
id|mft_no
)paren
suffix:semicolon
r_return
op_minus
id|ERANGE
suffix:semicolon
)brace
multiline_comment|/* Start by clearing the whole mft record to gives us a clean slate. */
id|memset
c_func
(paren
id|m
comma
l_int|0
comma
id|vol-&gt;mft_record_size
)paren
suffix:semicolon
multiline_comment|/* Aligned to 2-byte boundary. */
r_if
c_cond
(paren
id|vol-&gt;major_ver
OL
l_int|3
op_logical_or
(paren
id|vol-&gt;major_ver
op_eq
l_int|3
op_logical_and
op_logical_neg
id|vol-&gt;minor_ver
)paren
)paren
id|m-&gt;usa_ofs
op_assign
id|cpu_to_le16
c_func
(paren
(paren
r_sizeof
(paren
id|MFT_RECORD_OLD
)paren
op_plus
l_int|1
)paren
op_amp
op_complement
l_int|1
)paren
suffix:semicolon
r_else
(brace
id|m-&gt;usa_ofs
op_assign
id|cpu_to_le16
c_func
(paren
(paren
r_sizeof
(paren
id|MFT_RECORD
)paren
op_plus
l_int|1
)paren
op_amp
op_complement
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Set the NTFS 3.1+ specific fields while we know that the&n;&t;&t; * volume version is 3.1+.&n;&t;&t; */
id|m-&gt;reserved
op_assign
l_int|0
suffix:semicolon
id|m-&gt;mft_record_number
op_assign
id|cpu_to_le32
c_func
(paren
(paren
id|u32
)paren
id|mft_no
)paren
suffix:semicolon
)brace
id|m-&gt;magic
op_assign
id|magic_FILE
suffix:semicolon
r_if
c_cond
(paren
id|vol-&gt;mft_record_size
op_ge
id|NTFS_BLOCK_SIZE
)paren
id|m-&gt;usa_count
op_assign
id|cpu_to_le16
c_func
(paren
id|vol-&gt;mft_record_size
op_div
id|NTFS_BLOCK_SIZE
op_plus
l_int|1
)paren
suffix:semicolon
r_else
(brace
id|m-&gt;usa_count
op_assign
id|cpu_to_le16
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|ntfs_warning
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Sector size is bigger than mft record &quot;
l_string|&quot;size.  Setting usa_count to 1.  If chkdsk &quot;
l_string|&quot;reports this as corruption, please email &quot;
l_string|&quot;linux-ntfs-dev@lists.sourceforge.net stating &quot;
l_string|&quot;that you saw this message and that the &quot;
l_string|&quot;modified file system created was corrupt.  &quot;
l_string|&quot;Thank you.&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* Set the update sequence number to 1. */
op_star
(paren
id|le16
op_star
)paren
(paren
(paren
id|u8
op_star
)paren
id|m
op_plus
id|le16_to_cpu
c_func
(paren
id|m-&gt;usa_ofs
)paren
)paren
op_assign
id|cpu_to_le16
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|m-&gt;lsn
op_assign
l_int|0
suffix:semicolon
id|m-&gt;sequence_number
op_assign
id|cpu_to_le16
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|m-&gt;link_count
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Place the attributes straight after the update sequence array,&n;&t; * aligned to 8-byte boundary.&n;&t; */
id|m-&gt;attrs_offset
op_assign
id|cpu_to_le16
c_func
(paren
(paren
id|le16_to_cpu
c_func
(paren
id|m-&gt;usa_ofs
)paren
op_plus
(paren
id|le16_to_cpu
c_func
(paren
id|m-&gt;usa_count
)paren
op_lshift
l_int|1
)paren
op_plus
l_int|7
)paren
op_amp
op_complement
l_int|7
)paren
suffix:semicolon
id|m-&gt;flags
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Using attrs_offset plus eight bytes (for the termination attribute).&n;&t; * attrs_offset is already aligned to 8-byte boundary, so no need to&n;&t; * align again.&n;&t; */
id|m-&gt;bytes_in_use
op_assign
id|cpu_to_le32
c_func
(paren
id|le16_to_cpu
c_func
(paren
id|m-&gt;attrs_offset
)paren
op_plus
l_int|8
)paren
suffix:semicolon
id|m-&gt;bytes_allocated
op_assign
id|cpu_to_le32
c_func
(paren
id|vol-&gt;mft_record_size
)paren
suffix:semicolon
id|m-&gt;base_mft_record
op_assign
l_int|0
suffix:semicolon
id|m-&gt;next_attr_instance
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Add the termination attribute. */
id|a
op_assign
(paren
id|ATTR_RECORD
op_star
)paren
(paren
(paren
id|u8
op_star
)paren
id|m
op_plus
id|le16_to_cpu
c_func
(paren
id|m-&gt;attrs_offset
)paren
)paren
suffix:semicolon
id|a-&gt;type
op_assign
id|AT_END
suffix:semicolon
id|a-&gt;length
op_assign
l_int|0
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Done.&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_mft_record_format - format an mft record on an ntfs volume&n; * @vol:&t;volume on which to format the mft record&n; * @mft_no:&t;mft record number to format&n; *&n; * Format the mft record @mft_no in $MFT/$DATA, i.e. lay out an empty, unused&n; * mft record into the appropriate place of the mft data attribute.  This is&n; * used when extending the mft data attribute.&n; *&n; * Return 0 on success and -errno on error.&n; */
DECL|function|ntfs_mft_record_format
r_static
r_int
id|ntfs_mft_record_format
c_func
(paren
r_const
id|ntfs_volume
op_star
id|vol
comma
r_const
id|s64
id|mft_no
)paren
(brace
r_struct
id|inode
op_star
id|mft_vi
op_assign
id|vol-&gt;mft_ino
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
id|MFT_RECORD
op_star
id|m
suffix:semicolon
id|pgoff_t
id|index
comma
id|end_index
suffix:semicolon
r_int
r_int
id|ofs
suffix:semicolon
r_int
id|err
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Entering for mft record 0x%llx.&quot;
comma
(paren
r_int
r_int
)paren
id|mft_no
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * The index into the page cache and the offset within the page cache&n;&t; * page of the wanted mft record.&n;&t; */
id|index
op_assign
id|mft_no
op_lshift
id|vol-&gt;mft_record_size_bits
op_rshift
id|PAGE_CACHE_SHIFT
suffix:semicolon
id|ofs
op_assign
(paren
id|mft_no
op_lshift
id|vol-&gt;mft_record_size_bits
)paren
op_amp
op_complement
id|PAGE_CACHE_MASK
suffix:semicolon
multiline_comment|/* The maximum valid index into the page cache for $MFT&squot;s data. */
id|end_index
op_assign
id|mft_vi-&gt;i_size
op_rshift
id|PAGE_CACHE_SHIFT
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|index
op_ge
id|end_index
)paren
)paren
(brace
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|index
OG
id|end_index
op_logical_or
id|ofs
op_plus
id|vol-&gt;mft_record_size
op_ge
(paren
id|mft_vi-&gt;i_size
op_amp
op_complement
id|PAGE_CACHE_MASK
)paren
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Tried to format non-existing mft &quot;
l_string|&quot;record 0x%llx.&quot;
comma
(paren
r_int
r_int
)paren
id|mft_no
)paren
suffix:semicolon
r_return
op_minus
id|ENOENT
suffix:semicolon
)brace
)brace
multiline_comment|/* Read, map, and pin the page containing the mft record. */
id|page
op_assign
id|ntfs_map_page
c_func
(paren
id|mft_vi-&gt;i_mapping
comma
id|index
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|IS_ERR
c_func
(paren
id|page
)paren
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Failed to map page containing mft record &quot;
l_string|&quot;to format 0x%llx.&quot;
comma
(paren
r_int
r_int
)paren
id|mft_no
)paren
suffix:semicolon
r_return
id|PTR_ERR
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
id|lock_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|PageUptodate
c_func
(paren
id|page
)paren
)paren
suffix:semicolon
id|ClearPageUptodate
c_func
(paren
id|page
)paren
suffix:semicolon
id|m
op_assign
(paren
id|MFT_RECORD
op_star
)paren
(paren
(paren
id|u8
op_star
)paren
id|page_address
c_func
(paren
id|page
)paren
op_plus
id|ofs
)paren
suffix:semicolon
id|err
op_assign
id|ntfs_mft_record_layout
c_func
(paren
id|vol
comma
id|mft_no
comma
id|m
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|err
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Failed to layout mft record 0x%llx.&quot;
comma
(paren
r_int
r_int
)paren
id|mft_no
)paren
suffix:semicolon
id|SetPageUptodate
c_func
(paren
id|page
)paren
suffix:semicolon
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|ntfs_unmap_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
id|flush_dcache_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|SetPageUptodate
c_func
(paren
id|page
)paren
suffix:semicolon
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Make sure the mft record is written out to disk.  We could use&n;&t; * ilookup5() to check if an inode is in icache and so on but this is&n;&t; * unnecessary as ntfs_writepage() will write the dirty record anyway.&n;&t; */
id|mark_ntfs_record_dirty
c_func
(paren
id|page
comma
id|ofs
)paren
suffix:semicolon
id|ntfs_unmap_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Done.&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_mft_record_alloc - allocate an mft record on an ntfs volume&n; * @vol:&t;[IN]  volume on which to allocate the mft record&n; * @mode:&t;[IN]  mode if want a file or directory, i.e. base inode or 0&n; * @base_ni:&t;[IN]  open base inode if allocating an extent mft record or NULL&n; * @mrec:&t;[OUT] on successful return this is the mapped mft record&n; *&n; * Allocate an mft record in $MFT/$DATA of an open ntfs volume @vol.&n; *&n; * If @base_ni is NULL make the mft record a base mft record, i.e. a file or&n; * direvctory inode, and allocate it at the default allocator position.  In&n; * this case @mode is the file mode as given to us by the caller.  We in&n; * particular use @mode to distinguish whether a file or a directory is being&n; * created (S_IFDIR(mode) and S_IFREG(mode), respectively).&n; *&n; * If @base_ni is not NULL make the allocated mft record an extent record,&n; * allocate it starting at the mft record after the base mft record and attach&n; * the allocated and opened ntfs inode to the base inode @base_ni.  In this&n; * case @mode must be 0 as it is meaningless for extent inodes.&n; *&n; * You need to check the return value with IS_ERR().  If false, the function&n; * was successful and the return value is the now opened ntfs inode of the&n; * allocated mft record.  *@mrec is then set to the allocated, mapped, pinned,&n; * and locked mft record.  If IS_ERR() is true, the function failed and the&n; * error code is obtained from PTR_ERR(return value).  *@mrec is undefined in&n; * this case.&n; *&n; * Allocation strategy:&n; *&n; * To find a free mft record, we scan the mft bitmap for a zero bit.  To&n; * optimize this we start scanning at the place specified by @base_ni or if&n; * @base_ni is NULL we start where we last stopped and we perform wrap around&n; * when we reach the end.  Note, we do not try to allocate mft records below&n; * number 24 because numbers 0 to 15 are the defined system files anyway and 16&n; * to 24 are special in that they are used for storing extension mft records&n; * for the $DATA attribute of $MFT.  This is required to avoid the possibility&n; * of creating a runlist with a circular dependency which once written to disk&n; * can never be read in again.  Windows will only use records 16 to 24 for&n; * normal files if the volume is completely out of space.  We never use them&n; * which means that when the volume is really out of space we cannot create any&n; * more files while Windows can still create up to 8 small files.  We can start&n; * doing this at some later time, it does not matter much for now.&n; *&n; * When scanning the mft bitmap, we only search up to the last allocated mft&n; * record.  If there are no free records left in the range 24 to number of&n; * allocated mft records, then we extend the $MFT/$DATA attribute in order to&n; * create free mft records.  We extend the allocated size of $MFT/$DATA by 16&n; * records at a time or one cluster, if cluster size is above 16kiB.  If there&n; * is not sufficient space to do this, we try to extend by a single mft record&n; * or one cluster, if cluster size is above the mft record size.&n; *&n; * No matter how many mft records we allocate, we initialize only the first&n; * allocated mft record, incrementing mft data size and initialized size&n; * accordingly, open an ntfs_inode for it and return it to the caller, unless&n; * there are less than 24 mft records, in which case we allocate and initialize&n; * mft records until we reach record 24 which we consider as the first free mft&n; * record for use by normal files.&n; *&n; * If during any stage we overflow the initialized data in the mft bitmap, we&n; * extend the initialized size (and data size) by 8 bytes, allocating another&n; * cluster if required.  The bitmap data size has to be at least equal to the&n; * number of mft records in the mft, but it can be bigger, in which case the&n; * superflous bits are padded with zeroes.&n; *&n; * Thus, when we return successfully (IS_ERR() is false), we will have:&n; *&t;- initialized / extended the mft bitmap if necessary,&n; *&t;- initialized / extended the mft data if necessary,&n; *&t;- set the bit corresponding to the mft record being allocated in the&n; *&t;  mft bitmap,&n; *&t;- opened an ntfs_inode for the allocated mft record, and we will have&n; *&t;- returned the ntfs_inode as well as the allocated mapped, pinned, and&n; *&t;  locked mft record.&n; *&n; * On error, the volume will be left in a consistent state and no record will&n; * be allocated.  If rolling back a partial operation fails, we may leave some&n; * inconsistent metadata in which case we set NVolErrors() so the volume is&n; * left dirty when unmounted.&n; *&n; * Note, this function cannot make use of most of the normal functions, like&n; * for example for attribute resizing, etc, because when the run list overflows&n; * the base mft record and an attribute list is used, it is very important that&n; * the extension mft records used to store the $DATA attribute of $MFT can be&n; * reached without having to read the information contained inside them, as&n; * this would make it impossible to find them in the first place after the&n; * volume is unmounted.  $MFT/$BITMAP probably does not need to follow this&n; * rule because the bitmap is not essential for finding the mft records, but on&n; * the other hand, handling the bitmap in this special way would make life&n; * easier because otherwise there might be circular invocations of functions&n; * when reading the bitmap.&n; */
DECL|function|ntfs_mft_record_alloc
id|ntfs_inode
op_star
id|ntfs_mft_record_alloc
c_func
(paren
id|ntfs_volume
op_star
id|vol
comma
r_const
r_int
id|mode
comma
id|ntfs_inode
op_star
id|base_ni
comma
id|MFT_RECORD
op_star
op_star
id|mrec
)paren
(brace
id|s64
id|ll
comma
id|bit
comma
id|old_data_initialized
comma
id|old_data_size
suffix:semicolon
r_struct
id|inode
op_star
id|vi
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
id|ntfs_inode
op_star
id|mft_ni
comma
op_star
id|mftbmp_ni
comma
op_star
id|ni
suffix:semicolon
id|ntfs_attr_search_ctx
op_star
id|ctx
suffix:semicolon
id|MFT_RECORD
op_star
id|m
suffix:semicolon
id|ATTR_RECORD
op_star
id|a
suffix:semicolon
id|pgoff_t
id|index
suffix:semicolon
r_int
r_int
id|ofs
suffix:semicolon
r_int
id|err
suffix:semicolon
id|le16
id|seq_no
comma
id|usn
suffix:semicolon
id|BOOL
id|record_formatted
op_assign
id|FALSE
suffix:semicolon
r_if
c_cond
(paren
id|base_ni
)paren
(brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Entering (allocating an extent mft record for &quot;
l_string|&quot;base mft record 0x%llx).&quot;
comma
(paren
r_int
r_int
)paren
id|base_ni-&gt;mft_no
)paren
suffix:semicolon
multiline_comment|/* @mode and @base_ni are mutually exclusive. */
id|BUG_ON
c_func
(paren
id|mode
)paren
suffix:semicolon
)brace
r_else
id|ntfs_debug
c_func
(paren
l_string|&quot;Entering (allocating a base mft record).&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mode
)paren
(brace
multiline_comment|/* @mode and @base_ni are mutually exclusive. */
id|BUG_ON
c_func
(paren
id|base_ni
)paren
suffix:semicolon
multiline_comment|/* We only support creation of normal files and directories. */
r_if
c_cond
(paren
op_logical_neg
id|S_ISREG
c_func
(paren
id|mode
)paren
op_logical_and
op_logical_neg
id|S_ISDIR
c_func
(paren
id|mode
)paren
)paren
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|EOPNOTSUPP
)paren
suffix:semicolon
)brace
id|BUG_ON
c_func
(paren
op_logical_neg
id|mrec
)paren
suffix:semicolon
id|mft_ni
op_assign
id|NTFS_I
c_func
(paren
id|vol-&gt;mft_ino
)paren
suffix:semicolon
id|mftbmp_ni
op_assign
id|NTFS_I
c_func
(paren
id|vol-&gt;mftbmp_ino
)paren
suffix:semicolon
id|down_write
c_func
(paren
op_amp
id|vol-&gt;mftbmp_lock
)paren
suffix:semicolon
id|bit
op_assign
id|ntfs_mft_bitmap_find_and_alloc_free_rec_nolock
c_func
(paren
id|vol
comma
id|base_ni
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bit
op_ge
l_int|0
)paren
(brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Found and allocated free record (#1), bit 0x%llx.&quot;
comma
(paren
r_int
r_int
)paren
id|bit
)paren
suffix:semicolon
r_goto
id|have_alloc_rec
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bit
op_ne
op_minus
id|ENOSPC
)paren
(brace
id|up_write
c_func
(paren
op_amp
id|vol-&gt;mftbmp_lock
)paren
suffix:semicolon
r_return
id|ERR_PTR
c_func
(paren
id|bit
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * No free mft records left.  If the mft bitmap already covers more&n;&t; * than the currently used mft records, the next records are all free,&n;&t; * so we can simply allocate the first unused mft record.&n;&t; * Note: We also have to make sure that the mft bitmap at least covers&n;&t; * the first 24 mft records as they are special and whilst they may not&n;&t; * be in use, we do not allocate from them.&n;&t; */
id|ll
op_assign
id|mft_ni-&gt;initialized_size
op_rshift
id|vol-&gt;mft_record_size_bits
suffix:semicolon
r_if
c_cond
(paren
id|mftbmp_ni-&gt;initialized_size
op_lshift
l_int|3
OG
id|ll
op_logical_and
id|mftbmp_ni-&gt;initialized_size
OG
l_int|3
)paren
(brace
id|bit
op_assign
id|ll
suffix:semicolon
r_if
c_cond
(paren
id|bit
OL
l_int|24
)paren
id|bit
op_assign
l_int|24
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|bit
op_ge
(paren
l_int|1ll
op_lshift
l_int|32
)paren
)paren
)paren
r_goto
id|max_err_out
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Found free record (#2), bit 0x%llx.&quot;
comma
(paren
r_int
r_int
)paren
id|bit
)paren
suffix:semicolon
r_goto
id|found_free_rec
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * The mft bitmap needs to be expanded until it covers the first unused&n;&t; * mft record that we can allocate.&n;&t; * Note: The smallest mft record we allocate is mft record 24.&n;&t; */
id|bit
op_assign
id|mftbmp_ni-&gt;initialized_size
op_lshift
l_int|3
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|bit
op_ge
(paren
l_int|1ll
op_lshift
l_int|32
)paren
)paren
)paren
r_goto
id|max_err_out
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Status of mftbmp before extension: allocated_size 0x%llx, &quot;
l_string|&quot;data_size 0x%llx, initialized_size 0x%llx.&quot;
comma
(paren
r_int
r_int
)paren
id|mftbmp_ni-&gt;allocated_size
comma
(paren
r_int
r_int
)paren
id|vol-&gt;mftbmp_ino-&gt;i_size
comma
(paren
r_int
r_int
)paren
id|mftbmp_ni-&gt;initialized_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mftbmp_ni-&gt;initialized_size
op_plus
l_int|8
OG
id|mftbmp_ni-&gt;allocated_size
)paren
(brace
multiline_comment|/* Need to extend bitmap by one more cluster. */
id|ntfs_debug
c_func
(paren
l_string|&quot;mftbmp: initialized_size + 8 &gt; allocated_size.&quot;
)paren
suffix:semicolon
id|err
op_assign
id|ntfs_mft_bitmap_extend_allocation_nolock
c_func
(paren
id|vol
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|err
)paren
)paren
(brace
id|up_write
c_func
(paren
op_amp
id|vol-&gt;mftbmp_lock
)paren
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Status of mftbmp after allocation extension: &quot;
l_string|&quot;allocated_size 0x%llx, data_size 0x%llx, &quot;
l_string|&quot;initialized_size 0x%llx.&quot;
comma
(paren
r_int
r_int
)paren
id|mftbmp_ni-&gt;allocated_size
comma
(paren
r_int
r_int
)paren
id|vol-&gt;mftbmp_ino-&gt;i_size
comma
(paren
r_int
r_int
)paren
id|mftbmp_ni-&gt;initialized_size
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * We now have sufficient allocated space, extend the initialized_size&n;&t; * as well as the data_size if necessary and fill the new space with&n;&t; * zeroes.&n;&t; */
id|err
op_assign
id|ntfs_mft_bitmap_extend_initialized_nolock
c_func
(paren
id|vol
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|err
)paren
)paren
(brace
id|up_write
c_func
(paren
op_amp
id|vol-&gt;mftbmp_lock
)paren
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Status of mftbmp after initialized extention: &quot;
l_string|&quot;allocated_size 0x%llx, data_size 0x%llx, &quot;
l_string|&quot;initialized_size 0x%llx.&quot;
comma
(paren
r_int
r_int
)paren
id|mftbmp_ni-&gt;allocated_size
comma
(paren
r_int
r_int
)paren
id|vol-&gt;mftbmp_ino-&gt;i_size
comma
(paren
r_int
r_int
)paren
id|mftbmp_ni-&gt;initialized_size
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Found free record (#3), bit 0x%llx.&quot;
comma
(paren
r_int
r_int
)paren
id|bit
)paren
suffix:semicolon
id|found_free_rec
suffix:colon
multiline_comment|/* @bit is the found free mft record, allocate it in the mft bitmap. */
id|ntfs_debug
c_func
(paren
l_string|&quot;At found_free_rec.&quot;
)paren
suffix:semicolon
id|err
op_assign
id|ntfs_bitmap_set_bit
c_func
(paren
id|vol-&gt;mftbmp_ino
comma
id|bit
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|err
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Failed to allocate bit in mft bitmap.&quot;
)paren
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|vol-&gt;mftbmp_lock
)paren
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Set bit 0x%llx in mft bitmap.&quot;
comma
(paren
r_int
r_int
)paren
id|bit
)paren
suffix:semicolon
id|have_alloc_rec
suffix:colon
multiline_comment|/*&n;&t; * The mft bitmap is now uptodate.  Deal with mft data attribute now.&n;&t; * Note, we keep hold of the mft bitmap lock for writing until all&n;&t; * modifications to the mft data attribute are complete, too, as they&n;&t; * will impact decisions for mft bitmap and mft record allocation done&n;&t; * by a parallel allocation and if the lock is not maintained a&n;&t; * parallel allocation could allocate the same mft record as this one.&n;&t; */
id|ll
op_assign
(paren
id|bit
op_plus
l_int|1
)paren
op_lshift
id|vol-&gt;mft_record_size_bits
suffix:semicolon
r_if
c_cond
(paren
id|ll
op_le
id|mft_ni-&gt;initialized_size
)paren
(brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Allocated mft record already initialized.&quot;
)paren
suffix:semicolon
r_goto
id|mft_rec_already_initialized
suffix:semicolon
)brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Initializing allocated mft record.&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * The mft record is outside the initialized data.  Extend the mft data&n;&t; * attribute until it covers the allocated record.  The loop is only&n;&t; * actually traversed more than once when a freshly formatted volume is&n;&t; * first written to so it optimizes away nicely in the common case.&n;&t; */
id|ntfs_debug
c_func
(paren
l_string|&quot;Status of mft data before extension: &quot;
l_string|&quot;allocated_size 0x%llx, data_size 0x%llx, &quot;
l_string|&quot;initialized_size 0x%llx.&quot;
comma
(paren
r_int
r_int
)paren
id|mft_ni-&gt;allocated_size
comma
(paren
r_int
r_int
)paren
id|vol-&gt;mft_ino-&gt;i_size
comma
(paren
r_int
r_int
)paren
id|mft_ni-&gt;initialized_size
)paren
suffix:semicolon
r_while
c_loop
(paren
id|ll
OG
id|mft_ni-&gt;allocated_size
)paren
(brace
id|err
op_assign
id|ntfs_mft_data_extend_allocation_nolock
c_func
(paren
id|vol
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|err
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Failed to extend mft data &quot;
l_string|&quot;allocation.&quot;
)paren
suffix:semicolon
r_goto
id|undo_mftbmp_alloc_nolock
suffix:semicolon
)brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Status of mft data after allocation extension: &quot;
l_string|&quot;allocated_size 0x%llx, data_size 0x%llx, &quot;
l_string|&quot;initialized_size 0x%llx.&quot;
comma
(paren
r_int
r_int
)paren
id|mft_ni-&gt;allocated_size
comma
(paren
r_int
r_int
)paren
id|vol-&gt;mft_ino-&gt;i_size
comma
(paren
r_int
r_int
)paren
id|mft_ni-&gt;initialized_size
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Extend mft data initialized size (and data size of course) to reach&n;&t; * the allocated mft record, formatting the mft records allong the way.&n;&t; * Note: We only modify the ntfs_inode structure as that is all that is&n;&t; * needed by ntfs_mft_record_format().  We will update the attribute&n;&t; * record itself in one fell swoop later on.&n;&t; */
id|old_data_initialized
op_assign
id|mft_ni-&gt;initialized_size
suffix:semicolon
id|old_data_size
op_assign
id|vol-&gt;mft_ino-&gt;i_size
suffix:semicolon
r_while
c_loop
(paren
id|ll
OG
id|mft_ni-&gt;initialized_size
)paren
(brace
id|s64
id|new_initialized_size
comma
id|mft_no
suffix:semicolon
id|new_initialized_size
op_assign
id|mft_ni-&gt;initialized_size
op_plus
id|vol-&gt;mft_record_size
suffix:semicolon
id|mft_no
op_assign
id|mft_ni-&gt;initialized_size
op_rshift
id|vol-&gt;mft_record_size_bits
suffix:semicolon
r_if
c_cond
(paren
id|new_initialized_size
OG
id|vol-&gt;mft_ino-&gt;i_size
)paren
id|vol-&gt;mft_ino-&gt;i_size
op_assign
id|new_initialized_size
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Initializing mft record 0x%llx.&quot;
comma
(paren
r_int
r_int
)paren
id|mft_no
)paren
suffix:semicolon
id|err
op_assign
id|ntfs_mft_record_format
c_func
(paren
id|vol
comma
id|mft_no
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|err
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Failed to format mft record.&quot;
)paren
suffix:semicolon
r_goto
id|undo_data_init
suffix:semicolon
)brace
id|mft_ni-&gt;initialized_size
op_assign
id|new_initialized_size
suffix:semicolon
)brace
id|record_formatted
op_assign
id|TRUE
suffix:semicolon
multiline_comment|/* Update the mft data attribute record to reflect the new sizes. */
id|m
op_assign
id|map_mft_record
c_func
(paren
id|mft_ni
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|m
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Failed to map mft record.&quot;
)paren
suffix:semicolon
id|err
op_assign
id|PTR_ERR
c_func
(paren
id|m
)paren
suffix:semicolon
r_goto
id|undo_data_init
suffix:semicolon
)brace
id|ctx
op_assign
id|ntfs_attr_get_search_ctx
c_func
(paren
id|mft_ni
comma
id|m
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|ctx
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Failed to get search context.&quot;
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
id|unmap_mft_record
c_func
(paren
id|mft_ni
)paren
suffix:semicolon
r_goto
id|undo_data_init
suffix:semicolon
)brace
id|err
op_assign
id|ntfs_attr_lookup
c_func
(paren
id|mft_ni-&gt;type
comma
id|mft_ni-&gt;name
comma
id|mft_ni-&gt;name_len
comma
id|CASE_SENSITIVE
comma
l_int|0
comma
l_int|NULL
comma
l_int|0
comma
id|ctx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|err
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Failed to find first attribute extent of &quot;
l_string|&quot;mft data attribute.&quot;
)paren
suffix:semicolon
id|ntfs_attr_put_search_ctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
id|unmap_mft_record
c_func
(paren
id|mft_ni
)paren
suffix:semicolon
r_goto
id|undo_data_init
suffix:semicolon
)brace
id|a
op_assign
id|ctx-&gt;attr
suffix:semicolon
id|a-&gt;data.non_resident.initialized_size
op_assign
id|cpu_to_sle64
c_func
(paren
id|mft_ni-&gt;initialized_size
)paren
suffix:semicolon
id|a-&gt;data.non_resident.data_size
op_assign
id|cpu_to_sle64
c_func
(paren
id|vol-&gt;mft_ino-&gt;i_size
)paren
suffix:semicolon
multiline_comment|/* Ensure the changes make it to disk. */
id|flush_dcache_mft_record_page
c_func
(paren
id|ctx-&gt;ntfs_ino
)paren
suffix:semicolon
id|mark_mft_record_dirty
c_func
(paren
id|ctx-&gt;ntfs_ino
)paren
suffix:semicolon
id|ntfs_attr_put_search_ctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
id|unmap_mft_record
c_func
(paren
id|mft_ni
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Status of mft data after mft record initialization: &quot;
l_string|&quot;allocated_size 0x%llx, data_size 0x%llx, &quot;
l_string|&quot;initialized_size 0x%llx.&quot;
comma
(paren
r_int
r_int
)paren
id|mft_ni-&gt;allocated_size
comma
(paren
r_int
r_int
)paren
id|vol-&gt;mft_ino-&gt;i_size
comma
(paren
r_int
r_int
)paren
id|mft_ni-&gt;initialized_size
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|vol-&gt;mft_ino-&gt;i_size
OG
id|mft_ni-&gt;allocated_size
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|mft_ni-&gt;initialized_size
OG
id|vol-&gt;mft_ino-&gt;i_size
)paren
suffix:semicolon
id|mft_rec_already_initialized
suffix:colon
multiline_comment|/*&n;&t; * We can finally drop the mft bitmap lock as the mft data attribute&n;&t; * has been fully updated.  The only disparity left is that the&n;&t; * allocated mft record still needs to be marked as in use to match the&n;&t; * set bit in the mft bitmap but this is actually not a problem since&n;&t; * this mft record is not referenced from anywhere yet and the fact&n;&t; * that it is allocated in the mft bitmap means that no-one will try to&n;&t; * allocate it either.&n;&t; */
id|up_write
c_func
(paren
op_amp
id|vol-&gt;mftbmp_lock
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We now have allocated and initialized the mft record.  Calculate the&n;&t; * index of and the offset within the page cache page the record is in.&n;&t; */
id|index
op_assign
id|bit
op_lshift
id|vol-&gt;mft_record_size_bits
op_rshift
id|PAGE_CACHE_SHIFT
suffix:semicolon
id|ofs
op_assign
(paren
id|bit
op_lshift
id|vol-&gt;mft_record_size_bits
)paren
op_amp
op_complement
id|PAGE_CACHE_MASK
suffix:semicolon
multiline_comment|/* Read, map, and pin the page containing the mft record. */
id|page
op_assign
id|ntfs_map_page
c_func
(paren
id|vol-&gt;mft_ino-&gt;i_mapping
comma
id|index
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|IS_ERR
c_func
(paren
id|page
)paren
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Failed to map page containing allocated &quot;
l_string|&quot;mft record 0x%llx.&quot;
comma
(paren
r_int
r_int
)paren
id|bit
)paren
suffix:semicolon
id|err
op_assign
id|PTR_ERR
c_func
(paren
id|page
)paren
suffix:semicolon
r_goto
id|undo_mftbmp_alloc
suffix:semicolon
)brace
id|lock_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|PageUptodate
c_func
(paren
id|page
)paren
)paren
suffix:semicolon
id|ClearPageUptodate
c_func
(paren
id|page
)paren
suffix:semicolon
id|m
op_assign
(paren
id|MFT_RECORD
op_star
)paren
(paren
(paren
id|u8
op_star
)paren
id|page_address
c_func
(paren
id|page
)paren
op_plus
id|ofs
)paren
suffix:semicolon
multiline_comment|/* If we just formatted the mft record no need to do it again. */
r_if
c_cond
(paren
op_logical_neg
id|record_formatted
)paren
(brace
multiline_comment|/* Sanity check that the mft record is really not in use. */
r_if
c_cond
(paren
id|ntfs_is_file_record
c_func
(paren
id|m-&gt;magic
)paren
op_logical_and
(paren
id|m-&gt;flags
op_amp
id|MFT_RECORD_IN_USE
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Mft record 0x%llx was marked &quot;
l_string|&quot;free in mft bitmap but is marked &quot;
l_string|&quot;used itself.  Corrupt filesystem.  &quot;
l_string|&quot;Unmount and run chkdsk.&quot;
comma
(paren
r_int
r_int
)paren
id|bit
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EIO
suffix:semicolon
id|SetPageUptodate
c_func
(paren
id|page
)paren
suffix:semicolon
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|ntfs_unmap_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|NVolSetErrors
c_func
(paren
id|vol
)paren
suffix:semicolon
r_goto
id|undo_mftbmp_alloc
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * We need to (re-)format the mft record, preserving the&n;&t;&t; * sequence number if it is not zero as well as the update&n;&t;&t; * sequence number if it is not zero or -1 (0xffff).  This&n;&t;&t; * means we do not need to care whether or not something went&n;&t;&t; * wrong with the previous mft record.&n;&t;&t; */
id|seq_no
op_assign
id|m-&gt;sequence_number
suffix:semicolon
id|usn
op_assign
op_star
(paren
id|le16
op_star
)paren
(paren
(paren
id|u8
op_star
)paren
id|m
op_plus
id|le16_to_cpu
c_func
(paren
id|m-&gt;usa_ofs
)paren
)paren
suffix:semicolon
id|err
op_assign
id|ntfs_mft_record_layout
c_func
(paren
id|vol
comma
id|bit
comma
id|m
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|err
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Failed to layout allocated mft &quot;
l_string|&quot;record 0x%llx.&quot;
comma
(paren
r_int
r_int
)paren
id|bit
)paren
suffix:semicolon
id|SetPageUptodate
c_func
(paren
id|page
)paren
suffix:semicolon
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|ntfs_unmap_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_goto
id|undo_mftbmp_alloc
suffix:semicolon
)brace
r_if
c_cond
(paren
id|seq_no
)paren
id|m-&gt;sequence_number
op_assign
id|seq_no
suffix:semicolon
r_if
c_cond
(paren
id|usn
op_logical_and
id|le16_to_cpu
c_func
(paren
id|usn
)paren
op_ne
l_int|0xffff
)paren
op_star
(paren
id|le16
op_star
)paren
(paren
(paren
id|u8
op_star
)paren
id|m
op_plus
id|le16_to_cpu
c_func
(paren
id|m-&gt;usa_ofs
)paren
)paren
op_assign
id|usn
suffix:semicolon
)brace
multiline_comment|/* Set the mft record itself in use. */
id|m-&gt;flags
op_or_assign
id|MFT_RECORD_IN_USE
suffix:semicolon
r_if
c_cond
(paren
id|S_ISDIR
c_func
(paren
id|mode
)paren
)paren
id|m-&gt;flags
op_or_assign
id|MFT_RECORD_IS_DIRECTORY
suffix:semicolon
id|flush_dcache_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|SetPageUptodate
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|base_ni
)paren
(brace
multiline_comment|/*&n;&t;&t; * Setup the base mft record in the extent mft record.  This&n;&t;&t; * completes initialization of the allocated extent mft record&n;&t;&t; * and we can simply use it with map_extent_mft_record().&n;&t;&t; */
id|m-&gt;base_mft_record
op_assign
id|MK_LE_MREF
c_func
(paren
id|base_ni-&gt;mft_no
comma
id|base_ni-&gt;seq_no
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Allocate an extent inode structure for the new mft record,&n;&t;&t; * attach it to the base inode @base_ni and map, pin, and lock&n;&t;&t; * its, i.e. the allocated, mft record.&n;&t;&t; */
id|m
op_assign
id|map_extent_mft_record
c_func
(paren
id|base_ni
comma
id|bit
comma
op_amp
id|ni
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|m
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Failed to map allocated extent &quot;
l_string|&quot;mft record 0x%llx.&quot;
comma
(paren
r_int
r_int
)paren
id|bit
)paren
suffix:semicolon
id|err
op_assign
id|PTR_ERR
c_func
(paren
id|m
)paren
suffix:semicolon
multiline_comment|/* Set the mft record itself not in use. */
id|m-&gt;flags
op_and_assign
id|cpu_to_le16
c_func
(paren
op_complement
id|le16_to_cpu
c_func
(paren
id|MFT_RECORD_IN_USE
)paren
)paren
suffix:semicolon
id|flush_dcache_page
c_func
(paren
id|page
)paren
suffix:semicolon
multiline_comment|/* Make sure the mft record is written out to disk. */
id|mark_ntfs_record_dirty
c_func
(paren
id|page
comma
id|ofs
)paren
suffix:semicolon
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|ntfs_unmap_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_goto
id|undo_mftbmp_alloc
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Make sure the allocated mft record is written out to disk.&n;&t;&t; * No need to set the inode dirty because the caller is going&n;&t;&t; * to do that anyway after finishing with the new extent mft&n;&t;&t; * record (e.g. at a minimum a new attribute will be added to&n;&t;&t; * the mft record.&n;&t;&t; */
id|mark_ntfs_record_dirty
c_func
(paren
id|page
comma
id|ofs
)paren
suffix:semicolon
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Need to unmap the page since map_extent_mft_record() mapped&n;&t;&t; * it as well so we have it mapped twice at the moment.&n;&t;&t; */
id|ntfs_unmap_page
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * Allocate a new VFS inode and set it up.  NOTE: @vi-&gt;i_nlink&n;&t;&t; * is set to 1 but the mft record-&gt;link_count is 0.  The caller&n;&t;&t; * needs to bear this in mind.&n;&t;&t; */
id|vi
op_assign
id|new_inode
c_func
(paren
id|vol-&gt;sb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|vi
)paren
)paren
(brace
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
multiline_comment|/* Set the mft record itself not in use. */
id|m-&gt;flags
op_and_assign
id|cpu_to_le16
c_func
(paren
op_complement
id|le16_to_cpu
c_func
(paren
id|MFT_RECORD_IN_USE
)paren
)paren
suffix:semicolon
id|flush_dcache_page
c_func
(paren
id|page
)paren
suffix:semicolon
multiline_comment|/* Make sure the mft record is written out to disk. */
id|mark_ntfs_record_dirty
c_func
(paren
id|page
comma
id|ofs
)paren
suffix:semicolon
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|ntfs_unmap_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_goto
id|undo_mftbmp_alloc
suffix:semicolon
)brace
id|vi-&gt;i_ino
op_assign
id|bit
suffix:semicolon
multiline_comment|/*&n;&t;&t; * This is the optimal IO size (for stat), not the fs block&n;&t;&t; * size.&n;&t;&t; */
id|vi-&gt;i_blksize
op_assign
id|PAGE_CACHE_SIZE
suffix:semicolon
multiline_comment|/*&n;&t;&t; * This is for checking whether an inode has changed w.r.t. a&n;&t;&t; * file so that the file can be updated if necessary (compare&n;&t;&t; * with f_version).&n;&t;&t; */
id|vi-&gt;i_version
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* The owner and group come from the ntfs volume. */
id|vi-&gt;i_uid
op_assign
id|vol-&gt;uid
suffix:semicolon
id|vi-&gt;i_gid
op_assign
id|vol-&gt;gid
suffix:semicolon
multiline_comment|/* Initialize the ntfs specific part of @vi. */
id|ntfs_init_big_inode
c_func
(paren
id|vi
)paren
suffix:semicolon
id|ni
op_assign
id|NTFS_I
c_func
(paren
id|vi
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Set the appropriate mode, attribute type, and name.  For&n;&t;&t; * directories, also setup the index values to the defaults.&n;&t;&t; */
r_if
c_cond
(paren
id|S_ISDIR
c_func
(paren
id|mode
)paren
)paren
(brace
id|vi-&gt;i_mode
op_assign
id|S_IFDIR
op_or
id|S_IRWXUGO
suffix:semicolon
id|vi-&gt;i_mode
op_and_assign
op_complement
id|vol-&gt;dmask
suffix:semicolon
id|NInoSetMstProtected
c_func
(paren
id|ni
)paren
suffix:semicolon
id|ni-&gt;type
op_assign
id|AT_INDEX_ALLOCATION
suffix:semicolon
id|ni-&gt;name
op_assign
id|I30
suffix:semicolon
id|ni-&gt;name_len
op_assign
l_int|4
suffix:semicolon
id|ni-&gt;itype.index.block_size
op_assign
l_int|4096
suffix:semicolon
id|ni-&gt;itype.index.block_size_bits
op_assign
id|generic_ffs
c_func
(paren
l_int|4096
)paren
op_minus
l_int|1
suffix:semicolon
id|ni-&gt;itype.index.collation_rule
op_assign
id|COLLATION_FILE_NAME
suffix:semicolon
r_if
c_cond
(paren
id|vol-&gt;cluster_size
op_le
id|ni-&gt;itype.index.block_size
)paren
(brace
id|ni-&gt;itype.index.vcn_size
op_assign
id|vol-&gt;cluster_size
suffix:semicolon
id|ni-&gt;itype.index.vcn_size_bits
op_assign
id|vol-&gt;cluster_size_bits
suffix:semicolon
)brace
r_else
(brace
id|ni-&gt;itype.index.vcn_size
op_assign
id|vol-&gt;sector_size
suffix:semicolon
id|ni-&gt;itype.index.vcn_size_bits
op_assign
id|vol-&gt;sector_size_bits
suffix:semicolon
)brace
)brace
r_else
(brace
id|vi-&gt;i_mode
op_assign
id|S_IFREG
op_or
id|S_IRWXUGO
suffix:semicolon
id|vi-&gt;i_mode
op_and_assign
op_complement
id|vol-&gt;fmask
suffix:semicolon
id|ni-&gt;type
op_assign
id|AT_DATA
suffix:semicolon
id|ni-&gt;name
op_assign
l_int|NULL
suffix:semicolon
id|ni-&gt;name_len
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|IS_RDONLY
c_func
(paren
id|vi
)paren
)paren
id|vi-&gt;i_mode
op_and_assign
op_complement
id|S_IWUGO
suffix:semicolon
multiline_comment|/* Set the inode times to the current time. */
id|vi-&gt;i_atime
op_assign
id|vi-&gt;i_mtime
op_assign
id|vi-&gt;i_ctime
op_assign
id|current_kernel_time
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Set the file size to 0, the ntfs inode sizes are set to 0 by&n;&t;&t; * the call to ntfs_init_big_inode() below.&n;&t;&t; */
id|vi-&gt;i_size
op_assign
l_int|0
suffix:semicolon
id|vi-&gt;i_blocks
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Set the sequence number. */
id|vi-&gt;i_generation
op_assign
id|ni-&gt;seq_no
op_assign
id|le16_to_cpu
c_func
(paren
id|m-&gt;sequence_number
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Manually map, pin, and lock the mft record as we already&n;&t;&t; * have its page mapped and it is very easy to do.&n;&t;&t; */
id|atomic_inc
c_func
(paren
op_amp
id|ni-&gt;count
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|ni-&gt;mrec_lock
)paren
suffix:semicolon
id|ni-&gt;page
op_assign
id|page
suffix:semicolon
id|ni-&gt;page_ofs
op_assign
id|ofs
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Make sure the allocated mft record is written out to disk.&n;&t;&t; * NOTE: We do not set the ntfs inode dirty because this would&n;&t;&t; * fail in ntfs_write_inode() because the inode does not have a&n;&t;&t; * standard information attribute yet.  Also, there is no need&n;&t;&t; * to set the inode dirty because the caller is going to do&n;&t;&t; * that anyway after finishing with the new mft record (e.g. at&n;&t;&t; * a minimum some new attributes will be added to the mft&n;&t;&t; * record.&n;&t;&t; */
id|mark_ntfs_record_dirty
c_func
(paren
id|page
comma
id|ofs
)paren
suffix:semicolon
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
multiline_comment|/* Add the inode to the inode hash for the superblock. */
id|insert_inode_hash
c_func
(paren
id|vi
)paren
suffix:semicolon
multiline_comment|/* Update the default mft allocation position. */
id|vol-&gt;mft_data_pos
op_assign
id|bit
op_plus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Return the opened, allocated inode of the allocated mft record as&n;&t; * well as the mapped, pinned, and locked mft record.&n;&t; */
id|ntfs_debug
c_func
(paren
l_string|&quot;Returning opened, allocated %sinode 0x%llx.&quot;
comma
id|base_ni
ques
c_cond
l_string|&quot;extent &quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
r_int
r_int
)paren
id|bit
)paren
suffix:semicolon
op_star
id|mrec
op_assign
id|m
suffix:semicolon
r_return
id|ni
suffix:semicolon
id|undo_data_init
suffix:colon
id|mft_ni-&gt;initialized_size
op_assign
id|old_data_initialized
suffix:semicolon
id|vol-&gt;mft_ino-&gt;i_size
op_assign
id|old_data_size
suffix:semicolon
r_goto
id|undo_mftbmp_alloc_nolock
suffix:semicolon
id|undo_mftbmp_alloc
suffix:colon
id|down_write
c_func
(paren
op_amp
id|vol-&gt;mftbmp_lock
)paren
suffix:semicolon
id|undo_mftbmp_alloc_nolock
suffix:colon
r_if
c_cond
(paren
id|ntfs_bitmap_clear_bit
c_func
(paren
id|vol-&gt;mftbmp_ino
comma
id|bit
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Failed to clear bit in mft bitmap.%s&quot;
comma
id|es
)paren
suffix:semicolon
id|NVolSetErrors
c_func
(paren
id|vol
)paren
suffix:semicolon
)brace
id|up_write
c_func
(paren
op_amp
id|vol-&gt;mftbmp_lock
)paren
suffix:semicolon
id|err_out
suffix:colon
r_return
id|ERR_PTR
c_func
(paren
id|err
)paren
suffix:semicolon
id|max_err_out
suffix:colon
id|ntfs_warning
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Cannot allocate mft record because the maximum &quot;
l_string|&quot;number of inodes (2^32) has already been reached.&quot;
)paren
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|vol-&gt;mftbmp_lock
)paren
suffix:semicolon
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|ENOSPC
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_extent_mft_record_free - free an extent mft record on an ntfs volume&n; * @ni:&t;&t;ntfs inode of the mapped extent mft record to free&n; * @m:&t;&t;mapped extent mft record of the ntfs inode @ni&n; *&n; * Free the mapped extent mft record @m of the extent ntfs inode @ni.&n; *&n; * Note that this function unmaps the mft record and closes and destroys @ni&n; * internally and hence you cannot use either @ni nor @m any more after this&n; * function returns success.&n; *&n; * On success return 0 and on error return -errno.  @ni and @m are still valid&n; * in this case and have not been freed.&n; *&n; * For some errors an error message is displayed and the success code 0 is&n; * returned and the volume is then left dirty on umount.  This makes sense in&n; * case we could not rollback the changes that were already done since the&n; * caller no longer wants to reference this mft record so it does not matter to&n; * the caller if something is wrong with it as long as it is properly detached&n; * from the base inode.&n; */
DECL|function|ntfs_extent_mft_record_free
r_int
id|ntfs_extent_mft_record_free
c_func
(paren
id|ntfs_inode
op_star
id|ni
comma
id|MFT_RECORD
op_star
id|m
)paren
(brace
r_int
r_int
id|mft_no
op_assign
id|ni-&gt;mft_no
suffix:semicolon
id|ntfs_volume
op_star
id|vol
op_assign
id|ni-&gt;vol
suffix:semicolon
id|ntfs_inode
op_star
id|base_ni
suffix:semicolon
id|ntfs_inode
op_star
op_star
id|extent_nis
suffix:semicolon
r_int
id|i
comma
id|err
suffix:semicolon
id|le16
id|old_seq_no
suffix:semicolon
id|u16
id|seq_no
suffix:semicolon
id|BUG_ON
c_func
(paren
id|NInoAttr
c_func
(paren
id|ni
)paren
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|ni-&gt;nr_extents
op_ne
op_minus
l_int|1
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|ni-&gt;extent_lock
)paren
suffix:semicolon
id|base_ni
op_assign
id|ni-&gt;ext.base_ntfs_ino
suffix:semicolon
id|up
c_func
(paren
op_amp
id|ni-&gt;extent_lock
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|base_ni-&gt;nr_extents
op_le
l_int|0
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Entering for extent inode 0x%lx, base inode 0x%lx.&bslash;n&quot;
comma
id|mft_no
comma
id|base_ni-&gt;mft_no
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|base_ni-&gt;extent_lock
)paren
suffix:semicolon
multiline_comment|/* Make sure we are holding the only reference to the extent inode. */
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|ni-&gt;count
)paren
OG
l_int|2
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Tried to free busy extent inode 0x%lx, &quot;
l_string|&quot;not freeing.&quot;
comma
id|base_ni-&gt;mft_no
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|base_ni-&gt;extent_lock
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
multiline_comment|/* Dissociate the ntfs inode from the base inode. */
id|extent_nis
op_assign
id|base_ni-&gt;ext.extent_ntfs_inos
suffix:semicolon
id|err
op_assign
op_minus
id|ENOENT
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|base_ni-&gt;nr_extents
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|ni
op_ne
id|extent_nis
(braket
id|i
)braket
)paren
r_continue
suffix:semicolon
id|extent_nis
op_add_assign
id|i
suffix:semicolon
id|base_ni-&gt;nr_extents
op_decrement
suffix:semicolon
id|memmove
c_func
(paren
id|extent_nis
comma
id|extent_nis
op_plus
l_int|1
comma
(paren
id|base_ni-&gt;nr_extents
op_minus
id|i
)paren
op_star
r_sizeof
(paren
id|ntfs_inode
op_star
)paren
)paren
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|base_ni-&gt;extent_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|err
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Extent inode 0x%lx is not attached to &quot;
l_string|&quot;its base inode 0x%lx.&quot;
comma
id|mft_no
comma
id|base_ni-&gt;mft_no
)paren
suffix:semicolon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * The extent inode is no longer attached to the base inode so no one&n;&t; * can get a reference to it any more.&n;&t; */
multiline_comment|/* Mark the mft record as not in use. */
id|m-&gt;flags
op_and_assign
id|const_cpu_to_le16
c_func
(paren
op_complement
id|const_le16_to_cpu
c_func
(paren
id|MFT_RECORD_IN_USE
)paren
)paren
suffix:semicolon
multiline_comment|/* Increment the sequence number, skipping zero, if it is not zero. */
id|old_seq_no
op_assign
id|m-&gt;sequence_number
suffix:semicolon
id|seq_no
op_assign
id|le16_to_cpu
c_func
(paren
id|old_seq_no
)paren
suffix:semicolon
r_if
c_cond
(paren
id|seq_no
op_eq
l_int|0xffff
)paren
id|seq_no
op_assign
l_int|1
suffix:semicolon
r_else
r_if
c_cond
(paren
id|seq_no
)paren
id|seq_no
op_increment
suffix:semicolon
id|m-&gt;sequence_number
op_assign
id|cpu_to_le16
c_func
(paren
id|seq_no
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Set the ntfs inode dirty and write it out.  We do not need to worry&n;&t; * about the base inode here since whatever caused the extent mft&n;&t; * record to be freed is guaranteed to do it already.&n;&t; */
id|NInoSetDirty
c_func
(paren
id|ni
)paren
suffix:semicolon
id|err
op_assign
id|write_mft_record
c_func
(paren
id|ni
comma
id|m
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|err
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Failed to write mft record 0x%lx, not &quot;
l_string|&quot;freeing.&quot;
comma
id|mft_no
)paren
suffix:semicolon
r_goto
id|rollback
suffix:semicolon
)brace
id|rollback_error
suffix:colon
multiline_comment|/* Unmap and throw away the now freed extent inode. */
id|unmap_extent_mft_record
c_func
(paren
id|ni
)paren
suffix:semicolon
id|ntfs_clear_extent_inode
c_func
(paren
id|ni
)paren
suffix:semicolon
multiline_comment|/* Clear the bit in the $MFT/$BITMAP corresponding to this record. */
id|down_write
c_func
(paren
op_amp
id|vol-&gt;mftbmp_lock
)paren
suffix:semicolon
id|err
op_assign
id|ntfs_bitmap_clear_bit
c_func
(paren
id|vol-&gt;mftbmp_ino
comma
id|mft_no
)paren
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|vol-&gt;mftbmp_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|err
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * The extent inode is gone but we failed to deallocate it in&n;&t;&t; * the mft bitmap.  Just emit a warning and leave the volume&n;&t;&t; * dirty on umount.&n;&t;&t; */
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Failed to clear bit in mft bitmap.%s&quot;
comma
id|es
)paren
suffix:semicolon
id|NVolSetErrors
c_func
(paren
id|vol
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
id|rollback
suffix:colon
multiline_comment|/* Rollback what we did... */
id|down
c_func
(paren
op_amp
id|base_ni-&gt;extent_lock
)paren
suffix:semicolon
id|extent_nis
op_assign
id|base_ni-&gt;ext.extent_ntfs_inos
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|base_ni-&gt;nr_extents
op_amp
l_int|3
)paren
)paren
(brace
r_int
id|new_size
op_assign
(paren
id|base_ni-&gt;nr_extents
op_plus
l_int|4
)paren
op_star
r_sizeof
(paren
id|ntfs_inode
op_star
)paren
suffix:semicolon
id|extent_nis
op_assign
(paren
id|ntfs_inode
op_star
op_star
)paren
id|kmalloc
c_func
(paren
id|new_size
comma
id|GFP_NOFS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|extent_nis
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Failed to allocate internal &quot;
l_string|&quot;buffer during rollback.%s&quot;
comma
id|es
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|base_ni-&gt;extent_lock
)paren
suffix:semicolon
id|NVolSetErrors
c_func
(paren
id|vol
)paren
suffix:semicolon
r_goto
id|rollback_error
suffix:semicolon
)brace
r_if
c_cond
(paren
id|base_ni-&gt;nr_extents
)paren
(brace
id|BUG_ON
c_func
(paren
op_logical_neg
id|base_ni-&gt;ext.extent_ntfs_inos
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|extent_nis
comma
id|base_ni-&gt;ext.extent_ntfs_inos
comma
id|new_size
op_minus
l_int|4
op_star
r_sizeof
(paren
id|ntfs_inode
op_star
)paren
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|base_ni-&gt;ext.extent_ntfs_inos
)paren
suffix:semicolon
)brace
id|base_ni-&gt;ext.extent_ntfs_inos
op_assign
id|extent_nis
suffix:semicolon
)brace
id|m-&gt;flags
op_or_assign
id|MFT_RECORD_IN_USE
suffix:semicolon
id|m-&gt;sequence_number
op_assign
id|old_seq_no
suffix:semicolon
id|extent_nis
(braket
id|base_ni-&gt;nr_extents
op_increment
)braket
op_assign
id|ni
suffix:semicolon
id|up
c_func
(paren
op_amp
id|base_ni-&gt;extent_lock
)paren
suffix:semicolon
id|mark_mft_record_dirty
c_func
(paren
id|ni
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
macro_line|#endif /* NTFS_RW */
eof
