multiline_comment|/**&n; * mft.c - NTFS kernel mft record operations. Part of the Linux-NTFS project.&n; *&n; * Copyright (c) 2001-2004 Anton Altaparmakov&n; * Copyright (c) 2002 Richard Russon&n; *&n; * This program/include file is free software; you can redistribute it and/or&n; * modify it under the terms of the GNU General Public License as published&n; * by the Free Software Foundation; either version 2 of the License, or&n; * (at your option) any later version.&n; *&n; * This program/include file is distributed in the hope that it will be&n; * useful, but WITHOUT ANY WARRANTY; without even the implied warranty&n; * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; * GNU General Public License for more details.&n; *&n; * You should have received a copy of the GNU General Public License&n; * along with this program (in the main directory of the Linux-NTFS&n; * distribution in the file COPYING); if not, write to the Free Software&n; * Foundation,Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA&n; */
macro_line|#include &lt;linux/buffer_head.h&gt;
macro_line|#include &lt;linux/swap.h&gt;
macro_line|#include &quot;attrib.h&quot;
macro_line|#include &quot;aops.h&quot;
macro_line|#include &quot;bitmap.h&quot;
macro_line|#include &quot;debug.h&quot;
macro_line|#include &quot;dir.h&quot;
macro_line|#include &quot;lcnalloc.h&quot;
macro_line|#include &quot;malloc.h&quot;
macro_line|#include &quot;mft.h&quot;
macro_line|#include &quot;ntfs.h&quot;
multiline_comment|/**&n; * map_mft_record_page - map the page in which a specific mft record resides&n; * @ni:&t;&t;ntfs inode whose mft record page to map&n; *&n; * This maps the page in which the mft record of the ntfs inode @ni is situated&n; * and returns a pointer to the mft record within the mapped page.&n; *&n; * Return value needs to be checked with IS_ERR() and if that is true PTR_ERR()&n; * contains the negative error code returned.&n; */
DECL|function|map_mft_record_page
r_static
r_inline
id|MFT_RECORD
op_star
id|map_mft_record_page
c_func
(paren
id|ntfs_inode
op_star
id|ni
)paren
(brace
id|ntfs_volume
op_star
id|vol
op_assign
id|ni-&gt;vol
suffix:semicolon
r_struct
id|inode
op_star
id|mft_vi
op_assign
id|vol-&gt;mft_ino
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
r_int
r_int
id|index
comma
id|ofs
comma
id|end_index
suffix:semicolon
id|BUG_ON
c_func
(paren
id|ni-&gt;page
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * The index into the page cache and the offset within the page cache&n;&t; * page of the wanted mft record. FIXME: We need to check for&n;&t; * overflowing the unsigned long, but I don&squot;t think we would ever get&n;&t; * here if the volume was that big...&n;&t; */
id|index
op_assign
id|ni-&gt;mft_no
op_lshift
id|vol-&gt;mft_record_size_bits
op_rshift
id|PAGE_CACHE_SHIFT
suffix:semicolon
id|ofs
op_assign
(paren
id|ni-&gt;mft_no
op_lshift
id|vol-&gt;mft_record_size_bits
)paren
op_amp
op_complement
id|PAGE_CACHE_MASK
suffix:semicolon
multiline_comment|/* The maximum valid index into the page cache for $MFT&squot;s data. */
id|end_index
op_assign
id|mft_vi-&gt;i_size
op_rshift
id|PAGE_CACHE_SHIFT
suffix:semicolon
multiline_comment|/* If the wanted index is out of bounds the mft record doesn&squot;t exist. */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|index
op_ge
id|end_index
)paren
)paren
(brace
r_if
c_cond
(paren
id|index
OG
id|end_index
op_logical_or
(paren
id|mft_vi-&gt;i_size
op_amp
op_complement
id|PAGE_CACHE_MASK
)paren
OL
id|ofs
op_plus
id|vol-&gt;mft_record_size
)paren
(brace
id|page
op_assign
id|ERR_PTR
c_func
(paren
op_minus
id|ENOENT
)paren
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
)brace
multiline_comment|/* Read, map, and pin the page. */
id|page
op_assign
id|ntfs_map_page
c_func
(paren
id|mft_vi-&gt;i_mapping
comma
id|index
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
op_logical_neg
id|IS_ERR
c_func
(paren
id|page
)paren
)paren
)paren
(brace
id|ni-&gt;page
op_assign
id|page
suffix:semicolon
id|ni-&gt;page_ofs
op_assign
id|ofs
suffix:semicolon
r_return
id|page_address
c_func
(paren
id|page
)paren
op_plus
id|ofs
suffix:semicolon
)brace
id|err_out
suffix:colon
id|ni-&gt;page
op_assign
l_int|NULL
suffix:semicolon
id|ni-&gt;page_ofs
op_assign
l_int|0
suffix:semicolon
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Failed with error code %lu.&quot;
comma
op_minus
id|PTR_ERR
c_func
(paren
id|page
)paren
)paren
suffix:semicolon
r_return
(paren
r_void
op_star
)paren
id|page
suffix:semicolon
)brace
multiline_comment|/**&n; * map_mft_record - map, pin and lock an mft record&n; * @ni:&t;&t;ntfs inode whose MFT record to map&n; *&n; * First, take the mrec_lock semaphore. We might now be sleeping, while waiting&n; * for the semaphore if it was already locked by someone else.&n; *&n; * The page of the record is mapped using map_mft_record_page() before being&n; * returned to the caller.&n; *&n; * This in turn uses ntfs_map_page() to get the page containing the wanted mft&n; * record (it in turn calls read_cache_page() which reads it in from disk if&n; * necessary, increments the use count on the page so that it cannot disappear&n; * under us and returns a reference to the page cache page).&n; *&n; * If read_cache_page() invokes ntfs_readpage() to load the page from disk, it&n; * sets PG_locked and clears PG_uptodate on the page. Once I/O has completed&n; * and the post-read mst fixups on each mft record in the page have been&n; * performed, the page gets PG_uptodate set and PG_locked cleared (this is done&n; * in our asynchronous I/O completion handler end_buffer_read_mft_async()).&n; * ntfs_map_page() waits for PG_locked to become clear and checks if&n; * PG_uptodate is set and returns an error code if not. This provides&n; * sufficient protection against races when reading/using the page.&n; *&n; * However there is the write mapping to think about. Doing the above described&n; * checking here will be fine, because when initiating the write we will set&n; * PG_locked and clear PG_uptodate making sure nobody is touching the page&n; * contents. Doing the locking this way means that the commit to disk code in&n; * the page cache code paths is automatically sufficiently locked with us as&n; * we will not touch a page that has been locked or is not uptodate. The only&n; * locking problem then is them locking the page while we are accessing it.&n; *&n; * So that code will end up having to own the mrec_lock of all mft&n; * records/inodes present in the page before I/O can proceed. In that case we&n; * wouldn&squot;t need to bother with PG_locked and PG_uptodate as nobody will be&n; * accessing anything without owning the mrec_lock semaphore. But we do need&n; * to use them because of the read_cache_page() invocation and the code becomes&n; * so much simpler this way that it is well worth it.&n; *&n; * The mft record is now ours and we return a pointer to it. You need to check&n; * the returned pointer with IS_ERR() and if that is true, PTR_ERR() will return&n; * the error code.&n; *&n; * NOTE: Caller is responsible for setting the mft record dirty before calling&n; * unmap_mft_record(). This is obviously only necessary if the caller really&n; * modified the mft record...&n; * Q: Do we want to recycle one of the VFS inode state bits instead?&n; * A: No, the inode ones mean we want to change the mft record, not we want to&n; * write it out.&n; */
DECL|function|map_mft_record
id|MFT_RECORD
op_star
id|map_mft_record
c_func
(paren
id|ntfs_inode
op_star
id|ni
)paren
(brace
id|MFT_RECORD
op_star
id|m
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Entering for mft_no 0x%lx.&quot;
comma
id|ni-&gt;mft_no
)paren
suffix:semicolon
multiline_comment|/* Make sure the ntfs inode doesn&squot;t go away. */
id|atomic_inc
c_func
(paren
op_amp
id|ni-&gt;count
)paren
suffix:semicolon
multiline_comment|/* Serialize access to this mft record. */
id|down
c_func
(paren
op_amp
id|ni-&gt;mrec_lock
)paren
suffix:semicolon
id|m
op_assign
id|map_mft_record_page
c_func
(paren
id|ni
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
op_logical_neg
id|IS_ERR
c_func
(paren
id|m
)paren
)paren
)paren
r_return
id|m
suffix:semicolon
id|up
c_func
(paren
op_amp
id|ni-&gt;mrec_lock
)paren
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|ni-&gt;count
)paren
suffix:semicolon
id|ntfs_error
c_func
(paren
id|ni-&gt;vol-&gt;sb
comma
l_string|&quot;Failed with error code %lu.&quot;
comma
op_minus
id|PTR_ERR
c_func
(paren
id|m
)paren
)paren
suffix:semicolon
r_return
id|m
suffix:semicolon
)brace
multiline_comment|/**&n; * unmap_mft_record_page - unmap the page in which a specific mft record resides&n; * @ni:&t;&t;ntfs inode whose mft record page to unmap&n; *&n; * This unmaps the page in which the mft record of the ntfs inode @ni is&n; * situated and returns. This is a NOOP if highmem is not configured.&n; *&n; * The unmap happens via ntfs_unmap_page() which in turn decrements the use&n; * count on the page thus releasing it from the pinned state.&n; *&n; * We do not actually unmap the page from memory of course, as that will be&n; * done by the page cache code itself when memory pressure increases or&n; * whatever.&n; */
DECL|function|unmap_mft_record_page
r_static
r_inline
r_void
id|unmap_mft_record_page
c_func
(paren
id|ntfs_inode
op_star
id|ni
)paren
(brace
id|BUG_ON
c_func
(paren
op_logical_neg
id|ni-&gt;page
)paren
suffix:semicolon
singleline_comment|// TODO: If dirty, blah...
id|ntfs_unmap_page
c_func
(paren
id|ni-&gt;page
)paren
suffix:semicolon
id|ni-&gt;page
op_assign
l_int|NULL
suffix:semicolon
id|ni-&gt;page_ofs
op_assign
l_int|0
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/**&n; * unmap_mft_record - release a mapped mft record&n; * @ni:&t;&t;ntfs inode whose MFT record to unmap&n; *&n; * We release the page mapping and the mrec_lock mutex which unmaps the mft&n; * record and releases it for others to get hold of. We also release the ntfs&n; * inode by decrementing the ntfs inode reference count.&n; *&n; * NOTE: If caller has modified the mft record, it is imperative to set the mft&n; * record dirty BEFORE calling unmap_mft_record().&n; */
DECL|function|unmap_mft_record
r_void
id|unmap_mft_record
c_func
(paren
id|ntfs_inode
op_star
id|ni
)paren
(brace
r_struct
id|page
op_star
id|page
op_assign
id|ni-&gt;page
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|page
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Entering for mft_no 0x%lx.&quot;
comma
id|ni-&gt;mft_no
)paren
suffix:semicolon
id|unmap_mft_record_page
c_func
(paren
id|ni
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|ni-&gt;mrec_lock
)paren
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|ni-&gt;count
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If pure ntfs_inode, i.e. no vfs inode attached, we leave it to&n;&t; * ntfs_clear_extent_inode() in the extent inode case, and to the&n;&t; * caller in the non-extent, yet pure ntfs inode case, to do the actual&n;&t; * tear down of all structures and freeing of all allocated memory.&n;&t; */
r_return
suffix:semicolon
)brace
multiline_comment|/**&n; * map_extent_mft_record - load an extent inode and attach it to its base&n; * @base_ni:&t;base ntfs inode&n; * @mref:&t;mft reference of the extent inode to load&n; * @ntfs_ino:&t;on successful return, pointer to the ntfs_inode structure&n; *&n; * Load the extent mft record @mref and attach it to its base inode @base_ni.&n; * Return the mapped extent mft record if IS_ERR(result) is false.  Otherwise&n; * PTR_ERR(result) gives the negative error code.&n; *&n; * On successful return, @ntfs_ino contains a pointer to the ntfs_inode&n; * structure of the mapped extent inode.&n; */
DECL|function|map_extent_mft_record
id|MFT_RECORD
op_star
id|map_extent_mft_record
c_func
(paren
id|ntfs_inode
op_star
id|base_ni
comma
id|MFT_REF
id|mref
comma
id|ntfs_inode
op_star
op_star
id|ntfs_ino
)paren
(brace
id|MFT_RECORD
op_star
id|m
suffix:semicolon
id|ntfs_inode
op_star
id|ni
op_assign
l_int|NULL
suffix:semicolon
id|ntfs_inode
op_star
op_star
id|extent_nis
op_assign
l_int|NULL
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
r_int
id|mft_no
op_assign
id|MREF
c_func
(paren
id|mref
)paren
suffix:semicolon
id|u16
id|seq_no
op_assign
id|MSEQNO
c_func
(paren
id|mref
)paren
suffix:semicolon
id|BOOL
id|destroy_ni
op_assign
id|FALSE
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Mapping extent mft record 0x%lx (base mft record 0x%lx).&quot;
comma
id|mft_no
comma
id|base_ni-&gt;mft_no
)paren
suffix:semicolon
multiline_comment|/* Make sure the base ntfs inode doesn&squot;t go away. */
id|atomic_inc
c_func
(paren
op_amp
id|base_ni-&gt;count
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Check if this extent inode has already been added to the base inode,&n;&t; * in which case just return it. If not found, add it to the base&n;&t; * inode before returning it.&n;&t; */
id|down
c_func
(paren
op_amp
id|base_ni-&gt;extent_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|base_ni-&gt;nr_extents
OG
l_int|0
)paren
(brace
id|extent_nis
op_assign
id|base_ni-&gt;ext.extent_ntfs_inos
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|base_ni-&gt;nr_extents
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|mft_no
op_ne
id|extent_nis
(braket
id|i
)braket
op_member_access_from_pointer
id|mft_no
)paren
r_continue
suffix:semicolon
id|ni
op_assign
id|extent_nis
(braket
id|i
)braket
suffix:semicolon
multiline_comment|/* Make sure the ntfs inode doesn&squot;t go away. */
id|atomic_inc
c_func
(paren
op_amp
id|ni-&gt;count
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|likely
c_func
(paren
id|ni
op_ne
l_int|NULL
)paren
)paren
(brace
id|up
c_func
(paren
op_amp
id|base_ni-&gt;extent_lock
)paren
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|base_ni-&gt;count
)paren
suffix:semicolon
multiline_comment|/* We found the record; just have to map and return it. */
id|m
op_assign
id|map_mft_record
c_func
(paren
id|ni
)paren
suffix:semicolon
multiline_comment|/* map_mft_record() has incremented this on success. */
id|atomic_dec
c_func
(paren
op_amp
id|ni-&gt;count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
op_logical_neg
id|IS_ERR
c_func
(paren
id|m
)paren
)paren
)paren
(brace
multiline_comment|/* Verify the sequence number. */
r_if
c_cond
(paren
id|likely
c_func
(paren
id|le16_to_cpu
c_func
(paren
id|m-&gt;sequence_number
)paren
op_eq
id|seq_no
)paren
)paren
(brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Done 1.&quot;
)paren
suffix:semicolon
op_star
id|ntfs_ino
op_assign
id|ni
suffix:semicolon
r_return
id|m
suffix:semicolon
)brace
id|unmap_mft_record
c_func
(paren
id|ni
)paren
suffix:semicolon
id|ntfs_error
c_func
(paren
id|base_ni-&gt;vol-&gt;sb
comma
l_string|&quot;Found stale extent mft &quot;
l_string|&quot;reference! Corrupt file system. &quot;
l_string|&quot;Run chkdsk.&quot;
)paren
suffix:semicolon
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|EIO
)paren
suffix:semicolon
)brace
id|map_err_out
suffix:colon
id|ntfs_error
c_func
(paren
id|base_ni-&gt;vol-&gt;sb
comma
l_string|&quot;Failed to map extent &quot;
l_string|&quot;mft record, error code %ld.&quot;
comma
op_minus
id|PTR_ERR
c_func
(paren
id|m
)paren
)paren
suffix:semicolon
r_return
id|m
suffix:semicolon
)brace
multiline_comment|/* Record wasn&squot;t there. Get a new ntfs inode and initialize it. */
id|ni
op_assign
id|ntfs_new_extent_inode
c_func
(paren
id|base_ni-&gt;vol-&gt;sb
comma
id|mft_no
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|ni
)paren
)paren
(brace
id|up
c_func
(paren
op_amp
id|base_ni-&gt;extent_lock
)paren
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|base_ni-&gt;count
)paren
suffix:semicolon
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
)brace
id|ni-&gt;vol
op_assign
id|base_ni-&gt;vol
suffix:semicolon
id|ni-&gt;seq_no
op_assign
id|seq_no
suffix:semicolon
id|ni-&gt;nr_extents
op_assign
op_minus
l_int|1
suffix:semicolon
id|ni-&gt;ext.base_ntfs_ino
op_assign
id|base_ni
suffix:semicolon
multiline_comment|/* Now map the record. */
id|m
op_assign
id|map_mft_record
c_func
(paren
id|ni
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|m
)paren
)paren
(brace
id|up
c_func
(paren
op_amp
id|base_ni-&gt;extent_lock
)paren
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|base_ni-&gt;count
)paren
suffix:semicolon
id|ntfs_clear_extent_inode
c_func
(paren
id|ni
)paren
suffix:semicolon
r_goto
id|map_err_out
suffix:semicolon
)brace
multiline_comment|/* Verify the sequence number. */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|le16_to_cpu
c_func
(paren
id|m-&gt;sequence_number
)paren
op_ne
id|seq_no
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|base_ni-&gt;vol-&gt;sb
comma
l_string|&quot;Found stale extent mft &quot;
l_string|&quot;reference! Corrupt file system. Run chkdsk.&quot;
)paren
suffix:semicolon
id|destroy_ni
op_assign
id|TRUE
suffix:semicolon
id|m
op_assign
id|ERR_PTR
c_func
(paren
op_minus
id|EIO
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
multiline_comment|/* Attach extent inode to base inode, reallocating memory if needed. */
r_if
c_cond
(paren
op_logical_neg
(paren
id|base_ni-&gt;nr_extents
op_amp
l_int|3
)paren
)paren
(brace
id|ntfs_inode
op_star
op_star
id|tmp
suffix:semicolon
r_int
id|new_size
op_assign
(paren
id|base_ni-&gt;nr_extents
op_plus
l_int|4
)paren
op_star
r_sizeof
(paren
id|ntfs_inode
op_star
)paren
suffix:semicolon
id|tmp
op_assign
(paren
id|ntfs_inode
op_star
op_star
)paren
id|kmalloc
c_func
(paren
id|new_size
comma
id|GFP_NOFS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|tmp
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|base_ni-&gt;vol-&gt;sb
comma
l_string|&quot;Failed to allocate &quot;
l_string|&quot;internal buffer.&quot;
)paren
suffix:semicolon
id|destroy_ni
op_assign
id|TRUE
suffix:semicolon
id|m
op_assign
id|ERR_PTR
c_func
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|base_ni-&gt;nr_extents
)paren
(brace
id|BUG_ON
c_func
(paren
op_logical_neg
id|base_ni-&gt;ext.extent_ntfs_inos
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|tmp
comma
id|base_ni-&gt;ext.extent_ntfs_inos
comma
id|new_size
op_minus
l_int|4
op_star
r_sizeof
(paren
id|ntfs_inode
op_star
)paren
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|base_ni-&gt;ext.extent_ntfs_inos
)paren
suffix:semicolon
)brace
id|base_ni-&gt;ext.extent_ntfs_inos
op_assign
id|tmp
suffix:semicolon
)brace
id|base_ni-&gt;ext.extent_ntfs_inos
(braket
id|base_ni-&gt;nr_extents
op_increment
)braket
op_assign
id|ni
suffix:semicolon
id|up
c_func
(paren
op_amp
id|base_ni-&gt;extent_lock
)paren
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|base_ni-&gt;count
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Done 2.&quot;
)paren
suffix:semicolon
op_star
id|ntfs_ino
op_assign
id|ni
suffix:semicolon
r_return
id|m
suffix:semicolon
id|unm_err_out
suffix:colon
id|unmap_mft_record
c_func
(paren
id|ni
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|base_ni-&gt;extent_lock
)paren
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|base_ni-&gt;count
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If the extent inode was not attached to the base inode we need to&n;&t; * release it or we will leak memory.&n;&t; */
r_if
c_cond
(paren
id|destroy_ni
)paren
id|ntfs_clear_extent_inode
c_func
(paren
id|ni
)paren
suffix:semicolon
r_return
id|m
suffix:semicolon
)brace
macro_line|#ifdef NTFS_RW
multiline_comment|/**&n; * __mark_mft_record_dirty - set the mft record and the page containing it dirty&n; * @ni:&t;&t;ntfs inode describing the mapped mft record&n; *&n; * Internal function.  Users should call mark_mft_record_dirty() instead.&n; *&n; * Set the mapped (extent) mft record of the (base or extent) ntfs inode @ni,&n; * as well as the page containing the mft record, dirty.  Also, mark the base&n; * vfs inode dirty.  This ensures that any changes to the mft record are&n; * written out to disk.&n; *&n; * NOTE:  We only set I_DIRTY_SYNC and I_DIRTY_DATASYNC (and not I_DIRTY_PAGES)&n; * on the base vfs inode, because even though file data may have been modified,&n; * it is dirty in the inode meta data rather than the data page cache of the&n; * inode, and thus there are no data pages that need writing out.  Therefore, a&n; * full mark_inode_dirty() is overkill.  A mark_inode_dirty_sync(), on the&n; * other hand, is not sufficient, because I_DIRTY_DATASYNC needs to be set to&n; * ensure -&gt;write_inode is called from generic_osync_inode() and this needs to&n; * happen or the file data would not necessarily hit the device synchronously,&n; * even though the vfs inode has the O_SYNC flag set.  Also, I_DIRTY_DATASYNC&n; * simply &quot;feels&quot; better than just I_DIRTY_SYNC, since the file data has not&n; * actually hit the block device yet, which is not what I_DIRTY_SYNC on its own&n; * would suggest.&n; */
DECL|function|__mark_mft_record_dirty
r_void
id|__mark_mft_record_dirty
c_func
(paren
id|ntfs_inode
op_star
id|ni
)paren
(brace
id|ntfs_inode
op_star
id|base_ni
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Entering for inode 0x%lx.&quot;
comma
id|ni-&gt;mft_no
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|NInoAttr
c_func
(paren
id|ni
)paren
)paren
suffix:semicolon
id|mark_ntfs_record_dirty
c_func
(paren
id|ni-&gt;page
comma
id|ni-&gt;page_ofs
)paren
suffix:semicolon
multiline_comment|/* Determine the base vfs inode and mark it dirty, too. */
id|down
c_func
(paren
op_amp
id|ni-&gt;extent_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
id|ni-&gt;nr_extents
op_ge
l_int|0
)paren
)paren
id|base_ni
op_assign
id|ni
suffix:semicolon
r_else
id|base_ni
op_assign
id|ni-&gt;ext.base_ntfs_ino
suffix:semicolon
id|up
c_func
(paren
op_amp
id|ni-&gt;extent_lock
)paren
suffix:semicolon
id|__mark_inode_dirty
c_func
(paren
id|VFS_I
c_func
(paren
id|base_ni
)paren
comma
id|I_DIRTY_SYNC
op_or
id|I_DIRTY_DATASYNC
)paren
suffix:semicolon
)brace
DECL|variable|ntfs_please_email
r_static
r_const
r_char
op_star
id|ntfs_please_email
op_assign
l_string|&quot;Please email &quot;
l_string|&quot;linux-ntfs-dev@lists.sourceforge.net and say that you saw &quot;
l_string|&quot;this message.  Thank you.&quot;
suffix:semicolon
multiline_comment|/**&n; * ntfs_sync_mft_mirror_umount - synchronise an mft record to the mft mirror&n; * @vol:&t;ntfs volume on which the mft record to synchronize resides&n; * @mft_no:&t;mft record number of mft record to synchronize&n; * @m:&t;&t;mapped, mst protected (extent) mft record to synchronize&n; *&n; * Write the mapped, mst protected (extent) mft record @m with mft record&n; * number @mft_no to the mft mirror ($MFTMirr) of the ntfs volume @vol,&n; * bypassing the page cache and the $MFTMirr inode itself.&n; *&n; * This function is only for use at umount time when the mft mirror inode has&n; * already been disposed off.  We BUG() if we are called while the mft mirror&n; * inode is still attached to the volume.&n; *&n; * On success return 0.  On error return -errno.&n; *&n; * NOTE:  This function is not implemented yet as I am not convinced it can&n; * actually be triggered considering the sequence of commits we do in super.c::&n; * ntfs_put_super().  But just in case we provide this place holder as the&n; * alternative would be either to BUG() or to get a NULL pointer dereference&n; * and Oops.&n; */
DECL|function|ntfs_sync_mft_mirror_umount
r_static
r_int
id|ntfs_sync_mft_mirror_umount
c_func
(paren
id|ntfs_volume
op_star
id|vol
comma
r_const
r_int
r_int
id|mft_no
comma
id|MFT_RECORD
op_star
id|m
)paren
(brace
id|BUG_ON
c_func
(paren
id|vol-&gt;mftmirr_ino
)paren
suffix:semicolon
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Umount time mft mirror syncing is not &quot;
l_string|&quot;implemented yet.  %s&quot;
comma
id|ntfs_please_email
)paren
suffix:semicolon
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_sync_mft_mirror - synchronize an mft record to the mft mirror&n; * @vol:&t;ntfs volume on which the mft record to synchronize resides&n; * @mft_no:&t;mft record number of mft record to synchronize&n; * @m:&t;&t;mapped, mst protected (extent) mft record to synchronize&n; * @sync:&t;if true, wait for i/o completion&n; *&n; * Write the mapped, mst protected (extent) mft record @m with mft record&n; * number @mft_no to the mft mirror ($MFTMirr) of the ntfs volume @vol.&n; *&n; * On success return 0.  On error return -errno and set the volume errors flag&n; * in the ntfs volume @vol.&n; *&n; * NOTE:  We always perform synchronous i/o and ignore the @sync parameter.&n; *&n; * TODO:  If @sync is false, want to do truly asynchronous i/o, i.e. just&n; * schedule i/o via -&gt;writepage or do it via kntfsd or whatever.&n; */
DECL|function|ntfs_sync_mft_mirror
r_int
id|ntfs_sync_mft_mirror
c_func
(paren
id|ntfs_volume
op_star
id|vol
comma
r_const
r_int
r_int
id|mft_no
comma
id|MFT_RECORD
op_star
id|m
comma
r_int
id|sync
)paren
(brace
r_struct
id|page
op_star
id|page
suffix:semicolon
r_int
r_int
id|blocksize
op_assign
id|vol-&gt;sb-&gt;s_blocksize
suffix:semicolon
r_int
id|max_bhs
op_assign
id|vol-&gt;mft_record_size
op_div
id|blocksize
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bhs
(braket
id|max_bhs
)braket
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
comma
op_star
id|head
suffix:semicolon
id|u8
op_star
id|kmirr
suffix:semicolon
r_int
r_int
id|block_start
comma
id|block_end
comma
id|m_start
comma
id|m_end
suffix:semicolon
r_int
id|i_bhs
comma
id|nr_bhs
comma
id|err
op_assign
l_int|0
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Entering for inode 0x%lx.&quot;
comma
id|mft_no
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|max_bhs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|vol-&gt;mftmirr_ino
)paren
)paren
(brace
multiline_comment|/* This could happen during umount... */
id|err
op_assign
id|ntfs_sync_mft_mirror_umount
c_func
(paren
id|vol
comma
id|mft_no
comma
id|m
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
op_logical_neg
id|err
)paren
)paren
r_return
id|err
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
multiline_comment|/* Get the page containing the mirror copy of the mft record @m. */
id|page
op_assign
id|ntfs_map_page
c_func
(paren
id|vol-&gt;mftmirr_ino-&gt;i_mapping
comma
id|mft_no
op_rshift
(paren
id|PAGE_CACHE_SHIFT
op_minus
id|vol-&gt;mft_record_size_bits
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|page
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Failed to map mft mirror page.&quot;
)paren
suffix:semicolon
id|err
op_assign
id|PTR_ERR
c_func
(paren
id|page
)paren
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Exclusion against other writers.   This should never be a problem&n;&t; * since the page in which the mft record @m resides is also locked and&n;&t; * hence any other writers would be held up there but it is better to&n;&t; * make sure no one is writing from elsewhere.&n;&t; */
id|lock_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|PageUptodate
c_func
(paren
id|page
)paren
)paren
suffix:semicolon
id|ClearPageUptodate
c_func
(paren
id|page
)paren
suffix:semicolon
multiline_comment|/* The address in the page of the mirror copy of the mft record @m. */
id|kmirr
op_assign
id|page_address
c_func
(paren
id|page
)paren
op_plus
(paren
(paren
id|mft_no
op_lshift
id|vol-&gt;mft_record_size_bits
)paren
op_amp
op_complement
id|PAGE_CACHE_MASK
)paren
suffix:semicolon
multiline_comment|/* Copy the mst protected mft record to the mirror. */
id|memcpy
c_func
(paren
id|kmirr
comma
id|m
comma
id|vol-&gt;mft_record_size
)paren
suffix:semicolon
multiline_comment|/* Make sure we have mapped buffers. */
id|BUG_ON
c_func
(paren
op_logical_neg
id|page_has_buffers
c_func
(paren
id|page
)paren
)paren
suffix:semicolon
id|bh
op_assign
id|head
op_assign
id|page_buffers
c_func
(paren
id|page
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|bh
)paren
suffix:semicolon
id|nr_bhs
op_assign
l_int|0
suffix:semicolon
id|block_start
op_assign
l_int|0
suffix:semicolon
id|m_start
op_assign
id|kmirr
op_minus
(paren
id|u8
op_star
)paren
id|page_address
c_func
(paren
id|page
)paren
suffix:semicolon
id|m_end
op_assign
id|m_start
op_plus
id|vol-&gt;mft_record_size
suffix:semicolon
r_do
(brace
id|block_end
op_assign
id|block_start
op_plus
id|blocksize
suffix:semicolon
multiline_comment|/* If the buffer is outside the mft record, skip it. */
r_if
c_cond
(paren
(paren
id|block_end
op_le
id|m_start
)paren
op_logical_or
(paren
id|block_start
op_ge
id|m_end
)paren
)paren
r_continue
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|buffer_mapped
c_func
(paren
id|bh
)paren
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|bh
)paren
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|nr_bhs
op_logical_and
(paren
id|m_start
op_ne
id|block_start
)paren
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|nr_bhs
op_ge
id|max_bhs
)paren
suffix:semicolon
id|bhs
(braket
id|nr_bhs
op_increment
)braket
op_assign
id|bh
suffix:semicolon
id|BUG_ON
c_func
(paren
(paren
id|nr_bhs
op_ge
id|max_bhs
)paren
op_logical_and
(paren
id|m_end
op_ne
id|block_end
)paren
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|block_start
op_assign
id|block_end
comma
(paren
id|bh
op_assign
id|bh-&gt;b_this_page
)paren
op_ne
id|head
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
op_logical_neg
id|err
)paren
)paren
(brace
multiline_comment|/* Lock buffers and start synchronous write i/o on them. */
r_for
c_loop
(paren
id|i_bhs
op_assign
l_int|0
suffix:semicolon
id|i_bhs
OL
id|nr_bhs
suffix:semicolon
id|i_bhs
op_increment
)paren
(brace
r_struct
id|buffer_head
op_star
id|tbh
op_assign
id|bhs
(braket
id|i_bhs
)braket
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|test_set_buffer_locked
c_func
(paren
id|tbh
)paren
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|tbh
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buffer_dirty
c_func
(paren
id|tbh
)paren
)paren
id|clear_buffer_dirty
c_func
(paren
id|tbh
)paren
suffix:semicolon
id|get_bh
c_func
(paren
id|tbh
)paren
suffix:semicolon
id|tbh-&gt;b_end_io
op_assign
id|end_buffer_write_sync
suffix:semicolon
id|submit_bh
c_func
(paren
id|WRITE
comma
id|tbh
)paren
suffix:semicolon
)brace
multiline_comment|/* Wait on i/o completion of buffers. */
r_for
c_loop
(paren
id|i_bhs
op_assign
l_int|0
suffix:semicolon
id|i_bhs
OL
id|nr_bhs
suffix:semicolon
id|i_bhs
op_increment
)paren
(brace
r_struct
id|buffer_head
op_star
id|tbh
op_assign
id|bhs
(braket
id|i_bhs
)braket
suffix:semicolon
id|wait_on_buffer
c_func
(paren
id|tbh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|tbh
)paren
)paren
)paren
(brace
id|err
op_assign
op_minus
id|EIO
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * Set the buffer uptodate so the page and&n;&t;&t;&t;&t; * buffer states do not become out of sync.&n;&t;&t;&t;&t; */
id|set_buffer_uptodate
c_func
(paren
id|tbh
)paren
suffix:semicolon
)brace
)brace
)brace
r_else
multiline_comment|/* if (unlikely(err)) */
(brace
multiline_comment|/* Clean the buffers. */
r_for
c_loop
(paren
id|i_bhs
op_assign
l_int|0
suffix:semicolon
id|i_bhs
OL
id|nr_bhs
suffix:semicolon
id|i_bhs
op_increment
)paren
id|clear_buffer_dirty
c_func
(paren
id|bhs
(braket
id|i_bhs
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/* Current state: all buffers are clean, unlocked, and uptodate. */
multiline_comment|/* Remove the mst protection fixups again. */
id|post_write_mst_fixup
c_func
(paren
(paren
id|NTFS_RECORD
op_star
)paren
id|kmirr
)paren
suffix:semicolon
id|flush_dcache_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|SetPageUptodate
c_func
(paren
id|page
)paren
suffix:semicolon
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|ntfs_unmap_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
op_logical_neg
id|err
)paren
)paren
(brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Done.&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;I/O error while writing mft mirror &quot;
l_string|&quot;record 0x%lx!&quot;
comma
id|mft_no
)paren
suffix:semicolon
id|err_out
suffix:colon
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Failed to synchronize $MFTMirr (error &quot;
l_string|&quot;code %i).  Volume will be left marked dirty &quot;
l_string|&quot;on umount.  Run ntfsfix on the partition &quot;
l_string|&quot;after umounting to correct this.&quot;
comma
op_minus
id|err
)paren
suffix:semicolon
id|NVolSetErrors
c_func
(paren
id|vol
)paren
suffix:semicolon
)brace
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/**&n; * write_mft_record_nolock - write out a mapped (extent) mft record&n; * @ni:&t;&t;ntfs inode describing the mapped (extent) mft record&n; * @m:&t;&t;mapped (extent) mft record to write&n; * @sync:&t;if true, wait for i/o completion&n; *&n; * Write the mapped (extent) mft record @m described by the (regular or extent)&n; * ntfs inode @ni to backing store.  If the mft record @m has a counterpart in&n; * the mft mirror, that is also updated.&n; *&n; * We only write the mft record if the ntfs inode @ni is dirty and the first&n; * buffer belonging to its mft record is dirty, too.  We ignore the dirty state&n; * of subsequent buffers because we could have raced with&n; * fs/ntfs/aops.c::mark_ntfs_record_dirty().&n; *&n; * On success, clean the mft record and return 0.  On error, leave the mft&n; * record dirty and return -errno.  The caller should call make_bad_inode() on&n; * the base inode to ensure no more access happens to this inode.  We do not do&n; * it here as the caller may want to finish writing other extent mft records&n; * first to minimize on-disk metadata inconsistencies.&n; *&n; * NOTE:  We always perform synchronous i/o and ignore the @sync parameter.&n; * However, if the mft record has a counterpart in the mft mirror and @sync is&n; * true, we write the mft record, wait for i/o completion, and only then write&n; * the mft mirror copy.  This ensures that if the system crashes either the mft&n; * or the mft mirror will contain a self-consistent mft record @m.  If @sync is&n; * false on the other hand, we start i/o on both and then wait for completion&n; * on them.  This provides a speedup but no longer guarantees that you will end&n; * up with a self-consistent mft record in the case of a crash but if you asked&n; * for asynchronous writing you probably do not care about that anyway.&n; *&n; * TODO:  If @sync is false, want to do truly asynchronous i/o, i.e. just&n; * schedule i/o via -&gt;writepage or do it via kntfsd or whatever.&n; */
DECL|function|write_mft_record_nolock
r_int
id|write_mft_record_nolock
c_func
(paren
id|ntfs_inode
op_star
id|ni
comma
id|MFT_RECORD
op_star
id|m
comma
r_int
id|sync
)paren
(brace
id|ntfs_volume
op_star
id|vol
op_assign
id|ni-&gt;vol
suffix:semicolon
r_struct
id|page
op_star
id|page
op_assign
id|ni-&gt;page
suffix:semicolon
r_int
r_int
id|blocksize
op_assign
id|vol-&gt;sb-&gt;s_blocksize
suffix:semicolon
r_int
id|max_bhs
op_assign
id|vol-&gt;mft_record_size
op_div
id|blocksize
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bhs
(braket
id|max_bhs
)braket
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
comma
op_star
id|head
suffix:semicolon
r_int
r_int
id|block_start
comma
id|block_end
comma
id|m_start
comma
id|m_end
suffix:semicolon
r_int
id|i_bhs
comma
id|nr_bhs
comma
id|err
op_assign
l_int|0
suffix:semicolon
id|BOOL
id|rec_is_dirty
op_assign
id|TRUE
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Entering for inode 0x%lx.&quot;
comma
id|ni-&gt;mft_no
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|NInoAttr
c_func
(paren
id|ni
)paren
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|max_bhs
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|PageLocked
c_func
(paren
id|page
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If the ntfs_inode is clean no need to do anything.  If it is dirty,&n;&t; * mark it as clean now so that it can be redirtied later on if needed.&n;&t; * There is no danger of races since the caller is holding the locks&n;&t; * for the mft record @m and the page it is in.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|NInoTestClearDirty
c_func
(paren
id|ni
)paren
)paren
r_goto
id|done
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|page_has_buffers
c_func
(paren
id|page
)paren
)paren
suffix:semicolon
id|bh
op_assign
id|head
op_assign
id|page_buffers
c_func
(paren
id|page
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|bh
)paren
suffix:semicolon
id|nr_bhs
op_assign
l_int|0
suffix:semicolon
id|block_start
op_assign
l_int|0
suffix:semicolon
id|m_start
op_assign
id|ni-&gt;page_ofs
suffix:semicolon
id|m_end
op_assign
id|m_start
op_plus
id|vol-&gt;mft_record_size
suffix:semicolon
r_do
(brace
id|block_end
op_assign
id|block_start
op_plus
id|blocksize
suffix:semicolon
multiline_comment|/* If the buffer is outside the mft record, skip it. */
r_if
c_cond
(paren
id|block_end
op_le
id|m_start
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|block_start
op_ge
id|m_end
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|block_start
op_eq
id|m_start
)paren
(brace
multiline_comment|/* This block is the first one in the record. */
r_if
c_cond
(paren
op_logical_neg
id|buffer_dirty
c_func
(paren
id|bh
)paren
)paren
(brace
multiline_comment|/* Clean records are not written out. */
id|rec_is_dirty
op_assign
id|FALSE
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|rec_is_dirty
op_assign
id|TRUE
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; * This block is not the first one in the record.  We&n;&t;&t;&t; * ignore the buffer&squot;s dirty state because we could&n;&t;&t;&t; * have raced with a parallel mark_ntfs_record_dirty().&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|rec_is_dirty
)paren
r_continue
suffix:semicolon
)brace
id|BUG_ON
c_func
(paren
op_logical_neg
id|buffer_mapped
c_func
(paren
id|bh
)paren
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|bh
)paren
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|nr_bhs
op_logical_and
(paren
id|m_start
op_ne
id|block_start
)paren
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|nr_bhs
op_ge
id|max_bhs
)paren
suffix:semicolon
id|bhs
(braket
id|nr_bhs
op_increment
)braket
op_assign
id|bh
suffix:semicolon
id|BUG_ON
c_func
(paren
(paren
id|nr_bhs
op_ge
id|max_bhs
)paren
op_logical_and
(paren
id|m_end
op_ne
id|block_end
)paren
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|block_start
op_assign
id|block_end
comma
(paren
id|bh
op_assign
id|bh-&gt;b_this_page
)paren
op_ne
id|head
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rec_is_dirty
)paren
r_goto
id|done
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|err
)paren
)paren
r_goto
id|cleanup_out
suffix:semicolon
multiline_comment|/* Apply the mst protection fixups. */
id|err
op_assign
id|pre_write_mst_fixup
c_func
(paren
(paren
id|NTFS_RECORD
op_star
)paren
id|m
comma
id|vol-&gt;mft_record_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Failed to apply mst fixups!&quot;
)paren
suffix:semicolon
r_goto
id|cleanup_out
suffix:semicolon
)brace
id|flush_dcache_mft_record_page
c_func
(paren
id|ni
)paren
suffix:semicolon
multiline_comment|/* Lock buffers and start synchronous write i/o on them. */
r_for
c_loop
(paren
id|i_bhs
op_assign
l_int|0
suffix:semicolon
id|i_bhs
OL
id|nr_bhs
suffix:semicolon
id|i_bhs
op_increment
)paren
(brace
r_struct
id|buffer_head
op_star
id|tbh
op_assign
id|bhs
(braket
id|i_bhs
)braket
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|test_set_buffer_locked
c_func
(paren
id|tbh
)paren
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|tbh
)paren
)paren
suffix:semicolon
id|clear_buffer_dirty
c_func
(paren
id|tbh
)paren
suffix:semicolon
id|get_bh
c_func
(paren
id|tbh
)paren
suffix:semicolon
id|tbh-&gt;b_end_io
op_assign
id|end_buffer_write_sync
suffix:semicolon
id|submit_bh
c_func
(paren
id|WRITE
comma
id|tbh
)paren
suffix:semicolon
)brace
multiline_comment|/* Synchronize the mft mirror now if not @sync. */
r_if
c_cond
(paren
op_logical_neg
id|sync
op_logical_and
id|ni-&gt;mft_no
OL
id|vol-&gt;mftmirr_size
)paren
id|ntfs_sync_mft_mirror
c_func
(paren
id|vol
comma
id|ni-&gt;mft_no
comma
id|m
comma
id|sync
)paren
suffix:semicolon
multiline_comment|/* Wait on i/o completion of buffers. */
r_for
c_loop
(paren
id|i_bhs
op_assign
l_int|0
suffix:semicolon
id|i_bhs
OL
id|nr_bhs
suffix:semicolon
id|i_bhs
op_increment
)paren
(brace
r_struct
id|buffer_head
op_star
id|tbh
op_assign
id|bhs
(braket
id|i_bhs
)braket
suffix:semicolon
id|wait_on_buffer
c_func
(paren
id|tbh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|tbh
)paren
)paren
)paren
(brace
id|err
op_assign
op_minus
id|EIO
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Set the buffer uptodate so the page and buffer&n;&t;&t;&t; * states do not become out of sync.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|PageUptodate
c_func
(paren
id|page
)paren
)paren
id|set_buffer_uptodate
c_func
(paren
id|tbh
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* If @sync, now synchronize the mft mirror. */
r_if
c_cond
(paren
id|sync
op_logical_and
id|ni-&gt;mft_no
OL
id|vol-&gt;mftmirr_size
)paren
id|ntfs_sync_mft_mirror
c_func
(paren
id|vol
comma
id|ni-&gt;mft_no
comma
id|m
comma
id|sync
)paren
suffix:semicolon
multiline_comment|/* Remove the mst protection fixups again. */
id|post_write_mst_fixup
c_func
(paren
(paren
id|NTFS_RECORD
op_star
)paren
id|m
)paren
suffix:semicolon
id|flush_dcache_mft_record_page
c_func
(paren
id|ni
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|err
)paren
)paren
(brace
multiline_comment|/* I/O error during writing.  This is really bad! */
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;I/O error while writing mft record &quot;
l_string|&quot;0x%lx!  Marking base inode as bad.  You &quot;
l_string|&quot;should unmount the volume and run chkdsk.&quot;
comma
id|ni-&gt;mft_no
)paren
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
id|done
suffix:colon
id|ntfs_debug
c_func
(paren
l_string|&quot;Done.&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|cleanup_out
suffix:colon
multiline_comment|/* Clean the buffers. */
r_for
c_loop
(paren
id|i_bhs
op_assign
l_int|0
suffix:semicolon
id|i_bhs
OL
id|nr_bhs
suffix:semicolon
id|i_bhs
op_increment
)paren
id|clear_buffer_dirty
c_func
(paren
id|bhs
(braket
id|i_bhs
)braket
)paren
suffix:semicolon
id|err_out
suffix:colon
multiline_comment|/*&n;&t; * Current state: all buffers are clean, unlocked, and uptodate.&n;&t; * The caller should mark the base inode as bad so that no more i/o&n;&t; * happens.  -&gt;clear_inode() will still be invoked so all extent inodes&n;&t; * and other allocated memory will be freed.&n;&t; */
r_if
c_cond
(paren
id|err
op_eq
op_minus
id|ENOMEM
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Not enough memory to write mft record.  &quot;
l_string|&quot;Redirtying so the write is retried later.&quot;
)paren
suffix:semicolon
id|mark_mft_record_dirty
c_func
(paren
id|ni
)paren
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_may_write_mft_record - check if an mft record may be written out&n; * @vol:&t;[IN]  ntfs volume on which the mft record to check resides&n; * @mft_no:&t;[IN]  mft record number of the mft record to check&n; * @m:&t;&t;[IN]  mapped mft record to check&n; * @locked_ni:&t;[OUT] caller has to unlock this ntfs inode if one is returned&n; *&n; * Check if the mapped (base or extent) mft record @m with mft record number&n; * @mft_no belonging to the ntfs volume @vol may be written out.  If necessary&n; * and possible the ntfs inode of the mft record is locked and the base vfs&n; * inode is pinned.  The locked ntfs inode is then returned in @locked_ni.  The&n; * caller is responsible for unlocking the ntfs inode and unpinning the base&n; * vfs inode.&n; *&n; * Return TRUE if the mft record may be written out and FALSE if not.&n; *&n; * The caller has locked the page and cleared the uptodate flag on it which&n; * means that we can safely write out any dirty mft records that do not have&n; * their inodes in icache as determined by ilookup5() as anyone&n; * opening/creating such an inode would block when attempting to map the mft&n; * record in read_cache_page() until we are finished with the write out.&n; *&n; * Here is a description of the tests we perform:&n; *&n; * If the inode is found in icache we know the mft record must be a base mft&n; * record.  If it is dirty, we do not write it and return FALSE as the vfs&n; * inode write paths will result in the access times being updated which would&n; * cause the base mft record to be redirtied and written out again.  (We know&n; * the access time update will modify the base mft record because Windows&n; * chkdsk complains if the standard information attribute is not in the base&n; * mft record.)&n; *&n; * If the inode is in icache and not dirty, we attempt to lock the mft record&n; * and if we find the lock was already taken, it is not safe to write the mft&n; * record and we return FALSE.&n; *&n; * If we manage to obtain the lock we have exclusive access to the mft record,&n; * which also allows us safe writeout of the mft record.  We then set&n; * @locked_ni to the locked ntfs inode and return TRUE.&n; *&n; * Note we cannot just lock the mft record and sleep while waiting for the lock&n; * because this would deadlock due to lock reversal (normally the mft record is&n; * locked before the page is locked but we already have the page locked here&n; * when we try to lock the mft record).&n; *&n; * If the inode is not in icache we need to perform further checks.&n; *&n; * If the mft record is not a FILE record or it is a base mft record, we can&n; * safely write it and return TRUE.&n; *&n; * We now know the mft record is an extent mft record.  We check if the inode&n; * corresponding to its base mft record is in icache and obtain a reference to&n; * it if it is.  If it is not, we can safely write it and return TRUE.&n; *&n; * We now have the base inode for the extent mft record.  We check if it has an&n; * ntfs inode for the extent mft record attached and if not it is safe to write&n; * the extent mft record and we return TRUE.&n; *&n; * The ntfs inode for the extent mft record is attached to the base inode so we&n; * attempt to lock the extent mft record and if we find the lock was already&n; * taken, it is not safe to write the extent mft record and we return FALSE.&n; *&n; * If we manage to obtain the lock we have exclusive access to the extent mft&n; * record, which also allows us safe writeout of the extent mft record.  We&n; * set the ntfs inode of the extent mft record clean and then set @locked_ni to&n; * the now locked ntfs inode and return TRUE.&n; *&n; * Note, the reason for actually writing dirty mft records here and not just&n; * relying on the vfs inode dirty code paths is that we can have mft records&n; * modified without them ever having actual inodes in memory.  Also we can have&n; * dirty mft records with clean ntfs inodes in memory.  None of the described&n; * cases would result in the dirty mft records being written out if we only&n; * relied on the vfs inode dirty code paths.  And these cases can really occur&n; * during allocation of new mft records and in particular when the&n; * initialized_size of the $MFT/$DATA attribute is extended and the new space&n; * is initialized using ntfs_mft_record_format().  The clean inode can then&n; * appear if the mft record is reused for a new inode before it got written&n; * out.&n; */
DECL|function|ntfs_may_write_mft_record
id|BOOL
id|ntfs_may_write_mft_record
c_func
(paren
id|ntfs_volume
op_star
id|vol
comma
r_const
r_int
r_int
id|mft_no
comma
r_const
id|MFT_RECORD
op_star
id|m
comma
id|ntfs_inode
op_star
op_star
id|locked_ni
)paren
(brace
r_struct
id|super_block
op_star
id|sb
op_assign
id|vol-&gt;sb
suffix:semicolon
r_struct
id|inode
op_star
id|mft_vi
op_assign
id|vol-&gt;mft_ino
suffix:semicolon
r_struct
id|inode
op_star
id|vi
suffix:semicolon
id|ntfs_inode
op_star
id|ni
comma
op_star
id|eni
comma
op_star
op_star
id|extent_nis
suffix:semicolon
r_int
id|i
suffix:semicolon
id|ntfs_attr
id|na
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Entering for inode 0x%lx.&quot;
comma
id|mft_no
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Normally we do not return a locked inode so set @locked_ni to NULL.&n;&t; */
id|BUG_ON
c_func
(paren
op_logical_neg
id|locked_ni
)paren
suffix:semicolon
op_star
id|locked_ni
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * Check if the inode corresponding to this mft record is in the VFS&n;&t; * inode cache and obtain a reference to it if it is.&n;&t; */
id|ntfs_debug
c_func
(paren
l_string|&quot;Looking for inode 0x%lx in icache.&quot;
comma
id|mft_no
)paren
suffix:semicolon
id|na.mft_no
op_assign
id|mft_no
suffix:semicolon
id|na.name
op_assign
l_int|NULL
suffix:semicolon
id|na.name_len
op_assign
l_int|0
suffix:semicolon
id|na.type
op_assign
id|AT_UNUSED
suffix:semicolon
multiline_comment|/*&n;&t; * For inode 0, i.e. $MFT itself, we cannot use ilookup5() from here or&n;&t; * we deadlock because the inode is already locked by the kernel&n;&t; * (fs/fs-writeback.c::__sync_single_inode()) and ilookup5() waits&n;&t; * until the inode is unlocked before returning it and it never gets&n;&t; * unlocked because ntfs_should_write_mft_record() never returns.  )-:&n;&t; * Fortunately, we have inode 0 pinned in icache for the duration of&n;&t; * the mount so we can access it directly.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|mft_no
)paren
(brace
multiline_comment|/* Balance the below iput(). */
id|vi
op_assign
id|igrab
c_func
(paren
id|mft_vi
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|vi
op_ne
id|mft_vi
)paren
suffix:semicolon
)brace
r_else
id|vi
op_assign
id|ilookup5
c_func
(paren
id|sb
comma
id|mft_no
comma
(paren
id|test_t
)paren
id|ntfs_test_inode
comma
op_amp
id|na
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vi
)paren
(brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Base inode 0x%lx is in icache.&quot;
comma
id|mft_no
)paren
suffix:semicolon
multiline_comment|/* The inode is in icache. */
id|ni
op_assign
id|NTFS_I
c_func
(paren
id|vi
)paren
suffix:semicolon
multiline_comment|/* Take a reference to the ntfs inode. */
id|atomic_inc
c_func
(paren
op_amp
id|ni-&gt;count
)paren
suffix:semicolon
multiline_comment|/* If the inode is dirty, do not write this record. */
r_if
c_cond
(paren
id|NInoDirty
c_func
(paren
id|ni
)paren
)paren
(brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Inode 0x%lx is dirty, do not write it.&quot;
comma
id|mft_no
)paren
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|ni-&gt;count
)paren
suffix:semicolon
id|iput
c_func
(paren
id|vi
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Inode 0x%lx is not dirty.&quot;
comma
id|mft_no
)paren
suffix:semicolon
multiline_comment|/* The inode is not dirty, try to take the mft record lock. */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|down_trylock
c_func
(paren
op_amp
id|ni-&gt;mrec_lock
)paren
)paren
)paren
(brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Mft record 0x%lx is already locked, do &quot;
l_string|&quot;not write it.&quot;
comma
id|mft_no
)paren
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|ni-&gt;count
)paren
suffix:semicolon
id|iput
c_func
(paren
id|vi
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Managed to lock mft record 0x%lx, write it.&quot;
comma
id|mft_no
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * The write has to occur while we hold the mft record lock so&n;&t;&t; * return the locked ntfs inode.&n;&t;&t; */
op_star
id|locked_ni
op_assign
id|ni
suffix:semicolon
r_return
id|TRUE
suffix:semicolon
)brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Inode 0x%lx is not in icache.&quot;
comma
id|mft_no
)paren
suffix:semicolon
multiline_comment|/* The inode is not in icache. */
multiline_comment|/* Write the record if it is not a mft record (type &quot;FILE&quot;). */
r_if
c_cond
(paren
op_logical_neg
id|ntfs_is_mft_record
c_func
(paren
id|m-&gt;magic
)paren
)paren
(brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Mft record 0x%lx is not a FILE record, write it.&quot;
comma
id|mft_no
)paren
suffix:semicolon
r_return
id|TRUE
suffix:semicolon
)brace
multiline_comment|/* Write the mft record if it is a base inode. */
r_if
c_cond
(paren
op_logical_neg
id|m-&gt;base_mft_record
)paren
(brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Mft record 0x%lx is a base record, write it.&quot;
comma
id|mft_no
)paren
suffix:semicolon
r_return
id|TRUE
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * This is an extent mft record.  Check if the inode corresponding to&n;&t; * its base mft record is in icache and obtain a reference to it if it&n;&t; * is.&n;&t; */
id|na.mft_no
op_assign
id|MREF_LE
c_func
(paren
id|m-&gt;base_mft_record
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Mft record 0x%lx is an extent record.  Looking for base &quot;
l_string|&quot;inode 0x%lx in icache.&quot;
comma
id|mft_no
comma
id|na.mft_no
)paren
suffix:semicolon
id|vi
op_assign
id|ilookup5
c_func
(paren
id|sb
comma
id|na.mft_no
comma
(paren
id|test_t
)paren
id|ntfs_test_inode
comma
op_amp
id|na
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vi
)paren
(brace
multiline_comment|/*&n;&t;&t; * The base inode is not in icache, write this extent mft&n;&t;&t; * record.&n;&t;&t; */
id|ntfs_debug
c_func
(paren
l_string|&quot;Base inode 0x%lx is not in icache, write the &quot;
l_string|&quot;extent record.&quot;
comma
id|na.mft_no
)paren
suffix:semicolon
r_return
id|TRUE
suffix:semicolon
)brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Base inode 0x%lx is in icache.&quot;
comma
id|na.mft_no
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * The base inode is in icache.  Check if it has the extent inode&n;&t; * corresponding to this extent mft record attached.&n;&t; */
id|ni
op_assign
id|NTFS_I
c_func
(paren
id|vi
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|ni-&gt;extent_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ni-&gt;nr_extents
op_le
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * The base inode has no attached extent inodes, write this&n;&t;&t; * extent mft record.&n;&t;&t; */
id|up
c_func
(paren
op_amp
id|ni-&gt;extent_lock
)paren
suffix:semicolon
id|iput
c_func
(paren
id|vi
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Base inode 0x%lx has no attached extent inodes, &quot;
l_string|&quot;write the extent record.&quot;
comma
id|na.mft_no
)paren
suffix:semicolon
r_return
id|TRUE
suffix:semicolon
)brace
multiline_comment|/* Iterate over the attached extent inodes. */
id|extent_nis
op_assign
id|ni-&gt;ext.extent_ntfs_inos
suffix:semicolon
r_for
c_loop
(paren
id|eni
op_assign
l_int|NULL
comma
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ni-&gt;nr_extents
suffix:semicolon
op_increment
id|i
)paren
(brace
r_if
c_cond
(paren
id|mft_no
op_eq
id|extent_nis
(braket
id|i
)braket
op_member_access_from_pointer
id|mft_no
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Found the extent inode corresponding to this extent&n;&t;&t;&t; * mft record.&n;&t;&t;&t; */
id|eni
op_assign
id|extent_nis
(braket
id|i
)braket
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * If the extent inode was not attached to the base inode, write this&n;&t; * extent mft record.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|eni
)paren
(brace
id|up
c_func
(paren
op_amp
id|ni-&gt;extent_lock
)paren
suffix:semicolon
id|iput
c_func
(paren
id|vi
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Extent inode 0x%lx is not attached to its base &quot;
l_string|&quot;inode 0x%lx, write the extent record.&quot;
comma
id|mft_no
comma
id|na.mft_no
)paren
suffix:semicolon
r_return
id|TRUE
suffix:semicolon
)brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Extent inode 0x%lx is attached to its base inode 0x%lx.&quot;
comma
id|mft_no
comma
id|na.mft_no
)paren
suffix:semicolon
multiline_comment|/* Take a reference to the extent ntfs inode. */
id|atomic_inc
c_func
(paren
op_amp
id|eni-&gt;count
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|ni-&gt;extent_lock
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Found the extent inode coresponding to this extent mft record.&n;&t; * Try to take the mft record lock.&n;&t; */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|down_trylock
c_func
(paren
op_amp
id|eni-&gt;mrec_lock
)paren
)paren
)paren
(brace
id|atomic_dec
c_func
(paren
op_amp
id|eni-&gt;count
)paren
suffix:semicolon
id|iput
c_func
(paren
id|vi
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Extent mft record 0x%lx is already locked, do &quot;
l_string|&quot;not write it.&quot;
comma
id|mft_no
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Managed to lock extent mft record 0x%lx, write it.&quot;
comma
id|mft_no
)paren
suffix:semicolon
r_if
c_cond
(paren
id|NInoTestClearDirty
c_func
(paren
id|eni
)paren
)paren
id|ntfs_debug
c_func
(paren
l_string|&quot;Extent inode 0x%lx is dirty, marking it clean.&quot;
comma
id|mft_no
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * The write has to occur while we hold the mft record lock so return&n;&t; * the locked extent ntfs inode.&n;&t; */
op_star
id|locked_ni
op_assign
id|eni
suffix:semicolon
r_return
id|TRUE
suffix:semicolon
)brace
DECL|variable|es
r_static
r_const
r_char
op_star
id|es
op_assign
l_string|&quot;  Leaving inconsistent metadata.  Unmount and run &quot;
l_string|&quot;chkdsk.&quot;
suffix:semicolon
multiline_comment|/**&n; * ntfs_extent_mft_record_free - free an extent mft record on an ntfs volume&n; * @ni:&t;&t;ntfs inode of the mapped extent mft record to free&n; * @m:&t;&t;mapped extent mft record of the ntfs inode @ni&n; *&n; * Free the mapped extent mft record @m of the extent ntfs inode @ni.&n; *&n; * Note that this function unmaps the mft record and closes and destroys @ni&n; * internally and hence you cannot use either @ni nor @m any more after this&n; * function returns success.&n; *&n; * On success return 0 and on error return -errno.  @ni and @m are still valid&n; * in this case and have not been freed.&n; *&n; * For some errors an error message is displayed and the success code 0 is&n; * returned and the volume is then left dirty on umount.  This makes sense in&n; * case we could not rollback the changes that were already done since the&n; * caller no longer wants to reference this mft record so it does not matter to&n; * the caller if something is wrong with it as long as it is properly detached&n; * from the base inode.&n; */
DECL|function|ntfs_extent_mft_record_free
r_int
id|ntfs_extent_mft_record_free
c_func
(paren
id|ntfs_inode
op_star
id|ni
comma
id|MFT_RECORD
op_star
id|m
)paren
(brace
r_int
r_int
id|mft_no
op_assign
id|ni-&gt;mft_no
suffix:semicolon
id|ntfs_volume
op_star
id|vol
op_assign
id|ni-&gt;vol
suffix:semicolon
id|ntfs_inode
op_star
id|base_ni
suffix:semicolon
id|ntfs_inode
op_star
op_star
id|extent_nis
suffix:semicolon
r_int
id|i
comma
id|err
suffix:semicolon
id|le16
id|old_seq_no
suffix:semicolon
id|u16
id|seq_no
suffix:semicolon
id|BUG_ON
c_func
(paren
id|NInoAttr
c_func
(paren
id|ni
)paren
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|ni-&gt;nr_extents
op_ne
op_minus
l_int|1
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|ni-&gt;extent_lock
)paren
suffix:semicolon
id|base_ni
op_assign
id|ni-&gt;ext.base_ntfs_ino
suffix:semicolon
id|up
c_func
(paren
op_amp
id|ni-&gt;extent_lock
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|base_ni-&gt;nr_extents
op_le
l_int|0
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Entering for extent inode 0x%lx, base inode 0x%lx.&bslash;n&quot;
comma
id|mft_no
comma
id|base_ni-&gt;mft_no
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|base_ni-&gt;extent_lock
)paren
suffix:semicolon
multiline_comment|/* Make sure we are holding the only reference to the extent inode. */
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|ni-&gt;count
)paren
OG
l_int|2
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Tried to free busy extent inode 0x%lx, &quot;
l_string|&quot;not freeing.&quot;
comma
id|base_ni-&gt;mft_no
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|base_ni-&gt;extent_lock
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
multiline_comment|/* Dissociate the ntfs inode from the base inode. */
id|extent_nis
op_assign
id|base_ni-&gt;ext.extent_ntfs_inos
suffix:semicolon
id|err
op_assign
op_minus
id|ENOENT
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|base_ni-&gt;nr_extents
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|ni
op_ne
id|extent_nis
(braket
id|i
)braket
)paren
r_continue
suffix:semicolon
id|extent_nis
op_add_assign
id|i
suffix:semicolon
id|base_ni-&gt;nr_extents
op_decrement
suffix:semicolon
id|memmove
c_func
(paren
id|extent_nis
comma
id|extent_nis
op_plus
l_int|1
comma
(paren
id|base_ni-&gt;nr_extents
op_minus
id|i
)paren
op_star
r_sizeof
(paren
id|ntfs_inode
op_star
)paren
)paren
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|base_ni-&gt;extent_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|err
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Extent inode 0x%lx is not attached to &quot;
l_string|&quot;its base inode 0x%lx.&quot;
comma
id|mft_no
comma
id|base_ni-&gt;mft_no
)paren
suffix:semicolon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * The extent inode is no longer attached to the base inode so no one&n;&t; * can get a reference to it any more.&n;&t; */
multiline_comment|/* Mark the mft record as not in use. */
id|m-&gt;flags
op_and_assign
id|const_cpu_to_le16
c_func
(paren
op_complement
id|const_le16_to_cpu
c_func
(paren
id|MFT_RECORD_IN_USE
)paren
)paren
suffix:semicolon
multiline_comment|/* Increment the sequence number, skipping zero, if it is not zero. */
id|old_seq_no
op_assign
id|m-&gt;sequence_number
suffix:semicolon
id|seq_no
op_assign
id|le16_to_cpu
c_func
(paren
id|old_seq_no
)paren
suffix:semicolon
r_if
c_cond
(paren
id|seq_no
op_eq
l_int|0xffff
)paren
id|seq_no
op_assign
l_int|1
suffix:semicolon
r_else
r_if
c_cond
(paren
id|seq_no
)paren
id|seq_no
op_increment
suffix:semicolon
id|m-&gt;sequence_number
op_assign
id|cpu_to_le16
c_func
(paren
id|seq_no
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Set the ntfs inode dirty and write it out.  We do not need to worry&n;&t; * about the base inode here since whatever caused the extent mft&n;&t; * record to be freed is guaranteed to do it already.&n;&t; */
id|NInoSetDirty
c_func
(paren
id|ni
)paren
suffix:semicolon
id|err
op_assign
id|write_mft_record
c_func
(paren
id|ni
comma
id|m
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|err
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Failed to write mft record 0x%lx, not &quot;
l_string|&quot;freeing.&quot;
comma
id|mft_no
)paren
suffix:semicolon
r_goto
id|rollback
suffix:semicolon
)brace
id|rollback_error
suffix:colon
multiline_comment|/* Unmap and throw away the now freed extent inode. */
id|unmap_extent_mft_record
c_func
(paren
id|ni
)paren
suffix:semicolon
id|ntfs_clear_extent_inode
c_func
(paren
id|ni
)paren
suffix:semicolon
multiline_comment|/* Clear the bit in the $MFT/$BITMAP corresponding to this record. */
id|down_write
c_func
(paren
op_amp
id|vol-&gt;mftbmp_lock
)paren
suffix:semicolon
id|err
op_assign
id|ntfs_bitmap_clear_bit
c_func
(paren
id|vol-&gt;mftbmp_ino
comma
id|mft_no
)paren
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|vol-&gt;mftbmp_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|err
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * The extent inode is gone but we failed to deallocate it in&n;&t;&t; * the mft bitmap.  Just emit a warning and leave the volume&n;&t;&t; * dirty on umount.&n;&t;&t; */
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Failed to clear bit in mft bitmap.%s&quot;
comma
id|es
)paren
suffix:semicolon
id|NVolSetErrors
c_func
(paren
id|vol
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
id|rollback
suffix:colon
multiline_comment|/* Rollback what we did... */
id|down
c_func
(paren
op_amp
id|base_ni-&gt;extent_lock
)paren
suffix:semicolon
id|extent_nis
op_assign
id|base_ni-&gt;ext.extent_ntfs_inos
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|base_ni-&gt;nr_extents
op_amp
l_int|3
)paren
)paren
(brace
r_int
id|new_size
op_assign
(paren
id|base_ni-&gt;nr_extents
op_plus
l_int|4
)paren
op_star
r_sizeof
(paren
id|ntfs_inode
op_star
)paren
suffix:semicolon
id|extent_nis
op_assign
(paren
id|ntfs_inode
op_star
op_star
)paren
id|kmalloc
c_func
(paren
id|new_size
comma
id|GFP_NOFS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|extent_nis
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Failed to allocate internal &quot;
l_string|&quot;buffer during rollback.%s&quot;
comma
id|es
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|base_ni-&gt;extent_lock
)paren
suffix:semicolon
id|NVolSetErrors
c_func
(paren
id|vol
)paren
suffix:semicolon
r_goto
id|rollback_error
suffix:semicolon
)brace
r_if
c_cond
(paren
id|base_ni-&gt;nr_extents
)paren
(brace
id|BUG_ON
c_func
(paren
op_logical_neg
id|base_ni-&gt;ext.extent_ntfs_inos
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|extent_nis
comma
id|base_ni-&gt;ext.extent_ntfs_inos
comma
id|new_size
op_minus
l_int|4
op_star
r_sizeof
(paren
id|ntfs_inode
op_star
)paren
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|base_ni-&gt;ext.extent_ntfs_inos
)paren
suffix:semicolon
)brace
id|base_ni-&gt;ext.extent_ntfs_inos
op_assign
id|extent_nis
suffix:semicolon
)brace
id|m-&gt;flags
op_or_assign
id|MFT_RECORD_IN_USE
suffix:semicolon
id|m-&gt;sequence_number
op_assign
id|old_seq_no
suffix:semicolon
id|extent_nis
(braket
id|base_ni-&gt;nr_extents
op_increment
)braket
op_assign
id|ni
suffix:semicolon
id|up
c_func
(paren
op_amp
id|base_ni-&gt;extent_lock
)paren
suffix:semicolon
id|mark_mft_record_dirty
c_func
(paren
id|ni
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
macro_line|#endif /* NTFS_RW */
eof
