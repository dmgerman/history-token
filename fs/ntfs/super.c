multiline_comment|/*&n; * super.c - NTFS kernel super block handling. Part of the Linux-NTFS project.&n; *&n; * Copyright (c) 2001,2002 Anton Altaparmakov.&n; * Copyright (C) 2001,2002 Richard Russon.&n; *&n; * This program/include file is free software; you can redistribute it and/or&n; * modify it under the terms of the GNU General Public License as published&n; * by the Free Software Foundation; either version 2 of the License, or&n; * (at your option) any later version.&n; *&n; * This program/include file is distributed in the hope that it will be &n; * useful, but WITHOUT ANY WARRANTY; without even the implied warranty &n; * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; * GNU General Public License for more details.&n; *&n; * You should have received a copy of the GNU General Public License&n; * along with this program (in the main directory of the Linux-NTFS &n; * distribution in the file COPYING); if not, write to the Free Software&n; * Foundation,Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA&n; */
macro_line|#include &lt;linux/stddef.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/locks.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/genhd.h&gt;&t;/* For gendisk stuff. */
macro_line|#include &lt;linux/blkdev.h&gt;&t;/* Fox get_hardsect_size. */
macro_line|#include &quot;ntfs.h&quot;
macro_line|#include &quot;sysctl.h&quot;
multiline_comment|/* Number of mounted file systems which have compression enabled. */
DECL|variable|ntfs_nr_compression_users
r_static
r_int
r_int
id|ntfs_nr_compression_users
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Error constants/strings used in inode.c::ntfs_show_options(). */
r_typedef
r_enum
(brace
DECL|enumerator|ON_ERRORS_PANIC
id|ON_ERRORS_PANIC
op_assign
l_int|0x01
comma
DECL|enumerator|ON_ERRORS_REMOUNT_RO
id|ON_ERRORS_REMOUNT_RO
op_assign
l_int|0x02
comma
DECL|enumerator|ON_ERRORS_CONTINUE
id|ON_ERRORS_CONTINUE
op_assign
l_int|0x04
comma
DECL|enumerator|ON_ERRORS_RECOVER
id|ON_ERRORS_RECOVER
op_assign
l_int|0x10
comma
DECL|typedef|ON_ERRORS_ACTIONS
)brace
id|ON_ERRORS_ACTIONS
suffix:semicolon
DECL|variable|on_errors_arr
r_const
id|option_t
id|on_errors_arr
(braket
)braket
op_assign
(brace
(brace
id|ON_ERRORS_PANIC
comma
l_string|&quot;panic&quot;
)brace
comma
(brace
id|ON_ERRORS_REMOUNT_RO
comma
l_string|&quot;remount-ro&quot;
comma
)brace
comma
(brace
id|ON_ERRORS_CONTINUE
comma
l_string|&quot;continue&quot;
comma
)brace
comma
(brace
id|ON_ERRORS_RECOVER
comma
l_string|&quot;recover&quot;
)brace
comma
(brace
id|ON_ERRORS_RECOVER
op_or
id|ON_ERRORS_PANIC
comma
l_string|&quot;recover_or_panic&quot;
)brace
comma
(brace
id|ON_ERRORS_RECOVER
op_or
id|ON_ERRORS_REMOUNT_RO
comma
l_string|&quot;recover_or_remount-ro&quot;
)brace
comma
(brace
id|ON_ERRORS_RECOVER
op_or
id|ON_ERRORS_CONTINUE
comma
l_string|&quot;recover_or_continue&quot;
)brace
comma
(brace
l_int|0
comma
l_int|NULL
)brace
)brace
suffix:semicolon
DECL|variable|readdir_opts_arr
r_static
r_const
id|option_t
id|readdir_opts_arr
(braket
)braket
op_assign
(brace
(brace
id|SHOW_SYSTEM
comma
l_string|&quot;system&quot;
)brace
comma
(brace
id|SHOW_WIN32
comma
l_string|&quot;win32&quot;
)brace
comma
(brace
id|SHOW_WIN32
comma
l_string|&quot;long&quot;
)brace
comma
(brace
id|SHOW_DOS
comma
l_string|&quot;dos&quot;
)brace
comma
(brace
id|SHOW_DOS
comma
l_string|&quot;short&quot;
)brace
comma
(brace
id|SHOW_POSIX
comma
l_string|&quot;posix&quot;
)brace
comma
(brace
id|SHOW_ALL
comma
l_string|&quot;all&quot;
)brace
comma
(brace
l_int|0
comma
l_int|NULL
)brace
)brace
suffix:semicolon
multiline_comment|/**&n; * simple_getbool -&n; *&n; * Copied from old ntfs driver (which copied from vfat driver).&n; */
DECL|function|simple_getbool
r_static
r_int
id|simple_getbool
c_func
(paren
r_char
op_star
id|s
comma
id|BOOL
op_star
id|setval
)paren
(brace
r_if
c_cond
(paren
id|s
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|s
comma
l_string|&quot;1&quot;
)paren
op_logical_or
op_logical_neg
id|strcmp
c_func
(paren
id|s
comma
l_string|&quot;yes&quot;
)paren
op_logical_or
op_logical_neg
id|strcmp
c_func
(paren
id|s
comma
l_string|&quot;true&quot;
)paren
)paren
op_star
id|setval
op_assign
id|TRUE
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|s
comma
l_string|&quot;0&quot;
)paren
op_logical_or
op_logical_neg
id|strcmp
c_func
(paren
id|s
comma
l_string|&quot;no&quot;
)paren
op_logical_or
op_logical_neg
id|strcmp
c_func
(paren
id|s
comma
l_string|&quot;false&quot;
)paren
)paren
op_star
id|setval
op_assign
id|FALSE
suffix:semicolon
r_else
r_return
l_int|0
suffix:semicolon
)brace
r_else
op_star
id|setval
op_assign
id|TRUE
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/**&n; * parse_options - parse the (re)mount options&n; * @vol:&t;ntfs volume&n; * @opt:&t;string containing the (re)mount options&n; *&n; * Parse the recognized options in @opt for the ntfs volume described by @vol.&n; */
DECL|function|parse_options
r_static
id|BOOL
id|parse_options
c_func
(paren
id|ntfs_volume
op_star
id|vol
comma
r_char
op_star
id|opt
)paren
(brace
r_char
op_star
id|p
comma
op_star
id|v
comma
op_star
id|ov
suffix:semicolon
r_static
r_char
op_star
id|utf8
op_assign
l_string|&quot;utf8&quot;
suffix:semicolon
r_int
id|errors
op_assign
l_int|0
comma
id|sloppy
op_assign
l_int|0
suffix:semicolon
id|uid_t
id|uid
op_assign
(paren
id|uid_t
)paren
op_minus
l_int|1
suffix:semicolon
id|gid_t
id|gid
op_assign
(paren
id|gid_t
)paren
op_minus
l_int|1
suffix:semicolon
id|mode_t
id|fmask
op_assign
(paren
id|mode_t
)paren
op_minus
l_int|1
comma
id|dmask
op_assign
(paren
id|mode_t
)paren
op_minus
l_int|1
suffix:semicolon
r_int
id|mft_zone_multiplier
op_assign
op_minus
l_int|1
comma
id|on_errors
op_assign
op_minus
l_int|1
comma
id|readdir_opts
op_assign
op_minus
l_int|1
suffix:semicolon
r_struct
id|nls_table
op_star
id|nls_map
op_assign
l_int|NULL
comma
op_star
id|old_nls
suffix:semicolon
multiline_comment|/* I am lazy... (-8 */
DECL|macro|NTFS_GETOPT_WITH_DEFAULT
mdefine_line|#define NTFS_GETOPT_WITH_DEFAULT(option, variable, default_value)&t;&bslash;&n;&t;if (!strcmp(p, option)) {&t;&t;&t;&t;&t;&bslash;&n;&t;&t;if (!v || !*v)&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;variable = default_value;&t;&t;&t;&bslash;&n;&t;&t;else {&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;variable = simple_strtoul(ov = v, &amp;v, 0);&t;&bslash;&n;&t;&t;&t;if (*v)&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;goto needs_val;&t;&t;&t;&t;&bslash;&n;&t;&t;}&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;} 
DECL|macro|NTFS_GETOPT
mdefine_line|#define NTFS_GETOPT(option, variable)&t;&t;&t;&t;&t;&bslash;&n;&t;if (!strcmp(p, option)) {&t;&t;&t;&t;&t;&bslash;&n;&t;&t;if (!v || !*v)&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;goto needs_arg;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;variable = simple_strtoul(ov = v, &amp;v, 0);&t;&t;&bslash;&n;&t;&t;if (*v)&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;goto needs_val;&t;&t;&t;&t;&t;&bslash;&n;&t;} 
DECL|macro|NTFS_GETOPT_OPTIONS_ARRAY
mdefine_line|#define NTFS_GETOPT_OPTIONS_ARRAY(option, variable, opt_array)&t;&t;&bslash;&n;&t;if (!strcmp(p, option)) {&t;&t;&t;&t;&t;&bslash;&n;&t;&t;int _i;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;if (!v || !*v)&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;goto needs_arg;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;ov = v;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;if (variable == -1)&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;variable = 0;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;for (_i = 0; opt_array[_i].str &amp;&amp; *opt_array[_i].str; _i++) &bslash;&n;&t;&t;&t;if (!strcmp(opt_array[_i].str, v)) {&t;&t;&bslash;&n;&t;&t;&t;&t;variable |= opt_array[_i].val;&t;&t;&bslash;&n;&t;&t;&t;&t;break;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;}&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;if (!opt_array[_i].str || !*opt_array[_i].str)&t;&t;&bslash;&n;&t;&t;&t;goto needs_val;&t;&t;&t;&t;&t;&bslash;&n;&t;}
r_if
c_cond
(paren
op_logical_neg
id|opt
op_logical_or
op_logical_neg
op_star
id|opt
)paren
r_goto
id|no_mount_options
suffix:semicolon
r_while
c_loop
(paren
(paren
id|p
op_assign
id|strsep
c_func
(paren
op_amp
id|opt
comma
l_string|&quot;,&quot;
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|v
op_assign
id|strchr
c_func
(paren
id|p
comma
l_char|&squot;=&squot;
)paren
)paren
)paren
op_star
id|v
op_increment
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|NTFS_GETOPT
c_func
(paren
l_string|&quot;uid&quot;
comma
id|uid
)paren
r_else
id|NTFS_GETOPT
c_func
(paren
l_string|&quot;gid&quot;
comma
id|gid
)paren
r_else
id|NTFS_GETOPT
c_func
(paren
l_string|&quot;umask&quot;
comma
id|fmask
op_assign
id|dmask
)paren
r_else
id|NTFS_GETOPT
c_func
(paren
l_string|&quot;fmask&quot;
comma
id|fmask
)paren
r_else
id|NTFS_GETOPT
c_func
(paren
l_string|&quot;dmask&quot;
comma
id|dmask
)paren
r_else
id|NTFS_GETOPT_WITH_DEFAULT
c_func
(paren
l_string|&quot;sloppy&quot;
comma
id|sloppy
comma
id|TRUE
)paren
r_else
id|NTFS_GETOPT
c_func
(paren
l_string|&quot;mft_zone_multiplier&quot;
comma
id|mft_zone_multiplier
)paren
r_else
id|NTFS_GETOPT_OPTIONS_ARRAY
c_func
(paren
l_string|&quot;errors&quot;
comma
id|on_errors
comma
id|on_errors_arr
)paren
r_else
id|NTFS_GETOPT_OPTIONS_ARRAY
c_func
(paren
l_string|&quot;show_inodes&quot;
comma
id|readdir_opts
comma
id|readdir_opts_arr
)paren
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|p
comma
l_string|&quot;show_system_files&quot;
)paren
)paren
(brace
id|BOOL
id|val
op_assign
id|FALSE
suffix:semicolon
id|ntfs_warning
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Option show_system_files is &quot;
l_string|&quot;deprecated. Please use option &quot;
l_string|&quot;show_inodes=system in the future.&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|v
op_logical_or
op_logical_neg
op_star
id|v
)paren
id|val
op_assign
id|TRUE
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|simple_getbool
c_func
(paren
id|v
comma
op_amp
id|val
)paren
)paren
r_goto
id|needs_bool
suffix:semicolon
r_if
c_cond
(paren
id|val
)paren
(brace
r_if
c_cond
(paren
id|readdir_opts
op_eq
op_minus
l_int|1
)paren
id|readdir_opts
op_assign
l_int|0
suffix:semicolon
id|readdir_opts
op_or_assign
id|SHOW_SYSTEM
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|p
comma
l_string|&quot;posix&quot;
)paren
)paren
(brace
id|BOOL
id|val
op_assign
id|FALSE
suffix:semicolon
id|ntfs_warning
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Option posix is deprecated. &quot;
l_string|&quot;Please use option show_inodes=posix &quot;
l_string|&quot;instead. Be aware that some userspace &quot;
l_string|&quot;applications may be confused by this, &quot;
l_string|&quot;since the short and long names of &quot;
l_string|&quot;directory inodes will have the same inode &quot;
l_string|&quot;numbers, yet each will only have a link &quot;
l_string|&quot;count of 1 due to Linux not supporting &quot;
l_string|&quot;directory hard links.&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|v
op_logical_or
op_logical_neg
op_star
id|v
)paren
r_goto
id|needs_arg
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|simple_getbool
c_func
(paren
id|v
comma
op_amp
id|val
)paren
)paren
r_goto
id|needs_bool
suffix:semicolon
r_if
c_cond
(paren
id|val
)paren
(brace
r_if
c_cond
(paren
id|readdir_opts
op_eq
op_minus
l_int|1
)paren
id|readdir_opts
op_assign
l_int|0
suffix:semicolon
id|readdir_opts
op_or_assign
id|SHOW_POSIX
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|p
comma
l_string|&quot;nls&quot;
)paren
op_logical_or
op_logical_neg
id|strcmp
c_func
(paren
id|p
comma
l_string|&quot;iocharset&quot;
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|p
comma
l_string|&quot;iocharset&quot;
)paren
)paren
id|ntfs_warning
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Option iocharset is &quot;
l_string|&quot;deprecated. Please use &quot;
l_string|&quot;option nls=&lt;charsetname&gt; in &quot;
l_string|&quot;the future.&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|v
op_logical_or
op_logical_neg
op_star
id|v
)paren
r_goto
id|needs_arg
suffix:semicolon
id|use_utf8
suffix:colon
id|old_nls
op_assign
id|nls_map
suffix:semicolon
id|nls_map
op_assign
id|load_nls
c_func
(paren
id|v
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|nls_map
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|old_nls
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;NLS character set &quot;
l_string|&quot;%s not found.&quot;
comma
id|v
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;NLS character set %s not &quot;
l_string|&quot;found. Using previous one %s.&quot;
comma
id|v
comma
id|old_nls-&gt;charset
)paren
suffix:semicolon
id|nls_map
op_assign
id|old_nls
suffix:semicolon
)brace
r_else
multiline_comment|/* nls_map */
(brace
r_if
c_cond
(paren
id|old_nls
)paren
id|unload_nls
c_func
(paren
id|old_nls
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|p
comma
l_string|&quot;utf8&quot;
)paren
)paren
(brace
id|BOOL
id|val
op_assign
id|FALSE
suffix:semicolon
id|ntfs_warning
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Option utf8 is no longer &quot;
l_string|&quot;supported, using option nls=utf8. Please &quot;
l_string|&quot;use option nls=utf8 in the future and &quot;
l_string|&quot;make sure utf8 is compiled either as a &quot;
l_string|&quot;module or into the kernel.&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|v
op_logical_or
op_logical_neg
op_star
id|v
)paren
id|val
op_assign
id|TRUE
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|simple_getbool
c_func
(paren
id|v
comma
op_amp
id|val
)paren
)paren
r_goto
id|needs_bool
suffix:semicolon
r_if
c_cond
(paren
id|val
)paren
(brace
id|v
op_assign
id|utf8
suffix:semicolon
r_goto
id|use_utf8
suffix:semicolon
)brace
)brace
r_else
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Unrecognized mount option %s.&quot;
comma
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
id|errors
OL
id|INT_MAX
)paren
id|errors
op_increment
suffix:semicolon
)brace
DECL|macro|NTFS_GETOPT_OPTIONS_ARRAY
macro_line|#undef NTFS_GETOPT_OPTIONS_ARRAY
DECL|macro|NTFS_GETOPT
macro_line|#undef NTFS_GETOPT
DECL|macro|NTFS_GETOPT_WITH_DEFAULT
macro_line|#undef NTFS_GETOPT_WITH_DEFAULT
)brace
id|no_mount_options
suffix:colon
r_if
c_cond
(paren
id|errors
op_logical_and
op_logical_neg
id|sloppy
)paren
r_return
id|FALSE
suffix:semicolon
r_if
c_cond
(paren
id|sloppy
)paren
id|ntfs_warning
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Sloppy option given. Ignoring &quot;
l_string|&quot;unrecognized mount option(s) and continuing.&quot;
)paren
suffix:semicolon
multiline_comment|/* Keep this first! */
r_if
c_cond
(paren
id|on_errors
op_ne
op_minus
l_int|1
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|on_errors
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Invalid errors option argument &quot;
l_string|&quot;or bug in options parser.&quot;
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|nls_map
)paren
(brace
r_if
c_cond
(paren
id|vol-&gt;nls_map
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Cannot change NLS character set &quot;
l_string|&quot;on remount.&quot;
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
multiline_comment|/* else (!vol-&gt;nls_map) */
id|ntfs_debug
c_func
(paren
l_string|&quot;Using NLS character set %s.&quot;
comma
id|nls_map-&gt;charset
)paren
suffix:semicolon
id|vol-&gt;nls_map
op_assign
id|nls_map
suffix:semicolon
)brace
r_else
multiline_comment|/* (!nls_map) */
(brace
r_if
c_cond
(paren
op_logical_neg
id|vol-&gt;nls_map
)paren
(brace
id|vol-&gt;nls_map
op_assign
id|load_nls_default
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vol-&gt;nls_map
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Failed to load default &quot;
l_string|&quot;NLS character set.&quot;
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Using default NLS character set (%s).&quot;
comma
id|vol-&gt;nls_map-&gt;charset
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|mft_zone_multiplier
op_ne
op_minus
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|vol-&gt;mft_zone_multiplier
op_logical_and
id|vol-&gt;mft_zone_multiplier
op_ne
id|mft_zone_multiplier
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Cannot change mft_zone_multiplier &quot;
l_string|&quot;on remount.&quot;
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mft_zone_multiplier
template_param
l_int|4
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Invalid mft_zone_multiplier. &quot;
l_string|&quot;Using default value, i.e. 1.&quot;
)paren
suffix:semicolon
id|mft_zone_multiplier
op_assign
l_int|1
suffix:semicolon
)brace
id|vol-&gt;mft_zone_multiplier
op_assign
id|mft_zone_multiplier
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|vol-&gt;mft_zone_multiplier
)paren
multiline_comment|/* Not specified and it is the first mount, so set default. */
id|vol-&gt;mft_zone_multiplier
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|on_errors
op_ne
op_minus
l_int|1
)paren
id|vol-&gt;on_errors
op_assign
id|on_errors
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vol-&gt;on_errors
)paren
id|vol-&gt;on_errors
op_assign
id|ON_ERRORS_CONTINUE
suffix:semicolon
r_if
c_cond
(paren
id|uid
op_ne
(paren
id|uid_t
)paren
op_minus
l_int|1
)paren
id|vol-&gt;uid
op_assign
id|uid
suffix:semicolon
r_if
c_cond
(paren
id|gid
op_ne
(paren
id|gid_t
)paren
op_minus
l_int|1
)paren
id|vol-&gt;gid
op_assign
id|gid
suffix:semicolon
r_if
c_cond
(paren
id|fmask
op_ne
(paren
id|mode_t
)paren
op_minus
l_int|1
)paren
id|vol-&gt;fmask
op_assign
id|fmask
suffix:semicolon
r_if
c_cond
(paren
id|dmask
op_ne
(paren
id|mode_t
)paren
op_minus
l_int|1
)paren
id|vol-&gt;dmask
op_assign
id|dmask
suffix:semicolon
r_if
c_cond
(paren
id|readdir_opts
op_ne
op_minus
l_int|1
)paren
id|vol-&gt;readdir_opts
op_assign
id|readdir_opts
suffix:semicolon
r_return
id|TRUE
suffix:semicolon
id|needs_arg
suffix:colon
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;The %s option requires an argument.&quot;
comma
id|p
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
id|needs_bool
suffix:colon
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;The %s option requires a boolean argument.&quot;
comma
id|p
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
id|needs_val
suffix:colon
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Invalid %s option argument: %s&quot;
comma
id|p
comma
id|ov
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_remount - change the mount options of a mounted ntfs filesystem&n; * @sb:&t;&t;superblock of mounted ntfs filesystem&n; * @flags:&t;remount flags&n; * @opt:&t;remount options string&n; *&n; * Change the mount options of an already mounted ntfs filesystem.&n; *&n; * NOTE: The VFS set the @sb-&gt;s_flags remount flags to @flags after&n; * ntfs_remount() returns successfully (i.e. returns 0). Otherwise,&n; * @sb-&gt;s_flags are not changed.&n; */
DECL|function|ntfs_remount
r_static
r_int
id|ntfs_remount
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_int
op_star
id|flags
comma
r_char
op_star
id|opt
)paren
(brace
id|ntfs_volume
op_star
id|vol
op_assign
id|NTFS_SB
c_func
(paren
id|sb
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Entering.&quot;
)paren
suffix:semicolon
singleline_comment|// FIXME/TODO: If left like this we will have problems with rw-&gt;ro and
singleline_comment|// ro-&gt;rw, as well as with sync-&gt;async and vice versa remounts.
singleline_comment|// Note: The VFS already checks that there are no pending deletes and
singleline_comment|// no open files for writing. So we only need to worry about dirty
singleline_comment|// inode pages and dirty system files (which include dirty inodes).
singleline_comment|// Either handle by flushing the whole volume NOW or by having the
singleline_comment|// write routines work on MS_RDONLY fs and guarantee we don&squot;t mark
singleline_comment|// anything as dirty if MS_RDONLY is set. That way the dirty data
singleline_comment|// would get flushed but no new dirty data would appear. This is
singleline_comment|// probably best but we need to be careful not to mark anything dirty
singleline_comment|// or the MS_RDONLY will be leaking writes.
singleline_comment|// TODO: Deal with *flags.
r_if
c_cond
(paren
op_logical_neg
id|parse_options
c_func
(paren
id|vol
comma
id|opt
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * is_boot_sector_ntfs - check whether a boot sector is a valid NTFS boot sector&n; * @sb:&t;&t;Super block of the device to which @b belongs.&n; * @b:&t;&t;Boot sector of device @sb to check.&n; * @silent:&t;If TRUE, all output will be silenced.&n; *&n; * is_boot_sector_ntfs() checks whether the boot sector @b is a valid NTFS boot&n; * sector. Returns TRUE if it is valid and FALSE if not.&n; *&n; * @sb is only needed for warning/error output, i.e. it can be NULL when silent&n; * is TRUE.&n; */
DECL|function|is_boot_sector_ntfs
r_static
id|BOOL
id|is_boot_sector_ntfs
c_func
(paren
r_const
r_struct
id|super_block
op_star
id|sb
comma
r_const
id|NTFS_BOOT_SECTOR
op_star
id|b
comma
r_const
id|BOOL
id|silent
)paren
(brace
multiline_comment|/*&n;&t; * Check that checksum == sum of u32 values from b to the checksum&n;&t; * field. If checksum is zero, no checking is done.&n;&t; */
r_if
c_cond
(paren
(paren
r_void
op_star
)paren
id|b
OL
(paren
r_void
op_star
)paren
op_amp
id|b-&gt;checksum
op_logical_and
id|b-&gt;checksum
)paren
(brace
id|u32
id|i
comma
op_star
id|u
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|u
op_assign
(paren
id|u32
op_star
)paren
id|b
suffix:semicolon
id|u
OL
(paren
id|u32
op_star
)paren
(paren
op_amp
id|b-&gt;checksum
)paren
suffix:semicolon
op_increment
id|u
)paren
id|i
op_add_assign
id|le32_to_cpup
c_func
(paren
id|u
)paren
suffix:semicolon
r_if
c_cond
(paren
id|le32_to_cpu
c_func
(paren
id|b-&gt;checksum
)paren
op_ne
id|i
)paren
r_goto
id|not_ntfs
suffix:semicolon
)brace
multiline_comment|/* Check OEMidentifier is &quot;NTFS    &quot; */
r_if
c_cond
(paren
id|b-&gt;oem_id
op_ne
id|magicNTFS
)paren
r_goto
id|not_ntfs
suffix:semicolon
multiline_comment|/* Check bytes per sector value is between 256 and 4096. */
r_if
c_cond
(paren
id|le16_to_cpu
c_func
(paren
id|b-&gt;bpb.bytes_per_sector
)paren
template_param
l_int|0x1000
)paren
r_goto
id|not_ntfs
suffix:semicolon
multiline_comment|/* Check sectors per cluster value is valid. */
r_switch
c_cond
(paren
id|b-&gt;bpb.sectors_per_cluster
)paren
(brace
r_case
l_int|1
suffix:colon
r_case
l_int|2
suffix:colon
r_case
l_int|4
suffix:colon
r_case
l_int|8
suffix:colon
r_case
l_int|16
suffix:colon
r_case
l_int|32
suffix:colon
r_case
l_int|64
suffix:colon
r_case
l_int|128
suffix:colon
r_break
suffix:semicolon
r_default
suffix:colon
r_goto
id|not_ntfs
suffix:semicolon
)brace
multiline_comment|/* Check the cluster size is not above 65536 bytes. */
r_if
c_cond
(paren
(paren
id|u32
)paren
id|le16_to_cpu
c_func
(paren
id|b-&gt;bpb.bytes_per_sector
)paren
op_star
id|b-&gt;bpb.sectors_per_cluster
OG
l_int|0x10000
)paren
r_goto
id|not_ntfs
suffix:semicolon
multiline_comment|/* Check reserved/unused fields are really zero. */
r_if
c_cond
(paren
id|le16_to_cpu
c_func
(paren
id|b-&gt;bpb.reserved_sectors
)paren
op_logical_or
id|le16_to_cpu
c_func
(paren
id|b-&gt;bpb.root_entries
)paren
op_logical_or
id|le16_to_cpu
c_func
(paren
id|b-&gt;bpb.sectors
)paren
op_logical_or
id|le16_to_cpu
c_func
(paren
id|b-&gt;bpb.sectors_per_fat
)paren
op_logical_or
id|le32_to_cpu
c_func
(paren
id|b-&gt;bpb.large_sectors
)paren
op_logical_or
id|b-&gt;bpb.fats
)paren
r_goto
id|not_ntfs
suffix:semicolon
multiline_comment|/* Check clusters per file mft record value is valid. */
r_if
c_cond
(paren
(paren
id|u8
)paren
id|b-&gt;clusters_per_mft_record
template_param
l_int|0xf7
)paren
r_switch
c_cond
(paren
id|b-&gt;clusters_per_mft_record
)paren
(brace
r_case
l_int|1
suffix:colon
r_case
l_int|2
suffix:colon
r_case
l_int|4
suffix:colon
r_case
l_int|8
suffix:colon
r_case
l_int|16
suffix:colon
r_case
l_int|32
suffix:colon
r_case
l_int|64
suffix:colon
r_break
suffix:semicolon
r_default
suffix:colon
r_goto
id|not_ntfs
suffix:semicolon
)brace
multiline_comment|/* Check clusters per index block value is valid. */
r_if
c_cond
(paren
(paren
id|u8
)paren
id|b-&gt;clusters_per_index_record
template_param
l_int|0xf7
)paren
r_switch
c_cond
(paren
id|b-&gt;clusters_per_index_record
)paren
(brace
r_case
l_int|1
suffix:colon
r_case
l_int|2
suffix:colon
r_case
l_int|4
suffix:colon
r_case
l_int|8
suffix:colon
r_case
l_int|16
suffix:colon
r_case
l_int|32
suffix:colon
r_case
l_int|64
suffix:colon
r_break
suffix:semicolon
r_default
suffix:colon
r_goto
id|not_ntfs
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Check for valid end of sector marker. We will work without it, but&n;&t; * many BIOSes will refuse to boot from a bootsector if the magic is&n;&t; * incorrect, so we emit a warning.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|silent
op_logical_and
id|b-&gt;end_of_sector_marker
op_ne
id|cpu_to_le16
c_func
(paren
l_int|0xaa55
)paren
)paren
id|ntfs_warning
c_func
(paren
id|sb
comma
l_string|&quot;Invalid end of sector marker.&quot;
)paren
suffix:semicolon
r_return
id|TRUE
suffix:semicolon
id|not_ntfs
suffix:colon
r_return
id|FALSE
suffix:semicolon
)brace
multiline_comment|/**&n; * read_boot_sector - read the NTFS boot sector of a device&n; * @sb:&t;&t;super block of device to read the boot sector from&n; * @silent:&t;if true, suppress all output&n; *&n; * Reads the boot sector from the device and validates it. If that fails, tries&n; * to read the backup boot sector, first from the end of the device a-la NT4 and&n; * later and then from the middle of the device a-la NT3.51 and before.&n; *&n; * If a valid boot sector is found but it is not the primary boot sector, we&n; * repair the primary boot sector silently (unless the device is read-only or&n; * the primary boot sector is not accessible).&n; *&n; * NOTE: To call this function, @sb must have the fields s_dev, the ntfs super&n; * block (u.ntfs_sb), nr_blocks and the device flags (s_flags) initialized&n; * to their respective values.&n; *&n; * Return the unlocked buffer head containing the boot sector or NULL on error.&n; */
DECL|function|read_ntfs_boot_sector
r_static
r_struct
id|buffer_head
op_star
id|read_ntfs_boot_sector
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_const
r_int
id|silent
)paren
(brace
r_const
r_char
op_star
id|read_err_str
op_assign
l_string|&quot;Unable to read %s boot sector.&quot;
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh_primary
comma
op_star
id|bh_backup
suffix:semicolon
r_int
id|nr_blocks
op_assign
id|NTFS_SB
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|nr_blocks
suffix:semicolon
multiline_comment|/* Try to read primary boot sector. */
r_if
c_cond
(paren
(paren
id|bh_primary
op_assign
id|sb_bread
c_func
(paren
id|sb
comma
l_int|0
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|is_boot_sector_ntfs
c_func
(paren
id|sb
comma
(paren
id|NTFS_BOOT_SECTOR
op_star
)paren
id|bh_primary-&gt;b_data
comma
id|silent
)paren
)paren
r_return
id|bh_primary
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|silent
)paren
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Primary boot sector is invalid.&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|silent
)paren
id|ntfs_error
c_func
(paren
id|sb
comma
id|read_err_str
comma
l_string|&quot;primary&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|NTFS_SB
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|on_errors
op_amp
op_complement
id|ON_ERRORS_RECOVER
)paren
(brace
r_if
c_cond
(paren
id|bh_primary
)paren
id|brelse
c_func
(paren
id|bh_primary
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|silent
)paren
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Mount option errors=recover not used. &quot;
l_string|&quot;Aborting without trying to recover.&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Try to read NT4+ backup boot sector. */
r_if
c_cond
(paren
(paren
id|bh_backup
op_assign
id|sb_bread
c_func
(paren
id|sb
comma
id|nr_blocks
op_minus
l_int|1
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|is_boot_sector_ntfs
c_func
(paren
id|sb
comma
(paren
id|NTFS_BOOT_SECTOR
op_star
)paren
id|bh_backup-&gt;b_data
comma
id|silent
)paren
)paren
r_goto
id|hotfix_primary_boot_sector
suffix:semicolon
id|brelse
c_func
(paren
id|bh_backup
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|silent
)paren
id|ntfs_error
c_func
(paren
id|sb
comma
id|read_err_str
comma
l_string|&quot;backup&quot;
)paren
suffix:semicolon
multiline_comment|/* Try to read NT3.51- backup boot sector. */
r_if
c_cond
(paren
(paren
id|bh_backup
op_assign
id|sb_bread
c_func
(paren
id|sb
comma
id|nr_blocks
op_rshift
l_int|1
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|is_boot_sector_ntfs
c_func
(paren
id|sb
comma
(paren
id|NTFS_BOOT_SECTOR
op_star
)paren
id|bh_backup-&gt;b_data
comma
id|silent
)paren
)paren
r_goto
id|hotfix_primary_boot_sector
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|silent
)paren
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Could not find a valid backup boot &quot;
l_string|&quot;sector.&quot;
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|bh_backup
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|silent
)paren
id|ntfs_error
c_func
(paren
id|sb
comma
id|read_err_str
comma
l_string|&quot;backup&quot;
)paren
suffix:semicolon
multiline_comment|/* We failed. Cleanup and return. */
r_if
c_cond
(paren
id|bh_primary
)paren
id|brelse
c_func
(paren
id|bh_primary
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
id|hotfix_primary_boot_sector
suffix:colon
r_if
c_cond
(paren
id|bh_primary
)paren
(brace
multiline_comment|/*&n;&t;&t; * If we managed to read sector zero and the volume is not&n;&t;&t; * read-only, copy the found, valid backup boot sector to the&n;&t;&t; * primary boot sector.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|sb-&gt;s_flags
op_amp
id|MS_RDONLY
)paren
)paren
(brace
id|ntfs_warning
c_func
(paren
id|sb
comma
l_string|&quot;Hot-fix: Recovering invalid primary &quot;
l_string|&quot;boot sector from backup copy.&quot;
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|bh_primary-&gt;b_data
comma
id|bh_backup-&gt;b_data
comma
id|sb-&gt;s_blocksize
)paren
suffix:semicolon
id|mark_buffer_dirty
c_func
(paren
id|bh_primary
)paren
suffix:semicolon
id|ll_rw_block
c_func
(paren
id|WRITE
comma
l_int|1
comma
op_amp
id|bh_primary
)paren
suffix:semicolon
id|wait_on_buffer
c_func
(paren
id|bh_primary
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buffer_uptodate
c_func
(paren
id|bh_primary
)paren
)paren
(brace
id|brelse
c_func
(paren
id|bh_backup
)paren
suffix:semicolon
r_return
id|bh_primary
suffix:semicolon
)brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Hot-fix: Device write error while &quot;
l_string|&quot;recovering primary boot sector.&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|ntfs_warning
c_func
(paren
id|sb
comma
l_string|&quot;Hot-fix: Recovery of primary boot &quot;
l_string|&quot;sector failed: Read-only mount.&quot;
)paren
suffix:semicolon
)brace
id|brelse
c_func
(paren
id|bh_primary
)paren
suffix:semicolon
)brace
id|ntfs_warning
c_func
(paren
id|sb
comma
l_string|&quot;Using backup boot sector.&quot;
)paren
suffix:semicolon
r_return
id|bh_backup
suffix:semicolon
)brace
multiline_comment|/**&n; * parse_ntfs_boot_sector - parse the boot sector and store the data in @vol&n; * @vol:&t;volume structure to initialise with data from boot sector&n; * @b:&t;&t;boot sector to parse&n; * &n; * Parse the ntfs boot sector @b and store all imporant information therein in&n; * the ntfs super block @vol. Return TRUE on success and FALSE on error.&n; */
DECL|function|parse_ntfs_boot_sector
r_static
id|BOOL
id|parse_ntfs_boot_sector
c_func
(paren
id|ntfs_volume
op_star
id|vol
comma
r_const
id|NTFS_BOOT_SECTOR
op_star
id|b
)paren
(brace
r_int
r_int
id|sectors_per_cluster_bits
comma
id|nr_hidden_sects
suffix:semicolon
r_int
id|clusters_per_mft_record
comma
id|clusters_per_index_record
suffix:semicolon
id|s64
id|ll
suffix:semicolon
id|vol-&gt;sector_size
op_assign
id|le16_to_cpu
c_func
(paren
id|b-&gt;bpb.bytes_per_sector
)paren
suffix:semicolon
id|vol-&gt;sector_size_bits
op_assign
id|ffs
c_func
(paren
id|vol-&gt;sector_size
)paren
op_minus
l_int|1
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;vol-&gt;sector_size = %i (0x%x)&quot;
comma
id|vol-&gt;sector_size
comma
id|vol-&gt;sector_size
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;vol-&gt;sector_size_bits = %i (0x%x)&quot;
comma
id|vol-&gt;sector_size_bits
comma
id|vol-&gt;sector_size_bits
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vol-&gt;sector_size
op_ne
id|vol-&gt;sb-&gt;s_blocksize
)paren
id|ntfs_warning
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;The boot sector indicates a sector size &quot;
l_string|&quot;different from the device sector size.&quot;
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;sectors_per_cluster = 0x%x&quot;
comma
id|b-&gt;bpb.sectors_per_cluster
)paren
suffix:semicolon
id|sectors_per_cluster_bits
op_assign
id|ffs
c_func
(paren
id|b-&gt;bpb.sectors_per_cluster
)paren
op_minus
l_int|1
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;sectors_per_cluster_bits = 0x%x&quot;
comma
id|sectors_per_cluster_bits
)paren
suffix:semicolon
id|nr_hidden_sects
op_assign
id|le32_to_cpu
c_func
(paren
id|b-&gt;bpb.hidden_sectors
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;number of hidden sectors = 0x%x&quot;
comma
id|nr_hidden_sects
)paren
suffix:semicolon
id|vol-&gt;cluster_size
op_assign
id|vol-&gt;sector_size
op_lshift
id|sectors_per_cluster_bits
suffix:semicolon
id|vol-&gt;cluster_size_mask
op_assign
id|vol-&gt;cluster_size
op_minus
l_int|1
suffix:semicolon
id|vol-&gt;cluster_size_bits
op_assign
id|ffs
c_func
(paren
id|vol-&gt;cluster_size
)paren
op_minus
l_int|1
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;vol-&gt;cluster_size = %i (0x%x)&quot;
comma
id|vol-&gt;cluster_size
comma
id|vol-&gt;cluster_size
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;vol-&gt;cluster_size_mask = 0x%x&quot;
comma
id|vol-&gt;cluster_size_mask
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;vol-&gt;cluster_size_bits = %i (0x%x)&quot;
comma
id|vol-&gt;cluster_size_bits
comma
id|vol-&gt;cluster_size_bits
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vol-&gt;sector_size
OG
id|vol-&gt;cluster_size
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Sector sizes above the cluster size are &quot;
l_string|&quot;not supported. Sorry.&quot;
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|vol-&gt;sb-&gt;s_blocksize
OG
id|vol-&gt;cluster_size
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Cluster sizes smaller than the device &quot;
l_string|&quot;sector size are not supported. Sorry.&quot;
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
id|clusters_per_mft_record
op_assign
id|b-&gt;clusters_per_mft_record
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;clusters_per_mft_record = %i (0x%x)&quot;
comma
id|clusters_per_mft_record
comma
id|clusters_per_mft_record
)paren
suffix:semicolon
r_if
c_cond
(paren
id|clusters_per_mft_record
OG
l_int|0
)paren
id|vol-&gt;mft_record_size
op_assign
id|vol-&gt;cluster_size
op_lshift
(paren
id|ffs
c_func
(paren
id|clusters_per_mft_record
)paren
op_minus
l_int|1
)paren
suffix:semicolon
r_else
multiline_comment|/*&n;&t;&t; * When mft_record_size &lt; cluster_size, clusters_per_mft_record&n;&t;&t; * = -log2(mft_record_size) bytes. mft_record_size normaly is&n;&t;&t; * 1024 bytes, which is encoded as 0xF6 (-10 in decimal).&n;&t;&t; */
id|vol-&gt;mft_record_size
op_assign
l_int|1
op_lshift
op_minus
id|clusters_per_mft_record
suffix:semicolon
id|vol-&gt;mft_record_size_mask
op_assign
id|vol-&gt;mft_record_size
op_minus
l_int|1
suffix:semicolon
id|vol-&gt;mft_record_size_bits
op_assign
id|ffs
c_func
(paren
id|vol-&gt;mft_record_size
)paren
op_minus
l_int|1
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;vol-&gt;mft_record_size = %i (0x%x)&quot;
comma
id|vol-&gt;mft_record_size
comma
id|vol-&gt;mft_record_size
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;vol-&gt;mft_record_size_mask = 0x%x&quot;
comma
id|vol-&gt;mft_record_size_mask
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;vol-&gt;mft_record_size_bits = %i (0x%x)&quot;
comma
id|vol-&gt;mft_record_size_bits
comma
id|vol-&gt;mft_record_size_bits
)paren
suffix:semicolon
id|clusters_per_index_record
op_assign
id|b-&gt;clusters_per_index_record
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;clusters_per_index_record = %i (0x%x)&quot;
comma
id|clusters_per_index_record
comma
id|clusters_per_index_record
)paren
suffix:semicolon
r_if
c_cond
(paren
id|clusters_per_index_record
OG
l_int|0
)paren
id|vol-&gt;index_record_size
op_assign
id|vol-&gt;cluster_size
op_lshift
(paren
id|ffs
c_func
(paren
id|clusters_per_index_record
)paren
op_minus
l_int|1
)paren
suffix:semicolon
r_else
multiline_comment|/*&n;&t;&t; * When index_record_size &lt; cluster_size,&n;&t;&t; * clusters_per_index_record = -log2(index_record_size) bytes.&n;&t;&t; * index_record_size normaly equals 4096 bytes, which is&n;&t;&t; * encoded as 0xF4 (-12 in decimal).&n;&t;&t; */
id|vol-&gt;index_record_size
op_assign
l_int|1
op_lshift
op_minus
id|clusters_per_index_record
suffix:semicolon
id|vol-&gt;index_record_size_mask
op_assign
id|vol-&gt;index_record_size
op_minus
l_int|1
suffix:semicolon
id|vol-&gt;index_record_size_bits
op_assign
id|ffs
c_func
(paren
id|vol-&gt;index_record_size
)paren
op_minus
l_int|1
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;vol-&gt;index_record_size = %i (0x%x)&quot;
comma
id|vol-&gt;index_record_size
comma
id|vol-&gt;index_record_size
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;vol-&gt;index_record_size_mask = 0x%x&quot;
comma
id|vol-&gt;index_record_size_mask
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;vol-&gt;index_record_size_bits = %i (0x%x)&quot;
comma
id|vol-&gt;index_record_size_bits
comma
id|vol-&gt;index_record_size_bits
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Get the size of the volume in clusters and check for 64-bit-ness.&n;&t; * Windows currently only uses 32 bits to save the clusters so we do&n;&t; * the same as it is much faster on 32-bit CPUs.&n;&t; */
id|ll
op_assign
id|sle64_to_cpu
c_func
(paren
id|b-&gt;number_of_sectors
)paren
op_rshift
id|sectors_per_cluster_bits
suffix:semicolon
r_if
c_cond
(paren
(paren
id|u64
)paren
id|ll
op_ge
l_int|1ULL
op_lshift
(paren
r_sizeof
(paren
r_int
r_int
)paren
op_star
l_int|8
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Cannot handle %i-bit clusters. Sorry.&quot;
comma
r_sizeof
(paren
r_int
r_int
)paren
op_star
l_int|4
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
id|vol
op_member_access_from_pointer
id|_VCL
c_func
(paren
id|nr_clusters
)paren
op_assign
id|ll
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;vol-&gt;nr_clusters = 0x%Lx&quot;
comma
(paren
r_int
r_int
)paren
id|vol
op_member_access_from_pointer
id|_VCL
c_func
(paren
id|nr_clusters
)paren
)paren
suffix:semicolon
id|ll
op_assign
id|sle64_to_cpu
c_func
(paren
id|b-&gt;mft_lcn
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ll
op_ge
id|vol
op_member_access_from_pointer
id|_VCL
c_func
(paren
id|nr_clusters
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;MFT LCN is beyond end of volume. Weird.&quot;
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
id|vol-&gt;mft_lcn
op_assign
id|ll
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;vol-&gt;mft_lcn = 0x%Lx&quot;
comma
(paren
r_int
r_int
)paren
id|vol-&gt;mft_lcn
)paren
suffix:semicolon
id|ll
op_assign
id|sle64_to_cpu
c_func
(paren
id|b-&gt;mftmirr_lcn
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ll
op_ge
id|vol
op_member_access_from_pointer
id|_VCL
c_func
(paren
id|nr_clusters
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;MFTMirr LCN is beyond end of volume. &quot;
l_string|&quot;Weird.&quot;
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
id|vol-&gt;mftmirr_lcn
op_assign
id|ll
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;vol-&gt;mftmirr_lcn = 0x%Lx&quot;
comma
(paren
r_int
r_int
)paren
id|vol-&gt;mftmirr_lcn
)paren
suffix:semicolon
id|vol-&gt;serial_no
op_assign
id|le64_to_cpu
c_func
(paren
id|b-&gt;volume_serial_number
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;vol-&gt;serial_no = 0x%Lx&quot;
comma
(paren
r_int
r_int
r_int
)paren
id|vol-&gt;serial_no
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Determine MFT zone size. This is not strictly the right place to do&n;&t; * this, but I am too lazy to create a function especially for it...&n;&t; */
id|vol-&gt;mft_zone_end
op_assign
id|vol
op_member_access_from_pointer
id|_VCL
c_func
(paren
id|nr_clusters
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|vol-&gt;mft_zone_multiplier
)paren
(brace
multiline_comment|/* % of volume size in clusters */
r_case
l_int|4
suffix:colon
id|vol-&gt;mft_zone_end
op_assign
id|vol-&gt;mft_zone_end
op_rshift
l_int|1
suffix:semicolon
multiline_comment|/* 50%   */
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
id|vol-&gt;mft_zone_end
op_assign
(paren
id|vol-&gt;mft_zone_end
op_plus
(paren
id|vol-&gt;mft_zone_end
op_rshift
l_int|1
)paren
)paren
op_rshift
l_int|2
suffix:semicolon
multiline_comment|/* 37.5% */
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|vol-&gt;mft_zone_end
op_assign
id|vol-&gt;mft_zone_end
op_rshift
l_int|2
suffix:semicolon
multiline_comment|/* 25%   */
r_break
suffix:semicolon
r_default
suffix:colon
id|vol-&gt;mft_zone_multiplier
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Fall through into case 1. */
r_case
l_int|1
suffix:colon
id|vol-&gt;mft_zone_end
op_assign
id|vol-&gt;mft_zone_end
op_rshift
l_int|3
suffix:semicolon
multiline_comment|/* 12.5% */
r_break
suffix:semicolon
)brace
id|ntfs_debug
c_func
(paren
l_string|&quot;vol-&gt;mft_zone_multiplier = 0x%x&quot;
comma
id|vol-&gt;mft_zone_multiplier
)paren
suffix:semicolon
id|vol-&gt;mft_zone_start
op_assign
id|vol-&gt;mft_lcn
suffix:semicolon
id|vol-&gt;mft_zone_end
op_add_assign
id|vol-&gt;mft_lcn
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;vol-&gt;mft_zone_start = 0x%Lx&quot;
comma
(paren
r_int
r_int
)paren
id|vol-&gt;mft_zone_start
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;vol-&gt;mft_zone_end = 0x%Lx&quot;
comma
(paren
r_int
r_int
)paren
id|vol-&gt;mft_zone_end
)paren
suffix:semicolon
multiline_comment|/* And another misplaced defaults setting. */
r_if
c_cond
(paren
op_logical_neg
id|vol-&gt;on_errors
)paren
id|vol-&gt;on_errors
op_assign
id|ON_ERRORS_PANIC
suffix:semicolon
r_return
id|TRUE
suffix:semicolon
)brace
multiline_comment|/**&n; * load_and_init_upcase - load the upcase table for an ntfs volume&n; * @vol:&t;ntfs super block describing device whose upcase to load&n; *&n; * Return TRUE on success or FALSE on error.&n; */
DECL|function|load_and_init_upcase
r_static
id|BOOL
id|load_and_init_upcase
c_func
(paren
id|ntfs_volume
op_star
id|vol
)paren
(brace
r_struct
id|super_block
op_star
id|sb
op_assign
id|vol-&gt;sb
suffix:semicolon
r_struct
id|inode
op_star
id|ino
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
r_int
r_int
id|index
comma
id|max_index
suffix:semicolon
r_int
r_int
id|size
suffix:semicolon
r_int
id|i
comma
id|max
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Entering.&quot;
)paren
suffix:semicolon
multiline_comment|/* Read upcase table and setup vol-&gt;upcase and vol-&gt;upcase_len. */
id|ino
op_assign
id|iget
c_func
(paren
id|sb
comma
id|FILE_UpCase
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ino
op_logical_or
id|is_bad_inode
c_func
(paren
id|ino
)paren
)paren
(brace
r_if
c_cond
(paren
id|ino
)paren
id|iput
c_func
(paren
id|ino
)paren
suffix:semicolon
r_goto
id|upcase_failed
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * The upcase size must not be above 64k Unicode characters, must not&n;&t; * be zero and must be a multiple of sizeof(uchar_t).&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|ino-&gt;i_size
op_logical_or
id|ino-&gt;i_size
op_amp
(paren
r_sizeof
(paren
id|uchar_t
)paren
op_minus
l_int|1
)paren
op_logical_or
id|ino-&gt;i_size
OG
l_int|64ULL
op_star
l_int|1024
op_star
r_sizeof
(paren
id|uchar_t
)paren
)paren
r_goto
id|iput_upcase_failed
suffix:semicolon
id|vol-&gt;upcase
op_assign
(paren
id|uchar_t
op_star
)paren
id|ntfs_malloc_nofs
c_func
(paren
id|ino-&gt;i_size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vol-&gt;upcase
)paren
r_goto
id|iput_upcase_failed
suffix:semicolon
id|index
op_assign
l_int|0
suffix:semicolon
id|max_index
op_assign
id|ino-&gt;i_size
op_rshift
id|PAGE_CACHE_SHIFT
suffix:semicolon
id|size
op_assign
id|PAGE_CACHE_SIZE
suffix:semicolon
r_while
c_loop
(paren
id|index
OL
id|max_index
)paren
(brace
multiline_comment|/* Read the upcase table and copy it into the linear buffer. */
id|read_partial_upcase_page
suffix:colon
id|page
op_assign
id|ntfs_map_page
c_func
(paren
id|ino-&gt;i_mapping
comma
id|index
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|page
)paren
)paren
r_goto
id|iput_upcase_failed
suffix:semicolon
id|memcpy
c_func
(paren
(paren
r_char
op_star
)paren
id|vol-&gt;upcase
op_plus
(paren
id|index
op_increment
op_lshift
id|PAGE_CACHE_SHIFT
)paren
comma
id|page_address
c_func
(paren
id|page
)paren
comma
id|size
)paren
suffix:semicolon
id|ntfs_unmap_page
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
suffix:semicolon
r_if
c_cond
(paren
id|size
op_eq
id|PAGE_CACHE_SIZE
)paren
(brace
id|size
op_assign
id|ino-&gt;i_size
op_amp
op_complement
id|PAGE_CACHE_MASK
suffix:semicolon
r_if
c_cond
(paren
id|size
)paren
r_goto
id|read_partial_upcase_page
suffix:semicolon
)brace
id|vol-&gt;upcase_len
op_assign
id|ino-&gt;i_size
op_rshift
id|UCHAR_T_SIZE_BITS
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Read %Lu bytes from $UpCase (expected %u bytes).&quot;
comma
id|ino-&gt;i_size
comma
l_int|64
op_star
l_int|1024
op_star
r_sizeof
(paren
id|uchar_t
)paren
)paren
suffix:semicolon
id|iput
c_func
(paren
id|ino
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|ntfs_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|default_upcase
)paren
(brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Using volume specified $UpCase since default is &quot;
l_string|&quot;not present.&quot;
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|ntfs_lock
)paren
suffix:semicolon
r_return
id|TRUE
suffix:semicolon
)brace
id|max
op_assign
id|default_upcase_len
suffix:semicolon
r_if
c_cond
(paren
id|max
OG
id|vol-&gt;upcase_len
)paren
id|max
op_assign
id|vol-&gt;upcase_len
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|max
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|vol-&gt;upcase
(braket
id|i
)braket
op_ne
id|default_upcase
(braket
id|i
)braket
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
id|max
)paren
(brace
id|ntfs_free
c_func
(paren
id|vol-&gt;upcase
)paren
suffix:semicolon
id|vol-&gt;upcase
op_assign
id|default_upcase
suffix:semicolon
id|vol-&gt;upcase_len
op_assign
id|max
suffix:semicolon
id|ntfs_nr_upcase_users
op_increment
suffix:semicolon
id|up
c_func
(paren
op_amp
id|ntfs_lock
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Volume specified $UpCase matches default. Using &quot;
l_string|&quot;default.&quot;
)paren
suffix:semicolon
r_return
id|TRUE
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|ntfs_lock
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Using volume specified $UpCase since it does not match &quot;
l_string|&quot;the default.&quot;
)paren
suffix:semicolon
r_return
id|TRUE
suffix:semicolon
id|iput_upcase_failed
suffix:colon
id|iput
c_func
(paren
id|ino
)paren
suffix:semicolon
id|ntfs_free
c_func
(paren
id|vol-&gt;upcase
)paren
suffix:semicolon
id|vol-&gt;upcase
op_assign
l_int|NULL
suffix:semicolon
id|upcase_failed
suffix:colon
id|down
c_func
(paren
op_amp
id|ntfs_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|default_upcase
)paren
(brace
id|vol-&gt;upcase
op_assign
id|default_upcase
suffix:semicolon
id|vol-&gt;upcase_len
op_assign
id|default_upcase_len
suffix:semicolon
id|ntfs_nr_upcase_users
op_increment
suffix:semicolon
id|up
c_func
(paren
op_amp
id|ntfs_lock
)paren
suffix:semicolon
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Failed to load $UpCase from the volume. Using &quot;
l_string|&quot;default.&quot;
)paren
suffix:semicolon
r_return
id|TRUE
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|ntfs_lock
)paren
suffix:semicolon
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Failed to initialized upcase table.&quot;
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
multiline_comment|/**&n; * load_system_files - open the system files using normal functions&n; * @vol:&t;ntfs super block describing device whose system files to load&n; *&n; * Open the system files with normal access functions and complete setting up&n; * the ntfs super block @vol.&n; *&n; * Return TRUE on success or FALSE on error.&n; */
DECL|function|load_system_files
r_static
id|BOOL
id|load_system_files
c_func
(paren
id|ntfs_volume
op_star
id|vol
)paren
(brace
id|VCN
id|next_vcn
comma
id|last_vcn
comma
id|highest_vcn
suffix:semicolon
r_struct
id|super_block
op_star
id|sb
op_assign
id|vol-&gt;sb
suffix:semicolon
r_struct
id|inode
op_star
id|tmp_ino
suffix:semicolon
id|MFT_RECORD
op_star
id|m
suffix:semicolon
id|ATTR_RECORD
op_star
id|attr
suffix:semicolon
id|VOLUME_INFORMATION
op_star
id|vi
suffix:semicolon
id|attr_search_context
op_star
id|ctx
suffix:semicolon
id|run_list_element
op_star
id|rl
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Entering.&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We have $MFT already (vol-&gt;mft_ino) but we need to setup access to&n;&t; * the $MFT/$BITMAP attribute.&n;&t; */
id|m
op_assign
id|map_mft_record
c_func
(paren
id|READ
comma
id|NTFS_I
c_func
(paren
id|vol-&gt;mft_ino
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|m
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Failed to map $MFT.&quot;
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|get_attr_search_ctx
c_func
(paren
op_amp
id|ctx
comma
id|NTFS_I
c_func
(paren
id|vol-&gt;mft_ino
)paren
comma
id|m
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Failed to get attribute search context.&quot;
)paren
suffix:semicolon
r_goto
id|unmap_err_out
suffix:semicolon
)brace
multiline_comment|/* Load all attribute extents. */
id|attr
op_assign
l_int|NULL
suffix:semicolon
id|rl
op_assign
l_int|NULL
suffix:semicolon
id|next_vcn
op_assign
id|last_vcn
op_assign
id|highest_vcn
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|lookup_attr
c_func
(paren
id|AT_BITMAP
comma
l_int|NULL
comma
l_int|0
comma
l_int|0
comma
id|next_vcn
comma
l_int|NULL
comma
l_int|0
comma
id|ctx
)paren
)paren
(brace
id|run_list_element
op_star
id|nrl
suffix:semicolon
multiline_comment|/* Cache the current attribute extent. */
id|attr
op_assign
id|ctx-&gt;attr
suffix:semicolon
multiline_comment|/* $MFT/$BITMAP must be non-resident. */
r_if
c_cond
(paren
op_logical_neg
id|attr-&gt;non_resident
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;$MFT/$BITMAP must be non-resident but &quot;
l_string|&quot;a resident extent was found. $MFT is &quot;
l_string|&quot;corrupt. Run chkdsk.&quot;
)paren
suffix:semicolon
r_goto
id|put_err_out
suffix:semicolon
)brace
multiline_comment|/* $MFT/$BITMAP must be uncompressed and unencrypted. */
r_if
c_cond
(paren
id|attr-&gt;flags
op_amp
id|ATTR_COMPRESSION_MASK
op_logical_or
id|attr-&gt;flags
op_amp
id|ATTR_IS_ENCRYPTED
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;$MFT/$BITMAP must be uncompressed and &quot;
l_string|&quot;unencrypted but a compressed/&quot;
l_string|&quot;encrypted extent was found. $MFT is &quot;
l_string|&quot;corrupt. Run chkdsk.&quot;
)paren
suffix:semicolon
r_goto
id|put_err_out
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Decompress the mapping pairs array of this extent&n;&t;&t; * and merge the result into the existing run list. Note we&n;&t;&t; * don&squot;t need any locking at this stage as we are already&n;&t;&t; * running exclusively as we are mount in progress task.&n;&t;&t; */
id|nrl
op_assign
id|decompress_mapping_pairs
c_func
(paren
id|vol
comma
id|attr
comma
id|rl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|nrl
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;decompress_mapping_pairs() failed with &quot;
l_string|&quot;error code %ld. $MFT is corrupt.&quot;
comma
id|PTR_ERR
c_func
(paren
id|nrl
)paren
)paren
suffix:semicolon
r_goto
id|put_err_out
suffix:semicolon
)brace
id|rl
op_assign
id|nrl
suffix:semicolon
multiline_comment|/* Are we in the first extent? */
r_if
c_cond
(paren
op_logical_neg
id|next_vcn
)paren
(brace
multiline_comment|/* Get the last vcn in the $BITMAP attribute. */
id|last_vcn
op_assign
id|sle64_to_cpu
c_func
(paren
id|attr
op_member_access_from_pointer
id|_ANR
c_func
(paren
id|allocated_size
)paren
)paren
op_rshift
id|vol-&gt;cluster_size_bits
suffix:semicolon
id|vol-&gt;mftbmp_size
op_assign
id|sle64_to_cpu
c_func
(paren
id|attr
op_member_access_from_pointer
id|_ANR
c_func
(paren
id|data_size
)paren
)paren
suffix:semicolon
id|vol-&gt;mftbmp_initialized_size
op_assign
id|sle64_to_cpu
c_func
(paren
id|attr
op_member_access_from_pointer
id|_ANR
c_func
(paren
id|initialized_size
)paren
)paren
suffix:semicolon
id|vol-&gt;mftbmp_allocated_size
op_assign
id|sle64_to_cpu
c_func
(paren
id|attr
op_member_access_from_pointer
id|_ANR
c_func
(paren
id|allocated_size
)paren
)paren
suffix:semicolon
multiline_comment|/* Consistency check. */
r_if
c_cond
(paren
id|vol-&gt;mftbmp_size
OL
(paren
id|vol
op_member_access_from_pointer
id|_VMM
c_func
(paren
id|nr_mft_records
)paren
op_plus
l_int|7
)paren
op_rshift
l_int|3
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;$MFT/$BITMAP is too short to &quot;
l_string|&quot;contain a complete mft &quot;
l_string|&quot;bitmap: impossible. $MFT is &quot;
l_string|&quot;corrupt. Run chkdsk.&quot;
)paren
suffix:semicolon
r_goto
id|put_err_out
suffix:semicolon
)brace
)brace
multiline_comment|/* Get the lowest vcn for the next extent. */
id|highest_vcn
op_assign
id|sle64_to_cpu
c_func
(paren
id|attr
op_member_access_from_pointer
id|_ANR
c_func
(paren
id|highest_vcn
)paren
)paren
suffix:semicolon
id|next_vcn
op_assign
id|highest_vcn
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* Only one extent or error, which we catch below. */
r_if
c_cond
(paren
id|next_vcn
op_le
l_int|0
)paren
r_break
suffix:semicolon
multiline_comment|/* Avoid endless loops due to corruption. */
r_if
c_cond
(paren
id|next_vcn
OL
id|sle64_to_cpu
c_func
(paren
id|attr
op_member_access_from_pointer
id|_ANR
c_func
(paren
id|lowest_vcn
)paren
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;$MFT/$BITMAP has corrupt attribute &quot;
l_string|&quot;list attribute. Run chkdsk.&quot;
)paren
suffix:semicolon
r_goto
id|put_err_out
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|attr
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Missing or invalid $BITMAP attribute in file &quot;
l_string|&quot;$MFT. $MFT is corrupt. Run chkdsk.&quot;
)paren
suffix:semicolon
id|put_err_out
suffix:colon
id|put_attr_search_ctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
id|unmap_err_out
suffix:colon
id|unmap_mft_record
c_func
(paren
id|READ
comma
id|NTFS_I
c_func
(paren
id|vol-&gt;mft_ino
)paren
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
multiline_comment|/* We are finished with $MFT/$BITMAP. */
id|put_attr_search_ctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
id|unmap_mft_record
c_func
(paren
id|READ
comma
id|NTFS_I
c_func
(paren
id|vol-&gt;mft_ino
)paren
)paren
suffix:semicolon
multiline_comment|/* Catch errors. */
r_if
c_cond
(paren
id|highest_vcn
op_logical_and
id|highest_vcn
op_ne
id|last_vcn
op_minus
l_int|1
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Failed to load the complete run list for &quot;
l_string|&quot;$MFT/$BITMAP. Driver bug or corrupt $MFT. &quot;
l_string|&quot;Run chkdsk.&quot;
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;highest_vcn = 0x%Lx, last_vcn - 1 = 0x%Lx&quot;
comma
(paren
r_int
r_int
)paren
id|highest_vcn
comma
(paren
r_int
r_int
)paren
id|last_vcn
op_minus
l_int|1
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
suffix:semicolon
)brace
multiline_comment|/* Setup the run list and the address space in the volume structure. */
id|vol-&gt;mftbmp_rl.rl
op_assign
id|rl
suffix:semicolon
id|vol-&gt;mftbmp_mapping.a_ops
op_assign
op_amp
id|ntfs_mftbmp_aops
suffix:semicolon
multiline_comment|/* Not inode data, set to NULL. Our mft bitmap access kludge... */
id|vol-&gt;mftbmp_mapping.host
op_assign
l_int|NULL
suffix:semicolon
singleline_comment|// FIXME: If mounting read-only, it would be ok to ignore errors when
singleline_comment|// loading the mftbmp but we then need to make sure nobody remounts the
singleline_comment|// volume read-write...
multiline_comment|/* Get mft mirror inode. */
id|vol-&gt;mftmirr_ino
op_assign
id|iget
c_func
(paren
id|sb
comma
id|FILE_MFTMirr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vol-&gt;mftmirr_ino
op_logical_or
id|is_bad_inode
c_func
(paren
id|vol-&gt;mftmirr_ino
)paren
)paren
(brace
r_if
c_cond
(paren
id|is_bad_inode
c_func
(paren
id|vol-&gt;mftmirr_ino
)paren
)paren
id|iput
c_func
(paren
id|vol-&gt;mftmirr_ino
)paren
suffix:semicolon
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Failed to load $MFTMirr.&quot;
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
singleline_comment|// FIXME: Compare mftmirr with mft and repair if appropriate and not
singleline_comment|// a read-only mount.
multiline_comment|/* Read upcase table and setup vol-&gt;upcase and vol-&gt;upcase_len. */
r_if
c_cond
(paren
op_logical_neg
id|load_and_init_upcase
c_func
(paren
id|vol
)paren
)paren
r_goto
id|iput_mirr_err_out
suffix:semicolon
multiline_comment|/*&n;&t; * Get the cluster allocation bitmap inode and verify the size, no&n;&t; * need for any locking at this stage as we are already running&n;&t; * exclusively as we are mount in progress task.&n;&t; */
id|vol-&gt;lcnbmp_ino
op_assign
id|iget
c_func
(paren
id|sb
comma
id|FILE_Bitmap
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vol-&gt;lcnbmp_ino
op_logical_or
id|is_bad_inode
c_func
(paren
id|vol-&gt;lcnbmp_ino
)paren
)paren
(brace
r_if
c_cond
(paren
id|is_bad_inode
c_func
(paren
id|vol-&gt;lcnbmp_ino
)paren
)paren
id|iput
c_func
(paren
id|vol-&gt;lcnbmp_ino
)paren
suffix:semicolon
r_goto
id|bitmap_failed
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|vol
op_member_access_from_pointer
id|_VCL
c_func
(paren
id|nr_lcn_bits
)paren
op_plus
l_int|7
)paren
op_rshift
l_int|3
OG
id|vol-&gt;lcnbmp_ino-&gt;i_size
)paren
(brace
id|iput
c_func
(paren
id|vol-&gt;lcnbmp_ino
)paren
suffix:semicolon
id|bitmap_failed
suffix:colon
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Failed to load $Bitmap.&quot;
)paren
suffix:semicolon
r_goto
id|iput_mirr_err_out
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Get the volume inode and setup our cache of the volume flags and&n;&t; * version.&n;&t; */
id|vol-&gt;vol_ino
op_assign
id|iget
c_func
(paren
id|sb
comma
id|FILE_Volume
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vol-&gt;vol_ino
op_logical_or
id|is_bad_inode
c_func
(paren
id|vol-&gt;vol_ino
)paren
)paren
(brace
r_if
c_cond
(paren
id|is_bad_inode
c_func
(paren
id|vol-&gt;vol_ino
)paren
)paren
id|iput
c_func
(paren
id|vol-&gt;vol_ino
)paren
suffix:semicolon
id|volume_failed
suffix:colon
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Failed to load $Volume.&quot;
)paren
suffix:semicolon
r_goto
id|iput_bmp_mirr_err_out
suffix:semicolon
)brace
id|m
op_assign
id|map_mft_record
c_func
(paren
id|READ
comma
id|NTFS_I
c_func
(paren
id|vol-&gt;vol_ino
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|m
)paren
)paren
(brace
id|iput_volume_failed
suffix:colon
id|iput
c_func
(paren
id|vol-&gt;vol_ino
)paren
suffix:semicolon
r_goto
id|volume_failed
suffix:semicolon
)brace
r_if
c_cond
(paren
id|get_attr_search_ctx
c_func
(paren
op_amp
id|ctx
comma
id|NTFS_I
c_func
(paren
id|vol-&gt;vol_ino
)paren
comma
id|m
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Failed to get attribute search context.&quot;
)paren
suffix:semicolon
r_goto
id|get_ctx_vol_failed
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|lookup_attr
c_func
(paren
id|AT_VOLUME_INFORMATION
comma
l_int|NULL
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|NULL
comma
l_int|0
comma
id|ctx
)paren
op_logical_or
id|ctx-&gt;attr-&gt;non_resident
op_logical_or
id|ctx-&gt;attr-&gt;flags
)paren
(brace
id|err_put_vol
suffix:colon
id|put_attr_search_ctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
id|get_ctx_vol_failed
suffix:colon
id|unmap_mft_record
c_func
(paren
id|READ
comma
id|NTFS_I
c_func
(paren
id|vol-&gt;vol_ino
)paren
)paren
suffix:semicolon
r_goto
id|iput_volume_failed
suffix:semicolon
)brace
id|vi
op_assign
(paren
id|VOLUME_INFORMATION
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|ctx-&gt;attr
op_plus
id|le16_to_cpu
c_func
(paren
id|ctx-&gt;attr
op_member_access_from_pointer
id|_ARA
c_func
(paren
id|value_offset
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/* Some bounds checks. */
r_if
c_cond
(paren
(paren
id|u8
op_star
)paren
id|vi
template_param
(paren
id|u8
op_star
)paren
id|ctx-&gt;attr
op_plus
id|le32_to_cpu
c_func
(paren
id|ctx-&gt;attr-&gt;length
)paren
)paren
r_goto
id|err_put_vol
suffix:semicolon
multiline_comment|/* Setup volume flags and version. */
id|vol-&gt;vol_flags
op_assign
id|vi-&gt;flags
suffix:semicolon
id|vol-&gt;major_ver
op_assign
id|vi-&gt;major_ver
suffix:semicolon
id|vol-&gt;minor_ver
op_assign
id|vi-&gt;minor_ver
suffix:semicolon
id|put_attr_search_ctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
id|unmap_mft_record
c_func
(paren
id|READ
comma
id|NTFS_I
c_func
(paren
id|vol-&gt;vol_ino
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;NTFS volume version %i.%i.&bslash;n&quot;
comma
id|vol-&gt;major_ver
comma
id|vol-&gt;minor_ver
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Get the inode for the logfile and empty it if this is a read-write&n;&t; * mount.&n;&t; */
id|tmp_ino
op_assign
id|iget
c_func
(paren
id|sb
comma
id|FILE_LogFile
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tmp_ino
op_logical_or
id|is_bad_inode
c_func
(paren
id|tmp_ino
)paren
)paren
(brace
r_if
c_cond
(paren
id|is_bad_inode
c_func
(paren
id|tmp_ino
)paren
)paren
id|iput
c_func
(paren
id|tmp_ino
)paren
suffix:semicolon
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Failed to load $LogFile.&quot;
)paren
suffix:semicolon
singleline_comment|// FIMXE: We only want to empty the thing so pointless bailing
singleline_comment|// out. Can recover/ignore.
r_goto
id|iput_vol_bmp_mirr_err_out
suffix:semicolon
)brace
singleline_comment|// FIXME: Empty the logfile, but only if not read-only.
singleline_comment|// FIXME: What happens if someone remounts rw? We need to empty the file
singleline_comment|// then. We need a flag to tell us whether we have done it already.
id|iput
c_func
(paren
id|tmp_ino
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Get the inode for the attribute definitions file and parse the&n;&t; * attribute definitions.&n;&t; */
id|tmp_ino
op_assign
id|iget
c_func
(paren
id|sb
comma
id|FILE_AttrDef
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tmp_ino
op_logical_or
id|is_bad_inode
c_func
(paren
id|tmp_ino
)paren
)paren
(brace
r_if
c_cond
(paren
id|is_bad_inode
c_func
(paren
id|tmp_ino
)paren
)paren
id|iput
c_func
(paren
id|tmp_ino
)paren
suffix:semicolon
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Failed to load $AttrDef.&quot;
)paren
suffix:semicolon
r_goto
id|iput_vol_bmp_mirr_err_out
suffix:semicolon
)brace
singleline_comment|// FIXME: Parse the attribute definitions.
id|iput
c_func
(paren
id|tmp_ino
)paren
suffix:semicolon
multiline_comment|/* Get the root directory inode. */
id|vol-&gt;root_ino
op_assign
id|iget
c_func
(paren
id|sb
comma
id|FILE_root
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vol-&gt;root_ino
op_logical_or
id|is_bad_inode
c_func
(paren
id|vol-&gt;root_ino
)paren
)paren
(brace
r_if
c_cond
(paren
id|is_bad_inode
c_func
(paren
id|vol-&gt;root_ino
)paren
)paren
id|iput
c_func
(paren
id|vol-&gt;root_ino
)paren
suffix:semicolon
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Failed to load root directory.&quot;
)paren
suffix:semicolon
r_goto
id|iput_vol_bmp_mirr_err_out
suffix:semicolon
)brace
multiline_comment|/* If on NTFS versions before 3.0, we are done. */
r_if
c_cond
(paren
id|vol-&gt;major_ver
OL
l_int|3
)paren
r_return
id|TRUE
suffix:semicolon
multiline_comment|/* NTFS 3.0+ specific initialization. */
multiline_comment|/* Get the security descriptors inode. */
id|vol-&gt;secure_ino
op_assign
id|iget
c_func
(paren
id|sb
comma
id|FILE_Secure
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vol-&gt;secure_ino
op_logical_or
id|is_bad_inode
c_func
(paren
id|vol-&gt;secure_ino
)paren
)paren
(brace
r_if
c_cond
(paren
id|is_bad_inode
c_func
(paren
id|vol-&gt;secure_ino
)paren
)paren
id|iput
c_func
(paren
id|vol-&gt;secure_ino
)paren
suffix:semicolon
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Failed to load $Secure.&quot;
)paren
suffix:semicolon
r_goto
id|iput_root_vol_bmp_mirr_err_out
suffix:semicolon
)brace
singleline_comment|// FIXME: Initialize security.
multiline_comment|/* Get the extended system files&squot; directory inode. */
id|tmp_ino
op_assign
id|iget
c_func
(paren
id|sb
comma
id|FILE_Extend
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tmp_ino
op_logical_or
id|is_bad_inode
c_func
(paren
id|tmp_ino
)paren
)paren
(brace
r_if
c_cond
(paren
id|is_bad_inode
c_func
(paren
id|tmp_ino
)paren
)paren
id|iput
c_func
(paren
id|tmp_ino
)paren
suffix:semicolon
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Failed to load $Extend.&quot;
)paren
suffix:semicolon
r_goto
id|iput_sec_root_vol_bmp_mirr_err_out
suffix:semicolon
)brace
singleline_comment|// FIXME: Do something. E.g. want to delete the $UsnJrnl if exists.
singleline_comment|// Note we might be doing this at the wrong level; we might want to
singleline_comment|// d_alloc_root() and then do a &quot;normal&quot; open(2) of $Extend&bslash;$UsnJrnl
singleline_comment|// rather than using iget here, as we don&squot;t know the inode number for
singleline_comment|// the files in $Extend directory.
id|iput
c_func
(paren
id|tmp_ino
)paren
suffix:semicolon
r_return
id|TRUE
suffix:semicolon
id|iput_sec_root_vol_bmp_mirr_err_out
suffix:colon
id|iput
c_func
(paren
id|vol-&gt;secure_ino
)paren
suffix:semicolon
id|iput_root_vol_bmp_mirr_err_out
suffix:colon
id|iput
c_func
(paren
id|vol-&gt;root_ino
)paren
suffix:semicolon
id|iput_vol_bmp_mirr_err_out
suffix:colon
id|iput
c_func
(paren
id|vol-&gt;vol_ino
)paren
suffix:semicolon
id|iput_bmp_mirr_err_out
suffix:colon
id|iput
c_func
(paren
id|vol-&gt;lcnbmp_ino
)paren
suffix:semicolon
id|iput_mirr_err_out
suffix:colon
id|iput
c_func
(paren
id|vol-&gt;mftmirr_ino
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_put_super - called by the vfs to unmount a volume&n; * @vfs_sb:&t;vfs superblock of volume to unmount&n; *&n; * ntfs_put_super() is called by the VFS (from fs/super.c::do_umount()) when&n; * the volume is being unmounted (umount system call has been invoked) and it&n; * releases all inodes and memory belonging to the NTFS specific part of the&n; * super block.&n; */
DECL|function|ntfs_put_super
r_void
id|ntfs_put_super
c_func
(paren
r_struct
id|super_block
op_star
id|vfs_sb
)paren
(brace
id|ntfs_volume
op_star
id|vol
op_assign
id|NTFS_SB
c_func
(paren
id|vfs_sb
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Entering.&quot;
)paren
suffix:semicolon
id|iput
c_func
(paren
id|vol-&gt;vol_ino
)paren
suffix:semicolon
id|vol-&gt;vol_ino
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* NTFS 3.0+ specific clean up. */
r_if
c_cond
(paren
id|vol-&gt;major_ver
op_ge
l_int|3
)paren
(brace
r_if
c_cond
(paren
id|vol-&gt;secure_ino
)paren
(brace
id|iput
c_func
(paren
id|vol-&gt;secure_ino
)paren
suffix:semicolon
id|vol-&gt;secure_ino
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
id|iput
c_func
(paren
id|vol-&gt;root_ino
)paren
suffix:semicolon
id|vol-&gt;root_ino
op_assign
l_int|NULL
suffix:semicolon
id|down_write
c_func
(paren
op_amp
id|vol-&gt;lcnbmp_lock
)paren
suffix:semicolon
id|iput
c_func
(paren
id|vol-&gt;lcnbmp_ino
)paren
suffix:semicolon
id|vol-&gt;lcnbmp_ino
op_assign
l_int|NULL
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|vol-&gt;lcnbmp_lock
)paren
suffix:semicolon
id|iput
c_func
(paren
id|vol-&gt;mftmirr_ino
)paren
suffix:semicolon
id|vol-&gt;mftmirr_ino
op_assign
l_int|NULL
suffix:semicolon
id|iput
c_func
(paren
id|vol-&gt;mft_ino
)paren
suffix:semicolon
id|vol-&gt;mft_ino
op_assign
l_int|NULL
suffix:semicolon
id|down_write
c_func
(paren
op_amp
id|vol-&gt;mftbmp_lock
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Clean up mft bitmap address space. Ignore the _inode_ bit in the&n;&t; * name of the function... FIXME: What does this do with dirty pages?&n;&t; * (ask Al Viro)&n;&t; */
id|truncate_inode_pages
c_func
(paren
op_amp
id|vol-&gt;mftbmp_mapping
comma
l_int|0
)paren
suffix:semicolon
id|vol-&gt;mftbmp_mapping.a_ops
op_assign
l_int|NULL
suffix:semicolon
id|vol-&gt;mftbmp_mapping.host
op_assign
l_int|NULL
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|vol-&gt;mftbmp_lock
)paren
suffix:semicolon
id|write_lock
c_func
(paren
op_amp
id|vol-&gt;mftbmp_rl.lock
)paren
suffix:semicolon
id|ntfs_free
c_func
(paren
id|vol-&gt;mftbmp_rl.rl
)paren
suffix:semicolon
id|vol-&gt;mftbmp_rl.rl
op_assign
l_int|NULL
suffix:semicolon
id|write_unlock
c_func
(paren
op_amp
id|vol-&gt;mftbmp_rl.lock
)paren
suffix:semicolon
id|vol-&gt;upcase_len
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Decrease the number of mounts and destroy the global default upcase&n;&t; * table if necessary. Also decrease the number of upcase users if we&n;&t; * are a user.&n;&t; */
id|down
c_func
(paren
op_amp
id|ntfs_lock
)paren
suffix:semicolon
id|ntfs_nr_mounts
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|vol-&gt;upcase
op_eq
id|default_upcase
)paren
(brace
id|ntfs_nr_upcase_users
op_decrement
suffix:semicolon
id|vol-&gt;upcase
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|ntfs_nr_upcase_users
op_logical_and
id|default_upcase
)paren
(brace
id|ntfs_free
c_func
(paren
id|default_upcase
)paren
suffix:semicolon
id|default_upcase
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|vol-&gt;cluster_size
op_le
l_int|4096
op_logical_and
op_logical_neg
op_decrement
id|ntfs_nr_compression_users
)paren
id|free_compression_buffers
c_func
(paren
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|ntfs_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vol-&gt;upcase
)paren
(brace
id|ntfs_free
c_func
(paren
id|vol-&gt;upcase
)paren
suffix:semicolon
id|vol-&gt;upcase
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|vol-&gt;nls_map
)paren
(brace
id|unload_nls
c_func
(paren
id|vol-&gt;nls_map
)paren
suffix:semicolon
id|vol-&gt;nls_map
op_assign
l_int|NULL
suffix:semicolon
)brace
id|vfs_sb-&gt;u.generic_sbp
op_assign
l_int|NULL
suffix:semicolon
id|kfree
c_func
(paren
id|vol
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/**&n; * get_nr_free_clusters - return the number of free clusters on a volume&n; * @vol:&t;ntfs volume for which to obtain free cluster count&n; *&n; * Calculate the number of free clusters on the mounted NTFS volume @vol.&n; *&n; * Errors are ignored and we just return the number of free clusters we have&n; * found. This means we return an underestimate on error.&n; */
DECL|function|get_nr_free_clusters
id|s64
id|get_nr_free_clusters
c_func
(paren
id|ntfs_volume
op_star
id|vol
)paren
(brace
r_struct
id|address_space
op_star
id|mapping
op_assign
id|vol-&gt;lcnbmp_ino-&gt;i_mapping
suffix:semicolon
id|filler_t
op_star
id|readpage
op_assign
(paren
id|filler_t
op_star
)paren
id|mapping-&gt;a_ops-&gt;readpage
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
r_int
r_int
id|index
comma
id|max_index
suffix:semicolon
r_int
r_int
id|max_size
comma
id|i
suffix:semicolon
id|s64
id|nr_free
op_assign
l_int|0LL
suffix:semicolon
id|u32
op_star
id|b
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Entering.&quot;
)paren
suffix:semicolon
multiline_comment|/* Serialize accesses to the cluster bitmap. */
id|down_read
c_func
(paren
op_amp
id|vol-&gt;lcnbmp_lock
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Convert the number of bits into bytes rounded up, then convert into&n;&t; * multiples of PAGE_CACHE_SIZE.&n;&t; */
id|max_index
op_assign
(paren
id|vol
op_member_access_from_pointer
id|_VCL
c_func
(paren
id|nr_clusters
)paren
op_plus
l_int|7
)paren
op_rshift
(paren
l_int|3
op_plus
id|PAGE_CACHE_SHIFT
)paren
suffix:semicolon
multiline_comment|/* Use multiples of 4 bytes. */
id|max_size
op_assign
id|PAGE_CACHE_SIZE
op_rshift
l_int|2
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Reading $BITMAP, max_index = 0x%lx, max_size = 0x%x.&quot;
comma
id|max_index
comma
id|max_size
)paren
suffix:semicolon
r_for
c_loop
(paren
id|index
op_assign
l_int|0UL
suffix:semicolon
id|index
OL
id|max_index
suffix:semicolon
)paren
(brace
id|handle_partial_page
suffix:colon
multiline_comment|/*&n;&t;&t; * Read the page from page cache, getting it from backing store&n;&t;&t; * if necessary, and increment the use count.&n;&t;&t; */
id|page
op_assign
id|read_cache_page
c_func
(paren
id|mapping
comma
id|index
op_increment
comma
(paren
id|filler_t
op_star
)paren
id|readpage
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* Ignore pages which errored synchronously. */
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|page
)paren
)paren
(brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Sync read_cache_page() error. Skipping &quot;
l_string|&quot;page (index 0x%lx).&quot;
comma
id|index
op_minus
l_int|1
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|wait_on_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|Page_Uptodate
c_func
(paren
id|page
)paren
)paren
(brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Async read_cache_page() error. Skipping &quot;
l_string|&quot;page (index 0x%lx).&quot;
comma
id|index
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Ignore pages which errored asynchronously. */
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|b
op_assign
(paren
id|u32
op_star
)paren
id|kmap
c_func
(paren
id|page
)paren
suffix:semicolon
multiline_comment|/* For each 4 bytes, add up the number zero bits. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|max_size
suffix:semicolon
id|i
op_increment
)paren
id|nr_free
op_add_assign
(paren
id|s64
)paren
(paren
l_int|32
op_minus
id|hweight32
c_func
(paren
id|b
(braket
id|i
)braket
)paren
)paren
suffix:semicolon
id|kunmap
c_func
(paren
id|page
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|max_size
op_eq
id|PAGE_CACHE_SIZE
op_rshift
l_int|2
)paren
(brace
multiline_comment|/*&n;&t;&t; * Get the multiples of 4 bytes in use in the final partial&n;&t;&t; * page.&n;&t;&t; */
id|max_size
op_assign
(paren
(paren
(paren
(paren
id|vol
op_member_access_from_pointer
id|_VCL
c_func
(paren
id|nr_clusters
)paren
op_plus
l_int|7
)paren
op_rshift
l_int|3
)paren
op_amp
op_complement
id|PAGE_CACHE_MASK
)paren
op_plus
l_int|3
)paren
op_rshift
l_int|2
suffix:semicolon
multiline_comment|/* If there is a partial page go back and do it. */
r_if
c_cond
(paren
id|max_size
)paren
(brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Handling partial page, max_size = 0x%x.&quot;
comma
id|max_size
)paren
suffix:semicolon
r_goto
id|handle_partial_page
suffix:semicolon
)brace
)brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Finished reading $BITMAP, last index = 0x%lx&quot;
comma
id|index
op_minus
l_int|1
)paren
suffix:semicolon
id|up_read
c_func
(paren
op_amp
id|vol-&gt;lcnbmp_lock
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Exiting.&quot;
)paren
suffix:semicolon
r_return
id|nr_free
suffix:semicolon
)brace
multiline_comment|/**&n; * get_nr_free_mft_records - return the number of free inodes on a volume&n; * @vol:&t;ntfs volume for which to obtain free inode count&n; *&n; * Calculate the number of free mft records (inodes) on the mounted NTFS&n; * volume @vol.&n; *&n; * Errors are ignored and we just return the number of free inodes we have&n; * found. This means we return an underestimate on error.&n; */
DECL|function|get_nr_free_mft_records
id|s64
id|get_nr_free_mft_records
c_func
(paren
id|ntfs_volume
op_star
id|vol
)paren
(brace
r_struct
id|address_space
op_star
id|mapping
suffix:semicolon
id|filler_t
op_star
id|readpage
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
r_int
r_int
id|index
comma
id|max_index
suffix:semicolon
r_int
r_int
id|max_size
comma
id|i
suffix:semicolon
id|s64
id|nr_free
op_assign
l_int|0LL
suffix:semicolon
id|u32
op_star
id|b
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Entering.&quot;
)paren
suffix:semicolon
multiline_comment|/* Serialize accesses to the inode bitmap. */
id|down_read
c_func
(paren
op_amp
id|vol-&gt;mftbmp_lock
)paren
suffix:semicolon
id|mapping
op_assign
op_amp
id|vol-&gt;mftbmp_mapping
suffix:semicolon
id|readpage
op_assign
(paren
id|filler_t
op_star
)paren
id|mapping-&gt;a_ops-&gt;readpage
suffix:semicolon
multiline_comment|/*&n;&t; * Convert the number of bits into bytes rounded up, then convert into&n;&t; * multiples of PAGE_CACHE_SIZE.&n;&t; */
id|max_index
op_assign
(paren
id|vol
op_member_access_from_pointer
id|_VMM
c_func
(paren
id|nr_mft_records
)paren
op_plus
l_int|7
)paren
op_rshift
(paren
l_int|3
op_plus
id|PAGE_CACHE_SHIFT
)paren
suffix:semicolon
multiline_comment|/* Use multiples of 4 bytes. */
id|max_size
op_assign
id|PAGE_CACHE_SIZE
op_rshift
l_int|2
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Reading $MFT/$BITMAP, max_index = 0x%lx, max_size = &quot;
l_string|&quot;0x%x.&quot;
comma
id|max_index
comma
id|max_size
)paren
suffix:semicolon
r_for
c_loop
(paren
id|index
op_assign
l_int|0UL
suffix:semicolon
id|index
OL
id|max_index
suffix:semicolon
)paren
(brace
id|handle_partial_page
suffix:colon
multiline_comment|/*&n;&t;&t; * Read the page from page cache, getting it from backing store&n;&t;&t; * if necessary, and increment the use count.&n;&t;&t; */
id|page
op_assign
id|read_cache_page
c_func
(paren
id|mapping
comma
id|index
op_increment
comma
(paren
id|filler_t
op_star
)paren
id|readpage
comma
id|vol
)paren
suffix:semicolon
multiline_comment|/* Ignore pages which errored synchronously. */
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|page
)paren
)paren
(brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Sync read_cache_page() error. Skipping &quot;
l_string|&quot;page (index 0x%lx).&quot;
comma
id|index
op_minus
l_int|1
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|wait_on_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|Page_Uptodate
c_func
(paren
id|page
)paren
)paren
(brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Async read_cache_page() error. Skipping &quot;
l_string|&quot;page (index 0x%lx).&quot;
comma
id|index
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Ignore pages which errored asynchronously. */
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|b
op_assign
(paren
id|u32
op_star
)paren
id|kmap
c_func
(paren
id|page
)paren
suffix:semicolon
multiline_comment|/* For each 4 bytes, add up the number of zero bits. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|max_size
suffix:semicolon
id|i
op_increment
)paren
id|nr_free
op_add_assign
(paren
id|s64
)paren
(paren
l_int|32
op_minus
id|hweight32
c_func
(paren
id|b
(braket
id|i
)braket
)paren
)paren
suffix:semicolon
id|kunmap
c_func
(paren
id|page
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|index
op_eq
id|max_index
)paren
(brace
multiline_comment|/*&n;&t;&t; * Get the multiples of 4 bytes in use in the final partial&n;&t;&t; * page.&n;&t;&t; */
id|max_size
op_assign
(paren
(paren
(paren
(paren
id|vol
op_member_access_from_pointer
id|_VMM
c_func
(paren
id|nr_mft_records
)paren
op_plus
l_int|7
)paren
op_rshift
l_int|3
)paren
op_amp
op_complement
id|PAGE_CACHE_MASK
)paren
op_plus
l_int|3
)paren
op_rshift
l_int|2
suffix:semicolon
multiline_comment|/* If there is a partial page go back and do it. */
r_if
c_cond
(paren
id|max_size
)paren
(brace
multiline_comment|/* Compensate for out of bounds zero bits. */
r_if
c_cond
(paren
(paren
id|i
op_assign
id|vol
op_member_access_from_pointer
id|_VMM
c_func
(paren
id|nr_mft_records
)paren
op_amp
l_int|31
)paren
)paren
id|nr_free
op_sub_assign
(paren
id|s64
)paren
(paren
l_int|32
op_minus
id|i
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Handling partial page, max_size = 0x%x&quot;
comma
id|max_size
)paren
suffix:semicolon
r_goto
id|handle_partial_page
suffix:semicolon
)brace
)brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Finished reading $MFT/$BITMAP, last index = 0x%lx&quot;
comma
id|index
op_minus
l_int|1
)paren
suffix:semicolon
id|up_read
c_func
(paren
op_amp
id|vol-&gt;mftbmp_lock
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Exiting.&quot;
)paren
suffix:semicolon
r_return
id|nr_free
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_statfs - return information about mounted NTFS volume&n; * @sb:&t;&t;super block of mounted volume&n; * @sfs:&t;statfs structure in which to return the information&n; *&n; * Return information about the mounted NTFS volume @sb in the statfs structure&n; * pointed to by @sfs (this is initialized with zeros before ntfs_statfs is&n; * called). We interpret the values to be correct of the moment in time at&n; * which we are called. Most values are variable otherwise and this isn&squot;t just&n; * the free values but the totals as well. For example we can increase the&n; * total number of file nodes if we run out and we can keep doing this until&n; * there is no more space on the volume left at all.&n; *&n; * Called from vfs_statfs which is used to handle the statfs, fstatfs, and&n; * ustat system calls.&n; *&n; * Return 0 on success or -errno on error.&n; */
DECL|function|ntfs_statfs
r_int
id|ntfs_statfs
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_struct
id|statfs
op_star
id|sfs
)paren
(brace
id|ntfs_volume
op_star
id|vol
op_assign
id|NTFS_SB
c_func
(paren
id|sb
)paren
suffix:semicolon
id|s64
id|size
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Entering.&quot;
)paren
suffix:semicolon
multiline_comment|/* Type of filesystem. */
id|sfs-&gt;f_type
op_assign
id|NTFS_SB_MAGIC
suffix:semicolon
multiline_comment|/* Optimal transfer block size. */
id|sfs-&gt;f_bsize
op_assign
id|PAGE_CACHE_SIZE
suffix:semicolon
multiline_comment|/*&n;&t; * Total data blocks in file system in units of f_bsize and since&n;&t; * inodes are also stored in data blocs ($MFT is a file) this is just&n;&t; * the total clusters.&n;&t; */
id|sfs-&gt;f_blocks
op_assign
id|vol
op_member_access_from_pointer
id|_VCL
c_func
(paren
id|nr_clusters
)paren
op_lshift
id|vol-&gt;cluster_size_bits
op_rshift
id|PAGE_CACHE_SHIFT
suffix:semicolon
multiline_comment|/* Free data blocks in file system in units of f_bsize. */
id|size
op_assign
id|get_nr_free_clusters
c_func
(paren
id|vol
)paren
op_lshift
id|vol-&gt;cluster_size_bits
op_rshift
id|PAGE_CACHE_SHIFT
suffix:semicolon
r_if
c_cond
(paren
id|size
OL
l_int|0LL
)paren
id|size
op_assign
l_int|0LL
suffix:semicolon
multiline_comment|/* Free blocks avail to non-superuser, same as above on NTFS. */
id|sfs-&gt;f_bavail
op_assign
id|sfs-&gt;f_bfree
op_assign
id|size
suffix:semicolon
multiline_comment|/* Total file nodes in file system (at this moment in time). */
id|sfs-&gt;f_files
op_assign
id|vol-&gt;mft_ino-&gt;i_size
op_rshift
id|vol-&gt;mft_record_size_bits
suffix:semicolon
multiline_comment|/* Free file nodes in fs (based on current total count). */
id|size
op_assign
id|get_nr_free_mft_records
c_func
(paren
id|vol
)paren
suffix:semicolon
r_if
c_cond
(paren
id|size
OL
l_int|0LL
)paren
id|size
op_assign
l_int|0LL
suffix:semicolon
id|sfs-&gt;f_ffree
op_assign
id|size
suffix:semicolon
multiline_comment|/*&n;&t; * File system id. This is extremely *nix flavour dependent and even&n;&t; * within Linux itself all fs do their own thing. I interpret this to&n;&t; * mean a unique id associated with the mounted fs and not the id&n;&t; * associated with the file system driver, the latter is already given&n;&t; * by the file system type in sfs-&gt;f_type. Thus we use the 64-bit&n;&t; * volume serial number splitting it into two 32-bit parts. We enter&n;&t; * the least significant 32-bits in f_fsid[0] and the most significant&n;&t; * 32-bits in f_fsid[1].&n;&t; */
id|sfs-&gt;f_fsid.val
(braket
l_int|0
)braket
op_assign
id|vol-&gt;serial_no
op_amp
l_int|0xffffffff
suffix:semicolon
id|sfs-&gt;f_fsid.val
(braket
l_int|1
)braket
op_assign
(paren
id|vol-&gt;serial_no
op_rshift
l_int|32
)paren
op_amp
l_int|0xffffffff
suffix:semicolon
multiline_comment|/* Maximum length of filenames. */
id|sfs-&gt;f_namelen
op_assign
id|NTFS_MAX_NAME_LEN
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * Super operations for mount time when we don&squot;t have enough setup to use the&n; * proper functions.&n; */
DECL|variable|ntfs_mount_sops
r_struct
id|super_operations
id|ntfs_mount_sops
op_assign
(brace
id|alloc_inode
suffix:colon
id|ntfs_alloc_big_inode
comma
multiline_comment|/* VFS: Allocate a new inode. */
id|destroy_inode
suffix:colon
id|ntfs_destroy_big_inode
comma
multiline_comment|/* VFS: Deallocate an inode. */
id|read_inode
suffix:colon
id|ntfs_read_inode_mount
comma
multiline_comment|/* VFS: Load inode from disk,&n;&t;&t;&t;&t;&t;&t;   called from iget(). */
id|clear_inode
suffix:colon
id|ntfs_clear_big_inode
comma
multiline_comment|/* VFS: Called when an inode is&n;&t;&t;&t;&t;&t;&t;   removed from memory. */
)brace
suffix:semicolon
multiline_comment|/**&n; * The complete super operations.&n; */
DECL|variable|ntfs_sops
r_struct
id|super_operations
id|ntfs_sops
op_assign
(brace
id|alloc_inode
suffix:colon
id|ntfs_alloc_big_inode
comma
multiline_comment|/* VFS: Allocate a new inode. */
id|destroy_inode
suffix:colon
id|ntfs_destroy_big_inode
comma
multiline_comment|/* VFS: Deallocate an inode. */
id|read_inode
suffix:colon
id|ntfs_read_inode
comma
multiline_comment|/* VFS: Load inode from disk,&n;&t;&t;&t;&t;&t;&t;   called from iget(). */
id|dirty_inode
suffix:colon
id|ntfs_dirty_inode
comma
multiline_comment|/* VFS: Called from&n;&t;&t;&t;&t;&t;&t;   __mark_inode_dirty(). */
id|write_inode
suffix:colon
l_int|NULL
comma
multiline_comment|/* VFS: Write dirty inode to disk. */
id|put_inode
suffix:colon
l_int|NULL
comma
multiline_comment|/* VFS: Called whenever the reference&n;&t;&t;&t;&t;&t;   count (i_count) of the inode is&n;&t;&t;&t;&t;&t;   going to be decreased but before the&n;&t;&t;&t;&t;&t;   actual decrease. */
id|delete_inode
suffix:colon
l_int|NULL
comma
multiline_comment|/* VFS: Delete inode from disk. Called&n;&t;&t;&t;&t;&t;   when i_count becomes 0 and i_nlink is&n;&t;&t;&t;&t;&t;   also 0. */
id|put_super
suffix:colon
id|ntfs_put_super
comma
multiline_comment|/* Syscall: umount. */
id|write_super
suffix:colon
l_int|NULL
comma
multiline_comment|/* Flush dirty super block to disk. */
id|write_super_lockfs
suffix:colon
l_int|NULL
comma
multiline_comment|/* ? */
id|unlockfs
suffix:colon
l_int|NULL
comma
multiline_comment|/* ? */
id|statfs
suffix:colon
id|ntfs_statfs
comma
multiline_comment|/* Syscall: statfs */
id|remount_fs
suffix:colon
id|ntfs_remount
comma
multiline_comment|/* Syscall: mount -o remount. */
id|clear_inode
suffix:colon
id|ntfs_clear_big_inode
comma
multiline_comment|/* VFS: Called when an inode is&n;&t;&t;&t;&t;&t;&t;   removed from memory. */
id|umount_begin
suffix:colon
l_int|NULL
comma
multiline_comment|/* Forced umount. */
multiline_comment|/*&n;&t; * These are NFSd support functions but NTFS is a standard fs so&n;&t; * shouldn&squot;t need to implement these manually. At least we can try&n;&t; * without and if it doesn&squot;t work in some way we can always implement&n;&t; * something here.&n;&t; */
id|fh_to_dentry
suffix:colon
l_int|NULL
comma
multiline_comment|/* Get dentry for given file handle. */
id|dentry_to_fh
suffix:colon
l_int|NULL
comma
multiline_comment|/* Get file handle for given dentry. */
id|show_options
suffix:colon
id|ntfs_show_options
comma
multiline_comment|/* Show mount options in proc. */
)brace
suffix:semicolon
multiline_comment|/**&n; * ntfs_fill_super - mount an ntfs files system&n; * @sb:&t;&t;super block of ntfs file system to mount&n; * @opt:&t;string containing the mount options&n; * @silent:&t;silence error output&n; *&n; * ntfs_fill_super() is called by the VFS to mount the device described by @sb&n; * with the mount otions in @data with the NTFS file system.&n; *&n; * If @silent is true, remain silent even if errors are detected. This is used&n; * during bootup, when the kernel tries to mount the root file system with all&n; * registered file systems one after the other until one succeeds. This implies&n; * that all file systems except the correct one will quite correctly and&n; * expectedly return an error, but nobody wants to see error messages when in&n; * fact this is what is supposed to happen.&n; *&n; * NOTE: @sb-&gt;s_flags contains the mount options flags.&n; */
DECL|function|ntfs_fill_super
r_static
r_int
id|ntfs_fill_super
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_void
op_star
id|opt
comma
r_const
r_int
id|silent
)paren
(brace
r_extern
r_int
op_star
id|blksize_size
(braket
)braket
suffix:semicolon
id|ntfs_volume
op_star
id|vol
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
r_struct
id|inode
op_star
id|tmp_ino
suffix:semicolon
r_int
id|old_blocksize
comma
id|result
suffix:semicolon
id|kdev_t
id|dev
op_assign
id|sb-&gt;s_dev
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Entering.&quot;
)paren
suffix:semicolon
multiline_comment|/* Allocate a new ntfs_volume and place it in sb-&gt;u.generic_sbp. */
id|sb-&gt;u.generic_sbp
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|ntfs_volume
)paren
comma
id|GFP_NOFS
)paren
suffix:semicolon
id|vol
op_assign
id|NTFS_SB
c_func
(paren
id|sb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vol
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|silent
)paren
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Allocation of NTFS volume structure &quot;
l_string|&quot;failed. Aborting mount...&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
multiline_comment|/* Initialize ntfs_volume structure. */
id|memset
c_func
(paren
id|vol
comma
l_int|0
comma
r_sizeof
(paren
id|ntfs_volume
)paren
)paren
suffix:semicolon
id|vol-&gt;sb
op_assign
id|sb
suffix:semicolon
id|vol-&gt;upcase
op_assign
l_int|NULL
suffix:semicolon
id|vol-&gt;mft_ino
op_assign
l_int|NULL
suffix:semicolon
id|init_rwsem
c_func
(paren
op_amp
id|vol-&gt;mftbmp_lock
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|vol-&gt;mftbmp_mapping.clean_pages
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|vol-&gt;mftbmp_mapping.dirty_pages
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|vol-&gt;mftbmp_mapping.locked_pages
)paren
suffix:semicolon
id|vol-&gt;mftbmp_mapping.a_ops
op_assign
l_int|NULL
suffix:semicolon
id|vol-&gt;mftbmp_mapping.host
op_assign
l_int|NULL
suffix:semicolon
macro_line|#if LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,5,6)
id|vol-&gt;mftbmp_mapping.i_mmap
op_assign
l_int|NULL
suffix:semicolon
id|vol-&gt;mftbmp_mapping.i_mmap_shared
op_assign
l_int|NULL
suffix:semicolon
macro_line|#else
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|vol-&gt;mftbmp_mapping.i_mmap
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|vol-&gt;mftbmp_mapping.i_mmap_shared
)paren
suffix:semicolon
macro_line|#endif
id|spin_lock_init
c_func
(paren
op_amp
id|vol-&gt;mftbmp_mapping.i_shared_lock
)paren
suffix:semicolon
id|INIT_RUN_LIST
c_func
(paren
op_amp
id|vol-&gt;mftbmp_rl
)paren
suffix:semicolon
id|vol-&gt;mftmirr_ino
op_assign
l_int|NULL
suffix:semicolon
id|vol-&gt;lcnbmp_ino
op_assign
l_int|NULL
suffix:semicolon
id|init_rwsem
c_func
(paren
op_amp
id|vol-&gt;lcnbmp_lock
)paren
suffix:semicolon
id|vol-&gt;vol_ino
op_assign
l_int|NULL
suffix:semicolon
id|vol-&gt;root_ino
op_assign
l_int|NULL
suffix:semicolon
id|vol-&gt;secure_ino
op_assign
l_int|NULL
suffix:semicolon
id|vol-&gt;uid
op_assign
id|vol-&gt;gid
op_assign
l_int|0
suffix:semicolon
id|vol-&gt;on_errors
op_assign
l_int|0
suffix:semicolon
id|vol-&gt;mft_zone_multiplier
op_assign
l_int|0
suffix:semicolon
id|vol-&gt;nls_map
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * Default is group and other don&squot;t have write/execute access to files&n;&t; * and write access to directories.&n;&t; */
id|vol-&gt;fmask
op_assign
l_int|0033
suffix:semicolon
id|vol-&gt;dmask
op_assign
l_int|0022
suffix:semicolon
multiline_comment|/*&n;&t; * Default is to show long file names (including POSIX file names), and&n;&t; * not to show system files and short file names.&n;&t; */
id|vol-&gt;readdir_opts
op_assign
id|SHOW_WIN32
suffix:semicolon
multiline_comment|/* Important to get the mount options dealt with now. */
r_if
c_cond
(paren
op_logical_neg
id|parse_options
c_func
(paren
id|vol
comma
(paren
r_char
op_star
)paren
id|opt
)paren
)paren
r_goto
id|err_out_now
suffix:semicolon
multiline_comment|/* We are just a read-only fs at the moment. */
id|sb-&gt;s_flags
op_or_assign
id|MS_RDONLY
op_or
id|MS_NOATIME
op_or
id|MS_NODIRATIME
suffix:semicolon
multiline_comment|/*&n;&t; * TODO: Fail safety check. In the future we should really be able to&n;&t; * cope with this being the case, but for now just bail out.&n;&t; */
r_if
c_cond
(paren
id|get_hardsect_size
c_func
(paren
id|dev
)paren
OG
id|NTFS_BLOCK_SIZE
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|silent
)paren
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Device has unsupported hardsect_size.&quot;
)paren
suffix:semicolon
r_goto
id|err_out_now
suffix:semicolon
)brace
multiline_comment|/* Setup the device access block size to NTFS_BLOCK_SIZE. */
r_if
c_cond
(paren
op_logical_neg
id|blksize_size
(braket
id|major
c_func
(paren
id|dev
)paren
)braket
)paren
id|old_blocksize
op_assign
id|BLOCK_SIZE
suffix:semicolon
r_else
id|old_blocksize
op_assign
id|blksize_size
(braket
id|major
c_func
(paren
id|dev
)paren
)braket
(braket
id|minor
c_func
(paren
id|dev
)paren
)braket
suffix:semicolon
r_if
c_cond
(paren
id|sb_set_blocksize
c_func
(paren
id|sb
comma
id|NTFS_BLOCK_SIZE
)paren
op_ne
id|NTFS_BLOCK_SIZE
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|silent
)paren
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Unable to set block size.&quot;
)paren
suffix:semicolon
r_goto
id|set_blk_size_err_out_now
suffix:semicolon
)brace
multiline_comment|/* Get the size of the device in units of NTFS_BLOCK_SIZE bytes. */
id|vol-&gt;nr_blocks
op_assign
id|sb-&gt;s_bdev-&gt;bd_inode-&gt;i_size
op_rshift
id|NTFS_BLOCK_SIZE_BITS
suffix:semicolon
multiline_comment|/* Read the boot sector and return unlocked buffer head to it. */
r_if
c_cond
(paren
op_logical_neg
(paren
id|bh
op_assign
id|read_ntfs_boot_sector
c_func
(paren
id|sb
comma
id|silent
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|silent
)paren
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Not an NTFS volume.&quot;
)paren
suffix:semicolon
r_goto
id|set_blk_size_err_out_now
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Extract the data from the boot sector and setup the ntfs super block&n;&t; * using it.&n;&t; */
id|result
op_assign
id|parse_ntfs_boot_sector
c_func
(paren
id|vol
comma
(paren
id|NTFS_BOOT_SECTOR
op_star
)paren
id|bh-&gt;b_data
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|result
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|silent
)paren
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Unsupported NTFS filesystem.&quot;
)paren
suffix:semicolon
r_goto
id|set_blk_size_err_out_now
suffix:semicolon
)brace
multiline_comment|/* &n;&t; * TODO: When we start coping with sector sizes different from&n;&t; * NTFS_BLOCK_SIZE, we now probably need to set the blocksize of the&n;&t; * device (probably to NTFS_BLOCK_SIZE).&n;&t; */
multiline_comment|/* Setup remaining fields in the super block. */
id|sb-&gt;s_magic
op_assign
id|NTFS_SB_MAGIC
suffix:semicolon
multiline_comment|/*&n;&t; * Ntfs allows 63 bits for the file size, i.e. correct would be:&n;&t; * &t;sb-&gt;s_maxbytes = ~0ULL &gt;&gt; 1;&n;&t; * But the kernel uses a long as the page cache page index which on&n;&t; * 32-bit architectures is only 32-bits. MAX_LFS_FILESIZE is kernel&n;&t; * defined to the maximum the page cache page index can cope with&n;&t; * without overflowing the index or to 2^63 - 1, whichever is smaller.&n;&t; */
id|sb-&gt;s_maxbytes
op_assign
id|MAX_LFS_FILESIZE
suffix:semicolon
multiline_comment|/*&n;&t; * Now load the metadata required for the page cache and our address&n;&t; * space operations to function. We do this by setting up a specialised&n;&t; * read_inode method and then just calling iget() to obtain the inode&n;&t; * for $MFT which is sufficient to allow our normal inode operations&n;&t; * and associated address space operations to function.&n;&t; */
multiline_comment|/*&n;&t; * Poison vol-&gt;mft_ino so we know whether iget() called into our&n;&t; * ntfs_read_inode_mount() method.&n;&t; */
DECL|macro|OGIN
mdefine_line|#define OGIN&t;((struct inode*)le32_to_cpu(0x4e49474f))&t;/* OGIN */
id|vol-&gt;mft_ino
op_assign
id|OGIN
suffix:semicolon
id|sb-&gt;s_op
op_assign
op_amp
id|ntfs_mount_sops
suffix:semicolon
id|tmp_ino
op_assign
id|iget
c_func
(paren
id|vol-&gt;sb
comma
id|FILE_MFT
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tmp_ino
op_logical_or
id|tmp_ino
op_ne
id|vol-&gt;mft_ino
op_logical_or
id|is_bad_inode
c_func
(paren
id|tmp_ino
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|silent
)paren
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Failed to load essential metadata.&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp_ino
op_logical_and
id|vol-&gt;mft_ino
op_eq
id|OGIN
)paren
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;BUG: iget() did not call &quot;
l_string|&quot;ntfs_read_inode_mount() method!&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tmp_ino
)paren
r_goto
id|cond_iput_mft_ino_err_out_now
suffix:semicolon
r_goto
id|iput_tmp_ino_err_out_now
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Note: sb-&gt;s_op has already been set to &amp;ntfs_sops by our specialized&n;&t; * ntfs_read_inode_mount() method when it was invoked by iget().&n;&t; */
id|down
c_func
(paren
op_amp
id|ntfs_lock
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * The current mount is a compression user if the cluster size is&n;&t; * less than or equal 4kiB.&n;&t; */
r_if
c_cond
(paren
id|vol-&gt;cluster_size
op_le
l_int|4096
op_logical_and
op_logical_neg
id|ntfs_nr_compression_users
op_increment
)paren
(brace
id|result
op_assign
id|allocate_compression_buffers
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
)paren
(brace
id|ntfs_error
c_func
(paren
l_int|NULL
comma
l_string|&quot;Failed to allocate per CPU buffers &quot;
l_string|&quot;for compression engine.&quot;
)paren
suffix:semicolon
id|ntfs_nr_compression_users
op_decrement
suffix:semicolon
id|up
c_func
(paren
op_amp
id|ntfs_lock
)paren
suffix:semicolon
r_goto
id|iput_tmp_ino_err_out_now
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Increment the number of mounts and generate the global default&n;&t; * upcase table if necessary. Also temporarily increment the number of&n;&t; * upcase users to avoid race conditions with concurrent (u)mounts.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|ntfs_nr_mounts
op_increment
)paren
id|default_upcase
op_assign
id|generate_default_upcase
c_func
(paren
)paren
suffix:semicolon
id|ntfs_nr_upcase_users
op_increment
suffix:semicolon
id|up
c_func
(paren
op_amp
id|ntfs_lock
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * From now on, ignore @silent parameter. If we fail below this line,&n;&t; * it will be due to a corrupt fs or a system error, so we report it.&n;&t; */
multiline_comment|/*&n;&t; * Open the system files with normal access functions and complete&n;&t; * setting up the ntfs super block.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|load_system_files
c_func
(paren
id|vol
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Failed to load system files.&quot;
)paren
suffix:semicolon
r_goto
id|unl_upcase_iput_tmp_ino_err_out_now
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|sb-&gt;s_root
op_assign
id|d_alloc_root
c_func
(paren
id|vol-&gt;root_ino
)paren
)paren
)paren
(brace
multiline_comment|/* We increment i_count simulating an iget(). */
id|atomic_inc
c_func
(paren
op_amp
id|vol-&gt;root_ino-&gt;i_count
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Exiting, status successful.&quot;
)paren
suffix:semicolon
multiline_comment|/* Release the default upcase if it has no users. */
id|down
c_func
(paren
op_amp
id|ntfs_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_decrement
id|ntfs_nr_upcase_users
op_logical_and
id|default_upcase
)paren
(brace
id|ntfs_free
c_func
(paren
id|default_upcase
)paren
suffix:semicolon
id|default_upcase
op_assign
l_int|NULL
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|ntfs_lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Failed to allocate root directory.&quot;
)paren
suffix:semicolon
multiline_comment|/* Clean up after the successful load_system_files() call from above. */
id|iput
c_func
(paren
id|vol-&gt;vol_ino
)paren
suffix:semicolon
id|vol-&gt;vol_ino
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* NTFS 3.0+ specific clean up. */
r_if
c_cond
(paren
id|vol-&gt;major_ver
op_ge
l_int|3
)paren
(brace
id|iput
c_func
(paren
id|vol-&gt;secure_ino
)paren
suffix:semicolon
id|vol-&gt;secure_ino
op_assign
l_int|NULL
suffix:semicolon
)brace
id|iput
c_func
(paren
id|vol-&gt;root_ino
)paren
suffix:semicolon
id|vol-&gt;root_ino
op_assign
l_int|NULL
suffix:semicolon
id|iput
c_func
(paren
id|vol-&gt;lcnbmp_ino
)paren
suffix:semicolon
id|vol-&gt;lcnbmp_ino
op_assign
l_int|NULL
suffix:semicolon
id|iput
c_func
(paren
id|vol-&gt;mftmirr_ino
)paren
suffix:semicolon
id|vol-&gt;mftmirr_ino
op_assign
l_int|NULL
suffix:semicolon
id|truncate_inode_pages
c_func
(paren
op_amp
id|vol-&gt;mftbmp_mapping
comma
l_int|0
)paren
suffix:semicolon
id|vol-&gt;mftbmp_mapping.a_ops
op_assign
l_int|NULL
suffix:semicolon
id|vol-&gt;mftbmp_mapping.host
op_assign
l_int|NULL
suffix:semicolon
id|ntfs_free
c_func
(paren
id|vol-&gt;mftbmp_rl.rl
)paren
suffix:semicolon
id|vol-&gt;mftbmp_rl.rl
op_assign
l_int|NULL
suffix:semicolon
id|vol-&gt;upcase_len
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|vol-&gt;upcase
op_ne
id|default_upcase
)paren
id|ntfs_free
c_func
(paren
id|vol-&gt;upcase
)paren
suffix:semicolon
id|vol-&gt;upcase
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|vol-&gt;nls_map
)paren
(brace
id|unload_nls
c_func
(paren
id|vol-&gt;nls_map
)paren
suffix:semicolon
id|vol-&gt;nls_map
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Error exit code path. */
id|unl_upcase_iput_tmp_ino_err_out_now
suffix:colon
multiline_comment|/*&n;&t; * Decrease the number of mounts and destroy the global default upcase&n;&t; * table if necessary.&n;&t; */
id|down
c_func
(paren
op_amp
id|ntfs_lock
)paren
suffix:semicolon
id|ntfs_nr_mounts
op_decrement
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_decrement
id|ntfs_nr_upcase_users
op_logical_and
id|default_upcase
)paren
(brace
id|ntfs_free
c_func
(paren
id|default_upcase
)paren
suffix:semicolon
id|default_upcase
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|vol-&gt;cluster_size
op_le
l_int|4096
op_logical_and
op_logical_neg
op_decrement
id|ntfs_nr_compression_users
)paren
id|free_compression_buffers
c_func
(paren
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|ntfs_lock
)paren
suffix:semicolon
id|iput_tmp_ino_err_out_now
suffix:colon
id|iput
c_func
(paren
id|tmp_ino
)paren
suffix:semicolon
id|cond_iput_mft_ino_err_out_now
suffix:colon
r_if
c_cond
(paren
id|vol-&gt;mft_ino
op_logical_and
id|vol-&gt;mft_ino
op_ne
id|OGIN
op_logical_and
id|vol-&gt;mft_ino
op_ne
id|tmp_ino
)paren
(brace
id|iput
c_func
(paren
id|vol-&gt;mft_ino
)paren
suffix:semicolon
id|vol-&gt;mft_ino
op_assign
l_int|NULL
suffix:semicolon
)brace
DECL|macro|OGIN
macro_line|#undef OGIN
multiline_comment|/*&n;&t; * This is needed to get ntfs_clear_inode() called for each inode we&n;&t; * have ever called iget()/iput() on, otherwise we A) leak resources&n;&t; * and B) a subsequent mount fails automatically due to iget() never&n;&t; * calling down into our ntfs_read_inode{_mount}() methods again...&n;&t; */
r_if
c_cond
(paren
id|invalidate_inodes
c_func
(paren
id|sb
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Busy inodes left. This is most likely a NTFS &quot;
l_string|&quot;driver bug.&quot;
)paren
suffix:semicolon
multiline_comment|/* Copied from fs/super.c. I just love this message. (-; */
id|printk
c_func
(paren
l_string|&quot;VFS: Busy inodes after umount. Self-destruct in 5 &quot;
l_string|&quot;seconds.  Have a nice day...&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|set_blk_size_err_out_now
suffix:colon
multiline_comment|/* Errors at this stage are irrelevant. */
id|sb_set_blocksize
c_func
(paren
id|sb
comma
id|old_blocksize
)paren
suffix:semicolon
id|err_out_now
suffix:colon
id|sb-&gt;u.generic_sbp
op_assign
l_int|NULL
suffix:semicolon
id|kfree
c_func
(paren
id|vol
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Failed, returning -EINVAL.&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/*&n; * This is a slab cache to optimize allocations and deallocations of Unicode&n; * strings of the maximum length allowed by NTFS, which is NTFS_MAX_NAME_LEN&n; * (255) Unicode characters + a terminating NULL Unicode character.&n; */
DECL|variable|ntfs_name_cache
id|kmem_cache_t
op_star
id|ntfs_name_cache
suffix:semicolon
multiline_comment|/* Slab caches for efficient allocation/deallocation of of inodes. */
DECL|variable|ntfs_inode_cache
id|kmem_cache_t
op_star
id|ntfs_inode_cache
suffix:semicolon
DECL|variable|ntfs_big_inode_cache
id|kmem_cache_t
op_star
id|ntfs_big_inode_cache
suffix:semicolon
multiline_comment|/* Init once constructor for the inode slab cache. */
DECL|function|ntfs_big_inode_init_once
r_static
r_void
id|ntfs_big_inode_init_once
c_func
(paren
r_void
op_star
id|foo
comma
id|kmem_cache_t
op_star
id|cachep
comma
r_int
r_int
id|flags
)paren
(brace
id|ntfs_inode
op_star
id|ni
op_assign
(paren
id|ntfs_inode
op_star
)paren
id|foo
suffix:semicolon
r_if
c_cond
(paren
(paren
id|flags
op_amp
(paren
id|SLAB_CTOR_VERIFY
op_or
id|SLAB_CTOR_CONSTRUCTOR
)paren
)paren
op_eq
id|SLAB_CTOR_CONSTRUCTOR
)paren
id|inode_init_once
c_func
(paren
id|VFS_I
c_func
(paren
id|ni
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Slab cache to optimize allocations and deallocations of attribute search&n; * contexts.&n; */
DECL|variable|ntfs_attr_ctx_cache
id|kmem_cache_t
op_star
id|ntfs_attr_ctx_cache
suffix:semicolon
multiline_comment|/* A global default upcase table and a corresponding reference count. */
DECL|variable|default_upcase
m_wchar_t
op_star
id|default_upcase
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|ntfs_nr_upcase_users
r_int
r_int
id|ntfs_nr_upcase_users
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* The number of mounted filesystems. */
DECL|variable|ntfs_nr_mounts
r_int
r_int
id|ntfs_nr_mounts
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Driver wide semaphore. */
DECL|variable|ntfs_lock
id|DECLARE_MUTEX
c_func
(paren
id|ntfs_lock
)paren
suffix:semicolon
DECL|function|ntfs_get_sb
r_static
r_struct
id|super_block
op_star
id|ntfs_get_sb
c_func
(paren
r_struct
id|file_system_type
op_star
id|fs_type
comma
r_int
id|flags
comma
r_char
op_star
id|dev_name
comma
r_void
op_star
id|data
)paren
(brace
r_return
id|get_sb_bdev
c_func
(paren
id|fs_type
comma
id|flags
comma
id|dev_name
comma
id|data
comma
id|ntfs_fill_super
)paren
suffix:semicolon
)brace
DECL|variable|ntfs_fs_type
r_static
r_struct
id|file_system_type
id|ntfs_fs_type
op_assign
(brace
id|owner
suffix:colon
id|THIS_MODULE
comma
id|name
suffix:colon
l_string|&quot;ntfs&quot;
comma
id|get_sb
suffix:colon
id|ntfs_get_sb
comma
id|fs_flags
suffix:colon
id|FS_REQUIRES_DEV
comma
)brace
suffix:semicolon
multiline_comment|/* Stable names for the slab caches. */
DECL|variable|ntfs_attr_ctx_cache_name
r_static
r_const
r_char
op_star
id|ntfs_attr_ctx_cache_name
op_assign
l_string|&quot;ntfs_attr_ctx_cache&quot;
suffix:semicolon
DECL|variable|ntfs_name_cache_name
r_static
r_const
r_char
op_star
id|ntfs_name_cache_name
op_assign
l_string|&quot;ntfs_name_cache&quot;
suffix:semicolon
DECL|variable|ntfs_inode_cache_name
r_static
r_const
r_char
op_star
id|ntfs_inode_cache_name
op_assign
l_string|&quot;ntfs_inode_cache&quot;
suffix:semicolon
DECL|variable|ntfs_big_inode_cache_name
r_static
r_const
r_char
op_star
id|ntfs_big_inode_cache_name
op_assign
l_string|&quot;ntfs_big_inode_cache&quot;
suffix:semicolon
DECL|function|init_ntfs_fs
r_static
r_int
id|__init
id|init_ntfs_fs
c_func
(paren
r_void
)paren
(brace
r_int
id|err
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* This may be ugly but it results in pretty output so who cares. (-8 */
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;NTFS driver &quot;
id|NTFS_VERSION
l_string|&quot; [Flags: R/&quot;
macro_line|#ifdef CONFIG_NTFS_RW
l_string|&quot;W&quot;
macro_line|#else
l_string|&quot;O&quot;
macro_line|#endif
macro_line|#ifdef DEBUG
l_string|&quot; DEBUG&quot;
macro_line|#endif
macro_line|#ifdef MODULE
l_string|&quot; MODULE&quot;
macro_line|#endif
l_string|&quot;]. Copyright (c) 2001 Anton Altaparmakov.&bslash;n&quot;
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Debug messages are enabled.&quot;
)paren
suffix:semicolon
id|ntfs_attr_ctx_cache
op_assign
id|kmem_cache_create
c_func
(paren
id|ntfs_attr_ctx_cache_name
comma
r_sizeof
(paren
id|attr_search_context
)paren
comma
l_int|0
multiline_comment|/* offset */
comma
id|SLAB_HWCACHE_ALIGN
comma
l_int|NULL
multiline_comment|/* ctor */
comma
l_int|NULL
multiline_comment|/* dtor */
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ntfs_attr_ctx_cache
)paren
(brace
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;NTFS: Failed to create %s!&bslash;n&quot;
comma
id|ntfs_attr_ctx_cache_name
)paren
suffix:semicolon
r_goto
id|ctx_err_out
suffix:semicolon
)brace
id|ntfs_name_cache
op_assign
id|kmem_cache_create
c_func
(paren
id|ntfs_name_cache_name
comma
(paren
id|NTFS_MAX_NAME_LEN
op_plus
l_int|1
)paren
op_star
r_sizeof
(paren
id|uchar_t
)paren
comma
l_int|0
comma
id|SLAB_HWCACHE_ALIGN
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ntfs_name_cache
)paren
(brace
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;NTFS: Failed to create %s!&bslash;n&quot;
comma
id|ntfs_name_cache_name
)paren
suffix:semicolon
r_goto
id|name_err_out
suffix:semicolon
)brace
id|ntfs_inode_cache
op_assign
id|kmem_cache_create
c_func
(paren
id|ntfs_inode_cache_name
comma
r_sizeof
(paren
id|ntfs_inode
)paren
comma
l_int|0
comma
id|SLAB_HWCACHE_ALIGN
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ntfs_inode_cache
)paren
(brace
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;NTFS: Failed to create %s!&bslash;n&quot;
comma
id|ntfs_inode_cache_name
)paren
suffix:semicolon
r_goto
id|inode_err_out
suffix:semicolon
)brace
id|ntfs_big_inode_cache
op_assign
id|kmem_cache_create
c_func
(paren
id|ntfs_big_inode_cache_name
comma
r_sizeof
(paren
id|big_ntfs_inode
)paren
comma
l_int|0
comma
id|SLAB_HWCACHE_ALIGN
comma
id|ntfs_big_inode_init_once
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ntfs_big_inode_cache
)paren
(brace
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;NTFS: Failed to create %s!&bslash;n&quot;
comma
id|ntfs_big_inode_cache_name
)paren
suffix:semicolon
r_goto
id|big_inode_err_out
suffix:semicolon
)brace
multiline_comment|/* Register the ntfs sysctls. */
id|err
op_assign
id|ntfs_sysctl
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;NTFS: Failed to register NTFS sysctls!&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|sysctl_err_out
suffix:semicolon
)brace
id|err
op_assign
id|register_filesystem
c_func
(paren
op_amp
id|ntfs_fs_type
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|err
)paren
(brace
id|ntfs_debug
c_func
(paren
l_string|&quot;NTFS driver registered successfully.&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Success! */
)brace
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;NTFS: Failed to register NTFS file system driver!&bslash;n&quot;
)paren
suffix:semicolon
id|sysctl_err_out
suffix:colon
id|kmem_cache_destroy
c_func
(paren
id|ntfs_big_inode_cache
)paren
suffix:semicolon
id|big_inode_err_out
suffix:colon
id|kmem_cache_destroy
c_func
(paren
id|ntfs_inode_cache
)paren
suffix:semicolon
id|inode_err_out
suffix:colon
id|kmem_cache_destroy
c_func
(paren
id|ntfs_name_cache
)paren
suffix:semicolon
id|name_err_out
suffix:colon
id|kmem_cache_destroy
c_func
(paren
id|ntfs_attr_ctx_cache
)paren
suffix:semicolon
id|ctx_err_out
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|err
)paren
(brace
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;NTFS: Aborting NTFS file system driver &quot;
l_string|&quot;registration...&bslash;n&quot;
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_return
id|err
suffix:semicolon
)brace
DECL|function|exit_ntfs_fs
r_static
r_void
id|__exit
id|exit_ntfs_fs
c_func
(paren
r_void
)paren
(brace
r_int
id|err
op_assign
l_int|0
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Unregistering NTFS driver.&quot;
)paren
suffix:semicolon
id|unregister_filesystem
c_func
(paren
op_amp
id|ntfs_fs_type
)paren
suffix:semicolon
r_if
c_cond
(paren
id|kmem_cache_destroy
c_func
(paren
id|ntfs_big_inode_cache
)paren
op_logical_and
(paren
id|err
op_assign
l_int|1
)paren
)paren
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;NTFS: Failed to destory %s.&bslash;n&quot;
comma
id|ntfs_big_inode_cache_name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|kmem_cache_destroy
c_func
(paren
id|ntfs_inode_cache
)paren
op_logical_and
(paren
id|err
op_assign
l_int|1
)paren
)paren
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;NTFS: Failed to destory %s.&bslash;n&quot;
comma
id|ntfs_inode_cache_name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|kmem_cache_destroy
c_func
(paren
id|ntfs_name_cache
)paren
op_logical_and
(paren
id|err
op_assign
l_int|1
)paren
)paren
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;NTFS: Failed to destory %s.&bslash;n&quot;
comma
id|ntfs_name_cache_name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|kmem_cache_destroy
c_func
(paren
id|ntfs_attr_ctx_cache
)paren
op_logical_and
(paren
id|err
op_assign
l_int|1
)paren
)paren
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;NTFS: Failed to destory %s.&bslash;n&quot;
comma
id|ntfs_attr_ctx_cache_name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;NTFS: This causes memory to leak! There is &quot;
l_string|&quot;probably a BUG in the driver! Please report &quot;
l_string|&quot;you saw this message to &quot;
l_string|&quot;linux-ntfs-dev@lists.sf.net&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Unregister the ntfs sysctls. */
id|ntfs_sysctl
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
id|EXPORT_NO_SYMBOLS
suffix:semicolon
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Anton Altaparmakov &lt;aia21@cam.ac.uk&gt;&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;NTFS 1.2/3.x driver&quot;
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
id|MODULE_PARM
c_func
(paren
id|debug_msgs
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|debug_msgs
comma
l_string|&quot;Enable debug messages.&quot;
)paren
suffix:semicolon
macro_line|#endif
id|module_init
c_func
(paren
id|init_ntfs_fs
)paren
id|module_exit
c_func
(paren
id|exit_ntfs_fs
)paren
eof
