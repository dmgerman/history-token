multiline_comment|/*&n; * super.c&n; *&n; * Copyright (C) 1995-1997, 1999 Martin von L&#xfffd;wis&n; * Copyright (C) 1996-1997 R&#xfffd;gis Duchesne&n; * Copyright (C) 1999 Steve Dodd&n; * Copyright (C) 2000-2001 Anton Altparmakov (AIA)&n; */
macro_line|#include &lt;linux/ntfs_fs.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/bitops.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &quot;ntfstypes.h&quot;
macro_line|#include &quot;struct.h&quot;
macro_line|#include &quot;super.h&quot;
macro_line|#include &quot;macros.h&quot;
macro_line|#include &quot;inode.h&quot;
macro_line|#include &quot;support.h&quot;
macro_line|#include &quot;util.h&quot;
macro_line|#include &lt;linux/smp_lock.h&gt;
multiline_comment|/* All important structures in NTFS use 2 consistency checks:&n; * . a magic structure identifier (FILE, INDX, RSTR, RCRD...)&n; * . a fixup technique : the last word of each sector (called a fixup) of a&n; *   structure&squot;s record should end with the word at offset &lt;n&gt; of the first&n; *   sector, and if it is the case, must be replaced with the words following&n; *   &lt;n&gt;. The value of &lt;n&gt; and the number of fixups is taken from the fields&n; *   at the offsets 4 and 6. Note that the sector size is defined as&n; *   NTFS_SECTOR_SIZE and not as the hardware sector size (this is concordant&n; *   with what the Windows NTFS driver does).&n; *&n; * This function performs these 2 checks, and _fails_ if:&n; * . the input size is invalid&n; * . the fixup header is invalid&n; * . the size does not match the number of sectors&n; * . the magic identifier is wrong&n; * . a fixup is invalid&n; */
DECL|function|ntfs_fixup_record
r_int
id|ntfs_fixup_record
c_func
(paren
r_char
op_star
id|record
comma
r_char
op_star
id|magic
comma
r_int
id|size
)paren
(brace
r_int
id|start
comma
id|count
comma
id|offset
suffix:semicolon
id|ntfs_u16
id|fixup
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|IS_MAGIC
c_func
(paren
id|record
comma
id|magic
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|start
op_assign
id|NTFS_GETU16
c_func
(paren
id|record
op_plus
l_int|4
)paren
suffix:semicolon
id|count
op_assign
id|NTFS_GETU16
c_func
(paren
id|record
op_plus
l_int|6
)paren
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|size
op_amp
(paren
id|NTFS_SECTOR_SIZE
op_minus
l_int|1
)paren
op_logical_or
id|start
op_amp
l_int|1
op_logical_or
id|start
op_plus
id|count
op_star
l_int|2
OG
id|size
op_logical_or
id|size
op_rshift
l_int|9
op_ne
id|count
)paren
(brace
r_if
c_cond
(paren
id|size
op_le
l_int|0
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;NTFS: BUG: ntfs_fixup_record() got &quot;
l_string|&quot;zero size! Please report this to &quot;
l_string|&quot;linux-ntfs-dev@lists.sf.net&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|fixup
op_assign
id|NTFS_GETU16
c_func
(paren
id|record
op_plus
id|start
)paren
suffix:semicolon
id|start
op_add_assign
l_int|2
suffix:semicolon
id|offset
op_assign
id|NTFS_SECTOR_SIZE
op_minus
l_int|2
suffix:semicolon
r_while
c_loop
(paren
id|count
op_decrement
)paren
(brace
r_if
c_cond
(paren
id|NTFS_GETU16
c_func
(paren
id|record
op_plus
id|offset
)paren
op_ne
id|fixup
)paren
r_return
l_int|0
suffix:semicolon
id|NTFS_PUTU16
c_func
(paren
id|record
op_plus
id|offset
comma
id|NTFS_GETU16
c_func
(paren
id|record
op_plus
id|start
)paren
)paren
suffix:semicolon
id|start
op_add_assign
l_int|2
suffix:semicolon
id|offset
op_add_assign
id|NTFS_SECTOR_SIZE
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Get vital informations about the ntfs partition from the boot sector.&n; * Return 0 on success or -1 on error.&n; */
DECL|function|ntfs_init_volume
r_int
id|ntfs_init_volume
c_func
(paren
id|ntfs_volume
op_star
id|vol
comma
r_char
op_star
id|boot
)paren
(brace
r_int
id|sectors_per_cluster_bits
suffix:semicolon
id|__s64
id|ll
suffix:semicolon
id|ntfs_cluster_t
id|mft_zone_size
comma
id|tc
suffix:semicolon
multiline_comment|/* System defined default values, in case we don&squot;t load $AttrDef. */
id|vol-&gt;at_standard_information
op_assign
l_int|0x10
suffix:semicolon
id|vol-&gt;at_attribute_list
op_assign
l_int|0x20
suffix:semicolon
id|vol-&gt;at_file_name
op_assign
l_int|0x30
suffix:semicolon
id|vol-&gt;at_volume_version
op_assign
l_int|0x40
suffix:semicolon
id|vol-&gt;at_security_descriptor
op_assign
l_int|0x50
suffix:semicolon
id|vol-&gt;at_volume_name
op_assign
l_int|0x60
suffix:semicolon
id|vol-&gt;at_volume_information
op_assign
l_int|0x70
suffix:semicolon
id|vol-&gt;at_data
op_assign
l_int|0x80
suffix:semicolon
id|vol-&gt;at_index_root
op_assign
l_int|0x90
suffix:semicolon
id|vol-&gt;at_index_allocation
op_assign
l_int|0xA0
suffix:semicolon
id|vol-&gt;at_bitmap
op_assign
l_int|0xB0
suffix:semicolon
id|vol-&gt;at_symlink
op_assign
l_int|0xC0
suffix:semicolon
multiline_comment|/* Sector size. */
id|vol-&gt;sector_size
op_assign
id|NTFS_GETU16
c_func
(paren
id|boot
op_plus
l_int|0xB
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_FILE3
comma
l_string|&quot;ntfs_init_volume: vol-&gt;sector_size = 0x%x&bslash;n&quot;
comma
id|vol-&gt;sector_size
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_FILE3
comma
l_string|&quot;ntfs_init_volume: sectors_per_cluster = &quot;
l_string|&quot;0x%x&bslash;n&quot;
comma
id|NTFS_GETU8
c_func
(paren
id|boot
op_plus
l_int|0xD
)paren
)paren
suffix:semicolon
id|sectors_per_cluster_bits
op_assign
id|ffs
c_func
(paren
id|NTFS_GETU8
c_func
(paren
id|boot
op_plus
l_int|0xD
)paren
)paren
op_minus
l_int|1
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_FILE3
comma
l_string|&quot;ntfs_init_volume: sectors_per_cluster_bits &quot;
l_string|&quot;= 0x%x&bslash;n&quot;
comma
id|sectors_per_cluster_bits
)paren
suffix:semicolon
id|vol-&gt;mft_clusters_per_record
op_assign
id|NTFS_GETS8
c_func
(paren
id|boot
op_plus
l_int|0x40
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_FILE3
comma
l_string|&quot;ntfs_init_volume: vol-&gt;mft_clusters_per_record&quot;
l_string|&quot; = 0x%x&bslash;n&quot;
comma
id|vol-&gt;mft_clusters_per_record
)paren
suffix:semicolon
id|vol-&gt;index_clusters_per_record
op_assign
id|NTFS_GETS8
c_func
(paren
id|boot
op_plus
l_int|0x44
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_FILE3
comma
l_string|&quot;ntfs_init_volume: &quot;
l_string|&quot;vol-&gt;index_clusters_per_record = 0x%x&bslash;n&quot;
comma
id|vol-&gt;index_clusters_per_record
)paren
suffix:semicolon
id|vol-&gt;cluster_size
op_assign
id|vol-&gt;sector_size
op_lshift
id|sectors_per_cluster_bits
suffix:semicolon
id|vol-&gt;cluster_size_bits
op_assign
id|ffs
c_func
(paren
id|vol-&gt;cluster_size
)paren
op_minus
l_int|1
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_FILE3
comma
l_string|&quot;ntfs_init_volume: vol-&gt;cluster_size = 0x%x&bslash;n&quot;
comma
id|vol-&gt;cluster_size
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_FILE3
comma
l_string|&quot;ntfs_init_volume: vol-&gt;cluster_size_bits = &quot;
l_string|&quot;0x%x&bslash;n&quot;
comma
id|vol-&gt;cluster_size_bits
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vol-&gt;mft_clusters_per_record
OG
l_int|0
)paren
id|vol-&gt;mft_record_size
op_assign
id|vol-&gt;cluster_size
op_lshift
(paren
id|ffs
c_func
(paren
id|vol-&gt;mft_clusters_per_record
)paren
op_minus
l_int|1
)paren
suffix:semicolon
r_else
multiline_comment|/*&n;&t;&t; * When mft_record_size &lt; cluster_size, mft_clusters_per_record&n;&t;&t; * = -log2(mft_record_size) bytes. mft_record_size normaly is&n;&t;&t; * 1024 bytes, which is encoded as 0xF6 (-10 in decimal).&n;&t;&t; */
id|vol-&gt;mft_record_size
op_assign
l_int|1
op_lshift
op_minus
id|vol-&gt;mft_clusters_per_record
suffix:semicolon
id|vol-&gt;mft_record_size_bits
op_assign
id|ffs
c_func
(paren
id|vol-&gt;mft_record_size
)paren
op_minus
l_int|1
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_FILE3
comma
l_string|&quot;ntfs_init_volume: vol-&gt;mft_record_size = 0x%x&quot;
l_string|&quot;&bslash;n&quot;
comma
id|vol-&gt;mft_record_size
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_FILE3
comma
l_string|&quot;ntfs_init_volume: vol-&gt;mft_record_size_bits = &quot;
l_string|&quot;0x%x&bslash;n&quot;
comma
id|vol-&gt;mft_record_size_bits
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vol-&gt;index_clusters_per_record
OG
l_int|0
)paren
id|vol-&gt;index_record_size
op_assign
id|vol-&gt;cluster_size
op_lshift
(paren
id|ffs
c_func
(paren
id|vol-&gt;index_clusters_per_record
)paren
op_minus
l_int|1
)paren
suffix:semicolon
r_else
multiline_comment|/*&n;&t;&t; * When index_record_size &lt; cluster_size,&n;&t;&t; * index_clusters_per_record = -log2(index_record_size) bytes.&n;&t;&t; * index_record_size normaly equals 4096 bytes, which is&n;&t;&t; * encoded as 0xF4 (-12 in decimal).&n;&t;&t; */
id|vol-&gt;index_record_size
op_assign
l_int|1
op_lshift
op_minus
id|vol-&gt;index_clusters_per_record
suffix:semicolon
id|vol-&gt;index_record_size_bits
op_assign
id|ffs
c_func
(paren
id|vol-&gt;index_record_size
)paren
op_minus
l_int|1
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_FILE3
comma
l_string|&quot;ntfs_init_volume: vol-&gt;index_record_size = &quot;
l_string|&quot;0x%x&bslash;n&quot;
comma
id|vol-&gt;index_record_size
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_FILE3
comma
l_string|&quot;ntfs_init_volume: vol-&gt;index_record_size_bits &quot;
l_string|&quot;= 0x%x&bslash;n&quot;
comma
id|vol-&gt;index_record_size_bits
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Get the size of the volume in clusters (ofs 0x28 is nr_sectors) and&n;&t; * check for 64-bit-ness. Windows currently only uses 32 bits to save&n;&t; * the clusters so we do the same as it is much faster on 32-bit CPUs.&n;&t; */
id|ll
op_assign
id|NTFS_GETS64
c_func
(paren
id|boot
op_plus
l_int|0x28
)paren
op_rshift
id|sectors_per_cluster_bits
suffix:semicolon
r_if
c_cond
(paren
id|ll
op_ge
(paren
id|__s64
)paren
l_int|1
op_lshift
l_int|31
)paren
(brace
id|ntfs_error
c_func
(paren
l_string|&quot;Cannot handle 64-bit clusters. Please inform &quot;
l_string|&quot;linux-ntfs-dev@lists.sf.net that you got this &quot;
l_string|&quot;error.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|vol-&gt;nr_clusters
op_assign
(paren
id|ntfs_cluster_t
)paren
id|ll
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_FILE3
comma
l_string|&quot;ntfs_init_volume: vol-&gt;nr_clusters = 0x%x&bslash;n&quot;
comma
id|vol-&gt;nr_clusters
)paren
suffix:semicolon
id|vol-&gt;mft_lcn
op_assign
(paren
id|ntfs_cluster_t
)paren
id|NTFS_GETS64
c_func
(paren
id|boot
op_plus
l_int|0x30
)paren
suffix:semicolon
id|vol-&gt;mft_mirr_lcn
op_assign
(paren
id|ntfs_cluster_t
)paren
id|NTFS_GETS64
c_func
(paren
id|boot
op_plus
l_int|0x38
)paren
suffix:semicolon
multiline_comment|/* Determine MFT zone size. */
id|mft_zone_size
op_assign
id|vol-&gt;nr_clusters
suffix:semicolon
r_switch
c_cond
(paren
id|vol-&gt;mft_zone_multiplier
)paren
(brace
multiline_comment|/* % of volume size in clusters */
r_case
l_int|4
suffix:colon
id|mft_zone_size
op_rshift_assign
l_int|1
suffix:semicolon
multiline_comment|/* 50%   */
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
id|mft_zone_size
op_assign
id|mft_zone_size
op_star
l_int|3
op_rshift
l_int|3
suffix:semicolon
multiline_comment|/* 37.5% */
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|mft_zone_size
op_rshift_assign
l_int|2
suffix:semicolon
multiline_comment|/* 25%   */
r_break
suffix:semicolon
multiline_comment|/* case 1: */
r_default
suffix:colon
id|mft_zone_size
op_rshift_assign
l_int|3
suffix:semicolon
multiline_comment|/* 12.5% */
r_break
suffix:semicolon
)brace
multiline_comment|/* Setup mft zone. */
id|vol-&gt;mft_zone_start
op_assign
id|vol-&gt;mft_zone_pos
op_assign
id|vol-&gt;mft_lcn
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_FILE3
comma
l_string|&quot;ntfs_init_volume: vol-&gt;mft_zone_pos = %x&bslash;n&quot;
comma
id|vol-&gt;mft_zone_pos
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Calculate the mft_lcn for an unmodified NTFS volume (see mkntfs&n;&t; * source) and if the actual mft_lcn is in the expected place or even&n;&t; * further to the front of the volume, extend the mft_zone to cover the&n;&t; * beginning of the volume as well. This is in order to protect the&n;&t; * area reserved for the mft bitmap as well within the mft_zone itself.&n;&t; * On non-standard volumes we don&squot;t protect it as well as the overhead&n;&t; * would be higher than the speed increase we would get by doing it.&n;&t; */
id|tc
op_assign
(paren
l_int|8192
op_plus
l_int|2
op_star
id|vol-&gt;cluster_size
op_minus
l_int|1
)paren
op_div
id|vol-&gt;cluster_size
suffix:semicolon
r_if
c_cond
(paren
id|tc
op_star
id|vol-&gt;cluster_size
OL
l_int|16
op_star
l_int|1024
)paren
id|tc
op_assign
(paren
l_int|16
op_star
l_int|1024
op_plus
id|vol-&gt;cluster_size
op_minus
l_int|1
)paren
op_div
id|vol-&gt;cluster_size
suffix:semicolon
r_if
c_cond
(paren
id|vol-&gt;mft_zone_start
op_le
id|tc
)paren
id|vol-&gt;mft_zone_start
op_assign
(paren
id|ntfs_cluster_t
)paren
l_int|0
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_FILE3
comma
l_string|&quot;ntfs_init_volume: vol-&gt;mft_zone_start = %x&bslash;n&quot;
comma
id|vol-&gt;mft_zone_start
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Need to cap the mft zone on non-standard volumes so that it does&n;&t; * not point outside the boundaries of the volume, we do this by&n;&t; * halving the zone size until we are inside the volume.&n;&t; */
id|vol-&gt;mft_zone_end
op_assign
id|vol-&gt;mft_lcn
op_plus
id|mft_zone_size
suffix:semicolon
r_while
c_loop
(paren
id|vol-&gt;mft_zone_end
op_ge
id|vol-&gt;nr_clusters
)paren
(brace
id|mft_zone_size
op_rshift_assign
l_int|1
suffix:semicolon
id|vol-&gt;mft_zone_end
op_assign
id|vol-&gt;mft_lcn
op_plus
id|mft_zone_size
suffix:semicolon
)brace
id|ntfs_debug
c_func
(paren
id|DEBUG_FILE3
comma
l_string|&quot;ntfs_init_volume: vol-&gt;mft_zone_end = %x&bslash;n&quot;
comma
id|vol-&gt;mft_zone_end
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Set the current position within each data zone to the start of the&n;&t; * respective zone.&n;&t; */
id|vol-&gt;data1_zone_pos
op_assign
id|vol-&gt;mft_zone_end
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_FILE3
comma
l_string|&quot;ntfs_init_volume: vol-&gt;data1_zone_pos = %x&bslash;n&quot;
comma
id|vol-&gt;data1_zone_pos
)paren
suffix:semicolon
id|vol-&gt;data2_zone_pos
op_assign
(paren
id|ntfs_cluster_t
)paren
l_int|0
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_FILE3
comma
l_string|&quot;ntfs_init_volume: vol-&gt;data2_zone_pos = %x&bslash;n&quot;
comma
id|vol-&gt;data2_zone_pos
)paren
suffix:semicolon
multiline_comment|/* Set the mft data allocation position to mft record 24. */
id|vol-&gt;mft_data_pos
op_assign
l_int|24UL
suffix:semicolon
multiline_comment|/* This will be initialized later. */
id|vol-&gt;upcase
op_assign
l_int|0
suffix:semicolon
id|vol-&gt;upcase_length
op_assign
l_int|0
suffix:semicolon
id|vol-&gt;mft_ino
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ntfs_init_upcase
r_static
r_void
id|ntfs_init_upcase
c_func
(paren
id|ntfs_inode
op_star
id|upcase
)paren
(brace
id|ntfs_io
id|io
suffix:semicolon
DECL|macro|UPCASE_LENGTH
mdefine_line|#define UPCASE_LENGTH  256
id|upcase-&gt;vol-&gt;upcase
op_assign
id|ntfs_malloc
c_func
(paren
id|UPCASE_LENGTH
op_lshift
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|upcase-&gt;vol-&gt;upcase
)paren
r_return
suffix:semicolon
id|io.fn_put
op_assign
id|ntfs_put
suffix:semicolon
id|io.fn_get
op_assign
l_int|0
suffix:semicolon
id|io.param
op_assign
(paren
r_char
op_star
)paren
id|upcase-&gt;vol-&gt;upcase
suffix:semicolon
id|io.size
op_assign
id|UPCASE_LENGTH
op_lshift
l_int|1
suffix:semicolon
id|ntfs_read_attr
c_func
(paren
id|upcase
comma
id|upcase-&gt;vol-&gt;at_data
comma
l_int|0
comma
l_int|0
comma
op_amp
id|io
)paren
suffix:semicolon
id|upcase-&gt;vol-&gt;upcase_length
op_assign
id|io.size
op_rshift
l_int|1
suffix:semicolon
)brace
DECL|function|process_attrdef
r_static
r_int
id|process_attrdef
c_func
(paren
id|ntfs_inode
op_star
id|attrdef
comma
id|ntfs_u8
op_star
id|def
)paren
(brace
r_int
id|type
op_assign
id|NTFS_GETU32
c_func
(paren
id|def
op_plus
l_int|0x80
)paren
suffix:semicolon
r_int
id|check_type
op_assign
l_int|0
suffix:semicolon
id|ntfs_volume
op_star
id|vol
op_assign
id|attrdef-&gt;vol
suffix:semicolon
id|ntfs_u16
op_star
id|name
op_assign
(paren
id|ntfs_u16
op_star
)paren
id|def
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|type
)paren
(brace
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
l_string|&quot;process_atrdef: finished processing &quot;
l_string|&quot;and returning 1&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ntfs_ua_strncmp
c_func
(paren
id|name
comma
l_string|&quot;$STANDARD_INFORMATION&quot;
comma
l_int|64
)paren
op_eq
l_int|0
)paren
(brace
id|vol-&gt;at_standard_information
op_assign
id|type
suffix:semicolon
id|check_type
op_assign
l_int|0x10
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ntfs_ua_strncmp
c_func
(paren
id|name
comma
l_string|&quot;$ATTRIBUTE_LIST&quot;
comma
l_int|64
)paren
op_eq
l_int|0
)paren
(brace
id|vol-&gt;at_attribute_list
op_assign
id|type
suffix:semicolon
id|check_type
op_assign
l_int|0x20
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ntfs_ua_strncmp
c_func
(paren
id|name
comma
l_string|&quot;$FILE_NAME&quot;
comma
l_int|64
)paren
op_eq
l_int|0
)paren
(brace
id|vol-&gt;at_file_name
op_assign
id|type
suffix:semicolon
id|check_type
op_assign
l_int|0x30
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ntfs_ua_strncmp
c_func
(paren
id|name
comma
l_string|&quot;$VOLUME_VERSION&quot;
comma
l_int|64
)paren
op_eq
l_int|0
)paren
(brace
id|vol-&gt;at_volume_version
op_assign
id|type
suffix:semicolon
id|check_type
op_assign
l_int|0x40
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ntfs_ua_strncmp
c_func
(paren
id|name
comma
l_string|&quot;$SECURITY_DESCRIPTOR&quot;
comma
l_int|64
)paren
op_eq
l_int|0
)paren
(brace
id|vol-&gt;at_security_descriptor
op_assign
id|type
suffix:semicolon
id|check_type
op_assign
l_int|0x50
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ntfs_ua_strncmp
c_func
(paren
id|name
comma
l_string|&quot;$VOLUME_NAME&quot;
comma
l_int|64
)paren
op_eq
l_int|0
)paren
(brace
id|vol-&gt;at_volume_name
op_assign
id|type
suffix:semicolon
id|check_type
op_assign
l_int|0x60
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ntfs_ua_strncmp
c_func
(paren
id|name
comma
l_string|&quot;$VOLUME_INFORMATION&quot;
comma
l_int|64
)paren
op_eq
l_int|0
)paren
(brace
id|vol-&gt;at_volume_information
op_assign
id|type
suffix:semicolon
id|check_type
op_assign
l_int|0x70
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ntfs_ua_strncmp
c_func
(paren
id|name
comma
l_string|&quot;$DATA&quot;
comma
l_int|64
)paren
op_eq
l_int|0
)paren
(brace
id|vol-&gt;at_data
op_assign
id|type
suffix:semicolon
id|check_type
op_assign
l_int|0x80
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ntfs_ua_strncmp
c_func
(paren
id|name
comma
l_string|&quot;$INDEX_ROOT&quot;
comma
l_int|64
)paren
op_eq
l_int|0
)paren
(brace
id|vol-&gt;at_index_root
op_assign
id|type
suffix:semicolon
id|check_type
op_assign
l_int|0x90
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ntfs_ua_strncmp
c_func
(paren
id|name
comma
l_string|&quot;$INDEX_ALLOCATION&quot;
comma
l_int|64
)paren
op_eq
l_int|0
)paren
(brace
id|vol-&gt;at_index_allocation
op_assign
id|type
suffix:semicolon
id|check_type
op_assign
l_int|0xA0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ntfs_ua_strncmp
c_func
(paren
id|name
comma
l_string|&quot;$BITMAP&quot;
comma
l_int|64
)paren
op_eq
l_int|0
)paren
(brace
id|vol-&gt;at_bitmap
op_assign
id|type
suffix:semicolon
id|check_type
op_assign
l_int|0xB0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ntfs_ua_strncmp
c_func
(paren
id|name
comma
l_string|&quot;$SYMBOLIC_LINK&quot;
comma
l_int|64
)paren
op_eq
l_int|0
op_logical_or
id|ntfs_ua_strncmp
c_func
(paren
id|name
comma
l_string|&quot;$REPARSE_POINT&quot;
comma
l_int|64
)paren
op_eq
l_int|0
)paren
(brace
id|vol-&gt;at_symlink
op_assign
id|type
suffix:semicolon
id|check_type
op_assign
l_int|0xC0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|check_type
op_logical_and
id|check_type
op_ne
id|type
)paren
(brace
id|ntfs_error
c_func
(paren
l_string|&quot;process_attrdef: unexpected type 0x%x for 0x%x&bslash;n&quot;
comma
id|type
comma
id|check_type
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
l_string|&quot;process_attrdef: found %s attribute of type &quot;
l_string|&quot;0x%x&bslash;n&quot;
comma
id|check_type
ques
c_cond
l_string|&quot;known&quot;
suffix:colon
l_string|&quot;unknown&quot;
comma
id|type
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ntfs_init_attrdef
r_int
id|ntfs_init_attrdef
c_func
(paren
id|ntfs_inode
op_star
id|attrdef
)paren
(brace
id|ntfs_u8
op_star
id|buf
suffix:semicolon
id|ntfs_io
id|io
suffix:semicolon
id|__s64
id|offset
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|error
suffix:semicolon
id|ntfs_attribute
op_star
id|data
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_BSD
comma
l_string|&quot;Entered ntfs_init_attrdef()&bslash;n&quot;
)paren
suffix:semicolon
id|buf
op_assign
id|ntfs_malloc
c_func
(paren
l_int|4050
)paren
suffix:semicolon
multiline_comment|/* 90*45 */
r_if
c_cond
(paren
op_logical_neg
id|buf
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|io.fn_put
op_assign
id|ntfs_put
suffix:semicolon
id|io.fn_get
op_assign
id|ntfs_get
suffix:semicolon
id|io.do_read
op_assign
l_int|1
suffix:semicolon
id|offset
op_assign
l_int|0
suffix:semicolon
id|data
op_assign
id|ntfs_find_attr
c_func
(paren
id|attrdef
comma
id|attrdef-&gt;vol-&gt;at_data
comma
l_int|0
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_BSD
comma
l_string|&quot;In ntfs_init_attrdef() after call to &quot;
l_string|&quot;ntfs_find_attr.&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|data
)paren
(brace
id|ntfs_free
c_func
(paren
id|buf
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_do
(brace
id|io.param
op_assign
id|buf
suffix:semicolon
id|io.size
op_assign
l_int|4050
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_BSD
comma
l_string|&quot;In ntfs_init_attrdef() going to call &quot;
l_string|&quot;ntfs_readwrite_attr.&bslash;n&quot;
)paren
suffix:semicolon
id|error
op_assign
id|ntfs_readwrite_attr
c_func
(paren
id|attrdef
comma
id|data
comma
id|offset
comma
op_amp
id|io
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_BSD
comma
l_string|&quot;In ntfs_init_attrdef() after call to &quot;
l_string|&quot;ntfs_readwrite_attr.&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
op_logical_neg
id|error
op_logical_and
id|i
op_le
id|io.size
op_minus
l_int|0xA0
suffix:semicolon
id|i
op_add_assign
l_int|0xA0
)paren
(brace
id|ntfs_debug
c_func
(paren
id|DEBUG_BSD
comma
l_string|&quot;In ntfs_init_attrdef() going &quot;
l_string|&quot;to call process_attrdef.&bslash;n&quot;
)paren
suffix:semicolon
id|error
op_assign
id|process_attrdef
c_func
(paren
id|attrdef
comma
id|buf
op_plus
id|i
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_BSD
comma
l_string|&quot;In ntfs_init_attrdef() after &quot;
l_string|&quot;call to process_attrdef.&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|offset
op_add_assign
l_int|4096
suffix:semicolon
)brace
r_while
c_loop
(paren
op_logical_neg
id|error
op_logical_and
id|io.size
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_BSD
comma
l_string|&quot;Exiting ntfs_init_attrdef()&bslash;n&quot;
)paren
suffix:semicolon
id|ntfs_free
c_func
(paren
id|buf
)paren
suffix:semicolon
r_return
id|error
op_eq
l_int|1
ques
c_cond
l_int|0
suffix:colon
id|error
suffix:semicolon
)brace
multiline_comment|/* ntfs_get_version will determine the NTFS version of the volume and will&n; * return the version in a BCD format, with the MSB being the major version&n; * number and the LSB the minor one. Otherwise return &lt;0 on error.&n; * Example: version 3.1 will be returned as 0x0301. This has the obvious&n; * limitation of not coping with version numbers above 0x80 but that shouldn&squot;t&n; * be a problem... */
DECL|function|ntfs_get_version
r_int
id|ntfs_get_version
c_func
(paren
id|ntfs_inode
op_star
id|volume
)paren
(brace
id|ntfs_attribute
op_star
id|volinfo
suffix:semicolon
id|volinfo
op_assign
id|ntfs_find_attr
c_func
(paren
id|volume
comma
id|volume-&gt;vol-&gt;at_volume_information
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|volinfo
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|volinfo-&gt;resident
)paren
(brace
id|ntfs_error
c_func
(paren
l_string|&quot;Volume information attribute is not resident!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
(paren
(paren
id|ntfs_u8
op_star
)paren
id|volinfo-&gt;d.data
)paren
(braket
l_int|8
)braket
op_lshift
l_int|8
op_or
(paren
(paren
id|ntfs_u8
op_star
)paren
id|volinfo-&gt;d.data
)paren
(braket
l_int|9
)braket
suffix:semicolon
)brace
DECL|function|ntfs_load_special_files
r_int
id|ntfs_load_special_files
c_func
(paren
id|ntfs_volume
op_star
id|vol
)paren
(brace
r_int
id|error
suffix:semicolon
id|ntfs_inode
id|upcase
comma
id|attrdef
comma
id|volume
suffix:semicolon
id|vol-&gt;mft_ino
op_assign
(paren
id|ntfs_inode
op_star
)paren
id|ntfs_calloc
c_func
(paren
r_sizeof
(paren
id|ntfs_inode
)paren
)paren
suffix:semicolon
id|vol-&gt;mftmirr
op_assign
(paren
id|ntfs_inode
op_star
)paren
id|ntfs_calloc
c_func
(paren
r_sizeof
(paren
id|ntfs_inode
)paren
)paren
suffix:semicolon
id|vol-&gt;bitmap
op_assign
(paren
id|ntfs_inode
op_star
)paren
id|ntfs_calloc
c_func
(paren
r_sizeof
(paren
id|ntfs_inode
)paren
)paren
suffix:semicolon
id|vol-&gt;ino_flags
op_assign
l_int|4
op_or
l_int|2
op_or
l_int|1
suffix:semicolon
id|error
op_assign
op_minus
id|ENOMEM
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_BSD
comma
l_string|&quot;Going to load MFT&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vol-&gt;mft_ino
op_logical_or
(paren
id|error
op_assign
id|ntfs_init_inode
c_func
(paren
id|vol-&gt;mft_ino
comma
id|vol
comma
id|FILE_Mft
)paren
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
l_string|&quot;Problem loading MFT&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
id|ntfs_debug
c_func
(paren
id|DEBUG_BSD
comma
l_string|&quot;Going to load MIRR&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|ntfs_init_inode
c_func
(paren
id|vol-&gt;mftmirr
comma
id|vol
comma
id|FILE_MftMirr
)paren
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
l_string|&quot;Problem %d loading MFTMirr&bslash;n&quot;
comma
id|error
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
id|ntfs_debug
c_func
(paren
id|DEBUG_BSD
comma
l_string|&quot;Going to load BITMAP&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|ntfs_init_inode
c_func
(paren
id|vol-&gt;bitmap
comma
id|vol
comma
id|FILE_BitMap
)paren
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
l_string|&quot;Problem loading Bitmap&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
id|ntfs_debug
c_func
(paren
id|DEBUG_BSD
comma
l_string|&quot;Going to load UPCASE&bslash;n&quot;
)paren
suffix:semicolon
id|error
op_assign
id|ntfs_init_inode
c_func
(paren
op_amp
id|upcase
comma
id|vol
comma
id|FILE_UpCase
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
id|ntfs_init_upcase
c_func
(paren
op_amp
id|upcase
)paren
suffix:semicolon
id|ntfs_clear_inode
c_func
(paren
op_amp
id|upcase
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_BSD
comma
l_string|&quot;Going to load ATTRDEF&bslash;n&quot;
)paren
suffix:semicolon
id|error
op_assign
id|ntfs_init_inode
c_func
(paren
op_amp
id|attrdef
comma
id|vol
comma
id|FILE_AttrDef
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
id|error
op_assign
id|ntfs_init_attrdef
c_func
(paren
op_amp
id|attrdef
)paren
suffix:semicolon
id|ntfs_clear_inode
c_func
(paren
op_amp
id|attrdef
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
multiline_comment|/* Check for NTFS version and if Win2k version (ie. 3.0+) do not allow&n;&t; * write access since the driver write support is broken. */
id|ntfs_debug
c_func
(paren
id|DEBUG_BSD
comma
l_string|&quot;Going to load VOLUME&bslash;n&quot;
)paren
suffix:semicolon
id|error
op_assign
id|ntfs_init_inode
c_func
(paren
op_amp
id|volume
comma
id|vol
comma
id|FILE_Volume
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|ntfs_get_version
c_func
(paren
op_amp
id|volume
)paren
)paren
op_ge
l_int|0x0300
op_logical_and
op_logical_neg
(paren
id|NTFS_SB
c_func
(paren
id|vol
)paren
op_member_access_from_pointer
id|s_flags
op_amp
id|MS_RDONLY
)paren
)paren
(brace
id|NTFS_SB
c_func
(paren
id|vol
)paren
op_member_access_from_pointer
id|s_flags
op_or_assign
id|MS_RDONLY
suffix:semicolon
id|ntfs_error
c_func
(paren
l_string|&quot;Warning! NTFS volume version is Win2k+: Mounting &quot;
l_string|&quot;read-only&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|ntfs_clear_inode
c_func
(paren
op_amp
id|volume
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
OL
l_int|0
)paren
r_return
id|error
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_BSD
comma
l_string|&quot;NTFS volume is v%d.%d&bslash;n&quot;
comma
id|error
op_rshift
l_int|8
comma
id|error
op_amp
l_int|0xff
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ntfs_release_volume
r_int
id|ntfs_release_volume
c_func
(paren
id|ntfs_volume
op_star
id|vol
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
id|vol-&gt;ino_flags
op_amp
l_int|1
)paren
op_eq
l_int|1
)paren
op_logical_and
id|vol-&gt;mft_ino
)paren
(brace
id|ntfs_clear_inode
c_func
(paren
id|vol-&gt;mft_ino
)paren
suffix:semicolon
id|ntfs_free
c_func
(paren
id|vol-&gt;mft_ino
)paren
suffix:semicolon
id|vol-&gt;mft_ino
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
(paren
id|vol-&gt;ino_flags
op_amp
l_int|2
)paren
op_eq
l_int|2
)paren
op_logical_and
id|vol-&gt;mftmirr
)paren
(brace
id|ntfs_clear_inode
c_func
(paren
id|vol-&gt;mftmirr
)paren
suffix:semicolon
id|ntfs_free
c_func
(paren
id|vol-&gt;mftmirr
)paren
suffix:semicolon
id|vol-&gt;mftmirr
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
(paren
id|vol-&gt;ino_flags
op_amp
l_int|4
)paren
op_eq
l_int|4
)paren
op_logical_and
id|vol-&gt;bitmap
)paren
(brace
id|ntfs_clear_inode
c_func
(paren
id|vol-&gt;bitmap
)paren
suffix:semicolon
id|ntfs_free
c_func
(paren
id|vol-&gt;bitmap
)paren
suffix:semicolon
id|vol-&gt;bitmap
op_assign
l_int|0
suffix:semicolon
)brace
id|ntfs_free
c_func
(paren
id|vol-&gt;mft
)paren
suffix:semicolon
id|ntfs_free
c_func
(paren
id|vol-&gt;upcase
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Writes the volume size (units of clusters) into vol_size.&n; * Returns 0 if successful or error.&n; */
DECL|function|ntfs_get_volumesize
r_int
id|ntfs_get_volumesize
c_func
(paren
id|ntfs_volume
op_star
id|vol
comma
id|ntfs_s64
op_star
id|vol_size
)paren
(brace
id|ntfs_io
id|io
suffix:semicolon
r_char
op_star
id|cluster0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vol_size
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|cluster0
op_assign
id|ntfs_malloc
c_func
(paren
id|vol-&gt;cluster_size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cluster0
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|io.fn_put
op_assign
id|ntfs_put
suffix:semicolon
id|io.fn_get
op_assign
id|ntfs_get
suffix:semicolon
id|io.param
op_assign
id|cluster0
suffix:semicolon
id|io.do_read
op_assign
l_int|1
suffix:semicolon
id|io.size
op_assign
id|vol-&gt;cluster_size
suffix:semicolon
id|ntfs_getput_clusters
c_func
(paren
id|vol
comma
l_int|0
comma
l_int|0
comma
op_amp
id|io
)paren
suffix:semicolon
op_star
id|vol_size
op_assign
id|NTFS_GETU64
c_func
(paren
id|cluster0
op_plus
l_int|0x28
)paren
op_rshift
(paren
id|ffs
c_func
(paren
id|NTFS_GETU8
c_func
(paren
id|cluster0
op_plus
l_int|0xD
)paren
)paren
op_minus
l_int|1
)paren
suffix:semicolon
id|ntfs_free
c_func
(paren
id|cluster0
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|nc
r_static
r_int
id|nc
(braket
l_int|16
)braket
op_assign
initialization_block
suffix:semicolon
DECL|function|ntfs_get_free_cluster_count
r_int
id|ntfs_get_free_cluster_count
c_func
(paren
id|ntfs_inode
op_star
id|bitmap
)paren
(brace
id|ntfs_io
id|io
suffix:semicolon
r_int
id|offset
comma
id|error
comma
id|clusters
suffix:semicolon
r_int
r_char
op_star
id|bits
op_assign
id|ntfs_malloc
c_func
(paren
l_int|2048
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bits
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|offset
op_assign
id|clusters
op_assign
l_int|0
suffix:semicolon
id|io.fn_put
op_assign
id|ntfs_put
suffix:semicolon
id|io.fn_get
op_assign
id|ntfs_get
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_register
r_int
id|i
suffix:semicolon
id|io.param
op_assign
id|bits
suffix:semicolon
id|io.size
op_assign
l_int|2048
suffix:semicolon
id|error
op_assign
id|ntfs_read_attr
c_func
(paren
id|bitmap
comma
id|bitmap-&gt;vol-&gt;at_data
comma
l_int|0
comma
id|offset
comma
op_amp
id|io
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_logical_or
id|io.size
op_eq
l_int|0
)paren
r_break
suffix:semicolon
multiline_comment|/* I never thought I would do loop unrolling some day */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|io.size
op_minus
l_int|8
suffix:semicolon
)paren
(brace
id|clusters
op_add_assign
id|nc
(braket
id|bits
(braket
id|i
)braket
op_rshift
l_int|4
)braket
suffix:semicolon
id|clusters
op_add_assign
id|nc
(braket
id|bits
(braket
id|i
op_increment
)braket
op_amp
l_int|0xF
)braket
suffix:semicolon
id|clusters
op_add_assign
id|nc
(braket
id|bits
(braket
id|i
)braket
op_rshift
l_int|4
)braket
suffix:semicolon
id|clusters
op_add_assign
id|nc
(braket
id|bits
(braket
id|i
op_increment
)braket
op_amp
l_int|0xF
)braket
suffix:semicolon
id|clusters
op_add_assign
id|nc
(braket
id|bits
(braket
id|i
)braket
op_rshift
l_int|4
)braket
suffix:semicolon
id|clusters
op_add_assign
id|nc
(braket
id|bits
(braket
id|i
op_increment
)braket
op_amp
l_int|0xF
)braket
suffix:semicolon
id|clusters
op_add_assign
id|nc
(braket
id|bits
(braket
id|i
)braket
op_rshift
l_int|4
)braket
suffix:semicolon
id|clusters
op_add_assign
id|nc
(braket
id|bits
(braket
id|i
op_increment
)braket
op_amp
l_int|0xF
)braket
suffix:semicolon
id|clusters
op_add_assign
id|nc
(braket
id|bits
(braket
id|i
)braket
op_rshift
l_int|4
)braket
suffix:semicolon
id|clusters
op_add_assign
id|nc
(braket
id|bits
(braket
id|i
op_increment
)braket
op_amp
l_int|0xF
)braket
suffix:semicolon
id|clusters
op_add_assign
id|nc
(braket
id|bits
(braket
id|i
)braket
op_rshift
l_int|4
)braket
suffix:semicolon
id|clusters
op_add_assign
id|nc
(braket
id|bits
(braket
id|i
op_increment
)braket
op_amp
l_int|0xF
)braket
suffix:semicolon
id|clusters
op_add_assign
id|nc
(braket
id|bits
(braket
id|i
)braket
op_rshift
l_int|4
)braket
suffix:semicolon
id|clusters
op_add_assign
id|nc
(braket
id|bits
(braket
id|i
op_increment
)braket
op_amp
l_int|0xF
)braket
suffix:semicolon
id|clusters
op_add_assign
id|nc
(braket
id|bits
(braket
id|i
)braket
op_rshift
l_int|4
)braket
suffix:semicolon
id|clusters
op_add_assign
id|nc
(braket
id|bits
(braket
id|i
op_increment
)braket
op_amp
l_int|0xF
)braket
suffix:semicolon
)brace
r_while
c_loop
(paren
id|i
OL
id|io.size
)paren
(brace
id|clusters
op_add_assign
id|nc
(braket
id|bits
(braket
id|i
)braket
op_rshift
l_int|4
)braket
suffix:semicolon
id|clusters
op_add_assign
id|nc
(braket
id|bits
(braket
id|i
op_increment
)braket
op_amp
l_int|0xF
)braket
suffix:semicolon
)brace
id|offset
op_add_assign
id|io.size
suffix:semicolon
)brace
id|ntfs_free
c_func
(paren
id|bits
)paren
suffix:semicolon
r_return
id|clusters
suffix:semicolon
)brace
multiline_comment|/*&n; * Insert the fixups for the record. The number and location of the fixes&n; * is obtained from the record header but we double check with @rec_size and&n; * use that as the upper boundary, if necessary overwriting the count value in&n; * the record header.&n; *&n; * We return 0 on success or -1 if fixup header indicated the beginning of the&n; * update sequence array to be beyond the valid limit.&n; */
DECL|function|ntfs_insert_fixups
r_int
id|ntfs_insert_fixups
c_func
(paren
r_int
r_char
op_star
id|rec
comma
r_int
id|rec_size
)paren
(brace
r_int
id|first
suffix:semicolon
r_int
id|count
suffix:semicolon
r_int
id|offset
op_assign
op_minus
l_int|2
suffix:semicolon
id|ntfs_u16
id|fix
suffix:semicolon
id|first
op_assign
id|NTFS_GETU16
c_func
(paren
id|rec
op_plus
l_int|4
)paren
suffix:semicolon
id|count
op_assign
(paren
id|rec_size
op_rshift
id|NTFS_SECTOR_BITS
)paren
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|first
op_plus
id|count
op_star
l_int|2
OG
id|NTFS_SECTOR_SIZE
op_minus
l_int|2
)paren
(brace
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;NTFS: ntfs_insert_fixups() detected corrupt &quot;
l_string|&quot;NTFS record update sequence array position. - &quot;
l_string|&quot;Cannot hotfix.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|count
op_ne
id|NTFS_GETU16
c_func
(paren
id|rec
op_plus
l_int|6
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;NTFS: ntfs_insert_fixups() detected corrupt &quot;
l_string|&quot;NTFS record update sequence array size. - &quot;
l_string|&quot;Applying hotfix.&bslash;n&quot;
)paren
suffix:semicolon
id|NTFS_PUTU16
c_func
(paren
id|rec
op_plus
l_int|6
comma
id|count
)paren
suffix:semicolon
)brace
id|fix
op_assign
(paren
id|NTFS_GETU16
c_func
(paren
id|rec
op_plus
id|first
)paren
op_plus
l_int|1
)paren
op_amp
l_int|0xffff
suffix:semicolon
r_if
c_cond
(paren
id|fix
op_eq
l_int|0xffff
op_logical_or
op_logical_neg
id|fix
)paren
id|fix
op_assign
l_int|1
suffix:semicolon
id|NTFS_PUTU16
c_func
(paren
id|rec
op_plus
id|first
comma
id|fix
)paren
suffix:semicolon
id|count
op_decrement
suffix:semicolon
r_while
c_loop
(paren
id|count
op_decrement
)paren
(brace
id|first
op_add_assign
l_int|2
suffix:semicolon
id|offset
op_add_assign
id|NTFS_SECTOR_SIZE
suffix:semicolon
id|NTFS_PUTU16
c_func
(paren
id|rec
op_plus
id|first
comma
id|NTFS_GETU16
c_func
(paren
id|rec
op_plus
id|offset
)paren
)paren
suffix:semicolon
id|NTFS_PUTU16
c_func
(paren
id|rec
op_plus
id|offset
comma
id|fix
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_allocate_clusters - allocate logical clusters on an ntfs volume&n; * @vol:&t;volume on which to allocate clusters&n; * @location:&t;preferred location for first allocated cluster&n; * @count:&t;number of clusters to allocate&n; * @rl:&t;&t;address of pointer in which to return the allocated run list&n; * @rl_len:&t;the number of elements returned in @*rl&n; *&n; * Allocate @*count clusters (LCNs), preferably beginning at @*location in the&n; * bitmap of the volume @vol. If @*location is -1, it does not matter where the&n; * clusters are. @rl is the address of a ntfs_runlist pointer which this&n; * function will allocate and fill with the runlist of the allocated clusters.&n; * It is the callers responsibility to ntfs_vfree() @*rl after she is finished&n; * with it. If the function was not successful, @*rl will be set to NULL.&n; * @*rl_len will contain the number of ntfs_runlist elements in @*rl or 0 if&n; * @*rl is NULL.&n; *&n; * Return 0 on success, or -errno on error. On success, @*location and @*count&n; * say what was really allocated. On -ENOSPC, @*location and @*count say what&n; * could have been allocated. If nothing could be allocated or a different&n; * error occured, @*location = -1 and @*count = 0.&n; *&n; * There are two data zones. First is the area between the end of the mft zone&n; * and the end of the volume, and second is the area between the start of the&n; * volume and the start of the mft zone. On unmodified/standard volumes, the&n; * second mft zone doesn&squot;t exist due to the mft zone being expanded to cover&n; * the start of volume in order to reserve space for the mft bitmap attribute.&n; *&n; * This is not the prettiest function but the complexity stems from the need of&n; * implementing the mft vs data zoned approach and from the fact that we have&n; * access to the lcn bitmap in portions of PAGE_SIZE bytes at a time, so we&n; * need to cope with crossing over boundaries of two pages. Further, the fact&n; * that the allocator allows for caller supplied hints as to the location of&n; * where allocation should begin and the fact that the allocator keeps track of&n; * where in the data zones the next natural allocation should occur, contribute&n; * to the complexity of the function. But it should all be worthwhile, because&n; * this allocator should: 1) be a full implementation of the MFT zone approach&n; * used by Windows, 2) cause reduction in fragmentation as much as possible,&n; * and 3) be speedy in allocations (the code is not optimized for speed, but&n; * the algorithm is, so further speed improvements are probably possible).&n; *&n; * FIXME: Really need finer-grained locking but this will do for the moment. I&n; * just want to kill all races and have a working allocator. When that is done,&n; * we can beautify... (AIA)&n; * &n; * FIXME: We should be monitoring cluster allocation and increment the MFT zone&n; * size dynamically but this is something for the future. We will just cause&n; * heavier fragmentation by not doing it and I am not even sure Windows would&n; * grow the MFT zone dynamically, so might even be correct not doing this. The&n; * overhead in doing dynamic MFT zone expansion would be very large and unlikely&n; * worth the effort. (AIA)&n; *&n; * TODO: I have added in double the required zone position pointer wrap around&n; * logic which can be optimized to having only one of the two logic sets.&n; * However, having the double logic will work fine, but if we have only one of&n; * the sets and we get it wrong somewhere, then we get into trouble, so&n; * removing the duplicate logic requires _very_ careful consideration of _all_&n; * possible code paths. So at least for now, I am leaving the double logic -&n; * better safe than sorry... (AIA)&n; */
DECL|function|ntfs_allocate_clusters
r_int
id|ntfs_allocate_clusters
c_func
(paren
id|ntfs_volume
op_star
id|vol
comma
id|ntfs_cluster_t
op_star
id|location
comma
id|ntfs_cluster_t
op_star
id|count
comma
id|ntfs_runlist
op_star
op_star
id|rl
comma
r_int
op_star
id|rl_len
comma
r_const
id|NTFS_CLUSTER_ALLOCATION_ZONES
id|zone
)paren
(brace
id|ntfs_runlist
op_star
id|rl2
op_assign
l_int|NULL
comma
op_star
id|rlt
suffix:semicolon
id|ntfs_attribute
op_star
id|data
suffix:semicolon
id|ntfs_cluster_t
id|buf_pos
comma
id|zone_start
comma
id|zone_end
comma
id|mft_zone_size
suffix:semicolon
id|ntfs_cluster_t
id|lcn
comma
id|last_read_pos
comma
id|prev_lcn
op_assign
(paren
id|ntfs_cluster_t
)paren
l_int|0
suffix:semicolon
id|ntfs_cluster_t
id|initial_location
comma
id|prev_run_len
op_assign
(paren
id|ntfs_cluster_t
)paren
l_int|0
suffix:semicolon
id|ntfs_cluster_t
id|clusters
op_assign
(paren
id|ntfs_cluster_t
)paren
l_int|0
suffix:semicolon
r_int
r_char
op_star
id|buf
comma
op_star
id|byte
comma
id|bit
comma
id|search_zone
comma
id|done_zones
suffix:semicolon
r_int
r_char
id|pass
comma
id|need_writeback
suffix:semicolon
r_int
id|rlpos
op_assign
l_int|0
comma
id|rlsize
comma
id|buf_size
comma
id|err
op_assign
l_int|0
suffix:semicolon
id|ntfs_io
id|io
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): Entering with *location = &quot;
l_string|&quot;0x%x, *count = 0x%x, zone = %s_ZONE.&bslash;n&quot;
comma
op_star
id|location
comma
op_star
id|count
comma
id|zone
op_eq
id|DATA_ZONE
ques
c_cond
l_string|&quot;DATA&quot;
suffix:colon
l_string|&quot;MFT&quot;
)paren
suffix:semicolon
id|buf
op_assign
(paren
r_char
op_star
)paren
id|__get_free_page
c_func
(paren
id|GFP_NOFS
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buf
)paren
(brace
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): Returning &quot;
l_string|&quot;-ENOMEM.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|io.fn_put
op_assign
id|ntfs_put
suffix:semicolon
id|io.fn_get
op_assign
id|ntfs_get
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Get the $DATA attribute of $Bitmap. */
id|data
op_assign
id|ntfs_find_attr
c_func
(paren
id|vol-&gt;bitmap
comma
id|vol-&gt;at_data
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|data
)paren
(brace
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|err_ret
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If no specific location was requested, use the current data zone&n;&t; * position, otherwise use the requested location but make sure it lies&n;&t; * outside the mft zone. Also set done_zones to 0 (no zones done) and&n;&t; * pass depending on whether we are starting inside a zone (1) or&n;&t; * at the beginning of a zone (2). If requesting from the MFT_ZONE, then&n;&t; * we either start at the current position within the mft zone or at the&n;&t; * specified position and if the latter is out of bounds then we start&n;&t; * at the beginning of the MFT_ZONE.&n;&t; */
id|done_zones
op_assign
l_int|0
suffix:semicolon
id|pass
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * zone_start and zone_end are the current search range. search_zone&n;&t; * is 1 for mft zone, 2 for data zone 1 (end of mft zone till end of&n;&t; * volume) and 4 for data zone 2 (start of volume till start of mft&n;&t; * zone).&n;&t; */
id|zone_start
op_assign
op_star
id|location
suffix:semicolon
r_if
c_cond
(paren
id|zone_start
OL
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|zone
op_eq
id|DATA_ZONE
)paren
id|zone_start
op_assign
id|vol-&gt;data1_zone_pos
suffix:semicolon
r_else
id|zone_start
op_assign
id|vol-&gt;mft_zone_pos
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|zone_start
)paren
multiline_comment|/*&n;&t;&t;&t; * Zone starts at beginning of volume which means a&n;&t;&t;&t; * single pass is sufficient.&n;&t;&t;&t; */
id|pass
op_assign
l_int|2
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|zone_start
op_ge
id|vol-&gt;mft_zone_start
op_logical_and
id|zone_start
OL
id|vol-&gt;mft_zone_end
op_logical_and
id|zone
op_eq
id|DATA_ZONE
)paren
(brace
id|zone_start
op_assign
id|vol-&gt;mft_zone_end
suffix:semicolon
id|pass
op_assign
l_int|2
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|zone_start
OL
id|vol-&gt;mft_zone_start
op_logical_or
id|zone_start
op_ge
id|vol-&gt;mft_zone_end
)paren
op_logical_and
id|zone
op_eq
id|MFT_ZONE
)paren
(brace
id|zone_start
op_assign
id|vol-&gt;mft_lcn
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vol-&gt;mft_zone_end
)paren
id|zone_start
op_assign
(paren
id|ntfs_cluster_t
)paren
l_int|0
suffix:semicolon
id|pass
op_assign
l_int|2
suffix:semicolon
)brace
r_if
c_cond
(paren
id|zone
op_eq
id|DATA_ZONE
)paren
(brace
multiline_comment|/* Skip searching the mft zone. */
id|done_zones
op_or_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|zone_start
op_ge
id|vol-&gt;mft_zone_end
)paren
(brace
id|zone_end
op_assign
id|vol-&gt;nr_clusters
suffix:semicolon
id|search_zone
op_assign
l_int|2
suffix:semicolon
)brace
r_else
(brace
id|zone_end
op_assign
id|vol-&gt;mft_zone_start
suffix:semicolon
id|search_zone
op_assign
l_int|4
suffix:semicolon
)brace
)brace
r_else
multiline_comment|/* if (zone == MFT_ZONE) */
(brace
id|zone_end
op_assign
id|vol-&gt;mft_zone_end
suffix:semicolon
id|search_zone
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * buf_pos is the current bit position inside the bitmap. We use&n;&t; * initial_location to determine whether or not to do a zone switch.&n;&t; */
id|buf_pos
op_assign
id|initial_location
op_assign
id|zone_start
suffix:semicolon
multiline_comment|/* Loop until all clusters are allocated, i.e. clusters == 0. */
id|clusters
op_assign
op_star
id|count
suffix:semicolon
id|rlpos
op_assign
id|rlsize
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_star
id|count
op_le
l_int|0
)paren
(brace
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): *count &lt;= 0, &quot;
l_string|&quot;returning -EINVAL.&bslash;n&quot;
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|err_ret
suffix:semicolon
)brace
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): Start of outer while &quot;
l_string|&quot;loop: done_zones = 0x%x, search_zone = %i, &quot;
l_string|&quot;pass = %i, zone_start = 0x%x, zone_end = &quot;
l_string|&quot;0x%x, initial_location = 0x%x, buf_pos = &quot;
l_string|&quot;0x%x, rlpos = %i, rlsize = %i.&bslash;n&quot;
comma
id|done_zones
comma
id|search_zone
comma
id|pass
comma
id|zone_start
comma
id|zone_end
comma
id|initial_location
comma
id|buf_pos
comma
id|rlpos
comma
id|rlsize
)paren
suffix:semicolon
multiline_comment|/* Loop until we run out of free clusters. */
id|io.param
op_assign
id|buf
suffix:semicolon
id|io.size
op_assign
id|PAGE_SIZE
suffix:semicolon
id|io.do_read
op_assign
l_int|1
suffix:semicolon
id|last_read_pos
op_assign
id|buf_pos
op_rshift
l_int|3
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): last_read_pos = &quot;
l_string|&quot;0x%x.&bslash;n&quot;
comma
id|last_read_pos
)paren
suffix:semicolon
id|err
op_assign
id|ntfs_readwrite_attr
c_func
(paren
id|vol-&gt;bitmap
comma
id|data
comma
id|last_read_pos
comma
op_amp
id|io
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): &quot;
l_string|&quot;ntfs_read_attr failed with error &quot;
l_string|&quot;code %i, going to err_ret.&bslash;n&quot;
comma
op_minus
id|err
)paren
suffix:semicolon
r_goto
id|err_ret
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|io.size
)paren
(brace
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): !io.size, &quot;
l_string|&quot;going to zone_pass_done.&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|zone_pass_done
suffix:semicolon
)brace
id|buf_size
op_assign
id|io.size
op_lshift
l_int|3
suffix:semicolon
id|lcn
op_assign
id|buf_pos
op_amp
l_int|7
suffix:semicolon
id|buf_pos
op_and_assign
op_complement
l_int|7
suffix:semicolon
id|need_writeback
op_assign
l_int|0
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): Before inner while &quot;
l_string|&quot;loop: buf_size = 0x%x, lcn = 0x%x, buf_pos = &quot;
l_string|&quot;0x%x, need_writeback = %i.&bslash;n&quot;
comma
id|buf_size
comma
id|lcn
comma
id|buf_pos
comma
id|need_writeback
)paren
suffix:semicolon
r_while
c_loop
(paren
id|lcn
OL
id|buf_size
op_logical_and
id|lcn
op_plus
id|buf_pos
OL
id|zone_end
)paren
(brace
id|byte
op_assign
id|buf
op_plus
(paren
id|lcn
op_rshift
l_int|3
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): In inner &quot;
l_string|&quot;while loop: buf_size = 0x%x, lcn = &quot;
l_string|&quot;0x%x, buf_pos = 0x%x, need_writeback &quot;
l_string|&quot;= %i, byte ofs = 0x%x, *byte = &quot;
l_string|&quot;0x%x.&bslash;n&quot;
comma
id|buf_size
comma
id|lcn
comma
id|buf_pos
comma
id|need_writeback
comma
id|lcn
op_rshift
l_int|3
comma
op_star
id|byte
)paren
suffix:semicolon
multiline_comment|/* Skip full bytes. */
r_if
c_cond
(paren
op_star
id|byte
op_eq
l_int|0xff
)paren
(brace
id|lcn
op_add_assign
l_int|8
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): &quot;
l_string|&quot;continuing while loop 1.&bslash;n&quot;
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|bit
op_assign
l_int|1
op_lshift
(paren
id|lcn
op_amp
l_int|7
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): bit = %i.&bslash;n&quot;
comma
id|bit
)paren
suffix:semicolon
multiline_comment|/* If the bit is already set, go onto the next one. */
r_if
c_cond
(paren
op_star
id|byte
op_amp
id|bit
)paren
(brace
id|lcn
op_increment
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): &quot;
l_string|&quot;continuing while loop 2.&bslash;n&quot;
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* Allocate the bitmap bit. */
op_star
id|byte
op_or_assign
id|bit
suffix:semicolon
multiline_comment|/* We need to write this bitmap buffer back to disk! */
id|need_writeback
op_assign
l_int|1
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): *byte = &quot;
l_string|&quot;0x%x, need_writeback = %i.&bslash;n&quot;
comma
op_star
id|byte
comma
id|need_writeback
)paren
suffix:semicolon
multiline_comment|/* Reallocate memory if necessary. */
r_if
c_cond
(paren
(paren
id|rlpos
op_plus
l_int|2
)paren
op_star
r_sizeof
(paren
id|ntfs_runlist
)paren
op_ge
id|rlsize
)paren
(brace
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): &quot;
l_string|&quot;Reallocating space.&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Setup first free bit return value. */
r_if
c_cond
(paren
op_logical_neg
id|rl2
)paren
(brace
op_star
id|location
op_assign
id|lcn
op_plus
id|buf_pos
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): *location = &quot;
l_string|&quot;0x%x.&bslash;n&quot;
comma
op_star
id|location
)paren
suffix:semicolon
)brace
id|rlsize
op_add_assign
id|PAGE_SIZE
suffix:semicolon
id|rlt
op_assign
id|ntfs_vmalloc
c_func
(paren
id|rlsize
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rlt
)paren
(brace
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): Failed to &quot;
l_string|&quot;allocate memory, &quot;
l_string|&quot;returning -ENOMEM, &quot;
l_string|&quot;going to &quot;
l_string|&quot;wb_err_ret.&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|wb_err_ret
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rl2
)paren
(brace
id|ntfs_memcpy
c_func
(paren
id|rlt
comma
id|rl2
comma
id|rlsize
op_minus
id|PAGE_SIZE
)paren
suffix:semicolon
id|ntfs_vfree
c_func
(paren
id|rl2
)paren
suffix:semicolon
)brace
id|rl2
op_assign
id|rlt
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): &quot;
l_string|&quot;Reallocated memory, rlsize = &quot;
l_string|&quot;0x%x.&bslash;n&quot;
comma
id|rlsize
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * Coalesce with previous run if adjacent LCNs.&n;&t;&t;&t; * Otherwise, append a new run.&n;&t;&t;&t; */
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): Adding run &quot;
l_string|&quot;(lcn 0x%x, len 0x%x), prev_lcn = &quot;
l_string|&quot;0x%x, lcn = 0x%x, buf_pos = 0x%x, &quot;
l_string|&quot;prev_run_len = 0x%x, rlpos = %i.&bslash;n&quot;
comma
id|lcn
op_plus
id|buf_pos
comma
l_int|1
comma
id|prev_lcn
comma
id|lcn
comma
id|buf_pos
comma
id|prev_run_len
comma
id|rlpos
)paren
suffix:semicolon
r_if
c_cond
(paren
id|prev_lcn
op_eq
id|lcn
op_plus
id|buf_pos
op_minus
id|prev_run_len
op_logical_and
id|rlpos
)paren
(brace
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): &quot;
l_string|&quot;Coalescing to run (lcn 0x%x, &quot;
l_string|&quot;len 0x%x).&bslash;n&quot;
comma
id|rl2
(braket
id|rlpos
op_minus
l_int|1
)braket
dot
id|lcn
comma
id|rl2
(braket
id|rlpos
op_minus
l_int|1
)braket
dot
id|len
)paren
suffix:semicolon
id|rl2
(braket
id|rlpos
op_minus
l_int|1
)braket
dot
id|len
op_assign
op_increment
id|prev_run_len
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): &quot;
l_string|&quot;Run now (lcn 0x%x, len 0x%x), &quot;
l_string|&quot;prev_run_len = 0x%x.&bslash;n&quot;
comma
id|rl2
(braket
id|rlpos
op_minus
l_int|1
)braket
dot
id|lcn
comma
id|rl2
(braket
id|rlpos
op_minus
l_int|1
)braket
dot
id|len
comma
id|prev_run_len
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|rlpos
)paren
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): Adding new run, &quot;
l_string|&quot;(previous run lcn &quot;
l_string|&quot;0x%x, len 0x%x).&bslash;n&quot;
comma
id|rl2
(braket
id|rlpos
op_minus
l_int|1
)braket
dot
id|lcn
comma
id|rl2
(braket
id|rlpos
op_minus
l_int|1
)braket
dot
id|len
)paren
suffix:semicolon
r_else
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): Adding new run, &quot;
l_string|&quot;is first run.&bslash;n&quot;
)paren
suffix:semicolon
id|rl2
(braket
id|rlpos
)braket
dot
id|lcn
op_assign
id|prev_lcn
op_assign
id|lcn
op_plus
id|buf_pos
suffix:semicolon
id|rl2
(braket
id|rlpos
)braket
dot
id|len
op_assign
id|prev_run_len
op_assign
(paren
id|ntfs_cluster_t
)paren
l_int|1
suffix:semicolon
id|rlpos
op_increment
suffix:semicolon
)brace
multiline_comment|/* Done? */
r_if
c_cond
(paren
op_logical_neg
op_decrement
id|clusters
)paren
(brace
id|ntfs_cluster_t
id|tc
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * Update the current zone position. Positions&n;&t;&t;&t;&t; * of already scanned zones have been updated&n;&t;&t;&t;&t; * during the respective zone switches.&n;&t;&t;&t;&t; */
id|tc
op_assign
id|lcn
op_plus
id|buf_pos
op_plus
l_int|1
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): &quot;
l_string|&quot;Done. Updating current zone &quot;
l_string|&quot;position, tc = 0x%x, &quot;
l_string|&quot;search_zone = %i.&bslash;n&quot;
comma
id|tc
comma
id|search_zone
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|search_zone
)paren
(brace
r_case
l_int|1
suffix:colon
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): Before checks, &quot;
l_string|&quot;vol-&gt;mft_zone_pos = &quot;
l_string|&quot;0x%x.&bslash;n&quot;
comma
id|vol-&gt;mft_zone_pos
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tc
op_ge
id|vol-&gt;mft_zone_end
)paren
(brace
id|vol-&gt;mft_zone_pos
op_assign
id|vol-&gt;mft_lcn
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vol-&gt;mft_zone_end
)paren
id|vol-&gt;mft_zone_pos
op_assign
(paren
id|ntfs_cluster_t
)paren
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|initial_location
op_ge
id|vol-&gt;mft_zone_pos
op_logical_or
id|tc
OG
id|vol-&gt;mft_zone_pos
)paren
op_logical_and
id|tc
op_ge
id|vol-&gt;mft_lcn
)paren
id|vol-&gt;mft_zone_pos
op_assign
id|tc
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): After checks, &quot;
l_string|&quot;vol-&gt;mft_zone_pos = &quot;
l_string|&quot;0x%x.&bslash;n&quot;
comma
id|vol-&gt;mft_zone_pos
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): Before checks, &quot;
l_string|&quot;vol-&gt;data1_zone_pos = &quot;
l_string|&quot;0x%x.&bslash;n&quot;
comma
id|vol-&gt;data1_zone_pos
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tc
op_ge
id|vol-&gt;nr_clusters
)paren
id|vol-&gt;data1_zone_pos
op_assign
id|vol-&gt;mft_zone_end
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|initial_location
op_ge
id|vol-&gt;data1_zone_pos
op_logical_or
id|tc
OG
id|vol-&gt;data1_zone_pos
)paren
op_logical_and
id|tc
op_ge
id|vol-&gt;mft_zone_end
)paren
id|vol-&gt;data1_zone_pos
op_assign
id|tc
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): After checks, &quot;
l_string|&quot;vol-&gt;data1_zone_pos = &quot;
l_string|&quot;0x%x.&bslash;n&quot;
comma
id|vol-&gt;data1_zone_pos
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): Before checks, &quot;
l_string|&quot;vol-&gt;data2_zone_pos = &quot;
l_string|&quot;0x%x.&bslash;n&quot;
comma
id|vol-&gt;data2_zone_pos
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tc
op_ge
id|vol-&gt;mft_zone_start
)paren
id|vol-&gt;data2_zone_pos
op_assign
(paren
id|ntfs_cluster_t
)paren
l_int|0
suffix:semicolon
r_else
r_if
c_cond
(paren
id|initial_location
op_ge
id|vol-&gt;data2_zone_pos
op_logical_or
id|tc
OG
id|vol-&gt;data2_zone_pos
)paren
id|vol-&gt;data2_zone_pos
op_assign
id|tc
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): After checks, &quot;
l_string|&quot;vol-&gt;data2_zone_pos = &quot;
l_string|&quot;0x%x.&bslash;n&quot;
comma
id|vol-&gt;data2_zone_pos
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): &quot;
l_string|&quot;Going to done_ret.&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|done_ret
suffix:semicolon
)brace
id|lcn
op_increment
suffix:semicolon
)brace
id|buf_pos
op_add_assign
id|buf_size
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): After inner while &quot;
l_string|&quot;loop: buf_size = 0x%x, lcn = 0x%x, buf_pos = &quot;
l_string|&quot;0x%x, need_writeback = %i.&bslash;n&quot;
comma
id|buf_size
comma
id|lcn
comma
id|buf_pos
comma
id|need_writeback
)paren
suffix:semicolon
r_if
c_cond
(paren
id|need_writeback
)paren
(brace
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): Writing &quot;
l_string|&quot;back.&bslash;n&quot;
)paren
suffix:semicolon
id|need_writeback
op_assign
l_int|0
suffix:semicolon
id|io.param
op_assign
id|buf
suffix:semicolon
id|io.do_read
op_assign
l_int|0
suffix:semicolon
id|err
op_assign
id|ntfs_readwrite_attr
c_func
(paren
id|vol-&gt;bitmap
comma
id|data
comma
id|last_read_pos
comma
op_amp
id|io
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|ntfs_error
c_func
(paren
id|__FUNCTION__
l_string|&quot;(): Bitmap writeback &quot;
l_string|&quot;failed in read next buffer &quot;
l_string|&quot;code path with error code &quot;
l_string|&quot;%i.&bslash;n&quot;
comma
op_minus
id|err
)paren
suffix:semicolon
r_goto
id|err_ret
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|buf_pos
OL
id|zone_end
)paren
(brace
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): Continuing &quot;
l_string|&quot;outer while loop, buf_pos = 0x%x, &quot;
l_string|&quot;zone_end = 0x%x.&bslash;n&quot;
comma
id|buf_pos
comma
id|zone_end
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|zone_pass_done
suffix:colon
multiline_comment|/* Finished with the current zone pass. */
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): At zone_pass_done, &quot;
l_string|&quot;pass = %i.&bslash;n&quot;
comma
id|pass
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pass
op_eq
l_int|1
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Now do pass 2, scanning the first part of the zone&n;&t;&t;&t; * we omitted in pass 1.&n;&t;&t;&t; */
id|pass
op_assign
l_int|2
suffix:semicolon
id|zone_end
op_assign
id|zone_start
suffix:semicolon
r_switch
c_cond
(paren
id|search_zone
)paren
(brace
r_case
l_int|1
suffix:colon
multiline_comment|/* mft_zone */
id|zone_start
op_assign
id|vol-&gt;mft_zone_start
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
multiline_comment|/* data1_zone */
id|zone_start
op_assign
id|vol-&gt;mft_zone_end
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
multiline_comment|/* data2_zone */
id|zone_start
op_assign
(paren
id|ntfs_cluster_t
)paren
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Sanity check. */
r_if
c_cond
(paren
id|zone_end
OL
id|zone_start
)paren
id|zone_end
op_assign
id|zone_start
suffix:semicolon
id|buf_pos
op_assign
id|zone_start
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): Continuing &quot;
l_string|&quot;outer while loop, pass = 2, &quot;
l_string|&quot;zone_start = 0x%x, zone_end = 0x%x, &quot;
l_string|&quot;buf_pos = 0x%x.&bslash;n&quot;
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* pass == 2 */
id|done_zones_check
suffix:colon
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): At done_zones_check, &quot;
l_string|&quot;search_zone = %i, done_zones before = 0x%x, &quot;
l_string|&quot;done_zones after = 0x%x.&bslash;n&quot;
comma
id|search_zone
comma
id|done_zones
comma
id|done_zones
op_or
id|search_zone
)paren
suffix:semicolon
id|done_zones
op_or_assign
id|search_zone
suffix:semicolon
r_if
c_cond
(paren
id|done_zones
OL
l_int|7
)paren
(brace
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): Switching &quot;
l_string|&quot;zone.&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Now switch to the next zone we haven&squot;t done yet. */
id|pass
op_assign
l_int|1
suffix:semicolon
r_switch
c_cond
(paren
id|search_zone
)paren
(brace
r_case
l_int|1
suffix:colon
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): &quot;
l_string|&quot;Switching from mft zone to &quot;
l_string|&quot;data1 zone.&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Update mft zone position. */
r_if
c_cond
(paren
id|rlpos
)paren
(brace
id|ntfs_cluster_t
id|tc
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): Before checks, &quot;
l_string|&quot;vol-&gt;mft_zone_pos = &quot;
l_string|&quot;0x%x.&bslash;n&quot;
comma
id|vol-&gt;mft_zone_pos
)paren
suffix:semicolon
id|tc
op_assign
id|rl2
(braket
id|rlpos
op_minus
l_int|1
)braket
dot
id|lcn
op_plus
id|rl2
(braket
id|rlpos
op_minus
l_int|1
)braket
dot
id|len
suffix:semicolon
r_if
c_cond
(paren
id|tc
op_ge
id|vol-&gt;mft_zone_end
)paren
(brace
id|vol-&gt;mft_zone_pos
op_assign
id|vol-&gt;mft_lcn
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vol-&gt;mft_zone_end
)paren
id|vol-&gt;mft_zone_pos
op_assign
(paren
id|ntfs_cluster_t
)paren
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|initial_location
op_ge
id|vol-&gt;mft_zone_pos
op_logical_or
id|tc
OG
id|vol-&gt;mft_zone_pos
)paren
op_logical_and
id|tc
op_ge
id|vol-&gt;mft_lcn
)paren
id|vol-&gt;mft_zone_pos
op_assign
id|tc
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): After checks, &quot;
l_string|&quot;vol-&gt;mft_zone_pos = &quot;
l_string|&quot;0x%x.&bslash;n&quot;
comma
id|vol-&gt;mft_zone_pos
)paren
suffix:semicolon
)brace
multiline_comment|/* Switch from mft zone to data1 zone. */
id|switch_to_data1_zone
suffix:colon
id|search_zone
op_assign
l_int|2
suffix:semicolon
id|zone_start
op_assign
id|initial_location
op_assign
id|vol-&gt;data1_zone_pos
suffix:semicolon
id|zone_end
op_assign
id|vol-&gt;nr_clusters
suffix:semicolon
r_if
c_cond
(paren
id|zone_start
op_eq
id|vol-&gt;mft_zone_end
)paren
id|pass
op_assign
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|zone_start
op_ge
id|zone_end
)paren
(brace
id|vol-&gt;data1_zone_pos
op_assign
id|zone_start
op_assign
id|vol-&gt;mft_zone_end
suffix:semicolon
id|pass
op_assign
l_int|2
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): &quot;
l_string|&quot;Switching from data1 zone to &quot;
l_string|&quot;data2 zone.&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Update data1 zone position. */
r_if
c_cond
(paren
id|rlpos
)paren
(brace
id|ntfs_cluster_t
id|tc
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): Before checks, &quot;
l_string|&quot;vol-&gt;data1_zone_pos = &quot;
l_string|&quot;0x%x.&bslash;n&quot;
comma
id|vol-&gt;data1_zone_pos
)paren
suffix:semicolon
id|tc
op_assign
id|rl2
(braket
id|rlpos
op_minus
l_int|1
)braket
dot
id|lcn
op_plus
id|rl2
(braket
id|rlpos
op_minus
l_int|1
)braket
dot
id|len
suffix:semicolon
r_if
c_cond
(paren
id|tc
op_ge
id|vol-&gt;nr_clusters
)paren
id|vol-&gt;data1_zone_pos
op_assign
id|vol-&gt;mft_zone_end
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|initial_location
op_ge
id|vol-&gt;data1_zone_pos
op_logical_or
id|tc
OG
id|vol-&gt;data1_zone_pos
)paren
op_logical_and
id|tc
op_ge
id|vol-&gt;mft_zone_end
)paren
id|vol-&gt;data1_zone_pos
op_assign
id|tc
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): After checks, &quot;
l_string|&quot;vol-&gt;data1_zone_pos = &quot;
l_string|&quot;0x%x.&bslash;n&quot;
comma
id|vol-&gt;data1_zone_pos
)paren
suffix:semicolon
)brace
multiline_comment|/* Switch from data1 zone to data2 zone. */
id|search_zone
op_assign
l_int|4
suffix:semicolon
id|zone_start
op_assign
id|initial_location
op_assign
id|vol-&gt;data2_zone_pos
suffix:semicolon
id|zone_end
op_assign
id|vol-&gt;mft_zone_start
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|zone_start
)paren
id|pass
op_assign
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|zone_start
op_ge
id|zone_end
)paren
(brace
id|vol-&gt;data2_zone_pos
op_assign
id|zone_start
op_assign
id|initial_location
op_assign
(paren
id|ntfs_cluster_t
)paren
l_int|0
suffix:semicolon
id|pass
op_assign
l_int|2
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): &quot;
l_string|&quot;Switching from data2 zone to &quot;
l_string|&quot;data1 zone.&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Update data2 zone position. */
r_if
c_cond
(paren
id|rlpos
)paren
(brace
id|ntfs_cluster_t
id|tc
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): Before checks, &quot;
l_string|&quot;vol-&gt;data2_zone_pos = &quot;
l_string|&quot;0x%x.&bslash;n&quot;
comma
id|vol-&gt;data2_zone_pos
)paren
suffix:semicolon
id|tc
op_assign
id|rl2
(braket
id|rlpos
op_minus
l_int|1
)braket
dot
id|lcn
op_plus
id|rl2
(braket
id|rlpos
op_minus
l_int|1
)braket
dot
id|len
suffix:semicolon
r_if
c_cond
(paren
id|tc
op_ge
id|vol-&gt;mft_zone_start
)paren
id|vol-&gt;data2_zone_pos
op_assign
(paren
id|ntfs_cluster_t
)paren
l_int|0
suffix:semicolon
r_else
r_if
c_cond
(paren
id|initial_location
op_ge
id|vol-&gt;data2_zone_pos
op_logical_or
id|tc
OG
id|vol-&gt;data2_zone_pos
)paren
id|vol-&gt;data2_zone_pos
op_assign
id|tc
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): After checks, &quot;
l_string|&quot;vol-&gt;data2_zone_pos = &quot;
l_string|&quot;0x%x.&bslash;n&quot;
comma
id|vol-&gt;data2_zone_pos
)paren
suffix:semicolon
)brace
multiline_comment|/* Switch from data2 zone to data1 zone. */
r_goto
id|switch_to_data1_zone
suffix:semicolon
multiline_comment|/* See above. */
r_default
suffix:colon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): After zone &quot;
l_string|&quot;switch, search_zone = %i, pass = %i, &quot;
l_string|&quot;initial_location = 0x%x, zone_start &quot;
l_string|&quot;= 0x%x, zone_end = 0x%x.&bslash;n&quot;
comma
id|search_zone
comma
id|pass
comma
id|initial_location
comma
id|zone_start
comma
id|zone_end
)paren
suffix:semicolon
id|buf_pos
op_assign
id|zone_start
suffix:semicolon
r_if
c_cond
(paren
id|zone_start
op_eq
id|zone_end
)paren
(brace
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): &quot;
l_string|&quot;Empty zone, going to &quot;
l_string|&quot;done_zones_check.&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Empty zone. Don&squot;t bother searching it. */
r_goto
id|done_zones_check
suffix:semicolon
)brace
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): Continuing &quot;
l_string|&quot;outer while loop.&bslash;n&quot;
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* done_zones == 7 */
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): All zones are &quot;
l_string|&quot;finished.&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * All zones are finished! If DATA_ZONE, shrink mft zone. If&n;&t;&t; * MFT_ZONE, we have really run out of space.&n;&t;&t; */
id|mft_zone_size
op_assign
id|vol-&gt;mft_zone_end
op_minus
id|vol-&gt;mft_zone_start
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): vol-&gt;mft_zone_start &quot;
l_string|&quot;= 0x%x, vol-&gt;mft_zone_end = 0x%x, &quot;
l_string|&quot;mft_zone_size = 0x%x.&bslash;n&quot;
comma
id|vol-&gt;mft_zone_start
comma
id|vol-&gt;mft_zone_end
comma
id|mft_zone_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|zone
op_eq
id|MFT_ZONE
op_logical_or
id|mft_zone_size
op_le
(paren
id|ntfs_cluster_t
)paren
l_int|0
)paren
(brace
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): No free &quot;
l_string|&quot;clusters left, returning -ENOSPC, &quot;
l_string|&quot;going to fail_ret.&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Really no more space left on device. */
id|err
op_assign
op_minus
id|ENOSPC
suffix:semicolon
r_goto
id|fail_ret
suffix:semicolon
)brace
multiline_comment|/* zone == DATA_ZONE &amp;&amp; mft_zone_size &gt; 0 */
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): Shrinking mft &quot;
l_string|&quot;zone.&bslash;n&quot;
)paren
suffix:semicolon
id|zone_end
op_assign
id|vol-&gt;mft_zone_end
suffix:semicolon
id|mft_zone_size
op_rshift_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|mft_zone_size
OG
(paren
id|ntfs_cluster_t
)paren
l_int|0
)paren
id|vol-&gt;mft_zone_end
op_assign
id|vol-&gt;mft_zone_start
op_plus
id|mft_zone_size
suffix:semicolon
r_else
multiline_comment|/* mft zone and data2 zone no longer exist. */
id|vol-&gt;data2_zone_pos
op_assign
id|vol-&gt;mft_zone_start
op_assign
id|vol-&gt;mft_zone_end
op_assign
(paren
id|ntfs_cluster_t
)paren
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|vol-&gt;mft_zone_pos
op_ge
id|vol-&gt;mft_zone_end
)paren
(brace
id|vol-&gt;mft_zone_pos
op_assign
id|vol-&gt;mft_lcn
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vol-&gt;mft_zone_end
)paren
id|vol-&gt;mft_zone_pos
op_assign
(paren
id|ntfs_cluster_t
)paren
l_int|0
suffix:semicolon
)brace
id|buf_pos
op_assign
id|zone_start
op_assign
id|initial_location
op_assign
id|vol-&gt;data1_zone_pos
op_assign
id|vol-&gt;mft_zone_end
suffix:semicolon
id|search_zone
op_assign
l_int|2
suffix:semicolon
id|pass
op_assign
l_int|2
suffix:semicolon
id|done_zones
op_and_assign
op_complement
l_int|2
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): After shrinking mft &quot;
l_string|&quot;zone, mft_zone_size = 0x%x, &quot;
l_string|&quot;vol-&gt;mft_zone_start = 0x%x, vol-&gt;mft_zone_end &quot;
l_string|&quot;= 0x%x, vol-&gt;mft_zone_pos = 0x%x, search_zone &quot;
l_string|&quot;= 2, pass = 2, dones_zones = 0x%x, zone_start &quot;
l_string|&quot;= 0x%x, zone_end = 0x%x, vol-&gt;data1_zone_pos &quot;
l_string|&quot;= 0x%x, continuing outer while loop.&bslash;n&quot;
comma
id|mft_zone_size
comma
id|vol-&gt;mft_zone_start
comma
id|vol-&gt;mft_zone_end
comma
id|vol-&gt;mft_zone_pos
comma
id|search_zone
comma
id|pass
comma
id|done_zones
comma
id|zone_start
comma
id|zone_end
comma
id|vol-&gt;data1_zone_pos
)paren
suffix:semicolon
)brace
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): After outer while loop.&bslash;n&quot;
)paren
suffix:semicolon
id|done_ret
suffix:colon
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): At done_ret.&bslash;n&quot;
)paren
suffix:semicolon
id|rl2
(braket
id|rlpos
)braket
dot
id|lcn
op_assign
(paren
id|ntfs_cluster_t
)paren
op_minus
l_int|1
suffix:semicolon
id|rl2
(braket
id|rlpos
)braket
dot
id|len
op_assign
(paren
id|ntfs_cluster_t
)paren
l_int|0
suffix:semicolon
op_star
id|rl
op_assign
id|rl2
suffix:semicolon
op_star
id|rl_len
op_assign
id|rlpos
suffix:semicolon
r_if
c_cond
(paren
id|need_writeback
)paren
(brace
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): Writing back.&bslash;n&quot;
)paren
suffix:semicolon
id|need_writeback
op_assign
l_int|0
suffix:semicolon
id|io.param
op_assign
id|buf
suffix:semicolon
id|io.do_read
op_assign
l_int|0
suffix:semicolon
id|err
op_assign
id|ntfs_readwrite_attr
c_func
(paren
id|vol-&gt;bitmap
comma
id|data
comma
id|last_read_pos
comma
op_amp
id|io
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|ntfs_error
c_func
(paren
id|__FUNCTION__
l_string|&quot;(): Bitmap writeback failed &quot;
l_string|&quot;in done code path with error code &quot;
l_string|&quot;%i.&bslash;n&quot;
comma
op_minus
id|err
)paren
suffix:semicolon
r_goto
id|err_ret
suffix:semicolon
)brace
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): Wrote 0x%Lx bytes.&bslash;n&quot;
comma
id|io.size
)paren
suffix:semicolon
)brace
id|done_fail_ret
suffix:colon
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): At done_fail_ret (follows &quot;
l_string|&quot;done_ret).&bslash;n&quot;
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
id|free_page
c_func
(paren
(paren
r_int
r_int
)paren
id|buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
id|ntfs_debug
c_func
(paren
id|DEBUG_FILE3
comma
id|__FUNCTION__
l_string|&quot;(): Failed to allocate &quot;
l_string|&quot;clusters. Returning with error code %i.&bslash;n&quot;
comma
op_minus
id|err
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): Syncing $Bitmap inode.&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ntfs_update_inode
c_func
(paren
id|vol-&gt;bitmap
)paren
)paren
id|ntfs_error
c_func
(paren
id|__FUNCTION__
l_string|&quot;(): Failed to sync inode $Bitmap. &quot;
l_string|&quot;Continuing anyway.&bslash;n&quot;
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): Returning with code %i.&bslash;n&quot;
comma
id|err
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
id|fail_ret
suffix:colon
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): At fail_ret.&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rl2
)paren
(brace
r_if
c_cond
(paren
id|err
op_eq
op_minus
id|ENOSPC
)paren
(brace
multiline_comment|/* Return first free lcn and count of free clusters. */
op_star
id|location
op_assign
id|rl2
(braket
l_int|0
)braket
dot
id|lcn
suffix:semicolon
op_star
id|count
op_sub_assign
id|clusters
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): err = &quot;
l_string|&quot;-ENOSPC, *location = 0x%x, *count = &quot;
l_string|&quot;0x%x.&bslash;n&quot;
comma
op_star
id|location
comma
op_star
id|count
)paren
suffix:semicolon
)brace
multiline_comment|/* Deallocate all allocated clusters. */
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): Deallocating &quot;
l_string|&quot;allocated clusters.&bslash;n&quot;
)paren
suffix:semicolon
id|ntfs_deallocate_clusters
c_func
(paren
id|vol
comma
id|rl2
comma
id|rlpos
)paren
suffix:semicolon
multiline_comment|/* Free the runlist. */
id|ntfs_vfree
c_func
(paren
id|rl2
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|err
op_eq
op_minus
id|ENOSPC
)paren
(brace
multiline_comment|/* Nothing free at all. */
op_star
id|location
op_assign
id|vol-&gt;data1_zone_pos
suffix:semicolon
multiline_comment|/* Irrelevant... */
op_star
id|count
op_assign
l_int|0
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): No space &quot;
l_string|&quot;left at all, err = -ENOSPC, *location &quot;
l_string|&quot;= 0x%x, *count = 0.&bslash;n&quot;
comma
op_star
id|location
)paren
suffix:semicolon
)brace
)brace
op_star
id|rl
op_assign
l_int|NULL
suffix:semicolon
op_star
id|rl_len
op_assign
l_int|0
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): *rl = NULL, *rl_len = 0, &quot;
l_string|&quot;going to done_fail_ret.&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|done_fail_ret
suffix:semicolon
id|wb_err_ret
suffix:colon
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): At wb_err_ret.&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|need_writeback
)paren
(brace
r_int
id|__err
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): Writing back.&bslash;n&quot;
)paren
suffix:semicolon
id|io.param
op_assign
id|buf
suffix:semicolon
id|io.do_read
op_assign
l_int|0
suffix:semicolon
id|__err
op_assign
id|ntfs_readwrite_attr
c_func
(paren
id|vol-&gt;bitmap
comma
id|data
comma
id|last_read_pos
comma
op_amp
id|io
)paren
suffix:semicolon
r_if
c_cond
(paren
id|__err
)paren
id|ntfs_error
c_func
(paren
id|__FUNCTION__
l_string|&quot;(): Bitmap writeback failed &quot;
l_string|&quot;in error code path with error code &quot;
l_string|&quot;%i.&bslash;n&quot;
comma
op_minus
id|__err
)paren
suffix:semicolon
id|need_writeback
op_assign
l_int|0
suffix:semicolon
)brace
id|err_ret
suffix:colon
id|ntfs_debug
c_func
(paren
id|DEBUG_OTHER
comma
id|__FUNCTION__
l_string|&quot;(): At err_ret, *location = -1, &quot;
l_string|&quot;*count = 0, going to fail_ret.&bslash;n&quot;
)paren
suffix:semicolon
op_star
id|location
op_assign
op_minus
l_int|1
suffix:semicolon
op_star
id|count
op_assign
l_int|0
suffix:semicolon
r_goto
id|fail_ret
suffix:semicolon
)brace
multiline_comment|/*&n; * IMPORTANT: Caller has to hold big kernel lock or the race monster will come&n; * to get you! (-;&n; * TODO: Need our own lock for bitmap accesses but BKL is more secure for now,&n; * considering we might not have covered all places with a lock yet. In that&n; * case the BKL offers a one way exclusion which is better than no exclusion&n; * at all... (AIA)&n; */
DECL|function|ntfs_clear_bitrange
r_static
r_int
id|ntfs_clear_bitrange
c_func
(paren
id|ntfs_inode
op_star
id|bitmap
comma
r_const
id|ntfs_cluster_t
id|start_bit
comma
r_const
id|ntfs_cluster_t
id|count
)paren
(brace
id|ntfs_cluster_t
id|buf_size
comma
id|bit
comma
id|nr_bits
op_assign
id|count
suffix:semicolon
r_int
r_char
op_star
id|buf
comma
op_star
id|byte
suffix:semicolon
r_int
id|err
suffix:semicolon
id|ntfs_io
id|io
suffix:semicolon
id|io.fn_put
op_assign
id|ntfs_put
suffix:semicolon
id|io.fn_get
op_assign
id|ntfs_get
suffix:semicolon
multiline_comment|/* Calculate the required buffer size in bytes. */
id|buf_size
op_assign
(paren
id|ntfs_cluster_t
)paren
(paren
(paren
id|start_bit
op_amp
l_int|7
)paren
op_plus
id|nr_bits
op_plus
l_int|7
)paren
op_rshift
l_int|3
suffix:semicolon
r_if
c_cond
(paren
id|buf_size
op_le
(paren
id|ntfs_cluster_t
)paren
(paren
l_int|64
op_star
l_int|1024
)paren
)paren
id|buf
op_assign
id|ntfs_malloc
c_func
(paren
id|buf_size
)paren
suffix:semicolon
r_else
id|buf
op_assign
id|ntfs_vmalloc
c_func
(paren
id|buf_size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buf
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
multiline_comment|/* Read the bitmap from the data attribute. */
id|io.param
op_assign
id|byte
op_assign
id|buf
suffix:semicolon
id|io.size
op_assign
id|buf_size
suffix:semicolon
id|err
op_assign
id|ntfs_read_attr
c_func
(paren
id|bitmap
comma
id|bitmap-&gt;vol-&gt;at_data
comma
l_int|0
comma
id|start_bit
op_rshift
l_int|3
comma
op_amp
id|io
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_logical_or
id|io.size
op_ne
id|buf_size
)paren
r_goto
id|err_out
suffix:semicolon
multiline_comment|/* Now clear the bits in the read bitmap. */
id|bit
op_assign
id|start_bit
op_amp
l_int|7
suffix:semicolon
r_while
c_loop
(paren
id|bit
op_logical_and
id|nr_bits
)paren
(brace
multiline_comment|/* Process first partial byte, if present. */
op_star
id|byte
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|bit
op_increment
)paren
suffix:semicolon
id|nr_bits
op_decrement
suffix:semicolon
id|bit
op_and_assign
l_int|7
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bit
)paren
id|byte
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
id|nr_bits
op_ge
l_int|8
)paren
(brace
multiline_comment|/* Process full bytes. */
op_star
id|byte
op_assign
l_int|0
suffix:semicolon
id|nr_bits
op_sub_assign
l_int|8
suffix:semicolon
id|byte
op_increment
suffix:semicolon
)brace
id|bit
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|nr_bits
)paren
(brace
multiline_comment|/* Process last partial byte, if present. */
op_star
id|byte
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|bit
)paren
suffix:semicolon
id|nr_bits
op_decrement
suffix:semicolon
id|bit
op_increment
suffix:semicolon
)brace
multiline_comment|/* Write the modified bitmap back to disk. */
id|io.param
op_assign
id|buf
suffix:semicolon
id|io.size
op_assign
id|buf_size
suffix:semicolon
id|err
op_assign
id|ntfs_write_attr
c_func
(paren
id|bitmap
comma
id|bitmap-&gt;vol-&gt;at_data
comma
l_int|0
comma
id|start_bit
op_rshift
l_int|3
comma
op_amp
id|io
)paren
suffix:semicolon
id|err_out
suffix:colon
r_if
c_cond
(paren
id|buf_size
op_le
(paren
id|ntfs_cluster_t
)paren
(paren
l_int|64
op_star
l_int|1024
)paren
)paren
id|ntfs_free
c_func
(paren
id|buf
)paren
suffix:semicolon
r_else
id|ntfs_vfree
c_func
(paren
id|buf
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|err
op_logical_and
id|io.size
op_ne
id|buf_size
)paren
id|err
op_assign
op_minus
id|EIO
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; * See comments for lack of zone adjustments below in the description of the&n; * function ntfs_deallocate_clusters().&n; */
DECL|function|ntfs_deallocate_cluster_run
r_int
id|ntfs_deallocate_cluster_run
c_func
(paren
r_const
id|ntfs_volume
op_star
id|vol
comma
r_const
id|ntfs_cluster_t
id|lcn
comma
r_const
id|ntfs_cluster_t
id|len
)paren
(brace
r_int
id|err
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|err
op_assign
id|ntfs_clear_bitrange
c_func
(paren
id|vol-&gt;bitmap
comma
id|lcn
comma
id|len
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; * This is inefficient, but logically trivial, so will do for now. Note, we&n; * do not touch the mft nor the data zones here because we want to minimize&n; * recycling of clusters to enhance the chances of data being undeleteable.&n; * Also we don&squot;t want the overhead. Instead we do one additional sweep of the&n; * current data zone during cluster allocation to check for freed clusters.&n; */
DECL|function|ntfs_deallocate_clusters
r_int
id|ntfs_deallocate_clusters
c_func
(paren
r_const
id|ntfs_volume
op_star
id|vol
comma
r_const
id|ntfs_runlist
op_star
id|rl
comma
r_const
r_int
id|rl_len
)paren
(brace
r_int
id|i
comma
id|err
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|err
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|rl_len
op_logical_and
op_logical_neg
id|err
suffix:semicolon
id|i
op_increment
)paren
id|err
op_assign
id|ntfs_clear_bitrange
c_func
(paren
id|vol-&gt;bitmap
comma
id|rl
(braket
id|i
)braket
dot
id|lcn
comma
id|rl
(braket
id|i
)braket
dot
id|len
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
eof
