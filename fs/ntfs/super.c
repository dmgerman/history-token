multiline_comment|/*&n; * super.c - NTFS kernel super block handling. Part of the Linux-NTFS project.&n; *&n; * Copyright (c) 2001-2004 Anton Altaparmakov&n; * Copyright (c) 2001,2002 Richard Russon&n; *&n; * This program/include file is free software; you can redistribute it and/or&n; * modify it under the terms of the GNU General Public License as published&n; * by the Free Software Foundation; either version 2 of the License, or&n; * (at your option) any later version.&n; *&n; * This program/include file is distributed in the hope that it will be&n; * useful, but WITHOUT ANY WARRANTY; without even the implied warranty&n; * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; * GNU General Public License for more details.&n; *&n; * You should have received a copy of the GNU General Public License&n; * along with this program (in the main directory of the Linux-NTFS&n; * distribution in the file COPYING); if not, write to the Free Software&n; * Foundation,Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA&n; */
macro_line|#include &lt;linux/stddef.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/blkdev.h&gt;&t;/* For bdev_hardsect_size(). */
macro_line|#include &lt;linux/backing-dev.h&gt;
macro_line|#include &lt;linux/buffer_head.h&gt;
macro_line|#include &lt;linux/vfs.h&gt;
macro_line|#include &quot;ntfs.h&quot;
macro_line|#include &quot;sysctl.h&quot;
macro_line|#include &quot;logfile.h&quot;
multiline_comment|/* Number of mounted file systems which have compression enabled. */
DECL|variable|ntfs_nr_compression_users
r_static
r_int
r_int
id|ntfs_nr_compression_users
suffix:semicolon
multiline_comment|/* Error constants/strings used in inode.c::ntfs_show_options(). */
r_typedef
r_enum
(brace
multiline_comment|/* One of these must be present, default is ON_ERRORS_CONTINUE. */
DECL|enumerator|ON_ERRORS_PANIC
id|ON_ERRORS_PANIC
op_assign
l_int|0x01
comma
DECL|enumerator|ON_ERRORS_REMOUNT_RO
id|ON_ERRORS_REMOUNT_RO
op_assign
l_int|0x02
comma
DECL|enumerator|ON_ERRORS_CONTINUE
id|ON_ERRORS_CONTINUE
op_assign
l_int|0x04
comma
multiline_comment|/* Optional, can be combined with any of the above. */
DECL|enumerator|ON_ERRORS_RECOVER
id|ON_ERRORS_RECOVER
op_assign
l_int|0x10
comma
DECL|typedef|ON_ERRORS_ACTIONS
)brace
id|ON_ERRORS_ACTIONS
suffix:semicolon
DECL|variable|on_errors_arr
r_const
id|option_t
id|on_errors_arr
(braket
)braket
op_assign
(brace
(brace
id|ON_ERRORS_PANIC
comma
l_string|&quot;panic&quot;
)brace
comma
(brace
id|ON_ERRORS_REMOUNT_RO
comma
l_string|&quot;remount-ro&quot;
comma
)brace
comma
(brace
id|ON_ERRORS_CONTINUE
comma
l_string|&quot;continue&quot;
comma
)brace
comma
(brace
id|ON_ERRORS_RECOVER
comma
l_string|&quot;recover&quot;
)brace
comma
(brace
l_int|0
comma
l_int|NULL
)brace
)brace
suffix:semicolon
multiline_comment|/**&n; * simple_getbool -&n; *&n; * Copied from old ntfs driver (which copied from vfat driver).&n; */
DECL|function|simple_getbool
r_static
r_int
id|simple_getbool
c_func
(paren
r_char
op_star
id|s
comma
id|BOOL
op_star
id|setval
)paren
(brace
r_if
c_cond
(paren
id|s
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|s
comma
l_string|&quot;1&quot;
)paren
op_logical_or
op_logical_neg
id|strcmp
c_func
(paren
id|s
comma
l_string|&quot;yes&quot;
)paren
op_logical_or
op_logical_neg
id|strcmp
c_func
(paren
id|s
comma
l_string|&quot;true&quot;
)paren
)paren
op_star
id|setval
op_assign
id|TRUE
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|s
comma
l_string|&quot;0&quot;
)paren
op_logical_or
op_logical_neg
id|strcmp
c_func
(paren
id|s
comma
l_string|&quot;no&quot;
)paren
op_logical_or
op_logical_neg
id|strcmp
c_func
(paren
id|s
comma
l_string|&quot;false&quot;
)paren
)paren
op_star
id|setval
op_assign
id|FALSE
suffix:semicolon
r_else
r_return
l_int|0
suffix:semicolon
)brace
r_else
op_star
id|setval
op_assign
id|TRUE
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/**&n; * parse_options - parse the (re)mount options&n; * @vol:&t;ntfs volume&n; * @opt:&t;string containing the (re)mount options&n; *&n; * Parse the recognized options in @opt for the ntfs volume described by @vol.&n; */
DECL|function|parse_options
r_static
id|BOOL
id|parse_options
c_func
(paren
id|ntfs_volume
op_star
id|vol
comma
r_char
op_star
id|opt
)paren
(brace
r_char
op_star
id|p
comma
op_star
id|v
comma
op_star
id|ov
suffix:semicolon
r_static
r_char
op_star
id|utf8
op_assign
l_string|&quot;utf8&quot;
suffix:semicolon
r_int
id|errors
op_assign
l_int|0
comma
id|sloppy
op_assign
l_int|0
suffix:semicolon
id|uid_t
id|uid
op_assign
(paren
id|uid_t
)paren
op_minus
l_int|1
suffix:semicolon
id|gid_t
id|gid
op_assign
(paren
id|gid_t
)paren
op_minus
l_int|1
suffix:semicolon
id|mode_t
id|fmask
op_assign
(paren
id|mode_t
)paren
op_minus
l_int|1
comma
id|dmask
op_assign
(paren
id|mode_t
)paren
op_minus
l_int|1
suffix:semicolon
r_int
id|mft_zone_multiplier
op_assign
op_minus
l_int|1
comma
id|on_errors
op_assign
op_minus
l_int|1
suffix:semicolon
r_int
id|show_sys_files
op_assign
op_minus
l_int|1
comma
id|case_sensitive
op_assign
op_minus
l_int|1
suffix:semicolon
r_struct
id|nls_table
op_star
id|nls_map
op_assign
l_int|NULL
comma
op_star
id|old_nls
suffix:semicolon
multiline_comment|/* I am lazy... (-8 */
DECL|macro|NTFS_GETOPT_WITH_DEFAULT
mdefine_line|#define NTFS_GETOPT_WITH_DEFAULT(option, variable, default_value)&t;&bslash;&n;&t;if (!strcmp(p, option)) {&t;&t;&t;&t;&t;&bslash;&n;&t;&t;if (!v || !*v)&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;variable = default_value;&t;&t;&t;&bslash;&n;&t;&t;else {&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;variable = simple_strtoul(ov = v, &amp;v, 0);&t;&bslash;&n;&t;&t;&t;if (*v)&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;goto needs_val;&t;&t;&t;&t;&bslash;&n;&t;&t;}&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;}
DECL|macro|NTFS_GETOPT
mdefine_line|#define NTFS_GETOPT(option, variable)&t;&t;&t;&t;&t;&bslash;&n;&t;if (!strcmp(p, option)) {&t;&t;&t;&t;&t;&bslash;&n;&t;&t;if (!v || !*v)&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;goto needs_arg;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;variable = simple_strtoul(ov = v, &amp;v, 0);&t;&t;&bslash;&n;&t;&t;if (*v)&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;goto needs_val;&t;&t;&t;&t;&t;&bslash;&n;&t;}
DECL|macro|NTFS_GETOPT_BOOL
mdefine_line|#define NTFS_GETOPT_BOOL(option, variable)&t;&t;&t;&t;&bslash;&n;&t;if (!strcmp(p, option)) {&t;&t;&t;&t;&t;&bslash;&n;&t;&t;BOOL val;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;if (!simple_getbool(v, &amp;val))&t;&t;&t;&t;&bslash;&n;&t;&t;&t;goto needs_bool;&t;&t;&t;&t;&bslash;&n;&t;&t;variable = val;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;}
DECL|macro|NTFS_GETOPT_OPTIONS_ARRAY
mdefine_line|#define NTFS_GETOPT_OPTIONS_ARRAY(option, variable, opt_array)&t;&t;&bslash;&n;&t;if (!strcmp(p, option)) {&t;&t;&t;&t;&t;&bslash;&n;&t;&t;int _i;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;if (!v || !*v)&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;goto needs_arg;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;ov = v;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;if (variable == -1)&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;variable = 0;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;for (_i = 0; opt_array[_i].str &amp;&amp; *opt_array[_i].str; _i++) &bslash;&n;&t;&t;&t;if (!strcmp(opt_array[_i].str, v)) {&t;&t;&bslash;&n;&t;&t;&t;&t;variable |= opt_array[_i].val;&t;&t;&bslash;&n;&t;&t;&t;&t;break;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;}&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;if (!opt_array[_i].str || !*opt_array[_i].str)&t;&t;&bslash;&n;&t;&t;&t;goto needs_val;&t;&t;&t;&t;&t;&bslash;&n;&t;}
r_if
c_cond
(paren
op_logical_neg
id|opt
op_logical_or
op_logical_neg
op_star
id|opt
)paren
r_goto
id|no_mount_options
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Entering with mount options string: %s&quot;
comma
id|opt
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|p
op_assign
id|strsep
c_func
(paren
op_amp
id|opt
comma
l_string|&quot;,&quot;
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|v
op_assign
id|strchr
c_func
(paren
id|p
comma
l_char|&squot;=&squot;
)paren
)paren
)paren
op_star
id|v
op_increment
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|NTFS_GETOPT
c_func
(paren
l_string|&quot;uid&quot;
comma
id|uid
)paren
r_else
id|NTFS_GETOPT
c_func
(paren
l_string|&quot;gid&quot;
comma
id|gid
)paren
r_else
id|NTFS_GETOPT
c_func
(paren
l_string|&quot;umask&quot;
comma
id|fmask
op_assign
id|dmask
)paren
r_else
id|NTFS_GETOPT
c_func
(paren
l_string|&quot;fmask&quot;
comma
id|fmask
)paren
r_else
id|NTFS_GETOPT
c_func
(paren
l_string|&quot;dmask&quot;
comma
id|dmask
)paren
r_else
id|NTFS_GETOPT
c_func
(paren
l_string|&quot;mft_zone_multiplier&quot;
comma
id|mft_zone_multiplier
)paren
r_else
id|NTFS_GETOPT_WITH_DEFAULT
c_func
(paren
l_string|&quot;sloppy&quot;
comma
id|sloppy
comma
id|TRUE
)paren
r_else
id|NTFS_GETOPT_BOOL
c_func
(paren
l_string|&quot;show_sys_files&quot;
comma
id|show_sys_files
)paren
r_else
id|NTFS_GETOPT_BOOL
c_func
(paren
l_string|&quot;case_sensitive&quot;
comma
id|case_sensitive
)paren
r_else
id|NTFS_GETOPT_OPTIONS_ARRAY
c_func
(paren
l_string|&quot;errors&quot;
comma
id|on_errors
comma
id|on_errors_arr
)paren
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|p
comma
l_string|&quot;posix&quot;
)paren
op_logical_or
op_logical_neg
id|strcmp
c_func
(paren
id|p
comma
l_string|&quot;show_inodes&quot;
)paren
)paren
id|ntfs_warning
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Ignoring obsolete option %s.&quot;
comma
id|p
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|p
comma
l_string|&quot;nls&quot;
)paren
op_logical_or
op_logical_neg
id|strcmp
c_func
(paren
id|p
comma
l_string|&quot;iocharset&quot;
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|p
comma
l_string|&quot;iocharset&quot;
)paren
)paren
id|ntfs_warning
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Option iocharset is &quot;
l_string|&quot;deprecated. Please use &quot;
l_string|&quot;option nls=&lt;charsetname&gt; in &quot;
l_string|&quot;the future.&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|v
op_logical_or
op_logical_neg
op_star
id|v
)paren
r_goto
id|needs_arg
suffix:semicolon
id|use_utf8
suffix:colon
id|old_nls
op_assign
id|nls_map
suffix:semicolon
id|nls_map
op_assign
id|load_nls
c_func
(paren
id|v
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|nls_map
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|old_nls
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;NLS character set &quot;
l_string|&quot;%s not found.&quot;
comma
id|v
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;NLS character set %s not &quot;
l_string|&quot;found. Using previous one %s.&quot;
comma
id|v
comma
id|old_nls-&gt;charset
)paren
suffix:semicolon
id|nls_map
op_assign
id|old_nls
suffix:semicolon
)brace
r_else
multiline_comment|/* nls_map */
(brace
r_if
c_cond
(paren
id|old_nls
)paren
id|unload_nls
c_func
(paren
id|old_nls
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|p
comma
l_string|&quot;utf8&quot;
)paren
)paren
(brace
id|BOOL
id|val
op_assign
id|FALSE
suffix:semicolon
id|ntfs_warning
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Option utf8 is no longer &quot;
l_string|&quot;supported, using option nls=utf8. Please &quot;
l_string|&quot;use option nls=utf8 in the future and &quot;
l_string|&quot;make sure utf8 is compiled either as a &quot;
l_string|&quot;module or into the kernel.&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|v
op_logical_or
op_logical_neg
op_star
id|v
)paren
id|val
op_assign
id|TRUE
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|simple_getbool
c_func
(paren
id|v
comma
op_amp
id|val
)paren
)paren
r_goto
id|needs_bool
suffix:semicolon
r_if
c_cond
(paren
id|val
)paren
(brace
id|v
op_assign
id|utf8
suffix:semicolon
r_goto
id|use_utf8
suffix:semicolon
)brace
)brace
r_else
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Unrecognized mount option %s.&quot;
comma
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
id|errors
OL
id|INT_MAX
)paren
id|errors
op_increment
suffix:semicolon
)brace
DECL|macro|NTFS_GETOPT_OPTIONS_ARRAY
macro_line|#undef NTFS_GETOPT_OPTIONS_ARRAY
DECL|macro|NTFS_GETOPT_BOOL
macro_line|#undef NTFS_GETOPT_BOOL
DECL|macro|NTFS_GETOPT
macro_line|#undef NTFS_GETOPT
DECL|macro|NTFS_GETOPT_WITH_DEFAULT
macro_line|#undef NTFS_GETOPT_WITH_DEFAULT
)brace
id|no_mount_options
suffix:colon
r_if
c_cond
(paren
id|errors
op_logical_and
op_logical_neg
id|sloppy
)paren
r_return
id|FALSE
suffix:semicolon
r_if
c_cond
(paren
id|sloppy
)paren
id|ntfs_warning
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Sloppy option given. Ignoring &quot;
l_string|&quot;unrecognized mount option(s) and continuing.&quot;
)paren
suffix:semicolon
multiline_comment|/* Keep this first! */
r_if
c_cond
(paren
id|on_errors
op_ne
op_minus
l_int|1
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|on_errors
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Invalid errors option argument &quot;
l_string|&quot;or bug in options parser.&quot;
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|nls_map
)paren
(brace
r_if
c_cond
(paren
id|vol-&gt;nls_map
op_logical_and
id|vol-&gt;nls_map
op_ne
id|nls_map
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Cannot change NLS character set &quot;
l_string|&quot;on remount.&quot;
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
multiline_comment|/* else (!vol-&gt;nls_map) */
id|ntfs_debug
c_func
(paren
l_string|&quot;Using NLS character set %s.&quot;
comma
id|nls_map-&gt;charset
)paren
suffix:semicolon
id|vol-&gt;nls_map
op_assign
id|nls_map
suffix:semicolon
)brace
r_else
multiline_comment|/* (!nls_map) */
(brace
r_if
c_cond
(paren
op_logical_neg
id|vol-&gt;nls_map
)paren
(brace
id|vol-&gt;nls_map
op_assign
id|load_nls_default
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vol-&gt;nls_map
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Failed to load default &quot;
l_string|&quot;NLS character set.&quot;
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Using default NLS character set (%s).&quot;
comma
id|vol-&gt;nls_map-&gt;charset
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|mft_zone_multiplier
op_ne
op_minus
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|vol-&gt;mft_zone_multiplier
op_logical_and
id|vol-&gt;mft_zone_multiplier
op_ne
id|mft_zone_multiplier
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Cannot change mft_zone_multiplier &quot;
l_string|&quot;on remount.&quot;
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mft_zone_multiplier
template_param
l_int|4
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Invalid mft_zone_multiplier. &quot;
l_string|&quot;Using default value, i.e. 1.&quot;
)paren
suffix:semicolon
id|mft_zone_multiplier
op_assign
l_int|1
suffix:semicolon
)brace
id|vol-&gt;mft_zone_multiplier
op_assign
id|mft_zone_multiplier
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|vol-&gt;mft_zone_multiplier
)paren
id|vol-&gt;mft_zone_multiplier
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|on_errors
op_ne
op_minus
l_int|1
)paren
id|vol-&gt;on_errors
op_assign
id|on_errors
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vol-&gt;on_errors
op_logical_or
id|vol-&gt;on_errors
op_eq
id|ON_ERRORS_RECOVER
)paren
id|vol-&gt;on_errors
op_or_assign
id|ON_ERRORS_CONTINUE
suffix:semicolon
r_if
c_cond
(paren
id|uid
op_ne
(paren
id|uid_t
)paren
op_minus
l_int|1
)paren
id|vol-&gt;uid
op_assign
id|uid
suffix:semicolon
r_if
c_cond
(paren
id|gid
op_ne
(paren
id|gid_t
)paren
op_minus
l_int|1
)paren
id|vol-&gt;gid
op_assign
id|gid
suffix:semicolon
r_if
c_cond
(paren
id|fmask
op_ne
(paren
id|mode_t
)paren
op_minus
l_int|1
)paren
id|vol-&gt;fmask
op_assign
id|fmask
suffix:semicolon
r_if
c_cond
(paren
id|dmask
op_ne
(paren
id|mode_t
)paren
op_minus
l_int|1
)paren
id|vol-&gt;dmask
op_assign
id|dmask
suffix:semicolon
r_if
c_cond
(paren
id|show_sys_files
op_ne
op_minus
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|show_sys_files
)paren
id|NVolSetShowSystemFiles
c_func
(paren
id|vol
)paren
suffix:semicolon
r_else
id|NVolClearShowSystemFiles
c_func
(paren
id|vol
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|case_sensitive
op_ne
op_minus
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|case_sensitive
)paren
id|NVolSetCaseSensitive
c_func
(paren
id|vol
)paren
suffix:semicolon
r_else
id|NVolClearCaseSensitive
c_func
(paren
id|vol
)paren
suffix:semicolon
)brace
r_return
id|TRUE
suffix:semicolon
id|needs_arg
suffix:colon
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;The %s option requires an argument.&quot;
comma
id|p
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
id|needs_bool
suffix:colon
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;The %s option requires a boolean argument.&quot;
comma
id|p
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
id|needs_val
suffix:colon
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Invalid %s option argument: %s&quot;
comma
id|p
comma
id|ov
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
macro_line|#ifdef NTFS_RW
multiline_comment|/**&n; * ntfs_write_volume_flags - write new flags to the volume information flags&n; * @vol:&t;ntfs volume on which to modify the flags&n; * @flags:&t;new flags value for the volume information flags&n; *&n; * Internal function.  You probably want to use ntfs_{set,clear}_volume_flags()&n; * instead (see below).&n; *&n; * Replace the volume information flags on the volume @vol with the value&n; * supplied in @flags.  Note, this overwrites the volume information flags, so&n; * make sure to combine the flags you want to modify with the old flags and use&n; * the result when calling ntfs_write_volume_flags().&n; *&n; * Return 0 on success and -errno on error.&n; */
DECL|function|ntfs_write_volume_flags
r_static
r_int
id|ntfs_write_volume_flags
c_func
(paren
id|ntfs_volume
op_star
id|vol
comma
r_const
id|VOLUME_FLAGS
id|flags
)paren
(brace
id|ntfs_inode
op_star
id|ni
op_assign
id|NTFS_I
c_func
(paren
id|vol-&gt;vol_ino
)paren
suffix:semicolon
id|MFT_RECORD
op_star
id|m
suffix:semicolon
id|VOLUME_INFORMATION
op_star
id|vi
suffix:semicolon
id|attr_search_context
op_star
id|ctx
suffix:semicolon
r_int
id|err
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Entering, old flags = 0x%x, new flags = 0x%x.&quot;
comma
id|vol-&gt;vol_flags
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vol-&gt;vol_flags
op_eq
id|flags
)paren
r_goto
id|done
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|ni
)paren
suffix:semicolon
id|m
op_assign
id|map_mft_record
c_func
(paren
id|ni
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|m
)paren
)paren
(brace
id|err
op_assign
id|PTR_ERR
c_func
(paren
id|m
)paren
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
id|ctx
op_assign
id|get_attr_search_ctx
c_func
(paren
id|ni
comma
id|m
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ctx
)paren
(brace
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|put_unm_err_out
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|lookup_attr
c_func
(paren
id|AT_VOLUME_INFORMATION
comma
l_int|NULL
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|NULL
comma
l_int|0
comma
id|ctx
)paren
)paren
(brace
id|err
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|put_unm_err_out
suffix:semicolon
)brace
id|vi
op_assign
(paren
id|VOLUME_INFORMATION
op_star
)paren
(paren
(paren
id|u8
op_star
)paren
id|ctx-&gt;attr
op_plus
id|le16_to_cpu
c_func
(paren
id|ctx-&gt;attr-&gt;data.resident.value_offset
)paren
)paren
suffix:semicolon
id|vol-&gt;vol_flags
op_assign
id|vi-&gt;flags
op_assign
id|flags
suffix:semicolon
id|flush_dcache_mft_record_page
c_func
(paren
id|ctx-&gt;ntfs_ino
)paren
suffix:semicolon
id|mark_mft_record_dirty
c_func
(paren
id|ctx-&gt;ntfs_ino
)paren
suffix:semicolon
id|put_attr_search_ctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
id|unmap_mft_record
c_func
(paren
id|ni
)paren
suffix:semicolon
id|done
suffix:colon
id|ntfs_debug
c_func
(paren
l_string|&quot;Done.&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|put_unm_err_out
suffix:colon
r_if
c_cond
(paren
id|ctx
)paren
id|put_attr_search_ctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
id|unmap_mft_record
c_func
(paren
id|ni
)paren
suffix:semicolon
id|err_out
suffix:colon
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Failed with error code %i.&quot;
comma
op_minus
id|err
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_set_volume_flags - set bits in the volume information flags&n; * @vol:&t;ntfs volume on which to modify the flags&n; * @flags:&t;flags to set on the volume&n; *&n; * Set the bits in @flags in the volume information flags on the volume @vol.&n; *&n; * Return 0 on success and -errno on error.&n; */
DECL|function|ntfs_set_volume_flags
r_static
r_inline
r_int
id|ntfs_set_volume_flags
c_func
(paren
id|ntfs_volume
op_star
id|vol
comma
id|VOLUME_FLAGS
id|flags
)paren
(brace
id|flags
op_and_assign
id|VOLUME_FLAGS_MASK
suffix:semicolon
r_return
id|ntfs_write_volume_flags
c_func
(paren
id|vol
comma
id|vol-&gt;vol_flags
op_or
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_clear_volume_flags - clear bits in the volume information flags&n; * @vol:&t;ntfs volume on which to modify the flags&n; * @flags:&t;flags to clear on the volume&n; *&n; * Clear the bits in @flags in the volume information flags on the volume @vol.&n; *&n; * Return 0 on success and -errno on error.&n; */
DECL|function|ntfs_clear_volume_flags
r_static
r_inline
r_int
id|ntfs_clear_volume_flags
c_func
(paren
id|ntfs_volume
op_star
id|vol
comma
id|VOLUME_FLAGS
id|flags
)paren
(brace
id|flags
op_and_assign
id|VOLUME_FLAGS_MASK
suffix:semicolon
r_return
id|ntfs_write_volume_flags
c_func
(paren
id|vol
comma
id|vol-&gt;vol_flags
op_amp
op_complement
id|flags
)paren
suffix:semicolon
)brace
macro_line|#endif /* NTFS_RW */
multiline_comment|/**&n; * ntfs_remount - change the mount options of a mounted ntfs filesystem&n; * @sb:&t;&t;superblock of mounted ntfs filesystem&n; * @flags:&t;remount flags&n; * @opt:&t;remount options string&n; *&n; * Change the mount options of an already mounted ntfs filesystem.&n; *&n; * NOTE:  The VFS sets the @sb-&gt;s_flags remount flags to @flags after&n; * ntfs_remount() returns successfully (i.e. returns 0).  Otherwise,&n; * @sb-&gt;s_flags are not changed.&n; */
DECL|function|ntfs_remount
r_static
r_int
id|ntfs_remount
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_int
op_star
id|flags
comma
r_char
op_star
id|opt
)paren
(brace
id|ntfs_volume
op_star
id|vol
op_assign
id|NTFS_SB
c_func
(paren
id|sb
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Entering with remount options string: %s&quot;
comma
id|opt
)paren
suffix:semicolon
macro_line|#ifndef NTFS_RW
multiline_comment|/* For read-only compiled driver, enforce all read-only flags. */
op_star
id|flags
op_or_assign
id|MS_RDONLY
op_or
id|MS_NOATIME
op_or
id|MS_NODIRATIME
suffix:semicolon
macro_line|#else /* ! NTFS_RW */
multiline_comment|/*&n;&t; * For the read-write compiled driver, if we are remounting read-write,&n;&t; * make sure there are no volume errors and that no unsupported volume&n;&t; * flags are set.  Also, empty the logfile journal as it would become&n;&t; * stale as soon as something is written to the volume.&n;&t; */
r_if
c_cond
(paren
(paren
id|sb-&gt;s_flags
op_amp
id|MS_RDONLY
)paren
op_logical_and
op_logical_neg
(paren
op_star
id|flags
op_amp
id|MS_RDONLY
)paren
)paren
(brace
r_static
r_const
r_char
op_star
id|es
op_assign
l_string|&quot;.  Cannot remount read-write.&quot;
suffix:semicolon
r_if
c_cond
(paren
id|NVolErrors
c_func
(paren
id|vol
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Volume has errors and is read-only%s&quot;
comma
id|es
)paren
suffix:semicolon
r_return
op_minus
id|EROFS
suffix:semicolon
)brace
r_if
c_cond
(paren
id|vol-&gt;vol_flags
op_amp
id|VOLUME_MUST_MOUNT_RO_MASK
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Volume has unsupported flags set and &quot;
l_string|&quot;is read-only%s&quot;
comma
id|es
)paren
suffix:semicolon
r_return
op_minus
id|EROFS
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|ntfs_empty_logfile
c_func
(paren
id|vol-&gt;logfile_ino
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Failed to empty journal $LogFile%s&quot;
comma
id|es
)paren
suffix:semicolon
id|NVolSetErrors
c_func
(paren
id|vol
)paren
suffix:semicolon
r_return
op_minus
id|EROFS
suffix:semicolon
)brace
)brace
singleline_comment|// TODO:  For now we enforce no atime and dir atime updates as they are
singleline_comment|// not implemented.
r_if
c_cond
(paren
(paren
id|sb-&gt;s_flags
op_amp
id|MS_NOATIME
)paren
op_logical_and
op_logical_neg
(paren
op_star
id|flags
op_amp
id|MS_NOATIME
)paren
)paren
id|ntfs_warning
c_func
(paren
id|sb
comma
l_string|&quot;Atime updates are not implemented yet.  &quot;
l_string|&quot;Leaving them disabled.&quot;
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|sb-&gt;s_flags
op_amp
id|MS_NODIRATIME
)paren
op_logical_and
op_logical_neg
(paren
op_star
id|flags
op_amp
id|MS_NODIRATIME
)paren
)paren
id|ntfs_warning
c_func
(paren
id|sb
comma
l_string|&quot;Directory atime updates are not implemented &quot;
l_string|&quot;yet.  Leaving them disabled.&quot;
)paren
suffix:semicolon
op_star
id|flags
op_or_assign
id|MS_NOATIME
op_or
id|MS_NODIRATIME
suffix:semicolon
macro_line|#endif /* ! NTFS_RW */
singleline_comment|// FIXME/TODO: If left like this we will have problems with rw-&gt;ro and
singleline_comment|// ro-&gt;rw, as well as with sync-&gt;async and vice versa remounts.
singleline_comment|// Note: The VFS already checks that there are no pending deletes and
singleline_comment|// no open files for writing. So we only need to worry about dirty
singleline_comment|// inode pages and dirty system files (which include dirty inodes).
singleline_comment|// Either handle by flushing the whole volume NOW or by having the
singleline_comment|// write routines work on MS_RDONLY fs and guarantee we don&squot;t mark
singleline_comment|// anything as dirty if MS_RDONLY is set. That way the dirty data
singleline_comment|// would get flushed but no new dirty data would appear. This is
singleline_comment|// probably best but we need to be careful not to mark anything dirty
singleline_comment|// or the MS_RDONLY will be leaking writes.
singleline_comment|// TODO: Deal with *flags.
r_if
c_cond
(paren
op_logical_neg
id|parse_options
c_func
(paren
id|vol
comma
id|opt
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Done.&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * is_boot_sector_ntfs - check whether a boot sector is a valid NTFS boot sector&n; * @sb:&t;&t;Super block of the device to which @b belongs.&n; * @b:&t;&t;Boot sector of device @sb to check.&n; * @silent:&t;If TRUE, all output will be silenced.&n; *&n; * is_boot_sector_ntfs() checks whether the boot sector @b is a valid NTFS boot&n; * sector. Returns TRUE if it is valid and FALSE if not.&n; *&n; * @sb is only needed for warning/error output, i.e. it can be NULL when silent&n; * is TRUE.&n; */
DECL|function|is_boot_sector_ntfs
r_static
id|BOOL
id|is_boot_sector_ntfs
c_func
(paren
r_const
r_struct
id|super_block
op_star
id|sb
comma
r_const
id|NTFS_BOOT_SECTOR
op_star
id|b
comma
r_const
id|BOOL
id|silent
)paren
(brace
multiline_comment|/*&n;&t; * Check that checksum == sum of u32 values from b to the checksum&n;&t; * field. If checksum is zero, no checking is done.&n;&t; */
r_if
c_cond
(paren
(paren
r_void
op_star
)paren
id|b
OL
(paren
r_void
op_star
)paren
op_amp
id|b-&gt;checksum
op_logical_and
id|b-&gt;checksum
)paren
(brace
id|u32
id|i
comma
op_star
id|u
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|u
op_assign
(paren
id|u32
op_star
)paren
id|b
suffix:semicolon
id|u
OL
(paren
id|u32
op_star
)paren
(paren
op_amp
id|b-&gt;checksum
)paren
suffix:semicolon
op_increment
id|u
)paren
id|i
op_add_assign
id|le32_to_cpup
c_func
(paren
id|u
)paren
suffix:semicolon
r_if
c_cond
(paren
id|le32_to_cpu
c_func
(paren
id|b-&gt;checksum
)paren
op_ne
id|i
)paren
r_goto
id|not_ntfs
suffix:semicolon
)brace
multiline_comment|/* Check OEMidentifier is &quot;NTFS    &quot; */
r_if
c_cond
(paren
id|b-&gt;oem_id
op_ne
id|magicNTFS
)paren
r_goto
id|not_ntfs
suffix:semicolon
multiline_comment|/* Check bytes per sector value is between 256 and 4096. */
r_if
c_cond
(paren
id|le16_to_cpu
c_func
(paren
id|b-&gt;bpb.bytes_per_sector
)paren
template_param
l_int|0x1000
)paren
r_goto
id|not_ntfs
suffix:semicolon
multiline_comment|/* Check sectors per cluster value is valid. */
r_switch
c_cond
(paren
id|b-&gt;bpb.sectors_per_cluster
)paren
(brace
r_case
l_int|1
suffix:colon
r_case
l_int|2
suffix:colon
r_case
l_int|4
suffix:colon
r_case
l_int|8
suffix:colon
r_case
l_int|16
suffix:colon
r_case
l_int|32
suffix:colon
r_case
l_int|64
suffix:colon
r_case
l_int|128
suffix:colon
r_break
suffix:semicolon
r_default
suffix:colon
r_goto
id|not_ntfs
suffix:semicolon
)brace
multiline_comment|/* Check the cluster size is not above 65536 bytes. */
r_if
c_cond
(paren
(paren
id|u32
)paren
id|le16_to_cpu
c_func
(paren
id|b-&gt;bpb.bytes_per_sector
)paren
op_star
id|b-&gt;bpb.sectors_per_cluster
OG
l_int|0x10000
)paren
r_goto
id|not_ntfs
suffix:semicolon
multiline_comment|/* Check reserved/unused fields are really zero. */
r_if
c_cond
(paren
id|le16_to_cpu
c_func
(paren
id|b-&gt;bpb.reserved_sectors
)paren
op_logical_or
id|le16_to_cpu
c_func
(paren
id|b-&gt;bpb.root_entries
)paren
op_logical_or
id|le16_to_cpu
c_func
(paren
id|b-&gt;bpb.sectors
)paren
op_logical_or
id|le16_to_cpu
c_func
(paren
id|b-&gt;bpb.sectors_per_fat
)paren
op_logical_or
id|le32_to_cpu
c_func
(paren
id|b-&gt;bpb.large_sectors
)paren
op_logical_or
id|b-&gt;bpb.fats
)paren
r_goto
id|not_ntfs
suffix:semicolon
multiline_comment|/* Check clusters per file mft record value is valid. */
r_if
c_cond
(paren
(paren
id|u8
)paren
id|b-&gt;clusters_per_mft_record
template_param
l_int|0xf7
)paren
r_switch
c_cond
(paren
id|b-&gt;clusters_per_mft_record
)paren
(brace
r_case
l_int|1
suffix:colon
r_case
l_int|2
suffix:colon
r_case
l_int|4
suffix:colon
r_case
l_int|8
suffix:colon
r_case
l_int|16
suffix:colon
r_case
l_int|32
suffix:colon
r_case
l_int|64
suffix:colon
r_break
suffix:semicolon
r_default
suffix:colon
r_goto
id|not_ntfs
suffix:semicolon
)brace
multiline_comment|/* Check clusters per index block value is valid. */
r_if
c_cond
(paren
(paren
id|u8
)paren
id|b-&gt;clusters_per_index_record
template_param
l_int|0xf7
)paren
r_switch
c_cond
(paren
id|b-&gt;clusters_per_index_record
)paren
(brace
r_case
l_int|1
suffix:colon
r_case
l_int|2
suffix:colon
r_case
l_int|4
suffix:colon
r_case
l_int|8
suffix:colon
r_case
l_int|16
suffix:colon
r_case
l_int|32
suffix:colon
r_case
l_int|64
suffix:colon
r_break
suffix:semicolon
r_default
suffix:colon
r_goto
id|not_ntfs
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Check for valid end of sector marker. We will work without it, but&n;&t; * many BIOSes will refuse to boot from a bootsector if the magic is&n;&t; * incorrect, so we emit a warning.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|silent
op_logical_and
id|b-&gt;end_of_sector_marker
op_ne
id|cpu_to_le16
c_func
(paren
l_int|0xaa55
)paren
)paren
id|ntfs_warning
c_func
(paren
id|sb
comma
l_string|&quot;Invalid end of sector marker.&quot;
)paren
suffix:semicolon
r_return
id|TRUE
suffix:semicolon
id|not_ntfs
suffix:colon
r_return
id|FALSE
suffix:semicolon
)brace
multiline_comment|/**&n; * read_ntfs_boot_sector - read the NTFS boot sector of a device&n; * @sb:&t;&t;super block of device to read the boot sector from&n; * @silent:&t;if true, suppress all output&n; *&n; * Reads the boot sector from the device and validates it. If that fails, tries&n; * to read the backup boot sector, first from the end of the device a-la NT4 and&n; * later and then from the middle of the device a-la NT3.51 and before.&n; *&n; * If a valid boot sector is found but it is not the primary boot sector, we&n; * repair the primary boot sector silently (unless the device is read-only or&n; * the primary boot sector is not accessible).&n; *&n; * NOTE: To call this function, @sb must have the fields s_dev, the ntfs super&n; * block (u.ntfs_sb), nr_blocks and the device flags (s_flags) initialized&n; * to their respective values.&n; *&n; * Return the unlocked buffer head containing the boot sector or NULL on error.&n; */
DECL|function|read_ntfs_boot_sector
r_static
r_struct
id|buffer_head
op_star
id|read_ntfs_boot_sector
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_const
r_int
id|silent
)paren
(brace
r_const
r_char
op_star
id|read_err_str
op_assign
l_string|&quot;Unable to read %s boot sector.&quot;
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh_primary
comma
op_star
id|bh_backup
suffix:semicolon
r_int
id|nr_blocks
op_assign
id|NTFS_SB
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|nr_blocks
suffix:semicolon
multiline_comment|/* Try to read primary boot sector. */
r_if
c_cond
(paren
(paren
id|bh_primary
op_assign
id|sb_bread
c_func
(paren
id|sb
comma
l_int|0
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|is_boot_sector_ntfs
c_func
(paren
id|sb
comma
(paren
id|NTFS_BOOT_SECTOR
op_star
)paren
id|bh_primary-&gt;b_data
comma
id|silent
)paren
)paren
r_return
id|bh_primary
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|silent
)paren
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Primary boot sector is invalid.&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|silent
)paren
id|ntfs_error
c_func
(paren
id|sb
comma
id|read_err_str
comma
l_string|&quot;primary&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|NTFS_SB
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|on_errors
op_amp
id|ON_ERRORS_RECOVER
)paren
)paren
(brace
r_if
c_cond
(paren
id|bh_primary
)paren
id|brelse
c_func
(paren
id|bh_primary
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|silent
)paren
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Mount option errors=recover not used. &quot;
l_string|&quot;Aborting without trying to recover.&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Try to read NT4+ backup boot sector. */
r_if
c_cond
(paren
(paren
id|bh_backup
op_assign
id|sb_bread
c_func
(paren
id|sb
comma
id|nr_blocks
op_minus
l_int|1
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|is_boot_sector_ntfs
c_func
(paren
id|sb
comma
(paren
id|NTFS_BOOT_SECTOR
op_star
)paren
id|bh_backup-&gt;b_data
comma
id|silent
)paren
)paren
r_goto
id|hotfix_primary_boot_sector
suffix:semicolon
id|brelse
c_func
(paren
id|bh_backup
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|silent
)paren
id|ntfs_error
c_func
(paren
id|sb
comma
id|read_err_str
comma
l_string|&quot;backup&quot;
)paren
suffix:semicolon
multiline_comment|/* Try to read NT3.51- backup boot sector. */
r_if
c_cond
(paren
(paren
id|bh_backup
op_assign
id|sb_bread
c_func
(paren
id|sb
comma
id|nr_blocks
op_rshift
l_int|1
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|is_boot_sector_ntfs
c_func
(paren
id|sb
comma
(paren
id|NTFS_BOOT_SECTOR
op_star
)paren
id|bh_backup-&gt;b_data
comma
id|silent
)paren
)paren
r_goto
id|hotfix_primary_boot_sector
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|silent
)paren
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Could not find a valid backup boot &quot;
l_string|&quot;sector.&quot;
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|bh_backup
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|silent
)paren
id|ntfs_error
c_func
(paren
id|sb
comma
id|read_err_str
comma
l_string|&quot;backup&quot;
)paren
suffix:semicolon
multiline_comment|/* We failed. Cleanup and return. */
r_if
c_cond
(paren
id|bh_primary
)paren
id|brelse
c_func
(paren
id|bh_primary
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
id|hotfix_primary_boot_sector
suffix:colon
r_if
c_cond
(paren
id|bh_primary
)paren
(brace
multiline_comment|/*&n;&t;&t; * If we managed to read sector zero and the volume is not&n;&t;&t; * read-only, copy the found, valid backup boot sector to the&n;&t;&t; * primary boot sector.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|sb-&gt;s_flags
op_amp
id|MS_RDONLY
)paren
)paren
(brace
id|ntfs_warning
c_func
(paren
id|sb
comma
l_string|&quot;Hot-fix: Recovering invalid primary &quot;
l_string|&quot;boot sector from backup copy.&quot;
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|bh_primary-&gt;b_data
comma
id|bh_backup-&gt;b_data
comma
id|sb-&gt;s_blocksize
)paren
suffix:semicolon
id|mark_buffer_dirty
c_func
(paren
id|bh_primary
)paren
suffix:semicolon
id|sync_dirty_buffer
c_func
(paren
id|bh_primary
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buffer_uptodate
c_func
(paren
id|bh_primary
)paren
)paren
(brace
id|brelse
c_func
(paren
id|bh_backup
)paren
suffix:semicolon
r_return
id|bh_primary
suffix:semicolon
)brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Hot-fix: Device write error while &quot;
l_string|&quot;recovering primary boot sector.&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|ntfs_warning
c_func
(paren
id|sb
comma
l_string|&quot;Hot-fix: Recovery of primary boot &quot;
l_string|&quot;sector failed: Read-only mount.&quot;
)paren
suffix:semicolon
)brace
id|brelse
c_func
(paren
id|bh_primary
)paren
suffix:semicolon
)brace
id|ntfs_warning
c_func
(paren
id|sb
comma
l_string|&quot;Using backup boot sector.&quot;
)paren
suffix:semicolon
r_return
id|bh_backup
suffix:semicolon
)brace
multiline_comment|/**&n; * parse_ntfs_boot_sector - parse the boot sector and store the data in @vol&n; * @vol:&t;volume structure to initialise with data from boot sector&n; * @b:&t;&t;boot sector to parse&n; *&n; * Parse the ntfs boot sector @b and store all imporant information therein in&n; * the ntfs super block @vol. Return TRUE on success and FALSE on error.&n; */
DECL|function|parse_ntfs_boot_sector
r_static
id|BOOL
id|parse_ntfs_boot_sector
c_func
(paren
id|ntfs_volume
op_star
id|vol
comma
r_const
id|NTFS_BOOT_SECTOR
op_star
id|b
)paren
(brace
r_int
r_int
id|sectors_per_cluster_bits
comma
id|nr_hidden_sects
suffix:semicolon
r_int
id|clusters_per_mft_record
comma
id|clusters_per_index_record
suffix:semicolon
id|s64
id|ll
suffix:semicolon
id|vol-&gt;sector_size
op_assign
id|le16_to_cpu
c_func
(paren
id|b-&gt;bpb.bytes_per_sector
)paren
suffix:semicolon
id|vol-&gt;sector_size_bits
op_assign
id|ffs
c_func
(paren
id|vol-&gt;sector_size
)paren
op_minus
l_int|1
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;vol-&gt;sector_size = %i (0x%x)&quot;
comma
id|vol-&gt;sector_size
comma
id|vol-&gt;sector_size
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;vol-&gt;sector_size_bits = %i (0x%x)&quot;
comma
id|vol-&gt;sector_size_bits
comma
id|vol-&gt;sector_size_bits
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vol-&gt;sector_size
op_ne
id|vol-&gt;sb-&gt;s_blocksize
)paren
id|ntfs_warning
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;The boot sector indicates a sector size &quot;
l_string|&quot;different from the device sector size.&quot;
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;sectors_per_cluster = 0x%x&quot;
comma
id|b-&gt;bpb.sectors_per_cluster
)paren
suffix:semicolon
id|sectors_per_cluster_bits
op_assign
id|ffs
c_func
(paren
id|b-&gt;bpb.sectors_per_cluster
)paren
op_minus
l_int|1
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;sectors_per_cluster_bits = 0x%x&quot;
comma
id|sectors_per_cluster_bits
)paren
suffix:semicolon
id|nr_hidden_sects
op_assign
id|le32_to_cpu
c_func
(paren
id|b-&gt;bpb.hidden_sectors
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;number of hidden sectors = 0x%x&quot;
comma
id|nr_hidden_sects
)paren
suffix:semicolon
id|vol-&gt;cluster_size
op_assign
id|vol-&gt;sector_size
op_lshift
id|sectors_per_cluster_bits
suffix:semicolon
id|vol-&gt;cluster_size_mask
op_assign
id|vol-&gt;cluster_size
op_minus
l_int|1
suffix:semicolon
id|vol-&gt;cluster_size_bits
op_assign
id|ffs
c_func
(paren
id|vol-&gt;cluster_size
)paren
op_minus
l_int|1
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;vol-&gt;cluster_size = %i (0x%x)&quot;
comma
id|vol-&gt;cluster_size
comma
id|vol-&gt;cluster_size
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;vol-&gt;cluster_size_mask = 0x%x&quot;
comma
id|vol-&gt;cluster_size_mask
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;vol-&gt;cluster_size_bits = %i (0x%x)&quot;
comma
id|vol-&gt;cluster_size_bits
comma
id|vol-&gt;cluster_size_bits
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vol-&gt;sector_size
OG
id|vol-&gt;cluster_size
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Sector sizes above the cluster size are &quot;
l_string|&quot;not supported. Sorry.&quot;
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|vol-&gt;sb-&gt;s_blocksize
OG
id|vol-&gt;cluster_size
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Cluster sizes smaller than the device &quot;
l_string|&quot;sector size are not supported. Sorry.&quot;
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
id|clusters_per_mft_record
op_assign
id|b-&gt;clusters_per_mft_record
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;clusters_per_mft_record = %i (0x%x)&quot;
comma
id|clusters_per_mft_record
comma
id|clusters_per_mft_record
)paren
suffix:semicolon
r_if
c_cond
(paren
id|clusters_per_mft_record
OG
l_int|0
)paren
id|vol-&gt;mft_record_size
op_assign
id|vol-&gt;cluster_size
op_lshift
(paren
id|ffs
c_func
(paren
id|clusters_per_mft_record
)paren
op_minus
l_int|1
)paren
suffix:semicolon
r_else
multiline_comment|/*&n;&t;&t; * When mft_record_size &lt; cluster_size, clusters_per_mft_record&n;&t;&t; * = -log2(mft_record_size) bytes. mft_record_size normaly is&n;&t;&t; * 1024 bytes, which is encoded as 0xF6 (-10 in decimal).&n;&t;&t; */
id|vol-&gt;mft_record_size
op_assign
l_int|1
op_lshift
op_minus
id|clusters_per_mft_record
suffix:semicolon
id|vol-&gt;mft_record_size_mask
op_assign
id|vol-&gt;mft_record_size
op_minus
l_int|1
suffix:semicolon
id|vol-&gt;mft_record_size_bits
op_assign
id|ffs
c_func
(paren
id|vol-&gt;mft_record_size
)paren
op_minus
l_int|1
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;vol-&gt;mft_record_size = %i (0x%x)&quot;
comma
id|vol-&gt;mft_record_size
comma
id|vol-&gt;mft_record_size
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;vol-&gt;mft_record_size_mask = 0x%x&quot;
comma
id|vol-&gt;mft_record_size_mask
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;vol-&gt;mft_record_size_bits = %i (0x%x)&quot;
comma
id|vol-&gt;mft_record_size_bits
comma
id|vol-&gt;mft_record_size_bits
)paren
suffix:semicolon
id|clusters_per_index_record
op_assign
id|b-&gt;clusters_per_index_record
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;clusters_per_index_record = %i (0x%x)&quot;
comma
id|clusters_per_index_record
comma
id|clusters_per_index_record
)paren
suffix:semicolon
r_if
c_cond
(paren
id|clusters_per_index_record
OG
l_int|0
)paren
id|vol-&gt;index_record_size
op_assign
id|vol-&gt;cluster_size
op_lshift
(paren
id|ffs
c_func
(paren
id|clusters_per_index_record
)paren
op_minus
l_int|1
)paren
suffix:semicolon
r_else
multiline_comment|/*&n;&t;&t; * When index_record_size &lt; cluster_size,&n;&t;&t; * clusters_per_index_record = -log2(index_record_size) bytes.&n;&t;&t; * index_record_size normaly equals 4096 bytes, which is&n;&t;&t; * encoded as 0xF4 (-12 in decimal).&n;&t;&t; */
id|vol-&gt;index_record_size
op_assign
l_int|1
op_lshift
op_minus
id|clusters_per_index_record
suffix:semicolon
id|vol-&gt;index_record_size_mask
op_assign
id|vol-&gt;index_record_size
op_minus
l_int|1
suffix:semicolon
id|vol-&gt;index_record_size_bits
op_assign
id|ffs
c_func
(paren
id|vol-&gt;index_record_size
)paren
op_minus
l_int|1
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;vol-&gt;index_record_size = %i (0x%x)&quot;
comma
id|vol-&gt;index_record_size
comma
id|vol-&gt;index_record_size
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;vol-&gt;index_record_size_mask = 0x%x&quot;
comma
id|vol-&gt;index_record_size_mask
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;vol-&gt;index_record_size_bits = %i (0x%x)&quot;
comma
id|vol-&gt;index_record_size_bits
comma
id|vol-&gt;index_record_size_bits
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Get the size of the volume in clusters and check for 64-bit-ness.&n;&t; * Windows currently only uses 32 bits to save the clusters so we do&n;&t; * the same as it is much faster on 32-bit CPUs.&n;&t; */
id|ll
op_assign
id|sle64_to_cpu
c_func
(paren
id|b-&gt;number_of_sectors
)paren
op_rshift
id|sectors_per_cluster_bits
suffix:semicolon
r_if
c_cond
(paren
(paren
id|u64
)paren
id|ll
op_ge
l_int|1ULL
op_lshift
l_int|32
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Cannot handle 64-bit clusters. Sorry.&quot;
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
id|vol-&gt;nr_clusters
op_assign
id|ll
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;vol-&gt;nr_clusters = 0x%llx&quot;
comma
(paren
r_int
r_int
)paren
id|vol-&gt;nr_clusters
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * On an architecture where unsigned long is 32-bits, we restrict the&n;&t; * volume size to 2TiB (2^41). On a 64-bit architecture, the compiler&n;&t; * will hopefully optimize the whole check away.&n;&t; */
r_if
c_cond
(paren
r_sizeof
(paren
r_int
r_int
)paren
OL
l_int|8
)paren
(brace
r_if
c_cond
(paren
(paren
id|ll
op_lshift
id|vol-&gt;cluster_size_bits
)paren
op_ge
(paren
l_int|1ULL
op_lshift
l_int|41
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Volume size (%lluTiB) is too &quot;
l_string|&quot;large for this architecture. Maximum &quot;
l_string|&quot;supported is 2TiB. Sorry.&quot;
comma
(paren
r_int
r_int
r_int
)paren
id|ll
op_rshift
(paren
l_int|40
op_minus
id|vol-&gt;cluster_size_bits
)paren
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
)brace
id|ll
op_assign
id|sle64_to_cpu
c_func
(paren
id|b-&gt;mft_lcn
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ll
op_ge
id|vol-&gt;nr_clusters
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;MFT LCN is beyond end of volume. Weird.&quot;
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
id|vol-&gt;mft_lcn
op_assign
id|ll
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;vol-&gt;mft_lcn = 0x%llx&quot;
comma
(paren
r_int
r_int
)paren
id|vol-&gt;mft_lcn
)paren
suffix:semicolon
id|ll
op_assign
id|sle64_to_cpu
c_func
(paren
id|b-&gt;mftmirr_lcn
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ll
op_ge
id|vol-&gt;nr_clusters
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;MFTMirr LCN is beyond end of volume. &quot;
l_string|&quot;Weird.&quot;
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
id|vol-&gt;mftmirr_lcn
op_assign
id|ll
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;vol-&gt;mftmirr_lcn = 0x%llx&quot;
comma
(paren
r_int
r_int
)paren
id|vol-&gt;mftmirr_lcn
)paren
suffix:semicolon
macro_line|#ifdef NTFS_RW
multiline_comment|/*&n;&t; * Work out the size of the mft mirror in number of mft records. If the&n;&t; * cluster size is less than or equal to the size taken by four mft&n;&t; * records, the mft mirror stores the first four mft records. If the&n;&t; * cluster size is bigger than the size taken by four mft records, the&n;&t; * mft mirror contains as many mft records as will fit into one&n;&t; * cluster.&n;&t; */
r_if
c_cond
(paren
id|vol-&gt;cluster_size
op_le
(paren
l_int|4
op_lshift
id|vol-&gt;mft_record_size_bits
)paren
)paren
id|vol-&gt;mftmirr_size
op_assign
l_int|4
suffix:semicolon
r_else
id|vol-&gt;mftmirr_size
op_assign
id|vol-&gt;cluster_size
op_rshift
id|vol-&gt;mft_record_size_bits
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;vol-&gt;mftmirr_size = %i&quot;
comma
id|vol-&gt;mftmirr_size
)paren
suffix:semicolon
macro_line|#endif /* NTFS_RW */
id|vol-&gt;serial_no
op_assign
id|le64_to_cpu
c_func
(paren
id|b-&gt;volume_serial_number
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;vol-&gt;serial_no = 0x%llx&quot;
comma
(paren
r_int
r_int
r_int
)paren
id|vol-&gt;serial_no
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Determine MFT zone size. This is not strictly the right place to do&n;&t; * this, but I am too lazy to create a function especially for it...&n;&t; */
id|vol-&gt;mft_zone_end
op_assign
id|vol-&gt;nr_clusters
suffix:semicolon
r_switch
c_cond
(paren
id|vol-&gt;mft_zone_multiplier
)paren
(brace
multiline_comment|/* % of volume size in clusters */
r_case
l_int|4
suffix:colon
id|vol-&gt;mft_zone_end
op_assign
id|vol-&gt;mft_zone_end
op_rshift
l_int|1
suffix:semicolon
multiline_comment|/* 50%   */
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
id|vol-&gt;mft_zone_end
op_assign
(paren
id|vol-&gt;mft_zone_end
op_plus
(paren
id|vol-&gt;mft_zone_end
op_rshift
l_int|1
)paren
)paren
op_rshift
l_int|2
suffix:semicolon
multiline_comment|/* 37.5% */
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|vol-&gt;mft_zone_end
op_assign
id|vol-&gt;mft_zone_end
op_rshift
l_int|2
suffix:semicolon
multiline_comment|/* 25%   */
r_break
suffix:semicolon
r_default
suffix:colon
id|vol-&gt;mft_zone_multiplier
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Fall through into case 1. */
r_case
l_int|1
suffix:colon
id|vol-&gt;mft_zone_end
op_assign
id|vol-&gt;mft_zone_end
op_rshift
l_int|3
suffix:semicolon
multiline_comment|/* 12.5% */
r_break
suffix:semicolon
)brace
id|ntfs_debug
c_func
(paren
l_string|&quot;vol-&gt;mft_zone_multiplier = 0x%x&quot;
comma
id|vol-&gt;mft_zone_multiplier
)paren
suffix:semicolon
id|vol-&gt;mft_zone_start
op_assign
id|vol-&gt;mft_lcn
suffix:semicolon
id|vol-&gt;mft_zone_end
op_add_assign
id|vol-&gt;mft_lcn
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;vol-&gt;mft_zone_start = 0x%llx&quot;
comma
(paren
r_int
r_int
)paren
id|vol-&gt;mft_zone_start
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;vol-&gt;mft_zone_end = 0x%llx&quot;
comma
(paren
r_int
r_int
)paren
id|vol-&gt;mft_zone_end
)paren
suffix:semicolon
r_return
id|TRUE
suffix:semicolon
)brace
macro_line|#ifdef NTFS_RW
multiline_comment|/**&n; * load_and_init_mft_mirror - load and setup the mft mirror inode for a volume&n; * @vol:&t;ntfs super block describing device whose mft mirror to load&n; *&n; * Return TRUE on success or FALSE on error.&n; */
DECL|function|load_and_init_mft_mirror
r_static
id|BOOL
id|load_and_init_mft_mirror
c_func
(paren
id|ntfs_volume
op_star
id|vol
)paren
(brace
r_struct
id|inode
op_star
id|tmp_ino
suffix:semicolon
id|ntfs_inode
op_star
id|tmp_ni
suffix:semicolon
multiline_comment|/* Get mft mirror inode. */
id|tmp_ino
op_assign
id|ntfs_iget
c_func
(paren
id|vol-&gt;sb
comma
id|FILE_MFTMirr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|tmp_ino
)paren
op_logical_or
id|is_bad_inode
c_func
(paren
id|tmp_ino
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|IS_ERR
c_func
(paren
id|tmp_ino
)paren
)paren
id|iput
c_func
(paren
id|tmp_ino
)paren
suffix:semicolon
multiline_comment|/* Caller will display error message. */
r_return
id|FALSE
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Re-initialize some specifics about $MFTMirr&squot;s inode as&n;&t; * ntfs_read_inode() will have set up the default ones.&n;&t; */
multiline_comment|/* Set uid and gid to root. */
id|tmp_ino-&gt;i_uid
op_assign
id|tmp_ino-&gt;i_gid
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Regular file.  No access for anyone. */
id|tmp_ino-&gt;i_mode
op_assign
id|S_IFREG
suffix:semicolon
multiline_comment|/* No VFS initiated operations allowed for $MFTMirr. */
id|tmp_ino-&gt;i_op
op_assign
op_amp
id|ntfs_empty_inode_ops
suffix:semicolon
id|tmp_ino-&gt;i_fop
op_assign
op_amp
id|ntfs_empty_file_ops
suffix:semicolon
multiline_comment|/* Put back our special address space operations. */
id|tmp_ino-&gt;i_mapping-&gt;a_ops
op_assign
op_amp
id|ntfs_mft_aops
suffix:semicolon
id|tmp_ni
op_assign
id|NTFS_I
c_func
(paren
id|tmp_ino
)paren
suffix:semicolon
multiline_comment|/* The $MFTMirr, like the $MFT is multi sector transfer protected. */
id|NInoSetMstProtected
c_func
(paren
id|tmp_ni
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Set up our little cheat allowing us to reuse the async read io&n;&t; * completion handler for directories.&n;&t; */
id|tmp_ni-&gt;itype.index.block_size
op_assign
id|vol-&gt;mft_record_size
suffix:semicolon
id|tmp_ni-&gt;itype.index.block_size_bits
op_assign
id|vol-&gt;mft_record_size_bits
suffix:semicolon
id|vol-&gt;mftmirr_ino
op_assign
id|tmp_ino
suffix:semicolon
r_return
id|TRUE
suffix:semicolon
)brace
multiline_comment|/**&n; * check_mft_mirror - compare contents of the mft mirror with the mft&n; * @vol:&t;ntfs super block describing device whose mft mirror to check&n; *&n; * Return TRUE on success or FALSE on error.&n; */
DECL|function|check_mft_mirror
r_static
id|BOOL
id|check_mft_mirror
c_func
(paren
id|ntfs_volume
op_star
id|vol
)paren
(brace
r_int
r_int
id|index
suffix:semicolon
r_struct
id|super_block
op_star
id|sb
op_assign
id|vol-&gt;sb
suffix:semicolon
id|ntfs_inode
op_star
id|mirr_ni
suffix:semicolon
r_struct
id|page
op_star
id|mft_page
comma
op_star
id|mirr_page
suffix:semicolon
id|u8
op_star
id|kmft
comma
op_star
id|kmirr
suffix:semicolon
id|run_list_element
op_star
id|rl
comma
id|rl2
(braket
l_int|2
)braket
suffix:semicolon
r_int
id|mrecs_per_page
comma
id|i
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Entering.&quot;
)paren
suffix:semicolon
multiline_comment|/* Compare contents of $MFT and $MFTMirr. */
id|mrecs_per_page
op_assign
id|PAGE_CACHE_SIZE
op_div
id|vol-&gt;mft_record_size
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|mrecs_per_page
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|vol-&gt;mftmirr_size
)paren
suffix:semicolon
id|mft_page
op_assign
id|mirr_page
op_assign
l_int|NULL
suffix:semicolon
id|kmft
op_assign
id|kmirr
op_assign
l_int|NULL
suffix:semicolon
id|index
op_assign
id|i
op_assign
l_int|0
suffix:semicolon
r_do
(brace
id|u32
id|bytes
suffix:semicolon
multiline_comment|/* Switch pages if necessary. */
r_if
c_cond
(paren
op_logical_neg
(paren
id|i
op_mod
id|mrecs_per_page
)paren
)paren
(brace
r_if
c_cond
(paren
id|index
)paren
(brace
id|ntfs_unmap_page
c_func
(paren
id|mft_page
)paren
suffix:semicolon
id|ntfs_unmap_page
c_func
(paren
id|mirr_page
)paren
suffix:semicolon
)brace
multiline_comment|/* Get the $MFT page. */
id|mft_page
op_assign
id|ntfs_map_page
c_func
(paren
id|vol-&gt;mft_ino-&gt;i_mapping
comma
id|index
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|mft_page
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Failed to read $MFT.&quot;
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
id|kmft
op_assign
id|page_address
c_func
(paren
id|mft_page
)paren
suffix:semicolon
multiline_comment|/* Get the $MFTMirr page. */
id|mirr_page
op_assign
id|ntfs_map_page
c_func
(paren
id|vol-&gt;mftmirr_ino-&gt;i_mapping
comma
id|index
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|mirr_page
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Failed to read $MFTMirr.&quot;
)paren
suffix:semicolon
r_goto
id|mft_unmap_out
suffix:semicolon
)brace
id|kmirr
op_assign
id|page_address
c_func
(paren
id|mirr_page
)paren
suffix:semicolon
op_increment
id|index
suffix:semicolon
)brace
multiline_comment|/* Make sure the record is ok. */
r_if
c_cond
(paren
id|ntfs_is_baad_recordp
c_func
(paren
id|kmft
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Incomplete multi sector transfer &quot;
l_string|&quot;detected in mft record %i.&quot;
comma
id|i
)paren
suffix:semicolon
id|mm_unmap_out
suffix:colon
id|ntfs_unmap_page
c_func
(paren
id|mirr_page
)paren
suffix:semicolon
id|mft_unmap_out
suffix:colon
id|ntfs_unmap_page
c_func
(paren
id|mft_page
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ntfs_is_baad_recordp
c_func
(paren
id|kmirr
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Incomplete multi sector transfer &quot;
l_string|&quot;detected in mft mirror record %i.&quot;
comma
id|i
)paren
suffix:semicolon
r_goto
id|mm_unmap_out
suffix:semicolon
)brace
multiline_comment|/* Get the amount of data in the current record. */
id|bytes
op_assign
id|le32_to_cpu
c_func
(paren
(paren
(paren
id|MFT_RECORD
op_star
)paren
id|kmft
)paren
op_member_access_from_pointer
id|bytes_in_use
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bytes
op_logical_or
id|bytes
OG
id|vol-&gt;mft_record_size
)paren
(brace
id|bytes
op_assign
id|le32_to_cpu
c_func
(paren
(paren
(paren
id|MFT_RECORD
op_star
)paren
id|kmirr
)paren
op_member_access_from_pointer
id|bytes_in_use
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bytes
op_logical_or
id|bytes
OG
id|vol-&gt;mft_record_size
)paren
id|bytes
op_assign
id|vol-&gt;mft_record_size
suffix:semicolon
)brace
multiline_comment|/* Compare the two records. */
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|kmft
comma
id|kmirr
comma
id|bytes
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;$MFT and $MFTMirr (record %i) do not &quot;
l_string|&quot;match.  Run ntfsfix or chkdsk.&quot;
comma
id|i
)paren
suffix:semicolon
r_goto
id|mm_unmap_out
suffix:semicolon
)brace
id|kmft
op_add_assign
id|vol-&gt;mft_record_size
suffix:semicolon
id|kmirr
op_add_assign
id|vol-&gt;mft_record_size
suffix:semicolon
)brace
r_while
c_loop
(paren
op_increment
id|i
OL
id|vol-&gt;mftmirr_size
)paren
suffix:semicolon
multiline_comment|/* Release the last pages. */
id|ntfs_unmap_page
c_func
(paren
id|mft_page
)paren
suffix:semicolon
id|ntfs_unmap_page
c_func
(paren
id|mirr_page
)paren
suffix:semicolon
multiline_comment|/* Construct the mft mirror run list by hand. */
id|rl2
(braket
l_int|0
)braket
dot
id|vcn
op_assign
l_int|0
suffix:semicolon
id|rl2
(braket
l_int|0
)braket
dot
id|lcn
op_assign
id|vol-&gt;mftmirr_lcn
suffix:semicolon
id|rl2
(braket
l_int|0
)braket
dot
id|length
op_assign
(paren
id|vol-&gt;mftmirr_size
op_star
id|vol-&gt;mft_record_size
op_plus
id|vol-&gt;cluster_size
op_minus
l_int|1
)paren
op_div
id|vol-&gt;cluster_size
suffix:semicolon
id|rl2
(braket
l_int|1
)braket
dot
id|vcn
op_assign
id|rl2
(braket
l_int|0
)braket
dot
id|length
suffix:semicolon
id|rl2
(braket
l_int|1
)braket
dot
id|lcn
op_assign
id|LCN_ENOENT
suffix:semicolon
id|rl2
(braket
l_int|1
)braket
dot
id|length
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Because we have just read all of the mft mirror, we know we have&n;&t; * mapped the full run list for it.&n;&t; */
id|mirr_ni
op_assign
id|NTFS_I
c_func
(paren
id|vol-&gt;mftmirr_ino
)paren
suffix:semicolon
id|down_read
c_func
(paren
op_amp
id|mirr_ni-&gt;run_list.lock
)paren
suffix:semicolon
id|rl
op_assign
id|mirr_ni-&gt;run_list.rl
suffix:semicolon
multiline_comment|/* Compare the two run lists.  They must be identical. */
id|i
op_assign
l_int|0
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|rl2
(braket
id|i
)braket
dot
id|vcn
op_ne
id|rl
(braket
id|i
)braket
dot
id|vcn
op_logical_or
id|rl2
(braket
id|i
)braket
dot
id|lcn
op_ne
id|rl
(braket
id|i
)braket
dot
id|lcn
op_logical_or
id|rl2
(braket
id|i
)braket
dot
id|length
op_ne
id|rl
(braket
id|i
)braket
dot
id|length
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;$MFTMirr location mismatch.  &quot;
l_string|&quot;Run chkdsk.&quot;
)paren
suffix:semicolon
id|up_read
c_func
(paren
op_amp
id|mirr_ni-&gt;run_list.lock
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|rl2
(braket
id|i
op_increment
)braket
dot
id|length
)paren
suffix:semicolon
id|up_read
c_func
(paren
op_amp
id|mirr_ni-&gt;run_list.lock
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Done.&quot;
)paren
suffix:semicolon
r_return
id|TRUE
suffix:semicolon
)brace
multiline_comment|/**&n; * load_and_check_logfile - load and check the logfile inode for a volume&n; * @vol:&t;ntfs super block describing device whose logfile to load&n; *&n; * Return TRUE on success or FALSE on error.&n; */
DECL|function|load_and_check_logfile
r_static
id|BOOL
id|load_and_check_logfile
c_func
(paren
id|ntfs_volume
op_star
id|vol
)paren
(brace
r_struct
id|inode
op_star
id|tmp_ino
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Entering.&quot;
)paren
suffix:semicolon
id|tmp_ino
op_assign
id|ntfs_iget
c_func
(paren
id|vol-&gt;sb
comma
id|FILE_LogFile
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|tmp_ino
)paren
op_logical_or
id|is_bad_inode
c_func
(paren
id|tmp_ino
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|IS_ERR
c_func
(paren
id|tmp_ino
)paren
)paren
id|iput
c_func
(paren
id|tmp_ino
)paren
suffix:semicolon
multiline_comment|/* Caller will display error message. */
r_return
id|FALSE
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|ntfs_check_logfile
c_func
(paren
id|tmp_ino
)paren
)paren
(brace
id|iput
c_func
(paren
id|tmp_ino
)paren
suffix:semicolon
multiline_comment|/* ntfs_check_logfile() will have displayed error output. */
r_return
id|FALSE
suffix:semicolon
)brace
id|vol-&gt;logfile_ino
op_assign
id|tmp_ino
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Done.&quot;
)paren
suffix:semicolon
r_return
id|TRUE
suffix:semicolon
)brace
macro_line|#endif /* NTFS_RW */
multiline_comment|/**&n; * load_and_init_upcase - load the upcase table for an ntfs volume&n; * @vol:&t;ntfs super block describing device whose upcase to load&n; *&n; * Return TRUE on success or FALSE on error.&n; */
DECL|function|load_and_init_upcase
r_static
id|BOOL
id|load_and_init_upcase
c_func
(paren
id|ntfs_volume
op_star
id|vol
)paren
(brace
r_struct
id|super_block
op_star
id|sb
op_assign
id|vol-&gt;sb
suffix:semicolon
r_struct
id|inode
op_star
id|ino
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
r_int
r_int
id|index
comma
id|max_index
suffix:semicolon
r_int
r_int
id|size
suffix:semicolon
r_int
id|i
comma
id|max
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Entering.&quot;
)paren
suffix:semicolon
multiline_comment|/* Read upcase table and setup vol-&gt;upcase and vol-&gt;upcase_len. */
id|ino
op_assign
id|ntfs_iget
c_func
(paren
id|sb
comma
id|FILE_UpCase
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|ino
)paren
op_logical_or
id|is_bad_inode
c_func
(paren
id|ino
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|IS_ERR
c_func
(paren
id|ino
)paren
)paren
id|iput
c_func
(paren
id|ino
)paren
suffix:semicolon
r_goto
id|upcase_failed
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * The upcase size must not be above 64k Unicode characters, must not&n;&t; * be zero and must be a multiple of sizeof(ntfschar).&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|ino-&gt;i_size
op_logical_or
id|ino-&gt;i_size
op_amp
(paren
r_sizeof
(paren
id|ntfschar
)paren
op_minus
l_int|1
)paren
op_logical_or
id|ino-&gt;i_size
OG
l_int|64ULL
op_star
l_int|1024
op_star
r_sizeof
(paren
id|ntfschar
)paren
)paren
r_goto
id|iput_upcase_failed
suffix:semicolon
id|vol-&gt;upcase
op_assign
(paren
id|ntfschar
op_star
)paren
id|ntfs_malloc_nofs
c_func
(paren
id|ino-&gt;i_size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vol-&gt;upcase
)paren
r_goto
id|iput_upcase_failed
suffix:semicolon
id|index
op_assign
l_int|0
suffix:semicolon
id|max_index
op_assign
id|ino-&gt;i_size
op_rshift
id|PAGE_CACHE_SHIFT
suffix:semicolon
id|size
op_assign
id|PAGE_CACHE_SIZE
suffix:semicolon
r_while
c_loop
(paren
id|index
OL
id|max_index
)paren
(brace
multiline_comment|/* Read the upcase table and copy it into the linear buffer. */
id|read_partial_upcase_page
suffix:colon
id|page
op_assign
id|ntfs_map_page
c_func
(paren
id|ino-&gt;i_mapping
comma
id|index
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|page
)paren
)paren
r_goto
id|iput_upcase_failed
suffix:semicolon
id|memcpy
c_func
(paren
(paren
r_char
op_star
)paren
id|vol-&gt;upcase
op_plus
(paren
id|index
op_increment
op_lshift
id|PAGE_CACHE_SHIFT
)paren
comma
id|page_address
c_func
(paren
id|page
)paren
comma
id|size
)paren
suffix:semicolon
id|ntfs_unmap_page
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
suffix:semicolon
r_if
c_cond
(paren
id|size
op_eq
id|PAGE_CACHE_SIZE
)paren
(brace
id|size
op_assign
id|ino-&gt;i_size
op_amp
op_complement
id|PAGE_CACHE_MASK
suffix:semicolon
r_if
c_cond
(paren
id|size
)paren
r_goto
id|read_partial_upcase_page
suffix:semicolon
)brace
id|vol-&gt;upcase_len
op_assign
id|ino-&gt;i_size
op_rshift
id|UCHAR_T_SIZE_BITS
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Read %llu bytes from $UpCase (expected %u bytes).&quot;
comma
id|ino-&gt;i_size
comma
l_int|64
op_star
l_int|1024
op_star
r_sizeof
(paren
id|ntfschar
)paren
)paren
suffix:semicolon
id|iput
c_func
(paren
id|ino
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|ntfs_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|default_upcase
)paren
(brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Using volume specified $UpCase since default is &quot;
l_string|&quot;not present.&quot;
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|ntfs_lock
)paren
suffix:semicolon
r_return
id|TRUE
suffix:semicolon
)brace
id|max
op_assign
id|default_upcase_len
suffix:semicolon
r_if
c_cond
(paren
id|max
OG
id|vol-&gt;upcase_len
)paren
id|max
op_assign
id|vol-&gt;upcase_len
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|max
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|vol-&gt;upcase
(braket
id|i
)braket
op_ne
id|default_upcase
(braket
id|i
)braket
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
id|max
)paren
(brace
id|ntfs_free
c_func
(paren
id|vol-&gt;upcase
)paren
suffix:semicolon
id|vol-&gt;upcase
op_assign
id|default_upcase
suffix:semicolon
id|vol-&gt;upcase_len
op_assign
id|max
suffix:semicolon
id|ntfs_nr_upcase_users
op_increment
suffix:semicolon
id|up
c_func
(paren
op_amp
id|ntfs_lock
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Volume specified $UpCase matches default. Using &quot;
l_string|&quot;default.&quot;
)paren
suffix:semicolon
r_return
id|TRUE
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|ntfs_lock
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Using volume specified $UpCase since it does not match &quot;
l_string|&quot;the default.&quot;
)paren
suffix:semicolon
r_return
id|TRUE
suffix:semicolon
id|iput_upcase_failed
suffix:colon
id|iput
c_func
(paren
id|ino
)paren
suffix:semicolon
id|ntfs_free
c_func
(paren
id|vol-&gt;upcase
)paren
suffix:semicolon
id|vol-&gt;upcase
op_assign
l_int|NULL
suffix:semicolon
id|upcase_failed
suffix:colon
id|down
c_func
(paren
op_amp
id|ntfs_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|default_upcase
)paren
(brace
id|vol-&gt;upcase
op_assign
id|default_upcase
suffix:semicolon
id|vol-&gt;upcase_len
op_assign
id|default_upcase_len
suffix:semicolon
id|ntfs_nr_upcase_users
op_increment
suffix:semicolon
id|up
c_func
(paren
op_amp
id|ntfs_lock
)paren
suffix:semicolon
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Failed to load $UpCase from the volume. Using &quot;
l_string|&quot;default.&quot;
)paren
suffix:semicolon
r_return
id|TRUE
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|ntfs_lock
)paren
suffix:semicolon
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Failed to initialized upcase table.&quot;
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
multiline_comment|/**&n; * load_system_files - open the system files using normal functions&n; * @vol:&t;ntfs super block describing device whose system files to load&n; *&n; * Open the system files with normal access functions and complete setting up&n; * the ntfs super block @vol.&n; *&n; * Return TRUE on success or FALSE on error.&n; */
DECL|function|load_system_files
r_static
id|BOOL
id|load_system_files
c_func
(paren
id|ntfs_volume
op_star
id|vol
)paren
(brace
r_struct
id|super_block
op_star
id|sb
op_assign
id|vol-&gt;sb
suffix:semicolon
r_struct
id|inode
op_star
id|tmp_ino
suffix:semicolon
id|MFT_RECORD
op_star
id|m
suffix:semicolon
id|VOLUME_INFORMATION
op_star
id|vi
suffix:semicolon
id|attr_search_context
op_star
id|ctx
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Entering.&quot;
)paren
suffix:semicolon
macro_line|#ifdef NTFS_RW
multiline_comment|/* Get mft mirror inode compare the contents of $MFT and $MFTMirr. */
r_if
c_cond
(paren
op_logical_neg
id|load_and_init_mft_mirror
c_func
(paren
id|vol
)paren
op_logical_or
op_logical_neg
id|check_mft_mirror
c_func
(paren
id|vol
)paren
)paren
(brace
r_static
r_const
r_char
op_star
id|es1
op_assign
l_string|&quot;Failed to load $MFTMirr&quot;
suffix:semicolon
r_static
r_const
r_char
op_star
id|es2
op_assign
l_string|&quot;$MFTMirr does not match $MFT&quot;
suffix:semicolon
r_static
r_const
r_char
op_star
id|es3
op_assign
l_string|&quot;.  Run ntfsfix and/or chkdsk.&quot;
suffix:semicolon
multiline_comment|/* If a read-write mount, convert it to a read-only mount. */
r_if
c_cond
(paren
op_logical_neg
(paren
id|sb-&gt;s_flags
op_amp
id|MS_RDONLY
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|vol-&gt;on_errors
op_amp
(paren
id|ON_ERRORS_REMOUNT_RO
op_or
id|ON_ERRORS_CONTINUE
)paren
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;%s and neither on_errors=&quot;
l_string|&quot;continue nor on_errors=&quot;
l_string|&quot;remount-ro was specified%s&quot;
comma
op_logical_neg
id|vol-&gt;mftmirr_ino
ques
c_cond
id|es1
suffix:colon
id|es2
comma
id|es3
)paren
suffix:semicolon
r_goto
id|iput_mirr_err_out
suffix:semicolon
)brace
id|sb-&gt;s_flags
op_or_assign
id|MS_RDONLY
op_or
id|MS_NOATIME
op_or
id|MS_NODIRATIME
suffix:semicolon
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;%s.  Mounting read-only%s&quot;
comma
op_logical_neg
id|vol-&gt;mftmirr_ino
ques
c_cond
id|es1
suffix:colon
id|es2
comma
id|es3
)paren
suffix:semicolon
)brace
r_else
id|ntfs_warning
c_func
(paren
id|sb
comma
l_string|&quot;%s.  Will not be able to remount &quot;
l_string|&quot;read-write%s&quot;
comma
op_logical_neg
id|vol-&gt;mftmirr_ino
ques
c_cond
id|es1
suffix:colon
id|es2
comma
id|es3
)paren
suffix:semicolon
multiline_comment|/* This will prevent a read-write remount. */
id|NVolSetErrors
c_func
(paren
id|vol
)paren
suffix:semicolon
)brace
macro_line|#endif /* NTFS_RW */
multiline_comment|/* Get mft bitmap attribute inode. */
id|vol-&gt;mftbmp_ino
op_assign
id|ntfs_attr_iget
c_func
(paren
id|vol-&gt;mft_ino
comma
id|AT_BITMAP
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|vol-&gt;mftbmp_ino
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Failed to load $MFT/$BITMAP attribute.&quot;
)paren
suffix:semicolon
r_goto
id|iput_mirr_err_out
suffix:semicolon
)brace
multiline_comment|/* Read upcase table and setup @vol-&gt;upcase and @vol-&gt;upcase_len. */
r_if
c_cond
(paren
op_logical_neg
id|load_and_init_upcase
c_func
(paren
id|vol
)paren
)paren
r_goto
id|iput_mftbmp_err_out
suffix:semicolon
multiline_comment|/*&n;&t; * Get the cluster allocation bitmap inode and verify the size, no&n;&t; * need for any locking at this stage as we are already running&n;&t; * exclusively as we are mount in progress task.&n;&t; */
id|vol-&gt;lcnbmp_ino
op_assign
id|ntfs_iget
c_func
(paren
id|sb
comma
id|FILE_Bitmap
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|vol-&gt;lcnbmp_ino
)paren
op_logical_or
id|is_bad_inode
c_func
(paren
id|vol-&gt;lcnbmp_ino
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|IS_ERR
c_func
(paren
id|vol-&gt;lcnbmp_ino
)paren
)paren
id|iput
c_func
(paren
id|vol-&gt;lcnbmp_ino
)paren
suffix:semicolon
r_goto
id|bitmap_failed
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|vol-&gt;nr_clusters
op_plus
l_int|7
)paren
op_rshift
l_int|3
OG
id|vol-&gt;lcnbmp_ino-&gt;i_size
)paren
(brace
id|iput
c_func
(paren
id|vol-&gt;lcnbmp_ino
)paren
suffix:semicolon
id|bitmap_failed
suffix:colon
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Failed to load $Bitmap.&quot;
)paren
suffix:semicolon
r_goto
id|iput_mirr_err_out
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Get the volume inode and setup our cache of the volume flags and&n;&t; * version.&n;&t; */
id|vol-&gt;vol_ino
op_assign
id|ntfs_iget
c_func
(paren
id|sb
comma
id|FILE_Volume
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|vol-&gt;vol_ino
)paren
op_logical_or
id|is_bad_inode
c_func
(paren
id|vol-&gt;vol_ino
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|IS_ERR
c_func
(paren
id|vol-&gt;vol_ino
)paren
)paren
id|iput
c_func
(paren
id|vol-&gt;vol_ino
)paren
suffix:semicolon
id|volume_failed
suffix:colon
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Failed to load $Volume.&quot;
)paren
suffix:semicolon
r_goto
id|iput_lcnbmp_err_out
suffix:semicolon
)brace
id|m
op_assign
id|map_mft_record
c_func
(paren
id|NTFS_I
c_func
(paren
id|vol-&gt;vol_ino
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|m
)paren
)paren
(brace
id|iput_volume_failed
suffix:colon
id|iput
c_func
(paren
id|vol-&gt;vol_ino
)paren
suffix:semicolon
r_goto
id|volume_failed
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|ctx
op_assign
id|get_attr_search_ctx
c_func
(paren
id|NTFS_I
c_func
(paren
id|vol-&gt;vol_ino
)paren
comma
id|m
)paren
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Failed to get attribute search context.&quot;
)paren
suffix:semicolon
r_goto
id|get_ctx_vol_failed
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|lookup_attr
c_func
(paren
id|AT_VOLUME_INFORMATION
comma
l_int|NULL
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|NULL
comma
l_int|0
comma
id|ctx
)paren
op_logical_or
id|ctx-&gt;attr-&gt;non_resident
op_logical_or
id|ctx-&gt;attr-&gt;flags
)paren
(brace
id|err_put_vol
suffix:colon
id|put_attr_search_ctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
id|get_ctx_vol_failed
suffix:colon
id|unmap_mft_record
c_func
(paren
id|NTFS_I
c_func
(paren
id|vol-&gt;vol_ino
)paren
)paren
suffix:semicolon
r_goto
id|iput_volume_failed
suffix:semicolon
)brace
id|vi
op_assign
(paren
id|VOLUME_INFORMATION
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|ctx-&gt;attr
op_plus
id|le16_to_cpu
c_func
(paren
id|ctx-&gt;attr-&gt;data.resident.value_offset
)paren
)paren
suffix:semicolon
multiline_comment|/* Some bounds checks. */
r_if
c_cond
(paren
(paren
id|u8
op_star
)paren
id|vi
template_param
(paren
id|u8
op_star
)paren
id|ctx-&gt;attr
op_plus
id|le32_to_cpu
c_func
(paren
id|ctx-&gt;attr-&gt;length
)paren
)paren
r_goto
id|err_put_vol
suffix:semicolon
multiline_comment|/* Setup volume flags and version. */
id|vol-&gt;vol_flags
op_assign
id|vi-&gt;flags
suffix:semicolon
id|vol-&gt;major_ver
op_assign
id|vi-&gt;major_ver
suffix:semicolon
id|vol-&gt;minor_ver
op_assign
id|vi-&gt;minor_ver
suffix:semicolon
id|put_attr_search_ctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
id|unmap_mft_record
c_func
(paren
id|NTFS_I
c_func
(paren
id|vol-&gt;vol_ino
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;NTFS volume version %i.%i.&bslash;n&quot;
comma
id|vol-&gt;major_ver
comma
id|vol-&gt;minor_ver
)paren
suffix:semicolon
macro_line|#ifdef NTFS_RW
multiline_comment|/* Make sure that no unsupported volume flags are set. */
r_if
c_cond
(paren
id|vol-&gt;vol_flags
op_amp
id|VOLUME_MUST_MOUNT_RO_MASK
)paren
(brace
r_static
r_const
r_char
op_star
id|es1
op_assign
l_string|&quot;Volume has unsupported flags set&quot;
suffix:semicolon
r_static
r_const
r_char
op_star
id|es2
op_assign
l_string|&quot;.  Run chkdsk and mount in Windows.&quot;
suffix:semicolon
multiline_comment|/* If a read-write mount, convert it to a read-only mount. */
r_if
c_cond
(paren
op_logical_neg
(paren
id|sb-&gt;s_flags
op_amp
id|MS_RDONLY
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|vol-&gt;on_errors
op_amp
(paren
id|ON_ERRORS_REMOUNT_RO
op_or
id|ON_ERRORS_CONTINUE
)paren
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;%s and neither on_errors=&quot;
l_string|&quot;continue nor on_errors=&quot;
l_string|&quot;remount-ro was specified%s&quot;
comma
id|es1
comma
id|es2
)paren
suffix:semicolon
r_goto
id|iput_vol_err_out
suffix:semicolon
)brace
id|sb-&gt;s_flags
op_or_assign
id|MS_RDONLY
op_or
id|MS_NOATIME
op_or
id|MS_NODIRATIME
suffix:semicolon
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;%s.  Mounting read-only%s&quot;
comma
id|es1
comma
id|es2
)paren
suffix:semicolon
)brace
r_else
id|ntfs_warning
c_func
(paren
id|sb
comma
l_string|&quot;%s.  Will not be able to remount &quot;
l_string|&quot;read-write%s&quot;
comma
id|es1
comma
id|es2
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Do not set NVolErrors() because ntfs_remount() re-checks the&n;&t;&t; * flags which we need to do in case any flags have changed.&n;&t;&t; */
)brace
multiline_comment|/*&n;&t; * Get the inode for the logfile, check it and determine if the volume&n;&t; * was shutdown cleanly.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|load_and_check_logfile
c_func
(paren
id|vol
)paren
op_logical_or
op_logical_neg
id|ntfs_is_logfile_clean
c_func
(paren
id|vol-&gt;logfile_ino
)paren
)paren
(brace
r_static
r_const
r_char
op_star
id|es1
op_assign
l_string|&quot;Failed to load $LogFile&quot;
suffix:semicolon
r_static
r_const
r_char
op_star
id|es2
op_assign
l_string|&quot;$LogFile is not clean&quot;
suffix:semicolon
r_static
r_const
r_char
op_star
id|es3
op_assign
l_string|&quot;.  Mount in Windows.&quot;
suffix:semicolon
multiline_comment|/* If a read-write mount, convert it to a read-only mount. */
r_if
c_cond
(paren
op_logical_neg
(paren
id|sb-&gt;s_flags
op_amp
id|MS_RDONLY
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|vol-&gt;on_errors
op_amp
(paren
id|ON_ERRORS_REMOUNT_RO
op_or
id|ON_ERRORS_CONTINUE
)paren
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;%s and neither on_errors=&quot;
l_string|&quot;continue nor on_errors=&quot;
l_string|&quot;remount-ro was specified%s&quot;
comma
op_logical_neg
id|vol-&gt;logfile_ino
ques
c_cond
id|es1
suffix:colon
id|es2
comma
id|es3
)paren
suffix:semicolon
r_goto
id|iput_logfile_err_out
suffix:semicolon
)brace
id|sb-&gt;s_flags
op_or_assign
id|MS_RDONLY
op_or
id|MS_NOATIME
op_or
id|MS_NODIRATIME
suffix:semicolon
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;%s.  Mounting read-only%s&quot;
comma
op_logical_neg
id|vol-&gt;logfile_ino
ques
c_cond
id|es1
suffix:colon
id|es2
comma
id|es3
)paren
suffix:semicolon
)brace
r_else
id|ntfs_warning
c_func
(paren
id|sb
comma
l_string|&quot;%s.  Will not be able to remount &quot;
l_string|&quot;read-write%s&quot;
comma
op_logical_neg
id|vol-&gt;logfile_ino
ques
c_cond
id|es1
suffix:colon
id|es2
comma
id|es3
)paren
suffix:semicolon
multiline_comment|/* This will prevent a read-write remount. */
id|NVolSetErrors
c_func
(paren
id|vol
)paren
suffix:semicolon
multiline_comment|/* If a read-write mount, empty the logfile. */
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
(paren
id|sb-&gt;s_flags
op_amp
id|MS_RDONLY
)paren
op_logical_and
op_logical_neg
id|ntfs_empty_logfile
c_func
(paren
id|vol-&gt;logfile_ino
)paren
)paren
(brace
r_static
r_const
r_char
op_star
id|es1
op_assign
l_string|&quot;Failed to empty $LogFile&quot;
suffix:semicolon
r_static
r_const
r_char
op_star
id|es2
op_assign
l_string|&quot;.  Mount in Windows.&quot;
suffix:semicolon
multiline_comment|/* Convert to a read-only mount. */
r_if
c_cond
(paren
op_logical_neg
(paren
id|vol-&gt;on_errors
op_amp
(paren
id|ON_ERRORS_REMOUNT_RO
op_or
id|ON_ERRORS_CONTINUE
)paren
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;%s and neither on_errors=continue nor &quot;
l_string|&quot;on_errors=remount-ro was specified%s&quot;
comma
id|es1
comma
id|es2
)paren
suffix:semicolon
r_goto
id|iput_logfile_err_out
suffix:semicolon
)brace
id|sb-&gt;s_flags
op_or_assign
id|MS_RDONLY
op_or
id|MS_NOATIME
op_or
id|MS_NODIRATIME
suffix:semicolon
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;%s.  Mounting read-only%s&quot;
comma
id|es1
comma
id|es2
)paren
suffix:semicolon
multiline_comment|/* This will prevent a read-write remount. */
id|NVolSetErrors
c_func
(paren
id|vol
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n;&t; * Get the inode for the attribute definitions file and parse the&n;&t; * attribute definitions.&n;&t; */
id|tmp_ino
op_assign
id|ntfs_iget
c_func
(paren
id|sb
comma
id|FILE_AttrDef
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|tmp_ino
)paren
op_logical_or
id|is_bad_inode
c_func
(paren
id|tmp_ino
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|IS_ERR
c_func
(paren
id|tmp_ino
)paren
)paren
id|iput
c_func
(paren
id|tmp_ino
)paren
suffix:semicolon
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Failed to load $AttrDef.&quot;
)paren
suffix:semicolon
r_goto
id|iput_logfile_err_out
suffix:semicolon
)brace
singleline_comment|// FIXME: Parse the attribute definitions.
id|iput
c_func
(paren
id|tmp_ino
)paren
suffix:semicolon
multiline_comment|/* Get the root directory inode. */
id|vol-&gt;root_ino
op_assign
id|ntfs_iget
c_func
(paren
id|sb
comma
id|FILE_root
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|vol-&gt;root_ino
)paren
op_logical_or
id|is_bad_inode
c_func
(paren
id|vol-&gt;root_ino
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|IS_ERR
c_func
(paren
id|vol-&gt;root_ino
)paren
)paren
id|iput
c_func
(paren
id|vol-&gt;root_ino
)paren
suffix:semicolon
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Failed to load root directory.&quot;
)paren
suffix:semicolon
r_goto
id|iput_logfile_err_out
suffix:semicolon
)brace
multiline_comment|/* If on NTFS versions before 3.0, we are done. */
r_if
c_cond
(paren
id|vol-&gt;major_ver
OL
l_int|3
)paren
r_return
id|TRUE
suffix:semicolon
multiline_comment|/* NTFS 3.0+ specific initialization. */
multiline_comment|/* Get the security descriptors inode. */
id|vol-&gt;secure_ino
op_assign
id|ntfs_iget
c_func
(paren
id|sb
comma
id|FILE_Secure
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|vol-&gt;secure_ino
)paren
op_logical_or
id|is_bad_inode
c_func
(paren
id|vol-&gt;secure_ino
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|IS_ERR
c_func
(paren
id|vol-&gt;secure_ino
)paren
)paren
id|iput
c_func
(paren
id|vol-&gt;secure_ino
)paren
suffix:semicolon
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Failed to load $Secure.&quot;
)paren
suffix:semicolon
r_goto
id|iput_root_err_out
suffix:semicolon
)brace
singleline_comment|// FIXME: Initialize security.
multiline_comment|/* Get the extended system files&squot; directory inode. */
id|tmp_ino
op_assign
id|ntfs_iget
c_func
(paren
id|sb
comma
id|FILE_Extend
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|tmp_ino
)paren
op_logical_or
id|is_bad_inode
c_func
(paren
id|tmp_ino
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|IS_ERR
c_func
(paren
id|tmp_ino
)paren
)paren
id|iput
c_func
(paren
id|tmp_ino
)paren
suffix:semicolon
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Failed to load $Extend.&quot;
)paren
suffix:semicolon
r_goto
id|iput_sec_err_out
suffix:semicolon
)brace
singleline_comment|// FIXME: Do something. E.g. want to delete the $UsnJrnl if exists.
singleline_comment|// Note we might be doing this at the wrong level; we might want to
singleline_comment|// d_alloc_root() and then do a &quot;normal&quot; open(2) of $Extend&bslash;$UsnJrnl
singleline_comment|// rather than using ntfs_iget here, as we don&squot;t know the inode number
singleline_comment|// for the files in $Extend directory.
id|iput
c_func
(paren
id|tmp_ino
)paren
suffix:semicolon
r_return
id|TRUE
suffix:semicolon
id|iput_sec_err_out
suffix:colon
id|iput
c_func
(paren
id|vol-&gt;secure_ino
)paren
suffix:semicolon
id|iput_root_err_out
suffix:colon
id|iput
c_func
(paren
id|vol-&gt;root_ino
)paren
suffix:semicolon
id|iput_logfile_err_out
suffix:colon
macro_line|#ifdef NTFS_RW
r_if
c_cond
(paren
id|vol-&gt;logfile_ino
)paren
id|iput
c_func
(paren
id|vol-&gt;logfile_ino
)paren
suffix:semicolon
id|iput_vol_err_out
suffix:colon
macro_line|#endif /* NTFS_RW */
id|iput
c_func
(paren
id|vol-&gt;vol_ino
)paren
suffix:semicolon
id|iput_lcnbmp_err_out
suffix:colon
id|iput
c_func
(paren
id|vol-&gt;lcnbmp_ino
)paren
suffix:semicolon
id|iput_mftbmp_err_out
suffix:colon
id|iput
c_func
(paren
id|vol-&gt;mftbmp_ino
)paren
suffix:semicolon
id|iput_mirr_err_out
suffix:colon
macro_line|#ifdef NTFS_RW
r_if
c_cond
(paren
id|vol-&gt;mftmirr_ino
)paren
id|iput
c_func
(paren
id|vol-&gt;mftmirr_ino
)paren
suffix:semicolon
macro_line|#endif /* NTFS_RW */
r_return
id|FALSE
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_put_super - called by the vfs to unmount a volume&n; * @vfs_sb:&t;vfs superblock of volume to unmount&n; *&n; * ntfs_put_super() is called by the VFS (from fs/super.c::do_umount()) when&n; * the volume is being unmounted (umount system call has been invoked) and it&n; * releases all inodes and memory belonging to the NTFS specific part of the&n; * super block.&n; */
DECL|function|ntfs_put_super
r_static
r_void
id|ntfs_put_super
c_func
(paren
r_struct
id|super_block
op_star
id|vfs_sb
)paren
(brace
id|ntfs_volume
op_star
id|vol
op_assign
id|NTFS_SB
c_func
(paren
id|vfs_sb
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Entering.&quot;
)paren
suffix:semicolon
macro_line|#ifdef NTFS_RW
multiline_comment|/*&n;&t; * Commit all inodes while they are still open in case some of them&n;&t; * cause others to be dirtied.&n;&t; */
id|ntfs_commit_inode
c_func
(paren
id|vol-&gt;vol_ino
)paren
suffix:semicolon
multiline_comment|/* NTFS 3.0+ specific. */
r_if
c_cond
(paren
id|vol-&gt;major_ver
op_ge
l_int|3
)paren
(brace
r_if
c_cond
(paren
id|vol-&gt;secure_ino
)paren
id|ntfs_commit_inode
c_func
(paren
id|vol-&gt;secure_ino
)paren
suffix:semicolon
)brace
id|ntfs_commit_inode
c_func
(paren
id|vol-&gt;root_ino
)paren
suffix:semicolon
id|down_write
c_func
(paren
op_amp
id|vol-&gt;lcnbmp_lock
)paren
suffix:semicolon
id|ntfs_commit_inode
c_func
(paren
id|vol-&gt;lcnbmp_ino
)paren
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|vol-&gt;lcnbmp_lock
)paren
suffix:semicolon
id|down_write
c_func
(paren
op_amp
id|vol-&gt;mftbmp_lock
)paren
suffix:semicolon
id|ntfs_commit_inode
c_func
(paren
id|vol-&gt;mftbmp_ino
)paren
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|vol-&gt;mftbmp_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vol-&gt;logfile_ino
)paren
id|ntfs_commit_inode
c_func
(paren
id|vol-&gt;logfile_ino
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vol-&gt;mftmirr_ino
)paren
id|ntfs_commit_inode
c_func
(paren
id|vol-&gt;mftmirr_ino
)paren
suffix:semicolon
id|ntfs_commit_inode
c_func
(paren
id|vol-&gt;mft_ino
)paren
suffix:semicolon
macro_line|#endif /* NTFS_RW */
id|iput
c_func
(paren
id|vol-&gt;vol_ino
)paren
suffix:semicolon
id|vol-&gt;vol_ino
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* NTFS 3.0+ specific clean up. */
r_if
c_cond
(paren
id|vol-&gt;major_ver
op_ge
l_int|3
)paren
(brace
r_if
c_cond
(paren
id|vol-&gt;secure_ino
)paren
(brace
id|iput
c_func
(paren
id|vol-&gt;secure_ino
)paren
suffix:semicolon
id|vol-&gt;secure_ino
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
id|iput
c_func
(paren
id|vol-&gt;root_ino
)paren
suffix:semicolon
id|vol-&gt;root_ino
op_assign
l_int|NULL
suffix:semicolon
id|down_write
c_func
(paren
op_amp
id|vol-&gt;lcnbmp_lock
)paren
suffix:semicolon
id|iput
c_func
(paren
id|vol-&gt;lcnbmp_ino
)paren
suffix:semicolon
id|vol-&gt;lcnbmp_ino
op_assign
l_int|NULL
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|vol-&gt;lcnbmp_lock
)paren
suffix:semicolon
id|down_write
c_func
(paren
op_amp
id|vol-&gt;mftbmp_lock
)paren
suffix:semicolon
id|iput
c_func
(paren
id|vol-&gt;mftbmp_ino
)paren
suffix:semicolon
id|vol-&gt;mftbmp_ino
op_assign
l_int|NULL
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|vol-&gt;mftbmp_lock
)paren
suffix:semicolon
macro_line|#ifdef NTFS_RW
r_if
c_cond
(paren
id|vol-&gt;logfile_ino
)paren
(brace
id|iput
c_func
(paren
id|vol-&gt;logfile_ino
)paren
suffix:semicolon
id|vol-&gt;logfile_ino
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|vol-&gt;mftmirr_ino
)paren
(brace
multiline_comment|/* Re-commit the mft mirror and mft just in case. */
id|ntfs_commit_inode
c_func
(paren
id|vol-&gt;mftmirr_ino
)paren
suffix:semicolon
id|ntfs_commit_inode
c_func
(paren
id|vol-&gt;mft_ino
)paren
suffix:semicolon
id|iput
c_func
(paren
id|vol-&gt;mftmirr_ino
)paren
suffix:semicolon
id|vol-&gt;mftmirr_ino
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If any dirty inodes are left, throw away all mft data page cache&n;&t; * pages to allow a clean umount.  This should never happen any more&n;&t; * due to mft.c::ntfs_mft_writepage() cleaning all the dirty pages as&n;&t; * the underlying mft records are written out and cleaned.  If it does,&n;&t; * happen anyway, we want to know...&n;&t; */
id|ntfs_commit_inode
c_func
(paren
id|vol-&gt;mft_ino
)paren
suffix:semicolon
id|write_inode_now
c_func
(paren
id|vol-&gt;mft_ino
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|vfs_sb-&gt;s_dirty
)paren
)paren
(brace
r_char
op_star
id|s1
comma
op_star
id|s2
suffix:semicolon
id|down
c_func
(paren
op_amp
id|vol-&gt;mft_ino-&gt;i_sem
)paren
suffix:semicolon
id|truncate_inode_pages
c_func
(paren
id|vol-&gt;mft_ino-&gt;i_mapping
comma
l_int|0
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|vol-&gt;mft_ino-&gt;i_sem
)paren
suffix:semicolon
id|write_inode_now
c_func
(paren
id|vol-&gt;mft_ino
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|vfs_sb-&gt;s_dirty
)paren
)paren
(brace
r_static
r_char
op_star
id|_s1
op_assign
l_string|&quot;inodes&quot;
suffix:semicolon
r_static
r_char
op_star
id|_s2
op_assign
l_string|&quot;&quot;
suffix:semicolon
id|s1
op_assign
id|_s1
suffix:semicolon
id|s2
op_assign
id|_s2
suffix:semicolon
)brace
r_else
(brace
r_static
r_char
op_star
id|_s1
op_assign
l_string|&quot;mft pages&quot;
suffix:semicolon
r_static
r_char
op_star
id|_s2
op_assign
l_string|&quot;They have been thrown away.  &quot;
suffix:semicolon
id|s1
op_assign
id|_s1
suffix:semicolon
id|s2
op_assign
id|_s2
suffix:semicolon
)brace
id|ntfs_error
c_func
(paren
id|vfs_sb
comma
l_string|&quot;Dirty %s found at umount time.  %s&quot;
l_string|&quot;You should run chkdsk.  Please email &quot;
l_string|&quot;linux-ntfs-dev@lists.sourceforge.net and say &quot;
l_string|&quot;that you saw this message.  Thank you.&quot;
comma
id|s1
comma
id|s2
)paren
suffix:semicolon
)brace
macro_line|#endif /* NTFS_RW */
id|iput
c_func
(paren
id|vol-&gt;mft_ino
)paren
suffix:semicolon
id|vol-&gt;mft_ino
op_assign
l_int|NULL
suffix:semicolon
id|vol-&gt;upcase_len
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Decrease the number of mounts and destroy the global default upcase&n;&t; * table if necessary. Also decrease the number of upcase users if we&n;&t; * are a user.&n;&t; */
id|down
c_func
(paren
op_amp
id|ntfs_lock
)paren
suffix:semicolon
id|ntfs_nr_mounts
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|vol-&gt;upcase
op_eq
id|default_upcase
)paren
(brace
id|ntfs_nr_upcase_users
op_decrement
suffix:semicolon
id|vol-&gt;upcase
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|ntfs_nr_upcase_users
op_logical_and
id|default_upcase
)paren
(brace
id|ntfs_free
c_func
(paren
id|default_upcase
)paren
suffix:semicolon
id|default_upcase
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|vol-&gt;cluster_size
op_le
l_int|4096
op_logical_and
op_logical_neg
op_decrement
id|ntfs_nr_compression_users
)paren
id|free_compression_buffers
c_func
(paren
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|ntfs_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vol-&gt;upcase
)paren
(brace
id|ntfs_free
c_func
(paren
id|vol-&gt;upcase
)paren
suffix:semicolon
id|vol-&gt;upcase
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|vol-&gt;nls_map
)paren
(brace
id|unload_nls
c_func
(paren
id|vol-&gt;nls_map
)paren
suffix:semicolon
id|vol-&gt;nls_map
op_assign
l_int|NULL
suffix:semicolon
)brace
id|vfs_sb-&gt;s_fs_info
op_assign
l_int|NULL
suffix:semicolon
id|kfree
c_func
(paren
id|vol
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/**&n; * get_nr_free_clusters - return the number of free clusters on a volume&n; * @vol:&t;ntfs volume for which to obtain free cluster count&n; *&n; * Calculate the number of free clusters on the mounted NTFS volume @vol. We&n; * actually calculate the number of clusters in use instead because this&n; * allows us to not care about partial pages as these will be just zero filled&n; * and hence not be counted as allocated clusters.&n; *&n; * The only particularity is that clusters beyond the end of the logical ntfs&n; * volume will be marked as allocated to prevent errors which means we have to&n; * discount those at the end. This is important as the cluster bitmap always&n; * has a size in multiples of 8 bytes, i.e. up to 63 clusters could be outside&n; * the logical volume and marked in use when they are not as they do not exist.&n; *&n; * If any pages cannot be read we assume all clusters in the erroring pages are&n; * in use. This means we return an underestimate on errors which is better than&n; * an overestimate.&n; */
DECL|function|get_nr_free_clusters
r_static
id|s64
id|get_nr_free_clusters
c_func
(paren
id|ntfs_volume
op_star
id|vol
)paren
(brace
id|s64
id|nr_free
op_assign
id|vol-&gt;nr_clusters
suffix:semicolon
id|u32
op_star
id|kaddr
suffix:semicolon
r_struct
id|address_space
op_star
id|mapping
op_assign
id|vol-&gt;lcnbmp_ino-&gt;i_mapping
suffix:semicolon
id|filler_t
op_star
id|readpage
op_assign
(paren
id|filler_t
op_star
)paren
id|mapping-&gt;a_ops-&gt;readpage
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
r_int
r_int
id|index
comma
id|max_index
suffix:semicolon
r_int
r_int
id|max_size
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Entering.&quot;
)paren
suffix:semicolon
multiline_comment|/* Serialize accesses to the cluster bitmap. */
id|down_read
c_func
(paren
op_amp
id|vol-&gt;lcnbmp_lock
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Convert the number of bits into bytes rounded up, then convert into&n;&t; * multiples of PAGE_CACHE_SIZE, rounding up so that if we have one&n;&t; * full and one partial page max_index = 2.&n;&t; */
id|max_index
op_assign
(paren
(paren
(paren
id|vol-&gt;nr_clusters
op_plus
l_int|7
)paren
op_rshift
l_int|3
)paren
op_plus
id|PAGE_CACHE_SIZE
op_minus
l_int|1
)paren
op_rshift
id|PAGE_CACHE_SHIFT
suffix:semicolon
multiline_comment|/* Use multiples of 4 bytes. */
id|max_size
op_assign
id|PAGE_CACHE_SIZE
op_rshift
l_int|2
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Reading $Bitmap, max_index = 0x%lx, max_size = 0x%x.&quot;
comma
id|max_index
comma
id|max_size
)paren
suffix:semicolon
r_for
c_loop
(paren
id|index
op_assign
l_int|0UL
suffix:semicolon
id|index
OL
id|max_index
suffix:semicolon
id|index
op_increment
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Read the page from page cache, getting it from backing store&n;&t;&t; * if necessary, and increment the use count.&n;&t;&t; */
id|page
op_assign
id|read_cache_page
c_func
(paren
id|mapping
comma
id|index
comma
(paren
id|filler_t
op_star
)paren
id|readpage
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* Ignore pages which errored synchronously. */
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|page
)paren
)paren
(brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Sync read_cache_page() error. Skipping &quot;
l_string|&quot;page (index 0x%lx).&quot;
comma
id|index
)paren
suffix:semicolon
id|nr_free
op_sub_assign
id|PAGE_CACHE_SIZE
op_star
l_int|8
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|wait_on_page_locked
c_func
(paren
id|page
)paren
suffix:semicolon
multiline_comment|/* Ignore pages which errored asynchronously. */
r_if
c_cond
(paren
op_logical_neg
id|PageUptodate
c_func
(paren
id|page
)paren
)paren
(brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Async read_cache_page() error. Skipping &quot;
l_string|&quot;page (index 0x%lx).&quot;
comma
id|index
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
id|nr_free
op_sub_assign
id|PAGE_CACHE_SIZE
op_star
l_int|8
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|kaddr
op_assign
(paren
id|u32
op_star
)paren
id|kmap_atomic
c_func
(paren
id|page
comma
id|KM_USER0
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * For each 4 bytes, subtract the number of set bits. If this&n;&t;&t; * is the last page and it is partial we don&squot;t really care as&n;&t;&t; * it just means we do a little extra work but it won&squot;t affect&n;&t;&t; * the result as all out of range bytes are set to zero by&n;&t;&t; * ntfs_readpage().&n;&t;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|max_size
suffix:semicolon
id|i
op_increment
)paren
id|nr_free
op_sub_assign
(paren
id|s64
)paren
id|hweight32
c_func
(paren
id|kaddr
(braket
id|i
)braket
)paren
suffix:semicolon
id|kunmap_atomic
c_func
(paren
id|kaddr
comma
id|KM_USER0
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Finished reading $Bitmap, last index = 0x%lx.&quot;
comma
id|index
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Fixup for eventual bits outside logical ntfs volume (see function&n;&t; * description above).&n;&t; */
r_if
c_cond
(paren
id|vol-&gt;nr_clusters
op_amp
l_int|63
)paren
id|nr_free
op_add_assign
l_int|64
op_minus
(paren
id|vol-&gt;nr_clusters
op_amp
l_int|63
)paren
suffix:semicolon
id|up_read
c_func
(paren
op_amp
id|vol-&gt;lcnbmp_lock
)paren
suffix:semicolon
multiline_comment|/* If errors occured we may well have gone below zero, fix this. */
r_if
c_cond
(paren
id|nr_free
OL
l_int|0
)paren
id|nr_free
op_assign
l_int|0
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Exiting.&quot;
)paren
suffix:semicolon
r_return
id|nr_free
suffix:semicolon
)brace
multiline_comment|/**&n; * __get_nr_free_mft_records - return the number of free inodes on a volume&n; * @vol:&t;ntfs volume for which to obtain free inode count&n; *&n; * Calculate the number of free mft records (inodes) on the mounted NTFS&n; * volume @vol. We actually calculate the number of mft records in use instead&n; * because this allows us to not care about partial pages as these will be just&n; * zero filled and hence not be counted as allocated mft record.&n; *&n; * If any pages cannot be read we assume all mft records in the erroring pages&n; * are in use. This means we return an underestimate on errors which is better&n; * than an overestimate.&n; *&n; * NOTE: Caller must hold mftbmp_lock rw_semaphore for reading or writing.&n; */
DECL|function|__get_nr_free_mft_records
r_static
r_int
r_int
id|__get_nr_free_mft_records
c_func
(paren
id|ntfs_volume
op_star
id|vol
)paren
(brace
id|s64
id|nr_free
op_assign
id|vol-&gt;nr_mft_records
suffix:semicolon
id|u32
op_star
id|kaddr
suffix:semicolon
r_struct
id|address_space
op_star
id|mapping
op_assign
id|vol-&gt;mftbmp_ino-&gt;i_mapping
suffix:semicolon
id|filler_t
op_star
id|readpage
op_assign
(paren
id|filler_t
op_star
)paren
id|mapping-&gt;a_ops-&gt;readpage
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
r_int
r_int
id|index
comma
id|max_index
suffix:semicolon
r_int
r_int
id|max_size
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Entering.&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Convert the number of bits into bytes rounded up, then convert into&n;&t; * multiples of PAGE_CACHE_SIZE, rounding up so that if we have one&n;&t; * full and one partial page max_index = 2.&n;&t; */
id|max_index
op_assign
(paren
(paren
(paren
id|vol-&gt;nr_mft_records
op_plus
l_int|7
)paren
op_rshift
l_int|3
)paren
op_plus
id|PAGE_CACHE_SIZE
op_minus
l_int|1
)paren
op_rshift
id|PAGE_CACHE_SHIFT
suffix:semicolon
multiline_comment|/* Use multiples of 4 bytes. */
id|max_size
op_assign
id|PAGE_CACHE_SIZE
op_rshift
l_int|2
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Reading $MFT/$BITMAP, max_index = 0x%lx, max_size = &quot;
l_string|&quot;0x%x.&quot;
comma
id|max_index
comma
id|max_size
)paren
suffix:semicolon
r_for
c_loop
(paren
id|index
op_assign
l_int|0UL
suffix:semicolon
id|index
OL
id|max_index
suffix:semicolon
id|index
op_increment
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Read the page from page cache, getting it from backing store&n;&t;&t; * if necessary, and increment the use count.&n;&t;&t; */
id|page
op_assign
id|read_cache_page
c_func
(paren
id|mapping
comma
id|index
comma
(paren
id|filler_t
op_star
)paren
id|readpage
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* Ignore pages which errored synchronously. */
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|page
)paren
)paren
(brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Sync read_cache_page() error. Skipping &quot;
l_string|&quot;page (index 0x%lx).&quot;
comma
id|index
)paren
suffix:semicolon
id|nr_free
op_sub_assign
id|PAGE_CACHE_SIZE
op_star
l_int|8
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|wait_on_page_locked
c_func
(paren
id|page
)paren
suffix:semicolon
multiline_comment|/* Ignore pages which errored asynchronously. */
r_if
c_cond
(paren
op_logical_neg
id|PageUptodate
c_func
(paren
id|page
)paren
)paren
(brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Async read_cache_page() error. Skipping &quot;
l_string|&quot;page (index 0x%lx).&quot;
comma
id|index
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
id|nr_free
op_sub_assign
id|PAGE_CACHE_SIZE
op_star
l_int|8
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|kaddr
op_assign
(paren
id|u32
op_star
)paren
id|kmap_atomic
c_func
(paren
id|page
comma
id|KM_USER0
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * For each 4 bytes, subtract the number of set bits. If this&n;&t;&t; * is the last page and it is partial we don&squot;t really care as&n;&t;&t; * it just means we do a little extra work but it won&squot;t affect&n;&t;&t; * the result as all out of range bytes are set to zero by&n;&t;&t; * ntfs_readpage().&n;&t;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|max_size
suffix:semicolon
id|i
op_increment
)paren
id|nr_free
op_sub_assign
(paren
id|s64
)paren
id|hweight32
c_func
(paren
id|kaddr
(braket
id|i
)braket
)paren
suffix:semicolon
id|kunmap_atomic
c_func
(paren
id|kaddr
comma
id|KM_USER0
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Finished reading $MFT/$BITMAP, last index = 0x%lx.&quot;
comma
id|index
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* If errors occured we may well have gone below zero, fix this. */
r_if
c_cond
(paren
id|nr_free
OL
l_int|0
)paren
id|nr_free
op_assign
l_int|0
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Exiting.&quot;
)paren
suffix:semicolon
r_return
id|nr_free
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_statfs - return information about mounted NTFS volume&n; * @sb:&t;&t;super block of mounted volume&n; * @sfs:&t;statfs structure in which to return the information&n; *&n; * Return information about the mounted NTFS volume @sb in the statfs structure&n; * pointed to by @sfs (this is initialized with zeros before ntfs_statfs is&n; * called). We interpret the values to be correct of the moment in time at&n; * which we are called. Most values are variable otherwise and this isn&squot;t just&n; * the free values but the totals as well. For example we can increase the&n; * total number of file nodes if we run out and we can keep doing this until&n; * there is no more space on the volume left at all.&n; *&n; * Called from vfs_statfs which is used to handle the statfs, fstatfs, and&n; * ustat system calls.&n; *&n; * Return 0 on success or -errno on error.&n; */
DECL|function|ntfs_statfs
r_static
r_int
id|ntfs_statfs
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_struct
id|kstatfs
op_star
id|sfs
)paren
(brace
id|ntfs_volume
op_star
id|vol
op_assign
id|NTFS_SB
c_func
(paren
id|sb
)paren
suffix:semicolon
id|s64
id|size
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Entering.&quot;
)paren
suffix:semicolon
multiline_comment|/* Type of filesystem. */
id|sfs-&gt;f_type
op_assign
id|NTFS_SB_MAGIC
suffix:semicolon
multiline_comment|/* Optimal transfer block size. */
id|sfs-&gt;f_bsize
op_assign
id|PAGE_CACHE_SIZE
suffix:semicolon
multiline_comment|/*&n;&t; * Total data blocks in file system in units of f_bsize and since&n;&t; * inodes are also stored in data blocs ($MFT is a file) this is just&n;&t; * the total clusters.&n;&t; */
id|sfs-&gt;f_blocks
op_assign
id|vol-&gt;nr_clusters
op_lshift
id|vol-&gt;cluster_size_bits
op_rshift
id|PAGE_CACHE_SHIFT
suffix:semicolon
multiline_comment|/* Free data blocks in file system in units of f_bsize. */
id|size
op_assign
id|get_nr_free_clusters
c_func
(paren
id|vol
)paren
op_lshift
id|vol-&gt;cluster_size_bits
op_rshift
id|PAGE_CACHE_SHIFT
suffix:semicolon
r_if
c_cond
(paren
id|size
OL
l_int|0LL
)paren
id|size
op_assign
l_int|0LL
suffix:semicolon
multiline_comment|/* Free blocks avail to non-superuser, same as above on NTFS. */
id|sfs-&gt;f_bavail
op_assign
id|sfs-&gt;f_bfree
op_assign
id|size
suffix:semicolon
multiline_comment|/* Serialize accesses to the inode bitmap. */
id|down_read
c_func
(paren
op_amp
id|vol-&gt;mftbmp_lock
)paren
suffix:semicolon
multiline_comment|/* Total file nodes in file system (at this moment in time). */
id|sfs-&gt;f_files
op_assign
id|vol-&gt;mft_ino-&gt;i_size
op_rshift
id|vol-&gt;mft_record_size_bits
suffix:semicolon
multiline_comment|/* Free file nodes in fs (based on current total count). */
id|sfs-&gt;f_ffree
op_assign
id|__get_nr_free_mft_records
c_func
(paren
id|vol
)paren
suffix:semicolon
id|up_read
c_func
(paren
op_amp
id|vol-&gt;mftbmp_lock
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * File system id. This is extremely *nix flavour dependent and even&n;&t; * within Linux itself all fs do their own thing. I interpret this to&n;&t; * mean a unique id associated with the mounted fs and not the id&n;&t; * associated with the file system driver, the latter is already given&n;&t; * by the file system type in sfs-&gt;f_type. Thus we use the 64-bit&n;&t; * volume serial number splitting it into two 32-bit parts. We enter&n;&t; * the least significant 32-bits in f_fsid[0] and the most significant&n;&t; * 32-bits in f_fsid[1].&n;&t; */
id|sfs-&gt;f_fsid.val
(braket
l_int|0
)braket
op_assign
id|vol-&gt;serial_no
op_amp
l_int|0xffffffff
suffix:semicolon
id|sfs-&gt;f_fsid.val
(braket
l_int|1
)braket
op_assign
(paren
id|vol-&gt;serial_no
op_rshift
l_int|32
)paren
op_amp
l_int|0xffffffff
suffix:semicolon
multiline_comment|/* Maximum length of filenames. */
id|sfs-&gt;f_namelen
op_assign
id|NTFS_MAX_NAME_LEN
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * The complete super operations.&n; */
DECL|variable|ntfs_sops
r_struct
id|super_operations
id|ntfs_sops
op_assign
(brace
dot
id|alloc_inode
op_assign
id|ntfs_alloc_big_inode
comma
multiline_comment|/* VFS: Allocate new inode. */
dot
id|destroy_inode
op_assign
id|ntfs_destroy_big_inode
comma
multiline_comment|/* VFS: Deallocate inode. */
dot
id|put_inode
op_assign
id|ntfs_put_inode
comma
multiline_comment|/* VFS: Called just before&n;&t;&t;&t;&t;&t;&t;     the inode reference count&n;&t;&t;&t;&t;&t;&t;     is decreased. */
macro_line|#ifdef NTFS_RW
singleline_comment|//.dirty_inode&t;= NULL,&t;&t;&t;/* VFS: Called from
singleline_comment|//&t;&t;&t;&t;&t;   __mark_inode_dirty(). */
dot
id|write_inode
op_assign
id|ntfs_write_inode
comma
multiline_comment|/* VFS: Write dirty inode to&n;&t;&t;&t;&t;&t;&t;   disk. */
singleline_comment|//.drop_inode&t;= NULL,&t;&t;&t;/* VFS: Called just after the
singleline_comment|//&t;&t;&t;&t;&t;   inode reference count has
singleline_comment|//&t;&t;&t;&t;&t;   been decreased to zero.
singleline_comment|//&t;&t;&t;&t;&t;   NOTE: The inode lock is
singleline_comment|//&t;&t;&t;&t;&t;   held. See fs/inode.c::
singleline_comment|//&t;&t;&t;&t;&t;   generic_drop_inode(). */
singleline_comment|//.delete_inode&t;= NULL,&t;&t;&t;/* VFS: Delete inode from disk.
singleline_comment|//&t;&t;&t;&t;&t;   Called when i_count becomes
singleline_comment|//&t;&t;&t;&t;&t;   0 and i_nlink is also 0. */
singleline_comment|//.write_super&t;= NULL,&t;&t;&t;/* Flush dirty super block to
singleline_comment|//&t;&t;&t;&t;&t;   disk. */
singleline_comment|//.sync_fs&t;= NULL,&t;&t;&t;/* ? */
singleline_comment|//.write_super_lockfs&t;= NULL,&t;&t;/* ? */
singleline_comment|//.unlockfs&t;= NULL,&t;&t;&t;/* ? */
macro_line|#endif /* NTFS_RW */
dot
id|put_super
op_assign
id|ntfs_put_super
comma
multiline_comment|/* Syscall: umount. */
dot
id|statfs
op_assign
id|ntfs_statfs
comma
multiline_comment|/* Syscall: statfs */
dot
id|remount_fs
op_assign
id|ntfs_remount
comma
multiline_comment|/* Syscall: mount -o remount. */
dot
id|clear_inode
op_assign
id|ntfs_clear_big_inode
comma
multiline_comment|/* VFS: Called when an inode is&n;&t;&t;&t;&t;&t;&t;   removed from memory. */
singleline_comment|//.umount_begin&t;= NULL,&t;&t;&t;/* Forced umount. */
dot
id|show_options
op_assign
id|ntfs_show_options
comma
multiline_comment|/* Show mount options in&n;&t;&t;&t;&t;&t;&t;   proc. */
)brace
suffix:semicolon
multiline_comment|/**&n; * Declarations for NTFS specific export operations (fs/ntfs/namei.c).&n; */
r_extern
r_struct
id|dentry
op_star
id|ntfs_get_parent
c_func
(paren
r_struct
id|dentry
op_star
id|child_dent
)paren
suffix:semicolon
r_extern
r_struct
id|dentry
op_star
id|ntfs_get_dentry
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_void
op_star
id|fh
)paren
suffix:semicolon
multiline_comment|/**&n; * Export operations allowing NFS exporting of mounted NTFS partitions.&n; *&n; * We use the default -&gt;decode_fh() and -&gt;encode_fh() for now.  Note that they&n; * use 32 bits to store the inode number which is an unsigned long so on 64-bit&n; * architectures is usually 64 bits so it would all fail horribly on huge&n; * volumes.  I guess we need to define our own encode and decode fh functions&n; * that store 64-bit inode numbers at some point but for now we will ignore the&n; * problem...&n; *&n; * We also use the default -&gt;get_name() helper (used by -&gt;decode_fh() via&n; * fs/exportfs/expfs.c::find_exported_dentry()) as that is completely fs&n; * independent.&n; *&n; * The default -&gt;get_parent() just returns -EACCES so we have to provide our&n; * own and the default -&gt;get_dentry() is incompatible with NTFS due to not&n; * allowing the inode number 0 which is used in NTFS for the system file $MFT&n; * and due to using iget() whereas NTFS needs ntfs_iget().&n; */
DECL|variable|ntfs_export_ops
r_static
r_struct
id|export_operations
id|ntfs_export_ops
op_assign
(brace
dot
id|get_parent
op_assign
id|ntfs_get_parent
comma
multiline_comment|/* Find the parent of a given&n;&t;&t;&t;&t;&t;&t;   directory. */
dot
id|get_dentry
op_assign
id|ntfs_get_dentry
comma
multiline_comment|/* Find a dentry for the inode&n;&t;&t;&t;&t;&t;&t;   given a file handle&n;&t;&t;&t;&t;&t;&t;   sub-fragment. */
)brace
suffix:semicolon
multiline_comment|/**&n; * ntfs_fill_super - mount an ntfs files system&n; * @sb:&t;&t;super block of ntfs file system to mount&n; * @opt:&t;string containing the mount options&n; * @silent:&t;silence error output&n; *&n; * ntfs_fill_super() is called by the VFS to mount the device described by @sb&n; * with the mount otions in @data with the NTFS file system.&n; *&n; * If @silent is true, remain silent even if errors are detected. This is used&n; * during bootup, when the kernel tries to mount the root file system with all&n; * registered file systems one after the other until one succeeds. This implies&n; * that all file systems except the correct one will quite correctly and&n; * expectedly return an error, but nobody wants to see error messages when in&n; * fact this is what is supposed to happen.&n; *&n; * NOTE: @sb-&gt;s_flags contains the mount options flags.&n; */
DECL|function|ntfs_fill_super
r_static
r_int
id|ntfs_fill_super
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_void
op_star
id|opt
comma
r_const
r_int
id|silent
)paren
(brace
id|ntfs_volume
op_star
id|vol
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
r_struct
id|inode
op_star
id|tmp_ino
suffix:semicolon
r_int
id|result
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Entering.&quot;
)paren
suffix:semicolon
macro_line|#ifndef NTFS_RW
id|sb-&gt;s_flags
op_or_assign
id|MS_RDONLY
op_or
id|MS_NOATIME
op_or
id|MS_NODIRATIME
suffix:semicolon
macro_line|#else
r_if
c_cond
(paren
op_logical_neg
(paren
id|sb-&gt;s_flags
op_amp
id|MS_NOATIME
)paren
)paren
id|ntfs_warning
c_func
(paren
id|sb
comma
l_string|&quot;Atime updates are not implemented yet.  &quot;
l_string|&quot;Disabling them.&quot;
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
(paren
id|sb-&gt;s_flags
op_amp
id|MS_NODIRATIME
)paren
)paren
id|ntfs_warning
c_func
(paren
id|sb
comma
l_string|&quot;Directory atime updates are not implemented &quot;
l_string|&quot;yet.  Disabling them.&quot;
)paren
suffix:semicolon
id|sb-&gt;s_flags
op_or_assign
id|MS_NOATIME
op_or
id|MS_NODIRATIME
suffix:semicolon
macro_line|#endif
multiline_comment|/* Allocate a new ntfs_volume and place it in sb-&gt;s_fs_info. */
id|sb-&gt;s_fs_info
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|ntfs_volume
)paren
comma
id|GFP_NOFS
)paren
suffix:semicolon
id|vol
op_assign
id|NTFS_SB
c_func
(paren
id|sb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vol
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|silent
)paren
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Allocation of NTFS volume structure &quot;
l_string|&quot;failed. Aborting mount...&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
multiline_comment|/* Initialize ntfs_volume structure. */
id|memset
c_func
(paren
id|vol
comma
l_int|0
comma
r_sizeof
(paren
id|ntfs_volume
)paren
)paren
suffix:semicolon
id|vol-&gt;sb
op_assign
id|sb
suffix:semicolon
id|vol-&gt;upcase
op_assign
l_int|NULL
suffix:semicolon
id|vol-&gt;mft_ino
op_assign
l_int|NULL
suffix:semicolon
id|vol-&gt;mftbmp_ino
op_assign
l_int|NULL
suffix:semicolon
id|init_rwsem
c_func
(paren
op_amp
id|vol-&gt;mftbmp_lock
)paren
suffix:semicolon
macro_line|#ifdef NTFS_RW
id|vol-&gt;mftmirr_ino
op_assign
l_int|NULL
suffix:semicolon
id|vol-&gt;mftmirr_size
op_assign
l_int|0
suffix:semicolon
id|vol-&gt;logfile_ino
op_assign
l_int|NULL
suffix:semicolon
macro_line|#endif /* NTFS_RW */
id|vol-&gt;lcnbmp_ino
op_assign
l_int|NULL
suffix:semicolon
id|init_rwsem
c_func
(paren
op_amp
id|vol-&gt;lcnbmp_lock
)paren
suffix:semicolon
id|vol-&gt;vol_ino
op_assign
l_int|NULL
suffix:semicolon
id|vol-&gt;root_ino
op_assign
l_int|NULL
suffix:semicolon
id|vol-&gt;secure_ino
op_assign
l_int|NULL
suffix:semicolon
id|vol-&gt;uid
op_assign
id|vol-&gt;gid
op_assign
l_int|0
suffix:semicolon
id|vol-&gt;flags
op_assign
l_int|0
suffix:semicolon
id|vol-&gt;on_errors
op_assign
l_int|0
suffix:semicolon
id|vol-&gt;mft_zone_multiplier
op_assign
l_int|0
suffix:semicolon
id|vol-&gt;nls_map
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * Default is group and other don&squot;t have any access to files or&n;&t; * directories while owner has full access. Further, files by default&n;&t; * are not executable but directories are of course browseable.&n;&t; */
id|vol-&gt;fmask
op_assign
l_int|0177
suffix:semicolon
id|vol-&gt;dmask
op_assign
l_int|0077
suffix:semicolon
multiline_comment|/* Important to get the mount options dealt with now. */
r_if
c_cond
(paren
op_logical_neg
id|parse_options
c_func
(paren
id|vol
comma
(paren
r_char
op_star
)paren
id|opt
)paren
)paren
r_goto
id|err_out_now
suffix:semicolon
multiline_comment|/*&n;&t; * TODO: Fail safety check. In the future we should really be able to&n;&t; * cope with this being the case, but for now just bail out.&n;&t; */
r_if
c_cond
(paren
id|bdev_hardsect_size
c_func
(paren
id|sb-&gt;s_bdev
)paren
OG
id|NTFS_BLOCK_SIZE
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|silent
)paren
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Device has unsupported hardsect_size.&quot;
)paren
suffix:semicolon
r_goto
id|err_out_now
suffix:semicolon
)brace
multiline_comment|/* Setup the device access block size to NTFS_BLOCK_SIZE. */
r_if
c_cond
(paren
id|sb_set_blocksize
c_func
(paren
id|sb
comma
id|NTFS_BLOCK_SIZE
)paren
op_ne
id|NTFS_BLOCK_SIZE
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|silent
)paren
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Unable to set block size.&quot;
)paren
suffix:semicolon
r_goto
id|err_out_now
suffix:semicolon
)brace
multiline_comment|/* Get the size of the device in units of NTFS_BLOCK_SIZE bytes. */
id|vol-&gt;nr_blocks
op_assign
id|sb-&gt;s_bdev-&gt;bd_inode-&gt;i_size
op_rshift
id|NTFS_BLOCK_SIZE_BITS
suffix:semicolon
multiline_comment|/* Read the boot sector and return unlocked buffer head to it. */
r_if
c_cond
(paren
op_logical_neg
(paren
id|bh
op_assign
id|read_ntfs_boot_sector
c_func
(paren
id|sb
comma
id|silent
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|silent
)paren
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Not an NTFS volume.&quot;
)paren
suffix:semicolon
r_goto
id|err_out_now
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Extract the data from the boot sector and setup the ntfs super block&n;&t; * using it.&n;&t; */
id|result
op_assign
id|parse_ntfs_boot_sector
c_func
(paren
id|vol
comma
(paren
id|NTFS_BOOT_SECTOR
op_star
)paren
id|bh-&gt;b_data
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|result
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|silent
)paren
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Unsupported NTFS filesystem.&quot;
)paren
suffix:semicolon
r_goto
id|err_out_now
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * TODO: When we start coping with sector sizes different from&n;&t; * NTFS_BLOCK_SIZE, we now probably need to set the blocksize of the&n;&t; * device (probably to NTFS_BLOCK_SIZE).&n;&t; */
multiline_comment|/* Setup remaining fields in the super block. */
id|sb-&gt;s_magic
op_assign
id|NTFS_SB_MAGIC
suffix:semicolon
multiline_comment|/*&n;&t; * Ntfs allows 63 bits for the file size, i.e. correct would be:&n;&t; *&t;sb-&gt;s_maxbytes = ~0ULL &gt;&gt; 1;&n;&t; * But the kernel uses a long as the page cache page index which on&n;&t; * 32-bit architectures is only 32-bits. MAX_LFS_FILESIZE is kernel&n;&t; * defined to the maximum the page cache page index can cope with&n;&t; * without overflowing the index or to 2^63 - 1, whichever is smaller.&n;&t; */
id|sb-&gt;s_maxbytes
op_assign
id|MAX_LFS_FILESIZE
suffix:semicolon
multiline_comment|/*&n;&t; * Now load the metadata required for the page cache and our address&n;&t; * space operations to function. We do this by setting up a specialised&n;&t; * read_inode method and then just calling the normal iget() to obtain&n;&t; * the inode for $MFT which is sufficient to allow our normal inode&n;&t; * operations and associated address space operations to function.&n;&t; */
id|sb-&gt;s_op
op_assign
op_amp
id|ntfs_sops
suffix:semicolon
id|tmp_ino
op_assign
id|new_inode
c_func
(paren
id|sb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tmp_ino
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|silent
)paren
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Failed to load essential metadata.&quot;
)paren
suffix:semicolon
r_goto
id|err_out_now
suffix:semicolon
)brace
id|tmp_ino-&gt;i_ino
op_assign
id|FILE_MFT
suffix:semicolon
id|insert_inode_hash
c_func
(paren
id|tmp_ino
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ntfs_read_inode_mount
c_func
(paren
id|tmp_ino
)paren
OL
l_int|0
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|silent
)paren
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Failed to load essential metadata.&quot;
)paren
suffix:semicolon
r_goto
id|iput_tmp_ino_err_out_now
suffix:semicolon
)brace
id|down
c_func
(paren
op_amp
id|ntfs_lock
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * The current mount is a compression user if the cluster size is&n;&t; * less than or equal 4kiB.&n;&t; */
r_if
c_cond
(paren
id|vol-&gt;cluster_size
op_le
l_int|4096
op_logical_and
op_logical_neg
id|ntfs_nr_compression_users
op_increment
)paren
(brace
id|result
op_assign
id|allocate_compression_buffers
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
)paren
(brace
id|ntfs_error
c_func
(paren
l_int|NULL
comma
l_string|&quot;Failed to allocate buffers &quot;
l_string|&quot;for compression engine.&quot;
)paren
suffix:semicolon
id|ntfs_nr_compression_users
op_decrement
suffix:semicolon
id|up
c_func
(paren
op_amp
id|ntfs_lock
)paren
suffix:semicolon
r_goto
id|iput_tmp_ino_err_out_now
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Increment the number of mounts and generate the global default&n;&t; * upcase table if necessary. Also temporarily increment the number of&n;&t; * upcase users to avoid race conditions with concurrent (u)mounts.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|ntfs_nr_mounts
op_increment
)paren
id|default_upcase
op_assign
id|generate_default_upcase
c_func
(paren
)paren
suffix:semicolon
id|ntfs_nr_upcase_users
op_increment
suffix:semicolon
id|up
c_func
(paren
op_amp
id|ntfs_lock
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * From now on, ignore @silent parameter. If we fail below this line,&n;&t; * it will be due to a corrupt fs or a system error, so we report it.&n;&t; */
multiline_comment|/*&n;&t; * Open the system files with normal access functions and complete&n;&t; * setting up the ntfs super block.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|load_system_files
c_func
(paren
id|vol
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Failed to load system files.&quot;
)paren
suffix:semicolon
r_goto
id|unl_upcase_iput_tmp_ino_err_out_now
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|sb-&gt;s_root
op_assign
id|d_alloc_root
c_func
(paren
id|vol-&gt;root_ino
)paren
)paren
)paren
(brace
multiline_comment|/* We increment i_count simulating an ntfs_iget(). */
id|atomic_inc
c_func
(paren
op_amp
id|vol-&gt;root_ino-&gt;i_count
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Exiting, status successful.&quot;
)paren
suffix:semicolon
multiline_comment|/* Release the default upcase if it has no users. */
id|down
c_func
(paren
op_amp
id|ntfs_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_decrement
id|ntfs_nr_upcase_users
op_logical_and
id|default_upcase
)paren
(brace
id|ntfs_free
c_func
(paren
id|default_upcase
)paren
suffix:semicolon
id|default_upcase
op_assign
l_int|NULL
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|ntfs_lock
)paren
suffix:semicolon
id|sb-&gt;s_export_op
op_assign
op_amp
id|ntfs_export_ops
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Failed to allocate root directory.&quot;
)paren
suffix:semicolon
multiline_comment|/* Clean up after the successful load_system_files() call from above. */
id|iput
c_func
(paren
id|vol-&gt;vol_ino
)paren
suffix:semicolon
id|vol-&gt;vol_ino
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* NTFS 3.0+ specific clean up. */
r_if
c_cond
(paren
id|vol-&gt;major_ver
op_ge
l_int|3
)paren
(brace
id|iput
c_func
(paren
id|vol-&gt;secure_ino
)paren
suffix:semicolon
id|vol-&gt;secure_ino
op_assign
l_int|NULL
suffix:semicolon
)brace
id|iput
c_func
(paren
id|vol-&gt;root_ino
)paren
suffix:semicolon
id|vol-&gt;root_ino
op_assign
l_int|NULL
suffix:semicolon
id|iput
c_func
(paren
id|vol-&gt;lcnbmp_ino
)paren
suffix:semicolon
id|vol-&gt;lcnbmp_ino
op_assign
l_int|NULL
suffix:semicolon
macro_line|#ifdef NTFS_RW
id|iput
c_func
(paren
id|vol-&gt;mftmirr_ino
)paren
suffix:semicolon
id|vol-&gt;mftmirr_ino
op_assign
l_int|NULL
suffix:semicolon
macro_line|#endif /* NTFS_RW */
id|iput
c_func
(paren
id|vol-&gt;mftbmp_ino
)paren
suffix:semicolon
id|vol-&gt;mftbmp_ino
op_assign
l_int|NULL
suffix:semicolon
id|vol-&gt;upcase_len
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|vol-&gt;upcase
op_ne
id|default_upcase
)paren
id|ntfs_free
c_func
(paren
id|vol-&gt;upcase
)paren
suffix:semicolon
id|vol-&gt;upcase
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|vol-&gt;nls_map
)paren
(brace
id|unload_nls
c_func
(paren
id|vol-&gt;nls_map
)paren
suffix:semicolon
id|vol-&gt;nls_map
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Error exit code path. */
id|unl_upcase_iput_tmp_ino_err_out_now
suffix:colon
multiline_comment|/*&n;&t; * Decrease the number of mounts and destroy the global default upcase&n;&t; * table if necessary.&n;&t; */
id|down
c_func
(paren
op_amp
id|ntfs_lock
)paren
suffix:semicolon
id|ntfs_nr_mounts
op_decrement
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_decrement
id|ntfs_nr_upcase_users
op_logical_and
id|default_upcase
)paren
(brace
id|ntfs_free
c_func
(paren
id|default_upcase
)paren
suffix:semicolon
id|default_upcase
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|vol-&gt;cluster_size
op_le
l_int|4096
op_logical_and
op_logical_neg
op_decrement
id|ntfs_nr_compression_users
)paren
id|free_compression_buffers
c_func
(paren
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|ntfs_lock
)paren
suffix:semicolon
id|iput_tmp_ino_err_out_now
suffix:colon
id|iput
c_func
(paren
id|tmp_ino
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vol-&gt;mft_ino
op_logical_and
id|vol-&gt;mft_ino
op_ne
id|tmp_ino
)paren
(brace
id|iput
c_func
(paren
id|vol-&gt;mft_ino
)paren
suffix:semicolon
id|vol-&gt;mft_ino
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * This is needed to get ntfs_clear_extent_inode() called for each&n;&t; * inode we have ever called ntfs_iget()/iput() on, otherwise we A)&n;&t; * leak resources and B) a subsequent mount fails automatically due to&n;&t; * ntfs_iget() never calling down into our ntfs_read_locked_inode()&n;&t; * method again... FIXME: Do we need to do this twice now because of&n;&t; * attribute inodes? I think not, so leave as is for now... (AIA)&n;&t; */
r_if
c_cond
(paren
id|invalidate_inodes
c_func
(paren
id|sb
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Busy inodes left. This is most likely a NTFS &quot;
l_string|&quot;driver bug.&quot;
)paren
suffix:semicolon
multiline_comment|/* Copied from fs/super.c. I just love this message. (-; */
id|printk
c_func
(paren
l_string|&quot;NTFS: Busy inodes after umount. Self-destruct in 5 &quot;
l_string|&quot;seconds.  Have a nice day...&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* Errors at this stage are irrelevant. */
id|err_out_now
suffix:colon
id|sb-&gt;s_fs_info
op_assign
l_int|NULL
suffix:semicolon
id|kfree
c_func
(paren
id|vol
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Failed, returning -EINVAL.&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/*&n; * This is a slab cache to optimize allocations and deallocations of Unicode&n; * strings of the maximum length allowed by NTFS, which is NTFS_MAX_NAME_LEN&n; * (255) Unicode characters + a terminating NULL Unicode character.&n; */
DECL|variable|ntfs_name_cache
id|kmem_cache_t
op_star
id|ntfs_name_cache
suffix:semicolon
multiline_comment|/* Slab caches for efficient allocation/deallocation of of inodes. */
DECL|variable|ntfs_inode_cache
id|kmem_cache_t
op_star
id|ntfs_inode_cache
suffix:semicolon
DECL|variable|ntfs_big_inode_cache
id|kmem_cache_t
op_star
id|ntfs_big_inode_cache
suffix:semicolon
multiline_comment|/* Init once constructor for the inode slab cache. */
DECL|function|ntfs_big_inode_init_once
r_static
r_void
id|ntfs_big_inode_init_once
c_func
(paren
r_void
op_star
id|foo
comma
id|kmem_cache_t
op_star
id|cachep
comma
r_int
r_int
id|flags
)paren
(brace
id|ntfs_inode
op_star
id|ni
op_assign
(paren
id|ntfs_inode
op_star
)paren
id|foo
suffix:semicolon
r_if
c_cond
(paren
(paren
id|flags
op_amp
(paren
id|SLAB_CTOR_VERIFY
op_or
id|SLAB_CTOR_CONSTRUCTOR
)paren
)paren
op_eq
id|SLAB_CTOR_CONSTRUCTOR
)paren
id|inode_init_once
c_func
(paren
id|VFS_I
c_func
(paren
id|ni
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Slab cache to optimize allocations and deallocations of attribute search&n; * contexts.&n; */
DECL|variable|ntfs_attr_ctx_cache
id|kmem_cache_t
op_star
id|ntfs_attr_ctx_cache
suffix:semicolon
multiline_comment|/* A global default upcase table and a corresponding reference count. */
DECL|variable|default_upcase
m_wchar_t
op_star
id|default_upcase
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|ntfs_nr_upcase_users
r_int
r_int
id|ntfs_nr_upcase_users
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* The number of mounted filesystems. */
DECL|variable|ntfs_nr_mounts
r_int
r_int
id|ntfs_nr_mounts
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Driver wide semaphore. */
DECL|variable|ntfs_lock
id|DECLARE_MUTEX
c_func
(paren
id|ntfs_lock
)paren
suffix:semicolon
DECL|function|ntfs_get_sb
r_static
r_struct
id|super_block
op_star
id|ntfs_get_sb
c_func
(paren
r_struct
id|file_system_type
op_star
id|fs_type
comma
r_int
id|flags
comma
r_const
r_char
op_star
id|dev_name
comma
r_void
op_star
id|data
)paren
(brace
r_return
id|get_sb_bdev
c_func
(paren
id|fs_type
comma
id|flags
comma
id|dev_name
comma
id|data
comma
id|ntfs_fill_super
)paren
suffix:semicolon
)brace
DECL|variable|ntfs_fs_type
r_static
r_struct
id|file_system_type
id|ntfs_fs_type
op_assign
(brace
dot
id|owner
op_assign
id|THIS_MODULE
comma
dot
id|name
op_assign
l_string|&quot;ntfs&quot;
comma
dot
id|get_sb
op_assign
id|ntfs_get_sb
comma
dot
id|kill_sb
op_assign
id|kill_block_super
comma
dot
id|fs_flags
op_assign
id|FS_REQUIRES_DEV
comma
)brace
suffix:semicolon
multiline_comment|/* Stable names for the slab caches. */
DECL|variable|ntfs_attr_ctx_cache_name
r_static
r_const
r_char
id|ntfs_attr_ctx_cache_name
(braket
)braket
op_assign
l_string|&quot;ntfs_attr_ctx_cache&quot;
suffix:semicolon
DECL|variable|ntfs_name_cache_name
r_static
r_const
r_char
id|ntfs_name_cache_name
(braket
)braket
op_assign
l_string|&quot;ntfs_name_cache&quot;
suffix:semicolon
DECL|variable|ntfs_inode_cache_name
r_static
r_const
r_char
id|ntfs_inode_cache_name
(braket
)braket
op_assign
l_string|&quot;ntfs_inode_cache&quot;
suffix:semicolon
DECL|variable|ntfs_big_inode_cache_name
r_static
r_const
r_char
id|ntfs_big_inode_cache_name
(braket
)braket
op_assign
l_string|&quot;ntfs_big_inode_cache&quot;
suffix:semicolon
DECL|function|init_ntfs_fs
r_static
r_int
id|__init
id|init_ntfs_fs
c_func
(paren
r_void
)paren
(brace
r_int
id|err
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* This may be ugly but it results in pretty output so who cares. (-8 */
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;NTFS driver &quot;
id|NTFS_VERSION
l_string|&quot; [Flags: R/&quot;
macro_line|#ifdef NTFS_RW
l_string|&quot;W&quot;
macro_line|#else
l_string|&quot;O&quot;
macro_line|#endif
macro_line|#ifdef DEBUG
l_string|&quot; DEBUG&quot;
macro_line|#endif
macro_line|#ifdef MODULE
l_string|&quot; MODULE&quot;
macro_line|#endif
l_string|&quot;].&bslash;n&quot;
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Debug messages are enabled.&quot;
)paren
suffix:semicolon
id|ntfs_attr_ctx_cache
op_assign
id|kmem_cache_create
c_func
(paren
id|ntfs_attr_ctx_cache_name
comma
r_sizeof
(paren
id|attr_search_context
)paren
comma
l_int|0
multiline_comment|/* offset */
comma
id|SLAB_HWCACHE_ALIGN
comma
l_int|NULL
multiline_comment|/* ctor */
comma
l_int|NULL
multiline_comment|/* dtor */
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ntfs_attr_ctx_cache
)paren
(brace
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;NTFS: Failed to create %s!&bslash;n&quot;
comma
id|ntfs_attr_ctx_cache_name
)paren
suffix:semicolon
r_goto
id|ctx_err_out
suffix:semicolon
)brace
id|ntfs_name_cache
op_assign
id|kmem_cache_create
c_func
(paren
id|ntfs_name_cache_name
comma
(paren
id|NTFS_MAX_NAME_LEN
op_plus
l_int|1
)paren
op_star
r_sizeof
(paren
id|ntfschar
)paren
comma
l_int|0
comma
id|SLAB_HWCACHE_ALIGN
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ntfs_name_cache
)paren
(brace
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;NTFS: Failed to create %s!&bslash;n&quot;
comma
id|ntfs_name_cache_name
)paren
suffix:semicolon
r_goto
id|name_err_out
suffix:semicolon
)brace
id|ntfs_inode_cache
op_assign
id|kmem_cache_create
c_func
(paren
id|ntfs_inode_cache_name
comma
r_sizeof
(paren
id|ntfs_inode
)paren
comma
l_int|0
comma
id|SLAB_HWCACHE_ALIGN
op_or
id|SLAB_RECLAIM_ACCOUNT
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ntfs_inode_cache
)paren
(brace
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;NTFS: Failed to create %s!&bslash;n&quot;
comma
id|ntfs_inode_cache_name
)paren
suffix:semicolon
r_goto
id|inode_err_out
suffix:semicolon
)brace
id|ntfs_big_inode_cache
op_assign
id|kmem_cache_create
c_func
(paren
id|ntfs_big_inode_cache_name
comma
r_sizeof
(paren
id|big_ntfs_inode
)paren
comma
l_int|0
comma
id|SLAB_HWCACHE_ALIGN
op_or
id|SLAB_RECLAIM_ACCOUNT
comma
id|ntfs_big_inode_init_once
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ntfs_big_inode_cache
)paren
(brace
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;NTFS: Failed to create %s!&bslash;n&quot;
comma
id|ntfs_big_inode_cache_name
)paren
suffix:semicolon
r_goto
id|big_inode_err_out
suffix:semicolon
)brace
multiline_comment|/* Register the ntfs sysctls. */
id|err
op_assign
id|ntfs_sysctl
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;NTFS: Failed to register NTFS sysctls!&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|sysctl_err_out
suffix:semicolon
)brace
id|err
op_assign
id|register_filesystem
c_func
(paren
op_amp
id|ntfs_fs_type
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|err
)paren
(brace
id|ntfs_debug
c_func
(paren
l_string|&quot;NTFS driver registered successfully.&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Success! */
)brace
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;NTFS: Failed to register NTFS file system driver!&bslash;n&quot;
)paren
suffix:semicolon
id|sysctl_err_out
suffix:colon
id|kmem_cache_destroy
c_func
(paren
id|ntfs_big_inode_cache
)paren
suffix:semicolon
id|big_inode_err_out
suffix:colon
id|kmem_cache_destroy
c_func
(paren
id|ntfs_inode_cache
)paren
suffix:semicolon
id|inode_err_out
suffix:colon
id|kmem_cache_destroy
c_func
(paren
id|ntfs_name_cache
)paren
suffix:semicolon
id|name_err_out
suffix:colon
id|kmem_cache_destroy
c_func
(paren
id|ntfs_attr_ctx_cache
)paren
suffix:semicolon
id|ctx_err_out
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|err
)paren
(brace
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;NTFS: Aborting NTFS file system driver &quot;
l_string|&quot;registration...&bslash;n&quot;
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_return
id|err
suffix:semicolon
)brace
DECL|function|exit_ntfs_fs
r_static
r_void
id|__exit
id|exit_ntfs_fs
c_func
(paren
r_void
)paren
(brace
r_int
id|err
op_assign
l_int|0
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Unregistering NTFS driver.&quot;
)paren
suffix:semicolon
id|unregister_filesystem
c_func
(paren
op_amp
id|ntfs_fs_type
)paren
suffix:semicolon
r_if
c_cond
(paren
id|kmem_cache_destroy
c_func
(paren
id|ntfs_big_inode_cache
)paren
op_logical_and
(paren
id|err
op_assign
l_int|1
)paren
)paren
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;NTFS: Failed to destory %s.&bslash;n&quot;
comma
id|ntfs_big_inode_cache_name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|kmem_cache_destroy
c_func
(paren
id|ntfs_inode_cache
)paren
op_logical_and
(paren
id|err
op_assign
l_int|1
)paren
)paren
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;NTFS: Failed to destory %s.&bslash;n&quot;
comma
id|ntfs_inode_cache_name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|kmem_cache_destroy
c_func
(paren
id|ntfs_name_cache
)paren
op_logical_and
(paren
id|err
op_assign
l_int|1
)paren
)paren
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;NTFS: Failed to destory %s.&bslash;n&quot;
comma
id|ntfs_name_cache_name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|kmem_cache_destroy
c_func
(paren
id|ntfs_attr_ctx_cache
)paren
op_logical_and
(paren
id|err
op_assign
l_int|1
)paren
)paren
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;NTFS: Failed to destory %s.&bslash;n&quot;
comma
id|ntfs_attr_ctx_cache_name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;NTFS: This causes memory to leak! There is &quot;
l_string|&quot;probably a BUG in the driver! Please report &quot;
l_string|&quot;you saw this message to &quot;
l_string|&quot;linux-ntfs-dev@lists.sourceforge.net&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Unregister the ntfs sysctls. */
id|ntfs_sysctl
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Anton Altaparmakov &lt;aia21@cantab.net&gt;&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;NTFS 1.2/3.x driver - Copyright (c) 2001-2004 Anton Altaparmakov&quot;
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
id|MODULE_PARM
c_func
(paren
id|debug_msgs
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|debug_msgs
comma
l_string|&quot;Enable debug messages.&quot;
)paren
suffix:semicolon
macro_line|#endif
id|module_init
c_func
(paren
id|init_ntfs_fs
)paren
id|module_exit
c_func
(paren
id|exit_ntfs_fs
)paren
eof
