multiline_comment|/*&n; * dir.c&n; *&n; * Copyright (C) 1995-1997, 1999 Martin von L&#xfffd;wis&n; * Copyright (C) 1999 Steve Dodd&n; * Copyright (C) 1999 Joseph Malicki&n; * Copyright (C) 2001 Anton Altaparmakov (AIA)&n; */
macro_line|#include &quot;ntfstypes.h&quot;
macro_line|#include &quot;struct.h&quot;
macro_line|#include &quot;dir.h&quot;
macro_line|#include &quot;macros.h&quot;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &quot;super.h&quot;
macro_line|#include &quot;inode.h&quot;
macro_line|#include &quot;attr.h&quot;
macro_line|#include &quot;support.h&quot;
macro_line|#include &quot;util.h&quot;
macro_line|#include &lt;linux/smp_lock.h&gt;
DECL|variable|I30
r_static
r_char
id|I30
(braket
)braket
op_assign
l_string|&quot;$I30&quot;
suffix:semicolon
multiline_comment|/* An index record should start with INDX, and the last word in each block&n; * should contain the check value. If it passes, the original values need to&n; * be restored. */
DECL|function|ntfs_check_index_record
r_int
id|ntfs_check_index_record
c_func
(paren
id|ntfs_inode
op_star
id|ino
comma
r_char
op_star
id|record
)paren
(brace
r_return
id|ntfs_fixup_record
c_func
(paren
id|ino-&gt;vol
comma
id|record
comma
l_string|&quot;INDX&quot;
comma
id|ino-&gt;u.index.recordsize
)paren
suffix:semicolon
)brace
DECL|function|ntfs_is_top
r_static
r_inline
r_int
id|ntfs_is_top
c_func
(paren
id|ntfs_u64
id|stack
)paren
(brace
r_return
id|stack
op_eq
l_int|14
suffix:semicolon
)brace
DECL|function|ntfs_pop
r_static
r_int
id|ntfs_pop
c_func
(paren
id|ntfs_u64
op_star
id|stack
)paren
(brace
r_static
r_int
id|width
(braket
l_int|16
)braket
op_assign
(brace
l_int|1
comma
l_int|2
comma
l_int|1
comma
l_int|3
comma
l_int|1
comma
l_int|2
comma
l_int|1
comma
l_int|4
comma
l_int|1
comma
l_int|2
comma
l_int|1
comma
l_int|3
comma
l_int|1
comma
l_int|2
comma
l_int|1
comma
op_minus
l_int|1
)brace
suffix:semicolon
r_int
id|res
op_assign
op_minus
l_int|1
suffix:semicolon
r_switch
c_cond
(paren
id|width
(braket
op_star
id|stack
op_amp
l_int|15
)braket
)paren
(brace
r_case
l_int|1
suffix:colon
id|res
op_assign
(paren
r_int
)paren
(paren
(paren
op_star
id|stack
op_amp
l_int|15
)paren
op_rshift
l_int|1
)paren
suffix:semicolon
op_star
id|stack
op_rshift_assign
l_int|4
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|res
op_assign
(paren
r_int
)paren
(paren
(paren
(paren
op_star
id|stack
op_amp
l_int|63
)paren
op_rshift
l_int|2
)paren
op_plus
l_int|7
)paren
suffix:semicolon
op_star
id|stack
op_rshift_assign
l_int|6
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
id|res
op_assign
(paren
r_int
)paren
(paren
(paren
(paren
op_star
id|stack
op_amp
l_int|255
)paren
op_rshift
l_int|3
)paren
op_plus
l_int|23
)paren
suffix:semicolon
op_star
id|stack
op_rshift_assign
l_int|8
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
id|res
op_assign
(paren
r_int
)paren
(paren
(paren
(paren
op_star
id|stack
op_amp
l_int|1023
)paren
op_rshift
l_int|4
)paren
op_plus
l_int|55
)paren
suffix:semicolon
op_star
id|stack
op_rshift_assign
l_int|10
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|ntfs_error
c_func
(paren
l_string|&quot;Unknown encoding&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_return
id|res
suffix:semicolon
)brace
DECL|function|ntfs_top
r_static
r_inline
r_int
r_int
id|ntfs_top
c_func
(paren
r_void
)paren
(brace
r_return
l_int|14
suffix:semicolon
)brace
DECL|function|ntfs_push
r_static
id|ntfs_u64
id|ntfs_push
c_func
(paren
id|ntfs_u64
id|stack
comma
r_int
id|i
)paren
(brace
r_if
c_cond
(paren
id|i
OL
l_int|7
)paren
r_return
(paren
id|stack
op_lshift
l_int|4
)paren
op_or
(paren
id|i
op_lshift
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
OL
l_int|23
)paren
r_return
(paren
id|stack
op_lshift
l_int|6
)paren
op_or
(paren
(paren
id|i
op_minus
l_int|7
)paren
op_lshift
l_int|2
)paren
op_or
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|i
OL
l_int|55
)paren
r_return
(paren
id|stack
op_lshift
l_int|8
)paren
op_or
(paren
(paren
id|i
op_minus
l_int|23
)paren
op_lshift
l_int|3
)paren
op_or
l_int|3
suffix:semicolon
r_if
c_cond
(paren
id|i
OL
l_int|120
)paren
r_return
(paren
id|stack
op_lshift
l_int|10
)paren
op_or
(paren
(paren
id|i
op_minus
l_int|55
)paren
op_lshift
l_int|4
)paren
op_or
l_int|7
suffix:semicolon
id|ntfs_error
c_func
(paren
l_string|&quot;Too many entries&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_complement
(paren
(paren
id|ntfs_u64
)paren
l_int|0
)paren
suffix:semicolon
)brace
macro_line|#if 0
r_static
r_void
id|ntfs_display_stack
c_func
(paren
id|ntfs_u64
id|stack
)paren
(brace
r_while
c_loop
(paren
op_logical_neg
id|ntfs_is_top
c_func
(paren
id|stack
)paren
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%d &quot;
comma
id|ntfs_pop
c_func
(paren
op_amp
id|stack
)paren
)paren
suffix:semicolon
)brace
id|printf
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* True if the entry points to another block of entries. */
DECL|function|ntfs_entry_has_subnodes
r_static
r_inline
r_int
id|ntfs_entry_has_subnodes
c_func
(paren
r_char
op_star
id|entry
)paren
(brace
r_return
(paren
r_int
)paren
id|NTFS_GETU8
c_func
(paren
id|entry
op_plus
l_int|12
)paren
op_amp
l_int|1
suffix:semicolon
)brace
multiline_comment|/* True if it is not the &squot;end of dir&squot; entry. */
DECL|function|ntfs_entry_is_used
r_static
r_inline
r_int
id|ntfs_entry_is_used
c_func
(paren
r_char
op_star
id|entry
)paren
(brace
r_return
(paren
r_int
)paren
(paren
id|NTFS_GETU8
c_func
(paren
id|entry
op_plus
l_int|12
)paren
op_amp
l_int|2
)paren
op_eq
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Removed RACE for allocating index blocks. But stil not too happy.&n; * There might be more races afterwards. (AIA)&n; */
DECL|function|ntfs_allocate_index_block
r_static
r_int
id|ntfs_allocate_index_block
c_func
(paren
id|ntfs_iterate_s
op_star
id|walk
)paren
(brace
id|ntfs_attribute
op_star
id|allocation
comma
op_star
id|bitmap
op_assign
l_int|0
suffix:semicolon
r_int
id|error
comma
id|size
comma
id|i
comma
id|bit
suffix:semicolon
id|ntfs_u8
op_star
id|bmap
suffix:semicolon
id|ntfs_io
id|io
suffix:semicolon
id|ntfs_volume
op_star
id|vol
op_assign
id|walk-&gt;dir-&gt;vol
suffix:semicolon
multiline_comment|/* Check for allocation attribute. */
id|allocation
op_assign
id|ntfs_find_attr
c_func
(paren
id|walk-&gt;dir
comma
id|vol-&gt;at_index_allocation
comma
id|I30
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|allocation
)paren
(brace
id|ntfs_u8
id|bmp
(braket
l_int|8
)braket
suffix:semicolon
multiline_comment|/* Create index allocation attribute. */
id|error
op_assign
id|ntfs_create_attr
c_func
(paren
id|walk-&gt;dir
comma
id|vol-&gt;at_index_allocation
comma
id|I30
comma
l_int|0
comma
l_int|0
comma
op_amp
id|allocation
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|err_ret
suffix:semicolon
id|ntfs_bzero
c_func
(paren
id|bmp
comma
r_sizeof
(paren
id|bmp
)paren
)paren
suffix:semicolon
id|error
op_assign
id|ntfs_create_attr
c_func
(paren
id|walk-&gt;dir
comma
id|vol-&gt;at_bitmap
comma
id|I30
comma
id|bmp
comma
r_sizeof
(paren
id|bmp
)paren
comma
op_amp
id|bitmap
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|err_ret
suffix:semicolon
)brace
r_else
id|bitmap
op_assign
id|ntfs_find_attr
c_func
(paren
id|walk-&gt;dir
comma
id|vol-&gt;at_bitmap
comma
id|I30
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bitmap
)paren
(brace
id|ntfs_error
c_func
(paren
l_string|&quot;Directory w/o bitmap&bslash;n&quot;
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|err_ret
suffix:semicolon
)brace
id|size
op_assign
id|bitmap-&gt;size
suffix:semicolon
id|bmap
op_assign
id|ntfs_malloc
c_func
(paren
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bmap
)paren
(brace
id|error
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|err_ret
suffix:semicolon
)brace
id|io.fn_put
op_assign
id|ntfs_put
suffix:semicolon
id|io.fn_get
op_assign
id|ntfs_get
suffix:semicolon
id|try_again
suffix:colon
id|io.param
op_assign
id|bmap
suffix:semicolon
id|io.size
op_assign
id|size
suffix:semicolon
id|error
op_assign
id|ntfs_read_attr
c_func
(paren
id|walk-&gt;dir
comma
id|vol-&gt;at_bitmap
comma
id|I30
comma
l_int|0
comma
op_amp
id|io
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_logical_or
(paren
id|io.size
op_ne
id|size
op_logical_and
(paren
id|error
op_assign
op_minus
id|EIO
comma
l_int|1
)paren
)paren
)paren
r_goto
id|err_fb_out
suffix:semicolon
multiline_comment|/* Allocate a bit. */
r_for
c_loop
(paren
id|bit
op_assign
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|size
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|bmap
(braket
id|i
)braket
op_eq
l_int|0xFF
)paren
r_continue
suffix:semicolon
id|bit
op_assign
id|ffz
c_func
(paren
id|bmap
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bit
OL
l_int|8
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_ge
id|size
)paren
(brace
multiline_comment|/* FIXME: Extend bitmap. */
id|error
op_assign
op_minus
id|EOPNOTSUPP
suffix:semicolon
r_goto
id|err_fb_out
suffix:semicolon
)brace
multiline_comment|/* Get the byte containing our bit again, now taking the BKL. */
id|io.param
op_assign
id|bmap
suffix:semicolon
id|io.size
op_assign
l_int|1
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|error
op_assign
id|ntfs_read_attr
c_func
(paren
id|walk-&gt;dir
comma
id|vol-&gt;at_bitmap
comma
id|I30
comma
id|i
comma
op_amp
id|io
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_logical_or
(paren
id|io.size
op_ne
l_int|1
op_logical_and
(paren
id|error
op_assign
op_minus
id|EIO
comma
l_int|1
)paren
)paren
)paren
r_goto
id|err_unl_out
suffix:semicolon
r_if
c_cond
(paren
id|ntfs_test_and_set_bit
c_func
(paren
id|bmap
comma
id|bit
)paren
)paren
(brace
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Give other process(es) a chance to finish. */
id|schedule
c_func
(paren
)paren
suffix:semicolon
r_goto
id|try_again
suffix:semicolon
)brace
id|walk-&gt;newblock
op_assign
(paren
id|i
op_star
l_int|8
op_plus
id|bit
)paren
op_star
id|walk-&gt;dir-&gt;u.index.clusters_per_record
suffix:semicolon
id|io.param
op_assign
id|bmap
suffix:semicolon
id|error
op_assign
id|ntfs_write_attr
c_func
(paren
id|walk-&gt;dir
comma
id|vol-&gt;at_bitmap
comma
id|I30
comma
id|i
comma
op_amp
id|io
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_logical_or
(paren
id|io.size
op_ne
id|size
op_logical_and
(paren
id|error
op_assign
op_minus
id|EIO
comma
l_int|1
)paren
)paren
)paren
r_goto
id|err_unl_out
suffix:semicolon
multiline_comment|/* Change inode on disk, required when bitmap is resident. */
id|error
op_assign
id|ntfs_update_inode
c_func
(paren
id|walk-&gt;dir
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|err_unl_out
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
id|ntfs_free
c_func
(paren
id|bmap
)paren
suffix:semicolon
multiline_comment|/* Check whether record is out of allocated range. */
id|size
op_assign
id|allocation-&gt;size
suffix:semicolon
r_if
c_cond
(paren
id|walk-&gt;newblock
op_star
id|vol-&gt;cluster_size
op_ge
id|size
)paren
(brace
multiline_comment|/* Build index record. */
r_int
id|hsize
suffix:semicolon
r_int
id|s1
op_assign
id|walk-&gt;dir-&gt;u.index.recordsize
suffix:semicolon
r_int
id|nr_fix
op_assign
(paren
id|s1
op_rshift
id|vol-&gt;sector_size
)paren
op_plus
l_int|1
suffix:semicolon
r_char
op_star
id|record
op_assign
id|ntfs_malloc
c_func
(paren
id|s1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|record
)paren
(brace
id|error
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|err_ret
suffix:semicolon
)brace
id|ntfs_bzero
c_func
(paren
id|record
comma
id|s1
)paren
suffix:semicolon
multiline_comment|/* Magic */
id|ntfs_memcpy
c_func
(paren
id|record
comma
l_string|&quot;INDX&quot;
comma
l_int|4
)paren
suffix:semicolon
multiline_comment|/* Offset to fixups */
id|NTFS_PUTU16
c_func
(paren
id|record
op_plus
l_int|4
comma
l_int|0x28
)paren
suffix:semicolon
multiline_comment|/* Number of fixups. */
id|NTFS_PUTU16
c_func
(paren
id|record
op_plus
l_int|6
comma
id|nr_fix
)paren
suffix:semicolon
multiline_comment|/* Log file sequence number - We don&squot;t do journalling so we&n;&t;&t; * just set it to zero which should be the Right Thing. (AIA) */
id|NTFS_PUTU64
c_func
(paren
id|record
op_plus
l_int|8
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* VCN of buffer */
id|NTFS_PUTU64
c_func
(paren
id|record
op_plus
l_int|0x10
comma
id|walk-&gt;newblock
)paren
suffix:semicolon
multiline_comment|/* Header size. */
id|hsize
op_assign
l_int|0x10
op_plus
l_int|2
op_star
id|nr_fix
suffix:semicolon
id|hsize
op_assign
(paren
id|hsize
op_plus
l_int|7
)paren
op_amp
op_complement
l_int|7
suffix:semicolon
multiline_comment|/* Align. */
id|NTFS_PUTU16
c_func
(paren
id|record
op_plus
l_int|0x18
comma
id|hsize
)paren
suffix:semicolon
multiline_comment|/* Total size of record. */
id|NTFS_PUTU32
c_func
(paren
id|record
op_plus
l_int|0x20
comma
id|s1
op_minus
l_int|0x18
)paren
suffix:semicolon
multiline_comment|/* Writing the data will extend the attribute. */
id|io.param
op_assign
id|record
suffix:semicolon
id|io.size
op_assign
id|s1
suffix:semicolon
id|io.do_read
op_assign
l_int|0
suffix:semicolon
id|error
op_assign
id|ntfs_readwrite_attr
c_func
(paren
id|walk-&gt;dir
comma
id|allocation
comma
id|size
comma
op_amp
id|io
)paren
suffix:semicolon
id|ntfs_free
c_func
(paren
id|record
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_logical_or
(paren
id|io.size
op_ne
id|s1
op_logical_and
(paren
id|error
op_assign
op_minus
id|EIO
comma
l_int|1
)paren
)paren
)paren
r_goto
id|err_ret
suffix:semicolon
id|error
op_assign
id|ntfs_update_inode
c_func
(paren
id|walk-&gt;dir
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|err_ret
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
id|err_unl_out
suffix:colon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
id|err_fb_out
suffix:colon
id|ntfs_free
c_func
(paren
id|bmap
)paren
suffix:semicolon
id|err_ret
suffix:colon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/* Write an index block (root or allocation) back to storage.&n; * Used is the total number of bytes in buf, including all headers. */
DECL|function|ntfs_index_writeback
r_static
r_int
id|ntfs_index_writeback
c_func
(paren
id|ntfs_iterate_s
op_star
id|walk
comma
id|ntfs_u8
op_star
id|buf
comma
r_int
id|block
comma
r_int
id|used
)paren
(brace
id|ntfs_io
id|io
suffix:semicolon
r_int
id|error
suffix:semicolon
id|ntfs_attribute
op_star
id|a
suffix:semicolon
id|ntfs_volume
op_star
id|vol
op_assign
id|walk-&gt;dir-&gt;vol
suffix:semicolon
id|io.fn_put
op_assign
l_int|0
suffix:semicolon
id|io.fn_get
op_assign
id|ntfs_get
suffix:semicolon
id|io.param
op_assign
id|buf
suffix:semicolon
r_if
c_cond
(paren
id|block
op_eq
op_minus
l_int|1
)paren
(brace
multiline_comment|/* Index root. */
id|NTFS_PUTU16
c_func
(paren
id|buf
op_plus
l_int|0x14
comma
id|used
op_minus
l_int|0x10
)paren
suffix:semicolon
multiline_comment|/* 0x18 is a copy thereof. */
id|NTFS_PUTU16
c_func
(paren
id|buf
op_plus
l_int|0x18
comma
id|used
op_minus
l_int|0x10
)paren
suffix:semicolon
id|io.size
op_assign
id|used
suffix:semicolon
id|error
op_assign
id|ntfs_write_attr
c_func
(paren
id|walk-&gt;dir
comma
id|vol-&gt;at_index_root
comma
id|I30
comma
l_int|0
comma
op_amp
id|io
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_logical_or
(paren
id|io.size
op_ne
id|used
op_logical_and
(paren
id|error
op_assign
op_minus
id|EIO
comma
l_int|1
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
multiline_comment|/* Shrink if necessary. */
id|a
op_assign
id|ntfs_find_attr
c_func
(paren
id|walk-&gt;dir
comma
id|vol-&gt;at_index_root
comma
id|I30
)paren
suffix:semicolon
id|ntfs_resize_attr
c_func
(paren
id|walk-&gt;dir
comma
id|a
comma
id|used
)paren
suffix:semicolon
)brace
r_else
(brace
id|NTFS_PUTU16
c_func
(paren
id|buf
op_plus
l_int|0x1C
comma
id|used
op_minus
l_int|0x18
)paren
suffix:semicolon
id|ntfs_insert_fixups
c_func
(paren
id|buf
comma
id|vol-&gt;sector_size
)paren
suffix:semicolon
id|io.size
op_assign
id|walk-&gt;dir-&gt;u.index.recordsize
suffix:semicolon
id|error
op_assign
id|ntfs_write_attr
c_func
(paren
id|walk-&gt;dir
comma
id|vol-&gt;at_index_allocation
comma
id|I30
comma
(paren
id|__s64
)paren
id|block
op_lshift
id|vol-&gt;cluster_size_bits
comma
op_amp
id|io
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_logical_or
(paren
id|io.size
op_ne
id|walk-&gt;dir-&gt;u.index.recordsize
op_logical_and
(paren
id|error
op_assign
op_minus
id|EIO
comma
l_int|1
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ntfs_split_record
r_static
r_int
id|ntfs_split_record
c_func
(paren
id|ntfs_iterate_s
op_star
id|walk
comma
r_char
op_star
id|start
comma
r_int
id|bsize
comma
r_int
id|usize
)paren
(brace
r_char
op_star
id|entry
comma
op_star
id|prev
suffix:semicolon
id|ntfs_u8
op_star
id|newbuf
op_assign
l_int|0
comma
op_star
id|middle
op_assign
l_int|0
suffix:semicolon
r_int
id|error
comma
id|othersize
comma
id|mlen
suffix:semicolon
id|ntfs_io
id|io
suffix:semicolon
id|ntfs_volume
op_star
id|vol
op_assign
id|walk-&gt;dir-&gt;vol
suffix:semicolon
r_int
id|oldblock
suffix:semicolon
id|error
op_assign
id|ntfs_allocate_index_block
c_func
(paren
id|walk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
multiline_comment|/* This should not happen. */
r_if
c_cond
(paren
id|walk-&gt;block
op_eq
op_minus
l_int|1
)paren
(brace
id|ntfs_error
c_func
(paren
l_string|&quot;Trying to split root&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
id|entry
op_assign
id|start
op_plus
id|NTFS_GETU16
c_func
(paren
id|start
op_plus
l_int|0x18
)paren
op_plus
l_int|0x18
suffix:semicolon
r_for
c_loop
(paren
id|prev
op_assign
id|entry
suffix:semicolon
id|entry
op_minus
id|start
OL
id|usize
op_div
l_int|2
suffix:semicolon
id|entry
op_add_assign
id|NTFS_GETU16
c_func
(paren
id|entry
op_plus
l_int|8
)paren
)paren
id|prev
op_assign
id|entry
suffix:semicolon
id|newbuf
op_assign
id|ntfs_malloc
c_func
(paren
id|vol-&gt;index_record_size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|newbuf
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|io.fn_put
op_assign
id|ntfs_put
suffix:semicolon
id|io.fn_get
op_assign
id|ntfs_get
suffix:semicolon
id|io.param
op_assign
id|newbuf
suffix:semicolon
id|io.size
op_assign
id|vol-&gt;index_record_size
suffix:semicolon
multiline_comment|/* Read in old header. FIXME: Reading everything is overkill. */
id|error
op_assign
id|ntfs_read_attr
c_func
(paren
id|walk-&gt;dir
comma
id|vol-&gt;at_index_allocation
comma
id|I30
comma
(paren
id|__s64
)paren
id|walk-&gt;newblock
op_lshift
id|vol-&gt;cluster_size_bits
comma
op_amp
id|io
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|io.size
op_ne
id|vol-&gt;index_record_size
)paren
(brace
id|error
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* FIXME: Adjust header. */
multiline_comment|/* Copy everything from entry to new block. */
id|othersize
op_assign
id|usize
op_minus
(paren
id|entry
op_minus
id|start
)paren
suffix:semicolon
id|ntfs_memcpy
c_func
(paren
id|newbuf
op_plus
id|NTFS_GETU16
c_func
(paren
id|newbuf
op_plus
l_int|0x18
)paren
op_plus
l_int|0x18
comma
id|entry
comma
id|othersize
)paren
suffix:semicolon
multiline_comment|/* Copy flags. */
id|NTFS_PUTU32
c_func
(paren
id|newbuf
op_plus
l_int|0x24
comma
id|NTFS_GETU32
c_func
(paren
id|start
op_plus
l_int|0x24
)paren
)paren
suffix:semicolon
id|error
op_assign
id|ntfs_index_writeback
c_func
(paren
id|walk
comma
id|newbuf
comma
id|walk-&gt;newblock
comma
id|othersize
op_plus
id|NTFS_GETU16
c_func
(paren
id|newbuf
op_plus
l_int|0x18
)paren
op_plus
l_int|0x18
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* Move prev to walk. */
id|mlen
op_assign
id|NTFS_GETU16
c_func
(paren
id|prev
op_plus
l_int|0x8
)paren
suffix:semicolon
multiline_comment|/* Remember old child node. */
r_if
c_cond
(paren
id|ntfs_entry_has_subnodes
c_func
(paren
id|prev
)paren
)paren
id|oldblock
op_assign
id|NTFS_GETU32
c_func
(paren
id|prev
op_plus
id|mlen
op_minus
l_int|8
)paren
suffix:semicolon
r_else
id|oldblock
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* Allow for pointer to subnode. */
id|middle
op_assign
id|ntfs_malloc
c_func
(paren
id|ntfs_entry_has_subnodes
c_func
(paren
id|prev
)paren
ques
c_cond
id|mlen
suffix:colon
id|mlen
op_plus
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|middle
)paren
(brace
id|error
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|ntfs_memcpy
c_func
(paren
id|middle
comma
id|prev
comma
id|mlen
)paren
suffix:semicolon
multiline_comment|/* Set has_subnodes flag. */
id|NTFS_PUTU8
c_func
(paren
id|middle
op_plus
l_int|0xC
comma
id|NTFS_GETU8
c_func
(paren
id|middle
op_plus
l_int|0xC
)paren
op_or
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Middle entry points to block, parent entry will point to newblock. */
id|NTFS_PUTU64
c_func
(paren
id|middle
op_plus
id|mlen
op_minus
l_int|8
comma
id|walk-&gt;block
)paren
suffix:semicolon
r_if
c_cond
(paren
id|walk-&gt;new_entry
)paren
id|ntfs_error
c_func
(paren
l_string|&quot;Entry not reset&quot;
)paren
suffix:semicolon
id|walk-&gt;new_entry
op_assign
id|middle
suffix:semicolon
id|walk-&gt;u.flags
op_or_assign
id|ITERATE_SPLIT_DONE
suffix:semicolon
multiline_comment|/* Terminate old block. */
id|othersize
op_assign
id|usize
op_minus
(paren
id|prev
op_minus
id|start
)paren
suffix:semicolon
id|NTFS_PUTU64
c_func
(paren
id|prev
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|oldblock
op_eq
op_minus
l_int|1
)paren
(brace
id|NTFS_PUTU32
c_func
(paren
id|prev
op_plus
l_int|8
comma
l_int|0x10
)paren
suffix:semicolon
id|NTFS_PUTU32
c_func
(paren
id|prev
op_plus
l_int|0xC
comma
l_int|2
)paren
suffix:semicolon
id|othersize
op_add_assign
l_int|0x10
suffix:semicolon
)brace
r_else
(brace
id|NTFS_PUTU32
c_func
(paren
id|prev
op_plus
l_int|8
comma
l_int|0x18
)paren
suffix:semicolon
id|NTFS_PUTU32
c_func
(paren
id|prev
op_plus
l_int|0xC
comma
l_int|3
)paren
suffix:semicolon
id|NTFS_PUTU64
c_func
(paren
id|prev
op_plus
l_int|0x10
comma
id|oldblock
)paren
suffix:semicolon
id|othersize
op_add_assign
l_int|0x18
suffix:semicolon
)brace
multiline_comment|/* Write back original block. */
id|error
op_assign
id|ntfs_index_writeback
c_func
(paren
id|walk
comma
id|start
comma
id|walk-&gt;block
comma
id|othersize
)paren
suffix:semicolon
id|out
suffix:colon
r_if
c_cond
(paren
id|newbuf
)paren
id|ntfs_free
c_func
(paren
id|newbuf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|middle
)paren
id|ntfs_free
c_func
(paren
id|middle
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
DECL|function|ntfs_dir_insert
r_static
r_int
id|ntfs_dir_insert
c_func
(paren
id|ntfs_iterate_s
op_star
id|walk
comma
r_char
op_star
id|start
comma
r_char
op_star
id|entry
)paren
(brace
r_int
id|blocksize
comma
id|usedsize
comma
id|error
comma
id|offset
suffix:semicolon
r_int
id|do_split
op_assign
l_int|0
suffix:semicolon
id|offset
op_assign
id|entry
op_minus
id|start
suffix:semicolon
r_if
c_cond
(paren
id|walk-&gt;block
op_eq
op_minus
l_int|1
)paren
(brace
multiline_comment|/* index root */
id|blocksize
op_assign
id|walk-&gt;dir-&gt;vol-&gt;mft_record_size
suffix:semicolon
id|usedsize
op_assign
id|NTFS_GETU16
c_func
(paren
id|start
op_plus
l_int|0x14
)paren
op_plus
l_int|0x10
suffix:semicolon
)brace
r_else
(brace
id|blocksize
op_assign
id|walk-&gt;dir-&gt;u.index.recordsize
suffix:semicolon
id|usedsize
op_assign
id|NTFS_GETU16
c_func
(paren
id|start
op_plus
l_int|0x1C
)paren
op_plus
l_int|0x18
suffix:semicolon
)brace
r_if
c_cond
(paren
id|usedsize
op_plus
id|walk-&gt;new_entry_size
OG
id|blocksize
)paren
(brace
r_char
op_star
id|s1
op_assign
id|ntfs_malloc
c_func
(paren
id|blocksize
op_plus
id|walk-&gt;new_entry_size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|s1
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|ntfs_memcpy
c_func
(paren
id|s1
comma
id|start
comma
id|usedsize
)paren
suffix:semicolon
id|do_split
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Adjust entry to s1. */
id|entry
op_assign
id|s1
op_plus
(paren
id|entry
op_minus
id|start
)paren
suffix:semicolon
id|start
op_assign
id|s1
suffix:semicolon
)brace
id|ntfs_memmove
c_func
(paren
id|entry
op_plus
id|walk-&gt;new_entry_size
comma
id|entry
comma
id|usedsize
op_minus
id|offset
)paren
suffix:semicolon
id|ntfs_memcpy
c_func
(paren
id|entry
comma
id|walk-&gt;new_entry
comma
id|walk-&gt;new_entry_size
)paren
suffix:semicolon
id|usedsize
op_add_assign
id|walk-&gt;new_entry_size
suffix:semicolon
id|ntfs_free
c_func
(paren
id|walk-&gt;new_entry
)paren
suffix:semicolon
id|walk-&gt;new_entry
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|do_split
)paren
(brace
id|error
op_assign
id|ntfs_split_record
c_func
(paren
id|walk
comma
id|start
comma
id|blocksize
comma
id|usedsize
)paren
suffix:semicolon
id|ntfs_free
c_func
(paren
id|start
)paren
suffix:semicolon
)brace
r_else
(brace
id|error
op_assign
id|ntfs_index_writeback
c_func
(paren
id|walk
comma
id|start
comma
id|walk-&gt;block
comma
id|usedsize
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Try to split INDEX_ROOT attributes. Return -E2BIG if nothing changed. */
DECL|function|ntfs_split_indexroot
r_int
id|ntfs_split_indexroot
c_func
(paren
id|ntfs_inode
op_star
id|ino
)paren
(brace
id|ntfs_attribute
op_star
id|ra
suffix:semicolon
id|ntfs_u8
op_star
id|root
op_assign
l_int|0
comma
op_star
id|index
op_assign
l_int|0
suffix:semicolon
id|ntfs_io
id|io
suffix:semicolon
r_int
id|error
comma
id|off
comma
id|i
comma
id|bsize
comma
id|isize
suffix:semicolon
id|ntfs_iterate_s
id|walk
suffix:semicolon
id|ra
op_assign
id|ntfs_find_attr
c_func
(paren
id|ino
comma
id|ino-&gt;vol-&gt;at_index_root
comma
id|I30
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ra
)paren
r_return
op_minus
id|E2BIG
suffix:semicolon
id|bsize
op_assign
id|ino-&gt;vol-&gt;mft_record_size
suffix:semicolon
id|root
op_assign
id|ntfs_malloc
c_func
(paren
id|bsize
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|root
)paren
r_return
op_minus
id|E2BIG
suffix:semicolon
id|io.fn_put
op_assign
id|ntfs_put
suffix:semicolon
id|io.param
op_assign
id|root
suffix:semicolon
id|io.size
op_assign
id|bsize
suffix:semicolon
id|error
op_assign
id|ntfs_read_attr
c_func
(paren
id|ino
comma
id|ino-&gt;vol-&gt;at_index_root
comma
id|I30
comma
l_int|0
comma
op_amp
id|io
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|out
suffix:semicolon
id|off
op_assign
l_int|0x20
suffix:semicolon
multiline_comment|/* Count number of entries. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|ntfs_entry_is_used
c_func
(paren
id|root
op_plus
id|off
)paren
suffix:semicolon
id|i
op_increment
)paren
id|off
op_add_assign
id|NTFS_GETU16
c_func
(paren
id|root
op_plus
id|off
op_plus
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_le
l_int|2
)paren
(brace
multiline_comment|/* We don&squot;t split small index roots. */
id|error
op_assign
op_minus
id|E2BIG
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|index
op_assign
id|ntfs_malloc
c_func
(paren
id|ino-&gt;vol-&gt;index_record_size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|index
)paren
(brace
id|error
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|walk.dir
op_assign
id|ino
suffix:semicolon
id|walk.block
op_assign
op_minus
l_int|1
suffix:semicolon
id|walk.result
op_assign
id|walk.new_entry
op_assign
l_int|0
suffix:semicolon
id|walk.name
op_assign
l_int|0
suffix:semicolon
id|error
op_assign
id|ntfs_allocate_index_block
c_func
(paren
op_amp
id|walk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* Write old root to new index block. */
id|io.param
op_assign
id|index
suffix:semicolon
id|io.size
op_assign
id|ino-&gt;vol-&gt;index_record_size
suffix:semicolon
id|error
op_assign
id|ntfs_read_attr
c_func
(paren
id|ino
comma
id|ino-&gt;vol-&gt;at_index_allocation
comma
id|I30
comma
(paren
id|__s64
)paren
id|walk.newblock
op_lshift
id|ino-&gt;vol-&gt;cluster_size_bits
comma
op_amp
id|io
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|out
suffix:semicolon
id|isize
op_assign
id|NTFS_GETU16
c_func
(paren
id|root
op_plus
l_int|0x18
)paren
op_minus
l_int|0x10
suffix:semicolon
id|ntfs_memcpy
c_func
(paren
id|index
op_plus
id|NTFS_GETU16
c_func
(paren
id|index
op_plus
l_int|0x18
)paren
op_plus
l_int|0x18
comma
id|root
op_plus
l_int|0x20
comma
id|isize
)paren
suffix:semicolon
multiline_comment|/* Copy flags. */
id|NTFS_PUTU32
c_func
(paren
id|index
op_plus
l_int|0x24
comma
id|NTFS_GETU32
c_func
(paren
id|root
op_plus
l_int|0x1C
)paren
)paren
suffix:semicolon
id|error
op_assign
id|ntfs_index_writeback
c_func
(paren
op_amp
id|walk
comma
id|index
comma
id|walk.newblock
comma
id|isize
op_plus
id|NTFS_GETU16
c_func
(paren
id|index
op_plus
l_int|0x18
)paren
op_plus
l_int|0x18
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* Mark root as split. */
id|NTFS_PUTU32
c_func
(paren
id|root
op_plus
l_int|0x1C
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Truncate index root. */
id|NTFS_PUTU64
c_func
(paren
id|root
op_plus
l_int|0x20
comma
l_int|0
)paren
suffix:semicolon
id|NTFS_PUTU32
c_func
(paren
id|root
op_plus
l_int|0x28
comma
l_int|0x18
)paren
suffix:semicolon
id|NTFS_PUTU32
c_func
(paren
id|root
op_plus
l_int|0x2C
comma
l_int|3
)paren
suffix:semicolon
id|NTFS_PUTU64
c_func
(paren
id|root
op_plus
l_int|0x30
comma
id|walk.newblock
)paren
suffix:semicolon
id|error
op_assign
id|ntfs_index_writeback
c_func
(paren
op_amp
id|walk
comma
id|root
comma
op_minus
l_int|1
comma
l_int|0x38
)paren
suffix:semicolon
id|out
suffix:colon
id|ntfs_free
c_func
(paren
id|root
)paren
suffix:semicolon
id|ntfs_free
c_func
(paren
id|index
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/* The entry has been found. Copy the result in the caller&squot;s buffer */
DECL|function|ntfs_copyresult
r_static
r_int
id|ntfs_copyresult
c_func
(paren
r_char
op_star
id|dest
comma
r_char
op_star
id|source
)paren
(brace
r_int
id|length
op_assign
id|NTFS_GETU16
c_func
(paren
id|source
op_plus
l_int|8
)paren
suffix:semicolon
id|ntfs_memcpy
c_func
(paren
id|dest
comma
id|source
comma
id|length
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Use $UpCase some day. */
DECL|function|ntfs_my_toupper
r_static
r_inline
r_int
r_int
id|ntfs_my_toupper
c_func
(paren
id|ntfs_volume
op_star
id|vol
comma
id|ntfs_u16
id|x
)paren
(brace
multiline_comment|/* We should read any pending rest of $UpCase here. */
r_if
c_cond
(paren
id|x
op_ge
id|vol-&gt;upcase_length
)paren
r_return
id|x
suffix:semicolon
r_return
id|vol-&gt;upcase
(braket
id|x
)braket
suffix:semicolon
)brace
multiline_comment|/* Everything passed in walk and entry. */
DECL|function|ntfs_my_strcmp
r_static
r_int
id|ntfs_my_strcmp
c_func
(paren
id|ntfs_iterate_s
op_star
id|walk
comma
r_const
r_int
r_char
op_star
id|entry
)paren
(brace
r_int
id|lu
op_assign
op_star
(paren
id|entry
op_plus
l_int|0x50
)paren
suffix:semicolon
r_int
id|i
suffix:semicolon
id|ntfs_u16
op_star
id|name
op_assign
(paren
id|ntfs_u16
op_star
)paren
(paren
id|entry
op_plus
l_int|0x52
)paren
suffix:semicolon
id|ntfs_volume
op_star
id|vol
op_assign
id|walk-&gt;dir-&gt;vol
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|lu
op_logical_and
id|i
OL
id|walk-&gt;namelen
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|ntfs_my_toupper
c_func
(paren
id|vol
comma
id|NTFS_GETU16
c_func
(paren
id|name
op_plus
id|i
)paren
)paren
op_ne
id|ntfs_my_toupper
c_func
(paren
id|vol
comma
id|NTFS_GETU16
c_func
(paren
id|walk-&gt;name
op_plus
id|i
)paren
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
id|lu
op_logical_and
id|i
op_eq
id|walk-&gt;namelen
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
id|lu
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
id|walk-&gt;namelen
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|ntfs_my_toupper
c_func
(paren
id|vol
comma
id|NTFS_GETU16
c_func
(paren
id|name
op_plus
id|i
)paren
)paren
OL
id|ntfs_my_toupper
c_func
(paren
id|vol
comma
id|NTFS_GETU16
c_func
(paren
id|walk-&gt;name
op_plus
id|i
)paren
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Necessary forward declaration. */
r_static
r_int
id|ntfs_getdir_iterate
c_func
(paren
id|ntfs_iterate_s
op_star
id|walk
comma
r_char
op_star
id|start
comma
r_char
op_star
id|entry
)paren
suffix:semicolon
multiline_comment|/* Parse a block of entries. Load the block, fix it up, and iterate over the&n; * entries. The block is given as virtual cluster number. */
DECL|function|ntfs_getdir_record
r_static
r_int
id|ntfs_getdir_record
c_func
(paren
id|ntfs_iterate_s
op_star
id|walk
comma
r_int
id|block
)paren
(brace
r_int
id|length
op_assign
id|walk-&gt;dir-&gt;u.index.recordsize
suffix:semicolon
r_char
op_star
id|record
op_assign
(paren
r_char
op_star
)paren
id|ntfs_malloc
c_func
(paren
id|length
)paren
suffix:semicolon
r_char
op_star
id|offset
suffix:semicolon
r_int
id|retval
comma
id|error
suffix:semicolon
r_int
id|oldblock
suffix:semicolon
id|ntfs_io
id|io
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|record
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|io.fn_put
op_assign
id|ntfs_put
suffix:semicolon
id|io.param
op_assign
id|record
suffix:semicolon
id|io.size
op_assign
id|length
suffix:semicolon
multiline_comment|/* Read the block from the index allocation attribute. */
id|error
op_assign
id|ntfs_read_attr
c_func
(paren
id|walk-&gt;dir
comma
id|walk-&gt;dir-&gt;vol-&gt;at_index_allocation
comma
id|I30
comma
(paren
id|__s64
)paren
id|block
op_lshift
id|walk-&gt;dir-&gt;vol-&gt;cluster_size_bits
comma
op_amp
id|io
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_logical_or
id|io.size
op_ne
id|length
)paren
(brace
id|ntfs_error
c_func
(paren
l_string|&quot;read failed&bslash;n&quot;
)paren
suffix:semicolon
id|ntfs_free
c_func
(paren
id|record
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|ntfs_check_index_record
c_func
(paren
id|walk-&gt;dir
comma
id|record
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
l_string|&quot;%x is not an index record&bslash;n&quot;
comma
id|block
)paren
suffix:semicolon
id|ntfs_free
c_func
(paren
id|record
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|offset
op_assign
id|record
op_plus
id|NTFS_GETU16
c_func
(paren
id|record
op_plus
l_int|0x18
)paren
op_plus
l_int|0x18
suffix:semicolon
id|oldblock
op_assign
id|walk-&gt;block
suffix:semicolon
id|walk-&gt;block
op_assign
id|block
suffix:semicolon
id|retval
op_assign
id|ntfs_getdir_iterate
c_func
(paren
id|walk
comma
id|record
comma
id|offset
)paren
suffix:semicolon
id|walk-&gt;block
op_assign
id|oldblock
suffix:semicolon
id|ntfs_free
c_func
(paren
id|record
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/* Go down to the next block of entries. These collate before the current&n; * entry. */
DECL|function|ntfs_descend
r_static
r_int
id|ntfs_descend
c_func
(paren
id|ntfs_iterate_s
op_star
id|walk
comma
id|ntfs_u8
op_star
id|start
comma
id|ntfs_u8
op_star
id|entry
)paren
(brace
r_int
id|length
op_assign
id|NTFS_GETU16
c_func
(paren
id|entry
op_plus
l_int|8
)paren
suffix:semicolon
r_int
id|nextblock
op_assign
id|NTFS_GETU32
c_func
(paren
id|entry
op_plus
id|length
op_minus
l_int|8
)paren
suffix:semicolon
r_int
id|error
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ntfs_entry_has_subnodes
c_func
(paren
id|entry
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
l_string|&quot;illegal ntfs_descend call&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|error
op_assign
id|ntfs_getdir_record
c_func
(paren
id|walk
comma
id|nextblock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
op_logical_and
id|walk-&gt;type
op_eq
id|DIR_INSERT
op_logical_and
(paren
id|walk-&gt;u.flags
op_amp
id|ITERATE_SPLIT_DONE
)paren
)paren
(brace
multiline_comment|/* Split has occurred. Adjust entry, insert new_entry. */
id|NTFS_PUTU32
c_func
(paren
id|entry
op_plus
id|length
op_minus
l_int|8
comma
id|walk-&gt;newblock
)paren
suffix:semicolon
multiline_comment|/* Reset flags, as the current block might be split again. */
id|walk-&gt;u.flags
op_and_assign
op_complement
id|ITERATE_SPLIT_DONE
suffix:semicolon
id|error
op_assign
id|ntfs_dir_insert
c_func
(paren
id|walk
comma
id|start
comma
id|entry
)paren
suffix:semicolon
)brace
r_return
id|error
suffix:semicolon
)brace
DECL|function|ntfs_getdir_iterate_byposition
r_static
r_int
id|ntfs_getdir_iterate_byposition
c_func
(paren
id|ntfs_iterate_s
op_star
id|walk
comma
r_char
op_star
id|start
comma
r_char
op_star
id|entry
)paren
(brace
r_int
id|retval
op_assign
l_int|0
suffix:semicolon
r_int
id|curpos
op_assign
l_int|0
comma
id|destpos
op_assign
l_int|0
suffix:semicolon
r_int
id|length
suffix:semicolon
r_if
c_cond
(paren
id|walk-&gt;u.pos
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|ntfs_is_top
c_func
(paren
id|walk-&gt;u.pos
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|destpos
op_assign
id|ntfs_pop
c_func
(paren
op_amp
id|walk-&gt;u.pos
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|walk-&gt;u.pos
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|ntfs_entry_has_subnodes
c_func
(paren
id|entry
)paren
)paren
id|ntfs_descend
c_func
(paren
id|walk
comma
id|start
comma
id|entry
)paren
suffix:semicolon
r_else
id|walk-&gt;u.pos
op_assign
id|ntfs_top
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ntfs_is_top
c_func
(paren
id|walk-&gt;u.pos
)paren
op_logical_and
op_logical_neg
id|ntfs_entry_is_used
c_func
(paren
id|entry
)paren
)paren
r_return
l_int|1
suffix:semicolon
id|walk-&gt;u.pos
op_assign
id|ntfs_push
c_func
(paren
id|walk-&gt;u.pos
comma
id|curpos
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|curpos
op_eq
id|destpos
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ntfs_is_top
c_func
(paren
id|walk-&gt;u.pos
)paren
op_logical_and
id|ntfs_entry_has_subnodes
c_func
(paren
id|entry
)paren
)paren
(brace
id|retval
op_assign
id|ntfs_descend
c_func
(paren
id|walk
comma
id|start
comma
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
(brace
id|walk-&gt;u.pos
op_assign
id|ntfs_push
c_func
(paren
id|walk-&gt;u.pos
comma
id|curpos
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|ntfs_entry_is_used
c_func
(paren
id|entry
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|walk-&gt;u.pos
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ntfs_entry_is_used
c_func
(paren
id|entry
)paren
)paren
(brace
id|retval
op_assign
id|ntfs_copyresult
c_func
(paren
id|walk-&gt;result
comma
id|entry
)paren
suffix:semicolon
id|walk-&gt;u.pos
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|walk-&gt;u.pos
op_assign
id|ntfs_top
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
id|curpos
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ntfs_entry_is_used
c_func
(paren
id|entry
)paren
)paren
r_break
suffix:semicolon
id|length
op_assign
id|NTFS_GETU16
c_func
(paren
id|entry
op_plus
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|length
)paren
(brace
id|ntfs_error
c_func
(paren
l_string|&quot;infinite loop&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|entry
op_add_assign
id|length
suffix:semicolon
)brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Iterate over a list of entries, either from an index block, or from the&n; * index root.&n; * If searching BY_POSITION, pop the top index from the position. If the&n; * position stack is empty then, return the item at the index and set the&n; * position to the next entry. If the position stack is not empty, &n; * recursively proceed for subnodes. If the entry at the position is the&n; * &squot;end of dir&squot; entry, return &squot;not found&squot; and the empty stack.&n; * If searching BY_NAME, walk through the items until found or until&n; * one item is collated after the requested item. In the former case, return&n; * the result. In the latter case, recursively proceed to the subnodes.&n; * If &squot;end of dir&squot; is reached, the name is not in the directory */
DECL|function|ntfs_getdir_iterate
r_static
r_int
id|ntfs_getdir_iterate
c_func
(paren
id|ntfs_iterate_s
op_star
id|walk
comma
r_char
op_star
id|start
comma
r_char
op_star
id|entry
)paren
(brace
r_int
id|length
suffix:semicolon
r_int
id|cmp
suffix:semicolon
r_if
c_cond
(paren
id|walk-&gt;type
op_eq
id|BY_POSITION
)paren
r_return
id|ntfs_getdir_iterate_byposition
c_func
(paren
id|walk
comma
id|start
comma
id|entry
)paren
suffix:semicolon
r_do
(brace
multiline_comment|/* If the current entry is a real one, compare with the&n;&t;&t; * requested item. If the current entry is the last item, it&n;&t;&t; * is always larger than the requested item. */
id|cmp
op_assign
id|ntfs_entry_is_used
c_func
(paren
id|entry
)paren
ques
c_cond
id|ntfs_my_strcmp
c_func
(paren
id|walk
comma
id|entry
)paren
suffix:colon
op_minus
l_int|1
suffix:semicolon
r_switch
c_cond
(paren
id|walk-&gt;type
)paren
(brace
r_case
id|BY_NAME
suffix:colon
r_switch
c_cond
(paren
id|cmp
)paren
(brace
r_case
op_minus
l_int|1
suffix:colon
r_return
id|ntfs_entry_has_subnodes
c_func
(paren
id|entry
)paren
ques
c_cond
id|ntfs_descend
c_func
(paren
id|walk
comma
id|start
comma
id|entry
)paren
suffix:colon
l_int|0
suffix:semicolon
r_case
l_int|0
suffix:colon
r_return
id|ntfs_copyresult
c_func
(paren
id|walk-&gt;result
comma
id|entry
)paren
suffix:semicolon
r_case
l_int|1
suffix:colon
r_break
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|DIR_INSERT
suffix:colon
r_switch
c_cond
(paren
id|cmp
)paren
(brace
r_case
op_minus
l_int|1
suffix:colon
r_return
id|ntfs_entry_has_subnodes
c_func
(paren
id|entry
)paren
ques
c_cond
id|ntfs_descend
c_func
(paren
id|walk
comma
id|start
comma
id|entry
)paren
suffix:colon
id|ntfs_dir_insert
c_func
(paren
id|walk
comma
id|start
comma
id|entry
)paren
suffix:semicolon
r_case
l_int|0
suffix:colon
r_return
op_minus
id|EEXIST
suffix:semicolon
r_case
l_int|1
suffix:colon
r_break
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|ntfs_error
c_func
(paren
l_string|&quot;TODO&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* FIXME: ? */
)brace
r_if
c_cond
(paren
op_logical_neg
id|ntfs_entry_is_used
c_func
(paren
id|entry
)paren
)paren
r_break
suffix:semicolon
id|length
op_assign
id|NTFS_GETU16
c_func
(paren
id|entry
op_plus
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|length
)paren
(brace
id|ntfs_error
c_func
(paren
l_string|&quot;infinite loop&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|entry
op_add_assign
id|length
suffix:semicolon
)brace
r_while
c_loop
(paren
l_int|1
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*  Tree walking is done using position numbers. The following numbers have a&n; *  special meaning:&n; *       0   start (.)&n; *      -1   no more entries&n; *      -2   ..&n; *  All other numbers encode sequences of indices. The sequence a, b, c is &n; *  encoded as &lt;stop&gt;&lt;c&gt;&lt;b&gt;&lt;a&gt;, where &lt;foo&gt; is the encoding of foo. The&n; *  first few integers are encoded as follows:&n; *      0:    0000    1:    0010    2:    0100    3:    0110&n; *      4:    1000    5:    1010    6:    1100 stop:    1110&n; *      7:  000001    8:  000101    9:  001001   10:  001101&n; *  The least significant bits give the width of this encoding, the other bits&n; *  encode the value, starting from the first value of the interval.&n; *   tag     width  first value  last value&n; *   0       3      0            6&n; *   01      4      7            22&n; *   011     5      23           54&n; *   0111    6      55           119&n; *   More values are hopefully not needed, as the file position has currently&n; *   64 bits in total. */
multiline_comment|/* Find an entry in the directory. Return 0 if not found, otherwise copy the&n; * entry to the result buffer. */
DECL|function|ntfs_getdir
r_int
id|ntfs_getdir
c_func
(paren
id|ntfs_iterate_s
op_star
id|walk
)paren
(brace
r_int
id|length
op_assign
id|walk-&gt;dir-&gt;vol-&gt;mft_record_size
suffix:semicolon
r_int
id|retval
comma
id|error
suffix:semicolon
multiline_comment|/* Start at the index root. */
r_char
op_star
id|root
op_assign
id|ntfs_malloc
c_func
(paren
id|length
)paren
suffix:semicolon
id|ntfs_io
id|io
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|root
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|io.fn_put
op_assign
id|ntfs_put
suffix:semicolon
id|io.param
op_assign
id|root
suffix:semicolon
id|io.size
op_assign
id|length
suffix:semicolon
id|error
op_assign
id|ntfs_read_attr
c_func
(paren
id|walk-&gt;dir
comma
id|walk-&gt;dir-&gt;vol-&gt;at_index_root
comma
id|I30
comma
l_int|0
comma
op_amp
id|io
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|ntfs_error
c_func
(paren
l_string|&quot;Not a directory&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|walk-&gt;block
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* FIXME: Move these to walk. */
id|walk-&gt;dir-&gt;u.index.recordsize
op_assign
id|NTFS_GETU32
c_func
(paren
id|root
op_plus
l_int|0x8
)paren
suffix:semicolon
id|walk-&gt;dir-&gt;u.index.clusters_per_record
op_assign
id|NTFS_GETU32
c_func
(paren
id|root
op_plus
l_int|0xC
)paren
suffix:semicolon
multiline_comment|/* FIXME: Consistency check. */
multiline_comment|/* Skip header. */
id|retval
op_assign
id|ntfs_getdir_iterate
c_func
(paren
id|walk
comma
id|root
comma
id|root
op_plus
l_int|0x20
)paren
suffix:semicolon
id|ntfs_free
c_func
(paren
id|root
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/* Find an entry in the directory by its position stack. Iteration starts&n; * if the stack is 0, in which case the position is set to the first item&n; * in the directory. If the position is nonzero, return the item at the&n; * position and change the position to the next item. The position is -1&n; * if there are no more items. */
DECL|function|ntfs_getdir_byposition
r_int
id|ntfs_getdir_byposition
c_func
(paren
id|ntfs_iterate_s
op_star
id|walk
)paren
(brace
id|walk-&gt;type
op_assign
id|BY_POSITION
suffix:semicolon
r_return
id|ntfs_getdir
c_func
(paren
id|walk
)paren
suffix:semicolon
)brace
multiline_comment|/* Find an entry in the directory by its name. Return 0 if not found. */
DECL|function|ntfs_getdir_byname
r_int
id|ntfs_getdir_byname
c_func
(paren
id|ntfs_iterate_s
op_star
id|walk
)paren
(brace
id|walk-&gt;type
op_assign
id|BY_NAME
suffix:semicolon
r_return
id|ntfs_getdir
c_func
(paren
id|walk
)paren
suffix:semicolon
)brace
DECL|function|ntfs_getdir_unsorted
r_int
id|ntfs_getdir_unsorted
c_func
(paren
id|ntfs_inode
op_star
id|ino
comma
id|ntfs_u32
op_star
id|p_high
comma
id|ntfs_u32
op_star
id|p_low
comma
r_int
(paren
op_star
id|cb
)paren
(paren
id|ntfs_u8
op_star
comma
r_void
op_star
)paren
comma
r_void
op_star
id|param
)paren
(brace
r_char
op_star
id|buf
op_assign
l_int|0
comma
op_star
id|entry
op_assign
l_int|0
suffix:semicolon
id|ntfs_io
id|io
suffix:semicolon
r_int
id|length
suffix:semicolon
r_int
id|block
suffix:semicolon
r_int
id|start
suffix:semicolon
id|ntfs_attribute
op_star
id|attr
suffix:semicolon
id|ntfs_volume
op_star
id|vol
suffix:semicolon
r_int
id|byte
comma
id|bit
suffix:semicolon
r_int
id|error
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ino
)paren
(brace
id|ntfs_error
c_func
(paren
l_string|&quot;No inode passed to getdir_unsorted&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|vol
op_assign
id|ino-&gt;vol
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vol
)paren
(brace
id|ntfs_error
c_func
(paren
l_string|&quot;Inode %d has no volume&bslash;n&quot;
comma
id|ino-&gt;i_number
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|ntfs_debug
c_func
(paren
id|DEBUG_DIR3
comma
l_string|&quot;unsorted 1&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Are we still in the index root? */
r_if
c_cond
(paren
op_star
id|p_high
op_eq
l_int|0
)paren
(brace
id|buf
op_assign
id|ntfs_malloc
c_func
(paren
id|length
op_assign
id|vol-&gt;mft_record_size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buf
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|io.fn_put
op_assign
id|ntfs_put
suffix:semicolon
id|io.param
op_assign
id|buf
suffix:semicolon
id|io.size
op_assign
id|length
suffix:semicolon
id|error
op_assign
id|ntfs_read_attr
c_func
(paren
id|ino
comma
id|vol-&gt;at_index_root
comma
id|I30
comma
l_int|0
comma
op_amp
id|io
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|ntfs_free
c_func
(paren
id|buf
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
id|ino-&gt;u.index.recordsize
op_assign
id|NTFS_GETU32
c_func
(paren
id|buf
op_plus
l_int|0x8
)paren
suffix:semicolon
id|ino-&gt;u.index.clusters_per_record
op_assign
id|NTFS_GETU32
c_func
(paren
id|buf
op_plus
l_int|0xC
)paren
suffix:semicolon
id|entry
op_assign
id|buf
op_plus
l_int|0x20
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_DIR3
comma
l_string|&quot;unsorted 2&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* we are in an index record */
id|length
op_assign
id|ino-&gt;u.index.recordsize
suffix:semicolon
id|buf
op_assign
id|ntfs_malloc
c_func
(paren
id|length
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buf
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|io.fn_put
op_assign
id|ntfs_put
suffix:semicolon
id|io.param
op_assign
id|buf
suffix:semicolon
id|io.size
op_assign
id|length
suffix:semicolon
multiline_comment|/* 0 is index root, index allocation starts with 4. */
id|block
op_assign
op_star
id|p_high
op_minus
id|ino-&gt;u.index.clusters_per_record
suffix:semicolon
id|error
op_assign
id|ntfs_read_attr
c_func
(paren
id|ino
comma
id|vol-&gt;at_index_allocation
comma
id|I30
comma
(paren
id|__s64
)paren
id|block
op_lshift
id|vol-&gt;cluster_size_bits
comma
op_amp
id|io
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
op_logical_and
id|io.size
op_ne
id|length
)paren
id|error
op_assign
op_minus
id|EIO
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|ntfs_error
c_func
(paren
l_string|&quot;read failed&bslash;n&quot;
)paren
suffix:semicolon
id|ntfs_free
c_func
(paren
id|buf
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|ntfs_check_index_record
c_func
(paren
id|ino
comma
id|buf
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
l_string|&quot;%x is not an index record&bslash;n&quot;
comma
id|block
)paren
suffix:semicolon
id|ntfs_free
c_func
(paren
id|buf
)paren
suffix:semicolon
r_return
op_minus
id|ENOTDIR
suffix:semicolon
)brace
id|entry
op_assign
id|buf
op_plus
id|NTFS_GETU16
c_func
(paren
id|buf
op_plus
l_int|0x18
)paren
op_plus
l_int|0x18
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_DIR3
comma
l_string|&quot;unsorted 3&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* Process the entries. */
id|start
op_assign
op_star
id|p_low
suffix:semicolon
r_while
c_loop
(paren
id|ntfs_entry_is_used
c_func
(paren
id|entry
)paren
)paren
(brace
id|ntfs_debug
c_func
(paren
id|DEBUG_DIR3
comma
l_string|&quot;unsorted 4&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|start
)paren
id|start
op_decrement
suffix:semicolon
multiline_comment|/* Skip entries that were already processed. */
r_else
(brace
id|ntfs_debug
c_func
(paren
id|DEBUG_DIR3
comma
l_string|&quot;unsorted 5&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|cb
c_func
(paren
id|entry
comma
id|param
)paren
)paren
)paren
multiline_comment|/* The entry could not be processed. */
r_break
suffix:semicolon
(paren
op_star
id|p_low
)paren
op_increment
suffix:semicolon
)brace
id|entry
op_add_assign
id|NTFS_GETU16
c_func
(paren
id|entry
op_plus
l_int|8
)paren
suffix:semicolon
)brace
id|ntfs_debug
c_func
(paren
id|DEBUG_DIR3
comma
l_string|&quot;unsorted 6&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Caller did not process all entries. */
r_if
c_cond
(paren
id|error
)paren
(brace
id|ntfs_free
c_func
(paren
id|buf
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_DIR3
comma
l_string|&quot;unsorted 7&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/* We have to locate the next record. */
id|ntfs_free
c_func
(paren
id|buf
)paren
suffix:semicolon
id|buf
op_assign
l_int|0
suffix:semicolon
op_star
id|p_low
op_assign
l_int|0
suffix:semicolon
id|attr
op_assign
id|ntfs_find_attr
c_func
(paren
id|ino
comma
id|vol-&gt;at_bitmap
comma
id|I30
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|attr
)paren
(brace
multiline_comment|/* Directory does not have index allocation. */
op_star
id|p_high
op_assign
l_int|0xFFFFFFFF
suffix:semicolon
op_star
id|p_low
op_assign
l_int|0
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_DIR3
comma
l_string|&quot;unsorted 8&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|buf
op_assign
id|ntfs_malloc
c_func
(paren
id|length
op_assign
id|attr-&gt;size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buf
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|io.param
op_assign
id|buf
suffix:semicolon
id|io.size
op_assign
id|length
suffix:semicolon
id|error
op_assign
id|ntfs_read_attr
c_func
(paren
id|ino
comma
id|vol-&gt;at_bitmap
comma
id|I30
comma
l_int|0
comma
op_amp
id|io
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
op_logical_and
id|io.size
op_ne
id|length
)paren
id|error
op_assign
op_minus
id|EIO
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|ntfs_free
c_func
(paren
id|buf
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_DIR3
comma
l_string|&quot;unsorted 9&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|attr
op_assign
id|ntfs_find_attr
c_func
(paren
id|ino
comma
id|vol-&gt;at_index_allocation
comma
id|I30
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|attr
)paren
(brace
id|ntfs_free
c_func
(paren
id|buf
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_DIR3
comma
l_string|&quot;unsorted 9.5&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_if
c_cond
(paren
(paren
id|__s64
)paren
op_star
id|p_high
op_lshift
id|vol-&gt;cluster_size_bits
OG
id|attr-&gt;size
)paren
(brace
multiline_comment|/* No more index records. */
op_star
id|p_high
op_assign
l_int|0xFFFFFFFF
suffix:semicolon
id|ntfs_free
c_func
(paren
id|buf
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_DIR3
comma
l_string|&quot;unsorted 10&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
op_star
id|p_high
op_add_assign
id|ino-&gt;u.index.clusters_per_record
suffix:semicolon
id|byte
op_assign
op_star
id|p_high
op_div
id|ino-&gt;u.index.clusters_per_record
op_minus
l_int|1
suffix:semicolon
id|bit
op_assign
l_int|1
op_lshift
(paren
id|byte
op_amp
l_int|7
)paren
suffix:semicolon
id|byte
op_assign
id|byte
op_rshift
l_int|3
suffix:semicolon
multiline_comment|/* This record is allocated. */
r_if
c_cond
(paren
id|buf
(braket
id|byte
)braket
op_amp
id|bit
)paren
r_break
suffix:semicolon
)brace
id|ntfs_debug
c_func
(paren
id|DEBUG_DIR3
comma
l_string|&quot;unsorted 11&bslash;n&quot;
)paren
suffix:semicolon
id|ntfs_free
c_func
(paren
id|buf
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ntfs_dir_add
r_int
id|ntfs_dir_add
c_func
(paren
id|ntfs_inode
op_star
id|dir
comma
id|ntfs_inode
op_star
r_new
comma
id|ntfs_attribute
op_star
id|name
)paren
(brace
id|ntfs_iterate_s
id|walk
suffix:semicolon
r_int
id|nsize
comma
id|esize
suffix:semicolon
id|ntfs_u8
op_star
id|entry
comma
op_star
id|ndata
suffix:semicolon
r_int
id|error
suffix:semicolon
id|walk.type
op_assign
id|DIR_INSERT
suffix:semicolon
id|walk.dir
op_assign
id|dir
suffix:semicolon
id|walk.u.flags
op_assign
l_int|0
suffix:semicolon
id|nsize
op_assign
id|name-&gt;size
suffix:semicolon
id|ndata
op_assign
id|name-&gt;d.data
suffix:semicolon
id|walk.name
op_assign
(paren
id|ntfs_u16
op_star
)paren
(paren
id|ndata
op_plus
l_int|0x42
)paren
suffix:semicolon
id|walk.namelen
op_assign
id|NTFS_GETU8
c_func
(paren
id|ndata
op_plus
l_int|0x40
)paren
suffix:semicolon
id|walk.new_entry_size
op_assign
id|esize
op_assign
(paren
id|nsize
op_plus
l_int|0x10
op_plus
l_int|7
)paren
op_amp
op_complement
l_int|7
suffix:semicolon
id|walk.new_entry
op_assign
id|entry
op_assign
id|ntfs_malloc
c_func
(paren
id|esize
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|entry
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|NTFS_PUTINUM
c_func
(paren
id|entry
comma
r_new
)paren
suffix:semicolon
id|NTFS_PUTU16
c_func
(paren
id|entry
op_plus
l_int|0x8
comma
id|esize
)paren
suffix:semicolon
multiline_comment|/* Size of entry. */
id|NTFS_PUTU16
c_func
(paren
id|entry
op_plus
l_int|0xA
comma
id|nsize
)paren
suffix:semicolon
multiline_comment|/* Size of original name attribute. */
id|NTFS_PUTU16
c_func
(paren
id|entry
op_plus
l_int|0xC
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Flags. */
id|NTFS_PUTU16
c_func
(paren
id|entry
op_plus
l_int|0xE
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Reserved. */
id|ntfs_memcpy
c_func
(paren
id|entry
op_plus
l_int|0x10
comma
id|ndata
comma
id|nsize
)paren
suffix:semicolon
id|ntfs_bzero
c_func
(paren
id|entry
op_plus
l_int|0x10
op_plus
id|nsize
comma
id|esize
op_minus
l_int|0x10
op_minus
id|nsize
)paren
suffix:semicolon
id|error
op_assign
id|ntfs_getdir
c_func
(paren
op_amp
id|walk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|walk.new_entry
)paren
id|ntfs_free
c_func
(paren
id|walk.new_entry
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
macro_line|#if 0
r_int
id|ntfs_dir_add1
c_func
(paren
id|ntfs_inode
op_star
id|dir
comma
r_const
r_char
op_star
id|name
comma
r_int
id|namelen
comma
id|ntfs_inode
op_star
id|ino
)paren
(brace
id|ntfs_iterate_s
id|walk
suffix:semicolon
r_int
id|error
suffix:semicolon
r_int
id|nsize
suffix:semicolon
r_char
op_star
id|entry
suffix:semicolon
id|ntfs_attribute
op_star
id|name_attr
suffix:semicolon
id|error
op_assign
id|ntfs_decodeuni
c_func
(paren
id|dir-&gt;vol
comma
id|name
comma
id|namelen
comma
op_amp
id|walk.name
comma
op_amp
id|walk.namelen
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
multiline_comment|/* FIXME: Set flags. */
id|walk.type
op_assign
id|DIR_INSERT
suffix:semicolon
id|walk.dir
op_assign
id|dir
suffix:semicolon
multiline_comment|/* walk.new = ino; */
multiline_comment|/* Prepare new entry. */
multiline_comment|/* Round up to a multiple of 8. */
id|walk.new_entry_size
op_assign
id|nsize
op_assign
(paren
(paren
l_int|0x52
op_plus
l_int|2
op_star
id|walk.namelen
op_plus
l_int|7
)paren
op_div
l_int|8
)paren
op_star
l_int|8
suffix:semicolon
id|walk.new_entry
op_assign
id|entry
op_assign
id|ntfs_malloc
c_func
(paren
id|nsize
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|entry
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|ntfs_bzero
c_func
(paren
id|entry
comma
id|nsize
)paren
suffix:semicolon
id|NTFS_PUTINUM
c_func
(paren
id|entry
comma
id|ino
)paren
suffix:semicolon
id|NTFS_PUTU16
c_func
(paren
id|entry
op_plus
l_int|8
comma
id|nsize
)paren
suffix:semicolon
id|NTFS_PUTU16
c_func
(paren
id|entry
op_plus
l_int|0xA
comma
l_int|0x42
op_plus
l_int|2
op_star
id|namelen
)paren
suffix:semicolon
multiline_comment|/* FIXME: Size of name &n;&t;&t;&t;&t;&t;&t;       * attribute. */
id|NTFS_PUTU32
c_func
(paren
id|entry
op_plus
l_int|0xC
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* FIXME: D-F? */
id|name_attr
op_assign
id|ntfs_find_attr
c_func
(paren
id|ino
comma
id|vol-&gt;at_file_name
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* FIXME: multiple names */
r_if
c_cond
(paren
op_logical_neg
id|name_attr
op_logical_or
op_logical_neg
id|name_attr-&gt;resident
)paren
r_return
op_minus
id|EIDRM
suffix:semicolon
multiline_comment|/* Directory, file stamps, sizes, filename. */
id|ntfs_memcpy
c_func
(paren
id|entry
op_plus
l_int|0x10
comma
id|name_attr-&gt;d.data
comma
l_int|0x42
op_plus
l_int|2
op_star
id|namelen
)paren
suffix:semicolon
id|error
op_assign
id|ntfs_getdir
c_func
(paren
op_amp
id|walk
)paren
suffix:semicolon
id|ntfs_free
c_func
(paren
id|walk.name
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* Fills out and creates an INDEX_ROOT attribute. */
DECL|function|ntfs_add_index_root
r_int
id|ntfs_add_index_root
c_func
(paren
id|ntfs_inode
op_star
id|ino
comma
r_int
id|type
)paren
(brace
id|ntfs_attribute
op_star
id|da
suffix:semicolon
id|ntfs_u8
id|data
(braket
l_int|0x30
)braket
suffix:semicolon
multiline_comment|/* 0x20 header, 0x10 last entry. */
r_char
id|name
(braket
l_int|10
)braket
suffix:semicolon
id|NTFS_PUTU32
c_func
(paren
id|data
comma
id|type
)paren
suffix:semicolon
multiline_comment|/* Collation rule. 1 == COLLATION_FILENAME */
id|NTFS_PUTU32
c_func
(paren
id|data
op_plus
l_int|4
comma
l_int|1
)paren
suffix:semicolon
id|NTFS_PUTU32
c_func
(paren
id|data
op_plus
l_int|8
comma
id|ino-&gt;vol-&gt;index_record_size
)paren
suffix:semicolon
id|NTFS_PUTU32
c_func
(paren
id|data
op_plus
l_int|0xC
comma
id|ino-&gt;vol-&gt;index_clusters_per_record
)paren
suffix:semicolon
multiline_comment|/* Byte offset to first INDEX_ENTRY. */
id|NTFS_PUTU32
c_func
(paren
id|data
op_plus
l_int|0x10
comma
l_int|0x10
)paren
suffix:semicolon
multiline_comment|/* Size of entries, including header. */
id|NTFS_PUTU32
c_func
(paren
id|data
op_plus
l_int|0x14
comma
l_int|0x20
)paren
suffix:semicolon
id|NTFS_PUTU32
c_func
(paren
id|data
op_plus
l_int|0x18
comma
l_int|0x20
)paren
suffix:semicolon
multiline_comment|/* No index allocation, yet. */
id|NTFS_PUTU32
c_func
(paren
id|data
op_plus
l_int|0x1C
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Add last entry. */
multiline_comment|/* Indexed MFT record. */
id|NTFS_PUTU64
c_func
(paren
id|data
op_plus
l_int|0x20
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Size of entry. */
id|NTFS_PUTU32
c_func
(paren
id|data
op_plus
l_int|0x28
comma
l_int|0x10
)paren
suffix:semicolon
multiline_comment|/* Flags: Last entry, no child nodes. */
id|NTFS_PUTU32
c_func
(paren
id|data
op_plus
l_int|0x2C
comma
l_int|2
)paren
suffix:semicolon
multiline_comment|/* Compute name. */
id|ntfs_indexname
c_func
(paren
id|name
comma
id|type
)paren
suffix:semicolon
r_return
id|ntfs_create_attr
c_func
(paren
id|ino
comma
id|ino-&gt;vol-&gt;at_index_root
comma
id|name
comma
id|data
comma
r_sizeof
(paren
id|data
)paren
comma
op_amp
id|da
)paren
suffix:semicolon
)brace
DECL|function|ntfs_mkdir
r_int
id|ntfs_mkdir
c_func
(paren
id|ntfs_inode
op_star
id|dir
comma
r_const
r_char
op_star
id|name
comma
r_int
id|namelen
comma
id|ntfs_inode
op_star
id|result
)paren
(brace
r_int
id|error
suffix:semicolon
id|error
op_assign
id|ntfs_alloc_inode
c_func
(paren
id|dir
comma
id|result
comma
id|name
comma
id|namelen
comma
id|NTFS_AFLAG_DIR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|out
suffix:semicolon
id|error
op_assign
id|ntfs_add_index_root
c_func
(paren
id|result
comma
l_int|0x30
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* Set directory bit. */
id|result-&gt;attr
(braket
l_int|0x16
)braket
op_or_assign
l_int|2
suffix:semicolon
id|error
op_assign
id|ntfs_update_inode
c_func
(paren
id|dir
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|out
suffix:semicolon
id|error
op_assign
id|ntfs_update_inode
c_func
(paren
id|result
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|out
suffix:semicolon
id|out
suffix:colon
r_return
id|error
suffix:semicolon
)brace
eof
