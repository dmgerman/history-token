multiline_comment|/**&n; * dir.c - NTFS kernel directory operations. Part of the Linux-NTFS project.&n; *&n; * Copyright (c) 2001,2002 Anton Altaparmakov.&n; * Copyright (C) 2002 Richard Russon.&n; *&n; * This program/include file is free software; you can redistribute it and/or&n; * modify it under the terms of the GNU General Public License as published&n; * by the Free Software Foundation; either version 2 of the License, or&n; * (at your option) any later version.&n; *&n; * This program/include file is distributed in the hope that it will be &n; * useful, but WITHOUT ANY WARRANTY; without even the implied warranty &n; * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; * GNU General Public License for more details.&n; *&n; * You should have received a copy of the GNU General Public License&n; * along with this program (in the main directory of the Linux-NTFS &n; * distribution in the file COPYING); if not, write to the Free Software&n; * Foundation,Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA&n; */
macro_line|#include &quot;ntfs.h&quot;
multiline_comment|/**&n; * The little endian Unicode string $I30 as a global constant.&n; */
DECL|variable|I30
r_const
id|uchar_t
id|I30
(braket
l_int|5
)braket
op_assign
(brace
id|const_cpu_to_le16
c_func
(paren
l_char|&squot;$&squot;
)paren
comma
id|const_cpu_to_le16
c_func
(paren
l_char|&squot;I&squot;
)paren
comma
id|const_cpu_to_le16
c_func
(paren
l_char|&squot;3&squot;
)paren
comma
id|const_cpu_to_le16
c_func
(paren
l_char|&squot;0&squot;
)paren
comma
id|const_cpu_to_le16
c_func
(paren
l_int|0
)paren
)brace
suffix:semicolon
multiline_comment|/**&n; * ntfs_lookup_inode_by_name - find an inode in a directory given its name&n; * @dir_ni:&t;ntfs inode of the directory in which to search for the name&n; * @uname:&t;Unicode name for which to search in the directory&n; * @uname_len:&t;length of the name @uname in Unicode characters&n; *&n; * Look for an inode with name @uname in the directory with inode @dir_ni.&n; * ntfs_lookup_inode_by_name() walks the contents of the directory looking for&n; * the Unicode name. If the name is found in the directory, the corresponding&n; * inode number (&gt;= 0) is returned as a mft reference in cpu format, i.e. it&n; * is a 64-bit number containing the sequence number.&n; *&n; * On error, a negative value is returned corresponding to the error code. In&n; * particular if the inode is not found -ENOENT is returned. Note that you&n; * can&squot;t just check the return value for being negative, you have to check the&n; * inode number for being negative which you can extract using MREC(return&n; * value).&n; *&n; * Note, @uname_len does not include the (optional) terminating NULL character.&n; */
DECL|function|ntfs_lookup_inode_by_name
id|u64
id|ntfs_lookup_inode_by_name
c_func
(paren
id|ntfs_inode
op_star
id|dir_ni
comma
r_const
id|uchar_t
op_star
id|uname
comma
r_const
r_int
id|uname_len
)paren
(brace
id|ntfs_volume
op_star
id|vol
op_assign
id|dir_ni-&gt;vol
suffix:semicolon
r_struct
id|super_block
op_star
id|sb
op_assign
id|vol-&gt;sb
suffix:semicolon
id|MFT_RECORD
op_star
id|m
suffix:semicolon
id|INDEX_ROOT
op_star
id|ir
suffix:semicolon
id|INDEX_ENTRY
op_star
id|ie
suffix:semicolon
id|INDEX_ALLOCATION
op_star
id|ia
suffix:semicolon
id|u8
op_star
id|index_end
suffix:semicolon
id|u64
id|mref
suffix:semicolon
id|attr_search_context
op_star
id|ctx
suffix:semicolon
r_int
id|err
op_assign
l_int|0
comma
id|rc
suffix:semicolon
id|IGNORE_CASE_BOOL
id|ic
suffix:semicolon
id|VCN
id|vcn
comma
id|old_vcn
suffix:semicolon
r_struct
id|address_space
op_star
id|ia_mapping
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
id|u8
op_star
id|kaddr
suffix:semicolon
multiline_comment|/* Get hold of the mft record for the directory. */
id|m
op_assign
id|map_mft_record
c_func
(paren
id|READ
comma
id|dir_ni
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|m
)paren
)paren
r_goto
id|map_err_out
suffix:semicolon
id|ctx
op_assign
id|get_attr_search_ctx
c_func
(paren
id|dir_ni
comma
id|m
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ctx
)paren
(brace
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
multiline_comment|/* Find the index root attribute in the mft record. */
r_if
c_cond
(paren
op_logical_neg
id|lookup_attr
c_func
(paren
id|AT_INDEX_ROOT
comma
id|I30
comma
l_int|4
comma
id|CASE_SENSITIVE
comma
l_int|0
comma
l_int|NULL
comma
l_int|0
comma
id|ctx
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Index root attribute missing in directory &quot;
l_string|&quot;inode 0x%Lx.&quot;
comma
(paren
r_int
r_int
r_int
)paren
id|dir_ni-&gt;mft_no
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|put_unm_err_out
suffix:semicolon
)brace
multiline_comment|/* Get to the index root value (it&squot;s been verified in read_inode). */
id|ir
op_assign
(paren
id|INDEX_ROOT
op_star
)paren
(paren
(paren
id|u8
op_star
)paren
id|ctx-&gt;attr
op_plus
id|le16_to_cpu
c_func
(paren
id|ctx-&gt;attr
op_member_access_from_pointer
id|_ARA
c_func
(paren
id|value_offset
)paren
)paren
)paren
suffix:semicolon
id|index_end
op_assign
(paren
id|u8
op_star
)paren
op_amp
id|ir-&gt;index
op_plus
id|le32_to_cpu
c_func
(paren
id|ir-&gt;index.index_length
)paren
suffix:semicolon
multiline_comment|/* The first index entry. */
id|ie
op_assign
(paren
id|INDEX_ENTRY
op_star
)paren
(paren
(paren
id|u8
op_star
)paren
op_amp
id|ir-&gt;index
op_plus
id|le32_to_cpu
c_func
(paren
id|ir-&gt;index.entries_offset
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Loop until we exceed valid memory (corruption case) or until we&n;&t; * reach the last entry.&n;&t; */
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
id|ie
op_assign
(paren
id|INDEX_ENTRY
op_star
)paren
(paren
(paren
id|u8
op_star
)paren
id|ie
op_plus
id|le16_to_cpu
c_func
(paren
id|ie
op_member_access_from_pointer
id|_IEH
c_func
(paren
id|length
)paren
)paren
)paren
)paren
(brace
multiline_comment|/* Bounds checks. */
r_if
c_cond
(paren
(paren
id|u8
op_star
)paren
id|ie
template_param
id|index_end
op_logical_or
(paren
id|u8
op_star
)paren
id|ie
op_plus
id|le16_to_cpu
c_func
(paren
id|ie
op_member_access_from_pointer
id|_IEH
c_func
(paren
id|key_length
)paren
)paren
OG
id|index_end
)paren
r_goto
id|dir_err_out
suffix:semicolon
multiline_comment|/*&n;&t;&t; * The last entry cannot contain a name. It can however contain&n;&t;&t; * a pointer to a child node in the B+tree so we just break out.&n;&t;&t; */
r_if
c_cond
(paren
id|ie
op_member_access_from_pointer
id|_IEH
c_func
(paren
id|flags
)paren
op_amp
id|INDEX_ENTRY_END
)paren
r_break
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If the current entry has a name type of POSIX, the name is&n;&t;&t; * case sensitive and not otherwise. This has the effect of us&n;&t;&t; * not being able to access any POSIX file names which collate&n;&t;&t; * after the non-POSIX one when they only differ in case, but&n;&t;&t; * anyone doing screwy stuff like that deserves to burn in&n;&t;&t; * hell... Doing that kind of stuff on NT4 actually causes&n;&t;&t; * corruption on the partition even when using SP6a and Linux&n;&t;&t; * is not involved at all.&n;&t;&t; */
id|ic
op_assign
id|ie-&gt;key.file_name.file_name_type
ques
c_cond
id|IGNORE_CASE
suffix:colon
id|CASE_SENSITIVE
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If the names match perfectly, we are done and return the&n;&t;&t; * mft reference of the inode (i.e. the inode number together&n;&t;&t; * with the sequence number for consistency checking. We&n;&t;&t; * convert it to cpu format before returning.&n;&t;&t; */
r_if
c_cond
(paren
id|ntfs_are_names_equal
c_func
(paren
id|uname
comma
id|uname_len
comma
(paren
id|uchar_t
op_star
)paren
op_amp
id|ie-&gt;key.file_name.file_name
comma
id|ie-&gt;key.file_name.file_name_length
comma
id|ic
comma
id|vol-&gt;upcase
comma
id|vol-&gt;upcase_len
)paren
)paren
(brace
id|found_it
suffix:colon
id|mref
op_assign
id|le64_to_cpu
c_func
(paren
id|ie
op_member_access_from_pointer
id|_IIF
c_func
(paren
id|indexed_file
)paren
)paren
suffix:semicolon
id|put_attr_search_ctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
id|unmap_mft_record
c_func
(paren
id|READ
comma
id|dir_ni
)paren
suffix:semicolon
r_return
id|mref
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Not a perfect match, need to do full blown collation so we&n;&t;&t; * know which way in the B+tree we have to go.&n;&t;&t; */
id|rc
op_assign
id|ntfs_collate_names
c_func
(paren
id|uname
comma
id|uname_len
comma
(paren
id|uchar_t
op_star
)paren
op_amp
id|ie-&gt;key.file_name.file_name
comma
id|ie-&gt;key.file_name.file_name_length
comma
l_int|1
comma
id|IGNORE_CASE
comma
id|vol-&gt;upcase
comma
id|vol-&gt;upcase_len
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If uname collates before the name of the current entry, there&n;&t;&t; * is definitely no such name in this index but we might need to&n;&t;&t; * descend into the B+tree so we just break out of the loop.&n;&t;&t; */
r_if
c_cond
(paren
id|rc
op_eq
op_minus
l_int|1
)paren
r_break
suffix:semicolon
multiline_comment|/* The names are not equal, continue the search. */
r_if
c_cond
(paren
id|rc
)paren
r_continue
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Names match with case insensitive comparison, now try the&n;&t;&t; * case sensitive comparison, which is required for proper&n;&t;&t; * collation.&n;&t;&t; */
id|rc
op_assign
id|ntfs_collate_names
c_func
(paren
id|uname
comma
id|uname_len
comma
(paren
id|uchar_t
op_star
)paren
op_amp
id|ie-&gt;key.file_name.file_name
comma
id|ie-&gt;key.file_name.file_name_length
comma
l_int|1
comma
id|CASE_SENSITIVE
comma
id|vol-&gt;upcase
comma
id|vol-&gt;upcase_len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_eq
op_minus
l_int|1
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_continue
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Perfect match, this will never happen as the&n;&t;&t; * ntfs_are_names_equal() call will have gotten a match but we&n;&t;&t; * still treat it correctly.&n;&t;&t; */
r_goto
id|found_it
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * We have finished with this index without success. Check for the&n;&t; * presence of a child node.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|ie
op_member_access_from_pointer
id|_IEH
c_func
(paren
id|flags
)paren
op_amp
id|INDEX_ENTRY_NODE
)paren
)paren
(brace
multiline_comment|/* No child node, return -ENOENT. */
id|err
op_assign
op_minus
id|ENOENT
suffix:semicolon
r_goto
id|put_unm_err_out
suffix:semicolon
)brace
multiline_comment|/* Child node present, descend into it. */
multiline_comment|/* Consistency check: Verify that an index allocation exists. */
r_if
c_cond
(paren
op_logical_neg
id|NInoIndexAllocPresent
c_func
(paren
id|dir_ni
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;No index allocation attribute but index entry &quot;
l_string|&quot;requires one. Directory inode 0x%Lx is &quot;
l_string|&quot;corrupt or driver bug.&quot;
comma
(paren
r_int
r_int
r_int
)paren
id|dir_ni-&gt;mft_no
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|put_unm_err_out
suffix:semicolon
)brace
multiline_comment|/* Get the starting vcn of the index_block holding the child node. */
id|vcn
op_assign
id|sle64_to_cpup
c_func
(paren
(paren
id|u8
op_star
)paren
id|ie
op_plus
id|le16_to_cpu
c_func
(paren
id|ie
op_member_access_from_pointer
id|_IEH
c_func
(paren
id|length
)paren
)paren
op_minus
l_int|8
)paren
suffix:semicolon
id|ia_mapping
op_assign
id|VFS_I
c_func
(paren
id|dir_ni
)paren
op_member_access_from_pointer
id|i_mapping
suffix:semicolon
id|descend_into_child_node
suffix:colon
multiline_comment|/*&n;&t; * Convert vcn to index into the index allocation attribute in units&n;&t; * of PAGE_CACHE_SIZE and map the page cache page, reading it from&n;&t; * disk if necessary.&n;&t; */
id|page
op_assign
id|ntfs_map_page
c_func
(paren
id|ia_mapping
comma
id|vcn
op_lshift
id|dir_ni
op_member_access_from_pointer
id|_IDM
c_func
(paren
id|index_vcn_size_bits
)paren
op_rshift
id|PAGE_CACHE_SHIFT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|page
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Failed to map directory index page, error %ld.&quot;
comma
op_minus
id|PTR_ERR
c_func
(paren
id|page
)paren
)paren
suffix:semicolon
r_goto
id|put_unm_err_out
suffix:semicolon
)brace
id|kaddr
op_assign
(paren
id|u8
op_star
)paren
id|page_address
c_func
(paren
id|page
)paren
suffix:semicolon
id|fast_descend_into_child_node
suffix:colon
multiline_comment|/* Get to the index allocation block. */
id|ia
op_assign
(paren
id|INDEX_ALLOCATION
op_star
)paren
(paren
id|kaddr
op_plus
(paren
(paren
id|vcn
op_lshift
id|dir_ni
op_member_access_from_pointer
id|_IDM
c_func
(paren
id|index_vcn_size_bits
)paren
)paren
op_amp
op_complement
id|PAGE_CACHE_MASK
)paren
)paren
suffix:semicolon
multiline_comment|/* Bounds checks. */
r_if
c_cond
(paren
(paren
id|u8
op_star
)paren
id|ia
template_param
id|kaddr
op_plus
id|PAGE_CACHE_SIZE
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Out of bounds check failed. Corrupt directory &quot;
l_string|&quot;inode 0x%Lx or driver bug.&quot;
comma
(paren
r_int
r_int
r_int
)paren
id|dir_ni-&gt;mft_no
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|unm_unm_err_out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sle64_to_cpu
c_func
(paren
id|ia-&gt;index_block_vcn
)paren
op_ne
id|vcn
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Actual VCN (0x%Lx) of index buffer is &quot;
l_string|&quot;different from expected VCN (0x%Lx). &quot;
l_string|&quot;Directory inode 0x%Lx is corrupt or driver &quot;
l_string|&quot;bug.&quot;
comma
(paren
r_int
r_int
)paren
id|sle64_to_cpu
c_func
(paren
id|ia-&gt;index_block_vcn
)paren
comma
(paren
r_int
r_int
)paren
id|vcn
comma
(paren
r_int
r_int
r_int
)paren
id|dir_ni-&gt;mft_no
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|unm_unm_err_out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|le32_to_cpu
c_func
(paren
id|ia-&gt;index.allocated_size
)paren
op_plus
l_int|0x18
op_ne
id|dir_ni
op_member_access_from_pointer
id|_IDM
c_func
(paren
id|index_block_size
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Index buffer (VCN 0x%Lx) of directory inode &quot;
l_string|&quot;0x%Lx has a size (%u) differing from the &quot;
l_string|&quot;directory specified size (%u). Directory &quot;
l_string|&quot;inode is corrupt or driver bug.&quot;
comma
(paren
r_int
r_int
)paren
id|vcn
comma
(paren
r_int
r_int
r_int
)paren
id|dir_ni-&gt;mft_no
comma
id|le32_to_cpu
c_func
(paren
id|ia-&gt;index.allocated_size
)paren
op_plus
l_int|0x18
comma
id|dir_ni
op_member_access_from_pointer
id|_IDM
c_func
(paren
id|index_block_size
)paren
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|unm_unm_err_out
suffix:semicolon
)brace
id|index_end
op_assign
(paren
id|u8
op_star
)paren
id|ia
op_plus
id|dir_ni
op_member_access_from_pointer
id|_IDM
c_func
(paren
id|index_block_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|index_end
OG
id|kaddr
op_plus
id|PAGE_CACHE_SIZE
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Index buffer (VCN 0x%Lx) of directory inode &quot;
l_string|&quot;0x%Lx crosses page boundary. Impossible! &quot;
l_string|&quot;Cannot access! This is probably a bug in the &quot;
l_string|&quot;driver.&quot;
comma
(paren
r_int
r_int
)paren
id|vcn
comma
(paren
r_int
r_int
r_int
)paren
id|dir_ni-&gt;mft_no
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|unm_unm_err_out
suffix:semicolon
)brace
id|index_end
op_assign
(paren
id|u8
op_star
)paren
op_amp
id|ia-&gt;index
op_plus
id|le32_to_cpu
c_func
(paren
id|ia-&gt;index.index_length
)paren
suffix:semicolon
r_if
c_cond
(paren
id|index_end
OG
(paren
id|u8
op_star
)paren
id|ia
op_plus
id|dir_ni
op_member_access_from_pointer
id|_IDM
c_func
(paren
id|index_block_size
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Size of index buffer (VCN 0x%Lx) of directory &quot;
l_string|&quot;inode 0x%Lx exceeds maximum size.&quot;
comma
(paren
r_int
r_int
)paren
id|vcn
comma
(paren
r_int
r_int
r_int
)paren
id|dir_ni-&gt;mft_no
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|unm_unm_err_out
suffix:semicolon
)brace
multiline_comment|/* The first index entry. */
id|ie
op_assign
(paren
id|INDEX_ENTRY
op_star
)paren
(paren
(paren
id|u8
op_star
)paren
op_amp
id|ia-&gt;index
op_plus
id|le32_to_cpu
c_func
(paren
id|ia-&gt;index.entries_offset
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Iterate similar to above big loop but applied to index buffer, thus&n;&t; * loop until we exceed valid memory (corruption case) or until we&n;&t; * reach the last entry.&n;&t; */
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
id|ie
op_assign
(paren
id|INDEX_ENTRY
op_star
)paren
(paren
(paren
id|u8
op_star
)paren
id|ie
op_plus
id|le16_to_cpu
c_func
(paren
id|ie
op_member_access_from_pointer
id|_IEH
c_func
(paren
id|length
)paren
)paren
)paren
)paren
(brace
multiline_comment|/* Bounds check. */
r_if
c_cond
(paren
(paren
id|u8
op_star
)paren
id|ie
template_param
id|index_end
op_logical_or
(paren
id|u8
op_star
)paren
id|ie
op_plus
id|le16_to_cpu
c_func
(paren
id|ie
op_member_access_from_pointer
id|_IEH
c_func
(paren
id|key_length
)paren
)paren
OG
id|index_end
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Index entry out of bounds in &quot;
l_string|&quot;directory inode 0x%Lx.&quot;
comma
(paren
r_int
r_int
r_int
)paren
id|dir_ni-&gt;mft_no
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|unm_unm_err_out
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * The last entry cannot contain a name. It can however contain&n;&t;&t; * a pointer to a child node in the B+tree so we just break out.&n;&t;&t; */
r_if
c_cond
(paren
id|ie
op_member_access_from_pointer
id|_IEH
c_func
(paren
id|flags
)paren
op_amp
id|INDEX_ENTRY_END
)paren
r_break
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If the current entry has a name type of POSIX, the name is&n;&t;&t; * case sensitive and not otherwise. This has the effect of us&n;&t;&t; * not being able to access any POSIX file names which collate&n;&t;&t; * after the non-POSIX one when they only differ in case, but&n;&t;&t; * anyone doing screwy stuff like that deserves to burn in&n;&t;&t; * hell... Doing that kind of stuff on NT4 actually causes&n;&t;&t; * corruption on the partition even when using SP6a and Linux&n;&t;&t; * is not involved at all.&n;&t;&t; */
id|ic
op_assign
id|ie-&gt;key.file_name.file_name_type
ques
c_cond
id|IGNORE_CASE
suffix:colon
id|CASE_SENSITIVE
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If the names match perfectly, we are done and return the&n;&t;&t; * mft reference of the inode (i.e. the inode number together&n;&t;&t; * with the sequence number for consistency checking. We&n;&t;&t; * convert it to cpu format before returning.&n;&t;&t; */
r_if
c_cond
(paren
id|ntfs_are_names_equal
c_func
(paren
id|uname
comma
id|uname_len
comma
(paren
id|uchar_t
op_star
)paren
op_amp
id|ie-&gt;key.file_name.file_name
comma
id|ie-&gt;key.file_name.file_name_length
comma
id|ic
comma
id|vol-&gt;upcase
comma
id|vol-&gt;upcase_len
)paren
)paren
(brace
id|found_it2
suffix:colon
id|mref
op_assign
id|le64_to_cpu
c_func
(paren
id|ie
op_member_access_from_pointer
id|_IIF
c_func
(paren
id|indexed_file
)paren
)paren
suffix:semicolon
id|ntfs_unmap_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|put_attr_search_ctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
id|unmap_mft_record
c_func
(paren
id|READ
comma
id|dir_ni
)paren
suffix:semicolon
r_return
id|mref
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Not a perfect match, need to do full blown collation so we&n;&t;&t; * know which way in the B+tree we have to go.&n;&t;&t; */
id|rc
op_assign
id|ntfs_collate_names
c_func
(paren
id|uname
comma
id|uname_len
comma
(paren
id|uchar_t
op_star
)paren
op_amp
id|ie-&gt;key.file_name.file_name
comma
id|ie-&gt;key.file_name.file_name_length
comma
l_int|1
comma
id|IGNORE_CASE
comma
id|vol-&gt;upcase
comma
id|vol-&gt;upcase_len
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If uname collates before the name of the current entry, there&n;&t;&t; * is definitely no such name in this index but we might need to&n;&t;&t; * descend into the B+tree so we just break out of the loop.&n;&t;&t; */
r_if
c_cond
(paren
id|rc
op_eq
op_minus
l_int|1
)paren
r_break
suffix:semicolon
multiline_comment|/* The names are not equal, continue the search. */
r_if
c_cond
(paren
id|rc
)paren
r_continue
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Names match with case insensitive comparison, now try the&n;&t;&t; * case sensitive comparison, which is required for proper&n;&t;&t; * collation.&n;&t;&t; */
id|rc
op_assign
id|ntfs_collate_names
c_func
(paren
id|uname
comma
id|uname_len
comma
(paren
id|uchar_t
op_star
)paren
op_amp
id|ie-&gt;key.file_name.file_name
comma
id|ie-&gt;key.file_name.file_name_length
comma
l_int|1
comma
id|CASE_SENSITIVE
comma
id|vol-&gt;upcase
comma
id|vol-&gt;upcase_len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_eq
op_minus
l_int|1
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_continue
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Perfect match, this will never happen as the&n;&t;&t; * ntfs_are_names_equal() call will have gotten a match but we&n;&t;&t; * still treat it correctly.&n;&t;&t; */
r_goto
id|found_it2
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * We have finished with this index buffer without success. Check for&n;&t; * the presence of a child node.&n;&t; */
r_if
c_cond
(paren
id|ie
op_member_access_from_pointer
id|_IEH
c_func
(paren
id|flags
)paren
op_amp
id|INDEX_ENTRY_NODE
)paren
(brace
r_if
c_cond
(paren
(paren
id|ia-&gt;index.flags
op_amp
id|NODE_MASK
)paren
op_eq
id|LEAF_NODE
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Index entry with child node found in &quot;
l_string|&quot;a leaf node in directory inode 0x%Lx.&quot;
comma
(paren
r_int
r_int
r_int
)paren
id|dir_ni-&gt;mft_no
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|unm_unm_err_out
suffix:semicolon
)brace
multiline_comment|/* Child node present, descend into it. */
id|old_vcn
op_assign
id|vcn
suffix:semicolon
id|vcn
op_assign
id|sle64_to_cpup
c_func
(paren
(paren
id|u8
op_star
)paren
id|ie
op_plus
id|le16_to_cpu
c_func
(paren
id|ie
op_member_access_from_pointer
id|_IEH
c_func
(paren
id|length
)paren
)paren
op_minus
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vcn
op_ge
l_int|0
)paren
(brace
multiline_comment|/* If vcn is in the same page cache page as old_vcn we&n;&t;&t;&t; * recycle the mapped page. */
r_if
c_cond
(paren
id|old_vcn
op_lshift
id|vol-&gt;cluster_size_bits
op_rshift
id|PAGE_CACHE_SHIFT
op_eq
id|vcn
op_lshift
id|vol-&gt;cluster_size_bits
op_rshift
id|PAGE_CACHE_SHIFT
)paren
r_goto
id|fast_descend_into_child_node
suffix:semicolon
id|ntfs_unmap_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_goto
id|descend_into_child_node
suffix:semicolon
)brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Negative child node vcn in directory inode &quot;
l_string|&quot;0x%Lx.&quot;
comma
(paren
r_int
r_int
r_int
)paren
id|dir_ni-&gt;mft_no
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|unm_unm_err_out
suffix:semicolon
)brace
multiline_comment|/* No child node, return -ENOENT. */
id|ntfs_debug
c_func
(paren
l_string|&quot;Entry not found.&quot;
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|ENOENT
suffix:semicolon
id|unm_unm_err_out
suffix:colon
id|ntfs_unmap_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|put_unm_err_out
suffix:colon
id|put_attr_search_ctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
id|unm_err_out
suffix:colon
id|unmap_mft_record
c_func
(paren
id|READ
comma
id|dir_ni
)paren
suffix:semicolon
r_return
id|ERR_MREF
c_func
(paren
id|err
)paren
suffix:semicolon
id|map_err_out
suffix:colon
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;map_mft_record(READ) failed with error code %ld.&quot;
comma
op_minus
id|PTR_ERR
c_func
(paren
id|m
)paren
)paren
suffix:semicolon
r_return
id|ERR_MREF
c_func
(paren
id|PTR_ERR
c_func
(paren
id|m
)paren
)paren
suffix:semicolon
id|dir_err_out
suffix:colon
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Corrupt directory. Aborting lookup.&quot;
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|put_unm_err_out
suffix:semicolon
)brace
r_typedef
r_union
(brace
DECL|member|ir
id|INDEX_ROOT
op_star
id|ir
suffix:semicolon
DECL|member|ia
id|INDEX_ALLOCATION
op_star
id|ia
suffix:semicolon
DECL|typedef|index_union
)brace
id|index_union
id|__attribute__
(paren
(paren
id|__transparent_union__
)paren
)paren
suffix:semicolon
r_typedef
r_enum
(brace
DECL|enumerator|INDEX_TYPE_ROOT
id|INDEX_TYPE_ROOT
comma
multiline_comment|/* index root */
DECL|enumerator|INDEX_TYPE_ALLOCATION
id|INDEX_TYPE_ALLOCATION
comma
multiline_comment|/* index allocation */
DECL|typedef|INDEX_TYPE
)brace
id|INDEX_TYPE
suffix:semicolon
multiline_comment|/**&n; * ntfs_filldir - ntfs specific filldir method&n; * @vol:&t;current ntfs volume&n; * @filp:&t;open file descriptor for the current directory&n; * @ndir:&t;ntfs inode of current directory&n; * @index_type:&t;specifies whether @iu is an index root or an index allocation&n; * @iu:&t;&t;index root or index allocation attribute to which @ie belongs&n; * @ie:&t;&t;current index entry&n; * @name:&t;buffer to use for the converted name&n; * @dirent:&t;vfs filldir callback context&n; * filldir:&t;vfs filldir callback&n; *&n; * Convert the Unicode name to the loaded NLS and pass it to&n; * the filldir callback.&n; */
DECL|function|ntfs_filldir
r_static
r_inline
r_int
id|ntfs_filldir
c_func
(paren
id|ntfs_volume
op_star
id|vol
comma
r_struct
id|file
op_star
id|filp
comma
id|ntfs_inode
op_star
id|ndir
comma
r_const
id|INDEX_TYPE
id|index_type
comma
id|index_union
id|iu
comma
id|INDEX_ENTRY
op_star
id|ie
comma
id|u8
op_star
id|name
comma
r_void
op_star
id|dirent
comma
id|filldir_t
id|filldir
)paren
(brace
r_int
id|name_len
suffix:semicolon
r_int
id|dt_type
suffix:semicolon
id|FILE_NAME_TYPE_FLAGS
id|name_type
suffix:semicolon
id|READDIR_OPTIONS
id|readdir_opts
suffix:semicolon
multiline_comment|/* Advance the position even if going to skip the entry. */
r_if
c_cond
(paren
id|index_type
op_eq
id|INDEX_TYPE_ALLOCATION
)paren
id|filp-&gt;f_pos
op_assign
(paren
id|u8
op_star
)paren
id|ie
op_minus
(paren
id|u8
op_star
)paren
id|iu.ia
op_plus
(paren
id|sle64_to_cpu
c_func
(paren
id|iu.ia-&gt;index_block_vcn
)paren
op_lshift
id|ndir
op_member_access_from_pointer
id|_IDM
c_func
(paren
id|index_vcn_size_bits
)paren
)paren
op_plus
id|vol-&gt;mft_record_size
suffix:semicolon
r_else
multiline_comment|/* if (index_type == INDEX_TYPE_ROOT) */
id|filp-&gt;f_pos
op_assign
(paren
id|u8
op_star
)paren
id|ie
op_minus
(paren
id|u8
op_star
)paren
id|iu.ir
suffix:semicolon
id|readdir_opts
op_assign
id|vol-&gt;readdir_opts
suffix:semicolon
id|name_type
op_assign
id|ie-&gt;key.file_name.file_name_type
suffix:semicolon
r_if
c_cond
(paren
id|name_type
op_eq
id|FILE_NAME_DOS
op_logical_and
id|RHideDosNames
c_func
(paren
id|readdir_opts
)paren
)paren
(brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Skipping DOS name space entry.&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|RHideLongNames
c_func
(paren
id|readdir_opts
)paren
)paren
(brace
r_if
c_cond
(paren
id|name_type
op_eq
id|FILE_NAME_WIN32
op_logical_or
id|name_type
op_eq
id|FILE_NAME_POSIX
)paren
(brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Skipping WIN32/POSIX name space entry.&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|MREF_LE
c_func
(paren
id|ie
op_member_access_from_pointer
id|_IIF
c_func
(paren
id|indexed_file
)paren
)paren
op_eq
id|FILE_root
)paren
(brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Skipping root directory self reference entry.&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|MREF_LE
c_func
(paren
id|ie
op_member_access_from_pointer
id|_IIF
c_func
(paren
id|indexed_file
)paren
)paren
OL
id|FILE_first_user
op_logical_and
id|RHideSystemFiles
c_func
(paren
id|readdir_opts
)paren
)paren
(brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Skipping system file.&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|name_len
op_assign
id|ntfs_ucstonls
c_func
(paren
id|vol
comma
(paren
id|uchar_t
op_star
)paren
op_amp
id|ie-&gt;key.file_name.file_name
comma
id|ie-&gt;key.file_name.file_name_length
comma
op_amp
id|name
comma
id|NTFS_MAX_NAME_LEN
op_star
l_int|3
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|name_len
op_le
l_int|0
)paren
(brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Skipping unrepresentable file.&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ie-&gt;key.file_name.file_attributes
op_amp
id|FILE_ATTR_DUP_FILE_NAME_INDEX_PRESENT
)paren
id|dt_type
op_assign
id|DT_DIR
suffix:semicolon
r_else
id|dt_type
op_assign
id|DT_REG
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Calling filldir for %s with len %i, f_pos 0x%Lx, inode &quot;
l_string|&quot;0x%Lx, DT_%s.&quot;
comma
id|name
comma
id|name_len
comma
id|filp-&gt;f_pos
comma
(paren
r_int
r_int
r_int
)paren
id|MREF_LE
c_func
(paren
id|ie
op_member_access_from_pointer
id|_IIF
c_func
(paren
id|indexed_file
)paren
)paren
comma
id|dt_type
op_eq
id|DT_DIR
ques
c_cond
l_string|&quot;DIR&quot;
suffix:colon
l_string|&quot;REG&quot;
)paren
suffix:semicolon
r_return
id|filldir
c_func
(paren
id|dirent
comma
id|name
comma
id|name_len
comma
id|filp-&gt;f_pos
comma
(paren
r_int
r_int
)paren
id|MREF_LE
c_func
(paren
id|ie
op_member_access_from_pointer
id|_IIF
c_func
(paren
id|indexed_file
)paren
)paren
comma
id|dt_type
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * VFS calls readdir with BKL held so no possible RACE conditions.&n; * We use the same basic approach as the old NTFS driver, i.e. we parse the&n; * index root entries and then the index allocation entries that are marked&n; * as in use in the index bitmap.&n; * While this will return the names in random order this doesn&squot;t matter for&n; * readdir but OTOH results in faster readdir.&n; */
DECL|function|ntfs_readdir
r_static
r_int
id|ntfs_readdir
c_func
(paren
r_struct
id|file
op_star
id|filp
comma
r_void
op_star
id|dirent
comma
id|filldir_t
id|filldir
)paren
(brace
id|s64
id|ia_pos
comma
id|ia_start
comma
id|prev_ia_pos
suffix:semicolon
r_struct
id|inode
op_star
id|vdir
op_assign
id|filp-&gt;f_dentry-&gt;d_inode
suffix:semicolon
r_struct
id|super_block
op_star
id|sb
op_assign
id|vdir-&gt;i_sb
suffix:semicolon
id|ntfs_inode
op_star
id|ndir
op_assign
id|NTFS_I
c_func
(paren
id|vdir
)paren
suffix:semicolon
id|ntfs_volume
op_star
id|vol
op_assign
id|NTFS_SB
c_func
(paren
id|sb
)paren
suffix:semicolon
id|MFT_RECORD
op_star
id|m
suffix:semicolon
id|INDEX_ROOT
op_star
id|ir
suffix:semicolon
id|INDEX_ENTRY
op_star
id|ie
suffix:semicolon
id|INDEX_ALLOCATION
op_star
id|ia
suffix:semicolon
id|u8
op_star
id|name
suffix:semicolon
r_int
id|rc
comma
id|err
comma
id|ir_pos
comma
id|bmp_pos
suffix:semicolon
r_struct
id|address_space
op_star
id|ia_mapping
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
id|u8
op_star
id|kaddr
comma
op_star
id|bmp
comma
op_star
id|index_end
suffix:semicolon
id|attr_search_context
op_star
id|ctx
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Entering for inode 0x%Lx, f_pos 0x%Lx.&quot;
comma
(paren
r_int
r_int
r_int
)paren
id|ndir-&gt;mft_no
comma
id|filp-&gt;f_pos
)paren
suffix:semicolon
id|rc
op_assign
id|err
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Are we at end of dir yet? */
r_if
c_cond
(paren
id|filp-&gt;f_pos
op_ge
id|vdir-&gt;i_size
op_plus
id|vol-&gt;mft_record_size
)paren
r_goto
id|done
suffix:semicolon
multiline_comment|/* Emulate . and .. for all directories. */
r_if
c_cond
(paren
op_logical_neg
id|filp-&gt;f_pos
)paren
(brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Calling filldir for . with len 1, f_pos 0x0, &quot;
l_string|&quot;inode 0x%Lx, DT_DIR.&quot;
comma
(paren
r_int
r_int
r_int
)paren
id|ndir-&gt;mft_no
)paren
suffix:semicolon
id|rc
op_assign
id|filldir
c_func
(paren
id|dirent
comma
l_string|&quot;.&quot;
comma
l_int|1
comma
id|filp-&gt;f_pos
comma
id|vdir-&gt;i_ino
comma
id|DT_DIR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_goto
id|done
suffix:semicolon
id|filp-&gt;f_pos
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|filp-&gt;f_pos
op_eq
l_int|1
)paren
(brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Calling filldir for .. with len 2, f_pos 0x1, &quot;
l_string|&quot;inode 0x%lx, DT_DIR.&quot;
comma
id|parent_ino
c_func
(paren
id|filp-&gt;f_dentry
)paren
)paren
suffix:semicolon
id|rc
op_assign
id|filldir
c_func
(paren
id|dirent
comma
l_string|&quot;..&quot;
comma
l_int|2
comma
id|filp-&gt;f_pos
comma
id|parent_ino
c_func
(paren
id|filp-&gt;f_dentry
)paren
comma
id|DT_DIR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_goto
id|done
suffix:semicolon
id|filp-&gt;f_pos
op_increment
suffix:semicolon
)brace
multiline_comment|/* Get hold of the mft record for the directory. */
id|m
op_assign
id|map_mft_record
c_func
(paren
id|READ
comma
id|ndir
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|m
)paren
)paren
(brace
id|err
op_assign
id|PTR_ERR
c_func
(paren
id|m
)paren
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
id|ctx
op_assign
id|get_attr_search_ctx
c_func
(paren
id|ndir
comma
id|m
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ctx
)paren
(brace
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Allocate a buffer to store the current name being processed&n;&t; * converted to format determined by current NLS.&n;&t; */
id|name
op_assign
(paren
id|u8
op_star
)paren
id|kmalloc
c_func
(paren
id|NTFS_MAX_NAME_LEN
op_star
l_int|3
op_plus
l_int|1
comma
id|GFP_NOFS
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|name
)paren
(brace
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|put_unm_err_out
suffix:semicolon
)brace
multiline_comment|/* Are we jumping straight into the index allocation attribute? */
r_if
c_cond
(paren
id|filp-&gt;f_pos
op_ge
id|vol-&gt;mft_record_size
)paren
r_goto
id|skip_index_root
suffix:semicolon
multiline_comment|/* Get the offset into the index root attribute. */
id|ir_pos
op_assign
(paren
id|s64
)paren
id|filp-&gt;f_pos
suffix:semicolon
multiline_comment|/* Find the index root attribute in the mft record. */
r_if
c_cond
(paren
op_logical_neg
id|lookup_attr
c_func
(paren
id|AT_INDEX_ROOT
comma
id|I30
comma
l_int|4
comma
id|CASE_SENSITIVE
comma
l_int|0
comma
l_int|NULL
comma
l_int|0
comma
id|ctx
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Index root attribute missing in directory &quot;
l_string|&quot;inode 0x%Lx.&quot;
comma
(paren
r_int
r_int
r_int
)paren
id|ndir-&gt;mft_no
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|kf_unm_err_out
suffix:semicolon
)brace
multiline_comment|/* Get to the index root value (it&squot;s been verified in read_inode). */
id|ir
op_assign
(paren
id|INDEX_ROOT
op_star
)paren
(paren
(paren
id|u8
op_star
)paren
id|ctx-&gt;attr
op_plus
id|le16_to_cpu
c_func
(paren
id|ctx-&gt;attr
op_member_access_from_pointer
id|_ARA
c_func
(paren
id|value_offset
)paren
)paren
)paren
suffix:semicolon
id|index_end
op_assign
(paren
id|u8
op_star
)paren
op_amp
id|ir-&gt;index
op_plus
id|le32_to_cpu
c_func
(paren
id|ir-&gt;index.index_length
)paren
suffix:semicolon
multiline_comment|/* The first index entry. */
id|ie
op_assign
(paren
id|INDEX_ENTRY
op_star
)paren
(paren
(paren
id|u8
op_star
)paren
op_amp
id|ir-&gt;index
op_plus
id|le32_to_cpu
c_func
(paren
id|ir-&gt;index.entries_offset
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Loop until we exceed valid memory (corruption case) or until we&n;&t; * reach the last entry or until filldir tells us it has had enough&n;&t; * or signals an error (both covered by the rc test).&n;&t; */
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
id|ie
op_assign
(paren
id|INDEX_ENTRY
op_star
)paren
(paren
(paren
id|u8
op_star
)paren
id|ie
op_plus
id|le16_to_cpu
c_func
(paren
id|ie
op_member_access_from_pointer
id|_IEH
c_func
(paren
id|length
)paren
)paren
)paren
)paren
(brace
id|ntfs_debug
c_func
(paren
l_string|&quot;In index root, offset 0x%x.&quot;
comma
(paren
id|u8
op_star
)paren
id|ie
op_minus
(paren
id|u8
op_star
)paren
id|ir
)paren
suffix:semicolon
multiline_comment|/* Bounds checks. */
r_if
c_cond
(paren
(paren
id|u8
op_star
)paren
id|ie
template_param
id|index_end
op_logical_or
(paren
id|u8
op_star
)paren
id|ie
op_plus
id|le16_to_cpu
c_func
(paren
id|ie
op_member_access_from_pointer
id|_IEH
c_func
(paren
id|key_length
)paren
)paren
OG
id|index_end
)paren
r_goto
id|dir_err_out
suffix:semicolon
multiline_comment|/* The last entry cannot contain a name. */
r_if
c_cond
(paren
id|ie
op_member_access_from_pointer
id|_IEH
c_func
(paren
id|flags
)paren
op_amp
id|INDEX_ENTRY_END
)paren
r_break
suffix:semicolon
multiline_comment|/* Skip index root entry if continuing previous readdir. */
r_if
c_cond
(paren
id|ir_pos
OG
(paren
id|u8
op_star
)paren
id|ie
op_minus
(paren
id|u8
op_star
)paren
id|ir
)paren
r_continue
suffix:semicolon
multiline_comment|/* Submit the name to the filldir callback. */
id|rc
op_assign
id|ntfs_filldir
c_func
(paren
id|vol
comma
id|filp
comma
id|ndir
comma
id|INDEX_TYPE_ROOT
comma
id|ir
comma
id|ie
comma
id|name
comma
id|dirent
comma
id|filldir
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_goto
m_abort
suffix:semicolon
)brace
multiline_comment|/* If there is no index allocation attribute we are finished. */
r_if
c_cond
(paren
op_logical_neg
id|NInoIndexAllocPresent
c_func
(paren
id|ndir
)paren
)paren
r_goto
id|EOD
suffix:semicolon
multiline_comment|/* Advance f_pos to the beginning of the index allocation. */
id|filp-&gt;f_pos
op_assign
id|vol-&gt;mft_record_size
suffix:semicolon
multiline_comment|/* Reinitialize the search context. */
id|reinit_attr_search_ctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
id|skip_index_root
suffix:colon
r_if
c_cond
(paren
id|NInoBmpNonResident
c_func
(paren
id|ndir
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * Read the page of the bitmap that contains the current index&n;&t;&t; * block.&n;&t;&t; */
singleline_comment|// TODO: FIXME: Implement this!
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Index bitmap is non-resident, which is not &quot;
l_string|&quot;supported yet. Pretending that end of &quot;
l_string|&quot;directory has been reached.&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|EOD
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Find the index bitmap attribute in the mft record. */
r_if
c_cond
(paren
op_logical_neg
id|lookup_attr
c_func
(paren
id|AT_BITMAP
comma
id|I30
comma
l_int|4
comma
id|CASE_SENSITIVE
comma
l_int|0
comma
l_int|NULL
comma
l_int|0
comma
id|ctx
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Index bitmap attribute missing in &quot;
l_string|&quot;directory inode 0x%Lx.&quot;
comma
(paren
r_int
r_int
r_int
)paren
id|ndir-&gt;mft_no
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|kf_unm_err_out
suffix:semicolon
)brace
id|bmp
op_assign
(paren
id|u8
op_star
)paren
id|ctx-&gt;attr
op_plus
id|le16_to_cpu
c_func
(paren
id|ctx-&gt;attr
op_member_access_from_pointer
id|_ARA
c_func
(paren
id|value_offset
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Get the offset into the index allocation attribute. */
id|ia_pos
op_assign
(paren
id|s64
)paren
id|filp-&gt;f_pos
op_minus
id|vol-&gt;mft_record_size
suffix:semicolon
id|ia_mapping
op_assign
id|vdir-&gt;i_mapping
suffix:semicolon
multiline_comment|/* If the index block is not in use find the next one that is. */
id|bmp_pos
op_assign
id|ia_pos
op_rshift
id|ndir
op_member_access_from_pointer
id|_IDM
c_func
(paren
id|index_block_size_bits
)paren
suffix:semicolon
id|page
op_assign
l_int|NULL
suffix:semicolon
id|kaddr
op_assign
l_int|NULL
suffix:semicolon
id|prev_ia_pos
op_assign
op_minus
l_int|1LL
suffix:semicolon
r_if
c_cond
(paren
id|bmp_pos
op_rshift
l_int|3
op_ge
id|ndir
op_member_access_from_pointer
id|_IDM
c_func
(paren
id|bmp_size
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Current index allocation position exceeds &quot;
l_string|&quot;index bitmap size.&quot;
)paren
suffix:semicolon
r_goto
id|kf_unm_err_out
suffix:semicolon
)brace
r_while
c_loop
(paren
op_logical_neg
(paren
id|bmp
(braket
id|bmp_pos
op_rshift
l_int|3
)braket
op_amp
(paren
l_int|1
op_lshift
(paren
id|bmp_pos
op_amp
l_int|7
)paren
)paren
)paren
)paren
(brace
id|find_next_index_buffer
suffix:colon
id|bmp_pos
op_increment
suffix:semicolon
multiline_comment|/* If we have reached the end of the bitmap, we are done. */
r_if
c_cond
(paren
id|bmp_pos
op_rshift
l_int|3
op_ge
id|ndir
op_member_access_from_pointer
id|_IDM
c_func
(paren
id|bmp_size
)paren
)paren
r_goto
id|EOD
suffix:semicolon
id|ia_pos
op_assign
(paren
id|s64
)paren
id|bmp_pos
op_lshift
id|ndir
op_member_access_from_pointer
id|_IDM
c_func
(paren
id|index_block_size_bits
)paren
suffix:semicolon
)brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Handling index buffer 0x%x.&quot;
comma
id|bmp_pos
)paren
suffix:semicolon
multiline_comment|/* If the current index buffer is in the same page we reuse the page. */
r_if
c_cond
(paren
(paren
id|prev_ia_pos
op_amp
id|PAGE_CACHE_MASK
)paren
op_ne
(paren
id|ia_pos
op_amp
id|PAGE_CACHE_MASK
)paren
)paren
(brace
id|prev_ia_pos
op_assign
id|ia_pos
suffix:semicolon
r_if
c_cond
(paren
id|page
)paren
id|ntfs_unmap_page
c_func
(paren
id|page
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Map the page cache page containing the current ia_pos,&n;&t;&t; * reading it from disk if necessary.&n;&t;&t; */
id|page
op_assign
id|ntfs_map_page
c_func
(paren
id|ia_mapping
comma
id|ia_pos
op_rshift
id|PAGE_CACHE_SHIFT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|page
)paren
)paren
r_goto
id|map_page_err_out
suffix:semicolon
id|kaddr
op_assign
(paren
id|u8
op_star
)paren
id|page_address
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
multiline_comment|/* Get the current index buffer. */
id|ia
op_assign
(paren
id|INDEX_ALLOCATION
op_star
)paren
(paren
id|kaddr
op_plus
(paren
id|ia_pos
op_amp
op_complement
id|PAGE_CACHE_MASK
op_amp
op_complement
(paren
id|s64
)paren
(paren
id|ndir
op_member_access_from_pointer
id|_IDM
c_func
(paren
id|index_block_size
)paren
op_minus
l_int|1
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/* Bounds checks. */
r_if
c_cond
(paren
(paren
id|u8
op_star
)paren
id|ia
template_param
id|kaddr
op_plus
id|PAGE_CACHE_SIZE
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Out of bounds check failed. Corrupt directory &quot;
l_string|&quot;inode 0x%Lx or driver bug.&quot;
comma
(paren
r_int
r_int
r_int
)paren
id|ndir-&gt;mft_no
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|unm_dir_err_out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sle64_to_cpu
c_func
(paren
id|ia-&gt;index_block_vcn
)paren
op_ne
(paren
id|ia_pos
op_amp
op_complement
(paren
id|s64
)paren
(paren
id|ndir
op_member_access_from_pointer
id|_IDM
c_func
(paren
id|index_block_size
)paren
op_minus
l_int|1
)paren
)paren
op_rshift
id|ndir
op_member_access_from_pointer
id|_IDM
c_func
(paren
id|index_vcn_size_bits
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Actual VCN (0x%Lx) of index buffer is &quot;
l_string|&quot;different from expected VCN (0x%Lx). &quot;
l_string|&quot;Directory inode 0x%Lx is corrupt or driver &quot;
l_string|&quot;bug. &quot;
comma
(paren
r_int
r_int
)paren
id|sle64_to_cpu
c_func
(paren
id|ia-&gt;index_block_vcn
)paren
comma
(paren
r_int
r_int
)paren
id|ia_pos
op_rshift
id|ndir
op_member_access_from_pointer
id|_IDM
c_func
(paren
id|index_vcn_size_bits
)paren
comma
(paren
r_int
r_int
r_int
)paren
id|ndir-&gt;mft_no
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|unm_dir_err_out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|le32_to_cpu
c_func
(paren
id|ia-&gt;index.allocated_size
)paren
op_plus
l_int|0x18
op_ne
id|ndir
op_member_access_from_pointer
id|_IDM
c_func
(paren
id|index_block_size
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Index buffer (VCN 0x%Lx) of directory inode &quot;
l_string|&quot;0x%Lx has a size (%u) differing from the &quot;
l_string|&quot;directory specified size (%u). Directory &quot;
l_string|&quot;inode is corrupt or driver bug.&quot;
comma
(paren
r_int
r_int
)paren
id|ia_pos
op_rshift
id|ndir
op_member_access_from_pointer
id|_IDM
c_func
(paren
id|index_vcn_size_bits
)paren
comma
(paren
r_int
r_int
r_int
)paren
id|ndir-&gt;mft_no
comma
id|le32_to_cpu
c_func
(paren
id|ia-&gt;index.allocated_size
)paren
op_plus
l_int|0x18
comma
id|ndir
op_member_access_from_pointer
id|_IDM
c_func
(paren
id|index_block_size
)paren
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|unm_dir_err_out
suffix:semicolon
)brace
id|index_end
op_assign
(paren
id|u8
op_star
)paren
id|ia
op_plus
id|ndir
op_member_access_from_pointer
id|_IDM
c_func
(paren
id|index_block_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|index_end
OG
id|kaddr
op_plus
id|PAGE_CACHE_SIZE
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Index buffer (VCN 0x%Lx) of directory inode &quot;
l_string|&quot;0x%Lx crosses page boundary. Impossible! &quot;
l_string|&quot;Cannot access! This is probably a bug in the &quot;
l_string|&quot;driver.&quot;
comma
(paren
r_int
r_int
)paren
id|ia_pos
op_rshift
id|ndir
op_member_access_from_pointer
id|_IDM
c_func
(paren
id|index_vcn_size_bits
)paren
comma
(paren
r_int
r_int
r_int
)paren
id|ndir-&gt;mft_no
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|unm_dir_err_out
suffix:semicolon
)brace
id|ia_start
op_assign
id|ia_pos
op_amp
op_complement
(paren
id|s64
)paren
(paren
id|ndir
op_member_access_from_pointer
id|_IDM
c_func
(paren
id|index_block_size
)paren
op_minus
l_int|1
)paren
suffix:semicolon
id|index_end
op_assign
(paren
id|u8
op_star
)paren
op_amp
id|ia-&gt;index
op_plus
id|le32_to_cpu
c_func
(paren
id|ia-&gt;index.index_length
)paren
suffix:semicolon
r_if
c_cond
(paren
id|index_end
OG
(paren
id|u8
op_star
)paren
id|ia
op_plus
id|ndir
op_member_access_from_pointer
id|_IDM
c_func
(paren
id|index_block_size
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Size of index buffer (VCN 0x%Lx) of directory &quot;
l_string|&quot;inode 0x%Lx exceeds maximum size.&quot;
comma
(paren
r_int
r_int
)paren
id|ia_pos
op_rshift
id|ndir
op_member_access_from_pointer
id|_IDM
c_func
(paren
id|index_vcn_size_bits
)paren
comma
(paren
r_int
r_int
r_int
)paren
id|ndir-&gt;mft_no
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|unm_dir_err_out
suffix:semicolon
)brace
multiline_comment|/* The first index entry in this index buffer. */
id|ie
op_assign
(paren
id|INDEX_ENTRY
op_star
)paren
(paren
(paren
id|u8
op_star
)paren
op_amp
id|ia-&gt;index
op_plus
id|le32_to_cpu
c_func
(paren
id|ia-&gt;index.entries_offset
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Loop until we exceed valid memory (corruption case) or until we&n;&t; * reach the last entry or until filldir tells us it has had enough&n;&t; * or signals an error (both covered by the rc test).&n;&t; */
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
id|ie
op_assign
(paren
id|INDEX_ENTRY
op_star
)paren
(paren
(paren
id|u8
op_star
)paren
id|ie
op_plus
id|le16_to_cpu
c_func
(paren
id|ie
op_member_access_from_pointer
id|_IEH
c_func
(paren
id|length
)paren
)paren
)paren
)paren
(brace
id|ntfs_debug
c_func
(paren
l_string|&quot;In index allocation, offset 0x%Lx.&quot;
comma
(paren
r_int
r_int
)paren
id|ia_start
op_plus
(paren
(paren
id|u8
op_star
)paren
id|ie
op_minus
(paren
id|u8
op_star
)paren
id|ia
)paren
)paren
suffix:semicolon
multiline_comment|/* Bounds checks. */
r_if
c_cond
(paren
(paren
id|u8
op_star
)paren
id|ie
template_param
id|index_end
op_logical_or
(paren
id|u8
op_star
)paren
id|ie
op_plus
id|le16_to_cpu
c_func
(paren
id|ie
op_member_access_from_pointer
id|_IEH
c_func
(paren
id|key_length
)paren
)paren
OG
id|index_end
)paren
r_goto
id|unm_dir_err_out
suffix:semicolon
multiline_comment|/* The last entry cannot contain a name. */
r_if
c_cond
(paren
id|ie
op_member_access_from_pointer
id|_IEH
c_func
(paren
id|flags
)paren
op_amp
id|INDEX_ENTRY_END
)paren
r_break
suffix:semicolon
multiline_comment|/* Skip index block entry if continuing previous readdir. */
r_if
c_cond
(paren
id|ia_pos
op_minus
id|ia_start
OG
(paren
id|u8
op_star
)paren
id|ie
op_minus
(paren
id|u8
op_star
)paren
id|ia
)paren
r_continue
suffix:semicolon
multiline_comment|/* Submit the name to the filldir callback. */
id|rc
op_assign
id|ntfs_filldir
c_func
(paren
id|vol
comma
id|filp
comma
id|ndir
comma
id|INDEX_TYPE_ALLOCATION
comma
id|ia
comma
id|ie
comma
id|name
comma
id|dirent
comma
id|filldir
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
(brace
id|ntfs_unmap_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
)brace
r_goto
id|find_next_index_buffer
suffix:semicolon
id|EOD
suffix:colon
multiline_comment|/* We are finished, set f_pos to EOD. */
id|filp-&gt;f_pos
op_assign
id|vdir-&gt;i_size
op_plus
id|vol-&gt;mft_record_size
suffix:semicolon
m_abort
suffix:colon
id|put_attr_search_ctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
id|unmap_mft_record
c_func
(paren
id|READ
comma
id|ndir
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|name
)paren
suffix:semicolon
id|done
suffix:colon
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
op_logical_neg
id|rc
)paren
id|ntfs_debug
c_func
(paren
l_string|&quot;EOD, f_pos 0x%Lx, returning 0.&quot;
comma
id|filp-&gt;f_pos
)paren
suffix:semicolon
r_else
id|ntfs_debug
c_func
(paren
l_string|&quot;filldir returned %i, f_pos 0x%Lx, returning 0.&quot;
comma
id|rc
comma
id|filp-&gt;f_pos
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
id|map_page_err_out
suffix:colon
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Reading index allocation data failed.&quot;
)paren
suffix:semicolon
id|err
op_assign
id|PTR_ERR
c_func
(paren
id|page
)paren
suffix:semicolon
id|kf_unm_err_out
suffix:colon
id|kfree
c_func
(paren
id|name
)paren
suffix:semicolon
id|put_unm_err_out
suffix:colon
id|put_attr_search_ctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
id|unm_err_out
suffix:colon
id|unmap_mft_record
c_func
(paren
id|READ
comma
id|ndir
)paren
suffix:semicolon
id|err_out
suffix:colon
id|ntfs_debug
c_func
(paren
l_string|&quot;Failed. Returning error code %i.&quot;
comma
op_minus
id|err
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
id|unm_dir_err_out
suffix:colon
id|ntfs_unmap_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|dir_err_out
suffix:colon
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Corrupt directory. Aborting. You should run chkdsk.&quot;
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|kf_unm_err_out
suffix:semicolon
)brace
DECL|variable|ntfs_dir_ops
r_struct
id|file_operations
id|ntfs_dir_ops
op_assign
(brace
id|read
suffix:colon
id|generic_read_dir
comma
multiline_comment|/* Return -EISDIR. */
id|readdir
suffix:colon
id|ntfs_readdir
comma
multiline_comment|/* Read directory. */
)brace
suffix:semicolon
eof
