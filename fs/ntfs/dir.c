multiline_comment|/**&n; * dir.c - NTFS kernel directory operations. Part of the Linux-NTFS project.&n; *&n; * Copyright (c) 2001-2004 Anton Altaparmakov&n; * Copyright (c) 2002 Richard Russon&n; *&n; * This program/include file is free software; you can redistribute it and/or&n; * modify it under the terms of the GNU General Public License as published&n; * by the Free Software Foundation; either version 2 of the License, or&n; * (at your option) any later version.&n; *&n; * This program/include file is distributed in the hope that it will be&n; * useful, but WITHOUT ANY WARRANTY; without even the implied warranty&n; * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; * GNU General Public License for more details.&n; *&n; * You should have received a copy of the GNU General Public License&n; * along with this program (in the main directory of the Linux-NTFS&n; * distribution in the file COPYING); if not, write to the Free Software&n; * Foundation,Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA&n; */
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/buffer_head.h&gt;
macro_line|#include &quot;dir.h&quot;
macro_line|#include &quot;aops.h&quot;
macro_line|#include &quot;attrib.h&quot;
macro_line|#include &quot;mft.h&quot;
macro_line|#include &quot;debug.h&quot;
macro_line|#include &quot;ntfs.h&quot;
multiline_comment|/**&n; * The little endian Unicode string $I30 as a global constant.&n; */
DECL|variable|I30
id|ntfschar
id|I30
(braket
l_int|5
)braket
op_assign
(brace
id|const_cpu_to_le16
c_func
(paren
l_char|&squot;$&squot;
)paren
comma
id|const_cpu_to_le16
c_func
(paren
l_char|&squot;I&squot;
)paren
comma
id|const_cpu_to_le16
c_func
(paren
l_char|&squot;3&squot;
)paren
comma
id|const_cpu_to_le16
c_func
(paren
l_char|&squot;0&squot;
)paren
comma
l_int|0
)brace
suffix:semicolon
multiline_comment|/**&n; * ntfs_lookup_inode_by_name - find an inode in a directory given its name&n; * @dir_ni:&t;ntfs inode of the directory in which to search for the name&n; * @uname:&t;Unicode name for which to search in the directory&n; * @uname_len:&t;length of the name @uname in Unicode characters&n; * @res:&t;return the found file name if necessary (see below)&n; *&n; * Look for an inode with name @uname in the directory with inode @dir_ni.&n; * ntfs_lookup_inode_by_name() walks the contents of the directory looking for&n; * the Unicode name. If the name is found in the directory, the corresponding&n; * inode number (&gt;= 0) is returned as a mft reference in cpu format, i.e. it&n; * is a 64-bit number containing the sequence number.&n; *&n; * On error, a negative value is returned corresponding to the error code. In&n; * particular if the inode is not found -ENOENT is returned. Note that you&n; * can&squot;t just check the return value for being negative, you have to check the&n; * inode number for being negative which you can extract using MREC(return&n; * value).&n; *&n; * Note, @uname_len does not include the (optional) terminating NULL character.&n; *&n; * Note, we look for a case sensitive match first but we also look for a case&n; * insensitive match at the same time. If we find a case insensitive match, we&n; * save that for the case that we don&squot;t find an exact match, where we return&n; * the case insensitive match and setup @res (which we allocate!) with the mft&n; * reference, the file name type, length and with a copy of the little endian&n; * Unicode file name itself. If we match a file name which is in the DOS name&n; * space, we only return the mft reference and file name type in @res.&n; * ntfs_lookup() then uses this to find the long file name in the inode itself.&n; * This is to avoid polluting the dcache with short file names. We want them to&n; * work but we don&squot;t care for how quickly one can access them. This also fixes&n; * the dcache aliasing issues.&n; *&n; * Locking:  - Caller must hold i_sem on the directory.&n; *&t;     - Each page cache page in the index allocation mapping must be&n; *&t;       locked whilst being accessed otherwise we may find a corrupt&n; *&t;       page due to it being under -&gt;writepage at the moment which&n; *&t;       applies the mst protection fixups before writing out and then&n; *&t;       removes them again after the write is complete after which it &n; *&t;       unlocks the page.&n; */
DECL|function|ntfs_lookup_inode_by_name
id|MFT_REF
id|ntfs_lookup_inode_by_name
c_func
(paren
id|ntfs_inode
op_star
id|dir_ni
comma
r_const
id|ntfschar
op_star
id|uname
comma
r_const
r_int
id|uname_len
comma
id|ntfs_name
op_star
op_star
id|res
)paren
(brace
id|ntfs_volume
op_star
id|vol
op_assign
id|dir_ni-&gt;vol
suffix:semicolon
r_struct
id|super_block
op_star
id|sb
op_assign
id|vol-&gt;sb
suffix:semicolon
id|MFT_RECORD
op_star
id|m
suffix:semicolon
id|INDEX_ROOT
op_star
id|ir
suffix:semicolon
id|INDEX_ENTRY
op_star
id|ie
suffix:semicolon
id|INDEX_ALLOCATION
op_star
id|ia
suffix:semicolon
id|u8
op_star
id|index_end
suffix:semicolon
id|u64
id|mref
suffix:semicolon
id|ntfs_attr_search_ctx
op_star
id|ctx
suffix:semicolon
r_int
id|err
comma
id|rc
suffix:semicolon
id|VCN
id|vcn
comma
id|old_vcn
suffix:semicolon
r_struct
id|address_space
op_star
id|ia_mapping
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
id|u8
op_star
id|kaddr
suffix:semicolon
id|ntfs_name
op_star
id|name
op_assign
l_int|NULL
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|S_ISDIR
c_func
(paren
id|VFS_I
c_func
(paren
id|dir_ni
)paren
op_member_access_from_pointer
id|i_mode
)paren
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|NInoAttr
c_func
(paren
id|dir_ni
)paren
)paren
suffix:semicolon
multiline_comment|/* Get hold of the mft record for the directory. */
id|m
op_assign
id|map_mft_record
c_func
(paren
id|dir_ni
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|m
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;map_mft_record() failed with error code %ld.&quot;
comma
op_minus
id|PTR_ERR
c_func
(paren
id|m
)paren
)paren
suffix:semicolon
r_return
id|ERR_MREF
c_func
(paren
id|PTR_ERR
c_func
(paren
id|m
)paren
)paren
suffix:semicolon
)brace
id|ctx
op_assign
id|ntfs_attr_get_search_ctx
c_func
(paren
id|dir_ni
comma
id|m
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|ctx
)paren
)paren
(brace
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
multiline_comment|/* Find the index root attribute in the mft record. */
id|err
op_assign
id|ntfs_attr_lookup
c_func
(paren
id|AT_INDEX_ROOT
comma
id|I30
comma
l_int|4
comma
id|CASE_SENSITIVE
comma
l_int|0
comma
l_int|NULL
comma
l_int|0
comma
id|ctx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|err
)paren
)paren
(brace
r_if
c_cond
(paren
id|err
op_eq
op_minus
id|ENOENT
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Index root attribute missing in &quot;
l_string|&quot;directory inode 0x%lx.&quot;
comma
id|dir_ni-&gt;mft_no
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
r_goto
id|err_out
suffix:semicolon
)brace
multiline_comment|/* Get to the index root value (it&squot;s been verified in read_inode). */
id|ir
op_assign
(paren
id|INDEX_ROOT
op_star
)paren
(paren
(paren
id|u8
op_star
)paren
id|ctx-&gt;attr
op_plus
id|le16_to_cpu
c_func
(paren
id|ctx-&gt;attr-&gt;data.resident.value_offset
)paren
)paren
suffix:semicolon
id|index_end
op_assign
(paren
id|u8
op_star
)paren
op_amp
id|ir-&gt;index
op_plus
id|le32_to_cpu
c_func
(paren
id|ir-&gt;index.index_length
)paren
suffix:semicolon
multiline_comment|/* The first index entry. */
id|ie
op_assign
(paren
id|INDEX_ENTRY
op_star
)paren
(paren
(paren
id|u8
op_star
)paren
op_amp
id|ir-&gt;index
op_plus
id|le32_to_cpu
c_func
(paren
id|ir-&gt;index.entries_offset
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Loop until we exceed valid memory (corruption case) or until we&n;&t; * reach the last entry.&n;&t; */
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
id|ie
op_assign
(paren
id|INDEX_ENTRY
op_star
)paren
(paren
(paren
id|u8
op_star
)paren
id|ie
op_plus
id|le16_to_cpu
c_func
(paren
id|ie-&gt;length
)paren
)paren
)paren
(brace
multiline_comment|/* Bounds checks. */
r_if
c_cond
(paren
(paren
id|u8
op_star
)paren
id|ie
template_param
id|index_end
op_logical_or
(paren
id|u8
op_star
)paren
id|ie
op_plus
id|le16_to_cpu
c_func
(paren
id|ie-&gt;key_length
)paren
OG
id|index_end
)paren
r_goto
id|dir_err_out
suffix:semicolon
multiline_comment|/*&n;&t;&t; * The last entry cannot contain a name. It can however contain&n;&t;&t; * a pointer to a child node in the B+tree so we just break out.&n;&t;&t; */
r_if
c_cond
(paren
id|ie-&gt;flags
op_amp
id|INDEX_ENTRY_END
)paren
r_break
suffix:semicolon
multiline_comment|/*&n;&t;&t; * We perform a case sensitive comparison and if that matches&n;&t;&t; * we are done and return the mft reference of the inode (i.e.&n;&t;&t; * the inode number together with the sequence number for&n;&t;&t; * consistency checking). We convert it to cpu format before&n;&t;&t; * returning.&n;&t;&t; */
r_if
c_cond
(paren
id|ntfs_are_names_equal
c_func
(paren
id|uname
comma
id|uname_len
comma
(paren
id|ntfschar
op_star
)paren
op_amp
id|ie-&gt;key.file_name.file_name
comma
id|ie-&gt;key.file_name.file_name_length
comma
id|CASE_SENSITIVE
comma
id|vol-&gt;upcase
comma
id|vol-&gt;upcase_len
)paren
)paren
(brace
id|found_it
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * We have a perfect match, so we don&squot;t need to care&n;&t;&t;&t; * about having matched imperfectly before, so we can&n;&t;&t;&t; * free name and set *res to NULL.&n;&t;&t;&t; * However, if the perfect match is a short file name,&n;&t;&t;&t; * we need to signal this through *res, so that&n;&t;&t;&t; * ntfs_lookup() can fix dcache aliasing issues.&n;&t;&t;&t; * As an optimization we just reuse an existing&n;&t;&t;&t; * allocation of *res.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|ie-&gt;key.file_name.file_name_type
op_eq
id|FILE_NAME_DOS
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|name
)paren
(brace
id|name
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|ntfs_name
)paren
comma
id|GFP_NOFS
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|name
)paren
(brace
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
)brace
id|name-&gt;mref
op_assign
id|le64_to_cpu
c_func
(paren
id|ie-&gt;data.dir.indexed_file
)paren
suffix:semicolon
id|name-&gt;type
op_assign
id|FILE_NAME_DOS
suffix:semicolon
id|name-&gt;len
op_assign
l_int|0
suffix:semicolon
op_star
id|res
op_assign
id|name
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|name
)paren
id|kfree
c_func
(paren
id|name
)paren
suffix:semicolon
op_star
id|res
op_assign
l_int|NULL
suffix:semicolon
)brace
id|mref
op_assign
id|le64_to_cpu
c_func
(paren
id|ie-&gt;data.dir.indexed_file
)paren
suffix:semicolon
id|ntfs_attr_put_search_ctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
id|unmap_mft_record
c_func
(paren
id|dir_ni
)paren
suffix:semicolon
r_return
id|mref
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * For a case insensitive mount, we also perform a case&n;&t;&t; * insensitive comparison (provided the file name is not in the&n;&t;&t; * POSIX namespace). If the comparison matches, and the name is&n;&t;&t; * in the WIN32 namespace, we cache the filename in *res so&n;&t;&t; * that the caller, ntfs_lookup(), can work on it. If the&n;&t;&t; * comparison matches, and the name is in the DOS namespace, we&n;&t;&t; * only cache the mft reference and the file name type (we set&n;&t;&t; * the name length to zero for simplicity).&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|NVolCaseSensitive
c_func
(paren
id|vol
)paren
op_logical_and
id|ie-&gt;key.file_name.file_name_type
op_logical_and
id|ntfs_are_names_equal
c_func
(paren
id|uname
comma
id|uname_len
comma
(paren
id|ntfschar
op_star
)paren
op_amp
id|ie-&gt;key.file_name.file_name
comma
id|ie-&gt;key.file_name.file_name_length
comma
id|IGNORE_CASE
comma
id|vol-&gt;upcase
comma
id|vol-&gt;upcase_len
)paren
)paren
(brace
r_int
id|name_size
op_assign
r_sizeof
(paren
id|ntfs_name
)paren
suffix:semicolon
id|u8
id|type
op_assign
id|ie-&gt;key.file_name.file_name_type
suffix:semicolon
id|u8
id|len
op_assign
id|ie-&gt;key.file_name.file_name_length
suffix:semicolon
multiline_comment|/* Only one case insensitive matching name allowed. */
r_if
c_cond
(paren
id|name
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Found already allocated name &quot;
l_string|&quot;in phase 1. Please run chkdsk &quot;
l_string|&quot;and if that doesn&squot;t find any &quot;
l_string|&quot;errors please report you saw &quot;
l_string|&quot;this message to &quot;
l_string|&quot;linux-ntfs-dev@lists.&quot;
l_string|&quot;sourceforge.net.&quot;
)paren
suffix:semicolon
r_goto
id|dir_err_out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|type
op_ne
id|FILE_NAME_DOS
)paren
id|name_size
op_add_assign
id|len
op_star
r_sizeof
(paren
id|ntfschar
)paren
suffix:semicolon
id|name
op_assign
id|kmalloc
c_func
(paren
id|name_size
comma
id|GFP_NOFS
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|name
)paren
(brace
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
id|name-&gt;mref
op_assign
id|le64_to_cpu
c_func
(paren
id|ie-&gt;data.dir.indexed_file
)paren
suffix:semicolon
id|name-&gt;type
op_assign
id|type
suffix:semicolon
r_if
c_cond
(paren
id|type
op_ne
id|FILE_NAME_DOS
)paren
(brace
id|name-&gt;len
op_assign
id|len
suffix:semicolon
id|memcpy
c_func
(paren
id|name-&gt;name
comma
id|ie-&gt;key.file_name.file_name
comma
id|len
op_star
r_sizeof
(paren
id|ntfschar
)paren
)paren
suffix:semicolon
)brace
r_else
id|name-&gt;len
op_assign
l_int|0
suffix:semicolon
op_star
id|res
op_assign
id|name
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Not a perfect match, need to do full blown collation so we&n;&t;&t; * know which way in the B+tree we have to go.&n;&t;&t; */
id|rc
op_assign
id|ntfs_collate_names
c_func
(paren
id|uname
comma
id|uname_len
comma
(paren
id|ntfschar
op_star
)paren
op_amp
id|ie-&gt;key.file_name.file_name
comma
id|ie-&gt;key.file_name.file_name_length
comma
l_int|1
comma
id|IGNORE_CASE
comma
id|vol-&gt;upcase
comma
id|vol-&gt;upcase_len
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If uname collates before the name of the current entry, there&n;&t;&t; * is definitely no such name in this index but we might need to&n;&t;&t; * descend into the B+tree so we just break out of the loop.&n;&t;&t; */
r_if
c_cond
(paren
id|rc
op_eq
op_minus
l_int|1
)paren
r_break
suffix:semicolon
multiline_comment|/* The names are not equal, continue the search. */
r_if
c_cond
(paren
id|rc
)paren
r_continue
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Names match with case insensitive comparison, now try the&n;&t;&t; * case sensitive comparison, which is required for proper&n;&t;&t; * collation.&n;&t;&t; */
id|rc
op_assign
id|ntfs_collate_names
c_func
(paren
id|uname
comma
id|uname_len
comma
(paren
id|ntfschar
op_star
)paren
op_amp
id|ie-&gt;key.file_name.file_name
comma
id|ie-&gt;key.file_name.file_name_length
comma
l_int|1
comma
id|CASE_SENSITIVE
comma
id|vol-&gt;upcase
comma
id|vol-&gt;upcase_len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_eq
op_minus
l_int|1
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_continue
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Perfect match, this will never happen as the&n;&t;&t; * ntfs_are_names_equal() call will have gotten a match but we&n;&t;&t; * still treat it correctly.&n;&t;&t; */
r_goto
id|found_it
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * We have finished with this index without success. Check for the&n;&t; * presence of a child node and if not present return -ENOENT, unless&n;&t; * we have got a matching name cached in name in which case return the&n;&t; * mft reference associated with it.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|ie-&gt;flags
op_amp
id|INDEX_ENTRY_NODE
)paren
)paren
(brace
r_if
c_cond
(paren
id|name
)paren
(brace
id|ntfs_attr_put_search_ctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
id|unmap_mft_record
c_func
(paren
id|dir_ni
)paren
suffix:semicolon
r_return
id|name-&gt;mref
suffix:semicolon
)brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Entry not found.&quot;
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|ENOENT
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
multiline_comment|/* Child node present, descend into it. */
multiline_comment|/* Consistency check: Verify that an index allocation exists. */
r_if
c_cond
(paren
op_logical_neg
id|NInoIndexAllocPresent
c_func
(paren
id|dir_ni
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;No index allocation attribute but index entry &quot;
l_string|&quot;requires one. Directory inode 0x%lx is &quot;
l_string|&quot;corrupt or driver bug.&quot;
comma
id|dir_ni-&gt;mft_no
)paren
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
multiline_comment|/* Get the starting vcn of the index_block holding the child node. */
id|vcn
op_assign
id|sle64_to_cpup
c_func
(paren
(paren
id|sle64
op_star
)paren
(paren
(paren
id|u8
op_star
)paren
id|ie
op_plus
id|le16_to_cpu
c_func
(paren
id|ie-&gt;length
)paren
op_minus
l_int|8
)paren
)paren
suffix:semicolon
id|ia_mapping
op_assign
id|VFS_I
c_func
(paren
id|dir_ni
)paren
op_member_access_from_pointer
id|i_mapping
suffix:semicolon
multiline_comment|/*&n;&t; * We are done with the index root and the mft record. Release them,&n;&t; * otherwise we deadlock with ntfs_map_page().&n;&t; */
id|ntfs_attr_put_search_ctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
id|unmap_mft_record
c_func
(paren
id|dir_ni
)paren
suffix:semicolon
id|m
op_assign
l_int|NULL
suffix:semicolon
id|ctx
op_assign
l_int|NULL
suffix:semicolon
id|descend_into_child_node
suffix:colon
multiline_comment|/*&n;&t; * Convert vcn to index into the index allocation attribute in units&n;&t; * of PAGE_CACHE_SIZE and map the page cache page, reading it from&n;&t; * disk if necessary.&n;&t; */
id|page
op_assign
id|ntfs_map_page
c_func
(paren
id|ia_mapping
comma
id|vcn
op_lshift
id|dir_ni-&gt;itype.index.vcn_size_bits
op_rshift
id|PAGE_CACHE_SHIFT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|page
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Failed to map directory index page, error %ld.&quot;
comma
op_minus
id|PTR_ERR
c_func
(paren
id|page
)paren
)paren
suffix:semicolon
id|err
op_assign
id|PTR_ERR
c_func
(paren
id|page
)paren
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
id|lock_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|kaddr
op_assign
(paren
id|u8
op_star
)paren
id|page_address
c_func
(paren
id|page
)paren
suffix:semicolon
id|fast_descend_into_child_node
suffix:colon
multiline_comment|/* Get to the index allocation block. */
id|ia
op_assign
(paren
id|INDEX_ALLOCATION
op_star
)paren
(paren
id|kaddr
op_plus
(paren
(paren
id|vcn
op_lshift
id|dir_ni-&gt;itype.index.vcn_size_bits
)paren
op_amp
op_complement
id|PAGE_CACHE_MASK
)paren
)paren
suffix:semicolon
multiline_comment|/* Bounds checks. */
r_if
c_cond
(paren
(paren
id|u8
op_star
)paren
id|ia
template_param
id|kaddr
op_plus
id|PAGE_CACHE_SIZE
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Out of bounds check failed. Corrupt directory &quot;
l_string|&quot;inode 0x%lx or driver bug.&quot;
comma
id|dir_ni-&gt;mft_no
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
multiline_comment|/* Catch multi sector transfer fixup errors. */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|ntfs_is_indx_record
c_func
(paren
id|ia-&gt;magic
)paren
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Directory index record with vcn 0x%llx is &quot;
l_string|&quot;corrupt.  Corrupt inode 0x%lx.  Run chkdsk.&quot;
comma
(paren
r_int
r_int
r_int
)paren
id|vcn
comma
id|dir_ni-&gt;mft_no
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sle64_to_cpu
c_func
(paren
id|ia-&gt;index_block_vcn
)paren
op_ne
id|vcn
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Actual VCN (0x%llx) of index buffer is &quot;
l_string|&quot;different from expected VCN (0x%llx). &quot;
l_string|&quot;Directory inode 0x%lx is corrupt or driver &quot;
l_string|&quot;bug.&quot;
comma
(paren
r_int
r_int
r_int
)paren
id|sle64_to_cpu
c_func
(paren
id|ia-&gt;index_block_vcn
)paren
comma
(paren
r_int
r_int
r_int
)paren
id|vcn
comma
id|dir_ni-&gt;mft_no
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|le32_to_cpu
c_func
(paren
id|ia-&gt;index.allocated_size
)paren
op_plus
l_int|0x18
op_ne
id|dir_ni-&gt;itype.index.block_size
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Index buffer (VCN 0x%llx) of directory inode &quot;
l_string|&quot;0x%lx has a size (%u) differing from the &quot;
l_string|&quot;directory specified size (%u). Directory &quot;
l_string|&quot;inode is corrupt or driver bug.&quot;
comma
(paren
r_int
r_int
r_int
)paren
id|vcn
comma
id|dir_ni-&gt;mft_no
comma
id|le32_to_cpu
c_func
(paren
id|ia-&gt;index.allocated_size
)paren
op_plus
l_int|0x18
comma
id|dir_ni-&gt;itype.index.block_size
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
id|index_end
op_assign
(paren
id|u8
op_star
)paren
id|ia
op_plus
id|dir_ni-&gt;itype.index.block_size
suffix:semicolon
r_if
c_cond
(paren
id|index_end
OG
id|kaddr
op_plus
id|PAGE_CACHE_SIZE
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Index buffer (VCN 0x%llx) of directory inode &quot;
l_string|&quot;0x%lx crosses page boundary. Impossible! &quot;
l_string|&quot;Cannot access! This is probably a bug in the &quot;
l_string|&quot;driver.&quot;
comma
(paren
r_int
r_int
r_int
)paren
id|vcn
comma
id|dir_ni-&gt;mft_no
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
id|index_end
op_assign
(paren
id|u8
op_star
)paren
op_amp
id|ia-&gt;index
op_plus
id|le32_to_cpu
c_func
(paren
id|ia-&gt;index.index_length
)paren
suffix:semicolon
r_if
c_cond
(paren
id|index_end
OG
(paren
id|u8
op_star
)paren
id|ia
op_plus
id|dir_ni-&gt;itype.index.block_size
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Size of index buffer (VCN 0x%llx) of directory &quot;
l_string|&quot;inode 0x%lx exceeds maximum size.&quot;
comma
(paren
r_int
r_int
r_int
)paren
id|vcn
comma
id|dir_ni-&gt;mft_no
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
multiline_comment|/* The first index entry. */
id|ie
op_assign
(paren
id|INDEX_ENTRY
op_star
)paren
(paren
(paren
id|u8
op_star
)paren
op_amp
id|ia-&gt;index
op_plus
id|le32_to_cpu
c_func
(paren
id|ia-&gt;index.entries_offset
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Iterate similar to above big loop but applied to index buffer, thus&n;&t; * loop until we exceed valid memory (corruption case) or until we&n;&t; * reach the last entry.&n;&t; */
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
id|ie
op_assign
(paren
id|INDEX_ENTRY
op_star
)paren
(paren
(paren
id|u8
op_star
)paren
id|ie
op_plus
id|le16_to_cpu
c_func
(paren
id|ie-&gt;length
)paren
)paren
)paren
(brace
multiline_comment|/* Bounds check. */
r_if
c_cond
(paren
(paren
id|u8
op_star
)paren
id|ie
template_param
id|index_end
op_logical_or
(paren
id|u8
op_star
)paren
id|ie
op_plus
id|le16_to_cpu
c_func
(paren
id|ie-&gt;key_length
)paren
OG
id|index_end
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Index entry out of bounds in &quot;
l_string|&quot;directory inode 0x%lx.&quot;
comma
id|dir_ni-&gt;mft_no
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * The last entry cannot contain a name. It can however contain&n;&t;&t; * a pointer to a child node in the B+tree so we just break out.&n;&t;&t; */
r_if
c_cond
(paren
id|ie-&gt;flags
op_amp
id|INDEX_ENTRY_END
)paren
r_break
suffix:semicolon
multiline_comment|/*&n;&t;&t; * We perform a case sensitive comparison and if that matches&n;&t;&t; * we are done and return the mft reference of the inode (i.e.&n;&t;&t; * the inode number together with the sequence number for&n;&t;&t; * consistency checking). We convert it to cpu format before&n;&t;&t; * returning.&n;&t;&t; */
r_if
c_cond
(paren
id|ntfs_are_names_equal
c_func
(paren
id|uname
comma
id|uname_len
comma
(paren
id|ntfschar
op_star
)paren
op_amp
id|ie-&gt;key.file_name.file_name
comma
id|ie-&gt;key.file_name.file_name_length
comma
id|CASE_SENSITIVE
comma
id|vol-&gt;upcase
comma
id|vol-&gt;upcase_len
)paren
)paren
(brace
id|found_it2
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * We have a perfect match, so we don&squot;t need to care&n;&t;&t;&t; * about having matched imperfectly before, so we can&n;&t;&t;&t; * free name and set *res to NULL.&n;&t;&t;&t; * However, if the perfect match is a short file name,&n;&t;&t;&t; * we need to signal this through *res, so that&n;&t;&t;&t; * ntfs_lookup() can fix dcache aliasing issues.&n;&t;&t;&t; * As an optimization we just reuse an existing&n;&t;&t;&t; * allocation of *res.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|ie-&gt;key.file_name.file_name_type
op_eq
id|FILE_NAME_DOS
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|name
)paren
(brace
id|name
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|ntfs_name
)paren
comma
id|GFP_NOFS
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|name
)paren
(brace
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
)brace
id|name-&gt;mref
op_assign
id|le64_to_cpu
c_func
(paren
id|ie-&gt;data.dir.indexed_file
)paren
suffix:semicolon
id|name-&gt;type
op_assign
id|FILE_NAME_DOS
suffix:semicolon
id|name-&gt;len
op_assign
l_int|0
suffix:semicolon
op_star
id|res
op_assign
id|name
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|name
)paren
id|kfree
c_func
(paren
id|name
)paren
suffix:semicolon
op_star
id|res
op_assign
l_int|NULL
suffix:semicolon
)brace
id|mref
op_assign
id|le64_to_cpu
c_func
(paren
id|ie-&gt;data.dir.indexed_file
)paren
suffix:semicolon
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|ntfs_unmap_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
id|mref
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * For a case insensitive mount, we also perform a case&n;&t;&t; * insensitive comparison (provided the file name is not in the&n;&t;&t; * POSIX namespace). If the comparison matches, and the name is&n;&t;&t; * in the WIN32 namespace, we cache the filename in *res so&n;&t;&t; * that the caller, ntfs_lookup(), can work on it. If the&n;&t;&t; * comparison matches, and the name is in the DOS namespace, we&n;&t;&t; * only cache the mft reference and the file name type (we set&n;&t;&t; * the name length to zero for simplicity).&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|NVolCaseSensitive
c_func
(paren
id|vol
)paren
op_logical_and
id|ie-&gt;key.file_name.file_name_type
op_logical_and
id|ntfs_are_names_equal
c_func
(paren
id|uname
comma
id|uname_len
comma
(paren
id|ntfschar
op_star
)paren
op_amp
id|ie-&gt;key.file_name.file_name
comma
id|ie-&gt;key.file_name.file_name_length
comma
id|IGNORE_CASE
comma
id|vol-&gt;upcase
comma
id|vol-&gt;upcase_len
)paren
)paren
(brace
r_int
id|name_size
op_assign
r_sizeof
(paren
id|ntfs_name
)paren
suffix:semicolon
id|u8
id|type
op_assign
id|ie-&gt;key.file_name.file_name_type
suffix:semicolon
id|u8
id|len
op_assign
id|ie-&gt;key.file_name.file_name_length
suffix:semicolon
multiline_comment|/* Only one case insensitive matching name allowed. */
r_if
c_cond
(paren
id|name
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Found already allocated name &quot;
l_string|&quot;in phase 2. Please run chkdsk &quot;
l_string|&quot;and if that doesn&squot;t find any &quot;
l_string|&quot;errors please report you saw &quot;
l_string|&quot;this message to &quot;
l_string|&quot;linux-ntfs-dev@lists.&quot;
l_string|&quot;sourceforge.net.&quot;
)paren
suffix:semicolon
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|ntfs_unmap_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_goto
id|dir_err_out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|type
op_ne
id|FILE_NAME_DOS
)paren
id|name_size
op_add_assign
id|len
op_star
r_sizeof
(paren
id|ntfschar
)paren
suffix:semicolon
id|name
op_assign
id|kmalloc
c_func
(paren
id|name_size
comma
id|GFP_NOFS
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|name
)paren
(brace
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
id|name-&gt;mref
op_assign
id|le64_to_cpu
c_func
(paren
id|ie-&gt;data.dir.indexed_file
)paren
suffix:semicolon
id|name-&gt;type
op_assign
id|type
suffix:semicolon
r_if
c_cond
(paren
id|type
op_ne
id|FILE_NAME_DOS
)paren
(brace
id|name-&gt;len
op_assign
id|len
suffix:semicolon
id|memcpy
c_func
(paren
id|name-&gt;name
comma
id|ie-&gt;key.file_name.file_name
comma
id|len
op_star
r_sizeof
(paren
id|ntfschar
)paren
)paren
suffix:semicolon
)brace
r_else
id|name-&gt;len
op_assign
l_int|0
suffix:semicolon
op_star
id|res
op_assign
id|name
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Not a perfect match, need to do full blown collation so we&n;&t;&t; * know which way in the B+tree we have to go.&n;&t;&t; */
id|rc
op_assign
id|ntfs_collate_names
c_func
(paren
id|uname
comma
id|uname_len
comma
(paren
id|ntfschar
op_star
)paren
op_amp
id|ie-&gt;key.file_name.file_name
comma
id|ie-&gt;key.file_name.file_name_length
comma
l_int|1
comma
id|IGNORE_CASE
comma
id|vol-&gt;upcase
comma
id|vol-&gt;upcase_len
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If uname collates before the name of the current entry, there&n;&t;&t; * is definitely no such name in this index but we might need to&n;&t;&t; * descend into the B+tree so we just break out of the loop.&n;&t;&t; */
r_if
c_cond
(paren
id|rc
op_eq
op_minus
l_int|1
)paren
r_break
suffix:semicolon
multiline_comment|/* The names are not equal, continue the search. */
r_if
c_cond
(paren
id|rc
)paren
r_continue
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Names match with case insensitive comparison, now try the&n;&t;&t; * case sensitive comparison, which is required for proper&n;&t;&t; * collation.&n;&t;&t; */
id|rc
op_assign
id|ntfs_collate_names
c_func
(paren
id|uname
comma
id|uname_len
comma
(paren
id|ntfschar
op_star
)paren
op_amp
id|ie-&gt;key.file_name.file_name
comma
id|ie-&gt;key.file_name.file_name_length
comma
l_int|1
comma
id|CASE_SENSITIVE
comma
id|vol-&gt;upcase
comma
id|vol-&gt;upcase_len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_eq
op_minus
l_int|1
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_continue
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Perfect match, this will never happen as the&n;&t;&t; * ntfs_are_names_equal() call will have gotten a match but we&n;&t;&t; * still treat it correctly.&n;&t;&t; */
r_goto
id|found_it2
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * We have finished with this index buffer without success. Check for&n;&t; * the presence of a child node.&n;&t; */
r_if
c_cond
(paren
id|ie-&gt;flags
op_amp
id|INDEX_ENTRY_NODE
)paren
(brace
r_if
c_cond
(paren
(paren
id|ia-&gt;index.flags
op_amp
id|NODE_MASK
)paren
op_eq
id|LEAF_NODE
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Index entry with child node found in &quot;
l_string|&quot;a leaf node in directory inode 0x%lx.&quot;
comma
id|dir_ni-&gt;mft_no
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
multiline_comment|/* Child node present, descend into it. */
id|old_vcn
op_assign
id|vcn
suffix:semicolon
id|vcn
op_assign
id|sle64_to_cpup
c_func
(paren
(paren
id|sle64
op_star
)paren
(paren
(paren
id|u8
op_star
)paren
id|ie
op_plus
id|le16_to_cpu
c_func
(paren
id|ie-&gt;length
)paren
op_minus
l_int|8
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vcn
op_ge
l_int|0
)paren
(brace
multiline_comment|/* If vcn is in the same page cache page as old_vcn we&n;&t;&t;&t; * recycle the mapped page. */
r_if
c_cond
(paren
id|old_vcn
op_lshift
id|vol-&gt;cluster_size_bits
op_rshift
id|PAGE_CACHE_SHIFT
op_eq
id|vcn
op_lshift
id|vol-&gt;cluster_size_bits
op_rshift
id|PAGE_CACHE_SHIFT
)paren
r_goto
id|fast_descend_into_child_node
suffix:semicolon
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|ntfs_unmap_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_goto
id|descend_into_child_node
suffix:semicolon
)brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Negative child node vcn in directory inode &quot;
l_string|&quot;0x%lx.&quot;
comma
id|dir_ni-&gt;mft_no
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * No child node present, return -ENOENT, unless we have got a matching&n;&t; * name cached in name in which case return the mft reference&n;&t; * associated with it.&n;&t; */
r_if
c_cond
(paren
id|name
)paren
(brace
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|ntfs_unmap_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
id|name-&gt;mref
suffix:semicolon
)brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Entry not found.&quot;
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|ENOENT
suffix:semicolon
id|unm_err_out
suffix:colon
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|ntfs_unmap_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|err_out
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|err
)paren
id|err
op_assign
op_minus
id|EIO
suffix:semicolon
r_if
c_cond
(paren
id|ctx
)paren
id|ntfs_attr_put_search_ctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|m
)paren
id|unmap_mft_record
c_func
(paren
id|dir_ni
)paren
suffix:semicolon
r_if
c_cond
(paren
id|name
)paren
(brace
id|kfree
c_func
(paren
id|name
)paren
suffix:semicolon
op_star
id|res
op_assign
l_int|NULL
suffix:semicolon
)brace
r_return
id|ERR_MREF
c_func
(paren
id|err
)paren
suffix:semicolon
id|dir_err_out
suffix:colon
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Corrupt directory.  Aborting lookup.&quot;
)paren
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
macro_line|#if 0
singleline_comment|// TODO: (AIA)
singleline_comment|// The algorithm embedded in this code will be required for the time when we
singleline_comment|// want to support adding of entries to directories, where we require correct
singleline_comment|// collation of file names in order not to cause corruption of the file system.
multiline_comment|/**&n; * ntfs_lookup_inode_by_name - find an inode in a directory given its name&n; * @dir_ni:&t;ntfs inode of the directory in which to search for the name&n; * @uname:&t;Unicode name for which to search in the directory&n; * @uname_len:&t;length of the name @uname in Unicode characters&n; *&n; * Look for an inode with name @uname in the directory with inode @dir_ni.&n; * ntfs_lookup_inode_by_name() walks the contents of the directory looking for&n; * the Unicode name. If the name is found in the directory, the corresponding&n; * inode number (&gt;= 0) is returned as a mft reference in cpu format, i.e. it&n; * is a 64-bit number containing the sequence number.&n; *&n; * On error, a negative value is returned corresponding to the error code. In&n; * particular if the inode is not found -ENOENT is returned. Note that you&n; * can&squot;t just check the return value for being negative, you have to check the&n; * inode number for being negative which you can extract using MREC(return&n; * value).&n; *&n; * Note, @uname_len does not include the (optional) terminating NULL character.&n; */
id|u64
id|ntfs_lookup_inode_by_name
c_func
(paren
id|ntfs_inode
op_star
id|dir_ni
comma
r_const
id|ntfschar
op_star
id|uname
comma
r_const
r_int
id|uname_len
)paren
(brace
id|ntfs_volume
op_star
id|vol
op_assign
id|dir_ni-&gt;vol
suffix:semicolon
r_struct
id|super_block
op_star
id|sb
op_assign
id|vol-&gt;sb
suffix:semicolon
id|MFT_RECORD
op_star
id|m
suffix:semicolon
id|INDEX_ROOT
op_star
id|ir
suffix:semicolon
id|INDEX_ENTRY
op_star
id|ie
suffix:semicolon
id|INDEX_ALLOCATION
op_star
id|ia
suffix:semicolon
id|u8
op_star
id|index_end
suffix:semicolon
id|u64
id|mref
suffix:semicolon
id|ntfs_attr_search_ctx
op_star
id|ctx
suffix:semicolon
r_int
id|err
comma
id|rc
suffix:semicolon
id|IGNORE_CASE_BOOL
id|ic
suffix:semicolon
id|VCN
id|vcn
comma
id|old_vcn
suffix:semicolon
r_struct
id|address_space
op_star
id|ia_mapping
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
id|u8
op_star
id|kaddr
suffix:semicolon
multiline_comment|/* Get hold of the mft record for the directory. */
id|m
op_assign
id|map_mft_record
c_func
(paren
id|dir_ni
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|m
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;map_mft_record() failed with error code %ld.&quot;
comma
op_minus
id|PTR_ERR
c_func
(paren
id|m
)paren
)paren
suffix:semicolon
r_return
id|ERR_MREF
c_func
(paren
id|PTR_ERR
c_func
(paren
id|m
)paren
)paren
suffix:semicolon
)brace
id|ctx
op_assign
id|ntfs_attr_get_search_ctx
c_func
(paren
id|dir_ni
comma
id|m
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ctx
)paren
(brace
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
multiline_comment|/* Find the index root attribute in the mft record. */
id|err
op_assign
id|ntfs_attr_lookup
c_func
(paren
id|AT_INDEX_ROOT
comma
id|I30
comma
l_int|4
comma
id|CASE_SENSITIVE
comma
l_int|0
comma
l_int|NULL
comma
l_int|0
comma
id|ctx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|err
)paren
)paren
(brace
r_if
c_cond
(paren
id|err
op_eq
op_minus
id|ENOENT
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Index root attribute missing in &quot;
l_string|&quot;directory inode 0x%lx.&quot;
comma
id|dir_ni-&gt;mft_no
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
r_goto
id|err_out
suffix:semicolon
)brace
multiline_comment|/* Get to the index root value (it&squot;s been verified in read_inode). */
id|ir
op_assign
(paren
id|INDEX_ROOT
op_star
)paren
(paren
(paren
id|u8
op_star
)paren
id|ctx-&gt;attr
op_plus
id|le16_to_cpu
c_func
(paren
id|ctx-&gt;attr-&gt;data.resident.value_offset
)paren
)paren
suffix:semicolon
id|index_end
op_assign
(paren
id|u8
op_star
)paren
op_amp
id|ir-&gt;index
op_plus
id|le32_to_cpu
c_func
(paren
id|ir-&gt;index.index_length
)paren
suffix:semicolon
multiline_comment|/* The first index entry. */
id|ie
op_assign
(paren
id|INDEX_ENTRY
op_star
)paren
(paren
(paren
id|u8
op_star
)paren
op_amp
id|ir-&gt;index
op_plus
id|le32_to_cpu
c_func
(paren
id|ir-&gt;index.entries_offset
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Loop until we exceed valid memory (corruption case) or until we&n;&t; * reach the last entry.&n;&t; */
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
id|ie
op_assign
(paren
id|INDEX_ENTRY
op_star
)paren
(paren
(paren
id|u8
op_star
)paren
id|ie
op_plus
id|le16_to_cpu
c_func
(paren
id|ie-&gt;length
)paren
)paren
)paren
(brace
multiline_comment|/* Bounds checks. */
r_if
c_cond
(paren
(paren
id|u8
op_star
)paren
id|ie
template_param
id|index_end
op_logical_or
(paren
id|u8
op_star
)paren
id|ie
op_plus
id|le16_to_cpu
c_func
(paren
id|ie-&gt;key_length
)paren
OG
id|index_end
)paren
r_goto
id|dir_err_out
suffix:semicolon
multiline_comment|/*&n;&t;&t; * The last entry cannot contain a name. It can however contain&n;&t;&t; * a pointer to a child node in the B+tree so we just break out.&n;&t;&t; */
r_if
c_cond
(paren
id|ie-&gt;flags
op_amp
id|INDEX_ENTRY_END
)paren
r_break
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If the current entry has a name type of POSIX, the name is&n;&t;&t; * case sensitive and not otherwise. This has the effect of us&n;&t;&t; * not being able to access any POSIX file names which collate&n;&t;&t; * after the non-POSIX one when they only differ in case, but&n;&t;&t; * anyone doing screwy stuff like that deserves to burn in&n;&t;&t; * hell... Doing that kind of stuff on NT4 actually causes&n;&t;&t; * corruption on the partition even when using SP6a and Linux&n;&t;&t; * is not involved at all.&n;&t;&t; */
id|ic
op_assign
id|ie-&gt;key.file_name.file_name_type
ques
c_cond
id|IGNORE_CASE
suffix:colon
id|CASE_SENSITIVE
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If the names match perfectly, we are done and return the&n;&t;&t; * mft reference of the inode (i.e. the inode number together&n;&t;&t; * with the sequence number for consistency checking. We&n;&t;&t; * convert it to cpu format before returning.&n;&t;&t; */
r_if
c_cond
(paren
id|ntfs_are_names_equal
c_func
(paren
id|uname
comma
id|uname_len
comma
(paren
id|ntfschar
op_star
)paren
op_amp
id|ie-&gt;key.file_name.file_name
comma
id|ie-&gt;key.file_name.file_name_length
comma
id|ic
comma
id|vol-&gt;upcase
comma
id|vol-&gt;upcase_len
)paren
)paren
(brace
id|found_it
suffix:colon
id|mref
op_assign
id|le64_to_cpu
c_func
(paren
id|ie-&gt;data.dir.indexed_file
)paren
suffix:semicolon
id|ntfs_attr_put_search_ctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
id|unmap_mft_record
c_func
(paren
id|dir_ni
)paren
suffix:semicolon
r_return
id|mref
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Not a perfect match, need to do full blown collation so we&n;&t;&t; * know which way in the B+tree we have to go.&n;&t;&t; */
id|rc
op_assign
id|ntfs_collate_names
c_func
(paren
id|uname
comma
id|uname_len
comma
(paren
id|ntfschar
op_star
)paren
op_amp
id|ie-&gt;key.file_name.file_name
comma
id|ie-&gt;key.file_name.file_name_length
comma
l_int|1
comma
id|IGNORE_CASE
comma
id|vol-&gt;upcase
comma
id|vol-&gt;upcase_len
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If uname collates before the name of the current entry, there&n;&t;&t; * is definitely no such name in this index but we might need to&n;&t;&t; * descend into the B+tree so we just break out of the loop.&n;&t;&t; */
r_if
c_cond
(paren
id|rc
op_eq
op_minus
l_int|1
)paren
r_break
suffix:semicolon
multiline_comment|/* The names are not equal, continue the search. */
r_if
c_cond
(paren
id|rc
)paren
r_continue
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Names match with case insensitive comparison, now try the&n;&t;&t; * case sensitive comparison, which is required for proper&n;&t;&t; * collation.&n;&t;&t; */
id|rc
op_assign
id|ntfs_collate_names
c_func
(paren
id|uname
comma
id|uname_len
comma
(paren
id|ntfschar
op_star
)paren
op_amp
id|ie-&gt;key.file_name.file_name
comma
id|ie-&gt;key.file_name.file_name_length
comma
l_int|1
comma
id|CASE_SENSITIVE
comma
id|vol-&gt;upcase
comma
id|vol-&gt;upcase_len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_eq
op_minus
l_int|1
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_continue
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Perfect match, this will never happen as the&n;&t;&t; * ntfs_are_names_equal() call will have gotten a match but we&n;&t;&t; * still treat it correctly.&n;&t;&t; */
r_goto
id|found_it
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * We have finished with this index without success. Check for the&n;&t; * presence of a child node.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|ie-&gt;flags
op_amp
id|INDEX_ENTRY_NODE
)paren
)paren
(brace
multiline_comment|/* No child node, return -ENOENT. */
id|err
op_assign
op_minus
id|ENOENT
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
multiline_comment|/* Child node present, descend into it. */
multiline_comment|/* Consistency check: Verify that an index allocation exists. */
r_if
c_cond
(paren
op_logical_neg
id|NInoIndexAllocPresent
c_func
(paren
id|dir_ni
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;No index allocation attribute but index entry &quot;
l_string|&quot;requires one. Directory inode 0x%lx is &quot;
l_string|&quot;corrupt or driver bug.&quot;
comma
id|dir_ni-&gt;mft_no
)paren
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
multiline_comment|/* Get the starting vcn of the index_block holding the child node. */
id|vcn
op_assign
id|sle64_to_cpup
c_func
(paren
(paren
id|u8
op_star
)paren
id|ie
op_plus
id|le16_to_cpu
c_func
(paren
id|ie-&gt;length
)paren
op_minus
l_int|8
)paren
suffix:semicolon
id|ia_mapping
op_assign
id|VFS_I
c_func
(paren
id|dir_ni
)paren
op_member_access_from_pointer
id|i_mapping
suffix:semicolon
multiline_comment|/*&n;&t; * We are done with the index root and the mft record. Release them,&n;&t; * otherwise we deadlock with ntfs_map_page().&n;&t; */
id|ntfs_attr_put_search_ctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
id|unmap_mft_record
c_func
(paren
id|dir_ni
)paren
suffix:semicolon
id|m
op_assign
l_int|NULL
suffix:semicolon
id|ctx
op_assign
l_int|NULL
suffix:semicolon
id|descend_into_child_node
suffix:colon
multiline_comment|/*&n;&t; * Convert vcn to index into the index allocation attribute in units&n;&t; * of PAGE_CACHE_SIZE and map the page cache page, reading it from&n;&t; * disk if necessary.&n;&t; */
id|page
op_assign
id|ntfs_map_page
c_func
(paren
id|ia_mapping
comma
id|vcn
op_lshift
id|dir_ni-&gt;itype.index.vcn_size_bits
op_rshift
id|PAGE_CACHE_SHIFT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|page
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Failed to map directory index page, error %ld.&quot;
comma
op_minus
id|PTR_ERR
c_func
(paren
id|page
)paren
)paren
suffix:semicolon
id|err
op_assign
id|PTR_ERR
c_func
(paren
id|page
)paren
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
id|lock_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|kaddr
op_assign
(paren
id|u8
op_star
)paren
id|page_address
c_func
(paren
id|page
)paren
suffix:semicolon
id|fast_descend_into_child_node
suffix:colon
multiline_comment|/* Get to the index allocation block. */
id|ia
op_assign
(paren
id|INDEX_ALLOCATION
op_star
)paren
(paren
id|kaddr
op_plus
(paren
(paren
id|vcn
op_lshift
id|dir_ni-&gt;itype.index.vcn_size_bits
)paren
op_amp
op_complement
id|PAGE_CACHE_MASK
)paren
)paren
suffix:semicolon
multiline_comment|/* Bounds checks. */
r_if
c_cond
(paren
(paren
id|u8
op_star
)paren
id|ia
template_param
id|kaddr
op_plus
id|PAGE_CACHE_SIZE
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Out of bounds check failed. Corrupt directory &quot;
l_string|&quot;inode 0x%lx or driver bug.&quot;
comma
id|dir_ni-&gt;mft_no
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
multiline_comment|/* Catch multi sector transfer fixup errors. */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|ntfs_is_indx_record
c_func
(paren
id|ia-&gt;magic
)paren
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Directory index record with vcn 0x%llx is &quot;
l_string|&quot;corrupt.  Corrupt inode 0x%lx.  Run chkdsk.&quot;
comma
(paren
r_int
r_int
r_int
)paren
id|vcn
comma
id|dir_ni-&gt;mft_no
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sle64_to_cpu
c_func
(paren
id|ia-&gt;index_block_vcn
)paren
op_ne
id|vcn
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Actual VCN (0x%llx) of index buffer is &quot;
l_string|&quot;different from expected VCN (0x%llx). &quot;
l_string|&quot;Directory inode 0x%lx is corrupt or driver &quot;
l_string|&quot;bug.&quot;
comma
(paren
r_int
r_int
r_int
)paren
id|sle64_to_cpu
c_func
(paren
id|ia-&gt;index_block_vcn
)paren
comma
(paren
r_int
r_int
r_int
)paren
id|vcn
comma
id|dir_ni-&gt;mft_no
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|le32_to_cpu
c_func
(paren
id|ia-&gt;index.allocated_size
)paren
op_plus
l_int|0x18
op_ne
id|dir_ni-&gt;itype.index.block_size
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Index buffer (VCN 0x%llx) of directory inode &quot;
l_string|&quot;0x%lx has a size (%u) differing from the &quot;
l_string|&quot;directory specified size (%u). Directory &quot;
l_string|&quot;inode is corrupt or driver bug.&quot;
comma
(paren
r_int
r_int
r_int
)paren
id|vcn
comma
id|dir_ni-&gt;mft_no
comma
id|le32_to_cpu
c_func
(paren
id|ia-&gt;index.allocated_size
)paren
op_plus
l_int|0x18
comma
id|dir_ni-&gt;itype.index.block_size
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
id|index_end
op_assign
(paren
id|u8
op_star
)paren
id|ia
op_plus
id|dir_ni-&gt;itype.index.block_size
suffix:semicolon
r_if
c_cond
(paren
id|index_end
OG
id|kaddr
op_plus
id|PAGE_CACHE_SIZE
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Index buffer (VCN 0x%llx) of directory inode &quot;
l_string|&quot;0x%lx crosses page boundary. Impossible! &quot;
l_string|&quot;Cannot access! This is probably a bug in the &quot;
l_string|&quot;driver.&quot;
comma
(paren
r_int
r_int
r_int
)paren
id|vcn
comma
id|dir_ni-&gt;mft_no
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
id|index_end
op_assign
(paren
id|u8
op_star
)paren
op_amp
id|ia-&gt;index
op_plus
id|le32_to_cpu
c_func
(paren
id|ia-&gt;index.index_length
)paren
suffix:semicolon
r_if
c_cond
(paren
id|index_end
OG
(paren
id|u8
op_star
)paren
id|ia
op_plus
id|dir_ni-&gt;itype.index.block_size
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Size of index buffer (VCN 0x%llx) of directory &quot;
l_string|&quot;inode 0x%lx exceeds maximum size.&quot;
comma
(paren
r_int
r_int
r_int
)paren
id|vcn
comma
id|dir_ni-&gt;mft_no
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
multiline_comment|/* The first index entry. */
id|ie
op_assign
(paren
id|INDEX_ENTRY
op_star
)paren
(paren
(paren
id|u8
op_star
)paren
op_amp
id|ia-&gt;index
op_plus
id|le32_to_cpu
c_func
(paren
id|ia-&gt;index.entries_offset
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Iterate similar to above big loop but applied to index buffer, thus&n;&t; * loop until we exceed valid memory (corruption case) or until we&n;&t; * reach the last entry.&n;&t; */
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
id|ie
op_assign
(paren
id|INDEX_ENTRY
op_star
)paren
(paren
(paren
id|u8
op_star
)paren
id|ie
op_plus
id|le16_to_cpu
c_func
(paren
id|ie-&gt;length
)paren
)paren
)paren
(brace
multiline_comment|/* Bounds check. */
r_if
c_cond
(paren
(paren
id|u8
op_star
)paren
id|ie
template_param
id|index_end
op_logical_or
(paren
id|u8
op_star
)paren
id|ie
op_plus
id|le16_to_cpu
c_func
(paren
id|ie-&gt;key_length
)paren
OG
id|index_end
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Index entry out of bounds in &quot;
l_string|&quot;directory inode 0x%lx.&quot;
comma
id|dir_ni-&gt;mft_no
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * The last entry cannot contain a name. It can however contain&n;&t;&t; * a pointer to a child node in the B+tree so we just break out.&n;&t;&t; */
r_if
c_cond
(paren
id|ie-&gt;flags
op_amp
id|INDEX_ENTRY_END
)paren
r_break
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If the current entry has a name type of POSIX, the name is&n;&t;&t; * case sensitive and not otherwise. This has the effect of us&n;&t;&t; * not being able to access any POSIX file names which collate&n;&t;&t; * after the non-POSIX one when they only differ in case, but&n;&t;&t; * anyone doing screwy stuff like that deserves to burn in&n;&t;&t; * hell... Doing that kind of stuff on NT4 actually causes&n;&t;&t; * corruption on the partition even when using SP6a and Linux&n;&t;&t; * is not involved at all.&n;&t;&t; */
id|ic
op_assign
id|ie-&gt;key.file_name.file_name_type
ques
c_cond
id|IGNORE_CASE
suffix:colon
id|CASE_SENSITIVE
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If the names match perfectly, we are done and return the&n;&t;&t; * mft reference of the inode (i.e. the inode number together&n;&t;&t; * with the sequence number for consistency checking. We&n;&t;&t; * convert it to cpu format before returning.&n;&t;&t; */
r_if
c_cond
(paren
id|ntfs_are_names_equal
c_func
(paren
id|uname
comma
id|uname_len
comma
(paren
id|ntfschar
op_star
)paren
op_amp
id|ie-&gt;key.file_name.file_name
comma
id|ie-&gt;key.file_name.file_name_length
comma
id|ic
comma
id|vol-&gt;upcase
comma
id|vol-&gt;upcase_len
)paren
)paren
(brace
id|found_it2
suffix:colon
id|mref
op_assign
id|le64_to_cpu
c_func
(paren
id|ie-&gt;data.dir.indexed_file
)paren
suffix:semicolon
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|ntfs_unmap_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
id|mref
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Not a perfect match, need to do full blown collation so we&n;&t;&t; * know which way in the B+tree we have to go.&n;&t;&t; */
id|rc
op_assign
id|ntfs_collate_names
c_func
(paren
id|uname
comma
id|uname_len
comma
(paren
id|ntfschar
op_star
)paren
op_amp
id|ie-&gt;key.file_name.file_name
comma
id|ie-&gt;key.file_name.file_name_length
comma
l_int|1
comma
id|IGNORE_CASE
comma
id|vol-&gt;upcase
comma
id|vol-&gt;upcase_len
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If uname collates before the name of the current entry, there&n;&t;&t; * is definitely no such name in this index but we might need to&n;&t;&t; * descend into the B+tree so we just break out of the loop.&n;&t;&t; */
r_if
c_cond
(paren
id|rc
op_eq
op_minus
l_int|1
)paren
r_break
suffix:semicolon
multiline_comment|/* The names are not equal, continue the search. */
r_if
c_cond
(paren
id|rc
)paren
r_continue
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Names match with case insensitive comparison, now try the&n;&t;&t; * case sensitive comparison, which is required for proper&n;&t;&t; * collation.&n;&t;&t; */
id|rc
op_assign
id|ntfs_collate_names
c_func
(paren
id|uname
comma
id|uname_len
comma
(paren
id|ntfschar
op_star
)paren
op_amp
id|ie-&gt;key.file_name.file_name
comma
id|ie-&gt;key.file_name.file_name_length
comma
l_int|1
comma
id|CASE_SENSITIVE
comma
id|vol-&gt;upcase
comma
id|vol-&gt;upcase_len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_eq
op_minus
l_int|1
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_continue
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Perfect match, this will never happen as the&n;&t;&t; * ntfs_are_names_equal() call will have gotten a match but we&n;&t;&t; * still treat it correctly.&n;&t;&t; */
r_goto
id|found_it2
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * We have finished with this index buffer without success. Check for&n;&t; * the presence of a child node.&n;&t; */
r_if
c_cond
(paren
id|ie-&gt;flags
op_amp
id|INDEX_ENTRY_NODE
)paren
(brace
r_if
c_cond
(paren
(paren
id|ia-&gt;index.flags
op_amp
id|NODE_MASK
)paren
op_eq
id|LEAF_NODE
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Index entry with child node found in &quot;
l_string|&quot;a leaf node in directory inode 0x%lx.&quot;
comma
id|dir_ni-&gt;mft_no
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
multiline_comment|/* Child node present, descend into it. */
id|old_vcn
op_assign
id|vcn
suffix:semicolon
id|vcn
op_assign
id|sle64_to_cpup
c_func
(paren
(paren
id|u8
op_star
)paren
id|ie
op_plus
id|le16_to_cpu
c_func
(paren
id|ie-&gt;length
)paren
op_minus
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vcn
op_ge
l_int|0
)paren
(brace
multiline_comment|/* If vcn is in the same page cache page as old_vcn we&n;&t;&t;&t; * recycle the mapped page. */
r_if
c_cond
(paren
id|old_vcn
op_lshift
id|vol-&gt;cluster_size_bits
op_rshift
id|PAGE_CACHE_SHIFT
op_eq
id|vcn
op_lshift
id|vol-&gt;cluster_size_bits
op_rshift
id|PAGE_CACHE_SHIFT
)paren
r_goto
id|fast_descend_into_child_node
suffix:semicolon
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|ntfs_unmap_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_goto
id|descend_into_child_node
suffix:semicolon
)brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Negative child node vcn in directory inode &quot;
l_string|&quot;0x%lx.&quot;
comma
id|dir_ni-&gt;mft_no
)paren
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
multiline_comment|/* No child node, return -ENOENT. */
id|ntfs_debug
c_func
(paren
l_string|&quot;Entry not found.&quot;
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|ENOENT
suffix:semicolon
id|unm_err_out
suffix:colon
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|ntfs_unmap_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|err_out
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|err
)paren
id|err
op_assign
op_minus
id|EIO
suffix:semicolon
r_if
c_cond
(paren
id|ctx
)paren
id|ntfs_attr_put_search_ctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|m
)paren
id|unmap_mft_record
c_func
(paren
id|dir_ni
)paren
suffix:semicolon
r_return
id|ERR_MREF
c_func
(paren
id|err
)paren
suffix:semicolon
id|dir_err_out
suffix:colon
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Corrupt directory. Aborting lookup.&quot;
)paren
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/**&n; * ntfs_filldir - ntfs specific filldir method&n; * @vol:&t;current ntfs volume&n; * @fpos:&t;position in the directory&n; * @ndir:&t;ntfs inode of current directory&n; * @ia_page:&t;page in which the index allocation buffer @ie is in resides&n; * @ie:&t;&t;current index entry&n; * @name:&t;buffer to use for the converted name&n; * @dirent:&t;vfs filldir callback context&n; * @filldir:&t;vfs filldir callback&n; *&n; * Convert the Unicode @name to the loaded NLS and pass it to the @filldir&n; * callback.&n; *&n; * If @ia_page is not NULL it is the locked page containing the index&n; * allocation block containing the index entry @ie.&n; *&n; * Note, we drop (and then reacquire) the page lock on @ia_page across the&n; * @filldir() call otherwise we would deadlock with NFSd when it calls -&gt;lookup&n; * since ntfs_lookup() will lock the same page.  As an optimization, we do not&n; * retake the lock if we are returning a non-zero value as ntfs_readdir()&n; * would need to drop the lock immediately anyway.&n; */
DECL|function|ntfs_filldir
r_static
r_inline
r_int
id|ntfs_filldir
c_func
(paren
id|ntfs_volume
op_star
id|vol
comma
id|loff_t
id|fpos
comma
id|ntfs_inode
op_star
id|ndir
comma
r_struct
id|page
op_star
id|ia_page
comma
id|INDEX_ENTRY
op_star
id|ie
comma
id|u8
op_star
id|name
comma
r_void
op_star
id|dirent
comma
id|filldir_t
id|filldir
)paren
(brace
r_int
r_int
id|mref
suffix:semicolon
r_int
id|name_len
comma
id|rc
suffix:semicolon
r_int
id|dt_type
suffix:semicolon
id|FILE_NAME_TYPE_FLAGS
id|name_type
suffix:semicolon
id|name_type
op_assign
id|ie-&gt;key.file_name.file_name_type
suffix:semicolon
r_if
c_cond
(paren
id|name_type
op_eq
id|FILE_NAME_DOS
)paren
(brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Skipping DOS name space entry.&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|MREF_LE
c_func
(paren
id|ie-&gt;data.dir.indexed_file
)paren
op_eq
id|FILE_root
)paren
(brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Skipping root directory self reference entry.&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|MREF_LE
c_func
(paren
id|ie-&gt;data.dir.indexed_file
)paren
OL
id|FILE_first_user
op_logical_and
op_logical_neg
id|NVolShowSystemFiles
c_func
(paren
id|vol
)paren
)paren
(brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Skipping system file.&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|name_len
op_assign
id|ntfs_ucstonls
c_func
(paren
id|vol
comma
(paren
id|ntfschar
op_star
)paren
op_amp
id|ie-&gt;key.file_name.file_name
comma
id|ie-&gt;key.file_name.file_name_length
comma
op_amp
id|name
comma
id|NTFS_MAX_NAME_LEN
op_star
id|NLS_MAX_CHARSET_SIZE
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|name_len
op_le
l_int|0
)paren
(brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Skipping unrepresentable file.&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ie-&gt;key.file_name.file_attributes
op_amp
id|FILE_ATTR_DUP_FILE_NAME_INDEX_PRESENT
)paren
id|dt_type
op_assign
id|DT_DIR
suffix:semicolon
r_else
id|dt_type
op_assign
id|DT_REG
suffix:semicolon
id|mref
op_assign
id|MREF_LE
c_func
(paren
id|ie-&gt;data.dir.indexed_file
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Drop the page lock otherwise we deadlock with NFS when it calls&n;&t; * -&gt;lookup since ntfs_lookup() will lock the same page.&n;&t; */
r_if
c_cond
(paren
id|ia_page
)paren
id|unlock_page
c_func
(paren
id|ia_page
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Calling filldir for %s with len %i, fpos 0x%llx, inode &quot;
l_string|&quot;0x%lx, DT_%s.&quot;
comma
id|name
comma
id|name_len
comma
id|fpos
comma
id|mref
comma
id|dt_type
op_eq
id|DT_DIR
ques
c_cond
l_string|&quot;DIR&quot;
suffix:colon
l_string|&quot;REG&quot;
)paren
suffix:semicolon
id|rc
op_assign
id|filldir
c_func
(paren
id|dirent
comma
id|name
comma
id|name_len
comma
id|fpos
comma
id|mref
comma
id|dt_type
)paren
suffix:semicolon
multiline_comment|/* Relock the page but not if we are aborting -&gt;readdir. */
r_if
c_cond
(paren
op_logical_neg
id|rc
op_logical_and
id|ia_page
)paren
id|lock_page
c_func
(paren
id|ia_page
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/*&n; * We use the same basic approach as the old NTFS driver, i.e. we parse the&n; * index root entries and then the index allocation entries that are marked&n; * as in use in the index bitmap.&n; *&n; * While this will return the names in random order this doesn&squot;t matter for&n; * -&gt;readdir but OTOH results in a faster -&gt;readdir.&n; *&n; * VFS calls -&gt;readdir without BKL but with i_sem held. This protects the VFS&n; * parts (e.g. -&gt;f_pos and -&gt;i_size, and it also protects against directory&n; * modifications).&n; *&n; * Locking:  - Caller must hold i_sem on the directory.&n; *&t;     - Each page cache page in the index allocation mapping must be&n; *&t;       locked whilst being accessed otherwise we may find a corrupt&n; *&t;       page due to it being under -&gt;writepage at the moment which&n; *&t;       applies the mst protection fixups before writing out and then&n; *&t;       removes them again after the write is complete after which it &n; *&t;       unlocks the page.&n; */
DECL|function|ntfs_readdir
r_static
r_int
id|ntfs_readdir
c_func
(paren
r_struct
id|file
op_star
id|filp
comma
r_void
op_star
id|dirent
comma
id|filldir_t
id|filldir
)paren
(brace
id|s64
id|ia_pos
comma
id|ia_start
comma
id|prev_ia_pos
comma
id|bmp_pos
suffix:semicolon
id|loff_t
id|fpos
suffix:semicolon
r_struct
id|inode
op_star
id|bmp_vi
comma
op_star
id|vdir
op_assign
id|filp-&gt;f_dentry-&gt;d_inode
suffix:semicolon
r_struct
id|super_block
op_star
id|sb
op_assign
id|vdir-&gt;i_sb
suffix:semicolon
id|ntfs_inode
op_star
id|ndir
op_assign
id|NTFS_I
c_func
(paren
id|vdir
)paren
suffix:semicolon
id|ntfs_volume
op_star
id|vol
op_assign
id|NTFS_SB
c_func
(paren
id|sb
)paren
suffix:semicolon
id|MFT_RECORD
op_star
id|m
suffix:semicolon
id|INDEX_ROOT
op_star
id|ir
op_assign
l_int|NULL
suffix:semicolon
id|INDEX_ENTRY
op_star
id|ie
suffix:semicolon
id|INDEX_ALLOCATION
op_star
id|ia
suffix:semicolon
id|u8
op_star
id|name
op_assign
l_int|NULL
suffix:semicolon
r_int
id|rc
comma
id|err
comma
id|ir_pos
comma
id|cur_bmp_pos
suffix:semicolon
r_struct
id|address_space
op_star
id|ia_mapping
comma
op_star
id|bmp_mapping
suffix:semicolon
r_struct
id|page
op_star
id|bmp_page
op_assign
l_int|NULL
comma
op_star
id|ia_page
op_assign
l_int|NULL
suffix:semicolon
id|u8
op_star
id|kaddr
comma
op_star
id|bmp
comma
op_star
id|index_end
suffix:semicolon
id|ntfs_attr_search_ctx
op_star
id|ctx
suffix:semicolon
id|fpos
op_assign
id|filp-&gt;f_pos
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Entering for inode 0x%lx, fpos 0x%llx.&quot;
comma
id|vdir-&gt;i_ino
comma
id|fpos
)paren
suffix:semicolon
id|rc
op_assign
id|err
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Are we at end of dir yet? */
r_if
c_cond
(paren
id|fpos
op_ge
id|vdir-&gt;i_size
op_plus
id|vol-&gt;mft_record_size
)paren
r_goto
id|done
suffix:semicolon
multiline_comment|/* Emulate . and .. for all directories. */
r_if
c_cond
(paren
op_logical_neg
id|fpos
)paren
(brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Calling filldir for . with len 1, fpos 0x0, &quot;
l_string|&quot;inode 0x%lx, DT_DIR.&quot;
comma
id|vdir-&gt;i_ino
)paren
suffix:semicolon
id|rc
op_assign
id|filldir
c_func
(paren
id|dirent
comma
l_string|&quot;.&quot;
comma
l_int|1
comma
id|fpos
comma
id|vdir-&gt;i_ino
comma
id|DT_DIR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_goto
id|done
suffix:semicolon
id|fpos
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|fpos
op_eq
l_int|1
)paren
(brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Calling filldir for .. with len 2, fpos 0x1, &quot;
l_string|&quot;inode 0x%lx, DT_DIR.&quot;
comma
id|parent_ino
c_func
(paren
id|filp-&gt;f_dentry
)paren
)paren
suffix:semicolon
id|rc
op_assign
id|filldir
c_func
(paren
id|dirent
comma
l_string|&quot;..&quot;
comma
l_int|2
comma
id|fpos
comma
id|parent_ino
c_func
(paren
id|filp-&gt;f_dentry
)paren
comma
id|DT_DIR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_goto
id|done
suffix:semicolon
id|fpos
op_increment
suffix:semicolon
)brace
id|m
op_assign
l_int|NULL
suffix:semicolon
id|ctx
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * Allocate a buffer to store the current name being processed&n;&t; * converted to format determined by current NLS.&n;&t; */
id|name
op_assign
(paren
id|u8
op_star
)paren
id|kmalloc
c_func
(paren
id|NTFS_MAX_NAME_LEN
op_star
id|NLS_MAX_CHARSET_SIZE
op_plus
l_int|1
comma
id|GFP_NOFS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|name
)paren
)paren
(brace
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
multiline_comment|/* Are we jumping straight into the index allocation attribute? */
r_if
c_cond
(paren
id|fpos
op_ge
id|vol-&gt;mft_record_size
)paren
r_goto
id|skip_index_root
suffix:semicolon
multiline_comment|/* Get hold of the mft record for the directory. */
id|m
op_assign
id|map_mft_record
c_func
(paren
id|ndir
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|m
)paren
)paren
(brace
id|err
op_assign
id|PTR_ERR
c_func
(paren
id|m
)paren
suffix:semicolon
id|m
op_assign
l_int|NULL
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
id|ctx
op_assign
id|ntfs_attr_get_search_ctx
c_func
(paren
id|ndir
comma
id|m
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|ctx
)paren
)paren
(brace
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
multiline_comment|/* Get the offset into the index root attribute. */
id|ir_pos
op_assign
(paren
id|s64
)paren
id|fpos
suffix:semicolon
multiline_comment|/* Find the index root attribute in the mft record. */
id|err
op_assign
id|ntfs_attr_lookup
c_func
(paren
id|AT_INDEX_ROOT
comma
id|I30
comma
l_int|4
comma
id|CASE_SENSITIVE
comma
l_int|0
comma
l_int|NULL
comma
l_int|0
comma
id|ctx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|err
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Index root attribute missing in directory &quot;
l_string|&quot;inode 0x%lx.&quot;
comma
id|vdir-&gt;i_ino
)paren
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Copy the index root attribute value to a buffer so that we can put&n;&t; * the search context and unmap the mft record before calling the&n;&t; * filldir() callback.  We need to do this because of NFSd which calls&n;&t; * -&gt;lookup() from its filldir callback() and this causes NTFS to&n;&t; * deadlock as ntfs_lookup() maps the mft record of the directory and&n;&t; * we have got it mapped here already.  The only solution is for us to&n;&t; * unmap the mft record here so that a call to ntfs_lookup() is able to&n;&t; * map the mft record without deadlocking.&n;&t; */
id|rc
op_assign
id|le32_to_cpu
c_func
(paren
id|ctx-&gt;attr-&gt;data.resident.value_length
)paren
suffix:semicolon
id|ir
op_assign
(paren
id|INDEX_ROOT
op_star
)paren
id|kmalloc
c_func
(paren
id|rc
comma
id|GFP_NOFS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|ir
)paren
)paren
(brace
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
multiline_comment|/* Copy the index root value (it has been verified in read_inode). */
id|memcpy
c_func
(paren
id|ir
comma
(paren
id|u8
op_star
)paren
id|ctx-&gt;attr
op_plus
id|le16_to_cpu
c_func
(paren
id|ctx-&gt;attr-&gt;data.resident.value_offset
)paren
comma
id|rc
)paren
suffix:semicolon
id|ntfs_attr_put_search_ctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
id|unmap_mft_record
c_func
(paren
id|ndir
)paren
suffix:semicolon
id|ctx
op_assign
l_int|NULL
suffix:semicolon
id|m
op_assign
l_int|NULL
suffix:semicolon
id|index_end
op_assign
(paren
id|u8
op_star
)paren
op_amp
id|ir-&gt;index
op_plus
id|le32_to_cpu
c_func
(paren
id|ir-&gt;index.index_length
)paren
suffix:semicolon
multiline_comment|/* The first index entry. */
id|ie
op_assign
(paren
id|INDEX_ENTRY
op_star
)paren
(paren
(paren
id|u8
op_star
)paren
op_amp
id|ir-&gt;index
op_plus
id|le32_to_cpu
c_func
(paren
id|ir-&gt;index.entries_offset
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Loop until we exceed valid memory (corruption case) or until we&n;&t; * reach the last entry or until filldir tells us it has had enough&n;&t; * or signals an error (both covered by the rc test).&n;&t; */
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
id|ie
op_assign
(paren
id|INDEX_ENTRY
op_star
)paren
(paren
(paren
id|u8
op_star
)paren
id|ie
op_plus
id|le16_to_cpu
c_func
(paren
id|ie-&gt;length
)paren
)paren
)paren
(brace
id|ntfs_debug
c_func
(paren
l_string|&quot;In index root, offset 0x%zx.&quot;
comma
(paren
id|u8
op_star
)paren
id|ie
op_minus
(paren
id|u8
op_star
)paren
id|ir
)paren
suffix:semicolon
multiline_comment|/* Bounds checks. */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
(paren
id|u8
op_star
)paren
id|ie
template_param
id|index_end
op_logical_or
(paren
id|u8
op_star
)paren
id|ie
op_plus
id|le16_to_cpu
c_func
(paren
id|ie-&gt;key_length
)paren
OG
id|index_end
)paren
)paren
r_goto
id|err_out
suffix:semicolon
multiline_comment|/* The last entry cannot contain a name. */
r_if
c_cond
(paren
id|ie-&gt;flags
op_amp
id|INDEX_ENTRY_END
)paren
r_break
suffix:semicolon
multiline_comment|/* Skip index root entry if continuing previous readdir. */
r_if
c_cond
(paren
id|ir_pos
OG
(paren
id|u8
op_star
)paren
id|ie
op_minus
(paren
id|u8
op_star
)paren
id|ir
)paren
r_continue
suffix:semicolon
multiline_comment|/* Advance the position even if going to skip the entry. */
id|fpos
op_assign
(paren
id|u8
op_star
)paren
id|ie
op_minus
(paren
id|u8
op_star
)paren
id|ir
suffix:semicolon
multiline_comment|/* Submit the name to the filldir callback. */
id|rc
op_assign
id|ntfs_filldir
c_func
(paren
id|vol
comma
id|fpos
comma
id|ndir
comma
l_int|NULL
comma
id|ie
comma
id|name
comma
id|dirent
comma
id|filldir
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
(brace
id|kfree
c_func
(paren
id|ir
)paren
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
)brace
multiline_comment|/* We are done with the index root and can free the buffer. */
id|kfree
c_func
(paren
id|ir
)paren
suffix:semicolon
id|ir
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* If there is no index allocation attribute we are finished. */
r_if
c_cond
(paren
op_logical_neg
id|NInoIndexAllocPresent
c_func
(paren
id|ndir
)paren
)paren
r_goto
id|EOD
suffix:semicolon
multiline_comment|/* Advance fpos to the beginning of the index allocation. */
id|fpos
op_assign
id|vol-&gt;mft_record_size
suffix:semicolon
id|skip_index_root
suffix:colon
id|kaddr
op_assign
l_int|NULL
suffix:semicolon
id|prev_ia_pos
op_assign
op_minus
l_int|1LL
suffix:semicolon
multiline_comment|/* Get the offset into the index allocation attribute. */
id|ia_pos
op_assign
(paren
id|s64
)paren
id|fpos
op_minus
id|vol-&gt;mft_record_size
suffix:semicolon
id|ia_mapping
op_assign
id|vdir-&gt;i_mapping
suffix:semicolon
id|bmp_vi
op_assign
id|ndir-&gt;itype.index.bmp_ino
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|bmp_vi
)paren
)paren
(brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Inode 0x%lx, regetting index bitmap.&quot;
comma
id|vdir-&gt;i_ino
)paren
suffix:semicolon
id|bmp_vi
op_assign
id|ntfs_attr_iget
c_func
(paren
id|vdir
comma
id|AT_BITMAP
comma
id|I30
comma
l_int|4
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|bmp_vi
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Failed to get bitmap attribute.&quot;
)paren
suffix:semicolon
id|err
op_assign
id|PTR_ERR
c_func
(paren
id|bmp_vi
)paren
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
id|ndir-&gt;itype.index.bmp_ino
op_assign
id|bmp_vi
suffix:semicolon
)brace
id|bmp_mapping
op_assign
id|bmp_vi-&gt;i_mapping
suffix:semicolon
multiline_comment|/* Get the starting bitmap bit position and sanity check it. */
id|bmp_pos
op_assign
id|ia_pos
op_rshift
id|ndir-&gt;itype.index.block_size_bits
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|bmp_pos
op_rshift
l_int|3
op_ge
id|bmp_vi-&gt;i_size
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Current index allocation position exceeds &quot;
l_string|&quot;index bitmap size.&quot;
)paren
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
multiline_comment|/* Get the starting bit position in the current bitmap page. */
id|cur_bmp_pos
op_assign
id|bmp_pos
op_amp
(paren
(paren
id|PAGE_CACHE_SIZE
op_star
l_int|8
)paren
op_minus
l_int|1
)paren
suffix:semicolon
id|bmp_pos
op_and_assign
op_complement
(paren
id|u64
)paren
(paren
(paren
id|PAGE_CACHE_SIZE
op_star
l_int|8
)paren
op_minus
l_int|1
)paren
suffix:semicolon
id|get_next_bmp_page
suffix:colon
id|ntfs_debug
c_func
(paren
l_string|&quot;Reading bitmap with page index 0x%llx, bit ofs 0x%llx&quot;
comma
(paren
r_int
r_int
r_int
)paren
id|bmp_pos
op_rshift
(paren
l_int|3
op_plus
id|PAGE_CACHE_SHIFT
)paren
comma
(paren
r_int
r_int
r_int
)paren
id|bmp_pos
op_amp
(paren
r_int
r_int
r_int
)paren
(paren
(paren
id|PAGE_CACHE_SIZE
op_star
l_int|8
)paren
op_minus
l_int|1
)paren
)paren
suffix:semicolon
id|bmp_page
op_assign
id|ntfs_map_page
c_func
(paren
id|bmp_mapping
comma
id|bmp_pos
op_rshift
(paren
l_int|3
op_plus
id|PAGE_CACHE_SHIFT
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|bmp_page
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Reading index bitmap failed.&quot;
)paren
suffix:semicolon
id|err
op_assign
id|PTR_ERR
c_func
(paren
id|bmp_page
)paren
suffix:semicolon
id|bmp_page
op_assign
l_int|NULL
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
id|bmp
op_assign
(paren
id|u8
op_star
)paren
id|page_address
c_func
(paren
id|bmp_page
)paren
suffix:semicolon
multiline_comment|/* Find next index block in use. */
r_while
c_loop
(paren
op_logical_neg
(paren
id|bmp
(braket
id|cur_bmp_pos
op_rshift
l_int|3
)braket
op_amp
(paren
l_int|1
op_lshift
(paren
id|cur_bmp_pos
op_amp
l_int|7
)paren
)paren
)paren
)paren
(brace
id|find_next_index_buffer
suffix:colon
id|cur_bmp_pos
op_increment
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If we have reached the end of the bitmap page, get the next&n;&t;&t; * page, and put away the old one.&n;&t;&t; */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
(paren
id|cur_bmp_pos
op_rshift
l_int|3
)paren
op_ge
id|PAGE_CACHE_SIZE
)paren
)paren
(brace
id|ntfs_unmap_page
c_func
(paren
id|bmp_page
)paren
suffix:semicolon
id|bmp_pos
op_add_assign
id|PAGE_CACHE_SIZE
op_star
l_int|8
suffix:semicolon
id|cur_bmp_pos
op_assign
l_int|0
suffix:semicolon
r_goto
id|get_next_bmp_page
suffix:semicolon
)brace
multiline_comment|/* If we have reached the end of the bitmap, we are done. */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
(paren
(paren
id|bmp_pos
op_plus
id|cur_bmp_pos
)paren
op_rshift
l_int|3
)paren
op_ge
id|vdir-&gt;i_size
)paren
)paren
r_goto
id|unm_EOD
suffix:semicolon
id|ia_pos
op_assign
(paren
id|bmp_pos
op_plus
id|cur_bmp_pos
)paren
op_lshift
id|ndir-&gt;itype.index.block_size_bits
suffix:semicolon
)brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Handling index buffer 0x%llx.&quot;
comma
(paren
r_int
r_int
r_int
)paren
id|bmp_pos
op_plus
id|cur_bmp_pos
)paren
suffix:semicolon
multiline_comment|/* If the current index buffer is in the same page we reuse the page. */
r_if
c_cond
(paren
(paren
id|prev_ia_pos
op_amp
id|PAGE_CACHE_MASK
)paren
op_ne
(paren
id|ia_pos
op_amp
id|PAGE_CACHE_MASK
)paren
)paren
(brace
id|prev_ia_pos
op_assign
id|ia_pos
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
id|ia_page
op_ne
l_int|NULL
)paren
)paren
(brace
id|unlock_page
c_func
(paren
id|ia_page
)paren
suffix:semicolon
id|ntfs_unmap_page
c_func
(paren
id|ia_page
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Map the page cache page containing the current ia_pos,&n;&t;&t; * reading it from disk if necessary.&n;&t;&t; */
id|ia_page
op_assign
id|ntfs_map_page
c_func
(paren
id|ia_mapping
comma
id|ia_pos
op_rshift
id|PAGE_CACHE_SHIFT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|ia_page
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Reading index allocation data failed.&quot;
)paren
suffix:semicolon
id|err
op_assign
id|PTR_ERR
c_func
(paren
id|ia_page
)paren
suffix:semicolon
id|ia_page
op_assign
l_int|NULL
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
id|lock_page
c_func
(paren
id|ia_page
)paren
suffix:semicolon
id|kaddr
op_assign
(paren
id|u8
op_star
)paren
id|page_address
c_func
(paren
id|ia_page
)paren
suffix:semicolon
)brace
multiline_comment|/* Get the current index buffer. */
id|ia
op_assign
(paren
id|INDEX_ALLOCATION
op_star
)paren
(paren
id|kaddr
op_plus
(paren
id|ia_pos
op_amp
op_complement
id|PAGE_CACHE_MASK
op_amp
op_complement
(paren
id|s64
)paren
(paren
id|ndir-&gt;itype.index.block_size
op_minus
l_int|1
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/* Bounds checks. */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
(paren
id|u8
op_star
)paren
id|ia
template_param
id|kaddr
op_plus
id|PAGE_CACHE_SIZE
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Out of bounds check failed. Corrupt directory &quot;
l_string|&quot;inode 0x%lx or driver bug.&quot;
comma
id|vdir-&gt;i_ino
)paren
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
multiline_comment|/* Catch multi sector transfer fixup errors. */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|ntfs_is_indx_record
c_func
(paren
id|ia-&gt;magic
)paren
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Directory index record with vcn 0x%llx is &quot;
l_string|&quot;corrupt.  Corrupt inode 0x%lx.  Run chkdsk.&quot;
comma
(paren
r_int
r_int
r_int
)paren
id|ia_pos
op_rshift
id|ndir-&gt;itype.index.vcn_size_bits
comma
id|vdir-&gt;i_ino
)paren
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|sle64_to_cpu
c_func
(paren
id|ia-&gt;index_block_vcn
)paren
op_ne
(paren
id|ia_pos
op_amp
op_complement
(paren
id|s64
)paren
(paren
id|ndir-&gt;itype.index.block_size
op_minus
l_int|1
)paren
)paren
op_rshift
id|ndir-&gt;itype.index.vcn_size_bits
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Actual VCN (0x%llx) of index buffer is &quot;
l_string|&quot;different from expected VCN (0x%llx). &quot;
l_string|&quot;Directory inode 0x%lx is corrupt or driver &quot;
l_string|&quot;bug. &quot;
comma
(paren
r_int
r_int
r_int
)paren
id|sle64_to_cpu
c_func
(paren
id|ia-&gt;index_block_vcn
)paren
comma
(paren
r_int
r_int
r_int
)paren
id|ia_pos
op_rshift
id|ndir-&gt;itype.index.vcn_size_bits
comma
id|vdir-&gt;i_ino
)paren
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|le32_to_cpu
c_func
(paren
id|ia-&gt;index.allocated_size
)paren
op_plus
l_int|0x18
op_ne
id|ndir-&gt;itype.index.block_size
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Index buffer (VCN 0x%llx) of directory inode &quot;
l_string|&quot;0x%lx has a size (%u) differing from the &quot;
l_string|&quot;directory specified size (%u). Directory &quot;
l_string|&quot;inode is corrupt or driver bug.&quot;
comma
(paren
r_int
r_int
r_int
)paren
id|ia_pos
op_rshift
id|ndir-&gt;itype.index.vcn_size_bits
comma
id|vdir-&gt;i_ino
comma
id|le32_to_cpu
c_func
(paren
id|ia-&gt;index.allocated_size
)paren
op_plus
l_int|0x18
comma
id|ndir-&gt;itype.index.block_size
)paren
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
id|index_end
op_assign
(paren
id|u8
op_star
)paren
id|ia
op_plus
id|ndir-&gt;itype.index.block_size
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|index_end
OG
id|kaddr
op_plus
id|PAGE_CACHE_SIZE
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Index buffer (VCN 0x%llx) of directory inode &quot;
l_string|&quot;0x%lx crosses page boundary. Impossible! &quot;
l_string|&quot;Cannot access! This is probably a bug in the &quot;
l_string|&quot;driver.&quot;
comma
(paren
r_int
r_int
r_int
)paren
id|ia_pos
op_rshift
id|ndir-&gt;itype.index.vcn_size_bits
comma
id|vdir-&gt;i_ino
)paren
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
id|ia_start
op_assign
id|ia_pos
op_amp
op_complement
(paren
id|s64
)paren
(paren
id|ndir-&gt;itype.index.block_size
op_minus
l_int|1
)paren
suffix:semicolon
id|index_end
op_assign
(paren
id|u8
op_star
)paren
op_amp
id|ia-&gt;index
op_plus
id|le32_to_cpu
c_func
(paren
id|ia-&gt;index.index_length
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|index_end
OG
(paren
id|u8
op_star
)paren
id|ia
op_plus
id|ndir-&gt;itype.index.block_size
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Size of index buffer (VCN 0x%llx) of directory &quot;
l_string|&quot;inode 0x%lx exceeds maximum size.&quot;
comma
(paren
r_int
r_int
r_int
)paren
id|ia_pos
op_rshift
id|ndir-&gt;itype.index.vcn_size_bits
comma
id|vdir-&gt;i_ino
)paren
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
multiline_comment|/* The first index entry in this index buffer. */
id|ie
op_assign
(paren
id|INDEX_ENTRY
op_star
)paren
(paren
(paren
id|u8
op_star
)paren
op_amp
id|ia-&gt;index
op_plus
id|le32_to_cpu
c_func
(paren
id|ia-&gt;index.entries_offset
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Loop until we exceed valid memory (corruption case) or until we&n;&t; * reach the last entry or until filldir tells us it has had enough&n;&t; * or signals an error (both covered by the rc test).&n;&t; */
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
id|ie
op_assign
(paren
id|INDEX_ENTRY
op_star
)paren
(paren
(paren
id|u8
op_star
)paren
id|ie
op_plus
id|le16_to_cpu
c_func
(paren
id|ie-&gt;length
)paren
)paren
)paren
(brace
id|ntfs_debug
c_func
(paren
l_string|&quot;In index allocation, offset 0x%llx.&quot;
comma
(paren
r_int
r_int
r_int
)paren
id|ia_start
op_plus
(paren
r_int
r_int
r_int
)paren
(paren
(paren
id|u8
op_star
)paren
id|ie
op_minus
(paren
id|u8
op_star
)paren
id|ia
)paren
)paren
suffix:semicolon
multiline_comment|/* Bounds checks. */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
(paren
id|u8
op_star
)paren
id|ie
template_param
id|index_end
op_logical_or
(paren
id|u8
op_star
)paren
id|ie
op_plus
id|le16_to_cpu
c_func
(paren
id|ie-&gt;key_length
)paren
OG
id|index_end
)paren
)paren
r_goto
id|err_out
suffix:semicolon
multiline_comment|/* The last entry cannot contain a name. */
r_if
c_cond
(paren
id|ie-&gt;flags
op_amp
id|INDEX_ENTRY_END
)paren
r_break
suffix:semicolon
multiline_comment|/* Skip index block entry if continuing previous readdir. */
r_if
c_cond
(paren
id|ia_pos
op_minus
id|ia_start
OG
(paren
id|u8
op_star
)paren
id|ie
op_minus
(paren
id|u8
op_star
)paren
id|ia
)paren
r_continue
suffix:semicolon
multiline_comment|/* Advance the position even if going to skip the entry. */
id|fpos
op_assign
(paren
id|u8
op_star
)paren
id|ie
op_minus
(paren
id|u8
op_star
)paren
id|ia
op_plus
(paren
id|sle64_to_cpu
c_func
(paren
id|ia-&gt;index_block_vcn
)paren
op_lshift
id|ndir-&gt;itype.index.vcn_size_bits
)paren
op_plus
id|vol-&gt;mft_record_size
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Submit the name to the @filldir callback.  Note,&n;&t;&t; * ntfs_filldir() drops the lock on @ia_page but it retakes it&n;&t;&t; * before returning, unless a non-zero value is returned in&n;&t;&t; * which case the page is left unlocked.&n;&t;&t; */
id|rc
op_assign
id|ntfs_filldir
c_func
(paren
id|vol
comma
id|fpos
comma
id|ndir
comma
id|ia_page
comma
id|ie
comma
id|name
comma
id|dirent
comma
id|filldir
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
(brace
multiline_comment|/* @ia_page is already unlocked in this case. */
id|ntfs_unmap_page
c_func
(paren
id|ia_page
)paren
suffix:semicolon
id|ntfs_unmap_page
c_func
(paren
id|bmp_page
)paren
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
)brace
r_goto
id|find_next_index_buffer
suffix:semicolon
id|unm_EOD
suffix:colon
r_if
c_cond
(paren
id|ia_page
)paren
(brace
id|unlock_page
c_func
(paren
id|ia_page
)paren
suffix:semicolon
id|ntfs_unmap_page
c_func
(paren
id|ia_page
)paren
suffix:semicolon
)brace
id|ntfs_unmap_page
c_func
(paren
id|bmp_page
)paren
suffix:semicolon
id|EOD
suffix:colon
multiline_comment|/* We are finished, set fpos to EOD. */
id|fpos
op_assign
id|vdir-&gt;i_size
op_plus
id|vol-&gt;mft_record_size
suffix:semicolon
m_abort
suffix:colon
id|kfree
c_func
(paren
id|name
)paren
suffix:semicolon
id|done
suffix:colon
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
op_logical_neg
id|rc
)paren
id|ntfs_debug
c_func
(paren
l_string|&quot;EOD, fpos 0x%llx, returning 0.&quot;
comma
id|fpos
)paren
suffix:semicolon
r_else
id|ntfs_debug
c_func
(paren
l_string|&quot;filldir returned %i, fpos 0x%llx, returning 0.&quot;
comma
id|rc
comma
id|fpos
)paren
suffix:semicolon
macro_line|#endif
id|filp-&gt;f_pos
op_assign
id|fpos
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|err_out
suffix:colon
r_if
c_cond
(paren
id|bmp_page
)paren
id|ntfs_unmap_page
c_func
(paren
id|bmp_page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ia_page
)paren
(brace
id|unlock_page
c_func
(paren
id|ia_page
)paren
suffix:semicolon
id|ntfs_unmap_page
c_func
(paren
id|ia_page
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ir
)paren
id|kfree
c_func
(paren
id|ir
)paren
suffix:semicolon
r_if
c_cond
(paren
id|name
)paren
id|kfree
c_func
(paren
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ctx
)paren
id|ntfs_attr_put_search_ctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|m
)paren
id|unmap_mft_record
c_func
(paren
id|ndir
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|err
)paren
id|err
op_assign
op_minus
id|EIO
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Failed. Returning error code %i.&quot;
comma
op_minus
id|err
)paren
suffix:semicolon
id|filp-&gt;f_pos
op_assign
id|fpos
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_dir_open - called when an inode is about to be opened&n; * @vi:&t;&t;inode to be opened&n; * @filp:&t;file structure describing the inode&n; *&n; * Limit directory size to the page cache limit on architectures where unsigned&n; * long is 32-bits. This is the most we can do for now without overflowing the&n; * page cache page index. Doing it this way means we don&squot;t run into problems&n; * because of existing too large directories. It would be better to allow the&n; * user to read the accessible part of the directory but I doubt very much&n; * anyone is going to hit this check on a 32-bit architecture, so there is no&n; * point in adding the extra complexity required to support this.&n; *&n; * On 64-bit architectures, the check is hopefully optimized away by the&n; * compiler.&n; */
DECL|function|ntfs_dir_open
r_static
r_int
id|ntfs_dir_open
c_func
(paren
r_struct
id|inode
op_star
id|vi
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_if
c_cond
(paren
r_sizeof
(paren
r_int
r_int
)paren
OL
l_int|8
)paren
(brace
r_if
c_cond
(paren
id|vi-&gt;i_size
OG
id|MAX_LFS_FILESIZE
)paren
r_return
op_minus
id|EFBIG
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef NTFS_RW
multiline_comment|/**&n; * ntfs_dir_fsync - sync a directory to disk&n; * @filp:&t;directory to be synced&n; * @dentry:&t;dentry describing the directory to sync&n; * @datasync:&t;if non-zero only flush user data and not metadata&n; *&n; * Data integrity sync of a directory to disk.  Used for fsync, fdatasync, and&n; * msync system calls.  This function is based on file.c::ntfs_file_fsync().&n; *&n; * Write the mft record and all associated extent mft records as well as the&n; * $INDEX_ALLOCATION and $BITMAP attributes and then sync the block device.&n; *&n; * If @datasync is true, we do not wait on the inode(s) to be written out&n; * but we always wait on the page cache pages to be written out.&n; *&n; * Note: In the past @filp could be NULL so we ignore it as we don&squot;t need it&n; * anyway.&n; *&n; * Locking: Caller must hold i_sem on the inode.&n; *&n; * TODO: We should probably also write all attribute/index inodes associated&n; * with this inode but since we have no simple way of getting to them we ignore&n; * this problem for now.  We do write the $BITMAP attribute if it is present&n; * which is the important one for a directory so things are not too bad.&n; */
DECL|function|ntfs_dir_fsync
r_static
r_int
id|ntfs_dir_fsync
c_func
(paren
r_struct
id|file
op_star
id|filp
comma
r_struct
id|dentry
op_star
id|dentry
comma
r_int
id|datasync
)paren
(brace
r_struct
id|inode
op_star
id|vi
op_assign
id|dentry-&gt;d_inode
suffix:semicolon
id|ntfs_inode
op_star
id|ni
op_assign
id|NTFS_I
c_func
(paren
id|vi
)paren
suffix:semicolon
r_int
id|err
comma
id|ret
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Entering for inode 0x%lx.&quot;
comma
id|vi-&gt;i_ino
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|S_ISDIR
c_func
(paren
id|vi-&gt;i_mode
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|NInoIndexAllocPresent
c_func
(paren
id|ni
)paren
op_logical_and
id|ni-&gt;itype.index.bmp_ino
)paren
id|write_inode_now
c_func
(paren
id|ni-&gt;itype.index.bmp_ino
comma
op_logical_neg
id|datasync
)paren
suffix:semicolon
id|ret
op_assign
id|ntfs_write_inode
c_func
(paren
id|vi
comma
l_int|1
)paren
suffix:semicolon
id|write_inode_now
c_func
(paren
id|vi
comma
op_logical_neg
id|datasync
)paren
suffix:semicolon
id|err
op_assign
id|sync_blockdev
c_func
(paren
id|vi-&gt;i_sb-&gt;s_bdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|err
op_logical_and
op_logical_neg
id|ret
)paren
)paren
id|ret
op_assign
id|err
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
op_logical_neg
id|ret
)paren
)paren
id|ntfs_debug
c_func
(paren
l_string|&quot;Done.&quot;
)paren
suffix:semicolon
r_else
id|ntfs_warning
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Failed to f%ssync inode 0x%lx.  Error &quot;
l_string|&quot;%u.&quot;
comma
id|datasync
ques
c_cond
l_string|&quot;data&quot;
suffix:colon
l_string|&quot;&quot;
comma
id|vi-&gt;i_ino
comma
op_minus
id|ret
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
macro_line|#endif /* NTFS_RW */
DECL|variable|ntfs_dir_ops
r_struct
id|file_operations
id|ntfs_dir_ops
op_assign
(brace
dot
id|llseek
op_assign
id|generic_file_llseek
comma
multiline_comment|/* Seek inside directory. */
dot
id|read
op_assign
id|generic_read_dir
comma
multiline_comment|/* Return -EISDIR. */
dot
id|readdir
op_assign
id|ntfs_readdir
comma
multiline_comment|/* Read directory contents. */
macro_line|#ifdef NTFS_RW
dot
id|fsync
op_assign
id|ntfs_dir_fsync
comma
multiline_comment|/* Sync a directory to disk. */
multiline_comment|/*.aio_fsync&t;= ,*/
multiline_comment|/* Sync all outstanding async&n;&t;&t;&t;&t;&t;&t;   i/o operations on a kiocb. */
macro_line|#endif /* NTFS_RW */
multiline_comment|/*.ioctl&t;= ,*/
multiline_comment|/* Perform function on the&n;&t;&t;&t;&t;&t;&t;   mounted filesystem. */
dot
id|open
op_assign
id|ntfs_dir_open
comma
multiline_comment|/* Open directory. */
)brace
suffix:semicolon
eof
