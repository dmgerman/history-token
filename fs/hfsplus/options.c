multiline_comment|/*&n; *  linux/fs/hfsplus/options.c&n; *&n; * Copyright (C) 2001&n; * Brad Boyer (flar@allandria.com)&n; * (C) 2003 Ardis Technologies &lt;roman@ardistech.com&gt;&n; *&n; * Option parsing&n; */
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &quot;hfsplus_fs.h&quot;
multiline_comment|/* Initialize an options object to reasonable defaults */
DECL|function|fill_defaults
r_void
id|fill_defaults
c_func
(paren
r_struct
id|hfsplus_sb_info
op_star
id|opts
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|opts
)paren
r_return
suffix:semicolon
id|opts-&gt;creator
op_assign
id|HFSPLUS_DEF_CR_TYPE
suffix:semicolon
id|opts-&gt;type
op_assign
id|HFSPLUS_DEF_CR_TYPE
suffix:semicolon
id|opts-&gt;umask
op_assign
id|current-&gt;fs-&gt;umask
suffix:semicolon
id|opts-&gt;uid
op_assign
id|current-&gt;uid
suffix:semicolon
id|opts-&gt;gid
op_assign
id|current-&gt;gid
suffix:semicolon
id|opts-&gt;part
op_assign
op_minus
l_int|1
suffix:semicolon
id|opts-&gt;session
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* convert a &quot;four byte character&quot; to a 32 bit int with error checks */
DECL|function|fill_fourchar
r_static
r_int
id|fill_fourchar
c_func
(paren
id|u32
op_star
id|result
comma
r_char
op_star
id|input
)paren
(brace
id|u32
id|out
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|result
op_logical_or
op_logical_neg
id|input
op_logical_or
op_logical_neg
op_star
id|input
op_logical_or
(paren
id|strlen
c_func
(paren
id|input
)paren
op_ne
l_int|4
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|out
op_assign
l_int|0
comma
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
id|i
op_increment
)paren
(brace
id|out
op_lshift_assign
l_int|8
suffix:semicolon
id|out
op_or_assign
(paren
(paren
r_int
)paren
(paren
id|input
(braket
id|i
)braket
)paren
)paren
op_amp
l_int|0xFF
suffix:semicolon
)brace
op_star
id|result
op_assign
id|out
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* convert a string to int with error checks */
DECL|function|fill_int
r_static
r_int
id|fill_int
c_func
(paren
r_int
op_star
id|result
comma
r_char
op_star
id|input
comma
r_int
id|base
)paren
(brace
r_char
op_star
id|tmp
op_assign
id|input
suffix:semicolon
r_int
id|intval
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|result
op_logical_or
op_logical_neg
id|input
op_logical_or
op_logical_neg
op_star
id|input
)paren
r_return
l_int|0
suffix:semicolon
id|intval
op_assign
id|simple_strtoul
c_func
(paren
id|tmp
comma
op_amp
id|tmp
comma
id|base
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|tmp
)paren
r_return
l_int|0
suffix:semicolon
op_star
id|result
op_assign
id|intval
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Parse options from mount. Returns 0 on failure */
multiline_comment|/* input is the options passed to mount() as a string */
DECL|function|parse_options
r_int
id|parse_options
c_func
(paren
r_char
op_star
id|input
comma
r_struct
id|hfsplus_sb_info
op_star
id|results
)paren
(brace
r_char
op_star
id|curropt
comma
op_star
id|value
suffix:semicolon
r_int
id|tmp
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|input
)paren
r_return
l_int|1
suffix:semicolon
r_while
c_loop
(paren
(paren
id|curropt
op_assign
id|strsep
c_func
(paren
op_amp
id|input
comma
l_string|&quot;,&quot;
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
op_star
id|curropt
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
(paren
id|value
op_assign
id|strchr
c_func
(paren
id|curropt
comma
l_char|&squot;=&squot;
)paren
)paren
op_ne
l_int|NULL
)paren
op_star
id|value
op_increment
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|curropt
comma
l_string|&quot;creator&quot;
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|fill_fourchar
c_func
(paren
op_amp
(paren
id|results-&gt;creator
)paren
comma
id|value
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;HFS+-fs: creator requires a 4 character value&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|curropt
comma
l_string|&quot;type&quot;
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|fill_fourchar
c_func
(paren
op_amp
(paren
id|results-&gt;type
)paren
comma
id|value
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;HFS+-fs: type requires a 4 character value&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|curropt
comma
l_string|&quot;umask&quot;
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|fill_int
c_func
(paren
op_amp
id|tmp
comma
id|value
comma
l_int|8
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;HFS+-fs: umask requires a value&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|results-&gt;umask
op_assign
(paren
id|umode_t
)paren
id|tmp
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|curropt
comma
l_string|&quot;uid&quot;
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|fill_int
c_func
(paren
op_amp
id|tmp
comma
id|value
comma
l_int|0
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;HFS+-fs: uid requires an argument&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|results-&gt;uid
op_assign
(paren
id|uid_t
)paren
id|tmp
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|curropt
comma
l_string|&quot;gid&quot;
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|fill_int
c_func
(paren
op_amp
id|tmp
comma
id|value
comma
l_int|0
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;HFS+-fs: gid requires an argument&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|results-&gt;gid
op_assign
(paren
id|gid_t
)paren
id|tmp
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|curropt
comma
l_string|&quot;part&quot;
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|fill_int
c_func
(paren
op_amp
id|results-&gt;part
comma
id|value
comma
l_int|0
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;HFS+-fs: part requires an argument&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|curropt
comma
l_string|&quot;session&quot;
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|fill_int
c_func
(paren
op_amp
id|results-&gt;session
comma
id|value
comma
l_int|0
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;HFS+-fs: session requires an argument&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;HFS+-fs: unknown option %s&bslash;n&quot;
comma
id|curropt
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_return
l_int|1
suffix:semicolon
)brace
eof
