multiline_comment|/*&n; *  linux/fs/ext3/inode.c&n; *&n; * Copyright (C) 1992, 1993, 1994, 1995&n; * Remy Card (card@masi.ibp.fr)&n; * Laboratoire MASI - Institut Blaise Pascal&n; * Universite Pierre et Marie Curie (Paris VI)&n; *&n; *  from&n; *&n; *  linux/fs/minix/inode.c&n; *&n; *  Copyright (C) 1991, 1992  Linus Torvalds&n; *&n; *  Goal-directed block allocation by Stephen Tweedie&n; * &t;(sct@redhat.com), 1993, 1998&n; *  Big-endian to little-endian byte-swapping/bitmaps by&n; *        David S. Miller (davem@caip.rutgers.edu), 1995&n; *  64-bit file support on 64-bit platforms by Jakub Jelinek&n; * &t;(jj@sunsite.ms.mff.cuni.cz)&n; *&n; *  Assorted race fixes, rewrite of ext3_get_block() by Al Viro, 2000&n; */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/time.h&gt;
macro_line|#include &lt;linux/ext3_jbd.h&gt;
macro_line|#include &lt;linux/jbd.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/highuid.h&gt;
macro_line|#include &lt;linux/pagemap.h&gt;
macro_line|#include &lt;linux/quotaops.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/buffer_head.h&gt;
macro_line|#include &lt;linux/mpage.h&gt;
multiline_comment|/*&n; * SEARCH_FROM_ZERO forces each block allocation to search from the start&n; * of the filesystem.  This is to force rapid reallocation of recently-freed&n; * blocks.  The file fragmentation is horrendous.&n; */
DECL|macro|SEARCH_FROM_ZERO
macro_line|#undef SEARCH_FROM_ZERO
multiline_comment|/* The ext3 forget function must perform a revoke if we are freeing data&n; * which has been journaled.  Metadata (eg. indirect blocks) must be&n; * revoked in all cases. &n; *&n; * &quot;bh&quot; may be NULL: a metadata block may have been freed from memory&n; * but there may still be a record of it in the journal, and that record&n; * still needs to be revoked.&n; */
DECL|function|ext3_forget
r_static
r_int
id|ext3_forget
c_func
(paren
id|handle_t
op_star
id|handle
comma
r_int
id|is_metadata
comma
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|buffer_head
op_star
id|bh
comma
r_int
id|blocknr
)paren
(brace
r_int
id|err
suffix:semicolon
id|BUFFER_TRACE
c_func
(paren
id|bh
comma
l_string|&quot;enter&quot;
)paren
suffix:semicolon
id|jbd_debug
c_func
(paren
l_int|4
comma
l_string|&quot;forgetting bh %p: is_metadata = %d, mode %o, &quot;
l_string|&quot;data mode %lx&bslash;n&quot;
comma
id|bh
comma
id|is_metadata
comma
id|inode-&gt;i_mode
comma
id|test_opt
c_func
(paren
id|inode-&gt;i_sb
comma
id|DATA_FLAGS
)paren
)paren
suffix:semicolon
multiline_comment|/* Never use the revoke function if we are doing full data&n;&t; * journaling: there is no need to, and a V1 superblock won&squot;t&n;&t; * support it.  Otherwise, only skip the revoke on un-journaled&n;&t; * data blocks. */
r_if
c_cond
(paren
id|test_opt
c_func
(paren
id|inode-&gt;i_sb
comma
id|DATA_FLAGS
)paren
op_eq
id|EXT3_MOUNT_JOURNAL_DATA
op_logical_or
(paren
op_logical_neg
id|is_metadata
op_logical_and
op_logical_neg
id|ext3_should_journal_data
c_func
(paren
id|inode
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|bh
)paren
(brace
id|BUFFER_TRACE
c_func
(paren
id|bh
comma
l_string|&quot;call journal_forget&quot;
)paren
suffix:semicolon
id|ext3_journal_forget
c_func
(paren
id|handle
comma
id|bh
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * data!=journal &amp;&amp; (is_metadata || should_journal_data(inode))&n;&t; */
id|BUFFER_TRACE
c_func
(paren
id|bh
comma
l_string|&quot;call ext3_journal_revoke&quot;
)paren
suffix:semicolon
id|err
op_assign
id|ext3_journal_revoke
c_func
(paren
id|handle
comma
id|blocknr
comma
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
id|ext3_abort
c_func
(paren
id|inode-&gt;i_sb
comma
id|__FUNCTION__
comma
l_string|&quot;error %d when attempting revoke&quot;
comma
id|err
)paren
suffix:semicolon
id|BUFFER_TRACE
c_func
(paren
id|bh
comma
l_string|&quot;exit&quot;
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/* &n; * Truncate transactions can be complex and absolutely huge.  So we need to&n; * be able to restart the transaction at a conventient checkpoint to make&n; * sure we don&squot;t overflow the journal.&n; *&n; * start_transaction gets us a new handle for a truncate transaction,&n; * and extend_transaction tries to extend the existing one a bit.  If&n; * extend fails, we need to propagate the failure up and restart the&n; * transaction in the top-level truncate loop. --sct &n; */
DECL|function|start_transaction
r_static
id|handle_t
op_star
id|start_transaction
c_func
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
r_int
id|needed
suffix:semicolon
id|handle_t
op_star
id|result
suffix:semicolon
id|needed
op_assign
id|inode-&gt;i_blocks
suffix:semicolon
r_if
c_cond
(paren
id|needed
OG
id|EXT3_MAX_TRANS_DATA
)paren
id|needed
op_assign
id|EXT3_MAX_TRANS_DATA
suffix:semicolon
id|result
op_assign
id|ext3_journal_start
c_func
(paren
id|inode
comma
id|EXT3_DATA_TRANS_BLOCKS
op_plus
id|needed
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|IS_ERR
c_func
(paren
id|result
)paren
)paren
r_return
id|result
suffix:semicolon
id|ext3_std_error
c_func
(paren
id|inode-&gt;i_sb
comma
id|PTR_ERR
c_func
(paren
id|result
)paren
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/*&n; * Try to extend this transaction for the purposes of truncation.&n; *&n; * Returns 0 if we managed to create more room.  If we can&squot;t create more&n; * room, and the transaction must be restarted we return 1.&n; */
DECL|function|try_to_extend_transaction
r_static
r_int
id|try_to_extend_transaction
c_func
(paren
id|handle_t
op_star
id|handle
comma
r_struct
id|inode
op_star
id|inode
)paren
(brace
r_int
id|needed
suffix:semicolon
r_if
c_cond
(paren
id|handle-&gt;h_buffer_credits
OG
id|EXT3_RESERVE_TRANS_BLOCKS
)paren
r_return
l_int|0
suffix:semicolon
id|needed
op_assign
id|inode-&gt;i_blocks
suffix:semicolon
r_if
c_cond
(paren
id|needed
OG
id|EXT3_MAX_TRANS_DATA
)paren
id|needed
op_assign
id|EXT3_MAX_TRANS_DATA
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ext3_journal_extend
c_func
(paren
id|handle
comma
id|EXT3_RESERVE_TRANS_BLOCKS
op_plus
id|needed
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Restart the transaction associated with *handle.  This does a commit,&n; * so before we call here everything must be consistently dirtied against&n; * this transaction.&n; */
DECL|function|ext3_journal_test_restart
r_static
r_int
id|ext3_journal_test_restart
c_func
(paren
id|handle_t
op_star
id|handle
comma
r_struct
id|inode
op_star
id|inode
)paren
(brace
r_int
id|needed
op_assign
id|inode-&gt;i_blocks
suffix:semicolon
r_if
c_cond
(paren
id|needed
OG
id|EXT3_MAX_TRANS_DATA
)paren
id|needed
op_assign
id|EXT3_MAX_TRANS_DATA
suffix:semicolon
id|jbd_debug
c_func
(paren
l_int|2
comma
l_string|&quot;restarting handle %p&bslash;n&quot;
comma
id|handle
)paren
suffix:semicolon
r_return
id|ext3_journal_restart
c_func
(paren
id|handle
comma
id|EXT3_DATA_TRANS_BLOCKS
op_plus
id|needed
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Called at each iput()&n; */
DECL|function|ext3_put_inode
r_void
id|ext3_put_inode
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
id|ext3_discard_prealloc
(paren
id|inode
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Called at the last iput() if i_nlink is zero.&n; */
DECL|function|ext3_delete_inode
r_void
id|ext3_delete_inode
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
id|handle_t
op_star
id|handle
suffix:semicolon
r_if
c_cond
(paren
id|is_bad_inode
c_func
(paren
id|inode
)paren
op_logical_or
id|inode-&gt;i_ino
op_eq
id|EXT3_ACL_IDX_INO
op_logical_or
id|inode-&gt;i_ino
op_eq
id|EXT3_ACL_DATA_INO
)paren
r_goto
id|no_delete
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|handle
op_assign
id|start_transaction
c_func
(paren
id|inode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|handle
)paren
)paren
(brace
multiline_comment|/* If we&squot;re going to skip the normal cleanup, we still&n;&t;&t; * need to make sure that the in-core orphan linked list&n;&t;&t; * is properly cleaned up. */
id|ext3_orphan_del
c_func
(paren
l_int|NULL
comma
id|inode
)paren
suffix:semicolon
id|ext3_std_error
c_func
(paren
id|inode-&gt;i_sb
comma
id|PTR_ERR
c_func
(paren
id|handle
)paren
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_goto
id|no_delete
suffix:semicolon
)brace
r_if
c_cond
(paren
id|IS_SYNC
c_func
(paren
id|inode
)paren
)paren
id|handle-&gt;h_sync
op_assign
l_int|1
suffix:semicolon
id|inode-&gt;i_size
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|inode-&gt;i_blocks
)paren
id|ext3_truncate
c_func
(paren
id|inode
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Kill off the orphan record which ext3_truncate created.&n;&t; * AKPM: I think this can be inside the above `if&squot;.&n;&t; * Note that ext3_orphan_del() has to be able to cope with the&n;&t; * deletion of a non-existent orphan - this is because we don&squot;t&n;&t; * know if ext3_truncate() actually created an orphan record.&n;&t; * (Well, we could do this if we need to, but heck - it works)&n;&t; */
id|ext3_orphan_del
c_func
(paren
id|handle
comma
id|inode
)paren
suffix:semicolon
id|EXT3_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_dtime
op_assign
id|CURRENT_TIME
suffix:semicolon
multiline_comment|/* &n;&t; * One subtle ordering requirement: if anything has gone wrong&n;&t; * (transaction abort, IO errors, whatever), then we can still&n;&t; * do these next steps (the fs will already have been marked as&n;&t; * having errors), but we can&squot;t free the inode if the mark_dirty&n;&t; * fails.  &n;&t; */
r_if
c_cond
(paren
id|ext3_mark_inode_dirty
c_func
(paren
id|handle
comma
id|inode
)paren
)paren
multiline_comment|/* If that failed, just do the required in-core inode clear. */
id|clear_inode
c_func
(paren
id|inode
)paren
suffix:semicolon
r_else
id|ext3_free_inode
c_func
(paren
id|handle
comma
id|inode
)paren
suffix:semicolon
id|ext3_journal_stop
c_func
(paren
id|handle
comma
id|inode
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
id|no_delete
suffix:colon
id|clear_inode
c_func
(paren
id|inode
)paren
suffix:semicolon
multiline_comment|/* We must guarantee clearing of inode... */
)brace
DECL|function|ext3_discard_prealloc
r_void
id|ext3_discard_prealloc
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
macro_line|#ifdef EXT3_PREALLOCATE
r_struct
id|ext3_inode_info
op_star
id|ei
op_assign
id|EXT3_I
c_func
(paren
id|inode
)paren
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Writer: -&gt;i_prealloc* */
r_if
c_cond
(paren
id|ei-&gt;i_prealloc_count
)paren
(brace
r_int
r_int
id|total
op_assign
id|ei-&gt;i_prealloc_count
suffix:semicolon
r_int
r_int
id|block
op_assign
id|ei-&gt;i_prealloc_block
suffix:semicolon
id|ei-&gt;i_prealloc_count
op_assign
l_int|0
suffix:semicolon
id|ei-&gt;i_prealloc_block
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Writer: end */
id|ext3_free_blocks
(paren
id|inode
comma
id|block
comma
id|total
)paren
suffix:semicolon
)brace
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
)brace
DECL|function|ext3_alloc_block
r_static
r_int
id|ext3_alloc_block
(paren
id|handle_t
op_star
id|handle
comma
r_struct
id|inode
op_star
id|inode
comma
r_int
r_int
id|goal
comma
r_int
op_star
id|err
)paren
(brace
macro_line|#ifdef EXT3FS_DEBUG
r_static
r_int
r_int
id|alloc_hits
op_assign
l_int|0
comma
id|alloc_attempts
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
r_int
r_int
id|result
suffix:semicolon
macro_line|#ifdef EXT3_PREALLOCATE
r_struct
id|ext3_inode_info
op_star
id|ei
op_assign
id|EXT3_I
c_func
(paren
id|inode
)paren
suffix:semicolon
multiline_comment|/* Writer: -&gt;i_prealloc* */
r_if
c_cond
(paren
id|ei-&gt;i_prealloc_count
op_logical_and
(paren
id|goal
op_eq
id|ei-&gt;i_prealloc_block
op_logical_or
id|goal
op_plus
l_int|1
op_eq
id|ei-&gt;i_prealloc_block
)paren
)paren
(brace
id|result
op_assign
id|ei-&gt;i_prealloc_block
op_increment
suffix:semicolon
id|ei-&gt;i_prealloc_count
op_decrement
suffix:semicolon
multiline_comment|/* Writer: end */
id|ext3_debug
(paren
l_string|&quot;preallocation hit (%lu/%lu).&bslash;n&quot;
comma
op_increment
id|alloc_hits
comma
op_increment
id|alloc_attempts
)paren
suffix:semicolon
)brace
r_else
(brace
id|ext3_discard_prealloc
(paren
id|inode
)paren
suffix:semicolon
id|ext3_debug
(paren
l_string|&quot;preallocation miss (%lu/%lu).&bslash;n&quot;
comma
id|alloc_hits
comma
op_increment
id|alloc_attempts
)paren
suffix:semicolon
r_if
c_cond
(paren
id|S_ISREG
c_func
(paren
id|inode-&gt;i_mode
)paren
)paren
id|result
op_assign
id|ext3_new_block
(paren
id|inode
comma
id|goal
comma
op_amp
id|ei-&gt;i_prealloc_count
comma
op_amp
id|ei-&gt;i_prealloc_block
comma
id|err
)paren
suffix:semicolon
r_else
id|result
op_assign
id|ext3_new_block
(paren
id|inode
comma
id|goal
comma
l_int|0
comma
l_int|0
comma
id|err
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * AKPM: this is somewhat sticky.  I&squot;m not surprised it was&n;&t;&t; * disabled in 2.2&squot;s ext3.  Need to integrate b_committed_data&n;&t;&t; * guarding with preallocation, if indeed preallocation is&n;&t;&t; * effective.&n;&t;&t; */
)brace
macro_line|#else
id|result
op_assign
id|ext3_new_block
(paren
id|handle
comma
id|inode
comma
id|goal
comma
l_int|0
comma
l_int|0
comma
id|err
)paren
suffix:semicolon
macro_line|#endif
r_return
id|result
suffix:semicolon
)brace
r_typedef
r_struct
(brace
DECL|member|p
id|u32
op_star
id|p
suffix:semicolon
DECL|member|key
id|u32
id|key
suffix:semicolon
DECL|member|bh
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
DECL|typedef|Indirect
)brace
id|Indirect
suffix:semicolon
DECL|function|add_chain
r_static
r_inline
r_void
id|add_chain
c_func
(paren
id|Indirect
op_star
id|p
comma
r_struct
id|buffer_head
op_star
id|bh
comma
id|u32
op_star
id|v
)paren
(brace
id|p-&gt;key
op_assign
op_star
(paren
id|p-&gt;p
op_assign
id|v
)paren
suffix:semicolon
id|p-&gt;bh
op_assign
id|bh
suffix:semicolon
)brace
DECL|function|verify_chain
r_static
r_inline
r_int
id|verify_chain
c_func
(paren
id|Indirect
op_star
id|from
comma
id|Indirect
op_star
id|to
)paren
(brace
r_while
c_loop
(paren
id|from
op_le
id|to
op_logical_and
id|from-&gt;key
op_eq
op_star
id|from-&gt;p
)paren
id|from
op_increment
suffix:semicolon
r_return
(paren
id|from
OG
id|to
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;ext3_block_to_path - parse the block number into array of offsets&n; *&t;@inode: inode in question (we are only interested in its superblock)&n; *&t;@i_block: block number to be parsed&n; *&t;@offsets: array to store the offsets in&n; *      @boundary: set this non-zero if the referred-to block is likely to be&n; *             followed (on disk) by an indirect block.&n; *&n; *&t;To store the locations of file&squot;s data ext3 uses a data structure common&n; *&t;for UNIX filesystems - tree of pointers anchored in the inode, with&n; *&t;data blocks at leaves and indirect blocks in intermediate nodes.&n; *&t;This function translates the block number into path in that tree -&n; *&t;return value is the path length and @offsets[n] is the offset of&n; *&t;pointer to (n+1)th node in the nth one. If @block is out of range&n; *&t;(negative or too large) warning is printed and zero returned.&n; *&n; *&t;Note: function doesn&squot;t find node addresses, so no IO is needed. All&n; *&t;we need to know is the capacity of indirect blocks (taken from the&n; *&t;inode-&gt;i_sb).&n; */
multiline_comment|/*&n; * Portability note: the last comparison (check that we fit into triple&n; * indirect block) is spelled differently, because otherwise on an&n; * architecture with 32-bit longs and 8Kb pages we might get into trouble&n; * if our filesystem had 8Kb blocks. We might use long long, but that would&n; * kill us on x86. Oh, well, at least the sign propagation does not matter -&n; * i_block would have to be negative in the very beginning, so we would not&n; * get there at all.&n; */
DECL|function|ext3_block_to_path
r_static
r_int
id|ext3_block_to_path
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_int
id|i_block
comma
r_int
id|offsets
(braket
l_int|4
)braket
comma
r_int
op_star
id|boundary
)paren
(brace
r_int
id|ptrs
op_assign
id|EXT3_ADDR_PER_BLOCK
c_func
(paren
id|inode-&gt;i_sb
)paren
suffix:semicolon
r_int
id|ptrs_bits
op_assign
id|EXT3_ADDR_PER_BLOCK_BITS
c_func
(paren
id|inode-&gt;i_sb
)paren
suffix:semicolon
r_const
r_int
id|direct_blocks
op_assign
id|EXT3_NDIR_BLOCKS
comma
id|indirect_blocks
op_assign
id|ptrs
comma
id|double_blocks
op_assign
(paren
l_int|1
op_lshift
(paren
id|ptrs_bits
op_star
l_int|2
)paren
)paren
suffix:semicolon
r_int
id|n
op_assign
l_int|0
suffix:semicolon
r_int
id|final
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|i_block
OL
l_int|0
)paren
(brace
id|ext3_warning
(paren
id|inode-&gt;i_sb
comma
l_string|&quot;ext3_block_to_path&quot;
comma
l_string|&quot;block &lt; 0&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|i_block
OL
id|direct_blocks
)paren
(brace
id|offsets
(braket
id|n
op_increment
)braket
op_assign
id|i_block
suffix:semicolon
id|final
op_assign
id|direct_blocks
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|i_block
op_sub_assign
id|direct_blocks
)paren
OL
id|indirect_blocks
)paren
(brace
id|offsets
(braket
id|n
op_increment
)braket
op_assign
id|EXT3_IND_BLOCK
suffix:semicolon
id|offsets
(braket
id|n
op_increment
)braket
op_assign
id|i_block
suffix:semicolon
id|final
op_assign
id|ptrs
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|i_block
op_sub_assign
id|indirect_blocks
)paren
OL
id|double_blocks
)paren
(brace
id|offsets
(braket
id|n
op_increment
)braket
op_assign
id|EXT3_DIND_BLOCK
suffix:semicolon
id|offsets
(braket
id|n
op_increment
)braket
op_assign
id|i_block
op_rshift
id|ptrs_bits
suffix:semicolon
id|offsets
(braket
id|n
op_increment
)braket
op_assign
id|i_block
op_amp
(paren
id|ptrs
op_minus
l_int|1
)paren
suffix:semicolon
id|final
op_assign
id|ptrs
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
(paren
id|i_block
op_sub_assign
id|double_blocks
)paren
op_rshift
(paren
id|ptrs_bits
op_star
l_int|2
)paren
)paren
OL
id|ptrs
)paren
(brace
id|offsets
(braket
id|n
op_increment
)braket
op_assign
id|EXT3_TIND_BLOCK
suffix:semicolon
id|offsets
(braket
id|n
op_increment
)braket
op_assign
id|i_block
op_rshift
(paren
id|ptrs_bits
op_star
l_int|2
)paren
suffix:semicolon
id|offsets
(braket
id|n
op_increment
)braket
op_assign
(paren
id|i_block
op_rshift
id|ptrs_bits
)paren
op_amp
(paren
id|ptrs
op_minus
l_int|1
)paren
suffix:semicolon
id|offsets
(braket
id|n
op_increment
)braket
op_assign
id|i_block
op_amp
(paren
id|ptrs
op_minus
l_int|1
)paren
suffix:semicolon
id|final
op_assign
id|ptrs
suffix:semicolon
)brace
r_else
(brace
id|ext3_warning
(paren
id|inode-&gt;i_sb
comma
l_string|&quot;ext3_block_to_path&quot;
comma
l_string|&quot;block &gt; big&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|boundary
)paren
op_star
id|boundary
op_assign
(paren
id|i_block
op_amp
(paren
id|ptrs
op_minus
l_int|1
)paren
)paren
op_eq
(paren
id|final
op_minus
l_int|1
)paren
suffix:semicolon
r_return
id|n
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;ext3_get_branch - read the chain of indirect blocks leading to data&n; *&t;@inode: inode in question&n; *&t;@depth: depth of the chain (1 - direct pointer, etc.)&n; *&t;@offsets: offsets of pointers in inode/indirect blocks&n; *&t;@chain: place to store the result&n; *&t;@err: here we store the error value&n; *&n; *&t;Function fills the array of triples &lt;key, p, bh&gt; and returns %NULL&n; *&t;if everything went OK or the pointer to the last filled triple&n; *&t;(incomplete one) otherwise. Upon the return chain[i].key contains&n; *&t;the number of (i+1)-th block in the chain (as it is stored in memory,&n; *&t;i.e. little-endian 32-bit), chain[i].p contains the address of that&n; *&t;number (it points into struct inode for i==0 and into the bh-&gt;b_data&n; *&t;for i&gt;0) and chain[i].bh points to the buffer_head of i-th indirect&n; *&t;block for i&gt;0 and NULL for i==0. In other words, it holds the block&n; *&t;numbers of the chain, addresses they were taken from (and where we can&n; *&t;verify that chain did not change) and buffer_heads hosting these&n; *&t;numbers.&n; *&n; *&t;Function stops when it stumbles upon zero pointer (absent block)&n; *&t;&t;(pointer to last triple returned, *@err == 0)&n; *&t;or when it gets an IO error reading an indirect block&n; *&t;&t;(ditto, *@err == -EIO)&n; *&t;or when it notices that chain had been changed while it was reading&n; *&t;&t;(ditto, *@err == -EAGAIN)&n; *&t;or when it reads all @depth-1 indirect blocks successfully and finds&n; *&t;the whole chain, all way to the data (returns %NULL, *err == 0).&n; */
DECL|function|ext3_get_branch
r_static
id|Indirect
op_star
id|ext3_get_branch
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_int
id|depth
comma
r_int
op_star
id|offsets
comma
id|Indirect
id|chain
(braket
l_int|4
)braket
comma
r_int
op_star
id|err
)paren
(brace
r_struct
id|super_block
op_star
id|sb
op_assign
id|inode-&gt;i_sb
suffix:semicolon
id|Indirect
op_star
id|p
op_assign
id|chain
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
op_star
id|err
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* i_data is not going away, no lock needed */
id|add_chain
(paren
id|chain
comma
l_int|NULL
comma
id|EXT3_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_data
op_plus
op_star
id|offsets
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p-&gt;key
)paren
r_goto
id|no_block
suffix:semicolon
r_while
c_loop
(paren
op_decrement
id|depth
)paren
(brace
id|bh
op_assign
id|sb_bread
c_func
(paren
id|sb
comma
id|le32_to_cpu
c_func
(paren
id|p-&gt;key
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bh
)paren
r_goto
id|failure
suffix:semicolon
multiline_comment|/* Reader: pointers */
r_if
c_cond
(paren
op_logical_neg
id|verify_chain
c_func
(paren
id|chain
comma
id|p
)paren
)paren
r_goto
id|changed
suffix:semicolon
id|add_chain
c_func
(paren
op_increment
id|p
comma
id|bh
comma
(paren
id|u32
op_star
)paren
id|bh-&gt;b_data
op_plus
op_star
op_increment
id|offsets
)paren
suffix:semicolon
multiline_comment|/* Reader: end */
r_if
c_cond
(paren
op_logical_neg
id|p-&gt;key
)paren
r_goto
id|no_block
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
id|changed
suffix:colon
id|brelse
c_func
(paren
id|bh
)paren
suffix:semicolon
op_star
id|err
op_assign
op_minus
id|EAGAIN
suffix:semicolon
r_goto
id|no_block
suffix:semicolon
id|failure
suffix:colon
op_star
id|err
op_assign
op_minus
id|EIO
suffix:semicolon
id|no_block
suffix:colon
r_return
id|p
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;ext3_find_near - find a place for allocation with sufficient locality&n; *&t;@inode: owner&n; *&t;@ind: descriptor of indirect block.&n; *&n; *&t;This function returns the prefered place for block allocation.&n; *&t;It is used when heuristic for sequential allocation fails.&n; *&t;Rules are:&n; *&t;  + if there is a block to the left of our position - allocate near it.&n; *&t;  + if pointer will live in indirect block - allocate near that block.&n; *&t;  + if pointer will live in inode - allocate in the same&n; *&t;    cylinder group. &n; *&t;Caller must make sure that @ind is valid and will stay that way.&n; */
DECL|function|ext3_find_near
r_static
r_inline
r_int
r_int
id|ext3_find_near
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
id|Indirect
op_star
id|ind
)paren
(brace
r_struct
id|ext3_inode_info
op_star
id|ei
op_assign
id|EXT3_I
c_func
(paren
id|inode
)paren
suffix:semicolon
id|u32
op_star
id|start
op_assign
id|ind-&gt;bh
ques
c_cond
(paren
id|u32
op_star
)paren
id|ind-&gt;bh-&gt;b_data
suffix:colon
id|ei-&gt;i_data
suffix:semicolon
id|u32
op_star
id|p
suffix:semicolon
multiline_comment|/* Try to find previous block */
r_for
c_loop
(paren
id|p
op_assign
id|ind-&gt;p
op_minus
l_int|1
suffix:semicolon
id|p
op_ge
id|start
suffix:semicolon
id|p
op_decrement
)paren
r_if
c_cond
(paren
op_star
id|p
)paren
r_return
id|le32_to_cpu
c_func
(paren
op_star
id|p
)paren
suffix:semicolon
multiline_comment|/* No such thing, so let&squot;s try location of indirect block */
r_if
c_cond
(paren
id|ind-&gt;bh
)paren
r_return
id|ind-&gt;bh-&gt;b_blocknr
suffix:semicolon
multiline_comment|/*&n;&t; * It is going to be refered from inode itself? OK, just put it into&n;&t; * the same cylinder group then.&n;&t; */
r_return
(paren
id|ei-&gt;i_block_group
op_star
id|EXT3_BLOCKS_PER_GROUP
c_func
(paren
id|inode-&gt;i_sb
)paren
)paren
op_plus
id|le32_to_cpu
c_func
(paren
id|inode-&gt;i_sb-&gt;u.ext3_sb.s_es-&gt;s_first_data_block
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;ext3_find_goal - find a prefered place for allocation.&n; *&t;@inode: owner&n; *&t;@block:  block we want&n; *&t;@chain:  chain of indirect blocks&n; *&t;@partial: pointer to the last triple within a chain&n; *&t;@goal:&t;place to store the result.&n; *&n; *&t;Normally this function find the prefered place for block allocation,&n; *&t;stores it in *@goal and returns zero. If the branch had been changed&n; *&t;under us we return -EAGAIN.&n; */
DECL|function|ext3_find_goal
r_static
r_int
id|ext3_find_goal
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_int
id|block
comma
id|Indirect
id|chain
(braket
l_int|4
)braket
comma
id|Indirect
op_star
id|partial
comma
r_int
r_int
op_star
id|goal
)paren
(brace
r_struct
id|ext3_inode_info
op_star
id|ei
op_assign
id|EXT3_I
c_func
(paren
id|inode
)paren
suffix:semicolon
multiline_comment|/* Writer: -&gt;i_next_alloc* */
r_if
c_cond
(paren
id|block
op_eq
id|ei-&gt;i_next_alloc_block
op_plus
l_int|1
)paren
(brace
id|ei-&gt;i_next_alloc_block
op_increment
suffix:semicolon
id|ei-&gt;i_next_alloc_goal
op_increment
suffix:semicolon
)brace
macro_line|#ifdef SEARCH_FROM_ZERO
id|ei-&gt;i_next_alloc_block
op_assign
l_int|0
suffix:semicolon
id|ei-&gt;i_next_alloc_goal
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
multiline_comment|/* Writer: end */
multiline_comment|/* Reader: pointers, -&gt;i_next_alloc* */
r_if
c_cond
(paren
id|verify_chain
c_func
(paren
id|chain
comma
id|partial
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * try the heuristic for sequential allocation,&n;&t;&t; * failing that at least try to get decent locality.&n;&t;&t; */
r_if
c_cond
(paren
id|block
op_eq
id|ei-&gt;i_next_alloc_block
)paren
op_star
id|goal
op_assign
id|ei-&gt;i_next_alloc_goal
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_star
id|goal
)paren
op_star
id|goal
op_assign
id|ext3_find_near
c_func
(paren
id|inode
comma
id|partial
)paren
suffix:semicolon
macro_line|#ifdef SEARCH_FROM_ZERO
op_star
id|goal
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Reader: end */
r_return
op_minus
id|EAGAIN
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;ext3_alloc_branch - allocate and set up a chain of blocks.&n; *&t;@inode: owner&n; *&t;@num: depth of the chain (number of blocks to allocate)&n; *&t;@offsets: offsets (in the blocks) to store the pointers to next.&n; *&t;@branch: place to store the chain in.&n; *&n; *&t;This function allocates @num blocks, zeroes out all but the last one,&n; *&t;links them into chain and (if we are synchronous) writes them to disk.&n; *&t;In other words, it prepares a branch that can be spliced onto the&n; *&t;inode. It stores the information about that chain in the branch[], in&n; *&t;the same format as ext3_get_branch() would do. We are calling it after&n; *&t;we had read the existing part of chain and partial points to the last&n; *&t;triple of that (one with zero -&gt;key). Upon the exit we have the same&n; *&t;picture as after the successful ext3_get_block(), excpet that in one&n; *&t;place chain is disconnected - *branch-&gt;p is still zero (we did not&n; *&t;set the last link), but branch-&gt;key contains the number that should&n; *&t;be placed into *branch-&gt;p to fill that gap.&n; *&n; *&t;If allocation fails we free all blocks we&squot;ve allocated (and forget&n; *&t;their buffer_heads) and return the error value the from failed&n; *&t;ext3_alloc_block() (normally -ENOSPC). Otherwise we set the chain&n; *&t;as described above and return 0.&n; */
DECL|function|ext3_alloc_branch
r_static
r_int
id|ext3_alloc_branch
c_func
(paren
id|handle_t
op_star
id|handle
comma
r_struct
id|inode
op_star
id|inode
comma
r_int
id|num
comma
r_int
r_int
id|goal
comma
r_int
op_star
id|offsets
comma
id|Indirect
op_star
id|branch
)paren
(brace
r_int
id|blocksize
op_assign
id|inode-&gt;i_sb-&gt;s_blocksize
suffix:semicolon
r_int
id|n
op_assign
l_int|0
comma
id|keys
op_assign
l_int|0
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|parent
op_assign
id|ext3_alloc_block
c_func
(paren
id|handle
comma
id|inode
comma
id|goal
comma
op_amp
id|err
)paren
suffix:semicolon
id|branch
(braket
l_int|0
)braket
dot
id|key
op_assign
id|cpu_to_le32
c_func
(paren
id|parent
)paren
suffix:semicolon
r_if
c_cond
(paren
id|parent
)paren
(brace
r_for
c_loop
(paren
id|n
op_assign
l_int|1
suffix:semicolon
id|n
OL
id|num
suffix:semicolon
id|n
op_increment
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
multiline_comment|/* Allocate the next block */
r_int
id|nr
op_assign
id|ext3_alloc_block
c_func
(paren
id|handle
comma
id|inode
comma
id|parent
comma
op_amp
id|err
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|nr
)paren
r_break
suffix:semicolon
id|branch
(braket
id|n
)braket
dot
id|key
op_assign
id|cpu_to_le32
c_func
(paren
id|nr
)paren
suffix:semicolon
id|keys
op_assign
id|n
op_plus
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Get buffer_head for parent block, zero it out&n;&t;&t;&t; * and set the pointer to new one, then send&n;&t;&t;&t; * parent to disk.  &n;&t;&t;&t; */
id|bh
op_assign
id|sb_getblk
c_func
(paren
id|inode-&gt;i_sb
comma
id|parent
)paren
suffix:semicolon
id|branch
(braket
id|n
)braket
dot
id|bh
op_assign
id|bh
suffix:semicolon
id|lock_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
id|BUFFER_TRACE
c_func
(paren
id|bh
comma
l_string|&quot;call get_create_access&quot;
)paren
suffix:semicolon
id|err
op_assign
id|ext3_journal_get_create_access
c_func
(paren
id|handle
comma
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|unlock_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|bh
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|memset
c_func
(paren
id|bh-&gt;b_data
comma
l_int|0
comma
id|blocksize
)paren
suffix:semicolon
id|branch
(braket
id|n
)braket
dot
id|p
op_assign
(paren
id|u32
op_star
)paren
id|bh-&gt;b_data
op_plus
id|offsets
(braket
id|n
)braket
suffix:semicolon
op_star
id|branch
(braket
id|n
)braket
dot
id|p
op_assign
id|branch
(braket
id|n
)braket
dot
id|key
suffix:semicolon
id|BUFFER_TRACE
c_func
(paren
id|bh
comma
l_string|&quot;marking uptodate&quot;
)paren
suffix:semicolon
id|set_buffer_uptodate
c_func
(paren
id|bh
)paren
suffix:semicolon
id|unlock_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
id|BUFFER_TRACE
c_func
(paren
id|bh
comma
l_string|&quot;call ext3_journal_dirty_metadata&quot;
)paren
suffix:semicolon
id|err
op_assign
id|ext3_journal_dirty_metadata
c_func
(paren
id|handle
comma
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_break
suffix:semicolon
id|parent
op_assign
id|nr
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|n
op_eq
id|num
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Allocation failed, free what we already allocated */
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|keys
suffix:semicolon
id|i
op_increment
)paren
(brace
id|BUFFER_TRACE
c_func
(paren
id|branch
(braket
id|i
)braket
dot
id|bh
comma
l_string|&quot;call journal_forget&quot;
)paren
suffix:semicolon
id|ext3_journal_forget
c_func
(paren
id|handle
comma
id|branch
(braket
id|i
)braket
dot
id|bh
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|keys
suffix:semicolon
id|i
op_increment
)paren
id|ext3_free_blocks
c_func
(paren
id|handle
comma
id|inode
comma
id|le32_to_cpu
c_func
(paren
id|branch
(braket
id|i
)braket
dot
id|key
)paren
comma
l_int|1
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;ext3_splice_branch - splice the allocated branch onto inode.&n; *&t;@inode: owner&n; *&t;@block: (logical) number of block we are adding&n; *&t;@chain: chain of indirect blocks (with a missing link - see&n; *&t;&t;ext3_alloc_branch)&n; *&t;@where: location of missing link&n; *&t;@num:   number of blocks we are adding&n; *&n; *&t;This function verifies that chain (up to the missing link) had not&n; *&t;changed, fills the missing link and does all housekeeping needed in&n; *&t;inode (-&gt;i_blocks, etc.). In case of success we end up with the full&n; *&t;chain to new block and return 0. Otherwise (== chain had been changed)&n; *&t;we free the new blocks (forgetting their buffer_heads, indeed) and&n; *&t;return -EAGAIN.&n; */
DECL|function|ext3_splice_branch
r_static
r_int
id|ext3_splice_branch
c_func
(paren
id|handle_t
op_star
id|handle
comma
r_struct
id|inode
op_star
id|inode
comma
r_int
id|block
comma
id|Indirect
id|chain
(braket
l_int|4
)braket
comma
id|Indirect
op_star
id|where
comma
r_int
id|num
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
r_struct
id|ext3_inode_info
op_star
id|ei
op_assign
id|EXT3_I
c_func
(paren
id|inode
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If we&squot;re splicing into a [td]indirect block (as opposed to the&n;&t; * inode) then we need to get write access to the [td]indirect block&n;&t; * before the splice.&n;&t; */
r_if
c_cond
(paren
id|where-&gt;bh
)paren
(brace
id|BUFFER_TRACE
c_func
(paren
id|where-&gt;bh
comma
l_string|&quot;get_write_access&quot;
)paren
suffix:semicolon
id|err
op_assign
id|ext3_journal_get_write_access
c_func
(paren
id|handle
comma
id|where-&gt;bh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|err_out
suffix:semicolon
)brace
multiline_comment|/* Verify that place we are splicing to is still there and vacant */
multiline_comment|/* Writer: pointers, -&gt;i_next_alloc* */
r_if
c_cond
(paren
op_logical_neg
id|verify_chain
c_func
(paren
id|chain
comma
id|where
op_minus
l_int|1
)paren
op_logical_or
op_star
id|where-&gt;p
)paren
multiline_comment|/* Writer: end */
r_goto
id|changed
suffix:semicolon
multiline_comment|/* That&squot;s it */
op_star
id|where-&gt;p
op_assign
id|where-&gt;key
suffix:semicolon
id|ei-&gt;i_next_alloc_block
op_assign
id|block
suffix:semicolon
id|ei-&gt;i_next_alloc_goal
op_assign
id|le32_to_cpu
c_func
(paren
id|where
(braket
id|num
op_minus
l_int|1
)braket
dot
id|key
)paren
suffix:semicolon
macro_line|#ifdef SEARCH_FROM_ZERO
id|ei-&gt;i_next_alloc_block
op_assign
l_int|0
suffix:semicolon
id|ei-&gt;i_next_alloc_goal
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
multiline_comment|/* Writer: end */
multiline_comment|/* We are done with atomic stuff, now do the rest of housekeeping */
id|inode-&gt;i_ctime
op_assign
id|CURRENT_TIME
suffix:semicolon
id|ext3_mark_inode_dirty
c_func
(paren
id|handle
comma
id|inode
)paren
suffix:semicolon
multiline_comment|/* had we spliced it onto indirect block? */
r_if
c_cond
(paren
id|where-&gt;bh
)paren
(brace
multiline_comment|/*&n;&t;&t; * akpm: If we spliced it onto an indirect block, we haven&squot;t&n;&t;&t; * altered the inode.  Note however that if it is being spliced&n;&t;&t; * onto an indirect block at the very end of the file (the&n;&t;&t; * file is growing) then we *will* alter the inode to reflect&n;&t;&t; * the new i_size.  But that is not done here - it is done in&n;&t;&t; * generic_commit_write-&gt;__mark_inode_dirty-&gt;ext3_dirty_inode.&n;&t;&t; */
id|jbd_debug
c_func
(paren
l_int|5
comma
l_string|&quot;splicing indirect only&bslash;n&quot;
)paren
suffix:semicolon
id|BUFFER_TRACE
c_func
(paren
id|where-&gt;bh
comma
l_string|&quot;call ext3_journal_dirty_metadata&quot;
)paren
suffix:semicolon
id|err
op_assign
id|ext3_journal_dirty_metadata
c_func
(paren
id|handle
comma
id|where-&gt;bh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|err_out
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * OK, we spliced it into the inode itself on a direct block.&n;&t;&t; * Inode was dirtied above.&n;&t;&t; */
id|jbd_debug
c_func
(paren
l_int|5
comma
l_string|&quot;splicing direct&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_return
id|err
suffix:semicolon
id|changed
suffix:colon
multiline_comment|/*&n;&t; * AKPM: if where[i].bh isn&squot;t part of the current updating&n;&t; * transaction then we explode nastily.  Test this code path.&n;&t; */
id|jbd_debug
c_func
(paren
l_int|1
comma
l_string|&quot;the chain changed: try again&bslash;n&quot;
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EAGAIN
suffix:semicolon
id|err_out
suffix:colon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|num
suffix:semicolon
id|i
op_increment
)paren
(brace
id|BUFFER_TRACE
c_func
(paren
id|where
(braket
id|i
)braket
dot
id|bh
comma
l_string|&quot;call journal_forget&quot;
)paren
suffix:semicolon
id|ext3_journal_forget
c_func
(paren
id|handle
comma
id|where
(braket
id|i
)braket
dot
id|bh
)paren
suffix:semicolon
)brace
multiline_comment|/* For the normal collision cleanup case, we free up the blocks.&n;&t; * On genuine filesystem errors we don&squot;t even think about doing&n;&t; * that. */
r_if
c_cond
(paren
id|err
op_eq
op_minus
id|EAGAIN
)paren
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num
suffix:semicolon
id|i
op_increment
)paren
id|ext3_free_blocks
c_func
(paren
id|handle
comma
id|inode
comma
id|le32_to_cpu
c_func
(paren
id|where
(braket
id|i
)braket
dot
id|key
)paren
comma
l_int|1
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; * Allocation strategy is simple: if we have to allocate something, we will&n; * have to go the whole way to leaf. So let&squot;s do it before attaching anything&n; * to tree, set linkage between the newborn blocks, write them if sync is&n; * required, recheck the path, free and repeat if check fails, otherwise&n; * set the last missing link (that will protect us from any truncate-generated&n; * removals - all blocks on the path are immune now) and possibly force the&n; * write on the parent block.&n; * That has a nice additional property: no special recovery from the failed&n; * allocations is needed - we simply release blocks and do not touch anything&n; * reachable from inode.&n; *&n; * akpm: `handle&squot; can be NULL if create == 0.&n; *&n; * The BKL may not be held on entry here.  Be sure to take it early.&n; */
DECL|function|ext3_get_block_handle
r_static
r_int
id|ext3_get_block_handle
c_func
(paren
id|handle_t
op_star
id|handle
comma
r_struct
id|inode
op_star
id|inode
comma
id|sector_t
id|iblock
comma
r_struct
id|buffer_head
op_star
id|bh_result
comma
r_int
id|create
)paren
(brace
r_int
id|err
op_assign
op_minus
id|EIO
suffix:semicolon
r_int
id|offsets
(braket
l_int|4
)braket
suffix:semicolon
id|Indirect
id|chain
(braket
l_int|4
)braket
suffix:semicolon
id|Indirect
op_star
id|partial
suffix:semicolon
r_int
r_int
id|goal
suffix:semicolon
r_int
id|left
suffix:semicolon
r_int
id|boundary
op_assign
l_int|0
suffix:semicolon
r_int
id|depth
op_assign
id|ext3_block_to_path
c_func
(paren
id|inode
comma
id|iblock
comma
id|offsets
comma
op_amp
id|boundary
)paren
suffix:semicolon
r_struct
id|ext3_inode_info
op_star
id|ei
op_assign
id|EXT3_I
c_func
(paren
id|inode
)paren
suffix:semicolon
id|loff_t
id|new_size
suffix:semicolon
id|J_ASSERT
c_func
(paren
id|handle
op_ne
l_int|NULL
op_logical_or
id|create
op_eq
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|depth
op_eq
l_int|0
)paren
r_goto
id|out
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|reread
suffix:colon
id|partial
op_assign
id|ext3_get_branch
c_func
(paren
id|inode
comma
id|depth
comma
id|offsets
comma
id|chain
comma
op_amp
id|err
)paren
suffix:semicolon
multiline_comment|/* Simplest case - block found, no allocation needed */
r_if
c_cond
(paren
op_logical_neg
id|partial
)paren
(brace
id|clear_buffer_new
c_func
(paren
id|bh_result
)paren
suffix:semicolon
id|got_it
suffix:colon
id|map_bh
c_func
(paren
id|bh_result
comma
id|inode-&gt;i_sb
comma
id|le32_to_cpu
c_func
(paren
id|chain
(braket
id|depth
op_minus
l_int|1
)braket
dot
id|key
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|boundary
)paren
id|set_buffer_boundary
c_func
(paren
id|bh_result
)paren
suffix:semicolon
multiline_comment|/* Clean up and exit */
id|partial
op_assign
id|chain
op_plus
id|depth
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* the whole chain */
r_goto
id|cleanup
suffix:semicolon
)brace
multiline_comment|/* Next simple case - plain lookup or failed read of indirect block */
r_if
c_cond
(paren
op_logical_neg
id|create
op_logical_or
id|err
op_eq
op_minus
id|EIO
)paren
(brace
id|cleanup
suffix:colon
r_while
c_loop
(paren
id|partial
OG
id|chain
)paren
(brace
id|BUFFER_TRACE
c_func
(paren
id|partial-&gt;bh
comma
l_string|&quot;call brelse&quot;
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|partial-&gt;bh
)paren
suffix:semicolon
id|partial
op_decrement
suffix:semicolon
)brace
id|BUFFER_TRACE
c_func
(paren
id|bh_result
comma
l_string|&quot;returned&quot;
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Indirect block might be removed by truncate while we were&n;&t; * reading it. Handling of that case (forget what we&squot;ve got and&n;&t; * reread) is taken out of the main path.&n;&t; */
r_if
c_cond
(paren
id|err
op_eq
op_minus
id|EAGAIN
)paren
r_goto
id|changed
suffix:semicolon
r_if
c_cond
(paren
id|ext3_find_goal
c_func
(paren
id|inode
comma
id|iblock
comma
id|chain
comma
id|partial
comma
op_amp
id|goal
)paren
OL
l_int|0
)paren
r_goto
id|changed
suffix:semicolon
id|left
op_assign
(paren
id|chain
op_plus
id|depth
)paren
op_minus
id|partial
suffix:semicolon
multiline_comment|/*&n;&t; * Block out ext3_truncate while we alter the tree&n;&t; */
id|down_read
c_func
(paren
op_amp
id|ei-&gt;truncate_sem
)paren
suffix:semicolon
id|err
op_assign
id|ext3_alloc_branch
c_func
(paren
id|handle
comma
id|inode
comma
id|left
comma
id|goal
comma
id|offsets
op_plus
(paren
id|partial
op_minus
id|chain
)paren
comma
id|partial
)paren
suffix:semicolon
multiline_comment|/* The ext3_splice_branch call will free and forget any buffers&n;&t; * on the new chain if there is a failure, but that risks using&n;&t; * up transaction credits, especially for bitmaps where the&n;&t; * credits cannot be returned.  Can we handle this somehow?  We&n;&t; * may need to return -EAGAIN upwards in the worst case.  --sct */
r_if
c_cond
(paren
op_logical_neg
id|err
)paren
id|err
op_assign
id|ext3_splice_branch
c_func
(paren
id|handle
comma
id|inode
comma
id|iblock
comma
id|chain
comma
id|partial
comma
id|left
)paren
suffix:semicolon
id|up_read
c_func
(paren
op_amp
id|ei-&gt;truncate_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_eq
op_minus
id|EAGAIN
)paren
r_goto
id|changed
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|cleanup
suffix:semicolon
id|new_size
op_assign
id|inode-&gt;i_size
suffix:semicolon
multiline_comment|/*&n;&t; * This is not racy against ext3_truncate&squot;s modification of i_disksize&n;&t; * because VM/VFS ensures that the file cannot be extended while&n;&t; * truncate is in progress.  It is racy between multiple parallel&n;&t; * instances of get_block, but we have the BKL.&n;&t; */
r_if
c_cond
(paren
id|new_size
OG
id|ei-&gt;i_disksize
)paren
id|ei-&gt;i_disksize
op_assign
id|new_size
suffix:semicolon
id|set_buffer_new
c_func
(paren
id|bh_result
)paren
suffix:semicolon
r_goto
id|got_it
suffix:semicolon
id|changed
suffix:colon
r_while
c_loop
(paren
id|partial
OG
id|chain
)paren
(brace
id|jbd_debug
c_func
(paren
l_int|1
comma
l_string|&quot;buffer chain changed, retrying&bslash;n&quot;
)paren
suffix:semicolon
id|BUFFER_TRACE
c_func
(paren
id|partial-&gt;bh
comma
l_string|&quot;brelsing&quot;
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|partial-&gt;bh
)paren
suffix:semicolon
id|partial
op_decrement
suffix:semicolon
)brace
r_goto
id|reread
suffix:semicolon
)brace
DECL|function|ext3_get_block
r_static
r_int
id|ext3_get_block
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
id|sector_t
id|iblock
comma
r_struct
id|buffer_head
op_star
id|bh_result
comma
r_int
id|create
)paren
(brace
id|handle_t
op_star
id|handle
op_assign
l_int|0
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_if
c_cond
(paren
id|create
)paren
(brace
id|handle
op_assign
id|ext3_journal_current_handle
c_func
(paren
)paren
suffix:semicolon
id|J_ASSERT
c_func
(paren
id|handle
op_ne
l_int|0
)paren
suffix:semicolon
)brace
id|ret
op_assign
id|ext3_get_block_handle
c_func
(paren
id|handle
comma
id|inode
comma
id|iblock
comma
id|bh_result
comma
id|create
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * `handle&squot; can be NULL if create is zero&n; */
DECL|function|ext3_getblk
r_struct
id|buffer_head
op_star
id|ext3_getblk
c_func
(paren
id|handle_t
op_star
id|handle
comma
r_struct
id|inode
op_star
id|inode
comma
r_int
id|block
comma
r_int
id|create
comma
r_int
op_star
id|errp
)paren
(brace
r_struct
id|buffer_head
id|dummy
suffix:semicolon
r_int
id|fatal
op_assign
l_int|0
comma
id|err
suffix:semicolon
id|J_ASSERT
c_func
(paren
id|handle
op_ne
l_int|NULL
op_logical_or
id|create
op_eq
l_int|0
)paren
suffix:semicolon
id|dummy.b_state
op_assign
l_int|0
suffix:semicolon
id|dummy.b_blocknr
op_assign
op_minus
l_int|1000
suffix:semicolon
id|buffer_trace_init
c_func
(paren
op_amp
id|dummy.b_history
)paren
suffix:semicolon
op_star
id|errp
op_assign
id|ext3_get_block_handle
c_func
(paren
id|handle
comma
id|inode
comma
id|block
comma
op_amp
id|dummy
comma
id|create
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_star
id|errp
op_logical_and
id|buffer_mapped
c_func
(paren
op_amp
id|dummy
)paren
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
id|bh
op_assign
id|sb_getblk
c_func
(paren
id|inode-&gt;i_sb
comma
id|dummy.b_blocknr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buffer_new
c_func
(paren
op_amp
id|dummy
)paren
)paren
(brace
id|J_ASSERT
c_func
(paren
id|create
op_ne
l_int|0
)paren
suffix:semicolon
id|J_ASSERT
c_func
(paren
id|handle
op_ne
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Now that we do not always journal data, we&n;&t;&t;&t;   should keep in mind whether this should&n;&t;&t;&t;   always journal the new buffer as metadata.&n;&t;&t;&t;   For now, regular file writes use&n;&t;&t;&t;   ext3_get_block instead, so it&squot;s not a&n;&t;&t;&t;   problem. */
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|lock_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
id|BUFFER_TRACE
c_func
(paren
id|bh
comma
l_string|&quot;call get_create_access&quot;
)paren
suffix:semicolon
id|fatal
op_assign
id|ext3_journal_get_create_access
c_func
(paren
id|handle
comma
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fatal
)paren
(brace
id|memset
c_func
(paren
id|bh-&gt;b_data
comma
l_int|0
comma
id|inode-&gt;i_sb-&gt;s_blocksize
)paren
suffix:semicolon
id|set_buffer_uptodate
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
id|unlock_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
id|BUFFER_TRACE
c_func
(paren
id|bh
comma
l_string|&quot;call ext3_journal_dirty_metadata&quot;
)paren
suffix:semicolon
id|err
op_assign
id|ext3_journal_dirty_metadata
c_func
(paren
id|handle
comma
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fatal
)paren
id|fatal
op_assign
id|err
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|BUFFER_TRACE
c_func
(paren
id|bh
comma
l_string|&quot;not a new buffer&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|fatal
)paren
(brace
op_star
id|errp
op_assign
id|fatal
suffix:semicolon
id|brelse
c_func
(paren
id|bh
)paren
suffix:semicolon
id|bh
op_assign
l_int|NULL
suffix:semicolon
)brace
r_return
id|bh
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|ext3_bread
r_struct
id|buffer_head
op_star
id|ext3_bread
c_func
(paren
id|handle_t
op_star
id|handle
comma
r_struct
id|inode
op_star
id|inode
comma
r_int
id|block
comma
r_int
id|create
comma
r_int
op_star
id|err
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
r_int
id|prev_blocks
suffix:semicolon
id|prev_blocks
op_assign
id|inode-&gt;i_blocks
suffix:semicolon
id|bh
op_assign
id|ext3_getblk
(paren
id|handle
comma
id|inode
comma
id|block
comma
id|create
comma
id|err
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bh
)paren
r_return
id|bh
suffix:semicolon
macro_line|#ifdef EXT3_PREALLOCATE
multiline_comment|/*&n;&t; * If the inode has grown, and this is a directory, then use a few&n;&t; * more of the preallocated blocks to keep directory fragmentation&n;&t; * down.  The preallocated blocks are guaranteed to be contiguous.&n;&t; */
r_if
c_cond
(paren
id|create
op_logical_and
id|S_ISDIR
c_func
(paren
id|inode-&gt;i_mode
)paren
op_logical_and
id|inode-&gt;i_blocks
OG
id|prev_blocks
op_logical_and
id|EXT3_HAS_COMPAT_FEATURE
c_func
(paren
id|inode-&gt;i_sb
comma
id|EXT3_FEATURE_COMPAT_DIR_PREALLOC
)paren
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|buffer_head
op_star
id|tmp_bh
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|EXT3_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_prealloc_count
op_logical_and
id|i
OL
id|EXT3_SB
c_func
(paren
id|inode-&gt;i_sb
)paren
op_member_access_from_pointer
id|s_es-&gt;s_prealloc_dir_blocks
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * ext3_getblk will zero out the contents of the&n;&t;&t;&t; * directory for us&n;&t;&t;&t; */
id|tmp_bh
op_assign
id|ext3_getblk
c_func
(paren
id|handle
comma
id|inode
comma
id|block
op_plus
id|i
comma
id|create
comma
id|err
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tmp_bh
)paren
(brace
id|brelse
(paren
id|bh
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|brelse
(paren
id|tmp_bh
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
r_if
c_cond
(paren
id|buffer_uptodate
c_func
(paren
id|bh
)paren
)paren
r_return
id|bh
suffix:semicolon
id|ll_rw_block
(paren
id|READ
comma
l_int|1
comma
op_amp
id|bh
)paren
suffix:semicolon
id|wait_on_buffer
(paren
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buffer_uptodate
c_func
(paren
id|bh
)paren
)paren
r_return
id|bh
suffix:semicolon
id|brelse
(paren
id|bh
)paren
suffix:semicolon
op_star
id|err
op_assign
op_minus
id|EIO
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|walk_page_buffers
r_static
r_int
id|walk_page_buffers
c_func
(paren
id|handle_t
op_star
id|handle
comma
r_struct
id|buffer_head
op_star
id|head
comma
r_int
id|from
comma
r_int
id|to
comma
r_int
op_star
id|partial
comma
r_int
(paren
op_star
id|fn
)paren
(paren
id|handle_t
op_star
id|handle
comma
r_struct
id|buffer_head
op_star
id|bh
)paren
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
r_int
id|block_start
comma
id|block_end
suffix:semicolon
r_int
id|blocksize
op_assign
id|head-&gt;b_size
suffix:semicolon
r_int
id|err
comma
id|ret
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|bh
op_assign
id|head
comma
id|block_start
op_assign
l_int|0
suffix:semicolon
id|ret
op_eq
l_int|0
op_logical_and
(paren
id|bh
op_ne
id|head
op_logical_or
op_logical_neg
id|block_start
)paren
suffix:semicolon
id|block_start
op_assign
id|block_end
comma
id|bh
op_assign
id|bh-&gt;b_this_page
)paren
(brace
id|block_end
op_assign
id|block_start
op_plus
id|blocksize
suffix:semicolon
r_if
c_cond
(paren
id|block_end
op_le
id|from
op_logical_or
id|block_start
op_ge
id|to
)paren
(brace
r_if
c_cond
(paren
id|partial
op_logical_and
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|bh
)paren
)paren
op_star
id|partial
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|err
op_assign
(paren
op_star
id|fn
)paren
(paren
id|handle
comma
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
id|ret
op_assign
id|err
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * To preserve ordering, it is essential that the hole instantiation and&n; * the data write be encapsulated in a single transaction.  We cannot&n; * close off a transaction and start a new one between the ext3_get_block()&n; * and the commit_write().  So doing the journal_start at the start of&n; * prepare_write() is the right place.&n; *&n; * Also, this function can nest inside ext3_writepage() -&gt;&n; * block_write_full_page(). In that case, we *know* that ext3_writepage()&n; * has generated enough buffer credits to do the whole page.  So we won&squot;t&n; * block on the journal in that case, which is good, because the caller may&n; * be PF_MEMALLOC.&n; *&n; * By accident, ext3 can be reentered when a transaction is open via&n; * quota file writes.  If we were to commit the transaction while thus&n; * reentered, there can be a deadlock - we would be holding a quota&n; * lock, and the commit would never complete if another thread had a&n; * transaction open and was blocking on the quota lock - a ranking&n; * violation.&n; *&n; * So what we do is to rely on the fact that journal_stop/journal_start&n; * will _not_ run commit under these circumstances because handle-&gt;h_ref&n; * is elevated.  We&squot;ll still have enough credits for the tiny quotafile&n; * write.  &n; */
DECL|function|do_journal_get_write_access
r_static
r_int
id|do_journal_get_write_access
c_func
(paren
id|handle_t
op_star
id|handle
comma
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
r_return
id|ext3_journal_get_write_access
c_func
(paren
id|handle
comma
id|bh
)paren
suffix:semicolon
)brace
DECL|function|ext3_prepare_write
r_static
r_int
id|ext3_prepare_write
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_struct
id|page
op_star
id|page
comma
r_int
id|from
comma
r_int
id|to
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|page-&gt;mapping-&gt;host
suffix:semicolon
r_int
id|ret
comma
id|needed_blocks
op_assign
id|ext3_writepage_trans_blocks
c_func
(paren
id|inode
)paren
suffix:semicolon
id|handle_t
op_star
id|handle
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|handle
op_assign
id|ext3_journal_start
c_func
(paren
id|inode
comma
id|needed_blocks
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|handle
)paren
)paren
(brace
id|ret
op_assign
id|PTR_ERR
c_func
(paren
id|handle
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
id|ret
op_assign
id|block_prepare_write
c_func
(paren
id|page
comma
id|from
comma
id|to
comma
id|ext3_get_block
)paren
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
l_int|0
)paren
r_goto
id|prepare_write_failed
suffix:semicolon
r_if
c_cond
(paren
id|ext3_should_journal_data
c_func
(paren
id|inode
)paren
)paren
(brace
id|ret
op_assign
id|walk_page_buffers
c_func
(paren
id|handle
comma
id|page_buffers
c_func
(paren
id|page
)paren
comma
id|from
comma
id|to
comma
l_int|NULL
comma
id|do_journal_get_write_access
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * We&squot;re going to fail this prepare_write(),&n;&t;&t;&t; * so commit_write() will not be called.&n;&t;&t;&t; * We need to undo block_prepare_write()&squot;s kmap().&n;&t;&t;&t; * AKPM: Do we need to clear PageUptodate?  I don&squot;t&n;&t;&t;&t; * think so.&n;&t;&t;&t; */
id|kunmap
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
)brace
id|prepare_write_failed
suffix:colon
r_if
c_cond
(paren
id|ret
)paren
id|ext3_journal_stop
c_func
(paren
id|handle
comma
id|inode
)paren
suffix:semicolon
id|out
suffix:colon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|journal_dirty_sync_data
r_static
r_int
id|journal_dirty_sync_data
c_func
(paren
id|handle_t
op_star
id|handle
comma
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
r_return
id|ext3_journal_dirty_data
c_func
(paren
id|handle
comma
id|bh
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * For ext3_writepage().  We also brelse() the buffer to account for&n; * the bget() which ext3_writepage() performs.&n; */
DECL|function|journal_dirty_async_data
r_static
r_int
id|journal_dirty_async_data
c_func
(paren
id|handle_t
op_star
id|handle
comma
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
r_int
id|ret
op_assign
id|ext3_journal_dirty_data
c_func
(paren
id|handle
comma
id|bh
comma
l_int|1
)paren
suffix:semicolon
id|__brelse
c_func
(paren
id|bh
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* For commit_write() in data=journal mode */
DECL|function|commit_write_fn
r_static
r_int
id|commit_write_fn
c_func
(paren
id|handle_t
op_star
id|handle
comma
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
id|set_buffer_uptodate
c_func
(paren
id|bh
)paren
suffix:semicolon
r_return
id|ext3_journal_dirty_metadata
c_func
(paren
id|handle
comma
id|bh
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * We need to pick up the new inode size which generic_commit_write gave us&n; * `file&squot; can be NULL - eg, when called from page_symlink().&n; *&n; * ext3 never places buffers on inode-&gt;i_mapping-&gt;private_list.  metadata&n; * buffers are managed internally.&n; */
DECL|function|ext3_commit_write
r_static
r_int
id|ext3_commit_write
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_struct
id|page
op_star
id|page
comma
r_int
id|from
comma
r_int
id|to
)paren
(brace
id|handle_t
op_star
id|handle
op_assign
id|ext3_journal_current_handle
c_func
(paren
)paren
suffix:semicolon
r_struct
id|inode
op_star
id|inode
op_assign
id|page-&gt;mapping-&gt;host
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
comma
id|ret2
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ext3_should_journal_data
c_func
(paren
id|inode
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * Here we duplicate the generic_commit_write() functionality&n;&t;&t; */
r_int
id|partial
op_assign
l_int|0
suffix:semicolon
id|loff_t
id|pos
op_assign
(paren
(paren
id|loff_t
)paren
id|page-&gt;index
op_lshift
id|PAGE_CACHE_SHIFT
)paren
op_plus
id|to
suffix:semicolon
id|ret
op_assign
id|walk_page_buffers
c_func
(paren
id|handle
comma
id|page_buffers
c_func
(paren
id|page
)paren
comma
id|from
comma
id|to
comma
op_amp
id|partial
comma
id|commit_write_fn
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|partial
)paren
id|SetPageUptodate
c_func
(paren
id|page
)paren
suffix:semicolon
id|kunmap
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pos
OG
id|inode-&gt;i_size
)paren
id|inode-&gt;i_size
op_assign
id|pos
suffix:semicolon
id|EXT3_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_state
op_or_assign
id|EXT3_STATE_JDATA
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|ext3_should_order_data
c_func
(paren
id|inode
)paren
)paren
(brace
id|ret
op_assign
id|walk_page_buffers
c_func
(paren
id|handle
comma
id|page_buffers
c_func
(paren
id|page
)paren
comma
id|from
comma
id|to
comma
l_int|NULL
comma
id|journal_dirty_sync_data
)paren
suffix:semicolon
)brace
multiline_comment|/* Be careful here if generic_commit_write becomes a&n;&t;&t; * required invocation after block_prepare_write. */
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
id|ret
op_assign
id|generic_commit_write
c_func
(paren
id|file
comma
id|page
comma
id|from
comma
id|to
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; * block_prepare_write() was called, but we&squot;re not&n;&t;&t;&t; * going to call generic_commit_write().  So we&n;&t;&t;&t; * need to perform generic_commit_write()&squot;s kunmap&n;&t;&t;&t; * by hand.&n;&t;&t;&t; */
id|kunmap
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|inode-&gt;i_size
OG
id|EXT3_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_disksize
)paren
(brace
id|EXT3_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_disksize
op_assign
id|inode-&gt;i_size
suffix:semicolon
id|ret2
op_assign
id|ext3_mark_inode_dirty
c_func
(paren
id|handle
comma
id|inode
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
id|ret
op_assign
id|ret2
suffix:semicolon
)brace
id|ret2
op_assign
id|ext3_journal_stop
c_func
(paren
id|handle
comma
id|inode
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
id|ret
op_assign
id|ret2
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* &n; * bmap() is special.  It gets used by applications such as lilo and by&n; * the swapper to find the on-disk block of a specific piece of data.&n; *&n; * Naturally, this is dangerous if the block concerned is still in the&n; * journal.  If somebody makes a swapfile on an ext3 data-journaling&n; * filesystem and enables swap, then they may get a nasty shock when the&n; * data getting swapped to that swapfile suddenly gets overwritten by&n; * the original zero&squot;s written out previously to the journal and&n; * awaiting writeback in the kernel&squot;s buffer cache. &n; *&n; * So, if we see any bmap calls here on a modified, data-journaled file,&n; * take extra steps to flush any blocks which might be in the cache. &n; */
DECL|function|ext3_bmap
r_static
r_int
id|ext3_bmap
c_func
(paren
r_struct
id|address_space
op_star
id|mapping
comma
r_int
id|block
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|mapping-&gt;host
suffix:semicolon
id|journal_t
op_star
id|journal
suffix:semicolon
r_int
id|err
suffix:semicolon
r_if
c_cond
(paren
id|EXT3_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_state
op_amp
id|EXT3_STATE_JDATA
)paren
(brace
multiline_comment|/* &n;&t;&t; * This is a REALLY heavyweight approach, but the use of&n;&t;&t; * bmap on dirty files is expected to be extremely rare:&n;&t;&t; * only if we run lilo or swapon on a freshly made file&n;&t;&t; * do we expect this to happen. &n;&t;&t; *&n;&t;&t; * (bmap requires CAP_SYS_RAWIO so this does not&n;&t;&t; * represent an unprivileged user DOS attack --- we&squot;d be&n;&t;&t; * in trouble if mortal users could trigger this path at&n;&t;&t; * will.) &n;&t;&t; *&n;&t;&t; * NB. EXT3_STATE_JDATA is not set on files other than&n;&t;&t; * regular files.  If somebody wants to bmap a directory&n;&t;&t; * or symlink and gets confused because the buffer&n;&t;&t; * hasn&squot;t yet been flushed to disk, they deserve&n;&t;&t; * everything they get.&n;&t;&t; */
id|EXT3_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_state
op_and_assign
op_complement
id|EXT3_STATE_JDATA
suffix:semicolon
id|journal
op_assign
id|EXT3_JOURNAL
c_func
(paren
id|inode
)paren
suffix:semicolon
id|journal_lock_updates
c_func
(paren
id|journal
)paren
suffix:semicolon
id|err
op_assign
id|journal_flush
c_func
(paren
id|journal
)paren
suffix:semicolon
id|journal_unlock_updates
c_func
(paren
id|journal
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
l_int|0
suffix:semicolon
)brace
r_return
id|generic_block_bmap
c_func
(paren
id|mapping
comma
id|block
comma
id|ext3_get_block
)paren
suffix:semicolon
)brace
DECL|function|bget_one
r_static
r_int
id|bget_one
c_func
(paren
id|handle_t
op_star
id|handle
comma
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
id|atomic_inc
c_func
(paren
op_amp
id|bh-&gt;b_count
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Note that we always start a transaction even if we&squot;re not journalling&n; * data.  This is to preserve ordering: any hole instantiation within&n; * __block_write_full_page -&gt; ext3_get_block() should be journalled&n; * along with the data so we don&squot;t crash and then get metadata which&n; * refers to old data.&n; *&n; * In all journalling modes block_write_full_page() will start the I/O.&n; *&n; * Problem:&n; *&n; *&t;ext3_writepage() -&gt; kmalloc() -&gt; __alloc_pages() -&gt; page_launder() -&gt;&n; *&t;&t;ext3_writepage()&n; *&n; * Similar for:&n; *&n; *&t;ext3_file_write() -&gt; generic_file_write() -&gt; __alloc_pages() -&gt; ...&n; *&n; * Same applies to ext3_get_block().  We will deadlock on various things like&n; * lock_journal and i_truncate_sem.&n; *&n; * Setting PF_MEMALLOC here doesn&squot;t work - too many internal memory&n; * allocations fail.&n; *&n; * 16May01: If we&squot;re reentered then journal_current_handle() will be&n; *&t;    non-zero. We simply *return*.&n; *&n; * 1 July 2001: @@@ FIXME:&n; *   In journalled data mode, a data buffer may be metadata against the&n; *   current transaction.  But the same file is part of a shared mapping&n; *   and someone does a writepage() on it.&n; *&n; *   We will move the buffer onto the async_data list, but *after* it has&n; *   been dirtied. So there&squot;s a small window where we have dirty data on&n; *   BJ_Metadata.&n; *&n; *   Note that this only applies to the last partial page in the file.  The&n; *   bit which block_write_full_page() uses prepare/commit for.  (That&squot;s&n; *   broken code anyway: it&squot;s wrong for msync()).&n; *&n; *   It&squot;s a rare case: affects the final partial page, for journalled data&n; *   where the file is subject to bith write() and writepage() in the same&n; *   transction.  To fix it we&squot;ll need a custom block_write_full_page().&n; *   We&squot;ll probably need that anyway for journalling writepage() output.&n; *&n; * We don&squot;t honour synchronous mounts for writepage().  That would be&n; * disastrous.  Any write() or metadata operation will sync the fs for&n; * us.&n; */
DECL|function|ext3_writepage
r_static
r_int
id|ext3_writepage
c_func
(paren
r_struct
id|page
op_star
id|page
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|page-&gt;mapping-&gt;host
suffix:semicolon
r_struct
id|buffer_head
op_star
id|page_bufs
suffix:semicolon
id|handle_t
op_star
id|handle
op_assign
l_int|NULL
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
comma
id|err
suffix:semicolon
r_int
id|needed
suffix:semicolon
r_int
id|order_data
suffix:semicolon
id|J_ASSERT
c_func
(paren
id|PageLocked
c_func
(paren
id|page
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We give up here if we&squot;re reentered, because it might be&n;&t; * for a different filesystem.  One *could* look for a&n;&t; * nested transaction opportunity.&n;&t; */
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ext3_journal_current_handle
c_func
(paren
)paren
)paren
r_goto
id|out_fail
suffix:semicolon
id|needed
op_assign
id|ext3_writepage_trans_blocks
c_func
(paren
id|inode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;flags
op_amp
id|PF_MEMALLOC
)paren
id|handle
op_assign
id|ext3_journal_try_start
c_func
(paren
id|inode
comma
id|needed
)paren
suffix:semicolon
r_else
id|handle
op_assign
id|ext3_journal_start
c_func
(paren
id|inode
comma
id|needed
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|handle
)paren
)paren
(brace
id|ret
op_assign
id|PTR_ERR
c_func
(paren
id|handle
)paren
suffix:semicolon
r_goto
id|out_fail
suffix:semicolon
)brace
id|order_data
op_assign
id|ext3_should_order_data
c_func
(paren
id|inode
)paren
op_logical_or
id|ext3_should_journal_data
c_func
(paren
id|inode
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
id|page_bufs
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Purely to prevent compiler warning */
multiline_comment|/* bget() all the buffers */
r_if
c_cond
(paren
id|order_data
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|page_has_buffers
c_func
(paren
id|page
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|PageUptodate
c_func
(paren
id|page
)paren
)paren
id|buffer_error
c_func
(paren
)paren
suffix:semicolon
id|create_empty_buffers
c_func
(paren
id|page
comma
id|inode-&gt;i_sb-&gt;s_blocksize
comma
(paren
l_int|1
op_lshift
id|BH_Dirty
)paren
op_or
(paren
l_int|1
op_lshift
id|BH_Uptodate
)paren
)paren
suffix:semicolon
)brace
id|page_bufs
op_assign
id|page_buffers
c_func
(paren
id|page
)paren
suffix:semicolon
id|walk_page_buffers
c_func
(paren
id|handle
comma
id|page_bufs
comma
l_int|0
comma
id|PAGE_CACHE_SIZE
comma
l_int|NULL
comma
id|bget_one
)paren
suffix:semicolon
)brace
id|ret
op_assign
id|block_write_full_page
c_func
(paren
id|page
comma
id|ext3_get_block
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * The page can become unlocked at any point now, and&n;&t; * truncate can then come in and change things.  So we&n;&t; * can&squot;t touch *page from now on.  But *page_bufs is&n;&t; * safe due to elevated refcount.&n;&t; */
id|handle
op_assign
id|ext3_journal_current_handle
c_func
(paren
)paren
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* And attach them to the current transaction */
r_if
c_cond
(paren
id|order_data
)paren
(brace
id|err
op_assign
id|walk_page_buffers
c_func
(paren
id|handle
comma
id|page_bufs
comma
l_int|0
comma
id|PAGE_CACHE_SIZE
comma
l_int|NULL
comma
id|journal_dirty_async_data
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
id|ret
op_assign
id|err
suffix:semicolon
)brace
id|err
op_assign
id|ext3_journal_stop
c_func
(paren
id|handle
comma
id|inode
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
id|ret
op_assign
id|err
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
id|out_fail
suffix:colon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We have to fail this writepage to avoid cross-fs transactions.&n;&t; * Put the page back on mapping-&gt;dirty_pages, but leave its buffer&squot;s&n;&t; * dirty state as-is.&n;&t; */
id|__set_page_dirty_nobuffers
c_func
(paren
id|page
)paren
suffix:semicolon
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|ext3_readpage
r_static
r_int
id|ext3_readpage
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_struct
id|page
op_star
id|page
)paren
(brace
r_return
id|mpage_readpage
c_func
(paren
id|page
comma
id|ext3_get_block
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|ext3_readpages
id|ext3_readpages
c_func
(paren
r_struct
id|address_space
op_star
id|mapping
comma
r_struct
id|list_head
op_star
id|pages
comma
r_int
id|nr_pages
)paren
(brace
r_return
id|mpage_readpages
c_func
(paren
id|mapping
comma
id|pages
comma
id|nr_pages
comma
id|ext3_get_block
)paren
suffix:semicolon
)brace
DECL|function|ext3_invalidatepage
r_static
r_int
id|ext3_invalidatepage
c_func
(paren
r_struct
id|page
op_star
id|page
comma
r_int
r_int
id|offset
)paren
(brace
id|journal_t
op_star
id|journal
op_assign
id|EXT3_JOURNAL
c_func
(paren
id|page-&gt;mapping-&gt;host
)paren
suffix:semicolon
r_return
id|journal_invalidatepage
c_func
(paren
id|journal
comma
id|page
comma
id|offset
)paren
suffix:semicolon
)brace
DECL|function|ext3_releasepage
r_static
r_int
id|ext3_releasepage
c_func
(paren
r_struct
id|page
op_star
id|page
comma
r_int
id|wait
)paren
(brace
id|journal_t
op_star
id|journal
op_assign
id|EXT3_JOURNAL
c_func
(paren
id|page-&gt;mapping-&gt;host
)paren
suffix:semicolon
r_return
id|journal_try_to_free_buffers
c_func
(paren
id|journal
comma
id|page
comma
id|wait
)paren
suffix:semicolon
)brace
DECL|variable|ext3_aops
r_struct
id|address_space_operations
id|ext3_aops
op_assign
(brace
id|readpage
suffix:colon
id|ext3_readpage
comma
multiline_comment|/* BKL not held.  Don&squot;t need */
id|readpages
suffix:colon
id|ext3_readpages
comma
multiline_comment|/* BKL not held.  Don&squot;t need */
id|writepage
suffix:colon
id|ext3_writepage
comma
multiline_comment|/* BKL not held.  We take it */
id|sync_page
suffix:colon
id|block_sync_page
comma
id|prepare_write
suffix:colon
id|ext3_prepare_write
comma
multiline_comment|/* BKL not held.  We take it */
id|commit_write
suffix:colon
id|ext3_commit_write
comma
multiline_comment|/* BKL not held.  We take it */
id|bmap
suffix:colon
id|ext3_bmap
comma
multiline_comment|/* BKL held */
id|invalidatepage
suffix:colon
id|ext3_invalidatepage
comma
multiline_comment|/* BKL not held.  Don&squot;t need */
id|releasepage
suffix:colon
id|ext3_releasepage
comma
multiline_comment|/* BKL not held.  Don&squot;t need */
)brace
suffix:semicolon
multiline_comment|/* For writeback mode, we can use mpage_writepages() */
r_static
r_int
DECL|function|ext3_writepages
id|ext3_writepages
c_func
(paren
r_struct
id|address_space
op_star
id|mapping
comma
r_int
op_star
id|nr_to_write
)paren
(brace
r_int
id|ret
suffix:semicolon
r_int
id|err
suffix:semicolon
id|ret
op_assign
id|write_mapping_buffers
c_func
(paren
id|mapping
)paren
suffix:semicolon
id|err
op_assign
id|mpage_writepages
c_func
(paren
id|mapping
comma
id|nr_to_write
comma
id|ext3_get_block
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
id|ret
op_assign
id|err
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|variable|ext3_writeback_aops
r_struct
id|address_space_operations
id|ext3_writeback_aops
op_assign
(brace
id|readpage
suffix:colon
id|ext3_readpage
comma
multiline_comment|/* BKL not held.  Don&squot;t need */
id|readpages
suffix:colon
id|ext3_readpages
comma
multiline_comment|/* BKL not held.  Don&squot;t need */
id|writepage
suffix:colon
id|ext3_writepage
comma
multiline_comment|/* BKL not held.  We take it */
id|writepages
suffix:colon
id|ext3_writepages
comma
multiline_comment|/* BKL not held.  Don&squot;t need */
id|sync_page
suffix:colon
id|block_sync_page
comma
id|prepare_write
suffix:colon
id|ext3_prepare_write
comma
multiline_comment|/* BKL not held.  We take it */
id|commit_write
suffix:colon
id|ext3_commit_write
comma
multiline_comment|/* BKL not held.  We take it */
id|bmap
suffix:colon
id|ext3_bmap
comma
multiline_comment|/* BKL held */
id|invalidatepage
suffix:colon
id|ext3_invalidatepage
comma
multiline_comment|/* BKL not held.  Don&squot;t need */
id|releasepage
suffix:colon
id|ext3_releasepage
comma
multiline_comment|/* BKL not held.  Don&squot;t need */
)brace
suffix:semicolon
multiline_comment|/*&n; * ext3_block_truncate_page() zeroes out a mapping from file offset `from&squot;&n; * up to the end of the block which corresponds to `from&squot;.&n; * This required during truncate. We need to physically zero the tail end&n; * of that block so it doesn&squot;t yield old data if the file is later grown.&n; */
DECL|function|ext3_block_truncate_page
r_static
r_int
id|ext3_block_truncate_page
c_func
(paren
id|handle_t
op_star
id|handle
comma
r_struct
id|address_space
op_star
id|mapping
comma
id|loff_t
id|from
)paren
(brace
r_int
r_int
id|index
op_assign
id|from
op_rshift
id|PAGE_CACHE_SHIFT
suffix:semicolon
r_int
id|offset
op_assign
id|from
op_amp
(paren
id|PAGE_CACHE_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
r_int
id|blocksize
comma
id|iblock
comma
id|length
comma
id|pos
suffix:semicolon
r_struct
id|inode
op_star
id|inode
op_assign
id|mapping-&gt;host
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
r_int
id|err
suffix:semicolon
id|blocksize
op_assign
id|inode-&gt;i_sb-&gt;s_blocksize
suffix:semicolon
id|length
op_assign
id|offset
op_amp
(paren
id|blocksize
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Block boundary? Nothing to do */
r_if
c_cond
(paren
op_logical_neg
id|length
)paren
r_return
l_int|0
suffix:semicolon
id|length
op_assign
id|blocksize
op_minus
id|length
suffix:semicolon
id|iblock
op_assign
id|index
op_lshift
(paren
id|PAGE_CACHE_SHIFT
op_minus
id|inode-&gt;i_sb-&gt;s_blocksize_bits
)paren
suffix:semicolon
id|page
op_assign
id|grab_cache_page
c_func
(paren
id|mapping
comma
id|index
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page_has_buffers
c_func
(paren
id|page
)paren
)paren
id|create_empty_buffers
c_func
(paren
id|page
comma
id|blocksize
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Find the buffer that contains &quot;offset&quot; */
id|bh
op_assign
id|page_buffers
c_func
(paren
id|page
)paren
suffix:semicolon
id|pos
op_assign
id|blocksize
suffix:semicolon
r_while
c_loop
(paren
id|offset
op_ge
id|pos
)paren
(brace
id|bh
op_assign
id|bh-&gt;b_this_page
suffix:semicolon
id|iblock
op_increment
suffix:semicolon
id|pos
op_add_assign
id|blocksize
suffix:semicolon
)brace
id|err
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buffer_mapped
c_func
(paren
id|bh
)paren
)paren
(brace
id|ext3_get_block
c_func
(paren
id|inode
comma
id|iblock
comma
id|bh
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* unmapped? It&squot;s a hole - nothing to do */
r_if
c_cond
(paren
op_logical_neg
id|buffer_mapped
c_func
(paren
id|bh
)paren
)paren
r_goto
id|unlock
suffix:semicolon
)brace
multiline_comment|/* Ok, it&squot;s mapped. Make sure it&squot;s up-to-date */
r_if
c_cond
(paren
id|PageUptodate
c_func
(paren
id|page
)paren
)paren
id|set_buffer_uptodate
c_func
(paren
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|bh
)paren
)paren
(brace
id|err
op_assign
op_minus
id|EIO
suffix:semicolon
id|ll_rw_block
c_func
(paren
id|READ
comma
l_int|1
comma
op_amp
id|bh
)paren
suffix:semicolon
id|wait_on_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
multiline_comment|/* Uhhuh. Read error. Complain and punt. */
r_if
c_cond
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|bh
)paren
)paren
r_goto
id|unlock
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ext3_should_journal_data
c_func
(paren
id|inode
)paren
)paren
(brace
id|BUFFER_TRACE
c_func
(paren
id|bh
comma
l_string|&quot;get write access&quot;
)paren
suffix:semicolon
id|err
op_assign
id|ext3_journal_get_write_access
c_func
(paren
id|handle
comma
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|unlock
suffix:semicolon
)brace
id|memset
c_func
(paren
id|kmap
c_func
(paren
id|page
)paren
op_plus
id|offset
comma
l_int|0
comma
id|length
)paren
suffix:semicolon
id|flush_dcache_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|kunmap
c_func
(paren
id|page
)paren
suffix:semicolon
id|BUFFER_TRACE
c_func
(paren
id|bh
comma
l_string|&quot;zeroed end of block&quot;
)paren
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ext3_should_journal_data
c_func
(paren
id|inode
)paren
)paren
(brace
id|err
op_assign
id|ext3_journal_dirty_metadata
c_func
(paren
id|handle
comma
id|bh
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|ext3_should_order_data
c_func
(paren
id|inode
)paren
)paren
id|err
op_assign
id|ext3_journal_dirty_data
c_func
(paren
id|handle
comma
id|bh
comma
l_int|0
)paren
suffix:semicolon
id|mark_buffer_dirty
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
id|unlock
suffix:colon
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; * Probably it should be a library function... search for first non-zero word&n; * or memcmp with zero_page, whatever is better for particular architecture.&n; * Linus?&n; */
DECL|function|all_zeroes
r_static
r_inline
r_int
id|all_zeroes
c_func
(paren
id|u32
op_star
id|p
comma
id|u32
op_star
id|q
)paren
(brace
r_while
c_loop
(paren
id|p
OL
id|q
)paren
r_if
c_cond
(paren
op_star
id|p
op_increment
)paren
r_return
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;ext3_find_shared - find the indirect blocks for partial truncation.&n; *&t;@inode:&t;  inode in question&n; *&t;@depth:&t;  depth of the affected branch&n; *&t;@offsets: offsets of pointers in that branch (see ext3_block_to_path)&n; *&t;@chain:&t;  place to store the pointers to partial indirect blocks&n; *&t;@top:&t;  place to the (detached) top of branch&n; *&n; *&t;This is a helper function used by ext3_truncate().&n; *&n; *&t;When we do truncate() we may have to clean the ends of several&n; *&t;indirect blocks but leave the blocks themselves alive. Block is&n; *&t;partially truncated if some data below the new i_size is refered&n; *&t;from it (and it is on the path to the first completely truncated&n; *&t;data block, indeed).  We have to free the top of that path along&n; *&t;with everything to the right of the path. Since no allocation&n; *&t;past the truncation point is possible until ext3_truncate()&n; *&t;finishes, we may safely do the latter, but top of branch may&n; *&t;require special attention - pageout below the truncation point&n; *&t;might try to populate it.&n; *&n; *&t;We atomically detach the top of branch from the tree, store the&n; *&t;block number of its root in *@top, pointers to buffer_heads of&n; *&t;partially truncated blocks - in @chain[].bh and pointers to&n; *&t;their last elements that should not be removed - in&n; *&t;@chain[].p. Return value is the pointer to last filled element&n; *&t;of @chain.&n; *&n; *&t;The work left to caller to do the actual freeing of subtrees:&n; *&t;&t;a) free the subtree starting from *@top&n; *&t;&t;b) free the subtrees whose roots are stored in&n; *&t;&t;&t;(@chain[i].p+1 .. end of @chain[i].bh-&gt;b_data)&n; *&t;&t;c) free the subtrees growing from the inode past the @chain[0].&n; *&t;&t;&t;(no partially truncated stuff there).  */
DECL|function|ext3_find_shared
r_static
id|Indirect
op_star
id|ext3_find_shared
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_int
id|depth
comma
r_int
id|offsets
(braket
l_int|4
)braket
comma
id|Indirect
id|chain
(braket
l_int|4
)braket
comma
id|u32
op_star
id|top
)paren
(brace
id|Indirect
op_star
id|partial
comma
op_star
id|p
suffix:semicolon
r_int
id|k
comma
id|err
suffix:semicolon
op_star
id|top
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Make k index the deepest non-null offest + 1 */
r_for
c_loop
(paren
id|k
op_assign
id|depth
suffix:semicolon
id|k
OG
l_int|1
op_logical_and
op_logical_neg
id|offsets
(braket
id|k
op_minus
l_int|1
)braket
suffix:semicolon
id|k
op_decrement
)paren
suffix:semicolon
id|partial
op_assign
id|ext3_get_branch
c_func
(paren
id|inode
comma
id|k
comma
id|offsets
comma
id|chain
comma
op_amp
id|err
)paren
suffix:semicolon
multiline_comment|/* Writer: pointers */
r_if
c_cond
(paren
op_logical_neg
id|partial
)paren
id|partial
op_assign
id|chain
op_plus
id|k
op_minus
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * If the branch acquired continuation since we&squot;ve looked at it -&n;&t; * fine, it should all survive and (new) top doesn&squot;t belong to us.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|partial-&gt;key
op_logical_and
op_star
id|partial-&gt;p
)paren
multiline_comment|/* Writer: end */
r_goto
id|no_top
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|partial
suffix:semicolon
id|p
OG
id|chain
op_logical_and
id|all_zeroes
c_func
(paren
(paren
id|u32
op_star
)paren
id|p-&gt;bh-&gt;b_data
comma
id|p-&gt;p
)paren
suffix:semicolon
id|p
op_decrement
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * OK, we&squot;ve found the last block that must survive. The rest of our&n;&t; * branch should be detached before unlocking. However, if that rest&n;&t; * of branch is all ours and does not grow immediately from the inode&n;&t; * it&squot;s easier to cheat and just decrement partial-&gt;p.&n;&t; */
r_if
c_cond
(paren
id|p
op_eq
id|chain
op_plus
id|k
op_minus
l_int|1
op_logical_and
id|p
OG
id|chain
)paren
(brace
id|p-&gt;p
op_decrement
suffix:semicolon
)brace
r_else
(brace
op_star
id|top
op_assign
op_star
id|p-&gt;p
suffix:semicolon
multiline_comment|/* Nope, don&squot;t do this in ext3.  Must leave the tree intact */
macro_line|#if 0
op_star
id|p-&gt;p
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/* Writer: end */
r_while
c_loop
(paren
id|partial
OG
id|p
)paren
(brace
id|brelse
c_func
(paren
id|partial-&gt;bh
)paren
suffix:semicolon
id|partial
op_decrement
suffix:semicolon
)brace
id|no_top
suffix:colon
r_return
id|partial
suffix:semicolon
)brace
multiline_comment|/*&n; * Zero a number of block pointers in either an inode or an indirect block.&n; * If we restart the transaction we must again get write access to the&n; * indirect block for further modification.&n; *&n; * We release `count&squot; blocks on disk, but (last - first) may be greater&n; * than `count&squot; because there can be holes in there.&n; */
r_static
r_void
DECL|function|ext3_clear_blocks
id|ext3_clear_blocks
c_func
(paren
id|handle_t
op_star
id|handle
comma
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|buffer_head
op_star
id|bh
comma
r_int
r_int
id|block_to_free
comma
r_int
r_int
id|count
comma
id|u32
op_star
id|first
comma
id|u32
op_star
id|last
)paren
(brace
id|u32
op_star
id|p
suffix:semicolon
r_if
c_cond
(paren
id|try_to_extend_transaction
c_func
(paren
id|handle
comma
id|inode
)paren
)paren
(brace
r_if
c_cond
(paren
id|bh
)paren
(brace
id|BUFFER_TRACE
c_func
(paren
id|bh
comma
l_string|&quot;call ext3_journal_dirty_metadata&quot;
)paren
suffix:semicolon
id|ext3_journal_dirty_metadata
c_func
(paren
id|handle
comma
id|bh
)paren
suffix:semicolon
)brace
id|ext3_mark_inode_dirty
c_func
(paren
id|handle
comma
id|inode
)paren
suffix:semicolon
id|ext3_journal_test_restart
c_func
(paren
id|handle
comma
id|inode
)paren
suffix:semicolon
id|BUFFER_TRACE
c_func
(paren
id|bh
comma
l_string|&quot;get_write_access&quot;
)paren
suffix:semicolon
id|ext3_journal_get_write_access
c_func
(paren
id|handle
comma
id|bh
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Any buffers which are on the journal will be in memory. We find&n;&t; * them on the hash table so journal_revoke() will run journal_forget()&n;&t; * on them.  We&squot;ve already detached each block from the file, so&n;&t; * bforget() in journal_forget() should be safe.&n;&t; *&n;&t; * AKPM: turn on bforget in journal_forget()!!!&n;&t; */
r_for
c_loop
(paren
id|p
op_assign
id|first
suffix:semicolon
id|p
OL
id|last
suffix:semicolon
id|p
op_increment
)paren
(brace
id|u32
id|nr
op_assign
id|le32_to_cpu
c_func
(paren
op_star
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nr
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
op_star
id|p
op_assign
l_int|0
suffix:semicolon
id|bh
op_assign
id|sb_find_get_block
c_func
(paren
id|inode-&gt;i_sb
comma
id|nr
)paren
suffix:semicolon
id|ext3_forget
c_func
(paren
id|handle
comma
l_int|0
comma
id|inode
comma
id|bh
comma
id|nr
)paren
suffix:semicolon
)brace
)brace
id|ext3_free_blocks
c_func
(paren
id|handle
comma
id|inode
comma
id|block_to_free
comma
id|count
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * ext3_free_data - free a list of data blocks&n; * @handle:&t;handle for this transaction&n; * @inode:&t;inode we are dealing with&n; * @this_bh:&t;indirect buffer_head which contains *@first and *@last&n; * @first:&t;array of block numbers&n; * @last:&t;points immediately past the end of array&n; *&n; * We are freeing all blocks refered from that array (numbers are stored as&n; * little-endian 32-bit) and updating @inode-&gt;i_blocks appropriately.&n; *&n; * We accumulate contiguous runs of blocks to free.  Conveniently, if these&n; * blocks are contiguous then releasing them at one time will only affect one&n; * or two bitmap blocks (+ group descriptor(s) and superblock) and we won&squot;t&n; * actually use a lot of journal space.&n; *&n; * @this_bh will be %NULL if @first and @last point into the inode&squot;s direct&n; * block pointers.&n; */
DECL|function|ext3_free_data
r_static
r_void
id|ext3_free_data
c_func
(paren
id|handle_t
op_star
id|handle
comma
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|buffer_head
op_star
id|this_bh
comma
id|u32
op_star
id|first
comma
id|u32
op_star
id|last
)paren
(brace
r_int
r_int
id|block_to_free
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Starting block # of a run */
r_int
r_int
id|count
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Number of blocks in the run */
id|u32
op_star
id|block_to_free_p
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Pointer into inode/ind&n;&t;&t;&t;&t;&t;       corresponding to&n;&t;&t;&t;&t;&t;       block_to_free */
r_int
r_int
id|nr
suffix:semicolon
multiline_comment|/* Current block # */
id|u32
op_star
id|p
suffix:semicolon
multiline_comment|/* Pointer into inode/ind&n;&t;&t;&t;&t;&t;       for current block */
r_int
id|err
suffix:semicolon
r_if
c_cond
(paren
id|this_bh
)paren
(brace
multiline_comment|/* For indirect block */
id|BUFFER_TRACE
c_func
(paren
id|this_bh
comma
l_string|&quot;get_write_access&quot;
)paren
suffix:semicolon
id|err
op_assign
id|ext3_journal_get_write_access
c_func
(paren
id|handle
comma
id|this_bh
)paren
suffix:semicolon
multiline_comment|/* Important: if we can&squot;t update the indirect pointers&n;&t;&t; * to the blocks, we can&squot;t free them. */
r_if
c_cond
(paren
id|err
)paren
r_return
suffix:semicolon
)brace
r_for
c_loop
(paren
id|p
op_assign
id|first
suffix:semicolon
id|p
OL
id|last
suffix:semicolon
id|p
op_increment
)paren
(brace
id|nr
op_assign
id|le32_to_cpu
c_func
(paren
op_star
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nr
)paren
(brace
multiline_comment|/* accumulate blocks to free if they&squot;re contiguous */
r_if
c_cond
(paren
id|count
op_eq
l_int|0
)paren
(brace
id|block_to_free
op_assign
id|nr
suffix:semicolon
id|block_to_free_p
op_assign
id|p
suffix:semicolon
id|count
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|nr
op_eq
id|block_to_free
op_plus
id|count
)paren
(brace
id|count
op_increment
suffix:semicolon
)brace
r_else
(brace
id|ext3_clear_blocks
c_func
(paren
id|handle
comma
id|inode
comma
id|this_bh
comma
id|block_to_free
comma
id|count
comma
id|block_to_free_p
comma
id|p
)paren
suffix:semicolon
id|block_to_free
op_assign
id|nr
suffix:semicolon
id|block_to_free_p
op_assign
id|p
suffix:semicolon
id|count
op_assign
l_int|1
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|count
OG
l_int|0
)paren
id|ext3_clear_blocks
c_func
(paren
id|handle
comma
id|inode
comma
id|this_bh
comma
id|block_to_free
comma
id|count
comma
id|block_to_free_p
comma
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
id|this_bh
)paren
(brace
id|BUFFER_TRACE
c_func
(paren
id|this_bh
comma
l_string|&quot;call ext3_journal_dirty_metadata&quot;
)paren
suffix:semicolon
id|ext3_journal_dirty_metadata
c_func
(paren
id|handle
comma
id|this_bh
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; *&t;ext3_free_branches - free an array of branches&n; *&t;@handle: JBD handle for this transaction&n; *&t;@inode:&t;inode we are dealing with&n; *&t;@parent_bh: the buffer_head which contains *@first and *@last&n; *&t;@first:&t;array of block numbers&n; *&t;@last:&t;pointer immediately past the end of array&n; *&t;@depth:&t;depth of the branches to free&n; *&n; *&t;We are freeing all blocks refered from these branches (numbers are&n; *&t;stored as little-endian 32-bit) and updating @inode-&gt;i_blocks&n; *&t;appropriately.&n; */
DECL|function|ext3_free_branches
r_static
r_void
id|ext3_free_branches
c_func
(paren
id|handle_t
op_star
id|handle
comma
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|buffer_head
op_star
id|parent_bh
comma
id|u32
op_star
id|first
comma
id|u32
op_star
id|last
comma
r_int
id|depth
)paren
(brace
r_int
r_int
id|nr
suffix:semicolon
id|u32
op_star
id|p
suffix:semicolon
r_if
c_cond
(paren
id|is_handle_aborted
c_func
(paren
id|handle
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|depth
op_decrement
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
r_int
id|addr_per_block
op_assign
id|EXT3_ADDR_PER_BLOCK
c_func
(paren
id|inode-&gt;i_sb
)paren
suffix:semicolon
id|p
op_assign
id|last
suffix:semicolon
r_while
c_loop
(paren
op_decrement
id|p
op_ge
id|first
)paren
(brace
id|nr
op_assign
id|le32_to_cpu
c_func
(paren
op_star
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|nr
)paren
r_continue
suffix:semicolon
multiline_comment|/* A hole */
multiline_comment|/* Go read the buffer for the next level down */
id|bh
op_assign
id|sb_bread
c_func
(paren
id|inode-&gt;i_sb
comma
id|nr
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * A read failure? Report error and clear slot&n;&t;&t;&t; * (should be rare).&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|bh
)paren
(brace
id|ext3_error
c_func
(paren
id|inode-&gt;i_sb
comma
l_string|&quot;ext3_free_branches&quot;
comma
l_string|&quot;Read failure, inode=%ld, block=%ld&quot;
comma
id|inode-&gt;i_ino
comma
id|nr
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* This zaps the entire block.  Bottom up. */
id|BUFFER_TRACE
c_func
(paren
id|bh
comma
l_string|&quot;free child branches&quot;
)paren
suffix:semicolon
id|ext3_free_branches
c_func
(paren
id|handle
comma
id|inode
comma
id|bh
comma
(paren
id|u32
op_star
)paren
id|bh-&gt;b_data
comma
(paren
id|u32
op_star
)paren
id|bh-&gt;b_data
op_plus
id|addr_per_block
comma
id|depth
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * We&squot;ve probably journalled the indirect block several&n;&t;&t;&t; * times during the truncate.  But it&squot;s no longer&n;&t;&t;&t; * needed and we now drop it from the transaction via&n;&t;&t;&t; * journal_revoke().&n;&t;&t;&t; *&n;&t;&t;&t; * That&squot;s easy if it&squot;s exclusively part of this&n;&t;&t;&t; * transaction.  But if it&squot;s part of the committing&n;&t;&t;&t; * transaction then journal_forget() will simply&n;&t;&t;&t; * brelse() it.  That means that if the underlying&n;&t;&t;&t; * block is reallocated in ext3_get_block(),&n;&t;&t;&t; * unmap_underlying_metadata() will find this block&n;&t;&t;&t; * and will try to get rid of it.  damn, damn.&n;&t;&t;&t; *&n;&t;&t;&t; * If this block has already been committed to the&n;&t;&t;&t; * journal, a revoke record will be written.  And&n;&t;&t;&t; * revoke records must be emitted *before* clearing&n;&t;&t;&t; * this block&squot;s bit in the bitmaps.&n;&t;&t;&t; */
id|ext3_forget
c_func
(paren
id|handle
comma
l_int|1
comma
id|inode
comma
id|bh
comma
id|bh-&gt;b_blocknr
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Everything below this this pointer has been&n;&t;&t;&t; * released.  Now let this top-of-subtree go.&n;&t;&t;&t; *&n;&t;&t;&t; * We want the freeing of this indirect block to be&n;&t;&t;&t; * atomic in the journal with the updating of the&n;&t;&t;&t; * bitmap block which owns it.  So make some room in&n;&t;&t;&t; * the journal.&n;&t;&t;&t; *&n;&t;&t;&t; * We zero the parent pointer *after* freeing its&n;&t;&t;&t; * pointee in the bitmaps, so if extend_transaction()&n;&t;&t;&t; * for some reason fails to put the bitmap changes and&n;&t;&t;&t; * the release into the same transaction, recovery&n;&t;&t;&t; * will merely complain about releasing a free block,&n;&t;&t;&t; * rather than leaking blocks.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|is_handle_aborted
c_func
(paren
id|handle
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|try_to_extend_transaction
c_func
(paren
id|handle
comma
id|inode
)paren
)paren
(brace
id|ext3_mark_inode_dirty
c_func
(paren
id|handle
comma
id|inode
)paren
suffix:semicolon
id|ext3_journal_test_restart
c_func
(paren
id|handle
comma
id|inode
)paren
suffix:semicolon
)brace
id|ext3_free_blocks
c_func
(paren
id|handle
comma
id|inode
comma
id|nr
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|parent_bh
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * The block which we have just freed is&n;&t;&t;&t;&t; * pointed to by an indirect block: journal it&n;&t;&t;&t;&t; */
id|BUFFER_TRACE
c_func
(paren
id|parent_bh
comma
l_string|&quot;get_write_access&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ext3_journal_get_write_access
c_func
(paren
id|handle
comma
id|parent_bh
)paren
)paren
(brace
op_star
id|p
op_assign
l_int|0
suffix:semicolon
id|BUFFER_TRACE
c_func
(paren
id|parent_bh
comma
l_string|&quot;call ext3_journal_dirty_metadata&quot;
)paren
suffix:semicolon
id|ext3_journal_dirty_metadata
c_func
(paren
id|handle
comma
id|parent_bh
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
r_else
(brace
multiline_comment|/* We have reached the bottom of the tree. */
id|BUFFER_TRACE
c_func
(paren
id|parent_bh
comma
l_string|&quot;free data blocks&quot;
)paren
suffix:semicolon
id|ext3_free_data
c_func
(paren
id|handle
comma
id|inode
comma
id|parent_bh
comma
id|first
comma
id|last
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * ext3_truncate()&n; *&n; * We block out ext3_get_block() block instantiations across the entire&n; * transaction, and VFS/VM ensures that ext3_truncate() cannot run&n; * simultaneously on behalf of the same inode.&n; *&n; * As we work through the truncate and commmit bits of it to the journal there&n; * is one core, guiding principle: the file&squot;s tree must always be consistent on&n; * disk.  We must be able to restart the truncate after a crash.&n; *&n; * The file&squot;s tree may be transiently inconsistent in memory (although it&n; * probably isn&squot;t), but whenever we close off and commit a journal transaction,&n; * the contents of (the filesystem + the journal) must be consistent and&n; * restartable.  It&squot;s pretty simple, really: bottom up, right to left (although&n; * left-to-right works OK too).&n; *&n; * Note that at recovery time, journal replay occurs *before* the restart of&n; * truncate against the orphan inode list.&n; *&n; * The committed inode has the new, desired i_size (which is the same as&n; * i_disksize in this case).  After a crash, ext3_orphan_cleanup() will see&n; * that this inode&squot;s truncate did not complete and it will again call&n; * ext3_truncate() to have another go.  So there will be instantiated blocks&n; * to the right of the truncation point in a crashed ext3 filesystem.  But&n; * that&squot;s fine - as long as they are linked from the inode, the post-crash&n; * ext3_truncate() run will find them and release them.&n; */
DECL|function|ext3_truncate
r_void
id|ext3_truncate
c_func
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
id|handle_t
op_star
id|handle
suffix:semicolon
r_struct
id|ext3_inode_info
op_star
id|ei
op_assign
id|EXT3_I
c_func
(paren
id|inode
)paren
suffix:semicolon
id|u32
op_star
id|i_data
op_assign
id|ei-&gt;i_data
suffix:semicolon
r_int
id|addr_per_block
op_assign
id|EXT3_ADDR_PER_BLOCK
c_func
(paren
id|inode-&gt;i_sb
)paren
suffix:semicolon
r_int
id|offsets
(braket
l_int|4
)braket
suffix:semicolon
id|Indirect
id|chain
(braket
l_int|4
)braket
suffix:semicolon
id|Indirect
op_star
id|partial
suffix:semicolon
r_int
id|nr
op_assign
l_int|0
suffix:semicolon
r_int
id|n
suffix:semicolon
r_int
id|last_block
suffix:semicolon
r_int
id|blocksize
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|S_ISREG
c_func
(paren
id|inode-&gt;i_mode
)paren
op_logical_or
id|S_ISDIR
c_func
(paren
id|inode-&gt;i_mode
)paren
op_logical_or
id|S_ISLNK
c_func
(paren
id|inode-&gt;i_mode
)paren
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|IS_APPEND
c_func
(paren
id|inode
)paren
op_logical_or
id|IS_IMMUTABLE
c_func
(paren
id|inode
)paren
)paren
r_return
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|ext3_discard_prealloc
c_func
(paren
id|inode
)paren
suffix:semicolon
id|handle
op_assign
id|start_transaction
c_func
(paren
id|inode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|handle
)paren
)paren
(brace
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
multiline_comment|/* AKPM: return what? */
)brace
id|blocksize
op_assign
id|inode-&gt;i_sb-&gt;s_blocksize
suffix:semicolon
id|last_block
op_assign
(paren
id|inode-&gt;i_size
op_plus
id|blocksize
op_minus
l_int|1
)paren
op_rshift
id|EXT3_BLOCK_SIZE_BITS
c_func
(paren
id|inode-&gt;i_sb
)paren
suffix:semicolon
id|ext3_block_truncate_page
c_func
(paren
id|handle
comma
id|inode-&gt;i_mapping
comma
id|inode-&gt;i_size
)paren
suffix:semicolon
id|n
op_assign
id|ext3_block_to_path
c_func
(paren
id|inode
comma
id|last_block
comma
id|offsets
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|n
op_eq
l_int|0
)paren
r_goto
id|out_stop
suffix:semicolon
multiline_comment|/* error */
multiline_comment|/*&n;&t; * OK.  This truncate is going to happen.  We add the inode to the&n;&t; * orphan list, so that if this truncate spans multiple transactions,&n;&t; * and we crash, we will resume the truncate when the filesystem&n;&t; * recovers.  It also marks the inode dirty, to catch the new size.&n;&t; *&n;&t; * Implication: the file must always be in a sane, consistent&n;&t; * truncatable state while each transaction commits.&n;&t; */
r_if
c_cond
(paren
id|ext3_orphan_add
c_func
(paren
id|handle
comma
id|inode
)paren
)paren
r_goto
id|out_stop
suffix:semicolon
multiline_comment|/*&n;&t; * The orphan list entry will now protect us from any crash which&n;&t; * occurs before the truncate completes, so it is now safe to propagate&n;&t; * the new, shorter inode size (held for now in i_size) into the&n;&t; * on-disk inode. We do this via i_disksize, which is the value which&n;&t; * ext3 *really* writes onto the disk inode.&n;&t; */
id|ei-&gt;i_disksize
op_assign
id|inode-&gt;i_size
suffix:semicolon
multiline_comment|/*&n;&t; * From here we block out all ext3_get_block() callers who want to&n;&t; * modify the block allocation tree.&n;&t; */
id|down_write
c_func
(paren
op_amp
id|ei-&gt;truncate_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|n
op_eq
l_int|1
)paren
(brace
multiline_comment|/* direct blocks */
id|ext3_free_data
c_func
(paren
id|handle
comma
id|inode
comma
l_int|NULL
comma
id|i_data
op_plus
id|offsets
(braket
l_int|0
)braket
comma
id|i_data
op_plus
id|EXT3_NDIR_BLOCKS
)paren
suffix:semicolon
r_goto
id|do_indirects
suffix:semicolon
)brace
id|partial
op_assign
id|ext3_find_shared
c_func
(paren
id|inode
comma
id|n
comma
id|offsets
comma
id|chain
comma
op_amp
id|nr
)paren
suffix:semicolon
multiline_comment|/* Kill the top of shared branch (not detached) */
r_if
c_cond
(paren
id|nr
)paren
(brace
r_if
c_cond
(paren
id|partial
op_eq
id|chain
)paren
(brace
multiline_comment|/* Shared branch grows from the inode */
id|ext3_free_branches
c_func
(paren
id|handle
comma
id|inode
comma
l_int|NULL
comma
op_amp
id|nr
comma
op_amp
id|nr
op_plus
l_int|1
comma
(paren
id|chain
op_plus
id|n
op_minus
l_int|1
)paren
op_minus
id|partial
)paren
suffix:semicolon
op_star
id|partial-&gt;p
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * We mark the inode dirty prior to restart,&n;&t;&t;&t; * and prior to stop.  No need for it here.&n;&t;&t;&t; */
)brace
r_else
(brace
multiline_comment|/* Shared branch grows from an indirect block */
id|BUFFER_TRACE
c_func
(paren
id|partial-&gt;bh
comma
l_string|&quot;get_write_access&quot;
)paren
suffix:semicolon
id|ext3_free_branches
c_func
(paren
id|handle
comma
id|inode
comma
id|partial-&gt;bh
comma
id|partial-&gt;p
comma
id|partial-&gt;p
op_plus
l_int|1
comma
(paren
id|chain
op_plus
id|n
op_minus
l_int|1
)paren
op_minus
id|partial
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Clear the ends of indirect blocks on the shared branch */
r_while
c_loop
(paren
id|partial
OG
id|chain
)paren
(brace
id|ext3_free_branches
c_func
(paren
id|handle
comma
id|inode
comma
id|partial-&gt;bh
comma
id|partial-&gt;p
op_plus
l_int|1
comma
(paren
id|u32
op_star
)paren
id|partial-&gt;bh-&gt;b_data
op_plus
id|addr_per_block
comma
(paren
id|chain
op_plus
id|n
op_minus
l_int|1
)paren
op_minus
id|partial
)paren
suffix:semicolon
id|BUFFER_TRACE
c_func
(paren
id|partial-&gt;bh
comma
l_string|&quot;call brelse&quot;
)paren
suffix:semicolon
id|brelse
(paren
id|partial-&gt;bh
)paren
suffix:semicolon
id|partial
op_decrement
suffix:semicolon
)brace
id|do_indirects
suffix:colon
multiline_comment|/* Kill the remaining (whole) subtrees */
r_switch
c_cond
(paren
id|offsets
(braket
l_int|0
)braket
)paren
(brace
r_default
suffix:colon
id|nr
op_assign
id|i_data
(braket
id|EXT3_IND_BLOCK
)braket
suffix:semicolon
r_if
c_cond
(paren
id|nr
)paren
(brace
id|ext3_free_branches
c_func
(paren
id|handle
comma
id|inode
comma
l_int|NULL
comma
op_amp
id|nr
comma
op_amp
id|nr
op_plus
l_int|1
comma
l_int|1
)paren
suffix:semicolon
id|i_data
(braket
id|EXT3_IND_BLOCK
)braket
op_assign
l_int|0
suffix:semicolon
)brace
r_case
id|EXT3_IND_BLOCK
suffix:colon
id|nr
op_assign
id|i_data
(braket
id|EXT3_DIND_BLOCK
)braket
suffix:semicolon
r_if
c_cond
(paren
id|nr
)paren
(brace
id|ext3_free_branches
c_func
(paren
id|handle
comma
id|inode
comma
l_int|NULL
comma
op_amp
id|nr
comma
op_amp
id|nr
op_plus
l_int|1
comma
l_int|2
)paren
suffix:semicolon
id|i_data
(braket
id|EXT3_DIND_BLOCK
)braket
op_assign
l_int|0
suffix:semicolon
)brace
r_case
id|EXT3_DIND_BLOCK
suffix:colon
id|nr
op_assign
id|i_data
(braket
id|EXT3_TIND_BLOCK
)braket
suffix:semicolon
r_if
c_cond
(paren
id|nr
)paren
(brace
id|ext3_free_branches
c_func
(paren
id|handle
comma
id|inode
comma
l_int|NULL
comma
op_amp
id|nr
comma
op_amp
id|nr
op_plus
l_int|1
comma
l_int|3
)paren
suffix:semicolon
id|i_data
(braket
id|EXT3_TIND_BLOCK
)braket
op_assign
l_int|0
suffix:semicolon
)brace
r_case
id|EXT3_TIND_BLOCK
suffix:colon
suffix:semicolon
)brace
id|up_write
c_func
(paren
op_amp
id|ei-&gt;truncate_sem
)paren
suffix:semicolon
id|inode-&gt;i_mtime
op_assign
id|inode-&gt;i_ctime
op_assign
id|CURRENT_TIME
suffix:semicolon
id|ext3_mark_inode_dirty
c_func
(paren
id|handle
comma
id|inode
)paren
suffix:semicolon
multiline_comment|/* In a multi-transaction truncate, we only make the final&n;&t; * transaction synchronous */
r_if
c_cond
(paren
id|IS_SYNC
c_func
(paren
id|inode
)paren
)paren
id|handle-&gt;h_sync
op_assign
l_int|1
suffix:semicolon
id|out_stop
suffix:colon
multiline_comment|/*&n;&t; * If this was a simple ftruncate(), and the file will remain alive&n;&t; * then we need to clear up the orphan record which we created above.&n;&t; * However, if this was a real unlink then we were called by&n;&t; * ext3_delete_inode(), and we allow that function to clean up the&n;&t; * orphan info for us.&n;&t; */
r_if
c_cond
(paren
id|inode-&gt;i_nlink
)paren
id|ext3_orphan_del
c_func
(paren
id|handle
comma
id|inode
)paren
suffix:semicolon
id|ext3_journal_stop
c_func
(paren
id|handle
comma
id|inode
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* &n; * ext3_get_inode_loc returns with an extra refcount against the&n; * inode&squot;s underlying buffer_head on success. &n; */
DECL|function|ext3_get_inode_loc
r_int
id|ext3_get_inode_loc
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|ext3_iloc
op_star
id|iloc
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|block
suffix:semicolon
r_int
r_int
id|block_group
suffix:semicolon
r_int
r_int
id|group_desc
suffix:semicolon
r_int
r_int
id|desc
suffix:semicolon
r_int
r_int
id|offset
suffix:semicolon
r_struct
id|ext3_group_desc
op_star
id|gdp
suffix:semicolon
r_if
c_cond
(paren
(paren
id|inode-&gt;i_ino
op_ne
id|EXT3_ROOT_INO
op_logical_and
id|inode-&gt;i_ino
op_ne
id|EXT3_ACL_IDX_INO
op_logical_and
id|inode-&gt;i_ino
op_ne
id|EXT3_ACL_DATA_INO
op_logical_and
id|inode-&gt;i_ino
op_ne
id|EXT3_JOURNAL_INO
op_logical_and
id|inode-&gt;i_ino
OL
id|EXT3_FIRST_INO
c_func
(paren
id|inode-&gt;i_sb
)paren
)paren
op_logical_or
id|inode-&gt;i_ino
OG
id|le32_to_cpu
c_func
(paren
id|inode-&gt;i_sb-&gt;u.ext3_sb.s_es-&gt;s_inodes_count
)paren
)paren
(brace
id|ext3_error
(paren
id|inode-&gt;i_sb
comma
l_string|&quot;ext3_get_inode_loc&quot;
comma
l_string|&quot;bad inode number: %lu&quot;
comma
id|inode-&gt;i_ino
)paren
suffix:semicolon
r_goto
id|bad_inode
suffix:semicolon
)brace
id|block_group
op_assign
(paren
id|inode-&gt;i_ino
op_minus
l_int|1
)paren
op_div
id|EXT3_INODES_PER_GROUP
c_func
(paren
id|inode-&gt;i_sb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|block_group
op_ge
id|inode-&gt;i_sb-&gt;u.ext3_sb.s_groups_count
)paren
(brace
id|ext3_error
(paren
id|inode-&gt;i_sb
comma
l_string|&quot;ext3_get_inode_loc&quot;
comma
l_string|&quot;group &gt;= groups count&quot;
)paren
suffix:semicolon
r_goto
id|bad_inode
suffix:semicolon
)brace
id|group_desc
op_assign
id|block_group
op_rshift
id|EXT3_DESC_PER_BLOCK_BITS
c_func
(paren
id|inode-&gt;i_sb
)paren
suffix:semicolon
id|desc
op_assign
id|block_group
op_amp
(paren
id|EXT3_DESC_PER_BLOCK
c_func
(paren
id|inode-&gt;i_sb
)paren
op_minus
l_int|1
)paren
suffix:semicolon
id|bh
op_assign
id|inode-&gt;i_sb-&gt;u.ext3_sb.s_group_desc
(braket
id|group_desc
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bh
)paren
(brace
id|ext3_error
(paren
id|inode-&gt;i_sb
comma
l_string|&quot;ext3_get_inode_loc&quot;
comma
l_string|&quot;Descriptor not loaded&quot;
)paren
suffix:semicolon
r_goto
id|bad_inode
suffix:semicolon
)brace
id|gdp
op_assign
(paren
r_struct
id|ext3_group_desc
op_star
)paren
id|bh-&gt;b_data
suffix:semicolon
multiline_comment|/*&n;&t; * Figure out the offset within the block group inode table&n;&t; */
id|offset
op_assign
(paren
(paren
id|inode-&gt;i_ino
op_minus
l_int|1
)paren
op_mod
id|EXT3_INODES_PER_GROUP
c_func
(paren
id|inode-&gt;i_sb
)paren
)paren
op_star
id|EXT3_INODE_SIZE
c_func
(paren
id|inode-&gt;i_sb
)paren
suffix:semicolon
id|block
op_assign
id|le32_to_cpu
c_func
(paren
id|gdp
(braket
id|desc
)braket
dot
id|bg_inode_table
)paren
op_plus
(paren
id|offset
op_rshift
id|EXT3_BLOCK_SIZE_BITS
c_func
(paren
id|inode-&gt;i_sb
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|bh
op_assign
id|sb_bread
c_func
(paren
id|inode-&gt;i_sb
comma
id|block
)paren
)paren
)paren
(brace
id|ext3_error
(paren
id|inode-&gt;i_sb
comma
l_string|&quot;ext3_get_inode_loc&quot;
comma
l_string|&quot;unable to read inode block - &quot;
l_string|&quot;inode=%lu, block=%lu&quot;
comma
id|inode-&gt;i_ino
comma
id|block
)paren
suffix:semicolon
r_goto
id|bad_inode
suffix:semicolon
)brace
id|offset
op_and_assign
(paren
id|EXT3_BLOCK_SIZE
c_func
(paren
id|inode-&gt;i_sb
)paren
op_minus
l_int|1
)paren
suffix:semicolon
id|iloc-&gt;bh
op_assign
id|bh
suffix:semicolon
id|iloc-&gt;raw_inode
op_assign
(paren
r_struct
id|ext3_inode
op_star
)paren
(paren
id|bh-&gt;b_data
op_plus
id|offset
)paren
suffix:semicolon
id|iloc-&gt;block_group
op_assign
id|block_group
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|bad_inode
suffix:colon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
DECL|function|ext3_read_inode
r_void
id|ext3_read_inode
c_func
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
r_struct
id|ext3_iloc
id|iloc
suffix:semicolon
r_struct
id|ext3_inode
op_star
id|raw_inode
suffix:semicolon
r_struct
id|ext3_inode_info
op_star
id|ei
op_assign
id|EXT3_I
c_func
(paren
id|inode
)paren
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
r_int
id|block
suffix:semicolon
r_if
c_cond
(paren
id|ext3_get_inode_loc
c_func
(paren
id|inode
comma
op_amp
id|iloc
)paren
)paren
(brace
r_goto
id|bad_inode
suffix:semicolon
)brace
id|bh
op_assign
id|iloc.bh
suffix:semicolon
id|raw_inode
op_assign
id|iloc.raw_inode
suffix:semicolon
id|inode-&gt;i_mode
op_assign
id|le16_to_cpu
c_func
(paren
id|raw_inode-&gt;i_mode
)paren
suffix:semicolon
id|inode-&gt;i_uid
op_assign
(paren
id|uid_t
)paren
id|le16_to_cpu
c_func
(paren
id|raw_inode-&gt;i_uid_low
)paren
suffix:semicolon
id|inode-&gt;i_gid
op_assign
(paren
id|gid_t
)paren
id|le16_to_cpu
c_func
(paren
id|raw_inode-&gt;i_gid_low
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|test_opt
(paren
id|inode-&gt;i_sb
comma
id|NO_UID32
)paren
)paren
)paren
(brace
id|inode-&gt;i_uid
op_or_assign
id|le16_to_cpu
c_func
(paren
id|raw_inode-&gt;i_uid_high
)paren
op_lshift
l_int|16
suffix:semicolon
id|inode-&gt;i_gid
op_or_assign
id|le16_to_cpu
c_func
(paren
id|raw_inode-&gt;i_gid_high
)paren
op_lshift
l_int|16
suffix:semicolon
)brace
id|inode-&gt;i_nlink
op_assign
id|le16_to_cpu
c_func
(paren
id|raw_inode-&gt;i_links_count
)paren
suffix:semicolon
id|inode-&gt;i_size
op_assign
id|le32_to_cpu
c_func
(paren
id|raw_inode-&gt;i_size
)paren
suffix:semicolon
id|inode-&gt;i_atime
op_assign
id|le32_to_cpu
c_func
(paren
id|raw_inode-&gt;i_atime
)paren
suffix:semicolon
id|inode-&gt;i_ctime
op_assign
id|le32_to_cpu
c_func
(paren
id|raw_inode-&gt;i_ctime
)paren
suffix:semicolon
id|inode-&gt;i_mtime
op_assign
id|le32_to_cpu
c_func
(paren
id|raw_inode-&gt;i_mtime
)paren
suffix:semicolon
id|ei-&gt;i_state
op_assign
l_int|0
suffix:semicolon
id|ei-&gt;i_next_alloc_block
op_assign
l_int|0
suffix:semicolon
id|ei-&gt;i_next_alloc_goal
op_assign
l_int|0
suffix:semicolon
id|ei-&gt;i_dir_start_lookup
op_assign
l_int|0
suffix:semicolon
id|ei-&gt;i_dtime
op_assign
id|le32_to_cpu
c_func
(paren
id|raw_inode-&gt;i_dtime
)paren
suffix:semicolon
multiline_comment|/* We now have enough fields to check if the inode was active or not.&n;&t; * This is needed because nfsd might try to access dead inodes&n;&t; * the test is that same one that e2fsck uses&n;&t; * NeilBrown 1999oct15&n;&t; */
r_if
c_cond
(paren
id|inode-&gt;i_nlink
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|inode-&gt;i_mode
op_eq
l_int|0
op_logical_or
op_logical_neg
(paren
id|inode-&gt;i_sb-&gt;u.ext3_sb.s_mount_state
op_amp
id|EXT3_ORPHAN_FS
)paren
)paren
(brace
multiline_comment|/* this inode is deleted */
id|brelse
(paren
id|bh
)paren
suffix:semicolon
r_goto
id|bad_inode
suffix:semicolon
)brace
multiline_comment|/* The only unlinked inodes we let through here have&n;&t;&t; * valid i_mode and are being read by the orphan&n;&t;&t; * recovery code: that&squot;s fine, we&squot;re about to complete&n;&t;&t; * the process of deleting those. */
)brace
id|inode-&gt;i_blksize
op_assign
id|PAGE_SIZE
suffix:semicolon
multiline_comment|/* This is the optimal IO size&n;&t;&t;&t;&t;&t; * (for stat), not the fs block&n;&t;&t;&t;&t;&t; * size */
id|inode-&gt;i_blocks
op_assign
id|le32_to_cpu
c_func
(paren
id|raw_inode-&gt;i_blocks
)paren
suffix:semicolon
id|inode-&gt;i_version
op_assign
op_increment
id|event
suffix:semicolon
id|ei-&gt;i_flags
op_assign
id|le32_to_cpu
c_func
(paren
id|raw_inode-&gt;i_flags
)paren
suffix:semicolon
macro_line|#ifdef EXT3_FRAGMENTS
id|ei-&gt;i_faddr
op_assign
id|le32_to_cpu
c_func
(paren
id|raw_inode-&gt;i_faddr
)paren
suffix:semicolon
id|ei-&gt;i_frag_no
op_assign
id|raw_inode-&gt;i_frag
suffix:semicolon
id|ei-&gt;i_frag_size
op_assign
id|raw_inode-&gt;i_fsize
suffix:semicolon
macro_line|#endif
id|ei-&gt;i_file_acl
op_assign
id|le32_to_cpu
c_func
(paren
id|raw_inode-&gt;i_file_acl
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|S_ISREG
c_func
(paren
id|inode-&gt;i_mode
)paren
)paren
(brace
id|ei-&gt;i_dir_acl
op_assign
id|le32_to_cpu
c_func
(paren
id|raw_inode-&gt;i_dir_acl
)paren
suffix:semicolon
)brace
r_else
(brace
id|inode-&gt;i_size
op_or_assign
(paren
(paren
id|__u64
)paren
id|le32_to_cpu
c_func
(paren
id|raw_inode-&gt;i_size_high
)paren
)paren
op_lshift
l_int|32
suffix:semicolon
)brace
id|ei-&gt;i_disksize
op_assign
id|inode-&gt;i_size
suffix:semicolon
id|inode-&gt;i_generation
op_assign
id|le32_to_cpu
c_func
(paren
id|raw_inode-&gt;i_generation
)paren
suffix:semicolon
macro_line|#ifdef EXT3_PREALLOCATE
id|ei-&gt;i_prealloc_count
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
id|ei-&gt;i_block_group
op_assign
id|iloc.block_group
suffix:semicolon
multiline_comment|/*&n;&t; * NOTE! The in-memory inode i_data array is in little-endian order&n;&t; * even on big-endian machines: we do NOT byteswap the block numbers!&n;&t; */
r_for
c_loop
(paren
id|block
op_assign
l_int|0
suffix:semicolon
id|block
OL
id|EXT3_N_BLOCKS
suffix:semicolon
id|block
op_increment
)paren
id|ei-&gt;i_data
(braket
id|block
)braket
op_assign
id|iloc.raw_inode-&gt;i_block
(braket
id|block
)braket
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|ei-&gt;i_orphan
)paren
suffix:semicolon
id|brelse
(paren
id|iloc.bh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inode-&gt;i_ino
op_eq
id|EXT3_ACL_IDX_INO
op_logical_or
id|inode-&gt;i_ino
op_eq
id|EXT3_ACL_DATA_INO
)paren
multiline_comment|/* Nothing to do */
suffix:semicolon
r_else
r_if
c_cond
(paren
id|S_ISREG
c_func
(paren
id|inode-&gt;i_mode
)paren
)paren
(brace
id|inode-&gt;i_op
op_assign
op_amp
id|ext3_file_inode_operations
suffix:semicolon
id|inode-&gt;i_fop
op_assign
op_amp
id|ext3_file_operations
suffix:semicolon
r_if
c_cond
(paren
id|ext3_should_writeback_data
c_func
(paren
id|inode
)paren
)paren
id|inode-&gt;i_mapping-&gt;a_ops
op_assign
op_amp
id|ext3_writeback_aops
suffix:semicolon
r_else
id|inode-&gt;i_mapping-&gt;a_ops
op_assign
op_amp
id|ext3_aops
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|S_ISDIR
c_func
(paren
id|inode-&gt;i_mode
)paren
)paren
(brace
id|inode-&gt;i_op
op_assign
op_amp
id|ext3_dir_inode_operations
suffix:semicolon
id|inode-&gt;i_fop
op_assign
op_amp
id|ext3_dir_operations
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|S_ISLNK
c_func
(paren
id|inode-&gt;i_mode
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|inode-&gt;i_blocks
)paren
id|inode-&gt;i_op
op_assign
op_amp
id|ext3_fast_symlink_inode_operations
suffix:semicolon
r_else
(brace
id|inode-&gt;i_op
op_assign
op_amp
id|page_symlink_inode_operations
suffix:semicolon
r_if
c_cond
(paren
id|ext3_should_writeback_data
c_func
(paren
id|inode
)paren
)paren
id|inode-&gt;i_mapping-&gt;a_ops
op_assign
op_amp
id|ext3_writeback_aops
suffix:semicolon
r_else
id|inode-&gt;i_mapping-&gt;a_ops
op_assign
op_amp
id|ext3_aops
suffix:semicolon
)brace
)brace
r_else
id|init_special_inode
c_func
(paren
id|inode
comma
id|inode-&gt;i_mode
comma
id|le32_to_cpu
c_func
(paren
id|iloc.raw_inode-&gt;i_block
(braket
l_int|0
)braket
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ei-&gt;i_flags
op_amp
id|EXT3_SYNC_FL
)paren
id|inode-&gt;i_flags
op_or_assign
id|S_SYNC
suffix:semicolon
r_if
c_cond
(paren
id|ei-&gt;i_flags
op_amp
id|EXT3_APPEND_FL
)paren
id|inode-&gt;i_flags
op_or_assign
id|S_APPEND
suffix:semicolon
r_if
c_cond
(paren
id|ei-&gt;i_flags
op_amp
id|EXT3_IMMUTABLE_FL
)paren
id|inode-&gt;i_flags
op_or_assign
id|S_IMMUTABLE
suffix:semicolon
r_if
c_cond
(paren
id|ei-&gt;i_flags
op_amp
id|EXT3_NOATIME_FL
)paren
id|inode-&gt;i_flags
op_or_assign
id|S_NOATIME
suffix:semicolon
r_return
suffix:semicolon
id|bad_inode
suffix:colon
id|make_bad_inode
c_func
(paren
id|inode
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * Post the struct inode info into an on-disk inode location in the&n; * buffer-cache.  This gobbles the caller&squot;s reference to the&n; * buffer_head in the inode location struct.  &n; */
DECL|function|ext3_do_update_inode
r_static
r_int
id|ext3_do_update_inode
c_func
(paren
id|handle_t
op_star
id|handle
comma
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|ext3_iloc
op_star
id|iloc
)paren
(brace
r_struct
id|ext3_inode
op_star
id|raw_inode
op_assign
id|iloc-&gt;raw_inode
suffix:semicolon
r_struct
id|ext3_inode_info
op_star
id|ei
op_assign
id|EXT3_I
c_func
(paren
id|inode
)paren
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
op_assign
id|iloc-&gt;bh
suffix:semicolon
r_int
id|err
op_assign
l_int|0
comma
id|rc
comma
id|block
suffix:semicolon
r_if
c_cond
(paren
id|handle
)paren
(brace
id|BUFFER_TRACE
c_func
(paren
id|bh
comma
l_string|&quot;get_write_access&quot;
)paren
suffix:semicolon
id|err
op_assign
id|ext3_journal_get_write_access
c_func
(paren
id|handle
comma
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out_brelse
suffix:semicolon
)brace
id|raw_inode-&gt;i_mode
op_assign
id|cpu_to_le16
c_func
(paren
id|inode-&gt;i_mode
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|test_opt
c_func
(paren
id|inode-&gt;i_sb
comma
id|NO_UID32
)paren
)paren
)paren
(brace
id|raw_inode-&gt;i_uid_low
op_assign
id|cpu_to_le16
c_func
(paren
id|low_16_bits
c_func
(paren
id|inode-&gt;i_uid
)paren
)paren
suffix:semicolon
id|raw_inode-&gt;i_gid_low
op_assign
id|cpu_to_le16
c_func
(paren
id|low_16_bits
c_func
(paren
id|inode-&gt;i_gid
)paren
)paren
suffix:semicolon
multiline_comment|/*&n; * Fix up interoperability with old kernels. Otherwise, old inodes get&n; * re-used with the upper 16 bits of the uid/gid intact&n; */
r_if
c_cond
(paren
op_logical_neg
id|ei-&gt;i_dtime
)paren
(brace
id|raw_inode-&gt;i_uid_high
op_assign
id|cpu_to_le16
c_func
(paren
id|high_16_bits
c_func
(paren
id|inode-&gt;i_uid
)paren
)paren
suffix:semicolon
id|raw_inode-&gt;i_gid_high
op_assign
id|cpu_to_le16
c_func
(paren
id|high_16_bits
c_func
(paren
id|inode-&gt;i_gid
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|raw_inode-&gt;i_uid_high
op_assign
l_int|0
suffix:semicolon
id|raw_inode-&gt;i_gid_high
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_else
(brace
id|raw_inode-&gt;i_uid_low
op_assign
id|cpu_to_le16
c_func
(paren
id|fs_high2lowuid
c_func
(paren
id|inode-&gt;i_uid
)paren
)paren
suffix:semicolon
id|raw_inode-&gt;i_gid_low
op_assign
id|cpu_to_le16
c_func
(paren
id|fs_high2lowgid
c_func
(paren
id|inode-&gt;i_gid
)paren
)paren
suffix:semicolon
id|raw_inode-&gt;i_uid_high
op_assign
l_int|0
suffix:semicolon
id|raw_inode-&gt;i_gid_high
op_assign
l_int|0
suffix:semicolon
)brace
id|raw_inode-&gt;i_links_count
op_assign
id|cpu_to_le16
c_func
(paren
id|inode-&gt;i_nlink
)paren
suffix:semicolon
id|raw_inode-&gt;i_size
op_assign
id|cpu_to_le32
c_func
(paren
id|ei-&gt;i_disksize
)paren
suffix:semicolon
id|raw_inode-&gt;i_atime
op_assign
id|cpu_to_le32
c_func
(paren
id|inode-&gt;i_atime
)paren
suffix:semicolon
id|raw_inode-&gt;i_ctime
op_assign
id|cpu_to_le32
c_func
(paren
id|inode-&gt;i_ctime
)paren
suffix:semicolon
id|raw_inode-&gt;i_mtime
op_assign
id|cpu_to_le32
c_func
(paren
id|inode-&gt;i_mtime
)paren
suffix:semicolon
id|raw_inode-&gt;i_blocks
op_assign
id|cpu_to_le32
c_func
(paren
id|inode-&gt;i_blocks
)paren
suffix:semicolon
id|raw_inode-&gt;i_dtime
op_assign
id|cpu_to_le32
c_func
(paren
id|ei-&gt;i_dtime
)paren
suffix:semicolon
id|raw_inode-&gt;i_flags
op_assign
id|cpu_to_le32
c_func
(paren
id|ei-&gt;i_flags
)paren
suffix:semicolon
macro_line|#ifdef EXT3_FRAGMENTS
id|raw_inode-&gt;i_faddr
op_assign
id|cpu_to_le32
c_func
(paren
id|ei-&gt;i_faddr
)paren
suffix:semicolon
id|raw_inode-&gt;i_frag
op_assign
id|ei-&gt;i_frag_no
suffix:semicolon
id|raw_inode-&gt;i_fsize
op_assign
id|ei-&gt;i_frag_size
suffix:semicolon
macro_line|#else
multiline_comment|/* If we are not tracking these fields in the in-memory inode,&n;&t; * then preserve them on disk, but still initialise them to zero&n;&t; * for new inodes. */
r_if
c_cond
(paren
id|ei-&gt;i_state
op_amp
id|EXT3_STATE_NEW
)paren
(brace
id|raw_inode-&gt;i_faddr
op_assign
l_int|0
suffix:semicolon
id|raw_inode-&gt;i_frag
op_assign
l_int|0
suffix:semicolon
id|raw_inode-&gt;i_fsize
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#endif
id|raw_inode-&gt;i_file_acl
op_assign
id|cpu_to_le32
c_func
(paren
id|ei-&gt;i_file_acl
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|S_ISREG
c_func
(paren
id|inode-&gt;i_mode
)paren
)paren
(brace
id|raw_inode-&gt;i_dir_acl
op_assign
id|cpu_to_le32
c_func
(paren
id|ei-&gt;i_dir_acl
)paren
suffix:semicolon
)brace
r_else
(brace
id|raw_inode-&gt;i_size_high
op_assign
id|cpu_to_le32
c_func
(paren
id|ei-&gt;i_disksize
op_rshift
l_int|32
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ei-&gt;i_disksize
OG
l_int|0x7fffffffULL
)paren
(brace
r_struct
id|super_block
op_star
id|sb
op_assign
id|inode-&gt;i_sb
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|EXT3_HAS_RO_COMPAT_FEATURE
c_func
(paren
id|sb
comma
id|EXT3_FEATURE_RO_COMPAT_LARGE_FILE
)paren
op_logical_or
id|EXT3_SB
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|s_es-&gt;s_rev_level
op_eq
id|cpu_to_le32
c_func
(paren
id|EXT3_GOOD_OLD_REV
)paren
)paren
(brace
multiline_comment|/* If this is the first large file&n;&t;&t;&t;&t;* created, add a flag to the superblock.&n;&t;&t;&t;&t;*/
id|err
op_assign
id|ext3_journal_get_write_access
c_func
(paren
id|handle
comma
id|sb-&gt;u.ext3_sb.s_sbh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out_brelse
suffix:semicolon
id|ext3_update_dynamic_rev
c_func
(paren
id|sb
)paren
suffix:semicolon
id|EXT3_SET_RO_COMPAT_FEATURE
c_func
(paren
id|sb
comma
id|EXT3_FEATURE_RO_COMPAT_LARGE_FILE
)paren
suffix:semicolon
id|sb-&gt;s_dirt
op_assign
l_int|1
suffix:semicolon
id|handle-&gt;h_sync
op_assign
l_int|1
suffix:semicolon
id|err
op_assign
id|ext3_journal_dirty_metadata
c_func
(paren
id|handle
comma
id|sb-&gt;u.ext3_sb.s_sbh
)paren
suffix:semicolon
)brace
)brace
)brace
id|raw_inode-&gt;i_generation
op_assign
id|le32_to_cpu
c_func
(paren
id|inode-&gt;i_generation
)paren
suffix:semicolon
r_if
c_cond
(paren
id|S_ISCHR
c_func
(paren
id|inode-&gt;i_mode
)paren
op_logical_or
id|S_ISBLK
c_func
(paren
id|inode-&gt;i_mode
)paren
)paren
id|raw_inode-&gt;i_block
(braket
l_int|0
)braket
op_assign
id|cpu_to_le32
c_func
(paren
id|kdev_t_to_nr
c_func
(paren
id|inode-&gt;i_rdev
)paren
)paren
suffix:semicolon
r_else
r_for
c_loop
(paren
id|block
op_assign
l_int|0
suffix:semicolon
id|block
OL
id|EXT3_N_BLOCKS
suffix:semicolon
id|block
op_increment
)paren
id|raw_inode-&gt;i_block
(braket
id|block
)braket
op_assign
id|ei-&gt;i_data
(braket
id|block
)braket
suffix:semicolon
id|BUFFER_TRACE
c_func
(paren
id|bh
comma
l_string|&quot;call ext3_journal_dirty_metadata&quot;
)paren
suffix:semicolon
id|rc
op_assign
id|ext3_journal_dirty_metadata
c_func
(paren
id|handle
comma
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|err
)paren
id|err
op_assign
id|rc
suffix:semicolon
id|ei-&gt;i_state
op_and_assign
op_complement
id|EXT3_STATE_NEW
suffix:semicolon
id|out_brelse
suffix:colon
id|brelse
(paren
id|bh
)paren
suffix:semicolon
id|ext3_std_error
c_func
(paren
id|inode-&gt;i_sb
comma
id|err
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; * ext3_write_inode()&n; *&n; * We are called from a few places:&n; *&n; * - Within generic_file_write() for O_SYNC files.&n; *   Here, there will be no transaction running. We wait for any running&n; *   trasnaction to commit.&n; *&n; * - Within sys_sync(), kupdate and such.&n; *   We wait on commit, if tol to.&n; *&n; * - Within prune_icache() (PF_MEMALLOC == true)&n; *   Here we simply return.  We can&squot;t afford to block kswapd on the&n; *   journal commit.&n; *&n; * In all cases it is actually safe for us to return without doing anything,&n; * because the inode has been copied into a raw inode buffer in&n; * ext3_mark_inode_dirty().  This is a correctness thing for O_SYNC and for&n; * knfsd.&n; *&n; * Note that we are absolutely dependent upon all inode dirtiers doing the&n; * right thing: they *must* call mark_inode_dirty() after dirtying info in&n; * which we are interested.&n; *&n; * It would be a bug for them to not do this.  The code:&n; *&n; *&t;mark_inode_dirty(inode)&n; *&t;stuff();&n; *&t;inode-&gt;i_size = expr;&n; *&n; * is in error because a kswapd-driven write_inode() could occur while&n; * `stuff()&squot; is running, and the new i_size will be lost.  Plus the inode&n; * will no longer be on the superblock&squot;s dirty inode list.&n; */
DECL|function|ext3_write_inode
r_void
id|ext3_write_inode
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_int
id|wait
)paren
(brace
r_if
c_cond
(paren
id|current-&gt;flags
op_amp
id|PF_MEMALLOC
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|ext3_journal_current_handle
c_func
(paren
)paren
)paren
(brace
id|jbd_debug
c_func
(paren
l_int|0
comma
l_string|&quot;called recursively, non-PF_MEMALLOC!&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|wait
)paren
r_return
suffix:semicolon
id|ext3_force_commit
c_func
(paren
id|inode-&gt;i_sb
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * ext3_setattr()&n; *&n; * Called from notify_change.&n; *&n; * We want to trap VFS attempts to truncate the file as soon as&n; * possible.  In particular, we want to make sure that when the VFS&n; * shrinks i_size, we put the inode on the orphan list and modify&n; * i_disksize immediately, so that during the subsequent flushing of&n; * dirty pages and freeing of disk blocks, we can guarantee that any&n; * commit will leave the blocks being flushed in an unused state on&n; * disk.  (On recovery, the inode will get truncated and the blocks will&n; * be freed, so we have a strong guarantee that no future commit will&n; * leave these blocks visible to the user.)  &n; *&n; * This is only needed for regular files.  rmdir() has its own path, and&n; * we can never truncate a direcory except on final unlink (at which&n; * point i_nlink is zero so recovery is easy.)&n; *&n; * Called with the BKL.  &n; */
DECL|function|ext3_setattr
r_int
id|ext3_setattr
c_func
(paren
r_struct
id|dentry
op_star
id|dentry
comma
r_struct
id|iattr
op_star
id|attr
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|dentry-&gt;d_inode
suffix:semicolon
r_int
id|error
comma
id|rc
op_assign
l_int|0
suffix:semicolon
r_const
r_int
r_int
id|ia_valid
op_assign
id|attr-&gt;ia_valid
suffix:semicolon
id|error
op_assign
id|inode_change_ok
c_func
(paren
id|inode
comma
id|attr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ia_valid
op_amp
id|ATTR_UID
op_logical_and
id|attr-&gt;ia_uid
op_ne
id|inode-&gt;i_uid
)paren
op_logical_or
(paren
id|ia_valid
op_amp
id|ATTR_GID
op_logical_and
id|attr-&gt;ia_gid
op_ne
id|inode-&gt;i_gid
)paren
)paren
(brace
id|error
op_assign
id|DQUOT_TRANSFER
c_func
(paren
id|inode
comma
id|attr
)paren
ques
c_cond
op_minus
id|EDQUOT
suffix:colon
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
)brace
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|attr-&gt;ia_valid
op_amp
id|ATTR_SIZE
op_logical_and
id|attr-&gt;ia_size
OL
id|inode-&gt;i_size
)paren
(brace
id|handle_t
op_star
id|handle
suffix:semicolon
id|handle
op_assign
id|ext3_journal_start
c_func
(paren
id|inode
comma
l_int|3
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|handle
)paren
)paren
(brace
id|error
op_assign
id|PTR_ERR
c_func
(paren
id|handle
)paren
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
id|error
op_assign
id|ext3_orphan_add
c_func
(paren
id|handle
comma
id|inode
)paren
suffix:semicolon
id|EXT3_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_disksize
op_assign
id|attr-&gt;ia_size
suffix:semicolon
id|rc
op_assign
id|ext3_mark_inode_dirty
c_func
(paren
id|handle
comma
id|inode
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
id|error
op_assign
id|rc
suffix:semicolon
id|ext3_journal_stop
c_func
(paren
id|handle
comma
id|inode
)paren
suffix:semicolon
)brace
id|rc
op_assign
id|inode_setattr
c_func
(paren
id|inode
comma
id|attr
)paren
suffix:semicolon
multiline_comment|/* If inode_setattr&squot;s call to ext3_truncate failed to get a&n;&t; * transaction handle at all, we need to clean up the in-core&n;&t; * orphan list manually. */
r_if
c_cond
(paren
id|inode-&gt;i_nlink
)paren
id|ext3_orphan_del
c_func
(paren
l_int|NULL
comma
id|inode
)paren
suffix:semicolon
id|err_out
suffix:colon
id|ext3_std_error
c_func
(paren
id|inode-&gt;i_sb
comma
id|error
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
id|error
op_assign
id|rc
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * akpm: how many blocks doth make a writepage()?&n; *&n; * With N blocks per page, it may be:&n; * N data blocks&n; * 2 indirect block&n; * 2 dindirect&n; * 1 tindirect&n; * N+5 bitmap blocks (from the above)&n; * N+5 group descriptor summary blocks&n; * 1 inode block&n; * 1 superblock.&n; * 2 * EXT3_SINGLEDATA_TRANS_BLOCKS for the quote files&n; *&n; * 3 * (N + 5) + 2 + 2 * EXT3_SINGLEDATA_TRANS_BLOCKS&n; *&n; * With ordered or writeback data it&squot;s the same, less the N data blocks.&n; *&n; * If the inode&squot;s direct blocks can hold an integral number of pages then a&n; * page cannot straddle two indirect blocks, and we can only touch one indirect&n; * and dindirect block, and the &quot;5&quot; above becomes &quot;3&quot;.&n; *&n; * This still overestimates under most circumstances.  If we were to pass the&n; * start and end offsets in here as well we could do block_to_path() on each&n; * block and work out the exact number of indirects which are touched.  Pah.&n; */
DECL|function|ext3_writepage_trans_blocks
r_int
id|ext3_writepage_trans_blocks
c_func
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
r_int
id|bpp
op_assign
id|ext3_journal_blocks_per_page
c_func
(paren
id|inode
)paren
suffix:semicolon
r_int
id|indirects
op_assign
(paren
id|EXT3_NDIR_BLOCKS
op_mod
id|bpp
)paren
ques
c_cond
l_int|5
suffix:colon
l_int|3
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_if
c_cond
(paren
id|ext3_should_journal_data
c_func
(paren
id|inode
)paren
)paren
id|ret
op_assign
l_int|3
op_star
(paren
id|bpp
op_plus
id|indirects
)paren
op_plus
l_int|2
suffix:semicolon
r_else
id|ret
op_assign
l_int|2
op_star
(paren
id|bpp
op_plus
id|indirects
)paren
op_plus
l_int|2
suffix:semicolon
macro_line|#ifdef CONFIG_QUOTA
id|ret
op_add_assign
l_int|2
op_star
id|EXT3_SINGLEDATA_TRANS_BLOCKS
suffix:semicolon
macro_line|#endif
r_return
id|ret
suffix:semicolon
)brace
r_int
DECL|function|ext3_mark_iloc_dirty
id|ext3_mark_iloc_dirty
c_func
(paren
id|handle_t
op_star
id|handle
comma
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|ext3_iloc
op_star
id|iloc
)paren
(brace
r_int
id|err
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|handle
)paren
(brace
multiline_comment|/* the do_update_inode consumes one bh-&gt;b_count */
id|atomic_inc
c_func
(paren
op_amp
id|iloc-&gt;bh-&gt;b_count
)paren
suffix:semicolon
id|err
op_assign
id|ext3_do_update_inode
c_func
(paren
id|handle
comma
id|inode
comma
id|iloc
)paren
suffix:semicolon
multiline_comment|/* ext3_do_update_inode() does journal_dirty_metadata */
id|brelse
c_func
(paren
id|iloc-&gt;bh
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_EMERG
l_string|&quot;%s: called with no handle!&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
)brace
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/* &n; * On success, We end up with an outstanding reference count against&n; * iloc-&gt;bh.  This _must_ be cleaned up later. &n; */
r_int
DECL|function|ext3_reserve_inode_write
id|ext3_reserve_inode_write
c_func
(paren
id|handle_t
op_star
id|handle
comma
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|ext3_iloc
op_star
id|iloc
)paren
(brace
r_int
id|err
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|handle
)paren
(brace
id|err
op_assign
id|ext3_get_inode_loc
c_func
(paren
id|inode
comma
id|iloc
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|err
)paren
(brace
id|BUFFER_TRACE
c_func
(paren
id|iloc-&gt;bh
comma
l_string|&quot;get_write_access&quot;
)paren
suffix:semicolon
id|err
op_assign
id|ext3_journal_get_write_access
c_func
(paren
id|handle
comma
id|iloc-&gt;bh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|brelse
c_func
(paren
id|iloc-&gt;bh
)paren
suffix:semicolon
id|iloc-&gt;bh
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
)brace
id|ext3_std_error
c_func
(paren
id|inode-&gt;i_sb
comma
id|err
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; * akpm: What we do here is to mark the in-core inode as clean&n; * with respect to inode dirtiness (it may still be data-dirty).&n; * This means that the in-core inode may be reaped by prune_icache&n; * without having to perform any I/O.  This is a very good thing,&n; * because *any* task may call prune_icache - even ones which&n; * have a transaction open against a different journal.&n; *&n; * Is this cheating?  Not really.  Sure, we haven&squot;t written the&n; * inode out, but prune_icache isn&squot;t a user-visible syncing function.&n; * Whenever the user wants stuff synced (sys_sync, sys_msync, sys_fsync)&n; * we start and wait on commits.&n; *&n; * Is this efficient/effective?  Well, we&squot;re being nice to the system&n; * by cleaning up our inodes proactively so they can be reaped&n; * without I/O.  But we are potentially leaving up to five seconds&squot;&n; * worth of inodes floating about which prune_icache wants us to&n; * write out.  One way to fix that would be to get prune_icache()&n; * to do a write_super() to free up some memory.  It has the desired&n; * effect.&n; */
DECL|function|ext3_mark_inode_dirty
r_int
id|ext3_mark_inode_dirty
c_func
(paren
id|handle_t
op_star
id|handle
comma
r_struct
id|inode
op_star
id|inode
)paren
(brace
r_struct
id|ext3_iloc
id|iloc
suffix:semicolon
r_int
id|err
suffix:semicolon
id|err
op_assign
id|ext3_reserve_inode_write
c_func
(paren
id|handle
comma
id|inode
comma
op_amp
id|iloc
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|err
)paren
id|err
op_assign
id|ext3_mark_iloc_dirty
c_func
(paren
id|handle
comma
id|inode
comma
op_amp
id|iloc
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; * akpm: ext3_dirty_inode() is called from __mark_inode_dirty()&n; *&n; * We&squot;re really interested in the case where a file is being extended.&n; * i_size has been changed by generic_commit_write() and we thus need&n; * to include the updated inode in the current transaction.&n; *&n; * Also, DQUOT_ALLOC_SPACE() will always dirty the inode when blocks&n; * are allocated to the file.&n; *&n; * If the inode is marked synchronous, we don&squot;t honour that here - doing&n; * so would cause a commit on atime updates, which we don&squot;t bother doing.&n; * We handle synchronous inodes at the highest possible level.&n; */
DECL|function|ext3_dirty_inode
r_void
id|ext3_dirty_inode
c_func
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
id|handle_t
op_star
id|current_handle
op_assign
id|ext3_journal_current_handle
c_func
(paren
)paren
suffix:semicolon
id|handle_t
op_star
id|handle
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|handle
op_assign
id|ext3_journal_start
c_func
(paren
id|inode
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|handle
)paren
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|current_handle
op_logical_and
id|current_handle-&gt;h_transaction
op_ne
id|handle-&gt;h_transaction
)paren
(brace
multiline_comment|/* This task has a transaction open against a different fs */
id|printk
c_func
(paren
id|KERN_EMERG
l_string|&quot;%s: transactions do not match!&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
)brace
r_else
(brace
id|jbd_debug
c_func
(paren
l_int|5
comma
l_string|&quot;marking dirty.  outer handle=%p&bslash;n&quot;
comma
id|current_handle
)paren
suffix:semicolon
id|ext3_mark_inode_dirty
c_func
(paren
id|handle
comma
id|inode
)paren
suffix:semicolon
)brace
id|ext3_journal_stop
c_func
(paren
id|handle
comma
id|inode
)paren
suffix:semicolon
id|out
suffix:colon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#ifdef AKPM
multiline_comment|/* &n; * Bind an inode&squot;s backing buffer_head into this transaction, to prevent&n; * it from being flushed to disk early.  Unlike&n; * ext3_reserve_inode_write, this leaves behind no bh reference and&n; * returns no iloc structure, so the caller needs to repeat the iloc&n; * lookup to mark the inode dirty later.&n; */
r_static
r_inline
r_int
DECL|function|ext3_pin_inode
id|ext3_pin_inode
c_func
(paren
id|handle_t
op_star
id|handle
comma
r_struct
id|inode
op_star
id|inode
)paren
(brace
r_struct
id|ext3_iloc
id|iloc
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|handle
)paren
(brace
id|err
op_assign
id|ext3_get_inode_loc
c_func
(paren
id|inode
comma
op_amp
id|iloc
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|err
)paren
(brace
id|BUFFER_TRACE
c_func
(paren
id|iloc.bh
comma
l_string|&quot;get_write_access&quot;
)paren
suffix:semicolon
id|err
op_assign
id|journal_get_write_access
c_func
(paren
id|handle
comma
id|iloc.bh
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|err
)paren
id|err
op_assign
id|ext3_journal_dirty_metadata
c_func
(paren
id|handle
comma
id|iloc.bh
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|iloc.bh
)paren
suffix:semicolon
)brace
)brace
id|ext3_std_error
c_func
(paren
id|inode-&gt;i_sb
comma
id|err
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
macro_line|#endif
DECL|function|ext3_change_inode_journal_flag
r_int
id|ext3_change_inode_journal_flag
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_int
id|val
)paren
(brace
id|journal_t
op_star
id|journal
suffix:semicolon
id|handle_t
op_star
id|handle
suffix:semicolon
r_int
id|err
suffix:semicolon
multiline_comment|/*&n;&t; * We have to be very careful here: changing a data block&squot;s&n;&t; * journaling status dynamically is dangerous.  If we write a&n;&t; * data block to the journal, change the status and then delete&n;&t; * that block, we risk forgetting to revoke the old log record&n;&t; * from the journal and so a subsequent replay can corrupt data.&n;&t; * So, first we make sure that the journal is empty and that&n;&t; * nobody is changing anything.&n;&t; */
id|journal
op_assign
id|EXT3_JOURNAL
c_func
(paren
id|inode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_journal_aborted
c_func
(paren
id|journal
)paren
op_logical_or
id|IS_RDONLY
c_func
(paren
id|inode
)paren
)paren
r_return
op_minus
id|EROFS
suffix:semicolon
id|journal_lock_updates
c_func
(paren
id|journal
)paren
suffix:semicolon
id|journal_flush
c_func
(paren
id|journal
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * OK, there are no updates running now, and all cached data is&n;&t; * synced to disk.  We are now in a completely consistent state&n;&t; * which doesn&squot;t have anything in the journal, and we know that&n;&t; * no filesystem updates are running, so it is safe to modify&n;&t; * the inode&squot;s in-core data-journaling state flag now.&n;&t; */
r_if
c_cond
(paren
id|val
)paren
id|EXT3_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_flags
op_or_assign
id|EXT3_JOURNAL_DATA_FL
suffix:semicolon
r_else
id|EXT3_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_flags
op_and_assign
op_complement
id|EXT3_JOURNAL_DATA_FL
suffix:semicolon
id|journal_unlock_updates
c_func
(paren
id|journal
)paren
suffix:semicolon
multiline_comment|/* Finally we can mark the inode as dirty. */
id|handle
op_assign
id|ext3_journal_start
c_func
(paren
id|inode
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|handle
)paren
)paren
r_return
id|PTR_ERR
c_func
(paren
id|handle
)paren
suffix:semicolon
id|err
op_assign
id|ext3_mark_inode_dirty
c_func
(paren
id|handle
comma
id|inode
)paren
suffix:semicolon
id|handle-&gt;h_sync
op_assign
l_int|1
suffix:semicolon
id|ext3_journal_stop
c_func
(paren
id|handle
comma
id|inode
)paren
suffix:semicolon
id|ext3_std_error
c_func
(paren
id|inode-&gt;i_sb
comma
id|err
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; * ext3_aops_journal_start().&n; *&n; * &lt;This function died, but the comment lives on&gt;&n; *&n; * We need to take the inode semaphore *outside* the&n; * journal_start/journal_stop.  Otherwise, a different task could do a&n; * wait_for_commit() while holding -&gt;i_sem, which deadlocks.  The rule&n; * is: transaction open/closes are considered to be a locking operation&n; * and they nest *inside* -&gt;i_sem.&n; * ----------------------------------------------------------------------------&n; * Possible problem:&n; *&t;ext3_file_write()&n; *&t;-&gt; generic_file_write()&n; *&t;   -&gt; __alloc_pages()&n; *&t;      -&gt; page_launder()&n; *&t;&t; -&gt; ext3_writepage()&n; *&n; * And the writepage can be on a different fs while we have a&n; * transaction open against this one!  Bad.&n; *&n; * I tried making the task PF_MEMALLOC here, but that simply results in&n; * 0-order allocation failures passed back to generic_file_write().&n; * Instead, we rely on the reentrancy protection in ext3_writepage().&n; * ----------------------------------------------------------------------------&n; * When we do the journal_start() here we don&squot;t really need to reserve&n; * any blocks - we won&squot;t need any until we hit ext3_prepare_write(),&n; * which does all the needed journal extending.  However!  There is a&n; * problem with quotas:&n; *&n; * Thread 1:&n; * sys_sync&n; * -&gt;sync_dquots&n; *   -&gt;commit_dquot&n; *     -&gt;lock_dquot&n; *     -&gt;write_dquot&n; *       -&gt;ext3_file_write&n; *         -&gt;journal_start&n; *         -&gt;ext3_prepare_write&n; *           -&gt;journal_extend&n; *           -&gt;journal_start&n; * Thread 2:&n; * ext3_create&t;&t;(for example)&n; * -&gt;ext3_new_inode&n; *   -&gt;dquot_initialize&n; *     -&gt;lock_dquot&n; *&n; * Deadlock.  Thread 1&squot;s journal_start blocks because thread 2 has a&n; * transaction open.  Thread 2&squot;s transaction will never close because&n; * thread 2 is stuck waiting for the dquot lock.&n; *&n; * So.  We must ensure that thread 1 *never* needs to extend the journal&n; * for quota writes.  We do that by reserving enough journal blocks&n; * here, in ext3_aops_journal_start() to ensure that the forthcoming &quot;see if we&n; * need to extend&quot; test in ext3_prepare_write() succeeds.  &n; */
eof
