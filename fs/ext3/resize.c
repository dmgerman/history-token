multiline_comment|/*&n; *  linux/fs/ext3/resize.c&n; *&n; * Support for resizing an ext3 filesystem while it is mounted.&n; *&n; * Copyright (C) 2001, 2002 Andreas Dilger &lt;adilger@clusterfs.com&gt;&n; *&n; * This could probably be made into a module, because it is not often in use.&n; */
macro_line|#include &lt;linux/config.h&gt;
DECL|macro|EXT3FS_DEBUG
mdefine_line|#define EXT3FS_DEBUG
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/ext3_jbd.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
DECL|macro|outside
mdefine_line|#define outside(b, first, last)&t;((b) &lt; (first) || (b) &gt;= (last))
DECL|macro|inside
mdefine_line|#define inside(b, first, last)&t;((b) &gt;= (first) &amp;&amp; (b) &lt; (last))
DECL|function|verify_group_input
r_static
r_int
id|verify_group_input
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_struct
id|ext3_new_group_data
op_star
id|input
)paren
(brace
r_struct
id|ext3_sb_info
op_star
id|sbi
op_assign
id|EXT3_SB
c_func
(paren
id|sb
)paren
suffix:semicolon
r_struct
id|ext3_super_block
op_star
id|es
op_assign
id|sbi-&gt;s_es
suffix:semicolon
r_int
id|start
op_assign
id|le32_to_cpu
c_func
(paren
id|es-&gt;s_blocks_count
)paren
suffix:semicolon
r_int
id|end
op_assign
id|start
op_plus
id|input-&gt;blocks_count
suffix:semicolon
r_int
id|group
op_assign
id|input-&gt;group
suffix:semicolon
r_int
id|itend
op_assign
id|input-&gt;inode_table
op_plus
id|EXT3_SB
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|s_itb_per_group
suffix:semicolon
r_int
id|overhead
op_assign
id|ext3_bg_has_super
c_func
(paren
id|sb
comma
id|group
)paren
ques
c_cond
(paren
l_int|1
op_plus
id|ext3_bg_num_gdb
c_func
(paren
id|sb
comma
id|group
)paren
op_plus
id|le16_to_cpu
c_func
(paren
id|es-&gt;s_reserved_gdt_blocks
)paren
)paren
suffix:colon
l_int|0
suffix:semicolon
r_int
id|metaend
op_assign
id|start
op_plus
id|overhead
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
op_assign
l_int|NULL
suffix:semicolon
r_int
id|free_blocks_count
suffix:semicolon
r_int
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
id|input-&gt;free_blocks_count
op_assign
id|free_blocks_count
op_assign
id|input-&gt;blocks_count
op_minus
l_int|2
op_minus
id|overhead
op_minus
id|sbi-&gt;s_itb_per_group
suffix:semicolon
r_if
c_cond
(paren
id|test_opt
c_func
(paren
id|sb
comma
id|DEBUG
)paren
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;EXT3-fs: adding %s group %u: %u blocks &quot;
l_string|&quot;(%d free, %u reserved)&bslash;n&quot;
comma
id|ext3_bg_has_super
c_func
(paren
id|sb
comma
id|input-&gt;group
)paren
ques
c_cond
l_string|&quot;normal&quot;
suffix:colon
l_string|&quot;no-super&quot;
comma
id|input-&gt;group
comma
id|input-&gt;blocks_count
comma
id|free_blocks_count
comma
id|input-&gt;reserved_blocks
)paren
suffix:semicolon
r_if
c_cond
(paren
id|group
op_ne
id|sbi-&gt;s_groups_count
)paren
id|ext3_warning
c_func
(paren
id|sb
comma
id|__FUNCTION__
comma
l_string|&quot;Cannot add at group %u (only %lu groups)&quot;
comma
id|input-&gt;group
comma
id|sbi-&gt;s_groups_count
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|start
op_minus
id|le32_to_cpu
c_func
(paren
id|es-&gt;s_first_data_block
)paren
)paren
op_mod
id|EXT3_BLOCKS_PER_GROUP
c_func
(paren
id|sb
)paren
)paren
id|ext3_warning
c_func
(paren
id|sb
comma
id|__FUNCTION__
comma
l_string|&quot;Last group not full&quot;
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|input-&gt;reserved_blocks
OG
id|input-&gt;blocks_count
op_div
l_int|5
)paren
id|ext3_warning
c_func
(paren
id|sb
comma
id|__FUNCTION__
comma
l_string|&quot;Reserved blocks too high (%u)&quot;
comma
id|input-&gt;reserved_blocks
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|free_blocks_count
OL
l_int|0
)paren
id|ext3_warning
c_func
(paren
id|sb
comma
id|__FUNCTION__
comma
l_string|&quot;Bad blocks count %u&quot;
comma
id|input-&gt;blocks_count
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
(paren
id|bh
op_assign
id|sb_bread
c_func
(paren
id|sb
comma
id|end
op_minus
l_int|1
)paren
)paren
)paren
id|ext3_warning
c_func
(paren
id|sb
comma
id|__FUNCTION__
comma
l_string|&quot;Cannot read last block (%u)&quot;
comma
id|end
op_minus
l_int|1
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|outside
c_func
(paren
id|input-&gt;block_bitmap
comma
id|start
comma
id|end
)paren
)paren
id|ext3_warning
c_func
(paren
id|sb
comma
id|__FUNCTION__
comma
l_string|&quot;Block bitmap not in group (block %u)&quot;
comma
id|input-&gt;block_bitmap
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|outside
c_func
(paren
id|input-&gt;inode_bitmap
comma
id|start
comma
id|end
)paren
)paren
id|ext3_warning
c_func
(paren
id|sb
comma
id|__FUNCTION__
comma
l_string|&quot;Inode bitmap not in group (block %u)&quot;
comma
id|input-&gt;inode_bitmap
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|outside
c_func
(paren
id|input-&gt;inode_table
comma
id|start
comma
id|end
)paren
op_logical_or
id|outside
c_func
(paren
id|itend
op_minus
l_int|1
comma
id|start
comma
id|end
)paren
)paren
id|ext3_warning
c_func
(paren
id|sb
comma
id|__FUNCTION__
comma
l_string|&quot;Inode table not in group (blocks %u-%u)&quot;
comma
id|input-&gt;inode_table
comma
id|itend
op_minus
l_int|1
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|input-&gt;inode_bitmap
op_eq
id|input-&gt;block_bitmap
)paren
id|ext3_warning
c_func
(paren
id|sb
comma
id|__FUNCTION__
comma
l_string|&quot;Block bitmap same as inode bitmap (%u)&quot;
comma
id|input-&gt;block_bitmap
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|inside
c_func
(paren
id|input-&gt;block_bitmap
comma
id|input-&gt;inode_table
comma
id|itend
)paren
)paren
id|ext3_warning
c_func
(paren
id|sb
comma
id|__FUNCTION__
comma
l_string|&quot;Block bitmap (%u) in inode table (%u-%u)&quot;
comma
id|input-&gt;block_bitmap
comma
id|input-&gt;inode_table
comma
id|itend
op_minus
l_int|1
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|inside
c_func
(paren
id|input-&gt;inode_bitmap
comma
id|input-&gt;inode_table
comma
id|itend
)paren
)paren
id|ext3_warning
c_func
(paren
id|sb
comma
id|__FUNCTION__
comma
l_string|&quot;Inode bitmap (%u) in inode table (%u-%u)&quot;
comma
id|input-&gt;inode_bitmap
comma
id|input-&gt;inode_table
comma
id|itend
op_minus
l_int|1
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|inside
c_func
(paren
id|input-&gt;block_bitmap
comma
id|start
comma
id|metaend
)paren
)paren
id|ext3_warning
c_func
(paren
id|sb
comma
id|__FUNCTION__
comma
l_string|&quot;Block bitmap (%u) in GDT table (%u-%u)&quot;
comma
id|input-&gt;block_bitmap
comma
id|start
comma
id|metaend
op_minus
l_int|1
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|inside
c_func
(paren
id|input-&gt;inode_bitmap
comma
id|start
comma
id|metaend
)paren
)paren
id|ext3_warning
c_func
(paren
id|sb
comma
id|__FUNCTION__
comma
l_string|&quot;Inode bitmap (%u) in GDT table (%u-%u)&quot;
comma
id|input-&gt;inode_bitmap
comma
id|start
comma
id|metaend
op_minus
l_int|1
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|inside
c_func
(paren
id|input-&gt;inode_table
comma
id|start
comma
id|metaend
)paren
op_logical_or
id|inside
c_func
(paren
id|itend
op_minus
l_int|1
comma
id|start
comma
id|metaend
)paren
)paren
id|ext3_warning
c_func
(paren
id|sb
comma
id|__FUNCTION__
comma
l_string|&quot;Inode table (%u-%u) overlaps GDT table (%u-%u)&quot;
comma
id|input-&gt;inode_table
comma
id|itend
op_minus
l_int|1
comma
id|start
comma
id|metaend
op_minus
l_int|1
)paren
suffix:semicolon
r_else
id|err
op_assign
l_int|0
suffix:semicolon
id|brelse
c_func
(paren
id|bh
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|function|bclean
r_static
r_struct
id|buffer_head
op_star
id|bclean
c_func
(paren
id|handle_t
op_star
id|handle
comma
r_struct
id|super_block
op_star
id|sb
comma
r_int
r_int
id|blk
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
r_int
id|err
suffix:semicolon
id|bh
op_assign
id|sb_getblk
c_func
(paren
id|sb
comma
id|blk
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|ext3_journal_get_write_access
c_func
(paren
id|handle
comma
id|bh
)paren
)paren
)paren
(brace
id|brelse
c_func
(paren
id|bh
)paren
suffix:semicolon
id|bh
op_assign
id|ERR_PTR
c_func
(paren
id|err
)paren
suffix:semicolon
)brace
r_else
(brace
id|lock_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
id|memset
c_func
(paren
id|bh-&gt;b_data
comma
l_int|0
comma
id|sb-&gt;s_blocksize
)paren
suffix:semicolon
id|set_buffer_uptodate
c_func
(paren
id|bh
)paren
suffix:semicolon
id|unlock_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
r_return
id|bh
suffix:semicolon
)brace
multiline_comment|/*&n; * To avoid calling the atomic setbit hundreds or thousands of times, we only&n; * need to use it within a single byte (to ensure we get endianness right).&n; * We can use memset for the rest of the bitmap as there are no other users.&n; */
DECL|function|mark_bitmap_end
r_static
r_void
id|mark_bitmap_end
c_func
(paren
r_int
id|start_bit
comma
r_int
id|end_bit
comma
r_char
op_star
id|bitmap
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|start_bit
op_ge
id|end_bit
)paren
r_return
suffix:semicolon
id|ext3_debug
c_func
(paren
l_string|&quot;mark end bits +%d through +%d used&bslash;n&quot;
comma
id|start_bit
comma
id|end_bit
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|start_bit
suffix:semicolon
id|i
OL
(paren
(paren
id|start_bit
op_plus
l_int|7
)paren
op_amp
op_complement
l_int|7UL
)paren
suffix:semicolon
id|i
op_increment
)paren
id|ext3_set_bit
c_func
(paren
id|i
comma
id|bitmap
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
OL
id|end_bit
)paren
id|memset
c_func
(paren
id|bitmap
op_plus
(paren
id|i
op_rshift
l_int|3
)paren
comma
l_int|0xff
comma
(paren
id|end_bit
op_minus
id|i
)paren
op_rshift
l_int|3
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Set up the block and inode bitmaps, and the inode table for the new group.&n; * This doesn&squot;t need to be part of the main transaction, since we are only&n; * changing blocks outside the actual filesystem.  We still do journaling to&n; * ensure the recovery is correct in case of a failure just after resize.&n; * If any part of this fails, we simply abort the resize.&n; */
DECL|function|setup_new_group_blocks
r_static
r_int
id|setup_new_group_blocks
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_struct
id|ext3_new_group_data
op_star
id|input
)paren
(brace
r_struct
id|ext3_sb_info
op_star
id|sbi
op_assign
id|EXT3_SB
c_func
(paren
id|sb
)paren
suffix:semicolon
r_int
r_int
id|start
op_assign
id|input-&gt;group
op_star
id|sbi-&gt;s_blocks_per_group
op_plus
id|le32_to_cpu
c_func
(paren
id|sbi-&gt;s_es-&gt;s_first_data_block
)paren
suffix:semicolon
r_int
id|reserved_gdb
op_assign
id|ext3_bg_has_super
c_func
(paren
id|sb
comma
id|input-&gt;group
)paren
ques
c_cond
id|le16_to_cpu
c_func
(paren
id|sbi-&gt;s_es-&gt;s_reserved_gdt_blocks
)paren
suffix:colon
l_int|0
suffix:semicolon
r_int
r_int
id|gdblocks
op_assign
id|ext3_bg_num_gdb
c_func
(paren
id|sb
comma
id|input-&gt;group
)paren
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
id|handle_t
op_star
id|handle
suffix:semicolon
r_int
r_int
id|block
suffix:semicolon
r_int
id|bit
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|err
op_assign
l_int|0
comma
id|err2
suffix:semicolon
id|handle
op_assign
id|ext3_journal_start_sb
c_func
(paren
id|sb
comma
id|reserved_gdb
op_plus
id|gdblocks
op_plus
l_int|2
op_plus
id|sbi-&gt;s_itb_per_group
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|handle
)paren
)paren
r_return
id|PTR_ERR
c_func
(paren
id|handle
)paren
suffix:semicolon
id|lock_super
c_func
(paren
id|sb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|input-&gt;group
op_ne
id|sbi-&gt;s_groups_count
)paren
(brace
id|err
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_goto
id|exit_journal
suffix:semicolon
)brace
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|bh
op_assign
id|bclean
c_func
(paren
id|handle
comma
id|sb
comma
id|input-&gt;block_bitmap
)paren
)paren
)paren
(brace
id|err
op_assign
id|PTR_ERR
c_func
(paren
id|bh
)paren
suffix:semicolon
r_goto
id|exit_journal
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ext3_bg_has_super
c_func
(paren
id|sb
comma
id|input-&gt;group
)paren
)paren
(brace
id|ext3_debug
c_func
(paren
l_string|&quot;mark backup superblock %#04lx (+0)&bslash;n&quot;
comma
id|start
)paren
suffix:semicolon
id|ext3_set_bit
c_func
(paren
l_int|0
comma
id|bh-&gt;b_data
)paren
suffix:semicolon
)brace
multiline_comment|/* Copy all of the GDT blocks into the backup in this group */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|bit
op_assign
l_int|1
comma
id|block
op_assign
id|start
op_plus
l_int|1
suffix:semicolon
id|i
OL
id|gdblocks
suffix:semicolon
id|i
op_increment
comma
id|block
op_increment
comma
id|bit
op_increment
)paren
(brace
r_struct
id|buffer_head
op_star
id|gdb
suffix:semicolon
id|ext3_debug
c_func
(paren
l_string|&quot;update backup group %#04lx (+%d)&bslash;n&quot;
comma
id|block
comma
id|bit
)paren
suffix:semicolon
id|gdb
op_assign
id|sb_getblk
c_func
(paren
id|sb
comma
id|block
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|ext3_journal_get_write_access
c_func
(paren
id|handle
comma
id|gdb
)paren
)paren
)paren
(brace
id|brelse
c_func
(paren
id|gdb
)paren
suffix:semicolon
r_goto
id|exit_bh
suffix:semicolon
)brace
id|lock_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|gdb-&gt;b_data
comma
id|sbi-&gt;s_group_desc
(braket
id|i
)braket
comma
id|bh-&gt;b_size
)paren
suffix:semicolon
id|set_buffer_uptodate
c_func
(paren
id|gdb
)paren
suffix:semicolon
id|unlock_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
id|ext3_journal_dirty_metadata
c_func
(paren
id|handle
comma
id|gdb
)paren
suffix:semicolon
id|ext3_set_bit
c_func
(paren
id|bit
comma
id|bh-&gt;b_data
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|gdb
)paren
suffix:semicolon
)brace
multiline_comment|/* Zero out all of the reserved backup group descriptor table blocks */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|bit
op_assign
id|gdblocks
op_plus
l_int|1
comma
id|block
op_assign
id|start
op_plus
id|bit
suffix:semicolon
id|i
OL
id|reserved_gdb
suffix:semicolon
id|i
op_increment
comma
id|block
op_increment
comma
id|bit
op_increment
)paren
(brace
r_struct
id|buffer_head
op_star
id|gdb
suffix:semicolon
id|ext3_debug
c_func
(paren
l_string|&quot;clear reserved block %#04lx (+%d)&bslash;n&quot;
comma
id|block
comma
id|bit
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|gdb
op_assign
id|bclean
c_func
(paren
id|handle
comma
id|sb
comma
id|block
)paren
)paren
)paren
(brace
id|err
op_assign
id|PTR_ERR
c_func
(paren
id|bh
)paren
suffix:semicolon
r_goto
id|exit_bh
suffix:semicolon
)brace
id|ext3_journal_dirty_metadata
c_func
(paren
id|handle
comma
id|gdb
)paren
suffix:semicolon
id|ext3_set_bit
c_func
(paren
id|bit
comma
id|bh-&gt;b_data
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|gdb
)paren
suffix:semicolon
)brace
id|ext3_debug
c_func
(paren
l_string|&quot;mark block bitmap %#04x (+%ld)&bslash;n&quot;
comma
id|input-&gt;block_bitmap
comma
id|input-&gt;block_bitmap
op_minus
id|start
)paren
suffix:semicolon
id|ext3_set_bit
c_func
(paren
id|input-&gt;block_bitmap
op_minus
id|start
comma
id|bh-&gt;b_data
)paren
suffix:semicolon
id|ext3_debug
c_func
(paren
l_string|&quot;mark inode bitmap %#04x (+%ld)&bslash;n&quot;
comma
id|input-&gt;inode_bitmap
comma
id|input-&gt;inode_bitmap
op_minus
id|start
)paren
suffix:semicolon
id|ext3_set_bit
c_func
(paren
id|input-&gt;inode_bitmap
op_minus
id|start
comma
id|bh-&gt;b_data
)paren
suffix:semicolon
multiline_comment|/* Zero out all of the inode table blocks */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|block
op_assign
id|input-&gt;inode_table
comma
id|bit
op_assign
id|block
op_minus
id|start
suffix:semicolon
id|i
OL
id|sbi-&gt;s_itb_per_group
suffix:semicolon
id|i
op_increment
comma
id|bit
op_increment
comma
id|block
op_increment
)paren
(brace
r_struct
id|buffer_head
op_star
id|it
suffix:semicolon
id|ext3_debug
c_func
(paren
l_string|&quot;clear inode block %#04x (+%ld)&bslash;n&quot;
comma
id|block
comma
id|bit
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|it
op_assign
id|bclean
c_func
(paren
id|handle
comma
id|sb
comma
id|block
)paren
)paren
)paren
(brace
id|err
op_assign
id|PTR_ERR
c_func
(paren
id|it
)paren
suffix:semicolon
r_goto
id|exit_bh
suffix:semicolon
)brace
id|ext3_journal_dirty_metadata
c_func
(paren
id|handle
comma
id|it
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|it
)paren
suffix:semicolon
id|ext3_set_bit
c_func
(paren
id|bit
comma
id|bh-&gt;b_data
)paren
suffix:semicolon
)brace
id|mark_bitmap_end
c_func
(paren
id|input-&gt;blocks_count
comma
id|EXT3_BLOCKS_PER_GROUP
c_func
(paren
id|sb
)paren
comma
id|bh-&gt;b_data
)paren
suffix:semicolon
id|ext3_journal_dirty_metadata
c_func
(paren
id|handle
comma
id|bh
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|bh
)paren
suffix:semicolon
multiline_comment|/* Mark unused entries in inode bitmap used */
id|ext3_debug
c_func
(paren
l_string|&quot;clear inode bitmap %#04x (+%ld)&bslash;n&quot;
comma
id|input-&gt;inode_bitmap
comma
id|input-&gt;inode_bitmap
op_minus
id|start
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|bh
op_assign
id|bclean
c_func
(paren
id|handle
comma
id|sb
comma
id|input-&gt;inode_bitmap
)paren
)paren
)paren
(brace
id|err
op_assign
id|PTR_ERR
c_func
(paren
id|bh
)paren
suffix:semicolon
r_goto
id|exit_journal
suffix:semicolon
)brace
id|mark_bitmap_end
c_func
(paren
id|EXT3_INODES_PER_GROUP
c_func
(paren
id|sb
)paren
comma
id|EXT3_BLOCKS_PER_GROUP
c_func
(paren
id|sb
)paren
comma
id|bh-&gt;b_data
)paren
suffix:semicolon
id|ext3_journal_dirty_metadata
c_func
(paren
id|handle
comma
id|bh
)paren
suffix:semicolon
id|exit_bh
suffix:colon
id|brelse
c_func
(paren
id|bh
)paren
suffix:semicolon
id|exit_journal
suffix:colon
id|unlock_super
c_func
(paren
id|sb
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err2
op_assign
id|ext3_journal_stop
c_func
(paren
id|handle
)paren
)paren
op_logical_and
op_logical_neg
id|err
)paren
id|err
op_assign
id|err2
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; * Iterate through the groups which hold BACKUP superblock/GDT copies in an&n; * ext3 filesystem.  The counters should be initialized to 1, 5, and 7 before&n; * calling this for the first time.  In a sparse filesystem it will be the&n; * sequence of powers of 3, 5, and 7: 1, 3, 5, 7, 9, 25, 27, 49, 81, ...&n; * For a non-sparse filesystem it will be every group: 1, 2, 3, 4, ...&n; */
DECL|function|ext3_list_backups
r_int
id|ext3_list_backups
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_int
op_star
id|three
comma
r_int
op_star
id|five
comma
r_int
op_star
id|seven
)paren
(brace
r_int
op_star
id|min
op_assign
id|three
suffix:semicolon
r_int
id|mult
op_assign
l_int|3
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|EXT3_HAS_RO_COMPAT_FEATURE
c_func
(paren
id|sb
comma
id|EXT3_FEATURE_RO_COMPAT_SPARSE_SUPER
)paren
)paren
(brace
id|ret
op_assign
op_star
id|min
suffix:semicolon
op_star
id|min
op_add_assign
l_int|1
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|five
OL
op_star
id|min
)paren
(brace
id|min
op_assign
id|five
suffix:semicolon
id|mult
op_assign
l_int|5
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|seven
OL
op_star
id|min
)paren
(brace
id|min
op_assign
id|seven
suffix:semicolon
id|mult
op_assign
l_int|7
suffix:semicolon
)brace
id|ret
op_assign
op_star
id|min
suffix:semicolon
op_star
id|min
op_mul_assign
id|mult
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Check that all of the backup GDT blocks are held in the primary GDT block.&n; * It is assumed that they are stored in group order.  Returns the number of&n; * groups in current filesystem that have BACKUPS, or -ve error code.&n; */
DECL|function|verify_reserved_gdb
r_static
r_int
id|verify_reserved_gdb
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_struct
id|buffer_head
op_star
id|primary
)paren
(brace
r_const
r_int
r_int
id|blk
op_assign
id|primary-&gt;b_blocknr
suffix:semicolon
r_const
r_int
r_int
id|end
op_assign
id|EXT3_SB
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|s_groups_count
suffix:semicolon
r_int
id|three
op_assign
l_int|1
suffix:semicolon
r_int
id|five
op_assign
l_int|5
suffix:semicolon
r_int
id|seven
op_assign
l_int|7
suffix:semicolon
r_int
id|grp
suffix:semicolon
id|__u32
op_star
id|p
op_assign
(paren
id|__u32
op_star
)paren
id|primary-&gt;b_data
suffix:semicolon
r_int
id|gdbackups
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
(paren
id|grp
op_assign
id|ext3_list_backups
c_func
(paren
id|sb
comma
op_amp
id|three
comma
op_amp
id|five
comma
op_amp
id|seven
)paren
)paren
OL
id|end
)paren
(brace
r_if
c_cond
(paren
id|le32_to_cpu
c_func
(paren
op_star
id|p
op_increment
)paren
op_ne
id|grp
op_star
id|EXT3_BLOCKS_PER_GROUP
c_func
(paren
id|sb
)paren
op_plus
id|blk
)paren
(brace
id|ext3_warning
c_func
(paren
id|sb
comma
id|__FUNCTION__
comma
l_string|&quot;reserved GDT %ld missing grp %d (%ld)&bslash;n&quot;
comma
id|blk
comma
id|grp
comma
id|grp
op_star
id|EXT3_BLOCKS_PER_GROUP
c_func
(paren
id|sb
)paren
op_plus
id|blk
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
op_increment
id|gdbackups
OG
id|EXT3_ADDR_PER_BLOCK
c_func
(paren
id|sb
)paren
)paren
r_return
op_minus
id|EFBIG
suffix:semicolon
)brace
r_return
id|gdbackups
suffix:semicolon
)brace
multiline_comment|/*&n; * Called when we need to bring a reserved group descriptor table block into&n; * use from the resize inode.  The primary copy of the new GDT block currently&n; * is an indirect block (under the double indirect block in the resize inode).&n; * The new backup GDT blocks will be stored as leaf blocks in this indirect&n; * block, in group order.  Even though we know all the block numbers we need,&n; * we check to ensure that the resize inode has actually reserved these blocks.&n; *&n; * Don&squot;t need to update the block bitmaps because the blocks are still in use.&n; *&n; * We get all of the error cases out of the way, so that we are sure to not&n; * fail once we start modifying the data on disk, because JBD has no rollback.&n; */
DECL|function|add_new_gdb
r_static
r_int
id|add_new_gdb
c_func
(paren
id|handle_t
op_star
id|handle
comma
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|ext3_new_group_data
op_star
id|input
comma
r_struct
id|buffer_head
op_star
op_star
id|primary
)paren
(brace
r_struct
id|super_block
op_star
id|sb
op_assign
id|inode-&gt;i_sb
suffix:semicolon
r_struct
id|ext3_super_block
op_star
id|es
op_assign
id|EXT3_SB
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|s_es
suffix:semicolon
r_int
r_int
id|gdb_num
op_assign
id|input-&gt;group
op_div
id|EXT3_DESC_PER_BLOCK
c_func
(paren
id|sb
)paren
suffix:semicolon
r_int
r_int
id|gdblock
op_assign
id|EXT3_SB
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|s_sbh-&gt;b_blocknr
op_plus
l_int|1
op_plus
id|gdb_num
suffix:semicolon
r_struct
id|buffer_head
op_star
op_star
id|o_group_desc
comma
op_star
op_star
id|n_group_desc
suffix:semicolon
r_struct
id|buffer_head
op_star
id|dind
suffix:semicolon
r_int
id|gdbackups
suffix:semicolon
r_struct
id|ext3_iloc
id|iloc
suffix:semicolon
id|__u32
op_star
id|data
suffix:semicolon
r_int
id|err
suffix:semicolon
r_if
c_cond
(paren
id|test_opt
c_func
(paren
id|sb
comma
id|DEBUG
)paren
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;EXT3-fs: ext3_add_new_gdb: adding group block %lu&bslash;n&quot;
comma
id|gdb_num
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If we are not using the primary superblock/GDT copy don&squot;t resize,&n;&t; * because the user tools have no way of handling this.  Probably a&n;&t; * bad time to do it anyways.&n;&t; */
r_if
c_cond
(paren
id|EXT3_SB
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|s_sbh-&gt;b_blocknr
op_ne
id|le32_to_cpu
c_func
(paren
id|EXT3_SB
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|s_es-&gt;s_first_data_block
)paren
)paren
(brace
id|ext3_warning
c_func
(paren
id|sb
comma
id|__FUNCTION__
comma
l_string|&quot;won&squot;t resize using backup superblock at %llu&bslash;n&quot;
comma
(paren
r_int
r_int
r_int
)paren
id|EXT3_SB
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|s_sbh-&gt;b_blocknr
)paren
suffix:semicolon
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
op_star
id|primary
op_assign
id|sb_bread
c_func
(paren
id|sb
comma
id|gdblock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_star
id|primary
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_if
c_cond
(paren
(paren
id|gdbackups
op_assign
id|verify_reserved_gdb
c_func
(paren
id|sb
comma
op_star
id|primary
)paren
)paren
OL
l_int|0
)paren
(brace
id|err
op_assign
id|gdbackups
suffix:semicolon
r_goto
id|exit_bh
suffix:semicolon
)brace
id|data
op_assign
id|EXT3_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_data
op_plus
id|EXT3_DIND_BLOCK
suffix:semicolon
id|dind
op_assign
id|sb_bread
c_func
(paren
id|sb
comma
id|le32_to_cpu
c_func
(paren
op_star
id|data
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dind
)paren
(brace
id|err
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|exit_bh
suffix:semicolon
)brace
id|data
op_assign
(paren
id|__u32
op_star
)paren
id|dind-&gt;b_data
suffix:semicolon
r_if
c_cond
(paren
id|le32_to_cpu
c_func
(paren
id|data
(braket
id|gdb_num
op_mod
id|EXT3_ADDR_PER_BLOCK
c_func
(paren
id|sb
)paren
)braket
)paren
op_ne
id|gdblock
)paren
(brace
id|ext3_warning
c_func
(paren
id|sb
comma
id|__FUNCTION__
comma
l_string|&quot;new group %u GDT block %lu not reserved&bslash;n&quot;
comma
id|input-&gt;group
comma
id|gdblock
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|exit_dind
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|err
op_assign
id|ext3_journal_get_write_access
c_func
(paren
id|handle
comma
id|EXT3_SB
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|s_sbh
)paren
)paren
)paren
r_goto
id|exit_dind
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|ext3_journal_get_write_access
c_func
(paren
id|handle
comma
op_star
id|primary
)paren
)paren
)paren
r_goto
id|exit_sbh
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|ext3_journal_get_write_access
c_func
(paren
id|handle
comma
id|dind
)paren
)paren
)paren
r_goto
id|exit_primary
suffix:semicolon
multiline_comment|/* ext3_reserve_inode_write() gets a reference on the iloc */
r_if
c_cond
(paren
(paren
id|err
op_assign
id|ext3_reserve_inode_write
c_func
(paren
id|handle
comma
id|inode
comma
op_amp
id|iloc
)paren
)paren
)paren
r_goto
id|exit_dindj
suffix:semicolon
id|n_group_desc
op_assign
(paren
r_struct
id|buffer_head
op_star
op_star
)paren
id|kmalloc
c_func
(paren
(paren
id|gdb_num
op_plus
l_int|1
)paren
op_star
r_sizeof
(paren
r_struct
id|buffer_head
op_star
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|n_group_desc
)paren
(brace
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
id|ext3_warning
(paren
id|sb
comma
id|__FUNCTION__
comma
l_string|&quot;not enough memory for %lu groups&quot;
comma
id|gdb_num
op_plus
l_int|1
)paren
suffix:semicolon
r_goto
id|exit_inode
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Finally, we have all of the possible failures behind us...&n;&t; *&n;&t; * Remove new GDT block from inode double-indirect block and clear out&n;&t; * the new GDT block for use (which also &quot;frees&quot; the backup GDT blocks&n;&t; * from the reserved inode).  We don&squot;t need to change the bitmaps for&n;&t; * these blocks, because they are marked as in-use from being in the&n;&t; * reserved inode, and will become GDT blocks (primary and backup).&n;&t; */
id|data
(braket
id|gdb_num
op_mod
id|EXT3_ADDR_PER_BLOCK
c_func
(paren
id|sb
)paren
)braket
op_assign
l_int|0
suffix:semicolon
id|ext3_journal_dirty_metadata
c_func
(paren
id|handle
comma
id|dind
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|dind
)paren
suffix:semicolon
id|inode-&gt;i_blocks
op_sub_assign
(paren
id|gdbackups
op_plus
l_int|1
)paren
op_star
id|sb-&gt;s_blocksize
op_rshift
l_int|9
suffix:semicolon
id|ext3_mark_iloc_dirty
c_func
(paren
id|handle
comma
id|inode
comma
op_amp
id|iloc
)paren
suffix:semicolon
id|memset
c_func
(paren
(paren
op_star
id|primary
)paren
op_member_access_from_pointer
id|b_data
comma
l_int|0
comma
id|sb-&gt;s_blocksize
)paren
suffix:semicolon
id|ext3_journal_dirty_metadata
c_func
(paren
id|handle
comma
op_star
id|primary
)paren
suffix:semicolon
id|o_group_desc
op_assign
id|EXT3_SB
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|s_group_desc
suffix:semicolon
id|memcpy
c_func
(paren
id|n_group_desc
comma
id|o_group_desc
comma
id|EXT3_SB
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|s_gdb_count
op_star
r_sizeof
(paren
r_struct
id|buffer_head
op_star
)paren
)paren
suffix:semicolon
id|n_group_desc
(braket
id|gdb_num
)braket
op_assign
op_star
id|primary
suffix:semicolon
id|EXT3_SB
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|s_group_desc
op_assign
id|n_group_desc
suffix:semicolon
id|EXT3_SB
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|s_gdb_count
op_increment
suffix:semicolon
id|kfree
c_func
(paren
id|o_group_desc
)paren
suffix:semicolon
id|es-&gt;s_reserved_gdt_blocks
op_assign
id|cpu_to_le16
c_func
(paren
id|le16_to_cpu
c_func
(paren
id|es-&gt;s_reserved_gdt_blocks
)paren
op_minus
l_int|1
)paren
suffix:semicolon
id|ext3_journal_dirty_metadata
c_func
(paren
id|handle
comma
id|EXT3_SB
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|s_sbh
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|exit_inode
suffix:colon
singleline_comment|//ext3_journal_release_buffer(handle, iloc.bh);
id|brelse
c_func
(paren
id|iloc.bh
)paren
suffix:semicolon
id|exit_dindj
suffix:colon
singleline_comment|//ext3_journal_release_buffer(handle, dind);
id|exit_primary
suffix:colon
singleline_comment|//ext3_journal_release_buffer(handle, *primary);
id|exit_sbh
suffix:colon
singleline_comment|//ext3_journal_release_buffer(handle, *primary);
id|exit_dind
suffix:colon
id|brelse
c_func
(paren
id|dind
)paren
suffix:semicolon
id|exit_bh
suffix:colon
id|brelse
c_func
(paren
op_star
id|primary
)paren
suffix:semicolon
id|ext3_debug
c_func
(paren
l_string|&quot;leaving with error %d&bslash;n&quot;
comma
id|err
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; * Called when we are adding a new group which has a backup copy of each of&n; * the GDT blocks (i.e. sparse group) and there are reserved GDT blocks.&n; * We need to add these reserved backup GDT blocks to the resize inode, so&n; * that they are kept for future resizing and not allocated to files.&n; *&n; * Each reserved backup GDT block will go into a different indirect block.&n; * The indirect blocks are actually the primary reserved GDT blocks,&n; * so we know in advance what their block numbers are.  We only get the&n; * double-indirect block to verify it is pointing to the primary reserved&n; * GDT blocks so we don&squot;t overwrite a data block by accident.  The reserved&n; * backup GDT blocks are stored in their reserved primary GDT block.&n; */
DECL|function|reserve_backup_gdb
r_static
r_int
id|reserve_backup_gdb
c_func
(paren
id|handle_t
op_star
id|handle
comma
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|ext3_new_group_data
op_star
id|input
)paren
(brace
r_struct
id|super_block
op_star
id|sb
op_assign
id|inode-&gt;i_sb
suffix:semicolon
r_int
id|reserved_gdb
op_assign
id|le16_to_cpu
c_func
(paren
id|EXT3_SB
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|s_es-&gt;s_reserved_gdt_blocks
)paren
suffix:semicolon
r_struct
id|buffer_head
op_star
op_star
id|primary
suffix:semicolon
r_struct
id|buffer_head
op_star
id|dind
suffix:semicolon
r_struct
id|ext3_iloc
id|iloc
suffix:semicolon
r_int
r_int
id|blk
suffix:semicolon
id|__u32
op_star
id|data
comma
op_star
id|end
suffix:semicolon
r_int
id|gdbackups
op_assign
l_int|0
suffix:semicolon
r_int
id|res
comma
id|i
suffix:semicolon
r_int
id|err
suffix:semicolon
id|primary
op_assign
id|kmalloc
c_func
(paren
id|reserved_gdb
op_star
r_sizeof
(paren
op_star
id|primary
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|primary
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|data
op_assign
id|EXT3_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_data
op_plus
id|EXT3_DIND_BLOCK
suffix:semicolon
id|dind
op_assign
id|sb_bread
c_func
(paren
id|sb
comma
id|le32_to_cpu
c_func
(paren
op_star
id|data
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dind
)paren
(brace
id|err
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|exit_free
suffix:semicolon
)brace
id|blk
op_assign
id|EXT3_SB
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|s_sbh-&gt;b_blocknr
op_plus
l_int|1
op_plus
id|EXT3_SB
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|s_gdb_count
suffix:semicolon
id|data
op_assign
(paren
id|__u32
op_star
)paren
id|dind-&gt;b_data
op_plus
id|EXT3_SB
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|s_gdb_count
suffix:semicolon
id|end
op_assign
(paren
id|__u32
op_star
)paren
id|dind-&gt;b_data
op_plus
id|EXT3_ADDR_PER_BLOCK
c_func
(paren
id|sb
)paren
suffix:semicolon
multiline_comment|/* Get each reserved primary GDT block and verify it holds backups */
r_for
c_loop
(paren
id|res
op_assign
l_int|0
suffix:semicolon
id|res
OL
id|reserved_gdb
suffix:semicolon
id|res
op_increment
comma
id|blk
op_increment
)paren
(brace
r_if
c_cond
(paren
id|le32_to_cpu
c_func
(paren
op_star
id|data
)paren
op_ne
id|blk
)paren
(brace
id|ext3_warning
c_func
(paren
id|sb
comma
id|__FUNCTION__
comma
l_string|&quot;reserved block %lu not at offset %ld&bslash;n&quot;
comma
id|blk
comma
(paren
r_int
)paren
(paren
id|data
op_minus
(paren
id|__u32
op_star
)paren
id|dind-&gt;b_data
)paren
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|exit_bh
suffix:semicolon
)brace
id|primary
(braket
id|res
)braket
op_assign
id|sb_bread
c_func
(paren
id|sb
comma
id|blk
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|primary
(braket
id|res
)braket
)paren
(brace
id|err
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|exit_bh
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|gdbackups
op_assign
id|verify_reserved_gdb
c_func
(paren
id|sb
comma
id|primary
(braket
id|res
)braket
)paren
)paren
OL
l_int|0
)paren
(brace
id|brelse
c_func
(paren
id|primary
(braket
id|res
)braket
)paren
suffix:semicolon
id|err
op_assign
id|gdbackups
suffix:semicolon
r_goto
id|exit_bh
suffix:semicolon
)brace
r_if
c_cond
(paren
op_increment
id|data
op_ge
id|end
)paren
id|data
op_assign
(paren
id|__u32
op_star
)paren
id|dind-&gt;b_data
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|reserved_gdb
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|err
op_assign
id|ext3_journal_get_write_access
c_func
(paren
id|handle
comma
id|primary
(braket
id|i
)braket
)paren
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;int j;&n;&t;&t;&t;for (j = 0; j &lt; i; j++)&n;&t;&t;&t;&t;ext3_journal_release_buffer(handle, primary[j]);&n;&t;&t;&t; */
r_goto
id|exit_bh
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
(paren
id|err
op_assign
id|ext3_reserve_inode_write
c_func
(paren
id|handle
comma
id|inode
comma
op_amp
id|iloc
)paren
)paren
)paren
r_goto
id|exit_bh
suffix:semicolon
multiline_comment|/*&n;&t; * Finally we can add each of the reserved backup GDT blocks from&n;&t; * the new group to its reserved primary GDT block.&n;&t; */
id|blk
op_assign
id|input-&gt;group
op_star
id|EXT3_BLOCKS_PER_GROUP
c_func
(paren
id|sb
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|reserved_gdb
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|err2
suffix:semicolon
id|data
op_assign
(paren
id|__u32
op_star
)paren
id|primary
(braket
id|i
)braket
op_member_access_from_pointer
id|b_data
suffix:semicolon
multiline_comment|/* printk(&quot;reserving backup %lu[%u] = %lu&bslash;n&quot;,&n;&t;&t;       primary[i]-&gt;b_blocknr, gdbackups,&n;&t;&t;       blk + primary[i]-&gt;b_blocknr); */
id|data
(braket
id|gdbackups
)braket
op_assign
id|cpu_to_le32
c_func
(paren
id|blk
op_plus
id|primary
(braket
id|i
)braket
op_member_access_from_pointer
id|b_blocknr
)paren
suffix:semicolon
id|err2
op_assign
id|ext3_journal_dirty_metadata
c_func
(paren
id|handle
comma
id|primary
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|err
)paren
id|err
op_assign
id|err2
suffix:semicolon
)brace
id|inode-&gt;i_blocks
op_add_assign
id|reserved_gdb
op_star
id|sb-&gt;s_blocksize
op_rshift
l_int|9
suffix:semicolon
id|ext3_mark_iloc_dirty
c_func
(paren
id|handle
comma
id|inode
comma
op_amp
id|iloc
)paren
suffix:semicolon
id|exit_bh
suffix:colon
r_while
c_loop
(paren
op_decrement
id|res
op_ge
l_int|0
)paren
id|brelse
c_func
(paren
id|primary
(braket
id|res
)braket
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|dind
)paren
suffix:semicolon
id|exit_free
suffix:colon
id|kfree
c_func
(paren
id|primary
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; * Update the backup copies of the ext3 metadata.  These don&squot;t need to be part&n; * of the main resize transaction, because e2fsck will re-write them if there&n; * is a problem (basically only OOM will cause a problem).  However, we&n; * _should_ update the backups if possible, in case the primary gets trashed&n; * for some reason and we need to run e2fsck from a backup superblock.  The&n; * important part is that the new block and inode counts are in the backup&n; * superblocks, and the location of the new group metadata in the GDT backups.&n; *&n; * We do not need lock_super() for this, because these blocks are not&n; * otherwise touched by the filesystem code when it is mounted.  We don&squot;t&n; * need to worry about last changing from sbi-&gt;s_groups_count, because the&n; * worst that can happen is that we do not copy the full number of backups&n; * at this time.  The resize which changed s_groups_count will backup again.&n; */
DECL|function|update_backups
r_static
r_void
id|update_backups
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_int
id|blk_off
comma
r_char
op_star
id|data
comma
r_int
id|size
)paren
(brace
r_struct
id|ext3_sb_info
op_star
id|sbi
op_assign
id|EXT3_SB
c_func
(paren
id|sb
)paren
suffix:semicolon
r_const
r_int
r_int
id|last
op_assign
id|sbi-&gt;s_groups_count
suffix:semicolon
r_const
r_int
id|bpg
op_assign
id|EXT3_BLOCKS_PER_GROUP
c_func
(paren
id|sb
)paren
suffix:semicolon
r_int
id|three
op_assign
l_int|1
suffix:semicolon
r_int
id|five
op_assign
l_int|5
suffix:semicolon
r_int
id|seven
op_assign
l_int|7
suffix:semicolon
r_int
id|group
suffix:semicolon
r_int
id|rest
op_assign
id|sb-&gt;s_blocksize
op_minus
id|size
suffix:semicolon
id|handle_t
op_star
id|handle
suffix:semicolon
r_int
id|err
op_assign
l_int|0
comma
id|err2
suffix:semicolon
id|handle
op_assign
id|ext3_journal_start_sb
c_func
(paren
id|sb
comma
id|EXT3_MAX_TRANS_DATA
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|handle
)paren
)paren
(brace
id|group
op_assign
l_int|1
suffix:semicolon
id|err
op_assign
id|PTR_ERR
c_func
(paren
id|handle
)paren
suffix:semicolon
r_goto
id|exit_err
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|group
op_assign
id|ext3_list_backups
c_func
(paren
id|sb
comma
op_amp
id|three
comma
op_amp
id|five
comma
op_amp
id|seven
)paren
)paren
OL
id|last
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
multiline_comment|/* Out of journal space, and can&squot;t get more - abort - so sad */
r_if
c_cond
(paren
id|handle-&gt;h_buffer_credits
op_eq
l_int|0
op_logical_and
id|ext3_journal_extend
c_func
(paren
id|handle
comma
id|EXT3_MAX_TRANS_DATA
)paren
op_logical_and
(paren
id|err
op_assign
id|ext3_journal_restart
c_func
(paren
id|handle
comma
id|EXT3_MAX_TRANS_DATA
)paren
)paren
)paren
r_break
suffix:semicolon
id|bh
op_assign
id|sb_getblk
c_func
(paren
id|sb
comma
id|group
op_star
id|bpg
op_plus
id|blk_off
)paren
suffix:semicolon
id|ext3_debug
c_func
(paren
id|sb
comma
id|__FUNCTION__
comma
l_string|&quot;update metadata backup %#04lx&bslash;n&quot;
comma
id|bh-&gt;b_blocknr
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|ext3_journal_get_write_access
c_func
(paren
id|handle
comma
id|bh
)paren
)paren
)paren
r_break
suffix:semicolon
id|lock_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|bh-&gt;b_data
comma
id|data
comma
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rest
)paren
id|memset
c_func
(paren
id|bh-&gt;b_data
op_plus
id|size
comma
l_int|0
comma
id|rest
)paren
suffix:semicolon
id|set_buffer_uptodate
c_func
(paren
id|bh
)paren
suffix:semicolon
id|unlock_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
id|ext3_journal_dirty_metadata
c_func
(paren
id|handle
comma
id|bh
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|err2
op_assign
id|ext3_journal_stop
c_func
(paren
id|handle
)paren
)paren
op_logical_and
op_logical_neg
id|err
)paren
id|err
op_assign
id|err2
suffix:semicolon
multiline_comment|/*&n;&t; * Ugh! Need to have e2fsck write the backup copies.  It is too&n;&t; * late to revert the resize, we shouldn&squot;t fail just because of&n;&t; * the backup copies (they are only needed in case of corruption).&n;&t; *&n;&t; * However, if we got here we have a journal problem too, so we&n;&t; * can&squot;t really start a transaction to mark the superblock.&n;&t; * Chicken out and just set the flag on the hope it will be written&n;&t; * to disk, and if not - we will simply wait until next fsck.&n;&t; */
id|exit_err
suffix:colon
r_if
c_cond
(paren
id|err
)paren
(brace
id|ext3_warning
c_func
(paren
id|sb
comma
id|__FUNCTION__
comma
l_string|&quot;can&squot;t update backup for group %d (err %d), &quot;
l_string|&quot;forcing fsck on next reboot&bslash;n&quot;
comma
id|group
comma
id|err
)paren
suffix:semicolon
id|sbi-&gt;s_mount_state
op_and_assign
op_complement
id|EXT3_VALID_FS
suffix:semicolon
id|sbi-&gt;s_es-&gt;s_state
op_and_assign
op_complement
id|cpu_to_le16
c_func
(paren
id|EXT3_VALID_FS
)paren
suffix:semicolon
id|mark_buffer_dirty
c_func
(paren
id|sbi-&gt;s_sbh
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Add group descriptor data to an existing or new group descriptor block.&n; * Ensure we handle all possible error conditions _before_ we start modifying&n; * the filesystem, because we cannot abort the transaction and not have it&n; * write the data to disk.&n; *&n; * If we are on a GDT block boundary, we need to get the reserved GDT block.&n; * Otherwise, we may need to add backup GDT blocks for a sparse group.&n; *&n; * We only need to hold the superblock lock while we are actually adding&n; * in the new group&squot;s counts to the superblock.  Prior to that we have&n; * not really &quot;added&quot; the group at all.  We re-check that we are still&n; * adding in the last group in case things have changed since verifying.&n; */
DECL|function|ext3_group_add
r_int
id|ext3_group_add
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_struct
id|ext3_new_group_data
op_star
id|input
)paren
(brace
r_struct
id|ext3_sb_info
op_star
id|sbi
op_assign
id|EXT3_SB
c_func
(paren
id|sb
)paren
suffix:semicolon
r_struct
id|ext3_super_block
op_star
id|es
op_assign
id|sbi-&gt;s_es
suffix:semicolon
r_int
id|reserved_gdb
op_assign
id|ext3_bg_has_super
c_func
(paren
id|sb
comma
id|input-&gt;group
)paren
ques
c_cond
id|le16_to_cpu
c_func
(paren
id|es-&gt;s_reserved_gdt_blocks
)paren
suffix:colon
l_int|0
suffix:semicolon
r_struct
id|buffer_head
op_star
id|primary
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|ext3_group_desc
op_star
id|gdp
suffix:semicolon
r_struct
id|inode
op_star
id|inode
op_assign
l_int|NULL
suffix:semicolon
id|handle_t
op_star
id|handle
suffix:semicolon
r_int
id|gdb_off
comma
id|gdb_num
suffix:semicolon
r_int
id|err
comma
id|err2
suffix:semicolon
id|gdb_num
op_assign
id|input-&gt;group
op_div
id|EXT3_DESC_PER_BLOCK
c_func
(paren
id|sb
)paren
suffix:semicolon
id|gdb_off
op_assign
id|input-&gt;group
op_mod
id|EXT3_DESC_PER_BLOCK
c_func
(paren
id|sb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|gdb_off
op_eq
l_int|0
op_logical_and
op_logical_neg
id|EXT3_HAS_RO_COMPAT_FEATURE
c_func
(paren
id|sb
comma
id|EXT3_FEATURE_RO_COMPAT_SPARSE_SUPER
)paren
)paren
(brace
id|ext3_warning
c_func
(paren
id|sb
comma
id|__FUNCTION__
comma
l_string|&quot;Can&squot;t resize non-sparse filesystem further&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
r_if
c_cond
(paren
id|reserved_gdb
op_logical_or
id|gdb_off
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|EXT3_HAS_COMPAT_FEATURE
c_func
(paren
id|sb
comma
id|EXT3_FEATURE_COMPAT_RESIZE_INODE
)paren
)paren
(brace
id|ext3_warning
c_func
(paren
id|sb
comma
id|__FUNCTION__
comma
l_string|&quot;No reserved GDT blocks, can&squot;t resize&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
id|inode
op_assign
id|iget
c_func
(paren
id|sb
comma
id|EXT3_RESIZE_INO
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inode
op_logical_or
id|is_bad_inode
c_func
(paren
id|inode
)paren
)paren
(brace
id|ext3_warning
c_func
(paren
id|sb
comma
id|__FUNCTION__
comma
l_string|&quot;Error opening resize inode&bslash;n&quot;
)paren
suffix:semicolon
id|iput
c_func
(paren
id|inode
)paren
suffix:semicolon
r_return
op_minus
id|ENOENT
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
(paren
id|err
op_assign
id|verify_group_input
c_func
(paren
id|sb
comma
id|input
)paren
)paren
)paren
r_goto
id|exit_put
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|setup_new_group_blocks
c_func
(paren
id|sb
comma
id|input
)paren
)paren
)paren
r_goto
id|exit_put
suffix:semicolon
multiline_comment|/*&n;&t; * We will always be modifying at least the superblock and a GDT&n;&t; * block.  If we are adding a group past the last current GDT block,&n;&t; * we will also modify the inode and the dindirect block.  If we&n;&t; * are adding a group with superblock/GDT backups  we will also&n;&t; * modify each of the reserved GDT dindirect blocks.&n;&t; */
id|handle
op_assign
id|ext3_journal_start_sb
c_func
(paren
id|sb
comma
id|ext3_bg_has_super
c_func
(paren
id|sb
comma
id|input-&gt;group
)paren
ques
c_cond
l_int|3
op_plus
id|reserved_gdb
suffix:colon
l_int|4
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|handle
)paren
)paren
(brace
id|err
op_assign
id|PTR_ERR
c_func
(paren
id|handle
)paren
suffix:semicolon
r_goto
id|exit_put
suffix:semicolon
)brace
id|lock_super
c_func
(paren
id|sb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|input-&gt;group
op_ne
id|EXT3_SB
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|s_groups_count
)paren
(brace
id|ext3_warning
c_func
(paren
id|sb
comma
id|__FUNCTION__
comma
l_string|&quot;multiple resizers run on filesystem!&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|exit_journal
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|err
op_assign
id|ext3_journal_get_write_access
c_func
(paren
id|handle
comma
id|sbi-&gt;s_sbh
)paren
)paren
)paren
r_goto
id|exit_journal
suffix:semicolon
multiline_comment|/*&n;&t; * We will only either add reserved group blocks to a backup group&n;&t; * or remove reserved blocks for the first group in a new group block.&n;&t; * Doing both would be mean more complex code, and sane people don&squot;t&n;&t; * use non-sparse filesystems anymore.  This is already checked above.&n;&t; */
r_if
c_cond
(paren
id|gdb_off
)paren
(brace
id|primary
op_assign
id|sbi-&gt;s_group_desc
(braket
id|gdb_num
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|ext3_journal_get_write_access
c_func
(paren
id|handle
comma
id|primary
)paren
)paren
)paren
r_goto
id|exit_journal
suffix:semicolon
r_if
c_cond
(paren
id|reserved_gdb
op_logical_and
id|ext3_bg_num_gdb
c_func
(paren
id|sb
comma
id|input-&gt;group
)paren
op_logical_and
(paren
id|err
op_assign
id|reserve_backup_gdb
c_func
(paren
id|handle
comma
id|inode
comma
id|input
)paren
)paren
)paren
r_goto
id|exit_journal
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|err
op_assign
id|add_new_gdb
c_func
(paren
id|handle
comma
id|inode
comma
id|input
comma
op_amp
id|primary
)paren
)paren
)paren
r_goto
id|exit_journal
suffix:semicolon
multiline_comment|/*&n;&t; * OK, now we&squot;ve set up the new group.  Time to make it active.&n;&t; *&n;&t; * Current kernels don&squot;t lock all allocations via lock_super(),&n;&t; * so we have to be safe wrt. concurrent accesses the group&n;&t; * data.  So we need to be careful to set all of the relevant&n;&t; * group descriptor data etc. *before* we enable the group.&n;&t; *&n;&t; * The key field here is EXT3_SB(sb)-&gt;s_groups_count: as long as&n;&t; * that retains its old value, nobody is going to access the new&n;&t; * group.&n;&t; *&n;&t; * So first we update all the descriptor metadata for the new&n;&t; * group; then we update the total disk blocks count; then we&n;&t; * update the groups count to enable the group; then finally we&n;&t; * update the free space counts so that the system can start&n;&t; * using the new disk blocks.&n;&t; */
multiline_comment|/* Update group descriptor block for new group */
id|gdp
op_assign
(paren
r_struct
id|ext3_group_desc
op_star
)paren
id|primary-&gt;b_data
op_plus
id|gdb_off
suffix:semicolon
id|gdp-&gt;bg_block_bitmap
op_assign
id|cpu_to_le32
c_func
(paren
id|input-&gt;block_bitmap
)paren
suffix:semicolon
id|gdp-&gt;bg_inode_bitmap
op_assign
id|cpu_to_le32
c_func
(paren
id|input-&gt;inode_bitmap
)paren
suffix:semicolon
id|gdp-&gt;bg_inode_table
op_assign
id|cpu_to_le32
c_func
(paren
id|input-&gt;inode_table
)paren
suffix:semicolon
id|gdp-&gt;bg_free_blocks_count
op_assign
id|cpu_to_le16
c_func
(paren
id|input-&gt;free_blocks_count
)paren
suffix:semicolon
id|gdp-&gt;bg_free_inodes_count
op_assign
id|cpu_to_le16
c_func
(paren
id|EXT3_INODES_PER_GROUP
c_func
(paren
id|sb
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Make the new blocks and inodes valid next.  We do this before&n;&t; * increasing the group count so that once the group is enabled,&n;&t; * all of its blocks and inodes are already valid.&n;&t; *&n;&t; * We always allocate group-by-group, then block-by-block or&n;&t; * inode-by-inode within a group, so enabling these&n;&t; * blocks/inodes before the group is live won&squot;t actually let us&n;&t; * allocate the new space yet.&n;&t; */
id|es-&gt;s_blocks_count
op_assign
id|cpu_to_le32
c_func
(paren
id|le32_to_cpu
c_func
(paren
id|es-&gt;s_blocks_count
)paren
op_plus
id|input-&gt;blocks_count
)paren
suffix:semicolon
id|es-&gt;s_inodes_count
op_assign
id|cpu_to_le32
c_func
(paren
id|le32_to_cpu
c_func
(paren
id|es-&gt;s_inodes_count
)paren
op_plus
id|EXT3_INODES_PER_GROUP
c_func
(paren
id|sb
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We need to protect s_groups_count against other CPUs seeing&n;&t; * inconsistent state in the superblock.&n;&t; *&n;&t; * The precise rules we use are:&n;&t; *&n;&t; * * Writers of s_groups_count *must* hold lock_super&n;&t; * AND&n;&t; * * Writers must perform a smp_wmb() after updating all dependent&n;&t; *   data and before modifying the groups count&n;&t; *&n;&t; * * Readers must hold lock_super() over the access&n;&t; * OR&n;&t; * * Readers must perform an smp_rmb() after reading the groups count&n;&t; *   and before reading any dependent data.&n;&t; *&n;&t; * NB. These rules can be relaxed when checking the group count&n;&t; * while freeing data, as we can only allocate from a block&n;&t; * group after serialising against the group count, and we can&n;&t; * only then free after serialising in turn against that&n;&t; * allocation.&n;&t; */
id|smp_wmb
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Update the global fs size fields */
id|EXT3_SB
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|s_groups_count
op_increment
suffix:semicolon
id|ext3_journal_dirty_metadata
c_func
(paren
id|handle
comma
id|primary
)paren
suffix:semicolon
multiline_comment|/* Update the reserved block counts only once the new group is&n;&t; * active. */
id|es-&gt;s_r_blocks_count
op_assign
id|cpu_to_le32
c_func
(paren
id|le32_to_cpu
c_func
(paren
id|es-&gt;s_r_blocks_count
)paren
op_plus
id|input-&gt;reserved_blocks
)paren
suffix:semicolon
multiline_comment|/* Update the free space counts */
id|percpu_counter_mod
c_func
(paren
op_amp
id|sbi-&gt;s_freeblocks_counter
comma
id|input-&gt;free_blocks_count
)paren
suffix:semicolon
id|percpu_counter_mod
c_func
(paren
op_amp
id|sbi-&gt;s_freeinodes_counter
comma
id|EXT3_INODES_PER_GROUP
c_func
(paren
id|sb
)paren
)paren
suffix:semicolon
id|ext3_journal_dirty_metadata
c_func
(paren
id|handle
comma
id|EXT3_SB
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|s_sbh
)paren
suffix:semicolon
id|sb-&gt;s_dirt
op_assign
l_int|1
suffix:semicolon
id|exit_journal
suffix:colon
id|unlock_super
c_func
(paren
id|sb
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err2
op_assign
id|ext3_journal_stop
c_func
(paren
id|handle
)paren
)paren
op_logical_and
op_logical_neg
id|err
)paren
id|err
op_assign
id|err2
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|err
)paren
(brace
id|update_backups
c_func
(paren
id|sb
comma
id|sbi-&gt;s_sbh-&gt;b_blocknr
comma
(paren
r_char
op_star
)paren
id|es
comma
r_sizeof
(paren
r_struct
id|ext3_super_block
)paren
)paren
suffix:semicolon
id|update_backups
c_func
(paren
id|sb
comma
id|primary-&gt;b_blocknr
comma
id|primary-&gt;b_data
comma
id|primary-&gt;b_size
)paren
suffix:semicolon
)brace
id|exit_put
suffix:colon
id|iput
c_func
(paren
id|inode
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/* ext3_group_add */
multiline_comment|/* Extend the filesystem to the new number of blocks specified.  This entry&n; * point is only used to extend the current filesystem to the end of the last&n; * existing group.  It can be accessed via ioctl, or by &quot;remount,resize=&lt;size&gt;&quot;&n; * for emergencies (because it has no dependencies on reserved blocks).&n; *&n; * If we _really_ wanted, we could use default values to call ext3_group_add()&n; * allow the &quot;remount&quot; trick to work for arbitrary resizing, assuming enough&n; * GDT blocks are reserved to grow to the desired size.&n; */
DECL|function|ext3_group_extend
r_int
id|ext3_group_extend
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_struct
id|ext3_super_block
op_star
id|es
comma
r_int
r_int
id|n_blocks_count
)paren
(brace
r_int
r_int
id|o_blocks_count
suffix:semicolon
r_int
r_int
id|o_groups_count
suffix:semicolon
r_int
r_int
id|last
suffix:semicolon
r_int
id|add
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
id|handle_t
op_star
id|handle
suffix:semicolon
r_int
id|err
comma
id|freed_blocks
suffix:semicolon
multiline_comment|/* We don&squot;t need to worry about locking wrt other resizers just&n;&t; * yet: we&squot;re going to revalidate es-&gt;s_blocks_count after&n;&t; * taking lock_super() below. */
id|o_blocks_count
op_assign
id|le32_to_cpu
c_func
(paren
id|es-&gt;s_blocks_count
)paren
suffix:semicolon
id|o_groups_count
op_assign
id|EXT3_SB
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|s_groups_count
suffix:semicolon
r_if
c_cond
(paren
id|test_opt
c_func
(paren
id|sb
comma
id|DEBUG
)paren
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;EXT3-fs: extending last group from %lu to %lu blocks&bslash;n&quot;
comma
id|o_blocks_count
comma
id|n_blocks_count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|n_blocks_count
op_eq
l_int|0
op_logical_or
id|n_blocks_count
op_eq
id|o_blocks_count
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|n_blocks_count
OL
id|o_blocks_count
)paren
(brace
id|ext3_warning
c_func
(paren
id|sb
comma
id|__FUNCTION__
comma
l_string|&quot;can&squot;t shrink FS - resize aborted&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
multiline_comment|/* Handle the remaining blocks in the last group only. */
id|last
op_assign
(paren
id|o_blocks_count
op_minus
id|le32_to_cpu
c_func
(paren
id|es-&gt;s_first_data_block
)paren
)paren
op_mod
id|EXT3_BLOCKS_PER_GROUP
c_func
(paren
id|sb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|last
op_eq
l_int|0
)paren
(brace
id|ext3_warning
c_func
(paren
id|sb
comma
id|__FUNCTION__
comma
l_string|&quot;need to use ext2online to resize further&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
id|add
op_assign
id|EXT3_BLOCKS_PER_GROUP
c_func
(paren
id|sb
)paren
op_minus
id|last
suffix:semicolon
r_if
c_cond
(paren
id|o_blocks_count
op_plus
id|add
OG
id|n_blocks_count
)paren
id|add
op_assign
id|n_blocks_count
op_minus
id|o_blocks_count
suffix:semicolon
r_if
c_cond
(paren
id|o_blocks_count
op_plus
id|add
OL
id|n_blocks_count
)paren
id|ext3_warning
c_func
(paren
id|sb
comma
id|__FUNCTION__
comma
l_string|&quot;will only finish group (%lu blocks, %u new)&quot;
comma
id|o_blocks_count
op_plus
id|add
comma
id|add
)paren
suffix:semicolon
multiline_comment|/* See if the device is actually as big as what was requested */
id|bh
op_assign
id|sb_bread
c_func
(paren
id|sb
comma
id|o_blocks_count
op_plus
id|add
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bh
)paren
(brace
id|ext3_warning
c_func
(paren
id|sb
comma
id|__FUNCTION__
comma
l_string|&quot;can&squot;t read last block, resize aborted&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOSPC
suffix:semicolon
)brace
id|brelse
c_func
(paren
id|bh
)paren
suffix:semicolon
multiline_comment|/* We will update the superblock, one block bitmap, and&n;&t; * one group descriptor via ext3_free_blocks().&n;&t; */
id|handle
op_assign
id|ext3_journal_start_sb
c_func
(paren
id|sb
comma
l_int|3
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|handle
)paren
)paren
(brace
id|err
op_assign
id|PTR_ERR
c_func
(paren
id|handle
)paren
suffix:semicolon
id|ext3_warning
c_func
(paren
id|sb
comma
id|__FUNCTION__
comma
l_string|&quot;error %d on journal start&quot;
comma
id|err
)paren
suffix:semicolon
r_goto
id|exit_put
suffix:semicolon
)brace
id|lock_super
c_func
(paren
id|sb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|o_blocks_count
op_ne
id|le32_to_cpu
c_func
(paren
id|es-&gt;s_blocks_count
)paren
)paren
(brace
id|ext3_warning
c_func
(paren
id|sb
comma
id|__FUNCTION__
comma
l_string|&quot;multiple resizers run on filesystem!&bslash;n&quot;
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_goto
id|exit_put
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|err
op_assign
id|ext3_journal_get_write_access
c_func
(paren
id|handle
comma
id|EXT3_SB
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|s_sbh
)paren
)paren
)paren
(brace
id|ext3_warning
c_func
(paren
id|sb
comma
id|__FUNCTION__
comma
l_string|&quot;error %d on journal write access&quot;
comma
id|err
)paren
suffix:semicolon
id|unlock_super
c_func
(paren
id|sb
)paren
suffix:semicolon
id|ext3_journal_stop
c_func
(paren
id|handle
)paren
suffix:semicolon
r_goto
id|exit_put
suffix:semicolon
)brace
id|es-&gt;s_blocks_count
op_assign
id|cpu_to_le32
c_func
(paren
id|o_blocks_count
op_plus
id|add
)paren
suffix:semicolon
id|ext3_journal_dirty_metadata
c_func
(paren
id|handle
comma
id|EXT3_SB
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|s_sbh
)paren
suffix:semicolon
id|sb-&gt;s_dirt
op_assign
l_int|1
suffix:semicolon
id|unlock_super
c_func
(paren
id|sb
)paren
suffix:semicolon
id|ext3_debug
c_func
(paren
l_string|&quot;freeing blocks %ld through %ld&bslash;n&quot;
comma
id|o_blocks_count
comma
id|o_blocks_count
op_plus
id|add
)paren
suffix:semicolon
id|ext3_free_blocks_sb
c_func
(paren
id|handle
comma
id|sb
comma
id|o_blocks_count
comma
id|add
comma
op_amp
id|freed_blocks
)paren
suffix:semicolon
id|ext3_debug
c_func
(paren
l_string|&quot;freed blocks %ld through %ld&bslash;n&quot;
comma
id|o_blocks_count
comma
id|o_blocks_count
op_plus
id|add
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|ext3_journal_stop
c_func
(paren
id|handle
)paren
)paren
)paren
r_goto
id|exit_put
suffix:semicolon
r_if
c_cond
(paren
id|test_opt
c_func
(paren
id|sb
comma
id|DEBUG
)paren
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;EXT3-fs: extended group to %u blocks&bslash;n&quot;
comma
id|le32_to_cpu
c_func
(paren
id|es-&gt;s_blocks_count
)paren
)paren
suffix:semicolon
id|update_backups
c_func
(paren
id|sb
comma
id|EXT3_SB
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|s_sbh-&gt;b_blocknr
comma
(paren
r_char
op_star
)paren
id|es
comma
r_sizeof
(paren
r_struct
id|ext3_super_block
)paren
)paren
suffix:semicolon
id|exit_put
suffix:colon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/* ext3_group_extend */
eof
