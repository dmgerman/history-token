multiline_comment|/*&n; *  linux/fs/ext3/super.c&n; *&n; * Copyright (C) 1992, 1993, 1994, 1995&n; * Remy Card (card@masi.ibp.fr)&n; * Laboratoire MASI - Institut Blaise Pascal&n; * Universite Pierre et Marie Curie (Paris VI)&n; *&n; *  from&n; *&n; *  linux/fs/minix/inode.c&n; *&n; *  Copyright (C) 1991, 1992  Linus Torvalds&n; *&n; *  Big-endian to little-endian byte-swapping/bitmaps by&n; *        David S. Miller (davem@caip.rutgers.edu), 1995&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/time.h&gt;
macro_line|#include &lt;linux/jbd.h&gt;
macro_line|#include &lt;linux/ext3_fs.h&gt;
macro_line|#include &lt;linux/ext3_jbd.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/locks.h&gt;
macro_line|#include &lt;linux/blkdev.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#ifdef CONFIG_JBD_DEBUG
DECL|variable|ext3_ro_after
r_static
r_int
id|ext3_ro_after
suffix:semicolon
multiline_comment|/* Make fs read-only after this many jiffies */
macro_line|#endif
r_static
r_int
id|ext3_load_journal
c_func
(paren
r_struct
id|super_block
op_star
comma
r_struct
id|ext3_super_block
op_star
)paren
suffix:semicolon
r_static
r_int
id|ext3_create_journal
c_func
(paren
r_struct
id|super_block
op_star
comma
r_struct
id|ext3_super_block
op_star
comma
r_int
)paren
suffix:semicolon
r_static
r_void
id|ext3_commit_super
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_struct
id|ext3_super_block
op_star
id|es
comma
r_int
id|sync
)paren
suffix:semicolon
r_static
r_void
id|ext3_mark_recovery_complete
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_struct
id|ext3_super_block
op_star
id|es
)paren
suffix:semicolon
r_static
r_void
id|ext3_clear_journal_err
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_struct
id|ext3_super_block
op_star
id|es
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_JBD_DEBUG
DECL|variable|journal_no_write
r_int
id|journal_no_write
(braket
l_int|2
)braket
suffix:semicolon
multiline_comment|/*&n; * Debug code for turning filesystems &quot;read-only&quot; after a specified&n; * amount of time.  This is for crash/recovery testing.&n; */
DECL|function|make_rdonly
r_static
r_void
id|make_rdonly
c_func
(paren
r_struct
id|block_device
op_star
id|bdev
comma
r_int
op_star
id|no_write
)paren
(brace
r_if
c_cond
(paren
id|bdev
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Turning device %s read-only&bslash;n&quot;
comma
id|bdevname
c_func
(paren
id|bdev
)paren
)paren
suffix:semicolon
op_star
id|no_write
op_assign
l_int|0xdead0000
op_plus
id|bdev-&gt;bd_dev
suffix:semicolon
)brace
)brace
DECL|function|turn_fs_readonly
r_static
r_void
id|turn_fs_readonly
c_func
(paren
r_int
r_int
id|arg
)paren
(brace
r_struct
id|super_block
op_star
id|sb
op_assign
(paren
r_struct
id|super_block
op_star
)paren
id|arg
suffix:semicolon
id|make_rdonly
c_func
(paren
id|sb-&gt;s_bdev
comma
op_amp
id|journal_no_write
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|make_rdonly
c_func
(paren
id|EXT3_SB
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|s_journal-&gt;j_dev
comma
op_amp
id|journal_no_write
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|EXT3_SB
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|ro_wait_queue
)paren
suffix:semicolon
)brace
DECL|function|setup_ro_after
r_static
r_void
id|setup_ro_after
c_func
(paren
r_struct
id|super_block
op_star
id|sb
)paren
(brace
r_struct
id|ext3_sb_info
op_star
id|sbi
op_assign
id|EXT3_SB
c_func
(paren
id|sb
)paren
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|sbi-&gt;turn_ro_timer
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ext3_ro_after
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;fs will go read-only in %d jiffies&bslash;n&quot;
comma
id|ext3_ro_after
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|sbi-&gt;ro_wait_queue
)paren
suffix:semicolon
id|journal_no_write
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|journal_no_write
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
id|sbi-&gt;turn_ro_timer.function
op_assign
id|turn_fs_readonly
suffix:semicolon
id|sbi-&gt;turn_ro_timer.data
op_assign
(paren
r_int
r_int
)paren
id|sb
suffix:semicolon
id|sbi-&gt;turn_ro_timer.expires
op_assign
id|jiffies
op_plus
id|ext3_ro_after
suffix:semicolon
id|ext3_ro_after
op_assign
l_int|0
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|sbi-&gt;turn_ro_timer
)paren
suffix:semicolon
)brace
)brace
DECL|function|clear_ro_after
r_static
r_void
id|clear_ro_after
c_func
(paren
r_struct
id|super_block
op_star
id|sb
)paren
(brace
id|del_timer_sync
c_func
(paren
op_amp
id|EXT3_SB
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|turn_ro_timer
)paren
suffix:semicolon
id|journal_no_write
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|journal_no_write
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
id|ext3_ro_after
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#else
DECL|macro|setup_ro_after
mdefine_line|#define setup_ro_after(sb)&t;do {} while (0)
DECL|macro|clear_ro_after
mdefine_line|#define clear_ro_after(sb)&t;do {} while (0)
macro_line|#endif
DECL|variable|error_buf
r_static
r_char
id|error_buf
(braket
l_int|1024
)braket
suffix:semicolon
multiline_comment|/* Determine the appropriate response to ext3_error on a given filesystem */
DECL|function|ext3_error_behaviour
r_static
r_int
id|ext3_error_behaviour
c_func
(paren
r_struct
id|super_block
op_star
id|sb
)paren
(brace
multiline_comment|/* First check for mount-time options */
r_if
c_cond
(paren
id|test_opt
(paren
id|sb
comma
id|ERRORS_PANIC
)paren
)paren
r_return
id|EXT3_ERRORS_PANIC
suffix:semicolon
r_if
c_cond
(paren
id|test_opt
(paren
id|sb
comma
id|ERRORS_RO
)paren
)paren
r_return
id|EXT3_ERRORS_RO
suffix:semicolon
r_if
c_cond
(paren
id|test_opt
(paren
id|sb
comma
id|ERRORS_CONT
)paren
)paren
r_return
id|EXT3_ERRORS_CONTINUE
suffix:semicolon
multiline_comment|/* If no overrides were specified on the mount, then fall back&n;&t; * to the default behaviour set in the filesystem&squot;s superblock&n;&t; * on disk. */
r_switch
c_cond
(paren
id|le16_to_cpu
c_func
(paren
id|sb-&gt;u.ext3_sb.s_es-&gt;s_errors
)paren
)paren
(brace
r_case
id|EXT3_ERRORS_PANIC
suffix:colon
r_return
id|EXT3_ERRORS_PANIC
suffix:semicolon
r_case
id|EXT3_ERRORS_RO
suffix:colon
r_return
id|EXT3_ERRORS_RO
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
r_return
id|EXT3_ERRORS_CONTINUE
suffix:semicolon
)brace
multiline_comment|/* Deal with the reporting of failure conditions on a filesystem such as&n; * inconsistencies detected or read IO failures.&n; *&n; * On ext2, we can store the error state of the filesystem in the&n; * superblock.  That is not possible on ext3, because we may have other&n; * write ordering constraints on the superblock which prevent us from&n; * writing it out straight away; and given that the journal is about to&n; * be aborted, we can&squot;t rely on the current, or future, transactions to&n; * write out the superblock safely.&n; *&n; * We&squot;ll just use the journal_abort() error code to record an error in&n; * the journal instead.  On recovery, the journal will compain about&n; * that error until we&squot;ve noted it down and cleared it.&n; */
DECL|function|ext3_handle_error
r_static
r_void
id|ext3_handle_error
c_func
(paren
r_struct
id|super_block
op_star
id|sb
)paren
(brace
r_struct
id|ext3_super_block
op_star
id|es
op_assign
id|EXT3_SB
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|s_es
suffix:semicolon
id|EXT3_SB
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|s_mount_state
op_or_assign
id|EXT3_ERROR_FS
suffix:semicolon
id|es-&gt;s_state
op_or_assign
id|cpu_to_le32
c_func
(paren
id|EXT3_ERROR_FS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sb-&gt;s_flags
op_amp
id|MS_RDONLY
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|ext3_error_behaviour
c_func
(paren
id|sb
)paren
op_ne
id|EXT3_ERRORS_CONTINUE
)paren
(brace
id|EXT3_SB
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|s_mount_opt
op_or_assign
id|EXT3_MOUNT_ABORT
suffix:semicolon
id|journal_abort
c_func
(paren
id|EXT3_SB
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|s_journal
comma
op_minus
id|EIO
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ext3_error_behaviour
c_func
(paren
id|sb
)paren
op_eq
id|EXT3_ERRORS_PANIC
)paren
id|panic
(paren
l_string|&quot;EXT3-fs (device %s): panic forced after error&bslash;n&quot;
comma
id|sb-&gt;s_id
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ext3_error_behaviour
c_func
(paren
id|sb
)paren
op_eq
id|EXT3_ERRORS_RO
)paren
(brace
id|printk
(paren
id|KERN_CRIT
l_string|&quot;Remounting filesystem read-only&bslash;n&quot;
)paren
suffix:semicolon
id|sb-&gt;s_flags
op_or_assign
id|MS_RDONLY
suffix:semicolon
)brace
id|ext3_commit_super
c_func
(paren
id|sb
comma
id|es
comma
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|ext3_error
r_void
id|ext3_error
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_const
r_char
op_star
id|function
comma
r_const
r_char
op_star
id|fmt
comma
dot
dot
dot
)paren
(brace
id|va_list
id|args
suffix:semicolon
id|va_start
(paren
id|args
comma
id|fmt
)paren
suffix:semicolon
id|vsprintf
(paren
id|error_buf
comma
id|fmt
comma
id|args
)paren
suffix:semicolon
id|va_end
(paren
id|args
)paren
suffix:semicolon
id|printk
(paren
id|KERN_CRIT
l_string|&quot;EXT3-fs error (device %s): %s: %s&bslash;n&quot;
comma
id|sb-&gt;s_id
comma
id|function
comma
id|error_buf
)paren
suffix:semicolon
id|ext3_handle_error
c_func
(paren
id|sb
)paren
suffix:semicolon
)brace
DECL|function|ext3_decode_error
r_const
r_char
op_star
id|ext3_decode_error
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_int
id|errno
comma
r_char
id|nbuf
(braket
l_int|16
)braket
)paren
(brace
r_char
op_star
id|errstr
op_assign
l_int|NULL
suffix:semicolon
r_switch
c_cond
(paren
id|errno
)paren
(brace
r_case
op_minus
id|EIO
suffix:colon
id|errstr
op_assign
l_string|&quot;IO failure&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
op_minus
id|ENOMEM
suffix:colon
id|errstr
op_assign
l_string|&quot;Out of memory&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
op_minus
id|EROFS
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|sb
op_logical_or
id|EXT3_SB
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|s_journal-&gt;j_flags
op_amp
id|JFS_ABORT
)paren
id|errstr
op_assign
l_string|&quot;Journal has aborted&quot;
suffix:semicolon
r_else
id|errstr
op_assign
l_string|&quot;Readonly filesystem&quot;
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
multiline_comment|/* If the caller passed in an extra buffer for unknown&n;&t;&t; * errors, textualise them now.  Else we just return&n;&t;&t; * NULL. */
r_if
c_cond
(paren
id|nbuf
)paren
(brace
multiline_comment|/* Check for truncated error codes... */
r_if
c_cond
(paren
id|snprintf
c_func
(paren
id|nbuf
comma
l_int|16
comma
l_string|&quot;error %d&quot;
comma
op_minus
id|errno
)paren
op_ge
l_int|0
)paren
id|errstr
op_assign
id|nbuf
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
r_return
id|errstr
suffix:semicolon
)brace
multiline_comment|/* __ext3_std_error decodes expected errors from journaling functions&n; * automatically and invokes the appropriate error response.  */
DECL|function|__ext3_std_error
r_void
id|__ext3_std_error
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_const
r_char
op_star
id|function
comma
r_int
id|errno
)paren
(brace
r_char
id|nbuf
(braket
l_int|16
)braket
suffix:semicolon
r_const
r_char
op_star
id|errstr
op_assign
id|ext3_decode_error
c_func
(paren
id|sb
comma
id|errno
comma
id|nbuf
)paren
suffix:semicolon
id|printk
(paren
id|KERN_CRIT
l_string|&quot;EXT3-fs error (device %s) in %s: %s&bslash;n&quot;
comma
id|sb-&gt;s_id
comma
id|function
comma
id|errstr
)paren
suffix:semicolon
id|ext3_handle_error
c_func
(paren
id|sb
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * ext3_abort is a much stronger failure handler than ext3_error.  The&n; * abort function may be used to deal with unrecoverable failures such&n; * as journal IO errors or ENOMEM at a critical moment in log management.&n; *&n; * We unconditionally force the filesystem into an ABORT|READONLY state,&n; * unless the error response on the fs has been set to panic in which&n; * case we take the easy way out and panic immediately.&n; */
DECL|function|ext3_abort
r_void
id|ext3_abort
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_const
r_char
op_star
id|function
comma
r_const
r_char
op_star
id|fmt
comma
dot
dot
dot
)paren
(brace
id|va_list
id|args
suffix:semicolon
id|printk
(paren
id|KERN_CRIT
l_string|&quot;ext3_abort called.&bslash;n&quot;
)paren
suffix:semicolon
id|va_start
(paren
id|args
comma
id|fmt
)paren
suffix:semicolon
id|vsprintf
(paren
id|error_buf
comma
id|fmt
comma
id|args
)paren
suffix:semicolon
id|va_end
(paren
id|args
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ext3_error_behaviour
c_func
(paren
id|sb
)paren
op_eq
id|EXT3_ERRORS_PANIC
)paren
id|panic
(paren
l_string|&quot;EXT3-fs panic (device %s): %s: %s&bslash;n&quot;
comma
id|sb-&gt;s_id
comma
id|function
comma
id|error_buf
)paren
suffix:semicolon
id|printk
(paren
id|KERN_CRIT
l_string|&quot;EXT3-fs abort (device %s): %s: %s&bslash;n&quot;
comma
id|sb-&gt;s_id
comma
id|function
comma
id|error_buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sb-&gt;s_flags
op_amp
id|MS_RDONLY
)paren
r_return
suffix:semicolon
id|printk
(paren
id|KERN_CRIT
l_string|&quot;Remounting filesystem read-only&bslash;n&quot;
)paren
suffix:semicolon
id|sb-&gt;u.ext3_sb.s_mount_state
op_or_assign
id|EXT3_ERROR_FS
suffix:semicolon
id|sb-&gt;s_flags
op_or_assign
id|MS_RDONLY
suffix:semicolon
id|sb-&gt;u.ext3_sb.s_mount_opt
op_or_assign
id|EXT3_MOUNT_ABORT
suffix:semicolon
id|journal_abort
c_func
(paren
id|EXT3_SB
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|s_journal
comma
op_minus
id|EIO
)paren
suffix:semicolon
)brace
multiline_comment|/* Deal with the reporting of failure conditions while running, such as&n; * inconsistencies in operation or invalid system states.&n; *&n; * Use ext3_error() for cases of invalid filesystem states, as that will&n; * record an error on disk and force a filesystem check on the next boot.&n; */
DECL|function|ext3_panic
id|NORET_TYPE
r_void
id|ext3_panic
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_const
r_char
op_star
id|function
comma
r_const
r_char
op_star
id|fmt
comma
dot
dot
dot
)paren
(brace
id|va_list
id|args
suffix:semicolon
id|va_start
(paren
id|args
comma
id|fmt
)paren
suffix:semicolon
id|vsprintf
(paren
id|error_buf
comma
id|fmt
comma
id|args
)paren
suffix:semicolon
id|va_end
(paren
id|args
)paren
suffix:semicolon
multiline_comment|/* this is to prevent panic from syncing this filesystem */
multiline_comment|/* AKPM: is this sufficient? */
id|sb-&gt;s_flags
op_or_assign
id|MS_RDONLY
suffix:semicolon
id|panic
(paren
l_string|&quot;EXT3-fs panic (device %s): %s: %s&bslash;n&quot;
comma
id|sb-&gt;s_id
comma
id|function
comma
id|error_buf
)paren
suffix:semicolon
)brace
DECL|function|ext3_warning
r_void
id|ext3_warning
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_const
r_char
op_star
id|function
comma
r_const
r_char
op_star
id|fmt
comma
dot
dot
dot
)paren
(brace
id|va_list
id|args
suffix:semicolon
id|va_start
(paren
id|args
comma
id|fmt
)paren
suffix:semicolon
id|vsprintf
(paren
id|error_buf
comma
id|fmt
comma
id|args
)paren
suffix:semicolon
id|va_end
(paren
id|args
)paren
suffix:semicolon
id|printk
(paren
id|KERN_WARNING
l_string|&quot;EXT3-fs warning (device %s): %s: %s&bslash;n&quot;
comma
id|sb-&gt;s_id
comma
id|function
comma
id|error_buf
)paren
suffix:semicolon
)brace
DECL|function|ext3_update_dynamic_rev
r_void
id|ext3_update_dynamic_rev
c_func
(paren
r_struct
id|super_block
op_star
id|sb
)paren
(brace
r_struct
id|ext3_super_block
op_star
id|es
op_assign
id|EXT3_SB
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|s_es
suffix:semicolon
r_if
c_cond
(paren
id|le32_to_cpu
c_func
(paren
id|es-&gt;s_rev_level
)paren
OG
id|EXT3_GOOD_OLD_REV
)paren
r_return
suffix:semicolon
id|ext3_warning
c_func
(paren
id|sb
comma
id|__FUNCTION__
comma
l_string|&quot;updating to rev %d because of new feature flag, &quot;
l_string|&quot;running e2fsck is recommended&quot;
comma
id|EXT3_DYNAMIC_REV
)paren
suffix:semicolon
id|es-&gt;s_first_ino
op_assign
id|cpu_to_le32
c_func
(paren
id|EXT3_GOOD_OLD_FIRST_INO
)paren
suffix:semicolon
id|es-&gt;s_inode_size
op_assign
id|cpu_to_le16
c_func
(paren
id|EXT3_GOOD_OLD_INODE_SIZE
)paren
suffix:semicolon
id|es-&gt;s_rev_level
op_assign
id|cpu_to_le32
c_func
(paren
id|EXT3_DYNAMIC_REV
)paren
suffix:semicolon
multiline_comment|/* leave es-&gt;s_feature_*compat flags alone */
multiline_comment|/* es-&gt;s_uuid will be set by e2fsck if empty */
multiline_comment|/*&n;&t; * The rest of the superblock fields should be zero, and if not it&n;&t; * means they are likely already in use, so leave them alone.  We&n;&t; * can leave it up to e2fsck to clean up any inconsistencies there.&n;&t; */
)brace
multiline_comment|/*&n; * Open the external journal device&n; */
DECL|function|ext3_blkdev_get
r_static
r_struct
id|block_device
op_star
id|ext3_blkdev_get
c_func
(paren
id|kdev_t
id|dev
)paren
(brace
r_struct
id|block_device
op_star
id|bdev
suffix:semicolon
r_int
id|err
op_assign
op_minus
id|ENODEV
suffix:semicolon
id|bdev
op_assign
id|bdget
c_func
(paren
id|kdev_t_to_nr
c_func
(paren
id|dev
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bdev
op_eq
l_int|NULL
)paren
r_goto
id|fail
suffix:semicolon
id|err
op_assign
id|blkdev_get
c_func
(paren
id|bdev
comma
id|FMODE_READ
op_or
id|FMODE_WRITE
comma
l_int|0
comma
id|BDEV_FS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_goto
id|fail
suffix:semicolon
r_return
id|bdev
suffix:semicolon
id|fail
suffix:colon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;EXT3: failed to open journal device %s: %d&bslash;n&quot;
comma
id|__bdevname
c_func
(paren
id|dev
)paren
comma
id|err
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * Release the journal device&n; */
DECL|function|ext3_blkdev_put
r_static
r_int
id|ext3_blkdev_put
c_func
(paren
r_struct
id|block_device
op_star
id|bdev
)paren
(brace
r_return
id|blkdev_put
c_func
(paren
id|bdev
comma
id|BDEV_FS
)paren
suffix:semicolon
)brace
DECL|function|ext3_blkdev_remove
r_static
r_int
id|ext3_blkdev_remove
c_func
(paren
r_struct
id|ext3_sb_info
op_star
id|sbi
)paren
(brace
r_struct
id|block_device
op_star
id|bdev
suffix:semicolon
r_int
id|ret
op_assign
op_minus
id|ENODEV
suffix:semicolon
id|bdev
op_assign
id|sbi-&gt;journal_bdev
suffix:semicolon
r_if
c_cond
(paren
id|bdev
)paren
(brace
id|ret
op_assign
id|ext3_blkdev_put
c_func
(paren
id|bdev
)paren
suffix:semicolon
id|sbi-&gt;journal_bdev
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|function|orphan_list_entry
r_static
r_inline
r_struct
id|inode
op_star
id|orphan_list_entry
c_func
(paren
r_struct
id|list_head
op_star
id|l
)paren
(brace
r_return
op_amp
id|list_entry
c_func
(paren
id|l
comma
r_struct
id|ext3_inode_info
comma
id|i_orphan
)paren
op_member_access_from_pointer
id|vfs_inode
suffix:semicolon
)brace
DECL|function|dump_orphan_list
r_static
r_void
id|dump_orphan_list
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_struct
id|ext3_sb_info
op_star
id|sbi
)paren
(brace
r_struct
id|list_head
op_star
id|l
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;sb orphan head is %d&bslash;n&quot;
comma
id|le32_to_cpu
c_func
(paren
id|sbi-&gt;s_es-&gt;s_last_orphan
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;sb_info orphan list:&bslash;n&quot;
)paren
suffix:semicolon
id|list_for_each
c_func
(paren
id|l
comma
op_amp
id|sbi-&gt;s_orphan
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|orphan_list_entry
c_func
(paren
id|l
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;  &quot;
l_string|&quot;inode %s:%ld at %p: mode %o, nlink %d, next %d&bslash;n&quot;
comma
id|inode-&gt;i_sb-&gt;s_id
comma
id|inode-&gt;i_ino
comma
id|inode
comma
id|inode-&gt;i_mode
comma
id|inode-&gt;i_nlink
comma
id|le32_to_cpu
c_func
(paren
id|NEXT_ORPHAN
c_func
(paren
id|inode
)paren
)paren
)paren
suffix:semicolon
)brace
)brace
DECL|function|ext3_put_super
r_void
id|ext3_put_super
(paren
r_struct
id|super_block
op_star
id|sb
)paren
(brace
r_struct
id|ext3_sb_info
op_star
id|sbi
op_assign
id|EXT3_SB
c_func
(paren
id|sb
)paren
suffix:semicolon
r_struct
id|ext3_super_block
op_star
id|es
op_assign
id|sbi-&gt;s_es
suffix:semicolon
r_int
id|i
suffix:semicolon
id|journal_destroy
c_func
(paren
id|sbi-&gt;s_journal
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|sb-&gt;s_flags
op_amp
id|MS_RDONLY
)paren
)paren
(brace
id|EXT3_CLEAR_INCOMPAT_FEATURE
c_func
(paren
id|sb
comma
id|EXT3_FEATURE_INCOMPAT_RECOVER
)paren
suffix:semicolon
id|es-&gt;s_state
op_assign
id|le16_to_cpu
c_func
(paren
id|sbi-&gt;s_mount_state
)paren
suffix:semicolon
id|BUFFER_TRACE
c_func
(paren
id|sbi-&gt;s_sbh
comma
l_string|&quot;marking dirty&quot;
)paren
suffix:semicolon
id|mark_buffer_dirty
c_func
(paren
id|sbi-&gt;s_sbh
)paren
suffix:semicolon
id|ext3_commit_super
c_func
(paren
id|sb
comma
id|es
comma
l_int|1
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|sbi-&gt;s_gdb_count
suffix:semicolon
id|i
op_increment
)paren
id|brelse
c_func
(paren
id|sbi-&gt;s_group_desc
(braket
id|i
)braket
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|sbi-&gt;s_group_desc
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|EXT3_MAX_GROUP_LOADED
suffix:semicolon
id|i
op_increment
)paren
id|brelse
c_func
(paren
id|sbi-&gt;s_inode_bitmap
(braket
id|i
)braket
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|EXT3_MAX_GROUP_LOADED
suffix:semicolon
id|i
op_increment
)paren
id|brelse
c_func
(paren
id|sbi-&gt;s_block_bitmap
(braket
id|i
)braket
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|sbi-&gt;s_sbh
)paren
suffix:semicolon
multiline_comment|/* Debugging code just in case the in-memory inode orphan list&n;&t; * isn&squot;t empty.  The on-disk one can be non-empty if we&squot;ve&n;&t; * detected an error and taken the fs readonly, but the&n;&t; * in-memory list had better be clean by this point. */
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|sbi-&gt;s_orphan
)paren
)paren
id|dump_orphan_list
c_func
(paren
id|sb
comma
id|sbi
)paren
suffix:semicolon
id|J_ASSERT
c_func
(paren
id|list_empty
c_func
(paren
op_amp
id|sbi-&gt;s_orphan
)paren
)paren
suffix:semicolon
id|invalidate_bdev
c_func
(paren
id|sb-&gt;s_bdev
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sbi-&gt;journal_bdev
op_logical_and
id|sbi-&gt;journal_bdev
op_ne
id|sb-&gt;s_bdev
)paren
(brace
multiline_comment|/*&n;&t;&t; * Invalidate the journal device&squot;s buffers.  We don&squot;t want them&n;&t;&t; * floating about in memory - the physical journal device may&n;&t;&t; * hotswapped, and it breaks the `ro-after&squot; testing code.&n;&t;&t; */
id|fsync_no_super
c_func
(paren
id|sbi-&gt;journal_bdev
)paren
suffix:semicolon
id|invalidate_bdev
c_func
(paren
id|sbi-&gt;journal_bdev
comma
l_int|0
)paren
suffix:semicolon
id|ext3_blkdev_remove
c_func
(paren
id|sbi
)paren
suffix:semicolon
)brace
id|clear_ro_after
c_func
(paren
id|sb
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|variable|ext3_inode_cachep
r_static
id|kmem_cache_t
op_star
id|ext3_inode_cachep
suffix:semicolon
DECL|function|ext3_alloc_inode
r_static
r_struct
id|inode
op_star
id|ext3_alloc_inode
c_func
(paren
r_struct
id|super_block
op_star
id|sb
)paren
(brace
r_struct
id|ext3_inode_info
op_star
id|ei
suffix:semicolon
id|ei
op_assign
(paren
r_struct
id|ext3_inode_info
op_star
)paren
id|kmem_cache_alloc
c_func
(paren
id|ext3_inode_cachep
comma
id|SLAB_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ei
)paren
r_return
l_int|NULL
suffix:semicolon
r_return
op_amp
id|ei-&gt;vfs_inode
suffix:semicolon
)brace
DECL|function|ext3_destroy_inode
r_static
r_void
id|ext3_destroy_inode
c_func
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
id|kmem_cache_free
c_func
(paren
id|ext3_inode_cachep
comma
id|EXT3_I
c_func
(paren
id|inode
)paren
)paren
suffix:semicolon
)brace
DECL|function|init_once
r_static
r_void
id|init_once
c_func
(paren
r_void
op_star
id|foo
comma
id|kmem_cache_t
op_star
id|cachep
comma
r_int
r_int
id|flags
)paren
(brace
r_struct
id|ext3_inode_info
op_star
id|ei
op_assign
(paren
r_struct
id|ext3_inode_info
op_star
)paren
id|foo
suffix:semicolon
r_if
c_cond
(paren
(paren
id|flags
op_amp
(paren
id|SLAB_CTOR_VERIFY
op_or
id|SLAB_CTOR_CONSTRUCTOR
)paren
)paren
op_eq
id|SLAB_CTOR_CONSTRUCTOR
)paren
(brace
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|ei-&gt;i_orphan
)paren
suffix:semicolon
id|init_rwsem
c_func
(paren
op_amp
id|ei-&gt;truncate_sem
)paren
suffix:semicolon
id|inode_init_once
c_func
(paren
op_amp
id|ei-&gt;vfs_inode
)paren
suffix:semicolon
)brace
)brace
DECL|function|init_inodecache
r_static
r_int
id|init_inodecache
c_func
(paren
r_void
)paren
(brace
id|ext3_inode_cachep
op_assign
id|kmem_cache_create
c_func
(paren
l_string|&quot;ext3_inode_cache&quot;
comma
r_sizeof
(paren
r_struct
id|ext3_inode_info
)paren
comma
l_int|0
comma
id|SLAB_HWCACHE_ALIGN
comma
id|init_once
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ext3_inode_cachep
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|destroy_inodecache
r_static
r_void
id|destroy_inodecache
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|kmem_cache_destroy
c_func
(paren
id|ext3_inode_cachep
)paren
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ext3_inode_cache: not all structures were freed&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|variable|ext3_sops
r_static
r_struct
id|super_operations
id|ext3_sops
op_assign
(brace
id|alloc_inode
suffix:colon
id|ext3_alloc_inode
comma
id|destroy_inode
suffix:colon
id|ext3_destroy_inode
comma
id|read_inode
suffix:colon
id|ext3_read_inode
comma
multiline_comment|/* BKL held */
id|write_inode
suffix:colon
id|ext3_write_inode
comma
multiline_comment|/* BKL not held.  Don&squot;t need */
id|dirty_inode
suffix:colon
id|ext3_dirty_inode
comma
multiline_comment|/* BKL not held.  We take it */
id|put_inode
suffix:colon
id|ext3_put_inode
comma
multiline_comment|/* BKL not held.  Don&squot;t need */
id|delete_inode
suffix:colon
id|ext3_delete_inode
comma
multiline_comment|/* BKL not held.  We take it */
id|put_super
suffix:colon
id|ext3_put_super
comma
multiline_comment|/* BKL held */
id|write_super
suffix:colon
id|ext3_write_super
comma
multiline_comment|/* BKL not held. We take it. Needed? */
id|write_super_lockfs
suffix:colon
id|ext3_write_super_lockfs
comma
multiline_comment|/* BKL not held. Take it */
id|unlockfs
suffix:colon
id|ext3_unlockfs
comma
multiline_comment|/* BKL not held.  We take it */
id|statfs
suffix:colon
id|ext3_statfs
comma
multiline_comment|/* BKL held */
id|remount_fs
suffix:colon
id|ext3_remount
comma
multiline_comment|/* BKL held */
)brace
suffix:semicolon
DECL|function|want_value
r_static
r_int
id|want_value
c_func
(paren
r_char
op_star
id|value
comma
r_char
op_star
id|option
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|value
op_logical_or
op_logical_neg
op_star
id|value
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;EXT3-fs: the %s option needs an argument&bslash;n&quot;
comma
id|option
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|want_null_value
r_static
r_int
id|want_null_value
c_func
(paren
r_char
op_star
id|value
comma
r_char
op_star
id|option
)paren
(brace
r_if
c_cond
(paren
op_star
id|value
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;EXT3-fs: Invalid %s argument: %s&bslash;n&quot;
comma
id|option
comma
id|value
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|want_numeric
r_static
r_int
id|want_numeric
c_func
(paren
r_char
op_star
id|value
comma
r_char
op_star
id|option
comma
r_int
r_int
op_star
id|number
)paren
(brace
r_if
c_cond
(paren
id|want_value
c_func
(paren
id|value
comma
id|option
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
op_star
id|number
op_assign
id|simple_strtoul
c_func
(paren
id|value
comma
op_amp
id|value
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|want_null_value
c_func
(paren
id|value
comma
id|option
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * This function has been shamelessly adapted from the msdos fs&n; */
DECL|function|parse_options
r_static
r_int
id|parse_options
(paren
r_char
op_star
id|options
comma
r_int
r_int
op_star
id|sb_block
comma
r_struct
id|ext3_sb_info
op_star
id|sbi
comma
r_int
r_int
op_star
id|inum
comma
r_int
id|is_remount
)paren
(brace
r_int
r_int
op_star
id|mount_options
op_assign
op_amp
id|sbi-&gt;s_mount_opt
suffix:semicolon
id|uid_t
op_star
id|resuid
op_assign
op_amp
id|sbi-&gt;s_resuid
suffix:semicolon
id|gid_t
op_star
id|resgid
op_assign
op_amp
id|sbi-&gt;s_resgid
suffix:semicolon
r_char
op_star
id|this_char
suffix:semicolon
r_char
op_star
id|value
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|options
)paren
r_return
l_int|1
suffix:semicolon
r_while
c_loop
(paren
(paren
id|this_char
op_assign
id|strsep
(paren
op_amp
id|options
comma
l_string|&quot;,&quot;
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
op_star
id|this_char
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
(paren
id|value
op_assign
id|strchr
(paren
id|this_char
comma
l_char|&squot;=&squot;
)paren
)paren
op_ne
l_int|NULL
)paren
op_star
id|value
op_increment
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
(paren
id|this_char
comma
l_string|&quot;bsddf&quot;
)paren
)paren
id|clear_opt
(paren
op_star
id|mount_options
comma
id|MINIX_DF
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
(paren
id|this_char
comma
l_string|&quot;nouid32&quot;
)paren
)paren
(brace
id|set_opt
(paren
op_star
id|mount_options
comma
id|NO_UID32
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
(paren
id|this_char
comma
l_string|&quot;abort&quot;
)paren
)paren
id|set_opt
(paren
op_star
id|mount_options
comma
id|ABORT
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
(paren
id|this_char
comma
l_string|&quot;check&quot;
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|value
op_logical_or
op_logical_neg
op_star
id|value
op_logical_or
op_logical_neg
id|strcmp
(paren
id|value
comma
l_string|&quot;none&quot;
)paren
)paren
id|clear_opt
(paren
op_star
id|mount_options
comma
id|CHECK
)paren
suffix:semicolon
r_else
macro_line|#ifdef CONFIG_EXT3_CHECK
id|set_opt
(paren
op_star
id|mount_options
comma
id|CHECK
)paren
suffix:semicolon
macro_line|#else
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;EXT3 Check option not supported&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
(paren
id|this_char
comma
l_string|&quot;debug&quot;
)paren
)paren
id|set_opt
(paren
op_star
id|mount_options
comma
id|DEBUG
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
(paren
id|this_char
comma
l_string|&quot;errors&quot;
)paren
)paren
(brace
r_if
c_cond
(paren
id|want_value
c_func
(paren
id|value
comma
l_string|&quot;errors&quot;
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
(paren
id|value
comma
l_string|&quot;continue&quot;
)paren
)paren
(brace
id|clear_opt
(paren
op_star
id|mount_options
comma
id|ERRORS_RO
)paren
suffix:semicolon
id|clear_opt
(paren
op_star
id|mount_options
comma
id|ERRORS_PANIC
)paren
suffix:semicolon
id|set_opt
(paren
op_star
id|mount_options
comma
id|ERRORS_CONT
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
(paren
id|value
comma
l_string|&quot;remount-ro&quot;
)paren
)paren
(brace
id|clear_opt
(paren
op_star
id|mount_options
comma
id|ERRORS_CONT
)paren
suffix:semicolon
id|clear_opt
(paren
op_star
id|mount_options
comma
id|ERRORS_PANIC
)paren
suffix:semicolon
id|set_opt
(paren
op_star
id|mount_options
comma
id|ERRORS_RO
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
(paren
id|value
comma
l_string|&quot;panic&quot;
)paren
)paren
(brace
id|clear_opt
(paren
op_star
id|mount_options
comma
id|ERRORS_CONT
)paren
suffix:semicolon
id|clear_opt
(paren
op_star
id|mount_options
comma
id|ERRORS_RO
)paren
suffix:semicolon
id|set_opt
(paren
op_star
id|mount_options
comma
id|ERRORS_PANIC
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;EXT3-fs: Invalid errors option: %s&bslash;n&quot;
comma
id|value
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
(paren
id|this_char
comma
l_string|&quot;grpid&quot;
)paren
op_logical_or
op_logical_neg
id|strcmp
(paren
id|this_char
comma
l_string|&quot;bsdgroups&quot;
)paren
)paren
id|set_opt
(paren
op_star
id|mount_options
comma
id|GRPID
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
(paren
id|this_char
comma
l_string|&quot;minixdf&quot;
)paren
)paren
id|set_opt
(paren
op_star
id|mount_options
comma
id|MINIX_DF
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
(paren
id|this_char
comma
l_string|&quot;nocheck&quot;
)paren
)paren
id|clear_opt
(paren
op_star
id|mount_options
comma
id|CHECK
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
(paren
id|this_char
comma
l_string|&quot;nogrpid&quot;
)paren
op_logical_or
op_logical_neg
id|strcmp
(paren
id|this_char
comma
l_string|&quot;sysvgroups&quot;
)paren
)paren
id|clear_opt
(paren
op_star
id|mount_options
comma
id|GRPID
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
(paren
id|this_char
comma
l_string|&quot;resgid&quot;
)paren
)paren
(brace
r_int
r_int
id|v
suffix:semicolon
r_if
c_cond
(paren
id|want_numeric
c_func
(paren
id|value
comma
l_string|&quot;resgid&quot;
comma
op_amp
id|v
)paren
)paren
r_return
l_int|0
suffix:semicolon
op_star
id|resgid
op_assign
id|v
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
(paren
id|this_char
comma
l_string|&quot;resuid&quot;
)paren
)paren
(brace
r_int
r_int
id|v
suffix:semicolon
r_if
c_cond
(paren
id|want_numeric
c_func
(paren
id|value
comma
l_string|&quot;resuid&quot;
comma
op_amp
id|v
)paren
)paren
r_return
l_int|0
suffix:semicolon
op_star
id|resuid
op_assign
id|v
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
(paren
id|this_char
comma
l_string|&quot;sb&quot;
)paren
)paren
(brace
r_if
c_cond
(paren
id|want_numeric
c_func
(paren
id|value
comma
l_string|&quot;sb&quot;
comma
id|sb_block
)paren
)paren
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_JBD_DEBUG
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
(paren
id|this_char
comma
l_string|&quot;ro-after&quot;
)paren
)paren
(brace
r_int
r_int
id|v
suffix:semicolon
r_if
c_cond
(paren
id|want_numeric
c_func
(paren
id|value
comma
l_string|&quot;ro-after&quot;
comma
op_amp
id|v
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|ext3_ro_after
op_assign
id|v
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* Silently ignore the quota options */
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
(paren
id|this_char
comma
l_string|&quot;grpquota&quot;
)paren
op_logical_or
op_logical_neg
id|strcmp
(paren
id|this_char
comma
l_string|&quot;noquota&quot;
)paren
op_logical_or
op_logical_neg
id|strcmp
(paren
id|this_char
comma
l_string|&quot;quota&quot;
)paren
op_logical_or
op_logical_neg
id|strcmp
(paren
id|this_char
comma
l_string|&quot;usrquota&quot;
)paren
)paren
multiline_comment|/* Don&squot;t do anything ;-) */
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
(paren
id|this_char
comma
l_string|&quot;journal&quot;
)paren
)paren
(brace
multiline_comment|/* @@@ FIXME */
multiline_comment|/* Eventually we will want to be able to create&n;                           a journal file here.  For now, only allow the&n;                           user to specify an existing inode to be the&n;                           journal file. */
r_if
c_cond
(paren
id|is_remount
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;EXT3-fs: cannot specify &quot;
l_string|&quot;journal on remount&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|want_value
c_func
(paren
id|value
comma
l_string|&quot;journal&quot;
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
(paren
id|value
comma
l_string|&quot;update&quot;
)paren
)paren
id|set_opt
(paren
op_star
id|mount_options
comma
id|UPDATE_JOURNAL
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|want_numeric
c_func
(paren
id|value
comma
l_string|&quot;journal&quot;
comma
id|inum
)paren
)paren
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
(paren
id|this_char
comma
l_string|&quot;noload&quot;
)paren
)paren
id|set_opt
(paren
op_star
id|mount_options
comma
id|NOLOAD
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
(paren
id|this_char
comma
l_string|&quot;data&quot;
)paren
)paren
(brace
r_int
id|data_opt
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|want_value
c_func
(paren
id|value
comma
l_string|&quot;data&quot;
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
(paren
id|value
comma
l_string|&quot;journal&quot;
)paren
)paren
id|data_opt
op_assign
id|EXT3_MOUNT_JOURNAL_DATA
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
(paren
id|value
comma
l_string|&quot;ordered&quot;
)paren
)paren
id|data_opt
op_assign
id|EXT3_MOUNT_ORDERED_DATA
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
(paren
id|value
comma
l_string|&quot;writeback&quot;
)paren
)paren
id|data_opt
op_assign
id|EXT3_MOUNT_WRITEBACK_DATA
suffix:semicolon
r_else
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;EXT3-fs: Invalid data option: %s&bslash;n&quot;
comma
id|value
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|is_remount
)paren
(brace
r_if
c_cond
(paren
(paren
op_star
id|mount_options
op_amp
id|EXT3_MOUNT_DATA_FLAGS
)paren
op_ne
id|data_opt
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;EXT3-fs: cannot change data &quot;
l_string|&quot;mode on remount&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_else
(brace
op_star
id|mount_options
op_and_assign
op_complement
id|EXT3_MOUNT_DATA_FLAGS
suffix:semicolon
op_star
id|mount_options
op_or_assign
id|data_opt
suffix:semicolon
)brace
)brace
r_else
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;EXT3-fs: Unrecognized mount option %s&bslash;n&quot;
comma
id|this_char
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|ext3_setup_super
r_static
r_int
id|ext3_setup_super
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_struct
id|ext3_super_block
op_star
id|es
comma
r_int
id|read_only
)paren
(brace
r_struct
id|ext3_sb_info
op_star
id|sbi
op_assign
id|EXT3_SB
c_func
(paren
id|sb
)paren
suffix:semicolon
r_int
id|res
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|le32_to_cpu
c_func
(paren
id|es-&gt;s_rev_level
)paren
OG
id|EXT3_MAX_SUPP_REV
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;EXT3-fs warning: revision level too high, &quot;
l_string|&quot;forcing read-only mode&bslash;n&quot;
)paren
suffix:semicolon
id|res
op_assign
id|MS_RDONLY
suffix:semicolon
)brace
r_if
c_cond
(paren
id|read_only
)paren
r_return
id|res
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|sbi-&gt;s_mount_state
op_amp
id|EXT3_VALID_FS
)paren
)paren
id|printk
(paren
id|KERN_WARNING
l_string|&quot;EXT3-fs warning: mounting unchecked fs, &quot;
l_string|&quot;running e2fsck is recommended&bslash;n&quot;
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|sbi-&gt;s_mount_state
op_amp
id|EXT3_ERROR_FS
)paren
)paren
id|printk
(paren
id|KERN_WARNING
l_string|&quot;EXT3-fs warning: mounting fs with errors, &quot;
l_string|&quot;running e2fsck is recommended&bslash;n&quot;
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|__s16
)paren
id|le16_to_cpu
c_func
(paren
id|es-&gt;s_max_mnt_count
)paren
op_ge
l_int|0
op_logical_and
id|le16_to_cpu
c_func
(paren
id|es-&gt;s_mnt_count
)paren
op_ge
(paren
r_int
r_int
)paren
(paren
id|__s16
)paren
id|le16_to_cpu
c_func
(paren
id|es-&gt;s_max_mnt_count
)paren
)paren
id|printk
(paren
id|KERN_WARNING
l_string|&quot;EXT3-fs warning: maximal mount count reached, &quot;
l_string|&quot;running e2fsck is recommended&bslash;n&quot;
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|le32_to_cpu
c_func
(paren
id|es-&gt;s_checkinterval
)paren
op_logical_and
(paren
id|le32_to_cpu
c_func
(paren
id|es-&gt;s_lastcheck
)paren
op_plus
id|le32_to_cpu
c_func
(paren
id|es-&gt;s_checkinterval
)paren
op_le
id|CURRENT_TIME
)paren
)paren
id|printk
(paren
id|KERN_WARNING
l_string|&quot;EXT3-fs warning: checktime reached, &quot;
l_string|&quot;running e2fsck is recommended&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#if 0
multiline_comment|/* @@@ We _will_ want to clear the valid bit if we find&n;                   inconsistencies, to force a fsck at reboot.  But for&n;                   a plain journaled filesystem we can keep it set as&n;                   valid forever! :) */
id|es-&gt;s_state
op_assign
id|cpu_to_le16
c_func
(paren
id|le16_to_cpu
c_func
(paren
id|es-&gt;s_state
)paren
op_amp
op_complement
id|EXT3_VALID_FS
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
(paren
id|__s16
)paren
id|le16_to_cpu
c_func
(paren
id|es-&gt;s_max_mnt_count
)paren
)paren
id|es-&gt;s_max_mnt_count
op_assign
(paren
id|__s16
)paren
id|cpu_to_le16
c_func
(paren
id|EXT3_DFL_MAX_MNT_COUNT
)paren
suffix:semicolon
id|es-&gt;s_mnt_count
op_assign
id|cpu_to_le16
c_func
(paren
id|le16_to_cpu
c_func
(paren
id|es-&gt;s_mnt_count
)paren
op_plus
l_int|1
)paren
suffix:semicolon
id|es-&gt;s_mtime
op_assign
id|cpu_to_le32
c_func
(paren
id|CURRENT_TIME
)paren
suffix:semicolon
id|ext3_update_dynamic_rev
c_func
(paren
id|sb
)paren
suffix:semicolon
id|EXT3_SET_INCOMPAT_FEATURE
c_func
(paren
id|sb
comma
id|EXT3_FEATURE_INCOMPAT_RECOVER
)paren
suffix:semicolon
id|ext3_commit_super
(paren
id|sb
comma
id|es
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|test_opt
(paren
id|sb
comma
id|DEBUG
)paren
)paren
id|printk
(paren
id|KERN_INFO
l_string|&quot;[EXT3 FS %s, %s, bs=%lu, gc=%lu, &quot;
l_string|&quot;bpg=%lu, ipg=%lu, mo=%04lx]&bslash;n&quot;
comma
id|EXT3FS_VERSION
comma
id|EXT3FS_DATE
comma
id|sb-&gt;s_blocksize
comma
id|sbi-&gt;s_groups_count
comma
id|EXT3_BLOCKS_PER_GROUP
c_func
(paren
id|sb
)paren
comma
id|EXT3_INODES_PER_GROUP
c_func
(paren
id|sb
)paren
comma
id|sbi-&gt;s_mount_opt
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;EXT3 FS &quot;
id|EXT3FS_VERSION
l_string|&quot;, &quot;
id|EXT3FS_DATE
l_string|&quot; on %s, &quot;
comma
id|sb-&gt;s_id
)paren
suffix:semicolon
r_if
c_cond
(paren
id|EXT3_SB
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|s_journal-&gt;j_inode
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;external journal on %s&bslash;n&quot;
comma
id|bdevname
c_func
(paren
id|EXT3_SB
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|s_journal-&gt;j_dev
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;internal journal&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_EXT3_CHECK
r_if
c_cond
(paren
id|test_opt
(paren
id|sb
comma
id|CHECK
)paren
)paren
(brace
id|ext3_check_blocks_bitmap
(paren
id|sb
)paren
suffix:semicolon
id|ext3_check_inodes_bitmap
(paren
id|sb
)paren
suffix:semicolon
)brace
macro_line|#endif
id|setup_ro_after
c_func
(paren
id|sb
)paren
suffix:semicolon
r_return
id|res
suffix:semicolon
)brace
DECL|function|ext3_check_descriptors
r_static
r_int
id|ext3_check_descriptors
(paren
r_struct
id|super_block
op_star
id|sb
)paren
(brace
r_struct
id|ext3_sb_info
op_star
id|sbi
op_assign
id|EXT3_SB
c_func
(paren
id|sb
)paren
suffix:semicolon
r_int
r_int
id|block
op_assign
id|le32_to_cpu
c_func
(paren
id|sbi-&gt;s_es-&gt;s_first_data_block
)paren
suffix:semicolon
r_struct
id|ext3_group_desc
op_star
id|gdp
op_assign
l_int|NULL
suffix:semicolon
r_int
id|desc_block
op_assign
l_int|0
suffix:semicolon
r_int
id|i
suffix:semicolon
id|ext3_debug
(paren
l_string|&quot;Checking group descriptors&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|sbi-&gt;s_groups_count
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|i
op_mod
id|EXT3_DESC_PER_BLOCK
c_func
(paren
id|sb
)paren
)paren
op_eq
l_int|0
)paren
id|gdp
op_assign
(paren
r_struct
id|ext3_group_desc
op_star
)paren
id|sbi-&gt;s_group_desc
(braket
id|desc_block
op_increment
)braket
op_member_access_from_pointer
id|b_data
suffix:semicolon
r_if
c_cond
(paren
id|le32_to_cpu
c_func
(paren
id|gdp-&gt;bg_block_bitmap
)paren
OL
id|block
op_logical_or
id|le32_to_cpu
c_func
(paren
id|gdp-&gt;bg_block_bitmap
)paren
op_ge
id|block
op_plus
id|EXT3_BLOCKS_PER_GROUP
c_func
(paren
id|sb
)paren
)paren
(brace
id|ext3_error
(paren
id|sb
comma
l_string|&quot;ext3_check_descriptors&quot;
comma
l_string|&quot;Block bitmap for group %d&quot;
l_string|&quot; not in group (block %lu)!&quot;
comma
id|i
comma
(paren
r_int
r_int
)paren
id|le32_to_cpu
c_func
(paren
id|gdp-&gt;bg_block_bitmap
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|le32_to_cpu
c_func
(paren
id|gdp-&gt;bg_inode_bitmap
)paren
OL
id|block
op_logical_or
id|le32_to_cpu
c_func
(paren
id|gdp-&gt;bg_inode_bitmap
)paren
op_ge
id|block
op_plus
id|EXT3_BLOCKS_PER_GROUP
c_func
(paren
id|sb
)paren
)paren
(brace
id|ext3_error
(paren
id|sb
comma
l_string|&quot;ext3_check_descriptors&quot;
comma
l_string|&quot;Inode bitmap for group %d&quot;
l_string|&quot; not in group (block %lu)!&quot;
comma
id|i
comma
(paren
r_int
r_int
)paren
id|le32_to_cpu
c_func
(paren
id|gdp-&gt;bg_inode_bitmap
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|le32_to_cpu
c_func
(paren
id|gdp-&gt;bg_inode_table
)paren
OL
id|block
op_logical_or
id|le32_to_cpu
c_func
(paren
id|gdp-&gt;bg_inode_table
)paren
op_plus
id|sbi-&gt;s_itb_per_group
op_ge
id|block
op_plus
id|EXT3_BLOCKS_PER_GROUP
c_func
(paren
id|sb
)paren
)paren
(brace
id|ext3_error
(paren
id|sb
comma
l_string|&quot;ext3_check_descriptors&quot;
comma
l_string|&quot;Inode table for group %d&quot;
l_string|&quot; not in group (block %lu)!&quot;
comma
id|i
comma
(paren
r_int
r_int
)paren
id|le32_to_cpu
c_func
(paren
id|gdp-&gt;bg_inode_table
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|block
op_add_assign
id|EXT3_BLOCKS_PER_GROUP
c_func
(paren
id|sb
)paren
suffix:semicolon
id|gdp
op_increment
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* ext3_orphan_cleanup() walks a singly-linked list of inodes (starting at&n; * the superblock) which were deleted from all directories, but held open by&n; * a process at the time of a crash.  We walk the list and try to delete these&n; * inodes at recovery time (only with a read-write filesystem).&n; *&n; * In order to keep the orphan inode chain consistent during traversal (in&n; * case of crash during recovery), we link each inode into the superblock&n; * orphan list_head and handle it the same way as an inode deletion during&n; * normal operation (which journals the operations for us).&n; *&n; * We only do an iget() and an iput() on each inode, which is very safe if we&n; * accidentally point at an in-use or already deleted inode.  The worst that&n; * can happen in this case is that we get a &quot;bit already cleared&quot; message from&n; * ext3_free_inode().  The only reason we would point at a wrong inode is if&n; * e2fsck was run on this filesystem, and it must have already done the orphan&n; * inode cleanup for us, so we can safely abort without any further action.&n; */
DECL|function|ext3_orphan_cleanup
r_static
r_void
id|ext3_orphan_cleanup
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_struct
id|ext3_super_block
op_star
id|es
)paren
(brace
r_int
r_int
id|s_flags
op_assign
id|sb-&gt;s_flags
suffix:semicolon
r_int
id|nr_orphans
op_assign
l_int|0
comma
id|nr_truncates
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|es-&gt;s_last_orphan
)paren
(brace
id|jbd_debug
c_func
(paren
l_int|4
comma
l_string|&quot;no orphan inodes to clean up&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|s_flags
op_amp
id|MS_RDONLY
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;EXT3-fs: %s: orphan cleanup on readonly fs&bslash;n&quot;
comma
id|sb-&gt;s_id
)paren
suffix:semicolon
id|sb-&gt;s_flags
op_and_assign
op_complement
id|MS_RDONLY
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sb-&gt;u.ext3_sb.s_mount_state
op_amp
id|EXT3_ERROR_FS
)paren
(brace
r_if
c_cond
(paren
id|es-&gt;s_last_orphan
)paren
id|jbd_debug
c_func
(paren
l_int|1
comma
l_string|&quot;Errors on filesystem, &quot;
l_string|&quot;clearing orphan list.&bslash;n&quot;
)paren
suffix:semicolon
id|es-&gt;s_last_orphan
op_assign
l_int|0
suffix:semicolon
id|jbd_debug
c_func
(paren
l_int|1
comma
l_string|&quot;Skipping orphan recovery on fs with errors.&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_while
c_loop
(paren
id|es-&gt;s_last_orphan
)paren
(brace
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|inode
op_assign
id|ext3_orphan_get
c_func
(paren
id|sb
comma
id|le32_to_cpu
c_func
(paren
id|es-&gt;s_last_orphan
)paren
)paren
)paren
)paren
(brace
id|es-&gt;s_last_orphan
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
id|list_add
c_func
(paren
op_amp
id|EXT3_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_orphan
comma
op_amp
id|EXT3_SB
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|s_orphan
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inode-&gt;i_nlink
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
id|__FUNCTION__
l_string|&quot;: truncating inode %ld to %Ld bytes&bslash;n&quot;
comma
id|inode-&gt;i_ino
comma
id|inode-&gt;i_size
)paren
suffix:semicolon
id|jbd_debug
c_func
(paren
l_int|2
comma
l_string|&quot;truncating inode %ld to %Ld bytes&bslash;n&quot;
comma
id|inode-&gt;i_ino
comma
id|inode-&gt;i_size
)paren
suffix:semicolon
id|ext3_truncate
c_func
(paren
id|inode
)paren
suffix:semicolon
id|nr_truncates
op_increment
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
id|__FUNCTION__
l_string|&quot;: deleting unreferenced inode %ld&bslash;n&quot;
comma
id|inode-&gt;i_ino
)paren
suffix:semicolon
id|jbd_debug
c_func
(paren
l_int|2
comma
l_string|&quot;deleting unreferenced inode %ld&bslash;n&quot;
comma
id|inode-&gt;i_ino
)paren
suffix:semicolon
id|nr_orphans
op_increment
suffix:semicolon
)brace
id|iput
c_func
(paren
id|inode
)paren
suffix:semicolon
multiline_comment|/* The delete magic happens here! */
)brace
DECL|macro|PLURAL
mdefine_line|#define PLURAL(x) (x), ((x)==1) ? &quot;&quot; : &quot;s&quot;
r_if
c_cond
(paren
id|nr_orphans
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;EXT3-fs: %s: %d orphan inode%s deleted&bslash;n&quot;
comma
id|sb-&gt;s_id
comma
id|PLURAL
c_func
(paren
id|nr_orphans
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nr_truncates
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;EXT3-fs: %s: %d truncate%s cleaned up&bslash;n&quot;
comma
id|sb-&gt;s_id
comma
id|PLURAL
c_func
(paren
id|nr_truncates
)paren
)paren
suffix:semicolon
id|sb-&gt;s_flags
op_assign
id|s_flags
suffix:semicolon
multiline_comment|/* Restore MS_RDONLY status */
)brace
DECL|macro|log2
mdefine_line|#define log2(n) ffz(~(n))
multiline_comment|/*&n; * Maximal file size.  There is a direct, and {,double-,triple-}indirect&n; * block limit, and also a limit of (2^32 - 1) 512-byte sectors in i_blocks.&n; * We need to be 1 filesystem block less than the 2^32 sector limit.&n; */
DECL|function|ext3_max_size
r_static
id|loff_t
id|ext3_max_size
c_func
(paren
r_int
id|bits
)paren
(brace
id|loff_t
id|res
op_assign
id|EXT3_NDIR_BLOCKS
suffix:semicolon
id|res
op_add_assign
l_int|1LL
op_lshift
(paren
id|bits
op_minus
l_int|2
)paren
suffix:semicolon
id|res
op_add_assign
l_int|1LL
op_lshift
(paren
l_int|2
op_star
(paren
id|bits
op_minus
l_int|2
)paren
)paren
suffix:semicolon
id|res
op_add_assign
l_int|1LL
op_lshift
(paren
l_int|3
op_star
(paren
id|bits
op_minus
l_int|2
)paren
)paren
suffix:semicolon
id|res
op_lshift_assign
id|bits
suffix:semicolon
r_if
c_cond
(paren
id|res
OG
(paren
l_int|512LL
op_lshift
l_int|32
)paren
op_minus
(paren
l_int|1
op_lshift
id|bits
)paren
)paren
id|res
op_assign
(paren
l_int|512LL
op_lshift
l_int|32
)paren
op_minus
(paren
l_int|1
op_lshift
id|bits
)paren
suffix:semicolon
r_return
id|res
suffix:semicolon
)brace
DECL|function|ext3_fill_super
r_static
r_int
id|ext3_fill_super
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_void
op_star
id|data
comma
r_int
id|silent
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
r_struct
id|ext3_super_block
op_star
id|es
op_assign
l_int|0
suffix:semicolon
r_struct
id|ext3_sb_info
op_star
id|sbi
op_assign
id|EXT3_SB
c_func
(paren
id|sb
)paren
suffix:semicolon
r_int
r_int
id|sb_block
op_assign
l_int|1
suffix:semicolon
r_int
r_int
id|logic_sb_block
op_assign
l_int|1
suffix:semicolon
r_int
r_int
id|offset
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|journal_inum
op_assign
l_int|0
suffix:semicolon
r_int
id|blocksize
suffix:semicolon
r_int
id|hblock
suffix:semicolon
r_int
id|db_count
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|needs_recovery
suffix:semicolon
macro_line|#ifdef CONFIG_JBD_DEBUG
id|ext3_ro_after
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; * See what the current blocksize for the device is, and&n;&t; * use that as the blocksize.  Otherwise (or if the blocksize&n;&t; * is smaller than the default) use the default.&n;&t; * This is important for devices that have a hardware&n;&t; * sectorsize that is larger than the default.&n;&t; */
id|sbi-&gt;s_mount_opt
op_assign
l_int|0
suffix:semicolon
id|sbi-&gt;s_resuid
op_assign
id|EXT3_DEF_RESUID
suffix:semicolon
id|sbi-&gt;s_resgid
op_assign
id|EXT3_DEF_RESGID
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|parse_options
(paren
(paren
r_char
op_star
)paren
id|data
comma
op_amp
id|sb_block
comma
id|sbi
comma
op_amp
id|journal_inum
comma
l_int|0
)paren
)paren
r_goto
id|out_fail
suffix:semicolon
id|blocksize
op_assign
id|sb_min_blocksize
c_func
(paren
id|sb
comma
id|EXT3_MIN_BLOCK_SIZE
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * The ext3 superblock will not be buffer aligned for other than 1kB&n;&t; * block sizes.  We need to calculate the offset from buffer start.&n;&t; */
r_if
c_cond
(paren
id|blocksize
op_ne
id|EXT3_MIN_BLOCK_SIZE
)paren
(brace
id|logic_sb_block
op_assign
(paren
id|sb_block
op_star
id|EXT3_MIN_BLOCK_SIZE
)paren
op_div
id|blocksize
suffix:semicolon
id|offset
op_assign
(paren
id|sb_block
op_star
id|EXT3_MIN_BLOCK_SIZE
)paren
op_mod
id|blocksize
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|bh
op_assign
id|sb_bread
c_func
(paren
id|sb
comma
id|logic_sb_block
)paren
)paren
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;EXT3-fs: unable to read superblock&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|out_fail
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Note: s_es must be initialized as soon as possible because&n;&t; *       some ext3 macro-instructions depend on its value&n;&t; */
id|es
op_assign
(paren
r_struct
id|ext3_super_block
op_star
)paren
(paren
(paren
(paren
r_char
op_star
)paren
id|bh-&gt;b_data
)paren
op_plus
id|offset
)paren
suffix:semicolon
id|sbi-&gt;s_es
op_assign
id|es
suffix:semicolon
id|sb-&gt;s_magic
op_assign
id|le16_to_cpu
c_func
(paren
id|es-&gt;s_magic
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sb-&gt;s_magic
op_ne
id|EXT3_SUPER_MAGIC
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|silent
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;VFS: Can&squot;t find ext3 filesystem on dev %s.&bslash;n&quot;
comma
id|sb-&gt;s_id
)paren
suffix:semicolon
r_goto
id|failed_mount
suffix:semicolon
)brace
r_if
c_cond
(paren
id|le32_to_cpu
c_func
(paren
id|es-&gt;s_rev_level
)paren
op_eq
id|EXT3_GOOD_OLD_REV
op_logical_and
(paren
id|EXT3_HAS_COMPAT_FEATURE
c_func
(paren
id|sb
comma
op_complement
l_int|0U
)paren
op_logical_or
id|EXT3_HAS_RO_COMPAT_FEATURE
c_func
(paren
id|sb
comma
op_complement
l_int|0U
)paren
op_logical_or
id|EXT3_HAS_INCOMPAT_FEATURE
c_func
(paren
id|sb
comma
op_complement
l_int|0U
)paren
)paren
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;EXT3-fs warning: feature flags set on rev 0 fs, &quot;
l_string|&quot;running e2fsck is recommended&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Check feature flags regardless of the revision level, since we&n;&t; * previously didn&squot;t change the revision level when setting the flags,&n;&t; * so there is a chance incompat flags are set on a rev 0 filesystem.&n;&t; */
r_if
c_cond
(paren
(paren
id|i
op_assign
id|EXT3_HAS_INCOMPAT_FEATURE
c_func
(paren
id|sb
comma
op_complement
id|EXT3_FEATURE_INCOMPAT_SUPP
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;EXT3-fs: %s: couldn&squot;t mount because of &quot;
l_string|&quot;unsupported optional features (%x).&bslash;n&quot;
comma
id|sb-&gt;s_id
comma
id|i
)paren
suffix:semicolon
r_goto
id|failed_mount
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|sb-&gt;s_flags
op_amp
id|MS_RDONLY
)paren
op_logical_and
(paren
id|i
op_assign
id|EXT3_HAS_RO_COMPAT_FEATURE
c_func
(paren
id|sb
comma
op_complement
id|EXT3_FEATURE_RO_COMPAT_SUPP
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;EXT3-fs: %s: couldn&squot;t mount RDWR because of &quot;
l_string|&quot;unsupported optional features (%x).&bslash;n&quot;
comma
id|sb-&gt;s_id
comma
id|i
)paren
suffix:semicolon
r_goto
id|failed_mount
suffix:semicolon
)brace
id|blocksize
op_assign
id|BLOCK_SIZE
op_lshift
id|le32_to_cpu
c_func
(paren
id|es-&gt;s_log_block_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|blocksize
template_param
id|EXT3_MAX_BLOCK_SIZE
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;EXT3-fs: Unsupported filesystem blocksize %d on %s.&bslash;n&quot;
comma
id|blocksize
comma
id|sb-&gt;s_id
)paren
suffix:semicolon
r_goto
id|failed_mount
suffix:semicolon
)brace
id|sb-&gt;s_maxbytes
op_assign
id|ext3_max_size
c_func
(paren
id|sb-&gt;s_blocksize_bits
)paren
suffix:semicolon
id|hblock
op_assign
id|bdev_hardsect_size
c_func
(paren
id|sb-&gt;s_bdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sb-&gt;s_blocksize
op_ne
id|blocksize
)paren
(brace
multiline_comment|/*&n;&t;&t; * Make sure the blocksize for the filesystem is larger&n;&t;&t; * than the hardware sectorsize for the machine.&n;&t;&t; */
r_if
c_cond
(paren
id|blocksize
OL
id|hblock
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;EXT3-fs: blocksize %d too small for &quot;
l_string|&quot;device blocksize %d.&bslash;n&quot;
comma
id|blocksize
comma
id|hblock
)paren
suffix:semicolon
r_goto
id|failed_mount
suffix:semicolon
)brace
id|brelse
(paren
id|bh
)paren
suffix:semicolon
id|sb_set_blocksize
c_func
(paren
id|sb
comma
id|blocksize
)paren
suffix:semicolon
id|logic_sb_block
op_assign
(paren
id|sb_block
op_star
id|EXT3_MIN_BLOCK_SIZE
)paren
op_div
id|blocksize
suffix:semicolon
id|offset
op_assign
(paren
id|sb_block
op_star
id|EXT3_MIN_BLOCK_SIZE
)paren
op_mod
id|blocksize
suffix:semicolon
id|bh
op_assign
id|sb_bread
c_func
(paren
id|sb
comma
id|logic_sb_block
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bh
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;EXT3-fs: Can&squot;t read superblock on 2nd try.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|es
op_assign
(paren
r_struct
id|ext3_super_block
op_star
)paren
(paren
(paren
(paren
r_char
op_star
)paren
id|bh-&gt;b_data
)paren
op_plus
id|offset
)paren
suffix:semicolon
id|sbi-&gt;s_es
op_assign
id|es
suffix:semicolon
r_if
c_cond
(paren
id|es-&gt;s_magic
op_ne
id|le16_to_cpu
c_func
(paren
id|EXT3_SUPER_MAGIC
)paren
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;EXT3-fs: Magic mismatch, very weird !&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|failed_mount
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|le32_to_cpu
c_func
(paren
id|es-&gt;s_rev_level
)paren
op_eq
id|EXT3_GOOD_OLD_REV
)paren
(brace
id|sbi-&gt;s_inode_size
op_assign
id|EXT3_GOOD_OLD_INODE_SIZE
suffix:semicolon
id|sbi-&gt;s_first_ino
op_assign
id|EXT3_GOOD_OLD_FIRST_INO
suffix:semicolon
)brace
r_else
(brace
id|sbi-&gt;s_inode_size
op_assign
id|le16_to_cpu
c_func
(paren
id|es-&gt;s_inode_size
)paren
suffix:semicolon
id|sbi-&gt;s_first_ino
op_assign
id|le32_to_cpu
c_func
(paren
id|es-&gt;s_first_ino
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sbi-&gt;s_inode_size
op_ne
id|EXT3_GOOD_OLD_INODE_SIZE
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;EXT3-fs: unsupported inode size: %d&bslash;n&quot;
comma
id|sbi-&gt;s_inode_size
)paren
suffix:semicolon
r_goto
id|failed_mount
suffix:semicolon
)brace
)brace
id|sbi-&gt;s_frag_size
op_assign
id|EXT3_MIN_FRAG_SIZE
op_lshift
id|le32_to_cpu
c_func
(paren
id|es-&gt;s_log_frag_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|blocksize
op_ne
id|sbi-&gt;s_frag_size
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;EXT3-fs: fragsize %lu != blocksize %u (unsupported)&bslash;n&quot;
comma
id|sbi-&gt;s_frag_size
comma
id|blocksize
)paren
suffix:semicolon
r_goto
id|failed_mount
suffix:semicolon
)brace
id|sbi-&gt;s_frags_per_block
op_assign
l_int|1
suffix:semicolon
id|sbi-&gt;s_blocks_per_group
op_assign
id|le32_to_cpu
c_func
(paren
id|es-&gt;s_blocks_per_group
)paren
suffix:semicolon
id|sbi-&gt;s_frags_per_group
op_assign
id|le32_to_cpu
c_func
(paren
id|es-&gt;s_frags_per_group
)paren
suffix:semicolon
id|sbi-&gt;s_inodes_per_group
op_assign
id|le32_to_cpu
c_func
(paren
id|es-&gt;s_inodes_per_group
)paren
suffix:semicolon
id|sbi-&gt;s_inodes_per_block
op_assign
id|blocksize
op_div
id|EXT3_INODE_SIZE
c_func
(paren
id|sb
)paren
suffix:semicolon
id|sbi-&gt;s_itb_per_group
op_assign
id|sbi-&gt;s_inodes_per_group
op_div
id|sbi-&gt;s_inodes_per_block
suffix:semicolon
id|sbi-&gt;s_desc_per_block
op_assign
id|blocksize
op_div
r_sizeof
(paren
r_struct
id|ext3_group_desc
)paren
suffix:semicolon
id|sbi-&gt;s_sbh
op_assign
id|bh
suffix:semicolon
r_if
c_cond
(paren
id|sbi-&gt;s_resuid
op_eq
id|EXT3_DEF_RESUID
)paren
id|sbi-&gt;s_resuid
op_assign
id|le16_to_cpu
c_func
(paren
id|es-&gt;s_def_resuid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sbi-&gt;s_resgid
op_eq
id|EXT3_DEF_RESGID
)paren
id|sbi-&gt;s_resgid
op_assign
id|le16_to_cpu
c_func
(paren
id|es-&gt;s_def_resgid
)paren
suffix:semicolon
id|sbi-&gt;s_mount_state
op_assign
id|le16_to_cpu
c_func
(paren
id|es-&gt;s_state
)paren
suffix:semicolon
id|sbi-&gt;s_addr_per_block_bits
op_assign
id|log2
c_func
(paren
id|EXT3_ADDR_PER_BLOCK
c_func
(paren
id|sb
)paren
)paren
suffix:semicolon
id|sbi-&gt;s_desc_per_block_bits
op_assign
id|log2
c_func
(paren
id|EXT3_DESC_PER_BLOCK
c_func
(paren
id|sb
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sbi-&gt;s_blocks_per_group
OG
id|blocksize
op_star
l_int|8
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;EXT3-fs: #blocks per group too big: %lu&bslash;n&quot;
comma
id|sbi-&gt;s_blocks_per_group
)paren
suffix:semicolon
r_goto
id|failed_mount
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sbi-&gt;s_frags_per_group
OG
id|blocksize
op_star
l_int|8
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;EXT3-fs: #fragments per group too big: %lu&bslash;n&quot;
comma
id|sbi-&gt;s_frags_per_group
)paren
suffix:semicolon
r_goto
id|failed_mount
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sbi-&gt;s_inodes_per_group
OG
id|blocksize
op_star
l_int|8
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;EXT3-fs: #inodes per group too big: %lu&bslash;n&quot;
comma
id|sbi-&gt;s_inodes_per_group
)paren
suffix:semicolon
r_goto
id|failed_mount
suffix:semicolon
)brace
id|sbi-&gt;s_groups_count
op_assign
(paren
id|le32_to_cpu
c_func
(paren
id|es-&gt;s_blocks_count
)paren
op_minus
id|le32_to_cpu
c_func
(paren
id|es-&gt;s_first_data_block
)paren
op_plus
id|EXT3_BLOCKS_PER_GROUP
c_func
(paren
id|sb
)paren
op_minus
l_int|1
)paren
op_div
id|EXT3_BLOCKS_PER_GROUP
c_func
(paren
id|sb
)paren
suffix:semicolon
id|db_count
op_assign
(paren
id|sbi-&gt;s_groups_count
op_plus
id|EXT3_DESC_PER_BLOCK
c_func
(paren
id|sb
)paren
op_minus
l_int|1
)paren
op_div
id|EXT3_DESC_PER_BLOCK
c_func
(paren
id|sb
)paren
suffix:semicolon
id|sbi-&gt;s_group_desc
op_assign
id|kmalloc
c_func
(paren
id|db_count
op_star
r_sizeof
(paren
r_struct
id|buffer_head
op_star
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sbi-&gt;s_group_desc
op_eq
l_int|NULL
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;EXT3-fs: not enough memory&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|failed_mount
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|db_count
suffix:semicolon
id|i
op_increment
)paren
(brace
id|sbi-&gt;s_group_desc
(braket
id|i
)braket
op_assign
id|sb_bread
c_func
(paren
id|sb
comma
id|logic_sb_block
op_plus
id|i
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sbi-&gt;s_group_desc
(braket
id|i
)braket
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;EXT3-fs: &quot;
l_string|&quot;can&squot;t read group descriptor %d&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
id|db_count
op_assign
id|i
suffix:semicolon
r_goto
id|failed_mount2
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|ext3_check_descriptors
(paren
id|sb
)paren
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;EXT3-fs: group descriptors corrupted !&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|failed_mount2
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|EXT3_MAX_GROUP_LOADED
suffix:semicolon
id|i
op_increment
)paren
(brace
id|sbi-&gt;s_inode_bitmap_number
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
id|sbi-&gt;s_inode_bitmap
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
id|sbi-&gt;s_block_bitmap_number
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
id|sbi-&gt;s_block_bitmap
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
id|sbi-&gt;s_loaded_inode_bitmaps
op_assign
l_int|0
suffix:semicolon
id|sbi-&gt;s_loaded_block_bitmaps
op_assign
l_int|0
suffix:semicolon
id|sbi-&gt;s_gdb_count
op_assign
id|db_count
suffix:semicolon
multiline_comment|/*&n;&t; * set up enough so that it can read an inode&n;&t; */
id|sb-&gt;s_op
op_assign
op_amp
id|ext3_sops
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|sbi-&gt;s_orphan
)paren
suffix:semicolon
multiline_comment|/* unlinked but open files */
id|sb-&gt;s_root
op_assign
l_int|0
suffix:semicolon
id|needs_recovery
op_assign
(paren
id|es-&gt;s_last_orphan
op_ne
l_int|0
op_logical_or
id|EXT3_HAS_INCOMPAT_FEATURE
c_func
(paren
id|sb
comma
id|EXT3_FEATURE_INCOMPAT_RECOVER
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * The first inode we look at is the journal inode.  Don&squot;t try&n;&t; * root first: it may be modified in the journal!&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|test_opt
c_func
(paren
id|sb
comma
id|NOLOAD
)paren
op_logical_and
id|EXT3_HAS_COMPAT_FEATURE
c_func
(paren
id|sb
comma
id|EXT3_FEATURE_COMPAT_HAS_JOURNAL
)paren
)paren
(brace
r_if
c_cond
(paren
id|ext3_load_journal
c_func
(paren
id|sb
comma
id|es
)paren
)paren
r_goto
id|failed_mount2
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|journal_inum
)paren
(brace
r_if
c_cond
(paren
id|ext3_create_journal
c_func
(paren
id|sb
comma
id|es
comma
id|journal_inum
)paren
)paren
r_goto
id|failed_mount2
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
id|silent
)paren
id|printk
(paren
id|KERN_ERR
l_string|&quot;ext3: No journal on filesystem on %s&bslash;n&quot;
comma
id|sb-&gt;s_id
)paren
suffix:semicolon
r_goto
id|failed_mount2
suffix:semicolon
)brace
multiline_comment|/* We have now updated the journal if required, so we can&n;&t; * validate the data journaling mode. */
r_switch
c_cond
(paren
id|test_opt
c_func
(paren
id|sb
comma
id|DATA_FLAGS
)paren
)paren
(brace
r_case
l_int|0
suffix:colon
multiline_comment|/* No mode set, assume a default based on the journal&n;                   capabilities: ORDERED_DATA if the journal can&n;                   cope, else JOURNAL_DATA */
r_if
c_cond
(paren
id|journal_check_available_features
(paren
id|sbi-&gt;s_journal
comma
l_int|0
comma
l_int|0
comma
id|JFS_FEATURE_INCOMPAT_REVOKE
)paren
)paren
id|set_opt
c_func
(paren
id|sbi-&gt;s_mount_opt
comma
id|ORDERED_DATA
)paren
suffix:semicolon
r_else
id|set_opt
c_func
(paren
id|sbi-&gt;s_mount_opt
comma
id|JOURNAL_DATA
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|EXT3_MOUNT_ORDERED_DATA
suffix:colon
r_case
id|EXT3_MOUNT_WRITEBACK_DATA
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|journal_check_available_features
(paren
id|sbi-&gt;s_journal
comma
l_int|0
comma
l_int|0
comma
id|JFS_FEATURE_INCOMPAT_REVOKE
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;EXT3-fs: Journal does not support &quot;
l_string|&quot;requested data journaling mode&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|failed_mount3
suffix:semicolon
)brace
r_default
suffix:colon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * The journal_load will have done any necessary log recovery,&n;&t; * so we can safely mount the rest of the filesystem now.&n;&t; */
id|sb-&gt;s_root
op_assign
id|d_alloc_root
c_func
(paren
id|iget
c_func
(paren
id|sb
comma
id|EXT3_ROOT_INO
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sb-&gt;s_root
op_logical_or
op_logical_neg
id|S_ISDIR
c_func
(paren
id|sb-&gt;s_root-&gt;d_inode-&gt;i_mode
)paren
op_logical_or
op_logical_neg
id|sb-&gt;s_root-&gt;d_inode-&gt;i_blocks
op_logical_or
op_logical_neg
id|sb-&gt;s_root-&gt;d_inode-&gt;i_size
)paren
(brace
r_if
c_cond
(paren
id|sb-&gt;s_root
)paren
(brace
id|dput
c_func
(paren
id|sb-&gt;s_root
)paren
suffix:semicolon
id|sb-&gt;s_root
op_assign
l_int|NULL
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;EXT3-fs: corrupt root inode, run e2fsck&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;EXT3-fs: get root inode failed&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|failed_mount3
suffix:semicolon
)brace
id|ext3_setup_super
(paren
id|sb
comma
id|es
comma
id|sb-&gt;s_flags
op_amp
id|MS_RDONLY
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * akpm: core read_super() calls in here with the superblock locked.&n;&t; * That deadlocks, because orphan cleanup needs to lock the superblock&n;&t; * in numerous places.  Here we just pop the lock - it&squot;s relatively&n;&t; * harmless, because we are now ready to accept write_super() requests,&n;&t; * and aviro says that&squot;s the only reason for hanging onto the&n;&t; * superblock lock.&n;&t; */
id|EXT3_SB
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|s_mount_state
op_or_assign
id|EXT3_ORPHAN_FS
suffix:semicolon
id|unlock_super
c_func
(paren
id|sb
)paren
suffix:semicolon
multiline_comment|/* akpm: sigh */
id|ext3_orphan_cleanup
c_func
(paren
id|sb
comma
id|es
)paren
suffix:semicolon
id|lock_super
c_func
(paren
id|sb
)paren
suffix:semicolon
id|EXT3_SB
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|s_mount_state
op_and_assign
op_complement
id|EXT3_ORPHAN_FS
suffix:semicolon
r_if
c_cond
(paren
id|needs_recovery
)paren
id|printk
(paren
id|KERN_INFO
l_string|&quot;EXT3-fs: recovery complete.&bslash;n&quot;
)paren
suffix:semicolon
id|ext3_mark_recovery_complete
c_func
(paren
id|sb
comma
id|es
)paren
suffix:semicolon
id|printk
(paren
id|KERN_INFO
l_string|&quot;EXT3-fs: mounted filesystem with %s data mode.&bslash;n&quot;
comma
id|test_opt
c_func
(paren
id|sb
comma
id|DATA_FLAGS
)paren
op_eq
id|EXT3_MOUNT_JOURNAL_DATA
ques
c_cond
l_string|&quot;journal&quot;
suffix:colon
id|test_opt
c_func
(paren
id|sb
comma
id|DATA_FLAGS
)paren
op_eq
id|EXT3_MOUNT_ORDERED_DATA
ques
c_cond
l_string|&quot;ordered&quot;
suffix:colon
l_string|&quot;writeback&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|failed_mount3
suffix:colon
id|journal_destroy
c_func
(paren
id|sbi-&gt;s_journal
)paren
suffix:semicolon
id|failed_mount2
suffix:colon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|db_count
suffix:semicolon
id|i
op_increment
)paren
id|brelse
c_func
(paren
id|sbi-&gt;s_group_desc
(braket
id|i
)braket
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|sbi-&gt;s_group_desc
)paren
suffix:semicolon
id|failed_mount
suffix:colon
id|ext3_blkdev_remove
c_func
(paren
id|sbi
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|bh
)paren
suffix:semicolon
id|out_fail
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
DECL|function|ext3_get_journal
r_static
id|journal_t
op_star
id|ext3_get_journal
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_int
id|journal_inum
)paren
(brace
r_struct
id|inode
op_star
id|journal_inode
suffix:semicolon
id|journal_t
op_star
id|journal
suffix:semicolon
multiline_comment|/* First, test for the existence of a valid inode on disk.  Bad&n;&t; * things happen if we iget() an unused inode, as the subsequent&n;&t; * iput() will try to delete it. */
id|journal_inode
op_assign
id|iget
c_func
(paren
id|sb
comma
id|journal_inum
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|journal_inode
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;EXT3-fs: no journal found.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|journal_inode-&gt;i_nlink
)paren
(brace
id|make_bad_inode
c_func
(paren
id|journal_inode
)paren
suffix:semicolon
id|iput
c_func
(paren
id|journal_inode
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;EXT3-fs: journal inode is deleted.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|jbd_debug
c_func
(paren
l_int|2
comma
l_string|&quot;Journal inode found at %p: %Ld bytes&bslash;n&quot;
comma
id|journal_inode
comma
id|journal_inode-&gt;i_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_bad_inode
c_func
(paren
id|journal_inode
)paren
op_logical_or
op_logical_neg
id|S_ISREG
c_func
(paren
id|journal_inode-&gt;i_mode
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;EXT3-fs: invalid journal inode.&bslash;n&quot;
)paren
suffix:semicolon
id|iput
c_func
(paren
id|journal_inode
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|journal
op_assign
id|journal_init_inode
c_func
(paren
id|journal_inode
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|journal
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;EXT3-fs: Could not load journal inode&bslash;n&quot;
)paren
suffix:semicolon
id|iput
c_func
(paren
id|journal_inode
)paren
suffix:semicolon
)brace
r_return
id|journal
suffix:semicolon
)brace
DECL|function|ext3_get_dev_journal
r_static
id|journal_t
op_star
id|ext3_get_dev_journal
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
id|kdev_t
id|j_dev
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
id|journal_t
op_star
id|journal
suffix:semicolon
r_int
id|start
suffix:semicolon
r_int
id|len
suffix:semicolon
r_int
id|hblock
comma
id|blocksize
suffix:semicolon
r_int
r_int
id|sb_block
suffix:semicolon
r_int
r_int
id|offset
suffix:semicolon
r_struct
id|ext3_super_block
op_star
id|es
suffix:semicolon
r_struct
id|block_device
op_star
id|bdev
suffix:semicolon
id|bdev
op_assign
id|ext3_blkdev_get
c_func
(paren
id|j_dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bdev
op_eq
l_int|NULL
)paren
r_return
l_int|NULL
suffix:semicolon
id|blocksize
op_assign
id|sb-&gt;s_blocksize
suffix:semicolon
id|hblock
op_assign
id|bdev_hardsect_size
c_func
(paren
id|bdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|blocksize
OL
id|hblock
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;EXT3-fs: blocksize too small for journal device.&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|out_bdev
suffix:semicolon
)brace
id|sb_block
op_assign
id|EXT3_MIN_BLOCK_SIZE
op_div
id|blocksize
suffix:semicolon
id|offset
op_assign
id|EXT3_MIN_BLOCK_SIZE
op_mod
id|blocksize
suffix:semicolon
id|set_blocksize
c_func
(paren
id|j_dev
comma
id|blocksize
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|bh
op_assign
id|__bread
c_func
(paren
id|bdev
comma
id|sb_block
comma
id|blocksize
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;EXT3-fs: couldn&squot;t read superblock of &quot;
l_string|&quot;external journal&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|out_bdev
suffix:semicolon
)brace
id|es
op_assign
(paren
r_struct
id|ext3_super_block
op_star
)paren
(paren
(paren
(paren
r_char
op_star
)paren
id|bh-&gt;b_data
)paren
op_plus
id|offset
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|le16_to_cpu
c_func
(paren
id|es-&gt;s_magic
)paren
op_ne
id|EXT3_SUPER_MAGIC
)paren
op_logical_or
op_logical_neg
(paren
id|le32_to_cpu
c_func
(paren
id|es-&gt;s_feature_incompat
)paren
op_amp
id|EXT3_FEATURE_INCOMPAT_JOURNAL_DEV
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;EXT3-fs: external journal has &quot;
l_string|&quot;bad superblock&bslash;n&quot;
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|bh
)paren
suffix:semicolon
r_goto
id|out_bdev
suffix:semicolon
)brace
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|EXT3_SB
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|s_es-&gt;s_journal_uuid
comma
id|es-&gt;s_uuid
comma
l_int|16
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;EXT3-fs: journal UUID does not match&bslash;n&quot;
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|bh
)paren
suffix:semicolon
r_goto
id|out_bdev
suffix:semicolon
)brace
id|len
op_assign
id|le32_to_cpu
c_func
(paren
id|es-&gt;s_blocks_count
)paren
suffix:semicolon
id|start
op_assign
id|sb_block
op_plus
l_int|1
suffix:semicolon
id|brelse
c_func
(paren
id|bh
)paren
suffix:semicolon
multiline_comment|/* we&squot;re done with the superblock */
id|journal
op_assign
id|journal_init_dev
c_func
(paren
id|bdev
comma
id|sb-&gt;s_bdev
comma
id|start
comma
id|len
comma
id|blocksize
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|journal
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;EXT3-fs: failed to create device journal&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|out_bdev
suffix:semicolon
)brace
id|ll_rw_block
c_func
(paren
id|READ
comma
l_int|1
comma
op_amp
id|journal-&gt;j_sb_buffer
)paren
suffix:semicolon
id|wait_on_buffer
c_func
(paren
id|journal-&gt;j_sb_buffer
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|journal-&gt;j_sb_buffer
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;EXT3-fs: I/O error on journal device&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|out_journal
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ntohl
c_func
(paren
id|journal-&gt;j_superblock-&gt;s_nr_users
)paren
op_ne
l_int|1
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;EXT3-fs: External journal has more than one &quot;
l_string|&quot;user (unsupported) - %d&bslash;n&quot;
comma
id|ntohl
c_func
(paren
id|journal-&gt;j_superblock-&gt;s_nr_users
)paren
)paren
suffix:semicolon
r_goto
id|out_journal
suffix:semicolon
)brace
id|EXT3_SB
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|journal_bdev
op_assign
id|bdev
suffix:semicolon
r_return
id|journal
suffix:semicolon
id|out_journal
suffix:colon
id|journal_destroy
c_func
(paren
id|journal
)paren
suffix:semicolon
id|out_bdev
suffix:colon
id|ext3_blkdev_put
c_func
(paren
id|bdev
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|ext3_load_journal
r_static
r_int
id|ext3_load_journal
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_struct
id|ext3_super_block
op_star
id|es
)paren
(brace
id|journal_t
op_star
id|journal
suffix:semicolon
r_int
id|journal_inum
op_assign
id|le32_to_cpu
c_func
(paren
id|es-&gt;s_journal_inum
)paren
suffix:semicolon
id|kdev_t
id|journal_dev
op_assign
id|to_kdev_t
c_func
(paren
id|le32_to_cpu
c_func
(paren
id|es-&gt;s_journal_dev
)paren
)paren
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
r_int
id|really_read_only
suffix:semicolon
id|really_read_only
op_assign
id|is_read_only
c_func
(paren
id|sb-&gt;s_dev
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Are we loading a blank journal or performing recovery after a&n;&t; * crash?  For recovery, we need to check in advance whether we&n;&t; * can get read-write access to the device.&n;&t; */
r_if
c_cond
(paren
id|EXT3_HAS_INCOMPAT_FEATURE
c_func
(paren
id|sb
comma
id|EXT3_FEATURE_INCOMPAT_RECOVER
)paren
)paren
(brace
r_if
c_cond
(paren
id|sb-&gt;s_flags
op_amp
id|MS_RDONLY
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;EXT3-fs: INFO: recovery &quot;
l_string|&quot;required on readonly filesystem.&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|really_read_only
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;EXT3-fs: write access &quot;
l_string|&quot;unavailable, cannot proceed.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EROFS
suffix:semicolon
)brace
id|printk
(paren
id|KERN_INFO
l_string|&quot;EXT3-fs: write access will &quot;
l_string|&quot;be enabled during recovery.&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|journal_inum
op_logical_and
op_logical_neg
id|kdev_none
c_func
(paren
id|journal_dev
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;EXT3-fs: filesystem has both journal &quot;
l_string|&quot;and inode journals!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|journal_inum
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|journal
op_assign
id|ext3_get_journal
c_func
(paren
id|sb
comma
id|journal_inum
)paren
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|journal
op_assign
id|ext3_get_dev_journal
c_func
(paren
id|sb
comma
id|journal_dev
)paren
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|really_read_only
op_logical_and
id|test_opt
c_func
(paren
id|sb
comma
id|UPDATE_JOURNAL
)paren
)paren
(brace
id|err
op_assign
id|journal_update_format
c_func
(paren
id|journal
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;EXT3-fs: error updating journal.&bslash;n&quot;
)paren
suffix:semicolon
id|journal_destroy
c_func
(paren
id|journal
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|EXT3_HAS_INCOMPAT_FEATURE
c_func
(paren
id|sb
comma
id|EXT3_FEATURE_INCOMPAT_RECOVER
)paren
)paren
id|err
op_assign
id|journal_wipe
c_func
(paren
id|journal
comma
op_logical_neg
id|really_read_only
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|err
)paren
id|err
op_assign
id|journal_load
c_func
(paren
id|journal
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;EXT3-fs: error loading journal.&bslash;n&quot;
)paren
suffix:semicolon
id|journal_destroy
c_func
(paren
id|journal
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
id|EXT3_SB
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|s_journal
op_assign
id|journal
suffix:semicolon
id|ext3_clear_journal_err
c_func
(paren
id|sb
comma
id|es
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ext3_create_journal
r_static
r_int
id|ext3_create_journal
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_struct
id|ext3_super_block
op_star
id|es
comma
r_int
id|journal_inum
)paren
(brace
id|journal_t
op_star
id|journal
suffix:semicolon
r_if
c_cond
(paren
id|sb-&gt;s_flags
op_amp
id|MS_RDONLY
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;EXT3-fs: readonly filesystem when trying to &quot;
l_string|&quot;create journal.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EROFS
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|journal
op_assign
id|ext3_get_journal
c_func
(paren
id|sb
comma
id|journal_inum
)paren
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;EXT3-fs: creating new journal on inode %d&bslash;n&quot;
comma
id|journal_inum
)paren
suffix:semicolon
r_if
c_cond
(paren
id|journal_create
c_func
(paren
id|journal
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;EXT3-fs: error creating journal.&bslash;n&quot;
)paren
suffix:semicolon
id|journal_destroy
c_func
(paren
id|journal
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|EXT3_SB
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|s_journal
op_assign
id|journal
suffix:semicolon
id|ext3_update_dynamic_rev
c_func
(paren
id|sb
)paren
suffix:semicolon
id|EXT3_SET_INCOMPAT_FEATURE
c_func
(paren
id|sb
comma
id|EXT3_FEATURE_INCOMPAT_RECOVER
)paren
suffix:semicolon
id|EXT3_SET_COMPAT_FEATURE
c_func
(paren
id|sb
comma
id|EXT3_FEATURE_COMPAT_HAS_JOURNAL
)paren
suffix:semicolon
id|es-&gt;s_journal_inum
op_assign
id|cpu_to_le32
c_func
(paren
id|journal_inum
)paren
suffix:semicolon
id|sb-&gt;s_dirt
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Make sure we flush the recovery flag to disk. */
id|ext3_commit_super
c_func
(paren
id|sb
comma
id|es
comma
l_int|1
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ext3_commit_super
r_static
r_void
id|ext3_commit_super
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_struct
id|ext3_super_block
op_star
id|es
comma
r_int
id|sync
)paren
(brace
id|es-&gt;s_wtime
op_assign
id|cpu_to_le32
c_func
(paren
id|CURRENT_TIME
)paren
suffix:semicolon
id|BUFFER_TRACE
c_func
(paren
id|sb-&gt;u.ext3_sb.s_sbh
comma
l_string|&quot;marking dirty&quot;
)paren
suffix:semicolon
id|mark_buffer_dirty
c_func
(paren
id|sb-&gt;u.ext3_sb.s_sbh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sync
)paren
(brace
id|ll_rw_block
c_func
(paren
id|WRITE
comma
l_int|1
comma
op_amp
id|sb-&gt;u.ext3_sb.s_sbh
)paren
suffix:semicolon
id|wait_on_buffer
c_func
(paren
id|sb-&gt;u.ext3_sb.s_sbh
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Have we just finished recovery?  If so, and if we are mounting (or&n; * remounting) the filesystem readonly, then we will end up with a&n; * consistent fs on disk.  Record that fact.&n; */
DECL|function|ext3_mark_recovery_complete
r_static
r_void
id|ext3_mark_recovery_complete
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_struct
id|ext3_super_block
op_star
id|es
)paren
(brace
id|journal_flush
c_func
(paren
id|EXT3_SB
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|s_journal
)paren
suffix:semicolon
r_if
c_cond
(paren
id|EXT3_HAS_INCOMPAT_FEATURE
c_func
(paren
id|sb
comma
id|EXT3_FEATURE_INCOMPAT_RECOVER
)paren
op_logical_and
id|sb-&gt;s_flags
op_amp
id|MS_RDONLY
)paren
(brace
id|EXT3_CLEAR_INCOMPAT_FEATURE
c_func
(paren
id|sb
comma
id|EXT3_FEATURE_INCOMPAT_RECOVER
)paren
suffix:semicolon
id|sb-&gt;s_dirt
op_assign
l_int|0
suffix:semicolon
id|ext3_commit_super
c_func
(paren
id|sb
comma
id|es
comma
l_int|1
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * If we are mounting (or read-write remounting) a filesystem whose journal&n; * has recorded an error from a previous lifetime, move that error to the&n; * main filesystem now.&n; */
DECL|function|ext3_clear_journal_err
r_static
r_void
id|ext3_clear_journal_err
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_struct
id|ext3_super_block
op_star
id|es
)paren
(brace
id|journal_t
op_star
id|journal
suffix:semicolon
r_int
id|j_errno
suffix:semicolon
r_const
r_char
op_star
id|errstr
suffix:semicolon
id|journal
op_assign
id|EXT3_SB
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|s_journal
suffix:semicolon
multiline_comment|/*&n;&t; * Now check for any error status which may have been recorded in the&n;&t; * journal by a prior ext3_error() or ext3_abort()&n;&t; */
id|j_errno
op_assign
id|journal_errno
c_func
(paren
id|journal
)paren
suffix:semicolon
r_if
c_cond
(paren
id|j_errno
)paren
(brace
r_char
id|nbuf
(braket
l_int|16
)braket
suffix:semicolon
id|errstr
op_assign
id|ext3_decode_error
c_func
(paren
id|sb
comma
id|j_errno
comma
id|nbuf
)paren
suffix:semicolon
id|ext3_warning
c_func
(paren
id|sb
comma
id|__FUNCTION__
comma
l_string|&quot;Filesystem error recorded &quot;
l_string|&quot;from previous mount: %s&quot;
comma
id|errstr
)paren
suffix:semicolon
id|ext3_warning
c_func
(paren
id|sb
comma
id|__FUNCTION__
comma
l_string|&quot;Marking fs in need of &quot;
l_string|&quot;filesystem check.&quot;
)paren
suffix:semicolon
id|sb-&gt;u.ext3_sb.s_mount_state
op_or_assign
id|EXT3_ERROR_FS
suffix:semicolon
id|es-&gt;s_state
op_or_assign
id|cpu_to_le16
c_func
(paren
id|EXT3_ERROR_FS
)paren
suffix:semicolon
id|ext3_commit_super
(paren
id|sb
comma
id|es
comma
l_int|1
)paren
suffix:semicolon
id|journal_clear_err
c_func
(paren
id|journal
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Force the running and committing transactions to commit,&n; * and wait on the commit.&n; */
DECL|function|ext3_force_commit
r_int
id|ext3_force_commit
c_func
(paren
r_struct
id|super_block
op_star
id|sb
)paren
(brace
id|journal_t
op_star
id|journal
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_if
c_cond
(paren
id|sb-&gt;s_flags
op_amp
id|MS_RDONLY
)paren
r_return
l_int|0
suffix:semicolon
id|journal
op_assign
id|EXT3_SB
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|s_journal
suffix:semicolon
id|sb-&gt;s_dirt
op_assign
l_int|0
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* important: lock down j_running_transaction */
id|ret
op_assign
id|ext3_journal_force_commit
c_func
(paren
id|journal
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Ext3 always journals updates to the superblock itself, so we don&squot;t&n; * have to propagate any other updates to the superblock on disk at this&n; * point.  Just start an async writeback to get the buffers on their way&n; * to the disk.&n; *&n; * This implicitly triggers the writebehind on sync().&n; */
DECL|variable|do_sync_supers
r_static
r_int
id|do_sync_supers
op_assign
l_int|0
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|do_sync_supers
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|do_sync_supers
comma
l_string|&quot;Write superblocks synchronously&quot;
)paren
suffix:semicolon
DECL|function|ext3_write_super
r_void
id|ext3_write_super
(paren
r_struct
id|super_block
op_star
id|sb
)paren
(brace
id|tid_t
id|target
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|down_trylock
c_func
(paren
op_amp
id|sb-&gt;s_lock
)paren
op_eq
l_int|0
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* aviro detector */
id|sb-&gt;s_dirt
op_assign
l_int|0
suffix:semicolon
id|target
op_assign
id|log_start_commit
c_func
(paren
id|EXT3_SB
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|s_journal
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|do_sync_supers
)paren
(brace
id|unlock_super
c_func
(paren
id|sb
)paren
suffix:semicolon
id|log_wait_commit
c_func
(paren
id|EXT3_SB
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|s_journal
comma
id|target
)paren
suffix:semicolon
id|lock_super
c_func
(paren
id|sb
)paren
suffix:semicolon
)brace
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * LVM calls this function before a (read-only) snapshot is created.  This&n; * gives us a chance to flush the journal completely and mark the fs clean.&n; */
DECL|function|ext3_write_super_lockfs
r_void
id|ext3_write_super_lockfs
c_func
(paren
r_struct
id|super_block
op_star
id|sb
)paren
(brace
id|sb-&gt;s_dirt
op_assign
l_int|0
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* 2.4.5 forgot to do this for us */
r_if
c_cond
(paren
op_logical_neg
(paren
id|sb-&gt;s_flags
op_amp
id|MS_RDONLY
)paren
)paren
(brace
id|journal_t
op_star
id|journal
op_assign
id|EXT3_SB
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|s_journal
suffix:semicolon
multiline_comment|/* Now we set up the journal barrier. */
id|journal_lock_updates
c_func
(paren
id|journal
)paren
suffix:semicolon
id|journal_flush
c_func
(paren
id|journal
)paren
suffix:semicolon
multiline_comment|/* Journal blocked and flushed, clear needs_recovery flag. */
id|EXT3_CLEAR_INCOMPAT_FEATURE
c_func
(paren
id|sb
comma
id|EXT3_FEATURE_INCOMPAT_RECOVER
)paren
suffix:semicolon
id|ext3_commit_super
c_func
(paren
id|sb
comma
id|EXT3_SB
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|s_es
comma
l_int|1
)paren
suffix:semicolon
)brace
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Called by LVM after the snapshot is done.  We need to reset the RECOVER&n; * flag here, even though the filesystem is not technically dirty yet.&n; */
DECL|function|ext3_unlockfs
r_void
id|ext3_unlockfs
c_func
(paren
r_struct
id|super_block
op_star
id|sb
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|sb-&gt;s_flags
op_amp
id|MS_RDONLY
)paren
)paren
(brace
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|lock_super
c_func
(paren
id|sb
)paren
suffix:semicolon
multiline_comment|/* Reser the needs_recovery flag before the fs is unlocked. */
id|EXT3_SET_INCOMPAT_FEATURE
c_func
(paren
id|sb
comma
id|EXT3_FEATURE_INCOMPAT_RECOVER
)paren
suffix:semicolon
id|ext3_commit_super
c_func
(paren
id|sb
comma
id|EXT3_SB
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|s_es
comma
l_int|1
)paren
suffix:semicolon
id|unlock_super
c_func
(paren
id|sb
)paren
suffix:semicolon
id|journal_unlock_updates
c_func
(paren
id|EXT3_SB
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|s_journal
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
DECL|function|ext3_remount
r_int
id|ext3_remount
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_int
op_star
id|flags
comma
r_char
op_star
id|data
)paren
(brace
r_struct
id|ext3_super_block
op_star
id|es
suffix:semicolon
r_struct
id|ext3_sb_info
op_star
id|sbi
op_assign
id|EXT3_SB
c_func
(paren
id|sb
)paren
suffix:semicolon
r_int
r_int
id|tmp
suffix:semicolon
id|clear_ro_after
c_func
(paren
id|sb
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Allow the &quot;check&quot; option to be passed as a remount option.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|parse_options
c_func
(paren
id|data
comma
op_amp
id|tmp
comma
id|sbi
comma
op_amp
id|tmp
comma
l_int|1
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|sbi-&gt;s_mount_opt
op_amp
id|EXT3_MOUNT_ABORT
)paren
id|ext3_abort
c_func
(paren
id|sb
comma
id|__FUNCTION__
comma
l_string|&quot;Abort forced by user&quot;
)paren
suffix:semicolon
id|es
op_assign
id|sbi-&gt;s_es
suffix:semicolon
r_if
c_cond
(paren
(paren
op_star
id|flags
op_amp
id|MS_RDONLY
)paren
op_ne
(paren
id|sb-&gt;s_flags
op_amp
id|MS_RDONLY
)paren
)paren
(brace
r_if
c_cond
(paren
id|sbi-&gt;s_mount_opt
op_amp
id|EXT3_MOUNT_ABORT
)paren
r_return
op_minus
id|EROFS
suffix:semicolon
r_if
c_cond
(paren
op_star
id|flags
op_amp
id|MS_RDONLY
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * First of all, the unconditional stuff we have to do&n;&t;&t;&t; * to disable replay of the journal when we next remount&n;&t;&t;&t; */
id|sb-&gt;s_flags
op_or_assign
id|MS_RDONLY
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * OK, test if we are remounting a valid rw partition&n;&t;&t;&t; * readonly, and if so set the rdonly flag and then&n;&t;&t;&t; * mark the partition as valid again.&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|es-&gt;s_state
op_amp
id|cpu_to_le16
c_func
(paren
id|EXT3_VALID_FS
)paren
)paren
op_logical_and
(paren
id|sbi-&gt;s_mount_state
op_amp
id|EXT3_VALID_FS
)paren
)paren
id|es-&gt;s_state
op_assign
id|cpu_to_le16
c_func
(paren
id|sbi-&gt;s_mount_state
)paren
suffix:semicolon
id|ext3_mark_recovery_complete
c_func
(paren
id|sb
comma
id|es
)paren
suffix:semicolon
)brace
r_else
(brace
r_int
id|ret
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|EXT3_HAS_RO_COMPAT_FEATURE
c_func
(paren
id|sb
comma
op_complement
id|EXT3_FEATURE_RO_COMPAT_SUPP
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;EXT3-fs: %s: couldn&squot;t &quot;
l_string|&quot;remount RDWR because of unsupported &quot;
l_string|&quot;optional features (%x).&bslash;n&quot;
comma
id|sb-&gt;s_id
comma
id|ret
)paren
suffix:semicolon
r_return
op_minus
id|EROFS
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * Mounting a RDONLY partition read-write, so reread&n;&t;&t;&t; * and store the current valid flag.  (It may have&n;&t;&t;&t; * been changed by e2fsck since we originally mounted&n;&t;&t;&t; * the partition.)&n;&t;&t;&t; */
id|ext3_clear_journal_err
c_func
(paren
id|sb
comma
id|es
)paren
suffix:semicolon
id|sbi-&gt;s_mount_state
op_assign
id|le16_to_cpu
c_func
(paren
id|es-&gt;s_state
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ext3_setup_super
(paren
id|sb
comma
id|es
comma
l_int|0
)paren
)paren
id|sb-&gt;s_flags
op_and_assign
op_complement
id|MS_RDONLY
suffix:semicolon
)brace
)brace
id|setup_ro_after
c_func
(paren
id|sb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ext3_statfs
r_int
id|ext3_statfs
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_struct
id|statfs
op_star
id|buf
)paren
(brace
r_struct
id|ext3_super_block
op_star
id|es
op_assign
id|EXT3_SB
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|s_es
suffix:semicolon
r_int
r_int
id|overhead
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|test_opt
(paren
id|sb
comma
id|MINIX_DF
)paren
)paren
id|overhead
op_assign
l_int|0
suffix:semicolon
r_else
(brace
multiline_comment|/*&n;&t;&t; * Compute the overhead (FS structures)&n;&t;&t; */
multiline_comment|/*&n;&t;&t; * All of the blocks before first_data_block are&n;&t;&t; * overhead&n;&t;&t; */
id|overhead
op_assign
id|le32_to_cpu
c_func
(paren
id|es-&gt;s_first_data_block
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Add the overhead attributed to the superblock and&n;&t;&t; * block group descriptors.  If the sparse superblocks&n;&t;&t; * feature is turned on, then not all groups have this.&n;&t;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|EXT3_SB
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|s_groups_count
suffix:semicolon
id|i
op_increment
)paren
id|overhead
op_add_assign
id|ext3_bg_has_super
c_func
(paren
id|sb
comma
id|i
)paren
op_plus
id|ext3_bg_num_gdb
c_func
(paren
id|sb
comma
id|i
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Every block group has an inode bitmap, a block&n;&t;&t; * bitmap, and an inode table.&n;&t;&t; */
id|overhead
op_add_assign
(paren
id|EXT3_SB
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|s_groups_count
op_star
(paren
l_int|2
op_plus
id|EXT3_SB
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|s_itb_per_group
)paren
)paren
suffix:semicolon
)brace
id|buf-&gt;f_type
op_assign
id|EXT3_SUPER_MAGIC
suffix:semicolon
id|buf-&gt;f_bsize
op_assign
id|sb-&gt;s_blocksize
suffix:semicolon
id|buf-&gt;f_blocks
op_assign
id|le32_to_cpu
c_func
(paren
id|es-&gt;s_blocks_count
)paren
op_minus
id|overhead
suffix:semicolon
id|buf-&gt;f_bfree
op_assign
id|ext3_count_free_blocks
(paren
id|sb
)paren
suffix:semicolon
id|buf-&gt;f_bavail
op_assign
id|buf-&gt;f_bfree
op_minus
id|le32_to_cpu
c_func
(paren
id|es-&gt;s_r_blocks_count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buf-&gt;f_bfree
OL
id|le32_to_cpu
c_func
(paren
id|es-&gt;s_r_blocks_count
)paren
)paren
id|buf-&gt;f_bavail
op_assign
l_int|0
suffix:semicolon
id|buf-&gt;f_files
op_assign
id|le32_to_cpu
c_func
(paren
id|es-&gt;s_inodes_count
)paren
suffix:semicolon
id|buf-&gt;f_ffree
op_assign
id|ext3_count_free_inodes
(paren
id|sb
)paren
suffix:semicolon
id|buf-&gt;f_namelen
op_assign
id|EXT3_NAME_LEN
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ext3_get_sb
r_static
r_struct
id|super_block
op_star
id|ext3_get_sb
c_func
(paren
r_struct
id|file_system_type
op_star
id|fs_type
comma
r_int
id|flags
comma
r_char
op_star
id|dev_name
comma
r_void
op_star
id|data
)paren
(brace
r_return
id|get_sb_bdev
c_func
(paren
id|fs_type
comma
id|flags
comma
id|dev_name
comma
id|data
comma
id|ext3_fill_super
)paren
suffix:semicolon
)brace
DECL|variable|ext3_fs_type
r_static
r_struct
id|file_system_type
id|ext3_fs_type
op_assign
(brace
id|owner
suffix:colon
id|THIS_MODULE
comma
id|name
suffix:colon
l_string|&quot;ext3&quot;
comma
id|get_sb
suffix:colon
id|ext3_get_sb
comma
id|kill_sb
suffix:colon
id|kill_block_super
comma
id|fs_flags
suffix:colon
id|FS_REQUIRES_DEV
comma
)brace
suffix:semicolon
DECL|function|init_ext3_fs
r_static
r_int
id|__init
id|init_ext3_fs
c_func
(paren
r_void
)paren
(brace
r_int
id|err
op_assign
id|init_inodecache
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out1
suffix:semicolon
id|err
op_assign
id|register_filesystem
c_func
(paren
op_amp
id|ext3_fs_type
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|out
suffix:colon
id|destroy_inodecache
c_func
(paren
)paren
suffix:semicolon
id|out1
suffix:colon
r_return
id|err
suffix:semicolon
)brace
DECL|function|exit_ext3_fs
r_static
r_void
id|__exit
id|exit_ext3_fs
c_func
(paren
r_void
)paren
(brace
id|unregister_filesystem
c_func
(paren
op_amp
id|ext3_fs_type
)paren
suffix:semicolon
id|destroy_inodecache
c_func
(paren
)paren
suffix:semicolon
)brace
id|EXPORT_NO_SYMBOLS
suffix:semicolon
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Remy Card, Stephen Tweedie, Andrew Morton, Andreas Dilger, Theodore Ts&squot;o and others&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;Second Extended Filesystem with journaling extensions&quot;
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
id|module_init
c_func
(paren
id|init_ext3_fs
)paren
id|module_exit
c_func
(paren
id|exit_ext3_fs
)paren
eof
