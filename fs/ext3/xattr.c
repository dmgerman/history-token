multiline_comment|/*&n; * linux/fs/ext3/xattr.c&n; *&n; * Copyright (C) 2001-2003 Andreas Gruenbacher, &lt;agruen@suse.de&gt;&n; *&n; * Fix by Harrison Xing &lt;harrison@mountainviewdata.com&gt;.&n; * Ext3 code with a lot of help from Eric Jarman &lt;ejarman@acm.org&gt;.&n; * Extended attributes for symlinks and special files added per&n; *  suggestion of Luka Renko &lt;luka.renko@hermes.si&gt;.&n; */
multiline_comment|/*&n; * Extended attributes are stored on disk blocks allocated outside of&n; * any inode. The i_file_acl field is then made to point to this allocated&n; * block. If all extended attributes of an inode are identical, these&n; * inodes may share the same extended attribute block. Such situations&n; * are automatically detected by keeping a cache of recent attribute block&n; * numbers and hashes over the block&squot;s contents in memory.&n; *&n; *&n; * Extended attribute block layout:&n; *&n; *   +------------------+&n; *   | header           |&n; *   &#xfffd; entry 1          | |&n; *   | entry 2          | | growing downwards&n; *   | entry 3          | v&n; *   | four null bytes  |&n; *   | . . .            |&n; *   | value 1          | ^&n; *   | value 3          | | growing upwards&n; *   | value 2          | |&n; *   +------------------+&n; *&n; * The block header is followed by multiple entry descriptors. These entry&n; * descriptors are variable in size, and alligned to EXT3_XATTR_PAD&n; * byte boundaries. The entry descriptors are sorted by attribute name,&n; * so that two extended attribute blocks can be compared efficiently.&n; *&n; * Attribute values are aligned to the end of the block, stored in&n; * no specific order. They are also padded to EXT3_XATTR_PAD byte&n; * boundaries. No additional gaps are left between them.&n; *&n; * Locking strategy&n; * ----------------&n; * EXT3_I(inode)-&gt;i_file_acl is protected by EXT3_I(inode)-&gt;xattr_sem.&n; * EA blocks are only changed if they are exclusive to an inode, so&n; * holding xattr_sem also means that nothing but the EA block&squot;s reference&n; * count will change. Multiple writers to an EA block are synchronized&n; * by the bh lock. No more than a single bh lock is held at any time&n; * to avoid deadlocks.&n; */
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/ext3_jbd.h&gt;
macro_line|#include &lt;linux/ext3_fs.h&gt;
macro_line|#include &lt;linux/mbcache.h&gt;
macro_line|#include &lt;linux/quotaops.h&gt;
macro_line|#include &lt;linux/rwsem.h&gt;
macro_line|#include &quot;xattr.h&quot;
macro_line|#include &quot;acl.h&quot;
DECL|macro|HDR
mdefine_line|#define HDR(bh) ((struct ext3_xattr_header *)((bh)-&gt;b_data))
DECL|macro|ENTRY
mdefine_line|#define ENTRY(ptr) ((struct ext3_xattr_entry *)(ptr))
DECL|macro|FIRST_ENTRY
mdefine_line|#define FIRST_ENTRY(bh) ENTRY(HDR(bh)+1)
DECL|macro|IS_LAST_ENTRY
mdefine_line|#define IS_LAST_ENTRY(entry) (*(__u32 *)(entry) == 0)
macro_line|#ifdef EXT3_XATTR_DEBUG
DECL|macro|ea_idebug
macro_line|# define ea_idebug(inode, f...) do { &bslash;&n;&t;&t;printk(KERN_DEBUG &quot;inode %s:%ld: &quot;, &bslash;&n;&t;&t;&t;inode-&gt;i_sb-&gt;s_id, inode-&gt;i_ino); &bslash;&n;&t;&t;printk(f); &bslash;&n;&t;&t;printk(&quot;&bslash;n&quot;); &bslash;&n;&t;} while (0)
DECL|macro|ea_bdebug
macro_line|# define ea_bdebug(bh, f...) do { &bslash;&n;&t;&t;char b[BDEVNAME_SIZE]; &bslash;&n;&t;&t;printk(KERN_DEBUG &quot;block %s:%lu: &quot;, &bslash;&n;&t;&t;&t;bdevname(bh-&gt;b_bdev, b), &bslash;&n;&t;&t;&t;(unsigned long) bh-&gt;b_blocknr); &bslash;&n;&t;&t;printk(f); &bslash;&n;&t;&t;printk(&quot;&bslash;n&quot;); &bslash;&n;&t;} while (0)
macro_line|#else
DECL|macro|ea_idebug
macro_line|# define ea_idebug(f...)
DECL|macro|ea_bdebug
macro_line|# define ea_bdebug(f...)
macro_line|#endif
r_static
r_int
id|ext3_xattr_set_handle2
c_func
(paren
id|handle_t
op_star
comma
r_struct
id|inode
op_star
comma
r_struct
id|buffer_head
op_star
comma
r_struct
id|ext3_xattr_header
op_star
)paren
suffix:semicolon
r_static
r_int
id|ext3_xattr_cache_insert
c_func
(paren
r_struct
id|buffer_head
op_star
)paren
suffix:semicolon
r_static
r_struct
id|buffer_head
op_star
id|ext3_xattr_cache_find
c_func
(paren
id|handle_t
op_star
comma
r_struct
id|inode
op_star
comma
r_struct
id|ext3_xattr_header
op_star
comma
r_int
op_star
)paren
suffix:semicolon
r_static
r_void
id|ext3_xattr_cache_remove
c_func
(paren
r_struct
id|buffer_head
op_star
)paren
suffix:semicolon
r_static
r_void
id|ext3_xattr_rehash
c_func
(paren
r_struct
id|ext3_xattr_header
op_star
comma
r_struct
id|ext3_xattr_entry
op_star
)paren
suffix:semicolon
DECL|variable|ext3_xattr_cache
r_static
r_struct
id|mb_cache
op_star
id|ext3_xattr_cache
suffix:semicolon
DECL|variable|ext3_xattr_handlers
r_static
r_struct
id|ext3_xattr_handler
op_star
id|ext3_xattr_handlers
(braket
id|EXT3_XATTR_INDEX_MAX
)braket
suffix:semicolon
DECL|variable|ext3_handler_lock
r_static
id|rwlock_t
id|ext3_handler_lock
op_assign
id|RW_LOCK_UNLOCKED
suffix:semicolon
r_int
DECL|function|ext3_xattr_register
id|ext3_xattr_register
c_func
(paren
r_int
id|name_index
comma
r_struct
id|ext3_xattr_handler
op_star
id|handler
)paren
(brace
r_int
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|name_index
OG
l_int|0
op_logical_and
id|name_index
op_le
id|EXT3_XATTR_INDEX_MAX
)paren
(brace
id|write_lock
c_func
(paren
op_amp
id|ext3_handler_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ext3_xattr_handlers
(braket
id|name_index
op_minus
l_int|1
)braket
)paren
(brace
id|ext3_xattr_handlers
(braket
id|name_index
op_minus
l_int|1
)braket
op_assign
id|handler
suffix:semicolon
id|error
op_assign
l_int|0
suffix:semicolon
)brace
id|write_unlock
c_func
(paren
op_amp
id|ext3_handler_lock
)paren
suffix:semicolon
)brace
r_return
id|error
suffix:semicolon
)brace
r_void
DECL|function|ext3_xattr_unregister
id|ext3_xattr_unregister
c_func
(paren
r_int
id|name_index
comma
r_struct
id|ext3_xattr_handler
op_star
id|handler
)paren
(brace
r_if
c_cond
(paren
id|name_index
OG
l_int|0
op_logical_or
id|name_index
op_le
id|EXT3_XATTR_INDEX_MAX
)paren
(brace
id|write_lock
c_func
(paren
op_amp
id|ext3_handler_lock
)paren
suffix:semicolon
id|ext3_xattr_handlers
(braket
id|name_index
op_minus
l_int|1
)braket
op_assign
l_int|NULL
suffix:semicolon
id|write_unlock
c_func
(paren
op_amp
id|ext3_handler_lock
)paren
suffix:semicolon
)brace
)brace
r_static
r_inline
r_const
r_char
op_star
DECL|function|strcmp_prefix
id|strcmp_prefix
c_func
(paren
r_const
r_char
op_star
id|a
comma
r_const
r_char
op_star
id|a_prefix
)paren
(brace
r_while
c_loop
(paren
op_star
id|a_prefix
op_logical_and
op_star
id|a
op_eq
op_star
id|a_prefix
)paren
(brace
id|a
op_increment
suffix:semicolon
id|a_prefix
op_increment
suffix:semicolon
)brace
r_return
op_star
id|a_prefix
ques
c_cond
l_int|NULL
suffix:colon
id|a
suffix:semicolon
)brace
multiline_comment|/*&n; * Decode the extended attribute name, and translate it into&n; * the name_index and name suffix.&n; */
r_static
r_inline
r_struct
id|ext3_xattr_handler
op_star
DECL|function|ext3_xattr_resolve_name
id|ext3_xattr_resolve_name
c_func
(paren
r_const
r_char
op_star
op_star
id|name
)paren
(brace
r_struct
id|ext3_xattr_handler
op_star
id|handler
op_assign
l_int|NULL
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_star
id|name
)paren
r_return
l_int|NULL
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|ext3_handler_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|EXT3_XATTR_INDEX_MAX
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|ext3_xattr_handlers
(braket
id|i
)braket
)paren
(brace
r_const
r_char
op_star
id|n
op_assign
id|strcmp_prefix
c_func
(paren
op_star
id|name
comma
id|ext3_xattr_handlers
(braket
id|i
)braket
op_member_access_from_pointer
id|prefix
)paren
suffix:semicolon
r_if
c_cond
(paren
id|n
)paren
(brace
id|handler
op_assign
id|ext3_xattr_handlers
(braket
id|i
)braket
suffix:semicolon
op_star
id|name
op_assign
id|n
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
id|read_unlock
c_func
(paren
op_amp
id|ext3_handler_lock
)paren
suffix:semicolon
r_return
id|handler
suffix:semicolon
)brace
r_static
r_inline
r_struct
id|ext3_xattr_handler
op_star
DECL|function|ext3_xattr_handler
id|ext3_xattr_handler
c_func
(paren
r_int
id|name_index
)paren
(brace
r_struct
id|ext3_xattr_handler
op_star
id|handler
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|name_index
OG
l_int|0
op_logical_and
id|name_index
op_le
id|EXT3_XATTR_INDEX_MAX
)paren
(brace
id|read_lock
c_func
(paren
op_amp
id|ext3_handler_lock
)paren
suffix:semicolon
id|handler
op_assign
id|ext3_xattr_handlers
(braket
id|name_index
op_minus
l_int|1
)braket
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|ext3_handler_lock
)paren
suffix:semicolon
)brace
r_return
id|handler
suffix:semicolon
)brace
multiline_comment|/*&n; * Inode operation getxattr()&n; *&n; * dentry-&gt;d_inode-&gt;i_sem: don&squot;t care&n; */
id|ssize_t
DECL|function|ext3_getxattr
id|ext3_getxattr
c_func
(paren
r_struct
id|dentry
op_star
id|dentry
comma
r_const
r_char
op_star
id|name
comma
r_void
op_star
id|buffer
comma
r_int
id|size
)paren
(brace
r_struct
id|ext3_xattr_handler
op_star
id|handler
suffix:semicolon
r_struct
id|inode
op_star
id|inode
op_assign
id|dentry-&gt;d_inode
suffix:semicolon
id|handler
op_assign
id|ext3_xattr_resolve_name
c_func
(paren
op_amp
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|handler
)paren
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
r_return
id|handler
op_member_access_from_pointer
id|get
c_func
(paren
id|inode
comma
id|name
comma
id|buffer
comma
id|size
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Inode operation listxattr()&n; *&n; * dentry-&gt;d_inode-&gt;i_sem: don&squot;t care&n; */
id|ssize_t
DECL|function|ext3_listxattr
id|ext3_listxattr
c_func
(paren
r_struct
id|dentry
op_star
id|dentry
comma
r_char
op_star
id|buffer
comma
r_int
id|size
)paren
(brace
r_return
id|ext3_xattr_list
c_func
(paren
id|dentry-&gt;d_inode
comma
id|buffer
comma
id|size
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Inode operation setxattr()&n; *&n; * dentry-&gt;d_inode-&gt;i_sem: down&n; */
r_int
DECL|function|ext3_setxattr
id|ext3_setxattr
c_func
(paren
r_struct
id|dentry
op_star
id|dentry
comma
r_const
r_char
op_star
id|name
comma
r_const
r_void
op_star
id|value
comma
r_int
id|size
comma
r_int
id|flags
)paren
(brace
r_struct
id|ext3_xattr_handler
op_star
id|handler
suffix:semicolon
r_struct
id|inode
op_star
id|inode
op_assign
id|dentry-&gt;d_inode
suffix:semicolon
r_if
c_cond
(paren
id|size
op_eq
l_int|0
)paren
id|value
op_assign
l_string|&quot;&quot;
suffix:semicolon
multiline_comment|/* empty EA, do not remove */
id|handler
op_assign
id|ext3_xattr_resolve_name
c_func
(paren
op_amp
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|handler
)paren
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
r_return
id|handler
op_member_access_from_pointer
id|set
c_func
(paren
id|inode
comma
id|name
comma
id|value
comma
id|size
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Inode operation removexattr()&n; *&n; * dentry-&gt;d_inode-&gt;i_sem: down&n; */
r_int
DECL|function|ext3_removexattr
id|ext3_removexattr
c_func
(paren
r_struct
id|dentry
op_star
id|dentry
comma
r_const
r_char
op_star
id|name
)paren
(brace
r_struct
id|ext3_xattr_handler
op_star
id|handler
suffix:semicolon
r_struct
id|inode
op_star
id|inode
op_assign
id|dentry-&gt;d_inode
suffix:semicolon
id|handler
op_assign
id|ext3_xattr_resolve_name
c_func
(paren
op_amp
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|handler
)paren
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
r_return
id|handler
op_member_access_from_pointer
id|set
c_func
(paren
id|inode
comma
id|name
comma
l_int|NULL
comma
l_int|0
comma
id|XATTR_REPLACE
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * ext3_xattr_get()&n; *&n; * Copy an extended attribute into the buffer&n; * provided, or compute the buffer size required.&n; * Buffer is NULL to compute the size of the buffer required.&n; *&n; * Returns a negative error number on failure, or the number of bytes&n; * used / required on success.&n; */
r_int
DECL|function|ext3_xattr_get
id|ext3_xattr_get
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_int
id|name_index
comma
r_const
r_char
op_star
id|name
comma
r_void
op_star
id|buffer
comma
r_int
id|buffer_size
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|ext3_xattr_entry
op_star
id|entry
suffix:semicolon
r_int
id|name_len
comma
id|size
suffix:semicolon
r_char
op_star
id|end
suffix:semicolon
r_int
id|error
suffix:semicolon
id|ea_idebug
c_func
(paren
id|inode
comma
l_string|&quot;name=%d.%s, buffer=%p, buffer_size=%ld&quot;
comma
id|name_index
comma
id|name
comma
id|buffer
comma
(paren
r_int
)paren
id|buffer_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|name
op_eq
l_int|NULL
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|down_read
c_func
(paren
op_amp
id|EXT3_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|xattr_sem
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|ENODATA
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|EXT3_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_file_acl
)paren
r_goto
id|cleanup
suffix:semicolon
id|ea_idebug
c_func
(paren
id|inode
comma
l_string|&quot;reading block %d&quot;
comma
id|EXT3_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_file_acl
)paren
suffix:semicolon
id|bh
op_assign
id|sb_bread
c_func
(paren
id|inode-&gt;i_sb
comma
id|EXT3_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_file_acl
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|EIO
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bh
)paren
r_goto
id|cleanup
suffix:semicolon
id|ea_bdebug
c_func
(paren
id|bh
comma
l_string|&quot;b_count=%d, refcount=%d&quot;
comma
id|atomic_read
c_func
(paren
op_amp
(paren
id|bh-&gt;b_count
)paren
)paren
comma
id|le32_to_cpu
c_func
(paren
id|HDR
c_func
(paren
id|bh
)paren
op_member_access_from_pointer
id|h_refcount
)paren
)paren
suffix:semicolon
id|end
op_assign
id|bh-&gt;b_data
op_plus
id|bh-&gt;b_size
suffix:semicolon
r_if
c_cond
(paren
id|HDR
c_func
(paren
id|bh
)paren
op_member_access_from_pointer
id|h_magic
op_ne
id|cpu_to_le32
c_func
(paren
id|EXT3_XATTR_MAGIC
)paren
op_logical_or
id|HDR
c_func
(paren
id|bh
)paren
op_member_access_from_pointer
id|h_blocks
op_ne
id|cpu_to_le32
c_func
(paren
l_int|1
)paren
)paren
(brace
id|bad_block
suffix:colon
id|ext3_error
c_func
(paren
id|inode-&gt;i_sb
comma
l_string|&quot;ext3_xattr_get&quot;
comma
l_string|&quot;inode %ld: bad block %d&quot;
comma
id|inode-&gt;i_ino
comma
id|EXT3_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_file_acl
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|cleanup
suffix:semicolon
)brace
multiline_comment|/* find named attribute */
id|name_len
op_assign
id|strlen
c_func
(paren
id|name
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|ERANGE
suffix:semicolon
r_if
c_cond
(paren
id|name_len
OG
l_int|255
)paren
r_goto
id|cleanup
suffix:semicolon
id|entry
op_assign
id|FIRST_ENTRY
c_func
(paren
id|bh
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|IS_LAST_ENTRY
c_func
(paren
id|entry
)paren
)paren
(brace
r_struct
id|ext3_xattr_entry
op_star
id|next
op_assign
id|EXT3_XATTR_NEXT
c_func
(paren
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
r_char
op_star
)paren
id|next
op_ge
id|end
)paren
r_goto
id|bad_block
suffix:semicolon
r_if
c_cond
(paren
id|name_index
op_eq
id|entry-&gt;e_name_index
op_logical_and
id|name_len
op_eq
id|entry-&gt;e_name_len
op_logical_and
id|memcmp
c_func
(paren
id|name
comma
id|entry-&gt;e_name
comma
id|name_len
)paren
op_eq
l_int|0
)paren
r_goto
id|found
suffix:semicolon
id|entry
op_assign
id|next
suffix:semicolon
)brace
multiline_comment|/* Check the remaining name entries */
r_while
c_loop
(paren
op_logical_neg
id|IS_LAST_ENTRY
c_func
(paren
id|entry
)paren
)paren
(brace
r_struct
id|ext3_xattr_entry
op_star
id|next
op_assign
id|EXT3_XATTR_NEXT
c_func
(paren
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
r_char
op_star
)paren
id|next
op_ge
id|end
)paren
r_goto
id|bad_block
suffix:semicolon
id|entry
op_assign
id|next
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ext3_xattr_cache_insert
c_func
(paren
id|bh
)paren
)paren
id|ea_idebug
c_func
(paren
id|inode
comma
l_string|&quot;cache insert failed&quot;
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|ENODATA
suffix:semicolon
r_goto
id|cleanup
suffix:semicolon
id|found
suffix:colon
multiline_comment|/* check the buffer size */
r_if
c_cond
(paren
id|entry-&gt;e_value_block
op_ne
l_int|0
)paren
r_goto
id|bad_block
suffix:semicolon
id|size
op_assign
id|le32_to_cpu
c_func
(paren
id|entry-&gt;e_value_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|size
OG
id|inode-&gt;i_sb-&gt;s_blocksize
op_logical_or
id|le16_to_cpu
c_func
(paren
id|entry-&gt;e_value_offs
)paren
op_plus
id|size
OG
id|inode-&gt;i_sb-&gt;s_blocksize
)paren
r_goto
id|bad_block
suffix:semicolon
r_if
c_cond
(paren
id|ext3_xattr_cache_insert
c_func
(paren
id|bh
)paren
)paren
id|ea_idebug
c_func
(paren
id|inode
comma
l_string|&quot;cache insert failed&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buffer
)paren
(brace
id|error
op_assign
op_minus
id|ERANGE
suffix:semicolon
r_if
c_cond
(paren
id|size
OG
id|buffer_size
)paren
r_goto
id|cleanup
suffix:semicolon
multiline_comment|/* return value of attribute */
id|memcpy
c_func
(paren
id|buffer
comma
id|bh-&gt;b_data
op_plus
id|le16_to_cpu
c_func
(paren
id|entry-&gt;e_value_offs
)paren
comma
id|size
)paren
suffix:semicolon
)brace
id|error
op_assign
id|size
suffix:semicolon
id|cleanup
suffix:colon
id|brelse
c_func
(paren
id|bh
)paren
suffix:semicolon
id|up_read
c_func
(paren
op_amp
id|EXT3_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|xattr_sem
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * ext3_xattr_list()&n; *&n; * Copy a list of attribute names into the buffer&n; * provided, or compute the buffer size required.&n; * Buffer is NULL to compute the size of the buffer required.&n; *&n; * Returns a negative error number on failure, or the number of bytes&n; * used / required on success.&n; */
r_int
DECL|function|ext3_xattr_list
id|ext3_xattr_list
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_char
op_star
id|buffer
comma
r_int
id|buffer_size
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|ext3_xattr_entry
op_star
id|entry
suffix:semicolon
r_int
id|size
op_assign
l_int|0
suffix:semicolon
r_char
op_star
id|buf
comma
op_star
id|end
suffix:semicolon
r_int
id|error
suffix:semicolon
id|ea_idebug
c_func
(paren
id|inode
comma
l_string|&quot;buffer=%p, buffer_size=%ld&quot;
comma
id|buffer
comma
(paren
r_int
)paren
id|buffer_size
)paren
suffix:semicolon
id|down_read
c_func
(paren
op_amp
id|EXT3_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|xattr_sem
)paren
suffix:semicolon
id|error
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|EXT3_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_file_acl
)paren
r_goto
id|cleanup
suffix:semicolon
id|ea_idebug
c_func
(paren
id|inode
comma
l_string|&quot;reading block %d&quot;
comma
id|EXT3_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_file_acl
)paren
suffix:semicolon
id|bh
op_assign
id|sb_bread
c_func
(paren
id|inode-&gt;i_sb
comma
id|EXT3_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_file_acl
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|EIO
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bh
)paren
r_goto
id|cleanup
suffix:semicolon
id|ea_bdebug
c_func
(paren
id|bh
comma
l_string|&quot;b_count=%d, refcount=%d&quot;
comma
id|atomic_read
c_func
(paren
op_amp
(paren
id|bh-&gt;b_count
)paren
)paren
comma
id|le32_to_cpu
c_func
(paren
id|HDR
c_func
(paren
id|bh
)paren
op_member_access_from_pointer
id|h_refcount
)paren
)paren
suffix:semicolon
id|end
op_assign
id|bh-&gt;b_data
op_plus
id|bh-&gt;b_size
suffix:semicolon
r_if
c_cond
(paren
id|HDR
c_func
(paren
id|bh
)paren
op_member_access_from_pointer
id|h_magic
op_ne
id|cpu_to_le32
c_func
(paren
id|EXT3_XATTR_MAGIC
)paren
op_logical_or
id|HDR
c_func
(paren
id|bh
)paren
op_member_access_from_pointer
id|h_blocks
op_ne
id|cpu_to_le32
c_func
(paren
l_int|1
)paren
)paren
(brace
id|bad_block
suffix:colon
id|ext3_error
c_func
(paren
id|inode-&gt;i_sb
comma
l_string|&quot;ext3_xattr_list&quot;
comma
l_string|&quot;inode %ld: bad block %d&quot;
comma
id|inode-&gt;i_ino
comma
id|EXT3_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_file_acl
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|cleanup
suffix:semicolon
)brace
multiline_comment|/* compute the size required for the list of attribute names */
r_for
c_loop
(paren
id|entry
op_assign
id|FIRST_ENTRY
c_func
(paren
id|bh
)paren
suffix:semicolon
op_logical_neg
id|IS_LAST_ENTRY
c_func
(paren
id|entry
)paren
suffix:semicolon
id|entry
op_assign
id|EXT3_XATTR_NEXT
c_func
(paren
id|entry
)paren
)paren
(brace
r_struct
id|ext3_xattr_handler
op_star
id|handler
suffix:semicolon
r_struct
id|ext3_xattr_entry
op_star
id|next
op_assign
id|EXT3_XATTR_NEXT
c_func
(paren
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
r_char
op_star
)paren
id|next
op_ge
id|end
)paren
r_goto
id|bad_block
suffix:semicolon
id|handler
op_assign
id|ext3_xattr_handler
c_func
(paren
id|entry-&gt;e_name_index
)paren
suffix:semicolon
r_if
c_cond
(paren
id|handler
)paren
id|size
op_add_assign
id|handler
op_member_access_from_pointer
id|list
c_func
(paren
l_int|NULL
comma
id|inode
comma
id|entry-&gt;e_name
comma
id|entry-&gt;e_name_len
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ext3_xattr_cache_insert
c_func
(paren
id|bh
)paren
)paren
id|ea_idebug
c_func
(paren
id|inode
comma
l_string|&quot;cache insert failed&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buffer
)paren
(brace
id|error
op_assign
id|size
suffix:semicolon
r_goto
id|cleanup
suffix:semicolon
)brace
r_else
(brace
id|error
op_assign
op_minus
id|ERANGE
suffix:semicolon
r_if
c_cond
(paren
id|size
OG
id|buffer_size
)paren
r_goto
id|cleanup
suffix:semicolon
)brace
multiline_comment|/* list the attribute names */
id|buf
op_assign
id|buffer
suffix:semicolon
r_for
c_loop
(paren
id|entry
op_assign
id|FIRST_ENTRY
c_func
(paren
id|bh
)paren
suffix:semicolon
op_logical_neg
id|IS_LAST_ENTRY
c_func
(paren
id|entry
)paren
suffix:semicolon
id|entry
op_assign
id|EXT3_XATTR_NEXT
c_func
(paren
id|entry
)paren
)paren
(brace
r_struct
id|ext3_xattr_handler
op_star
id|handler
suffix:semicolon
id|handler
op_assign
id|ext3_xattr_handler
c_func
(paren
id|entry-&gt;e_name_index
)paren
suffix:semicolon
r_if
c_cond
(paren
id|handler
)paren
id|buf
op_add_assign
id|handler
op_member_access_from_pointer
id|list
c_func
(paren
id|buf
comma
id|inode
comma
id|entry-&gt;e_name
comma
id|entry-&gt;e_name_len
)paren
suffix:semicolon
)brace
id|error
op_assign
id|size
suffix:semicolon
id|cleanup
suffix:colon
id|brelse
c_func
(paren
id|bh
)paren
suffix:semicolon
id|up_read
c_func
(paren
op_amp
id|EXT3_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|xattr_sem
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * If the EXT3_FEATURE_COMPAT_EXT_ATTR feature of this file system is&n; * not set, set it.&n; */
DECL|function|ext3_xattr_update_super_block
r_static
r_void
id|ext3_xattr_update_super_block
c_func
(paren
id|handle_t
op_star
id|handle
comma
r_struct
id|super_block
op_star
id|sb
)paren
(brace
r_if
c_cond
(paren
id|EXT3_HAS_COMPAT_FEATURE
c_func
(paren
id|sb
comma
id|EXT3_FEATURE_COMPAT_EXT_ATTR
)paren
)paren
r_return
suffix:semicolon
id|lock_super
c_func
(paren
id|sb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ext3_journal_get_write_access
c_func
(paren
id|handle
comma
id|EXT3_SB
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|s_sbh
)paren
op_eq
l_int|0
)paren
(brace
id|EXT3_SB
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|s_es-&gt;s_feature_compat
op_or_assign
id|cpu_to_le32
c_func
(paren
id|EXT3_FEATURE_COMPAT_EXT_ATTR
)paren
suffix:semicolon
id|sb-&gt;s_dirt
op_assign
l_int|1
suffix:semicolon
id|ext3_journal_dirty_metadata
c_func
(paren
id|handle
comma
id|EXT3_SB
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|s_sbh
)paren
suffix:semicolon
)brace
id|unlock_super
c_func
(paren
id|sb
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * ext3_xattr_set_handle()&n; *&n; * Create, replace or remove an extended attribute for this inode. Buffer&n; * is NULL to remove an existing extended attribute, and non-NULL to&n; * either replace an existing extended attribute, or create a new extended&n; * attribute. The flags XATTR_REPLACE and XATTR_CREATE&n; * specify that an extended attribute must exist and must not exist&n; * previous to the call, respectively.&n; *&n; * Returns 0, or a negative error number on failure.&n; */
r_int
DECL|function|ext3_xattr_set_handle
id|ext3_xattr_set_handle
c_func
(paren
id|handle_t
op_star
id|handle
comma
r_struct
id|inode
op_star
id|inode
comma
r_int
id|name_index
comma
r_const
r_char
op_star
id|name
comma
r_const
r_void
op_star
id|value
comma
r_int
id|value_len
comma
r_int
id|flags
)paren
(brace
r_struct
id|super_block
op_star
id|sb
op_assign
id|inode-&gt;i_sb
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|ext3_xattr_header
op_star
id|header
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|ext3_xattr_entry
op_star
id|here
comma
op_star
id|last
suffix:semicolon
r_int
id|name_len
comma
id|free
comma
id|min_offs
op_assign
id|sb-&gt;s_blocksize
suffix:semicolon
r_int
id|not_found
op_assign
l_int|1
comma
id|error
suffix:semicolon
r_char
op_star
id|end
suffix:semicolon
multiline_comment|/*&n;&t; * header -- Points either into bh, or to a temporarily&n;&t; *           allocated buffer.&n;&t; * here -- The named entry found, or the place for inserting, within&n;&t; *         the block pointed to by header.&n;&t; * last -- Points right after the last named entry within the block&n;&t; *         pointed to by header.&n;&t; * min_offs -- The offset of the first value (values are aligned&n;&t; *             towards the end of the block).&n;&t; * end -- Points right after the block pointed to by header.&n;&t; */
id|ea_idebug
c_func
(paren
id|inode
comma
l_string|&quot;name=%d.%s, value=%p, value_len=%ld&quot;
comma
id|name_index
comma
id|name
comma
id|value
comma
(paren
r_int
)paren
id|value_len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_RDONLY
c_func
(paren
id|inode
)paren
)paren
r_return
op_minus
id|EROFS
suffix:semicolon
r_if
c_cond
(paren
id|IS_IMMUTABLE
c_func
(paren
id|inode
)paren
op_logical_or
id|IS_APPEND
c_func
(paren
id|inode
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|value
op_eq
l_int|NULL
)paren
id|value_len
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|name
op_eq
l_int|NULL
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|name_len
op_assign
id|strlen
c_func
(paren
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|name_len
OG
l_int|255
op_logical_or
id|value_len
OG
id|sb-&gt;s_blocksize
)paren
r_return
op_minus
id|ERANGE
suffix:semicolon
id|down_write
c_func
(paren
op_amp
id|EXT3_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|xattr_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|EXT3_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_file_acl
)paren
(brace
multiline_comment|/* The inode already has an extended attribute block. */
id|bh
op_assign
id|sb_bread
c_func
(paren
id|sb
comma
id|EXT3_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_file_acl
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|EIO
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bh
)paren
r_goto
id|cleanup
suffix:semicolon
id|ea_bdebug
c_func
(paren
id|bh
comma
l_string|&quot;b_count=%d, refcount=%d&quot;
comma
id|atomic_read
c_func
(paren
op_amp
(paren
id|bh-&gt;b_count
)paren
)paren
comma
id|le32_to_cpu
c_func
(paren
id|HDR
c_func
(paren
id|bh
)paren
op_member_access_from_pointer
id|h_refcount
)paren
)paren
suffix:semicolon
id|header
op_assign
id|HDR
c_func
(paren
id|bh
)paren
suffix:semicolon
id|end
op_assign
id|bh-&gt;b_data
op_plus
id|bh-&gt;b_size
suffix:semicolon
r_if
c_cond
(paren
id|header-&gt;h_magic
op_ne
id|cpu_to_le32
c_func
(paren
id|EXT3_XATTR_MAGIC
)paren
op_logical_or
id|header-&gt;h_blocks
op_ne
id|cpu_to_le32
c_func
(paren
l_int|1
)paren
)paren
(brace
id|bad_block
suffix:colon
id|ext3_error
c_func
(paren
id|sb
comma
l_string|&quot;ext3_xattr_set&quot;
comma
l_string|&quot;inode %ld: bad block %d&quot;
comma
id|inode-&gt;i_ino
comma
id|EXT3_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_file_acl
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|cleanup
suffix:semicolon
)brace
multiline_comment|/* Find the named attribute. */
id|here
op_assign
id|FIRST_ENTRY
c_func
(paren
id|bh
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|IS_LAST_ENTRY
c_func
(paren
id|here
)paren
)paren
(brace
r_struct
id|ext3_xattr_entry
op_star
id|next
op_assign
id|EXT3_XATTR_NEXT
c_func
(paren
id|here
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
r_char
op_star
)paren
id|next
op_ge
id|end
)paren
r_goto
id|bad_block
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|here-&gt;e_value_block
op_logical_and
id|here-&gt;e_value_size
)paren
(brace
r_int
id|offs
op_assign
id|le16_to_cpu
c_func
(paren
id|here-&gt;e_value_offs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|offs
OL
id|min_offs
)paren
id|min_offs
op_assign
id|offs
suffix:semicolon
)brace
id|not_found
op_assign
id|name_index
op_minus
id|here-&gt;e_name_index
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|not_found
)paren
id|not_found
op_assign
id|name_len
op_minus
id|here-&gt;e_name_len
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|not_found
)paren
id|not_found
op_assign
id|memcmp
c_func
(paren
id|name
comma
id|here-&gt;e_name
comma
id|name_len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|not_found
op_le
l_int|0
)paren
r_break
suffix:semicolon
id|here
op_assign
id|next
suffix:semicolon
)brace
id|last
op_assign
id|here
suffix:semicolon
multiline_comment|/* We still need to compute min_offs and last. */
r_while
c_loop
(paren
op_logical_neg
id|IS_LAST_ENTRY
c_func
(paren
id|last
)paren
)paren
(brace
r_struct
id|ext3_xattr_entry
op_star
id|next
op_assign
id|EXT3_XATTR_NEXT
c_func
(paren
id|last
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
r_char
op_star
)paren
id|next
op_ge
id|end
)paren
r_goto
id|bad_block
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|last-&gt;e_value_block
op_logical_and
id|last-&gt;e_value_size
)paren
(brace
r_int
id|offs
op_assign
id|le16_to_cpu
c_func
(paren
id|last-&gt;e_value_offs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|offs
OL
id|min_offs
)paren
id|min_offs
op_assign
id|offs
suffix:semicolon
)brace
id|last
op_assign
id|next
suffix:semicolon
)brace
multiline_comment|/* Check whether we have enough space left. */
id|free
op_assign
id|min_offs
op_minus
(paren
(paren
r_char
op_star
)paren
id|last
op_minus
(paren
r_char
op_star
)paren
id|header
)paren
op_minus
r_sizeof
(paren
id|__u32
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* We will use a new extended attribute block. */
id|free
op_assign
id|sb-&gt;s_blocksize
op_minus
r_sizeof
(paren
r_struct
id|ext3_xattr_header
)paren
op_minus
r_sizeof
(paren
id|__u32
)paren
suffix:semicolon
id|here
op_assign
id|last
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* avoid gcc uninitialized warning. */
)brace
r_if
c_cond
(paren
id|not_found
)paren
(brace
multiline_comment|/* Request to remove a nonexistent attribute? */
id|error
op_assign
op_minus
id|ENODATA
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|XATTR_REPLACE
)paren
r_goto
id|cleanup
suffix:semicolon
id|error
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|value
op_eq
l_int|NULL
)paren
r_goto
id|cleanup
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Request to create an existing attribute? */
id|error
op_assign
op_minus
id|EEXIST
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|XATTR_CREATE
)paren
r_goto
id|cleanup
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|here-&gt;e_value_block
op_logical_and
id|here-&gt;e_value_size
)paren
(brace
r_int
id|size
op_assign
id|le32_to_cpu
c_func
(paren
id|here-&gt;e_value_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|le16_to_cpu
c_func
(paren
id|here-&gt;e_value_offs
)paren
op_plus
id|size
OG
id|sb-&gt;s_blocksize
op_logical_or
id|size
OG
id|sb-&gt;s_blocksize
)paren
r_goto
id|bad_block
suffix:semicolon
id|free
op_add_assign
id|EXT3_XATTR_SIZE
c_func
(paren
id|size
)paren
suffix:semicolon
)brace
id|free
op_add_assign
id|EXT3_XATTR_LEN
c_func
(paren
id|name_len
)paren
suffix:semicolon
)brace
id|error
op_assign
op_minus
id|ENOSPC
suffix:semicolon
r_if
c_cond
(paren
id|free
OL
id|EXT3_XATTR_LEN
c_func
(paren
id|name_len
)paren
op_plus
id|EXT3_XATTR_SIZE
c_func
(paren
id|value_len
)paren
)paren
r_goto
id|cleanup
suffix:semicolon
multiline_comment|/* Here we know that we can set the new attribute. */
r_if
c_cond
(paren
id|header
)paren
(brace
r_int
id|credits
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* assert(header == HDR(bh)); */
r_if
c_cond
(paren
id|header-&gt;h_refcount
op_ne
id|cpu_to_le32
c_func
(paren
l_int|1
)paren
)paren
r_goto
id|skip_get_write_access
suffix:semicolon
multiline_comment|/* ext3_journal_get_write_access() requires an unlocked bh,&n;&t;&t;   which complicates things here. */
id|error
op_assign
id|ext3_journal_get_write_access_credits
c_func
(paren
id|handle
comma
id|bh
comma
op_amp
id|credits
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|cleanup
suffix:semicolon
id|lock_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|header-&gt;h_refcount
op_eq
id|cpu_to_le32
c_func
(paren
l_int|1
)paren
)paren
(brace
id|ea_bdebug
c_func
(paren
id|bh
comma
l_string|&quot;modifying in-place&quot;
)paren
suffix:semicolon
id|ext3_xattr_cache_remove
c_func
(paren
id|bh
)paren
suffix:semicolon
multiline_comment|/* keep the buffer locked while modifying it. */
)brace
r_else
(brace
r_int
id|offset
suffix:semicolon
id|unlock_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
id|journal_release_buffer
c_func
(paren
id|handle
comma
id|bh
comma
id|credits
)paren
suffix:semicolon
id|skip_get_write_access
suffix:colon
id|ea_bdebug
c_func
(paren
id|bh
comma
l_string|&quot;cloning&quot;
)paren
suffix:semicolon
id|header
op_assign
id|kmalloc
c_func
(paren
id|bh-&gt;b_size
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
id|header
op_eq
l_int|NULL
)paren
r_goto
id|cleanup
suffix:semicolon
id|memcpy
c_func
(paren
id|header
comma
id|HDR
c_func
(paren
id|bh
)paren
comma
id|bh-&gt;b_size
)paren
suffix:semicolon
id|header-&gt;h_refcount
op_assign
id|cpu_to_le32
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|offset
op_assign
(paren
r_char
op_star
)paren
id|here
op_minus
id|bh-&gt;b_data
suffix:semicolon
id|here
op_assign
id|ENTRY
c_func
(paren
(paren
r_char
op_star
)paren
id|header
op_plus
id|offset
)paren
suffix:semicolon
id|offset
op_assign
(paren
r_char
op_star
)paren
id|last
op_minus
id|bh-&gt;b_data
suffix:semicolon
id|last
op_assign
id|ENTRY
c_func
(paren
(paren
r_char
op_star
)paren
id|header
op_plus
id|offset
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* Allocate a buffer where we construct the new block. */
id|header
op_assign
id|kmalloc
c_func
(paren
id|sb-&gt;s_blocksize
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
id|header
op_eq
l_int|NULL
)paren
r_goto
id|cleanup
suffix:semicolon
id|memset
c_func
(paren
id|header
comma
l_int|0
comma
id|sb-&gt;s_blocksize
)paren
suffix:semicolon
id|end
op_assign
(paren
r_char
op_star
)paren
id|header
op_plus
id|sb-&gt;s_blocksize
suffix:semicolon
id|header-&gt;h_magic
op_assign
id|cpu_to_le32
c_func
(paren
id|EXT3_XATTR_MAGIC
)paren
suffix:semicolon
id|header-&gt;h_blocks
op_assign
id|header-&gt;h_refcount
op_assign
id|cpu_to_le32
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|last
op_assign
id|here
op_assign
id|ENTRY
c_func
(paren
id|header
op_plus
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* Iff we are modifying the block in-place, bh is locked here. */
r_if
c_cond
(paren
id|not_found
)paren
(brace
multiline_comment|/* Insert the new name. */
r_int
id|size
op_assign
id|EXT3_XATTR_LEN
c_func
(paren
id|name_len
)paren
suffix:semicolon
r_int
id|rest
op_assign
(paren
r_char
op_star
)paren
id|last
op_minus
(paren
r_char
op_star
)paren
id|here
suffix:semicolon
id|memmove
c_func
(paren
(paren
r_char
op_star
)paren
id|here
op_plus
id|size
comma
id|here
comma
id|rest
)paren
suffix:semicolon
id|memset
c_func
(paren
id|here
comma
l_int|0
comma
id|size
)paren
suffix:semicolon
id|here-&gt;e_name_index
op_assign
id|name_index
suffix:semicolon
id|here-&gt;e_name_len
op_assign
id|name_len
suffix:semicolon
id|memcpy
c_func
(paren
id|here-&gt;e_name
comma
id|name
comma
id|name_len
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
id|here-&gt;e_value_block
op_logical_and
id|here-&gt;e_value_size
)paren
(brace
r_char
op_star
id|first_val
op_assign
(paren
r_char
op_star
)paren
id|header
op_plus
id|min_offs
suffix:semicolon
r_int
id|offs
op_assign
id|le16_to_cpu
c_func
(paren
id|here-&gt;e_value_offs
)paren
suffix:semicolon
r_char
op_star
id|val
op_assign
(paren
r_char
op_star
)paren
id|header
op_plus
id|offs
suffix:semicolon
r_int
id|size
op_assign
id|EXT3_XATTR_SIZE
c_func
(paren
id|le32_to_cpu
c_func
(paren
id|here-&gt;e_value_size
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|size
op_eq
id|EXT3_XATTR_SIZE
c_func
(paren
id|value_len
)paren
)paren
(brace
multiline_comment|/* The old and the new value have the same&n;&t;&t;&t;&t;   size. Just replace. */
id|here-&gt;e_value_size
op_assign
id|cpu_to_le32
c_func
(paren
id|value_len
)paren
suffix:semicolon
id|memset
c_func
(paren
id|val
op_plus
id|size
op_minus
id|EXT3_XATTR_PAD
comma
l_int|0
comma
id|EXT3_XATTR_PAD
)paren
suffix:semicolon
multiline_comment|/* Clear pad bytes. */
id|memcpy
c_func
(paren
id|val
comma
id|value
comma
id|value_len
)paren
suffix:semicolon
r_goto
id|skip_replace
suffix:semicolon
)brace
multiline_comment|/* Remove the old value. */
id|memmove
c_func
(paren
id|first_val
op_plus
id|size
comma
id|first_val
comma
id|val
op_minus
id|first_val
)paren
suffix:semicolon
id|memset
c_func
(paren
id|first_val
comma
l_int|0
comma
id|size
)paren
suffix:semicolon
id|here-&gt;e_value_offs
op_assign
l_int|0
suffix:semicolon
id|min_offs
op_add_assign
id|size
suffix:semicolon
multiline_comment|/* Adjust all value offsets. */
id|last
op_assign
id|ENTRY
c_func
(paren
id|header
op_plus
l_int|1
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|IS_LAST_ENTRY
c_func
(paren
id|last
)paren
)paren
(brace
r_int
id|o
op_assign
id|le16_to_cpu
c_func
(paren
id|last-&gt;e_value_offs
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|last-&gt;e_value_block
op_logical_and
id|o
OL
id|offs
)paren
id|last-&gt;e_value_offs
op_assign
id|cpu_to_le16
c_func
(paren
id|o
op_plus
id|size
)paren
suffix:semicolon
id|last
op_assign
id|EXT3_XATTR_NEXT
c_func
(paren
id|last
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|value
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* Remove the old name. */
r_int
id|size
op_assign
id|EXT3_XATTR_LEN
c_func
(paren
id|name_len
)paren
suffix:semicolon
id|last
op_assign
id|ENTRY
c_func
(paren
(paren
r_char
op_star
)paren
id|last
op_minus
id|size
)paren
suffix:semicolon
id|memmove
c_func
(paren
id|here
comma
(paren
r_char
op_star
)paren
id|here
op_plus
id|size
comma
(paren
r_char
op_star
)paren
id|last
op_minus
(paren
r_char
op_star
)paren
id|here
)paren
suffix:semicolon
id|memset
c_func
(paren
id|last
comma
l_int|0
comma
id|size
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|value
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* Insert the new value. */
id|here-&gt;e_value_size
op_assign
id|cpu_to_le32
c_func
(paren
id|value_len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|value_len
)paren
(brace
r_int
id|size
op_assign
id|EXT3_XATTR_SIZE
c_func
(paren
id|value_len
)paren
suffix:semicolon
r_char
op_star
id|val
op_assign
(paren
r_char
op_star
)paren
id|header
op_plus
id|min_offs
op_minus
id|size
suffix:semicolon
id|here-&gt;e_value_offs
op_assign
id|cpu_to_le16
c_func
(paren
(paren
r_char
op_star
)paren
id|val
op_minus
(paren
r_char
op_star
)paren
id|header
)paren
suffix:semicolon
id|memset
c_func
(paren
id|val
op_plus
id|size
op_minus
id|EXT3_XATTR_PAD
comma
l_int|0
comma
id|EXT3_XATTR_PAD
)paren
suffix:semicolon
multiline_comment|/* Clear the pad bytes. */
id|memcpy
c_func
(paren
id|val
comma
id|value
comma
id|value_len
)paren
suffix:semicolon
)brace
)brace
id|skip_replace
suffix:colon
r_if
c_cond
(paren
id|IS_LAST_ENTRY
c_func
(paren
id|ENTRY
c_func
(paren
id|header
op_plus
l_int|1
)paren
)paren
)paren
(brace
multiline_comment|/* This block is now empty. */
r_if
c_cond
(paren
id|bh
op_logical_and
id|header
op_eq
id|HDR
c_func
(paren
id|bh
)paren
)paren
id|unlock_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
multiline_comment|/* we were modifying in-place. */
id|error
op_assign
id|ext3_xattr_set_handle2
c_func
(paren
id|handle
comma
id|inode
comma
id|bh
comma
l_int|NULL
)paren
suffix:semicolon
)brace
r_else
(brace
id|ext3_xattr_rehash
c_func
(paren
id|header
comma
id|here
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bh
op_logical_and
id|header
op_eq
id|HDR
c_func
(paren
id|bh
)paren
)paren
id|unlock_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
multiline_comment|/* we were modifying in-place. */
id|error
op_assign
id|ext3_xattr_set_handle2
c_func
(paren
id|handle
comma
id|inode
comma
id|bh
comma
id|header
)paren
suffix:semicolon
)brace
id|cleanup
suffix:colon
id|brelse
c_func
(paren
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|bh
op_logical_and
id|header
op_eq
id|HDR
c_func
(paren
id|bh
)paren
)paren
)paren
id|kfree
c_func
(paren
id|header
)paren
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|EXT3_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|xattr_sem
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * Second half of ext3_xattr_set_handle(): Update the file system.&n; */
r_static
r_int
DECL|function|ext3_xattr_set_handle2
id|ext3_xattr_set_handle2
c_func
(paren
id|handle_t
op_star
id|handle
comma
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|buffer_head
op_star
id|old_bh
comma
r_struct
id|ext3_xattr_header
op_star
id|header
)paren
(brace
r_struct
id|super_block
op_star
id|sb
op_assign
id|inode-&gt;i_sb
suffix:semicolon
r_struct
id|buffer_head
op_star
id|new_bh
op_assign
l_int|NULL
suffix:semicolon
r_int
id|credits
op_assign
l_int|0
comma
id|error
suffix:semicolon
r_if
c_cond
(paren
id|header
)paren
(brace
id|new_bh
op_assign
id|ext3_xattr_cache_find
c_func
(paren
id|handle
comma
id|inode
comma
id|header
comma
op_amp
id|credits
)paren
suffix:semicolon
r_if
c_cond
(paren
id|new_bh
)paren
(brace
multiline_comment|/* We found an identical block in the cache. */
r_if
c_cond
(paren
id|new_bh
op_eq
id|old_bh
)paren
id|ea_bdebug
c_func
(paren
id|new_bh
comma
l_string|&quot;keeping this block&quot;
)paren
suffix:semicolon
r_else
(brace
multiline_comment|/* The old block is released after updating&n;&t;&t;&t;&t;   the inode. */
id|ea_bdebug
c_func
(paren
id|new_bh
comma
l_string|&quot;reusing block&quot;
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|EDQUOT
suffix:semicolon
r_if
c_cond
(paren
id|DQUOT_ALLOC_BLOCK
c_func
(paren
id|inode
comma
l_int|1
)paren
)paren
(brace
id|unlock_buffer
c_func
(paren
id|new_bh
)paren
suffix:semicolon
id|journal_release_buffer
c_func
(paren
id|handle
comma
id|new_bh
comma
id|credits
)paren
suffix:semicolon
r_goto
id|cleanup
suffix:semicolon
)brace
id|HDR
c_func
(paren
id|new_bh
)paren
op_member_access_from_pointer
id|h_refcount
op_assign
id|cpu_to_le32
c_func
(paren
l_int|1
op_plus
id|le32_to_cpu
c_func
(paren
id|HDR
c_func
(paren
id|new_bh
)paren
op_member_access_from_pointer
id|h_refcount
)paren
)paren
suffix:semicolon
id|ea_bdebug
c_func
(paren
id|new_bh
comma
l_string|&quot;refcount now=%d&quot;
comma
id|le32_to_cpu
c_func
(paren
id|HDR
c_func
(paren
id|new_bh
)paren
op_member_access_from_pointer
id|h_refcount
)paren
)paren
suffix:semicolon
)brace
id|unlock_buffer
c_func
(paren
id|new_bh
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|old_bh
op_logical_and
id|header
op_eq
id|HDR
c_func
(paren
id|old_bh
)paren
)paren
(brace
multiline_comment|/* Keep this block. No need to lock the block as we&n;&t;&t;&t; * don&squot;t need to change the reference count. */
id|new_bh
op_assign
id|old_bh
suffix:semicolon
id|get_bh
c_func
(paren
id|new_bh
)paren
suffix:semicolon
id|ext3_xattr_cache_insert
c_func
(paren
id|new_bh
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* We need to allocate a new block */
r_int
id|goal
op_assign
id|le32_to_cpu
c_func
(paren
id|EXT3_SB
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|s_es-&gt;s_first_data_block
)paren
op_plus
id|EXT3_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_block_group
op_star
id|EXT3_BLOCKS_PER_GROUP
c_func
(paren
id|sb
)paren
suffix:semicolon
r_int
id|block
op_assign
id|ext3_new_block
c_func
(paren
id|handle
comma
id|inode
comma
id|goal
comma
l_int|NULL
comma
l_int|NULL
comma
op_amp
id|error
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|cleanup
suffix:semicolon
id|ea_idebug
c_func
(paren
id|inode
comma
l_string|&quot;creating block %d&quot;
comma
id|block
)paren
suffix:semicolon
id|new_bh
op_assign
id|sb_getblk
c_func
(paren
id|sb
comma
id|block
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|new_bh
)paren
(brace
id|getblk_failed
suffix:colon
id|ext3_free_blocks
c_func
(paren
id|handle
comma
id|inode
comma
id|block
comma
l_int|1
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|cleanup
suffix:semicolon
)brace
id|lock_buffer
c_func
(paren
id|new_bh
)paren
suffix:semicolon
id|error
op_assign
id|ext3_journal_get_create_access
c_func
(paren
id|handle
comma
id|new_bh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|unlock_buffer
c_func
(paren
id|new_bh
)paren
suffix:semicolon
r_goto
id|getblk_failed
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|new_bh-&gt;b_data
comma
id|header
comma
id|new_bh-&gt;b_size
)paren
suffix:semicolon
id|set_buffer_uptodate
c_func
(paren
id|new_bh
)paren
suffix:semicolon
id|unlock_buffer
c_func
(paren
id|new_bh
)paren
suffix:semicolon
id|ext3_xattr_cache_insert
c_func
(paren
id|new_bh
)paren
suffix:semicolon
id|ext3_xattr_update_super_block
c_func
(paren
id|handle
comma
id|sb
)paren
suffix:semicolon
)brace
id|error
op_assign
id|ext3_journal_dirty_metadata
c_func
(paren
id|handle
comma
id|new_bh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|cleanup
suffix:semicolon
)brace
multiline_comment|/* Update the inode. */
id|EXT3_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_file_acl
op_assign
id|new_bh
ques
c_cond
id|new_bh-&gt;b_blocknr
suffix:colon
l_int|0
suffix:semicolon
id|inode-&gt;i_ctime
op_assign
id|CURRENT_TIME
suffix:semicolon
id|ext3_mark_inode_dirty
c_func
(paren
id|handle
comma
id|inode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_SYNC
c_func
(paren
id|inode
)paren
)paren
id|handle-&gt;h_sync
op_assign
l_int|1
suffix:semicolon
id|error
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|old_bh
op_logical_and
id|old_bh
op_ne
id|new_bh
)paren
(brace
multiline_comment|/*&n;&t;&t; * If there was an old block, and we are no longer using it,&n;&t;&t; * release the old block.&n;&t;&t;*/
id|error
op_assign
id|ext3_journal_get_write_access
c_func
(paren
id|handle
comma
id|old_bh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|cleanup
suffix:semicolon
id|lock_buffer
c_func
(paren
id|old_bh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|HDR
c_func
(paren
id|old_bh
)paren
op_member_access_from_pointer
id|h_refcount
op_eq
id|cpu_to_le32
c_func
(paren
l_int|1
)paren
)paren
(brace
multiline_comment|/* Free the old block. */
id|ea_bdebug
c_func
(paren
id|old_bh
comma
l_string|&quot;freeing&quot;
)paren
suffix:semicolon
id|ext3_free_blocks
c_func
(paren
id|handle
comma
id|inode
comma
id|old_bh-&gt;b_blocknr
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* ext3_forget() calls bforget() for us, but we&n;&t;&t;&t;   let our caller release old_bh, so we need to&n;&t;&t;&t;   duplicate the handle before. */
id|get_bh
c_func
(paren
id|old_bh
)paren
suffix:semicolon
id|ext3_forget
c_func
(paren
id|handle
comma
l_int|1
comma
id|inode
comma
id|old_bh
comma
id|old_bh-&gt;b_blocknr
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Decrement the refcount only. */
id|HDR
c_func
(paren
id|old_bh
)paren
op_member_access_from_pointer
id|h_refcount
op_assign
id|cpu_to_le32
c_func
(paren
id|le32_to_cpu
c_func
(paren
id|HDR
c_func
(paren
id|old_bh
)paren
op_member_access_from_pointer
id|h_refcount
)paren
op_minus
l_int|1
)paren
suffix:semicolon
id|DQUOT_FREE_BLOCK
c_func
(paren
id|inode
comma
l_int|1
)paren
suffix:semicolon
id|ext3_journal_dirty_metadata
c_func
(paren
id|handle
comma
id|old_bh
)paren
suffix:semicolon
id|ea_bdebug
c_func
(paren
id|old_bh
comma
l_string|&quot;refcount now=%d&quot;
comma
id|le32_to_cpu
c_func
(paren
id|HDR
c_func
(paren
id|old_bh
)paren
op_member_access_from_pointer
id|h_refcount
)paren
)paren
suffix:semicolon
)brace
id|unlock_buffer
c_func
(paren
id|old_bh
)paren
suffix:semicolon
)brace
id|cleanup
suffix:colon
id|brelse
c_func
(paren
id|new_bh
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * ext3_xattr_set()&n; *&n; * Like ext3_xattr_set_handle, but start from an inode. This extended&n; * attribute modification is a filesystem transaction by itself.&n; *&n; * Returns 0, or a negative error number on failure.&n; */
r_int
DECL|function|ext3_xattr_set
id|ext3_xattr_set
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_int
id|name_index
comma
r_const
r_char
op_star
id|name
comma
r_const
r_void
op_star
id|value
comma
r_int
id|value_len
comma
r_int
id|flags
)paren
(brace
id|handle_t
op_star
id|handle
suffix:semicolon
r_int
id|error
comma
id|retries
op_assign
l_int|0
suffix:semicolon
id|retry
suffix:colon
id|handle
op_assign
id|ext3_journal_start
c_func
(paren
id|inode
comma
id|EXT3_DATA_TRANS_BLOCKS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|handle
)paren
)paren
(brace
id|error
op_assign
id|PTR_ERR
c_func
(paren
id|handle
)paren
suffix:semicolon
)brace
r_else
(brace
r_int
id|error2
suffix:semicolon
id|error
op_assign
id|ext3_xattr_set_handle
c_func
(paren
id|handle
comma
id|inode
comma
id|name_index
comma
id|name
comma
id|value
comma
id|value_len
comma
id|flags
)paren
suffix:semicolon
id|error2
op_assign
id|ext3_journal_stop
c_func
(paren
id|handle
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_eq
op_minus
id|ENOSPC
op_logical_and
id|ext3_should_retry_alloc
c_func
(paren
id|inode-&gt;i_sb
comma
op_amp
id|retries
)paren
)paren
r_goto
id|retry
suffix:semicolon
r_if
c_cond
(paren
id|error
op_eq
l_int|0
)paren
id|error
op_assign
id|error2
suffix:semicolon
)brace
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * ext3_xattr_delete_inode()&n; *&n; * Free extended attribute resources associated with this inode. This&n; * is called immediately before an inode is freed.&n; */
r_void
DECL|function|ext3_xattr_delete_inode
id|ext3_xattr_delete_inode
c_func
(paren
id|handle_t
op_star
id|handle
comma
r_struct
id|inode
op_star
id|inode
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
op_assign
l_int|NULL
suffix:semicolon
id|down_write
c_func
(paren
op_amp
id|EXT3_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|xattr_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|EXT3_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_file_acl
)paren
r_goto
id|cleanup
suffix:semicolon
id|bh
op_assign
id|sb_bread
c_func
(paren
id|inode-&gt;i_sb
comma
id|EXT3_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_file_acl
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bh
)paren
(brace
id|ext3_error
c_func
(paren
id|inode-&gt;i_sb
comma
l_string|&quot;ext3_xattr_delete_inode&quot;
comma
l_string|&quot;inode %ld: block %d read error&quot;
comma
id|inode-&gt;i_ino
comma
id|EXT3_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_file_acl
)paren
suffix:semicolon
r_goto
id|cleanup
suffix:semicolon
)brace
r_if
c_cond
(paren
id|HDR
c_func
(paren
id|bh
)paren
op_member_access_from_pointer
id|h_magic
op_ne
id|cpu_to_le32
c_func
(paren
id|EXT3_XATTR_MAGIC
)paren
op_logical_or
id|HDR
c_func
(paren
id|bh
)paren
op_member_access_from_pointer
id|h_blocks
op_ne
id|cpu_to_le32
c_func
(paren
l_int|1
)paren
)paren
(brace
id|ext3_error
c_func
(paren
id|inode-&gt;i_sb
comma
l_string|&quot;ext3_xattr_delete_inode&quot;
comma
l_string|&quot;inode %ld: bad block %d&quot;
comma
id|inode-&gt;i_ino
comma
id|EXT3_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_file_acl
)paren
suffix:semicolon
r_goto
id|cleanup
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ext3_journal_get_write_access
c_func
(paren
id|handle
comma
id|bh
)paren
op_ne
l_int|0
)paren
r_goto
id|cleanup
suffix:semicolon
id|lock_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|HDR
c_func
(paren
id|bh
)paren
op_member_access_from_pointer
id|h_refcount
op_eq
id|cpu_to_le32
c_func
(paren
l_int|1
)paren
)paren
(brace
id|ext3_xattr_cache_remove
c_func
(paren
id|bh
)paren
suffix:semicolon
id|ext3_free_blocks
c_func
(paren
id|handle
comma
id|inode
comma
id|EXT3_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_file_acl
comma
l_int|1
)paren
suffix:semicolon
id|get_bh
c_func
(paren
id|bh
)paren
suffix:semicolon
id|ext3_forget
c_func
(paren
id|handle
comma
l_int|1
comma
id|inode
comma
id|bh
comma
id|EXT3_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_file_acl
)paren
suffix:semicolon
)brace
r_else
(brace
id|HDR
c_func
(paren
id|bh
)paren
op_member_access_from_pointer
id|h_refcount
op_assign
id|cpu_to_le32
c_func
(paren
id|le32_to_cpu
c_func
(paren
id|HDR
c_func
(paren
id|bh
)paren
op_member_access_from_pointer
id|h_refcount
)paren
op_minus
l_int|1
)paren
suffix:semicolon
id|ext3_journal_dirty_metadata
c_func
(paren
id|handle
comma
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_SYNC
c_func
(paren
id|inode
)paren
)paren
id|handle-&gt;h_sync
op_assign
l_int|1
suffix:semicolon
id|DQUOT_FREE_BLOCK
c_func
(paren
id|inode
comma
l_int|1
)paren
suffix:semicolon
)brace
id|ea_bdebug
c_func
(paren
id|bh
comma
l_string|&quot;refcount now=%d&quot;
comma
id|le32_to_cpu
c_func
(paren
id|HDR
c_func
(paren
id|bh
)paren
op_member_access_from_pointer
id|h_refcount
)paren
op_minus
l_int|1
)paren
suffix:semicolon
id|unlock_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
id|EXT3_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_file_acl
op_assign
l_int|0
suffix:semicolon
id|cleanup
suffix:colon
id|brelse
c_func
(paren
id|bh
)paren
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|EXT3_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|xattr_sem
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * ext3_xattr_put_super()&n; *&n; * This is called when a file system is unmounted.&n; */
r_void
DECL|function|ext3_xattr_put_super
id|ext3_xattr_put_super
c_func
(paren
r_struct
id|super_block
op_star
id|sb
)paren
(brace
id|mb_cache_shrink
c_func
(paren
id|ext3_xattr_cache
comma
id|sb-&gt;s_bdev
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * ext3_xattr_cache_insert()&n; *&n; * Create a new entry in the extended attribute cache, and insert&n; * it unless such an entry is already in the cache.&n; *&n; * Returns 0, or a negative error number on failure.&n; */
r_static
r_int
DECL|function|ext3_xattr_cache_insert
id|ext3_xattr_cache_insert
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
id|__u32
id|hash
op_assign
id|le32_to_cpu
c_func
(paren
id|HDR
c_func
(paren
id|bh
)paren
op_member_access_from_pointer
id|h_hash
)paren
suffix:semicolon
r_struct
id|mb_cache_entry
op_star
id|ce
suffix:semicolon
r_int
id|error
suffix:semicolon
id|ce
op_assign
id|mb_cache_entry_alloc
c_func
(paren
id|ext3_xattr_cache
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ce
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|error
op_assign
id|mb_cache_entry_insert
c_func
(paren
id|ce
comma
id|bh-&gt;b_bdev
comma
id|bh-&gt;b_blocknr
comma
op_amp
id|hash
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|mb_cache_entry_free
c_func
(paren
id|ce
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_eq
op_minus
id|EBUSY
)paren
(brace
id|ea_bdebug
c_func
(paren
id|bh
comma
l_string|&quot;already in cache (%d cache entries)&quot;
comma
id|atomic_read
c_func
(paren
op_amp
id|ext3_xattr_cache-&gt;c_entry_count
)paren
)paren
suffix:semicolon
id|error
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_else
(brace
id|ea_bdebug
c_func
(paren
id|bh
comma
l_string|&quot;inserting [%x] (%d cache entries)&quot;
comma
(paren
r_int
)paren
id|hash
comma
id|atomic_read
c_func
(paren
op_amp
id|ext3_xattr_cache-&gt;c_entry_count
)paren
)paren
suffix:semicolon
id|mb_cache_entry_release
c_func
(paren
id|ce
)paren
suffix:semicolon
)brace
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * ext3_xattr_cmp()&n; *&n; * Compare two extended attribute blocks for equality.&n; *&n; * Returns 0 if the blocks are equal, 1 if they differ, and&n; * a negative error number on errors.&n; */
r_static
r_int
DECL|function|ext3_xattr_cmp
id|ext3_xattr_cmp
c_func
(paren
r_struct
id|ext3_xattr_header
op_star
id|header1
comma
r_struct
id|ext3_xattr_header
op_star
id|header2
)paren
(brace
r_struct
id|ext3_xattr_entry
op_star
id|entry1
comma
op_star
id|entry2
suffix:semicolon
id|entry1
op_assign
id|ENTRY
c_func
(paren
id|header1
op_plus
l_int|1
)paren
suffix:semicolon
id|entry2
op_assign
id|ENTRY
c_func
(paren
id|header2
op_plus
l_int|1
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|IS_LAST_ENTRY
c_func
(paren
id|entry1
)paren
)paren
(brace
r_if
c_cond
(paren
id|IS_LAST_ENTRY
c_func
(paren
id|entry2
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|entry1-&gt;e_hash
op_ne
id|entry2-&gt;e_hash
op_logical_or
id|entry1-&gt;e_name_len
op_ne
id|entry2-&gt;e_name_len
op_logical_or
id|entry1-&gt;e_value_size
op_ne
id|entry2-&gt;e_value_size
op_logical_or
id|memcmp
c_func
(paren
id|entry1-&gt;e_name
comma
id|entry2-&gt;e_name
comma
id|entry1-&gt;e_name_len
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|entry1-&gt;e_value_block
op_ne
l_int|0
op_logical_or
id|entry2-&gt;e_value_block
op_ne
l_int|0
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_if
c_cond
(paren
id|memcmp
c_func
(paren
(paren
r_char
op_star
)paren
id|header1
op_plus
id|le16_to_cpu
c_func
(paren
id|entry1-&gt;e_value_offs
)paren
comma
(paren
r_char
op_star
)paren
id|header2
op_plus
id|le16_to_cpu
c_func
(paren
id|entry2-&gt;e_value_offs
)paren
comma
id|le32_to_cpu
c_func
(paren
id|entry1-&gt;e_value_size
)paren
)paren
)paren
r_return
l_int|1
suffix:semicolon
id|entry1
op_assign
id|EXT3_XATTR_NEXT
c_func
(paren
id|entry1
)paren
suffix:semicolon
id|entry2
op_assign
id|EXT3_XATTR_NEXT
c_func
(paren
id|entry2
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|IS_LAST_ENTRY
c_func
(paren
id|entry2
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * ext3_xattr_cache_find()&n; *&n; * Find an identical extended attribute block.&n; *&n; * Returns a pointer to the block found, or NULL if such a block was&n; * not found or an error occurred.&n; */
r_static
r_struct
id|buffer_head
op_star
DECL|function|ext3_xattr_cache_find
id|ext3_xattr_cache_find
c_func
(paren
id|handle_t
op_star
id|handle
comma
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|ext3_xattr_header
op_star
id|header
comma
r_int
op_star
id|credits
)paren
(brace
id|__u32
id|hash
op_assign
id|le32_to_cpu
c_func
(paren
id|header-&gt;h_hash
)paren
suffix:semicolon
r_struct
id|mb_cache_entry
op_star
id|ce
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|header-&gt;h_hash
)paren
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/* never share */
id|ea_idebug
c_func
(paren
id|inode
comma
l_string|&quot;looking for cached blocks [%x]&quot;
comma
(paren
r_int
)paren
id|hash
)paren
suffix:semicolon
id|ce
op_assign
id|mb_cache_entry_find_first
c_func
(paren
id|ext3_xattr_cache
comma
l_int|0
comma
id|inode-&gt;i_sb-&gt;s_bdev
comma
id|hash
)paren
suffix:semicolon
r_while
c_loop
(paren
id|ce
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
op_assign
id|sb_bread
c_func
(paren
id|inode-&gt;i_sb
comma
id|ce-&gt;e_block
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bh
)paren
(brace
id|ext3_error
c_func
(paren
id|inode-&gt;i_sb
comma
l_string|&quot;ext3_xattr_cache_find&quot;
comma
l_string|&quot;inode %ld: block %ld read error&quot;
comma
id|inode-&gt;i_ino
comma
(paren
r_int
r_int
)paren
id|ce-&gt;e_block
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ext3_journal_get_write_access_credits
c_func
(paren
id|handle
comma
id|bh
comma
id|credits
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* ext3_journal_get_write_access() requires an unlocked&n;&t;&t;&t; * bh, which complicates things here. */
id|lock_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|le32_to_cpu
c_func
(paren
id|HDR
c_func
(paren
id|bh
)paren
op_member_access_from_pointer
id|h_refcount
)paren
OG
id|EXT3_XATTR_REFCOUNT_MAX
)paren
(brace
id|ea_idebug
c_func
(paren
id|inode
comma
l_string|&quot;block %ld refcount %d&gt;%d&quot;
comma
(paren
r_int
r_int
)paren
id|ce-&gt;e_block
comma
id|le32_to_cpu
c_func
(paren
id|HDR
c_func
(paren
id|bh
)paren
op_member_access_from_pointer
id|h_refcount
)paren
comma
id|EXT3_XATTR_REFCOUNT_MAX
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|ext3_xattr_cmp
c_func
(paren
id|header
comma
id|HDR
c_func
(paren
id|bh
)paren
)paren
)paren
(brace
id|mb_cache_entry_release
c_func
(paren
id|ce
)paren
suffix:semicolon
multiline_comment|/* buffer will be unlocked by caller */
r_return
id|bh
suffix:semicolon
)brace
id|unlock_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
id|journal_release_buffer
c_func
(paren
id|handle
comma
id|bh
comma
op_star
id|credits
)paren
suffix:semicolon
op_star
id|credits
op_assign
l_int|0
suffix:semicolon
id|brelse
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
id|ce
op_assign
id|mb_cache_entry_find_next
c_func
(paren
id|ce
comma
l_int|0
comma
id|inode-&gt;i_sb-&gt;s_bdev
comma
id|hash
)paren
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * ext3_xattr_cache_remove()&n; *&n; * Remove the cache entry of a block from the cache. Called when a&n; * block becomes invalid.&n; */
r_static
r_void
DECL|function|ext3_xattr_cache_remove
id|ext3_xattr_cache_remove
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
r_struct
id|mb_cache_entry
op_star
id|ce
suffix:semicolon
id|ce
op_assign
id|mb_cache_entry_get
c_func
(paren
id|ext3_xattr_cache
comma
id|bh-&gt;b_bdev
comma
id|bh-&gt;b_blocknr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ce
)paren
(brace
id|ea_bdebug
c_func
(paren
id|bh
comma
l_string|&quot;removing (%d cache entries remaining)&quot;
comma
id|atomic_read
c_func
(paren
op_amp
id|ext3_xattr_cache-&gt;c_entry_count
)paren
op_minus
l_int|1
)paren
suffix:semicolon
id|mb_cache_entry_free
c_func
(paren
id|ce
)paren
suffix:semicolon
)brace
r_else
id|ea_bdebug
c_func
(paren
id|bh
comma
l_string|&quot;no cache entry&quot;
)paren
suffix:semicolon
)brace
DECL|macro|NAME_HASH_SHIFT
mdefine_line|#define NAME_HASH_SHIFT 5
DECL|macro|VALUE_HASH_SHIFT
mdefine_line|#define VALUE_HASH_SHIFT 16
multiline_comment|/*&n; * ext3_xattr_hash_entry()&n; *&n; * Compute the hash of an extended attribute.&n; */
DECL|function|ext3_xattr_hash_entry
r_static
r_inline
r_void
id|ext3_xattr_hash_entry
c_func
(paren
r_struct
id|ext3_xattr_header
op_star
id|header
comma
r_struct
id|ext3_xattr_entry
op_star
id|entry
)paren
(brace
id|__u32
id|hash
op_assign
l_int|0
suffix:semicolon
r_char
op_star
id|name
op_assign
id|entry-&gt;e_name
suffix:semicolon
r_int
id|n
suffix:semicolon
r_for
c_loop
(paren
id|n
op_assign
l_int|0
suffix:semicolon
id|n
OL
id|entry-&gt;e_name_len
suffix:semicolon
id|n
op_increment
)paren
(brace
id|hash
op_assign
(paren
id|hash
op_lshift
id|NAME_HASH_SHIFT
)paren
op_xor
(paren
id|hash
op_rshift
(paren
l_int|8
op_star
r_sizeof
(paren
id|hash
)paren
op_minus
id|NAME_HASH_SHIFT
)paren
)paren
op_xor
op_star
id|name
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|entry-&gt;e_value_block
op_eq
l_int|0
op_logical_and
id|entry-&gt;e_value_size
op_ne
l_int|0
)paren
(brace
id|__u32
op_star
id|value
op_assign
(paren
id|__u32
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|header
op_plus
id|le16_to_cpu
c_func
(paren
id|entry-&gt;e_value_offs
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|n
op_assign
(paren
id|le32_to_cpu
c_func
(paren
id|entry-&gt;e_value_size
)paren
op_plus
id|EXT3_XATTR_ROUND
)paren
op_rshift
id|EXT3_XATTR_PAD_BITS
suffix:semicolon
id|n
suffix:semicolon
id|n
op_decrement
)paren
(brace
id|hash
op_assign
(paren
id|hash
op_lshift
id|VALUE_HASH_SHIFT
)paren
op_xor
(paren
id|hash
op_rshift
(paren
l_int|8
op_star
r_sizeof
(paren
id|hash
)paren
op_minus
id|VALUE_HASH_SHIFT
)paren
)paren
op_xor
id|le32_to_cpu
c_func
(paren
op_star
id|value
op_increment
)paren
suffix:semicolon
)brace
)brace
id|entry-&gt;e_hash
op_assign
id|cpu_to_le32
c_func
(paren
id|hash
)paren
suffix:semicolon
)brace
DECL|macro|NAME_HASH_SHIFT
macro_line|#undef NAME_HASH_SHIFT
DECL|macro|VALUE_HASH_SHIFT
macro_line|#undef VALUE_HASH_SHIFT
DECL|macro|BLOCK_HASH_SHIFT
mdefine_line|#define BLOCK_HASH_SHIFT 16
multiline_comment|/*&n; * ext3_xattr_rehash()&n; *&n; * Re-compute the extended attribute hash value after an entry has changed.&n; */
DECL|function|ext3_xattr_rehash
r_static
r_void
id|ext3_xattr_rehash
c_func
(paren
r_struct
id|ext3_xattr_header
op_star
id|header
comma
r_struct
id|ext3_xattr_entry
op_star
id|entry
)paren
(brace
r_struct
id|ext3_xattr_entry
op_star
id|here
suffix:semicolon
id|__u32
id|hash
op_assign
l_int|0
suffix:semicolon
id|ext3_xattr_hash_entry
c_func
(paren
id|header
comma
id|entry
)paren
suffix:semicolon
id|here
op_assign
id|ENTRY
c_func
(paren
id|header
op_plus
l_int|1
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|IS_LAST_ENTRY
c_func
(paren
id|here
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|here-&gt;e_hash
)paren
(brace
multiline_comment|/* Block is not shared if an entry&squot;s hash value == 0 */
id|hash
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
id|hash
op_assign
(paren
id|hash
op_lshift
id|BLOCK_HASH_SHIFT
)paren
op_xor
(paren
id|hash
op_rshift
(paren
l_int|8
op_star
r_sizeof
(paren
id|hash
)paren
op_minus
id|BLOCK_HASH_SHIFT
)paren
)paren
op_xor
id|le32_to_cpu
c_func
(paren
id|here-&gt;e_hash
)paren
suffix:semicolon
id|here
op_assign
id|EXT3_XATTR_NEXT
c_func
(paren
id|here
)paren
suffix:semicolon
)brace
id|header-&gt;h_hash
op_assign
id|cpu_to_le32
c_func
(paren
id|hash
)paren
suffix:semicolon
)brace
DECL|macro|BLOCK_HASH_SHIFT
macro_line|#undef BLOCK_HASH_SHIFT
r_int
id|__init
DECL|function|init_ext3_xattr
id|init_ext3_xattr
c_func
(paren
r_void
)paren
(brace
r_int
id|err
suffix:semicolon
id|err
op_assign
id|ext3_xattr_register
c_func
(paren
id|EXT3_XATTR_INDEX_USER
comma
op_amp
id|ext3_xattr_user_handler
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
id|err
op_assign
id|ext3_xattr_register
c_func
(paren
id|EXT3_XATTR_INDEX_TRUSTED
comma
op_amp
id|ext3_xattr_trusted_handler
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out
suffix:semicolon
macro_line|#ifdef CONFIG_EXT3_FS_SECURITY
id|err
op_assign
id|ext3_xattr_register
c_func
(paren
id|EXT3_XATTR_INDEX_SECURITY
comma
op_amp
id|ext3_xattr_security_handler
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out1
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_EXT3_FS_POSIX_ACL
id|err
op_assign
id|init_ext3_acl
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out2
suffix:semicolon
macro_line|#endif
id|ext3_xattr_cache
op_assign
id|mb_cache_create
c_func
(paren
l_string|&quot;ext3_xattr&quot;
comma
l_int|NULL
comma
r_sizeof
(paren
r_struct
id|mb_cache_entry
)paren
op_plus
r_sizeof
(paren
r_struct
id|mb_cache_entry_index
)paren
comma
l_int|1
comma
l_int|6
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ext3_xattr_cache
)paren
(brace
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|out3
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
id|out3
suffix:colon
macro_line|#ifdef CONFIG_EXT3_FS_POSIX_ACL
id|exit_ext3_acl
c_func
(paren
)paren
suffix:semicolon
id|out2
suffix:colon
macro_line|#endif
macro_line|#ifdef CONFIG_EXT3_FS_SECURITY
id|ext3_xattr_unregister
c_func
(paren
id|EXT3_XATTR_INDEX_SECURITY
comma
op_amp
id|ext3_xattr_security_handler
)paren
suffix:semicolon
id|out1
suffix:colon
macro_line|#endif
id|ext3_xattr_unregister
c_func
(paren
id|EXT3_XATTR_INDEX_TRUSTED
comma
op_amp
id|ext3_xattr_trusted_handler
)paren
suffix:semicolon
id|out
suffix:colon
id|ext3_xattr_unregister
c_func
(paren
id|EXT3_XATTR_INDEX_USER
comma
op_amp
id|ext3_xattr_user_handler
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
r_void
DECL|function|exit_ext3_xattr
id|exit_ext3_xattr
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|ext3_xattr_cache
)paren
id|mb_cache_destroy
c_func
(paren
id|ext3_xattr_cache
)paren
suffix:semicolon
id|ext3_xattr_cache
op_assign
l_int|NULL
suffix:semicolon
macro_line|#ifdef CONFIG_EXT3_FS_POSIX_ACL
id|exit_ext3_acl
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_EXT3_FS_SECURITY
id|ext3_xattr_unregister
c_func
(paren
id|EXT3_XATTR_INDEX_SECURITY
comma
op_amp
id|ext3_xattr_security_handler
)paren
suffix:semicolon
macro_line|#endif
id|ext3_xattr_unregister
c_func
(paren
id|EXT3_XATTR_INDEX_TRUSTED
comma
op_amp
id|ext3_xattr_trusted_handler
)paren
suffix:semicolon
id|ext3_xattr_unregister
c_func
(paren
id|EXT3_XATTR_INDEX_USER
comma
op_amp
id|ext3_xattr_user_handler
)paren
suffix:semicolon
)brace
eof
