multiline_comment|/*&n; *  linux/fs/ext3/hash.c&n; *&n; * Copyright (C) 2002 by Theodore Ts&squot;o&n; *&n; * This file is released under the GPL v2.&n; * &n; * This file may be redistributed under the terms of the GNU Public&n; * License.&n; */
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/jbd.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/ext3_fs.h&gt;
DECL|macro|DELTA
mdefine_line|#define DELTA 0x9E3779B9
DECL|function|TEA_transform
r_static
r_void
id|TEA_transform
c_func
(paren
id|__u32
id|buf
(braket
l_int|4
)braket
comma
id|__u32
r_const
id|in
(braket
)braket
)paren
(brace
id|__u32
id|sum
op_assign
l_int|0
suffix:semicolon
id|__u32
id|b0
op_assign
id|buf
(braket
l_int|0
)braket
comma
id|b1
op_assign
id|buf
(braket
l_int|1
)braket
suffix:semicolon
id|__u32
id|a
op_assign
id|in
(braket
l_int|0
)braket
comma
id|b
op_assign
id|in
(braket
l_int|1
)braket
comma
id|c
op_assign
id|in
(braket
l_int|2
)braket
comma
id|d
op_assign
id|in
(braket
l_int|3
)braket
suffix:semicolon
r_int
id|n
op_assign
l_int|16
suffix:semicolon
r_do
(brace
id|sum
op_add_assign
id|DELTA
suffix:semicolon
id|b0
op_add_assign
(paren
(paren
id|b1
op_lshift
l_int|4
)paren
op_plus
id|a
)paren
op_xor
(paren
id|b1
op_plus
id|sum
)paren
op_xor
(paren
(paren
id|b1
op_rshift
l_int|5
)paren
op_plus
id|b
)paren
suffix:semicolon
id|b1
op_add_assign
(paren
(paren
id|b0
op_lshift
l_int|4
)paren
op_plus
id|c
)paren
op_xor
(paren
id|b0
op_plus
id|sum
)paren
op_xor
(paren
(paren
id|b0
op_rshift
l_int|5
)paren
op_plus
id|d
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
op_decrement
id|n
)paren
(brace
suffix:semicolon
)brace
id|buf
(braket
l_int|0
)braket
op_add_assign
id|b0
suffix:semicolon
id|buf
(braket
l_int|1
)braket
op_add_assign
id|b1
suffix:semicolon
)brace
multiline_comment|/* F, G and H are basic MD4 functions: selection, majority, parity */
DECL|macro|F
mdefine_line|#define F(x, y, z) ((z) ^ ((x) &amp; ((y) ^ (z))))
DECL|macro|G
mdefine_line|#define G(x, y, z) (((x) &amp; (y)) + (((x) ^ (y)) &amp; (z)))
DECL|macro|H
mdefine_line|#define H(x, y, z) ((x) ^ (y) ^ (z))
multiline_comment|/*&n; * The generic round function.  The application is so specific that&n; * we don&squot;t bother protecting all the arguments with parens, as is generally&n; * good macro practice, in favor of extra legibility.&n; * Rotation is separate from addition to prevent recomputation&n; */
DECL|macro|ROUND
mdefine_line|#define ROUND(f, a, b, c, d, x, s)&t;&bslash;&n;&t;(a += f(b, c, d) + x, a = (a &lt;&lt; s) | (a &gt;&gt; (32-s)))
DECL|macro|K1
mdefine_line|#define K1 0
DECL|macro|K2
mdefine_line|#define K2 013240474631UL
DECL|macro|K3
mdefine_line|#define K3 015666365641UL
multiline_comment|/*&n; * Basic cut-down MD4 transform.  Returns only 32 bits of result.&n; */
DECL|function|halfMD4Transform
r_static
r_void
id|halfMD4Transform
(paren
id|__u32
id|buf
(braket
l_int|4
)braket
comma
id|__u32
r_const
id|in
(braket
)braket
)paren
(brace
id|__u32
id|a
op_assign
id|buf
(braket
l_int|0
)braket
comma
id|b
op_assign
id|buf
(braket
l_int|1
)braket
comma
id|c
op_assign
id|buf
(braket
l_int|2
)braket
comma
id|d
op_assign
id|buf
(braket
l_int|3
)braket
suffix:semicolon
multiline_comment|/* Round 1 */
id|ROUND
c_func
(paren
id|F
comma
id|a
comma
id|b
comma
id|c
comma
id|d
comma
id|in
(braket
l_int|0
)braket
op_plus
id|K1
comma
l_int|3
)paren
suffix:semicolon
id|ROUND
c_func
(paren
id|F
comma
id|d
comma
id|a
comma
id|b
comma
id|c
comma
id|in
(braket
l_int|1
)braket
op_plus
id|K1
comma
l_int|7
)paren
suffix:semicolon
id|ROUND
c_func
(paren
id|F
comma
id|c
comma
id|d
comma
id|a
comma
id|b
comma
id|in
(braket
l_int|2
)braket
op_plus
id|K1
comma
l_int|11
)paren
suffix:semicolon
id|ROUND
c_func
(paren
id|F
comma
id|b
comma
id|c
comma
id|d
comma
id|a
comma
id|in
(braket
l_int|3
)braket
op_plus
id|K1
comma
l_int|19
)paren
suffix:semicolon
id|ROUND
c_func
(paren
id|F
comma
id|a
comma
id|b
comma
id|c
comma
id|d
comma
id|in
(braket
l_int|4
)braket
op_plus
id|K1
comma
l_int|3
)paren
suffix:semicolon
id|ROUND
c_func
(paren
id|F
comma
id|d
comma
id|a
comma
id|b
comma
id|c
comma
id|in
(braket
l_int|5
)braket
op_plus
id|K1
comma
l_int|7
)paren
suffix:semicolon
id|ROUND
c_func
(paren
id|F
comma
id|c
comma
id|d
comma
id|a
comma
id|b
comma
id|in
(braket
l_int|6
)braket
op_plus
id|K1
comma
l_int|11
)paren
suffix:semicolon
id|ROUND
c_func
(paren
id|F
comma
id|b
comma
id|c
comma
id|d
comma
id|a
comma
id|in
(braket
l_int|7
)braket
op_plus
id|K1
comma
l_int|19
)paren
suffix:semicolon
multiline_comment|/* Round 2 */
id|ROUND
c_func
(paren
id|G
comma
id|a
comma
id|b
comma
id|c
comma
id|d
comma
id|in
(braket
l_int|1
)braket
op_plus
id|K2
comma
l_int|3
)paren
suffix:semicolon
id|ROUND
c_func
(paren
id|G
comma
id|d
comma
id|a
comma
id|b
comma
id|c
comma
id|in
(braket
l_int|3
)braket
op_plus
id|K2
comma
l_int|5
)paren
suffix:semicolon
id|ROUND
c_func
(paren
id|G
comma
id|c
comma
id|d
comma
id|a
comma
id|b
comma
id|in
(braket
l_int|5
)braket
op_plus
id|K2
comma
l_int|9
)paren
suffix:semicolon
id|ROUND
c_func
(paren
id|G
comma
id|b
comma
id|c
comma
id|d
comma
id|a
comma
id|in
(braket
l_int|7
)braket
op_plus
id|K2
comma
l_int|13
)paren
suffix:semicolon
id|ROUND
c_func
(paren
id|G
comma
id|a
comma
id|b
comma
id|c
comma
id|d
comma
id|in
(braket
l_int|0
)braket
op_plus
id|K2
comma
l_int|3
)paren
suffix:semicolon
id|ROUND
c_func
(paren
id|G
comma
id|d
comma
id|a
comma
id|b
comma
id|c
comma
id|in
(braket
l_int|2
)braket
op_plus
id|K2
comma
l_int|5
)paren
suffix:semicolon
id|ROUND
c_func
(paren
id|G
comma
id|c
comma
id|d
comma
id|a
comma
id|b
comma
id|in
(braket
l_int|4
)braket
op_plus
id|K2
comma
l_int|9
)paren
suffix:semicolon
id|ROUND
c_func
(paren
id|G
comma
id|b
comma
id|c
comma
id|d
comma
id|a
comma
id|in
(braket
l_int|6
)braket
op_plus
id|K2
comma
l_int|13
)paren
suffix:semicolon
multiline_comment|/* Round 3 */
id|ROUND
c_func
(paren
id|H
comma
id|a
comma
id|b
comma
id|c
comma
id|d
comma
id|in
(braket
l_int|3
)braket
op_plus
id|K3
comma
l_int|3
)paren
suffix:semicolon
id|ROUND
c_func
(paren
id|H
comma
id|d
comma
id|a
comma
id|b
comma
id|c
comma
id|in
(braket
l_int|7
)braket
op_plus
id|K3
comma
l_int|9
)paren
suffix:semicolon
id|ROUND
c_func
(paren
id|H
comma
id|c
comma
id|d
comma
id|a
comma
id|b
comma
id|in
(braket
l_int|2
)braket
op_plus
id|K3
comma
l_int|11
)paren
suffix:semicolon
id|ROUND
c_func
(paren
id|H
comma
id|b
comma
id|c
comma
id|d
comma
id|a
comma
id|in
(braket
l_int|6
)braket
op_plus
id|K3
comma
l_int|15
)paren
suffix:semicolon
id|ROUND
c_func
(paren
id|H
comma
id|a
comma
id|b
comma
id|c
comma
id|d
comma
id|in
(braket
l_int|1
)braket
op_plus
id|K3
comma
l_int|3
)paren
suffix:semicolon
id|ROUND
c_func
(paren
id|H
comma
id|d
comma
id|a
comma
id|b
comma
id|c
comma
id|in
(braket
l_int|5
)braket
op_plus
id|K3
comma
l_int|9
)paren
suffix:semicolon
id|ROUND
c_func
(paren
id|H
comma
id|c
comma
id|d
comma
id|a
comma
id|b
comma
id|in
(braket
l_int|0
)braket
op_plus
id|K3
comma
l_int|11
)paren
suffix:semicolon
id|ROUND
c_func
(paren
id|H
comma
id|b
comma
id|c
comma
id|d
comma
id|a
comma
id|in
(braket
l_int|4
)braket
op_plus
id|K3
comma
l_int|15
)paren
suffix:semicolon
id|buf
(braket
l_int|0
)braket
op_add_assign
id|a
suffix:semicolon
id|buf
(braket
l_int|1
)braket
op_add_assign
id|b
suffix:semicolon
id|buf
(braket
l_int|2
)braket
op_add_assign
id|c
suffix:semicolon
id|buf
(braket
l_int|3
)braket
op_add_assign
id|d
suffix:semicolon
)brace
DECL|macro|ROUND
macro_line|#undef ROUND
DECL|macro|F
macro_line|#undef F
DECL|macro|G
macro_line|#undef G
DECL|macro|H
macro_line|#undef H
DECL|macro|K1
macro_line|#undef K1
DECL|macro|K2
macro_line|#undef K2
DECL|macro|K3
macro_line|#undef K3
multiline_comment|/* The old legacy hash */
DECL|function|dx_hack_hash
r_static
id|__u32
id|dx_hack_hash
(paren
r_const
r_char
op_star
id|name
comma
r_int
id|len
)paren
(brace
id|__u32
id|hash0
op_assign
l_int|0x12a3fe2d
comma
id|hash1
op_assign
l_int|0x37abe8f9
suffix:semicolon
r_while
c_loop
(paren
id|len
op_decrement
)paren
(brace
id|__u32
id|hash
op_assign
id|hash1
op_plus
(paren
id|hash0
op_xor
(paren
op_star
id|name
op_increment
op_star
l_int|7152373
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hash
op_amp
l_int|0x80000000
)paren
id|hash
op_sub_assign
l_int|0x7fffffff
suffix:semicolon
id|hash1
op_assign
id|hash0
suffix:semicolon
id|hash0
op_assign
id|hash
suffix:semicolon
)brace
r_return
(paren
id|hash0
op_lshift
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|str2hashbuf
r_static
r_void
id|str2hashbuf
c_func
(paren
r_const
r_char
op_star
id|msg
comma
r_int
id|len
comma
id|__u32
op_star
id|buf
comma
r_int
id|num
)paren
(brace
id|__u32
id|pad
comma
id|val
suffix:semicolon
r_int
id|i
suffix:semicolon
id|pad
op_assign
(paren
id|__u32
)paren
id|len
op_or
(paren
(paren
id|__u32
)paren
id|len
op_lshift
l_int|8
)paren
suffix:semicolon
id|pad
op_or_assign
id|pad
op_lshift
l_int|16
suffix:semicolon
id|val
op_assign
id|pad
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|num
op_star
l_int|4
)paren
id|len
op_assign
id|num
op_star
l_int|4
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|i
op_mod
l_int|4
)paren
op_eq
l_int|0
)paren
id|val
op_assign
id|pad
suffix:semicolon
id|val
op_assign
id|msg
(braket
id|i
)braket
op_plus
(paren
id|val
op_lshift
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|i
op_mod
l_int|4
)paren
op_eq
l_int|3
)paren
(brace
op_star
id|buf
op_increment
op_assign
id|val
suffix:semicolon
id|val
op_assign
id|pad
suffix:semicolon
id|num
op_decrement
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_decrement
id|num
op_ge
l_int|0
)paren
op_star
id|buf
op_increment
op_assign
id|val
suffix:semicolon
r_while
c_loop
(paren
op_decrement
id|num
op_ge
l_int|0
)paren
op_star
id|buf
op_increment
op_assign
id|pad
suffix:semicolon
)brace
multiline_comment|/*&n; * Returns the hash of a filename.  If len is 0 and name is NULL, then&n; * this function can be used to test whether or not a hash version is&n; * supported.&n; * &n; * The seed is an 4 longword (32 bits) &quot;secret&quot; which can be used to&n; * uniquify a hash.  If the seed is all zero&squot;s, then some default seed&n; * may be used.&n; * &n; * A particular hash version specifies whether or not the seed is&n; * represented, and whether or not the returned hash is 32 bits or 64&n; * bits.  32 bit hashes will return 0 for the minor hash.&n; */
DECL|function|ext3fs_dirhash
r_int
id|ext3fs_dirhash
c_func
(paren
r_const
r_char
op_star
id|name
comma
r_int
id|len
comma
r_struct
id|dx_hash_info
op_star
id|hinfo
)paren
(brace
id|__u32
id|hash
suffix:semicolon
id|__u32
id|minor_hash
op_assign
l_int|0
suffix:semicolon
r_const
r_char
op_star
id|p
suffix:semicolon
r_int
id|i
suffix:semicolon
id|__u32
id|in
(braket
l_int|8
)braket
comma
id|buf
(braket
l_int|4
)braket
suffix:semicolon
multiline_comment|/* Initialize the default seed for the hash checksum functions */
id|buf
(braket
l_int|0
)braket
op_assign
l_int|0x67452301
suffix:semicolon
id|buf
(braket
l_int|1
)braket
op_assign
l_int|0xefcdab89
suffix:semicolon
id|buf
(braket
l_int|2
)braket
op_assign
l_int|0x98badcfe
suffix:semicolon
id|buf
(braket
l_int|3
)braket
op_assign
l_int|0x10325476
suffix:semicolon
multiline_comment|/* Check to see if the seed is all zero&squot;s */
r_if
c_cond
(paren
id|hinfo-&gt;seed
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|hinfo-&gt;seed
(braket
id|i
)braket
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
OL
l_int|4
)paren
id|memcpy
c_func
(paren
id|buf
comma
id|hinfo-&gt;seed
comma
r_sizeof
(paren
id|buf
)paren
)paren
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|hinfo-&gt;hash_version
)paren
(brace
r_case
id|DX_HASH_LEGACY
suffix:colon
id|hash
op_assign
id|dx_hack_hash
c_func
(paren
id|name
comma
id|len
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DX_HASH_HALF_MD4
suffix:colon
id|p
op_assign
id|name
suffix:semicolon
r_while
c_loop
(paren
id|len
OG
l_int|0
)paren
(brace
id|str2hashbuf
c_func
(paren
id|p
comma
id|len
comma
id|in
comma
l_int|8
)paren
suffix:semicolon
id|halfMD4Transform
c_func
(paren
id|buf
comma
id|in
)paren
suffix:semicolon
id|len
op_sub_assign
l_int|32
suffix:semicolon
id|p
op_add_assign
l_int|32
suffix:semicolon
)brace
id|minor_hash
op_assign
id|buf
(braket
l_int|2
)braket
suffix:semicolon
id|hash
op_assign
id|buf
(braket
l_int|1
)braket
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DX_HASH_TEA
suffix:colon
id|p
op_assign
id|name
suffix:semicolon
r_while
c_loop
(paren
id|len
OG
l_int|0
)paren
(brace
id|str2hashbuf
c_func
(paren
id|p
comma
id|len
comma
id|in
comma
l_int|4
)paren
suffix:semicolon
id|TEA_transform
c_func
(paren
id|buf
comma
id|in
)paren
suffix:semicolon
id|len
op_sub_assign
l_int|16
suffix:semicolon
id|p
op_add_assign
l_int|16
suffix:semicolon
)brace
id|hash
op_assign
id|buf
(braket
l_int|0
)braket
suffix:semicolon
id|minor_hash
op_assign
id|buf
(braket
l_int|1
)braket
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|hinfo-&gt;hash
op_assign
l_int|0
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|hinfo-&gt;hash
op_assign
id|hash
op_amp
op_complement
l_int|1
suffix:semicolon
id|hinfo-&gt;minor_hash
op_assign
id|minor_hash
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
eof
