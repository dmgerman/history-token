multiline_comment|/*&n; *  linux/fs/hfs/bitmap.c&n; *&n; * Copyright (C) 1996-1997  Paul H. Hargrove&n; * (C) 2003 Ardis Technologies &lt;roman@ardistech.com&gt;&n; * This file may be distributed under the terms of the GNU General Public License.&n; *&n; * Based on GPLed code Copyright (C) 1995  Michael Dreher&n; *&n; * This file contains the code to modify the volume bitmap:&n; * search/set/clear bits.&n; */
macro_line|#include &quot;hfs_fs.h&quot;
multiline_comment|/*&n; * hfs_find_zero_bit()&n; *&n; * Description:&n; *  Given a block of memory, its length in bits, and a starting bit number,&n; *  determine the number of the first zero bits (in left-to-right ordering)&n; *  in that range.&n; *&n; *  Returns &gt;= &squot;size&squot; if no zero bits are found in the range.&n; *&n; *  Accesses memory in 32-bit aligned chunks of 32-bits and thus&n; *  may read beyond the &squot;size&squot;th bit.&n; */
DECL|function|hfs_find_set_zero_bits
r_static
id|u32
id|hfs_find_set_zero_bits
c_func
(paren
id|__be32
op_star
id|bitmap
comma
id|u32
id|size
comma
id|u32
id|offset
comma
id|u32
op_star
id|max
)paren
(brace
id|__be32
op_star
id|curr
comma
op_star
id|end
suffix:semicolon
id|u32
id|mask
comma
id|start
comma
id|len
comma
id|n
suffix:semicolon
id|__be32
id|val
suffix:semicolon
r_int
id|i
suffix:semicolon
id|len
op_assign
op_star
id|max
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|len
)paren
r_return
id|size
suffix:semicolon
id|curr
op_assign
id|bitmap
op_plus
(paren
id|offset
op_div
l_int|32
)paren
suffix:semicolon
id|end
op_assign
id|bitmap
op_plus
(paren
(paren
id|size
op_plus
l_int|31
)paren
op_div
l_int|32
)paren
suffix:semicolon
multiline_comment|/* scan the first partial u32 for zero bits */
id|val
op_assign
op_star
id|curr
suffix:semicolon
r_if
c_cond
(paren
op_complement
id|val
)paren
(brace
id|n
op_assign
id|be32_to_cpu
c_func
(paren
id|val
)paren
suffix:semicolon
id|i
op_assign
id|offset
op_mod
l_int|32
suffix:semicolon
id|mask
op_assign
(paren
l_int|1U
op_lshift
l_int|31
)paren
op_rshift
id|i
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|i
OL
l_int|32
suffix:semicolon
id|mask
op_rshift_assign
l_int|1
comma
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|n
op_amp
id|mask
)paren
)paren
r_goto
id|found
suffix:semicolon
)brace
)brace
multiline_comment|/* scan complete u32s for the first zero bit */
r_while
c_loop
(paren
op_increment
id|curr
OL
id|end
)paren
(brace
id|val
op_assign
op_star
id|curr
suffix:semicolon
r_if
c_cond
(paren
op_complement
id|val
)paren
(brace
id|n
op_assign
id|be32_to_cpu
c_func
(paren
id|val
)paren
suffix:semicolon
id|mask
op_assign
l_int|1
op_lshift
l_int|31
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|32
suffix:semicolon
id|mask
op_rshift_assign
l_int|1
comma
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|n
op_amp
id|mask
)paren
)paren
r_goto
id|found
suffix:semicolon
)brace
)brace
)brace
r_return
id|size
suffix:semicolon
id|found
suffix:colon
id|start
op_assign
(paren
id|curr
op_minus
id|bitmap
)paren
op_star
l_int|32
op_plus
id|i
suffix:semicolon
r_if
c_cond
(paren
id|start
op_ge
id|size
)paren
r_return
id|start
suffix:semicolon
multiline_comment|/* do any partial u32 at the start */
id|len
op_assign
id|min
c_func
(paren
id|size
op_minus
id|start
comma
id|len
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|n
op_or_assign
id|mask
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|i
op_ge
l_int|32
)paren
r_break
suffix:semicolon
id|mask
op_rshift_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_decrement
id|len
op_logical_or
id|n
op_amp
id|mask
)paren
r_goto
id|done
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
op_decrement
id|len
)paren
r_goto
id|done
suffix:semicolon
op_star
id|curr
op_increment
op_assign
id|cpu_to_be32
c_func
(paren
id|n
)paren
suffix:semicolon
multiline_comment|/* do full u32s */
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|n
op_assign
id|be32_to_cpu
c_func
(paren
op_star
id|curr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
l_int|32
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|n
)paren
(brace
id|len
op_assign
l_int|32
suffix:semicolon
r_break
suffix:semicolon
)brace
op_star
id|curr
op_increment
op_assign
id|cpu_to_be32
c_func
(paren
l_int|0xffffffff
)paren
suffix:semicolon
id|len
op_sub_assign
l_int|32
suffix:semicolon
)brace
multiline_comment|/* do any partial u32 at end */
id|mask
op_assign
l_int|1U
op_lshift
l_int|31
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|n
op_amp
id|mask
)paren
r_break
suffix:semicolon
id|n
op_or_assign
id|mask
suffix:semicolon
id|mask
op_rshift_assign
l_int|1
suffix:semicolon
)brace
id|done
suffix:colon
op_star
id|curr
op_assign
id|cpu_to_be32
c_func
(paren
id|n
)paren
suffix:semicolon
op_star
id|max
op_assign
(paren
id|curr
op_minus
id|bitmap
)paren
op_star
l_int|32
op_plus
id|i
op_minus
id|start
suffix:semicolon
r_return
id|start
suffix:semicolon
)brace
multiline_comment|/*&n; * hfs_vbm_search_free()&n; *&n; * Description:&n; *   Search for &squot;num_bits&squot; consecutive cleared bits in the bitmap blocks of&n; *   the hfs MDB. &squot;mdb&squot; had better be locked or the returned range&n; *   may be no longer free, when this functions returns!&n; *   XXX Currently the search starts from bit 0, but it should start with&n; *   the bit number stored in &squot;s_alloc_ptr&squot; of the MDB.&n; * Input Variable(s):&n; *   struct hfs_mdb *mdb: Pointer to the hfs MDB&n; *   u16 *num_bits: Pointer to the number of cleared bits&n; *     to search for&n; * Output Variable(s):&n; *   u16 *num_bits: The number of consecutive clear bits of the&n; *     returned range. If the bitmap is fragmented, this will be less than&n; *     requested and it will be zero, when the disk is full.&n; * Returns:&n; *   The number of the first bit of the range of cleared bits which has been&n; *   found. When &squot;num_bits&squot; is zero, this is invalid!&n; * Preconditions:&n; *   &squot;mdb&squot; points to a &quot;valid&quot; (struct hfs_mdb).&n; *   &squot;num_bits&squot; points to a variable of type (u16), which contains&n; *&t;the number of cleared bits to find.&n; * Postconditions:&n; *   &squot;num_bits&squot; is set to the length of the found sequence.&n; */
DECL|function|hfs_vbm_search_free
id|u32
id|hfs_vbm_search_free
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
id|u32
id|goal
comma
id|u32
op_star
id|num_bits
)paren
(brace
r_void
op_star
id|bitmap
suffix:semicolon
id|u32
id|pos
suffix:semicolon
multiline_comment|/* make sure we have actual work to perform */
r_if
c_cond
(paren
op_logical_neg
op_star
id|num_bits
)paren
r_return
l_int|0
suffix:semicolon
id|down
c_func
(paren
op_amp
id|HFS_SB
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|bitmap_lock
)paren
suffix:semicolon
id|bitmap
op_assign
id|HFS_SB
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|bitmap
suffix:semicolon
id|pos
op_assign
id|hfs_find_set_zero_bits
c_func
(paren
id|bitmap
comma
id|HFS_SB
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|fs_ablocks
comma
id|goal
comma
id|num_bits
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pos
op_ge
id|HFS_SB
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|fs_ablocks
)paren
(brace
r_if
c_cond
(paren
id|goal
)paren
id|pos
op_assign
id|hfs_find_set_zero_bits
c_func
(paren
id|bitmap
comma
id|goal
comma
l_int|0
comma
id|num_bits
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pos
op_ge
id|HFS_SB
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|fs_ablocks
)paren
(brace
op_star
id|num_bits
op_assign
id|pos
op_assign
l_int|0
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
)brace
id|dprint
c_func
(paren
id|DBG_BITMAP
comma
l_string|&quot;alloc_bits: %u,%u&bslash;n&quot;
comma
id|pos
comma
op_star
id|num_bits
)paren
suffix:semicolon
id|HFS_SB
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|free_ablocks
op_sub_assign
op_star
id|num_bits
suffix:semicolon
id|hfs_bitmap_dirty
c_func
(paren
id|sb
)paren
suffix:semicolon
id|out
suffix:colon
id|up
c_func
(paren
op_amp
id|HFS_SB
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|bitmap_lock
)paren
suffix:semicolon
r_return
id|pos
suffix:semicolon
)brace
multiline_comment|/*&n; * hfs_clear_vbm_bits()&n; *&n; * Description:&n; *   Clear the requested bits in the volume bitmap of the hfs filesystem&n; * Input Variable(s):&n; *   struct hfs_mdb *mdb: Pointer to the hfs MDB&n; *   u16 start: The offset of the first bit&n; *   u16 count: The number of bits&n; * Output Variable(s):&n; *   None&n; * Returns:&n; *    0: no error&n; *   -1: One of the bits was already clear.  This is a strange&n; *&t; error and when it happens, the filesystem must be repaired!&n; *   -2: One or more of the bits are out of range of the bitmap.&n; * Preconditions:&n; *   &squot;mdb&squot; points to a &quot;valid&quot; (struct hfs_mdb).&n; * Postconditions:&n; *   Starting with bit number &squot;start&squot;, &squot;count&squot; bits in the volume bitmap&n; *   are cleared. The affected bitmap blocks are marked &quot;dirty&quot;, the free&n; *   block count of the MDB is updated and the MDB is marked dirty.&n; */
DECL|function|hfs_clear_vbm_bits
r_int
id|hfs_clear_vbm_bits
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
id|u16
id|start
comma
id|u16
id|count
)paren
(brace
id|__be32
op_star
id|curr
suffix:semicolon
id|u32
id|mask
suffix:semicolon
r_int
id|i
comma
id|len
suffix:semicolon
multiline_comment|/* is there any actual work to be done? */
r_if
c_cond
(paren
op_logical_neg
id|count
)paren
r_return
l_int|0
suffix:semicolon
id|dprint
c_func
(paren
id|DBG_BITMAP
comma
l_string|&quot;clear_bits: %u,%u&bslash;n&quot;
comma
id|start
comma
id|count
)paren
suffix:semicolon
multiline_comment|/* are all of the bits in range? */
r_if
c_cond
(paren
(paren
id|start
op_plus
id|count
)paren
OG
id|HFS_SB
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|fs_ablocks
)paren
r_return
op_minus
l_int|2
suffix:semicolon
id|down
c_func
(paren
op_amp
id|HFS_SB
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|bitmap_lock
)paren
suffix:semicolon
multiline_comment|/* bitmap is always on a 32-bit boundary */
id|curr
op_assign
id|HFS_SB
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|bitmap
op_plus
(paren
id|start
op_div
l_int|32
)paren
suffix:semicolon
id|len
op_assign
id|count
suffix:semicolon
multiline_comment|/* do any partial u32 at the start */
id|i
op_assign
id|start
op_mod
l_int|32
suffix:semicolon
r_if
c_cond
(paren
id|i
)paren
(brace
r_int
id|j
op_assign
l_int|32
op_minus
id|i
suffix:semicolon
id|mask
op_assign
l_int|0xffffffffU
op_lshift
id|j
suffix:semicolon
r_if
c_cond
(paren
id|j
OG
id|count
)paren
(brace
id|mask
op_or_assign
l_int|0xffffffffU
op_rshift
(paren
id|i
op_plus
id|count
)paren
suffix:semicolon
op_star
id|curr
op_and_assign
id|cpu_to_be32
c_func
(paren
id|mask
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
op_star
id|curr
op_increment
op_and_assign
id|cpu_to_be32
c_func
(paren
id|mask
)paren
suffix:semicolon
id|count
op_sub_assign
id|j
suffix:semicolon
)brace
multiline_comment|/* do full u32s */
r_while
c_loop
(paren
id|count
op_ge
l_int|32
)paren
(brace
op_star
id|curr
op_increment
op_assign
l_int|0
suffix:semicolon
id|count
op_sub_assign
l_int|32
suffix:semicolon
)brace
multiline_comment|/* do any partial u32 at end */
r_if
c_cond
(paren
id|count
)paren
(brace
id|mask
op_assign
l_int|0xffffffffU
op_rshift
id|count
suffix:semicolon
op_star
id|curr
op_and_assign
id|cpu_to_be32
c_func
(paren
id|mask
)paren
suffix:semicolon
)brace
id|out
suffix:colon
id|HFS_SB
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|free_ablocks
op_add_assign
id|len
suffix:semicolon
id|up
c_func
(paren
op_amp
id|HFS_SB
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|bitmap_lock
)paren
suffix:semicolon
id|hfs_bitmap_dirty
c_func
(paren
id|sb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
eof
