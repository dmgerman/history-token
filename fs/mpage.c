multiline_comment|/*&n; * fs/mpage.c&n; *&n; * Copyright (C) 2002, Linus Torvalds.&n; *&n; * Contains functions related to preparing and submitting BIOs which contain&n; * multiple pagecache pages.&n; *&n; * 15May2002&t;akpm@zip.com.au&n; *&t;&t;Initial version&n; */
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/bio.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/buffer_head.h&gt;
macro_line|#include &lt;linux/blkdev.h&gt;
macro_line|#include &lt;linux/highmem.h&gt;
macro_line|#include &lt;linux/prefetch.h&gt;
macro_line|#include &lt;linux/mpage.h&gt;
multiline_comment|/*&n; * The largest-sized BIO which this code will assemble, in bytes.  Set this&n; * to PAGE_CACHE_SIZE if your drivers are broken.&n; */
DECL|macro|MPAGE_BIO_MAX_SIZE
mdefine_line|#define MPAGE_BIO_MAX_SIZE BIO_MAX_SIZE
multiline_comment|/*&n; * I/O completion handler for multipage BIOs.&n; *&n; * The mpage code never puts partial pages into a BIO (except for end-of-file).&n; * If a page does not map to a contiguous run of blocks then it simply falls&n; * back to block_read_full_page().&n; *&n; * Why is this?  If a page&squot;s completion depends on a number of different BIOs&n; * which can complete in any order (or at the same time) then determining the&n; * status of that page is hard.  See end_buffer_async_read() for the details.&n; * There is no point in duplicating all that complexity.&n; */
DECL|function|mpage_end_io_read
r_static
r_void
id|mpage_end_io_read
c_func
(paren
r_struct
id|bio
op_star
id|bio
)paren
(brace
r_const
r_int
id|uptodate
op_assign
id|test_bit
c_func
(paren
id|BIO_UPTODATE
comma
op_amp
id|bio-&gt;bi_flags
)paren
suffix:semicolon
r_struct
id|bio_vec
op_star
id|bvec
op_assign
id|bio-&gt;bi_io_vec
op_plus
id|bio-&gt;bi_vcnt
op_minus
l_int|1
suffix:semicolon
r_do
(brace
r_struct
id|page
op_star
id|page
op_assign
id|bvec-&gt;bv_page
suffix:semicolon
r_if
c_cond
(paren
op_decrement
id|bvec
op_ge
id|bio-&gt;bi_io_vec
)paren
id|prefetchw
c_func
(paren
op_amp
id|bvec-&gt;bv_page-&gt;flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|uptodate
)paren
(brace
id|SetPageUptodate
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
r_else
(brace
id|ClearPageUptodate
c_func
(paren
id|page
)paren
suffix:semicolon
id|SetPageError
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|bvec
op_ge
id|bio-&gt;bi_io_vec
)paren
suffix:semicolon
id|bio_put
c_func
(paren
id|bio
)paren
suffix:semicolon
)brace
DECL|function|mpage_end_io_write
r_static
r_void
id|mpage_end_io_write
c_func
(paren
r_struct
id|bio
op_star
id|bio
)paren
(brace
r_const
r_int
id|uptodate
op_assign
id|test_bit
c_func
(paren
id|BIO_UPTODATE
comma
op_amp
id|bio-&gt;bi_flags
)paren
suffix:semicolon
r_struct
id|bio_vec
op_star
id|bvec
op_assign
id|bio-&gt;bi_io_vec
op_plus
id|bio-&gt;bi_vcnt
op_minus
l_int|1
suffix:semicolon
r_do
(brace
r_struct
id|page
op_star
id|page
op_assign
id|bvec-&gt;bv_page
suffix:semicolon
r_if
c_cond
(paren
op_decrement
id|bvec
op_ge
id|bio-&gt;bi_io_vec
)paren
id|prefetchw
c_func
(paren
op_amp
id|bvec-&gt;bv_page-&gt;flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|uptodate
)paren
id|SetPageError
c_func
(paren
id|page
)paren
suffix:semicolon
id|end_page_writeback
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|bvec
op_ge
id|bio-&gt;bi_io_vec
)paren
suffix:semicolon
id|bio_put
c_func
(paren
id|bio
)paren
suffix:semicolon
)brace
DECL|function|mpage_bio_submit
r_struct
id|bio
op_star
id|mpage_bio_submit
c_func
(paren
r_int
id|rw
comma
r_struct
id|bio
op_star
id|bio
)paren
(brace
id|bio-&gt;bi_vcnt
op_assign
id|bio-&gt;bi_idx
suffix:semicolon
id|bio-&gt;bi_idx
op_assign
l_int|0
suffix:semicolon
id|bio-&gt;bi_end_io
op_assign
id|mpage_end_io_read
suffix:semicolon
r_if
c_cond
(paren
id|rw
op_eq
id|WRITE
)paren
id|bio-&gt;bi_end_io
op_assign
id|mpage_end_io_write
suffix:semicolon
id|submit_bio
c_func
(paren
id|rw
comma
id|bio
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_static
r_struct
id|bio
op_star
DECL|function|mpage_alloc
id|mpage_alloc
c_func
(paren
r_struct
id|block_device
op_star
id|bdev
comma
id|sector_t
id|first_sector
comma
r_int
id|nr_vecs
comma
r_int
id|gfp_flags
)paren
(brace
r_struct
id|bio
op_star
id|bio
suffix:semicolon
id|bio
op_assign
id|bio_alloc
c_func
(paren
id|gfp_flags
comma
id|nr_vecs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bio
op_eq
l_int|NULL
op_logical_and
(paren
id|current-&gt;flags
op_amp
id|PF_MEMALLOC
)paren
)paren
(brace
r_while
c_loop
(paren
op_logical_neg
id|bio
op_logical_and
(paren
id|nr_vecs
op_div_assign
l_int|2
)paren
)paren
id|bio
op_assign
id|bio_alloc
c_func
(paren
id|gfp_flags
comma
id|nr_vecs
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bio
)paren
(brace
id|bio-&gt;bi_bdev
op_assign
id|bdev
suffix:semicolon
id|bio-&gt;bi_vcnt
op_assign
id|nr_vecs
suffix:semicolon
id|bio-&gt;bi_idx
op_assign
l_int|0
suffix:semicolon
id|bio-&gt;bi_size
op_assign
l_int|0
suffix:semicolon
id|bio-&gt;bi_sector
op_assign
id|first_sector
suffix:semicolon
id|bio-&gt;bi_io_vec
(braket
l_int|0
)braket
dot
id|bv_page
op_assign
l_int|NULL
suffix:semicolon
)brace
r_return
id|bio
suffix:semicolon
)brace
multiline_comment|/**&n; * mpage_readpages - populate an address space with some pages, and&n; *                       start reads against them.&n; *&n; * @mapping: the address_space&n; * @pages: The address of a list_head which contains the target pages.  These&n; *   pages have their -&gt;index populated and are otherwise uninitialised.&n; *&n; *   The page at @pages-&gt;prev has the lowest file offset, and reads should be&n; *   issued in @pages-&gt;prev to @pages-&gt;next order.&n; *&n; * @nr_pages: The number of pages at *@pages&n; * @get_block: The filesystem&squot;s block mapper function.&n; *&n; * This function walks the pages and the blocks within each page, building and&n; * emitting large BIOs.&n; *&n; * If anything unusual happens, such as:&n; *&n; * - encountering a page which has buffers&n; * - encountering a page which has a non-hole after a hole&n; * - encountering a page with non-contiguous blocks&n; *&n; * then this code just gives up and calls the buffer_head-based read function.&n; * It does handle a page which has holes at the end - that is a common case:&n; * the end-of-file on blocksize &lt; PAGE_CACHE_SIZE setups.&n; *&n; * BH_Boundary explanation:&n; *&n; * There is a problem.  The mpage read code assembles several pages, gets all&n; * their disk mappings, and then submits them all.  That&squot;s fine, but obtaining&n; * the disk mappings may require I/O.  Reads of indirect blocks, for example.&n; *&n; * So an mpage read of the first 16 blocks of an ext2 file will cause I/O to be&n; * submitted in the following order:&n; * &t;12 0 1 2 3 4 5 6 7 8 9 10 11 13 14 15 16&n; * because the indirect block has to be read to get the mappings of blocks&n; * 13,14,15,16.  Obviously, this impacts performance.&n; * &n; * So what we do it to allow the filesystem&squot;s get_block() function to set&n; * BH_Boundary when it maps block 11.  BH_Boundary says: mapping of the block&n; * after this one will require I/O against a block which is probably close to&n; * this one.  So you should push what I/O you have currently accumulated.&n; *&n; * This all causes the disk requests to be issued in the correct order.&n; */
r_static
r_struct
id|bio
op_star
DECL|function|do_mpage_readpage
id|do_mpage_readpage
c_func
(paren
r_struct
id|bio
op_star
id|bio
comma
r_struct
id|page
op_star
id|page
comma
r_int
id|nr_pages
comma
id|sector_t
op_star
id|last_block_in_bio
comma
id|get_block_t
id|get_block
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|page-&gt;mapping-&gt;host
suffix:semicolon
r_const
r_int
id|blkbits
op_assign
id|inode-&gt;i_blkbits
suffix:semicolon
r_const
r_int
id|blocks_per_page
op_assign
id|PAGE_CACHE_SIZE
op_rshift
id|blkbits
suffix:semicolon
r_const
r_int
id|blocksize
op_assign
l_int|1
op_lshift
id|blkbits
suffix:semicolon
r_struct
id|bio_vec
op_star
id|bvec
suffix:semicolon
id|sector_t
id|block_in_file
suffix:semicolon
id|sector_t
id|last_block
suffix:semicolon
id|sector_t
id|blocks
(braket
id|MAX_BUF_PER_PAGE
)braket
suffix:semicolon
r_int
id|page_block
suffix:semicolon
r_int
id|first_hole
op_assign
id|blocks_per_page
suffix:semicolon
r_struct
id|block_device
op_star
id|bdev
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|buffer_head
id|bh
suffix:semicolon
r_if
c_cond
(paren
id|page_has_buffers
c_func
(paren
id|page
)paren
)paren
r_goto
id|confused
suffix:semicolon
id|block_in_file
op_assign
id|page-&gt;index
op_lshift
(paren
id|PAGE_CACHE_SHIFT
op_minus
id|blkbits
)paren
suffix:semicolon
id|last_block
op_assign
(paren
id|inode-&gt;i_size
op_plus
id|blocksize
op_minus
l_int|1
)paren
op_rshift
id|blkbits
suffix:semicolon
r_for
c_loop
(paren
id|page_block
op_assign
l_int|0
suffix:semicolon
id|page_block
OL
id|blocks_per_page
suffix:semicolon
id|page_block
op_increment
comma
id|block_in_file
op_increment
)paren
(brace
id|bh.b_state
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|block_in_file
OL
id|last_block
)paren
(brace
r_if
c_cond
(paren
id|get_block
c_func
(paren
id|inode
comma
id|block_in_file
comma
op_amp
id|bh
comma
l_int|0
)paren
)paren
r_goto
id|confused
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|buffer_mapped
c_func
(paren
op_amp
id|bh
)paren
)paren
(brace
r_if
c_cond
(paren
id|first_hole
op_eq
id|blocks_per_page
)paren
id|first_hole
op_assign
id|page_block
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|first_hole
op_ne
id|blocks_per_page
)paren
r_goto
id|confused
suffix:semicolon
multiline_comment|/* hole -&gt; non-hole */
multiline_comment|/* Contiguous blocks? */
r_if
c_cond
(paren
id|page_block
op_logical_and
id|blocks
(braket
id|page_block
op_minus
l_int|1
)braket
op_ne
id|bh.b_blocknr
op_minus
l_int|1
)paren
r_goto
id|confused
suffix:semicolon
id|blocks
(braket
id|page_block
)braket
op_assign
id|bh.b_blocknr
suffix:semicolon
id|bdev
op_assign
id|bh.b_bdev
suffix:semicolon
)brace
r_if
c_cond
(paren
id|first_hole
op_ne
id|blocks_per_page
)paren
(brace
id|memset
c_func
(paren
id|kmap
c_func
(paren
id|page
)paren
op_plus
(paren
id|first_hole
op_lshift
id|blkbits
)paren
comma
l_int|0
comma
id|PAGE_CACHE_SIZE
op_minus
(paren
id|first_hole
op_lshift
id|blkbits
)paren
)paren
suffix:semicolon
id|flush_dcache_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|kunmap
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|first_hole
op_eq
l_int|0
)paren
(brace
id|SetPageUptodate
c_func
(paren
id|page
)paren
suffix:semicolon
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * This page will go to BIO.  Do we need to send this BIO off first?&n;&t; */
r_if
c_cond
(paren
id|bio
op_logical_and
(paren
id|bio-&gt;bi_idx
op_eq
id|bio-&gt;bi_vcnt
op_logical_or
op_star
id|last_block_in_bio
op_ne
id|blocks
(braket
l_int|0
)braket
op_minus
l_int|1
)paren
)paren
id|bio
op_assign
id|mpage_bio_submit
c_func
(paren
id|READ
comma
id|bio
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bio
op_eq
l_int|NULL
)paren
(brace
r_int
id|nr_bvecs
op_assign
id|MPAGE_BIO_MAX_SIZE
op_div
id|PAGE_CACHE_SIZE
suffix:semicolon
r_if
c_cond
(paren
id|nr_bvecs
OG
id|nr_pages
)paren
id|nr_bvecs
op_assign
id|nr_pages
suffix:semicolon
id|bio
op_assign
id|mpage_alloc
c_func
(paren
id|bdev
comma
id|blocks
(braket
l_int|0
)braket
op_lshift
(paren
id|blkbits
op_minus
l_int|9
)paren
comma
id|nr_bvecs
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bio
op_eq
l_int|NULL
)paren
r_goto
id|confused
suffix:semicolon
)brace
id|bvec
op_assign
op_amp
id|bio-&gt;bi_io_vec
(braket
id|bio-&gt;bi_idx
op_increment
)braket
suffix:semicolon
id|bvec-&gt;bv_page
op_assign
id|page
suffix:semicolon
id|bvec-&gt;bv_len
op_assign
(paren
id|first_hole
op_lshift
id|blkbits
)paren
suffix:semicolon
id|bvec-&gt;bv_offset
op_assign
l_int|0
suffix:semicolon
id|bio-&gt;bi_size
op_add_assign
id|bvec-&gt;bv_len
suffix:semicolon
r_if
c_cond
(paren
id|buffer_boundary
c_func
(paren
op_amp
id|bh
)paren
op_logical_or
(paren
id|first_hole
op_ne
id|blocks_per_page
)paren
)paren
id|bio
op_assign
id|mpage_bio_submit
c_func
(paren
id|READ
comma
id|bio
)paren
suffix:semicolon
r_else
op_star
id|last_block_in_bio
op_assign
id|blocks
(braket
id|blocks_per_page
op_minus
l_int|1
)braket
suffix:semicolon
id|out
suffix:colon
r_return
id|bio
suffix:semicolon
id|confused
suffix:colon
r_if
c_cond
(paren
id|bio
)paren
id|bio
op_assign
id|mpage_bio_submit
c_func
(paren
id|READ
comma
id|bio
)paren
suffix:semicolon
id|block_read_full_page
c_func
(paren
id|page
comma
id|get_block
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_int
DECL|function|mpage_readpages
id|mpage_readpages
c_func
(paren
r_struct
id|address_space
op_star
id|mapping
comma
r_struct
id|list_head
op_star
id|pages
comma
r_int
id|nr_pages
comma
id|get_block_t
id|get_block
)paren
(brace
r_struct
id|bio
op_star
id|bio
op_assign
l_int|NULL
suffix:semicolon
r_int
id|page_idx
suffix:semicolon
id|sector_t
id|last_block_in_bio
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|page_idx
op_assign
l_int|0
suffix:semicolon
id|page_idx
OL
id|nr_pages
suffix:semicolon
id|page_idx
op_increment
)paren
(brace
r_struct
id|page
op_star
id|page
op_assign
id|list_entry
c_func
(paren
id|pages-&gt;prev
comma
r_struct
id|page
comma
id|list
)paren
suffix:semicolon
id|prefetchw
c_func
(paren
op_amp
id|page-&gt;flags
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|page-&gt;list
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|add_to_page_cache_unique
c_func
(paren
id|page
comma
id|mapping
comma
id|page-&gt;index
)paren
)paren
id|bio
op_assign
id|do_mpage_readpage
c_func
(paren
id|bio
comma
id|page
comma
id|nr_pages
op_minus
id|page_idx
comma
op_amp
id|last_block_in_bio
comma
id|get_block
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
id|BUG_ON
c_func
(paren
op_logical_neg
id|list_empty
c_func
(paren
id|pages
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bio
)paren
id|mpage_bio_submit
c_func
(paren
id|READ
comma
id|bio
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|mpage_readpages
id|EXPORT_SYMBOL
c_func
(paren
id|mpage_readpages
)paren
suffix:semicolon
multiline_comment|/*&n; * This isn&squot;t called much at all&n; */
DECL|function|mpage_readpage
r_int
id|mpage_readpage
c_func
(paren
r_struct
id|page
op_star
id|page
comma
id|get_block_t
id|get_block
)paren
(brace
r_struct
id|bio
op_star
id|bio
op_assign
l_int|NULL
suffix:semicolon
id|sector_t
id|last_block_in_bio
op_assign
l_int|0
suffix:semicolon
id|bio
op_assign
id|do_mpage_readpage
c_func
(paren
id|bio
comma
id|page
comma
l_int|1
comma
op_amp
id|last_block_in_bio
comma
id|get_block
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bio
)paren
id|mpage_bio_submit
c_func
(paren
id|READ
comma
id|bio
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|mpage_readpage
id|EXPORT_SYMBOL
c_func
(paren
id|mpage_readpage
)paren
suffix:semicolon
multiline_comment|/*&n; * Writing is not so simple.&n; *&n; * If the page has buffers then they will be used for obtaining the disk&n; * mapping.  We only support pages which are fully mapped-and-dirty, with a&n; * special case for pages which are unmapped at the end: end-of-file.&n; *&n; * If the page has no buffers (preferred) then the page is mapped here.&n; *&n; * If all blocks are found to be contiguous then the page can go into the&n; * BIO.  Otherwise fall back to the mapping&squot;s writepage().&n; * &n; * FIXME: This code wants an estimate of how many pages are still to be&n; * written, so it can intelligently allocate a suitably-sized BIO.  For now,&n; * just allocate full-size (16-page) BIOs.&n; */
r_static
r_inline
r_struct
id|bio
op_star
DECL|function|mpage_writepage
id|mpage_writepage
c_func
(paren
r_struct
id|bio
op_star
id|bio
comma
r_struct
id|page
op_star
id|page
comma
id|get_block_t
id|get_block
comma
id|sector_t
op_star
id|last_block_in_bio
comma
r_int
op_star
id|ret
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|page-&gt;mapping-&gt;host
suffix:semicolon
r_const
r_int
id|blkbits
op_assign
id|inode-&gt;i_blkbits
suffix:semicolon
r_int
r_int
id|end_index
suffix:semicolon
r_const
r_int
id|blocks_per_page
op_assign
id|PAGE_CACHE_SIZE
op_rshift
id|blkbits
suffix:semicolon
r_struct
id|bio_vec
op_star
id|bvec
suffix:semicolon
id|sector_t
id|last_block
suffix:semicolon
id|sector_t
id|block_in_file
suffix:semicolon
id|sector_t
id|blocks
(braket
id|MAX_BUF_PER_PAGE
)braket
suffix:semicolon
r_int
id|page_block
suffix:semicolon
r_int
id|first_unmapped
op_assign
id|blocks_per_page
suffix:semicolon
r_struct
id|block_device
op_star
id|bdev
op_assign
l_int|NULL
suffix:semicolon
r_int
id|boundary
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|page_has_buffers
c_func
(paren
id|page
)paren
)paren
(brace
r_struct
id|buffer_head
op_star
id|head
op_assign
id|page_buffers
c_func
(paren
id|page
)paren
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
op_assign
id|head
suffix:semicolon
multiline_comment|/* If they&squot;re all mapped and dirty, do it */
id|page_block
op_assign
l_int|0
suffix:semicolon
r_do
(brace
id|BUG_ON
c_func
(paren
id|buffer_locked
c_func
(paren
id|bh
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buffer_mapped
c_func
(paren
id|bh
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * unmapped dirty buffers are created by&n;&t;&t;&t;&t; * __set_page_dirty_buffers -&gt; mmapped data&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|buffer_dirty
c_func
(paren
id|bh
)paren
)paren
r_goto
id|confused
suffix:semicolon
r_if
c_cond
(paren
id|first_unmapped
op_eq
id|blocks_per_page
)paren
id|first_unmapped
op_assign
id|page_block
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|first_unmapped
op_ne
id|blocks_per_page
)paren
r_goto
id|confused
suffix:semicolon
multiline_comment|/* hole -&gt; non-hole */
r_if
c_cond
(paren
op_logical_neg
id|buffer_dirty
c_func
(paren
id|bh
)paren
op_logical_or
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|bh
)paren
)paren
r_goto
id|confused
suffix:semicolon
r_if
c_cond
(paren
id|page_block
)paren
(brace
r_if
c_cond
(paren
id|bh-&gt;b_blocknr
op_ne
id|blocks
(braket
id|page_block
op_minus
l_int|1
)braket
op_plus
l_int|1
)paren
r_goto
id|confused
suffix:semicolon
)brace
id|blocks
(braket
id|page_block
op_increment
)braket
op_assign
id|bh-&gt;b_blocknr
suffix:semicolon
id|boundary
op_assign
id|buffer_boundary
c_func
(paren
id|bh
)paren
suffix:semicolon
id|bdev
op_assign
id|bh-&gt;b_bdev
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|bh
op_assign
id|bh-&gt;b_this_page
)paren
op_ne
id|head
)paren
suffix:semicolon
r_if
c_cond
(paren
id|first_unmapped
)paren
r_goto
id|page_is_mapped
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Page has buffers, but they are all unmapped. The page was&n;&t;&t; * created by pagein or read over a hole which was handled by&n;&t;&t; * block_read_full_page().  If this address_space is also&n;&t;&t; * using mpage_readpages then this can rarely happen.&n;&t;&t; */
r_goto
id|confused
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * The page has no buffers: map it to disk&n;&t; */
id|BUG_ON
c_func
(paren
op_logical_neg
id|PageUptodate
c_func
(paren
id|page
)paren
)paren
suffix:semicolon
id|block_in_file
op_assign
id|page-&gt;index
op_lshift
(paren
id|PAGE_CACHE_SHIFT
op_minus
id|blkbits
)paren
suffix:semicolon
id|last_block
op_assign
(paren
id|inode-&gt;i_size
op_minus
l_int|1
)paren
op_rshift
id|blkbits
suffix:semicolon
r_for
c_loop
(paren
id|page_block
op_assign
l_int|0
suffix:semicolon
id|page_block
OL
id|blocks_per_page
suffix:semicolon
)paren
(brace
r_struct
id|buffer_head
id|map_bh
suffix:semicolon
id|map_bh.b_state
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|get_block
c_func
(paren
id|inode
comma
id|block_in_file
comma
op_amp
id|map_bh
comma
l_int|1
)paren
)paren
r_goto
id|confused
suffix:semicolon
r_if
c_cond
(paren
id|buffer_new
c_func
(paren
op_amp
id|map_bh
)paren
)paren
id|unmap_underlying_metadata
c_func
(paren
id|map_bh.b_bdev
comma
id|map_bh.b_blocknr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|page_block
)paren
(brace
r_if
c_cond
(paren
id|map_bh.b_blocknr
op_ne
id|blocks
(braket
id|page_block
op_minus
l_int|1
)braket
op_plus
l_int|1
)paren
r_goto
id|confused
suffix:semicolon
)brace
id|blocks
(braket
id|page_block
op_increment
)braket
op_assign
id|map_bh.b_blocknr
suffix:semicolon
id|boundary
op_assign
id|buffer_boundary
c_func
(paren
op_amp
id|map_bh
)paren
suffix:semicolon
id|bdev
op_assign
id|map_bh.b_bdev
suffix:semicolon
r_if
c_cond
(paren
id|block_in_file
op_eq
id|last_block
)paren
r_break
suffix:semicolon
id|block_in_file
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|page_block
op_eq
l_int|0
)paren
id|buffer_error
c_func
(paren
)paren
suffix:semicolon
id|first_unmapped
op_assign
id|page_block
suffix:semicolon
id|end_index
op_assign
id|inode-&gt;i_size
op_rshift
id|PAGE_CACHE_SHIFT
suffix:semicolon
r_if
c_cond
(paren
id|page-&gt;index
op_ge
id|end_index
)paren
(brace
r_int
id|offset
op_assign
id|inode-&gt;i_size
op_amp
(paren
id|PAGE_CACHE_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|page-&gt;index
OG
id|end_index
op_logical_or
op_logical_neg
id|offset
)paren
r_goto
id|confused
suffix:semicolon
id|memset
c_func
(paren
id|kmap
c_func
(paren
id|page
)paren
op_plus
id|offset
comma
l_int|0
comma
id|PAGE_CACHE_SIZE
op_minus
id|offset
)paren
suffix:semicolon
id|flush_dcache_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|kunmap
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
id|page_is_mapped
suffix:colon
multiline_comment|/*&n;&t; * This page will go to BIO.  Do we need to send this BIO off first?&n;&t; */
r_if
c_cond
(paren
id|bio
op_logical_and
(paren
id|bio-&gt;bi_idx
op_eq
id|bio-&gt;bi_vcnt
op_logical_or
op_star
id|last_block_in_bio
op_ne
id|blocks
(braket
l_int|0
)braket
op_minus
l_int|1
)paren
)paren
id|bio
op_assign
id|mpage_bio_submit
c_func
(paren
id|WRITE
comma
id|bio
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bio
op_eq
l_int|NULL
)paren
(brace
r_int
id|nr_bvecs
op_assign
id|MPAGE_BIO_MAX_SIZE
op_div
id|PAGE_CACHE_SIZE
suffix:semicolon
id|bio
op_assign
id|mpage_alloc
c_func
(paren
id|bdev
comma
id|blocks
(braket
l_int|0
)braket
op_lshift
(paren
id|blkbits
op_minus
l_int|9
)paren
comma
id|nr_bvecs
comma
id|GFP_NOFS
op_or
id|__GFP_HIGH
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bio
op_eq
l_int|NULL
)paren
r_goto
id|confused
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * OK, we have our BIO, so we can now mark the buffers clean.  Make&n;&t; * sure to only clean buffers which we know we&squot;ll be writing.&n;&t; */
r_if
c_cond
(paren
id|page_has_buffers
c_func
(paren
id|page
)paren
)paren
(brace
r_struct
id|buffer_head
op_star
id|head
op_assign
id|page_buffers
c_func
(paren
id|page
)paren
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
op_assign
id|head
suffix:semicolon
r_int
id|buffer_counter
op_assign
l_int|0
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|buffer_counter
op_increment
op_eq
id|first_unmapped
)paren
r_break
suffix:semicolon
id|clear_buffer_dirty
c_func
(paren
id|bh
)paren
suffix:semicolon
id|bh
op_assign
id|bh-&gt;b_this_page
suffix:semicolon
)brace
r_while
c_loop
(paren
id|bh
op_ne
id|head
)paren
suffix:semicolon
)brace
id|bvec
op_assign
op_amp
id|bio-&gt;bi_io_vec
(braket
id|bio-&gt;bi_idx
op_increment
)braket
suffix:semicolon
id|bvec-&gt;bv_page
op_assign
id|page
suffix:semicolon
id|bvec-&gt;bv_len
op_assign
(paren
id|first_unmapped
op_lshift
id|blkbits
)paren
suffix:semicolon
id|bvec-&gt;bv_offset
op_assign
l_int|0
suffix:semicolon
id|bio-&gt;bi_size
op_add_assign
id|bvec-&gt;bv_len
suffix:semicolon
id|BUG_ON
c_func
(paren
id|PageWriteback
c_func
(paren
id|page
)paren
)paren
suffix:semicolon
id|SetPageWriteback
c_func
(paren
id|page
)paren
suffix:semicolon
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|boundary
op_logical_or
(paren
id|first_unmapped
op_ne
id|blocks_per_page
)paren
)paren
id|bio
op_assign
id|mpage_bio_submit
c_func
(paren
id|WRITE
comma
id|bio
)paren
suffix:semicolon
r_else
op_star
id|last_block_in_bio
op_assign
id|blocks
(braket
id|blocks_per_page
op_minus
l_int|1
)braket
suffix:semicolon
r_goto
id|out
suffix:semicolon
id|confused
suffix:colon
r_if
c_cond
(paren
id|bio
)paren
id|bio
op_assign
id|mpage_bio_submit
c_func
(paren
id|WRITE
comma
id|bio
)paren
suffix:semicolon
op_star
id|ret
op_assign
id|page-&gt;mapping-&gt;a_ops
op_member_access_from_pointer
id|writepage
c_func
(paren
id|page
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|bio
suffix:semicolon
)brace
multiline_comment|/*&n; * This is a cut-n-paste of generic_writepages().  We _could_&n; * generalise that function.  It&squot;d get a bit messy.  We&squot;ll see.&n; */
r_int
DECL|function|mpage_writepages
id|mpage_writepages
c_func
(paren
r_struct
id|address_space
op_star
id|mapping
comma
r_int
op_star
id|nr_to_write
comma
id|get_block_t
id|get_block
)paren
(brace
r_struct
id|bio
op_star
id|bio
op_assign
l_int|NULL
suffix:semicolon
id|sector_t
id|last_block_in_bio
op_assign
l_int|0
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_int
id|done
op_assign
l_int|0
suffix:semicolon
id|write_lock
c_func
(paren
op_amp
id|mapping-&gt;page_lock
)paren
suffix:semicolon
id|list_splice_init
c_func
(paren
op_amp
id|mapping-&gt;dirty_pages
comma
op_amp
id|mapping-&gt;io_pages
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|mapping-&gt;io_pages
)paren
op_logical_and
op_logical_neg
id|done
)paren
(brace
r_struct
id|page
op_star
id|page
op_assign
id|list_entry
c_func
(paren
id|mapping-&gt;io_pages.prev
comma
r_struct
id|page
comma
id|list
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|page-&gt;list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PageWriteback
c_func
(paren
id|page
)paren
)paren
(brace
r_if
c_cond
(paren
id|PageDirty
c_func
(paren
id|page
)paren
)paren
(brace
id|list_add
c_func
(paren
op_amp
id|page-&gt;list
comma
op_amp
id|mapping-&gt;dirty_pages
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|list_add
c_func
(paren
op_amp
id|page-&gt;list
comma
op_amp
id|mapping-&gt;locked_pages
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|PageDirty
c_func
(paren
id|page
)paren
)paren
(brace
id|list_add
c_func
(paren
op_amp
id|page-&gt;list
comma
op_amp
id|mapping-&gt;clean_pages
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|list_add
c_func
(paren
op_amp
id|page-&gt;list
comma
op_amp
id|mapping-&gt;locked_pages
)paren
suffix:semicolon
id|page_cache_get
c_func
(paren
id|page
)paren
suffix:semicolon
id|write_unlock
c_func
(paren
op_amp
id|mapping-&gt;page_lock
)paren
suffix:semicolon
id|lock_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|page-&gt;mapping
op_logical_and
id|TestClearPageDirty
c_func
(paren
id|page
)paren
op_logical_and
op_logical_neg
id|PageWriteback
c_func
(paren
id|page
)paren
)paren
(brace
multiline_comment|/* FIXME: batch this up */
r_if
c_cond
(paren
op_logical_neg
id|PageActive
c_func
(paren
id|page
)paren
op_logical_and
id|PageLRU
c_func
(paren
id|page
)paren
)paren
(brace
id|spin_lock
c_func
(paren
op_amp
id|pagemap_lru_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|PageActive
c_func
(paren
id|page
)paren
op_logical_and
id|PageLRU
c_func
(paren
id|page
)paren
)paren
(brace
id|list_del
c_func
(paren
op_amp
id|page-&gt;lru
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|page-&gt;lru
comma
op_amp
id|inactive_list
)paren
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|pagemap_lru_lock
)paren
suffix:semicolon
)brace
id|bio
op_assign
id|mpage_writepage
c_func
(paren
id|bio
comma
id|page
comma
id|get_block
comma
op_amp
id|last_block_in_bio
comma
op_amp
id|ret
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_logical_or
(paren
id|nr_to_write
op_logical_and
op_decrement
(paren
op_star
id|nr_to_write
)paren
op_le
l_int|0
)paren
)paren
id|done
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
id|write_lock
c_func
(paren
op_amp
id|mapping-&gt;page_lock
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Put the rest back, in the correct order.&n;&t; */
id|list_splice_init
c_func
(paren
op_amp
id|mapping-&gt;io_pages
comma
id|mapping-&gt;dirty_pages.prev
)paren
suffix:semicolon
id|write_unlock
c_func
(paren
op_amp
id|mapping-&gt;page_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bio
)paren
id|mpage_bio_submit
c_func
(paren
id|WRITE
comma
id|bio
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|variable|mpage_writepages
id|EXPORT_SYMBOL
c_func
(paren
id|mpage_writepages
)paren
suffix:semicolon
eof
