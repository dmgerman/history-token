multiline_comment|/*&n; * fs/mpage.c&n; *&n; * Copyright (C) 2002, Linus Torvalds.&n; *&n; * Contains functions related to preparing and submitting BIOs which contain&n; * multiple pagecache pages.&n; *&n; * 15May2002&t;akpm@zip.com.au&n; *&t;&t;Initial version&n; */
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/bio.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/buffer_head.h&gt;
macro_line|#include &lt;linux/blkdev.h&gt;
macro_line|#include &lt;linux/highmem.h&gt;
macro_line|#include &lt;linux/prefetch.h&gt;
macro_line|#include &lt;linux/mpage.h&gt;
multiline_comment|/*&n; * The largest-sized BIO which this code will assemble, in bytes.  Set this&n; * to PAGE_CACHE_SIZE if your drivers are broken.&n; */
DECL|macro|MPAGE_BIO_MAX_SIZE
mdefine_line|#define MPAGE_BIO_MAX_SIZE BIO_MAX_SIZE
multiline_comment|/*&n; * I/O completion handler for multipage BIOs.&n; *&n; * The mpage code never puts partial pages into a BIO (except for end-of-file).&n; * If a page does not map to a contiguous run of blocks then it simply falls&n; * back to block_read_full_page().&n; *&n; * Why is this?  If a page&squot;s completion depends on a number of different BIOs&n; * which can complete in any order (or at the same time) then determining the&n; * status of that page is hard.  See end_buffer_async_read() for the details.&n; * There is no point in duplicating all that complexity.&n; */
DECL|function|mpage_end_io_read
r_static
r_void
id|mpage_end_io_read
c_func
(paren
r_struct
id|bio
op_star
id|bio
)paren
(brace
r_const
r_int
id|uptodate
op_assign
id|test_bit
c_func
(paren
id|BIO_UPTODATE
comma
op_amp
id|bio-&gt;bi_flags
)paren
suffix:semicolon
r_struct
id|bio_vec
op_star
id|bvec
op_assign
id|bio-&gt;bi_io_vec
op_plus
id|bio-&gt;bi_vcnt
op_minus
l_int|1
suffix:semicolon
r_do
(brace
r_struct
id|page
op_star
id|page
op_assign
id|bvec-&gt;bv_page
suffix:semicolon
r_if
c_cond
(paren
op_decrement
id|bvec
op_ge
id|bio-&gt;bi_io_vec
)paren
id|prefetchw
c_func
(paren
op_amp
id|bvec-&gt;bv_page-&gt;flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|uptodate
)paren
(brace
id|SetPageUptodate
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
r_else
(brace
id|ClearPageUptodate
c_func
(paren
id|page
)paren
suffix:semicolon
id|SetPageError
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|bvec
op_ge
id|bio-&gt;bi_io_vec
)paren
suffix:semicolon
id|bio_put
c_func
(paren
id|bio
)paren
suffix:semicolon
)brace
DECL|function|mpage_bio_submit
r_struct
id|bio
op_star
id|mpage_bio_submit
c_func
(paren
r_int
id|rw
comma
r_struct
id|bio
op_star
id|bio
)paren
(brace
id|bio-&gt;bi_vcnt
op_assign
id|bio-&gt;bi_idx
suffix:semicolon
id|bio-&gt;bi_idx
op_assign
l_int|0
suffix:semicolon
id|bio-&gt;bi_end_io
op_assign
id|mpage_end_io_read
suffix:semicolon
id|submit_bio
c_func
(paren
id|rw
comma
id|bio
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_static
r_struct
id|bio
op_star
DECL|function|mpage_alloc
id|mpage_alloc
c_func
(paren
r_struct
id|block_device
op_star
id|bdev
comma
id|sector_t
id|first_sector
comma
r_int
id|nr_vecs
comma
r_int
id|gfp_flags
)paren
(brace
r_struct
id|bio
op_star
id|bio
suffix:semicolon
id|bio
op_assign
id|bio_alloc
c_func
(paren
id|gfp_flags
comma
id|nr_vecs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bio
)paren
(brace
id|bio-&gt;bi_bdev
op_assign
id|bdev
suffix:semicolon
id|bio-&gt;bi_vcnt
op_assign
id|nr_vecs
suffix:semicolon
id|bio-&gt;bi_idx
op_assign
l_int|0
suffix:semicolon
id|bio-&gt;bi_size
op_assign
l_int|0
suffix:semicolon
id|bio-&gt;bi_sector
op_assign
id|first_sector
suffix:semicolon
id|bio-&gt;bi_io_vec
(braket
l_int|0
)braket
dot
id|bv_page
op_assign
l_int|NULL
suffix:semicolon
)brace
r_return
id|bio
suffix:semicolon
)brace
multiline_comment|/**&n; * mpage_readpages - populate an address space with some pages, and&n; *                       start reads against them.&n; *&n; * @mapping: the address_space&n; * @pages: The address of a list_head which contains the target pages.  These&n; *   pages have their -&gt;index populated and are otherwise uninitialised.&n; *&n; *   The page at @pages-&gt;prev has the lowest file offset, and reads should be&n; *   issued in @pages-&gt;prev to @pages-&gt;next order.&n; *&n; * @nr_pages: The number of pages at *@pages&n; * @get_block: The filesystem&squot;s block mapper function.&n; *&n; * This function walks the pages and the blocks within each page, building and&n; * emitting large BIOs.&n; *&n; * If anything unusual happens, such as:&n; *&n; * - encountering a page which has buffers&n; * - encountering a page which has a non-hole after a hole&n; * - encountering a page with non-contiguous blocks&n; *&n; * then this code just gives up and calls the buffer_head-based read function.&n; * It does handle a page which has holes at the end - that is a common case:&n; * the end-of-file on blocksize &lt; PAGE_CACHE_SIZE setups.&n; *&n; * BH_Boundary explanation:&n; *&n; * There is a problem.  The mpage read code assembles several pages, gets all&n; * their disk mappings, and then submits them all.  That&squot;s fine, but obtaining&n; * the disk mappings may require I/O.  Reads of indirect blocks, for example.&n; *&n; * So an mpage read of the first 16 blocks of an ext2 file will cause I/O to be&n; * submitted in the following order:&n; * &t;12 0 1 2 3 4 5 6 7 8 9 10 11 13 14 15 16&n; * because the indirect block has to be read to get the mappings of blocks&n; * 13,14,15,16.  Obviously, this impacts performance.&n; * &n; * So what we do it to allow the filesystem&squot;s get_block() function to set&n; * BH_Boundary when it maps block 11.  BH_Boundary says: mapping of the block&n; * after this one will require I/O against a block which is probably close to&n; * this one.  So you should push what I/O you have currently accumulated.&n; *&n; * This all causes the disk requests to be issued in the correct order.&n; */
r_static
r_struct
id|bio
op_star
DECL|function|do_mpage_readpage
id|do_mpage_readpage
c_func
(paren
r_struct
id|bio
op_star
id|bio
comma
r_struct
id|page
op_star
id|page
comma
r_int
id|nr_pages
comma
id|sector_t
op_star
id|last_block_in_bio
comma
id|get_block_t
id|get_block
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|page-&gt;mapping-&gt;host
suffix:semicolon
r_const
r_int
id|blkbits
op_assign
id|inode-&gt;i_blkbits
suffix:semicolon
r_const
r_int
id|blocks_per_page
op_assign
id|PAGE_CACHE_SIZE
op_rshift
id|blkbits
suffix:semicolon
r_const
r_int
id|blocksize
op_assign
l_int|1
op_lshift
id|blkbits
suffix:semicolon
r_struct
id|bio_vec
op_star
id|bvec
suffix:semicolon
id|sector_t
id|block_in_file
suffix:semicolon
id|sector_t
id|last_block
suffix:semicolon
id|sector_t
id|blocks
(braket
id|MAX_BUF_PER_PAGE
)braket
suffix:semicolon
r_int
id|page_block
suffix:semicolon
r_int
id|first_hole
op_assign
id|blocks_per_page
suffix:semicolon
r_struct
id|block_device
op_star
id|bdev
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|buffer_head
id|bh
suffix:semicolon
r_if
c_cond
(paren
id|page_has_buffers
c_func
(paren
id|page
)paren
)paren
r_goto
id|confused
suffix:semicolon
id|block_in_file
op_assign
id|page-&gt;index
op_lshift
(paren
id|PAGE_CACHE_SHIFT
op_minus
id|blkbits
)paren
suffix:semicolon
id|last_block
op_assign
(paren
id|inode-&gt;i_size
op_plus
id|blocksize
op_minus
l_int|1
)paren
op_rshift
id|blkbits
suffix:semicolon
r_for
c_loop
(paren
id|page_block
op_assign
l_int|0
suffix:semicolon
id|page_block
OL
id|blocks_per_page
suffix:semicolon
id|page_block
op_increment
comma
id|block_in_file
op_increment
)paren
(brace
id|bh.b_state
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|block_in_file
OL
id|last_block
)paren
(brace
r_if
c_cond
(paren
id|get_block
c_func
(paren
id|inode
comma
id|block_in_file
comma
op_amp
id|bh
comma
l_int|0
)paren
)paren
r_goto
id|confused
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|buffer_mapped
c_func
(paren
op_amp
id|bh
)paren
)paren
(brace
r_if
c_cond
(paren
id|first_hole
op_eq
id|blocks_per_page
)paren
id|first_hole
op_assign
id|page_block
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|first_hole
op_ne
id|blocks_per_page
)paren
r_goto
id|confused
suffix:semicolon
multiline_comment|/* hole -&gt; non-hole */
multiline_comment|/* Contiguous blocks? */
r_if
c_cond
(paren
id|page_block
op_logical_and
id|blocks
(braket
id|page_block
op_minus
l_int|1
)braket
op_ne
id|bh.b_blocknr
op_minus
l_int|1
)paren
r_goto
id|confused
suffix:semicolon
id|blocks
(braket
id|page_block
)braket
op_assign
id|bh.b_blocknr
suffix:semicolon
id|bdev
op_assign
id|bh.b_bdev
suffix:semicolon
)brace
r_if
c_cond
(paren
id|first_hole
op_ne
id|blocks_per_page
)paren
(brace
id|memset
c_func
(paren
id|kmap
c_func
(paren
id|page
)paren
op_plus
(paren
id|first_hole
op_lshift
id|blkbits
)paren
comma
l_int|0
comma
id|PAGE_CACHE_SIZE
op_minus
(paren
id|first_hole
op_lshift
id|blkbits
)paren
)paren
suffix:semicolon
id|flush_dcache_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|kunmap
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|first_hole
op_eq
l_int|0
)paren
(brace
id|SetPageUptodate
c_func
(paren
id|page
)paren
suffix:semicolon
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * This page will go to BIO.  Do we need to send this BIO off first?&n;&t; */
r_if
c_cond
(paren
id|bio
op_logical_and
(paren
id|bio-&gt;bi_idx
op_eq
id|bio-&gt;bi_vcnt
op_logical_or
op_star
id|last_block_in_bio
op_ne
id|blocks
(braket
l_int|0
)braket
op_minus
l_int|1
)paren
)paren
id|bio
op_assign
id|mpage_bio_submit
c_func
(paren
id|READ
comma
id|bio
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bio
op_eq
l_int|NULL
)paren
(brace
r_int
id|nr_bvecs
op_assign
id|MPAGE_BIO_MAX_SIZE
op_div
id|PAGE_CACHE_SIZE
suffix:semicolon
r_if
c_cond
(paren
id|nr_bvecs
OG
id|nr_pages
)paren
id|nr_bvecs
op_assign
id|nr_pages
suffix:semicolon
id|bio
op_assign
id|mpage_alloc
c_func
(paren
id|bdev
comma
id|blocks
(braket
l_int|0
)braket
op_lshift
(paren
id|blkbits
op_minus
l_int|9
)paren
comma
id|nr_bvecs
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bio
op_eq
l_int|NULL
)paren
r_goto
id|confused
suffix:semicolon
)brace
id|bvec
op_assign
op_amp
id|bio-&gt;bi_io_vec
(braket
id|bio-&gt;bi_idx
op_increment
)braket
suffix:semicolon
id|bvec-&gt;bv_page
op_assign
id|page
suffix:semicolon
id|bvec-&gt;bv_len
op_assign
(paren
id|first_hole
op_lshift
id|blkbits
)paren
suffix:semicolon
id|bvec-&gt;bv_offset
op_assign
l_int|0
suffix:semicolon
id|bio-&gt;bi_size
op_add_assign
id|bvec-&gt;bv_len
suffix:semicolon
r_if
c_cond
(paren
id|buffer_boundary
c_func
(paren
op_amp
id|bh
)paren
op_logical_or
(paren
id|first_hole
op_ne
id|blocks_per_page
)paren
)paren
id|bio
op_assign
id|mpage_bio_submit
c_func
(paren
id|READ
comma
id|bio
)paren
suffix:semicolon
r_else
op_star
id|last_block_in_bio
op_assign
id|blocks
(braket
id|blocks_per_page
op_minus
l_int|1
)braket
suffix:semicolon
id|out
suffix:colon
r_return
id|bio
suffix:semicolon
id|confused
suffix:colon
r_if
c_cond
(paren
id|bio
)paren
id|bio
op_assign
id|mpage_bio_submit
c_func
(paren
id|READ
comma
id|bio
)paren
suffix:semicolon
id|block_read_full_page
c_func
(paren
id|page
comma
id|get_block
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_int
DECL|function|mpage_readpages
id|mpage_readpages
c_func
(paren
r_struct
id|address_space
op_star
id|mapping
comma
r_struct
id|list_head
op_star
id|pages
comma
r_int
id|nr_pages
comma
id|get_block_t
id|get_block
)paren
(brace
r_struct
id|bio
op_star
id|bio
op_assign
l_int|NULL
suffix:semicolon
r_int
id|page_idx
suffix:semicolon
id|sector_t
id|last_block_in_bio
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|page_idx
op_assign
l_int|0
suffix:semicolon
id|page_idx
OL
id|nr_pages
suffix:semicolon
id|page_idx
op_increment
)paren
(brace
r_struct
id|page
op_star
id|page
op_assign
id|list_entry
c_func
(paren
id|pages-&gt;prev
comma
r_struct
id|page
comma
id|list
)paren
suffix:semicolon
id|prefetchw
c_func
(paren
op_amp
id|page-&gt;flags
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|page-&gt;list
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|add_to_page_cache_unique
c_func
(paren
id|page
comma
id|mapping
comma
id|page-&gt;index
)paren
)paren
id|bio
op_assign
id|do_mpage_readpage
c_func
(paren
id|bio
comma
id|page
comma
id|nr_pages
op_minus
id|page_idx
comma
op_amp
id|last_block_in_bio
comma
id|get_block
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
id|BUG_ON
c_func
(paren
op_logical_neg
id|list_empty
c_func
(paren
id|pages
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bio
)paren
id|mpage_bio_submit
c_func
(paren
id|READ
comma
id|bio
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|mpage_readpages
id|EXPORT_SYMBOL
c_func
(paren
id|mpage_readpages
)paren
suffix:semicolon
multiline_comment|/*&n; * This isn&squot;t called much at all&n; */
DECL|function|mpage_readpage
r_int
id|mpage_readpage
c_func
(paren
r_struct
id|page
op_star
id|page
comma
id|get_block_t
id|get_block
)paren
(brace
r_struct
id|bio
op_star
id|bio
op_assign
l_int|NULL
suffix:semicolon
id|sector_t
id|last_block_in_bio
op_assign
l_int|0
suffix:semicolon
id|bio
op_assign
id|do_mpage_readpage
c_func
(paren
id|bio
comma
id|page
comma
l_int|1
comma
op_amp
id|last_block_in_bio
comma
id|get_block
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bio
)paren
id|mpage_bio_submit
c_func
(paren
id|READ
comma
id|bio
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|mpage_readpage
id|EXPORT_SYMBOL
c_func
(paren
id|mpage_readpage
)paren
suffix:semicolon
eof
