multiline_comment|/*&n; * linux/fs/nfs/write.c&n; *&n; * Writing file data over NFS.&n; *&n; * We do it like this: When a (user) process wishes to write data to an&n; * NFS file, a write request is allocated that contains the RPC task data&n; * plus some info on the page to be written, and added to the inode&squot;s&n; * write chain. If the process writes past the end of the page, an async&n; * RPC call to write the page is scheduled immediately; otherwise, the call&n; * is delayed for a few seconds.&n; *&n; * Just like readahead, no async I/O is performed if wsize &lt; PAGE_SIZE.&n; *&n; * Write requests are kept on the inode&squot;s writeback list. Each entry in&n; * that list references the page (portion) to be written. When the&n; * cache timeout has expired, the RPC task is woken up, and tries to&n; * lock the page. As soon as it manages to do so, the request is moved&n; * from the writeback list to the writelock list.&n; *&n; * Note: we must make sure never to confuse the inode passed in the&n; * write_page request with the one in page-&gt;inode. As far as I understand&n; * it, these are different when doing a swap-out.&n; *&n; * To understand everything that goes on here and in the NFS read code,&n; * one should be aware that a page is locked in exactly one of the following&n; * cases:&n; *&n; *  -&t;A write request is in progress.&n; *  -&t;A user process is in generic_file_write/nfs_update_page&n; *  -&t;A user process is in generic_file_read&n; *&n; * Also note that because of the way pages are invalidated in&n; * nfs_revalidate_inode, the following assertions hold:&n; *&n; *  -&t;If a page is dirty, there will be no read requests (a page will&n; *&t;not be re-read unless invalidated by nfs_revalidate_inode).&n; *  -&t;If the page is not uptodate, there will be no pending write&n; *&t;requests, and no process will be in nfs_update_page.&n; *&n; * FIXME: Interaction with the vmscan routines is not optimal yet.&n; * Either vmscan must be made nfs-savvy, or we need a different page&n; * reclaim concept that supports something like FS-independent&n; * buffer_heads with a b_ops-&gt; field.&n; *&n; * Copyright (C) 1996, 1997, Olaf Kirch &lt;okir@monad.swb.de&gt;&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/pagemap.h&gt;
macro_line|#include &lt;linux/file.h&gt;
macro_line|#include &lt;linux/mpage.h&gt;
macro_line|#include &lt;linux/writeback.h&gt;
macro_line|#include &lt;linux/sunrpc/clnt.h&gt;
macro_line|#include &lt;linux/nfs_fs.h&gt;
macro_line|#include &lt;linux/nfs_mount.h&gt;
macro_line|#include &lt;linux/nfs_page.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/mempool.h&gt;
DECL|macro|NFSDBG_FACILITY
mdefine_line|#define NFSDBG_FACILITY&t;&t;NFSDBG_PAGECACHE
DECL|macro|MIN_POOL_WRITE
mdefine_line|#define MIN_POOL_WRITE&t;&t;(32)
DECL|macro|MIN_POOL_COMMIT
mdefine_line|#define MIN_POOL_COMMIT&t;&t;(4)
multiline_comment|/*&n; * Local function declarations&n; */
r_static
r_struct
id|nfs_page
op_star
id|nfs_update_request
c_func
(paren
r_struct
id|file
op_star
comma
r_struct
id|inode
op_star
comma
r_struct
id|page
op_star
comma
r_int
r_int
comma
r_int
r_int
)paren
suffix:semicolon
r_static
r_void
id|nfs_strategy
c_func
(paren
r_struct
id|inode
op_star
id|inode
)paren
suffix:semicolon
DECL|variable|nfs_wdata_cachep
r_static
id|kmem_cache_t
op_star
id|nfs_wdata_cachep
suffix:semicolon
DECL|variable|nfs_wdata_mempool
r_static
id|mempool_t
op_star
id|nfs_wdata_mempool
suffix:semicolon
DECL|variable|nfs_commit_mempool
r_static
id|mempool_t
op_star
id|nfs_commit_mempool
suffix:semicolon
DECL|function|nfs_writedata_alloc
r_static
id|__inline__
r_struct
id|nfs_write_data
op_star
id|nfs_writedata_alloc
c_func
(paren
r_void
)paren
(brace
r_struct
id|nfs_write_data
op_star
id|p
suffix:semicolon
id|p
op_assign
(paren
r_struct
id|nfs_write_data
op_star
)paren
id|mempool_alloc
c_func
(paren
id|nfs_wdata_mempool
comma
id|SLAB_NOFS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
)paren
(brace
id|memset
c_func
(paren
id|p
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|p
)paren
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|p-&gt;pages
)paren
suffix:semicolon
)brace
r_return
id|p
suffix:semicolon
)brace
DECL|function|nfs_writedata_free
r_static
id|__inline__
r_void
id|nfs_writedata_free
c_func
(paren
r_struct
id|nfs_write_data
op_star
id|p
)paren
(brace
id|mempool_free
c_func
(paren
id|p
comma
id|nfs_wdata_mempool
)paren
suffix:semicolon
)brace
DECL|function|nfs_writedata_release
r_void
id|nfs_writedata_release
c_func
(paren
r_struct
id|rpc_task
op_star
id|task
)paren
(brace
r_struct
id|nfs_write_data
op_star
id|wdata
op_assign
(paren
r_struct
id|nfs_write_data
op_star
)paren
id|task-&gt;tk_calldata
suffix:semicolon
id|nfs_writedata_free
c_func
(paren
id|wdata
)paren
suffix:semicolon
)brace
DECL|function|nfs_commit_alloc
r_static
id|__inline__
r_struct
id|nfs_write_data
op_star
id|nfs_commit_alloc
c_func
(paren
r_void
)paren
(brace
r_struct
id|nfs_write_data
op_star
id|p
suffix:semicolon
id|p
op_assign
(paren
r_struct
id|nfs_write_data
op_star
)paren
id|mempool_alloc
c_func
(paren
id|nfs_commit_mempool
comma
id|SLAB_NOFS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
)paren
(brace
id|memset
c_func
(paren
id|p
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|p
)paren
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|p-&gt;pages
)paren
suffix:semicolon
)brace
r_return
id|p
suffix:semicolon
)brace
DECL|function|nfs_commit_free
r_static
id|__inline__
r_void
id|nfs_commit_free
c_func
(paren
r_struct
id|nfs_write_data
op_star
id|p
)paren
(brace
id|mempool_free
c_func
(paren
id|p
comma
id|nfs_commit_mempool
)paren
suffix:semicolon
)brace
DECL|function|nfs_commit_release
r_void
id|nfs_commit_release
c_func
(paren
r_struct
id|rpc_task
op_star
id|task
)paren
(brace
r_struct
id|nfs_write_data
op_star
id|wdata
op_assign
(paren
r_struct
id|nfs_write_data
op_star
)paren
id|task-&gt;tk_calldata
suffix:semicolon
id|nfs_commit_free
c_func
(paren
id|wdata
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This function will be used to simulate weak cache consistency&n; * under NFSv2 when the NFSv3 attribute patch is included.&n; * For the moment, we just call nfs_refresh_inode().&n; */
r_static
id|__inline__
r_int
DECL|function|nfs_write_attributes
id|nfs_write_attributes
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|nfs_fattr
op_star
id|fattr
)paren
(brace
r_if
c_cond
(paren
(paren
id|fattr-&gt;valid
op_amp
id|NFS_ATTR_FATTR
)paren
op_logical_and
op_logical_neg
(paren
id|fattr-&gt;valid
op_amp
id|NFS_ATTR_WCC
)paren
)paren
(brace
id|fattr-&gt;pre_size
op_assign
id|NFS_CACHE_ISIZE
c_func
(paren
id|inode
)paren
suffix:semicolon
id|fattr-&gt;pre_mtime
op_assign
id|NFS_CACHE_MTIME
c_func
(paren
id|inode
)paren
suffix:semicolon
id|fattr-&gt;pre_ctime
op_assign
id|NFS_CACHE_CTIME
c_func
(paren
id|inode
)paren
suffix:semicolon
id|fattr-&gt;valid
op_or_assign
id|NFS_ATTR_WCC
suffix:semicolon
)brace
r_return
id|nfs_refresh_inode
c_func
(paren
id|inode
comma
id|fattr
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Write a page synchronously.&n; * Offset is the data offset within the page.&n; */
r_static
r_int
DECL|function|nfs_writepage_sync
id|nfs_writepage_sync
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|page
op_star
id|page
comma
r_int
r_int
id|offset
comma
r_int
r_int
id|count
)paren
(brace
r_struct
id|rpc_cred
op_star
id|cred
op_assign
l_int|NULL
suffix:semicolon
id|loff_t
id|base
suffix:semicolon
r_int
r_int
id|wsize
op_assign
id|NFS_SERVER
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|wsize
suffix:semicolon
r_int
id|result
comma
id|refresh
op_assign
l_int|0
comma
id|written
op_assign
l_int|0
comma
id|flags
suffix:semicolon
id|u8
op_star
id|buffer
suffix:semicolon
r_struct
id|nfs_fattr
id|fattr
suffix:semicolon
r_struct
id|nfs_writeverf
id|verf
suffix:semicolon
r_if
c_cond
(paren
id|file
)paren
id|cred
op_assign
id|get_rpccred
c_func
(paren
id|nfs_file_cred
c_func
(paren
id|file
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cred
)paren
id|cred
op_assign
id|get_rpccred
c_func
(paren
id|NFS_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|mm_cred
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;NFS:      nfs_writepage_sync(%s/%Ld %d@%Ld)&bslash;n&quot;
comma
id|inode-&gt;i_sb-&gt;s_id
comma
(paren
r_int
r_int
)paren
id|NFS_FILEID
c_func
(paren
id|inode
)paren
comma
id|count
comma
(paren
r_int
r_int
)paren
(paren
id|page_offset
c_func
(paren
id|page
)paren
op_plus
id|offset
)paren
)paren
suffix:semicolon
id|base
op_assign
id|page_offset
c_func
(paren
id|page
)paren
op_plus
id|offset
suffix:semicolon
id|flags
op_assign
(paren
(paren
id|IS_SWAPFILE
c_func
(paren
id|inode
)paren
)paren
ques
c_cond
id|NFS_RW_SWAP
suffix:colon
l_int|0
)paren
op_or
id|NFS_RW_SYNC
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|count
OL
id|wsize
op_logical_and
op_logical_neg
id|IS_SWAPFILE
c_func
(paren
id|inode
)paren
)paren
id|wsize
op_assign
id|count
suffix:semicolon
id|result
op_assign
id|NFS_PROTO
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|write
c_func
(paren
id|inode
comma
id|cred
comma
op_amp
id|fattr
comma
id|flags
comma
id|offset
comma
id|wsize
comma
id|page
comma
op_amp
id|verf
)paren
suffix:semicolon
id|nfs_write_attributes
c_func
(paren
id|inode
comma
op_amp
id|fattr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
multiline_comment|/* Must mark the page invalid after I/O error */
id|ClearPageUptodate
c_func
(paren
id|page
)paren
suffix:semicolon
r_goto
id|io_error
suffix:semicolon
)brace
r_if
c_cond
(paren
id|result
op_ne
id|wsize
)paren
id|printk
c_func
(paren
l_string|&quot;NFS: short write, wsize=%u, result=%d&bslash;n&quot;
comma
id|wsize
comma
id|result
)paren
suffix:semicolon
id|refresh
op_assign
l_int|1
suffix:semicolon
id|buffer
op_add_assign
id|wsize
suffix:semicolon
id|base
op_add_assign
id|wsize
suffix:semicolon
id|offset
op_add_assign
id|wsize
suffix:semicolon
id|written
op_add_assign
id|wsize
suffix:semicolon
id|count
op_sub_assign
id|wsize
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If we&squot;ve extended the file, update the inode&n;&t;&t; * now so we don&squot;t invalidate the cache.&n;&t;&t; */
r_if
c_cond
(paren
id|base
OG
id|inode-&gt;i_size
)paren
id|inode-&gt;i_size
op_assign
id|base
suffix:semicolon
)brace
r_while
c_loop
(paren
id|count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PageError
c_func
(paren
id|page
)paren
)paren
id|ClearPageError
c_func
(paren
id|page
)paren
suffix:semicolon
id|io_error
suffix:colon
r_if
c_cond
(paren
id|cred
)paren
id|put_rpccred
c_func
(paren
id|cred
)paren
suffix:semicolon
r_return
id|written
ques
c_cond
id|written
suffix:colon
id|result
suffix:semicolon
)brace
r_static
r_int
DECL|function|nfs_writepage_async
id|nfs_writepage_async
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|page
op_star
id|page
comma
r_int
r_int
id|offset
comma
r_int
r_int
id|count
)paren
(brace
r_struct
id|nfs_page
op_star
id|req
suffix:semicolon
id|loff_t
id|end
suffix:semicolon
r_int
id|status
suffix:semicolon
id|req
op_assign
id|nfs_update_request
c_func
(paren
id|file
comma
id|inode
comma
id|page
comma
id|offset
comma
id|count
)paren
suffix:semicolon
id|status
op_assign
(paren
id|IS_ERR
c_func
(paren
id|req
)paren
)paren
ques
c_cond
id|PTR_ERR
c_func
(paren
id|req
)paren
suffix:colon
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|status
OL
l_int|0
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|req-&gt;wb_cred
)paren
id|req-&gt;wb_cred
op_assign
id|get_rpccred
c_func
(paren
id|NFS_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|mm_cred
)paren
suffix:semicolon
id|nfs_unlock_request
c_func
(paren
id|req
)paren
suffix:semicolon
id|nfs_strategy
c_func
(paren
id|inode
)paren
suffix:semicolon
id|end
op_assign
(paren
(paren
id|loff_t
)paren
id|page-&gt;index
op_lshift
id|PAGE_CACHE_SHIFT
)paren
op_plus
(paren
id|loff_t
)paren
(paren
id|offset
op_plus
id|count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inode-&gt;i_size
OL
id|end
)paren
id|inode-&gt;i_size
op_assign
id|end
suffix:semicolon
id|out
suffix:colon
r_return
id|status
suffix:semicolon
)brace
multiline_comment|/*&n; * Write an mmapped page to the server.&n; */
r_int
DECL|function|nfs_writepage
id|nfs_writepage
c_func
(paren
r_struct
id|page
op_star
id|page
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|page-&gt;mapping-&gt;host
suffix:semicolon
r_int
r_int
id|end_index
suffix:semicolon
r_int
id|offset
op_assign
id|PAGE_CACHE_SIZE
suffix:semicolon
r_int
id|err
suffix:semicolon
id|end_index
op_assign
id|inode-&gt;i_size
op_rshift
id|PAGE_CACHE_SHIFT
suffix:semicolon
multiline_comment|/* Ensure we&squot;ve flushed out any previous writes */
id|nfs_wb_page
c_func
(paren
id|inode
comma
id|page
)paren
suffix:semicolon
multiline_comment|/* easy case */
r_if
c_cond
(paren
id|page-&gt;index
OL
id|end_index
)paren
r_goto
id|do_it
suffix:semicolon
multiline_comment|/* things got complicated... */
id|offset
op_assign
id|inode-&gt;i_size
op_amp
(paren
id|PAGE_CACHE_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* OK, are we completely out? */
id|err
op_assign
op_minus
id|EIO
suffix:semicolon
r_if
c_cond
(paren
id|page-&gt;index
op_ge
id|end_index
op_plus
l_int|1
op_logical_or
op_logical_neg
id|offset
)paren
r_goto
id|out
suffix:semicolon
id|do_it
suffix:colon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|NFS_SERVER
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|wsize
op_ge
id|PAGE_CACHE_SIZE
op_logical_and
op_logical_neg
id|IS_SYNC
c_func
(paren
id|inode
)paren
)paren
(brace
id|err
op_assign
id|nfs_writepage_async
c_func
(paren
l_int|NULL
comma
id|inode
comma
id|page
comma
l_int|0
comma
id|offset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_ge
l_int|0
)paren
id|err
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|err
op_assign
id|nfs_writepage_sync
c_func
(paren
l_int|NULL
comma
id|inode
comma
id|page
comma
l_int|0
comma
id|offset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_eq
id|offset
)paren
id|err
op_assign
l_int|0
suffix:semicolon
)brace
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
id|out
suffix:colon
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
r_int
DECL|function|nfs_writepages
id|nfs_writepages
c_func
(paren
r_struct
id|address_space
op_star
id|mapping
comma
r_struct
id|writeback_control
op_star
id|wbc
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|mapping-&gt;host
suffix:semicolon
r_int
id|is_sync
op_assign
op_logical_neg
id|wbc-&gt;nonblocking
suffix:semicolon
r_int
id|err
suffix:semicolon
id|err
op_assign
id|generic_writepages
c_func
(paren
id|mapping
comma
id|wbc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out
suffix:semicolon
id|err
op_assign
id|nfs_flush_file
c_func
(paren
id|inode
comma
l_int|NULL
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|is_sync
)paren
id|err
op_assign
id|nfs_wb_all
c_func
(paren
id|inode
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; * Insert a write request into an inode&n; */
r_static
r_inline
r_int
DECL|function|nfs_inode_add_request
id|nfs_inode_add_request
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|nfs_page
op_star
id|req
)paren
(brace
r_struct
id|nfs_inode
op_star
id|nfsi
op_assign
id|NFS_I
c_func
(paren
id|inode
)paren
suffix:semicolon
r_int
id|error
suffix:semicolon
id|error
op_assign
id|radix_tree_insert
c_func
(paren
op_amp
id|nfsi-&gt;nfs_page_tree
comma
id|req-&gt;wb_index
comma
id|req
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|error
op_eq
op_minus
id|EEXIST
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|nfsi-&gt;npages
)paren
id|igrab
c_func
(paren
id|inode
)paren
suffix:semicolon
id|nfsi-&gt;npages
op_increment
suffix:semicolon
id|req-&gt;wb_count
op_increment
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Insert a write request into an inode&n; */
r_static
r_inline
r_void
DECL|function|nfs_inode_remove_request
id|nfs_inode_remove_request
c_func
(paren
r_struct
id|nfs_page
op_star
id|req
)paren
(brace
r_struct
id|nfs_inode
op_star
id|nfsi
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
id|BUG_ON
(paren
op_logical_neg
id|NFS_WBACK_BUSY
c_func
(paren
id|req
)paren
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|nfs_wreq_lock
)paren
suffix:semicolon
id|inode
op_assign
id|req-&gt;wb_inode
suffix:semicolon
id|nfsi
op_assign
id|NFS_I
c_func
(paren
id|inode
)paren
suffix:semicolon
id|radix_tree_delete
c_func
(paren
op_amp
id|nfsi-&gt;nfs_page_tree
comma
id|req-&gt;wb_index
)paren
suffix:semicolon
id|nfsi-&gt;npages
op_decrement
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|nfsi-&gt;npages
)paren
(brace
id|spin_unlock
c_func
(paren
op_amp
id|nfs_wreq_lock
)paren
suffix:semicolon
id|iput
c_func
(paren
id|inode
)paren
suffix:semicolon
)brace
r_else
id|spin_unlock
c_func
(paren
op_amp
id|nfs_wreq_lock
)paren
suffix:semicolon
id|nfs_clear_request
c_func
(paren
id|req
)paren
suffix:semicolon
id|nfs_release_request
c_func
(paren
id|req
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Find a request&n; */
r_static
r_inline
r_struct
id|nfs_page
op_star
DECL|function|_nfs_find_request
id|_nfs_find_request
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_int
r_int
id|index
)paren
(brace
r_struct
id|nfs_inode
op_star
id|nfsi
op_assign
id|NFS_I
c_func
(paren
id|inode
)paren
suffix:semicolon
r_struct
id|nfs_page
op_star
id|req
suffix:semicolon
id|req
op_assign
(paren
r_struct
id|nfs_page
op_star
)paren
id|radix_tree_lookup
c_func
(paren
op_amp
id|nfsi-&gt;nfs_page_tree
comma
id|index
)paren
suffix:semicolon
r_if
c_cond
(paren
id|req
)paren
id|req-&gt;wb_count
op_increment
suffix:semicolon
r_return
id|req
suffix:semicolon
)brace
r_static
r_struct
id|nfs_page
op_star
DECL|function|nfs_find_request
id|nfs_find_request
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_int
r_int
id|index
)paren
(brace
r_struct
id|nfs_page
op_star
id|req
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|nfs_wreq_lock
)paren
suffix:semicolon
id|req
op_assign
id|_nfs_find_request
c_func
(paren
id|inode
comma
id|index
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|nfs_wreq_lock
)paren
suffix:semicolon
r_return
id|req
suffix:semicolon
)brace
multiline_comment|/*&n; * Add a request to the inode&squot;s dirty list.&n; */
r_static
r_inline
r_void
DECL|function|nfs_mark_request_dirty
id|nfs_mark_request_dirty
c_func
(paren
r_struct
id|nfs_page
op_star
id|req
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|req-&gt;wb_inode
suffix:semicolon
r_struct
id|nfs_inode
op_star
id|nfsi
op_assign
id|NFS_I
c_func
(paren
id|inode
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|nfs_wreq_lock
)paren
suffix:semicolon
id|nfs_list_add_request
c_func
(paren
id|req
comma
op_amp
id|nfsi-&gt;dirty
)paren
suffix:semicolon
id|nfsi-&gt;ndirty
op_increment
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|nfs_wreq_lock
)paren
suffix:semicolon
id|mark_inode_dirty
c_func
(paren
id|inode
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Check if a request is dirty&n; */
r_static
r_inline
r_int
DECL|function|nfs_dirty_request
id|nfs_dirty_request
c_func
(paren
r_struct
id|nfs_page
op_star
id|req
)paren
(brace
r_struct
id|nfs_inode
op_star
id|nfsi
op_assign
id|NFS_I
c_func
(paren
id|req-&gt;wb_inode
)paren
suffix:semicolon
r_return
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|req-&gt;wb_list
)paren
op_logical_and
id|req-&gt;wb_list_head
op_eq
op_amp
id|nfsi-&gt;dirty
suffix:semicolon
)brace
macro_line|#if defined(CONFIG_NFS_V3) || defined(CONFIG_NFS_V4)
multiline_comment|/*&n; * Add a request to the inode&squot;s commit list.&n; */
r_static
r_inline
r_void
DECL|function|nfs_mark_request_commit
id|nfs_mark_request_commit
c_func
(paren
r_struct
id|nfs_page
op_star
id|req
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|req-&gt;wb_inode
suffix:semicolon
r_struct
id|nfs_inode
op_star
id|nfsi
op_assign
id|NFS_I
c_func
(paren
id|inode
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|nfs_wreq_lock
)paren
suffix:semicolon
id|nfs_list_add_request
c_func
(paren
id|req
comma
op_amp
id|nfsi-&gt;commit
)paren
suffix:semicolon
id|nfsi-&gt;ncommit
op_increment
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|nfs_wreq_lock
)paren
suffix:semicolon
id|mark_inode_dirty
c_func
(paren
id|inode
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n; * Wait for a request to complete.&n; *&n; * Interruptible by signals only if mounted with intr flag.&n; */
r_static
r_int
DECL|function|nfs_wait_on_requests
id|nfs_wait_on_requests
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|idx_start
comma
r_int
r_int
id|npages
)paren
(brace
r_struct
id|nfs_inode
op_star
id|nfsi
op_assign
id|NFS_I
c_func
(paren
id|inode
)paren
suffix:semicolon
r_struct
id|nfs_page
op_star
id|req
suffix:semicolon
r_int
r_int
id|idx_end
comma
id|next
suffix:semicolon
r_int
r_int
id|res
op_assign
l_int|0
suffix:semicolon
r_int
id|error
suffix:semicolon
r_if
c_cond
(paren
id|npages
op_eq
l_int|0
)paren
id|idx_end
op_assign
op_complement
l_int|0
suffix:semicolon
r_else
id|idx_end
op_assign
id|idx_start
op_plus
id|npages
op_minus
l_int|1
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|nfs_wreq_lock
)paren
suffix:semicolon
id|next
op_assign
id|idx_start
suffix:semicolon
r_while
c_loop
(paren
id|radix_tree_gang_lookup
c_func
(paren
op_amp
id|nfsi-&gt;nfs_page_tree
comma
(paren
r_void
op_star
op_star
)paren
op_amp
id|req
comma
id|next
comma
l_int|1
)paren
)paren
(brace
r_if
c_cond
(paren
id|req-&gt;wb_index
OG
id|idx_end
)paren
r_break
suffix:semicolon
id|next
op_assign
id|req-&gt;wb_index
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|file
op_logical_and
id|req-&gt;wb_file
op_ne
id|file
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|NFS_WBACK_BUSY
c_func
(paren
id|req
)paren
)paren
r_continue
suffix:semicolon
id|req-&gt;wb_count
op_increment
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|nfs_wreq_lock
)paren
suffix:semicolon
id|error
op_assign
id|nfs_wait_on_request
c_func
(paren
id|req
)paren
suffix:semicolon
id|nfs_release_request
c_func
(paren
id|req
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
OL
l_int|0
)paren
r_return
id|error
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|nfs_wreq_lock
)paren
suffix:semicolon
id|next
op_assign
id|idx_start
suffix:semicolon
id|res
op_increment
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|nfs_wreq_lock
)paren
suffix:semicolon
r_return
id|res
suffix:semicolon
)brace
multiline_comment|/*&n; * nfs_scan_dirty - Scan an inode for dirty requests&n; * @inode: NFS inode to scan&n; * @dst: destination list&n; * @file: if set, ensure we match requests from this file&n; * @idx_start: lower bound of page-&gt;index to scan.&n; * @npages: idx_start + npages sets the upper bound to scan.&n; *&n; * Moves requests from the inode&squot;s dirty page list.&n; * The requests are *not* checked to ensure that they form a contiguous set.&n; */
r_static
r_int
DECL|function|nfs_scan_dirty
id|nfs_scan_dirty
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|list_head
op_star
id|dst
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|idx_start
comma
r_int
r_int
id|npages
)paren
(brace
r_struct
id|nfs_inode
op_star
id|nfsi
op_assign
id|NFS_I
c_func
(paren
id|inode
)paren
suffix:semicolon
r_int
id|res
suffix:semicolon
id|res
op_assign
id|nfs_scan_list
c_func
(paren
op_amp
id|nfsi-&gt;dirty
comma
id|dst
comma
id|file
comma
id|idx_start
comma
id|npages
)paren
suffix:semicolon
id|nfsi-&gt;ndirty
op_sub_assign
id|res
suffix:semicolon
r_if
c_cond
(paren
(paren
id|nfsi-&gt;ndirty
op_eq
l_int|0
)paren
op_ne
id|list_empty
c_func
(paren
op_amp
id|nfsi-&gt;dirty
)paren
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;NFS: desynchronized value of nfs_i.ndirty.&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|res
suffix:semicolon
)brace
macro_line|#if defined(CONFIG_NFS_V3) || defined(CONFIG_NFS_V4)
multiline_comment|/*&n; * nfs_scan_commit - Scan an inode for commit requests&n; * @inode: NFS inode to scan&n; * @dst: destination list&n; * @file: if set, ensure we collect requests from this file only.&n; * @idx_start: lower bound of page-&gt;index to scan.&n; * @npages: idx_start + npages sets the upper bound to scan.&n; *&n; * Moves requests from the inode&squot;s &squot;commit&squot; request list.&n; * The requests are *not* checked to ensure that they form a contiguous set.&n; */
r_static
r_int
DECL|function|nfs_scan_commit
id|nfs_scan_commit
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|list_head
op_star
id|dst
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|idx_start
comma
r_int
r_int
id|npages
)paren
(brace
r_struct
id|nfs_inode
op_star
id|nfsi
op_assign
id|NFS_I
c_func
(paren
id|inode
)paren
suffix:semicolon
r_int
id|res
suffix:semicolon
id|res
op_assign
id|nfs_scan_list
c_func
(paren
op_amp
id|nfsi-&gt;commit
comma
id|dst
comma
id|file
comma
id|idx_start
comma
id|npages
)paren
suffix:semicolon
id|nfsi-&gt;ncommit
op_sub_assign
id|res
suffix:semicolon
r_if
c_cond
(paren
(paren
id|nfsi-&gt;ncommit
op_eq
l_int|0
)paren
op_ne
id|list_empty
c_func
(paren
op_amp
id|nfsi-&gt;commit
)paren
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;NFS: desynchronized value of nfs_i.ncommit.&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|res
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n; * Try to update any existing write request, or create one if there is none.&n; * In order to match, the request&squot;s credentials must match those of&n; * the calling process.&n; *&n; * Note: Should always be called with the Page Lock held!&n; */
r_static
r_struct
id|nfs_page
op_star
DECL|function|nfs_update_request
id|nfs_update_request
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|page
op_star
id|page
comma
r_int
r_int
id|offset
comma
r_int
r_int
id|bytes
)paren
(brace
r_struct
id|nfs_page
op_star
id|req
comma
op_star
r_new
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|rqend
comma
id|end
suffix:semicolon
id|end
op_assign
id|offset
op_plus
id|bytes
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
multiline_comment|/* Loop over all inode entries and see if we find&n;&t;&t; * A request for the page we wish to update&n;&t;&t; */
id|spin_lock
c_func
(paren
op_amp
id|nfs_wreq_lock
)paren
suffix:semicolon
id|req
op_assign
id|_nfs_find_request
c_func
(paren
id|inode
comma
id|page-&gt;index
)paren
suffix:semicolon
r_if
c_cond
(paren
id|req
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|nfs_lock_request_dontget
c_func
(paren
id|req
)paren
)paren
(brace
r_int
id|error
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|nfs_wreq_lock
)paren
suffix:semicolon
id|error
op_assign
id|nfs_wait_on_request
c_func
(paren
id|req
)paren
suffix:semicolon
id|nfs_release_request
c_func
(paren
id|req
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
OL
l_int|0
)paren
r_return
id|ERR_PTR
c_func
(paren
id|error
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|nfs_wreq_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
r_new
)paren
id|nfs_release_request
c_func
(paren
r_new
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
r_new
)paren
(brace
r_int
id|error
suffix:semicolon
id|nfs_lock_request_dontget
c_func
(paren
r_new
)paren
suffix:semicolon
id|error
op_assign
id|nfs_inode_add_request
c_func
(paren
id|inode
comma
r_new
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|spin_unlock
c_func
(paren
op_amp
id|nfs_wreq_lock
)paren
suffix:semicolon
id|nfs_unlock_request
c_func
(paren
r_new
)paren
suffix:semicolon
r_return
id|ERR_PTR
c_func
(paren
id|error
)paren
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|nfs_wreq_lock
)paren
suffix:semicolon
id|nfs_mark_request_dirty
c_func
(paren
r_new
)paren
suffix:semicolon
r_return
r_new
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|nfs_wreq_lock
)paren
suffix:semicolon
r_new
op_assign
id|nfs_create_request
c_func
(paren
id|nfs_file_cred
c_func
(paren
id|file
)paren
comma
id|inode
comma
id|page
comma
id|offset
comma
id|bytes
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
r_new
)paren
)paren
r_return
r_new
suffix:semicolon
r_if
c_cond
(paren
id|file
)paren
(brace
r_new
op_member_access_from_pointer
id|wb_file
op_assign
id|file
suffix:semicolon
id|get_file
c_func
(paren
id|file
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* We have a request for our page.&n;&t; * If the creds don&squot;t match, or the&n;&t; * page addresses don&squot;t match,&n;&t; * tell the caller to wait on the conflicting&n;&t; * request.&n;&t; */
id|rqend
op_assign
id|req-&gt;wb_offset
op_plus
id|req-&gt;wb_bytes
suffix:semicolon
r_if
c_cond
(paren
id|req-&gt;wb_file
op_ne
id|file
op_logical_or
id|req-&gt;wb_page
op_ne
id|page
op_logical_or
op_logical_neg
id|nfs_dirty_request
c_func
(paren
id|req
)paren
op_logical_or
id|offset
OG
id|rqend
op_logical_or
id|end
OL
id|req-&gt;wb_offset
)paren
(brace
id|nfs_unlock_request
c_func
(paren
id|req
)paren
suffix:semicolon
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|EBUSY
)paren
suffix:semicolon
)brace
multiline_comment|/* Okay, the request matches. Update the region */
r_if
c_cond
(paren
id|offset
OL
id|req-&gt;wb_offset
)paren
(brace
id|req-&gt;wb_offset
op_assign
id|offset
suffix:semicolon
id|req-&gt;wb_bytes
op_assign
id|rqend
op_minus
id|req-&gt;wb_offset
suffix:semicolon
)brace
r_if
c_cond
(paren
id|end
OG
id|rqend
)paren
id|req-&gt;wb_bytes
op_assign
id|end
op_minus
id|req-&gt;wb_offset
suffix:semicolon
r_return
id|req
suffix:semicolon
)brace
multiline_comment|/*&n; * This is the strategy routine for NFS.&n; * It is called by nfs_updatepage whenever the user wrote up to the end&n; * of a page.&n; *&n; * We always try to submit a set of requests in parallel so that the&n; * server&squot;s write code can gather writes. This is mainly for the benefit&n; * of NFSv2.&n; *&n; * We never submit more requests than we think the remote can handle.&n; * For UDP sockets, we make sure we don&squot;t exceed the congestion window;&n; * for TCP, we limit the number of requests to 8.&n; *&n; * NFS_STRATEGY_PAGES gives the minimum number of requests for NFSv2 that&n; * should be sent out in one go. This is for the benefit of NFSv2 servers&n; * that perform write gathering.&n; *&n; * FIXME: Different servers may have different sweet spots.&n; * Record the average congestion window in server struct?&n; */
DECL|macro|NFS_STRATEGY_PAGES
mdefine_line|#define NFS_STRATEGY_PAGES      8
r_static
r_void
DECL|function|nfs_strategy
id|nfs_strategy
c_func
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
r_int
r_int
id|dirty
comma
id|wpages
suffix:semicolon
id|dirty
op_assign
id|NFS_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|ndirty
suffix:semicolon
id|wpages
op_assign
id|NFS_SERVER
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|wpages
suffix:semicolon
macro_line|#if defined(CONFIG_NFS_V3) || defined(CONFIG_NFS_V4)
r_if
c_cond
(paren
id|NFS_PROTO
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|version
op_eq
l_int|2
)paren
(brace
r_if
c_cond
(paren
id|dirty
op_ge
id|NFS_STRATEGY_PAGES
op_star
id|wpages
)paren
id|nfs_flush_file
c_func
(paren
id|inode
comma
l_int|NULL
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|dirty
op_ge
id|wpages
)paren
id|nfs_flush_file
c_func
(paren
id|inode
comma
l_int|NULL
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
macro_line|#else
r_if
c_cond
(paren
id|dirty
op_ge
id|NFS_STRATEGY_PAGES
op_star
id|wpages
)paren
id|nfs_flush_file
c_func
(paren
id|inode
comma
l_int|NULL
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
macro_line|#endif
)brace
r_int
DECL|function|nfs_flush_incompatible
id|nfs_flush_incompatible
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_struct
id|page
op_star
id|page
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|page-&gt;mapping-&gt;host
suffix:semicolon
r_struct
id|rpc_cred
op_star
id|cred
op_assign
id|nfs_file_cred
c_func
(paren
id|file
)paren
suffix:semicolon
r_struct
id|nfs_page
op_star
id|req
suffix:semicolon
r_int
id|status
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Look for a request corresponding to this page. If there&n;&t; * is one, and it belongs to another file, we flush it out&n;&t; * before we try to copy anything into the page. Do this&n;&t; * due to the lack of an ACCESS-type call in NFSv2.&n;&t; * Also do the same if we find a request from an existing&n;&t; * dropped page.&n;&t; */
id|req
op_assign
id|nfs_find_request
c_func
(paren
id|inode
comma
id|page-&gt;index
)paren
suffix:semicolon
r_if
c_cond
(paren
id|req
)paren
(brace
r_if
c_cond
(paren
id|req-&gt;wb_file
op_ne
id|file
op_logical_or
id|req-&gt;wb_cred
op_ne
id|cred
op_logical_or
id|req-&gt;wb_page
op_ne
id|page
)paren
id|status
op_assign
id|nfs_wb_page
c_func
(paren
id|inode
comma
id|page
)paren
suffix:semicolon
id|nfs_release_request
c_func
(paren
id|req
)paren
suffix:semicolon
)brace
r_return
(paren
id|status
OL
l_int|0
)paren
ques
c_cond
id|status
suffix:colon
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Update and possibly write a cached page of an NFS file.&n; *&n; * XXX: Keep an eye on generic_file_read to make sure it doesn&squot;t do bad&n; * things with a page scheduled for an RPC call (e.g. invalidate it).&n; */
r_int
DECL|function|nfs_updatepage
id|nfs_updatepage
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_struct
id|page
op_star
id|page
comma
r_int
r_int
id|offset
comma
r_int
r_int
id|count
)paren
(brace
r_struct
id|dentry
op_star
id|dentry
op_assign
id|file-&gt;f_dentry
suffix:semicolon
r_struct
id|inode
op_star
id|inode
op_assign
id|page-&gt;mapping-&gt;host
suffix:semicolon
r_struct
id|nfs_page
op_star
id|req
suffix:semicolon
id|loff_t
id|end
suffix:semicolon
r_int
id|status
op_assign
l_int|0
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;NFS:      nfs_updatepage(%s/%s %d@%Ld)&bslash;n&quot;
comma
id|dentry-&gt;d_parent-&gt;d_name.name
comma
id|dentry-&gt;d_name.name
comma
id|count
comma
(paren
r_int
r_int
)paren
(paren
id|page_offset
c_func
(paren
id|page
)paren
op_plus
id|offset
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If wsize is smaller than page size, update and write&n;&t; * page synchronously.&n;&t; */
r_if
c_cond
(paren
id|NFS_SERVER
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|wsize
OL
id|PAGE_CACHE_SIZE
op_logical_or
id|IS_SYNC
c_func
(paren
id|inode
)paren
)paren
(brace
id|status
op_assign
id|nfs_writepage_sync
c_func
(paren
id|file
comma
id|inode
comma
id|page
comma
id|offset
comma
id|count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|offset
op_eq
l_int|0
op_logical_and
id|status
op_eq
id|PAGE_CACHE_SIZE
)paren
id|SetPageUptodate
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
id|status
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Try to find an NFS request corresponding to this page&n;&t; * and update it.&n;&t; * If the existing request cannot be updated, we must flush&n;&t; * it out now.&n;&t; */
r_do
(brace
id|req
op_assign
id|nfs_update_request
c_func
(paren
id|file
comma
id|inode
comma
id|page
comma
id|offset
comma
id|count
)paren
suffix:semicolon
id|status
op_assign
(paren
id|IS_ERR
c_func
(paren
id|req
)paren
)paren
ques
c_cond
id|PTR_ERR
c_func
(paren
id|req
)paren
suffix:colon
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|status
op_ne
op_minus
id|EBUSY
)paren
r_break
suffix:semicolon
multiline_comment|/* Request could not be updated. Flush it out and try again */
id|status
op_assign
id|nfs_wb_page
c_func
(paren
id|inode
comma
id|page
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|status
op_ge
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
OL
l_int|0
)paren
r_goto
id|done
suffix:semicolon
id|status
op_assign
l_int|0
suffix:semicolon
id|end
op_assign
(paren
(paren
id|loff_t
)paren
id|page-&gt;index
op_lshift
id|PAGE_CACHE_SHIFT
)paren
op_plus
(paren
id|loff_t
)paren
(paren
id|offset
op_plus
id|count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inode-&gt;i_size
OL
id|end
)paren
id|inode-&gt;i_size
op_assign
id|end
suffix:semicolon
multiline_comment|/* If we wrote past the end of the page.&n;&t; * Call the strategy routine so it can send out a bunch&n;&t; * of requests.&n;&t; */
r_if
c_cond
(paren
id|req-&gt;wb_offset
op_eq
l_int|0
op_logical_and
id|req-&gt;wb_bytes
op_eq
id|PAGE_CACHE_SIZE
)paren
(brace
id|SetPageUptodate
c_func
(paren
id|page
)paren
suffix:semicolon
id|nfs_unlock_request
c_func
(paren
id|req
)paren
suffix:semicolon
id|nfs_strategy
c_func
(paren
id|inode
)paren
suffix:semicolon
)brace
r_else
id|nfs_unlock_request
c_func
(paren
id|req
)paren
suffix:semicolon
id|done
suffix:colon
id|dprintk
c_func
(paren
l_string|&quot;NFS:      nfs_updatepage returns %d (isize %Ld)&bslash;n&quot;
comma
id|status
comma
(paren
r_int
r_int
)paren
id|inode-&gt;i_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
OL
l_int|0
)paren
id|ClearPageUptodate
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
id|status
suffix:semicolon
)brace
multiline_comment|/*&n; * Set up the argument/result storage required for the RPC call.&n; */
r_static
r_void
DECL|function|nfs_write_rpcsetup
id|nfs_write_rpcsetup
c_func
(paren
r_struct
id|list_head
op_star
id|head
comma
r_struct
id|nfs_write_data
op_star
id|data
comma
r_int
id|how
)paren
(brace
r_struct
id|rpc_task
op_star
id|task
op_assign
op_amp
id|data-&gt;task
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_struct
id|nfs_page
op_star
id|req
suffix:semicolon
r_struct
id|page
op_star
op_star
id|pages
suffix:semicolon
r_int
r_int
id|count
suffix:semicolon
multiline_comment|/* Set up the RPC argument and reply structs&n;&t; * NB: take care not to mess about with data-&gt;commit et al. */
id|pages
op_assign
id|data-&gt;pagevec
suffix:semicolon
id|count
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
id|head
)paren
)paren
(brace
id|req
op_assign
id|nfs_list_entry
c_func
(paren
id|head-&gt;next
)paren
suffix:semicolon
id|nfs_list_remove_request
c_func
(paren
id|req
)paren
suffix:semicolon
id|nfs_list_add_request
c_func
(paren
id|req
comma
op_amp
id|data-&gt;pages
)paren
suffix:semicolon
id|SetPageWriteback
c_func
(paren
id|req-&gt;wb_page
)paren
suffix:semicolon
op_star
id|pages
op_increment
op_assign
id|req-&gt;wb_page
suffix:semicolon
id|count
op_add_assign
id|req-&gt;wb_bytes
suffix:semicolon
)brace
id|req
op_assign
id|nfs_list_entry
c_func
(paren
id|data-&gt;pages.next
)paren
suffix:semicolon
id|data-&gt;inode
op_assign
id|inode
op_assign
id|req-&gt;wb_inode
suffix:semicolon
id|data-&gt;cred
op_assign
id|req-&gt;wb_cred
suffix:semicolon
id|NFS_PROTO
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|write_setup
c_func
(paren
id|data
comma
id|count
comma
id|how
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;NFS: %4d initiated write call (req %s/%Ld, %u bytes @ offset %Lu)&bslash;n&quot;
comma
id|task-&gt;tk_pid
comma
id|inode-&gt;i_sb-&gt;s_id
comma
(paren
r_int
r_int
)paren
id|NFS_FILEID
c_func
(paren
id|inode
)paren
comma
id|count
comma
(paren
r_int
r_int
r_int
)paren
id|req_offset
c_func
(paren
id|req
)paren
op_plus
id|req-&gt;wb_offset
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Create an RPC task for the given write request and kick it.&n; * The page must have been locked by the caller.&n; *&n; * It may happen that the page we&squot;re passed is not marked dirty.&n; * This is the case if nfs_updatepage detects a conflicting request&n; * that has been written but not committed.&n; */
r_static
r_int
DECL|function|nfs_flush_one
id|nfs_flush_one
c_func
(paren
r_struct
id|list_head
op_star
id|head
comma
r_struct
id|inode
op_star
id|inode
comma
r_int
id|how
)paren
(brace
r_struct
id|rpc_clnt
op_star
id|clnt
op_assign
id|NFS_CLIENT
c_func
(paren
id|inode
)paren
suffix:semicolon
r_struct
id|nfs_write_data
op_star
id|data
suffix:semicolon
id|sigset_t
id|oldset
suffix:semicolon
id|data
op_assign
id|nfs_writedata_alloc
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|data
)paren
r_goto
id|out_bad
suffix:semicolon
multiline_comment|/* Set up the argument struct */
id|nfs_write_rpcsetup
c_func
(paren
id|head
comma
id|data
comma
id|how
)paren
suffix:semicolon
id|rpc_clnt_sigmask
c_func
(paren
id|clnt
comma
op_amp
id|oldset
)paren
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|rpc_execute
c_func
(paren
op_amp
id|data-&gt;task
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
id|rpc_clnt_sigunmask
c_func
(paren
id|clnt
comma
op_amp
id|oldset
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|out_bad
suffix:colon
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
id|head
)paren
)paren
(brace
r_struct
id|nfs_page
op_star
id|req
op_assign
id|nfs_list_entry
c_func
(paren
id|head-&gt;next
)paren
suffix:semicolon
id|nfs_list_remove_request
c_func
(paren
id|req
)paren
suffix:semicolon
id|nfs_mark_request_dirty
c_func
(paren
id|req
)paren
suffix:semicolon
id|nfs_unlock_request
c_func
(paren
id|req
)paren
suffix:semicolon
)brace
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_int
DECL|function|nfs_flush_list
id|nfs_flush_list
c_func
(paren
r_struct
id|list_head
op_star
id|head
comma
r_int
id|wpages
comma
r_int
id|how
)paren
(brace
id|LIST_HEAD
c_func
(paren
id|one_request
)paren
suffix:semicolon
r_struct
id|nfs_page
op_star
id|req
suffix:semicolon
r_int
id|error
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|pages
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
id|head
)paren
)paren
(brace
id|pages
op_add_assign
id|nfs_coalesce_requests
c_func
(paren
id|head
comma
op_amp
id|one_request
comma
id|wpages
)paren
suffix:semicolon
id|req
op_assign
id|nfs_list_entry
c_func
(paren
id|one_request.next
)paren
suffix:semicolon
id|error
op_assign
id|nfs_flush_one
c_func
(paren
op_amp
id|one_request
comma
id|req-&gt;wb_inode
comma
id|how
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
OL
l_int|0
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|error
op_ge
l_int|0
)paren
r_return
id|pages
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
id|head
)paren
)paren
(brace
id|req
op_assign
id|nfs_list_entry
c_func
(paren
id|head-&gt;next
)paren
suffix:semicolon
id|nfs_list_remove_request
c_func
(paren
id|req
)paren
suffix:semicolon
id|nfs_mark_request_dirty
c_func
(paren
id|req
)paren
suffix:semicolon
id|nfs_unlock_request
c_func
(paren
id|req
)paren
suffix:semicolon
)brace
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * This function is called when the WRITE call is complete.&n; */
r_void
DECL|function|nfs_writeback_done
id|nfs_writeback_done
c_func
(paren
r_struct
id|rpc_task
op_star
id|task
comma
r_int
id|stable
comma
r_int
r_int
id|arg_count
comma
r_int
r_int
id|res_count
)paren
(brace
r_struct
id|nfs_write_data
op_star
id|data
op_assign
(paren
r_struct
id|nfs_write_data
op_star
)paren
id|task-&gt;tk_calldata
suffix:semicolon
r_struct
id|inode
op_star
id|inode
op_assign
id|data-&gt;inode
suffix:semicolon
r_struct
id|nfs_page
op_star
id|req
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;NFS: %4d nfs_writeback_done (status %d)&bslash;n&quot;
comma
id|task-&gt;tk_pid
comma
id|task-&gt;tk_status
)paren
suffix:semicolon
multiline_comment|/* We can&squot;t handle that yet but we check for it nevertheless */
r_if
c_cond
(paren
id|res_count
OL
id|arg_count
op_logical_and
id|task-&gt;tk_status
op_ge
l_int|0
)paren
(brace
r_static
r_int
r_int
id|complain
suffix:semicolon
r_if
c_cond
(paren
id|time_before
c_func
(paren
id|complain
comma
id|jiffies
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;NFS: Server wrote less than requested.&bslash;n&quot;
)paren
suffix:semicolon
id|complain
op_assign
id|jiffies
op_plus
l_int|300
op_star
id|HZ
suffix:semicolon
)brace
multiline_comment|/* Can&squot;t do anything about it right now except throw&n;&t;&t; * an error. */
id|task-&gt;tk_status
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
macro_line|#if defined(CONFIG_NFS_V3) || defined(CONFIG_NFS_V4)
r_if
c_cond
(paren
id|data-&gt;verf.committed
OL
id|stable
op_logical_and
id|task-&gt;tk_status
op_ge
l_int|0
)paren
(brace
multiline_comment|/* We tried a write call, but the server did not&n;&t;&t; * commit data to stable storage even though we&n;&t;&t; * requested it.&n;&t;&t; * Note: There is a known bug in Tru64 &lt; 5.0 in which&n;&t;&t; *&t; the server reports NFS_DATA_SYNC, but performs&n;&t;&t; *&t; NFS_FILE_SYNC. We therefore implement this checking&n;&t;&t; *&t; as a dprintk() in order to avoid filling syslog.&n;&t;&t; */
r_static
r_int
r_int
id|complain
suffix:semicolon
r_if
c_cond
(paren
id|time_before
c_func
(paren
id|complain
comma
id|jiffies
)paren
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;NFS: faulty NFS server %s:&quot;
l_string|&quot; (committed = %d) != (stable = %d)&bslash;n&quot;
comma
id|NFS_SERVER
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|hostname
comma
id|data-&gt;verf.committed
comma
id|stable
)paren
suffix:semicolon
id|complain
op_assign
id|jiffies
op_plus
l_int|300
op_star
id|HZ
suffix:semicolon
)brace
)brace
macro_line|#endif
multiline_comment|/*&n;&t; * Update attributes as result of writeback.&n;&t; * FIXME: There is an inherent race with invalidate_inode_pages and&n;&t; *&t;  writebacks since the page-&gt;count is kept &gt; 1 for as long&n;&t; *&t;  as the page has a write request pending.&n;&t; */
id|nfs_write_attributes
c_func
(paren
id|inode
comma
op_amp
id|data-&gt;fattr
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|data-&gt;pages
)paren
)paren
(brace
id|req
op_assign
id|nfs_list_entry
c_func
(paren
id|data-&gt;pages.next
)paren
suffix:semicolon
id|nfs_list_remove_request
c_func
(paren
id|req
)paren
suffix:semicolon
id|page
op_assign
id|req-&gt;wb_page
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;NFS: write (%s/%Ld %d@%Ld)&quot;
comma
id|req-&gt;wb_inode-&gt;i_sb-&gt;s_id
comma
(paren
r_int
r_int
)paren
id|NFS_FILEID
c_func
(paren
id|req-&gt;wb_inode
)paren
comma
id|req-&gt;wb_bytes
comma
(paren
r_int
r_int
)paren
(paren
id|req_offset
c_func
(paren
id|req
)paren
op_plus
id|req-&gt;wb_offset
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|task-&gt;tk_status
OL
l_int|0
)paren
(brace
id|ClearPageUptodate
c_func
(paren
id|page
)paren
suffix:semicolon
id|SetPageError
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|req-&gt;wb_file
)paren
id|req-&gt;wb_file-&gt;f_error
op_assign
id|task-&gt;tk_status
suffix:semicolon
id|end_page_writeback
c_func
(paren
id|page
)paren
suffix:semicolon
id|nfs_inode_remove_request
c_func
(paren
id|req
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;, error = %d&bslash;n&quot;
comma
id|task-&gt;tk_status
)paren
suffix:semicolon
r_goto
id|next
suffix:semicolon
)brace
id|end_page_writeback
c_func
(paren
id|page
)paren
suffix:semicolon
macro_line|#if defined(CONFIG_NFS_V3) || defined(CONFIG_NFS_V4)
r_if
c_cond
(paren
id|stable
op_ne
id|NFS_UNSTABLE
op_logical_or
id|data-&gt;verf.committed
op_eq
id|NFS_FILE_SYNC
)paren
(brace
id|nfs_inode_remove_request
c_func
(paren
id|req
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot; OK&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|next
suffix:semicolon
)brace
id|memcpy
c_func
(paren
op_amp
id|req-&gt;wb_verf
comma
op_amp
id|data-&gt;verf
comma
r_sizeof
(paren
id|req-&gt;wb_verf
)paren
)paren
suffix:semicolon
id|nfs_mark_request_commit
c_func
(paren
id|req
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot; marked for commit&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#else
id|nfs_inode_remove_request
c_func
(paren
id|req
)paren
suffix:semicolon
macro_line|#endif
id|next
suffix:colon
id|nfs_unlock_request
c_func
(paren
id|req
)paren
suffix:semicolon
)brace
)brace
macro_line|#if defined(CONFIG_NFS_V3) || defined(CONFIG_NFS_V4)
multiline_comment|/*&n; * Set up the argument/result storage required for the RPC call.&n; */
r_static
r_void
DECL|function|nfs_commit_rpcsetup
id|nfs_commit_rpcsetup
c_func
(paren
r_struct
id|list_head
op_star
id|head
comma
r_struct
id|nfs_write_data
op_star
id|data
comma
r_int
id|how
)paren
(brace
r_struct
id|rpc_task
op_star
id|task
op_assign
op_amp
id|data-&gt;task
suffix:semicolon
r_struct
id|nfs_page
op_star
id|first
comma
op_star
id|last
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
id|loff_t
id|start
comma
id|end
comma
id|len
suffix:semicolon
multiline_comment|/* Set up the RPC argument and reply structs&n;&t; * NB: take care not to mess about with data-&gt;commit et al. */
id|list_splice_init
c_func
(paren
id|head
comma
op_amp
id|data-&gt;pages
)paren
suffix:semicolon
id|first
op_assign
id|nfs_list_entry
c_func
(paren
id|data-&gt;pages.next
)paren
suffix:semicolon
id|last
op_assign
id|nfs_list_entry
c_func
(paren
id|data-&gt;pages.prev
)paren
suffix:semicolon
id|inode
op_assign
id|first-&gt;wb_inode
suffix:semicolon
multiline_comment|/*&n;&t; * Determine the offset range of requests in the COMMIT call.&n;&t; * We rely on the fact that data-&gt;pages is an ordered list...&n;&t; */
id|start
op_assign
id|req_offset
c_func
(paren
id|first
)paren
op_plus
id|first-&gt;wb_offset
suffix:semicolon
id|end
op_assign
id|req_offset
c_func
(paren
id|last
)paren
op_plus
(paren
id|last-&gt;wb_offset
op_plus
id|last-&gt;wb_bytes
)paren
suffix:semicolon
id|len
op_assign
id|end
op_minus
id|start
suffix:semicolon
multiline_comment|/* If &squot;len&squot; is not a 32-bit quantity, pass &squot;0&squot; in the COMMIT call */
r_if
c_cond
(paren
id|end
op_ge
id|inode-&gt;i_size
op_logical_or
id|len
template_param
(paren
op_complement
(paren
(paren
id|u32
)paren
l_int|0
)paren
op_rshift
l_int|1
)paren
)paren
id|len
op_assign
l_int|0
suffix:semicolon
id|data-&gt;inode
op_assign
id|inode
suffix:semicolon
id|data-&gt;cred
op_assign
id|first-&gt;wb_cred
suffix:semicolon
id|NFS_PROTO
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|commit_setup
c_func
(paren
id|data
comma
id|start
comma
id|len
comma
id|how
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;NFS: %4d initiated commit call&bslash;n&quot;
comma
id|task-&gt;tk_pid
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Commit dirty pages&n; */
r_int
DECL|function|nfs_commit_list
id|nfs_commit_list
c_func
(paren
r_struct
id|list_head
op_star
id|head
comma
r_int
id|how
)paren
(brace
r_struct
id|rpc_clnt
op_star
id|clnt
suffix:semicolon
r_struct
id|nfs_write_data
op_star
id|data
suffix:semicolon
r_struct
id|nfs_page
op_star
id|req
suffix:semicolon
id|sigset_t
id|oldset
suffix:semicolon
id|data
op_assign
id|nfs_commit_alloc
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|data
)paren
r_goto
id|out_bad
suffix:semicolon
multiline_comment|/* Set up the argument struct */
id|nfs_commit_rpcsetup
c_func
(paren
id|head
comma
id|data
comma
id|how
)paren
suffix:semicolon
id|clnt
op_assign
id|NFS_CLIENT
c_func
(paren
id|data-&gt;inode
)paren
suffix:semicolon
id|rpc_clnt_sigmask
c_func
(paren
id|clnt
comma
op_amp
id|oldset
)paren
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|rpc_execute
c_func
(paren
op_amp
id|data-&gt;task
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
id|rpc_clnt_sigunmask
c_func
(paren
id|clnt
comma
op_amp
id|oldset
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|out_bad
suffix:colon
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
id|head
)paren
)paren
(brace
id|req
op_assign
id|nfs_list_entry
c_func
(paren
id|head-&gt;next
)paren
suffix:semicolon
id|nfs_list_remove_request
c_func
(paren
id|req
)paren
suffix:semicolon
id|nfs_mark_request_commit
c_func
(paren
id|req
)paren
suffix:semicolon
id|nfs_unlock_request
c_func
(paren
id|req
)paren
suffix:semicolon
)brace
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
multiline_comment|/*&n; * COMMIT call returned&n; */
r_void
DECL|function|nfs_commit_done
id|nfs_commit_done
c_func
(paren
r_struct
id|rpc_task
op_star
id|task
)paren
(brace
r_struct
id|nfs_write_data
op_star
id|data
op_assign
(paren
r_struct
id|nfs_write_data
op_star
)paren
id|task-&gt;tk_calldata
suffix:semicolon
r_struct
id|nfs_page
op_star
id|req
suffix:semicolon
r_struct
id|inode
op_star
id|inode
op_assign
id|data-&gt;inode
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;NFS: %4d nfs_commit_done (status %d)&bslash;n&quot;
comma
id|task-&gt;tk_pid
comma
id|task-&gt;tk_status
)paren
suffix:semicolon
id|nfs_write_attributes
c_func
(paren
id|inode
comma
op_amp
id|data-&gt;fattr
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|data-&gt;pages
)paren
)paren
(brace
id|req
op_assign
id|nfs_list_entry
c_func
(paren
id|data-&gt;pages.next
)paren
suffix:semicolon
id|nfs_list_remove_request
c_func
(paren
id|req
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;NFS: commit (%s/%Ld %d@%Ld)&quot;
comma
id|req-&gt;wb_inode-&gt;i_sb-&gt;s_id
comma
(paren
r_int
r_int
)paren
id|NFS_FILEID
c_func
(paren
id|req-&gt;wb_inode
)paren
comma
id|req-&gt;wb_bytes
comma
(paren
r_int
r_int
)paren
(paren
id|req_offset
c_func
(paren
id|req
)paren
op_plus
id|req-&gt;wb_offset
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|task-&gt;tk_status
OL
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|req-&gt;wb_file
)paren
id|req-&gt;wb_file-&gt;f_error
op_assign
id|task-&gt;tk_status
suffix:semicolon
id|nfs_inode_remove_request
c_func
(paren
id|req
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;, error = %d&bslash;n&quot;
comma
id|task-&gt;tk_status
)paren
suffix:semicolon
r_goto
id|next
suffix:semicolon
)brace
multiline_comment|/* Okay, COMMIT succeeded, apparently. Check the verifier&n;&t;&t; * returned by the server against all stored verfs. */
r_if
c_cond
(paren
op_logical_neg
id|memcmp
c_func
(paren
id|req-&gt;wb_verf.verifier
comma
id|data-&gt;verf.verifier
comma
r_sizeof
(paren
id|data-&gt;verf.verifier
)paren
)paren
)paren
(brace
multiline_comment|/* We have a match */
id|nfs_inode_remove_request
c_func
(paren
id|req
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot; OK&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|next
suffix:semicolon
)brace
multiline_comment|/* We have a mismatch. Write the page again */
id|dprintk
c_func
(paren
l_string|&quot; mismatch&bslash;n&quot;
)paren
suffix:semicolon
id|nfs_mark_request_dirty
c_func
(paren
id|req
)paren
suffix:semicolon
id|next
suffix:colon
id|nfs_unlock_request
c_func
(paren
id|req
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
DECL|function|nfs_flush_file
r_int
id|nfs_flush_file
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|idx_start
comma
r_int
r_int
id|npages
comma
r_int
id|how
)paren
(brace
id|LIST_HEAD
c_func
(paren
id|head
)paren
suffix:semicolon
r_int
id|res
comma
id|error
op_assign
l_int|0
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|nfs_wreq_lock
)paren
suffix:semicolon
id|res
op_assign
id|nfs_scan_dirty
c_func
(paren
id|inode
comma
op_amp
id|head
comma
id|file
comma
id|idx_start
comma
id|npages
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|nfs_wreq_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res
)paren
id|error
op_assign
id|nfs_flush_list
c_func
(paren
op_amp
id|head
comma
id|NFS_SERVER
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|wpages
comma
id|how
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
OL
l_int|0
)paren
r_return
id|error
suffix:semicolon
r_return
id|res
suffix:semicolon
)brace
macro_line|#if defined(CONFIG_NFS_V3) || defined(CONFIG_NFS_V4)
DECL|function|nfs_commit_file
r_int
id|nfs_commit_file
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|idx_start
comma
r_int
r_int
id|npages
comma
r_int
id|how
)paren
(brace
id|LIST_HEAD
c_func
(paren
id|head
)paren
suffix:semicolon
r_int
id|res
comma
id|error
op_assign
l_int|0
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|nfs_wreq_lock
)paren
suffix:semicolon
id|res
op_assign
id|nfs_scan_commit
c_func
(paren
id|inode
comma
op_amp
id|head
comma
id|file
comma
id|idx_start
comma
id|npages
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|nfs_wreq_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res
)paren
id|error
op_assign
id|nfs_commit_list
c_func
(paren
op_amp
id|head
comma
id|how
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
OL
l_int|0
)paren
r_return
id|error
suffix:semicolon
r_return
id|res
suffix:semicolon
)brace
macro_line|#endif
DECL|function|nfs_sync_file
r_int
id|nfs_sync_file
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|idx_start
comma
r_int
r_int
id|npages
comma
r_int
id|how
)paren
(brace
r_int
id|error
comma
id|wait
suffix:semicolon
id|wait
op_assign
id|how
op_amp
id|FLUSH_WAIT
suffix:semicolon
id|how
op_and_assign
op_complement
id|FLUSH_WAIT
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inode
op_logical_and
id|file
)paren
id|inode
op_assign
id|file-&gt;f_dentry-&gt;d_inode
suffix:semicolon
r_do
(brace
id|error
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|wait
)paren
id|error
op_assign
id|nfs_wait_on_requests
c_func
(paren
id|inode
comma
id|file
comma
id|idx_start
comma
id|npages
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_eq
l_int|0
)paren
id|error
op_assign
id|nfs_flush_file
c_func
(paren
id|inode
comma
id|file
comma
id|idx_start
comma
id|npages
comma
id|how
)paren
suffix:semicolon
macro_line|#if defined(CONFIG_NFS_V3) || defined(CONFIG_NFS_V4)
r_if
c_cond
(paren
id|error
op_eq
l_int|0
)paren
id|error
op_assign
id|nfs_commit_file
c_func
(paren
id|inode
comma
id|file
comma
id|idx_start
comma
id|npages
comma
id|how
)paren
suffix:semicolon
macro_line|#endif
)brace
r_while
c_loop
(paren
id|error
OG
l_int|0
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
DECL|function|nfs_init_writepagecache
r_int
id|nfs_init_writepagecache
c_func
(paren
r_void
)paren
(brace
id|nfs_wdata_cachep
op_assign
id|kmem_cache_create
c_func
(paren
l_string|&quot;nfs_write_data&quot;
comma
r_sizeof
(paren
r_struct
id|nfs_write_data
)paren
comma
l_int|0
comma
id|SLAB_HWCACHE_ALIGN
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nfs_wdata_cachep
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|nfs_wdata_mempool
op_assign
id|mempool_create
c_func
(paren
id|MIN_POOL_WRITE
comma
id|mempool_alloc_slab
comma
id|mempool_free_slab
comma
id|nfs_wdata_cachep
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nfs_wdata_mempool
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|nfs_commit_mempool
op_assign
id|mempool_create
c_func
(paren
id|MIN_POOL_COMMIT
comma
id|mempool_alloc_slab
comma
id|mempool_free_slab
comma
id|nfs_wdata_cachep
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nfs_commit_mempool
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|nfs_destroy_writepagecache
r_void
id|nfs_destroy_writepagecache
c_func
(paren
r_void
)paren
(brace
id|mempool_destroy
c_func
(paren
id|nfs_commit_mempool
)paren
suffix:semicolon
id|mempool_destroy
c_func
(paren
id|nfs_wdata_mempool
)paren
suffix:semicolon
r_if
c_cond
(paren
id|kmem_cache_destroy
c_func
(paren
id|nfs_wdata_cachep
)paren
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;nfs_write_data: not all structures were freed&bslash;n&quot;
)paren
suffix:semicolon
)brace
eof
