multiline_comment|/*&n; *  fs/nfs/nfs4renewd.c&n; *&n; *  Copyright (c) 2002 The Regents of the University of Michigan.&n; *  All rights reserved.&n; *&n; *  Kendrick Smith &lt;kmsmith@umich.edu&gt;&n; *&n; *  Redistribution and use in source and binary forms, with or without&n; *  modification, are permitted provided that the following conditions&n; *  are met:&n; *&n; *  1. Redistributions of source code must retain the above copyright&n; *     notice, this list of conditions and the following disclaimer.&n; *  2. Redistributions in binary form must reproduce the above copyright&n; *     notice, this list of conditions and the following disclaimer in the&n; *     documentation and/or other materials provided with the distribution.&n; *  3. Neither the name of the University nor the names of its&n; *     contributors may be used to endorse or promote products derived&n; *     from this software without specific prior written permission.&n; *&n; *  THIS SOFTWARE IS PROVIDED ``AS IS&squot;&squot; AND ANY EXPRESS OR IMPLIED&n; *  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF&n; *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE&n; *  DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE&n; *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR&n; *  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF&n; *  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR&n; *  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF&n; *  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING&n; *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS&n; *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.&n; *&n; * Implementation of the NFSv4 &quot;renew daemon&quot;, which wakes up periodically to&n; * send a RENEW, to keep state alive on the server.  The daemon is implemented&n; * as an rpc_task, not a real kernel thread, so it always runs in rpciod&squot;s&n; * context.  There is one renewd per nfs_server.&n; *&n; * TODO: If the send queue gets backlogged (e.g., if the server goes down),&n; * we will keep filling the queue with periodic RENEW requests.  We need a&n; * mechanism for ensuring that if renewd successfully sends off a request,&n; * then it only wakes up when the request is finished.  Maybe use the&n; * child task framework of the RPC layer?&n; */
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/pagemap.h&gt;
macro_line|#include &lt;linux/sunrpc/sched.h&gt;
macro_line|#include &lt;linux/sunrpc/clnt.h&gt;
macro_line|#include &lt;linux/nfs.h&gt;
macro_line|#include &lt;linux/nfs4.h&gt;
macro_line|#include &lt;linux/nfs_fs.h&gt;
DECL|macro|NFSDBG_FACILITY
mdefine_line|#define NFSDBG_FACILITY&t;NFSDBG_PROC
r_void
DECL|function|nfs4_renew_state
id|nfs4_renew_state
c_func
(paren
r_void
op_star
id|data
)paren
(brace
r_struct
id|nfs4_client
op_star
id|clp
op_assign
(paren
r_struct
id|nfs4_client
op_star
)paren
id|data
suffix:semicolon
r_int
id|lease
comma
id|timeout
suffix:semicolon
r_int
r_int
id|last
comma
id|now
suffix:semicolon
id|down_read
c_func
(paren
op_amp
id|clp-&gt;cl_sem
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;%s: start&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
multiline_comment|/* Are there any active superblocks? */
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|clp-&gt;cl_superblocks
)paren
)paren
r_goto
id|out
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|clp-&gt;cl_lock
)paren
suffix:semicolon
id|lease
op_assign
id|clp-&gt;cl_lease_time
suffix:semicolon
id|last
op_assign
id|clp-&gt;cl_last_renewal
suffix:semicolon
id|now
op_assign
id|jiffies
suffix:semicolon
id|timeout
op_assign
(paren
l_int|2
op_star
id|lease
)paren
op_div
l_int|3
op_plus
(paren
r_int
)paren
id|last
op_minus
(paren
r_int
)paren
id|now
suffix:semicolon
multiline_comment|/* Are we close to a lease timeout? */
r_if
c_cond
(paren
id|time_after
c_func
(paren
id|now
comma
id|last
op_plus
id|lease
op_div
l_int|3
)paren
)paren
(brace
id|spin_unlock
c_func
(paren
op_amp
id|clp-&gt;cl_lock
)paren
suffix:semicolon
multiline_comment|/* Queue an asynchronous RENEW. */
id|nfs4_proc_async_renew
c_func
(paren
id|clp
)paren
suffix:semicolon
id|timeout
op_assign
(paren
l_int|2
op_star
id|lease
)paren
op_div
l_int|3
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|clp-&gt;cl_lock
)paren
suffix:semicolon
)brace
r_else
id|dprintk
c_func
(paren
l_string|&quot;%s: failed to call renewd. Reason: lease not expired &bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
r_if
c_cond
(paren
id|timeout
OL
l_int|5
op_star
id|HZ
)paren
multiline_comment|/* safeguard */
id|timeout
op_assign
l_int|5
op_star
id|HZ
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;%s: requeueing work. Lease period = %ld&bslash;n&quot;
comma
id|__FUNCTION__
comma
(paren
id|timeout
op_plus
id|HZ
op_minus
l_int|1
)paren
op_div
id|HZ
)paren
suffix:semicolon
id|cancel_delayed_work
c_func
(paren
op_amp
id|clp-&gt;cl_renewd
)paren
suffix:semicolon
id|schedule_delayed_work
c_func
(paren
op_amp
id|clp-&gt;cl_renewd
comma
id|timeout
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|clp-&gt;cl_lock
)paren
suffix:semicolon
id|out
suffix:colon
id|up_read
c_func
(paren
op_amp
id|clp-&gt;cl_sem
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;%s: done&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
)brace
multiline_comment|/* Must be called with clp-&gt;cl_sem locked for writes */
r_void
DECL|function|nfs4_schedule_state_renewal
id|nfs4_schedule_state_renewal
c_func
(paren
r_struct
id|nfs4_client
op_star
id|clp
)paren
(brace
r_int
id|timeout
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|clp-&gt;cl_lock
)paren
suffix:semicolon
id|timeout
op_assign
(paren
l_int|2
op_star
id|clp-&gt;cl_lease_time
)paren
op_div
l_int|3
op_plus
(paren
r_int
)paren
id|clp-&gt;cl_last_renewal
op_minus
(paren
r_int
)paren
id|jiffies
suffix:semicolon
r_if
c_cond
(paren
id|timeout
OL
l_int|5
op_star
id|HZ
)paren
id|timeout
op_assign
l_int|5
op_star
id|HZ
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;%s: requeueing work. Lease period = %ld&bslash;n&quot;
comma
id|__FUNCTION__
comma
(paren
id|timeout
op_plus
id|HZ
op_minus
l_int|1
)paren
op_div
id|HZ
)paren
suffix:semicolon
id|cancel_delayed_work
c_func
(paren
op_amp
id|clp-&gt;cl_renewd
)paren
suffix:semicolon
id|schedule_delayed_work
c_func
(paren
op_amp
id|clp-&gt;cl_renewd
comma
id|timeout
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|clp-&gt;cl_lock
)paren
suffix:semicolon
)brace
r_void
DECL|function|nfs4_renewd_prepare_shutdown
id|nfs4_renewd_prepare_shutdown
c_func
(paren
r_struct
id|nfs_server
op_star
id|server
)paren
(brace
r_struct
id|nfs4_client
op_star
id|clp
op_assign
id|server-&gt;nfs4_state
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|clp
)paren
r_return
suffix:semicolon
id|flush_scheduled_work
c_func
(paren
)paren
suffix:semicolon
id|down_write
c_func
(paren
op_amp
id|clp-&gt;cl_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|server-&gt;nfs4_siblings
)paren
)paren
id|list_del_init
c_func
(paren
op_amp
id|server-&gt;nfs4_siblings
)paren
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|clp-&gt;cl_sem
)paren
suffix:semicolon
)brace
multiline_comment|/* Must be called with clp-&gt;cl_sem locked for writes */
r_void
DECL|function|nfs4_kill_renewd
id|nfs4_kill_renewd
c_func
(paren
r_struct
id|nfs4_client
op_star
id|clp
)paren
(brace
id|down_read
c_func
(paren
op_amp
id|clp-&gt;cl_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|clp-&gt;cl_superblocks
)paren
)paren
(brace
id|up_read
c_func
(paren
op_amp
id|clp-&gt;cl_sem
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|cancel_delayed_work
c_func
(paren
op_amp
id|clp-&gt;cl_renewd
)paren
suffix:semicolon
id|up_read
c_func
(paren
op_amp
id|clp-&gt;cl_sem
)paren
suffix:semicolon
id|flush_scheduled_work
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Local variables:&n; *   c-basic-offset: 8&n; * End:&n; */
eof
