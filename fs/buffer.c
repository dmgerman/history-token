multiline_comment|/*&n; *  linux/fs/buffer.c&n; *&n; *  Copyright (C) 1991, 1992, 2002  Linus Torvalds&n; */
multiline_comment|/*&n; * Start bdflush() with kernel_thread not syscall - Paul Gortmaker, 12/95&n; *&n; * Removed a lot of unnecessary code and simplified things now that&n; * the buffer cache isn&squot;t our primary cache - Andrew Tridgell 12/96&n; *&n; * Speed up hash, lru, and free list operations.  Use gfp() for allocating&n; * hash table, use SLAB cache for buffer heads. SMP threading.  -DaveM&n; *&n; * Added 32k buffer block sizes - these are required older ARM systems. - RMK&n; *&n; * async buffer flushing, 1999 Andrea Arcangeli &lt;andrea@suse.de&gt;&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/percpu.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/blkdev.h&gt;
macro_line|#include &lt;linux/file.h&gt;
macro_line|#include &lt;linux/quotaops.h&gt;
macro_line|#include &lt;linux/highmem.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/writeback.h&gt;
macro_line|#include &lt;linux/hash.h&gt;
macro_line|#include &lt;linux/suspend.h&gt;
macro_line|#include &lt;linux/buffer_head.h&gt;
macro_line|#include &lt;linux/bio.h&gt;
macro_line|#include &lt;linux/notifier.h&gt;
macro_line|#include &lt;linux/cpu.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
r_static
r_void
id|invalidate_bh_lrus
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|macro|BH_ENTRY
mdefine_line|#define BH_ENTRY(list) list_entry((list), struct buffer_head, b_assoc_buffers)
DECL|struct|bh_wait_queue
r_struct
id|bh_wait_queue
(brace
DECL|member|bh
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
DECL|member|wait
id|wait_queue_t
id|wait
suffix:semicolon
)brace
suffix:semicolon
DECL|macro|__DEFINE_BH_WAIT
mdefine_line|#define __DEFINE_BH_WAIT(name, b, f)&t;&t;&t;&t;&t;&bslash;&n;&t;struct bh_wait_queue name = {&t;&t;&t;&t;&t;&bslash;&n;&t;&t;.bh&t;= b,&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;.wait&t;= {&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;.task&t;= current,&t;&t;&t;&bslash;&n;&t;&t;&t;&t;.flags&t;= f,&t;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;.func&t;= bh_wake_function,&t;&t;&bslash;&n;&t;&t;&t;&t;.task_list =&t;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;&t;LIST_HEAD_INIT(name.wait.task_list),&bslash;&n;&t;&t;&t;},&t;&t;&t;&t;&t;&t;&bslash;&n;&t;}
DECL|macro|DEFINE_BH_WAIT
mdefine_line|#define DEFINE_BH_WAIT(name, bh)&t;__DEFINE_BH_WAIT(name, bh, 0)
DECL|macro|DEFINE_BH_WAIT_EXCLUSIVE
mdefine_line|#define DEFINE_BH_WAIT_EXCLUSIVE(name, bh) &bslash;&n;&t;&t;__DEFINE_BH_WAIT(name, bh, WQ_FLAG_EXCLUSIVE)
multiline_comment|/*&n; * Hashed waitqueue_head&squot;s for wait_on_buffer()&n; */
DECL|macro|BH_WAIT_TABLE_ORDER
mdefine_line|#define BH_WAIT_TABLE_ORDER&t;7
DECL|struct|bh_wait_queue_head
r_static
r_struct
id|bh_wait_queue_head
(brace
DECL|member|wqh
id|wait_queue_head_t
id|wqh
suffix:semicolon
DECL|variable|bh_wait_queue_heads
)brace
id|____cacheline_aligned_in_smp
id|bh_wait_queue_heads
(braket
l_int|1
op_lshift
id|BH_WAIT_TABLE_ORDER
)braket
suffix:semicolon
r_inline
r_void
DECL|function|init_buffer
id|init_buffer
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
comma
id|bh_end_io_t
op_star
id|handler
comma
r_void
op_star
r_private
)paren
(brace
id|bh-&gt;b_end_io
op_assign
id|handler
suffix:semicolon
id|bh-&gt;b_private
op_assign
r_private
suffix:semicolon
)brace
multiline_comment|/*&n; * Return the address of the waitqueue_head to be used for this&n; * buffer_head&n; */
DECL|function|bh_waitq_head
id|wait_queue_head_t
op_star
id|bh_waitq_head
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
r_return
op_amp
id|bh_wait_queue_heads
(braket
id|hash_ptr
c_func
(paren
id|bh
comma
id|BH_WAIT_TABLE_ORDER
)paren
)braket
dot
id|wqh
suffix:semicolon
)brace
DECL|variable|bh_waitq_head
id|EXPORT_SYMBOL
c_func
(paren
id|bh_waitq_head
)paren
suffix:semicolon
DECL|function|wake_up_buffer
r_void
id|wake_up_buffer
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
id|wait_queue_head_t
op_star
id|wq
op_assign
id|bh_waitq_head
c_func
(paren
id|bh
)paren
suffix:semicolon
id|smp_mb
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|waitqueue_active
c_func
(paren
id|wq
)paren
)paren
id|__wake_up
c_func
(paren
id|wq
comma
id|TASK_INTERRUPTIBLE
op_or
id|TASK_UNINTERRUPTIBLE
comma
l_int|1
comma
id|bh
)paren
suffix:semicolon
)brace
DECL|variable|wake_up_buffer
id|EXPORT_SYMBOL
c_func
(paren
id|wake_up_buffer
)paren
suffix:semicolon
DECL|function|bh_wake_function
r_static
r_int
id|bh_wake_function
c_func
(paren
id|wait_queue_t
op_star
id|wait
comma
r_int
id|mode
comma
r_int
id|sync
comma
r_void
op_star
id|key
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
op_assign
id|key
suffix:semicolon
r_struct
id|bh_wait_queue
op_star
id|wq
suffix:semicolon
id|wq
op_assign
id|container_of
c_func
(paren
id|wait
comma
r_struct
id|bh_wait_queue
comma
id|wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|wq-&gt;bh
op_ne
id|bh
op_logical_or
id|buffer_locked
c_func
(paren
id|bh
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_else
r_return
id|autoremove_wake_function
c_func
(paren
id|wait
comma
id|mode
comma
id|sync
comma
id|key
)paren
suffix:semicolon
)brace
DECL|function|sync_buffer
r_static
r_void
id|sync_buffer
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
r_struct
id|block_device
op_star
id|bd
suffix:semicolon
id|smp_mb
c_func
(paren
)paren
suffix:semicolon
id|bd
op_assign
id|bh-&gt;b_bdev
suffix:semicolon
r_if
c_cond
(paren
id|bd
)paren
id|blk_run_address_space
c_func
(paren
id|bd-&gt;bd_inode-&gt;i_mapping
)paren
suffix:semicolon
)brace
DECL|function|__lock_buffer
r_void
id|fastcall
id|__lock_buffer
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
id|wait_queue_head_t
op_star
id|wqh
op_assign
id|bh_waitq_head
c_func
(paren
id|bh
)paren
suffix:semicolon
id|DEFINE_BH_WAIT_EXCLUSIVE
c_func
(paren
id|wait
comma
id|bh
)paren
suffix:semicolon
r_do
(brace
id|prepare_to_wait_exclusive
c_func
(paren
id|wqh
comma
op_amp
id|wait.wait
comma
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buffer_locked
c_func
(paren
id|bh
)paren
)paren
(brace
id|sync_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
id|io_schedule
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|test_set_buffer_locked
c_func
(paren
id|bh
)paren
)paren
suffix:semicolon
id|finish_wait
c_func
(paren
id|wqh
comma
op_amp
id|wait.wait
)paren
suffix:semicolon
)brace
DECL|variable|__lock_buffer
id|EXPORT_SYMBOL
c_func
(paren
id|__lock_buffer
)paren
suffix:semicolon
DECL|function|unlock_buffer
r_void
id|fastcall
id|unlock_buffer
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
id|clear_buffer_locked
c_func
(paren
id|bh
)paren
suffix:semicolon
id|smp_mb__after_clear_bit
c_func
(paren
)paren
suffix:semicolon
id|wake_up_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Block until a buffer comes unlocked.  This doesn&squot;t stop it&n; * from becoming locked again - you have to lock it yourself&n; * if you want to preserve its state.&n; */
DECL|function|__wait_on_buffer
r_void
id|__wait_on_buffer
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
id|wait_queue_head_t
op_star
id|wqh
op_assign
id|bh_waitq_head
c_func
(paren
id|bh
)paren
suffix:semicolon
id|DEFINE_BH_WAIT
c_func
(paren
id|wait
comma
id|bh
)paren
suffix:semicolon
r_do
(brace
id|prepare_to_wait
c_func
(paren
id|wqh
comma
op_amp
id|wait.wait
comma
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buffer_locked
c_func
(paren
id|bh
)paren
)paren
(brace
id|sync_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
id|io_schedule
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|buffer_locked
c_func
(paren
id|bh
)paren
)paren
suffix:semicolon
id|finish_wait
c_func
(paren
id|wqh
comma
op_amp
id|wait.wait
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|__set_page_buffers
id|__set_page_buffers
c_func
(paren
r_struct
id|page
op_star
id|page
comma
r_struct
id|buffer_head
op_star
id|head
)paren
(brace
id|page_cache_get
c_func
(paren
id|page
)paren
suffix:semicolon
id|SetPagePrivate
c_func
(paren
id|page
)paren
suffix:semicolon
id|page
op_member_access_from_pointer
r_private
op_assign
(paren
r_int
r_int
)paren
id|head
suffix:semicolon
)brace
r_static
r_void
DECL|function|__clear_page_buffers
id|__clear_page_buffers
c_func
(paren
r_struct
id|page
op_star
id|page
)paren
(brace
id|ClearPagePrivate
c_func
(paren
id|page
)paren
suffix:semicolon
id|page
op_member_access_from_pointer
r_private
op_assign
l_int|0
suffix:semicolon
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
DECL|function|buffer_io_error
r_static
r_void
id|buffer_io_error
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
r_char
id|b
(braket
id|BDEVNAME_SIZE
)braket
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Buffer I/O error on device %s, logical block %Lu&bslash;n&quot;
comma
id|bdevname
c_func
(paren
id|bh-&gt;b_bdev
comma
id|b
)paren
comma
(paren
r_int
r_int
r_int
)paren
id|bh-&gt;b_blocknr
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Default synchronous end-of-IO handler..  Just mark it up-to-date and&n; * unlock the buffer. This is what ll_rw_block uses too.&n; */
DECL|function|end_buffer_read_sync
r_void
id|end_buffer_read_sync
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
comma
r_int
id|uptodate
)paren
(brace
r_if
c_cond
(paren
id|uptodate
)paren
(brace
id|set_buffer_uptodate
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* This happens, due to failed READA attempts. */
id|clear_buffer_uptodate
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
id|unlock_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
id|put_bh
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
DECL|function|end_buffer_write_sync
r_void
id|end_buffer_write_sync
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
comma
r_int
id|uptodate
)paren
(brace
r_char
id|b
(braket
id|BDEVNAME_SIZE
)braket
suffix:semicolon
r_if
c_cond
(paren
id|uptodate
)paren
(brace
id|set_buffer_uptodate
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|printk_ratelimit
c_func
(paren
)paren
)paren
(brace
id|buffer_io_error
c_func
(paren
id|bh
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;lost page write due to &quot;
l_string|&quot;I/O error on %s&bslash;n&quot;
comma
id|bdevname
c_func
(paren
id|bh-&gt;b_bdev
comma
id|b
)paren
)paren
suffix:semicolon
)brace
id|set_buffer_write_io_error
c_func
(paren
id|bh
)paren
suffix:semicolon
id|clear_buffer_uptodate
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
id|unlock_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
id|put_bh
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Write out and wait upon all the dirty data associated with a block&n; * device via its mapping.  Does not take the superblock lock.&n; */
DECL|function|sync_blockdev
r_int
id|sync_blockdev
c_func
(paren
r_struct
id|block_device
op_star
id|bdev
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|bdev
)paren
(brace
r_int
id|err
suffix:semicolon
id|ret
op_assign
id|filemap_fdatawrite
c_func
(paren
id|bdev-&gt;bd_inode-&gt;i_mapping
)paren
suffix:semicolon
id|err
op_assign
id|filemap_fdatawait
c_func
(paren
id|bdev-&gt;bd_inode-&gt;i_mapping
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
id|ret
op_assign
id|err
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|variable|sync_blockdev
id|EXPORT_SYMBOL
c_func
(paren
id|sync_blockdev
)paren
suffix:semicolon
multiline_comment|/*&n; * Write out and wait upon all dirty data associated with this&n; * superblock.  Filesystem data as well as the underlying block&n; * device.  Takes the superblock lock.&n; */
DECL|function|fsync_super
r_int
id|fsync_super
c_func
(paren
r_struct
id|super_block
op_star
id|sb
)paren
(brace
id|sync_inodes_sb
c_func
(paren
id|sb
comma
l_int|0
)paren
suffix:semicolon
id|DQUOT_SYNC
c_func
(paren
id|sb
)paren
suffix:semicolon
id|lock_super
c_func
(paren
id|sb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sb-&gt;s_dirt
op_logical_and
id|sb-&gt;s_op-&gt;write_super
)paren
id|sb-&gt;s_op
op_member_access_from_pointer
id|write_super
c_func
(paren
id|sb
)paren
suffix:semicolon
id|unlock_super
c_func
(paren
id|sb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sb-&gt;s_op-&gt;sync_fs
)paren
id|sb-&gt;s_op
op_member_access_from_pointer
id|sync_fs
c_func
(paren
id|sb
comma
l_int|1
)paren
suffix:semicolon
id|sync_blockdev
c_func
(paren
id|sb-&gt;s_bdev
)paren
suffix:semicolon
id|sync_inodes_sb
c_func
(paren
id|sb
comma
l_int|1
)paren
suffix:semicolon
r_return
id|sync_blockdev
c_func
(paren
id|sb-&gt;s_bdev
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Write out and wait upon all dirty data associated with this&n; * device.   Filesystem data as well as the underlying block&n; * device.  Takes the superblock lock.&n; */
DECL|function|fsync_bdev
r_int
id|fsync_bdev
c_func
(paren
r_struct
id|block_device
op_star
id|bdev
)paren
(brace
r_struct
id|super_block
op_star
id|sb
op_assign
id|get_super
c_func
(paren
id|bdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sb
)paren
(brace
r_int
id|res
op_assign
id|fsync_super
c_func
(paren
id|sb
)paren
suffix:semicolon
id|drop_super
c_func
(paren
id|sb
)paren
suffix:semicolon
r_return
id|res
suffix:semicolon
)brace
r_return
id|sync_blockdev
c_func
(paren
id|bdev
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * freeze_bdev  --  lock a filesystem and force it into a consistent state&n; * @bdev:&t;blockdevice to lock&n; *&n; * This takes the block device bd_mount_sem to make sure no new mounts&n; * happen on bdev until thaw_bdev() is called.&n; * If a superblock is found on this device, we take the s_umount semaphore&n; * on it to make sure nobody unmounts until the snapshot creation is done.&n; */
DECL|function|freeze_bdev
r_struct
id|super_block
op_star
id|freeze_bdev
c_func
(paren
r_struct
id|block_device
op_star
id|bdev
)paren
(brace
r_struct
id|super_block
op_star
id|sb
suffix:semicolon
id|down
c_func
(paren
op_amp
id|bdev-&gt;bd_mount_sem
)paren
suffix:semicolon
id|sb
op_assign
id|get_super
c_func
(paren
id|bdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sb
op_logical_and
op_logical_neg
(paren
id|sb-&gt;s_flags
op_amp
id|MS_RDONLY
)paren
)paren
(brace
id|sb-&gt;s_frozen
op_assign
id|SB_FREEZE_WRITE
suffix:semicolon
id|wmb
c_func
(paren
)paren
suffix:semicolon
id|sync_inodes_sb
c_func
(paren
id|sb
comma
l_int|0
)paren
suffix:semicolon
id|DQUOT_SYNC
c_func
(paren
id|sb
)paren
suffix:semicolon
id|lock_super
c_func
(paren
id|sb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sb-&gt;s_dirt
op_logical_and
id|sb-&gt;s_op-&gt;write_super
)paren
id|sb-&gt;s_op
op_member_access_from_pointer
id|write_super
c_func
(paren
id|sb
)paren
suffix:semicolon
id|unlock_super
c_func
(paren
id|sb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sb-&gt;s_op-&gt;sync_fs
)paren
id|sb-&gt;s_op
op_member_access_from_pointer
id|sync_fs
c_func
(paren
id|sb
comma
l_int|1
)paren
suffix:semicolon
id|sync_blockdev
c_func
(paren
id|sb-&gt;s_bdev
)paren
suffix:semicolon
id|sync_inodes_sb
c_func
(paren
id|sb
comma
l_int|1
)paren
suffix:semicolon
id|sb-&gt;s_frozen
op_assign
id|SB_FREEZE_TRANS
suffix:semicolon
id|wmb
c_func
(paren
)paren
suffix:semicolon
id|sync_blockdev
c_func
(paren
id|sb-&gt;s_bdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sb-&gt;s_op-&gt;write_super_lockfs
)paren
id|sb-&gt;s_op
op_member_access_from_pointer
id|write_super_lockfs
c_func
(paren
id|sb
)paren
suffix:semicolon
)brace
id|sync_blockdev
c_func
(paren
id|bdev
)paren
suffix:semicolon
r_return
id|sb
suffix:semicolon
multiline_comment|/* thaw_bdev releases s-&gt;s_umount and bd_mount_sem */
)brace
DECL|variable|freeze_bdev
id|EXPORT_SYMBOL
c_func
(paren
id|freeze_bdev
)paren
suffix:semicolon
multiline_comment|/**&n; * thaw_bdev  -- unlock filesystem&n; * @bdev:&t;blockdevice to unlock&n; * @sb:&t;&t;associated superblock&n; *&n; * Unlocks the filesystem and marks it writeable again after freeze_bdev().&n; */
DECL|function|thaw_bdev
r_void
id|thaw_bdev
c_func
(paren
r_struct
id|block_device
op_star
id|bdev
comma
r_struct
id|super_block
op_star
id|sb
)paren
(brace
r_if
c_cond
(paren
id|sb
)paren
(brace
id|BUG_ON
c_func
(paren
id|sb-&gt;s_bdev
op_ne
id|bdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sb-&gt;s_op-&gt;unlockfs
)paren
id|sb-&gt;s_op
op_member_access_from_pointer
id|unlockfs
c_func
(paren
id|sb
)paren
suffix:semicolon
id|sb-&gt;s_frozen
op_assign
id|SB_UNFROZEN
suffix:semicolon
id|wmb
c_func
(paren
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|sb-&gt;s_wait_unfrozen
)paren
suffix:semicolon
id|drop_super
c_func
(paren
id|sb
)paren
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|bdev-&gt;bd_mount_sem
)paren
suffix:semicolon
)brace
DECL|variable|thaw_bdev
id|EXPORT_SYMBOL
c_func
(paren
id|thaw_bdev
)paren
suffix:semicolon
multiline_comment|/*&n; * sync everything.  Start out by waking pdflush, because that writes back&n; * all queues in parallel.&n; */
DECL|function|do_sync
r_static
r_void
id|do_sync
c_func
(paren
r_int
r_int
id|wait
)paren
(brace
id|wakeup_bdflush
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|sync_inodes
c_func
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* All mappings, inodes and their blockdevs */
id|DQUOT_SYNC
c_func
(paren
l_int|NULL
)paren
suffix:semicolon
id|sync_supers
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Write the superblocks */
id|sync_filesystems
c_func
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Start syncing the filesystems */
id|sync_filesystems
c_func
(paren
id|wait
)paren
suffix:semicolon
multiline_comment|/* Waitingly sync the filesystems */
id|sync_inodes
c_func
(paren
id|wait
)paren
suffix:semicolon
multiline_comment|/* Mappings, inodes and blockdevs, again. */
r_if
c_cond
(paren
op_logical_neg
id|wait
)paren
id|printk
c_func
(paren
l_string|&quot;Emergency Sync complete&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|laptop_mode
)paren
)paren
id|laptop_sync_completion
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|sys_sync
id|asmlinkage
r_int
id|sys_sync
c_func
(paren
r_void
)paren
(brace
id|do_sync
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|emergency_sync
r_void
id|emergency_sync
c_func
(paren
r_void
)paren
(brace
id|pdflush_operation
c_func
(paren
id|do_sync
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Generic function to fsync a file.&n; *&n; * filp may be NULL if called via the msync of a vma.&n; */
DECL|function|file_fsync
r_int
id|file_fsync
c_func
(paren
r_struct
id|file
op_star
id|filp
comma
r_struct
id|dentry
op_star
id|dentry
comma
r_int
id|datasync
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|dentry-&gt;d_inode
suffix:semicolon
r_struct
id|super_block
op_star
id|sb
suffix:semicolon
r_int
id|ret
suffix:semicolon
multiline_comment|/* sync the inode to buffers */
id|write_inode_now
c_func
(paren
id|inode
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* sync the superblock to buffers */
id|sb
op_assign
id|inode-&gt;i_sb
suffix:semicolon
id|lock_super
c_func
(paren
id|sb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sb-&gt;s_op-&gt;write_super
)paren
id|sb-&gt;s_op
op_member_access_from_pointer
id|write_super
c_func
(paren
id|sb
)paren
suffix:semicolon
id|unlock_super
c_func
(paren
id|sb
)paren
suffix:semicolon
multiline_comment|/* .. finally sync the buffers to disk */
id|ret
op_assign
id|sync_blockdev
c_func
(paren
id|sb-&gt;s_bdev
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|sys_fsync
id|asmlinkage
r_int
id|sys_fsync
c_func
(paren
r_int
r_int
id|fd
)paren
(brace
r_struct
id|file
op_star
id|file
suffix:semicolon
r_struct
id|address_space
op_star
id|mapping
suffix:semicolon
r_int
id|ret
comma
id|err
suffix:semicolon
id|ret
op_assign
op_minus
id|EBADF
suffix:semicolon
id|file
op_assign
id|fget
c_func
(paren
id|fd
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|file
)paren
r_goto
id|out
suffix:semicolon
id|mapping
op_assign
id|file-&gt;f_mapping
suffix:semicolon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|file-&gt;f_op
op_logical_or
op_logical_neg
id|file-&gt;f_op-&gt;fsync
)paren
(brace
multiline_comment|/* Why?  We can still call filemap_fdatawrite */
r_goto
id|out_putf
suffix:semicolon
)brace
multiline_comment|/* We need to protect against concurrent writers.. */
id|down
c_func
(paren
op_amp
id|mapping-&gt;host-&gt;i_sem
)paren
suffix:semicolon
id|current-&gt;flags
op_or_assign
id|PF_SYNCWRITE
suffix:semicolon
id|ret
op_assign
id|filemap_fdatawrite
c_func
(paren
id|mapping
)paren
suffix:semicolon
id|err
op_assign
id|file-&gt;f_op
op_member_access_from_pointer
id|fsync
c_func
(paren
id|file
comma
id|file-&gt;f_dentry
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
id|ret
op_assign
id|err
suffix:semicolon
id|err
op_assign
id|filemap_fdatawait
c_func
(paren
id|mapping
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
id|ret
op_assign
id|err
suffix:semicolon
id|current-&gt;flags
op_and_assign
op_complement
id|PF_SYNCWRITE
suffix:semicolon
id|up
c_func
(paren
op_amp
id|mapping-&gt;host-&gt;i_sem
)paren
suffix:semicolon
id|out_putf
suffix:colon
id|fput
c_func
(paren
id|file
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|sys_fdatasync
id|asmlinkage
r_int
id|sys_fdatasync
c_func
(paren
r_int
r_int
id|fd
)paren
(brace
r_struct
id|file
op_star
id|file
suffix:semicolon
r_struct
id|address_space
op_star
id|mapping
suffix:semicolon
r_int
id|ret
comma
id|err
suffix:semicolon
id|ret
op_assign
op_minus
id|EBADF
suffix:semicolon
id|file
op_assign
id|fget
c_func
(paren
id|fd
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|file
)paren
r_goto
id|out
suffix:semicolon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|file-&gt;f_op
op_logical_or
op_logical_neg
id|file-&gt;f_op-&gt;fsync
)paren
r_goto
id|out_putf
suffix:semicolon
id|mapping
op_assign
id|file-&gt;f_mapping
suffix:semicolon
id|down
c_func
(paren
op_amp
id|mapping-&gt;host-&gt;i_sem
)paren
suffix:semicolon
id|current-&gt;flags
op_or_assign
id|PF_SYNCWRITE
suffix:semicolon
id|ret
op_assign
id|filemap_fdatawrite
c_func
(paren
id|mapping
)paren
suffix:semicolon
id|err
op_assign
id|file-&gt;f_op
op_member_access_from_pointer
id|fsync
c_func
(paren
id|file
comma
id|file-&gt;f_dentry
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
id|ret
op_assign
id|err
suffix:semicolon
id|err
op_assign
id|filemap_fdatawait
c_func
(paren
id|mapping
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
id|ret
op_assign
id|err
suffix:semicolon
id|current-&gt;flags
op_and_assign
op_complement
id|PF_SYNCWRITE
suffix:semicolon
id|up
c_func
(paren
op_amp
id|mapping-&gt;host-&gt;i_sem
)paren
suffix:semicolon
id|out_putf
suffix:colon
id|fput
c_func
(paren
id|file
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Various filesystems appear to want __find_get_block to be non-blocking.&n; * But it&squot;s the page lock which protects the buffers.  To get around this,&n; * we get exclusion from try_to_free_buffers with the blockdev mapping&squot;s&n; * private_lock.&n; *&n; * Hack idea: for the blockdev mapping, i_bufferlist_lock contention&n; * may be quite high.  This code could TryLock the page, and if that&n; * succeeds, there is no need to take private_lock. (But if&n; * private_lock is contended then so is mapping-&gt;tree_lock).&n; */
r_static
r_struct
id|buffer_head
op_star
DECL|function|__find_get_block_slow
id|__find_get_block_slow
c_func
(paren
r_struct
id|block_device
op_star
id|bdev
comma
id|sector_t
id|block
comma
r_int
id|unused
)paren
(brace
r_struct
id|inode
op_star
id|bd_inode
op_assign
id|bdev-&gt;bd_inode
suffix:semicolon
r_struct
id|address_space
op_star
id|bd_mapping
op_assign
id|bd_inode-&gt;i_mapping
suffix:semicolon
r_struct
id|buffer_head
op_star
id|ret
op_assign
l_int|NULL
suffix:semicolon
id|pgoff_t
id|index
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
r_struct
id|buffer_head
op_star
id|head
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
id|index
op_assign
id|block
op_rshift
(paren
id|PAGE_CACHE_SHIFT
op_minus
id|bd_inode-&gt;i_blkbits
)paren
suffix:semicolon
id|page
op_assign
id|find_get_page
c_func
(paren
id|bd_mapping
comma
id|index
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page
)paren
r_goto
id|out
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|bd_mapping-&gt;private_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page_has_buffers
c_func
(paren
id|page
)paren
)paren
r_goto
id|out_unlock
suffix:semicolon
id|head
op_assign
id|page_buffers
c_func
(paren
id|page
)paren
suffix:semicolon
id|bh
op_assign
id|head
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|bh-&gt;b_blocknr
op_eq
id|block
)paren
(brace
id|ret
op_assign
id|bh
suffix:semicolon
id|get_bh
c_func
(paren
id|bh
)paren
suffix:semicolon
r_goto
id|out_unlock
suffix:semicolon
)brace
id|bh
op_assign
id|bh-&gt;b_this_page
suffix:semicolon
)brace
r_while
c_loop
(paren
id|bh
op_ne
id|head
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;__find_get_block_slow() failed. &quot;
l_string|&quot;block=%llu, b_blocknr=%llu&bslash;n&quot;
comma
(paren
r_int
r_int
r_int
)paren
id|block
comma
(paren
r_int
r_int
r_int
)paren
id|bh-&gt;b_blocknr
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;b_state=0x%08lx, b_size=%u&bslash;n&quot;
comma
id|bh-&gt;b_state
comma
id|bh-&gt;b_size
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;device blocksize: %d&bslash;n&quot;
comma
l_int|1
op_lshift
id|bd_inode-&gt;i_blkbits
)paren
suffix:semicolon
id|out_unlock
suffix:colon
id|spin_unlock
c_func
(paren
op_amp
id|bd_mapping-&gt;private_lock
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* If invalidate_buffers() will trash dirty buffers, it means some kind&n;   of fs corruption is going on. Trashing dirty data always imply losing&n;   information that was supposed to be just stored on the physical layer&n;   by the user.&n;&n;   Thus invalidate_buffers in general usage is not allwowed to trash&n;   dirty buffers. For example ioctl(FLSBLKBUF) expects dirty data to&n;   be preserved.  These buffers are simply skipped.&n;  &n;   We also skip buffers which are still in use.  For example this can&n;   happen if a userspace program is reading the block device.&n;&n;   NOTE: In the case where the user removed a removable-media-disk even if&n;   there&squot;s still dirty data not synced on disk (due a bug in the device driver&n;   or due an error of the user), by not destroying the dirty buffers we could&n;   generate corruption also on the next media inserted, thus a parameter is&n;   necessary to handle this case in the most safe way possible (trying&n;   to not corrupt also the new disk inserted with the data belonging to&n;   the old now corrupted disk). Also for the ramdisk the natural thing&n;   to do in order to release the ramdisk memory is to destroy dirty buffers.&n;&n;   These are two special cases. Normal usage imply the device driver&n;   to issue a sync on the device (without waiting I/O completion) and&n;   then an invalidate_buffers call that doesn&squot;t trash dirty buffers.&n;&n;   For handling cache coherency with the blkdev pagecache the &squot;update&squot; case&n;   is been introduced. It is needed to re-read from disk any pinned&n;   buffer. NOTE: re-reading from disk is destructive so we can do it only&n;   when we assume nobody is changing the buffercache under our I/O and when&n;   we think the disk contains more recent information than the buffercache.&n;   The update == 1 pass marks the buffers we need to update, the update == 2&n;   pass does the actual I/O. */
DECL|function|invalidate_bdev
r_void
id|invalidate_bdev
c_func
(paren
r_struct
id|block_device
op_star
id|bdev
comma
r_int
id|destroy_dirty_buffers
)paren
(brace
id|invalidate_bh_lrus
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * FIXME: what about destroy_dirty_buffers?&n;&t; * We really want to use invalidate_inode_pages2() for&n;&t; * that, but not until that&squot;s cleaned up.&n;&t; */
id|invalidate_inode_pages
c_func
(paren
id|bdev-&gt;bd_inode-&gt;i_mapping
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Kick pdflush then try to free up some ZONE_NORMAL memory.&n; */
DECL|function|free_more_memory
r_static
r_void
id|free_more_memory
c_func
(paren
r_void
)paren
(brace
r_struct
id|zone
op_star
op_star
id|zones
suffix:semicolon
id|pg_data_t
op_star
id|pgdat
suffix:semicolon
id|wakeup_bdflush
c_func
(paren
l_int|1024
)paren
suffix:semicolon
id|yield
c_func
(paren
)paren
suffix:semicolon
id|for_each_pgdat
c_func
(paren
id|pgdat
)paren
(brace
id|zones
op_assign
id|pgdat-&gt;node_zonelists
(braket
id|GFP_NOFS
op_amp
id|GFP_ZONEMASK
)braket
dot
id|zones
suffix:semicolon
r_if
c_cond
(paren
op_star
id|zones
)paren
id|try_to_free_pages
c_func
(paren
id|zones
comma
id|GFP_NOFS
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * I/O completion handler for block_read_full_page() - pages&n; * which come unlocked at the end of I/O.&n; */
DECL|function|end_buffer_async_read
r_static
r_void
id|end_buffer_async_read
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
comma
r_int
id|uptodate
)paren
(brace
r_static
id|spinlock_t
id|page_uptodate_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|buffer_head
op_star
id|tmp
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
r_int
id|page_uptodate
op_assign
l_int|1
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|buffer_async_read
c_func
(paren
id|bh
)paren
)paren
suffix:semicolon
id|page
op_assign
id|bh-&gt;b_page
suffix:semicolon
r_if
c_cond
(paren
id|uptodate
)paren
(brace
id|set_buffer_uptodate
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
r_else
(brace
id|clear_buffer_uptodate
c_func
(paren
id|bh
)paren
suffix:semicolon
id|buffer_io_error
c_func
(paren
id|bh
)paren
suffix:semicolon
id|SetPageError
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Be _very_ careful from here on. Bad things can happen if&n;&t; * two buffer heads end IO at almost the same time and both&n;&t; * decide that the page is now completely done.&n;&t; */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|page_uptodate_lock
comma
id|flags
)paren
suffix:semicolon
id|clear_buffer_async_read
c_func
(paren
id|bh
)paren
suffix:semicolon
id|unlock_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
id|tmp
op_assign
id|bh
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|tmp
)paren
)paren
id|page_uptodate
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|buffer_async_read
c_func
(paren
id|tmp
)paren
)paren
(brace
id|BUG_ON
c_func
(paren
op_logical_neg
id|buffer_locked
c_func
(paren
id|tmp
)paren
)paren
suffix:semicolon
r_goto
id|still_busy
suffix:semicolon
)brace
id|tmp
op_assign
id|tmp-&gt;b_this_page
suffix:semicolon
)brace
r_while
c_loop
(paren
id|tmp
op_ne
id|bh
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|page_uptodate_lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If none of the buffers had errors and they are all&n;&t; * uptodate then we can set the page uptodate.&n;&t; */
r_if
c_cond
(paren
id|page_uptodate
op_logical_and
op_logical_neg
id|PageError
c_func
(paren
id|page
)paren
)paren
id|SetPageUptodate
c_func
(paren
id|page
)paren
suffix:semicolon
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
suffix:semicolon
id|still_busy
suffix:colon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|page_uptodate_lock
comma
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * Completion handler for block_write_full_page() - pages which are unlocked&n; * during I/O, and which have PageWriteback cleared upon I/O completion.&n; */
DECL|function|end_buffer_async_write
r_void
id|end_buffer_async_write
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
comma
r_int
id|uptodate
)paren
(brace
r_char
id|b
(braket
id|BDEVNAME_SIZE
)braket
suffix:semicolon
r_static
id|spinlock_t
id|page_uptodate_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|buffer_head
op_star
id|tmp
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|buffer_async_write
c_func
(paren
id|bh
)paren
)paren
suffix:semicolon
id|page
op_assign
id|bh-&gt;b_page
suffix:semicolon
r_if
c_cond
(paren
id|uptodate
)paren
(brace
id|set_buffer_uptodate
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|printk_ratelimit
c_func
(paren
)paren
)paren
(brace
id|buffer_io_error
c_func
(paren
id|bh
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;lost page write due to &quot;
l_string|&quot;I/O error on %s&bslash;n&quot;
comma
id|bdevname
c_func
(paren
id|bh-&gt;b_bdev
comma
id|b
)paren
)paren
suffix:semicolon
)brace
id|set_bit
c_func
(paren
id|AS_EIO
comma
op_amp
id|page-&gt;mapping-&gt;flags
)paren
suffix:semicolon
id|clear_buffer_uptodate
c_func
(paren
id|bh
)paren
suffix:semicolon
id|SetPageError
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|page_uptodate_lock
comma
id|flags
)paren
suffix:semicolon
id|clear_buffer_async_write
c_func
(paren
id|bh
)paren
suffix:semicolon
id|unlock_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
id|tmp
op_assign
id|bh-&gt;b_this_page
suffix:semicolon
r_while
c_loop
(paren
id|tmp
op_ne
id|bh
)paren
(brace
r_if
c_cond
(paren
id|buffer_async_write
c_func
(paren
id|tmp
)paren
)paren
(brace
id|BUG_ON
c_func
(paren
op_logical_neg
id|buffer_locked
c_func
(paren
id|tmp
)paren
)paren
suffix:semicolon
r_goto
id|still_busy
suffix:semicolon
)brace
id|tmp
op_assign
id|tmp-&gt;b_this_page
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|page_uptodate_lock
comma
id|flags
)paren
suffix:semicolon
id|end_page_writeback
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
suffix:semicolon
id|still_busy
suffix:colon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|page_uptodate_lock
comma
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * If a page&squot;s buffers are under async readin (end_buffer_async_read&n; * completion) then there is a possibility that another thread of&n; * control could lock one of the buffers after it has completed&n; * but while some of the other buffers have not completed.  This&n; * locked buffer would confuse end_buffer_async_read() into not unlocking&n; * the page.  So the absence of BH_Async_Read tells end_buffer_async_read()&n; * that this buffer is not under async I/O.&n; *&n; * The page comes unlocked when it has no locked buffer_async buffers&n; * left.&n; *&n; * PageLocked prevents anyone starting new async I/O reads any of&n; * the buffers.&n; *&n; * PageWriteback is used to prevent simultaneous writeout of the same&n; * page.&n; *&n; * PageLocked prevents anyone from starting writeback of a page which is&n; * under read I/O (PageWriteback is only ever set against a locked page).&n; */
DECL|function|mark_buffer_async_read
r_void
id|mark_buffer_async_read
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
id|bh-&gt;b_end_io
op_assign
id|end_buffer_async_read
suffix:semicolon
id|set_buffer_async_read
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
DECL|variable|mark_buffer_async_read
id|EXPORT_SYMBOL
c_func
(paren
id|mark_buffer_async_read
)paren
suffix:semicolon
DECL|function|mark_buffer_async_write
r_void
id|mark_buffer_async_write
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
id|bh-&gt;b_end_io
op_assign
id|end_buffer_async_write
suffix:semicolon
id|set_buffer_async_write
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
DECL|variable|mark_buffer_async_write
id|EXPORT_SYMBOL
c_func
(paren
id|mark_buffer_async_write
)paren
suffix:semicolon
multiline_comment|/*&n; * fs/buffer.c contains helper functions for buffer-backed address space&squot;s&n; * fsync functions.  A common requirement for buffer-based filesystems is&n; * that certain data from the backing blockdev needs to be written out for&n; * a successful fsync().  For example, ext2 indirect blocks need to be&n; * written back and waited upon before fsync() returns.&n; *&n; * The functions mark_buffer_inode_dirty(), fsync_inode_buffers(),&n; * inode_has_buffers() and invalidate_inode_buffers() are provided for the&n; * management of a list of dependent buffers at -&gt;i_mapping-&gt;private_list.&n; *&n; * Locking is a little subtle: try_to_free_buffers() will remove buffers&n; * from their controlling inode&squot;s queue when they are being freed.  But&n; * try_to_free_buffers() will be operating against the *blockdev* mapping&n; * at the time, not against the S_ISREG file which depends on those buffers.&n; * So the locking for private_list is via the private_lock in the address_space&n; * which backs the buffers.  Which is different from the address_space &n; * against which the buffers are listed.  So for a particular address_space,&n; * mapping-&gt;private_lock does *not* protect mapping-&gt;private_list!  In fact,&n; * mapping-&gt;private_list will always be protected by the backing blockdev&squot;s&n; * -&gt;private_lock.&n; *&n; * Which introduces a requirement: all buffers on an address_space&squot;s&n; * -&gt;private_list must be from the same address_space: the blockdev&squot;s.&n; *&n; * address_spaces which do not place buffers at -&gt;private_list via these&n; * utility functions are free to use private_lock and private_list for&n; * whatever they want.  The only requirement is that list_empty(private_list)&n; * be true at clear_inode() time.&n; *&n; * FIXME: clear_inode should not call invalidate_inode_buffers().  The&n; * filesystems should do that.  invalidate_inode_buffers() should just go&n; * BUG_ON(!list_empty).&n; *&n; * FIXME: mark_buffer_dirty_inode() is a data-plane operation.  It should&n; * take an address_space, not an inode.  And it should be called&n; * mark_buffer_dirty_fsync() to clearly define why those buffers are being&n; * queued up.&n; *&n; * FIXME: mark_buffer_dirty_inode() doesn&squot;t need to add the buffer to the&n; * list if it is already on a list.  Because if the buffer is on a list,&n; * it *must* already be on the right one.  If not, the filesystem is being&n; * silly.  This will save a ton of locking.  But first we have to ensure&n; * that buffers are taken *off* the old inode&squot;s list when they are freed&n; * (presumably in truncate).  That requires careful auditing of all&n; * filesystems (do it inside bforget()).  It could also be done by bringing&n; * b_inode back.&n; */
DECL|function|buffer_insert_list
r_void
id|buffer_insert_list
c_func
(paren
id|spinlock_t
op_star
id|lock
comma
r_struct
id|buffer_head
op_star
id|bh
comma
r_struct
id|list_head
op_star
id|list
)paren
(brace
id|spin_lock
c_func
(paren
id|lock
)paren
suffix:semicolon
id|list_move_tail
c_func
(paren
op_amp
id|bh-&gt;b_assoc_buffers
comma
id|list
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
id|lock
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * The buffer&squot;s backing address_space&squot;s private_lock must be held&n; */
DECL|function|__remove_assoc_queue
r_static
r_inline
r_void
id|__remove_assoc_queue
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
id|list_del_init
c_func
(paren
op_amp
id|bh-&gt;b_assoc_buffers
)paren
suffix:semicolon
)brace
DECL|function|inode_has_buffers
r_int
id|inode_has_buffers
c_func
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
r_return
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|inode-&gt;i_data.private_list
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * osync is designed to support O_SYNC io.  It waits synchronously for&n; * all already-submitted IO to complete, but does not queue any new&n; * writes to the disk.&n; *&n; * To do O_SYNC writes, just queue the buffer writes with ll_rw_block as&n; * you dirty the buffers, and then use osync_inode_buffers to wait for&n; * completion.  Any other dirty buffers which are not yet queued for&n; * write will not be flushed to disk by the osync.&n; */
DECL|function|osync_buffers_list
r_static
r_int
id|osync_buffers_list
c_func
(paren
id|spinlock_t
op_star
id|lock
comma
r_struct
id|list_head
op_star
id|list
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
r_struct
id|list_head
op_star
id|p
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
id|spin_lock
c_func
(paren
id|lock
)paren
suffix:semicolon
id|repeat
suffix:colon
id|list_for_each_prev
c_func
(paren
id|p
comma
id|list
)paren
(brace
id|bh
op_assign
id|BH_ENTRY
c_func
(paren
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buffer_locked
c_func
(paren
id|bh
)paren
)paren
(brace
id|get_bh
c_func
(paren
id|bh
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
id|lock
)paren
suffix:semicolon
id|wait_on_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|bh
)paren
)paren
id|err
op_assign
op_minus
id|EIO
suffix:semicolon
id|brelse
c_func
(paren
id|bh
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
id|lock
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
)brace
id|spin_unlock
c_func
(paren
id|lock
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/**&n; * sync_mapping_buffers - write out and wait upon a mapping&squot;s &quot;associated&quot;&n; *                        buffers&n; * @buffer_mapping - the mapping which backs the buffers&squot; data&n; * @mapping - the mapping which wants those buffers written&n; *&n; * Starts I/O against the buffers at mapping-&gt;private_list, and waits upon&n; * that I/O.&n; *&n; * Basically, this is a convenience function for fsync().  @buffer_mapping is&n; * the blockdev which &quot;owns&quot; the buffers and @mapping is a file or directory&n; * which needs those buffers to be written for a successful fsync().&n; */
DECL|function|sync_mapping_buffers
r_int
id|sync_mapping_buffers
c_func
(paren
r_struct
id|address_space
op_star
id|mapping
)paren
(brace
r_struct
id|address_space
op_star
id|buffer_mapping
op_assign
id|mapping-&gt;assoc_mapping
suffix:semicolon
r_if
c_cond
(paren
id|buffer_mapping
op_eq
l_int|NULL
op_logical_or
id|list_empty
c_func
(paren
op_amp
id|mapping-&gt;private_list
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_return
id|fsync_buffers_list
c_func
(paren
op_amp
id|buffer_mapping-&gt;private_lock
comma
op_amp
id|mapping-&gt;private_list
)paren
suffix:semicolon
)brace
DECL|variable|sync_mapping_buffers
id|EXPORT_SYMBOL
c_func
(paren
id|sync_mapping_buffers
)paren
suffix:semicolon
multiline_comment|/*&n; * Called when we&squot;ve recently written block `bblock&squot;, and it is known that&n; * `bblock&squot; was for a buffer_boundary() buffer.  This means that the block at&n; * `bblock + 1&squot; is probably a dirty indirect block.  Hunt it down and, if it&squot;s&n; * dirty, schedule it for IO.  So that indirects merge nicely with their data.&n; */
DECL|function|write_boundary_block
r_void
id|write_boundary_block
c_func
(paren
r_struct
id|block_device
op_star
id|bdev
comma
id|sector_t
id|bblock
comma
r_int
id|blocksize
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
op_assign
id|__find_get_block
c_func
(paren
id|bdev
comma
id|bblock
op_plus
l_int|1
comma
id|blocksize
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bh
)paren
(brace
r_if
c_cond
(paren
id|buffer_dirty
c_func
(paren
id|bh
)paren
)paren
id|ll_rw_block
c_func
(paren
id|WRITE
comma
l_int|1
comma
op_amp
id|bh
)paren
suffix:semicolon
id|put_bh
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
)brace
DECL|function|mark_buffer_dirty_inode
r_void
id|mark_buffer_dirty_inode
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
comma
r_struct
id|inode
op_star
id|inode
)paren
(brace
r_struct
id|address_space
op_star
id|mapping
op_assign
id|inode-&gt;i_mapping
suffix:semicolon
r_struct
id|address_space
op_star
id|buffer_mapping
op_assign
id|bh-&gt;b_page-&gt;mapping
suffix:semicolon
id|mark_buffer_dirty
c_func
(paren
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mapping-&gt;assoc_mapping
)paren
(brace
id|mapping-&gt;assoc_mapping
op_assign
id|buffer_mapping
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|mapping-&gt;assoc_mapping
op_ne
id|buffer_mapping
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|bh-&gt;b_assoc_buffers
)paren
)paren
id|buffer_insert_list
c_func
(paren
op_amp
id|buffer_mapping-&gt;private_lock
comma
id|bh
comma
op_amp
id|mapping-&gt;private_list
)paren
suffix:semicolon
)brace
DECL|variable|mark_buffer_dirty_inode
id|EXPORT_SYMBOL
c_func
(paren
id|mark_buffer_dirty_inode
)paren
suffix:semicolon
multiline_comment|/*&n; * Add a page to the dirty page list.&n; *&n; * It is a sad fact of life that this function is called from several places&n; * deeply under spinlocking.  It may not sleep.&n; *&n; * If the page has buffers, the uptodate buffers are set dirty, to preserve&n; * dirty-state coherency between the page and the buffers.  It the page does&n; * not have buffers then when they are later attached they will all be set&n; * dirty.&n; *&n; * The buffers are dirtied before the page is dirtied.  There&squot;s a small race&n; * window in which a writepage caller may see the page cleanness but not the&n; * buffer dirtiness.  That&squot;s fine.  If this code were to set the page dirty&n; * before the buffers, a concurrent writepage caller could clear the page dirty&n; * bit, see a bunch of clean buffers and we&squot;d end up with dirty buffers/clean&n; * page on the dirty page list.&n; *&n; * We use private_lock to lock against try_to_free_buffers while using the&n; * page&squot;s buffer list.  Also use this to protect against clean buffers being&n; * added to the page after it was set dirty.&n; *&n; * FIXME: may need to call -&gt;reservepage here as well.  That&squot;s rather up to the&n; * address_space though.&n; */
DECL|function|__set_page_dirty_buffers
r_int
id|__set_page_dirty_buffers
c_func
(paren
r_struct
id|page
op_star
id|page
)paren
(brace
r_struct
id|address_space
op_star
r_const
id|mapping
op_assign
id|page-&gt;mapping
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|mapping-&gt;private_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|page_has_buffers
c_func
(paren
id|page
)paren
)paren
(brace
r_struct
id|buffer_head
op_star
id|head
op_assign
id|page_buffers
c_func
(paren
id|page
)paren
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
op_assign
id|head
suffix:semicolon
r_do
(brace
id|set_buffer_dirty
c_func
(paren
id|bh
)paren
suffix:semicolon
id|bh
op_assign
id|bh-&gt;b_this_page
suffix:semicolon
)brace
r_while
c_loop
(paren
id|bh
op_ne
id|head
)paren
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|mapping-&gt;private_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|TestSetPageDirty
c_func
(paren
id|page
)paren
)paren
(brace
id|spin_lock_irq
c_func
(paren
op_amp
id|mapping-&gt;tree_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|page-&gt;mapping
)paren
(brace
multiline_comment|/* Race with truncate? */
r_if
c_cond
(paren
op_logical_neg
id|mapping-&gt;backing_dev_info-&gt;memory_backed
)paren
id|inc_page_state
c_func
(paren
id|nr_dirty
)paren
suffix:semicolon
id|radix_tree_tag_set
c_func
(paren
op_amp
id|mapping-&gt;page_tree
comma
id|page_index
c_func
(paren
id|page
)paren
comma
id|PAGECACHE_TAG_DIRTY
)paren
suffix:semicolon
)brace
id|spin_unlock_irq
c_func
(paren
op_amp
id|mapping-&gt;tree_lock
)paren
suffix:semicolon
id|__mark_inode_dirty
c_func
(paren
id|mapping-&gt;host
comma
id|I_DIRTY_PAGES
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|__set_page_dirty_buffers
id|EXPORT_SYMBOL
c_func
(paren
id|__set_page_dirty_buffers
)paren
suffix:semicolon
multiline_comment|/*&n; * Write out and wait upon a list of buffers.&n; *&n; * We have conflicting pressures: we want to make sure that all&n; * initially dirty buffers get waited on, but that any subsequently&n; * dirtied buffers don&squot;t.  After all, we don&squot;t want fsync to last&n; * forever if somebody is actively writing to the file.&n; *&n; * Do this in two main stages: first we copy dirty buffers to a&n; * temporary inode list, queueing the writes as we go.  Then we clean&n; * up, waiting for those writes to complete.&n; * &n; * During this second stage, any subsequent updates to the file may end&n; * up refiling the buffer on the original inode&squot;s dirty list again, so&n; * there is a chance we will end up with a buffer queued for write but&n; * not yet completed on that list.  So, as a final cleanup we go through&n; * the osync code to catch these locked, dirty buffers without requeuing&n; * any newly dirty buffers for write.&n; */
DECL|function|fsync_buffers_list
r_int
id|fsync_buffers_list
c_func
(paren
id|spinlock_t
op_star
id|lock
comma
r_struct
id|list_head
op_star
id|list
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
r_struct
id|list_head
id|tmp
suffix:semicolon
r_int
id|err
op_assign
l_int|0
comma
id|err2
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|tmp
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
id|lock
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
id|list
)paren
)paren
(brace
id|bh
op_assign
id|BH_ENTRY
c_func
(paren
id|list-&gt;next
)paren
suffix:semicolon
id|list_del_init
c_func
(paren
op_amp
id|bh-&gt;b_assoc_buffers
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buffer_dirty
c_func
(paren
id|bh
)paren
op_logical_or
id|buffer_locked
c_func
(paren
id|bh
)paren
)paren
(brace
id|list_add
c_func
(paren
op_amp
id|bh-&gt;b_assoc_buffers
comma
op_amp
id|tmp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buffer_dirty
c_func
(paren
id|bh
)paren
)paren
(brace
id|get_bh
c_func
(paren
id|bh
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
id|lock
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * Ensure any pending I/O completes so that&n;&t;&t;&t;&t; * ll_rw_block() actually writes the current&n;&t;&t;&t;&t; * contents - it is a noop if I/O is still in&n;&t;&t;&t;&t; * flight on potentially older contents.&n;&t;&t;&t;&t; */
id|wait_on_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
id|ll_rw_block
c_func
(paren
id|WRITE
comma
l_int|1
comma
op_amp
id|bh
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|bh
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
id|lock
)paren
suffix:semicolon
)brace
)brace
)brace
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|tmp
)paren
)paren
(brace
id|bh
op_assign
id|BH_ENTRY
c_func
(paren
id|tmp.prev
)paren
suffix:semicolon
id|__remove_assoc_queue
c_func
(paren
id|bh
)paren
suffix:semicolon
id|get_bh
c_func
(paren
id|bh
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
id|lock
)paren
suffix:semicolon
id|wait_on_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|bh
)paren
)paren
id|err
op_assign
op_minus
id|EIO
suffix:semicolon
id|brelse
c_func
(paren
id|bh
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
id|lock
)paren
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
id|lock
)paren
suffix:semicolon
id|err2
op_assign
id|osync_buffers_list
c_func
(paren
id|lock
comma
id|list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
r_else
r_return
id|err2
suffix:semicolon
)brace
multiline_comment|/*&n; * Invalidate any and all dirty buffers on a given inode.  We are&n; * probably unmounting the fs, but that doesn&squot;t mean we have already&n; * done a sync().  Just drop the buffers from the inode list.&n; *&n; * NOTE: we take the inode&squot;s blockdev&squot;s mapping&squot;s private_lock.  Which&n; * assumes that all the buffers are against the blockdev.  Not true&n; * for reiserfs.&n; */
DECL|function|invalidate_inode_buffers
r_void
id|invalidate_inode_buffers
c_func
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
r_if
c_cond
(paren
id|inode_has_buffers
c_func
(paren
id|inode
)paren
)paren
(brace
r_struct
id|address_space
op_star
id|mapping
op_assign
op_amp
id|inode-&gt;i_data
suffix:semicolon
r_struct
id|list_head
op_star
id|list
op_assign
op_amp
id|mapping-&gt;private_list
suffix:semicolon
r_struct
id|address_space
op_star
id|buffer_mapping
op_assign
id|mapping-&gt;assoc_mapping
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|buffer_mapping-&gt;private_lock
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
id|list
)paren
)paren
id|__remove_assoc_queue
c_func
(paren
id|BH_ENTRY
c_func
(paren
id|list-&gt;next
)paren
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|buffer_mapping-&gt;private_lock
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Remove any clean buffers from the inode&squot;s buffer list.  This is called&n; * when we&squot;re trying to free the inode itself.  Those buffers can pin it.&n; *&n; * Returns true if all buffers were removed.&n; */
DECL|function|remove_inode_buffers
r_int
id|remove_inode_buffers
c_func
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
r_int
id|ret
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|inode_has_buffers
c_func
(paren
id|inode
)paren
)paren
(brace
r_struct
id|address_space
op_star
id|mapping
op_assign
op_amp
id|inode-&gt;i_data
suffix:semicolon
r_struct
id|list_head
op_star
id|list
op_assign
op_amp
id|mapping-&gt;private_list
suffix:semicolon
r_struct
id|address_space
op_star
id|buffer_mapping
op_assign
id|mapping-&gt;assoc_mapping
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|buffer_mapping-&gt;private_lock
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
id|list
)paren
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
op_assign
id|BH_ENTRY
c_func
(paren
id|list-&gt;next
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buffer_dirty
c_func
(paren
id|bh
)paren
)paren
(brace
id|ret
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
id|__remove_assoc_queue
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|buffer_mapping-&gt;private_lock
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Create the appropriate buffers when given a page for data area and&n; * the size of each buffer.. Use the bh-&gt;b_this_page linked list to&n; * follow the buffers created.  Return NULL if unable to create more&n; * buffers.&n; *&n; * The retry flag is used to differentiate async IO (paging, swapping)&n; * which may not fail from ordinary buffer allocations.&n; */
r_static
r_struct
id|buffer_head
op_star
DECL|function|create_buffers
id|create_buffers
c_func
(paren
r_struct
id|page
op_star
id|page
comma
r_int
r_int
id|size
comma
r_int
id|retry
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
comma
op_star
id|head
suffix:semicolon
r_int
id|offset
suffix:semicolon
id|try_again
suffix:colon
id|head
op_assign
l_int|NULL
suffix:semicolon
id|offset
op_assign
id|PAGE_SIZE
suffix:semicolon
r_while
c_loop
(paren
(paren
id|offset
op_sub_assign
id|size
)paren
op_ge
l_int|0
)paren
(brace
id|bh
op_assign
id|alloc_buffer_head
c_func
(paren
id|GFP_NOFS
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bh
)paren
r_goto
id|no_grow
suffix:semicolon
id|bh-&gt;b_bdev
op_assign
l_int|NULL
suffix:semicolon
id|bh-&gt;b_this_page
op_assign
id|head
suffix:semicolon
id|bh-&gt;b_blocknr
op_assign
op_minus
l_int|1
suffix:semicolon
id|head
op_assign
id|bh
suffix:semicolon
id|bh-&gt;b_state
op_assign
l_int|0
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|bh-&gt;b_count
comma
l_int|0
)paren
suffix:semicolon
id|bh-&gt;b_size
op_assign
id|size
suffix:semicolon
multiline_comment|/* Link the buffer to its page */
id|set_bh_page
c_func
(paren
id|bh
comma
id|page
comma
id|offset
)paren
suffix:semicolon
id|bh-&gt;b_end_io
op_assign
l_int|NULL
suffix:semicolon
)brace
r_return
id|head
suffix:semicolon
multiline_comment|/*&n; * In case anything failed, we just free everything we got.&n; */
id|no_grow
suffix:colon
r_if
c_cond
(paren
id|head
)paren
(brace
r_do
(brace
id|bh
op_assign
id|head
suffix:semicolon
id|head
op_assign
id|head-&gt;b_this_page
suffix:semicolon
id|free_buffer_head
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|head
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Return failure for non-async IO requests.  Async IO requests&n;&t; * are not allowed to fail, so we have to wait until buffer heads&n;&t; * become available.  But we don&squot;t want tasks sleeping with &n;&t; * partially complete buffers, so all were released above.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|retry
)paren
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/* We&squot;re _really_ low on memory. Now we just&n;&t; * wait for old buffer heads to become free due to&n;&t; * finishing IO.  Since this is an async request and&n;&t; * the reserve list is empty, we&squot;re sure there are &n;&t; * async buffer heads in use.&n;&t; */
id|free_more_memory
c_func
(paren
)paren
suffix:semicolon
r_goto
id|try_again
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|link_dev_buffers
id|link_dev_buffers
c_func
(paren
r_struct
id|page
op_star
id|page
comma
r_struct
id|buffer_head
op_star
id|head
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
comma
op_star
id|tail
suffix:semicolon
id|bh
op_assign
id|head
suffix:semicolon
r_do
(brace
id|tail
op_assign
id|bh
suffix:semicolon
id|bh
op_assign
id|bh-&gt;b_this_page
suffix:semicolon
)brace
r_while
c_loop
(paren
id|bh
)paren
suffix:semicolon
id|tail-&gt;b_this_page
op_assign
id|head
suffix:semicolon
id|__set_page_buffers
c_func
(paren
id|page
comma
id|head
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Initialise the state of a blockdev page&squot;s buffers.&n; */
r_static
r_void
DECL|function|init_page_buffers
id|init_page_buffers
c_func
(paren
r_struct
id|page
op_star
id|page
comma
r_struct
id|block_device
op_star
id|bdev
comma
id|sector_t
id|block
comma
r_int
id|size
)paren
(brace
r_struct
id|buffer_head
op_star
id|head
op_assign
id|page_buffers
c_func
(paren
id|page
)paren
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
op_assign
id|head
suffix:semicolon
r_int
r_int
id|b_state
suffix:semicolon
id|b_state
op_assign
l_int|1
op_lshift
id|BH_Mapped
suffix:semicolon
r_if
c_cond
(paren
id|PageUptodate
c_func
(paren
id|page
)paren
)paren
id|b_state
op_or_assign
l_int|1
op_lshift
id|BH_Uptodate
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|bh-&gt;b_state
op_amp
(paren
l_int|1
op_lshift
id|BH_Mapped
)paren
)paren
)paren
(brace
id|init_buffer
c_func
(paren
id|bh
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
id|bh-&gt;b_bdev
op_assign
id|bdev
suffix:semicolon
id|bh-&gt;b_blocknr
op_assign
id|block
suffix:semicolon
id|bh-&gt;b_state
op_assign
id|b_state
suffix:semicolon
)brace
id|block
op_increment
suffix:semicolon
id|bh
op_assign
id|bh-&gt;b_this_page
suffix:semicolon
)brace
r_while
c_loop
(paren
id|bh
op_ne
id|head
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Create the page-cache page that contains the requested block.&n; *&n; * This is user purely for blockdev mappings.&n; */
r_static
r_struct
id|page
op_star
DECL|function|grow_dev_page
id|grow_dev_page
c_func
(paren
r_struct
id|block_device
op_star
id|bdev
comma
id|sector_t
id|block
comma
id|pgoff_t
id|index
comma
r_int
id|size
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|bdev-&gt;bd_inode
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
id|page
op_assign
id|find_or_create_page
c_func
(paren
id|inode-&gt;i_mapping
comma
id|index
comma
id|GFP_NOFS
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|PageLocked
c_func
(paren
id|page
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|page_has_buffers
c_func
(paren
id|page
)paren
)paren
(brace
id|bh
op_assign
id|page_buffers
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bh-&gt;b_size
op_eq
id|size
)paren
r_return
id|page
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|try_to_free_buffers
c_func
(paren
id|page
)paren
)paren
r_goto
id|failed
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Allocate some buffers for this page&n;&t; */
id|bh
op_assign
id|create_buffers
c_func
(paren
id|page
comma
id|size
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bh
)paren
r_goto
id|failed
suffix:semicolon
multiline_comment|/*&n;&t; * Link the page to the buffers and initialise them.  Take the&n;&t; * lock to be atomic wrt __find_get_block(), which does not&n;&t; * run under the page lock.&n;&t; */
id|spin_lock
c_func
(paren
op_amp
id|inode-&gt;i_mapping-&gt;private_lock
)paren
suffix:semicolon
id|link_dev_buffers
c_func
(paren
id|page
comma
id|bh
)paren
suffix:semicolon
id|init_page_buffers
c_func
(paren
id|page
comma
id|bdev
comma
id|block
comma
id|size
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|inode-&gt;i_mapping-&gt;private_lock
)paren
suffix:semicolon
r_return
id|page
suffix:semicolon
id|failed
suffix:colon
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * Create buffers for the specified block device block&squot;s page.  If&n; * that page was dirty, the buffers are set dirty also.&n; *&n; * Except that&squot;s a bug.  Attaching dirty buffers to a dirty&n; * blockdev&squot;s page can result in filesystem corruption, because&n; * some of those buffers may be aliases of filesystem data.&n; * grow_dev_page() will go BUG() if this happens.&n; */
r_static
r_inline
r_int
DECL|function|grow_buffers
id|grow_buffers
c_func
(paren
r_struct
id|block_device
op_star
id|bdev
comma
id|sector_t
id|block
comma
r_int
id|size
)paren
(brace
r_struct
id|page
op_star
id|page
suffix:semicolon
id|pgoff_t
id|index
suffix:semicolon
r_int
id|sizebits
suffix:semicolon
id|sizebits
op_assign
op_minus
l_int|1
suffix:semicolon
r_do
(brace
id|sizebits
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|size
op_lshift
id|sizebits
)paren
OL
id|PAGE_SIZE
)paren
suffix:semicolon
id|index
op_assign
id|block
op_rshift
id|sizebits
suffix:semicolon
id|block
op_assign
id|index
op_lshift
id|sizebits
suffix:semicolon
multiline_comment|/* Create a page with the proper size buffers.. */
id|page
op_assign
id|grow_dev_page
c_func
(paren
id|bdev
comma
id|block
comma
id|index
comma
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page
)paren
r_return
l_int|0
suffix:semicolon
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_struct
id|buffer_head
op_star
DECL|function|__getblk_slow
id|__getblk_slow
c_func
(paren
r_struct
id|block_device
op_star
id|bdev
comma
id|sector_t
id|block
comma
r_int
id|size
)paren
(brace
multiline_comment|/* Size must be multiple of hard sectorsize */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|size
op_amp
(paren
id|bdev_hardsect_size
c_func
(paren
id|bdev
)paren
op_minus
l_int|1
)paren
op_logical_or
(paren
id|size
template_param
id|PAGE_SIZE
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;getblk(): invalid block size %d requested&bslash;n&quot;
comma
id|size
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;hardsect size: %d&bslash;n&quot;
comma
id|bdev_hardsect_size
c_func
(paren
id|bdev
)paren
)paren
suffix:semicolon
id|dump_stack
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
id|bh
op_assign
id|__find_get_block
c_func
(paren
id|bdev
comma
id|block
comma
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bh
)paren
r_return
id|bh
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|grow_buffers
c_func
(paren
id|bdev
comma
id|block
comma
id|size
)paren
)paren
id|free_more_memory
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * The relationship between dirty buffers and dirty pages:&n; *&n; * Whenever a page has any dirty buffers, the page&squot;s dirty bit is set, and&n; * the page is tagged dirty in its radix tree.&n; *&n; * At all times, the dirtiness of the buffers represents the dirtiness of&n; * subsections of the page.  If the page has buffers, the page dirty bit is&n; * merely a hint about the true dirty state.&n; *&n; * When a page is set dirty in its entirety, all its buffers are marked dirty&n; * (if the page has buffers).&n; *&n; * When a buffer is marked dirty, its page is dirtied, but the page&squot;s other&n; * buffers are not.&n; *&n; * Also.  When blockdev buffers are explicitly read with bread(), they&n; * individually become uptodate.  But their backing page remains not&n; * uptodate - even if all of its buffers are uptodate.  A subsequent&n; * block_read_full_page() against that page will discover all the uptodate&n; * buffers, will set the page uptodate and will perform no I/O.&n; */
multiline_comment|/**&n; * mark_buffer_dirty - mark a buffer_head as needing writeout&n; *&n; * mark_buffer_dirty() will set the dirty bit against the buffer, then set its&n; * backing page dirty, then tag the page as dirty in its address_space&squot;s radix&n; * tree and then attach the address_space&squot;s inode to its superblock&squot;s dirty&n; * inode list.&n; *&n; * mark_buffer_dirty() is atomic.  It takes bh-&gt;b_page-&gt;mapping-&gt;private_lock,&n; * mapping-&gt;tree_lock and the global inode_lock.&n; */
DECL|function|mark_buffer_dirty
r_void
id|fastcall
id|mark_buffer_dirty
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|buffer_dirty
c_func
(paren
id|bh
)paren
op_logical_and
op_logical_neg
id|test_set_buffer_dirty
c_func
(paren
id|bh
)paren
)paren
id|__set_page_dirty_nobuffers
c_func
(paren
id|bh-&gt;b_page
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Decrement a buffer_head&squot;s reference count.  If all buffers against a page&n; * have zero reference count, are clean and unlocked, and if the page is clean&n; * and unlocked then try_to_free_buffers() may strip the buffers from the page&n; * in preparation for freeing it (sometimes, rarely, buffers are removed from&n; * a page but it ends up not being freed, and buffers may later be reattached).&n; */
DECL|function|__brelse
r_void
id|__brelse
c_func
(paren
r_struct
id|buffer_head
op_star
id|buf
)paren
(brace
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|buf-&gt;b_count
)paren
)paren
(brace
id|put_bh
c_func
(paren
id|buf
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;VFS: brelse: Trying to free free buffer&bslash;n&quot;
)paren
suffix:semicolon
id|WARN_ON
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * bforget() is like brelse(), except it discards any&n; * potentially dirty data.&n; */
DECL|function|__bforget
r_void
id|__bforget
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
id|clear_buffer_dirty
c_func
(paren
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|bh-&gt;b_assoc_buffers
)paren
)paren
(brace
r_struct
id|address_space
op_star
id|buffer_mapping
op_assign
id|bh-&gt;b_page-&gt;mapping
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|buffer_mapping-&gt;private_lock
)paren
suffix:semicolon
id|list_del_init
c_func
(paren
op_amp
id|bh-&gt;b_assoc_buffers
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|buffer_mapping-&gt;private_lock
)paren
suffix:semicolon
)brace
id|__brelse
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
DECL|function|__bread_slow
r_static
r_struct
id|buffer_head
op_star
id|__bread_slow
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
id|lock_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buffer_uptodate
c_func
(paren
id|bh
)paren
)paren
(brace
id|unlock_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
r_return
id|bh
suffix:semicolon
)brace
r_else
(brace
id|get_bh
c_func
(paren
id|bh
)paren
suffix:semicolon
id|bh-&gt;b_end_io
op_assign
id|end_buffer_read_sync
suffix:semicolon
id|submit_bh
c_func
(paren
id|READ
comma
id|bh
)paren
suffix:semicolon
id|wait_on_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buffer_uptodate
c_func
(paren
id|bh
)paren
)paren
r_return
id|bh
suffix:semicolon
)brace
id|brelse
c_func
(paren
id|bh
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * Per-cpu buffer LRU implementation.  To reduce the cost of __find_get_block().&n; * The bhs[] array is sorted - newest buffer is at bhs[0].  Buffers have their&n; * refcount elevated by one when they&squot;re in an LRU.  A buffer can only appear&n; * once in a particular CPU&squot;s LRU.  A single buffer can be present in multiple&n; * CPU&squot;s LRUs at the same time.&n; *&n; * This is a transparent caching front-end to sb_bread(), sb_getblk() and&n; * sb_find_get_block().&n; *&n; * The LRUs themselves only need locking against invalidate_bh_lrus.  We use&n; * a local interrupt disable for that.&n; */
DECL|macro|BH_LRU_SIZE
mdefine_line|#define BH_LRU_SIZE&t;8
DECL|struct|bh_lru
r_struct
id|bh_lru
(brace
DECL|member|bhs
r_struct
id|buffer_head
op_star
id|bhs
(braket
id|BH_LRU_SIZE
)braket
suffix:semicolon
)brace
suffix:semicolon
r_static
id|DEFINE_PER_CPU
c_func
(paren
r_struct
id|bh_lru
comma
id|bh_lrus
)paren
op_assign
(brace
(brace
l_int|0
)brace
)brace
suffix:semicolon
macro_line|#ifdef CONFIG_SMP
DECL|macro|bh_lru_lock
mdefine_line|#define bh_lru_lock()&t;local_irq_disable()
DECL|macro|bh_lru_unlock
mdefine_line|#define bh_lru_unlock()&t;local_irq_enable()
macro_line|#else
DECL|macro|bh_lru_lock
mdefine_line|#define bh_lru_lock()&t;preempt_disable()
DECL|macro|bh_lru_unlock
mdefine_line|#define bh_lru_unlock()&t;preempt_enable()
macro_line|#endif
DECL|function|check_irqs_on
r_static
r_inline
r_void
id|check_irqs_on
c_func
(paren
r_void
)paren
(brace
macro_line|#ifdef irqs_disabled
id|BUG_ON
c_func
(paren
id|irqs_disabled
c_func
(paren
)paren
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n; * The LRU management algorithm is dopey-but-simple.  Sorry.&n; */
DECL|function|bh_lru_install
r_static
r_void
id|bh_lru_install
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
r_struct
id|buffer_head
op_star
id|evictee
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|bh_lru
op_star
id|lru
suffix:semicolon
id|check_irqs_on
c_func
(paren
)paren
suffix:semicolon
id|bh_lru_lock
c_func
(paren
)paren
suffix:semicolon
id|lru
op_assign
op_amp
id|__get_cpu_var
c_func
(paren
id|bh_lrus
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lru-&gt;bhs
(braket
l_int|0
)braket
op_ne
id|bh
)paren
(brace
r_struct
id|buffer_head
op_star
id|bhs
(braket
id|BH_LRU_SIZE
)braket
suffix:semicolon
r_int
id|in
suffix:semicolon
r_int
id|out
op_assign
l_int|0
suffix:semicolon
id|get_bh
c_func
(paren
id|bh
)paren
suffix:semicolon
id|bhs
(braket
id|out
op_increment
)braket
op_assign
id|bh
suffix:semicolon
r_for
c_loop
(paren
id|in
op_assign
l_int|0
suffix:semicolon
id|in
OL
id|BH_LRU_SIZE
suffix:semicolon
id|in
op_increment
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh2
op_assign
id|lru-&gt;bhs
(braket
id|in
)braket
suffix:semicolon
r_if
c_cond
(paren
id|bh2
op_eq
id|bh
)paren
(brace
id|__brelse
c_func
(paren
id|bh2
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|out
op_ge
id|BH_LRU_SIZE
)paren
(brace
id|BUG_ON
c_func
(paren
id|evictee
op_ne
l_int|NULL
)paren
suffix:semicolon
id|evictee
op_assign
id|bh2
suffix:semicolon
)brace
r_else
(brace
id|bhs
(braket
id|out
op_increment
)braket
op_assign
id|bh2
suffix:semicolon
)brace
)brace
)brace
r_while
c_loop
(paren
id|out
OL
id|BH_LRU_SIZE
)paren
id|bhs
(braket
id|out
op_increment
)braket
op_assign
l_int|NULL
suffix:semicolon
id|memcpy
c_func
(paren
id|lru-&gt;bhs
comma
id|bhs
comma
r_sizeof
(paren
id|bhs
)paren
)paren
suffix:semicolon
)brace
id|bh_lru_unlock
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|evictee
)paren
id|__brelse
c_func
(paren
id|evictee
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Look up the bh in this cpu&squot;s LRU.  If it&squot;s there, move it to the head.&n; */
r_static
r_inline
r_struct
id|buffer_head
op_star
DECL|function|lookup_bh_lru
id|lookup_bh_lru
c_func
(paren
r_struct
id|block_device
op_star
id|bdev
comma
id|sector_t
id|block
comma
r_int
id|size
)paren
(brace
r_struct
id|buffer_head
op_star
id|ret
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|bh_lru
op_star
id|lru
suffix:semicolon
r_int
id|i
suffix:semicolon
id|check_irqs_on
c_func
(paren
)paren
suffix:semicolon
id|bh_lru_lock
c_func
(paren
)paren
suffix:semicolon
id|lru
op_assign
op_amp
id|__get_cpu_var
c_func
(paren
id|bh_lrus
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|BH_LRU_SIZE
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
op_assign
id|lru-&gt;bhs
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|bh
op_logical_and
id|bh-&gt;b_bdev
op_eq
id|bdev
op_logical_and
id|bh-&gt;b_blocknr
op_eq
id|block
op_logical_and
id|bh-&gt;b_size
op_eq
id|size
)paren
(brace
r_if
c_cond
(paren
id|i
)paren
(brace
r_while
c_loop
(paren
id|i
)paren
(brace
id|lru-&gt;bhs
(braket
id|i
)braket
op_assign
id|lru-&gt;bhs
(braket
id|i
op_minus
l_int|1
)braket
suffix:semicolon
id|i
op_decrement
suffix:semicolon
)brace
id|lru-&gt;bhs
(braket
l_int|0
)braket
op_assign
id|bh
suffix:semicolon
)brace
id|get_bh
c_func
(paren
id|bh
)paren
suffix:semicolon
id|ret
op_assign
id|bh
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|bh_lru_unlock
c_func
(paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Perform a pagecache lookup for the matching buffer.  If it&squot;s there, refresh&n; * it in the LRU and mark it as accessed.  If it is not present then return&n; * NULL&n; */
r_struct
id|buffer_head
op_star
DECL|function|__find_get_block
id|__find_get_block
c_func
(paren
r_struct
id|block_device
op_star
id|bdev
comma
id|sector_t
id|block
comma
r_int
id|size
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
op_assign
id|lookup_bh_lru
c_func
(paren
id|bdev
comma
id|block
comma
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bh
op_eq
l_int|NULL
)paren
(brace
id|bh
op_assign
id|__find_get_block_slow
c_func
(paren
id|bdev
comma
id|block
comma
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bh
)paren
id|bh_lru_install
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bh
)paren
id|touch_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
r_return
id|bh
suffix:semicolon
)brace
DECL|variable|__find_get_block
id|EXPORT_SYMBOL
c_func
(paren
id|__find_get_block
)paren
suffix:semicolon
multiline_comment|/*&n; * __getblk will locate (and, if necessary, create) the buffer_head&n; * which corresponds to the passed block_device, block and size. The&n; * returned buffer has its reference count incremented.&n; *&n; * __getblk() cannot fail - it just keeps trying.  If you pass it an&n; * illegal block number, __getblk() will happily return a buffer_head&n; * which represents the non-existent block.  Very weird.&n; *&n; * __getblk() will lock up the machine if grow_dev_page&squot;s try_to_free_buffers()&n; * attempt is failing.  FIXME, perhaps?&n; */
r_struct
id|buffer_head
op_star
DECL|function|__getblk
id|__getblk
c_func
(paren
r_struct
id|block_device
op_star
id|bdev
comma
id|sector_t
id|block
comma
r_int
id|size
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
op_assign
id|__find_get_block
c_func
(paren
id|bdev
comma
id|block
comma
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bh
op_eq
l_int|NULL
)paren
id|bh
op_assign
id|__getblk_slow
c_func
(paren
id|bdev
comma
id|block
comma
id|size
)paren
suffix:semicolon
r_return
id|bh
suffix:semicolon
)brace
DECL|variable|__getblk
id|EXPORT_SYMBOL
c_func
(paren
id|__getblk
)paren
suffix:semicolon
multiline_comment|/*&n; * Do async read-ahead on a buffer..&n; */
DECL|function|__breadahead
r_void
id|__breadahead
c_func
(paren
r_struct
id|block_device
op_star
id|bdev
comma
id|sector_t
id|block
comma
r_int
id|size
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
op_assign
id|__getblk
c_func
(paren
id|bdev
comma
id|block
comma
id|size
)paren
suffix:semicolon
id|ll_rw_block
c_func
(paren
id|READA
comma
l_int|1
comma
op_amp
id|bh
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
DECL|variable|__breadahead
id|EXPORT_SYMBOL
c_func
(paren
id|__breadahead
)paren
suffix:semicolon
multiline_comment|/**&n; *  __bread() - reads a specified block and returns the bh&n; *  @block: number of block&n; *  @size: size (in bytes) to read&n; * &n; *  Reads a specified block, and returns buffer head that contains it.&n; *  It returns NULL if the block was unreadable.&n; */
r_struct
id|buffer_head
op_star
DECL|function|__bread
id|__bread
c_func
(paren
r_struct
id|block_device
op_star
id|bdev
comma
id|sector_t
id|block
comma
r_int
id|size
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
op_assign
id|__getblk
c_func
(paren
id|bdev
comma
id|block
comma
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|bh
)paren
)paren
id|bh
op_assign
id|__bread_slow
c_func
(paren
id|bh
)paren
suffix:semicolon
r_return
id|bh
suffix:semicolon
)brace
DECL|variable|__bread
id|EXPORT_SYMBOL
c_func
(paren
id|__bread
)paren
suffix:semicolon
multiline_comment|/*&n; * invalidate_bh_lrus() is called rarely - at unmount.  Because it is only for&n; * unmount it only needs to ensure that all buffers from the target device are&n; * invalidated on return and it doesn&squot;t need to worry about new buffers from&n; * that device being added - the unmount code has to prevent that.&n; */
DECL|function|invalidate_bh_lru
r_static
r_void
id|invalidate_bh_lru
c_func
(paren
r_void
op_star
id|arg
)paren
(brace
r_struct
id|bh_lru
op_star
id|b
op_assign
op_amp
id|get_cpu_var
c_func
(paren
id|bh_lrus
)paren
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|BH_LRU_SIZE
suffix:semicolon
id|i
op_increment
)paren
(brace
id|brelse
c_func
(paren
id|b-&gt;bhs
(braket
id|i
)braket
)paren
suffix:semicolon
id|b-&gt;bhs
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
id|put_cpu_var
c_func
(paren
id|bh_lrus
)paren
suffix:semicolon
)brace
DECL|function|invalidate_bh_lrus
r_static
r_void
id|invalidate_bh_lrus
c_func
(paren
r_void
)paren
(brace
id|on_each_cpu
c_func
(paren
id|invalidate_bh_lru
comma
l_int|NULL
comma
l_int|1
comma
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|set_bh_page
r_void
id|set_bh_page
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
comma
r_struct
id|page
op_star
id|page
comma
r_int
r_int
id|offset
)paren
(brace
id|bh-&gt;b_page
op_assign
id|page
suffix:semicolon
r_if
c_cond
(paren
id|offset
op_ge
id|PAGE_SIZE
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PageHighMem
c_func
(paren
id|page
)paren
)paren
multiline_comment|/*&n;&t;&t; * This catches illegal uses and preserves the offset:&n;&t;&t; */
id|bh-&gt;b_data
op_assign
(paren
r_char
op_star
)paren
(paren
l_int|0
op_plus
id|offset
)paren
suffix:semicolon
r_else
id|bh-&gt;b_data
op_assign
id|page_address
c_func
(paren
id|page
)paren
op_plus
id|offset
suffix:semicolon
)brace
DECL|variable|set_bh_page
id|EXPORT_SYMBOL
c_func
(paren
id|set_bh_page
)paren
suffix:semicolon
multiline_comment|/*&n; * Called when truncating a buffer on a page completely.&n; */
DECL|function|discard_buffer
r_static
r_inline
r_void
id|discard_buffer
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
id|lock_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
id|clear_buffer_dirty
c_func
(paren
id|bh
)paren
suffix:semicolon
id|bh-&gt;b_bdev
op_assign
l_int|NULL
suffix:semicolon
id|clear_buffer_mapped
c_func
(paren
id|bh
)paren
suffix:semicolon
id|clear_buffer_req
c_func
(paren
id|bh
)paren
suffix:semicolon
id|clear_buffer_new
c_func
(paren
id|bh
)paren
suffix:semicolon
id|clear_buffer_delay
c_func
(paren
id|bh
)paren
suffix:semicolon
id|unlock_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * try_to_release_page() - release old fs-specific metadata on a page&n; *&n; * @page: the page which the kernel is trying to free&n; * @gfp_mask: memory allocation flags (and I/O mode)&n; *&n; * The address_space is to try to release any data against the page&n; * (presumably at page-&gt;private).  If the release was successful, return `1&squot;.&n; * Otherwise return zero.&n; *&n; * The @gfp_mask argument specifies whether I/O may be performed to release&n; * this page (__GFP_IO), and whether the call may block (__GFP_WAIT).&n; *&n; * NOTE: @gfp_mask may go away, and this function may become non-blocking.&n; */
DECL|function|try_to_release_page
r_int
id|try_to_release_page
c_func
(paren
r_struct
id|page
op_star
id|page
comma
r_int
id|gfp_mask
)paren
(brace
r_struct
id|address_space
op_star
r_const
id|mapping
op_assign
id|page-&gt;mapping
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|PageLocked
c_func
(paren
id|page
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PageWriteback
c_func
(paren
id|page
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|mapping
op_logical_and
id|mapping-&gt;a_ops-&gt;releasepage
)paren
r_return
id|mapping-&gt;a_ops
op_member_access_from_pointer
id|releasepage
c_func
(paren
id|page
comma
id|gfp_mask
)paren
suffix:semicolon
r_return
id|try_to_free_buffers
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
DECL|variable|try_to_release_page
id|EXPORT_SYMBOL
c_func
(paren
id|try_to_release_page
)paren
suffix:semicolon
multiline_comment|/**&n; * block_invalidatepage - invalidate part of all of a buffer-backed page&n; *&n; * @page: the page which is affected&n; * @offset: the index of the truncation point&n; *&n; * block_invalidatepage() is called when all or part of the page has become&n; * invalidatedby a truncate operation.&n; *&n; * block_invalidatepage() does not have to release all buffers, but it must&n; * ensure that no dirty buffer is left outside @offset and that no I/O&n; * is underway against any of the blocks which are outside the truncation&n; * point.  Because the caller is about to free (and possibly reuse) those&n; * blocks on-disk.&n; */
DECL|function|block_invalidatepage
r_int
id|block_invalidatepage
c_func
(paren
r_struct
id|page
op_star
id|page
comma
r_int
r_int
id|offset
)paren
(brace
r_struct
id|buffer_head
op_star
id|head
comma
op_star
id|bh
comma
op_star
id|next
suffix:semicolon
r_int
r_int
id|curr_off
op_assign
l_int|0
suffix:semicolon
r_int
id|ret
op_assign
l_int|1
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|PageLocked
c_func
(paren
id|page
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page_has_buffers
c_func
(paren
id|page
)paren
)paren
r_goto
id|out
suffix:semicolon
id|head
op_assign
id|page_buffers
c_func
(paren
id|page
)paren
suffix:semicolon
id|bh
op_assign
id|head
suffix:semicolon
r_do
(brace
r_int
r_int
id|next_off
op_assign
id|curr_off
op_plus
id|bh-&gt;b_size
suffix:semicolon
id|next
op_assign
id|bh-&gt;b_this_page
suffix:semicolon
multiline_comment|/*&n;&t;&t; * is this block fully invalidated?&n;&t;&t; */
r_if
c_cond
(paren
id|offset
op_le
id|curr_off
)paren
id|discard_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
id|curr_off
op_assign
id|next_off
suffix:semicolon
id|bh
op_assign
id|next
suffix:semicolon
)brace
r_while
c_loop
(paren
id|bh
op_ne
id|head
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We release buffers only if the entire page is being invalidated.&n;&t; * The get_block cached value has been unconditionally invalidated,&n;&t; * so real IO is not possible anymore.&n;&t; */
r_if
c_cond
(paren
id|offset
op_eq
l_int|0
)paren
id|ret
op_assign
id|try_to_release_page
c_func
(paren
id|page
comma
l_int|0
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|ret
suffix:semicolon
)brace
DECL|variable|block_invalidatepage
id|EXPORT_SYMBOL
c_func
(paren
id|block_invalidatepage
)paren
suffix:semicolon
multiline_comment|/*&n; * We attach and possibly dirty the buffers atomically wrt&n; * __set_page_dirty_buffers() via private_lock.  try_to_free_buffers&n; * is already excluded via the page lock.&n; */
DECL|function|create_empty_buffers
r_void
id|create_empty_buffers
c_func
(paren
r_struct
id|page
op_star
id|page
comma
r_int
r_int
id|blocksize
comma
r_int
r_int
id|b_state
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
comma
op_star
id|head
comma
op_star
id|tail
suffix:semicolon
id|head
op_assign
id|create_buffers
c_func
(paren
id|page
comma
id|blocksize
comma
l_int|1
)paren
suffix:semicolon
id|bh
op_assign
id|head
suffix:semicolon
r_do
(brace
id|bh-&gt;b_state
op_or_assign
id|b_state
suffix:semicolon
id|tail
op_assign
id|bh
suffix:semicolon
id|bh
op_assign
id|bh-&gt;b_this_page
suffix:semicolon
)brace
r_while
c_loop
(paren
id|bh
)paren
suffix:semicolon
id|tail-&gt;b_this_page
op_assign
id|head
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|page-&gt;mapping-&gt;private_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PageUptodate
c_func
(paren
id|page
)paren
op_logical_or
id|PageDirty
c_func
(paren
id|page
)paren
)paren
(brace
id|bh
op_assign
id|head
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|PageDirty
c_func
(paren
id|page
)paren
)paren
id|set_buffer_dirty
c_func
(paren
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PageUptodate
c_func
(paren
id|page
)paren
)paren
id|set_buffer_uptodate
c_func
(paren
id|bh
)paren
suffix:semicolon
id|bh
op_assign
id|bh-&gt;b_this_page
suffix:semicolon
)brace
r_while
c_loop
(paren
id|bh
op_ne
id|head
)paren
suffix:semicolon
)brace
id|__set_page_buffers
c_func
(paren
id|page
comma
id|head
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|page-&gt;mapping-&gt;private_lock
)paren
suffix:semicolon
)brace
DECL|variable|create_empty_buffers
id|EXPORT_SYMBOL
c_func
(paren
id|create_empty_buffers
)paren
suffix:semicolon
multiline_comment|/*&n; * We are taking a block for data and we don&squot;t want any output from any&n; * buffer-cache aliases starting from return from that function and&n; * until the moment when something will explicitly mark the buffer&n; * dirty (hopefully that will not happen until we will free that block ;-)&n; * We don&squot;t even need to mark it not-uptodate - nobody can expect&n; * anything from a newly allocated buffer anyway. We used to used&n; * unmap_buffer() for such invalidation, but that was wrong. We definitely&n; * don&squot;t want to mark the alias unmapped, for example - it would confuse&n; * anyone who might pick it with bread() afterwards...&n; *&n; * Also..  Note that bforget() doesn&squot;t lock the buffer.  So there can&n; * be writeout I/O going on against recently-freed buffers.  We don&squot;t&n; * wait on that I/O in bforget() - it&squot;s more efficient to wait on the I/O&n; * only if we really need to.  That happens here.&n; */
DECL|function|unmap_underlying_metadata
r_void
id|unmap_underlying_metadata
c_func
(paren
r_struct
id|block_device
op_star
id|bdev
comma
id|sector_t
id|block
)paren
(brace
r_struct
id|buffer_head
op_star
id|old_bh
suffix:semicolon
id|old_bh
op_assign
id|__find_get_block_slow
c_func
(paren
id|bdev
comma
id|block
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|old_bh
)paren
(brace
id|clear_buffer_dirty
c_func
(paren
id|old_bh
)paren
suffix:semicolon
id|wait_on_buffer
c_func
(paren
id|old_bh
)paren
suffix:semicolon
id|clear_buffer_req
c_func
(paren
id|old_bh
)paren
suffix:semicolon
id|__brelse
c_func
(paren
id|old_bh
)paren
suffix:semicolon
)brace
)brace
DECL|variable|unmap_underlying_metadata
id|EXPORT_SYMBOL
c_func
(paren
id|unmap_underlying_metadata
)paren
suffix:semicolon
multiline_comment|/*&n; * NOTE! All mapped/uptodate combinations are valid:&n; *&n; *&t;Mapped&t;Uptodate&t;Meaning&n; *&n; *&t;No&t;No&t;&t;&quot;unknown&quot; - must do get_block()&n; *&t;No&t;Yes&t;&t;&quot;hole&quot; - zero-filled&n; *&t;Yes&t;No&t;&t;&quot;allocated&quot; - allocated on disk, not read in&n; *&t;Yes&t;Yes&t;&t;&quot;valid&quot; - allocated and up-to-date in memory.&n; *&n; * &quot;Dirty&quot; is valid only with the last case (mapped+uptodate).&n; */
multiline_comment|/*&n; * While block_write_full_page is writing back the dirty buffers under&n; * the page lock, whoever dirtied the buffers may decide to clean them&n; * again at any time.  We handle that by only looking at the buffer&n; * state inside lock_buffer().&n; *&n; * If block_write_full_page() is called for regular writeback&n; * (called_for_sync() is false) then it will redirty a page which has a locked&n; * buffer.   This only can happen if someone has written the buffer directly,&n; * with submit_bh().  At the address_space level PageWriteback prevents this&n; * contention from occurring.&n; */
DECL|function|__block_write_full_page
r_static
r_int
id|__block_write_full_page
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|page
op_star
id|page
comma
id|get_block_t
op_star
id|get_block
comma
r_struct
id|writeback_control
op_star
id|wbc
)paren
(brace
r_int
id|err
suffix:semicolon
id|sector_t
id|block
suffix:semicolon
id|sector_t
id|last_block
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
comma
op_star
id|head
suffix:semicolon
r_int
id|nr_underway
op_assign
l_int|0
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|PageLocked
c_func
(paren
id|page
)paren
)paren
suffix:semicolon
id|last_block
op_assign
(paren
id|i_size_read
c_func
(paren
id|inode
)paren
op_minus
l_int|1
)paren
op_rshift
id|inode-&gt;i_blkbits
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page_has_buffers
c_func
(paren
id|page
)paren
)paren
(brace
id|create_empty_buffers
c_func
(paren
id|page
comma
l_int|1
op_lshift
id|inode-&gt;i_blkbits
comma
(paren
l_int|1
op_lshift
id|BH_Dirty
)paren
op_or
(paren
l_int|1
op_lshift
id|BH_Uptodate
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Be very careful.  We have no exclusion from __set_page_dirty_buffers&n;&t; * here, and the (potentially unmapped) buffers may become dirty at&n;&t; * any time.  If a buffer becomes dirty here after we&squot;ve inspected it&n;&t; * then we just miss that fact, and the page stays dirty.&n;&t; *&n;&t; * Buffers outside i_size may be dirtied by __set_page_dirty_buffers;&n;&t; * handle that here by just cleaning them.&n;&t; */
id|block
op_assign
id|page-&gt;index
op_lshift
(paren
id|PAGE_CACHE_SHIFT
op_minus
id|inode-&gt;i_blkbits
)paren
suffix:semicolon
id|head
op_assign
id|page_buffers
c_func
(paren
id|page
)paren
suffix:semicolon
id|bh
op_assign
id|head
suffix:semicolon
multiline_comment|/*&n;&t; * Get all the dirty buffers mapped to disk addresses and&n;&t; * handle any aliases from the underlying blockdev&squot;s mapping.&n;&t; */
r_do
(brace
r_if
c_cond
(paren
id|block
OG
id|last_block
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * mapped buffers outside i_size will occur, because&n;&t;&t;&t; * this page can be outside i_size when there is a&n;&t;&t;&t; * truncate in progress.&n;&t;&t;&t; */
multiline_comment|/*&n;&t;&t;&t; * The buffer was zeroed by block_write_full_page()&n;&t;&t;&t; */
id|clear_buffer_dirty
c_func
(paren
id|bh
)paren
suffix:semicolon
id|set_buffer_uptodate
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|buffer_mapped
c_func
(paren
id|bh
)paren
op_logical_and
id|buffer_dirty
c_func
(paren
id|bh
)paren
)paren
(brace
id|err
op_assign
id|get_block
c_func
(paren
id|inode
comma
id|block
comma
id|bh
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|recover
suffix:semicolon
r_if
c_cond
(paren
id|buffer_new
c_func
(paren
id|bh
)paren
)paren
(brace
multiline_comment|/* blockdev mappings never come here */
id|clear_buffer_new
c_func
(paren
id|bh
)paren
suffix:semicolon
id|unmap_underlying_metadata
c_func
(paren
id|bh-&gt;b_bdev
comma
id|bh-&gt;b_blocknr
)paren
suffix:semicolon
)brace
)brace
id|bh
op_assign
id|bh-&gt;b_this_page
suffix:semicolon
id|block
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
id|bh
op_ne
id|head
)paren
suffix:semicolon
r_do
(brace
id|get_bh
c_func
(paren
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buffer_mapped
c_func
(paren
id|bh
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If it&squot;s a fully non-blocking write attempt and we cannot&n;&t;&t; * lock the buffer then redirty the page.  Note that this can&n;&t;&t; * potentially cause a busy-wait loop from pdflush and kswapd&n;&t;&t; * activity, but those code paths have their own higher-level&n;&t;&t; * throttling.&n;&t;&t; */
r_if
c_cond
(paren
id|wbc-&gt;sync_mode
op_ne
id|WB_SYNC_NONE
op_logical_or
op_logical_neg
id|wbc-&gt;nonblocking
)paren
(brace
id|lock_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|test_set_buffer_locked
c_func
(paren
id|bh
)paren
)paren
(brace
id|redirty_page_for_writepage
c_func
(paren
id|wbc
comma
id|page
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|test_clear_buffer_dirty
c_func
(paren
id|bh
)paren
)paren
(brace
id|mark_buffer_async_write
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
r_else
(brace
id|unlock_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
(paren
id|bh
op_assign
id|bh-&gt;b_this_page
)paren
op_ne
id|head
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|PageWriteback
c_func
(paren
id|page
)paren
)paren
suffix:semicolon
id|set_page_writeback
c_func
(paren
id|page
)paren
suffix:semicolon
multiline_comment|/* Keeps try_to_free_buffers() away */
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * The page may come unlocked any time after the *first* submit_bh()&n;&t; * call.  Be careful with its buffers.&n;&t; */
r_do
(brace
r_struct
id|buffer_head
op_star
id|next
op_assign
id|bh-&gt;b_this_page
suffix:semicolon
r_if
c_cond
(paren
id|buffer_async_write
c_func
(paren
id|bh
)paren
)paren
(brace
id|submit_bh
c_func
(paren
id|WRITE
comma
id|bh
)paren
suffix:semicolon
id|nr_underway
op_increment
suffix:semicolon
)brace
id|put_bh
c_func
(paren
id|bh
)paren
suffix:semicolon
id|bh
op_assign
id|next
suffix:semicolon
)brace
r_while
c_loop
(paren
id|bh
op_ne
id|head
)paren
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
id|done
suffix:colon
r_if
c_cond
(paren
id|nr_underway
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * The page was marked dirty, but the buffers were&n;&t;&t; * clean.  Someone wrote them back by hand with&n;&t;&t; * ll_rw_block/submit_bh.  A rare case.&n;&t;&t; */
r_int
id|uptodate
op_assign
l_int|1
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|bh
)paren
)paren
(brace
id|uptodate
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
id|bh
op_assign
id|bh-&gt;b_this_page
suffix:semicolon
)brace
r_while
c_loop
(paren
id|bh
op_ne
id|head
)paren
suffix:semicolon
r_if
c_cond
(paren
id|uptodate
)paren
id|SetPageUptodate
c_func
(paren
id|page
)paren
suffix:semicolon
id|end_page_writeback
c_func
(paren
id|page
)paren
suffix:semicolon
id|wbc-&gt;pages_skipped
op_increment
suffix:semicolon
multiline_comment|/* We didn&squot;t write this page */
)brace
r_return
id|err
suffix:semicolon
id|recover
suffix:colon
multiline_comment|/*&n;&t; * ENOSPC, or some other error.  We may already have added some&n;&t; * blocks to the file, so we need to write these out to avoid&n;&t; * exposing stale data.&n;&t; * The page is currently locked and not marked for writeback&n;&t; */
id|bh
op_assign
id|head
suffix:semicolon
multiline_comment|/* Recovery: lock and submit the mapped buffers */
r_do
(brace
id|get_bh
c_func
(paren
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buffer_mapped
c_func
(paren
id|bh
)paren
op_logical_and
id|buffer_dirty
c_func
(paren
id|bh
)paren
)paren
(brace
id|lock_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
id|mark_buffer_async_write
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; * The buffer may have been set dirty during&n;&t;&t;&t; * attachment to a dirty page.&n;&t;&t;&t; */
id|clear_buffer_dirty
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
(paren
id|bh
op_assign
id|bh-&gt;b_this_page
)paren
op_ne
id|head
)paren
suffix:semicolon
id|SetPageError
c_func
(paren
id|page
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|PageWriteback
c_func
(paren
id|page
)paren
)paren
suffix:semicolon
id|set_page_writeback
c_func
(paren
id|page
)paren
suffix:semicolon
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_do
(brace
r_struct
id|buffer_head
op_star
id|next
op_assign
id|bh-&gt;b_this_page
suffix:semicolon
r_if
c_cond
(paren
id|buffer_async_write
c_func
(paren
id|bh
)paren
)paren
(brace
id|clear_buffer_dirty
c_func
(paren
id|bh
)paren
suffix:semicolon
id|submit_bh
c_func
(paren
id|WRITE
comma
id|bh
)paren
suffix:semicolon
id|nr_underway
op_increment
suffix:semicolon
)brace
id|put_bh
c_func
(paren
id|bh
)paren
suffix:semicolon
id|bh
op_assign
id|next
suffix:semicolon
)brace
r_while
c_loop
(paren
id|bh
op_ne
id|head
)paren
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
DECL|function|__block_prepare_write
r_static
r_int
id|__block_prepare_write
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|page
op_star
id|page
comma
r_int
id|from
comma
r_int
id|to
comma
id|get_block_t
op_star
id|get_block
)paren
(brace
r_int
id|block_start
comma
id|block_end
suffix:semicolon
id|sector_t
id|block
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
r_int
id|blocksize
comma
id|bbits
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
comma
op_star
id|head
comma
op_star
id|wait
(braket
l_int|2
)braket
comma
op_star
op_star
id|wait_bh
op_assign
id|wait
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|PageLocked
c_func
(paren
id|page
)paren
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|from
OG
id|PAGE_CACHE_SIZE
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|to
OG
id|PAGE_CACHE_SIZE
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|from
OG
id|to
)paren
suffix:semicolon
id|blocksize
op_assign
l_int|1
op_lshift
id|inode-&gt;i_blkbits
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page_has_buffers
c_func
(paren
id|page
)paren
)paren
id|create_empty_buffers
c_func
(paren
id|page
comma
id|blocksize
comma
l_int|0
)paren
suffix:semicolon
id|head
op_assign
id|page_buffers
c_func
(paren
id|page
)paren
suffix:semicolon
id|bbits
op_assign
id|inode-&gt;i_blkbits
suffix:semicolon
id|block
op_assign
(paren
id|sector_t
)paren
id|page-&gt;index
op_lshift
(paren
id|PAGE_CACHE_SHIFT
op_minus
id|bbits
)paren
suffix:semicolon
r_for
c_loop
(paren
id|bh
op_assign
id|head
comma
id|block_start
op_assign
l_int|0
suffix:semicolon
id|bh
op_ne
id|head
op_logical_or
op_logical_neg
id|block_start
suffix:semicolon
id|block
op_increment
comma
id|block_start
op_assign
id|block_end
comma
id|bh
op_assign
id|bh-&gt;b_this_page
)paren
(brace
id|block_end
op_assign
id|block_start
op_plus
id|blocksize
suffix:semicolon
r_if
c_cond
(paren
id|block_end
op_le
id|from
op_logical_or
id|block_start
op_ge
id|to
)paren
(brace
r_if
c_cond
(paren
id|PageUptodate
c_func
(paren
id|page
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|bh
)paren
)paren
id|set_buffer_uptodate
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|buffer_new
c_func
(paren
id|bh
)paren
)paren
id|clear_buffer_new
c_func
(paren
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buffer_mapped
c_func
(paren
id|bh
)paren
)paren
(brace
id|err
op_assign
id|get_block
c_func
(paren
id|inode
comma
id|block
comma
id|bh
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|buffer_new
c_func
(paren
id|bh
)paren
)paren
(brace
id|clear_buffer_new
c_func
(paren
id|bh
)paren
suffix:semicolon
id|unmap_underlying_metadata
c_func
(paren
id|bh-&gt;b_bdev
comma
id|bh-&gt;b_blocknr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PageUptodate
c_func
(paren
id|page
)paren
)paren
(brace
id|set_buffer_uptodate
c_func
(paren
id|bh
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|block_end
OG
id|to
op_logical_or
id|block_start
OL
id|from
)paren
(brace
r_void
op_star
id|kaddr
suffix:semicolon
id|kaddr
op_assign
id|kmap_atomic
c_func
(paren
id|page
comma
id|KM_USER0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|block_end
OG
id|to
)paren
id|memset
c_func
(paren
id|kaddr
op_plus
id|to
comma
l_int|0
comma
id|block_end
op_minus
id|to
)paren
suffix:semicolon
r_if
c_cond
(paren
id|block_start
OL
id|from
)paren
id|memset
c_func
(paren
id|kaddr
op_plus
id|block_start
comma
l_int|0
comma
id|from
op_minus
id|block_start
)paren
suffix:semicolon
id|flush_dcache_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|kunmap_atomic
c_func
(paren
id|kaddr
comma
id|KM_USER0
)paren
suffix:semicolon
)brace
r_continue
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|PageUptodate
c_func
(paren
id|page
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|bh
)paren
)paren
id|set_buffer_uptodate
c_func
(paren
id|bh
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|bh
)paren
op_logical_and
op_logical_neg
id|buffer_delay
c_func
(paren
id|bh
)paren
op_logical_and
(paren
id|block_start
template_param
id|to
)paren
)paren
(brace
id|ll_rw_block
c_func
(paren
id|READ
comma
l_int|1
comma
op_amp
id|bh
)paren
suffix:semicolon
op_star
id|wait_bh
op_increment
op_assign
id|bh
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * If we issued read requests - let them complete.&n;&t; */
r_while
c_loop
(paren
id|wait_bh
OG
id|wait
)paren
(brace
id|wait_on_buffer
c_func
(paren
op_star
op_decrement
id|wait_bh
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
op_star
id|wait_bh
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
id|out
suffix:colon
multiline_comment|/*&n;&t; * Zero out any newly allocated blocks to avoid exposing stale&n;&t; * data.  If BH_New is set, we know that the block was newly&n;&t; * allocated in the above loop.&n;&t; */
id|bh
op_assign
id|head
suffix:semicolon
id|block_start
op_assign
l_int|0
suffix:semicolon
r_do
(brace
id|block_end
op_assign
id|block_start
op_plus
id|blocksize
suffix:semicolon
r_if
c_cond
(paren
id|block_end
op_le
id|from
)paren
r_goto
id|next_bh
suffix:semicolon
r_if
c_cond
(paren
id|block_start
op_ge
id|to
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|buffer_new
c_func
(paren
id|bh
)paren
)paren
(brace
r_void
op_star
id|kaddr
suffix:semicolon
id|clear_buffer_new
c_func
(paren
id|bh
)paren
suffix:semicolon
id|kaddr
op_assign
id|kmap_atomic
c_func
(paren
id|page
comma
id|KM_USER0
)paren
suffix:semicolon
id|memset
c_func
(paren
id|kaddr
op_plus
id|block_start
comma
l_int|0
comma
id|bh-&gt;b_size
)paren
suffix:semicolon
id|kunmap_atomic
c_func
(paren
id|kaddr
comma
id|KM_USER0
)paren
suffix:semicolon
id|set_buffer_uptodate
c_func
(paren
id|bh
)paren
suffix:semicolon
id|mark_buffer_dirty
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
id|next_bh
suffix:colon
id|block_start
op_assign
id|block_end
suffix:semicolon
id|bh
op_assign
id|bh-&gt;b_this_page
suffix:semicolon
)brace
r_while
c_loop
(paren
id|bh
op_ne
id|head
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|function|__block_commit_write
r_static
r_int
id|__block_commit_write
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|page
op_star
id|page
comma
r_int
id|from
comma
r_int
id|to
)paren
(brace
r_int
id|block_start
comma
id|block_end
suffix:semicolon
r_int
id|partial
op_assign
l_int|0
suffix:semicolon
r_int
id|blocksize
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
comma
op_star
id|head
suffix:semicolon
id|blocksize
op_assign
l_int|1
op_lshift
id|inode-&gt;i_blkbits
suffix:semicolon
r_for
c_loop
(paren
id|bh
op_assign
id|head
op_assign
id|page_buffers
c_func
(paren
id|page
)paren
comma
id|block_start
op_assign
l_int|0
suffix:semicolon
id|bh
op_ne
id|head
op_logical_or
op_logical_neg
id|block_start
suffix:semicolon
id|block_start
op_assign
id|block_end
comma
id|bh
op_assign
id|bh-&gt;b_this_page
)paren
(brace
id|block_end
op_assign
id|block_start
op_plus
id|blocksize
suffix:semicolon
r_if
c_cond
(paren
id|block_end
op_le
id|from
op_logical_or
id|block_start
op_ge
id|to
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|bh
)paren
)paren
id|partial
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|set_buffer_uptodate
c_func
(paren
id|bh
)paren
suffix:semicolon
id|mark_buffer_dirty
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * If this is a partial write which happened to make all buffers&n;&t; * uptodate then we can optimize away a bogus readpage() for&n;&t; * the next read(). Here we &squot;discover&squot; whether the page went&n;&t; * uptodate as a result of this (potentially partial) write.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|partial
)paren
id|SetPageUptodate
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Generic &quot;read page&quot; function for block devices that have the normal&n; * get_block functionality. This is most of the block device filesystems.&n; * Reads the page asynchronously --- the unlock_buffer() and&n; * set/clear_buffer_uptodate() functions propagate buffer state into the&n; * page struct once IO has completed.&n; */
DECL|function|block_read_full_page
r_int
id|block_read_full_page
c_func
(paren
r_struct
id|page
op_star
id|page
comma
id|get_block_t
op_star
id|get_block
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|page-&gt;mapping-&gt;host
suffix:semicolon
id|sector_t
id|iblock
comma
id|lblock
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
comma
op_star
id|head
comma
op_star
id|arr
(braket
id|MAX_BUF_PER_PAGE
)braket
suffix:semicolon
r_int
r_int
id|blocksize
suffix:semicolon
r_int
id|nr
comma
id|i
suffix:semicolon
r_int
id|fully_mapped
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|PageLocked
c_func
(paren
id|page
)paren
)paren
id|PAGE_BUG
c_func
(paren
id|page
)paren
suffix:semicolon
id|blocksize
op_assign
l_int|1
op_lshift
id|inode-&gt;i_blkbits
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page_has_buffers
c_func
(paren
id|page
)paren
)paren
id|create_empty_buffers
c_func
(paren
id|page
comma
id|blocksize
comma
l_int|0
)paren
suffix:semicolon
id|head
op_assign
id|page_buffers
c_func
(paren
id|page
)paren
suffix:semicolon
id|iblock
op_assign
(paren
id|sector_t
)paren
id|page-&gt;index
op_lshift
(paren
id|PAGE_CACHE_SHIFT
op_minus
id|inode-&gt;i_blkbits
)paren
suffix:semicolon
id|lblock
op_assign
(paren
id|i_size_read
c_func
(paren
id|inode
)paren
op_plus
id|blocksize
op_minus
l_int|1
)paren
op_rshift
id|inode-&gt;i_blkbits
suffix:semicolon
id|bh
op_assign
id|head
suffix:semicolon
id|nr
op_assign
l_int|0
suffix:semicolon
id|i
op_assign
l_int|0
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|buffer_uptodate
c_func
(paren
id|bh
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buffer_mapped
c_func
(paren
id|bh
)paren
)paren
(brace
id|fully_mapped
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|iblock
OL
id|lblock
)paren
(brace
r_if
c_cond
(paren
id|get_block
c_func
(paren
id|inode
comma
id|iblock
comma
id|bh
comma
l_int|0
)paren
)paren
id|SetPageError
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|buffer_mapped
c_func
(paren
id|bh
)paren
)paren
(brace
r_void
op_star
id|kaddr
op_assign
id|kmap_atomic
c_func
(paren
id|page
comma
id|KM_USER0
)paren
suffix:semicolon
id|memset
c_func
(paren
id|kaddr
op_plus
id|i
op_star
id|blocksize
comma
l_int|0
comma
id|blocksize
)paren
suffix:semicolon
id|flush_dcache_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|kunmap_atomic
c_func
(paren
id|kaddr
comma
id|KM_USER0
)paren
suffix:semicolon
id|set_buffer_uptodate
c_func
(paren
id|bh
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * get_block() might have updated the buffer&n;&t;&t;&t; * synchronously&n;&t;&t;&t; */
r_if
c_cond
(paren
id|buffer_uptodate
c_func
(paren
id|bh
)paren
)paren
r_continue
suffix:semicolon
)brace
id|arr
(braket
id|nr
op_increment
)braket
op_assign
id|bh
suffix:semicolon
)brace
r_while
c_loop
(paren
id|i
op_increment
comma
id|iblock
op_increment
comma
(paren
id|bh
op_assign
id|bh-&gt;b_this_page
)paren
op_ne
id|head
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fully_mapped
)paren
id|SetPageMappedToDisk
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|nr
)paren
(brace
multiline_comment|/*&n;&t;&t; * All buffers are uptodate - we can set the page uptodate&n;&t;&t; * as well. But not if get_block() returned an error.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|PageError
c_func
(paren
id|page
)paren
)paren
id|SetPageUptodate
c_func
(paren
id|page
)paren
suffix:semicolon
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Stage two: lock the buffers */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr
suffix:semicolon
id|i
op_increment
)paren
(brace
id|bh
op_assign
id|arr
(braket
id|i
)braket
suffix:semicolon
id|lock_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
id|mark_buffer_async_read
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Stage 3: start the IO.  Check for uptodateness&n;&t; * inside the buffer lock in case another process reading&n;&t; * the underlying blockdev brought it uptodate (the sct fix).&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr
suffix:semicolon
id|i
op_increment
)paren
(brace
id|bh
op_assign
id|arr
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|buffer_uptodate
c_func
(paren
id|bh
)paren
)paren
id|end_buffer_async_read
c_func
(paren
id|bh
comma
l_int|1
)paren
suffix:semicolon
r_else
id|submit_bh
c_func
(paren
id|READ
comma
id|bh
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* utility function for filesystems that need to do work on expanding&n; * truncates.  Uses prepare/commit_write to allow the filesystem to&n; * deal with the hole.  &n; */
DECL|function|generic_cont_expand
r_int
id|generic_cont_expand
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
id|loff_t
id|size
)paren
(brace
r_struct
id|address_space
op_star
id|mapping
op_assign
id|inode-&gt;i_mapping
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
r_int
r_int
id|index
comma
id|offset
comma
id|limit
suffix:semicolon
r_int
id|err
suffix:semicolon
id|err
op_assign
op_minus
id|EFBIG
suffix:semicolon
id|limit
op_assign
id|current-&gt;rlim
(braket
id|RLIMIT_FSIZE
)braket
dot
id|rlim_cur
suffix:semicolon
r_if
c_cond
(paren
id|limit
op_ne
id|RLIM_INFINITY
op_logical_and
id|size
OG
(paren
id|loff_t
)paren
id|limit
)paren
(brace
id|send_sig
c_func
(paren
id|SIGXFSZ
comma
id|current
comma
l_int|0
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|size
OG
id|inode-&gt;i_sb-&gt;s_maxbytes
)paren
r_goto
id|out
suffix:semicolon
id|offset
op_assign
(paren
id|size
op_amp
(paren
id|PAGE_CACHE_SIZE
op_minus
l_int|1
)paren
)paren
suffix:semicolon
multiline_comment|/* Within page */
multiline_comment|/* ugh.  in prepare/commit_write, if from==to==start of block, we &n;&t;** skip the prepare.  make sure we never send an offset for the start&n;&t;** of a block&n;&t;*/
r_if
c_cond
(paren
(paren
id|offset
op_amp
(paren
id|inode-&gt;i_sb-&gt;s_blocksize
op_minus
l_int|1
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|offset
op_increment
suffix:semicolon
)brace
id|index
op_assign
id|size
op_rshift
id|PAGE_CACHE_SHIFT
suffix:semicolon
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
id|page
op_assign
id|grab_cache_page
c_func
(paren
id|mapping
comma
id|index
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page
)paren
r_goto
id|out
suffix:semicolon
id|err
op_assign
id|mapping-&gt;a_ops
op_member_access_from_pointer
id|prepare_write
c_func
(paren
l_int|NULL
comma
id|page
comma
id|offset
comma
id|offset
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|err
)paren
(brace
id|err
op_assign
id|mapping-&gt;a_ops
op_member_access_from_pointer
id|commit_write
c_func
(paren
l_int|NULL
comma
id|page
comma
id|offset
comma
id|offset
)paren
suffix:semicolon
)brace
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OG
l_int|0
)paren
id|err
op_assign
l_int|0
suffix:semicolon
id|out
suffix:colon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; * For moronic filesystems that do not allow holes in file.&n; * We may have to extend the file.&n; */
DECL|function|cont_prepare_write
r_int
id|cont_prepare_write
c_func
(paren
r_struct
id|page
op_star
id|page
comma
r_int
id|offset
comma
r_int
id|to
comma
id|get_block_t
op_star
id|get_block
comma
id|loff_t
op_star
id|bytes
)paren
(brace
r_struct
id|address_space
op_star
id|mapping
op_assign
id|page-&gt;mapping
suffix:semicolon
r_struct
id|inode
op_star
id|inode
op_assign
id|mapping-&gt;host
suffix:semicolon
r_struct
id|page
op_star
id|new_page
suffix:semicolon
id|pgoff_t
id|pgpos
suffix:semicolon
r_int
id|status
suffix:semicolon
r_int
id|zerofrom
suffix:semicolon
r_int
id|blocksize
op_assign
l_int|1
op_lshift
id|inode-&gt;i_blkbits
suffix:semicolon
r_void
op_star
id|kaddr
suffix:semicolon
r_while
c_loop
(paren
id|page-&gt;index
OG
(paren
id|pgpos
op_assign
op_star
id|bytes
op_rshift
id|PAGE_CACHE_SHIFT
)paren
)paren
(brace
id|status
op_assign
op_minus
id|ENOMEM
suffix:semicolon
id|new_page
op_assign
id|grab_cache_page
c_func
(paren
id|mapping
comma
id|pgpos
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|new_page
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* we might sleep */
r_if
c_cond
(paren
op_star
id|bytes
op_rshift
id|PAGE_CACHE_SHIFT
op_ne
id|pgpos
)paren
(brace
id|unlock_page
c_func
(paren
id|new_page
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|new_page
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|zerofrom
op_assign
op_star
id|bytes
op_amp
op_complement
id|PAGE_CACHE_MASK
suffix:semicolon
r_if
c_cond
(paren
id|zerofrom
op_amp
(paren
id|blocksize
op_minus
l_int|1
)paren
)paren
(brace
op_star
id|bytes
op_or_assign
(paren
id|blocksize
op_minus
l_int|1
)paren
suffix:semicolon
(paren
op_star
id|bytes
)paren
op_increment
suffix:semicolon
)brace
id|status
op_assign
id|__block_prepare_write
c_func
(paren
id|inode
comma
id|new_page
comma
id|zerofrom
comma
id|PAGE_CACHE_SIZE
comma
id|get_block
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
)paren
r_goto
id|out_unmap
suffix:semicolon
id|kaddr
op_assign
id|kmap_atomic
c_func
(paren
id|new_page
comma
id|KM_USER0
)paren
suffix:semicolon
id|memset
c_func
(paren
id|kaddr
op_plus
id|zerofrom
comma
l_int|0
comma
id|PAGE_CACHE_SIZE
op_minus
id|zerofrom
)paren
suffix:semicolon
id|flush_dcache_page
c_func
(paren
id|new_page
)paren
suffix:semicolon
id|kunmap_atomic
c_func
(paren
id|kaddr
comma
id|KM_USER0
)paren
suffix:semicolon
id|__block_commit_write
c_func
(paren
id|inode
comma
id|new_page
comma
id|zerofrom
comma
id|PAGE_CACHE_SIZE
)paren
suffix:semicolon
id|unlock_page
c_func
(paren
id|new_page
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|new_page
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|page-&gt;index
OL
id|pgpos
)paren
(brace
multiline_comment|/* completely inside the area */
id|zerofrom
op_assign
id|offset
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* page covers the boundary, find the boundary offset */
id|zerofrom
op_assign
op_star
id|bytes
op_amp
op_complement
id|PAGE_CACHE_MASK
suffix:semicolon
multiline_comment|/* if we will expand the thing last block will be filled */
r_if
c_cond
(paren
id|to
OG
id|zerofrom
op_logical_and
(paren
id|zerofrom
op_amp
(paren
id|blocksize
op_minus
l_int|1
)paren
)paren
)paren
(brace
op_star
id|bytes
op_or_assign
(paren
id|blocksize
op_minus
l_int|1
)paren
suffix:semicolon
(paren
op_star
id|bytes
)paren
op_increment
suffix:semicolon
)brace
multiline_comment|/* starting below the boundary? Nothing to zero out */
r_if
c_cond
(paren
id|offset
op_le
id|zerofrom
)paren
id|zerofrom
op_assign
id|offset
suffix:semicolon
)brace
id|status
op_assign
id|__block_prepare_write
c_func
(paren
id|inode
comma
id|page
comma
id|zerofrom
comma
id|to
comma
id|get_block
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
)paren
r_goto
id|out1
suffix:semicolon
r_if
c_cond
(paren
id|zerofrom
OL
id|offset
)paren
(brace
id|kaddr
op_assign
id|kmap_atomic
c_func
(paren
id|page
comma
id|KM_USER0
)paren
suffix:semicolon
id|memset
c_func
(paren
id|kaddr
op_plus
id|zerofrom
comma
l_int|0
comma
id|offset
op_minus
id|zerofrom
)paren
suffix:semicolon
id|flush_dcache_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|kunmap_atomic
c_func
(paren
id|kaddr
comma
id|KM_USER0
)paren
suffix:semicolon
id|__block_commit_write
c_func
(paren
id|inode
comma
id|page
comma
id|zerofrom
comma
id|offset
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
id|out1
suffix:colon
id|ClearPageUptodate
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
id|status
suffix:semicolon
id|out_unmap
suffix:colon
id|ClearPageUptodate
c_func
(paren
id|new_page
)paren
suffix:semicolon
id|unlock_page
c_func
(paren
id|new_page
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|new_page
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|status
suffix:semicolon
)brace
DECL|function|block_prepare_write
r_int
id|block_prepare_write
c_func
(paren
r_struct
id|page
op_star
id|page
comma
r_int
id|from
comma
r_int
id|to
comma
id|get_block_t
op_star
id|get_block
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|page-&gt;mapping-&gt;host
suffix:semicolon
r_int
id|err
op_assign
id|__block_prepare_write
c_func
(paren
id|inode
comma
id|page
comma
id|from
comma
id|to
comma
id|get_block
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
id|ClearPageUptodate
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|function|block_commit_write
r_int
id|block_commit_write
c_func
(paren
r_struct
id|page
op_star
id|page
comma
r_int
id|from
comma
r_int
id|to
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|page-&gt;mapping-&gt;host
suffix:semicolon
id|__block_commit_write
c_func
(paren
id|inode
comma
id|page
comma
id|from
comma
id|to
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|generic_commit_write
r_int
id|generic_commit_write
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_struct
id|page
op_star
id|page
comma
r_int
id|from
comma
r_int
id|to
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|page-&gt;mapping-&gt;host
suffix:semicolon
id|loff_t
id|pos
op_assign
(paren
(paren
id|loff_t
)paren
id|page-&gt;index
op_lshift
id|PAGE_CACHE_SHIFT
)paren
op_plus
id|to
suffix:semicolon
id|__block_commit_write
c_func
(paren
id|inode
comma
id|page
comma
id|from
comma
id|to
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * No need to use i_size_read() here, the i_size&n;&t; * cannot change under us because we hold i_sem.&n;&t; */
r_if
c_cond
(paren
id|pos
OG
id|inode-&gt;i_size
)paren
(brace
id|i_size_write
c_func
(paren
id|inode
comma
id|pos
)paren
suffix:semicolon
id|mark_inode_dirty
c_func
(paren
id|inode
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * nobh_prepare_write()&squot;s prereads are special: the buffer_heads are freed&n; * immediately, while under the page lock.  So it needs a special end_io&n; * handler which does not touch the bh after unlocking it.&n; *&n; * Note: unlock_buffer() sort-of does touch the bh after unlocking it, but&n; * a race there is benign: unlock_buffer() only use the bh&squot;s address for&n; * hashing after unlocking the buffer, so it doesn&squot;t actually touch the bh&n; * itself.&n; */
DECL|function|end_buffer_read_nobh
r_static
r_void
id|end_buffer_read_nobh
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
comma
r_int
id|uptodate
)paren
(brace
r_if
c_cond
(paren
id|uptodate
)paren
(brace
id|set_buffer_uptodate
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* This happens, due to failed READA attempts. */
id|clear_buffer_uptodate
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
id|unlock_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * On entry, the page is fully not uptodate.&n; * On exit the page is fully uptodate in the areas outside (from,to)&n; */
DECL|function|nobh_prepare_write
r_int
id|nobh_prepare_write
c_func
(paren
r_struct
id|page
op_star
id|page
comma
r_int
id|from
comma
r_int
id|to
comma
id|get_block_t
op_star
id|get_block
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|page-&gt;mapping-&gt;host
suffix:semicolon
r_const
r_int
id|blkbits
op_assign
id|inode-&gt;i_blkbits
suffix:semicolon
r_const
r_int
id|blocksize
op_assign
l_int|1
op_lshift
id|blkbits
suffix:semicolon
r_struct
id|buffer_head
id|map_bh
suffix:semicolon
r_struct
id|buffer_head
op_star
id|read_bh
(braket
id|MAX_BUF_PER_PAGE
)braket
suffix:semicolon
r_int
id|block_in_page
suffix:semicolon
r_int
id|block_start
suffix:semicolon
id|sector_t
id|block_in_file
suffix:semicolon
r_char
op_star
id|kaddr
suffix:semicolon
r_int
id|nr_reads
op_assign
l_int|0
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_int
id|is_mapped_to_disk
op_assign
l_int|1
suffix:semicolon
r_int
id|dirtied_it
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|PageMappedToDisk
c_func
(paren
id|page
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|block_in_file
op_assign
(paren
id|sector_t
)paren
id|page-&gt;index
op_lshift
(paren
id|PAGE_CACHE_SHIFT
op_minus
id|blkbits
)paren
suffix:semicolon
id|map_bh.b_page
op_assign
id|page
suffix:semicolon
multiline_comment|/*&n;&t; * We loop across all blocks in the page, whether or not they are&n;&t; * part of the affected region.  This is so we can discover if the&n;&t; * page is fully mapped-to-disk.&n;&t; */
r_for
c_loop
(paren
id|block_start
op_assign
l_int|0
comma
id|block_in_page
op_assign
l_int|0
suffix:semicolon
id|block_start
OL
id|PAGE_CACHE_SIZE
suffix:semicolon
id|block_in_page
op_increment
comma
id|block_start
op_add_assign
id|blocksize
)paren
(brace
r_int
id|block_end
op_assign
id|block_start
op_plus
id|blocksize
suffix:semicolon
r_int
id|create
suffix:semicolon
id|map_bh.b_state
op_assign
l_int|0
suffix:semicolon
id|create
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|block_start
op_ge
id|to
)paren
id|create
op_assign
l_int|0
suffix:semicolon
id|ret
op_assign
id|get_block
c_func
(paren
id|inode
comma
id|block_in_file
op_plus
id|block_in_page
comma
op_amp
id|map_bh
comma
id|create
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_goto
id|failed
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buffer_mapped
c_func
(paren
op_amp
id|map_bh
)paren
)paren
id|is_mapped_to_disk
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|buffer_new
c_func
(paren
op_amp
id|map_bh
)paren
)paren
id|unmap_underlying_metadata
c_func
(paren
id|map_bh.b_bdev
comma
id|map_bh.b_blocknr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PageUptodate
c_func
(paren
id|page
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|buffer_new
c_func
(paren
op_amp
id|map_bh
)paren
op_logical_or
op_logical_neg
id|buffer_mapped
c_func
(paren
op_amp
id|map_bh
)paren
)paren
(brace
id|kaddr
op_assign
id|kmap_atomic
c_func
(paren
id|page
comma
id|KM_USER0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|block_start
OL
id|from
)paren
(brace
id|memset
c_func
(paren
id|kaddr
op_plus
id|block_start
comma
l_int|0
comma
id|from
op_minus
id|block_start
)paren
suffix:semicolon
id|dirtied_it
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|block_end
OG
id|to
)paren
(brace
id|memset
c_func
(paren
id|kaddr
op_plus
id|to
comma
l_int|0
comma
id|block_end
op_minus
id|to
)paren
suffix:semicolon
id|dirtied_it
op_assign
l_int|1
suffix:semicolon
)brace
id|flush_dcache_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|kunmap_atomic
c_func
(paren
id|kaddr
comma
id|KM_USER0
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|buffer_uptodate
c_func
(paren
op_amp
id|map_bh
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/* reiserfs does this */
r_if
c_cond
(paren
id|block_start
template_param
id|to
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
op_assign
id|alloc_buffer_head
c_func
(paren
id|GFP_NOFS
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bh
)paren
(brace
id|ret
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|failed
suffix:semicolon
)brace
id|bh-&gt;b_state
op_assign
id|map_bh.b_state
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|bh-&gt;b_count
comma
l_int|0
)paren
suffix:semicolon
id|bh-&gt;b_this_page
op_assign
l_int|0
suffix:semicolon
id|bh-&gt;b_page
op_assign
id|page
suffix:semicolon
id|bh-&gt;b_blocknr
op_assign
id|map_bh.b_blocknr
suffix:semicolon
id|bh-&gt;b_size
op_assign
id|blocksize
suffix:semicolon
id|bh-&gt;b_data
op_assign
(paren
r_char
op_star
)paren
(paren
r_int
)paren
id|block_start
suffix:semicolon
id|bh-&gt;b_bdev
op_assign
id|map_bh.b_bdev
suffix:semicolon
id|bh-&gt;b_private
op_assign
l_int|NULL
suffix:semicolon
id|read_bh
(braket
id|nr_reads
op_increment
)braket
op_assign
id|bh
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|nr_reads
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
multiline_comment|/*&n;&t;&t; * The page is locked, so these buffers are protected from&n;&t;&t; * any VM or truncate activity.  Hence we don&squot;t need to care&n;&t;&t; * for the buffer_head refcounts.&n;&t;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr_reads
suffix:semicolon
id|i
op_increment
)paren
(brace
id|bh
op_assign
id|read_bh
(braket
id|i
)braket
suffix:semicolon
id|lock_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
id|bh-&gt;b_end_io
op_assign
id|end_buffer_read_nobh
suffix:semicolon
id|submit_bh
c_func
(paren
id|READ
comma
id|bh
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr_reads
suffix:semicolon
id|i
op_increment
)paren
(brace
id|bh
op_assign
id|read_bh
(braket
id|i
)braket
suffix:semicolon
id|wait_on_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|bh
)paren
)paren
id|ret
op_assign
op_minus
id|EIO
suffix:semicolon
id|free_buffer_head
c_func
(paren
id|bh
)paren
suffix:semicolon
id|read_bh
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ret
)paren
r_goto
id|failed
suffix:semicolon
)brace
r_if
c_cond
(paren
id|is_mapped_to_disk
)paren
id|SetPageMappedToDisk
c_func
(paren
id|page
)paren
suffix:semicolon
id|SetPageUptodate
c_func
(paren
id|page
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Setting the page dirty here isn&squot;t necessary for the prepare_write&n;&t; * function - commit_write will do that.  But if/when this function is&n;&t; * used within the pagefault handler to ensure that all mmapped pages&n;&t; * have backing space in the filesystem, we will need to dirty the page&n;&t; * if its contents were altered.&n;&t; */
r_if
c_cond
(paren
id|dirtied_it
)paren
id|set_page_dirty
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|failed
suffix:colon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr_reads
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|read_bh
(braket
id|i
)braket
)paren
id|free_buffer_head
c_func
(paren
id|read_bh
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Error recovery is pretty slack.  Clear the page and mark it dirty&n;&t; * so we&squot;ll later zero out any blocks which _were_ allocated.&n;&t; */
id|kaddr
op_assign
id|kmap_atomic
c_func
(paren
id|page
comma
id|KM_USER0
)paren
suffix:semicolon
id|memset
c_func
(paren
id|kaddr
comma
l_int|0
comma
id|PAGE_CACHE_SIZE
)paren
suffix:semicolon
id|kunmap_atomic
c_func
(paren
id|kaddr
comma
id|KM_USER0
)paren
suffix:semicolon
id|SetPageUptodate
c_func
(paren
id|page
)paren
suffix:semicolon
id|set_page_dirty
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|variable|nobh_prepare_write
id|EXPORT_SYMBOL
c_func
(paren
id|nobh_prepare_write
)paren
suffix:semicolon
DECL|function|nobh_commit_write
r_int
id|nobh_commit_write
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_struct
id|page
op_star
id|page
comma
r_int
id|from
comma
r_int
id|to
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|page-&gt;mapping-&gt;host
suffix:semicolon
id|loff_t
id|pos
op_assign
(paren
(paren
id|loff_t
)paren
id|page-&gt;index
op_lshift
id|PAGE_CACHE_SHIFT
)paren
op_plus
id|to
suffix:semicolon
id|set_page_dirty
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pos
OG
id|inode-&gt;i_size
)paren
(brace
id|i_size_write
c_func
(paren
id|inode
comma
id|pos
)paren
suffix:semicolon
id|mark_inode_dirty
c_func
(paren
id|inode
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|nobh_commit_write
id|EXPORT_SYMBOL
c_func
(paren
id|nobh_commit_write
)paren
suffix:semicolon
multiline_comment|/*&n; * This function assumes that -&gt;prepare_write() uses nobh_prepare_write().&n; */
DECL|function|nobh_truncate_page
r_int
id|nobh_truncate_page
c_func
(paren
r_struct
id|address_space
op_star
id|mapping
comma
id|loff_t
id|from
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|mapping-&gt;host
suffix:semicolon
r_int
id|blocksize
op_assign
l_int|1
op_lshift
id|inode-&gt;i_blkbits
suffix:semicolon
id|pgoff_t
id|index
op_assign
id|from
op_rshift
id|PAGE_CACHE_SHIFT
suffix:semicolon
r_int
id|offset
op_assign
id|from
op_amp
(paren
id|PAGE_CACHE_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
r_int
id|to
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
r_struct
id|address_space_operations
op_star
id|a_ops
op_assign
id|mapping-&gt;a_ops
suffix:semicolon
r_char
op_star
id|kaddr
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|offset
op_amp
(paren
id|blocksize
op_minus
l_int|1
)paren
)paren
op_eq
l_int|0
)paren
r_goto
id|out
suffix:semicolon
id|ret
op_assign
op_minus
id|ENOMEM
suffix:semicolon
id|page
op_assign
id|grab_cache_page
c_func
(paren
id|mapping
comma
id|index
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page
)paren
r_goto
id|out
suffix:semicolon
id|to
op_assign
(paren
id|offset
op_plus
id|blocksize
)paren
op_amp
op_complement
(paren
id|blocksize
op_minus
l_int|1
)paren
suffix:semicolon
id|ret
op_assign
id|a_ops
op_member_access_from_pointer
id|prepare_write
c_func
(paren
l_int|NULL
comma
id|page
comma
id|offset
comma
id|to
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
id|kaddr
op_assign
id|kmap_atomic
c_func
(paren
id|page
comma
id|KM_USER0
)paren
suffix:semicolon
id|memset
c_func
(paren
id|kaddr
op_plus
id|offset
comma
l_int|0
comma
id|PAGE_CACHE_SIZE
op_minus
id|offset
)paren
suffix:semicolon
id|flush_dcache_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|kunmap_atomic
c_func
(paren
id|kaddr
comma
id|KM_USER0
)paren
suffix:semicolon
id|set_page_dirty
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|ret
suffix:semicolon
)brace
DECL|variable|nobh_truncate_page
id|EXPORT_SYMBOL
c_func
(paren
id|nobh_truncate_page
)paren
suffix:semicolon
DECL|function|block_truncate_page
r_int
id|block_truncate_page
c_func
(paren
r_struct
id|address_space
op_star
id|mapping
comma
id|loff_t
id|from
comma
id|get_block_t
op_star
id|get_block
)paren
(brace
id|pgoff_t
id|index
op_assign
id|from
op_rshift
id|PAGE_CACHE_SHIFT
suffix:semicolon
r_int
id|offset
op_assign
id|from
op_amp
(paren
id|PAGE_CACHE_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
r_int
id|blocksize
suffix:semicolon
id|pgoff_t
id|iblock
suffix:semicolon
r_int
id|length
comma
id|pos
suffix:semicolon
r_struct
id|inode
op_star
id|inode
op_assign
id|mapping-&gt;host
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
r_void
op_star
id|kaddr
suffix:semicolon
r_int
id|err
suffix:semicolon
id|blocksize
op_assign
l_int|1
op_lshift
id|inode-&gt;i_blkbits
suffix:semicolon
id|length
op_assign
id|offset
op_amp
(paren
id|blocksize
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Block boundary? Nothing to do */
r_if
c_cond
(paren
op_logical_neg
id|length
)paren
r_return
l_int|0
suffix:semicolon
id|length
op_assign
id|blocksize
op_minus
id|length
suffix:semicolon
id|iblock
op_assign
id|index
op_lshift
(paren
id|PAGE_CACHE_SHIFT
op_minus
id|inode-&gt;i_blkbits
)paren
suffix:semicolon
id|page
op_assign
id|grab_cache_page
c_func
(paren
id|mapping
comma
id|index
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page_has_buffers
c_func
(paren
id|page
)paren
)paren
id|create_empty_buffers
c_func
(paren
id|page
comma
id|blocksize
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Find the buffer that contains &quot;offset&quot; */
id|bh
op_assign
id|page_buffers
c_func
(paren
id|page
)paren
suffix:semicolon
id|pos
op_assign
id|blocksize
suffix:semicolon
r_while
c_loop
(paren
id|offset
op_ge
id|pos
)paren
(brace
id|bh
op_assign
id|bh-&gt;b_this_page
suffix:semicolon
id|iblock
op_increment
suffix:semicolon
id|pos
op_add_assign
id|blocksize
suffix:semicolon
)brace
id|err
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buffer_mapped
c_func
(paren
id|bh
)paren
)paren
(brace
id|err
op_assign
id|get_block
c_func
(paren
id|inode
comma
id|iblock
comma
id|bh
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|unlock
suffix:semicolon
multiline_comment|/* unmapped? It&squot;s a hole - nothing to do */
r_if
c_cond
(paren
op_logical_neg
id|buffer_mapped
c_func
(paren
id|bh
)paren
)paren
r_goto
id|unlock
suffix:semicolon
)brace
multiline_comment|/* Ok, it&squot;s mapped. Make sure it&squot;s up-to-date */
r_if
c_cond
(paren
id|PageUptodate
c_func
(paren
id|page
)paren
)paren
id|set_buffer_uptodate
c_func
(paren
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|bh
)paren
op_logical_and
op_logical_neg
id|buffer_delay
c_func
(paren
id|bh
)paren
)paren
(brace
id|err
op_assign
op_minus
id|EIO
suffix:semicolon
id|ll_rw_block
c_func
(paren
id|READ
comma
l_int|1
comma
op_amp
id|bh
)paren
suffix:semicolon
id|wait_on_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
multiline_comment|/* Uhhuh. Read error. Complain and punt. */
r_if
c_cond
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|bh
)paren
)paren
r_goto
id|unlock
suffix:semicolon
)brace
id|kaddr
op_assign
id|kmap_atomic
c_func
(paren
id|page
comma
id|KM_USER0
)paren
suffix:semicolon
id|memset
c_func
(paren
id|kaddr
op_plus
id|offset
comma
l_int|0
comma
id|length
)paren
suffix:semicolon
id|flush_dcache_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|kunmap_atomic
c_func
(paren
id|kaddr
comma
id|KM_USER0
)paren
suffix:semicolon
id|mark_buffer_dirty
c_func
(paren
id|bh
)paren
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
id|unlock
suffix:colon
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; * The generic -&gt;writepage function for buffer-backed address_spaces&n; */
DECL|function|block_write_full_page
r_int
id|block_write_full_page
c_func
(paren
r_struct
id|page
op_star
id|page
comma
id|get_block_t
op_star
id|get_block
comma
r_struct
id|writeback_control
op_star
id|wbc
)paren
(brace
r_struct
id|inode
op_star
r_const
id|inode
op_assign
id|page-&gt;mapping-&gt;host
suffix:semicolon
id|loff_t
id|i_size
op_assign
id|i_size_read
c_func
(paren
id|inode
)paren
suffix:semicolon
r_const
id|pgoff_t
id|end_index
op_assign
id|i_size
op_rshift
id|PAGE_CACHE_SHIFT
suffix:semicolon
r_int
id|offset
suffix:semicolon
r_void
op_star
id|kaddr
suffix:semicolon
multiline_comment|/* Is the page fully inside i_size? */
r_if
c_cond
(paren
id|page-&gt;index
OL
id|end_index
)paren
r_return
id|__block_write_full_page
c_func
(paren
id|inode
comma
id|page
comma
id|get_block
comma
id|wbc
)paren
suffix:semicolon
multiline_comment|/* Is the page fully outside i_size? (truncate in progress) */
id|offset
op_assign
id|i_size
op_amp
(paren
id|PAGE_CACHE_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|page-&gt;index
op_ge
id|end_index
op_plus
l_int|1
op_logical_or
op_logical_neg
id|offset
)paren
(brace
multiline_comment|/*&n;&t;&t; * The page may have dirty, unmapped buffers.  For example,&n;&t;&t; * they may have been added in ext3_writepage().  Make them&n;&t;&t; * freeable here, so the page does not leak.&n;&t;&t; */
id|block_invalidatepage
c_func
(paren
id|page
comma
l_int|0
)paren
suffix:semicolon
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/* don&squot;t care */
)brace
multiline_comment|/*&n;&t; * The page straddles i_size.  It must be zeroed out on each and every&n;&t; * writepage invocation because it may be mmapped.  &quot;A file is mapped&n;&t; * in multiples of the page size.  For a file that is not a multiple of&n;&t; * the  page size, the remaining memory is zeroed when mapped, and&n;&t; * writes to that region are not written out to the file.&quot;&n;&t; */
id|kaddr
op_assign
id|kmap_atomic
c_func
(paren
id|page
comma
id|KM_USER0
)paren
suffix:semicolon
id|memset
c_func
(paren
id|kaddr
op_plus
id|offset
comma
l_int|0
comma
id|PAGE_CACHE_SIZE
op_minus
id|offset
)paren
suffix:semicolon
id|flush_dcache_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|kunmap_atomic
c_func
(paren
id|kaddr
comma
id|KM_USER0
)paren
suffix:semicolon
r_return
id|__block_write_full_page
c_func
(paren
id|inode
comma
id|page
comma
id|get_block
comma
id|wbc
)paren
suffix:semicolon
)brace
DECL|function|generic_block_bmap
id|sector_t
id|generic_block_bmap
c_func
(paren
r_struct
id|address_space
op_star
id|mapping
comma
id|sector_t
id|block
comma
id|get_block_t
op_star
id|get_block
)paren
(brace
r_struct
id|buffer_head
id|tmp
suffix:semicolon
r_struct
id|inode
op_star
id|inode
op_assign
id|mapping-&gt;host
suffix:semicolon
id|tmp.b_state
op_assign
l_int|0
suffix:semicolon
id|tmp.b_blocknr
op_assign
l_int|0
suffix:semicolon
id|get_block
c_func
(paren
id|inode
comma
id|block
comma
op_amp
id|tmp
comma
l_int|0
)paren
suffix:semicolon
r_return
id|tmp.b_blocknr
suffix:semicolon
)brace
DECL|function|end_bio_bh_io_sync
r_static
r_int
id|end_bio_bh_io_sync
c_func
(paren
r_struct
id|bio
op_star
id|bio
comma
r_int
r_int
id|bytes_done
comma
r_int
id|err
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
op_assign
id|bio-&gt;bi_private
suffix:semicolon
r_if
c_cond
(paren
id|bio-&gt;bi_size
)paren
r_return
l_int|1
suffix:semicolon
id|bh
op_member_access_from_pointer
id|b_end_io
c_func
(paren
id|bh
comma
id|test_bit
c_func
(paren
id|BIO_UPTODATE
comma
op_amp
id|bio-&gt;bi_flags
)paren
)paren
suffix:semicolon
id|bio_put
c_func
(paren
id|bio
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|submit_bh
r_void
id|submit_bh
c_func
(paren
r_int
id|rw
comma
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
r_struct
id|bio
op_star
id|bio
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|buffer_locked
c_func
(paren
id|bh
)paren
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|buffer_mapped
c_func
(paren
id|bh
)paren
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|bh-&gt;b_end_io
)paren
suffix:semicolon
multiline_comment|/* Only clear out a write error when rewriting */
r_if
c_cond
(paren
id|test_set_buffer_req
c_func
(paren
id|bh
)paren
op_logical_and
id|rw
op_eq
id|WRITE
)paren
id|clear_buffer_write_io_error
c_func
(paren
id|bh
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * from here on down, it&squot;s all bio -- do the initial mapping,&n;&t; * submit_bio -&gt; generic_make_request may further map this bio around&n;&t; */
id|bio
op_assign
id|bio_alloc
c_func
(paren
id|GFP_NOIO
comma
l_int|1
)paren
suffix:semicolon
id|bio-&gt;bi_sector
op_assign
id|bh-&gt;b_blocknr
op_star
(paren
id|bh-&gt;b_size
op_rshift
l_int|9
)paren
suffix:semicolon
id|bio-&gt;bi_bdev
op_assign
id|bh-&gt;b_bdev
suffix:semicolon
id|bio-&gt;bi_io_vec
(braket
l_int|0
)braket
dot
id|bv_page
op_assign
id|bh-&gt;b_page
suffix:semicolon
id|bio-&gt;bi_io_vec
(braket
l_int|0
)braket
dot
id|bv_len
op_assign
id|bh-&gt;b_size
suffix:semicolon
id|bio-&gt;bi_io_vec
(braket
l_int|0
)braket
dot
id|bv_offset
op_assign
id|bh_offset
c_func
(paren
id|bh
)paren
suffix:semicolon
id|bio-&gt;bi_vcnt
op_assign
l_int|1
suffix:semicolon
id|bio-&gt;bi_idx
op_assign
l_int|0
suffix:semicolon
id|bio-&gt;bi_size
op_assign
id|bh-&gt;b_size
suffix:semicolon
id|bio-&gt;bi_end_io
op_assign
id|end_bio_bh_io_sync
suffix:semicolon
id|bio-&gt;bi_private
op_assign
id|bh
suffix:semicolon
id|submit_bio
c_func
(paren
id|rw
comma
id|bio
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * ll_rw_block: low-level access to block devices (DEPRECATED)&n; * @rw: whether to %READ or %WRITE or maybe %READA (readahead)&n; * @nr: number of &amp;struct buffer_heads in the array&n; * @bhs: array of pointers to &amp;struct buffer_head&n; *&n; * ll_rw_block() takes an array of pointers to &amp;struct buffer_heads,&n; * and requests an I/O operation on them, either a %READ or a %WRITE.&n; * The third %READA option is described in the documentation for&n; * generic_make_request() which ll_rw_block() calls.&n; *&n; * This function drops any buffer that it cannot get a lock on (with the&n; * BH_Lock state bit), any buffer that appears to be clean when doing a&n; * write request, and any buffer that appears to be up-to-date when doing&n; * read request.  Further it marks as clean buffers that are processed for&n; * writing (the buffer cache won&squot;t assume that they are actually clean until&n; * the buffer gets unlocked).&n; *&n; * ll_rw_block sets b_end_io to simple completion handler that marks&n; * the buffer up-to-date (if approriate), unlocks the buffer and wakes&n; * any waiters. &n; *&n; * All of the buffers must be for the same device, and must also be a&n; * multiple of the current approved size for the device.&n; */
DECL|function|ll_rw_block
r_void
id|ll_rw_block
c_func
(paren
r_int
id|rw
comma
r_int
id|nr
comma
r_struct
id|buffer_head
op_star
id|bhs
(braket
)braket
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
op_assign
id|bhs
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|test_set_buffer_locked
c_func
(paren
id|bh
)paren
)paren
r_continue
suffix:semicolon
id|get_bh
c_func
(paren
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rw
op_eq
id|WRITE
)paren
(brace
id|bh-&gt;b_end_io
op_assign
id|end_buffer_write_sync
suffix:semicolon
r_if
c_cond
(paren
id|test_clear_buffer_dirty
c_func
(paren
id|bh
)paren
)paren
(brace
id|submit_bh
c_func
(paren
id|WRITE
comma
id|bh
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
)brace
r_else
(brace
id|bh-&gt;b_end_io
op_assign
id|end_buffer_read_sync
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|bh
)paren
)paren
(brace
id|submit_bh
c_func
(paren
id|rw
comma
id|bh
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
)brace
id|unlock_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
id|put_bh
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * For a data-integrity writeout, we need to wait upon any in-progress I/O&n; * and then start new I/O and then wait upon it.&n; */
DECL|function|sync_dirty_buffer
r_void
id|sync_dirty_buffer
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
id|WARN_ON
c_func
(paren
id|atomic_read
c_func
(paren
op_amp
id|bh-&gt;b_count
)paren
OL
l_int|1
)paren
suffix:semicolon
id|lock_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|test_clear_buffer_dirty
c_func
(paren
id|bh
)paren
)paren
(brace
id|get_bh
c_func
(paren
id|bh
)paren
suffix:semicolon
id|bh-&gt;b_end_io
op_assign
id|end_buffer_write_sync
suffix:semicolon
id|submit_bh
c_func
(paren
id|WRITE
comma
id|bh
)paren
suffix:semicolon
id|wait_on_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
r_else
(brace
id|unlock_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * try_to_free_buffers() checks if all the buffers on this particular page&n; * are unused, and releases them if so.&n; *&n; * Exclusion against try_to_free_buffers may be obtained by either&n; * locking the page or by holding its mapping&squot;s private_lock.&n; *&n; * If the page is dirty but all the buffers are clean then we need to&n; * be sure to mark the page clean as well.  This is because the page&n; * may be against a block device, and a later reattachment of buffers&n; * to a dirty page will set *all* buffers dirty.  Which would corrupt&n; * filesystem data on the same device.&n; *&n; * The same applies to regular filesystem pages: if all the buffers are&n; * clean then we set the page clean and proceed.  To do that, we require&n; * total exclusion from __set_page_dirty_buffers().  That is obtained with&n; * private_lock.&n; *&n; * try_to_free_buffers() is non-blocking.&n; */
DECL|function|buffer_busy
r_static
r_inline
r_int
id|buffer_busy
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
r_return
id|atomic_read
c_func
(paren
op_amp
id|bh-&gt;b_count
)paren
op_or
(paren
id|bh-&gt;b_state
op_amp
(paren
(paren
l_int|1
op_lshift
id|BH_Dirty
)paren
op_or
(paren
l_int|1
op_lshift
id|BH_Lock
)paren
)paren
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|drop_buffers
id|drop_buffers
c_func
(paren
r_struct
id|page
op_star
id|page
comma
r_struct
id|buffer_head
op_star
op_star
id|buffers_to_free
)paren
(brace
r_struct
id|buffer_head
op_star
id|head
op_assign
id|page_buffers
c_func
(paren
id|page
)paren
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
r_int
id|was_uptodate
op_assign
l_int|1
suffix:semicolon
id|bh
op_assign
id|head
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|buffer_write_io_error
c_func
(paren
id|bh
)paren
)paren
id|set_bit
c_func
(paren
id|AS_EIO
comma
op_amp
id|page-&gt;mapping-&gt;flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buffer_busy
c_func
(paren
id|bh
)paren
)paren
r_goto
id|failed
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|bh
)paren
op_logical_and
op_logical_neg
id|buffer_req
c_func
(paren
id|bh
)paren
)paren
id|was_uptodate
op_assign
l_int|0
suffix:semicolon
id|bh
op_assign
id|bh-&gt;b_this_page
suffix:semicolon
)brace
r_while
c_loop
(paren
id|bh
op_ne
id|head
)paren
suffix:semicolon
r_do
(brace
r_struct
id|buffer_head
op_star
id|next
op_assign
id|bh-&gt;b_this_page
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|bh-&gt;b_assoc_buffers
)paren
)paren
id|__remove_assoc_queue
c_func
(paren
id|bh
)paren
suffix:semicolon
id|bh
op_assign
id|next
suffix:semicolon
)brace
r_while
c_loop
(paren
id|bh
op_ne
id|head
)paren
suffix:semicolon
op_star
id|buffers_to_free
op_assign
id|head
suffix:semicolon
id|__clear_page_buffers
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
id|failed
suffix:colon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|try_to_free_buffers
r_int
id|try_to_free_buffers
c_func
(paren
r_struct
id|page
op_star
id|page
)paren
(brace
r_struct
id|address_space
op_star
r_const
id|mapping
op_assign
id|page-&gt;mapping
suffix:semicolon
r_struct
id|buffer_head
op_star
id|buffers_to_free
op_assign
l_int|NULL
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|PageLocked
c_func
(paren
id|page
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PageWriteback
c_func
(paren
id|page
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|mapping
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* can this still happen? */
id|ret
op_assign
id|drop_buffers
c_func
(paren
id|page
comma
op_amp
id|buffers_to_free
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|spin_lock
c_func
(paren
op_amp
id|mapping-&gt;private_lock
)paren
suffix:semicolon
id|ret
op_assign
id|drop_buffers
c_func
(paren
id|page
comma
op_amp
id|buffers_to_free
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
multiline_comment|/*&n;&t;&t; * If the filesystem writes its buffers by hand (eg ext3)&n;&t;&t; * then we can have clean buffers against a dirty page.  We&n;&t;&t; * clean the page here; otherwise later reattachment of buffers&n;&t;&t; * could encounter a non-uptodate page, which is unresolvable.&n;&t;&t; * This only applies in the rare case where try_to_free_buffers&n;&t;&t; * succeeds but the page is not freed.&n;&t;&t; */
id|clear_page_dirty
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|mapping-&gt;private_lock
)paren
suffix:semicolon
id|out
suffix:colon
r_if
c_cond
(paren
id|buffers_to_free
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
op_assign
id|buffers_to_free
suffix:semicolon
r_do
(brace
r_struct
id|buffer_head
op_star
id|next
op_assign
id|bh-&gt;b_this_page
suffix:semicolon
id|free_buffer_head
c_func
(paren
id|bh
)paren
suffix:semicolon
id|bh
op_assign
id|next
suffix:semicolon
)brace
r_while
c_loop
(paren
id|bh
op_ne
id|buffers_to_free
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|variable|try_to_free_buffers
id|EXPORT_SYMBOL
c_func
(paren
id|try_to_free_buffers
)paren
suffix:semicolon
DECL|function|block_sync_page
r_int
id|block_sync_page
c_func
(paren
r_struct
id|page
op_star
id|page
)paren
(brace
r_struct
id|address_space
op_star
id|mapping
suffix:semicolon
id|smp_mb
c_func
(paren
)paren
suffix:semicolon
id|mapping
op_assign
id|page_mapping
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mapping
)paren
id|blk_run_backing_dev
c_func
(paren
id|mapping-&gt;backing_dev_info
comma
id|page
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * There are no bdflush tunables left.  But distributions are&n; * still running obsolete flush daemons, so we terminate them here.&n; *&n; * Use of bdflush() is deprecated and will be removed in a future kernel.&n; * The `pdflush&squot; kernel threads fully replace bdflush daemons and this call.&n; */
DECL|function|sys_bdflush
id|asmlinkage
r_int
id|sys_bdflush
c_func
(paren
r_int
id|func
comma
r_int
id|data
)paren
(brace
r_static
r_int
id|msg_count
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_ADMIN
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|msg_count
OL
l_int|5
)paren
(brace
id|msg_count
op_increment
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;warning: process `%s&squot; used the obsolete bdflush&quot;
l_string|&quot; system call&bslash;n&quot;
comma
id|current-&gt;comm
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Fix your initscripts?&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|func
op_eq
l_int|1
)paren
id|do_exit
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Buffer-head allocation&n; */
DECL|variable|bh_cachep
r_static
id|kmem_cache_t
op_star
id|bh_cachep
suffix:semicolon
multiline_comment|/*&n; * Once the number of bh&squot;s in the machine exceeds this level, we start&n; * stripping them in writeback.&n; */
DECL|variable|max_buffer_heads
r_static
r_int
id|max_buffer_heads
suffix:semicolon
DECL|variable|buffer_heads_over_limit
r_int
id|buffer_heads_over_limit
suffix:semicolon
DECL|struct|bh_accounting
r_struct
id|bh_accounting
(brace
DECL|member|nr
r_int
id|nr
suffix:semicolon
multiline_comment|/* Number of live bh&squot;s */
DECL|member|ratelimit
r_int
id|ratelimit
suffix:semicolon
multiline_comment|/* Limit cacheline bouncing */
)brace
suffix:semicolon
r_static
id|DEFINE_PER_CPU
c_func
(paren
r_struct
id|bh_accounting
comma
id|bh_accounting
)paren
op_assign
(brace
l_int|0
comma
l_int|0
)brace
suffix:semicolon
DECL|function|recalc_bh_state
r_static
r_void
id|recalc_bh_state
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|tot
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|__get_cpu_var
c_func
(paren
id|bh_accounting
)paren
dot
id|ratelimit
op_increment
OL
l_int|4096
)paren
r_return
suffix:semicolon
id|__get_cpu_var
c_func
(paren
id|bh_accounting
)paren
dot
id|ratelimit
op_assign
l_int|0
suffix:semicolon
id|for_each_cpu
c_func
(paren
id|i
)paren
id|tot
op_add_assign
id|per_cpu
c_func
(paren
id|bh_accounting
comma
id|i
)paren
dot
id|nr
suffix:semicolon
id|buffer_heads_over_limit
op_assign
(paren
id|tot
OG
id|max_buffer_heads
)paren
suffix:semicolon
)brace
DECL|function|alloc_buffer_head
r_struct
id|buffer_head
op_star
id|alloc_buffer_head
c_func
(paren
r_int
id|gfp_flags
)paren
(brace
r_struct
id|buffer_head
op_star
id|ret
op_assign
id|kmem_cache_alloc
c_func
(paren
id|bh_cachep
comma
id|gfp_flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|preempt_disable
c_func
(paren
)paren
suffix:semicolon
id|__get_cpu_var
c_func
(paren
id|bh_accounting
)paren
dot
id|nr
op_increment
suffix:semicolon
id|recalc_bh_state
c_func
(paren
)paren
suffix:semicolon
id|preempt_enable
c_func
(paren
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|variable|alloc_buffer_head
id|EXPORT_SYMBOL
c_func
(paren
id|alloc_buffer_head
)paren
suffix:semicolon
DECL|function|free_buffer_head
r_void
id|free_buffer_head
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
id|BUG_ON
c_func
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|bh-&gt;b_assoc_buffers
)paren
)paren
suffix:semicolon
id|kmem_cache_free
c_func
(paren
id|bh_cachep
comma
id|bh
)paren
suffix:semicolon
id|preempt_disable
c_func
(paren
)paren
suffix:semicolon
id|__get_cpu_var
c_func
(paren
id|bh_accounting
)paren
dot
id|nr
op_decrement
suffix:semicolon
id|recalc_bh_state
c_func
(paren
)paren
suffix:semicolon
id|preempt_enable
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|variable|free_buffer_head
id|EXPORT_SYMBOL
c_func
(paren
id|free_buffer_head
)paren
suffix:semicolon
r_static
r_void
DECL|function|init_buffer_head
id|init_buffer_head
c_func
(paren
r_void
op_star
id|data
comma
id|kmem_cache_t
op_star
id|cachep
comma
r_int
r_int
id|flags
)paren
(brace
r_if
c_cond
(paren
(paren
id|flags
op_amp
(paren
id|SLAB_CTOR_VERIFY
op_or
id|SLAB_CTOR_CONSTRUCTOR
)paren
)paren
op_eq
id|SLAB_CTOR_CONSTRUCTOR
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
op_assign
(paren
r_struct
id|buffer_head
op_star
)paren
id|data
suffix:semicolon
id|memset
c_func
(paren
id|bh
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|bh
)paren
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|bh-&gt;b_assoc_buffers
)paren
suffix:semicolon
)brace
)brace
macro_line|#ifdef CONFIG_HOTPLUG_CPU
DECL|function|buffer_exit_cpu
r_static
r_void
id|buffer_exit_cpu
c_func
(paren
r_int
id|cpu
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|bh_lru
op_star
id|b
op_assign
op_amp
id|per_cpu
c_func
(paren
id|bh_lrus
comma
id|cpu
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|BH_LRU_SIZE
suffix:semicolon
id|i
op_increment
)paren
(brace
id|brelse
c_func
(paren
id|b-&gt;bhs
(braket
id|i
)braket
)paren
suffix:semicolon
id|b-&gt;bhs
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
DECL|function|buffer_cpu_notify
r_static
r_int
id|buffer_cpu_notify
c_func
(paren
r_struct
id|notifier_block
op_star
id|self
comma
r_int
r_int
id|action
comma
r_void
op_star
id|hcpu
)paren
(brace
r_if
c_cond
(paren
id|action
op_eq
id|CPU_DEAD
)paren
id|buffer_exit_cpu
c_func
(paren
(paren
r_int
r_int
)paren
id|hcpu
)paren
suffix:semicolon
r_return
id|NOTIFY_OK
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_HOTPLUG_CPU */
DECL|function|buffer_init
r_void
id|__init
id|buffer_init
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|nrpages
suffix:semicolon
id|bh_cachep
op_assign
id|kmem_cache_create
c_func
(paren
l_string|&quot;buffer_head&quot;
comma
r_sizeof
(paren
r_struct
id|buffer_head
)paren
comma
l_int|0
comma
id|SLAB_PANIC
comma
id|init_buffer_head
comma
l_int|NULL
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ARRAY_SIZE
c_func
(paren
id|bh_wait_queue_heads
)paren
suffix:semicolon
id|i
op_increment
)paren
id|init_waitqueue_head
c_func
(paren
op_amp
id|bh_wait_queue_heads
(braket
id|i
)braket
dot
id|wqh
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Limit the bh occupancy to 10% of ZONE_NORMAL&n;&t; */
id|nrpages
op_assign
(paren
id|nr_free_buffer_pages
c_func
(paren
)paren
op_star
l_int|10
)paren
op_div
l_int|100
suffix:semicolon
id|max_buffer_heads
op_assign
id|nrpages
op_star
(paren
id|PAGE_SIZE
op_div
r_sizeof
(paren
r_struct
id|buffer_head
)paren
)paren
suffix:semicolon
id|hotcpu_notifier
c_func
(paren
id|buffer_cpu_notify
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|variable|__bforget
id|EXPORT_SYMBOL
c_func
(paren
id|__bforget
)paren
suffix:semicolon
DECL|variable|__brelse
id|EXPORT_SYMBOL
c_func
(paren
id|__brelse
)paren
suffix:semicolon
DECL|variable|__wait_on_buffer
id|EXPORT_SYMBOL
c_func
(paren
id|__wait_on_buffer
)paren
suffix:semicolon
DECL|variable|block_commit_write
id|EXPORT_SYMBOL
c_func
(paren
id|block_commit_write
)paren
suffix:semicolon
DECL|variable|block_prepare_write
id|EXPORT_SYMBOL
c_func
(paren
id|block_prepare_write
)paren
suffix:semicolon
DECL|variable|block_read_full_page
id|EXPORT_SYMBOL
c_func
(paren
id|block_read_full_page
)paren
suffix:semicolon
DECL|variable|block_sync_page
id|EXPORT_SYMBOL
c_func
(paren
id|block_sync_page
)paren
suffix:semicolon
DECL|variable|block_truncate_page
id|EXPORT_SYMBOL
c_func
(paren
id|block_truncate_page
)paren
suffix:semicolon
DECL|variable|block_write_full_page
id|EXPORT_SYMBOL
c_func
(paren
id|block_write_full_page
)paren
suffix:semicolon
DECL|variable|buffer_insert_list
id|EXPORT_SYMBOL
c_func
(paren
id|buffer_insert_list
)paren
suffix:semicolon
DECL|variable|cont_prepare_write
id|EXPORT_SYMBOL
c_func
(paren
id|cont_prepare_write
)paren
suffix:semicolon
DECL|variable|end_buffer_async_write
id|EXPORT_SYMBOL
c_func
(paren
id|end_buffer_async_write
)paren
suffix:semicolon
DECL|variable|end_buffer_read_sync
id|EXPORT_SYMBOL
c_func
(paren
id|end_buffer_read_sync
)paren
suffix:semicolon
DECL|variable|end_buffer_write_sync
id|EXPORT_SYMBOL
c_func
(paren
id|end_buffer_write_sync
)paren
suffix:semicolon
DECL|variable|file_fsync
id|EXPORT_SYMBOL
c_func
(paren
id|file_fsync
)paren
suffix:semicolon
DECL|variable|fsync_bdev
id|EXPORT_SYMBOL
c_func
(paren
id|fsync_bdev
)paren
suffix:semicolon
DECL|variable|fsync_buffers_list
id|EXPORT_SYMBOL
c_func
(paren
id|fsync_buffers_list
)paren
suffix:semicolon
DECL|variable|generic_block_bmap
id|EXPORT_SYMBOL
c_func
(paren
id|generic_block_bmap
)paren
suffix:semicolon
DECL|variable|generic_commit_write
id|EXPORT_SYMBOL
c_func
(paren
id|generic_commit_write
)paren
suffix:semicolon
DECL|variable|generic_cont_expand
id|EXPORT_SYMBOL
c_func
(paren
id|generic_cont_expand
)paren
suffix:semicolon
DECL|variable|init_buffer
id|EXPORT_SYMBOL
c_func
(paren
id|init_buffer
)paren
suffix:semicolon
DECL|variable|invalidate_bdev
id|EXPORT_SYMBOL
c_func
(paren
id|invalidate_bdev
)paren
suffix:semicolon
DECL|variable|ll_rw_block
id|EXPORT_SYMBOL
c_func
(paren
id|ll_rw_block
)paren
suffix:semicolon
DECL|variable|mark_buffer_dirty
id|EXPORT_SYMBOL
c_func
(paren
id|mark_buffer_dirty
)paren
suffix:semicolon
DECL|variable|submit_bh
id|EXPORT_SYMBOL
c_func
(paren
id|submit_bh
)paren
suffix:semicolon
DECL|variable|sync_dirty_buffer
id|EXPORT_SYMBOL
c_func
(paren
id|sync_dirty_buffer
)paren
suffix:semicolon
DECL|variable|unlock_buffer
id|EXPORT_SYMBOL
c_func
(paren
id|unlock_buffer
)paren
suffix:semicolon
eof
