multiline_comment|/*&n; * JFFS -- Journaling Flash File System, Linux implementation.&n; *&n; * Copyright (C) 2000  Axis Communications AB.&n; *&n; * Created by Simon Kagstrom &lt;simonk@axis.com&gt;.&n; *&n; * $Id: jffs_proc.c,v 1.5 2001/06/02 14:34:55 dwmw2 Exp $&n; *&n; * This is free software; you can redistribute it and/or modify it&n; * under the terms of the GNU General Public License as published by&n; * the Free Software Foundation; either version 2 of the License, or&n; * (at your option) any later version.&n; *&n; *  Overview:&n; *   This file defines JFFS partition entries in the proc file system.&n; *&n; *  TODO:&n; *   Create some more proc files for different kinds of info, i.e. statistics&n; *   about written and read bytes, number of calls to different routines,&n; *   reports about failures.&n; */
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/jffs.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &quot;jffs_fm.h&quot;
macro_line|#include &quot;jffs_proc.h&quot;
multiline_comment|/*&n; * Structure for a JFFS partition in the system&n; */
DECL|struct|jffs_partition_dir
r_struct
id|jffs_partition_dir
(brace
DECL|member|c
r_struct
id|jffs_control
op_star
id|c
suffix:semicolon
DECL|member|part_root
r_struct
id|proc_dir_entry
op_star
id|part_root
suffix:semicolon
DECL|member|part_info
r_struct
id|proc_dir_entry
op_star
id|part_info
suffix:semicolon
DECL|member|part_layout
r_struct
id|proc_dir_entry
op_star
id|part_layout
suffix:semicolon
DECL|member|next
r_struct
id|jffs_partition_dir
op_star
id|next
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * Structure for top-level entry in &squot;/proc/fs&squot; directory&n; */
DECL|variable|jffs_proc_root
r_struct
id|proc_dir_entry
op_star
id|jffs_proc_root
suffix:semicolon
multiline_comment|/*&n; * Linked list of &squot;jffs_partition_dirs&squot; to help us track&n; * the mounted JFFS partitions in the system&n; */
DECL|variable|jffs_part_dirs
r_static
r_struct
id|jffs_partition_dir
op_star
id|jffs_part_dirs
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n; * Read functions for entries&n; */
r_static
r_int
id|jffs_proc_info_read
c_func
(paren
r_char
op_star
id|page
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|off
comma
r_int
id|count
comma
r_int
op_star
id|eof
comma
r_void
op_star
id|data
)paren
suffix:semicolon
r_static
r_int
id|jffs_proc_layout_read
(paren
r_char
op_star
id|page
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|off
comma
r_int
id|count
comma
r_int
op_star
id|eof
comma
r_void
op_star
id|data
)paren
suffix:semicolon
multiline_comment|/*&n; * Register a JFFS partition directory (called upon mount)&n; */
DECL|function|jffs_register_jffs_proc_dir
r_int
id|jffs_register_jffs_proc_dir
c_func
(paren
id|kdev_t
id|dev
comma
r_struct
id|jffs_control
op_star
id|c
)paren
(brace
r_struct
id|jffs_partition_dir
op_star
id|part_dir
suffix:semicolon
r_struct
id|proc_dir_entry
op_star
id|part_info
op_assign
l_int|0
suffix:semicolon
r_struct
id|proc_dir_entry
op_star
id|part_layout
op_assign
l_int|0
suffix:semicolon
r_struct
id|proc_dir_entry
op_star
id|part_root
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Allocate structure for local JFFS partition table */
r_if
c_cond
(paren
op_logical_neg
(paren
id|part_dir
op_assign
(paren
r_struct
id|jffs_partition_dir
op_star
)paren
id|kmalloc
(paren
r_sizeof
(paren
r_struct
id|jffs_partition_dir
)paren
comma
id|GFP_KERNEL
)paren
)paren
)paren
(brace
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
multiline_comment|/* Create entry for this partition */
r_if
c_cond
(paren
(paren
id|part_root
op_assign
id|create_proc_entry
(paren
id|kdevname
c_func
(paren
id|dev
)paren
comma
id|S_IFDIR
op_or
id|S_IRUGO
op_or
id|S_IXUGO
comma
id|jffs_proc_root
)paren
)paren
)paren
(brace
id|part_root-&gt;read_proc
op_assign
id|jffs_proc_info_read
suffix:semicolon
id|part_root-&gt;data
op_assign
(paren
r_void
op_star
)paren
id|c
suffix:semicolon
)brace
r_else
(brace
id|kfree
(paren
id|part_dir
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
multiline_comment|/* Create entry for &squot;info&squot; file */
r_if
c_cond
(paren
(paren
id|part_info
op_assign
id|create_proc_entry
(paren
l_string|&quot;info&quot;
comma
l_int|0
comma
id|part_root
)paren
)paren
)paren
(brace
id|part_info-&gt;read_proc
op_assign
id|jffs_proc_info_read
suffix:semicolon
id|part_info-&gt;data
op_assign
(paren
r_void
op_star
)paren
id|c
suffix:semicolon
)brace
r_else
(brace
id|remove_proc_entry
(paren
id|part_root-&gt;name
comma
id|jffs_proc_root
)paren
suffix:semicolon
id|kfree
(paren
id|part_dir
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
multiline_comment|/* Create entry for &squot;layout&squot; file */
r_if
c_cond
(paren
(paren
id|part_layout
op_assign
id|create_proc_entry
(paren
l_string|&quot;layout&quot;
comma
l_int|0
comma
id|part_root
)paren
)paren
)paren
(brace
id|part_layout-&gt;read_proc
op_assign
id|jffs_proc_layout_read
suffix:semicolon
id|part_layout-&gt;data
op_assign
(paren
r_void
op_star
)paren
id|c
suffix:semicolon
)brace
r_else
(brace
id|remove_proc_entry
(paren
id|part_info-&gt;name
comma
id|part_root
)paren
suffix:semicolon
id|remove_proc_entry
(paren
id|part_root-&gt;name
comma
id|jffs_proc_root
)paren
suffix:semicolon
id|kfree
(paren
id|part_dir
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
multiline_comment|/* Fill in structure for table and insert in the list */
id|part_dir-&gt;c
op_assign
id|c
suffix:semicolon
id|part_dir-&gt;part_root
op_assign
id|part_root
suffix:semicolon
id|part_dir-&gt;part_info
op_assign
id|part_info
suffix:semicolon
id|part_dir-&gt;part_layout
op_assign
id|part_layout
suffix:semicolon
id|part_dir-&gt;next
op_assign
id|jffs_part_dirs
suffix:semicolon
id|jffs_part_dirs
op_assign
id|part_dir
suffix:semicolon
multiline_comment|/* Return happy */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Unregister a JFFS partition directory (called at umount)&n; */
DECL|function|jffs_unregister_jffs_proc_dir
r_int
id|jffs_unregister_jffs_proc_dir
c_func
(paren
r_struct
id|jffs_control
op_star
id|c
)paren
(brace
r_struct
id|jffs_partition_dir
op_star
id|part_dir
op_assign
id|jffs_part_dirs
suffix:semicolon
r_struct
id|jffs_partition_dir
op_star
id|prev_part_dir
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|part_dir
)paren
(brace
r_if
c_cond
(paren
id|part_dir-&gt;c
op_eq
id|c
)paren
(brace
multiline_comment|/* Remove entries for partition */
id|remove_proc_entry
(paren
id|part_dir-&gt;part_info-&gt;name
comma
id|part_dir-&gt;part_root
)paren
suffix:semicolon
id|remove_proc_entry
(paren
id|part_dir-&gt;part_layout-&gt;name
comma
id|part_dir-&gt;part_root
)paren
suffix:semicolon
id|remove_proc_entry
(paren
id|part_dir-&gt;part_root-&gt;name
comma
id|jffs_proc_root
)paren
suffix:semicolon
multiline_comment|/* Remove entry from list */
r_if
c_cond
(paren
id|prev_part_dir
)paren
id|prev_part_dir-&gt;next
op_assign
id|part_dir-&gt;next
suffix:semicolon
r_else
id|jffs_part_dirs
op_assign
id|part_dir-&gt;next
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Check to see if this is the last one&n;&t;&t;&t; * and remove the entry from &squot;/proc/fs&squot;&n;&t;&t;&t; * if it is.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|jffs_part_dirs
op_eq
id|part_dir-&gt;next
)paren
macro_line|#if LINUX_VERSION_CODE &lt; 0x020300
id|remove_proc_entry
(paren
l_string|&quot;jffs&quot;
comma
op_amp
id|proc_root_fs
)paren
suffix:semicolon
macro_line|#else
id|remove_proc_entry
(paren
l_string|&quot;jffs&quot;
comma
id|proc_root_fs
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Free memory for entry */
id|kfree
c_func
(paren
id|part_dir
)paren
suffix:semicolon
multiline_comment|/* Return happy */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Move to next entry */
id|prev_part_dir
op_assign
id|part_dir
suffix:semicolon
id|part_dir
op_assign
id|part_dir-&gt;next
suffix:semicolon
)brace
multiline_comment|/* Return unhappy */
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Read a JFFS partition&squot;s `info&squot; file&n; */
DECL|function|jffs_proc_info_read
r_static
r_int
id|jffs_proc_info_read
(paren
r_char
op_star
id|page
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|off
comma
r_int
id|count
comma
r_int
op_star
id|eof
comma
r_void
op_star
id|data
)paren
(brace
r_struct
id|jffs_control
op_star
id|c
op_assign
(paren
r_struct
id|jffs_control
op_star
)paren
id|data
suffix:semicolon
r_int
id|len
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Get information on the parition */
id|len
op_add_assign
id|sprintf
(paren
id|page
comma
l_string|&quot;partition size:     %08lX (%u)&bslash;n&quot;
l_string|&quot;sector size:        %08lX (%u)&bslash;n&quot;
l_string|&quot;used size:          %08lX (%u)&bslash;n&quot;
l_string|&quot;dirty size:         %08lX (%u)&bslash;n&quot;
l_string|&quot;free size:          %08lX (%u)&bslash;n&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|c-&gt;fmc-&gt;flash_size
comma
id|c-&gt;fmc-&gt;flash_size
comma
(paren
r_int
r_int
)paren
id|c-&gt;fmc-&gt;sector_size
comma
id|c-&gt;fmc-&gt;sector_size
comma
(paren
r_int
r_int
)paren
id|c-&gt;fmc-&gt;used_size
comma
id|c-&gt;fmc-&gt;used_size
comma
(paren
r_int
r_int
)paren
id|c-&gt;fmc-&gt;dirty_size
comma
id|c-&gt;fmc-&gt;dirty_size
comma
(paren
r_int
r_int
)paren
(paren
id|c-&gt;fmc-&gt;flash_size
op_minus
(paren
id|c-&gt;fmc-&gt;used_size
op_plus
id|c-&gt;fmc-&gt;dirty_size
)paren
)paren
comma
id|c-&gt;fmc-&gt;flash_size
op_minus
(paren
id|c-&gt;fmc-&gt;used_size
op_plus
id|c-&gt;fmc-&gt;dirty_size
)paren
)paren
suffix:semicolon
multiline_comment|/* We&squot;re done */
op_star
id|eof
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Return length */
r_return
id|len
suffix:semicolon
)brace
multiline_comment|/*&n; * Read a JFFS partition&squot;s `layout&squot; file&n; */
DECL|function|jffs_proc_layout_read
r_static
r_int
id|jffs_proc_layout_read
(paren
r_char
op_star
id|page
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|off
comma
r_int
id|count
comma
r_int
op_star
id|eof
comma
r_void
op_star
id|data
)paren
(brace
r_struct
id|jffs_control
op_star
id|c
op_assign
(paren
r_struct
id|jffs_control
op_star
)paren
id|data
suffix:semicolon
r_struct
id|jffs_fm
op_star
id|fm
op_assign
l_int|0
suffix:semicolon
r_struct
id|jffs_fm
op_star
id|last_fm
op_assign
l_int|0
suffix:semicolon
r_int
id|len
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Get the first item in the list */
id|fm
op_assign
id|c-&gt;fmc-&gt;head
suffix:semicolon
multiline_comment|/* Print free space */
r_if
c_cond
(paren
id|fm
op_logical_and
id|fm-&gt;offset
)paren
(brace
id|len
op_add_assign
id|sprintf
(paren
id|page
comma
l_string|&quot;00000000 %08lX free&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|fm-&gt;offset
)paren
suffix:semicolon
)brace
multiline_comment|/* Loop through all of the flash control structures */
r_while
c_loop
(paren
id|fm
op_logical_and
(paren
id|len
OL
(paren
id|off
op_plus
id|count
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|fm-&gt;nodes
)paren
(brace
id|len
op_add_assign
id|sprintf
(paren
id|page
op_plus
id|len
comma
l_string|&quot;%08lX %08lX ino=%08lX, ver=%08lX&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|fm-&gt;offset
comma
(paren
r_int
r_int
)paren
id|fm-&gt;size
comma
(paren
r_int
r_int
)paren
id|fm-&gt;nodes-&gt;node-&gt;ino
comma
(paren
r_int
r_int
)paren
id|fm-&gt;nodes-&gt;node-&gt;version
)paren
suffix:semicolon
)brace
r_else
(brace
id|len
op_add_assign
id|sprintf
(paren
id|page
op_plus
id|len
comma
l_string|&quot;%08lX %08lX dirty&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|fm-&gt;offset
comma
(paren
r_int
r_int
)paren
id|fm-&gt;size
)paren
suffix:semicolon
)brace
id|last_fm
op_assign
id|fm
suffix:semicolon
id|fm
op_assign
id|fm-&gt;next
suffix:semicolon
)brace
multiline_comment|/* Print free space */
r_if
c_cond
(paren
(paren
id|len
OL
(paren
id|off
op_plus
id|count
)paren
)paren
op_logical_and
id|last_fm
op_logical_and
(paren
id|last_fm-&gt;offset
OL
id|c-&gt;fmc-&gt;flash_size
)paren
)paren
(brace
id|len
op_add_assign
id|sprintf
(paren
id|page
op_plus
id|len
comma
l_string|&quot;%08lX %08lX free&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|last_fm-&gt;offset
op_plus
id|last_fm-&gt;size
comma
(paren
r_int
r_int
)paren
(paren
id|c-&gt;fmc-&gt;flash_size
op_minus
(paren
id|last_fm-&gt;offset
op_plus
id|last_fm-&gt;size
)paren
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* We&squot;re done */
op_star
id|eof
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Return length */
r_return
id|len
suffix:semicolon
)brace
eof
