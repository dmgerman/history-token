macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/file.h&gt;
macro_line|#include &lt;linux/mount.h&gt;
macro_line|#include &lt;linux/seq_file.h&gt;
macro_line|#include &quot;internal.h&quot;
multiline_comment|/*&n; * Logic: we&squot;ve got two memory sums for each process, &quot;shared&quot;, and&n; * &quot;non-shared&quot;. Shared memory may get counted more then once, for&n; * each process that owns it. Non-shared memory is counted&n; * accurately.&n; */
DECL|function|task_mem
r_char
op_star
id|task_mem
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_char
op_star
id|buffer
)paren
(brace
r_int
r_int
id|bytes
op_assign
l_int|0
comma
id|sbytes
op_assign
l_int|0
comma
id|slack
op_assign
l_int|0
suffix:semicolon
r_struct
id|mm_tblock_struct
op_star
id|tblock
suffix:semicolon
id|down_read
c_func
(paren
op_amp
id|mm-&gt;mmap_sem
)paren
suffix:semicolon
r_for
c_loop
(paren
id|tblock
op_assign
id|mm-&gt;context.tblock
suffix:semicolon
id|tblock
suffix:semicolon
id|tblock
op_assign
id|tblock-&gt;next
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|tblock-&gt;vma
)paren
r_continue
suffix:semicolon
id|bytes
op_add_assign
id|kobjsize
c_func
(paren
id|tblock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|mm-&gt;mm_count
)paren
OG
l_int|1
op_logical_or
id|atomic_read
c_func
(paren
op_amp
id|tblock-&gt;vma-&gt;vm_usage
)paren
OG
l_int|1
)paren
(brace
id|sbytes
op_add_assign
id|kobjsize
c_func
(paren
(paren
r_void
op_star
)paren
id|tblock-&gt;vma-&gt;vm_start
)paren
suffix:semicolon
id|sbytes
op_add_assign
id|kobjsize
c_func
(paren
id|tblock-&gt;vma
)paren
suffix:semicolon
)brace
r_else
(brace
id|bytes
op_add_assign
id|kobjsize
c_func
(paren
(paren
r_void
op_star
)paren
id|tblock-&gt;vma-&gt;vm_start
)paren
suffix:semicolon
id|bytes
op_add_assign
id|kobjsize
c_func
(paren
id|tblock-&gt;vma
)paren
suffix:semicolon
id|slack
op_add_assign
id|kobjsize
c_func
(paren
(paren
r_void
op_star
)paren
id|tblock-&gt;vma-&gt;vm_start
)paren
op_minus
(paren
id|tblock-&gt;vma-&gt;vm_end
op_minus
id|tblock-&gt;vma-&gt;vm_start
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|mm-&gt;mm_count
)paren
OG
l_int|1
)paren
id|sbytes
op_add_assign
id|kobjsize
c_func
(paren
id|mm
)paren
suffix:semicolon
r_else
id|bytes
op_add_assign
id|kobjsize
c_func
(paren
id|mm
)paren
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;fs
op_logical_and
id|atomic_read
c_func
(paren
op_amp
id|current-&gt;fs-&gt;count
)paren
OG
l_int|1
)paren
id|sbytes
op_add_assign
id|kobjsize
c_func
(paren
id|current-&gt;fs
)paren
suffix:semicolon
r_else
id|bytes
op_add_assign
id|kobjsize
c_func
(paren
id|current-&gt;fs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;files
op_logical_and
id|atomic_read
c_func
(paren
op_amp
id|current-&gt;files-&gt;count
)paren
OG
l_int|1
)paren
id|sbytes
op_add_assign
id|kobjsize
c_func
(paren
id|current-&gt;files
)paren
suffix:semicolon
r_else
id|bytes
op_add_assign
id|kobjsize
c_func
(paren
id|current-&gt;files
)paren
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;sighand
op_logical_and
id|atomic_read
c_func
(paren
op_amp
id|current-&gt;sighand-&gt;count
)paren
OG
l_int|1
)paren
id|sbytes
op_add_assign
id|kobjsize
c_func
(paren
id|current-&gt;sighand
)paren
suffix:semicolon
r_else
id|bytes
op_add_assign
id|kobjsize
c_func
(paren
id|current-&gt;sighand
)paren
suffix:semicolon
id|bytes
op_add_assign
id|kobjsize
c_func
(paren
id|current
)paren
suffix:semicolon
multiline_comment|/* includes kernel stack */
id|buffer
op_add_assign
id|sprintf
c_func
(paren
id|buffer
comma
l_string|&quot;Mem:&bslash;t%8lu bytes&bslash;n&quot;
l_string|&quot;Slack:&bslash;t%8lu bytes&bslash;n&quot;
l_string|&quot;Shared:&bslash;t%8lu bytes&bslash;n&quot;
comma
id|bytes
comma
id|slack
comma
id|sbytes
)paren
suffix:semicolon
id|up_read
c_func
(paren
op_amp
id|mm-&gt;mmap_sem
)paren
suffix:semicolon
r_return
id|buffer
suffix:semicolon
)brace
DECL|function|task_vsize
r_int
r_int
id|task_vsize
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
)paren
(brace
r_struct
id|mm_tblock_struct
op_star
id|tbp
suffix:semicolon
r_int
r_int
id|vsize
op_assign
l_int|0
suffix:semicolon
id|down_read
c_func
(paren
op_amp
id|mm-&gt;mmap_sem
)paren
suffix:semicolon
r_for
c_loop
(paren
id|tbp
op_assign
id|mm-&gt;context.tblock
suffix:semicolon
id|tbp
suffix:semicolon
id|tbp
op_assign
id|tbp-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|tbp-&gt;vma
)paren
id|vsize
op_add_assign
id|kobjsize
c_func
(paren
(paren
r_void
op_star
)paren
id|tbp-&gt;vma-&gt;vm_start
)paren
suffix:semicolon
)brace
id|up_read
c_func
(paren
op_amp
id|mm-&gt;mmap_sem
)paren
suffix:semicolon
r_return
id|vsize
suffix:semicolon
)brace
DECL|function|task_statm
r_int
id|task_statm
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_int
op_star
id|shared
comma
r_int
op_star
id|text
comma
r_int
op_star
id|data
comma
r_int
op_star
id|resident
)paren
(brace
r_struct
id|mm_tblock_struct
op_star
id|tbp
suffix:semicolon
r_int
id|size
op_assign
id|kobjsize
c_func
(paren
id|mm
)paren
suffix:semicolon
id|down_read
c_func
(paren
op_amp
id|mm-&gt;mmap_sem
)paren
suffix:semicolon
r_for
c_loop
(paren
id|tbp
op_assign
id|mm-&gt;context.tblock
suffix:semicolon
id|tbp
suffix:semicolon
id|tbp
op_assign
id|tbp-&gt;next
)paren
(brace
id|size
op_add_assign
id|kobjsize
c_func
(paren
id|tbp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tbp-&gt;vma
)paren
(brace
id|size
op_add_assign
id|kobjsize
c_func
(paren
id|tbp-&gt;vma
)paren
suffix:semicolon
id|size
op_add_assign
id|kobjsize
c_func
(paren
(paren
r_void
op_star
)paren
id|tbp-&gt;vma-&gt;vm_start
)paren
suffix:semicolon
)brace
)brace
id|size
op_add_assign
(paren
op_star
id|text
op_assign
id|mm-&gt;end_code
op_minus
id|mm-&gt;start_code
)paren
suffix:semicolon
id|size
op_add_assign
(paren
op_star
id|data
op_assign
id|mm-&gt;start_stack
op_minus
id|mm-&gt;start_data
)paren
suffix:semicolon
id|up_read
c_func
(paren
op_amp
id|mm-&gt;mmap_sem
)paren
suffix:semicolon
op_star
id|resident
op_assign
id|size
suffix:semicolon
r_return
id|size
suffix:semicolon
)brace
DECL|function|proc_exe_link
r_int
id|proc_exe_link
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|dentry
op_star
op_star
id|dentry
comma
r_struct
id|vfsmount
op_star
op_star
id|mnt
)paren
(brace
r_struct
id|mm_tblock_struct
op_star
id|tblock
suffix:semicolon
r_struct
id|vm_area_struct
op_star
id|vma
suffix:semicolon
r_int
id|result
op_assign
op_minus
id|ENOENT
suffix:semicolon
r_struct
id|task_struct
op_star
id|task
op_assign
id|proc_task
c_func
(paren
id|inode
)paren
suffix:semicolon
r_struct
id|mm_struct
op_star
id|mm
op_assign
id|get_task_mm
c_func
(paren
id|task
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mm
)paren
r_goto
id|out
suffix:semicolon
id|down_read
c_func
(paren
op_amp
id|mm-&gt;mmap_sem
)paren
suffix:semicolon
id|tblock
op_assign
id|mm-&gt;context.tblock
suffix:semicolon
id|vma
op_assign
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
id|tblock
)paren
(brace
r_if
c_cond
(paren
(paren
id|tblock-&gt;vma-&gt;vm_flags
op_amp
id|VM_EXECUTABLE
)paren
op_logical_and
id|tblock-&gt;vma-&gt;vm_file
)paren
(brace
id|vma
op_assign
id|tblock-&gt;vma
suffix:semicolon
r_break
suffix:semicolon
)brace
id|tblock
op_assign
id|tblock-&gt;next
suffix:semicolon
)brace
r_if
c_cond
(paren
id|vma
)paren
(brace
op_star
id|mnt
op_assign
id|mntget
c_func
(paren
id|vma-&gt;vm_file-&gt;f_vfsmnt
)paren
suffix:semicolon
op_star
id|dentry
op_assign
id|dget
c_func
(paren
id|vma-&gt;vm_file-&gt;f_dentry
)paren
suffix:semicolon
id|result
op_assign
l_int|0
suffix:semicolon
)brace
id|up_read
c_func
(paren
op_amp
id|mm-&gt;mmap_sem
)paren
suffix:semicolon
id|mmput
c_func
(paren
id|mm
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/*&n; * Albert D. Cahalan suggested to fake entries for the traditional&n; * sections here.  This might be worth investigating.&n; */
DECL|function|show_map
r_static
r_int
id|show_map
c_func
(paren
r_struct
id|seq_file
op_star
id|m
comma
r_void
op_star
id|v
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|m_start
r_static
r_void
op_star
id|m_start
c_func
(paren
r_struct
id|seq_file
op_star
id|m
comma
id|loff_t
op_star
id|pos
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|m_stop
r_static
r_void
id|m_stop
c_func
(paren
r_struct
id|seq_file
op_star
id|m
comma
r_void
op_star
id|v
)paren
(brace
)brace
DECL|function|m_next
r_static
r_void
op_star
id|m_next
c_func
(paren
r_struct
id|seq_file
op_star
id|m
comma
r_void
op_star
id|v
comma
id|loff_t
op_star
id|pos
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|variable|proc_pid_maps_op
r_struct
id|seq_operations
id|proc_pid_maps_op
op_assign
(brace
dot
id|start
op_assign
id|m_start
comma
dot
id|next
op_assign
id|m_next
comma
dot
id|stop
op_assign
id|m_stop
comma
dot
id|show
op_assign
id|show_map
)brace
suffix:semicolon
eof
