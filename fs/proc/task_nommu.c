macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/file.h&gt;
multiline_comment|/*&n; * Logic: we&squot;ve got two memory sums for each process, &quot;shared&quot;, and&n; * &quot;non-shared&quot;. Shared memory may get counted more then once, for&n; * each process that owns it. Non-shared memory is counted&n; * accurately.&n; */
DECL|function|task_mem
r_char
op_star
id|task_mem
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_char
op_star
id|buffer
)paren
(brace
r_int
r_int
id|bytes
op_assign
l_int|0
comma
id|sbytes
op_assign
l_int|0
comma
id|slack
op_assign
l_int|0
suffix:semicolon
r_struct
id|mm_tblock_struct
op_star
id|tblock
suffix:semicolon
id|down_read
c_func
(paren
op_amp
id|mm-&gt;mmap_sem
)paren
suffix:semicolon
r_for
c_loop
(paren
id|tblock
op_assign
op_amp
id|mm-&gt;context.tblock
suffix:semicolon
id|tblock
suffix:semicolon
id|tblock
op_assign
id|tblock-&gt;next
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|tblock-&gt;rblock
)paren
r_continue
suffix:semicolon
id|bytes
op_add_assign
id|kobjsize
c_func
(paren
id|tblock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|mm-&gt;mm_count
)paren
OG
l_int|1
op_logical_or
id|tblock-&gt;rblock-&gt;refcount
OG
l_int|1
)paren
(brace
id|sbytes
op_add_assign
id|kobjsize
c_func
(paren
id|tblock-&gt;rblock-&gt;kblock
)paren
suffix:semicolon
id|sbytes
op_add_assign
id|kobjsize
c_func
(paren
id|tblock-&gt;rblock
)paren
suffix:semicolon
)brace
r_else
(brace
id|bytes
op_add_assign
id|kobjsize
c_func
(paren
id|tblock-&gt;rblock-&gt;kblock
)paren
suffix:semicolon
id|bytes
op_add_assign
id|kobjsize
c_func
(paren
id|tblock-&gt;rblock
)paren
suffix:semicolon
id|slack
op_add_assign
id|kobjsize
c_func
(paren
id|tblock-&gt;rblock-&gt;kblock
)paren
op_minus
id|tblock-&gt;rblock-&gt;size
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|mm-&gt;mm_count
)paren
OG
l_int|1
)paren
id|sbytes
op_add_assign
id|kobjsize
c_func
(paren
id|mm
)paren
suffix:semicolon
r_else
id|bytes
op_add_assign
id|kobjsize
c_func
(paren
id|mm
)paren
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;fs
op_logical_and
id|atomic_read
c_func
(paren
op_amp
id|current-&gt;fs-&gt;count
)paren
OG
l_int|1
)paren
id|sbytes
op_add_assign
id|kobjsize
c_func
(paren
id|current-&gt;fs
)paren
suffix:semicolon
r_else
id|bytes
op_add_assign
id|kobjsize
c_func
(paren
id|current-&gt;fs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;files
op_logical_and
id|atomic_read
c_func
(paren
op_amp
id|current-&gt;files-&gt;count
)paren
OG
l_int|1
)paren
id|sbytes
op_add_assign
id|kobjsize
c_func
(paren
id|current-&gt;files
)paren
suffix:semicolon
r_else
id|bytes
op_add_assign
id|kobjsize
c_func
(paren
id|current-&gt;files
)paren
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;sighand
op_logical_and
id|atomic_read
c_func
(paren
op_amp
id|current-&gt;sighand-&gt;count
)paren
OG
l_int|1
)paren
id|sbytes
op_add_assign
id|kobjsize
c_func
(paren
id|current-&gt;sighand
)paren
suffix:semicolon
r_else
id|bytes
op_add_assign
id|kobjsize
c_func
(paren
id|current-&gt;sighand
)paren
suffix:semicolon
id|bytes
op_add_assign
id|kobjsize
c_func
(paren
id|current
)paren
suffix:semicolon
multiline_comment|/* includes kernel stack */
id|buffer
op_add_assign
id|sprintf
c_func
(paren
id|buffer
comma
l_string|&quot;Mem:&bslash;t%8lu bytes&bslash;n&quot;
l_string|&quot;Slack:&bslash;t%8lu bytes&bslash;n&quot;
l_string|&quot;Shared:&bslash;t%8lu bytes&bslash;n&quot;
comma
id|bytes
comma
id|slack
comma
id|sbytes
)paren
suffix:semicolon
id|up_read
c_func
(paren
op_amp
id|mm-&gt;mmap_sem
)paren
suffix:semicolon
r_return
id|buffer
suffix:semicolon
)brace
DECL|function|task_vsize
r_int
r_int
id|task_vsize
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
)paren
(brace
r_struct
id|mm_tblock_struct
op_star
id|tbp
suffix:semicolon
r_int
r_int
id|vsize
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|tbp
op_assign
op_amp
id|mm-&gt;context.tblock
suffix:semicolon
id|tbp
suffix:semicolon
id|tbp
op_assign
id|tbp-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|tbp-&gt;rblock
)paren
id|vsize
op_add_assign
id|kobjsize
c_func
(paren
id|tbp-&gt;rblock-&gt;kblock
)paren
suffix:semicolon
)brace
r_return
id|vsize
suffix:semicolon
)brace
DECL|function|task_statm
r_int
id|task_statm
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_int
op_star
id|shared
comma
r_int
op_star
id|text
comma
r_int
op_star
id|data
comma
r_int
op_star
id|resident
)paren
(brace
r_struct
id|mm_tblock_struct
op_star
id|tbp
suffix:semicolon
r_int
id|size
op_assign
id|kobjsize
c_func
(paren
id|mm
)paren
suffix:semicolon
r_for
c_loop
(paren
id|tbp
op_assign
op_amp
id|mm-&gt;context.tblock
suffix:semicolon
id|tbp
suffix:semicolon
id|tbp
op_assign
id|tbp-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|tbp-&gt;next
)paren
id|size
op_add_assign
id|kobjsize
c_func
(paren
id|tbp-&gt;next
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tbp-&gt;rblock
)paren
(brace
id|size
op_add_assign
id|kobjsize
c_func
(paren
id|tbp-&gt;rblock
)paren
suffix:semicolon
id|size
op_add_assign
id|kobjsize
c_func
(paren
id|tbp-&gt;rblock-&gt;kblock
)paren
suffix:semicolon
)brace
)brace
id|size
op_add_assign
(paren
op_star
id|text
op_assign
id|mm-&gt;end_code
op_minus
id|mm-&gt;start_code
)paren
suffix:semicolon
id|size
op_add_assign
(paren
op_star
id|data
op_assign
id|mm-&gt;start_stack
op_minus
id|mm-&gt;start_data
)paren
suffix:semicolon
op_star
id|resident
op_assign
id|size
suffix:semicolon
r_return
id|size
suffix:semicolon
)brace
multiline_comment|/*&n; * Albert D. Cahalan suggested to fake entries for the traditional&n; * sections here.  This might be worth investigating.&n; */
DECL|function|proc_pid_read_maps
id|ssize_t
id|proc_pid_read_maps
c_func
(paren
r_struct
id|task_struct
op_star
id|task
comma
r_struct
id|file
op_star
id|file
comma
r_char
op_star
id|buf
comma
r_int
id|count
comma
id|loff_t
op_star
id|ppos
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
eof
