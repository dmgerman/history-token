multiline_comment|/* binfmt_elf_fdpic.c: FDPIC ELF binary format&n; *&n; * Copyright (C) 2003, 2004 Red Hat, Inc. All Rights Reserved.&n; * Written by David Howells (dhowells@redhat.com)&n; * Derived from binfmt_elf.c&n; *&n; * This program is free software; you can redistribute it and/or&n; * modify it under the terms of the GNU General Public License&n; * as published by the Free Software Foundation; either version&n; * 2 of the License, or (at your option) any later version.&n; */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/stat.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/mman.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/signal.h&gt;
macro_line|#include &lt;linux/binfmts.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/file.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/highmem.h&gt;
macro_line|#include &lt;linux/personality.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/elf.h&gt;
macro_line|#include &lt;linux/elf-fdpic.h&gt;
macro_line|#include &lt;linux/elfcore.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/param.h&gt;
macro_line|#include &lt;asm/pgalloc.h&gt;
DECL|typedef|elf_caddr_t
r_typedef
r_char
op_star
id|elf_caddr_t
suffix:semicolon
macro_line|#ifndef elf_addr_t
DECL|macro|elf_addr_t
mdefine_line|#define elf_addr_t unsigned long
macro_line|#endif
macro_line|#if 0
mdefine_line|#define kdebug(fmt, ...) printk(&quot;FDPIC &quot;fmt&quot;&bslash;n&quot; ,##__VA_ARGS__ )
macro_line|#else
DECL|macro|kdebug
mdefine_line|#define kdebug(fmt, ...) do {} while(0)
macro_line|#endif
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
r_static
r_int
id|load_elf_fdpic_binary
c_func
(paren
r_struct
id|linux_binprm
op_star
id|bprm
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
singleline_comment|//static int load_elf_fdpic_library(struct file *);
r_static
r_int
id|elf_fdpic_fetch_phdrs
c_func
(paren
r_struct
id|elf_fdpic_params
op_star
id|params
comma
r_struct
id|file
op_star
id|file
)paren
suffix:semicolon
r_static
r_int
id|elf_fdpic_map_file
c_func
(paren
r_struct
id|elf_fdpic_params
op_star
id|params
comma
r_struct
id|file
op_star
id|file
comma
r_struct
id|mm_struct
op_star
id|mm
comma
r_const
r_char
op_star
id|what
)paren
suffix:semicolon
r_static
r_int
id|create_elf_fdpic_tables
c_func
(paren
r_struct
id|linux_binprm
op_star
id|bprm
comma
r_struct
id|mm_struct
op_star
id|mm
comma
r_struct
id|elf_fdpic_params
op_star
id|exec_params
comma
r_struct
id|elf_fdpic_params
op_star
id|interp_params
)paren
suffix:semicolon
macro_line|#ifndef CONFIG_MMU
r_static
r_int
id|elf_fdpic_transfer_args_to_stack
c_func
(paren
r_struct
id|linux_binprm
op_star
id|bprm
comma
r_int
r_int
op_star
id|_sp
)paren
suffix:semicolon
r_static
r_int
id|elf_fdpic_map_file_constdisp_on_uclinux
c_func
(paren
r_struct
id|elf_fdpic_params
op_star
id|params
comma
r_struct
id|file
op_star
id|file
comma
r_struct
id|mm_struct
op_star
id|mm
)paren
suffix:semicolon
macro_line|#endif
r_static
r_int
id|elf_fdpic_map_file_by_direct_mmap
c_func
(paren
r_struct
id|elf_fdpic_params
op_star
id|params
comma
r_struct
id|file
op_star
id|file
comma
r_struct
id|mm_struct
op_star
id|mm
)paren
suffix:semicolon
DECL|variable|elf_fdpic_format
r_static
r_struct
id|linux_binfmt
id|elf_fdpic_format
op_assign
(brace
dot
id|module
op_assign
id|THIS_MODULE
comma
dot
id|load_binary
op_assign
id|load_elf_fdpic_binary
comma
singleline_comment|//&t;.load_shlib&t;= load_elf_fdpic_library,
singleline_comment|//&t;.core_dump&t;= elf_fdpic_core_dump,
dot
id|min_coredump
op_assign
id|ELF_EXEC_PAGESIZE
comma
)brace
suffix:semicolon
DECL|function|init_elf_fdpic_binfmt
r_static
r_int
id|__init
id|init_elf_fdpic_binfmt
c_func
(paren
r_void
)paren
(brace
r_return
id|register_binfmt
c_func
(paren
op_amp
id|elf_fdpic_format
)paren
suffix:semicolon
)brace
DECL|function|exit_elf_fdpic_binfmt
r_static
r_void
id|__exit
id|exit_elf_fdpic_binfmt
c_func
(paren
r_void
)paren
(brace
id|unregister_binfmt
c_func
(paren
op_amp
id|elf_fdpic_format
)paren
suffix:semicolon
)brace
id|module_init
c_func
(paren
id|init_elf_fdpic_binfmt
)paren
id|module_exit
c_func
(paren
id|exit_elf_fdpic_binfmt
)paren
DECL|function|is_elf_fdpic
r_static
r_int
id|is_elf_fdpic
c_func
(paren
r_struct
id|elfhdr
op_star
id|hdr
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|hdr-&gt;e_ident
comma
id|ELFMAG
comma
id|SELFMAG
)paren
op_ne
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|hdr-&gt;e_type
op_ne
id|ET_EXEC
op_logical_and
id|hdr-&gt;e_type
op_ne
id|ET_DYN
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|elf_check_arch
c_func
(paren
id|hdr
)paren
op_logical_or
op_logical_neg
id|elf_check_fdpic
c_func
(paren
id|hdr
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|file-&gt;f_op
op_logical_or
op_logical_neg
id|file-&gt;f_op-&gt;mmap
)paren
r_return
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * read the program headers table into memory&n; */
DECL|function|elf_fdpic_fetch_phdrs
r_static
r_int
id|elf_fdpic_fetch_phdrs
c_func
(paren
r_struct
id|elf_fdpic_params
op_star
id|params
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_struct
id|elf32_phdr
op_star
id|phdr
suffix:semicolon
r_int
r_int
id|size
suffix:semicolon
r_int
id|retval
comma
id|loop
suffix:semicolon
r_if
c_cond
(paren
id|params-&gt;hdr.e_phentsize
op_ne
r_sizeof
(paren
r_struct
id|elf_phdr
)paren
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
id|params-&gt;hdr.e_phnum
OG
l_int|65536U
op_div
r_sizeof
(paren
r_struct
id|elf_phdr
)paren
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|size
op_assign
id|params-&gt;hdr.e_phnum
op_star
r_sizeof
(paren
r_struct
id|elf_phdr
)paren
suffix:semicolon
id|params-&gt;phdrs
op_assign
id|kmalloc
c_func
(paren
id|size
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|params-&gt;phdrs
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|retval
op_assign
id|kernel_read
c_func
(paren
id|file
comma
id|params-&gt;hdr.e_phoff
comma
(paren
r_char
op_star
)paren
id|params-&gt;phdrs
comma
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
OL
l_int|0
)paren
r_return
id|retval
suffix:semicolon
multiline_comment|/* determine stack size for this binary */
id|phdr
op_assign
id|params-&gt;phdrs
suffix:semicolon
r_for
c_loop
(paren
id|loop
op_assign
l_int|0
suffix:semicolon
id|loop
OL
id|params-&gt;hdr.e_phnum
suffix:semicolon
id|loop
op_increment
comma
id|phdr
op_increment
)paren
(brace
r_if
c_cond
(paren
id|phdr-&gt;p_type
op_ne
id|PT_GNU_STACK
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|phdr-&gt;p_flags
op_amp
id|PF_X
)paren
id|params-&gt;flags
op_or_assign
id|ELF_FDPIC_FLAG_EXEC_STACK
suffix:semicolon
r_else
id|params-&gt;flags
op_or_assign
id|ELF_FDPIC_FLAG_NOEXEC_STACK
suffix:semicolon
id|params-&gt;stack_size
op_assign
id|phdr-&gt;p_memsz
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* end elf_fdpic_fetch_phdrs() */
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * load an fdpic binary into various bits of memory&n; */
DECL|function|load_elf_fdpic_binary
r_static
r_int
id|load_elf_fdpic_binary
c_func
(paren
r_struct
id|linux_binprm
op_star
id|bprm
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|elf_fdpic_params
id|exec_params
comma
id|interp_params
suffix:semicolon
r_struct
id|elf_phdr
op_star
id|phdr
suffix:semicolon
r_int
r_int
id|stack_size
suffix:semicolon
r_struct
id|file
op_star
id|interpreter
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* to shut gcc up */
r_char
op_star
id|interpreter_name
op_assign
l_int|NULL
suffix:semicolon
r_int
id|executable_stack
suffix:semicolon
r_int
id|retval
comma
id|i
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|exec_params
comma
l_int|0
comma
r_sizeof
(paren
id|exec_params
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|interp_params
comma
l_int|0
comma
r_sizeof
(paren
id|interp_params
)paren
)paren
suffix:semicolon
id|exec_params.hdr
op_assign
op_star
(paren
r_struct
id|elfhdr
op_star
)paren
id|bprm-&gt;buf
suffix:semicolon
id|exec_params.flags
op_assign
id|ELF_FDPIC_FLAG_PRESENT
op_or
id|ELF_FDPIC_FLAG_EXECUTABLE
suffix:semicolon
multiline_comment|/* check that this is a binary we know how to deal with */
id|retval
op_assign
op_minus
id|ENOEXEC
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|is_elf_fdpic
c_func
(paren
op_amp
id|exec_params.hdr
comma
id|bprm-&gt;file
)paren
)paren
r_goto
id|error
suffix:semicolon
multiline_comment|/* read the program header table */
id|retval
op_assign
id|elf_fdpic_fetch_phdrs
c_func
(paren
op_amp
id|exec_params
comma
id|bprm-&gt;file
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
OL
l_int|0
)paren
r_goto
id|error
suffix:semicolon
multiline_comment|/* scan for a program header that specifies an interpreter */
id|phdr
op_assign
id|exec_params.phdrs
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|exec_params.hdr.e_phnum
suffix:semicolon
id|i
op_increment
comma
id|phdr
op_increment
)paren
(brace
r_switch
c_cond
(paren
id|phdr-&gt;p_type
)paren
(brace
r_case
id|PT_INTERP
suffix:colon
id|retval
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
id|phdr-&gt;p_filesz
OG
id|PATH_MAX
)paren
r_goto
id|error
suffix:semicolon
id|retval
op_assign
op_minus
id|ENOENT
suffix:semicolon
r_if
c_cond
(paren
id|phdr-&gt;p_filesz
OL
l_int|2
)paren
r_goto
id|error
suffix:semicolon
multiline_comment|/* read the name of the interpreter into memory */
id|interpreter_name
op_assign
(paren
r_char
op_star
)paren
id|kmalloc
c_func
(paren
id|phdr-&gt;p_filesz
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|interpreter_name
)paren
r_goto
id|error
suffix:semicolon
id|retval
op_assign
id|kernel_read
c_func
(paren
id|bprm-&gt;file
comma
id|phdr-&gt;p_offset
comma
id|interpreter_name
comma
id|phdr-&gt;p_filesz
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
OL
l_int|0
)paren
r_goto
id|error
suffix:semicolon
id|retval
op_assign
op_minus
id|ENOENT
suffix:semicolon
r_if
c_cond
(paren
id|interpreter_name
(braket
id|phdr-&gt;p_filesz
op_minus
l_int|1
)braket
op_ne
l_char|&squot;&bslash;0&squot;
)paren
r_goto
id|error
suffix:semicolon
id|kdebug
c_func
(paren
l_string|&quot;Using ELF interpreter %s&quot;
comma
id|interpreter_name
)paren
suffix:semicolon
multiline_comment|/* replace the program with the interpreter */
id|interpreter
op_assign
id|open_exec
c_func
(paren
id|interpreter_name
)paren
suffix:semicolon
id|retval
op_assign
id|PTR_ERR
c_func
(paren
id|interpreter
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|interpreter
)paren
)paren
(brace
id|interpreter
op_assign
l_int|NULL
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
id|retval
op_assign
id|kernel_read
c_func
(paren
id|interpreter
comma
l_int|0
comma
id|bprm-&gt;buf
comma
id|BINPRM_BUF_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
OL
l_int|0
)paren
r_goto
id|error
suffix:semicolon
id|interp_params.hdr
op_assign
op_star
(paren
(paren
r_struct
id|elfhdr
op_star
)paren
id|bprm-&gt;buf
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PT_LOAD
suffix:colon
macro_line|#ifdef CONFIG_MMU
r_if
c_cond
(paren
id|exec_params.load_addr
op_eq
l_int|0
)paren
id|exec_params.load_addr
op_assign
id|phdr-&gt;p_vaddr
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|elf_check_const_displacement
c_func
(paren
op_amp
id|exec_params.hdr
)paren
)paren
id|exec_params.flags
op_or_assign
id|ELF_FDPIC_FLAG_CONSTDISP
suffix:semicolon
multiline_comment|/* perform insanity checks on the interpreter */
r_if
c_cond
(paren
id|interpreter_name
)paren
(brace
id|retval
op_assign
op_minus
id|ELIBBAD
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|is_elf_fdpic
c_func
(paren
op_amp
id|interp_params.hdr
comma
id|interpreter
)paren
)paren
r_goto
id|error
suffix:semicolon
id|interp_params.flags
op_assign
id|ELF_FDPIC_FLAG_PRESENT
suffix:semicolon
multiline_comment|/* read the interpreter&squot;s program header table */
id|retval
op_assign
id|elf_fdpic_fetch_phdrs
c_func
(paren
op_amp
id|interp_params
comma
id|interpreter
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
OL
l_int|0
)paren
r_goto
id|error
suffix:semicolon
)brace
id|stack_size
op_assign
id|exec_params.stack_size
suffix:semicolon
r_if
c_cond
(paren
id|stack_size
OL
id|interp_params.stack_size
)paren
id|stack_size
op_assign
id|interp_params.stack_size
suffix:semicolon
r_if
c_cond
(paren
id|exec_params.flags
op_amp
id|ELF_FDPIC_FLAG_EXEC_STACK
)paren
id|executable_stack
op_assign
id|EXSTACK_ENABLE_X
suffix:semicolon
r_else
r_if
c_cond
(paren
id|exec_params.flags
op_amp
id|ELF_FDPIC_FLAG_NOEXEC_STACK
)paren
id|executable_stack
op_assign
id|EXSTACK_DISABLE_X
suffix:semicolon
r_else
r_if
c_cond
(paren
id|interp_params.flags
op_amp
id|ELF_FDPIC_FLAG_EXEC_STACK
)paren
id|executable_stack
op_assign
id|EXSTACK_ENABLE_X
suffix:semicolon
r_else
r_if
c_cond
(paren
id|interp_params.flags
op_amp
id|ELF_FDPIC_FLAG_NOEXEC_STACK
)paren
id|executable_stack
op_assign
id|EXSTACK_DISABLE_X
suffix:semicolon
r_else
id|executable_stack
op_assign
id|EXSTACK_DEFAULT
suffix:semicolon
id|retval
op_assign
op_minus
id|ENOEXEC
suffix:semicolon
r_if
c_cond
(paren
id|stack_size
op_eq
l_int|0
)paren
r_goto
id|error
suffix:semicolon
r_if
c_cond
(paren
id|elf_check_const_displacement
c_func
(paren
op_amp
id|interp_params.hdr
)paren
)paren
id|interp_params.flags
op_or_assign
id|ELF_FDPIC_FLAG_CONSTDISP
suffix:semicolon
multiline_comment|/* flush all traces of the currently running executable */
id|retval
op_assign
id|flush_old_exec
c_func
(paren
id|bprm
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_goto
id|error
suffix:semicolon
multiline_comment|/* there&squot;s now no turning back... the old userspace image is dead,&n;&t; * defunct, deceased, etc. after this point we have to exit via&n;&t; * error_kill */
id|set_personality
c_func
(paren
id|PER_LINUX_FDPIC
)paren
suffix:semicolon
id|set_binfmt
c_func
(paren
op_amp
id|elf_fdpic_format
)paren
suffix:semicolon
id|current-&gt;mm-&gt;start_code
op_assign
l_int|0
suffix:semicolon
id|current-&gt;mm-&gt;end_code
op_assign
l_int|0
suffix:semicolon
id|current-&gt;mm-&gt;start_stack
op_assign
l_int|0
suffix:semicolon
id|current-&gt;mm-&gt;start_data
op_assign
l_int|0
suffix:semicolon
id|current-&gt;mm-&gt;end_data
op_assign
l_int|0
suffix:semicolon
id|current-&gt;mm-&gt;context.exec_fdpic_loadmap
op_assign
l_int|0
suffix:semicolon
id|current-&gt;mm-&gt;context.interp_fdpic_loadmap
op_assign
l_int|0
suffix:semicolon
id|current-&gt;flags
op_and_assign
op_complement
id|PF_FORKNOEXEC
suffix:semicolon
macro_line|#ifdef CONFIG_MMU
id|elf_fdpic_arch_lay_out_mm
c_func
(paren
op_amp
id|exec_params
comma
op_amp
id|interp_params
comma
op_amp
id|current-&gt;mm-&gt;start_stack
comma
op_amp
id|current-&gt;mm-&gt;start_brk
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* do this so that we can load the interpreter, if need be&n;&t; * - we will change some of these later&n;&t; */
id|current-&gt;mm-&gt;rss
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef CONFIG_MMU
id|retval
op_assign
id|setup_arg_pages
c_func
(paren
id|bprm
comma
id|current-&gt;mm-&gt;start_stack
comma
id|executable_stack
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
OL
l_int|0
)paren
(brace
id|send_sig
c_func
(paren
id|SIGKILL
comma
id|current
comma
l_int|0
)paren
suffix:semicolon
r_goto
id|error_kill
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* load the executable and interpreter into memory */
id|retval
op_assign
id|elf_fdpic_map_file
c_func
(paren
op_amp
id|exec_params
comma
id|bprm-&gt;file
comma
id|current-&gt;mm
comma
l_string|&quot;executable&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
OL
l_int|0
)paren
r_goto
id|error_kill
suffix:semicolon
r_if
c_cond
(paren
id|interpreter_name
)paren
(brace
id|retval
op_assign
id|elf_fdpic_map_file
c_func
(paren
op_amp
id|interp_params
comma
id|interpreter
comma
id|current-&gt;mm
comma
l_string|&quot;interpreter&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Unable to load interpreter&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|error_kill
suffix:semicolon
)brace
id|allow_write_access
c_func
(paren
id|interpreter
)paren
suffix:semicolon
id|fput
c_func
(paren
id|interpreter
)paren
suffix:semicolon
id|interpreter
op_assign
l_int|NULL
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_MMU
r_if
c_cond
(paren
op_logical_neg
id|current-&gt;mm-&gt;start_brk
)paren
id|current-&gt;mm-&gt;start_brk
op_assign
id|current-&gt;mm-&gt;end_data
suffix:semicolon
id|current-&gt;mm-&gt;brk
op_assign
id|current-&gt;mm-&gt;start_brk
op_assign
id|PAGE_ALIGN
c_func
(paren
id|current-&gt;mm-&gt;start_brk
)paren
suffix:semicolon
macro_line|#else
multiline_comment|/* create a stack and brk area big enough for everyone&n;&t; * - the brk heap starts at the bottom and works up&n;&t; * - the stack starts at the top and works down&n;&t; */
id|stack_size
op_assign
(paren
id|stack_size
op_plus
id|PAGE_SIZE
op_minus
l_int|1
)paren
op_amp
id|PAGE_MASK
suffix:semicolon
r_if
c_cond
(paren
id|stack_size
OL
id|PAGE_SIZE
op_star
l_int|2
)paren
id|stack_size
op_assign
id|PAGE_SIZE
op_star
l_int|2
suffix:semicolon
id|down_write
c_func
(paren
op_amp
id|current-&gt;mm-&gt;mmap_sem
)paren
suffix:semicolon
id|current-&gt;mm-&gt;start_brk
op_assign
id|do_mmap
c_func
(paren
l_int|NULL
comma
l_int|0
comma
id|stack_size
comma
id|PROT_READ
op_or
id|PROT_WRITE
op_or
id|PROT_EXEC
comma
id|MAP_PRIVATE
op_or
id|MAP_ANON
op_or
id|MAP_GROWSDOWN
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
(paren
r_void
op_star
)paren
id|current-&gt;mm-&gt;start_brk
)paren
)paren
(brace
id|up_write
c_func
(paren
op_amp
id|current-&gt;mm-&gt;mmap_sem
)paren
suffix:semicolon
id|retval
op_assign
id|current-&gt;mm-&gt;start_brk
suffix:semicolon
id|current-&gt;mm-&gt;start_brk
op_assign
l_int|0
suffix:semicolon
r_goto
id|error_kill
suffix:semicolon
)brace
r_if
c_cond
(paren
id|do_mremap
c_func
(paren
id|current-&gt;mm-&gt;start_brk
comma
id|stack_size
comma
id|ksize
c_func
(paren
(paren
r_char
op_star
)paren
id|current-&gt;mm-&gt;start_brk
)paren
comma
l_int|0
comma
l_int|0
)paren
op_eq
id|current-&gt;mm-&gt;start_brk
)paren
id|stack_size
op_assign
id|ksize
c_func
(paren
(paren
r_char
op_star
)paren
id|current-&gt;mm-&gt;start_brk
)paren
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|current-&gt;mm-&gt;mmap_sem
)paren
suffix:semicolon
id|current-&gt;mm-&gt;brk
op_assign
id|current-&gt;mm-&gt;start_brk
suffix:semicolon
id|current-&gt;mm-&gt;context.end_brk
op_assign
id|current-&gt;mm-&gt;start_brk
suffix:semicolon
id|current-&gt;mm-&gt;context.end_brk
op_add_assign
(paren
id|stack_size
OG
id|PAGE_SIZE
)paren
ques
c_cond
(paren
id|stack_size
op_minus
id|PAGE_SIZE
)paren
suffix:colon
l_int|0
suffix:semicolon
id|current-&gt;mm-&gt;start_stack
op_assign
id|current-&gt;mm-&gt;start_brk
op_plus
id|stack_size
suffix:semicolon
macro_line|#endif
id|compute_creds
c_func
(paren
id|bprm
)paren
suffix:semicolon
id|current-&gt;flags
op_and_assign
op_complement
id|PF_FORKNOEXEC
suffix:semicolon
r_if
c_cond
(paren
id|create_elf_fdpic_tables
c_func
(paren
id|bprm
comma
id|current-&gt;mm
comma
op_amp
id|exec_params
comma
op_amp
id|interp_params
)paren
OL
l_int|0
)paren
r_goto
id|error_kill
suffix:semicolon
id|kdebug
c_func
(paren
l_string|&quot;- start_code  %lx&quot;
comma
(paren
r_int
)paren
id|current-&gt;mm-&gt;start_code
)paren
suffix:semicolon
id|kdebug
c_func
(paren
l_string|&quot;- end_code    %lx&quot;
comma
(paren
r_int
)paren
id|current-&gt;mm-&gt;end_code
)paren
suffix:semicolon
id|kdebug
c_func
(paren
l_string|&quot;- start_data  %lx&quot;
comma
(paren
r_int
)paren
id|current-&gt;mm-&gt;start_data
)paren
suffix:semicolon
id|kdebug
c_func
(paren
l_string|&quot;- end_data    %lx&quot;
comma
(paren
r_int
)paren
id|current-&gt;mm-&gt;end_data
)paren
suffix:semicolon
id|kdebug
c_func
(paren
l_string|&quot;- start_brk   %lx&quot;
comma
(paren
r_int
)paren
id|current-&gt;mm-&gt;start_brk
)paren
suffix:semicolon
id|kdebug
c_func
(paren
l_string|&quot;- brk         %lx&quot;
comma
(paren
r_int
)paren
id|current-&gt;mm-&gt;brk
)paren
suffix:semicolon
id|kdebug
c_func
(paren
l_string|&quot;- start_stack %lx&quot;
comma
(paren
r_int
)paren
id|current-&gt;mm-&gt;start_stack
)paren
suffix:semicolon
macro_line|#ifdef ELF_FDPIC_PLAT_INIT
multiline_comment|/*&n;&t; * The ABI may specify that certain registers be set up in special&n;&t; * ways (on i386 %edx is the address of a DT_FINI function, for&n;&t; * example.  This macro performs whatever initialization to&n;&t; * the regs structure is required.&n;&t; */
id|ELF_FDPIC_PLAT_INIT
c_func
(paren
id|regs
comma
id|exec_params.map_addr
comma
id|interp_params.map_addr
comma
id|interp_params.dynamic_addr
ques
c_cond
suffix:colon
id|exec_params.dynamic_addr
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* everything is now ready... get the userspace context ready to roll */
id|start_thread
c_func
(paren
id|regs
comma
id|interp_params.entry_addr
ques
c_cond
suffix:colon
id|exec_params.entry_addr
comma
id|current-&gt;mm-&gt;start_stack
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|current-&gt;ptrace
op_amp
id|PT_PTRACED
)paren
)paren
(brace
r_if
c_cond
(paren
id|current-&gt;ptrace
op_amp
id|PT_TRACE_EXEC
)paren
id|ptrace_notify
(paren
(paren
id|PTRACE_EVENT_EXEC
op_lshift
l_int|8
)paren
op_or
id|SIGTRAP
)paren
suffix:semicolon
r_else
id|send_sig
c_func
(paren
id|SIGTRAP
comma
id|current
comma
l_int|0
)paren
suffix:semicolon
)brace
id|retval
op_assign
l_int|0
suffix:semicolon
id|error
suffix:colon
r_if
c_cond
(paren
id|interpreter
)paren
(brace
id|allow_write_access
c_func
(paren
id|interpreter
)paren
suffix:semicolon
id|fput
c_func
(paren
id|interpreter
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|interpreter_name
)paren
id|kfree
c_func
(paren
id|interpreter_name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|exec_params.phdrs
)paren
id|kfree
c_func
(paren
id|exec_params.phdrs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|exec_params.loadmap
)paren
id|kfree
c_func
(paren
id|exec_params.loadmap
)paren
suffix:semicolon
r_if
c_cond
(paren
id|interp_params.phdrs
)paren
id|kfree
c_func
(paren
id|interp_params.phdrs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|interp_params.loadmap
)paren
id|kfree
c_func
(paren
id|interp_params.loadmap
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
multiline_comment|/* unrecoverable error - kill the process */
id|error_kill
suffix:colon
id|send_sig
c_func
(paren
id|SIGSEGV
comma
id|current
comma
l_int|0
)paren
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
multiline_comment|/* end load_elf_fdpic_binary() */
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * present useful information to the program&n; */
DECL|function|create_elf_fdpic_tables
r_static
r_int
id|create_elf_fdpic_tables
c_func
(paren
r_struct
id|linux_binprm
op_star
id|bprm
comma
r_struct
id|mm_struct
op_star
id|mm
comma
r_struct
id|elf_fdpic_params
op_star
id|exec_params
comma
r_struct
id|elf_fdpic_params
op_star
id|interp_params
)paren
(brace
r_int
r_int
id|sp
comma
id|csp
comma
id|nitems
suffix:semicolon
id|elf_caddr_t
op_star
id|argv
comma
op_star
id|envp
suffix:semicolon
r_int
id|platform_len
op_assign
l_int|0
comma
id|len
suffix:semicolon
r_char
op_star
id|k_platform
comma
op_star
id|u_platform
comma
op_star
id|p
suffix:semicolon
r_int
id|hwcap
suffix:semicolon
r_int
id|loop
suffix:semicolon
multiline_comment|/* we&squot;re going to shovel a whole load of stuff onto the stack */
macro_line|#ifdef CONFIG_MMU
id|sp
op_assign
id|bprm-&gt;p
suffix:semicolon
macro_line|#else
id|sp
op_assign
id|mm-&gt;start_stack
suffix:semicolon
multiline_comment|/* stack the program arguments and environment */
r_if
c_cond
(paren
id|elf_fdpic_transfer_args_to_stack
c_func
(paren
id|bprm
comma
op_amp
id|sp
)paren
OL
l_int|0
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
macro_line|#endif
multiline_comment|/* get hold of platform and hardware capabilities masks for the machine&n;&t; * we are running on.  In some cases (Sparc), this info is impossible&n;&t; * to get, in others (i386) it is merely difficult.&n;&t; */
id|hwcap
op_assign
id|ELF_HWCAP
suffix:semicolon
id|k_platform
op_assign
id|ELF_PLATFORM
suffix:semicolon
r_if
c_cond
(paren
id|k_platform
)paren
(brace
id|platform_len
op_assign
id|strlen
c_func
(paren
id|k_platform
)paren
op_plus
l_int|1
suffix:semicolon
id|sp
op_sub_assign
id|platform_len
suffix:semicolon
r_if
c_cond
(paren
id|__copy_to_user
c_func
(paren
id|u_platform
comma
id|k_platform
comma
id|platform_len
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
id|u_platform
op_assign
(paren
r_char
op_star
)paren
id|sp
suffix:semicolon
macro_line|#if defined(__i386__) &amp;&amp; defined(CONFIG_SMP)
multiline_comment|/* in some cases (e.g. Hyper-Threading), we want to avoid L1 evictions&n;&t; * by the processes running on the same package. One thing we can do&n;&t; * is to shuffle the initial stack for them.&n;&t; *&n;&t; * the conditionals here are unneeded, but kept in to make the&n;&t; * code behaviour the same as pre change unless we have hyperthreaded&n;&t; * processors. This keeps Mr Marcelo Person happier but should be&n;&t; * removed for 2.5&n;&t; */
r_if
c_cond
(paren
id|smp_num_siblings
OG
l_int|1
)paren
id|sp
op_assign
id|sp
op_minus
(paren
(paren
id|current-&gt;pid
op_mod
l_int|64
)paren
op_lshift
l_int|7
)paren
suffix:semicolon
macro_line|#endif
id|sp
op_and_assign
op_complement
l_int|7UL
suffix:semicolon
multiline_comment|/* stack the load map(s) */
id|len
op_assign
r_sizeof
(paren
r_struct
id|elf32_fdpic_loadmap
)paren
suffix:semicolon
id|len
op_add_assign
r_sizeof
(paren
r_struct
id|elf32_fdpic_loadseg
)paren
op_star
id|exec_params-&gt;loadmap-&gt;nsegs
suffix:semicolon
id|sp
op_assign
(paren
id|sp
op_minus
id|len
)paren
op_amp
op_complement
l_int|7UL
suffix:semicolon
id|exec_params-&gt;map_addr
op_assign
id|sp
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|sp
comma
id|exec_params-&gt;loadmap
comma
id|len
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|current-&gt;mm-&gt;context.exec_fdpic_loadmap
op_assign
(paren
r_int
r_int
)paren
id|sp
suffix:semicolon
r_if
c_cond
(paren
id|interp_params-&gt;loadmap
)paren
(brace
id|len
op_assign
r_sizeof
(paren
r_struct
id|elf32_fdpic_loadmap
)paren
suffix:semicolon
id|len
op_add_assign
r_sizeof
(paren
r_struct
id|elf32_fdpic_loadseg
)paren
op_star
id|interp_params-&gt;loadmap-&gt;nsegs
suffix:semicolon
id|sp
op_assign
(paren
id|sp
op_minus
id|len
)paren
op_amp
op_complement
l_int|7UL
suffix:semicolon
id|interp_params-&gt;map_addr
op_assign
id|sp
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|sp
comma
id|interp_params-&gt;loadmap
comma
id|len
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|current-&gt;mm-&gt;context.interp_fdpic_loadmap
op_assign
(paren
r_int
r_int
)paren
id|sp
suffix:semicolon
)brace
multiline_comment|/* force 16 byte _final_ alignment here for generality */
DECL|macro|DLINFO_ITEMS
mdefine_line|#define DLINFO_ITEMS 13
id|nitems
op_assign
l_int|1
op_plus
id|DLINFO_ITEMS
op_plus
(paren
id|k_platform
ques
c_cond
l_int|1
suffix:colon
l_int|0
)paren
suffix:semicolon
macro_line|#ifdef DLINFO_ARCH_ITEMS
id|nitems
op_add_assign
id|DLINFO_ARCH_ITEMS
suffix:semicolon
macro_line|#endif
id|csp
op_assign
id|sp
suffix:semicolon
id|sp
op_sub_assign
id|nitems
op_star
l_int|2
op_star
r_sizeof
(paren
r_int
r_int
)paren
suffix:semicolon
id|sp
op_sub_assign
(paren
id|bprm-&gt;envc
op_plus
l_int|1
)paren
op_star
r_sizeof
(paren
r_char
op_star
)paren
suffix:semicolon
multiline_comment|/* envv[] */
id|sp
op_sub_assign
(paren
id|bprm-&gt;argc
op_plus
l_int|1
)paren
op_star
r_sizeof
(paren
r_char
op_star
)paren
suffix:semicolon
multiline_comment|/* argv[] */
id|sp
op_sub_assign
l_int|1
op_star
r_sizeof
(paren
r_int
r_int
)paren
suffix:semicolon
multiline_comment|/* argc */
id|csp
op_sub_assign
id|sp
op_amp
l_int|15UL
suffix:semicolon
id|sp
op_sub_assign
id|sp
op_amp
l_int|15UL
suffix:semicolon
multiline_comment|/* put the ELF interpreter info on the stack */
DECL|macro|NEW_AUX_ENT
mdefine_line|#define NEW_AUX_ENT(nr, id, val)&t;&t;&t;&t;&t;&t;&bslash;&n;&t;do {&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;struct { unsigned long _id, _val; } *ent = (void *) csp;&t;&bslash;&n;&t;&t;__put_user((id), &amp;ent[nr]._id);&t;&t;&t;&t;&t;&bslash;&n;&t;&t;__put_user((val), &amp;ent[nr]._val);&t;&t;&t;&t;&bslash;&n;&t;} while (0)
id|csp
op_sub_assign
l_int|2
op_star
r_sizeof
(paren
r_int
r_int
)paren
suffix:semicolon
id|NEW_AUX_ENT
c_func
(paren
l_int|0
comma
id|AT_NULL
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|k_platform
)paren
(brace
id|csp
op_sub_assign
l_int|2
op_star
r_sizeof
(paren
r_int
r_int
)paren
suffix:semicolon
id|NEW_AUX_ENT
c_func
(paren
l_int|0
comma
id|AT_PLATFORM
comma
(paren
id|elf_addr_t
)paren
(paren
r_int
r_int
)paren
id|u_platform
)paren
suffix:semicolon
)brace
id|csp
op_sub_assign
id|DLINFO_ITEMS
op_star
l_int|2
op_star
r_sizeof
(paren
r_int
r_int
)paren
suffix:semicolon
id|NEW_AUX_ENT
c_func
(paren
l_int|0
comma
id|AT_HWCAP
comma
id|hwcap
)paren
suffix:semicolon
id|NEW_AUX_ENT
c_func
(paren
l_int|1
comma
id|AT_PAGESZ
comma
id|PAGE_SIZE
)paren
suffix:semicolon
id|NEW_AUX_ENT
c_func
(paren
l_int|2
comma
id|AT_CLKTCK
comma
id|CLOCKS_PER_SEC
)paren
suffix:semicolon
id|NEW_AUX_ENT
c_func
(paren
l_int|3
comma
id|AT_PHDR
comma
id|exec_params-&gt;ph_addr
)paren
suffix:semicolon
id|NEW_AUX_ENT
c_func
(paren
l_int|4
comma
id|AT_PHENT
comma
r_sizeof
(paren
r_struct
id|elf_phdr
)paren
)paren
suffix:semicolon
id|NEW_AUX_ENT
c_func
(paren
l_int|5
comma
id|AT_PHNUM
comma
id|exec_params-&gt;hdr.e_phnum
)paren
suffix:semicolon
id|NEW_AUX_ENT
c_func
(paren
l_int|6
comma
id|AT_BASE
comma
id|interp_params-&gt;elfhdr_addr
)paren
suffix:semicolon
id|NEW_AUX_ENT
c_func
(paren
l_int|7
comma
id|AT_FLAGS
comma
l_int|0
)paren
suffix:semicolon
id|NEW_AUX_ENT
c_func
(paren
l_int|8
comma
id|AT_ENTRY
comma
id|exec_params-&gt;entry_addr
)paren
suffix:semicolon
id|NEW_AUX_ENT
c_func
(paren
l_int|9
comma
id|AT_UID
comma
(paren
id|elf_addr_t
)paren
id|current-&gt;uid
)paren
suffix:semicolon
id|NEW_AUX_ENT
c_func
(paren
l_int|10
comma
id|AT_EUID
comma
(paren
id|elf_addr_t
)paren
id|current-&gt;euid
)paren
suffix:semicolon
id|NEW_AUX_ENT
c_func
(paren
l_int|11
comma
id|AT_GID
comma
(paren
id|elf_addr_t
)paren
id|current-&gt;gid
)paren
suffix:semicolon
id|NEW_AUX_ENT
c_func
(paren
l_int|12
comma
id|AT_EGID
comma
(paren
id|elf_addr_t
)paren
id|current-&gt;egid
)paren
suffix:semicolon
macro_line|#ifdef ARCH_DLINFO
multiline_comment|/* ARCH_DLINFO must come last so platform specific code can enforce&n;&t; * special alignment requirements on the AUXV if necessary (eg. PPC).&n;&t; */
id|ARCH_DLINFO
suffix:semicolon
macro_line|#endif
DECL|macro|NEW_AUX_ENT
macro_line|#undef NEW_AUX_ENT
multiline_comment|/* allocate room for argv[] and envv[] */
id|csp
op_sub_assign
(paren
id|bprm-&gt;envc
op_plus
l_int|1
)paren
op_star
r_sizeof
(paren
id|elf_caddr_t
)paren
suffix:semicolon
id|envp
op_assign
(paren
id|elf_caddr_t
op_star
)paren
id|csp
suffix:semicolon
id|csp
op_sub_assign
(paren
id|bprm-&gt;argc
op_plus
l_int|1
)paren
op_star
r_sizeof
(paren
id|elf_caddr_t
)paren
suffix:semicolon
id|argv
op_assign
(paren
id|elf_caddr_t
op_star
)paren
id|csp
suffix:semicolon
multiline_comment|/* stack argc */
id|csp
op_sub_assign
r_sizeof
(paren
r_int
r_int
)paren
suffix:semicolon
id|__put_user
c_func
(paren
id|bprm-&gt;argc
comma
(paren
r_int
r_int
op_star
)paren
id|csp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|csp
op_ne
id|sp
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* fill in the argv[] array */
macro_line|#ifdef CONFIG_MMU
id|current-&gt;mm-&gt;arg_start
op_assign
id|bprm-&gt;p
suffix:semicolon
macro_line|#else
id|current-&gt;mm-&gt;arg_start
op_assign
id|current-&gt;mm-&gt;start_stack
op_minus
(paren
id|MAX_ARG_PAGES
op_star
id|PAGE_SIZE
op_minus
id|bprm-&gt;p
)paren
suffix:semicolon
macro_line|#endif
id|p
op_assign
(paren
r_char
op_star
)paren
id|current-&gt;mm-&gt;arg_start
suffix:semicolon
r_for
c_loop
(paren
id|loop
op_assign
id|bprm-&gt;argc
suffix:semicolon
id|loop
OG
l_int|0
suffix:semicolon
id|loop
op_decrement
)paren
(brace
id|__put_user
c_func
(paren
(paren
id|elf_caddr_t
)paren
id|p
comma
id|argv
op_increment
)paren
suffix:semicolon
id|len
op_assign
id|strnlen_user
c_func
(paren
id|p
comma
id|PAGE_SIZE
op_star
id|MAX_ARG_PAGES
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|len
op_logical_or
id|len
OG
id|PAGE_SIZE
op_star
id|MAX_ARG_PAGES
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|p
op_add_assign
id|len
suffix:semicolon
)brace
id|__put_user
c_func
(paren
l_int|NULL
comma
id|argv
)paren
suffix:semicolon
id|current-&gt;mm-&gt;arg_end
op_assign
(paren
r_int
r_int
)paren
id|p
suffix:semicolon
multiline_comment|/* fill in the envv[] array */
id|current-&gt;mm-&gt;env_start
op_assign
(paren
r_int
r_int
)paren
id|p
suffix:semicolon
r_for
c_loop
(paren
id|loop
op_assign
id|bprm-&gt;envc
suffix:semicolon
id|loop
OG
l_int|0
suffix:semicolon
id|loop
op_decrement
)paren
(brace
id|__put_user
c_func
(paren
(paren
id|elf_caddr_t
)paren
(paren
r_int
r_int
)paren
id|p
comma
id|envp
op_increment
)paren
suffix:semicolon
id|len
op_assign
id|strnlen_user
c_func
(paren
id|p
comma
id|PAGE_SIZE
op_star
id|MAX_ARG_PAGES
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|len
op_logical_or
id|len
OG
id|PAGE_SIZE
op_star
id|MAX_ARG_PAGES
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|p
op_add_assign
id|len
suffix:semicolon
)brace
id|__put_user
c_func
(paren
l_int|NULL
comma
id|envp
)paren
suffix:semicolon
id|current-&gt;mm-&gt;env_end
op_assign
(paren
r_int
r_int
)paren
id|p
suffix:semicolon
id|mm-&gt;start_stack
op_assign
(paren
r_int
r_int
)paren
id|sp
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* end create_elf_fdpic_tables() */
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * transfer the program arguments and environment from the holding pages onto&n; * the stack&n; */
macro_line|#ifndef CONFIG_MMU
DECL|function|elf_fdpic_transfer_args_to_stack
r_static
r_int
id|elf_fdpic_transfer_args_to_stack
c_func
(paren
r_struct
id|linux_binprm
op_star
id|bprm
comma
r_int
r_int
op_star
id|_sp
)paren
(brace
r_int
r_int
id|index
comma
id|stop
comma
id|sp
suffix:semicolon
r_char
op_star
id|src
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|stop
op_assign
id|bprm-&gt;p
op_rshift
id|PAGE_SHIFT
suffix:semicolon
id|sp
op_assign
op_star
id|_sp
suffix:semicolon
r_for
c_loop
(paren
id|index
op_assign
id|MAX_ARG_PAGES
op_minus
l_int|1
suffix:semicolon
id|index
op_ge
id|stop
suffix:semicolon
id|index
op_decrement
)paren
(brace
id|src
op_assign
id|kmap
c_func
(paren
id|bprm-&gt;page
(braket
id|index
)braket
)paren
suffix:semicolon
id|sp
op_sub_assign
id|PAGE_SIZE
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|sp
comma
id|src
comma
id|PAGE_SIZE
)paren
op_ne
l_int|0
)paren
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
id|kunmap
c_func
(paren
id|bprm-&gt;page
(braket
id|index
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
r_goto
id|out
suffix:semicolon
)brace
op_star
id|_sp
op_assign
(paren
op_star
id|_sp
op_minus
(paren
id|MAX_ARG_PAGES
op_star
id|PAGE_SIZE
op_minus
id|bprm-&gt;p
)paren
)paren
op_amp
op_complement
l_int|15
suffix:semicolon
id|out
suffix:colon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* end elf_fdpic_transfer_args_to_stack() */
macro_line|#endif
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * load the appropriate binary image (executable or interpreter) into memory&n; * - we assume no MMU is available&n; * - if no other PIC bits are set in params-&gt;hdr-&gt;e_flags&n; *   - we assume that the LOADable segments in the binary are independently relocatable&n; *   - we assume R/O executable segments are shareable&n; * - else&n; *   - we assume the loadable parts of the image to require fixed displacement&n; *   - the image is not shareable&n; */
DECL|function|elf_fdpic_map_file
r_static
r_int
id|elf_fdpic_map_file
c_func
(paren
r_struct
id|elf_fdpic_params
op_star
id|params
comma
r_struct
id|file
op_star
id|file
comma
r_struct
id|mm_struct
op_star
id|mm
comma
r_const
r_char
op_star
id|what
)paren
(brace
r_struct
id|elf32_fdpic_loadmap
op_star
id|loadmap
suffix:semicolon
macro_line|#ifdef CONFIG_MMU
r_struct
id|elf32_fdpic_loadseg
op_star
id|mseg
suffix:semicolon
macro_line|#endif
r_struct
id|elf32_fdpic_loadseg
op_star
id|seg
suffix:semicolon
r_struct
id|elf32_phdr
op_star
id|phdr
suffix:semicolon
r_int
r_int
id|load_addr
comma
id|stop
suffix:semicolon
r_int
id|nloads
comma
id|tmp
suffix:semicolon
r_int
id|size
suffix:semicolon
r_int
id|loop
comma
id|ret
suffix:semicolon
multiline_comment|/* allocate a load map table */
id|nloads
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|loop
op_assign
l_int|0
suffix:semicolon
id|loop
OL
id|params-&gt;hdr.e_phnum
suffix:semicolon
id|loop
op_increment
)paren
r_if
c_cond
(paren
id|params-&gt;phdrs
(braket
id|loop
)braket
dot
id|p_type
op_eq
id|PT_LOAD
)paren
id|nloads
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|nloads
op_eq
l_int|0
)paren
r_return
op_minus
id|ELIBBAD
suffix:semicolon
id|size
op_assign
r_sizeof
(paren
op_star
id|loadmap
)paren
op_plus
id|nloads
op_star
r_sizeof
(paren
op_star
id|seg
)paren
suffix:semicolon
id|loadmap
op_assign
id|kmalloc
c_func
(paren
id|size
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|loadmap
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|params-&gt;loadmap
op_assign
id|loadmap
suffix:semicolon
id|memset
c_func
(paren
id|loadmap
comma
l_int|0
comma
id|size
)paren
suffix:semicolon
id|loadmap-&gt;version
op_assign
id|ELF32_FDPIC_LOADMAP_VERSION
suffix:semicolon
id|loadmap-&gt;nsegs
op_assign
id|nloads
suffix:semicolon
id|load_addr
op_assign
id|params-&gt;load_addr
suffix:semicolon
id|seg
op_assign
id|loadmap-&gt;segs
suffix:semicolon
multiline_comment|/* map the requested LOADs into the memory space */
r_switch
c_cond
(paren
id|params-&gt;flags
op_amp
id|ELF_FDPIC_FLAG_ARRANGEMENT
)paren
(brace
r_case
id|ELF_FDPIC_FLAG_CONSTDISP
suffix:colon
r_case
id|ELF_FDPIC_FLAG_CONTIGUOUS
suffix:colon
macro_line|#ifndef CONFIG_MMU
id|ret
op_assign
id|elf_fdpic_map_file_constdisp_on_uclinux
c_func
(paren
id|params
comma
id|file
comma
id|mm
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
r_return
id|ret
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
r_default
suffix:colon
id|ret
op_assign
id|elf_fdpic_map_file_by_direct_mmap
c_func
(paren
id|params
comma
id|file
comma
id|mm
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
r_return
id|ret
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* map the entry point */
r_if
c_cond
(paren
id|params-&gt;hdr.e_entry
)paren
(brace
id|seg
op_assign
id|loadmap-&gt;segs
suffix:semicolon
r_for
c_loop
(paren
id|loop
op_assign
id|loadmap-&gt;nsegs
suffix:semicolon
id|loop
OG
l_int|0
suffix:semicolon
id|loop
op_decrement
comma
id|seg
op_increment
)paren
(brace
r_if
c_cond
(paren
id|params-&gt;hdr.e_entry
op_ge
id|seg-&gt;p_vaddr
op_logical_and
id|params-&gt;hdr.e_entry
OL
id|seg-&gt;p_vaddr
op_plus
id|seg-&gt;p_memsz
)paren
(brace
id|params-&gt;entry_addr
op_assign
(paren
id|params-&gt;hdr.e_entry
op_minus
id|seg-&gt;p_vaddr
)paren
op_plus
id|seg-&gt;addr
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* determine where the program header table has wound up if mapped */
id|stop
op_assign
id|params-&gt;hdr.e_phoff
op_plus
id|params-&gt;hdr.e_phnum
op_star
r_sizeof
(paren
r_struct
id|elf_phdr
)paren
suffix:semicolon
id|phdr
op_assign
id|params-&gt;phdrs
suffix:semicolon
r_for
c_loop
(paren
id|loop
op_assign
l_int|0
suffix:semicolon
id|loop
OL
id|params-&gt;hdr.e_phnum
suffix:semicolon
id|loop
op_increment
comma
id|phdr
op_increment
)paren
(brace
r_if
c_cond
(paren
id|phdr-&gt;p_type
op_ne
id|PT_LOAD
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|phdr-&gt;p_offset
OG
id|params-&gt;hdr.e_phoff
op_logical_or
id|phdr-&gt;p_offset
op_plus
id|phdr-&gt;p_filesz
OL
id|stop
)paren
r_continue
suffix:semicolon
id|seg
op_assign
id|loadmap-&gt;segs
suffix:semicolon
r_for
c_loop
(paren
id|loop
op_assign
id|loadmap-&gt;nsegs
suffix:semicolon
id|loop
OG
l_int|0
suffix:semicolon
id|loop
op_decrement
comma
id|seg
op_increment
)paren
(brace
r_if
c_cond
(paren
id|phdr-&gt;p_vaddr
op_ge
id|seg-&gt;p_vaddr
op_logical_and
id|phdr-&gt;p_vaddr
op_plus
id|phdr-&gt;p_filesz
op_le
id|seg-&gt;p_vaddr
op_plus
id|seg-&gt;p_memsz
)paren
(brace
id|params-&gt;ph_addr
op_assign
(paren
id|phdr-&gt;p_vaddr
op_minus
id|seg-&gt;p_vaddr
)paren
op_plus
id|seg-&gt;addr
op_plus
id|params-&gt;hdr.e_phoff
op_minus
id|phdr-&gt;p_offset
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
)brace
multiline_comment|/* determine where the dynamic section has wound up if there is one */
id|phdr
op_assign
id|params-&gt;phdrs
suffix:semicolon
r_for
c_loop
(paren
id|loop
op_assign
l_int|0
suffix:semicolon
id|loop
OL
id|params-&gt;hdr.e_phnum
suffix:semicolon
id|loop
op_increment
comma
id|phdr
op_increment
)paren
(brace
r_if
c_cond
(paren
id|phdr-&gt;p_type
op_ne
id|PT_DYNAMIC
)paren
r_continue
suffix:semicolon
id|seg
op_assign
id|loadmap-&gt;segs
suffix:semicolon
r_for
c_loop
(paren
id|loop
op_assign
id|loadmap-&gt;nsegs
suffix:semicolon
id|loop
OG
l_int|0
suffix:semicolon
id|loop
op_decrement
comma
id|seg
op_increment
)paren
(brace
r_if
c_cond
(paren
id|phdr-&gt;p_vaddr
op_ge
id|seg-&gt;p_vaddr
op_logical_and
id|phdr-&gt;p_vaddr
op_plus
id|phdr-&gt;p_memsz
op_le
id|seg-&gt;p_vaddr
op_plus
id|seg-&gt;p_memsz
)paren
(brace
id|params-&gt;dynamic_addr
op_assign
(paren
id|phdr-&gt;p_vaddr
op_minus
id|seg-&gt;p_vaddr
)paren
op_plus
id|seg-&gt;addr
suffix:semicolon
multiline_comment|/* check the dynamic section contains at least one item, and that&n;&t;&t;&t;&t; * the last item is a NULL entry */
r_if
c_cond
(paren
id|phdr-&gt;p_memsz
op_eq
l_int|0
op_logical_or
id|phdr-&gt;p_memsz
op_mod
r_sizeof
(paren
id|Elf32_Dyn
)paren
op_ne
l_int|0
)paren
r_goto
id|dynamic_error
suffix:semicolon
id|tmp
op_assign
id|phdr-&gt;p_memsz
op_div
r_sizeof
(paren
id|Elf32_Dyn
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|Elf32_Dyn
op_star
)paren
id|params-&gt;dynamic_addr
)paren
(braket
id|tmp
op_minus
l_int|1
)braket
dot
id|d_tag
op_ne
l_int|0
)paren
r_goto
id|dynamic_error
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
)brace
multiline_comment|/* now elide adjacent segments in the load map on MMU linux&n;&t; * - on uClinux the holes between may actually be filled with system stuff or stuff from&n;&t; *   other processes&n;&t; */
macro_line|#ifdef CONFIG_MMU
id|nloads
op_assign
id|loadmap-&gt;nsegs
suffix:semicolon
id|mseg
op_assign
id|loadmap-&gt;segs
suffix:semicolon
id|seg
op_assign
id|mseg
op_plus
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|loop
op_assign
l_int|1
suffix:semicolon
id|loop
OL
id|nloads
suffix:semicolon
id|loop
op_increment
)paren
(brace
multiline_comment|/* see if we have a candidate for merging */
r_if
c_cond
(paren
id|seg-&gt;p_vaddr
op_minus
id|mseg-&gt;p_vaddr
op_eq
id|seg-&gt;addr
op_minus
id|mseg-&gt;addr
)paren
(brace
id|load_addr
op_assign
id|PAGE_ALIGN
c_func
(paren
id|mseg-&gt;addr
op_plus
id|mseg-&gt;p_memsz
)paren
suffix:semicolon
r_if
c_cond
(paren
id|load_addr
op_eq
(paren
id|seg-&gt;addr
op_amp
id|PAGE_MASK
)paren
)paren
(brace
id|mseg-&gt;p_memsz
op_add_assign
id|load_addr
op_minus
(paren
id|mseg-&gt;addr
op_plus
id|mseg-&gt;p_memsz
)paren
suffix:semicolon
id|mseg-&gt;p_memsz
op_add_assign
id|seg-&gt;addr
op_amp
op_complement
id|PAGE_MASK
suffix:semicolon
id|mseg-&gt;p_memsz
op_add_assign
id|seg-&gt;p_memsz
suffix:semicolon
id|loadmap-&gt;nsegs
op_decrement
suffix:semicolon
r_continue
suffix:semicolon
)brace
)brace
id|mseg
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|mseg
op_ne
id|seg
)paren
op_star
id|mseg
op_assign
op_star
id|seg
suffix:semicolon
)brace
macro_line|#endif
id|kdebug
c_func
(paren
l_string|&quot;Mapped Object [%s]:&quot;
comma
id|what
)paren
suffix:semicolon
id|kdebug
c_func
(paren
l_string|&quot;- elfhdr   : %lx&quot;
comma
id|params-&gt;elfhdr_addr
)paren
suffix:semicolon
id|kdebug
c_func
(paren
l_string|&quot;- entry    : %lx&quot;
comma
id|params-&gt;entry_addr
)paren
suffix:semicolon
id|kdebug
c_func
(paren
l_string|&quot;- PHDR[]   : %lx&quot;
comma
id|params-&gt;ph_addr
)paren
suffix:semicolon
id|kdebug
c_func
(paren
l_string|&quot;- DYNAMIC[]: %lx&quot;
comma
id|params-&gt;dynamic_addr
)paren
suffix:semicolon
id|seg
op_assign
id|loadmap-&gt;segs
suffix:semicolon
r_for
c_loop
(paren
id|loop
op_assign
l_int|0
suffix:semicolon
id|loop
OL
id|loadmap-&gt;nsegs
suffix:semicolon
id|loop
op_increment
comma
id|seg
op_increment
)paren
id|kdebug
c_func
(paren
l_string|&quot;- LOAD[%d] : %08x-%08x [va=%x ms=%x]&quot;
comma
id|loop
comma
id|seg-&gt;addr
comma
id|seg-&gt;addr
op_plus
id|seg-&gt;p_memsz
op_minus
l_int|1
comma
id|seg-&gt;p_vaddr
comma
id|seg-&gt;p_memsz
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|dynamic_error
suffix:colon
id|printk
c_func
(paren
l_string|&quot;ELF FDPIC %s with invalid DYNAMIC section (inode=%lu)&bslash;n&quot;
comma
id|what
comma
id|file-&gt;f_dentry-&gt;d_inode-&gt;i_ino
)paren
suffix:semicolon
r_return
op_minus
id|ELIBBAD
suffix:semicolon
)brace
multiline_comment|/* end elf_fdpic_map_file() */
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * map a file with constant displacement under uClinux&n; */
macro_line|#ifndef CONFIG_MMU
DECL|function|elf_fdpic_map_file_constdisp_on_uclinux
r_static
r_int
id|elf_fdpic_map_file_constdisp_on_uclinux
c_func
(paren
r_struct
id|elf_fdpic_params
op_star
id|params
comma
r_struct
id|file
op_star
id|file
comma
r_struct
id|mm_struct
op_star
id|mm
)paren
(brace
r_struct
id|elf32_fdpic_loadseg
op_star
id|seg
suffix:semicolon
r_struct
id|elf32_phdr
op_star
id|phdr
suffix:semicolon
r_int
r_int
id|load_addr
comma
id|base
op_assign
id|ULONG_MAX
comma
id|top
op_assign
l_int|0
comma
id|maddr
op_assign
l_int|0
comma
id|mflags
suffix:semicolon
id|loff_t
id|fpos
suffix:semicolon
r_int
id|loop
comma
id|ret
suffix:semicolon
id|load_addr
op_assign
id|params-&gt;load_addr
suffix:semicolon
id|seg
op_assign
id|params-&gt;loadmap-&gt;segs
suffix:semicolon
multiline_comment|/* determine the bounds of the contiguous overall allocation we must make */
id|phdr
op_assign
id|params-&gt;phdrs
suffix:semicolon
r_for
c_loop
(paren
id|loop
op_assign
l_int|0
suffix:semicolon
id|loop
OL
id|params-&gt;hdr.e_phnum
suffix:semicolon
id|loop
op_increment
comma
id|phdr
op_increment
)paren
(brace
r_if
c_cond
(paren
id|params-&gt;phdrs
(braket
id|loop
)braket
dot
id|p_type
op_ne
id|PT_LOAD
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|base
OG
id|phdr-&gt;p_vaddr
)paren
id|base
op_assign
id|phdr-&gt;p_vaddr
suffix:semicolon
r_if
c_cond
(paren
id|top
OL
id|phdr-&gt;p_vaddr
op_plus
id|phdr-&gt;p_memsz
)paren
id|top
op_assign
id|phdr-&gt;p_vaddr
op_plus
id|phdr-&gt;p_memsz
suffix:semicolon
)brace
multiline_comment|/* allocate one big anon block for everything */
id|mflags
op_assign
id|MAP_PRIVATE
suffix:semicolon
r_if
c_cond
(paren
id|params-&gt;flags
op_amp
id|ELF_FDPIC_FLAG_EXECUTABLE
)paren
id|mflags
op_or_assign
id|MAP_EXECUTABLE
suffix:semicolon
id|down_write
c_func
(paren
op_amp
id|mm-&gt;mmap_sem
)paren
suffix:semicolon
id|maddr
op_assign
id|do_mmap
c_func
(paren
l_int|NULL
comma
id|load_addr
comma
id|top
op_minus
id|base
comma
id|PROT_READ
op_or
id|PROT_WRITE
op_or
id|PROT_EXEC
comma
id|mflags
comma
l_int|0
)paren
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|mm-&gt;mmap_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
(paren
r_void
op_star
)paren
id|maddr
)paren
)paren
r_return
(paren
r_int
)paren
id|maddr
suffix:semicolon
r_if
c_cond
(paren
id|load_addr
op_ne
l_int|0
)paren
id|load_addr
op_add_assign
id|PAGE_ALIGN
c_func
(paren
id|top
op_minus
id|base
)paren
suffix:semicolon
multiline_comment|/* and then load the file segments into it */
id|phdr
op_assign
id|params-&gt;phdrs
suffix:semicolon
r_for
c_loop
(paren
id|loop
op_assign
l_int|0
suffix:semicolon
id|loop
OL
id|params-&gt;hdr.e_phnum
suffix:semicolon
id|loop
op_increment
comma
id|phdr
op_increment
)paren
(brace
r_if
c_cond
(paren
id|params-&gt;phdrs
(braket
id|loop
)braket
dot
id|p_type
op_ne
id|PT_LOAD
)paren
r_continue
suffix:semicolon
id|fpos
op_assign
id|phdr-&gt;p_offset
suffix:semicolon
id|seg-&gt;addr
op_assign
id|maddr
op_plus
(paren
id|phdr-&gt;p_vaddr
op_minus
id|base
)paren
suffix:semicolon
id|seg-&gt;p_vaddr
op_assign
id|phdr-&gt;p_vaddr
suffix:semicolon
id|seg-&gt;p_memsz
op_assign
id|phdr-&gt;p_memsz
suffix:semicolon
id|ret
op_assign
id|file-&gt;f_op
op_member_access_from_pointer
id|read
c_func
(paren
id|file
comma
(paren
r_void
op_star
)paren
id|seg-&gt;addr
comma
id|phdr-&gt;p_filesz
comma
op_amp
id|fpos
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
r_return
id|ret
suffix:semicolon
multiline_comment|/* map the ELF header address if in this segment */
r_if
c_cond
(paren
id|phdr-&gt;p_offset
op_eq
l_int|0
)paren
id|params-&gt;elfhdr_addr
op_assign
id|seg-&gt;addr
suffix:semicolon
multiline_comment|/* clear any space allocated but not loaded */
r_if
c_cond
(paren
id|phdr-&gt;p_filesz
OL
id|phdr-&gt;p_memsz
)paren
id|clear_user
c_func
(paren
(paren
r_void
op_star
)paren
(paren
id|seg-&gt;addr
op_plus
id|phdr-&gt;p_filesz
)paren
comma
id|phdr-&gt;p_memsz
op_minus
id|phdr-&gt;p_filesz
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mm
)paren
(brace
r_if
c_cond
(paren
id|phdr-&gt;p_flags
op_amp
id|PF_X
)paren
(brace
id|mm-&gt;start_code
op_assign
id|seg-&gt;addr
suffix:semicolon
id|mm-&gt;end_code
op_assign
id|seg-&gt;addr
op_plus
id|phdr-&gt;p_memsz
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|mm-&gt;start_data
)paren
(brace
id|mm-&gt;start_data
op_assign
id|seg-&gt;addr
suffix:semicolon
macro_line|#ifndef CONFIG_MMU
id|mm-&gt;end_data
op_assign
id|seg-&gt;addr
op_plus
id|phdr-&gt;p_memsz
suffix:semicolon
macro_line|#endif
)brace
macro_line|#ifdef CONFIG_MMU
r_if
c_cond
(paren
id|seg-&gt;addr
op_plus
id|phdr-&gt;p_memsz
OG
id|mm-&gt;end_data
)paren
id|mm-&gt;end_data
op_assign
id|seg-&gt;addr
op_plus
id|phdr-&gt;p_memsz
suffix:semicolon
macro_line|#endif
)brace
id|seg
op_increment
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* end elf_fdpic_map_file_constdisp_on_uclinux() */
macro_line|#endif
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * map a binary by direct mmap() of the individual PT_LOAD segments&n; */
DECL|function|elf_fdpic_map_file_by_direct_mmap
r_static
r_int
id|elf_fdpic_map_file_by_direct_mmap
c_func
(paren
r_struct
id|elf_fdpic_params
op_star
id|params
comma
r_struct
id|file
op_star
id|file
comma
r_struct
id|mm_struct
op_star
id|mm
)paren
(brace
r_struct
id|elf32_fdpic_loadseg
op_star
id|seg
suffix:semicolon
r_struct
id|elf32_phdr
op_star
id|phdr
suffix:semicolon
r_int
r_int
id|load_addr
comma
id|delta_vaddr
suffix:semicolon
r_int
id|loop
comma
id|dvset
suffix:semicolon
id|load_addr
op_assign
id|params-&gt;load_addr
suffix:semicolon
id|delta_vaddr
op_assign
l_int|0
suffix:semicolon
id|dvset
op_assign
l_int|0
suffix:semicolon
id|seg
op_assign
id|params-&gt;loadmap-&gt;segs
suffix:semicolon
multiline_comment|/* deal with each load segment separately */
id|phdr
op_assign
id|params-&gt;phdrs
suffix:semicolon
r_for
c_loop
(paren
id|loop
op_assign
l_int|0
suffix:semicolon
id|loop
OL
id|params-&gt;hdr.e_phnum
suffix:semicolon
id|loop
op_increment
comma
id|phdr
op_increment
)paren
(brace
r_int
r_int
id|maddr
comma
id|disp
comma
id|excess
comma
id|excess1
suffix:semicolon
r_int
id|prot
op_assign
l_int|0
comma
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|phdr-&gt;p_type
op_ne
id|PT_LOAD
)paren
r_continue
suffix:semicolon
id|kdebug
c_func
(paren
l_string|&quot;[LOAD] va=%lx of=%lx fs=%lx ms=%lx&quot;
comma
(paren
r_int
r_int
)paren
id|phdr-&gt;p_vaddr
comma
(paren
r_int
r_int
)paren
id|phdr-&gt;p_offset
comma
(paren
r_int
r_int
)paren
id|phdr-&gt;p_filesz
comma
(paren
r_int
r_int
)paren
id|phdr-&gt;p_memsz
)paren
suffix:semicolon
multiline_comment|/* determine the mapping parameters */
r_if
c_cond
(paren
id|phdr-&gt;p_flags
op_amp
id|PF_R
)paren
id|prot
op_or_assign
id|PROT_READ
suffix:semicolon
r_if
c_cond
(paren
id|phdr-&gt;p_flags
op_amp
id|PF_W
)paren
id|prot
op_or_assign
id|PROT_WRITE
suffix:semicolon
r_if
c_cond
(paren
id|phdr-&gt;p_flags
op_amp
id|PF_X
)paren
id|prot
op_or_assign
id|PROT_EXEC
suffix:semicolon
id|flags
op_assign
id|MAP_PRIVATE
op_or
id|MAP_DENYWRITE
suffix:semicolon
r_if
c_cond
(paren
id|params-&gt;flags
op_amp
id|ELF_FDPIC_FLAG_EXECUTABLE
)paren
id|flags
op_or_assign
id|MAP_EXECUTABLE
suffix:semicolon
id|maddr
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|params-&gt;flags
op_amp
id|ELF_FDPIC_FLAG_ARRANGEMENT
)paren
(brace
r_case
id|ELF_FDPIC_FLAG_INDEPENDENT
suffix:colon
multiline_comment|/* PT_LOADs are independently locatable */
r_break
suffix:semicolon
r_case
id|ELF_FDPIC_FLAG_HONOURVADDR
suffix:colon
multiline_comment|/* the specified virtual address must be honoured */
id|maddr
op_assign
id|phdr-&gt;p_vaddr
suffix:semicolon
id|flags
op_or_assign
id|MAP_FIXED
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ELF_FDPIC_FLAG_CONSTDISP
suffix:colon
multiline_comment|/* constant displacement&n;&t;&t;&t; * - can be mapped anywhere, but must be mapped as a unit&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|dvset
)paren
(brace
id|maddr
op_assign
id|load_addr
suffix:semicolon
id|delta_vaddr
op_assign
id|phdr-&gt;p_vaddr
suffix:semicolon
id|dvset
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|maddr
op_assign
id|load_addr
op_plus
id|phdr-&gt;p_vaddr
op_minus
id|delta_vaddr
suffix:semicolon
id|flags
op_or_assign
id|MAP_FIXED
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|ELF_FDPIC_FLAG_CONTIGUOUS
suffix:colon
multiline_comment|/* contiguity handled later */
r_break
suffix:semicolon
r_default
suffix:colon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
id|maddr
op_and_assign
id|PAGE_MASK
suffix:semicolon
multiline_comment|/* create the mapping */
id|disp
op_assign
id|phdr-&gt;p_vaddr
op_amp
op_complement
id|PAGE_MASK
suffix:semicolon
id|down_write
c_func
(paren
op_amp
id|mm-&gt;mmap_sem
)paren
suffix:semicolon
id|maddr
op_assign
id|do_mmap
c_func
(paren
id|file
comma
id|maddr
comma
id|phdr-&gt;p_memsz
op_plus
id|disp
comma
id|prot
comma
id|flags
comma
id|phdr-&gt;p_offset
op_minus
id|disp
)paren
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|mm-&gt;mmap_sem
)paren
suffix:semicolon
id|kdebug
c_func
(paren
l_string|&quot;mmap[%d] &lt;file&gt; sz=%lx pr=%x fl=%x of=%lx --&gt; %08lx&quot;
comma
id|loop
comma
id|phdr-&gt;p_memsz
op_plus
id|disp
comma
id|prot
comma
id|flags
comma
id|phdr-&gt;p_offset
op_minus
id|disp
comma
id|maddr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
(paren
r_void
op_star
)paren
id|maddr
)paren
)paren
r_return
(paren
r_int
)paren
id|maddr
suffix:semicolon
r_if
c_cond
(paren
(paren
id|params-&gt;flags
op_amp
id|ELF_FDPIC_FLAG_ARRANGEMENT
)paren
op_eq
id|ELF_FDPIC_FLAG_CONTIGUOUS
)paren
id|load_addr
op_add_assign
id|PAGE_ALIGN
c_func
(paren
id|phdr-&gt;p_memsz
op_plus
id|disp
)paren
suffix:semicolon
id|seg-&gt;addr
op_assign
id|maddr
op_plus
id|disp
suffix:semicolon
id|seg-&gt;p_vaddr
op_assign
id|phdr-&gt;p_vaddr
suffix:semicolon
id|seg-&gt;p_memsz
op_assign
id|phdr-&gt;p_memsz
suffix:semicolon
multiline_comment|/* map the ELF header address if in this segment */
r_if
c_cond
(paren
id|phdr-&gt;p_offset
op_eq
l_int|0
)paren
id|params-&gt;elfhdr_addr
op_assign
id|seg-&gt;addr
suffix:semicolon
multiline_comment|/* clear the bit between beginning of mapping and beginning of PT_LOAD */
r_if
c_cond
(paren
id|prot
op_amp
id|PROT_WRITE
op_logical_and
id|disp
OG
l_int|0
)paren
(brace
id|kdebug
c_func
(paren
l_string|&quot;clear[%d] ad=%lx sz=%lx&quot;
comma
id|loop
comma
id|maddr
comma
id|disp
)paren
suffix:semicolon
id|clear_user
c_func
(paren
(paren
r_void
op_star
)paren
id|maddr
comma
id|disp
)paren
suffix:semicolon
id|maddr
op_add_assign
id|disp
suffix:semicolon
)brace
multiline_comment|/* clear any space allocated but not loaded&n;&t;&t; * - on uClinux we can just clear the lot&n;&t;&t; * - on MMU linux we&squot;ll get a SIGBUS beyond the last page&n;&t;&t; *   extant in the file&n;&t;&t; */
id|excess
op_assign
id|phdr-&gt;p_memsz
op_minus
id|phdr-&gt;p_filesz
suffix:semicolon
id|excess1
op_assign
id|PAGE_SIZE
op_minus
(paren
(paren
id|maddr
op_plus
id|phdr-&gt;p_filesz
)paren
op_amp
op_complement
id|PAGE_MASK
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_MMU
r_if
c_cond
(paren
id|excess
OG
id|excess1
)paren
(brace
r_int
r_int
id|xaddr
op_assign
id|maddr
op_plus
id|phdr-&gt;p_filesz
op_plus
id|excess1
suffix:semicolon
r_int
r_int
id|xmaddr
suffix:semicolon
id|flags
op_or_assign
id|MAP_FIXED
op_or
id|MAP_ANONYMOUS
suffix:semicolon
id|down_write
c_func
(paren
op_amp
id|mm-&gt;mmap_sem
)paren
suffix:semicolon
id|xmaddr
op_assign
id|do_mmap
c_func
(paren
l_int|NULL
comma
id|xaddr
comma
id|excess
op_minus
id|excess1
comma
id|prot
comma
id|flags
comma
l_int|0
)paren
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|mm-&gt;mmap_sem
)paren
suffix:semicolon
id|kdebug
c_func
(paren
l_string|&quot;mmap[%d] &lt;anon&gt;&quot;
l_string|&quot; ad=%lx sz=%lx pr=%x fl=%x of=0 --&gt; %08lx&quot;
comma
id|loop
comma
id|xaddr
comma
id|excess
op_minus
id|excess1
comma
id|prot
comma
id|flags
comma
id|xmaddr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|xmaddr
op_ne
id|xaddr
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_if
c_cond
(paren
id|prot
op_amp
id|PROT_WRITE
op_logical_and
id|excess1
OG
l_int|0
)paren
(brace
id|kdebug
c_func
(paren
l_string|&quot;clear[%d] ad=%lx sz=%lx&quot;
comma
id|loop
comma
id|maddr
op_plus
id|phdr-&gt;p_filesz
comma
id|excess1
)paren
suffix:semicolon
id|clear_user
c_func
(paren
(paren
r_void
op_star
)paren
id|maddr
op_plus
id|phdr-&gt;p_filesz
comma
id|excess1
)paren
suffix:semicolon
)brace
macro_line|#else
r_if
c_cond
(paren
id|excess
OG
l_int|0
)paren
(brace
id|kdebug
c_func
(paren
l_string|&quot;clear[%d] ad=%lx sz=%lx&quot;
comma
id|loop
comma
id|maddr
op_plus
id|phdr-&gt;p_filesz
comma
id|excess
)paren
suffix:semicolon
id|clear_user
c_func
(paren
(paren
r_void
op_star
)paren
id|maddr
op_plus
id|phdr-&gt;p_filesz
comma
id|excess
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|mm
)paren
(brace
r_if
c_cond
(paren
id|phdr-&gt;p_flags
op_amp
id|PF_X
)paren
(brace
id|mm-&gt;start_code
op_assign
id|maddr
suffix:semicolon
id|mm-&gt;end_code
op_assign
id|maddr
op_plus
id|phdr-&gt;p_memsz
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|mm-&gt;start_data
)paren
(brace
id|mm-&gt;start_data
op_assign
id|maddr
suffix:semicolon
id|mm-&gt;end_data
op_assign
id|maddr
op_plus
id|phdr-&gt;p_memsz
suffix:semicolon
)brace
)brace
id|seg
op_increment
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* end elf_fdpic_map_file_by_direct_mmap() */
eof
