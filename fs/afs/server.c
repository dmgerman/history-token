multiline_comment|/* server.c: AFS server record management&n; *&n; * Copyright (C) 2002 Red Hat, Inc. All Rights Reserved.&n; * Written by David Howells (dhowells@redhat.com)&n; *&n; * This program is free software; you can redistribute it and/or&n; * modify it under the terms of the GNU General Public License&n; * as published by the Free Software Foundation; either version&n; * 2 of the License, or (at your option) any later version.&n; */
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;rxrpc/peer.h&gt;
macro_line|#include &lt;rxrpc/connection.h&gt;
macro_line|#include &quot;volume.h&quot;
macro_line|#include &quot;cell.h&quot;
macro_line|#include &quot;server.h&quot;
macro_line|#include &quot;transport.h&quot;
macro_line|#include &quot;vlclient.h&quot;
macro_line|#include &quot;kafstimod.h&quot;
macro_line|#include &quot;internal.h&quot;
DECL|variable|afs_server_peer_lock
id|spinlock_t
id|afs_server_peer_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
DECL|macro|FS_SERVICE_ID
mdefine_line|#define FS_SERVICE_ID&t;&t;1&t;/* AFS Volume Location Service ID */
DECL|macro|VL_SERVICE_ID
mdefine_line|#define VL_SERVICE_ID&t;&t;52&t;/* AFS Volume Location Service ID */
DECL|function|__afs_server_timeout
r_static
r_void
id|__afs_server_timeout
c_func
(paren
id|afs_timer_t
op_star
id|timer
)paren
(brace
id|afs_server_t
op_star
id|server
op_assign
id|list_entry
c_func
(paren
id|timer
comma
id|afs_server_t
comma
id|timeout
)paren
suffix:semicolon
id|_debug
c_func
(paren
l_string|&quot;SERVER TIMEOUT [%p{u=%d}]&quot;
comma
id|server
comma
id|atomic_read
c_func
(paren
op_amp
id|server-&gt;usage
)paren
)paren
suffix:semicolon
id|afs_server_do_timeout
c_func
(paren
id|server
)paren
suffix:semicolon
)brace
DECL|variable|afs_server_timer_ops
r_static
r_const
r_struct
id|afs_timer_ops
id|afs_server_timer_ops
op_assign
(brace
dot
id|timed_out
op_assign
id|__afs_server_timeout
comma
)brace
suffix:semicolon
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * lookup a server record in a cell&n; * - TODO: search the cell&squot;s server list&n; */
DECL|function|afs_server_lookup
r_int
id|afs_server_lookup
c_func
(paren
id|afs_cell_t
op_star
id|cell
comma
r_const
r_struct
id|in_addr
op_star
id|addr
comma
id|afs_server_t
op_star
op_star
id|_server
)paren
(brace
r_struct
id|list_head
op_star
id|_p
suffix:semicolon
id|afs_server_t
op_star
id|server
comma
op_star
id|active
comma
op_star
id|zombie
suffix:semicolon
r_int
id|loop
suffix:semicolon
id|_enter
c_func
(paren
l_string|&quot;%p,%08x,&quot;
comma
id|cell
comma
id|ntohl
c_func
(paren
id|addr-&gt;s_addr
)paren
)paren
suffix:semicolon
multiline_comment|/* allocate and initialise a server record */
id|server
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|afs_server_t
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|server
)paren
(brace
id|_leave
c_func
(paren
l_string|&quot; = -ENOMEM&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|memset
c_func
(paren
id|server
comma
l_int|0
comma
r_sizeof
(paren
id|afs_server_t
)paren
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|server-&gt;usage
comma
l_int|1
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|server-&gt;link
)paren
suffix:semicolon
id|init_rwsem
c_func
(paren
op_amp
id|server-&gt;sem
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|server-&gt;fs_callq
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|server-&gt;fs_lock
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|server-&gt;cb_promises
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|server-&gt;cb_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|loop
op_assign
l_int|0
suffix:semicolon
id|loop
OL
id|AFS_SERVER_CONN_LIST_SIZE
suffix:semicolon
id|loop
op_increment
)paren
id|server-&gt;fs_conn_cnt
(braket
id|loop
)braket
op_assign
l_int|4
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|server-&gt;addr
comma
id|addr
comma
r_sizeof
(paren
r_struct
id|in_addr
)paren
)paren
suffix:semicolon
id|server-&gt;addr.s_addr
op_assign
id|addr-&gt;s_addr
suffix:semicolon
id|afs_timer_init
c_func
(paren
op_amp
id|server-&gt;timeout
comma
op_amp
id|afs_server_timer_ops
)paren
suffix:semicolon
multiline_comment|/* add to the cell */
id|write_lock
c_func
(paren
op_amp
id|cell-&gt;sv_lock
)paren
suffix:semicolon
multiline_comment|/* check the active list */
id|list_for_each
c_func
(paren
id|_p
comma
op_amp
id|cell-&gt;sv_list
)paren
(brace
id|active
op_assign
id|list_entry
c_func
(paren
id|_p
comma
id|afs_server_t
comma
id|link
)paren
suffix:semicolon
r_if
c_cond
(paren
id|active-&gt;addr.s_addr
op_eq
id|addr-&gt;s_addr
)paren
r_goto
id|use_active_server
suffix:semicolon
)brace
multiline_comment|/* check the inactive list */
id|spin_lock
c_func
(paren
op_amp
id|cell-&gt;sv_gylock
)paren
suffix:semicolon
id|list_for_each
c_func
(paren
id|_p
comma
op_amp
id|cell-&gt;sv_graveyard
)paren
(brace
id|zombie
op_assign
id|list_entry
c_func
(paren
id|_p
comma
id|afs_server_t
comma
id|link
)paren
suffix:semicolon
r_if
c_cond
(paren
id|zombie-&gt;addr.s_addr
op_eq
id|addr-&gt;s_addr
)paren
r_goto
id|resurrect_server
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|cell-&gt;sv_gylock
)paren
suffix:semicolon
id|afs_get_cell
c_func
(paren
id|cell
)paren
suffix:semicolon
id|server-&gt;cell
op_assign
id|cell
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|server-&gt;link
comma
op_amp
id|cell-&gt;sv_list
)paren
suffix:semicolon
id|write_unlock
c_func
(paren
op_amp
id|cell-&gt;sv_lock
)paren
suffix:semicolon
op_star
id|_server
op_assign
id|server
suffix:semicolon
id|_leave
c_func
(paren
l_string|&quot; = 0 (%p)&quot;
comma
id|server
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/* found a matching active server */
id|use_active_server
suffix:colon
id|_debug
c_func
(paren
l_string|&quot;active server&quot;
)paren
suffix:semicolon
id|afs_get_server
c_func
(paren
id|active
)paren
suffix:semicolon
id|write_unlock
c_func
(paren
op_amp
id|cell-&gt;sv_lock
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|server
)paren
suffix:semicolon
op_star
id|_server
op_assign
id|active
suffix:semicolon
id|_leave
c_func
(paren
l_string|&quot; = 0 (%p)&quot;
comma
id|active
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/* found a matching server in the graveyard, so resurrect it and dispose of the new rec */
id|resurrect_server
suffix:colon
id|_debug
c_func
(paren
l_string|&quot;resurrecting server&quot;
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|zombie-&gt;link
)paren
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|zombie-&gt;link
comma
op_amp
id|cell-&gt;sv_list
)paren
suffix:semicolon
id|afs_get_server
c_func
(paren
id|zombie
)paren
suffix:semicolon
id|afs_kafstimod_del_timer
c_func
(paren
op_amp
id|zombie-&gt;timeout
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|cell-&gt;sv_gylock
)paren
suffix:semicolon
id|write_unlock
c_func
(paren
op_amp
id|cell-&gt;sv_lock
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|server
)paren
suffix:semicolon
op_star
id|_server
op_assign
id|zombie
suffix:semicolon
id|_leave
c_func
(paren
l_string|&quot; = 0 (%p)&quot;
comma
id|zombie
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* end afs_server_lookup() */
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * destroy a server record&n; * - removes from the cell list&n; */
DECL|function|afs_put_server
r_void
id|afs_put_server
c_func
(paren
id|afs_server_t
op_star
id|server
)paren
(brace
id|afs_cell_t
op_star
id|cell
suffix:semicolon
id|_enter
c_func
(paren
l_string|&quot;%p&quot;
comma
id|server
)paren
suffix:semicolon
id|cell
op_assign
id|server-&gt;cell
suffix:semicolon
multiline_comment|/* sanity check */
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|server-&gt;usage
)paren
op_le
l_int|0
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* to prevent a race, the decrement and the dequeue must be effectively atomic */
id|write_lock
c_func
(paren
op_amp
id|cell-&gt;sv_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
op_logical_neg
id|atomic_dec_and_test
c_func
(paren
op_amp
id|server-&gt;usage
)paren
)paren
)paren
(brace
id|write_unlock
c_func
(paren
op_amp
id|cell-&gt;sv_lock
)paren
suffix:semicolon
id|_leave
c_func
(paren
l_string|&quot;&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|spin_lock
c_func
(paren
op_amp
id|cell-&gt;sv_gylock
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|server-&gt;link
)paren
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|server-&gt;link
comma
op_amp
id|cell-&gt;sv_graveyard
)paren
suffix:semicolon
multiline_comment|/* time out in 10 secs */
id|afs_kafstimod_add_timer
c_func
(paren
op_amp
id|server-&gt;timeout
comma
l_int|10
op_star
id|HZ
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|cell-&gt;sv_gylock
)paren
suffix:semicolon
id|write_unlock
c_func
(paren
op_amp
id|cell-&gt;sv_lock
)paren
suffix:semicolon
id|_leave
c_func
(paren
l_string|&quot; [killed]&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* end afs_put_server() */
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * timeout server record&n; * - removes from the cell&squot;s graveyard if the usage count is zero&n; */
DECL|function|afs_server_do_timeout
r_void
id|afs_server_do_timeout
c_func
(paren
id|afs_server_t
op_star
id|server
)paren
(brace
r_struct
id|rxrpc_peer
op_star
id|peer
suffix:semicolon
id|afs_cell_t
op_star
id|cell
suffix:semicolon
r_int
id|loop
suffix:semicolon
id|_enter
c_func
(paren
l_string|&quot;%p&quot;
comma
id|server
)paren
suffix:semicolon
id|cell
op_assign
id|server-&gt;cell
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|server-&gt;usage
)paren
OL
l_int|0
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* remove from graveyard if still dead */
id|spin_lock
c_func
(paren
op_amp
id|cell-&gt;vl_gylock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|server-&gt;usage
)paren
op_eq
l_int|0
)paren
id|list_del_init
c_func
(paren
op_amp
id|server-&gt;link
)paren
suffix:semicolon
r_else
id|server
op_assign
l_int|NULL
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|cell-&gt;vl_gylock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|server
)paren
(brace
id|_leave
c_func
(paren
l_string|&quot;&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
multiline_comment|/* resurrected */
)brace
multiline_comment|/* we can now destroy it properly */
id|afs_put_cell
c_func
(paren
id|cell
)paren
suffix:semicolon
multiline_comment|/* uncross-point the structs under a global lock */
id|spin_lock
c_func
(paren
op_amp
id|afs_server_peer_lock
)paren
suffix:semicolon
id|peer
op_assign
id|server-&gt;peer
suffix:semicolon
r_if
c_cond
(paren
id|peer
)paren
(brace
id|server-&gt;peer
op_assign
l_int|NULL
suffix:semicolon
id|peer-&gt;user
op_assign
l_int|NULL
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|afs_server_peer_lock
)paren
suffix:semicolon
multiline_comment|/* finish cleaning up the server */
r_for
c_loop
(paren
id|loop
op_assign
id|AFS_SERVER_CONN_LIST_SIZE
op_minus
l_int|1
suffix:semicolon
id|loop
op_ge
l_int|0
suffix:semicolon
id|loop
op_decrement
)paren
r_if
c_cond
(paren
id|server-&gt;fs_conn
(braket
id|loop
)braket
)paren
id|rxrpc_put_connection
c_func
(paren
id|server-&gt;fs_conn
(braket
id|loop
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|server-&gt;vlserver
)paren
id|rxrpc_put_connection
c_func
(paren
id|server-&gt;vlserver
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|server
)paren
suffix:semicolon
id|_leave
c_func
(paren
l_string|&quot; [destroyed]&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* end afs_server_do_timeout() */
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * get a callslot on a connection to the fileserver on the specified server&n; */
DECL|function|afs_server_request_callslot
r_int
id|afs_server_request_callslot
c_func
(paren
id|afs_server_t
op_star
id|server
comma
r_struct
id|afs_server_callslot
op_star
id|callslot
)paren
(brace
r_struct
id|afs_server_callslot
op_star
id|pcallslot
suffix:semicolon
r_struct
id|rxrpc_connection
op_star
id|conn
suffix:semicolon
r_int
id|nconn
comma
id|ret
suffix:semicolon
id|_enter
c_func
(paren
l_string|&quot;%p,&quot;
comma
id|server
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|callslot-&gt;link
)paren
suffix:semicolon
id|callslot-&gt;task
op_assign
id|current
suffix:semicolon
id|callslot-&gt;conn
op_assign
l_int|NULL
suffix:semicolon
id|callslot-&gt;nconn
op_assign
op_minus
l_int|1
suffix:semicolon
id|callslot-&gt;ready
op_assign
l_int|0
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
id|conn
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* get hold of a callslot first */
id|spin_lock
c_func
(paren
op_amp
id|server-&gt;fs_lock
)paren
suffix:semicolon
multiline_comment|/* resurrect the server if it&squot;s death timeout has expired */
r_if
c_cond
(paren
id|server-&gt;fs_state
)paren
(brace
r_if
c_cond
(paren
id|time_before
c_func
(paren
id|jiffies
comma
id|server-&gt;fs_dead_jif
)paren
)paren
(brace
id|ret
op_assign
id|server-&gt;fs_state
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|server-&gt;fs_lock
)paren
suffix:semicolon
id|_leave
c_func
(paren
l_string|&quot; = %d [still dead]&quot;
comma
id|ret
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
id|server-&gt;fs_state
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* try and find a connection that has spare callslots */
r_for
c_loop
(paren
id|nconn
op_assign
l_int|0
suffix:semicolon
id|nconn
OL
id|AFS_SERVER_CONN_LIST_SIZE
suffix:semicolon
id|nconn
op_increment
)paren
(brace
r_if
c_cond
(paren
id|server-&gt;fs_conn_cnt
(braket
id|nconn
)braket
OG
l_int|0
)paren
(brace
id|server-&gt;fs_conn_cnt
(braket
id|nconn
)braket
op_decrement
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|server-&gt;fs_lock
)paren
suffix:semicolon
id|callslot-&gt;nconn
op_assign
id|nconn
suffix:semicolon
r_goto
id|obtained_slot
suffix:semicolon
)brace
)brace
multiline_comment|/* none were available - wait interruptibly for one to become available */
id|set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|callslot-&gt;link
comma
op_amp
id|server-&gt;fs_callq
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|server-&gt;fs_lock
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|callslot-&gt;ready
op_logical_and
op_logical_neg
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
)brace
id|set_current_state
c_func
(paren
id|TASK_RUNNING
)paren
suffix:semicolon
multiline_comment|/* even if we were interrupted we may still be queued */
r_if
c_cond
(paren
op_logical_neg
id|callslot-&gt;ready
)paren
(brace
id|spin_lock
c_func
(paren
op_amp
id|server-&gt;fs_lock
)paren
suffix:semicolon
id|list_del_init
c_func
(paren
op_amp
id|callslot-&gt;link
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|server-&gt;fs_lock
)paren
suffix:semicolon
)brace
id|nconn
op_assign
id|callslot-&gt;nconn
suffix:semicolon
multiline_comment|/* if interrupted, we must release any slot we also got before returning an error */
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
id|ret
op_assign
op_minus
id|EINTR
suffix:semicolon
r_goto
id|error_release
suffix:semicolon
)brace
multiline_comment|/* if we were woken up with an error, then pass that error back to the called */
r_if
c_cond
(paren
id|nconn
OL
l_int|0
)paren
(brace
id|_leave
c_func
(paren
l_string|&quot; = %d&quot;
comma
id|callslot-&gt;errno
)paren
suffix:semicolon
r_return
id|callslot-&gt;errno
suffix:semicolon
)brace
multiline_comment|/* were we given a connection directly? */
r_if
c_cond
(paren
id|callslot-&gt;conn
)paren
(brace
multiline_comment|/* yes - use it */
id|_leave
c_func
(paren
l_string|&quot; = 0 (nc=%d)&quot;
comma
id|nconn
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* got a callslot, but no connection */
id|obtained_slot
suffix:colon
multiline_comment|/* need to get hold of the RxRPC connection */
id|down_write
c_func
(paren
op_amp
id|server-&gt;sem
)paren
suffix:semicolon
multiline_comment|/* quick check to see if there&squot;s an outstanding error */
id|ret
op_assign
id|server-&gt;fs_state
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_goto
id|error_release_upw
suffix:semicolon
r_if
c_cond
(paren
id|server-&gt;fs_conn
(braket
id|nconn
)braket
)paren
(brace
multiline_comment|/* reuse an existing connection */
id|rxrpc_get_connection
c_func
(paren
id|server-&gt;fs_conn
(braket
id|nconn
)braket
)paren
suffix:semicolon
id|callslot-&gt;conn
op_assign
id|server-&gt;fs_conn
(braket
id|nconn
)braket
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* create a new connection */
id|ret
op_assign
id|rxrpc_create_connection
c_func
(paren
id|afs_transport
comma
id|htons
c_func
(paren
l_int|7000
)paren
comma
id|server-&gt;addr.s_addr
comma
id|FS_SERVICE_ID
comma
l_int|NULL
comma
op_amp
id|server-&gt;fs_conn
(braket
id|nconn
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
r_goto
id|error_release_upw
suffix:semicolon
id|callslot-&gt;conn
op_assign
id|server-&gt;fs_conn
(braket
l_int|0
)braket
suffix:semicolon
id|rxrpc_get_connection
c_func
(paren
id|callslot-&gt;conn
)paren
suffix:semicolon
)brace
id|up_write
c_func
(paren
op_amp
id|server-&gt;sem
)paren
suffix:semicolon
id|_leave
c_func
(paren
l_string|&quot; = 0&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/* handle an error occurring */
id|error_release_upw
suffix:colon
id|up_write
c_func
(paren
op_amp
id|server-&gt;sem
)paren
suffix:semicolon
id|error_release
suffix:colon
multiline_comment|/* either release the callslot or pass it along to another deserving task */
id|spin_lock
c_func
(paren
op_amp
id|server-&gt;fs_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nconn
OL
l_int|0
)paren
(brace
multiline_comment|/* no callslot allocated */
)brace
r_else
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|server-&gt;fs_callq
)paren
)paren
(brace
multiline_comment|/* no one waiting */
id|server-&gt;fs_conn_cnt
(braket
id|nconn
)braket
op_increment
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|server-&gt;fs_lock
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* someone&squot;s waiting - dequeue them and wake them up */
id|pcallslot
op_assign
id|list_entry
c_func
(paren
id|server-&gt;fs_callq.next
comma
r_struct
id|afs_server_callslot
comma
id|link
)paren
suffix:semicolon
id|list_del_init
c_func
(paren
op_amp
id|pcallslot-&gt;link
)paren
suffix:semicolon
id|pcallslot-&gt;errno
op_assign
id|server-&gt;fs_state
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pcallslot-&gt;errno
)paren
(brace
multiline_comment|/* pass them out callslot details */
id|callslot-&gt;conn
op_assign
id|xchg
c_func
(paren
op_amp
id|pcallslot-&gt;conn
comma
id|callslot-&gt;conn
)paren
suffix:semicolon
id|pcallslot-&gt;nconn
op_assign
id|nconn
suffix:semicolon
id|callslot-&gt;nconn
op_assign
id|nconn
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
id|pcallslot-&gt;ready
op_assign
l_int|1
suffix:semicolon
id|wake_up_process
c_func
(paren
id|pcallslot-&gt;task
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|server-&gt;fs_lock
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|callslot-&gt;conn
)paren
id|rxrpc_put_connection
c_func
(paren
id|callslot-&gt;conn
)paren
suffix:semicolon
id|callslot-&gt;conn
op_assign
l_int|NULL
suffix:semicolon
id|_leave
c_func
(paren
l_string|&quot; = %d&quot;
comma
id|ret
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* end afs_server_request_callslot() */
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * release a callslot back to the server&n; * - transfers the RxRPC connection to the next pending callslot if possible&n; */
DECL|function|afs_server_release_callslot
r_void
id|afs_server_release_callslot
c_func
(paren
id|afs_server_t
op_star
id|server
comma
r_struct
id|afs_server_callslot
op_star
id|callslot
)paren
(brace
r_struct
id|afs_server_callslot
op_star
id|pcallslot
suffix:semicolon
id|_enter
c_func
(paren
l_string|&quot;{ad=%08x,cnt=%u},{%d}&quot;
comma
id|ntohl
c_func
(paren
id|server-&gt;addr.s_addr
)paren
comma
id|server-&gt;fs_conn_cnt
(braket
id|callslot-&gt;nconn
)braket
comma
id|callslot-&gt;nconn
)paren
suffix:semicolon
r_if
c_cond
(paren
id|callslot-&gt;nconn
OL
l_int|0
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|server-&gt;fs_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|server-&gt;fs_callq
)paren
)paren
(brace
multiline_comment|/* no one waiting */
id|server-&gt;fs_conn_cnt
(braket
id|callslot-&gt;nconn
)braket
op_increment
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|server-&gt;fs_lock
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* someone&squot;s waiting - dequeue them and wake them up */
id|pcallslot
op_assign
id|list_entry
c_func
(paren
id|server-&gt;fs_callq.next
comma
r_struct
id|afs_server_callslot
comma
id|link
)paren
suffix:semicolon
id|list_del_init
c_func
(paren
op_amp
id|pcallslot-&gt;link
)paren
suffix:semicolon
id|pcallslot-&gt;errno
op_assign
id|server-&gt;fs_state
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pcallslot-&gt;errno
)paren
(brace
multiline_comment|/* pass them out callslot details */
id|callslot-&gt;conn
op_assign
id|xchg
c_func
(paren
op_amp
id|pcallslot-&gt;conn
comma
id|callslot-&gt;conn
)paren
suffix:semicolon
id|pcallslot-&gt;nconn
op_assign
id|callslot-&gt;nconn
suffix:semicolon
id|callslot-&gt;nconn
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
id|pcallslot-&gt;ready
op_assign
l_int|1
suffix:semicolon
id|wake_up_process
c_func
(paren
id|pcallslot-&gt;task
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|server-&gt;fs_lock
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|callslot-&gt;conn
)paren
id|rxrpc_put_connection
c_func
(paren
id|callslot-&gt;conn
)paren
suffix:semicolon
id|_leave
c_func
(paren
l_string|&quot;&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* end afs_server_release_callslot() */
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * get a handle to a connection to the vlserver (volume location) on the specified server&n; */
DECL|function|afs_server_get_vlconn
r_int
id|afs_server_get_vlconn
c_func
(paren
id|afs_server_t
op_star
id|server
comma
r_struct
id|rxrpc_connection
op_star
op_star
id|_conn
)paren
(brace
r_struct
id|rxrpc_connection
op_star
id|conn
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|_enter
c_func
(paren
l_string|&quot;%p,&quot;
comma
id|server
)paren
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
id|conn
op_assign
l_int|NULL
suffix:semicolon
id|down_read
c_func
(paren
op_amp
id|server-&gt;sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|server-&gt;vlserver
)paren
(brace
multiline_comment|/* reuse an existing connection */
id|rxrpc_get_connection
c_func
(paren
id|server-&gt;vlserver
)paren
suffix:semicolon
id|conn
op_assign
id|server-&gt;vlserver
suffix:semicolon
id|up_read
c_func
(paren
op_amp
id|server-&gt;sem
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* create a new connection */
id|up_read
c_func
(paren
op_amp
id|server-&gt;sem
)paren
suffix:semicolon
id|down_write
c_func
(paren
op_amp
id|server-&gt;sem
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|server-&gt;vlserver
)paren
(brace
id|ret
op_assign
id|rxrpc_create_connection
c_func
(paren
id|afs_transport
comma
id|htons
c_func
(paren
l_int|7003
)paren
comma
id|server-&gt;addr.s_addr
comma
id|VL_SERVICE_ID
comma
l_int|NULL
comma
op_amp
id|server-&gt;vlserver
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
id|rxrpc_get_connection
c_func
(paren
id|server-&gt;vlserver
)paren
suffix:semicolon
id|conn
op_assign
id|server-&gt;vlserver
suffix:semicolon
)brace
id|up_write
c_func
(paren
op_amp
id|server-&gt;sem
)paren
suffix:semicolon
)brace
op_star
id|_conn
op_assign
id|conn
suffix:semicolon
id|_leave
c_func
(paren
l_string|&quot; = %d&quot;
comma
id|ret
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* end afs_server_get_vlconn() */
eof
