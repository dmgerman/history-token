multiline_comment|/* volume.c: AFS volume management&n; *&n; * Copyright (C) 2002 Red Hat, Inc. All Rights Reserved.&n; * Written by David Howells (dhowells@redhat.com)&n; *&n; * This program is free software; you can redistribute it and/or&n; * modify it under the terms of the GNU General Public License&n; * as published by the Free Software Foundation; either version&n; * 2 of the License, or (at your option) any later version.&n; */
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/pagemap.h&gt;
macro_line|#include &quot;volume.h&quot;
macro_line|#include &quot;vnode.h&quot;
macro_line|#include &quot;cell.h&quot;
macro_line|#include &quot;cache.h&quot;
macro_line|#include &quot;cmservice.h&quot;
macro_line|#include &quot;fsclient.h&quot;
macro_line|#include &quot;vlclient.h&quot;
macro_line|#include &quot;internal.h&quot;
macro_line|#ifdef __KDEBUG
DECL|variable|afs_voltypes
r_static
r_const
r_char
op_star
id|afs_voltypes
(braket
)braket
op_assign
(brace
l_string|&quot;R/W&quot;
comma
l_string|&quot;R/O&quot;
comma
l_string|&quot;BAK&quot;
)brace
suffix:semicolon
macro_line|#endif
macro_line|#ifdef AFS_CACHING_SUPPORT
r_static
id|cachefs_match_val_t
id|afs_volume_cache_match
c_func
(paren
r_void
op_star
id|target
comma
r_const
r_void
op_star
id|entry
)paren
suffix:semicolon
r_static
r_void
id|afs_volume_cache_update
c_func
(paren
r_void
op_star
id|source
comma
r_void
op_star
id|entry
)paren
suffix:semicolon
DECL|variable|afs_volume_cache_index_def
r_struct
id|cachefs_index_def
id|afs_volume_cache_index_def
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;volume&quot;
comma
dot
id|data_size
op_assign
r_sizeof
(paren
r_struct
id|afs_cache_vhash
)paren
comma
dot
id|keys
(braket
l_int|0
)braket
op_assign
(brace
id|CACHEFS_INDEX_KEYS_BIN
comma
l_int|1
)brace
comma
dot
id|keys
(braket
l_int|1
)braket
op_assign
(brace
id|CACHEFS_INDEX_KEYS_BIN
comma
l_int|1
)brace
comma
dot
id|match
op_assign
id|afs_volume_cache_match
comma
dot
id|update
op_assign
id|afs_volume_cache_update
comma
)brace
suffix:semicolon
macro_line|#endif
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * lookup a volume by name&n; * - this can be one of the following:&n; *&t;&quot;%[cell:]volume[.]&quot;&t;&t;R/W volume&n; *&t;&quot;#[cell:]volume[.]&quot;&t;&t;R/O or R/W volume (rwparent=0),&n; *&t;&t;&t;&t;&t; or R/W (rwparent=1) volume&n; *&t;&quot;%[cell:]volume.readonly&quot;&t;R/O volume&n; *&t;&quot;#[cell:]volume.readonly&quot;&t;R/O volume&n; *&t;&quot;%[cell:]volume.backup&quot;&t;&t;Backup volume&n; *&t;&quot;#[cell:]volume.backup&quot;&t;&t;Backup volume&n; *&n; * The cell name is optional, and defaults to the current cell.&n; *&n; * See &quot;The Rules of Mount Point Traversal&quot; in Chapter 5 of the AFS SysAdmin&n; * Guide&n; * - Rule 1: Explicit type suffix forces access of that type or nothing&n; *           (no suffix, then use Rule 2 &amp; 3)&n; * - Rule 2: If parent volume is R/O, then mount R/O volume by preference, R/W&n; *           if not available&n; * - Rule 3: If parent volume is R/W, then only mount R/W volume unless&n; *           explicitly told otherwise&n; */
DECL|function|afs_volume_lookup
r_int
id|afs_volume_lookup
c_func
(paren
r_const
r_char
op_star
id|name
comma
r_struct
id|afs_cell
op_star
id|cell
comma
r_int
id|rwpath
comma
r_struct
id|afs_volume
op_star
op_star
id|_volume
)paren
(brace
r_struct
id|afs_vlocation
op_star
id|vlocation
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|afs_volume
op_star
id|volume
op_assign
l_int|NULL
suffix:semicolon
id|afs_voltype_t
id|type
suffix:semicolon
r_const
r_char
op_star
id|cellname
comma
op_star
id|volname
comma
op_star
id|suffix
suffix:semicolon
r_char
id|srvtmask
suffix:semicolon
r_int
id|force
comma
id|ret
comma
id|loop
comma
id|cellnamesz
comma
id|volnamesz
suffix:semicolon
id|_enter
c_func
(paren
l_string|&quot;%s,,%d,&quot;
comma
id|name
comma
id|rwpath
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|name
op_logical_or
(paren
id|name
(braket
l_int|0
)braket
op_ne
l_char|&squot;%&squot;
op_logical_and
id|name
(braket
l_int|0
)braket
op_ne
l_char|&squot;#&squot;
)paren
op_logical_or
op_logical_neg
id|name
(braket
l_int|1
)braket
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;kAFS: unparsable volume name&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* determine the type of volume we&squot;re looking for */
id|force
op_assign
l_int|0
suffix:semicolon
id|type
op_assign
id|AFSVL_ROVOL
suffix:semicolon
r_if
c_cond
(paren
id|rwpath
op_logical_or
id|name
(braket
l_int|0
)braket
op_eq
l_char|&squot;%&squot;
)paren
(brace
id|type
op_assign
id|AFSVL_RWVOL
suffix:semicolon
id|force
op_assign
l_int|1
suffix:semicolon
)brace
id|suffix
op_assign
id|strrchr
c_func
(paren
id|name
comma
l_char|&squot;.&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|suffix
)paren
(brace
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|suffix
comma
l_string|&quot;.readonly&quot;
)paren
op_eq
l_int|0
)paren
(brace
id|type
op_assign
id|AFSVL_ROVOL
suffix:semicolon
id|force
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|suffix
comma
l_string|&quot;.backup&quot;
)paren
op_eq
l_int|0
)paren
(brace
id|type
op_assign
id|AFSVL_BACKVOL
suffix:semicolon
id|force
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|suffix
(braket
l_int|1
)braket
op_eq
l_int|0
)paren
(brace
)brace
r_else
(brace
id|suffix
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
multiline_comment|/* split the cell and volume names */
id|name
op_increment
suffix:semicolon
id|volname
op_assign
id|strchr
c_func
(paren
id|name
comma
l_char|&squot;:&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|volname
)paren
(brace
id|cellname
op_assign
id|name
suffix:semicolon
id|cellnamesz
op_assign
id|volname
op_minus
id|name
suffix:semicolon
id|volname
op_increment
suffix:semicolon
)brace
r_else
(brace
id|volname
op_assign
id|name
suffix:semicolon
id|cellname
op_assign
l_int|NULL
suffix:semicolon
id|cellnamesz
op_assign
l_int|0
suffix:semicolon
)brace
id|volnamesz
op_assign
id|suffix
ques
c_cond
id|suffix
op_minus
id|volname
suffix:colon
id|strlen
c_func
(paren
id|volname
)paren
suffix:semicolon
id|_debug
c_func
(paren
l_string|&quot;CELL:%*.*s [%p] VOLUME:%*.*s SUFFIX:%s TYPE:%d%s&quot;
comma
id|cellnamesz
comma
id|cellnamesz
comma
id|cellname
ques
c_cond
suffix:colon
l_string|&quot;&quot;
comma
id|cell
comma
id|volnamesz
comma
id|volnamesz
comma
id|volname
comma
id|suffix
ques
c_cond
suffix:colon
l_string|&quot;-&quot;
comma
id|type
comma
id|force
ques
c_cond
l_string|&quot; FORCE&quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
multiline_comment|/* lookup the cell record */
r_if
c_cond
(paren
id|cellname
op_logical_or
op_logical_neg
id|cell
)paren
(brace
id|ret
op_assign
id|afs_cell_lookup
c_func
(paren
id|cellname
comma
id|cellnamesz
comma
op_amp
id|cell
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;kAFS: unable to lookup cell &squot;%s&squot;&bslash;n&quot;
comma
id|cellname
ques
c_cond
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
)brace
r_else
(brace
id|afs_get_cell
c_func
(paren
id|cell
)paren
suffix:semicolon
)brace
multiline_comment|/* lookup the volume location record */
id|ret
op_assign
id|afs_vlocation_lookup
c_func
(paren
id|cell
comma
id|volname
comma
id|volnamesz
comma
op_amp
id|vlocation
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
r_goto
id|error
suffix:semicolon
multiline_comment|/* make the final decision on the type we want */
id|ret
op_assign
op_minus
id|ENOMEDIUM
suffix:semicolon
r_if
c_cond
(paren
id|force
op_logical_and
op_logical_neg
(paren
id|vlocation-&gt;vldb.vidmask
op_amp
(paren
l_int|1
op_lshift
id|type
)paren
)paren
)paren
r_goto
id|error
suffix:semicolon
id|srvtmask
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|loop
op_assign
l_int|0
suffix:semicolon
id|loop
OL
id|vlocation-&gt;vldb.nservers
suffix:semicolon
id|loop
op_increment
)paren
id|srvtmask
op_or_assign
id|vlocation-&gt;vldb.srvtmask
(braket
id|loop
)braket
suffix:semicolon
r_if
c_cond
(paren
id|force
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|srvtmask
op_amp
(paren
l_int|1
op_lshift
id|type
)paren
)paren
)paren
r_goto
id|error
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|srvtmask
op_amp
id|AFS_VOL_VTM_RO
)paren
(brace
id|type
op_assign
id|AFSVL_ROVOL
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|srvtmask
op_amp
id|AFS_VOL_VTM_RW
)paren
(brace
id|type
op_assign
id|AFSVL_RWVOL
suffix:semicolon
)brace
r_else
(brace
r_goto
id|error
suffix:semicolon
)brace
id|down_write
c_func
(paren
op_amp
id|cell-&gt;vl_sem
)paren
suffix:semicolon
multiline_comment|/* is the volume already active? */
r_if
c_cond
(paren
id|vlocation-&gt;vols
(braket
id|type
)braket
)paren
(brace
multiline_comment|/* yes - re-use it */
id|volume
op_assign
id|vlocation-&gt;vols
(braket
id|type
)braket
suffix:semicolon
id|afs_get_volume
c_func
(paren
id|volume
)paren
suffix:semicolon
r_goto
id|success
suffix:semicolon
)brace
multiline_comment|/* create a new volume record */
id|_debug
c_func
(paren
l_string|&quot;creating new volume record&quot;
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|ENOMEM
suffix:semicolon
id|volume
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|afs_volume
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|volume
)paren
r_goto
id|error_up
suffix:semicolon
id|memset
c_func
(paren
id|volume
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|afs_volume
)paren
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|volume-&gt;usage
comma
l_int|1
)paren
suffix:semicolon
id|volume-&gt;type
op_assign
id|type
suffix:semicolon
id|volume-&gt;type_force
op_assign
id|force
suffix:semicolon
id|volume-&gt;cell
op_assign
id|cell
suffix:semicolon
id|volume-&gt;vid
op_assign
id|vlocation-&gt;vldb.vid
(braket
id|type
)braket
suffix:semicolon
id|init_rwsem
c_func
(paren
op_amp
id|volume-&gt;server_sem
)paren
suffix:semicolon
multiline_comment|/* look up all the applicable server records */
r_for
c_loop
(paren
id|loop
op_assign
l_int|0
suffix:semicolon
id|loop
OL
l_int|8
suffix:semicolon
id|loop
op_increment
)paren
(brace
r_if
c_cond
(paren
id|vlocation-&gt;vldb.srvtmask
(braket
id|loop
)braket
op_amp
(paren
l_int|1
op_lshift
id|volume-&gt;type
)paren
)paren
(brace
id|ret
op_assign
id|afs_server_lookup
c_func
(paren
id|volume-&gt;cell
comma
op_amp
id|vlocation-&gt;vldb.servers
(braket
id|loop
)braket
comma
op_amp
id|volume-&gt;servers
(braket
id|volume-&gt;nservers
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
r_goto
id|error_discard
suffix:semicolon
id|volume-&gt;nservers
op_increment
suffix:semicolon
)brace
)brace
multiline_comment|/* attach the cache and volume location */
macro_line|#ifdef AFS_CACHING_SUPPORT
id|cachefs_acquire_cookie
c_func
(paren
id|vlocation-&gt;cache
comma
op_amp
id|afs_vnode_cache_index_def
comma
id|volume
comma
op_amp
id|volume-&gt;cache
)paren
suffix:semicolon
macro_line|#endif
id|afs_get_vlocation
c_func
(paren
id|vlocation
)paren
suffix:semicolon
id|volume-&gt;vlocation
op_assign
id|vlocation
suffix:semicolon
id|vlocation-&gt;vols
(braket
id|type
)braket
op_assign
id|volume
suffix:semicolon
id|success
suffix:colon
id|_debug
c_func
(paren
l_string|&quot;kAFS selected %s volume %08x&quot;
comma
id|afs_voltypes
(braket
id|volume-&gt;type
)braket
comma
id|volume-&gt;vid
)paren
suffix:semicolon
op_star
id|_volume
op_assign
id|volume
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* clean up */
id|error_up
suffix:colon
id|up_write
c_func
(paren
op_amp
id|cell-&gt;vl_sem
)paren
suffix:semicolon
id|error
suffix:colon
id|afs_put_vlocation
c_func
(paren
id|vlocation
)paren
suffix:semicolon
id|afs_put_cell
c_func
(paren
id|cell
)paren
suffix:semicolon
id|_leave
c_func
(paren
l_string|&quot; = %d (%p)&quot;
comma
id|ret
comma
id|volume
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
id|error_discard
suffix:colon
id|up_write
c_func
(paren
op_amp
id|cell-&gt;vl_sem
)paren
suffix:semicolon
r_for
c_loop
(paren
id|loop
op_assign
id|volume-&gt;nservers
op_minus
l_int|1
suffix:semicolon
id|loop
op_ge
l_int|0
suffix:semicolon
id|loop
op_decrement
)paren
id|afs_put_server
c_func
(paren
id|volume-&gt;servers
(braket
id|loop
)braket
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|volume
)paren
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
multiline_comment|/* end afs_volume_lookup() */
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * destroy a volume record&n; */
DECL|function|afs_put_volume
r_void
id|afs_put_volume
c_func
(paren
r_struct
id|afs_volume
op_star
id|volume
)paren
(brace
r_struct
id|afs_vlocation
op_star
id|vlocation
suffix:semicolon
r_int
id|loop
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|volume
)paren
r_return
suffix:semicolon
id|_enter
c_func
(paren
l_string|&quot;%p&quot;
comma
id|volume
)paren
suffix:semicolon
id|vlocation
op_assign
id|volume-&gt;vlocation
suffix:semicolon
multiline_comment|/* sanity check */
id|BUG_ON
c_func
(paren
id|atomic_read
c_func
(paren
op_amp
id|volume-&gt;usage
)paren
op_le
l_int|0
)paren
suffix:semicolon
multiline_comment|/* to prevent a race, the decrement and the dequeue must be effectively&n;&t; * atomic */
id|down_write
c_func
(paren
op_amp
id|vlocation-&gt;cell-&gt;vl_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
op_logical_neg
id|atomic_dec_and_test
c_func
(paren
op_amp
id|volume-&gt;usage
)paren
)paren
)paren
(brace
id|up_write
c_func
(paren
op_amp
id|vlocation-&gt;cell-&gt;vl_sem
)paren
suffix:semicolon
id|_leave
c_func
(paren
l_string|&quot;&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|vlocation-&gt;vols
(braket
id|volume-&gt;type
)braket
op_assign
l_int|NULL
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|vlocation-&gt;cell-&gt;vl_sem
)paren
suffix:semicolon
multiline_comment|/* finish cleaning up the volume */
macro_line|#ifdef AFS_CACHING_SUPPORT
id|cachefs_relinquish_cookie
c_func
(paren
id|volume-&gt;cache
comma
l_int|0
)paren
suffix:semicolon
macro_line|#endif
id|afs_put_vlocation
c_func
(paren
id|vlocation
)paren
suffix:semicolon
r_for
c_loop
(paren
id|loop
op_assign
id|volume-&gt;nservers
op_minus
l_int|1
suffix:semicolon
id|loop
op_ge
l_int|0
suffix:semicolon
id|loop
op_decrement
)paren
id|afs_put_server
c_func
(paren
id|volume-&gt;servers
(braket
id|loop
)braket
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|volume
)paren
suffix:semicolon
id|_leave
c_func
(paren
l_string|&quot; [destroyed]&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* end afs_put_volume() */
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * pick a server to use to try accessing this volume&n; * - returns with an elevated usage count on the server chosen&n; */
DECL|function|afs_volume_pick_fileserver
r_int
id|afs_volume_pick_fileserver
c_func
(paren
r_struct
id|afs_volume
op_star
id|volume
comma
r_struct
id|afs_server
op_star
op_star
id|_server
)paren
(brace
r_struct
id|afs_server
op_star
id|server
suffix:semicolon
r_int
id|ret
comma
id|state
comma
id|loop
suffix:semicolon
id|_enter
c_func
(paren
l_string|&quot;%s&quot;
comma
id|volume-&gt;vlocation-&gt;vldb.name
)paren
suffix:semicolon
id|down_read
c_func
(paren
op_amp
id|volume-&gt;server_sem
)paren
suffix:semicolon
multiline_comment|/* handle the no-server case */
r_if
c_cond
(paren
id|volume-&gt;nservers
op_eq
l_int|0
)paren
(brace
id|ret
op_assign
id|volume-&gt;rjservers
ques
c_cond
op_minus
id|ENOMEDIUM
suffix:colon
op_minus
id|ESTALE
suffix:semicolon
id|up_read
c_func
(paren
op_amp
id|volume-&gt;server_sem
)paren
suffix:semicolon
id|_leave
c_func
(paren
l_string|&quot; = %d [no servers]&quot;
comma
id|ret
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* basically, just search the list for the first live server and use&n;&t; * that */
id|ret
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|loop
op_assign
l_int|0
suffix:semicolon
id|loop
OL
id|volume-&gt;nservers
suffix:semicolon
id|loop
op_increment
)paren
(brace
id|server
op_assign
id|volume-&gt;servers
(braket
id|loop
)braket
suffix:semicolon
id|state
op_assign
id|server-&gt;fs_state
suffix:semicolon
r_switch
c_cond
(paren
id|state
)paren
(brace
multiline_comment|/* found an apparently healthy server */
r_case
l_int|0
suffix:colon
id|afs_get_server
c_func
(paren
id|server
)paren
suffix:semicolon
id|up_read
c_func
(paren
op_amp
id|volume-&gt;server_sem
)paren
suffix:semicolon
op_star
id|_server
op_assign
id|server
suffix:semicolon
id|_leave
c_func
(paren
l_string|&quot; = 0 (picked %08x)&quot;
comma
id|ntohl
c_func
(paren
id|server-&gt;addr.s_addr
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
op_minus
id|ENETUNREACH
suffix:colon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
id|ret
op_assign
id|state
suffix:semicolon
r_break
suffix:semicolon
r_case
op_minus
id|EHOSTUNREACH
suffix:colon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
op_logical_or
id|ret
op_eq
op_minus
id|ENETUNREACH
)paren
id|ret
op_assign
id|state
suffix:semicolon
r_break
suffix:semicolon
r_case
op_minus
id|ECONNREFUSED
suffix:colon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
op_logical_or
id|ret
op_eq
op_minus
id|ENETUNREACH
op_logical_or
id|ret
op_eq
op_minus
id|EHOSTUNREACH
)paren
id|ret
op_assign
id|state
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
r_case
op_minus
id|EREMOTEIO
suffix:colon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
op_logical_or
id|ret
op_eq
op_minus
id|ENETUNREACH
op_logical_or
id|ret
op_eq
op_minus
id|EHOSTUNREACH
op_logical_or
id|ret
op_eq
op_minus
id|ECONNREFUSED
)paren
id|ret
op_assign
id|state
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* no available servers&n;&t; * - TODO: handle the no active servers case better&n;&t; */
id|up_read
c_func
(paren
op_amp
id|volume-&gt;server_sem
)paren
suffix:semicolon
id|_leave
c_func
(paren
l_string|&quot; = %d&quot;
comma
id|ret
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* end afs_volume_pick_fileserver() */
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * release a server after use&n; * - releases the ref on the server struct that was acquired by picking&n; * - records result of using a particular server to access a volume&n; * - return 0 to try again, 1 if okay or to issue error&n; */
DECL|function|afs_volume_release_fileserver
r_int
id|afs_volume_release_fileserver
c_func
(paren
r_struct
id|afs_volume
op_star
id|volume
comma
r_struct
id|afs_server
op_star
id|server
comma
r_int
id|result
)paren
(brace
r_int
id|loop
suffix:semicolon
id|_enter
c_func
(paren
l_string|&quot;%s,%08x,%d&quot;
comma
id|volume-&gt;vlocation-&gt;vldb.name
comma
id|ntohl
c_func
(paren
id|server-&gt;addr.s_addr
)paren
comma
id|result
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|result
)paren
(brace
multiline_comment|/* success */
r_case
l_int|0
suffix:colon
id|server-&gt;fs_act_jif
op_assign
id|jiffies
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* the fileserver denied all knowledge of the volume */
r_case
op_minus
id|ENOMEDIUM
suffix:colon
id|server-&gt;fs_act_jif
op_assign
id|jiffies
suffix:semicolon
id|down_write
c_func
(paren
op_amp
id|volume-&gt;server_sem
)paren
suffix:semicolon
multiline_comment|/* first, find where the server is in the active list (if it&n;&t;&t; * is) */
r_for
c_loop
(paren
id|loop
op_assign
l_int|0
suffix:semicolon
id|loop
OL
id|volume-&gt;nservers
suffix:semicolon
id|loop
op_increment
)paren
r_if
c_cond
(paren
id|volume-&gt;servers
(braket
id|loop
)braket
op_eq
id|server
)paren
r_goto
id|present
suffix:semicolon
multiline_comment|/* no longer there - may have been discarded by another op */
r_goto
id|try_next_server_upw
suffix:semicolon
id|present
suffix:colon
id|volume-&gt;nservers
op_decrement
suffix:semicolon
id|memmove
c_func
(paren
op_amp
id|volume-&gt;servers
(braket
id|loop
)braket
comma
op_amp
id|volume-&gt;servers
(braket
id|loop
op_plus
l_int|1
)braket
comma
r_sizeof
(paren
id|volume-&gt;servers
(braket
id|loop
)braket
)paren
op_star
(paren
id|volume-&gt;nservers
op_minus
id|loop
)paren
)paren
suffix:semicolon
id|volume-&gt;servers
(braket
id|volume-&gt;nservers
)braket
op_assign
l_int|NULL
suffix:semicolon
id|afs_put_server
c_func
(paren
id|server
)paren
suffix:semicolon
id|volume-&gt;rjservers
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|volume-&gt;nservers
OG
l_int|0
)paren
multiline_comment|/* another server might acknowledge its existence */
r_goto
id|try_next_server_upw
suffix:semicolon
multiline_comment|/* handle the case where all the fileservers have rejected the&n;&t;&t; * volume&n;&t;&t; * - TODO: try asking the fileservers for volume information&n;&t;&t; * - TODO: contact the VL server again to see if the volume is&n;&t;&t; *         no longer registered&n;&t;&t; */
id|up_write
c_func
(paren
op_amp
id|volume-&gt;server_sem
)paren
suffix:semicolon
id|afs_put_server
c_func
(paren
id|server
)paren
suffix:semicolon
id|_leave
c_func
(paren
l_string|&quot; [completely rejected]&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
multiline_comment|/* problem reaching the server */
r_case
op_minus
id|ENETUNREACH
suffix:colon
r_case
op_minus
id|EHOSTUNREACH
suffix:colon
r_case
op_minus
id|ECONNREFUSED
suffix:colon
r_case
op_minus
id|ETIMEDOUT
suffix:colon
r_case
op_minus
id|EREMOTEIO
suffix:colon
multiline_comment|/* mark the server as dead&n;&t;&t; * TODO: vary dead timeout depending on error&n;&t;&t; */
id|spin_lock
c_func
(paren
op_amp
id|server-&gt;fs_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|server-&gt;fs_state
)paren
(brace
id|server-&gt;fs_dead_jif
op_assign
id|jiffies
op_plus
id|HZ
op_star
l_int|10
suffix:semicolon
id|server-&gt;fs_state
op_assign
id|result
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;kAFS: SERVER DEAD state=%d&bslash;n&quot;
comma
id|result
)paren
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|server-&gt;fs_lock
)paren
suffix:semicolon
r_goto
id|try_next_server
suffix:semicolon
multiline_comment|/* miscellaneous error */
r_default
suffix:colon
id|server-&gt;fs_act_jif
op_assign
id|jiffies
suffix:semicolon
r_case
op_minus
id|ENOMEM
suffix:colon
r_case
op_minus
id|ENONET
suffix:colon
r_break
suffix:semicolon
)brace
multiline_comment|/* tell the caller to accept the result */
id|afs_put_server
c_func
(paren
id|server
)paren
suffix:semicolon
id|_leave
c_func
(paren
l_string|&quot;&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
multiline_comment|/* tell the caller to loop around and try the next server */
id|try_next_server_upw
suffix:colon
id|up_write
c_func
(paren
op_amp
id|volume-&gt;server_sem
)paren
suffix:semicolon
id|try_next_server
suffix:colon
id|afs_put_server
c_func
(paren
id|server
)paren
suffix:semicolon
id|_leave
c_func
(paren
l_string|&quot; [try next server]&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* end afs_volume_release_fileserver() */
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * match a volume hash record stored in the cache&n; */
macro_line|#ifdef AFS_CACHING_SUPPORT
DECL|function|afs_volume_cache_match
r_static
id|cachefs_match_val_t
id|afs_volume_cache_match
c_func
(paren
r_void
op_star
id|target
comma
r_const
r_void
op_star
id|entry
)paren
(brace
r_const
r_struct
id|afs_cache_vhash
op_star
id|vhash
op_assign
id|entry
suffix:semicolon
r_struct
id|afs_volume
op_star
id|volume
op_assign
id|target
suffix:semicolon
id|_enter
c_func
(paren
l_string|&quot;{%u},{%u}&quot;
comma
id|volume-&gt;type
comma
id|vhash-&gt;vtype
)paren
suffix:semicolon
r_if
c_cond
(paren
id|volume-&gt;type
op_eq
id|vhash-&gt;vtype
)paren
(brace
id|_leave
c_func
(paren
l_string|&quot; = SUCCESS&quot;
)paren
suffix:semicolon
r_return
id|CACHEFS_MATCH_SUCCESS
suffix:semicolon
)brace
id|_leave
c_func
(paren
l_string|&quot; = FAILED&quot;
)paren
suffix:semicolon
r_return
id|CACHEFS_MATCH_FAILED
suffix:semicolon
)brace
multiline_comment|/* end afs_volume_cache_match() */
macro_line|#endif
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * update a volume hash record stored in the cache&n; */
macro_line|#ifdef AFS_CACHING_SUPPORT
DECL|function|afs_volume_cache_update
r_static
r_void
id|afs_volume_cache_update
c_func
(paren
r_void
op_star
id|source
comma
r_void
op_star
id|entry
)paren
(brace
r_struct
id|afs_cache_vhash
op_star
id|vhash
op_assign
id|entry
suffix:semicolon
r_struct
id|afs_volume
op_star
id|volume
op_assign
id|source
suffix:semicolon
id|_enter
c_func
(paren
l_string|&quot;&quot;
)paren
suffix:semicolon
id|vhash-&gt;vtype
op_assign
id|volume-&gt;type
suffix:semicolon
)brace
multiline_comment|/* end afs_volume_cache_update() */
macro_line|#endif
eof
