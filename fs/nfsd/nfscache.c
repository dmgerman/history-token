multiline_comment|/*&n; * linux/fs/nfsd/nfscache.c&n; *&n; * Request reply cache. This is currently a global cache, but this may&n; * change in the future and be a per-client cache.&n; *&n; * This code is heavily inspired by the 44BSD implementation, although&n; * it does things a bit differently.&n; *&n; * Copyright (C) 1995, 1996 Olaf Kirch &lt;okir@monad.swb.de&gt;&n; */
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/time.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/list.h&gt;
macro_line|#include &lt;linux/sunrpc/svc.h&gt;
macro_line|#include &lt;linux/nfsd/nfsd.h&gt;
macro_line|#include &lt;linux/nfsd/cache.h&gt;
multiline_comment|/* Size of reply cache. Common values are:&n; * 4.3BSD:&t;128&n; * 4.4BSD:&t;256&n; * Solaris2:&t;1024&n; * DEC Unix:&t;512-4096&n; */
DECL|macro|CACHESIZE
mdefine_line|#define CACHESIZE&t;&t;1024
DECL|macro|HASHSIZE
mdefine_line|#define HASHSIZE&t;&t;64
DECL|macro|REQHASH
mdefine_line|#define REQHASH(xid)&t;&t;((((xid) &gt;&gt; 24) ^ (xid)) &amp; (HASHSIZE-1))
DECL|variable|hash_list
r_static
r_struct
id|hlist_head
op_star
id|hash_list
suffix:semicolon
DECL|variable|lru_head
r_static
r_struct
id|list_head
id|lru_head
suffix:semicolon
DECL|variable|cache_disabled
r_static
r_int
id|cache_disabled
op_assign
l_int|1
suffix:semicolon
r_static
r_int
id|nfsd_cache_append
c_func
(paren
r_struct
id|svc_rqst
op_star
id|rqstp
comma
r_struct
id|kvec
op_star
id|vec
)paren
suffix:semicolon
multiline_comment|/* &n; * locking for the reply cache:&n; * A cache entry is &quot;single use&quot; if c_state == RC_INPROG&n; * Otherwise, it when accessing _prev or _next, the lock must be held.&n; */
r_static
id|DEFINE_SPINLOCK
c_func
(paren
id|cache_lock
)paren
suffix:semicolon
r_void
DECL|function|nfsd_cache_init
id|nfsd_cache_init
c_func
(paren
r_void
)paren
(brace
r_struct
id|svc_cacherep
op_star
id|rp
suffix:semicolon
r_int
id|i
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|lru_head
)paren
suffix:semicolon
id|i
op_assign
id|CACHESIZE
suffix:semicolon
r_while
c_loop
(paren
id|i
)paren
(brace
id|rp
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|rp
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rp
)paren
r_break
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|rp-&gt;c_lru
comma
op_amp
id|lru_head
)paren
suffix:semicolon
id|rp-&gt;c_state
op_assign
id|RC_UNUSED
suffix:semicolon
id|rp-&gt;c_type
op_assign
id|RC_NOCACHE
suffix:semicolon
id|INIT_HLIST_NODE
c_func
(paren
op_amp
id|rp-&gt;c_hash
)paren
suffix:semicolon
id|i
op_decrement
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
)paren
id|printk
(paren
id|KERN_ERR
l_string|&quot;nfsd: cannot allocate all %d cache entries, only got %d&bslash;n&quot;
comma
id|CACHESIZE
comma
id|CACHESIZE
op_minus
id|i
)paren
suffix:semicolon
id|hash_list
op_assign
id|kmalloc
(paren
id|HASHSIZE
op_star
r_sizeof
(paren
r_struct
id|hlist_head
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hash_list
)paren
(brace
id|nfsd_cache_shutdown
c_func
(paren
)paren
suffix:semicolon
id|printk
(paren
id|KERN_ERR
l_string|&quot;nfsd: cannot allocate %Zd bytes for hash list&bslash;n&quot;
comma
id|HASHSIZE
op_star
r_sizeof
(paren
r_struct
id|hlist_head
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|memset
c_func
(paren
id|hash_list
comma
l_int|0
comma
id|HASHSIZE
op_star
r_sizeof
(paren
r_struct
id|hlist_head
)paren
)paren
suffix:semicolon
id|cache_disabled
op_assign
l_int|0
suffix:semicolon
)brace
r_void
DECL|function|nfsd_cache_shutdown
id|nfsd_cache_shutdown
c_func
(paren
r_void
)paren
(brace
r_struct
id|svc_cacherep
op_star
id|rp
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|lru_head
)paren
)paren
(brace
id|rp
op_assign
id|list_entry
c_func
(paren
id|lru_head.next
comma
r_struct
id|svc_cacherep
comma
id|c_lru
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rp-&gt;c_state
op_eq
id|RC_DONE
op_logical_and
id|rp-&gt;c_type
op_eq
id|RC_REPLBUFF
)paren
id|kfree
c_func
(paren
id|rp-&gt;c_replvec.iov_base
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|rp-&gt;c_lru
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|rp
)paren
suffix:semicolon
)brace
id|cache_disabled
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|hash_list
)paren
id|kfree
(paren
id|hash_list
)paren
suffix:semicolon
id|hash_list
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * Move cache entry to end of LRU list&n; */
r_static
r_void
DECL|function|lru_put_end
id|lru_put_end
c_func
(paren
r_struct
id|svc_cacherep
op_star
id|rp
)paren
(brace
id|list_del
c_func
(paren
op_amp
id|rp-&gt;c_lru
)paren
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|rp-&gt;c_lru
comma
op_amp
id|lru_head
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Move a cache entry from one hash list to another&n; */
r_static
r_void
DECL|function|hash_refile
id|hash_refile
c_func
(paren
r_struct
id|svc_cacherep
op_star
id|rp
)paren
(brace
id|hlist_del_init
c_func
(paren
op_amp
id|rp-&gt;c_hash
)paren
suffix:semicolon
id|hlist_add_head
c_func
(paren
op_amp
id|rp-&gt;c_hash
comma
id|hash_list
op_plus
id|REQHASH
c_func
(paren
id|rp-&gt;c_xid
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Try to find an entry matching the current call in the cache. When none&n; * is found, we grab the oldest unlocked entry off the LRU list.&n; * Note that no operation within the loop may sleep.&n; */
r_int
DECL|function|nfsd_cache_lookup
id|nfsd_cache_lookup
c_func
(paren
r_struct
id|svc_rqst
op_star
id|rqstp
comma
r_int
id|type
)paren
(brace
r_struct
id|hlist_node
op_star
id|hn
suffix:semicolon
r_struct
id|hlist_head
op_star
id|rh
suffix:semicolon
r_struct
id|svc_cacherep
op_star
id|rp
suffix:semicolon
id|u32
id|xid
op_assign
id|rqstp-&gt;rq_xid
comma
id|proto
op_assign
id|rqstp-&gt;rq_prot
comma
id|vers
op_assign
id|rqstp-&gt;rq_vers
comma
id|proc
op_assign
id|rqstp-&gt;rq_proc
suffix:semicolon
r_int
r_int
id|age
suffix:semicolon
r_int
id|rtn
suffix:semicolon
id|rqstp-&gt;rq_cacherep
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|cache_disabled
op_logical_or
id|type
op_eq
id|RC_NOCACHE
)paren
(brace
id|nfsdstats.rcnocache
op_increment
suffix:semicolon
r_return
id|RC_DOIT
suffix:semicolon
)brace
id|spin_lock
c_func
(paren
op_amp
id|cache_lock
)paren
suffix:semicolon
id|rtn
op_assign
id|RC_DOIT
suffix:semicolon
id|rh
op_assign
op_amp
id|hash_list
(braket
id|REQHASH
c_func
(paren
id|xid
)paren
)braket
suffix:semicolon
id|hlist_for_each_entry
c_func
(paren
id|rp
comma
id|hn
comma
id|rh
comma
id|c_hash
)paren
(brace
r_if
c_cond
(paren
id|rp-&gt;c_state
op_ne
id|RC_UNUSED
op_logical_and
id|xid
op_eq
id|rp-&gt;c_xid
op_logical_and
id|proc
op_eq
id|rp-&gt;c_proc
op_logical_and
id|proto
op_eq
id|rp-&gt;c_prot
op_logical_and
id|vers
op_eq
id|rp-&gt;c_vers
op_logical_and
id|time_before
c_func
(paren
id|jiffies
comma
id|rp-&gt;c_timestamp
op_plus
l_int|120
op_star
id|HZ
)paren
op_logical_and
id|memcmp
c_func
(paren
(paren
r_char
op_star
)paren
op_amp
id|rqstp-&gt;rq_addr
comma
(paren
r_char
op_star
)paren
op_amp
id|rp-&gt;c_addr
comma
r_sizeof
(paren
id|rp-&gt;c_addr
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|nfsdstats.rchits
op_increment
suffix:semicolon
r_goto
id|found_entry
suffix:semicolon
)brace
)brace
id|nfsdstats.rcmisses
op_increment
suffix:semicolon
multiline_comment|/* This loop shouldn&squot;t take more than a few iterations normally */
(brace
r_int
id|safe
op_assign
l_int|0
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|rp
comma
op_amp
id|lru_head
comma
id|c_lru
)paren
(brace
r_if
c_cond
(paren
id|rp-&gt;c_state
op_ne
id|RC_INPROG
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|safe
op_increment
OG
id|CACHESIZE
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;nfsd: loop in repcache LRU list&bslash;n&quot;
)paren
suffix:semicolon
id|cache_disabled
op_assign
l_int|1
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* This should not happen */
r_if
c_cond
(paren
id|rp
op_eq
l_int|NULL
)paren
(brace
r_static
r_int
id|complaints
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;nfsd: all repcache entries locked!&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|complaints
OG
l_int|5
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;nfsd: disabling repcache.&bslash;n&quot;
)paren
suffix:semicolon
id|cache_disabled
op_assign
l_int|1
suffix:semicolon
)brace
r_goto
id|out
suffix:semicolon
)brace
id|rqstp-&gt;rq_cacherep
op_assign
id|rp
suffix:semicolon
id|rp-&gt;c_state
op_assign
id|RC_INPROG
suffix:semicolon
id|rp-&gt;c_xid
op_assign
id|xid
suffix:semicolon
id|rp-&gt;c_proc
op_assign
id|proc
suffix:semicolon
id|rp-&gt;c_addr
op_assign
id|rqstp-&gt;rq_addr
suffix:semicolon
id|rp-&gt;c_prot
op_assign
id|proto
suffix:semicolon
id|rp-&gt;c_vers
op_assign
id|vers
suffix:semicolon
id|rp-&gt;c_timestamp
op_assign
id|jiffies
suffix:semicolon
id|hash_refile
c_func
(paren
id|rp
)paren
suffix:semicolon
multiline_comment|/* release any buffer */
r_if
c_cond
(paren
id|rp-&gt;c_type
op_eq
id|RC_REPLBUFF
)paren
(brace
id|kfree
c_func
(paren
id|rp-&gt;c_replvec.iov_base
)paren
suffix:semicolon
id|rp-&gt;c_replvec.iov_base
op_assign
l_int|NULL
suffix:semicolon
)brace
id|rp-&gt;c_type
op_assign
id|RC_NOCACHE
suffix:semicolon
id|out
suffix:colon
id|spin_unlock
c_func
(paren
op_amp
id|cache_lock
)paren
suffix:semicolon
r_return
id|rtn
suffix:semicolon
id|found_entry
suffix:colon
multiline_comment|/* We found a matching entry which is either in progress or done. */
id|age
op_assign
id|jiffies
op_minus
id|rp-&gt;c_timestamp
suffix:semicolon
id|rp-&gt;c_timestamp
op_assign
id|jiffies
suffix:semicolon
id|lru_put_end
c_func
(paren
id|rp
)paren
suffix:semicolon
id|rtn
op_assign
id|RC_DROPIT
suffix:semicolon
multiline_comment|/* Request being processed or excessive rexmits */
r_if
c_cond
(paren
id|rp-&gt;c_state
op_eq
id|RC_INPROG
op_logical_or
id|age
OL
id|RC_DELAY
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* From the hall of fame of impractical attacks:&n;&t; * Is this a user who tries to snoop on the cache? */
id|rtn
op_assign
id|RC_DOIT
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rqstp-&gt;rq_secure
op_logical_and
id|rp-&gt;c_secure
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* Compose RPC reply header */
r_switch
c_cond
(paren
id|rp-&gt;c_type
)paren
(brace
r_case
id|RC_NOCACHE
suffix:colon
r_break
suffix:semicolon
r_case
id|RC_REPLSTAT
suffix:colon
id|svc_putu32
c_func
(paren
op_amp
id|rqstp-&gt;rq_res.head
(braket
l_int|0
)braket
comma
id|rp-&gt;c_replstat
)paren
suffix:semicolon
id|rtn
op_assign
id|RC_REPLY
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RC_REPLBUFF
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|nfsd_cache_append
c_func
(paren
id|rqstp
comma
op_amp
id|rp-&gt;c_replvec
)paren
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* should not happen */
id|rtn
op_assign
id|RC_REPLY
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;nfsd: bad repcache type %d&bslash;n&quot;
comma
id|rp-&gt;c_type
)paren
suffix:semicolon
id|rp-&gt;c_state
op_assign
id|RC_UNUSED
suffix:semicolon
)brace
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n; * Update a cache entry. This is called from nfsd_dispatch when&n; * the procedure has been executed and the complete reply is in&n; * rqstp-&gt;rq_res.&n; *&n; * We&squot;re copying around data here rather than swapping buffers because&n; * the toplevel loop requires max-sized buffers, which would be a waste&n; * of memory for a cache with a max reply size of 100 bytes (diropokres).&n; *&n; * If we should start to use different types of cache entries tailored&n; * specifically for attrstat and fh&squot;s, we may save even more space.&n; *&n; * Also note that a cachetype of RC_NOCACHE can legally be passed when&n; * nfsd failed to encode a reply that otherwise would have been cached.&n; * In this case, nfsd_cache_update is called with statp == NULL.&n; */
r_void
DECL|function|nfsd_cache_update
id|nfsd_cache_update
c_func
(paren
r_struct
id|svc_rqst
op_star
id|rqstp
comma
r_int
id|cachetype
comma
id|u32
op_star
id|statp
)paren
(brace
r_struct
id|svc_cacherep
op_star
id|rp
suffix:semicolon
r_struct
id|kvec
op_star
id|resv
op_assign
op_amp
id|rqstp-&gt;rq_res.head
(braket
l_int|0
)braket
comma
op_star
id|cachv
suffix:semicolon
r_int
id|len
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|rp
op_assign
id|rqstp-&gt;rq_cacherep
)paren
op_logical_or
id|cache_disabled
)paren
r_return
suffix:semicolon
id|len
op_assign
id|resv-&gt;iov_len
op_minus
(paren
(paren
r_char
op_star
)paren
id|statp
op_minus
(paren
r_char
op_star
)paren
id|resv-&gt;iov_base
)paren
suffix:semicolon
id|len
op_rshift_assign
l_int|2
suffix:semicolon
multiline_comment|/* Don&squot;t cache excessive amounts of data and XDR failures */
r_if
c_cond
(paren
op_logical_neg
id|statp
op_logical_or
id|len
OG
(paren
l_int|256
op_rshift
l_int|2
)paren
)paren
(brace
id|rp-&gt;c_state
op_assign
id|RC_UNUSED
suffix:semicolon
r_return
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|cachetype
)paren
(brace
r_case
id|RC_REPLSTAT
suffix:colon
r_if
c_cond
(paren
id|len
op_ne
l_int|1
)paren
id|printk
c_func
(paren
l_string|&quot;nfsd: RC_REPLSTAT/reply len %d!&bslash;n&quot;
comma
id|len
)paren
suffix:semicolon
id|rp-&gt;c_replstat
op_assign
op_star
id|statp
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RC_REPLBUFF
suffix:colon
id|cachv
op_assign
op_amp
id|rp-&gt;c_replvec
suffix:semicolon
id|cachv-&gt;iov_base
op_assign
id|kmalloc
c_func
(paren
id|len
op_lshift
l_int|2
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cachv-&gt;iov_base
)paren
(brace
id|spin_lock
c_func
(paren
op_amp
id|cache_lock
)paren
suffix:semicolon
id|rp-&gt;c_state
op_assign
id|RC_UNUSED
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|cache_lock
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|cachv-&gt;iov_len
op_assign
id|len
op_lshift
l_int|2
suffix:semicolon
id|memcpy
c_func
(paren
id|cachv-&gt;iov_base
comma
id|statp
comma
id|len
op_lshift
l_int|2
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|spin_lock
c_func
(paren
op_amp
id|cache_lock
)paren
suffix:semicolon
id|lru_put_end
c_func
(paren
id|rp
)paren
suffix:semicolon
id|rp-&gt;c_secure
op_assign
id|rqstp-&gt;rq_secure
suffix:semicolon
id|rp-&gt;c_type
op_assign
id|cachetype
suffix:semicolon
id|rp-&gt;c_state
op_assign
id|RC_DONE
suffix:semicolon
id|rp-&gt;c_timestamp
op_assign
id|jiffies
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|cache_lock
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * Copy cached reply to current reply buffer. Should always fit.&n; * FIXME as reply is in a page, we should just attach the page, and&n; * keep a refcount....&n; */
r_static
r_int
DECL|function|nfsd_cache_append
id|nfsd_cache_append
c_func
(paren
r_struct
id|svc_rqst
op_star
id|rqstp
comma
r_struct
id|kvec
op_star
id|data
)paren
(brace
r_struct
id|kvec
op_star
id|vec
op_assign
op_amp
id|rqstp-&gt;rq_res.head
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
id|vec-&gt;iov_len
op_plus
id|data-&gt;iov_len
OG
id|PAGE_SIZE
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;nfsd: cached reply too large (%Zd).&bslash;n&quot;
comma
id|data-&gt;iov_len
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|memcpy
c_func
(paren
(paren
r_char
op_star
)paren
id|vec-&gt;iov_base
op_plus
id|vec-&gt;iov_len
comma
id|data-&gt;iov_base
comma
id|data-&gt;iov_len
)paren
suffix:semicolon
id|vec-&gt;iov_len
op_add_assign
id|data-&gt;iov_len
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
eof
