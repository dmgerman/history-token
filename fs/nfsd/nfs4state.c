multiline_comment|/*&n;*  linux/fs/nfsd/nfs4state.c&n;*&n;*  Copyright (c) 2001 The Regents of the University of Michigan.&n;*  All rights reserved.&n;*&n;*  Kendrick Smith &lt;kmsmith@umich.edu&gt;&n;*  Andy Adamson &lt;kandros@umich.edu&gt;&n;*&n;*  Redistribution and use in source and binary forms, with or without&n;*  modification, are permitted provided that the following conditions&n;*  are met:&n;*&n;*  1. Redistributions of source code must retain the above copyright&n;*     notice, this list of conditions and the following disclaimer.&n;*  2. Redistributions in binary form must reproduce the above copyright&n;*     notice, this list of conditions and the following disclaimer in the&n;*     documentation and/or other materials provided with the distribution.&n;*  3. Neither the name of the University nor the names of its&n;*     contributors may be used to endorse or promote products derived&n;*     from this software without specific prior written permission.&n;*&n;*  THIS SOFTWARE IS PROVIDED ``AS IS&squot;&squot; AND ANY EXPRESS OR IMPLIED&n;*  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF&n;*  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE&n;*  DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE&n;*  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR&n;*  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF&n;*  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR&n;*  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF&n;*  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING&n;*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS&n;*  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.&n;*&n;*/
macro_line|#include &lt;linux/param.h&gt;
macro_line|#include &lt;linux/major.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/sunrpc/svc.h&gt;
macro_line|#include &lt;linux/nfsd/nfsd.h&gt;
macro_line|#include &lt;linux/nfsd/cache.h&gt;
macro_line|#include &lt;linux/mount.h&gt;
macro_line|#include &lt;linux/workqueue.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/nfs4.h&gt;
macro_line|#include &lt;linux/nfsd/state.h&gt;
macro_line|#include &lt;linux/nfsd/xdr4.h&gt;
DECL|macro|NFSDDBG_FACILITY
mdefine_line|#define NFSDDBG_FACILITY                NFSDDBG_PROC
multiline_comment|/* Globals */
DECL|variable|lease_time
r_static
id|time_t
id|lease_time
op_assign
l_int|90
suffix:semicolon
multiline_comment|/* default lease time */
DECL|variable|old_lease_time
r_static
id|time_t
id|old_lease_time
op_assign
l_int|90
suffix:semicolon
multiline_comment|/* past incarnation lease time */
DECL|variable|nfs4_reclaim_init
r_static
id|u32
id|nfs4_reclaim_init
op_assign
l_int|0
suffix:semicolon
DECL|variable|boot_time
id|time_t
id|boot_time
suffix:semicolon
DECL|variable|grace_end
r_static
id|time_t
id|grace_end
op_assign
l_int|0
suffix:semicolon
DECL|variable|current_clientid
r_static
id|u32
id|current_clientid
op_assign
l_int|1
suffix:semicolon
DECL|variable|current_ownerid
r_static
id|u32
id|current_ownerid
suffix:semicolon
DECL|variable|current_fileid
r_static
id|u32
id|current_fileid
suffix:semicolon
DECL|variable|nfs4_init
r_static
id|u32
id|nfs4_init
suffix:semicolon
DECL|variable|zerostateid
id|stateid_t
id|zerostateid
suffix:semicolon
multiline_comment|/* bits all 0 */
DECL|variable|onestateid
id|stateid_t
id|onestateid
suffix:semicolon
multiline_comment|/* bits all 1 */
multiline_comment|/* debug counters */
DECL|variable|list_add_perfile
id|u32
id|list_add_perfile
op_assign
l_int|0
suffix:semicolon
DECL|variable|list_del_perfile
id|u32
id|list_del_perfile
op_assign
l_int|0
suffix:semicolon
DECL|variable|add_perclient
id|u32
id|add_perclient
op_assign
l_int|0
suffix:semicolon
DECL|variable|del_perclient
id|u32
id|del_perclient
op_assign
l_int|0
suffix:semicolon
DECL|variable|alloc_file
id|u32
id|alloc_file
op_assign
l_int|0
suffix:semicolon
DECL|variable|free_file
id|u32
id|free_file
op_assign
l_int|0
suffix:semicolon
DECL|variable|alloc_sowner
id|u32
id|alloc_sowner
op_assign
l_int|0
suffix:semicolon
DECL|variable|free_sowner
id|u32
id|free_sowner
op_assign
l_int|0
suffix:semicolon
DECL|variable|vfsopen
id|u32
id|vfsopen
op_assign
l_int|0
suffix:semicolon
DECL|variable|vfsclose
id|u32
id|vfsclose
op_assign
l_int|0
suffix:semicolon
DECL|variable|alloc_lsowner
id|u32
id|alloc_lsowner
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* forward declarations */
r_struct
id|nfs4_stateid
op_star
id|find_stateid
c_func
(paren
id|stateid_t
op_star
id|stid
comma
r_int
id|flags
)paren
suffix:semicolon
multiline_comment|/* Locking:&n; *&n; * client_sema: &n; * &t;protects clientid_hashtbl[], clientstr_hashtbl[],&n; * &t;unconfstr_hashtbl[], uncofid_hashtbl[].&n; */
r_static
id|DECLARE_MUTEX
c_func
(paren
id|client_sema
)paren
suffix:semicolon
r_void
DECL|function|nfs4_lock_state
id|nfs4_lock_state
c_func
(paren
r_void
)paren
(brace
id|down
c_func
(paren
op_amp
id|client_sema
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * nfs4_unlock_state(); called in encode&n; */
r_void
DECL|function|nfs4_unlock_state
id|nfs4_unlock_state
c_func
(paren
r_void
)paren
(brace
id|up
c_func
(paren
op_amp
id|client_sema
)paren
suffix:semicolon
)brace
r_static
r_inline
id|u32
DECL|function|opaque_hashval
id|opaque_hashval
c_func
(paren
r_const
r_void
op_star
id|ptr
comma
r_int
id|nbytes
)paren
(brace
r_int
r_char
op_star
id|cptr
op_assign
(paren
r_int
r_char
op_star
)paren
id|ptr
suffix:semicolon
id|u32
id|x
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|nbytes
op_decrement
)paren
(brace
id|x
op_mul_assign
l_int|37
suffix:semicolon
id|x
op_add_assign
op_star
id|cptr
op_increment
suffix:semicolon
)brace
r_return
id|x
suffix:semicolon
)brace
multiline_comment|/* forward declarations */
r_static
r_void
id|release_stateowner
c_func
(paren
r_struct
id|nfs4_stateowner
op_star
id|sop
)paren
suffix:semicolon
r_static
r_void
id|release_stateid
c_func
(paren
r_struct
id|nfs4_stateid
op_star
id|stp
comma
r_int
id|flags
)paren
suffix:semicolon
r_static
r_void
id|release_file
c_func
(paren
r_struct
id|nfs4_file
op_star
id|fp
)paren
suffix:semicolon
multiline_comment|/* &n; * SETCLIENTID state &n; */
multiline_comment|/* Hash tables for nfs4_clientid state */
DECL|macro|CLIENT_HASH_BITS
mdefine_line|#define CLIENT_HASH_BITS                 4
DECL|macro|CLIENT_HASH_SIZE
mdefine_line|#define CLIENT_HASH_SIZE                (1 &lt;&lt; CLIENT_HASH_BITS)
DECL|macro|CLIENT_HASH_MASK
mdefine_line|#define CLIENT_HASH_MASK                (CLIENT_HASH_SIZE - 1)
DECL|macro|clientid_hashval
mdefine_line|#define clientid_hashval(id) &bslash;&n;&t;((id) &amp; CLIENT_HASH_MASK)
DECL|macro|clientstr_hashval
mdefine_line|#define clientstr_hashval(name, namelen) &bslash;&n;&t;(opaque_hashval((name), (namelen)) &amp; CLIENT_HASH_MASK)
multiline_comment|/*&n; * reclaim_str_hashtbl[] holds known client info from previous reset/reboot&n; * used in reboot/reset lease grace period processing&n; *&n; * conf_id_hashtbl[], and conf_str_hashtbl[] hold confirmed&n; * setclientid_confirmed info. &n; *&n; * unconf_str_hastbl[] and unconf_id_hashtbl[] hold unconfirmed &n; * setclientid info.&n; *&n; * client_lru holds client queue ordered by nfs4_client.cl_time&n; * for lease renewal.&n; *&n; * close_lru holds (open) stateowner queue ordered by nfs4_stateowner.so_time&n; * for last close replay.&n; */
DECL|variable|reclaim_str_hashtbl
r_static
r_struct
id|list_head
id|reclaim_str_hashtbl
(braket
id|CLIENT_HASH_SIZE
)braket
suffix:semicolon
DECL|variable|reclaim_str_hashtbl_size
r_static
r_int
id|reclaim_str_hashtbl_size
suffix:semicolon
DECL|variable|conf_id_hashtbl
r_static
r_struct
id|list_head
id|conf_id_hashtbl
(braket
id|CLIENT_HASH_SIZE
)braket
suffix:semicolon
DECL|variable|conf_str_hashtbl
r_static
r_struct
id|list_head
id|conf_str_hashtbl
(braket
id|CLIENT_HASH_SIZE
)braket
suffix:semicolon
DECL|variable|unconf_str_hashtbl
r_static
r_struct
id|list_head
id|unconf_str_hashtbl
(braket
id|CLIENT_HASH_SIZE
)braket
suffix:semicolon
DECL|variable|unconf_id_hashtbl
r_static
r_struct
id|list_head
id|unconf_id_hashtbl
(braket
id|CLIENT_HASH_SIZE
)braket
suffix:semicolon
DECL|variable|client_lru
r_static
r_struct
id|list_head
id|client_lru
suffix:semicolon
DECL|variable|close_lru
r_static
r_struct
id|list_head
id|close_lru
suffix:semicolon
r_static
r_inline
r_void
DECL|function|renew_client
id|renew_client
c_func
(paren
r_struct
id|nfs4_client
op_star
id|clp
)paren
(brace
multiline_comment|/*&n;&t;* Move client to the end to the LRU list.&n;&t;*/
id|dprintk
c_func
(paren
l_string|&quot;renewing client (clientid %08x/%08x)&bslash;n&quot;
comma
id|clp-&gt;cl_clientid.cl_boot
comma
id|clp-&gt;cl_clientid.cl_id
)paren
suffix:semicolon
id|list_move_tail
c_func
(paren
op_amp
id|clp-&gt;cl_lru
comma
op_amp
id|client_lru
)paren
suffix:semicolon
id|clp-&gt;cl_time
op_assign
id|get_seconds
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* SETCLIENTID and SETCLIENTID_CONFIRM Helper functions */
r_static
r_int
DECL|function|STALE_CLIENTID
id|STALE_CLIENTID
c_func
(paren
id|clientid_t
op_star
id|clid
)paren
(brace
r_if
c_cond
(paren
id|clid-&gt;cl_boot
op_eq
id|boot_time
)paren
r_return
l_int|0
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;NFSD stale clientid (%08x/%08x)&bslash;n&quot;
comma
id|clid-&gt;cl_boot
comma
id|clid-&gt;cl_id
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* &n; * XXX Should we use a slab cache ?&n; * This type of memory management is somewhat inefficient, but we use it&n; * anyway since SETCLIENTID is not a common operation.&n; */
r_static
r_inline
r_struct
id|nfs4_client
op_star
DECL|function|alloc_client
id|alloc_client
c_func
(paren
r_struct
id|xdr_netobj
id|name
)paren
(brace
r_struct
id|nfs4_client
op_star
id|clp
suffix:semicolon
r_if
c_cond
(paren
(paren
id|clp
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|nfs4_client
)paren
comma
id|GFP_KERNEL
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|memset
c_func
(paren
id|clp
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|clp
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|clp-&gt;cl_name.data
op_assign
id|kmalloc
c_func
(paren
id|name.len
comma
id|GFP_KERNEL
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|memcpy
c_func
(paren
id|clp-&gt;cl_name.data
comma
id|name.data
comma
id|name.len
)paren
suffix:semicolon
id|clp-&gt;cl_name.len
op_assign
id|name.len
suffix:semicolon
)brace
r_else
(brace
id|kfree
c_func
(paren
id|clp
)paren
suffix:semicolon
id|clp
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
r_return
id|clp
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|free_client
id|free_client
c_func
(paren
r_struct
id|nfs4_client
op_star
id|clp
)paren
(brace
r_if
c_cond
(paren
id|clp-&gt;cl_cred.cr_group_info
)paren
id|put_group_info
c_func
(paren
id|clp-&gt;cl_cred.cr_group_info
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|clp-&gt;cl_name.data
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|clp
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|expire_client
id|expire_client
c_func
(paren
r_struct
id|nfs4_client
op_star
id|clp
)paren
(brace
r_struct
id|nfs4_stateowner
op_star
id|sop
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;NFSD: expire_client&bslash;n&quot;
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|clp-&gt;cl_idhash
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|clp-&gt;cl_strhash
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|clp-&gt;cl_lru
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|clp-&gt;cl_perclient
)paren
)paren
(brace
id|sop
op_assign
id|list_entry
c_func
(paren
id|clp-&gt;cl_perclient.next
comma
r_struct
id|nfs4_stateowner
comma
id|so_perclient
)paren
suffix:semicolon
id|release_stateowner
c_func
(paren
id|sop
)paren
suffix:semicolon
)brace
id|free_client
c_func
(paren
id|clp
)paren
suffix:semicolon
)brace
r_static
r_struct
id|nfs4_client
op_star
DECL|function|create_client
id|create_client
c_func
(paren
r_struct
id|xdr_netobj
id|name
)paren
(brace
r_struct
id|nfs4_client
op_star
id|clp
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|clp
op_assign
id|alloc_client
c_func
(paren
id|name
)paren
)paren
)paren
r_goto
id|out
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|clp-&gt;cl_idhash
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|clp-&gt;cl_strhash
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|clp-&gt;cl_perclient
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|clp-&gt;cl_lru
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|clp
suffix:semicolon
)brace
r_static
r_void
DECL|function|copy_verf
id|copy_verf
c_func
(paren
r_struct
id|nfs4_client
op_star
id|target
comma
id|nfs4_verifier
op_star
id|source
)paren
(brace
id|memcpy
c_func
(paren
id|target-&gt;cl_verifier.data
comma
id|source-&gt;data
comma
r_sizeof
(paren
id|target-&gt;cl_verifier.data
)paren
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|copy_clid
id|copy_clid
c_func
(paren
r_struct
id|nfs4_client
op_star
id|target
comma
r_struct
id|nfs4_client
op_star
id|source
)paren
(brace
id|target-&gt;cl_clientid.cl_boot
op_assign
id|source-&gt;cl_clientid.cl_boot
suffix:semicolon
id|target-&gt;cl_clientid.cl_id
op_assign
id|source-&gt;cl_clientid.cl_id
suffix:semicolon
)brace
r_static
r_void
DECL|function|copy_cred
id|copy_cred
c_func
(paren
r_struct
id|svc_cred
op_star
id|target
comma
r_struct
id|svc_cred
op_star
id|source
)paren
(brace
id|target-&gt;cr_uid
op_assign
id|source-&gt;cr_uid
suffix:semicolon
id|target-&gt;cr_gid
op_assign
id|source-&gt;cr_gid
suffix:semicolon
id|target-&gt;cr_group_info
op_assign
id|source-&gt;cr_group_info
suffix:semicolon
id|get_group_info
c_func
(paren
id|target-&gt;cr_group_info
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|cmp_name
id|cmp_name
c_func
(paren
r_struct
id|xdr_netobj
op_star
id|n1
comma
r_struct
id|xdr_netobj
op_star
id|n2
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|n1
op_logical_or
op_logical_neg
id|n2
)paren
r_return
l_int|0
suffix:semicolon
r_return
(paren
id|n1-&gt;len
op_eq
id|n2-&gt;len
)paren
op_logical_and
op_logical_neg
id|memcmp
c_func
(paren
id|n1-&gt;data
comma
id|n2-&gt;data
comma
id|n2-&gt;len
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|cmp_verf
id|cmp_verf
c_func
(paren
id|nfs4_verifier
op_star
id|v1
comma
id|nfs4_verifier
op_star
id|v2
)paren
(brace
r_return
op_logical_neg
id|memcmp
c_func
(paren
id|v1-&gt;data
comma
id|v2-&gt;data
comma
r_sizeof
(paren
id|v1-&gt;data
)paren
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|cmp_clid
id|cmp_clid
c_func
(paren
id|clientid_t
op_star
id|cl1
comma
id|clientid_t
op_star
id|cl2
)paren
(brace
r_return
(paren
id|cl1-&gt;cl_boot
op_eq
id|cl2-&gt;cl_boot
)paren
op_logical_and
(paren
id|cl1-&gt;cl_id
op_eq
id|cl2-&gt;cl_id
)paren
suffix:semicolon
)brace
multiline_comment|/* XXX what about NGROUP */
r_static
r_int
DECL|function|cmp_creds
(def_block
id|cmp_creds
c_func
(paren
r_struct
id|svc_cred
op_star
id|cr1
comma
r_struct
id|svc_cred
op_star
id|cr2
)paren
(brace
r_return
id|cr1-&gt;cr_uid
op_eq
id|cr2-&gt;cr_uid
suffix:semicolon
)brace
)def_block
r_static
r_void
DECL|function|gen_clid
id|gen_clid
c_func
(paren
r_struct
id|nfs4_client
op_star
id|clp
)paren
(brace
id|clp-&gt;cl_clientid.cl_boot
op_assign
id|boot_time
suffix:semicolon
id|clp-&gt;cl_clientid.cl_id
op_assign
id|current_clientid
op_increment
suffix:semicolon
)brace
r_static
r_void
DECL|function|gen_confirm
id|gen_confirm
c_func
(paren
r_struct
id|nfs4_client
op_star
id|clp
)paren
(brace
r_struct
id|timespec
id|tv
suffix:semicolon
id|u32
op_star
id|p
suffix:semicolon
id|tv
op_assign
id|CURRENT_TIME
suffix:semicolon
id|p
op_assign
(paren
id|u32
op_star
)paren
id|clp-&gt;cl_confirm.data
suffix:semicolon
op_star
id|p
op_increment
op_assign
id|tv.tv_sec
suffix:semicolon
op_star
id|p
op_increment
op_assign
id|tv.tv_nsec
suffix:semicolon
)brace
r_static
r_int
DECL|function|check_name
id|check_name
c_func
(paren
r_struct
id|xdr_netobj
id|name
)paren
(brace
r_if
c_cond
(paren
id|name.len
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|name.len
OG
id|NFS4_OPAQUE_LIMIT
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;NFSD: check_name: name too long(%d)!&bslash;n&quot;
comma
id|name.len
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
r_void
DECL|function|add_to_unconfirmed
id|add_to_unconfirmed
c_func
(paren
r_struct
id|nfs4_client
op_star
id|clp
comma
r_int
r_int
id|strhashval
)paren
(brace
r_int
r_int
id|idhashval
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|clp-&gt;cl_strhash
comma
op_amp
id|unconf_str_hashtbl
(braket
id|strhashval
)braket
)paren
suffix:semicolon
id|idhashval
op_assign
id|clientid_hashval
c_func
(paren
id|clp-&gt;cl_clientid.cl_id
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|clp-&gt;cl_idhash
comma
op_amp
id|unconf_id_hashtbl
(braket
id|idhashval
)braket
)paren
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|clp-&gt;cl_lru
comma
op_amp
id|client_lru
)paren
suffix:semicolon
id|clp-&gt;cl_time
op_assign
id|get_seconds
c_func
(paren
)paren
suffix:semicolon
)brace
r_void
DECL|function|move_to_confirmed
id|move_to_confirmed
c_func
(paren
r_struct
id|nfs4_client
op_star
id|clp
comma
r_int
r_int
id|idhashval
)paren
(brace
r_int
r_int
id|strhashval
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;NFSD: move_to_confirm nfs4_client %p&bslash;n&quot;
comma
id|clp
)paren
suffix:semicolon
id|list_del_init
c_func
(paren
op_amp
id|clp-&gt;cl_strhash
)paren
suffix:semicolon
id|list_del_init
c_func
(paren
op_amp
id|clp-&gt;cl_idhash
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|clp-&gt;cl_idhash
comma
op_amp
id|conf_id_hashtbl
(braket
id|idhashval
)braket
)paren
suffix:semicolon
id|strhashval
op_assign
id|clientstr_hashval
c_func
(paren
id|clp-&gt;cl_name.data
comma
id|clp-&gt;cl_name.len
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|clp-&gt;cl_strhash
comma
op_amp
id|conf_str_hashtbl
(braket
id|strhashval
)braket
)paren
suffix:semicolon
id|renew_client
c_func
(paren
id|clp
)paren
suffix:semicolon
)brace
multiline_comment|/* a helper function for parse_callback */
r_static
r_int
DECL|function|parse_octet
id|parse_octet
c_func
(paren
r_int
r_int
op_star
id|lenp
comma
r_char
op_star
op_star
id|addrp
)paren
(brace
r_int
r_int
id|len
op_assign
op_star
id|lenp
suffix:semicolon
r_char
op_star
id|p
op_assign
op_star
id|addrp
suffix:semicolon
r_int
id|n
op_assign
op_minus
l_int|1
suffix:semicolon
r_char
id|c
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|len
)paren
r_break
suffix:semicolon
id|len
op_decrement
suffix:semicolon
id|c
op_assign
op_star
id|p
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;.&squot;
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
(paren
id|c
OL
l_char|&squot;0&squot;
)paren
op_logical_or
(paren
id|c
OG
l_char|&squot;9&squot;
)paren
)paren
(brace
id|n
op_assign
op_minus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|n
OL
l_int|0
)paren
id|n
op_assign
l_int|0
suffix:semicolon
id|n
op_assign
(paren
id|n
op_star
l_int|10
)paren
op_plus
(paren
id|c
op_minus
l_char|&squot;0&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|n
OG
l_int|255
)paren
(brace
id|n
op_assign
op_minus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
op_star
id|lenp
op_assign
id|len
suffix:semicolon
op_star
id|addrp
op_assign
id|p
suffix:semicolon
r_return
id|n
suffix:semicolon
)brace
multiline_comment|/* parse and set the setclientid ipv4 callback address */
r_int
DECL|function|parse_ipv4
id|parse_ipv4
c_func
(paren
r_int
r_int
id|addr_len
comma
r_char
op_star
id|addr_val
comma
r_int
r_int
op_star
id|cbaddrp
comma
r_int
r_int
op_star
id|cbportp
)paren
(brace
r_int
id|temp
op_assign
l_int|0
suffix:semicolon
id|u32
id|cbaddr
op_assign
l_int|0
suffix:semicolon
id|u16
id|cbport
op_assign
l_int|0
suffix:semicolon
id|u32
id|addrlen
op_assign
id|addr_len
suffix:semicolon
r_char
op_star
id|addr
op_assign
id|addr_val
suffix:semicolon
r_int
id|i
comma
id|shift
suffix:semicolon
multiline_comment|/* ipaddress */
id|shift
op_assign
l_int|24
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|4
suffix:semicolon
id|i
OG
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
r_if
c_cond
(paren
(paren
id|temp
op_assign
id|parse_octet
c_func
(paren
op_amp
id|addrlen
comma
op_amp
id|addr
)paren
)paren
OL
l_int|0
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
id|cbaddr
op_or_assign
(paren
id|temp
op_lshift
id|shift
)paren
suffix:semicolon
r_if
c_cond
(paren
id|shift
OG
l_int|0
)paren
id|shift
op_sub_assign
l_int|8
suffix:semicolon
)brace
op_star
id|cbaddrp
op_assign
id|cbaddr
suffix:semicolon
multiline_comment|/* port */
id|shift
op_assign
l_int|8
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|2
suffix:semicolon
id|i
OG
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
r_if
c_cond
(paren
(paren
id|temp
op_assign
id|parse_octet
c_func
(paren
op_amp
id|addrlen
comma
op_amp
id|addr
)paren
)paren
OL
l_int|0
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
id|cbport
op_or_assign
(paren
id|temp
op_lshift
id|shift
)paren
suffix:semicolon
r_if
c_cond
(paren
id|shift
OG
l_int|0
)paren
id|shift
op_sub_assign
l_int|8
suffix:semicolon
)brace
op_star
id|cbportp
op_assign
id|cbport
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_void
DECL|function|gen_callback
id|gen_callback
c_func
(paren
r_struct
id|nfs4_client
op_star
id|clp
comma
r_struct
id|nfsd4_setclientid
op_star
id|se
)paren
(brace
r_struct
id|nfs4_callback
op_star
id|cb
op_assign
op_amp
id|clp-&gt;cl_callback
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|parse_ipv4
c_func
(paren
id|se-&gt;se_callback_addr_len
comma
id|se-&gt;se_callback_addr_val
comma
op_amp
id|cb-&gt;cb_addr
comma
op_amp
id|cb-&gt;cb_port
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;NFSD: BAD callback address. client will not receive delegations&bslash;n&quot;
)paren
suffix:semicolon
id|cb-&gt;cb_parsed
op_assign
l_int|0
suffix:semicolon
r_return
suffix:semicolon
)brace
id|cb-&gt;cb_netid.len
op_assign
id|se-&gt;se_callback_netid_len
suffix:semicolon
id|cb-&gt;cb_netid.data
op_assign
id|se-&gt;se_callback_netid_val
suffix:semicolon
id|cb-&gt;cb_prog
op_assign
id|se-&gt;se_callback_prog
suffix:semicolon
id|cb-&gt;cb_ident
op_assign
id|se-&gt;se_callback_ident
suffix:semicolon
id|cb-&gt;cb_parsed
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * RFC 3010 has a complex implmentation description of processing a &n; * SETCLIENTID request consisting of 5 bullets, labeled as &n; * CASE0 - CASE4 below.&n; *&n; * NOTES:&n; * &t;callback information will be processed in a future patch&n; *&n; *&t;an unconfirmed record is added when:&n; *      NORMAL (part of CASE 4): there is no confirmed nor unconfirmed record.&n; *&t;CASE 1: confirmed record found with matching name, principal,&n; *&t;&t;verifier, and clientid.&n; *&t;CASE 2: confirmed record found with matching name, principal,&n; *&t;&t;and there is no unconfirmed record with matching&n; *&t;&t;name and principal&n; *&n; *      an unconfirmed record is replaced when:&n; *&t;CASE 3: confirmed record found with matching name, principal,&n; *&t;&t;and an unconfirmed record is found with matching &n; *&t;&t;name, principal, and with clientid and&n; *&t;&t;confirm that does not match the confirmed record.&n; *&t;CASE 4: there is no confirmed record with matching name and &n; *&t;&t;principal. there is an unconfirmed record with &n; *&t;&t;matching name, principal.&n; *&n; *&t;an unconfirmed record is deleted when:&n; *&t;CASE 1: an unconfirmed record that matches input name, verifier,&n; *&t;&t;and confirmed clientid.&n; *&t;CASE 4: any unconfirmed records with matching name and principal&n; *&t;&t;that exist after an unconfirmed record has been replaced&n; *&t;&t;as described above.&n; *&n; */
r_int
DECL|function|nfsd4_setclientid
id|nfsd4_setclientid
c_func
(paren
r_struct
id|svc_rqst
op_star
id|rqstp
comma
r_struct
id|nfsd4_setclientid
op_star
id|setclid
)paren
(brace
id|u32
id|ip_addr
op_assign
id|rqstp-&gt;rq_addr.sin_addr.s_addr
suffix:semicolon
r_struct
id|xdr_netobj
id|clname
op_assign
(brace
dot
id|len
op_assign
id|setclid-&gt;se_namelen
comma
dot
id|data
op_assign
id|setclid-&gt;se_name
comma
)brace
suffix:semicolon
id|nfs4_verifier
id|clverifier
op_assign
id|setclid-&gt;se_verf
suffix:semicolon
r_int
r_int
id|strhashval
suffix:semicolon
r_struct
id|nfs4_client
op_star
id|conf
comma
op_star
id|unconf
comma
op_star
r_new
comma
op_star
id|clp
suffix:semicolon
r_int
id|status
suffix:semicolon
id|status
op_assign
id|nfserr_inval
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|check_name
c_func
(paren
id|clname
)paren
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* &n;&t; * XXX The Duplicate Request Cache (DRC) has been checked (??)&n;&t; * We get here on a DRC miss.&n;&t; */
id|strhashval
op_assign
id|clientstr_hashval
c_func
(paren
id|clname.data
comma
id|clname.len
)paren
suffix:semicolon
id|conf
op_assign
l_int|NULL
suffix:semicolon
id|nfs4_lock_state
c_func
(paren
)paren
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|clp
comma
op_amp
id|conf_str_hashtbl
(braket
id|strhashval
)braket
comma
id|cl_strhash
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|cmp_name
c_func
(paren
op_amp
id|clp-&gt;cl_name
comma
op_amp
id|clname
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/* &n;&t;&t; * CASE 0:&n;&t;&t; * clname match, confirmed, different principal&n;&t;&t; * or different ip_address&n;&t;&t; */
id|status
op_assign
id|nfserr_clid_inuse
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cmp_creds
c_func
(paren
op_amp
id|clp-&gt;cl_cred
comma
op_amp
id|rqstp-&gt;rq_cred
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;NFSD: setclientid: string in use by client&quot;
l_string|&quot;(clientid %08x/%08x)&bslash;n&quot;
comma
id|clp-&gt;cl_clientid.cl_boot
comma
id|clp-&gt;cl_clientid.cl_id
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|clp-&gt;cl_addr
op_ne
id|ip_addr
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;NFSD: setclientid: string in use by client&quot;
l_string|&quot;(clientid %08x/%08x)&bslash;n&quot;
comma
id|clp-&gt;cl_clientid.cl_boot
comma
id|clp-&gt;cl_clientid.cl_id
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* &n;&t; &t; * cl_name match from a previous SETCLIENTID operation&n;&t; &t; * XXX check for additional matches?&n;&t;&t; */
id|conf
op_assign
id|clp
suffix:semicolon
r_break
suffix:semicolon
)brace
id|unconf
op_assign
l_int|NULL
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|clp
comma
op_amp
id|unconf_str_hashtbl
(braket
id|strhashval
)braket
comma
id|cl_strhash
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|cmp_name
c_func
(paren
op_amp
id|clp-&gt;cl_name
comma
op_amp
id|clname
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/* cl_name match from a previous SETCLIENTID operation */
id|unconf
op_assign
id|clp
suffix:semicolon
r_break
suffix:semicolon
)brace
id|status
op_assign
id|nfserr_resource
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|conf
)paren
(brace
multiline_comment|/* &n;&t;&t; * CASE 4:&n;&t;&t; * placed first, because it is the normal case.&n;&t;&t; */
r_if
c_cond
(paren
id|unconf
)paren
id|expire_client
c_func
(paren
id|unconf
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
r_new
op_assign
id|create_client
c_func
(paren
id|clname
)paren
)paren
)paren
r_goto
id|out
suffix:semicolon
id|copy_verf
c_func
(paren
r_new
comma
op_amp
id|clverifier
)paren
suffix:semicolon
r_new
op_member_access_from_pointer
id|cl_addr
op_assign
id|ip_addr
suffix:semicolon
id|copy_cred
c_func
(paren
op_amp
r_new
op_member_access_from_pointer
id|cl_cred
comma
op_amp
id|rqstp-&gt;rq_cred
)paren
suffix:semicolon
id|gen_clid
c_func
(paren
r_new
)paren
suffix:semicolon
id|gen_confirm
c_func
(paren
r_new
)paren
suffix:semicolon
id|gen_callback
c_func
(paren
r_new
comma
id|setclid
)paren
suffix:semicolon
id|add_to_unconfirmed
c_func
(paren
r_new
comma
id|strhashval
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|cmp_verf
c_func
(paren
op_amp
id|conf-&gt;cl_verifier
comma
op_amp
id|clverifier
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * CASE 1:&n;&t;&t; * cl_name match, confirmed, principal match&n;&t;&t; * verifier match: probable callback update&n;&t;&t; *&n;&t;&t; * remove any unconfirmed nfs4_client with &n;&t;&t; * matching cl_name, cl_verifier, and cl_clientid&n;&t;&t; *&n;&t;&t; * create and insert an unconfirmed nfs4_client with same &n;&t;&t; * cl_name, cl_verifier, and cl_clientid as existing &n;&t;&t; * nfs4_client,  but with the new callback info and a &n;&t;&t; * new cl_confirm&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|unconf
)paren
op_logical_and
id|cmp_verf
c_func
(paren
op_amp
id|unconf-&gt;cl_verifier
comma
op_amp
id|conf-&gt;cl_verifier
)paren
op_logical_and
id|cmp_clid
c_func
(paren
op_amp
id|unconf-&gt;cl_clientid
comma
op_amp
id|conf-&gt;cl_clientid
)paren
)paren
(brace
id|expire_client
c_func
(paren
id|unconf
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
r_new
op_assign
id|create_client
c_func
(paren
id|clname
)paren
)paren
)paren
r_goto
id|out
suffix:semicolon
id|copy_verf
c_func
(paren
r_new
comma
op_amp
id|conf-&gt;cl_verifier
)paren
suffix:semicolon
r_new
op_member_access_from_pointer
id|cl_addr
op_assign
id|ip_addr
suffix:semicolon
id|copy_cred
c_func
(paren
op_amp
r_new
op_member_access_from_pointer
id|cl_cred
comma
op_amp
id|rqstp-&gt;rq_cred
)paren
suffix:semicolon
id|copy_clid
c_func
(paren
r_new
comma
id|conf
)paren
suffix:semicolon
id|gen_confirm
c_func
(paren
r_new
)paren
suffix:semicolon
id|gen_callback
c_func
(paren
r_new
comma
id|setclid
)paren
suffix:semicolon
id|add_to_unconfirmed
c_func
(paren
r_new
comma
id|strhashval
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|unconf
)paren
(brace
multiline_comment|/*&n;&t;&t; * CASE 2:&n;&t;&t; * clname match, confirmed, principal match&n;&t;&t; * verfier does not match&n;&t;&t; * no unconfirmed. create a new unconfirmed nfs4_client&n;&t;&t; * using input clverifier, clname, and callback info&n;&t;&t; * and generate a new cl_clientid and cl_confirm.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
r_new
op_assign
id|create_client
c_func
(paren
id|clname
)paren
)paren
)paren
r_goto
id|out
suffix:semicolon
id|copy_verf
c_func
(paren
r_new
comma
op_amp
id|clverifier
)paren
suffix:semicolon
r_new
op_member_access_from_pointer
id|cl_addr
op_assign
id|ip_addr
suffix:semicolon
id|copy_cred
c_func
(paren
op_amp
r_new
op_member_access_from_pointer
id|cl_cred
comma
op_amp
id|rqstp-&gt;rq_cred
)paren
suffix:semicolon
id|gen_clid
c_func
(paren
r_new
)paren
suffix:semicolon
id|gen_confirm
c_func
(paren
r_new
)paren
suffix:semicolon
id|gen_callback
c_func
(paren
r_new
comma
id|setclid
)paren
suffix:semicolon
id|add_to_unconfirmed
c_func
(paren
r_new
comma
id|strhashval
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|cmp_verf
c_func
(paren
op_amp
id|conf-&gt;cl_confirm
comma
op_amp
id|unconf-&gt;cl_confirm
)paren
)paren
(brace
multiline_comment|/*&t;&n;&t;&t; * CASE3:&n;&t;&t; * confirmed found (name, principal match)&n;&t;&t; * confirmed verifier does not match input clverifier&n;&t;&t; *&n;&t;&t; * unconfirmed found (name match)&n;&t;&t; * confirmed-&gt;cl_confirm != unconfirmed-&gt;cl_confirm&n;&t;&t; *&n;&t;&t; * remove unconfirmed.&n;&t;&t; *&n;&t;&t; * create an unconfirmed nfs4_client &n;&t;&t; * with same cl_name as existing confirmed nfs4_client, &n;&t;&t; * but with new callback info, new cl_clientid,&n;&t;&t; * new cl_verifier and a new cl_confirm&n;&t;&t; */
id|expire_client
c_func
(paren
id|unconf
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
r_new
op_assign
id|create_client
c_func
(paren
id|clname
)paren
)paren
)paren
r_goto
id|out
suffix:semicolon
id|copy_verf
c_func
(paren
r_new
comma
op_amp
id|clverifier
)paren
suffix:semicolon
r_new
op_member_access_from_pointer
id|cl_addr
op_assign
id|ip_addr
suffix:semicolon
id|copy_cred
c_func
(paren
op_amp
r_new
op_member_access_from_pointer
id|cl_cred
comma
op_amp
id|rqstp-&gt;rq_cred
)paren
suffix:semicolon
id|gen_clid
c_func
(paren
r_new
)paren
suffix:semicolon
id|gen_confirm
c_func
(paren
r_new
)paren
suffix:semicolon
id|gen_callback
c_func
(paren
r_new
comma
id|setclid
)paren
suffix:semicolon
id|add_to_unconfirmed
c_func
(paren
r_new
comma
id|strhashval
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* No cases hit !!! */
id|status
op_assign
id|nfserr_inval
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|setclid-&gt;se_clientid.cl_boot
op_assign
r_new
op_member_access_from_pointer
id|cl_clientid.cl_boot
suffix:semicolon
id|setclid-&gt;se_clientid.cl_id
op_assign
r_new
op_member_access_from_pointer
id|cl_clientid.cl_id
suffix:semicolon
id|memcpy
c_func
(paren
id|setclid-&gt;se_confirm.data
comma
r_new
op_member_access_from_pointer
id|cl_confirm.data
comma
r_sizeof
(paren
id|setclid-&gt;se_confirm.data
)paren
)paren
suffix:semicolon
id|status
op_assign
id|nfs_ok
suffix:semicolon
id|out
suffix:colon
id|nfs4_unlock_state
c_func
(paren
)paren
suffix:semicolon
r_return
id|status
suffix:semicolon
)brace
multiline_comment|/*&n; * RFC 3010 has a complex implmentation description of processing a &n; * SETCLIENTID_CONFIRM request consisting of 4 bullets describing&n; * processing on a DRC miss, labeled as CASE1 - CASE4 below.&n; *&n; * NOTE: callback information will be processed here in a future patch&n; */
r_int
DECL|function|nfsd4_setclientid_confirm
id|nfsd4_setclientid_confirm
c_func
(paren
r_struct
id|svc_rqst
op_star
id|rqstp
comma
r_struct
id|nfsd4_setclientid_confirm
op_star
id|setclientid_confirm
)paren
(brace
id|u32
id|ip_addr
op_assign
id|rqstp-&gt;rq_addr.sin_addr.s_addr
suffix:semicolon
r_int
r_int
id|idhashval
suffix:semicolon
r_struct
id|nfs4_client
op_star
id|clp
comma
op_star
id|conf
op_assign
l_int|NULL
comma
op_star
id|unconf
op_assign
l_int|NULL
suffix:semicolon
id|nfs4_verifier
id|confirm
op_assign
id|setclientid_confirm-&gt;sc_confirm
suffix:semicolon
id|clientid_t
op_star
id|clid
op_assign
op_amp
id|setclientid_confirm-&gt;sc_clientid
suffix:semicolon
r_int
id|status
suffix:semicolon
id|status
op_assign
id|nfserr_stale_clientid
suffix:semicolon
r_if
c_cond
(paren
id|STALE_CLIENTID
c_func
(paren
id|clid
)paren
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* &n;&t; * XXX The Duplicate Request Cache (DRC) has been checked (??)&n;&t; * We get here on a DRC miss.&n;&t; */
id|idhashval
op_assign
id|clientid_hashval
c_func
(paren
id|clid-&gt;cl_id
)paren
suffix:semicolon
id|nfs4_lock_state
c_func
(paren
)paren
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|clp
comma
op_amp
id|conf_id_hashtbl
(braket
id|idhashval
)braket
comma
id|cl_idhash
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|cmp_clid
c_func
(paren
op_amp
id|clp-&gt;cl_clientid
comma
id|clid
)paren
)paren
r_continue
suffix:semicolon
id|status
op_assign
id|nfserr_inval
suffix:semicolon
multiline_comment|/* &n;&t;&t; * Found a record for this clientid. If the IP addresses&n;&t;&t; * don&squot;t match, return ERR_INVAL just as if the record had&n;&t;&t; * not been found.&n;&t;&t; */
r_if
c_cond
(paren
id|clp-&gt;cl_addr
op_ne
id|ip_addr
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;NFSD: setclientid: string in use by client&quot;
l_string|&quot;(clientid %08x/%08x)&bslash;n&quot;
comma
id|clp-&gt;cl_clientid.cl_boot
comma
id|clp-&gt;cl_clientid.cl_id
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|conf
op_assign
id|clp
suffix:semicolon
r_break
suffix:semicolon
)brace
id|list_for_each_entry
c_func
(paren
id|clp
comma
op_amp
id|unconf_id_hashtbl
(braket
id|idhashval
)braket
comma
id|cl_idhash
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|cmp_clid
c_func
(paren
op_amp
id|clp-&gt;cl_clientid
comma
id|clid
)paren
)paren
r_continue
suffix:semicolon
id|status
op_assign
id|nfserr_inval
suffix:semicolon
r_if
c_cond
(paren
id|clp-&gt;cl_addr
op_ne
id|ip_addr
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;NFSD: setclientid: string in use by client&quot;
l_string|&quot;(clientid %08x/%08x)&bslash;n&quot;
comma
id|clp-&gt;cl_clientid.cl_boot
comma
id|clp-&gt;cl_clientid.cl_id
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|unconf
op_assign
id|clp
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* CASE 1: &n;&t;* unconf record that matches input clientid and input confirm.&n;&t;* conf record that matches input clientid.&n;&t;* conf  and unconf records match names, verifiers &n;&t;*/
r_if
c_cond
(paren
(paren
id|conf
op_logical_and
id|unconf
)paren
op_logical_and
(paren
id|cmp_verf
c_func
(paren
op_amp
id|unconf-&gt;cl_confirm
comma
op_amp
id|confirm
)paren
)paren
op_logical_and
(paren
id|cmp_verf
c_func
(paren
op_amp
id|conf-&gt;cl_verifier
comma
op_amp
id|unconf-&gt;cl_verifier
)paren
)paren
op_logical_and
(paren
id|cmp_name
c_func
(paren
op_amp
id|conf-&gt;cl_name
comma
op_amp
id|unconf-&gt;cl_name
)paren
)paren
op_logical_and
(paren
op_logical_neg
id|cmp_verf
c_func
(paren
op_amp
id|conf-&gt;cl_confirm
comma
op_amp
id|unconf-&gt;cl_confirm
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|cmp_creds
c_func
(paren
op_amp
id|conf-&gt;cl_cred
comma
op_amp
id|unconf-&gt;cl_cred
)paren
)paren
id|status
op_assign
id|nfserr_clid_inuse
suffix:semicolon
r_else
(brace
id|expire_client
c_func
(paren
id|conf
)paren
suffix:semicolon
id|move_to_confirmed
c_func
(paren
id|unconf
comma
id|idhashval
)paren
suffix:semicolon
id|status
op_assign
id|nfs_ok
suffix:semicolon
)brace
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* CASE 2:&n;&t; * conf record that matches input clientid.&n;&t; * if unconf record that matches input clientid, then unconf-&gt;cl_name&n;&t; * or unconf-&gt;cl_verifier don&squot;t match the conf record.&n;&t; */
r_if
c_cond
(paren
(paren
id|conf
op_logical_and
op_logical_neg
id|unconf
)paren
op_logical_or
(paren
(paren
id|conf
op_logical_and
id|unconf
)paren
op_logical_and
(paren
op_logical_neg
id|cmp_verf
c_func
(paren
op_amp
id|conf-&gt;cl_verifier
comma
op_amp
id|unconf-&gt;cl_verifier
)paren
op_logical_or
op_logical_neg
id|cmp_name
c_func
(paren
op_amp
id|conf-&gt;cl_name
comma
op_amp
id|unconf-&gt;cl_name
)paren
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|cmp_creds
c_func
(paren
op_amp
id|conf-&gt;cl_cred
comma
op_amp
id|rqstp-&gt;rq_cred
)paren
)paren
(brace
id|status
op_assign
id|nfserr_clid_inuse
suffix:semicolon
)brace
r_else
(brace
id|status
op_assign
id|nfs_ok
suffix:semicolon
)brace
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* CASE 3:&n;&t; * conf record not found.&n;&t; * unconf record found. &n;&t; * unconf-&gt;cl_confirm matches input confirm&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|conf
op_logical_and
id|unconf
op_logical_and
id|cmp_verf
c_func
(paren
op_amp
id|unconf-&gt;cl_confirm
comma
op_amp
id|confirm
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|cmp_creds
c_func
(paren
op_amp
id|unconf-&gt;cl_cred
comma
op_amp
id|rqstp-&gt;rq_cred
)paren
)paren
(brace
id|status
op_assign
id|nfserr_clid_inuse
suffix:semicolon
)brace
r_else
(brace
id|status
op_assign
id|nfs_ok
suffix:semicolon
id|move_to_confirmed
c_func
(paren
id|unconf
comma
id|idhashval
)paren
suffix:semicolon
)brace
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* CASE 4:&n;&t; * conf record not found, or if conf, then conf-&gt;cl_confirm does not&n;&t; * match input confirm.&n;&t; * unconf record not found, or if unconf, then unconf-&gt;cl_confirm &n;&t; * does not match input confirm.&n;&t; */
r_if
c_cond
(paren
(paren
op_logical_neg
id|conf
op_logical_or
(paren
id|conf
op_logical_and
op_logical_neg
id|cmp_verf
c_func
(paren
op_amp
id|conf-&gt;cl_confirm
comma
op_amp
id|confirm
)paren
)paren
)paren
op_logical_and
(paren
op_logical_neg
id|unconf
op_logical_or
(paren
id|unconf
op_logical_and
op_logical_neg
id|cmp_verf
c_func
(paren
op_amp
id|unconf-&gt;cl_confirm
comma
op_amp
id|confirm
)paren
)paren
)paren
)paren
(brace
id|status
op_assign
id|nfserr_stale_clientid
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* check that we have hit one of the cases...*/
id|status
op_assign
id|nfserr_inval
suffix:semicolon
r_goto
id|out
suffix:semicolon
id|out
suffix:colon
multiline_comment|/* XXX if status == nfs_ok, probe callback path */
id|nfs4_unlock_state
c_func
(paren
)paren
suffix:semicolon
r_return
id|status
suffix:semicolon
)brace
multiline_comment|/* &n; * Open owner state (share locks)&n; */
multiline_comment|/* hash tables for nfs4_stateowner */
DECL|macro|OWNER_HASH_BITS
mdefine_line|#define OWNER_HASH_BITS              8
DECL|macro|OWNER_HASH_SIZE
mdefine_line|#define OWNER_HASH_SIZE             (1 &lt;&lt; OWNER_HASH_BITS)
DECL|macro|OWNER_HASH_MASK
mdefine_line|#define OWNER_HASH_MASK             (OWNER_HASH_SIZE - 1)
DECL|macro|ownerid_hashval
mdefine_line|#define ownerid_hashval(id) &bslash;&n;        ((id) &amp; OWNER_HASH_MASK)
DECL|macro|ownerstr_hashval
mdefine_line|#define ownerstr_hashval(clientid, ownername) &bslash;&n;        (((clientid) + opaque_hashval((ownername.data), (ownername.len))) &amp; OWNER_HASH_MASK)
DECL|variable|ownerid_hashtbl
r_static
r_struct
id|list_head
id|ownerid_hashtbl
(braket
id|OWNER_HASH_SIZE
)braket
suffix:semicolon
DECL|variable|ownerstr_hashtbl
r_static
r_struct
id|list_head
id|ownerstr_hashtbl
(braket
id|OWNER_HASH_SIZE
)braket
suffix:semicolon
multiline_comment|/* hash table for nfs4_file */
DECL|macro|FILE_HASH_BITS
mdefine_line|#define FILE_HASH_BITS                   8
DECL|macro|FILE_HASH_SIZE
mdefine_line|#define FILE_HASH_SIZE                  (1 &lt;&lt; FILE_HASH_BITS)
DECL|macro|FILE_HASH_MASK
mdefine_line|#define FILE_HASH_MASK                  (FILE_HASH_SIZE - 1)
multiline_comment|/* hash table for (open)nfs4_stateid */
DECL|macro|STATEID_HASH_BITS
mdefine_line|#define STATEID_HASH_BITS              10
DECL|macro|STATEID_HASH_SIZE
mdefine_line|#define STATEID_HASH_SIZE              (1 &lt;&lt; STATEID_HASH_BITS)
DECL|macro|STATEID_HASH_MASK
mdefine_line|#define STATEID_HASH_MASK              (STATEID_HASH_SIZE - 1)
DECL|macro|file_hashval
mdefine_line|#define file_hashval(x) &bslash;&n;        hash_ptr(x, FILE_HASH_BITS)
DECL|macro|stateid_hashval
mdefine_line|#define stateid_hashval(owner_id, file_id)  &bslash;&n;        (((owner_id) + (file_id)) &amp; STATEID_HASH_MASK)
DECL|variable|file_hashtbl
r_static
r_struct
id|list_head
id|file_hashtbl
(braket
id|FILE_HASH_SIZE
)braket
suffix:semicolon
DECL|variable|stateid_hashtbl
r_static
r_struct
id|list_head
id|stateid_hashtbl
(braket
id|STATEID_HASH_SIZE
)braket
suffix:semicolon
multiline_comment|/* OPEN Share state helper functions */
r_static
r_inline
r_struct
id|nfs4_file
op_star
DECL|function|alloc_init_file
id|alloc_init_file
c_func
(paren
r_int
r_int
id|hashval
comma
r_struct
id|inode
op_star
id|ino
)paren
(brace
r_struct
id|nfs4_file
op_star
id|fp
suffix:semicolon
r_if
c_cond
(paren
(paren
id|fp
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|nfs4_file
)paren
comma
id|GFP_KERNEL
)paren
)paren
)paren
(brace
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|fp-&gt;fi_hash
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|fp-&gt;fi_perfile
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|fp-&gt;fi_hash
comma
op_amp
id|file_hashtbl
(braket
id|hashval
)braket
)paren
suffix:semicolon
id|fp-&gt;fi_inode
op_assign
id|igrab
c_func
(paren
id|ino
)paren
suffix:semicolon
id|fp-&gt;fi_id
op_assign
id|current_fileid
op_increment
suffix:semicolon
id|alloc_file
op_increment
suffix:semicolon
r_return
id|fp
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
r_static
r_void
DECL|function|release_all_files
id|release_all_files
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|nfs4_file
op_star
id|fp
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|FILE_HASH_SIZE
suffix:semicolon
id|i
op_increment
)paren
(brace
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|file_hashtbl
(braket
id|i
)braket
)paren
)paren
(brace
id|fp
op_assign
id|list_entry
c_func
(paren
id|file_hashtbl
(braket
id|i
)braket
dot
id|next
comma
r_struct
id|nfs4_file
comma
id|fi_hash
)paren
suffix:semicolon
multiline_comment|/* this should never be more than once... */
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|fp-&gt;fi_perfile
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ERROR: release_all_files: file %p is open, creating dangling state !!!&bslash;n&quot;
comma
id|fp
)paren
suffix:semicolon
)brace
id|release_file
c_func
(paren
id|fp
)paren
suffix:semicolon
)brace
)brace
)brace
r_static
r_inline
r_struct
id|nfs4_stateowner
op_star
DECL|function|alloc_stateowner
id|alloc_stateowner
c_func
(paren
r_struct
id|xdr_netobj
op_star
id|owner
)paren
(brace
r_struct
id|nfs4_stateowner
op_star
id|sop
suffix:semicolon
r_if
c_cond
(paren
(paren
id|sop
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|nfs4_stateowner
)paren
comma
id|GFP_KERNEL
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|sop-&gt;so_owner.data
op_assign
id|kmalloc
c_func
(paren
id|owner-&gt;len
comma
id|GFP_KERNEL
)paren
)paren
)paren
(brace
id|memcpy
c_func
(paren
id|sop-&gt;so_owner.data
comma
id|owner-&gt;data
comma
id|owner-&gt;len
)paren
suffix:semicolon
id|sop-&gt;so_owner.len
op_assign
id|owner-&gt;len
suffix:semicolon
r_return
id|sop
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|sop
)paren
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* should use a slab cache */
r_static
r_void
DECL|function|free_stateowner
id|free_stateowner
c_func
(paren
r_struct
id|nfs4_stateowner
op_star
id|sop
)paren
(brace
r_if
c_cond
(paren
id|sop
)paren
(brace
id|kfree
c_func
(paren
id|sop-&gt;so_owner.data
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|sop
)paren
suffix:semicolon
id|sop
op_assign
l_int|NULL
suffix:semicolon
id|free_sowner
op_increment
suffix:semicolon
)brace
)brace
r_static
r_struct
id|nfs4_stateowner
op_star
DECL|function|alloc_init_open_stateowner
id|alloc_init_open_stateowner
c_func
(paren
r_int
r_int
id|strhashval
comma
r_struct
id|nfs4_client
op_star
id|clp
comma
r_struct
id|nfsd4_open
op_star
id|open
)paren
(brace
r_struct
id|nfs4_stateowner
op_star
id|sop
suffix:semicolon
r_struct
id|nfs4_replay
op_star
id|rp
suffix:semicolon
r_int
r_int
id|idhashval
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|sop
op_assign
id|alloc_stateowner
c_func
(paren
op_amp
id|open-&gt;op_owner
)paren
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
id|idhashval
op_assign
id|ownerid_hashval
c_func
(paren
id|current_ownerid
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|sop-&gt;so_idhash
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|sop-&gt;so_strhash
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|sop-&gt;so_perclient
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|sop-&gt;so_perfilestate
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|sop-&gt;so_perlockowner
)paren
suffix:semicolon
multiline_comment|/* not used */
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|sop-&gt;so_close_lru
)paren
suffix:semicolon
id|sop-&gt;so_time
op_assign
l_int|0
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|sop-&gt;so_idhash
comma
op_amp
id|ownerid_hashtbl
(braket
id|idhashval
)braket
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|sop-&gt;so_strhash
comma
op_amp
id|ownerstr_hashtbl
(braket
id|strhashval
)braket
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|sop-&gt;so_perclient
comma
op_amp
id|clp-&gt;cl_perclient
)paren
suffix:semicolon
id|add_perclient
op_increment
suffix:semicolon
id|sop-&gt;so_is_open_owner
op_assign
l_int|1
suffix:semicolon
id|sop-&gt;so_id
op_assign
id|current_ownerid
op_increment
suffix:semicolon
id|sop-&gt;so_client
op_assign
id|clp
suffix:semicolon
id|sop-&gt;so_seqid
op_assign
id|open-&gt;op_seqid
suffix:semicolon
id|sop-&gt;so_confirmed
op_assign
l_int|0
suffix:semicolon
id|rp
op_assign
op_amp
id|sop-&gt;so_replay
suffix:semicolon
id|rp-&gt;rp_status
op_assign
id|NFSERR_SERVERFAULT
suffix:semicolon
id|rp-&gt;rp_buflen
op_assign
l_int|0
suffix:semicolon
id|rp-&gt;rp_buf
op_assign
id|rp-&gt;rp_ibuf
suffix:semicolon
id|alloc_sowner
op_increment
suffix:semicolon
r_return
id|sop
suffix:semicolon
)brace
r_static
r_void
DECL|function|release_stateid_lockowner
id|release_stateid_lockowner
c_func
(paren
r_struct
id|nfs4_stateid
op_star
id|open_stp
)paren
(brace
r_struct
id|nfs4_stateowner
op_star
id|lock_sop
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|open_stp-&gt;st_perlockowner
)paren
)paren
(brace
id|lock_sop
op_assign
id|list_entry
c_func
(paren
id|open_stp-&gt;st_perlockowner.next
comma
r_struct
id|nfs4_stateowner
comma
id|so_perlockowner
)paren
suffix:semicolon
multiline_comment|/* list_del(&amp;open_stp-&gt;st_perlockowner);  */
id|BUG_ON
c_func
(paren
id|lock_sop-&gt;so_is_open_owner
)paren
suffix:semicolon
id|release_stateowner
c_func
(paren
id|lock_sop
)paren
suffix:semicolon
)brace
)brace
r_static
r_void
DECL|function|release_stateowner
id|release_stateowner
c_func
(paren
r_struct
id|nfs4_stateowner
op_star
id|sop
)paren
(brace
r_struct
id|nfs4_stateid
op_star
id|stp
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|sop-&gt;so_idhash
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|sop-&gt;so_strhash
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|sop-&gt;so_perclient
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|sop-&gt;so_perlockowner
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|sop-&gt;so_close_lru
)paren
suffix:semicolon
id|del_perclient
op_increment
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|sop-&gt;so_perfilestate
)paren
)paren
(brace
id|stp
op_assign
id|list_entry
c_func
(paren
id|sop-&gt;so_perfilestate.next
comma
r_struct
id|nfs4_stateid
comma
id|st_perfilestate
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sop-&gt;so_is_open_owner
)paren
id|release_stateid
c_func
(paren
id|stp
comma
id|OPEN_STATE
)paren
suffix:semicolon
r_else
id|release_stateid
c_func
(paren
id|stp
comma
id|LOCK_STATE
)paren
suffix:semicolon
)brace
id|free_stateowner
c_func
(paren
id|sop
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|init_stateid
id|init_stateid
c_func
(paren
r_struct
id|nfs4_stateid
op_star
id|stp
comma
r_struct
id|nfs4_file
op_star
id|fp
comma
r_struct
id|nfs4_stateowner
op_star
id|sop
comma
r_struct
id|nfsd4_open
op_star
id|open
)paren
(brace
r_int
r_int
id|hashval
op_assign
id|stateid_hashval
c_func
(paren
id|sop-&gt;so_id
comma
id|fp-&gt;fi_id
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|stp-&gt;st_hash
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|stp-&gt;st_perfilestate
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|stp-&gt;st_perlockowner
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|stp-&gt;st_perfile
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|stp-&gt;st_hash
comma
op_amp
id|stateid_hashtbl
(braket
id|hashval
)braket
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|stp-&gt;st_perfilestate
comma
op_amp
id|sop-&gt;so_perfilestate
)paren
suffix:semicolon
id|list_add_perfile
op_increment
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|stp-&gt;st_perfile
comma
op_amp
id|fp-&gt;fi_perfile
)paren
suffix:semicolon
id|stp-&gt;st_stateowner
op_assign
id|sop
suffix:semicolon
id|stp-&gt;st_file
op_assign
id|fp
suffix:semicolon
id|stp-&gt;st_stateid.si_boot
op_assign
id|boot_time
suffix:semicolon
id|stp-&gt;st_stateid.si_stateownerid
op_assign
id|sop-&gt;so_id
suffix:semicolon
id|stp-&gt;st_stateid.si_fileid
op_assign
id|fp-&gt;fi_id
suffix:semicolon
id|stp-&gt;st_stateid.si_generation
op_assign
l_int|0
suffix:semicolon
id|stp-&gt;st_access_bmap
op_assign
l_int|0
suffix:semicolon
id|stp-&gt;st_deny_bmap
op_assign
l_int|0
suffix:semicolon
id|__set_bit
c_func
(paren
id|open-&gt;op_share_access
comma
op_amp
id|stp-&gt;st_access_bmap
)paren
suffix:semicolon
id|__set_bit
c_func
(paren
id|open-&gt;op_share_deny
comma
op_amp
id|stp-&gt;st_deny_bmap
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|release_stateid
id|release_stateid
c_func
(paren
r_struct
id|nfs4_stateid
op_star
id|stp
comma
r_int
id|flags
)paren
(brace
id|list_del
c_func
(paren
op_amp
id|stp-&gt;st_hash
)paren
suffix:semicolon
id|list_del_perfile
op_increment
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|stp-&gt;st_perfile
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|stp-&gt;st_perfilestate
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|stp-&gt;st_vfs_set
)paren
op_logical_and
(paren
id|flags
op_amp
id|OPEN_STATE
)paren
)paren
(brace
id|release_stateid_lockowner
c_func
(paren
id|stp
)paren
suffix:semicolon
id|nfsd_close
c_func
(paren
id|stp-&gt;st_vfs_file
)paren
suffix:semicolon
id|vfsclose
op_increment
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|stp-&gt;st_vfs_set
)paren
op_logical_and
(paren
id|flags
op_amp
id|LOCK_STATE
)paren
)paren
(brace
r_struct
id|file
op_star
id|filp
op_assign
id|stp-&gt;st_vfs_file
suffix:semicolon
id|locks_remove_posix
c_func
(paren
id|filp
comma
(paren
id|fl_owner_t
)paren
id|stp-&gt;st_stateowner
)paren
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|stp
)paren
suffix:semicolon
id|stp
op_assign
l_int|NULL
suffix:semicolon
)brace
r_static
r_void
DECL|function|release_file
id|release_file
c_func
(paren
r_struct
id|nfs4_file
op_star
id|fp
)paren
(brace
id|free_file
op_increment
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|fp-&gt;fi_hash
)paren
suffix:semicolon
id|iput
c_func
(paren
id|fp-&gt;fi_inode
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|fp
)paren
suffix:semicolon
)brace
r_void
DECL|function|move_to_close_lru
id|move_to_close_lru
c_func
(paren
r_struct
id|nfs4_stateowner
op_star
id|sop
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;NFSD: move_to_close_lru nfs4_stateowner %p&bslash;n&quot;
comma
id|sop
)paren
suffix:semicolon
multiline_comment|/* remove stateowner from all other hash lists except perclient */
id|list_del_init
c_func
(paren
op_amp
id|sop-&gt;so_idhash
)paren
suffix:semicolon
id|list_del_init
c_func
(paren
op_amp
id|sop-&gt;so_strhash
)paren
suffix:semicolon
id|list_del_init
c_func
(paren
op_amp
id|sop-&gt;so_perlockowner
)paren
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|sop-&gt;so_close_lru
comma
op_amp
id|close_lru
)paren
suffix:semicolon
id|sop-&gt;so_time
op_assign
id|get_seconds
c_func
(paren
)paren
suffix:semicolon
)brace
r_void
DECL|function|release_state_owner
id|release_state_owner
c_func
(paren
r_struct
id|nfs4_stateid
op_star
id|stp
comma
r_struct
id|nfs4_stateowner
op_star
op_star
id|sopp
comma
r_int
id|flag
)paren
(brace
r_struct
id|nfs4_stateowner
op_star
id|sop
op_assign
id|stp-&gt;st_stateowner
suffix:semicolon
r_struct
id|nfs4_file
op_star
id|fp
op_assign
id|stp-&gt;st_file
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;NFSD: release_state_owner&bslash;n&quot;
)paren
suffix:semicolon
id|release_stateid
c_func
(paren
id|stp
comma
id|flag
)paren
suffix:semicolon
multiline_comment|/* place unused nfs4_stateowners on so_close_lru list to be&n;&t; * released by the laundromat service after the lease period&n;&t; * to enable us to handle CLOSE replay&n;&t; */
r_if
c_cond
(paren
id|sop-&gt;so_confirmed
op_logical_and
id|list_empty
c_func
(paren
op_amp
id|sop-&gt;so_perfilestate
)paren
)paren
id|move_to_close_lru
c_func
(paren
id|sop
)paren
suffix:semicolon
multiline_comment|/* unused nfs4_file&squot;s are releseed. XXX slab cache? */
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|fp-&gt;fi_perfile
)paren
)paren
(brace
id|release_file
c_func
(paren
id|fp
)paren
suffix:semicolon
)brace
)brace
r_static
r_int
DECL|function|cmp_owner_str
id|cmp_owner_str
c_func
(paren
r_struct
id|nfs4_stateowner
op_star
id|sop
comma
r_struct
id|xdr_netobj
op_star
id|owner
comma
id|clientid_t
op_star
id|clid
)paren
(brace
r_return
(paren
(paren
id|sop-&gt;so_owner.len
op_eq
id|owner-&gt;len
)paren
op_logical_and
op_logical_neg
id|memcmp
c_func
(paren
id|sop-&gt;so_owner.data
comma
id|owner-&gt;data
comma
id|owner-&gt;len
)paren
op_logical_and
(paren
id|sop-&gt;so_client-&gt;cl_clientid.cl_id
op_eq
id|clid-&gt;cl_id
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* search ownerstr_hashtbl[] for owner */
r_static
r_int
DECL|function|find_openstateowner_str
id|find_openstateowner_str
c_func
(paren
r_int
r_int
id|hashval
comma
r_struct
id|nfsd4_open
op_star
id|open
comma
r_struct
id|nfs4_stateowner
op_star
op_star
id|op
)paren
(brace
r_struct
id|nfs4_stateowner
op_star
id|local
op_assign
l_int|NULL
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|local
comma
op_amp
id|ownerstr_hashtbl
(braket
id|hashval
)braket
comma
id|so_strhash
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|cmp_owner_str
c_func
(paren
id|local
comma
op_amp
id|open-&gt;op_owner
comma
op_amp
id|open-&gt;op_clientid
)paren
)paren
r_continue
suffix:semicolon
op_star
id|op
op_assign
id|local
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* see if clientid is in confirmed hash table */
r_static
r_int
DECL|function|verify_clientid
id|verify_clientid
c_func
(paren
r_struct
id|nfs4_client
op_star
op_star
id|client
comma
id|clientid_t
op_star
id|clid
)paren
(brace
r_struct
id|nfs4_client
op_star
id|clp
suffix:semicolon
r_int
r_int
id|idhashval
op_assign
id|clientid_hashval
c_func
(paren
id|clid-&gt;cl_id
)paren
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|clp
comma
op_amp
id|conf_id_hashtbl
(braket
id|idhashval
)braket
comma
id|cl_idhash
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|cmp_clid
c_func
(paren
op_amp
id|clp-&gt;cl_clientid
comma
id|clid
)paren
)paren
r_continue
suffix:semicolon
op_star
id|client
op_assign
id|clp
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
op_star
id|client
op_assign
l_int|NULL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* search file_hashtbl[] for file */
r_static
r_int
DECL|function|find_file
id|find_file
c_func
(paren
r_int
r_int
id|hashval
comma
r_struct
id|inode
op_star
id|ino
comma
r_struct
id|nfs4_file
op_star
op_star
id|fp
)paren
(brace
r_struct
id|nfs4_file
op_star
id|local
op_assign
l_int|NULL
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|local
comma
op_amp
id|file_hashtbl
(braket
id|hashval
)braket
comma
id|fi_hash
)paren
(brace
r_if
c_cond
(paren
id|local-&gt;fi_inode
op_eq
id|ino
)paren
(brace
op_star
id|fp
op_assign
id|local
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|macro|TEST_ACCESS
mdefine_line|#define TEST_ACCESS(x) ((x &gt; 0 || x &lt; 4)?1:0)
DECL|macro|TEST_DENY
mdefine_line|#define TEST_DENY(x) ((x &gt;= 0 || x &lt; 5)?1:0)
r_void
DECL|function|set_access
id|set_access
c_func
(paren
r_int
r_int
op_star
id|access
comma
r_int
r_int
id|bmap
)paren
(brace
r_int
id|i
suffix:semicolon
op_star
id|access
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|i
comma
op_amp
id|bmap
)paren
)paren
op_star
id|access
op_or_assign
id|i
suffix:semicolon
)brace
)brace
r_void
DECL|function|set_deny
id|set_deny
c_func
(paren
r_int
r_int
op_star
id|deny
comma
r_int
r_int
id|bmap
)paren
(brace
r_int
id|i
suffix:semicolon
op_star
id|deny
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|i
comma
op_amp
id|bmap
)paren
)paren
op_star
id|deny
op_or_assign
id|i
suffix:semicolon
)brace
)brace
r_static
r_int
DECL|function|test_share
id|test_share
c_func
(paren
r_struct
id|nfs4_stateid
op_star
id|stp
comma
r_struct
id|nfsd4_open
op_star
id|open
)paren
(brace
r_int
r_int
id|access
comma
id|deny
suffix:semicolon
id|set_access
c_func
(paren
op_amp
id|access
comma
id|stp-&gt;st_access_bmap
)paren
suffix:semicolon
id|set_deny
c_func
(paren
op_amp
id|deny
comma
id|stp-&gt;st_deny_bmap
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|access
op_amp
id|open-&gt;op_share_deny
)paren
op_logical_or
(paren
id|deny
op_amp
id|open-&gt;op_share_access
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Called to check deny when READ with all zero stateid or&n; * WRITE with all zero or all one stateid&n; */
r_int
DECL|function|nfs4_share_conflict
id|nfs4_share_conflict
c_func
(paren
r_struct
id|svc_fh
op_star
id|current_fh
comma
r_int
r_int
id|deny_type
)paren
(brace
r_struct
id|inode
op_star
id|ino
op_assign
id|current_fh-&gt;fh_dentry-&gt;d_inode
suffix:semicolon
r_int
r_int
id|fi_hashval
suffix:semicolon
r_struct
id|nfs4_file
op_star
id|fp
suffix:semicolon
r_struct
id|nfs4_stateid
op_star
id|stp
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;NFSD: nfs4_share_conflict&bslash;n&quot;
)paren
suffix:semicolon
id|fi_hashval
op_assign
id|file_hashval
c_func
(paren
id|ino
)paren
suffix:semicolon
r_if
c_cond
(paren
id|find_file
c_func
(paren
id|fi_hashval
comma
id|ino
comma
op_amp
id|fp
)paren
)paren
(brace
multiline_comment|/* Search for conflicting share reservations */
id|list_for_each_entry
c_func
(paren
id|stp
comma
op_amp
id|fp-&gt;fi_perfile
comma
id|st_perfile
)paren
(brace
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|deny_type
comma
op_amp
id|stp-&gt;st_deny_bmap
)paren
op_logical_or
id|test_bit
c_func
(paren
id|NFS4_SHARE_DENY_BOTH
comma
op_amp
id|stp-&gt;st_deny_bmap
)paren
)paren
r_return
id|nfserr_share_denied
suffix:semicolon
)brace
)brace
r_return
id|nfs_ok
suffix:semicolon
)brace
r_static
r_inline
r_int
DECL|function|nfs4_file_upgrade
id|nfs4_file_upgrade
c_func
(paren
r_struct
id|file
op_star
id|filp
comma
r_int
r_int
id|share_access
)paren
(brace
r_int
id|status
suffix:semicolon
r_if
c_cond
(paren
id|share_access
op_amp
id|NFS4_SHARE_ACCESS_WRITE
)paren
(brace
id|status
op_assign
id|get_write_access
c_func
(paren
id|filp-&gt;f_dentry-&gt;d_inode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
)paren
r_return
id|nfserrno
c_func
(paren
id|status
)paren
suffix:semicolon
id|filp-&gt;f_mode
op_assign
(paren
id|filp-&gt;f_mode
op_or
id|FMODE_WRITE
)paren
op_amp
op_complement
id|FMODE_READ
suffix:semicolon
)brace
r_return
id|nfs_ok
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|nfs4_file_downgrade
id|nfs4_file_downgrade
c_func
(paren
r_struct
id|file
op_star
id|filp
comma
r_int
r_int
id|share_access
)paren
(brace
r_if
c_cond
(paren
id|share_access
op_amp
id|NFS4_SHARE_ACCESS_WRITE
)paren
(brace
id|put_write_access
c_func
(paren
id|filp-&gt;f_dentry-&gt;d_inode
)paren
suffix:semicolon
id|filp-&gt;f_mode
op_assign
(paren
id|filp-&gt;f_mode
op_or
id|FMODE_READ
)paren
op_amp
op_complement
id|FMODE_WRITE
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * nfsd4_process_open1()&n; * &t;lookup stateowner.&n; * &t;&t;found:&n; * &t;&t;&t;check confirmed &n; * &t;&t;&t;&t;confirmed:&n; * &t;&t;&t;&t;&t;check seqid&n; * &t;&t;&t;&t;not confirmed:&n; * &t;&t;&t;&t;&t;delete owner&n; * &t;&t;&t;&t;&t;create new owner&n; * &t;&t;notfound:&n; * &t;&t;&t;verify clientid&n; * &t;&t;&t;create new owner&n; *&n; * called with nfs4_lock_state() held.&n; */
r_int
DECL|function|nfsd4_process_open1
id|nfsd4_process_open1
c_func
(paren
r_struct
id|nfsd4_open
op_star
id|open
)paren
(brace
r_int
id|status
suffix:semicolon
id|clientid_t
op_star
id|clientid
op_assign
op_amp
id|open-&gt;op_clientid
suffix:semicolon
r_struct
id|nfs4_client
op_star
id|clp
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|strhashval
suffix:semicolon
r_struct
id|nfs4_stateowner
op_star
id|sop
op_assign
l_int|NULL
suffix:semicolon
id|status
op_assign
id|nfserr_inval
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|check_name
c_func
(paren
id|open-&gt;op_owner
)paren
)paren
r_goto
id|out
suffix:semicolon
id|status
op_assign
id|nfserr_stale_clientid
suffix:semicolon
r_if
c_cond
(paren
id|STALE_CLIENTID
c_func
(paren
op_amp
id|open-&gt;op_clientid
)paren
)paren
r_return
id|status
suffix:semicolon
id|strhashval
op_assign
id|ownerstr_hashval
c_func
(paren
id|clientid-&gt;cl_id
comma
id|open-&gt;op_owner
)paren
suffix:semicolon
r_if
c_cond
(paren
id|find_openstateowner_str
c_func
(paren
id|strhashval
comma
id|open
comma
op_amp
id|sop
)paren
)paren
(brace
id|open-&gt;op_stateowner
op_assign
id|sop
suffix:semicolon
multiline_comment|/* check for replay */
r_if
c_cond
(paren
id|open-&gt;op_seqid
op_eq
id|sop-&gt;so_seqid
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|sop-&gt;so_replay.rp_buflen
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;* The original OPEN failed in so spectacularly that we&n;&t;&t;&t;* don&squot;t even have replay data saved!  Therefore, we&n;&t;&t;&t;* have no choice but to continue processing&n;&t;&t;&t;* this OPEN; presumably, we&squot;ll fail again for the same&n;&t;&t;&t;* reason.&n;&t;&t;&t;*/
id|dprintk
c_func
(paren
l_string|&quot;nfsd4_process_open1: replay with no replay cache&bslash;n&quot;
)paren
suffix:semicolon
id|status
op_assign
id|NFS_OK
suffix:semicolon
r_goto
id|renew
suffix:semicolon
)brace
multiline_comment|/* replay: indicate to calling function */
id|status
op_assign
id|NFSERR_REPLAY_ME
suffix:semicolon
r_return
id|status
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sop-&gt;so_confirmed
)paren
(brace
r_if
c_cond
(paren
id|open-&gt;op_seqid
op_eq
id|sop-&gt;so_seqid
op_plus
l_int|1
)paren
(brace
id|status
op_assign
id|nfs_ok
suffix:semicolon
r_goto
id|renew
suffix:semicolon
)brace
id|status
op_assign
id|nfserr_bad_seqid
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* If we get here, we received and OPEN for an unconfirmed&n;&t;&t; * nfs4_stateowner. &n;&t;&t; * Since the sequid&squot;s are different, purge the &n;&t;&t; * existing nfs4_stateowner, and instantiate a new one.&n;&t;&t; */
id|clp
op_assign
id|sop-&gt;so_client
suffix:semicolon
id|release_stateowner
c_func
(paren
id|sop
)paren
suffix:semicolon
r_goto
id|instantiate_new_owner
suffix:semicolon
)brace
multiline_comment|/* nfs4_stateowner not found. &n;&t;* verify clientid and instantiate new nfs4_stateowner&n;&t;* if verify fails this is presumably the result of the &n;&t;* client&squot;s lease expiring.&n;&t;*&n;&t;* XXX compare clp-&gt;cl_addr with rqstp addr? &n;&t;*/
id|status
op_assign
id|nfserr_expired
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|verify_clientid
c_func
(paren
op_amp
id|clp
comma
id|clientid
)paren
)paren
r_goto
id|out
suffix:semicolon
id|instantiate_new_owner
suffix:colon
id|status
op_assign
id|nfserr_resource
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|sop
op_assign
id|alloc_init_open_stateowner
c_func
(paren
id|strhashval
comma
id|clp
comma
id|open
)paren
)paren
)paren
r_goto
id|out
suffix:semicolon
id|open-&gt;op_stateowner
op_assign
id|sop
suffix:semicolon
id|status
op_assign
id|nfs_ok
suffix:semicolon
id|renew
suffix:colon
id|renew_client
c_func
(paren
id|sop-&gt;so_client
)paren
suffix:semicolon
id|out
suffix:colon
r_if
c_cond
(paren
id|status
op_logical_and
id|open-&gt;op_claim_type
op_eq
id|NFS4_OPEN_CLAIM_PREVIOUS
)paren
id|status
op_assign
id|nfserr_reclaim_bad
suffix:semicolon
r_return
id|status
suffix:semicolon
)brace
multiline_comment|/*&n; * called with nfs4_lock_state() held.&n; */
r_int
DECL|function|nfsd4_process_open2
id|nfsd4_process_open2
c_func
(paren
r_struct
id|svc_rqst
op_star
id|rqstp
comma
r_struct
id|svc_fh
op_star
id|current_fh
comma
r_struct
id|nfsd4_open
op_star
id|open
)paren
(brace
r_struct
id|iattr
id|iattr
suffix:semicolon
r_struct
id|nfs4_stateowner
op_star
id|sop
op_assign
id|open-&gt;op_stateowner
suffix:semicolon
r_struct
id|nfs4_file
op_star
id|fp
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|inode
op_star
id|ino
suffix:semicolon
r_int
r_int
id|fi_hashval
suffix:semicolon
r_struct
id|nfs4_stateid
op_star
id|stq
comma
op_star
id|stp
op_assign
l_int|NULL
suffix:semicolon
r_int
id|status
suffix:semicolon
id|status
op_assign
id|nfserr_resource
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sop
)paren
r_return
id|status
suffix:semicolon
id|ino
op_assign
id|current_fh-&gt;fh_dentry-&gt;d_inode
suffix:semicolon
id|status
op_assign
id|nfserr_inval
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|TEST_ACCESS
c_func
(paren
id|open-&gt;op_share_access
)paren
op_logical_or
op_logical_neg
id|TEST_DENY
c_func
(paren
id|open-&gt;op_share_deny
)paren
)paren
r_goto
id|out
suffix:semicolon
id|fi_hashval
op_assign
id|file_hashval
c_func
(paren
id|ino
)paren
suffix:semicolon
r_if
c_cond
(paren
id|find_file
c_func
(paren
id|fi_hashval
comma
id|ino
comma
op_amp
id|fp
)paren
)paren
(brace
multiline_comment|/* Search for conflicting share reservations */
id|status
op_assign
id|nfserr_share_denied
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|stq
comma
op_amp
id|fp-&gt;fi_perfile
comma
id|st_perfile
)paren
(brace
r_if
c_cond
(paren
id|stq-&gt;st_stateowner
op_eq
id|sop
)paren
(brace
id|stp
op_assign
id|stq
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* ignore lock owners */
r_if
c_cond
(paren
id|stq-&gt;st_stateowner-&gt;so_is_open_owner
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|test_share
c_func
(paren
id|stq
comma
id|open
)paren
)paren
r_goto
id|out
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* No nfs4_file found; allocate and init a new one */
id|status
op_assign
id|nfserr_resource
suffix:semicolon
r_if
c_cond
(paren
(paren
id|fp
op_assign
id|alloc_init_file
c_func
(paren
id|fi_hashval
comma
id|ino
)paren
)paren
op_eq
l_int|NULL
)paren
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|stp
)paren
(brace
r_int
id|flags
op_assign
l_int|0
suffix:semicolon
id|status
op_assign
id|nfserr_resource
suffix:semicolon
r_if
c_cond
(paren
(paren
id|stp
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|nfs4_stateid
)paren
comma
id|GFP_KERNEL
)paren
)paren
op_eq
l_int|NULL
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|open-&gt;op_share_access
op_amp
id|NFS4_SHARE_ACCESS_WRITE
)paren
id|flags
op_assign
id|MAY_WRITE
suffix:semicolon
r_else
id|flags
op_assign
id|MAY_READ
suffix:semicolon
r_if
c_cond
(paren
(paren
id|status
op_assign
id|nfsd_open
c_func
(paren
id|rqstp
comma
id|current_fh
comma
id|S_IFREG
comma
id|flags
comma
op_amp
id|stp-&gt;st_vfs_file
)paren
)paren
op_ne
l_int|0
)paren
r_goto
id|out_free
suffix:semicolon
id|vfsopen
op_increment
suffix:semicolon
id|init_stateid
c_func
(paren
id|stp
comma
id|fp
comma
id|sop
comma
id|open
)paren
suffix:semicolon
id|stp-&gt;st_vfs_set
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* This is an upgrade of an existing OPEN. &n;&t;&t; * OR the incoming share with the existing &n;&t;&t; * nfs4_stateid share */
r_int
r_int
id|share_access
suffix:semicolon
id|set_access
c_func
(paren
op_amp
id|share_access
comma
id|stp-&gt;st_access_bmap
)paren
suffix:semicolon
id|share_access
op_assign
op_complement
id|share_access
suffix:semicolon
id|share_access
op_and_assign
id|open-&gt;op_share_access
suffix:semicolon
multiline_comment|/* update the struct file */
r_if
c_cond
(paren
(paren
id|status
op_assign
id|nfs4_file_upgrade
c_func
(paren
id|stp-&gt;st_vfs_file
comma
id|share_access
)paren
)paren
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* remember the open */
id|set_bit
c_func
(paren
id|open-&gt;op_share_access
comma
op_amp
id|stp-&gt;st_access_bmap
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|open-&gt;op_share_deny
comma
op_amp
id|stp-&gt;st_deny_bmap
)paren
suffix:semicolon
multiline_comment|/* bump the stateid */
id|update_stateid
c_func
(paren
op_amp
id|stp-&gt;st_stateid
)paren
suffix:semicolon
)brace
id|dprintk
c_func
(paren
l_string|&quot;nfs4_process_open2: stateid=(%08x/%08x/%08x/%08x)&bslash;n&bslash;n&quot;
comma
id|stp-&gt;st_stateid.si_boot
comma
id|stp-&gt;st_stateid.si_stateownerid
comma
id|stp-&gt;st_stateid.si_fileid
comma
id|stp-&gt;st_stateid.si_generation
)paren
suffix:semicolon
r_if
c_cond
(paren
id|open-&gt;op_truncate
)paren
(brace
id|iattr.ia_valid
op_assign
id|ATTR_SIZE
suffix:semicolon
id|iattr.ia_size
op_assign
l_int|0
suffix:semicolon
id|status
op_assign
id|nfsd_setattr
c_func
(paren
id|rqstp
comma
id|current_fh
comma
op_amp
id|iattr
comma
l_int|0
comma
(paren
id|time_t
)paren
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
)paren
r_goto
id|out
suffix:semicolon
)brace
id|memcpy
c_func
(paren
op_amp
id|open-&gt;op_stateid
comma
op_amp
id|stp-&gt;st_stateid
comma
r_sizeof
(paren
id|stateid_t
)paren
)paren
suffix:semicolon
id|open-&gt;op_delegate_type
op_assign
id|NFS4_OPEN_DELEGATE_NONE
suffix:semicolon
id|status
op_assign
id|nfs_ok
suffix:semicolon
id|out
suffix:colon
r_if
c_cond
(paren
id|fp
op_logical_and
id|list_empty
c_func
(paren
op_amp
id|fp-&gt;fi_perfile
)paren
)paren
id|release_file
c_func
(paren
id|fp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|open-&gt;op_claim_type
op_eq
id|NFS4_OPEN_CLAIM_PREVIOUS
)paren
(brace
r_if
c_cond
(paren
id|status
)paren
id|status
op_assign
id|nfserr_reclaim_bad
suffix:semicolon
r_else
(brace
multiline_comment|/* successful reclaim. so_seqid is decremented because&n;&t;&t;* it will be bumped in encode_open&n;&t;&t;*/
id|open-&gt;op_stateowner-&gt;so_confirmed
op_assign
l_int|1
suffix:semicolon
id|open-&gt;op_stateowner-&gt;so_seqid
op_decrement
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;* To finish the open response, we just need to set the rflags.&n;&t;*/
id|open-&gt;op_rflags
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|open-&gt;op_stateowner-&gt;so_confirmed
)paren
id|open-&gt;op_rflags
op_or_assign
id|NFS4_OPEN_RESULT_CONFIRM
suffix:semicolon
r_return
id|status
suffix:semicolon
id|out_free
suffix:colon
id|kfree
c_func
(paren
id|stp
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
DECL|variable|laundromat_work
r_static
r_struct
id|work_struct
id|laundromat_work
suffix:semicolon
r_static
r_void
id|laundromat_main
c_func
(paren
r_void
op_star
)paren
suffix:semicolon
r_static
id|DECLARE_WORK
c_func
(paren
id|laundromat_work
comma
id|laundromat_main
comma
l_int|NULL
)paren
suffix:semicolon
r_int
DECL|function|nfsd4_renew
id|nfsd4_renew
c_func
(paren
id|clientid_t
op_star
id|clid
)paren
(brace
r_struct
id|nfs4_client
op_star
id|clp
suffix:semicolon
r_int
r_int
id|idhashval
suffix:semicolon
r_int
id|status
suffix:semicolon
id|nfs4_lock_state
c_func
(paren
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;process_renew(%08x/%08x): starting&bslash;n&quot;
comma
id|clid-&gt;cl_boot
comma
id|clid-&gt;cl_id
)paren
suffix:semicolon
id|status
op_assign
id|nfserr_stale_clientid
suffix:semicolon
r_if
c_cond
(paren
id|STALE_CLIENTID
c_func
(paren
id|clid
)paren
)paren
r_goto
id|out
suffix:semicolon
id|status
op_assign
id|nfs_ok
suffix:semicolon
id|idhashval
op_assign
id|clientid_hashval
c_func
(paren
id|clid-&gt;cl_id
)paren
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|clp
comma
op_amp
id|conf_id_hashtbl
(braket
id|idhashval
)braket
comma
id|cl_idhash
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|cmp_clid
c_func
(paren
op_amp
id|clp-&gt;cl_clientid
comma
id|clid
)paren
)paren
r_continue
suffix:semicolon
id|renew_client
c_func
(paren
id|clp
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|list_for_each_entry
c_func
(paren
id|clp
comma
op_amp
id|unconf_id_hashtbl
(braket
id|idhashval
)braket
comma
id|cl_idhash
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|cmp_clid
c_func
(paren
op_amp
id|clp-&gt;cl_clientid
comma
id|clid
)paren
)paren
r_continue
suffix:semicolon
id|renew_client
c_func
(paren
id|clp
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n;&t;* Couldn&squot;t find an nfs4_client for this clientid.  &n;&t;* Presumably this is because the client took too long to &n;&t;* RENEW, so return NFS4ERR_EXPIRED.&n;&t;*/
id|dprintk
c_func
(paren
l_string|&quot;nfsd4_renew: clientid not found!&bslash;n&quot;
)paren
suffix:semicolon
id|status
op_assign
id|nfserr_expired
suffix:semicolon
id|out
suffix:colon
id|nfs4_unlock_state
c_func
(paren
)paren
suffix:semicolon
r_return
id|status
suffix:semicolon
)brace
id|time_t
DECL|function|nfs4_laundromat
id|nfs4_laundromat
c_func
(paren
r_void
)paren
(brace
r_struct
id|nfs4_client
op_star
id|clp
suffix:semicolon
r_struct
id|nfs4_stateowner
op_star
id|sop
suffix:semicolon
r_struct
id|list_head
op_star
id|pos
comma
op_star
id|next
suffix:semicolon
id|time_t
id|cutoff
op_assign
id|get_seconds
c_func
(paren
)paren
op_minus
id|NFSD_LEASE_TIME
suffix:semicolon
id|time_t
id|t
comma
id|clientid_val
op_assign
id|NFSD_LEASE_TIME
suffix:semicolon
id|time_t
id|u
comma
id|close_val
op_assign
id|NFSD_LEASE_TIME
suffix:semicolon
id|nfs4_lock_state
c_func
(paren
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;NFSD: laundromat service - starting, examining clients&bslash;n&quot;
)paren
suffix:semicolon
id|list_for_each_safe
c_func
(paren
id|pos
comma
id|next
comma
op_amp
id|client_lru
)paren
(brace
id|clp
op_assign
id|list_entry
c_func
(paren
id|pos
comma
r_struct
id|nfs4_client
comma
id|cl_lru
)paren
suffix:semicolon
r_if
c_cond
(paren
id|time_after
c_func
(paren
(paren
r_int
r_int
)paren
id|clp-&gt;cl_time
comma
(paren
r_int
r_int
)paren
id|cutoff
)paren
)paren
(brace
id|t
op_assign
id|clp-&gt;cl_time
op_minus
id|cutoff
suffix:semicolon
r_if
c_cond
(paren
id|clientid_val
OG
id|t
)paren
id|clientid_val
op_assign
id|t
suffix:semicolon
r_break
suffix:semicolon
)brace
id|dprintk
c_func
(paren
l_string|&quot;NFSD: purging unused client (clientid %08x)&bslash;n&quot;
comma
id|clp-&gt;cl_clientid.cl_id
)paren
suffix:semicolon
id|expire_client
c_func
(paren
id|clp
)paren
suffix:semicolon
)brace
id|list_for_each_safe
c_func
(paren
id|pos
comma
id|next
comma
op_amp
id|close_lru
)paren
(brace
id|sop
op_assign
id|list_entry
c_func
(paren
id|pos
comma
r_struct
id|nfs4_stateowner
comma
id|so_close_lru
)paren
suffix:semicolon
r_if
c_cond
(paren
id|time_after
c_func
(paren
(paren
r_int
r_int
)paren
id|sop-&gt;so_time
comma
(paren
r_int
r_int
)paren
id|cutoff
)paren
)paren
(brace
id|u
op_assign
id|sop-&gt;so_time
op_minus
id|cutoff
suffix:semicolon
r_if
c_cond
(paren
id|close_val
OG
id|u
)paren
id|close_val
op_assign
id|u
suffix:semicolon
r_break
suffix:semicolon
)brace
id|dprintk
c_func
(paren
l_string|&quot;NFSD: purging unused open stateowner (so_id %d)&bslash;n&quot;
comma
id|sop-&gt;so_id
)paren
suffix:semicolon
id|release_stateowner
c_func
(paren
id|sop
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|clientid_val
OL
id|NFSD_LAUNDROMAT_MINTIMEOUT
)paren
id|clientid_val
op_assign
id|NFSD_LAUNDROMAT_MINTIMEOUT
suffix:semicolon
id|nfs4_unlock_state
c_func
(paren
)paren
suffix:semicolon
r_return
id|clientid_val
suffix:semicolon
)brace
r_void
DECL|function|laundromat_main
id|laundromat_main
c_func
(paren
r_void
op_star
id|not_used
)paren
(brace
id|time_t
id|t
suffix:semicolon
id|t
op_assign
id|nfs4_laundromat
c_func
(paren
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;NFSD: laundromat_main - sleeping for %ld seconds&bslash;n&quot;
comma
id|t
)paren
suffix:semicolon
id|schedule_delayed_work
c_func
(paren
op_amp
id|laundromat_work
comma
id|t
op_star
id|HZ
)paren
suffix:semicolon
)brace
multiline_comment|/* search ownerid_hashtbl[] and close_lru for stateid owner&n; * (stateid-&gt;si_stateownerid)&n; */
r_struct
id|nfs4_stateowner
op_star
DECL|function|find_openstateowner_id
id|find_openstateowner_id
c_func
(paren
id|u32
id|st_id
comma
r_int
id|flags
)paren
(brace
r_struct
id|nfs4_stateowner
op_star
id|local
op_assign
l_int|NULL
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;NFSD: find_openstateowner_id %d&bslash;n&quot;
comma
id|st_id
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|CLOSE_STATE
)paren
(brace
id|list_for_each_entry
c_func
(paren
id|local
comma
op_amp
id|close_lru
comma
id|so_close_lru
)paren
(brace
r_if
c_cond
(paren
id|local-&gt;so_id
op_eq
id|st_id
)paren
r_return
id|local
suffix:semicolon
)brace
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
r_static
r_inline
r_int
DECL|function|nfs4_check_fh
id|nfs4_check_fh
c_func
(paren
r_struct
id|svc_fh
op_star
id|fhp
comma
r_struct
id|nfs4_stateid
op_star
id|stp
)paren
(brace
r_return
(paren
id|stp-&gt;st_vfs_set
op_eq
l_int|0
op_logical_or
id|fhp-&gt;fh_dentry-&gt;d_inode
op_ne
id|stp-&gt;st_vfs_file-&gt;f_dentry-&gt;d_inode
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|STALE_STATEID
id|STALE_STATEID
c_func
(paren
id|stateid_t
op_star
id|stateid
)paren
(brace
r_if
c_cond
(paren
id|stateid-&gt;si_boot
op_eq
id|boot_time
)paren
r_return
l_int|0
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;NFSD: stale stateid (%08x/%08x/%08x/%08x)!&bslash;n&quot;
comma
id|stateid-&gt;si_boot
comma
id|stateid-&gt;si_stateownerid
comma
id|stateid-&gt;si_fileid
comma
id|stateid-&gt;si_generation
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;* Checks for stateid operations&n;*/
r_int
DECL|function|nfs4_preprocess_stateid_op
id|nfs4_preprocess_stateid_op
c_func
(paren
r_struct
id|svc_fh
op_star
id|current_fh
comma
id|stateid_t
op_star
id|stateid
comma
r_int
id|flags
comma
r_struct
id|nfs4_stateid
op_star
op_star
id|stpp
)paren
(brace
r_struct
id|nfs4_stateid
op_star
id|stp
suffix:semicolon
r_int
id|status
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;NFSD: preprocess_stateid_op: stateid = (%08x/%08x/%08x/%08x)&bslash;n&quot;
comma
id|stateid-&gt;si_boot
comma
id|stateid-&gt;si_stateownerid
comma
id|stateid-&gt;si_fileid
comma
id|stateid-&gt;si_generation
)paren
suffix:semicolon
op_star
id|stpp
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* STALE STATEID */
id|status
op_assign
id|nfserr_stale_stateid
suffix:semicolon
r_if
c_cond
(paren
id|STALE_STATEID
c_func
(paren
id|stateid
)paren
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* BAD STATEID */
id|status
op_assign
id|nfserr_bad_stateid
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|stp
op_assign
id|find_stateid
c_func
(paren
id|stateid
comma
id|flags
)paren
)paren
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;NFSD: preprocess_stateid_op: no open stateid!&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|flags
op_amp
id|CHECK_FH
)paren
op_logical_and
id|nfs4_check_fh
c_func
(paren
id|current_fh
comma
id|stp
)paren
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;NFSD: preprocess_stateid_op: fh-stateid mismatch!&bslash;n&quot;
)paren
suffix:semicolon
id|stp-&gt;st_vfs_set
op_assign
l_int|0
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|stp-&gt;st_stateowner-&gt;so_confirmed
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;preprocess_stateid_op: lockowner not confirmed yet!&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|stateid-&gt;si_generation
OG
id|stp-&gt;st_stateid.si_generation
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;preprocess_stateid_op: future stateid?!&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* OLD STATEID */
id|status
op_assign
id|nfserr_old_stateid
suffix:semicolon
r_if
c_cond
(paren
id|stateid-&gt;si_generation
OL
id|stp-&gt;st_stateid.si_generation
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;preprocess_stateid_op: old stateid!&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
op_star
id|stpp
op_assign
id|stp
suffix:semicolon
id|status
op_assign
id|nfs_ok
suffix:semicolon
id|renew_client
c_func
(paren
id|stp-&gt;st_stateowner-&gt;so_client
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|status
suffix:semicolon
)brace
multiline_comment|/* &n; * Checks for sequence id mutating operations. &n; */
r_int
DECL|function|nfs4_preprocess_seqid_op
id|nfs4_preprocess_seqid_op
c_func
(paren
r_struct
id|svc_fh
op_star
id|current_fh
comma
id|u32
id|seqid
comma
id|stateid_t
op_star
id|stateid
comma
r_int
id|flags
comma
r_struct
id|nfs4_stateowner
op_star
op_star
id|sopp
comma
r_struct
id|nfs4_stateid
op_star
op_star
id|stpp
comma
id|clientid_t
op_star
id|lockclid
)paren
(brace
r_int
id|status
suffix:semicolon
r_struct
id|nfs4_stateid
op_star
id|stp
suffix:semicolon
r_struct
id|nfs4_stateowner
op_star
id|sop
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;NFSD: preprocess_seqid_op: seqid=%d &quot;
l_string|&quot;stateid = (%08x/%08x/%08x/%08x)&bslash;n&quot;
comma
id|seqid
comma
id|stateid-&gt;si_boot
comma
id|stateid-&gt;si_stateownerid
comma
id|stateid-&gt;si_fileid
comma
id|stateid-&gt;si_generation
)paren
suffix:semicolon
op_star
id|stpp
op_assign
l_int|NULL
suffix:semicolon
op_star
id|sopp
op_assign
l_int|NULL
suffix:semicolon
id|status
op_assign
id|nfserr_bad_stateid
suffix:semicolon
r_if
c_cond
(paren
id|ZERO_STATEID
c_func
(paren
id|stateid
)paren
op_logical_or
id|ONE_STATEID
c_func
(paren
id|stateid
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;NFSD: preprocess_seqid_op: magic stateid!&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|status
op_assign
id|nfserr_stale_stateid
suffix:semicolon
r_if
c_cond
(paren
id|STALE_STATEID
c_func
(paren
id|stateid
)paren
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/*&n;&t;* We return BAD_STATEID if filehandle doesn&squot;t match stateid, &n;&t;* the confirmed flag is incorrecly set, or the generation &n;&t;* number is incorrect.  &n;&t;* If there is no entry in the openfile table for this id, &n;&t;* we can&squot;t always return BAD_STATEID;&n;&t;* this might be a retransmitted CLOSE which has arrived after &n;&t;* the openfile has been released.&n;&t;*/
r_if
c_cond
(paren
op_logical_neg
(paren
id|stp
op_assign
id|find_stateid
c_func
(paren
id|stateid
comma
id|flags
)paren
)paren
)paren
r_goto
id|no_nfs4_stateid
suffix:semicolon
id|status
op_assign
id|nfserr_bad_stateid
suffix:semicolon
multiline_comment|/* for new lock stateowners:&n;&t; * check that the lock-&gt;v.new.open_stateid&n;&t; * refers to an open stateowner&n;&t; *&n;&t; * check that the lockclid (nfs4_lock-&gt;v.new.clientid) is the same&n;&t; * as the open_stateid-&gt;st_stateowner-&gt;so_client-&gt;clientid&n;&t; */
r_if
c_cond
(paren
id|lockclid
)paren
(brace
r_struct
id|nfs4_stateowner
op_star
id|sop
op_assign
id|stp-&gt;st_stateowner
suffix:semicolon
r_struct
id|nfs4_client
op_star
id|clp
op_assign
id|sop-&gt;so_client
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sop-&gt;so_is_open_owner
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cmp_clid
c_func
(paren
op_amp
id|clp-&gt;cl_clientid
comma
id|lockclid
)paren
)paren
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|flags
op_amp
id|CHECK_FH
)paren
op_logical_and
id|nfs4_check_fh
c_func
(paren
id|current_fh
comma
id|stp
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;NFSD: preprocess_seqid_op: fh-stateid mismatch!&bslash;n&quot;
)paren
suffix:semicolon
id|stp-&gt;st_vfs_set
op_assign
l_int|0
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
op_star
id|stpp
op_assign
id|stp
suffix:semicolon
op_star
id|sopp
op_assign
id|sop
op_assign
id|stp-&gt;st_stateowner
suffix:semicolon
multiline_comment|/*&n;&t;*  We now validate the seqid and stateid generation numbers.&n;&t;*  For the moment, we ignore the possibility of &n;&t;*  generation number wraparound.&n;&t;*/
r_if
c_cond
(paren
id|seqid
op_ne
id|sop-&gt;so_seqid
op_plus
l_int|1
)paren
r_goto
id|check_replay
suffix:semicolon
r_if
c_cond
(paren
id|sop-&gt;so_confirmed
)paren
(brace
r_if
c_cond
(paren
id|flags
op_amp
id|CONFIRM
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;NFSD: preprocess_seqid_op: expected unconfirmed stateowner!&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|flags
op_amp
id|CONFIRM
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;NFSD: preprocess_seqid_op: stateowner not confirmed yet!&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|stateid-&gt;si_generation
OG
id|stp-&gt;st_stateid.si_generation
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;NFSD: preprocess_seqid_op: future stateid?!&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|status
op_assign
id|nfserr_old_stateid
suffix:semicolon
r_if
c_cond
(paren
id|stateid-&gt;si_generation
OL
id|stp-&gt;st_stateid.si_generation
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;NFSD: preprocess_seqid_op: old stateid!&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* XXX renew the client lease here */
id|status
op_assign
id|nfs_ok
suffix:semicolon
id|out
suffix:colon
r_return
id|status
suffix:semicolon
id|no_nfs4_stateid
suffix:colon
multiline_comment|/*&n;&t;* We determine whether this is a bad stateid or a replay, &n;&t;* starting by trying to look up the stateowner.&n;&t;* If stateowner is not found - stateid is bad.&n;&t;*/
r_if
c_cond
(paren
op_logical_neg
(paren
id|sop
op_assign
id|find_openstateowner_id
c_func
(paren
id|stateid-&gt;si_stateownerid
comma
id|flags
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;NFSD: preprocess_seqid_op: no stateowner or nfs4_stateid!&bslash;n&quot;
)paren
suffix:semicolon
id|status
op_assign
id|nfserr_bad_stateid
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
op_star
id|sopp
op_assign
id|sop
suffix:semicolon
id|check_replay
suffix:colon
r_if
c_cond
(paren
id|seqid
op_eq
id|sop-&gt;so_seqid
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;NFSD: preprocess_seqid_op: retransmission?&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* indicate replay to calling function */
id|status
op_assign
id|NFSERR_REPLAY_ME
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;NFSD: preprocess_seqid_op: bad seqid (expected %d, got %d&bslash;n&quot;
comma
id|sop-&gt;so_seqid
op_plus
l_int|1
comma
id|seqid
)paren
suffix:semicolon
op_star
id|sopp
op_assign
l_int|NULL
suffix:semicolon
id|status
op_assign
id|nfserr_bad_seqid
suffix:semicolon
)brace
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n; * eventually, this will perform an upcall to the &squot;state daemon&squot; as well as&n; * set the cl_first_state field.&n; */
r_void
DECL|function|first_state
id|first_state
c_func
(paren
r_struct
id|nfs4_client
op_star
id|clp
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|clp-&gt;cl_first_state
)paren
id|clp-&gt;cl_first_state
op_assign
id|get_seconds
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * nfs4_unlock_state(); called in encode&n; */
r_int
DECL|function|nfsd4_open_confirm
id|nfsd4_open_confirm
c_func
(paren
r_struct
id|svc_rqst
op_star
id|rqstp
comma
r_struct
id|svc_fh
op_star
id|current_fh
comma
r_struct
id|nfsd4_open_confirm
op_star
id|oc
)paren
(brace
r_int
id|status
suffix:semicolon
r_struct
id|nfs4_stateowner
op_star
id|sop
suffix:semicolon
r_struct
id|nfs4_stateid
op_star
id|stp
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;NFSD: nfsd4_open_confirm on file %.*s&bslash;n&quot;
comma
(paren
r_int
)paren
id|current_fh-&gt;fh_dentry-&gt;d_name.len
comma
id|current_fh-&gt;fh_dentry-&gt;d_name.name
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|status
op_assign
id|fh_verify
c_func
(paren
id|rqstp
comma
id|current_fh
comma
id|S_IFREG
comma
l_int|0
)paren
)paren
)paren
r_goto
id|out
suffix:semicolon
id|oc-&gt;oc_stateowner
op_assign
l_int|NULL
suffix:semicolon
id|nfs4_lock_state
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|status
op_assign
id|nfs4_preprocess_seqid_op
c_func
(paren
id|current_fh
comma
id|oc-&gt;oc_seqid
comma
op_amp
id|oc-&gt;oc_req_stateid
comma
id|CHECK_FH
op_or
id|CONFIRM
op_or
id|OPEN_STATE
comma
op_amp
id|oc-&gt;oc_stateowner
comma
op_amp
id|stp
comma
l_int|NULL
)paren
)paren
)paren
r_goto
id|out
suffix:semicolon
id|sop
op_assign
id|oc-&gt;oc_stateowner
suffix:semicolon
id|sop-&gt;so_confirmed
op_assign
l_int|1
suffix:semicolon
id|update_stateid
c_func
(paren
op_amp
id|stp-&gt;st_stateid
)paren
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|oc-&gt;oc_resp_stateid
comma
op_amp
id|stp-&gt;st_stateid
comma
r_sizeof
(paren
id|stateid_t
)paren
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;NFSD: nfsd4_open_confirm: success, seqid=%d &quot;
l_string|&quot;stateid=(%08x/%08x/%08x/%08x)&bslash;n&quot;
comma
id|oc-&gt;oc_seqid
comma
id|stp-&gt;st_stateid.si_boot
comma
id|stp-&gt;st_stateid.si_stateownerid
comma
id|stp-&gt;st_stateid.si_fileid
comma
id|stp-&gt;st_stateid.si_generation
)paren
suffix:semicolon
id|status
op_assign
id|nfs_ok
suffix:semicolon
id|first_state
c_func
(paren
id|sop-&gt;so_client
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|status
suffix:semicolon
)brace
multiline_comment|/*&n; * unset all bits in union bitmap (bmap) that&n; * do not exist in share (from successful OPEN_DOWNGRADE)&n; */
r_static
r_void
DECL|function|reset_union_bmap_access
id|reset_union_bmap_access
c_func
(paren
r_int
r_int
id|access
comma
r_int
r_int
op_star
id|bmap
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|i
op_amp
id|access
)paren
op_ne
id|i
)paren
id|__clear_bit
c_func
(paren
id|i
comma
id|bmap
)paren
suffix:semicolon
)brace
)brace
r_static
r_void
DECL|function|reset_union_bmap_deny
id|reset_union_bmap_deny
c_func
(paren
r_int
r_int
id|deny
comma
r_int
r_int
op_star
id|bmap
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|i
op_amp
id|deny
)paren
op_ne
id|i
)paren
id|__clear_bit
c_func
(paren
id|i
comma
id|bmap
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * nfs4_unlock_state(); called in encode&n; */
r_int
DECL|function|nfsd4_open_downgrade
id|nfsd4_open_downgrade
c_func
(paren
r_struct
id|svc_rqst
op_star
id|rqstp
comma
r_struct
id|svc_fh
op_star
id|current_fh
comma
r_struct
id|nfsd4_open_downgrade
op_star
id|od
)paren
(brace
r_int
id|status
suffix:semicolon
r_struct
id|nfs4_stateid
op_star
id|stp
suffix:semicolon
r_int
r_int
id|share_access
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;NFSD: nfsd4_open_downgrade on file %.*s&bslash;n&quot;
comma
(paren
r_int
)paren
id|current_fh-&gt;fh_dentry-&gt;d_name.len
comma
id|current_fh-&gt;fh_dentry-&gt;d_name.name
)paren
suffix:semicolon
id|od-&gt;od_stateowner
op_assign
l_int|NULL
suffix:semicolon
id|status
op_assign
id|nfserr_inval
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|TEST_ACCESS
c_func
(paren
id|od-&gt;od_share_access
)paren
op_logical_or
op_logical_neg
id|TEST_DENY
c_func
(paren
id|od-&gt;od_share_deny
)paren
)paren
r_goto
id|out
suffix:semicolon
id|nfs4_lock_state
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|status
op_assign
id|nfs4_preprocess_seqid_op
c_func
(paren
id|current_fh
comma
id|od-&gt;od_seqid
comma
op_amp
id|od-&gt;od_stateid
comma
id|CHECK_FH
op_or
id|OPEN_STATE
comma
op_amp
id|od-&gt;od_stateowner
comma
op_amp
id|stp
comma
l_int|NULL
)paren
)paren
)paren
r_goto
id|out
suffix:semicolon
id|status
op_assign
id|nfserr_inval
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|test_bit
c_func
(paren
id|od-&gt;od_share_access
comma
op_amp
id|stp-&gt;st_access_bmap
)paren
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;NFSD:access not a subset current bitmap: 0x%lx, input access=%08x&bslash;n&quot;
comma
id|stp-&gt;st_access_bmap
comma
id|od-&gt;od_share_access
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|test_bit
c_func
(paren
id|od-&gt;od_share_deny
comma
op_amp
id|stp-&gt;st_deny_bmap
)paren
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;NFSD:deny not a subset current bitmap: 0x%lx, input deny=%08x&bslash;n&quot;
comma
id|stp-&gt;st_deny_bmap
comma
id|od-&gt;od_share_deny
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|set_access
c_func
(paren
op_amp
id|share_access
comma
id|stp-&gt;st_access_bmap
)paren
suffix:semicolon
id|nfs4_file_downgrade
c_func
(paren
id|stp-&gt;st_vfs_file
comma
id|share_access
op_amp
op_complement
id|od-&gt;od_share_access
)paren
suffix:semicolon
id|reset_union_bmap_access
c_func
(paren
id|od-&gt;od_share_access
comma
op_amp
id|stp-&gt;st_access_bmap
)paren
suffix:semicolon
id|reset_union_bmap_deny
c_func
(paren
id|od-&gt;od_share_deny
comma
op_amp
id|stp-&gt;st_deny_bmap
)paren
suffix:semicolon
id|update_stateid
c_func
(paren
op_amp
id|stp-&gt;st_stateid
)paren
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|od-&gt;od_stateid
comma
op_amp
id|stp-&gt;st_stateid
comma
r_sizeof
(paren
id|stateid_t
)paren
)paren
suffix:semicolon
id|status
op_assign
id|nfs_ok
suffix:semicolon
id|out
suffix:colon
r_return
id|status
suffix:semicolon
)brace
multiline_comment|/*&n; * nfs4_unlock_state() called after encode&n; */
r_int
DECL|function|nfsd4_close
id|nfsd4_close
c_func
(paren
r_struct
id|svc_rqst
op_star
id|rqstp
comma
r_struct
id|svc_fh
op_star
id|current_fh
comma
r_struct
id|nfsd4_close
op_star
id|close
)paren
(brace
r_int
id|status
suffix:semicolon
r_struct
id|nfs4_stateid
op_star
id|stp
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;NFSD: nfsd4_close on file %.*s&bslash;n&quot;
comma
(paren
r_int
)paren
id|current_fh-&gt;fh_dentry-&gt;d_name.len
comma
id|current_fh-&gt;fh_dentry-&gt;d_name.name
)paren
suffix:semicolon
id|close-&gt;cl_stateowner
op_assign
l_int|NULL
suffix:semicolon
id|nfs4_lock_state
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* check close_lru for replay */
r_if
c_cond
(paren
(paren
id|status
op_assign
id|nfs4_preprocess_seqid_op
c_func
(paren
id|current_fh
comma
id|close-&gt;cl_seqid
comma
op_amp
id|close-&gt;cl_stateid
comma
id|CHECK_FH
op_or
id|OPEN_STATE
op_or
id|CLOSE_STATE
comma
op_amp
id|close-&gt;cl_stateowner
comma
op_amp
id|stp
comma
l_int|NULL
)paren
)paren
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/*&n;&t;*  Return success, but first update the stateid.&n;&t;*/
id|status
op_assign
id|nfs_ok
suffix:semicolon
id|update_stateid
c_func
(paren
op_amp
id|stp-&gt;st_stateid
)paren
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|close-&gt;cl_stateid
comma
op_amp
id|stp-&gt;st_stateid
comma
r_sizeof
(paren
id|stateid_t
)paren
)paren
suffix:semicolon
multiline_comment|/* release_state_owner() calls nfsd_close() if needed */
id|release_state_owner
c_func
(paren
id|stp
comma
op_amp
id|close-&gt;cl_stateowner
comma
id|OPEN_STATE
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|status
suffix:semicolon
)brace
multiline_comment|/* &n; * Lock owner state (byte-range locks)&n; */
DECL|macro|LOFF_OVERFLOW
mdefine_line|#define LOFF_OVERFLOW(start, len)      ((u64)(len) &gt; ~(u64)(start))
DECL|macro|LOCK_HASH_BITS
mdefine_line|#define LOCK_HASH_BITS              8
DECL|macro|LOCK_HASH_SIZE
mdefine_line|#define LOCK_HASH_SIZE             (1 &lt;&lt; LOCK_HASH_BITS)
DECL|macro|LOCK_HASH_MASK
mdefine_line|#define LOCK_HASH_MASK             (LOCK_HASH_SIZE - 1)
DECL|macro|lockownerid_hashval
mdefine_line|#define lockownerid_hashval(id) &bslash;&n;        ((id) &amp; LOCK_HASH_MASK)
DECL|macro|lock_ownerstr_hashval
mdefine_line|#define lock_ownerstr_hashval(x, clientid, ownername) &bslash;&n;        ((file_hashval(x) + (clientid) + opaque_hashval((ownername.data), (ownername.len))) &amp; LOCK_HASH_MASK)
DECL|variable|lock_ownerid_hashtbl
r_static
r_struct
id|list_head
id|lock_ownerid_hashtbl
(braket
id|LOCK_HASH_SIZE
)braket
suffix:semicolon
DECL|variable|lock_ownerstr_hashtbl
r_static
r_struct
id|list_head
id|lock_ownerstr_hashtbl
(braket
id|LOCK_HASH_SIZE
)braket
suffix:semicolon
DECL|variable|lockstateid_hashtbl
r_static
r_struct
id|list_head
id|lockstateid_hashtbl
(braket
id|STATEID_HASH_SIZE
)braket
suffix:semicolon
r_struct
id|nfs4_stateid
op_star
DECL|function|find_stateid
id|find_stateid
c_func
(paren
id|stateid_t
op_star
id|stid
comma
r_int
id|flags
)paren
(brace
r_struct
id|nfs4_stateid
op_star
id|local
op_assign
l_int|NULL
suffix:semicolon
id|u32
id|st_id
op_assign
id|stid-&gt;si_stateownerid
suffix:semicolon
id|u32
id|f_id
op_assign
id|stid-&gt;si_fileid
suffix:semicolon
r_int
r_int
id|hashval
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;NFSD: find_stateid flags 0x%x&bslash;n&quot;
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|flags
op_amp
id|LOCK_STATE
)paren
op_logical_or
(paren
id|flags
op_amp
id|RDWR_STATE
)paren
)paren
(brace
id|hashval
op_assign
id|stateid_hashval
c_func
(paren
id|st_id
comma
id|f_id
)paren
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|local
comma
op_amp
id|lockstateid_hashtbl
(braket
id|hashval
)braket
comma
id|st_hash
)paren
(brace
r_if
c_cond
(paren
(paren
id|local-&gt;st_stateid.si_stateownerid
op_eq
id|st_id
)paren
op_logical_and
(paren
id|local-&gt;st_stateid.si_fileid
op_eq
id|f_id
)paren
)paren
r_return
id|local
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
(paren
id|flags
op_amp
id|OPEN_STATE
)paren
op_logical_or
(paren
id|flags
op_amp
id|RDWR_STATE
)paren
)paren
(brace
id|hashval
op_assign
id|stateid_hashval
c_func
(paren
id|st_id
comma
id|f_id
)paren
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|local
comma
op_amp
id|stateid_hashtbl
(braket
id|hashval
)braket
comma
id|st_hash
)paren
(brace
r_if
c_cond
(paren
(paren
id|local-&gt;st_stateid.si_stateownerid
op_eq
id|st_id
)paren
op_logical_and
(paren
id|local-&gt;st_stateid.si_fileid
op_eq
id|f_id
)paren
)paren
r_return
id|local
suffix:semicolon
)brace
)brace
r_else
id|printk
c_func
(paren
l_string|&quot;NFSD: find_stateid: ERROR: no state flag&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * TODO: Linux file offsets are _signed_ 64-bit quantities, which means that&n; * we can&squot;t properly handle lock requests that go beyond the (2^63 - 1)-th&n; * byte, because of sign extension problems.  Since NFSv4 calls for 64-bit&n; * locking, this prevents us from being completely protocol-compliant.  The&n; * real solution to this problem is to start using unsigned file offsets in&n; * the VFS, but this is a very deep change!&n; */
r_static
r_inline
r_void
DECL|function|nfs4_transform_lock_offset
id|nfs4_transform_lock_offset
c_func
(paren
r_struct
id|file_lock
op_star
id|lock
)paren
(brace
r_if
c_cond
(paren
id|lock-&gt;fl_start
OL
l_int|0
)paren
id|lock-&gt;fl_start
op_assign
id|OFFSET_MAX
suffix:semicolon
r_if
c_cond
(paren
id|lock-&gt;fl_end
OL
l_int|0
)paren
id|lock-&gt;fl_end
op_assign
id|OFFSET_MAX
suffix:semicolon
)brace
r_int
DECL|function|nfs4_verify_lock_stateowner
id|nfs4_verify_lock_stateowner
c_func
(paren
r_struct
id|nfs4_stateowner
op_star
id|sop
comma
r_int
r_int
id|hashval
)paren
(brace
r_struct
id|nfs4_stateowner
op_star
id|local
op_assign
l_int|NULL
suffix:semicolon
r_int
id|status
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|hashval
op_ge
id|LOCK_HASH_SIZE
)paren
r_goto
id|out
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|local
comma
op_amp
id|lock_ownerid_hashtbl
(braket
id|hashval
)braket
comma
id|so_idhash
)paren
(brace
r_if
c_cond
(paren
id|local
op_eq
id|sop
)paren
(brace
id|status
op_assign
l_int|1
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
)brace
id|out
suffix:colon
r_return
id|status
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|nfs4_set_lock_denied
id|nfs4_set_lock_denied
c_func
(paren
r_struct
id|file_lock
op_star
id|fl
comma
r_struct
id|nfsd4_lock_denied
op_star
id|deny
)paren
(brace
r_struct
id|nfs4_stateowner
op_star
id|sop
op_assign
(paren
r_struct
id|nfs4_stateowner
op_star
)paren
id|fl-&gt;fl_owner
suffix:semicolon
id|deny-&gt;ld_sop
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|nfs4_verify_lock_stateowner
c_func
(paren
id|sop
comma
id|fl-&gt;fl_pid
)paren
)paren
id|deny-&gt;ld_sop
op_assign
id|sop
suffix:semicolon
id|deny-&gt;ld_start
op_assign
id|fl-&gt;fl_start
suffix:semicolon
id|deny-&gt;ld_length
op_assign
op_complement
(paren
id|u64
)paren
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|fl-&gt;fl_end
op_ne
op_complement
(paren
id|u64
)paren
l_int|0
)paren
id|deny-&gt;ld_length
op_assign
id|fl-&gt;fl_end
op_minus
id|fl-&gt;fl_start
op_plus
l_int|1
suffix:semicolon
id|deny-&gt;ld_type
op_assign
id|NFS4_READ_LT
suffix:semicolon
r_if
c_cond
(paren
id|fl-&gt;fl_type
op_ne
id|F_RDLCK
)paren
id|deny-&gt;ld_type
op_assign
id|NFS4_WRITE_LT
suffix:semicolon
)brace
r_static
r_struct
id|nfs4_stateowner
op_star
DECL|function|find_lockstateowner
id|find_lockstateowner
c_func
(paren
r_struct
id|xdr_netobj
op_star
id|owner
comma
id|clientid_t
op_star
id|clid
)paren
(brace
r_struct
id|nfs4_stateowner
op_star
id|local
op_assign
l_int|NULL
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|LOCK_HASH_SIZE
suffix:semicolon
id|i
op_increment
)paren
(brace
id|list_for_each_entry
c_func
(paren
id|local
comma
op_amp
id|lock_ownerid_hashtbl
(braket
id|i
)braket
comma
id|so_idhash
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|cmp_owner_str
c_func
(paren
id|local
comma
id|owner
comma
id|clid
)paren
)paren
r_continue
suffix:semicolon
r_return
id|local
suffix:semicolon
)brace
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
r_static
r_int
DECL|function|find_lockstateowner_str
id|find_lockstateowner_str
c_func
(paren
r_int
r_int
id|hashval
comma
r_struct
id|xdr_netobj
op_star
id|owner
comma
id|clientid_t
op_star
id|clid
comma
r_struct
id|nfs4_stateowner
op_star
op_star
id|op
)paren
(brace
r_struct
id|nfs4_stateowner
op_star
id|local
op_assign
l_int|NULL
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|local
comma
op_amp
id|lock_ownerstr_hashtbl
(braket
id|hashval
)braket
comma
id|so_strhash
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|cmp_owner_str
c_func
(paren
id|local
comma
id|owner
comma
id|clid
)paren
)paren
r_continue
suffix:semicolon
op_star
id|op
op_assign
id|local
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
op_star
id|op
op_assign
l_int|NULL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Alloc a lock owner structure.&n; * Called in nfsd4_lock - therefore, OPEN and OPEN_CONFIRM (if needed) has &n; * occured. &n; *&n; * strhashval = lock_ownerstr_hashval &n; * so_seqid = lock-&gt;lk_new_lock_seqid - 1: it gets bumped in encode &n; */
r_static
r_struct
id|nfs4_stateowner
op_star
DECL|function|alloc_init_lock_stateowner
id|alloc_init_lock_stateowner
c_func
(paren
r_int
r_int
id|strhashval
comma
r_struct
id|nfs4_client
op_star
id|clp
comma
r_struct
id|nfs4_stateid
op_star
id|open_stp
comma
r_struct
id|nfsd4_lock
op_star
id|lock
)paren
(brace
r_struct
id|nfs4_stateowner
op_star
id|sop
suffix:semicolon
r_struct
id|nfs4_replay
op_star
id|rp
suffix:semicolon
r_int
r_int
id|idhashval
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|sop
op_assign
id|alloc_stateowner
c_func
(paren
op_amp
id|lock-&gt;lk_new_owner
)paren
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
id|idhashval
op_assign
id|lockownerid_hashval
c_func
(paren
id|current_ownerid
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|sop-&gt;so_idhash
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|sop-&gt;so_strhash
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|sop-&gt;so_perclient
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|sop-&gt;so_perfilestate
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|sop-&gt;so_perlockowner
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|sop-&gt;so_close_lru
)paren
suffix:semicolon
multiline_comment|/* not used */
id|sop-&gt;so_time
op_assign
l_int|0
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|sop-&gt;so_idhash
comma
op_amp
id|lock_ownerid_hashtbl
(braket
id|idhashval
)braket
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|sop-&gt;so_strhash
comma
op_amp
id|lock_ownerstr_hashtbl
(braket
id|strhashval
)braket
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|sop-&gt;so_perclient
comma
op_amp
id|clp-&gt;cl_perclient
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|sop-&gt;so_perlockowner
comma
op_amp
id|open_stp-&gt;st_perlockowner
)paren
suffix:semicolon
id|add_perclient
op_increment
suffix:semicolon
id|sop-&gt;so_is_open_owner
op_assign
l_int|0
suffix:semicolon
id|sop-&gt;so_id
op_assign
id|current_ownerid
op_increment
suffix:semicolon
id|sop-&gt;so_client
op_assign
id|clp
suffix:semicolon
id|sop-&gt;so_seqid
op_assign
id|lock-&gt;lk_new_lock_seqid
op_minus
l_int|1
suffix:semicolon
id|sop-&gt;so_confirmed
op_assign
l_int|1
suffix:semicolon
id|rp
op_assign
op_amp
id|sop-&gt;so_replay
suffix:semicolon
id|rp-&gt;rp_status
op_assign
id|NFSERR_SERVERFAULT
suffix:semicolon
id|rp-&gt;rp_buflen
op_assign
l_int|0
suffix:semicolon
id|rp-&gt;rp_buf
op_assign
id|rp-&gt;rp_ibuf
suffix:semicolon
id|alloc_lsowner
op_increment
suffix:semicolon
r_return
id|sop
suffix:semicolon
)brace
r_struct
id|nfs4_stateid
op_star
DECL|function|alloc_init_lock_stateid
id|alloc_init_lock_stateid
c_func
(paren
r_struct
id|nfs4_stateowner
op_star
id|sop
comma
r_struct
id|nfs4_file
op_star
id|fp
comma
r_struct
id|nfs4_stateid
op_star
id|open_stp
)paren
(brace
r_struct
id|nfs4_stateid
op_star
id|stp
suffix:semicolon
r_int
r_int
id|hashval
op_assign
id|stateid_hashval
c_func
(paren
id|sop-&gt;so_id
comma
id|fp-&gt;fi_id
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|stp
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|nfs4_stateid
)paren
comma
id|GFP_KERNEL
)paren
)paren
op_eq
l_int|NULL
)paren
r_goto
id|out
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|stp-&gt;st_hash
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|stp-&gt;st_perfile
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|stp-&gt;st_perfilestate
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|stp-&gt;st_perlockowner
)paren
suffix:semicolon
multiline_comment|/* not used */
id|list_add
c_func
(paren
op_amp
id|stp-&gt;st_hash
comma
op_amp
id|lockstateid_hashtbl
(braket
id|hashval
)braket
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|stp-&gt;st_perfile
comma
op_amp
id|fp-&gt;fi_perfile
)paren
suffix:semicolon
id|list_add_perfile
op_increment
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|stp-&gt;st_perfilestate
comma
op_amp
id|sop-&gt;so_perfilestate
)paren
suffix:semicolon
id|stp-&gt;st_stateowner
op_assign
id|sop
suffix:semicolon
id|stp-&gt;st_file
op_assign
id|fp
suffix:semicolon
id|stp-&gt;st_stateid.si_boot
op_assign
id|boot_time
suffix:semicolon
id|stp-&gt;st_stateid.si_stateownerid
op_assign
id|sop-&gt;so_id
suffix:semicolon
id|stp-&gt;st_stateid.si_fileid
op_assign
id|fp-&gt;fi_id
suffix:semicolon
id|stp-&gt;st_stateid.si_generation
op_assign
l_int|0
suffix:semicolon
id|stp-&gt;st_vfs_file
op_assign
id|open_stp-&gt;st_vfs_file
suffix:semicolon
multiline_comment|/* FIXME refcount?? */
id|stp-&gt;st_vfs_set
op_assign
id|open_stp-&gt;st_vfs_set
suffix:semicolon
id|stp-&gt;st_access_bmap
op_assign
id|open_stp-&gt;st_access_bmap
suffix:semicolon
id|stp-&gt;st_deny_bmap
op_assign
id|open_stp-&gt;st_deny_bmap
suffix:semicolon
id|out
suffix:colon
r_return
id|stp
suffix:semicolon
)brace
r_int
DECL|function|check_lock_length
id|check_lock_length
c_func
(paren
id|u64
id|offset
comma
id|u64
id|length
)paren
(brace
r_return
(paren
(paren
id|length
op_eq
l_int|0
)paren
op_logical_or
(paren
(paren
id|length
op_ne
op_complement
(paren
id|u64
)paren
l_int|0
)paren
op_logical_and
id|LOFF_OVERFLOW
c_func
(paren
id|offset
comma
id|length
)paren
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  LOCK operation &n; *&n; * nfs4_unlock_state(); called in encode&n; */
r_int
DECL|function|nfsd4_lock
id|nfsd4_lock
c_func
(paren
r_struct
id|svc_rqst
op_star
id|rqstp
comma
r_struct
id|svc_fh
op_star
id|current_fh
comma
r_struct
id|nfsd4_lock
op_star
id|lock
)paren
(brace
r_struct
id|nfs4_stateowner
op_star
id|lock_sop
op_assign
l_int|NULL
comma
op_star
id|open_sop
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|nfs4_stateid
op_star
id|lock_stp
suffix:semicolon
r_struct
id|file
op_star
id|filp
suffix:semicolon
r_struct
id|file_lock
id|file_lock
suffix:semicolon
r_struct
id|file_lock
op_star
id|conflock
suffix:semicolon
r_int
id|status
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|strhashval
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;NFSD: nfsd4_lock: start=%Ld length=%Ld&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|lock-&gt;lk_offset
comma
(paren
r_int
r_int
)paren
id|lock-&gt;lk_length
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nfs4_in_grace
c_func
(paren
)paren
op_logical_and
op_logical_neg
id|lock-&gt;lk_reclaim
)paren
r_return
id|nfserr_grace
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|nfs4_in_grace
c_func
(paren
)paren
op_logical_and
id|lock-&gt;lk_reclaim
)paren
r_return
id|nfserr_no_grace
suffix:semicolon
r_if
c_cond
(paren
id|check_lock_length
c_func
(paren
id|lock-&gt;lk_offset
comma
id|lock-&gt;lk_length
)paren
)paren
r_return
id|nfserr_inval
suffix:semicolon
id|lock-&gt;lk_stateowner
op_assign
l_int|NULL
suffix:semicolon
id|nfs4_lock_state
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lock-&gt;lk_is_new
)paren
(brace
multiline_comment|/*&n;&t; * Client indicates that this is a new lockowner.&n;&t; * Use open owner and open stateid to create lock owner and lock &n;&t; * stateid.&n;&t; */
r_struct
id|nfs4_stateid
op_star
id|open_stp
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|nfs4_file
op_star
id|fp
suffix:semicolon
id|status
op_assign
id|nfserr_stale_clientid
suffix:semicolon
r_if
c_cond
(paren
id|STALE_CLIENTID
c_func
(paren
op_amp
id|lock-&gt;lk_new_clientid
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;NFSD: nfsd4_lock: clientid is stale!&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* is the new lock seqid presented by the client zero? */
id|status
op_assign
id|nfserr_bad_seqid
suffix:semicolon
r_if
c_cond
(paren
id|lock-&gt;v
dot
r_new
dot
id|lock_seqid
op_ne
l_int|0
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* validate and update open stateid and open seqid */
id|status
op_assign
id|nfs4_preprocess_seqid_op
c_func
(paren
id|current_fh
comma
id|lock-&gt;lk_new_open_seqid
comma
op_amp
id|lock-&gt;lk_new_open_stateid
comma
id|CHECK_FH
op_or
id|OPEN_STATE
comma
op_amp
id|open_sop
comma
op_amp
id|open_stp
comma
op_amp
id|lock-&gt;v
dot
r_new
dot
id|clientid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
)paren
(brace
r_if
c_cond
(paren
id|lock-&gt;lk_reclaim
)paren
id|status
op_assign
id|nfserr_reclaim_bad
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* create lockowner and lock stateid */
id|fp
op_assign
id|open_stp-&gt;st_file
suffix:semicolon
id|strhashval
op_assign
id|lock_ownerstr_hashval
c_func
(paren
id|fp-&gt;fi_inode
comma
id|open_sop-&gt;so_client-&gt;cl_clientid.cl_id
comma
id|lock-&gt;v
dot
r_new
dot
id|owner
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t; * If we already have this lock owner, the client is in &n;&t;&t; * error (or our bookeeping is wrong!) &n;&t;&t; * for asking for a &squot;new lock&squot;.&n;&t;&t; */
id|status
op_assign
id|nfserr_bad_stateid
suffix:semicolon
id|lock_sop
op_assign
id|find_lockstateowner
c_func
(paren
op_amp
id|lock-&gt;v
dot
r_new
dot
id|owner
comma
op_amp
id|lock-&gt;v
dot
r_new
dot
id|clientid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lock_sop
)paren
r_goto
id|out
suffix:semicolon
id|status
op_assign
id|nfserr_resource
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|lock-&gt;lk_stateowner
op_assign
id|alloc_init_lock_stateowner
c_func
(paren
id|strhashval
comma
id|open_sop-&gt;so_client
comma
id|open_stp
comma
id|lock
)paren
)paren
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
(paren
id|lock_stp
op_assign
id|alloc_init_lock_stateid
c_func
(paren
id|lock-&gt;lk_stateowner
comma
id|fp
comma
id|open_stp
)paren
)paren
op_eq
l_int|NULL
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* bump the open seqid used to create the lock */
id|open_sop-&gt;so_seqid
op_increment
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* lock (lock owner + lock stateid) already exists */
id|status
op_assign
id|nfs4_preprocess_seqid_op
c_func
(paren
id|current_fh
comma
id|lock-&gt;lk_old_lock_seqid
comma
op_amp
id|lock-&gt;lk_old_lock_stateid
comma
id|CHECK_FH
op_or
id|LOCK_STATE
comma
op_amp
id|lock-&gt;lk_stateowner
comma
op_amp
id|lock_stp
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
)paren
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* lock-&gt;lk_stateowner and lock_stp have been created or found */
id|filp
op_assign
id|lock_stp-&gt;st_vfs_file
suffix:semicolon
r_if
c_cond
(paren
(paren
id|status
op_assign
id|fh_verify
c_func
(paren
id|rqstp
comma
id|current_fh
comma
id|S_IFREG
comma
id|MAY_LOCK
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;NFSD: nfsd4_lock: permission denied!&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|locks_init_lock
c_func
(paren
op_amp
id|file_lock
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|lock-&gt;lk_type
)paren
(brace
r_case
id|NFS4_READ_LT
suffix:colon
r_case
id|NFS4_READW_LT
suffix:colon
id|file_lock.fl_type
op_assign
id|F_RDLCK
suffix:semicolon
r_break
suffix:semicolon
r_case
id|NFS4_WRITE_LT
suffix:colon
r_case
id|NFS4_WRITEW_LT
suffix:colon
id|file_lock.fl_type
op_assign
id|F_WRLCK
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|status
op_assign
id|nfserr_inval
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|file_lock.fl_owner
op_assign
(paren
id|fl_owner_t
)paren
id|lock-&gt;lk_stateowner
suffix:semicolon
id|file_lock.fl_pid
op_assign
id|lockownerid_hashval
c_func
(paren
id|lock-&gt;lk_stateowner-&gt;so_id
)paren
suffix:semicolon
id|file_lock.fl_file
op_assign
id|filp
suffix:semicolon
id|file_lock.fl_flags
op_assign
id|FL_POSIX
suffix:semicolon
id|file_lock.fl_start
op_assign
id|lock-&gt;lk_offset
suffix:semicolon
r_if
c_cond
(paren
(paren
id|lock-&gt;lk_length
op_eq
op_complement
(paren
id|u64
)paren
l_int|0
)paren
op_logical_or
id|LOFF_OVERFLOW
c_func
(paren
id|lock-&gt;lk_offset
comma
id|lock-&gt;lk_length
)paren
)paren
id|file_lock.fl_end
op_assign
op_complement
(paren
id|u64
)paren
l_int|0
suffix:semicolon
r_else
id|file_lock.fl_end
op_assign
id|lock-&gt;lk_offset
op_plus
id|lock-&gt;lk_length
op_minus
l_int|1
suffix:semicolon
id|nfs4_transform_lock_offset
c_func
(paren
op_amp
id|file_lock
)paren
suffix:semicolon
multiline_comment|/*&n;&t;* Try to lock the file in the VFS.&n;&t;* Note: locks.c uses the BKL to protect the inode&squot;s lock list.&n;&t;*/
id|status
op_assign
id|posix_lock_file
c_func
(paren
id|filp
comma
op_amp
id|file_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|file_lock.fl_ops
op_logical_and
id|file_lock.fl_ops-&gt;fl_release_private
)paren
id|file_lock.fl_ops
op_member_access_from_pointer
id|fl_release_private
c_func
(paren
op_amp
id|file_lock
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;NFSD: nfsd4_lock: posix_lock_file status %d&bslash;n&quot;
comma
id|status
)paren
suffix:semicolon
r_switch
c_cond
(paren
op_minus
id|status
)paren
(brace
r_case
l_int|0
suffix:colon
multiline_comment|/* success! */
id|update_stateid
c_func
(paren
op_amp
id|lock_stp-&gt;st_stateid
)paren
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|lock-&gt;lk_resp_stateid
comma
op_amp
id|lock_stp-&gt;st_stateid
comma
r_sizeof
(paren
id|stateid_t
)paren
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
r_case
(paren
id|EAGAIN
)paren
suffix:colon
r_goto
id|conflicting_lock
suffix:semicolon
r_case
(paren
id|EDEADLK
)paren
suffix:colon
id|status
op_assign
id|nfserr_deadlock
suffix:semicolon
r_default
suffix:colon
id|dprintk
c_func
(paren
l_string|&quot;NFSD: nfsd4_lock: posix_lock_file() failed! status %d&bslash;n&quot;
comma
id|status
)paren
suffix:semicolon
r_goto
id|out_destroy_new_stateid
suffix:semicolon
)brace
id|conflicting_lock
suffix:colon
id|dprintk
c_func
(paren
l_string|&quot;NFSD: nfsd4_lock: conflicting lock found!&bslash;n&quot;
)paren
suffix:semicolon
id|status
op_assign
id|nfserr_denied
suffix:semicolon
multiline_comment|/* XXX There is a race here. Future patch needed to provide &n;&t; * an atomic posix_lock_and_test_file&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|conflock
op_assign
id|posix_test_lock
c_func
(paren
id|filp
comma
op_amp
id|file_lock
)paren
)paren
)paren
(brace
id|status
op_assign
id|nfserr_serverfault
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|nfs4_set_lock_denied
c_func
(paren
id|conflock
comma
op_amp
id|lock-&gt;lk_denied
)paren
suffix:semicolon
id|out_destroy_new_stateid
suffix:colon
r_if
c_cond
(paren
id|lock-&gt;lk_is_new
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;NFSD: nfsd4_lock: destroy new stateid!&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;* An error encountered after instantiation of the new&n;&t;* stateid has forced us to destroy it.&n;&t;*/
r_if
c_cond
(paren
op_logical_neg
id|seqid_mutating_err
c_func
(paren
id|status
)paren
)paren
id|open_sop-&gt;so_seqid
op_decrement
suffix:semicolon
id|release_state_owner
c_func
(paren
id|lock_stp
comma
op_amp
id|lock-&gt;lk_stateowner
comma
id|LOCK_STATE
)paren
suffix:semicolon
)brace
id|out
suffix:colon
r_return
id|status
suffix:semicolon
)brace
multiline_comment|/*&n; * LOCKT operation&n; */
r_int
DECL|function|nfsd4_lockt
id|nfsd4_lockt
c_func
(paren
r_struct
id|svc_rqst
op_star
id|rqstp
comma
r_struct
id|svc_fh
op_star
id|current_fh
comma
r_struct
id|nfsd4_lockt
op_star
id|lockt
)paren
(brace
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_struct
id|nfs4_stateowner
op_star
id|sop
suffix:semicolon
r_struct
id|file
id|file
suffix:semicolon
r_struct
id|file_lock
id|file_lock
suffix:semicolon
r_struct
id|file_lock
op_star
id|conflicting_lock
suffix:semicolon
r_int
r_int
id|strhashval
suffix:semicolon
r_int
id|status
suffix:semicolon
r_if
c_cond
(paren
id|nfs4_in_grace
c_func
(paren
)paren
)paren
r_return
id|nfserr_grace
suffix:semicolon
r_if
c_cond
(paren
id|check_lock_length
c_func
(paren
id|lockt-&gt;lt_offset
comma
id|lockt-&gt;lt_length
)paren
)paren
r_return
id|nfserr_inval
suffix:semicolon
id|lockt-&gt;lt_stateowner
op_assign
l_int|NULL
suffix:semicolon
id|nfs4_lock_state
c_func
(paren
)paren
suffix:semicolon
id|status
op_assign
id|nfserr_stale_clientid
suffix:semicolon
r_if
c_cond
(paren
id|STALE_CLIENTID
c_func
(paren
op_amp
id|lockt-&gt;lt_clientid
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;NFSD: nfsd4_lockt: clientid is stale!&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|status
op_assign
id|fh_verify
c_func
(paren
id|rqstp
comma
id|current_fh
comma
id|S_IFREG
comma
l_int|0
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;NFSD: nfsd4_lockt: fh_verify() failed!&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_eq
id|nfserr_symlink
)paren
id|status
op_assign
id|nfserr_inval
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|inode
op_assign
id|current_fh-&gt;fh_dentry-&gt;d_inode
suffix:semicolon
id|locks_init_lock
c_func
(paren
op_amp
id|file_lock
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|lockt-&gt;lt_type
)paren
(brace
r_case
id|NFS4_READ_LT
suffix:colon
r_case
id|NFS4_READW_LT
suffix:colon
id|file_lock.fl_type
op_assign
id|F_RDLCK
suffix:semicolon
r_break
suffix:semicolon
r_case
id|NFS4_WRITE_LT
suffix:colon
r_case
id|NFS4_WRITEW_LT
suffix:colon
id|file_lock.fl_type
op_assign
id|F_WRLCK
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;NFSD: nfs4_lockt: bad lock type!&bslash;n&quot;
)paren
suffix:semicolon
id|status
op_assign
id|nfserr_inval
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|strhashval
op_assign
id|lock_ownerstr_hashval
c_func
(paren
id|inode
comma
id|lockt-&gt;lt_clientid.cl_id
comma
id|lockt-&gt;lt_owner
)paren
suffix:semicolon
id|find_lockstateowner_str
c_func
(paren
id|strhashval
comma
op_amp
id|lockt-&gt;lt_owner
comma
op_amp
id|lockt-&gt;lt_clientid
comma
op_amp
id|lockt-&gt;lt_stateowner
)paren
suffix:semicolon
id|sop
op_assign
id|lockt-&gt;lt_stateowner
suffix:semicolon
r_if
c_cond
(paren
id|sop
)paren
(brace
id|file_lock.fl_owner
op_assign
(paren
id|fl_owner_t
)paren
id|sop
suffix:semicolon
id|file_lock.fl_pid
op_assign
id|lockownerid_hashval
c_func
(paren
id|sop-&gt;so_id
)paren
suffix:semicolon
)brace
r_else
(brace
id|file_lock.fl_owner
op_assign
l_int|NULL
suffix:semicolon
id|file_lock.fl_pid
op_assign
l_int|0
suffix:semicolon
)brace
id|file_lock.fl_flags
op_assign
id|FL_POSIX
suffix:semicolon
id|file_lock.fl_start
op_assign
id|lockt-&gt;lt_offset
suffix:semicolon
r_if
c_cond
(paren
(paren
id|lockt-&gt;lt_length
op_eq
op_complement
(paren
id|u64
)paren
l_int|0
)paren
op_logical_or
id|LOFF_OVERFLOW
c_func
(paren
id|lockt-&gt;lt_offset
comma
id|lockt-&gt;lt_length
)paren
)paren
id|file_lock.fl_end
op_assign
op_complement
(paren
id|u64
)paren
l_int|0
suffix:semicolon
r_else
id|file_lock.fl_end
op_assign
id|lockt-&gt;lt_offset
op_plus
id|lockt-&gt;lt_length
op_minus
l_int|1
suffix:semicolon
id|nfs4_transform_lock_offset
c_func
(paren
op_amp
id|file_lock
)paren
suffix:semicolon
multiline_comment|/* posix_test_lock uses the struct file _only_ to resolve the inode.&n;&t; * since LOCKT doesn&squot;t require an OPEN, and therefore a struct&n;&t; * file may not exist, pass posix_test_lock a struct file with&n;&t; * only the dentry:inode set.&n;&t; */
id|memset
c_func
(paren
op_amp
id|file
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|file
)paren
)paren
suffix:semicolon
id|file.f_dentry
op_assign
id|current_fh-&gt;fh_dentry
suffix:semicolon
id|status
op_assign
id|nfs_ok
suffix:semicolon
id|conflicting_lock
op_assign
id|posix_test_lock
c_func
(paren
op_amp
id|file
comma
op_amp
id|file_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|conflicting_lock
)paren
(brace
id|status
op_assign
id|nfserr_denied
suffix:semicolon
id|nfs4_set_lock_denied
c_func
(paren
id|conflicting_lock
comma
op_amp
id|lockt-&gt;lt_denied
)paren
suffix:semicolon
)brace
id|out
suffix:colon
id|nfs4_unlock_state
c_func
(paren
)paren
suffix:semicolon
r_return
id|status
suffix:semicolon
)brace
r_int
DECL|function|nfsd4_locku
id|nfsd4_locku
c_func
(paren
r_struct
id|svc_rqst
op_star
id|rqstp
comma
r_struct
id|svc_fh
op_star
id|current_fh
comma
r_struct
id|nfsd4_locku
op_star
id|locku
)paren
(brace
r_struct
id|nfs4_stateid
op_star
id|stp
suffix:semicolon
r_struct
id|file
op_star
id|filp
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|file_lock
id|file_lock
suffix:semicolon
r_int
id|status
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;NFSD: nfsd4_locku: start=%Ld length=%Ld&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|locku-&gt;lu_offset
comma
(paren
r_int
r_int
)paren
id|locku-&gt;lu_length
)paren
suffix:semicolon
r_if
c_cond
(paren
id|check_lock_length
c_func
(paren
id|locku-&gt;lu_offset
comma
id|locku-&gt;lu_length
)paren
)paren
r_return
id|nfserr_inval
suffix:semicolon
id|locku-&gt;lu_stateowner
op_assign
l_int|NULL
suffix:semicolon
id|nfs4_lock_state
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|status
op_assign
id|nfs4_preprocess_seqid_op
c_func
(paren
id|current_fh
comma
id|locku-&gt;lu_seqid
comma
op_amp
id|locku-&gt;lu_stateid
comma
id|CHECK_FH
op_or
id|LOCK_STATE
comma
op_amp
id|locku-&gt;lu_stateowner
comma
op_amp
id|stp
comma
l_int|NULL
)paren
)paren
)paren
r_goto
id|out
suffix:semicolon
id|filp
op_assign
id|stp-&gt;st_vfs_file
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|filp
)paren
suffix:semicolon
id|locks_init_lock
c_func
(paren
op_amp
id|file_lock
)paren
suffix:semicolon
id|file_lock.fl_type
op_assign
id|F_UNLCK
suffix:semicolon
id|file_lock.fl_owner
op_assign
(paren
id|fl_owner_t
)paren
id|locku-&gt;lu_stateowner
suffix:semicolon
id|file_lock.fl_pid
op_assign
id|lockownerid_hashval
c_func
(paren
id|locku-&gt;lu_stateowner-&gt;so_id
)paren
suffix:semicolon
id|file_lock.fl_file
op_assign
id|filp
suffix:semicolon
id|file_lock.fl_flags
op_assign
id|FL_POSIX
suffix:semicolon
id|file_lock.fl_start
op_assign
id|locku-&gt;lu_offset
suffix:semicolon
r_if
c_cond
(paren
(paren
id|locku-&gt;lu_length
op_eq
op_complement
(paren
id|u64
)paren
l_int|0
)paren
op_logical_or
id|LOFF_OVERFLOW
c_func
(paren
id|locku-&gt;lu_offset
comma
id|locku-&gt;lu_length
)paren
)paren
id|file_lock.fl_end
op_assign
op_complement
(paren
id|u64
)paren
l_int|0
suffix:semicolon
r_else
id|file_lock.fl_end
op_assign
id|locku-&gt;lu_offset
op_plus
id|locku-&gt;lu_length
op_minus
l_int|1
suffix:semicolon
id|nfs4_transform_lock_offset
c_func
(paren
op_amp
id|file_lock
)paren
suffix:semicolon
multiline_comment|/*&n;&t;*  Try to unlock the file in the VFS.&n;&t;*/
id|status
op_assign
id|posix_lock_file
c_func
(paren
id|filp
comma
op_amp
id|file_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|file_lock.fl_ops
op_logical_and
id|file_lock.fl_ops-&gt;fl_release_private
)paren
id|file_lock.fl_ops
op_member_access_from_pointer
id|fl_release_private
c_func
(paren
op_amp
id|file_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;NFSD: nfs4_locku: posix_lock_file failed!&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|out_nfserr
suffix:semicolon
)brace
multiline_comment|/*&n;&t;* OK, unlock succeeded; the only thing left to do is update the stateid.&n;&t;*/
id|update_stateid
c_func
(paren
op_amp
id|stp-&gt;st_stateid
)paren
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|locku-&gt;lu_stateid
comma
op_amp
id|stp-&gt;st_stateid
comma
r_sizeof
(paren
id|stateid_t
)paren
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|status
suffix:semicolon
id|out_nfserr
suffix:colon
id|status
op_assign
id|nfserrno
c_func
(paren
id|status
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n; * returns&n; * &t;1: locks held by lockowner&n; * &t;0: no locks held by lockowner&n; */
r_static
r_int
DECL|function|check_for_locks
id|check_for_locks
c_func
(paren
r_struct
id|file
op_star
id|filp
comma
r_struct
id|nfs4_stateowner
op_star
id|lowner
)paren
(brace
r_struct
id|file_lock
op_star
op_star
id|flpp
suffix:semicolon
r_struct
id|inode
op_star
id|inode
op_assign
id|filp-&gt;f_dentry-&gt;d_inode
suffix:semicolon
r_int
id|status
op_assign
l_int|0
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|flpp
op_assign
op_amp
id|inode-&gt;i_flock
suffix:semicolon
op_star
id|flpp
op_ne
l_int|NULL
suffix:semicolon
id|flpp
op_assign
op_amp
(paren
op_star
id|flpp
)paren
op_member_access_from_pointer
id|fl_next
)paren
(brace
r_if
c_cond
(paren
(paren
op_star
id|flpp
)paren
op_member_access_from_pointer
id|fl_owner
op_eq
(paren
id|fl_owner_t
)paren
id|lowner
)paren
id|status
op_assign
l_int|1
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|out
suffix:colon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
id|status
suffix:semicolon
)brace
r_int
DECL|function|nfsd4_release_lockowner
id|nfsd4_release_lockowner
c_func
(paren
r_struct
id|svc_rqst
op_star
id|rqstp
comma
r_struct
id|nfsd4_release_lockowner
op_star
id|rlockowner
)paren
(brace
id|clientid_t
op_star
id|clid
op_assign
op_amp
id|rlockowner-&gt;rl_clientid
suffix:semicolon
r_struct
id|nfs4_stateowner
op_star
id|local
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|xdr_netobj
op_star
id|owner
op_assign
op_amp
id|rlockowner-&gt;rl_owner
suffix:semicolon
r_int
id|status
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;nfsd4_release_lockowner clientid: (%08x/%08x):&bslash;n&quot;
comma
id|clid-&gt;cl_boot
comma
id|clid-&gt;cl_id
)paren
suffix:semicolon
multiline_comment|/* XXX check for lease expiration */
id|status
op_assign
id|nfserr_stale_clientid
suffix:semicolon
r_if
c_cond
(paren
id|STALE_CLIENTID
c_func
(paren
id|clid
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;NFSD: nfsd4_release_lockowner: clientid is stale!&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|status
suffix:semicolon
)brace
id|nfs4_lock_state
c_func
(paren
)paren
suffix:semicolon
id|status
op_assign
id|nfs_ok
suffix:semicolon
id|local
op_assign
id|find_lockstateowner
c_func
(paren
id|owner
comma
id|clid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|local
)paren
(brace
r_struct
id|nfs4_stateid
op_star
id|stp
suffix:semicolon
multiline_comment|/* check for any locks held by any stateid&n;&t;&t; * associated with the (lock) stateowner */
id|status
op_assign
id|nfserr_locks_held
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|stp
comma
op_amp
id|local-&gt;so_perfilestate
comma
id|st_perfilestate
)paren
(brace
r_if
c_cond
(paren
id|stp-&gt;st_vfs_set
)paren
(brace
r_if
c_cond
(paren
id|check_for_locks
c_func
(paren
id|stp-&gt;st_vfs_file
comma
id|local
)paren
)paren
r_goto
id|out
suffix:semicolon
)brace
)brace
multiline_comment|/* no locks held by (lock) stateowner */
id|status
op_assign
id|nfs_ok
suffix:semicolon
id|release_stateowner
c_func
(paren
id|local
)paren
suffix:semicolon
)brace
id|out
suffix:colon
id|nfs4_unlock_state
c_func
(paren
)paren
suffix:semicolon
r_return
id|status
suffix:semicolon
)brace
r_static
r_inline
r_struct
id|nfs4_client_reclaim
op_star
DECL|function|alloc_reclaim
id|alloc_reclaim
c_func
(paren
r_int
id|namelen
)paren
(brace
r_struct
id|nfs4_client_reclaim
op_star
id|crp
op_assign
l_int|NULL
suffix:semicolon
id|crp
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|nfs4_client_reclaim
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|crp
)paren
r_return
l_int|NULL
suffix:semicolon
id|crp-&gt;cr_name.data
op_assign
id|kmalloc
c_func
(paren
id|namelen
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|crp-&gt;cr_name.data
)paren
(brace
id|kfree
c_func
(paren
id|crp
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_return
id|crp
suffix:semicolon
)brace
multiline_comment|/*&n; * failure =&gt; all reset bets are off, nfserr_no_grace...&n; */
r_static
r_int
DECL|function|nfs4_client_to_reclaim
id|nfs4_client_to_reclaim
c_func
(paren
r_struct
id|nfs4_client
op_star
id|clp
)paren
(brace
r_int
r_int
id|strhashval
suffix:semicolon
r_struct
id|nfs4_client_reclaim
op_star
id|crp
op_assign
l_int|NULL
suffix:semicolon
id|crp
op_assign
id|alloc_reclaim
c_func
(paren
id|clp-&gt;cl_name.len
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|crp
)paren
r_return
l_int|0
suffix:semicolon
id|strhashval
op_assign
id|clientstr_hashval
c_func
(paren
id|clp-&gt;cl_name.data
comma
id|clp-&gt;cl_name.len
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|crp-&gt;cr_strhash
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|crp-&gt;cr_strhash
comma
op_amp
id|reclaim_str_hashtbl
(braket
id|strhashval
)braket
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|crp-&gt;cr_name.data
comma
id|clp-&gt;cl_name.data
comma
id|clp-&gt;cl_name.len
)paren
suffix:semicolon
id|crp-&gt;cr_name.len
op_assign
id|clp-&gt;cl_name.len
suffix:semicolon
id|crp-&gt;cr_first_state
op_assign
id|clp-&gt;cl_first_state
suffix:semicolon
id|crp-&gt;cr_expired
op_assign
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_static
r_void
DECL|function|nfs4_release_reclaim
id|nfs4_release_reclaim
c_func
(paren
r_void
)paren
(brace
r_struct
id|nfs4_client_reclaim
op_star
id|crp
op_assign
l_int|NULL
suffix:semicolon
r_int
id|i
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|nfs4_reclaim_init
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|CLIENT_HASH_SIZE
suffix:semicolon
id|i
op_increment
)paren
(brace
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|reclaim_str_hashtbl
(braket
id|i
)braket
)paren
)paren
(brace
id|crp
op_assign
id|list_entry
c_func
(paren
id|reclaim_str_hashtbl
(braket
id|i
)braket
dot
id|next
comma
r_struct
id|nfs4_client_reclaim
comma
id|cr_strhash
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|crp-&gt;cr_strhash
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|crp-&gt;cr_name.data
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|crp
)paren
suffix:semicolon
id|reclaim_str_hashtbl_size
op_decrement
suffix:semicolon
)brace
)brace
id|BUG_ON
c_func
(paren
id|reclaim_str_hashtbl_size
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * called from OPEN, CLAIM_PREVIOUS with a new clientid. */
r_struct
id|nfs4_client_reclaim
op_star
DECL|function|nfs4_find_reclaim_client
id|nfs4_find_reclaim_client
c_func
(paren
id|clientid_t
op_star
id|clid
)paren
(brace
r_int
r_int
id|idhashval
op_assign
id|clientid_hashval
c_func
(paren
id|clid-&gt;cl_id
)paren
suffix:semicolon
r_int
r_int
id|strhashval
suffix:semicolon
r_struct
id|nfs4_client
op_star
id|clp
comma
op_star
id|client
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|nfs4_client_reclaim
op_star
id|crp
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* find clientid in conf_id_hashtbl */
id|list_for_each_entry
c_func
(paren
id|clp
comma
op_amp
id|conf_id_hashtbl
(braket
id|idhashval
)braket
comma
id|cl_idhash
)paren
(brace
r_if
c_cond
(paren
id|cmp_clid
c_func
(paren
op_amp
id|clp-&gt;cl_clientid
comma
id|clid
)paren
)paren
(brace
id|client
op_assign
id|clp
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|client
)paren
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/* find clp-&gt;cl_name in reclaim_str_hashtbl */
id|strhashval
op_assign
id|clientstr_hashval
c_func
(paren
id|client-&gt;cl_name.data
comma
id|client-&gt;cl_name.len
)paren
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|crp
comma
op_amp
id|reclaim_str_hashtbl
(braket
id|strhashval
)braket
comma
id|cr_strhash
)paren
(brace
r_if
c_cond
(paren
id|cmp_name
c_func
(paren
op_amp
id|crp-&gt;cr_name
comma
op_amp
id|client-&gt;cl_name
)paren
)paren
(brace
r_return
id|crp
suffix:semicolon
)brace
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n;* Called from OPEN. Look for clientid in reclaim list.&n;*/
r_int
DECL|function|nfs4_check_open_reclaim
id|nfs4_check_open_reclaim
c_func
(paren
id|clientid_t
op_star
id|clid
)paren
(brace
r_struct
id|nfs4_client_reclaim
op_star
id|crp
suffix:semicolon
r_if
c_cond
(paren
(paren
id|crp
op_assign
id|nfs4_find_reclaim_client
c_func
(paren
id|clid
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
id|nfserr_reclaim_bad
suffix:semicolon
r_if
c_cond
(paren
id|crp-&gt;cr_expired
)paren
r_return
id|nfserr_no_grace
suffix:semicolon
r_return
id|nfs_ok
suffix:semicolon
)brace
multiline_comment|/* &n; * Start and stop routines&n; */
r_void
DECL|function|nfs4_state_init
id|nfs4_state_init
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
id|time_t
id|grace_time
suffix:semicolon
r_if
c_cond
(paren
id|nfs4_init
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|nfs4_reclaim_init
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|CLIENT_HASH_SIZE
suffix:semicolon
id|i
op_increment
)paren
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|reclaim_str_hashtbl
(braket
id|i
)braket
)paren
suffix:semicolon
id|reclaim_str_hashtbl_size
op_assign
l_int|0
suffix:semicolon
id|nfs4_reclaim_init
op_assign
l_int|1
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|CLIENT_HASH_SIZE
suffix:semicolon
id|i
op_increment
)paren
(brace
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|conf_id_hashtbl
(braket
id|i
)braket
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|conf_str_hashtbl
(braket
id|i
)braket
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|unconf_str_hashtbl
(braket
id|i
)braket
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|unconf_id_hashtbl
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|FILE_HASH_SIZE
suffix:semicolon
id|i
op_increment
)paren
(brace
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|file_hashtbl
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|OWNER_HASH_SIZE
suffix:semicolon
id|i
op_increment
)paren
(brace
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|ownerstr_hashtbl
(braket
id|i
)braket
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|ownerid_hashtbl
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|STATEID_HASH_SIZE
suffix:semicolon
id|i
op_increment
)paren
(brace
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|stateid_hashtbl
(braket
id|i
)braket
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|lockstateid_hashtbl
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|LOCK_HASH_SIZE
suffix:semicolon
id|i
op_increment
)paren
(brace
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|lock_ownerid_hashtbl
(braket
id|i
)braket
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|lock_ownerstr_hashtbl
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|memset
c_func
(paren
op_amp
id|zerostateid
comma
l_int|0
comma
r_sizeof
(paren
id|stateid_t
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|onestateid
comma
op_complement
l_int|0
comma
r_sizeof
(paren
id|stateid_t
)paren
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|close_lru
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|client_lru
)paren
suffix:semicolon
id|boot_time
op_assign
id|get_seconds
c_func
(paren
)paren
suffix:semicolon
id|grace_time
op_assign
id|max
c_func
(paren
id|old_lease_time
comma
id|lease_time
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reclaim_str_hashtbl_size
op_eq
l_int|0
)paren
id|grace_time
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|grace_time
)paren
id|printk
c_func
(paren
l_string|&quot;NFSD: starting %ld-second grace period&bslash;n&quot;
comma
id|grace_time
)paren
suffix:semicolon
id|grace_end
op_assign
id|boot_time
op_plus
id|grace_time
suffix:semicolon
id|INIT_WORK
c_func
(paren
op_amp
id|laundromat_work
comma
id|laundromat_main
comma
l_int|NULL
)paren
suffix:semicolon
id|schedule_delayed_work
c_func
(paren
op_amp
id|laundromat_work
comma
id|NFSD_LEASE_TIME
op_star
id|HZ
)paren
suffix:semicolon
id|nfs4_init
op_assign
l_int|1
suffix:semicolon
)brace
r_int
DECL|function|nfs4_in_grace
id|nfs4_in_grace
c_func
(paren
r_void
)paren
(brace
r_return
id|get_seconds
c_func
(paren
)paren
OL
id|grace_end
suffix:semicolon
)brace
r_void
DECL|function|set_no_grace
id|set_no_grace
c_func
(paren
r_void
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;NFSD: ERROR in reboot recovery.  State reclaims will fail.&bslash;n&quot;
)paren
suffix:semicolon
id|grace_end
op_assign
id|get_seconds
c_func
(paren
)paren
suffix:semicolon
)brace
id|time_t
DECL|function|nfs4_lease_time
id|nfs4_lease_time
c_func
(paren
r_void
)paren
(brace
r_return
id|lease_time
suffix:semicolon
)brace
r_static
r_void
DECL|function|__nfs4_state_shutdown
id|__nfs4_state_shutdown
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|nfs4_client
op_star
id|clp
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|CLIENT_HASH_SIZE
suffix:semicolon
id|i
op_increment
)paren
(brace
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|conf_id_hashtbl
(braket
id|i
)braket
)paren
)paren
(brace
id|clp
op_assign
id|list_entry
c_func
(paren
id|conf_id_hashtbl
(braket
id|i
)braket
dot
id|next
comma
r_struct
id|nfs4_client
comma
id|cl_idhash
)paren
suffix:semicolon
id|expire_client
c_func
(paren
id|clp
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|unconf_str_hashtbl
(braket
id|i
)braket
)paren
)paren
(brace
id|clp
op_assign
id|list_entry
c_func
(paren
id|unconf_str_hashtbl
(braket
id|i
)braket
dot
id|next
comma
r_struct
id|nfs4_client
comma
id|cl_strhash
)paren
suffix:semicolon
id|expire_client
c_func
(paren
id|clp
)paren
suffix:semicolon
)brace
)brace
id|release_all_files
c_func
(paren
)paren
suffix:semicolon
id|cancel_delayed_work
c_func
(paren
op_amp
id|laundromat_work
)paren
suffix:semicolon
id|flush_scheduled_work
c_func
(paren
)paren
suffix:semicolon
id|nfs4_init
op_assign
l_int|0
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;NFSD: list_add_perfile %d list_del_perfile %d&bslash;n&quot;
comma
id|list_add_perfile
comma
id|list_del_perfile
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;NFSD: add_perclient %d del_perclient %d&bslash;n&quot;
comma
id|add_perclient
comma
id|del_perclient
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;NFSD: alloc_file %d free_file %d&bslash;n&quot;
comma
id|alloc_file
comma
id|free_file
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;NFSD: alloc_sowner %d alloc_lsowner %d free_sowner %d&bslash;n&quot;
comma
id|alloc_sowner
comma
id|alloc_lsowner
comma
id|free_sowner
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;NFSD: vfsopen %d vfsclose %d&bslash;n&quot;
comma
id|vfsopen
comma
id|vfsclose
)paren
suffix:semicolon
)brace
r_void
DECL|function|nfs4_state_shutdown
id|nfs4_state_shutdown
c_func
(paren
r_void
)paren
(brace
id|nfs4_lock_state
c_func
(paren
)paren
suffix:semicolon
id|nfs4_release_reclaim
c_func
(paren
)paren
suffix:semicolon
id|__nfs4_state_shutdown
c_func
(paren
)paren
suffix:semicolon
id|nfs4_unlock_state
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Called when leasetime is changed.&n; *&n; * if nfsd is not started, simply set the global lease.&n; *&n; * if nfsd(s) are running, lease change requires nfsv4 state to be reset.&n; * e.g: boot_time is reset, existing nfs4_client structs are&n; * used to fill reclaim_str_hashtbl, then all state (except for the&n; * reclaim_str_hashtbl) is re-initialized.&n; *&n; * if the old lease time is greater than the new lease time, the grace&n; * period needs to be set to the old lease time to allow clients to reclaim&n; * their state. XXX - we may want to set the grace period == lease time&n; * after an initial grace period == old lease time&n; *&n; * if an error occurs in this process, the new lease is set, but the server&n; * will not honor OPEN or LOCK reclaims, and will return nfserr_no_grace&n; * which means OPEN/LOCK/READ/WRITE will fail during grace period.&n; *&n; * clients will attempt to reset all state with SETCLIENTID/CONFIRM, and&n; * OPEN and LOCK reclaims.&n; */
r_void
DECL|function|nfs4_reset_lease
id|nfs4_reset_lease
c_func
(paren
id|time_t
id|leasetime
)paren
(brace
r_struct
id|nfs4_client
op_star
id|clp
suffix:semicolon
r_int
id|i
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;NFSD: New leasetime %ld&bslash;n&quot;
comma
id|leasetime
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|nfs4_init
)paren
r_return
suffix:semicolon
id|nfs4_lock_state
c_func
(paren
)paren
suffix:semicolon
id|old_lease_time
op_assign
id|lease_time
suffix:semicolon
id|lease_time
op_assign
id|leasetime
suffix:semicolon
id|nfs4_release_reclaim
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* populate reclaim_str_hashtbl with current confirmed nfs4_clientid */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|CLIENT_HASH_SIZE
suffix:semicolon
id|i
op_increment
)paren
(brace
id|list_for_each_entry
c_func
(paren
id|clp
comma
op_amp
id|conf_id_hashtbl
(braket
id|i
)braket
comma
id|cl_idhash
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|nfs4_client_to_reclaim
c_func
(paren
id|clp
)paren
)paren
(brace
id|nfs4_release_reclaim
c_func
(paren
)paren
suffix:semicolon
r_goto
id|init_state
suffix:semicolon
)brace
id|reclaim_str_hashtbl_size
op_increment
suffix:semicolon
)brace
)brace
id|init_state
suffix:colon
id|__nfs4_state_shutdown
c_func
(paren
)paren
suffix:semicolon
id|nfs4_state_init
c_func
(paren
)paren
suffix:semicolon
id|nfs4_unlock_state
c_func
(paren
)paren
suffix:semicolon
)brace
eof
