multiline_comment|/*&n;*  linux/fs/nfsd/nfs4state.c&n;*&n;*  Copyright (c) 2001 The Regents of the University of Michigan.&n;*  All rights reserved.&n;*&n;*  Kendrick Smith &lt;kmsmith@umich.edu&gt;&n;*  Andy Adamson &lt;kandros@umich.edu&gt;&n;*&n;*  Redistribution and use in source and binary forms, with or without&n;*  modification, are permitted provided that the following conditions&n;*  are met:&n;*&n;*  1. Redistributions of source code must retain the above copyright&n;*     notice, this list of conditions and the following disclaimer.&n;*  2. Redistributions in binary form must reproduce the above copyright&n;*     notice, this list of conditions and the following disclaimer in the&n;*     documentation and/or other materials provided with the distribution.&n;*  3. Neither the name of the University nor the names of its&n;*     contributors may be used to endorse or promote products derived&n;*     from this software without specific prior written permission.&n;*&n;*  THIS SOFTWARE IS PROVIDED ``AS IS&squot;&squot; AND ANY EXPRESS OR IMPLIED&n;*  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF&n;*  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE&n;*  DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE&n;*  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR&n;*  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF&n;*  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR&n;*  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF&n;*  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING&n;*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS&n;*  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.&n;*&n;*/
macro_line|#include &lt;linux/param.h&gt;
macro_line|#include &lt;linux/major.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/sunrpc/svc.h&gt;
macro_line|#include &lt;linux/nfsd/nfsd.h&gt;
macro_line|#include &lt;linux/nfsd/cache.h&gt;
macro_line|#include &lt;linux/mount.h&gt;
macro_line|#include &lt;linux/workqueue.h&gt;
macro_line|#include &lt;linux/nfs4.h&gt;
macro_line|#include &lt;linux/nfsd/state.h&gt;
macro_line|#include &lt;linux/nfsd/xdr4.h&gt;
DECL|macro|NFSDDBG_FACILITY
mdefine_line|#define NFSDDBG_FACILITY                NFSDDBG_PROC
multiline_comment|/* Globals */
DECL|variable|boot_time
id|time_t
id|boot_time
suffix:semicolon
DECL|variable|current_clientid
r_static
id|u32
id|current_clientid
op_assign
l_int|1
suffix:semicolon
DECL|variable|current_ownerid
r_static
id|u32
id|current_ownerid
op_assign
l_int|0
suffix:semicolon
DECL|variable|current_fileid
r_static
id|u32
id|current_fileid
op_assign
l_int|0
suffix:semicolon
DECL|variable|nfs4_init
r_static
id|u32
id|nfs4_init
op_assign
l_int|0
suffix:semicolon
DECL|variable|zerostateid
id|stateid_t
id|zerostateid
suffix:semicolon
multiline_comment|/* bits all 0 */
DECL|variable|onestateid
id|stateid_t
id|onestateid
suffix:semicolon
multiline_comment|/* bits all 1 */
multiline_comment|/* debug counters */
DECL|variable|list_add_perfile
id|u32
id|list_add_perfile
op_assign
l_int|0
suffix:semicolon
DECL|variable|list_del_perfile
id|u32
id|list_del_perfile
op_assign
l_int|0
suffix:semicolon
DECL|variable|add_perclient
id|u32
id|add_perclient
op_assign
l_int|0
suffix:semicolon
DECL|variable|del_perclient
id|u32
id|del_perclient
op_assign
l_int|0
suffix:semicolon
DECL|variable|alloc_file
id|u32
id|alloc_file
op_assign
l_int|0
suffix:semicolon
DECL|variable|free_file
id|u32
id|free_file
op_assign
l_int|0
suffix:semicolon
DECL|variable|alloc_sowner
id|u32
id|alloc_sowner
op_assign
l_int|0
suffix:semicolon
DECL|variable|free_sowner
id|u32
id|free_sowner
op_assign
l_int|0
suffix:semicolon
DECL|variable|vfsopen
id|u32
id|vfsopen
op_assign
l_int|0
suffix:semicolon
DECL|variable|vfsclose
id|u32
id|vfsclose
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Locking:&n; *&n; * client_sema: &n; * &t;protects clientid_hashtbl[], clientstr_hashtbl[],&n; * &t;unconfstr_hashtbl[], uncofid_hashtbl[].&n; */
DECL|variable|client_sema
r_static
r_struct
id|semaphore
id|client_sema
suffix:semicolon
r_static
r_inline
id|u32
DECL|function|opaque_hashval
id|opaque_hashval
c_func
(paren
r_const
r_void
op_star
id|ptr
comma
r_int
id|nbytes
)paren
(brace
r_int
r_char
op_star
id|cptr
op_assign
(paren
r_int
r_char
op_star
)paren
id|ptr
suffix:semicolon
id|u32
id|x
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|nbytes
op_decrement
)paren
(brace
id|x
op_mul_assign
l_int|37
suffix:semicolon
id|x
op_add_assign
op_star
id|cptr
op_increment
suffix:semicolon
)brace
r_return
id|x
suffix:semicolon
)brace
multiline_comment|/* forward declarations */
r_static
r_void
id|release_stateowner
c_func
(paren
r_struct
id|nfs4_stateowner
op_star
id|sop
)paren
suffix:semicolon
r_static
r_void
id|release_stateid
c_func
(paren
r_struct
id|nfs4_stateid
op_star
id|stp
)paren
suffix:semicolon
r_static
r_void
id|release_file
c_func
(paren
r_struct
id|nfs4_file
op_star
id|fp
)paren
suffix:semicolon
multiline_comment|/* &n; * SETCLIENTID state &n; */
multiline_comment|/* Hash tables for nfs4_clientid state */
DECL|macro|CLIENT_HASH_BITS
mdefine_line|#define CLIENT_HASH_BITS                 4
DECL|macro|CLIENT_HASH_SIZE
mdefine_line|#define CLIENT_HASH_SIZE                (1 &lt;&lt; CLIENT_HASH_BITS)
DECL|macro|CLIENT_HASH_MASK
mdefine_line|#define CLIENT_HASH_MASK                (CLIENT_HASH_SIZE - 1)
DECL|macro|clientid_hashval
mdefine_line|#define clientid_hashval(id) &bslash;&n;&t;((id) &amp; CLIENT_HASH_MASK)
DECL|macro|clientstr_hashval
mdefine_line|#define clientstr_hashval(name, namelen) &bslash;&n;&t;(opaque_hashval((name), (namelen)) &amp; CLIENT_HASH_MASK)
multiline_comment|/* conf_id_hashtbl[], and conf_str_hashtbl[] hold confirmed&n; * setclientid_confirmed info. &n; *&n; * unconf_str_hastbl[] and unconf_id_hashtbl[] hold unconfirmed &n; * setclientid info.&n; *&n; * client_lru holds client queue ordered by nfs4_client.cl_time&n; * for lease renewal.&n; */
DECL|variable|conf_id_hashtbl
r_static
r_struct
id|list_head
id|conf_id_hashtbl
(braket
id|CLIENT_HASH_SIZE
)braket
suffix:semicolon
DECL|variable|conf_str_hashtbl
r_static
r_struct
id|list_head
id|conf_str_hashtbl
(braket
id|CLIENT_HASH_SIZE
)braket
suffix:semicolon
DECL|variable|unconf_str_hashtbl
r_static
r_struct
id|list_head
id|unconf_str_hashtbl
(braket
id|CLIENT_HASH_SIZE
)braket
suffix:semicolon
DECL|variable|unconf_id_hashtbl
r_static
r_struct
id|list_head
id|unconf_id_hashtbl
(braket
id|CLIENT_HASH_SIZE
)braket
suffix:semicolon
DECL|variable|client_lru
r_static
r_struct
id|list_head
id|client_lru
suffix:semicolon
r_static
r_inline
r_void
DECL|function|renew_client
id|renew_client
c_func
(paren
r_struct
id|nfs4_client
op_star
id|clp
)paren
(brace
multiline_comment|/*&n;&t;* Move client to the end to the LRU list.&n;&t;*/
id|dprintk
c_func
(paren
l_string|&quot;renewing client (clientid %08x/%08x)&bslash;n&quot;
comma
id|clp-&gt;cl_clientid.cl_boot
comma
id|clp-&gt;cl_clientid.cl_id
)paren
suffix:semicolon
id|list_move_tail
c_func
(paren
op_amp
id|clp-&gt;cl_lru
comma
op_amp
id|client_lru
)paren
suffix:semicolon
id|clp-&gt;cl_time
op_assign
id|get_seconds
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* SETCLIENTID and SETCLIENTID_CONFIRM Helper functions */
r_static
r_int
DECL|function|STALE_CLIENTID
id|STALE_CLIENTID
c_func
(paren
id|clientid_t
op_star
id|clid
)paren
(brace
r_if
c_cond
(paren
id|clid-&gt;cl_boot
op_eq
id|boot_time
)paren
r_return
l_int|0
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;NFSD stale clientid (%08x/%08x)&bslash;n&quot;
comma
id|clid-&gt;cl_boot
comma
id|clid-&gt;cl_id
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* &n; * XXX Should we use a slab cache ?&n; * This type of memory management is somewhat inefficient, but we use it&n; * anyway since SETCLIENTID is not a common operation.&n; */
r_static
r_inline
r_struct
id|nfs4_client
op_star
DECL|function|alloc_client
id|alloc_client
c_func
(paren
r_struct
id|xdr_netobj
id|name
)paren
(brace
r_struct
id|nfs4_client
op_star
id|clp
suffix:semicolon
r_if
c_cond
(paren
(paren
id|clp
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|nfs4_client
)paren
comma
id|GFP_KERNEL
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|memset
c_func
(paren
id|clp
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|clp
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|clp-&gt;cl_name.data
op_assign
id|kmalloc
c_func
(paren
id|name.len
comma
id|GFP_KERNEL
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|memcpy
c_func
(paren
id|clp-&gt;cl_name.data
comma
id|name.data
comma
id|name.len
)paren
suffix:semicolon
id|clp-&gt;cl_name.len
op_assign
id|name.len
suffix:semicolon
)brace
r_else
(brace
id|kfree
c_func
(paren
id|clp
)paren
suffix:semicolon
id|clp
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
r_return
id|clp
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|free_client
id|free_client
c_func
(paren
r_struct
id|nfs4_client
op_star
id|clp
)paren
(brace
id|kfree
c_func
(paren
id|clp-&gt;cl_name.data
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|clp
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|expire_client
id|expire_client
c_func
(paren
r_struct
id|nfs4_client
op_star
id|clp
)paren
(brace
r_struct
id|nfs4_stateowner
op_star
id|sop
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;NFSD: expire_client&bslash;n&quot;
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|clp-&gt;cl_idhash
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|clp-&gt;cl_strhash
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|clp-&gt;cl_lru
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|clp-&gt;cl_perclient
)paren
)paren
(brace
id|sop
op_assign
id|list_entry
c_func
(paren
id|clp-&gt;cl_perclient.next
comma
r_struct
id|nfs4_stateowner
comma
id|so_perclient
)paren
suffix:semicolon
id|release_stateowner
c_func
(paren
id|sop
)paren
suffix:semicolon
)brace
id|free_client
c_func
(paren
id|clp
)paren
suffix:semicolon
)brace
r_static
r_struct
id|nfs4_client
op_star
DECL|function|create_client
id|create_client
c_func
(paren
r_struct
id|xdr_netobj
id|name
)paren
(brace
r_struct
id|nfs4_client
op_star
id|clp
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|clp
op_assign
id|alloc_client
c_func
(paren
id|name
)paren
)paren
)paren
(brace
r_goto
id|out
suffix:semicolon
)brace
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|clp-&gt;cl_idhash
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|clp-&gt;cl_strhash
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|clp-&gt;cl_perclient
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|clp-&gt;cl_lru
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|clp
suffix:semicolon
)brace
r_static
r_void
DECL|function|copy_verf
id|copy_verf
c_func
(paren
r_struct
id|nfs4_client
op_star
id|target
comma
id|nfs4_verifier
id|source
)paren
(brace
id|memcpy
c_func
(paren
op_amp
id|target-&gt;cl_verifier
comma
id|source
comma
r_sizeof
(paren
id|nfs4_verifier
)paren
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|copy_clid
id|copy_clid
c_func
(paren
r_struct
id|nfs4_client
op_star
id|target
comma
r_struct
id|nfs4_client
op_star
id|source
)paren
(brace
id|target-&gt;cl_clientid.cl_boot
op_assign
id|source-&gt;cl_clientid.cl_boot
suffix:semicolon
id|target-&gt;cl_clientid.cl_id
op_assign
id|source-&gt;cl_clientid.cl_id
suffix:semicolon
)brace
r_static
r_void
DECL|function|copy_cred
id|copy_cred
c_func
(paren
r_struct
id|svc_cred
op_star
id|target
comma
r_struct
id|svc_cred
op_star
id|source
)paren
(brace
r_int
id|i
suffix:semicolon
id|target-&gt;cr_uid
op_assign
id|source-&gt;cr_uid
suffix:semicolon
id|target-&gt;cr_gid
op_assign
id|source-&gt;cr_gid
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NGROUPS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|target-&gt;cr_groups
(braket
id|i
)braket
op_assign
id|source-&gt;cr_groups
(braket
id|i
)braket
suffix:semicolon
)brace
)brace
r_static
r_int
DECL|function|cmp_name
id|cmp_name
c_func
(paren
r_struct
id|xdr_netobj
op_star
id|n1
comma
r_struct
id|xdr_netobj
op_star
id|n2
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|n1
op_logical_or
op_logical_neg
id|n2
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
r_return
(paren
id|n1-&gt;len
op_eq
id|n2-&gt;len
)paren
op_logical_and
op_logical_neg
id|memcmp
c_func
(paren
id|n1-&gt;data
comma
id|n2-&gt;data
comma
id|n2-&gt;len
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|cmp_verf
id|cmp_verf
c_func
(paren
id|nfs4_verifier
id|v1
comma
id|nfs4_verifier
id|v2
)paren
(brace
r_return
op_logical_neg
id|memcmp
c_func
(paren
id|v1
comma
id|v2
comma
r_sizeof
(paren
id|nfs4_verifier
)paren
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|cmp_clid
id|cmp_clid
c_func
(paren
id|clientid_t
op_star
id|cl1
comma
id|clientid_t
op_star
id|cl2
)paren
(brace
r_return
(paren
id|cl1-&gt;cl_boot
op_eq
id|cl2-&gt;cl_boot
)paren
op_logical_and
(paren
id|cl1-&gt;cl_id
op_eq
id|cl2-&gt;cl_id
)paren
suffix:semicolon
)brace
multiline_comment|/* XXX what about NGROUP */
r_static
r_int
DECL|function|cmp_creds
(def_block
id|cmp_creds
c_func
(paren
r_struct
id|svc_cred
op_star
id|cr1
comma
r_struct
id|svc_cred
op_star
id|cr2
)paren
(brace
r_return
(paren
id|cr1-&gt;cr_uid
op_eq
id|cr2-&gt;cr_uid
)paren
op_logical_and
(paren
id|cr1-&gt;cr_gid
op_eq
id|cr2-&gt;cr_gid
)paren
suffix:semicolon
)brace
)def_block
r_static
r_void
DECL|function|gen_clid
id|gen_clid
c_func
(paren
r_struct
id|nfs4_client
op_star
id|clp
)paren
(brace
id|clp-&gt;cl_clientid.cl_boot
op_assign
id|boot_time
suffix:semicolon
id|clp-&gt;cl_clientid.cl_id
op_assign
id|current_clientid
op_increment
suffix:semicolon
)brace
r_static
r_void
DECL|function|gen_confirm
id|gen_confirm
c_func
(paren
r_struct
id|nfs4_client
op_star
id|clp
)paren
(brace
r_struct
id|timespec
id|tv
suffix:semicolon
id|u32
op_star
id|p
suffix:semicolon
id|tv
op_assign
id|CURRENT_TIME
suffix:semicolon
id|p
op_assign
(paren
id|u32
op_star
)paren
id|clp-&gt;cl_confirm
suffix:semicolon
op_star
id|p
op_increment
op_assign
id|tv.tv_sec
suffix:semicolon
op_star
id|p
op_increment
op_assign
id|tv.tv_nsec
suffix:semicolon
)brace
r_static
r_int
DECL|function|check_name
id|check_name
c_func
(paren
r_struct
id|xdr_netobj
id|name
)paren
(brace
r_if
c_cond
(paren
id|name.len
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|name.len
OG
id|NFS4_OPAQUE_LIMIT
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;NFSD: check_name: name too long(%d)!&bslash;n&quot;
comma
id|name.len
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
r_void
DECL|function|add_to_unconfirmed
id|add_to_unconfirmed
c_func
(paren
r_struct
id|nfs4_client
op_star
id|clp
comma
r_int
r_int
id|strhashval
)paren
(brace
r_int
r_int
id|idhashval
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|clp-&gt;cl_strhash
comma
op_amp
id|unconf_str_hashtbl
(braket
id|strhashval
)braket
)paren
suffix:semicolon
id|idhashval
op_assign
id|clientid_hashval
c_func
(paren
id|clp-&gt;cl_clientid.cl_id
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|clp-&gt;cl_idhash
comma
op_amp
id|unconf_id_hashtbl
(braket
id|idhashval
)braket
)paren
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|clp-&gt;cl_lru
comma
op_amp
id|client_lru
)paren
suffix:semicolon
id|clp-&gt;cl_time
op_assign
id|get_seconds
c_func
(paren
)paren
suffix:semicolon
)brace
r_void
DECL|function|move_to_confirmed
id|move_to_confirmed
c_func
(paren
r_struct
id|nfs4_client
op_star
id|clp
comma
r_int
r_int
id|idhashval
)paren
(brace
r_int
r_int
id|strhashval
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;NFSD: move_to_confirm nfs4_client %p&bslash;n&quot;
comma
id|clp
)paren
suffix:semicolon
id|list_del_init
c_func
(paren
op_amp
id|clp-&gt;cl_strhash
)paren
suffix:semicolon
id|list_del_init
c_func
(paren
op_amp
id|clp-&gt;cl_idhash
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|clp-&gt;cl_idhash
comma
op_amp
id|conf_id_hashtbl
(braket
id|idhashval
)braket
)paren
suffix:semicolon
id|strhashval
op_assign
id|clientstr_hashval
c_func
(paren
id|clp-&gt;cl_name.data
comma
id|clp-&gt;cl_name.len
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|clp-&gt;cl_strhash
comma
op_amp
id|conf_str_hashtbl
(braket
id|strhashval
)braket
)paren
suffix:semicolon
id|renew_client
c_func
(paren
id|clp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * RFC 3010 has a complex implmentation description of processing a &n; * SETCLIENTID request consisting of 5 bullets, labeled as &n; * CASE0 - CASE4 below.&n; *&n; * NOTES:&n; * &t;callback information will be processed in a future patch&n; *&n; *&t;an unconfirmed record is added when:&n; *      NORMAL (part of CASE 4): there is no confirmed nor unconfirmed record.&n; *&t;CASE 1: confirmed record found with matching name, principal,&n; *&t;&t;verifier, and clientid.&n; *&t;CASE 2: confirmed record found with matching name, principal,&n; *&t;&t;and there is no unconfirmed record with matching&n; *&t;&t;name and principal&n; *&n; *      an unconfirmed record is replaced when:&n; *&t;CASE 3: confirmed record found with matching name, principal,&n; *&t;&t;and an unconfirmed record is found with matching &n; *&t;&t;name, principal, and with clientid and&n; *&t;&t;confirm that does not match the confirmed record.&n; *&t;CASE 4: there is no confirmed record with matching name and &n; *&t;&t;principal. there is an unconfirmed record with &n; *&t;&t;matching name, principal.&n; *&n; *&t;an unconfirmed record is deleted when:&n; *&t;CASE 1: an unconfirmed record that matches input name, verifier,&n; *&t;&t;and confirmed clientid.&n; *&t;CASE 4: any unconfirmed records with matching name and principal&n; *&t;&t;that exist after an unconfirmed record has been replaced&n; *&t;&t;as described above.&n; *&n; */
r_int
DECL|function|nfsd4_setclientid
id|nfsd4_setclientid
c_func
(paren
r_struct
id|svc_rqst
op_star
id|rqstp
comma
r_struct
id|nfsd4_setclientid
op_star
id|setclid
)paren
(brace
id|u32
id|ip_addr
op_assign
id|rqstp-&gt;rq_addr.sin_addr.s_addr
suffix:semicolon
r_struct
id|xdr_netobj
id|clname
op_assign
(brace
dot
id|len
op_assign
id|setclid-&gt;se_namelen
comma
dot
id|data
op_assign
id|setclid-&gt;se_name
comma
)brace
suffix:semicolon
r_char
op_star
id|clverifier
op_assign
id|setclid-&gt;se_verf
suffix:semicolon
r_int
r_int
id|strhashval
suffix:semicolon
r_struct
id|nfs4_client
op_star
id|conf
comma
op_star
id|unconf
comma
op_star
r_new
comma
op_star
id|clp
suffix:semicolon
r_int
id|status
suffix:semicolon
r_struct
id|list_head
op_star
id|pos
comma
op_star
id|next
suffix:semicolon
id|status
op_assign
id|nfserr_inval
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|check_name
c_func
(paren
id|clname
)paren
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* &n;&t; * XXX The Duplicate Request Cache (DRC) has been checked (??)&n;&t; * We get here on a DRC miss.&n;&t; */
id|strhashval
op_assign
id|clientstr_hashval
c_func
(paren
id|clname.data
comma
id|clname.len
)paren
suffix:semicolon
id|conf
op_assign
l_int|NULL
suffix:semicolon
id|down
c_func
(paren
op_amp
id|client_sema
)paren
suffix:semicolon
id|list_for_each_safe
c_func
(paren
id|pos
comma
id|next
comma
op_amp
id|conf_str_hashtbl
(braket
id|strhashval
)braket
)paren
(brace
id|clp
op_assign
id|list_entry
c_func
(paren
id|pos
comma
r_struct
id|nfs4_client
comma
id|cl_strhash
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cmp_name
c_func
(paren
op_amp
id|clp-&gt;cl_name
comma
op_amp
id|clname
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/* &n;&t;&t; * CASE 0:&n;&t;&t; * clname match, confirmed, different principal&n;&t;&t; * or different ip_address&n;&t;&t; */
id|status
op_assign
id|nfserr_clid_inuse
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cmp_creds
c_func
(paren
op_amp
id|clp-&gt;cl_cred
comma
op_amp
id|rqstp-&gt;rq_cred
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;NFSD: setclientid: string in use by client&quot;
l_string|&quot;(clientid %08x/%08x)&bslash;n&quot;
comma
id|clp-&gt;cl_clientid.cl_boot
comma
id|clp-&gt;cl_clientid.cl_id
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|clp-&gt;cl_addr
op_ne
id|ip_addr
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;NFSD: setclientid: string in use by client&quot;
l_string|&quot;(clientid %08x/%08x)&bslash;n&quot;
comma
id|clp-&gt;cl_clientid.cl_boot
comma
id|clp-&gt;cl_clientid.cl_id
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* &n;&t; &t; * cl_name match from a previous SETCLIENTID operation&n;&t; &t; * XXX check for additional matches?&n;&t;&t; */
id|conf
op_assign
id|clp
suffix:semicolon
r_break
suffix:semicolon
)brace
id|unconf
op_assign
l_int|NULL
suffix:semicolon
id|list_for_each_safe
c_func
(paren
id|pos
comma
id|next
comma
op_amp
id|unconf_str_hashtbl
(braket
id|strhashval
)braket
)paren
(brace
id|clp
op_assign
id|list_entry
c_func
(paren
id|pos
comma
r_struct
id|nfs4_client
comma
id|cl_strhash
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cmp_name
c_func
(paren
op_amp
id|clp-&gt;cl_name
comma
op_amp
id|clname
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/* cl_name match from a previous SETCLIENTID operation */
id|unconf
op_assign
id|clp
suffix:semicolon
r_break
suffix:semicolon
)brace
id|status
op_assign
id|nfserr_resource
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|conf
)paren
(brace
multiline_comment|/* &n;&t;&t; * CASE 4:&n;&t;&t; * placed first, because it is the normal case.&n;&t;&t; */
r_if
c_cond
(paren
id|unconf
)paren
id|expire_client
c_func
(paren
id|unconf
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
r_new
op_assign
id|create_client
c_func
(paren
id|clname
)paren
)paren
)paren
r_goto
id|out
suffix:semicolon
id|copy_verf
c_func
(paren
r_new
comma
id|clverifier
)paren
suffix:semicolon
r_new
op_member_access_from_pointer
id|cl_addr
op_assign
id|ip_addr
suffix:semicolon
id|copy_cred
c_func
(paren
op_amp
r_new
op_member_access_from_pointer
id|cl_cred
comma
op_amp
id|rqstp-&gt;rq_cred
)paren
suffix:semicolon
id|gen_clid
c_func
(paren
r_new
)paren
suffix:semicolon
id|gen_confirm
c_func
(paren
r_new
)paren
suffix:semicolon
id|add_to_unconfirmed
c_func
(paren
r_new
comma
id|strhashval
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|cmp_verf
c_func
(paren
id|conf-&gt;cl_verifier
comma
id|clverifier
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * CASE 1:&n;&t;&t; * cl_name match, confirmed, principal match&n;&t;&t; * verifier match: probable callback update&n;&t;&t; *&n;&t;&t; * remove any unconfirmed nfs4_client with &n;&t;&t; * matching cl_name, cl_verifier, and cl_clientid&n;&t;&t; *&n;&t;&t; * create and insert an unconfirmed nfs4_client with same &n;&t;&t; * cl_name, cl_verifier, and cl_clientid as existing &n;&t;&t; * nfs4_client,  but with the new callback info and a &n;&t;&t; * new cl_confirm&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|unconf
)paren
op_logical_and
id|cmp_verf
c_func
(paren
id|unconf-&gt;cl_verifier
comma
id|conf-&gt;cl_verifier
)paren
op_logical_and
id|cmp_clid
c_func
(paren
op_amp
id|unconf-&gt;cl_clientid
comma
op_amp
id|conf-&gt;cl_clientid
)paren
)paren
(brace
id|expire_client
c_func
(paren
id|unconf
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
r_new
op_assign
id|create_client
c_func
(paren
id|clname
)paren
)paren
)paren
r_goto
id|out
suffix:semicolon
id|copy_verf
c_func
(paren
r_new
comma
id|conf-&gt;cl_verifier
)paren
suffix:semicolon
r_new
op_member_access_from_pointer
id|cl_addr
op_assign
id|ip_addr
suffix:semicolon
id|copy_cred
c_func
(paren
op_amp
r_new
op_member_access_from_pointer
id|cl_cred
comma
op_amp
id|rqstp-&gt;rq_cred
)paren
suffix:semicolon
id|copy_clid
c_func
(paren
r_new
comma
id|conf
)paren
suffix:semicolon
id|gen_confirm
c_func
(paren
r_new
)paren
suffix:semicolon
id|add_to_unconfirmed
c_func
(paren
r_new
comma
id|strhashval
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|unconf
)paren
(brace
multiline_comment|/*&n;&t;&t; * CASE 2:&n;&t;&t; * clname match, confirmed, principal match&n;&t;&t; * verfier does not match&n;&t;&t; * no unconfirmed. create a new unconfirmed nfs4_client&n;&t;&t; * using input clverifier, clname, and callback info&n;&t;&t; * and generate a new cl_clientid and cl_confirm.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
r_new
op_assign
id|create_client
c_func
(paren
id|clname
)paren
)paren
)paren
r_goto
id|out
suffix:semicolon
id|copy_verf
c_func
(paren
r_new
comma
id|clverifier
)paren
suffix:semicolon
r_new
op_member_access_from_pointer
id|cl_addr
op_assign
id|ip_addr
suffix:semicolon
id|copy_cred
c_func
(paren
op_amp
r_new
op_member_access_from_pointer
id|cl_cred
comma
op_amp
id|rqstp-&gt;rq_cred
)paren
suffix:semicolon
id|gen_clid
c_func
(paren
r_new
)paren
suffix:semicolon
id|gen_confirm
c_func
(paren
r_new
)paren
suffix:semicolon
id|add_to_unconfirmed
c_func
(paren
r_new
comma
id|strhashval
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|cmp_clid
c_func
(paren
op_amp
id|conf-&gt;cl_clientid
comma
op_amp
id|unconf-&gt;cl_clientid
)paren
op_logical_and
op_logical_neg
id|cmp_verf
c_func
(paren
id|conf-&gt;cl_confirm
comma
id|unconf-&gt;cl_confirm
)paren
)paren
(brace
multiline_comment|/*&t;&n;&t;&t; * CASE3:&n;&t;&t; * confirmed found (name, principal match)&n;&t;&t; * confirmed verifier does not match input clverifier&n;&t;&t; *&n;&t;&t; * unconfirmed found (name match)&n;&t;&t; * confirmed-&gt;cl_clientid != unconfirmed-&gt;cl_clientid and&n;&t;&t; * confirmed-&gt;cl_confirm != unconfirmed-&gt;cl_confirm&n;&t;&t; *&n;&t;&t; * remove unconfirmed.&n;&t;&t; *&n;&t;&t; * create an unconfirmed nfs4_client &n;&t;&t; * with same cl_name as existing confirmed nfs4_client, &n;&t;&t; * but with new callback info, new cl_clientid,&n;&t;&t; * new cl_verifier and a new cl_confirm&n;&t;&t; */
id|expire_client
c_func
(paren
id|unconf
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
r_new
op_assign
id|create_client
c_func
(paren
id|clname
)paren
)paren
)paren
r_goto
id|out
suffix:semicolon
id|copy_verf
c_func
(paren
r_new
comma
id|clverifier
)paren
suffix:semicolon
r_new
op_member_access_from_pointer
id|cl_addr
op_assign
id|ip_addr
suffix:semicolon
id|copy_cred
c_func
(paren
op_amp
r_new
op_member_access_from_pointer
id|cl_cred
comma
op_amp
id|rqstp-&gt;rq_cred
)paren
suffix:semicolon
id|gen_clid
c_func
(paren
r_new
)paren
suffix:semicolon
id|gen_confirm
c_func
(paren
r_new
)paren
suffix:semicolon
id|add_to_unconfirmed
c_func
(paren
r_new
comma
id|strhashval
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* No cases hit !!! */
id|status
op_assign
id|nfserr_inval
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|setclid-&gt;se_clientid.cl_boot
op_assign
r_new
op_member_access_from_pointer
id|cl_clientid.cl_boot
suffix:semicolon
id|setclid-&gt;se_clientid.cl_id
op_assign
r_new
op_member_access_from_pointer
id|cl_clientid.cl_id
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|setclid-&gt;se_confirm
comma
r_new
op_member_access_from_pointer
id|cl_confirm
comma
r_sizeof
(paren
id|nfs4_verifier
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;NFSD: this client will not receive delegations&bslash;n&quot;
)paren
suffix:semicolon
id|status
op_assign
id|nfs_ok
suffix:semicolon
id|out
suffix:colon
id|up
c_func
(paren
op_amp
id|client_sema
)paren
suffix:semicolon
r_return
id|status
suffix:semicolon
)brace
multiline_comment|/*&n; * RFC 3010 has a complex implmentation description of processing a &n; * SETCLIENTID_CONFIRM request consisting of 4 bullets describing&n; * processing on a DRC miss, labeled as CASE1 - CASE4 below.&n; *&n; * NOTE: callback information will be processed here in a future patch&n; */
r_int
DECL|function|nfsd4_setclientid_confirm
id|nfsd4_setclientid_confirm
c_func
(paren
r_struct
id|svc_rqst
op_star
id|rqstp
comma
r_struct
id|nfsd4_setclientid_confirm
op_star
id|setclientid_confirm
)paren
(brace
id|u32
id|ip_addr
op_assign
id|rqstp-&gt;rq_addr.sin_addr.s_addr
suffix:semicolon
r_int
r_int
id|idhashval
suffix:semicolon
r_struct
id|nfs4_client
op_star
id|clp
comma
op_star
id|conf
op_assign
l_int|NULL
comma
op_star
id|unconf
op_assign
l_int|NULL
suffix:semicolon
r_char
op_star
id|confirm
op_assign
id|setclientid_confirm-&gt;sc_confirm
suffix:semicolon
id|clientid_t
op_star
id|clid
op_assign
op_amp
id|setclientid_confirm-&gt;sc_clientid
suffix:semicolon
r_struct
id|list_head
op_star
id|pos
comma
op_star
id|next
suffix:semicolon
r_int
id|status
suffix:semicolon
id|status
op_assign
id|nfserr_stale_clientid
suffix:semicolon
r_if
c_cond
(paren
id|STALE_CLIENTID
c_func
(paren
id|clid
)paren
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* &n;&t; * XXX The Duplicate Request Cache (DRC) has been checked (??)&n;&t; * We get here on a DRC miss.&n;&t; */
id|idhashval
op_assign
id|clientid_hashval
c_func
(paren
id|clid-&gt;cl_id
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|client_sema
)paren
suffix:semicolon
id|list_for_each_safe
c_func
(paren
id|pos
comma
id|next
comma
op_amp
id|conf_id_hashtbl
(braket
id|idhashval
)braket
)paren
(brace
id|clp
op_assign
id|list_entry
c_func
(paren
id|pos
comma
r_struct
id|nfs4_client
comma
id|cl_idhash
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cmp_clid
c_func
(paren
op_amp
id|clp-&gt;cl_clientid
comma
id|clid
)paren
)paren
r_continue
suffix:semicolon
id|status
op_assign
id|nfserr_inval
suffix:semicolon
multiline_comment|/* &n;&t;&t; * Found a record for this clientid. If the IP addresses&n;&t;&t; * don&squot;t match, return ERR_INVAL just as if the record had&n;&t;&t; * not been found.&n;&t;&t; */
r_if
c_cond
(paren
id|clp-&gt;cl_addr
op_ne
id|ip_addr
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;NFSD: setclientid: string in use by client&quot;
l_string|&quot;(clientid %08x/%08x)&bslash;n&quot;
comma
id|clp-&gt;cl_clientid.cl_boot
comma
id|clp-&gt;cl_clientid.cl_id
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|conf
op_assign
id|clp
suffix:semicolon
r_break
suffix:semicolon
)brace
id|list_for_each_safe
c_func
(paren
id|pos
comma
id|next
comma
op_amp
id|unconf_id_hashtbl
(braket
id|idhashval
)braket
)paren
(brace
id|clp
op_assign
id|list_entry
c_func
(paren
id|pos
comma
r_struct
id|nfs4_client
comma
id|cl_idhash
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cmp_clid
c_func
(paren
op_amp
id|clp-&gt;cl_clientid
comma
id|clid
)paren
)paren
r_continue
suffix:semicolon
id|status
op_assign
id|nfserr_inval
suffix:semicolon
r_if
c_cond
(paren
id|clp-&gt;cl_addr
op_ne
id|ip_addr
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;NFSD: setclientid: string in use by client&quot;
l_string|&quot;(clientid %08x/%08x)&bslash;n&quot;
comma
id|clp-&gt;cl_clientid.cl_boot
comma
id|clp-&gt;cl_clientid.cl_id
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|unconf
op_assign
id|clp
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* CASE 1: &n;&t;* unconf record that matches input clientid and input confirm.&n;&t;* conf record that matches input clientid.&n;&t;* conf  and unconf records match names, verifiers &n;&t;*/
r_if
c_cond
(paren
(paren
id|conf
op_logical_and
id|unconf
)paren
op_logical_and
(paren
id|cmp_verf
c_func
(paren
id|unconf-&gt;cl_confirm
comma
id|confirm
)paren
)paren
op_logical_and
(paren
id|cmp_verf
c_func
(paren
id|conf-&gt;cl_verifier
comma
id|unconf-&gt;cl_verifier
)paren
)paren
op_logical_and
(paren
id|cmp_name
c_func
(paren
op_amp
id|conf-&gt;cl_name
comma
op_amp
id|unconf-&gt;cl_name
)paren
)paren
op_logical_and
(paren
op_logical_neg
id|cmp_verf
c_func
(paren
id|conf-&gt;cl_confirm
comma
id|unconf-&gt;cl_confirm
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|cmp_creds
c_func
(paren
op_amp
id|conf-&gt;cl_cred
comma
op_amp
id|unconf-&gt;cl_cred
)paren
)paren
id|status
op_assign
id|nfserr_clid_inuse
suffix:semicolon
r_else
(brace
id|expire_client
c_func
(paren
id|conf
)paren
suffix:semicolon
id|move_to_confirmed
c_func
(paren
id|unconf
comma
id|idhashval
)paren
suffix:semicolon
id|status
op_assign
id|nfs_ok
suffix:semicolon
)brace
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* CASE 2:&n;&t; * conf record that matches input clientid.&n;&t; * if unconf record that matches input clientid, then unconf-&gt;cl_name&n;&t; * or unconf-&gt;cl_verifier don&squot;t match the conf record.&n;&t; */
r_if
c_cond
(paren
(paren
id|conf
op_logical_and
op_logical_neg
id|unconf
)paren
op_logical_or
(paren
(paren
id|conf
op_logical_and
id|unconf
)paren
op_logical_and
(paren
op_logical_neg
id|cmp_verf
c_func
(paren
id|conf-&gt;cl_verifier
comma
id|unconf-&gt;cl_verifier
)paren
op_logical_or
op_logical_neg
id|cmp_name
c_func
(paren
op_amp
id|conf-&gt;cl_name
comma
op_amp
id|unconf-&gt;cl_name
)paren
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|cmp_creds
c_func
(paren
op_amp
id|conf-&gt;cl_cred
comma
op_amp
id|rqstp-&gt;rq_cred
)paren
)paren
(brace
id|status
op_assign
id|nfserr_clid_inuse
suffix:semicolon
)brace
r_else
(brace
id|status
op_assign
id|nfs_ok
suffix:semicolon
)brace
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* CASE 3:&n;&t; * conf record not found.&n;&t; * unconf record found. &n;&t; * unconf-&gt;cl_confirm matches input confirm&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|conf
op_logical_and
id|unconf
op_logical_and
id|cmp_verf
c_func
(paren
id|unconf-&gt;cl_confirm
comma
id|confirm
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|cmp_creds
c_func
(paren
op_amp
id|unconf-&gt;cl_cred
comma
op_amp
id|rqstp-&gt;rq_cred
)paren
)paren
(brace
id|status
op_assign
id|nfserr_clid_inuse
suffix:semicolon
)brace
r_else
(brace
id|status
op_assign
id|nfs_ok
suffix:semicolon
id|move_to_confirmed
c_func
(paren
id|unconf
comma
id|idhashval
)paren
suffix:semicolon
)brace
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* CASE 4:&n;&t; * conf record not found, or if conf, then conf-&gt;cl_confirm does not&n;&t; * match input confirm.&n;&t; * unconf record not found, or if unconf, then unconf-&gt;cl_confirm &n;&t; * does not match input confirm.&n;&t; */
r_if
c_cond
(paren
(paren
op_logical_neg
id|conf
op_logical_or
(paren
id|conf
op_logical_and
op_logical_neg
id|cmp_verf
c_func
(paren
id|conf-&gt;cl_confirm
comma
id|confirm
)paren
)paren
)paren
op_logical_and
(paren
op_logical_neg
id|unconf
op_logical_or
(paren
id|unconf
op_logical_and
op_logical_neg
id|cmp_verf
c_func
(paren
id|unconf-&gt;cl_confirm
comma
id|confirm
)paren
)paren
)paren
)paren
(brace
id|status
op_assign
id|nfserr_stale_clientid
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* check that we have hit one of the cases...*/
id|status
op_assign
id|nfserr_inval
suffix:semicolon
r_goto
id|out
suffix:semicolon
id|out
suffix:colon
multiline_comment|/* XXX if status == nfs_ok, probe callback path */
id|up
c_func
(paren
op_amp
id|client_sema
)paren
suffix:semicolon
r_return
id|status
suffix:semicolon
)brace
multiline_comment|/* &n; * Open owner state (share locks)&n; */
DECL|macro|ZERO_STATEID
mdefine_line|#define ZERO_STATEID(stateid)       (!memcmp((stateid), &amp;zerostateid, sizeof(stateid_t)))
DECL|macro|ONE_STATEID
mdefine_line|#define ONE_STATEID(stateid)        (!memcmp((stateid), &amp;onestateid, sizeof(stateid_t)))
multiline_comment|/* hash tables for nfs4_stateowner */
DECL|macro|OWNER_HASH_BITS
mdefine_line|#define OWNER_HASH_BITS              8
DECL|macro|OWNER_HASH_SIZE
mdefine_line|#define OWNER_HASH_SIZE             (1 &lt;&lt; OWNER_HASH_BITS)
DECL|macro|OWNER_HASH_MASK
mdefine_line|#define OWNER_HASH_MASK             (OWNER_HASH_SIZE - 1)
DECL|macro|ownerid_hashval
mdefine_line|#define ownerid_hashval(id) &bslash;&n;        ((id) &amp; OWNER_HASH_MASK)
DECL|macro|ownerstr_hashval
mdefine_line|#define ownerstr_hashval(clientid, ownername) &bslash;&n;        (((clientid) + opaque_hashval((ownername.data), (ownername.len))) &amp; OWNER_HASH_MASK)
DECL|variable|ownerid_hashtbl
r_static
r_struct
id|list_head
id|ownerid_hashtbl
(braket
id|OWNER_HASH_SIZE
)braket
suffix:semicolon
DECL|variable|ownerstr_hashtbl
r_static
r_struct
id|list_head
id|ownerstr_hashtbl
(braket
id|OWNER_HASH_SIZE
)braket
suffix:semicolon
multiline_comment|/* hash table for nfs4_file */
DECL|macro|FILE_HASH_BITS
mdefine_line|#define FILE_HASH_BITS                   8
DECL|macro|FILE_HASH_SIZE
mdefine_line|#define FILE_HASH_SIZE                  (1 &lt;&lt; FILE_HASH_BITS)
DECL|macro|FILE_HASH_MASK
mdefine_line|#define FILE_HASH_MASK                  (FILE_HASH_SIZE - 1)
multiline_comment|/* hash table for (open)nfs4_stateid */
DECL|macro|OPENSTATEID_HASH_BITS
mdefine_line|#define OPENSTATEID_HASH_BITS              10
DECL|macro|OPENSTATEID_HASH_SIZE
mdefine_line|#define OPENSTATEID_HASH_SIZE              (1 &lt;&lt; OPENSTATEID_HASH_BITS)
DECL|macro|OPENSTATEID_HASH_MASK
mdefine_line|#define OPENSTATEID_HASH_MASK              (OPENSTATEID_HASH_SIZE - 1)
DECL|macro|file_hashval
mdefine_line|#define file_hashval(x) &bslash;&n;        ((unsigned int)((x)-&gt;dev + (x)-&gt;ino + (x)-&gt;generation) &amp; FILE_HASH_MASK)
DECL|macro|openstateid_hashval
mdefine_line|#define openstateid_hashval(owner_id, file_id)  &bslash;&n;        (((owner_id) + (file_id)) &amp; OPENSTATEID_HASH_MASK)
DECL|variable|file_hashtbl
r_static
r_struct
id|list_head
id|file_hashtbl
(braket
id|FILE_HASH_SIZE
)braket
suffix:semicolon
DECL|variable|openstateid_hashtbl
r_static
r_struct
id|list_head
id|openstateid_hashtbl
(braket
id|OPENSTATEID_HASH_SIZE
)braket
suffix:semicolon
multiline_comment|/* OPEN Share state helper functions */
r_static
r_inline
r_struct
id|nfs4_file
op_star
DECL|function|alloc_init_file
id|alloc_init_file
c_func
(paren
r_int
r_int
id|hashval
comma
id|nfs4_ino_desc_t
op_star
id|ino
)paren
(brace
r_struct
id|nfs4_file
op_star
id|fp
suffix:semicolon
r_if
c_cond
(paren
(paren
id|fp
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|nfs4_file
)paren
comma
id|GFP_KERNEL
)paren
)paren
)paren
(brace
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|fp-&gt;fi_hash
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|fp-&gt;fi_perfile
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|fp-&gt;fi_hash
comma
op_amp
id|file_hashtbl
(braket
id|hashval
)braket
)paren
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|fp-&gt;fi_ino
comma
id|ino
comma
r_sizeof
(paren
id|nfs4_ino_desc_t
)paren
)paren
suffix:semicolon
id|fp-&gt;fi_id
op_assign
id|current_fileid
op_increment
suffix:semicolon
id|alloc_file
op_increment
suffix:semicolon
r_return
id|fp
suffix:semicolon
)brace
r_return
(paren
r_struct
id|nfs4_file
op_star
)paren
l_int|NULL
suffix:semicolon
)brace
r_static
r_void
DECL|function|release_all_files
id|release_all_files
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|nfs4_file
op_star
id|fp
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|FILE_HASH_SIZE
suffix:semicolon
id|i
op_increment
)paren
(brace
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|file_hashtbl
(braket
id|i
)braket
)paren
)paren
(brace
id|fp
op_assign
id|list_entry
c_func
(paren
id|file_hashtbl
(braket
id|i
)braket
dot
id|next
comma
r_struct
id|nfs4_file
comma
id|fi_hash
)paren
suffix:semicolon
multiline_comment|/* this should never be more than once... */
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|fp-&gt;fi_perfile
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ERROR: release_all_files: file %p is open, creating dangling state !!!&bslash;n&quot;
comma
id|fp
)paren
suffix:semicolon
)brace
id|release_file
c_func
(paren
id|fp
)paren
suffix:semicolon
)brace
)brace
)brace
r_static
r_inline
r_struct
id|nfs4_stateowner
op_star
DECL|function|alloc_stateowner
id|alloc_stateowner
c_func
(paren
r_struct
id|xdr_netobj
op_star
id|owner
)paren
(brace
r_struct
id|nfs4_stateowner
op_star
id|sop
suffix:semicolon
r_if
c_cond
(paren
(paren
id|sop
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|nfs4_stateowner
)paren
comma
id|GFP_KERNEL
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|sop-&gt;so_owner.data
op_assign
id|kmalloc
c_func
(paren
id|owner-&gt;len
comma
id|GFP_KERNEL
)paren
)paren
)paren
(brace
id|memcpy
c_func
(paren
id|sop-&gt;so_owner.data
comma
id|owner-&gt;data
comma
id|owner-&gt;len
)paren
suffix:semicolon
id|sop-&gt;so_owner.len
op_assign
id|owner-&gt;len
suffix:semicolon
r_return
id|sop
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|sop
)paren
suffix:semicolon
)brace
r_return
(paren
r_struct
id|nfs4_stateowner
op_star
)paren
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* should use a slab cache */
r_static
r_void
DECL|function|free_stateowner
id|free_stateowner
c_func
(paren
r_struct
id|nfs4_stateowner
op_star
id|sop
)paren
(brace
r_if
c_cond
(paren
id|sop
)paren
(brace
id|kfree
c_func
(paren
id|sop-&gt;so_owner.data
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|sop
)paren
suffix:semicolon
id|sop
op_assign
l_int|NULL
suffix:semicolon
id|free_sowner
op_increment
suffix:semicolon
)brace
)brace
r_static
r_struct
id|nfs4_stateowner
op_star
DECL|function|alloc_init_stateowner
id|alloc_init_stateowner
c_func
(paren
r_int
r_int
id|strhashval
comma
r_struct
id|nfs4_client
op_star
id|clp
comma
r_struct
id|nfsd4_open
op_star
id|open
)paren
(brace
r_struct
id|nfs4_stateowner
op_star
id|sop
suffix:semicolon
r_int
r_int
id|idhashval
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|sop
op_assign
id|alloc_stateowner
c_func
(paren
op_amp
id|open-&gt;op_owner
)paren
)paren
)paren
r_return
(paren
r_struct
id|nfs4_stateowner
op_star
)paren
l_int|NULL
suffix:semicolon
id|idhashval
op_assign
id|ownerid_hashval
c_func
(paren
id|current_ownerid
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|sop-&gt;so_idhash
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|sop-&gt;so_strhash
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|sop-&gt;so_perclient
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|sop-&gt;so_peropenstate
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|sop-&gt;so_idhash
comma
op_amp
id|ownerid_hashtbl
(braket
id|idhashval
)braket
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|sop-&gt;so_strhash
comma
op_amp
id|ownerstr_hashtbl
(braket
id|strhashval
)braket
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|sop-&gt;so_perclient
comma
op_amp
id|clp-&gt;cl_perclient
)paren
suffix:semicolon
id|add_perclient
op_increment
suffix:semicolon
id|sop-&gt;so_id
op_assign
id|current_ownerid
op_increment
suffix:semicolon
id|sop-&gt;so_client
op_assign
id|clp
suffix:semicolon
id|sop-&gt;so_seqid
op_assign
id|open-&gt;op_seqid
suffix:semicolon
id|sop-&gt;so_confirmed
op_assign
l_int|0
suffix:semicolon
id|alloc_sowner
op_increment
suffix:semicolon
r_return
id|sop
suffix:semicolon
)brace
r_static
r_void
DECL|function|release_stateowner
id|release_stateowner
c_func
(paren
r_struct
id|nfs4_stateowner
op_star
id|sop
)paren
(brace
r_struct
id|nfs4_stateid
op_star
id|stp
suffix:semicolon
id|list_del_init
c_func
(paren
op_amp
id|sop-&gt;so_idhash
)paren
suffix:semicolon
id|list_del_init
c_func
(paren
op_amp
id|sop-&gt;so_strhash
)paren
suffix:semicolon
id|list_del_init
c_func
(paren
op_amp
id|sop-&gt;so_perclient
)paren
suffix:semicolon
id|del_perclient
op_increment
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|sop-&gt;so_peropenstate
)paren
)paren
(brace
id|stp
op_assign
id|list_entry
c_func
(paren
id|sop-&gt;so_peropenstate.next
comma
r_struct
id|nfs4_stateid
comma
id|st_peropenstate
)paren
suffix:semicolon
id|release_stateid
c_func
(paren
id|stp
)paren
suffix:semicolon
)brace
id|free_stateowner
c_func
(paren
id|sop
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|init_stateid
id|init_stateid
c_func
(paren
r_struct
id|nfs4_stateid
op_star
id|stp
comma
r_struct
id|nfs4_file
op_star
id|fp
comma
r_struct
id|nfs4_stateowner
op_star
id|sop
comma
r_struct
id|nfsd4_open
op_star
id|open
)paren
(brace
r_int
r_int
id|hashval
op_assign
id|openstateid_hashval
c_func
(paren
id|sop-&gt;so_id
comma
id|fp-&gt;fi_id
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|stp-&gt;st_hash
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|stp-&gt;st_peropenstate
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|stp-&gt;st_perfile
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|stp-&gt;st_hash
comma
op_amp
id|openstateid_hashtbl
(braket
id|hashval
)braket
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|stp-&gt;st_peropenstate
comma
op_amp
id|sop-&gt;so_peropenstate
)paren
suffix:semicolon
id|list_add_perfile
op_increment
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|stp-&gt;st_perfile
comma
op_amp
id|fp-&gt;fi_perfile
)paren
suffix:semicolon
id|stp-&gt;st_stateowner
op_assign
id|sop
suffix:semicolon
id|stp-&gt;st_file
op_assign
id|fp
suffix:semicolon
id|stp-&gt;st_stateid.si_boot
op_assign
id|boot_time
suffix:semicolon
id|stp-&gt;st_stateid.si_stateownerid
op_assign
id|sop-&gt;so_id
suffix:semicolon
id|stp-&gt;st_stateid.si_fileid
op_assign
id|fp-&gt;fi_id
suffix:semicolon
id|stp-&gt;st_stateid.si_generation
op_assign
l_int|0
suffix:semicolon
id|stp-&gt;st_share_access
op_assign
id|open-&gt;op_share_access
suffix:semicolon
id|stp-&gt;st_share_deny
op_assign
id|open-&gt;op_share_deny
suffix:semicolon
)brace
r_static
r_void
DECL|function|release_stateid
id|release_stateid
c_func
(paren
r_struct
id|nfs4_stateid
op_star
id|stp
)paren
(brace
id|list_del_init
c_func
(paren
op_amp
id|stp-&gt;st_hash
)paren
suffix:semicolon
id|list_del_perfile
op_increment
suffix:semicolon
id|list_del_init
c_func
(paren
op_amp
id|stp-&gt;st_perfile
)paren
suffix:semicolon
id|list_del_init
c_func
(paren
op_amp
id|stp-&gt;st_peropenstate
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stp-&gt;st_vfs_set
)paren
(brace
id|nfsd_close
c_func
(paren
op_amp
id|stp-&gt;st_vfs_file
)paren
suffix:semicolon
id|vfsclose
op_increment
suffix:semicolon
id|dput
c_func
(paren
id|stp-&gt;st_vfs_file.f_dentry
)paren
suffix:semicolon
id|mntput
c_func
(paren
id|stp-&gt;st_vfs_file.f_vfsmnt
)paren
suffix:semicolon
)brace
multiline_comment|/* should use a slab cache */
id|kfree
c_func
(paren
id|stp
)paren
suffix:semicolon
id|stp
op_assign
l_int|NULL
suffix:semicolon
)brace
r_static
r_void
DECL|function|release_file
id|release_file
c_func
(paren
r_struct
id|nfs4_file
op_star
id|fp
)paren
(brace
id|free_file
op_increment
suffix:semicolon
id|list_del_init
c_func
(paren
op_amp
id|fp-&gt;fi_hash
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|fp
)paren
suffix:semicolon
)brace
r_void
DECL|function|release_open_state
id|release_open_state
c_func
(paren
r_struct
id|nfs4_stateid
op_star
id|stp
)paren
(brace
r_struct
id|nfs4_stateowner
op_star
id|sop
op_assign
id|stp-&gt;st_stateowner
suffix:semicolon
r_struct
id|nfs4_file
op_star
id|fp
op_assign
id|stp-&gt;st_file
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;NFSD: release_open_state&bslash;n&quot;
)paren
suffix:semicolon
id|release_stateid
c_func
(paren
id|stp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * release unused nfs4_stateowners.&n;&t; * XXX will need to be placed  on an  open_stateid_lru list to be&n;&t; * released by the laundromat service after the lease period&n;&t; * to enable us to handle CLOSE replay&n;&t; */
r_if
c_cond
(paren
id|sop-&gt;so_confirmed
op_logical_and
id|list_empty
c_func
(paren
op_amp
id|sop-&gt;so_peropenstate
)paren
)paren
(brace
id|release_stateowner
c_func
(paren
id|sop
)paren
suffix:semicolon
)brace
multiline_comment|/* unused nfs4_file&squot;s are releseed. XXX slab cache? */
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|fp-&gt;fi_perfile
)paren
)paren
(brace
id|release_file
c_func
(paren
id|fp
)paren
suffix:semicolon
)brace
)brace
r_static
r_int
DECL|function|cmp_owner_str
id|cmp_owner_str
c_func
(paren
r_struct
id|nfs4_stateowner
op_star
id|sop
comma
r_struct
id|nfsd4_open
op_star
id|open
)paren
(brace
r_return
(paren
(paren
id|sop-&gt;so_owner.len
op_eq
id|open-&gt;op_owner.len
)paren
op_logical_and
op_logical_neg
id|memcmp
c_func
(paren
id|sop-&gt;so_owner.data
comma
id|open-&gt;op_owner.data
comma
id|sop-&gt;so_owner.len
)paren
op_logical_and
(paren
id|sop-&gt;so_client-&gt;cl_clientid.cl_id
op_eq
id|open-&gt;op_clientid.cl_id
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* search ownerstr_hashtbl[] for owner */
r_static
r_int
DECL|function|find_stateowner_str
id|find_stateowner_str
c_func
(paren
r_int
r_int
id|hashval
comma
r_struct
id|nfsd4_open
op_star
id|open
comma
r_struct
id|nfs4_stateowner
op_star
op_star
id|op
)paren
(brace
r_struct
id|list_head
op_star
id|pos
comma
op_star
id|next
suffix:semicolon
r_struct
id|nfs4_stateowner
op_star
id|local
op_assign
l_int|NULL
suffix:semicolon
id|list_for_each_safe
c_func
(paren
id|pos
comma
id|next
comma
op_amp
id|ownerstr_hashtbl
(braket
id|hashval
)braket
)paren
(brace
id|local
op_assign
id|list_entry
c_func
(paren
id|pos
comma
r_struct
id|nfs4_stateowner
comma
id|so_strhash
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cmp_owner_str
c_func
(paren
id|local
comma
id|open
)paren
)paren
(brace
r_continue
suffix:semicolon
)brace
op_star
id|op
op_assign
id|local
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* see if clientid is in confirmed hash table */
r_static
r_int
DECL|function|verify_clientid
id|verify_clientid
c_func
(paren
r_struct
id|nfs4_client
op_star
op_star
id|client
comma
id|clientid_t
op_star
id|clid
)paren
(brace
r_struct
id|list_head
op_star
id|pos
comma
op_star
id|next
suffix:semicolon
r_struct
id|nfs4_client
op_star
id|clp
suffix:semicolon
r_int
r_int
id|idhashval
op_assign
id|clientid_hashval
c_func
(paren
id|clid-&gt;cl_id
)paren
suffix:semicolon
id|list_for_each_safe
c_func
(paren
id|pos
comma
id|next
comma
op_amp
id|conf_id_hashtbl
(braket
id|idhashval
)braket
)paren
(brace
id|clp
op_assign
id|list_entry
c_func
(paren
id|pos
comma
r_struct
id|nfs4_client
comma
id|cl_idhash
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cmp_clid
c_func
(paren
op_amp
id|clp-&gt;cl_clientid
comma
id|clid
)paren
)paren
r_continue
suffix:semicolon
op_star
id|client
op_assign
id|clp
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
op_star
id|client
op_assign
l_int|NULL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* search file_hashtbl[] for file */
r_static
r_int
DECL|function|find_file
id|find_file
c_func
(paren
r_int
r_int
id|hashval
comma
id|nfs4_ino_desc_t
op_star
id|ino
comma
r_struct
id|nfs4_file
op_star
op_star
id|fp
)paren
(brace
r_struct
id|list_head
op_star
id|pos
comma
op_star
id|next
suffix:semicolon
r_struct
id|nfs4_file
op_star
id|local
op_assign
l_int|NULL
suffix:semicolon
id|list_for_each_safe
c_func
(paren
id|pos
comma
id|next
comma
op_amp
id|file_hashtbl
(braket
id|hashval
)braket
)paren
(brace
id|local
op_assign
id|list_entry
c_func
(paren
id|pos
comma
r_struct
id|nfs4_file
comma
id|fi_hash
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|memcmp
c_func
(paren
op_amp
id|local-&gt;fi_ino
comma
id|ino
comma
r_sizeof
(paren
id|nfs4_ino_desc_t
)paren
)paren
)paren
(brace
op_star
id|fp
op_assign
id|local
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|test_share
id|test_share
c_func
(paren
r_struct
id|nfs4_stateid
op_star
id|stp
comma
r_struct
id|nfsd4_open
op_star
id|open
)paren
(brace
r_if
c_cond
(paren
(paren
id|stp-&gt;st_share_access
op_amp
id|open-&gt;op_share_deny
)paren
op_logical_or
(paren
id|stp-&gt;st_share_deny
op_amp
id|open-&gt;op_share_access
)paren
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|nfs4_init_ino
id|nfs4_init_ino
c_func
(paren
id|nfs4_ino_desc_t
op_star
id|ino
comma
r_struct
id|svc_fh
op_star
id|fhp
)paren
(brace
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fhp-&gt;fh_dentry
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|inode
op_assign
id|fhp-&gt;fh_dentry-&gt;d_inode
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inode
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|ino-&gt;dev
op_assign
id|inode-&gt;i_sb-&gt;s_dev
suffix:semicolon
id|ino-&gt;ino
op_assign
id|inode-&gt;i_ino
suffix:semicolon
id|ino-&gt;generation
op_assign
id|inode-&gt;i_generation
suffix:semicolon
)brace
r_static
r_inline
r_int
DECL|function|nfs4_file_upgrade
id|nfs4_file_upgrade
c_func
(paren
r_struct
id|file
op_star
id|filp
comma
r_int
r_int
id|share_access
)paren
(brace
r_int
id|status
suffix:semicolon
r_if
c_cond
(paren
id|share_access
op_amp
id|NFS4_SHARE_ACCESS_WRITE
)paren
(brace
id|status
op_assign
id|get_write_access
c_func
(paren
id|filp-&gt;f_dentry-&gt;d_inode
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|status
)paren
id|filp-&gt;f_mode
op_assign
id|FMODE_WRITE
suffix:semicolon
r_else
r_return
id|nfserrno
c_func
(paren
id|status
)paren
suffix:semicolon
)brace
r_return
id|nfs_ok
suffix:semicolon
)brace
multiline_comment|/*&n; * nfsd4_process_open1()&n; * &t;lookup stateowner.&n; * &t;&t;found:&n; * &t;&t;&t;check confirmed &n; * &t;&t;&t;&t;confirmed:&n; * &t;&t;&t;&t;&t;check seqid&n; * &t;&t;&t;&t;not confirmed:&n; * &t;&t;&t;&t;&t;delete owner&n; * &t;&t;&t;&t;&t;create new owner&n; * &t;&t;notfound:&n; * &t;&t;&t;verify clientid&n; * &t;&t;&t;create new owner&n; */
r_int
DECL|function|nfsd4_process_open1
id|nfsd4_process_open1
c_func
(paren
r_struct
id|nfsd4_open
op_star
id|open
)paren
(brace
r_int
id|status
suffix:semicolon
id|clientid_t
op_star
id|clientid
op_assign
op_amp
id|open-&gt;op_clientid
suffix:semicolon
r_struct
id|nfs4_client
op_star
id|clp
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|strhashval
suffix:semicolon
r_struct
id|nfs4_stateowner
op_star
id|sop
op_assign
l_int|NULL
suffix:semicolon
id|status
op_assign
id|nfserr_inval
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|check_name
c_func
(paren
id|open-&gt;op_owner
)paren
)paren
r_goto
id|out
suffix:semicolon
id|status
op_assign
id|nfserr_stale_clientid
suffix:semicolon
r_if
c_cond
(paren
id|STALE_CLIENTID
c_func
(paren
op_amp
id|open-&gt;op_clientid
)paren
)paren
r_goto
id|out
suffix:semicolon
id|down
c_func
(paren
op_amp
id|client_sema
)paren
suffix:semicolon
multiline_comment|/* XXX need finer grained locking */
id|strhashval
op_assign
id|ownerstr_hashval
c_func
(paren
id|clientid-&gt;cl_id
comma
id|open-&gt;op_owner
)paren
suffix:semicolon
r_if
c_cond
(paren
id|find_stateowner_str
c_func
(paren
id|strhashval
comma
id|open
comma
op_amp
id|sop
)paren
)paren
(brace
id|open-&gt;op_stateowner
op_assign
id|sop
suffix:semicolon
r_if
c_cond
(paren
id|open-&gt;op_seqid
op_eq
id|sop-&gt;so_seqid
)paren
(brace
multiline_comment|/* XXX retplay: for now, return bad seqid */
id|status
op_assign
id|nfserr_bad_seqid
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sop-&gt;so_confirmed
)paren
(brace
r_if
c_cond
(paren
id|open-&gt;op_seqid
op_eq
id|sop-&gt;so_seqid
op_plus
l_int|1
)paren
(brace
id|status
op_assign
id|nfs_ok
suffix:semicolon
r_goto
id|renew
suffix:semicolon
)brace
id|status
op_assign
id|nfserr_bad_seqid
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* If we get here, we received and OPEN for an unconfirmed&n;&t;&t; * nfs4_stateowner. If seqid&squot;s are the same then this &n;&t;&t; * is a replay.&n;&t;&t; * If the sequid&squot;s are different, then purge the &n;&t;&t; * existing nfs4_stateowner, and instantiate a new one.&n;&t;&t; */
id|clp
op_assign
id|sop-&gt;so_client
suffix:semicolon
id|release_stateowner
c_func
(paren
id|sop
)paren
suffix:semicolon
r_goto
id|instantiate_new_owner
suffix:semicolon
)brace
multiline_comment|/* nfs4_stateowner not found. &n;&t;* verify clientid and instantiate new nfs4_stateowner&n;&t;* if verify fails this is presumably the result of the &n;&t;* client&squot;s lease expiring.&n;&t;*&n;&t;* XXX compare clp-&gt;cl_addr with rqstp addr? &n;&t;*/
id|status
op_assign
id|nfserr_expired
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|verify_clientid
c_func
(paren
op_amp
id|clp
comma
id|clientid
)paren
)paren
r_goto
id|out
suffix:semicolon
id|instantiate_new_owner
suffix:colon
id|status
op_assign
id|nfserr_resource
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|sop
op_assign
id|alloc_init_stateowner
c_func
(paren
id|strhashval
comma
id|clp
comma
id|open
)paren
)paren
)paren
r_goto
id|out
suffix:semicolon
id|open-&gt;op_stateowner
op_assign
id|sop
suffix:semicolon
id|status
op_assign
id|nfs_ok
suffix:semicolon
id|renew
suffix:colon
id|renew_client
c_func
(paren
id|sop-&gt;so_client
)paren
suffix:semicolon
id|out
suffix:colon
id|up
c_func
(paren
op_amp
id|client_sema
)paren
suffix:semicolon
multiline_comment|/*XXX need finer grained locking */
r_return
id|status
suffix:semicolon
)brace
r_int
DECL|function|nfsd4_process_open2
id|nfsd4_process_open2
c_func
(paren
r_struct
id|svc_rqst
op_star
id|rqstp
comma
r_struct
id|svc_fh
op_star
id|current_fh
comma
r_struct
id|nfsd4_open
op_star
id|open
)paren
(brace
r_struct
id|iattr
id|iattr
suffix:semicolon
r_struct
id|nfs4_stateowner
op_star
id|sop
op_assign
id|open-&gt;op_stateowner
suffix:semicolon
r_struct
id|nfs4_file
op_star
id|fp
suffix:semicolon
id|nfs4_ino_desc_t
id|ino
suffix:semicolon
r_int
r_int
id|fi_hashval
suffix:semicolon
r_struct
id|list_head
op_star
id|pos
comma
op_star
id|next
suffix:semicolon
r_struct
id|nfs4_stateid
op_star
id|stq
comma
op_star
id|stp
op_assign
l_int|NULL
suffix:semicolon
r_int
id|status
suffix:semicolon
id|status
op_assign
id|nfserr_resource
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sop
)paren
r_goto
id|out
suffix:semicolon
id|nfs4_init_ino
c_func
(paren
op_amp
id|ino
comma
id|current_fh
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|client_sema
)paren
suffix:semicolon
multiline_comment|/*XXX need finer grained locking */
id|fi_hashval
op_assign
id|file_hashval
c_func
(paren
op_amp
id|ino
)paren
suffix:semicolon
r_if
c_cond
(paren
id|find_file
c_func
(paren
id|fi_hashval
comma
op_amp
id|ino
comma
op_amp
id|fp
)paren
)paren
(brace
multiline_comment|/* Search for conflicting share reservations */
id|status
op_assign
id|nfserr_share_denied
suffix:semicolon
id|list_for_each_safe
c_func
(paren
id|pos
comma
id|next
comma
op_amp
id|fp-&gt;fi_perfile
)paren
(brace
id|stq
op_assign
id|list_entry
c_func
(paren
id|pos
comma
r_struct
id|nfs4_stateid
comma
id|st_perfile
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stq-&gt;st_stateowner
op_eq
id|sop
)paren
(brace
id|stp
op_assign
id|stq
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|test_share
c_func
(paren
id|stq
comma
id|open
)paren
)paren
r_goto
id|out
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* No nfs4_file found; allocate and init a new one */
id|status
op_assign
id|nfserr_resource
suffix:semicolon
r_if
c_cond
(paren
(paren
id|fp
op_assign
id|alloc_init_file
c_func
(paren
id|fi_hashval
comma
op_amp
id|ino
)paren
)paren
op_eq
l_int|NULL
)paren
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|stp
)paren
(brace
r_int
id|flags
op_assign
l_int|0
suffix:semicolon
id|status
op_assign
id|nfserr_resource
suffix:semicolon
r_if
c_cond
(paren
(paren
id|stp
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|nfs4_stateid
)paren
comma
id|GFP_KERNEL
)paren
)paren
op_eq
l_int|NULL
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|open-&gt;op_share_access
op_logical_and
id|NFS4_SHARE_ACCESS_WRITE
)paren
id|flags
op_assign
id|MAY_WRITE
suffix:semicolon
r_else
id|flags
op_assign
id|MAY_READ
suffix:semicolon
r_if
c_cond
(paren
(paren
id|status
op_assign
id|nfsd_open
c_func
(paren
id|rqstp
comma
id|current_fh
comma
id|S_IFREG
comma
id|flags
comma
op_amp
id|stp-&gt;st_vfs_file
)paren
)paren
op_ne
l_int|0
)paren
r_goto
id|out_free
suffix:semicolon
id|vfsopen
op_increment
suffix:semicolon
id|dget
c_func
(paren
id|stp-&gt;st_vfs_file.f_dentry
)paren
suffix:semicolon
id|mntget
c_func
(paren
id|stp-&gt;st_vfs_file.f_vfsmnt
)paren
suffix:semicolon
id|init_stateid
c_func
(paren
id|stp
comma
id|fp
comma
id|sop
comma
id|open
)paren
suffix:semicolon
id|stp-&gt;st_vfs_set
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* This is an upgrade of an existing OPEN. &n;&t;&t; * OR the incoming share with the existing &n;&t;&t; * nfs4_stateid share */
r_int
id|share_access
op_assign
id|open-&gt;op_share_access
suffix:semicolon
id|share_access
op_and_assign
op_complement
(paren
id|stp-&gt;st_share_access
)paren
suffix:semicolon
multiline_comment|/* update the struct file */
r_if
c_cond
(paren
(paren
id|status
op_assign
id|nfs4_file_upgrade
c_func
(paren
op_amp
id|stp-&gt;st_vfs_file
comma
id|share_access
)paren
)paren
)paren
r_goto
id|out
suffix:semicolon
id|stp-&gt;st_share_access
op_or_assign
id|share_access
suffix:semicolon
id|stp-&gt;st_share_deny
op_or_assign
id|open-&gt;op_share_deny
suffix:semicolon
multiline_comment|/* bump the stateid */
id|update_stateid
c_func
(paren
op_amp
id|stp-&gt;st_stateid
)paren
suffix:semicolon
)brace
id|dprintk
c_func
(paren
l_string|&quot;nfs4_process_open2: stateid=(%08x/%08x/%08x/%08x)&bslash;n&bslash;n&quot;
comma
id|stp-&gt;st_stateid.si_boot
comma
id|stp-&gt;st_stateid.si_stateownerid
comma
id|stp-&gt;st_stateid.si_fileid
comma
id|stp-&gt;st_stateid.si_generation
)paren
suffix:semicolon
r_if
c_cond
(paren
id|open-&gt;op_truncate
)paren
(brace
id|iattr.ia_valid
op_assign
id|ATTR_SIZE
suffix:semicolon
id|iattr.ia_size
op_assign
l_int|0
suffix:semicolon
id|status
op_assign
id|nfsd_setattr
c_func
(paren
id|rqstp
comma
id|current_fh
comma
op_amp
id|iattr
comma
l_int|0
comma
(paren
id|time_t
)paren
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
)paren
r_goto
id|out
suffix:semicolon
)brace
id|memcpy
c_func
(paren
op_amp
id|open-&gt;op_stateid
comma
op_amp
id|stp-&gt;st_stateid
comma
r_sizeof
(paren
id|stateid_t
)paren
)paren
suffix:semicolon
id|open-&gt;op_delegate_type
op_assign
id|NFS4_OPEN_DELEGATE_NONE
suffix:semicolon
id|status
op_assign
id|nfs_ok
suffix:semicolon
id|out
suffix:colon
multiline_comment|/*&n;&t;* To finish the open response, we just need to set the rflags.&n;&t;*/
id|open-&gt;op_rflags
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|open-&gt;op_stateowner-&gt;so_confirmed
)paren
id|open-&gt;op_rflags
op_or_assign
id|NFS4_OPEN_RESULT_CONFIRM
suffix:semicolon
id|up
c_func
(paren
op_amp
id|client_sema
)paren
suffix:semicolon
multiline_comment|/*XXX need finer grained locking */
r_return
id|status
suffix:semicolon
id|out_free
suffix:colon
id|kfree
c_func
(paren
id|stp
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
DECL|variable|laundromat_work
r_static
r_struct
id|work_struct
id|laundromat_work
suffix:semicolon
r_static
r_void
id|laundromat_main
c_func
(paren
r_void
op_star
)paren
suffix:semicolon
r_static
id|DECLARE_WORK
c_func
(paren
id|laundromat_work
comma
id|laundromat_main
comma
l_int|NULL
)paren
suffix:semicolon
r_int
DECL|function|nfsd4_renew
id|nfsd4_renew
c_func
(paren
id|clientid_t
op_star
id|clid
)paren
(brace
r_struct
id|nfs4_client
op_star
id|clp
suffix:semicolon
r_struct
id|list_head
op_star
id|pos
comma
op_star
id|next
suffix:semicolon
r_int
r_int
id|idhashval
suffix:semicolon
r_int
id|status
suffix:semicolon
id|down
c_func
(paren
op_amp
id|client_sema
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;process_renew(%08x/%08x): starting&bslash;n&quot;
comma
id|clid-&gt;cl_boot
comma
id|clid-&gt;cl_id
)paren
suffix:semicolon
id|status
op_assign
id|nfserr_stale_clientid
suffix:semicolon
r_if
c_cond
(paren
id|STALE_CLIENTID
c_func
(paren
id|clid
)paren
)paren
r_goto
id|out
suffix:semicolon
id|status
op_assign
id|nfs_ok
suffix:semicolon
id|idhashval
op_assign
id|clientid_hashval
c_func
(paren
id|clid-&gt;cl_id
)paren
suffix:semicolon
id|list_for_each_safe
c_func
(paren
id|pos
comma
id|next
comma
op_amp
id|conf_id_hashtbl
(braket
id|idhashval
)braket
)paren
(brace
id|clp
op_assign
id|list_entry
c_func
(paren
id|pos
comma
r_struct
id|nfs4_client
comma
id|cl_idhash
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cmp_clid
c_func
(paren
op_amp
id|clp-&gt;cl_clientid
comma
id|clid
)paren
)paren
r_continue
suffix:semicolon
id|renew_client
c_func
(paren
id|clp
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|list_for_each_safe
c_func
(paren
id|pos
comma
id|next
comma
op_amp
id|unconf_id_hashtbl
(braket
id|idhashval
)braket
)paren
(brace
id|clp
op_assign
id|list_entry
c_func
(paren
id|pos
comma
r_struct
id|nfs4_client
comma
id|cl_idhash
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cmp_clid
c_func
(paren
op_amp
id|clp-&gt;cl_clientid
comma
id|clid
)paren
)paren
r_continue
suffix:semicolon
id|renew_client
c_func
(paren
id|clp
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n;&t;* Couldn&squot;t find an nfs4_client for this clientid.  &n;&t;* Presumably this is because the client took too long to &n;&t;* RENEW, so return NFS4ERR_EXPIRED.&n;&t;*/
id|printk
c_func
(paren
l_string|&quot;nfsd4_renew: clientid not found!&bslash;n&quot;
)paren
suffix:semicolon
id|status
op_assign
id|nfserr_expired
suffix:semicolon
id|out
suffix:colon
id|up
c_func
(paren
op_amp
id|client_sema
)paren
suffix:semicolon
r_return
id|status
suffix:semicolon
)brace
id|time_t
DECL|function|nfs4_laundromat
id|nfs4_laundromat
c_func
(paren
r_void
)paren
(brace
r_struct
id|nfs4_client
op_star
id|clp
suffix:semicolon
r_struct
id|list_head
op_star
id|pos
comma
op_star
id|next
suffix:semicolon
id|time_t
id|cutoff
op_assign
id|get_seconds
c_func
(paren
)paren
op_minus
id|NFSD_LEASE_TIME
suffix:semicolon
id|time_t
id|t
comma
id|return_val
op_assign
id|NFSD_LEASE_TIME
suffix:semicolon
id|down
c_func
(paren
op_amp
id|client_sema
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;NFSD: laundromat service - starting, examining clients&bslash;n&quot;
)paren
suffix:semicolon
id|list_for_each_safe
c_func
(paren
id|pos
comma
id|next
comma
op_amp
id|client_lru
)paren
(brace
id|clp
op_assign
id|list_entry
c_func
(paren
id|pos
comma
r_struct
id|nfs4_client
comma
id|cl_lru
)paren
suffix:semicolon
r_if
c_cond
(paren
id|time_after
c_func
(paren
(paren
r_int
r_int
)paren
id|clp-&gt;cl_time
comma
(paren
r_int
r_int
)paren
id|cutoff
)paren
)paren
(brace
id|t
op_assign
id|clp-&gt;cl_time
op_minus
id|cutoff
suffix:semicolon
r_if
c_cond
(paren
id|return_val
OG
id|t
)paren
id|return_val
op_assign
id|t
suffix:semicolon
r_break
suffix:semicolon
)brace
id|dprintk
c_func
(paren
l_string|&quot;NFSD: purging unused client (clientid %08x)&bslash;n&quot;
comma
id|clp-&gt;cl_clientid.cl_id
)paren
suffix:semicolon
id|expire_client
c_func
(paren
id|clp
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|return_val
OL
id|NFSD_LAUNDROMAT_MINTIMEOUT
)paren
id|return_val
op_assign
id|NFSD_LAUNDROMAT_MINTIMEOUT
suffix:semicolon
id|up
c_func
(paren
op_amp
id|client_sema
)paren
suffix:semicolon
r_return
id|return_val
suffix:semicolon
)brace
r_void
DECL|function|laundromat_main
id|laundromat_main
c_func
(paren
r_void
op_star
id|not_used
)paren
(brace
id|time_t
id|t
suffix:semicolon
id|t
op_assign
id|nfs4_laundromat
c_func
(paren
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;NFSD: laundromat_main - sleeping for %ld seconds&bslash;n&quot;
comma
id|t
)paren
suffix:semicolon
id|schedule_delayed_work
c_func
(paren
op_amp
id|laundromat_work
comma
id|t
op_star
id|HZ
)paren
suffix:semicolon
)brace
multiline_comment|/* search openstateid_hashtbl[] for stateid */
r_struct
id|nfs4_stateid
op_star
DECL|function|find_stateid
id|find_stateid
c_func
(paren
id|stateid_t
op_star
id|stid
)paren
(brace
r_struct
id|list_head
op_star
id|pos
comma
op_star
id|next
suffix:semicolon
r_struct
id|nfs4_stateid
op_star
id|local
op_assign
l_int|NULL
suffix:semicolon
id|u32
id|st_id
op_assign
id|stid-&gt;si_stateownerid
suffix:semicolon
id|u32
id|f_id
op_assign
id|stid-&gt;si_fileid
suffix:semicolon
r_int
r_int
id|hashval
op_assign
id|openstateid_hashval
c_func
(paren
id|st_id
comma
id|f_id
)paren
suffix:semicolon
id|list_for_each_safe
c_func
(paren
id|pos
comma
id|next
comma
op_amp
id|openstateid_hashtbl
(braket
id|hashval
)braket
)paren
(brace
id|local
op_assign
id|list_entry
c_func
(paren
id|pos
comma
r_struct
id|nfs4_stateid
comma
id|st_hash
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|local-&gt;st_stateid.si_stateownerid
op_eq
id|st_id
)paren
op_logical_and
(paren
id|local-&gt;st_stateid.si_fileid
op_eq
id|f_id
)paren
)paren
(brace
r_return
id|local
suffix:semicolon
)brace
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* search ownerid_hashtbl[] for stateid owner (stateid-&gt;si_stateownerid) */
r_struct
id|nfs4_stateowner
op_star
DECL|function|find_stateowner_id
id|find_stateowner_id
c_func
(paren
id|u32
id|st_id
)paren
(brace
r_struct
id|list_head
op_star
id|pos
comma
op_star
id|next
suffix:semicolon
r_struct
id|nfs4_stateowner
op_star
id|local
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|hashval
op_assign
id|ownerid_hashval
c_func
(paren
id|st_id
)paren
suffix:semicolon
id|list_for_each_safe
c_func
(paren
id|pos
comma
id|next
comma
op_amp
id|ownerid_hashtbl
(braket
id|hashval
)braket
)paren
(brace
id|local
op_assign
id|list_entry
c_func
(paren
id|pos
comma
r_struct
id|nfs4_stateowner
comma
id|so_idhash
)paren
suffix:semicolon
r_if
c_cond
(paren
id|local-&gt;so_id
op_eq
id|st_id
)paren
(brace
r_return
id|local
suffix:semicolon
)brace
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
r_static
r_inline
r_int
DECL|function|nfs4_check_fh
id|nfs4_check_fh
c_func
(paren
r_struct
id|svc_fh
op_star
id|fhp
comma
r_struct
id|nfs4_stateid
op_star
id|stp
)paren
(brace
r_return
(paren
id|fhp-&gt;fh_dentry
op_ne
id|stp-&gt;st_vfs_file.f_dentry
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|STALE_STATEID
id|STALE_STATEID
c_func
(paren
id|stateid_t
op_star
id|stateid
)paren
(brace
r_if
c_cond
(paren
id|stateid-&gt;si_boot
op_eq
id|boot_time
)paren
r_return
l_int|0
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;NFSD: stale stateid (%08x/%08x/%08x/%08x)!&bslash;n&quot;
comma
id|stateid-&gt;si_boot
comma
id|stateid-&gt;si_stateownerid
comma
id|stateid-&gt;si_fileid
comma
id|stateid-&gt;si_generation
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* &n; * Checks for sequence id mutating operations. &n; *&n; * XXX need to code replay cache logic&n; */
r_int
DECL|function|nfs4_preprocess_seqid_op
id|nfs4_preprocess_seqid_op
c_func
(paren
r_struct
id|svc_fh
op_star
id|current_fh
comma
id|u32
id|seqid
comma
id|stateid_t
op_star
id|stateid
comma
r_int
id|flags
comma
r_struct
id|nfs4_stateowner
op_star
op_star
id|sopp
comma
r_struct
id|nfs4_stateid
op_star
op_star
id|stpp
)paren
(brace
r_int
id|status
suffix:semicolon
r_struct
id|nfs4_stateid
op_star
id|stp
suffix:semicolon
r_struct
id|nfs4_stateowner
op_star
id|sop
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;NFSD: preprocess_seqid_op: seqid=%d &quot;
l_string|&quot;stateid = (%08x/%08x/%08x/%08x)&bslash;n&quot;
comma
id|seqid
comma
id|stateid-&gt;si_boot
comma
id|stateid-&gt;si_stateownerid
comma
id|stateid-&gt;si_fileid
comma
id|stateid-&gt;si_generation
)paren
suffix:semicolon
op_star
id|stpp
op_assign
l_int|NULL
suffix:semicolon
op_star
id|sopp
op_assign
l_int|NULL
suffix:semicolon
id|status
op_assign
id|nfserr_bad_stateid
suffix:semicolon
r_if
c_cond
(paren
id|ZERO_STATEID
c_func
(paren
id|stateid
)paren
op_logical_or
id|ONE_STATEID
c_func
(paren
id|stateid
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;NFSD: preprocess_seqid_op: magic stateid!&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|status
op_assign
id|nfserr_stale_stateid
suffix:semicolon
r_if
c_cond
(paren
id|STALE_STATEID
c_func
(paren
id|stateid
)paren
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/*&n;&t;* We return BAD_STATEID if filehandle doesn&squot;t match stateid, &n;&t;* the confirmed flag is incorrecly set, or the generation &n;&t;* number is incorrect.  &n;&t;* If there is no entry in the openfile table for this id, &n;&t;* we can&squot;t always return BAD_STATEID;&n;&t;* this might be a retransmitted CLOSE which has arrived after &n;&t;* the openfile has been released.&n;&t;*/
r_if
c_cond
(paren
op_logical_neg
(paren
id|stp
op_assign
id|find_stateid
c_func
(paren
id|stateid
)paren
)paren
)paren
r_goto
id|no_nfs4_stateid
suffix:semicolon
id|status
op_assign
id|nfserr_bad_stateid
suffix:semicolon
r_if
c_cond
(paren
(paren
id|flags
op_amp
id|CHECK_FH
)paren
op_logical_and
id|nfs4_check_fh
c_func
(paren
id|current_fh
comma
id|stp
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;NFSD: preprocess_seqid_op: fh-stateid mismatch!&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
op_star
id|stpp
op_assign
id|stp
suffix:semicolon
op_star
id|sopp
op_assign
id|sop
op_assign
id|stp-&gt;st_stateowner
suffix:semicolon
multiline_comment|/*&n;&t;*  We now validate the seqid and stateid generation numbers.&n;&t;*  For the moment, we ignore the possibility of &n;&t;*  generation number wraparound.&n;&t;*/
r_if
c_cond
(paren
id|seqid
op_ne
id|sop-&gt;so_seqid
op_plus
l_int|1
)paren
r_goto
id|check_replay
suffix:semicolon
r_if
c_cond
(paren
id|sop-&gt;so_confirmed
)paren
(brace
r_if
c_cond
(paren
id|flags
op_amp
id|CONFIRM
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;NFSD: preprocess_seqid_op: expected unconfirmed stateowner!&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|flags
op_amp
id|CONFIRM
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;NFSD: preprocess_seqid_op: stateowner not confirmed yet!&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|stateid-&gt;si_generation
OG
id|stp-&gt;st_stateid.si_generation
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;NFSD: preprocess_seqid_op: future stateid?!&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|status
op_assign
id|nfserr_old_stateid
suffix:semicolon
r_if
c_cond
(paren
id|stateid-&gt;si_generation
OL
id|stp-&gt;st_stateid.si_generation
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;NFSD: preprocess_seqid_op: old stateid!&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* XXX renew the client lease here */
id|status
op_assign
id|nfs_ok
suffix:semicolon
id|out
suffix:colon
r_return
id|status
suffix:semicolon
id|no_nfs4_stateid
suffix:colon
multiline_comment|/*&n;&t;* We determine whether this is a bad stateid or a replay, &n;&t;* starting by trying to look up the stateowner.&n;&t;* If stateowner is not found - stateid is bad.&n;&t;*/
r_if
c_cond
(paren
op_logical_neg
(paren
id|sop
op_assign
id|find_stateowner_id
c_func
(paren
id|stateid-&gt;si_stateownerid
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;NFSD: preprocess_seqid_op: no stateowner or nfs4_stateid!&bslash;n&quot;
)paren
suffix:semicolon
id|status
op_assign
id|nfserr_bad_stateid
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|check_replay
suffix:colon
id|status
op_assign
id|nfserr_bad_seqid
suffix:semicolon
r_if
c_cond
(paren
id|seqid
op_eq
id|sop-&gt;so_seqid
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;NFSD: preprocess_seqid_op: retransmission?&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* XXX will need to indicate replay to calling function here */
)brace
r_else
id|printk
c_func
(paren
l_string|&quot;NFSD: preprocess_seqid_op: bad seqid (expected %d, got %d&bslash;n&quot;
comma
id|sop-&gt;so_seqid
op_plus
l_int|1
comma
id|seqid
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_int
DECL|function|nfsd4_open_confirm
id|nfsd4_open_confirm
c_func
(paren
r_struct
id|svc_rqst
op_star
id|rqstp
comma
r_struct
id|svc_fh
op_star
id|current_fh
comma
r_struct
id|nfsd4_open_confirm
op_star
id|oc
)paren
(brace
r_int
id|status
suffix:semicolon
r_struct
id|nfs4_stateowner
op_star
id|sop
suffix:semicolon
r_struct
id|nfs4_stateid
op_star
id|stp
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;NFSD: nfsd4_open_confirm on file %s&bslash;n&quot;
comma
id|current_fh-&gt;fh_dentry-&gt;d_name
)paren
suffix:semicolon
id|oc-&gt;oc_stateowner
op_assign
l_int|NULL
suffix:semicolon
id|down
c_func
(paren
op_amp
id|client_sema
)paren
suffix:semicolon
multiline_comment|/* XXX need finer grained locking */
r_if
c_cond
(paren
(paren
id|status
op_assign
id|nfs4_preprocess_seqid_op
c_func
(paren
id|current_fh
comma
id|oc-&gt;oc_seqid
comma
op_amp
id|oc-&gt;oc_req_stateid
comma
id|CHECK_FH
op_or
id|CONFIRM
comma
op_amp
id|oc-&gt;oc_stateowner
comma
op_amp
id|stp
)paren
)paren
)paren
r_goto
id|out
suffix:semicolon
id|sop
op_assign
id|oc-&gt;oc_stateowner
suffix:semicolon
id|sop-&gt;so_confirmed
op_assign
l_int|1
suffix:semicolon
id|update_stateid
c_func
(paren
op_amp
id|stp-&gt;st_stateid
)paren
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|oc-&gt;oc_resp_stateid
comma
op_amp
id|stp-&gt;st_stateid
comma
r_sizeof
(paren
id|stateid_t
)paren
)paren
suffix:semicolon
multiline_comment|/* XXX renew the client lease here */
id|dprintk
c_func
(paren
l_string|&quot;NFSD: nfsd4_open_confirm: success, seqid=%d &quot;
l_string|&quot;stateid=(%08x/%08x/%08x/%08x)&bslash;n&quot;
comma
id|oc-&gt;oc_seqid
comma
id|stp-&gt;st_stateid.si_boot
comma
id|stp-&gt;st_stateid.si_stateownerid
comma
id|stp-&gt;st_stateid.si_fileid
comma
id|stp-&gt;st_stateid.si_generation
)paren
suffix:semicolon
id|status
op_assign
id|nfs_ok
suffix:semicolon
id|out
suffix:colon
id|up
c_func
(paren
op_amp
id|client_sema
)paren
suffix:semicolon
r_return
id|status
suffix:semicolon
)brace
r_int
DECL|function|nfsd4_close
id|nfsd4_close
c_func
(paren
r_struct
id|svc_rqst
op_star
id|rqstp
comma
r_struct
id|svc_fh
op_star
id|current_fh
comma
r_struct
id|nfsd4_close
op_star
id|close
)paren
(brace
r_int
id|status
suffix:semicolon
r_struct
id|nfs4_stateid
op_star
id|stp
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;NFSD: nfsd4_close on file %.*s&bslash;n&quot;
comma
id|current_fh-&gt;fh_dentry-&gt;d_name.len
comma
id|current_fh-&gt;fh_dentry-&gt;d_name.name
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|client_sema
)paren
suffix:semicolon
multiline_comment|/* XXX need finer grained locking */
r_if
c_cond
(paren
(paren
id|status
op_assign
id|nfs4_preprocess_seqid_op
c_func
(paren
id|current_fh
comma
id|close-&gt;cl_seqid
comma
op_amp
id|close-&gt;cl_stateid
comma
id|CHECK_FH
comma
op_amp
id|close-&gt;cl_stateowner
comma
op_amp
id|stp
)paren
)paren
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/*&n;&t;*  Return success, but first update the stateid.&n;&t;*/
id|status
op_assign
id|nfs_ok
suffix:semicolon
id|update_stateid
c_func
(paren
op_amp
id|stp-&gt;st_stateid
)paren
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|close-&gt;cl_stateid
comma
op_amp
id|stp-&gt;st_stateid
comma
r_sizeof
(paren
id|stateid_t
)paren
)paren
suffix:semicolon
multiline_comment|/* release_open_state() calls nfsd_close() if needed */
id|release_open_state
c_func
(paren
id|stp
)paren
suffix:semicolon
id|out
suffix:colon
id|up
c_func
(paren
op_amp
id|client_sema
)paren
suffix:semicolon
r_return
id|status
suffix:semicolon
)brace
r_void
DECL|function|nfs4_state_init
id|nfs4_state_init
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|nfs4_init
)paren
r_return
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|CLIENT_HASH_SIZE
suffix:semicolon
id|i
op_increment
)paren
(brace
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|conf_id_hashtbl
(braket
id|i
)braket
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|conf_str_hashtbl
(braket
id|i
)braket
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|unconf_str_hashtbl
(braket
id|i
)braket
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|unconf_id_hashtbl
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|FILE_HASH_SIZE
suffix:semicolon
id|i
op_increment
)paren
(brace
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|file_hashtbl
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|OWNER_HASH_SIZE
suffix:semicolon
id|i
op_increment
)paren
(brace
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|ownerstr_hashtbl
(braket
id|i
)braket
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|ownerid_hashtbl
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|OPENSTATEID_HASH_SIZE
suffix:semicolon
id|i
op_increment
)paren
(brace
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|openstateid_hashtbl
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|memset
c_func
(paren
op_amp
id|zerostateid
comma
l_int|0
comma
r_sizeof
(paren
id|stateid_t
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|onestateid
comma
op_complement
l_int|0
comma
r_sizeof
(paren
id|stateid_t
)paren
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|client_lru
)paren
suffix:semicolon
id|init_MUTEX
c_func
(paren
op_amp
id|client_sema
)paren
suffix:semicolon
id|boot_time
op_assign
id|get_seconds
c_func
(paren
)paren
suffix:semicolon
id|INIT_WORK
c_func
(paren
op_amp
id|laundromat_work
comma
id|laundromat_main
comma
l_int|NULL
)paren
suffix:semicolon
id|schedule_delayed_work
c_func
(paren
op_amp
id|laundromat_work
comma
id|NFSD_LEASE_TIME
op_star
id|HZ
)paren
suffix:semicolon
id|nfs4_init
op_assign
l_int|1
suffix:semicolon
)brace
r_static
r_void
DECL|function|__nfs4_state_shutdown
id|__nfs4_state_shutdown
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|nfs4_client
op_star
id|clp
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|CLIENT_HASH_SIZE
suffix:semicolon
id|i
op_increment
)paren
(brace
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|conf_id_hashtbl
(braket
id|i
)braket
)paren
)paren
(brace
id|clp
op_assign
id|list_entry
c_func
(paren
id|conf_id_hashtbl
(braket
id|i
)braket
dot
id|next
comma
r_struct
id|nfs4_client
comma
id|cl_idhash
)paren
suffix:semicolon
id|expire_client
c_func
(paren
id|clp
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|unconf_str_hashtbl
(braket
id|i
)braket
)paren
)paren
(brace
id|clp
op_assign
id|list_entry
c_func
(paren
id|unconf_str_hashtbl
(braket
id|i
)braket
dot
id|next
comma
r_struct
id|nfs4_client
comma
id|cl_strhash
)paren
suffix:semicolon
id|expire_client
c_func
(paren
id|clp
)paren
suffix:semicolon
)brace
)brace
id|release_all_files
c_func
(paren
)paren
suffix:semicolon
id|cancel_delayed_work
c_func
(paren
op_amp
id|laundromat_work
)paren
suffix:semicolon
id|flush_scheduled_work
c_func
(paren
)paren
suffix:semicolon
id|nfs4_init
op_assign
l_int|0
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;NFSD: list_add_perfile %d list_del_perfile %d&bslash;n&quot;
comma
id|list_add_perfile
comma
id|list_del_perfile
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;NFSD: add_perclient %d del_perclient %d&bslash;n&quot;
comma
id|add_perclient
comma
id|del_perclient
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;NFSD: alloc_file %d free_file %d&bslash;n&quot;
comma
id|alloc_file
comma
id|free_file
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;NFSD: alloc_sowner %d free_sowner %d&bslash;n&quot;
comma
id|alloc_sowner
comma
id|free_sowner
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;NFSD: vfsopen %d vfsclose %d&bslash;n&quot;
comma
id|vfsopen
comma
id|vfsclose
)paren
suffix:semicolon
)brace
r_void
DECL|function|nfs4_state_shutdown
id|nfs4_state_shutdown
c_func
(paren
r_void
)paren
(brace
id|down
c_func
(paren
op_amp
id|client_sema
)paren
suffix:semicolon
id|__nfs4_state_shutdown
c_func
(paren
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|client_sema
)paren
suffix:semicolon
)brace
eof
