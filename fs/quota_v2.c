multiline_comment|/*&n; *&t;vfsv0 quota IO operations on file&n; */
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/mount.h&gt;
macro_line|#include &lt;linux/dqblk_v2.h&gt;
macro_line|#include &lt;linux/quotaio_v2.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;asm/byteorder.h&gt;
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Jan Kara&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;Quota format v2 support&quot;
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
DECL|macro|__QUOTA_V2_PARANOIA
mdefine_line|#define __QUOTA_V2_PARANOIA
DECL|typedef|dqbuf_t
r_typedef
r_char
op_star
id|dqbuf_t
suffix:semicolon
DECL|macro|GETIDINDEX
mdefine_line|#define GETIDINDEX(id, depth) (((id) &gt;&gt; ((V2_DQTREEDEPTH-(depth)-1)*8)) &amp; 0xff)
DECL|macro|GETENTRIES
mdefine_line|#define GETENTRIES(buf) ((struct v2_disk_dqblk *)(((char *)buf)+sizeof(struct v2_disk_dqdbheader)))
multiline_comment|/* Check whether given file is really vfsv0 quotafile */
DECL|function|v2_check_quota_file
r_static
r_int
id|v2_check_quota_file
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_int
id|type
)paren
(brace
r_struct
id|v2_disk_dqheader
id|dqhead
suffix:semicolon
id|ssize_t
id|size
suffix:semicolon
r_static
r_const
id|uint
id|quota_magics
(braket
)braket
op_assign
id|V2_INITQMAGICS
suffix:semicolon
r_static
r_const
id|uint
id|quota_versions
(braket
)braket
op_assign
id|V2_INITQVERSIONS
suffix:semicolon
id|size
op_assign
id|sb-&gt;s_op
op_member_access_from_pointer
id|quota_read
c_func
(paren
id|sb
comma
id|type
comma
(paren
r_char
op_star
)paren
op_amp
id|dqhead
comma
r_sizeof
(paren
r_struct
id|v2_disk_dqheader
)paren
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|size
op_ne
r_sizeof
(paren
r_struct
id|v2_disk_dqheader
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;failed read&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|le32_to_cpu
c_func
(paren
id|dqhead.dqh_magic
)paren
op_ne
id|quota_magics
(braket
id|type
)braket
op_logical_or
id|le32_to_cpu
c_func
(paren
id|dqhead.dqh_version
)paren
op_ne
id|quota_versions
(braket
id|type
)braket
)paren
r_return
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Read information header from quota file */
DECL|function|v2_read_file_info
r_static
r_int
id|v2_read_file_info
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_int
id|type
)paren
(brace
r_struct
id|v2_disk_dqinfo
id|dinfo
suffix:semicolon
r_struct
id|mem_dqinfo
op_star
id|info
op_assign
id|sb_dqopt
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|info
op_plus
id|type
suffix:semicolon
id|ssize_t
id|size
suffix:semicolon
id|size
op_assign
id|sb-&gt;s_op
op_member_access_from_pointer
id|quota_read
c_func
(paren
id|sb
comma
id|type
comma
(paren
r_char
op_star
)paren
op_amp
id|dinfo
comma
r_sizeof
(paren
r_struct
id|v2_disk_dqinfo
)paren
comma
id|V2_DQINFOOFF
)paren
suffix:semicolon
r_if
c_cond
(paren
id|size
op_ne
r_sizeof
(paren
r_struct
id|v2_disk_dqinfo
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Can&squot;t read info structure on device %s.&bslash;n&quot;
comma
id|sb-&gt;s_id
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|info-&gt;dqi_bgrace
op_assign
id|le32_to_cpu
c_func
(paren
id|dinfo.dqi_bgrace
)paren
suffix:semicolon
id|info-&gt;dqi_igrace
op_assign
id|le32_to_cpu
c_func
(paren
id|dinfo.dqi_igrace
)paren
suffix:semicolon
id|info-&gt;dqi_flags
op_assign
id|le32_to_cpu
c_func
(paren
id|dinfo.dqi_flags
)paren
suffix:semicolon
id|info-&gt;u.v2_i.dqi_blocks
op_assign
id|le32_to_cpu
c_func
(paren
id|dinfo.dqi_blocks
)paren
suffix:semicolon
id|info-&gt;u.v2_i.dqi_free_blk
op_assign
id|le32_to_cpu
c_func
(paren
id|dinfo.dqi_free_blk
)paren
suffix:semicolon
id|info-&gt;u.v2_i.dqi_free_entry
op_assign
id|le32_to_cpu
c_func
(paren
id|dinfo.dqi_free_entry
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Write information header to quota file */
DECL|function|v2_write_file_info
r_static
r_int
id|v2_write_file_info
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_int
id|type
)paren
(brace
r_struct
id|v2_disk_dqinfo
id|dinfo
suffix:semicolon
r_struct
id|mem_dqinfo
op_star
id|info
op_assign
id|sb_dqopt
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|info
op_plus
id|type
suffix:semicolon
id|ssize_t
id|size
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|dq_data_lock
)paren
suffix:semicolon
id|info-&gt;dqi_flags
op_and_assign
op_complement
id|DQF_INFO_DIRTY
suffix:semicolon
id|dinfo.dqi_bgrace
op_assign
id|cpu_to_le32
c_func
(paren
id|info-&gt;dqi_bgrace
)paren
suffix:semicolon
id|dinfo.dqi_igrace
op_assign
id|cpu_to_le32
c_func
(paren
id|info-&gt;dqi_igrace
)paren
suffix:semicolon
id|dinfo.dqi_flags
op_assign
id|cpu_to_le32
c_func
(paren
id|info-&gt;dqi_flags
op_amp
id|DQF_MASK
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|dq_data_lock
)paren
suffix:semicolon
id|dinfo.dqi_blocks
op_assign
id|cpu_to_le32
c_func
(paren
id|info-&gt;u.v2_i.dqi_blocks
)paren
suffix:semicolon
id|dinfo.dqi_free_blk
op_assign
id|cpu_to_le32
c_func
(paren
id|info-&gt;u.v2_i.dqi_free_blk
)paren
suffix:semicolon
id|dinfo.dqi_free_entry
op_assign
id|cpu_to_le32
c_func
(paren
id|info-&gt;u.v2_i.dqi_free_entry
)paren
suffix:semicolon
id|size
op_assign
id|sb-&gt;s_op
op_member_access_from_pointer
id|quota_write
c_func
(paren
id|sb
comma
id|type
comma
(paren
r_char
op_star
)paren
op_amp
id|dinfo
comma
r_sizeof
(paren
r_struct
id|v2_disk_dqinfo
)paren
comma
id|V2_DQINFOOFF
)paren
suffix:semicolon
r_if
c_cond
(paren
id|size
op_ne
r_sizeof
(paren
r_struct
id|v2_disk_dqinfo
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Can&squot;t write info structure on device %s.&bslash;n&quot;
comma
id|sb-&gt;s_id
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|disk2memdqb
r_static
r_void
id|disk2memdqb
c_func
(paren
r_struct
id|mem_dqblk
op_star
id|m
comma
r_struct
id|v2_disk_dqblk
op_star
id|d
)paren
(brace
id|m-&gt;dqb_ihardlimit
op_assign
id|le32_to_cpu
c_func
(paren
id|d-&gt;dqb_ihardlimit
)paren
suffix:semicolon
id|m-&gt;dqb_isoftlimit
op_assign
id|le32_to_cpu
c_func
(paren
id|d-&gt;dqb_isoftlimit
)paren
suffix:semicolon
id|m-&gt;dqb_curinodes
op_assign
id|le32_to_cpu
c_func
(paren
id|d-&gt;dqb_curinodes
)paren
suffix:semicolon
id|m-&gt;dqb_itime
op_assign
id|le64_to_cpu
c_func
(paren
id|d-&gt;dqb_itime
)paren
suffix:semicolon
id|m-&gt;dqb_bhardlimit
op_assign
id|le32_to_cpu
c_func
(paren
id|d-&gt;dqb_bhardlimit
)paren
suffix:semicolon
id|m-&gt;dqb_bsoftlimit
op_assign
id|le32_to_cpu
c_func
(paren
id|d-&gt;dqb_bsoftlimit
)paren
suffix:semicolon
id|m-&gt;dqb_curspace
op_assign
id|le64_to_cpu
c_func
(paren
id|d-&gt;dqb_curspace
)paren
suffix:semicolon
id|m-&gt;dqb_btime
op_assign
id|le64_to_cpu
c_func
(paren
id|d-&gt;dqb_btime
)paren
suffix:semicolon
)brace
DECL|function|mem2diskdqb
r_static
r_void
id|mem2diskdqb
c_func
(paren
r_struct
id|v2_disk_dqblk
op_star
id|d
comma
r_struct
id|mem_dqblk
op_star
id|m
comma
id|qid_t
id|id
)paren
(brace
id|d-&gt;dqb_ihardlimit
op_assign
id|cpu_to_le32
c_func
(paren
id|m-&gt;dqb_ihardlimit
)paren
suffix:semicolon
id|d-&gt;dqb_isoftlimit
op_assign
id|cpu_to_le32
c_func
(paren
id|m-&gt;dqb_isoftlimit
)paren
suffix:semicolon
id|d-&gt;dqb_curinodes
op_assign
id|cpu_to_le32
c_func
(paren
id|m-&gt;dqb_curinodes
)paren
suffix:semicolon
id|d-&gt;dqb_itime
op_assign
id|cpu_to_le64
c_func
(paren
id|m-&gt;dqb_itime
)paren
suffix:semicolon
id|d-&gt;dqb_bhardlimit
op_assign
id|cpu_to_le32
c_func
(paren
id|m-&gt;dqb_bhardlimit
)paren
suffix:semicolon
id|d-&gt;dqb_bsoftlimit
op_assign
id|cpu_to_le32
c_func
(paren
id|m-&gt;dqb_bsoftlimit
)paren
suffix:semicolon
id|d-&gt;dqb_curspace
op_assign
id|cpu_to_le64
c_func
(paren
id|m-&gt;dqb_curspace
)paren
suffix:semicolon
id|d-&gt;dqb_btime
op_assign
id|cpu_to_le64
c_func
(paren
id|m-&gt;dqb_btime
)paren
suffix:semicolon
id|d-&gt;dqb_id
op_assign
id|cpu_to_le32
c_func
(paren
id|id
)paren
suffix:semicolon
)brace
DECL|function|getdqbuf
r_static
id|dqbuf_t
id|getdqbuf
c_func
(paren
r_void
)paren
(brace
id|dqbuf_t
id|buf
op_assign
id|kmalloc
c_func
(paren
id|V2_DQBLKSIZE
comma
id|GFP_NOFS
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buf
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;VFS: Not enough memory for quota buffers.&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|buf
suffix:semicolon
)brace
DECL|function|freedqbuf
r_static
r_inline
r_void
id|freedqbuf
c_func
(paren
id|dqbuf_t
id|buf
)paren
(brace
id|kfree
c_func
(paren
id|buf
)paren
suffix:semicolon
)brace
DECL|function|read_blk
r_static
r_inline
id|ssize_t
id|read_blk
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_int
id|type
comma
id|uint
id|blk
comma
id|dqbuf_t
id|buf
)paren
(brace
id|memset
c_func
(paren
id|buf
comma
l_int|0
comma
id|V2_DQBLKSIZE
)paren
suffix:semicolon
r_return
id|sb-&gt;s_op
op_member_access_from_pointer
id|quota_read
c_func
(paren
id|sb
comma
id|type
comma
(paren
r_char
op_star
)paren
id|buf
comma
id|V2_DQBLKSIZE
comma
id|blk
op_lshift
id|V2_DQBLKSIZE_BITS
)paren
suffix:semicolon
)brace
DECL|function|write_blk
r_static
r_inline
id|ssize_t
id|write_blk
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_int
id|type
comma
id|uint
id|blk
comma
id|dqbuf_t
id|buf
)paren
(brace
r_return
id|sb-&gt;s_op
op_member_access_from_pointer
id|quota_write
c_func
(paren
id|sb
comma
id|type
comma
(paren
r_char
op_star
)paren
id|buf
comma
id|V2_DQBLKSIZE
comma
id|blk
op_lshift
id|V2_DQBLKSIZE_BITS
)paren
suffix:semicolon
)brace
multiline_comment|/* Remove empty block from list and return it */
DECL|function|get_free_dqblk
r_static
r_int
id|get_free_dqblk
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_int
id|type
)paren
(brace
id|dqbuf_t
id|buf
op_assign
id|getdqbuf
c_func
(paren
)paren
suffix:semicolon
r_struct
id|mem_dqinfo
op_star
id|info
op_assign
id|sb_dqinfo
c_func
(paren
id|sb
comma
id|type
)paren
suffix:semicolon
r_struct
id|v2_disk_dqdbheader
op_star
id|dh
op_assign
(paren
r_struct
id|v2_disk_dqdbheader
op_star
)paren
id|buf
suffix:semicolon
r_int
id|ret
comma
id|blk
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buf
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;u.v2_i.dqi_free_blk
)paren
(brace
id|blk
op_assign
id|info-&gt;u.v2_i.dqi_free_blk
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|read_blk
c_func
(paren
id|sb
comma
id|type
comma
id|blk
comma
id|buf
)paren
)paren
OL
l_int|0
)paren
r_goto
id|out_buf
suffix:semicolon
id|info-&gt;u.v2_i.dqi_free_blk
op_assign
id|le32_to_cpu
c_func
(paren
id|dh-&gt;dqdh_next_free
)paren
suffix:semicolon
)brace
r_else
(brace
id|memset
c_func
(paren
id|buf
comma
l_int|0
comma
id|V2_DQBLKSIZE
)paren
suffix:semicolon
multiline_comment|/* Assure block allocation... */
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|write_blk
c_func
(paren
id|sb
comma
id|type
comma
id|info-&gt;u.v2_i.dqi_blocks
comma
id|buf
)paren
)paren
OL
l_int|0
)paren
r_goto
id|out_buf
suffix:semicolon
id|blk
op_assign
id|info-&gt;u.v2_i.dqi_blocks
op_increment
suffix:semicolon
)brace
id|mark_info_dirty
c_func
(paren
id|sb
comma
id|type
)paren
suffix:semicolon
id|ret
op_assign
id|blk
suffix:semicolon
id|out_buf
suffix:colon
id|freedqbuf
c_func
(paren
id|buf
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* Insert empty block to the list */
DECL|function|put_free_dqblk
r_static
r_int
id|put_free_dqblk
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_int
id|type
comma
id|dqbuf_t
id|buf
comma
id|uint
id|blk
)paren
(brace
r_struct
id|mem_dqinfo
op_star
id|info
op_assign
id|sb_dqinfo
c_func
(paren
id|sb
comma
id|type
)paren
suffix:semicolon
r_struct
id|v2_disk_dqdbheader
op_star
id|dh
op_assign
(paren
r_struct
id|v2_disk_dqdbheader
op_star
)paren
id|buf
suffix:semicolon
r_int
id|err
suffix:semicolon
id|dh-&gt;dqdh_next_free
op_assign
id|cpu_to_le32
c_func
(paren
id|info-&gt;u.v2_i.dqi_free_blk
)paren
suffix:semicolon
id|dh-&gt;dqdh_prev_free
op_assign
id|cpu_to_le32
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|dh-&gt;dqdh_entries
op_assign
id|cpu_to_le16
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|info-&gt;u.v2_i.dqi_free_blk
op_assign
id|blk
suffix:semicolon
id|mark_info_dirty
c_func
(paren
id|sb
comma
id|type
)paren
suffix:semicolon
multiline_comment|/* Some strange block. We had better leave it... */
r_if
c_cond
(paren
(paren
id|err
op_assign
id|write_blk
c_func
(paren
id|sb
comma
id|type
comma
id|blk
comma
id|buf
)paren
)paren
OL
l_int|0
)paren
r_return
id|err
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Remove given block from the list of blocks with free entries */
DECL|function|remove_free_dqentry
r_static
r_int
id|remove_free_dqentry
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_int
id|type
comma
id|dqbuf_t
id|buf
comma
id|uint
id|blk
)paren
(brace
id|dqbuf_t
id|tmpbuf
op_assign
id|getdqbuf
c_func
(paren
)paren
suffix:semicolon
r_struct
id|mem_dqinfo
op_star
id|info
op_assign
id|sb_dqinfo
c_func
(paren
id|sb
comma
id|type
)paren
suffix:semicolon
r_struct
id|v2_disk_dqdbheader
op_star
id|dh
op_assign
(paren
r_struct
id|v2_disk_dqdbheader
op_star
)paren
id|buf
suffix:semicolon
id|uint
id|nextblk
op_assign
id|le32_to_cpu
c_func
(paren
id|dh-&gt;dqdh_next_free
)paren
comma
id|prevblk
op_assign
id|le32_to_cpu
c_func
(paren
id|dh-&gt;dqdh_prev_free
)paren
suffix:semicolon
r_int
id|err
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tmpbuf
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
id|nextblk
)paren
(brace
r_if
c_cond
(paren
(paren
id|err
op_assign
id|read_blk
c_func
(paren
id|sb
comma
id|type
comma
id|nextblk
comma
id|tmpbuf
)paren
)paren
OL
l_int|0
)paren
r_goto
id|out_buf
suffix:semicolon
(paren
(paren
r_struct
id|v2_disk_dqdbheader
op_star
)paren
id|tmpbuf
)paren
op_member_access_from_pointer
id|dqdh_prev_free
op_assign
id|dh-&gt;dqdh_prev_free
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|write_blk
c_func
(paren
id|sb
comma
id|type
comma
id|nextblk
comma
id|tmpbuf
)paren
)paren
OL
l_int|0
)paren
r_goto
id|out_buf
suffix:semicolon
)brace
r_if
c_cond
(paren
id|prevblk
)paren
(brace
r_if
c_cond
(paren
(paren
id|err
op_assign
id|read_blk
c_func
(paren
id|sb
comma
id|type
comma
id|prevblk
comma
id|tmpbuf
)paren
)paren
OL
l_int|0
)paren
r_goto
id|out_buf
suffix:semicolon
(paren
(paren
r_struct
id|v2_disk_dqdbheader
op_star
)paren
id|tmpbuf
)paren
op_member_access_from_pointer
id|dqdh_next_free
op_assign
id|dh-&gt;dqdh_next_free
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|write_blk
c_func
(paren
id|sb
comma
id|type
comma
id|prevblk
comma
id|tmpbuf
)paren
)paren
OL
l_int|0
)paren
r_goto
id|out_buf
suffix:semicolon
)brace
r_else
(brace
id|info-&gt;u.v2_i.dqi_free_entry
op_assign
id|nextblk
suffix:semicolon
id|mark_info_dirty
c_func
(paren
id|sb
comma
id|type
)paren
suffix:semicolon
)brace
id|freedqbuf
c_func
(paren
id|tmpbuf
)paren
suffix:semicolon
id|dh-&gt;dqdh_next_free
op_assign
id|dh-&gt;dqdh_prev_free
op_assign
id|cpu_to_le32
c_func
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* No matter whether write succeeds block is out of list */
r_if
c_cond
(paren
id|write_blk
c_func
(paren
id|sb
comma
id|type
comma
id|blk
comma
id|buf
)paren
OL
l_int|0
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;VFS: Can&squot;t write block (%u) with free entries.&bslash;n&quot;
comma
id|blk
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|out_buf
suffix:colon
id|freedqbuf
c_func
(paren
id|tmpbuf
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/* Insert given block to the beginning of list with free entries */
DECL|function|insert_free_dqentry
r_static
r_int
id|insert_free_dqentry
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_int
id|type
comma
id|dqbuf_t
id|buf
comma
id|uint
id|blk
)paren
(brace
id|dqbuf_t
id|tmpbuf
op_assign
id|getdqbuf
c_func
(paren
)paren
suffix:semicolon
r_struct
id|mem_dqinfo
op_star
id|info
op_assign
id|sb_dqinfo
c_func
(paren
id|sb
comma
id|type
)paren
suffix:semicolon
r_struct
id|v2_disk_dqdbheader
op_star
id|dh
op_assign
(paren
r_struct
id|v2_disk_dqdbheader
op_star
)paren
id|buf
suffix:semicolon
r_int
id|err
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tmpbuf
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|dh-&gt;dqdh_next_free
op_assign
id|cpu_to_le32
c_func
(paren
id|info-&gt;u.v2_i.dqi_free_entry
)paren
suffix:semicolon
id|dh-&gt;dqdh_prev_free
op_assign
id|cpu_to_le32
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|write_blk
c_func
(paren
id|sb
comma
id|type
comma
id|blk
comma
id|buf
)paren
)paren
OL
l_int|0
)paren
r_goto
id|out_buf
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;u.v2_i.dqi_free_entry
)paren
(brace
r_if
c_cond
(paren
(paren
id|err
op_assign
id|read_blk
c_func
(paren
id|sb
comma
id|type
comma
id|info-&gt;u.v2_i.dqi_free_entry
comma
id|tmpbuf
)paren
)paren
OL
l_int|0
)paren
r_goto
id|out_buf
suffix:semicolon
(paren
(paren
r_struct
id|v2_disk_dqdbheader
op_star
)paren
id|tmpbuf
)paren
op_member_access_from_pointer
id|dqdh_prev_free
op_assign
id|cpu_to_le32
c_func
(paren
id|blk
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|write_blk
c_func
(paren
id|sb
comma
id|type
comma
id|info-&gt;u.v2_i.dqi_free_entry
comma
id|tmpbuf
)paren
)paren
OL
l_int|0
)paren
r_goto
id|out_buf
suffix:semicolon
)brace
id|freedqbuf
c_func
(paren
id|tmpbuf
)paren
suffix:semicolon
id|info-&gt;u.v2_i.dqi_free_entry
op_assign
id|blk
suffix:semicolon
id|mark_info_dirty
c_func
(paren
id|sb
comma
id|type
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|out_buf
suffix:colon
id|freedqbuf
c_func
(paren
id|tmpbuf
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/* Find space for dquot */
DECL|function|find_free_dqentry
r_static
id|uint
id|find_free_dqentry
c_func
(paren
r_struct
id|dquot
op_star
id|dquot
comma
r_int
op_star
id|err
)paren
(brace
r_struct
id|super_block
op_star
id|sb
op_assign
id|dquot-&gt;dq_sb
suffix:semicolon
r_struct
id|mem_dqinfo
op_star
id|info
op_assign
id|sb_dqopt
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|info
op_plus
id|dquot-&gt;dq_type
suffix:semicolon
id|uint
id|blk
comma
id|i
suffix:semicolon
r_struct
id|v2_disk_dqdbheader
op_star
id|dh
suffix:semicolon
r_struct
id|v2_disk_dqblk
op_star
id|ddquot
suffix:semicolon
r_struct
id|v2_disk_dqblk
id|fakedquot
suffix:semicolon
id|dqbuf_t
id|buf
suffix:semicolon
op_star
id|err
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|buf
op_assign
id|getdqbuf
c_func
(paren
)paren
)paren
)paren
(brace
op_star
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|dh
op_assign
(paren
r_struct
id|v2_disk_dqdbheader
op_star
)paren
id|buf
suffix:semicolon
id|ddquot
op_assign
id|GETENTRIES
c_func
(paren
id|buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;u.v2_i.dqi_free_entry
)paren
(brace
id|blk
op_assign
id|info-&gt;u.v2_i.dqi_free_entry
suffix:semicolon
r_if
c_cond
(paren
(paren
op_star
id|err
op_assign
id|read_blk
c_func
(paren
id|sb
comma
id|dquot-&gt;dq_type
comma
id|blk
comma
id|buf
)paren
)paren
OL
l_int|0
)paren
r_goto
id|out_buf
suffix:semicolon
)brace
r_else
(brace
id|blk
op_assign
id|get_free_dqblk
c_func
(paren
id|sb
comma
id|dquot-&gt;dq_type
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
)paren
id|blk
OL
l_int|0
)paren
(brace
op_star
id|err
op_assign
id|blk
suffix:semicolon
id|freedqbuf
c_func
(paren
id|buf
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|memset
c_func
(paren
id|buf
comma
l_int|0
comma
id|V2_DQBLKSIZE
)paren
suffix:semicolon
multiline_comment|/* This is enough as block is already zeroed and entry list is empty... */
id|info-&gt;u.v2_i.dqi_free_entry
op_assign
id|blk
suffix:semicolon
id|mark_info_dirty
c_func
(paren
id|sb
comma
id|dquot-&gt;dq_type
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|le16_to_cpu
c_func
(paren
id|dh-&gt;dqdh_entries
)paren
op_plus
l_int|1
op_ge
id|V2_DQSTRINBLK
)paren
multiline_comment|/* Block will be full? */
r_if
c_cond
(paren
(paren
op_star
id|err
op_assign
id|remove_free_dqentry
c_func
(paren
id|sb
comma
id|dquot-&gt;dq_type
comma
id|buf
comma
id|blk
)paren
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;VFS: find_free_dqentry(): Can&squot;t remove block (%u) from entry free list.&bslash;n&quot;
comma
id|blk
)paren
suffix:semicolon
r_goto
id|out_buf
suffix:semicolon
)brace
id|dh-&gt;dqdh_entries
op_assign
id|cpu_to_le16
c_func
(paren
id|le16_to_cpu
c_func
(paren
id|dh-&gt;dqdh_entries
)paren
op_plus
l_int|1
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|fakedquot
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|v2_disk_dqblk
)paren
)paren
suffix:semicolon
multiline_comment|/* Find free structure in block */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|V2_DQSTRINBLK
op_logical_and
id|memcmp
c_func
(paren
op_amp
id|fakedquot
comma
id|ddquot
op_plus
id|i
comma
r_sizeof
(paren
r_struct
id|v2_disk_dqblk
)paren
)paren
suffix:semicolon
id|i
op_increment
)paren
suffix:semicolon
macro_line|#ifdef __QUOTA_V2_PARANOIA
r_if
c_cond
(paren
id|i
op_eq
id|V2_DQSTRINBLK
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;VFS: find_free_dqentry(): Data block full but it shouldn&squot;t.&bslash;n&quot;
)paren
suffix:semicolon
op_star
id|err
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|out_buf
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
(paren
op_star
id|err
op_assign
id|write_blk
c_func
(paren
id|sb
comma
id|dquot-&gt;dq_type
comma
id|blk
comma
id|buf
)paren
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;VFS: find_free_dqentry(): Can&squot;t write quota data block %u.&bslash;n&quot;
comma
id|blk
)paren
suffix:semicolon
r_goto
id|out_buf
suffix:semicolon
)brace
id|dquot-&gt;dq_off
op_assign
(paren
id|blk
op_lshift
id|V2_DQBLKSIZE_BITS
)paren
op_plus
r_sizeof
(paren
r_struct
id|v2_disk_dqdbheader
)paren
op_plus
id|i
op_star
r_sizeof
(paren
r_struct
id|v2_disk_dqblk
)paren
suffix:semicolon
id|freedqbuf
c_func
(paren
id|buf
)paren
suffix:semicolon
r_return
id|blk
suffix:semicolon
id|out_buf
suffix:colon
id|freedqbuf
c_func
(paren
id|buf
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Insert reference to structure into the trie */
DECL|function|do_insert_tree
r_static
r_int
id|do_insert_tree
c_func
(paren
r_struct
id|dquot
op_star
id|dquot
comma
id|uint
op_star
id|treeblk
comma
r_int
id|depth
)paren
(brace
r_struct
id|super_block
op_star
id|sb
op_assign
id|dquot-&gt;dq_sb
suffix:semicolon
id|dqbuf_t
id|buf
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
comma
id|newson
op_assign
l_int|0
comma
id|newact
op_assign
l_int|0
suffix:semicolon
id|__le32
op_star
id|ref
suffix:semicolon
id|uint
id|newblk
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|buf
op_assign
id|getdqbuf
c_func
(paren
)paren
)paren
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_star
id|treeblk
)paren
(brace
id|ret
op_assign
id|get_free_dqblk
c_func
(paren
id|sb
comma
id|dquot-&gt;dq_type
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
r_goto
id|out_buf
suffix:semicolon
op_star
id|treeblk
op_assign
id|ret
suffix:semicolon
id|memset
c_func
(paren
id|buf
comma
l_int|0
comma
id|V2_DQBLKSIZE
)paren
suffix:semicolon
id|newact
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|read_blk
c_func
(paren
id|sb
comma
id|dquot-&gt;dq_type
comma
op_star
id|treeblk
comma
id|buf
)paren
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;VFS: Can&squot;t read tree quota block %u.&bslash;n&quot;
comma
op_star
id|treeblk
)paren
suffix:semicolon
r_goto
id|out_buf
suffix:semicolon
)brace
)brace
id|ref
op_assign
(paren
id|__le32
op_star
)paren
id|buf
suffix:semicolon
id|newblk
op_assign
id|le32_to_cpu
c_func
(paren
id|ref
(braket
id|GETIDINDEX
c_func
(paren
id|dquot-&gt;dq_id
comma
id|depth
)paren
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|newblk
)paren
id|newson
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|depth
op_eq
id|V2_DQTREEDEPTH
op_minus
l_int|1
)paren
(brace
macro_line|#ifdef __QUOTA_V2_PARANOIA
r_if
c_cond
(paren
id|newblk
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;VFS: Inserting already present quota entry (block %u).&bslash;n&quot;
comma
id|le32_to_cpu
c_func
(paren
id|ref
(braket
id|GETIDINDEX
c_func
(paren
id|dquot-&gt;dq_id
comma
id|depth
)paren
)braket
)paren
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|out_buf
suffix:semicolon
)brace
macro_line|#endif
id|newblk
op_assign
id|find_free_dqentry
c_func
(paren
id|dquot
comma
op_amp
id|ret
)paren
suffix:semicolon
)brace
r_else
id|ret
op_assign
id|do_insert_tree
c_func
(paren
id|dquot
comma
op_amp
id|newblk
comma
id|depth
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|newson
op_logical_and
id|ret
op_ge
l_int|0
)paren
(brace
id|ref
(braket
id|GETIDINDEX
c_func
(paren
id|dquot-&gt;dq_id
comma
id|depth
)paren
)braket
op_assign
id|cpu_to_le32
c_func
(paren
id|newblk
)paren
suffix:semicolon
id|ret
op_assign
id|write_blk
c_func
(paren
id|sb
comma
id|dquot-&gt;dq_type
comma
op_star
id|treeblk
comma
id|buf
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|newact
op_logical_and
id|ret
OL
l_int|0
)paren
id|put_free_dqblk
c_func
(paren
id|sb
comma
id|dquot-&gt;dq_type
comma
id|buf
comma
op_star
id|treeblk
)paren
suffix:semicolon
id|out_buf
suffix:colon
id|freedqbuf
c_func
(paren
id|buf
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* Wrapper for inserting quota structure into tree */
DECL|function|dq_insert_tree
r_static
r_inline
r_int
id|dq_insert_tree
c_func
(paren
r_struct
id|dquot
op_star
id|dquot
)paren
(brace
r_int
id|tmp
op_assign
id|V2_DQTREEOFF
suffix:semicolon
r_return
id|do_insert_tree
c_func
(paren
id|dquot
comma
op_amp
id|tmp
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;We don&squot;t have to be afraid of deadlocks as we never have quotas on quota files...&n; */
DECL|function|v2_write_dquot
r_static
r_int
id|v2_write_dquot
c_func
(paren
r_struct
id|dquot
op_star
id|dquot
)paren
(brace
r_int
id|type
op_assign
id|dquot-&gt;dq_type
suffix:semicolon
id|ssize_t
id|ret
suffix:semicolon
r_struct
id|v2_disk_dqblk
id|ddquot
comma
id|empty
suffix:semicolon
multiline_comment|/* dq_off is guarded by dqio_sem */
r_if
c_cond
(paren
op_logical_neg
id|dquot-&gt;dq_off
)paren
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|dq_insert_tree
c_func
(paren
id|dquot
)paren
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;VFS: Error %zd occurred while creating quota.&bslash;n&quot;
comma
id|ret
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
id|spin_lock
c_func
(paren
op_amp
id|dq_data_lock
)paren
suffix:semicolon
id|mem2diskdqb
c_func
(paren
op_amp
id|ddquot
comma
op_amp
id|dquot-&gt;dq_dqb
comma
id|dquot-&gt;dq_id
)paren
suffix:semicolon
multiline_comment|/* Argh... We may need to write structure full of zeroes but that would be&n;&t; * treated as an empty place by the rest of the code. Format change would&n;&t; * be definitely cleaner but the problems probably are not worth it */
id|memset
c_func
(paren
op_amp
id|empty
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|v2_disk_dqblk
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|memcmp
c_func
(paren
op_amp
id|empty
comma
op_amp
id|ddquot
comma
r_sizeof
(paren
r_struct
id|v2_disk_dqblk
)paren
)paren
)paren
id|ddquot.dqb_itime
op_assign
id|cpu_to_le64
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|dq_data_lock
)paren
suffix:semicolon
id|ret
op_assign
id|dquot-&gt;dq_sb-&gt;s_op
op_member_access_from_pointer
id|quota_write
c_func
(paren
id|dquot-&gt;dq_sb
comma
id|type
comma
(paren
r_char
op_star
)paren
op_amp
id|ddquot
comma
r_sizeof
(paren
r_struct
id|v2_disk_dqblk
)paren
comma
id|dquot-&gt;dq_off
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
r_sizeof
(paren
r_struct
id|v2_disk_dqblk
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;VFS: dquota write failed on dev %s&bslash;n&quot;
comma
id|dquot-&gt;dq_sb-&gt;s_id
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ge
l_int|0
)paren
id|ret
op_assign
op_minus
id|ENOSPC
suffix:semicolon
)brace
r_else
id|ret
op_assign
l_int|0
suffix:semicolon
id|dqstats.writes
op_increment
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* Free dquot entry in data block */
DECL|function|free_dqentry
r_static
r_int
id|free_dqentry
c_func
(paren
r_struct
id|dquot
op_star
id|dquot
comma
id|uint
id|blk
)paren
(brace
r_struct
id|super_block
op_star
id|sb
op_assign
id|dquot-&gt;dq_sb
suffix:semicolon
r_int
id|type
op_assign
id|dquot-&gt;dq_type
suffix:semicolon
r_struct
id|v2_disk_dqdbheader
op_star
id|dh
suffix:semicolon
id|dqbuf_t
id|buf
op_assign
id|getdqbuf
c_func
(paren
)paren
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buf
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
id|dquot-&gt;dq_off
op_rshift
id|V2_DQBLKSIZE_BITS
op_ne
id|blk
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;VFS: Quota structure has offset to other &quot;
l_string|&quot;block (%u) than it should (%u).&bslash;n&quot;
comma
id|blk
comma
(paren
id|uint
)paren
(paren
id|dquot-&gt;dq_off
op_rshift
id|V2_DQBLKSIZE_BITS
)paren
)paren
suffix:semicolon
r_goto
id|out_buf
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|read_blk
c_func
(paren
id|sb
comma
id|type
comma
id|blk
comma
id|buf
)paren
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;VFS: Can&squot;t read quota data block %u&bslash;n&quot;
comma
id|blk
)paren
suffix:semicolon
r_goto
id|out_buf
suffix:semicolon
)brace
id|dh
op_assign
(paren
r_struct
id|v2_disk_dqdbheader
op_star
)paren
id|buf
suffix:semicolon
id|dh-&gt;dqdh_entries
op_assign
id|cpu_to_le16
c_func
(paren
id|le16_to_cpu
c_func
(paren
id|dh-&gt;dqdh_entries
)paren
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|le16_to_cpu
c_func
(paren
id|dh-&gt;dqdh_entries
)paren
)paren
(brace
multiline_comment|/* Block got free? */
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|remove_free_dqentry
c_func
(paren
id|sb
comma
id|type
comma
id|buf
comma
id|blk
)paren
)paren
OL
l_int|0
op_logical_or
(paren
id|ret
op_assign
id|put_free_dqblk
c_func
(paren
id|sb
comma
id|type
comma
id|buf
comma
id|blk
)paren
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;VFS: Can&squot;t move quota data block (%u) &quot;
l_string|&quot;to free list.&bslash;n&quot;
comma
id|blk
)paren
suffix:semicolon
r_goto
id|out_buf
suffix:semicolon
)brace
)brace
r_else
(brace
id|memset
c_func
(paren
id|buf
op_plus
(paren
id|dquot-&gt;dq_off
op_amp
(paren
(paren
l_int|1
op_lshift
id|V2_DQBLKSIZE_BITS
)paren
op_minus
l_int|1
)paren
)paren
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|v2_disk_dqblk
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|le16_to_cpu
c_func
(paren
id|dh-&gt;dqdh_entries
)paren
op_eq
id|V2_DQSTRINBLK
op_minus
l_int|1
)paren
(brace
multiline_comment|/* Insert will write block itself */
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|insert_free_dqentry
c_func
(paren
id|sb
comma
id|type
comma
id|buf
comma
id|blk
)paren
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;VFS: Can&squot;t insert quota data block (%u) to free entry list.&bslash;n&quot;
comma
id|blk
)paren
suffix:semicolon
r_goto
id|out_buf
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|write_blk
c_func
(paren
id|sb
comma
id|type
comma
id|blk
comma
id|buf
)paren
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;VFS: Can&squot;t write quota data &quot;
l_string|&quot;block %u&bslash;n&quot;
comma
id|blk
)paren
suffix:semicolon
r_goto
id|out_buf
suffix:semicolon
)brace
)brace
id|dquot-&gt;dq_off
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Quota is now unattached */
id|out_buf
suffix:colon
id|freedqbuf
c_func
(paren
id|buf
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* Remove reference to dquot from tree */
DECL|function|remove_tree
r_static
r_int
id|remove_tree
c_func
(paren
r_struct
id|dquot
op_star
id|dquot
comma
id|uint
op_star
id|blk
comma
r_int
id|depth
)paren
(brace
r_struct
id|super_block
op_star
id|sb
op_assign
id|dquot-&gt;dq_sb
suffix:semicolon
r_int
id|type
op_assign
id|dquot-&gt;dq_type
suffix:semicolon
id|dqbuf_t
id|buf
op_assign
id|getdqbuf
c_func
(paren
)paren
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|uint
id|newblk
suffix:semicolon
id|__le32
op_star
id|ref
op_assign
(paren
id|__le32
op_star
)paren
id|buf
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buf
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|read_blk
c_func
(paren
id|sb
comma
id|type
comma
op_star
id|blk
comma
id|buf
)paren
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;VFS: Can&squot;t read quota data block %u&bslash;n&quot;
comma
op_star
id|blk
)paren
suffix:semicolon
r_goto
id|out_buf
suffix:semicolon
)brace
id|newblk
op_assign
id|le32_to_cpu
c_func
(paren
id|ref
(braket
id|GETIDINDEX
c_func
(paren
id|dquot-&gt;dq_id
comma
id|depth
)paren
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|depth
op_eq
id|V2_DQTREEDEPTH
op_minus
l_int|1
)paren
(brace
id|ret
op_assign
id|free_dqentry
c_func
(paren
id|dquot
comma
id|newblk
)paren
suffix:semicolon
id|newblk
op_assign
l_int|0
suffix:semicolon
)brace
r_else
id|ret
op_assign
id|remove_tree
c_func
(paren
id|dquot
comma
op_amp
id|newblk
comma
id|depth
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ge
l_int|0
op_logical_and
op_logical_neg
id|newblk
)paren
(brace
r_int
id|i
suffix:semicolon
id|ref
(braket
id|GETIDINDEX
c_func
(paren
id|dquot-&gt;dq_id
comma
id|depth
)paren
)braket
op_assign
id|cpu_to_le32
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|V2_DQBLKSIZE
op_logical_and
op_logical_neg
id|buf
(braket
id|i
)braket
suffix:semicolon
id|i
op_increment
)paren
suffix:semicolon
multiline_comment|/* Block got empty? */
r_if
c_cond
(paren
id|i
op_eq
id|V2_DQBLKSIZE
)paren
(brace
id|put_free_dqblk
c_func
(paren
id|sb
comma
id|type
comma
id|buf
comma
op_star
id|blk
)paren
suffix:semicolon
op_star
id|blk
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|write_blk
c_func
(paren
id|sb
comma
id|type
comma
op_star
id|blk
comma
id|buf
)paren
)paren
OL
l_int|0
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;VFS: Can&squot;t write quota tree &quot;
l_string|&quot;block %u.&bslash;n&quot;
comma
op_star
id|blk
)paren
suffix:semicolon
)brace
id|out_buf
suffix:colon
id|freedqbuf
c_func
(paren
id|buf
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* Delete dquot from tree */
DECL|function|v2_delete_dquot
r_static
r_int
id|v2_delete_dquot
c_func
(paren
r_struct
id|dquot
op_star
id|dquot
)paren
(brace
id|uint
id|tmp
op_assign
id|V2_DQTREEOFF
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dquot-&gt;dq_off
)paren
multiline_comment|/* Even not allocated? */
r_return
l_int|0
suffix:semicolon
r_return
id|remove_tree
c_func
(paren
id|dquot
comma
op_amp
id|tmp
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* Find entry in block */
DECL|function|find_block_dqentry
r_static
id|loff_t
id|find_block_dqentry
c_func
(paren
r_struct
id|dquot
op_star
id|dquot
comma
id|uint
id|blk
)paren
(brace
id|dqbuf_t
id|buf
op_assign
id|getdqbuf
c_func
(paren
)paren
suffix:semicolon
id|loff_t
id|ret
op_assign
l_int|0
suffix:semicolon
r_int
id|i
suffix:semicolon
r_struct
id|v2_disk_dqblk
op_star
id|ddquot
op_assign
id|GETENTRIES
c_func
(paren
id|buf
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buf
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|read_blk
c_func
(paren
id|dquot-&gt;dq_sb
comma
id|dquot-&gt;dq_type
comma
id|blk
comma
id|buf
)paren
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;VFS: Can&squot;t read quota tree block %u.&bslash;n&quot;
comma
id|blk
)paren
suffix:semicolon
r_goto
id|out_buf
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dquot-&gt;dq_id
)paren
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|V2_DQSTRINBLK
op_logical_and
id|le32_to_cpu
c_func
(paren
id|ddquot
(braket
id|i
)braket
dot
id|dqb_id
)paren
op_ne
id|dquot-&gt;dq_id
suffix:semicolon
id|i
op_increment
)paren
suffix:semicolon
r_else
(brace
multiline_comment|/* ID 0 as a bit more complicated searching... */
r_struct
id|v2_disk_dqblk
id|fakedquot
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|fakedquot
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|v2_disk_dqblk
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|V2_DQSTRINBLK
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
op_logical_neg
id|le32_to_cpu
c_func
(paren
id|ddquot
(braket
id|i
)braket
dot
id|dqb_id
)paren
op_logical_and
id|memcmp
c_func
(paren
op_amp
id|fakedquot
comma
id|ddquot
op_plus
id|i
comma
r_sizeof
(paren
r_struct
id|v2_disk_dqblk
)paren
)paren
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_eq
id|V2_DQSTRINBLK
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;VFS: Quota for id %u referenced &quot;
l_string|&quot;but not present.&bslash;n&quot;
comma
id|dquot-&gt;dq_id
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|out_buf
suffix:semicolon
)brace
r_else
id|ret
op_assign
(paren
id|blk
op_lshift
id|V2_DQBLKSIZE_BITS
)paren
op_plus
r_sizeof
(paren
r_struct
id|v2_disk_dqdbheader
)paren
op_plus
id|i
op_star
r_sizeof
(paren
r_struct
id|v2_disk_dqblk
)paren
suffix:semicolon
id|out_buf
suffix:colon
id|freedqbuf
c_func
(paren
id|buf
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* Find entry for given id in the tree */
DECL|function|find_tree_dqentry
r_static
id|loff_t
id|find_tree_dqentry
c_func
(paren
r_struct
id|dquot
op_star
id|dquot
comma
id|uint
id|blk
comma
r_int
id|depth
)paren
(brace
id|dqbuf_t
id|buf
op_assign
id|getdqbuf
c_func
(paren
)paren
suffix:semicolon
id|loff_t
id|ret
op_assign
l_int|0
suffix:semicolon
id|__le32
op_star
id|ref
op_assign
(paren
id|__le32
op_star
)paren
id|buf
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buf
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|read_blk
c_func
(paren
id|dquot-&gt;dq_sb
comma
id|dquot-&gt;dq_type
comma
id|blk
comma
id|buf
)paren
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;VFS: Can&squot;t read quota tree block %u.&bslash;n&quot;
comma
id|blk
)paren
suffix:semicolon
r_goto
id|out_buf
suffix:semicolon
)brace
id|ret
op_assign
l_int|0
suffix:semicolon
id|blk
op_assign
id|le32_to_cpu
c_func
(paren
id|ref
(braket
id|GETIDINDEX
c_func
(paren
id|dquot-&gt;dq_id
comma
id|depth
)paren
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|blk
)paren
multiline_comment|/* No reference? */
r_goto
id|out_buf
suffix:semicolon
r_if
c_cond
(paren
id|depth
OL
id|V2_DQTREEDEPTH
op_minus
l_int|1
)paren
id|ret
op_assign
id|find_tree_dqentry
c_func
(paren
id|dquot
comma
id|blk
comma
id|depth
op_plus
l_int|1
)paren
suffix:semicolon
r_else
id|ret
op_assign
id|find_block_dqentry
c_func
(paren
id|dquot
comma
id|blk
)paren
suffix:semicolon
id|out_buf
suffix:colon
id|freedqbuf
c_func
(paren
id|buf
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* Find entry for given id in the tree - wrapper function */
DECL|function|find_dqentry
r_static
r_inline
id|loff_t
id|find_dqentry
c_func
(paren
r_struct
id|dquot
op_star
id|dquot
)paren
(brace
r_return
id|find_tree_dqentry
c_func
(paren
id|dquot
comma
id|V2_DQTREEOFF
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|v2_read_dquot
r_static
r_int
id|v2_read_dquot
c_func
(paren
r_struct
id|dquot
op_star
id|dquot
)paren
(brace
r_int
id|type
op_assign
id|dquot-&gt;dq_type
suffix:semicolon
id|loff_t
id|offset
suffix:semicolon
r_struct
id|v2_disk_dqblk
id|ddquot
comma
id|empty
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef __QUOTA_V2_PARANOIA
multiline_comment|/* Invalidated quota? */
r_if
c_cond
(paren
op_logical_neg
id|dquot-&gt;dq_sb
op_logical_or
op_logical_neg
id|sb_dqopt
c_func
(paren
id|dquot-&gt;dq_sb
)paren
op_member_access_from_pointer
id|files
(braket
id|type
)braket
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;VFS: Quota invalidated while reading!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
macro_line|#endif
id|offset
op_assign
id|find_dqentry
c_func
(paren
id|dquot
)paren
suffix:semicolon
r_if
c_cond
(paren
id|offset
op_le
l_int|0
)paren
(brace
multiline_comment|/* Entry not present? */
r_if
c_cond
(paren
id|offset
OL
l_int|0
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;VFS: Can&squot;t read quota &quot;
l_string|&quot;structure for id %u.&bslash;n&quot;
comma
id|dquot-&gt;dq_id
)paren
suffix:semicolon
id|dquot-&gt;dq_off
op_assign
l_int|0
suffix:semicolon
id|set_bit
c_func
(paren
id|DQ_FAKE_B
comma
op_amp
id|dquot-&gt;dq_flags
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|dquot-&gt;dq_dqb
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|mem_dqblk
)paren
)paren
suffix:semicolon
id|ret
op_assign
id|offset
suffix:semicolon
)brace
r_else
(brace
id|dquot-&gt;dq_off
op_assign
id|offset
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|dquot-&gt;dq_sb-&gt;s_op
op_member_access_from_pointer
id|quota_read
c_func
(paren
id|dquot-&gt;dq_sb
comma
id|type
comma
(paren
r_char
op_star
)paren
op_amp
id|ddquot
comma
r_sizeof
(paren
r_struct
id|v2_disk_dqblk
)paren
comma
id|offset
)paren
)paren
op_ne
r_sizeof
(paren
r_struct
id|v2_disk_dqblk
)paren
)paren
(brace
r_if
c_cond
(paren
id|ret
op_ge
l_int|0
)paren
id|ret
op_assign
op_minus
id|EIO
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;VFS: Error while reading quota &quot;
l_string|&quot;structure for id %u.&bslash;n&quot;
comma
id|dquot-&gt;dq_id
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|ddquot
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|v2_disk_dqblk
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|ret
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* We need to escape back all-zero structure */
id|memset
c_func
(paren
op_amp
id|empty
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|v2_disk_dqblk
)paren
)paren
suffix:semicolon
id|empty.dqb_itime
op_assign
id|cpu_to_le64
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|memcmp
c_func
(paren
op_amp
id|empty
comma
op_amp
id|ddquot
comma
r_sizeof
(paren
r_struct
id|v2_disk_dqblk
)paren
)paren
)paren
id|ddquot.dqb_itime
op_assign
l_int|0
suffix:semicolon
)brace
id|disk2memdqb
c_func
(paren
op_amp
id|dquot-&gt;dq_dqb
comma
op_amp
id|ddquot
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dquot-&gt;dq_dqb.dqb_bhardlimit
op_logical_and
op_logical_neg
id|dquot-&gt;dq_dqb.dqb_bsoftlimit
op_logical_and
op_logical_neg
id|dquot-&gt;dq_dqb.dqb_ihardlimit
op_logical_and
op_logical_neg
id|dquot-&gt;dq_dqb.dqb_isoftlimit
)paren
id|set_bit
c_func
(paren
id|DQ_FAKE_B
comma
op_amp
id|dquot-&gt;dq_flags
)paren
suffix:semicolon
)brace
id|dqstats.reads
op_increment
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* Check whether dquot should not be deleted. We know we are&n; * the only one operating on dquot (thanks to dq_lock) */
DECL|function|v2_release_dquot
r_static
r_int
id|v2_release_dquot
c_func
(paren
r_struct
id|dquot
op_star
id|dquot
)paren
(brace
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|DQ_FAKE_B
comma
op_amp
id|dquot-&gt;dq_flags
)paren
op_logical_and
op_logical_neg
(paren
id|dquot-&gt;dq_dqb.dqb_curinodes
op_or
id|dquot-&gt;dq_dqb.dqb_curspace
)paren
)paren
r_return
id|v2_delete_dquot
c_func
(paren
id|dquot
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|v2_format_ops
r_static
r_struct
id|quota_format_ops
id|v2_format_ops
op_assign
(brace
dot
id|check_quota_file
op_assign
id|v2_check_quota_file
comma
dot
id|read_file_info
op_assign
id|v2_read_file_info
comma
dot
id|write_file_info
op_assign
id|v2_write_file_info
comma
dot
id|free_file_info
op_assign
l_int|NULL
comma
dot
id|read_dqblk
op_assign
id|v2_read_dquot
comma
dot
id|commit_dqblk
op_assign
id|v2_write_dquot
comma
dot
id|release_dqblk
op_assign
id|v2_release_dquot
comma
)brace
suffix:semicolon
DECL|variable|v2_quota_format
r_static
r_struct
id|quota_format_type
id|v2_quota_format
op_assign
(brace
dot
id|qf_fmt_id
op_assign
id|QFMT_VFS_V0
comma
dot
id|qf_ops
op_assign
op_amp
id|v2_format_ops
comma
dot
id|qf_owner
op_assign
id|THIS_MODULE
)brace
suffix:semicolon
DECL|function|init_v2_quota_format
r_static
r_int
id|__init
id|init_v2_quota_format
c_func
(paren
r_void
)paren
(brace
r_return
id|register_quota_format
c_func
(paren
op_amp
id|v2_quota_format
)paren
suffix:semicolon
)brace
DECL|function|exit_v2_quota_format
r_static
r_void
id|__exit
id|exit_v2_quota_format
c_func
(paren
r_void
)paren
(brace
id|unregister_quota_format
c_func
(paren
op_amp
id|v2_quota_format
)paren
suffix:semicolon
)brace
DECL|variable|init_v2_quota_format
id|module_init
c_func
(paren
id|init_v2_quota_format
)paren
suffix:semicolon
DECL|variable|exit_v2_quota_format
id|module_exit
c_func
(paren
id|exit_v2_quota_format
)paren
suffix:semicolon
eof
