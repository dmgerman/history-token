multiline_comment|/*&n; * Copyright (C) 2001 Jens Axboe &lt;axboe@suse.de&gt;&n; *&n; * This program is free software; you can redistribute it and/or modify&n; * it under the terms of the GNU General Public License version 2 as&n; * published by the Free Software Foundation.&n; *&n; * This program is distributed in the hope that it will be useful,&n; * but WITHOUT ANY WARRANTY; without even the implied warranty of&n;&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; * GNU General Public License for more details.&n; *&n; * You should have received a copy of the GNU General Public Licens&n; * along with this program; if not, write to the Free Software&n; * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-&n; *&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/pagemap.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/swap.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/iobuf.h&gt;
macro_line|#include &lt;linux/blk.h&gt;
macro_line|#include &lt;linux/vmalloc.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/prefetch.h&gt;
macro_line|#include &lt;linux/compiler.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
DECL|variable|bio_cachep
id|kmem_cache_t
op_star
id|bio_cachep
suffix:semicolon
DECL|variable|bio_lock
r_static
id|spinlock_t
id|__cacheline_aligned
id|bio_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
DECL|variable|bio_pool
r_static
r_struct
id|bio
op_star
id|bio_pool
suffix:semicolon
r_static
id|DECLARE_WAIT_QUEUE_HEAD
c_func
(paren
id|bio_pool_wait
)paren
suffix:semicolon
r_static
id|DECLARE_WAIT_QUEUE_HEAD
c_func
(paren
id|biovec_pool_wait
)paren
suffix:semicolon
DECL|variable|bio_pool_free
r_static
r_int
r_int
id|bio_pool_free
suffix:semicolon
DECL|macro|BIOVEC_NR_POOLS
mdefine_line|#define BIOVEC_NR_POOLS 6
DECL|struct|biovec_pool
r_struct
id|biovec_pool
(brace
DECL|member|bp_size
r_int
id|bp_size
suffix:semicolon
DECL|member|bp_cachep
id|kmem_cache_t
op_star
id|bp_cachep
suffix:semicolon
DECL|member|bp_wait
id|wait_queue_head_t
id|bp_wait
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|bvec_list
r_static
r_struct
id|biovec_pool
id|bvec_list
(braket
id|BIOVEC_NR_POOLS
)braket
suffix:semicolon
multiline_comment|/*&n; * if you change this list, also change bvec_alloc or things will&n; * break badly!&n; */
DECL|variable|bvec_pool_sizes
r_static
r_const
r_int
id|bvec_pool_sizes
(braket
id|BIOVEC_NR_POOLS
)braket
op_assign
(brace
l_int|1
comma
l_int|4
comma
l_int|16
comma
l_int|64
comma
l_int|128
comma
l_int|256
)brace
suffix:semicolon
DECL|macro|BIO_MAX_PAGES
mdefine_line|#define BIO_MAX_PAGES&t;(bvec_pool_sizes[BIOVEC_NR_POOLS - 1])
multiline_comment|/*&n; * TODO: change this to use slab reservation scheme once that infrastructure&n; * is in place...&n; */
DECL|macro|BIO_POOL_SIZE
mdefine_line|#define BIO_POOL_SIZE&t;&t;(256)
multiline_comment|/*&n; * if need be, add bio_pool_get_irq() to match...&n; */
DECL|function|__bio_pool_get
r_static
r_inline
r_struct
id|bio
op_star
id|__bio_pool_get
c_func
(paren
r_void
)paren
(brace
r_struct
id|bio
op_star
id|bio
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bio
op_assign
id|bio_pool
)paren
)paren
(brace
id|BUG_ON
c_func
(paren
id|bio_pool_free
op_le
l_int|0
)paren
suffix:semicolon
id|bio_pool
op_assign
id|bio-&gt;bi_next
suffix:semicolon
id|bio-&gt;bi_next
op_assign
l_int|NULL
suffix:semicolon
id|bio_pool_free
op_decrement
suffix:semicolon
)brace
r_return
id|bio
suffix:semicolon
)brace
DECL|function|bio_pool_get
r_static
r_inline
r_struct
id|bio
op_star
id|bio_pool_get
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|bio
op_star
id|bio
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|bio_lock
comma
id|flags
)paren
suffix:semicolon
id|bio
op_assign
id|__bio_pool_get
c_func
(paren
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|bio
op_logical_and
id|bio_pool_free
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|bio_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|bio
suffix:semicolon
)brace
DECL|function|bio_pool_put
r_static
r_inline
r_void
id|bio_pool_put
c_func
(paren
r_struct
id|bio
op_star
id|bio
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|wake_pool
op_assign
l_int|0
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|bio_lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * if the pool has enough free entries, just slab free the bio&n;&t; */
r_if
c_cond
(paren
id|bio_pool_free
OL
id|BIO_POOL_SIZE
)paren
(brace
id|bio-&gt;bi_next
op_assign
id|bio_pool
suffix:semicolon
id|bio_pool
op_assign
id|bio
suffix:semicolon
id|bio_pool_free
op_increment
suffix:semicolon
id|wake_pool
op_assign
id|waitqueue_active
c_func
(paren
op_amp
id|bio_pool_wait
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|bio_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|wake_pool
)paren
id|wake_up_nr
c_func
(paren
op_amp
id|bio_pool_wait
comma
l_int|1
)paren
suffix:semicolon
)brace
r_else
(brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|bio_lock
comma
id|flags
)paren
suffix:semicolon
id|kmem_cache_free
c_func
(paren
id|bio_cachep
comma
id|bio
)paren
suffix:semicolon
)brace
)brace
DECL|macro|BIO_CAN_WAIT
mdefine_line|#define BIO_CAN_WAIT(gfp_mask)&t;&bslash;&n;&t;(((gfp_mask) &amp; (__GFP_WAIT | __GFP_IO)) == (__GFP_WAIT | __GFP_IO))
DECL|function|bvec_alloc
r_static
r_inline
r_struct
id|bio_vec
op_star
id|bvec_alloc
c_func
(paren
r_int
id|gfp_mask
comma
r_int
id|nr
comma
r_int
op_star
id|idx
)paren
(brace
r_struct
id|bio_vec
op_star
id|bvl
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|biovec_pool
op_star
id|bp
suffix:semicolon
multiline_comment|/*&n;&t; * see comment near bvec_pool_sizes define!&n;&t; */
r_switch
c_cond
(paren
id|nr
)paren
(brace
r_case
l_int|1
suffix:colon
op_star
id|idx
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
dot
dot
dot
l_int|4
suffix:colon
op_star
id|idx
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|5
dot
dot
dot
l_int|16
suffix:colon
op_star
id|idx
op_assign
l_int|2
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|17
dot
dot
dot
l_int|64
suffix:colon
op_star
id|idx
op_assign
l_int|3
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|65
dot
dot
dot
l_int|128
suffix:colon
op_star
id|idx
op_assign
l_int|4
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|129
dot
dot
dot
l_int|256
suffix:colon
op_star
id|idx
op_assign
l_int|5
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
l_int|NULL
suffix:semicolon
)brace
id|bp
op_assign
op_amp
id|bvec_list
(braket
op_star
id|idx
)braket
suffix:semicolon
multiline_comment|/*&n;&t; * ok, so idx now points to the slab we want to allocate from&n;&t; */
r_if
c_cond
(paren
(paren
id|bvl
op_assign
id|kmem_cache_alloc
c_func
(paren
id|bp-&gt;bp_cachep
comma
id|gfp_mask
)paren
)paren
)paren
r_goto
id|out_gotit
suffix:semicolon
multiline_comment|/*&n;&t; * we need slab reservations for this to be completely&n;&t; * deadlock free...&n;&t; */
r_if
c_cond
(paren
id|BIO_CAN_WAIT
c_func
(paren
id|gfp_mask
)paren
)paren
(brace
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
id|add_wait_queue_exclusive
c_func
(paren
op_amp
id|bp-&gt;bp_wait
comma
op_amp
id|wait
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|set_current_state
c_func
(paren
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
id|bvl
op_assign
id|kmem_cache_alloc
c_func
(paren
id|bp-&gt;bp_cachep
comma
id|gfp_mask
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bvl
)paren
r_goto
id|out_gotit
suffix:semicolon
id|run_task_queue
c_func
(paren
op_amp
id|tq_disk
)paren
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
id|remove_wait_queue
c_func
(paren
op_amp
id|bp-&gt;bp_wait
comma
op_amp
id|wait
)paren
suffix:semicolon
id|__set_current_state
c_func
(paren
id|TASK_RUNNING
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bvl
)paren
(brace
id|out_gotit
suffix:colon
id|memset
c_func
(paren
id|bvl
comma
l_int|0
comma
id|bp-&gt;bp_size
)paren
suffix:semicolon
)brace
r_return
id|bvl
suffix:semicolon
)brace
multiline_comment|/*&n; * default destructor for a bio allocated with bio_alloc()&n; */
DECL|function|bio_destructor
r_void
id|bio_destructor
c_func
(paren
r_struct
id|bio
op_star
id|bio
)paren
(brace
r_struct
id|biovec_pool
op_star
id|bp
op_assign
op_amp
id|bvec_list
(braket
id|bio-&gt;bi_max
)braket
suffix:semicolon
id|BUG_ON
c_func
(paren
id|bio-&gt;bi_max
op_ge
id|BIOVEC_NR_POOLS
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * cloned bio doesn&squot;t own the veclist&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|bio-&gt;bi_flags
op_amp
(paren
l_int|1
op_lshift
id|BIO_CLONED
)paren
)paren
)paren
id|kmem_cache_free
c_func
(paren
id|bp-&gt;bp_cachep
comma
id|bio-&gt;bi_io_vec
)paren
suffix:semicolon
id|bio_pool_put
c_func
(paren
id|bio
)paren
suffix:semicolon
)brace
DECL|function|bio_init
r_inline
r_void
id|bio_init
c_func
(paren
r_struct
id|bio
op_star
id|bio
)paren
(brace
id|bio-&gt;bi_next
op_assign
l_int|NULL
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|bio-&gt;bi_cnt
comma
l_int|1
)paren
suffix:semicolon
id|bio-&gt;bi_flags
op_assign
l_int|0
suffix:semicolon
id|bio-&gt;bi_rw
op_assign
l_int|0
suffix:semicolon
id|bio-&gt;bi_vcnt
op_assign
l_int|0
suffix:semicolon
id|bio-&gt;bi_idx
op_assign
l_int|0
suffix:semicolon
id|bio-&gt;bi_size
op_assign
l_int|0
suffix:semicolon
id|bio-&gt;bi_end_io
op_assign
l_int|NULL
suffix:semicolon
)brace
DECL|function|__bio_alloc
r_static
r_inline
r_struct
id|bio
op_star
id|__bio_alloc
c_func
(paren
r_int
id|gfp_mask
comma
id|bio_destructor_t
op_star
id|dest
)paren
(brace
r_struct
id|bio
op_star
id|bio
suffix:semicolon
multiline_comment|/*&n;&t; * first try our reserved pool&n;&t; */
r_if
c_cond
(paren
(paren
id|bio
op_assign
id|bio_pool_get
c_func
(paren
)paren
)paren
)paren
r_goto
id|gotit
suffix:semicolon
multiline_comment|/*&n;&t; * no such luck, try slab alloc&n;&t; */
r_if
c_cond
(paren
(paren
id|bio
op_assign
id|kmem_cache_alloc
c_func
(paren
id|bio_cachep
comma
id|gfp_mask
)paren
)paren
)paren
r_goto
id|gotit
suffix:semicolon
multiline_comment|/*&n;&t; * hrmpf, not much luck. if we are allowed to wait, wait on&n;&t; * bio_pool to be replenished&n;&t; */
r_if
c_cond
(paren
id|BIO_CAN_WAIT
c_func
(paren
id|gfp_mask
)paren
)paren
(brace
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
id|add_wait_queue_exclusive
c_func
(paren
op_amp
id|bio_pool_wait
comma
op_amp
id|wait
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|set_current_state
c_func
(paren
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bio
op_assign
id|bio_pool_get
c_func
(paren
)paren
)paren
)paren
r_break
suffix:semicolon
id|run_task_queue
c_func
(paren
op_amp
id|tq_disk
)paren
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
id|remove_wait_queue
c_func
(paren
op_amp
id|bio_pool_wait
comma
op_amp
id|wait
)paren
suffix:semicolon
id|__set_current_state
c_func
(paren
id|TASK_RUNNING
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bio
)paren
(brace
id|gotit
suffix:colon
id|bio_init
c_func
(paren
id|bio
)paren
suffix:semicolon
id|bio-&gt;bi_io_vec
op_assign
l_int|NULL
suffix:semicolon
id|bio-&gt;bi_destructor
op_assign
id|dest
suffix:semicolon
)brace
r_return
id|bio
suffix:semicolon
)brace
multiline_comment|/**&n; * bio_alloc - allocate a bio for I/O&n; * @gfp_mask:   the GFP_ mask given to the slab allocator&n; * @nr_iovecs:&t;number of iovecs to pre-allocate&n; *&n; * Description:&n; *   bio_alloc will first try it&squot;s on internal pool to satisfy the allocation&n; *   and if that fails fall back to the bio slab cache. In the latter case,&n; *   the @gfp_mask specifies the priority of the allocation. In particular,&n; *   if %__GFP_WAIT is set then we will block on the internal pool waiting&n; *   for a &amp;struct bio to become free.&n; **/
DECL|function|bio_alloc
r_struct
id|bio
op_star
id|bio_alloc
c_func
(paren
r_int
id|gfp_mask
comma
r_int
id|nr_iovecs
)paren
(brace
r_struct
id|bio
op_star
id|bio
op_assign
id|__bio_alloc
c_func
(paren
id|gfp_mask
comma
id|bio_destructor
)paren
suffix:semicolon
r_struct
id|bio_vec
op_star
id|bvl
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|bio
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|nr_iovecs
op_logical_or
(paren
id|bvl
op_assign
id|bvec_alloc
c_func
(paren
id|gfp_mask
comma
id|nr_iovecs
comma
op_amp
id|bio-&gt;bi_max
)paren
)paren
)paren
(brace
id|bio-&gt;bi_io_vec
op_assign
id|bvl
suffix:semicolon
r_return
id|bio
suffix:semicolon
)brace
id|bio_pool_put
c_func
(paren
id|bio
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * queue lock assumed held!&n; */
DECL|function|bio_free
r_static
r_inline
r_void
id|bio_free
c_func
(paren
r_struct
id|bio
op_star
id|bio
)paren
(brace
id|bio
op_member_access_from_pointer
id|bi_destructor
c_func
(paren
id|bio
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * bio_put - release a reference to a bio&n; * @bio:   bio to release reference to&n; *&n; * Description:&n; *   Put a reference to a &amp;struct bio, either one you have gotten with&n; *   bio_alloc or bio_get. The last put of a bio will free it.&n; **/
DECL|function|bio_put
r_void
id|bio_put
c_func
(paren
r_struct
id|bio
op_star
id|bio
)paren
(brace
id|BUG_ON
c_func
(paren
op_logical_neg
id|atomic_read
c_func
(paren
op_amp
id|bio-&gt;bi_cnt
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * last put frees it&n;&t; */
r_if
c_cond
(paren
id|atomic_dec_and_test
c_func
(paren
op_amp
id|bio-&gt;bi_cnt
)paren
)paren
(brace
id|BUG_ON
c_func
(paren
id|bio-&gt;bi_next
)paren
suffix:semicolon
id|bio_free
c_func
(paren
id|bio
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; *&t;bio_clone&t;-&t;duplicate a bio&n; *&t;@bio: bio to clone&n; *&t;@gfp_mask: allocation priority&n; *&n; *&t;Duplicate a &amp;bio. Caller will own the returned bio, but not&n; *&t;the actual data it points to. Reference count of returned&n; * &t;bio will be one.&n; */
DECL|function|bio_clone
r_struct
id|bio
op_star
id|bio_clone
c_func
(paren
r_struct
id|bio
op_star
id|bio
comma
r_int
id|gfp_mask
)paren
(brace
r_struct
id|bio
op_star
id|b
op_assign
id|bio_alloc
c_func
(paren
id|gfp_mask
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|b
)paren
(brace
id|b-&gt;bi_io_vec
op_assign
id|bio-&gt;bi_io_vec
suffix:semicolon
id|b-&gt;bi_sector
op_assign
id|bio-&gt;bi_sector
suffix:semicolon
id|b-&gt;bi_dev
op_assign
id|bio-&gt;bi_dev
suffix:semicolon
id|b-&gt;bi_flags
op_or_assign
l_int|1
op_lshift
id|BIO_CLONED
suffix:semicolon
id|b-&gt;bi_rw
op_assign
id|bio-&gt;bi_rw
suffix:semicolon
id|b-&gt;bi_vcnt
op_assign
id|bio-&gt;bi_vcnt
suffix:semicolon
id|b-&gt;bi_idx
op_assign
id|bio-&gt;bi_idx
suffix:semicolon
id|b-&gt;bi_size
op_assign
id|bio-&gt;bi_size
suffix:semicolon
id|b-&gt;bi_max
op_assign
id|bio-&gt;bi_max
suffix:semicolon
)brace
r_return
id|b
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;bio_copy&t;-&t;create copy of a bio&n; *&t;@bio: bio to copy&n; *&t;@gfp_mask: allocation priority&n; *&t;@copy: copy data to allocated bio&n; *&n; *&t;Create a copy of a &amp;bio. Caller will own the returned bio and&n; *&t;the actual data it points to. Reference count of returned&n; * &t;bio will be one.&n; */
DECL|function|bio_copy
r_struct
id|bio
op_star
id|bio_copy
c_func
(paren
r_struct
id|bio
op_star
id|bio
comma
r_int
id|gfp_mask
comma
r_int
id|copy
)paren
(brace
r_struct
id|bio
op_star
id|b
op_assign
id|bio_alloc
c_func
(paren
id|gfp_mask
comma
id|bio-&gt;bi_vcnt
)paren
suffix:semicolon
r_int
r_int
id|flags
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* gcc silly */
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|b
)paren
(brace
r_struct
id|bio_vec
op_star
id|bv
suffix:semicolon
multiline_comment|/*&n;&t;&t; * iterate iovec list and alloc pages + copy data&n;&t;&t; */
id|bio_for_each_segment
c_func
(paren
id|bv
comma
id|bio
comma
id|i
)paren
(brace
r_struct
id|bio_vec
op_star
id|bbv
op_assign
op_amp
id|b-&gt;bi_io_vec
(braket
id|i
)braket
suffix:semicolon
r_char
op_star
id|vfrom
comma
op_star
id|vto
suffix:semicolon
id|bbv-&gt;bv_page
op_assign
id|alloc_page
c_func
(paren
id|gfp_mask
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bbv-&gt;bv_page
op_eq
l_int|NULL
)paren
r_goto
id|oom
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|copy
)paren
r_goto
id|fill_in
suffix:semicolon
r_if
c_cond
(paren
id|gfp_mask
op_amp
id|__GFP_WAIT
)paren
(brace
id|vfrom
op_assign
id|kmap
c_func
(paren
id|bv-&gt;bv_page
)paren
suffix:semicolon
id|vto
op_assign
id|kmap
c_func
(paren
id|bbv-&gt;bv_page
)paren
suffix:semicolon
)brace
r_else
(brace
id|__save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|__cli
c_func
(paren
)paren
suffix:semicolon
id|vfrom
op_assign
id|kmap_atomic
c_func
(paren
id|bv-&gt;bv_page
comma
id|KM_BIO_IRQ
)paren
suffix:semicolon
id|vto
op_assign
id|kmap_atomic
c_func
(paren
id|bbv-&gt;bv_page
comma
id|KM_BIO_IRQ
)paren
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|vto
op_plus
id|bbv-&gt;bv_offset
comma
id|vfrom
op_plus
id|bv-&gt;bv_offset
comma
id|bv-&gt;bv_len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|gfp_mask
op_amp
id|__GFP_WAIT
)paren
(brace
id|kunmap
c_func
(paren
id|bbv-&gt;bv_page
)paren
suffix:semicolon
id|kunmap
c_func
(paren
id|bv-&gt;bv_page
)paren
suffix:semicolon
)brace
r_else
(brace
id|kunmap_atomic
c_func
(paren
id|vto
comma
id|KM_BIO_IRQ
)paren
suffix:semicolon
id|kunmap_atomic
c_func
(paren
id|vfrom
comma
id|KM_BIO_IRQ
)paren
suffix:semicolon
id|__restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
id|fill_in
suffix:colon
id|bbv-&gt;bv_len
op_assign
id|bv-&gt;bv_len
suffix:semicolon
id|bbv-&gt;bv_offset
op_assign
id|bv-&gt;bv_offset
suffix:semicolon
)brace
id|b-&gt;bi_sector
op_assign
id|bio-&gt;bi_sector
suffix:semicolon
id|b-&gt;bi_dev
op_assign
id|bio-&gt;bi_dev
suffix:semicolon
id|b-&gt;bi_rw
op_assign
id|bio-&gt;bi_rw
suffix:semicolon
id|b-&gt;bi_vcnt
op_assign
id|bio-&gt;bi_vcnt
suffix:semicolon
id|b-&gt;bi_size
op_assign
id|bio-&gt;bi_size
suffix:semicolon
)brace
r_return
id|b
suffix:semicolon
id|oom
suffix:colon
r_while
c_loop
(paren
id|i
op_ge
l_int|0
)paren
(brace
id|__free_page
c_func
(paren
id|b-&gt;bi_io_vec
(braket
id|i
)braket
dot
id|bv_page
)paren
suffix:semicolon
id|i
op_decrement
suffix:semicolon
)brace
id|bio_pool_put
c_func
(paren
id|b
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
macro_line|#ifdef BIO_PAGEIO
DECL|function|bio_end_io_page
r_static
r_int
id|bio_end_io_page
c_func
(paren
r_struct
id|bio
op_star
id|bio
)paren
(brace
r_struct
id|page
op_star
id|page
op_assign
id|bio_page
c_func
(paren
id|bio
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|test_bit
c_func
(paren
id|BIO_UPTODATE
comma
op_amp
id|bio-&gt;bi_flags
)paren
)paren
id|SetPageError
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|PageError
c_func
(paren
id|page
)paren
)paren
id|SetPageUptodate
c_func
(paren
id|page
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Run the hooks that have to be done when a page I/O has completed.&n;&t; */
r_if
c_cond
(paren
id|PageTestandClearDecrAfter
c_func
(paren
id|page
)paren
)paren
id|atomic_dec
c_func
(paren
op_amp
id|nr_async_pages
)paren
suffix:semicolon
id|UnlockPage
c_func
(paren
id|page
)paren
suffix:semicolon
id|bio_put
c_func
(paren
id|bio
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
macro_line|#endif
DECL|function|bio_end_io_kio
r_static
r_int
id|bio_end_io_kio
c_func
(paren
r_struct
id|bio
op_star
id|bio
comma
r_int
id|nr_sectors
)paren
(brace
r_struct
id|kiobuf
op_star
id|kio
op_assign
(paren
r_struct
id|kiobuf
op_star
)paren
id|bio-&gt;bi_private
suffix:semicolon
r_int
id|uptodate
comma
id|done
suffix:semicolon
id|done
op_assign
l_int|0
suffix:semicolon
id|uptodate
op_assign
id|test_bit
c_func
(paren
id|BIO_UPTODATE
comma
op_amp
id|bio-&gt;bi_flags
)paren
suffix:semicolon
r_do
(brace
r_int
id|sectors
op_assign
id|bio-&gt;bi_io_vec
(braket
id|bio-&gt;bi_idx
)braket
dot
id|bv_len
op_rshift
l_int|9
suffix:semicolon
id|nr_sectors
op_sub_assign
id|sectors
suffix:semicolon
id|bio-&gt;bi_idx
op_increment
suffix:semicolon
id|done
op_assign
op_logical_neg
id|end_kio_request
c_func
(paren
id|kio
comma
id|uptodate
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bio-&gt;bi_idx
op_eq
id|bio-&gt;bi_vcnt
)paren
id|done
op_assign
l_int|1
suffix:semicolon
)brace
r_while
c_loop
(paren
op_logical_neg
id|done
op_logical_and
id|nr_sectors
OG
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * all done&n;&t; */
r_if
c_cond
(paren
id|done
)paren
(brace
id|bio_put
c_func
(paren
id|bio
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * obviously doesn&squot;t work for stacking drivers, but ll_rw_blk will split&n; * bio for those&n; */
DECL|function|get_max_segments
r_int
id|get_max_segments
c_func
(paren
id|kdev_t
id|dev
)paren
(brace
r_int
id|segments
op_assign
id|MAX_SEGMENTS
suffix:semicolon
id|request_queue_t
op_star
id|q
suffix:semicolon
r_if
c_cond
(paren
(paren
id|q
op_assign
id|blk_get_queue
c_func
(paren
id|dev
)paren
)paren
)paren
id|segments
op_assign
id|q-&gt;max_segments
suffix:semicolon
r_return
id|segments
suffix:semicolon
)brace
DECL|function|get_max_sectors
r_int
id|get_max_sectors
c_func
(paren
id|kdev_t
id|dev
)paren
(brace
r_int
id|sectors
op_assign
id|MAX_SECTORS
suffix:semicolon
id|request_queue_t
op_star
id|q
suffix:semicolon
r_if
c_cond
(paren
(paren
id|q
op_assign
id|blk_get_queue
c_func
(paren
id|dev
)paren
)paren
)paren
id|sectors
op_assign
id|q-&gt;max_sectors
suffix:semicolon
r_return
id|sectors
suffix:semicolon
)brace
multiline_comment|/**&n; * ll_rw_kio - submit a &amp;struct kiobuf for I/O&n; * @rw:   %READ or %WRITE&n; * @kio:   the kiobuf to do I/O on&n; * @dev:   target device&n; * @sector:   start location on disk&n; *&n; * Description:&n; *   ll_rw_kio will map the page list inside the &amp;struct kiobuf to&n; *   &amp;struct bio and queue them for I/O. The kiobuf given must describe&n; *   a continous range of data, and must be fully prepared for I/O.&n; **/
DECL|function|ll_rw_kio
r_void
id|ll_rw_kio
c_func
(paren
r_int
id|rw
comma
r_struct
id|kiobuf
op_star
id|kio
comma
id|kdev_t
id|dev
comma
id|sector_t
id|sector
)paren
(brace
r_int
id|i
comma
id|offset
comma
id|size
comma
id|err
comma
id|map_i
comma
id|total_nr_pages
comma
id|nr_pages
suffix:semicolon
r_int
id|max_bytes
comma
id|max_segments
suffix:semicolon
r_struct
id|bio_vec
op_star
id|bvec
suffix:semicolon
r_struct
id|bio
op_star
id|bio
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rw
op_amp
id|WRITE
)paren
op_logical_and
id|is_read_only
c_func
(paren
id|dev
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ll_rw_bio: WRITE to ro device %s&bslash;n&quot;
comma
id|kdevname
c_func
(paren
id|dev
)paren
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EPERM
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|kio-&gt;nr_pages
)paren
(brace
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * rudimentary max sectors/segments checks and setup. once we are&n;&t; * sure that drivers can handle requests that cannot be completed in&n;&t; * one go this will die&n;&t; */
id|max_bytes
op_assign
id|get_max_sectors
c_func
(paren
id|dev
)paren
op_lshift
l_int|9
suffix:semicolon
id|max_segments
op_assign
id|get_max_segments
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|max_bytes
op_rshift
id|PAGE_SHIFT
)paren
OL
(paren
id|max_segments
op_plus
l_int|1
)paren
)paren
id|max_segments
op_assign
(paren
id|max_bytes
op_rshift
id|PAGE_SHIFT
)paren
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|max_segments
OG
id|BIO_MAX_PAGES
)paren
id|max_segments
op_assign
id|BIO_MAX_PAGES
suffix:semicolon
multiline_comment|/*&n;&t; * maybe kio is bigger than the max we can easily map into a bio.&n;&t; * if so, split it up in appropriately sized chunks.&n;&t; */
id|total_nr_pages
op_assign
id|kio-&gt;nr_pages
suffix:semicolon
id|offset
op_assign
id|kio-&gt;offset
op_amp
op_complement
id|PAGE_MASK
suffix:semicolon
id|size
op_assign
id|kio-&gt;length
suffix:semicolon
multiline_comment|/*&n;&t; * set I/O count to number of pages for now&n;&t; */
id|atomic_set
c_func
(paren
op_amp
id|kio-&gt;io_count
comma
id|total_nr_pages
)paren
suffix:semicolon
id|map_i
op_assign
l_int|0
suffix:semicolon
id|next_chunk
suffix:colon
r_if
c_cond
(paren
(paren
id|nr_pages
op_assign
id|total_nr_pages
)paren
OG
id|max_segments
)paren
id|nr_pages
op_assign
id|max_segments
suffix:semicolon
multiline_comment|/*&n;&t; * allocate bio and do initial setup&n;&t; */
r_if
c_cond
(paren
(paren
id|bio
op_assign
id|bio_alloc
c_func
(paren
id|GFP_NOIO
comma
id|nr_pages
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|bio-&gt;bi_sector
op_assign
id|sector
suffix:semicolon
id|bio-&gt;bi_dev
op_assign
id|dev
suffix:semicolon
id|bio-&gt;bi_idx
op_assign
l_int|0
suffix:semicolon
id|bio-&gt;bi_end_io
op_assign
id|bio_end_io_kio
suffix:semicolon
id|bio-&gt;bi_private
op_assign
id|kio
suffix:semicolon
id|bvec
op_assign
id|bio-&gt;bi_io_vec
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr_pages
suffix:semicolon
id|i
op_increment
comma
id|bvec
op_increment
comma
id|map_i
op_increment
)paren
(brace
r_int
id|nbytes
op_assign
id|PAGE_SIZE
op_minus
id|offset
suffix:semicolon
r_if
c_cond
(paren
id|nbytes
OG
id|size
)paren
id|nbytes
op_assign
id|size
suffix:semicolon
id|BUG_ON
c_func
(paren
id|kio-&gt;maplist
(braket
id|map_i
)braket
op_eq
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bio-&gt;bi_size
op_plus
id|nbytes
OG
id|max_bytes
)paren
r_goto
id|queue_io
suffix:semicolon
id|bio-&gt;bi_vcnt
op_increment
suffix:semicolon
id|bio-&gt;bi_size
op_add_assign
id|nbytes
suffix:semicolon
id|bvec-&gt;bv_page
op_assign
id|kio-&gt;maplist
(braket
id|map_i
)braket
suffix:semicolon
id|bvec-&gt;bv_len
op_assign
id|nbytes
suffix:semicolon
id|bvec-&gt;bv_offset
op_assign
id|offset
suffix:semicolon
multiline_comment|/*&n;&t;&t; * kiobuf only has an offset into the first page&n;&t;&t; */
id|offset
op_assign
l_int|0
suffix:semicolon
id|sector
op_add_assign
id|nbytes
op_rshift
l_int|9
suffix:semicolon
id|size
op_sub_assign
id|nbytes
suffix:semicolon
id|total_nr_pages
op_decrement
suffix:semicolon
id|kio-&gt;offset
op_add_assign
id|nbytes
suffix:semicolon
)brace
id|queue_io
suffix:colon
r_if
c_cond
(paren
id|bio-&gt;bi_vcnt
OG
l_int|1
)paren
id|bio-&gt;bi_flags
op_or_assign
l_int|1
op_lshift
id|BIO_PREBUILT
suffix:semicolon
id|submit_bio
c_func
(paren
id|rw
comma
id|bio
)paren
suffix:semicolon
r_if
c_cond
(paren
id|total_nr_pages
)paren
r_goto
id|next_chunk
suffix:semicolon
r_if
c_cond
(paren
id|size
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ll_rw_kio: size %d left (kio %d)&bslash;n&quot;
comma
id|size
comma
id|kio-&gt;length
)paren
suffix:semicolon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
id|out
suffix:colon
r_if
c_cond
(paren
id|err
)paren
id|kio-&gt;errno
op_assign
id|err
suffix:semicolon
)brace
DECL|function|bio_endio
r_int
id|bio_endio
c_func
(paren
r_struct
id|bio
op_star
id|bio
comma
r_int
id|uptodate
comma
r_int
id|nr_sectors
)paren
(brace
r_if
c_cond
(paren
id|uptodate
)paren
id|set_bit
c_func
(paren
id|BIO_UPTODATE
comma
op_amp
id|bio-&gt;bi_flags
)paren
suffix:semicolon
r_else
id|clear_bit
c_func
(paren
id|BIO_UPTODATE
comma
op_amp
id|bio-&gt;bi_flags
)paren
suffix:semicolon
r_return
id|bio
op_member_access_from_pointer
id|bi_end_io
c_func
(paren
id|bio
comma
id|nr_sectors
)paren
suffix:semicolon
)brace
DECL|function|bio_init_pool
r_static
r_int
id|__init
id|bio_init_pool
c_func
(paren
r_void
)paren
(brace
r_struct
id|bio
op_star
id|bio
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|BIO_POOL_SIZE
suffix:semicolon
id|i
op_increment
)paren
(brace
id|bio
op_assign
id|kmem_cache_alloc
c_func
(paren
id|bio_cachep
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bio
)paren
id|panic
c_func
(paren
l_string|&quot;bio: cannot init bio pool&bslash;n&quot;
)paren
suffix:semicolon
id|bio_pool_put
c_func
(paren
id|bio
)paren
suffix:semicolon
)brace
r_return
id|i
suffix:semicolon
)brace
DECL|function|biovec_init_pool
r_static
r_void
id|__init
id|biovec_init_pool
c_func
(paren
r_void
)paren
(brace
r_char
id|name
(braket
l_int|16
)braket
suffix:semicolon
r_int
id|i
comma
id|size
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|bvec_list
comma
l_int|0
comma
r_sizeof
(paren
id|bvec_list
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|BIOVEC_NR_POOLS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|biovec_pool
op_star
id|bp
op_assign
op_amp
id|bvec_list
(braket
id|i
)braket
suffix:semicolon
id|size
op_assign
id|bvec_pool_sizes
(braket
id|i
)braket
op_star
r_sizeof
(paren
r_struct
id|bio_vec
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;biovec: init pool %d, %d entries, %d bytes&bslash;n&quot;
comma
id|i
comma
id|bvec_pool_sizes
(braket
id|i
)braket
comma
id|size
)paren
suffix:semicolon
id|snprintf
c_func
(paren
id|name
comma
r_sizeof
(paren
id|name
)paren
op_minus
l_int|1
comma
l_string|&quot;biovec-%d&quot;
comma
id|bvec_pool_sizes
(braket
id|i
)braket
)paren
suffix:semicolon
id|bp-&gt;bp_cachep
op_assign
id|kmem_cache_create
c_func
(paren
id|name
comma
id|size
comma
l_int|0
comma
id|SLAB_HWCACHE_ALIGN
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bp-&gt;bp_cachep
)paren
id|panic
c_func
(paren
l_string|&quot;biovec: can&squot;t init slab pools&bslash;n&quot;
)paren
suffix:semicolon
id|bp-&gt;bp_size
op_assign
id|size
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|bp-&gt;bp_wait
)paren
suffix:semicolon
)brace
)brace
DECL|function|init_bio
r_static
r_int
id|__init
id|init_bio
c_func
(paren
r_void
)paren
(brace
r_int
id|nr
suffix:semicolon
id|bio_cachep
op_assign
id|kmem_cache_create
c_func
(paren
l_string|&quot;bio&quot;
comma
r_sizeof
(paren
r_struct
id|bio
)paren
comma
l_int|0
comma
id|SLAB_HWCACHE_ALIGN
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bio_cachep
)paren
id|panic
c_func
(paren
l_string|&quot;bio: can&squot;t create bio_cachep slab cache&bslash;n&quot;
)paren
suffix:semicolon
id|nr
op_assign
id|bio_init_pool
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;BIO: pool of %d setup, %uKb (%d bytes/bio)&bslash;n&quot;
comma
id|nr
comma
id|nr
op_star
r_sizeof
(paren
r_struct
id|bio
)paren
op_rshift
l_int|10
comma
r_sizeof
(paren
r_struct
id|bio
)paren
)paren
suffix:semicolon
id|biovec_init_pool
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|init_bio
id|module_init
c_func
(paren
id|init_bio
)paren
suffix:semicolon
DECL|variable|bio_alloc
id|EXPORT_SYMBOL
c_func
(paren
id|bio_alloc
)paren
suffix:semicolon
DECL|variable|bio_put
id|EXPORT_SYMBOL
c_func
(paren
id|bio_put
)paren
suffix:semicolon
DECL|variable|ll_rw_kio
id|EXPORT_SYMBOL
c_func
(paren
id|ll_rw_kio
)paren
suffix:semicolon
DECL|variable|bio_endio
id|EXPORT_SYMBOL
c_func
(paren
id|bio_endio
)paren
suffix:semicolon
DECL|variable|bio_init
id|EXPORT_SYMBOL
c_func
(paren
id|bio_init
)paren
suffix:semicolon
DECL|variable|bio_copy
id|EXPORT_SYMBOL
c_func
(paren
id|bio_copy
)paren
suffix:semicolon
DECL|variable|bio_clone
id|EXPORT_SYMBOL
c_func
(paren
id|bio_clone
)paren
suffix:semicolon
eof
