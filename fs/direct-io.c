multiline_comment|/*&n; * fs/direct-io.c&n; *&n; * Copyright (C) 2002, Linus Torvalds.&n; *&n; * O_DIRECT&n; *&n; * 04Jul2002&t;akpm@zip.com.au&n; *&t;&t;Initial version&n; * 11Sep2002&t;janetinc@us.ibm.com&n; * &t;&t;added readv/writev support.&n; * 29Oct2002&t;akpm@zip.com.au&n; *&t;&t;rewrote bio_add_page() support.&n; * 30Oct2002&t;pbadari@us.ibm.com&n; *&t;&t;added support for non-aligned IO.&n; * 06Nov2002&t;pbadari@us.ibm.com&n; *&t;&t;added asynchronous IO support.&n; * 21Jul2003&t;nathans@sgi.com&n; *&t;&t;added IO completion notifier.&n; */
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/highmem.h&gt;
macro_line|#include &lt;linux/pagemap.h&gt;
macro_line|#include &lt;linux/bio.h&gt;
macro_line|#include &lt;linux/wait.h&gt;
macro_line|#include &lt;linux/err.h&gt;
macro_line|#include &lt;linux/blkdev.h&gt;
macro_line|#include &lt;linux/buffer_head.h&gt;
macro_line|#include &lt;linux/rwsem.h&gt;
macro_line|#include &lt;linux/uio.h&gt;
macro_line|#include &lt;asm/atomic.h&gt;
multiline_comment|/*&n; * How many user pages to map in one call to get_user_pages().  This determines&n; * the size of a structure on the stack.&n; */
DECL|macro|DIO_PAGES
mdefine_line|#define DIO_PAGES&t;64
multiline_comment|/*&n; * This code generally works in units of &quot;dio_blocks&quot;.  A dio_block is&n; * somewhere between the hard sector size and the filesystem block size.  it&n; * is determined on a per-invocation basis.   When talking to the filesystem&n; * we need to convert dio_blocks to fs_blocks by scaling the dio_block quantity&n; * down by dio-&gt;blkfactor.  Similarly, fs-blocksize quantities are converted&n; * to bio_block quantities by shifting left by blkfactor.&n; *&n; * If blkfactor is zero then the user&squot;s request was aligned to the filesystem&squot;s&n; * blocksize.&n; *&n; * lock_type is DIO_LOCKING for regular files on direct-IO-naive filesystems.&n; * This determines whether we need to do the fancy locking which prevents&n; * direct-IO from being able to read uninitialised disk blocks.  If its zero&n; * (blockdev) this locking is not done, and if it is DIO_OWN_LOCKING i_sem is&n; * not held for the entire direct write (taken briefly, initially, during a&n; * direct read though, but its never held for the duration of a direct-IO).&n; */
DECL|struct|dio
r_struct
id|dio
(brace
multiline_comment|/* BIO submission state */
DECL|member|bio
r_struct
id|bio
op_star
id|bio
suffix:semicolon
multiline_comment|/* bio under assembly */
DECL|member|inode
r_struct
id|inode
op_star
id|inode
suffix:semicolon
DECL|member|rw
r_int
id|rw
suffix:semicolon
DECL|member|lock_type
r_int
id|lock_type
suffix:semicolon
multiline_comment|/* doesn&squot;t change */
DECL|member|blkbits
r_int
id|blkbits
suffix:semicolon
multiline_comment|/* doesn&squot;t change */
DECL|member|blkfactor
r_int
id|blkfactor
suffix:semicolon
multiline_comment|/* When we&squot;re using an alignment which&n;&t;&t;&t;&t;&t;   is finer than the filesystem&squot;s soft&n;&t;&t;&t;&t;&t;   blocksize, this specifies how much&n;&t;&t;&t;&t;&t;   finer.  blkfactor=2 means 1/4-block&n;&t;&t;&t;&t;&t;   alignment.  Does not change */
DECL|member|start_zero_done
r_int
id|start_zero_done
suffix:semicolon
multiline_comment|/* flag: sub-blocksize zeroing has&n;&t;&t;&t;&t;&t;   been performed at the start of a&n;&t;&t;&t;&t;&t;   write */
DECL|member|pages_in_io
r_int
id|pages_in_io
suffix:semicolon
multiline_comment|/* approximate total IO pages */
DECL|member|size
r_int
id|size
suffix:semicolon
multiline_comment|/* total request size (doesn&squot;t change)*/
DECL|member|block_in_file
id|sector_t
id|block_in_file
suffix:semicolon
multiline_comment|/* Current offset into the underlying&n;&t;&t;&t;&t;&t;   file in dio_block units. */
DECL|member|blocks_available
r_int
id|blocks_available
suffix:semicolon
multiline_comment|/* At block_in_file.  changes */
DECL|member|final_block_in_request
id|sector_t
id|final_block_in_request
suffix:semicolon
multiline_comment|/* doesn&squot;t change */
DECL|member|first_block_in_page
r_int
id|first_block_in_page
suffix:semicolon
multiline_comment|/* doesn&squot;t change, Used only once */
DECL|member|boundary
r_int
id|boundary
suffix:semicolon
multiline_comment|/* prev block is at a boundary */
DECL|member|reap_counter
r_int
id|reap_counter
suffix:semicolon
multiline_comment|/* rate limit reaping */
DECL|member|get_blocks
id|get_blocks_t
op_star
id|get_blocks
suffix:semicolon
multiline_comment|/* block mapping function */
DECL|member|end_io
id|dio_iodone_t
op_star
id|end_io
suffix:semicolon
multiline_comment|/* IO completion function */
DECL|member|final_block_in_bio
id|sector_t
id|final_block_in_bio
suffix:semicolon
multiline_comment|/* current final block in bio + 1 */
DECL|member|next_block_for_io
id|sector_t
id|next_block_for_io
suffix:semicolon
multiline_comment|/* next block to be put under IO,&n;&t;&t;&t;&t;&t;   in dio_blocks units */
DECL|member|map_bh
r_struct
id|buffer_head
id|map_bh
suffix:semicolon
multiline_comment|/* last get_blocks() result */
multiline_comment|/*&n;&t; * Deferred addition of a page to the dio.  These variables are&n;&t; * private to dio_send_cur_page(), submit_page_section() and&n;&t; * dio_bio_add_page().&n;&t; */
DECL|member|cur_page
r_struct
id|page
op_star
id|cur_page
suffix:semicolon
multiline_comment|/* The page */
DECL|member|cur_page_offset
r_int
id|cur_page_offset
suffix:semicolon
multiline_comment|/* Offset into it, in bytes */
DECL|member|cur_page_len
r_int
id|cur_page_len
suffix:semicolon
multiline_comment|/* Nr of bytes at cur_page_offset */
DECL|member|cur_page_block
id|sector_t
id|cur_page_block
suffix:semicolon
multiline_comment|/* Where it starts */
multiline_comment|/*&n;&t; * Page fetching state. These variables belong to dio_refill_pages().&n;&t; */
DECL|member|curr_page
r_int
id|curr_page
suffix:semicolon
multiline_comment|/* changes */
DECL|member|total_pages
r_int
id|total_pages
suffix:semicolon
multiline_comment|/* doesn&squot;t change */
DECL|member|curr_user_address
r_int
r_int
id|curr_user_address
suffix:semicolon
multiline_comment|/* changes */
multiline_comment|/*&n;&t; * Page queue.  These variables belong to dio_refill_pages() and&n;&t; * dio_get_page().&n;&t; */
DECL|member|pages
r_struct
id|page
op_star
id|pages
(braket
id|DIO_PAGES
)braket
suffix:semicolon
multiline_comment|/* page buffer */
DECL|member|head
r_int
id|head
suffix:semicolon
multiline_comment|/* next page to process */
DECL|member|tail
r_int
id|tail
suffix:semicolon
multiline_comment|/* last valid page + 1 */
DECL|member|page_errors
r_int
id|page_errors
suffix:semicolon
multiline_comment|/* errno from get_user_pages() */
multiline_comment|/* BIO completion state */
DECL|member|bio_lock
id|spinlock_t
id|bio_lock
suffix:semicolon
multiline_comment|/* protects BIO fields below */
DECL|member|bio_count
r_int
id|bio_count
suffix:semicolon
multiline_comment|/* nr bios to be completed */
DECL|member|bios_in_flight
r_int
id|bios_in_flight
suffix:semicolon
multiline_comment|/* nr bios in flight */
DECL|member|bio_list
r_struct
id|bio
op_star
id|bio_list
suffix:semicolon
multiline_comment|/* singly linked via bi_private */
DECL|member|waiter
r_struct
id|task_struct
op_star
id|waiter
suffix:semicolon
multiline_comment|/* waiting task (NULL if none) */
multiline_comment|/* AIO related stuff */
DECL|member|iocb
r_struct
id|kiocb
op_star
id|iocb
suffix:semicolon
multiline_comment|/* kiocb */
DECL|member|is_async
r_int
id|is_async
suffix:semicolon
multiline_comment|/* is IO async ? */
DECL|member|result
id|ssize_t
id|result
suffix:semicolon
multiline_comment|/* IO result */
)brace
suffix:semicolon
multiline_comment|/*&n; * How many pages are in the queue?&n; */
DECL|function|dio_pages_present
r_static
r_inline
r_int
id|dio_pages_present
c_func
(paren
r_struct
id|dio
op_star
id|dio
)paren
(brace
r_return
id|dio-&gt;tail
op_minus
id|dio-&gt;head
suffix:semicolon
)brace
multiline_comment|/*&n; * Go grab and pin some userspace pages.   Typically we&squot;ll get 64 at a time.&n; */
DECL|function|dio_refill_pages
r_static
r_int
id|dio_refill_pages
c_func
(paren
r_struct
id|dio
op_star
id|dio
)paren
(brace
r_int
id|ret
suffix:semicolon
r_int
id|nr_pages
suffix:semicolon
id|nr_pages
op_assign
id|min
c_func
(paren
id|dio-&gt;total_pages
op_minus
id|dio-&gt;curr_page
comma
id|DIO_PAGES
)paren
suffix:semicolon
id|down_read
c_func
(paren
op_amp
id|current-&gt;mm-&gt;mmap_sem
)paren
suffix:semicolon
id|ret
op_assign
id|get_user_pages
c_func
(paren
id|current
comma
multiline_comment|/* Task for fault acounting */
id|current-&gt;mm
comma
multiline_comment|/* whose pages? */
id|dio-&gt;curr_user_address
comma
multiline_comment|/* Where from? */
id|nr_pages
comma
multiline_comment|/* How many pages? */
id|dio-&gt;rw
op_eq
id|READ
comma
multiline_comment|/* Write to memory? */
l_int|0
comma
multiline_comment|/* force (?) */
op_amp
id|dio-&gt;pages
(braket
l_int|0
)braket
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* vmas */
id|up_read
c_func
(paren
op_amp
id|current-&gt;mm-&gt;mmap_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
op_logical_and
id|dio-&gt;blocks_available
op_logical_and
(paren
id|dio-&gt;rw
op_eq
id|WRITE
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * A memory fault, but the filesystem has some outstanding&n;&t;&t; * mapped blocks.  We need to use those blocks up to avoid&n;&t;&t; * leaking stale data in the file.&n;&t;&t; */
r_if
c_cond
(paren
id|dio-&gt;page_errors
op_eq
l_int|0
)paren
id|dio-&gt;page_errors
op_assign
id|ret
suffix:semicolon
id|dio-&gt;pages
(braket
l_int|0
)braket
op_assign
id|ZERO_PAGE
c_func
(paren
id|dio-&gt;curr_user_address
)paren
suffix:semicolon
id|dio-&gt;head
op_assign
l_int|0
suffix:semicolon
id|dio-&gt;tail
op_assign
l_int|1
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ret
op_ge
l_int|0
)paren
(brace
id|dio-&gt;curr_user_address
op_add_assign
id|ret
op_star
id|PAGE_SIZE
suffix:semicolon
id|dio-&gt;curr_page
op_add_assign
id|ret
suffix:semicolon
id|dio-&gt;head
op_assign
l_int|0
suffix:semicolon
id|dio-&gt;tail
op_assign
id|ret
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
)brace
id|out
suffix:colon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Get another userspace page.  Returns an ERR_PTR on error.  Pages are&n; * buffered inside the dio so that we can call get_user_pages() against a&n; * decent number of pages, less frequently.  To provide nicer use of the&n; * L1 cache.&n; */
DECL|function|dio_get_page
r_static
r_struct
id|page
op_star
id|dio_get_page
c_func
(paren
r_struct
id|dio
op_star
id|dio
)paren
(brace
r_if
c_cond
(paren
id|dio_pages_present
c_func
(paren
id|dio
)paren
op_eq
l_int|0
)paren
(brace
r_int
id|ret
suffix:semicolon
id|ret
op_assign
id|dio_refill_pages
c_func
(paren
id|dio
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_return
id|ERR_PTR
c_func
(paren
id|ret
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|dio_pages_present
c_func
(paren
id|dio
)paren
op_eq
l_int|0
)paren
suffix:semicolon
)brace
r_return
id|dio-&gt;pages
(braket
id|dio-&gt;head
op_increment
)braket
suffix:semicolon
)brace
multiline_comment|/*&n; * Called when all DIO BIO I/O has been completed - let the filesystem&n; * know, if it registered an interest earlier via get_blocks.  Pass the&n; * private field of the map buffer_head so that filesystems can use it&n; * to hold additional state between get_blocks calls and dio_complete.&n; */
DECL|function|dio_complete
r_static
r_void
id|dio_complete
c_func
(paren
r_struct
id|dio
op_star
id|dio
comma
id|loff_t
id|offset
comma
id|ssize_t
id|bytes
)paren
(brace
r_if
c_cond
(paren
id|dio-&gt;end_io
op_logical_and
id|dio-&gt;result
)paren
id|dio
op_member_access_from_pointer
id|end_io
c_func
(paren
id|dio-&gt;inode
comma
id|offset
comma
id|bytes
comma
id|dio-&gt;map_bh.b_private
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dio-&gt;lock_type
op_eq
id|DIO_LOCKING
)paren
id|up_read
c_func
(paren
op_amp
id|dio-&gt;inode-&gt;i_alloc_sem
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Called when a BIO has been processed.  If the count goes to zero then IO is&n; * complete and we can signal this to the AIO layer.&n; */
DECL|function|finished_one_bio
r_static
r_void
id|finished_one_bio
c_func
(paren
r_struct
id|dio
op_star
id|dio
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|dio-&gt;bio_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dio-&gt;bio_count
op_eq
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|dio-&gt;is_async
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Last reference to the dio is going away.&n;&t;&t;&t; * Drop spinlock and complete the DIO.&n;&t;&t;&t; */
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|dio-&gt;bio_lock
comma
id|flags
)paren
suffix:semicolon
id|dio_complete
c_func
(paren
id|dio
comma
id|dio-&gt;block_in_file
op_lshift
id|dio-&gt;blkbits
comma
id|dio-&gt;result
)paren
suffix:semicolon
multiline_comment|/* Complete AIO later if falling back to buffered i/o */
r_if
c_cond
(paren
id|dio-&gt;result
op_eq
id|dio-&gt;size
op_logical_or
(paren
(paren
id|dio-&gt;rw
op_eq
id|READ
)paren
op_logical_and
id|dio-&gt;result
)paren
)paren
(brace
id|aio_complete
c_func
(paren
id|dio-&gt;iocb
comma
id|dio-&gt;result
comma
l_int|0
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|dio
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * Falling back to buffered&n;&t;&t;&t;&t; */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|dio-&gt;bio_lock
comma
id|flags
)paren
suffix:semicolon
id|dio-&gt;bio_count
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|dio-&gt;waiter
)paren
id|wake_up_process
c_func
(paren
id|dio-&gt;waiter
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|dio-&gt;bio_lock
comma
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
)brace
id|dio-&gt;bio_count
op_decrement
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|dio-&gt;bio_lock
comma
id|flags
)paren
suffix:semicolon
)brace
r_static
r_int
id|dio_bio_complete
c_func
(paren
r_struct
id|dio
op_star
id|dio
comma
r_struct
id|bio
op_star
id|bio
)paren
suffix:semicolon
multiline_comment|/*&n; * Asynchronous IO callback. &n; */
DECL|function|dio_bio_end_aio
r_static
r_int
id|dio_bio_end_aio
c_func
(paren
r_struct
id|bio
op_star
id|bio
comma
r_int
r_int
id|bytes_done
comma
r_int
id|error
)paren
(brace
r_struct
id|dio
op_star
id|dio
op_assign
id|bio-&gt;bi_private
suffix:semicolon
r_if
c_cond
(paren
id|bio-&gt;bi_size
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* cleanup the bio */
id|dio_bio_complete
c_func
(paren
id|dio
comma
id|bio
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * The BIO completion handler simply queues the BIO up for the process-context&n; * handler.&n; *&n; * During I/O bi_private points at the dio.  After I/O, bi_private is used to&n; * implement a singly-linked list of completed BIOs, at dio-&gt;bio_list.&n; */
DECL|function|dio_bio_end_io
r_static
r_int
id|dio_bio_end_io
c_func
(paren
r_struct
id|bio
op_star
id|bio
comma
r_int
r_int
id|bytes_done
comma
r_int
id|error
)paren
(brace
r_struct
id|dio
op_star
id|dio
op_assign
id|bio-&gt;bi_private
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|bio-&gt;bi_size
)paren
r_return
l_int|1
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|dio-&gt;bio_lock
comma
id|flags
)paren
suffix:semicolon
id|bio-&gt;bi_private
op_assign
id|dio-&gt;bio_list
suffix:semicolon
id|dio-&gt;bio_list
op_assign
id|bio
suffix:semicolon
id|dio-&gt;bios_in_flight
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|dio-&gt;waiter
op_logical_and
id|dio-&gt;bios_in_flight
op_eq
l_int|0
)paren
id|wake_up_process
c_func
(paren
id|dio-&gt;waiter
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|dio-&gt;bio_lock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|dio_bio_alloc
id|dio_bio_alloc
c_func
(paren
r_struct
id|dio
op_star
id|dio
comma
r_struct
id|block_device
op_star
id|bdev
comma
id|sector_t
id|first_sector
comma
r_int
id|nr_vecs
)paren
(brace
r_struct
id|bio
op_star
id|bio
suffix:semicolon
id|bio
op_assign
id|bio_alloc
c_func
(paren
id|GFP_KERNEL
comma
id|nr_vecs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bio
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|bio-&gt;bi_bdev
op_assign
id|bdev
suffix:semicolon
id|bio-&gt;bi_sector
op_assign
id|first_sector
suffix:semicolon
r_if
c_cond
(paren
id|dio-&gt;is_async
)paren
id|bio-&gt;bi_end_io
op_assign
id|dio_bio_end_aio
suffix:semicolon
r_else
id|bio-&gt;bi_end_io
op_assign
id|dio_bio_end_io
suffix:semicolon
id|dio-&gt;bio
op_assign
id|bio
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * In the AIO read case we speculatively dirty the pages before starting IO.&n; * During IO completion, any of these pages which happen to have been written&n; * back will be redirtied by bio_check_pages_dirty().&n; */
DECL|function|dio_bio_submit
r_static
r_void
id|dio_bio_submit
c_func
(paren
r_struct
id|dio
op_star
id|dio
)paren
(brace
r_struct
id|bio
op_star
id|bio
op_assign
id|dio-&gt;bio
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|bio-&gt;bi_private
op_assign
id|dio
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|dio-&gt;bio_lock
comma
id|flags
)paren
suffix:semicolon
id|dio-&gt;bio_count
op_increment
suffix:semicolon
id|dio-&gt;bios_in_flight
op_increment
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|dio-&gt;bio_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dio-&gt;is_async
op_logical_and
id|dio-&gt;rw
op_eq
id|READ
)paren
id|bio_set_pages_dirty
c_func
(paren
id|bio
)paren
suffix:semicolon
id|submit_bio
c_func
(paren
id|dio-&gt;rw
comma
id|bio
)paren
suffix:semicolon
id|dio-&gt;bio
op_assign
l_int|NULL
suffix:semicolon
id|dio-&gt;boundary
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Release any resources in case of a failure&n; */
DECL|function|dio_cleanup
r_static
r_void
id|dio_cleanup
c_func
(paren
r_struct
id|dio
op_star
id|dio
)paren
(brace
r_while
c_loop
(paren
id|dio_pages_present
c_func
(paren
id|dio
)paren
)paren
id|page_cache_release
c_func
(paren
id|dio_get_page
c_func
(paren
id|dio
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Wait for the next BIO to complete.  Remove it and return it.&n; */
DECL|function|dio_await_one
r_static
r_struct
id|bio
op_star
id|dio_await_one
c_func
(paren
r_struct
id|dio
op_star
id|dio
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|bio
op_star
id|bio
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|dio-&gt;bio_lock
comma
id|flags
)paren
suffix:semicolon
r_while
c_loop
(paren
id|dio-&gt;bio_list
op_eq
l_int|NULL
)paren
(brace
id|set_current_state
c_func
(paren
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dio-&gt;bio_list
op_eq
l_int|NULL
)paren
(brace
id|dio-&gt;waiter
op_assign
id|current
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|dio-&gt;bio_lock
comma
id|flags
)paren
suffix:semicolon
id|blk_run_address_space
c_func
(paren
id|dio-&gt;inode-&gt;i_mapping
)paren
suffix:semicolon
id|io_schedule
c_func
(paren
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|dio-&gt;bio_lock
comma
id|flags
)paren
suffix:semicolon
id|dio-&gt;waiter
op_assign
l_int|NULL
suffix:semicolon
)brace
id|set_current_state
c_func
(paren
id|TASK_RUNNING
)paren
suffix:semicolon
)brace
id|bio
op_assign
id|dio-&gt;bio_list
suffix:semicolon
id|dio-&gt;bio_list
op_assign
id|bio-&gt;bi_private
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|dio-&gt;bio_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|bio
suffix:semicolon
)brace
multiline_comment|/*&n; * Process one completed BIO.  No locks are held.&n; */
DECL|function|dio_bio_complete
r_static
r_int
id|dio_bio_complete
c_func
(paren
r_struct
id|dio
op_star
id|dio
comma
r_struct
id|bio
op_star
id|bio
)paren
(brace
r_const
r_int
id|uptodate
op_assign
id|test_bit
c_func
(paren
id|BIO_UPTODATE
comma
op_amp
id|bio-&gt;bi_flags
)paren
suffix:semicolon
r_struct
id|bio_vec
op_star
id|bvec
op_assign
id|bio-&gt;bi_io_vec
suffix:semicolon
r_int
id|page_no
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|uptodate
)paren
id|dio-&gt;result
op_assign
op_minus
id|EIO
suffix:semicolon
r_if
c_cond
(paren
id|dio-&gt;is_async
op_logical_and
id|dio-&gt;rw
op_eq
id|READ
)paren
(brace
id|bio_check_pages_dirty
c_func
(paren
id|bio
)paren
suffix:semicolon
multiline_comment|/* transfers ownership */
)brace
r_else
(brace
r_for
c_loop
(paren
id|page_no
op_assign
l_int|0
suffix:semicolon
id|page_no
OL
id|bio-&gt;bi_vcnt
suffix:semicolon
id|page_no
op_increment
)paren
(brace
r_struct
id|page
op_star
id|page
op_assign
id|bvec
(braket
id|page_no
)braket
dot
id|bv_page
suffix:semicolon
r_if
c_cond
(paren
id|dio-&gt;rw
op_eq
id|READ
op_logical_and
op_logical_neg
id|PageCompound
c_func
(paren
id|page
)paren
)paren
id|set_page_dirty_lock
c_func
(paren
id|page
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
id|bio_put
c_func
(paren
id|bio
)paren
suffix:semicolon
)brace
id|finished_one_bio
c_func
(paren
id|dio
)paren
suffix:semicolon
r_return
id|uptodate
ques
c_cond
l_int|0
suffix:colon
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/*&n; * Wait on and process all in-flight BIOs.&n; */
DECL|function|dio_await_completion
r_static
r_int
id|dio_await_completion
c_func
(paren
r_struct
id|dio
op_star
id|dio
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|dio-&gt;bio
)paren
id|dio_bio_submit
c_func
(paren
id|dio
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * The bio_lock is not held for the read of bio_count.&n;&t; * This is ok since it is the dio_bio_complete() that changes&n;&t; * bio_count.&n;&t; */
r_while
c_loop
(paren
id|dio-&gt;bio_count
)paren
(brace
r_struct
id|bio
op_star
id|bio
op_assign
id|dio_await_one
c_func
(paren
id|dio
)paren
suffix:semicolon
r_int
id|ret2
suffix:semicolon
id|ret2
op_assign
id|dio_bio_complete
c_func
(paren
id|dio
comma
id|bio
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
id|ret
op_assign
id|ret2
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * A really large O_DIRECT read or write can generate a lot of BIOs.  So&n; * to keep the memory consumption sane we periodically reap any completed BIOs&n; * during the BIO generation phase.&n; *&n; * This also helps to limit the peak amount of pinned userspace memory.&n; */
DECL|function|dio_bio_reap
r_static
r_int
id|dio_bio_reap
c_func
(paren
r_struct
id|dio
op_star
id|dio
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|dio-&gt;reap_counter
op_increment
op_ge
l_int|64
)paren
(brace
r_while
c_loop
(paren
id|dio-&gt;bio_list
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|bio
op_star
id|bio
suffix:semicolon
r_int
id|ret2
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|dio-&gt;bio_lock
comma
id|flags
)paren
suffix:semicolon
id|bio
op_assign
id|dio-&gt;bio_list
suffix:semicolon
id|dio-&gt;bio_list
op_assign
id|bio-&gt;bi_private
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|dio-&gt;bio_lock
comma
id|flags
)paren
suffix:semicolon
id|ret2
op_assign
id|dio_bio_complete
c_func
(paren
id|dio
comma
id|bio
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
id|ret
op_assign
id|ret2
suffix:semicolon
)brace
id|dio-&gt;reap_counter
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Call into the fs to map some more disk blocks.  We record the current number&n; * of available blocks at dio-&gt;blocks_available.  These are in units of the&n; * fs blocksize, (1 &lt;&lt; inode-&gt;i_blkbits).&n; *&n; * The fs is allowed to map lots of blocks at once.  If it wants to do that,&n; * it uses the passed inode-relative block number as the file offset, as usual.&n; *&n; * get_blocks() is passed the number of i_blkbits-sized blocks which direct_io&n; * has remaining to do.  The fs should not map more than this number of blocks.&n; *&n; * If the fs has mapped a lot of blocks, it should populate bh-&gt;b_size to&n; * indicate how much contiguous disk space has been made available at&n; * bh-&gt;b_blocknr.&n; *&n; * If *any* of the mapped blocks are new, then the fs must set buffer_new().&n; * This isn&squot;t very efficient...&n; *&n; * In the case of filesystem holes: the fs may return an arbitrarily-large&n; * hole by returning an appropriate value in b_size and by clearing&n; * buffer_mapped().  However the direct-io code will only process holes one&n; * block at a time - it will repeatedly call get_blocks() as it walks the hole.&n; */
DECL|function|get_more_blocks
r_static
r_int
id|get_more_blocks
c_func
(paren
r_struct
id|dio
op_star
id|dio
)paren
(brace
r_int
id|ret
suffix:semicolon
r_struct
id|buffer_head
op_star
id|map_bh
op_assign
op_amp
id|dio-&gt;map_bh
suffix:semicolon
id|sector_t
id|fs_startblk
suffix:semicolon
multiline_comment|/* Into file, in filesystem-sized blocks */
r_int
r_int
id|fs_count
suffix:semicolon
multiline_comment|/* Number of filesystem-sized blocks */
r_int
r_int
id|dio_count
suffix:semicolon
multiline_comment|/* Number of dio_block-sized blocks */
r_int
r_int
id|blkmask
suffix:semicolon
r_int
id|create
suffix:semicolon
multiline_comment|/*&n;&t; * If there was a memory error and we&squot;ve overwritten all the&n;&t; * mapped blocks then we can now return that memory error&n;&t; */
id|ret
op_assign
id|dio-&gt;page_errors
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
id|map_bh-&gt;b_state
op_assign
l_int|0
suffix:semicolon
id|map_bh-&gt;b_size
op_assign
l_int|0
suffix:semicolon
id|BUG_ON
c_func
(paren
id|dio-&gt;block_in_file
op_ge
id|dio-&gt;final_block_in_request
)paren
suffix:semicolon
id|fs_startblk
op_assign
id|dio-&gt;block_in_file
op_rshift
id|dio-&gt;blkfactor
suffix:semicolon
id|dio_count
op_assign
id|dio-&gt;final_block_in_request
op_minus
id|dio-&gt;block_in_file
suffix:semicolon
id|fs_count
op_assign
id|dio_count
op_rshift
id|dio-&gt;blkfactor
suffix:semicolon
id|blkmask
op_assign
(paren
l_int|1
op_lshift
id|dio-&gt;blkfactor
)paren
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|dio_count
op_amp
id|blkmask
)paren
id|fs_count
op_increment
suffix:semicolon
id|create
op_assign
id|dio-&gt;rw
op_eq
id|WRITE
suffix:semicolon
r_if
c_cond
(paren
id|dio-&gt;lock_type
op_eq
id|DIO_LOCKING
)paren
(brace
r_if
c_cond
(paren
id|dio-&gt;block_in_file
OL
(paren
id|i_size_read
c_func
(paren
id|dio-&gt;inode
)paren
op_rshift
id|dio-&gt;blkbits
)paren
)paren
id|create
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|dio-&gt;lock_type
op_eq
id|DIO_NO_LOCKING
)paren
(brace
id|create
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * For writes inside i_size we forbid block creations: only&n;&t;&t; * overwrites are permitted.  We fall back to buffered writes&n;&t;&t; * at a higher level for inside-i_size block-instantiating&n;&t;&t; * writes.&n;&t;&t; */
id|ret
op_assign
(paren
op_star
id|dio-&gt;get_blocks
)paren
(paren
id|dio-&gt;inode
comma
id|fs_startblk
comma
id|fs_count
comma
id|map_bh
comma
id|create
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * There is no bio.  Make one now.&n; */
DECL|function|dio_new_bio
r_static
r_int
id|dio_new_bio
c_func
(paren
r_struct
id|dio
op_star
id|dio
comma
id|sector_t
id|start_sector
)paren
(brace
id|sector_t
id|sector
suffix:semicolon
r_int
id|ret
comma
id|nr_pages
suffix:semicolon
id|ret
op_assign
id|dio_bio_reap
c_func
(paren
id|dio
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_goto
id|out
suffix:semicolon
id|sector
op_assign
id|start_sector
op_lshift
(paren
id|dio-&gt;blkbits
op_minus
l_int|9
)paren
suffix:semicolon
id|nr_pages
op_assign
id|min
c_func
(paren
id|dio-&gt;pages_in_io
comma
id|bio_get_nr_vecs
c_func
(paren
id|dio-&gt;map_bh.b_bdev
)paren
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|nr_pages
op_le
l_int|0
)paren
suffix:semicolon
id|ret
op_assign
id|dio_bio_alloc
c_func
(paren
id|dio
comma
id|dio-&gt;map_bh.b_bdev
comma
id|sector
comma
id|nr_pages
)paren
suffix:semicolon
id|dio-&gt;boundary
op_assign
l_int|0
suffix:semicolon
id|out
suffix:colon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Attempt to put the current chunk of &squot;cur_page&squot; into the current BIO.  If&n; * that was successful then update final_block_in_bio and take a ref against&n; * the just-added page.&n; *&n; * Return zero on success.  Non-zero means the caller needs to start a new BIO.&n; */
DECL|function|dio_bio_add_page
r_static
r_int
id|dio_bio_add_page
c_func
(paren
r_struct
id|dio
op_star
id|dio
)paren
(brace
r_int
id|ret
suffix:semicolon
id|ret
op_assign
id|bio_add_page
c_func
(paren
id|dio-&gt;bio
comma
id|dio-&gt;cur_page
comma
id|dio-&gt;cur_page_len
comma
id|dio-&gt;cur_page_offset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
id|dio-&gt;cur_page_len
)paren
(brace
multiline_comment|/*&n;&t;&t; * Decrement count only, if we are done with this page&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|dio-&gt;cur_page_len
op_plus
id|dio-&gt;cur_page_offset
)paren
op_eq
id|PAGE_SIZE
)paren
id|dio-&gt;pages_in_io
op_decrement
suffix:semicolon
id|page_cache_get
c_func
(paren
id|dio-&gt;cur_page
)paren
suffix:semicolon
id|dio-&gt;final_block_in_bio
op_assign
id|dio-&gt;cur_page_block
op_plus
(paren
id|dio-&gt;cur_page_len
op_rshift
id|dio-&gt;blkbits
)paren
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|ret
op_assign
l_int|1
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Put cur_page under IO.  The section of cur_page which is described by&n; * cur_page_offset,cur_page_len is put into a BIO.  The section of cur_page&n; * starts on-disk at cur_page_block.&n; *&n; * We take a ref against the page here (on behalf of its presence in the bio).&n; *&n; * The caller of this function is responsible for removing cur_page from the&n; * dio, and for dropping the refcount which came from that presence.&n; */
DECL|function|dio_send_cur_page
r_static
r_int
id|dio_send_cur_page
c_func
(paren
r_struct
id|dio
op_star
id|dio
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|dio-&gt;bio
)paren
(brace
multiline_comment|/*&n;&t;&t; * See whether this new request is contiguous with the old&n;&t;&t; */
r_if
c_cond
(paren
id|dio-&gt;final_block_in_bio
op_ne
id|dio-&gt;cur_page_block
)paren
id|dio_bio_submit
c_func
(paren
id|dio
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Submit now if the underlying fs is about to perform a&n;&t;&t; * metadata read&n;&t;&t; */
r_if
c_cond
(paren
id|dio-&gt;boundary
)paren
id|dio_bio_submit
c_func
(paren
id|dio
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dio-&gt;bio
op_eq
l_int|NULL
)paren
(brace
id|ret
op_assign
id|dio_new_bio
c_func
(paren
id|dio
comma
id|dio-&gt;cur_page_block
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dio_bio_add_page
c_func
(paren
id|dio
)paren
op_ne
l_int|0
)paren
(brace
id|dio_bio_submit
c_func
(paren
id|dio
)paren
suffix:semicolon
id|ret
op_assign
id|dio_new_bio
c_func
(paren
id|dio
comma
id|dio-&gt;cur_page_block
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
id|ret
op_assign
id|dio_bio_add_page
c_func
(paren
id|dio
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|ret
op_ne
l_int|0
)paren
suffix:semicolon
)brace
)brace
id|out
suffix:colon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * An autonomous function to put a chunk of a page under deferred IO.&n; *&n; * The caller doesn&squot;t actually know (or care) whether this piece of page is in&n; * a BIO, or is under IO or whatever.  We just take care of all possible &n; * situations here.  The separation between the logic of do_direct_IO() and&n; * that of submit_page_section() is important for clarity.  Please don&squot;t break.&n; *&n; * The chunk of page starts on-disk at blocknr.&n; *&n; * We perform deferred IO, by recording the last-submitted page inside our&n; * private part of the dio structure.  If possible, we just expand the IO&n; * across that page here.&n; *&n; * If that doesn&squot;t work out then we put the old page into the bio and add this&n; * page to the dio instead.&n; */
r_static
r_int
DECL|function|submit_page_section
id|submit_page_section
c_func
(paren
r_struct
id|dio
op_star
id|dio
comma
r_struct
id|page
op_star
id|page
comma
r_int
id|offset
comma
r_int
id|len
comma
id|sector_t
id|blocknr
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Can we just grow the current page&squot;s presence in the dio?&n;&t; */
r_if
c_cond
(paren
(paren
id|dio-&gt;cur_page
op_eq
id|page
)paren
op_logical_and
(paren
id|dio-&gt;cur_page_offset
op_plus
id|dio-&gt;cur_page_len
op_eq
id|offset
)paren
op_logical_and
(paren
id|dio-&gt;cur_page_block
op_plus
(paren
id|dio-&gt;cur_page_len
op_rshift
id|dio-&gt;blkbits
)paren
op_eq
id|blocknr
)paren
)paren
(brace
id|dio-&gt;cur_page_len
op_add_assign
id|len
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If dio-&gt;boundary then we want to schedule the IO now to&n;&t;&t; * avoid metadata seeks.&n;&t;&t; */
r_if
c_cond
(paren
id|dio-&gt;boundary
)paren
(brace
id|ret
op_assign
id|dio_send_cur_page
c_func
(paren
id|dio
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|dio-&gt;cur_page
)paren
suffix:semicolon
id|dio-&gt;cur_page
op_assign
l_int|NULL
suffix:semicolon
)brace
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If there&squot;s a deferred page already there then send it.&n;&t; */
r_if
c_cond
(paren
id|dio-&gt;cur_page
)paren
(brace
id|ret
op_assign
id|dio_send_cur_page
c_func
(paren
id|dio
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|dio-&gt;cur_page
)paren
suffix:semicolon
id|dio-&gt;cur_page
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_goto
id|out
suffix:semicolon
)brace
id|page_cache_get
c_func
(paren
id|page
)paren
suffix:semicolon
multiline_comment|/* It is in dio */
id|dio-&gt;cur_page
op_assign
id|page
suffix:semicolon
id|dio-&gt;cur_page_offset
op_assign
id|offset
suffix:semicolon
id|dio-&gt;cur_page_len
op_assign
id|len
suffix:semicolon
id|dio-&gt;cur_page_block
op_assign
id|blocknr
suffix:semicolon
id|out
suffix:colon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Clean any dirty buffers in the blockdev mapping which alias newly-created&n; * file blocks.  Only called for S_ISREG files - blockdevs do not set&n; * buffer_new&n; */
DECL|function|clean_blockdev_aliases
r_static
r_void
id|clean_blockdev_aliases
c_func
(paren
r_struct
id|dio
op_star
id|dio
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|nblocks
suffix:semicolon
id|nblocks
op_assign
id|dio-&gt;map_bh.b_size
op_rshift
id|dio-&gt;inode-&gt;i_blkbits
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nblocks
suffix:semicolon
id|i
op_increment
)paren
(brace
id|unmap_underlying_metadata
c_func
(paren
id|dio-&gt;map_bh.b_bdev
comma
id|dio-&gt;map_bh.b_blocknr
op_plus
id|i
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * If we are not writing the entire block and get_block() allocated&n; * the block for us, we need to fill-in the unused portion of the&n; * block with zeros. This happens only if user-buffer, fileoffset or&n; * io length is not filesystem block-size multiple.&n; *&n; * `end&squot; is zero if we&squot;re doing the start of the IO, 1 at the end of the&n; * IO.&n; */
DECL|function|dio_zero_block
r_static
r_void
id|dio_zero_block
c_func
(paren
r_struct
id|dio
op_star
id|dio
comma
r_int
id|end
)paren
(brace
r_int
id|dio_blocks_per_fs_block
suffix:semicolon
r_int
id|this_chunk_blocks
suffix:semicolon
multiline_comment|/* In dio_blocks */
r_int
id|this_chunk_bytes
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
id|dio-&gt;start_zero_done
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dio-&gt;blkfactor
op_logical_or
op_logical_neg
id|buffer_new
c_func
(paren
op_amp
id|dio-&gt;map_bh
)paren
)paren
r_return
suffix:semicolon
id|dio_blocks_per_fs_block
op_assign
l_int|1
op_lshift
id|dio-&gt;blkfactor
suffix:semicolon
id|this_chunk_blocks
op_assign
id|dio-&gt;block_in_file
op_amp
(paren
id|dio_blocks_per_fs_block
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|this_chunk_blocks
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t; * We need to zero out part of an fs block.  It is either at the&n;&t; * beginning or the end of the fs block.&n;&t; */
r_if
c_cond
(paren
id|end
)paren
id|this_chunk_blocks
op_assign
id|dio_blocks_per_fs_block
op_minus
id|this_chunk_blocks
suffix:semicolon
id|this_chunk_bytes
op_assign
id|this_chunk_blocks
op_lshift
id|dio-&gt;blkbits
suffix:semicolon
id|page
op_assign
id|ZERO_PAGE
c_func
(paren
id|dio-&gt;curr_user_address
)paren
suffix:semicolon
r_if
c_cond
(paren
id|submit_page_section
c_func
(paren
id|dio
comma
id|page
comma
l_int|0
comma
id|this_chunk_bytes
comma
id|dio-&gt;next_block_for_io
)paren
)paren
r_return
suffix:semicolon
id|dio-&gt;next_block_for_io
op_add_assign
id|this_chunk_blocks
suffix:semicolon
)brace
multiline_comment|/*&n; * Walk the user pages, and the file, mapping blocks to disk and generating&n; * a sequence of (page,offset,len,block) mappings.  These mappings are injected&n; * into submit_page_section(), which takes care of the next stage of submission&n; *&n; * Direct IO against a blockdev is different from a file.  Because we can&n; * happily perform page-sized but 512-byte aligned IOs.  It is important that&n; * blockdev IO be able to have fine alignment and large sizes.&n; *&n; * So what we do is to permit the -&gt;get_blocks function to populate bh.b_size&n; * with the size of IO which is permitted at this offset and this i_blkbits.&n; *&n; * For best results, the blockdev should be set up with 512-byte i_blkbits and&n; * it should set b_size to PAGE_SIZE or more inside get_blocks().  This gives&n; * fine alignment but still allows this function to work in PAGE_SIZE units.&n; */
DECL|function|do_direct_IO
r_static
r_int
id|do_direct_IO
c_func
(paren
r_struct
id|dio
op_star
id|dio
)paren
(brace
r_const
r_int
id|blkbits
op_assign
id|dio-&gt;blkbits
suffix:semicolon
r_const
r_int
id|blocks_per_page
op_assign
id|PAGE_SIZE
op_rshift
id|blkbits
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
r_int
id|block_in_page
suffix:semicolon
r_struct
id|buffer_head
op_star
id|map_bh
op_assign
op_amp
id|dio-&gt;map_bh
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* The I/O can start at any block offset within the first page */
id|block_in_page
op_assign
id|dio-&gt;first_block_in_page
suffix:semicolon
r_while
c_loop
(paren
id|dio-&gt;block_in_file
OL
id|dio-&gt;final_block_in_request
)paren
(brace
id|page
op_assign
id|dio_get_page
c_func
(paren
id|dio
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|page
)paren
)paren
(brace
id|ret
op_assign
id|PTR_ERR
c_func
(paren
id|page
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_while
c_loop
(paren
id|block_in_page
OL
id|blocks_per_page
)paren
(brace
r_int
id|offset_in_page
op_assign
id|block_in_page
op_lshift
id|blkbits
suffix:semicolon
r_int
id|this_chunk_bytes
suffix:semicolon
multiline_comment|/* # of bytes mapped */
r_int
id|this_chunk_blocks
suffix:semicolon
multiline_comment|/* # of blocks */
r_int
id|u
suffix:semicolon
r_if
c_cond
(paren
id|dio-&gt;blocks_available
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * Need to go and map some more disk&n;&t;&t;&t;&t; */
r_int
r_int
id|blkmask
suffix:semicolon
r_int
r_int
id|dio_remainder
suffix:semicolon
id|ret
op_assign
id|get_more_blocks
c_func
(paren
id|dio
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|buffer_mapped
c_func
(paren
id|map_bh
)paren
)paren
r_goto
id|do_holes
suffix:semicolon
id|dio-&gt;blocks_available
op_assign
id|map_bh-&gt;b_size
op_rshift
id|dio-&gt;blkbits
suffix:semicolon
id|dio-&gt;next_block_for_io
op_assign
id|map_bh-&gt;b_blocknr
op_lshift
id|dio-&gt;blkfactor
suffix:semicolon
r_if
c_cond
(paren
id|buffer_new
c_func
(paren
id|map_bh
)paren
)paren
id|clean_blockdev_aliases
c_func
(paren
id|dio
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dio-&gt;blkfactor
)paren
r_goto
id|do_holes
suffix:semicolon
id|blkmask
op_assign
(paren
l_int|1
op_lshift
id|dio-&gt;blkfactor
)paren
op_minus
l_int|1
suffix:semicolon
id|dio_remainder
op_assign
(paren
id|dio-&gt;block_in_file
op_amp
id|blkmask
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * If we are at the start of IO and that IO&n;&t;&t;&t;&t; * starts partway into a fs-block,&n;&t;&t;&t;&t; * dio_remainder will be non-zero.  If the IO&n;&t;&t;&t;&t; * is a read then we can simply advance the IO&n;&t;&t;&t;&t; * cursor to the first block which is to be&n;&t;&t;&t;&t; * read.  But if the IO is a write and the&n;&t;&t;&t;&t; * block was newly allocated we cannot do that;&n;&t;&t;&t;&t; * the start of the fs block must be zeroed out&n;&t;&t;&t;&t; * on-disk&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|buffer_new
c_func
(paren
id|map_bh
)paren
)paren
id|dio-&gt;next_block_for_io
op_add_assign
id|dio_remainder
suffix:semicolon
id|dio-&gt;blocks_available
op_sub_assign
id|dio_remainder
suffix:semicolon
)brace
id|do_holes
suffix:colon
multiline_comment|/* Handle holes */
r_if
c_cond
(paren
op_logical_neg
id|buffer_mapped
c_func
(paren
id|map_bh
)paren
)paren
(brace
r_char
op_star
id|kaddr
suffix:semicolon
multiline_comment|/* AKPM: eargh, -ENOTBLK is a hack */
r_if
c_cond
(paren
id|dio-&gt;rw
op_eq
id|WRITE
)paren
(brace
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
op_minus
id|ENOTBLK
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dio-&gt;block_in_file
op_ge
id|i_size_read
c_func
(paren
id|dio-&gt;inode
)paren
op_rshift
id|blkbits
)paren
(brace
multiline_comment|/* We hit eof */
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|kaddr
op_assign
id|kmap_atomic
c_func
(paren
id|page
comma
id|KM_USER0
)paren
suffix:semicolon
id|memset
c_func
(paren
id|kaddr
op_plus
(paren
id|block_in_page
op_lshift
id|blkbits
)paren
comma
l_int|0
comma
l_int|1
op_lshift
id|blkbits
)paren
suffix:semicolon
id|flush_dcache_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|kunmap_atomic
c_func
(paren
id|kaddr
comma
id|KM_USER0
)paren
suffix:semicolon
id|dio-&gt;block_in_file
op_increment
suffix:semicolon
id|block_in_page
op_increment
suffix:semicolon
r_goto
id|next_block
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * If we&squot;re performing IO which has an alignment which&n;&t;&t;&t; * is finer than the underlying fs, go check to see if&n;&t;&t;&t; * we must zero out the start of this block.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|dio-&gt;blkfactor
op_logical_and
op_logical_neg
id|dio-&gt;start_zero_done
)paren
)paren
id|dio_zero_block
c_func
(paren
id|dio
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Work out, in this_chunk_blocks, how much disk we&n;&t;&t;&t; * can add to this page&n;&t;&t;&t; */
id|this_chunk_blocks
op_assign
id|dio-&gt;blocks_available
suffix:semicolon
id|u
op_assign
(paren
id|PAGE_SIZE
op_minus
id|offset_in_page
)paren
op_rshift
id|blkbits
suffix:semicolon
r_if
c_cond
(paren
id|this_chunk_blocks
OG
id|u
)paren
id|this_chunk_blocks
op_assign
id|u
suffix:semicolon
id|u
op_assign
id|dio-&gt;final_block_in_request
op_minus
id|dio-&gt;block_in_file
suffix:semicolon
r_if
c_cond
(paren
id|this_chunk_blocks
OG
id|u
)paren
id|this_chunk_blocks
op_assign
id|u
suffix:semicolon
id|this_chunk_bytes
op_assign
id|this_chunk_blocks
op_lshift
id|blkbits
suffix:semicolon
id|BUG_ON
c_func
(paren
id|this_chunk_bytes
op_eq
l_int|0
)paren
suffix:semicolon
id|dio-&gt;boundary
op_assign
id|buffer_boundary
c_func
(paren
id|map_bh
)paren
suffix:semicolon
id|ret
op_assign
id|submit_page_section
c_func
(paren
id|dio
comma
id|page
comma
id|offset_in_page
comma
id|this_chunk_bytes
comma
id|dio-&gt;next_block_for_io
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|dio-&gt;next_block_for_io
op_add_assign
id|this_chunk_blocks
suffix:semicolon
id|dio-&gt;block_in_file
op_add_assign
id|this_chunk_blocks
suffix:semicolon
id|block_in_page
op_add_assign
id|this_chunk_blocks
suffix:semicolon
id|dio-&gt;blocks_available
op_sub_assign
id|this_chunk_blocks
suffix:semicolon
id|next_block
suffix:colon
r_if
c_cond
(paren
id|dio-&gt;block_in_file
OG
id|dio-&gt;final_block_in_request
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dio-&gt;block_in_file
op_eq
id|dio-&gt;final_block_in_request
)paren
r_break
suffix:semicolon
)brace
multiline_comment|/* Drop the ref which was taken in get_user_pages() */
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
id|block_in_page
op_assign
l_int|0
suffix:semicolon
)brace
id|out
suffix:colon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Releases both i_sem and i_alloc_sem&n; */
r_static
id|ssize_t
DECL|function|direct_io_worker
id|direct_io_worker
c_func
(paren
r_int
id|rw
comma
r_struct
id|kiocb
op_star
id|iocb
comma
r_struct
id|inode
op_star
id|inode
comma
r_const
r_struct
id|iovec
op_star
id|iov
comma
id|loff_t
id|offset
comma
r_int
r_int
id|nr_segs
comma
r_int
id|blkbits
comma
id|get_blocks_t
id|get_blocks
comma
id|dio_iodone_t
id|end_io
comma
r_struct
id|dio
op_star
id|dio
)paren
(brace
r_int
r_int
id|user_addr
suffix:semicolon
r_int
id|seg
suffix:semicolon
id|ssize_t
id|ret
op_assign
l_int|0
suffix:semicolon
id|ssize_t
id|ret2
suffix:semicolon
r_int
id|bytes
suffix:semicolon
id|dio-&gt;bio
op_assign
l_int|NULL
suffix:semicolon
id|dio-&gt;inode
op_assign
id|inode
suffix:semicolon
id|dio-&gt;rw
op_assign
id|rw
suffix:semicolon
id|dio-&gt;blkbits
op_assign
id|blkbits
suffix:semicolon
id|dio-&gt;blkfactor
op_assign
id|inode-&gt;i_blkbits
op_minus
id|blkbits
suffix:semicolon
id|dio-&gt;start_zero_done
op_assign
l_int|0
suffix:semicolon
id|dio-&gt;size
op_assign
l_int|0
suffix:semicolon
id|dio-&gt;block_in_file
op_assign
id|offset
op_rshift
id|blkbits
suffix:semicolon
id|dio-&gt;blocks_available
op_assign
l_int|0
suffix:semicolon
id|dio-&gt;cur_page
op_assign
l_int|NULL
suffix:semicolon
id|dio-&gt;boundary
op_assign
l_int|0
suffix:semicolon
id|dio-&gt;reap_counter
op_assign
l_int|0
suffix:semicolon
id|dio-&gt;get_blocks
op_assign
id|get_blocks
suffix:semicolon
id|dio-&gt;end_io
op_assign
id|end_io
suffix:semicolon
id|dio-&gt;map_bh.b_private
op_assign
l_int|NULL
suffix:semicolon
id|dio-&gt;final_block_in_bio
op_assign
op_minus
l_int|1
suffix:semicolon
id|dio-&gt;next_block_for_io
op_assign
op_minus
l_int|1
suffix:semicolon
id|dio-&gt;page_errors
op_assign
l_int|0
suffix:semicolon
id|dio-&gt;result
op_assign
l_int|0
suffix:semicolon
id|dio-&gt;iocb
op_assign
id|iocb
suffix:semicolon
multiline_comment|/*&n;&t; * BIO completion state.&n;&t; *&n;&t; * -&gt;bio_count starts out at one, and we decrement it to zero after all&n;&t; * BIOs are submitted.  This to avoid the situation where a really fast&n;&t; * (or synchronous) device could take the count to zero while we&squot;re&n;&t; * still submitting BIOs.&n;&t; */
id|dio-&gt;bio_count
op_assign
l_int|1
suffix:semicolon
id|dio-&gt;bios_in_flight
op_assign
l_int|0
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|dio-&gt;bio_lock
)paren
suffix:semicolon
id|dio-&gt;bio_list
op_assign
l_int|NULL
suffix:semicolon
id|dio-&gt;waiter
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * In case of non-aligned buffers, we may need 2 more&n;&t; * pages since we need to zero out first and last block.&n;&t; */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|dio-&gt;blkfactor
)paren
)paren
id|dio-&gt;pages_in_io
op_assign
l_int|2
suffix:semicolon
r_else
id|dio-&gt;pages_in_io
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|seg
op_assign
l_int|0
suffix:semicolon
id|seg
OL
id|nr_segs
suffix:semicolon
id|seg
op_increment
)paren
(brace
id|user_addr
op_assign
(paren
r_int
r_int
)paren
id|iov
(braket
id|seg
)braket
dot
id|iov_base
suffix:semicolon
id|dio-&gt;pages_in_io
op_add_assign
(paren
(paren
id|user_addr
op_plus
id|iov
(braket
id|seg
)braket
dot
id|iov_len
op_plus
id|PAGE_SIZE
op_minus
l_int|1
)paren
op_div
id|PAGE_SIZE
op_minus
id|user_addr
op_div
id|PAGE_SIZE
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|seg
op_assign
l_int|0
suffix:semicolon
id|seg
OL
id|nr_segs
suffix:semicolon
id|seg
op_increment
)paren
(brace
id|user_addr
op_assign
(paren
r_int
r_int
)paren
id|iov
(braket
id|seg
)braket
dot
id|iov_base
suffix:semicolon
id|dio-&gt;size
op_add_assign
id|bytes
op_assign
id|iov
(braket
id|seg
)braket
dot
id|iov_len
suffix:semicolon
multiline_comment|/* Index into the first page of the first block */
id|dio-&gt;first_block_in_page
op_assign
(paren
id|user_addr
op_amp
op_complement
id|PAGE_MASK
)paren
op_rshift
id|blkbits
suffix:semicolon
id|dio-&gt;final_block_in_request
op_assign
id|dio-&gt;block_in_file
op_plus
(paren
id|bytes
op_rshift
id|blkbits
)paren
suffix:semicolon
multiline_comment|/* Page fetching state */
id|dio-&gt;head
op_assign
l_int|0
suffix:semicolon
id|dio-&gt;tail
op_assign
l_int|0
suffix:semicolon
id|dio-&gt;curr_page
op_assign
l_int|0
suffix:semicolon
id|dio-&gt;total_pages
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|user_addr
op_amp
(paren
id|PAGE_SIZE
op_minus
l_int|1
)paren
)paren
(brace
id|dio-&gt;total_pages
op_increment
suffix:semicolon
id|bytes
op_sub_assign
id|PAGE_SIZE
op_minus
(paren
id|user_addr
op_amp
(paren
id|PAGE_SIZE
op_minus
l_int|1
)paren
)paren
suffix:semicolon
)brace
id|dio-&gt;total_pages
op_add_assign
(paren
id|bytes
op_plus
id|PAGE_SIZE
op_minus
l_int|1
)paren
op_div
id|PAGE_SIZE
suffix:semicolon
id|dio-&gt;curr_user_address
op_assign
id|user_addr
suffix:semicolon
id|ret
op_assign
id|do_direct_IO
c_func
(paren
id|dio
)paren
suffix:semicolon
id|dio-&gt;result
op_add_assign
id|iov
(braket
id|seg
)braket
dot
id|iov_len
op_minus
(paren
(paren
id|dio-&gt;final_block_in_request
op_minus
id|dio-&gt;block_in_file
)paren
op_lshift
id|blkbits
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|dio_cleanup
c_func
(paren
id|dio
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* end iovec loop */
r_if
c_cond
(paren
id|ret
op_eq
op_minus
id|ENOTBLK
op_logical_and
id|rw
op_eq
id|WRITE
)paren
(brace
multiline_comment|/*&n;&t;&t; * The remaining part of the request will be&n;&t;&t; * be handled by buffered I/O when we return&n;&t;&t; */
id|ret
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * There may be some unwritten disk at the end of a part-written&n;&t; * fs-block-sized block.  Go zero that now.&n;&t; */
id|dio_zero_block
c_func
(paren
id|dio
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dio-&gt;cur_page
)paren
(brace
id|ret2
op_assign
id|dio_send_cur_page
c_func
(paren
id|dio
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
id|ret
op_assign
id|ret2
suffix:semicolon
id|page_cache_release
c_func
(paren
id|dio-&gt;cur_page
)paren
suffix:semicolon
id|dio-&gt;cur_page
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dio-&gt;bio
)paren
id|dio_bio_submit
c_func
(paren
id|dio
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * It is possible that, we return short IO due to end of file.&n;&t; * In that case, we need to release all the pages we got hold on.&n;&t; */
id|dio_cleanup
c_func
(paren
id|dio
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * All block lookups have been performed. For READ requests&n;&t; * we can let i_sem go now that its achieved its purpose&n;&t; * of protecting us from looking up uninitialized blocks.&n;&t; */
r_if
c_cond
(paren
(paren
id|rw
op_eq
id|READ
)paren
op_logical_and
(paren
id|dio-&gt;lock_type
op_eq
id|DIO_LOCKING
)paren
)paren
id|up
c_func
(paren
op_amp
id|dio-&gt;inode-&gt;i_sem
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * OK, all BIOs are submitted, so we can decrement bio_count to truly&n;&t; * reflect the number of to-be-processed BIOs.&n;&t; */
r_if
c_cond
(paren
id|dio-&gt;is_async
)paren
(brace
r_int
id|should_wait
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|dio-&gt;result
OL
id|dio-&gt;size
op_logical_and
id|rw
op_eq
id|WRITE
)paren
(brace
id|dio-&gt;waiter
op_assign
id|current
suffix:semicolon
id|should_wait
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
id|ret
op_assign
id|dio-&gt;result
suffix:semicolon
id|finished_one_bio
c_func
(paren
id|dio
)paren
suffix:semicolon
multiline_comment|/* This can free the dio */
id|blk_run_address_space
c_func
(paren
id|inode-&gt;i_mapping
)paren
suffix:semicolon
r_if
c_cond
(paren
id|should_wait
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Wait for already issued I/O to drain out and&n;&t;&t;&t; * release its references to user-space pages&n;&t;&t;&t; * before returning to fallback on buffered I/O&n;&t;&t;&t; */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|dio-&gt;bio_lock
comma
id|flags
)paren
suffix:semicolon
id|set_current_state
c_func
(paren
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
r_while
c_loop
(paren
id|dio-&gt;bio_count
)paren
(brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|dio-&gt;bio_lock
comma
id|flags
)paren
suffix:semicolon
id|io_schedule
c_func
(paren
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|dio-&gt;bio_lock
comma
id|flags
)paren
suffix:semicolon
id|set_current_state
c_func
(paren
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|dio-&gt;bio_lock
comma
id|flags
)paren
suffix:semicolon
id|set_current_state
c_func
(paren
id|TASK_RUNNING
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|dio
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|ssize_t
id|transferred
op_assign
l_int|0
suffix:semicolon
id|finished_one_bio
c_func
(paren
id|dio
)paren
suffix:semicolon
id|ret2
op_assign
id|dio_await_completion
c_func
(paren
id|dio
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
id|ret
op_assign
id|ret2
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
id|ret
op_assign
id|dio-&gt;page_errors
suffix:semicolon
r_if
c_cond
(paren
id|dio-&gt;result
)paren
(brace
id|loff_t
id|i_size
op_assign
id|i_size_read
c_func
(paren
id|inode
)paren
suffix:semicolon
id|transferred
op_assign
id|dio-&gt;result
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Adjust the return value if the read crossed a&n;&t;&t;&t; * non-block-aligned EOF.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|rw
op_eq
id|READ
op_logical_and
(paren
id|offset
op_plus
id|transferred
OG
id|i_size
)paren
)paren
id|transferred
op_assign
id|i_size
op_minus
id|offset
suffix:semicolon
)brace
id|dio_complete
c_func
(paren
id|dio
comma
id|offset
comma
id|transferred
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
id|ret
op_assign
id|transferred
suffix:semicolon
multiline_comment|/* We could have also come here on an AIO file extend */
r_if
c_cond
(paren
op_logical_neg
id|is_sync_kiocb
c_func
(paren
id|iocb
)paren
op_logical_and
id|rw
op_eq
id|WRITE
op_logical_and
id|ret
op_ge
l_int|0
op_logical_and
id|dio-&gt;result
op_eq
id|dio-&gt;size
)paren
multiline_comment|/*&n;&t;&t;&t; * For AIO writes where we have completed the&n;&t;&t;&t; * i/o, we have to mark the the aio complete.&n;&t;&t;&t; */
id|aio_complete
c_func
(paren
id|iocb
comma
id|ret
comma
l_int|0
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|dio
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * This is a library function for use by filesystem drivers.&n; * The locking rules are governed by the dio_lock_type parameter.&n; *&n; * DIO_NO_LOCKING (no locking, for raw block device access)&n; * For writes, i_sem is not held on entry; it is never taken.&n; *&n; * DIO_LOCKING (simple locking for regular files)&n; * For writes we are called under i_sem and return with i_sem held, even though&n; * it is internally dropped.&n; * For reads, i_sem is not held on entry, but it is taken and dropped before&n; * returning.&n; *&n; * DIO_OWN_LOCKING (filesystem provides synchronisation and handling of&n; *&t;uninitialised data, allowing parallel direct readers and writers)&n; * For writes we are called without i_sem, return without it, never touch it.&n; * For reads, i_sem is held on entry and will be released before returning.&n; *&n; * Additional i_alloc_sem locking requirements described inline below.&n; */
id|ssize_t
DECL|function|__blockdev_direct_IO
id|__blockdev_direct_IO
c_func
(paren
r_int
id|rw
comma
r_struct
id|kiocb
op_star
id|iocb
comma
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|block_device
op_star
id|bdev
comma
r_const
r_struct
id|iovec
op_star
id|iov
comma
id|loff_t
id|offset
comma
r_int
r_int
id|nr_segs
comma
id|get_blocks_t
id|get_blocks
comma
id|dio_iodone_t
id|end_io
comma
r_int
id|dio_lock_type
)paren
(brace
r_int
id|seg
suffix:semicolon
r_int
id|size
suffix:semicolon
r_int
r_int
id|addr
suffix:semicolon
r_int
id|blkbits
op_assign
id|inode-&gt;i_blkbits
suffix:semicolon
r_int
id|bdev_blkbits
op_assign
l_int|0
suffix:semicolon
r_int
id|blocksize_mask
op_assign
(paren
l_int|1
op_lshift
id|blkbits
)paren
op_minus
l_int|1
suffix:semicolon
id|ssize_t
id|retval
op_assign
op_minus
id|EINVAL
suffix:semicolon
id|loff_t
id|end
op_assign
id|offset
suffix:semicolon
r_struct
id|dio
op_star
id|dio
suffix:semicolon
r_int
id|reader_with_isem
op_assign
(paren
id|rw
op_eq
id|READ
op_logical_and
id|dio_lock_type
op_eq
id|DIO_OWN_LOCKING
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rw
op_amp
id|WRITE
)paren
id|current-&gt;flags
op_or_assign
id|PF_SYNCWRITE
suffix:semicolon
r_if
c_cond
(paren
id|bdev
)paren
id|bdev_blkbits
op_assign
id|blksize_bits
c_func
(paren
id|bdev_hardsect_size
c_func
(paren
id|bdev
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|offset
op_amp
id|blocksize_mask
)paren
(brace
r_if
c_cond
(paren
id|bdev
)paren
id|blkbits
op_assign
id|bdev_blkbits
suffix:semicolon
id|blocksize_mask
op_assign
(paren
l_int|1
op_lshift
id|blkbits
)paren
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|offset
op_amp
id|blocksize_mask
)paren
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* Check the memory alignment.  Blocks cannot straddle pages */
r_for
c_loop
(paren
id|seg
op_assign
l_int|0
suffix:semicolon
id|seg
OL
id|nr_segs
suffix:semicolon
id|seg
op_increment
)paren
(brace
id|addr
op_assign
(paren
r_int
r_int
)paren
id|iov
(braket
id|seg
)braket
dot
id|iov_base
suffix:semicolon
id|size
op_assign
id|iov
(braket
id|seg
)braket
dot
id|iov_len
suffix:semicolon
id|end
op_add_assign
id|size
suffix:semicolon
r_if
c_cond
(paren
(paren
id|addr
op_amp
id|blocksize_mask
)paren
op_logical_or
(paren
id|size
op_amp
id|blocksize_mask
)paren
)paren
(brace
r_if
c_cond
(paren
id|bdev
)paren
id|blkbits
op_assign
id|bdev_blkbits
suffix:semicolon
id|blocksize_mask
op_assign
(paren
l_int|1
op_lshift
id|blkbits
)paren
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|addr
op_amp
id|blocksize_mask
)paren
op_logical_or
(paren
id|size
op_amp
id|blocksize_mask
)paren
)paren
r_goto
id|out
suffix:semicolon
)brace
)brace
id|dio
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|dio
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|retval
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dio
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/*&n;&t; * For block device access DIO_NO_LOCKING is used,&n;&t; *&t;neither readers nor writers do any locking at all&n;&t; * For regular files using DIO_LOCKING,&n;&t; *&t;readers need to grab i_sem and i_alloc_sem&n;&t; *&t;writers need to grab i_alloc_sem only (i_sem is already held)&n;&t; * For regular files using DIO_OWN_LOCKING,&n;&t; *&t;neither readers nor writers take any locks here&n;&t; *&t;(i_sem is already held and release for writers here)&n;&t; */
id|dio-&gt;lock_type
op_assign
id|dio_lock_type
suffix:semicolon
r_if
c_cond
(paren
id|dio_lock_type
op_ne
id|DIO_NO_LOCKING
)paren
(brace
r_if
c_cond
(paren
id|rw
op_eq
id|READ
)paren
(brace
r_struct
id|address_space
op_star
id|mapping
suffix:semicolon
id|mapping
op_assign
id|iocb-&gt;ki_filp-&gt;f_mapping
suffix:semicolon
r_if
c_cond
(paren
id|dio_lock_type
op_ne
id|DIO_OWN_LOCKING
)paren
(brace
id|down
c_func
(paren
op_amp
id|inode-&gt;i_sem
)paren
suffix:semicolon
id|reader_with_isem
op_assign
l_int|1
suffix:semicolon
)brace
id|retval
op_assign
id|filemap_write_and_wait
c_func
(paren
id|mapping
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
(brace
id|kfree
c_func
(paren
id|dio
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dio_lock_type
op_eq
id|DIO_OWN_LOCKING
)paren
(brace
id|up
c_func
(paren
op_amp
id|inode-&gt;i_sem
)paren
suffix:semicolon
id|reader_with_isem
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|dio_lock_type
op_eq
id|DIO_LOCKING
)paren
id|down_read
c_func
(paren
op_amp
id|inode-&gt;i_alloc_sem
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * For file extending writes updating i_size before data&n;&t; * writeouts complete can expose uninitialized blocks. So&n;&t; * even for AIO, we need to wait for i/o to complete before&n;&t; * returning in this case.&n;&t; */
id|dio-&gt;is_async
op_assign
op_logical_neg
id|is_sync_kiocb
c_func
(paren
id|iocb
)paren
op_logical_and
op_logical_neg
(paren
(paren
id|rw
op_eq
id|WRITE
)paren
op_logical_and
(paren
id|end
OG
id|i_size_read
c_func
(paren
id|inode
)paren
)paren
)paren
suffix:semicolon
id|retval
op_assign
id|direct_io_worker
c_func
(paren
id|rw
comma
id|iocb
comma
id|inode
comma
id|iov
comma
id|offset
comma
id|nr_segs
comma
id|blkbits
comma
id|get_blocks
comma
id|end_io
comma
id|dio
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rw
op_eq
id|READ
op_logical_and
id|dio_lock_type
op_eq
id|DIO_LOCKING
)paren
id|reader_with_isem
op_assign
l_int|0
suffix:semicolon
id|out
suffix:colon
r_if
c_cond
(paren
id|reader_with_isem
)paren
id|up
c_func
(paren
op_amp
id|inode-&gt;i_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rw
op_amp
id|WRITE
)paren
id|current-&gt;flags
op_and_assign
op_complement
id|PF_SYNCWRITE
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
DECL|variable|__blockdev_direct_IO
id|EXPORT_SYMBOL
c_func
(paren
id|__blockdev_direct_IO
)paren
suffix:semicolon
eof
