multiline_comment|/*&n; * fs/direct-io.c&n; *&n; * Copyright (C) 2002, Linus Torvalds.&n; *&n; * O_DIRECT&n; *&n; * 04Jul2002&t;akpm@zip.com.au&n; *&t;&t;Initial version&n; * 11Sep2002&t;janetinc@us.ibm.com&n; * &t;&t;added readv/writev support.&n; * 29Oct2002&t;akpm@zip.com.au&n; *&t;&t;rewrote bio_add_page() support.&n; * 30Oct2002&t;pbadari@us.ibm.com&n; *&t;&t;added support for non-aligned IO.&n; * 06Nov2002&t;pbadari@us.ibm.com&n; *&t;&t;added asynchronous IO support.&n; * 21Jul2003&t;nathans@sgi.com&n; *&t;&t;added IO completion notifier.&n; */
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/highmem.h&gt;
macro_line|#include &lt;linux/pagemap.h&gt;
macro_line|#include &lt;linux/bio.h&gt;
macro_line|#include &lt;linux/wait.h&gt;
macro_line|#include &lt;linux/err.h&gt;
macro_line|#include &lt;linux/blkdev.h&gt;
macro_line|#include &lt;linux/buffer_head.h&gt;
macro_line|#include &lt;linux/rwsem.h&gt;
macro_line|#include &lt;linux/uio.h&gt;
macro_line|#include &lt;asm/atomic.h&gt;
multiline_comment|/*&n; * How many user pages to map in one call to get_user_pages().  This determines&n; * the size of a structure on the stack.&n; */
DECL|macro|DIO_PAGES
mdefine_line|#define DIO_PAGES&t;64
multiline_comment|/*&n; * This code generally works in units of &quot;dio_blocks&quot;.  A dio_block is&n; * somewhere between the hard sector size and the filesystem block size.  it&n; * is determined on a per-invocation basis.   When talking to the filesystem&n; * we need to convert dio_blocks to fs_blocks by scaling the dio_block quantity&n; * down by dio-&gt;blkfactor.  Similarly, fs-blocksize quantities are converted&n; * to bio_block quantities by shifting left by blkfactor.&n; *&n; * If blkfactor is zero then the user&squot;s request was aligned to the filesystem&squot;s&n; * blocksize.&n; */
DECL|struct|dio
r_struct
id|dio
(brace
multiline_comment|/* BIO submission state */
DECL|member|bio
r_struct
id|bio
op_star
id|bio
suffix:semicolon
multiline_comment|/* bio under assembly */
DECL|member|inode
r_struct
id|inode
op_star
id|inode
suffix:semicolon
DECL|member|rw
r_int
id|rw
suffix:semicolon
DECL|member|blkbits
r_int
id|blkbits
suffix:semicolon
multiline_comment|/* doesn&squot;t change */
DECL|member|blkfactor
r_int
id|blkfactor
suffix:semicolon
multiline_comment|/* When we&squot;re using an alignment which&n;&t;&t;&t;&t;&t;   is finer than the filesystem&squot;s soft&n;&t;&t;&t;&t;&t;   blocksize, this specifies how much&n;&t;&t;&t;&t;&t;   finer.  blkfactor=2 means 1/4-block&n;&t;&t;&t;&t;&t;   alignment.  Does not change */
DECL|member|start_zero_done
r_int
id|start_zero_done
suffix:semicolon
multiline_comment|/* flag: sub-blocksize zeroing has&n;&t;&t;&t;&t;&t;   been performed at the start of a&n;&t;&t;&t;&t;&t;   write */
DECL|member|pages_in_io
r_int
id|pages_in_io
suffix:semicolon
multiline_comment|/* approximate total IO pages */
DECL|member|block_in_file
id|sector_t
id|block_in_file
suffix:semicolon
multiline_comment|/* Current offset into the underlying&n;&t;&t;&t;&t;&t;   file in dio_block units. */
DECL|member|blocks_available
r_int
id|blocks_available
suffix:semicolon
multiline_comment|/* At block_in_file.  changes */
DECL|member|final_block_in_request
id|sector_t
id|final_block_in_request
suffix:semicolon
multiline_comment|/* doesn&squot;t change */
DECL|member|first_block_in_page
r_int
id|first_block_in_page
suffix:semicolon
multiline_comment|/* doesn&squot;t change, Used only once */
DECL|member|boundary
r_int
id|boundary
suffix:semicolon
multiline_comment|/* prev block is at a boundary */
DECL|member|reap_counter
r_int
id|reap_counter
suffix:semicolon
multiline_comment|/* rate limit reaping */
DECL|member|get_blocks
id|get_blocks_t
op_star
id|get_blocks
suffix:semicolon
multiline_comment|/* block mapping function */
DECL|member|end_io
id|dio_iodone_t
op_star
id|end_io
suffix:semicolon
multiline_comment|/* IO completion function */
DECL|member|final_block_in_bio
id|sector_t
id|final_block_in_bio
suffix:semicolon
multiline_comment|/* current final block in bio + 1 */
DECL|member|next_block_for_io
id|sector_t
id|next_block_for_io
suffix:semicolon
multiline_comment|/* next block to be put under IO,&n;&t;&t;&t;&t;&t;   in dio_blocks units */
DECL|member|map_bh
r_struct
id|buffer_head
id|map_bh
suffix:semicolon
multiline_comment|/* last get_blocks() result */
multiline_comment|/*&n;&t; * Deferred addition of a page to the dio.  These variables are&n;&t; * private to dio_send_cur_page(), submit_page_section() and&n;&t; * dio_bio_add_page().&n;&t; */
DECL|member|cur_page
r_struct
id|page
op_star
id|cur_page
suffix:semicolon
multiline_comment|/* The page */
DECL|member|cur_page_offset
r_int
id|cur_page_offset
suffix:semicolon
multiline_comment|/* Offset into it, in bytes */
DECL|member|cur_page_len
r_int
id|cur_page_len
suffix:semicolon
multiline_comment|/* Nr of bytes at cur_page_offset */
DECL|member|cur_page_block
id|sector_t
id|cur_page_block
suffix:semicolon
multiline_comment|/* Where it starts */
multiline_comment|/*&n;&t; * Page fetching state. These variables belong to dio_refill_pages().&n;&t; */
DECL|member|curr_page
r_int
id|curr_page
suffix:semicolon
multiline_comment|/* changes */
DECL|member|total_pages
r_int
id|total_pages
suffix:semicolon
multiline_comment|/* doesn&squot;t change */
DECL|member|curr_user_address
r_int
r_int
id|curr_user_address
suffix:semicolon
multiline_comment|/* changes */
multiline_comment|/*&n;&t; * Page queue.  These variables belong to dio_refill_pages() and&n;&t; * dio_get_page().&n;&t; */
DECL|member|pages
r_struct
id|page
op_star
id|pages
(braket
id|DIO_PAGES
)braket
suffix:semicolon
multiline_comment|/* page buffer */
DECL|member|head
r_int
id|head
suffix:semicolon
multiline_comment|/* next page to process */
DECL|member|tail
r_int
id|tail
suffix:semicolon
multiline_comment|/* last valid page + 1 */
DECL|member|page_errors
r_int
id|page_errors
suffix:semicolon
multiline_comment|/* errno from get_user_pages() */
multiline_comment|/* BIO completion state */
DECL|member|bio_count
id|atomic_t
id|bio_count
suffix:semicolon
multiline_comment|/* nr bios to be completed */
DECL|member|bios_in_flight
id|atomic_t
id|bios_in_flight
suffix:semicolon
multiline_comment|/* nr bios in flight */
DECL|member|bio_list_lock
id|spinlock_t
id|bio_list_lock
suffix:semicolon
multiline_comment|/* protects bio_list */
DECL|member|bio_list
r_struct
id|bio
op_star
id|bio_list
suffix:semicolon
multiline_comment|/* singly linked via bi_private */
DECL|member|waiter
r_struct
id|task_struct
op_star
id|waiter
suffix:semicolon
multiline_comment|/* waiting task (NULL if none) */
multiline_comment|/* AIO related stuff */
DECL|member|iocb
r_struct
id|kiocb
op_star
id|iocb
suffix:semicolon
multiline_comment|/* kiocb */
DECL|member|is_async
r_int
id|is_async
suffix:semicolon
multiline_comment|/* is IO async ? */
DECL|member|result
r_int
id|result
suffix:semicolon
multiline_comment|/* IO result */
)brace
suffix:semicolon
multiline_comment|/*&n; * How many pages are in the queue?&n; */
DECL|function|dio_pages_present
r_static
r_inline
r_int
id|dio_pages_present
c_func
(paren
r_struct
id|dio
op_star
id|dio
)paren
(brace
r_return
id|dio-&gt;tail
op_minus
id|dio-&gt;head
suffix:semicolon
)brace
multiline_comment|/*&n; * Go grab and pin some userspace pages.   Typically we&squot;ll get 64 at a time.&n; */
DECL|function|dio_refill_pages
r_static
r_int
id|dio_refill_pages
c_func
(paren
r_struct
id|dio
op_star
id|dio
)paren
(brace
r_int
id|ret
suffix:semicolon
r_int
id|nr_pages
suffix:semicolon
id|nr_pages
op_assign
id|min
c_func
(paren
id|dio-&gt;total_pages
op_minus
id|dio-&gt;curr_page
comma
id|DIO_PAGES
)paren
suffix:semicolon
id|down_read
c_func
(paren
op_amp
id|current-&gt;mm-&gt;mmap_sem
)paren
suffix:semicolon
id|ret
op_assign
id|get_user_pages
c_func
(paren
id|current
comma
multiline_comment|/* Task for fault acounting */
id|current-&gt;mm
comma
multiline_comment|/* whose pages? */
id|dio-&gt;curr_user_address
comma
multiline_comment|/* Where from? */
id|nr_pages
comma
multiline_comment|/* How many pages? */
id|dio-&gt;rw
op_eq
id|READ
comma
multiline_comment|/* Write to memory? */
l_int|0
comma
multiline_comment|/* force (?) */
op_amp
id|dio-&gt;pages
(braket
l_int|0
)braket
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* vmas */
id|up_read
c_func
(paren
op_amp
id|current-&gt;mm-&gt;mmap_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
op_logical_and
id|dio-&gt;blocks_available
op_logical_and
(paren
id|dio-&gt;rw
op_eq
id|WRITE
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * A memory fault, but the filesystem has some outstanding&n;&t;&t; * mapped blocks.  We need to use those blocks up to avoid&n;&t;&t; * leaking stale data in the file.&n;&t;&t; */
r_if
c_cond
(paren
id|dio-&gt;page_errors
op_eq
l_int|0
)paren
id|dio-&gt;page_errors
op_assign
id|ret
suffix:semicolon
id|dio-&gt;pages
(braket
l_int|0
)braket
op_assign
id|ZERO_PAGE
c_func
(paren
id|dio-&gt;curr_user_address
)paren
suffix:semicolon
id|dio-&gt;head
op_assign
l_int|0
suffix:semicolon
id|dio-&gt;tail
op_assign
l_int|1
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ret
op_ge
l_int|0
)paren
(brace
id|dio-&gt;curr_user_address
op_add_assign
id|ret
op_star
id|PAGE_SIZE
suffix:semicolon
id|dio-&gt;curr_page
op_add_assign
id|ret
suffix:semicolon
id|dio-&gt;head
op_assign
l_int|0
suffix:semicolon
id|dio-&gt;tail
op_assign
id|ret
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
)brace
id|out
suffix:colon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Get another userspace page.  Returns an ERR_PTR on error.  Pages are&n; * buffered inside the dio so that we can call get_user_pages() against a&n; * decent number of pages, less frequently.  To provide nicer use of the&n; * L1 cache.&n; */
DECL|function|dio_get_page
r_static
r_struct
id|page
op_star
id|dio_get_page
c_func
(paren
r_struct
id|dio
op_star
id|dio
)paren
(brace
r_if
c_cond
(paren
id|dio_pages_present
c_func
(paren
id|dio
)paren
op_eq
l_int|0
)paren
(brace
r_int
id|ret
suffix:semicolon
id|ret
op_assign
id|dio_refill_pages
c_func
(paren
id|dio
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_return
id|ERR_PTR
c_func
(paren
id|ret
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|dio_pages_present
c_func
(paren
id|dio
)paren
op_eq
l_int|0
)paren
suffix:semicolon
)brace
r_return
id|dio-&gt;pages
(braket
id|dio-&gt;head
op_increment
)braket
suffix:semicolon
)brace
multiline_comment|/*&n; * Called when all DIO BIO I/O has been completed - let the filesystem&n; * know, if it registered an interest earlier via get_blocks.  Pass the&n; * private field of the map buffer_head so that filesystems can use it&n; * to hold additional state between get_blocks calls and dio_complete.&n; */
DECL|function|dio_complete
r_static
r_void
id|dio_complete
c_func
(paren
r_struct
id|dio
op_star
id|dio
comma
id|loff_t
id|offset
comma
id|ssize_t
id|bytes
)paren
(brace
r_if
c_cond
(paren
id|dio-&gt;end_io
)paren
id|dio
op_member_access_from_pointer
id|end_io
c_func
(paren
id|dio-&gt;inode
comma
id|offset
comma
id|bytes
comma
id|dio-&gt;map_bh.b_private
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Called when a BIO has been processed.  If the count goes to zero then IO is&n; * complete and we can signal this to the AIO layer.&n; */
DECL|function|finished_one_bio
r_static
r_void
id|finished_one_bio
c_func
(paren
r_struct
id|dio
op_star
id|dio
)paren
(brace
r_if
c_cond
(paren
id|atomic_dec_and_test
c_func
(paren
op_amp
id|dio-&gt;bio_count
)paren
)paren
(brace
r_if
c_cond
(paren
id|dio-&gt;is_async
)paren
(brace
id|dio_complete
c_func
(paren
id|dio
comma
id|dio-&gt;block_in_file
op_lshift
id|dio-&gt;blkbits
comma
id|dio-&gt;result
)paren
suffix:semicolon
id|aio_complete
c_func
(paren
id|dio-&gt;iocb
comma
id|dio-&gt;result
comma
l_int|0
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|dio
)paren
suffix:semicolon
)brace
)brace
)brace
r_static
r_int
id|dio_bio_complete
c_func
(paren
r_struct
id|dio
op_star
id|dio
comma
r_struct
id|bio
op_star
id|bio
)paren
suffix:semicolon
multiline_comment|/*&n; * Asynchronous IO callback. &n; */
DECL|function|dio_bio_end_aio
r_static
r_int
id|dio_bio_end_aio
c_func
(paren
r_struct
id|bio
op_star
id|bio
comma
r_int
r_int
id|bytes_done
comma
r_int
id|error
)paren
(brace
r_struct
id|dio
op_star
id|dio
op_assign
id|bio-&gt;bi_private
suffix:semicolon
r_if
c_cond
(paren
id|bio-&gt;bi_size
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* cleanup the bio */
id|dio_bio_complete
c_func
(paren
id|dio
comma
id|bio
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * The BIO completion handler simply queues the BIO up for the process-context&n; * handler.&n; *&n; * During I/O bi_private points at the dio.  After I/O, bi_private is used to&n; * implement a singly-linked list of completed BIOs, at dio-&gt;bio_list.&n; */
DECL|function|dio_bio_end_io
r_static
r_int
id|dio_bio_end_io
c_func
(paren
r_struct
id|bio
op_star
id|bio
comma
r_int
r_int
id|bytes_done
comma
r_int
id|error
)paren
(brace
r_struct
id|dio
op_star
id|dio
op_assign
id|bio-&gt;bi_private
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|bio-&gt;bi_size
)paren
r_return
l_int|1
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|dio-&gt;bio_list_lock
comma
id|flags
)paren
suffix:semicolon
id|bio-&gt;bi_private
op_assign
id|dio-&gt;bio_list
suffix:semicolon
id|dio-&gt;bio_list
op_assign
id|bio
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|dio-&gt;bios_in_flight
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dio-&gt;waiter
op_logical_and
id|atomic_read
c_func
(paren
op_amp
id|dio-&gt;bios_in_flight
)paren
op_eq
l_int|0
)paren
id|wake_up_process
c_func
(paren
id|dio-&gt;waiter
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|dio-&gt;bio_list_lock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|dio_bio_alloc
id|dio_bio_alloc
c_func
(paren
r_struct
id|dio
op_star
id|dio
comma
r_struct
id|block_device
op_star
id|bdev
comma
id|sector_t
id|first_sector
comma
r_int
id|nr_vecs
)paren
(brace
r_struct
id|bio
op_star
id|bio
suffix:semicolon
id|bio
op_assign
id|bio_alloc
c_func
(paren
id|GFP_KERNEL
comma
id|nr_vecs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bio
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|bio-&gt;bi_bdev
op_assign
id|bdev
suffix:semicolon
id|bio-&gt;bi_sector
op_assign
id|first_sector
suffix:semicolon
r_if
c_cond
(paren
id|dio-&gt;is_async
)paren
id|bio-&gt;bi_end_io
op_assign
id|dio_bio_end_aio
suffix:semicolon
r_else
id|bio-&gt;bi_end_io
op_assign
id|dio_bio_end_io
suffix:semicolon
id|dio-&gt;bio
op_assign
id|bio
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * In the AIO read case we speculatively dirty the pages before starting IO.&n; * During IO completion, any of these pages which happen to have been written&n; * back will be redirtied by bio_check_pages_dirty().&n; */
DECL|function|dio_bio_submit
r_static
r_void
id|dio_bio_submit
c_func
(paren
r_struct
id|dio
op_star
id|dio
)paren
(brace
r_struct
id|bio
op_star
id|bio
op_assign
id|dio-&gt;bio
suffix:semicolon
id|bio-&gt;bi_private
op_assign
id|dio
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|dio-&gt;bio_count
)paren
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|dio-&gt;bios_in_flight
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dio-&gt;is_async
op_logical_and
id|dio-&gt;rw
op_eq
id|READ
)paren
id|bio_set_pages_dirty
c_func
(paren
id|bio
)paren
suffix:semicolon
id|submit_bio
c_func
(paren
id|dio-&gt;rw
comma
id|bio
)paren
suffix:semicolon
id|dio-&gt;bio
op_assign
l_int|NULL
suffix:semicolon
id|dio-&gt;boundary
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Release any resources in case of a failure&n; */
DECL|function|dio_cleanup
r_static
r_void
id|dio_cleanup
c_func
(paren
r_struct
id|dio
op_star
id|dio
)paren
(brace
r_while
c_loop
(paren
id|dio_pages_present
c_func
(paren
id|dio
)paren
)paren
id|page_cache_release
c_func
(paren
id|dio_get_page
c_func
(paren
id|dio
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Wait for the next BIO to complete.  Remove it and return it.&n; */
DECL|function|dio_await_one
r_static
r_struct
id|bio
op_star
id|dio_await_one
c_func
(paren
r_struct
id|dio
op_star
id|dio
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|bio
op_star
id|bio
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|dio-&gt;bio_list_lock
comma
id|flags
)paren
suffix:semicolon
r_while
c_loop
(paren
id|dio-&gt;bio_list
op_eq
l_int|NULL
)paren
(brace
id|set_current_state
c_func
(paren
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dio-&gt;bio_list
op_eq
l_int|NULL
)paren
(brace
id|dio-&gt;waiter
op_assign
id|current
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|dio-&gt;bio_list_lock
comma
id|flags
)paren
suffix:semicolon
id|blk_run_queues
c_func
(paren
)paren
suffix:semicolon
id|io_schedule
c_func
(paren
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|dio-&gt;bio_list_lock
comma
id|flags
)paren
suffix:semicolon
id|dio-&gt;waiter
op_assign
l_int|NULL
suffix:semicolon
)brace
id|set_current_state
c_func
(paren
id|TASK_RUNNING
)paren
suffix:semicolon
)brace
id|bio
op_assign
id|dio-&gt;bio_list
suffix:semicolon
id|dio-&gt;bio_list
op_assign
id|bio-&gt;bi_private
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|dio-&gt;bio_list_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|bio
suffix:semicolon
)brace
multiline_comment|/*&n; * Process one completed BIO.  No locks are held.&n; */
DECL|function|dio_bio_complete
r_static
r_int
id|dio_bio_complete
c_func
(paren
r_struct
id|dio
op_star
id|dio
comma
r_struct
id|bio
op_star
id|bio
)paren
(brace
r_const
r_int
id|uptodate
op_assign
id|test_bit
c_func
(paren
id|BIO_UPTODATE
comma
op_amp
id|bio-&gt;bi_flags
)paren
suffix:semicolon
r_struct
id|bio_vec
op_star
id|bvec
op_assign
id|bio-&gt;bi_io_vec
suffix:semicolon
r_int
id|page_no
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|uptodate
)paren
id|dio-&gt;result
op_assign
op_minus
id|EIO
suffix:semicolon
r_if
c_cond
(paren
id|dio-&gt;is_async
op_logical_and
id|dio-&gt;rw
op_eq
id|READ
)paren
(brace
id|bio_check_pages_dirty
c_func
(paren
id|bio
)paren
suffix:semicolon
multiline_comment|/* transfers ownership */
)brace
r_else
(brace
r_for
c_loop
(paren
id|page_no
op_assign
l_int|0
suffix:semicolon
id|page_no
OL
id|bio-&gt;bi_vcnt
suffix:semicolon
id|page_no
op_increment
)paren
(brace
r_struct
id|page
op_star
id|page
op_assign
id|bvec
(braket
id|page_no
)braket
dot
id|bv_page
suffix:semicolon
r_if
c_cond
(paren
id|dio-&gt;rw
op_eq
id|READ
)paren
id|set_page_dirty_lock
c_func
(paren
id|page
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
id|bio_put
c_func
(paren
id|bio
)paren
suffix:semicolon
)brace
id|finished_one_bio
c_func
(paren
id|dio
)paren
suffix:semicolon
r_return
id|uptodate
ques
c_cond
l_int|0
suffix:colon
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/*&n; * Wait on and process all in-flight BIOs.&n; */
DECL|function|dio_await_completion
r_static
r_int
id|dio_await_completion
c_func
(paren
r_struct
id|dio
op_star
id|dio
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|dio-&gt;bio
)paren
id|dio_bio_submit
c_func
(paren
id|dio
)paren
suffix:semicolon
r_while
c_loop
(paren
id|atomic_read
c_func
(paren
op_amp
id|dio-&gt;bio_count
)paren
)paren
(brace
r_struct
id|bio
op_star
id|bio
op_assign
id|dio_await_one
c_func
(paren
id|dio
)paren
suffix:semicolon
r_int
id|ret2
suffix:semicolon
id|ret2
op_assign
id|dio_bio_complete
c_func
(paren
id|dio
comma
id|bio
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
id|ret
op_assign
id|ret2
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * A really large O_DIRECT read or write can generate a lot of BIOs.  So&n; * to keep the memory consumption sane we periodically reap any completed BIOs&n; * during the BIO generation phase.&n; *&n; * This also helps to limit the peak amount of pinned userspace memory.&n; */
DECL|function|dio_bio_reap
r_static
r_int
id|dio_bio_reap
c_func
(paren
r_struct
id|dio
op_star
id|dio
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|dio-&gt;reap_counter
op_increment
op_ge
l_int|64
)paren
(brace
r_while
c_loop
(paren
id|dio-&gt;bio_list
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|bio
op_star
id|bio
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|dio-&gt;bio_list_lock
comma
id|flags
)paren
suffix:semicolon
id|bio
op_assign
id|dio-&gt;bio_list
suffix:semicolon
id|dio-&gt;bio_list
op_assign
id|bio-&gt;bi_private
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|dio-&gt;bio_list_lock
comma
id|flags
)paren
suffix:semicolon
id|ret
op_assign
id|dio_bio_complete
c_func
(paren
id|dio
comma
id|bio
)paren
suffix:semicolon
)brace
id|dio-&gt;reap_counter
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Call into the fs to map some more disk blocks.  We record the current number&n; * of available blocks at dio-&gt;blocks_available.  These are in units of the&n; * fs blocksize, (1 &lt;&lt; inode-&gt;i_blkbits).&n; *&n; * The fs is allowed to map lots of blocks at once.  If it wants to do that,&n; * it uses the passed inode-relative block number as the file offset, as usual.&n; *&n; * get_blocks() is passed the number of i_blkbits-sized blocks which direct_io&n; * has remaining to do.  The fs should not map more than this number of blocks.&n; *&n; * If the fs has mapped a lot of blocks, it should populate bh-&gt;b_size to&n; * indicate how much contiguous disk space has been made available at&n; * bh-&gt;b_blocknr.&n; *&n; * If *any* of the mapped blocks are new, then the fs must set buffer_new().&n; * This isn&squot;t very efficient...&n; *&n; * In the case of filesystem holes: the fs may return an arbitrarily-large&n; * hole by returning an appropriate value in b_size and by clearing&n; * buffer_mapped().  However the direct-io code will only process holes one&n; * block at a time - it will repeatedly call get_blocks() as it walks the hole.&n; */
DECL|function|get_more_blocks
r_static
r_int
id|get_more_blocks
c_func
(paren
r_struct
id|dio
op_star
id|dio
)paren
(brace
r_int
id|ret
suffix:semicolon
r_struct
id|buffer_head
op_star
id|map_bh
op_assign
op_amp
id|dio-&gt;map_bh
suffix:semicolon
id|sector_t
id|fs_startblk
suffix:semicolon
multiline_comment|/* Into file, in filesystem-sized blocks */
r_int
r_int
id|fs_count
suffix:semicolon
multiline_comment|/* Number of filesystem-sized blocks */
r_int
r_int
id|dio_count
suffix:semicolon
multiline_comment|/* Number of dio_block-sized blocks */
r_int
r_int
id|blkmask
suffix:semicolon
multiline_comment|/*&n;&t; * If there was a memory error and we&squot;ve overwritten all the&n;&t; * mapped blocks then we can now return that memory error&n;&t; */
id|ret
op_assign
id|dio-&gt;page_errors
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
id|map_bh-&gt;b_state
op_assign
l_int|0
suffix:semicolon
id|map_bh-&gt;b_size
op_assign
l_int|0
suffix:semicolon
id|BUG_ON
c_func
(paren
id|dio-&gt;block_in_file
op_ge
id|dio-&gt;final_block_in_request
)paren
suffix:semicolon
id|fs_startblk
op_assign
id|dio-&gt;block_in_file
op_rshift
id|dio-&gt;blkfactor
suffix:semicolon
id|dio_count
op_assign
id|dio-&gt;final_block_in_request
op_minus
id|dio-&gt;block_in_file
suffix:semicolon
id|fs_count
op_assign
id|dio_count
op_rshift
id|dio-&gt;blkfactor
suffix:semicolon
id|blkmask
op_assign
(paren
l_int|1
op_lshift
id|dio-&gt;blkfactor
)paren
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|dio_count
op_amp
id|blkmask
)paren
id|fs_count
op_increment
suffix:semicolon
id|ret
op_assign
(paren
op_star
id|dio-&gt;get_blocks
)paren
(paren
id|dio-&gt;inode
comma
id|fs_startblk
comma
id|fs_count
comma
id|map_bh
comma
id|dio-&gt;rw
op_eq
id|WRITE
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * There is no bio.  Make one now.&n; */
DECL|function|dio_new_bio
r_static
r_int
id|dio_new_bio
c_func
(paren
r_struct
id|dio
op_star
id|dio
comma
id|sector_t
id|start_sector
)paren
(brace
id|sector_t
id|sector
suffix:semicolon
r_int
id|ret
comma
id|nr_pages
suffix:semicolon
id|ret
op_assign
id|dio_bio_reap
c_func
(paren
id|dio
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_goto
id|out
suffix:semicolon
id|sector
op_assign
id|start_sector
op_lshift
(paren
id|dio-&gt;blkbits
op_minus
l_int|9
)paren
suffix:semicolon
id|nr_pages
op_assign
id|min
c_func
(paren
id|dio-&gt;pages_in_io
comma
id|bio_get_nr_vecs
c_func
(paren
id|dio-&gt;map_bh.b_bdev
)paren
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|nr_pages
op_le
l_int|0
)paren
suffix:semicolon
id|ret
op_assign
id|dio_bio_alloc
c_func
(paren
id|dio
comma
id|dio-&gt;map_bh.b_bdev
comma
id|sector
comma
id|nr_pages
)paren
suffix:semicolon
id|dio-&gt;boundary
op_assign
l_int|0
suffix:semicolon
id|out
suffix:colon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Attempt to put the current chunk of &squot;cur_page&squot; into the current BIO.  If&n; * that was successful then update final_block_in_bio and take a ref against&n; * the just-added page.&n; *&n; * Return zero on success.  Non-zero means the caller needs to start a new BIO.&n; */
DECL|function|dio_bio_add_page
r_static
r_int
id|dio_bio_add_page
c_func
(paren
r_struct
id|dio
op_star
id|dio
)paren
(brace
r_int
id|ret
suffix:semicolon
id|ret
op_assign
id|bio_add_page
c_func
(paren
id|dio-&gt;bio
comma
id|dio-&gt;cur_page
comma
id|dio-&gt;cur_page_len
comma
id|dio-&gt;cur_page_offset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
id|dio-&gt;cur_page_len
)paren
(brace
id|dio-&gt;pages_in_io
op_decrement
suffix:semicolon
id|page_cache_get
c_func
(paren
id|dio-&gt;cur_page
)paren
suffix:semicolon
id|dio-&gt;final_block_in_bio
op_assign
id|dio-&gt;cur_page_block
op_plus
(paren
id|dio-&gt;cur_page_len
op_rshift
id|dio-&gt;blkbits
)paren
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|ret
op_assign
l_int|1
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Put cur_page under IO.  The section of cur_page which is described by&n; * cur_page_offset,cur_page_len is put into a BIO.  The section of cur_page&n; * starts on-disk at cur_page_block.&n; *&n; * We take a ref against the page here (on behalf of its presence in the bio).&n; *&n; * The caller of this function is responsible for removing cur_page from the&n; * dio, and for dropping the refcount which came from that presence.&n; */
DECL|function|dio_send_cur_page
r_static
r_int
id|dio_send_cur_page
c_func
(paren
r_struct
id|dio
op_star
id|dio
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|dio-&gt;bio
)paren
(brace
multiline_comment|/*&n;&t;&t; * See whether this new request is contiguous with the old&n;&t;&t; */
r_if
c_cond
(paren
id|dio-&gt;final_block_in_bio
op_ne
id|dio-&gt;cur_page_block
)paren
id|dio_bio_submit
c_func
(paren
id|dio
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Submit now if the underlying fs is about to perform a&n;&t;&t; * metadata read&n;&t;&t; */
r_if
c_cond
(paren
id|dio-&gt;boundary
)paren
id|dio_bio_submit
c_func
(paren
id|dio
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dio-&gt;bio
op_eq
l_int|NULL
)paren
(brace
id|ret
op_assign
id|dio_new_bio
c_func
(paren
id|dio
comma
id|dio-&gt;cur_page_block
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dio_bio_add_page
c_func
(paren
id|dio
)paren
op_ne
l_int|0
)paren
(brace
id|dio_bio_submit
c_func
(paren
id|dio
)paren
suffix:semicolon
id|ret
op_assign
id|dio_new_bio
c_func
(paren
id|dio
comma
id|dio-&gt;cur_page_block
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
id|ret
op_assign
id|dio_bio_add_page
c_func
(paren
id|dio
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|ret
op_ne
l_int|0
)paren
suffix:semicolon
)brace
)brace
id|out
suffix:colon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * An autonomous function to put a chunk of a page under deferred IO.&n; *&n; * The caller doesn&squot;t actually know (or care) whether this piece of page is in&n; * a BIO, or is under IO or whatever.  We just take care of all possible &n; * situations here.  The separation between the logic of do_direct_IO() and&n; * that of submit_page_section() is important for clarity.  Please don&squot;t break.&n; *&n; * The chunk of page starts on-disk at blocknr.&n; *&n; * We perform deferred IO, by recording the last-submitted page inside our&n; * private part of the dio structure.  If possible, we just expand the IO&n; * across that page here.&n; *&n; * If that doesn&squot;t work out then we put the old page into the bio and add this&n; * page to the dio instead.&n; */
r_static
r_int
DECL|function|submit_page_section
id|submit_page_section
c_func
(paren
r_struct
id|dio
op_star
id|dio
comma
r_struct
id|page
op_star
id|page
comma
r_int
id|offset
comma
r_int
id|len
comma
id|sector_t
id|blocknr
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Can we just grow the current page&squot;s presence in the dio?&n;&t; */
r_if
c_cond
(paren
(paren
id|dio-&gt;cur_page
op_eq
id|page
)paren
op_logical_and
(paren
id|dio-&gt;cur_page_offset
op_plus
id|dio-&gt;cur_page_len
op_eq
id|offset
)paren
op_logical_and
(paren
id|dio-&gt;cur_page_block
op_plus
(paren
id|dio-&gt;cur_page_len
op_rshift
id|dio-&gt;blkbits
)paren
op_eq
id|blocknr
)paren
)paren
(brace
id|dio-&gt;cur_page_len
op_add_assign
id|len
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If dio-&gt;boundary then we want to schedule the IO now to&n;&t;&t; * avoid metadata seeks.&n;&t;&t; */
r_if
c_cond
(paren
id|dio-&gt;boundary
)paren
(brace
id|ret
op_assign
id|dio_send_cur_page
c_func
(paren
id|dio
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|dio-&gt;cur_page
)paren
suffix:semicolon
id|dio-&gt;cur_page
op_assign
l_int|NULL
suffix:semicolon
)brace
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If there&squot;s a deferred page already there then send it.&n;&t; */
r_if
c_cond
(paren
id|dio-&gt;cur_page
)paren
(brace
id|ret
op_assign
id|dio_send_cur_page
c_func
(paren
id|dio
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|dio-&gt;cur_page
)paren
suffix:semicolon
id|dio-&gt;cur_page
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_goto
id|out
suffix:semicolon
)brace
id|page_cache_get
c_func
(paren
id|page
)paren
suffix:semicolon
multiline_comment|/* It is in dio */
id|dio-&gt;cur_page
op_assign
id|page
suffix:semicolon
id|dio-&gt;cur_page_offset
op_assign
id|offset
suffix:semicolon
id|dio-&gt;cur_page_len
op_assign
id|len
suffix:semicolon
id|dio-&gt;cur_page_block
op_assign
id|blocknr
suffix:semicolon
id|out
suffix:colon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Clean any dirty buffers in the blockdev mapping which alias newly-created&n; * file blocks.  Only called for S_ISREG files - blockdevs do not set&n; * buffer_new&n; */
DECL|function|clean_blockdev_aliases
r_static
r_void
id|clean_blockdev_aliases
c_func
(paren
r_struct
id|dio
op_star
id|dio
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|dio-&gt;blocks_available
suffix:semicolon
id|i
op_increment
)paren
(brace
id|unmap_underlying_metadata
c_func
(paren
id|dio-&gt;map_bh.b_bdev
comma
id|dio-&gt;map_bh.b_blocknr
op_plus
id|i
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * If we are not writing the entire block and get_block() allocated&n; * the block for us, we need to fill-in the unused portion of the&n; * block with zeros. This happens only if user-buffer, fileoffset or&n; * io length is not filesystem block-size multiple.&n; *&n; * `end&squot; is zero if we&squot;re doing the start of the IO, 1 at the end of the&n; * IO.&n; */
DECL|function|dio_zero_block
r_static
r_void
id|dio_zero_block
c_func
(paren
r_struct
id|dio
op_star
id|dio
comma
r_int
id|end
)paren
(brace
r_int
id|dio_blocks_per_fs_block
suffix:semicolon
r_int
id|this_chunk_blocks
suffix:semicolon
multiline_comment|/* In dio_blocks */
r_int
id|this_chunk_bytes
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
id|dio-&gt;start_zero_done
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dio-&gt;blkfactor
op_logical_or
op_logical_neg
id|buffer_new
c_func
(paren
op_amp
id|dio-&gt;map_bh
)paren
)paren
r_return
suffix:semicolon
id|dio_blocks_per_fs_block
op_assign
l_int|1
op_lshift
id|dio-&gt;blkfactor
suffix:semicolon
id|this_chunk_blocks
op_assign
id|dio-&gt;block_in_file
op_amp
(paren
id|dio_blocks_per_fs_block
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|this_chunk_blocks
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t; * We need to zero out part of an fs block.  It is either at the&n;&t; * beginning or the end of the fs block.&n;&t; */
r_if
c_cond
(paren
id|end
)paren
id|this_chunk_blocks
op_assign
id|dio_blocks_per_fs_block
op_minus
id|this_chunk_blocks
suffix:semicolon
id|this_chunk_bytes
op_assign
id|this_chunk_blocks
op_lshift
id|dio-&gt;blkbits
suffix:semicolon
id|page
op_assign
id|ZERO_PAGE
c_func
(paren
id|dio-&gt;cur_user_address
)paren
suffix:semicolon
r_if
c_cond
(paren
id|submit_page_section
c_func
(paren
id|dio
comma
id|page
comma
l_int|0
comma
id|this_chunk_bytes
comma
id|dio-&gt;next_block_for_io
)paren
)paren
r_return
suffix:semicolon
id|dio-&gt;next_block_for_io
op_add_assign
id|this_chunk_blocks
suffix:semicolon
)brace
multiline_comment|/*&n; * Walk the user pages, and the file, mapping blocks to disk and generating&n; * a sequence of (page,offset,len,block) mappings.  These mappings are injected&n; * into submit_page_section(), which takes care of the next stage of submission&n; *&n; * Direct IO against a blockdev is different from a file.  Because we can&n; * happily perform page-sized but 512-byte aligned IOs.  It is important that&n; * blockdev IO be able to have fine alignment and large sizes.&n; *&n; * So what we do is to permit the -&gt;get_blocks function to populate bh.b_size&n; * with the size of IO which is permitted at this offset and this i_blkbits.&n; *&n; * For best results, the blockdev should be set up with 512-byte i_blkbits and&n; * it should set b_size to PAGE_SIZE or more inside get_blocks().  This gives&n; * fine alignment but still allows this function to work in PAGE_SIZE units.&n; */
DECL|function|do_direct_IO
r_static
r_int
id|do_direct_IO
c_func
(paren
r_struct
id|dio
op_star
id|dio
)paren
(brace
r_const
r_int
id|blkbits
op_assign
id|dio-&gt;blkbits
suffix:semicolon
r_const
r_int
id|blocks_per_page
op_assign
id|PAGE_SIZE
op_rshift
id|blkbits
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
r_int
id|block_in_page
suffix:semicolon
r_struct
id|buffer_head
op_star
id|map_bh
op_assign
op_amp
id|dio-&gt;map_bh
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* The I/O can start at any block offset within the first page */
id|block_in_page
op_assign
id|dio-&gt;first_block_in_page
suffix:semicolon
r_while
c_loop
(paren
id|dio-&gt;block_in_file
OL
id|dio-&gt;final_block_in_request
)paren
(brace
id|page
op_assign
id|dio_get_page
c_func
(paren
id|dio
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|page
)paren
)paren
(brace
id|ret
op_assign
id|PTR_ERR
c_func
(paren
id|page
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_while
c_loop
(paren
id|block_in_page
OL
id|blocks_per_page
)paren
(brace
r_int
id|offset_in_page
op_assign
id|block_in_page
op_lshift
id|blkbits
suffix:semicolon
r_int
id|this_chunk_bytes
suffix:semicolon
multiline_comment|/* # of bytes mapped */
r_int
id|this_chunk_blocks
suffix:semicolon
multiline_comment|/* # of blocks */
r_int
id|u
suffix:semicolon
r_if
c_cond
(paren
id|dio-&gt;blocks_available
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * Need to go and map some more disk&n;&t;&t;&t;&t; */
r_int
r_int
id|blkmask
suffix:semicolon
r_int
r_int
id|dio_remainder
suffix:semicolon
id|ret
op_assign
id|get_more_blocks
c_func
(paren
id|dio
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|buffer_mapped
c_func
(paren
id|map_bh
)paren
)paren
r_goto
id|do_holes
suffix:semicolon
id|dio-&gt;blocks_available
op_assign
id|map_bh-&gt;b_size
op_rshift
id|dio-&gt;blkbits
suffix:semicolon
id|dio-&gt;next_block_for_io
op_assign
id|map_bh-&gt;b_blocknr
op_lshift
id|dio-&gt;blkfactor
suffix:semicolon
r_if
c_cond
(paren
id|buffer_new
c_func
(paren
id|map_bh
)paren
)paren
id|clean_blockdev_aliases
c_func
(paren
id|dio
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dio-&gt;blkfactor
)paren
r_goto
id|do_holes
suffix:semicolon
id|blkmask
op_assign
(paren
l_int|1
op_lshift
id|dio-&gt;blkfactor
)paren
op_minus
l_int|1
suffix:semicolon
id|dio_remainder
op_assign
(paren
id|dio-&gt;block_in_file
op_amp
id|blkmask
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * If we are at the start of IO and that IO&n;&t;&t;&t;&t; * starts partway into a fs-block,&n;&t;&t;&t;&t; * dio_remainder will be non-zero.  If the IO&n;&t;&t;&t;&t; * is a read then we can simply advance the IO&n;&t;&t;&t;&t; * cursor to the first block which is to be&n;&t;&t;&t;&t; * read.  But if the IO is a write and the&n;&t;&t;&t;&t; * block was newly allocated we cannot do that;&n;&t;&t;&t;&t; * the start of the fs block must be zeroed out&n;&t;&t;&t;&t; * on-disk&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|buffer_new
c_func
(paren
id|map_bh
)paren
)paren
id|dio-&gt;next_block_for_io
op_add_assign
id|dio_remainder
suffix:semicolon
id|dio-&gt;blocks_available
op_sub_assign
id|dio_remainder
suffix:semicolon
)brace
id|do_holes
suffix:colon
multiline_comment|/* Handle holes */
r_if
c_cond
(paren
op_logical_neg
id|buffer_mapped
c_func
(paren
id|map_bh
)paren
)paren
(brace
r_char
op_star
id|kaddr
suffix:semicolon
r_if
c_cond
(paren
id|dio-&gt;block_in_file
op_ge
id|i_size_read
c_func
(paren
id|dio-&gt;inode
)paren
op_rshift
id|blkbits
)paren
(brace
multiline_comment|/* We hit eof */
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|kaddr
op_assign
id|kmap_atomic
c_func
(paren
id|page
comma
id|KM_USER0
)paren
suffix:semicolon
id|memset
c_func
(paren
id|kaddr
op_plus
(paren
id|block_in_page
op_lshift
id|blkbits
)paren
comma
l_int|0
comma
l_int|1
op_lshift
id|blkbits
)paren
suffix:semicolon
id|flush_dcache_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|kunmap_atomic
c_func
(paren
id|kaddr
comma
id|KM_USER0
)paren
suffix:semicolon
id|dio-&gt;block_in_file
op_increment
suffix:semicolon
id|block_in_page
op_increment
suffix:semicolon
r_goto
id|next_block
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * If we&squot;re performing IO which has an alignment which&n;&t;&t;&t; * is finer than the underlying fs, go check to see if&n;&t;&t;&t; * we must zero out the start of this block.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|dio-&gt;blkfactor
op_logical_and
op_logical_neg
id|dio-&gt;start_zero_done
)paren
)paren
id|dio_zero_block
c_func
(paren
id|dio
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Work out, in this_chunk_blocks, how much disk we&n;&t;&t;&t; * can add to this page&n;&t;&t;&t; */
id|this_chunk_blocks
op_assign
id|dio-&gt;blocks_available
suffix:semicolon
id|u
op_assign
(paren
id|PAGE_SIZE
op_minus
id|offset_in_page
)paren
op_rshift
id|blkbits
suffix:semicolon
r_if
c_cond
(paren
id|this_chunk_blocks
OG
id|u
)paren
id|this_chunk_blocks
op_assign
id|u
suffix:semicolon
id|u
op_assign
id|dio-&gt;final_block_in_request
op_minus
id|dio-&gt;block_in_file
suffix:semicolon
r_if
c_cond
(paren
id|this_chunk_blocks
OG
id|u
)paren
id|this_chunk_blocks
op_assign
id|u
suffix:semicolon
id|this_chunk_bytes
op_assign
id|this_chunk_blocks
op_lshift
id|blkbits
suffix:semicolon
id|BUG_ON
c_func
(paren
id|this_chunk_bytes
op_eq
l_int|0
)paren
suffix:semicolon
id|dio-&gt;boundary
op_assign
id|buffer_boundary
c_func
(paren
id|map_bh
)paren
suffix:semicolon
id|ret
op_assign
id|submit_page_section
c_func
(paren
id|dio
comma
id|page
comma
id|offset_in_page
comma
id|this_chunk_bytes
comma
id|dio-&gt;next_block_for_io
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|dio-&gt;next_block_for_io
op_add_assign
id|this_chunk_blocks
suffix:semicolon
id|dio-&gt;block_in_file
op_add_assign
id|this_chunk_blocks
suffix:semicolon
id|block_in_page
op_add_assign
id|this_chunk_blocks
suffix:semicolon
id|dio-&gt;blocks_available
op_sub_assign
id|this_chunk_blocks
suffix:semicolon
id|next_block
suffix:colon
r_if
c_cond
(paren
id|dio-&gt;block_in_file
OG
id|dio-&gt;final_block_in_request
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dio-&gt;block_in_file
op_eq
id|dio-&gt;final_block_in_request
)paren
r_break
suffix:semicolon
)brace
multiline_comment|/* Drop the ref which was taken in get_user_pages() */
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
id|block_in_page
op_assign
l_int|0
suffix:semicolon
)brace
id|out
suffix:colon
r_return
id|ret
suffix:semicolon
)brace
r_static
r_int
DECL|function|direct_io_worker
id|direct_io_worker
c_func
(paren
r_int
id|rw
comma
r_struct
id|kiocb
op_star
id|iocb
comma
r_struct
id|inode
op_star
id|inode
comma
r_const
r_struct
id|iovec
op_star
id|iov
comma
id|loff_t
id|offset
comma
r_int
r_int
id|nr_segs
comma
r_int
id|blkbits
comma
id|get_blocks_t
id|get_blocks
comma
id|dio_iodone_t
id|end_io
)paren
(brace
r_int
r_int
id|user_addr
suffix:semicolon
r_int
id|seg
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_int
id|ret2
suffix:semicolon
r_struct
id|dio
op_star
id|dio
suffix:semicolon
r_int
id|bytes
suffix:semicolon
id|dio
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|dio
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dio
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|dio-&gt;is_async
op_assign
op_logical_neg
id|is_sync_kiocb
c_func
(paren
id|iocb
)paren
suffix:semicolon
id|dio-&gt;bio
op_assign
l_int|NULL
suffix:semicolon
id|dio-&gt;inode
op_assign
id|inode
suffix:semicolon
id|dio-&gt;rw
op_assign
id|rw
suffix:semicolon
id|dio-&gt;blkbits
op_assign
id|blkbits
suffix:semicolon
id|dio-&gt;blkfactor
op_assign
id|inode-&gt;i_blkbits
op_minus
id|blkbits
suffix:semicolon
id|dio-&gt;start_zero_done
op_assign
l_int|0
suffix:semicolon
id|dio-&gt;block_in_file
op_assign
id|offset
op_rshift
id|blkbits
suffix:semicolon
id|dio-&gt;blocks_available
op_assign
l_int|0
suffix:semicolon
id|dio-&gt;cur_page
op_assign
l_int|NULL
suffix:semicolon
id|dio-&gt;boundary
op_assign
l_int|0
suffix:semicolon
id|dio-&gt;reap_counter
op_assign
l_int|0
suffix:semicolon
id|dio-&gt;get_blocks
op_assign
id|get_blocks
suffix:semicolon
id|dio-&gt;end_io
op_assign
id|end_io
suffix:semicolon
id|dio-&gt;map_bh.b_private
op_assign
l_int|NULL
suffix:semicolon
id|dio-&gt;final_block_in_bio
op_assign
op_minus
l_int|1
suffix:semicolon
id|dio-&gt;next_block_for_io
op_assign
op_minus
l_int|1
suffix:semicolon
id|dio-&gt;page_errors
op_assign
l_int|0
suffix:semicolon
id|dio-&gt;result
op_assign
l_int|0
suffix:semicolon
id|dio-&gt;iocb
op_assign
id|iocb
suffix:semicolon
multiline_comment|/*&n;&t; * BIO completion state.&n;&t; *&n;&t; * -&gt;bio_count starts out at one, and we decrement it to zero after all&n;&t; * BIOs are submitted.  This to avoid the situation where a really fast&n;&t; * (or synchronous) device could take the count to zero while we&squot;re&n;&t; * still submitting BIOs.&n;&t; */
id|atomic_set
c_func
(paren
op_amp
id|dio-&gt;bio_count
comma
l_int|1
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|dio-&gt;bios_in_flight
comma
l_int|0
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|dio-&gt;bio_list_lock
)paren
suffix:semicolon
id|dio-&gt;bio_list
op_assign
l_int|NULL
suffix:semicolon
id|dio-&gt;waiter
op_assign
l_int|NULL
suffix:semicolon
id|dio-&gt;pages_in_io
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|seg
op_assign
l_int|0
suffix:semicolon
id|seg
OL
id|nr_segs
suffix:semicolon
id|seg
op_increment
)paren
id|dio-&gt;pages_in_io
op_add_assign
(paren
id|iov
(braket
id|seg
)braket
dot
id|iov_len
op_rshift
id|blkbits
)paren
op_plus
l_int|2
suffix:semicolon
r_for
c_loop
(paren
id|seg
op_assign
l_int|0
suffix:semicolon
id|seg
OL
id|nr_segs
suffix:semicolon
id|seg
op_increment
)paren
(brace
id|user_addr
op_assign
(paren
r_int
r_int
)paren
id|iov
(braket
id|seg
)braket
dot
id|iov_base
suffix:semicolon
id|bytes
op_assign
id|iov
(braket
id|seg
)braket
dot
id|iov_len
suffix:semicolon
multiline_comment|/* Index into the first page of the first block */
id|dio-&gt;first_block_in_page
op_assign
(paren
id|user_addr
op_amp
op_complement
id|PAGE_MASK
)paren
op_rshift
id|blkbits
suffix:semicolon
id|dio-&gt;final_block_in_request
op_assign
id|dio-&gt;block_in_file
op_plus
(paren
id|bytes
op_rshift
id|blkbits
)paren
suffix:semicolon
multiline_comment|/* Page fetching state */
id|dio-&gt;head
op_assign
l_int|0
suffix:semicolon
id|dio-&gt;tail
op_assign
l_int|0
suffix:semicolon
id|dio-&gt;curr_page
op_assign
l_int|0
suffix:semicolon
id|dio-&gt;total_pages
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|user_addr
op_amp
(paren
id|PAGE_SIZE
op_minus
l_int|1
)paren
)paren
(brace
id|dio-&gt;total_pages
op_increment
suffix:semicolon
id|bytes
op_sub_assign
id|PAGE_SIZE
op_minus
(paren
id|user_addr
op_amp
(paren
id|PAGE_SIZE
op_minus
l_int|1
)paren
)paren
suffix:semicolon
)brace
id|dio-&gt;total_pages
op_add_assign
(paren
id|bytes
op_plus
id|PAGE_SIZE
op_minus
l_int|1
)paren
op_div
id|PAGE_SIZE
suffix:semicolon
id|dio-&gt;curr_user_address
op_assign
id|user_addr
suffix:semicolon
id|ret
op_assign
id|do_direct_IO
c_func
(paren
id|dio
)paren
suffix:semicolon
id|dio-&gt;result
op_add_assign
id|iov
(braket
id|seg
)braket
dot
id|iov_len
op_minus
(paren
(paren
id|dio-&gt;final_block_in_request
op_minus
id|dio-&gt;block_in_file
)paren
op_lshift
id|blkbits
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|dio_cleanup
c_func
(paren
id|dio
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* end iovec loop */
multiline_comment|/*&n;&t; * There may be some unwritten disk at the end of a part-written&n;&t; * fs-block-sized block.  Go zero that now.&n;&t; */
id|dio_zero_block
c_func
(paren
id|dio
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dio-&gt;cur_page
)paren
(brace
id|ret2
op_assign
id|dio_send_cur_page
c_func
(paren
id|dio
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
id|ret
op_assign
id|ret2
suffix:semicolon
id|page_cache_release
c_func
(paren
id|dio-&gt;cur_page
)paren
suffix:semicolon
id|dio-&gt;cur_page
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dio-&gt;bio
)paren
id|dio_bio_submit
c_func
(paren
id|dio
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * OK, all BIOs are submitted, so we can decrement bio_count to truly&n;&t; * reflect the number of to-be-processed BIOs.&n;&t; */
r_if
c_cond
(paren
id|dio-&gt;is_async
)paren
(brace
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
id|ret
op_assign
id|dio-&gt;result
suffix:semicolon
multiline_comment|/* Bytes written */
id|finished_one_bio
c_func
(paren
id|dio
)paren
suffix:semicolon
multiline_comment|/* This can free the dio */
id|blk_run_queues
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|finished_one_bio
c_func
(paren
id|dio
)paren
suffix:semicolon
id|ret2
op_assign
id|dio_await_completion
c_func
(paren
id|dio
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
id|ret
op_assign
id|ret2
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
id|ret
op_assign
id|dio-&gt;page_errors
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
op_logical_and
id|dio-&gt;result
)paren
(brace
id|loff_t
id|i_size
op_assign
id|i_size_read
c_func
(paren
id|inode
)paren
suffix:semicolon
id|ret
op_assign
id|dio-&gt;result
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Adjust the return value if the read crossed a&n;&t;&t;&t; * non-block-aligned EOF.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|rw
op_eq
id|READ
op_logical_and
(paren
id|offset
op_plus
id|ret
OG
id|i_size
)paren
)paren
id|ret
op_assign
id|i_size
op_minus
id|offset
suffix:semicolon
)brace
id|dio_complete
c_func
(paren
id|dio
comma
id|offset
comma
id|ret
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|dio
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * This is a library function for use by filesystem drivers.&n; */
r_int
DECL|function|blockdev_direct_IO
id|blockdev_direct_IO
c_func
(paren
r_int
id|rw
comma
r_struct
id|kiocb
op_star
id|iocb
comma
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|block_device
op_star
id|bdev
comma
r_const
r_struct
id|iovec
op_star
id|iov
comma
id|loff_t
id|offset
comma
r_int
r_int
id|nr_segs
comma
id|get_blocks_t
id|get_blocks
comma
id|dio_iodone_t
id|end_io
)paren
(brace
r_int
id|seg
suffix:semicolon
r_int
id|size
suffix:semicolon
r_int
r_int
id|addr
suffix:semicolon
r_int
id|blkbits
op_assign
id|inode-&gt;i_blkbits
suffix:semicolon
r_int
id|bdev_blkbits
op_assign
l_int|0
suffix:semicolon
r_int
id|blocksize_mask
op_assign
(paren
l_int|1
op_lshift
id|blkbits
)paren
op_minus
l_int|1
suffix:semicolon
id|ssize_t
id|retval
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|bdev
)paren
id|bdev_blkbits
op_assign
id|blksize_bits
c_func
(paren
id|bdev_hardsect_size
c_func
(paren
id|bdev
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|offset
op_amp
id|blocksize_mask
)paren
(brace
r_if
c_cond
(paren
id|bdev
)paren
id|blkbits
op_assign
id|bdev_blkbits
suffix:semicolon
id|blocksize_mask
op_assign
(paren
l_int|1
op_lshift
id|blkbits
)paren
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|offset
op_amp
id|blocksize_mask
)paren
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* Check the memory alignment.  Blocks cannot straddle pages */
r_for
c_loop
(paren
id|seg
op_assign
l_int|0
suffix:semicolon
id|seg
OL
id|nr_segs
suffix:semicolon
id|seg
op_increment
)paren
(brace
id|addr
op_assign
(paren
r_int
r_int
)paren
id|iov
(braket
id|seg
)braket
dot
id|iov_base
suffix:semicolon
id|size
op_assign
id|iov
(braket
id|seg
)braket
dot
id|iov_len
suffix:semicolon
r_if
c_cond
(paren
(paren
id|addr
op_amp
id|blocksize_mask
)paren
op_logical_or
(paren
id|size
op_amp
id|blocksize_mask
)paren
)paren
(brace
r_if
c_cond
(paren
id|bdev
)paren
id|blkbits
op_assign
id|bdev_blkbits
suffix:semicolon
id|blocksize_mask
op_assign
(paren
l_int|1
op_lshift
id|blkbits
)paren
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|addr
op_amp
id|blocksize_mask
)paren
op_logical_or
(paren
id|size
op_amp
id|blocksize_mask
)paren
)paren
r_goto
id|out
suffix:semicolon
)brace
)brace
id|retval
op_assign
id|direct_io_worker
c_func
(paren
id|rw
comma
id|iocb
comma
id|inode
comma
id|iov
comma
id|offset
comma
id|nr_segs
comma
id|blkbits
comma
id|get_blocks
comma
id|end_io
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|retval
suffix:semicolon
)brace
DECL|variable|blockdev_direct_IO
id|EXPORT_SYMBOL
c_func
(paren
id|blockdev_direct_IO
)paren
suffix:semicolon
eof
