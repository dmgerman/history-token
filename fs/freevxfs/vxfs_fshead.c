multiline_comment|/*&n; * Copyright (c) 2000-2001 Christoph Hellwig.&n; * All rights reserved.&n; *&n; * Redistribution and use in source and binary forms, with or without&n; * modification, are permitted provided that the following conditions&n; * are met:&n; * 1. Redistributions of source code must retain the above copyright&n; *    notice, this list of conditions, and the following disclaimer,&n; *    without modification.&n; * 2. The name of the author may not be used to endorse or promote products&n; *    derived from this software without specific prior written permission.&n; *&n; * Alternatively, this software may be distributed under the terms of the&n; * GNU General Public License (&quot;GPL&quot;).&n; *&n; * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS&squot;&squot; AND&n; * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE&n; * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE&n; * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR&n; * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL&n; * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS&n; * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)&n; * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT&n; * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY&n; * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF&n; * SUCH DAMAGE.&n; */
macro_line|#ident &quot;$Id: vxfs_fshead.c,v 1.17 2001/04/24 19:28:36 hch Exp hch $&quot;
multiline_comment|/*&n; * Veritas filesystem driver - fileset header routines.&n; */
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &quot;vxfs.h&quot;
macro_line|#include &quot;vxfs_inode.h&quot;
macro_line|#include &quot;vxfs_extern.h&quot;
macro_line|#include &quot;vxfs_fshead.h&quot;
macro_line|#ifdef DIAGNOSTIC
r_static
r_void
DECL|function|vxfs_dumpfsh
id|vxfs_dumpfsh
c_func
(paren
r_struct
id|vxfs_fsh
op_star
id|fhp
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&bslash;ndumping fileset header:&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;----------------------------&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;version: %u&bslash;n&quot;
comma
id|fhp-&gt;fsh_version
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;fsindex: %u&bslash;n&quot;
comma
id|fhp-&gt;fsh_fsindex
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;iauino: %u&bslash;tninodes:%u&bslash;n&quot;
comma
id|fhp-&gt;fsh_iauino
comma
id|fhp-&gt;fsh_ninodes
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;maxinode: %u&bslash;tlctino: %u&bslash;n&quot;
comma
id|fhp-&gt;fsh_maxinode
comma
id|fhp-&gt;fsh_lctino
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;nau: %u&bslash;n&quot;
comma
id|fhp-&gt;fsh_nau
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ilistino[0]: %u&bslash;tilistino[1]: %u&bslash;n&quot;
comma
id|fhp-&gt;fsh_ilistino
(braket
l_int|0
)braket
comma
id|fhp-&gt;fsh_ilistino
(braket
l_int|1
)braket
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/**&n; * vxfs_getfsh - read fileset header into memory&n; * @ip:&t;&t;the (fake) fileset header inode&n; * @which:&t;0 for the structural, 1 for the primary fsh.&n; *&n; * Description:&n; *   vxfs_getfsh reads either the structural or primary fileset header&n; *   described by @ip into memory.&n; *&n; * Returns:&n; *   The fileset header structure on success, else Zero.&n; */
r_static
r_struct
id|vxfs_fsh
op_star
DECL|function|vxfs_getfsh
id|vxfs_getfsh
c_func
(paren
r_struct
id|inode
op_star
id|ip
comma
r_int
id|which
)paren
(brace
r_struct
id|buffer_head
op_star
id|bp
suffix:semicolon
id|bp
op_assign
id|vxfs_bread
c_func
(paren
id|ip
comma
id|which
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buffer_mapped
c_func
(paren
id|bp
)paren
)paren
(brace
r_struct
id|vxfs_fsh
op_star
id|fhp
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|fhp
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|vxfs_fsh
)paren
comma
id|SLAB_KERNEL
)paren
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
id|memcpy
c_func
(paren
id|fhp
comma
id|bp-&gt;b_data
comma
r_sizeof
(paren
r_struct
id|vxfs_fsh
)paren
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|bp
)paren
suffix:semicolon
r_return
(paren
id|fhp
)paren
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/**&n; * vxfs_read_fshead - read the fileset headers&n; * @sbp:&t;superblock to which the fileset belongs&n; *&n; * Description:&n; *   vxfs_read_fshead will fill the inode and structural inode list in @sb.&n; *&n; * Returns:&n; *   Zero on success, else a negative error code (-EINVAL).&n; */
r_int
DECL|function|vxfs_read_fshead
id|vxfs_read_fshead
c_func
(paren
r_struct
id|super_block
op_star
id|sbp
)paren
(brace
r_struct
id|vxfs_sb_info
op_star
id|infp
op_assign
id|VXFS_SBI
c_func
(paren
id|sbp
)paren
suffix:semicolon
r_struct
id|vxfs_fsh
op_star
id|pfp
comma
op_star
id|sfp
suffix:semicolon
r_struct
id|vxfs_inode_info
op_star
id|vip
comma
op_star
id|tip
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|vip
op_assign
id|vxfs_blkiget
c_func
(paren
id|sbp
comma
id|infp-&gt;vsi_iext
comma
id|infp-&gt;vsi_fshino
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;vxfs: unabled to read fsh inode&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|VXFS_ISFSH
c_func
(paren
id|vip
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;vxfs: fsh list inode is of wrong type (%x)&bslash;n&quot;
comma
id|vip-&gt;vii_mode
op_amp
id|VXFS_TYPE_MASK
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
macro_line|#ifdef DIAGNOSTIC
id|printk
c_func
(paren
l_string|&quot;vxfs: fsh inode dump:&bslash;n&quot;
)paren
suffix:semicolon
id|vxfs_dumpi
c_func
(paren
id|vip
comma
id|infp-&gt;vsi_fshino
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
(paren
id|infp-&gt;vsi_fship
op_assign
id|vxfs_fake_inode
c_func
(paren
id|sbp
comma
id|vip
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;vxfs: unabled to get fsh inode&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|sfp
op_assign
id|vxfs_getfsh
c_func
(paren
id|infp-&gt;vsi_fship
comma
l_int|0
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;vxfs: unabled to get structural fsh&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
macro_line|#ifdef DIAGNOSTIC
id|vxfs_dumpfsh
c_func
(paren
id|sfp
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
(paren
id|pfp
op_assign
id|vxfs_getfsh
c_func
(paren
id|infp-&gt;vsi_fship
comma
l_int|1
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;vxfs: unabled to get primary fsh&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
macro_line|#ifdef DIAGNOSTIC
id|vxfs_dumpfsh
c_func
(paren
id|pfp
)paren
suffix:semicolon
macro_line|#endif
id|tip
op_assign
id|vxfs_blkiget
c_func
(paren
id|sbp
comma
id|infp-&gt;vsi_iext
comma
id|sfp-&gt;fsh_ilistino
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tip
op_logical_or
(paren
(paren
id|infp-&gt;vsi_stilist
op_assign
id|vxfs_fake_inode
c_func
(paren
id|sbp
comma
id|tip
)paren
)paren
op_eq
l_int|NULL
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;vxfs: unabled to get structual list inode&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|VXFS_ISILT
c_func
(paren
id|VXFS_INO
c_func
(paren
id|infp-&gt;vsi_stilist
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;vxfs: structual list inode is of wrong type (%x)&bslash;n&quot;
comma
id|VXFS_INO
c_func
(paren
id|infp-&gt;vsi_stilist
)paren
op_member_access_from_pointer
id|vii_mode
op_amp
id|VXFS_TYPE_MASK
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|tip
op_assign
id|vxfs_stiget
c_func
(paren
id|sbp
comma
id|pfp-&gt;fsh_ilistino
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tip
op_logical_or
(paren
(paren
id|infp-&gt;vsi_ilist
op_assign
id|vxfs_fake_inode
c_func
(paren
id|sbp
comma
id|tip
)paren
)paren
op_eq
l_int|NULL
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;vxfs: unabled to get inode list inode&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|VXFS_ISILT
c_func
(paren
id|VXFS_INO
c_func
(paren
id|infp-&gt;vsi_ilist
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;vxfs: inode list inode is of wrong type (%x)&bslash;n&quot;
comma
id|VXFS_INO
c_func
(paren
id|infp-&gt;vsi_ilist
)paren
op_member_access_from_pointer
id|vii_mode
op_amp
id|VXFS_TYPE_MASK
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
eof
