multiline_comment|/*&n; * Copyright (c) 2000-2001 Christoph Hellwig.&n; * All rights reserved.&n; *&n; * Redistribution and use in source and binary forms, with or without&n; * modification, are permitted provided that the following conditions&n; * are met:&n; * 1. Redistributions of source code must retain the above copyright&n; *    notice, this list of conditions, and the following disclaimer,&n; *    without modification.&n; * 2. The name of the author may not be used to endorse or promote products&n; *    derived from this software without specific prior written permission.&n; *&n; * Alternatively, this software may be distributed under the terms of the&n; * GNU General Public License (&quot;GPL&quot;).&n; *&n; * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS&squot;&squot; AND&n; * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE&n; * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE&n; * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR&n; * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL&n; * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS&n; * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)&n; * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT&n; * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY&n; * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF&n; * SUCH DAMAGE.&n; */
macro_line|#ident &quot;$Id: vxfs_lookup.c,v 1.17 2001/05/21 15:23:53 hch Exp hch $&quot;
multiline_comment|/*&n; * Veritas filesystem driver - lookup and other directory related code.&n; */
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/highmem.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/pagemap.h&gt;
macro_line|#include &quot;vxfs.h&quot;
macro_line|#include &quot;vxfs_dir.h&quot;
macro_line|#include &quot;vxfs_inode.h&quot;
macro_line|#include &quot;vxfs_extern.h&quot;
multiline_comment|/*&n; * Number of VxFS blocks per page.&n; */
DECL|macro|VXFS_BLOCK_PER_PAGE
mdefine_line|#define VXFS_BLOCK_PER_PAGE(sbp)  ((PAGE_CACHE_SIZE / (sbp)-&gt;s_blocksize))
r_static
r_struct
id|dentry
op_star
id|vxfs_lookup
c_func
(paren
r_struct
id|inode
op_star
comma
r_struct
id|dentry
op_star
)paren
suffix:semicolon
r_static
r_int
id|vxfs_readdir
c_func
(paren
r_struct
id|file
op_star
comma
r_void
op_star
comma
id|filldir_t
)paren
suffix:semicolon
DECL|variable|vxfs_dir_inode_ops
r_struct
id|inode_operations
id|vxfs_dir_inode_ops
op_assign
(brace
dot
id|lookup
op_assign
id|vxfs_lookup
comma
)brace
suffix:semicolon
DECL|variable|vxfs_dir_operations
r_struct
id|file_operations
id|vxfs_dir_operations
op_assign
(brace
dot
id|readdir
op_assign
id|vxfs_readdir
comma
)brace
suffix:semicolon
r_static
id|__inline__
id|u_long
DECL|function|dir_pages
id|dir_pages
c_func
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
r_return
(paren
id|inode-&gt;i_size
op_plus
id|PAGE_CACHE_SIZE
op_minus
l_int|1
)paren
op_rshift
id|PAGE_CACHE_SHIFT
suffix:semicolon
)brace
r_static
id|__inline__
id|u_long
DECL|function|dir_blocks
id|dir_blocks
c_func
(paren
r_struct
id|inode
op_star
id|ip
)paren
(brace
id|u_long
id|bsize
op_assign
id|ip-&gt;i_sb-&gt;s_blocksize
suffix:semicolon
r_return
(paren
id|ip-&gt;i_size
op_plus
id|bsize
op_minus
l_int|1
)paren
op_amp
op_complement
(paren
id|bsize
op_minus
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * NOTE! unlike strncmp, vxfs_match returns 1 for success, 0 for failure.&n; *&n; * len &lt;= VXFS_NAMELEN and de != NULL are guaranteed by caller.&n; */
r_static
id|__inline__
r_int
DECL|function|vxfs_match
id|vxfs_match
c_func
(paren
r_int
id|len
comma
r_const
r_char
op_star
r_const
id|name
comma
r_struct
id|vxfs_direct
op_star
id|de
)paren
(brace
r_if
c_cond
(paren
id|len
op_ne
id|de-&gt;d_namelen
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|de-&gt;d_ino
)paren
r_return
l_int|0
suffix:semicolon
r_return
op_logical_neg
id|memcmp
c_func
(paren
id|name
comma
id|de-&gt;d_name
comma
id|len
)paren
suffix:semicolon
)brace
r_static
id|__inline__
r_struct
id|vxfs_direct
op_star
DECL|function|vxfs_next_entry
id|vxfs_next_entry
c_func
(paren
r_struct
id|vxfs_direct
op_star
id|de
)paren
(brace
r_return
(paren
(paren
r_struct
id|vxfs_direct
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|de
op_plus
id|de-&gt;d_reclen
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * vxfs_find_entry - find a mathing directory entry for a dentry&n; * @ip:&t;&t;directory inode&n; * @dp:&t;&t;dentry for which we want to find a direct&n; * @ppp:&t;gets filled with the page the return value sits in&n; *&n; * Description:&n; *   vxfs_find_entry finds a &amp;struct vxfs_direct for the VFS directory&n; *   cache entry @dp.  @ppp will be filled with the page the return&n; *   value resides in.&n; *&n; * Returns:&n; *   The wanted direct on success, else a NULL pointer.&n; */
r_static
r_struct
id|vxfs_direct
op_star
DECL|function|vxfs_find_entry
id|vxfs_find_entry
c_func
(paren
r_struct
id|inode
op_star
id|ip
comma
r_struct
id|dentry
op_star
id|dp
comma
r_struct
id|page
op_star
op_star
id|ppp
)paren
(brace
id|u_long
id|npages
comma
id|page
comma
id|nblocks
comma
id|pblocks
comma
id|block
suffix:semicolon
id|u_long
id|bsize
op_assign
id|ip-&gt;i_sb-&gt;s_blocksize
suffix:semicolon
r_const
r_char
op_star
id|name
op_assign
id|dp-&gt;d_name.name
suffix:semicolon
r_int
id|namelen
op_assign
id|dp-&gt;d_name.len
suffix:semicolon
id|npages
op_assign
id|dir_pages
c_func
(paren
id|ip
)paren
suffix:semicolon
id|nblocks
op_assign
id|dir_blocks
c_func
(paren
id|ip
)paren
suffix:semicolon
id|pblocks
op_assign
id|VXFS_BLOCK_PER_PAGE
c_func
(paren
id|ip-&gt;i_sb
)paren
suffix:semicolon
r_for
c_loop
(paren
id|page
op_assign
l_int|0
suffix:semicolon
id|page
OL
id|npages
suffix:semicolon
id|page
op_increment
)paren
(brace
id|caddr_t
id|kaddr
suffix:semicolon
r_struct
id|page
op_star
id|pp
suffix:semicolon
id|pp
op_assign
id|vxfs_get_page
c_func
(paren
id|ip
comma
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|pp
)paren
)paren
r_continue
suffix:semicolon
id|kaddr
op_assign
(paren
id|caddr_t
)paren
id|page_address
c_func
(paren
id|pp
)paren
suffix:semicolon
r_for
c_loop
(paren
id|block
op_assign
l_int|0
suffix:semicolon
id|block
op_le
id|nblocks
op_logical_and
id|block
op_le
id|pblocks
suffix:semicolon
id|block
op_increment
)paren
(brace
id|caddr_t
id|baddr
comma
id|limit
suffix:semicolon
r_struct
id|vxfs_dirblk
op_star
id|dbp
suffix:semicolon
r_struct
id|vxfs_direct
op_star
id|de
suffix:semicolon
id|baddr
op_assign
id|kaddr
op_plus
(paren
id|block
op_star
id|bsize
)paren
suffix:semicolon
id|limit
op_assign
id|baddr
op_plus
id|bsize
op_minus
id|VXFS_DIRLEN
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|dbp
op_assign
(paren
r_struct
id|vxfs_dirblk
op_star
)paren
id|baddr
suffix:semicolon
id|de
op_assign
(paren
r_struct
id|vxfs_direct
op_star
)paren
(paren
id|baddr
op_plus
id|VXFS_DIRBLKOV
c_func
(paren
id|dbp
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
(paren
id|caddr_t
)paren
id|de
op_le
id|limit
suffix:semicolon
id|de
op_assign
id|vxfs_next_entry
c_func
(paren
id|de
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|de-&gt;d_reclen
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|de-&gt;d_ino
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|vxfs_match
c_func
(paren
id|namelen
comma
id|name
comma
id|de
)paren
)paren
(brace
op_star
id|ppp
op_assign
id|pp
suffix:semicolon
r_return
(paren
id|de
)paren
suffix:semicolon
)brace
)brace
)brace
id|vxfs_put_page
c_func
(paren
id|pp
)paren
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/**&n; * vxfs_inode_by_name - find inode number for dentry&n; * @dip:&t;directory to search in&n; * @dp:&t;&t;dentry we seach for&n; *&n; * Description:&n; *   vxfs_inode_by_name finds out the inode number of&n; *   the path component described by @dp in @dip.&n; *&n; * Returns:&n; *   The wanted inode number on success, else Zero.&n; */
r_static
id|ino_t
DECL|function|vxfs_inode_by_name
id|vxfs_inode_by_name
c_func
(paren
r_struct
id|inode
op_star
id|dip
comma
r_struct
id|dentry
op_star
id|dp
)paren
(brace
r_struct
id|vxfs_direct
op_star
id|de
suffix:semicolon
r_struct
id|page
op_star
id|pp
suffix:semicolon
id|ino_t
id|ino
op_assign
l_int|0
suffix:semicolon
id|de
op_assign
id|vxfs_find_entry
c_func
(paren
id|dip
comma
id|dp
comma
op_amp
id|pp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|de
)paren
(brace
id|ino
op_assign
id|de-&gt;d_ino
suffix:semicolon
id|kunmap
c_func
(paren
id|pp
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|pp
)paren
suffix:semicolon
)brace
r_return
(paren
id|ino
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * vxfs_lookup - lookup pathname component&n; * @dip:&t;dir in which we lookup&n; * @dp:&t;&t;dentry we lookup&n; *&n; * Description:&n; *   vxfs_lookup tries to lookup the pathname component described&n; *   by @dp in @dip.&n; *&n; * Returns:&n; *   A NULL-pointer on success, else an negative error code encoded&n; *   in the return pointer.&n; */
r_static
r_struct
id|dentry
op_star
DECL|function|vxfs_lookup
id|vxfs_lookup
c_func
(paren
r_struct
id|inode
op_star
id|dip
comma
r_struct
id|dentry
op_star
id|dp
)paren
(brace
r_struct
id|inode
op_star
id|ip
op_assign
l_int|NULL
suffix:semicolon
id|ino_t
id|ino
suffix:semicolon
r_if
c_cond
(paren
id|dp-&gt;d_name.len
OG
id|VXFS_NAMELEN
)paren
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|ENAMETOOLONG
)paren
suffix:semicolon
id|ino
op_assign
id|vxfs_inode_by_name
c_func
(paren
id|dip
comma
id|dp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ino
op_eq
l_int|0
)paren
r_return
l_int|NULL
suffix:semicolon
id|ip
op_assign
id|iget
c_func
(paren
id|dip-&gt;i_sb
comma
id|ino
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ip
)paren
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|EACCES
)paren
suffix:semicolon
id|d_add
c_func
(paren
id|dp
comma
id|ip
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/**&n; * vxfs_readdir - read a directory&n; * @fp:&t;&t;the directory to read&n; * @retp:&t;return buffer&n; * @filler:&t;filldir callback&n; *&n; * Description:&n; *   vxfs_readdir fills @retp with directory entries from @fp&n; *   using the VFS supplied callback @filler.&n; *&n; * Returns:&n; *   Zero.&n; */
r_static
r_int
DECL|function|vxfs_readdir
id|vxfs_readdir
c_func
(paren
r_struct
id|file
op_star
id|fp
comma
r_void
op_star
id|retp
comma
id|filldir_t
id|filler
)paren
(brace
r_struct
id|inode
op_star
id|ip
op_assign
id|fp-&gt;f_dentry-&gt;d_inode
suffix:semicolon
r_struct
id|super_block
op_star
id|sbp
op_assign
id|ip-&gt;i_sb
suffix:semicolon
id|u_long
id|bsize
op_assign
id|sbp-&gt;s_blocksize
suffix:semicolon
id|u_long
id|page
comma
id|npages
comma
id|block
comma
id|nblocks
comma
id|offset
suffix:semicolon
id|loff_t
id|pos
suffix:semicolon
r_int
id|pblocks
suffix:semicolon
r_switch
c_cond
(paren
(paren
r_int
)paren
id|fp-&gt;f_pos
)paren
(brace
r_case
l_int|0
suffix:colon
r_if
c_cond
(paren
id|filler
c_func
(paren
id|retp
comma
l_string|&quot;.&quot;
comma
l_int|1
comma
id|fp-&gt;f_pos
comma
id|ip-&gt;i_ino
comma
id|DT_DIR
)paren
OL
l_int|0
)paren
r_goto
id|out
suffix:semicolon
id|fp-&gt;f_pos
op_increment
suffix:semicolon
multiline_comment|/* fallthrough */
r_case
l_int|1
suffix:colon
r_if
c_cond
(paren
id|filler
c_func
(paren
id|retp
comma
l_string|&quot;..&quot;
comma
l_int|2
comma
id|fp-&gt;f_pos
comma
id|VXFS_INO
c_func
(paren
id|ip
)paren
op_member_access_from_pointer
id|vii_dotdot
comma
id|DT_DIR
)paren
OL
l_int|0
)paren
r_goto
id|out
suffix:semicolon
id|fp-&gt;f_pos
op_increment
suffix:semicolon
multiline_comment|/* fallthrough */
)brace
id|pos
op_assign
id|fp-&gt;f_pos
op_minus
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|pos
OG
id|VXFS_DIRROUND
c_func
(paren
id|ip-&gt;i_size
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|page
op_assign
id|pos
op_rshift
id|PAGE_CACHE_SHIFT
suffix:semicolon
id|offset
op_assign
id|pos
op_amp
op_complement
id|PAGE_CACHE_MASK
suffix:semicolon
id|block
op_assign
id|pos
op_rshift
id|sbp-&gt;s_blocksize_bits
suffix:semicolon
id|npages
op_assign
id|dir_pages
c_func
(paren
id|ip
)paren
suffix:semicolon
id|nblocks
op_assign
id|dir_blocks
c_func
(paren
id|ip
)paren
suffix:semicolon
id|pblocks
op_assign
id|VXFS_BLOCK_PER_PAGE
c_func
(paren
id|sbp
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|page
OL
id|npages
suffix:semicolon
id|page
op_increment
comma
id|block
op_assign
l_int|0
)paren
(brace
id|caddr_t
id|kaddr
suffix:semicolon
r_struct
id|page
op_star
id|pp
suffix:semicolon
id|pp
op_assign
id|vxfs_get_page
c_func
(paren
id|ip
comma
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|pp
)paren
)paren
r_continue
suffix:semicolon
id|kaddr
op_assign
(paren
id|caddr_t
)paren
id|page_address
c_func
(paren
id|pp
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|block
op_le
id|nblocks
op_logical_and
id|block
op_le
id|pblocks
suffix:semicolon
id|block
op_increment
)paren
(brace
id|caddr_t
id|baddr
comma
id|limit
suffix:semicolon
r_struct
id|vxfs_dirblk
op_star
id|dbp
suffix:semicolon
r_struct
id|vxfs_direct
op_star
id|de
suffix:semicolon
id|baddr
op_assign
id|kaddr
op_plus
(paren
id|block
op_star
id|bsize
)paren
suffix:semicolon
id|limit
op_assign
id|baddr
op_plus
id|bsize
op_minus
id|VXFS_DIRLEN
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|dbp
op_assign
(paren
r_struct
id|vxfs_dirblk
op_star
)paren
id|baddr
suffix:semicolon
id|de
op_assign
(paren
r_struct
id|vxfs_direct
op_star
)paren
(paren
id|offset
ques
c_cond
(paren
id|kaddr
op_plus
id|offset
)paren
suffix:colon
(paren
id|baddr
op_plus
id|VXFS_DIRBLKOV
c_func
(paren
id|dbp
)paren
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
(paren
id|caddr_t
)paren
id|de
op_le
id|limit
suffix:semicolon
id|de
op_assign
id|vxfs_next_entry
c_func
(paren
id|de
)paren
)paren
(brace
r_int
id|over
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|de-&gt;d_reclen
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|de-&gt;d_ino
)paren
r_continue
suffix:semicolon
id|offset
op_assign
(paren
id|caddr_t
)paren
id|de
op_minus
id|kaddr
suffix:semicolon
id|over
op_assign
id|filler
c_func
(paren
id|retp
comma
id|de-&gt;d_name
comma
id|de-&gt;d_namelen
comma
(paren
(paren
id|page
op_lshift
id|PAGE_CACHE_SHIFT
)paren
op_or
id|offset
)paren
op_plus
l_int|2
comma
id|de-&gt;d_ino
comma
id|DT_UNKNOWN
)paren
suffix:semicolon
r_if
c_cond
(paren
id|over
)paren
(brace
id|vxfs_put_page
c_func
(paren
id|pp
)paren
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
)brace
)brace
id|vxfs_put_page
c_func
(paren
id|pp
)paren
suffix:semicolon
id|offset
op_assign
l_int|0
suffix:semicolon
)brace
id|done
suffix:colon
id|fp-&gt;f_pos
op_assign
(paren
(paren
id|page
op_lshift
id|PAGE_CACHE_SHIFT
)paren
op_or
id|offset
)paren
op_plus
l_int|2
suffix:semicolon
id|out
suffix:colon
id|fp-&gt;f_version
op_assign
id|ip-&gt;i_version
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
eof
