multiline_comment|/*&n; * Copyright (c) 2000-2001 Christoph Hellwig.&n; * All rights reserved.&n; *&n; * Redistribution and use in source and binary forms, with or without&n; * modification, are permitted provided that the following conditions&n; * are met:&n; * 1. Redistributions of source code must retain the above copyright&n; *    notice, this list of conditions, and the following disclaimer,&n; *    without modification.&n; * 2. The name of the author may not be used to endorse or promote products&n; *    derived from this software without specific prior written permission.&n; *&n; * Alternatively, this software may be distributed under the terms of the&n; * GNU General Public License (&quot;GPL&quot;).&n; *&n; * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS&squot;&squot; AND&n; * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE&n; * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE&n; * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR&n; * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL&n; * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS&n; * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)&n; * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT&n; * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY&n; * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF&n; * SUCH DAMAGE.&n; */
macro_line|#ident &quot;$Id: vxfs_subr.c,v 1.5 2001/04/26 22:49:51 hch Exp hch $&quot;
multiline_comment|/*&n; * Veritas filesystem driver - shared subroutines.&n; */
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/pagemap.h&gt;
macro_line|#include &quot;vxfs_extern.h&quot;
r_static
r_int
id|vxfs_readpage
c_func
(paren
r_struct
id|file
op_star
comma
r_struct
id|page
op_star
)paren
suffix:semicolon
r_static
r_int
id|vxfs_bmap
c_func
(paren
r_struct
id|address_space
op_star
comma
r_int
)paren
suffix:semicolon
DECL|variable|vxfs_aops
r_struct
id|address_space_operations
id|vxfs_aops
op_assign
(brace
dot
id|readpage
op_assign
id|vxfs_readpage
comma
dot
id|bmap
op_assign
id|vxfs_bmap
comma
dot
id|sync_page
op_assign
id|block_sync_page
comma
)brace
suffix:semicolon
multiline_comment|/**&n; * vxfs_get_page - read a page into memory.&n; * @ip:&t;&t;inode to read from&n; * @n:&t;&t;page number&n; *&n; * Description:&n; *   vxfs_get_page reads the @n th page of @ip into the pagecache.&n; *&n; * Returns:&n; *   The wanted page on success, else a NULL pointer.&n; */
r_struct
id|page
op_star
DECL|function|vxfs_get_page
id|vxfs_get_page
c_func
(paren
r_struct
id|inode
op_star
id|ip
comma
id|u_long
id|n
)paren
(brace
r_struct
id|address_space
op_star
id|mapping
op_assign
id|ip-&gt;i_mapping
suffix:semicolon
r_struct
id|page
op_star
id|pp
suffix:semicolon
id|pp
op_assign
id|read_cache_page
c_func
(paren
id|mapping
comma
id|n
comma
(paren
id|filler_t
op_star
)paren
id|mapping-&gt;a_ops-&gt;readpage
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|IS_ERR
c_func
(paren
id|pp
)paren
)paren
(brace
id|wait_on_page
c_func
(paren
id|pp
)paren
suffix:semicolon
id|kmap
c_func
(paren
id|pp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|Page_Uptodate
c_func
(paren
id|pp
)paren
)paren
r_goto
id|fail
suffix:semicolon
multiline_comment|/** if (!PageChecked(pp)) **/
multiline_comment|/** vxfs_check_page(pp); **/
r_if
c_cond
(paren
id|PageError
c_func
(paren
id|pp
)paren
)paren
r_goto
id|fail
suffix:semicolon
)brace
r_return
(paren
id|pp
)paren
suffix:semicolon
id|fail
suffix:colon
id|vxfs_put_page
c_func
(paren
id|pp
)paren
suffix:semicolon
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|EIO
)paren
suffix:semicolon
)brace
id|__inline__
r_void
DECL|function|vxfs_put_page
id|vxfs_put_page
c_func
(paren
r_struct
id|page
op_star
id|pp
)paren
(brace
id|kunmap
c_func
(paren
id|pp
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|pp
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * vxfs_bread - read buffer for a give inode,block tuple&n; * @ip:&t;&t;inode&n; * @block:&t;logical block&n; *&n; * Description:&n; *   The vxfs_bread function reads block no @block  of&n; *   @ip into the buffercache.&n; *&n; * Returns:&n; *   The resulting &amp;struct buffer_head.&n; */
r_struct
id|buffer_head
op_star
DECL|function|vxfs_bread
id|vxfs_bread
c_func
(paren
r_struct
id|inode
op_star
id|ip
comma
r_int
id|block
)paren
(brace
r_struct
id|buffer_head
op_star
id|bp
suffix:semicolon
id|daddr_t
id|pblock
suffix:semicolon
id|pblock
op_assign
id|vxfs_bmap1
c_func
(paren
id|ip
comma
id|block
)paren
suffix:semicolon
id|bp
op_assign
id|bread
c_func
(paren
id|ip-&gt;i_dev
comma
id|pblock
comma
id|ip-&gt;i_sb-&gt;s_blocksize
)paren
suffix:semicolon
r_return
(paren
id|bp
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * vxfs_get_block - locate buffer for given inode,block tuple &n; * @ip:&t;&t;inode&n; * @iblock:&t;logical block&n; * @bp:&t;&t;buffer skeleton&n; * @create:&t;%TRUE if blocks may be newly allocated.&n; *&n; * Description:&n; *   The vxfs_get_block function fills @bp with the right physical&n; *   block and device number to perform a lowlevel read/write on&n; *   it.&n; *&n; * Returns:&n; *   Zero on success, else a negativ error code (-EIO).&n; */
r_static
r_int
DECL|function|vxfs_getblk
id|vxfs_getblk
c_func
(paren
r_struct
id|inode
op_star
id|ip
comma
r_int
id|iblock
comma
r_struct
id|buffer_head
op_star
id|bp
comma
r_int
id|create
)paren
(brace
id|daddr_t
id|pblock
suffix:semicolon
id|pblock
op_assign
id|vxfs_bmap1
c_func
(paren
id|ip
comma
id|iblock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pblock
op_ne
l_int|0
)paren
(brace
id|bp-&gt;b_dev
op_assign
id|ip-&gt;i_dev
suffix:semicolon
id|bp-&gt;b_blocknr
op_assign
id|pblock
suffix:semicolon
id|bp-&gt;b_state
op_or_assign
(paren
l_int|1UL
op_lshift
id|BH_Mapped
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/**&n; * vxfs_readpage - read one page synchronously into the pagecache&n; * @file:&t;file context (unused)&n; * @page:&t;page frame to fill in.&n; *&n; * Description:&n; *   The vxfs_readpage routine reads @page synchronously into the&n; *   pagecache.&n; *&n; * Returns:&n; *   Zero on success, else a negative error code.&n; *&n; * Locking status:&n; *   @page is locked and will be unlocked.&n; */
r_static
r_int
DECL|function|vxfs_readpage
id|vxfs_readpage
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_struct
id|page
op_star
id|page
)paren
(brace
r_return
id|block_read_full_page
c_func
(paren
id|page
comma
id|vxfs_getblk
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * vxfs_bmap - perform logical to physical block mapping&n; * @mapping:&t;logical to physical mapping to use&n; * @block:&t;logical block (relative to @mapping).&n; *&n; * Description:&n; *   Vxfs_bmap find out the corresponding phsical block to the&n; *   @mapping, @block pair.&n; *&n; * Returns:&n; *   Physical block number on success, else Zero.&n; *&n; * Locking status:&n; *   We are under the bkl.&n; */
r_static
r_int
DECL|function|vxfs_bmap
id|vxfs_bmap
c_func
(paren
r_struct
id|address_space
op_star
id|mapping
comma
r_int
id|block
)paren
(brace
r_return
id|generic_block_bmap
c_func
(paren
id|mapping
comma
id|block
comma
id|vxfs_getblk
)paren
suffix:semicolon
)brace
eof
