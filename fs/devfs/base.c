multiline_comment|/*  devfs (Device FileSystem) driver.&n;&n;    Copyright (C) 1998-2002  Richard Gooch&n;&n;    This library is free software; you can redistribute it and/or&n;    modify it under the terms of the GNU Library General Public&n;    License as published by the Free Software Foundation; either&n;    version 2 of the License, or (at your option) any later version.&n;&n;    This library is distributed in the hope that it will be useful,&n;    but WITHOUT ANY WARRANTY; without even the implied warranty of&n;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU&n;    Library General Public License for more details.&n;&n;    You should have received a copy of the GNU Library General Public&n;    License along with this library; if not, write to the Free&n;    Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.&n;&n;    Richard Gooch may be reached by email at  rgooch@atnf.csiro.au&n;    The postal address is:&n;      Richard Gooch, c/o ATNF, P. O. Box 76, Epping, N.S.W., 2121, Australia.&n;&n;    ChangeLog&n;&n;    19980110   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;               Original version.&n;  v0.1&n;    19980111   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;               Created per-fs inode table rather than using inode-&gt;u.generic_ip&n;  v0.2&n;    19980111   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;               Created .epoch inode which has a ctime of 0.&n;&t;       Fixed loss of named pipes when dentries lost.&n;&t;       Fixed loss of inode data when devfs_register() follows mknod().&n;  v0.3&n;    19980111   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;               Fix for when compiling with CONFIG_KERNELD.&n;    19980112   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;               Fix for readdir() which sometimes didn&squot;t show entries.&n;&t;       Added &lt;&lt;tolerant&gt;&gt; option to &lt;devfs_register&gt;.&n;  v0.4&n;    19980113   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;               Created &lt;devfs_fill_file&gt; function.&n;  v0.5&n;    19980115   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;               Added subdirectory support. Major restructuring.&n;    19980116   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;               Fixed &lt;find_by_dev&gt; to not search major=0,minor=0.&n;&t;       Added symlink support.&n;  v0.6&n;    19980120   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;               Created &lt;devfs_mk_dir&gt; function and support directory unregister&n;    19980120   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;               Auto-ownership uses real uid/gid rather than effective uid/gid.&n;  v0.7&n;    19980121   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;               Supported creation of sockets.&n;  v0.8&n;    19980122   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;               Added DEVFS_FL_HIDE_UNREG flag.&n;&t;       Interface change to &lt;devfs_mk_symlink&gt;.&n;               Created &lt;devfs_symlink&gt; to support symlink(2).&n;  v0.9&n;    19980123   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;               Added check to &lt;devfs_fill_file&gt; to check inode is in devfs.&n;&t;       Added optional traversal of symlinks.&n;  v0.10&n;    19980124   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;               Created &lt;devfs_get_flags&gt; and &lt;devfs_set_flags&gt;.&n;  v0.11&n;    19980125   C. Scott Ananian &lt;cananian@alumni.princeton.edu&gt;&n;               Created &lt;devfs_find_handle&gt;.&n;    19980125   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;               Allow removal of symlinks.&n;  v0.12&n;    19980125   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;               Created &lt;devfs_set_symlink_destination&gt;.&n;    19980126   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;               Moved DEVFS_SUPER_MAGIC into header file.&n;&t;       Added DEVFS_FL_HIDE flag.&n;&t;       Created &lt;devfs_get_maj_min&gt;.&n;&t;       Created &lt;devfs_get_handle_from_inode&gt;.&n;&t;       Fixed minor bug in &lt;find_by_dev&gt;.&n;    19980127   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Changed interface to &lt;find_by_dev&gt;, &lt;find_entry&gt;,&n;&t;       &lt;devfs_unregister&gt;, &lt;devfs_fill_file&gt; and &lt;devfs_find_handle&gt;.&n;&t;       Fixed inode times when symlink created with symlink(2).&n;  v0.13&n;    19980129   C. Scott Ananian &lt;cananian@alumni.princeton.edu&gt;&n;               Exported &lt;devfs_set_symlink_destination&gt;, &lt;devfs_get_maj_min&gt;&n;&t;       and &lt;devfs_get_handle_from_inode&gt;.&n;    19980129   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Created &lt;devfs_unlink&gt; to support unlink(2).&n;  v0.14&n;    19980129   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Fixed kerneld support for entries in devfs subdirectories.&n;    19980130   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Bugfixes in &lt;call_kerneld&gt;.&n;  v0.15&n;    19980207   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Call kerneld when looking up unregistered entries.&n;  v0.16&n;    19980326   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Modified interface to &lt;devfs_find_handle&gt; for symlink traversal.&n;  v0.17&n;    19980331   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Fixed persistence bug with device numbers for manually created&n;&t;       device files.&n;&t;       Fixed problem with recreating symlinks with different content.&n;  v0.18&n;    19980401   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Changed to CONFIG_KMOD.&n;&t;       Hide entries which are manually unlinked.&n;&t;       Always invalidate devfs dentry cache when registering entries.&n;&t;       Created &lt;devfs_rmdir&gt; to support rmdir(2).&n;&t;       Ensure directories created by &lt;devfs_mk_dir&gt; are visible.&n;  v0.19&n;    19980402   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Invalidate devfs dentry cache when making directories.&n;&t;       Invalidate devfs dentry cache when removing entries.&n;&t;       Fixed persistence bug with fifos.&n;  v0.20&n;    19980421   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Print process command when debugging kerneld/kmod.&n;&t;       Added debugging for register/unregister/change operations.&n;    19980422   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Added &quot;devfs=&quot; boot options.&n;  v0.21&n;    19980426   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       No longer lock/unlock superblock in &lt;devfs_put_super&gt;.&n;&t;       Drop negative dentries when they are released.&n;&t;       Manage dcache more efficiently.&n;  v0.22&n;    19980427   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Added DEVFS_FL_AUTO_DEVNUM flag.&n;  v0.23&n;    19980430   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       No longer set unnecessary methods.&n;  v0.24&n;    19980504   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Added PID display to &lt;call_kerneld&gt; debugging message.&n;&t;       Added &quot;after&quot; debugging message to &lt;call_kerneld&gt;.&n;    19980519   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Added &quot;diread&quot; and &quot;diwrite&quot; boot options.&n;    19980520   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Fixed persistence problem with permissions.&n;  v0.25&n;    19980602   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Support legacy device nodes.&n;&t;       Fixed bug where recreated inodes were hidden.&n;  v0.26&n;    19980602   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Improved debugging in &lt;get_vfs_inode&gt;.&n;    19980607   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       No longer free old dentries in &lt;devfs_mk_dir&gt;.&n;&t;       Free all dentries for a given entry when deleting inodes.&n;  v0.27&n;    19980627   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Limit auto-device numbering to majors 128 to 239.&n;  v0.28&n;    19980629   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Fixed inode times persistence problem.&n;  v0.29&n;    19980704   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Fixed spelling in &lt;devfs_readlink&gt; debug.&n;&t;       Fixed bug in &lt;devfs_setup&gt; parsing &quot;dilookup&quot;.&n;  v0.30&n;    19980705   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Fixed devfs inode leak when manually recreating inodes.&n;&t;       Fixed permission persistence problem when recreating inodes.&n;  v0.31&n;    19980727   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Removed harmless &quot;unused variable&quot; compiler warning.&n;&t;       Fixed modes for manually recreated device nodes.&n;  v0.32&n;    19980728   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Added NULL devfs inode warning in &lt;devfs_read_inode&gt;.&n;&t;       Force all inode nlink values to 1.&n;  v0.33&n;    19980730   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Added &quot;dimknod&quot; boot option.&n;&t;       Set inode nlink to 0 when freeing dentries.&n;&t;       Fixed modes for manually recreated symlinks.&n;  v0.34&n;    19980802   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Fixed bugs in recreated directories and symlinks.&n;  v0.35&n;    19980806   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Fixed bugs in recreated device nodes.&n;    19980807   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Fixed bug in currently unused &lt;devfs_get_handle_from_inode&gt;.&n;&t;       Defined new &lt;devfs_handle_t&gt; type.&n;&t;       Improved debugging when getting entries.&n;&t;       Fixed bug where directories could be emptied.&n;  v0.36&n;    19980809   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Replaced dummy .epoch inode with .devfsd character device.&n;    19980810   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Implemented devfsd protocol revision 0.&n;  v0.37&n;    19980819   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Added soothing message to warning in &lt;devfs_d_iput&gt;.&n;  v0.38&n;    19980829   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Use GCC extensions for structure initialisations.&n;&t;       Implemented async open notification.&n;&t;       Incremented devfsd protocol revision to 1.&n;  v0.39&n;    19980908   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Moved async open notification to end of &lt;devfs_open&gt;.&n;  v0.40&n;    19980910   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Prepended &quot;/dev/&quot; to module load request.&n;&t;       Renamed &lt;call_kerneld&gt; to &lt;call_kmod&gt;.&n;  v0.41&n;    19980910   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Fixed typo &quot;AYSNC&quot; -&gt; &quot;ASYNC&quot;.&n;  v0.42&n;    19980910   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Added open flag for files.&n;  v0.43&n;    19980927   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Set i_blocks=0 and i_blksize=1024 in &lt;devfs_read_inode&gt;.&n;  v0.44&n;    19981005   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Added test for empty &lt;&lt;name&gt;&gt; in &lt;devfs_find_handle&gt;.&n;&t;       Renamed &lt;generate_path&gt; to &lt;devfs_generate_path&gt; and published.&n;  v0.45&n;    19981006   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Created &lt;devfs_get_fops&gt;.&n;  v0.46&n;    19981007   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Limit auto-device numbering to majors 144 to 239.&n;  v0.47&n;    19981010   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Updated &lt;devfs_follow_link&gt; for VFS change in 2.1.125.&n;  v0.48&n;    19981022   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Created DEVFS_ FL_COMPAT flag.&n;  v0.49&n;    19981023   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Created &quot;nocompat&quot; boot option.&n;  v0.50&n;    19981025   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Replaced &quot;mount&quot; boot option with &quot;nomount&quot;.&n;  v0.51&n;    19981110   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Created &quot;only&quot; boot option.&n;  v0.52&n;    19981112   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Added DEVFS_FL_REMOVABLE flag.&n;  v0.53&n;    19981114   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Only call &lt;scan_dir_for_removable&gt; on first call to&n;&t;       &lt;devfs_readdir&gt;.&n;  v0.54&n;    19981205   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Updated &lt;devfs_rmdir&gt; for VFS change in 2.1.131.&n;  v0.55&n;    19981218   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Created &lt;devfs_mk_compat&gt;.&n;    19981220   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Check for partitions on removable media in &lt;devfs_lookup&gt;.&n;  v0.56&n;    19990118   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Added support for registering regular files.&n;&t;       Created &lt;devfs_set_file_size&gt;.&n;&t;       Update devfs inodes from entries if not changed through FS.&n;  v0.57&n;    19990124   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Fixed &lt;devfs_fill_file&gt; to only initialise temporary inodes.&n;&t;       Trap for NULL fops in &lt;devfs_register&gt;.&n;&t;       Return -ENODEV in &lt;devfs_fill_file&gt; for non-driver inodes.&n;  v0.58&n;    19990126   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Switched from PATH_MAX to DEVFS_PATHLEN.&n;  v0.59&n;    19990127   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Created &quot;nottycompat&quot; boot option.&n;  v0.60&n;    19990318   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Fixed &lt;devfsd_read&gt; to not overrun event buffer.&n;  v0.61&n;    19990329   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Created &lt;devfs_auto_unregister&gt;.&n;  v0.62&n;    19990330   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Don&squot;t return unregistred entries in &lt;devfs_find_handle&gt;.&n;&t;       Panic in &lt;devfs_unregister&gt; if entry unregistered.&n;    19990401   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Don&squot;t panic in &lt;devfs_auto_unregister&gt; for duplicates.&n;  v0.63&n;    19990402   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Don&squot;t unregister already unregistered entries in &lt;unregister&gt;.&n;  v0.64&n;    19990510   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Disable warning messages when unable to read partition table for&n;&t;       removable media.&n;  v0.65&n;    19990512   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Updated &lt;devfs_lookup&gt; for VFS change in 2.3.1-pre1.&n;&t;       Created &quot;oops-on-panic&quot; boot option.&n;&t;       Improved debugging in &lt;devfs_register&gt; and &lt;devfs_unregister&gt;.&n;  v0.66&n;    19990519   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Added documentation for some functions.&n;    19990525   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Removed &quot;oops-on-panic&quot; boot option: now always Oops.&n;  v0.67&n;    19990531   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Improved debugging in &lt;devfs_register&gt;.&n;  v0.68&n;    19990604   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Added &quot;diunlink&quot; and &quot;nokmod&quot; boot options.&n;&t;       Removed superfluous warning message in &lt;devfs_d_iput&gt;.&n;  v0.69&n;    19990611   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Took account of change to &lt;d_alloc_root&gt;.&n;  v0.70&n;    19990614   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Created separate event queue for each mounted devfs.&n;&t;       Removed &lt;devfs_invalidate_dcache&gt;.&n;&t;       Created new ioctl()s.&n;&t;       Incremented devfsd protocol revision to 3.&n;&t;       Fixed bug when re-creating directories: contents were lost.&n;&t;       Block access to inodes until devfsd updates permissions.&n;    19990615   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Support 2.2.x kernels.&n;  v0.71&n;    19990623   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Switched to sending process uid/gid to devfsd.&n;&t;       Renamed &lt;call_kmod&gt; to &lt;try_modload&gt;.&n;&t;       Added DEVFSD_NOTIFY_LOOKUP event.&n;    19990624   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Added DEVFSD_NOTIFY_CHANGE event.&n;&t;       Incremented devfsd protocol revision to 4.&n;  v0.72&n;    19990713   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Return EISDIR rather than EINVAL for read(2) on directories.&n;  v0.73&n;    19990809   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Changed &lt;devfs_setup&gt; to new __init scheme.&n;  v0.74&n;    19990901   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Changed remaining function declarations to new __init scheme.&n;  v0.75&n;    19991013   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Created &lt;devfs_get_info&gt;, &lt;devfs_set_info&gt;,&n;&t;       &lt;devfs_get_first_child&gt; and &lt;devfs_get_next_sibling&gt;.&n;&t;       Added &lt;&lt;dir&gt;&gt; parameter to &lt;devfs_register&gt;, &lt;devfs_mk_compat&gt;,&n;&t;       &lt;devfs_mk_dir&gt; and &lt;devfs_find_handle&gt;.&n;&t;       Work sponsored by SGI.&n;  v0.76&n;    19991017   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Allow multiple unregistrations.&n;&t;       Work sponsored by SGI.&n;  v0.77&n;    19991026   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Added major and minor number to devfsd protocol.&n;&t;       Incremented devfsd protocol revision to 5.&n;&t;       Work sponsored by SGI.&n;  v0.78&n;    19991030   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Support info pointer for all devfs entry types.&n;&t;       Added &lt;&lt;info&gt;&gt; parameter to &lt;devfs_mk_dir&gt; and&n;&t;       &lt;devfs_mk_symlink&gt;.&n;&t;       Work sponsored by SGI.&n;  v0.79&n;    19991031   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Support &quot;../&quot; when searching devfs namespace.&n;&t;       Work sponsored by SGI.&n;  v0.80&n;    19991101   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Created &lt;devfs_get_unregister_slave&gt;.&n;&t;       Work sponsored by SGI.&n;  v0.81&n;    19991103   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Exported &lt;devfs_get_parent&gt;.&n;&t;       Work sponsored by SGI.&n;  v0.82&n;    19991104   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;               Removed unused &lt;devfs_set_symlink_destination&gt;.&n;    19991105   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;               Do not hide entries from devfsd or children.&n;&t;       Removed DEVFS_ FL_TTY_COMPAT flag.&n;&t;       Removed &quot;nottycompat&quot; boot option.&n;&t;       Removed &lt;devfs_mk_compat&gt;.&n;&t;       Work sponsored by SGI.&n;  v0.83&n;    19991107   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Added DEVFS_FL_WAIT flag.&n;&t;       Work sponsored by SGI.&n;  v0.84&n;    19991107   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Support new &quot;disc&quot; naming scheme in &lt;get_removable_partition&gt;.&n;&t;       Allow NULL fops in &lt;devfs_register&gt;.&n;&t;       Work sponsored by SGI.&n;  v0.85&n;    19991110   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Fall back to major table if NULL fops given to &lt;devfs_register&gt;.&n;&t;       Work sponsored by SGI.&n;  v0.86&n;    19991204   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Support fifos when unregistering.&n;&t;       Work sponsored by SGI.&n;  v0.87&n;    19991209   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Removed obsolete DEVFS_ FL_COMPAT and DEVFS_ FL_TOLERANT flags.&n;&t;       Work sponsored by SGI.&n;  v0.88&n;    19991214   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Removed kmod support.&n;&t;       Work sponsored by SGI.&n;  v0.89&n;    19991216   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Improved debugging in &lt;get_vfs_inode&gt;.&n;&t;       Ensure dentries created by devfsd will be cleaned up.&n;&t;       Work sponsored by SGI.&n;  v0.90&n;    19991223   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Created &lt;devfs_get_name&gt;.&n;&t;       Work sponsored by SGI.&n;  v0.91&n;    20000203   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Ported to kernel 2.3.42.&n;&t;       Removed &lt;devfs_fill_file&gt;.&n;&t;       Work sponsored by SGI.&n;  v0.92&n;    20000306   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Added DEVFS_ FL_NO_PERSISTENCE flag.&n;&t;       Removed unnecessary call to &lt;update_devfs_inode_from_entry&gt; in&n;&t;       &lt;devfs_readdir&gt;.&n;&t;       Work sponsored by SGI.&n;  v0.93&n;    20000413   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Set inode-&gt;i_size to correct size for symlinks.&n;    20000414   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Only give lookup() method to directories to comply with new VFS&n;&t;       assumptions.&n;&t;       Work sponsored by SGI.&n;    20000415   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Remove unnecessary tests in symlink methods.&n;&t;       Don&squot;t kill existing block ops in &lt;devfs_read_inode&gt;.&n;&t;       Work sponsored by SGI.&n;  v0.94&n;    20000424   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Don&squot;t create missing directories in &lt;devfs_find_handle&gt;.&n;&t;       Work sponsored by SGI.&n;  v0.95&n;    20000430   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Added CONFIG_DEVFS_MOUNT.&n;&t;       Work sponsored by SGI.&n;  v0.96&n;    20000608   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Disabled multi-mount capability (use VFS bindings instead).&n;&t;       Work sponsored by SGI.&n;  v0.97&n;    20000610   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Switched to FS_SINGLE to disable multi-mounts.&n;    20000612   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Removed module support.&n;&t;       Removed multi-mount code.&n;&t;       Removed compatibility macros: VFS has changed too much.&n;&t;       Work sponsored by SGI.&n;  v0.98&n;    20000614   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Merged devfs inode into devfs entry.&n;&t;       Work sponsored by SGI.&n;  v0.99&n;    20000619   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Removed dead code in &lt;devfs_register&gt; which used to call&n;&t;       &lt;free_dentries&gt;.&n;&t;       Work sponsored by SGI.&n;  v0.100&n;    20000621   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Changed interface to &lt;devfs_register&gt;.&n;&t;       Work sponsored by SGI.&n;  v0.101&n;    20000622   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Simplified interface to &lt;devfs_mk_symlink&gt; and &lt;devfs_mk_dir&gt;.&n;&t;       Simplified interface to &lt;devfs_find_handle&gt;.&n;&t;       Work sponsored by SGI.&n;  v0.102&n;    20010519   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Ensure &lt;devfs_generate_path&gt; terminates string for root entry.&n;&t;       Exported &lt;devfs_get_name&gt; to modules.&n;    20010520   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Make &lt;devfs_mk_symlink&gt; send events to devfsd.&n;&t;       Cleaned up option processing in &lt;devfs_setup&gt;.&n;    20010521   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Fixed bugs in handling symlinks: could leak or cause Oops.&n;    20010522   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Cleaned up directory handling by separating fops.&n;  v0.103&n;    20010601   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Fixed handling of inverted options in &lt;devfs_setup&gt;.&n;  v0.104&n;    20010604   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Adjusted &lt;try_modload&gt; to account for &lt;devfs_generate_path&gt; fix.&n;  v0.105&n;    20010617   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Answered question posed by Al Viro and removed his comments.&n;&t;       Moved setting of registered flag after other fields are changed.&n;&t;       Fixed race between &lt;devfsd_close&gt; and &lt;devfsd_notify_one&gt;.&n;&t;       Global VFS changes added bogus BKL to &lt;devfsd_close&gt;: removed.&n;&t;       Widened locking in &lt;devfs_readlink&gt; and &lt;devfs_follow_link&gt;.&n;&t;       Replaced &lt;devfsd_read&gt; stack usage with &lt;devfsd_ioctl&gt; kmalloc.&n;&t;       Simplified locking in &lt;devfsd_ioctl&gt; and fixed memory leak.&n;  v0.106&n;    20010709   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Removed broken devnum allocation and use &lt;devfs_alloc_devnum&gt;.&n;&t;       Fixed old devnum leak by calling new &lt;devfs_dealloc_devnum&gt;.&n;  v0.107&n;    20010712   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Fixed bug in &lt;devfs_setup&gt; which could hang boot process.&n;  v0.108&n;    20010730   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Added DEVFSD_NOTIFY_DELETE event.&n;    20010801   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Removed #include &lt;asm/segment.h&gt;.&n;  v0.109&n;    20010807   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Fixed inode table races by removing it and using&n;&t;       inode-&gt;u.generic_ip instead.&n;&t;       Moved &lt;devfs_read_inode&gt; into &lt;get_vfs_inode&gt;.&n;&t;       Moved &lt;devfs_write_inode&gt; into &lt;devfs_notify_change&gt;.&n;  v0.110&n;    20010808   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Fixed race in &lt;devfs_do_symlink&gt; for uni-processor.&n;  v0.111&n;    20010818   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Removed remnant of multi-mount support in &lt;devfs_mknod&gt;.&n;               Removed unused DEVFS_FL_SHOW_UNREG flag.&n;  v0.112&n;    20010820   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Removed nlink field from struct devfs_inode.&n;  v0.113&n;    20010823   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Replaced BKL with global rwsem to protect symlink data (quick&n;&t;       and dirty hack).&n;  v0.114&n;    20010827   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Replaced global rwsem for symlink with per-link refcount.&n;  v0.115&n;    20010919   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Set inode-&gt;i_mapping-&gt;a_ops for block nodes in &lt;get_vfs_inode&gt;.&n;  v0.116&n;    20011008   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Fixed overrun in &lt;devfs_link&gt; by removing function (not needed).&n;    20011009   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Fixed buffer underrun in &lt;try_modload&gt;.&n;    20011029   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Fixed race in &lt;devfsd_ioctl&gt; when setting event mask.&n;    20011114   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       First release of new locking code.&n;  v1.0&n;    20011117   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Discard temporary buffer, now use &quot;%s&quot; for dentry names.&n;    20011118   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Don&squot;t generate path in &lt;try_modload&gt;: use fake entry instead.&n;&t;       Use &quot;existing&quot; directory in &lt;_devfs_make_parent_for_leaf&gt;.&n;    20011122   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Use slab cache rather than fixed buffer for devfsd events.&n;  v1.1&n;    20011125   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Send DEVFSD_NOTIFY_REGISTERED events in &lt;devfs_mk_dir&gt;.&n;    20011127   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Fixed locking bug in &lt;devfs_d_revalidate_wait&gt; due to typo.&n;&t;       Do not send CREATE, CHANGE, ASYNC_OPEN or DELETE events from&n;&t;       devfsd or children.&n;  v1.2&n;    20011202   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Fixed bug in &lt;devfsd_read&gt;: was dereferencing freed pointer.&n;  v1.3&n;    20011203   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Fixed bug in &lt;devfsd_close&gt;: was dereferencing freed pointer.&n;&t;       Added process group check for devfsd privileges.&n;  v1.4&n;    20011204   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Use SLAB_ATOMIC in &lt;devfsd_notify_de&gt; from &lt;devfs_d_delete&gt;.&n;  v1.5&n;    20011211   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Return old entry in &lt;devfs_mk_dir&gt; for 2.4.x kernels.&n;    20011212   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Increment refcount on module in &lt;check_disc_changed&gt;.&n;    20011215   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Created &lt;devfs_get_handle&gt; and exported &lt;devfs_put&gt;.&n;&t;       Increment refcount on module in &lt;devfs_get_ops&gt;.&n;&t;       Created &lt;devfs_put_ops&gt;.&n;  v1.6&n;    20011216   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Added poisoning to &lt;devfs_put&gt;.&n;&t;       Improved debugging messages.&n;  v1.7&n;    20011221   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Corrected (made useful) debugging message in &lt;unregister&gt;.&n;&t;       Moved &lt;kmem_cache_create&gt; in &lt;mount_devfs_fs&gt; to &lt;init_devfs_fs&gt;&n;    20011224   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Added magic number to guard against scribbling drivers.&n;    20011226   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Only return old entry in &lt;devfs_mk_dir&gt; if a directory.&n;&t;       Defined macros for error and debug messages.&n;  v1.8&n;    20020113   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Fixed (rare, old) race in &lt;devfs_lookup&gt;.&n;  v1.9&n;    20020120   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Fixed deadlock bug in &lt;devfs_d_revalidate_wait&gt;.&n;&t;       Tag VFS deletable in &lt;devfs_mk_symlink&gt; if handle ignored.&n;  v1.10&n;    20020129   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Added KERN_* to remaining messages.&n;&t;       Cleaned up declaration of &lt;stat_read&gt;.&n;  v1.11&n;    20020219   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Changed &lt;devfs_rmdir&gt; to allow later additions if not yet empty.&n;  v1.12&n;    20020406   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Removed silently introduced calls to lock_kernel() and&n;&t;       unlock_kernel() due to recent VFS locking changes. BKL isn&squot;t&n;&t;       required in devfs.&n;  v1.13&n;    20020428   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Removed 2.4.x compatibility code.&n;  v1.14&n;    20020510   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Added BKL to &lt;devfs_open&gt; because drivers still need it.&n;  v1.15&n;    20020512   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Protected &lt;scan_dir_for_removable&gt; and &lt;get_removable_partition&gt;&n;&t;       from changing directory contents.&n;  v1.16&n;    20020514   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Minor cleanup of &lt;scan_dir_for_removable&gt;.&n;  v1.17&n;    20020721   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Switched to ISO C structure field initialisers.&n;&t;       Switch to set_current_state() and move before add_wait_queue().&n;    20020722   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Fixed devfs entry leak in &lt;devfs_readdir&gt; when *readdir fails.&n;  v1.18&n;    20020725   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Created &lt;devfs_find_and_unregister&gt;.&n;  v1.19&n;    20020728   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Removed deprecated &lt;devfs_find_handle&gt;.&n;  v1.20&n;    20020820   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Fixed module unload race in &lt;devfs_open&gt;.&n;  v1.21&n;    20021013   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Removed DEVFS_ FL_AUTO_OWNER.&n;&t;       Switched lingering structure field initialiser to ISO C.&n;&t;       Added locking when updating FCB flags.&n;  v1.22&n;*/
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/time.h&gt;
macro_line|#include &lt;linux/tty.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/wait.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/ctype.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/devfs_fs.h&gt;
macro_line|#include &lt;linux/devfs_fs_kernel.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/smp.h&gt;
macro_line|#include &lt;linux/rwsem.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/namei.h&gt;
macro_line|#include &lt;linux/bitops.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/processor.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
macro_line|#include &lt;asm/atomic.h&gt;
DECL|macro|DEVFS_VERSION
mdefine_line|#define DEVFS_VERSION            &quot;2004-01-31&quot;
DECL|macro|DEVFS_NAME
mdefine_line|#define DEVFS_NAME &quot;devfs&quot;
DECL|macro|FIRST_INODE
mdefine_line|#define FIRST_INODE 1
DECL|macro|STRING_LENGTH
mdefine_line|#define STRING_LENGTH 256
DECL|macro|FAKE_BLOCK_SIZE
mdefine_line|#define FAKE_BLOCK_SIZE 1024
DECL|macro|POISON_PTR
mdefine_line|#define POISON_PTR ( *(void **) poison_array )
DECL|macro|MAGIC_VALUE
mdefine_line|#define MAGIC_VALUE 0x327db823
macro_line|#ifndef TRUE
DECL|macro|TRUE
macro_line|#  define TRUE 1
DECL|macro|FALSE
macro_line|#  define FALSE 0
macro_line|#endif
DECL|macro|MODE_DIR
mdefine_line|#define MODE_DIR (S_IFDIR | S_IWUSR | S_IRUGO | S_IXUGO)
DECL|macro|DEBUG_NONE
mdefine_line|#define DEBUG_NONE         0x0000000
DECL|macro|DEBUG_MODULE_LOAD
mdefine_line|#define DEBUG_MODULE_LOAD  0x0000001
DECL|macro|DEBUG_REGISTER
mdefine_line|#define DEBUG_REGISTER     0x0000002
DECL|macro|DEBUG_UNREGISTER
mdefine_line|#define DEBUG_UNREGISTER   0x0000004
DECL|macro|DEBUG_FREE
mdefine_line|#define DEBUG_FREE         0x0000008
DECL|macro|DEBUG_SET_FLAGS
mdefine_line|#define DEBUG_SET_FLAGS    0x0000010
DECL|macro|DEBUG_S_READ
mdefine_line|#define DEBUG_S_READ       0x0000100&t;/*  Break  */
DECL|macro|DEBUG_I_LOOKUP
mdefine_line|#define DEBUG_I_LOOKUP     0x0001000&t;/*  Break  */
DECL|macro|DEBUG_I_CREATE
mdefine_line|#define DEBUG_I_CREATE     0x0002000
DECL|macro|DEBUG_I_GET
mdefine_line|#define DEBUG_I_GET        0x0004000
DECL|macro|DEBUG_I_CHANGE
mdefine_line|#define DEBUG_I_CHANGE     0x0008000
DECL|macro|DEBUG_I_UNLINK
mdefine_line|#define DEBUG_I_UNLINK     0x0010000
DECL|macro|DEBUG_I_RLINK
mdefine_line|#define DEBUG_I_RLINK      0x0020000
DECL|macro|DEBUG_I_FLINK
mdefine_line|#define DEBUG_I_FLINK      0x0040000
DECL|macro|DEBUG_I_MKNOD
mdefine_line|#define DEBUG_I_MKNOD      0x0080000
DECL|macro|DEBUG_F_READDIR
mdefine_line|#define DEBUG_F_READDIR    0x0100000&t;/*  Break  */
DECL|macro|DEBUG_D_DELETE
mdefine_line|#define DEBUG_D_DELETE     0x1000000&t;/*  Break  */
DECL|macro|DEBUG_D_RELEASE
mdefine_line|#define DEBUG_D_RELEASE    0x2000000
DECL|macro|DEBUG_D_IPUT
mdefine_line|#define DEBUG_D_IPUT       0x4000000
DECL|macro|DEBUG_ALL
mdefine_line|#define DEBUG_ALL          0xfffffff
DECL|macro|DEBUG_DISABLED
mdefine_line|#define DEBUG_DISABLED     DEBUG_NONE
DECL|macro|OPTION_NONE
mdefine_line|#define OPTION_NONE             0x00
DECL|macro|OPTION_MOUNT
mdefine_line|#define OPTION_MOUNT            0x01
DECL|macro|PRINTK
mdefine_line|#define PRINTK(format, args...) &bslash;&n;   {printk (KERN_ERR &quot;%s&quot; format, __FUNCTION__ , ## args);}
DECL|macro|OOPS
mdefine_line|#define OOPS(format, args...) &bslash;&n;   {printk (KERN_CRIT &quot;%s&quot; format, __FUNCTION__ , ## args); &bslash;&n;    printk (&quot;Forcing Oops&bslash;n&quot;); &bslash;&n;    BUG();}
macro_line|#ifdef CONFIG_DEVFS_DEBUG
DECL|macro|VERIFY_ENTRY
macro_line|#  define VERIFY_ENTRY(de) &bslash;&n;   {if ((de) &amp;&amp; (de)-&gt;magic_number != MAGIC_VALUE) &bslash;&n;        OOPS (&quot;(%p): bad magic value: %x&bslash;n&quot;, (de), (de)-&gt;magic_number);}
DECL|macro|WRITE_ENTRY_MAGIC
macro_line|#  define WRITE_ENTRY_MAGIC(de,magic) (de)-&gt;magic_number = (magic)
DECL|macro|DPRINTK
macro_line|#  define DPRINTK(flag, format, args...) &bslash;&n;   {if (devfs_debug &amp; flag) &bslash;&n;&t;printk (KERN_INFO &quot;%s&quot; format, __FUNCTION__ , ## args);}
macro_line|#else
DECL|macro|VERIFY_ENTRY
macro_line|#  define VERIFY_ENTRY(de)
DECL|macro|WRITE_ENTRY_MAGIC
macro_line|#  define WRITE_ENTRY_MAGIC(de,magic)
DECL|macro|DPRINTK
macro_line|#  define DPRINTK(flag, format, args...)
macro_line|#endif
DECL|typedef|devfs_handle_t
r_typedef
r_struct
id|devfs_entry
op_star
id|devfs_handle_t
suffix:semicolon
DECL|struct|directory_type
r_struct
id|directory_type
(brace
DECL|member|lock
id|rwlock_t
id|lock
suffix:semicolon
multiline_comment|/*  Lock for searching(R)/updating(W)   */
DECL|member|first
r_struct
id|devfs_entry
op_star
id|first
suffix:semicolon
DECL|member|last
r_struct
id|devfs_entry
op_star
id|last
suffix:semicolon
DECL|member|no_more_additions
r_int
r_char
id|no_more_additions
suffix:colon
l_int|1
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|symlink_type
r_struct
id|symlink_type
(brace
DECL|member|length
r_int
r_int
id|length
suffix:semicolon
multiline_comment|/*  Not including the NULL-termimator       */
DECL|member|linkname
r_char
op_star
id|linkname
suffix:semicolon
multiline_comment|/*  This is NULL-terminated                 */
)brace
suffix:semicolon
DECL|struct|devfs_inode
r_struct
id|devfs_inode
(brace
multiline_comment|/*  This structure is for &quot;persistent&quot; inode storage  */
DECL|member|dentry
r_struct
id|dentry
op_star
id|dentry
suffix:semicolon
DECL|member|atime
r_struct
id|timespec
id|atime
suffix:semicolon
DECL|member|mtime
r_struct
id|timespec
id|mtime
suffix:semicolon
DECL|member|ctime
r_struct
id|timespec
id|ctime
suffix:semicolon
DECL|member|ino
r_int
r_int
id|ino
suffix:semicolon
multiline_comment|/*  Inode number as seen in the VFS         */
DECL|member|uid
id|uid_t
id|uid
suffix:semicolon
DECL|member|gid
id|gid_t
id|gid
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|devfs_entry
r_struct
id|devfs_entry
(brace
macro_line|#ifdef CONFIG_DEVFS_DEBUG
DECL|member|magic_number
r_int
r_int
id|magic_number
suffix:semicolon
macro_line|#endif
DECL|member|info
r_void
op_star
id|info
suffix:semicolon
DECL|member|refcount
id|atomic_t
id|refcount
suffix:semicolon
multiline_comment|/*  When this drops to zero, it&squot;s unused    */
r_union
(brace
DECL|member|dir
r_struct
id|directory_type
id|dir
suffix:semicolon
DECL|member|dev
id|dev_t
id|dev
suffix:semicolon
DECL|member|symlink
r_struct
id|symlink_type
id|symlink
suffix:semicolon
DECL|member|name
r_const
r_char
op_star
id|name
suffix:semicolon
multiline_comment|/*  Only used for (mode == 0)               */
DECL|member|u
)brace
id|u
suffix:semicolon
DECL|member|prev
r_struct
id|devfs_entry
op_star
id|prev
suffix:semicolon
multiline_comment|/*  Previous entry in the parent directory  */
DECL|member|next
r_struct
id|devfs_entry
op_star
id|next
suffix:semicolon
multiline_comment|/*  Next entry in the parent directory      */
DECL|member|parent
r_struct
id|devfs_entry
op_star
id|parent
suffix:semicolon
multiline_comment|/*  The parent directory                    */
DECL|member|inode
r_struct
id|devfs_inode
id|inode
suffix:semicolon
DECL|member|mode
id|umode_t
id|mode
suffix:semicolon
DECL|member|namelen
r_int
r_int
id|namelen
suffix:semicolon
multiline_comment|/*  I think 64k+ filenames are a way off... */
DECL|member|vfs
r_int
r_char
id|vfs
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/*  Whether the VFS may delete the entry   */
DECL|member|name
r_char
id|name
(braket
l_int|1
)braket
suffix:semicolon
multiline_comment|/*  This is just a dummy: the allocated array&n;&t;&t;&t;&t;   is bigger. This is NULL-terminated      */
)brace
suffix:semicolon
multiline_comment|/*  The root of the device tree  */
DECL|variable|root_entry
r_static
r_struct
id|devfs_entry
op_star
id|root_entry
suffix:semicolon
DECL|struct|devfsd_buf_entry
r_struct
id|devfsd_buf_entry
(brace
DECL|member|de
r_struct
id|devfs_entry
op_star
id|de
suffix:semicolon
multiline_comment|/*  The name is generated with this         */
DECL|member|type
r_int
r_int
id|type
suffix:semicolon
multiline_comment|/*  The type of event                       */
DECL|member|mode
id|umode_t
id|mode
suffix:semicolon
DECL|member|uid
id|uid_t
id|uid
suffix:semicolon
DECL|member|gid
id|gid_t
id|gid
suffix:semicolon
DECL|member|next
r_struct
id|devfsd_buf_entry
op_star
id|next
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|fs_info
r_struct
id|fs_info
(brace
multiline_comment|/*  This structure is for the mounted devfs  */
DECL|member|sb
r_struct
id|super_block
op_star
id|sb
suffix:semicolon
DECL|member|devfsd_buffer_lock
id|spinlock_t
id|devfsd_buffer_lock
suffix:semicolon
multiline_comment|/*  Lock when inserting/deleting events  */
DECL|member|devfsd_first_event
r_struct
id|devfsd_buf_entry
op_star
id|devfsd_first_event
suffix:semicolon
DECL|member|devfsd_last_event
r_struct
id|devfsd_buf_entry
op_star
id|devfsd_last_event
suffix:semicolon
DECL|member|devfsd_sleeping
r_volatile
r_int
id|devfsd_sleeping
suffix:semicolon
DECL|member|devfsd_task
r_volatile
r_struct
id|task_struct
op_star
id|devfsd_task
suffix:semicolon
DECL|member|devfsd_pgrp
r_volatile
id|pid_t
id|devfsd_pgrp
suffix:semicolon
DECL|member|devfsd_file
r_volatile
r_struct
id|file
op_star
id|devfsd_file
suffix:semicolon
DECL|member|devfsd_info
r_struct
id|devfsd_notify_struct
op_star
id|devfsd_info
suffix:semicolon
DECL|member|devfsd_event_mask
r_volatile
r_int
r_int
id|devfsd_event_mask
suffix:semicolon
DECL|member|devfsd_overrun_count
id|atomic_t
id|devfsd_overrun_count
suffix:semicolon
DECL|member|devfsd_wait_queue
id|wait_queue_head_t
id|devfsd_wait_queue
suffix:semicolon
multiline_comment|/*  Wake devfsd on input       */
DECL|member|revalidate_wait_queue
id|wait_queue_head_t
id|revalidate_wait_queue
suffix:semicolon
multiline_comment|/*  Wake when devfsd sleeps    */
)brace
suffix:semicolon
DECL|variable|fs_info
r_static
r_struct
id|fs_info
id|fs_info
op_assign
(brace
dot
id|devfsd_buffer_lock
op_assign
id|SPIN_LOCK_UNLOCKED
)brace
suffix:semicolon
DECL|variable|devfsd_buf_cache
r_static
id|kmem_cache_t
op_star
id|devfsd_buf_cache
suffix:semicolon
macro_line|#ifdef CONFIG_DEVFS_DEBUG
DECL|variable|__initdata
r_static
r_int
r_int
id|devfs_debug_init
id|__initdata
op_assign
id|DEBUG_NONE
suffix:semicolon
DECL|variable|devfs_debug
r_static
r_int
r_int
id|devfs_debug
op_assign
id|DEBUG_NONE
suffix:semicolon
r_static
id|DEFINE_SPINLOCK
c_func
(paren
id|stat_lock
)paren
suffix:semicolon
DECL|variable|stat_num_entries
r_static
r_int
r_int
id|stat_num_entries
suffix:semicolon
DECL|variable|stat_num_bytes
r_static
r_int
r_int
id|stat_num_bytes
suffix:semicolon
macro_line|#endif
DECL|variable|poison_array
r_static
r_int
r_char
id|poison_array
(braket
l_int|8
)braket
op_assign
(brace
l_int|0x5a
comma
l_int|0x5a
comma
l_int|0x5a
comma
l_int|0x5a
comma
l_int|0x5a
comma
l_int|0x5a
comma
l_int|0x5a
comma
l_int|0x5a
)brace
suffix:semicolon
macro_line|#ifdef CONFIG_DEVFS_MOUNT
DECL|variable|boot_options
r_static
r_int
r_int
id|boot_options
op_assign
id|OPTION_MOUNT
suffix:semicolon
macro_line|#else
DECL|variable|boot_options
r_static
r_int
r_int
id|boot_options
op_assign
id|OPTION_NONE
suffix:semicolon
macro_line|#endif
multiline_comment|/*  Forward function declarations  */
r_static
id|devfs_handle_t
id|_devfs_walk_path
c_func
(paren
r_struct
id|devfs_entry
op_star
id|dir
comma
r_const
r_char
op_star
id|name
comma
r_int
id|namelen
comma
r_int
id|traverse_symlink
)paren
suffix:semicolon
r_static
id|ssize_t
id|devfsd_read
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_char
id|__user
op_star
id|buf
comma
r_int
id|len
comma
id|loff_t
op_star
id|ppos
)paren
suffix:semicolon
r_static
r_int
id|devfsd_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
suffix:semicolon
r_static
r_int
id|devfsd_close
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_DEVFS_DEBUG
r_static
id|ssize_t
id|stat_read
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_char
id|__user
op_star
id|buf
comma
r_int
id|len
comma
id|loff_t
op_star
id|ppos
)paren
suffix:semicolon
DECL|variable|stat_fops
r_static
r_struct
id|file_operations
id|stat_fops
op_assign
(brace
dot
id|open
op_assign
id|nonseekable_open
comma
dot
id|read
op_assign
id|stat_read
comma
)brace
suffix:semicolon
macro_line|#endif
multiline_comment|/*  Devfs daemon file operations  */
DECL|variable|devfsd_fops
r_static
r_struct
id|file_operations
id|devfsd_fops
op_assign
(brace
dot
id|open
op_assign
id|nonseekable_open
comma
dot
id|read
op_assign
id|devfsd_read
comma
dot
id|ioctl
op_assign
id|devfsd_ioctl
comma
dot
id|release
op_assign
id|devfsd_close
comma
)brace
suffix:semicolon
multiline_comment|/*  Support functions follow  */
multiline_comment|/**&n; *&t;devfs_get - Get a reference to a devfs entry.&n; *&t;@de:  The devfs entry.&n; */
DECL|function|devfs_get
r_static
r_struct
id|devfs_entry
op_star
id|devfs_get
c_func
(paren
r_struct
id|devfs_entry
op_star
id|de
)paren
(brace
id|VERIFY_ENTRY
c_func
(paren
id|de
)paren
suffix:semicolon
r_if
c_cond
(paren
id|de
)paren
id|atomic_inc
c_func
(paren
op_amp
id|de-&gt;refcount
)paren
suffix:semicolon
r_return
id|de
suffix:semicolon
)brace
multiline_comment|/*  End Function devfs_get  */
multiline_comment|/**&n; *&t;devfs_put - Put (release) a reference to a devfs entry.&n; *&t;@de:  The handle to the devfs entry.&n; */
DECL|function|devfs_put
r_static
r_void
id|devfs_put
c_func
(paren
id|devfs_handle_t
id|de
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|de
)paren
r_return
suffix:semicolon
id|VERIFY_ENTRY
c_func
(paren
id|de
)paren
suffix:semicolon
r_if
c_cond
(paren
id|de-&gt;info
op_eq
id|POISON_PTR
)paren
id|OOPS
c_func
(paren
l_string|&quot;(%p): poisoned pointer&bslash;n&quot;
comma
id|de
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|atomic_dec_and_test
c_func
(paren
op_amp
id|de-&gt;refcount
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|de
op_eq
id|root_entry
)paren
id|OOPS
c_func
(paren
l_string|&quot;(%p): root entry being freed&bslash;n&quot;
comma
id|de
)paren
suffix:semicolon
id|DPRINTK
c_func
(paren
id|DEBUG_FREE
comma
l_string|&quot;(%s): de: %p, parent: %p &bslash;&quot;%s&bslash;&quot;&bslash;n&quot;
comma
id|de-&gt;name
comma
id|de
comma
id|de-&gt;parent
comma
id|de-&gt;parent
ques
c_cond
id|de-&gt;parent-&gt;name
suffix:colon
l_string|&quot;no parent&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|S_ISLNK
c_func
(paren
id|de-&gt;mode
)paren
)paren
id|kfree
c_func
(paren
id|de-&gt;u.symlink.linkname
)paren
suffix:semicolon
id|WRITE_ENTRY_MAGIC
c_func
(paren
id|de
comma
l_int|0
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_DEVFS_DEBUG
id|spin_lock
c_func
(paren
op_amp
id|stat_lock
)paren
suffix:semicolon
op_decrement
id|stat_num_entries
suffix:semicolon
id|stat_num_bytes
op_sub_assign
r_sizeof
op_star
id|de
op_plus
id|de-&gt;namelen
suffix:semicolon
r_if
c_cond
(paren
id|S_ISLNK
c_func
(paren
id|de-&gt;mode
)paren
)paren
id|stat_num_bytes
op_sub_assign
id|de-&gt;u.symlink.length
op_plus
l_int|1
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|stat_lock
)paren
suffix:semicolon
macro_line|#endif
id|de-&gt;info
op_assign
id|POISON_PTR
suffix:semicolon
id|kfree
c_func
(paren
id|de
)paren
suffix:semicolon
)brace
multiline_comment|/*  End Function devfs_put  */
multiline_comment|/**&n; *&t;_devfs_search_dir - Search for a devfs entry in a directory.&n; *&t;@dir:  The directory to search.&n; *&t;@name:  The name of the entry to search for.&n; *&t;@namelen:  The number of characters in @name.&n; *&n; *  Search for a devfs entry in a directory and returns a pointer to the entry&n; *   on success, else %NULL. The directory must be locked already.&n; *   An implicit devfs_get() is performed on the returned entry.&n; */
DECL|function|_devfs_search_dir
r_static
r_struct
id|devfs_entry
op_star
id|_devfs_search_dir
c_func
(paren
r_struct
id|devfs_entry
op_star
id|dir
comma
r_const
r_char
op_star
id|name
comma
r_int
r_int
id|namelen
)paren
(brace
r_struct
id|devfs_entry
op_star
id|curr
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|S_ISDIR
c_func
(paren
id|dir-&gt;mode
)paren
)paren
(brace
id|PRINTK
c_func
(paren
l_string|&quot;(%s): not a directory&bslash;n&quot;
comma
id|dir-&gt;name
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_for
c_loop
(paren
id|curr
op_assign
id|dir-&gt;u.dir.first
suffix:semicolon
id|curr
op_ne
l_int|NULL
suffix:semicolon
id|curr
op_assign
id|curr-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|curr-&gt;namelen
op_ne
id|namelen
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|curr-&gt;name
comma
id|name
comma
id|namelen
)paren
op_eq
l_int|0
)paren
r_break
suffix:semicolon
multiline_comment|/*  Not found: try the next one  */
)brace
r_return
id|devfs_get
c_func
(paren
id|curr
)paren
suffix:semicolon
)brace
multiline_comment|/*  End Function _devfs_search_dir  */
multiline_comment|/**&n; *&t;_devfs_alloc_entry - Allocate a devfs entry.&n; *&t;@name:     the name of the entry&n; *&t;@namelen:  the number of characters in @name&n; *      @mode:     the mode for the entry&n; *&n; *  Allocate a devfs entry and returns a pointer to the entry on success, else&n; *   %NULL.&n; */
DECL|function|_devfs_alloc_entry
r_static
r_struct
id|devfs_entry
op_star
id|_devfs_alloc_entry
c_func
(paren
r_const
r_char
op_star
id|name
comma
r_int
r_int
id|namelen
comma
id|umode_t
id|mode
)paren
(brace
r_struct
id|devfs_entry
op_star
r_new
suffix:semicolon
r_static
r_int
r_int
id|inode_counter
op_assign
id|FIRST_INODE
suffix:semicolon
r_static
id|DEFINE_SPINLOCK
c_func
(paren
id|counter_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|name
op_logical_and
(paren
id|namelen
OL
l_int|1
)paren
)paren
id|namelen
op_assign
id|strlen
c_func
(paren
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
r_new
op_assign
id|kmalloc
c_func
(paren
r_sizeof
op_star
r_new
op_plus
id|namelen
comma
id|GFP_KERNEL
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
l_int|NULL
suffix:semicolon
id|memset
c_func
(paren
r_new
comma
l_int|0
comma
r_sizeof
op_star
r_new
op_plus
id|namelen
)paren
suffix:semicolon
multiline_comment|/*  Will set &squot;&bslash;0&squot; on name  */
r_new
op_member_access_from_pointer
id|mode
op_assign
id|mode
suffix:semicolon
r_if
c_cond
(paren
id|S_ISDIR
c_func
(paren
id|mode
)paren
)paren
id|rwlock_init
c_func
(paren
op_amp
r_new
op_member_access_from_pointer
id|u.dir.lock
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
r_new
op_member_access_from_pointer
id|refcount
comma
l_int|1
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|counter_lock
)paren
suffix:semicolon
r_new
op_member_access_from_pointer
id|inode.ino
op_assign
id|inode_counter
op_increment
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|counter_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|name
)paren
id|memcpy
c_func
(paren
r_new
op_member_access_from_pointer
id|name
comma
id|name
comma
id|namelen
)paren
suffix:semicolon
r_new
op_member_access_from_pointer
id|namelen
op_assign
id|namelen
suffix:semicolon
id|WRITE_ENTRY_MAGIC
c_func
(paren
r_new
comma
id|MAGIC_VALUE
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_DEVFS_DEBUG
id|spin_lock
c_func
(paren
op_amp
id|stat_lock
)paren
suffix:semicolon
op_increment
id|stat_num_entries
suffix:semicolon
id|stat_num_bytes
op_add_assign
r_sizeof
op_star
r_new
op_plus
id|namelen
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|stat_lock
)paren
suffix:semicolon
macro_line|#endif
r_return
r_new
suffix:semicolon
)brace
multiline_comment|/*  End Function _devfs_alloc_entry  */
multiline_comment|/**&n; *&t;_devfs_append_entry - Append a devfs entry to a directory&squot;s child list.&n; *&t;@dir:  The directory to add to.&n; *&t;@de:  The devfs entry to append.&n; *&t;@old_de: If an existing entry exists, it will be written here. This may&n; *&t;&t; be %NULL. An implicit devfs_get() is performed on this entry.&n; *&n; *  Append a devfs entry to a directory&squot;s list of children, checking first to&n; *   see if an entry of the same name exists. The directory will be locked.&n; *   The value 0 is returned on success, else a negative error code.&n; *   On failure, an implicit devfs_put() is performed on %de.&n; */
DECL|function|_devfs_append_entry
r_static
r_int
id|_devfs_append_entry
c_func
(paren
id|devfs_handle_t
id|dir
comma
id|devfs_handle_t
id|de
comma
id|devfs_handle_t
op_star
id|old_de
)paren
(brace
r_int
id|retval
suffix:semicolon
r_if
c_cond
(paren
id|old_de
)paren
op_star
id|old_de
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|S_ISDIR
c_func
(paren
id|dir-&gt;mode
)paren
)paren
(brace
id|PRINTK
c_func
(paren
l_string|&quot;(%s): dir: &bslash;&quot;%s&bslash;&quot; is not a directory&bslash;n&quot;
comma
id|de-&gt;name
comma
id|dir-&gt;name
)paren
suffix:semicolon
id|devfs_put
c_func
(paren
id|de
)paren
suffix:semicolon
r_return
op_minus
id|ENOTDIR
suffix:semicolon
)brace
id|write_lock
c_func
(paren
op_amp
id|dir-&gt;u.dir.lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dir-&gt;u.dir.no_more_additions
)paren
id|retval
op_assign
op_minus
id|ENOENT
suffix:semicolon
r_else
(brace
r_struct
id|devfs_entry
op_star
id|old
suffix:semicolon
id|old
op_assign
id|_devfs_search_dir
c_func
(paren
id|dir
comma
id|de-&gt;name
comma
id|de-&gt;namelen
)paren
suffix:semicolon
r_if
c_cond
(paren
id|old_de
)paren
op_star
id|old_de
op_assign
id|old
suffix:semicolon
r_else
id|devfs_put
c_func
(paren
id|old
)paren
suffix:semicolon
r_if
c_cond
(paren
id|old
op_eq
l_int|NULL
)paren
(brace
id|de-&gt;parent
op_assign
id|dir
suffix:semicolon
id|de-&gt;prev
op_assign
id|dir-&gt;u.dir.last
suffix:semicolon
multiline_comment|/*  Append to the directory&squot;s list of children  */
r_if
c_cond
(paren
id|dir-&gt;u.dir.first
op_eq
l_int|NULL
)paren
id|dir-&gt;u.dir.first
op_assign
id|de
suffix:semicolon
r_else
id|dir-&gt;u.dir.last-&gt;next
op_assign
id|de
suffix:semicolon
id|dir-&gt;u.dir.last
op_assign
id|de
suffix:semicolon
id|retval
op_assign
l_int|0
suffix:semicolon
)brace
r_else
id|retval
op_assign
op_minus
id|EEXIST
suffix:semicolon
)brace
id|write_unlock
c_func
(paren
op_amp
id|dir-&gt;u.dir.lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
id|devfs_put
c_func
(paren
id|de
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*  End Function _devfs_append_entry  */
multiline_comment|/**&n; *&t;_devfs_get_root_entry - Get the root devfs entry.&n; *&n; *&t;Returns the root devfs entry on success, else %NULL.&n; *&n; *&t;TODO it must be called asynchronously due to the fact&n; *&t;that devfs is initialized relatively late. Proper way&n; *&t;is to remove module_init from init_devfs_fs and manually&n; *&t;call it early enough during system init&n; */
DECL|function|_devfs_get_root_entry
r_static
r_struct
id|devfs_entry
op_star
id|_devfs_get_root_entry
c_func
(paren
r_void
)paren
(brace
r_struct
id|devfs_entry
op_star
r_new
suffix:semicolon
r_static
id|DEFINE_SPINLOCK
c_func
(paren
id|root_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|root_entry
)paren
r_return
id|root_entry
suffix:semicolon
r_new
op_assign
id|_devfs_alloc_entry
c_func
(paren
l_int|NULL
comma
l_int|0
comma
id|MODE_DIR
)paren
suffix:semicolon
r_if
c_cond
(paren
r_new
op_eq
l_int|NULL
)paren
r_return
l_int|NULL
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|root_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|root_entry
)paren
(brace
id|spin_unlock
c_func
(paren
op_amp
id|root_lock
)paren
suffix:semicolon
id|devfs_put
c_func
(paren
r_new
)paren
suffix:semicolon
r_return
id|root_entry
suffix:semicolon
)brace
id|root_entry
op_assign
r_new
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|root_lock
)paren
suffix:semicolon
r_return
id|root_entry
suffix:semicolon
)brace
multiline_comment|/*  End Function _devfs_get_root_entry  */
multiline_comment|/**&n; *&t;_devfs_descend - Descend down a tree using the next component name.&n; *&t;@dir:  The directory to search.&n; *&t;@name:  The component name to search for.&n; *&t;@namelen:  The length of %name.&n; *&t;@next_pos:  The position of the next &squot;/&squot; or &squot;&bslash;0&squot; is written here.&n; *&n; *  Descend into a directory, searching for a component. This function forms&n; *   the core of a tree-walking algorithm. The directory will be locked.&n; *   The devfs entry corresponding to the component is returned. If there is&n; *   no matching entry, %NULL is returned.&n; *   An implicit devfs_get() is performed on the returned entry.&n; */
DECL|function|_devfs_descend
r_static
r_struct
id|devfs_entry
op_star
id|_devfs_descend
c_func
(paren
r_struct
id|devfs_entry
op_star
id|dir
comma
r_const
r_char
op_star
id|name
comma
r_int
id|namelen
comma
r_int
op_star
id|next_pos
)paren
(brace
r_const
r_char
op_star
id|stop
comma
op_star
id|ptr
suffix:semicolon
r_struct
id|devfs_entry
op_star
id|entry
suffix:semicolon
r_if
c_cond
(paren
(paren
id|namelen
op_ge
l_int|3
)paren
op_logical_and
(paren
id|strncmp
c_func
(paren
id|name
comma
l_string|&quot;../&quot;
comma
l_int|3
)paren
op_eq
l_int|0
)paren
)paren
(brace
multiline_comment|/*  Special-case going to parent directory  */
op_star
id|next_pos
op_assign
l_int|3
suffix:semicolon
r_return
id|devfs_get
c_func
(paren
id|dir-&gt;parent
)paren
suffix:semicolon
)brace
id|stop
op_assign
id|name
op_plus
id|namelen
suffix:semicolon
multiline_comment|/*  Search for a possible &squot;/&squot;  */
r_for
c_loop
(paren
id|ptr
op_assign
id|name
suffix:semicolon
(paren
id|ptr
OL
id|stop
)paren
op_logical_and
(paren
op_star
id|ptr
op_ne
l_char|&squot;/&squot;
)paren
suffix:semicolon
op_increment
id|ptr
)paren
suffix:semicolon
op_star
id|next_pos
op_assign
id|ptr
op_minus
id|name
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|dir-&gt;u.dir.lock
)paren
suffix:semicolon
id|entry
op_assign
id|_devfs_search_dir
c_func
(paren
id|dir
comma
id|name
comma
op_star
id|next_pos
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|dir-&gt;u.dir.lock
)paren
suffix:semicolon
r_return
id|entry
suffix:semicolon
)brace
multiline_comment|/*  End Function _devfs_descend  */
DECL|function|_devfs_make_parent_for_leaf
r_static
id|devfs_handle_t
id|_devfs_make_parent_for_leaf
c_func
(paren
r_struct
id|devfs_entry
op_star
id|dir
comma
r_const
r_char
op_star
id|name
comma
r_int
id|namelen
comma
r_int
op_star
id|leaf_pos
)paren
(brace
r_int
id|next_pos
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|dir
op_eq
l_int|NULL
)paren
id|dir
op_assign
id|_devfs_get_root_entry
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dir
op_eq
l_int|NULL
)paren
r_return
l_int|NULL
suffix:semicolon
id|devfs_get
c_func
(paren
id|dir
)paren
suffix:semicolon
multiline_comment|/*  Search for possible trailing component and ignore it  */
r_for
c_loop
(paren
op_decrement
id|namelen
suffix:semicolon
(paren
id|namelen
OG
l_int|0
)paren
op_logical_and
(paren
id|name
(braket
id|namelen
)braket
op_ne
l_char|&squot;/&squot;
)paren
suffix:semicolon
op_decrement
id|namelen
)paren
suffix:semicolon
op_star
id|leaf_pos
op_assign
(paren
id|name
(braket
id|namelen
)braket
op_eq
l_char|&squot;/&squot;
)paren
ques
c_cond
(paren
id|namelen
op_plus
l_int|1
)paren
suffix:colon
l_int|0
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|namelen
OG
l_int|0
suffix:semicolon
id|name
op_add_assign
id|next_pos
comma
id|namelen
op_sub_assign
id|next_pos
)paren
(brace
r_struct
id|devfs_entry
op_star
id|de
comma
op_star
id|old
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
(paren
id|de
op_assign
id|_devfs_descend
c_func
(paren
id|dir
comma
id|name
comma
id|namelen
comma
op_amp
id|next_pos
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|de
op_assign
id|_devfs_alloc_entry
c_func
(paren
id|name
comma
id|next_pos
comma
id|MODE_DIR
)paren
suffix:semicolon
id|devfs_get
c_func
(paren
id|de
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|de
op_logical_or
id|_devfs_append_entry
c_func
(paren
id|dir
comma
id|de
comma
op_amp
id|old
)paren
)paren
(brace
id|devfs_put
c_func
(paren
id|de
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|old
op_logical_or
op_logical_neg
id|S_ISDIR
c_func
(paren
id|old-&gt;mode
)paren
)paren
(brace
id|devfs_put
c_func
(paren
id|old
)paren
suffix:semicolon
id|devfs_put
c_func
(paren
id|dir
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|de
op_assign
id|old
suffix:semicolon
multiline_comment|/*  Use the existing directory  */
)brace
)brace
r_if
c_cond
(paren
id|de
op_eq
id|dir-&gt;parent
)paren
(brace
id|devfs_put
c_func
(paren
id|dir
)paren
suffix:semicolon
id|devfs_put
c_func
(paren
id|de
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|devfs_put
c_func
(paren
id|dir
)paren
suffix:semicolon
id|dir
op_assign
id|de
suffix:semicolon
r_if
c_cond
(paren
id|name
(braket
id|next_pos
)braket
op_eq
l_char|&squot;/&squot;
)paren
op_increment
id|next_pos
suffix:semicolon
)brace
r_return
id|dir
suffix:semicolon
)brace
multiline_comment|/*  End Function _devfs_make_parent_for_leaf  */
DECL|function|_devfs_prepare_leaf
r_static
id|devfs_handle_t
id|_devfs_prepare_leaf
c_func
(paren
id|devfs_handle_t
op_star
id|dir
comma
r_const
r_char
op_star
id|name
comma
id|umode_t
id|mode
)paren
(brace
r_int
id|namelen
comma
id|leaf_pos
suffix:semicolon
r_struct
id|devfs_entry
op_star
id|de
suffix:semicolon
id|namelen
op_assign
id|strlen
c_func
(paren
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
op_star
id|dir
op_assign
id|_devfs_make_parent_for_leaf
c_func
(paren
op_star
id|dir
comma
id|name
comma
id|namelen
comma
op_amp
id|leaf_pos
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|PRINTK
c_func
(paren
l_string|&quot;(%s): could not create parent path&bslash;n&quot;
comma
id|name
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|de
op_assign
id|_devfs_alloc_entry
c_func
(paren
id|name
op_plus
id|leaf_pos
comma
id|namelen
op_minus
id|leaf_pos
comma
id|mode
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|PRINTK
c_func
(paren
l_string|&quot;(%s): could not allocate entry&bslash;n&quot;
comma
id|name
)paren
suffix:semicolon
id|devfs_put
c_func
(paren
op_star
id|dir
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_return
id|de
suffix:semicolon
)brace
multiline_comment|/*  End Function _devfs_prepare_leaf  */
DECL|function|_devfs_walk_path
r_static
id|devfs_handle_t
id|_devfs_walk_path
c_func
(paren
r_struct
id|devfs_entry
op_star
id|dir
comma
r_const
r_char
op_star
id|name
comma
r_int
id|namelen
comma
r_int
id|traverse_symlink
)paren
(brace
r_int
id|next_pos
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|dir
op_eq
l_int|NULL
)paren
id|dir
op_assign
id|_devfs_get_root_entry
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dir
op_eq
l_int|NULL
)paren
r_return
l_int|NULL
suffix:semicolon
id|devfs_get
c_func
(paren
id|dir
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|namelen
OG
l_int|0
suffix:semicolon
id|name
op_add_assign
id|next_pos
comma
id|namelen
op_sub_assign
id|next_pos
)paren
(brace
r_struct
id|devfs_entry
op_star
id|de
comma
op_star
id|link
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|S_ISDIR
c_func
(paren
id|dir-&gt;mode
)paren
)paren
(brace
id|devfs_put
c_func
(paren
id|dir
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|de
op_assign
id|_devfs_descend
c_func
(paren
id|dir
comma
id|name
comma
id|namelen
comma
op_amp
id|next_pos
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|devfs_put
c_func
(paren
id|dir
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|S_ISLNK
c_func
(paren
id|de-&gt;mode
)paren
op_logical_and
id|traverse_symlink
)paren
(brace
multiline_comment|/*  Need to follow the link: this is a stack chomper  */
multiline_comment|/* FIXME what if it puts outside of mounted tree? */
id|link
op_assign
id|_devfs_walk_path
c_func
(paren
id|dir
comma
id|de-&gt;u.symlink.linkname
comma
id|de-&gt;u.symlink.length
comma
id|TRUE
)paren
suffix:semicolon
id|devfs_put
c_func
(paren
id|de
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|link
)paren
(brace
id|devfs_put
c_func
(paren
id|dir
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|de
op_assign
id|link
suffix:semicolon
)brace
id|devfs_put
c_func
(paren
id|dir
)paren
suffix:semicolon
id|dir
op_assign
id|de
suffix:semicolon
r_if
c_cond
(paren
id|name
(braket
id|next_pos
)braket
op_eq
l_char|&squot;/&squot;
)paren
op_increment
id|next_pos
suffix:semicolon
)brace
r_return
id|dir
suffix:semicolon
)brace
multiline_comment|/*  End Function _devfs_walk_path  */
multiline_comment|/**&n; *&t;_devfs_find_entry - Find a devfs entry.&n; *&t;@dir: The handle to the parent devfs directory entry. If this is %NULL the&n; *&t;&t;name is relative to the root of the devfs.&n; *&t;@name: The name of the entry. This may be %NULL.&n; *&t;@traverse_symlink: If %TRUE then symbolic links are traversed.&n; *&n; *&t;Returns the devfs_entry pointer on success, else %NULL. An implicit&n; *&t;devfs_get() is performed.&n; */
DECL|function|_devfs_find_entry
r_static
r_struct
id|devfs_entry
op_star
id|_devfs_find_entry
c_func
(paren
id|devfs_handle_t
id|dir
comma
r_const
r_char
op_star
id|name
comma
r_int
id|traverse_symlink
)paren
(brace
r_int
r_int
id|namelen
op_assign
id|strlen
c_func
(paren
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|name
(braket
l_int|0
)braket
op_eq
l_char|&squot;/&squot;
)paren
(brace
multiline_comment|/*  Skip leading pathname component  */
r_if
c_cond
(paren
id|namelen
OL
l_int|2
)paren
(brace
id|PRINTK
c_func
(paren
l_string|&quot;(%s): too short&bslash;n&quot;
comma
id|name
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_for
c_loop
(paren
op_increment
id|name
comma
op_decrement
id|namelen
suffix:semicolon
(paren
op_star
id|name
op_ne
l_char|&squot;/&squot;
)paren
op_logical_and
(paren
id|namelen
OG
l_int|0
)paren
suffix:semicolon
op_increment
id|name
comma
op_decrement
id|namelen
)paren
suffix:semicolon
r_if
c_cond
(paren
id|namelen
OL
l_int|2
)paren
(brace
id|PRINTK
c_func
(paren
l_string|&quot;(%s): too short&bslash;n&quot;
comma
id|name
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
op_increment
id|name
suffix:semicolon
op_decrement
id|namelen
suffix:semicolon
)brace
r_return
id|_devfs_walk_path
c_func
(paren
id|dir
comma
id|name
comma
id|namelen
comma
id|traverse_symlink
)paren
suffix:semicolon
)brace
multiline_comment|/*  End Function _devfs_find_entry  */
DECL|function|get_devfs_entry_from_vfs_inode
r_static
r_struct
id|devfs_entry
op_star
id|get_devfs_entry_from_vfs_inode
c_func
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
r_if
c_cond
(paren
id|inode
op_eq
l_int|NULL
)paren
r_return
l_int|NULL
suffix:semicolon
id|VERIFY_ENTRY
c_func
(paren
(paren
r_struct
id|devfs_entry
op_star
)paren
id|inode-&gt;u.generic_ip
)paren
suffix:semicolon
r_return
id|inode-&gt;u.generic_ip
suffix:semicolon
)brace
multiline_comment|/*  End Function get_devfs_entry_from_vfs_inode  */
multiline_comment|/**&n; *&t;free_dentry - Free the dentry for a device entry and invalidate inode.&n; *&t;@de: The entry.&n; *&n; *&t;This must only be called after the entry has been unhooked from its&n; *&t; parent directory.&n; */
DECL|function|free_dentry
r_static
r_void
id|free_dentry
c_func
(paren
r_struct
id|devfs_entry
op_star
id|de
)paren
(brace
r_struct
id|dentry
op_star
id|dentry
op_assign
id|de-&gt;inode.dentry
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dentry
)paren
r_return
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|dcache_lock
)paren
suffix:semicolon
id|dget_locked
c_func
(paren
id|dentry
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|dcache_lock
)paren
suffix:semicolon
multiline_comment|/*  Forcefully remove the inode  */
r_if
c_cond
(paren
id|dentry-&gt;d_inode
op_ne
l_int|NULL
)paren
id|dentry-&gt;d_inode-&gt;i_nlink
op_assign
l_int|0
suffix:semicolon
id|d_drop
c_func
(paren
id|dentry
)paren
suffix:semicolon
id|dput
c_func
(paren
id|dentry
)paren
suffix:semicolon
)brace
multiline_comment|/*  End Function free_dentry  */
multiline_comment|/**&n; *&t;is_devfsd_or_child - Test if the current process is devfsd or one of its children.&n; *&t;@fs_info: The filesystem information.&n; *&n; *&t;Returns %TRUE if devfsd or child, else %FALSE.&n; */
DECL|function|is_devfsd_or_child
r_static
r_int
id|is_devfsd_or_child
c_func
(paren
r_struct
id|fs_info
op_star
id|fs_info
)paren
(brace
r_struct
id|task_struct
op_star
id|p
op_assign
id|current
suffix:semicolon
r_if
c_cond
(paren
id|p
op_eq
id|fs_info-&gt;devfsd_task
)paren
r_return
(paren
id|TRUE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|process_group
c_func
(paren
id|p
)paren
op_eq
id|fs_info-&gt;devfsd_pgrp
)paren
r_return
(paren
id|TRUE
)paren
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|p
op_ne
op_amp
id|init_task
suffix:semicolon
id|p
op_assign
id|p-&gt;real_parent
)paren
(brace
r_if
c_cond
(paren
id|p
op_eq
id|fs_info-&gt;devfsd_task
)paren
(brace
id|read_unlock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
r_return
(paren
id|TRUE
)paren
suffix:semicolon
)brace
)brace
id|read_unlock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
r_return
(paren
id|FALSE
)paren
suffix:semicolon
)brace
multiline_comment|/*  End Function is_devfsd_or_child  */
multiline_comment|/**&n; *&t;devfsd_queue_empty - Test if devfsd has work pending in its event queue.&n; *&t;@fs_info: The filesystem information.&n; *&n; *&t;Returns %TRUE if the queue is empty, else %FALSE.&n; */
DECL|function|devfsd_queue_empty
r_static
r_inline
r_int
id|devfsd_queue_empty
c_func
(paren
r_struct
id|fs_info
op_star
id|fs_info
)paren
(brace
r_return
(paren
id|fs_info-&gt;devfsd_last_event
)paren
ques
c_cond
id|FALSE
suffix:colon
id|TRUE
suffix:semicolon
)brace
multiline_comment|/*  End Function devfsd_queue_empty  */
multiline_comment|/**&n; *&t;wait_for_devfsd_finished - Wait for devfsd to finish processing its event queue.&n; *&t;@fs_info: The filesystem information.&n; *&n; *&t;Returns %TRUE if no more waiting will be required, else %FALSE.&n; */
DECL|function|wait_for_devfsd_finished
r_static
r_int
id|wait_for_devfsd_finished
c_func
(paren
r_struct
id|fs_info
op_star
id|fs_info
)paren
(brace
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fs_info-&gt;devfsd_task
op_eq
l_int|NULL
)paren
r_return
(paren
id|TRUE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|devfsd_queue_empty
c_func
(paren
id|fs_info
)paren
op_logical_and
id|fs_info-&gt;devfsd_sleeping
)paren
r_return
id|TRUE
suffix:semicolon
r_if
c_cond
(paren
id|is_devfsd_or_child
c_func
(paren
id|fs_info
)paren
)paren
r_return
(paren
id|FALSE
)paren
suffix:semicolon
id|set_current_state
c_func
(paren
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
id|add_wait_queue
c_func
(paren
op_amp
id|fs_info-&gt;revalidate_wait_queue
comma
op_amp
id|wait
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|devfsd_queue_empty
c_func
(paren
id|fs_info
)paren
op_logical_or
op_logical_neg
id|fs_info-&gt;devfsd_sleeping
)paren
r_if
c_cond
(paren
id|fs_info-&gt;devfsd_task
)paren
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|remove_wait_queue
c_func
(paren
op_amp
id|fs_info-&gt;revalidate_wait_queue
comma
op_amp
id|wait
)paren
suffix:semicolon
id|__set_current_state
c_func
(paren
id|TASK_RUNNING
)paren
suffix:semicolon
r_return
(paren
id|TRUE
)paren
suffix:semicolon
)brace
multiline_comment|/*  End Function wait_for_devfsd_finished  */
multiline_comment|/**&n; *&t;devfsd_notify_de - Notify the devfsd daemon of a change.&n; *&t;@de: The devfs entry that has changed. This and all parent entries will&n; *            have their reference counts incremented if the event was queued.&n; *&t;@type: The type of change.&n; *&t;@mode: The mode of the entry.&n; *&t;@uid: The user ID.&n; *&t;@gid: The group ID.&n; *&t;@fs_info: The filesystem info.&n; *&n; *&t;Returns %TRUE if an event was queued and devfsd woken up, else %FALSE.&n; */
DECL|function|devfsd_notify_de
r_static
r_int
id|devfsd_notify_de
c_func
(paren
r_struct
id|devfs_entry
op_star
id|de
comma
r_int
r_int
id|type
comma
id|umode_t
id|mode
comma
id|uid_t
id|uid
comma
id|gid_t
id|gid
comma
r_struct
id|fs_info
op_star
id|fs_info
)paren
(brace
r_struct
id|devfsd_buf_entry
op_star
id|entry
suffix:semicolon
r_struct
id|devfs_entry
op_star
id|curr
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|fs_info-&gt;devfsd_event_mask
op_amp
(paren
l_int|1
op_lshift
id|type
)paren
)paren
)paren
r_return
(paren
id|FALSE
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|entry
op_assign
id|kmem_cache_alloc
c_func
(paren
id|devfsd_buf_cache
comma
id|SLAB_KERNEL
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|atomic_inc
c_func
(paren
op_amp
id|fs_info-&gt;devfsd_overrun_count
)paren
suffix:semicolon
r_return
(paren
id|FALSE
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|curr
op_assign
id|de
suffix:semicolon
id|curr
op_ne
l_int|NULL
suffix:semicolon
id|curr
op_assign
id|curr-&gt;parent
)paren
id|devfs_get
c_func
(paren
id|curr
)paren
suffix:semicolon
id|entry-&gt;de
op_assign
id|de
suffix:semicolon
id|entry-&gt;type
op_assign
id|type
suffix:semicolon
id|entry-&gt;mode
op_assign
id|mode
suffix:semicolon
id|entry-&gt;uid
op_assign
id|uid
suffix:semicolon
id|entry-&gt;gid
op_assign
id|gid
suffix:semicolon
id|entry-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|fs_info-&gt;devfsd_buffer_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fs_info-&gt;devfsd_first_event
)paren
id|fs_info-&gt;devfsd_first_event
op_assign
id|entry
suffix:semicolon
r_if
c_cond
(paren
id|fs_info-&gt;devfsd_last_event
)paren
id|fs_info-&gt;devfsd_last_event-&gt;next
op_assign
id|entry
suffix:semicolon
id|fs_info-&gt;devfsd_last_event
op_assign
id|entry
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|fs_info-&gt;devfsd_buffer_lock
)paren
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|fs_info-&gt;devfsd_wait_queue
)paren
suffix:semicolon
r_return
(paren
id|TRUE
)paren
suffix:semicolon
)brace
multiline_comment|/*  End Function devfsd_notify_de  */
multiline_comment|/**&n; *&t;devfsd_notify - Notify the devfsd daemon of a change.&n; *&t;@de: The devfs entry that has changed.&n; *&t;@type: The type of change event.&n; *&t;@wait: If TRUE, the function waits for the daemon to finish processing&n; *&t;&t;the event.&n; */
DECL|function|devfsd_notify
r_static
r_void
id|devfsd_notify
c_func
(paren
r_struct
id|devfs_entry
op_star
id|de
comma
r_int
r_int
id|type
)paren
(brace
id|devfsd_notify_de
c_func
(paren
id|de
comma
id|type
comma
id|de-&gt;mode
comma
id|current-&gt;euid
comma
id|current-&gt;egid
comma
op_amp
id|fs_info
)paren
suffix:semicolon
)brace
DECL|function|devfs_mk_dev
r_static
r_int
id|devfs_mk_dev
c_func
(paren
id|dev_t
id|dev
comma
id|umode_t
id|mode
comma
r_const
r_char
op_star
id|fmt
comma
id|va_list
id|args
)paren
(brace
r_struct
id|devfs_entry
op_star
id|dir
op_assign
l_int|NULL
comma
op_star
id|de
suffix:semicolon
r_char
id|buf
(braket
l_int|64
)braket
suffix:semicolon
r_int
id|error
comma
id|n
suffix:semicolon
id|n
op_assign
id|vsnprintf
c_func
(paren
id|buf
comma
r_sizeof
(paren
id|buf
)paren
comma
id|fmt
comma
id|args
)paren
suffix:semicolon
r_if
c_cond
(paren
id|n
op_ge
r_sizeof
(paren
id|buf
)paren
op_logical_or
op_logical_neg
id|buf
(braket
l_int|0
)braket
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: invalid format string %s&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|fmt
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|de
op_assign
id|_devfs_prepare_leaf
c_func
(paren
op_amp
id|dir
comma
id|buf
comma
id|mode
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|de
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: could not prepare leaf for %s&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|buf
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
multiline_comment|/* could be more accurate... */
)brace
id|de-&gt;u.dev
op_assign
id|dev
suffix:semicolon
id|error
op_assign
id|_devfs_append_entry
c_func
(paren
id|dir
comma
id|de
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: could not append to parent for %s&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|buf
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|devfsd_notify
c_func
(paren
id|de
comma
id|DEVFSD_NOTIFY_REGISTERED
)paren
suffix:semicolon
id|out
suffix:colon
id|devfs_put
c_func
(paren
id|dir
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
DECL|function|devfs_mk_bdev
r_int
id|devfs_mk_bdev
c_func
(paren
id|dev_t
id|dev
comma
id|umode_t
id|mode
comma
r_const
r_char
op_star
id|fmt
comma
dot
dot
dot
)paren
(brace
id|va_list
id|args
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|S_ISBLK
c_func
(paren
id|mode
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: invalide mode (%u) for %s&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|mode
comma
id|fmt
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|va_start
c_func
(paren
id|args
comma
id|fmt
)paren
suffix:semicolon
r_return
id|devfs_mk_dev
c_func
(paren
id|dev
comma
id|mode
comma
id|fmt
comma
id|args
)paren
suffix:semicolon
)brace
DECL|variable|devfs_mk_bdev
id|EXPORT_SYMBOL
c_func
(paren
id|devfs_mk_bdev
)paren
suffix:semicolon
DECL|function|devfs_mk_cdev
r_int
id|devfs_mk_cdev
c_func
(paren
id|dev_t
id|dev
comma
id|umode_t
id|mode
comma
r_const
r_char
op_star
id|fmt
comma
dot
dot
dot
)paren
(brace
id|va_list
id|args
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|S_ISCHR
c_func
(paren
id|mode
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: invalide mode (%u) for %s&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|mode
comma
id|fmt
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|va_start
c_func
(paren
id|args
comma
id|fmt
)paren
suffix:semicolon
r_return
id|devfs_mk_dev
c_func
(paren
id|dev
comma
id|mode
comma
id|fmt
comma
id|args
)paren
suffix:semicolon
)brace
DECL|variable|devfs_mk_cdev
id|EXPORT_SYMBOL
c_func
(paren
id|devfs_mk_cdev
)paren
suffix:semicolon
multiline_comment|/**&n; *&t;_devfs_unhook - Unhook a device entry from its parents list&n; *&t;@de: The entry to unhook.&n; *&n; *&t;Returns %TRUE if the entry was unhooked, else %FALSE if it was&n; *&t;&t;previously unhooked.&n; *&t;The caller must have a write lock on the parent directory.&n; */
DECL|function|_devfs_unhook
r_static
r_int
id|_devfs_unhook
c_func
(paren
r_struct
id|devfs_entry
op_star
id|de
)paren
(brace
r_struct
id|devfs_entry
op_star
id|parent
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|de
op_logical_or
(paren
id|de-&gt;prev
op_eq
id|de
)paren
)paren
r_return
id|FALSE
suffix:semicolon
id|parent
op_assign
id|de-&gt;parent
suffix:semicolon
r_if
c_cond
(paren
id|de-&gt;prev
op_eq
l_int|NULL
)paren
id|parent-&gt;u.dir.first
op_assign
id|de-&gt;next
suffix:semicolon
r_else
id|de-&gt;prev-&gt;next
op_assign
id|de-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|de-&gt;next
op_eq
l_int|NULL
)paren
id|parent-&gt;u.dir.last
op_assign
id|de-&gt;prev
suffix:semicolon
r_else
id|de-&gt;next-&gt;prev
op_assign
id|de-&gt;prev
suffix:semicolon
id|de-&gt;prev
op_assign
id|de
suffix:semicolon
multiline_comment|/*  Indicate we&squot;re unhooked                      */
id|de-&gt;next
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*  Force early termination for &lt;devfs_readdir&gt;  */
r_return
id|TRUE
suffix:semicolon
)brace
multiline_comment|/*  End Function _devfs_unhook  */
multiline_comment|/**&n; *&t;_devfs_unregister - Unregister a device entry from its parent.&n; *&t;@dir: The parent directory.&n; *&t;@de: The entry to unregister.&n; *&n; *&t;The caller must have a write lock on the parent directory, which is&n; *&t;unlocked by this function.&n; */
DECL|function|_devfs_unregister
r_static
r_void
id|_devfs_unregister
c_func
(paren
r_struct
id|devfs_entry
op_star
id|dir
comma
r_struct
id|devfs_entry
op_star
id|de
)paren
(brace
r_int
id|unhooked
op_assign
id|_devfs_unhook
c_func
(paren
id|de
)paren
suffix:semicolon
id|write_unlock
c_func
(paren
op_amp
id|dir-&gt;u.dir.lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|unhooked
)paren
r_return
suffix:semicolon
id|devfs_get
c_func
(paren
id|dir
)paren
suffix:semicolon
id|devfsd_notify
c_func
(paren
id|de
comma
id|DEVFSD_NOTIFY_UNREGISTERED
)paren
suffix:semicolon
id|free_dentry
c_func
(paren
id|de
)paren
suffix:semicolon
id|devfs_put
c_func
(paren
id|dir
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|S_ISDIR
c_func
(paren
id|de-&gt;mode
)paren
)paren
r_return
suffix:semicolon
r_while
c_loop
(paren
id|TRUE
)paren
(brace
multiline_comment|/*  Recursively unregister: this is a stack chomper  */
r_struct
id|devfs_entry
op_star
id|child
suffix:semicolon
id|write_lock
c_func
(paren
op_amp
id|de-&gt;u.dir.lock
)paren
suffix:semicolon
id|de-&gt;u.dir.no_more_additions
op_assign
id|TRUE
suffix:semicolon
id|child
op_assign
id|de-&gt;u.dir.first
suffix:semicolon
id|VERIFY_ENTRY
c_func
(paren
id|child
)paren
suffix:semicolon
id|_devfs_unregister
c_func
(paren
id|de
comma
id|child
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|child
)paren
r_break
suffix:semicolon
id|DPRINTK
c_func
(paren
id|DEBUG_UNREGISTER
comma
l_string|&quot;(%s): child: %p  refcount: %d&bslash;n&quot;
comma
id|child-&gt;name
comma
id|child
comma
id|atomic_read
c_func
(paren
op_amp
id|child-&gt;refcount
)paren
)paren
suffix:semicolon
id|devfs_put
c_func
(paren
id|child
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*  End Function _devfs_unregister  */
DECL|function|devfs_do_symlink
r_static
r_int
id|devfs_do_symlink
c_func
(paren
id|devfs_handle_t
id|dir
comma
r_const
r_char
op_star
id|name
comma
r_const
r_char
op_star
id|link
comma
id|devfs_handle_t
op_star
id|handle
)paren
(brace
r_int
id|err
suffix:semicolon
r_int
r_int
id|linklength
suffix:semicolon
r_char
op_star
id|newlink
suffix:semicolon
r_struct
id|devfs_entry
op_star
id|de
suffix:semicolon
r_if
c_cond
(paren
id|handle
op_ne
l_int|NULL
)paren
op_star
id|handle
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|name
op_eq
l_int|NULL
)paren
(brace
id|PRINTK
c_func
(paren
l_string|&quot;(): NULL name pointer&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|link
op_eq
l_int|NULL
)paren
(brace
id|PRINTK
c_func
(paren
l_string|&quot;(%s): NULL link pointer&bslash;n&quot;
comma
id|name
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|linklength
op_assign
id|strlen
c_func
(paren
id|link
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|newlink
op_assign
id|kmalloc
c_func
(paren
id|linklength
op_plus
l_int|1
comma
id|GFP_KERNEL
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|memcpy
c_func
(paren
id|newlink
comma
id|link
comma
id|linklength
)paren
suffix:semicolon
id|newlink
(braket
id|linklength
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_if
c_cond
(paren
(paren
id|de
op_assign
id|_devfs_prepare_leaf
c_func
(paren
op_amp
id|dir
comma
id|name
comma
id|S_IFLNK
op_or
id|S_IRUGO
op_or
id|S_IXUGO
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|PRINTK
c_func
(paren
l_string|&quot;(%s): could not prepare leaf&bslash;n&quot;
comma
id|name
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|newlink
)paren
suffix:semicolon
r_return
op_minus
id|ENOTDIR
suffix:semicolon
)brace
id|de-&gt;info
op_assign
l_int|NULL
suffix:semicolon
id|de-&gt;u.symlink.linkname
op_assign
id|newlink
suffix:semicolon
id|de-&gt;u.symlink.length
op_assign
id|linklength
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|_devfs_append_entry
c_func
(paren
id|dir
comma
id|de
comma
l_int|NULL
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|PRINTK
c_func
(paren
l_string|&quot;(%s): could not append to parent, err: %d&bslash;n&quot;
comma
id|name
comma
id|err
)paren
suffix:semicolon
id|devfs_put
c_func
(paren
id|dir
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
id|devfs_put
c_func
(paren
id|dir
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_DEVFS_DEBUG
id|spin_lock
c_func
(paren
op_amp
id|stat_lock
)paren
suffix:semicolon
id|stat_num_bytes
op_add_assign
id|linklength
op_plus
l_int|1
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|stat_lock
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|handle
op_ne
l_int|NULL
)paren
op_star
id|handle
op_assign
id|de
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*  End Function devfs_do_symlink  */
multiline_comment|/**&n; *&t;devfs_mk_symlink Create a symbolic link in the devfs namespace.&n; *&t;@from: The name of the entry.&n; *&t;@to: Name of the destination&n; *&n; *&t;Returns 0 on success, else a negative error code is returned.&n; */
DECL|function|devfs_mk_symlink
r_int
id|devfs_mk_symlink
c_func
(paren
r_const
r_char
op_star
id|from
comma
r_const
r_char
op_star
id|to
)paren
(brace
id|devfs_handle_t
id|de
suffix:semicolon
r_int
id|err
suffix:semicolon
id|err
op_assign
id|devfs_do_symlink
c_func
(paren
l_int|NULL
comma
id|from
comma
id|to
comma
op_amp
id|de
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|err
)paren
(brace
id|de-&gt;vfs
op_assign
id|TRUE
suffix:semicolon
id|devfsd_notify
c_func
(paren
id|de
comma
id|DEVFSD_NOTIFY_REGISTERED
)paren
suffix:semicolon
)brace
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;devfs_mk_dir - Create a directory in the devfs namespace.&n; *&t;&t;new name is relative to the root of the devfs.&n; *&t;@fmt: The name of the entry.&n; *&n; *&t;Use of this function is optional. The devfs_register() function&n; *&t;will automatically create intermediate directories as needed. This function&n; *&t;is provided for efficiency reasons, as it provides a handle to a directory.&n; *&t;On failure %NULL is returned.&n; */
DECL|function|devfs_mk_dir
r_int
id|devfs_mk_dir
c_func
(paren
r_const
r_char
op_star
id|fmt
comma
dot
dot
dot
)paren
(brace
r_struct
id|devfs_entry
op_star
id|dir
op_assign
l_int|NULL
comma
op_star
id|de
op_assign
l_int|NULL
comma
op_star
id|old
suffix:semicolon
r_char
id|buf
(braket
l_int|64
)braket
suffix:semicolon
id|va_list
id|args
suffix:semicolon
r_int
id|error
comma
id|n
suffix:semicolon
id|va_start
c_func
(paren
id|args
comma
id|fmt
)paren
suffix:semicolon
id|n
op_assign
id|vsnprintf
c_func
(paren
id|buf
comma
l_int|64
comma
id|fmt
comma
id|args
)paren
suffix:semicolon
r_if
c_cond
(paren
id|n
op_ge
l_int|64
op_logical_or
op_logical_neg
id|buf
(braket
l_int|0
)braket
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: invalid argument.&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|de
op_assign
id|_devfs_prepare_leaf
c_func
(paren
op_amp
id|dir
comma
id|buf
comma
id|MODE_DIR
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|de
)paren
(brace
id|PRINTK
c_func
(paren
l_string|&quot;(%s): could not prepare leaf&bslash;n&quot;
comma
id|buf
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|error
op_assign
id|_devfs_append_entry
c_func
(paren
id|dir
comma
id|de
comma
op_amp
id|old
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_eq
op_minus
id|EEXIST
op_logical_and
id|S_ISDIR
c_func
(paren
id|old-&gt;mode
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * devfs_mk_dir() of an already-existing directory will&n;&t;&t; * return success.&n;&t;&t; */
id|error
op_assign
l_int|0
suffix:semicolon
r_goto
id|out_put
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|error
)paren
(brace
id|PRINTK
c_func
(paren
l_string|&quot;(%s): could not append to dir: %p &bslash;&quot;%s&bslash;&quot;&bslash;n&quot;
comma
id|buf
comma
id|dir
comma
id|dir-&gt;name
)paren
suffix:semicolon
id|devfs_put
c_func
(paren
id|old
)paren
suffix:semicolon
r_goto
id|out_put
suffix:semicolon
)brace
id|devfsd_notify
c_func
(paren
id|de
comma
id|DEVFSD_NOTIFY_REGISTERED
)paren
suffix:semicolon
id|out_put
suffix:colon
id|devfs_put
c_func
(paren
id|dir
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
DECL|function|devfs_remove
r_void
id|devfs_remove
c_func
(paren
r_const
r_char
op_star
id|fmt
comma
dot
dot
dot
)paren
(brace
r_char
id|buf
(braket
l_int|64
)braket
suffix:semicolon
id|va_list
id|args
suffix:semicolon
r_int
id|n
suffix:semicolon
id|va_start
c_func
(paren
id|args
comma
id|fmt
)paren
suffix:semicolon
id|n
op_assign
id|vsnprintf
c_func
(paren
id|buf
comma
r_sizeof
(paren
id|buf
)paren
comma
id|fmt
comma
id|args
)paren
suffix:semicolon
r_if
c_cond
(paren
id|n
OL
r_sizeof
(paren
id|buf
)paren
op_logical_and
id|buf
(braket
l_int|0
)braket
)paren
(brace
id|devfs_handle_t
id|de
op_assign
id|_devfs_find_entry
c_func
(paren
l_int|NULL
comma
id|buf
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|de
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: %s not found, cannot remove&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|buf
)paren
suffix:semicolon
id|dump_stack
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|write_lock
c_func
(paren
op_amp
id|de-&gt;parent-&gt;u.dir.lock
)paren
suffix:semicolon
id|_devfs_unregister
c_func
(paren
id|de-&gt;parent
comma
id|de
)paren
suffix:semicolon
id|devfs_put
c_func
(paren
id|de
)paren
suffix:semicolon
id|devfs_put
c_func
(paren
id|de
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; *&t;devfs_generate_path - Generate a pathname for an entry, relative to the devfs root.&n; *&t;@de: The devfs entry.&n; *&t;@path: The buffer to write the pathname to. The pathname and &squot;&bslash;0&squot;&n; *&t;&t;terminator will be written at the end of the buffer.&n; *&t;@buflen: The length of the buffer.&n; *&n; *&t;Returns the offset in the buffer where the pathname starts on success,&n; *&t;else a negative error code.&n; */
DECL|function|devfs_generate_path
r_static
r_int
id|devfs_generate_path
c_func
(paren
id|devfs_handle_t
id|de
comma
r_char
op_star
id|path
comma
r_int
id|buflen
)paren
(brace
r_int
id|pos
suffix:semicolon
DECL|macro|NAMEOF
mdefine_line|#define NAMEOF(de) ( (de)-&gt;mode ? (de)-&gt;name : (de)-&gt;u.name )
r_if
c_cond
(paren
id|de
op_eq
l_int|NULL
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|VERIFY_ENTRY
c_func
(paren
id|de
)paren
suffix:semicolon
r_if
c_cond
(paren
id|de-&gt;namelen
op_ge
id|buflen
)paren
r_return
op_minus
id|ENAMETOOLONG
suffix:semicolon
multiline_comment|/*  Must be first       */
id|path
(braket
id|buflen
op_minus
l_int|1
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_if
c_cond
(paren
id|de-&gt;parent
op_eq
l_int|NULL
)paren
r_return
id|buflen
op_minus
l_int|1
suffix:semicolon
multiline_comment|/*  Don&squot;t prepend root  */
id|pos
op_assign
id|buflen
op_minus
id|de-&gt;namelen
op_minus
l_int|1
suffix:semicolon
id|memcpy
c_func
(paren
id|path
op_plus
id|pos
comma
id|NAMEOF
c_func
(paren
id|de
)paren
comma
id|de-&gt;namelen
)paren
suffix:semicolon
r_for
c_loop
(paren
id|de
op_assign
id|de-&gt;parent
suffix:semicolon
id|de-&gt;parent
op_ne
l_int|NULL
suffix:semicolon
id|de
op_assign
id|de-&gt;parent
)paren
(brace
r_if
c_cond
(paren
id|pos
op_minus
id|de-&gt;namelen
op_minus
l_int|1
OL
l_int|0
)paren
r_return
op_minus
id|ENAMETOOLONG
suffix:semicolon
id|path
(braket
op_decrement
id|pos
)braket
op_assign
l_char|&squot;/&squot;
suffix:semicolon
id|pos
op_sub_assign
id|de-&gt;namelen
suffix:semicolon
id|memcpy
c_func
(paren
id|path
op_plus
id|pos
comma
id|NAMEOF
c_func
(paren
id|de
)paren
comma
id|de-&gt;namelen
)paren
suffix:semicolon
)brace
r_return
id|pos
suffix:semicolon
)brace
multiline_comment|/*  End Function devfs_generate_path  */
multiline_comment|/**&n; *&t;devfs_setup - Process kernel boot options.&n; *&t;@str: The boot options after the &quot;devfs=&quot;.&n; */
DECL|function|devfs_setup
r_static
r_int
id|__init
id|devfs_setup
c_func
(paren
r_char
op_star
id|str
)paren
(brace
r_static
r_struct
(brace
r_char
op_star
id|name
suffix:semicolon
r_int
r_int
id|mask
suffix:semicolon
r_int
r_int
op_star
id|opt
suffix:semicolon
)brace
id|devfs_options_tab
(braket
)braket
id|__initdata
op_assign
(brace
macro_line|#ifdef CONFIG_DEVFS_DEBUG
(brace
l_string|&quot;dall&quot;
comma
id|DEBUG_ALL
comma
op_amp
id|devfs_debug_init
)brace
comma
(brace
l_string|&quot;dmod&quot;
comma
id|DEBUG_MODULE_LOAD
comma
op_amp
id|devfs_debug_init
)brace
comma
(brace
l_string|&quot;dreg&quot;
comma
id|DEBUG_REGISTER
comma
op_amp
id|devfs_debug_init
)brace
comma
(brace
l_string|&quot;dunreg&quot;
comma
id|DEBUG_UNREGISTER
comma
op_amp
id|devfs_debug_init
)brace
comma
(brace
l_string|&quot;dfree&quot;
comma
id|DEBUG_FREE
comma
op_amp
id|devfs_debug_init
)brace
comma
(brace
l_string|&quot;diget&quot;
comma
id|DEBUG_I_GET
comma
op_amp
id|devfs_debug_init
)brace
comma
(brace
l_string|&quot;dchange&quot;
comma
id|DEBUG_SET_FLAGS
comma
op_amp
id|devfs_debug_init
)brace
comma
(brace
l_string|&quot;dsread&quot;
comma
id|DEBUG_S_READ
comma
op_amp
id|devfs_debug_init
)brace
comma
(brace
l_string|&quot;dichange&quot;
comma
id|DEBUG_I_CHANGE
comma
op_amp
id|devfs_debug_init
)brace
comma
(brace
l_string|&quot;dimknod&quot;
comma
id|DEBUG_I_MKNOD
comma
op_amp
id|devfs_debug_init
)brace
comma
(brace
l_string|&quot;dilookup&quot;
comma
id|DEBUG_I_LOOKUP
comma
op_amp
id|devfs_debug_init
)brace
comma
(brace
l_string|&quot;diunlink&quot;
comma
id|DEBUG_I_UNLINK
comma
op_amp
id|devfs_debug_init
)brace
comma
macro_line|#endif&t;&t;&t;&t;/*  CONFIG_DEVFS_DEBUG  */
(brace
l_string|&quot;mount&quot;
comma
id|OPTION_MOUNT
comma
op_amp
id|boot_options
)brace
comma
(brace
l_int|NULL
comma
l_int|0
comma
l_int|NULL
)brace
)brace
suffix:semicolon
r_while
c_loop
(paren
(paren
op_star
id|str
op_ne
l_char|&squot;&bslash;0&squot;
)paren
op_logical_and
op_logical_neg
id|isspace
c_func
(paren
op_star
id|str
)paren
)paren
(brace
r_int
id|i
comma
id|found
op_assign
l_int|0
comma
id|invert
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|str
comma
l_string|&quot;no&quot;
comma
l_int|2
)paren
op_eq
l_int|0
)paren
(brace
id|invert
op_assign
l_int|1
suffix:semicolon
id|str
op_add_assign
l_int|2
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|devfs_options_tab
(braket
id|i
)braket
dot
id|name
op_ne
l_int|NULL
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|len
op_assign
id|strlen
c_func
(paren
id|devfs_options_tab
(braket
id|i
)braket
dot
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|str
comma
id|devfs_options_tab
(braket
id|i
)braket
dot
id|name
comma
id|len
)paren
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|invert
)paren
op_star
id|devfs_options_tab
(braket
id|i
)braket
dot
id|opt
op_and_assign
op_complement
id|devfs_options_tab
(braket
id|i
)braket
dot
id|mask
suffix:semicolon
r_else
op_star
id|devfs_options_tab
(braket
id|i
)braket
dot
id|opt
op_or_assign
id|devfs_options_tab
(braket
id|i
)braket
dot
id|mask
suffix:semicolon
id|str
op_add_assign
id|len
suffix:semicolon
id|found
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|found
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*  No match         */
r_if
c_cond
(paren
op_star
id|str
op_ne
l_char|&squot;,&squot;
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*  No more options  */
op_increment
id|str
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*  End Function devfs_setup  */
id|__setup
c_func
(paren
l_string|&quot;devfs=&quot;
comma
id|devfs_setup
)paren
suffix:semicolon
DECL|variable|devfs_mk_dir
id|EXPORT_SYMBOL
c_func
(paren
id|devfs_mk_dir
)paren
suffix:semicolon
DECL|variable|devfs_remove
id|EXPORT_SYMBOL
c_func
(paren
id|devfs_remove
)paren
suffix:semicolon
multiline_comment|/**&n; *&t;try_modload - Notify devfsd of an inode lookup by a non-devfsd process.&n; *&t;@parent: The parent devfs entry.&n; *&t;@fs_info: The filesystem info.&n; *&t;@name: The device name.&n; *&t;@namelen: The number of characters in @name.&n; *&t;@buf: A working area that will be used. This must not go out of scope&n; *            until devfsd is idle again.&n; *&n; *&t;Returns 0 on success (event was queued), else a negative error code.&n; */
DECL|function|try_modload
r_static
r_int
id|try_modload
c_func
(paren
r_struct
id|devfs_entry
op_star
id|parent
comma
r_struct
id|fs_info
op_star
id|fs_info
comma
r_const
r_char
op_star
id|name
comma
r_int
id|namelen
comma
r_struct
id|devfs_entry
op_star
id|buf
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|fs_info-&gt;devfsd_event_mask
op_amp
(paren
l_int|1
op_lshift
id|DEVFSD_NOTIFY_LOOKUP
)paren
)paren
)paren
r_return
op_minus
id|ENOENT
suffix:semicolon
r_if
c_cond
(paren
id|is_devfsd_or_child
c_func
(paren
id|fs_info
)paren
)paren
r_return
op_minus
id|ENOENT
suffix:semicolon
id|memset
c_func
(paren
id|buf
comma
l_int|0
comma
r_sizeof
op_star
id|buf
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|buf-&gt;refcount
comma
l_int|1
)paren
suffix:semicolon
id|buf-&gt;parent
op_assign
id|parent
suffix:semicolon
id|buf-&gt;namelen
op_assign
id|namelen
suffix:semicolon
id|buf-&gt;u.name
op_assign
id|name
suffix:semicolon
id|WRITE_ENTRY_MAGIC
c_func
(paren
id|buf
comma
id|MAGIC_VALUE
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|devfsd_notify_de
c_func
(paren
id|buf
comma
id|DEVFSD_NOTIFY_LOOKUP
comma
l_int|0
comma
id|current-&gt;euid
comma
id|current-&gt;egid
comma
id|fs_info
)paren
)paren
r_return
op_minus
id|ENOENT
suffix:semicolon
multiline_comment|/*  Possible success: event has been queued  */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*  End Function try_modload  */
multiline_comment|/*  Superblock operations follow  */
DECL|variable|devfs_iops
r_static
r_struct
id|inode_operations
id|devfs_iops
suffix:semicolon
DECL|variable|devfs_dir_iops
r_static
r_struct
id|inode_operations
id|devfs_dir_iops
suffix:semicolon
DECL|variable|devfs_fops
r_static
r_struct
id|file_operations
id|devfs_fops
suffix:semicolon
DECL|variable|devfs_dir_fops
r_static
r_struct
id|file_operations
id|devfs_dir_fops
suffix:semicolon
DECL|variable|devfs_symlink_iops
r_static
r_struct
id|inode_operations
id|devfs_symlink_iops
suffix:semicolon
DECL|function|devfs_notify_change
r_static
r_int
id|devfs_notify_change
c_func
(paren
r_struct
id|dentry
op_star
id|dentry
comma
r_struct
id|iattr
op_star
id|iattr
)paren
(brace
r_int
id|retval
suffix:semicolon
r_struct
id|devfs_entry
op_star
id|de
suffix:semicolon
r_struct
id|inode
op_star
id|inode
op_assign
id|dentry-&gt;d_inode
suffix:semicolon
r_struct
id|fs_info
op_star
id|fs_info
op_assign
id|inode-&gt;i_sb-&gt;s_fs_info
suffix:semicolon
id|de
op_assign
id|get_devfs_entry_from_vfs_inode
c_func
(paren
id|inode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|de
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|retval
op_assign
id|inode_change_ok
c_func
(paren
id|inode
comma
id|iattr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_ne
l_int|0
)paren
r_return
id|retval
suffix:semicolon
id|retval
op_assign
id|inode_setattr
c_func
(paren
id|inode
comma
id|iattr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_ne
l_int|0
)paren
r_return
id|retval
suffix:semicolon
id|DPRINTK
c_func
(paren
id|DEBUG_I_CHANGE
comma
l_string|&quot;(%d): VFS inode: %p  devfs_entry: %p&bslash;n&quot;
comma
(paren
r_int
)paren
id|inode-&gt;i_ino
comma
id|inode
comma
id|de
)paren
suffix:semicolon
id|DPRINTK
c_func
(paren
id|DEBUG_I_CHANGE
comma
l_string|&quot;():   mode: 0%o  uid: %d  gid: %d&bslash;n&quot;
comma
(paren
r_int
)paren
id|inode-&gt;i_mode
comma
(paren
r_int
)paren
id|inode-&gt;i_uid
comma
(paren
r_int
)paren
id|inode-&gt;i_gid
)paren
suffix:semicolon
multiline_comment|/*  Inode is not on hash chains, thus must save permissions here rather&n;&t;   than in a write_inode() method  */
id|de-&gt;mode
op_assign
id|inode-&gt;i_mode
suffix:semicolon
id|de-&gt;inode.uid
op_assign
id|inode-&gt;i_uid
suffix:semicolon
id|de-&gt;inode.gid
op_assign
id|inode-&gt;i_gid
suffix:semicolon
id|de-&gt;inode.atime
op_assign
id|inode-&gt;i_atime
suffix:semicolon
id|de-&gt;inode.mtime
op_assign
id|inode-&gt;i_mtime
suffix:semicolon
id|de-&gt;inode.ctime
op_assign
id|inode-&gt;i_ctime
suffix:semicolon
r_if
c_cond
(paren
(paren
id|iattr-&gt;ia_valid
op_amp
(paren
id|ATTR_MODE
op_or
id|ATTR_UID
op_or
id|ATTR_GID
)paren
)paren
op_logical_and
op_logical_neg
id|is_devfsd_or_child
c_func
(paren
id|fs_info
)paren
)paren
id|devfsd_notify_de
c_func
(paren
id|de
comma
id|DEVFSD_NOTIFY_CHANGE
comma
id|inode-&gt;i_mode
comma
id|inode-&gt;i_uid
comma
id|inode-&gt;i_gid
comma
id|fs_info
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*  End Function devfs_notify_change  */
DECL|variable|devfs_sops
r_static
r_struct
id|super_operations
id|devfs_sops
op_assign
(brace
dot
id|drop_inode
op_assign
id|generic_delete_inode
comma
dot
id|statfs
op_assign
id|simple_statfs
comma
)brace
suffix:semicolon
multiline_comment|/**&n; *&t;_devfs_get_vfs_inode - Get a VFS inode.&n; *&t;@sb: The super block.&n; *&t;@de: The devfs inode.&n; *&t;@dentry: The dentry to register with the devfs inode.&n; *&n; *&t;Returns the inode on success, else %NULL. An implicit devfs_get() is&n; *       performed if the inode is created.&n; */
DECL|function|_devfs_get_vfs_inode
r_static
r_struct
id|inode
op_star
id|_devfs_get_vfs_inode
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_struct
id|devfs_entry
op_star
id|de
comma
r_struct
id|dentry
op_star
id|dentry
)paren
(brace
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_if
c_cond
(paren
id|de-&gt;prev
op_eq
id|de
)paren
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/*  Quick check to see if unhooked  */
r_if
c_cond
(paren
(paren
id|inode
op_assign
id|new_inode
c_func
(paren
id|sb
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|PRINTK
c_func
(paren
l_string|&quot;(%s): new_inode() failed, de: %p&bslash;n&quot;
comma
id|de-&gt;name
comma
id|de
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|de-&gt;parent
)paren
(brace
id|read_lock
c_func
(paren
op_amp
id|de-&gt;parent-&gt;u.dir.lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|de-&gt;prev
op_ne
id|de
)paren
id|de-&gt;inode.dentry
op_assign
id|dentry
suffix:semicolon
multiline_comment|/*      Not unhooked  */
id|read_unlock
c_func
(paren
op_amp
id|de-&gt;parent-&gt;u.dir.lock
)paren
suffix:semicolon
)brace
r_else
id|de-&gt;inode.dentry
op_assign
id|dentry
suffix:semicolon
multiline_comment|/*  Root: no locking needed  */
r_if
c_cond
(paren
id|de-&gt;inode.dentry
op_ne
id|dentry
)paren
(brace
multiline_comment|/*  Must have been unhooked  */
id|iput
c_func
(paren
id|inode
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* FIXME where is devfs_put? */
id|inode-&gt;u.generic_ip
op_assign
id|devfs_get
c_func
(paren
id|de
)paren
suffix:semicolon
id|inode-&gt;i_ino
op_assign
id|de-&gt;inode.ino
suffix:semicolon
id|DPRINTK
c_func
(paren
id|DEBUG_I_GET
comma
l_string|&quot;(%d): VFS inode: %p  devfs_entry: %p&bslash;n&quot;
comma
(paren
r_int
)paren
id|inode-&gt;i_ino
comma
id|inode
comma
id|de
)paren
suffix:semicolon
id|inode-&gt;i_blocks
op_assign
l_int|0
suffix:semicolon
id|inode-&gt;i_blksize
op_assign
id|FAKE_BLOCK_SIZE
suffix:semicolon
id|inode-&gt;i_op
op_assign
op_amp
id|devfs_iops
suffix:semicolon
id|inode-&gt;i_mode
op_assign
id|de-&gt;mode
suffix:semicolon
r_if
c_cond
(paren
id|S_ISDIR
c_func
(paren
id|de-&gt;mode
)paren
)paren
(brace
id|inode-&gt;i_op
op_assign
op_amp
id|devfs_dir_iops
suffix:semicolon
id|inode-&gt;i_fop
op_assign
op_amp
id|devfs_dir_fops
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|S_ISLNK
c_func
(paren
id|de-&gt;mode
)paren
)paren
(brace
id|inode-&gt;i_op
op_assign
op_amp
id|devfs_symlink_iops
suffix:semicolon
id|inode-&gt;i_size
op_assign
id|de-&gt;u.symlink.length
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|S_ISCHR
c_func
(paren
id|de-&gt;mode
)paren
op_logical_or
id|S_ISBLK
c_func
(paren
id|de-&gt;mode
)paren
)paren
(brace
id|init_special_inode
c_func
(paren
id|inode
comma
id|de-&gt;mode
comma
id|de-&gt;u.dev
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|S_ISFIFO
c_func
(paren
id|de-&gt;mode
)paren
op_logical_or
id|S_ISSOCK
c_func
(paren
id|de-&gt;mode
)paren
)paren
(brace
id|init_special_inode
c_func
(paren
id|inode
comma
id|de-&gt;mode
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
(brace
id|PRINTK
c_func
(paren
l_string|&quot;(%s): unknown mode %o de: %p&bslash;n&quot;
comma
id|de-&gt;name
comma
id|de-&gt;mode
comma
id|de
)paren
suffix:semicolon
id|iput
c_func
(paren
id|inode
)paren
suffix:semicolon
id|devfs_put
c_func
(paren
id|de
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|inode-&gt;i_uid
op_assign
id|de-&gt;inode.uid
suffix:semicolon
id|inode-&gt;i_gid
op_assign
id|de-&gt;inode.gid
suffix:semicolon
id|inode-&gt;i_atime
op_assign
id|de-&gt;inode.atime
suffix:semicolon
id|inode-&gt;i_mtime
op_assign
id|de-&gt;inode.mtime
suffix:semicolon
id|inode-&gt;i_ctime
op_assign
id|de-&gt;inode.ctime
suffix:semicolon
id|DPRINTK
c_func
(paren
id|DEBUG_I_GET
comma
l_string|&quot;():   mode: 0%o  uid: %d  gid: %d&bslash;n&quot;
comma
(paren
r_int
)paren
id|inode-&gt;i_mode
comma
(paren
r_int
)paren
id|inode-&gt;i_uid
comma
(paren
r_int
)paren
id|inode-&gt;i_gid
)paren
suffix:semicolon
r_return
id|inode
suffix:semicolon
)brace
multiline_comment|/*  End Function _devfs_get_vfs_inode  */
multiline_comment|/*  File operations for device entries follow  */
DECL|function|devfs_readdir
r_static
r_int
id|devfs_readdir
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_void
op_star
id|dirent
comma
id|filldir_t
id|filldir
)paren
(brace
r_int
id|err
comma
id|count
suffix:semicolon
r_int
id|stored
op_assign
l_int|0
suffix:semicolon
r_struct
id|fs_info
op_star
id|fs_info
suffix:semicolon
r_struct
id|devfs_entry
op_star
id|parent
comma
op_star
id|de
comma
op_star
id|next
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|inode
op_star
id|inode
op_assign
id|file-&gt;f_dentry-&gt;d_inode
suffix:semicolon
id|fs_info
op_assign
id|inode-&gt;i_sb-&gt;s_fs_info
suffix:semicolon
id|parent
op_assign
id|get_devfs_entry_from_vfs_inode
c_func
(paren
id|file-&gt;f_dentry-&gt;d_inode
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
)paren
id|file-&gt;f_pos
OL
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|DPRINTK
c_func
(paren
id|DEBUG_F_READDIR
comma
l_string|&quot;(%s): fs_info: %p  pos: %ld&bslash;n&quot;
comma
id|parent-&gt;name
comma
id|fs_info
comma
(paren
r_int
)paren
id|file-&gt;f_pos
)paren
suffix:semicolon
r_switch
c_cond
(paren
(paren
r_int
)paren
id|file-&gt;f_pos
)paren
(brace
r_case
l_int|0
suffix:colon
id|err
op_assign
(paren
op_star
id|filldir
)paren
(paren
id|dirent
comma
l_string|&quot;..&quot;
comma
l_int|2
comma
id|file-&gt;f_pos
comma
id|parent_ino
c_func
(paren
id|file-&gt;f_dentry
)paren
comma
id|DT_DIR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_eq
op_minus
id|EINVAL
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_return
id|err
suffix:semicolon
id|file-&gt;f_pos
op_increment
suffix:semicolon
op_increment
id|stored
suffix:semicolon
multiline_comment|/*  Fall through  */
r_case
l_int|1
suffix:colon
id|err
op_assign
(paren
op_star
id|filldir
)paren
(paren
id|dirent
comma
l_string|&quot;.&quot;
comma
l_int|1
comma
id|file-&gt;f_pos
comma
id|inode-&gt;i_ino
comma
id|DT_DIR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_eq
op_minus
id|EINVAL
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_return
id|err
suffix:semicolon
id|file-&gt;f_pos
op_increment
suffix:semicolon
op_increment
id|stored
suffix:semicolon
multiline_comment|/*  Fall through  */
r_default
suffix:colon
multiline_comment|/*  Skip entries  */
id|count
op_assign
id|file-&gt;f_pos
op_minus
l_int|2
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|parent-&gt;u.dir.lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|de
op_assign
id|parent-&gt;u.dir.first
suffix:semicolon
id|de
op_logical_and
(paren
id|count
OG
l_int|0
)paren
suffix:semicolon
id|de
op_assign
id|de-&gt;next
)paren
op_decrement
id|count
suffix:semicolon
id|devfs_get
c_func
(paren
id|de
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|parent-&gt;u.dir.lock
)paren
suffix:semicolon
multiline_comment|/*  Now add all remaining entries  */
r_while
c_loop
(paren
id|de
)paren
(brace
id|err
op_assign
(paren
op_star
id|filldir
)paren
(paren
id|dirent
comma
id|de-&gt;name
comma
id|de-&gt;namelen
comma
id|file-&gt;f_pos
comma
id|de-&gt;inode.ino
comma
id|de-&gt;mode
op_rshift
l_int|12
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
id|devfs_put
c_func
(paren
id|de
)paren
suffix:semicolon
r_else
(brace
id|file-&gt;f_pos
op_increment
suffix:semicolon
op_increment
id|stored
suffix:semicolon
)brace
r_if
c_cond
(paren
id|err
op_eq
op_minus
id|EINVAL
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_return
id|err
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|parent-&gt;u.dir.lock
)paren
suffix:semicolon
id|next
op_assign
id|devfs_get
c_func
(paren
id|de-&gt;next
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|parent-&gt;u.dir.lock
)paren
suffix:semicolon
id|devfs_put
c_func
(paren
id|de
)paren
suffix:semicolon
id|de
op_assign
id|next
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
r_return
id|stored
suffix:semicolon
)brace
multiline_comment|/*  End Function devfs_readdir  */
multiline_comment|/* Open devfs specific special files */
DECL|function|devfs_open
r_static
r_int
id|devfs_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_int
id|err
suffix:semicolon
r_int
id|minor
op_assign
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
r_struct
id|file_operations
op_star
id|old_fops
comma
op_star
id|new_fops
suffix:semicolon
r_switch
c_cond
(paren
id|minor
)paren
(brace
r_case
l_int|0
suffix:colon
multiline_comment|/* /dev/.devfsd */
id|new_fops
op_assign
id|fops_get
c_func
(paren
op_amp
id|devfsd_fops
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#ifdef CONFIG_DEVFS_DEBUG
r_case
l_int|1
suffix:colon
multiline_comment|/* /dev/.stat */
id|new_fops
op_assign
id|fops_get
c_func
(paren
op_amp
id|stat_fops
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
r_default
suffix:colon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_if
c_cond
(paren
id|new_fops
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|old_fops
op_assign
id|file-&gt;f_op
suffix:semicolon
id|file-&gt;f_op
op_assign
id|new_fops
suffix:semicolon
id|err
op_assign
id|new_fops-&gt;open
ques
c_cond
id|new_fops
op_member_access_from_pointer
id|open
c_func
(paren
id|inode
comma
id|file
)paren
suffix:colon
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|file-&gt;f_op
op_assign
id|old_fops
suffix:semicolon
id|fops_put
c_func
(paren
id|new_fops
)paren
suffix:semicolon
)brace
r_else
id|fops_put
c_func
(paren
id|old_fops
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*  End Function devfs_open  */
DECL|variable|devfs_fops
r_static
r_struct
id|file_operations
id|devfs_fops
op_assign
(brace
dot
id|open
op_assign
id|devfs_open
comma
)brace
suffix:semicolon
DECL|variable|devfs_dir_fops
r_static
r_struct
id|file_operations
id|devfs_dir_fops
op_assign
(brace
dot
id|read
op_assign
id|generic_read_dir
comma
dot
id|readdir
op_assign
id|devfs_readdir
comma
)brace
suffix:semicolon
multiline_comment|/*  Dentry operations for device entries follow  */
multiline_comment|/**&n; *&t;devfs_d_release - Callback for when a dentry is freed.&n; *&t;@dentry: The dentry.&n; */
DECL|function|devfs_d_release
r_static
r_void
id|devfs_d_release
c_func
(paren
r_struct
id|dentry
op_star
id|dentry
)paren
(brace
id|DPRINTK
c_func
(paren
id|DEBUG_D_RELEASE
comma
l_string|&quot;(%p): inode: %p&bslash;n&quot;
comma
id|dentry
comma
id|dentry-&gt;d_inode
)paren
suffix:semicolon
)brace
multiline_comment|/*  End Function devfs_d_release  */
multiline_comment|/**&n; *&t;devfs_d_iput - Callback for when a dentry loses its inode.&n; *&t;@dentry: The dentry.&n; *&t;@inode:&t;The inode.&n; */
DECL|function|devfs_d_iput
r_static
r_void
id|devfs_d_iput
c_func
(paren
r_struct
id|dentry
op_star
id|dentry
comma
r_struct
id|inode
op_star
id|inode
)paren
(brace
r_struct
id|devfs_entry
op_star
id|de
suffix:semicolon
id|de
op_assign
id|get_devfs_entry_from_vfs_inode
c_func
(paren
id|inode
)paren
suffix:semicolon
id|DPRINTK
c_func
(paren
id|DEBUG_D_IPUT
comma
l_string|&quot;(%s): dentry: %p inode: %p de: %p de-&gt;dentry: %p&bslash;n&quot;
comma
id|de-&gt;name
comma
id|dentry
comma
id|inode
comma
id|de
comma
id|de-&gt;inode.dentry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|de-&gt;inode.dentry
op_logical_and
(paren
id|de-&gt;inode.dentry
op_ne
id|dentry
)paren
)paren
id|OOPS
c_func
(paren
l_string|&quot;(%s): de: %p dentry: %p de-&gt;dentry: %p&bslash;n&quot;
comma
id|de-&gt;name
comma
id|de
comma
id|dentry
comma
id|de-&gt;inode.dentry
)paren
suffix:semicolon
id|de-&gt;inode.dentry
op_assign
l_int|NULL
suffix:semicolon
id|iput
c_func
(paren
id|inode
)paren
suffix:semicolon
id|devfs_put
c_func
(paren
id|de
)paren
suffix:semicolon
)brace
multiline_comment|/*  End Function devfs_d_iput  */
r_static
r_int
id|devfs_d_delete
c_func
(paren
r_struct
id|dentry
op_star
id|dentry
)paren
suffix:semicolon
DECL|variable|devfs_dops
r_static
r_struct
id|dentry_operations
id|devfs_dops
op_assign
(brace
dot
id|d_delete
op_assign
id|devfs_d_delete
comma
dot
id|d_release
op_assign
id|devfs_d_release
comma
dot
id|d_iput
op_assign
id|devfs_d_iput
comma
)brace
suffix:semicolon
r_static
r_int
id|devfs_d_revalidate_wait
c_func
(paren
r_struct
id|dentry
op_star
id|dentry
comma
r_struct
id|nameidata
op_star
)paren
suffix:semicolon
DECL|variable|devfs_wait_dops
r_static
r_struct
id|dentry_operations
id|devfs_wait_dops
op_assign
(brace
dot
id|d_delete
op_assign
id|devfs_d_delete
comma
dot
id|d_release
op_assign
id|devfs_d_release
comma
dot
id|d_iput
op_assign
id|devfs_d_iput
comma
dot
id|d_revalidate
op_assign
id|devfs_d_revalidate_wait
comma
)brace
suffix:semicolon
multiline_comment|/**&n; *&t;devfs_d_delete - Callback for when all files for a dentry are closed.&n; *&t;@dentry: The dentry.&n; */
DECL|function|devfs_d_delete
r_static
r_int
id|devfs_d_delete
c_func
(paren
r_struct
id|dentry
op_star
id|dentry
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|dentry-&gt;d_inode
suffix:semicolon
r_if
c_cond
(paren
id|dentry-&gt;d_op
op_eq
op_amp
id|devfs_wait_dops
)paren
id|dentry-&gt;d_op
op_assign
op_amp
id|devfs_dops
suffix:semicolon
multiline_comment|/*  Unhash dentry if negative (has no inode)  */
r_if
c_cond
(paren
id|inode
op_eq
l_int|NULL
)paren
(brace
id|DPRINTK
c_func
(paren
id|DEBUG_D_DELETE
comma
l_string|&quot;(%p): dropping negative dentry&bslash;n&quot;
comma
id|dentry
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*  End Function devfs_d_delete  */
DECL|struct|devfs_lookup_struct
r_struct
id|devfs_lookup_struct
(brace
DECL|member|de
id|devfs_handle_t
id|de
suffix:semicolon
DECL|member|wait_queue
id|wait_queue_head_t
id|wait_queue
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* XXX: this doesn&squot;t handle the case where we got a negative dentry&n;        but a devfs entry has been registered in the meanwhile */
DECL|function|devfs_d_revalidate_wait
r_static
r_int
id|devfs_d_revalidate_wait
c_func
(paren
r_struct
id|dentry
op_star
id|dentry
comma
r_struct
id|nameidata
op_star
id|nd
)paren
(brace
r_struct
id|inode
op_star
id|dir
op_assign
id|dentry-&gt;d_parent-&gt;d_inode
suffix:semicolon
r_struct
id|fs_info
op_star
id|fs_info
op_assign
id|dir-&gt;i_sb-&gt;s_fs_info
suffix:semicolon
id|devfs_handle_t
id|parent
op_assign
id|get_devfs_entry_from_vfs_inode
c_func
(paren
id|dir
)paren
suffix:semicolon
r_struct
id|devfs_lookup_struct
op_star
id|lookup_info
op_assign
id|dentry-&gt;d_fsdata
suffix:semicolon
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
r_int
id|need_lock
suffix:semicolon
multiline_comment|/*&n;&t; * FIXME HACK&n;&t; *&n;&t; * make sure that&n;&t; *   d_instantiate always runs under lock&n;&t; *   we release i_sem lock before going to sleep&n;&t; *&n;&t; * unfortunately sometimes d_revalidate is called with&n;&t; * and sometimes without i_sem lock held. The following checks&n;&t; * attempt to deduce when we need to add (and drop resp.) lock&n;&t; * here. This relies on current (2.6.2) calling coventions:&n;&t; *&n;&t; *   lookup_hash is always run under i_sem and is passing NULL&n;&t; *   as nd&n;&t; *&n;&t; *   open(...,O_CREATE,...) calls _lookup_hash under i_sem&n;&t; *   and sets flags to LOOKUP_OPEN|LOOKUP_CREATE&n;&t; *&n;&t; *   all other invocations of -&gt;d_revalidate seem to happen&n;&t; *   outside of i_sem&n;&t; */
id|need_lock
op_assign
id|nd
op_logical_and
(paren
op_logical_neg
(paren
id|nd-&gt;flags
op_amp
id|LOOKUP_CREATE
)paren
op_logical_or
(paren
id|nd-&gt;flags
op_amp
id|LOOKUP_PARENT
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|need_lock
)paren
id|down
c_func
(paren
op_amp
id|dir-&gt;i_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_devfsd_or_child
c_func
(paren
id|fs_info
)paren
)paren
(brace
id|devfs_handle_t
id|de
op_assign
id|lookup_info-&gt;de
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
id|DPRINTK
c_func
(paren
id|DEBUG_I_LOOKUP
comma
l_string|&quot;(%s): dentry: %p inode: %p de: %p by: &bslash;&quot;%s&bslash;&quot;&bslash;n&quot;
comma
id|dentry-&gt;d_name.name
comma
id|dentry
comma
id|dentry-&gt;d_inode
comma
id|de
comma
id|current-&gt;comm
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dentry-&gt;d_inode
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|de
op_eq
l_int|NULL
)paren
(brace
id|read_lock
c_func
(paren
op_amp
id|parent-&gt;u.dir.lock
)paren
suffix:semicolon
id|de
op_assign
id|_devfs_search_dir
c_func
(paren
id|parent
comma
id|dentry-&gt;d_name.name
comma
id|dentry-&gt;d_name.len
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|parent-&gt;u.dir.lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|de
op_eq
l_int|NULL
)paren
r_goto
id|out
suffix:semicolon
id|lookup_info-&gt;de
op_assign
id|de
suffix:semicolon
)brace
multiline_comment|/*  Create an inode, now that the driver information is available  */
id|inode
op_assign
id|_devfs_get_vfs_inode
c_func
(paren
id|dir-&gt;i_sb
comma
id|de
comma
id|dentry
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inode
)paren
r_goto
id|out
suffix:semicolon
id|DPRINTK
c_func
(paren
id|DEBUG_I_LOOKUP
comma
l_string|&quot;(%s): new VFS inode(%u): %p de: %p by: &bslash;&quot;%s&bslash;&quot;&bslash;n&quot;
comma
id|de-&gt;name
comma
id|de-&gt;inode.ino
comma
id|inode
comma
id|de
comma
id|current-&gt;comm
)paren
suffix:semicolon
id|d_instantiate
c_func
(paren
id|dentry
comma
id|inode
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|lookup_info
op_eq
l_int|NULL
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/*  Early termination  */
id|read_lock
c_func
(paren
op_amp
id|parent-&gt;u.dir.lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dentry-&gt;d_fsdata
)paren
(brace
id|set_current_state
c_func
(paren
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
id|add_wait_queue
c_func
(paren
op_amp
id|lookup_info-&gt;wait_queue
comma
op_amp
id|wait
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|parent-&gt;u.dir.lock
)paren
suffix:semicolon
multiline_comment|/* at this point it is always (hopefully) locked */
id|up
c_func
(paren
op_amp
id|dir-&gt;i_sem
)paren
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|dir-&gt;i_sem
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * This does not need nor should remove wait from wait_queue.&n;&t;&t; * Wait queue head is never reused - nothing is ever added to it&n;&t;&t; * after all waiters have been waked up and head itself disappears&n;&t;&t; * very soon after it. Moreover it is local variable on stack that&n;&t;&t; * is likely to have already disappeared so any reference to it&n;&t;&t; * at this point is buggy.&n;&t;&t; */
)brace
r_else
id|read_unlock
c_func
(paren
op_amp
id|parent-&gt;u.dir.lock
)paren
suffix:semicolon
id|out
suffix:colon
r_if
c_cond
(paren
id|need_lock
)paren
id|up
c_func
(paren
op_amp
id|dir-&gt;i_sem
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*  End Function devfs_d_revalidate_wait  */
multiline_comment|/*  Inode operations for device entries follow  */
DECL|function|devfs_lookup
r_static
r_struct
id|dentry
op_star
id|devfs_lookup
c_func
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|dentry
op_star
id|dentry
comma
r_struct
id|nameidata
op_star
id|nd
)paren
(brace
r_struct
id|devfs_entry
id|tmp
suffix:semicolon
multiline_comment|/*  Must stay in scope until devfsd idle again  */
r_struct
id|devfs_lookup_struct
id|lookup_info
suffix:semicolon
r_struct
id|fs_info
op_star
id|fs_info
op_assign
id|dir-&gt;i_sb-&gt;s_fs_info
suffix:semicolon
r_struct
id|devfs_entry
op_star
id|parent
comma
op_star
id|de
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_struct
id|dentry
op_star
id|retval
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*  Set up the dentry operations before anything else, to ensure cleaning&n;&t;   up on any error  */
id|dentry-&gt;d_op
op_assign
op_amp
id|devfs_dops
suffix:semicolon
multiline_comment|/*  First try to get the devfs entry for this directory  */
id|parent
op_assign
id|get_devfs_entry_from_vfs_inode
c_func
(paren
id|dir
)paren
suffix:semicolon
id|DPRINTK
c_func
(paren
id|DEBUG_I_LOOKUP
comma
l_string|&quot;(%s): dentry: %p parent: %p by: &bslash;&quot;%s&bslash;&quot;&bslash;n&quot;
comma
id|dentry-&gt;d_name.name
comma
id|dentry
comma
id|parent
comma
id|current-&gt;comm
)paren
suffix:semicolon
r_if
c_cond
(paren
id|parent
op_eq
l_int|NULL
)paren
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|ENOENT
)paren
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|parent-&gt;u.dir.lock
)paren
suffix:semicolon
id|de
op_assign
id|_devfs_search_dir
c_func
(paren
id|parent
comma
id|dentry-&gt;d_name.name
comma
id|dentry-&gt;d_name.len
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|parent-&gt;u.dir.lock
)paren
suffix:semicolon
id|lookup_info.de
op_assign
id|de
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|lookup_info.wait_queue
)paren
suffix:semicolon
id|dentry-&gt;d_fsdata
op_assign
op_amp
id|lookup_info
suffix:semicolon
r_if
c_cond
(paren
id|de
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/*  Try with devfsd. For any kind of failure, leave a negative dentry&n;&t;&t;&t;&t;   so someone else can deal with it (in the case where the sysadmin&n;&t;&t;&t;&t;   does a mknod()). It&squot;s important to do this before hashing the&n;&t;&t;&t;&t;   dentry, so that the devfsd queue is filled before revalidates&n;&t;&t;&t;&t;   can start  */
r_if
c_cond
(paren
id|try_modload
c_func
(paren
id|parent
comma
id|fs_info
comma
id|dentry-&gt;d_name.name
comma
id|dentry-&gt;d_name.len
comma
op_amp
id|tmp
)paren
OL
l_int|0
)paren
(brace
multiline_comment|/*  Lookup event was not queued to devfsd  */
id|d_add
c_func
(paren
id|dentry
comma
l_int|NULL
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
)brace
id|dentry-&gt;d_op
op_assign
op_amp
id|devfs_wait_dops
suffix:semicolon
id|d_add
c_func
(paren
id|dentry
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/*  Open the floodgates  */
multiline_comment|/*  Unlock directory semaphore, which will release any waiters. They&n;&t;   will get the hashed dentry, and may be forced to wait for&n;&t;   revalidation  */
id|up
c_func
(paren
op_amp
id|dir-&gt;i_sem
)paren
suffix:semicolon
id|wait_for_devfsd_finished
c_func
(paren
id|fs_info
)paren
suffix:semicolon
multiline_comment|/*  If I&squot;m not devfsd, must wait  */
id|down
c_func
(paren
op_amp
id|dir-&gt;i_sem
)paren
suffix:semicolon
multiline_comment|/*  Grab it again because them&squot;s the rules  */
id|de
op_assign
id|lookup_info.de
suffix:semicolon
multiline_comment|/*  If someone else has been so kind as to make the inode, we go home&n;&t;   early  */
r_if
c_cond
(paren
id|dentry-&gt;d_inode
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|de
op_eq
l_int|NULL
)paren
(brace
id|read_lock
c_func
(paren
op_amp
id|parent-&gt;u.dir.lock
)paren
suffix:semicolon
id|de
op_assign
id|_devfs_search_dir
c_func
(paren
id|parent
comma
id|dentry-&gt;d_name.name
comma
id|dentry-&gt;d_name.len
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|parent-&gt;u.dir.lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|de
op_eq
l_int|NULL
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/*  OK, there&squot;s an entry now, but no VFS inode yet  */
)brace
multiline_comment|/*  Create an inode, now that the driver information is available  */
id|inode
op_assign
id|_devfs_get_vfs_inode
c_func
(paren
id|dir-&gt;i_sb
comma
id|de
comma
id|dentry
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inode
)paren
(brace
id|retval
op_assign
id|ERR_PTR
c_func
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|DPRINTK
c_func
(paren
id|DEBUG_I_LOOKUP
comma
l_string|&quot;(%s): new VFS inode(%u): %p de: %p by: &bslash;&quot;%s&bslash;&quot;&bslash;n&quot;
comma
id|de-&gt;name
comma
id|de-&gt;inode.ino
comma
id|inode
comma
id|de
comma
id|current-&gt;comm
)paren
suffix:semicolon
id|d_instantiate
c_func
(paren
id|dentry
comma
id|inode
)paren
suffix:semicolon
id|out
suffix:colon
id|write_lock
c_func
(paren
op_amp
id|parent-&gt;u.dir.lock
)paren
suffix:semicolon
id|dentry-&gt;d_op
op_assign
op_amp
id|devfs_dops
suffix:semicolon
id|dentry-&gt;d_fsdata
op_assign
l_int|NULL
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|lookup_info.wait_queue
)paren
suffix:semicolon
id|write_unlock
c_func
(paren
op_amp
id|parent-&gt;u.dir.lock
)paren
suffix:semicolon
id|devfs_put
c_func
(paren
id|de
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*  End Function devfs_lookup  */
DECL|function|devfs_unlink
r_static
r_int
id|devfs_unlink
c_func
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|dentry
op_star
id|dentry
)paren
(brace
r_int
id|unhooked
suffix:semicolon
r_struct
id|devfs_entry
op_star
id|de
suffix:semicolon
r_struct
id|inode
op_star
id|inode
op_assign
id|dentry-&gt;d_inode
suffix:semicolon
r_struct
id|fs_info
op_star
id|fs_info
op_assign
id|dir-&gt;i_sb-&gt;s_fs_info
suffix:semicolon
id|de
op_assign
id|get_devfs_entry_from_vfs_inode
c_func
(paren
id|inode
)paren
suffix:semicolon
id|DPRINTK
c_func
(paren
id|DEBUG_I_UNLINK
comma
l_string|&quot;(%s): de: %p&bslash;n&quot;
comma
id|dentry-&gt;d_name.name
comma
id|de
)paren
suffix:semicolon
r_if
c_cond
(paren
id|de
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOENT
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|de-&gt;vfs
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|write_lock
c_func
(paren
op_amp
id|de-&gt;parent-&gt;u.dir.lock
)paren
suffix:semicolon
id|unhooked
op_assign
id|_devfs_unhook
c_func
(paren
id|de
)paren
suffix:semicolon
id|write_unlock
c_func
(paren
op_amp
id|de-&gt;parent-&gt;u.dir.lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|unhooked
)paren
r_return
op_minus
id|ENOENT
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|is_devfsd_or_child
c_func
(paren
id|fs_info
)paren
)paren
id|devfsd_notify_de
c_func
(paren
id|de
comma
id|DEVFSD_NOTIFY_DELETE
comma
id|inode-&gt;i_mode
comma
id|inode-&gt;i_uid
comma
id|inode-&gt;i_gid
comma
id|fs_info
)paren
suffix:semicolon
id|free_dentry
c_func
(paren
id|de
)paren
suffix:semicolon
id|devfs_put
c_func
(paren
id|de
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*  End Function devfs_unlink  */
DECL|function|devfs_symlink
r_static
r_int
id|devfs_symlink
c_func
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|dentry
op_star
id|dentry
comma
r_const
r_char
op_star
id|symname
)paren
(brace
r_int
id|err
suffix:semicolon
r_struct
id|fs_info
op_star
id|fs_info
op_assign
id|dir-&gt;i_sb-&gt;s_fs_info
suffix:semicolon
r_struct
id|devfs_entry
op_star
id|parent
comma
op_star
id|de
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
multiline_comment|/*  First try to get the devfs entry for this directory  */
id|parent
op_assign
id|get_devfs_entry_from_vfs_inode
c_func
(paren
id|dir
)paren
suffix:semicolon
r_if
c_cond
(paren
id|parent
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOENT
suffix:semicolon
id|err
op_assign
id|devfs_do_symlink
c_func
(paren
id|parent
comma
id|dentry-&gt;d_name.name
comma
id|symname
comma
op_amp
id|de
)paren
suffix:semicolon
id|DPRINTK
c_func
(paren
id|DEBUG_DISABLED
comma
l_string|&quot;(%s): errcode from &lt;devfs_do_symlink&gt;: %d&bslash;n&quot;
comma
id|dentry-&gt;d_name.name
comma
id|err
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_return
id|err
suffix:semicolon
id|de-&gt;vfs
op_assign
id|TRUE
suffix:semicolon
id|de-&gt;inode.uid
op_assign
id|current-&gt;euid
suffix:semicolon
id|de-&gt;inode.gid
op_assign
id|current-&gt;egid
suffix:semicolon
id|de-&gt;inode.atime
op_assign
id|CURRENT_TIME
suffix:semicolon
id|de-&gt;inode.mtime
op_assign
id|CURRENT_TIME
suffix:semicolon
id|de-&gt;inode.ctime
op_assign
id|CURRENT_TIME
suffix:semicolon
r_if
c_cond
(paren
(paren
id|inode
op_assign
id|_devfs_get_vfs_inode
c_func
(paren
id|dir-&gt;i_sb
comma
id|de
comma
id|dentry
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|DPRINTK
c_func
(paren
id|DEBUG_DISABLED
comma
l_string|&quot;(%s): new VFS inode(%u): %p  dentry: %p&bslash;n&quot;
comma
id|dentry-&gt;d_name.name
comma
id|de-&gt;inode.ino
comma
id|inode
comma
id|dentry
)paren
suffix:semicolon
id|d_instantiate
c_func
(paren
id|dentry
comma
id|inode
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|is_devfsd_or_child
c_func
(paren
id|fs_info
)paren
)paren
id|devfsd_notify_de
c_func
(paren
id|de
comma
id|DEVFSD_NOTIFY_CREATE
comma
id|inode-&gt;i_mode
comma
id|inode-&gt;i_uid
comma
id|inode-&gt;i_gid
comma
id|fs_info
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*  End Function devfs_symlink  */
DECL|function|devfs_mkdir
r_static
r_int
id|devfs_mkdir
c_func
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|dentry
op_star
id|dentry
comma
r_int
id|mode
)paren
(brace
r_int
id|err
suffix:semicolon
r_struct
id|fs_info
op_star
id|fs_info
op_assign
id|dir-&gt;i_sb-&gt;s_fs_info
suffix:semicolon
r_struct
id|devfs_entry
op_star
id|parent
comma
op_star
id|de
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
id|mode
op_assign
(paren
id|mode
op_amp
op_complement
id|S_IFMT
)paren
op_or
id|S_IFDIR
suffix:semicolon
multiline_comment|/*  VFS doesn&squot;t pass S_IFMT part  */
id|parent
op_assign
id|get_devfs_entry_from_vfs_inode
c_func
(paren
id|dir
)paren
suffix:semicolon
r_if
c_cond
(paren
id|parent
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOENT
suffix:semicolon
id|de
op_assign
id|_devfs_alloc_entry
c_func
(paren
id|dentry-&gt;d_name.name
comma
id|dentry-&gt;d_name.len
comma
id|mode
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|de
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|de-&gt;vfs
op_assign
id|TRUE
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|_devfs_append_entry
c_func
(paren
id|parent
comma
id|de
comma
l_int|NULL
)paren
)paren
op_ne
l_int|0
)paren
r_return
id|err
suffix:semicolon
id|de-&gt;inode.uid
op_assign
id|current-&gt;euid
suffix:semicolon
id|de-&gt;inode.gid
op_assign
id|current-&gt;egid
suffix:semicolon
id|de-&gt;inode.atime
op_assign
id|CURRENT_TIME
suffix:semicolon
id|de-&gt;inode.mtime
op_assign
id|CURRENT_TIME
suffix:semicolon
id|de-&gt;inode.ctime
op_assign
id|CURRENT_TIME
suffix:semicolon
r_if
c_cond
(paren
(paren
id|inode
op_assign
id|_devfs_get_vfs_inode
c_func
(paren
id|dir-&gt;i_sb
comma
id|de
comma
id|dentry
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|DPRINTK
c_func
(paren
id|DEBUG_DISABLED
comma
l_string|&quot;(%s): new VFS inode(%u): %p  dentry: %p&bslash;n&quot;
comma
id|dentry-&gt;d_name.name
comma
id|de-&gt;inode.ino
comma
id|inode
comma
id|dentry
)paren
suffix:semicolon
id|d_instantiate
c_func
(paren
id|dentry
comma
id|inode
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|is_devfsd_or_child
c_func
(paren
id|fs_info
)paren
)paren
id|devfsd_notify_de
c_func
(paren
id|de
comma
id|DEVFSD_NOTIFY_CREATE
comma
id|inode-&gt;i_mode
comma
id|inode-&gt;i_uid
comma
id|inode-&gt;i_gid
comma
id|fs_info
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*  End Function devfs_mkdir  */
DECL|function|devfs_rmdir
r_static
r_int
id|devfs_rmdir
c_func
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|dentry
op_star
id|dentry
)paren
(brace
r_int
id|err
op_assign
l_int|0
suffix:semicolon
r_struct
id|devfs_entry
op_star
id|de
suffix:semicolon
r_struct
id|fs_info
op_star
id|fs_info
op_assign
id|dir-&gt;i_sb-&gt;s_fs_info
suffix:semicolon
r_struct
id|inode
op_star
id|inode
op_assign
id|dentry-&gt;d_inode
suffix:semicolon
r_if
c_cond
(paren
id|dir-&gt;i_sb-&gt;s_fs_info
op_ne
id|inode-&gt;i_sb-&gt;s_fs_info
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|de
op_assign
id|get_devfs_entry_from_vfs_inode
c_func
(paren
id|inode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|de
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOENT
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|S_ISDIR
c_func
(paren
id|de-&gt;mode
)paren
)paren
r_return
op_minus
id|ENOTDIR
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|de-&gt;vfs
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
multiline_comment|/*  First ensure the directory is empty and will stay that way  */
id|write_lock
c_func
(paren
op_amp
id|de-&gt;u.dir.lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|de-&gt;u.dir.first
)paren
id|err
op_assign
op_minus
id|ENOTEMPTY
suffix:semicolon
r_else
id|de-&gt;u.dir.no_more_additions
op_assign
id|TRUE
suffix:semicolon
id|write_unlock
c_func
(paren
op_amp
id|de-&gt;u.dir.lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
multiline_comment|/*  Now unhook the directory from its parent  */
id|write_lock
c_func
(paren
op_amp
id|de-&gt;parent-&gt;u.dir.lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|_devfs_unhook
c_func
(paren
id|de
)paren
)paren
id|err
op_assign
op_minus
id|ENOENT
suffix:semicolon
id|write_unlock
c_func
(paren
op_amp
id|de-&gt;parent-&gt;u.dir.lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|is_devfsd_or_child
c_func
(paren
id|fs_info
)paren
)paren
id|devfsd_notify_de
c_func
(paren
id|de
comma
id|DEVFSD_NOTIFY_DELETE
comma
id|inode-&gt;i_mode
comma
id|inode-&gt;i_uid
comma
id|inode-&gt;i_gid
comma
id|fs_info
)paren
suffix:semicolon
id|free_dentry
c_func
(paren
id|de
)paren
suffix:semicolon
id|devfs_put
c_func
(paren
id|de
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*  End Function devfs_rmdir  */
DECL|function|devfs_mknod
r_static
r_int
id|devfs_mknod
c_func
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|dentry
op_star
id|dentry
comma
r_int
id|mode
comma
id|dev_t
id|rdev
)paren
(brace
r_int
id|err
suffix:semicolon
r_struct
id|fs_info
op_star
id|fs_info
op_assign
id|dir-&gt;i_sb-&gt;s_fs_info
suffix:semicolon
r_struct
id|devfs_entry
op_star
id|parent
comma
op_star
id|de
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
id|DPRINTK
c_func
(paren
id|DEBUG_I_MKNOD
comma
l_string|&quot;(%s): mode: 0%o  dev: %u:%u&bslash;n&quot;
comma
id|dentry-&gt;d_name.name
comma
id|mode
comma
id|MAJOR
c_func
(paren
id|rdev
)paren
comma
id|MINOR
c_func
(paren
id|rdev
)paren
)paren
suffix:semicolon
id|parent
op_assign
id|get_devfs_entry_from_vfs_inode
c_func
(paren
id|dir
)paren
suffix:semicolon
r_if
c_cond
(paren
id|parent
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOENT
suffix:semicolon
id|de
op_assign
id|_devfs_alloc_entry
c_func
(paren
id|dentry-&gt;d_name.name
comma
id|dentry-&gt;d_name.len
comma
id|mode
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|de
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|de-&gt;vfs
op_assign
id|TRUE
suffix:semicolon
r_if
c_cond
(paren
id|S_ISCHR
c_func
(paren
id|mode
)paren
op_logical_or
id|S_ISBLK
c_func
(paren
id|mode
)paren
)paren
id|de-&gt;u.dev
op_assign
id|rdev
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|_devfs_append_entry
c_func
(paren
id|parent
comma
id|de
comma
l_int|NULL
)paren
)paren
op_ne
l_int|0
)paren
r_return
id|err
suffix:semicolon
id|de-&gt;inode.uid
op_assign
id|current-&gt;euid
suffix:semicolon
id|de-&gt;inode.gid
op_assign
id|current-&gt;egid
suffix:semicolon
id|de-&gt;inode.atime
op_assign
id|CURRENT_TIME
suffix:semicolon
id|de-&gt;inode.mtime
op_assign
id|CURRENT_TIME
suffix:semicolon
id|de-&gt;inode.ctime
op_assign
id|CURRENT_TIME
suffix:semicolon
r_if
c_cond
(paren
(paren
id|inode
op_assign
id|_devfs_get_vfs_inode
c_func
(paren
id|dir-&gt;i_sb
comma
id|de
comma
id|dentry
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|DPRINTK
c_func
(paren
id|DEBUG_I_MKNOD
comma
l_string|&quot;:   new VFS inode(%u): %p  dentry: %p&bslash;n&quot;
comma
id|de-&gt;inode.ino
comma
id|inode
comma
id|dentry
)paren
suffix:semicolon
id|d_instantiate
c_func
(paren
id|dentry
comma
id|inode
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|is_devfsd_or_child
c_func
(paren
id|fs_info
)paren
)paren
id|devfsd_notify_de
c_func
(paren
id|de
comma
id|DEVFSD_NOTIFY_CREATE
comma
id|inode-&gt;i_mode
comma
id|inode-&gt;i_uid
comma
id|inode-&gt;i_gid
comma
id|fs_info
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*  End Function devfs_mknod  */
DECL|function|devfs_follow_link
r_static
r_int
id|devfs_follow_link
c_func
(paren
r_struct
id|dentry
op_star
id|dentry
comma
r_struct
id|nameidata
op_star
id|nd
)paren
(brace
r_struct
id|devfs_entry
op_star
id|p
op_assign
id|get_devfs_entry_from_vfs_inode
c_func
(paren
id|dentry-&gt;d_inode
)paren
suffix:semicolon
id|nd_set_link
c_func
(paren
id|nd
comma
id|p
ques
c_cond
id|p-&gt;u.symlink.linkname
suffix:colon
id|ERR_PTR
c_func
(paren
op_minus
id|ENODEV
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*  End Function devfs_follow_link  */
DECL|variable|devfs_iops
r_static
r_struct
id|inode_operations
id|devfs_iops
op_assign
(brace
dot
id|setattr
op_assign
id|devfs_notify_change
comma
)brace
suffix:semicolon
DECL|variable|devfs_dir_iops
r_static
r_struct
id|inode_operations
id|devfs_dir_iops
op_assign
(brace
dot
id|lookup
op_assign
id|devfs_lookup
comma
dot
id|unlink
op_assign
id|devfs_unlink
comma
dot
id|symlink
op_assign
id|devfs_symlink
comma
dot
id|mkdir
op_assign
id|devfs_mkdir
comma
dot
id|rmdir
op_assign
id|devfs_rmdir
comma
dot
id|mknod
op_assign
id|devfs_mknod
comma
dot
id|setattr
op_assign
id|devfs_notify_change
comma
)brace
suffix:semicolon
DECL|variable|devfs_symlink_iops
r_static
r_struct
id|inode_operations
id|devfs_symlink_iops
op_assign
(brace
dot
id|readlink
op_assign
id|generic_readlink
comma
dot
id|follow_link
op_assign
id|devfs_follow_link
comma
dot
id|setattr
op_assign
id|devfs_notify_change
comma
)brace
suffix:semicolon
DECL|function|devfs_fill_super
r_static
r_int
id|devfs_fill_super
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_void
op_star
id|data
comma
r_int
id|silent
)paren
(brace
r_struct
id|inode
op_star
id|root_inode
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|_devfs_get_root_entry
c_func
(paren
)paren
op_eq
l_int|NULL
)paren
r_goto
id|out_no_root
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|fs_info.devfsd_overrun_count
comma
l_int|0
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|fs_info.devfsd_wait_queue
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|fs_info.revalidate_wait_queue
)paren
suffix:semicolon
id|fs_info.sb
op_assign
id|sb
suffix:semicolon
id|sb-&gt;s_fs_info
op_assign
op_amp
id|fs_info
suffix:semicolon
id|sb-&gt;s_blocksize
op_assign
l_int|1024
suffix:semicolon
id|sb-&gt;s_blocksize_bits
op_assign
l_int|10
suffix:semicolon
id|sb-&gt;s_magic
op_assign
id|DEVFS_SUPER_MAGIC
suffix:semicolon
id|sb-&gt;s_op
op_assign
op_amp
id|devfs_sops
suffix:semicolon
id|sb-&gt;s_time_gran
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|root_inode
op_assign
id|_devfs_get_vfs_inode
c_func
(paren
id|sb
comma
id|root_entry
comma
l_int|NULL
)paren
)paren
op_eq
l_int|NULL
)paren
r_goto
id|out_no_root
suffix:semicolon
id|sb-&gt;s_root
op_assign
id|d_alloc_root
c_func
(paren
id|root_inode
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sb-&gt;s_root
)paren
r_goto
id|out_no_root
suffix:semicolon
id|DPRINTK
c_func
(paren
id|DEBUG_S_READ
comma
l_string|&quot;(): made devfs ptr: %p&bslash;n&quot;
comma
id|sb-&gt;s_fs_info
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|out_no_root
suffix:colon
id|PRINTK
c_func
(paren
l_string|&quot;(): get root inode failed&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|root_inode
)paren
id|iput
c_func
(paren
id|root_inode
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/*  End Function devfs_fill_super  */
DECL|function|devfs_get_sb
r_static
r_struct
id|super_block
op_star
id|devfs_get_sb
c_func
(paren
r_struct
id|file_system_type
op_star
id|fs_type
comma
r_int
id|flags
comma
r_const
r_char
op_star
id|dev_name
comma
r_void
op_star
id|data
)paren
(brace
r_return
id|get_sb_single
c_func
(paren
id|fs_type
comma
id|flags
comma
id|data
comma
id|devfs_fill_super
)paren
suffix:semicolon
)brace
DECL|variable|devfs_fs_type
r_static
r_struct
id|file_system_type
id|devfs_fs_type
op_assign
(brace
dot
id|name
op_assign
id|DEVFS_NAME
comma
dot
id|get_sb
op_assign
id|devfs_get_sb
comma
dot
id|kill_sb
op_assign
id|kill_anon_super
comma
)brace
suffix:semicolon
multiline_comment|/*  File operations for devfsd follow  */
DECL|function|devfsd_read
r_static
id|ssize_t
id|devfsd_read
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_char
id|__user
op_star
id|buf
comma
r_int
id|len
comma
id|loff_t
op_star
id|ppos
)paren
(brace
r_int
id|done
op_assign
id|FALSE
suffix:semicolon
r_int
id|ival
suffix:semicolon
id|loff_t
id|pos
comma
id|devname_offset
comma
id|tlen
comma
id|rpos
suffix:semicolon
id|devfs_handle_t
id|de
suffix:semicolon
r_struct
id|devfsd_buf_entry
op_star
id|entry
suffix:semicolon
r_struct
id|fs_info
op_star
id|fs_info
op_assign
id|file-&gt;f_dentry-&gt;d_inode-&gt;i_sb-&gt;s_fs_info
suffix:semicolon
r_struct
id|devfsd_notify_struct
op_star
id|info
op_assign
id|fs_info-&gt;devfsd_info
suffix:semicolon
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
multiline_comment|/*  Verify the task has grabbed the queue  */
r_if
c_cond
(paren
id|fs_info-&gt;devfsd_task
op_ne
id|current
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|info-&gt;major
op_assign
l_int|0
suffix:semicolon
id|info-&gt;minor
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*  Block for a new entry  */
id|set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
id|add_wait_queue
c_func
(paren
op_amp
id|fs_info-&gt;devfsd_wait_queue
comma
op_amp
id|wait
)paren
suffix:semicolon
r_while
c_loop
(paren
id|devfsd_queue_empty
c_func
(paren
id|fs_info
)paren
)paren
(brace
id|fs_info-&gt;devfsd_sleeping
op_assign
id|TRUE
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|fs_info-&gt;revalidate_wait_queue
)paren
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|fs_info-&gt;devfsd_sleeping
op_assign
id|FALSE
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
id|remove_wait_queue
c_func
(paren
op_amp
id|fs_info-&gt;devfsd_wait_queue
comma
op_amp
id|wait
)paren
suffix:semicolon
id|__set_current_state
c_func
(paren
id|TASK_RUNNING
)paren
suffix:semicolon
r_return
op_minus
id|EINTR
suffix:semicolon
)brace
id|set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
)brace
id|remove_wait_queue
c_func
(paren
op_amp
id|fs_info-&gt;devfsd_wait_queue
comma
op_amp
id|wait
)paren
suffix:semicolon
id|__set_current_state
c_func
(paren
id|TASK_RUNNING
)paren
suffix:semicolon
multiline_comment|/*  Now play with the data  */
id|ival
op_assign
id|atomic_read
c_func
(paren
op_amp
id|fs_info-&gt;devfsd_overrun_count
)paren
suffix:semicolon
id|info-&gt;overrun_count
op_assign
id|ival
suffix:semicolon
id|entry
op_assign
id|fs_info-&gt;devfsd_first_event
suffix:semicolon
id|info-&gt;type
op_assign
id|entry-&gt;type
suffix:semicolon
id|info-&gt;mode
op_assign
id|entry-&gt;mode
suffix:semicolon
id|info-&gt;uid
op_assign
id|entry-&gt;uid
suffix:semicolon
id|info-&gt;gid
op_assign
id|entry-&gt;gid
suffix:semicolon
id|de
op_assign
id|entry-&gt;de
suffix:semicolon
r_if
c_cond
(paren
id|S_ISCHR
c_func
(paren
id|de-&gt;mode
)paren
op_logical_or
id|S_ISBLK
c_func
(paren
id|de-&gt;mode
)paren
)paren
(brace
id|info-&gt;major
op_assign
id|MAJOR
c_func
(paren
id|de-&gt;u.dev
)paren
suffix:semicolon
id|info-&gt;minor
op_assign
id|MINOR
c_func
(paren
id|de-&gt;u.dev
)paren
suffix:semicolon
)brace
id|pos
op_assign
id|devfs_generate_path
c_func
(paren
id|de
comma
id|info-&gt;devname
comma
id|DEVFS_PATHLEN
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pos
OL
l_int|0
)paren
r_return
id|pos
suffix:semicolon
id|info-&gt;namelen
op_assign
id|DEVFS_PATHLEN
op_minus
id|pos
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;mode
op_eq
l_int|0
)paren
id|info-&gt;mode
op_assign
id|de-&gt;mode
suffix:semicolon
id|devname_offset
op_assign
id|info-&gt;devname
op_minus
(paren
r_char
op_star
)paren
id|info
suffix:semicolon
id|rpos
op_assign
op_star
id|ppos
suffix:semicolon
r_if
c_cond
(paren
id|rpos
OL
id|devname_offset
)paren
(brace
multiline_comment|/*  Copy parts of the header  */
id|tlen
op_assign
id|devname_offset
op_minus
id|rpos
suffix:semicolon
r_if
c_cond
(paren
id|tlen
OG
id|len
)paren
id|tlen
op_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|buf
comma
(paren
r_char
op_star
)paren
id|info
op_plus
id|rpos
comma
id|tlen
)paren
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
id|rpos
op_add_assign
id|tlen
suffix:semicolon
id|buf
op_add_assign
id|tlen
suffix:semicolon
id|len
op_sub_assign
id|tlen
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|rpos
op_ge
id|devname_offset
)paren
op_logical_and
(paren
id|len
OG
l_int|0
)paren
)paren
(brace
multiline_comment|/*  Copy the name  */
id|tlen
op_assign
id|info-&gt;namelen
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|tlen
OG
id|len
)paren
id|tlen
op_assign
id|len
suffix:semicolon
r_else
id|done
op_assign
id|TRUE
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
(paren
id|buf
comma
id|info-&gt;devname
op_plus
id|pos
op_plus
id|rpos
op_minus
id|devname_offset
comma
id|tlen
)paren
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
id|rpos
op_add_assign
id|tlen
suffix:semicolon
)brace
id|tlen
op_assign
id|rpos
op_minus
op_star
id|ppos
suffix:semicolon
r_if
c_cond
(paren
id|done
)paren
(brace
id|devfs_handle_t
id|parent
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|fs_info-&gt;devfsd_buffer_lock
)paren
suffix:semicolon
id|fs_info-&gt;devfsd_first_event
op_assign
id|entry-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|entry-&gt;next
op_eq
l_int|NULL
)paren
id|fs_info-&gt;devfsd_last_event
op_assign
l_int|NULL
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|fs_info-&gt;devfsd_buffer_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|de
op_ne
l_int|NULL
suffix:semicolon
id|de
op_assign
id|parent
)paren
(brace
id|parent
op_assign
id|de-&gt;parent
suffix:semicolon
id|devfs_put
c_func
(paren
id|de
)paren
suffix:semicolon
)brace
id|kmem_cache_free
c_func
(paren
id|devfsd_buf_cache
comma
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ival
OG
l_int|0
)paren
id|atomic_sub
c_func
(paren
id|ival
comma
op_amp
id|fs_info-&gt;devfsd_overrun_count
)paren
suffix:semicolon
op_star
id|ppos
op_assign
l_int|0
suffix:semicolon
)brace
r_else
op_star
id|ppos
op_assign
id|rpos
suffix:semicolon
r_return
id|tlen
suffix:semicolon
)brace
multiline_comment|/*  End Function devfsd_read  */
DECL|function|devfsd_ioctl
r_static
r_int
id|devfsd_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_int
id|ival
suffix:semicolon
r_struct
id|fs_info
op_star
id|fs_info
op_assign
id|inode-&gt;i_sb-&gt;s_fs_info
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|DEVFSDIOC_GET_PROTO_REV
suffix:colon
id|ival
op_assign
id|DEVFSD_PROTOCOL_REVISION_KERNEL
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
(paren
r_void
id|__user
op_star
)paren
id|arg
comma
op_amp
id|ival
comma
r_sizeof
id|ival
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DEVFSDIOC_SET_EVENT_MASK
suffix:colon
multiline_comment|/*  Ensure only one reader has access to the queue. This scheme will&n;&t;&t;   work even if the global kernel lock were to be removed, because it&n;&t;&t;   doesn&squot;t matter who gets in first, as long as only one gets it  */
r_if
c_cond
(paren
id|fs_info-&gt;devfsd_task
op_eq
l_int|NULL
)paren
(brace
r_static
id|DEFINE_SPINLOCK
c_func
(paren
id|lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|spin_trylock
c_func
(paren
op_amp
id|lock
)paren
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
r_if
c_cond
(paren
id|fs_info-&gt;devfsd_task
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/*  We lost the race...  */
id|spin_unlock
c_func
(paren
op_amp
id|lock
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|fs_info-&gt;devfsd_task
op_assign
id|current
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|lock
)paren
suffix:semicolon
id|fs_info-&gt;devfsd_pgrp
op_assign
(paren
id|process_group
c_func
(paren
id|current
)paren
op_eq
id|current-&gt;pid
)paren
ques
c_cond
id|process_group
c_func
(paren
id|current
)paren
suffix:colon
l_int|0
suffix:semicolon
id|fs_info-&gt;devfsd_file
op_assign
id|file
suffix:semicolon
id|fs_info-&gt;devfsd_info
op_assign
id|kmalloc
c_func
(paren
r_sizeof
op_star
id|fs_info-&gt;devfsd_info
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fs_info-&gt;devfsd_info
)paren
(brace
id|devfsd_close
c_func
(paren
id|inode
comma
id|file
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|fs_info-&gt;devfsd_task
op_ne
id|current
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
id|fs_info-&gt;devfsd_event_mask
op_assign
id|arg
suffix:semicolon
multiline_comment|/*  Let the masses come forth  */
r_break
suffix:semicolon
r_case
id|DEVFSDIOC_RELEASE_EVENT_QUEUE
suffix:colon
r_if
c_cond
(paren
id|fs_info-&gt;devfsd_file
op_ne
id|file
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_return
id|devfsd_close
c_func
(paren
id|inode
comma
id|file
)paren
suffix:semicolon
multiline_comment|/*break; */
macro_line|#ifdef CONFIG_DEVFS_DEBUG
r_case
id|DEVFSDIOC_SET_DEBUG_MASK
suffix:colon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|ival
comma
(paren
r_void
id|__user
op_star
)paren
id|arg
comma
r_sizeof
id|ival
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|devfs_debug
op_assign
id|ival
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
r_default
suffix:colon
r_return
op_minus
id|ENOIOCTLCMD
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*  End Function devfsd_ioctl  */
DECL|function|devfsd_close
r_static
r_int
id|devfsd_close
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_struct
id|devfsd_buf_entry
op_star
id|entry
comma
op_star
id|next
suffix:semicolon
r_struct
id|fs_info
op_star
id|fs_info
op_assign
id|inode-&gt;i_sb-&gt;s_fs_info
suffix:semicolon
r_if
c_cond
(paren
id|fs_info-&gt;devfsd_file
op_ne
id|file
)paren
r_return
l_int|0
suffix:semicolon
id|fs_info-&gt;devfsd_event_mask
op_assign
l_int|0
suffix:semicolon
id|fs_info-&gt;devfsd_file
op_assign
l_int|NULL
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|fs_info-&gt;devfsd_buffer_lock
)paren
suffix:semicolon
id|entry
op_assign
id|fs_info-&gt;devfsd_first_event
suffix:semicolon
id|fs_info-&gt;devfsd_first_event
op_assign
l_int|NULL
suffix:semicolon
id|fs_info-&gt;devfsd_last_event
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|fs_info-&gt;devfsd_info
)paren
(brace
id|kfree
c_func
(paren
id|fs_info-&gt;devfsd_info
)paren
suffix:semicolon
id|fs_info-&gt;devfsd_info
op_assign
l_int|NULL
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|fs_info-&gt;devfsd_buffer_lock
)paren
suffix:semicolon
id|fs_info-&gt;devfsd_pgrp
op_assign
l_int|0
suffix:semicolon
id|fs_info-&gt;devfsd_task
op_assign
l_int|NULL
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|fs_info-&gt;revalidate_wait_queue
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|entry
suffix:semicolon
id|entry
op_assign
id|next
)paren
(brace
id|next
op_assign
id|entry-&gt;next
suffix:semicolon
id|kmem_cache_free
c_func
(paren
id|devfsd_buf_cache
comma
id|entry
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*  End Function devfsd_close  */
macro_line|#ifdef CONFIG_DEVFS_DEBUG
DECL|function|stat_read
r_static
id|ssize_t
id|stat_read
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_char
id|__user
op_star
id|buf
comma
r_int
id|len
comma
id|loff_t
op_star
id|ppos
)paren
(brace
id|ssize_t
id|num
suffix:semicolon
r_char
id|txt
(braket
l_int|80
)braket
suffix:semicolon
id|num
op_assign
id|sprintf
c_func
(paren
id|txt
comma
l_string|&quot;Number of entries: %u  number of bytes: %u&bslash;n&quot;
comma
id|stat_num_entries
comma
id|stat_num_bytes
)paren
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_star
id|ppos
op_ge
id|num
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_star
id|ppos
op_plus
id|len
OG
id|num
)paren
id|len
op_assign
id|num
op_minus
op_star
id|ppos
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|buf
comma
id|txt
op_plus
op_star
id|ppos
comma
id|len
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
op_star
id|ppos
op_add_assign
id|len
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
multiline_comment|/*  End Function stat_read  */
macro_line|#endif
DECL|function|init_devfs_fs
r_static
r_int
id|__init
id|init_devfs_fs
c_func
(paren
r_void
)paren
(brace
r_int
id|err
suffix:semicolon
r_int
id|major
suffix:semicolon
r_struct
id|devfs_entry
op_star
id|devfsd
suffix:semicolon
macro_line|#ifdef CONFIG_DEVFS_DEBUG
r_struct
id|devfs_entry
op_star
id|stat
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|_devfs_get_root_entry
c_func
(paren
)paren
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: %s Richard Gooch (rgooch@atnf.csiro.au)&bslash;n&quot;
comma
id|DEVFS_NAME
comma
id|DEVFS_VERSION
)paren
suffix:semicolon
id|devfsd_buf_cache
op_assign
id|kmem_cache_create
c_func
(paren
l_string|&quot;devfsd_event&quot;
comma
r_sizeof
(paren
r_struct
id|devfsd_buf_entry
)paren
comma
l_int|0
comma
l_int|0
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|devfsd_buf_cache
)paren
id|OOPS
c_func
(paren
l_string|&quot;(): unable to allocate event slab&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_DEVFS_DEBUG
id|devfs_debug
op_assign
id|devfs_debug_init
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: devfs_debug: 0x%0x&bslash;n&quot;
comma
id|DEVFS_NAME
comma
id|devfs_debug
)paren
suffix:semicolon
macro_line|#endif
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: boot_options: 0x%0x&bslash;n&quot;
comma
id|DEVFS_NAME
comma
id|boot_options
)paren
suffix:semicolon
multiline_comment|/* register special device for devfsd communication */
id|major
op_assign
id|register_chrdev
c_func
(paren
l_int|0
comma
l_string|&quot;devfs&quot;
comma
op_amp
id|devfs_fops
)paren
suffix:semicolon
r_if
c_cond
(paren
id|major
OL
l_int|0
)paren
r_return
id|major
suffix:semicolon
multiline_comment|/*  And create the entry for &quot;.devfsd&quot;  */
id|devfsd
op_assign
id|_devfs_alloc_entry
c_func
(paren
l_string|&quot;.devfsd&quot;
comma
l_int|0
comma
id|S_IFCHR
op_or
id|S_IRUSR
op_or
id|S_IWUSR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|devfsd
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|devfsd-&gt;u.dev
op_assign
id|MKDEV
c_func
(paren
id|major
comma
l_int|0
)paren
suffix:semicolon
id|_devfs_append_entry
c_func
(paren
id|root_entry
comma
id|devfsd
comma
l_int|NULL
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_DEVFS_DEBUG
id|stat
op_assign
id|_devfs_alloc_entry
c_func
(paren
l_string|&quot;.stat&quot;
comma
l_int|0
comma
id|S_IFCHR
op_or
id|S_IRUGO
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|stat-&gt;u.dev
op_assign
id|MKDEV
c_func
(paren
id|major
comma
l_int|1
)paren
suffix:semicolon
id|_devfs_append_entry
c_func
(paren
id|root_entry
comma
id|stat
comma
l_int|NULL
)paren
suffix:semicolon
macro_line|#endif
id|err
op_assign
id|register_filesystem
c_func
(paren
op_amp
id|devfs_fs_type
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*  End Function init_devfs_fs  */
DECL|function|mount_devfs_fs
r_void
id|__init
id|mount_devfs_fs
c_func
(paren
r_void
)paren
(brace
r_int
id|err
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|boot_options
op_amp
id|OPTION_MOUNT
)paren
)paren
r_return
suffix:semicolon
id|err
op_assign
id|do_mount
c_func
(paren
l_string|&quot;none&quot;
comma
l_string|&quot;/dev&quot;
comma
l_string|&quot;devfs&quot;
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_eq
l_int|0
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Mounted devfs on /dev&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|PRINTK
c_func
(paren
l_string|&quot;(): unable to mount devfs, err: %d&bslash;n&quot;
comma
id|err
)paren
suffix:semicolon
)brace
multiline_comment|/*  End Function mount_devfs_fs  */
id|module_init
c_func
(paren
id|init_devfs_fs
)paren
eof
