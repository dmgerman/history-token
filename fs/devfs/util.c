multiline_comment|/*  devfs (Device FileSystem) utilities.&n;&n;    Copyright (C) 1999-2002  Richard Gooch&n;&n;    This library is free software; you can redistribute it and/or&n;    modify it under the terms of the GNU Library General Public&n;    License as published by the Free Software Foundation; either&n;    version 2 of the License, or (at your option) any later version.&n;&n;    This library is distributed in the hope that it will be useful,&n;    but WITHOUT ANY WARRANTY; without even the implied warranty of&n;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU&n;    Library General Public License for more details.&n;&n;    You should have received a copy of the GNU Library General Public&n;    License along with this library; if not, write to the Free&n;    Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.&n;&n;    Richard Gooch may be reached by email at  rgooch@atnf.csiro.au&n;    The postal address is:&n;      Richard Gooch, c/o ATNF, P. O. Box 76, Epping, N.S.W., 2121, Australia.&n;&n;    ChangeLog&n;&n;    19991031   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;               Created.&n;    19991103   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;               Created &lt;_devfs_convert_name&gt; and supported SCSI and IDE CD-ROMs&n;    20000203   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;               Changed operations pointer type to void *.&n;    20000621   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;               Changed interface to &lt;devfs_register_series&gt;.&n;    20000622   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;               Took account of interface change to &lt;devfs_mk_symlink&gt;.&n;               Took account of interface change to &lt;devfs_mk_dir&gt;.&n;    20010519   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;               Documentation cleanup.&n;    20010709   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;               Created &lt;devfs_*alloc_major&gt; and &lt;devfs_*alloc_devnum&gt;.&n;    20010710   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;               Created &lt;devfs_*alloc_unique_number&gt;.&n;    20010730   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;               Documentation typo fix.&n;    20010806   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;               Made &lt;block_semaphore&gt; and &lt;char_semaphore&gt; private.&n;    20010813   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;               Fixed bug in &lt;devfs_alloc_unique_number&gt;: limited to 128 numbers&n;    20010818   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;               Updated major masks up to Linus&squot; &quot;no new majors&quot; proclamation.&n;&t;       Block: were 126 now 122 free, char: were 26 now 19 free.&n;    20020324   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;               Fixed bug in &lt;devfs_alloc_unique_number&gt;: was clearing beyond&n;&t;       bitfield.&n;    20020326   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;               Fixed bitfield data type for &lt;devfs_*alloc_devnum&gt;.&n;               Made major bitfield type and initialiser 64 bit safe.&n;*/
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/devfs_fs_kernel.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/vmalloc.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
multiline_comment|/*  Private functions follow  */
multiline_comment|/**&n; *&t;devfs_register_tape - Register a tape device in the &quot;/dev/tapes&quot; hierarchy.&n; *&t;@de: Any tape device entry in the device directory.&n; */
DECL|function|devfs_register_tape
r_void
id|devfs_register_tape
(paren
id|devfs_handle_t
id|de
)paren
(brace
r_int
id|pos
suffix:semicolon
id|devfs_handle_t
id|parent
comma
id|slave
suffix:semicolon
r_char
id|name
(braket
l_int|16
)braket
comma
id|dest
(braket
l_int|64
)braket
suffix:semicolon
r_static
r_int
r_int
id|tape_counter
suffix:semicolon
r_static
id|devfs_handle_t
id|tape_dir
suffix:semicolon
r_if
c_cond
(paren
id|tape_dir
op_eq
l_int|NULL
)paren
id|tape_dir
op_assign
id|devfs_mk_dir
(paren
l_int|NULL
comma
l_string|&quot;tapes&quot;
comma
l_int|NULL
)paren
suffix:semicolon
id|parent
op_assign
id|devfs_get_parent
(paren
id|de
)paren
suffix:semicolon
id|pos
op_assign
id|devfs_generate_path
(paren
id|parent
comma
id|dest
op_plus
l_int|3
comma
r_sizeof
id|dest
op_minus
l_int|3
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pos
OL
l_int|0
)paren
r_return
suffix:semicolon
id|strncpy
(paren
id|dest
op_plus
id|pos
comma
l_string|&quot;../&quot;
comma
l_int|3
)paren
suffix:semicolon
id|sprintf
(paren
id|name
comma
l_string|&quot;tape%u&quot;
comma
id|tape_counter
op_increment
)paren
suffix:semicolon
id|devfs_mk_symlink
(paren
id|tape_dir
comma
id|name
comma
id|DEVFS_FL_DEFAULT
comma
id|dest
op_plus
id|pos
comma
op_amp
id|slave
comma
l_int|NULL
)paren
suffix:semicolon
id|devfs_auto_unregister
(paren
id|de
comma
id|slave
)paren
suffix:semicolon
)brace
multiline_comment|/*  End Function devfs_register_tape  */
DECL|variable|devfs_register_tape
id|EXPORT_SYMBOL
c_func
(paren
id|devfs_register_tape
)paren
suffix:semicolon
multiline_comment|/**&n; *&t;devfs_register_series - Register a sequence of device entries.&n; *&t;@dir: The handle to the parent devfs directory entry. If this is %NULL&n; *&t;&t;the new names are relative to the root of the devfs.&n; *&t;@format: The printf-style format string. A single &quot;&bslash;%u&quot; is allowed.&n; *&t;@num_entries: The number of entries to register.&n; *&t;@flags: A set of bitwise-ORed flags (DEVFS_FL_*).&n; *&t;@major: The major number. Not needed for regular files.&n; *&t;@minor_start: The starting minor number. Not needed for regular files.&n; *&t;@mode: The default file mode.&n; *&t;@ops: The &amp;file_operations or &amp;block_device_operations structure.&n; *&t;&t;This must not be externally deallocated.&n; *&t;@info: An arbitrary pointer which will be written to the private_data&n; *&t;&t;field of the &amp;file structure passed to the device driver. You&n; *&t;&t;can set this to whatever you like, and change it once the file&n; *&t;&t;is opened (the next file opened will not see this change).&n; */
DECL|function|devfs_register_series
r_void
id|devfs_register_series
(paren
id|devfs_handle_t
id|dir
comma
r_const
r_char
op_star
id|format
comma
r_int
r_int
id|num_entries
comma
r_int
r_int
id|flags
comma
r_int
r_int
id|major
comma
r_int
r_int
id|minor_start
comma
id|umode_t
id|mode
comma
r_void
op_star
id|ops
comma
r_void
op_star
id|info
)paren
(brace
r_int
r_int
id|count
suffix:semicolon
r_char
id|devname
(braket
l_int|128
)braket
suffix:semicolon
r_for
c_loop
(paren
id|count
op_assign
l_int|0
suffix:semicolon
id|count
OL
id|num_entries
suffix:semicolon
op_increment
id|count
)paren
(brace
id|sprintf
(paren
id|devname
comma
id|format
comma
id|count
)paren
suffix:semicolon
id|devfs_register
(paren
id|dir
comma
id|devname
comma
id|flags
comma
id|major
comma
id|minor_start
op_plus
id|count
comma
id|mode
comma
id|ops
comma
id|info
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*  End Function devfs_register_series  */
DECL|variable|devfs_register_series
id|EXPORT_SYMBOL
c_func
(paren
id|devfs_register_series
)paren
suffix:semicolon
DECL|struct|major_list
r_struct
id|major_list
(brace
DECL|member|lock
id|spinlock_t
id|lock
suffix:semicolon
DECL|member|bits
r_int
r_int
id|bits
(braket
l_int|256
op_div
id|BITS_PER_LONG
)braket
suffix:semicolon
)brace
suffix:semicolon
macro_line|#if BITS_PER_LONG == 32
DECL|macro|INITIALISER64
macro_line|#  define INITIALISER64(low,high) (low), (high)
macro_line|#else
DECL|macro|INITIALISER64
macro_line|#  define INITIALISER64(low,high) ( (high) &lt;&lt; 32 | (low) )
macro_line|#endif
multiline_comment|/*  Block majors already assigned:&n;    0-3, 7-9, 11-63, 65-99, 101-113, 120-127, 199, 201, 240-255&n;    Total free: 122&n;*/
DECL|variable|block_major_list
r_static
r_struct
id|major_list
id|block_major_list
op_assign
(brace
id|SPIN_LOCK_UNLOCKED
comma
(brace
id|INITIALISER64
(paren
l_int|0xfffffb8f
comma
l_int|0xffffffff
)paren
comma
multiline_comment|/*  Majors 0-31,    32-63    */
id|INITIALISER64
(paren
l_int|0xfffffffe
comma
l_int|0xff03ffef
)paren
comma
multiline_comment|/*  Majors 64-95,   96-127   */
id|INITIALISER64
(paren
l_int|0x00000000
comma
l_int|0x00000000
)paren
comma
multiline_comment|/*  Majors 128-159, 160-191  */
id|INITIALISER64
(paren
l_int|0x00000280
comma
l_int|0xffff0000
)paren
comma
multiline_comment|/*  Majors 192-223, 224-255  */
)brace
)brace
suffix:semicolon
multiline_comment|/*  Char majors already assigned:&n;    0-7, 9-151, 154-158, 160-211, 216-221, 224-230, 240-255&n;    Total free: 19&n;*/
DECL|variable|char_major_list
r_static
r_struct
id|major_list
id|char_major_list
op_assign
(brace
id|SPIN_LOCK_UNLOCKED
comma
(brace
id|INITIALISER64
(paren
l_int|0xfffffeff
comma
l_int|0xffffffff
)paren
comma
multiline_comment|/*  Majors 0-31,    32-63    */
id|INITIALISER64
(paren
l_int|0xffffffff
comma
l_int|0xffffffff
)paren
comma
multiline_comment|/*  Majors 64-95,   96-127   */
id|INITIALISER64
(paren
l_int|0x7cffffff
comma
l_int|0xffffffff
)paren
comma
multiline_comment|/*  Majors 128-159, 160-191  */
id|INITIALISER64
(paren
l_int|0x3f0fffff
comma
l_int|0xffff007f
)paren
comma
multiline_comment|/*  Majors 192-223, 224-255  */
)brace
)brace
suffix:semicolon
multiline_comment|/**&n; *&t;devfs_alloc_major - Allocate a major number.&n; *&t;@type: The type of the major (DEVFS_SPECIAL_CHR or DEVFS_SPECIAL_BLK)&n;&n; *&t;Returns the allocated major, else -1 if none are available.&n; *&t;This routine is thread safe and does not block.&n; */
DECL|function|devfs_alloc_major
r_int
id|devfs_alloc_major
(paren
r_char
id|type
)paren
(brace
r_int
id|major
suffix:semicolon
r_struct
id|major_list
op_star
id|list
suffix:semicolon
id|list
op_assign
(paren
id|type
op_eq
id|DEVFS_SPECIAL_CHR
)paren
ques
c_cond
op_amp
id|char_major_list
suffix:colon
op_amp
id|block_major_list
suffix:semicolon
id|spin_lock
(paren
op_amp
id|list-&gt;lock
)paren
suffix:semicolon
id|major
op_assign
id|find_first_zero_bit
(paren
id|list-&gt;bits
comma
l_int|256
)paren
suffix:semicolon
r_if
c_cond
(paren
id|major
OL
l_int|256
)paren
id|__set_bit
(paren
id|major
comma
id|list-&gt;bits
)paren
suffix:semicolon
r_else
id|major
op_assign
op_minus
l_int|1
suffix:semicolon
id|spin_unlock
(paren
op_amp
id|list-&gt;lock
)paren
suffix:semicolon
r_return
id|major
suffix:semicolon
)brace
multiline_comment|/*  End Function devfs_alloc_major  */
DECL|variable|devfs_alloc_major
id|EXPORT_SYMBOL
c_func
(paren
id|devfs_alloc_major
)paren
suffix:semicolon
multiline_comment|/**&n; *&t;devfs_dealloc_major - Deallocate a major number.&n; *&t;@type: The type of the major (DEVFS_SPECIAL_CHR or DEVFS_SPECIAL_BLK)&n; *&t;@major: The major number.&n; *&t;This routine is thread safe and does not block.&n; */
DECL|function|devfs_dealloc_major
r_void
id|devfs_dealloc_major
(paren
r_char
id|type
comma
r_int
id|major
)paren
(brace
r_int
id|was_set
suffix:semicolon
r_struct
id|major_list
op_star
id|list
suffix:semicolon
r_if
c_cond
(paren
id|major
OL
l_int|0
)paren
r_return
suffix:semicolon
id|list
op_assign
(paren
id|type
op_eq
id|DEVFS_SPECIAL_CHR
)paren
ques
c_cond
op_amp
id|char_major_list
suffix:colon
op_amp
id|block_major_list
suffix:semicolon
id|spin_lock
(paren
op_amp
id|list-&gt;lock
)paren
suffix:semicolon
id|was_set
op_assign
id|__test_and_clear_bit
(paren
id|major
comma
id|list-&gt;bits
)paren
suffix:semicolon
id|spin_unlock
(paren
op_amp
id|list-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|was_set
)paren
id|printk
(paren
id|KERN_ERR
id|__FUNCTION__
l_string|&quot;(): major %d was already free&bslash;n&quot;
comma
id|major
)paren
suffix:semicolon
)brace
multiline_comment|/*  End Function devfs_dealloc_major  */
DECL|variable|devfs_dealloc_major
id|EXPORT_SYMBOL
c_func
(paren
id|devfs_dealloc_major
)paren
suffix:semicolon
DECL|struct|minor_list
r_struct
id|minor_list
(brace
DECL|member|major
r_int
id|major
suffix:semicolon
DECL|member|bits
r_int
r_int
id|bits
(braket
l_int|256
op_div
id|BITS_PER_LONG
)braket
suffix:semicolon
DECL|member|next
r_struct
id|minor_list
op_star
id|next
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|device_list
r_struct
id|device_list
(brace
DECL|member|first
DECL|member|last
r_struct
id|minor_list
op_star
id|first
comma
op_star
id|last
suffix:semicolon
DECL|member|none_free
r_int
id|none_free
suffix:semicolon
)brace
suffix:semicolon
r_static
id|DECLARE_MUTEX
(paren
id|block_semaphore
)paren
suffix:semicolon
DECL|variable|block_list
r_static
r_struct
id|device_list
id|block_list
suffix:semicolon
r_static
id|DECLARE_MUTEX
(paren
id|char_semaphore
)paren
suffix:semicolon
DECL|variable|char_list
r_static
r_struct
id|device_list
id|char_list
suffix:semicolon
multiline_comment|/**&n; *&t;devfs_alloc_devnum - Allocate a device number.&n; *&t;@type: The type (DEVFS_SPECIAL_CHR or DEVFS_SPECIAL_BLK).&n; *&n; *&t;Returns the allocated device number, else NODEV if none are available.&n; *&t;This routine is thread safe and may block.&n; */
DECL|function|devfs_alloc_devnum
id|kdev_t
id|devfs_alloc_devnum
(paren
r_char
id|type
)paren
(brace
r_int
id|minor
suffix:semicolon
r_struct
id|semaphore
op_star
id|semaphore
suffix:semicolon
r_struct
id|device_list
op_star
id|list
suffix:semicolon
r_struct
id|minor_list
op_star
id|entry
suffix:semicolon
r_if
c_cond
(paren
id|type
op_eq
id|DEVFS_SPECIAL_CHR
)paren
(brace
id|semaphore
op_assign
op_amp
id|char_semaphore
suffix:semicolon
id|list
op_assign
op_amp
id|char_list
suffix:semicolon
)brace
r_else
(brace
id|semaphore
op_assign
op_amp
id|block_semaphore
suffix:semicolon
id|list
op_assign
op_amp
id|block_list
suffix:semicolon
)brace
r_if
c_cond
(paren
id|list-&gt;none_free
)paren
r_return
id|NODEV
suffix:semicolon
multiline_comment|/*  Fast test  */
id|down
(paren
id|semaphore
)paren
suffix:semicolon
r_if
c_cond
(paren
id|list-&gt;none_free
)paren
(brace
id|up
(paren
id|semaphore
)paren
suffix:semicolon
r_return
id|NODEV
suffix:semicolon
)brace
r_for
c_loop
(paren
id|entry
op_assign
id|list-&gt;first
suffix:semicolon
id|entry
op_ne
l_int|NULL
suffix:semicolon
id|entry
op_assign
id|entry-&gt;next
)paren
(brace
id|minor
op_assign
id|find_first_zero_bit
(paren
id|entry-&gt;bits
comma
l_int|256
)paren
suffix:semicolon
r_if
c_cond
(paren
id|minor
op_ge
l_int|256
)paren
r_continue
suffix:semicolon
id|__set_bit
(paren
id|minor
comma
id|entry-&gt;bits
)paren
suffix:semicolon
id|up
(paren
id|semaphore
)paren
suffix:semicolon
r_return
id|mk_kdev
(paren
id|entry-&gt;major
comma
id|minor
)paren
suffix:semicolon
)brace
multiline_comment|/*  Need to allocate a new major  */
r_if
c_cond
(paren
(paren
id|entry
op_assign
id|kmalloc
(paren
r_sizeof
op_star
id|entry
comma
id|GFP_KERNEL
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|list-&gt;none_free
op_assign
l_int|1
suffix:semicolon
id|up
(paren
id|semaphore
)paren
suffix:semicolon
r_return
id|NODEV
suffix:semicolon
)brace
id|memset
(paren
id|entry
comma
l_int|0
comma
r_sizeof
op_star
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|entry-&gt;major
op_assign
id|devfs_alloc_major
(paren
id|type
)paren
)paren
OL
l_int|0
)paren
(brace
id|list-&gt;none_free
op_assign
l_int|1
suffix:semicolon
id|up
(paren
id|semaphore
)paren
suffix:semicolon
id|kfree
(paren
id|entry
)paren
suffix:semicolon
r_return
id|NODEV
suffix:semicolon
)brace
id|__set_bit
(paren
l_int|0
comma
id|entry-&gt;bits
)paren
suffix:semicolon
r_if
c_cond
(paren
id|list-&gt;first
op_eq
l_int|NULL
)paren
id|list-&gt;first
op_assign
id|entry
suffix:semicolon
r_else
id|list-&gt;last-&gt;next
op_assign
id|entry
suffix:semicolon
id|list-&gt;last
op_assign
id|entry
suffix:semicolon
id|up
(paren
id|semaphore
)paren
suffix:semicolon
r_return
id|mk_kdev
(paren
id|entry-&gt;major
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*  End Function devfs_alloc_devnum  */
DECL|variable|devfs_alloc_devnum
id|EXPORT_SYMBOL
c_func
(paren
id|devfs_alloc_devnum
)paren
suffix:semicolon
multiline_comment|/**&n; *&t;devfs_dealloc_devnum - Dellocate a device number.&n; *&t;@type: The type (DEVFS_SPECIAL_CHR or DEVFS_SPECIAL_BLK).&n; *&t;@devnum: The device number.&n; *&n; *&t;This routine is thread safe and does not block.&n; */
DECL|function|devfs_dealloc_devnum
r_void
id|devfs_dealloc_devnum
(paren
r_char
id|type
comma
id|kdev_t
id|devnum
)paren
(brace
r_int
id|major
comma
id|minor
suffix:semicolon
r_struct
id|semaphore
op_star
id|semaphore
suffix:semicolon
r_struct
id|device_list
op_star
id|list
suffix:semicolon
r_struct
id|minor_list
op_star
id|entry
suffix:semicolon
r_if
c_cond
(paren
id|kdev_none
(paren
id|devnum
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|type
op_eq
id|DEVFS_SPECIAL_CHR
)paren
(brace
id|semaphore
op_assign
op_amp
id|char_semaphore
suffix:semicolon
id|list
op_assign
op_amp
id|char_list
suffix:semicolon
)brace
r_else
(brace
id|semaphore
op_assign
op_amp
id|block_semaphore
suffix:semicolon
id|list
op_assign
op_amp
id|block_list
suffix:semicolon
)brace
id|major
op_assign
id|major
(paren
id|devnum
)paren
suffix:semicolon
id|minor
op_assign
id|minor
(paren
id|devnum
)paren
suffix:semicolon
id|down
(paren
id|semaphore
)paren
suffix:semicolon
r_for
c_loop
(paren
id|entry
op_assign
id|list-&gt;first
suffix:semicolon
id|entry
op_ne
l_int|NULL
suffix:semicolon
id|entry
op_assign
id|entry-&gt;next
)paren
(brace
r_int
id|was_set
suffix:semicolon
r_if
c_cond
(paren
id|entry-&gt;major
op_ne
id|major
)paren
r_continue
suffix:semicolon
id|was_set
op_assign
id|__test_and_clear_bit
(paren
id|minor
comma
id|entry-&gt;bits
)paren
suffix:semicolon
r_if
c_cond
(paren
id|was_set
)paren
id|list-&gt;none_free
op_assign
l_int|0
suffix:semicolon
id|up
(paren
id|semaphore
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|was_set
)paren
id|printk
(paren
id|KERN_ERR
id|__FUNCTION__
l_string|&quot;(): device %s was already free&bslash;n&quot;
comma
id|kdevname
(paren
id|devnum
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|up
(paren
id|semaphore
)paren
suffix:semicolon
id|printk
(paren
id|KERN_ERR
id|__FUNCTION__
l_string|&quot;(): major for %s not previously allocated&bslash;n&quot;
comma
id|kdevname
(paren
id|devnum
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*  End Function devfs_dealloc_devnum  */
DECL|variable|devfs_dealloc_devnum
id|EXPORT_SYMBOL
c_func
(paren
id|devfs_dealloc_devnum
)paren
suffix:semicolon
multiline_comment|/**&n; *&t;devfs_alloc_unique_number - Allocate a unique (positive) number.&n; *&t;@space: The number space to allocate from.&n; *&n; *&t;Returns the allocated unique number, else a negative error code.&n; *&t;This routine is thread safe and may block.&n; */
DECL|function|devfs_alloc_unique_number
r_int
id|devfs_alloc_unique_number
(paren
r_struct
id|unique_numspace
op_star
id|space
)paren
(brace
r_int
id|number
suffix:semicolon
r_int
r_int
id|length
suffix:semicolon
multiline_comment|/*  Get around stupid lack of semaphore initialiser  */
id|spin_lock
(paren
op_amp
id|space-&gt;init_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|space-&gt;sem_initialised
)paren
(brace
id|sema_init
(paren
op_amp
id|space-&gt;semaphore
comma
l_int|1
)paren
suffix:semicolon
id|space-&gt;sem_initialised
op_assign
l_int|1
suffix:semicolon
)brace
id|spin_unlock
(paren
op_amp
id|space-&gt;init_lock
)paren
suffix:semicolon
id|down
(paren
op_amp
id|space-&gt;semaphore
)paren
suffix:semicolon
r_if
c_cond
(paren
id|space-&gt;num_free
OL
l_int|1
)paren
(brace
r_void
op_star
id|bits
suffix:semicolon
r_if
c_cond
(paren
id|space-&gt;length
OL
l_int|16
)paren
id|length
op_assign
l_int|16
suffix:semicolon
r_else
id|length
op_assign
id|space-&gt;length
op_lshift
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bits
op_assign
id|vmalloc
(paren
id|length
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|up
(paren
op_amp
id|space-&gt;semaphore
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_if
c_cond
(paren
id|space-&gt;bits
op_ne
l_int|NULL
)paren
(brace
id|memcpy
(paren
id|bits
comma
id|space-&gt;bits
comma
id|space-&gt;length
)paren
suffix:semicolon
id|vfree
(paren
id|space-&gt;bits
)paren
suffix:semicolon
)brace
id|space-&gt;num_free
op_assign
(paren
id|length
op_minus
id|space-&gt;length
)paren
op_lshift
l_int|3
suffix:semicolon
id|space-&gt;bits
op_assign
id|bits
suffix:semicolon
id|memset
(paren
id|bits
op_plus
id|space-&gt;length
comma
l_int|0
comma
id|length
op_minus
id|space-&gt;length
)paren
suffix:semicolon
id|space-&gt;length
op_assign
id|length
suffix:semicolon
)brace
id|number
op_assign
id|find_first_zero_bit
(paren
id|space-&gt;bits
comma
id|space-&gt;length
op_lshift
l_int|3
)paren
suffix:semicolon
op_decrement
id|space-&gt;num_free
suffix:semicolon
id|__set_bit
(paren
id|number
comma
id|space-&gt;bits
)paren
suffix:semicolon
id|up
(paren
op_amp
id|space-&gt;semaphore
)paren
suffix:semicolon
r_return
id|number
suffix:semicolon
)brace
multiline_comment|/*  End Function devfs_alloc_unique_number  */
DECL|variable|devfs_alloc_unique_number
id|EXPORT_SYMBOL
c_func
(paren
id|devfs_alloc_unique_number
)paren
suffix:semicolon
multiline_comment|/**&n; *&t;devfs_dealloc_unique_number - Deallocate a unique (positive) number.&n; *&t;@space: The number space to deallocate from.&n; *&t;@number: The number to deallocate.&n; *&n; *&t;This routine is thread safe and may block.&n; */
DECL|function|devfs_dealloc_unique_number
r_void
id|devfs_dealloc_unique_number
(paren
r_struct
id|unique_numspace
op_star
id|space
comma
r_int
id|number
)paren
(brace
r_int
id|was_set
suffix:semicolon
r_if
c_cond
(paren
id|number
OL
l_int|0
)paren
r_return
suffix:semicolon
id|down
(paren
op_amp
id|space-&gt;semaphore
)paren
suffix:semicolon
id|was_set
op_assign
id|__test_and_clear_bit
(paren
id|number
comma
id|space-&gt;bits
)paren
suffix:semicolon
r_if
c_cond
(paren
id|was_set
)paren
op_increment
id|space-&gt;num_free
suffix:semicolon
id|up
(paren
op_amp
id|space-&gt;semaphore
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|was_set
)paren
id|printk
(paren
id|KERN_ERR
id|__FUNCTION__
l_string|&quot;(): number %d was already free&bslash;n&quot;
comma
id|number
)paren
suffix:semicolon
)brace
multiline_comment|/*  End Function devfs_dealloc_unique_number  */
DECL|variable|devfs_dealloc_unique_number
id|EXPORT_SYMBOL
c_func
(paren
id|devfs_dealloc_unique_number
)paren
suffix:semicolon
eof
