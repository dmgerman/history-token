multiline_comment|/*  devfs (Device FileSystem) utilities.&n;&n;    Copyright (C) 1999-2002  Richard Gooch&n;&n;    This library is free software; you can redistribute it and/or&n;    modify it under the terms of the GNU Library General Public&n;    License as published by the Free Software Foundation; either&n;    version 2 of the License, or (at your option) any later version.&n;&n;    This library is distributed in the hope that it will be useful,&n;    but WITHOUT ANY WARRANTY; without even the implied warranty of&n;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU&n;    Library General Public License for more details.&n;&n;    You should have received a copy of the GNU Library General Public&n;    License along with this library; if not, write to the Free&n;    Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.&n;&n;    Richard Gooch may be reached by email at  rgooch@atnf.csiro.au&n;    The postal address is:&n;      Richard Gooch, c/o ATNF, P. O. Box 76, Epping, N.S.W., 2121, Australia.&n;&n;    ChangeLog&n;&n;    19991031   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;               Created.&n;    19991103   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;               Created &lt;_devfs_convert_name&gt; and supported SCSI and IDE CD-ROMs&n;    20000203   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;               Changed operations pointer type to void *.&n;    20000621   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;               Changed interface to &lt;devfs_register_series&gt;.&n;    20000622   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;               Took account of interface change to &lt;devfs_mk_symlink&gt;.&n;               Took account of interface change to &lt;devfs_mk_dir&gt;.&n;    20010519   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;               Documentation cleanup.&n;    20010709   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;               Created &lt;devfs_*alloc_major&gt; and &lt;devfs_*alloc_devnum&gt;.&n;    20010710   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;               Created &lt;devfs_*alloc_unique_number&gt;.&n;    20010730   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;               Documentation typo fix.&n;    20010806   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;               Made &lt;block_semaphore&gt; and &lt;char_semaphore&gt; private.&n;    20010813   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;               Fixed bug in &lt;devfs_alloc_unique_number&gt;: limited to 128 numbers&n;    20010818   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;               Updated major masks up to Linus&squot; &quot;no new majors&quot; proclamation.&n;&t;       Block: were 126 now 122 free, char: were 26 now 19 free.&n;    20020324   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;               Fixed bug in &lt;devfs_alloc_unique_number&gt;: was clearing beyond&n;&t;       bitfield.&n;    20020326   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;               Fixed bitfield data type for &lt;devfs_*alloc_devnum&gt;.&n;               Made major bitfield type and initialiser 64 bit safe.&n;    20020413   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;               Fixed shift warning on 64 bit machines.&n;    20020428   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;               Copied and used macro for error messages from fs/devfs/base.c &n;    20021013   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;               Documentation fix.&n;    20030101   Adam J. Richter &lt;adam@yggdrasil.com&gt;&n;               Eliminate DEVFS_SPECIAL_{CHR,BLK}.  Use mode_t instead.&n;    20030106   Christoph Hellwig &lt;hch@infradead.org&gt;&n;               Rewrite devfs_{,de}alloc_devnum to look like C code.&n;*/
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/devfs_fs_kernel.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/vmalloc.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &quot;internal.h&quot;
DECL|macro|PRINTK
mdefine_line|#define PRINTK(format, args...) &bslash;&n;   {printk (KERN_ERR &quot;%s&quot; format, __FUNCTION__ , ## args);}
multiline_comment|/*  Private functions follow  */
multiline_comment|/**&n; *&t;devfs_register_tape - Register a tape device in the &quot;/dev/tapes&quot; hierarchy.&n; *&t;@de: Any tape device entry in the device directory.&n; */
DECL|function|devfs_register_tape
r_int
id|devfs_register_tape
(paren
id|devfs_handle_t
id|de
)paren
(brace
r_int
id|pos
suffix:semicolon
id|devfs_handle_t
id|slave
suffix:semicolon
r_char
id|name
(braket
l_int|32
)braket
comma
id|dest
(braket
l_int|64
)braket
suffix:semicolon
r_static
r_int
r_int
id|tape_counter
suffix:semicolon
r_int
id|n
op_assign
id|tape_counter
op_increment
suffix:semicolon
id|pos
op_assign
id|devfs_generate_path
(paren
id|de
comma
id|dest
op_plus
l_int|3
comma
r_sizeof
id|dest
op_minus
l_int|3
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pos
OL
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|strncpy
(paren
id|dest
op_plus
id|pos
comma
l_string|&quot;../&quot;
comma
l_int|3
)paren
suffix:semicolon
id|sprintf
(paren
id|name
comma
l_string|&quot;tapes/tape%u&quot;
comma
id|n
)paren
suffix:semicolon
id|devfs_mk_symlink
(paren
l_int|NULL
comma
id|name
comma
id|DEVFS_FL_DEFAULT
comma
id|dest
op_plus
id|pos
comma
op_amp
id|slave
comma
l_int|NULL
)paren
suffix:semicolon
r_return
id|n
suffix:semicolon
)brace
multiline_comment|/*  End Function devfs_register_tape  */
DECL|variable|devfs_register_tape
id|EXPORT_SYMBOL
c_func
(paren
id|devfs_register_tape
)paren
suffix:semicolon
DECL|function|devfs_unregister_tape
r_void
id|devfs_unregister_tape
c_func
(paren
r_int
id|num
)paren
(brace
r_if
c_cond
(paren
id|num
op_ge
l_int|0
)paren
id|devfs_remove
c_func
(paren
l_string|&quot;tapes/tape%u&quot;
comma
id|num
)paren
suffix:semicolon
)brace
DECL|variable|devfs_unregister_tape
id|EXPORT_SYMBOL
c_func
(paren
id|devfs_unregister_tape
)paren
suffix:semicolon
DECL|struct|major_list
r_struct
id|major_list
(brace
DECL|member|lock
id|spinlock_t
id|lock
suffix:semicolon
DECL|member|bits
r_int
r_int
id|bits
(braket
l_int|256
op_div
id|BITS_PER_LONG
)braket
suffix:semicolon
)brace
suffix:semicolon
macro_line|#if BITS_PER_LONG == 32
DECL|macro|INITIALISER64
macro_line|#  define INITIALISER64(low,high) (low), (high)
macro_line|#else
DECL|macro|INITIALISER64
macro_line|#  define INITIALISER64(low,high) ( (unsigned long) (high) &lt;&lt; 32 | (low) )
macro_line|#endif
multiline_comment|/*  Block majors already assigned:&n;    0-3, 7-9, 11-63, 65-99, 101-113, 120-127, 199, 201, 240-255&n;    Total free: 122&n;*/
DECL|variable|block_major_list
r_static
r_struct
id|major_list
id|block_major_list
op_assign
(brace
id|SPIN_LOCK_UNLOCKED
comma
(brace
id|INITIALISER64
(paren
l_int|0xfffffb8f
comma
l_int|0xffffffff
)paren
comma
multiline_comment|/*  Majors 0-31,    32-63    */
id|INITIALISER64
(paren
l_int|0xfffffffe
comma
l_int|0xff03ffef
)paren
comma
multiline_comment|/*  Majors 64-95,   96-127   */
id|INITIALISER64
(paren
l_int|0x00000000
comma
l_int|0x00000000
)paren
comma
multiline_comment|/*  Majors 128-159, 160-191  */
id|INITIALISER64
(paren
l_int|0x00000280
comma
l_int|0xffff0000
)paren
comma
multiline_comment|/*  Majors 192-223, 224-255  */
)brace
)brace
suffix:semicolon
multiline_comment|/*  Char majors already assigned:&n;    0-7, 9-151, 154-158, 160-211, 216-221, 224-230, 240-255&n;    Total free: 19&n;*/
DECL|variable|char_major_list
r_static
r_struct
id|major_list
id|char_major_list
op_assign
(brace
id|SPIN_LOCK_UNLOCKED
comma
(brace
id|INITIALISER64
(paren
l_int|0xfffffeff
comma
l_int|0xffffffff
)paren
comma
multiline_comment|/*  Majors 0-31,    32-63    */
id|INITIALISER64
(paren
l_int|0xffffffff
comma
l_int|0xffffffff
)paren
comma
multiline_comment|/*  Majors 64-95,   96-127   */
id|INITIALISER64
(paren
l_int|0x7cffffff
comma
l_int|0xffffffff
)paren
comma
multiline_comment|/*  Majors 128-159, 160-191  */
id|INITIALISER64
(paren
l_int|0x3f0fffff
comma
l_int|0xffff007f
)paren
comma
multiline_comment|/*  Majors 192-223, 224-255  */
)brace
)brace
suffix:semicolon
multiline_comment|/**&n; *&t;devfs_alloc_major - Allocate a major number.&n; *&t;@mode: The file mode (must be block device or character device).&n; *&t;Returns the allocated major, else -1 if none are available.&n; *&t;This routine is thread safe and does not block.&n; */
DECL|struct|minor_list
r_struct
id|minor_list
(brace
DECL|member|major
r_int
id|major
suffix:semicolon
DECL|member|bits
r_int
r_int
id|bits
(braket
l_int|256
op_div
id|BITS_PER_LONG
)braket
suffix:semicolon
DECL|member|next
r_struct
id|minor_list
op_star
id|next
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|device_list
r_static
r_struct
id|device_list
(brace
DECL|member|first
r_struct
id|minor_list
op_star
id|first
suffix:semicolon
DECL|member|last
r_struct
id|minor_list
op_star
id|last
suffix:semicolon
DECL|member|none_free
r_int
id|none_free
suffix:semicolon
DECL|variable|block_list
DECL|variable|char_list
)brace
id|block_list
comma
id|char_list
suffix:semicolon
r_static
id|DECLARE_MUTEX
c_func
(paren
id|device_list_mutex
)paren
suffix:semicolon
multiline_comment|/**&n; *&t;devfs_alloc_devnum - Allocate a device number.&n; *&t;@mode: The file mode (must be block device or character device).&n; *&n; *&t;Returns the allocated device number, else NODEV if none are available.&n; *&t;This routine is thread safe and may block.&n; */
DECL|function|devfs_alloc_devnum
id|dev_t
id|devfs_alloc_devnum
c_func
(paren
id|umode_t
id|mode
)paren
(brace
r_struct
id|device_list
op_star
id|list
suffix:semicolon
r_struct
id|major_list
op_star
id|major_list
suffix:semicolon
r_struct
id|minor_list
op_star
id|entry
suffix:semicolon
r_int
id|minor
suffix:semicolon
r_if
c_cond
(paren
id|S_ISCHR
c_func
(paren
id|mode
)paren
)paren
(brace
id|major_list
op_assign
op_amp
id|char_major_list
suffix:semicolon
id|list
op_assign
op_amp
id|char_list
suffix:semicolon
)brace
r_else
(brace
id|major_list
op_assign
op_amp
id|block_major_list
suffix:semicolon
id|list
op_assign
op_amp
id|block_list
suffix:semicolon
)brace
id|down
c_func
(paren
op_amp
id|device_list_mutex
)paren
suffix:semicolon
r_if
c_cond
(paren
id|list-&gt;none_free
)paren
r_goto
id|out_unlock
suffix:semicolon
r_for
c_loop
(paren
id|entry
op_assign
id|list-&gt;first
suffix:semicolon
id|entry
suffix:semicolon
id|entry
op_assign
id|entry-&gt;next
)paren
(brace
id|minor
op_assign
id|find_first_zero_bit
(paren
id|entry-&gt;bits
comma
l_int|256
)paren
suffix:semicolon
r_if
c_cond
(paren
id|minor
op_ge
l_int|256
)paren
r_continue
suffix:semicolon
r_goto
id|out_done
suffix:semicolon
)brace
multiline_comment|/*  Need to allocate a new major  */
id|entry
op_assign
id|kmalloc
(paren
r_sizeof
op_star
id|entry
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|entry
)paren
r_goto
id|out_full
suffix:semicolon
id|memset
c_func
(paren
id|entry
comma
l_int|0
comma
r_sizeof
op_star
id|entry
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|major_list-&gt;lock
)paren
suffix:semicolon
id|entry-&gt;major
op_assign
id|find_first_zero_bit
c_func
(paren
id|major_list-&gt;bits
comma
l_int|256
)paren
suffix:semicolon
r_if
c_cond
(paren
id|entry-&gt;major
op_ge
l_int|256
)paren
(brace
id|spin_unlock
c_func
(paren
op_amp
id|major_list-&gt;lock
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|entry
)paren
suffix:semicolon
r_goto
id|out_full
suffix:semicolon
)brace
id|__set_bit
c_func
(paren
id|entry-&gt;major
comma
id|major_list-&gt;bits
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|major_list-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list-&gt;first
)paren
id|list-&gt;first
op_assign
id|entry
suffix:semicolon
r_else
id|list-&gt;last-&gt;next
op_assign
id|entry
suffix:semicolon
id|list-&gt;last
op_assign
id|entry
suffix:semicolon
id|minor
op_assign
l_int|0
suffix:semicolon
id|out_done
suffix:colon
id|__set_bit
c_func
(paren
id|minor
comma
id|entry-&gt;bits
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|device_list_mutex
)paren
suffix:semicolon
r_return
id|MKDEV
c_func
(paren
id|entry-&gt;major
comma
id|minor
)paren
suffix:semicolon
id|out_full
suffix:colon
id|list-&gt;none_free
op_assign
l_int|1
suffix:semicolon
id|out_unlock
suffix:colon
id|up
c_func
(paren
op_amp
id|device_list_mutex
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;devfs_dealloc_devnum - Dellocate a device number.&n; *&t;@mode: The file mode (must be block device or character device).&n; *&t;@devnum: The device number.&n; *&n; *&t;This routine is thread safe and may block.&n; */
DECL|function|devfs_dealloc_devnum
r_void
id|devfs_dealloc_devnum
c_func
(paren
id|umode_t
id|mode
comma
id|dev_t
id|devnum
)paren
(brace
r_struct
id|device_list
op_star
id|list
op_assign
id|S_ISCHR
c_func
(paren
id|mode
)paren
ques
c_cond
op_amp
id|char_list
suffix:colon
op_amp
id|block_list
suffix:semicolon
r_struct
id|minor_list
op_star
id|entry
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|devnum
)paren
r_return
suffix:semicolon
id|down
c_func
(paren
op_amp
id|device_list_mutex
)paren
suffix:semicolon
r_for
c_loop
(paren
id|entry
op_assign
id|list-&gt;first
suffix:semicolon
id|entry
suffix:semicolon
id|entry
op_assign
id|entry-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|entry-&gt;major
op_eq
id|MAJOR
c_func
(paren
id|devnum
)paren
)paren
(brace
r_if
c_cond
(paren
id|__test_and_clear_bit
c_func
(paren
id|MINOR
c_func
(paren
id|devnum
)paren
comma
id|entry-&gt;bits
)paren
)paren
id|list-&gt;none_free
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|up
c_func
(paren
op_amp
id|device_list_mutex
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;devfs_alloc_unique_number - Allocate a unique (positive) number.&n; *&t;@space: The number space to allocate from.&n; *&n; *&t;Returns the allocated unique number, else a negative error code.&n; *&t;This routine is thread safe and may block.&n; */
DECL|function|devfs_alloc_unique_number
r_int
id|devfs_alloc_unique_number
(paren
r_struct
id|unique_numspace
op_star
id|space
)paren
(brace
r_int
id|number
suffix:semicolon
r_int
r_int
id|length
suffix:semicolon
multiline_comment|/*  Get around stupid lack of semaphore initialiser  */
id|spin_lock
(paren
op_amp
id|space-&gt;init_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|space-&gt;sem_initialised
)paren
(brace
id|sema_init
(paren
op_amp
id|space-&gt;semaphore
comma
l_int|1
)paren
suffix:semicolon
id|space-&gt;sem_initialised
op_assign
l_int|1
suffix:semicolon
)brace
id|spin_unlock
(paren
op_amp
id|space-&gt;init_lock
)paren
suffix:semicolon
id|down
(paren
op_amp
id|space-&gt;semaphore
)paren
suffix:semicolon
r_if
c_cond
(paren
id|space-&gt;num_free
OL
l_int|1
)paren
(brace
r_void
op_star
id|bits
suffix:semicolon
r_if
c_cond
(paren
id|space-&gt;length
OL
l_int|16
)paren
id|length
op_assign
l_int|16
suffix:semicolon
r_else
id|length
op_assign
id|space-&gt;length
op_lshift
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bits
op_assign
id|vmalloc
(paren
id|length
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|up
(paren
op_amp
id|space-&gt;semaphore
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_if
c_cond
(paren
id|space-&gt;bits
op_ne
l_int|NULL
)paren
(brace
id|memcpy
(paren
id|bits
comma
id|space-&gt;bits
comma
id|space-&gt;length
)paren
suffix:semicolon
id|vfree
(paren
id|space-&gt;bits
)paren
suffix:semicolon
)brace
id|space-&gt;num_free
op_assign
(paren
id|length
op_minus
id|space-&gt;length
)paren
op_lshift
l_int|3
suffix:semicolon
id|space-&gt;bits
op_assign
id|bits
suffix:semicolon
id|memset
(paren
id|bits
op_plus
id|space-&gt;length
comma
l_int|0
comma
id|length
op_minus
id|space-&gt;length
)paren
suffix:semicolon
id|space-&gt;length
op_assign
id|length
suffix:semicolon
)brace
id|number
op_assign
id|find_first_zero_bit
(paren
id|space-&gt;bits
comma
id|space-&gt;length
op_lshift
l_int|3
)paren
suffix:semicolon
op_decrement
id|space-&gt;num_free
suffix:semicolon
id|__set_bit
(paren
id|number
comma
id|space-&gt;bits
)paren
suffix:semicolon
id|up
(paren
op_amp
id|space-&gt;semaphore
)paren
suffix:semicolon
r_return
id|number
suffix:semicolon
)brace
multiline_comment|/*  End Function devfs_alloc_unique_number  */
DECL|variable|devfs_alloc_unique_number
id|EXPORT_SYMBOL
c_func
(paren
id|devfs_alloc_unique_number
)paren
suffix:semicolon
multiline_comment|/**&n; *&t;devfs_dealloc_unique_number - Deallocate a unique (positive) number.&n; *&t;@space: The number space to deallocate from.&n; *&t;@number: The number to deallocate.&n; *&n; *&t;This routine is thread safe and may block.&n; */
DECL|function|devfs_dealloc_unique_number
r_void
id|devfs_dealloc_unique_number
(paren
r_struct
id|unique_numspace
op_star
id|space
comma
r_int
id|number
)paren
(brace
r_int
id|was_set
suffix:semicolon
r_if
c_cond
(paren
id|number
OL
l_int|0
)paren
r_return
suffix:semicolon
id|down
(paren
op_amp
id|space-&gt;semaphore
)paren
suffix:semicolon
id|was_set
op_assign
id|__test_and_clear_bit
(paren
id|number
comma
id|space-&gt;bits
)paren
suffix:semicolon
r_if
c_cond
(paren
id|was_set
)paren
op_increment
id|space-&gt;num_free
suffix:semicolon
id|up
(paren
op_amp
id|space-&gt;semaphore
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|was_set
)paren
id|PRINTK
(paren
l_string|&quot;(): number %d was already free&bslash;n&quot;
comma
id|number
)paren
suffix:semicolon
)brace
multiline_comment|/*  End Function devfs_dealloc_unique_number  */
DECL|variable|devfs_dealloc_unique_number
id|EXPORT_SYMBOL
c_func
(paren
id|devfs_dealloc_unique_number
)paren
suffix:semicolon
eof
