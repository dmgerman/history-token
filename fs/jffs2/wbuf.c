multiline_comment|/*&n; * JFFS2 -- Journalling Flash File System, Version 2.&n; *&n; * Copyright (C) 2001-2003 Red Hat, Inc.&n; * Copyright (C) 2004 Thomas Gleixner &lt;tglx@linutronix.de&gt;&n; *&n; * Created by David Woodhouse &lt;dwmw2@infradead.org&gt;&n; * Modified debugged and enhanced by Thomas Gleixner &lt;tglx@linutronix.de&gt;&n; *&n; * For licensing information, see the file &squot;LICENCE&squot; in this directory.&n; *&n; * $Id: wbuf.c,v 1.82 2004/11/20 22:08:31 dwmw2 Exp $&n; *&n; */
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/mtd/mtd.h&gt;
macro_line|#include &lt;linux/crc32.h&gt;
macro_line|#include &lt;linux/mtd/nand.h&gt;
macro_line|#include &quot;nodelist.h&quot;
multiline_comment|/* For testing write failures */
DECL|macro|BREAKME
macro_line|#undef BREAKME
DECL|macro|BREAKMEHEADER
macro_line|#undef BREAKMEHEADER
macro_line|#ifdef BREAKME
DECL|variable|brokenbuf
r_static
r_int
r_char
op_star
id|brokenbuf
suffix:semicolon
macro_line|#endif
multiline_comment|/* max. erase failures before we mark a block bad */
DECL|macro|MAX_ERASE_FAILURES
mdefine_line|#define MAX_ERASE_FAILURES &t;2
multiline_comment|/* two seconds timeout for timed wbuf-flushing */
DECL|macro|WBUF_FLUSH_TIMEOUT
mdefine_line|#define WBUF_FLUSH_TIMEOUT&t;2 * HZ
DECL|struct|jffs2_inodirty
r_struct
id|jffs2_inodirty
(brace
DECL|member|ino
r_uint32
id|ino
suffix:semicolon
DECL|member|next
r_struct
id|jffs2_inodirty
op_star
id|next
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|inodirty_nomem
r_static
r_struct
id|jffs2_inodirty
id|inodirty_nomem
suffix:semicolon
DECL|function|jffs2_wbuf_pending_for_ino
r_static
r_int
id|jffs2_wbuf_pending_for_ino
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
comma
r_uint32
id|ino
)paren
(brace
r_struct
id|jffs2_inodirty
op_star
id|this
op_assign
id|c-&gt;wbuf_inodes
suffix:semicolon
multiline_comment|/* If a malloc failed, consider _everything_ dirty */
r_if
c_cond
(paren
id|this
op_eq
op_amp
id|inodirty_nomem
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* If ino == 0, _any_ non-GC writes mean &squot;yes&squot; */
r_if
c_cond
(paren
id|this
op_logical_and
op_logical_neg
id|ino
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* Look to see if the inode in question is pending in the wbuf */
r_while
c_loop
(paren
id|this
)paren
(brace
r_if
c_cond
(paren
id|this-&gt;ino
op_eq
id|ino
)paren
r_return
l_int|1
suffix:semicolon
id|this
op_assign
id|this-&gt;next
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|jffs2_clear_wbuf_ino_list
r_static
r_void
id|jffs2_clear_wbuf_ino_list
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
)paren
(brace
r_struct
id|jffs2_inodirty
op_star
id|this
suffix:semicolon
id|this
op_assign
id|c-&gt;wbuf_inodes
suffix:semicolon
r_if
c_cond
(paren
id|this
op_ne
op_amp
id|inodirty_nomem
)paren
(brace
r_while
c_loop
(paren
id|this
)paren
(brace
r_struct
id|jffs2_inodirty
op_star
id|next
op_assign
id|this-&gt;next
suffix:semicolon
id|kfree
c_func
(paren
id|this
)paren
suffix:semicolon
id|this
op_assign
id|next
suffix:semicolon
)brace
)brace
id|c-&gt;wbuf_inodes
op_assign
l_int|NULL
suffix:semicolon
)brace
DECL|function|jffs2_wbuf_dirties_inode
r_static
r_void
id|jffs2_wbuf_dirties_inode
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
comma
r_uint32
id|ino
)paren
(brace
r_struct
id|jffs2_inodirty
op_star
r_new
suffix:semicolon
multiline_comment|/* Mark the superblock dirty so that kupdated will flush... */
id|OFNI_BS_2SFFJ
c_func
(paren
id|c
)paren
op_member_access_from_pointer
id|s_dirt
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|jffs2_wbuf_pending_for_ino
c_func
(paren
id|c
comma
id|ino
)paren
)paren
r_return
suffix:semicolon
r_new
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
r_new
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
r_new
)paren
(brace
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;No memory to allocate inodirty. Fallback to all considered dirty&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|jffs2_clear_wbuf_ino_list
c_func
(paren
id|c
)paren
suffix:semicolon
id|c-&gt;wbuf_inodes
op_assign
op_amp
id|inodirty_nomem
suffix:semicolon
r_return
suffix:semicolon
)brace
r_new
op_member_access_from_pointer
id|ino
op_assign
id|ino
suffix:semicolon
r_new
op_member_access_from_pointer
id|next
op_assign
id|c-&gt;wbuf_inodes
suffix:semicolon
id|c-&gt;wbuf_inodes
op_assign
r_new
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|function|jffs2_refile_wbuf_blocks
r_static
r_inline
r_void
id|jffs2_refile_wbuf_blocks
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
)paren
(brace
r_struct
id|list_head
op_star
id|this
comma
op_star
id|next
suffix:semicolon
r_static
r_int
id|n
suffix:semicolon
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|c-&gt;erasable_pending_wbuf_list
)paren
)paren
r_return
suffix:semicolon
id|list_for_each_safe
c_func
(paren
id|this
comma
id|next
comma
op_amp
id|c-&gt;erasable_pending_wbuf_list
)paren
(brace
r_struct
id|jffs2_eraseblock
op_star
id|jeb
op_assign
id|list_entry
c_func
(paren
id|this
comma
r_struct
id|jffs2_eraseblock
comma
id|list
)paren
suffix:semicolon
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Removing eraseblock at 0x%08x from erasable_pending_wbuf_list...&bslash;n&quot;
comma
id|jeb-&gt;offset
)paren
)paren
suffix:semicolon
id|list_del
c_func
(paren
id|this
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|jiffies
op_plus
(paren
id|n
op_increment
)paren
)paren
op_amp
l_int|127
)paren
(brace
multiline_comment|/* Most of the time, we just erase it immediately. Otherwise we&n;&t;&t;&t;   spend ages scanning it on mount, etc. */
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;...and adding to erase_pending_list&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|jeb-&gt;list
comma
op_amp
id|c-&gt;erase_pending_list
)paren
suffix:semicolon
id|c-&gt;nr_erasing_blocks
op_increment
suffix:semicolon
id|jffs2_erase_pending_trigger
c_func
(paren
id|c
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Sometimes, however, we leave it elsewhere so it doesn&squot;t get&n;&t;&t;&t;   immediately reused, and we spread the load a bit. */
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;...and adding to erasable_list&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|jeb-&gt;list
comma
op_amp
id|c-&gt;erasable_list
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|function|jffs2_block_refile
r_static
r_void
id|jffs2_block_refile
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
comma
r_struct
id|jffs2_eraseblock
op_star
id|jeb
)paren
(brace
id|D1
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;About to refile bad block at %08x&bslash;n&quot;
comma
id|jeb-&gt;offset
)paren
)paren
suffix:semicolon
id|D2
c_func
(paren
id|jffs2_dump_block_lists
c_func
(paren
id|c
)paren
)paren
suffix:semicolon
multiline_comment|/* File the existing block on the bad_used_list.... */
r_if
c_cond
(paren
id|c-&gt;nextblock
op_eq
id|jeb
)paren
id|c-&gt;nextblock
op_assign
l_int|NULL
suffix:semicolon
r_else
multiline_comment|/* Not sure this should ever happen... need more coffee */
id|list_del
c_func
(paren
op_amp
id|jeb-&gt;list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|jeb-&gt;first_node
)paren
(brace
id|D1
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;Refiling block at %08x to bad_used_list&bslash;n&quot;
comma
id|jeb-&gt;offset
)paren
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|jeb-&gt;list
comma
op_amp
id|c-&gt;bad_used_list
)paren
suffix:semicolon
)brace
r_else
(brace
id|BUG
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* It has to have had some nodes or we couldn&squot;t be here */
id|D1
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;Refiling block at %08x to erase_pending_list&bslash;n&quot;
comma
id|jeb-&gt;offset
)paren
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|jeb-&gt;list
comma
op_amp
id|c-&gt;erase_pending_list
)paren
suffix:semicolon
id|c-&gt;nr_erasing_blocks
op_increment
suffix:semicolon
id|jffs2_erase_pending_trigger
c_func
(paren
id|c
)paren
suffix:semicolon
)brace
id|D2
c_func
(paren
id|jffs2_dump_block_lists
c_func
(paren
id|c
)paren
)paren
suffix:semicolon
multiline_comment|/* Adjust its size counts accordingly */
id|c-&gt;wasted_size
op_add_assign
id|jeb-&gt;free_size
suffix:semicolon
id|c-&gt;free_size
op_sub_assign
id|jeb-&gt;free_size
suffix:semicolon
id|jeb-&gt;wasted_size
op_add_assign
id|jeb-&gt;free_size
suffix:semicolon
id|jeb-&gt;free_size
op_assign
l_int|0
suffix:semicolon
id|ACCT_SANITY_CHECK
c_func
(paren
id|c
comma
id|jeb
)paren
suffix:semicolon
id|D1
c_func
(paren
id|ACCT_PARANOIA_CHECK
c_func
(paren
id|jeb
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Recover from failure to write wbuf. Recover the nodes up to the&n; * wbuf, not the one which we were starting to try to write. */
DECL|function|jffs2_wbuf_recover
r_static
r_void
id|jffs2_wbuf_recover
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
)paren
(brace
r_struct
id|jffs2_eraseblock
op_star
id|jeb
comma
op_star
id|new_jeb
suffix:semicolon
r_struct
id|jffs2_raw_node_ref
op_star
op_star
id|first_raw
comma
op_star
op_star
id|raw
suffix:semicolon
r_int
id|retlen
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_int
r_char
op_star
id|buf
suffix:semicolon
r_uint32
id|start
comma
id|end
comma
id|ofs
comma
id|len
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|c-&gt;erase_completion_lock
)paren
suffix:semicolon
id|jeb
op_assign
op_amp
id|c-&gt;blocks
(braket
id|c-&gt;wbuf_ofs
op_div
id|c-&gt;sector_size
)braket
suffix:semicolon
id|jffs2_block_refile
c_func
(paren
id|c
comma
id|jeb
)paren
suffix:semicolon
multiline_comment|/* Find the first node to be recovered, by skipping over every&n;&t;   node which ends before the wbuf starts, or which is obsolete. */
id|first_raw
op_assign
op_amp
id|jeb-&gt;first_node
suffix:semicolon
r_while
c_loop
(paren
op_star
id|first_raw
op_logical_and
(paren
id|ref_obsolete
c_func
(paren
op_star
id|first_raw
)paren
op_logical_or
(paren
id|ref_offset
c_func
(paren
op_star
id|first_raw
)paren
op_plus
id|ref_totlen
c_func
(paren
id|c
comma
id|jeb
comma
op_star
id|first_raw
)paren
)paren
OL
id|c-&gt;wbuf_ofs
)paren
)paren
(brace
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Skipping node at 0x%08x(%d)-0x%08x which is either before 0x%08x or obsolete&bslash;n&quot;
comma
id|ref_offset
c_func
(paren
op_star
id|first_raw
)paren
comma
id|ref_flags
c_func
(paren
op_star
id|first_raw
)paren
comma
(paren
id|ref_offset
c_func
(paren
op_star
id|first_raw
)paren
op_plus
id|ref_totlen
c_func
(paren
id|c
comma
id|jeb
comma
op_star
id|first_raw
)paren
)paren
comma
id|c-&gt;wbuf_ofs
)paren
)paren
suffix:semicolon
id|first_raw
op_assign
op_amp
(paren
op_star
id|first_raw
)paren
op_member_access_from_pointer
id|next_phys
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
op_star
id|first_raw
)paren
(brace
multiline_comment|/* All nodes were obsolete. Nothing to recover. */
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;No non-obsolete nodes to be recovered. Just filing block bad&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|c-&gt;erase_completion_lock
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|start
op_assign
id|ref_offset
c_func
(paren
op_star
id|first_raw
)paren
suffix:semicolon
id|end
op_assign
id|ref_offset
c_func
(paren
op_star
id|first_raw
)paren
op_plus
id|ref_totlen
c_func
(paren
id|c
comma
id|jeb
comma
op_star
id|first_raw
)paren
suffix:semicolon
multiline_comment|/* Find the last node to be recovered */
id|raw
op_assign
id|first_raw
suffix:semicolon
r_while
c_loop
(paren
(paren
op_star
id|raw
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ref_obsolete
c_func
(paren
op_star
id|raw
)paren
)paren
id|end
op_assign
id|ref_offset
c_func
(paren
op_star
id|raw
)paren
op_plus
id|ref_totlen
c_func
(paren
id|c
comma
id|jeb
comma
op_star
id|raw
)paren
suffix:semicolon
id|raw
op_assign
op_amp
(paren
op_star
id|raw
)paren
op_member_access_from_pointer
id|next_phys
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|c-&gt;erase_completion_lock
)paren
suffix:semicolon
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;wbuf recover %08x-%08x&bslash;n&quot;
comma
id|start
comma
id|end
)paren
)paren
suffix:semicolon
id|buf
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|start
OL
id|c-&gt;wbuf_ofs
)paren
(brace
multiline_comment|/* First affected node was already partially written.&n;&t;&t; * Attempt to reread the old data into our buffer. */
id|buf
op_assign
id|kmalloc
c_func
(paren
id|end
op_minus
id|start
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buf
)paren
(brace
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;Malloc failure in wbuf recovery. Data loss ensues.&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|read_failed
suffix:semicolon
)brace
multiline_comment|/* Do the read... */
r_if
c_cond
(paren
id|jffs2_cleanmarker_oob
c_func
(paren
id|c
)paren
)paren
id|ret
op_assign
id|c-&gt;mtd
op_member_access_from_pointer
id|read_ecc
c_func
(paren
id|c-&gt;mtd
comma
id|start
comma
id|c-&gt;wbuf_ofs
op_minus
id|start
comma
op_amp
id|retlen
comma
id|buf
comma
l_int|NULL
comma
id|c-&gt;oobinfo
)paren
suffix:semicolon
r_else
id|ret
op_assign
id|c-&gt;mtd
op_member_access_from_pointer
id|read
c_func
(paren
id|c-&gt;mtd
comma
id|start
comma
id|c-&gt;wbuf_ofs
op_minus
id|start
comma
op_amp
id|retlen
comma
id|buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
op_minus
id|EBADMSG
op_logical_and
id|retlen
op_eq
id|c-&gt;wbuf_ofs
op_minus
id|start
)paren
(brace
multiline_comment|/* ECC recovered */
id|ret
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ret
op_logical_or
id|retlen
op_ne
id|c-&gt;wbuf_ofs
op_minus
id|start
)paren
(brace
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;Old data are already lost in wbuf recovery. Data loss ensues.&bslash;n&quot;
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|buf
)paren
suffix:semicolon
id|buf
op_assign
l_int|NULL
suffix:semicolon
id|read_failed
suffix:colon
id|first_raw
op_assign
op_amp
(paren
op_star
id|first_raw
)paren
op_member_access_from_pointer
id|next_phys
suffix:semicolon
multiline_comment|/* If this was the only node to be recovered, give up */
r_if
c_cond
(paren
op_logical_neg
(paren
op_star
id|first_raw
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* It wasn&squot;t. Go on and try to recover nodes complete in the wbuf */
id|start
op_assign
id|ref_offset
c_func
(paren
op_star
id|first_raw
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Read succeeded. Copy the remaining data from the wbuf */
id|memcpy
c_func
(paren
id|buf
op_plus
(paren
id|c-&gt;wbuf_ofs
op_minus
id|start
)paren
comma
id|c-&gt;wbuf
comma
id|end
op_minus
id|c-&gt;wbuf_ofs
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* OK... we&squot;re to rewrite (end-start) bytes of data from first_raw onwards.&n;&t;   Either &squot;buf&squot; contains the data, or we find it in the wbuf */
multiline_comment|/* ... and get an allocation of space from a shiny new block instead */
id|ret
op_assign
id|jffs2_reserve_space_gc
c_func
(paren
id|c
comma
id|end
op_minus
id|start
comma
op_amp
id|ofs
comma
op_amp
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Failed to allocate space for wbuf recovery. Data loss ensues.&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buf
)paren
id|kfree
c_func
(paren
id|buf
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|end
op_minus
id|start
op_ge
id|c-&gt;wbuf_pagesize
)paren
(brace
multiline_comment|/* Need to do another write immediately. This, btw,&n;&t;&t; means that we&squot;ll be writing from &squot;buf&squot; and not from&n;&t;&t; the wbuf. Since if we&squot;re writing from the wbuf there&n;&t;&t; won&squot;t be more than a wbuf full of data, now will&n;&t;&t; there? :) */
r_uint32
id|towrite
op_assign
(paren
id|end
op_minus
id|start
)paren
op_minus
(paren
(paren
id|end
op_minus
id|start
)paren
op_mod
id|c-&gt;wbuf_pagesize
)paren
suffix:semicolon
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Write 0x%x bytes at 0x%08x in wbuf recover&bslash;n&quot;
comma
id|towrite
comma
id|ofs
)paren
)paren
suffix:semicolon
macro_line|#ifdef BREAKMEHEADER
r_static
r_int
id|breakme
suffix:semicolon
r_if
c_cond
(paren
id|breakme
op_increment
op_eq
l_int|20
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;Faking write error at 0x%08x&bslash;n&quot;
comma
id|ofs
)paren
suffix:semicolon
id|breakme
op_assign
l_int|0
suffix:semicolon
id|c-&gt;mtd
op_member_access_from_pointer
id|write_ecc
c_func
(paren
id|c-&gt;mtd
comma
id|ofs
comma
id|towrite
comma
op_amp
id|retlen
comma
id|brokenbuf
comma
l_int|NULL
comma
id|c-&gt;oobinfo
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
r_else
macro_line|#endif
r_if
c_cond
(paren
id|jffs2_cleanmarker_oob
c_func
(paren
id|c
)paren
)paren
id|ret
op_assign
id|c-&gt;mtd
op_member_access_from_pointer
id|write_ecc
c_func
(paren
id|c-&gt;mtd
comma
id|ofs
comma
id|towrite
comma
op_amp
id|retlen
comma
id|buf
comma
l_int|NULL
comma
id|c-&gt;oobinfo
)paren
suffix:semicolon
r_else
id|ret
op_assign
id|c-&gt;mtd
op_member_access_from_pointer
id|write
c_func
(paren
id|c-&gt;mtd
comma
id|ofs
comma
id|towrite
comma
op_amp
id|retlen
comma
id|buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_logical_or
id|retlen
op_ne
id|towrite
)paren
(brace
multiline_comment|/* Argh. We tried. Really we did. */
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;Recovery of wbuf failed due to a second write error&bslash;n&quot;
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retlen
)paren
(brace
r_struct
id|jffs2_raw_node_ref
op_star
id|raw2
suffix:semicolon
id|raw2
op_assign
id|jffs2_alloc_raw_node_ref
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|raw2
)paren
r_return
suffix:semicolon
id|raw2-&gt;flash_offset
op_assign
id|ofs
op_or
id|REF_OBSOLETE
suffix:semicolon
id|raw2-&gt;__totlen
op_assign
id|ref_totlen
c_func
(paren
id|c
comma
id|jeb
comma
op_star
id|first_raw
)paren
suffix:semicolon
id|raw2-&gt;next_phys
op_assign
l_int|NULL
suffix:semicolon
id|raw2-&gt;next_in_ino
op_assign
l_int|NULL
suffix:semicolon
id|jffs2_add_physical_node_ref
c_func
(paren
id|c
comma
id|raw2
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;Recovery of wbuf succeeded to %08x&bslash;n&quot;
comma
id|ofs
)paren
suffix:semicolon
id|c-&gt;wbuf_len
op_assign
(paren
id|end
op_minus
id|start
)paren
op_minus
id|towrite
suffix:semicolon
id|c-&gt;wbuf_ofs
op_assign
id|ofs
op_plus
id|towrite
suffix:semicolon
id|memcpy
c_func
(paren
id|c-&gt;wbuf
comma
id|buf
op_plus
id|towrite
comma
id|c-&gt;wbuf_len
)paren
suffix:semicolon
multiline_comment|/* Don&squot;t muck about with c-&gt;wbuf_inodes. False positives are harmless. */
id|kfree
c_func
(paren
id|buf
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* OK, now we&squot;re left with the dregs in whichever buffer we&squot;re using */
r_if
c_cond
(paren
id|buf
)paren
(brace
id|memcpy
c_func
(paren
id|c-&gt;wbuf
comma
id|buf
comma
id|end
op_minus
id|start
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|buf
)paren
suffix:semicolon
)brace
r_else
(brace
id|memmove
c_func
(paren
id|c-&gt;wbuf
comma
id|c-&gt;wbuf
op_plus
(paren
id|start
op_minus
id|c-&gt;wbuf_ofs
)paren
comma
id|end
op_minus
id|start
)paren
suffix:semicolon
)brace
id|c-&gt;wbuf_ofs
op_assign
id|ofs
suffix:semicolon
id|c-&gt;wbuf_len
op_assign
id|end
op_minus
id|start
suffix:semicolon
)brace
multiline_comment|/* Now sort out the jffs2_raw_node_refs, moving them from the old to the next block */
id|new_jeb
op_assign
op_amp
id|c-&gt;blocks
(braket
id|ofs
op_div
id|c-&gt;sector_size
)braket
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|c-&gt;erase_completion_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|new_jeb-&gt;first_node
)paren
(brace
multiline_comment|/* Odd, but possible with ST flash later maybe */
id|new_jeb-&gt;last_node-&gt;next_phys
op_assign
op_star
id|first_raw
suffix:semicolon
)brace
r_else
(brace
id|new_jeb-&gt;first_node
op_assign
op_star
id|first_raw
suffix:semicolon
)brace
id|raw
op_assign
id|first_raw
suffix:semicolon
r_while
c_loop
(paren
op_star
id|raw
)paren
(brace
r_uint32
id|rawlen
op_assign
id|ref_totlen
c_func
(paren
id|c
comma
id|jeb
comma
op_star
id|raw
)paren
suffix:semicolon
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Refiling block of %08x at %08x(%d) to %08x&bslash;n&quot;
comma
id|rawlen
comma
id|ref_offset
c_func
(paren
op_star
id|raw
)paren
comma
id|ref_flags
c_func
(paren
op_star
id|raw
)paren
comma
id|ofs
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ref_obsolete
c_func
(paren
op_star
id|raw
)paren
)paren
(brace
multiline_comment|/* Shouldn&squot;t really happen much */
id|new_jeb-&gt;dirty_size
op_add_assign
id|rawlen
suffix:semicolon
id|new_jeb-&gt;free_size
op_sub_assign
id|rawlen
suffix:semicolon
id|c-&gt;dirty_size
op_add_assign
id|rawlen
suffix:semicolon
)brace
r_else
(brace
id|new_jeb-&gt;used_size
op_add_assign
id|rawlen
suffix:semicolon
id|new_jeb-&gt;free_size
op_sub_assign
id|rawlen
suffix:semicolon
id|jeb-&gt;dirty_size
op_add_assign
id|rawlen
suffix:semicolon
id|jeb-&gt;used_size
op_sub_assign
id|rawlen
suffix:semicolon
id|c-&gt;dirty_size
op_add_assign
id|rawlen
suffix:semicolon
)brace
id|c-&gt;free_size
op_sub_assign
id|rawlen
suffix:semicolon
(paren
op_star
id|raw
)paren
op_member_access_from_pointer
id|flash_offset
op_assign
id|ofs
op_or
id|ref_flags
c_func
(paren
op_star
id|raw
)paren
suffix:semicolon
id|ofs
op_add_assign
id|rawlen
suffix:semicolon
id|new_jeb-&gt;last_node
op_assign
op_star
id|raw
suffix:semicolon
id|raw
op_assign
op_amp
(paren
op_star
id|raw
)paren
op_member_access_from_pointer
id|next_phys
suffix:semicolon
)brace
multiline_comment|/* Fix up the original jeb now it&squot;s on the bad_list */
op_star
id|first_raw
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|first_raw
op_eq
op_amp
id|jeb-&gt;first_node
)paren
(brace
id|jeb-&gt;last_node
op_assign
l_int|NULL
suffix:semicolon
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Failing block at %08x is now empty. Moving to erase_pending_list&bslash;n&quot;
comma
id|jeb-&gt;offset
)paren
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|jeb-&gt;list
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|jeb-&gt;list
comma
op_amp
id|c-&gt;erase_pending_list
)paren
suffix:semicolon
id|c-&gt;nr_erasing_blocks
op_increment
suffix:semicolon
id|jffs2_erase_pending_trigger
c_func
(paren
id|c
)paren
suffix:semicolon
)brace
r_else
id|jeb-&gt;last_node
op_assign
id|container_of
c_func
(paren
id|first_raw
comma
r_struct
id|jffs2_raw_node_ref
comma
id|next_phys
)paren
suffix:semicolon
id|ACCT_SANITY_CHECK
c_func
(paren
id|c
comma
id|jeb
)paren
suffix:semicolon
id|D1
c_func
(paren
id|ACCT_PARANOIA_CHECK
c_func
(paren
id|jeb
)paren
)paren
suffix:semicolon
id|ACCT_SANITY_CHECK
c_func
(paren
id|c
comma
id|new_jeb
)paren
suffix:semicolon
id|D1
c_func
(paren
id|ACCT_PARANOIA_CHECK
c_func
(paren
id|new_jeb
)paren
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|c-&gt;erase_completion_lock
)paren
suffix:semicolon
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;wbuf recovery completed OK&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Meaning of pad argument:&n;   0: Do not pad. Probably pointless - we only ever use this when we can&squot;t pad anyway.&n;   1: Pad, do not adjust nextblock free_size&n;   2: Pad, adjust nextblock free_size&n;*/
DECL|macro|NOPAD
mdefine_line|#define NOPAD&t;&t;0
DECL|macro|PAD_NOACCOUNT
mdefine_line|#define PAD_NOACCOUNT&t;1
DECL|macro|PAD_ACCOUNTING
mdefine_line|#define PAD_ACCOUNTING&t;2
DECL|function|__jffs2_flush_wbuf
r_static
r_int
id|__jffs2_flush_wbuf
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
comma
r_int
id|pad
)paren
(brace
r_int
id|ret
suffix:semicolon
r_int
id|retlen
suffix:semicolon
multiline_comment|/* Nothing to do if not NAND flash. In particular, we shouldn&squot;t&n;&t;   del_timer() the timer we never initialised. */
r_if
c_cond
(paren
id|jffs2_can_mark_obsolete
c_func
(paren
id|c
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|down_trylock
c_func
(paren
op_amp
id|c-&gt;alloc_sem
)paren
)paren
(brace
id|up
c_func
(paren
op_amp
id|c-&gt;alloc_sem
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;jffs2_flush_wbuf() called with alloc_sem not locked!&bslash;n&quot;
)paren
suffix:semicolon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|c-&gt;wbuf
op_logical_or
op_logical_neg
id|c-&gt;wbuf_len
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* claim remaining space on the page&n;&t;   this happens, if we have a change to a new block,&n;&t;   or if fsync forces us to flush the writebuffer.&n;&t;   if we have a switch to next page, we will not have&n;&t;   enough remaining space for this. &n;&t;*/
r_if
c_cond
(paren
id|pad
)paren
(brace
id|c-&gt;wbuf_len
op_assign
id|PAD
c_func
(paren
id|c-&gt;wbuf_len
)paren
suffix:semicolon
multiline_comment|/* Pad with JFFS2_DIRTY_BITMASK initially.  this helps out ECC&squot;d NOR&n;&t;&t;   with 8 byte page size */
id|memset
c_func
(paren
id|c-&gt;wbuf
op_plus
id|c-&gt;wbuf_len
comma
l_int|0
comma
id|c-&gt;wbuf_pagesize
op_minus
id|c-&gt;wbuf_len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c-&gt;wbuf_len
op_plus
r_sizeof
(paren
r_struct
id|jffs2_unknown_node
)paren
OL
id|c-&gt;wbuf_pagesize
)paren
(brace
r_struct
id|jffs2_unknown_node
op_star
id|padnode
op_assign
(paren
r_void
op_star
)paren
(paren
id|c-&gt;wbuf
op_plus
id|c-&gt;wbuf_len
)paren
suffix:semicolon
id|padnode-&gt;magic
op_assign
id|cpu_to_je16
c_func
(paren
id|JFFS2_MAGIC_BITMASK
)paren
suffix:semicolon
id|padnode-&gt;nodetype
op_assign
id|cpu_to_je16
c_func
(paren
id|JFFS2_NODETYPE_PADDING
)paren
suffix:semicolon
id|padnode-&gt;totlen
op_assign
id|cpu_to_je32
c_func
(paren
id|c-&gt;wbuf_pagesize
op_minus
id|c-&gt;wbuf_len
)paren
suffix:semicolon
id|padnode-&gt;hdr_crc
op_assign
id|cpu_to_je32
c_func
(paren
id|crc32
c_func
(paren
l_int|0
comma
id|padnode
comma
r_sizeof
(paren
op_star
id|padnode
)paren
op_minus
l_int|4
)paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* else jffs2_flash_writev has actually filled in the rest of the&n;&t;   buffer for us, and will deal with the node refs etc. later. */
macro_line|#ifdef BREAKME
r_static
r_int
id|breakme
suffix:semicolon
r_if
c_cond
(paren
id|breakme
op_increment
op_eq
l_int|20
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;Faking write error at 0x%08x&bslash;n&quot;
comma
id|c-&gt;wbuf_ofs
)paren
suffix:semicolon
id|breakme
op_assign
l_int|0
suffix:semicolon
id|c-&gt;mtd
op_member_access_from_pointer
id|write_ecc
c_func
(paren
id|c-&gt;mtd
comma
id|c-&gt;wbuf_ofs
comma
id|c-&gt;wbuf_pagesize
comma
op_amp
id|retlen
comma
id|brokenbuf
comma
l_int|NULL
comma
id|c-&gt;oobinfo
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
r_else
macro_line|#endif
r_if
c_cond
(paren
id|jffs2_cleanmarker_oob
c_func
(paren
id|c
)paren
)paren
id|ret
op_assign
id|c-&gt;mtd
op_member_access_from_pointer
id|write_ecc
c_func
(paren
id|c-&gt;mtd
comma
id|c-&gt;wbuf_ofs
comma
id|c-&gt;wbuf_pagesize
comma
op_amp
id|retlen
comma
id|c-&gt;wbuf
comma
l_int|NULL
comma
id|c-&gt;oobinfo
)paren
suffix:semicolon
r_else
id|ret
op_assign
id|c-&gt;mtd
op_member_access_from_pointer
id|write
c_func
(paren
id|c-&gt;mtd
comma
id|c-&gt;wbuf_ofs
comma
id|c-&gt;wbuf_pagesize
comma
op_amp
id|retlen
comma
id|c-&gt;wbuf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_logical_or
id|retlen
op_ne
id|c-&gt;wbuf_pagesize
)paren
(brace
r_if
c_cond
(paren
id|ret
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;jffs2_flush_wbuf(): Write failed with %d&bslash;n&quot;
comma
id|ret
)paren
suffix:semicolon
r_else
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;jffs2_flush_wbuf(): Write was short: %zd instead of %d&bslash;n&quot;
comma
id|retlen
comma
id|c-&gt;wbuf_pagesize
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
id|jffs2_wbuf_recover
c_func
(paren
id|c
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
id|spin_lock
c_func
(paren
op_amp
id|c-&gt;erase_completion_lock
)paren
suffix:semicolon
multiline_comment|/* Adjust free size of the block if we padded. */
r_if
c_cond
(paren
id|pad
)paren
(brace
r_struct
id|jffs2_eraseblock
op_star
id|jeb
suffix:semicolon
id|jeb
op_assign
op_amp
id|c-&gt;blocks
(braket
id|c-&gt;wbuf_ofs
op_div
id|c-&gt;sector_size
)braket
suffix:semicolon
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;jffs2_flush_wbuf() adjusting free_size of %sblock at %08x&bslash;n&quot;
comma
(paren
id|jeb
op_eq
id|c-&gt;nextblock
)paren
ques
c_cond
l_string|&quot;next&quot;
suffix:colon
l_string|&quot;&quot;
comma
id|jeb-&gt;offset
)paren
)paren
suffix:semicolon
multiline_comment|/* wbuf_pagesize - wbuf_len is the amount of space that&squot;s to be &n;&t;&t;   padded. If there is less free space in the block than that,&n;&t;&t;   something screwed up */
r_if
c_cond
(paren
id|jeb-&gt;free_size
OL
(paren
id|c-&gt;wbuf_pagesize
op_minus
id|c-&gt;wbuf_len
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;jffs2_flush_wbuf(): Accounting error. wbuf at 0x%08x has 0x%03x bytes, 0x%03x left.&bslash;n&quot;
comma
id|c-&gt;wbuf_ofs
comma
id|c-&gt;wbuf_len
comma
id|c-&gt;wbuf_pagesize
op_minus
id|c-&gt;wbuf_len
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;jffs2_flush_wbuf(): But free_size for block at 0x%08x is only 0x%08x&bslash;n&quot;
comma
id|jeb-&gt;offset
comma
id|jeb-&gt;free_size
)paren
suffix:semicolon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
id|jeb-&gt;free_size
op_sub_assign
(paren
id|c-&gt;wbuf_pagesize
op_minus
id|c-&gt;wbuf_len
)paren
suffix:semicolon
id|c-&gt;free_size
op_sub_assign
(paren
id|c-&gt;wbuf_pagesize
op_minus
id|c-&gt;wbuf_len
)paren
suffix:semicolon
id|jeb-&gt;wasted_size
op_add_assign
(paren
id|c-&gt;wbuf_pagesize
op_minus
id|c-&gt;wbuf_len
)paren
suffix:semicolon
id|c-&gt;wasted_size
op_add_assign
(paren
id|c-&gt;wbuf_pagesize
op_minus
id|c-&gt;wbuf_len
)paren
suffix:semicolon
)brace
multiline_comment|/* Stick any now-obsoleted blocks on the erase_pending_list */
id|jffs2_refile_wbuf_blocks
c_func
(paren
id|c
)paren
suffix:semicolon
id|jffs2_clear_wbuf_ino_list
c_func
(paren
id|c
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|c-&gt;erase_completion_lock
)paren
suffix:semicolon
id|memset
c_func
(paren
id|c-&gt;wbuf
comma
l_int|0xff
comma
id|c-&gt;wbuf_pagesize
)paren
suffix:semicolon
multiline_comment|/* adjust write buffer offset, else we get a non contiguous write bug */
id|c-&gt;wbuf_ofs
op_add_assign
id|c-&gt;wbuf_pagesize
suffix:semicolon
id|c-&gt;wbuf_len
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Trigger garbage collection to flush the write-buffer. &n;   If ino arg is zero, do it if _any_ real (i.e. not GC) writes are&n;   outstanding. If ino arg non-zero, do it only if a write for the &n;   given inode is outstanding. */
DECL|function|jffs2_flush_wbuf_gc
r_int
id|jffs2_flush_wbuf_gc
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
comma
r_uint32
id|ino
)paren
(brace
r_uint32
id|old_wbuf_ofs
suffix:semicolon
r_uint32
id|old_wbuf_len
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;jffs2_flush_wbuf_gc() called for ino #%u...&bslash;n&quot;
comma
id|ino
)paren
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|c-&gt;alloc_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|jffs2_wbuf_pending_for_ino
c_func
(paren
id|c
comma
id|ino
)paren
)paren
(brace
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Ino #%d not pending in wbuf. Returning&bslash;n&quot;
comma
id|ino
)paren
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|c-&gt;alloc_sem
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|old_wbuf_ofs
op_assign
id|c-&gt;wbuf_ofs
suffix:semicolon
id|old_wbuf_len
op_assign
id|c-&gt;wbuf_len
suffix:semicolon
r_if
c_cond
(paren
id|c-&gt;unchecked_size
)paren
(brace
multiline_comment|/* GC won&squot;t make any progress for a while */
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;jffs2_flush_wbuf_gc() padding. Not finished checking&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|down_write
c_func
(paren
op_amp
id|c-&gt;wbuf_sem
)paren
suffix:semicolon
id|ret
op_assign
id|__jffs2_flush_wbuf
c_func
(paren
id|c
comma
id|PAD_ACCOUNTING
)paren
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|c-&gt;wbuf_sem
)paren
suffix:semicolon
)brace
r_else
r_while
c_loop
(paren
id|old_wbuf_len
op_logical_and
id|old_wbuf_ofs
op_eq
id|c-&gt;wbuf_ofs
)paren
(brace
id|up
c_func
(paren
op_amp
id|c-&gt;alloc_sem
)paren
suffix:semicolon
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;jffs2_flush_wbuf_gc() calls gc pass&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|ret
op_assign
id|jffs2_garbage_collect_pass
c_func
(paren
id|c
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
multiline_comment|/* GC failed. Flush it with padding instead */
id|down
c_func
(paren
op_amp
id|c-&gt;alloc_sem
)paren
suffix:semicolon
id|down_write
c_func
(paren
op_amp
id|c-&gt;wbuf_sem
)paren
suffix:semicolon
id|ret
op_assign
id|__jffs2_flush_wbuf
c_func
(paren
id|c
comma
id|PAD_ACCOUNTING
)paren
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|c-&gt;wbuf_sem
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|down
c_func
(paren
op_amp
id|c-&gt;alloc_sem
)paren
suffix:semicolon
)brace
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;jffs2_flush_wbuf_gc() ends...&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|c-&gt;alloc_sem
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* Pad write-buffer to end and write it, wasting space. */
DECL|function|jffs2_flush_wbuf_pad
r_int
id|jffs2_flush_wbuf_pad
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
)paren
(brace
r_int
id|ret
suffix:semicolon
id|down_write
c_func
(paren
op_amp
id|c-&gt;wbuf_sem
)paren
suffix:semicolon
id|ret
op_assign
id|__jffs2_flush_wbuf
c_func
(paren
id|c
comma
id|PAD_NOACCOUNT
)paren
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|c-&gt;wbuf_sem
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|macro|PAGE_DIV
mdefine_line|#define PAGE_DIV(x) ( (x) &amp; (~(c-&gt;wbuf_pagesize - 1)) )
DECL|macro|PAGE_MOD
mdefine_line|#define PAGE_MOD(x) ( (x) &amp; (c-&gt;wbuf_pagesize - 1) )
DECL|function|jffs2_flash_writev
r_int
id|jffs2_flash_writev
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
comma
r_const
r_struct
id|kvec
op_star
id|invecs
comma
r_int
r_int
id|count
comma
id|loff_t
id|to
comma
r_int
op_star
id|retlen
comma
r_uint32
id|ino
)paren
(brace
r_struct
id|kvec
id|outvecs
(braket
l_int|3
)braket
suffix:semicolon
r_uint32
id|totlen
op_assign
l_int|0
suffix:semicolon
r_uint32
id|split_ofs
op_assign
l_int|0
suffix:semicolon
r_uint32
id|old_totlen
suffix:semicolon
r_int
id|ret
comma
id|splitvec
op_assign
op_minus
l_int|1
suffix:semicolon
r_int
id|invec
comma
id|outvec
suffix:semicolon
r_int
id|wbuf_retlen
suffix:semicolon
r_int
r_char
op_star
id|wbuf_ptr
suffix:semicolon
r_int
id|donelen
op_assign
l_int|0
suffix:semicolon
r_uint32
id|outvec_to
op_assign
id|to
suffix:semicolon
multiline_comment|/* If not NAND flash, don&squot;t bother */
r_if
c_cond
(paren
op_logical_neg
id|c-&gt;wbuf
)paren
r_return
id|jffs2_flash_direct_writev
c_func
(paren
id|c
comma
id|invecs
comma
id|count
comma
id|to
comma
id|retlen
)paren
suffix:semicolon
id|down_write
c_func
(paren
op_amp
id|c-&gt;wbuf_sem
)paren
suffix:semicolon
multiline_comment|/* If wbuf_ofs is not initialized, set it to target address */
r_if
c_cond
(paren
id|c-&gt;wbuf_ofs
op_eq
l_int|0xFFFFFFFF
)paren
(brace
id|c-&gt;wbuf_ofs
op_assign
id|PAGE_DIV
c_func
(paren
id|to
)paren
suffix:semicolon
id|c-&gt;wbuf_len
op_assign
id|PAGE_MOD
c_func
(paren
id|to
)paren
suffix:semicolon
id|memset
c_func
(paren
id|c-&gt;wbuf
comma
l_int|0xff
comma
id|c-&gt;wbuf_pagesize
)paren
suffix:semicolon
)brace
multiline_comment|/* Fixup the wbuf if we are moving to a new eraseblock.  The checks below&n;&t;   fail for ECC&squot;d NOR because cleanmarker == 16, so a block starts at&n;&t;   xxx0010.  */
r_if
c_cond
(paren
id|jffs2_nor_ecc
c_func
(paren
id|c
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
id|c-&gt;wbuf_ofs
op_mod
id|c-&gt;sector_size
)paren
op_eq
l_int|0
)paren
op_logical_and
op_logical_neg
id|c-&gt;wbuf_len
)paren
(brace
id|c-&gt;wbuf_ofs
op_assign
id|PAGE_DIV
c_func
(paren
id|to
)paren
suffix:semicolon
id|c-&gt;wbuf_len
op_assign
id|PAGE_MOD
c_func
(paren
id|to
)paren
suffix:semicolon
id|memset
c_func
(paren
id|c-&gt;wbuf
comma
l_int|0xff
comma
id|c-&gt;wbuf_pagesize
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Sanity checks on target address. &n;&t;   It&squot;s permitted to write at PAD(c-&gt;wbuf_len+c-&gt;wbuf_ofs), &n;&t;   and it&squot;s permitted to write at the beginning of a new &n;&t;   erase block. Anything else, and you die.&n;&t;   New block starts at xxx000c (0-b = block header)&n;&t;*/
r_if
c_cond
(paren
(paren
id|to
op_amp
op_complement
(paren
id|c-&gt;sector_size
op_minus
l_int|1
)paren
)paren
op_ne
(paren
id|c-&gt;wbuf_ofs
op_amp
op_complement
(paren
id|c-&gt;sector_size
op_minus
l_int|1
)paren
)paren
)paren
(brace
multiline_comment|/* It&squot;s a write to a new block */
r_if
c_cond
(paren
id|c-&gt;wbuf_len
)paren
(brace
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;jffs2_flash_writev() to 0x%lx causes flush of wbuf at 0x%08x&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|to
comma
id|c-&gt;wbuf_ofs
)paren
)paren
suffix:semicolon
id|ret
op_assign
id|__jffs2_flush_wbuf
c_func
(paren
id|c
comma
id|PAD_NOACCOUNT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
multiline_comment|/* the underlying layer has to check wbuf_len to do the cleanup */
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;jffs2_flush_wbuf() called from jffs2_flash_writev() failed %d&bslash;n&quot;
comma
id|ret
)paren
)paren
suffix:semicolon
op_star
id|retlen
op_assign
l_int|0
suffix:semicolon
r_goto
m_exit
suffix:semicolon
)brace
)brace
multiline_comment|/* set pointer to new block */
id|c-&gt;wbuf_ofs
op_assign
id|PAGE_DIV
c_func
(paren
id|to
)paren
suffix:semicolon
id|c-&gt;wbuf_len
op_assign
id|PAGE_MOD
c_func
(paren
id|to
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|to
op_ne
id|PAD
c_func
(paren
id|c-&gt;wbuf_ofs
op_plus
id|c-&gt;wbuf_len
)paren
)paren
(brace
multiline_comment|/* We&squot;re not writing immediately after the writebuffer. Bad. */
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;jffs2_flash_writev(): Non-contiguous write to %08lx&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|to
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c-&gt;wbuf_len
)paren
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;wbuf was previously %08x-%08x&bslash;n&quot;
comma
id|c-&gt;wbuf_ofs
comma
id|c-&gt;wbuf_ofs
op_plus
id|c-&gt;wbuf_len
)paren
suffix:semicolon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Note outvecs[3] above. We know count is never greater than 2 */
r_if
c_cond
(paren
id|count
OG
l_int|2
)paren
(brace
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;jffs2_flash_writev(): count is %ld&bslash;n&quot;
comma
id|count
)paren
suffix:semicolon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
id|invec
op_assign
l_int|0
suffix:semicolon
id|outvec
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Fill writebuffer first, if already in use */
r_if
c_cond
(paren
id|c-&gt;wbuf_len
)paren
(brace
r_uint32
id|invec_ofs
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* adjust alignment offset */
r_if
c_cond
(paren
id|c-&gt;wbuf_len
op_ne
id|PAGE_MOD
c_func
(paren
id|to
)paren
)paren
(brace
id|c-&gt;wbuf_len
op_assign
id|PAGE_MOD
c_func
(paren
id|to
)paren
suffix:semicolon
multiline_comment|/* take care of alignment to next page */
r_if
c_cond
(paren
op_logical_neg
id|c-&gt;wbuf_len
)paren
id|c-&gt;wbuf_len
op_assign
id|c-&gt;wbuf_pagesize
suffix:semicolon
)brace
r_while
c_loop
(paren
id|c-&gt;wbuf_len
OL
id|c-&gt;wbuf_pagesize
)paren
(brace
r_uint32
id|thislen
suffix:semicolon
r_if
c_cond
(paren
id|invec
op_eq
id|count
)paren
r_goto
id|alldone
suffix:semicolon
id|thislen
op_assign
id|c-&gt;wbuf_pagesize
op_minus
id|c-&gt;wbuf_len
suffix:semicolon
r_if
c_cond
(paren
id|thislen
op_ge
id|invecs
(braket
id|invec
)braket
dot
id|iov_len
)paren
id|thislen
op_assign
id|invecs
(braket
id|invec
)braket
dot
id|iov_len
suffix:semicolon
id|invec_ofs
op_assign
id|thislen
suffix:semicolon
id|memcpy
c_func
(paren
id|c-&gt;wbuf
op_plus
id|c-&gt;wbuf_len
comma
id|invecs
(braket
id|invec
)braket
dot
id|iov_base
comma
id|thislen
)paren
suffix:semicolon
id|c-&gt;wbuf_len
op_add_assign
id|thislen
suffix:semicolon
id|donelen
op_add_assign
id|thislen
suffix:semicolon
multiline_comment|/* Get next invec, if actual did not fill the buffer */
r_if
c_cond
(paren
id|c-&gt;wbuf_len
OL
id|c-&gt;wbuf_pagesize
)paren
id|invec
op_increment
suffix:semicolon
)brace
multiline_comment|/* write buffer is full, flush buffer */
id|ret
op_assign
id|__jffs2_flush_wbuf
c_func
(paren
id|c
comma
id|NOPAD
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
multiline_comment|/* the underlying layer has to check wbuf_len to do the cleanup */
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;jffs2_flush_wbuf() called from jffs2_flash_writev() failed %d&bslash;n&quot;
comma
id|ret
)paren
)paren
suffix:semicolon
multiline_comment|/* Retlen zero to make sure our caller doesn&squot;t mark the space dirty.&n;&t;&t;&t;   We&squot;ve already done everything that&squot;s necessary */
op_star
id|retlen
op_assign
l_int|0
suffix:semicolon
r_goto
m_exit
suffix:semicolon
)brace
id|outvec_to
op_add_assign
id|donelen
suffix:semicolon
id|c-&gt;wbuf_ofs
op_assign
id|outvec_to
suffix:semicolon
multiline_comment|/* All invecs done ? */
r_if
c_cond
(paren
id|invec
op_eq
id|count
)paren
r_goto
id|alldone
suffix:semicolon
multiline_comment|/* Set up the first outvec, containing the remainder of the&n;&t;&t;   invec we partially used */
r_if
c_cond
(paren
id|invecs
(braket
id|invec
)braket
dot
id|iov_len
OG
id|invec_ofs
)paren
(brace
id|outvecs
(braket
l_int|0
)braket
dot
id|iov_base
op_assign
id|invecs
(braket
id|invec
)braket
dot
id|iov_base
op_plus
id|invec_ofs
suffix:semicolon
id|totlen
op_assign
id|outvecs
(braket
l_int|0
)braket
dot
id|iov_len
op_assign
id|invecs
(braket
id|invec
)braket
dot
id|iov_len
op_minus
id|invec_ofs
suffix:semicolon
r_if
c_cond
(paren
id|totlen
OG
id|c-&gt;wbuf_pagesize
)paren
(brace
id|splitvec
op_assign
id|outvec
suffix:semicolon
id|split_ofs
op_assign
id|outvecs
(braket
l_int|0
)braket
dot
id|iov_len
op_minus
id|PAGE_MOD
c_func
(paren
id|totlen
)paren
suffix:semicolon
)brace
id|outvec
op_increment
suffix:semicolon
)brace
id|invec
op_increment
suffix:semicolon
)brace
multiline_comment|/* OK, now we&squot;ve flushed the wbuf and the start of the bits&n;&t;   we have been asked to write, now to write the rest.... */
multiline_comment|/* totlen holds the amount of data still to be written */
id|old_totlen
op_assign
id|totlen
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|invec
OL
id|count
suffix:semicolon
id|invec
op_increment
comma
id|outvec
op_increment
)paren
(brace
id|outvecs
(braket
id|outvec
)braket
dot
id|iov_base
op_assign
id|invecs
(braket
id|invec
)braket
dot
id|iov_base
suffix:semicolon
id|totlen
op_add_assign
id|outvecs
(braket
id|outvec
)braket
dot
id|iov_len
op_assign
id|invecs
(braket
id|invec
)braket
dot
id|iov_len
suffix:semicolon
r_if
c_cond
(paren
id|PAGE_DIV
c_func
(paren
id|totlen
)paren
op_ne
id|PAGE_DIV
c_func
(paren
id|old_totlen
)paren
)paren
(brace
id|splitvec
op_assign
id|outvec
suffix:semicolon
id|split_ofs
op_assign
id|outvecs
(braket
id|outvec
)braket
dot
id|iov_len
op_minus
id|PAGE_MOD
c_func
(paren
id|totlen
)paren
suffix:semicolon
id|old_totlen
op_assign
id|totlen
suffix:semicolon
)brace
)brace
multiline_comment|/* Now the outvecs array holds all the remaining data to write */
multiline_comment|/* Up to splitvec,split_ofs is to be written immediately. The rest&n;&t;   goes into the (now-empty) wbuf */
r_if
c_cond
(paren
id|splitvec
op_ne
op_minus
l_int|1
)paren
(brace
r_uint32
id|remainder
suffix:semicolon
id|remainder
op_assign
id|outvecs
(braket
id|splitvec
)braket
dot
id|iov_len
op_minus
id|split_ofs
suffix:semicolon
id|outvecs
(braket
id|splitvec
)braket
dot
id|iov_len
op_assign
id|split_ofs
suffix:semicolon
multiline_comment|/* We did cross a page boundary, so we write some now */
r_if
c_cond
(paren
id|jffs2_cleanmarker_oob
c_func
(paren
id|c
)paren
)paren
id|ret
op_assign
id|c-&gt;mtd
op_member_access_from_pointer
id|writev_ecc
c_func
(paren
id|c-&gt;mtd
comma
id|outvecs
comma
id|splitvec
op_plus
l_int|1
comma
id|outvec_to
comma
op_amp
id|wbuf_retlen
comma
l_int|NULL
comma
id|c-&gt;oobinfo
)paren
suffix:semicolon
r_else
id|ret
op_assign
id|jffs2_flash_direct_writev
c_func
(paren
id|c
comma
id|outvecs
comma
id|splitvec
op_plus
l_int|1
comma
id|outvec_to
comma
op_amp
id|wbuf_retlen
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
op_logical_or
id|wbuf_retlen
op_ne
id|PAGE_DIV
c_func
(paren
id|totlen
)paren
)paren
(brace
multiline_comment|/* At this point we have no problem,&n;&t;&t;&t;   c-&gt;wbuf is empty. &n;&t;&t;&t;*/
op_star
id|retlen
op_assign
id|donelen
suffix:semicolon
r_goto
m_exit
suffix:semicolon
)brace
id|donelen
op_add_assign
id|wbuf_retlen
suffix:semicolon
id|c-&gt;wbuf_ofs
op_assign
id|PAGE_DIV
c_func
(paren
id|outvec_to
)paren
op_plus
id|PAGE_DIV
c_func
(paren
id|totlen
)paren
suffix:semicolon
r_if
c_cond
(paren
id|remainder
)paren
(brace
id|outvecs
(braket
id|splitvec
)braket
dot
id|iov_base
op_add_assign
id|split_ofs
suffix:semicolon
id|outvecs
(braket
id|splitvec
)braket
dot
id|iov_len
op_assign
id|remainder
suffix:semicolon
)brace
r_else
(brace
id|splitvec
op_increment
suffix:semicolon
)brace
)brace
r_else
(brace
id|splitvec
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Now splitvec points to the start of the bits we have to copy&n;&t;   into the wbuf */
id|wbuf_ptr
op_assign
id|c-&gt;wbuf
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|splitvec
OL
id|outvec
suffix:semicolon
id|splitvec
op_increment
)paren
(brace
multiline_comment|/* Don&squot;t copy the wbuf into itself */
r_if
c_cond
(paren
id|outvecs
(braket
id|splitvec
)braket
dot
id|iov_base
op_eq
id|c-&gt;wbuf
)paren
r_continue
suffix:semicolon
id|memcpy
c_func
(paren
id|wbuf_ptr
comma
id|outvecs
(braket
id|splitvec
)braket
dot
id|iov_base
comma
id|outvecs
(braket
id|splitvec
)braket
dot
id|iov_len
)paren
suffix:semicolon
id|wbuf_ptr
op_add_assign
id|outvecs
(braket
id|splitvec
)braket
dot
id|iov_len
suffix:semicolon
id|donelen
op_add_assign
id|outvecs
(braket
id|splitvec
)braket
dot
id|iov_len
suffix:semicolon
)brace
id|c-&gt;wbuf_len
op_assign
id|wbuf_ptr
op_minus
id|c-&gt;wbuf
suffix:semicolon
multiline_comment|/* If there&squot;s a remainder in the wbuf and it&squot;s a non-GC write,&n;&t;   remember that the wbuf affects this ino */
id|alldone
suffix:colon
op_star
id|retlen
op_assign
id|donelen
suffix:semicolon
r_if
c_cond
(paren
id|c-&gt;wbuf_len
op_logical_and
id|ino
)paren
id|jffs2_wbuf_dirties_inode
c_func
(paren
id|c
comma
id|ino
)paren
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
m_exit
suffix:colon
id|up_write
c_func
(paren
op_amp
id|c-&gt;wbuf_sem
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;This is the entry for flash write.&n; *&t;Check, if we work on NAND FLASH, if so build an kvec and write it via vritev&n;*/
DECL|function|jffs2_flash_write
r_int
id|jffs2_flash_write
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
comma
id|loff_t
id|ofs
comma
r_int
id|len
comma
r_int
op_star
id|retlen
comma
r_const
id|u_char
op_star
id|buf
)paren
(brace
r_struct
id|kvec
id|vecs
(braket
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
id|jffs2_can_mark_obsolete
c_func
(paren
id|c
)paren
)paren
r_return
id|c-&gt;mtd
op_member_access_from_pointer
id|write
c_func
(paren
id|c-&gt;mtd
comma
id|ofs
comma
id|len
comma
id|retlen
comma
id|buf
)paren
suffix:semicolon
id|vecs
(braket
l_int|0
)braket
dot
id|iov_base
op_assign
(paren
r_int
r_char
op_star
)paren
id|buf
suffix:semicolon
id|vecs
(braket
l_int|0
)braket
dot
id|iov_len
op_assign
id|len
suffix:semicolon
r_return
id|jffs2_flash_writev
c_func
(paren
id|c
comma
id|vecs
comma
l_int|1
comma
id|ofs
comma
id|retlen
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;Handle readback from writebuffer and ECC failure return&n;*/
DECL|function|jffs2_flash_read
r_int
id|jffs2_flash_read
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
comma
id|loff_t
id|ofs
comma
r_int
id|len
comma
r_int
op_star
id|retlen
comma
id|u_char
op_star
id|buf
)paren
(brace
id|loff_t
id|orbf
op_assign
l_int|0
comma
id|owbf
op_assign
l_int|0
comma
id|lwbf
op_assign
l_int|0
suffix:semicolon
r_int
id|ret
suffix:semicolon
multiline_comment|/* Read flash */
r_if
c_cond
(paren
op_logical_neg
id|jffs2_can_mark_obsolete
c_func
(paren
id|c
)paren
)paren
(brace
id|down_read
c_func
(paren
op_amp
id|c-&gt;wbuf_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|jffs2_cleanmarker_oob
c_func
(paren
id|c
)paren
)paren
id|ret
op_assign
id|c-&gt;mtd
op_member_access_from_pointer
id|read_ecc
c_func
(paren
id|c-&gt;mtd
comma
id|ofs
comma
id|len
comma
id|retlen
comma
id|buf
comma
l_int|NULL
comma
id|c-&gt;oobinfo
)paren
suffix:semicolon
r_else
id|ret
op_assign
id|c-&gt;mtd
op_member_access_from_pointer
id|read
c_func
(paren
id|c-&gt;mtd
comma
id|ofs
comma
id|len
comma
id|retlen
comma
id|buf
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_eq
op_minus
id|EBADMSG
)paren
op_logical_and
(paren
op_star
id|retlen
op_eq
id|len
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;mtd-&gt;read(0x%zx bytes from 0x%llx) returned ECC error&bslash;n&quot;
comma
id|len
comma
id|ofs
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t; * We have the raw data without ECC correction in the buffer, maybe &n;&t;&t;&t; * we are lucky and all data or parts are correct. We check the node.&n;&t;&t;&t; * If data are corrupted node check will sort it out.&n;&t;&t;&t; * We keep this block, it will fail on write or erase and the we&n;&t;&t;&t; * mark it bad. Or should we do that now? But we should give him a chance.&n;&t;&t;&t; * Maybe we had a system crash or power loss before the ecc write or  &n;&t;&t;&t; * a erase was completed.&n;&t;&t;&t; * So we return success. :)&n;&t;&t;&t; */
id|ret
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_else
r_return
id|c-&gt;mtd
op_member_access_from_pointer
id|read
c_func
(paren
id|c-&gt;mtd
comma
id|ofs
comma
id|len
comma
id|retlen
comma
id|buf
)paren
suffix:semicolon
multiline_comment|/* if no writebuffer available or write buffer empty, return */
r_if
c_cond
(paren
op_logical_neg
id|c-&gt;wbuf_pagesize
op_logical_or
op_logical_neg
id|c-&gt;wbuf_len
)paren
r_goto
m_exit
suffix:semicolon
multiline_comment|/* if we read in a different block, return */
r_if
c_cond
(paren
(paren
id|ofs
op_amp
op_complement
(paren
id|c-&gt;sector_size
op_minus
l_int|1
)paren
)paren
op_ne
(paren
id|c-&gt;wbuf_ofs
op_amp
op_complement
(paren
id|c-&gt;sector_size
op_minus
l_int|1
)paren
)paren
)paren
r_goto
m_exit
suffix:semicolon
r_if
c_cond
(paren
id|ofs
op_ge
id|c-&gt;wbuf_ofs
)paren
(brace
id|owbf
op_assign
(paren
id|ofs
op_minus
id|c-&gt;wbuf_ofs
)paren
suffix:semicolon
multiline_comment|/* offset in write buffer */
r_if
c_cond
(paren
id|owbf
OG
id|c-&gt;wbuf_len
)paren
multiline_comment|/* is read beyond write buffer ? */
r_goto
m_exit
suffix:semicolon
id|lwbf
op_assign
id|c-&gt;wbuf_len
op_minus
id|owbf
suffix:semicolon
multiline_comment|/* number of bytes to copy */
r_if
c_cond
(paren
id|lwbf
OG
id|len
)paren
id|lwbf
op_assign
id|len
suffix:semicolon
)brace
r_else
(brace
id|orbf
op_assign
(paren
id|c-&gt;wbuf_ofs
op_minus
id|ofs
)paren
suffix:semicolon
multiline_comment|/* offset in read buffer */
r_if
c_cond
(paren
id|orbf
OG
id|len
)paren
multiline_comment|/* is write beyond write buffer ? */
r_goto
m_exit
suffix:semicolon
id|lwbf
op_assign
id|len
op_minus
id|orbf
suffix:semicolon
multiline_comment|/* number of bytes to copy */
r_if
c_cond
(paren
id|lwbf
OG
id|c-&gt;wbuf_len
)paren
id|lwbf
op_assign
id|c-&gt;wbuf_len
suffix:semicolon
)brace
r_if
c_cond
(paren
id|lwbf
OG
l_int|0
)paren
id|memcpy
c_func
(paren
id|buf
op_plus
id|orbf
comma
id|c-&gt;wbuf
op_plus
id|owbf
comma
id|lwbf
)paren
suffix:semicolon
m_exit
suffix:colon
id|up_read
c_func
(paren
op_amp
id|c-&gt;wbuf_sem
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Check, if the out of band area is empty&n; */
DECL|function|jffs2_check_oob_empty
r_int
id|jffs2_check_oob_empty
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
comma
r_struct
id|jffs2_eraseblock
op_star
id|jeb
comma
r_int
id|mode
)paren
(brace
r_int
r_char
op_star
id|buf
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_int
id|i
comma
id|len
comma
id|page
suffix:semicolon
r_int
id|retlen
suffix:semicolon
r_int
id|oob_size
suffix:semicolon
multiline_comment|/* allocate a buffer for all oob data in this sector */
id|oob_size
op_assign
id|c-&gt;mtd-&gt;oobsize
suffix:semicolon
id|len
op_assign
l_int|4
op_star
id|oob_size
suffix:semicolon
id|buf
op_assign
id|kmalloc
c_func
(paren
id|len
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buf
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;jffs2_check_oob_empty(): allocation of temporary data buffer for oob check failed&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
multiline_comment|/* &n;&t; * if mode = 0, we scan for a total empty oob area, else we have&n;&t; * to take care of the cleanmarker in the first page of the block&n;&t;*/
id|ret
op_assign
id|jffs2_flash_read_oob
c_func
(paren
id|c
comma
id|jeb-&gt;offset
comma
id|len
comma
op_amp
id|retlen
comma
id|buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;jffs2_check_oob_empty(): Read OOB failed %d for block at %08x&bslash;n&quot;
comma
id|ret
comma
id|jeb-&gt;offset
)paren
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|retlen
OL
id|len
)paren
(brace
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;jffs2_check_oob_empty(): Read OOB return short read &quot;
l_string|&quot;(%zd bytes not %d) for block at %08x&bslash;n&quot;
comma
id|retlen
comma
id|len
comma
id|jeb-&gt;offset
)paren
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* Special check for first page */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|oob_size
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* Yeah, we know about the cleanmarker. */
r_if
c_cond
(paren
id|mode
op_logical_and
id|i
op_ge
id|c-&gt;fsdata_pos
op_logical_and
id|i
OL
id|c-&gt;fsdata_pos
op_plus
id|c-&gt;fsdata_len
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|buf
(braket
id|i
)braket
op_ne
l_int|0xFF
)paren
(brace
id|D2
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Found %02x at %x in OOB for %08x&bslash;n&quot;
comma
id|buf
(braket
id|page
op_plus
id|i
)braket
comma
id|page
op_plus
id|i
comma
id|jeb-&gt;offset
)paren
)paren
suffix:semicolon
id|ret
op_assign
l_int|1
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
)brace
multiline_comment|/* we know, we are aligned :) */
r_for
c_loop
(paren
id|page
op_assign
id|oob_size
suffix:semicolon
id|page
OL
id|len
suffix:semicolon
id|page
op_add_assign
r_sizeof
(paren
r_int
)paren
)paren
(brace
r_int
r_int
id|dat
op_assign
op_star
(paren
r_int
r_int
op_star
)paren
(paren
op_amp
id|buf
(braket
id|page
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dat
op_ne
op_minus
l_int|1
)paren
(brace
id|ret
op_assign
l_int|1
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
)brace
id|out
suffix:colon
id|kfree
c_func
(paren
id|buf
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n;*&t;Scan for a valid cleanmarker and for bad blocks&n;*&t;For virtual blocks (concatenated physical blocks) check the cleanmarker&n;*&t;only in the first page of the first physical block, but scan for bad blocks in all&n;*&t;physical blocks&n;*/
DECL|function|jffs2_check_nand_cleanmarker
r_int
id|jffs2_check_nand_cleanmarker
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
comma
r_struct
id|jffs2_eraseblock
op_star
id|jeb
)paren
(brace
r_struct
id|jffs2_unknown_node
id|n
suffix:semicolon
r_int
r_char
id|buf
(braket
l_int|2
op_star
id|NAND_MAX_OOBSIZE
)braket
suffix:semicolon
r_int
r_char
op_star
id|p
suffix:semicolon
r_int
id|ret
comma
id|i
comma
id|cnt
comma
id|retval
op_assign
l_int|0
suffix:semicolon
r_int
id|retlen
comma
id|offset
suffix:semicolon
r_int
id|oob_size
suffix:semicolon
id|offset
op_assign
id|jeb-&gt;offset
suffix:semicolon
id|oob_size
op_assign
id|c-&gt;mtd-&gt;oobsize
suffix:semicolon
multiline_comment|/* Loop through the physical blocks */
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
suffix:semicolon
id|cnt
OL
(paren
id|c-&gt;sector_size
op_div
id|c-&gt;mtd-&gt;erasesize
)paren
suffix:semicolon
id|cnt
op_increment
)paren
(brace
multiline_comment|/* Check first if the block is bad. */
r_if
c_cond
(paren
id|c-&gt;mtd-&gt;block_isbad
(paren
id|c-&gt;mtd
comma
id|offset
)paren
)paren
(brace
id|D1
(paren
id|printk
(paren
id|KERN_WARNING
l_string|&quot;jffs2_check_nand_cleanmarker(): Bad block at %08x&bslash;n&quot;
comma
id|jeb-&gt;offset
)paren
)paren
suffix:semicolon
r_return
l_int|2
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;   *    We read oob data from page 0 and 1 of the block.&n;&t;&t;   *    page 0 contains cleanmarker and badblock info&n;&t;&t;   *    page 1 contains failure count of this block&n;&t;&t; */
id|ret
op_assign
id|c-&gt;mtd-&gt;read_oob
(paren
id|c-&gt;mtd
comma
id|offset
comma
id|oob_size
op_lshift
l_int|1
comma
op_amp
id|retlen
comma
id|buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|D1
(paren
id|printk
(paren
id|KERN_WARNING
l_string|&quot;jffs2_check_nand_cleanmarker(): Read OOB failed %d for block at %08x&bslash;n&quot;
comma
id|ret
comma
id|jeb-&gt;offset
)paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_if
c_cond
(paren
id|retlen
OL
(paren
id|oob_size
op_lshift
l_int|1
)paren
)paren
(brace
id|D1
(paren
id|printk
(paren
id|KERN_WARNING
l_string|&quot;jffs2_check_nand_cleanmarker(): Read OOB return short read (%zd bytes not %d) for block at %08x&bslash;n&quot;
comma
id|retlen
comma
id|oob_size
op_lshift
l_int|1
comma
id|jeb-&gt;offset
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/* Check cleanmarker only on the first physical block */
r_if
c_cond
(paren
op_logical_neg
id|cnt
)paren
(brace
id|n.magic
op_assign
id|cpu_to_je16
(paren
id|JFFS2_MAGIC_BITMASK
)paren
suffix:semicolon
id|n.nodetype
op_assign
id|cpu_to_je16
(paren
id|JFFS2_NODETYPE_CLEANMARKER
)paren
suffix:semicolon
id|n.totlen
op_assign
id|cpu_to_je32
(paren
l_int|8
)paren
suffix:semicolon
id|p
op_assign
(paren
r_int
r_char
op_star
)paren
op_amp
id|n
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|c-&gt;fsdata_len
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|buf
(braket
id|c-&gt;fsdata_pos
op_plus
id|i
)braket
op_ne
id|p
(braket
id|i
)braket
)paren
(brace
id|retval
op_assign
l_int|1
suffix:semicolon
)brace
)brace
id|D1
c_func
(paren
r_if
(paren
id|retval
op_eq
l_int|1
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;jffs2_check_nand_cleanmarker(): Cleanmarker node not detected in block at %08x&bslash;n&quot;
comma
id|jeb-&gt;offset
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;OOB at %08x was &quot;
comma
id|offset
)paren
suffix:semicolon
r_for
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|oob_size
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%02x &quot;
comma
id|buf
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
)paren
)brace
id|offset
op_add_assign
id|c-&gt;mtd-&gt;erasesize
suffix:semicolon
)brace
r_return
id|retval
suffix:semicolon
)brace
DECL|function|jffs2_write_nand_cleanmarker
r_int
id|jffs2_write_nand_cleanmarker
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
comma
r_struct
id|jffs2_eraseblock
op_star
id|jeb
)paren
(brace
r_struct
id|jffs2_unknown_node
id|n
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_int
id|retlen
suffix:semicolon
id|n.magic
op_assign
id|cpu_to_je16
c_func
(paren
id|JFFS2_MAGIC_BITMASK
)paren
suffix:semicolon
id|n.nodetype
op_assign
id|cpu_to_je16
c_func
(paren
id|JFFS2_NODETYPE_CLEANMARKER
)paren
suffix:semicolon
id|n.totlen
op_assign
id|cpu_to_je32
c_func
(paren
l_int|8
)paren
suffix:semicolon
id|ret
op_assign
id|jffs2_flash_write_oob
c_func
(paren
id|c
comma
id|jeb-&gt;offset
op_plus
id|c-&gt;fsdata_pos
comma
id|c-&gt;fsdata_len
comma
op_amp
id|retlen
comma
(paren
r_int
r_char
op_star
)paren
op_amp
id|n
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;jffs2_write_nand_cleanmarker(): Write failed for block at %08x: error %d&bslash;n&quot;
comma
id|jeb-&gt;offset
comma
id|ret
)paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_if
c_cond
(paren
id|retlen
op_ne
id|c-&gt;fsdata_len
)paren
(brace
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;jffs2_write_nand_cleanmarker(): Short write for block at %08x: %zd not %d&bslash;n&quot;
comma
id|jeb-&gt;offset
comma
id|retlen
comma
id|c-&gt;fsdata_len
)paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* &n; * On NAND we try to mark this block bad. If the block was erased more&n; * than MAX_ERASE_FAILURES we mark it finaly bad.&n; * Don&squot;t care about failures. This block remains on the erase-pending&n; * or badblock list as long as nobody manipulates the flash with&n; * a bootloader or something like that.&n; */
DECL|function|jffs2_write_nand_badblock
r_int
id|jffs2_write_nand_badblock
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
comma
r_struct
id|jffs2_eraseblock
op_star
id|jeb
comma
r_uint32
id|bad_offset
)paren
(brace
r_int
id|ret
suffix:semicolon
multiline_comment|/* if the count is &lt; max, we try to write the counter to the 2nd page oob area */
r_if
c_cond
(paren
op_increment
id|jeb-&gt;bad_count
OL
id|MAX_ERASE_FAILURES
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|c-&gt;mtd-&gt;block_markbad
)paren
r_return
l_int|1
suffix:semicolon
singleline_comment|// What else can we do?
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;jffs2_write_nand_badblock(): Marking bad block at %08x&bslash;n&quot;
comma
id|bad_offset
)paren
)paren
suffix:semicolon
id|ret
op_assign
id|c-&gt;mtd
op_member_access_from_pointer
id|block_markbad
c_func
(paren
id|c-&gt;mtd
comma
id|bad_offset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;jffs2_write_nand_badblock(): Write failed for block at %08x: error %d&bslash;n&quot;
comma
id|jeb-&gt;offset
comma
id|ret
)paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|macro|NAND_JFFS2_OOB16_FSDALEN
mdefine_line|#define NAND_JFFS2_OOB16_FSDALEN&t;8
DECL|variable|jffs2_oobinfo_docecc
r_static
r_struct
id|nand_oobinfo
id|jffs2_oobinfo_docecc
op_assign
(brace
dot
id|useecc
op_assign
id|MTD_NANDECC_PLACE
comma
dot
id|eccbytes
op_assign
l_int|6
comma
dot
id|eccpos
op_assign
(brace
l_int|0
comma
l_int|1
comma
l_int|2
comma
l_int|3
comma
l_int|4
comma
l_int|5
)brace
)brace
suffix:semicolon
DECL|function|jffs2_nand_set_oobinfo
r_static
r_int
id|jffs2_nand_set_oobinfo
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
)paren
(brace
r_struct
id|nand_oobinfo
op_star
id|oinfo
op_assign
op_amp
id|c-&gt;mtd-&gt;oobinfo
suffix:semicolon
multiline_comment|/* Do this only, if we have an oob buffer */
r_if
c_cond
(paren
op_logical_neg
id|c-&gt;mtd-&gt;oobsize
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Cleanmarker is out-of-band, so inline size zero */
id|c-&gt;cleanmarker_size
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Should we use autoplacement ? */
r_if
c_cond
(paren
id|oinfo
op_logical_and
id|oinfo-&gt;useecc
op_eq
id|MTD_NANDECC_AUTOPLACE
)paren
(brace
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;JFFS2 using autoplace on NAND&bslash;n&quot;
)paren
)paren
suffix:semicolon
multiline_comment|/* Get the position of the free bytes */
r_if
c_cond
(paren
op_logical_neg
id|oinfo-&gt;oobfree
(braket
l_int|0
)braket
(braket
l_int|1
)braket
)paren
(brace
id|printk
(paren
id|KERN_WARNING
l_string|&quot;jffs2_nand_set_oobinfo(): Eeep. Autoplacement selected and no empty space in oob&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOSPC
suffix:semicolon
)brace
id|c-&gt;fsdata_pos
op_assign
id|oinfo-&gt;oobfree
(braket
l_int|0
)braket
(braket
l_int|0
)braket
suffix:semicolon
id|c-&gt;fsdata_len
op_assign
id|oinfo-&gt;oobfree
(braket
l_int|0
)braket
(braket
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
id|c-&gt;fsdata_len
OG
l_int|8
)paren
id|c-&gt;fsdata_len
op_assign
l_int|8
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* This is just a legacy fallback and should go away soon */
r_switch
c_cond
(paren
id|c-&gt;mtd-&gt;ecctype
)paren
(brace
r_case
id|MTD_ECC_RS_DiskOnChip
suffix:colon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;JFFS2 using DiskOnChip hardware ECC without autoplacement. Fix it!&bslash;n&quot;
)paren
suffix:semicolon
id|c-&gt;oobinfo
op_assign
op_amp
id|jffs2_oobinfo_docecc
suffix:semicolon
id|c-&gt;fsdata_pos
op_assign
l_int|6
suffix:semicolon
id|c-&gt;fsdata_len
op_assign
id|NAND_JFFS2_OOB16_FSDALEN
suffix:semicolon
id|c-&gt;badblock_pos
op_assign
l_int|15
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;JFFS2 on NAND. No autoplacment info found&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|jffs2_nand_flash_setup
r_int
id|jffs2_nand_flash_setup
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
)paren
(brace
r_int
id|res
suffix:semicolon
multiline_comment|/* Initialise write buffer */
id|init_rwsem
c_func
(paren
op_amp
id|c-&gt;wbuf_sem
)paren
suffix:semicolon
id|c-&gt;wbuf_pagesize
op_assign
id|c-&gt;mtd-&gt;oobblock
suffix:semicolon
id|c-&gt;wbuf_ofs
op_assign
l_int|0xFFFFFFFF
suffix:semicolon
id|c-&gt;wbuf
op_assign
id|kmalloc
c_func
(paren
id|c-&gt;wbuf_pagesize
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|c-&gt;wbuf
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|res
op_assign
id|jffs2_nand_set_oobinfo
c_func
(paren
id|c
)paren
suffix:semicolon
macro_line|#ifdef BREAKME
r_if
c_cond
(paren
op_logical_neg
id|brokenbuf
)paren
id|brokenbuf
op_assign
id|kmalloc
c_func
(paren
id|c-&gt;wbuf_pagesize
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|brokenbuf
)paren
(brace
id|kfree
c_func
(paren
id|c-&gt;wbuf
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|memset
c_func
(paren
id|brokenbuf
comma
l_int|0xdb
comma
id|c-&gt;wbuf_pagesize
)paren
suffix:semicolon
macro_line|#endif
r_return
id|res
suffix:semicolon
)brace
DECL|function|jffs2_nand_flash_cleanup
r_void
id|jffs2_nand_flash_cleanup
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
)paren
(brace
id|kfree
c_func
(paren
id|c-&gt;wbuf
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_JFFS2_FS_NOR_ECC
DECL|function|jffs2_nor_ecc_flash_setup
r_int
id|jffs2_nor_ecc_flash_setup
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
)paren
(brace
multiline_comment|/* Cleanmarker is actually larger on the flashes */
id|c-&gt;cleanmarker_size
op_assign
l_int|16
suffix:semicolon
multiline_comment|/* Initialize write buffer */
id|init_rwsem
c_func
(paren
op_amp
id|c-&gt;wbuf_sem
)paren
suffix:semicolon
id|c-&gt;wbuf_pagesize
op_assign
id|c-&gt;mtd-&gt;eccsize
suffix:semicolon
id|c-&gt;wbuf_ofs
op_assign
l_int|0xFFFFFFFF
suffix:semicolon
id|c-&gt;wbuf
op_assign
id|kmalloc
c_func
(paren
id|c-&gt;wbuf_pagesize
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|c-&gt;wbuf
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|jffs2_nor_ecc_flash_cleanup
r_void
id|jffs2_nor_ecc_flash_cleanup
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
)paren
(brace
id|kfree
c_func
(paren
id|c-&gt;wbuf
)paren
suffix:semicolon
)brace
macro_line|#endif
eof
