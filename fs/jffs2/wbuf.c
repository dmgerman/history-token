multiline_comment|/*&n; * JFFS2 -- Journalling Flash File System, Version 2.&n; *&n; * Copyright (C) 2001, 2002 Red Hat, Inc.&n; *&n; * Created by David Woodhouse &lt;dwmw2@cambridge.redhat.com&gt;&n; *&n; * For licensing information, see the file &squot;LICENCE&squot; in this directory.&n; *&n; * $Id: wbuf.c,v 1.30 2003/02/19 17:48:49 gleixner Exp $&n; *&n; */
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/mtd/mtd.h&gt;
macro_line|#include &lt;linux/crc32.h&gt;
macro_line|#include &lt;linux/mtd/nand.h&gt;
macro_line|#include &quot;nodelist.h&quot;
multiline_comment|/* max. erase failures before we mark a block bad */
DECL|macro|MAX_ERASE_FAILURES
mdefine_line|#define MAX_ERASE_FAILURES &t;5
multiline_comment|/* two seconds timeout for timed wbuf-flushing */
DECL|macro|WBUF_FLUSH_TIMEOUT
mdefine_line|#define WBUF_FLUSH_TIMEOUT&t;2 * HZ
DECL|macro|JFFS2_OOB_ECCPOS0
mdefine_line|#define JFFS2_OOB_ECCPOS0&t;&t;0
DECL|macro|JFFS2_OOB_ECCPOS1
mdefine_line|#define JFFS2_OOB_ECCPOS1&t;&t;1
DECL|macro|JFFS2_OOB_ECCPOS2
mdefine_line|#define JFFS2_OOB_ECCPOS2&t;&t;2
DECL|macro|JFFS2_OOB_ECCPOS3
mdefine_line|#define JFFS2_OOB_ECCPOS3&t;&t;3
DECL|macro|JFFS2_OOB_ECCPOS4
mdefine_line|#define JFFS2_OOB_ECCPOS4&t;&t;6
DECL|macro|JFFS2_OOB_ECCPOS5
mdefine_line|#define JFFS2_OOB_ECCPOS5&t;&t;7
DECL|macro|NAND_JFFS2_OOB8_FSDAPOS
mdefine_line|#define NAND_JFFS2_OOB8_FSDAPOS&t;&t;6
DECL|macro|NAND_JFFS2_OOB16_FSDAPOS
mdefine_line|#define NAND_JFFS2_OOB16_FSDAPOS&t;8
DECL|macro|NAND_JFFS2_OOB8_FSDALEN
mdefine_line|#define NAND_JFFS2_OOB8_FSDALEN&t;&t;2
DECL|macro|NAND_JFFS2_OOB16_FSDALEN
mdefine_line|#define NAND_JFFS2_OOB16_FSDALEN&t;8
DECL|variable|jffs2_oobinfo
r_struct
id|nand_oobinfo
id|jffs2_oobinfo
op_assign
(brace
dot
id|useecc
op_assign
l_int|1
comma
dot
id|eccpos
op_assign
(brace
id|JFFS2_OOB_ECCPOS0
comma
id|JFFS2_OOB_ECCPOS1
comma
id|JFFS2_OOB_ECCPOS2
comma
id|JFFS2_OOB_ECCPOS3
comma
id|JFFS2_OOB_ECCPOS4
comma
id|JFFS2_OOB_ECCPOS5
)brace
)brace
suffix:semicolon
DECL|function|jffs2_refile_wbuf_blocks
r_static
r_inline
r_void
id|jffs2_refile_wbuf_blocks
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
)paren
(brace
r_struct
id|list_head
op_star
id|this
comma
op_star
id|next
suffix:semicolon
r_static
r_int
id|n
suffix:semicolon
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|c-&gt;erasable_pending_wbuf_list
)paren
)paren
r_return
suffix:semicolon
id|list_for_each_safe
c_func
(paren
id|this
comma
id|next
comma
op_amp
id|c-&gt;erasable_pending_wbuf_list
)paren
(brace
r_struct
id|jffs2_eraseblock
op_star
id|jeb
op_assign
id|list_entry
c_func
(paren
id|this
comma
r_struct
id|jffs2_eraseblock
comma
id|list
)paren
suffix:semicolon
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Removing eraseblock at 0x%08x from erasable_pending_wbuf_list...&bslash;n&quot;
comma
id|jeb-&gt;offset
)paren
)paren
suffix:semicolon
id|list_del
c_func
(paren
id|this
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|jiffies
op_plus
(paren
id|n
op_increment
)paren
)paren
op_amp
l_int|127
)paren
(brace
multiline_comment|/* Most of the time, we just erase it immediately. Otherwise we&n;&t;&t;&t;   spend ages scanning it on mount, etc. */
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;...and adding to erase_pending_list&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|jeb-&gt;list
comma
op_amp
id|c-&gt;erase_pending_list
)paren
suffix:semicolon
id|c-&gt;nr_erasing_blocks
op_increment
suffix:semicolon
id|jffs2_erase_pending_trigger
c_func
(paren
id|c
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Sometimes, however, we leave it elsewhere so it doesn&squot;t get&n;&t;&t;&t;   immediately reused, and we spread the load a bit. */
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;...and adding to erasable_list&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|jeb-&gt;list
comma
op_amp
id|c-&gt;erasable_list
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* &n;*&t;Timed flushing of wbuf. If we have no consecutive write to wbuf, within&t;&n;*&t;the specified time, we flush the contents with padding !&n;*/
DECL|function|jffs2_wbuf_timeout
r_void
id|jffs2_wbuf_timeout
(paren
r_int
r_int
id|data
)paren
(brace
r_struct
id|jffs2_sb_info
op_star
id|c
op_assign
(paren
r_struct
id|jffs2_sb_info
op_star
)paren
id|data
suffix:semicolon
multiline_comment|/* &n;&t;* Wake up the flush process, we need process context to have the right &n;&t;* to sleep on flash write&n;&t;*/
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;jffs2_wbuf_timeout(): timer expired&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|schedule_work
c_func
(paren
op_amp
id|c-&gt;wbuf_task
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;*&t;Process for timed wbuf flush&n;*&n;*&t;FIXME What happens, if we have a write failure there ????&n;*/
DECL|function|jffs2_wbuf_process
r_void
id|jffs2_wbuf_process
(paren
r_void
op_star
id|data
)paren
(brace
r_struct
id|jffs2_sb_info
op_star
id|c
op_assign
(paren
r_struct
id|jffs2_sb_info
op_star
)paren
id|data
suffix:semicolon
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;jffs2_wbuf_process() entered&bslash;n&quot;
)paren
)paren
suffix:semicolon
multiline_comment|/* Check, if the timer is active again */
r_if
c_cond
(paren
id|timer_pending
(paren
op_amp
id|c-&gt;wbuf_timer
)paren
)paren
(brace
id|D1
c_func
(paren
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;Nothing to do, timer is active again&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|down_trylock
c_func
(paren
op_amp
id|c-&gt;alloc_sem
)paren
)paren
(brace
multiline_comment|/* If someone else has the alloc_sem, they&squot;re about to&n;&t;&t;   write anyway. So no need to waste space by&n;&t;&t;   padding */
id|D1
c_func
(paren
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;jffs2_wbuf_process() alloc_sem already occupied&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|D1
c_func
(paren
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;jffs2_wbuf_process() alloc_sem got&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|c-&gt;nextblock
)paren
(brace
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;jffs2_wbuf_process(): nextblock NULL, nothing to do&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c-&gt;wbuf_len
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;jffs2_wbuf_process(): c-&gt;wbuf_len is 0x%03x but nextblock is NULL!&bslash;n&quot;
comma
id|c-&gt;wbuf_len
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|c-&gt;alloc_sem
)paren
suffix:semicolon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/* if !c-&gt;nextblock then the tail will have got flushed from&n;&t;   jffs2_do_reserve_space() anyway. */
r_if
c_cond
(paren
id|c-&gt;nextblock
)paren
(brace
id|jffs2_flush_wbuf
c_func
(paren
id|c
comma
l_int|2
)paren
suffix:semicolon
)brace
multiline_comment|/* pad and adjust nextblock */
id|up
c_func
(paren
op_amp
id|c-&gt;alloc_sem
)paren
suffix:semicolon
)brace
multiline_comment|/* Meaning of pad argument:&n;   0: Do not pad. Probably pointless - we only ever use this when we can&squot;t pad anyway.&n;   1: Pad, do not adjust nextblock free_size&n;   2: Pad, adjust nextblock free_size&n;*/
DECL|function|jffs2_flush_wbuf
r_int
id|jffs2_flush_wbuf
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
comma
r_int
id|pad
)paren
(brace
r_int
id|ret
suffix:semicolon
r_int
id|retlen
suffix:semicolon
multiline_comment|/* Nothing to do if not NAND flash. In particular, we shouldn&squot;t&n;&t;   del_timer() the timer we never initialised. */
r_if
c_cond
(paren
id|jffs2_can_mark_obsolete
c_func
(paren
id|c
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|down_trylock
c_func
(paren
op_amp
id|c-&gt;alloc_sem
)paren
)paren
(brace
id|up
c_func
(paren
op_amp
id|c-&gt;alloc_sem
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;jffs2_flush_wbuf() called with alloc_sem not locked!&bslash;n&quot;
)paren
suffix:semicolon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* delete a eventually started timed wbuf flush */
id|del_timer_sync
c_func
(paren
op_amp
id|c-&gt;wbuf_timer
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|c-&gt;wbuf
op_logical_or
op_logical_neg
id|c-&gt;wbuf_len
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* claim remaining space on the page&n;&t;   this happens, if we have a change to a new block,&n;&t;   or if fsync forces us to flush the writebuffer.&n;&t;   if we have a switch to next page, we will not have&n;&t;   enough remaining space for this. &n;&t;*/
r_if
c_cond
(paren
id|pad
)paren
(brace
id|c-&gt;wbuf_len
op_assign
id|PAD
c_func
(paren
id|c-&gt;wbuf_len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c-&gt;wbuf_len
op_plus
r_sizeof
(paren
r_struct
id|jffs2_unknown_node
)paren
OL
id|c-&gt;wbuf_pagesize
)paren
(brace
r_struct
id|jffs2_unknown_node
op_star
id|padnode
op_assign
(paren
r_void
op_star
)paren
(paren
id|c-&gt;wbuf
op_plus
id|c-&gt;wbuf_len
)paren
suffix:semicolon
id|padnode-&gt;magic
op_assign
id|cpu_to_je16
c_func
(paren
id|JFFS2_MAGIC_BITMASK
)paren
suffix:semicolon
id|padnode-&gt;nodetype
op_assign
id|cpu_to_je16
c_func
(paren
id|JFFS2_NODETYPE_PADDING
)paren
suffix:semicolon
id|padnode-&gt;totlen
op_assign
id|cpu_to_je32
c_func
(paren
id|c-&gt;wbuf_pagesize
op_minus
id|c-&gt;wbuf_len
)paren
suffix:semicolon
id|padnode-&gt;hdr_crc
op_assign
id|cpu_to_je32
c_func
(paren
id|crc32
c_func
(paren
l_int|0
comma
id|padnode
comma
r_sizeof
(paren
op_star
id|padnode
)paren
op_minus
l_int|4
)paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* else jffs2_flash_writev has actually filled in the rest of the&n;&t;   buffer for us, and will deal with the node refs etc. later. */
id|ret
op_assign
id|c-&gt;mtd
op_member_access_from_pointer
id|write_ecc
c_func
(paren
id|c-&gt;mtd
comma
id|c-&gt;wbuf_ofs
comma
id|c-&gt;wbuf_pagesize
comma
op_amp
id|retlen
comma
id|c-&gt;wbuf
comma
l_int|NULL
comma
op_amp
id|jffs2_oobinfo
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_logical_or
id|retlen
op_ne
id|c-&gt;wbuf_pagesize
)paren
(brace
r_if
c_cond
(paren
id|ret
)paren
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;jffs2_flush_wbuf(): Write failed with %d&bslash;n&quot;
comma
id|ret
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;jffs2_flush_wbuf(): Write was short: %zd instead of %d&bslash;n&quot;
comma
id|retlen
comma
id|c-&gt;wbuf_pagesize
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EIO
suffix:semicolon
multiline_comment|/* CHECKME NAND &n;&t;&t;   So that the caller knows what happened. If&n;&t;&t;   we were called from jffs2_flash_writev(), it&squot;ll&n;&t;&t;   know to return failure and _its_ caller will&n;&t;&t;   try again. writev gives back to jffs2_write_xxx &n;&t;&t;   in write.c. There are the real fixme&squot;s&n;&t;&t; */
multiline_comment|/*  FIXME NAND&n;&t;&t;   If we were called from GC or fsync, there&squot;s no repair kit yet&n;&t;&t;*/
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* Adjusting free size of next block only, if it&squot;s called from fsync ! */
r_if
c_cond
(paren
id|pad
op_eq
l_int|2
)paren
(brace
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;jffs2_flush_wbuf() adjusting free_size of c-&gt;nextblock&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|c-&gt;erase_completion_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|c-&gt;nextblock
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* wbuf_pagesize - wbuf_len is the amount of space that&squot;s to be &n;&t;&t;   padded. If there is less free space in the block than that,&n;&t;&t;   something screwed up */
r_if
c_cond
(paren
id|c-&gt;nextblock-&gt;free_size
OL
(paren
id|c-&gt;wbuf_pagesize
op_minus
id|c-&gt;wbuf_len
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;jffs2_flush_wbuf(): Accounting error. wbuf at 0x%08x has 0x%03x bytes, 0x%03x left.&bslash;n&quot;
comma
id|c-&gt;wbuf_ofs
comma
id|c-&gt;wbuf_len
comma
id|c-&gt;wbuf_pagesize
op_minus
id|c-&gt;wbuf_len
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;jffs2_flush_wbuf(): But free_size for block at 0x%08x is only 0x%08x&bslash;n&quot;
comma
id|c-&gt;nextblock-&gt;offset
comma
id|c-&gt;nextblock-&gt;free_size
)paren
suffix:semicolon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
id|c-&gt;nextblock-&gt;free_size
op_sub_assign
(paren
id|c-&gt;wbuf_pagesize
op_minus
id|c-&gt;wbuf_len
)paren
suffix:semicolon
id|c-&gt;free_size
op_sub_assign
(paren
id|c-&gt;wbuf_pagesize
op_minus
id|c-&gt;wbuf_len
)paren
suffix:semicolon
id|c-&gt;nextblock-&gt;wasted_size
op_add_assign
(paren
id|c-&gt;wbuf_pagesize
op_minus
id|c-&gt;wbuf_len
)paren
suffix:semicolon
id|c-&gt;wasted_size
op_add_assign
(paren
id|c-&gt;wbuf_pagesize
op_minus
id|c-&gt;wbuf_len
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|c-&gt;erase_completion_lock
)paren
suffix:semicolon
)brace
multiline_comment|/* Stick any now-obsoleted blocks on the erase_pending_list */
id|spin_lock
c_func
(paren
op_amp
id|c-&gt;erase_completion_lock
)paren
suffix:semicolon
id|jffs2_refile_wbuf_blocks
c_func
(paren
id|c
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|c-&gt;erase_completion_lock
)paren
suffix:semicolon
id|memset
c_func
(paren
id|c-&gt;wbuf
comma
l_int|0xff
comma
id|c-&gt;wbuf_pagesize
)paren
suffix:semicolon
multiline_comment|/* adjust write buffer offset, else we get a non contigous write bug */
id|c-&gt;wbuf_ofs
op_add_assign
id|c-&gt;wbuf_pagesize
suffix:semicolon
id|c-&gt;wbuf_len
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|macro|PAGE_DIV
mdefine_line|#define PAGE_DIV(x) ( (x) &amp; (~(c-&gt;wbuf_pagesize - 1)) )
DECL|macro|PAGE_MOD
mdefine_line|#define PAGE_MOD(x) ( (x) &amp; (c-&gt;wbuf_pagesize - 1) )
DECL|function|jffs2_flash_writev
r_int
id|jffs2_flash_writev
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
comma
r_const
r_struct
id|iovec
op_star
id|invecs
comma
r_int
r_int
id|count
comma
id|loff_t
id|to
comma
r_int
op_star
id|retlen
)paren
(brace
r_struct
id|iovec
id|outvecs
(braket
l_int|3
)braket
suffix:semicolon
r_uint32
id|totlen
op_assign
l_int|0
suffix:semicolon
r_uint32
id|split_ofs
op_assign
l_int|0
suffix:semicolon
r_uint32
id|old_totlen
suffix:semicolon
r_int
id|ret
comma
id|splitvec
op_assign
op_minus
l_int|1
suffix:semicolon
r_int
id|invec
comma
id|outvec
suffix:semicolon
r_int
id|wbuf_retlen
suffix:semicolon
r_int
r_char
op_star
id|wbuf_ptr
suffix:semicolon
r_int
id|donelen
op_assign
l_int|0
suffix:semicolon
r_uint32
id|outvec_to
op_assign
id|to
suffix:semicolon
multiline_comment|/* If not NAND flash, don&squot;t bother */
r_if
c_cond
(paren
op_logical_neg
id|c-&gt;wbuf
)paren
r_return
id|jffs2_flash_direct_writev
c_func
(paren
id|c
comma
id|invecs
comma
id|count
comma
id|to
comma
id|retlen
)paren
suffix:semicolon
multiline_comment|/* If wbuf_ofs is not initialized, set it to target address */
r_if
c_cond
(paren
id|c-&gt;wbuf_ofs
op_eq
l_int|0xFFFFFFFF
)paren
(brace
id|c-&gt;wbuf_ofs
op_assign
id|PAGE_DIV
c_func
(paren
id|to
)paren
suffix:semicolon
id|c-&gt;wbuf_len
op_assign
id|PAGE_MOD
c_func
(paren
id|to
)paren
suffix:semicolon
id|memset
c_func
(paren
id|c-&gt;wbuf
comma
l_int|0xff
comma
id|c-&gt;wbuf_pagesize
)paren
suffix:semicolon
)brace
multiline_comment|/* Sanity checks on target address. &n;&t;   It&squot;s permitted to write at PAD(c-&gt;wbuf_len+c-&gt;wbuf_ofs), &n;&t;   and it&squot;s permitted to write at the beginning of a new &n;&t;   erase block. Anything else, and you die.&n;&t;   New block starts at xxx000c (0-b = block header)&n;&t;*/
r_if
c_cond
(paren
(paren
id|to
op_amp
op_complement
(paren
id|c-&gt;sector_size
op_minus
l_int|1
)paren
)paren
op_ne
(paren
id|c-&gt;wbuf_ofs
op_amp
op_complement
(paren
id|c-&gt;sector_size
op_minus
l_int|1
)paren
)paren
)paren
(brace
multiline_comment|/* It&squot;s a write to a new block */
r_if
c_cond
(paren
id|c-&gt;wbuf_len
)paren
(brace
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;jffs2_flash_writev() to 0x%lx causes flush of wbuf at 0x%08x&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|to
comma
id|c-&gt;wbuf_ofs
)paren
)paren
suffix:semicolon
id|ret
op_assign
id|jffs2_flush_wbuf
c_func
(paren
id|c
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
multiline_comment|/* the underlying layer has to check wbuf_len to do the cleanup */
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;jffs2_flush_wbuf() called from jffs2_flash_writev() failed %d&bslash;n&quot;
comma
id|ret
)paren
)paren
suffix:semicolon
op_star
id|retlen
op_assign
l_int|0
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
)brace
multiline_comment|/* set pointer to new block */
id|c-&gt;wbuf_ofs
op_assign
id|PAGE_DIV
c_func
(paren
id|to
)paren
suffix:semicolon
id|c-&gt;wbuf_len
op_assign
id|PAGE_MOD
c_func
(paren
id|to
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|to
op_ne
id|PAD
c_func
(paren
id|c-&gt;wbuf_ofs
op_plus
id|c-&gt;wbuf_len
)paren
)paren
(brace
multiline_comment|/* We&squot;re not writing immediately after the writebuffer. Bad. */
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;jffs2_flash_writev(): Non-contiguous write to %08lx&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|to
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c-&gt;wbuf_len
)paren
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;wbuf was previously %08x-%08x&bslash;n&quot;
comma
id|c-&gt;wbuf_ofs
comma
id|c-&gt;wbuf_ofs
op_plus
id|c-&gt;wbuf_len
)paren
suffix:semicolon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Note outvecs[3] above. We know count is never greater than 2 */
r_if
c_cond
(paren
id|count
OG
l_int|2
)paren
(brace
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;jffs2_flash_writev(): count is %ld&bslash;n&quot;
comma
id|count
)paren
suffix:semicolon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
id|invec
op_assign
l_int|0
suffix:semicolon
id|outvec
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Fill writebuffer first, if already in use */
r_if
c_cond
(paren
id|c-&gt;wbuf_len
)paren
(brace
r_uint32
id|invec_ofs
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* adjust alignment offset */
r_if
c_cond
(paren
id|c-&gt;wbuf_len
op_ne
id|PAGE_MOD
c_func
(paren
id|to
)paren
)paren
(brace
id|c-&gt;wbuf_len
op_assign
id|PAGE_MOD
c_func
(paren
id|to
)paren
suffix:semicolon
multiline_comment|/* take care of alignment to next page */
r_if
c_cond
(paren
op_logical_neg
id|c-&gt;wbuf_len
)paren
id|c-&gt;wbuf_len
op_assign
id|c-&gt;wbuf_pagesize
suffix:semicolon
)brace
r_while
c_loop
(paren
id|c-&gt;wbuf_len
OL
id|c-&gt;wbuf_pagesize
)paren
(brace
r_uint32
id|thislen
suffix:semicolon
r_if
c_cond
(paren
id|invec
op_eq
id|count
)paren
r_goto
id|alldone
suffix:semicolon
id|thislen
op_assign
id|c-&gt;wbuf_pagesize
op_minus
id|c-&gt;wbuf_len
suffix:semicolon
r_if
c_cond
(paren
id|thislen
op_ge
id|invecs
(braket
id|invec
)braket
dot
id|iov_len
)paren
id|thislen
op_assign
id|invecs
(braket
id|invec
)braket
dot
id|iov_len
suffix:semicolon
id|invec_ofs
op_assign
id|thislen
suffix:semicolon
id|memcpy
c_func
(paren
id|c-&gt;wbuf
op_plus
id|c-&gt;wbuf_len
comma
id|invecs
(braket
id|invec
)braket
dot
id|iov_base
comma
id|thislen
)paren
suffix:semicolon
id|c-&gt;wbuf_len
op_add_assign
id|thislen
suffix:semicolon
id|donelen
op_add_assign
id|thislen
suffix:semicolon
multiline_comment|/* Get next invec, if actual did not fill the buffer */
r_if
c_cond
(paren
id|c-&gt;wbuf_len
OL
id|c-&gt;wbuf_pagesize
)paren
id|invec
op_increment
suffix:semicolon
)brace
multiline_comment|/* write buffer is full, flush buffer */
id|ret
op_assign
id|jffs2_flush_wbuf
c_func
(paren
id|c
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
multiline_comment|/* the underlying layer has to check wbuf_len to do the cleanup */
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;jffs2_flush_wbuf() called from jffs2_flash_writev() failed %d&bslash;n&quot;
comma
id|ret
)paren
)paren
suffix:semicolon
op_star
id|retlen
op_assign
l_int|0
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
id|outvec_to
op_add_assign
id|donelen
suffix:semicolon
id|c-&gt;wbuf_ofs
op_assign
id|outvec_to
suffix:semicolon
multiline_comment|/* All invecs done ? */
r_if
c_cond
(paren
id|invec
op_eq
id|count
)paren
r_goto
id|alldone
suffix:semicolon
multiline_comment|/* Set up the first outvec, containing the remainder of the&n;&t;&t;   invec we partially used */
r_if
c_cond
(paren
id|invecs
(braket
id|invec
)braket
dot
id|iov_len
OG
id|invec_ofs
)paren
(brace
id|outvecs
(braket
l_int|0
)braket
dot
id|iov_base
op_assign
id|invecs
(braket
id|invec
)braket
dot
id|iov_base
op_plus
id|invec_ofs
suffix:semicolon
id|totlen
op_assign
id|outvecs
(braket
l_int|0
)braket
dot
id|iov_len
op_assign
id|invecs
(braket
id|invec
)braket
dot
id|iov_len
op_minus
id|invec_ofs
suffix:semicolon
r_if
c_cond
(paren
id|totlen
OG
id|c-&gt;wbuf_pagesize
)paren
(brace
id|splitvec
op_assign
id|outvec
suffix:semicolon
id|split_ofs
op_assign
id|outvecs
(braket
l_int|0
)braket
dot
id|iov_len
op_minus
id|PAGE_MOD
c_func
(paren
id|totlen
)paren
suffix:semicolon
)brace
id|outvec
op_increment
suffix:semicolon
)brace
id|invec
op_increment
suffix:semicolon
)brace
multiline_comment|/* OK, now we&squot;ve flushed the wbuf and the start of the bits&n;&t;   we have been asked to write, now to write the rest.... */
multiline_comment|/* totlen holds the amount of data still to be written */
id|old_totlen
op_assign
id|totlen
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|invec
OL
id|count
suffix:semicolon
id|invec
op_increment
comma
id|outvec
op_increment
)paren
(brace
id|outvecs
(braket
id|outvec
)braket
dot
id|iov_base
op_assign
id|invecs
(braket
id|invec
)braket
dot
id|iov_base
suffix:semicolon
id|totlen
op_add_assign
id|outvecs
(braket
id|outvec
)braket
dot
id|iov_len
op_assign
id|invecs
(braket
id|invec
)braket
dot
id|iov_len
suffix:semicolon
r_if
c_cond
(paren
id|PAGE_DIV
c_func
(paren
id|totlen
)paren
op_ne
id|PAGE_DIV
c_func
(paren
id|old_totlen
)paren
)paren
(brace
id|splitvec
op_assign
id|outvec
suffix:semicolon
id|split_ofs
op_assign
id|outvecs
(braket
id|outvec
)braket
dot
id|iov_len
op_minus
id|PAGE_MOD
c_func
(paren
id|totlen
)paren
suffix:semicolon
id|old_totlen
op_assign
id|totlen
suffix:semicolon
)brace
)brace
multiline_comment|/* Now the outvecs array holds all the remaining data to write */
multiline_comment|/* Up to splitvec,split_ofs is to be written immediately. The rest&n;&t;   goes into the (now-empty) wbuf */
r_if
c_cond
(paren
id|splitvec
op_ne
op_minus
l_int|1
)paren
(brace
r_uint32
id|remainder
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|remainder
op_assign
id|outvecs
(braket
id|splitvec
)braket
dot
id|iov_len
op_minus
id|split_ofs
suffix:semicolon
id|outvecs
(braket
id|splitvec
)braket
dot
id|iov_len
op_assign
id|split_ofs
suffix:semicolon
multiline_comment|/* We did cross a page boundary, so we write some now */
id|ret
op_assign
id|c-&gt;mtd
op_member_access_from_pointer
id|writev_ecc
c_func
(paren
id|c-&gt;mtd
comma
id|outvecs
comma
id|splitvec
op_plus
l_int|1
comma
id|outvec_to
comma
op_amp
id|wbuf_retlen
comma
l_int|NULL
comma
op_amp
id|jffs2_oobinfo
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
op_logical_or
id|wbuf_retlen
op_ne
id|PAGE_DIV
c_func
(paren
id|totlen
)paren
)paren
(brace
multiline_comment|/* At this point we have no problem,&n;&t;&t;&t;   c-&gt;wbuf is empty. &n;&t;&t;&t;*/
op_star
id|retlen
op_assign
id|donelen
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
id|donelen
op_add_assign
id|wbuf_retlen
suffix:semicolon
id|c-&gt;wbuf_ofs
op_assign
id|PAGE_DIV
c_func
(paren
id|outvec_to
)paren
op_plus
id|PAGE_DIV
c_func
(paren
id|totlen
)paren
suffix:semicolon
r_if
c_cond
(paren
id|remainder
)paren
(brace
id|outvecs
(braket
id|splitvec
)braket
dot
id|iov_base
op_add_assign
id|split_ofs
suffix:semicolon
id|outvecs
(braket
id|splitvec
)braket
dot
id|iov_len
op_assign
id|remainder
suffix:semicolon
)brace
r_else
(brace
id|splitvec
op_increment
suffix:semicolon
)brace
)brace
r_else
(brace
id|splitvec
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Now splitvec points to the start of the bits we have to copy&n;&t;   into the wbuf */
id|wbuf_ptr
op_assign
id|c-&gt;wbuf
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|splitvec
OL
id|outvec
suffix:semicolon
id|splitvec
op_increment
)paren
(brace
multiline_comment|/* Don&squot;t copy the wbuf into itself */
r_if
c_cond
(paren
id|outvecs
(braket
id|splitvec
)braket
dot
id|iov_base
op_eq
id|c-&gt;wbuf
)paren
r_continue
suffix:semicolon
id|memcpy
c_func
(paren
id|wbuf_ptr
comma
id|outvecs
(braket
id|splitvec
)braket
dot
id|iov_base
comma
id|outvecs
(braket
id|splitvec
)braket
dot
id|iov_len
)paren
suffix:semicolon
id|wbuf_ptr
op_add_assign
id|outvecs
(braket
id|splitvec
)braket
dot
id|iov_len
suffix:semicolon
id|donelen
op_add_assign
id|outvecs
(braket
id|splitvec
)braket
dot
id|iov_len
suffix:semicolon
)brace
id|c-&gt;wbuf_len
op_assign
id|wbuf_ptr
op_minus
id|c-&gt;wbuf
suffix:semicolon
id|alldone
suffix:colon
op_star
id|retlen
op_assign
id|donelen
suffix:semicolon
multiline_comment|/* Setup timed wbuf flush, if buffer len != 0 */
r_if
c_cond
(paren
id|c-&gt;wbuf_len
)paren
(brace
id|D1
c_func
(paren
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;jffs2_flash_writev: mod wbuf_timer&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|mod_timer
c_func
(paren
op_amp
id|c-&gt;wbuf_timer
comma
id|jiffies
op_plus
id|WBUF_FLUSH_TIMEOUT
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;This is the entry for flash write.&n; *&t;Check, if we work on NAND FLASH, if so build an iovec and write it via vritev&n;*/
DECL|function|jffs2_flash_write
r_int
id|jffs2_flash_write
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
comma
id|loff_t
id|ofs
comma
r_int
id|len
comma
r_int
op_star
id|retlen
comma
r_const
id|u_char
op_star
id|buf
)paren
(brace
r_struct
id|iovec
id|vecs
(braket
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
id|jffs2_can_mark_obsolete
c_func
(paren
id|c
)paren
)paren
r_return
id|c-&gt;mtd
op_member_access_from_pointer
id|write
c_func
(paren
id|c-&gt;mtd
comma
id|ofs
comma
id|len
comma
id|retlen
comma
id|buf
)paren
suffix:semicolon
id|vecs
(braket
l_int|0
)braket
dot
id|iov_base
op_assign
(paren
r_int
r_char
op_star
)paren
id|buf
suffix:semicolon
id|vecs
(braket
l_int|0
)braket
dot
id|iov_len
op_assign
id|len
suffix:semicolon
r_return
id|jffs2_flash_writev
c_func
(paren
id|c
comma
id|vecs
comma
l_int|1
comma
id|ofs
comma
id|retlen
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;Handle readback from writebuffer and ECC failure return&n;*/
DECL|function|jffs2_flash_read
r_int
id|jffs2_flash_read
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
comma
id|loff_t
id|ofs
comma
r_int
id|len
comma
r_int
op_star
id|retlen
comma
id|u_char
op_star
id|buf
)paren
(brace
id|loff_t
id|orbf
op_assign
l_int|0
comma
id|owbf
op_assign
l_int|0
comma
id|lwbf
op_assign
l_int|0
suffix:semicolon
r_int
id|ret
suffix:semicolon
multiline_comment|/* Read flash */
r_if
c_cond
(paren
op_logical_neg
id|jffs2_can_mark_obsolete
c_func
(paren
id|c
)paren
)paren
(brace
id|ret
op_assign
id|c-&gt;mtd
op_member_access_from_pointer
id|read_ecc
c_func
(paren
id|c-&gt;mtd
comma
id|ofs
comma
id|len
comma
id|retlen
comma
id|buf
comma
l_int|NULL
comma
op_amp
id|jffs2_oobinfo
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_eq
op_minus
id|EIO
)paren
op_logical_and
(paren
op_star
id|retlen
op_eq
id|len
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;mtd-&gt;read(0x%zx bytes from 0x%llx) returned ECC error&bslash;n&quot;
comma
id|len
comma
id|ofs
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t; * We have the raw data without ECC correction in the buffer, maybe &n;&t;&t;&t; * we are lucky and all data or parts are correct. We check the node.&n;&t;&t;&t; * If data are corrupted node check will sort it out.&n;&t;&t;&t; * We keep this block, it will fail on write or erase and the we&n;&t;&t;&t; * mark it bad. Or should we do that now? But we should give him a chance.&n;&t;&t;&t; * Maybe we had a system crash or power loss before the ecc write or  &n;&t;&t;&t; * a erase was completed.&n;&t;&t;&t; * So we return success. :)&n;&t;&t;&t; */
id|ret
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_else
r_return
id|c-&gt;mtd
op_member_access_from_pointer
id|read
c_func
(paren
id|c-&gt;mtd
comma
id|ofs
comma
id|len
comma
id|retlen
comma
id|buf
)paren
suffix:semicolon
multiline_comment|/* if no writebuffer available or write buffer empty, return */
r_if
c_cond
(paren
op_logical_neg
id|c-&gt;wbuf_pagesize
op_logical_or
op_logical_neg
id|c-&gt;wbuf_len
)paren
r_return
id|ret
suffix:semicolon
multiline_comment|/* if we read in a different block, return */
r_if
c_cond
(paren
(paren
id|ofs
op_amp
op_complement
(paren
id|c-&gt;sector_size
op_minus
l_int|1
)paren
)paren
op_ne
(paren
id|c-&gt;wbuf_ofs
op_amp
op_complement
(paren
id|c-&gt;sector_size
op_minus
l_int|1
)paren
)paren
)paren
r_return
id|ret
suffix:semicolon
r_if
c_cond
(paren
id|ofs
op_ge
id|c-&gt;wbuf_ofs
)paren
(brace
id|owbf
op_assign
(paren
id|ofs
op_minus
id|c-&gt;wbuf_ofs
)paren
suffix:semicolon
multiline_comment|/* offset in write buffer */
r_if
c_cond
(paren
id|owbf
OG
id|c-&gt;wbuf_len
)paren
multiline_comment|/* is read beyond write buffer ? */
r_return
id|ret
suffix:semicolon
id|lwbf
op_assign
id|c-&gt;wbuf_len
op_minus
id|owbf
suffix:semicolon
multiline_comment|/* number of bytes to copy */
r_if
c_cond
(paren
id|lwbf
OG
id|len
)paren
id|lwbf
op_assign
id|len
suffix:semicolon
)brace
r_else
(brace
id|orbf
op_assign
(paren
id|c-&gt;wbuf_ofs
op_minus
id|ofs
)paren
suffix:semicolon
multiline_comment|/* offset in read buffer */
r_if
c_cond
(paren
id|orbf
OG
id|len
)paren
multiline_comment|/* is write beyond write buffer ? */
r_return
id|ret
suffix:semicolon
id|lwbf
op_assign
id|len
op_minus
id|orbf
suffix:semicolon
multiline_comment|/* number of bytes to copy */
r_if
c_cond
(paren
id|lwbf
OG
id|c-&gt;wbuf_len
)paren
id|lwbf
op_assign
id|c-&gt;wbuf_len
suffix:semicolon
)brace
r_if
c_cond
(paren
id|lwbf
OG
l_int|0
)paren
id|memcpy
c_func
(paren
id|buf
op_plus
id|orbf
comma
id|c-&gt;wbuf
op_plus
id|owbf
comma
id|lwbf
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Check, if the out of band area is empty&n; */
DECL|function|jffs2_check_oob_empty
r_int
id|jffs2_check_oob_empty
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
comma
r_struct
id|jffs2_eraseblock
op_star
id|jeb
comma
r_int
id|mode
)paren
(brace
r_int
r_char
op_star
id|buf
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_int
id|i
comma
id|len
comma
id|cnt
comma
id|page
suffix:semicolon
r_int
id|retlen
suffix:semicolon
r_int
id|fsdata_pos
comma
id|badblock_pos
comma
id|oob_size
suffix:semicolon
id|oob_size
op_assign
id|c-&gt;mtd-&gt;oobsize
suffix:semicolon
r_switch
c_cond
(paren
id|c-&gt;mtd-&gt;ecctype
)paren
(brace
r_case
id|MTD_ECC_SW
suffix:colon
id|fsdata_pos
op_assign
(paren
id|c-&gt;wbuf_pagesize
op_eq
l_int|256
)paren
ques
c_cond
id|NAND_JFFS2_OOB8_FSDAPOS
suffix:colon
id|NAND_JFFS2_OOB16_FSDAPOS
suffix:semicolon
id|badblock_pos
op_assign
id|NAND_BADBLOCK_POS
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;jffs2_write_oob_empty(): Invalid ECC type&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* allocate a buffer for all oob data in this sector */
id|len
op_assign
l_int|4
op_star
id|oob_size
suffix:semicolon
id|buf
op_assign
id|kmalloc
c_func
(paren
id|len
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buf
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;jffs2_check_oob_empty(): allocation of temporary data buffer for oob check failed&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
multiline_comment|/* &n;&t; * if mode = 0, we scan for a total empty oob area, else we have&n;&t; * to take care of the cleanmarker in the first page of the block&n;&t;*/
id|ret
op_assign
id|jffs2_flash_read_oob
c_func
(paren
id|c
comma
id|jeb-&gt;offset
comma
id|len
comma
op_amp
id|retlen
comma
id|buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;jffs2_check_oob_empty(): Read OOB failed %d for block at %08x&bslash;n&quot;
comma
id|ret
comma
id|jeb-&gt;offset
)paren
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|retlen
OL
id|len
)paren
(brace
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;jffs2_check_oob_empty(): Read OOB return short read &quot;
l_string|&quot;(%zd bytes not %d) for block at %08x&bslash;n&quot;
comma
id|retlen
comma
id|len
comma
id|jeb-&gt;offset
)paren
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* Special check for first two pages */
r_for
c_loop
(paren
id|page
op_assign
l_int|0
suffix:semicolon
id|page
OL
l_int|2
op_star
id|oob_size
suffix:semicolon
id|page
op_add_assign
id|oob_size
)paren
(brace
multiline_comment|/* Check for bad block marker */
r_if
c_cond
(paren
id|buf
(braket
id|page
op_plus
id|badblock_pos
)braket
op_ne
l_int|0xff
)paren
(brace
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;jffs2_check_oob_empty(): Bad or failed block at %08x&bslash;n&quot;
comma
id|jeb-&gt;offset
)paren
)paren
suffix:semicolon
multiline_comment|/* Return 2 for bad and 3 for failed block &n;&t;&t;&t;   bad goes to list_bad and failed to list_erase */
id|ret
op_assign
(paren
op_logical_neg
id|page
)paren
ques
c_cond
l_int|2
suffix:colon
l_int|3
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|cnt
op_assign
id|oob_size
suffix:semicolon
r_if
c_cond
(paren
id|mode
)paren
id|cnt
op_sub_assign
id|fsdata_pos
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|cnt
suffix:semicolon
id|i
op_add_assign
r_sizeof
(paren
r_int
r_int
)paren
)paren
(brace
r_int
r_int
id|dat
op_assign
op_star
(paren
r_int
r_int
op_star
)paren
(paren
op_amp
id|buf
(braket
id|page
op_plus
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dat
op_ne
l_int|0xffff
)paren
(brace
id|ret
op_assign
l_int|1
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
)brace
multiline_comment|/* only the first page can contain a cleanmarker !*/
id|mode
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* we know, we are aligned :) */
r_for
c_loop
(paren
suffix:semicolon
id|page
OL
id|len
suffix:semicolon
id|page
op_add_assign
r_sizeof
(paren
r_int
)paren
)paren
(brace
r_int
r_int
id|dat
op_assign
op_star
(paren
r_int
r_int
op_star
)paren
(paren
op_amp
id|buf
(braket
id|page
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dat
op_ne
op_minus
l_int|1
)paren
(brace
id|ret
op_assign
l_int|1
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
)brace
id|out
suffix:colon
id|kfree
c_func
(paren
id|buf
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n;*&t;Scan for a valid cleanmarker and for bad blocks&n;*&t;For virtual blocks (concatenated physical blocks) check the cleanmarker&n;*&t;only in the first page of the first physical block, but scan for bad blocks in all&n;*&t;physical blocks&n;*/
DECL|function|jffs2_check_nand_cleanmarker
r_int
id|jffs2_check_nand_cleanmarker
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
comma
r_struct
id|jffs2_eraseblock
op_star
id|jeb
)paren
(brace
r_struct
id|jffs2_unknown_node
id|n
suffix:semicolon
r_int
r_char
id|buf
(braket
l_int|32
)braket
suffix:semicolon
r_int
r_char
op_star
id|p
suffix:semicolon
r_int
id|ret
comma
id|i
comma
id|cnt
comma
id|retval
op_assign
l_int|0
suffix:semicolon
r_int
id|retlen
comma
id|offset
suffix:semicolon
r_int
id|fsdata_pos
comma
id|fsdata_len
comma
id|oob_size
comma
id|badblock_pos
suffix:semicolon
id|offset
op_assign
id|jeb-&gt;offset
suffix:semicolon
id|oob_size
op_assign
id|c-&gt;mtd-&gt;oobsize
suffix:semicolon
r_switch
c_cond
(paren
id|c-&gt;mtd-&gt;ecctype
)paren
(brace
r_case
id|MTD_ECC_SW
suffix:colon
id|fsdata_pos
op_assign
(paren
id|c-&gt;wbuf_pagesize
op_eq
l_int|256
)paren
ques
c_cond
id|NAND_JFFS2_OOB8_FSDAPOS
suffix:colon
id|NAND_JFFS2_OOB16_FSDAPOS
suffix:semicolon
id|fsdata_len
op_assign
(paren
id|c-&gt;wbuf_pagesize
op_eq
l_int|256
)paren
ques
c_cond
id|NAND_JFFS2_OOB8_FSDALEN
suffix:colon
id|NAND_JFFS2_OOB16_FSDALEN
suffix:semicolon
id|badblock_pos
op_assign
id|NAND_BADBLOCK_POS
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|D1
(paren
id|printk
(paren
id|KERN_WARNING
l_string|&quot;jffs2_write_nand_cleanmarker(): Invalid ECC type&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* Loop through the physical blocks */
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
suffix:semicolon
id|cnt
OL
(paren
id|c-&gt;sector_size
op_div
id|c-&gt;mtd-&gt;erasesize
)paren
suffix:semicolon
id|cnt
op_increment
)paren
(brace
multiline_comment|/*&n;&t;&t;   *    We read oob data from page 0 and 1 of the block.&n;&t;&t;   *    page 0 contains cleanmarker and badblock info&n;&t;&t;   *    page 1 contains failure count of this block&n;&t;&t; */
id|ret
op_assign
id|c-&gt;mtd-&gt;read_oob
(paren
id|c-&gt;mtd
comma
id|offset
comma
id|oob_size
op_lshift
l_int|1
comma
op_amp
id|retlen
comma
id|buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|D1
(paren
id|printk
(paren
id|KERN_WARNING
l_string|&quot;jffs2_check_nand_cleanmarker(): Read OOB failed %d for block at %08x&bslash;n&quot;
comma
id|ret
comma
id|jeb-&gt;offset
)paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_if
c_cond
(paren
id|retlen
OL
(paren
id|oob_size
op_lshift
l_int|1
)paren
)paren
(brace
id|D1
(paren
id|printk
(paren
id|KERN_WARNING
l_string|&quot;jffs2_check_nand_cleanmarker(): Read OOB return short read (%zd bytes not %d) for block at %08x&bslash;n&quot;
comma
id|retlen
comma
id|oob_size
op_lshift
l_int|1
comma
id|jeb-&gt;offset
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/* Check for bad block marker */
r_if
c_cond
(paren
id|buf
(braket
id|badblock_pos
)braket
op_ne
l_int|0xff
)paren
(brace
id|D1
(paren
id|printk
(paren
id|KERN_WARNING
l_string|&quot;jffs2_check_nand_cleanmarker(): Bad block at %08x&bslash;n&quot;
comma
id|jeb-&gt;offset
)paren
)paren
suffix:semicolon
r_return
l_int|2
suffix:semicolon
)brace
multiline_comment|/* Check for failure counter in the second page */
r_if
c_cond
(paren
id|buf
(braket
id|badblock_pos
op_plus
id|oob_size
)braket
op_ne
l_int|0xff
)paren
(brace
id|D1
(paren
id|printk
(paren
id|KERN_WARNING
l_string|&quot;jffs2_check_nand_cleanmarker(): Block marked as failed at %08x, fail count:%d&bslash;n&quot;
comma
id|jeb-&gt;offset
comma
id|buf
(braket
id|badblock_pos
op_plus
id|oob_size
)braket
)paren
)paren
suffix:semicolon
r_return
l_int|3
suffix:semicolon
)brace
multiline_comment|/* Check cleanmarker only on the first physical block */
r_if
c_cond
(paren
op_logical_neg
id|cnt
)paren
(brace
id|n.magic
op_assign
id|cpu_to_je16
(paren
id|JFFS2_MAGIC_BITMASK
)paren
suffix:semicolon
id|n.nodetype
op_assign
id|cpu_to_je16
(paren
id|JFFS2_NODETYPE_CLEANMARKER
)paren
suffix:semicolon
id|n.totlen
op_assign
id|cpu_to_je32
(paren
l_int|8
)paren
suffix:semicolon
id|p
op_assign
(paren
r_int
r_char
op_star
)paren
op_amp
id|n
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|fsdata_len
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|buf
(braket
id|fsdata_pos
op_plus
id|i
)braket
op_ne
id|p
(braket
id|i
)braket
)paren
(brace
id|D2
(paren
id|printk
(paren
id|KERN_WARNING
l_string|&quot;jffs2_check_nand_cleanmarker(): Cleanmarker node not detected in block at %08x&bslash;n&quot;
comma
id|jeb-&gt;offset
)paren
)paren
suffix:semicolon
id|retval
op_assign
l_int|1
suffix:semicolon
)brace
)brace
)brace
id|offset
op_add_assign
id|c-&gt;mtd-&gt;erasesize
suffix:semicolon
)brace
r_return
id|retval
suffix:semicolon
)brace
DECL|function|jffs2_write_nand_cleanmarker
r_int
id|jffs2_write_nand_cleanmarker
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
comma
r_struct
id|jffs2_eraseblock
op_star
id|jeb
)paren
(brace
r_struct
id|jffs2_unknown_node
id|n
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_int
id|fsdata_pos
comma
id|fsdata_len
suffix:semicolon
r_int
id|retlen
suffix:semicolon
r_switch
c_cond
(paren
id|c-&gt;mtd-&gt;ecctype
)paren
(brace
r_case
id|MTD_ECC_SW
suffix:colon
id|fsdata_pos
op_assign
(paren
id|c-&gt;wbuf_pagesize
op_eq
l_int|256
)paren
ques
c_cond
id|NAND_JFFS2_OOB8_FSDAPOS
suffix:colon
id|NAND_JFFS2_OOB16_FSDAPOS
suffix:semicolon
id|fsdata_len
op_assign
(paren
id|c-&gt;wbuf_pagesize
op_eq
l_int|256
)paren
ques
c_cond
id|NAND_JFFS2_OOB8_FSDALEN
suffix:colon
id|NAND_JFFS2_OOB16_FSDALEN
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;jffs2_write_nand_cleanmarker(): Invalid ECC type&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|n.magic
op_assign
id|cpu_to_je16
c_func
(paren
id|JFFS2_MAGIC_BITMASK
)paren
suffix:semicolon
id|n.nodetype
op_assign
id|cpu_to_je16
c_func
(paren
id|JFFS2_NODETYPE_CLEANMARKER
)paren
suffix:semicolon
id|n.totlen
op_assign
id|cpu_to_je32
c_func
(paren
l_int|8
)paren
suffix:semicolon
id|ret
op_assign
id|jffs2_flash_write_oob
c_func
(paren
id|c
comma
id|jeb-&gt;offset
op_plus
id|fsdata_pos
comma
id|fsdata_len
comma
op_amp
id|retlen
comma
(paren
r_int
r_char
op_star
)paren
op_amp
id|n
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;jffs2_write_nand_cleanmarker(): Write failed for block at %08x: error %d&bslash;n&quot;
comma
id|jeb-&gt;offset
comma
id|ret
)paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_if
c_cond
(paren
id|retlen
op_ne
id|fsdata_len
)paren
(brace
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;jffs2_write_nand_cleanmarker(): Short write for block at %08x: %zd not %d&bslash;n&quot;
comma
id|jeb-&gt;offset
comma
id|retlen
comma
id|fsdata_len
)paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* &n; * We try to get the failure count of this block.&n; */
DECL|function|jffs2_nand_read_failcnt
r_int
id|jffs2_nand_read_failcnt
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
comma
r_struct
id|jffs2_eraseblock
op_star
id|jeb
)paren
(brace
r_int
r_char
id|buf
(braket
l_int|16
)braket
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_int
id|retlen
suffix:semicolon
r_int
id|oob_size
comma
id|badblock_pos
suffix:semicolon
id|oob_size
op_assign
id|c-&gt;mtd-&gt;oobsize
suffix:semicolon
r_switch
c_cond
(paren
id|c-&gt;mtd-&gt;ecctype
)paren
(brace
r_case
id|MTD_ECC_SW
suffix:colon
id|badblock_pos
op_assign
id|NAND_BADBLOCK_POS
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;jffs2_nand_read_failcnt(): Invalid ECC type&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|ret
op_assign
id|c-&gt;mtd
op_member_access_from_pointer
id|read_oob
c_func
(paren
id|c-&gt;mtd
comma
id|jeb-&gt;offset
op_plus
id|c-&gt;mtd-&gt;oobblock
comma
id|oob_size
comma
op_amp
id|retlen
comma
id|buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;jffs2_nand_read_failcnt(): Read OOB failed %d for block at %08x&bslash;n&quot;
comma
id|ret
comma
id|jeb-&gt;offset
)paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_if
c_cond
(paren
id|retlen
OL
id|oob_size
)paren
(brace
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;jffs2_nand_read_failcnt(): Read OOB return short read (%zd bytes not %d) for block at %08x&bslash;n&quot;
comma
id|retlen
comma
id|oob_size
comma
id|jeb-&gt;offset
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|jeb-&gt;bad_count
op_assign
id|buf
(braket
id|badblock_pos
)braket
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* &n; * On NAND we try to mark this block bad. We try to write how often&n; * the block was erased and mark it finaly bad, if the count&n; * is &gt; MAX_ERASE_FAILURES. We read this information on mount !&n; * jeb-&gt;bad_count contains the count before this erase.&n; * Don&squot;t care about failures. This block remains on the erase-pending&n; * or badblock list as long as nobody manipulates the flash with&n; * a bootloader or something like that.&n; */
DECL|function|jffs2_write_nand_badblock
r_int
id|jffs2_write_nand_badblock
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
comma
r_struct
id|jffs2_eraseblock
op_star
id|jeb
)paren
(brace
r_int
r_char
id|buf
op_assign
l_int|0x0
suffix:semicolon
r_int
id|ret
comma
id|pos
suffix:semicolon
r_int
id|retlen
suffix:semicolon
r_switch
c_cond
(paren
id|c-&gt;mtd-&gt;ecctype
)paren
(brace
r_case
id|MTD_ECC_SW
suffix:colon
id|pos
op_assign
id|NAND_BADBLOCK_POS
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;jffs2_write_nand_badblock(): Invalid ECC type&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* if the count is &lt; max, we try to write the counter to the 2nd page oob area */
r_if
c_cond
(paren
op_increment
id|jeb-&gt;bad_count
OL
id|MAX_ERASE_FAILURES
)paren
(brace
id|buf
op_assign
(paren
r_int
r_char
)paren
id|jeb-&gt;bad_count
suffix:semicolon
id|pos
op_add_assign
id|c-&gt;mtd-&gt;oobblock
suffix:semicolon
)brace
id|ret
op_assign
id|jffs2_flash_write_oob
c_func
(paren
id|c
comma
id|jeb-&gt;offset
op_plus
id|pos
comma
l_int|1
comma
op_amp
id|retlen
comma
op_amp
id|buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;jffs2_write_nand_badblock(): Write failed for block at %08x: error %d&bslash;n&quot;
comma
id|jeb-&gt;offset
comma
id|ret
)paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_if
c_cond
(paren
id|retlen
op_ne
l_int|1
)paren
(brace
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;jffs2_write_nand_badblock(): Short write for block at %08x: %zd not 1&bslash;n&quot;
comma
id|jeb-&gt;offset
comma
id|retlen
)paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
eof
