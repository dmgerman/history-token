multiline_comment|/*&n; * JFFS2 -- Journalling Flash File System, Version 2.&n; *&n; * Copyright (C) 2001, 2002 Red Hat, Inc.&n; *&n; * Created by David Woodhouse &lt;dwmw2@cambridge.redhat.com&gt;&n; *&n; * The original JFFS, from which the design for JFFS2 was derived,&n; * was designed and implemented by Axis Communications AB.&n; *&n; * The contents of this file are subject to the Red Hat eCos Public&n; * License Version 1.1 (the &quot;Licence&quot;); you may not use this file&n; * except in compliance with the Licence.  You may obtain a copy of&n; * the Licence at http://www.redhat.com/&n; *&n; * Software distributed under the Licence is distributed on an &quot;AS IS&quot;&n; * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.&n; * See the Licence for the specific language governing rights and&n; * limitations under the Licence.&n; *&n; * The Original Code is JFFS2 - Journalling Flash File System, version 2&n; *&n; * Alternatively, the contents of this file may be used under the&n; * terms of the GNU General Public License version 2 (the &quot;GPL&quot;), in&n; * which case the provisions of the GPL are applicable instead of the&n; * above.  If you wish to allow the use of your version of this file&n; * only under the terms of the GPL and not to allow others to use your&n; * version of this file under the RHEPL, indicate your decision by&n; * deleting the provisions above and replace them with the notice and&n; * other provisions required by the GPL.  If you do not delete the&n; * provisions above, a recipient may use your version of this file&n; * under either the RHEPL or the GPL.&n; *&n; * $Id: wbuf.c,v 1.7 2002/03/08 11:27:59 dwmw2 Exp $&n; *&n; */
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/mtd/mtd.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/crc32.h&gt;
macro_line|#include &quot;nodelist.h&quot;
multiline_comment|/* FIXME duplicated defines in wbuf.c and nand.c&n; * Constants for out of band layout&n; */
DECL|macro|NAND_JFFS2_OOB_BADBPOS
mdefine_line|#define NAND_JFFS2_OOB_BADBPOS&t;&t;5
DECL|macro|NAND_JFFS2_OOB8_FSDAPOS
mdefine_line|#define NAND_JFFS2_OOB8_FSDAPOS&t;&t;6
DECL|macro|NAND_JFFS2_OOB16_FSDAPOS
mdefine_line|#define NAND_JFFS2_OOB16_FSDAPOS&t;8
DECL|macro|NAND_JFFS2_OOB8_FSDALEN
mdefine_line|#define NAND_JFFS2_OOB8_FSDALEN&t;&t;2
DECL|macro|NAND_JFFS2_OOB16_FSDALEN
mdefine_line|#define NAND_JFFS2_OOB16_FSDALEN&t;8
DECL|macro|MAX_ERASE_FAILURES
mdefine_line|#define MAX_ERASE_FAILURES &t;5
DECL|function|jffs2_refile_wbuf_blocks
r_static
r_inline
r_void
id|jffs2_refile_wbuf_blocks
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
)paren
(brace
r_struct
id|list_head
op_star
id|this
comma
op_star
id|next
suffix:semicolon
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|c-&gt;erasable_pending_wbuf_list
)paren
)paren
r_return
suffix:semicolon
id|list_for_each_safe
c_func
(paren
id|this
comma
id|next
comma
op_amp
id|c-&gt;erasable_pending_wbuf_list
)paren
(brace
id|list_del
c_func
(paren
id|this
)paren
suffix:semicolon
id|list_add_tail
c_func
(paren
id|this
comma
op_amp
id|c-&gt;erasable_list
)paren
suffix:semicolon
)brace
)brace
DECL|function|jffs2_flush_wbuf
r_int
id|jffs2_flush_wbuf
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
comma
r_int
id|pad
)paren
(brace
r_int
id|ret
suffix:semicolon
r_int
id|retlen
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|c-&gt;wbuf
op_logical_or
op_logical_neg
id|c-&gt;wbuf_len
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* claim remaining space on the page&n;&t;   this happens, if we have a change to a new block,&n;&t;   or if fsync forces us to flush the writebuffer.&n;&t;   if we have a switch to next page, we will not have&n;&t;   enough remaining space for this. &n;&t;*/
r_if
c_cond
(paren
id|pad
)paren
(brace
id|c-&gt;wbuf_len
op_assign
id|PAD
c_func
(paren
id|c-&gt;wbuf_len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c-&gt;wbuf_len
op_plus
r_sizeof
(paren
r_struct
id|jffs2_unknown_node
)paren
OL
id|c-&gt;wbuf_pagesize
)paren
(brace
r_struct
id|jffs2_unknown_node
op_star
id|padnode
op_assign
(paren
r_void
op_star
)paren
(paren
id|c-&gt;wbuf
op_plus
id|c-&gt;wbuf_len
)paren
suffix:semicolon
id|padnode-&gt;magic
op_assign
id|JFFS2_MAGIC_BITMASK
suffix:semicolon
id|padnode-&gt;nodetype
op_assign
id|JFFS2_NODETYPE_PADDING
suffix:semicolon
id|padnode-&gt;totlen
op_assign
id|c-&gt;wbuf_pagesize
op_minus
id|c-&gt;wbuf_len
suffix:semicolon
id|padnode-&gt;hdr_crc
op_assign
id|crc32
c_func
(paren
l_int|0
comma
id|padnode
comma
r_sizeof
(paren
op_star
id|padnode
)paren
op_minus
l_int|4
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* else jffs2_flash_writev has actually filled in the rest of the&n;&t;   buffer for us, and will deal with the node refs etc. later. */
id|ret
op_assign
id|c-&gt;mtd
op_member_access_from_pointer
id|write
c_func
(paren
id|c-&gt;mtd
comma
id|c-&gt;wbuf_ofs
comma
id|c-&gt;wbuf_pagesize
comma
op_amp
id|retlen
comma
id|c-&gt;wbuf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_logical_or
id|retlen
op_ne
id|c-&gt;wbuf_pagesize
)paren
(brace
r_if
c_cond
(paren
id|ret
)paren
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;jffs2_flush_wbuf(): Write failed with %d&bslash;n&quot;
comma
id|ret
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;jffs2_flush_wbuf(): Write was short %d instead of %d&bslash;n&quot;
comma
id|retlen
comma
id|c-&gt;wbuf_pagesize
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EIO
suffix:semicolon
multiline_comment|/* CHECKME NAND &n;&t;&t;   So that the caller knows what happened. If&n;&t;&t;   we were called from jffs2_flash_writev(), it&squot;ll&n;&t;&t;   know to return failure and _its_ caller will&n;&t;&t;   try again. writev gives back to jffs2_write_xxx &n;&t;&t;   in write.c. There are the real fixme&squot;s&n;&t;&t; */
multiline_comment|/*  FIXME NAND&n;&t;&t;   If we were called from GC or fsync, there&squot;s no repair kit yet&n;&t;&t;*/
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* Adjusting free size of next block only, if it&squot;s called from fsync ! */
r_if
c_cond
(paren
id|pad
op_eq
l_int|2
)paren
(brace
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;jffs2_flush_wbuf() adjusting free_size of c-&gt;nextblock&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|spin_lock_bh
c_func
(paren
op_amp
id|c-&gt;erase_completion_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|c-&gt;nextblock
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c-&gt;nextblock-&gt;free_size
OL
(paren
id|c-&gt;wbuf_pagesize
op_minus
id|c-&gt;wbuf_len
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|c-&gt;nextblock-&gt;free_size
op_sub_assign
(paren
id|c-&gt;wbuf_pagesize
op_minus
id|c-&gt;wbuf_len
)paren
suffix:semicolon
id|c-&gt;nextblock-&gt;dirty_size
op_add_assign
(paren
id|c-&gt;wbuf_pagesize
op_minus
id|c-&gt;wbuf_len
)paren
suffix:semicolon
id|spin_unlock_bh
c_func
(paren
op_amp
id|c-&gt;erase_completion_lock
)paren
suffix:semicolon
)brace
multiline_comment|/* Stick any now-obsoleted blocks on the erase_pending_list */
id|spin_lock_bh
c_func
(paren
op_amp
id|c-&gt;erase_completion_lock
)paren
suffix:semicolon
id|jffs2_refile_wbuf_blocks
c_func
(paren
id|c
)paren
suffix:semicolon
id|spin_unlock_bh
c_func
(paren
op_amp
id|c-&gt;erase_completion_lock
)paren
suffix:semicolon
id|memset
c_func
(paren
id|c-&gt;wbuf
comma
l_int|0xff
comma
id|c-&gt;wbuf_pagesize
)paren
suffix:semicolon
multiline_comment|/* adjust write buffer offset, else we get a non contigous write bug */
id|c-&gt;wbuf_ofs
op_add_assign
id|c-&gt;wbuf_pagesize
suffix:semicolon
id|c-&gt;wbuf_len
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|macro|PAGE_DIV
mdefine_line|#define PAGE_DIV(x) ( (x) &amp; (~(c-&gt;wbuf_pagesize - 1)) )
DECL|macro|PAGE_MOD
mdefine_line|#define PAGE_MOD(x) ( (x) &amp; (c-&gt;wbuf_pagesize - 1) )
DECL|function|jffs2_flash_writev
r_int
id|jffs2_flash_writev
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
comma
r_const
r_struct
id|iovec
op_star
id|invecs
comma
r_int
r_int
id|count
comma
id|loff_t
id|to
comma
r_int
op_star
id|retlen
)paren
(brace
r_struct
id|iovec
id|outvecs
(braket
l_int|3
)braket
suffix:semicolon
r_uint32
id|totlen
op_assign
l_int|0
suffix:semicolon
r_uint32
id|split_ofs
op_assign
l_int|0
suffix:semicolon
r_uint32
id|old_totlen
suffix:semicolon
r_int
id|ret
comma
id|splitvec
op_assign
op_minus
l_int|1
suffix:semicolon
r_int
id|invec
comma
id|outvec
suffix:semicolon
r_int
id|wbuf_retlen
suffix:semicolon
r_int
r_char
op_star
id|wbuf_ptr
suffix:semicolon
r_int
id|donelen
op_assign
l_int|0
suffix:semicolon
r_uint32
id|outvec_to
op_assign
id|to
suffix:semicolon
multiline_comment|/* If not NAND flash, don&squot;t bother */
r_if
c_cond
(paren
op_logical_neg
id|c-&gt;wbuf
)paren
r_return
id|jffs2_flash_direct_writev
c_func
(paren
id|c
comma
id|invecs
comma
id|count
comma
id|to
comma
id|retlen
)paren
suffix:semicolon
multiline_comment|/* If wbuf_ofs is not initialized, set it to target adress */
r_if
c_cond
(paren
id|c-&gt;wbuf_ofs
op_eq
l_int|0xFFFFFFFF
)paren
(brace
id|c-&gt;wbuf_ofs
op_assign
id|PAGE_DIV
c_func
(paren
id|to
)paren
suffix:semicolon
id|c-&gt;wbuf_len
op_assign
id|PAGE_MOD
c_func
(paren
id|to
)paren
suffix:semicolon
id|memset
c_func
(paren
id|c-&gt;wbuf
comma
l_int|0xff
comma
id|c-&gt;wbuf_pagesize
)paren
suffix:semicolon
)brace
multiline_comment|/* Sanity checks on target address. &n;&t;   It&squot;s permitted to write at PAD(c-&gt;wbuf_len+c-&gt;wbuf_ofs), &n;&t;   and it&squot;s permitted to write at the beginning of a new &n;&t;   erase block. Anything else, and you die.&n;&t;   New block starts at xxx000c (0-b = block header)&n;&t;*/
r_if
c_cond
(paren
(paren
id|to
op_amp
op_complement
(paren
id|c-&gt;sector_size
op_minus
l_int|1
)paren
)paren
op_ne
(paren
id|c-&gt;wbuf_ofs
op_amp
op_complement
(paren
id|c-&gt;sector_size
op_minus
l_int|1
)paren
)paren
)paren
(brace
multiline_comment|/* It&squot;s a write to a new block */
r_if
c_cond
(paren
id|c-&gt;wbuf_len
)paren
(brace
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;jffs2_flash_writev() to 0x%lx causes flush of wbuf at 0x%08x&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|to
comma
id|c-&gt;wbuf_ofs
)paren
)paren
suffix:semicolon
id|ret
op_assign
id|jffs2_flush_wbuf
c_func
(paren
id|c
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
multiline_comment|/* the underlying layer has to check wbuf_len to do the cleanup */
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;jffs2_flush_wbuf() called from jffs2_flash_writev() failed %d&bslash;n&quot;
comma
id|ret
)paren
)paren
suffix:semicolon
op_star
id|retlen
op_assign
l_int|0
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
)brace
multiline_comment|/* set pointer to new block */
id|c-&gt;wbuf_ofs
op_assign
id|PAGE_DIV
c_func
(paren
id|to
)paren
suffix:semicolon
id|c-&gt;wbuf_len
op_assign
id|PAGE_MOD
c_func
(paren
id|to
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|to
op_ne
id|PAD
c_func
(paren
id|c-&gt;wbuf_ofs
op_plus
id|c-&gt;wbuf_len
)paren
)paren
(brace
multiline_comment|/* We&squot;re not writing immediately after the writebuffer. Bad. */
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;jffs2_flash_writev(): Non-contiguous write to %08lx&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|to
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c-&gt;wbuf_len
)paren
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;wbuf was previously %08x-%08x&bslash;n&quot;
comma
id|c-&gt;wbuf_ofs
comma
id|c-&gt;wbuf_ofs
op_plus
id|c-&gt;wbuf_len
)paren
suffix:semicolon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Note outvecs[3] above. We know count is never greater than 2 */
r_if
c_cond
(paren
id|count
OG
l_int|2
)paren
(brace
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;jffs2_flash_writev(): count is %ld&bslash;n&quot;
comma
id|count
)paren
suffix:semicolon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
id|invec
op_assign
l_int|0
suffix:semicolon
id|outvec
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Fill writebuffer first, if already in use */
r_if
c_cond
(paren
id|c-&gt;wbuf_len
)paren
(brace
r_uint32
id|invec_ofs
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* adjust alignment offset */
r_if
c_cond
(paren
id|c-&gt;wbuf_len
op_ne
id|PAGE_MOD
c_func
(paren
id|to
)paren
)paren
(brace
id|c-&gt;wbuf_len
op_assign
id|PAGE_MOD
c_func
(paren
id|to
)paren
suffix:semicolon
multiline_comment|/* take care of alignment to next page */
r_if
c_cond
(paren
op_logical_neg
id|c-&gt;wbuf_len
)paren
id|c-&gt;wbuf_len
op_assign
id|c-&gt;wbuf_pagesize
suffix:semicolon
)brace
r_while
c_loop
(paren
id|c-&gt;wbuf_len
OL
id|c-&gt;wbuf_pagesize
)paren
(brace
r_uint32
id|thislen
suffix:semicolon
r_if
c_cond
(paren
id|invec
op_eq
id|count
)paren
r_goto
id|alldone
suffix:semicolon
id|thislen
op_assign
id|c-&gt;wbuf_pagesize
op_minus
id|c-&gt;wbuf_len
suffix:semicolon
r_if
c_cond
(paren
id|thislen
op_ge
id|invecs
(braket
id|invec
)braket
dot
id|iov_len
)paren
id|thislen
op_assign
id|invecs
(braket
id|invec
)braket
dot
id|iov_len
suffix:semicolon
id|invec_ofs
op_assign
id|thislen
suffix:semicolon
id|memcpy
c_func
(paren
id|c-&gt;wbuf
op_plus
id|c-&gt;wbuf_len
comma
id|invecs
(braket
id|invec
)braket
dot
id|iov_base
comma
id|thislen
)paren
suffix:semicolon
id|c-&gt;wbuf_len
op_add_assign
id|thislen
suffix:semicolon
id|donelen
op_add_assign
id|thislen
suffix:semicolon
multiline_comment|/* Get next invec, if actual did not fill the buffer */
r_if
c_cond
(paren
id|c-&gt;wbuf_len
OL
id|c-&gt;wbuf_pagesize
)paren
id|invec
op_increment
suffix:semicolon
)brace
multiline_comment|/* write buffer is full, flush buffer */
id|ret
op_assign
id|jffs2_flush_wbuf
c_func
(paren
id|c
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
multiline_comment|/* the underlying layer has to check wbuf_len to do the cleanup */
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;jffs2_flush_wbuf() called from jffs2_flash_writev() failed %d&bslash;n&quot;
comma
id|ret
)paren
)paren
suffix:semicolon
op_star
id|retlen
op_assign
l_int|0
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
id|outvec_to
op_add_assign
id|donelen
suffix:semicolon
id|c-&gt;wbuf_ofs
op_assign
id|outvec_to
suffix:semicolon
multiline_comment|/* All invecs done ? */
r_if
c_cond
(paren
id|invec
op_eq
id|count
)paren
r_goto
id|alldone
suffix:semicolon
multiline_comment|/* Set up the first outvec, containing the remainder of the&n;&t;&t;   invec we partially used */
r_if
c_cond
(paren
id|invecs
(braket
id|invec
)braket
dot
id|iov_len
OG
id|invec_ofs
)paren
(brace
id|outvecs
(braket
l_int|0
)braket
dot
id|iov_base
op_assign
id|invecs
(braket
id|invec
)braket
dot
id|iov_base
op_plus
id|invec_ofs
suffix:semicolon
id|totlen
op_assign
id|outvecs
(braket
l_int|0
)braket
dot
id|iov_len
op_assign
id|invecs
(braket
id|invec
)braket
dot
id|iov_len
op_minus
id|invec_ofs
suffix:semicolon
r_if
c_cond
(paren
id|totlen
OG
id|c-&gt;wbuf_pagesize
)paren
(brace
id|splitvec
op_assign
id|outvec
suffix:semicolon
id|split_ofs
op_assign
id|outvecs
(braket
l_int|0
)braket
dot
id|iov_len
op_minus
id|PAGE_MOD
c_func
(paren
id|totlen
)paren
suffix:semicolon
)brace
id|outvec
op_increment
suffix:semicolon
)brace
id|invec
op_increment
suffix:semicolon
)brace
multiline_comment|/* OK, now we&squot;ve flushed the wbuf and the start of the bits&n;&t;   we have been asked to write, now to write the rest.... */
multiline_comment|/* totlen holds the amount of data still to be written */
id|old_totlen
op_assign
id|totlen
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|invec
OL
id|count
suffix:semicolon
id|invec
op_increment
comma
id|outvec
op_increment
)paren
(brace
id|outvecs
(braket
id|outvec
)braket
dot
id|iov_base
op_assign
id|invecs
(braket
id|invec
)braket
dot
id|iov_base
suffix:semicolon
id|totlen
op_add_assign
id|outvecs
(braket
id|outvec
)braket
dot
id|iov_len
op_assign
id|invecs
(braket
id|invec
)braket
dot
id|iov_len
suffix:semicolon
r_if
c_cond
(paren
id|PAGE_DIV
c_func
(paren
id|totlen
)paren
op_ne
id|PAGE_DIV
c_func
(paren
id|old_totlen
)paren
)paren
(brace
id|splitvec
op_assign
id|outvec
suffix:semicolon
id|split_ofs
op_assign
id|outvecs
(braket
id|outvec
)braket
dot
id|iov_len
op_minus
id|PAGE_MOD
c_func
(paren
id|totlen
)paren
suffix:semicolon
id|old_totlen
op_assign
id|totlen
suffix:semicolon
)brace
)brace
multiline_comment|/* Now the outvecs array holds all the remaining data to write */
multiline_comment|/* Up to splitvec,split_ofs is to be written immediately. The rest&n;&t;   goes into the (now-empty) wbuf */
r_if
c_cond
(paren
id|splitvec
op_ne
op_minus
l_int|1
)paren
(brace
r_uint32
id|remainder
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|remainder
op_assign
id|outvecs
(braket
id|splitvec
)braket
dot
id|iov_len
op_minus
id|split_ofs
suffix:semicolon
id|outvecs
(braket
id|splitvec
)braket
dot
id|iov_len
op_assign
id|split_ofs
suffix:semicolon
multiline_comment|/* We did cross a page boundary, so we write some now */
id|ret
op_assign
id|jffs2_flash_direct_writev
c_func
(paren
id|c
comma
id|outvecs
comma
id|splitvec
op_plus
l_int|1
comma
id|outvec_to
comma
op_amp
id|wbuf_retlen
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
op_logical_or
id|wbuf_retlen
op_ne
id|PAGE_DIV
c_func
(paren
id|totlen
)paren
)paren
(brace
multiline_comment|/* At this point we have no problem,&n;&t;&t;&t;   c-&gt;wbuf is empty. &n;&t;&t;&t;*/
op_star
id|retlen
op_assign
id|donelen
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
id|donelen
op_add_assign
id|wbuf_retlen
suffix:semicolon
id|c-&gt;wbuf_ofs
op_assign
id|PAGE_DIV
c_func
(paren
id|outvec_to
)paren
op_plus
id|PAGE_DIV
c_func
(paren
id|totlen
)paren
suffix:semicolon
r_if
c_cond
(paren
id|remainder
)paren
(brace
id|outvecs
(braket
id|splitvec
)braket
dot
id|iov_base
op_add_assign
id|split_ofs
suffix:semicolon
id|outvecs
(braket
id|splitvec
)braket
dot
id|iov_len
op_assign
id|remainder
suffix:semicolon
)brace
r_else
(brace
id|splitvec
op_increment
suffix:semicolon
)brace
)brace
r_else
(brace
id|splitvec
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Now splitvec points to the start of the bits we have to copy&n;&t;   into the wbuf */
id|wbuf_ptr
op_assign
id|c-&gt;wbuf
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|splitvec
OL
id|outvec
suffix:semicolon
id|splitvec
op_increment
)paren
(brace
multiline_comment|/* Don&squot;t copy the wbuf into itself */
r_if
c_cond
(paren
id|outvecs
(braket
id|splitvec
)braket
dot
id|iov_base
op_eq
id|c-&gt;wbuf
)paren
r_continue
suffix:semicolon
id|memcpy
c_func
(paren
id|wbuf_ptr
comma
id|outvecs
(braket
id|splitvec
)braket
dot
id|iov_base
comma
id|outvecs
(braket
id|splitvec
)braket
dot
id|iov_len
)paren
suffix:semicolon
id|wbuf_ptr
op_add_assign
id|outvecs
(braket
id|splitvec
)braket
dot
id|iov_len
suffix:semicolon
id|donelen
op_add_assign
id|outvecs
(braket
id|splitvec
)braket
dot
id|iov_len
suffix:semicolon
)brace
id|c-&gt;wbuf_len
op_assign
id|wbuf_ptr
op_minus
id|c-&gt;wbuf
suffix:semicolon
id|alldone
suffix:colon
op_star
id|retlen
op_assign
id|donelen
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t;This is the entry for NOR-Flash. We use it also for NAND to flush wbuf&n;*/
DECL|function|jffs2_flash_write
r_int
id|jffs2_flash_write
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
comma
id|loff_t
id|ofs
comma
r_int
id|len
comma
r_int
op_star
id|retlen
comma
r_const
id|u_char
op_star
id|buf
)paren
(brace
r_return
id|c-&gt;mtd
op_member_access_from_pointer
id|write
c_func
(paren
id|c-&gt;mtd
comma
id|ofs
comma
id|len
comma
id|retlen
comma
id|buf
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;Handle readback from writebuffer and ECC failure return&n;*/
DECL|function|jffs2_flash_read
r_int
id|jffs2_flash_read
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
comma
id|loff_t
id|ofs
comma
r_int
id|len
comma
r_int
op_star
id|retlen
comma
id|u_char
op_star
id|buf
)paren
(brace
id|loff_t
id|orbf
op_assign
l_int|0
comma
id|owbf
op_assign
l_int|0
comma
id|lwbf
op_assign
l_int|0
suffix:semicolon
r_int
id|ret
suffix:semicolon
multiline_comment|/* Read flash */
id|ret
op_assign
id|c-&gt;mtd
op_member_access_from_pointer
id|read
c_func
(paren
id|c-&gt;mtd
comma
id|ofs
comma
id|len
comma
id|retlen
comma
id|buf
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|jffs2_can_mark_obsolete
c_func
(paren
id|c
)paren
op_logical_and
(paren
id|ret
op_eq
op_minus
id|EIO
)paren
op_logical_and
(paren
op_star
id|retlen
op_eq
id|len
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;mtd-&gt;read(0x%x bytes from 0x%llx) returned ECC error&bslash;n&quot;
comma
id|len
comma
id|ofs
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t; * We have the raw data without ECC correction in the buffer, maybe &n;&t;&t; * we are lucky and all data or parts are correct. We check the node.&n;&t;&t; * If data are corrupted node check will sort it out.&n;&t;&t; * We keep this block, it will fail on write or erase and the we&n;&t;&t; * mark it bad. Or should we do that now? But we should give him a chance.&n;&t;&t; * Maybe we had a system crash or power loss before the ecc write or  &n;&t;&t; * a erase was completed.&n;&t;&t; * So we return success. :)&n;&t;&t; */
id|ret
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* if no writebuffer available or write buffer empty, return */
r_if
c_cond
(paren
op_logical_neg
id|c-&gt;wbuf_pagesize
op_logical_or
op_logical_neg
id|c-&gt;wbuf_len
)paren
r_return
id|ret
suffix:semicolon
multiline_comment|/* if we read in a different block, return */
r_if
c_cond
(paren
(paren
id|ofs
op_amp
op_complement
(paren
id|c-&gt;sector_size
op_minus
l_int|1
)paren
)paren
op_ne
(paren
id|c-&gt;wbuf_ofs
op_amp
op_complement
(paren
id|c-&gt;sector_size
op_minus
l_int|1
)paren
)paren
)paren
r_return
id|ret
suffix:semicolon
r_if
c_cond
(paren
id|ofs
op_ge
id|c-&gt;wbuf_ofs
)paren
(brace
id|owbf
op_assign
(paren
id|ofs
op_minus
id|c-&gt;wbuf_ofs
)paren
suffix:semicolon
multiline_comment|/* offset in write buffer */
r_if
c_cond
(paren
id|owbf
OG
id|c-&gt;wbuf_len
)paren
multiline_comment|/* is read beyond write buffer ? */
r_return
id|ret
suffix:semicolon
id|lwbf
op_assign
id|c-&gt;wbuf_len
op_minus
id|owbf
suffix:semicolon
multiline_comment|/* number of bytes to copy */
r_if
c_cond
(paren
id|lwbf
OG
id|len
)paren
id|lwbf
op_assign
id|len
suffix:semicolon
)brace
r_else
(brace
id|orbf
op_assign
(paren
id|c-&gt;wbuf_ofs
op_minus
id|ofs
)paren
suffix:semicolon
multiline_comment|/* offset in read buffer */
r_if
c_cond
(paren
id|orbf
OG
id|len
)paren
multiline_comment|/* is write beyond write buffer ? */
r_return
id|ret
suffix:semicolon
id|lwbf
op_assign
id|len
op_minus
id|orbf
suffix:semicolon
multiline_comment|/* number of bytes to copy */
r_if
c_cond
(paren
id|lwbf
OG
id|c-&gt;wbuf_len
)paren
id|lwbf
op_assign
id|c-&gt;wbuf_len
suffix:semicolon
)brace
r_if
c_cond
(paren
id|lwbf
OG
l_int|0
)paren
id|memcpy
c_func
(paren
id|buf
op_plus
id|orbf
comma
id|c-&gt;wbuf
op_plus
id|owbf
comma
id|lwbf
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Check, if the out of band area is empty&n; */
DECL|function|jffs2_check_oob_empty
r_int
id|jffs2_check_oob_empty
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
comma
r_struct
id|jffs2_eraseblock
op_star
id|jeb
comma
r_int
id|mode
)paren
(brace
r_int
r_char
op_star
id|buf
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_int
id|i
comma
id|len
comma
id|cnt
comma
id|page
suffix:semicolon
r_int
id|retlen
suffix:semicolon
r_int
id|fsdata_pos
comma
id|badblock_pos
comma
id|oob_size
suffix:semicolon
id|oob_size
op_assign
id|c-&gt;mtd-&gt;oobsize
suffix:semicolon
r_switch
c_cond
(paren
id|c-&gt;mtd-&gt;ecctype
)paren
(brace
r_case
id|MTD_ECC_SW
suffix:colon
id|fsdata_pos
op_assign
(paren
id|c-&gt;wbuf_pagesize
op_eq
l_int|256
)paren
ques
c_cond
id|NAND_JFFS2_OOB8_FSDAPOS
suffix:colon
id|NAND_JFFS2_OOB16_FSDAPOS
suffix:semicolon
id|badblock_pos
op_assign
id|NAND_JFFS2_OOB_BADBPOS
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;jffs2_write_oob_empty(): Invalid ECC type&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* allocate a buffer for all oob data in this sector */
id|len
op_assign
id|oob_size
op_star
(paren
id|c-&gt;sector_size
op_div
id|c-&gt;mtd-&gt;oobblock
)paren
suffix:semicolon
id|buf
op_assign
id|kmalloc
c_func
(paren
id|len
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buf
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;jffs2_check_oob_empty(): allocation of temporary data buffer for oob check failed&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
multiline_comment|/* &n;&t; * if mode = 0, we scan for a total empty oob area, else we have&n;&t; * to take care of the cleanmarker in the first page of the block&n;&t;*/
id|ret
op_assign
id|jffs2_flash_read_oob
c_func
(paren
id|c
comma
id|jeb-&gt;offset
comma
id|len
comma
op_amp
id|retlen
comma
id|buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;jffs2_check_oob_empty(): Read OOB failed %d for block at %08x&bslash;n&quot;
comma
id|ret
comma
id|jeb-&gt;offset
)paren
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|retlen
OL
id|len
)paren
(brace
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;jffs2_check_oob_empty(): Read OOB return short read &quot;
l_string|&quot;(%d bytes not %d) for block at %08x&bslash;n&quot;
comma
id|retlen
comma
id|len
comma
id|jeb-&gt;offset
)paren
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* Special check for first two pages */
r_for
c_loop
(paren
id|page
op_assign
l_int|0
suffix:semicolon
id|page
OL
l_int|2
suffix:semicolon
id|page
op_add_assign
id|oob_size
)paren
(brace
multiline_comment|/* Check for bad block marker */
r_if
c_cond
(paren
id|buf
(braket
id|page
op_plus
id|badblock_pos
)braket
op_ne
l_int|0xff
)paren
(brace
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;jffs2_check_oob_empty(): Bad or failed block at %08x&bslash;n&quot;
comma
id|jeb-&gt;offset
)paren
)paren
suffix:semicolon
multiline_comment|/* Return 2 for bad and 3 for failed block &n;&t;&t;&t;   bad goes to list_bad and failed to list_erase */
id|ret
op_assign
(paren
op_logical_neg
id|page
)paren
ques
c_cond
l_int|2
suffix:colon
l_int|3
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|cnt
op_assign
id|oob_size
suffix:semicolon
r_if
c_cond
(paren
id|mode
)paren
id|cnt
op_sub_assign
id|fsdata_pos
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|cnt
suffix:semicolon
id|i
op_add_assign
r_sizeof
(paren
r_int
r_int
)paren
)paren
(brace
r_int
r_int
id|dat
op_assign
op_star
(paren
r_int
r_int
op_star
)paren
(paren
op_amp
id|buf
(braket
id|page
op_plus
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dat
op_ne
l_int|0xffff
)paren
(brace
id|ret
op_assign
l_int|1
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
)brace
multiline_comment|/* only the first page can contain a cleanmarker !*/
id|mode
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* we know, we are aligned :) */
r_for
c_loop
(paren
suffix:semicolon
id|page
OL
id|len
suffix:semicolon
id|page
op_add_assign
r_sizeof
(paren
r_int
)paren
)paren
(brace
r_int
r_int
id|dat
op_assign
op_star
(paren
r_int
r_int
op_star
)paren
(paren
op_amp
id|buf
(braket
id|page
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dat
op_ne
op_minus
l_int|1
)paren
(brace
id|ret
op_assign
l_int|1
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
)brace
id|out
suffix:colon
id|kfree
c_func
(paren
id|buf
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|jffs2_check_nand_cleanmarker
r_int
id|jffs2_check_nand_cleanmarker
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
comma
r_struct
id|jffs2_eraseblock
op_star
id|jeb
)paren
(brace
r_struct
id|jffs2_unknown_node
id|n
suffix:semicolon
r_int
r_char
id|buf
(braket
l_int|32
)braket
suffix:semicolon
r_int
r_char
op_star
id|p
suffix:semicolon
r_int
id|ret
comma
id|i
suffix:semicolon
r_int
id|retlen
suffix:semicolon
r_int
id|fsdata_pos
comma
id|fsdata_len
comma
id|oob_size
comma
id|badblock_pos
suffix:semicolon
id|oob_size
op_assign
id|c-&gt;mtd-&gt;oobsize
suffix:semicolon
r_switch
c_cond
(paren
id|c-&gt;mtd-&gt;ecctype
)paren
(brace
r_case
id|MTD_ECC_SW
suffix:colon
id|fsdata_pos
op_assign
(paren
id|c-&gt;wbuf_pagesize
op_eq
l_int|256
)paren
ques
c_cond
id|NAND_JFFS2_OOB8_FSDAPOS
suffix:colon
id|NAND_JFFS2_OOB16_FSDAPOS
suffix:semicolon
id|fsdata_len
op_assign
(paren
id|c-&gt;wbuf_pagesize
op_eq
l_int|256
)paren
ques
c_cond
id|NAND_JFFS2_OOB8_FSDALEN
suffix:colon
id|NAND_JFFS2_OOB16_FSDALEN
suffix:semicolon
id|badblock_pos
op_assign
id|NAND_JFFS2_OOB_BADBPOS
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;jffs2_write_nand_cleanmarker(): Invalid ECC type&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/*&n;&t;*&t;We read oob data from page 0 and 1 of the block.&n;&t;*&t;page 0 contains cleanmarker and badblock info&n;&t;*&t;page 2 contains failure count of this block&n;&t;*/
id|ret
op_assign
id|c-&gt;mtd
op_member_access_from_pointer
id|read_oob
c_func
(paren
id|c-&gt;mtd
comma
id|jeb-&gt;offset
comma
id|oob_size
op_lshift
l_int|1
comma
op_amp
id|retlen
comma
id|buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;jffs2_check_nand_cleanmarker(): Read OOB failed %d for block at %08x&bslash;n&quot;
comma
id|ret
comma
id|jeb-&gt;offset
)paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_if
c_cond
(paren
id|retlen
OL
(paren
id|oob_size
op_lshift
l_int|1
)paren
)paren
(brace
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;jffs2_check_nand_cleanmarker(): Read OOB return short read (%d bytes not %d) for block at %08x&bslash;n&quot;
comma
id|retlen
comma
id|oob_size
op_lshift
l_int|1
comma
id|jeb-&gt;offset
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/* Check for bad block marker */
r_if
c_cond
(paren
id|buf
(braket
id|badblock_pos
)braket
op_ne
l_int|0xff
)paren
(brace
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;jffs2_check_nand_cleanmarker(): Bad block at %08x&bslash;n&quot;
comma
id|jeb-&gt;offset
)paren
)paren
suffix:semicolon
r_return
l_int|2
suffix:semicolon
)brace
multiline_comment|/* Check for failure counter in the second page */
r_if
c_cond
(paren
id|buf
(braket
id|badblock_pos
op_plus
id|oob_size
)braket
op_ne
l_int|0xff
)paren
(brace
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;jffs2_check_nand_cleanmarker(): Block marked as failed at %08x, fail count:%d&bslash;n&quot;
comma
id|jeb-&gt;offset
comma
id|buf
(braket
id|badblock_pos
op_plus
id|oob_size
)braket
)paren
)paren
suffix:semicolon
r_return
l_int|3
suffix:semicolon
)brace
id|n.magic
op_assign
id|JFFS2_MAGIC_BITMASK
suffix:semicolon
id|n.nodetype
op_assign
id|JFFS2_NODETYPE_CLEANMARKER
suffix:semicolon
id|n.totlen
op_assign
l_int|8
suffix:semicolon
id|p
op_assign
(paren
r_int
r_char
op_star
)paren
op_amp
id|n
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|fsdata_len
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|buf
(braket
id|fsdata_pos
op_plus
id|i
)braket
op_ne
id|p
(braket
id|i
)braket
)paren
(brace
id|D2
c_func
(paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;jffs2_check_nand_cleanmarker(): Cleanmarker node not detected in block at %08x&bslash;n&quot;
comma
id|jeb-&gt;offset
)paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|jffs2_write_nand_cleanmarker
r_int
id|jffs2_write_nand_cleanmarker
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
comma
r_struct
id|jffs2_eraseblock
op_star
id|jeb
)paren
(brace
r_struct
id|jffs2_unknown_node
id|n
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_int
id|fsdata_pos
comma
id|fsdata_len
suffix:semicolon
r_int
id|retlen
suffix:semicolon
r_switch
c_cond
(paren
id|c-&gt;mtd-&gt;ecctype
)paren
(brace
r_case
id|MTD_ECC_SW
suffix:colon
id|fsdata_pos
op_assign
(paren
id|c-&gt;wbuf_pagesize
op_eq
l_int|256
)paren
ques
c_cond
id|NAND_JFFS2_OOB8_FSDAPOS
suffix:colon
id|NAND_JFFS2_OOB16_FSDAPOS
suffix:semicolon
id|fsdata_len
op_assign
(paren
id|c-&gt;wbuf_pagesize
op_eq
l_int|256
)paren
ques
c_cond
id|NAND_JFFS2_OOB8_FSDALEN
suffix:colon
id|NAND_JFFS2_OOB16_FSDALEN
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;jffs2_write_nand_cleanmarker(): Invalid ECC type&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|n.magic
op_assign
id|JFFS2_MAGIC_BITMASK
suffix:semicolon
id|n.nodetype
op_assign
id|JFFS2_NODETYPE_CLEANMARKER
suffix:semicolon
id|n.totlen
op_assign
l_int|8
suffix:semicolon
id|ret
op_assign
id|jffs2_flash_write_oob
c_func
(paren
id|c
comma
id|jeb-&gt;offset
op_plus
id|fsdata_pos
comma
id|fsdata_len
comma
op_amp
id|retlen
comma
(paren
r_int
r_char
op_star
)paren
op_amp
id|n
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;jffs2_write_nand_cleanmarker(): Write failed for block at %08x: error %d&bslash;n&quot;
comma
id|jeb-&gt;offset
comma
id|ret
)paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_if
c_cond
(paren
id|retlen
op_ne
id|fsdata_len
)paren
(brace
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;jffs2_write_nand_cleanmarker(): Short write for block at %08x: %d not %d&bslash;n&quot;
comma
id|jeb-&gt;offset
comma
id|retlen
comma
id|fsdata_len
)paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* &n; * We try to get the failure count of this block.&n; */
DECL|function|jffs2_nand_read_failcnt
r_int
id|jffs2_nand_read_failcnt
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
comma
r_struct
id|jffs2_eraseblock
op_star
id|jeb
)paren
(brace
r_int
r_char
id|buf
(braket
l_int|16
)braket
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_int
id|retlen
suffix:semicolon
r_int
id|oob_size
comma
id|badblock_pos
suffix:semicolon
id|oob_size
op_assign
id|c-&gt;mtd-&gt;oobsize
suffix:semicolon
r_switch
c_cond
(paren
id|c-&gt;mtd-&gt;ecctype
)paren
(brace
r_case
id|MTD_ECC_SW
suffix:colon
id|badblock_pos
op_assign
id|NAND_JFFS2_OOB_BADBPOS
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;jffs2_nand_read_failcnt(): Invalid ECC type&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|ret
op_assign
id|c-&gt;mtd
op_member_access_from_pointer
id|read_oob
c_func
(paren
id|c-&gt;mtd
comma
id|jeb-&gt;offset
op_plus
id|c-&gt;mtd-&gt;oobblock
comma
id|oob_size
comma
op_amp
id|retlen
comma
id|buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;jffs2_nand_read_failcnt(): Read OOB failed %d for block at %08x&bslash;n&quot;
comma
id|ret
comma
id|jeb-&gt;offset
)paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_if
c_cond
(paren
id|retlen
OL
id|oob_size
)paren
(brace
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;jffs2_nand_read_failcnt(): Read OOB return short read (%d bytes not %d) for block at %08x&bslash;n&quot;
comma
id|retlen
comma
id|oob_size
comma
id|jeb-&gt;offset
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|jeb-&gt;bad_count
op_assign
id|buf
(braket
id|badblock_pos
)braket
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* &n; * On NAND we try to mark this block bad. We try to write how often&n; * the block was erased and mark it finaly bad, if the count&n; * is &gt; MAX_ERASE_FAILURES. We read this information on mount !&n; * jeb-&gt;bad_count contains the count before this erase.&n; * Don&squot;t care about failures. This block remains on the erase-pending&n; * or badblock list as long as nobody manipulates the flash with&n; * a bootloader or something like that.&n; */
DECL|function|jffs2_write_nand_badblock
r_int
id|jffs2_write_nand_badblock
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
comma
r_struct
id|jffs2_eraseblock
op_star
id|jeb
)paren
(brace
r_int
r_char
id|buf
op_assign
l_int|0x0
suffix:semicolon
r_int
id|ret
comma
id|pos
suffix:semicolon
r_int
id|retlen
suffix:semicolon
r_switch
c_cond
(paren
id|c-&gt;mtd-&gt;ecctype
)paren
(brace
r_case
id|MTD_ECC_SW
suffix:colon
id|pos
op_assign
id|NAND_JFFS2_OOB_BADBPOS
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;jffs2_write_nand_badblock(): Invalid ECC type&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* if the count is &lt; max, we try to write the counter to the 2nd page oob area */
r_if
c_cond
(paren
op_increment
id|jeb-&gt;bad_count
OL
id|MAX_ERASE_FAILURES
)paren
(brace
id|buf
op_assign
(paren
r_int
r_char
)paren
id|jeb-&gt;bad_count
suffix:semicolon
id|pos
op_add_assign
id|c-&gt;mtd-&gt;oobblock
suffix:semicolon
)brace
id|ret
op_assign
id|jffs2_flash_write_oob
c_func
(paren
id|c
comma
id|jeb-&gt;offset
op_plus
id|pos
comma
l_int|1
comma
op_amp
id|retlen
comma
op_amp
id|buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;jffs2_write_nand_badblock(): Write failed for block at %08x: error %d&bslash;n&quot;
comma
id|jeb-&gt;offset
comma
id|ret
)paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_if
c_cond
(paren
id|retlen
op_ne
l_int|1
)paren
(brace
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;jffs2_write_nand_badblock(): Short write for block at %08x: %d not 1&bslash;n&quot;
comma
id|jeb-&gt;offset
comma
id|retlen
)paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
eof
