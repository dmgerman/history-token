multiline_comment|/*&n; * JFFS2 -- Journalling Flash File System, Version 2.&n; *&n; * Copyright (C) 2001, 2002 Red Hat, Inc.&n; *&n; * Created by David Woodhouse &lt;dwmw2@cambridge.redhat.com&gt;&n; *&n; * The original JFFS, from which the design for JFFS2 was derived,&n; * was designed and implemented by Axis Communications AB.&n; *&n; * The contents of this file are subject to the Red Hat eCos Public&n; * License Version 1.1 (the &quot;Licence&quot;); you may not use this file&n; * except in compliance with the Licence.  You may obtain a copy of&n; * the Licence at http://www.redhat.com/&n; *&n; * Software distributed under the Licence is distributed on an &quot;AS IS&quot;&n; * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.&n; * See the Licence for the specific language governing rights and&n; * limitations under the Licence.&n; *&n; * The Original Code is JFFS2 - Journalling Flash File System, version 2&n; *&n; * Alternatively, the contents of this file may be used under the&n; * terms of the GNU General Public License version 2 (the &quot;GPL&quot;), in&n; * which case the provisions of the GPL are applicable instead of the&n; * above.  If you wish to allow the use of your version of this file&n; * only under the terms of the GPL and not to allow others to use your&n; * version of this file under the RHEPL, indicate your decision by&n; * deleting the provisions above and replace them with the notice and&n; * other provisions required by the GPL.  If you do not delete the&n; * provisions above, a recipient may use your version of this file&n; * under either the RHEPL or the GPL.&n; *&n; * $Id: background.c,v 1.23 2002/03/06 12:37:08 dwmw2 Exp $&n; *&n; */
DECL|macro|__KERNEL_SYSCALLS__
mdefine_line|#define __KERNEL_SYSCALLS__
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/unistd.h&gt;
macro_line|#include &lt;linux/jffs2.h&gt;
macro_line|#include &lt;linux/mtd/mtd.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/completion.h&gt;
macro_line|#include &lt;linux/mtd/compatmac.h&gt; /* recalc_sigpending() */
macro_line|#include &quot;nodelist.h&quot;
r_static
r_int
id|jffs2_garbage_collect_thread
c_func
(paren
r_void
op_star
)paren
suffix:semicolon
r_static
r_int
id|thread_should_wake
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
)paren
suffix:semicolon
DECL|function|jffs2_garbage_collect_trigger
r_void
id|jffs2_garbage_collect_trigger
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
)paren
(brace
id|spin_lock_bh
c_func
(paren
op_amp
id|c-&gt;erase_completion_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c-&gt;gc_task
op_logical_and
id|thread_should_wake
c_func
(paren
id|c
)paren
)paren
id|send_sig
c_func
(paren
id|SIGHUP
comma
id|c-&gt;gc_task
comma
l_int|1
)paren
suffix:semicolon
id|spin_unlock_bh
c_func
(paren
op_amp
id|c-&gt;erase_completion_lock
)paren
suffix:semicolon
)brace
multiline_comment|/* This must only ever be called when no GC thread is currently running */
DECL|function|jffs2_start_garbage_collect_thread
r_int
id|jffs2_start_garbage_collect_thread
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
)paren
(brace
id|pid_t
id|pid
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|c-&gt;gc_task
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|init_MUTEX_LOCKED
c_func
(paren
op_amp
id|c-&gt;gc_thread_start
)paren
suffix:semicolon
id|init_completion
c_func
(paren
op_amp
id|c-&gt;gc_thread_exit
)paren
suffix:semicolon
id|pid
op_assign
id|kernel_thread
c_func
(paren
id|jffs2_garbage_collect_thread
comma
id|c
comma
id|CLONE_FS
op_or
id|CLONE_FILES
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pid
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;fork failed for JFFS2 garbage collect thread: %d&bslash;n&quot;
comma
op_minus
id|pid
)paren
suffix:semicolon
id|complete
c_func
(paren
op_amp
id|c-&gt;gc_thread_exit
)paren
suffix:semicolon
id|ret
op_assign
id|pid
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Wait for it... */
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;JFFS2: Garbage collect thread is pid %d&bslash;n&quot;
comma
id|pid
)paren
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|c-&gt;gc_thread_start
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|function|jffs2_stop_garbage_collect_thread
r_void
id|jffs2_stop_garbage_collect_thread
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
)paren
(brace
id|spin_lock_bh
c_func
(paren
op_amp
id|c-&gt;erase_completion_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c-&gt;gc_task
)paren
(brace
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;jffs2: Killing GC task %d&bslash;n&quot;
comma
id|c-&gt;gc_task-&gt;pid
)paren
)paren
suffix:semicolon
id|send_sig
c_func
(paren
id|SIGKILL
comma
id|c-&gt;gc_task
comma
l_int|1
)paren
suffix:semicolon
)brace
id|spin_unlock_bh
c_func
(paren
op_amp
id|c-&gt;erase_completion_lock
)paren
suffix:semicolon
id|wait_for_completion
c_func
(paren
op_amp
id|c-&gt;gc_thread_exit
)paren
suffix:semicolon
)brace
DECL|function|jffs2_garbage_collect_thread
r_static
r_int
id|jffs2_garbage_collect_thread
c_func
(paren
r_void
op_star
id|_c
)paren
(brace
r_struct
id|jffs2_sb_info
op_star
id|c
op_assign
id|_c
suffix:semicolon
id|daemonize
c_func
(paren
)paren
suffix:semicolon
id|current-&gt;tty
op_assign
l_int|NULL
suffix:semicolon
id|c-&gt;gc_task
op_assign
id|current
suffix:semicolon
id|up
c_func
(paren
op_amp
id|c-&gt;gc_thread_start
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|current-&gt;comm
comma
l_string|&quot;jffs2_gcd_mtd%d&quot;
comma
id|c-&gt;mtd-&gt;index
)paren
suffix:semicolon
id|set_user_nice
c_func
(paren
id|current
comma
l_int|10
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|spin_lock_irq
c_func
(paren
op_amp
id|current-&gt;sigmask_lock
)paren
suffix:semicolon
id|siginitsetinv
(paren
op_amp
id|current-&gt;blocked
comma
id|sigmask
c_func
(paren
id|SIGHUP
)paren
op_or
id|sigmask
c_func
(paren
id|SIGKILL
)paren
op_or
id|sigmask
c_func
(paren
id|SIGSTOP
)paren
op_or
id|sigmask
c_func
(paren
id|SIGCONT
)paren
)paren
suffix:semicolon
id|recalc_sigpending
c_func
(paren
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|current-&gt;sigmask_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|thread_should_wake
c_func
(paren
id|c
)paren
)paren
(brace
id|set_current_state
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;jffs2_garbage_collect_thread sleeping...&bslash;n&quot;
)paren
)paren
suffix:semicolon
multiline_comment|/* Yes, there&squot;s a race here; we checked thread_should_wake() before&n;&t;&t;&t;   setting current-&gt;state to TASK_INTERRUPTIBLE. But it doesn&squot;t&n;&t;&t;&t;   matter - We don&squot;t care if we miss a wakeup, because the GC thread&n;&t;&t;&t;   is only an optimisation anyway. */
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
id|cond_resched
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Put_super will send a SIGKILL and then wait on the sem. &n;                 */
r_while
c_loop
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
id|siginfo_t
id|info
suffix:semicolon
r_int
r_int
id|signr
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|current-&gt;sigmask_lock
)paren
suffix:semicolon
id|signr
op_assign
id|dequeue_signal
c_func
(paren
op_amp
id|current-&gt;blocked
comma
op_amp
id|info
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|current-&gt;sigmask_lock
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|signr
)paren
(brace
r_case
id|SIGSTOP
suffix:colon
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;jffs2_garbage_collect_thread(): SIGSTOP received.&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|set_current_state
c_func
(paren
id|TASK_STOPPED
)paren
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIGKILL
suffix:colon
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;jffs2_garbage_collect_thread(): SIGKILL received.&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|spin_lock_bh
c_func
(paren
op_amp
id|c-&gt;erase_completion_lock
)paren
suffix:semicolon
id|c-&gt;gc_task
op_assign
l_int|NULL
suffix:semicolon
id|spin_unlock_bh
c_func
(paren
op_amp
id|c-&gt;erase_completion_lock
)paren
suffix:semicolon
id|complete_and_exit
c_func
(paren
op_amp
id|c-&gt;gc_thread_exit
comma
l_int|0
)paren
suffix:semicolon
r_case
id|SIGHUP
suffix:colon
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;jffs2_garbage_collect_thread(): SIGHUP received.&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;jffs2_garbage_collect_thread(): signal %ld received&bslash;n&quot;
comma
id|signr
)paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* We don&squot;t want SIGHUP to interrupt us. STOP and KILL are OK though. */
id|spin_lock_irq
c_func
(paren
op_amp
id|current-&gt;sigmask_lock
)paren
suffix:semicolon
id|siginitsetinv
(paren
op_amp
id|current-&gt;blocked
comma
id|sigmask
c_func
(paren
id|SIGKILL
)paren
op_or
id|sigmask
c_func
(paren
id|SIGSTOP
)paren
op_or
id|sigmask
c_func
(paren
id|SIGCONT
)paren
)paren
suffix:semicolon
id|recalc_sigpending
c_func
(paren
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|current-&gt;sigmask_lock
)paren
suffix:semicolon
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;jffs2_garbage_collect_thread(): pass&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|jffs2_garbage_collect_pass
c_func
(paren
id|c
)paren
suffix:semicolon
)brace
)brace
DECL|function|thread_should_wake
r_static
r_int
id|thread_should_wake
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
)paren
(brace
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;thread_should_wake(): nr_free_blocks %d, nr_erasing_blocks %d, dirty_size 0x%x&bslash;n&quot;
comma
id|c-&gt;nr_free_blocks
comma
id|c-&gt;nr_erasing_blocks
comma
id|c-&gt;dirty_size
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c-&gt;nr_free_blocks
op_plus
id|c-&gt;nr_erasing_blocks
template_param
id|c-&gt;sector_size
)paren
r_return
l_int|1
suffix:semicolon
r_else
r_return
l_int|0
suffix:semicolon
)brace
eof
