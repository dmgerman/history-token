multiline_comment|/*&n; * JFFS2 -- Journalling Flash File System, Version 2.&n; *&n; * Copyright (C) 2001, 2002 Red Hat, Inc.&n; *&n; * Created by David Woodhouse &lt;dwmw2@cambridge.redhat.com&gt;&n; *&n; * The original JFFS, from which the design for JFFS2 was derived,&n; * was designed and implemented by Axis Communications AB.&n; *&n; * The contents of this file are subject to the Red Hat eCos Public&n; * License Version 1.1 (the &quot;Licence&quot;); you may not use this file&n; * except in compliance with the Licence.  You may obtain a copy of&n; * the Licence at http://www.redhat.com/&n; *&n; * Software distributed under the Licence is distributed on an &quot;AS IS&quot;&n; * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.&n; * See the Licence for the specific language governing rights and&n; * limitations under the Licence.&n; *&n; * The Original Code is JFFS2 - Journalling Flash File System, version 2&n; *&n; * Alternatively, the contents of this file may be used under the&n; * terms of the GNU General Public License version 2 (the &quot;GPL&quot;), in&n; * which case the provisions of the GPL are applicable instead of the&n; * above.  If you wish to allow the use of your version of this file&n; * only under the terms of the GPL and not to allow others to use your&n; * version of this file under the RHEPL, indicate your decision by&n; * deleting the provisions above and replace them with the notice and&n; * other provisions required by the GPL.  If you do not delete the&n; * provisions above, a recipient may use your version of this file&n; * under either the RHEPL or the GPL.&n; *&n; * $Id: readinode.c,v 1.71 2002/03/06 12:25:59 dwmw2 Exp $&n; *&n; */
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/crc32.h&gt;
macro_line|#include &lt;linux/mtd/mtd.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &quot;nodelist.h&quot;
id|D1
c_func
(paren
r_void
id|jffs2_print_frag_list
c_func
(paren
r_struct
id|jffs2_inode_info
op_star
id|f
)paren
(brace
r_struct
id|jffs2_node_frag
op_star
id|this
op_assign
id|f-&gt;fraglist
suffix:semicolon
r_while
(paren
id|this
)paren
(brace
r_if
(paren
id|this-&gt;node
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;frag %04x-%04x: 0x%08x on flash (*%p-&gt;%p)&bslash;n&quot;
comma
id|this-&gt;ofs
comma
id|this-&gt;ofs
op_plus
id|this-&gt;size
comma
id|this-&gt;node-&gt;raw-&gt;flash_offset
op_amp
op_complement
l_int|3
comma
id|this
comma
id|this-&gt;next
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;frag %04x-%04x: hole (*%p-&gt;%p)&bslash;n&quot;
comma
id|this-&gt;ofs
comma
id|this-&gt;ofs
op_plus
id|this-&gt;size
comma
id|this
comma
id|this-&gt;next
)paren
suffix:semicolon
id|this
op_assign
id|this-&gt;next
suffix:semicolon
)brace
r_if
(paren
id|f-&gt;metadata
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;metadata at 0x%08x&bslash;n&quot;
comma
id|f-&gt;metadata-&gt;raw-&gt;flash_offset
op_amp
op_complement
l_int|3
)paren
suffix:semicolon
)brace
)brace
)paren
multiline_comment|/* Given an inode, probably with existing list of fragments, add the new node&n; * to the fragment list.&n; */
DECL|function|jffs2_add_full_dnode_to_inode
r_int
id|jffs2_add_full_dnode_to_inode
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
comma
r_struct
id|jffs2_inode_info
op_star
id|f
comma
r_struct
id|jffs2_full_dnode
op_star
id|fn
)paren
(brace
r_int
id|ret
suffix:semicolon
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;jffs2_add_full_dnode_to_inode(ino #%u, f %p, fn %p)&bslash;n&quot;
comma
id|f-&gt;inocache-&gt;ino
comma
id|f
comma
id|fn
)paren
)paren
suffix:semicolon
id|ret
op_assign
id|jffs2_add_full_dnode_to_fraglist
c_func
(paren
id|c
comma
op_amp
id|f-&gt;fraglist
comma
id|fn
)paren
suffix:semicolon
id|D2
c_func
(paren
id|jffs2_print_frag_list
c_func
(paren
id|f
)paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|jffs2_obsolete_node_frag
r_static
r_void
id|jffs2_obsolete_node_frag
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
comma
r_struct
id|jffs2_node_frag
op_star
id|this
)paren
(brace
r_if
c_cond
(paren
id|this-&gt;node
)paren
(brace
id|this-&gt;node-&gt;frags
op_decrement
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|this-&gt;node-&gt;frags
)paren
(brace
multiline_comment|/* The node has no valid frags left. It&squot;s totally obsoleted */
id|D2
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Marking old node @0x%08x (0x%04x-0x%04x) obsolete&bslash;n&quot;
comma
id|this-&gt;node-&gt;raw-&gt;flash_offset
op_amp
op_complement
l_int|3
comma
id|this-&gt;node-&gt;ofs
comma
id|this-&gt;node-&gt;ofs
op_plus
id|this-&gt;node-&gt;size
)paren
)paren
suffix:semicolon
id|jffs2_mark_node_obsolete
c_func
(paren
id|c
comma
id|this-&gt;node-&gt;raw
)paren
suffix:semicolon
id|jffs2_free_full_dnode
c_func
(paren
id|this-&gt;node
)paren
suffix:semicolon
)brace
r_else
(brace
id|D2
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Not marking old node @0x%08x (0x%04x-0x%04x) obsolete. frags is %d&bslash;n&quot;
comma
id|this-&gt;node-&gt;raw-&gt;flash_offset
op_amp
op_complement
l_int|3
comma
id|this-&gt;node-&gt;ofs
comma
id|this-&gt;node-&gt;ofs
op_plus
id|this-&gt;node-&gt;size
comma
id|this-&gt;node-&gt;frags
)paren
)paren
suffix:semicolon
)brace
)brace
id|jffs2_free_node_frag
c_func
(paren
id|this
)paren
suffix:semicolon
)brace
multiline_comment|/* Doesn&squot;t set inode-&gt;i_size */
DECL|function|jffs2_add_full_dnode_to_fraglist
r_int
id|jffs2_add_full_dnode_to_fraglist
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
comma
r_struct
id|jffs2_node_frag
op_star
op_star
id|list
comma
r_struct
id|jffs2_full_dnode
op_star
id|fn
)paren
(brace
r_struct
id|jffs2_node_frag
op_star
id|this
comma
op_star
op_star
id|prev
comma
op_star
id|old
suffix:semicolon
r_struct
id|jffs2_node_frag
op_star
id|newfrag
comma
op_star
id|newfrag2
suffix:semicolon
r_uint32
id|lastend
op_assign
l_int|0
suffix:semicolon
id|newfrag
op_assign
id|jffs2_alloc_node_frag
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|newfrag
)paren
(brace
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|D2
c_func
(paren
r_if
(paren
id|fn-&gt;raw
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;adding node %04x-%04x @0x%08x on flash, newfrag *%p&bslash;n&quot;
comma
id|fn-&gt;ofs
comma
id|fn-&gt;ofs
op_plus
id|fn-&gt;size
comma
id|fn-&gt;raw-&gt;flash_offset
op_amp
op_complement
l_int|3
comma
id|newfrag
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;adding hole node %04x-%04x on flash, newfrag *%p&bslash;n&quot;
comma
id|fn-&gt;ofs
comma
id|fn-&gt;ofs
op_plus
id|fn-&gt;size
comma
id|newfrag
)paren
)paren
suffix:semicolon
id|prev
op_assign
id|list
suffix:semicolon
id|this
op_assign
op_star
id|list
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fn-&gt;size
)paren
(brace
id|jffs2_free_node_frag
c_func
(paren
id|newfrag
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|newfrag-&gt;ofs
op_assign
id|fn-&gt;ofs
suffix:semicolon
id|newfrag-&gt;size
op_assign
id|fn-&gt;size
suffix:semicolon
id|newfrag-&gt;node
op_assign
id|fn
suffix:semicolon
id|newfrag-&gt;node-&gt;frags
op_assign
l_int|1
suffix:semicolon
id|newfrag-&gt;next
op_assign
(paren
r_void
op_star
)paren
l_int|0xdeadbeef
suffix:semicolon
multiline_comment|/* Skip all the nodes which are completed before this one starts */
r_while
c_loop
(paren
id|this
op_logical_and
id|fn-&gt;ofs
op_ge
id|this-&gt;ofs
op_plus
id|this-&gt;size
)paren
(brace
id|lastend
op_assign
id|this-&gt;ofs
op_plus
id|this-&gt;size
suffix:semicolon
id|D2
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;j_a_f_d_t_f: skipping frag 0x%04x-0x%04x; phys 0x%08x (*%p-&gt;%p)&bslash;n&quot;
comma
id|this-&gt;ofs
comma
id|this-&gt;ofs
op_plus
id|this-&gt;size
comma
id|this-&gt;node
ques
c_cond
(paren
id|this-&gt;node-&gt;raw-&gt;flash_offset
op_amp
op_complement
l_int|3
)paren
suffix:colon
l_int|0xffffffff
comma
id|this
comma
id|this-&gt;next
)paren
)paren
suffix:semicolon
id|prev
op_assign
op_amp
id|this-&gt;next
suffix:semicolon
id|this
op_assign
id|this-&gt;next
suffix:semicolon
)brace
multiline_comment|/* See if we ran off the end of the list */
r_if
c_cond
(paren
op_logical_neg
id|this
)paren
(brace
multiline_comment|/* We did */
r_if
c_cond
(paren
id|lastend
OL
id|fn-&gt;ofs
)paren
(brace
multiline_comment|/* ... and we need to put a hole in before the new node */
r_struct
id|jffs2_node_frag
op_star
id|holefrag
op_assign
id|jffs2_alloc_node_frag
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|holefrag
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|holefrag-&gt;ofs
op_assign
id|lastend
suffix:semicolon
id|holefrag-&gt;size
op_assign
id|fn-&gt;ofs
op_minus
id|lastend
suffix:semicolon
id|holefrag-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|holefrag-&gt;node
op_assign
l_int|NULL
suffix:semicolon
op_star
id|prev
op_assign
id|holefrag
suffix:semicolon
id|prev
op_assign
op_amp
id|holefrag-&gt;next
suffix:semicolon
)brace
id|newfrag-&gt;next
op_assign
l_int|NULL
suffix:semicolon
op_star
id|prev
op_assign
id|newfrag
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|D2
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;j_a_f_d_t_f: dealing with frag 0x%04x-0x%04x; phys 0x%08x (*%p-&gt;%p)&bslash;n&quot;
comma
id|this-&gt;ofs
comma
id|this-&gt;ofs
op_plus
id|this-&gt;size
comma
id|this-&gt;node
ques
c_cond
(paren
id|this-&gt;node-&gt;raw-&gt;flash_offset
op_amp
op_complement
l_int|3
)paren
suffix:colon
l_int|0xffffffff
comma
id|this
comma
id|this-&gt;next
)paren
)paren
suffix:semicolon
multiline_comment|/* OK. &squot;this&squot; is pointing at the first frag that fn-&gt;ofs at least partially obsoletes,&n;&t; * - i.e. fn-&gt;ofs &lt; this-&gt;ofs+this-&gt;size &amp;&amp; fn-&gt;ofs &gt;= this-&gt;ofs  &n;&t; */
r_if
c_cond
(paren
id|fn-&gt;ofs
OG
id|this-&gt;ofs
)paren
(brace
multiline_comment|/* This node isn&squot;t completely obsoleted. The start of it remains valid */
r_if
c_cond
(paren
id|this-&gt;ofs
op_plus
id|this-&gt;size
OG
id|fn-&gt;ofs
op_plus
id|fn-&gt;size
)paren
(brace
multiline_comment|/* The new node splits &squot;this&squot; frag into two */
id|newfrag2
op_assign
id|jffs2_alloc_node_frag
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|newfrag2
)paren
(brace
id|jffs2_free_node_frag
c_func
(paren
id|newfrag
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;split old frag 0x%04x-0x%04x --&gt;&quot;
comma
id|this-&gt;ofs
comma
id|this-&gt;ofs
op_plus
id|this-&gt;size
)paren
suffix:semicolon
r_if
(paren
id|this-&gt;node
)paren
id|printk
c_func
(paren
l_string|&quot;phys 0x%08x&bslash;n&quot;
comma
id|this-&gt;node-&gt;raw-&gt;flash_offset
op_amp
op_complement
l_int|3
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;hole&bslash;n&quot;
)paren
suffix:semicolon
)paren
id|newfrag2-&gt;ofs
op_assign
id|fn-&gt;ofs
op_plus
id|fn-&gt;size
suffix:semicolon
id|newfrag2-&gt;size
op_assign
(paren
id|this-&gt;ofs
op_plus
id|this-&gt;size
)paren
op_minus
id|newfrag2-&gt;ofs
suffix:semicolon
id|newfrag2-&gt;next
op_assign
id|this-&gt;next
suffix:semicolon
id|newfrag2-&gt;node
op_assign
id|this-&gt;node
suffix:semicolon
r_if
c_cond
(paren
id|this-&gt;node
)paren
id|this-&gt;node-&gt;frags
op_increment
suffix:semicolon
id|newfrag-&gt;next
op_assign
id|newfrag2
suffix:semicolon
id|this-&gt;next
op_assign
id|newfrag
suffix:semicolon
id|this-&gt;size
op_assign
id|newfrag-&gt;ofs
op_minus
id|this-&gt;ofs
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* New node just reduces &squot;this&squot; frag in size, doesn&squot;t split it */
id|this-&gt;size
op_assign
id|fn-&gt;ofs
op_minus
id|this-&gt;ofs
suffix:semicolon
id|newfrag-&gt;next
op_assign
id|this-&gt;next
suffix:semicolon
id|this-&gt;next
op_assign
id|newfrag
suffix:semicolon
id|this
op_assign
id|newfrag-&gt;next
suffix:semicolon
)brace
r_else
(brace
id|D2
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Inserting newfrag (*%p) in before &squot;this&squot; (*%p)&bslash;n&quot;
comma
id|newfrag
comma
id|this
)paren
)paren
suffix:semicolon
op_star
id|prev
op_assign
id|newfrag
suffix:semicolon
id|newfrag-&gt;next
op_assign
id|this
suffix:semicolon
)brace
multiline_comment|/* OK, now we have newfrag added in the correct place in the list, but&n;&t;   newfrag-&gt;next points to a fragment which may be overlapping it&n;&t;*/
r_while
c_loop
(paren
id|this
op_logical_and
id|newfrag-&gt;ofs
op_plus
id|newfrag-&gt;size
op_ge
id|this-&gt;ofs
op_plus
id|this-&gt;size
)paren
(brace
multiline_comment|/* &squot;this&squot; frag is obsoleted. */
id|old
op_assign
id|this
suffix:semicolon
id|this
op_assign
id|old-&gt;next
suffix:semicolon
id|jffs2_obsolete_node_frag
c_func
(paren
id|c
comma
id|old
)paren
suffix:semicolon
)brace
multiline_comment|/* Now we&squot;re pointing at the first frag which isn&squot;t totally obsoleted by &n;&t;   the new frag */
id|newfrag-&gt;next
op_assign
id|this
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|this
op_logical_or
id|newfrag-&gt;ofs
op_plus
id|newfrag-&gt;size
op_eq
id|this-&gt;ofs
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Still some overlap */
id|this-&gt;size
op_assign
(paren
id|this-&gt;ofs
op_plus
id|this-&gt;size
)paren
op_minus
(paren
id|newfrag-&gt;ofs
op_plus
id|newfrag-&gt;size
)paren
suffix:semicolon
id|this-&gt;ofs
op_assign
id|newfrag-&gt;ofs
op_plus
id|newfrag-&gt;size
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|jffs2_truncate_fraglist
r_void
id|jffs2_truncate_fraglist
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
comma
r_struct
id|jffs2_node_frag
op_star
op_star
id|list
comma
r_uint32
id|size
)paren
(brace
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Truncating fraglist to 0x%08x bytes&bslash;n&quot;
comma
id|size
)paren
)paren
suffix:semicolon
r_while
c_loop
(paren
op_star
id|list
)paren
(brace
r_if
c_cond
(paren
(paren
op_star
id|list
)paren
op_member_access_from_pointer
id|ofs
op_ge
id|size
)paren
(brace
r_struct
id|jffs2_node_frag
op_star
id|this
op_assign
op_star
id|list
suffix:semicolon
op_star
id|list
op_assign
id|this-&gt;next
suffix:semicolon
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Removing frag 0x%08x-0x%08x&bslash;n&quot;
comma
id|this-&gt;ofs
comma
id|this-&gt;ofs
op_plus
id|this-&gt;size
)paren
)paren
suffix:semicolon
id|jffs2_obsolete_node_frag
c_func
(paren
id|c
comma
id|this
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
op_star
id|list
)paren
op_member_access_from_pointer
id|ofs
op_plus
(paren
op_star
id|list
)paren
op_member_access_from_pointer
id|size
OG
id|size
)paren
(brace
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Truncating frag 0x%08x-0x%08x&bslash;n&quot;
comma
(paren
op_star
id|list
)paren
op_member_access_from_pointer
id|ofs
comma
(paren
op_star
id|list
)paren
op_member_access_from_pointer
id|ofs
op_plus
(paren
op_star
id|list
)paren
op_member_access_from_pointer
id|size
)paren
)paren
suffix:semicolon
(paren
op_star
id|list
)paren
op_member_access_from_pointer
id|size
op_assign
id|size
op_minus
(paren
op_star
id|list
)paren
op_member_access_from_pointer
id|ofs
suffix:semicolon
)brace
id|list
op_assign
op_amp
(paren
op_star
id|list
)paren
op_member_access_from_pointer
id|next
suffix:semicolon
)brace
)brace
multiline_comment|/* Scan the list of all nodes present for this ino, build map of versions, etc. */
DECL|function|jffs2_do_read_inode
r_int
id|jffs2_do_read_inode
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
comma
r_struct
id|jffs2_inode_info
op_star
id|f
comma
r_uint32
id|ino
comma
r_struct
id|jffs2_raw_inode
op_star
id|latest_node
)paren
(brace
r_struct
id|jffs2_tmp_dnode_info
op_star
id|tn_list
comma
op_star
id|tn
suffix:semicolon
r_struct
id|jffs2_full_dirent
op_star
id|fd_list
suffix:semicolon
r_struct
id|jffs2_full_dnode
op_star
id|fn
op_assign
l_int|NULL
suffix:semicolon
r_uint32
id|crc
suffix:semicolon
r_uint32
id|latest_mctime
comma
id|mctime_ver
suffix:semicolon
r_uint32
id|mdata_ver
op_assign
l_int|0
suffix:semicolon
r_int
id|retlen
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|D2
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;jffs2_do_read_inode(): getting inocache&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|f-&gt;inocache
op_assign
id|jffs2_get_ino_cache
c_func
(paren
id|c
comma
id|ino
)paren
suffix:semicolon
id|D2
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;jffs2_do_read_inode(): Got inocache at %p&bslash;n&quot;
comma
id|f-&gt;inocache
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|f-&gt;inocache
op_logical_and
id|ino
op_eq
l_int|1
)paren
(brace
multiline_comment|/* Special case - no root inode on medium */
id|f-&gt;inocache
op_assign
id|jffs2_alloc_inode_cache
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|f-&gt;inocache
)paren
(brace
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;jffs2_do_read_inode(): Cannot allocate inocache for root inode&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;jffs2_do_read_inode(): Creating inocache for root inode&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|f-&gt;inocache
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|jffs2_inode_cache
)paren
)paren
suffix:semicolon
id|f-&gt;inocache-&gt;ino
op_assign
id|f-&gt;inocache-&gt;nlink
op_assign
l_int|1
suffix:semicolon
id|f-&gt;inocache-&gt;nodes
op_assign
(paren
r_struct
id|jffs2_raw_node_ref
op_star
)paren
id|f-&gt;inocache
suffix:semicolon
id|jffs2_add_ino_cache
c_func
(paren
id|c
comma
id|f-&gt;inocache
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|f-&gt;inocache
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;jffs2_do_read_inode() on nonexistent ino %u&bslash;n&quot;
comma
id|ino
)paren
suffix:semicolon
r_return
op_minus
id|ENOENT
suffix:semicolon
)brace
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;jffs2_do_read_inode(): ino #%u nlink is %d&bslash;n&quot;
comma
id|ino
comma
id|f-&gt;inocache-&gt;nlink
)paren
)paren
suffix:semicolon
multiline_comment|/* Grab all nodes relevant to this ino */
id|ret
op_assign
id|jffs2_get_inode_nodes
c_func
(paren
id|c
comma
id|ino
comma
id|f
comma
op_amp
id|tn_list
comma
op_amp
id|fd_list
comma
op_amp
id|f-&gt;highest_version
comma
op_amp
id|latest_mctime
comma
op_amp
id|mctime_ver
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;jffs2_get_inode_nodes() for ino %u returned %d&bslash;n&quot;
comma
id|ino
comma
id|ret
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
id|f-&gt;dents
op_assign
id|fd_list
suffix:semicolon
r_while
c_loop
(paren
id|tn_list
)paren
(brace
id|tn
op_assign
id|tn_list
suffix:semicolon
id|fn
op_assign
id|tn-&gt;fn
suffix:semicolon
r_if
c_cond
(paren
id|f-&gt;metadata
op_logical_and
id|tn-&gt;version
OG
id|mdata_ver
)paren
(brace
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Obsoleting old metadata at 0x%08x&bslash;n&quot;
comma
id|f-&gt;metadata-&gt;raw-&gt;flash_offset
op_amp
op_complement
l_int|3
)paren
)paren
suffix:semicolon
id|jffs2_mark_node_obsolete
c_func
(paren
id|c
comma
id|f-&gt;metadata-&gt;raw
)paren
suffix:semicolon
id|jffs2_free_full_dnode
c_func
(paren
id|f-&gt;metadata
)paren
suffix:semicolon
id|f-&gt;metadata
op_assign
l_int|NULL
suffix:semicolon
id|mdata_ver
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|fn-&gt;size
)paren
(brace
id|jffs2_add_full_dnode_to_inode
c_func
(paren
id|c
comma
id|f
comma
id|fn
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Zero-sized node at end of version list. Just a metadata update */
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;metadata @%08x: ver %d&bslash;n&quot;
comma
id|fn-&gt;raw-&gt;flash_offset
op_amp
op_complement
l_int|3
comma
id|tn-&gt;version
)paren
)paren
suffix:semicolon
id|f-&gt;metadata
op_assign
id|fn
suffix:semicolon
id|mdata_ver
op_assign
id|tn-&gt;version
suffix:semicolon
)brace
id|tn_list
op_assign
id|tn-&gt;next
suffix:semicolon
id|jffs2_free_tmp_dnode_info
c_func
(paren
id|tn
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|fn
)paren
(brace
multiline_comment|/* No data nodes for this inode. */
r_if
c_cond
(paren
id|ino
op_ne
l_int|1
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;jffs2_do_read_inode(): No data nodes found for ino #%u&bslash;n&quot;
comma
id|ino
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fd_list
)paren
(brace
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;jffs2_do_read_inode(): But it has children so we fake some modes for it&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|latest_node-&gt;mode
op_assign
id|S_IFDIR
op_or
id|S_IRUGO
op_or
id|S_IWUSR
op_or
id|S_IXUGO
suffix:semicolon
id|latest_node-&gt;version
op_assign
l_int|0
suffix:semicolon
id|latest_node-&gt;atime
op_assign
id|latest_node-&gt;ctime
op_assign
id|latest_node-&gt;mtime
op_assign
l_int|0
suffix:semicolon
id|latest_node-&gt;isize
op_assign
l_int|0
suffix:semicolon
id|latest_node-&gt;gid
op_assign
l_int|0
suffix:semicolon
id|latest_node-&gt;uid
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|ret
op_assign
id|jffs2_flash_read
c_func
(paren
id|c
comma
id|fn-&gt;raw-&gt;flash_offset
op_amp
op_complement
l_int|3
comma
r_sizeof
(paren
op_star
id|latest_node
)paren
comma
op_amp
id|retlen
comma
(paren
r_void
op_star
)paren
id|latest_node
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_logical_or
id|retlen
op_ne
r_sizeof
(paren
op_star
id|latest_node
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;MTD read in jffs2_do_read_inode() failed: Returned %d, %ld of %d bytes read&bslash;n&quot;
comma
id|ret
comma
(paren
r_int
)paren
id|retlen
comma
r_sizeof
(paren
op_star
id|latest_node
)paren
)paren
suffix:semicolon
multiline_comment|/* FIXME: If this fails, there seems to be a memory leak. Find it. */
id|jffs2_do_clear_inode
c_func
(paren
id|c
comma
id|f
)paren
suffix:semicolon
r_return
id|ret
ques
c_cond
id|ret
suffix:colon
op_minus
id|EIO
suffix:semicolon
)brace
id|crc
op_assign
id|crc32
c_func
(paren
l_int|0
comma
id|latest_node
comma
r_sizeof
(paren
op_star
id|latest_node
)paren
op_minus
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
id|crc
op_ne
id|latest_node-&gt;node_crc
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;CRC failed for read_inode of inode %u at physical location 0x%x&bslash;n&quot;
comma
id|ino
comma
id|fn-&gt;raw-&gt;flash_offset
op_amp
op_complement
l_int|3
)paren
suffix:semicolon
id|jffs2_do_clear_inode
c_func
(paren
id|c
comma
id|f
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|latest_node-&gt;mode
op_amp
id|S_IFMT
)paren
(brace
r_case
id|S_IFDIR
suffix:colon
r_if
c_cond
(paren
id|mctime_ver
OG
id|latest_node-&gt;version
)paren
(brace
multiline_comment|/* The times in the latest_node are actually older than&n;&t;&t;&t;   mctime in the latest dirent. Cheat. */
id|latest_node-&gt;ctime
op_assign
id|latest_node-&gt;mtime
op_assign
id|latest_mctime
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|S_IFREG
suffix:colon
multiline_comment|/* If it was a regular file, truncate it to the latest node&squot;s isize */
id|jffs2_truncate_fraglist
c_func
(paren
id|c
comma
op_amp
id|f-&gt;fraglist
comma
id|latest_node-&gt;isize
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|S_IFLNK
suffix:colon
multiline_comment|/* Hack to work around broken isize in old symlink code.&n;&t;&t;   Remove this when dwmw2 comes to his senses and stops&n;&t;&t;   symlinks from being an entirely gratuitous special&n;&t;&t;   case. */
r_if
c_cond
(paren
op_logical_neg
id|latest_node-&gt;isize
)paren
id|latest_node-&gt;isize
op_assign
id|latest_node-&gt;dsize
suffix:semicolon
multiline_comment|/* fall through... */
r_case
id|S_IFBLK
suffix:colon
r_case
id|S_IFCHR
suffix:colon
multiline_comment|/* Xertain inode types should have only one data node, and it&squot;s&n;&t;&t;   kept as the metadata node */
r_if
c_cond
(paren
id|f-&gt;metadata
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Argh. Special inode #%u with mode 0%o had metadata node&bslash;n&quot;
comma
id|ino
comma
id|latest_node-&gt;mode
)paren
suffix:semicolon
id|jffs2_do_clear_inode
c_func
(paren
id|c
comma
id|f
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|f-&gt;fraglist
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Argh. Special inode #%u with mode 0%o has no fragments&bslash;n&quot;
comma
id|ino
comma
id|latest_node-&gt;mode
)paren
suffix:semicolon
id|jffs2_do_clear_inode
c_func
(paren
id|c
comma
id|f
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/* ASSERT: f-&gt;fraglist != NULL */
r_if
c_cond
(paren
id|f-&gt;fraglist-&gt;next
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Argh. Special inode #%u with mode 0%o had more than one node&bslash;n&quot;
comma
id|ino
comma
id|latest_node-&gt;mode
)paren
suffix:semicolon
multiline_comment|/* FIXME: Deal with it - check crc32, check for duplicate node, check times and discard the older one */
id|jffs2_do_clear_inode
c_func
(paren
id|c
comma
id|f
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/* OK. We&squot;re happy */
id|f-&gt;metadata
op_assign
id|f-&gt;fraglist-&gt;node
suffix:semicolon
id|jffs2_free_node_frag
c_func
(paren
id|f-&gt;fraglist
)paren
suffix:semicolon
id|f-&gt;fraglist
op_assign
l_int|NULL
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|jffs2_do_clear_inode
r_void
id|jffs2_do_clear_inode
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
comma
r_struct
id|jffs2_inode_info
op_star
id|f
)paren
(brace
r_struct
id|jffs2_node_frag
op_star
id|frag
comma
op_star
id|frags
suffix:semicolon
r_struct
id|jffs2_full_dirent
op_star
id|fd
comma
op_star
id|fds
suffix:semicolon
multiline_comment|/* If it&squot;s a deleted inode, grab the alloc_sem to keep the&n;&t;   (maybe temporary) BUG() in jffs2_mark_node_obsolete() &n;&t;   from triggering */
r_if
c_cond
(paren
op_logical_neg
id|f-&gt;inocache-&gt;nlink
)paren
(brace
id|down
c_func
(paren
op_amp
id|c-&gt;alloc_sem
)paren
suffix:semicolon
)brace
id|down
c_func
(paren
op_amp
id|f-&gt;sem
)paren
suffix:semicolon
id|frags
op_assign
id|f-&gt;fraglist
suffix:semicolon
id|fds
op_assign
id|f-&gt;dents
suffix:semicolon
r_if
c_cond
(paren
id|f-&gt;metadata
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|f-&gt;inocache-&gt;nlink
)paren
id|jffs2_mark_node_obsolete
c_func
(paren
id|c
comma
id|f-&gt;metadata-&gt;raw
)paren
suffix:semicolon
id|jffs2_free_full_dnode
c_func
(paren
id|f-&gt;metadata
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|frags
)paren
(brace
id|frag
op_assign
id|frags
suffix:semicolon
id|frags
op_assign
id|frag-&gt;next
suffix:semicolon
id|D2
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;jffs2_do_clear_inode: frag at 0x%x-0x%x: node %p, frags %d--&bslash;n&quot;
comma
id|frag-&gt;ofs
comma
id|frag-&gt;ofs
op_plus
id|frag-&gt;size
comma
id|frag-&gt;node
comma
id|frag-&gt;node
ques
c_cond
id|frag-&gt;node-&gt;frags
suffix:colon
l_int|0
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|frag-&gt;node
op_logical_and
op_logical_neg
(paren
op_decrement
id|frag-&gt;node-&gt;frags
)paren
)paren
(brace
multiline_comment|/* Not a hole, and it&squot;s the final remaining frag of this node. Free the node */
r_if
c_cond
(paren
op_logical_neg
id|f-&gt;inocache-&gt;nlink
)paren
id|jffs2_mark_node_obsolete
c_func
(paren
id|c
comma
id|frag-&gt;node-&gt;raw
)paren
suffix:semicolon
id|jffs2_free_full_dnode
c_func
(paren
id|frag-&gt;node
)paren
suffix:semicolon
)brace
id|jffs2_free_node_frag
c_func
(paren
id|frag
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|fds
)paren
(brace
id|fd
op_assign
id|fds
suffix:semicolon
id|fds
op_assign
id|fd-&gt;next
suffix:semicolon
id|jffs2_free_full_dirent
c_func
(paren
id|fd
)paren
suffix:semicolon
)brace
multiline_comment|/* Urgh. Is there a nicer way to do this? */
r_if
c_cond
(paren
op_logical_neg
id|f-&gt;inocache-&gt;nlink
)paren
(brace
id|up
c_func
(paren
op_amp
id|f-&gt;sem
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|c-&gt;alloc_sem
)paren
suffix:semicolon
)brace
r_else
(brace
id|up
c_func
(paren
op_amp
id|f-&gt;sem
)paren
suffix:semicolon
)brace
)brace
eof
