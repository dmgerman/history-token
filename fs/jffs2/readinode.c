multiline_comment|/*&n; * JFFS2 -- Journalling Flash File System, Version 2.&n; *&n; * Copyright (C) 2001, 2002 Red Hat, Inc.&n; *&n; * Created by David Woodhouse &lt;dwmw2@cambridge.redhat.com&gt;&n; *&n; * For licensing information, see the file &squot;LICENCE&squot; in this directory.&n; *&n; * $Id: readinode.c,v 1.106 2003/05/14 06:53:26 dwmw2 Exp $&n; *&n; */
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/crc32.h&gt;
macro_line|#include &lt;linux/pagemap.h&gt;
macro_line|#include &lt;linux/mtd/mtd.h&gt;
macro_line|#include &lt;linux/compiler.h&gt;
macro_line|#include &quot;nodelist.h&quot;
r_static
r_int
id|jffs2_add_frag_to_fragtree
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
comma
r_struct
id|rb_root
op_star
id|list
comma
r_struct
id|jffs2_node_frag
op_star
id|newfrag
)paren
suffix:semicolon
macro_line|#if CONFIG_JFFS2_FS_DEBUG &gt;= 1
DECL|function|jffs2_print_fragtree
r_static
r_void
id|jffs2_print_fragtree
c_func
(paren
r_struct
id|rb_root
op_star
id|list
comma
r_int
id|permitbug
)paren
(brace
r_struct
id|jffs2_node_frag
op_star
id|this
op_assign
id|frag_first
c_func
(paren
id|list
)paren
suffix:semicolon
r_uint32
id|lastofs
op_assign
l_int|0
suffix:semicolon
r_int
id|buggy
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|this
)paren
(brace
r_if
c_cond
(paren
id|this-&gt;node
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;frag %04x-%04x: 0x%08x(%d) on flash (*%p). left (%p), right (%p), parent (%p)&bslash;n&quot;
comma
id|this-&gt;ofs
comma
id|this-&gt;ofs
op_plus
id|this-&gt;size
comma
id|ref_offset
c_func
(paren
id|this-&gt;node-&gt;raw
)paren
comma
id|ref_flags
c_func
(paren
id|this-&gt;node-&gt;raw
)paren
comma
id|this
comma
id|frag_left
c_func
(paren
id|this
)paren
comma
id|frag_right
c_func
(paren
id|this
)paren
comma
id|frag_parent
c_func
(paren
id|this
)paren
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;frag %04x-%04x: hole (*%p). left (%p} right (%p), parent (%p)&bslash;n&quot;
comma
id|this-&gt;ofs
comma
id|this-&gt;ofs
op_plus
id|this-&gt;size
comma
id|this
comma
id|frag_left
c_func
(paren
id|this
)paren
comma
id|frag_right
c_func
(paren
id|this
)paren
comma
id|frag_parent
c_func
(paren
id|this
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|this-&gt;ofs
op_ne
id|lastofs
)paren
id|buggy
op_assign
l_int|1
suffix:semicolon
id|lastofs
op_assign
id|this-&gt;ofs
op_plus
id|this-&gt;size
suffix:semicolon
id|this
op_assign
id|frag_next
c_func
(paren
id|this
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|buggy
op_logical_and
op_logical_neg
id|permitbug
)paren
(brace
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;Frag tree got a hole in it&bslash;n&quot;
)paren
suffix:semicolon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
DECL|function|jffs2_print_frag_list
r_void
id|jffs2_print_frag_list
c_func
(paren
r_struct
id|jffs2_inode_info
op_star
id|f
)paren
(brace
id|jffs2_print_fragtree
c_func
(paren
op_amp
id|f-&gt;fragtree
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|f-&gt;metadata
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;metadata at 0x%08x&bslash;n&quot;
comma
id|ref_offset
c_func
(paren
id|f-&gt;metadata-&gt;raw
)paren
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif /* D1 */
DECL|function|jffs2_obsolete_node_frag
r_static
r_void
id|jffs2_obsolete_node_frag
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
comma
r_struct
id|jffs2_node_frag
op_star
id|this
)paren
(brace
r_if
c_cond
(paren
id|this-&gt;node
)paren
(brace
id|this-&gt;node-&gt;frags
op_decrement
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|this-&gt;node-&gt;frags
)paren
(brace
multiline_comment|/* The node has no valid frags left. It&squot;s totally obsoleted */
id|D2
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Marking old node @0x%08x (0x%04x-0x%04x) obsolete&bslash;n&quot;
comma
id|ref_offset
c_func
(paren
id|this-&gt;node-&gt;raw
)paren
comma
id|this-&gt;node-&gt;ofs
comma
id|this-&gt;node-&gt;ofs
op_plus
id|this-&gt;node-&gt;size
)paren
)paren
suffix:semicolon
id|jffs2_mark_node_obsolete
c_func
(paren
id|c
comma
id|this-&gt;node-&gt;raw
)paren
suffix:semicolon
id|jffs2_free_full_dnode
c_func
(paren
id|this-&gt;node
)paren
suffix:semicolon
)brace
r_else
(brace
id|D2
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Marking old node @0x%08x (0x%04x-0x%04x) REF_NORMAL. frags is %d&bslash;n&quot;
comma
id|ref_offset
c_func
(paren
id|this-&gt;node-&gt;raw
)paren
comma
id|this-&gt;node-&gt;ofs
comma
id|this-&gt;node-&gt;ofs
op_plus
id|this-&gt;node-&gt;size
comma
id|this-&gt;node-&gt;frags
)paren
)paren
suffix:semicolon
id|mark_ref_normal
c_func
(paren
id|this-&gt;node-&gt;raw
)paren
suffix:semicolon
)brace
)brace
id|jffs2_free_node_frag
c_func
(paren
id|this
)paren
suffix:semicolon
)brace
multiline_comment|/* Given an inode, probably with existing list of fragments, add the new node&n; * to the fragment list.&n; */
DECL|function|jffs2_add_full_dnode_to_inode
r_int
id|jffs2_add_full_dnode_to_inode
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
comma
r_struct
id|jffs2_inode_info
op_star
id|f
comma
r_struct
id|jffs2_full_dnode
op_star
id|fn
)paren
(brace
r_int
id|ret
suffix:semicolon
r_struct
id|jffs2_node_frag
op_star
id|newfrag
suffix:semicolon
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;jffs2_add_full_dnode_to_inode(ino #%u, f %p, fn %p)&bslash;n&quot;
comma
id|f-&gt;inocache-&gt;ino
comma
id|f
comma
id|fn
)paren
)paren
suffix:semicolon
id|newfrag
op_assign
id|jffs2_alloc_node_frag
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|newfrag
)paren
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|D2
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;adding node %04x-%04x @0x%08x on flash, newfrag *%p&bslash;n&quot;
comma
id|fn-&gt;ofs
comma
id|fn-&gt;ofs
op_plus
id|fn-&gt;size
comma
id|ref_offset
c_func
(paren
id|fn-&gt;raw
)paren
comma
id|newfrag
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|fn-&gt;size
)paren
)paren
(brace
id|jffs2_free_node_frag
c_func
(paren
id|newfrag
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|newfrag-&gt;ofs
op_assign
id|fn-&gt;ofs
suffix:semicolon
id|newfrag-&gt;size
op_assign
id|fn-&gt;size
suffix:semicolon
id|newfrag-&gt;node
op_assign
id|fn
suffix:semicolon
id|newfrag-&gt;node-&gt;frags
op_assign
l_int|1
suffix:semicolon
id|ret
op_assign
id|jffs2_add_frag_to_fragtree
c_func
(paren
id|c
comma
op_amp
id|f-&gt;fragtree
comma
id|newfrag
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_return
id|ret
suffix:semicolon
multiline_comment|/* If we now share a page with other nodes, mark either previous&n;&t;   or next node REF_NORMAL, as appropriate.  */
r_if
c_cond
(paren
id|newfrag-&gt;ofs
op_amp
(paren
id|PAGE_CACHE_SIZE
op_minus
l_int|1
)paren
)paren
(brace
r_struct
id|jffs2_node_frag
op_star
id|prev
op_assign
id|frag_prev
c_func
(paren
id|newfrag
)paren
suffix:semicolon
id|mark_ref_normal
c_func
(paren
id|fn-&gt;raw
)paren
suffix:semicolon
multiline_comment|/* If we don&squot;t start at zero there&squot;s _always_ a previous */
r_if
c_cond
(paren
id|prev-&gt;node
)paren
id|mark_ref_normal
c_func
(paren
id|prev-&gt;node-&gt;raw
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|newfrag-&gt;ofs
op_plus
id|newfrag-&gt;size
)paren
op_amp
(paren
id|PAGE_CACHE_SIZE
op_minus
l_int|1
)paren
)paren
(brace
r_struct
id|jffs2_node_frag
op_star
id|next
op_assign
id|frag_next
c_func
(paren
id|newfrag
)paren
suffix:semicolon
r_if
c_cond
(paren
id|next
)paren
(brace
id|mark_ref_normal
c_func
(paren
id|fn-&gt;raw
)paren
suffix:semicolon
r_if
c_cond
(paren
id|next-&gt;node
)paren
id|mark_ref_normal
c_func
(paren
id|next-&gt;node-&gt;raw
)paren
suffix:semicolon
)brace
)brace
id|D2
c_func
(paren
id|jffs2_print_frag_list
c_func
(paren
id|f
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Doesn&squot;t set inode-&gt;i_size */
DECL|function|jffs2_add_frag_to_fragtree
r_static
r_int
id|jffs2_add_frag_to_fragtree
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
comma
r_struct
id|rb_root
op_star
id|list
comma
r_struct
id|jffs2_node_frag
op_star
id|newfrag
)paren
(brace
r_struct
id|jffs2_node_frag
op_star
id|this
suffix:semicolon
r_uint32
id|lastend
suffix:semicolon
multiline_comment|/* Skip all the nodes which are completed before this one starts */
id|this
op_assign
id|jffs2_lookup_node_frag
c_func
(paren
id|list
comma
id|newfrag-&gt;node-&gt;ofs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|this
)paren
(brace
id|D2
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;j_a_f_d_t_f: Lookup gave frag 0x%04x-0x%04x; phys 0x%08x (*%p)&bslash;n&quot;
comma
id|this-&gt;ofs
comma
id|this-&gt;ofs
op_plus
id|this-&gt;size
comma
id|this-&gt;node
ques
c_cond
(paren
id|ref_offset
c_func
(paren
id|this-&gt;node-&gt;raw
)paren
)paren
suffix:colon
l_int|0xffffffff
comma
id|this
)paren
)paren
suffix:semicolon
id|lastend
op_assign
id|this-&gt;ofs
op_plus
id|this-&gt;size
suffix:semicolon
)brace
r_else
(brace
id|D2
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;j_a_f_d_t_f: Lookup gave no frag&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|lastend
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* See if we ran off the end of the list */
r_if
c_cond
(paren
id|lastend
op_le
id|newfrag-&gt;ofs
)paren
(brace
multiline_comment|/* We did */
multiline_comment|/* Check if &squot;this&squot; node was on the same page as the new node.&n;&t;&t;   If so, both &squot;this&squot; and the new node get marked REF_NORMAL so&n;&t;&t;   the GC can take a look.&n;&t;&t;*/
r_if
c_cond
(paren
(paren
id|lastend
op_minus
l_int|1
)paren
op_rshift
id|PAGE_CACHE_SHIFT
op_eq
id|newfrag-&gt;ofs
op_rshift
id|PAGE_CACHE_SHIFT
)paren
(brace
r_if
c_cond
(paren
id|this-&gt;node
)paren
id|mark_ref_normal
c_func
(paren
id|this-&gt;node-&gt;raw
)paren
suffix:semicolon
id|mark_ref_normal
c_func
(paren
id|newfrag-&gt;node-&gt;raw
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|lastend
OL
id|newfrag-&gt;node-&gt;ofs
)paren
(brace
multiline_comment|/* ... and we need to put a hole in before the new node */
r_struct
id|jffs2_node_frag
op_star
id|holefrag
op_assign
id|jffs2_alloc_node_frag
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|holefrag
)paren
(brace
id|jffs2_free_node_frag
c_func
(paren
id|newfrag
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|holefrag-&gt;ofs
op_assign
id|lastend
suffix:semicolon
id|holefrag-&gt;size
op_assign
id|newfrag-&gt;node-&gt;ofs
op_minus
id|lastend
suffix:semicolon
id|holefrag-&gt;node
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|this
)paren
(brace
multiline_comment|/* By definition, the &squot;this&squot; node has no right-hand child, &n;&t;&t;&t;&t;   because there are no frags with offset greater than it.&n;&t;&t;&t;&t;   So that&squot;s where we want to put the hole */
id|D2
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Adding hole frag (%p) on right of node at (%p)&bslash;n&quot;
comma
id|holefrag
comma
id|this
)paren
)paren
suffix:semicolon
id|rb_link_node
c_func
(paren
op_amp
id|holefrag-&gt;rb
comma
op_amp
id|this-&gt;rb
comma
op_amp
id|this-&gt;rb.rb_right
)paren
suffix:semicolon
)brace
r_else
(brace
id|D2
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Adding hole frag (%p) at root of tree&bslash;n&quot;
comma
id|holefrag
)paren
)paren
suffix:semicolon
id|rb_link_node
c_func
(paren
op_amp
id|holefrag-&gt;rb
comma
l_int|NULL
comma
op_amp
id|list-&gt;rb_node
)paren
suffix:semicolon
)brace
id|rb_insert_color
c_func
(paren
op_amp
id|holefrag-&gt;rb
comma
id|list
)paren
suffix:semicolon
id|this
op_assign
id|holefrag
suffix:semicolon
)brace
r_if
c_cond
(paren
id|this
)paren
(brace
multiline_comment|/* By definition, the &squot;this&squot; node has no right-hand child, &n;&t;&t;&t;   because there are no frags with offset greater than it.&n;&t;&t;&t;   So that&squot;s where we want to put the hole */
id|D2
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Adding new frag (%p) on right of node at (%p)&bslash;n&quot;
comma
id|newfrag
comma
id|this
)paren
)paren
suffix:semicolon
id|rb_link_node
c_func
(paren
op_amp
id|newfrag-&gt;rb
comma
op_amp
id|this-&gt;rb
comma
op_amp
id|this-&gt;rb.rb_right
)paren
suffix:semicolon
)brace
r_else
(brace
id|D2
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Adding new frag (%p) at root of tree&bslash;n&quot;
comma
id|newfrag
)paren
)paren
suffix:semicolon
id|rb_link_node
c_func
(paren
op_amp
id|newfrag-&gt;rb
comma
l_int|NULL
comma
op_amp
id|list-&gt;rb_node
)paren
suffix:semicolon
)brace
id|rb_insert_color
c_func
(paren
op_amp
id|newfrag-&gt;rb
comma
id|list
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|D2
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;j_a_f_d_t_f: dealing with frag 0x%04x-0x%04x; phys 0x%08x (*%p)&bslash;n&quot;
comma
id|this-&gt;ofs
comma
id|this-&gt;ofs
op_plus
id|this-&gt;size
comma
id|this-&gt;node
ques
c_cond
(paren
id|ref_offset
c_func
(paren
id|this-&gt;node-&gt;raw
)paren
)paren
suffix:colon
l_int|0xffffffff
comma
id|this
)paren
)paren
suffix:semicolon
multiline_comment|/* OK. &squot;this&squot; is pointing at the first frag that newfrag-&gt;ofs at least partially obsoletes,&n;&t; * - i.e. newfrag-&gt;ofs &lt; this-&gt;ofs+this-&gt;size &amp;&amp; newfrag-&gt;ofs &gt;= this-&gt;ofs  &n;&t; */
r_if
c_cond
(paren
id|newfrag-&gt;ofs
OG
id|this-&gt;ofs
)paren
(brace
multiline_comment|/* This node isn&squot;t completely obsoleted. The start of it remains valid */
multiline_comment|/* Mark the new node and the partially covered node REF_NORMAL -- let&n;&t;&t;   the GC take a look at them */
id|mark_ref_normal
c_func
(paren
id|newfrag-&gt;node-&gt;raw
)paren
suffix:semicolon
r_if
c_cond
(paren
id|this-&gt;node
)paren
id|mark_ref_normal
c_func
(paren
id|this-&gt;node-&gt;raw
)paren
suffix:semicolon
r_if
c_cond
(paren
id|this-&gt;ofs
op_plus
id|this-&gt;size
OG
id|newfrag-&gt;ofs
op_plus
id|newfrag-&gt;size
)paren
(brace
multiline_comment|/* The new node splits &squot;this&squot; frag into two */
r_struct
id|jffs2_node_frag
op_star
id|newfrag2
op_assign
id|jffs2_alloc_node_frag
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|newfrag2
)paren
(brace
id|jffs2_free_node_frag
c_func
(paren
id|newfrag
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|D2
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;split old frag 0x%04x-0x%04x --&gt;&quot;
comma
id|this-&gt;ofs
comma
id|this-&gt;ofs
op_plus
id|this-&gt;size
)paren
suffix:semicolon
r_if
(paren
id|this-&gt;node
)paren
id|printk
c_func
(paren
l_string|&quot;phys 0x%08x&bslash;n&quot;
comma
id|ref_offset
c_func
(paren
id|this-&gt;node-&gt;raw
)paren
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;hole&bslash;n&quot;
)paren
suffix:semicolon
)paren
multiline_comment|/* New second frag pointing to this&squot;s node */
id|newfrag2-&gt;ofs
op_assign
id|newfrag-&gt;ofs
op_plus
id|newfrag-&gt;size
suffix:semicolon
id|newfrag2-&gt;size
op_assign
(paren
id|this-&gt;ofs
op_plus
id|this-&gt;size
)paren
op_minus
id|newfrag2-&gt;ofs
suffix:semicolon
id|newfrag2-&gt;node
op_assign
id|this-&gt;node
suffix:semicolon
r_if
c_cond
(paren
id|this-&gt;node
)paren
id|this-&gt;node-&gt;frags
op_increment
suffix:semicolon
multiline_comment|/* Adjust size of original &squot;this&squot; */
id|this-&gt;size
op_assign
id|newfrag-&gt;ofs
op_minus
id|this-&gt;ofs
suffix:semicolon
multiline_comment|/* Now, we know there&squot;s no node with offset&n;&t;&t;&t;   greater than this-&gt;ofs but smaller than&n;&t;&t;&t;   newfrag2-&gt;ofs or newfrag-&gt;ofs, for obvious&n;&t;&t;&t;   reasons. So we can do a tree insert from&n;&t;&t;&t;   &squot;this&squot; to insert newfrag, and a tree insert&n;&t;&t;&t;   from newfrag to insert newfrag2. */
id|jffs2_fragtree_insert
c_func
(paren
id|newfrag
comma
id|this
)paren
suffix:semicolon
id|rb_insert_color
c_func
(paren
op_amp
id|newfrag-&gt;rb
comma
id|list
)paren
suffix:semicolon
id|jffs2_fragtree_insert
c_func
(paren
id|newfrag2
comma
id|newfrag
)paren
suffix:semicolon
id|rb_insert_color
c_func
(paren
op_amp
id|newfrag2-&gt;rb
comma
id|list
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* New node just reduces &squot;this&squot; frag in size, doesn&squot;t split it */
id|this-&gt;size
op_assign
id|newfrag-&gt;ofs
op_minus
id|this-&gt;ofs
suffix:semicolon
multiline_comment|/* Again, we know it lives down here in the tree */
id|jffs2_fragtree_insert
c_func
(paren
id|newfrag
comma
id|this
)paren
suffix:semicolon
id|rb_insert_color
c_func
(paren
op_amp
id|newfrag-&gt;rb
comma
id|list
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* New frag starts at the same point as &squot;this&squot; used to. Replace &n;&t;&t;   it in the tree without doing a delete and insertion */
id|D2
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Inserting newfrag (*%p),%d-%d in before &squot;this&squot; (*%p),%d-%d&bslash;n&quot;
comma
id|newfrag
comma
id|newfrag-&gt;ofs
comma
id|newfrag-&gt;ofs
op_plus
id|newfrag-&gt;size
comma
id|this
comma
id|this-&gt;ofs
comma
id|this-&gt;ofs
op_plus
id|this-&gt;size
)paren
)paren
suffix:semicolon
id|rb_replace_node
c_func
(paren
op_amp
id|this-&gt;rb
comma
op_amp
id|newfrag-&gt;rb
comma
id|list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|newfrag-&gt;ofs
op_plus
id|newfrag-&gt;size
op_ge
id|this-&gt;ofs
op_plus
id|this-&gt;size
)paren
(brace
id|D2
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Obsoleting node frag %p (%x-%x)&bslash;n&quot;
comma
id|this
comma
id|this-&gt;ofs
comma
id|this-&gt;ofs
op_plus
id|this-&gt;size
)paren
)paren
suffix:semicolon
id|jffs2_obsolete_node_frag
c_func
(paren
id|c
comma
id|this
)paren
suffix:semicolon
)brace
r_else
(brace
id|this-&gt;ofs
op_add_assign
id|newfrag-&gt;size
suffix:semicolon
id|this-&gt;size
op_sub_assign
id|newfrag-&gt;size
suffix:semicolon
id|jffs2_fragtree_insert
c_func
(paren
id|this
comma
id|newfrag
)paren
suffix:semicolon
id|rb_insert_color
c_func
(paren
op_amp
id|this-&gt;rb
comma
id|list
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/* OK, now we have newfrag added in the correct place in the tree, but&n;&t;   frag_next(newfrag) may be a fragment which is overlapped by it &n;&t;*/
r_while
c_loop
(paren
(paren
id|this
op_assign
id|frag_next
c_func
(paren
id|newfrag
)paren
)paren
op_logical_and
id|newfrag-&gt;ofs
op_plus
id|newfrag-&gt;size
op_ge
id|this-&gt;ofs
op_plus
id|this-&gt;size
)paren
(brace
multiline_comment|/* &squot;this&squot; frag is obsoleted completely. */
id|D2
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Obsoleting node frag %p (%x-%x) and removing from tree&bslash;n&quot;
comma
id|this
comma
id|this-&gt;ofs
comma
id|this-&gt;ofs
op_plus
id|this-&gt;size
)paren
)paren
suffix:semicolon
id|rb_erase
c_func
(paren
op_amp
id|this-&gt;rb
comma
id|list
)paren
suffix:semicolon
id|jffs2_obsolete_node_frag
c_func
(paren
id|c
comma
id|this
)paren
suffix:semicolon
)brace
multiline_comment|/* Now we&squot;re pointing at the first frag which isn&squot;t totally obsoleted by &n;&t;   the new frag */
r_if
c_cond
(paren
op_logical_neg
id|this
op_logical_or
id|newfrag-&gt;ofs
op_plus
id|newfrag-&gt;size
op_eq
id|this-&gt;ofs
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Still some overlap but we don&squot;t need to move it in the tree */
id|this-&gt;size
op_assign
(paren
id|this-&gt;ofs
op_plus
id|this-&gt;size
)paren
op_minus
(paren
id|newfrag-&gt;ofs
op_plus
id|newfrag-&gt;size
)paren
suffix:semicolon
id|this-&gt;ofs
op_assign
id|newfrag-&gt;ofs
op_plus
id|newfrag-&gt;size
suffix:semicolon
multiline_comment|/* And mark them REF_NORMAL so the GC takes a look at them */
r_if
c_cond
(paren
id|this-&gt;node
)paren
id|mark_ref_normal
c_func
(paren
id|this-&gt;node-&gt;raw
)paren
suffix:semicolon
id|mark_ref_normal
c_func
(paren
id|newfrag-&gt;node-&gt;raw
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|jffs2_truncate_fraglist
r_void
id|jffs2_truncate_fraglist
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
comma
r_struct
id|rb_root
op_star
id|list
comma
r_uint32
id|size
)paren
(brace
r_struct
id|jffs2_node_frag
op_star
id|frag
op_assign
id|jffs2_lookup_node_frag
c_func
(paren
id|list
comma
id|size
)paren
suffix:semicolon
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Truncating fraglist to 0x%08x bytes&bslash;n&quot;
comma
id|size
)paren
)paren
suffix:semicolon
multiline_comment|/* We know frag-&gt;ofs &lt;= size. That&squot;s what lookup does for us */
r_if
c_cond
(paren
id|frag
op_logical_and
id|frag-&gt;ofs
op_ne
id|size
)paren
(brace
r_if
c_cond
(paren
id|frag-&gt;ofs
op_plus
id|frag-&gt;size
op_ge
id|size
)paren
(brace
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Truncating frag 0x%08x-0x%08x&bslash;n&quot;
comma
id|frag-&gt;ofs
comma
id|frag-&gt;ofs
op_plus
id|frag-&gt;size
)paren
)paren
suffix:semicolon
id|frag-&gt;size
op_assign
id|size
op_minus
id|frag-&gt;ofs
suffix:semicolon
)brace
id|frag
op_assign
id|frag_next
c_func
(paren
id|frag
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|frag
op_logical_and
id|frag-&gt;ofs
op_ge
id|size
)paren
(brace
r_struct
id|jffs2_node_frag
op_star
id|next
op_assign
id|frag_next
c_func
(paren
id|frag
)paren
suffix:semicolon
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Removing frag 0x%08x-0x%08x&bslash;n&quot;
comma
id|frag-&gt;ofs
comma
id|frag-&gt;ofs
op_plus
id|frag-&gt;size
)paren
)paren
suffix:semicolon
id|frag_erase
c_func
(paren
id|frag
comma
id|list
)paren
suffix:semicolon
id|jffs2_obsolete_node_frag
c_func
(paren
id|c
comma
id|frag
)paren
suffix:semicolon
id|frag
op_assign
id|next
suffix:semicolon
)brace
)brace
multiline_comment|/* Scan the list of all nodes present for this ino, build map of versions, etc. */
r_static
r_int
id|jffs2_do_read_inode_internal
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
comma
r_struct
id|jffs2_inode_info
op_star
id|f
comma
r_struct
id|jffs2_raw_inode
op_star
id|latest_node
)paren
suffix:semicolon
DECL|function|jffs2_do_read_inode
r_int
id|jffs2_do_read_inode
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
comma
r_struct
id|jffs2_inode_info
op_star
id|f
comma
r_uint32
id|ino
comma
r_struct
id|jffs2_raw_inode
op_star
id|latest_node
)paren
(brace
id|D2
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;jffs2_do_read_inode(): getting inocache&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|retry_inocache
suffix:colon
id|spin_lock
c_func
(paren
op_amp
id|c-&gt;inocache_lock
)paren
suffix:semicolon
id|f-&gt;inocache
op_assign
id|jffs2_get_ino_cache
c_func
(paren
id|c
comma
id|ino
)paren
suffix:semicolon
id|D2
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;jffs2_do_read_inode(): Got inocache at %p&bslash;n&quot;
comma
id|f-&gt;inocache
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|f-&gt;inocache
)paren
(brace
multiline_comment|/* Check its state. We may need to wait before we can use it */
r_switch
c_cond
(paren
id|f-&gt;inocache-&gt;state
)paren
(brace
r_case
id|INO_STATE_UNCHECKED
suffix:colon
r_case
id|INO_STATE_CHECKEDABSENT
suffix:colon
id|f-&gt;inocache-&gt;state
op_assign
id|INO_STATE_READING
suffix:semicolon
r_break
suffix:semicolon
r_case
id|INO_STATE_CHECKING
suffix:colon
r_case
id|INO_STATE_GC
suffix:colon
multiline_comment|/* If it&squot;s in either of these states, we need&n;&t;&t;&t;   to wait for whoever&squot;s got it to finish and&n;&t;&t;&t;   put it back. */
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;jffs2_get_ino_cache_read waiting for ino #%u in state %d&bslash;n&quot;
comma
id|ino
comma
id|f-&gt;inocache-&gt;state
)paren
)paren
suffix:semicolon
id|sleep_on_spinunlock
c_func
(paren
op_amp
id|c-&gt;inocache_wq
comma
op_amp
id|c-&gt;inocache_lock
)paren
suffix:semicolon
r_goto
id|retry_inocache
suffix:semicolon
r_case
id|INO_STATE_READING
suffix:colon
r_case
id|INO_STATE_PRESENT
suffix:colon
multiline_comment|/* Eep. This should never happen. It can&n;&t;&t;&t;happen if Linux calls read_inode() again&n;&t;&t;&t;before clear_inode() has finished though. */
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Eep. Trying to read_inode #%u when it&squot;s already in state %d!&bslash;n&quot;
comma
id|ino
comma
id|f-&gt;inocache-&gt;state
)paren
suffix:semicolon
multiline_comment|/* Fail. That&squot;s probably better than allowing it to succeed */
id|f-&gt;inocache
op_assign
l_int|NULL
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
id|spin_unlock
c_func
(paren
op_amp
id|c-&gt;inocache_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|f-&gt;inocache
op_logical_and
id|ino
op_eq
l_int|1
)paren
(brace
multiline_comment|/* Special case - no root inode on medium */
id|f-&gt;inocache
op_assign
id|jffs2_alloc_inode_cache
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|f-&gt;inocache
)paren
(brace
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;jffs2_do_read_inode(): Cannot allocate inocache for root inode&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;jffs2_do_read_inode(): Creating inocache for root inode&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|f-&gt;inocache
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|jffs2_inode_cache
)paren
)paren
suffix:semicolon
id|f-&gt;inocache-&gt;ino
op_assign
id|f-&gt;inocache-&gt;nlink
op_assign
l_int|1
suffix:semicolon
id|f-&gt;inocache-&gt;nodes
op_assign
(paren
r_struct
id|jffs2_raw_node_ref
op_star
)paren
id|f-&gt;inocache
suffix:semicolon
id|f-&gt;inocache-&gt;state
op_assign
id|INO_STATE_READING
suffix:semicolon
id|jffs2_add_ino_cache
c_func
(paren
id|c
comma
id|f-&gt;inocache
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|f-&gt;inocache
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;jffs2_do_read_inode() on nonexistent ino %u&bslash;n&quot;
comma
id|ino
)paren
suffix:semicolon
r_return
op_minus
id|ENOENT
suffix:semicolon
)brace
r_return
id|jffs2_do_read_inode_internal
c_func
(paren
id|c
comma
id|f
comma
id|latest_node
)paren
suffix:semicolon
)brace
DECL|function|jffs2_do_crccheck_inode
r_int
id|jffs2_do_crccheck_inode
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
comma
r_struct
id|jffs2_inode_cache
op_star
id|ic
)paren
(brace
r_struct
id|jffs2_raw_inode
id|n
suffix:semicolon
r_struct
id|jffs2_inode_info
op_star
id|f
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|f
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|f
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|memset
c_func
(paren
id|f
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|f
)paren
)paren
suffix:semicolon
id|init_MUTEX_LOCKED
c_func
(paren
op_amp
id|f-&gt;sem
)paren
suffix:semicolon
id|f-&gt;inocache
op_assign
id|ic
suffix:semicolon
id|ret
op_assign
id|jffs2_do_read_inode_internal
c_func
(paren
id|c
comma
id|f
comma
op_amp
id|n
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
(brace
id|up
c_func
(paren
op_amp
id|f-&gt;sem
)paren
suffix:semicolon
id|jffs2_do_clear_inode
c_func
(paren
id|c
comma
id|f
)paren
suffix:semicolon
)brace
id|kfree
(paren
id|f
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|jffs2_do_read_inode_internal
r_static
r_int
id|jffs2_do_read_inode_internal
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
comma
r_struct
id|jffs2_inode_info
op_star
id|f
comma
r_struct
id|jffs2_raw_inode
op_star
id|latest_node
)paren
(brace
r_struct
id|jffs2_tmp_dnode_info
op_star
id|tn_list
comma
op_star
id|tn
suffix:semicolon
r_struct
id|jffs2_full_dirent
op_star
id|fd_list
suffix:semicolon
r_struct
id|jffs2_full_dnode
op_star
id|fn
op_assign
l_int|NULL
suffix:semicolon
r_uint32
id|crc
suffix:semicolon
r_uint32
id|latest_mctime
comma
id|mctime_ver
suffix:semicolon
r_uint32
id|mdata_ver
op_assign
l_int|0
suffix:semicolon
r_int
id|retlen
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;jffs2_do_read_inode_internal(): ino #%u nlink is %d&bslash;n&quot;
comma
id|f-&gt;inocache-&gt;ino
comma
id|f-&gt;inocache-&gt;nlink
)paren
)paren
suffix:semicolon
multiline_comment|/* Grab all nodes relevant to this ino */
id|ret
op_assign
id|jffs2_get_inode_nodes
c_func
(paren
id|c
comma
id|f-&gt;inocache-&gt;ino
comma
id|f
comma
op_amp
id|tn_list
comma
op_amp
id|fd_list
comma
op_amp
id|f-&gt;highest_version
comma
op_amp
id|latest_mctime
comma
op_amp
id|mctime_ver
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;jffs2_get_inode_nodes() for ino %u returned %d&bslash;n&quot;
comma
id|f-&gt;inocache-&gt;ino
comma
id|ret
)paren
suffix:semicolon
r_if
c_cond
(paren
id|f-&gt;inocache-&gt;state
op_eq
id|INO_STATE_READING
)paren
id|jffs2_set_inocache_state
c_func
(paren
id|c
comma
id|f-&gt;inocache
comma
id|INO_STATE_CHECKEDABSENT
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
id|f-&gt;dents
op_assign
id|fd_list
suffix:semicolon
r_while
c_loop
(paren
id|tn_list
)paren
(brace
id|tn
op_assign
id|tn_list
suffix:semicolon
id|fn
op_assign
id|tn-&gt;fn
suffix:semicolon
r_if
c_cond
(paren
id|f-&gt;metadata
)paren
(brace
r_if
c_cond
(paren
id|tn-&gt;version
OG
id|mdata_ver
)paren
(brace
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Obsoleting old metadata at 0x%08x&bslash;n&quot;
comma
id|ref_offset
c_func
(paren
id|f-&gt;metadata-&gt;raw
)paren
)paren
)paren
suffix:semicolon
id|jffs2_mark_node_obsolete
c_func
(paren
id|c
comma
id|f-&gt;metadata-&gt;raw
)paren
suffix:semicolon
id|jffs2_free_full_dnode
c_func
(paren
id|f-&gt;metadata
)paren
suffix:semicolon
id|f-&gt;metadata
op_assign
l_int|NULL
suffix:semicolon
id|mdata_ver
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Er. New metadata at 0x%08x with ver %d is actually older than previous %d&bslash;n&quot;
comma
id|ref_offset
c_func
(paren
id|f-&gt;metadata-&gt;raw
)paren
comma
id|tn-&gt;version
comma
id|mdata_ver
)paren
)paren
suffix:semicolon
id|jffs2_mark_node_obsolete
c_func
(paren
id|c
comma
id|fn-&gt;raw
)paren
suffix:semicolon
id|jffs2_free_full_dnode
c_func
(paren
id|fn
)paren
suffix:semicolon
r_goto
id|next_tn
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|fn-&gt;size
)paren
(brace
id|jffs2_add_full_dnode_to_inode
c_func
(paren
id|c
comma
id|f
comma
id|fn
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Zero-sized node at end of version list. Just a metadata update */
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;metadata @%08x: ver %d&bslash;n&quot;
comma
id|ref_offset
c_func
(paren
id|fn-&gt;raw
)paren
comma
id|tn-&gt;version
)paren
)paren
suffix:semicolon
id|f-&gt;metadata
op_assign
id|fn
suffix:semicolon
id|mdata_ver
op_assign
id|tn-&gt;version
suffix:semicolon
)brace
id|next_tn
suffix:colon
id|tn_list
op_assign
id|tn-&gt;next
suffix:semicolon
id|jffs2_free_tmp_dnode_info
c_func
(paren
id|tn
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|fn
)paren
(brace
multiline_comment|/* No data nodes for this inode. */
r_if
c_cond
(paren
id|f-&gt;inocache-&gt;ino
op_ne
l_int|1
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;jffs2_do_read_inode(): No data nodes found for ino #%u&bslash;n&quot;
comma
id|f-&gt;inocache-&gt;ino
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fd_list
)paren
(brace
r_if
c_cond
(paren
id|f-&gt;inocache-&gt;state
op_eq
id|INO_STATE_READING
)paren
id|jffs2_set_inocache_state
c_func
(paren
id|c
comma
id|f-&gt;inocache
comma
id|INO_STATE_CHECKEDABSENT
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;jffs2_do_read_inode(): But it has children so we fake some modes for it&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|latest_node-&gt;mode
op_assign
id|cpu_to_jemode
c_func
(paren
id|S_IFDIR
op_or
id|S_IRUGO
op_or
id|S_IWUSR
op_or
id|S_IXUGO
)paren
suffix:semicolon
id|latest_node-&gt;version
op_assign
id|cpu_to_je32
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|latest_node-&gt;atime
op_assign
id|latest_node-&gt;ctime
op_assign
id|latest_node-&gt;mtime
op_assign
id|cpu_to_je32
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|latest_node-&gt;isize
op_assign
id|cpu_to_je32
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|latest_node-&gt;gid
op_assign
id|cpu_to_je16
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|latest_node-&gt;uid
op_assign
id|cpu_to_je16
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|f-&gt;inocache-&gt;state
op_eq
id|INO_STATE_READING
)paren
id|jffs2_set_inocache_state
c_func
(paren
id|c
comma
id|f-&gt;inocache
comma
id|INO_STATE_PRESENT
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|ret
op_assign
id|jffs2_flash_read
c_func
(paren
id|c
comma
id|ref_offset
c_func
(paren
id|fn-&gt;raw
)paren
comma
r_sizeof
(paren
op_star
id|latest_node
)paren
comma
op_amp
id|retlen
comma
(paren
r_void
op_star
)paren
id|latest_node
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_logical_or
id|retlen
op_ne
r_sizeof
(paren
op_star
id|latest_node
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;MTD read in jffs2_do_read_inode() failed: Returned %d, %zd of %zd bytes read&bslash;n&quot;
comma
id|ret
comma
id|retlen
comma
r_sizeof
(paren
op_star
id|latest_node
)paren
)paren
suffix:semicolon
multiline_comment|/* FIXME: If this fails, there seems to be a memory leak. Find it. */
id|up
c_func
(paren
op_amp
id|f-&gt;sem
)paren
suffix:semicolon
id|jffs2_do_clear_inode
c_func
(paren
id|c
comma
id|f
)paren
suffix:semicolon
r_return
id|ret
ques
c_cond
id|ret
suffix:colon
op_minus
id|EIO
suffix:semicolon
)brace
id|crc
op_assign
id|crc32
c_func
(paren
l_int|0
comma
id|latest_node
comma
r_sizeof
(paren
op_star
id|latest_node
)paren
op_minus
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
id|crc
op_ne
id|je32_to_cpu
c_func
(paren
id|latest_node-&gt;node_crc
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;CRC failed for read_inode of inode %u at physical location 0x%x&bslash;n&quot;
comma
id|f-&gt;inocache-&gt;ino
comma
id|ref_offset
c_func
(paren
id|fn-&gt;raw
)paren
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|f-&gt;sem
)paren
suffix:semicolon
id|jffs2_do_clear_inode
c_func
(paren
id|c
comma
id|f
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|jemode_to_cpu
c_func
(paren
id|latest_node-&gt;mode
)paren
op_amp
id|S_IFMT
)paren
(brace
r_case
id|S_IFDIR
suffix:colon
r_if
c_cond
(paren
id|mctime_ver
OG
id|je32_to_cpu
c_func
(paren
id|latest_node-&gt;version
)paren
)paren
(brace
multiline_comment|/* The times in the latest_node are actually older than&n;&t;&t;&t;   mctime in the latest dirent. Cheat. */
id|latest_node-&gt;ctime
op_assign
id|latest_node-&gt;mtime
op_assign
id|cpu_to_je32
c_func
(paren
id|latest_mctime
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|S_IFREG
suffix:colon
multiline_comment|/* If it was a regular file, truncate it to the latest node&squot;s isize */
id|jffs2_truncate_fraglist
c_func
(paren
id|c
comma
op_amp
id|f-&gt;fragtree
comma
id|je32_to_cpu
c_func
(paren
id|latest_node-&gt;isize
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|S_IFLNK
suffix:colon
multiline_comment|/* Hack to work around broken isize in old symlink code.&n;&t;&t;   Remove this when dwmw2 comes to his senses and stops&n;&t;&t;   symlinks from being an entirely gratuitous special&n;&t;&t;   case. */
r_if
c_cond
(paren
op_logical_neg
id|je32_to_cpu
c_func
(paren
id|latest_node-&gt;isize
)paren
)paren
id|latest_node-&gt;isize
op_assign
id|latest_node-&gt;dsize
suffix:semicolon
multiline_comment|/* fall through... */
r_case
id|S_IFBLK
suffix:colon
r_case
id|S_IFCHR
suffix:colon
multiline_comment|/* Certain inode types should have only one data node, and it&squot;s&n;&t;&t;   kept as the metadata node */
r_if
c_cond
(paren
id|f-&gt;metadata
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Argh. Special inode #%u with mode 0%o had metadata node&bslash;n&quot;
comma
id|f-&gt;inocache-&gt;ino
comma
id|jemode_to_cpu
c_func
(paren
id|latest_node-&gt;mode
)paren
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|f-&gt;sem
)paren
suffix:semicolon
id|jffs2_do_clear_inode
c_func
(paren
id|c
comma
id|f
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|frag_first
c_func
(paren
op_amp
id|f-&gt;fragtree
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Argh. Special inode #%u with mode 0%o has no fragments&bslash;n&quot;
comma
id|f-&gt;inocache-&gt;ino
comma
id|jemode_to_cpu
c_func
(paren
id|latest_node-&gt;mode
)paren
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|f-&gt;sem
)paren
suffix:semicolon
id|jffs2_do_clear_inode
c_func
(paren
id|c
comma
id|f
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/* ASSERT: f-&gt;fraglist != NULL */
r_if
c_cond
(paren
id|frag_next
c_func
(paren
id|frag_first
c_func
(paren
op_amp
id|f-&gt;fragtree
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Argh. Special inode #%u with mode 0x%x had more than one node&bslash;n&quot;
comma
id|f-&gt;inocache-&gt;ino
comma
id|jemode_to_cpu
c_func
(paren
id|latest_node-&gt;mode
)paren
)paren
suffix:semicolon
multiline_comment|/* FIXME: Deal with it - check crc32, check for duplicate node, check times and discard the older one */
id|up
c_func
(paren
op_amp
id|f-&gt;sem
)paren
suffix:semicolon
id|jffs2_do_clear_inode
c_func
(paren
id|c
comma
id|f
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/* OK. We&squot;re happy */
id|f-&gt;metadata
op_assign
id|frag_first
c_func
(paren
op_amp
id|f-&gt;fragtree
)paren
op_member_access_from_pointer
id|node
suffix:semicolon
id|jffs2_free_node_frag
c_func
(paren
id|frag_first
c_func
(paren
op_amp
id|f-&gt;fragtree
)paren
)paren
suffix:semicolon
id|f-&gt;fragtree
op_assign
id|RB_ROOT
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|f-&gt;inocache-&gt;state
op_eq
id|INO_STATE_READING
)paren
id|jffs2_set_inocache_state
c_func
(paren
id|c
comma
id|f-&gt;inocache
comma
id|INO_STATE_PRESENT
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|jffs2_do_clear_inode
r_void
id|jffs2_do_clear_inode
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
comma
r_struct
id|jffs2_inode_info
op_star
id|f
)paren
(brace
r_struct
id|jffs2_full_dirent
op_star
id|fd
comma
op_star
id|fds
suffix:semicolon
multiline_comment|/* I don&squot;t think we care about the potential race due to reading this&n;&t;   without f-&gt;sem. It can never get undeleted. */
r_int
id|deleted
op_assign
id|f-&gt;inocache
op_logical_and
op_logical_neg
id|f-&gt;inocache-&gt;nlink
suffix:semicolon
multiline_comment|/* If it&squot;s a deleted inode, grab the alloc_sem. This prevents&n;&t;   jffs2_garbage_collect_pass() from deciding that it wants to&n;&t;   garbage collect one of the nodes we&squot;re just about to mark &n;&t;   obsolete -- by the time we drop alloc_sem and return, all&n;&t;   the nodes are marked obsolete, and jffs2_g_c_pass() won&squot;t&n;&t;   call iget() for the inode in question.&n;&n;&t;   We also used to do this to keep the temporary BUG() in &n;&t;   jffs2_mark_node_obsolete() from triggering. &n;&t;*/
r_if
c_cond
(paren
id|deleted
)paren
(brace
id|down
c_func
(paren
op_amp
id|c-&gt;alloc_sem
)paren
suffix:semicolon
)brace
id|down
c_func
(paren
op_amp
id|f-&gt;sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|f-&gt;metadata
)paren
(brace
r_if
c_cond
(paren
id|deleted
)paren
id|jffs2_mark_node_obsolete
c_func
(paren
id|c
comma
id|f-&gt;metadata-&gt;raw
)paren
suffix:semicolon
id|jffs2_free_full_dnode
c_func
(paren
id|f-&gt;metadata
)paren
suffix:semicolon
)brace
id|jffs2_kill_fragtree
c_func
(paren
op_amp
id|f-&gt;fragtree
comma
id|deleted
ques
c_cond
id|c
suffix:colon
l_int|NULL
)paren
suffix:semicolon
id|fds
op_assign
id|f-&gt;dents
suffix:semicolon
r_while
c_loop
(paren
id|fds
)paren
(brace
id|fd
op_assign
id|fds
suffix:semicolon
id|fds
op_assign
id|fd-&gt;next
suffix:semicolon
id|jffs2_free_full_dirent
c_func
(paren
id|fd
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|f-&gt;inocache
op_logical_and
id|f-&gt;inocache-&gt;state
op_ne
id|INO_STATE_CHECKING
)paren
id|jffs2_set_inocache_state
c_func
(paren
id|c
comma
id|f-&gt;inocache
comma
id|INO_STATE_CHECKEDABSENT
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|f-&gt;sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|deleted
)paren
(brace
id|up
c_func
(paren
op_amp
id|c-&gt;alloc_sem
)paren
suffix:semicolon
)brace
)brace
eof
