multiline_comment|/*&n; * JFFS2 -- Journalling Flash File System, Version 2.&n; *&n; * Copyright (C) 2001-2003 Red Hat, Inc.&n; *&n; * Created by David Woodhouse &lt;dwmw2@infradead.org&gt;&n; *&n; * For licensing information, see the file &squot;LICENCE&squot; in this directory.&n; *&n; * $Id: build.c,v 1.60 2004/11/17 17:13:13 dedekind Exp $&n; *&n; */
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &quot;nodelist.h&quot;
r_static
r_void
id|jffs2_build_remove_unlinked_inode
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
comma
r_struct
id|jffs2_inode_cache
op_star
comma
r_struct
id|jffs2_full_dirent
op_star
op_star
)paren
suffix:semicolon
r_static
r_inline
r_struct
id|jffs2_inode_cache
op_star
DECL|function|first_inode_chain
id|first_inode_chain
c_func
(paren
r_int
op_star
id|i
comma
r_struct
id|jffs2_sb_info
op_star
id|c
)paren
(brace
r_for
c_loop
(paren
suffix:semicolon
op_star
id|i
OL
id|INOCACHE_HASHSIZE
suffix:semicolon
(paren
op_star
id|i
)paren
op_increment
)paren
(brace
r_if
c_cond
(paren
id|c-&gt;inocache_list
(braket
op_star
id|i
)braket
)paren
r_return
id|c-&gt;inocache_list
(braket
op_star
id|i
)braket
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
r_static
r_inline
r_struct
id|jffs2_inode_cache
op_star
DECL|function|next_inode
id|next_inode
c_func
(paren
r_int
op_star
id|i
comma
r_struct
id|jffs2_inode_cache
op_star
id|ic
comma
r_struct
id|jffs2_sb_info
op_star
id|c
)paren
(brace
multiline_comment|/* More in this chain? */
r_if
c_cond
(paren
id|ic-&gt;next
)paren
r_return
id|ic-&gt;next
suffix:semicolon
(paren
op_star
id|i
)paren
op_increment
suffix:semicolon
r_return
id|first_inode_chain
c_func
(paren
id|i
comma
id|c
)paren
suffix:semicolon
)brace
DECL|macro|for_each_inode
mdefine_line|#define for_each_inode(i, c, ic)&t;&t;&t;&bslash;&n;&t;for (i = 0, ic = first_inode_chain(&amp;i, (c));&t;&bslash;&n;&t;     ic;&t;&t;&t;&t;&t;&bslash;&n;&t;     ic = next_inode(&amp;i, ic, (c)))
DECL|function|jffs2_build_inode_pass1
r_static
r_inline
r_void
id|jffs2_build_inode_pass1
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
comma
r_struct
id|jffs2_inode_cache
op_star
id|ic
)paren
(brace
r_struct
id|jffs2_full_dirent
op_star
id|fd
suffix:semicolon
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;jffs2_build_inode building directory inode #%u&bslash;n&quot;
comma
id|ic-&gt;ino
)paren
)paren
suffix:semicolon
multiline_comment|/* For each child, increase nlink */
r_for
c_loop
(paren
id|fd
op_assign
id|ic-&gt;scan_dents
suffix:semicolon
id|fd
suffix:semicolon
id|fd
op_assign
id|fd-&gt;next
)paren
(brace
r_struct
id|jffs2_inode_cache
op_star
id|child_ic
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fd-&gt;ino
)paren
r_continue
suffix:semicolon
multiline_comment|/* XXX: Can get high latency here with huge directories */
id|child_ic
op_assign
id|jffs2_get_ino_cache
c_func
(paren
id|c
comma
id|fd-&gt;ino
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|child_ic
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;Eep. Child &bslash;&quot;%s&bslash;&quot; (ino #%u) of dir ino #%u doesn&squot;t exist!&bslash;n&quot;
comma
id|fd-&gt;name
comma
id|fd-&gt;ino
comma
id|ic-&gt;ino
)paren
suffix:semicolon
id|jffs2_mark_node_obsolete
c_func
(paren
id|c
comma
id|fd-&gt;raw
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|child_ic-&gt;nlink
op_increment
op_logical_and
id|fd-&gt;type
op_eq
id|DT_DIR
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;Child dir &bslash;&quot;%s&bslash;&quot; (ino #%u) of dir ino #%u appears to be a hard link&bslash;n&quot;
comma
id|fd-&gt;name
comma
id|fd-&gt;ino
comma
id|ic-&gt;ino
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fd-&gt;ino
op_eq
l_int|1
op_logical_and
id|ic-&gt;ino
op_eq
l_int|1
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;This is mostly harmless, and probably caused by creating a JFFS2 image&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;using a buggy version of mkfs.jffs2. Use at least v1.17.&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* What do we do about it? */
)brace
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Increased nlink for child &bslash;&quot;%s&bslash;&quot; (ino #%u)&bslash;n&quot;
comma
id|fd-&gt;name
comma
id|fd-&gt;ino
)paren
)paren
suffix:semicolon
multiline_comment|/* Can&squot;t free them. We might need them in pass 2 */
)brace
)brace
multiline_comment|/* Scan plan:&n; - Scan physical nodes. Build map of inodes/dirents. Allocate inocaches as we go&n; - Scan directory tree from top down, setting nlink in inocaches&n; - Scan inocaches for inodes with nlink==0&n;*/
DECL|function|jffs2_build_filesystem
r_static
r_int
id|jffs2_build_filesystem
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
)paren
(brace
r_int
id|ret
suffix:semicolon
r_int
id|i
suffix:semicolon
r_struct
id|jffs2_inode_cache
op_star
id|ic
suffix:semicolon
r_struct
id|jffs2_full_dirent
op_star
id|dead_fds
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* First, scan the medium and build all the inode caches with&n;&t;   lists of physical nodes */
id|c-&gt;flags
op_or_assign
id|JFFS2_SB_FLAG_MOUNTING
suffix:semicolon
id|ret
op_assign
id|jffs2_scan_medium
c_func
(paren
id|c
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_return
id|ret
suffix:semicolon
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Scanned flash completely&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|D2
c_func
(paren
id|jffs2_dump_block_lists
c_func
(paren
id|c
)paren
)paren
suffix:semicolon
multiline_comment|/* Now scan the directory tree, increasing nlink according to every dirent found. */
id|for_each_inode
c_func
(paren
id|i
comma
id|c
comma
id|ic
)paren
(brace
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Pass 1: ino #%u&bslash;n&quot;
comma
id|ic-&gt;ino
)paren
)paren
suffix:semicolon
id|D1
c_func
(paren
id|BUG_ON
c_func
(paren
id|ic-&gt;ino
OG
id|c-&gt;highest_ino
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ic-&gt;scan_dents
)paren
(brace
id|jffs2_build_inode_pass1
c_func
(paren
id|c
comma
id|ic
)paren
suffix:semicolon
id|cond_resched
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
id|c-&gt;flags
op_and_assign
op_complement
id|JFFS2_SB_FLAG_MOUNTING
suffix:semicolon
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Pass 1 complete&bslash;n&quot;
)paren
)paren
suffix:semicolon
multiline_comment|/* Next, scan for inodes with nlink == 0 and remove them. If&n;&t;   they were directories, then decrement the nlink of their&n;&t;   children too, and repeat the scan. As that&squot;s going to be&n;&t;   a fairly uncommon occurrence, it&squot;s not so evil to do it this&n;&t;   way. Recursion bad. */
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Pass 2 starting&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|for_each_inode
c_func
(paren
id|i
comma
id|c
comma
id|ic
)paren
(brace
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Pass 2: ino #%u, nlink %d, ic %p, nodes %p&bslash;n&quot;
comma
id|ic-&gt;ino
comma
id|ic-&gt;nlink
comma
id|ic
comma
id|ic-&gt;nodes
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ic-&gt;nlink
)paren
r_continue
suffix:semicolon
id|jffs2_build_remove_unlinked_inode
c_func
(paren
id|c
comma
id|ic
comma
op_amp
id|dead_fds
)paren
suffix:semicolon
id|cond_resched
c_func
(paren
)paren
suffix:semicolon
)brace
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Pass 2a starting&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|dead_fds
)paren
(brace
r_struct
id|jffs2_inode_cache
op_star
id|ic
suffix:semicolon
r_struct
id|jffs2_full_dirent
op_star
id|fd
op_assign
id|dead_fds
suffix:semicolon
id|dead_fds
op_assign
id|fd-&gt;next
suffix:semicolon
id|ic
op_assign
id|jffs2_get_ino_cache
c_func
(paren
id|c
comma
id|fd-&gt;ino
)paren
suffix:semicolon
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Removing dead_fd ino #%u (&bslash;&quot;%s&bslash;&quot;), ic at %p&bslash;n&quot;
comma
id|fd-&gt;ino
comma
id|fd-&gt;name
comma
id|ic
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ic
)paren
id|jffs2_build_remove_unlinked_inode
c_func
(paren
id|c
comma
id|ic
comma
op_amp
id|dead_fds
)paren
suffix:semicolon
id|jffs2_free_full_dirent
c_func
(paren
id|fd
)paren
suffix:semicolon
)brace
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Pass 2 complete&bslash;n&quot;
)paren
)paren
suffix:semicolon
multiline_comment|/* Finally, we can scan again and free the dirent structs */
id|for_each_inode
c_func
(paren
id|i
comma
id|c
comma
id|ic
)paren
(brace
r_struct
id|jffs2_full_dirent
op_star
id|fd
suffix:semicolon
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Pass 3: ino #%u, ic %p, nodes %p&bslash;n&quot;
comma
id|ic-&gt;ino
comma
id|ic
comma
id|ic-&gt;nodes
)paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|ic-&gt;scan_dents
)paren
(brace
id|fd
op_assign
id|ic-&gt;scan_dents
suffix:semicolon
id|ic-&gt;scan_dents
op_assign
id|fd-&gt;next
suffix:semicolon
id|jffs2_free_full_dirent
c_func
(paren
id|fd
)paren
suffix:semicolon
)brace
id|ic-&gt;scan_dents
op_assign
l_int|NULL
suffix:semicolon
id|cond_resched
c_func
(paren
)paren
suffix:semicolon
)brace
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Pass 3 complete&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|D2
c_func
(paren
id|jffs2_dump_block_lists
c_func
(paren
id|c
)paren
)paren
suffix:semicolon
multiline_comment|/* Rotate the lists by some number to ensure wear levelling */
id|jffs2_rotate_lists
c_func
(paren
id|c
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|jffs2_build_remove_unlinked_inode
r_static
r_void
id|jffs2_build_remove_unlinked_inode
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
comma
r_struct
id|jffs2_inode_cache
op_star
id|ic
comma
r_struct
id|jffs2_full_dirent
op_star
op_star
id|dead_fds
)paren
(brace
r_struct
id|jffs2_raw_node_ref
op_star
id|raw
suffix:semicolon
r_struct
id|jffs2_full_dirent
op_star
id|fd
suffix:semicolon
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;JFFS2: Removing ino #%u with nlink == zero.&bslash;n&quot;
comma
id|ic-&gt;ino
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|raw
op_assign
id|ic-&gt;nodes
suffix:semicolon
id|raw
op_ne
(paren
r_void
op_star
)paren
id|ic
suffix:semicolon
id|raw
op_assign
id|raw-&gt;next_in_ino
)paren
(brace
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;obsoleting node at 0x%08x&bslash;n&quot;
comma
id|ref_offset
c_func
(paren
id|raw
)paren
)paren
)paren
suffix:semicolon
id|jffs2_mark_node_obsolete
c_func
(paren
id|c
comma
id|raw
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ic-&gt;scan_dents
)paren
(brace
r_int
id|whinged
op_assign
l_int|0
suffix:semicolon
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Inode #%u was a directory which may have children...&bslash;n&quot;
comma
id|ic-&gt;ino
)paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|ic-&gt;scan_dents
)paren
(brace
r_struct
id|jffs2_inode_cache
op_star
id|child_ic
suffix:semicolon
id|fd
op_assign
id|ic-&gt;scan_dents
suffix:semicolon
id|ic-&gt;scan_dents
op_assign
id|fd-&gt;next
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fd-&gt;ino
)paren
(brace
multiline_comment|/* It&squot;s a deletion dirent. Ignore it */
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Child &bslash;&quot;%s&bslash;&quot; is a deletion dirent, skipping...&bslash;n&quot;
comma
id|fd-&gt;name
)paren
)paren
suffix:semicolon
id|jffs2_free_full_dirent
c_func
(paren
id|fd
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|whinged
)paren
(brace
id|whinged
op_assign
l_int|1
suffix:semicolon
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;Inode #%u was a directory with children - removing those too...&bslash;n&quot;
comma
id|ic-&gt;ino
)paren
suffix:semicolon
)brace
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Removing child &bslash;&quot;%s&bslash;&quot;, ino #%u&bslash;n&quot;
comma
id|fd-&gt;name
comma
id|fd-&gt;ino
)paren
)paren
suffix:semicolon
id|child_ic
op_assign
id|jffs2_get_ino_cache
c_func
(paren
id|c
comma
id|fd-&gt;ino
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|child_ic
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;Cannot remove child &bslash;&quot;%s&bslash;&quot;, ino #%u, because it doesn&squot;t exist&bslash;n&quot;
comma
id|fd-&gt;name
comma
id|fd-&gt;ino
)paren
suffix:semicolon
id|jffs2_free_full_dirent
c_func
(paren
id|fd
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* Reduce nlink of the child. If it&squot;s now zero, stick it on the &n;&t;&t;&t;   dead_fds list to be cleaned up later. Else just free the fd */
id|child_ic-&gt;nlink
op_decrement
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|child_ic-&gt;nlink
)paren
(brace
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Inode #%u (&bslash;&quot;%s&bslash;&quot;) has now got zero nlink. Adding to dead_fds list.&bslash;n&quot;
comma
id|fd-&gt;ino
comma
id|fd-&gt;name
)paren
)paren
suffix:semicolon
id|fd-&gt;next
op_assign
op_star
id|dead_fds
suffix:semicolon
op_star
id|dead_fds
op_assign
id|fd
suffix:semicolon
)brace
r_else
(brace
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Inode #%u (&bslash;&quot;%s&bslash;&quot;) has now got nlink %d. Ignoring.&bslash;n&quot;
comma
id|fd-&gt;ino
comma
id|fd-&gt;name
comma
id|child_ic-&gt;nlink
)paren
)paren
suffix:semicolon
id|jffs2_free_full_dirent
c_func
(paren
id|fd
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;&t;   We don&squot;t delete the inocache from the hash list and free it yet. &n;&t;   The erase code will do that, when all the nodes are completely gone.&n;&t;*/
)brace
DECL|function|jffs2_calc_trigger_levels
r_static
r_void
id|jffs2_calc_trigger_levels
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
)paren
(brace
r_uint32
id|size
suffix:semicolon
multiline_comment|/* Deletion should almost _always_ be allowed. We&squot;re fairly&n;&t;   buggered once we stop allowing people to delete stuff&n;&t;   because there&squot;s not enough free space... */
id|c-&gt;resv_blocks_deletion
op_assign
l_int|2
suffix:semicolon
multiline_comment|/* Be conservative about how much space we need before we allow writes. &n;&t;   On top of that which is required for deletia, require an extra 2%&n;&t;   of the medium to be available, for overhead caused by nodes being&n;&t;   split across blocks, etc. */
id|size
op_assign
id|c-&gt;flash_size
op_div
l_int|50
suffix:semicolon
multiline_comment|/* 2% of flash size */
id|size
op_add_assign
id|c-&gt;nr_blocks
op_star
l_int|100
suffix:semicolon
multiline_comment|/* And 100 bytes per eraseblock */
id|size
op_add_assign
id|c-&gt;sector_size
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* ... and round up */
id|c-&gt;resv_blocks_write
op_assign
id|c-&gt;resv_blocks_deletion
op_plus
(paren
id|size
op_div
id|c-&gt;sector_size
)paren
suffix:semicolon
multiline_comment|/* When do we let the GC thread run in the background */
id|c-&gt;resv_blocks_gctrigger
op_assign
id|c-&gt;resv_blocks_write
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* When do we allow garbage collection to merge nodes to make &n;&t;   long-term progress at the expense of short-term space exhaustion? */
id|c-&gt;resv_blocks_gcmerge
op_assign
id|c-&gt;resv_blocks_deletion
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* When do we allow garbage collection to eat from bad blocks rather&n;&t;   than actually making progress? */
id|c-&gt;resv_blocks_gcbad
op_assign
l_int|0
suffix:semicolon
singleline_comment|//c-&gt;resv_blocks_deletion + 2;
multiline_comment|/* If there&squot;s less than this amount of dirty space, don&squot;t bother&n;&t;   trying to GC to make more space. It&squot;ll be a fruitless task */
id|c-&gt;nospc_dirty_size
op_assign
id|c-&gt;sector_size
op_plus
(paren
id|c-&gt;flash_size
op_div
l_int|100
)paren
suffix:semicolon
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;JFFS2 trigger levels (size %d KiB, block size %d KiB, %d blocks)&bslash;n&quot;
comma
id|c-&gt;flash_size
op_div
l_int|1024
comma
id|c-&gt;sector_size
op_div
l_int|1024
comma
id|c-&gt;nr_blocks
)paren
)paren
suffix:semicolon
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Blocks required to allow deletion:    %d (%d KiB)&bslash;n&quot;
comma
id|c-&gt;resv_blocks_deletion
comma
id|c-&gt;resv_blocks_deletion
op_star
id|c-&gt;sector_size
op_div
l_int|1024
)paren
)paren
suffix:semicolon
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Blocks required to allow writes:      %d (%d KiB)&bslash;n&quot;
comma
id|c-&gt;resv_blocks_write
comma
id|c-&gt;resv_blocks_write
op_star
id|c-&gt;sector_size
op_div
l_int|1024
)paren
)paren
suffix:semicolon
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Blocks required to quiesce GC thread: %d (%d KiB)&bslash;n&quot;
comma
id|c-&gt;resv_blocks_gctrigger
comma
id|c-&gt;resv_blocks_gctrigger
op_star
id|c-&gt;sector_size
op_div
l_int|1024
)paren
)paren
suffix:semicolon
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Blocks required to allow GC merges:   %d (%d KiB)&bslash;n&quot;
comma
id|c-&gt;resv_blocks_gcmerge
comma
id|c-&gt;resv_blocks_gcmerge
op_star
id|c-&gt;sector_size
op_div
l_int|1024
)paren
)paren
suffix:semicolon
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Blocks required to GC bad blocks:     %d (%d KiB)&bslash;n&quot;
comma
id|c-&gt;resv_blocks_gcbad
comma
id|c-&gt;resv_blocks_gcbad
op_star
id|c-&gt;sector_size
op_div
l_int|1024
)paren
)paren
suffix:semicolon
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Amount of dirty space required to GC: %d bytes&bslash;n&quot;
comma
id|c-&gt;nospc_dirty_size
)paren
)paren
suffix:semicolon
)brace
DECL|function|jffs2_do_mount_fs
r_int
id|jffs2_do_mount_fs
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
)paren
(brace
r_int
id|i
suffix:semicolon
id|c-&gt;free_size
op_assign
id|c-&gt;flash_size
suffix:semicolon
id|c-&gt;nr_blocks
op_assign
id|c-&gt;flash_size
op_div
id|c-&gt;sector_size
suffix:semicolon
id|c-&gt;blocks
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|jffs2_eraseblock
)paren
op_star
id|c-&gt;nr_blocks
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|c-&gt;blocks
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|c-&gt;nr_blocks
suffix:semicolon
id|i
op_increment
)paren
(brace
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|c-&gt;blocks
(braket
id|i
)braket
dot
id|list
)paren
suffix:semicolon
id|c-&gt;blocks
(braket
id|i
)braket
dot
id|offset
op_assign
id|i
op_star
id|c-&gt;sector_size
suffix:semicolon
id|c-&gt;blocks
(braket
id|i
)braket
dot
id|free_size
op_assign
id|c-&gt;sector_size
suffix:semicolon
id|c-&gt;blocks
(braket
id|i
)braket
dot
id|dirty_size
op_assign
l_int|0
suffix:semicolon
id|c-&gt;blocks
(braket
id|i
)braket
dot
id|wasted_size
op_assign
l_int|0
suffix:semicolon
id|c-&gt;blocks
(braket
id|i
)braket
dot
id|unchecked_size
op_assign
l_int|0
suffix:semicolon
id|c-&gt;blocks
(braket
id|i
)braket
dot
id|used_size
op_assign
l_int|0
suffix:semicolon
id|c-&gt;blocks
(braket
id|i
)braket
dot
id|first_node
op_assign
l_int|NULL
suffix:semicolon
id|c-&gt;blocks
(braket
id|i
)braket
dot
id|last_node
op_assign
l_int|NULL
suffix:semicolon
)brace
id|init_MUTEX
c_func
(paren
op_amp
id|c-&gt;alloc_sem
)paren
suffix:semicolon
id|init_MUTEX
c_func
(paren
op_amp
id|c-&gt;erase_free_sem
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|c-&gt;erase_wait
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|c-&gt;inocache_wq
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|c-&gt;erase_completion_lock
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|c-&gt;inocache_lock
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|c-&gt;clean_list
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|c-&gt;very_dirty_list
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|c-&gt;dirty_list
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|c-&gt;erasable_list
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|c-&gt;erasing_list
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|c-&gt;erase_pending_list
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|c-&gt;erasable_pending_wbuf_list
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|c-&gt;erase_complete_list
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|c-&gt;free_list
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|c-&gt;bad_list
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|c-&gt;bad_used_list
)paren
suffix:semicolon
id|c-&gt;highest_ino
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|jffs2_build_filesystem
c_func
(paren
id|c
)paren
)paren
(brace
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;build_fs failed&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|jffs2_free_ino_caches
c_func
(paren
id|c
)paren
suffix:semicolon
id|jffs2_free_raw_node_refs
c_func
(paren
id|c
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|c-&gt;blocks
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|jffs2_calc_trigger_levels
c_func
(paren
id|c
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
eof
