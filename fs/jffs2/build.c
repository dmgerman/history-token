multiline_comment|/*&n; * JFFS2 -- Journalling Flash File System, Version 2.&n; *&n; * Copyright (C) 2001, 2002 Red Hat, Inc.&n; *&n; * Created by David Woodhouse &lt;dwmw2@cambridge.redhat.com&gt;&n; *&n; * The original JFFS, from which the design for JFFS2 was derived,&n; * was designed and implemented by Axis Communications AB.&n; *&n; * The contents of this file are subject to the Red Hat eCos Public&n; * License Version 1.1 (the &quot;Licence&quot;); you may not use this file&n; * except in compliance with the Licence.  You may obtain a copy of&n; * the Licence at http://www.redhat.com/&n; *&n; * Software distributed under the Licence is distributed on an &quot;AS IS&quot;&n; * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.&n; * See the Licence for the specific language governing rights and&n; * limitations under the Licence.&n; *&n; * The Original Code is JFFS2 - Journalling Flash File System, version 2&n; *&n; * Alternatively, the contents of this file may be used under the&n; * terms of the GNU General Public License version 2 (the &quot;GPL&quot;), in&n; * which case the provisions of the GPL are applicable instead of the&n; * above.  If you wish to allow the use of your version of this file&n; * only under the terms of the GPL and not to allow others to use your&n; * version of this file under the RHEPL, indicate your decision by&n; * deleting the provisions above and replace them with the notice and&n; * other provisions required by the GPL.  If you do not delete the&n; * provisions above, a recipient may use your version of this file&n; * under either the RHEPL or the GPL.&n; *&n; * $Id: build.c,v 1.32 2002/03/08 15:11:24 dwmw2 Exp $&n; *&n; */
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &quot;nodelist.h&quot;
r_int
id|jffs2_build_inode_pass1
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
comma
r_struct
id|jffs2_inode_cache
op_star
)paren
suffix:semicolon
r_int
id|jffs2_build_remove_unlinked_inode
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
comma
r_struct
id|jffs2_inode_cache
op_star
)paren
suffix:semicolon
DECL|macro|for_each_inode
mdefine_line|#define for_each_inode(i, c, ic) for (i=0; i&lt;INOCACHE_HASHSIZE; i++) for (ic=c-&gt;inocache_list[i]; ic; ic=ic-&gt;next) 
multiline_comment|/* Scan plan:&n; - Scan physical nodes. Build map of inodes/dirents. Allocate inocaches as we go&n; - Scan directory tree from top down, setting nlink in inocaches&n; - Scan inocaches for inodes with nlink==0&n;*/
DECL|function|jffs2_build_filesystem
r_static
r_int
id|jffs2_build_filesystem
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
)paren
(brace
r_int
id|ret
suffix:semicolon
r_int
id|i
suffix:semicolon
r_struct
id|jffs2_inode_cache
op_star
id|ic
suffix:semicolon
multiline_comment|/* First, scan the medium and build all the inode caches with&n;&t;   lists of physical nodes */
id|c-&gt;flags
op_or_assign
id|JFFS2_SB_FLAG_MOUNTING
suffix:semicolon
id|ret
op_assign
id|jffs2_scan_medium
c_func
(paren
id|c
)paren
suffix:semicolon
id|c-&gt;flags
op_and_assign
op_complement
id|JFFS2_SB_FLAG_MOUNTING
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_return
id|ret
suffix:semicolon
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Scanned flash completely&bslash;n&quot;
)paren
)paren
suffix:semicolon
multiline_comment|/* Now build the data map for each inode, marking obsoleted nodes&n;&t;   as such, and also increase nlink of any children. */
id|for_each_inode
c_func
(paren
id|i
comma
id|c
comma
id|ic
)paren
(brace
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Pass 1: ino #%u&bslash;n&quot;
comma
id|ic-&gt;ino
)paren
)paren
suffix:semicolon
id|ret
op_assign
id|jffs2_build_inode_pass1
c_func
(paren
id|c
comma
id|ic
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Eep. jffs2_build_inode_pass1 for ino %d returned %d&bslash;n&quot;
comma
id|ic-&gt;ino
comma
id|ret
)paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
)brace
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Pass 1 complete&bslash;n&quot;
)paren
)paren
suffix:semicolon
multiline_comment|/* Next, scan for inodes with nlink == 0 and remove them. If&n;&t;   they were directories, then decrement the nlink of their&n;&t;   children too, and repeat the scan. As that&squot;s going to be&n;&t;   a fairly uncommon occurrence, it&squot;s not so evil to do it this&n;&t;   way. Recursion bad. */
r_do
(brace
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Pass 2 (re)starting&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
id|for_each_inode
c_func
(paren
id|i
comma
id|c
comma
id|ic
)paren
(brace
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Pass 2: ino #%u, nlink %d, ic %p, nodes %p&bslash;n&quot;
comma
id|ic-&gt;ino
comma
id|ic-&gt;nlink
comma
id|ic
comma
id|ic-&gt;nodes
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ic-&gt;nlink
)paren
r_continue
suffix:semicolon
id|ret
op_assign
id|jffs2_build_remove_unlinked_inode
c_func
(paren
id|c
comma
id|ic
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_break
suffix:semicolon
multiline_comment|/* -EAGAIN means the inode&squot;s nlink was zero, so we deleted it,&n;&t;&t;   and furthermore that it had children and their nlink has now&n;&t;&t;   gone to zero too. So we have to restart the scan. */
)brace
)brace
r_while
c_loop
(paren
id|ret
op_eq
op_minus
id|EAGAIN
)paren
(brace
suffix:semicolon
)brace
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Pass 2 complete&bslash;n&quot;
)paren
)paren
suffix:semicolon
multiline_comment|/* Finally, we can scan again and free the dirent nodes and scan_info structs */
id|for_each_inode
c_func
(paren
id|i
comma
id|c
comma
id|ic
)paren
(brace
r_struct
id|jffs2_scan_info
op_star
id|scan
op_assign
id|ic-&gt;scan
suffix:semicolon
r_struct
id|jffs2_full_dirent
op_star
id|fd
suffix:semicolon
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Pass 3: ino #%u, ic %p, nodes %p&bslash;n&quot;
comma
id|ic-&gt;ino
comma
id|ic
comma
id|ic-&gt;nodes
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|scan
)paren
(brace
r_if
c_cond
(paren
id|ic-&gt;nlink
)paren
(brace
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Why no scan struct for ino #%u which has nlink %d?&bslash;n&quot;
comma
id|ic-&gt;ino
comma
id|ic-&gt;nlink
)paren
)paren
suffix:semicolon
)brace
r_continue
suffix:semicolon
)brace
id|ic-&gt;scan
op_assign
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
id|scan-&gt;dents
)paren
(brace
id|fd
op_assign
id|scan-&gt;dents
suffix:semicolon
id|scan-&gt;dents
op_assign
id|fd-&gt;next
suffix:semicolon
id|jffs2_free_full_dirent
c_func
(paren
id|fd
)paren
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|scan
)paren
suffix:semicolon
)brace
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Pass 3 complete&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|jffs2_build_inode_pass1
r_int
id|jffs2_build_inode_pass1
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
comma
r_struct
id|jffs2_inode_cache
op_star
id|ic
)paren
(brace
r_struct
id|jffs2_tmp_dnode_info
op_star
id|tn
suffix:semicolon
r_struct
id|jffs2_full_dirent
op_star
id|fd
suffix:semicolon
r_struct
id|jffs2_node_frag
op_star
id|fraglist
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|jffs2_tmp_dnode_info
op_star
id|metadata
op_assign
l_int|NULL
suffix:semicolon
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;jffs2_build_inode building inode #%u&bslash;n&quot;
comma
id|ic-&gt;ino
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ic-&gt;ino
OG
id|c-&gt;highest_ino
)paren
id|c-&gt;highest_ino
op_assign
id|ic-&gt;ino
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ic-&gt;scan-&gt;tmpnodes
op_logical_and
id|ic-&gt;ino
op_ne
l_int|1
)paren
(brace
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;jffs2_build_inode: ino #%u has no data nodes!&bslash;n&quot;
comma
id|ic-&gt;ino
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Build the list to make sure any obsolete nodes are marked as such */
r_while
c_loop
(paren
id|ic-&gt;scan-&gt;tmpnodes
)paren
(brace
id|tn
op_assign
id|ic-&gt;scan-&gt;tmpnodes
suffix:semicolon
id|ic-&gt;scan-&gt;tmpnodes
op_assign
id|tn-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|metadata
op_logical_and
id|tn-&gt;version
OG
id|metadata-&gt;version
)paren
(brace
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;jffs2_build_inode_pass1 ignoring old metadata at 0x%08x&bslash;n&quot;
comma
id|metadata-&gt;fn-&gt;raw-&gt;flash_offset
op_amp
op_complement
l_int|3
)paren
)paren
suffix:semicolon
id|jffs2_mark_node_obsolete
c_func
(paren
id|c
comma
id|metadata-&gt;fn-&gt;raw
)paren
suffix:semicolon
id|jffs2_free_full_dnode
c_func
(paren
id|metadata-&gt;fn
)paren
suffix:semicolon
id|jffs2_free_tmp_dnode_info
c_func
(paren
id|metadata
)paren
suffix:semicolon
id|metadata
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tn-&gt;fn-&gt;size
)paren
(brace
id|jffs2_add_full_dnode_to_fraglist
(paren
id|c
comma
op_amp
id|fraglist
comma
id|tn-&gt;fn
)paren
suffix:semicolon
id|jffs2_free_tmp_dnode_info
c_func
(paren
id|tn
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
id|metadata
)paren
(brace
id|metadata
op_assign
id|tn
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* This will only happen if it has the _same_ version&n;&t;&t;&t;&t;   number as the existing metadata node. */
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;jffs2_build_inode_pass1 ignoring new metadata at 0x%08x&bslash;n&quot;
comma
id|tn-&gt;fn-&gt;raw-&gt;flash_offset
op_amp
op_complement
l_int|3
)paren
)paren
suffix:semicolon
id|jffs2_mark_node_obsolete
c_func
(paren
id|c
comma
id|tn-&gt;fn-&gt;raw
)paren
suffix:semicolon
id|jffs2_free_full_dnode
c_func
(paren
id|tn-&gt;fn
)paren
suffix:semicolon
id|jffs2_free_tmp_dnode_info
c_func
(paren
id|tn
)paren
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|ic-&gt;scan-&gt;version
)paren
(brace
multiline_comment|/* It&squot;s a regular file, so truncate it to the last known&n;&t;&t;   i_size, if necessary */
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;jffs2_build_inode_pass1 truncating fraglist to 0x%08x&bslash;n&quot;
comma
id|ic-&gt;scan-&gt;isize
)paren
)paren
suffix:semicolon
id|jffs2_truncate_fraglist
c_func
(paren
id|c
comma
op_amp
id|fraglist
comma
id|ic-&gt;scan-&gt;isize
)paren
suffix:semicolon
)brace
multiline_comment|/* OK. Now clear up */
r_if
c_cond
(paren
id|metadata
)paren
(brace
id|jffs2_free_full_dnode
c_func
(paren
id|metadata-&gt;fn
)paren
suffix:semicolon
id|jffs2_free_tmp_dnode_info
c_func
(paren
id|metadata
)paren
suffix:semicolon
)brace
id|metadata
op_assign
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
id|fraglist
)paren
(brace
r_struct
id|jffs2_node_frag
op_star
id|frag
suffix:semicolon
id|frag
op_assign
id|fraglist
suffix:semicolon
id|fraglist
op_assign
id|fraglist-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|frag-&gt;node
op_logical_and
op_logical_neg
(paren
op_decrement
id|frag-&gt;node-&gt;frags
)paren
)paren
(brace
id|jffs2_free_full_dnode
c_func
(paren
id|frag-&gt;node
)paren
suffix:semicolon
)brace
id|jffs2_free_node_frag
c_func
(paren
id|frag
)paren
suffix:semicolon
)brace
multiline_comment|/* Now for each child, increase nlink */
r_for
c_loop
(paren
id|fd
op_assign
id|ic-&gt;scan-&gt;dents
suffix:semicolon
id|fd
suffix:semicolon
id|fd
op_assign
id|fd-&gt;next
)paren
(brace
r_struct
id|jffs2_inode_cache
op_star
id|child_ic
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fd-&gt;ino
)paren
r_continue
suffix:semicolon
id|child_ic
op_assign
id|jffs2_get_ino_cache
c_func
(paren
id|c
comma
id|fd-&gt;ino
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|child_ic
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;Eep. Child &bslash;&quot;%s&bslash;&quot; (ino #%u) of dir ino #%u doesn&squot;t exist!&bslash;n&quot;
comma
id|fd-&gt;name
comma
id|fd-&gt;ino
comma
id|ic-&gt;ino
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|child_ic-&gt;nlink
op_increment
op_logical_and
id|fd-&gt;type
op_eq
id|DT_DIR
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;Child dir &bslash;&quot;%s&bslash;&quot; (ino #%u) of dir ino #%u appears to be a hard link&bslash;n&quot;
comma
id|fd-&gt;name
comma
id|fd-&gt;ino
comma
id|ic-&gt;ino
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fd-&gt;ino
op_eq
l_int|1
op_logical_and
id|ic-&gt;ino
op_eq
l_int|1
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;This is mostly harmless, and probably caused by creating a JFFS2 image&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;using a buggy version of mkfs.jffs2. Use at least v1.17.&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* What do we do about it? */
)brace
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Increased nlink for child &bslash;&quot;%s&bslash;&quot; (ino #%u)&bslash;n&quot;
comma
id|fd-&gt;name
comma
id|fd-&gt;ino
)paren
)paren
suffix:semicolon
multiline_comment|/* Can&squot;t free them. We might need them in pass 2 */
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|jffs2_build_remove_unlinked_inode
r_int
id|jffs2_build_remove_unlinked_inode
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
comma
r_struct
id|jffs2_inode_cache
op_star
id|ic
)paren
(brace
r_struct
id|jffs2_raw_node_ref
op_star
id|raw
suffix:semicolon
r_struct
id|jffs2_full_dirent
op_star
id|fd
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ic-&gt;scan
)paren
(brace
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;ino #%u was already removed&bslash;n&quot;
comma
id|ic-&gt;ino
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;JFFS2: Removing ino #%u with nlink == zero.&bslash;n&quot;
comma
id|ic-&gt;ino
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|raw
op_assign
id|ic-&gt;nodes
suffix:semicolon
id|raw
op_ne
(paren
r_void
op_star
)paren
id|ic
suffix:semicolon
id|raw
op_assign
id|raw-&gt;next_in_ino
)paren
(brace
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;obsoleting node at 0x%08x&bslash;n&quot;
comma
id|raw-&gt;flash_offset
op_amp
op_complement
l_int|3
)paren
)paren
suffix:semicolon
id|jffs2_mark_node_obsolete
c_func
(paren
id|c
comma
id|raw
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ic-&gt;scan-&gt;dents
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;Inode #%u was a directory with children - removing those too...&bslash;n&quot;
comma
id|ic-&gt;ino
)paren
suffix:semicolon
r_while
c_loop
(paren
id|ic-&gt;scan-&gt;dents
)paren
(brace
r_struct
id|jffs2_inode_cache
op_star
id|child_ic
suffix:semicolon
id|fd
op_assign
id|ic-&gt;scan-&gt;dents
suffix:semicolon
id|ic-&gt;scan-&gt;dents
op_assign
id|fd-&gt;next
suffix:semicolon
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Removing child &bslash;&quot;%s&bslash;&quot;, ino #%u&bslash;n&quot;
comma
id|fd-&gt;name
comma
id|fd-&gt;ino
)paren
)paren
suffix:semicolon
id|child_ic
op_assign
id|jffs2_get_ino_cache
c_func
(paren
id|c
comma
id|fd-&gt;ino
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|child_ic
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;Cannot remove child &bslash;&quot;%s&bslash;&quot;, ino #%u, because it doesn&squot;t exist&bslash;n&quot;
comma
id|fd-&gt;name
comma
id|fd-&gt;ino
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|jffs2_free_full_dirent
c_func
(paren
id|fd
)paren
suffix:semicolon
id|child_ic-&gt;nlink
op_decrement
suffix:semicolon
)brace
id|ret
op_assign
op_minus
id|EAGAIN
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|ic-&gt;scan
)paren
suffix:semicolon
id|ic-&gt;scan
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t;   We don&squot;t delete the inocache from the hash list and free it yet. &n;&t;   The erase code will do that, when all the nodes are completely gone.&n;&t;*/
r_return
id|ret
suffix:semicolon
)brace
DECL|function|jffs2_do_mount_fs
r_int
id|jffs2_do_mount_fs
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
)paren
(brace
r_int
id|i
suffix:semicolon
id|c-&gt;free_size
op_assign
id|c-&gt;flash_size
suffix:semicolon
id|c-&gt;nr_blocks
op_assign
id|c-&gt;flash_size
op_div
id|c-&gt;sector_size
suffix:semicolon
id|c-&gt;blocks
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|jffs2_eraseblock
)paren
op_star
id|c-&gt;nr_blocks
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|c-&gt;blocks
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|c-&gt;nr_blocks
suffix:semicolon
id|i
op_increment
)paren
(brace
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|c-&gt;blocks
(braket
id|i
)braket
dot
id|list
)paren
suffix:semicolon
id|c-&gt;blocks
(braket
id|i
)braket
dot
id|offset
op_assign
id|i
op_star
id|c-&gt;sector_size
suffix:semicolon
id|c-&gt;blocks
(braket
id|i
)braket
dot
id|free_size
op_assign
id|c-&gt;sector_size
suffix:semicolon
id|c-&gt;blocks
(braket
id|i
)braket
dot
id|dirty_size
op_assign
l_int|0
suffix:semicolon
id|c-&gt;blocks
(braket
id|i
)braket
dot
id|used_size
op_assign
l_int|0
suffix:semicolon
id|c-&gt;blocks
(braket
id|i
)braket
dot
id|first_node
op_assign
l_int|NULL
suffix:semicolon
id|c-&gt;blocks
(braket
id|i
)braket
dot
id|last_node
op_assign
l_int|NULL
suffix:semicolon
)brace
id|init_MUTEX
c_func
(paren
op_amp
id|c-&gt;alloc_sem
)paren
suffix:semicolon
id|init_MUTEX
c_func
(paren
op_amp
id|c-&gt;erase_free_sem
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|c-&gt;erase_wait
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|c-&gt;erase_completion_lock
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|c-&gt;inocache_lock
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|c-&gt;clean_list
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|c-&gt;dirty_list
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|c-&gt;erasable_list
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|c-&gt;erasing_list
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|c-&gt;erase_pending_list
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|c-&gt;erasable_pending_wbuf_list
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|c-&gt;erase_complete_list
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|c-&gt;free_list
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|c-&gt;bad_list
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|c-&gt;bad_used_list
)paren
suffix:semicolon
id|c-&gt;highest_ino
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|jffs2_build_filesystem
c_func
(paren
id|c
)paren
)paren
(brace
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;build_fs failed&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|jffs2_free_ino_caches
c_func
(paren
id|c
)paren
suffix:semicolon
id|jffs2_free_raw_node_refs
c_func
(paren
id|c
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|c-&gt;blocks
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
eof
