multiline_comment|/*&n; * JFFS2 -- Journalling Flash File System, Version 2.&n; *&n; * Copyright (C) 2001, 2002 Red Hat, Inc.&n; *&n; * Created by David Woodhouse &lt;dwmw2@cambridge.redhat.com&gt;&n; *&n; * For licensing information, see the file &squot;LICENCE&squot; in this directory.&n; *&n; * $Id: build.c,v 1.46 2003/04/29 17:12:26 gleixner Exp $&n; *&n; */
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &quot;nodelist.h&quot;
r_int
id|jffs2_build_inode_pass1
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
comma
r_struct
id|jffs2_inode_cache
op_star
)paren
suffix:semicolon
r_int
id|jffs2_build_remove_unlinked_inode
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
comma
r_struct
id|jffs2_inode_cache
op_star
)paren
suffix:semicolon
r_static
r_inline
r_struct
id|jffs2_inode_cache
op_star
DECL|function|first_inode_chain
id|first_inode_chain
c_func
(paren
r_int
op_star
id|i
comma
r_struct
id|jffs2_sb_info
op_star
id|c
)paren
(brace
r_for
c_loop
(paren
suffix:semicolon
op_star
id|i
OL
id|INOCACHE_HASHSIZE
suffix:semicolon
(paren
op_star
id|i
)paren
op_increment
)paren
(brace
r_if
c_cond
(paren
id|c-&gt;inocache_list
(braket
op_star
id|i
)braket
)paren
r_return
id|c-&gt;inocache_list
(braket
op_star
id|i
)braket
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
r_static
r_inline
r_struct
id|jffs2_inode_cache
op_star
DECL|function|next_inode
id|next_inode
c_func
(paren
r_int
op_star
id|i
comma
r_struct
id|jffs2_inode_cache
op_star
id|ic
comma
r_struct
id|jffs2_sb_info
op_star
id|c
)paren
(brace
multiline_comment|/* More in this chain? */
r_if
c_cond
(paren
id|ic-&gt;next
)paren
r_return
id|ic-&gt;next
suffix:semicolon
(paren
op_star
id|i
)paren
op_increment
suffix:semicolon
r_return
id|first_inode_chain
c_func
(paren
id|i
comma
id|c
)paren
suffix:semicolon
)brace
DECL|macro|for_each_inode
mdefine_line|#define for_each_inode(i, c, ic)&t;&t;&t;&bslash;&n;&t;for (i = 0, ic = first_inode_chain(&amp;i, (c));&t;&bslash;&n;&t;     ic;&t;&t;&t;&t;&t;&bslash;&n;&t;     ic = next_inode(&amp;i, ic, (c)))
multiline_comment|/* Scan plan:&n; - Scan physical nodes. Build map of inodes/dirents. Allocate inocaches as we go&n; - Scan directory tree from top down, setting nlink in inocaches&n; - Scan inocaches for inodes with nlink==0&n;*/
DECL|function|jffs2_build_filesystem
r_static
r_int
id|jffs2_build_filesystem
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
)paren
(brace
r_int
id|ret
suffix:semicolon
r_int
id|i
suffix:semicolon
r_struct
id|jffs2_inode_cache
op_star
id|ic
suffix:semicolon
multiline_comment|/* First, scan the medium and build all the inode caches with&n;&t;   lists of physical nodes */
id|c-&gt;flags
op_or_assign
id|JFFS2_SB_FLAG_MOUNTING
suffix:semicolon
id|ret
op_assign
id|jffs2_scan_medium
c_func
(paren
id|c
)paren
suffix:semicolon
id|c-&gt;flags
op_and_assign
op_complement
id|JFFS2_SB_FLAG_MOUNTING
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_return
id|ret
suffix:semicolon
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Scanned flash completely&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|D1
c_func
(paren
id|jffs2_dump_block_lists
c_func
(paren
id|c
)paren
)paren
suffix:semicolon
multiline_comment|/* Now scan the directory tree, increasing nlink according to every dirent found. */
id|for_each_inode
c_func
(paren
id|i
comma
id|c
comma
id|ic
)paren
(brace
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Pass 1: ino #%u&bslash;n&quot;
comma
id|ic-&gt;ino
)paren
)paren
suffix:semicolon
id|ret
op_assign
id|jffs2_build_inode_pass1
c_func
(paren
id|c
comma
id|ic
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Eep. jffs2_build_inode_pass1 for ino %d returned %d&bslash;n&quot;
comma
id|ic-&gt;ino
comma
id|ret
)paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
id|cond_resched
c_func
(paren
)paren
suffix:semicolon
)brace
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Pass 1 complete&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|D1
c_func
(paren
id|jffs2_dump_block_lists
c_func
(paren
id|c
)paren
)paren
suffix:semicolon
multiline_comment|/* Next, scan for inodes with nlink == 0 and remove them. If&n;&t;   they were directories, then decrement the nlink of their&n;&t;   children too, and repeat the scan. As that&squot;s going to be&n;&t;   a fairly uncommon occurrence, it&squot;s not so evil to do it this&n;&t;   way. Recursion bad. */
r_do
(brace
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Pass 2 (re)starting&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
id|for_each_inode
c_func
(paren
id|i
comma
id|c
comma
id|ic
)paren
(brace
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Pass 2: ino #%u, nlink %d, ic %p, nodes %p&bslash;n&quot;
comma
id|ic-&gt;ino
comma
id|ic-&gt;nlink
comma
id|ic
comma
id|ic-&gt;nodes
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ic-&gt;nlink
)paren
r_continue
suffix:semicolon
multiline_comment|/* XXX: Can get high latency here. Move the cond_resched() from the end of the loop? */
id|ret
op_assign
id|jffs2_build_remove_unlinked_inode
c_func
(paren
id|c
comma
id|ic
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_break
suffix:semicolon
multiline_comment|/* -EAGAIN means the inode&squot;s nlink was zero, so we deleted it,&n;&t;&t;   and furthermore that it had children and their nlink has now&n;&t;&t;   gone to zero too. So we have to restart the scan. */
)brace
id|D1
c_func
(paren
id|jffs2_dump_block_lists
c_func
(paren
id|c
)paren
)paren
suffix:semicolon
id|cond_resched
c_func
(paren
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|ret
op_eq
op_minus
id|EAGAIN
)paren
(brace
suffix:semicolon
)brace
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Pass 2 complete&bslash;n&quot;
)paren
)paren
suffix:semicolon
multiline_comment|/* Finally, we can scan again and free the dirent nodes and scan_info structs */
id|for_each_inode
c_func
(paren
id|i
comma
id|c
comma
id|ic
)paren
(brace
r_struct
id|jffs2_full_dirent
op_star
id|fd
suffix:semicolon
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Pass 3: ino #%u, ic %p, nodes %p&bslash;n&quot;
comma
id|ic-&gt;ino
comma
id|ic
comma
id|ic-&gt;nodes
)paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|ic-&gt;scan_dents
)paren
(brace
id|fd
op_assign
id|ic-&gt;scan_dents
suffix:semicolon
id|ic-&gt;scan_dents
op_assign
id|fd-&gt;next
suffix:semicolon
id|jffs2_free_full_dirent
c_func
(paren
id|fd
)paren
suffix:semicolon
)brace
id|ic-&gt;scan_dents
op_assign
l_int|NULL
suffix:semicolon
id|cond_resched
c_func
(paren
)paren
suffix:semicolon
)brace
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Pass 3 complete&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|D1
c_func
(paren
id|jffs2_dump_block_lists
c_func
(paren
id|c
)paren
)paren
suffix:semicolon
multiline_comment|/* Rotate the lists by some number to ensure wear levelling */
id|jffs2_rotate_lists
c_func
(paren
id|c
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|jffs2_build_inode_pass1
r_int
id|jffs2_build_inode_pass1
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
comma
r_struct
id|jffs2_inode_cache
op_star
id|ic
)paren
(brace
r_struct
id|jffs2_full_dirent
op_star
id|fd
suffix:semicolon
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;jffs2_build_inode building inode #%u&bslash;n&quot;
comma
id|ic-&gt;ino
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ic-&gt;ino
OG
id|c-&gt;highest_ino
)paren
id|c-&gt;highest_ino
op_assign
id|ic-&gt;ino
suffix:semicolon
multiline_comment|/* For each child, increase nlink */
r_for
c_loop
(paren
id|fd
op_assign
id|ic-&gt;scan_dents
suffix:semicolon
id|fd
suffix:semicolon
id|fd
op_assign
id|fd-&gt;next
)paren
(brace
r_struct
id|jffs2_inode_cache
op_star
id|child_ic
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fd-&gt;ino
)paren
r_continue
suffix:semicolon
multiline_comment|/* XXX: Can get high latency here with huge directories */
id|child_ic
op_assign
id|jffs2_get_ino_cache
c_func
(paren
id|c
comma
id|fd-&gt;ino
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|child_ic
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;Eep. Child &bslash;&quot;%s&bslash;&quot; (ino #%u) of dir ino #%u doesn&squot;t exist!&bslash;n&quot;
comma
id|fd-&gt;name
comma
id|fd-&gt;ino
comma
id|ic-&gt;ino
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|child_ic-&gt;nlink
op_increment
op_logical_and
id|fd-&gt;type
op_eq
id|DT_DIR
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;Child dir &bslash;&quot;%s&bslash;&quot; (ino #%u) of dir ino #%u appears to be a hard link&bslash;n&quot;
comma
id|fd-&gt;name
comma
id|fd-&gt;ino
comma
id|ic-&gt;ino
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fd-&gt;ino
op_eq
l_int|1
op_logical_and
id|ic-&gt;ino
op_eq
l_int|1
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;This is mostly harmless, and probably caused by creating a JFFS2 image&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;using a buggy version of mkfs.jffs2. Use at least v1.17.&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* What do we do about it? */
)brace
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Increased nlink for child &bslash;&quot;%s&bslash;&quot; (ino #%u)&bslash;n&quot;
comma
id|fd-&gt;name
comma
id|fd-&gt;ino
)paren
)paren
suffix:semicolon
multiline_comment|/* Can&squot;t free them. We might need them in pass 2 */
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|jffs2_build_remove_unlinked_inode
r_int
id|jffs2_build_remove_unlinked_inode
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
comma
r_struct
id|jffs2_inode_cache
op_star
id|ic
)paren
(brace
r_struct
id|jffs2_raw_node_ref
op_star
id|raw
suffix:semicolon
r_struct
id|jffs2_full_dirent
op_star
id|fd
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;JFFS2: Removing ino #%u with nlink == zero.&bslash;n&quot;
comma
id|ic-&gt;ino
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|raw
op_assign
id|ic-&gt;nodes
suffix:semicolon
id|raw
op_ne
(paren
r_void
op_star
)paren
id|ic
suffix:semicolon
id|raw
op_assign
id|raw-&gt;next_in_ino
)paren
(brace
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;obsoleting node at 0x%08x&bslash;n&quot;
comma
id|ref_offset
c_func
(paren
id|raw
)paren
)paren
)paren
suffix:semicolon
id|jffs2_mark_node_obsolete
c_func
(paren
id|c
comma
id|raw
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ic-&gt;scan_dents
)paren
(brace
r_int
id|whinged
op_assign
l_int|0
suffix:semicolon
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Inode #%u was a directory which may have children...&bslash;n&quot;
comma
id|ic-&gt;ino
)paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|ic-&gt;scan_dents
)paren
(brace
r_struct
id|jffs2_inode_cache
op_star
id|child_ic
suffix:semicolon
id|fd
op_assign
id|ic-&gt;scan_dents
suffix:semicolon
id|ic-&gt;scan_dents
op_assign
id|fd-&gt;next
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fd-&gt;ino
)paren
(brace
multiline_comment|/* It&squot;s a deletion dirent. Ignore it */
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Child &bslash;&quot;%s&bslash;&quot; is a deletion dirent, skipping...&bslash;n&quot;
comma
id|fd-&gt;name
)paren
)paren
suffix:semicolon
id|jffs2_free_full_dirent
c_func
(paren
id|fd
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|whinged
)paren
(brace
id|whinged
op_assign
l_int|1
suffix:semicolon
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;Inode #%u was a directory with children - removing those too...&bslash;n&quot;
comma
id|ic-&gt;ino
)paren
suffix:semicolon
)brace
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Removing child &bslash;&quot;%s&bslash;&quot;, ino #%u&bslash;n&quot;
comma
id|fd-&gt;name
comma
id|fd-&gt;ino
)paren
)paren
suffix:semicolon
id|child_ic
op_assign
id|jffs2_get_ino_cache
c_func
(paren
id|c
comma
id|fd-&gt;ino
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|child_ic
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;Cannot remove child &bslash;&quot;%s&bslash;&quot;, ino #%u, because it doesn&squot;t exist&bslash;n&quot;
comma
id|fd-&gt;name
comma
id|fd-&gt;ino
)paren
suffix:semicolon
id|jffs2_free_full_dirent
c_func
(paren
id|fd
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|jffs2_free_full_dirent
c_func
(paren
id|fd
)paren
suffix:semicolon
id|child_ic-&gt;nlink
op_decrement
suffix:semicolon
)brace
id|ret
op_assign
op_minus
id|EAGAIN
suffix:semicolon
)brace
multiline_comment|/*&n;&t;   We don&squot;t delete the inocache from the hash list and free it yet. &n;&t;   The erase code will do that, when all the nodes are completely gone.&n;&t;*/
r_return
id|ret
suffix:semicolon
)brace
DECL|function|jffs2_do_mount_fs
r_int
id|jffs2_do_mount_fs
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
)paren
(brace
r_int
id|i
suffix:semicolon
id|c-&gt;free_size
op_assign
id|c-&gt;flash_size
suffix:semicolon
id|c-&gt;nr_blocks
op_assign
id|c-&gt;flash_size
op_div
id|c-&gt;sector_size
suffix:semicolon
id|c-&gt;blocks
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|jffs2_eraseblock
)paren
op_star
id|c-&gt;nr_blocks
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|c-&gt;blocks
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|c-&gt;nr_blocks
suffix:semicolon
id|i
op_increment
)paren
(brace
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|c-&gt;blocks
(braket
id|i
)braket
dot
id|list
)paren
suffix:semicolon
id|c-&gt;blocks
(braket
id|i
)braket
dot
id|offset
op_assign
id|i
op_star
id|c-&gt;sector_size
suffix:semicolon
id|c-&gt;blocks
(braket
id|i
)braket
dot
id|free_size
op_assign
id|c-&gt;sector_size
suffix:semicolon
id|c-&gt;blocks
(braket
id|i
)braket
dot
id|dirty_size
op_assign
l_int|0
suffix:semicolon
id|c-&gt;blocks
(braket
id|i
)braket
dot
id|wasted_size
op_assign
l_int|0
suffix:semicolon
id|c-&gt;blocks
(braket
id|i
)braket
dot
id|unchecked_size
op_assign
l_int|0
suffix:semicolon
id|c-&gt;blocks
(braket
id|i
)braket
dot
id|used_size
op_assign
l_int|0
suffix:semicolon
id|c-&gt;blocks
(braket
id|i
)braket
dot
id|first_node
op_assign
l_int|NULL
suffix:semicolon
id|c-&gt;blocks
(braket
id|i
)braket
dot
id|last_node
op_assign
l_int|NULL
suffix:semicolon
)brace
id|init_MUTEX
c_func
(paren
op_amp
id|c-&gt;alloc_sem
)paren
suffix:semicolon
id|init_MUTEX
c_func
(paren
op_amp
id|c-&gt;erase_free_sem
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|c-&gt;erase_wait
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|c-&gt;inocache_wq
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|c-&gt;erase_completion_lock
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|c-&gt;inocache_lock
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|c-&gt;clean_list
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|c-&gt;very_dirty_list
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|c-&gt;dirty_list
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|c-&gt;erasable_list
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|c-&gt;erasing_list
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|c-&gt;erase_pending_list
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|c-&gt;erasable_pending_wbuf_list
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|c-&gt;erase_complete_list
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|c-&gt;free_list
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|c-&gt;bad_list
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|c-&gt;bad_used_list
)paren
suffix:semicolon
id|c-&gt;highest_ino
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|jffs2_build_filesystem
c_func
(paren
id|c
)paren
)paren
(brace
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;build_fs failed&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|jffs2_free_ino_caches
c_func
(paren
id|c
)paren
suffix:semicolon
id|jffs2_free_raw_node_refs
c_func
(paren
id|c
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|c-&gt;blocks
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
eof
