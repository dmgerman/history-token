multiline_comment|/*&n; * JFFS2 -- Journalling Flash File System, Version 2.&n; *&n; * Copyright (C) 2001-2003 Red Hat, Inc.&n; *&n; * Created by David Woodhouse &lt;dwmw2@redhat.com&gt;&n; *&n; * For licensing information, see the file &squot;LICENCE&squot; in this directory.&n; *&n; * $Id: nodelist.h,v 1.121 2004/11/14 17:07:07 dedekind Exp $&n; *&n; */
macro_line|#ifndef __JFFS2_NODELIST_H__
DECL|macro|__JFFS2_NODELIST_H__
mdefine_line|#define __JFFS2_NODELIST_H__
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/jffs2.h&gt;
macro_line|#include &lt;linux/jffs2_fs_sb.h&gt;
macro_line|#include &lt;linux/jffs2_fs_i.h&gt;
macro_line|#ifdef __ECOS
macro_line|#include &quot;os-ecos.h&quot;
macro_line|#else
macro_line|#include &lt;linux/mtd/compatmac.h&gt; /* For min/max in older kernels */
macro_line|#include &quot;os-linux.h&quot;
macro_line|#endif
macro_line|#ifndef CONFIG_JFFS2_FS_DEBUG
DECL|macro|CONFIG_JFFS2_FS_DEBUG
mdefine_line|#define CONFIG_JFFS2_FS_DEBUG 1
macro_line|#endif
macro_line|#if CONFIG_JFFS2_FS_DEBUG &gt; 0
DECL|macro|D1
mdefine_line|#define D1(x) x
macro_line|#else
DECL|macro|D1
mdefine_line|#define D1(x)
macro_line|#endif
macro_line|#if CONFIG_JFFS2_FS_DEBUG &gt; 1
DECL|macro|D2
mdefine_line|#define D2(x) x
macro_line|#else
DECL|macro|D2
mdefine_line|#define D2(x)
macro_line|#endif
DECL|macro|JFFS2_NATIVE_ENDIAN
mdefine_line|#define JFFS2_NATIVE_ENDIAN
multiline_comment|/* Note we handle mode bits conversion from JFFS2 (i.e. Linux) to/from&n;   whatever OS we&squot;re actually running on here too. */
macro_line|#if defined(JFFS2_NATIVE_ENDIAN)
DECL|macro|cpu_to_je16
mdefine_line|#define cpu_to_je16(x) ((jint16_t){x})
DECL|macro|cpu_to_je32
mdefine_line|#define cpu_to_je32(x) ((jint32_t){x})
DECL|macro|cpu_to_jemode
mdefine_line|#define cpu_to_jemode(x) ((jmode_t){os_to_jffs2_mode(x)})
DECL|macro|je16_to_cpu
mdefine_line|#define je16_to_cpu(x) ((x).v16)
DECL|macro|je32_to_cpu
mdefine_line|#define je32_to_cpu(x) ((x).v32)
DECL|macro|jemode_to_cpu
mdefine_line|#define jemode_to_cpu(x) (jffs2_to_os_mode((x).m))
macro_line|#elif defined(JFFS2_BIG_ENDIAN)
DECL|macro|cpu_to_je16
mdefine_line|#define cpu_to_je16(x) ((jint16_t){cpu_to_be16(x)})
DECL|macro|cpu_to_je32
mdefine_line|#define cpu_to_je32(x) ((jint32_t){cpu_to_be32(x)})
DECL|macro|cpu_to_jemode
mdefine_line|#define cpu_to_jemode(x) ((jmode_t){cpu_to_be32(os_to_jffs2_mode(x))})
DECL|macro|je16_to_cpu
mdefine_line|#define je16_to_cpu(x) (be16_to_cpu(x.v16))
DECL|macro|je32_to_cpu
mdefine_line|#define je32_to_cpu(x) (be32_to_cpu(x.v32))
DECL|macro|jemode_to_cpu
mdefine_line|#define jemode_to_cpu(x) (be32_to_cpu(jffs2_to_os_mode((x).m)))
macro_line|#elif defined(JFFS2_LITTLE_ENDIAN)
DECL|macro|cpu_to_je16
mdefine_line|#define cpu_to_je16(x) ((jint16_t){cpu_to_le16(x)})
DECL|macro|cpu_to_je32
mdefine_line|#define cpu_to_je32(x) ((jint32_t){cpu_to_le32(x)})
DECL|macro|cpu_to_jemode
mdefine_line|#define cpu_to_jemode(x) ((jmode_t){cpu_to_le32(os_to_jffs2_mode(x))})
DECL|macro|je16_to_cpu
mdefine_line|#define je16_to_cpu(x) (le16_to_cpu(x.v16))
DECL|macro|je32_to_cpu
mdefine_line|#define je32_to_cpu(x) (le32_to_cpu(x.v32))
DECL|macro|jemode_to_cpu
mdefine_line|#define jemode_to_cpu(x) (le32_to_cpu(jffs2_to_os_mode((x).m)))
macro_line|#else 
macro_line|#error wibble
macro_line|#endif
multiline_comment|/*&n;  This is all we need to keep in-core for each raw node during normal&n;  operation. As and when we do read_inode on a particular inode, we can&n;  scan the nodes which are listed for it and build up a proper map of &n;  which nodes are currently valid. JFFSv1 always used to keep that whole&n;  map in core for each inode.&n;*/
DECL|struct|jffs2_raw_node_ref
r_struct
id|jffs2_raw_node_ref
(brace
DECL|member|next_in_ino
r_struct
id|jffs2_raw_node_ref
op_star
id|next_in_ino
suffix:semicolon
multiline_comment|/* Points to the next raw_node_ref&n;&t;&t;for this inode. If this is the last, it points to the inode_cache&n;&t;&t;for this inode instead. The inode_cache will have NULL in the first&n;&t;&t;word so you know when you&squot;ve got there :) */
DECL|member|next_phys
r_struct
id|jffs2_raw_node_ref
op_star
id|next_phys
suffix:semicolon
DECL|member|flash_offset
r_uint32
id|flash_offset
suffix:semicolon
DECL|member|__totlen
r_uint32
id|__totlen
suffix:semicolon
multiline_comment|/* This may die; use ref_totlen(c, jeb, ) below */
)brace
suffix:semicolon
multiline_comment|/* flash_offset &amp; 3 always has to be zero, because nodes are&n;&t;   always aligned at 4 bytes. So we have a couple of extra bits&n;&t;   to play with, which indicate the node&squot;s status; see below: */
DECL|macro|REF_UNCHECKED
mdefine_line|#define REF_UNCHECKED&t;0&t;/* We haven&squot;t yet checked the CRC or built its inode */
DECL|macro|REF_OBSOLETE
mdefine_line|#define REF_OBSOLETE&t;1&t;/* Obsolete, can be completely ignored */
DECL|macro|REF_PRISTINE
mdefine_line|#define REF_PRISTINE&t;2&t;/* Completely clean. GC without looking */
DECL|macro|REF_NORMAL
mdefine_line|#define REF_NORMAL&t;3&t;/* Possibly overlapped. Read the page and write again on GC */
DECL|macro|ref_flags
mdefine_line|#define ref_flags(ref)&t;&t;((ref)-&gt;flash_offset &amp; 3)
DECL|macro|ref_offset
mdefine_line|#define ref_offset(ref)&t;&t;((ref)-&gt;flash_offset &amp; ~3)
DECL|macro|ref_obsolete
mdefine_line|#define ref_obsolete(ref)&t;(((ref)-&gt;flash_offset &amp; 3) == REF_OBSOLETE)
DECL|macro|mark_ref_normal
mdefine_line|#define mark_ref_normal(ref)    do { (ref)-&gt;flash_offset = ref_offset(ref) | REF_NORMAL; } while(0)
multiline_comment|/* &n;   Used for keeping track of deletion nodes &amp;c, which can only be marked&n;   as obsolete when the node which they mark as deleted has actually been &n;   removed from the flash.&n;*/
DECL|struct|jffs2_raw_node_ref_list
r_struct
id|jffs2_raw_node_ref_list
(brace
DECL|member|rew
r_struct
id|jffs2_raw_node_ref
op_star
id|rew
suffix:semicolon
DECL|member|next
r_struct
id|jffs2_raw_node_ref_list
op_star
id|next
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* For each inode in the filesystem, we need to keep a record of&n;   nlink, because it would be a PITA to scan the whole directory tree&n;   at read_inode() time to calculate it, and to keep sufficient information&n;   in the raw_node_ref (basically both parent and child inode number for &n;   dirent nodes) would take more space than this does. We also keep&n;   a pointer to the first physical node which is part of this inode, too.&n;*/
DECL|struct|jffs2_inode_cache
r_struct
id|jffs2_inode_cache
(brace
DECL|member|scan_dents
r_struct
id|jffs2_full_dirent
op_star
id|scan_dents
suffix:semicolon
multiline_comment|/* Used during scan to hold&n;&t;&t;temporary lists of dirents, and later must be set to&n;&t;&t;NULL to mark the end of the raw_node_ref-&gt;next_in_ino&n;&t;&t;chain. */
DECL|member|next
r_struct
id|jffs2_inode_cache
op_star
id|next
suffix:semicolon
DECL|member|nodes
r_struct
id|jffs2_raw_node_ref
op_star
id|nodes
suffix:semicolon
DECL|member|ino
r_uint32
id|ino
suffix:semicolon
DECL|member|nlink
r_int
id|nlink
suffix:semicolon
DECL|member|state
r_int
id|state
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* Inode states for &squot;state&squot; above. We need the &squot;GC&squot; state to prevent&n;   someone from doing a read_inode() while we&squot;re moving a &squot;REF_PRISTINE&squot;&n;   node without going through all the iget() nonsense */
DECL|macro|INO_STATE_UNCHECKED
mdefine_line|#define INO_STATE_UNCHECKED&t;0&t;/* CRC checks not yet done */
DECL|macro|INO_STATE_CHECKING
mdefine_line|#define INO_STATE_CHECKING&t;1&t;/* CRC checks in progress */
DECL|macro|INO_STATE_PRESENT
mdefine_line|#define INO_STATE_PRESENT&t;2&t;/* In core */
DECL|macro|INO_STATE_CHECKEDABSENT
mdefine_line|#define INO_STATE_CHECKEDABSENT&t;3&t;/* Checked, cleared again */
DECL|macro|INO_STATE_GC
mdefine_line|#define INO_STATE_GC&t;&t;4&t;/* GCing a &squot;pristine&squot; node */
DECL|macro|INO_STATE_READING
mdefine_line|#define INO_STATE_READING&t;5&t;/* In read_inode() */
DECL|macro|INOCACHE_HASHSIZE
mdefine_line|#define INOCACHE_HASHSIZE 128
DECL|struct|jffs2_scan_info
r_struct
id|jffs2_scan_info
(brace
DECL|member|dents
r_struct
id|jffs2_full_dirent
op_star
id|dents
suffix:semicolon
DECL|member|tmpnodes
r_struct
id|jffs2_tmp_dnode_info
op_star
id|tmpnodes
suffix:semicolon
multiline_comment|/* Latest i_size info */
DECL|member|version
r_uint32
id|version
suffix:semicolon
DECL|member|isize
r_uint32
id|isize
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;  Larger representation of a raw node, kept in-core only when the &n;  struct inode for this particular ino is instantiated.&n;*/
DECL|struct|jffs2_full_dnode
r_struct
id|jffs2_full_dnode
(brace
DECL|member|raw
r_struct
id|jffs2_raw_node_ref
op_star
id|raw
suffix:semicolon
DECL|member|ofs
r_uint32
id|ofs
suffix:semicolon
multiline_comment|/* Don&squot;t really need this, but optimisation */
DECL|member|size
r_uint32
id|size
suffix:semicolon
DECL|member|frags
r_uint32
id|frags
suffix:semicolon
multiline_comment|/* Number of fragments which currently refer&n;&t;&t;&t;to this node. When this reaches zero, &n;&t;&t;&t;the node is obsolete.&n;&t;&t;     */
)brace
suffix:semicolon
multiline_comment|/* &n;   Even larger representation of a raw node, kept in-core only while&n;   we&squot;re actually building up the original map of which nodes go where,&n;   in read_inode()&n;*/
DECL|struct|jffs2_tmp_dnode_info
r_struct
id|jffs2_tmp_dnode_info
(brace
DECL|member|next
r_struct
id|jffs2_tmp_dnode_info
op_star
id|next
suffix:semicolon
DECL|member|fn
r_struct
id|jffs2_full_dnode
op_star
id|fn
suffix:semicolon
DECL|member|version
r_uint32
id|version
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|jffs2_full_dirent
r_struct
id|jffs2_full_dirent
(brace
DECL|member|raw
r_struct
id|jffs2_raw_node_ref
op_star
id|raw
suffix:semicolon
DECL|member|next
r_struct
id|jffs2_full_dirent
op_star
id|next
suffix:semicolon
DECL|member|version
r_uint32
id|version
suffix:semicolon
DECL|member|ino
r_uint32
id|ino
suffix:semicolon
multiline_comment|/* == zero for unlink */
DECL|member|nhash
r_int
r_int
id|nhash
suffix:semicolon
DECL|member|type
r_int
r_char
id|type
suffix:semicolon
DECL|member|name
r_int
r_char
id|name
(braket
l_int|0
)braket
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;  Fragments - used to build a map of which raw node to obtain &n;  data from for each part of the ino&n;*/
DECL|struct|jffs2_node_frag
r_struct
id|jffs2_node_frag
(brace
DECL|member|rb
r_struct
id|rb_node
id|rb
suffix:semicolon
DECL|member|node
r_struct
id|jffs2_full_dnode
op_star
id|node
suffix:semicolon
multiline_comment|/* NULL for holes */
DECL|member|size
r_uint32
id|size
suffix:semicolon
DECL|member|ofs
r_uint32
id|ofs
suffix:semicolon
multiline_comment|/* Don&squot;t really need this, but optimisation */
)brace
suffix:semicolon
DECL|struct|jffs2_eraseblock
r_struct
id|jffs2_eraseblock
(brace
DECL|member|list
r_struct
id|list_head
id|list
suffix:semicolon
DECL|member|bad_count
r_int
id|bad_count
suffix:semicolon
DECL|member|offset
r_uint32
id|offset
suffix:semicolon
multiline_comment|/* of this block in the MTD */
DECL|member|unchecked_size
r_uint32
id|unchecked_size
suffix:semicolon
DECL|member|used_size
r_uint32
id|used_size
suffix:semicolon
DECL|member|dirty_size
r_uint32
id|dirty_size
suffix:semicolon
DECL|member|wasted_size
r_uint32
id|wasted_size
suffix:semicolon
DECL|member|free_size
r_uint32
id|free_size
suffix:semicolon
multiline_comment|/* Note that sector_size - free_size&n;&t;&t;&t;&t;   is the address of the first free space */
DECL|member|first_node
r_struct
id|jffs2_raw_node_ref
op_star
id|first_node
suffix:semicolon
DECL|member|last_node
r_struct
id|jffs2_raw_node_ref
op_star
id|last_node
suffix:semicolon
DECL|member|gc_node
r_struct
id|jffs2_raw_node_ref
op_star
id|gc_node
suffix:semicolon
multiline_comment|/* Next node to be garbage collected */
multiline_comment|/* For deletia. When a dirent node in this eraseblock is&n;&t;   deleted by a node elsewhere, that other node can only &n;&t;   be marked as obsolete when this block is actually erased.&n;&t;   So we keep a list of the nodes to mark as obsolete when&n;&t;   the erase is completed.&n;&t;*/
singleline_comment|// MAYBE&t;struct jffs2_raw_node_ref_list *deletia;
)brace
suffix:semicolon
DECL|macro|ACCT_SANITY_CHECK
mdefine_line|#define ACCT_SANITY_CHECK(c, jeb) do { &bslash;&n;&t;&t;struct jffs2_eraseblock *___j = jeb; &bslash;&n;&t;&t;if ((___j) &amp;&amp; ___j-&gt;used_size + ___j-&gt;dirty_size + ___j-&gt;free_size + ___j-&gt;wasted_size + ___j-&gt;unchecked_size != c-&gt;sector_size) { &bslash;&n;&t;&t;printk(KERN_NOTICE &quot;Eeep. Space accounting for block at 0x%08x is screwed&bslash;n&quot;, ___j-&gt;offset); &bslash;&n;&t;&t;printk(KERN_NOTICE &quot;free 0x%08x + dirty 0x%08x + used %08x + wasted %08x + unchecked %08x != total %08x&bslash;n&quot;, &bslash;&n;&t;&t;___j-&gt;free_size, ___j-&gt;dirty_size, ___j-&gt;used_size, ___j-&gt;wasted_size, ___j-&gt;unchecked_size, c-&gt;sector_size); &bslash;&n;&t;&t;BUG(); &bslash;&n;&t;} &bslash;&n;&t;if (c-&gt;used_size + c-&gt;dirty_size + c-&gt;free_size + c-&gt;erasing_size + c-&gt;bad_size + c-&gt;wasted_size + c-&gt;unchecked_size != c-&gt;flash_size) { &bslash;&n;&t;&t;printk(KERN_NOTICE &quot;Eeep. Space accounting superblock info is screwed&bslash;n&quot;); &bslash;&n;&t;&t;printk(KERN_NOTICE &quot;free 0x%08x + dirty 0x%08x + used %08x + erasing %08x + bad %08x + wasted %08x + unchecked %08x != total %08x&bslash;n&quot;, &bslash;&n;&t;&t;c-&gt;free_size, c-&gt;dirty_size, c-&gt;used_size, c-&gt;erasing_size, c-&gt;bad_size, c-&gt;wasted_size, c-&gt;unchecked_size, c-&gt;flash_size); &bslash;&n;&t;&t;BUG(); &bslash;&n;&t;} &bslash;&n;} while(0)
DECL|function|paranoia_failed_dump
r_static
r_inline
r_void
id|paranoia_failed_dump
c_func
(paren
r_struct
id|jffs2_eraseblock
op_star
id|jeb
)paren
(brace
r_struct
id|jffs2_raw_node_ref
op_star
id|ref
suffix:semicolon
r_int
id|i
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
id|KERN_NOTICE
)paren
suffix:semicolon
r_for
c_loop
(paren
id|ref
op_assign
id|jeb-&gt;first_node
suffix:semicolon
id|ref
suffix:semicolon
id|ref
op_assign
id|ref-&gt;next_phys
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%08x-&gt;&quot;
comma
id|ref_offset
c_func
(paren
id|ref
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|i
op_eq
l_int|8
)paren
(brace
id|i
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
id|KERN_NOTICE
)paren
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|macro|ACCT_PARANOIA_CHECK
mdefine_line|#define ACCT_PARANOIA_CHECK(jeb) do { &bslash;&n;&t;&t;uint32_t my_used_size = 0; &bslash;&n;&t;&t;uint32_t my_unchecked_size = 0; &bslash;&n;&t;&t;struct jffs2_raw_node_ref *ref2 = jeb-&gt;first_node; &bslash;&n;&t;&t;while (ref2) { &bslash;&n;&t;&t;&t;if (unlikely(ref2-&gt;flash_offset &lt; jeb-&gt;offset || &bslash;&n;&t;&t;&t;&t;     ref2-&gt;flash_offset &gt; jeb-&gt;offset + c-&gt;sector_size)) { &bslash;&n;&t;&t;&t;&t;printk(KERN_NOTICE &quot;Node %08x shouldn&squot;t be in block at %08x!&bslash;n&quot;, &bslash;&n;&t;&t;&t;&t;       ref_offset(ref2), jeb-&gt;offset); &bslash;&n;&t;&t;&t;&t;paranoia_failed_dump(jeb); &bslash;&n;&t;&t;&t;&t;BUG(); &bslash;&n;&t;&t;&t;} &bslash;&n;&t;&t;&t;if (ref_flags(ref2) == REF_UNCHECKED) &bslash;&n;&t;&t;&t;&t;my_unchecked_size += ref_totlen(c, jeb, ref2); &bslash;&n;&t;&t;&t;else if (!ref_obsolete(ref2)) &bslash;&n;&t;&t;&t;&t;my_used_size += ref_totlen(c, jeb, ref2); &bslash;&n;&t;&t;&t;if (unlikely((!ref2-&gt;next_phys) != (ref2 == jeb-&gt;last_node))) { &bslash;&n;                                if (!ref2-&gt;next_phys) &bslash;&n;&t;&t;&t;&t;       printk(&quot;ref for node at %p (phys %08x) has next_phys-&gt;%p (----), last_node-&gt;%p (phys %08x)&bslash;n&quot;, &bslash;&n;&t;&t;&t;&t;             ref2, ref_offset(ref2), ref2-&gt;next_phys, &bslash;&n;&t;&t;&t;&t;             jeb-&gt;last_node, ref_offset(jeb-&gt;last_node)); &bslash;&n;                                else &bslash;&n;                                       printk(&quot;ref for node at %p (phys %08x) has next_phys-&gt;%p (%08x), last_node-&gt;%p (phys %08x)&bslash;n&quot;, &bslash;&n;&t;&t;&t;&t;             ref2, ref_offset(ref2), ref2-&gt;next_phys, ref_offset(ref2-&gt;next_phys), &bslash;&n;&t;&t;&t;&t;             jeb-&gt;last_node, ref_offset(jeb-&gt;last_node)); &bslash;&n;&t;&t;&t;&t;paranoia_failed_dump(jeb); &bslash;&n;&t;&t;&t;&t;BUG(); &bslash;&n;&t;&t;&t;} &bslash;&n;&t;&t;&t;ref2 = ref2-&gt;next_phys; &bslash;&n;&t;&t;} &bslash;&n;&t;&t;if (my_used_size != jeb-&gt;used_size) { &bslash;&n;&t;&t;&t;printk(KERN_NOTICE &quot;Calculated used size %08x != stored used size %08x&bslash;n&quot;, my_used_size, jeb-&gt;used_size); &bslash;&n;&t;&t;&t;BUG(); &bslash;&n;&t;&t;} &bslash;&n;&t;&t;if (my_unchecked_size != jeb-&gt;unchecked_size) { &bslash;&n;&t;&t;&t;printk(KERN_NOTICE &quot;Calculated unchecked size %08x != stored unchecked size %08x&bslash;n&quot;, my_unchecked_size, jeb-&gt;unchecked_size); &bslash;&n;&t;&t;&t;BUG(); &bslash;&n;&t;&t;} &bslash;&n;&t;} while(0)
multiline_comment|/* Calculate totlen from surrounding nodes or eraseblock */
DECL|function|__ref_totlen
r_static
r_inline
r_uint32
id|__ref_totlen
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
comma
r_struct
id|jffs2_eraseblock
op_star
id|jeb
comma
r_struct
id|jffs2_raw_node_ref
op_star
id|ref
)paren
(brace
r_uint32
id|ref_end
suffix:semicolon
r_if
c_cond
(paren
id|ref-&gt;next_phys
)paren
id|ref_end
op_assign
id|ref_offset
c_func
(paren
id|ref-&gt;next_phys
)paren
suffix:semicolon
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
id|jeb
)paren
id|jeb
op_assign
op_amp
id|c-&gt;blocks
(braket
id|ref-&gt;flash_offset
op_div
id|c-&gt;sector_size
)braket
suffix:semicolon
multiline_comment|/* Last node in block. Use free_space */
id|BUG_ON
c_func
(paren
id|ref
op_ne
id|jeb-&gt;last_node
)paren
suffix:semicolon
id|ref_end
op_assign
id|jeb-&gt;offset
op_plus
id|c-&gt;sector_size
op_minus
id|jeb-&gt;free_size
suffix:semicolon
)brace
r_return
id|ref_end
op_minus
id|ref_offset
c_func
(paren
id|ref
)paren
suffix:semicolon
)brace
DECL|function|ref_totlen
r_static
r_inline
r_uint32
id|ref_totlen
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
comma
r_struct
id|jffs2_eraseblock
op_star
id|jeb
comma
r_struct
id|jffs2_raw_node_ref
op_star
id|ref
)paren
(brace
r_uint32
id|ret
suffix:semicolon
id|D1
c_func
(paren
r_if
(paren
id|jeb
op_logical_and
id|jeb
op_ne
op_amp
id|c-&gt;blocks
(braket
id|ref-&gt;flash_offset
op_div
id|c-&gt;sector_size
)braket
)paren
(brace
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;ref_totlen called with wrong block -- at 0x%08x instead of 0x%08x; ref 0x%08x&bslash;n&quot;
comma
id|jeb-&gt;offset
comma
id|c-&gt;blocks
(braket
id|ref-&gt;flash_offset
op_div
id|c-&gt;sector_size
)braket
dot
id|offset
comma
id|ref_offset
c_func
(paren
id|ref
)paren
)paren
suffix:semicolon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
)paren
macro_line|#if 1
id|ret
op_assign
id|ref-&gt;__totlen
suffix:semicolon
macro_line|#else
multiline_comment|/* This doesn&squot;t actually work yet */
id|ret
op_assign
id|__ref_totlen
c_func
(paren
id|c
comma
id|jeb
comma
id|ref
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
id|ref-&gt;__totlen
)paren
(brace
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;Totlen for ref at %p (0x%08x-0x%08x) miscalculated as 0x%x instead of %x&bslash;n&quot;
comma
id|ref
comma
id|ref_offset
c_func
(paren
id|ref
)paren
comma
id|ref_offset
c_func
(paren
id|ref
)paren
op_plus
id|ref-&gt;__totlen
comma
id|ret
comma
id|ref-&gt;__totlen
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|jeb
)paren
id|jeb
op_assign
op_amp
id|c-&gt;blocks
(braket
id|ref-&gt;flash_offset
op_div
id|c-&gt;sector_size
)braket
suffix:semicolon
id|paranoia_failed_dump
c_func
(paren
id|jeb
)paren
suffix:semicolon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#endif
r_return
id|ret
suffix:semicolon
)brace
DECL|macro|ALLOC_NORMAL
mdefine_line|#define ALLOC_NORMAL&t;0&t;/* Normal allocation */
DECL|macro|ALLOC_DELETION
mdefine_line|#define ALLOC_DELETION&t;1&t;/* Deletion node. Best to allow it */
DECL|macro|ALLOC_GC
mdefine_line|#define ALLOC_GC&t;2&t;/* Space requested for GC. Give it or die */
DECL|macro|ALLOC_NORETRY
mdefine_line|#define ALLOC_NORETRY&t;3&t;/* For jffs2_write_dnode: On failure, return -EAGAIN instead of retrying */
multiline_comment|/* How much dirty space before it goes on the very_dirty_list */
DECL|macro|VERYDIRTY
mdefine_line|#define VERYDIRTY(c, size) ((size) &gt;= ((c)-&gt;sector_size / 2))
multiline_comment|/* check if dirty space is more than 255 Byte */
DECL|macro|ISDIRTY
mdefine_line|#define ISDIRTY(size) ((size) &gt;  sizeof (struct jffs2_raw_inode) + JFFS2_MIN_DATA_LEN) 
DECL|macro|PAD
mdefine_line|#define PAD(x) (((x)+3)&amp;~3)
DECL|function|jffs2_raw_ref_to_ic
r_static
r_inline
r_struct
id|jffs2_inode_cache
op_star
id|jffs2_raw_ref_to_ic
c_func
(paren
r_struct
id|jffs2_raw_node_ref
op_star
id|raw
)paren
(brace
r_while
c_loop
(paren
id|raw-&gt;next_in_ino
)paren
(brace
id|raw
op_assign
id|raw-&gt;next_in_ino
suffix:semicolon
)brace
r_return
(paren
(paren
r_struct
id|jffs2_inode_cache
op_star
)paren
id|raw
)paren
suffix:semicolon
)brace
DECL|function|frag_first
r_static
r_inline
r_struct
id|jffs2_node_frag
op_star
id|frag_first
c_func
(paren
r_struct
id|rb_root
op_star
id|root
)paren
(brace
r_struct
id|rb_node
op_star
id|node
op_assign
id|root-&gt;rb_node
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|node
)paren
r_return
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
id|node-&gt;rb_left
)paren
(brace
id|node
op_assign
id|node-&gt;rb_left
suffix:semicolon
)brace
r_return
id|rb_entry
c_func
(paren
id|node
comma
r_struct
id|jffs2_node_frag
comma
id|rb
)paren
suffix:semicolon
)brace
DECL|macro|rb_parent
mdefine_line|#define rb_parent(rb) ((rb)-&gt;rb_parent)
DECL|macro|frag_next
mdefine_line|#define frag_next(frag) rb_entry(rb_next(&amp;(frag)-&gt;rb), struct jffs2_node_frag, rb)
DECL|macro|frag_prev
mdefine_line|#define frag_prev(frag) rb_entry(rb_prev(&amp;(frag)-&gt;rb), struct jffs2_node_frag, rb)
DECL|macro|frag_parent
mdefine_line|#define frag_parent(frag) rb_entry(rb_parent(&amp;(frag)-&gt;rb), struct jffs2_node_frag, rb)
DECL|macro|frag_left
mdefine_line|#define frag_left(frag) rb_entry((frag)-&gt;rb.rb_left, struct jffs2_node_frag, rb)
DECL|macro|frag_right
mdefine_line|#define frag_right(frag) rb_entry((frag)-&gt;rb.rb_right, struct jffs2_node_frag, rb)
DECL|macro|frag_erase
mdefine_line|#define frag_erase(frag, list) rb_erase(&amp;frag-&gt;rb, list);
multiline_comment|/* nodelist.c */
id|D1
c_func
(paren
r_void
id|jffs2_print_frag_list
c_func
(paren
r_struct
id|jffs2_inode_info
op_star
id|f
)paren
)paren
suffix:semicolon
r_void
id|jffs2_add_fd_to_list
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
comma
r_struct
id|jffs2_full_dirent
op_star
r_new
comma
r_struct
id|jffs2_full_dirent
op_star
op_star
id|list
)paren
suffix:semicolon
r_int
id|jffs2_get_inode_nodes
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
comma
r_struct
id|jffs2_inode_info
op_star
id|f
comma
r_struct
id|jffs2_tmp_dnode_info
op_star
op_star
id|tnp
comma
r_struct
id|jffs2_full_dirent
op_star
op_star
id|fdp
comma
r_uint32
op_star
id|highest_version
comma
r_uint32
op_star
id|latest_mctime
comma
r_uint32
op_star
id|mctime_ver
)paren
suffix:semicolon
r_void
id|jffs2_set_inocache_state
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
comma
r_struct
id|jffs2_inode_cache
op_star
id|ic
comma
r_int
id|state
)paren
suffix:semicolon
r_struct
id|jffs2_inode_cache
op_star
id|jffs2_get_ino_cache
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
comma
r_uint32
id|ino
)paren
suffix:semicolon
r_void
id|jffs2_add_ino_cache
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
comma
r_struct
id|jffs2_inode_cache
op_star
r_new
)paren
suffix:semicolon
r_void
id|jffs2_del_ino_cache
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
comma
r_struct
id|jffs2_inode_cache
op_star
id|old
)paren
suffix:semicolon
r_void
id|jffs2_free_ino_caches
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
)paren
suffix:semicolon
r_void
id|jffs2_free_raw_node_refs
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
)paren
suffix:semicolon
r_struct
id|jffs2_node_frag
op_star
id|jffs2_lookup_node_frag
c_func
(paren
r_struct
id|rb_root
op_star
id|fragtree
comma
r_uint32
id|offset
)paren
suffix:semicolon
r_void
id|jffs2_kill_fragtree
c_func
(paren
r_struct
id|rb_root
op_star
id|root
comma
r_struct
id|jffs2_sb_info
op_star
id|c_delete
)paren
suffix:semicolon
r_void
id|jffs2_fragtree_insert
c_func
(paren
r_struct
id|jffs2_node_frag
op_star
id|newfrag
comma
r_struct
id|jffs2_node_frag
op_star
id|base
)paren
suffix:semicolon
r_struct
id|rb_node
op_star
id|rb_next
c_func
(paren
r_struct
id|rb_node
op_star
)paren
suffix:semicolon
r_struct
id|rb_node
op_star
id|rb_prev
c_func
(paren
r_struct
id|rb_node
op_star
)paren
suffix:semicolon
r_void
id|rb_replace_node
c_func
(paren
r_struct
id|rb_node
op_star
id|victim
comma
r_struct
id|rb_node
op_star
r_new
comma
r_struct
id|rb_root
op_star
id|root
)paren
suffix:semicolon
multiline_comment|/* nodemgmt.c */
r_int
id|jffs2_thread_should_wake
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
)paren
suffix:semicolon
r_int
id|jffs2_reserve_space
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
comma
r_uint32
id|minsize
comma
r_uint32
op_star
id|ofs
comma
r_uint32
op_star
id|len
comma
r_int
id|prio
)paren
suffix:semicolon
r_int
id|jffs2_reserve_space_gc
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
comma
r_uint32
id|minsize
comma
r_uint32
op_star
id|ofs
comma
r_uint32
op_star
id|len
)paren
suffix:semicolon
r_int
id|jffs2_add_physical_node_ref
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
comma
r_struct
id|jffs2_raw_node_ref
op_star
r_new
)paren
suffix:semicolon
r_void
id|jffs2_complete_reservation
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
)paren
suffix:semicolon
r_void
id|jffs2_mark_node_obsolete
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
comma
r_struct
id|jffs2_raw_node_ref
op_star
id|raw
)paren
suffix:semicolon
r_void
id|jffs2_dump_block_lists
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
)paren
suffix:semicolon
multiline_comment|/* write.c */
r_int
id|jffs2_do_new_inode
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
comma
r_struct
id|jffs2_inode_info
op_star
id|f
comma
r_uint32
id|mode
comma
r_struct
id|jffs2_raw_inode
op_star
id|ri
)paren
suffix:semicolon
r_struct
id|jffs2_full_dnode
op_star
id|jffs2_write_dnode
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
comma
r_struct
id|jffs2_inode_info
op_star
id|f
comma
r_struct
id|jffs2_raw_inode
op_star
id|ri
comma
r_const
r_int
r_char
op_star
id|data
comma
r_uint32
id|datalen
comma
r_uint32
id|flash_ofs
comma
r_int
id|alloc_mode
)paren
suffix:semicolon
r_struct
id|jffs2_full_dirent
op_star
id|jffs2_write_dirent
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
comma
r_struct
id|jffs2_inode_info
op_star
id|f
comma
r_struct
id|jffs2_raw_dirent
op_star
id|rd
comma
r_const
r_int
r_char
op_star
id|name
comma
r_uint32
id|namelen
comma
r_uint32
id|flash_ofs
comma
r_int
id|alloc_mode
)paren
suffix:semicolon
r_int
id|jffs2_write_inode_range
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
comma
r_struct
id|jffs2_inode_info
op_star
id|f
comma
r_struct
id|jffs2_raw_inode
op_star
id|ri
comma
r_int
r_char
op_star
id|buf
comma
r_uint32
id|offset
comma
r_uint32
id|writelen
comma
r_uint32
op_star
id|retlen
)paren
suffix:semicolon
r_int
id|jffs2_do_create
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
comma
r_struct
id|jffs2_inode_info
op_star
id|dir_f
comma
r_struct
id|jffs2_inode_info
op_star
id|f
comma
r_struct
id|jffs2_raw_inode
op_star
id|ri
comma
r_const
r_char
op_star
id|name
comma
r_int
id|namelen
)paren
suffix:semicolon
r_int
id|jffs2_do_unlink
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
comma
r_struct
id|jffs2_inode_info
op_star
id|dir_f
comma
r_const
r_char
op_star
id|name
comma
r_int
id|namelen
comma
r_struct
id|jffs2_inode_info
op_star
id|dead_f
)paren
suffix:semicolon
r_int
id|jffs2_do_link
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
comma
r_struct
id|jffs2_inode_info
op_star
id|dir_f
comma
r_uint32
id|ino
comma
r_uint8
id|type
comma
r_const
r_char
op_star
id|name
comma
r_int
id|namelen
)paren
suffix:semicolon
multiline_comment|/* readinode.c */
r_void
id|jffs2_truncate_fraglist
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
comma
r_struct
id|rb_root
op_star
id|list
comma
r_uint32
id|size
)paren
suffix:semicolon
r_int
id|jffs2_add_full_dnode_to_inode
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
comma
r_struct
id|jffs2_inode_info
op_star
id|f
comma
r_struct
id|jffs2_full_dnode
op_star
id|fn
)paren
suffix:semicolon
r_int
id|jffs2_do_read_inode
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
comma
r_struct
id|jffs2_inode_info
op_star
id|f
comma
r_uint32
id|ino
comma
r_struct
id|jffs2_raw_inode
op_star
id|latest_node
)paren
suffix:semicolon
r_int
id|jffs2_do_crccheck_inode
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
comma
r_struct
id|jffs2_inode_cache
op_star
id|ic
)paren
suffix:semicolon
r_void
id|jffs2_do_clear_inode
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
comma
r_struct
id|jffs2_inode_info
op_star
id|f
)paren
suffix:semicolon
multiline_comment|/* malloc.c */
r_int
id|jffs2_create_slab_caches
c_func
(paren
r_void
)paren
suffix:semicolon
r_void
id|jffs2_destroy_slab_caches
c_func
(paren
r_void
)paren
suffix:semicolon
r_struct
id|jffs2_full_dirent
op_star
id|jffs2_alloc_full_dirent
c_func
(paren
r_int
id|namesize
)paren
suffix:semicolon
r_void
id|jffs2_free_full_dirent
c_func
(paren
r_struct
id|jffs2_full_dirent
op_star
)paren
suffix:semicolon
r_struct
id|jffs2_full_dnode
op_star
id|jffs2_alloc_full_dnode
c_func
(paren
r_void
)paren
suffix:semicolon
r_void
id|jffs2_free_full_dnode
c_func
(paren
r_struct
id|jffs2_full_dnode
op_star
)paren
suffix:semicolon
r_struct
id|jffs2_raw_dirent
op_star
id|jffs2_alloc_raw_dirent
c_func
(paren
r_void
)paren
suffix:semicolon
r_void
id|jffs2_free_raw_dirent
c_func
(paren
r_struct
id|jffs2_raw_dirent
op_star
)paren
suffix:semicolon
r_struct
id|jffs2_raw_inode
op_star
id|jffs2_alloc_raw_inode
c_func
(paren
r_void
)paren
suffix:semicolon
r_void
id|jffs2_free_raw_inode
c_func
(paren
r_struct
id|jffs2_raw_inode
op_star
)paren
suffix:semicolon
r_struct
id|jffs2_tmp_dnode_info
op_star
id|jffs2_alloc_tmp_dnode_info
c_func
(paren
r_void
)paren
suffix:semicolon
r_void
id|jffs2_free_tmp_dnode_info
c_func
(paren
r_struct
id|jffs2_tmp_dnode_info
op_star
)paren
suffix:semicolon
r_struct
id|jffs2_raw_node_ref
op_star
id|jffs2_alloc_raw_node_ref
c_func
(paren
r_void
)paren
suffix:semicolon
r_void
id|jffs2_free_raw_node_ref
c_func
(paren
r_struct
id|jffs2_raw_node_ref
op_star
)paren
suffix:semicolon
r_struct
id|jffs2_node_frag
op_star
id|jffs2_alloc_node_frag
c_func
(paren
r_void
)paren
suffix:semicolon
r_void
id|jffs2_free_node_frag
c_func
(paren
r_struct
id|jffs2_node_frag
op_star
)paren
suffix:semicolon
r_struct
id|jffs2_inode_cache
op_star
id|jffs2_alloc_inode_cache
c_func
(paren
r_void
)paren
suffix:semicolon
r_void
id|jffs2_free_inode_cache
c_func
(paren
r_struct
id|jffs2_inode_cache
op_star
)paren
suffix:semicolon
multiline_comment|/* gc.c */
r_int
id|jffs2_garbage_collect_pass
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
)paren
suffix:semicolon
multiline_comment|/* read.c */
r_int
id|jffs2_read_dnode
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
comma
r_struct
id|jffs2_inode_info
op_star
id|f
comma
r_struct
id|jffs2_full_dnode
op_star
id|fd
comma
r_int
r_char
op_star
id|buf
comma
r_int
id|ofs
comma
r_int
id|len
)paren
suffix:semicolon
r_int
id|jffs2_read_inode_range
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
comma
r_struct
id|jffs2_inode_info
op_star
id|f
comma
r_int
r_char
op_star
id|buf
comma
r_uint32
id|offset
comma
r_uint32
id|len
)paren
suffix:semicolon
r_char
op_star
id|jffs2_getlink
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
comma
r_struct
id|jffs2_inode_info
op_star
id|f
)paren
suffix:semicolon
multiline_comment|/* scan.c */
r_int
id|jffs2_scan_medium
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
)paren
suffix:semicolon
r_void
id|jffs2_rotate_lists
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
)paren
suffix:semicolon
multiline_comment|/* build.c */
r_int
id|jffs2_do_mount_fs
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
)paren
suffix:semicolon
multiline_comment|/* erase.c */
r_void
id|jffs2_erase_block
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
comma
r_struct
id|jffs2_eraseblock
op_star
id|jeb
)paren
suffix:semicolon
r_void
id|jffs2_erase_pending_blocks
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
comma
r_int
id|count
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_JFFS2_FS_NAND
multiline_comment|/* wbuf.c */
r_int
id|jffs2_flush_wbuf_gc
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
comma
r_uint32
id|ino
)paren
suffix:semicolon
r_int
id|jffs2_flush_wbuf_pad
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
)paren
suffix:semicolon
r_int
id|jffs2_check_nand_cleanmarker
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
comma
r_struct
id|jffs2_eraseblock
op_star
id|jeb
)paren
suffix:semicolon
r_int
id|jffs2_write_nand_cleanmarker
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
comma
r_struct
id|jffs2_eraseblock
op_star
id|jeb
)paren
suffix:semicolon
macro_line|#endif
macro_line|#endif /* __JFFS2_NODELIST_H__ */
eof
