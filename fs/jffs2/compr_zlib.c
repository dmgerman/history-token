multiline_comment|/*&n; * JFFS2 -- Journalling Flash File System, Version 2.&n; *&n; * Copyright (C) 2001 Red Hat, Inc.&n; *&n; * Created by David Woodhouse &lt;dwmw2@cambridge.redhat.com&gt;&n; *&n; * The original JFFS, from which the design for JFFS2 was derived,&n; * was designed and implemented by Axis Communications AB.&n; *&n; * The contents of this file are subject to the Red Hat eCos Public&n; * License Version 1.1 (the &quot;Licence&quot;); you may not use this file&n; * except in compliance with the Licence.  You may obtain a copy of&n; * the Licence at http://www.redhat.com/&n; *&n; * Software distributed under the Licence is distributed on an &quot;AS IS&quot;&n; * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.&n; * See the Licence for the specific language governing rights and&n; * limitations under the Licence.&n; *&n; * The Original Code is JFFS2 - Journalling Flash File System, version 2&n; *&n; * Alternatively, the contents of this file may be used under the&n; * terms of the GNU General Public License version 2 (the &quot;GPL&quot;), in&n; * which case the provisions of the GPL are applicable instead of the&n; * above.  If you wish to allow the use of your version of this file&n; * only under the terms of the GPL and not to allow others to use your&n; * version of this file under the RHEPL, indicate your decision by&n; * deleting the provisions above and replace them with the notice and&n; * other provisions required by the GPL.  If you do not delete the&n; * provisions above, a recipient may use your version of this file&n; * under either the RHEPL or the GPL.&n; *&n; * $Id: compr_zlib.c,v 1.6 2001/04/18 15:04:00 dwmw2 Exp $&n; *&n; */
macro_line|#include &quot;zlib.h&quot;
macro_line|#ifdef __KERNEL__
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/jffs2.h&gt;
macro_line|#include &quot;nodelist.h&quot;
DECL|function|zalloc
r_static
r_void
op_star
id|zalloc
c_func
(paren
r_void
op_star
id|opaque
comma
r_int
id|nr
comma
r_int
id|size
)paren
(brace
multiline_comment|/* How much does it request? Should we use vmalloc? Or be dynamic? */
r_return
id|kmalloc
c_func
(paren
id|nr
op_star
id|size
comma
id|GFP_KERNEL
)paren
suffix:semicolon
)brace
DECL|function|zfree
r_static
r_void
id|zfree
c_func
(paren
r_void
op_star
id|opaque
comma
r_void
op_star
id|addr
)paren
(brace
id|kfree
c_func
(paren
id|addr
)paren
suffix:semicolon
)brace
macro_line|#else
DECL|macro|min
mdefine_line|#define min(x,y) ((x)&lt;(y)?(x):(y))
macro_line|#ifndef D1
DECL|macro|D1
mdefine_line|#define D1(x)
macro_line|#endif
DECL|macro|KERN_DEBUG
mdefine_line|#define KERN_DEBUG
DECL|macro|KERN_NOTICE
mdefine_line|#define KERN_NOTICE
DECL|macro|KERN_WARNING
mdefine_line|#define KERN_WARNING
DECL|macro|printk
mdefine_line|#define printk printf
macro_line|#include &lt;stdio.h&gt;
macro_line|#include &lt;asm/types.h&gt;
macro_line|#endif
multiline_comment|/* Plan: call deflate() with avail_in == *sourcelen, &n;&t;&t;avail_out = *dstlen - 12 and flush == Z_FINISH. &n;&t;&t;If it doesn&squot;t manage to finish,&t;call it again with&n;&t;&t;avail_in == 0 and avail_out set to the remaining 12&n;&t;&t;bytes for it to clean up. &n;&t;   Q: Is 12 bytes sufficient?&n;&t;*/
DECL|macro|STREAM_END_SPACE
mdefine_line|#define STREAM_END_SPACE 12
DECL|function|zlib_compress
r_int
id|zlib_compress
c_func
(paren
r_int
r_char
op_star
id|data_in
comma
r_int
r_char
op_star
id|cpage_out
comma
id|__u32
op_star
id|sourcelen
comma
id|__u32
op_star
id|dstlen
)paren
(brace
id|z_stream
id|strm
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_if
c_cond
(paren
op_star
id|dstlen
op_le
id|STREAM_END_SPACE
)paren
r_return
op_minus
l_int|1
suffix:semicolon
macro_line|#ifdef __KERNEL__
id|strm.zalloc
op_assign
id|zalloc
suffix:semicolon
id|strm.zfree
op_assign
id|zfree
suffix:semicolon
macro_line|#else
id|strm.zalloc
op_assign
(paren
r_void
op_star
)paren
l_int|0
suffix:semicolon
id|strm.zfree
op_assign
(paren
r_void
op_star
)paren
l_int|0
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|Z_OK
op_ne
id|deflateInit
c_func
(paren
op_amp
id|strm
comma
l_int|3
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;deflateInit failed&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|strm.next_in
op_assign
id|data_in
suffix:semicolon
id|strm.total_in
op_assign
l_int|0
suffix:semicolon
id|strm.next_out
op_assign
id|cpage_out
suffix:semicolon
id|strm.total_out
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|strm.total_out
OL
op_star
id|dstlen
op_minus
id|STREAM_END_SPACE
op_logical_and
id|strm.total_in
OL
op_star
id|sourcelen
)paren
(brace
id|strm.avail_out
op_assign
op_star
id|dstlen
op_minus
(paren
id|strm.total_out
op_plus
id|STREAM_END_SPACE
)paren
suffix:semicolon
id|strm.avail_in
op_assign
id|min
c_func
(paren
op_star
id|sourcelen
op_minus
id|strm.total_in
comma
id|strm.avail_out
)paren
suffix:semicolon
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;calling deflate with avail_in %d, avail_out %d&bslash;n&quot;
comma
id|strm.avail_in
comma
id|strm.avail_out
)paren
)paren
suffix:semicolon
id|ret
op_assign
id|deflate
c_func
(paren
op_amp
id|strm
comma
id|Z_PARTIAL_FLUSH
)paren
suffix:semicolon
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;deflate returned with avail_in %d, avail_out %d, total_in %ld, total_out %ld&bslash;n&quot;
comma
id|strm.avail_in
comma
id|strm.avail_out
comma
id|strm.total_in
comma
id|strm.total_out
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
id|Z_OK
)paren
(brace
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;deflate in loop returned %d&bslash;n&quot;
comma
id|ret
)paren
)paren
suffix:semicolon
id|deflateEnd
c_func
(paren
op_amp
id|strm
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
)brace
id|strm.avail_out
op_add_assign
id|STREAM_END_SPACE
suffix:semicolon
id|strm.avail_in
op_assign
l_int|0
suffix:semicolon
id|ret
op_assign
id|deflate
c_func
(paren
op_amp
id|strm
comma
id|Z_FINISH
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
id|Z_STREAM_END
)paren
(brace
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;final deflate returned %d&bslash;n&quot;
comma
id|ret
)paren
)paren
suffix:semicolon
id|deflateEnd
c_func
(paren
op_amp
id|strm
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|deflateEnd
c_func
(paren
op_amp
id|strm
)paren
suffix:semicolon
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;zlib compressed %ld bytes into %ld&bslash;n&quot;
comma
id|strm.total_in
comma
id|strm.total_out
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|strm.total_out
op_ge
id|strm.total_in
)paren
r_return
op_minus
l_int|1
suffix:semicolon
op_star
id|dstlen
op_assign
id|strm.total_out
suffix:semicolon
op_star
id|sourcelen
op_assign
id|strm.total_in
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|zlib_decompress
r_void
id|zlib_decompress
c_func
(paren
r_int
r_char
op_star
id|data_in
comma
r_int
r_char
op_star
id|cpage_out
comma
id|__u32
id|srclen
comma
id|__u32
id|destlen
)paren
(brace
id|z_stream
id|strm
suffix:semicolon
r_int
id|ret
suffix:semicolon
macro_line|#ifdef __KERNEL__
id|strm.zalloc
op_assign
id|zalloc
suffix:semicolon
id|strm.zfree
op_assign
id|zfree
suffix:semicolon
macro_line|#else
id|strm.zalloc
op_assign
(paren
r_void
op_star
)paren
l_int|0
suffix:semicolon
id|strm.zfree
op_assign
(paren
r_void
op_star
)paren
l_int|0
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|Z_OK
op_ne
id|inflateInit
c_func
(paren
op_amp
id|strm
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;inflateInit failed&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|strm.next_in
op_assign
id|data_in
suffix:semicolon
id|strm.avail_in
op_assign
id|srclen
suffix:semicolon
id|strm.total_in
op_assign
l_int|0
suffix:semicolon
id|strm.next_out
op_assign
id|cpage_out
suffix:semicolon
id|strm.avail_out
op_assign
id|destlen
suffix:semicolon
id|strm.total_out
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
(paren
id|ret
op_assign
id|inflate
c_func
(paren
op_amp
id|strm
comma
id|Z_FINISH
)paren
)paren
op_eq
id|Z_OK
)paren
(brace
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ret
op_ne
id|Z_STREAM_END
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;inflate returned %d&bslash;n&quot;
comma
id|ret
)paren
suffix:semicolon
)brace
id|inflateEnd
c_func
(paren
op_amp
id|strm
)paren
suffix:semicolon
)brace
eof
