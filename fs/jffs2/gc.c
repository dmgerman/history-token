multiline_comment|/*&n; * JFFS2 -- Journalling Flash File System, Version 2.&n; *&n; * Copyright (C) 2001 Red Hat, Inc.&n; *&n; * Created by David Woodhouse &lt;dwmw2@cambridge.redhat.com&gt;&n; *&n; * The original JFFS, from which the design for JFFS2 was derived,&n; * was designed and implemented by Axis Communications AB.&n; *&n; * The contents of this file are subject to the Red Hat eCos Public&n; * License Version 1.1 (the &quot;Licence&quot;); you may not use this file&n; * except in compliance with the Licence.  You may obtain a copy of&n; * the Licence at http://www.redhat.com/&n; *&n; * Software distributed under the Licence is distributed on an &quot;AS IS&quot;&n; * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.&n; * See the Licence for the specific language governing rights and&n; * limitations under the Licence.&n; *&n; * The Original Code is JFFS2 - Journalling Flash File System, version 2&n; *&n; * Alternatively, the contents of this file may be used under the&n; * terms of the GNU General Public License version 2 (the &quot;GPL&quot;), in&n; * which case the provisions of the GPL are applicable instead of the&n; * above.  If you wish to allow the use of your version of this file&n; * only under the terms of the GPL and not to allow others to use your&n; * version of this file under the RHEPL, indicate your decision by&n; * deleting the provisions above and replace them with the notice and&n; * other provisions required by the GPL.  If you do not delete the&n; * provisions above, a recipient may use your version of this file&n; * under either the RHEPL or the GPL.&n; *&n; * $Id: gc.c,v 1.52 2001/09/19 21:53:47 dwmw2 Exp $&n; *&n; */
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/mtd/mtd.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/jffs2.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/pagemap.h&gt;
macro_line|#include &quot;nodelist.h&quot;
macro_line|#include &quot;crc32.h&quot;
r_static
r_int
id|jffs2_garbage_collect_metadata
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
comma
r_struct
id|jffs2_eraseblock
op_star
id|jeb
comma
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|jffs2_full_dnode
op_star
id|fd
)paren
suffix:semicolon
r_static
r_int
id|jffs2_garbage_collect_dirent
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
comma
r_struct
id|jffs2_eraseblock
op_star
id|jeb
comma
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|jffs2_full_dirent
op_star
id|fd
)paren
suffix:semicolon
r_static
r_int
id|jffs2_garbage_collect_deletion_dirent
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
comma
r_struct
id|jffs2_eraseblock
op_star
id|jeb
comma
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|jffs2_full_dirent
op_star
id|fd
)paren
suffix:semicolon
r_static
r_int
id|jffs2_garbage_collect_hole
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
comma
r_struct
id|jffs2_eraseblock
op_star
id|jeb
comma
r_struct
id|inode
op_star
id|indeo
comma
r_struct
id|jffs2_full_dnode
op_star
id|fn
comma
id|__u32
id|start
comma
id|__u32
id|end
)paren
suffix:semicolon
r_static
r_int
id|jffs2_garbage_collect_dnode
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
comma
r_struct
id|jffs2_eraseblock
op_star
id|jeb
comma
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|jffs2_full_dnode
op_star
id|fn
comma
id|__u32
id|start
comma
id|__u32
id|end
)paren
suffix:semicolon
multiline_comment|/* Called with erase_completion_lock held */
DECL|function|jffs2_find_gc_block
r_static
r_struct
id|jffs2_eraseblock
op_star
id|jffs2_find_gc_block
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
)paren
(brace
r_struct
id|jffs2_eraseblock
op_star
id|ret
suffix:semicolon
r_struct
id|list_head
op_star
id|nextlist
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Pick an eraseblock to garbage collect next. This is where we&squot;ll&n;&t;   put the clever wear-levelling algorithms. Eventually.  */
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|c-&gt;bad_used_list
)paren
op_logical_and
id|c-&gt;nr_free_blocks
OG
id|JFFS2_RESERVED_BLOCKS_GCBAD
)paren
(brace
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Picking block from bad_used_list to GC next&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|nextlist
op_assign
op_amp
id|c-&gt;bad_used_list
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|jiffies
op_mod
l_int|100
op_logical_and
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|c-&gt;dirty_list
)paren
)paren
(brace
multiline_comment|/* Most of the time, pick one off the dirty list */
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Picking block from dirty_list to GC next&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|nextlist
op_assign
op_amp
id|c-&gt;dirty_list
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|c-&gt;clean_list
)paren
)paren
(brace
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Picking block from clean_list to GC next&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|nextlist
op_assign
op_amp
id|c-&gt;clean_list
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|c-&gt;dirty_list
)paren
)paren
(brace
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Picking block from dirty_list to GC next (clean_list was empty)&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|nextlist
op_assign
op_amp
id|c-&gt;dirty_list
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Eep. Both were empty */
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;jffs2: No clean _or_ dirty blocks to GC from! Where are they all?&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|ret
op_assign
id|list_entry
c_func
(paren
id|nextlist-&gt;next
comma
r_struct
id|jffs2_eraseblock
comma
id|list
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|ret-&gt;list
)paren
suffix:semicolon
id|c-&gt;gcblock
op_assign
id|ret
suffix:semicolon
id|ret-&gt;gc_node
op_assign
id|ret-&gt;first_node
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ret-&gt;gc_node
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Eep. ret-&gt;gc_node for block at 0x%08x is NULL&bslash;n&quot;
comma
id|ret-&gt;offset
)paren
suffix:semicolon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* jffs2_garbage_collect_pass&n; * Make a single attempt to progress GC. Move one node, and possibly&n; * start erasing one eraseblock.&n; */
DECL|function|jffs2_garbage_collect_pass
r_int
id|jffs2_garbage_collect_pass
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
)paren
(brace
r_struct
id|jffs2_eraseblock
op_star
id|jeb
suffix:semicolon
r_struct
id|jffs2_inode_info
op_star
id|f
suffix:semicolon
r_struct
id|jffs2_raw_node_ref
op_star
id|raw
suffix:semicolon
r_struct
id|jffs2_node_frag
op_star
id|frag
suffix:semicolon
r_struct
id|jffs2_full_dnode
op_star
id|fn
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|jffs2_full_dirent
op_star
id|fd
suffix:semicolon
id|__u32
id|start
op_assign
l_int|0
comma
id|end
op_assign
l_int|0
comma
id|nrfrags
op_assign
l_int|0
suffix:semicolon
id|__u32
id|inum
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|down_interruptible
c_func
(paren
op_amp
id|c-&gt;alloc_sem
)paren
)paren
r_return
op_minus
id|EINTR
suffix:semicolon
id|spin_lock_bh
c_func
(paren
op_amp
id|c-&gt;erase_completion_lock
)paren
suffix:semicolon
multiline_comment|/* First, work out which block we&squot;re garbage-collecting */
id|jeb
op_assign
id|c-&gt;gcblock
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|jeb
)paren
id|jeb
op_assign
id|jffs2_find_gc_block
c_func
(paren
id|c
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|jeb
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;jffs2: Couldn&squot;t find erase block to garbage collect!&bslash;n&quot;
)paren
suffix:semicolon
id|spin_unlock_bh
c_func
(paren
op_amp
id|c-&gt;erase_completion_lock
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|c-&gt;alloc_sem
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;garbage collect from block at phys 0x%08x&bslash;n&quot;
comma
id|jeb-&gt;offset
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|jeb-&gt;used_size
)paren
r_goto
id|eraseit
suffix:semicolon
id|raw
op_assign
id|jeb-&gt;gc_node
suffix:semicolon
r_while
c_loop
(paren
id|raw-&gt;flash_offset
op_amp
l_int|1
)paren
(brace
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Node at 0x%08x is obsolete... skipping&bslash;n&quot;
comma
id|raw-&gt;flash_offset
op_amp
op_complement
l_int|3
)paren
)paren
suffix:semicolon
id|jeb-&gt;gc_node
op_assign
id|raw
op_assign
id|raw-&gt;next_phys
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|raw
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;eep. End of raw list while still supposedly nodes to GC&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;erase block at 0x%08x. free_size 0x%08x, dirty_size 0x%08x, used_size 0x%08x&bslash;n&quot;
comma
id|jeb-&gt;offset
comma
id|jeb-&gt;free_size
comma
id|jeb-&gt;dirty_size
comma
id|jeb-&gt;used_size
)paren
suffix:semicolon
id|spin_unlock_bh
c_func
(paren
op_amp
id|c-&gt;erase_completion_lock
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|c-&gt;alloc_sem
)paren
suffix:semicolon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Going to garbage collect node at 0x%08x&bslash;n&quot;
comma
id|raw-&gt;flash_offset
op_amp
op_complement
l_int|3
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|raw-&gt;next_in_ino
)paren
(brace
multiline_comment|/* Inode-less node. Clean marker, snapshot or something like that */
id|spin_unlock_bh
c_func
(paren
op_amp
id|c-&gt;erase_completion_lock
)paren
suffix:semicolon
id|jffs2_mark_node_obsolete
c_func
(paren
id|c
comma
id|raw
)paren
suffix:semicolon
r_goto
id|eraseit_lock
suffix:semicolon
)brace
id|inum
op_assign
id|jffs2_raw_ref_to_inum
c_func
(paren
id|raw
)paren
suffix:semicolon
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Inode number is #%u&bslash;n&quot;
comma
id|inum
)paren
)paren
suffix:semicolon
id|spin_unlock_bh
c_func
(paren
op_amp
id|c-&gt;erase_completion_lock
)paren
suffix:semicolon
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;jffs2_garbage_collect_pass collecting from block @0x%08x. Node @0x%08x, ino #%u&bslash;n&quot;
comma
id|jeb-&gt;offset
comma
id|raw-&gt;flash_offset
op_amp
op_complement
l_int|3
comma
id|inum
)paren
)paren
suffix:semicolon
id|inode
op_assign
id|iget
c_func
(paren
id|OFNI_BS_2SFFJ
c_func
(paren
id|c
)paren
comma
id|inum
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_bad_inode
c_func
(paren
id|inode
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;Eep. read_inode() failed for ino #%u&bslash;n&quot;
comma
id|inum
)paren
suffix:semicolon
multiline_comment|/* NB. This will happen again. We need to do something appropriate here. */
id|iput
c_func
(paren
id|inode
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|c-&gt;alloc_sem
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|f
op_assign
id|JFFS2_INODE_INFO
c_func
(paren
id|inode
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|f-&gt;sem
)paren
suffix:semicolon
multiline_comment|/* Now we have the lock for this inode. Check that it&squot;s still the one at the head&n;&t;   of the list. */
r_if
c_cond
(paren
id|raw-&gt;flash_offset
op_amp
l_int|1
)paren
(brace
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;node to be GC&squot;d was obsoleted in the meantime.&bslash;n&quot;
)paren
)paren
suffix:semicolon
multiline_comment|/* They&squot;ll call again */
r_goto
id|upnout
suffix:semicolon
)brace
multiline_comment|/* OK. Looks safe. And nobody can get us now because we have the semaphore. Move the block */
r_if
c_cond
(paren
id|f-&gt;metadata
op_logical_and
id|f-&gt;metadata-&gt;raw
op_eq
id|raw
)paren
(brace
id|fn
op_assign
id|f-&gt;metadata
suffix:semicolon
id|ret
op_assign
id|jffs2_garbage_collect_metadata
c_func
(paren
id|c
comma
id|jeb
comma
id|inode
comma
id|fn
)paren
suffix:semicolon
r_goto
id|upnout
suffix:semicolon
)brace
r_for
c_loop
(paren
id|frag
op_assign
id|f-&gt;fraglist
suffix:semicolon
id|frag
suffix:semicolon
id|frag
op_assign
id|frag-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|frag-&gt;node
op_logical_and
id|frag-&gt;node-&gt;raw
op_eq
id|raw
)paren
(brace
id|fn
op_assign
id|frag-&gt;node
suffix:semicolon
id|end
op_assign
id|frag-&gt;ofs
op_plus
id|frag-&gt;size
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|nrfrags
op_increment
)paren
id|start
op_assign
id|frag-&gt;ofs
suffix:semicolon
r_if
c_cond
(paren
id|nrfrags
op_eq
id|frag-&gt;node-&gt;frags
)paren
r_break
suffix:semicolon
multiline_comment|/* We&squot;ve found them all */
)brace
)brace
r_if
c_cond
(paren
id|fn
)paren
(brace
multiline_comment|/* We found a datanode. Do the GC */
r_if
c_cond
(paren
(paren
id|start
op_rshift
id|PAGE_CACHE_SHIFT
)paren
OL
(paren
(paren
id|end
op_minus
l_int|1
)paren
op_rshift
id|PAGE_CACHE_SHIFT
)paren
)paren
(brace
multiline_comment|/* It crosses a page boundary. Therefore, it must be a hole. */
id|ret
op_assign
id|jffs2_garbage_collect_hole
c_func
(paren
id|c
comma
id|jeb
comma
id|inode
comma
id|fn
comma
id|start
comma
id|end
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* It could still be a hole. But we GC the page this way anyway */
id|ret
op_assign
id|jffs2_garbage_collect_dnode
c_func
(paren
id|c
comma
id|jeb
comma
id|inode
comma
id|fn
comma
id|start
comma
id|end
)paren
suffix:semicolon
)brace
r_goto
id|upnout
suffix:semicolon
)brace
multiline_comment|/* Wasn&squot;t a dnode. Try dirent */
r_for
c_loop
(paren
id|fd
op_assign
id|f-&gt;dents
suffix:semicolon
id|fd
suffix:semicolon
id|fd
op_assign
id|fd-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|fd-&gt;raw
op_eq
id|raw
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|fd
op_logical_and
id|fd-&gt;ino
)paren
(brace
id|ret
op_assign
id|jffs2_garbage_collect_dirent
c_func
(paren
id|c
comma
id|jeb
comma
id|inode
comma
id|fd
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|fd
)paren
(brace
id|ret
op_assign
id|jffs2_garbage_collect_deletion_dirent
c_func
(paren
id|c
comma
id|jeb
comma
id|inode
comma
id|fd
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Raw node at 0x%08x wasn&squot;t in node lists for ino #%lu&bslash;n&quot;
comma
id|raw-&gt;flash_offset
op_amp
op_complement
l_int|3
comma
id|inode-&gt;i_ino
)paren
suffix:semicolon
r_if
c_cond
(paren
id|raw-&gt;flash_offset
op_amp
l_int|1
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;But it&squot;s obsolete so we don&squot;t mind too much&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|ret
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
)brace
id|upnout
suffix:colon
id|up
c_func
(paren
op_amp
id|f-&gt;sem
)paren
suffix:semicolon
id|iput
c_func
(paren
id|inode
)paren
suffix:semicolon
id|eraseit_lock
suffix:colon
multiline_comment|/* If we&squot;ve finished this block, start it erasing */
id|spin_lock_bh
c_func
(paren
op_amp
id|c-&gt;erase_completion_lock
)paren
suffix:semicolon
id|eraseit
suffix:colon
r_if
c_cond
(paren
id|c-&gt;gcblock
op_logical_and
op_logical_neg
id|c-&gt;gcblock-&gt;used_size
)paren
(brace
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Block at 0x%08x completely obsoleted by GC. Moving to erase_pending_list&bslash;n&quot;
comma
id|c-&gt;gcblock-&gt;offset
)paren
)paren
suffix:semicolon
multiline_comment|/* We&squot;re GC&squot;ing an empty block? */
id|list_add_tail
c_func
(paren
op_amp
id|c-&gt;gcblock-&gt;list
comma
op_amp
id|c-&gt;erase_pending_list
)paren
suffix:semicolon
id|c-&gt;gcblock
op_assign
l_int|NULL
suffix:semicolon
id|c-&gt;nr_erasing_blocks
op_increment
suffix:semicolon
id|jffs2_erase_pending_trigger
c_func
(paren
id|c
)paren
suffix:semicolon
)brace
id|spin_unlock_bh
c_func
(paren
op_amp
id|c-&gt;erase_completion_lock
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|c-&gt;alloc_sem
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|jffs2_garbage_collect_metadata
r_static
r_int
id|jffs2_garbage_collect_metadata
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
comma
r_struct
id|jffs2_eraseblock
op_star
id|jeb
comma
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|jffs2_full_dnode
op_star
id|fn
)paren
(brace
r_struct
id|jffs2_inode_info
op_star
id|f
op_assign
id|JFFS2_INODE_INFO
c_func
(paren
id|inode
)paren
suffix:semicolon
r_struct
id|jffs2_full_dnode
op_star
id|new_fn
suffix:semicolon
r_struct
id|jffs2_raw_inode
id|ri
suffix:semicolon
r_int
r_int
id|dev
suffix:semicolon
r_char
op_star
id|mdata
op_assign
l_int|NULL
comma
id|mdatalen
op_assign
l_int|0
suffix:semicolon
id|__u32
id|alloclen
comma
id|phys_ofs
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_if
c_cond
(paren
(paren
id|inode-&gt;i_mode
op_amp
id|S_IFMT
)paren
op_eq
id|S_IFBLK
op_logical_or
(paren
id|inode-&gt;i_mode
op_amp
id|S_IFMT
)paren
op_eq
id|S_IFCHR
)paren
(brace
multiline_comment|/* For these, we don&squot;t actually need to read the old node */
id|dev
op_assign
(paren
id|major
c_func
(paren
id|inode-&gt;i_rdev
)paren
op_lshift
l_int|8
)paren
op_or
id|minor
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
id|mdata
op_assign
(paren
r_char
op_star
)paren
op_amp
id|dev
suffix:semicolon
id|mdatalen
op_assign
r_sizeof
(paren
id|dev
)paren
suffix:semicolon
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;jffs2_garbage_collect_metadata(): Writing %d bytes of kdev_t&bslash;n&quot;
comma
id|mdatalen
)paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|inode-&gt;i_mode
op_amp
id|S_IFMT
)paren
op_eq
id|S_IFLNK
)paren
(brace
id|mdatalen
op_assign
id|fn-&gt;size
suffix:semicolon
id|mdata
op_assign
id|kmalloc
c_func
(paren
id|fn-&gt;size
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mdata
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;kmalloc of mdata failed in jffs2_garbage_collect_metadata()&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|ret
op_assign
id|jffs2_read_dnode
c_func
(paren
id|c
comma
id|fn
comma
id|mdata
comma
l_int|0
comma
id|mdatalen
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;read of old metadata failed in jffs2_garbage_collect_metadata(): %d&bslash;n&quot;
comma
id|ret
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|mdata
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;jffs2_garbage_collect_metadata(): Writing %d bites of symlink target&bslash;n&quot;
comma
id|mdatalen
)paren
)paren
suffix:semicolon
)brace
id|ret
op_assign
id|jffs2_reserve_space_gc
c_func
(paren
id|c
comma
r_sizeof
(paren
id|ri
)paren
op_plus
id|mdatalen
comma
op_amp
id|phys_ofs
comma
op_amp
id|alloclen
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;jffs2_reserve_space_gc of %d bytes for garbage_collect_metadata failed: %d&bslash;n&quot;
comma
r_sizeof
(paren
id|ri
)paren
op_plus
id|mdatalen
comma
id|ret
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|memset
c_func
(paren
op_amp
id|ri
comma
l_int|0
comma
r_sizeof
(paren
id|ri
)paren
)paren
suffix:semicolon
id|ri.magic
op_assign
id|JFFS2_MAGIC_BITMASK
suffix:semicolon
id|ri.nodetype
op_assign
id|JFFS2_NODETYPE_INODE
suffix:semicolon
id|ri.totlen
op_assign
r_sizeof
(paren
id|ri
)paren
op_plus
id|mdatalen
suffix:semicolon
id|ri.hdr_crc
op_assign
id|crc32
c_func
(paren
l_int|0
comma
op_amp
id|ri
comma
r_sizeof
(paren
r_struct
id|jffs2_unknown_node
)paren
op_minus
l_int|4
)paren
suffix:semicolon
id|ri.ino
op_assign
id|inode-&gt;i_ino
suffix:semicolon
id|ri.version
op_assign
op_increment
id|f-&gt;highest_version
suffix:semicolon
id|ri.mode
op_assign
id|inode-&gt;i_mode
suffix:semicolon
id|ri.uid
op_assign
id|inode-&gt;i_uid
suffix:semicolon
id|ri.gid
op_assign
id|inode-&gt;i_gid
suffix:semicolon
id|ri.isize
op_assign
id|inode-&gt;i_size
suffix:semicolon
id|ri.atime
op_assign
id|inode-&gt;i_atime
suffix:semicolon
id|ri.ctime
op_assign
id|inode-&gt;i_ctime
suffix:semicolon
id|ri.mtime
op_assign
id|inode-&gt;i_mtime
suffix:semicolon
id|ri.offset
op_assign
l_int|0
suffix:semicolon
id|ri.csize
op_assign
id|mdatalen
suffix:semicolon
id|ri.dsize
op_assign
id|mdatalen
suffix:semicolon
id|ri.compr
op_assign
id|JFFS2_COMPR_NONE
suffix:semicolon
id|ri.node_crc
op_assign
id|crc32
c_func
(paren
l_int|0
comma
op_amp
id|ri
comma
r_sizeof
(paren
id|ri
)paren
op_minus
l_int|8
)paren
suffix:semicolon
id|ri.data_crc
op_assign
id|crc32
c_func
(paren
l_int|0
comma
id|mdata
comma
id|mdatalen
)paren
suffix:semicolon
id|new_fn
op_assign
id|jffs2_write_dnode
c_func
(paren
id|inode
comma
op_amp
id|ri
comma
id|mdata
comma
id|mdatalen
comma
id|phys_ofs
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|new_fn
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Error writing new dnode: %ld&bslash;n&quot;
comma
id|PTR_ERR
c_func
(paren
id|new_fn
)paren
)paren
suffix:semicolon
id|ret
op_assign
id|PTR_ERR
c_func
(paren
id|new_fn
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|jffs2_mark_node_obsolete
c_func
(paren
id|c
comma
id|fn-&gt;raw
)paren
suffix:semicolon
id|jffs2_free_full_dnode
c_func
(paren
id|fn
)paren
suffix:semicolon
id|f-&gt;metadata
op_assign
id|new_fn
suffix:semicolon
id|out
suffix:colon
r_if
c_cond
(paren
(paren
id|inode-&gt;i_mode
op_amp
id|S_IFMT
)paren
op_eq
id|S_IFLNK
)paren
id|kfree
c_func
(paren
id|mdata
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|jffs2_garbage_collect_dirent
r_static
r_int
id|jffs2_garbage_collect_dirent
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
comma
r_struct
id|jffs2_eraseblock
op_star
id|jeb
comma
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|jffs2_full_dirent
op_star
id|fd
)paren
(brace
r_struct
id|jffs2_inode_info
op_star
id|f
op_assign
id|JFFS2_INODE_INFO
c_func
(paren
id|inode
)paren
suffix:semicolon
r_struct
id|jffs2_full_dirent
op_star
id|new_fd
suffix:semicolon
r_struct
id|jffs2_raw_dirent
id|rd
suffix:semicolon
id|__u32
id|alloclen
comma
id|phys_ofs
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|rd.magic
op_assign
id|JFFS2_MAGIC_BITMASK
suffix:semicolon
id|rd.nodetype
op_assign
id|JFFS2_NODETYPE_DIRENT
suffix:semicolon
id|rd.nsize
op_assign
id|strlen
c_func
(paren
id|fd-&gt;name
)paren
suffix:semicolon
id|rd.totlen
op_assign
r_sizeof
(paren
id|rd
)paren
op_plus
id|rd.nsize
suffix:semicolon
id|rd.hdr_crc
op_assign
id|crc32
c_func
(paren
l_int|0
comma
op_amp
id|rd
comma
r_sizeof
(paren
r_struct
id|jffs2_unknown_node
)paren
op_minus
l_int|4
)paren
suffix:semicolon
id|rd.pino
op_assign
id|inode-&gt;i_ino
suffix:semicolon
id|rd.version
op_assign
op_increment
id|f-&gt;highest_version
suffix:semicolon
id|rd.ino
op_assign
id|fd-&gt;ino
suffix:semicolon
id|rd.mctime
op_assign
id|max
c_func
(paren
id|inode-&gt;i_mtime
comma
id|inode-&gt;i_ctime
)paren
suffix:semicolon
id|rd.type
op_assign
id|fd-&gt;type
suffix:semicolon
id|rd.node_crc
op_assign
id|crc32
c_func
(paren
l_int|0
comma
op_amp
id|rd
comma
r_sizeof
(paren
id|rd
)paren
op_minus
l_int|8
)paren
suffix:semicolon
id|rd.name_crc
op_assign
id|crc32
c_func
(paren
l_int|0
comma
id|fd-&gt;name
comma
id|rd.nsize
)paren
suffix:semicolon
id|ret
op_assign
id|jffs2_reserve_space_gc
c_func
(paren
id|c
comma
r_sizeof
(paren
id|rd
)paren
op_plus
id|rd.nsize
comma
op_amp
id|phys_ofs
comma
op_amp
id|alloclen
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;jffs2_reserve_space_gc of %d bytes for garbage_collect_dirent failed: %d&bslash;n&quot;
comma
r_sizeof
(paren
id|rd
)paren
op_plus
id|rd.nsize
comma
id|ret
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
id|new_fd
op_assign
id|jffs2_write_dirent
c_func
(paren
id|inode
comma
op_amp
id|rd
comma
id|fd-&gt;name
comma
id|rd.nsize
comma
id|phys_ofs
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|new_fd
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;jffs2_write_dirent in garbage_collect_dirent failed: %ld&bslash;n&quot;
comma
id|PTR_ERR
c_func
(paren
id|new_fd
)paren
)paren
suffix:semicolon
r_return
id|PTR_ERR
c_func
(paren
id|new_fd
)paren
suffix:semicolon
)brace
id|jffs2_add_fd_to_list
c_func
(paren
id|c
comma
id|new_fd
comma
op_amp
id|f-&gt;dents
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|jffs2_garbage_collect_deletion_dirent
r_static
r_int
id|jffs2_garbage_collect_deletion_dirent
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
comma
r_struct
id|jffs2_eraseblock
op_star
id|jeb
comma
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|jffs2_full_dirent
op_star
id|fd
)paren
(brace
r_struct
id|jffs2_inode_info
op_star
id|f
op_assign
id|JFFS2_INODE_INFO
c_func
(paren
id|inode
)paren
suffix:semicolon
r_struct
id|jffs2_full_dirent
op_star
op_star
id|fdp
op_assign
op_amp
id|f-&gt;dents
suffix:semicolon
r_int
id|found
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* FIXME: When we run on NAND flash, we need to work out whether&n;&t;   this deletion dirent is still needed to actively delete a&n;&t;   &squot;real&squot; dirent with the same name that&squot;s still somewhere else&n;&t;   on the flash. For now, we know that we&squot;ve actually obliterated&n;&t;   all the older dirents when they became obsolete, so we didn&squot;t&n;&t;   really need to write the deletion to flash in the first place.&n;&t;*/
r_while
c_loop
(paren
op_star
id|fdp
)paren
(brace
r_if
c_cond
(paren
(paren
op_star
id|fdp
)paren
op_eq
id|fd
)paren
(brace
id|found
op_assign
l_int|1
suffix:semicolon
op_star
id|fdp
op_assign
id|fd-&gt;next
suffix:semicolon
r_break
suffix:semicolon
)brace
id|fdp
op_assign
op_amp
(paren
op_star
id|fdp
)paren
op_member_access_from_pointer
id|next
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|found
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Deletion dirent &bslash;&quot;%s&bslash;&quot; not found in list for ino #%lu&bslash;n&quot;
comma
id|fd-&gt;name
comma
id|inode-&gt;i_ino
)paren
suffix:semicolon
)brace
id|jffs2_mark_node_obsolete
c_func
(paren
id|c
comma
id|fd-&gt;raw
)paren
suffix:semicolon
id|jffs2_free_full_dirent
c_func
(paren
id|fd
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|jffs2_garbage_collect_hole
r_static
r_int
id|jffs2_garbage_collect_hole
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
comma
r_struct
id|jffs2_eraseblock
op_star
id|jeb
comma
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|jffs2_full_dnode
op_star
id|fn
comma
id|__u32
id|start
comma
id|__u32
id|end
)paren
(brace
r_struct
id|jffs2_inode_info
op_star
id|f
op_assign
id|JFFS2_INODE_INFO
c_func
(paren
id|inode
)paren
suffix:semicolon
r_struct
id|jffs2_raw_inode
id|ri
suffix:semicolon
r_struct
id|jffs2_node_frag
op_star
id|frag
suffix:semicolon
r_struct
id|jffs2_full_dnode
op_star
id|new_fn
suffix:semicolon
id|__u32
id|alloclen
comma
id|phys_ofs
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Writing replacement hole node for ino #%lu from offset 0x%x to 0x%x&bslash;n&quot;
comma
id|inode-&gt;i_ino
comma
id|start
comma
id|end
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|ri
comma
l_int|0
comma
r_sizeof
(paren
id|ri
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fn-&gt;frags
OG
l_int|1
)paren
(brace
r_int
id|readlen
suffix:semicolon
id|__u32
id|crc
suffix:semicolon
multiline_comment|/* It&squot;s partially obsoleted by a later write. So we have to &n;&t;&t;   write it out again with the _same_ version as before */
id|ret
op_assign
id|c-&gt;mtd
op_member_access_from_pointer
id|read
c_func
(paren
id|c-&gt;mtd
comma
id|fn-&gt;raw-&gt;flash_offset
op_amp
op_complement
l_int|3
comma
r_sizeof
(paren
id|ri
)paren
comma
op_amp
id|readlen
comma
(paren
r_char
op_star
)paren
op_amp
id|ri
)paren
suffix:semicolon
r_if
c_cond
(paren
id|readlen
op_ne
r_sizeof
(paren
id|ri
)paren
op_logical_or
id|ret
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Node read failed in jffs2_garbage_collect_hole. Ret %d, retlen %d. Data will be lost by writing new hold node&bslash;n&quot;
comma
id|ret
comma
id|readlen
)paren
suffix:semicolon
r_goto
id|fill
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ri.nodetype
op_ne
id|JFFS2_NODETYPE_INODE
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;jffs2_garbage_collect_hole: Node at 0x%08x had node type 0x%04x instead of JFFS2_NODETYPE_INODE(0x%04x)&bslash;n&quot;
comma
id|fn-&gt;raw-&gt;flash_offset
op_amp
op_complement
l_int|3
comma
id|ri.nodetype
comma
id|JFFS2_NODETYPE_INODE
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ri.totlen
op_ne
r_sizeof
(paren
id|ri
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;jffs2_garbage_collect_hole: Node at 0x%08x had totlen 0x%x instead of expected 0x%x&bslash;n&quot;
comma
id|fn-&gt;raw-&gt;flash_offset
op_amp
op_complement
l_int|3
comma
id|ri.totlen
comma
r_sizeof
(paren
id|ri
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|crc
op_assign
id|crc32
c_func
(paren
l_int|0
comma
op_amp
id|ri
comma
r_sizeof
(paren
id|ri
)paren
op_minus
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
id|crc
op_ne
id|ri.node_crc
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;jffs2_garbage_collect_hole: Node at 0x%08x had CRC 0x%08x which doesn&squot;t match calculated CRC 0x%08x&bslash;n&quot;
comma
id|fn-&gt;raw-&gt;flash_offset
op_amp
op_complement
l_int|3
comma
id|ri.node_crc
comma
id|crc
)paren
suffix:semicolon
multiline_comment|/* FIXME: We could possibly deal with this by writing new holes for each frag */
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Data in the range 0x%08x to 0x%08x of inode #%lu will be lost&bslash;n&quot;
comma
id|start
comma
id|end
comma
id|inode-&gt;i_ino
)paren
suffix:semicolon
r_goto
id|fill
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ri.compr
op_ne
id|JFFS2_COMPR_ZERO
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;jffs2_garbage_collect_hole: Node 0x%08x wasn&squot;t a hole node!&bslash;n&quot;
comma
id|fn-&gt;raw-&gt;flash_offset
op_amp
op_complement
l_int|3
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Data in the range 0x%08x to 0x%08x of inode #%lu will be lost&bslash;n&quot;
comma
id|start
comma
id|end
comma
id|inode-&gt;i_ino
)paren
suffix:semicolon
r_goto
id|fill
suffix:semicolon
)brace
)brace
r_else
(brace
id|fill
suffix:colon
id|ri.magic
op_assign
id|JFFS2_MAGIC_BITMASK
suffix:semicolon
id|ri.nodetype
op_assign
id|JFFS2_NODETYPE_INODE
suffix:semicolon
id|ri.totlen
op_assign
r_sizeof
(paren
id|ri
)paren
suffix:semicolon
id|ri.hdr_crc
op_assign
id|crc32
c_func
(paren
l_int|0
comma
op_amp
id|ri
comma
r_sizeof
(paren
r_struct
id|jffs2_unknown_node
)paren
op_minus
l_int|4
)paren
suffix:semicolon
id|ri.ino
op_assign
id|inode-&gt;i_ino
suffix:semicolon
id|ri.version
op_assign
op_increment
id|f-&gt;highest_version
suffix:semicolon
id|ri.offset
op_assign
id|start
suffix:semicolon
id|ri.csize
op_assign
id|end
op_minus
id|start
suffix:semicolon
id|ri.dsize
op_assign
l_int|0
suffix:semicolon
id|ri.compr
op_assign
id|JFFS2_COMPR_ZERO
suffix:semicolon
)brace
id|ri.mode
op_assign
id|inode-&gt;i_mode
suffix:semicolon
id|ri.uid
op_assign
id|inode-&gt;i_uid
suffix:semicolon
id|ri.gid
op_assign
id|inode-&gt;i_gid
suffix:semicolon
id|ri.isize
op_assign
id|inode-&gt;i_size
suffix:semicolon
id|ri.atime
op_assign
id|inode-&gt;i_atime
suffix:semicolon
id|ri.ctime
op_assign
id|inode-&gt;i_ctime
suffix:semicolon
id|ri.mtime
op_assign
id|inode-&gt;i_mtime
suffix:semicolon
id|ri.data_crc
op_assign
l_int|0
suffix:semicolon
id|ri.node_crc
op_assign
id|crc32
c_func
(paren
l_int|0
comma
op_amp
id|ri
comma
r_sizeof
(paren
id|ri
)paren
op_minus
l_int|8
)paren
suffix:semicolon
id|ret
op_assign
id|jffs2_reserve_space_gc
c_func
(paren
id|c
comma
r_sizeof
(paren
id|ri
)paren
comma
op_amp
id|phys_ofs
comma
op_amp
id|alloclen
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;jffs2_reserve_space_gc of %d bytes for garbage_collect_hole failed: %d&bslash;n&quot;
comma
r_sizeof
(paren
id|ri
)paren
comma
id|ret
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
id|new_fn
op_assign
id|jffs2_write_dnode
c_func
(paren
id|inode
comma
op_amp
id|ri
comma
l_int|NULL
comma
l_int|0
comma
id|phys_ofs
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|new_fn
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Error writing new hole node: %ld&bslash;n&quot;
comma
id|PTR_ERR
c_func
(paren
id|new_fn
)paren
)paren
suffix:semicolon
r_return
id|PTR_ERR
c_func
(paren
id|new_fn
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ri.version
op_eq
id|f-&gt;highest_version
)paren
(brace
id|jffs2_add_full_dnode_to_inode
c_func
(paren
id|c
comma
id|f
comma
id|new_fn
)paren
suffix:semicolon
r_if
c_cond
(paren
id|f-&gt;metadata
)paren
(brace
id|jffs2_mark_node_obsolete
c_func
(paren
id|c
comma
id|f-&gt;metadata-&gt;raw
)paren
suffix:semicolon
id|jffs2_free_full_dnode
c_func
(paren
id|f-&gt;metadata
)paren
suffix:semicolon
id|f-&gt;metadata
op_assign
l_int|NULL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_for
c_loop
(paren
id|frag
op_assign
id|f-&gt;fraglist
suffix:semicolon
id|frag
suffix:semicolon
id|frag
op_assign
id|frag-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|frag-&gt;ofs
OG
id|fn-&gt;size
op_plus
id|fn-&gt;ofs
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|frag-&gt;node
op_eq
id|fn
)paren
(brace
id|frag-&gt;node
op_assign
id|new_fn
suffix:semicolon
id|new_fn-&gt;frags
op_increment
suffix:semicolon
id|fn-&gt;frags
op_decrement
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|fn-&gt;frags
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;jffs2_garbage_collect_hole: Old node still has frags!&bslash;n&quot;
)paren
suffix:semicolon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|new_fn-&gt;frags
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;jffs2_garbage_collect_hole: New node has no frags!&bslash;n&quot;
)paren
suffix:semicolon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
id|jffs2_mark_node_obsolete
c_func
(paren
id|c
comma
id|fn-&gt;raw
)paren
suffix:semicolon
id|jffs2_free_full_dnode
c_func
(paren
id|fn
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|jffs2_garbage_collect_dnode
r_static
r_int
id|jffs2_garbage_collect_dnode
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
comma
r_struct
id|jffs2_eraseblock
op_star
id|jeb
comma
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|jffs2_full_dnode
op_star
id|fn
comma
id|__u32
id|start
comma
id|__u32
id|end
)paren
(brace
r_struct
id|jffs2_inode_info
op_star
id|f
op_assign
id|JFFS2_INODE_INFO
c_func
(paren
id|inode
)paren
suffix:semicolon
r_struct
id|jffs2_full_dnode
op_star
id|new_fn
suffix:semicolon
r_struct
id|jffs2_raw_inode
id|ri
suffix:semicolon
id|__u32
id|alloclen
comma
id|phys_ofs
comma
id|offset
comma
id|orig_end
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_int
r_char
op_star
id|comprbuf
op_assign
l_int|NULL
comma
op_star
id|writebuf
suffix:semicolon
r_struct
id|page
op_star
id|pg
suffix:semicolon
r_int
r_char
op_star
id|pg_ptr
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|ri
comma
l_int|0
comma
r_sizeof
(paren
id|ri
)paren
)paren
suffix:semicolon
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Writing replacement dnode for ino #%lu from offset 0x%x to 0x%x&bslash;n&quot;
comma
id|inode-&gt;i_ino
comma
id|start
comma
id|end
)paren
)paren
suffix:semicolon
id|orig_end
op_assign
id|end
suffix:semicolon
multiline_comment|/* If we&squot;re looking at the last node in the block we&squot;re&n;&t;   garbage-collecting, we allow ourselves to merge as if the&n;&t;   block was already erasing. We&squot;re likely to be GC&squot;ing a&n;&t;   partial page, and the next block we GC is likely to have&n;&t;   the other half of this page right at the beginning, which&n;&t;   means we&squot;d expand it _then_, as nr_erasing_blocks would have&n;&t;   increased since we checked, and in doing so would obsolete &n;&t;   the partial node which we&squot;d have written here. Meaning that &n;&t;   the GC would churn and churn, and just leave dirty blocks in&n;&t;   it&squot;s wake.&n;&t;*/
r_if
c_cond
(paren
id|c-&gt;nr_free_blocks
op_plus
id|c-&gt;nr_erasing_blocks
OG
id|JFFS2_RESERVED_BLOCKS_GCMERGE
op_minus
(paren
id|fn-&gt;raw-&gt;next_phys
ques
c_cond
l_int|0
suffix:colon
l_int|1
)paren
)paren
(brace
multiline_comment|/* Shitloads of space */
multiline_comment|/* FIXME: Integrate this properly with GC calculations */
id|start
op_and_assign
op_complement
(paren
id|PAGE_CACHE_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
id|end
op_assign
id|min_t
c_func
(paren
id|__u32
comma
id|start
op_plus
id|PAGE_CACHE_SIZE
comma
id|inode-&gt;i_size
)paren
suffix:semicolon
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Plenty of free space, so expanding to write from offset 0x%x to 0x%x&bslash;n&quot;
comma
id|start
comma
id|end
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|end
OL
id|orig_end
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Eep. jffs2_garbage_collect_dnode extended node to write, but it got smaller: start 0x%x, orig_end 0x%x, end 0x%x&bslash;n&quot;
comma
id|start
comma
id|orig_end
comma
id|end
)paren
suffix:semicolon
id|end
op_assign
id|orig_end
suffix:semicolon
)brace
)brace
multiline_comment|/* First, use readpage() to read the appropriate page into the page cache */
multiline_comment|/* Q: What happens if we actually try to GC the _same_ page for which commit_write()&n;&t; *    triggered garbage collection in the first place?&n;&t; * A: I _think_ it&squot;s OK. read_cache_page shouldn&squot;t deadlock, we&squot;ll write out the&n;&t; *    page OK. We&squot;ll actually write it out again in commit_write, which is a little&n;&t; *    suboptimal, but at least we&squot;re correct.&n;&t; */
id|pg
op_assign
id|read_cache_page
c_func
(paren
id|inode-&gt;i_mapping
comma
id|start
op_rshift
id|PAGE_CACHE_SHIFT
comma
(paren
r_void
op_star
)paren
id|jffs2_do_readpage_unlock
comma
id|inode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|pg
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;read_cache_page() returned error: %ld&bslash;n&quot;
comma
id|PTR_ERR
c_func
(paren
id|pg
)paren
)paren
suffix:semicolon
r_return
id|PTR_ERR
c_func
(paren
id|pg
)paren
suffix:semicolon
)brace
id|pg_ptr
op_assign
(paren
r_char
op_star
)paren
id|kmap
c_func
(paren
id|pg
)paren
suffix:semicolon
id|comprbuf
op_assign
id|kmalloc
c_func
(paren
id|end
op_minus
id|start
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|offset
op_assign
id|start
suffix:semicolon
r_while
c_loop
(paren
id|offset
OL
id|orig_end
)paren
(brace
id|__u32
id|datalen
suffix:semicolon
id|__u32
id|cdatalen
suffix:semicolon
r_char
id|comprtype
op_assign
id|JFFS2_COMPR_NONE
suffix:semicolon
id|ret
op_assign
id|jffs2_reserve_space_gc
c_func
(paren
id|c
comma
r_sizeof
(paren
id|ri
)paren
op_plus
id|JFFS2_MIN_DATA_LEN
comma
op_amp
id|phys_ofs
comma
op_amp
id|alloclen
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;jffs2_reserve_space_gc of %d bytes for garbage_collect_dnode failed: %d&bslash;n&quot;
comma
r_sizeof
(paren
id|ri
)paren
op_plus
id|JFFS2_MIN_DATA_LEN
comma
id|ret
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|cdatalen
op_assign
id|min
c_func
(paren
id|alloclen
op_minus
r_sizeof
(paren
id|ri
)paren
comma
id|end
op_minus
id|offset
)paren
suffix:semicolon
id|datalen
op_assign
id|end
op_minus
id|offset
suffix:semicolon
id|writebuf
op_assign
id|pg_ptr
op_plus
(paren
id|offset
op_amp
(paren
id|PAGE_CACHE_SIZE
op_minus
l_int|1
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|comprbuf
)paren
(brace
id|comprtype
op_assign
id|jffs2_compress
c_func
(paren
id|writebuf
comma
id|comprbuf
comma
op_amp
id|datalen
comma
op_amp
id|cdatalen
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|comprtype
)paren
(brace
id|writebuf
op_assign
id|comprbuf
suffix:semicolon
)brace
r_else
(brace
id|datalen
op_assign
id|cdatalen
suffix:semicolon
)brace
id|ri.magic
op_assign
id|JFFS2_MAGIC_BITMASK
suffix:semicolon
id|ri.nodetype
op_assign
id|JFFS2_NODETYPE_INODE
suffix:semicolon
id|ri.totlen
op_assign
r_sizeof
(paren
id|ri
)paren
op_plus
id|cdatalen
suffix:semicolon
id|ri.hdr_crc
op_assign
id|crc32
c_func
(paren
l_int|0
comma
op_amp
id|ri
comma
r_sizeof
(paren
r_struct
id|jffs2_unknown_node
)paren
op_minus
l_int|4
)paren
suffix:semicolon
id|ri.ino
op_assign
id|inode-&gt;i_ino
suffix:semicolon
id|ri.version
op_assign
op_increment
id|f-&gt;highest_version
suffix:semicolon
id|ri.mode
op_assign
id|inode-&gt;i_mode
suffix:semicolon
id|ri.uid
op_assign
id|inode-&gt;i_uid
suffix:semicolon
id|ri.gid
op_assign
id|inode-&gt;i_gid
suffix:semicolon
id|ri.isize
op_assign
id|inode-&gt;i_size
suffix:semicolon
id|ri.atime
op_assign
id|inode-&gt;i_atime
suffix:semicolon
id|ri.ctime
op_assign
id|inode-&gt;i_ctime
suffix:semicolon
id|ri.mtime
op_assign
id|inode-&gt;i_mtime
suffix:semicolon
id|ri.offset
op_assign
id|offset
suffix:semicolon
id|ri.csize
op_assign
id|cdatalen
suffix:semicolon
id|ri.dsize
op_assign
id|datalen
suffix:semicolon
id|ri.compr
op_assign
id|comprtype
suffix:semicolon
id|ri.node_crc
op_assign
id|crc32
c_func
(paren
l_int|0
comma
op_amp
id|ri
comma
r_sizeof
(paren
id|ri
)paren
op_minus
l_int|8
)paren
suffix:semicolon
id|ri.data_crc
op_assign
id|crc32
c_func
(paren
l_int|0
comma
id|writebuf
comma
id|cdatalen
)paren
suffix:semicolon
id|new_fn
op_assign
id|jffs2_write_dnode
c_func
(paren
id|inode
comma
op_amp
id|ri
comma
id|writebuf
comma
id|cdatalen
comma
id|phys_ofs
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|new_fn
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Error writing new dnode: %ld&bslash;n&quot;
comma
id|PTR_ERR
c_func
(paren
id|new_fn
)paren
)paren
suffix:semicolon
id|ret
op_assign
id|PTR_ERR
c_func
(paren
id|new_fn
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|ret
op_assign
id|jffs2_add_full_dnode_to_inode
c_func
(paren
id|c
comma
id|f
comma
id|new_fn
)paren
suffix:semicolon
id|offset
op_add_assign
id|datalen
suffix:semicolon
r_if
c_cond
(paren
id|f-&gt;metadata
)paren
(brace
id|jffs2_mark_node_obsolete
c_func
(paren
id|c
comma
id|f-&gt;metadata-&gt;raw
)paren
suffix:semicolon
id|jffs2_free_full_dnode
c_func
(paren
id|f-&gt;metadata
)paren
suffix:semicolon
id|f-&gt;metadata
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|comprbuf
)paren
id|kfree
c_func
(paren
id|comprbuf
)paren
suffix:semicolon
id|kunmap
c_func
(paren
id|pg
)paren
suffix:semicolon
multiline_comment|/* XXX: Does the page get freed automatically? */
multiline_comment|/* AAA: Judging by the unmount getting stuck in __wait_on_page, nope. */
id|page_cache_release
c_func
(paren
id|pg
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
eof
