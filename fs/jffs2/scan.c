multiline_comment|/*&n; * JFFS2 -- Journalling Flash File System, Version 2.&n; *&n; * Copyright (C) 2001-2003 Red Hat, Inc.&n; *&n; * Created by David Woodhouse &lt;dwmw2@redhat.com&gt;&n; *&n; * For licensing information, see the file &squot;LICENCE&squot; in this directory.&n; *&n; * $Id: scan.c,v 1.104 2003/10/11 14:52:48 dwmw2 Exp $&n; *&n; */
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/mtd/mtd.h&gt;
macro_line|#include &lt;linux/pagemap.h&gt;
macro_line|#include &lt;linux/crc32.h&gt;
macro_line|#include &lt;linux/compiler.h&gt;
macro_line|#include &quot;nodelist.h&quot;
DECL|macro|EMPTY_SCAN_SIZE
mdefine_line|#define EMPTY_SCAN_SIZE 1024
DECL|macro|DIRTY_SPACE
mdefine_line|#define DIRTY_SPACE(x) do { typeof(x) _x = (x); &bslash;&n;&t;&t;c-&gt;free_size -= _x; c-&gt;dirty_size += _x; &bslash;&n;&t;&t;jeb-&gt;free_size -= _x ; jeb-&gt;dirty_size += _x; &bslash;&n;&t;&t;}while(0)
DECL|macro|USED_SPACE
mdefine_line|#define USED_SPACE(x) do { typeof(x) _x = (x); &bslash;&n;&t;&t;c-&gt;free_size -= _x; c-&gt;used_size += _x; &bslash;&n;&t;&t;jeb-&gt;free_size -= _x ; jeb-&gt;used_size += _x; &bslash;&n;&t;&t;}while(0)
DECL|macro|UNCHECKED_SPACE
mdefine_line|#define UNCHECKED_SPACE(x) do { typeof(x) _x = (x); &bslash;&n;&t;&t;c-&gt;free_size -= _x; c-&gt;unchecked_size += _x; &bslash;&n;&t;&t;jeb-&gt;free_size -= _x ; jeb-&gt;unchecked_size += _x; &bslash;&n;&t;&t;}while(0)
DECL|macro|noisy_printk
mdefine_line|#define noisy_printk(noise, args...) do { &bslash;&n;&t;if (*(noise)) { &bslash;&n;&t;&t;printk(KERN_NOTICE args); &bslash;&n;&t;&t; (*(noise))--; &bslash;&n;&t;&t; if (!(*(noise))) { &bslash;&n;&t;&t;&t; printk(KERN_NOTICE &quot;Further such events for this erase block will not be printed&bslash;n&quot;); &bslash;&n;&t;&t; } &bslash;&n;&t;} &bslash;&n;} while(0)
DECL|variable|pseudo_random
r_static
r_uint32
id|pseudo_random
suffix:semicolon
r_static
r_int
id|jffs2_scan_eraseblock
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
comma
r_struct
id|jffs2_eraseblock
op_star
id|jeb
comma
r_int
r_char
op_star
id|buf
comma
r_uint32
id|buf_size
)paren
suffix:semicolon
multiline_comment|/* These helper functions _must_ increase ofs and also do the dirty/used space accounting. &n; * Returning an error will abort the mount - bad checksums etc. should just mark the space&n; * as dirty.&n; */
r_static
r_int
id|jffs2_scan_inode_node
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
comma
r_struct
id|jffs2_eraseblock
op_star
id|jeb
comma
r_struct
id|jffs2_raw_inode
op_star
id|ri
comma
r_uint32
id|ofs
)paren
suffix:semicolon
r_static
r_int
id|jffs2_scan_dirent_node
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
comma
r_struct
id|jffs2_eraseblock
op_star
id|jeb
comma
r_struct
id|jffs2_raw_dirent
op_star
id|rd
comma
r_uint32
id|ofs
)paren
suffix:semicolon
DECL|macro|BLK_STATE_ALLFF
mdefine_line|#define BLK_STATE_ALLFF&t;&t;0
DECL|macro|BLK_STATE_CLEAN
mdefine_line|#define BLK_STATE_CLEAN&t;&t;1
DECL|macro|BLK_STATE_PARTDIRTY
mdefine_line|#define BLK_STATE_PARTDIRTY&t;2
DECL|macro|BLK_STATE_CLEANMARKER
mdefine_line|#define BLK_STATE_CLEANMARKER&t;3
DECL|macro|BLK_STATE_ALLDIRTY
mdefine_line|#define BLK_STATE_ALLDIRTY&t;4
DECL|macro|BLK_STATE_BADBLOCK
mdefine_line|#define BLK_STATE_BADBLOCK&t;5
DECL|function|min_free
r_static
r_inline
r_int
id|min_free
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
)paren
(brace
r_uint32
id|min
op_assign
l_int|2
op_star
r_sizeof
(paren
r_struct
id|jffs2_raw_inode
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_JFFS2_FS_NAND
r_if
c_cond
(paren
op_logical_neg
id|jffs2_can_mark_obsolete
c_func
(paren
id|c
)paren
op_logical_and
id|min
OL
id|c-&gt;wbuf_pagesize
)paren
r_return
id|c-&gt;wbuf_pagesize
suffix:semicolon
macro_line|#endif
r_return
id|min
suffix:semicolon
)brace
DECL|function|jffs2_scan_medium
r_int
id|jffs2_scan_medium
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
)paren
(brace
r_int
id|i
comma
id|ret
suffix:semicolon
r_uint32
id|empty_blocks
op_assign
l_int|0
comma
id|bad_blocks
op_assign
l_int|0
suffix:semicolon
r_int
r_char
op_star
id|flashbuf
op_assign
l_int|NULL
suffix:semicolon
r_uint32
id|buf_size
op_assign
l_int|0
suffix:semicolon
macro_line|#ifndef __ECOS
r_int
id|pointlen
suffix:semicolon
r_if
c_cond
(paren
id|c-&gt;mtd-&gt;point
)paren
(brace
id|ret
op_assign
id|c-&gt;mtd-&gt;point
(paren
id|c-&gt;mtd
comma
l_int|0
comma
id|c-&gt;mtd-&gt;size
comma
op_amp
id|pointlen
comma
op_amp
id|flashbuf
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ret
op_logical_and
id|pointlen
OL
id|c-&gt;mtd-&gt;size
)paren
(brace
multiline_comment|/* Don&squot;t muck about if it won&squot;t let us point to the whole flash */
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;MTD point returned len too short: 0x%zx&bslash;n&quot;
comma
id|pointlen
)paren
)paren
suffix:semicolon
id|c-&gt;mtd
op_member_access_from_pointer
id|unpoint
c_func
(paren
id|c-&gt;mtd
comma
id|flashbuf
comma
l_int|0
comma
id|c-&gt;mtd-&gt;size
)paren
suffix:semicolon
id|flashbuf
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ret
)paren
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;MTD point failed %d&bslash;n&quot;
comma
id|ret
)paren
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|flashbuf
)paren
(brace
multiline_comment|/* For NAND it&squot;s quicker to read a whole eraseblock at a time,&n;&t;&t;   apparently */
r_if
c_cond
(paren
id|jffs2_cleanmarker_oob
c_func
(paren
id|c
)paren
)paren
id|buf_size
op_assign
id|c-&gt;sector_size
suffix:semicolon
r_else
id|buf_size
op_assign
id|PAGE_SIZE
suffix:semicolon
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Allocating readbuf of %d bytes&bslash;n&quot;
comma
id|buf_size
)paren
)paren
suffix:semicolon
id|flashbuf
op_assign
id|kmalloc
c_func
(paren
id|buf_size
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|flashbuf
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|c-&gt;nr_blocks
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|jffs2_eraseblock
op_star
id|jeb
op_assign
op_amp
id|c-&gt;blocks
(braket
id|i
)braket
suffix:semicolon
id|ret
op_assign
id|jffs2_scan_eraseblock
c_func
(paren
id|c
comma
id|jeb
comma
id|buf_size
ques
c_cond
id|flashbuf
suffix:colon
(paren
id|flashbuf
op_plus
id|jeb-&gt;offset
)paren
comma
id|buf_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
r_goto
id|out
suffix:semicolon
id|ACCT_PARANOIA_CHECK
c_func
(paren
id|jeb
)paren
suffix:semicolon
multiline_comment|/* Now decide which list to put it on */
r_switch
c_cond
(paren
id|ret
)paren
(brace
r_case
id|BLK_STATE_ALLFF
suffix:colon
multiline_comment|/* &n;&t;&t;&t; * Empty block.   Since we can&squot;t be sure it &n;&t;&t;&t; * was entirely erased, we just queue it for erase&n;&t;&t;&t; * again.  It will be marked as such when the erase&n;&t;&t;&t; * is complete.  Meanwhile we still count it as empty&n;&t;&t;&t; * for later checks.&n;&t;&t;&t; */
id|empty_blocks
op_increment
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|jeb-&gt;list
comma
op_amp
id|c-&gt;erase_pending_list
)paren
suffix:semicolon
id|c-&gt;nr_erasing_blocks
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BLK_STATE_CLEANMARKER
suffix:colon
multiline_comment|/* Only a CLEANMARKER node is valid */
r_if
c_cond
(paren
op_logical_neg
id|jeb-&gt;dirty_size
)paren
(brace
multiline_comment|/* It&squot;s actually free */
id|list_add
c_func
(paren
op_amp
id|jeb-&gt;list
comma
op_amp
id|c-&gt;free_list
)paren
suffix:semicolon
id|c-&gt;nr_free_blocks
op_increment
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Dirt */
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Adding all-dirty block at 0x%08x to erase_pending_list&bslash;n&quot;
comma
id|jeb-&gt;offset
)paren
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|jeb-&gt;list
comma
op_amp
id|c-&gt;erase_pending_list
)paren
suffix:semicolon
id|c-&gt;nr_erasing_blocks
op_increment
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|BLK_STATE_CLEAN
suffix:colon
multiline_comment|/* Full (or almost full) of clean data. Clean list */
id|list_add
c_func
(paren
op_amp
id|jeb-&gt;list
comma
op_amp
id|c-&gt;clean_list
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BLK_STATE_PARTDIRTY
suffix:colon
multiline_comment|/* Some data, but not full. Dirty list. */
multiline_comment|/* Except that we want to remember the block with most free space,&n;                           and stick it in the &squot;nextblock&squot; position to start writing to it.&n;                           Later when we do snapshots, this must be the most recent block,&n;                           not the one with most free space.&n;                        */
r_if
c_cond
(paren
id|jeb-&gt;free_size
OG
id|min_free
c_func
(paren
id|c
)paren
op_logical_and
(paren
op_logical_neg
id|c-&gt;nextblock
op_logical_or
id|c-&gt;nextblock-&gt;free_size
OL
id|jeb-&gt;free_size
)paren
)paren
(brace
multiline_comment|/* Better candidate for the next writes to go to */
r_if
c_cond
(paren
id|c-&gt;nextblock
)paren
(brace
id|c-&gt;nextblock-&gt;dirty_size
op_add_assign
id|c-&gt;nextblock-&gt;free_size
op_plus
id|c-&gt;nextblock-&gt;wasted_size
suffix:semicolon
id|c-&gt;dirty_size
op_add_assign
id|c-&gt;nextblock-&gt;free_size
op_plus
id|c-&gt;nextblock-&gt;wasted_size
suffix:semicolon
id|c-&gt;free_size
op_sub_assign
id|c-&gt;nextblock-&gt;free_size
suffix:semicolon
id|c-&gt;wasted_size
op_sub_assign
id|c-&gt;nextblock-&gt;wasted_size
suffix:semicolon
id|c-&gt;nextblock-&gt;free_size
op_assign
id|c-&gt;nextblock-&gt;wasted_size
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|VERYDIRTY
c_func
(paren
id|c
comma
id|c-&gt;nextblock-&gt;dirty_size
)paren
)paren
(brace
id|list_add
c_func
(paren
op_amp
id|c-&gt;nextblock-&gt;list
comma
op_amp
id|c-&gt;very_dirty_list
)paren
suffix:semicolon
)brace
r_else
(brace
id|list_add
c_func
(paren
op_amp
id|c-&gt;nextblock-&gt;list
comma
op_amp
id|c-&gt;dirty_list
)paren
suffix:semicolon
)brace
)brace
id|c-&gt;nextblock
op_assign
id|jeb
suffix:semicolon
)brace
r_else
(brace
id|jeb-&gt;dirty_size
op_add_assign
id|jeb-&gt;free_size
op_plus
id|jeb-&gt;wasted_size
suffix:semicolon
id|c-&gt;dirty_size
op_add_assign
id|jeb-&gt;free_size
op_plus
id|jeb-&gt;wasted_size
suffix:semicolon
id|c-&gt;free_size
op_sub_assign
id|jeb-&gt;free_size
suffix:semicolon
id|c-&gt;wasted_size
op_sub_assign
id|jeb-&gt;wasted_size
suffix:semicolon
id|jeb-&gt;free_size
op_assign
id|jeb-&gt;wasted_size
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|VERYDIRTY
c_func
(paren
id|c
comma
id|jeb-&gt;dirty_size
)paren
)paren
(brace
id|list_add
c_func
(paren
op_amp
id|jeb-&gt;list
comma
op_amp
id|c-&gt;very_dirty_list
)paren
suffix:semicolon
)brace
r_else
(brace
id|list_add
c_func
(paren
op_amp
id|jeb-&gt;list
comma
op_amp
id|c-&gt;dirty_list
)paren
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
r_case
id|BLK_STATE_ALLDIRTY
suffix:colon
multiline_comment|/* Nothing valid - not even a clean marker. Needs erasing. */
multiline_comment|/* For now we just put it on the erasing list. We&squot;ll start the erases later */
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;JFFS2: Erase block at 0x%08x is not formatted. It will be erased&bslash;n&quot;
comma
id|jeb-&gt;offset
)paren
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|jeb-&gt;list
comma
op_amp
id|c-&gt;erase_pending_list
)paren
suffix:semicolon
id|c-&gt;nr_erasing_blocks
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BLK_STATE_BADBLOCK
suffix:colon
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;JFFS2: Block at 0x%08x is bad&bslash;n&quot;
comma
id|jeb-&gt;offset
)paren
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|jeb-&gt;list
comma
op_amp
id|c-&gt;bad_list
)paren
suffix:semicolon
id|c-&gt;bad_size
op_add_assign
id|c-&gt;sector_size
suffix:semicolon
id|c-&gt;free_size
op_sub_assign
id|c-&gt;sector_size
suffix:semicolon
id|bad_blocks
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;jffs2_scan_medium(): unknown block state&bslash;n&quot;
)paren
suffix:semicolon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Nextblock dirty is always seen as wasted, because we cannot recycle it now */
r_if
c_cond
(paren
id|c-&gt;nextblock
op_logical_and
(paren
id|c-&gt;nextblock-&gt;dirty_size
)paren
)paren
(brace
id|c-&gt;nextblock-&gt;wasted_size
op_add_assign
id|c-&gt;nextblock-&gt;dirty_size
suffix:semicolon
id|c-&gt;wasted_size
op_add_assign
id|c-&gt;nextblock-&gt;dirty_size
suffix:semicolon
id|c-&gt;dirty_size
op_sub_assign
id|c-&gt;nextblock-&gt;dirty_size
suffix:semicolon
id|c-&gt;nextblock-&gt;dirty_size
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_JFFS2_FS_NAND
r_if
c_cond
(paren
op_logical_neg
id|jffs2_can_mark_obsolete
c_func
(paren
id|c
)paren
op_logical_and
id|c-&gt;nextblock
op_logical_and
(paren
id|c-&gt;nextblock-&gt;free_size
op_amp
(paren
id|c-&gt;wbuf_pagesize
op_minus
l_int|1
)paren
)paren
)paren
(brace
multiline_comment|/* If we&squot;re going to start writing into a block which already &n;&t;&t;   contains data, and the end of the data isn&squot;t page-aligned,&n;&t;&t;   skip a little and align it. */
r_uint32
id|skip
op_assign
id|c-&gt;nextblock-&gt;free_size
op_amp
(paren
id|c-&gt;wbuf_pagesize
op_minus
l_int|1
)paren
suffix:semicolon
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;jffs2_scan_medium(): Skipping %d bytes in nextblock to ensure page alignment&bslash;n&quot;
comma
id|skip
)paren
)paren
suffix:semicolon
id|c-&gt;nextblock-&gt;wasted_size
op_add_assign
id|skip
suffix:semicolon
id|c-&gt;wasted_size
op_add_assign
id|skip
suffix:semicolon
id|c-&gt;nextblock-&gt;free_size
op_sub_assign
id|skip
suffix:semicolon
id|c-&gt;free_size
op_sub_assign
id|skip
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|c-&gt;nr_erasing_blocks
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|c-&gt;used_size
op_logical_and
(paren
(paren
id|empty_blocks
op_plus
id|bad_blocks
)paren
op_ne
id|c-&gt;nr_blocks
op_logical_or
id|bad_blocks
op_eq
id|c-&gt;nr_blocks
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;Cowardly refusing to erase blocks on filesystem with no valid JFFS2 nodes&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;empty_blocks %d, bad_blocks %d, c-&gt;nr_blocks %d&bslash;n&quot;
comma
id|empty_blocks
comma
id|bad_blocks
comma
id|c-&gt;nr_blocks
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|jffs2_erase_pending_trigger
c_func
(paren
id|c
)paren
suffix:semicolon
)brace
id|ret
op_assign
l_int|0
suffix:semicolon
id|out
suffix:colon
r_if
c_cond
(paren
id|buf_size
)paren
id|kfree
c_func
(paren
id|flashbuf
)paren
suffix:semicolon
macro_line|#ifndef __ECOS
r_else
id|c-&gt;mtd
op_member_access_from_pointer
id|unpoint
c_func
(paren
id|c-&gt;mtd
comma
id|flashbuf
comma
l_int|0
comma
id|c-&gt;mtd-&gt;size
)paren
suffix:semicolon
macro_line|#endif
r_return
id|ret
suffix:semicolon
)brace
DECL|function|jffs2_fill_scan_buf
r_static
r_int
id|jffs2_fill_scan_buf
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
comma
r_int
r_char
op_star
id|buf
comma
r_uint32
id|ofs
comma
r_uint32
id|len
)paren
(brace
r_int
id|ret
suffix:semicolon
r_int
id|retlen
suffix:semicolon
id|ret
op_assign
id|jffs2_flash_read
c_func
(paren
id|c
comma
id|ofs
comma
id|len
comma
op_amp
id|retlen
comma
id|buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;mtd-&gt;read(0x%x bytes from 0x%x) returned %d&bslash;n&quot;
comma
id|len
comma
id|ofs
comma
id|ret
)paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_if
c_cond
(paren
id|retlen
OL
id|len
)paren
(brace
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Read at 0x%x gave only 0x%zx bytes&bslash;n&quot;
comma
id|ofs
comma
id|retlen
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|D2
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Read 0x%x bytes from 0x%08x into buf&bslash;n&quot;
comma
id|len
comma
id|ofs
)paren
)paren
suffix:semicolon
id|D2
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;000: %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x&bslash;n&quot;
comma
id|buf
(braket
l_int|0
)braket
comma
id|buf
(braket
l_int|1
)braket
comma
id|buf
(braket
l_int|2
)braket
comma
id|buf
(braket
l_int|3
)braket
comma
id|buf
(braket
l_int|4
)braket
comma
id|buf
(braket
l_int|5
)braket
comma
id|buf
(braket
l_int|6
)braket
comma
id|buf
(braket
l_int|7
)braket
comma
id|buf
(braket
l_int|8
)braket
comma
id|buf
(braket
l_int|9
)braket
comma
id|buf
(braket
l_int|10
)braket
comma
id|buf
(braket
l_int|11
)braket
comma
id|buf
(braket
l_int|12
)braket
comma
id|buf
(braket
l_int|13
)braket
comma
id|buf
(braket
l_int|14
)braket
comma
id|buf
(braket
l_int|15
)braket
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|jffs2_scan_eraseblock
r_static
r_int
id|jffs2_scan_eraseblock
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
comma
r_struct
id|jffs2_eraseblock
op_star
id|jeb
comma
r_int
r_char
op_star
id|buf
comma
r_uint32
id|buf_size
)paren
(brace
r_struct
id|jffs2_unknown_node
op_star
id|node
suffix:semicolon
r_struct
id|jffs2_unknown_node
id|crcnode
suffix:semicolon
r_uint32
id|ofs
comma
id|prevofs
suffix:semicolon
r_uint32
id|hdr_crc
comma
id|buf_ofs
comma
id|buf_len
suffix:semicolon
r_int
id|err
suffix:semicolon
r_int
id|noise
op_assign
l_int|0
suffix:semicolon
r_int
id|wasempty
op_assign
l_int|0
suffix:semicolon
r_uint32
id|empty_start
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef CONFIG_JFFS2_FS_NAND
r_int
id|cleanmarkerfound
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
id|ofs
op_assign
id|jeb-&gt;offset
suffix:semicolon
id|prevofs
op_assign
id|jeb-&gt;offset
op_minus
l_int|1
suffix:semicolon
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;jffs2_scan_eraseblock(): Scanning block at 0x%x&bslash;n&quot;
comma
id|ofs
)paren
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_JFFS2_FS_NAND
r_if
c_cond
(paren
id|jffs2_cleanmarker_oob
c_func
(paren
id|c
)paren
)paren
(brace
r_int
id|ret
op_assign
id|jffs2_check_nand_cleanmarker
c_func
(paren
id|c
comma
id|jeb
)paren
suffix:semicolon
id|D2
c_func
(paren
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;jffs_check_nand_cleanmarker returned %d&bslash;n&quot;
comma
id|ret
)paren
)paren
suffix:semicolon
multiline_comment|/* Even if it&squot;s not found, we still scan to see&n;&t;&t;   if the block is empty. We use this information&n;&t;&t;   to decide whether to erase it or not. */
r_switch
c_cond
(paren
id|ret
)paren
(brace
r_case
l_int|0
suffix:colon
id|cleanmarkerfound
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
r_return
id|BLK_STATE_BADBLOCK
suffix:semicolon
r_case
l_int|3
suffix:colon
r_return
id|BLK_STATE_ALLDIRTY
suffix:semicolon
multiline_comment|/* Block has failed to erase min. once */
r_default
suffix:colon
r_return
id|ret
suffix:semicolon
)brace
)brace
macro_line|#endif
id|buf_ofs
op_assign
id|jeb-&gt;offset
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buf_size
)paren
(brace
id|buf_len
op_assign
id|c-&gt;sector_size
suffix:semicolon
)brace
r_else
(brace
id|buf_len
op_assign
id|EMPTY_SCAN_SIZE
suffix:semicolon
id|err
op_assign
id|jffs2_fill_scan_buf
c_func
(paren
id|c
comma
id|buf
comma
id|buf_ofs
comma
id|buf_len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/* We temporarily use &squot;ofs&squot; as a pointer into the buffer/jeb */
id|ofs
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Scan only 4KiB of 0xFF before declaring it&squot;s empty */
r_while
c_loop
(paren
id|ofs
OL
id|EMPTY_SCAN_SIZE
op_logical_and
op_star
(paren
r_uint32
op_star
)paren
(paren
op_amp
id|buf
(braket
id|ofs
)braket
)paren
op_eq
l_int|0xFFFFFFFF
)paren
(brace
id|ofs
op_add_assign
l_int|4
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ofs
op_eq
id|EMPTY_SCAN_SIZE
)paren
(brace
macro_line|#ifdef CONFIG_JFFS2_FS_NAND
r_if
c_cond
(paren
id|jffs2_cleanmarker_oob
c_func
(paren
id|c
)paren
)paren
(brace
multiline_comment|/* scan oob, take care of cleanmarker */
r_int
id|ret
op_assign
id|jffs2_check_oob_empty
c_func
(paren
id|c
comma
id|jeb
comma
id|cleanmarkerfound
)paren
suffix:semicolon
id|D2
c_func
(paren
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;jffs2_check_oob_empty returned %d&bslash;n&quot;
comma
id|ret
)paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|ret
)paren
(brace
r_case
l_int|0
suffix:colon
r_return
id|cleanmarkerfound
ques
c_cond
id|BLK_STATE_CLEANMARKER
suffix:colon
id|BLK_STATE_ALLFF
suffix:semicolon
r_case
l_int|1
suffix:colon
r_return
id|BLK_STATE_ALLDIRTY
suffix:semicolon
r_case
l_int|2
suffix:colon
r_return
id|BLK_STATE_BADBLOCK
suffix:semicolon
multiline_comment|/* case 2/3 are paranoia checks */
r_case
l_int|3
suffix:colon
r_return
id|BLK_STATE_ALLDIRTY
suffix:semicolon
multiline_comment|/* Block has failed to erase min. once */
r_default
suffix:colon
r_return
id|ret
suffix:semicolon
)brace
)brace
macro_line|#endif
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Block at 0x%08x is empty (erased)&bslash;n&quot;
comma
id|jeb-&gt;offset
)paren
)paren
suffix:semicolon
r_return
id|BLK_STATE_ALLFF
suffix:semicolon
multiline_comment|/* OK to erase if all blocks are like this */
)brace
r_if
c_cond
(paren
id|ofs
)paren
(brace
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Free space at %08x ends at %08x&bslash;n&quot;
comma
id|jeb-&gt;offset
comma
id|jeb-&gt;offset
op_plus
id|ofs
)paren
)paren
suffix:semicolon
id|DIRTY_SPACE
c_func
(paren
id|ofs
)paren
suffix:semicolon
)brace
multiline_comment|/* Now ofs is a complete physical flash offset as it always was... */
id|ofs
op_add_assign
id|jeb-&gt;offset
suffix:semicolon
id|noise
op_assign
l_int|10
suffix:semicolon
r_while
c_loop
(paren
id|ofs
OL
id|jeb-&gt;offset
op_plus
id|c-&gt;sector_size
)paren
(brace
id|D1
c_func
(paren
id|ACCT_PARANOIA_CHECK
c_func
(paren
id|jeb
)paren
)paren
suffix:semicolon
id|cond_resched
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ofs
op_amp
l_int|3
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Eep. ofs 0x%08x not word-aligned!&bslash;n&quot;
comma
id|ofs
)paren
suffix:semicolon
id|ofs
op_assign
id|PAD
c_func
(paren
id|ofs
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ofs
op_eq
id|prevofs
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;ofs 0x%08x has already been seen. Skipping&bslash;n&quot;
comma
id|ofs
)paren
suffix:semicolon
id|DIRTY_SPACE
c_func
(paren
l_int|4
)paren
suffix:semicolon
id|ofs
op_add_assign
l_int|4
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|prevofs
op_assign
id|ofs
suffix:semicolon
r_if
c_cond
(paren
id|jeb-&gt;offset
op_plus
id|c-&gt;sector_size
OL
id|ofs
op_plus
r_sizeof
(paren
op_star
id|node
)paren
)paren
(brace
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Fewer than %zd bytes left to end of block. (%x+%x&lt;%x+%zx) Not reading&bslash;n&quot;
comma
r_sizeof
(paren
r_struct
id|jffs2_unknown_node
)paren
comma
id|jeb-&gt;offset
comma
id|c-&gt;sector_size
comma
id|ofs
comma
r_sizeof
(paren
op_star
id|node
)paren
)paren
)paren
suffix:semicolon
id|DIRTY_SPACE
c_func
(paren
(paren
id|jeb-&gt;offset
op_plus
id|c-&gt;sector_size
)paren
op_minus
id|ofs
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|buf_ofs
op_plus
id|buf_len
OL
id|ofs
op_plus
r_sizeof
(paren
op_star
id|node
)paren
)paren
(brace
id|buf_len
op_assign
id|min_t
c_func
(paren
r_uint32
comma
id|buf_size
comma
id|jeb-&gt;offset
op_plus
id|c-&gt;sector_size
op_minus
id|ofs
)paren
suffix:semicolon
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Fewer than %zd bytes (node header) left to end of buf. Reading 0x%x at 0x%08x&bslash;n&quot;
comma
r_sizeof
(paren
r_struct
id|jffs2_unknown_node
)paren
comma
id|buf_len
comma
id|ofs
)paren
)paren
suffix:semicolon
id|err
op_assign
id|jffs2_fill_scan_buf
c_func
(paren
id|c
comma
id|buf
comma
id|ofs
comma
id|buf_len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
id|buf_ofs
op_assign
id|ofs
suffix:semicolon
)brace
id|node
op_assign
(paren
r_struct
id|jffs2_unknown_node
op_star
)paren
op_amp
id|buf
(braket
id|ofs
op_minus
id|buf_ofs
)braket
suffix:semicolon
r_if
c_cond
(paren
op_star
(paren
r_uint32
op_star
)paren
(paren
op_amp
id|buf
(braket
id|ofs
op_minus
id|buf_ofs
)braket
)paren
op_eq
l_int|0xffffffff
)paren
(brace
r_uint32
id|inbuf_ofs
op_assign
id|ofs
op_minus
id|buf_ofs
op_plus
l_int|4
suffix:semicolon
r_uint32
id|scanend
suffix:semicolon
id|empty_start
op_assign
id|ofs
suffix:semicolon
id|ofs
op_add_assign
l_int|4
suffix:semicolon
multiline_comment|/* If scanning empty space after only a cleanmarker, don&squot;t&n;&t;&t;&t;   bother scanning the whole block */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|empty_start
op_eq
id|jeb-&gt;offset
op_plus
id|c-&gt;cleanmarker_size
op_logical_and
id|jeb-&gt;offset
op_plus
id|EMPTY_SCAN_SIZE
OL
id|buf_ofs
op_plus
id|buf_len
)paren
)paren
id|scanend
op_assign
id|jeb-&gt;offset
op_plus
id|EMPTY_SCAN_SIZE
op_minus
id|buf_ofs
suffix:semicolon
r_else
id|scanend
op_assign
id|buf_len
suffix:semicolon
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Found empty flash at 0x%08x&bslash;n&quot;
comma
id|ofs
)paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|inbuf_ofs
OL
id|scanend
)paren
(brace
r_if
c_cond
(paren
op_star
(paren
r_uint32
op_star
)paren
(paren
op_amp
id|buf
(braket
id|inbuf_ofs
)braket
)paren
op_ne
l_int|0xffffffff
)paren
r_goto
id|emptyends
suffix:semicolon
id|inbuf_ofs
op_add_assign
l_int|4
suffix:semicolon
id|ofs
op_add_assign
l_int|4
suffix:semicolon
)brace
multiline_comment|/* Ran off end. */
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Empty flash ends normally at 0x%08x&bslash;n&quot;
comma
id|ofs
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buf_ofs
op_eq
id|jeb-&gt;offset
op_logical_and
id|jeb-&gt;used_size
op_eq
id|PAD
c_func
(paren
id|c-&gt;cleanmarker_size
)paren
op_logical_and
id|c-&gt;cleanmarker_size
op_logical_and
op_logical_neg
id|jeb-&gt;first_node-&gt;next_in_ino
op_logical_and
op_logical_neg
id|jeb-&gt;dirty_size
)paren
r_return
id|BLK_STATE_CLEANMARKER
suffix:semicolon
id|wasempty
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|wasempty
)paren
(brace
id|emptyends
suffix:colon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Empty flash at 0x%08x ends at 0x%08x&bslash;n&quot;
comma
id|empty_start
comma
id|ofs
)paren
suffix:semicolon
id|DIRTY_SPACE
c_func
(paren
id|ofs
op_minus
id|empty_start
)paren
suffix:semicolon
id|wasempty
op_assign
l_int|0
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ofs
op_eq
id|jeb-&gt;offset
op_logical_and
id|je16_to_cpu
c_func
(paren
id|node-&gt;magic
)paren
op_eq
id|KSAMTIB_CIGAM_2SFFJ
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Magic bitmask is backwards at offset 0x%08x. Wrong endian filesystem?&bslash;n&quot;
comma
id|ofs
)paren
suffix:semicolon
id|DIRTY_SPACE
c_func
(paren
l_int|4
)paren
suffix:semicolon
id|ofs
op_add_assign
l_int|4
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|je16_to_cpu
c_func
(paren
id|node-&gt;magic
)paren
op_eq
id|JFFS2_DIRTY_BITMASK
)paren
(brace
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Dirty bitmask at 0x%08x&bslash;n&quot;
comma
id|ofs
)paren
)paren
suffix:semicolon
id|DIRTY_SPACE
c_func
(paren
l_int|4
)paren
suffix:semicolon
id|ofs
op_add_assign
l_int|4
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|je16_to_cpu
c_func
(paren
id|node-&gt;magic
)paren
op_eq
id|JFFS2_OLD_MAGIC_BITMASK
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Old JFFS2 bitmask found at 0x%08x&bslash;n&quot;
comma
id|ofs
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;You cannot use older JFFS2 filesystems with newer kernels&bslash;n&quot;
)paren
suffix:semicolon
id|DIRTY_SPACE
c_func
(paren
l_int|4
)paren
suffix:semicolon
id|ofs
op_add_assign
l_int|4
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|je16_to_cpu
c_func
(paren
id|node-&gt;magic
)paren
op_ne
id|JFFS2_MAGIC_BITMASK
)paren
(brace
multiline_comment|/* OK. We&squot;re out of possibilities. Whinge and move on */
id|noisy_printk
c_func
(paren
op_amp
id|noise
comma
l_string|&quot;jffs2_scan_eraseblock(): Magic bitmask 0x%04x not found at 0x%08x: 0x%04x instead&bslash;n&quot;
comma
id|JFFS2_MAGIC_BITMASK
comma
id|ofs
comma
id|je16_to_cpu
c_func
(paren
id|node-&gt;magic
)paren
)paren
suffix:semicolon
id|DIRTY_SPACE
c_func
(paren
l_int|4
)paren
suffix:semicolon
id|ofs
op_add_assign
l_int|4
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* We seem to have a node of sorts. Check the CRC */
id|crcnode.magic
op_assign
id|node-&gt;magic
suffix:semicolon
id|crcnode.nodetype
op_assign
id|cpu_to_je16
c_func
(paren
id|je16_to_cpu
c_func
(paren
id|node-&gt;nodetype
)paren
op_or
id|JFFS2_NODE_ACCURATE
)paren
suffix:semicolon
id|crcnode.totlen
op_assign
id|node-&gt;totlen
suffix:semicolon
id|hdr_crc
op_assign
id|crc32
c_func
(paren
l_int|0
comma
op_amp
id|crcnode
comma
r_sizeof
(paren
id|crcnode
)paren
op_minus
l_int|4
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hdr_crc
op_ne
id|je32_to_cpu
c_func
(paren
id|node-&gt;hdr_crc
)paren
)paren
(brace
id|noisy_printk
c_func
(paren
op_amp
id|noise
comma
l_string|&quot;jffs2_scan_eraseblock(): Node at 0x%08x {0x%04x, 0x%04x, 0x%08x) has invalid CRC 0x%08x (calculated 0x%08x)&bslash;n&quot;
comma
id|ofs
comma
id|je16_to_cpu
c_func
(paren
id|node-&gt;magic
)paren
comma
id|je16_to_cpu
c_func
(paren
id|node-&gt;nodetype
)paren
comma
id|je32_to_cpu
c_func
(paren
id|node-&gt;totlen
)paren
comma
id|je32_to_cpu
c_func
(paren
id|node-&gt;hdr_crc
)paren
comma
id|hdr_crc
)paren
suffix:semicolon
id|DIRTY_SPACE
c_func
(paren
l_int|4
)paren
suffix:semicolon
id|ofs
op_add_assign
l_int|4
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ofs
op_plus
id|je32_to_cpu
c_func
(paren
id|node-&gt;totlen
)paren
OG
id|jeb-&gt;offset
op_plus
id|c-&gt;sector_size
)paren
(brace
multiline_comment|/* Eep. Node goes over the end of the erase block. */
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Node at 0x%08x with length 0x%08x would run over the end of the erase block&bslash;n&quot;
comma
id|ofs
comma
id|je32_to_cpu
c_func
(paren
id|node-&gt;totlen
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Perhaps the file system was created with the wrong erase size?&bslash;n&quot;
)paren
suffix:semicolon
id|DIRTY_SPACE
c_func
(paren
l_int|4
)paren
suffix:semicolon
id|ofs
op_add_assign
l_int|4
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|je16_to_cpu
c_func
(paren
id|node-&gt;nodetype
)paren
op_amp
id|JFFS2_NODE_ACCURATE
)paren
)paren
(brace
multiline_comment|/* Wheee. This is an obsoleted node */
id|D2
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Node at 0x%08x is obsolete. Skipping&bslash;n&quot;
comma
id|ofs
)paren
)paren
suffix:semicolon
id|DIRTY_SPACE
c_func
(paren
id|PAD
c_func
(paren
id|je32_to_cpu
c_func
(paren
id|node-&gt;totlen
)paren
)paren
)paren
suffix:semicolon
id|ofs
op_add_assign
id|PAD
c_func
(paren
id|je32_to_cpu
c_func
(paren
id|node-&gt;totlen
)paren
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|je16_to_cpu
c_func
(paren
id|node-&gt;nodetype
)paren
)paren
(brace
r_case
id|JFFS2_NODETYPE_INODE
suffix:colon
r_if
c_cond
(paren
id|buf_ofs
op_plus
id|buf_len
OL
id|ofs
op_plus
r_sizeof
(paren
r_struct
id|jffs2_raw_inode
)paren
)paren
(brace
id|buf_len
op_assign
id|min_t
c_func
(paren
r_uint32
comma
id|buf_size
comma
id|jeb-&gt;offset
op_plus
id|c-&gt;sector_size
op_minus
id|ofs
)paren
suffix:semicolon
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Fewer than %zd bytes (inode node) left to end of buf. Reading 0x%x at 0x%08x&bslash;n&quot;
comma
r_sizeof
(paren
r_struct
id|jffs2_raw_inode
)paren
comma
id|buf_len
comma
id|ofs
)paren
)paren
suffix:semicolon
id|err
op_assign
id|jffs2_fill_scan_buf
c_func
(paren
id|c
comma
id|buf
comma
id|ofs
comma
id|buf_len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
id|buf_ofs
op_assign
id|ofs
suffix:semicolon
id|node
op_assign
(paren
r_void
op_star
)paren
id|buf
suffix:semicolon
)brace
id|err
op_assign
id|jffs2_scan_inode_node
c_func
(paren
id|c
comma
id|jeb
comma
(paren
r_void
op_star
)paren
id|node
comma
id|ofs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
id|ofs
op_add_assign
id|PAD
c_func
(paren
id|je32_to_cpu
c_func
(paren
id|node-&gt;totlen
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|JFFS2_NODETYPE_DIRENT
suffix:colon
r_if
c_cond
(paren
id|buf_ofs
op_plus
id|buf_len
OL
id|ofs
op_plus
id|je32_to_cpu
c_func
(paren
id|node-&gt;totlen
)paren
)paren
(brace
id|buf_len
op_assign
id|min_t
c_func
(paren
r_uint32
comma
id|buf_size
comma
id|jeb-&gt;offset
op_plus
id|c-&gt;sector_size
op_minus
id|ofs
)paren
suffix:semicolon
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Fewer than %d bytes (dirent node) left to end of buf. Reading 0x%x at 0x%08x&bslash;n&quot;
comma
id|je32_to_cpu
c_func
(paren
id|node-&gt;totlen
)paren
comma
id|buf_len
comma
id|ofs
)paren
)paren
suffix:semicolon
id|err
op_assign
id|jffs2_fill_scan_buf
c_func
(paren
id|c
comma
id|buf
comma
id|ofs
comma
id|buf_len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
id|buf_ofs
op_assign
id|ofs
suffix:semicolon
id|node
op_assign
(paren
r_void
op_star
)paren
id|buf
suffix:semicolon
)brace
id|err
op_assign
id|jffs2_scan_dirent_node
c_func
(paren
id|c
comma
id|jeb
comma
(paren
r_void
op_star
)paren
id|node
comma
id|ofs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
id|ofs
op_add_assign
id|PAD
c_func
(paren
id|je32_to_cpu
c_func
(paren
id|node-&gt;totlen
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|JFFS2_NODETYPE_CLEANMARKER
suffix:colon
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;CLEANMARKER node found at 0x%08x&bslash;n&quot;
comma
id|ofs
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|je32_to_cpu
c_func
(paren
id|node-&gt;totlen
)paren
op_ne
id|c-&gt;cleanmarker_size
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;CLEANMARKER node found at 0x%08x has totlen 0x%x != normal 0x%x&bslash;n&quot;
comma
id|ofs
comma
id|je32_to_cpu
c_func
(paren
id|node-&gt;totlen
)paren
comma
id|c-&gt;cleanmarker_size
)paren
suffix:semicolon
id|DIRTY_SPACE
c_func
(paren
id|PAD
c_func
(paren
r_sizeof
(paren
r_struct
id|jffs2_unknown_node
)paren
)paren
)paren
suffix:semicolon
id|ofs
op_add_assign
id|PAD
c_func
(paren
r_sizeof
(paren
r_struct
id|jffs2_unknown_node
)paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|jeb-&gt;first_node
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;CLEANMARKER node found at 0x%08x, not first node in block (0x%08x)&bslash;n&quot;
comma
id|ofs
comma
id|jeb-&gt;offset
)paren
suffix:semicolon
id|DIRTY_SPACE
c_func
(paren
id|PAD
c_func
(paren
r_sizeof
(paren
r_struct
id|jffs2_unknown_node
)paren
)paren
)paren
suffix:semicolon
id|ofs
op_add_assign
id|PAD
c_func
(paren
r_sizeof
(paren
r_struct
id|jffs2_unknown_node
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
r_struct
id|jffs2_raw_node_ref
op_star
id|marker_ref
op_assign
id|jffs2_alloc_raw_node_ref
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|marker_ref
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;Failed to allocate node ref for clean marker&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|marker_ref-&gt;next_in_ino
op_assign
l_int|NULL
suffix:semicolon
id|marker_ref-&gt;next_phys
op_assign
l_int|NULL
suffix:semicolon
id|marker_ref-&gt;flash_offset
op_assign
id|ofs
op_or
id|REF_NORMAL
suffix:semicolon
id|marker_ref-&gt;totlen
op_assign
id|c-&gt;cleanmarker_size
suffix:semicolon
id|jeb-&gt;first_node
op_assign
id|jeb-&gt;last_node
op_assign
id|marker_ref
suffix:semicolon
id|USED_SPACE
c_func
(paren
id|PAD
c_func
(paren
id|c-&gt;cleanmarker_size
)paren
)paren
suffix:semicolon
id|ofs
op_add_assign
id|PAD
c_func
(paren
id|c-&gt;cleanmarker_size
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|JFFS2_NODETYPE_PADDING
suffix:colon
id|DIRTY_SPACE
c_func
(paren
id|PAD
c_func
(paren
id|je32_to_cpu
c_func
(paren
id|node-&gt;totlen
)paren
)paren
)paren
suffix:semicolon
id|ofs
op_add_assign
id|PAD
c_func
(paren
id|je32_to_cpu
c_func
(paren
id|node-&gt;totlen
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
r_switch
c_cond
(paren
id|je16_to_cpu
c_func
(paren
id|node-&gt;nodetype
)paren
op_amp
id|JFFS2_COMPAT_MASK
)paren
(brace
r_case
id|JFFS2_FEATURE_ROCOMPAT
suffix:colon
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;Read-only compatible feature node (0x%04x) found at offset 0x%08x&bslash;n&quot;
comma
id|je16_to_cpu
c_func
(paren
id|node-&gt;nodetype
)paren
comma
id|ofs
)paren
suffix:semicolon
id|c-&gt;flags
op_or_assign
id|JFFS2_SB_FLAG_RO
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|jffs2_is_readonly
c_func
(paren
id|c
)paren
)paren
)paren
r_return
op_minus
id|EROFS
suffix:semicolon
id|DIRTY_SPACE
c_func
(paren
id|PAD
c_func
(paren
id|je32_to_cpu
c_func
(paren
id|node-&gt;totlen
)paren
)paren
)paren
suffix:semicolon
id|ofs
op_add_assign
id|PAD
c_func
(paren
id|je32_to_cpu
c_func
(paren
id|node-&gt;totlen
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|JFFS2_FEATURE_INCOMPAT
suffix:colon
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;Incompatible feature node (0x%04x) found at offset 0x%08x&bslash;n&quot;
comma
id|je16_to_cpu
c_func
(paren
id|node-&gt;nodetype
)paren
comma
id|ofs
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
r_case
id|JFFS2_FEATURE_RWCOMPAT_DELETE
suffix:colon
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;Unknown but compatible feature node (0x%04x) found at offset 0x%08x&bslash;n&quot;
comma
id|je16_to_cpu
c_func
(paren
id|node-&gt;nodetype
)paren
comma
id|ofs
)paren
)paren
suffix:semicolon
id|DIRTY_SPACE
c_func
(paren
id|PAD
c_func
(paren
id|je32_to_cpu
c_func
(paren
id|node-&gt;totlen
)paren
)paren
)paren
suffix:semicolon
id|ofs
op_add_assign
id|PAD
c_func
(paren
id|je32_to_cpu
c_func
(paren
id|node-&gt;totlen
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|JFFS2_FEATURE_RWCOMPAT_COPY
suffix:colon
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;Unknown but compatible feature node (0x%04x) found at offset 0x%08x&bslash;n&quot;
comma
id|je16_to_cpu
c_func
(paren
id|node-&gt;nodetype
)paren
comma
id|ofs
)paren
)paren
suffix:semicolon
id|USED_SPACE
c_func
(paren
id|PAD
c_func
(paren
id|je32_to_cpu
c_func
(paren
id|node-&gt;totlen
)paren
)paren
)paren
suffix:semicolon
id|ofs
op_add_assign
id|PAD
c_func
(paren
id|je32_to_cpu
c_func
(paren
id|node-&gt;totlen
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Block at 0x%08x: free 0x%08x, dirty 0x%08x, unchecked 0x%08x, used 0x%08x&bslash;n&quot;
comma
id|jeb-&gt;offset
comma
id|jeb-&gt;free_size
comma
id|jeb-&gt;dirty_size
comma
id|jeb-&gt;unchecked_size
comma
id|jeb-&gt;used_size
)paren
)paren
suffix:semicolon
multiline_comment|/* mark_node_obsolete can add to wasted !! */
r_if
c_cond
(paren
id|jeb-&gt;wasted_size
)paren
(brace
id|jeb-&gt;dirty_size
op_add_assign
id|jeb-&gt;wasted_size
suffix:semicolon
id|c-&gt;dirty_size
op_add_assign
id|jeb-&gt;wasted_size
suffix:semicolon
id|c-&gt;wasted_size
op_sub_assign
id|jeb-&gt;wasted_size
suffix:semicolon
id|jeb-&gt;wasted_size
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|jeb-&gt;used_size
op_plus
id|jeb-&gt;unchecked_size
)paren
op_eq
id|PAD
c_func
(paren
id|c-&gt;cleanmarker_size
)paren
op_logical_and
op_logical_neg
id|jeb-&gt;dirty_size
op_logical_and
(paren
op_logical_neg
id|jeb-&gt;first_node
op_logical_or
id|jeb-&gt;first_node-&gt;next_in_ino
)paren
)paren
r_return
id|BLK_STATE_CLEANMARKER
suffix:semicolon
multiline_comment|/* move blocks with max 4 byte dirty space to cleanlist */
r_else
r_if
c_cond
(paren
op_logical_neg
id|ISDIRTY
c_func
(paren
id|c-&gt;sector_size
op_minus
(paren
id|jeb-&gt;used_size
op_plus
id|jeb-&gt;unchecked_size
)paren
)paren
)paren
(brace
id|c-&gt;dirty_size
op_sub_assign
id|jeb-&gt;dirty_size
suffix:semicolon
id|c-&gt;wasted_size
op_add_assign
id|jeb-&gt;dirty_size
suffix:semicolon
id|jeb-&gt;wasted_size
op_add_assign
id|jeb-&gt;dirty_size
suffix:semicolon
id|jeb-&gt;dirty_size
op_assign
l_int|0
suffix:semicolon
r_return
id|BLK_STATE_CLEAN
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|jeb-&gt;used_size
op_logical_or
id|jeb-&gt;unchecked_size
)paren
r_return
id|BLK_STATE_PARTDIRTY
suffix:semicolon
r_else
r_return
id|BLK_STATE_ALLDIRTY
suffix:semicolon
)brace
DECL|function|jffs2_scan_make_ino_cache
r_static
r_struct
id|jffs2_inode_cache
op_star
id|jffs2_scan_make_ino_cache
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
comma
r_uint32
id|ino
)paren
(brace
r_struct
id|jffs2_inode_cache
op_star
id|ic
suffix:semicolon
id|ic
op_assign
id|jffs2_get_ino_cache
c_func
(paren
id|c
comma
id|ino
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ic
)paren
r_return
id|ic
suffix:semicolon
id|ic
op_assign
id|jffs2_alloc_inode_cache
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ic
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;jffs2_scan_make_inode_cache(): allocation of inode cache failed&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|memset
c_func
(paren
id|ic
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|ic
)paren
)paren
suffix:semicolon
id|ic-&gt;ino
op_assign
id|ino
suffix:semicolon
id|ic-&gt;nodes
op_assign
(paren
r_void
op_star
)paren
id|ic
suffix:semicolon
id|jffs2_add_ino_cache
c_func
(paren
id|c
comma
id|ic
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ino
op_eq
l_int|1
)paren
id|ic-&gt;nlink
op_assign
l_int|1
suffix:semicolon
r_return
id|ic
suffix:semicolon
)brace
DECL|function|jffs2_scan_inode_node
r_static
r_int
id|jffs2_scan_inode_node
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
comma
r_struct
id|jffs2_eraseblock
op_star
id|jeb
comma
r_struct
id|jffs2_raw_inode
op_star
id|ri
comma
r_uint32
id|ofs
)paren
(brace
r_struct
id|jffs2_raw_node_ref
op_star
id|raw
suffix:semicolon
r_struct
id|jffs2_inode_cache
op_star
id|ic
suffix:semicolon
r_uint32
id|ino
op_assign
id|je32_to_cpu
c_func
(paren
id|ri-&gt;ino
)paren
suffix:semicolon
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;jffs2_scan_inode_node(): Node at 0x%08x&bslash;n&quot;
comma
id|ofs
)paren
)paren
suffix:semicolon
multiline_comment|/* We do very little here now. Just check the ino# to which we should attribute&n;&t;   this node; we can do all the CRC checking etc. later. There&squot;s a tradeoff here -- &n;&t;   we used to scan the flash once only, reading everything we want from it into&n;&t;   memory, then building all our in-core data structures and freeing the extra&n;&t;   information. Now we allow the first part of the mount to complete a lot quicker,&n;&t;   but we have to go _back_ to the flash in order to finish the CRC checking, etc. &n;&t;   Which means that the _full_ amount of time to get to proper write mode with GC&n;&t;   operational may actually be _longer_ than before. Sucks to be me. */
id|raw
op_assign
id|jffs2_alloc_raw_node_ref
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|raw
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;jffs2_scan_inode_node(): allocation of node reference failed&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|ic
op_assign
id|jffs2_get_ino_cache
c_func
(paren
id|c
comma
id|ino
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ic
)paren
(brace
multiline_comment|/* Inocache get failed. Either we read a bogus ino# or it&squot;s just genuinely the&n;&t;&t;   first node we found for this inode. Do a CRC check to protect against the former&n;&t;&t;   case */
r_uint32
id|crc
op_assign
id|crc32
c_func
(paren
l_int|0
comma
id|ri
comma
r_sizeof
(paren
op_star
id|ri
)paren
op_minus
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
id|crc
op_ne
id|je32_to_cpu
c_func
(paren
id|ri-&gt;node_crc
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;jffs2_scan_inode_node(): CRC failed on node at 0x%08x: Read 0x%08x, calculated 0x%08x&bslash;n&quot;
comma
id|ofs
comma
id|je32_to_cpu
c_func
(paren
id|ri-&gt;node_crc
)paren
comma
id|crc
)paren
suffix:semicolon
multiline_comment|/* We believe totlen because the CRC on the node _header_ was OK, just the node itself failed. */
id|DIRTY_SPACE
c_func
(paren
id|PAD
c_func
(paren
id|je32_to_cpu
c_func
(paren
id|ri-&gt;totlen
)paren
)paren
)paren
suffix:semicolon
id|jffs2_free_raw_node_ref
c_func
(paren
id|raw
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|ic
op_assign
id|jffs2_scan_make_ino_cache
c_func
(paren
id|c
comma
id|ino
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ic
)paren
(brace
id|jffs2_free_raw_node_ref
c_func
(paren
id|raw
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
)brace
multiline_comment|/* Wheee. It worked */
id|raw-&gt;flash_offset
op_assign
id|ofs
op_or
id|REF_UNCHECKED
suffix:semicolon
id|raw-&gt;totlen
op_assign
id|PAD
c_func
(paren
id|je32_to_cpu
c_func
(paren
id|ri-&gt;totlen
)paren
)paren
suffix:semicolon
id|raw-&gt;next_phys
op_assign
l_int|NULL
suffix:semicolon
id|raw-&gt;next_in_ino
op_assign
id|ic-&gt;nodes
suffix:semicolon
id|ic-&gt;nodes
op_assign
id|raw
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|jeb-&gt;first_node
)paren
id|jeb-&gt;first_node
op_assign
id|raw
suffix:semicolon
r_if
c_cond
(paren
id|jeb-&gt;last_node
)paren
id|jeb-&gt;last_node-&gt;next_phys
op_assign
id|raw
suffix:semicolon
id|jeb-&gt;last_node
op_assign
id|raw
suffix:semicolon
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Node is ino #%u, version %d. Range 0x%x-0x%x&bslash;n&quot;
comma
id|je32_to_cpu
c_func
(paren
id|ri-&gt;ino
)paren
comma
id|je32_to_cpu
c_func
(paren
id|ri-&gt;version
)paren
comma
id|je32_to_cpu
c_func
(paren
id|ri-&gt;offset
)paren
comma
id|je32_to_cpu
c_func
(paren
id|ri-&gt;offset
)paren
op_plus
id|je32_to_cpu
c_func
(paren
id|ri-&gt;dsize
)paren
)paren
)paren
suffix:semicolon
id|pseudo_random
op_add_assign
id|je32_to_cpu
c_func
(paren
id|ri-&gt;version
)paren
suffix:semicolon
id|UNCHECKED_SPACE
c_func
(paren
id|PAD
c_func
(paren
id|je32_to_cpu
c_func
(paren
id|ri-&gt;totlen
)paren
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|jffs2_scan_dirent_node
r_static
r_int
id|jffs2_scan_dirent_node
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
comma
r_struct
id|jffs2_eraseblock
op_star
id|jeb
comma
r_struct
id|jffs2_raw_dirent
op_star
id|rd
comma
r_uint32
id|ofs
)paren
(brace
r_struct
id|jffs2_raw_node_ref
op_star
id|raw
suffix:semicolon
r_struct
id|jffs2_full_dirent
op_star
id|fd
suffix:semicolon
r_struct
id|jffs2_inode_cache
op_star
id|ic
suffix:semicolon
r_uint32
id|crc
suffix:semicolon
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;jffs2_scan_dirent_node(): Node at 0x%08x&bslash;n&quot;
comma
id|ofs
)paren
)paren
suffix:semicolon
multiline_comment|/* We don&squot;t get here unless the node is still valid, so we don&squot;t have to&n;&t;   mask in the ACCURATE bit any more. */
id|crc
op_assign
id|crc32
c_func
(paren
l_int|0
comma
id|rd
comma
r_sizeof
(paren
op_star
id|rd
)paren
op_minus
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
id|crc
op_ne
id|je32_to_cpu
c_func
(paren
id|rd-&gt;node_crc
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;jffs2_scan_dirent_node(): Node CRC failed on node at 0x%08x: Read 0x%08x, calculated 0x%08x&bslash;n&quot;
comma
id|ofs
comma
id|je32_to_cpu
c_func
(paren
id|rd-&gt;node_crc
)paren
comma
id|crc
)paren
suffix:semicolon
multiline_comment|/* We believe totlen because the CRC on the node _header_ was OK, just the node itself failed. */
id|DIRTY_SPACE
c_func
(paren
id|PAD
c_func
(paren
id|je32_to_cpu
c_func
(paren
id|rd-&gt;totlen
)paren
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|pseudo_random
op_add_assign
id|je32_to_cpu
c_func
(paren
id|rd-&gt;version
)paren
suffix:semicolon
id|fd
op_assign
id|jffs2_alloc_full_dirent
c_func
(paren
id|rd-&gt;nsize
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fd
)paren
(brace
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|memcpy
c_func
(paren
op_amp
id|fd-&gt;name
comma
id|rd-&gt;name
comma
id|rd-&gt;nsize
)paren
suffix:semicolon
id|fd-&gt;name
(braket
id|rd-&gt;nsize
)braket
op_assign
l_int|0
suffix:semicolon
id|crc
op_assign
id|crc32
c_func
(paren
l_int|0
comma
id|fd-&gt;name
comma
id|rd-&gt;nsize
)paren
suffix:semicolon
r_if
c_cond
(paren
id|crc
op_ne
id|je32_to_cpu
c_func
(paren
id|rd-&gt;name_crc
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;jffs2_scan_dirent_node(): Name CRC failed on node at 0x%08x: Read 0x%08x, calculated 0x%08x&bslash;n&quot;
comma
id|ofs
comma
id|je32_to_cpu
c_func
(paren
id|rd-&gt;name_crc
)paren
comma
id|crc
)paren
suffix:semicolon
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;Name for which CRC failed is (now) &squot;%s&squot;, ino #%d&bslash;n&quot;
comma
id|fd-&gt;name
comma
id|je32_to_cpu
c_func
(paren
id|rd-&gt;ino
)paren
)paren
)paren
suffix:semicolon
id|jffs2_free_full_dirent
c_func
(paren
id|fd
)paren
suffix:semicolon
multiline_comment|/* FIXME: Why do we believe totlen? */
multiline_comment|/* We believe totlen because the CRC on the node _header_ was OK, just the name failed. */
id|DIRTY_SPACE
c_func
(paren
id|PAD
c_func
(paren
id|je32_to_cpu
c_func
(paren
id|rd-&gt;totlen
)paren
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|raw
op_assign
id|jffs2_alloc_raw_node_ref
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|raw
)paren
(brace
id|jffs2_free_full_dirent
c_func
(paren
id|fd
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;jffs2_scan_dirent_node(): allocation of node reference failed&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|ic
op_assign
id|jffs2_scan_make_ino_cache
c_func
(paren
id|c
comma
id|je32_to_cpu
c_func
(paren
id|rd-&gt;pino
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ic
)paren
(brace
id|jffs2_free_full_dirent
c_func
(paren
id|fd
)paren
suffix:semicolon
id|jffs2_free_raw_node_ref
c_func
(paren
id|raw
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|raw-&gt;totlen
op_assign
id|PAD
c_func
(paren
id|je32_to_cpu
c_func
(paren
id|rd-&gt;totlen
)paren
)paren
suffix:semicolon
id|raw-&gt;flash_offset
op_assign
id|ofs
op_or
id|REF_PRISTINE
suffix:semicolon
id|raw-&gt;next_phys
op_assign
l_int|NULL
suffix:semicolon
id|raw-&gt;next_in_ino
op_assign
id|ic-&gt;nodes
suffix:semicolon
id|ic-&gt;nodes
op_assign
id|raw
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|jeb-&gt;first_node
)paren
id|jeb-&gt;first_node
op_assign
id|raw
suffix:semicolon
r_if
c_cond
(paren
id|jeb-&gt;last_node
)paren
id|jeb-&gt;last_node-&gt;next_phys
op_assign
id|raw
suffix:semicolon
id|jeb-&gt;last_node
op_assign
id|raw
suffix:semicolon
id|fd-&gt;raw
op_assign
id|raw
suffix:semicolon
id|fd-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|fd-&gt;version
op_assign
id|je32_to_cpu
c_func
(paren
id|rd-&gt;version
)paren
suffix:semicolon
id|fd-&gt;ino
op_assign
id|je32_to_cpu
c_func
(paren
id|rd-&gt;ino
)paren
suffix:semicolon
id|fd-&gt;nhash
op_assign
id|full_name_hash
c_func
(paren
id|fd-&gt;name
comma
id|rd-&gt;nsize
)paren
suffix:semicolon
id|fd-&gt;type
op_assign
id|rd-&gt;type
suffix:semicolon
id|USED_SPACE
c_func
(paren
id|PAD
c_func
(paren
id|je32_to_cpu
c_func
(paren
id|rd-&gt;totlen
)paren
)paren
)paren
suffix:semicolon
id|jffs2_add_fd_to_list
c_func
(paren
id|c
comma
id|fd
comma
op_amp
id|ic-&gt;scan_dents
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|count_list
r_static
r_int
id|count_list
c_func
(paren
r_struct
id|list_head
op_star
id|l
)paren
(brace
r_uint32
id|count
op_assign
l_int|0
suffix:semicolon
r_struct
id|list_head
op_star
id|tmp
suffix:semicolon
id|list_for_each
c_func
(paren
id|tmp
comma
id|l
)paren
(brace
id|count
op_increment
suffix:semicolon
)brace
r_return
id|count
suffix:semicolon
)brace
multiline_comment|/* Note: This breaks if list_empty(head). I don&squot;t care. You&n;   might, if you copy this code and use it elsewhere :) */
DECL|function|rotate_list
r_static
r_void
id|rotate_list
c_func
(paren
r_struct
id|list_head
op_star
id|head
comma
r_uint32
id|count
)paren
(brace
r_struct
id|list_head
op_star
id|n
op_assign
id|head-&gt;next
suffix:semicolon
id|list_del
c_func
(paren
id|head
)paren
suffix:semicolon
r_while
c_loop
(paren
id|count
op_decrement
)paren
(brace
id|n
op_assign
id|n-&gt;next
suffix:semicolon
)brace
id|list_add
c_func
(paren
id|head
comma
id|n
)paren
suffix:semicolon
)brace
DECL|function|jffs2_rotate_lists
r_void
id|jffs2_rotate_lists
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
)paren
(brace
r_uint32
id|x
suffix:semicolon
r_uint32
id|rotateby
suffix:semicolon
id|x
op_assign
id|count_list
c_func
(paren
op_amp
id|c-&gt;clean_list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|x
)paren
(brace
id|rotateby
op_assign
id|pseudo_random
op_mod
id|x
suffix:semicolon
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Rotating clean_list by %d&bslash;n&quot;
comma
id|rotateby
)paren
)paren
suffix:semicolon
id|rotate_list
c_func
(paren
(paren
op_amp
id|c-&gt;clean_list
)paren
comma
id|rotateby
)paren
suffix:semicolon
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Erase block at front of clean_list is at %08x&bslash;n&quot;
comma
id|list_entry
c_func
(paren
id|c-&gt;clean_list.next
comma
r_struct
id|jffs2_eraseblock
comma
id|list
)paren
op_member_access_from_pointer
id|offset
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Not rotating empty clean_list&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
id|x
op_assign
id|count_list
c_func
(paren
op_amp
id|c-&gt;very_dirty_list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|x
)paren
(brace
id|rotateby
op_assign
id|pseudo_random
op_mod
id|x
suffix:semicolon
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Rotating very_dirty_list by %d&bslash;n&quot;
comma
id|rotateby
)paren
)paren
suffix:semicolon
id|rotate_list
c_func
(paren
(paren
op_amp
id|c-&gt;very_dirty_list
)paren
comma
id|rotateby
)paren
suffix:semicolon
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Erase block at front of very_dirty_list is at %08x&bslash;n&quot;
comma
id|list_entry
c_func
(paren
id|c-&gt;very_dirty_list.next
comma
r_struct
id|jffs2_eraseblock
comma
id|list
)paren
op_member_access_from_pointer
id|offset
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Not rotating empty very_dirty_list&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
id|x
op_assign
id|count_list
c_func
(paren
op_amp
id|c-&gt;dirty_list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|x
)paren
(brace
id|rotateby
op_assign
id|pseudo_random
op_mod
id|x
suffix:semicolon
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Rotating dirty_list by %d&bslash;n&quot;
comma
id|rotateby
)paren
)paren
suffix:semicolon
id|rotate_list
c_func
(paren
(paren
op_amp
id|c-&gt;dirty_list
)paren
comma
id|rotateby
)paren
suffix:semicolon
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Erase block at front of dirty_list is at %08x&bslash;n&quot;
comma
id|list_entry
c_func
(paren
id|c-&gt;dirty_list.next
comma
r_struct
id|jffs2_eraseblock
comma
id|list
)paren
op_member_access_from_pointer
id|offset
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Not rotating empty dirty_list&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
id|x
op_assign
id|count_list
c_func
(paren
op_amp
id|c-&gt;erasable_list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|x
)paren
(brace
id|rotateby
op_assign
id|pseudo_random
op_mod
id|x
suffix:semicolon
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Rotating erasable_list by %d&bslash;n&quot;
comma
id|rotateby
)paren
)paren
suffix:semicolon
id|rotate_list
c_func
(paren
(paren
op_amp
id|c-&gt;erasable_list
)paren
comma
id|rotateby
)paren
suffix:semicolon
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Erase block at front of erasable_list is at %08x&bslash;n&quot;
comma
id|list_entry
c_func
(paren
id|c-&gt;erasable_list.next
comma
r_struct
id|jffs2_eraseblock
comma
id|list
)paren
op_member_access_from_pointer
id|offset
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Not rotating empty erasable_list&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|c-&gt;nr_erasing_blocks
)paren
(brace
id|rotateby
op_assign
id|pseudo_random
op_mod
id|c-&gt;nr_erasing_blocks
suffix:semicolon
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Rotating erase_pending_list by %d&bslash;n&quot;
comma
id|rotateby
)paren
)paren
suffix:semicolon
id|rotate_list
c_func
(paren
(paren
op_amp
id|c-&gt;erase_pending_list
)paren
comma
id|rotateby
)paren
suffix:semicolon
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Erase block at front of erase_pending_list is at %08x&bslash;n&quot;
comma
id|list_entry
c_func
(paren
id|c-&gt;erase_pending_list.next
comma
r_struct
id|jffs2_eraseblock
comma
id|list
)paren
op_member_access_from_pointer
id|offset
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Not rotating empty erase_pending_list&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|c-&gt;nr_free_blocks
)paren
(brace
id|rotateby
op_assign
id|pseudo_random
op_mod
id|c-&gt;nr_free_blocks
suffix:semicolon
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Rotating free_list by %d&bslash;n&quot;
comma
id|rotateby
)paren
)paren
suffix:semicolon
id|rotate_list
c_func
(paren
(paren
op_amp
id|c-&gt;free_list
)paren
comma
id|rotateby
)paren
suffix:semicolon
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Erase block at front of free_list is at %08x&bslash;n&quot;
comma
id|list_entry
c_func
(paren
id|c-&gt;free_list.next
comma
r_struct
id|jffs2_eraseblock
comma
id|list
)paren
op_member_access_from_pointer
id|offset
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Not rotating empty free_list&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
)brace
eof
