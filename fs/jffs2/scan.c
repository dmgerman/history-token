multiline_comment|/*&n; * JFFS2 -- Journalling Flash File System, Version 2.&n; *&n; * Copyright (C) 2001, 2002 Red Hat, Inc.&n; *&n; * Created by David Woodhouse &lt;dwmw2@cambridge.redhat.com&gt;&n; *&n; * The original JFFS, from which the design for JFFS2 was derived,&n; * was designed and implemented by Axis Communications AB.&n; *&n; * The contents of this file are subject to the Red Hat eCos Public&n; * License Version 1.1 (the &quot;Licence&quot;); you may not use this file&n; * except in compliance with the Licence.  You may obtain a copy of&n; * the Licence at http://www.redhat.com/&n; *&n; * Software distributed under the Licence is distributed on an &quot;AS IS&quot;&n; * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.&n; * See the Licence for the specific language governing rights and&n; * limitations under the Licence.&n; *&n; * The Original Code is JFFS2 - Journalling Flash File System, version 2&n; *&n; * Alternatively, the contents of this file may be used under the&n; * terms of the GNU General Public License version 2 (the &quot;GPL&quot;), in&n; * which case the provisions of the GPL are applicable instead of the&n; * above.  If you wish to allow the use of your version of this file&n; * only under the terms of the GPL and not to allow others to use your&n; * version of this file under the RHEPL, indicate your decision by&n; * deleting the provisions above and replace them with the notice and&n; * other provisions required by the GPL.  If you do not delete the&n; * provisions above, a recipient may use your version of this file&n; * under either the RHEPL or the GPL.&n; *&n; * $Id: scan.c,v 1.69 2002/03/08 11:03:23 dwmw2 Exp $&n; *&n; */
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/mtd/mtd.h&gt;
macro_line|#include &lt;linux/pagemap.h&gt;
macro_line|#include &lt;linux/crc32.h&gt;
macro_line|#include &quot;nodelist.h&quot;
DECL|macro|DIRTY_SPACE
mdefine_line|#define DIRTY_SPACE(x) do { typeof(x) _x = (x); &bslash;&n;&t;&t;c-&gt;free_size -= _x; c-&gt;dirty_size += _x; &bslash;&n;&t;&t;jeb-&gt;free_size -= _x ; jeb-&gt;dirty_size += _x; &bslash;&n;&t;&t;}while(0)
DECL|macro|USED_SPACE
mdefine_line|#define USED_SPACE(x) do { typeof(x) _x = (x); &bslash;&n;&t;&t;c-&gt;free_size -= _x; c-&gt;used_size += _x; &bslash;&n;&t;&t;jeb-&gt;free_size -= _x ; jeb-&gt;used_size += _x; &bslash;&n;&t;&t;}while(0)
DECL|macro|noisy_printk
mdefine_line|#define noisy_printk(noise, args...) do { &bslash;&n;&t;if (*(noise)) { &bslash;&n;&t;&t;printk(KERN_NOTICE args); &bslash;&n;&t;&t; (*(noise))--; &bslash;&n;&t;&t; if (!(*(noise))) { &bslash;&n;&t;&t;&t; printk(KERN_NOTICE &quot;Further such events for this erase block will not be printed&bslash;n&quot;); &bslash;&n;&t;&t; } &bslash;&n;&t;} &bslash;&n;} while(0)
DECL|variable|pseudo_random
r_static
r_uint32
id|pseudo_random
suffix:semicolon
r_static
r_void
id|jffs2_rotate_lists
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
)paren
suffix:semicolon
r_static
r_int
id|jffs2_scan_eraseblock
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
comma
r_struct
id|jffs2_eraseblock
op_star
id|jeb
)paren
suffix:semicolon
multiline_comment|/* These helper functions _must_ increase ofs and also do the dirty/used space accounting. &n; * Returning an error will abort the mount - bad checksums etc. should just mark the space&n; * as dirty.&n; */
r_static
r_int
id|jffs2_scan_empty
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
comma
r_struct
id|jffs2_eraseblock
op_star
id|jeb
comma
r_uint32
op_star
id|ofs
comma
r_int
op_star
id|noise
)paren
suffix:semicolon
r_static
r_int
id|jffs2_scan_inode_node
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
comma
r_struct
id|jffs2_eraseblock
op_star
id|jeb
comma
r_uint32
op_star
id|ofs
)paren
suffix:semicolon
r_static
r_int
id|jffs2_scan_dirent_node
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
comma
r_struct
id|jffs2_eraseblock
op_star
id|jeb
comma
r_uint32
op_star
id|ofs
)paren
suffix:semicolon
DECL|macro|BLK_STATE_ALLFF
mdefine_line|#define BLK_STATE_ALLFF&t;&t;0
DECL|macro|BLK_STATE_CLEAN
mdefine_line|#define BLK_STATE_CLEAN&t;&t;1
DECL|macro|BLK_STATE_PARTDIRTY
mdefine_line|#define BLK_STATE_PARTDIRTY&t;2
DECL|macro|BLK_STATE_CLEANMARKER
mdefine_line|#define BLK_STATE_CLEANMARKER&t;3
DECL|macro|BLK_STATE_ALLDIRTY
mdefine_line|#define BLK_STATE_ALLDIRTY&t;4
DECL|macro|BLK_STATE_BADBLOCK
mdefine_line|#define BLK_STATE_BADBLOCK&t;5
DECL|function|jffs2_scan_medium
r_int
id|jffs2_scan_medium
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
)paren
(brace
r_int
id|i
comma
id|ret
suffix:semicolon
r_uint32
id|empty_blocks
op_assign
l_int|0
comma
id|bad_blocks
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|c-&gt;blocks
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;EEEK! c-&gt;blocks is NULL!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|c-&gt;nr_blocks
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|jffs2_eraseblock
op_star
id|jeb
op_assign
op_amp
id|c-&gt;blocks
(braket
id|i
)braket
suffix:semicolon
id|ret
op_assign
id|jffs2_scan_eraseblock
c_func
(paren
id|c
comma
id|jeb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
r_return
id|ret
suffix:semicolon
id|ACCT_PARANOIA_CHECK
c_func
(paren
id|jeb
)paren
suffix:semicolon
multiline_comment|/* Now decide which list to put it on */
r_switch
c_cond
(paren
id|ret
)paren
(brace
r_case
id|BLK_STATE_ALLFF
suffix:colon
multiline_comment|/* &n;&t;&t;&t; * Empty block.   Since we can&squot;t be sure it &n;&t;&t;&t; * was entirely erased, we just queue it for erase&n;&t;&t;&t; * again.  It will be marked as such when the erase&n;&t;&t;&t; * is complete.  Meanwhile we still count it as empty&n;&t;&t;&t; * for later checks.&n;&t;&t;&t; */
id|empty_blocks
op_increment
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|jeb-&gt;list
comma
op_amp
id|c-&gt;erase_pending_list
)paren
suffix:semicolon
id|c-&gt;nr_erasing_blocks
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BLK_STATE_CLEANMARKER
suffix:colon
multiline_comment|/* Only a CLEANMARKER node is valid */
r_if
c_cond
(paren
op_logical_neg
id|jeb-&gt;dirty_size
)paren
(brace
multiline_comment|/* It&squot;s actually free */
id|list_add
c_func
(paren
op_amp
id|jeb-&gt;list
comma
op_amp
id|c-&gt;free_list
)paren
suffix:semicolon
id|c-&gt;nr_free_blocks
op_increment
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Dirt */
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Adding all-dirty block at 0x%08x to erase_pending_list&bslash;n&quot;
comma
id|jeb-&gt;offset
)paren
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|jeb-&gt;list
comma
op_amp
id|c-&gt;erase_pending_list
)paren
suffix:semicolon
id|c-&gt;nr_erasing_blocks
op_increment
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|BLK_STATE_CLEAN
suffix:colon
multiline_comment|/* Full (or almost full) of clean data. Clean list */
id|list_add
c_func
(paren
op_amp
id|jeb-&gt;list
comma
op_amp
id|c-&gt;clean_list
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BLK_STATE_PARTDIRTY
suffix:colon
multiline_comment|/* Some data, but not full. Dirty list. */
multiline_comment|/* Except that we want to remember the block with most free space,&n;                           and stick it in the &squot;nextblock&squot; position to start writing to it.&n;                           Later when we do snapshots, this must be the most recent block,&n;                           not the one with most free space.&n;                        */
r_if
c_cond
(paren
id|jeb-&gt;free_size
OG
l_int|2
op_star
r_sizeof
(paren
r_struct
id|jffs2_raw_inode
)paren
op_logical_and
(paren
op_logical_neg
id|c-&gt;nextblock
op_logical_or
id|c-&gt;nextblock-&gt;free_size
OL
id|jeb-&gt;free_size
)paren
)paren
(brace
multiline_comment|/* Better candidate for the next writes to go to */
r_if
c_cond
(paren
id|c-&gt;nextblock
)paren
id|list_add
c_func
(paren
op_amp
id|c-&gt;nextblock-&gt;list
comma
op_amp
id|c-&gt;dirty_list
)paren
suffix:semicolon
id|c-&gt;nextblock
op_assign
id|jeb
suffix:semicolon
)brace
r_else
(brace
id|list_add
c_func
(paren
op_amp
id|jeb-&gt;list
comma
op_amp
id|c-&gt;dirty_list
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|BLK_STATE_ALLDIRTY
suffix:colon
multiline_comment|/* Nothing valid - not even a clean marker. Needs erasing. */
multiline_comment|/* For now we just put it on the erasing list. We&squot;ll start the erases later */
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;JFFS2: Erase block at 0x%08x is not formatted. It will be erased&bslash;n&quot;
comma
id|jeb-&gt;offset
)paren
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|jeb-&gt;list
comma
op_amp
id|c-&gt;erase_pending_list
)paren
suffix:semicolon
id|c-&gt;nr_erasing_blocks
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BLK_STATE_BADBLOCK
suffix:colon
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;JFFS2: Block at 0x%08x is bad&bslash;n&quot;
comma
id|jeb-&gt;offset
)paren
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|jeb-&gt;list
comma
op_amp
id|c-&gt;bad_list
)paren
suffix:semicolon
id|c-&gt;bad_size
op_add_assign
id|c-&gt;sector_size
suffix:semicolon
id|c-&gt;free_size
op_sub_assign
id|c-&gt;sector_size
suffix:semicolon
id|bad_blocks
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;jffs2_scan_medium(): unknown block state&bslash;n&quot;
)paren
suffix:semicolon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Rotate the lists by some number to ensure wear levelling */
id|jffs2_rotate_lists
c_func
(paren
id|c
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c-&gt;nr_erasing_blocks
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|c-&gt;used_size
op_logical_and
(paren
(paren
id|empty_blocks
op_plus
id|bad_blocks
)paren
op_ne
id|c-&gt;nr_blocks
op_logical_or
id|bad_blocks
op_eq
id|c-&gt;nr_blocks
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;Cowardly refusing to erase blocks on filesystem with no valid JFFS2 nodes&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;empty_blocks %d, bad_blocks %d, c-&gt;nr_blocks %d&bslash;n&quot;
comma
id|empty_blocks
comma
id|bad_blocks
comma
id|c-&gt;nr_blocks
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|jffs2_erase_pending_trigger
c_func
(paren
id|c
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|jffs2_scan_eraseblock
r_static
r_int
id|jffs2_scan_eraseblock
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
comma
r_struct
id|jffs2_eraseblock
op_star
id|jeb
)paren
(brace
r_struct
id|jffs2_unknown_node
id|node
suffix:semicolon
r_uint32
id|ofs
comma
id|prevofs
suffix:semicolon
r_uint32
id|hdr_crc
comma
id|nodetype
suffix:semicolon
r_int
id|err
suffix:semicolon
r_int
id|noise
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef CONFIG_JFFS2_FS_NAND
r_int
id|cleanmarkerfound
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
id|ofs
op_assign
id|jeb-&gt;offset
suffix:semicolon
id|prevofs
op_assign
id|jeb-&gt;offset
op_minus
l_int|1
suffix:semicolon
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;jffs2_scan_eraseblock(): Scanning block at 0x%x&bslash;n&quot;
comma
id|ofs
)paren
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_JFFS2_FS_NAND
r_if
c_cond
(paren
id|jffs2_cleanmarker_oob
c_func
(paren
id|c
)paren
)paren
(brace
r_int
id|ret
op_assign
id|jffs2_check_nand_cleanmarker
c_func
(paren
id|c
comma
id|jeb
)paren
suffix:semicolon
id|D2
c_func
(paren
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;jffs_check_nand_cleanmarker returned %d&bslash;n&quot;
comma
id|ret
)paren
)paren
suffix:semicolon
multiline_comment|/* Even if it&squot;s not found, we still scan to see&n;&t;&t;   if the block is empty. We use this information&n;&t;&t;   to decide whether to erase it or not. */
r_switch
c_cond
(paren
id|ret
)paren
(brace
r_case
l_int|0
suffix:colon
id|cleanmarkerfound
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
r_return
id|BLK_STATE_BADBLOCK
suffix:semicolon
r_case
l_int|3
suffix:colon
r_return
id|BLK_STATE_ALLDIRTY
suffix:semicolon
multiline_comment|/* Block has failed to erase min. once */
r_default
suffix:colon
r_return
id|ret
suffix:semicolon
)brace
)brace
macro_line|#endif
id|err
op_assign
id|jffs2_scan_empty
c_func
(paren
id|c
comma
id|jeb
comma
op_amp
id|ofs
comma
op_amp
id|noise
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
r_if
c_cond
(paren
id|ofs
op_eq
id|jeb-&gt;offset
op_plus
id|c-&gt;sector_size
)paren
(brace
macro_line|#ifdef CONFIG_JFFS2_FS_NAND
r_if
c_cond
(paren
id|jffs2_cleanmarker_oob
c_func
(paren
id|c
)paren
)paren
(brace
multiline_comment|/* scan oob, take care of cleanmarker */
r_int
id|ret
op_assign
id|jffs2_check_oob_empty
c_func
(paren
id|c
comma
id|jeb
comma
id|cleanmarkerfound
)paren
suffix:semicolon
id|D2
c_func
(paren
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;jffs_check_oob_empty returned %d&bslash;n&quot;
comma
id|ret
)paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|ret
)paren
(brace
r_case
l_int|0
suffix:colon
r_return
id|cleanmarkerfound
ques
c_cond
id|BLK_STATE_CLEANMARKER
suffix:colon
id|BLK_STATE_ALLFF
suffix:semicolon
r_case
l_int|1
suffix:colon
r_return
id|BLK_STATE_ALLDIRTY
suffix:semicolon
r_case
l_int|2
suffix:colon
r_return
id|BLK_STATE_BADBLOCK
suffix:semicolon
multiline_comment|/* case 2/3 are paranoia checks */
r_case
l_int|3
suffix:colon
r_return
id|BLK_STATE_ALLDIRTY
suffix:semicolon
multiline_comment|/* Block has failed to erase min. once */
r_default
suffix:colon
r_return
id|ret
suffix:semicolon
)brace
)brace
macro_line|#endif
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Block at 0x%08x is empty (erased)&bslash;n&quot;
comma
id|jeb-&gt;offset
)paren
)paren
suffix:semicolon
r_return
id|BLK_STATE_ALLFF
suffix:semicolon
multiline_comment|/* OK to erase if all blocks are like this */
)brace
id|noise
op_assign
l_int|10
suffix:semicolon
r_while
c_loop
(paren
id|ofs
OL
id|jeb-&gt;offset
op_plus
id|c-&gt;sector_size
)paren
(brace
r_int
id|retlen
suffix:semicolon
id|ACCT_PARANOIA_CHECK
c_func
(paren
id|jeb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ofs
op_amp
l_int|3
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Eep. ofs 0x%08x not word-aligned!&bslash;n&quot;
comma
id|ofs
)paren
suffix:semicolon
id|ofs
op_assign
(paren
id|ofs
op_plus
l_int|3
)paren
op_amp
op_complement
l_int|3
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ofs
op_eq
id|prevofs
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;ofs 0x%08x has already been seen. Skipping&bslash;n&quot;
comma
id|ofs
)paren
suffix:semicolon
id|DIRTY_SPACE
c_func
(paren
l_int|4
)paren
suffix:semicolon
id|ofs
op_add_assign
l_int|4
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|prevofs
op_assign
id|ofs
suffix:semicolon
r_if
c_cond
(paren
id|jeb-&gt;offset
op_plus
id|c-&gt;sector_size
OL
id|ofs
op_plus
r_sizeof
(paren
id|node
)paren
)paren
(brace
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Fewer than %d bytes left to end of block. Not reading&bslash;n&quot;
comma
r_sizeof
(paren
r_struct
id|jffs2_unknown_node
)paren
)paren
)paren
suffix:semicolon
id|DIRTY_SPACE
c_func
(paren
(paren
id|jeb-&gt;offset
op_plus
id|c-&gt;sector_size
)paren
op_minus
id|ofs
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|err
op_assign
id|jffs2_flash_read
c_func
(paren
id|c
comma
id|ofs
comma
r_sizeof
(paren
id|node
)paren
comma
op_amp
id|retlen
comma
(paren
r_char
op_star
)paren
op_amp
id|node
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;mtd-&gt;read(0x%x bytes from 0x%x) returned %d&bslash;n&quot;
comma
r_sizeof
(paren
id|node
)paren
comma
id|ofs
comma
id|err
)paren
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
r_if
c_cond
(paren
id|retlen
OL
r_sizeof
(paren
id|node
)paren
)paren
(brace
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Read at 0x%x gave only 0x%x bytes&bslash;n&quot;
comma
id|ofs
comma
id|retlen
)paren
)paren
suffix:semicolon
id|DIRTY_SPACE
c_func
(paren
id|retlen
)paren
suffix:semicolon
id|ofs
op_add_assign
id|retlen
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|node.magic
op_eq
id|JFFS2_EMPTY_BITMASK
op_logical_and
id|node.nodetype
op_eq
id|JFFS2_EMPTY_BITMASK
)paren
(brace
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Found empty flash at 0x%x&bslash;n&quot;
comma
id|ofs
)paren
)paren
suffix:semicolon
id|err
op_assign
id|jffs2_scan_empty
c_func
(paren
id|c
comma
id|jeb
comma
op_amp
id|ofs
comma
op_amp
id|noise
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ofs
op_eq
id|jeb-&gt;offset
op_logical_and
id|node.magic
op_eq
id|KSAMTIB_CIGAM_2SFFJ
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Magic bitmask is backwards at offset 0x%08x. Wrong endian filesystem?&bslash;n&quot;
comma
id|ofs
)paren
suffix:semicolon
id|DIRTY_SPACE
c_func
(paren
l_int|4
)paren
suffix:semicolon
id|ofs
op_add_assign
l_int|4
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|node.magic
op_eq
id|JFFS2_DIRTY_BITMASK
)paren
(brace
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Empty bitmask at 0x%08x&bslash;n&quot;
comma
id|ofs
)paren
)paren
suffix:semicolon
id|DIRTY_SPACE
c_func
(paren
l_int|4
)paren
suffix:semicolon
id|ofs
op_add_assign
l_int|4
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|node.magic
op_eq
id|JFFS2_OLD_MAGIC_BITMASK
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Old JFFS2 bitmask found at 0x%08x&bslash;n&quot;
comma
id|ofs
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;You cannot use older JFFS2 filesystems with newer kernels&bslash;n&quot;
)paren
suffix:semicolon
id|DIRTY_SPACE
c_func
(paren
l_int|4
)paren
suffix:semicolon
id|ofs
op_add_assign
l_int|4
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|node.magic
op_ne
id|JFFS2_MAGIC_BITMASK
)paren
(brace
multiline_comment|/* OK. We&squot;re out of possibilities. Whinge and move on */
id|noisy_printk
c_func
(paren
op_amp
id|noise
comma
l_string|&quot;jffs2_scan_eraseblock(): Magic bitmask 0x%04x not found at 0x%08x: 0x%04x instead&bslash;n&quot;
comma
id|JFFS2_MAGIC_BITMASK
comma
id|ofs
comma
id|node.magic
)paren
suffix:semicolon
id|DIRTY_SPACE
c_func
(paren
l_int|4
)paren
suffix:semicolon
id|ofs
op_add_assign
l_int|4
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* We seem to have a node of sorts. Check the CRC */
id|nodetype
op_assign
id|node.nodetype
suffix:semicolon
id|node.nodetype
op_or_assign
id|JFFS2_NODE_ACCURATE
suffix:semicolon
id|hdr_crc
op_assign
id|crc32
c_func
(paren
l_int|0
comma
op_amp
id|node
comma
r_sizeof
(paren
id|node
)paren
op_minus
l_int|4
)paren
suffix:semicolon
id|node.nodetype
op_assign
id|nodetype
suffix:semicolon
r_if
c_cond
(paren
id|hdr_crc
op_ne
id|node.hdr_crc
)paren
(brace
id|noisy_printk
c_func
(paren
op_amp
id|noise
comma
l_string|&quot;jffs2_scan_eraseblock(): Node at 0x%08x {0x%04x, 0x%04x, 0x%08x) has invalid CRC 0x%08x (calculated 0x%08x)&bslash;n&quot;
comma
id|ofs
comma
id|node.magic
comma
id|node.nodetype
comma
id|node.totlen
comma
id|node.hdr_crc
comma
id|hdr_crc
)paren
suffix:semicolon
id|DIRTY_SPACE
c_func
(paren
l_int|4
)paren
suffix:semicolon
id|ofs
op_add_assign
l_int|4
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|node.nodetype
op_amp
id|JFFS2_NODE_ACCURATE
)paren
)paren
(brace
multiline_comment|/* Wheee. This is an obsoleted node */
id|D2
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Node at 0x%08x is obsolete. Skipping&bslash;n&quot;
comma
id|ofs
)paren
)paren
suffix:semicolon
id|DIRTY_SPACE
c_func
(paren
id|PAD
c_func
(paren
id|node.totlen
)paren
)paren
suffix:semicolon
id|ofs
op_add_assign
id|PAD
c_func
(paren
id|node.totlen
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|node.nodetype
)paren
(brace
r_case
id|JFFS2_NODETYPE_INODE
suffix:colon
id|err
op_assign
id|jffs2_scan_inode_node
c_func
(paren
id|c
comma
id|jeb
comma
op_amp
id|ofs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
r_break
suffix:semicolon
r_case
id|JFFS2_NODETYPE_DIRENT
suffix:colon
id|err
op_assign
id|jffs2_scan_dirent_node
c_func
(paren
id|c
comma
id|jeb
comma
op_amp
id|ofs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
r_break
suffix:semicolon
r_case
id|JFFS2_NODETYPE_CLEANMARKER
suffix:colon
r_if
c_cond
(paren
id|node.totlen
op_ne
r_sizeof
(paren
r_struct
id|jffs2_unknown_node
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;CLEANMARKER node found at 0x%08x has totlen 0x%x != normal 0x%x&bslash;n&quot;
comma
id|ofs
comma
id|node.totlen
comma
r_sizeof
(paren
r_struct
id|jffs2_unknown_node
)paren
)paren
suffix:semicolon
id|DIRTY_SPACE
c_func
(paren
id|PAD
c_func
(paren
r_sizeof
(paren
r_struct
id|jffs2_unknown_node
)paren
)paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|jeb-&gt;first_node
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;CLEANMARKER node found at 0x%08x, not first node in block (0x%08x)&bslash;n&quot;
comma
id|ofs
comma
id|jeb-&gt;offset
)paren
suffix:semicolon
id|DIRTY_SPACE
c_func
(paren
id|PAD
c_func
(paren
r_sizeof
(paren
r_struct
id|jffs2_unknown_node
)paren
)paren
)paren
suffix:semicolon
id|ofs
op_add_assign
id|PAD
c_func
(paren
r_sizeof
(paren
r_struct
id|jffs2_unknown_node
)paren
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_else
(brace
r_struct
id|jffs2_raw_node_ref
op_star
id|marker_ref
op_assign
id|jffs2_alloc_raw_node_ref
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|marker_ref
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;Failed to allocate node ref for clean marker&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|marker_ref-&gt;next_in_ino
op_assign
l_int|NULL
suffix:semicolon
id|marker_ref-&gt;next_phys
op_assign
l_int|NULL
suffix:semicolon
id|marker_ref-&gt;flash_offset
op_assign
id|ofs
suffix:semicolon
id|marker_ref-&gt;totlen
op_assign
r_sizeof
(paren
r_struct
id|jffs2_unknown_node
)paren
suffix:semicolon
id|jeb-&gt;first_node
op_assign
id|jeb-&gt;last_node
op_assign
id|marker_ref
suffix:semicolon
id|USED_SPACE
c_func
(paren
id|PAD
c_func
(paren
r_sizeof
(paren
r_struct
id|jffs2_unknown_node
)paren
)paren
)paren
suffix:semicolon
)brace
id|ofs
op_add_assign
id|PAD
c_func
(paren
r_sizeof
(paren
r_struct
id|jffs2_unknown_node
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
r_switch
c_cond
(paren
id|node.nodetype
op_amp
id|JFFS2_COMPAT_MASK
)paren
(brace
r_case
id|JFFS2_FEATURE_ROCOMPAT
suffix:colon
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;Read-only compatible feature node (0x%04x) found at offset 0x%08x&bslash;n&quot;
comma
id|node.nodetype
comma
id|ofs
)paren
suffix:semicolon
id|c-&gt;flags
op_or_assign
id|JFFS2_SB_FLAG_RO
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|jffs2_is_readonly
c_func
(paren
id|c
)paren
)paren
)paren
r_return
op_minus
id|EROFS
suffix:semicolon
id|DIRTY_SPACE
c_func
(paren
id|PAD
c_func
(paren
id|node.totlen
)paren
)paren
suffix:semicolon
id|ofs
op_add_assign
id|PAD
c_func
(paren
id|node.totlen
)paren
suffix:semicolon
r_continue
suffix:semicolon
r_case
id|JFFS2_FEATURE_INCOMPAT
suffix:colon
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;Incompatible feature node (0x%04x) found at offset 0x%08x&bslash;n&quot;
comma
id|node.nodetype
comma
id|ofs
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
r_case
id|JFFS2_FEATURE_RWCOMPAT_DELETE
suffix:colon
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;Unknown but compatible feature node (0x%04x) found at offset 0x%08x&bslash;n&quot;
comma
id|node.nodetype
comma
id|ofs
)paren
)paren
suffix:semicolon
id|DIRTY_SPACE
c_func
(paren
id|PAD
c_func
(paren
id|node.totlen
)paren
)paren
suffix:semicolon
id|ofs
op_add_assign
id|PAD
c_func
(paren
id|node.totlen
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|JFFS2_FEATURE_RWCOMPAT_COPY
suffix:colon
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;Unknown but compatible feature node (0x%04x) found at offset 0x%08x&bslash;n&quot;
comma
id|node.nodetype
comma
id|ofs
)paren
)paren
suffix:semicolon
id|USED_SPACE
c_func
(paren
id|PAD
c_func
(paren
id|node.totlen
)paren
)paren
suffix:semicolon
id|ofs
op_add_assign
id|PAD
c_func
(paren
id|node.totlen
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Block at 0x%08x: free 0x%08x, dirty 0x%08x, used 0x%08x&bslash;n&quot;
comma
id|jeb-&gt;offset
comma
id|jeb-&gt;free_size
comma
id|jeb-&gt;dirty_size
comma
id|jeb-&gt;used_size
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|jeb-&gt;used_size
op_eq
id|PAD
c_func
(paren
r_sizeof
(paren
r_struct
id|jffs2_unknown_node
)paren
)paren
op_logical_and
op_logical_neg
id|jeb-&gt;first_node-&gt;next_in_ino
op_logical_and
op_logical_neg
id|jeb-&gt;dirty_size
)paren
r_return
id|BLK_STATE_CLEANMARKER
suffix:semicolon
r_else
r_if
c_cond
(paren
id|jeb-&gt;used_size
OG
id|c-&gt;sector_size
op_minus
(paren
l_int|2
op_star
r_sizeof
(paren
r_struct
id|jffs2_raw_inode
)paren
)paren
)paren
r_return
id|BLK_STATE_CLEAN
suffix:semicolon
r_else
r_if
c_cond
(paren
id|jeb-&gt;used_size
)paren
r_return
id|BLK_STATE_PARTDIRTY
suffix:semicolon
r_else
r_return
id|BLK_STATE_ALLDIRTY
suffix:semicolon
)brace
multiline_comment|/* We&squot;re pointing at the first empty word on the flash. Scan and account for the whole dirty region */
DECL|function|jffs2_scan_empty
r_static
r_int
id|jffs2_scan_empty
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
comma
r_struct
id|jffs2_eraseblock
op_star
id|jeb
comma
r_uint32
op_star
id|startofs
comma
r_int
op_star
id|noise
)paren
(brace
r_uint32
op_star
id|buf
suffix:semicolon
r_uint32
id|scanlen
op_assign
(paren
id|jeb-&gt;offset
op_plus
id|c-&gt;sector_size
)paren
op_minus
op_star
id|startofs
suffix:semicolon
r_uint32
id|curofs
op_assign
op_star
id|startofs
suffix:semicolon
id|buf
op_assign
id|kmalloc
c_func
(paren
id|min
c_func
(paren
(paren
r_uint32
)paren
id|PAGE_SIZE
comma
id|scanlen
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buf
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Scan buffer allocation failed&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_while
c_loop
(paren
id|scanlen
)paren
(brace
r_int
id|retlen
suffix:semicolon
r_int
id|ret
comma
id|i
suffix:semicolon
id|ret
op_assign
id|jffs2_flash_read
c_func
(paren
id|c
comma
id|curofs
comma
id|min
c_func
(paren
(paren
r_uint32
)paren
id|PAGE_SIZE
comma
id|scanlen
)paren
comma
op_amp
id|retlen
comma
(paren
r_char
op_star
)paren
id|buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;jffs2_scan_empty(): Read 0x%x bytes at 0x%08x returned %d&bslash;n&quot;
comma
id|min
c_func
(paren
(paren
r_uint32
)paren
id|PAGE_SIZE
comma
id|scanlen
)paren
comma
id|curofs
comma
id|ret
)paren
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|buf
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_if
c_cond
(paren
id|retlen
OL
l_int|4
)paren
(brace
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Eep. too few bytes read in scan_empty()&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|buf
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
id|retlen
op_div
l_int|4
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|buf
(braket
id|i
)braket
op_ne
l_int|0xffffffff
)paren
(brace
id|curofs
op_add_assign
id|i
op_star
l_int|4
suffix:semicolon
id|noisy_printk
c_func
(paren
id|noise
comma
l_string|&quot;jffs2_scan_empty(): Empty block at 0x%08x ends at 0x%08x (with 0x%08x)! Marking dirty&bslash;n&quot;
comma
op_star
id|startofs
comma
id|curofs
comma
id|buf
(braket
id|i
)braket
)paren
suffix:semicolon
id|DIRTY_SPACE
c_func
(paren
id|curofs
op_minus
(paren
op_star
id|startofs
)paren
)paren
suffix:semicolon
op_star
id|startofs
op_assign
id|curofs
suffix:semicolon
id|kfree
c_func
(paren
id|buf
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
id|scanlen
op_sub_assign
id|retlen
op_amp
op_complement
l_int|3
suffix:semicolon
id|curofs
op_add_assign
id|retlen
op_amp
op_complement
l_int|3
suffix:semicolon
)brace
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Empty flash detected from 0x%08x to 0x%08x&bslash;n&quot;
comma
op_star
id|startofs
comma
id|curofs
)paren
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|buf
)paren
suffix:semicolon
op_star
id|startofs
op_assign
id|curofs
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|jffs2_scan_make_ino_cache
r_static
r_struct
id|jffs2_inode_cache
op_star
id|jffs2_scan_make_ino_cache
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
comma
r_uint32
id|ino
)paren
(brace
r_struct
id|jffs2_inode_cache
op_star
id|ic
suffix:semicolon
id|ic
op_assign
id|jffs2_get_ino_cache
c_func
(paren
id|c
comma
id|ino
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ic
)paren
r_return
id|ic
suffix:semicolon
id|ic
op_assign
id|jffs2_alloc_inode_cache
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ic
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;jffs2_scan_make_inode_cache(): allocation of inode cache failed&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|memset
c_func
(paren
id|ic
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|ic
)paren
)paren
suffix:semicolon
id|ic-&gt;scan
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|jffs2_scan_info
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ic-&gt;scan
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;jffs2_scan_make_inode_cache(): allocation of scan info for inode cache failed&bslash;n&quot;
)paren
suffix:semicolon
id|jffs2_free_inode_cache
c_func
(paren
id|ic
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|memset
c_func
(paren
id|ic-&gt;scan
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|ic-&gt;scan
)paren
)paren
suffix:semicolon
id|ic-&gt;ino
op_assign
id|ino
suffix:semicolon
id|ic-&gt;nodes
op_assign
(paren
r_void
op_star
)paren
id|ic
suffix:semicolon
id|jffs2_add_ino_cache
c_func
(paren
id|c
comma
id|ic
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ino
op_eq
l_int|1
)paren
id|ic-&gt;nlink
op_assign
l_int|1
suffix:semicolon
r_return
id|ic
suffix:semicolon
)brace
DECL|function|jffs2_scan_inode_node
r_static
r_int
id|jffs2_scan_inode_node
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
comma
r_struct
id|jffs2_eraseblock
op_star
id|jeb
comma
r_uint32
op_star
id|ofs
)paren
(brace
r_struct
id|jffs2_raw_node_ref
op_star
id|raw
suffix:semicolon
r_struct
id|jffs2_full_dnode
op_star
id|fn
suffix:semicolon
r_struct
id|jffs2_tmp_dnode_info
op_star
id|tn
comma
op_star
op_star
id|tn_list
suffix:semicolon
r_struct
id|jffs2_inode_cache
op_star
id|ic
suffix:semicolon
r_struct
id|jffs2_raw_inode
id|ri
suffix:semicolon
r_uint32
id|crc
suffix:semicolon
r_uint16
id|oldnodetype
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_int
id|retlen
suffix:semicolon
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;jffs2_scan_inode_node(): Node at 0x%08x&bslash;n&quot;
comma
op_star
id|ofs
)paren
)paren
suffix:semicolon
id|ret
op_assign
id|jffs2_flash_read
c_func
(paren
id|c
comma
op_star
id|ofs
comma
r_sizeof
(paren
id|ri
)paren
comma
op_amp
id|retlen
comma
(paren
r_char
op_star
)paren
op_amp
id|ri
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;jffs2_scan_inode_node(): Read error at 0x%08x: %d&bslash;n&quot;
comma
op_star
id|ofs
comma
id|ret
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_if
c_cond
(paren
id|retlen
op_ne
r_sizeof
(paren
id|ri
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;Short read: 0x%x bytes at 0x%08x instead of requested %x&bslash;n&quot;
comma
id|retlen
comma
op_star
id|ofs
comma
r_sizeof
(paren
id|ri
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/* We sort of assume that the node was accurate when it was &n;&t;   first written to the medium :) */
id|oldnodetype
op_assign
id|ri.nodetype
suffix:semicolon
id|ri.nodetype
op_or_assign
id|JFFS2_NODE_ACCURATE
suffix:semicolon
id|crc
op_assign
id|crc32
c_func
(paren
l_int|0
comma
op_amp
id|ri
comma
r_sizeof
(paren
id|ri
)paren
op_minus
l_int|8
)paren
suffix:semicolon
id|ri.nodetype
op_assign
id|oldnodetype
suffix:semicolon
r_if
c_cond
(paren
id|crc
op_ne
id|ri.node_crc
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;jffs2_scan_inode_node(): CRC failed on node at 0x%08x: Read 0x%08x, calculated 0x%08x&bslash;n&quot;
comma
op_star
id|ofs
comma
id|ri.node_crc
comma
id|crc
)paren
suffix:semicolon
multiline_comment|/* FIXME: Why do we believe totlen? */
id|DIRTY_SPACE
c_func
(paren
l_int|4
)paren
suffix:semicolon
op_star
id|ofs
op_add_assign
l_int|4
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* There was a bug where we wrote hole nodes out with csize/dsize&n;&t;   swapped. Deal with it */
r_if
c_cond
(paren
id|ri.compr
op_eq
id|JFFS2_COMPR_ZERO
op_logical_and
op_logical_neg
id|ri.dsize
op_logical_and
id|ri.csize
)paren
(brace
id|ri.dsize
op_assign
id|ri.csize
suffix:semicolon
id|ri.csize
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ri.csize
)paren
(brace
multiline_comment|/* Check data CRC too */
r_int
r_char
op_star
id|dbuf
suffix:semicolon
r_uint32
id|crc
suffix:semicolon
id|dbuf
op_assign
id|kmalloc
c_func
(paren
id|PAGE_CACHE_SIZE
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dbuf
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;jffs2_scan_inode_node(): allocation of temporary data buffer for CRC check failed&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|ret
op_assign
id|jffs2_flash_read
c_func
(paren
id|c
comma
op_star
id|ofs
op_plus
r_sizeof
(paren
id|ri
)paren
comma
id|ri.csize
comma
op_amp
id|retlen
comma
id|dbuf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;jffs2_scan_inode_node(): Read error at 0x%08x: %d&bslash;n&quot;
comma
op_star
id|ofs
op_plus
r_sizeof
(paren
id|ri
)paren
comma
id|ret
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|dbuf
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_if
c_cond
(paren
id|retlen
op_ne
id|ri.csize
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;Short read: 0x%x bytes at 0x%08x instead of requested %x&bslash;n&quot;
comma
id|retlen
comma
op_star
id|ofs
op_plus
r_sizeof
(paren
id|ri
)paren
comma
id|ri.csize
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|dbuf
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|crc
op_assign
id|crc32
c_func
(paren
l_int|0
comma
id|dbuf
comma
id|ri.csize
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|dbuf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|crc
op_ne
id|ri.data_crc
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;jffs2_scan_inode_node(): Data CRC failed on node at 0x%08x: Read 0x%08x, calculated 0x%08x&bslash;n&quot;
comma
op_star
id|ofs
comma
id|ri.data_crc
comma
id|crc
)paren
suffix:semicolon
id|DIRTY_SPACE
c_func
(paren
id|PAD
c_func
(paren
id|ri.totlen
)paren
)paren
suffix:semicolon
op_star
id|ofs
op_add_assign
id|PAD
c_func
(paren
id|ri.totlen
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/* Wheee. It worked */
id|raw
op_assign
id|jffs2_alloc_raw_node_ref
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|raw
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;jffs2_scan_inode_node(): allocation of node reference failed&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|tn
op_assign
id|jffs2_alloc_tmp_dnode_info
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tn
)paren
(brace
id|jffs2_free_raw_node_ref
c_func
(paren
id|raw
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|fn
op_assign
id|jffs2_alloc_full_dnode
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fn
)paren
(brace
id|jffs2_free_tmp_dnode_info
c_func
(paren
id|tn
)paren
suffix:semicolon
id|jffs2_free_raw_node_ref
c_func
(paren
id|raw
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|ic
op_assign
id|jffs2_scan_make_ino_cache
c_func
(paren
id|c
comma
id|ri.ino
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ic
)paren
(brace
id|jffs2_free_full_dnode
c_func
(paren
id|fn
)paren
suffix:semicolon
id|jffs2_free_tmp_dnode_info
c_func
(paren
id|tn
)paren
suffix:semicolon
id|jffs2_free_raw_node_ref
c_func
(paren
id|raw
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
multiline_comment|/* Build the data structures and file them for later */
id|raw-&gt;flash_offset
op_assign
op_star
id|ofs
suffix:semicolon
id|raw-&gt;totlen
op_assign
id|PAD
c_func
(paren
id|ri.totlen
)paren
suffix:semicolon
id|raw-&gt;next_phys
op_assign
l_int|NULL
suffix:semicolon
id|raw-&gt;next_in_ino
op_assign
id|ic-&gt;nodes
suffix:semicolon
id|ic-&gt;nodes
op_assign
id|raw
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|jeb-&gt;first_node
)paren
id|jeb-&gt;first_node
op_assign
id|raw
suffix:semicolon
r_if
c_cond
(paren
id|jeb-&gt;last_node
)paren
id|jeb-&gt;last_node-&gt;next_phys
op_assign
id|raw
suffix:semicolon
id|jeb-&gt;last_node
op_assign
id|raw
suffix:semicolon
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Node is ino #%u, version %d. Range 0x%x-0x%x&bslash;n&quot;
comma
id|ri.ino
comma
id|ri.version
comma
id|ri.offset
comma
id|ri.offset
op_plus
id|ri.dsize
)paren
)paren
suffix:semicolon
id|pseudo_random
op_add_assign
id|ri.version
suffix:semicolon
r_for
c_loop
(paren
id|tn_list
op_assign
op_amp
id|ic-&gt;scan-&gt;tmpnodes
suffix:semicolon
op_star
id|tn_list
suffix:semicolon
id|tn_list
op_assign
op_amp
(paren
(paren
op_star
id|tn_list
)paren
op_member_access_from_pointer
id|next
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
op_star
id|tn_list
)paren
op_member_access_from_pointer
id|version
OL
id|ri.version
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
(paren
op_star
id|tn_list
)paren
op_member_access_from_pointer
id|version
OG
id|ri.version
)paren
r_break
suffix:semicolon
multiline_comment|/* Wheee. We&squot;ve found another instance of the same version number.&n;&t;&t;   We should obsolete one of them. &n;&t;&t;*/
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Duplicate version %d found in ino #%u. Previous one is at 0x%08x&bslash;n&quot;
comma
id|ri.version
comma
id|ic-&gt;ino
comma
(paren
op_star
id|tn_list
)paren
op_member_access_from_pointer
id|fn-&gt;raw-&gt;flash_offset
op_amp
op_complement
l_int|3
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|jeb-&gt;used_size
)paren
(brace
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;No valid nodes yet found in this eraseblock 0x%08x, so obsoleting the new instance at 0x%08x&bslash;n&quot;
comma
id|jeb-&gt;offset
comma
id|raw-&gt;flash_offset
op_amp
op_complement
l_int|3
)paren
)paren
suffix:semicolon
id|ri.nodetype
op_and_assign
op_complement
id|JFFS2_NODE_ACCURATE
suffix:semicolon
multiline_comment|/* Perhaps we could also mark it as such on the medium. Maybe later */
)brace
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ri.nodetype
op_amp
id|JFFS2_NODE_ACCURATE
)paren
(brace
multiline_comment|/* Only do fraglist truncation in pass1 for S_IFREG inodes */
r_if
c_cond
(paren
id|S_ISREG
c_func
(paren
id|ri.mode
)paren
op_logical_and
id|ic-&gt;scan-&gt;version
OL
id|ri.version
)paren
(brace
id|ic-&gt;scan-&gt;version
op_assign
id|ri.version
suffix:semicolon
id|ic-&gt;scan-&gt;isize
op_assign
id|ri.isize
suffix:semicolon
)brace
id|memset
c_func
(paren
id|fn
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|fn
)paren
)paren
suffix:semicolon
id|fn-&gt;ofs
op_assign
id|ri.offset
suffix:semicolon
id|fn-&gt;size
op_assign
id|ri.dsize
suffix:semicolon
id|fn-&gt;frags
op_assign
l_int|0
suffix:semicolon
id|fn-&gt;raw
op_assign
id|raw
suffix:semicolon
id|tn-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|tn-&gt;fn
op_assign
id|fn
suffix:semicolon
id|tn-&gt;version
op_assign
id|ri.version
suffix:semicolon
id|USED_SPACE
c_func
(paren
id|PAD
c_func
(paren
id|ri.totlen
)paren
)paren
suffix:semicolon
id|jffs2_add_tn_to_list
c_func
(paren
id|tn
comma
op_amp
id|ic-&gt;scan-&gt;tmpnodes
)paren
suffix:semicolon
multiline_comment|/* Make sure the one we just added is the _last_ in the list&n;&t;&t;   with this version number, so the older ones get obsoleted */
r_while
c_loop
(paren
id|tn-&gt;next
op_logical_and
id|tn-&gt;next-&gt;version
op_eq
id|tn-&gt;version
)paren
(brace
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Shifting new node at 0x%08x after other node at 0x%08x for version %d in list&bslash;n&quot;
comma
id|fn-&gt;raw-&gt;flash_offset
op_amp
op_complement
l_int|3
comma
id|tn-&gt;next-&gt;fn-&gt;raw-&gt;flash_offset
op_amp
op_complement
l_int|3
comma
id|ri.version
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tn-&gt;fn
op_ne
id|fn
)paren
(brace
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
id|tn-&gt;fn
op_assign
id|tn-&gt;next-&gt;fn
suffix:semicolon
id|tn-&gt;next-&gt;fn
op_assign
id|fn
suffix:semicolon
id|tn
op_assign
id|tn-&gt;next
suffix:semicolon
)brace
)brace
r_else
(brace
id|jffs2_free_full_dnode
c_func
(paren
id|fn
)paren
suffix:semicolon
id|jffs2_free_tmp_dnode_info
c_func
(paren
id|tn
)paren
suffix:semicolon
id|raw-&gt;flash_offset
op_or_assign
l_int|1
suffix:semicolon
id|DIRTY_SPACE
c_func
(paren
id|PAD
c_func
(paren
id|ri.totlen
)paren
)paren
suffix:semicolon
)brace
op_star
id|ofs
op_add_assign
id|PAD
c_func
(paren
id|ri.totlen
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|jffs2_scan_dirent_node
r_static
r_int
id|jffs2_scan_dirent_node
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
comma
r_struct
id|jffs2_eraseblock
op_star
id|jeb
comma
r_uint32
op_star
id|ofs
)paren
(brace
r_struct
id|jffs2_raw_node_ref
op_star
id|raw
suffix:semicolon
r_struct
id|jffs2_full_dirent
op_star
id|fd
suffix:semicolon
r_struct
id|jffs2_inode_cache
op_star
id|ic
suffix:semicolon
r_struct
id|jffs2_raw_dirent
id|rd
suffix:semicolon
r_uint16
id|oldnodetype
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_uint32
id|crc
suffix:semicolon
r_int
id|retlen
suffix:semicolon
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;jffs2_scan_dirent_node(): Node at 0x%08x&bslash;n&quot;
comma
op_star
id|ofs
)paren
)paren
suffix:semicolon
id|ret
op_assign
id|jffs2_flash_read
c_func
(paren
id|c
comma
op_star
id|ofs
comma
r_sizeof
(paren
id|rd
)paren
comma
op_amp
id|retlen
comma
(paren
r_char
op_star
)paren
op_amp
id|rd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;jffs2_scan_dirent_node(): Read error at 0x%08x: %d&bslash;n&quot;
comma
op_star
id|ofs
comma
id|ret
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_if
c_cond
(paren
id|retlen
op_ne
r_sizeof
(paren
id|rd
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;Short read: 0x%x bytes at 0x%08x instead of requested %x&bslash;n&quot;
comma
id|retlen
comma
op_star
id|ofs
comma
r_sizeof
(paren
id|rd
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/* We sort of assume that the node was accurate when it was &n;&t;   first written to the medium :) */
id|oldnodetype
op_assign
id|rd.nodetype
suffix:semicolon
id|rd.nodetype
op_or_assign
id|JFFS2_NODE_ACCURATE
suffix:semicolon
id|crc
op_assign
id|crc32
c_func
(paren
l_int|0
comma
op_amp
id|rd
comma
r_sizeof
(paren
id|rd
)paren
op_minus
l_int|8
)paren
suffix:semicolon
id|rd.nodetype
op_assign
id|oldnodetype
suffix:semicolon
r_if
c_cond
(paren
id|crc
op_ne
id|rd.node_crc
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;jffs2_scan_dirent_node(): Node CRC failed on node at 0x%08x: Read 0x%08x, calculated 0x%08x&bslash;n&quot;
comma
op_star
id|ofs
comma
id|rd.node_crc
comma
id|crc
)paren
suffix:semicolon
multiline_comment|/* FIXME: Why do we believe totlen? */
id|DIRTY_SPACE
c_func
(paren
l_int|4
)paren
suffix:semicolon
op_star
id|ofs
op_add_assign
l_int|4
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|pseudo_random
op_add_assign
id|rd.version
suffix:semicolon
id|fd
op_assign
id|jffs2_alloc_full_dirent
c_func
(paren
id|rd.nsize
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fd
)paren
(brace
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|ret
op_assign
id|jffs2_flash_read
c_func
(paren
id|c
comma
op_star
id|ofs
op_plus
r_sizeof
(paren
id|rd
)paren
comma
id|rd.nsize
comma
op_amp
id|retlen
comma
op_amp
id|fd-&gt;name
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|jffs2_free_full_dirent
c_func
(paren
id|fd
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;jffs2_scan_dirent_node(): Read error at 0x%08x: %d&bslash;n&quot;
comma
op_star
id|ofs
op_plus
r_sizeof
(paren
id|rd
)paren
comma
id|ret
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_if
c_cond
(paren
id|retlen
op_ne
id|rd.nsize
)paren
(brace
id|jffs2_free_full_dirent
c_func
(paren
id|fd
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;Short read: 0x%x bytes at 0x%08x instead of requested %x&bslash;n&quot;
comma
id|retlen
comma
op_star
id|ofs
op_plus
r_sizeof
(paren
id|rd
)paren
comma
id|rd.nsize
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|crc
op_assign
id|crc32
c_func
(paren
l_int|0
comma
id|fd-&gt;name
comma
id|rd.nsize
)paren
suffix:semicolon
r_if
c_cond
(paren
id|crc
op_ne
id|rd.name_crc
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;jffs2_scan_dirent_node(): Name CRC failed on node at 0x%08x: Read 0x%08x, calculated 0x%08x&bslash;n&quot;
comma
op_star
id|ofs
comma
id|rd.name_crc
comma
id|crc
)paren
suffix:semicolon
id|fd-&gt;name
(braket
id|rd.nsize
)braket
op_assign
l_int|0
suffix:semicolon
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;Name for which CRC failed is (now) &squot;%s&squot;, ino #%d&bslash;n&quot;
comma
id|fd-&gt;name
comma
id|rd.ino
)paren
)paren
suffix:semicolon
id|jffs2_free_full_dirent
c_func
(paren
id|fd
)paren
suffix:semicolon
multiline_comment|/* FIXME: Why do we believe totlen? */
id|DIRTY_SPACE
c_func
(paren
id|PAD
c_func
(paren
id|rd.totlen
)paren
)paren
suffix:semicolon
op_star
id|ofs
op_add_assign
id|PAD
c_func
(paren
id|rd.totlen
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|raw
op_assign
id|jffs2_alloc_raw_node_ref
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|raw
)paren
(brace
id|jffs2_free_full_dirent
c_func
(paren
id|fd
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;jffs2_scan_dirent_node(): allocation of node reference failed&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|ic
op_assign
id|jffs2_scan_make_ino_cache
c_func
(paren
id|c
comma
id|rd.pino
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ic
)paren
(brace
id|jffs2_free_full_dirent
c_func
(paren
id|fd
)paren
suffix:semicolon
id|jffs2_free_raw_node_ref
c_func
(paren
id|raw
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|raw-&gt;totlen
op_assign
id|PAD
c_func
(paren
id|rd.totlen
)paren
suffix:semicolon
id|raw-&gt;flash_offset
op_assign
op_star
id|ofs
suffix:semicolon
id|raw-&gt;next_phys
op_assign
l_int|NULL
suffix:semicolon
id|raw-&gt;next_in_ino
op_assign
id|ic-&gt;nodes
suffix:semicolon
id|ic-&gt;nodes
op_assign
id|raw
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|jeb-&gt;first_node
)paren
id|jeb-&gt;first_node
op_assign
id|raw
suffix:semicolon
r_if
c_cond
(paren
id|jeb-&gt;last_node
)paren
id|jeb-&gt;last_node-&gt;next_phys
op_assign
id|raw
suffix:semicolon
id|jeb-&gt;last_node
op_assign
id|raw
suffix:semicolon
r_if
c_cond
(paren
id|rd.nodetype
op_amp
id|JFFS2_NODE_ACCURATE
)paren
(brace
id|fd-&gt;raw
op_assign
id|raw
suffix:semicolon
id|fd-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|fd-&gt;version
op_assign
id|rd.version
suffix:semicolon
id|fd-&gt;ino
op_assign
id|rd.ino
suffix:semicolon
id|fd-&gt;name
(braket
id|rd.nsize
)braket
op_assign
l_int|0
suffix:semicolon
id|fd-&gt;nhash
op_assign
id|full_name_hash
c_func
(paren
id|fd-&gt;name
comma
id|rd.nsize
)paren
suffix:semicolon
id|fd-&gt;type
op_assign
id|rd.type
suffix:semicolon
id|USED_SPACE
c_func
(paren
id|PAD
c_func
(paren
id|rd.totlen
)paren
)paren
suffix:semicolon
id|jffs2_add_fd_to_list
c_func
(paren
id|c
comma
id|fd
comma
op_amp
id|ic-&gt;scan-&gt;dents
)paren
suffix:semicolon
)brace
r_else
(brace
id|raw-&gt;flash_offset
op_or_assign
l_int|1
suffix:semicolon
id|jffs2_free_full_dirent
c_func
(paren
id|fd
)paren
suffix:semicolon
id|DIRTY_SPACE
c_func
(paren
id|PAD
c_func
(paren
id|rd.totlen
)paren
)paren
suffix:semicolon
)brace
op_star
id|ofs
op_add_assign
id|PAD
c_func
(paren
id|rd.totlen
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|count_list
r_static
r_int
id|count_list
c_func
(paren
r_struct
id|list_head
op_star
id|l
)paren
(brace
r_uint32
id|count
op_assign
l_int|0
suffix:semicolon
r_struct
id|list_head
op_star
id|tmp
suffix:semicolon
id|list_for_each
c_func
(paren
id|tmp
comma
id|l
)paren
(brace
id|count
op_increment
suffix:semicolon
)brace
r_return
id|count
suffix:semicolon
)brace
multiline_comment|/* Note: This breaks if list_empty(head). I don&squot;t care. You&n;   might, if you copy this code and use it elsewhere :) */
DECL|function|rotate_list
r_static
r_void
id|rotate_list
c_func
(paren
r_struct
id|list_head
op_star
id|head
comma
r_uint32
id|count
)paren
(brace
r_struct
id|list_head
op_star
id|n
op_assign
id|head-&gt;next
suffix:semicolon
id|list_del
c_func
(paren
id|head
)paren
suffix:semicolon
r_while
c_loop
(paren
id|count
op_decrement
)paren
(brace
id|n
op_assign
id|n-&gt;next
suffix:semicolon
)brace
id|list_add
c_func
(paren
id|head
comma
id|n
)paren
suffix:semicolon
)brace
DECL|function|jffs2_rotate_lists
r_static
r_void
id|jffs2_rotate_lists
c_func
(paren
r_struct
id|jffs2_sb_info
op_star
id|c
)paren
(brace
r_uint32
id|x
suffix:semicolon
id|x
op_assign
id|count_list
c_func
(paren
op_amp
id|c-&gt;clean_list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|x
)paren
id|rotate_list
c_func
(paren
(paren
op_amp
id|c-&gt;clean_list
)paren
comma
id|pseudo_random
op_mod
id|x
)paren
suffix:semicolon
id|x
op_assign
id|count_list
c_func
(paren
op_amp
id|c-&gt;dirty_list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|x
)paren
id|rotate_list
c_func
(paren
(paren
op_amp
id|c-&gt;dirty_list
)paren
comma
id|pseudo_random
op_mod
id|x
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c-&gt;nr_erasing_blocks
)paren
id|rotate_list
c_func
(paren
(paren
op_amp
id|c-&gt;erase_pending_list
)paren
comma
id|pseudo_random
op_mod
id|c-&gt;nr_erasing_blocks
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c-&gt;nr_free_blocks
)paren
multiline_comment|/* Not that it should ever be zero */
id|rotate_list
c_func
(paren
(paren
op_amp
id|c-&gt;free_list
)paren
comma
id|pseudo_random
op_mod
id|c-&gt;nr_free_blocks
)paren
suffix:semicolon
)brace
eof
