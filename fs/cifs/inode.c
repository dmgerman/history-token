multiline_comment|/*&n; *   fs/cifs/inode.c&n; *&n; *   Copyright (C) International Business Machines  Corp., 2002,2005&n; *   Author(s): Steve French (sfrench@us.ibm.com)&n; *&n; *   This library is free software; you can redistribute it and/or modify&n; *   it under the terms of the GNU Lesser General Public License as published&n; *   by the Free Software Foundation; either version 2.1 of the License, or&n; *   (at your option) any later version.&n; *&n; *   This library is distributed in the hope that it will be useful,&n; *   but WITHOUT ANY WARRANTY; without even the implied warranty of&n; *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See&n; *   the GNU Lesser General Public License for more details.&n; *&n; *   You should have received a copy of the GNU Lesser General Public License&n; *   along with this library; if not, write to the Free Software&n; *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA&n; */
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/buffer_head.h&gt;
macro_line|#include &lt;linux/stat.h&gt;
macro_line|#include &lt;linux/pagemap.h&gt;
macro_line|#include &lt;asm/div64.h&gt;
macro_line|#include &quot;cifsfs.h&quot;
macro_line|#include &quot;cifspdu.h&quot;
macro_line|#include &quot;cifsglob.h&quot;
macro_line|#include &quot;cifsproto.h&quot;
macro_line|#include &quot;cifs_debug.h&quot;
macro_line|#include &quot;cifs_fs_sb.h&quot;
DECL|function|cifs_get_inode_info_unix
r_int
id|cifs_get_inode_info_unix
c_func
(paren
r_struct
id|inode
op_star
op_star
id|pinode
comma
r_const
r_int
r_char
op_star
id|search_path
comma
r_struct
id|super_block
op_star
id|sb
comma
r_int
id|xid
)paren
(brace
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
id|FILE_UNIX_BASIC_INFO
id|findData
suffix:semicolon
r_struct
id|cifsTconInfo
op_star
id|pTcon
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_struct
id|cifs_sb_info
op_star
id|cifs_sb
op_assign
id|CIFS_SB
c_func
(paren
id|sb
)paren
suffix:semicolon
r_char
op_star
id|tmp_path
suffix:semicolon
id|pTcon
op_assign
id|cifs_sb-&gt;tcon
suffix:semicolon
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot; Getting info on %s &quot;
comma
id|search_path
)paren
)paren
suffix:semicolon
multiline_comment|/* could have done a find first instead but this returns more info */
id|rc
op_assign
id|CIFSSMBUnixQPathInfo
c_func
(paren
id|xid
comma
id|pTcon
comma
id|search_path
comma
op_amp
id|findData
comma
id|cifs_sb-&gt;local_nls
)paren
suffix:semicolon
multiline_comment|/*&t;dump_mem(&quot;&bslash;nUnixQPathInfo return data&quot;, &amp;findData,&n;&t;&t; sizeof(findData)); */
r_if
c_cond
(paren
id|rc
)paren
(brace
r_if
c_cond
(paren
id|rc
op_eq
op_minus
id|EREMOTE
)paren
(brace
id|tmp_path
op_assign
id|kmalloc
c_func
(paren
id|strnlen
c_func
(paren
id|pTcon-&gt;treeName
comma
id|MAX_TREE_SIZE
op_plus
l_int|1
)paren
op_plus
id|strnlen
c_func
(paren
id|search_path
comma
id|MAX_PATHCONF
)paren
op_plus
l_int|1
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp_path
op_eq
l_int|NULL
)paren
(brace
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
multiline_comment|/* have to skip first of the double backslash of&n;&t;&t;&t;   UNC name */
id|strncpy
c_func
(paren
id|tmp_path
comma
id|pTcon-&gt;treeName
comma
id|MAX_TREE_SIZE
)paren
suffix:semicolon
id|strncat
c_func
(paren
id|tmp_path
comma
id|search_path
comma
id|MAX_PATHCONF
)paren
suffix:semicolon
id|rc
op_assign
id|connect_to_dfs_path
c_func
(paren
id|xid
comma
id|pTcon-&gt;ses
comma
multiline_comment|/* treename + */
id|tmp_path
comma
id|cifs_sb-&gt;local_nls
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|tmp_path
)paren
suffix:semicolon
multiline_comment|/* BB fix up inode etc. */
)brace
r_else
r_if
c_cond
(paren
id|rc
)paren
(brace
r_return
id|rc
suffix:semicolon
)brace
)brace
r_else
(brace
r_struct
id|cifsInodeInfo
op_star
id|cifsInfo
suffix:semicolon
id|__u32
id|type
op_assign
id|le32_to_cpu
c_func
(paren
id|findData.Type
)paren
suffix:semicolon
id|__u64
id|num_of_bytes
op_assign
id|le64_to_cpu
c_func
(paren
id|findData.NumOfBytes
)paren
suffix:semicolon
id|__u64
id|end_of_file
op_assign
id|le64_to_cpu
c_func
(paren
id|findData.EndOfFile
)paren
suffix:semicolon
multiline_comment|/* get new inode */
r_if
c_cond
(paren
op_star
id|pinode
op_eq
l_int|NULL
)paren
(brace
op_star
id|pinode
op_assign
id|new_inode
c_func
(paren
id|sb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|pinode
op_eq
l_int|NULL
)paren
(brace
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
multiline_comment|/* Is an i_ino of zero legal? */
multiline_comment|/* Are there sanity checks we can use to ensure that&n;&t;&t;&t;   the server is really filling in that field? */
r_if
c_cond
(paren
id|cifs_sb-&gt;mnt_cifs_flags
op_amp
id|CIFS_MOUNT_SERVER_INUM
)paren
(brace
(paren
op_star
id|pinode
)paren
op_member_access_from_pointer
id|i_ino
op_assign
(paren
r_int
r_int
)paren
id|findData.UniqueId
suffix:semicolon
)brace
multiline_comment|/* note ino incremented to unique num in new_inode */
id|insert_inode_hash
c_func
(paren
op_star
id|pinode
)paren
suffix:semicolon
)brace
id|inode
op_assign
op_star
id|pinode
suffix:semicolon
id|cifsInfo
op_assign
id|CIFS_I
c_func
(paren
id|inode
)paren
suffix:semicolon
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot; Old time %ld &quot;
comma
id|cifsInfo-&gt;time
)paren
)paren
suffix:semicolon
id|cifsInfo-&gt;time
op_assign
id|jiffies
suffix:semicolon
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot; New time %ld &quot;
comma
id|cifsInfo-&gt;time
)paren
)paren
suffix:semicolon
multiline_comment|/* this is ok to set on every inode revalidate */
id|atomic_set
c_func
(paren
op_amp
id|cifsInfo-&gt;inUse
comma
l_int|1
)paren
suffix:semicolon
id|inode-&gt;i_atime
op_assign
id|cifs_NTtimeToUnix
c_func
(paren
id|le64_to_cpu
c_func
(paren
id|findData.LastAccessTime
)paren
)paren
suffix:semicolon
id|inode-&gt;i_mtime
op_assign
id|cifs_NTtimeToUnix
c_func
(paren
id|le64_to_cpu
(paren
id|findData.LastModificationTime
)paren
)paren
suffix:semicolon
id|inode-&gt;i_ctime
op_assign
id|cifs_NTtimeToUnix
c_func
(paren
id|le64_to_cpu
c_func
(paren
id|findData.LastStatusChange
)paren
)paren
suffix:semicolon
id|inode-&gt;i_mode
op_assign
id|le64_to_cpu
c_func
(paren
id|findData.Permissions
)paren
suffix:semicolon
r_if
c_cond
(paren
id|type
op_eq
id|UNIX_FILE
)paren
(brace
id|inode-&gt;i_mode
op_or_assign
id|S_IFREG
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|type
op_eq
id|UNIX_SYMLINK
)paren
(brace
id|inode-&gt;i_mode
op_or_assign
id|S_IFLNK
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|type
op_eq
id|UNIX_DIR
)paren
(brace
id|inode-&gt;i_mode
op_or_assign
id|S_IFDIR
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|type
op_eq
id|UNIX_CHARDEV
)paren
(brace
id|inode-&gt;i_mode
op_or_assign
id|S_IFCHR
suffix:semicolon
id|inode-&gt;i_rdev
op_assign
id|MKDEV
c_func
(paren
id|le64_to_cpu
c_func
(paren
id|findData.DevMajor
)paren
comma
id|le64_to_cpu
c_func
(paren
id|findData.DevMinor
)paren
op_amp
id|MINORMASK
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|type
op_eq
id|UNIX_BLOCKDEV
)paren
(brace
id|inode-&gt;i_mode
op_or_assign
id|S_IFBLK
suffix:semicolon
id|inode-&gt;i_rdev
op_assign
id|MKDEV
c_func
(paren
id|le64_to_cpu
c_func
(paren
id|findData.DevMajor
)paren
comma
id|le64_to_cpu
c_func
(paren
id|findData.DevMinor
)paren
op_amp
id|MINORMASK
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|type
op_eq
id|UNIX_FIFO
)paren
(brace
id|inode-&gt;i_mode
op_or_assign
id|S_IFIFO
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|type
op_eq
id|UNIX_SOCKET
)paren
(brace
id|inode-&gt;i_mode
op_or_assign
id|S_IFSOCK
suffix:semicolon
)brace
id|inode-&gt;i_uid
op_assign
id|le64_to_cpu
c_func
(paren
id|findData.Uid
)paren
suffix:semicolon
id|inode-&gt;i_gid
op_assign
id|le64_to_cpu
c_func
(paren
id|findData.Gid
)paren
suffix:semicolon
id|inode-&gt;i_nlink
op_assign
id|le64_to_cpu
c_func
(paren
id|findData.Nlinks
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_size_safe_to_change
c_func
(paren
id|cifsInfo
)paren
)paren
(brace
multiline_comment|/* can not safely change the file size here if the&n;&t;&t;   client is writing to it due to potential races */
id|i_size_write
c_func
(paren
id|inode
comma
id|end_of_file
)paren
suffix:semicolon
multiline_comment|/* blksize needs to be multiple of two. So safer to default to&n;&t;&t;blksize and blkbits set in superblock so 2**blkbits and blksize&n;&t;&t;will match rather than setting to:&n;&t;&t;(pTcon-&gt;ses-&gt;server-&gt;maxBuf - MAX_CIFS_HDR_SIZE) &amp; 0xFFFFFE00;*/
multiline_comment|/* This seems incredibly stupid but it turns out that i_blocks&n;&t;&t;   is not related to (i_size / i_blksize), instead 512 byte size&n;&t;&t;   is required for calculating num blocks */
multiline_comment|/* 512 bytes (2**9) is the fake blocksize that must be used */
multiline_comment|/* for this calculation */
id|inode-&gt;i_blocks
op_assign
(paren
l_int|512
op_minus
l_int|1
op_plus
id|num_of_bytes
)paren
op_rshift
l_int|9
suffix:semicolon
)brace
r_if
c_cond
(paren
id|num_of_bytes
OL
id|end_of_file
)paren
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;allocation size less than end of file &quot;
)paren
)paren
suffix:semicolon
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;Size %ld and blocks %ld&quot;
comma
(paren
r_int
r_int
)paren
id|inode-&gt;i_size
comma
id|inode-&gt;i_blocks
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|S_ISREG
c_func
(paren
id|inode-&gt;i_mode
)paren
)paren
(brace
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot; File inode &quot;
)paren
)paren
suffix:semicolon
id|inode-&gt;i_op
op_assign
op_amp
id|cifs_file_inode_ops
suffix:semicolon
r_if
c_cond
(paren
id|cifs_sb-&gt;mnt_cifs_flags
op_amp
id|CIFS_MOUNT_DIRECT_IO
)paren
(brace
id|inode-&gt;i_fop
op_assign
op_amp
id|cifs_file_direct_ops
suffix:semicolon
)brace
r_else
id|inode-&gt;i_fop
op_assign
op_amp
id|cifs_file_ops
suffix:semicolon
id|inode-&gt;i_data.a_ops
op_assign
op_amp
id|cifs_addr_ops
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|S_ISDIR
c_func
(paren
id|inode-&gt;i_mode
)paren
)paren
(brace
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot; Directory inode&quot;
)paren
)paren
suffix:semicolon
id|inode-&gt;i_op
op_assign
op_amp
id|cifs_dir_inode_ops
suffix:semicolon
id|inode-&gt;i_fop
op_assign
op_amp
id|cifs_dir_ops
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|S_ISLNK
c_func
(paren
id|inode-&gt;i_mode
)paren
)paren
(brace
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot; Symbolic Link inode &quot;
)paren
)paren
suffix:semicolon
id|inode-&gt;i_op
op_assign
op_amp
id|cifs_symlink_inode_ops
suffix:semicolon
multiline_comment|/* tmp_inode-&gt;i_fop = */
multiline_comment|/* do not need to set to anything */
)brace
r_else
(brace
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot; Init special inode &quot;
)paren
)paren
suffix:semicolon
id|init_special_inode
c_func
(paren
id|inode
comma
id|inode-&gt;i_mode
comma
id|inode-&gt;i_rdev
)paren
suffix:semicolon
)brace
)brace
r_return
id|rc
suffix:semicolon
)brace
DECL|function|cifs_get_inode_info
r_int
id|cifs_get_inode_info
c_func
(paren
r_struct
id|inode
op_star
op_star
id|pinode
comma
r_const
r_int
r_char
op_star
id|search_path
comma
id|FILE_ALL_INFO
op_star
id|pfindData
comma
r_struct
id|super_block
op_star
id|sb
comma
r_int
id|xid
)paren
(brace
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
r_struct
id|cifsTconInfo
op_star
id|pTcon
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_struct
id|cifs_sb_info
op_star
id|cifs_sb
op_assign
id|CIFS_SB
c_func
(paren
id|sb
)paren
suffix:semicolon
r_char
op_star
id|tmp_path
suffix:semicolon
r_char
op_star
id|buf
op_assign
l_int|NULL
suffix:semicolon
id|pTcon
op_assign
id|cifs_sb-&gt;tcon
suffix:semicolon
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;Getting info on %s &quot;
comma
id|search_path
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|pfindData
op_eq
l_int|NULL
)paren
op_logical_and
(paren
op_star
id|pinode
op_ne
l_int|NULL
)paren
)paren
(brace
r_if
c_cond
(paren
id|CIFS_I
c_func
(paren
op_star
id|pinode
)paren
op_member_access_from_pointer
id|clientCanCacheRead
)paren
(brace
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;No need to revalidate cached inode sizes&quot;
)paren
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
)brace
multiline_comment|/* if file info not passed in then get it from server */
r_if
c_cond
(paren
id|pfindData
op_eq
l_int|NULL
)paren
(brace
id|buf
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|FILE_ALL_INFO
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buf
op_eq
l_int|NULL
)paren
(brace
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|pfindData
op_assign
(paren
id|FILE_ALL_INFO
op_star
)paren
id|buf
suffix:semicolon
multiline_comment|/* could do find first instead but this returns more info */
id|rc
op_assign
id|CIFSSMBQPathInfo
c_func
(paren
id|xid
comma
id|pTcon
comma
id|search_path
comma
id|pfindData
comma
id|cifs_sb-&gt;local_nls
)paren
suffix:semicolon
)brace
multiline_comment|/* dump_mem(&quot;&bslash;nQPathInfo return data&quot;,&amp;findData, sizeof(findData)); */
r_if
c_cond
(paren
id|rc
)paren
(brace
r_if
c_cond
(paren
id|rc
op_eq
op_minus
id|EREMOTE
)paren
(brace
id|tmp_path
op_assign
id|kmalloc
c_func
(paren
id|strnlen
(paren
id|pTcon-&gt;treeName
comma
id|MAX_TREE_SIZE
op_plus
l_int|1
)paren
op_plus
id|strnlen
c_func
(paren
id|search_path
comma
id|MAX_PATHCONF
)paren
op_plus
l_int|1
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp_path
op_eq
l_int|NULL
)paren
(brace
id|kfree
c_func
(paren
id|buf
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|strncpy
c_func
(paren
id|tmp_path
comma
id|pTcon-&gt;treeName
comma
id|MAX_TREE_SIZE
)paren
suffix:semicolon
id|strncat
c_func
(paren
id|tmp_path
comma
id|search_path
comma
id|MAX_PATHCONF
)paren
suffix:semicolon
id|rc
op_assign
id|connect_to_dfs_path
c_func
(paren
id|xid
comma
id|pTcon-&gt;ses
comma
multiline_comment|/* treename + */
id|tmp_path
comma
id|cifs_sb-&gt;local_nls
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|tmp_path
)paren
suffix:semicolon
multiline_comment|/* BB fix up inode etc. */
)brace
r_else
r_if
c_cond
(paren
id|rc
)paren
(brace
id|kfree
c_func
(paren
id|buf
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
)brace
r_else
(brace
r_struct
id|cifsInodeInfo
op_star
id|cifsInfo
suffix:semicolon
id|__u32
id|attr
op_assign
id|le32_to_cpu
c_func
(paren
id|pfindData-&gt;Attributes
)paren
suffix:semicolon
multiline_comment|/* get new inode */
r_if
c_cond
(paren
op_star
id|pinode
op_eq
l_int|NULL
)paren
(brace
op_star
id|pinode
op_assign
id|new_inode
c_func
(paren
id|sb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|pinode
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
multiline_comment|/* Is an i_ino of zero legal? */
multiline_comment|/* Are there sanity checks we can use to ensure that&n;&t;&t;&t;   the server is really filling in that field? */
multiline_comment|/* We can not use the IndexNumber from either Windows&n;&t;&t;&t;   or Samba as it is frequently set to zero */
multiline_comment|/* There may be higher info levels that work but are&n;&t;&t;&t;   there Windows server or network appliances for which&n;&t;&t;&t;   IndexNumber field is not guaranteed unique? */
multiline_comment|/* if(cifs_sb-&gt;mnt_cifs_flags &amp; CIFS_MOUNT_SERVER_INUM){&n;&t;&t;&t;&t;(*pinode)-&gt;i_ino = &n;&t;&t;&t;&t;&t;(unsigned long)pfindData-&gt;IndexNumber;&n;&t;&t;&t;} */
multiline_comment|/*NB: ino incremented to unique num in new_inode*/
id|insert_inode_hash
c_func
(paren
op_star
id|pinode
)paren
suffix:semicolon
)brace
id|inode
op_assign
op_star
id|pinode
suffix:semicolon
id|cifsInfo
op_assign
id|CIFS_I
c_func
(paren
id|inode
)paren
suffix:semicolon
id|cifsInfo-&gt;cifsAttrs
op_assign
id|attr
suffix:semicolon
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot; Old time %ld &quot;
comma
id|cifsInfo-&gt;time
)paren
)paren
suffix:semicolon
id|cifsInfo-&gt;time
op_assign
id|jiffies
suffix:semicolon
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot; New time %ld &quot;
comma
id|cifsInfo-&gt;time
)paren
)paren
suffix:semicolon
multiline_comment|/* blksize needs to be multiple of two. So safer to default to&n;&t;&t;blksize and blkbits set in superblock so 2**blkbits and blksize&n;&t;&t;will match rather than setting to:&n;&t;&t;(pTcon-&gt;ses-&gt;server-&gt;maxBuf - MAX_CIFS_HDR_SIZE) &amp; 0xFFFFFE00;*/
multiline_comment|/* Linux can not store file creation time unfortunately so we ignore it */
id|inode-&gt;i_atime
op_assign
id|cifs_NTtimeToUnix
c_func
(paren
id|le64_to_cpu
c_func
(paren
id|pfindData-&gt;LastAccessTime
)paren
)paren
suffix:semicolon
id|inode-&gt;i_mtime
op_assign
id|cifs_NTtimeToUnix
c_func
(paren
id|le64_to_cpu
c_func
(paren
id|pfindData-&gt;LastWriteTime
)paren
)paren
suffix:semicolon
id|inode-&gt;i_ctime
op_assign
id|cifs_NTtimeToUnix
c_func
(paren
id|le64_to_cpu
c_func
(paren
id|pfindData-&gt;ChangeTime
)paren
)paren
suffix:semicolon
id|cFYI
c_func
(paren
l_int|0
comma
(paren
l_string|&quot; Attributes came in as 0x%x &quot;
comma
id|attr
)paren
)paren
suffix:semicolon
multiline_comment|/* set default mode. will override for dirs below */
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|cifsInfo-&gt;inUse
)paren
op_eq
l_int|0
)paren
multiline_comment|/* new inode, can safely set these fields */
id|inode-&gt;i_mode
op_assign
id|cifs_sb-&gt;mnt_file_mode
suffix:semicolon
multiline_comment|/*&t;&t;if (attr &amp; ATTR_REPARSE)  */
multiline_comment|/* We no longer handle these as symlinks because we could not&n;&t;&t;   follow them due to the absolute path with drive letter */
r_if
c_cond
(paren
id|attr
op_amp
id|ATTR_DIRECTORY
)paren
(brace
multiline_comment|/* override default perms since we do not do byte range locking&n;&t;&t;   on dirs */
id|inode-&gt;i_mode
op_assign
id|cifs_sb-&gt;mnt_dir_mode
suffix:semicolon
id|inode-&gt;i_mode
op_or_assign
id|S_IFDIR
suffix:semicolon
)brace
r_else
(brace
id|inode-&gt;i_mode
op_or_assign
id|S_IFREG
suffix:semicolon
multiline_comment|/* treat the dos attribute of read-only as read-only&n;&t;&t;&t;   mode e.g. 555 */
r_if
c_cond
(paren
id|cifsInfo-&gt;cifsAttrs
op_amp
id|ATTR_READONLY
)paren
id|inode-&gt;i_mode
op_and_assign
op_complement
(paren
id|S_IWUGO
)paren
suffix:semicolon
multiline_comment|/* BB add code here -&n;&t;&t;   validate if device or weird share or device type? */
)brace
r_if
c_cond
(paren
id|is_size_safe_to_change
c_func
(paren
id|cifsInfo
)paren
)paren
(brace
multiline_comment|/* can not safely change the file size here if the&n;&t;&t;&t;   client is writing to it due to potential races */
id|i_size_write
c_func
(paren
id|inode
comma
id|le64_to_cpu
c_func
(paren
id|pfindData-&gt;EndOfFile
)paren
)paren
suffix:semicolon
multiline_comment|/* 512 bytes (2**9) is the fake blocksize that must be&n;&t;&t;&t;   used for this calculation */
id|inode-&gt;i_blocks
op_assign
(paren
l_int|512
op_minus
l_int|1
op_plus
id|le64_to_cpu
c_func
(paren
id|pfindData-&gt;AllocationSize
)paren
)paren
op_rshift
l_int|9
suffix:semicolon
)brace
id|inode-&gt;i_nlink
op_assign
id|le32_to_cpu
c_func
(paren
id|pfindData-&gt;NumberOfLinks
)paren
suffix:semicolon
multiline_comment|/* BB fill in uid and gid here? with help from winbind? &n;&t;&t;   or retrieve from NTFS stream extended attribute */
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|cifsInfo-&gt;inUse
)paren
op_eq
l_int|0
)paren
(brace
id|inode-&gt;i_uid
op_assign
id|cifs_sb-&gt;mnt_uid
suffix:semicolon
id|inode-&gt;i_gid
op_assign
id|cifs_sb-&gt;mnt_gid
suffix:semicolon
multiline_comment|/* set so we do not keep refreshing these fields with&n;&t;&t;&t;   bad data after user has changed them in memory */
id|atomic_set
c_func
(paren
op_amp
id|cifsInfo-&gt;inUse
comma
l_int|1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|S_ISREG
c_func
(paren
id|inode-&gt;i_mode
)paren
)paren
(brace
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot; File inode &quot;
)paren
)paren
suffix:semicolon
id|inode-&gt;i_op
op_assign
op_amp
id|cifs_file_inode_ops
suffix:semicolon
r_if
c_cond
(paren
id|cifs_sb-&gt;mnt_cifs_flags
op_amp
id|CIFS_MOUNT_DIRECT_IO
)paren
(brace
id|inode-&gt;i_fop
op_assign
op_amp
id|cifs_file_direct_ops
suffix:semicolon
)brace
r_else
id|inode-&gt;i_fop
op_assign
op_amp
id|cifs_file_ops
suffix:semicolon
id|inode-&gt;i_data.a_ops
op_assign
op_amp
id|cifs_addr_ops
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|S_ISDIR
c_func
(paren
id|inode-&gt;i_mode
)paren
)paren
(brace
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot; Directory inode &quot;
)paren
)paren
suffix:semicolon
id|inode-&gt;i_op
op_assign
op_amp
id|cifs_dir_inode_ops
suffix:semicolon
id|inode-&gt;i_fop
op_assign
op_amp
id|cifs_dir_ops
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|S_ISLNK
c_func
(paren
id|inode-&gt;i_mode
)paren
)paren
(brace
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot; Symbolic Link inode &quot;
)paren
)paren
suffix:semicolon
id|inode-&gt;i_op
op_assign
op_amp
id|cifs_symlink_inode_ops
suffix:semicolon
)brace
r_else
(brace
id|init_special_inode
c_func
(paren
id|inode
comma
id|inode-&gt;i_mode
comma
id|inode-&gt;i_rdev
)paren
suffix:semicolon
)brace
)brace
id|kfree
c_func
(paren
id|buf
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/* gets root inode */
DECL|function|cifs_read_inode
r_void
id|cifs_read_inode
c_func
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
r_int
id|xid
suffix:semicolon
r_struct
id|cifs_sb_info
op_star
id|cifs_sb
suffix:semicolon
id|cifs_sb
op_assign
id|CIFS_SB
c_func
(paren
id|inode-&gt;i_sb
)paren
suffix:semicolon
id|xid
op_assign
id|GetXid
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cifs_sb-&gt;tcon-&gt;ses-&gt;capabilities
op_amp
id|CAP_UNIX
)paren
id|cifs_get_inode_info_unix
c_func
(paren
op_amp
id|inode
comma
l_string|&quot;&quot;
comma
id|inode-&gt;i_sb
comma
id|xid
)paren
suffix:semicolon
r_else
id|cifs_get_inode_info
c_func
(paren
op_amp
id|inode
comma
l_string|&quot;&quot;
comma
l_int|NULL
comma
id|inode-&gt;i_sb
comma
id|xid
)paren
suffix:semicolon
multiline_comment|/* can not call macro FreeXid here since in a void func */
id|_FreeXid
c_func
(paren
id|xid
)paren
suffix:semicolon
)brace
DECL|function|cifs_unlink
r_int
id|cifs_unlink
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|dentry
op_star
id|direntry
)paren
(brace
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
r_int
id|xid
suffix:semicolon
r_struct
id|cifs_sb_info
op_star
id|cifs_sb
suffix:semicolon
r_struct
id|cifsTconInfo
op_star
id|pTcon
suffix:semicolon
r_char
op_star
id|full_path
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|cifsInodeInfo
op_star
id|cifsInode
suffix:semicolon
id|FILE_BASIC_INFO
op_star
id|pinfo_buf
suffix:semicolon
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot; cifs_unlink, inode = 0x%p with &quot;
comma
id|inode
)paren
)paren
suffix:semicolon
id|xid
op_assign
id|GetXid
c_func
(paren
)paren
suffix:semicolon
id|cifs_sb
op_assign
id|CIFS_SB
c_func
(paren
id|inode-&gt;i_sb
)paren
suffix:semicolon
id|pTcon
op_assign
id|cifs_sb-&gt;tcon
suffix:semicolon
multiline_comment|/* Unlink can be called from rename so we can not grab the sem here&n;&t;   since we deadlock otherwise */
multiline_comment|/*&t;down(&amp;direntry-&gt;d_sb-&gt;s_vfs_rename_sem);*/
id|full_path
op_assign
id|build_path_from_dentry
c_func
(paren
id|direntry
)paren
suffix:semicolon
multiline_comment|/*&t;up(&amp;direntry-&gt;d_sb-&gt;s_vfs_rename_sem);*/
r_if
c_cond
(paren
id|full_path
op_eq
l_int|NULL
)paren
(brace
id|FreeXid
c_func
(paren
id|xid
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|rc
op_assign
id|CIFSSMBDelFile
c_func
(paren
id|xid
comma
id|pTcon
comma
id|full_path
comma
id|cifs_sb-&gt;local_nls
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rc
)paren
(brace
id|direntry-&gt;d_inode-&gt;i_nlink
op_decrement
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|rc
op_eq
op_minus
id|ENOENT
)paren
(brace
id|d_drop
c_func
(paren
id|direntry
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|rc
op_eq
op_minus
id|ETXTBSY
)paren
(brace
r_int
id|oplock
op_assign
id|FALSE
suffix:semicolon
id|__u16
id|netfid
suffix:semicolon
id|rc
op_assign
id|CIFSSMBOpen
c_func
(paren
id|xid
comma
id|pTcon
comma
id|full_path
comma
id|FILE_OPEN
comma
id|DELETE
comma
id|CREATE_NOT_DIR
op_or
id|CREATE_DELETE_ON_CLOSE
comma
op_amp
id|netfid
comma
op_amp
id|oplock
comma
l_int|NULL
comma
id|cifs_sb-&gt;local_nls
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_eq
l_int|0
)paren
(brace
id|CIFSSMBRenameOpenFile
c_func
(paren
id|xid
comma
id|pTcon
comma
id|netfid
comma
l_int|NULL
comma
id|cifs_sb-&gt;local_nls
)paren
suffix:semicolon
id|CIFSSMBClose
c_func
(paren
id|xid
comma
id|pTcon
comma
id|netfid
)paren
suffix:semicolon
id|direntry-&gt;d_inode-&gt;i_nlink
op_decrement
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|rc
op_eq
op_minus
id|EACCES
)paren
(brace
multiline_comment|/* try only if r/o attribute set in local lookup data? */
id|pinfo_buf
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|FILE_BASIC_INFO
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pinfo_buf
)paren
(brace
id|memset
c_func
(paren
id|pinfo_buf
comma
l_int|0
comma
r_sizeof
(paren
id|FILE_BASIC_INFO
)paren
)paren
suffix:semicolon
multiline_comment|/* ATTRS set to normal clears r/o bit */
id|pinfo_buf-&gt;Attributes
op_assign
id|cpu_to_le32
c_func
(paren
id|ATTR_NORMAL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|pTcon-&gt;ses-&gt;flags
op_amp
id|CIFS_SES_NT4
)paren
)paren
id|rc
op_assign
id|CIFSSMBSetTimes
c_func
(paren
id|xid
comma
id|pTcon
comma
id|full_path
comma
id|pinfo_buf
comma
id|cifs_sb-&gt;local_nls
)paren
suffix:semicolon
r_else
id|rc
op_assign
op_minus
id|EOPNOTSUPP
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_eq
op_minus
id|EOPNOTSUPP
)paren
(brace
r_int
id|oplock
op_assign
id|FALSE
suffix:semicolon
id|__u16
id|netfid
suffix:semicolon
multiline_comment|/*&t;rc = CIFSSMBSetAttrLegacy(xid, pTcon,&n;&t;&t;&t;&t;&t;&t;&t;  full_path,&n;&t;&t;&t;&t;&t;&t;&t;  (__u16)ATTR_NORMAL,&n;&t;&t;&t;&t;&t;&t;&t;  cifs_sb-&gt;local_nls); &n;&t;&t;&t;   For some strange reason it seems that NT4 eats the&n;&t;&t;&t;   old setattr call without actually setting the&n;&t;&t;&t;   attributes so on to the third attempted workaround&n;&t;&t;&t;   */
multiline_comment|/* BB could scan to see if we already have it open&n;&t;&t;&t;   and pass in pid of opener to function */
id|rc
op_assign
id|CIFSSMBOpen
c_func
(paren
id|xid
comma
id|pTcon
comma
id|full_path
comma
id|FILE_OPEN
comma
id|SYNCHRONIZE
op_or
id|FILE_WRITE_ATTRIBUTES
comma
l_int|0
comma
op_amp
id|netfid
comma
op_amp
id|oplock
comma
l_int|NULL
comma
id|cifs_sb-&gt;local_nls
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_eq
l_int|0
)paren
(brace
id|rc
op_assign
id|CIFSSMBSetFileTimes
c_func
(paren
id|xid
comma
id|pTcon
comma
id|pinfo_buf
comma
id|netfid
)paren
suffix:semicolon
id|CIFSSMBClose
c_func
(paren
id|xid
comma
id|pTcon
comma
id|netfid
)paren
suffix:semicolon
)brace
)brace
id|kfree
c_func
(paren
id|pinfo_buf
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rc
op_eq
l_int|0
)paren
(brace
id|rc
op_assign
id|CIFSSMBDelFile
c_func
(paren
id|xid
comma
id|pTcon
comma
id|full_path
comma
id|cifs_sb-&gt;local_nls
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rc
)paren
(brace
id|direntry-&gt;d_inode-&gt;i_nlink
op_decrement
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|rc
op_eq
op_minus
id|ETXTBSY
)paren
(brace
r_int
id|oplock
op_assign
id|FALSE
suffix:semicolon
id|__u16
id|netfid
suffix:semicolon
id|rc
op_assign
id|CIFSSMBOpen
c_func
(paren
id|xid
comma
id|pTcon
comma
id|full_path
comma
id|FILE_OPEN
comma
id|DELETE
comma
id|CREATE_NOT_DIR
op_or
id|CREATE_DELETE_ON_CLOSE
comma
op_amp
id|netfid
comma
op_amp
id|oplock
comma
l_int|NULL
comma
id|cifs_sb-&gt;local_nls
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_eq
l_int|0
)paren
(brace
id|CIFSSMBRenameOpenFile
c_func
(paren
id|xid
comma
id|pTcon
comma
id|netfid
comma
l_int|NULL
comma
id|cifs_sb-&gt;local_nls
)paren
suffix:semicolon
id|CIFSSMBClose
c_func
(paren
id|xid
comma
id|pTcon
comma
id|netfid
)paren
suffix:semicolon
id|direntry-&gt;d_inode-&gt;i_nlink
op_decrement
suffix:semicolon
)brace
multiline_comment|/* BB if rc = -ETXTBUSY goto the rename logic BB */
)brace
)brace
)brace
id|cifsInode
op_assign
id|CIFS_I
c_func
(paren
id|direntry-&gt;d_inode
)paren
suffix:semicolon
id|cifsInode-&gt;time
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* will force revalidate to get info when&n;&t;&t;&t;&t;   needed */
id|direntry-&gt;d_inode-&gt;i_ctime
op_assign
id|inode-&gt;i_ctime
op_assign
id|inode-&gt;i_mtime
op_assign
id|current_fs_time
c_func
(paren
id|inode-&gt;i_sb
)paren
suffix:semicolon
id|cifsInode
op_assign
id|CIFS_I
c_func
(paren
id|inode
)paren
suffix:semicolon
id|cifsInode-&gt;time
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* force revalidate of dir as well */
id|kfree
c_func
(paren
id|full_path
)paren
suffix:semicolon
id|FreeXid
c_func
(paren
id|xid
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
DECL|function|cifs_mkdir
r_int
id|cifs_mkdir
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|dentry
op_star
id|direntry
comma
r_int
id|mode
)paren
(brace
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
r_int
id|xid
suffix:semicolon
r_struct
id|cifs_sb_info
op_star
id|cifs_sb
suffix:semicolon
r_struct
id|cifsTconInfo
op_star
id|pTcon
suffix:semicolon
r_char
op_star
id|full_path
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|inode
op_star
id|newinode
op_assign
l_int|NULL
suffix:semicolon
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;In cifs_mkdir, mode = 0x%x inode = 0x%p &quot;
comma
id|mode
comma
id|inode
)paren
)paren
suffix:semicolon
id|xid
op_assign
id|GetXid
c_func
(paren
)paren
suffix:semicolon
id|cifs_sb
op_assign
id|CIFS_SB
c_func
(paren
id|inode-&gt;i_sb
)paren
suffix:semicolon
id|pTcon
op_assign
id|cifs_sb-&gt;tcon
suffix:semicolon
id|down
c_func
(paren
op_amp
id|inode-&gt;i_sb-&gt;s_vfs_rename_sem
)paren
suffix:semicolon
id|full_path
op_assign
id|build_path_from_dentry
c_func
(paren
id|direntry
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|inode-&gt;i_sb-&gt;s_vfs_rename_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|full_path
op_eq
l_int|NULL
)paren
(brace
id|FreeXid
c_func
(paren
id|xid
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
multiline_comment|/* BB add setting the equivalent of mode via CreateX w/ACLs */
id|rc
op_assign
id|CIFSSMBMkDir
c_func
(paren
id|xid
comma
id|pTcon
comma
id|full_path
comma
id|cifs_sb-&gt;local_nls
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
(brace
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;cifs_mkdir returned 0x%x &quot;
comma
id|rc
)paren
)paren
suffix:semicolon
id|d_drop
c_func
(paren
id|direntry
)paren
suffix:semicolon
)brace
r_else
(brace
id|inode-&gt;i_nlink
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|pTcon-&gt;ses-&gt;capabilities
op_amp
id|CAP_UNIX
)paren
id|rc
op_assign
id|cifs_get_inode_info_unix
c_func
(paren
op_amp
id|newinode
comma
id|full_path
comma
id|inode-&gt;i_sb
comma
id|xid
)paren
suffix:semicolon
r_else
id|rc
op_assign
id|cifs_get_inode_info
c_func
(paren
op_amp
id|newinode
comma
id|full_path
comma
l_int|NULL
comma
id|inode-&gt;i_sb
comma
id|xid
)paren
suffix:semicolon
id|direntry-&gt;d_op
op_assign
op_amp
id|cifs_dentry_ops
suffix:semicolon
id|d_instantiate
c_func
(paren
id|direntry
comma
id|newinode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|direntry-&gt;d_inode
)paren
id|direntry-&gt;d_inode-&gt;i_nlink
op_assign
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|cifs_sb-&gt;tcon-&gt;ses-&gt;capabilities
op_amp
id|CAP_UNIX
)paren
r_if
c_cond
(paren
id|cifs_sb-&gt;mnt_cifs_flags
op_amp
id|CIFS_MOUNT_SET_UID
)paren
(brace
id|CIFSSMBUnixSetPerms
c_func
(paren
id|xid
comma
id|pTcon
comma
id|full_path
comma
id|mode
comma
(paren
id|__u64
)paren
id|current-&gt;euid
comma
(paren
id|__u64
)paren
id|current-&gt;egid
comma
l_int|0
multiline_comment|/* dev_t */
comma
id|cifs_sb-&gt;local_nls
)paren
suffix:semicolon
)brace
r_else
(brace
id|CIFSSMBUnixSetPerms
c_func
(paren
id|xid
comma
id|pTcon
comma
id|full_path
comma
id|mode
comma
(paren
id|__u64
)paren
op_minus
l_int|1
comma
(paren
id|__u64
)paren
op_minus
l_int|1
comma
l_int|0
multiline_comment|/* dev_t */
comma
id|cifs_sb-&gt;local_nls
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* BB to be implemented via Windows secrty descriptors&n;&t;&t;&t;   eg CIFSSMBWinSetPerms(xid, pTcon, full_path, mode,&n;&t;&t;&t;&t;&t;&t; -1, -1, local_nls); */
)brace
)brace
id|kfree
c_func
(paren
id|full_path
)paren
suffix:semicolon
id|FreeXid
c_func
(paren
id|xid
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
DECL|function|cifs_rmdir
r_int
id|cifs_rmdir
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|dentry
op_star
id|direntry
)paren
(brace
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
r_int
id|xid
suffix:semicolon
r_struct
id|cifs_sb_info
op_star
id|cifs_sb
suffix:semicolon
r_struct
id|cifsTconInfo
op_star
id|pTcon
suffix:semicolon
r_char
op_star
id|full_path
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|cifsInodeInfo
op_star
id|cifsInode
suffix:semicolon
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot; cifs_rmdir, inode = 0x%p with &quot;
comma
id|inode
)paren
)paren
suffix:semicolon
id|xid
op_assign
id|GetXid
c_func
(paren
)paren
suffix:semicolon
id|cifs_sb
op_assign
id|CIFS_SB
c_func
(paren
id|inode-&gt;i_sb
)paren
suffix:semicolon
id|pTcon
op_assign
id|cifs_sb-&gt;tcon
suffix:semicolon
id|down
c_func
(paren
op_amp
id|inode-&gt;i_sb-&gt;s_vfs_rename_sem
)paren
suffix:semicolon
id|full_path
op_assign
id|build_path_from_dentry
c_func
(paren
id|direntry
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|inode-&gt;i_sb-&gt;s_vfs_rename_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|full_path
op_eq
l_int|NULL
)paren
(brace
id|FreeXid
c_func
(paren
id|xid
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|rc
op_assign
id|CIFSSMBRmDir
c_func
(paren
id|xid
comma
id|pTcon
comma
id|full_path
comma
id|cifs_sb-&gt;local_nls
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rc
)paren
(brace
id|inode-&gt;i_nlink
op_decrement
suffix:semicolon
id|i_size_write
c_func
(paren
id|direntry-&gt;d_inode
comma
l_int|0
)paren
suffix:semicolon
id|direntry-&gt;d_inode-&gt;i_nlink
op_assign
l_int|0
suffix:semicolon
)brace
id|cifsInode
op_assign
id|CIFS_I
c_func
(paren
id|direntry-&gt;d_inode
)paren
suffix:semicolon
id|cifsInode-&gt;time
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* force revalidate to go get info when&n;&t;&t;&t;&t;   needed */
id|direntry-&gt;d_inode-&gt;i_ctime
op_assign
id|inode-&gt;i_ctime
op_assign
id|inode-&gt;i_mtime
op_assign
id|current_fs_time
c_func
(paren
id|inode-&gt;i_sb
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|full_path
)paren
suffix:semicolon
id|FreeXid
c_func
(paren
id|xid
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
DECL|function|cifs_rename
r_int
id|cifs_rename
c_func
(paren
r_struct
id|inode
op_star
id|source_inode
comma
r_struct
id|dentry
op_star
id|source_direntry
comma
r_struct
id|inode
op_star
id|target_inode
comma
r_struct
id|dentry
op_star
id|target_direntry
)paren
(brace
r_char
op_star
id|fromName
suffix:semicolon
r_char
op_star
id|toName
suffix:semicolon
r_struct
id|cifs_sb_info
op_star
id|cifs_sb_source
suffix:semicolon
r_struct
id|cifs_sb_info
op_star
id|cifs_sb_target
suffix:semicolon
r_struct
id|cifsTconInfo
op_star
id|pTcon
suffix:semicolon
r_int
id|xid
suffix:semicolon
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
id|xid
op_assign
id|GetXid
c_func
(paren
)paren
suffix:semicolon
id|cifs_sb_target
op_assign
id|CIFS_SB
c_func
(paren
id|target_inode-&gt;i_sb
)paren
suffix:semicolon
id|cifs_sb_source
op_assign
id|CIFS_SB
c_func
(paren
id|source_inode-&gt;i_sb
)paren
suffix:semicolon
id|pTcon
op_assign
id|cifs_sb_source-&gt;tcon
suffix:semicolon
r_if
c_cond
(paren
id|pTcon
op_ne
id|cifs_sb_target-&gt;tcon
)paren
(brace
id|FreeXid
c_func
(paren
id|xid
)paren
suffix:semicolon
r_return
op_minus
id|EXDEV
suffix:semicolon
multiline_comment|/* BB actually could be allowed if same server,&n;&t;&t;&t;&t;   but different share.&n;&t;&t;&t;&t;   Might eventually add support for this */
)brace
multiline_comment|/* we already  have the rename sem so we do not need to grab it again&n;&t;   here to protect the path integrity */
id|fromName
op_assign
id|build_path_from_dentry
c_func
(paren
id|source_direntry
)paren
suffix:semicolon
id|toName
op_assign
id|build_path_from_dentry
c_func
(paren
id|target_direntry
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|fromName
op_eq
l_int|NULL
)paren
op_logical_or
(paren
id|toName
op_eq
l_int|NULL
)paren
)paren
(brace
id|rc
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|cifs_rename_exit
suffix:semicolon
)brace
id|rc
op_assign
id|CIFSSMBRename
c_func
(paren
id|xid
comma
id|pTcon
comma
id|fromName
comma
id|toName
comma
id|cifs_sb_source-&gt;local_nls
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_eq
op_minus
id|EEXIST
)paren
(brace
multiline_comment|/* check if they are the same file because rename of hardlinked&n;&t;&t;   files is a noop */
id|FILE_UNIX_BASIC_INFO
op_star
id|info_buf_source
suffix:semicolon
id|FILE_UNIX_BASIC_INFO
op_star
id|info_buf_target
suffix:semicolon
id|info_buf_source
op_assign
id|kmalloc
c_func
(paren
l_int|2
op_star
r_sizeof
(paren
id|FILE_UNIX_BASIC_INFO
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info_buf_source
op_ne
l_int|NULL
)paren
(brace
id|info_buf_target
op_assign
id|info_buf_source
op_plus
l_int|1
suffix:semicolon
id|rc
op_assign
id|CIFSSMBUnixQPathInfo
c_func
(paren
id|xid
comma
id|pTcon
comma
id|fromName
comma
id|info_buf_source
comma
id|cifs_sb_source-&gt;local_nls
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_eq
l_int|0
)paren
(brace
id|rc
op_assign
id|CIFSSMBUnixQPathInfo
c_func
(paren
id|xid
comma
id|pTcon
comma
id|toName
comma
id|info_buf_target
comma
id|cifs_sb_target-&gt;local_nls
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|rc
op_eq
l_int|0
)paren
op_logical_and
(paren
id|info_buf_source-&gt;UniqueId
op_eq
id|info_buf_target-&gt;UniqueId
)paren
)paren
(brace
multiline_comment|/* do not rename since the files are hardlinked which&n;&t;&t;&t;   is a noop */
)brace
r_else
(brace
multiline_comment|/* we either can not tell the files are hardlinked&n;&t;&t;&t;   (as with Windows servers) or files are not&n;&t;&t;&t;   hardlinked so delete the target manually before&n;&t;&t;&t;   renaming to follow POSIX rather than Windows&n;&t;&t;&t;   semantics */
id|cifs_unlink
c_func
(paren
id|target_inode
comma
id|target_direntry
)paren
suffix:semicolon
id|rc
op_assign
id|CIFSSMBRename
c_func
(paren
id|xid
comma
id|pTcon
comma
id|fromName
comma
id|toName
comma
id|cifs_sb_source-&gt;local_nls
)paren
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|info_buf_source
)paren
suffix:semicolon
)brace
multiline_comment|/* if we can not get memory just leave rc as EEXIST */
)brace
r_if
c_cond
(paren
id|rc
)paren
(brace
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;rename rc %d&quot;
comma
id|rc
)paren
)paren
suffix:semicolon
multiline_comment|/* BB removeme BB */
)brace
r_if
c_cond
(paren
(paren
id|rc
op_eq
op_minus
id|EIO
)paren
op_logical_or
(paren
id|rc
op_eq
op_minus
id|EEXIST
)paren
)paren
(brace
r_int
id|oplock
op_assign
id|FALSE
suffix:semicolon
id|__u16
id|netfid
suffix:semicolon
multiline_comment|/* BB FIXME Is Generic Read correct for rename? */
multiline_comment|/* if renaming directory - we should not say CREATE_NOT_DIR,&n;&t;&t;   need to test renaming open directory, also GENERIC_READ&n;&t;&t;   might not right be right access to request */
id|rc
op_assign
id|CIFSSMBOpen
c_func
(paren
id|xid
comma
id|pTcon
comma
id|fromName
comma
id|FILE_OPEN
comma
id|GENERIC_READ
comma
id|CREATE_NOT_DIR
comma
op_amp
id|netfid
comma
op_amp
id|oplock
comma
l_int|NULL
comma
id|cifs_sb_source-&gt;local_nls
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_eq
l_int|0
)paren
(brace
id|CIFSSMBRenameOpenFile
c_func
(paren
id|xid
comma
id|pTcon
comma
id|netfid
comma
id|toName
comma
id|cifs_sb_source-&gt;local_nls
)paren
suffix:semicolon
id|CIFSSMBClose
c_func
(paren
id|xid
comma
id|pTcon
comma
id|netfid
)paren
suffix:semicolon
)brace
)brace
id|cifs_rename_exit
suffix:colon
id|kfree
c_func
(paren
id|fromName
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|toName
)paren
suffix:semicolon
id|FreeXid
c_func
(paren
id|xid
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
DECL|function|cifs_revalidate
r_int
id|cifs_revalidate
c_func
(paren
r_struct
id|dentry
op_star
id|direntry
)paren
(brace
r_int
id|xid
suffix:semicolon
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
r_char
op_star
id|full_path
suffix:semicolon
r_struct
id|cifs_sb_info
op_star
id|cifs_sb
suffix:semicolon
r_struct
id|cifsInodeInfo
op_star
id|cifsInode
suffix:semicolon
id|loff_t
id|local_size
suffix:semicolon
r_struct
id|timespec
id|local_mtime
suffix:semicolon
r_int
id|invalidate_inode
op_assign
id|FALSE
suffix:semicolon
r_if
c_cond
(paren
id|direntry-&gt;d_inode
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOENT
suffix:semicolon
id|cifsInode
op_assign
id|CIFS_I
c_func
(paren
id|direntry-&gt;d_inode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cifsInode
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOENT
suffix:semicolon
multiline_comment|/* no sense revalidating inode info on file that no one can write */
r_if
c_cond
(paren
id|CIFS_I
c_func
(paren
id|direntry-&gt;d_inode
)paren
op_member_access_from_pointer
id|clientCanCacheRead
)paren
r_return
id|rc
suffix:semicolon
id|xid
op_assign
id|GetXid
c_func
(paren
)paren
suffix:semicolon
id|cifs_sb
op_assign
id|CIFS_SB
c_func
(paren
id|direntry-&gt;d_sb
)paren
suffix:semicolon
multiline_comment|/* can not safely grab the rename sem here if rename calls revalidate&n;&t;   since that would deadlock */
id|full_path
op_assign
id|build_path_from_dentry
c_func
(paren
id|direntry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|full_path
op_eq
l_int|NULL
)paren
(brace
id|FreeXid
c_func
(paren
id|xid
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;Revalidate: %s inode 0x%p count %d dentry: 0x%p d_time %ld &quot;
l_string|&quot;jiffies %ld&quot;
comma
id|full_path
comma
id|direntry-&gt;d_inode
comma
id|direntry-&gt;d_inode-&gt;i_count.counter
comma
id|direntry
comma
id|direntry-&gt;d_time
comma
id|jiffies
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cifsInode-&gt;time
op_eq
l_int|0
)paren
(brace
multiline_comment|/* was set to zero previously to force revalidate */
)brace
r_else
r_if
c_cond
(paren
id|time_before
c_func
(paren
id|jiffies
comma
id|cifsInode-&gt;time
op_plus
id|HZ
)paren
op_logical_and
id|lookupCacheEnabled
)paren
(brace
r_if
c_cond
(paren
(paren
id|S_ISREG
c_func
(paren
id|direntry-&gt;d_inode-&gt;i_mode
)paren
op_eq
l_int|0
)paren
op_logical_or
(paren
id|direntry-&gt;d_inode-&gt;i_nlink
op_eq
l_int|1
)paren
)paren
(brace
id|kfree
c_func
(paren
id|full_path
)paren
suffix:semicolon
id|FreeXid
c_func
(paren
id|xid
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
r_else
(brace
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;Have to revalidate file due to hardlinks&quot;
)paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* save mtime and size */
id|local_mtime
op_assign
id|direntry-&gt;d_inode-&gt;i_mtime
suffix:semicolon
id|local_size
op_assign
id|direntry-&gt;d_inode-&gt;i_size
suffix:semicolon
r_if
c_cond
(paren
id|cifs_sb-&gt;tcon-&gt;ses-&gt;capabilities
op_amp
id|CAP_UNIX
)paren
(brace
id|rc
op_assign
id|cifs_get_inode_info_unix
c_func
(paren
op_amp
id|direntry-&gt;d_inode
comma
id|full_path
comma
id|direntry-&gt;d_sb
comma
id|xid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
(brace
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;error on getting revalidate info %d&quot;
comma
id|rc
)paren
)paren
suffix:semicolon
multiline_comment|/*&t;&t;&t;if (rc != -ENOENT)&n;&t;&t;&t;&t;rc = 0; */
multiline_comment|/* BB should we cache info on&n;&t;&t;&t;&t;&t;&t;   certain errors? */
)brace
)brace
r_else
(brace
id|rc
op_assign
id|cifs_get_inode_info
c_func
(paren
op_amp
id|direntry-&gt;d_inode
comma
id|full_path
comma
l_int|NULL
comma
id|direntry-&gt;d_sb
comma
id|xid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
(brace
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;error on getting revalidate info %d&quot;
comma
id|rc
)paren
)paren
suffix:semicolon
multiline_comment|/*&t;&t;&t;if (rc != -ENOENT)&n;&t;&t;&t;&t;rc = 0; */
multiline_comment|/* BB should we cache info on&n;&t;&t;&t;&t;&t;&t;   certain errors? */
)brace
)brace
multiline_comment|/* should we remap certain errors, access denied?, to zero */
multiline_comment|/* if not oplocked, we invalidate inode pages if mtime or file size&n;&t;   had changed on server */
r_if
c_cond
(paren
id|timespec_equal
c_func
(paren
op_amp
id|local_mtime
comma
op_amp
id|direntry-&gt;d_inode-&gt;i_mtime
)paren
op_logical_and
(paren
id|local_size
op_eq
id|direntry-&gt;d_inode-&gt;i_size
)paren
)paren
(brace
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;cifs_revalidate - inode unchanged&quot;
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* file may have changed on server */
r_if
c_cond
(paren
id|cifsInode-&gt;clientCanCacheRead
)paren
(brace
multiline_comment|/* no need to invalidate inode pages since we were the&n;&t;&t;&t;   only ones who could have modified the file and the&n;&t;&t;&t;   server copy is staler than ours */
)brace
r_else
(brace
id|invalidate_inode
op_assign
id|TRUE
suffix:semicolon
)brace
)brace
multiline_comment|/* can not grab this sem since kernel filesys locking documentation&n;&t;   indicates i_sem may be taken by the kernel on lookup and rename&n;&t;   which could deadlock if we grab the i_sem here as well */
multiline_comment|/*&t;down(&amp;direntry-&gt;d_inode-&gt;i_sem);*/
multiline_comment|/* need to write out dirty pages here  */
r_if
c_cond
(paren
id|direntry-&gt;d_inode-&gt;i_mapping
)paren
(brace
multiline_comment|/* do we need to lock inode until after invalidate completes&n;&t;&t;   below? */
id|filemap_fdatawrite
c_func
(paren
id|direntry-&gt;d_inode-&gt;i_mapping
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|invalidate_inode
)paren
(brace
r_if
c_cond
(paren
id|direntry-&gt;d_inode-&gt;i_mapping
)paren
id|filemap_fdatawait
c_func
(paren
id|direntry-&gt;d_inode-&gt;i_mapping
)paren
suffix:semicolon
multiline_comment|/* may eventually have to do this for open files too */
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
(paren
id|cifsInode-&gt;openFileList
)paren
)paren
)paren
(brace
multiline_comment|/* Has changed on server - flush read ahead pages */
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;Invalidating read ahead data on &quot;
l_string|&quot;closed file&quot;
)paren
)paren
suffix:semicolon
id|invalidate_remote_inode
c_func
(paren
id|direntry-&gt;d_inode
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&t;up(&amp;direntry-&gt;d_inode-&gt;i_sem); */
id|kfree
c_func
(paren
id|full_path
)paren
suffix:semicolon
id|FreeXid
c_func
(paren
id|xid
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
DECL|function|cifs_getattr
r_int
id|cifs_getattr
c_func
(paren
r_struct
id|vfsmount
op_star
id|mnt
comma
r_struct
id|dentry
op_star
id|dentry
comma
r_struct
id|kstat
op_star
id|stat
)paren
(brace
r_int
id|err
op_assign
id|cifs_revalidate
c_func
(paren
id|dentry
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|err
)paren
id|generic_fillattr
c_func
(paren
id|dentry-&gt;d_inode
comma
id|stat
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|function|cifs_truncate_page
r_static
r_int
id|cifs_truncate_page
c_func
(paren
r_struct
id|address_space
op_star
id|mapping
comma
id|loff_t
id|from
)paren
(brace
id|pgoff_t
id|index
op_assign
id|from
op_rshift
id|PAGE_CACHE_SHIFT
suffix:semicolon
r_int
id|offset
op_assign
id|from
op_amp
(paren
id|PAGE_CACHE_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
r_char
op_star
id|kaddr
suffix:semicolon
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
id|page
op_assign
id|grab_cache_page
c_func
(paren
id|mapping
comma
id|index
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|kaddr
op_assign
id|kmap_atomic
c_func
(paren
id|page
comma
id|KM_USER0
)paren
suffix:semicolon
id|memset
c_func
(paren
id|kaddr
op_plus
id|offset
comma
l_int|0
comma
id|PAGE_CACHE_SIZE
op_minus
id|offset
)paren
suffix:semicolon
id|flush_dcache_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|kunmap_atomic
c_func
(paren
id|kaddr
comma
id|KM_USER0
)paren
suffix:semicolon
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
DECL|function|cifs_setattr
r_int
id|cifs_setattr
c_func
(paren
r_struct
id|dentry
op_star
id|direntry
comma
r_struct
id|iattr
op_star
id|attrs
)paren
(brace
r_int
id|xid
suffix:semicolon
r_struct
id|cifs_sb_info
op_star
id|cifs_sb
suffix:semicolon
r_struct
id|cifsTconInfo
op_star
id|pTcon
suffix:semicolon
r_char
op_star
id|full_path
op_assign
l_int|NULL
suffix:semicolon
r_int
id|rc
op_assign
op_minus
id|EACCES
suffix:semicolon
r_int
id|found
op_assign
id|FALSE
suffix:semicolon
r_struct
id|cifsFileInfo
op_star
id|open_file
op_assign
l_int|NULL
suffix:semicolon
id|FILE_BASIC_INFO
id|time_buf
suffix:semicolon
r_int
id|set_time
op_assign
id|FALSE
suffix:semicolon
id|__u64
id|mode
op_assign
l_int|0xFFFFFFFFFFFFFFFFULL
suffix:semicolon
id|__u64
id|uid
op_assign
l_int|0xFFFFFFFFFFFFFFFFULL
suffix:semicolon
id|__u64
id|gid
op_assign
l_int|0xFFFFFFFFFFFFFFFFULL
suffix:semicolon
r_struct
id|cifsInodeInfo
op_star
id|cifsInode
suffix:semicolon
r_struct
id|list_head
op_star
id|tmp
suffix:semicolon
id|xid
op_assign
id|GetXid
c_func
(paren
)paren
suffix:semicolon
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot; In cifs_setattr, name = %s attrs-&gt;iavalid 0x%x &quot;
comma
id|direntry-&gt;d_name.name
comma
id|attrs-&gt;ia_valid
)paren
)paren
suffix:semicolon
id|cifs_sb
op_assign
id|CIFS_SB
c_func
(paren
id|direntry-&gt;d_inode-&gt;i_sb
)paren
suffix:semicolon
id|pTcon
op_assign
id|cifs_sb-&gt;tcon
suffix:semicolon
id|down
c_func
(paren
op_amp
id|direntry-&gt;d_sb-&gt;s_vfs_rename_sem
)paren
suffix:semicolon
id|full_path
op_assign
id|build_path_from_dentry
c_func
(paren
id|direntry
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|direntry-&gt;d_sb-&gt;s_vfs_rename_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|full_path
op_eq
l_int|NULL
)paren
(brace
id|FreeXid
c_func
(paren
id|xid
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|cifsInode
op_assign
id|CIFS_I
c_func
(paren
id|direntry-&gt;d_inode
)paren
suffix:semicolon
multiline_comment|/* BB check if we need to refresh inode from server now ? BB */
multiline_comment|/* need to flush data before changing file size on server */
id|filemap_fdatawrite
c_func
(paren
id|direntry-&gt;d_inode-&gt;i_mapping
)paren
suffix:semicolon
id|filemap_fdatawait
c_func
(paren
id|direntry-&gt;d_inode-&gt;i_mapping
)paren
suffix:semicolon
r_if
c_cond
(paren
id|attrs-&gt;ia_valid
op_amp
id|ATTR_SIZE
)paren
(brace
id|read_lock
c_func
(paren
op_amp
id|GlobalSMBSeslock
)paren
suffix:semicolon
multiline_comment|/* To avoid spurious oplock breaks from server, in the case of&n;&t;&t;   inodes that we already have open, avoid doing path based&n;&t;&t;   setting of file size if we can do it by handle.&n;&t;&t;   This keeps our caching token (oplock) and avoids timeouts&n;&t;&t;   when the local oplock break takes longer to flush&n;&t;&t;   writebehind data than the SMB timeout for the SetPathInfo&n;&t;&t;   request would allow */
id|list_for_each
c_func
(paren
id|tmp
comma
op_amp
id|cifsInode-&gt;openFileList
)paren
(brace
id|open_file
op_assign
id|list_entry
c_func
(paren
id|tmp
comma
r_struct
id|cifsFileInfo
comma
id|flist
)paren
suffix:semicolon
multiline_comment|/* We check if file is open for writing first */
r_if
c_cond
(paren
(paren
id|open_file-&gt;pfile
)paren
op_logical_and
(paren
(paren
id|open_file-&gt;pfile-&gt;f_flags
op_amp
id|O_RDWR
)paren
op_logical_or
(paren
id|open_file-&gt;pfile-&gt;f_flags
op_amp
id|O_WRONLY
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|open_file-&gt;invalidHandle
op_eq
id|FALSE
)paren
(brace
multiline_comment|/* we found a valid, writeable network&n;&t;&t;&t;&t;&t;   file handle to use to try to set the&n;&t;&t;&t;&t;&t;   file size */
id|__u16
id|nfid
op_assign
id|open_file-&gt;netfid
suffix:semicolon
id|__u32
id|npid
op_assign
id|open_file-&gt;pid
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|GlobalSMBSeslock
)paren
suffix:semicolon
id|found
op_assign
id|TRUE
suffix:semicolon
id|rc
op_assign
id|CIFSSMBSetFileSize
c_func
(paren
id|xid
comma
id|pTcon
comma
id|attrs-&gt;ia_size
comma
id|nfid
comma
id|npid
comma
id|FALSE
)paren
suffix:semicolon
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;SetFileSize by handle &quot;
l_string|&quot;(setattrs) rc = %d&quot;
comma
id|rc
)paren
)paren
suffix:semicolon
multiline_comment|/* Do not need reopen and retry on&n;&t;&t;&t;&t;&t;   EAGAIN since we will retry by&n;&t;&t;&t;&t;&t;   pathname below */
multiline_comment|/* now that we found one valid file&n;&t;&t;&t;&t;&t;   handle no sense continuing to loop&n;&t;&t;&t;&t;&t;   trying others, so break here */
r_break
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|found
op_eq
id|FALSE
)paren
id|read_unlock
c_func
(paren
op_amp
id|GlobalSMBSeslock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_ne
l_int|0
)paren
(brace
multiline_comment|/* Set file size by pathname rather than by handle&n;&t;&t;&t;   either because no valid, writeable file handle for&n;&t;&t;&t;   it was found or because there was an error setting&n;&t;&t;&t;   it by handle */
id|rc
op_assign
id|CIFSSMBSetEOF
c_func
(paren
id|xid
comma
id|pTcon
comma
id|full_path
comma
id|attrs-&gt;ia_size
comma
id|FALSE
comma
id|cifs_sb-&gt;local_nls
)paren
suffix:semicolon
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot; SetEOF by path (setattrs) rc = %d&quot;
comma
id|rc
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Server is ok setting allocation size implicitly - no need&n;&t;&t;   to call:&n;&t;&t;CIFSSMBSetEOF(xid, pTcon, full_path, attrs-&gt;ia_size, TRUE,&n;&t;&t;&t; cifs_sb-&gt;local_nls);&n;&t;&t;   */
r_if
c_cond
(paren
id|rc
op_eq
l_int|0
)paren
(brace
id|rc
op_assign
id|vmtruncate
c_func
(paren
id|direntry-&gt;d_inode
comma
id|attrs-&gt;ia_size
)paren
suffix:semicolon
id|cifs_truncate_page
c_func
(paren
id|direntry-&gt;d_inode-&gt;i_mapping
comma
id|direntry-&gt;d_inode-&gt;i_size
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|attrs-&gt;ia_valid
op_amp
id|ATTR_UID
)paren
(brace
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot; CIFS - UID changed to %d&quot;
comma
id|attrs-&gt;ia_uid
)paren
)paren
suffix:semicolon
id|uid
op_assign
id|attrs-&gt;ia_uid
suffix:semicolon
multiline_comment|/* entry-&gt;uid = cpu_to_le16(attr-&gt;ia_uid); */
)brace
r_if
c_cond
(paren
id|attrs-&gt;ia_valid
op_amp
id|ATTR_GID
)paren
(brace
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot; CIFS - GID changed to %d&quot;
comma
id|attrs-&gt;ia_gid
)paren
)paren
suffix:semicolon
id|gid
op_assign
id|attrs-&gt;ia_gid
suffix:semicolon
multiline_comment|/* entry-&gt;gid = cpu_to_le16(attr-&gt;ia_gid); */
)brace
id|time_buf.Attributes
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|attrs-&gt;ia_valid
op_amp
id|ATTR_MODE
)paren
(brace
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot; CIFS - Mode changed to 0x%x&quot;
comma
id|attrs-&gt;ia_mode
)paren
)paren
suffix:semicolon
id|mode
op_assign
id|attrs-&gt;ia_mode
suffix:semicolon
multiline_comment|/* entry-&gt;mode = cpu_to_le16(attr-&gt;ia_mode); */
)brace
r_if
c_cond
(paren
(paren
id|cifs_sb-&gt;tcon-&gt;ses-&gt;capabilities
op_amp
id|CAP_UNIX
)paren
op_logical_and
(paren
id|attrs-&gt;ia_valid
op_amp
(paren
id|ATTR_MODE
op_or
id|ATTR_GID
op_or
id|ATTR_UID
)paren
)paren
)paren
id|rc
op_assign
id|CIFSSMBUnixSetPerms
c_func
(paren
id|xid
comma
id|pTcon
comma
id|full_path
comma
id|mode
comma
id|uid
comma
id|gid
comma
l_int|0
multiline_comment|/* dev_t */
comma
id|cifs_sb-&gt;local_nls
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|attrs-&gt;ia_valid
op_amp
id|ATTR_MODE
)paren
(brace
r_if
c_cond
(paren
(paren
id|mode
op_amp
id|S_IWUGO
)paren
op_eq
l_int|0
)paren
multiline_comment|/* not writeable */
(brace
r_if
c_cond
(paren
(paren
id|cifsInode-&gt;cifsAttrs
op_amp
id|ATTR_READONLY
)paren
op_eq
l_int|0
)paren
id|time_buf.Attributes
op_assign
id|cpu_to_le32
c_func
(paren
id|cifsInode-&gt;cifsAttrs
op_or
id|ATTR_READONLY
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|mode
op_amp
id|S_IWUGO
)paren
op_eq
id|S_IWUGO
)paren
(brace
r_if
c_cond
(paren
id|cifsInode-&gt;cifsAttrs
op_amp
id|ATTR_READONLY
)paren
id|time_buf.Attributes
op_assign
id|cpu_to_le32
c_func
(paren
id|cifsInode-&gt;cifsAttrs
op_amp
(paren
op_complement
id|ATTR_READONLY
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* BB to be implemented -&n;&t;&t;   via Windows security descriptors or streams */
multiline_comment|/* CIFSSMBWinSetPerms(xid, pTcon, full_path, mode, uid, gid,&n;&t;&t;&t;&t;      cifs_sb-&gt;local_nls); */
)brace
r_if
c_cond
(paren
id|attrs-&gt;ia_valid
op_amp
id|ATTR_ATIME
)paren
(brace
id|set_time
op_assign
id|TRUE
suffix:semicolon
id|time_buf.LastAccessTime
op_assign
id|cpu_to_le64
c_func
(paren
id|cifs_UnixTimeToNT
c_func
(paren
id|attrs-&gt;ia_atime
)paren
)paren
suffix:semicolon
)brace
r_else
id|time_buf.LastAccessTime
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|attrs-&gt;ia_valid
op_amp
id|ATTR_MTIME
)paren
(brace
id|set_time
op_assign
id|TRUE
suffix:semicolon
id|time_buf.LastWriteTime
op_assign
id|cpu_to_le64
c_func
(paren
id|cifs_UnixTimeToNT
c_func
(paren
id|attrs-&gt;ia_mtime
)paren
)paren
suffix:semicolon
)brace
r_else
id|time_buf.LastWriteTime
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|attrs-&gt;ia_valid
op_amp
id|ATTR_CTIME
)paren
(brace
id|set_time
op_assign
id|TRUE
suffix:semicolon
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot; CIFS - CTIME changed &quot;
)paren
)paren
suffix:semicolon
multiline_comment|/* BB probably no need */
id|time_buf.ChangeTime
op_assign
id|cpu_to_le64
c_func
(paren
id|cifs_UnixTimeToNT
c_func
(paren
id|attrs-&gt;ia_ctime
)paren
)paren
suffix:semicolon
)brace
r_else
id|time_buf.ChangeTime
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|set_time
op_logical_or
id|time_buf.Attributes
)paren
(brace
multiline_comment|/* BB what if setting one attribute fails (such as size) but&n;&t;&t;   time setting works? */
id|time_buf.CreationTime
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* do not change */
multiline_comment|/* In the future we should experiment - try setting timestamps&n;&t;&t;   via Handle (SetFileInfo) instead of by path */
r_if
c_cond
(paren
op_logical_neg
(paren
id|pTcon-&gt;ses-&gt;flags
op_amp
id|CIFS_SES_NT4
)paren
)paren
id|rc
op_assign
id|CIFSSMBSetTimes
c_func
(paren
id|xid
comma
id|pTcon
comma
id|full_path
comma
op_amp
id|time_buf
comma
id|cifs_sb-&gt;local_nls
)paren
suffix:semicolon
r_else
id|rc
op_assign
op_minus
id|EOPNOTSUPP
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_eq
op_minus
id|EOPNOTSUPP
)paren
(brace
r_int
id|oplock
op_assign
id|FALSE
suffix:semicolon
id|__u16
id|netfid
suffix:semicolon
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;calling SetFileInfo since SetPathInfo for &quot;
l_string|&quot;times not supported by this server&quot;
)paren
)paren
suffix:semicolon
multiline_comment|/* BB we could scan to see if we already have it open&n;&t;&t;&t;   and pass in pid of opener to function */
id|rc
op_assign
id|CIFSSMBOpen
c_func
(paren
id|xid
comma
id|pTcon
comma
id|full_path
comma
id|FILE_OPEN
comma
id|SYNCHRONIZE
op_or
id|FILE_WRITE_ATTRIBUTES
comma
id|CREATE_NOT_DIR
comma
op_amp
id|netfid
comma
op_amp
id|oplock
comma
l_int|NULL
comma
id|cifs_sb-&gt;local_nls
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_eq
l_int|0
)paren
(brace
id|rc
op_assign
id|CIFSSMBSetFileTimes
c_func
(paren
id|xid
comma
id|pTcon
comma
op_amp
id|time_buf
comma
id|netfid
)paren
suffix:semicolon
id|CIFSSMBClose
c_func
(paren
id|xid
comma
id|pTcon
comma
id|netfid
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* BB For even older servers we could convert time_buf&n;&t;&t;&t;   into old DOS style which uses two second&n;&t;&t;&t;   granularity */
multiline_comment|/* rc = CIFSSMBSetTimesLegacy(xid, pTcon, full_path,&n;        &t;        &t;&t;&amp;time_buf, cifs_sb-&gt;local_nls); */
)brace
)brace
)brace
multiline_comment|/* do not need local check to inode_check_ok since the server does&n;&t;   that */
r_if
c_cond
(paren
op_logical_neg
id|rc
)paren
id|rc
op_assign
id|inode_setattr
c_func
(paren
id|direntry-&gt;d_inode
comma
id|attrs
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|full_path
)paren
suffix:semicolon
id|FreeXid
c_func
(paren
id|xid
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
DECL|function|cifs_delete_inode
r_void
id|cifs_delete_inode
c_func
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;In cifs_delete_inode, inode = 0x%p &quot;
comma
id|inode
)paren
)paren
suffix:semicolon
multiline_comment|/* may have to add back in if and when safe distributed caching of&n;&t;   directories added e.g. via FindNotify */
)brace
eof
