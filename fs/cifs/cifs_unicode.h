multiline_comment|/*&n; * cifs_unicode:  Unicode kernel case support&n; *&n; * Function:&n; *     Convert a unicode character to upper or lower case using&n; *     compressed tables.&n; *&n; *   Copyright (c) International Business Machines  Corp., 2000,2002&n; *&n; *   This program is free software;  you can redistribute it and/or modify&n; *   it under the terms of the GNU General Public License as published by&n; *   the Free Software Foundation; either version 2 of the License, or &n; *   (at your option) any later version.&n; * &n; *   This program is distributed in the hope that it will be useful,&n; *   but WITHOUT ANY WARRANTY;  without even the implied warranty of&n; *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See&n; *   the GNU General Public License for more details.&n; *&n; *   You should have received a copy of the GNU General Public License&n; *   along with this program;  if not, write to the Free Software &n; *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA&n; *&n; *&n; * Notes:&n; *     These APIs are based on the C library functions.  The semantics&n; *     should match the C functions but with expanded size operands.&n; *&n; *     The upper/lower functions are based on a table created by mkupr.&n; *     This is a compressed table of upper and lower case conversion.&n; *&n; */
macro_line|#include &lt;asm/byteorder.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/nls.h&gt;
DECL|macro|UNIUPR_NOLOWER
mdefine_line|#define  UNIUPR_NOLOWER&t;&t;/* Example to not expand lower case tables */
multiline_comment|/* Just define what we want from uniupr.h.  We don&squot;t want to define the tables&n; * in each source file.&n; */
macro_line|#ifndef&t;UNICASERANGE_DEFINED
DECL|struct|UniCaseRange
r_struct
id|UniCaseRange
(brace
DECL|member|start
m_wchar_t
id|start
suffix:semicolon
DECL|member|end
m_wchar_t
id|end
suffix:semicolon
DECL|member|table
r_int
r_char
op_star
id|table
suffix:semicolon
)brace
suffix:semicolon
macro_line|#endif&t;&t;&t;&t;/* UNICASERANGE_DEFINED */
macro_line|#ifndef UNIUPR_NOUPPER
r_extern
r_int
r_char
id|CifsUniUpperTable
(braket
l_int|512
)braket
suffix:semicolon
r_extern
r_const
r_struct
id|UniCaseRange
id|CifsUniUpperRange
(braket
)braket
suffix:semicolon
macro_line|#endif&t;&t;&t;&t;/* UNIUPR_NOUPPER */
macro_line|#ifndef UNIUPR_NOLOWER
r_extern
r_int
r_char
id|UniLowerTable
(braket
l_int|512
)braket
suffix:semicolon
r_extern
r_struct
id|UniCaseRange
id|UniLowerRange
(braket
)braket
suffix:semicolon
macro_line|#endif&t;&t;&t;&t;/* UNIUPR_NOLOWER */
multiline_comment|/*&n; *      directory entry argument&n; */
DECL|struct|component_name
r_struct
id|component_name
(brace
DECL|member|namlen
r_int
id|namlen
suffix:semicolon
DECL|member|name
m_wchar_t
op_star
id|name
suffix:semicolon
)brace
suffix:semicolon
macro_line|#ifdef __KERNEL__
r_int
id|cifs_strfromUCS_le
c_func
(paren
r_char
op_star
comma
r_const
m_wchar_t
op_star
comma
r_int
comma
r_const
r_struct
id|nls_table
op_star
)paren
suffix:semicolon
r_int
id|cifs_strtoUCS
c_func
(paren
m_wchar_t
op_star
comma
r_const
r_char
op_star
comma
r_int
comma
r_const
r_struct
id|nls_table
op_star
)paren
suffix:semicolon
r_int
id|cifs_UCSname
c_func
(paren
r_struct
id|component_name
op_star
comma
r_struct
id|dentry
op_star
comma
r_const
r_struct
id|nls_table
op_star
)paren
suffix:semicolon
r_void
id|toUpper
c_func
(paren
r_const
r_struct
id|nls_table
op_star
comma
r_char
op_star
)paren
suffix:semicolon
macro_line|#endif
DECL|macro|free_UCSname
mdefine_line|#define free_UCSname(COMP) kfree((COMP)-&gt;name)
multiline_comment|/*&n; * UniStrcat:  Concatenate the second string to the first&n; *&n; * Returns:&n; *     Address of the first string&n; */
r_static
r_inline
m_wchar_t
op_star
DECL|function|UniStrcat
id|UniStrcat
c_func
(paren
m_wchar_t
op_star
id|ucs1
comma
r_const
m_wchar_t
op_star
id|ucs2
)paren
(brace
m_wchar_t
op_star
id|anchor
op_assign
id|ucs1
suffix:semicolon
multiline_comment|/* save a pointer to start of ucs1 */
r_while
c_loop
(paren
op_star
id|ucs1
op_increment
)paren
suffix:semicolon
multiline_comment|/* To end of first string */
id|ucs1
op_decrement
suffix:semicolon
multiline_comment|/* Return to the null */
r_while
c_loop
(paren
(paren
op_star
id|ucs1
op_increment
op_assign
op_star
id|ucs2
op_increment
)paren
)paren
suffix:semicolon
multiline_comment|/* copy string 2 over */
r_return
id|anchor
suffix:semicolon
)brace
multiline_comment|/*&n; * UniStrchr:  Find a character in a string&n; *&n; * Returns:&n; *     Address of first occurrence of character in string&n; *     or NULL if the character is not in the string&n; */
r_static
r_inline
m_wchar_t
op_star
DECL|function|UniStrchr
id|UniStrchr
c_func
(paren
r_const
m_wchar_t
op_star
id|ucs
comma
m_wchar_t
id|uc
)paren
(brace
r_while
c_loop
(paren
(paren
op_star
id|ucs
op_ne
id|uc
)paren
op_logical_and
op_star
id|ucs
)paren
id|ucs
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_star
id|ucs
op_eq
id|uc
)paren
r_return
(paren
m_wchar_t
op_star
)paren
id|ucs
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * UniStrcmp:  Compare two strings&n; *&n; * Returns:&n; *     &lt; 0:  First string is less than second&n; *     = 0:  Strings are equal&n; *     &gt; 0:  First string is greater than second&n; */
r_static
r_inline
r_int
DECL|function|UniStrcmp
id|UniStrcmp
c_func
(paren
r_const
m_wchar_t
op_star
id|ucs1
comma
r_const
m_wchar_t
op_star
id|ucs2
)paren
(brace
r_while
c_loop
(paren
(paren
op_star
id|ucs1
op_eq
op_star
id|ucs2
)paren
op_logical_and
op_star
id|ucs1
)paren
(brace
id|ucs1
op_increment
suffix:semicolon
id|ucs2
op_increment
suffix:semicolon
)brace
r_return
(paren
r_int
)paren
op_star
id|ucs1
op_minus
(paren
r_int
)paren
op_star
id|ucs2
suffix:semicolon
)brace
multiline_comment|/*&n; * UniStrcpy:  Copy a string&n; */
r_static
r_inline
m_wchar_t
op_star
DECL|function|UniStrcpy
id|UniStrcpy
c_func
(paren
m_wchar_t
op_star
id|ucs1
comma
r_const
m_wchar_t
op_star
id|ucs2
)paren
(brace
m_wchar_t
op_star
id|anchor
op_assign
id|ucs1
suffix:semicolon
multiline_comment|/* save the start of result string */
r_while
c_loop
(paren
(paren
op_star
id|ucs1
op_increment
op_assign
op_star
id|ucs2
op_increment
)paren
)paren
suffix:semicolon
r_return
id|anchor
suffix:semicolon
)brace
multiline_comment|/*&n; * UniStrlen:  Return the length of a string (in 16 bit Unicode chars not bytes)&n; */
r_static
r_inline
r_int
DECL|function|UniStrlen
id|UniStrlen
c_func
(paren
r_const
m_wchar_t
op_star
id|ucs1
)paren
(brace
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
op_star
id|ucs1
op_increment
)paren
id|i
op_increment
suffix:semicolon
r_return
id|i
suffix:semicolon
)brace
multiline_comment|/*&n; * UniStrnlen:  Return the length (in 16 bit Unicode chars not bytes) of a string (length limited)&n; */
r_static
r_inline
r_int
DECL|function|UniStrnlen
id|UniStrnlen
c_func
(paren
r_const
m_wchar_t
op_star
id|ucs1
comma
r_int
id|maxlen
)paren
(brace
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
op_star
id|ucs1
op_increment
)paren
(brace
id|i
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|i
op_ge
id|maxlen
)paren
r_break
suffix:semicolon
)brace
r_return
id|i
suffix:semicolon
)brace
multiline_comment|/*&n; * UniStrncat:  Concatenate length limited string&n; */
r_static
r_inline
m_wchar_t
op_star
DECL|function|UniStrncat
id|UniStrncat
c_func
(paren
m_wchar_t
op_star
id|ucs1
comma
r_const
m_wchar_t
op_star
id|ucs2
comma
r_int
id|n
)paren
(brace
m_wchar_t
op_star
id|anchor
op_assign
id|ucs1
suffix:semicolon
multiline_comment|/* save pointer to string 1 */
r_while
c_loop
(paren
op_star
id|ucs1
op_increment
)paren
suffix:semicolon
id|ucs1
op_decrement
suffix:semicolon
multiline_comment|/* point to null terminator of s1 */
r_while
c_loop
(paren
id|n
op_decrement
op_logical_and
(paren
op_star
id|ucs1
op_assign
op_star
id|ucs2
)paren
)paren
(brace
multiline_comment|/* copy s2 after s1 */
id|ucs1
op_increment
suffix:semicolon
id|ucs2
op_increment
suffix:semicolon
)brace
op_star
id|ucs1
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Null terminate the result */
r_return
(paren
id|anchor
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * UniStrncmp:  Compare length limited string&n; */
r_static
r_inline
r_int
DECL|function|UniStrncmp
id|UniStrncmp
c_func
(paren
r_const
m_wchar_t
op_star
id|ucs1
comma
r_const
m_wchar_t
op_star
id|ucs2
comma
r_int
id|n
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|n
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Null strings are equal */
r_while
c_loop
(paren
(paren
op_star
id|ucs1
op_eq
op_star
id|ucs2
)paren
op_logical_and
op_star
id|ucs1
op_logical_and
op_decrement
id|n
)paren
(brace
id|ucs1
op_increment
suffix:semicolon
id|ucs2
op_increment
suffix:semicolon
)brace
r_return
(paren
r_int
)paren
op_star
id|ucs1
op_minus
(paren
r_int
)paren
op_star
id|ucs2
suffix:semicolon
)brace
multiline_comment|/*&n; * UniStrncmp_le:  Compare length limited string - native to little-endian&n; */
r_static
r_inline
r_int
DECL|function|UniStrncmp_le
id|UniStrncmp_le
c_func
(paren
r_const
m_wchar_t
op_star
id|ucs1
comma
r_const
m_wchar_t
op_star
id|ucs2
comma
r_int
id|n
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|n
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Null strings are equal */
r_while
c_loop
(paren
(paren
op_star
id|ucs1
op_eq
id|__le16_to_cpu
c_func
(paren
op_star
id|ucs2
)paren
)paren
op_logical_and
op_star
id|ucs1
op_logical_and
op_decrement
id|n
)paren
(brace
id|ucs1
op_increment
suffix:semicolon
id|ucs2
op_increment
suffix:semicolon
)brace
r_return
(paren
r_int
)paren
op_star
id|ucs1
op_minus
(paren
r_int
)paren
id|__le16_to_cpu
c_func
(paren
op_star
id|ucs2
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * UniStrncpy:  Copy length limited string with pad&n; */
r_static
r_inline
m_wchar_t
op_star
DECL|function|UniStrncpy
id|UniStrncpy
c_func
(paren
m_wchar_t
op_star
id|ucs1
comma
r_const
m_wchar_t
op_star
id|ucs2
comma
r_int
id|n
)paren
(brace
m_wchar_t
op_star
id|anchor
op_assign
id|ucs1
suffix:semicolon
r_while
c_loop
(paren
id|n
op_decrement
op_logical_and
op_star
id|ucs2
)paren
multiline_comment|/* Copy the strings */
op_star
id|ucs1
op_increment
op_assign
op_star
id|ucs2
op_increment
suffix:semicolon
id|n
op_increment
suffix:semicolon
r_while
c_loop
(paren
id|n
op_decrement
)paren
multiline_comment|/* Pad with nulls */
op_star
id|ucs1
op_increment
op_assign
l_int|0
suffix:semicolon
r_return
id|anchor
suffix:semicolon
)brace
multiline_comment|/*&n; * UniStrncpy_le:  Copy length limited string with pad to little-endian&n; */
r_static
r_inline
m_wchar_t
op_star
DECL|function|UniStrncpy_le
id|UniStrncpy_le
c_func
(paren
m_wchar_t
op_star
id|ucs1
comma
r_const
m_wchar_t
op_star
id|ucs2
comma
r_int
id|n
)paren
(brace
m_wchar_t
op_star
id|anchor
op_assign
id|ucs1
suffix:semicolon
r_while
c_loop
(paren
id|n
op_decrement
op_logical_and
op_star
id|ucs2
)paren
multiline_comment|/* Copy the strings */
op_star
id|ucs1
op_increment
op_assign
id|__le16_to_cpu
c_func
(paren
op_star
id|ucs2
op_increment
)paren
suffix:semicolon
id|n
op_increment
suffix:semicolon
r_while
c_loop
(paren
id|n
op_decrement
)paren
multiline_comment|/* Pad with nulls */
op_star
id|ucs1
op_increment
op_assign
l_int|0
suffix:semicolon
r_return
id|anchor
suffix:semicolon
)brace
multiline_comment|/*&n; * UniStrstr:  Find a string in a string&n; *&n; * Returns:&n; *     Address of first match found&n; *     NULL if no matching string is found&n; */
r_static
r_inline
m_wchar_t
op_star
DECL|function|UniStrstr
id|UniStrstr
c_func
(paren
r_const
m_wchar_t
op_star
id|ucs1
comma
r_const
m_wchar_t
op_star
id|ucs2
)paren
(brace
r_const
m_wchar_t
op_star
id|anchor1
op_assign
id|ucs1
suffix:semicolon
r_const
m_wchar_t
op_star
id|anchor2
op_assign
id|ucs2
suffix:semicolon
r_while
c_loop
(paren
op_star
id|ucs1
)paren
(brace
r_if
c_cond
(paren
op_star
id|ucs1
op_eq
op_star
id|ucs2
)paren
(brace
multiline_comment|/* Partial match found */
id|ucs1
op_increment
suffix:semicolon
id|ucs2
op_increment
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
op_star
id|ucs2
)paren
multiline_comment|/* Match found */
r_return
(paren
m_wchar_t
op_star
)paren
id|anchor1
suffix:semicolon
id|ucs1
op_assign
op_increment
id|anchor1
suffix:semicolon
multiline_comment|/* No match */
id|ucs2
op_assign
id|anchor2
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
op_star
id|ucs2
)paren
multiline_comment|/* Both end together */
r_return
(paren
m_wchar_t
op_star
)paren
id|anchor1
suffix:semicolon
multiline_comment|/* Match found */
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/* No match */
)brace
macro_line|#ifndef UNIUPR_NOUPPER
multiline_comment|/*&n; * UniToupper:  Convert a unicode character to upper case&n; */
r_static
r_inline
m_wchar_t
DECL|function|UniToupper
id|UniToupper
c_func
(paren
r_register
m_wchar_t
id|uc
)paren
(brace
r_register
r_const
r_struct
id|UniCaseRange
op_star
id|rp
suffix:semicolon
r_if
c_cond
(paren
id|uc
OL
r_sizeof
(paren
id|CifsUniUpperTable
)paren
)paren
(brace
multiline_comment|/* Latin characters */
r_return
id|uc
op_plus
id|CifsUniUpperTable
(braket
id|uc
)braket
suffix:semicolon
multiline_comment|/* Use base tables */
)brace
r_else
(brace
id|rp
op_assign
id|CifsUniUpperRange
suffix:semicolon
multiline_comment|/* Use range tables */
r_while
c_loop
(paren
id|rp-&gt;start
)paren
(brace
r_if
c_cond
(paren
id|uc
OL
id|rp-&gt;start
)paren
multiline_comment|/* Before start of range */
r_return
id|uc
suffix:semicolon
multiline_comment|/* Uppercase = input */
r_if
c_cond
(paren
id|uc
op_le
id|rp-&gt;end
)paren
multiline_comment|/* In range */
r_return
id|uc
op_plus
id|rp-&gt;table
(braket
id|uc
op_minus
id|rp-&gt;start
)braket
suffix:semicolon
id|rp
op_increment
suffix:semicolon
multiline_comment|/* Try next range */
)brace
)brace
r_return
id|uc
suffix:semicolon
multiline_comment|/* Past last range */
)brace
multiline_comment|/*&n; * UniStrupr:  Upper case a unicode string&n; */
r_static
r_inline
m_wchar_t
op_star
DECL|function|UniStrupr
id|UniStrupr
c_func
(paren
r_register
m_wchar_t
op_star
id|upin
)paren
(brace
r_register
m_wchar_t
op_star
id|up
suffix:semicolon
id|up
op_assign
id|upin
suffix:semicolon
r_while
c_loop
(paren
op_star
id|up
)paren
(brace
multiline_comment|/* For all characters */
op_star
id|up
op_assign
id|UniToupper
c_func
(paren
op_star
id|up
)paren
suffix:semicolon
id|up
op_increment
suffix:semicolon
)brace
r_return
id|upin
suffix:semicolon
multiline_comment|/* Return input pointer */
)brace
macro_line|#endif&t;&t;&t;&t;/* UNIUPR_NOUPPER */
macro_line|#ifndef UNIUPR_NOLOWER
multiline_comment|/*&n; * UniTolower:  Convert a unicode character to lower case&n; */
r_static
r_inline
m_wchar_t
DECL|function|UniTolower
id|UniTolower
c_func
(paren
m_wchar_t
id|uc
)paren
(brace
r_register
r_struct
id|UniCaseRange
op_star
id|rp
suffix:semicolon
r_if
c_cond
(paren
id|uc
OL
r_sizeof
(paren
id|UniLowerTable
)paren
)paren
(brace
multiline_comment|/* Latin characters */
r_return
id|uc
op_plus
id|UniLowerTable
(braket
id|uc
)braket
suffix:semicolon
multiline_comment|/* Use base tables */
)brace
r_else
(brace
id|rp
op_assign
id|UniLowerRange
suffix:semicolon
multiline_comment|/* Use range tables */
r_while
c_loop
(paren
id|rp-&gt;start
)paren
(brace
r_if
c_cond
(paren
id|uc
OL
id|rp-&gt;start
)paren
multiline_comment|/* Before start of range */
r_return
id|uc
suffix:semicolon
multiline_comment|/* Uppercase = input */
r_if
c_cond
(paren
id|uc
op_le
id|rp-&gt;end
)paren
multiline_comment|/* In range */
r_return
id|uc
op_plus
id|rp-&gt;table
(braket
id|uc
op_minus
id|rp-&gt;start
)braket
suffix:semicolon
id|rp
op_increment
suffix:semicolon
multiline_comment|/* Try next range */
)brace
)brace
r_return
id|uc
suffix:semicolon
multiline_comment|/* Past last range */
)brace
multiline_comment|/*&n; * UniStrlwr:  Lower case a unicode string&n; */
r_static
r_inline
m_wchar_t
op_star
DECL|function|UniStrlwr
id|UniStrlwr
c_func
(paren
r_register
m_wchar_t
op_star
id|upin
)paren
(brace
r_register
m_wchar_t
op_star
id|up
suffix:semicolon
id|up
op_assign
id|upin
suffix:semicolon
r_while
c_loop
(paren
op_star
id|up
)paren
(brace
multiline_comment|/* For all characters */
op_star
id|up
op_assign
id|UniTolower
c_func
(paren
op_star
id|up
)paren
suffix:semicolon
id|up
op_increment
suffix:semicolon
)brace
r_return
id|upin
suffix:semicolon
multiline_comment|/* Return input pointer */
)brace
macro_line|#endif
eof
