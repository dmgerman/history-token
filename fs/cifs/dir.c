multiline_comment|/*&n; *   fs/cifs/dir.c&n; *&n; *   vfs operations that deal with dentries&n; * &n; *   Copyright (c) International Business Machines  Corp., 2002&n; *   Author(s): Steve French (sfrench@us.ibm.com)&n; *&n; *   This library is free software; you can redistribute it and/or modify&n; *   it under the terms of the GNU Lesser General Public License as published&n; *   by the Free Software Foundation; either version 2.1 of the License, or&n; *   (at your option) any later version.&n; *&n; *   This library is distributed in the hope that it will be useful,&n; *   but WITHOUT ANY WARRANTY; without even the implied warranty of&n; *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See&n; *   the GNU Lesser General Public License for more details.&n; *&n; *   You should have received a copy of the GNU Lesser General Public License&n; *   along with this library; if not, write to the Free Software&n; *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA&n; */
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/stat.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &quot;cifsfs.h&quot;
macro_line|#include &quot;cifspdu.h&quot;
macro_line|#include &quot;cifsglob.h&quot;
macro_line|#include &quot;cifsproto.h&quot;
macro_line|#include &quot;cifs_debug.h&quot;
macro_line|#include &quot;cifs_fs_sb.h&quot;
r_void
DECL|function|renew_parental_timestamps
id|renew_parental_timestamps
c_func
(paren
r_struct
id|dentry
op_star
id|direntry
)paren
(brace
multiline_comment|/* BB check if there is a way to get the kernel to do this or if we really need this */
r_do
(brace
id|direntry-&gt;d_time
op_assign
id|jiffies
suffix:semicolon
id|direntry
op_assign
id|direntry-&gt;d_parent
suffix:semicolon
)brace
r_while
c_loop
(paren
op_logical_neg
id|IS_ROOT
c_func
(paren
id|direntry
)paren
)paren
suffix:semicolon
multiline_comment|/* BB for DFS case should stop at the root of share which could be lower than root of this mount due to implicit dfs connections */
)brace
multiline_comment|/* Note: caller must free return buffer */
r_char
op_star
DECL|function|build_path_from_dentry
id|build_path_from_dentry
c_func
(paren
r_struct
id|dentry
op_star
id|direntry
)paren
(brace
r_struct
id|dentry
op_star
id|temp
suffix:semicolon
r_int
id|namelen
op_assign
l_int|0
suffix:semicolon
r_char
op_star
id|full_path
suffix:semicolon
r_for
c_loop
(paren
id|temp
op_assign
id|direntry
suffix:semicolon
op_logical_neg
id|IS_ROOT
c_func
(paren
id|temp
)paren
suffix:semicolon
)paren
(brace
id|namelen
op_add_assign
(paren
l_int|1
op_plus
id|temp-&gt;d_name.len
)paren
suffix:semicolon
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot; len %d &quot;
comma
id|namelen
)paren
)paren
suffix:semicolon
id|temp
op_assign
id|temp-&gt;d_parent
suffix:semicolon
)brace
id|namelen
op_add_assign
l_int|1
suffix:semicolon
multiline_comment|/* allow for trailing null */
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;Final namelength (in build_path): %d &quot;
comma
id|namelen
)paren
)paren
suffix:semicolon
multiline_comment|/* BB remove */
id|full_path
op_assign
id|kmalloc
c_func
(paren
id|namelen
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|namelen
op_decrement
suffix:semicolon
id|full_path
(braket
id|namelen
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* trailing null */
r_for
c_loop
(paren
id|temp
op_assign
id|direntry
suffix:semicolon
op_logical_neg
id|IS_ROOT
c_func
(paren
id|temp
)paren
suffix:semicolon
)paren
(brace
id|namelen
op_sub_assign
l_int|1
op_plus
id|temp-&gt;d_name.len
suffix:semicolon
r_if
c_cond
(paren
id|namelen
OL
l_int|0
)paren
(brace
r_break
suffix:semicolon
)brace
r_else
(brace
id|full_path
(braket
id|namelen
)braket
op_assign
l_char|&squot;&bslash;&bslash;&squot;
suffix:semicolon
id|strncpy
c_func
(paren
id|full_path
op_plus
id|namelen
op_plus
l_int|1
comma
id|temp-&gt;d_name.name
comma
id|temp-&gt;d_name.len
)paren
suffix:semicolon
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot; name: %s &quot;
comma
id|full_path
op_plus
id|namelen
)paren
)paren
suffix:semicolon
multiline_comment|/* BB remove */
)brace
id|temp
op_assign
id|temp-&gt;d_parent
suffix:semicolon
)brace
r_if
c_cond
(paren
id|namelen
op_ne
l_int|0
)paren
id|cERROR
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;&bslash;nWe did not end path lookup where we expected namelen is %d&quot;
comma
id|namelen
)paren
)paren
suffix:semicolon
r_return
id|full_path
suffix:semicolon
)brace
r_char
op_star
DECL|function|build_wildcard_path_from_dentry
id|build_wildcard_path_from_dentry
c_func
(paren
r_struct
id|dentry
op_star
id|direntry
)paren
(brace
r_struct
id|dentry
op_star
id|temp
suffix:semicolon
r_int
id|namelen
op_assign
l_int|0
suffix:semicolon
r_char
op_star
id|full_path
suffix:semicolon
r_for
c_loop
(paren
id|temp
op_assign
id|direntry
suffix:semicolon
op_logical_neg
id|IS_ROOT
c_func
(paren
id|temp
)paren
suffix:semicolon
)paren
(brace
id|namelen
op_add_assign
(paren
l_int|1
op_plus
id|temp-&gt;d_name.len
)paren
suffix:semicolon
id|temp
op_assign
id|temp-&gt;d_parent
suffix:semicolon
)brace
id|namelen
op_add_assign
l_int|3
suffix:semicolon
multiline_comment|/* allow for trailing null and wildcard (slash and *) */
id|full_path
op_assign
id|kmalloc
c_func
(paren
id|namelen
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|namelen
op_decrement
suffix:semicolon
id|full_path
(braket
id|namelen
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* trailing null */
id|namelen
op_decrement
suffix:semicolon
id|full_path
(braket
id|namelen
)braket
op_assign
l_char|&squot;*&squot;
suffix:semicolon
id|namelen
op_decrement
suffix:semicolon
id|full_path
(braket
id|namelen
)braket
op_assign
l_char|&squot;&bslash;&bslash;&squot;
suffix:semicolon
r_for
c_loop
(paren
id|temp
op_assign
id|direntry
suffix:semicolon
op_logical_neg
id|IS_ROOT
c_func
(paren
id|temp
)paren
suffix:semicolon
)paren
(brace
id|namelen
op_sub_assign
l_int|1
op_plus
id|temp-&gt;d_name.len
suffix:semicolon
r_if
c_cond
(paren
id|namelen
OL
l_int|0
)paren
(brace
r_break
suffix:semicolon
)brace
r_else
(brace
id|full_path
(braket
id|namelen
)braket
op_assign
l_char|&squot;&bslash;&bslash;&squot;
suffix:semicolon
id|strncpy
c_func
(paren
id|full_path
op_plus
id|namelen
op_plus
l_int|1
comma
id|temp-&gt;d_name.name
comma
id|temp-&gt;d_name.len
)paren
suffix:semicolon
)brace
id|temp
op_assign
id|temp-&gt;d_parent
suffix:semicolon
)brace
r_if
c_cond
(paren
id|namelen
op_ne
l_int|0
)paren
id|cERROR
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;&bslash;nWe did not end path lookup where we expected namelen is %d&quot;
comma
id|namelen
)paren
)paren
suffix:semicolon
r_return
id|full_path
suffix:semicolon
)brace
multiline_comment|/* Inode operations in similar order to how they appear in the Linux file fs.h */
r_int
DECL|function|cifs_create
id|cifs_create
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|dentry
op_star
id|direntry
comma
r_int
id|mode
)paren
(brace
r_int
id|rc
op_assign
op_minus
id|ENOENT
suffix:semicolon
r_int
id|xid
suffix:semicolon
r_int
id|oplock
op_assign
id|FALSE
suffix:semicolon
multiline_comment|/* no need to oplock when we are not going to read from the file */
id|__u16
id|fileHandle
suffix:semicolon
r_struct
id|cifs_sb_info
op_star
id|cifs_sb
suffix:semicolon
r_struct
id|cifsTconInfo
op_star
id|pTcon
suffix:semicolon
r_char
op_star
id|full_path
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|inode
op_star
id|newinode
op_assign
l_int|NULL
suffix:semicolon
id|xid
op_assign
id|GetXid
c_func
(paren
)paren
suffix:semicolon
id|cifs_sb
op_assign
id|CIFS_SB
c_func
(paren
id|inode-&gt;i_sb
)paren
suffix:semicolon
id|pTcon
op_assign
id|cifs_sb-&gt;tcon
suffix:semicolon
id|full_path
op_assign
id|build_path_from_dentry
c_func
(paren
id|direntry
)paren
suffix:semicolon
multiline_comment|/* BB add processing for setting the equivalent of mode - e.g. via CreateX with ACLs */
id|rc
op_assign
id|CIFSSMBOpen
c_func
(paren
id|xid
comma
id|pTcon
comma
id|full_path
comma
id|FILE_OVERWRITE_IF
comma
id|GENERIC_ALL
multiline_comment|/* 0x20197 was used previously */
comma
id|mode
comma
op_amp
id|fileHandle
comma
op_amp
id|oplock
comma
id|cifs_sb-&gt;local_nls
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
(brace
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;&bslash;ncifs_create returned 0x%x &quot;
comma
id|rc
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|pTcon-&gt;ses-&gt;capabilities
op_amp
id|CAP_UNIX
)paren
id|rc
op_assign
id|cifs_get_inode_info_unix
c_func
(paren
op_amp
id|newinode
comma
id|full_path
comma
id|inode-&gt;i_sb
)paren
suffix:semicolon
r_else
id|rc
op_assign
id|cifs_get_inode_info
c_func
(paren
op_amp
id|newinode
comma
id|full_path
comma
id|inode-&gt;i_sb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_ne
l_int|0
)paren
(brace
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;&bslash;nCreate worked but get_inode_info failed with rc = %d &quot;
comma
id|rc
)paren
)paren
suffix:semicolon
multiline_comment|/* close handle */
)brace
r_else
(brace
id|direntry-&gt;d_op
op_assign
op_amp
id|cifs_dentry_ops
suffix:semicolon
id|d_instantiate
c_func
(paren
id|direntry
comma
id|newinode
)paren
suffix:semicolon
)brace
id|CIFSSMBClose
c_func
(paren
id|xid
comma
id|pTcon
comma
id|fileHandle
)paren
suffix:semicolon
multiline_comment|/* BB In the future chain close with the NTCreateX to narrow window */
r_if
c_cond
(paren
id|newinode
)paren
(brace
id|newinode-&gt;i_mode
op_assign
id|mode
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|full_path
)paren
id|kfree
c_func
(paren
id|full_path
)paren
suffix:semicolon
id|FreeXid
c_func
(paren
id|xid
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
r_struct
id|dentry
op_star
DECL|function|cifs_lookup
id|cifs_lookup
c_func
(paren
r_struct
id|inode
op_star
id|parent_dir_inode
comma
r_struct
id|dentry
op_star
id|direntry
)paren
(brace
r_int
id|rc
comma
id|xid
suffix:semicolon
r_struct
id|cifs_sb_info
op_star
id|cifs_sb
suffix:semicolon
r_struct
id|cifsTconInfo
op_star
id|pTcon
suffix:semicolon
r_struct
id|inode
op_star
id|newInode
op_assign
l_int|NULL
suffix:semicolon
r_char
op_star
id|full_path
op_assign
l_int|NULL
suffix:semicolon
id|xid
op_assign
id|GetXid
c_func
(paren
)paren
suffix:semicolon
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot; parent inode = 0x%p name is: %s and dentry = 0x%p&quot;
comma
id|parent_dir_inode
comma
id|direntry-&gt;d_name.name
comma
id|direntry
)paren
)paren
suffix:semicolon
multiline_comment|/* BB Add check of incoming data - e.g. frame not longer than maximum SMB - let server check the namelen BB */
multiline_comment|/* check whether path exists */
id|cifs_sb
op_assign
id|CIFS_SB
c_func
(paren
id|parent_dir_inode-&gt;i_sb
)paren
suffix:semicolon
id|pTcon
op_assign
id|cifs_sb-&gt;tcon
suffix:semicolon
id|full_path
op_assign
id|build_path_from_dentry
c_func
(paren
id|direntry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|direntry-&gt;d_inode
op_ne
l_int|NULL
)paren
(brace
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot; non-NULL inode in lookup&quot;
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot; NULL inode in lookup&quot;
)paren
)paren
suffix:semicolon
)brace
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot; Full path: %s inode = 0x%p&bslash;n&quot;
comma
id|full_path
comma
id|direntry-&gt;d_inode
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pTcon-&gt;ses-&gt;capabilities
op_amp
id|CAP_UNIX
)paren
id|rc
op_assign
id|cifs_get_inode_info_unix
c_func
(paren
op_amp
id|newInode
comma
id|full_path
comma
id|parent_dir_inode-&gt;i_sb
)paren
suffix:semicolon
r_else
id|rc
op_assign
id|cifs_get_inode_info
c_func
(paren
op_amp
id|newInode
comma
id|full_path
comma
id|parent_dir_inode-&gt;i_sb
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rc
op_eq
l_int|0
)paren
op_logical_and
(paren
id|newInode
op_ne
l_int|NULL
)paren
)paren
(brace
id|direntry-&gt;d_op
op_assign
op_amp
id|cifs_dentry_ops
suffix:semicolon
id|d_add
c_func
(paren
id|direntry
comma
id|newInode
)paren
suffix:semicolon
multiline_comment|/* since paths are not looked up by component - the parent directories are presumed to be good here */
id|renew_parental_timestamps
c_func
(paren
id|direntry
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|rc
op_eq
op_minus
id|ENOENT
)paren
(brace
id|rc
op_assign
l_int|0
suffix:semicolon
id|d_add
c_func
(paren
id|direntry
comma
l_int|NULL
)paren
suffix:semicolon
)brace
r_else
(brace
id|cERROR
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;Error 0x%x or (%d decimal) on cifs_get_inode_info in lookup&bslash;n&quot;
comma
id|rc
comma
id|rc
)paren
)paren
suffix:semicolon
multiline_comment|/* BB special case check for Access Denied - watch security exposure of returning dir info implicitly via different rc if file exists or not but no access BB */
)brace
r_if
c_cond
(paren
id|full_path
)paren
id|kfree
c_func
(paren
id|full_path
)paren
suffix:semicolon
id|FreeXid
c_func
(paren
id|xid
)paren
suffix:semicolon
r_return
id|ERR_PTR
c_func
(paren
id|rc
)paren
suffix:semicolon
)brace
r_int
DECL|function|cifs_dir_open
id|cifs_dir_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
multiline_comment|/* NB: currently unused since searches are opened in readdir */
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
r_int
id|xid
suffix:semicolon
r_struct
id|cifs_sb_info
op_star
id|cifs_sb
suffix:semicolon
r_struct
id|cifsTconInfo
op_star
id|pTcon
suffix:semicolon
r_char
op_star
id|full_path
op_assign
l_int|NULL
suffix:semicolon
id|xid
op_assign
id|GetXid
c_func
(paren
)paren
suffix:semicolon
id|cifs_sb
op_assign
id|CIFS_SB
c_func
(paren
id|inode-&gt;i_sb
)paren
suffix:semicolon
id|pTcon
op_assign
id|cifs_sb-&gt;tcon
suffix:semicolon
id|full_path
op_assign
id|build_wildcard_path_from_dentry
c_func
(paren
id|file-&gt;f_dentry
)paren
suffix:semicolon
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot; inode = 0x%p and full path is %s&bslash;n&quot;
comma
id|inode
comma
id|full_path
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|full_path
)paren
id|kfree
c_func
(paren
id|full_path
)paren
suffix:semicolon
id|FreeXid
c_func
(paren
id|xid
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
r_static
r_int
DECL|function|cifs_d_revalidate
id|cifs_d_revalidate
c_func
(paren
r_struct
id|dentry
op_star
id|direntry
comma
r_int
id|flags
)paren
(brace
r_int
id|isValid
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&t;lock_kernel(); */
multiline_comment|/* surely we do not want to lock the kernel for a whole network round trip which could take seconds */
r_if
c_cond
(paren
id|direntry-&gt;d_inode
)paren
(brace
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;In cifs_d_revalidate, name = %s and inode = 0x%p with count %d with time %ld and dentry 0x%p with time %ld&bslash;n&quot;
comma
id|direntry-&gt;d_name.name
comma
id|direntry-&gt;d_inode
comma
id|direntry-&gt;d_inode-&gt;i_count.counter
comma
id|direntry-&gt;d_inode-&gt;i_atime
comma
id|direntry
comma
id|direntry-&gt;d_time
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cifs_revalidate
c_func
(paren
id|direntry
)paren
)paren
(brace
multiline_comment|/* unlock_kernel(); */
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_else
(brace
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;In cifs_d_revalidate with no inode but name = %s and dentry 0x%p&bslash;n&quot;
comma
id|direntry-&gt;d_name.name
comma
id|direntry
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*    unlock_kernel(); */
r_return
id|isValid
suffix:semicolon
)brace
multiline_comment|/* static int cifs_d_delete(struct dentry *direntry)&n;{&n;&t;int rc = 0;&n;&n;&t;cFYI(1, (&quot;In cifs d_delete, name = %s&bslash;n&quot;, direntry-&gt;d_name.name));&n;&n;&t;return rc;&n;}     */
DECL|variable|cifs_dentry_ops
r_struct
id|dentry_operations
id|cifs_dentry_ops
op_assign
(brace
dot
id|d_revalidate
op_assign
id|cifs_d_revalidate
comma
multiline_comment|/* d_delete:       cifs_d_delete,       */
multiline_comment|/* not needed except for debugging */
multiline_comment|/* no need for d_hash, d_compare, d_release, d_iput ... yet. BB confirm this BB */
)brace
suffix:semicolon
eof
