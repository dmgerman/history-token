multiline_comment|/*&n; *   fs/cifs/file.c&n; *&n; *   vfs operations that deal with files&n; * &n; *   Copyright (C) International Business Machines  Corp., 2002,2003&n; *   Author(s): Steve French (sfrench@us.ibm.com)&n; *&n; *   This library is free software; you can redistribute it and/or modify&n; *   it under the terms of the GNU Lesser General Public License as published&n; *   by the Free Software Foundation; either version 2.1 of the License, or&n; *   (at your option) any later version.&n; *&n; *   This library is distributed in the hope that it will be useful,&n; *   but WITHOUT ANY WARRANTY; without even the implied warranty of&n; *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See&n; *   the GNU Lesser General Public License for more details.&n; *&n; *   You should have received a copy of the GNU Lesser General Public License&n; *   along with this library; if not, write to the Free Software&n; *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA&n; */
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/stat.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/pagemap.h&gt;
macro_line|#include &lt;linux/pagevec.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;asm/div64.h&gt;
macro_line|#include &quot;cifsfs.h&quot;
macro_line|#include &quot;cifspdu.h&quot;
macro_line|#include &quot;cifsglob.h&quot;
macro_line|#include &quot;cifsproto.h&quot;
macro_line|#include &quot;cifs_unicode.h&quot;
macro_line|#include &quot;cifs_debug.h&quot;
macro_line|#include &quot;cifs_fs_sb.h&quot;
r_extern
r_int
id|cifs_readdir2
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_void
op_star
id|direntry
comma
id|filldir_t
id|filldir
)paren
suffix:semicolon
multiline_comment|/* BB removeme BB */
r_int
DECL|function|cifs_open
id|cifs_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_int
id|rc
op_assign
op_minus
id|EACCES
suffix:semicolon
r_int
id|xid
comma
id|oplock
suffix:semicolon
r_struct
id|cifs_sb_info
op_star
id|cifs_sb
suffix:semicolon
r_struct
id|cifsTconInfo
op_star
id|pTcon
suffix:semicolon
r_struct
id|cifsFileInfo
op_star
id|pCifsFile
suffix:semicolon
r_struct
id|cifsInodeInfo
op_star
id|pCifsInode
suffix:semicolon
r_struct
id|list_head
op_star
id|tmp
suffix:semicolon
r_char
op_star
id|full_path
op_assign
l_int|NULL
suffix:semicolon
r_int
id|desiredAccess
op_assign
l_int|0x20197
suffix:semicolon
r_int
id|disposition
suffix:semicolon
id|__u16
id|netfid
suffix:semicolon
id|FILE_ALL_INFO
op_star
id|buf
op_assign
l_int|NULL
suffix:semicolon
id|xid
op_assign
id|GetXid
c_func
(paren
)paren
suffix:semicolon
id|cifs_sb
op_assign
id|CIFS_SB
c_func
(paren
id|inode-&gt;i_sb
)paren
suffix:semicolon
id|pTcon
op_assign
id|cifs_sb-&gt;tcon
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_flags
op_amp
id|O_CREAT
)paren
(brace
multiline_comment|/* search inode for this file and fill in file-&gt;private_data = */
id|pCifsInode
op_assign
id|CIFS_I
c_func
(paren
id|file-&gt;f_dentry-&gt;d_inode
)paren
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|GlobalSMBSeslock
)paren
suffix:semicolon
id|list_for_each
c_func
(paren
id|tmp
comma
op_amp
id|pCifsInode-&gt;openFileList
)paren
(brace
id|pCifsFile
op_assign
id|list_entry
c_func
(paren
id|tmp
comma
r_struct
id|cifsFileInfo
comma
id|flist
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|pCifsFile-&gt;pfile
op_eq
l_int|NULL
)paren
op_logical_and
(paren
id|pCifsFile-&gt;pid
op_assign
id|current-&gt;pid
)paren
)paren
(brace
multiline_comment|/* mode set in cifs_create */
id|pCifsFile-&gt;pfile
op_assign
id|file
suffix:semicolon
multiline_comment|/* needed for writepage */
id|file-&gt;private_data
op_assign
id|pCifsFile
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|read_unlock
c_func
(paren
op_amp
id|GlobalSMBSeslock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;private_data
op_ne
l_int|NULL
)paren
(brace
id|rc
op_assign
l_int|0
suffix:semicolon
id|FreeXid
c_func
(paren
id|xid
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|file-&gt;f_flags
op_amp
id|O_EXCL
)paren
(brace
id|cERROR
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;could not find file instance for new file %p &quot;
comma
id|file
)paren
)paren
suffix:semicolon
)brace
)brace
)brace
id|down
c_func
(paren
op_amp
id|inode-&gt;i_sb-&gt;s_vfs_rename_sem
)paren
suffix:semicolon
id|full_path
op_assign
id|build_path_from_dentry
c_func
(paren
id|file-&gt;f_dentry
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|inode-&gt;i_sb-&gt;s_vfs_rename_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|full_path
op_eq
l_int|NULL
)paren
(brace
id|FreeXid
c_func
(paren
id|xid
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot; inode = 0x%p file flags are 0x%x for %s&quot;
comma
id|inode
comma
id|file-&gt;f_flags
comma
id|full_path
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|file-&gt;f_flags
op_amp
id|O_ACCMODE
)paren
op_eq
id|O_RDONLY
)paren
id|desiredAccess
op_assign
id|GENERIC_READ
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|file-&gt;f_flags
op_amp
id|O_ACCMODE
)paren
op_eq
id|O_WRONLY
)paren
id|desiredAccess
op_assign
id|GENERIC_WRITE
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|file-&gt;f_flags
op_amp
id|O_ACCMODE
)paren
op_eq
id|O_RDWR
)paren
(brace
multiline_comment|/* GENERIC_ALL is too much permission to request */
multiline_comment|/* can cause unnecessary access denied on create */
multiline_comment|/* desiredAccess = GENERIC_ALL; */
id|desiredAccess
op_assign
id|GENERIC_READ
op_or
id|GENERIC_WRITE
suffix:semicolon
)brace
multiline_comment|/*********************************************************************&n; *  open flag mapping table:&n; *  &n; *&t;POSIX Flag            CIFS Disposition&n; *&t;----------            ---------------- &n; *&t;O_CREAT               FILE_OPEN_IF&n; *&t;O_CREAT | O_EXCL      FILE_CREATE&n; *&t;O_CREAT | O_TRUNC     FILE_OVERWRITE_IF&n; *&t;O_TRUNC               FILE_OVERWRITE&n; *&t;none of the above     FILE_OPEN&n; *&n; *&t;Note that there is not a direct match between disposition&n; *&t;FILE_SUPERSEDE (ie create whether or not file exists although &n; *&t;O_CREAT | O_TRUNC is similar but truncates the existing&n; *&t;file rather than creating a new file as FILE_SUPERSEDE does&n; *&t;(which uses the attributes / metadata passed in on open call)&n; *?&n; *?  O_SYNC is a reasonable match to CIFS writethrough flag  &n; *?  and the read write flags match reasonably.  O_LARGEFILE&n; *?  is irrelevant because largefile support is always used&n; *?  by this client. Flags O_APPEND, O_DIRECT, O_DIRECTORY,&n; *&t; O_FASYNC, O_NOFOLLOW, O_NONBLOCK need further investigation&n; *********************************************************************/
r_if
c_cond
(paren
(paren
id|file-&gt;f_flags
op_amp
(paren
id|O_CREAT
op_or
id|O_EXCL
)paren
)paren
op_eq
(paren
id|O_CREAT
op_or
id|O_EXCL
)paren
)paren
(brace
id|disposition
op_assign
id|FILE_CREATE
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|file-&gt;f_flags
op_amp
(paren
id|O_CREAT
op_or
id|O_TRUNC
)paren
)paren
op_eq
(paren
id|O_CREAT
op_or
id|O_TRUNC
)paren
)paren
(brace
id|disposition
op_assign
id|FILE_OVERWRITE_IF
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|file-&gt;f_flags
op_amp
id|O_CREAT
)paren
op_eq
id|O_CREAT
)paren
(brace
id|disposition
op_assign
id|FILE_OPEN_IF
suffix:semicolon
)brace
r_else
id|disposition
op_assign
id|FILE_OPEN
suffix:semicolon
r_if
c_cond
(paren
id|oplockEnabled
)paren
id|oplock
op_assign
id|REQ_OPLOCK
suffix:semicolon
r_else
id|oplock
op_assign
id|FALSE
suffix:semicolon
multiline_comment|/* BB pass O_SYNC flag through on file attributes .. BB */
multiline_comment|/* Also refresh inode by passing in file_info buf returned by SMBOpen &n;&t;   and calling get_inode_info with returned buf (at least &n;&t;   helps non-Unix server case */
multiline_comment|/* BB we can not do this if this is the second open of a file &n;&t;and the first handle has writebehind data, we might be &n;&t;able to simply do a filemap_fdatawrite/filemap_fdatawait first */
id|buf
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|FILE_ALL_INFO
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buf
op_eq
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|full_path
)paren
id|kfree
c_func
(paren
id|full_path
)paren
suffix:semicolon
id|FreeXid
c_func
(paren
id|xid
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|rc
op_assign
id|CIFSSMBOpen
c_func
(paren
id|xid
comma
id|pTcon
comma
id|full_path
comma
id|disposition
comma
id|desiredAccess
comma
id|CREATE_NOT_DIR
comma
op_amp
id|netfid
comma
op_amp
id|oplock
comma
id|buf
comma
id|cifs_sb-&gt;local_nls
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
(brace
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;cifs_open returned 0x%x &quot;
comma
id|rc
)paren
)paren
suffix:semicolon
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;oplock: %d &quot;
comma
id|oplock
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|file-&gt;private_data
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|cifsFileInfo
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;private_data
)paren
(brace
id|memset
c_func
(paren
id|file-&gt;private_data
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|cifsFileInfo
)paren
)paren
suffix:semicolon
id|pCifsFile
op_assign
(paren
r_struct
id|cifsFileInfo
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
id|pCifsFile-&gt;netfid
op_assign
id|netfid
suffix:semicolon
id|pCifsFile-&gt;pid
op_assign
id|current-&gt;pid
suffix:semicolon
id|init_MUTEX
c_func
(paren
op_amp
id|pCifsFile-&gt;fh_sem
)paren
suffix:semicolon
id|pCifsFile-&gt;pfile
op_assign
id|file
suffix:semicolon
multiline_comment|/* needed for writepage */
id|pCifsFile-&gt;pInode
op_assign
id|inode
suffix:semicolon
id|pCifsFile-&gt;invalidHandle
op_assign
id|FALSE
suffix:semicolon
id|pCifsFile-&gt;closePend
op_assign
id|FALSE
suffix:semicolon
id|write_lock
c_func
(paren
op_amp
id|file-&gt;f_owner.lock
)paren
suffix:semicolon
id|write_lock
c_func
(paren
op_amp
id|GlobalSMBSeslock
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|pCifsFile-&gt;tlist
comma
op_amp
id|pTcon-&gt;openFileList
)paren
suffix:semicolon
id|pCifsInode
op_assign
id|CIFS_I
c_func
(paren
id|file-&gt;f_dentry-&gt;d_inode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pCifsInode
)paren
(brace
multiline_comment|/* want handles we can use to read with first */
multiline_comment|/* in the list so we do not have to walk the */
multiline_comment|/* list to search for one in prepare_write */
r_if
c_cond
(paren
(paren
id|file-&gt;f_flags
op_amp
id|O_ACCMODE
)paren
op_eq
id|O_WRONLY
)paren
(brace
id|list_add_tail
c_func
(paren
op_amp
id|pCifsFile-&gt;flist
comma
op_amp
id|pCifsInode-&gt;openFileList
)paren
suffix:semicolon
)brace
r_else
(brace
id|list_add
c_func
(paren
op_amp
id|pCifsFile-&gt;flist
comma
op_amp
id|pCifsInode-&gt;openFileList
)paren
suffix:semicolon
)brace
id|write_unlock
c_func
(paren
op_amp
id|GlobalSMBSeslock
)paren
suffix:semicolon
id|write_unlock
c_func
(paren
op_amp
id|file-&gt;f_owner.lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pCifsInode-&gt;clientCanCacheRead
)paren
(brace
multiline_comment|/* we have the inode open somewhere else&n;&t;&t;&t;&t;&t;   no need to discard cache data */
)brace
r_else
(brace
r_if
c_cond
(paren
id|buf
)paren
(brace
multiline_comment|/* BB need same check in cifs_create too? */
multiline_comment|/* if not oplocked, invalidate inode pages if mtime &n;&t;&t;&t;&t;&t;   or file size changed */
r_struct
id|timespec
id|temp
suffix:semicolon
id|temp
op_assign
id|cifs_NTtimeToUnix
c_func
(paren
id|le64_to_cpu
c_func
(paren
id|buf-&gt;LastWriteTime
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|timespec_equal
c_func
(paren
op_amp
id|file-&gt;f_dentry-&gt;d_inode-&gt;i_mtime
comma
op_amp
id|temp
)paren
op_logical_and
(paren
id|file-&gt;f_dentry-&gt;d_inode-&gt;i_size
op_eq
(paren
id|loff_t
)paren
id|le64_to_cpu
c_func
(paren
id|buf-&gt;EndOfFile
)paren
)paren
)paren
(brace
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;inode unchanged on server&quot;
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|file-&gt;f_dentry-&gt;d_inode-&gt;i_mapping
)paren
(brace
multiline_comment|/* BB no need to lock inode until after invalidate*/
multiline_comment|/* since namei code should already have it locked?*/
id|filemap_fdatawrite
c_func
(paren
id|file-&gt;f_dentry-&gt;d_inode-&gt;i_mapping
)paren
suffix:semicolon
id|filemap_fdatawait
c_func
(paren
id|file-&gt;f_dentry-&gt;d_inode-&gt;i_mapping
)paren
suffix:semicolon
)brace
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;invalidating remote inode since open detected it changed&quot;
)paren
)paren
suffix:semicolon
id|invalidate_remote_inode
c_func
(paren
id|file-&gt;f_dentry-&gt;d_inode
)paren
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|pTcon-&gt;ses-&gt;capabilities
op_amp
id|CAP_UNIX
)paren
id|rc
op_assign
id|cifs_get_inode_info_unix
c_func
(paren
op_amp
id|file-&gt;f_dentry-&gt;d_inode
comma
id|full_path
comma
id|inode-&gt;i_sb
comma
id|xid
)paren
suffix:semicolon
r_else
id|rc
op_assign
id|cifs_get_inode_info
c_func
(paren
op_amp
id|file-&gt;f_dentry-&gt;d_inode
comma
id|full_path
comma
id|buf
comma
id|inode-&gt;i_sb
comma
id|xid
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|oplock
op_amp
l_int|0xF
)paren
op_eq
id|OPLOCK_EXCLUSIVE
)paren
(brace
id|pCifsInode-&gt;clientCanCacheAll
op_assign
id|TRUE
suffix:semicolon
id|pCifsInode-&gt;clientCanCacheRead
op_assign
id|TRUE
suffix:semicolon
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;Exclusive Oplock granted on inode %p&quot;
comma
id|file-&gt;f_dentry-&gt;d_inode
)paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|oplock
op_amp
l_int|0xF
)paren
op_eq
id|OPLOCK_READ
)paren
(brace
id|pCifsInode-&gt;clientCanCacheRead
op_assign
id|TRUE
suffix:semicolon
)brace
)brace
r_else
(brace
id|write_unlock
c_func
(paren
op_amp
id|GlobalSMBSeslock
)paren
suffix:semicolon
id|write_unlock
c_func
(paren
op_amp
id|file-&gt;f_owner.lock
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|oplock
op_amp
id|CIFS_CREATE_ACTION
)paren
(brace
multiline_comment|/* time to set mode which we can not set earlier due&n;&t;&t;&t;&t; to problems creating new read-only files */
r_if
c_cond
(paren
id|cifs_sb-&gt;tcon-&gt;ses-&gt;capabilities
op_amp
id|CAP_UNIX
)paren
id|CIFSSMBUnixSetPerms
c_func
(paren
id|xid
comma
id|pTcon
comma
id|full_path
comma
id|inode-&gt;i_mode
comma
(paren
id|__u64
)paren
op_minus
l_int|1
comma
(paren
id|__u64
)paren
op_minus
l_int|1
comma
l_int|0
multiline_comment|/* dev */
comma
id|cifs_sb-&gt;local_nls
)paren
suffix:semicolon
r_else
(brace
multiline_comment|/* BB implement via Windows security descriptors */
multiline_comment|/* eg CIFSSMBWinSetPerms(xid,pTcon,full_path,mode,-1,-1,local_nls);*/
multiline_comment|/* in the meantime could set r/o dos attribute when perms are eg:&n;&t;&t;&t;&t;&t;mode &amp; 0222 == 0 */
)brace
)brace
)brace
)brace
r_if
c_cond
(paren
id|buf
)paren
id|kfree
c_func
(paren
id|buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|full_path
)paren
id|kfree
c_func
(paren
id|full_path
)paren
suffix:semicolon
id|FreeXid
c_func
(paren
id|xid
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/* Try to reaquire byte range locks that were released when session */
multiline_comment|/* to server was lost */
DECL|function|cifs_relock_file
r_static
r_int
id|cifs_relock_file
c_func
(paren
r_struct
id|cifsFileInfo
op_star
id|cifsFile
)paren
(brace
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* BB list all locks open on this file and relock */
r_return
id|rc
suffix:semicolon
)brace
DECL|function|cifs_reopen_file
r_static
r_int
id|cifs_reopen_file
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
id|can_flush
)paren
(brace
r_int
id|rc
op_assign
op_minus
id|EACCES
suffix:semicolon
r_int
id|xid
comma
id|oplock
suffix:semicolon
r_struct
id|cifs_sb_info
op_star
id|cifs_sb
suffix:semicolon
r_struct
id|cifsTconInfo
op_star
id|pTcon
suffix:semicolon
r_struct
id|cifsFileInfo
op_star
id|pCifsFile
suffix:semicolon
r_struct
id|cifsInodeInfo
op_star
id|pCifsInode
suffix:semicolon
r_char
op_star
id|full_path
op_assign
l_int|NULL
suffix:semicolon
r_int
id|desiredAccess
op_assign
l_int|0x20197
suffix:semicolon
r_int
id|disposition
op_assign
id|FILE_OPEN
suffix:semicolon
id|__u16
id|netfid
suffix:semicolon
r_if
c_cond
(paren
id|inode
op_eq
l_int|NULL
)paren
(brace
r_return
op_minus
id|EBADF
suffix:semicolon
)brace
r_if
c_cond
(paren
id|file-&gt;private_data
)paren
(brace
id|pCifsFile
op_assign
(paren
r_struct
id|cifsFileInfo
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
)brace
r_else
r_return
op_minus
id|EBADF
suffix:semicolon
id|xid
op_assign
id|GetXid
c_func
(paren
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|pCifsFile-&gt;fh_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pCifsFile-&gt;invalidHandle
op_eq
id|FALSE
)paren
(brace
id|up
c_func
(paren
op_amp
id|pCifsFile-&gt;fh_sem
)paren
suffix:semicolon
id|FreeXid
c_func
(paren
id|xid
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|file-&gt;f_dentry
op_eq
l_int|NULL
)paren
(brace
id|up
c_func
(paren
op_amp
id|pCifsFile-&gt;fh_sem
)paren
suffix:semicolon
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;failed file reopen, no valid name if dentry freed&quot;
)paren
)paren
suffix:semicolon
id|FreeXid
c_func
(paren
id|xid
)paren
suffix:semicolon
r_return
op_minus
id|EBADF
suffix:semicolon
)brace
id|cifs_sb
op_assign
id|CIFS_SB
c_func
(paren
id|inode-&gt;i_sb
)paren
suffix:semicolon
id|pTcon
op_assign
id|cifs_sb-&gt;tcon
suffix:semicolon
multiline_comment|/* can not grab rename sem here because various ops, including&n;those that already have the rename sem can end up causing writepage&n;to get called and if the server was down that means we end up here,&n;and we can never tell if the caller already has the rename_sem */
id|full_path
op_assign
id|build_path_from_dentry
c_func
(paren
id|file-&gt;f_dentry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|full_path
op_eq
l_int|NULL
)paren
(brace
id|up
c_func
(paren
op_amp
id|pCifsFile-&gt;fh_sem
)paren
suffix:semicolon
id|FreeXid
c_func
(paren
id|xid
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot; inode = 0x%p file flags are 0x%x for %s&quot;
comma
id|inode
comma
id|file-&gt;f_flags
comma
id|full_path
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|file-&gt;f_flags
op_amp
id|O_ACCMODE
)paren
op_eq
id|O_RDONLY
)paren
id|desiredAccess
op_assign
id|GENERIC_READ
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|file-&gt;f_flags
op_amp
id|O_ACCMODE
)paren
op_eq
id|O_WRONLY
)paren
id|desiredAccess
op_assign
id|GENERIC_WRITE
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|file-&gt;f_flags
op_amp
id|O_ACCMODE
)paren
op_eq
id|O_RDWR
)paren
(brace
multiline_comment|/* GENERIC_ALL is too much permission to request */
multiline_comment|/* can cause unnecessary access denied on create */
multiline_comment|/* desiredAccess = GENERIC_ALL; */
id|desiredAccess
op_assign
id|GENERIC_READ
op_or
id|GENERIC_WRITE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|oplockEnabled
)paren
id|oplock
op_assign
id|REQ_OPLOCK
suffix:semicolon
r_else
id|oplock
op_assign
id|FALSE
suffix:semicolon
multiline_comment|/* Can not refresh inode by passing in file_info buf to be returned&n;&t; by SMBOpen and then calling get_inode_info with returned buf &n;&t; since file might have write behind data that needs to be flushed &n;&t; and server version of file size can be stale. If we &n;&t; knew for sure that inode was not dirty locally we could do this */
multiline_comment|/*&t;buf = kmalloc(sizeof(FILE_ALL_INFO),GFP_KERNEL);&n;&t;if(buf==0) {&n;&t;&t;up(&amp;pCifsFile-&gt;fh_sem);&n;&t;&t;if (full_path)&n;&t;&t;&t;kfree(full_path);&n;&t;&t;FreeXid(xid);&n;&t;&t;return -ENOMEM;&n;&t;}*/
id|rc
op_assign
id|CIFSSMBOpen
c_func
(paren
id|xid
comma
id|pTcon
comma
id|full_path
comma
id|disposition
comma
id|desiredAccess
comma
id|CREATE_NOT_DIR
comma
op_amp
id|netfid
comma
op_amp
id|oplock
comma
l_int|NULL
comma
id|cifs_sb-&gt;local_nls
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
(brace
id|up
c_func
(paren
op_amp
id|pCifsFile-&gt;fh_sem
)paren
suffix:semicolon
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;cifs_open returned 0x%x &quot;
comma
id|rc
)paren
)paren
suffix:semicolon
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;oplock: %d &quot;
comma
id|oplock
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|pCifsFile-&gt;netfid
op_assign
id|netfid
suffix:semicolon
id|pCifsFile-&gt;invalidHandle
op_assign
id|FALSE
suffix:semicolon
id|up
c_func
(paren
op_amp
id|pCifsFile-&gt;fh_sem
)paren
suffix:semicolon
id|pCifsInode
op_assign
id|CIFS_I
c_func
(paren
id|inode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pCifsInode
)paren
(brace
r_if
c_cond
(paren
id|can_flush
)paren
(brace
id|filemap_fdatawrite
c_func
(paren
id|inode-&gt;i_mapping
)paren
suffix:semicolon
id|filemap_fdatawait
c_func
(paren
id|inode-&gt;i_mapping
)paren
suffix:semicolon
multiline_comment|/* temporarily disable caching while we&n;&t;&t;&t;go to server to get inode info */
id|pCifsInode-&gt;clientCanCacheAll
op_assign
id|FALSE
suffix:semicolon
id|pCifsInode-&gt;clientCanCacheRead
op_assign
id|FALSE
suffix:semicolon
r_if
c_cond
(paren
id|pTcon-&gt;ses-&gt;capabilities
op_amp
id|CAP_UNIX
)paren
id|rc
op_assign
id|cifs_get_inode_info_unix
c_func
(paren
op_amp
id|inode
comma
id|full_path
comma
id|inode-&gt;i_sb
comma
id|xid
)paren
suffix:semicolon
r_else
id|rc
op_assign
id|cifs_get_inode_info
c_func
(paren
op_amp
id|inode
comma
id|full_path
comma
l_int|NULL
comma
id|inode-&gt;i_sb
comma
id|xid
)paren
suffix:semicolon
)brace
multiline_comment|/* else we are writing out data to server already&n;&t;&t;&t;and could deadlock if we tried to flush data, and &n;&t;&t;&t;since we do not know if we have data that would&n;&t;&t;&t;invalidate the current end of file on the server&n;&t;&t;&t;we can not go to the server to get the new&n;&t;&t;&t;inod info */
r_if
c_cond
(paren
(paren
id|oplock
op_amp
l_int|0xF
)paren
op_eq
id|OPLOCK_EXCLUSIVE
)paren
(brace
id|pCifsInode-&gt;clientCanCacheAll
op_assign
id|TRUE
suffix:semicolon
id|pCifsInode-&gt;clientCanCacheRead
op_assign
id|TRUE
suffix:semicolon
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;Exclusive Oplock granted on inode %p&quot;
comma
id|file-&gt;f_dentry-&gt;d_inode
)paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|oplock
op_amp
l_int|0xF
)paren
op_eq
id|OPLOCK_READ
)paren
(brace
id|pCifsInode-&gt;clientCanCacheRead
op_assign
id|TRUE
suffix:semicolon
id|pCifsInode-&gt;clientCanCacheAll
op_assign
id|FALSE
suffix:semicolon
)brace
r_else
(brace
id|pCifsInode-&gt;clientCanCacheRead
op_assign
id|FALSE
suffix:semicolon
id|pCifsInode-&gt;clientCanCacheAll
op_assign
id|FALSE
suffix:semicolon
)brace
id|cifs_relock_file
c_func
(paren
id|pCifsFile
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|full_path
)paren
id|kfree
c_func
(paren
id|full_path
)paren
suffix:semicolon
id|FreeXid
c_func
(paren
id|xid
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
r_int
DECL|function|cifs_close
id|cifs_close
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
r_int
id|xid
suffix:semicolon
r_struct
id|cifs_sb_info
op_star
id|cifs_sb
suffix:semicolon
r_struct
id|cifsTconInfo
op_star
id|pTcon
suffix:semicolon
r_struct
id|cifsFileInfo
op_star
id|pSMBFile
op_assign
(paren
r_struct
id|cifsFileInfo
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
id|xid
op_assign
id|GetXid
c_func
(paren
)paren
suffix:semicolon
id|cifs_sb
op_assign
id|CIFS_SB
c_func
(paren
id|inode-&gt;i_sb
)paren
suffix:semicolon
id|pTcon
op_assign
id|cifs_sb-&gt;tcon
suffix:semicolon
r_if
c_cond
(paren
id|pSMBFile
)paren
(brace
id|pSMBFile-&gt;closePend
op_assign
id|TRUE
suffix:semicolon
id|write_lock
c_func
(paren
op_amp
id|file-&gt;f_owner.lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pTcon
)paren
(brace
multiline_comment|/* no sense reconnecting to close a file that is&n;&t;&t;&t;&t;already closed */
r_if
c_cond
(paren
id|pTcon-&gt;tidStatus
op_ne
id|CifsNeedReconnect
)paren
(brace
id|write_unlock
c_func
(paren
op_amp
id|file-&gt;f_owner.lock
)paren
suffix:semicolon
id|rc
op_assign
id|CIFSSMBClose
c_func
(paren
id|xid
comma
id|pTcon
comma
id|pSMBFile-&gt;netfid
)paren
suffix:semicolon
id|write_lock
c_func
(paren
op_amp
id|file-&gt;f_owner.lock
)paren
suffix:semicolon
)brace
)brace
id|list_del
c_func
(paren
op_amp
id|pSMBFile-&gt;flist
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|pSMBFile-&gt;tlist
)paren
suffix:semicolon
id|write_unlock
c_func
(paren
op_amp
id|file-&gt;f_owner.lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pSMBFile-&gt;search_resume_name
)paren
(brace
id|kfree
c_func
(paren
id|pSMBFile-&gt;search_resume_name
)paren
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|file-&gt;private_data
)paren
suffix:semicolon
id|file-&gt;private_data
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
id|rc
op_assign
op_minus
id|EBADF
suffix:semicolon
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
(paren
id|CIFS_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|openFileList
)paren
)paren
)paren
(brace
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;closing last open instance for inode %p&quot;
comma
id|inode
)paren
)paren
suffix:semicolon
multiline_comment|/* if the file is not open we do not know if we can cache&n;&t;&t;info on this inode, much less write behind and read ahead */
id|CIFS_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|clientCanCacheRead
op_assign
id|FALSE
suffix:semicolon
id|CIFS_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|clientCanCacheAll
op_assign
id|FALSE
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|rc
op_eq
l_int|0
)paren
op_logical_and
id|CIFS_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|write_behind_rc
)paren
(brace
id|rc
op_assign
id|CIFS_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|write_behind_rc
suffix:semicolon
)brace
id|FreeXid
c_func
(paren
id|xid
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
r_int
DECL|function|cifs_closedir
id|cifs_closedir
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
r_int
id|xid
suffix:semicolon
r_struct
id|cifsFileInfo
op_star
id|pCFileStruct
op_assign
(paren
r_struct
id|cifsFileInfo
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
r_char
op_star
id|ptmp
suffix:semicolon
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;Closedir inode = 0x%p with &quot;
comma
id|inode
)paren
)paren
suffix:semicolon
id|xid
op_assign
id|GetXid
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pCFileStruct
)paren
(brace
r_struct
id|cifsTconInfo
op_star
id|pTcon
suffix:semicolon
r_struct
id|cifs_sb_info
op_star
id|cifs_sb
op_assign
id|CIFS_SB
c_func
(paren
id|file-&gt;f_dentry-&gt;d_sb
)paren
suffix:semicolon
id|pTcon
op_assign
id|cifs_sb-&gt;tcon
suffix:semicolon
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;Freeing private data in close dir&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pCFileStruct-&gt;srch_inf.endOfSearch
op_eq
id|FALSE
)paren
(brace
id|pCFileStruct-&gt;invalidHandle
op_assign
id|TRUE
suffix:semicolon
id|rc
op_assign
id|CIFSFindClose
c_func
(paren
id|xid
comma
id|pTcon
comma
id|pCFileStruct-&gt;netfid
)paren
suffix:semicolon
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;Closing uncompleted readdir with rc %d&quot;
comma
id|rc
)paren
)paren
suffix:semicolon
multiline_comment|/* not much we can do if it fails anywway, ignore rc */
id|rc
op_assign
l_int|0
suffix:semicolon
)brace
id|ptmp
op_assign
id|pCFileStruct-&gt;srch_inf.ntwrk_buf_start
suffix:semicolon
r_if
c_cond
(paren
id|ptmp
)paren
(brace
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;freeing smb buf in srch struct in closedir&quot;
)paren
)paren
suffix:semicolon
multiline_comment|/* BB removeme BB */
id|pCFileStruct-&gt;srch_inf.ntwrk_buf_start
op_assign
l_int|NULL
suffix:semicolon
id|cifs_buf_release
c_func
(paren
id|ptmp
)paren
suffix:semicolon
)brace
id|ptmp
op_assign
id|pCFileStruct-&gt;search_resume_name
suffix:semicolon
r_if
c_cond
(paren
id|ptmp
)paren
(brace
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;freeing resume name in closedir&quot;
)paren
)paren
suffix:semicolon
multiline_comment|/* BB removeme BB */
id|pCFileStruct-&gt;search_resume_name
op_assign
l_int|NULL
suffix:semicolon
id|kfree
c_func
(paren
id|ptmp
)paren
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|file-&gt;private_data
)paren
suffix:semicolon
id|file-&gt;private_data
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* BB can we lock the filestruct while this is going on? */
id|FreeXid
c_func
(paren
id|xid
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
r_int
DECL|function|cifs_lock
id|cifs_lock
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_int
id|cmd
comma
r_struct
id|file_lock
op_star
id|pfLock
)paren
(brace
r_int
id|rc
comma
id|xid
suffix:semicolon
id|__u32
id|lockType
op_assign
id|LOCKING_ANDX_LARGE_FILES
suffix:semicolon
id|__u32
id|numLock
op_assign
l_int|0
suffix:semicolon
id|__u32
id|numUnlock
op_assign
l_int|0
suffix:semicolon
id|__u64
id|length
suffix:semicolon
r_int
id|wait_flag
op_assign
id|FALSE
suffix:semicolon
r_struct
id|cifs_sb_info
op_star
id|cifs_sb
suffix:semicolon
r_struct
id|cifsTconInfo
op_star
id|pTcon
suffix:semicolon
id|length
op_assign
l_int|1
op_plus
id|pfLock-&gt;fl_end
op_minus
id|pfLock-&gt;fl_start
suffix:semicolon
id|rc
op_assign
op_minus
id|EACCES
suffix:semicolon
id|xid
op_assign
id|GetXid
c_func
(paren
)paren
suffix:semicolon
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;Lock parm: 0x%x flockflags: 0x%x flocktype: 0x%x start: %lld end: %lld&quot;
comma
id|cmd
comma
id|pfLock-&gt;fl_flags
comma
id|pfLock-&gt;fl_type
comma
id|pfLock-&gt;fl_start
comma
id|pfLock-&gt;fl_end
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pfLock-&gt;fl_flags
op_amp
id|FL_POSIX
)paren
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;Posix &quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pfLock-&gt;fl_flags
op_amp
id|FL_FLOCK
)paren
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;Flock &quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pfLock-&gt;fl_flags
op_amp
id|FL_SLEEP
)paren
(brace
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;Blocking lock &quot;
)paren
)paren
suffix:semicolon
id|wait_flag
op_assign
id|TRUE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pfLock-&gt;fl_flags
op_amp
id|FL_ACCESS
)paren
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;Process suspended by mandatory locking - not implemented yet &quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pfLock-&gt;fl_flags
op_amp
id|FL_LEASE
)paren
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;Lease on file - not implemented yet&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pfLock-&gt;fl_flags
op_amp
(paren
op_complement
(paren
id|FL_POSIX
op_or
id|FL_FLOCK
op_or
id|FL_SLEEP
op_or
id|FL_ACCESS
op_or
id|FL_LEASE
)paren
)paren
)paren
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;Unknown lock flags 0x%x&quot;
comma
id|pfLock-&gt;fl_flags
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pfLock-&gt;fl_type
op_eq
id|F_WRLCK
)paren
(brace
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;F_WRLCK &quot;
)paren
)paren
suffix:semicolon
id|numLock
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|pfLock-&gt;fl_type
op_eq
id|F_UNLCK
)paren
(brace
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;F_UNLCK &quot;
)paren
)paren
suffix:semicolon
id|numUnlock
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|pfLock-&gt;fl_type
op_eq
id|F_RDLCK
)paren
(brace
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;F_RDLCK &quot;
)paren
)paren
suffix:semicolon
id|lockType
op_or_assign
id|LOCKING_ANDX_SHARED_LOCK
suffix:semicolon
id|numLock
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|pfLock-&gt;fl_type
op_eq
id|F_EXLCK
)paren
(brace
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;F_EXLCK &quot;
)paren
)paren
suffix:semicolon
id|numLock
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|pfLock-&gt;fl_type
op_eq
id|F_SHLCK
)paren
(brace
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;F_SHLCK &quot;
)paren
)paren
suffix:semicolon
id|lockType
op_or_assign
id|LOCKING_ANDX_SHARED_LOCK
suffix:semicolon
id|numLock
op_assign
l_int|1
suffix:semicolon
)brace
r_else
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;Unknown type of lock &quot;
)paren
)paren
suffix:semicolon
id|cifs_sb
op_assign
id|CIFS_SB
c_func
(paren
id|file-&gt;f_dentry-&gt;d_sb
)paren
suffix:semicolon
id|pTcon
op_assign
id|cifs_sb-&gt;tcon
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;private_data
op_eq
l_int|NULL
)paren
(brace
id|FreeXid
c_func
(paren
id|xid
)paren
suffix:semicolon
r_return
op_minus
id|EBADF
suffix:semicolon
)brace
r_if
c_cond
(paren
id|IS_GETLK
c_func
(paren
id|cmd
)paren
)paren
(brace
id|rc
op_assign
id|CIFSSMBLock
c_func
(paren
id|xid
comma
id|pTcon
comma
(paren
(paren
r_struct
id|cifsFileInfo
op_star
)paren
id|file
op_member_access_from_pointer
id|private_data
)paren
op_member_access_from_pointer
id|netfid
comma
id|length
comma
id|pfLock-&gt;fl_start
comma
l_int|0
comma
l_int|1
comma
id|lockType
comma
l_int|0
multiline_comment|/* wait flag */
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_eq
l_int|0
)paren
(brace
id|rc
op_assign
id|CIFSSMBLock
c_func
(paren
id|xid
comma
id|pTcon
comma
(paren
(paren
r_struct
id|cifsFileInfo
op_star
)paren
id|file
op_member_access_from_pointer
id|private_data
)paren
op_member_access_from_pointer
id|netfid
comma
id|length
comma
id|pfLock-&gt;fl_start
comma
l_int|1
multiline_comment|/* numUnlock */
comma
l_int|0
multiline_comment|/* numLock */
comma
id|lockType
comma
l_int|0
multiline_comment|/* wait flag */
)paren
suffix:semicolon
id|pfLock-&gt;fl_type
op_assign
id|F_UNLCK
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_ne
l_int|0
)paren
id|cERROR
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;Error unlocking previously locked range %d during test of lock &quot;
comma
id|rc
)paren
)paren
suffix:semicolon
id|rc
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* if rc == ERR_SHARING_VIOLATION ? */
id|rc
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* do not change lock type to unlock since range in use */
)brace
id|FreeXid
c_func
(paren
id|xid
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
id|rc
op_assign
id|CIFSSMBLock
c_func
(paren
id|xid
comma
id|pTcon
comma
(paren
(paren
r_struct
id|cifsFileInfo
op_star
)paren
id|file-&gt;private_data
)paren
op_member_access_from_pointer
id|netfid
comma
id|length
comma
id|pfLock-&gt;fl_start
comma
id|numUnlock
comma
id|numLock
comma
id|lockType
comma
id|wait_flag
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_eq
l_int|0
op_logical_and
(paren
id|pfLock-&gt;fl_flags
op_amp
id|FL_POSIX
)paren
)paren
id|posix_lock_file
c_func
(paren
id|file
comma
id|pfLock
)paren
suffix:semicolon
id|FreeXid
c_func
(paren
id|xid
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
id|ssize_t
DECL|function|cifs_write
id|cifs_write
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_const
r_char
op_star
id|write_data
comma
r_int
id|write_size
comma
id|loff_t
op_star
id|poffset
)paren
(brace
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|bytes_written
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|total_written
suffix:semicolon
r_struct
id|cifs_sb_info
op_star
id|cifs_sb
suffix:semicolon
r_struct
id|cifsTconInfo
op_star
id|pTcon
suffix:semicolon
r_int
id|xid
comma
id|long_op
suffix:semicolon
r_struct
id|cifsFileInfo
op_star
id|open_file
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_dentry
op_eq
l_int|NULL
)paren
(brace
r_return
op_minus
id|EBADF
suffix:semicolon
)brace
id|cifs_sb
op_assign
id|CIFS_SB
c_func
(paren
id|file-&gt;f_dentry-&gt;d_sb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cifs_sb
op_eq
l_int|NULL
)paren
(brace
r_return
op_minus
id|EBADF
suffix:semicolon
)brace
id|pTcon
op_assign
id|cifs_sb-&gt;tcon
suffix:semicolon
multiline_comment|/*cFYI(1,&n;&t;   (&quot; write %d bytes to offset %lld of %s&quot;, write_size,&n;&t;   *poffset, file-&gt;f_dentry-&gt;d_name.name)); */
r_if
c_cond
(paren
id|file-&gt;private_data
op_eq
l_int|NULL
)paren
(brace
r_return
op_minus
id|EBADF
suffix:semicolon
)brace
r_else
(brace
id|open_file
op_assign
(paren
r_struct
id|cifsFileInfo
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
)brace
id|xid
op_assign
id|GetXid
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_dentry-&gt;d_inode
op_eq
l_int|NULL
)paren
(brace
id|FreeXid
c_func
(paren
id|xid
)paren
suffix:semicolon
r_return
op_minus
id|EBADF
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|poffset
OG
id|file-&gt;f_dentry-&gt;d_inode-&gt;i_size
)paren
id|long_op
op_assign
l_int|2
suffix:semicolon
multiline_comment|/* writes past end of file can take a long time */
r_else
id|long_op
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|total_written
op_assign
l_int|0
suffix:semicolon
id|write_size
OG
id|total_written
suffix:semicolon
id|total_written
op_add_assign
id|bytes_written
)paren
(brace
id|rc
op_assign
op_minus
id|EAGAIN
suffix:semicolon
r_while
c_loop
(paren
id|rc
op_eq
op_minus
id|EAGAIN
)paren
(brace
r_if
c_cond
(paren
id|file-&gt;private_data
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* file has been closed on us */
id|FreeXid
c_func
(paren
id|xid
)paren
suffix:semicolon
multiline_comment|/* if we have gotten here we have written some data&n;&t;&t;&t;and blocked, and the file has been freed on us&n;&t;&t;&t;while we blocked so return what we managed to write */
r_return
id|total_written
suffix:semicolon
)brace
r_if
c_cond
(paren
id|open_file-&gt;closePend
)paren
(brace
id|FreeXid
c_func
(paren
id|xid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|total_written
)paren
(brace
r_return
id|total_written
suffix:semicolon
)brace
r_else
r_return
op_minus
id|EBADF
suffix:semicolon
)brace
r_if
c_cond
(paren
id|open_file-&gt;invalidHandle
)paren
(brace
r_if
c_cond
(paren
(paren
id|file-&gt;f_dentry
op_eq
l_int|NULL
)paren
op_logical_or
(paren
id|file-&gt;f_dentry-&gt;d_inode
op_eq
l_int|NULL
)paren
)paren
(brace
id|FreeXid
c_func
(paren
id|xid
)paren
suffix:semicolon
r_return
id|total_written
suffix:semicolon
)brace
multiline_comment|/* we could deadlock if we called&n;&t;&t;&t;&t; filemap_fdatawait from here so tell&n;&t;&t;&t;&t;reopen_file not to flush data to server now */
id|rc
op_assign
id|cifs_reopen_file
c_func
(paren
id|file-&gt;f_dentry-&gt;d_inode
comma
id|file
comma
id|FALSE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_ne
l_int|0
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
id|rc
op_assign
id|CIFSSMBWrite
c_func
(paren
id|xid
comma
id|pTcon
comma
id|open_file-&gt;netfid
comma
id|write_size
op_minus
id|total_written
comma
op_star
id|poffset
comma
op_amp
id|bytes_written
comma
id|write_data
op_plus
id|total_written
comma
id|long_op
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rc
op_logical_or
(paren
id|bytes_written
op_eq
l_int|0
)paren
)paren
(brace
r_if
c_cond
(paren
id|total_written
)paren
r_break
suffix:semicolon
r_else
(brace
id|FreeXid
c_func
(paren
id|xid
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
)brace
r_else
op_star
id|poffset
op_add_assign
id|bytes_written
suffix:semicolon
id|long_op
op_assign
id|FALSE
suffix:semicolon
multiline_comment|/* subsequent writes fast - 15 seconds is plenty */
)brace
macro_line|#ifdef CONFIG_CIFS_STATS
r_if
c_cond
(paren
id|total_written
OG
l_int|0
)paren
(brace
id|atomic_inc
c_func
(paren
op_amp
id|pTcon-&gt;num_writes
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|pTcon-&gt;stat_lock
)paren
suffix:semicolon
id|pTcon-&gt;bytes_written
op_add_assign
id|total_written
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|pTcon-&gt;stat_lock
)paren
suffix:semicolon
)brace
macro_line|#endif&t;&t;
multiline_comment|/* since the write may have blocked check these pointers again */
r_if
c_cond
(paren
id|file-&gt;f_dentry
)paren
(brace
r_if
c_cond
(paren
id|file-&gt;f_dentry-&gt;d_inode
)paren
(brace
id|file-&gt;f_dentry-&gt;d_inode-&gt;i_ctime
op_assign
id|file-&gt;f_dentry-&gt;d_inode-&gt;i_mtime
op_assign
id|CURRENT_TIME
suffix:semicolon
r_if
c_cond
(paren
id|total_written
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
op_star
id|poffset
OG
id|file-&gt;f_dentry-&gt;d_inode-&gt;i_size
)paren
id|i_size_write
c_func
(paren
id|file-&gt;f_dentry-&gt;d_inode
comma
op_star
id|poffset
)paren
suffix:semicolon
)brace
id|mark_inode_dirty_sync
c_func
(paren
id|file-&gt;f_dentry-&gt;d_inode
)paren
suffix:semicolon
)brace
)brace
id|FreeXid
c_func
(paren
id|xid
)paren
suffix:semicolon
r_return
id|total_written
suffix:semicolon
)brace
r_static
r_int
DECL|function|cifs_partialpagewrite
id|cifs_partialpagewrite
c_func
(paren
r_struct
id|page
op_star
id|page
comma
r_int
id|from
comma
r_int
id|to
)paren
(brace
r_struct
id|address_space
op_star
id|mapping
op_assign
id|page-&gt;mapping
suffix:semicolon
id|loff_t
id|offset
op_assign
(paren
id|loff_t
)paren
id|page-&gt;index
op_lshift
id|PAGE_CACHE_SHIFT
suffix:semicolon
r_char
op_star
id|write_data
suffix:semicolon
r_int
id|rc
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_int
id|bytes_written
op_assign
l_int|0
suffix:semicolon
r_struct
id|cifs_sb_info
op_star
id|cifs_sb
suffix:semicolon
r_struct
id|cifsTconInfo
op_star
id|pTcon
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_struct
id|cifsInodeInfo
op_star
id|cifsInode
suffix:semicolon
r_struct
id|cifsFileInfo
op_star
id|open_file
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|list_head
op_star
id|tmp
suffix:semicolon
r_struct
id|list_head
op_star
id|tmp1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mapping
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|mapping-&gt;host
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
id|inode
op_assign
id|page-&gt;mapping-&gt;host
suffix:semicolon
id|cifs_sb
op_assign
id|CIFS_SB
c_func
(paren
id|inode-&gt;i_sb
)paren
suffix:semicolon
id|pTcon
op_assign
id|cifs_sb-&gt;tcon
suffix:semicolon
id|offset
op_add_assign
(paren
id|loff_t
)paren
id|from
suffix:semicolon
id|write_data
op_assign
id|kmap
c_func
(paren
id|page
)paren
suffix:semicolon
id|write_data
op_add_assign
id|from
suffix:semicolon
r_if
c_cond
(paren
(paren
id|to
OG
id|PAGE_CACHE_SIZE
)paren
op_logical_or
(paren
id|from
OG
id|to
)paren
)paren
(brace
id|kunmap
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/* racing with truncate? */
r_if
c_cond
(paren
id|offset
OG
id|mapping-&gt;host-&gt;i_size
)paren
(brace
id|kunmap
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/* don&squot;t care */
)brace
multiline_comment|/* check to make sure that we are not extending the file */
r_if
c_cond
(paren
id|mapping-&gt;host-&gt;i_size
op_minus
id|offset
OL
(paren
id|loff_t
)paren
id|to
)paren
(brace
id|to
op_assign
(paren
r_int
)paren
(paren
id|mapping-&gt;host-&gt;i_size
op_minus
id|offset
)paren
suffix:semicolon
)brace
id|cifsInode
op_assign
id|CIFS_I
c_func
(paren
id|mapping-&gt;host
)paren
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|GlobalSMBSeslock
)paren
suffix:semicolon
multiline_comment|/* BB we should start at the end */
id|list_for_each_safe
c_func
(paren
id|tmp
comma
id|tmp1
comma
op_amp
id|cifsInode-&gt;openFileList
)paren
(brace
id|open_file
op_assign
id|list_entry
c_func
(paren
id|tmp
comma
r_struct
id|cifsFileInfo
comma
id|flist
)paren
suffix:semicolon
r_if
c_cond
(paren
id|open_file-&gt;closePend
)paren
(brace
r_continue
suffix:semicolon
)brace
multiline_comment|/* We check if file is open for writing first */
r_if
c_cond
(paren
(paren
id|open_file-&gt;pfile
)paren
op_logical_and
(paren
(paren
id|open_file-&gt;pfile-&gt;f_flags
op_amp
id|O_RDWR
)paren
op_logical_or
(paren
id|open_file-&gt;pfile-&gt;f_flags
op_amp
id|O_WRONLY
)paren
)paren
)paren
(brace
id|read_unlock
c_func
(paren
op_amp
id|GlobalSMBSeslock
)paren
suffix:semicolon
id|bytes_written
op_assign
id|cifs_write
c_func
(paren
id|open_file-&gt;pfile
comma
id|write_data
comma
id|to
op_minus
id|from
comma
op_amp
id|offset
)paren
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|GlobalSMBSeslock
)paren
suffix:semicolon
multiline_comment|/* Does mm or vfs already set times? */
id|inode-&gt;i_atime
op_assign
id|inode-&gt;i_mtime
op_assign
id|CURRENT_TIME
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bytes_written
OG
l_int|0
)paren
op_logical_and
(paren
id|offset
)paren
)paren
(brace
id|rc
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|bytes_written
OL
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|rc
op_eq
op_minus
id|EBADF
)paren
(brace
multiline_comment|/* have seen a case in which&n;&t;&t;&t;&t;kernel seemed to have closed/freed a file&n;&t;&t;&t;&t;even with writes active so we might as well&n;&t;&t;&t;&t;see if there are other file structs to try&n;&t;&t;&t;&t;for the same inode before giving up */
r_continue
suffix:semicolon
)brace
r_else
id|rc
op_assign
id|bytes_written
suffix:semicolon
)brace
r_break
suffix:semicolon
multiline_comment|/* now that we found a valid file handle&n;&t;&t;&t;&t;and tried to write to it we are done, no&n;&t;&t;&t;&t;sense continuing to loop looking for another */
)brace
r_if
c_cond
(paren
id|tmp-&gt;next
op_eq
l_int|NULL
)paren
(brace
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;File instance %p removed&quot;
comma
id|tmp
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|read_unlock
c_func
(paren
op_amp
id|GlobalSMBSeslock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|open_file
op_eq
l_int|NULL
)paren
(brace
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;No writeable filehandles for inode&quot;
)paren
)paren
suffix:semicolon
id|rc
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
id|kunmap
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
macro_line|#if 0
r_static
r_int
id|cifs_writepages
c_func
(paren
r_struct
id|address_space
op_star
id|mapping
comma
r_struct
id|writeback_control
op_star
id|wbc
)paren
(brace
r_int
id|rc
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_int
id|xid
suffix:semicolon
id|xid
op_assign
id|GetXid
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* call 16K write then Setpageuptodate */
id|FreeXid
c_func
(paren
id|xid
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
macro_line|#endif
r_static
r_int
DECL|function|cifs_writepage
id|cifs_writepage
c_func
(paren
r_struct
id|page
op_star
id|page
comma
r_struct
id|writeback_control
op_star
id|wbc
)paren
(brace
r_int
id|rc
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_int
id|xid
suffix:semicolon
id|xid
op_assign
id|GetXid
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* BB add check for wbc flags */
id|page_cache_get
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|PageUptodate
c_func
(paren
id|page
)paren
)paren
(brace
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;ppw - page not up to date&quot;
)paren
)paren
suffix:semicolon
)brace
id|rc
op_assign
id|cifs_partialpagewrite
c_func
(paren
id|page
comma
l_int|0
comma
id|PAGE_CACHE_SIZE
)paren
suffix:semicolon
id|SetPageUptodate
c_func
(paren
id|page
)paren
suffix:semicolon
multiline_comment|/* BB add check for error and Clearuptodate? */
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
id|FreeXid
c_func
(paren
id|xid
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
r_static
r_int
DECL|function|cifs_commit_write
id|cifs_commit_write
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_struct
id|page
op_star
id|page
comma
r_int
id|offset
comma
r_int
id|to
)paren
(brace
r_int
id|xid
suffix:semicolon
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
r_struct
id|inode
op_star
id|inode
op_assign
id|page-&gt;mapping-&gt;host
suffix:semicolon
id|loff_t
id|position
op_assign
(paren
(paren
id|loff_t
)paren
id|page-&gt;index
op_lshift
id|PAGE_CACHE_SHIFT
)paren
op_plus
id|to
suffix:semicolon
r_char
op_star
id|page_data
suffix:semicolon
id|xid
op_assign
id|GetXid
c_func
(paren
)paren
suffix:semicolon
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;commit write for page %p up to position %lld for %d&quot;
comma
id|page
comma
id|position
comma
id|to
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|position
OG
id|inode-&gt;i_size
)paren
(brace
id|i_size_write
c_func
(paren
id|inode
comma
id|position
)paren
suffix:semicolon
multiline_comment|/*if (file-&gt;private_data == NULL) {&n;&t;&t;&t;rc = -EBADF;&n;&t;&t;} else {&n;&t;&t;&t;open_file = (struct cifsFileInfo *)file-&gt;private_data;&n;&t;&t;&t;cifs_sb = CIFS_SB(inode-&gt;i_sb);&n;&t;&t;&t;rc = -EAGAIN;&n;&t;&t;&t;while(rc == -EAGAIN) {&n;&t;&t;&t;&t;if((open_file-&gt;invalidHandle) &amp;&amp; &n;&t;&t;&t;&t;  (!open_file-&gt;closePend)) {&n;&t;&t;&t;&t;&t;rc = cifs_reopen_file(file-&gt;f_dentry-&gt;d_inode,file);&n;&t;&t;&t;&t;&t;if(rc != 0)&n;&t;&t;&t;&t;&t;&t;break;&n;&t;&t;&t;&t;}&n;&t;&t;&t;&t;if(!open_file-&gt;closePend) {&n;&t;&t;&t;&t;&t;rc = CIFSSMBSetFileSize(xid, cifs_sb-&gt;tcon, &n;&t;&t;&t;&t;&t;&t;position, open_file-&gt;netfid,&n;&t;&t;&t;&t;&t;&t;open_file-&gt;pid,FALSE);&n;&t;&t;&t;&t;} else {&n;&t;&t;&t;&t;&t;rc = -EBADF;&n;&t;&t;&t;&t;&t;break;&n;&t;&t;&t;&t;}&n;&t;&t;&t;}&n;&t;&t;&t;cFYI(1,(&quot; SetEOF (commit write) rc = %d&quot;,rc));&n;&t;&t;}*/
)brace
r_if
c_cond
(paren
op_logical_neg
id|PageUptodate
c_func
(paren
id|page
)paren
)paren
(brace
id|position
op_assign
(paren
(paren
id|loff_t
)paren
id|page-&gt;index
op_lshift
id|PAGE_CACHE_SHIFT
)paren
op_plus
id|offset
suffix:semicolon
multiline_comment|/* can not rely on (or let) writepage write this data */
r_if
c_cond
(paren
id|to
OL
id|offset
)paren
(brace
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;Illegal offsets, can not copy from %d to %d&quot;
comma
id|offset
comma
id|to
)paren
)paren
suffix:semicolon
id|FreeXid
c_func
(paren
id|xid
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/* this is probably better than directly calling &n;&t;&t;partialpage_write since in this function&n;&t;&t;the file handle is known which we might as well&n;&t;&t;leverage */
multiline_comment|/* BB check if anything else missing out of ppw */
multiline_comment|/* such as updating last write time */
id|page_data
op_assign
id|kmap
c_func
(paren
id|page
)paren
suffix:semicolon
id|rc
op_assign
id|cifs_write
c_func
(paren
id|file
comma
id|page_data
op_plus
id|offset
comma
id|to
op_minus
id|offset
comma
op_amp
id|position
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
OG
l_int|0
)paren
(brace
id|rc
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* else if rc &lt; 0 should we set writebehind rc? */
id|kunmap
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
r_else
(brace
id|set_page_dirty
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
id|FreeXid
c_func
(paren
id|xid
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
r_int
DECL|function|cifs_fsync
id|cifs_fsync
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_struct
id|dentry
op_star
id|dentry
comma
r_int
id|datasync
)paren
(brace
r_int
id|xid
suffix:semicolon
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
r_struct
id|inode
op_star
id|inode
op_assign
id|file-&gt;f_dentry-&gt;d_inode
suffix:semicolon
id|xid
op_assign
id|GetXid
c_func
(paren
)paren
suffix:semicolon
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;Sync file - name: %s datasync: 0x%x &quot;
comma
id|dentry-&gt;d_name.name
comma
id|datasync
)paren
)paren
suffix:semicolon
id|rc
op_assign
id|filemap_fdatawrite
c_func
(paren
id|inode-&gt;i_mapping
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_eq
l_int|0
)paren
(brace
id|CIFS_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|write_behind_rc
op_assign
l_int|0
suffix:semicolon
)brace
id|FreeXid
c_func
(paren
id|xid
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/* static int&n;cifs_sync_page(struct page *page)&n;{&n;&t;struct address_space *mapping;&n;&t;struct inode *inode;&n;&t;unsigned long index = page-&gt;index;&n;&t;unsigned int rpages = 0;&n;&t;int rc = 0;&n;&n;&t;cFYI(1,(&quot;sync page %p&quot;,page));&n;&t;mapping = page-&gt;mapping;&n;&t;if (!mapping)&n;&t;&t;return 0;&n;&t;inode = mapping-&gt;host;&n;&t;if (!inode)&n;&t;&t;return 0;*/
multiline_comment|/*&t;fill in rpages then &n;    result = cifs_pagein_inode(inode, index, rpages); */
multiline_comment|/* BB finish */
multiline_comment|/*   cFYI(1, (&quot;rpages is %d for sync page of Index %ld &quot;, rpages, index));&n;&n;&t;if (rc &lt; 0)&n;&t;&t;return rc;&n;&t;return 0;&n;} */
multiline_comment|/*&n; * As file closes, flush all cached write data for this inode checking&n; * for write behind errors.&n; *&n; */
DECL|function|cifs_flush
r_int
id|cifs_flush
c_func
(paren
r_struct
id|file
op_star
id|file
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|file-&gt;f_dentry-&gt;d_inode
suffix:semicolon
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Rather than do the steps manually: */
multiline_comment|/* lock the inode for writing */
multiline_comment|/* loop through pages looking for write behind data (dirty pages) */
multiline_comment|/* coalesce into contiguous 16K (or smaller) chunks to write to server */
multiline_comment|/* send to server (prefer in parallel) */
multiline_comment|/* deal with writebehind errors */
multiline_comment|/* unlock inode for writing */
multiline_comment|/* filemapfdatawrite appears easier for the time being */
id|rc
op_assign
id|filemap_fdatawrite
c_func
(paren
id|inode-&gt;i_mapping
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_eq
l_int|0
)paren
(brace
multiline_comment|/* reset wb rc if we were able to write out dirty pages */
id|CIFS_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|write_behind_rc
op_assign
l_int|0
suffix:semicolon
)brace
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;Flush inode %p file %p rc %d&quot;
comma
id|inode
comma
id|file
comma
id|rc
)paren
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
id|ssize_t
DECL|function|cifs_user_read
id|cifs_user_read
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_char
id|__user
op_star
id|read_data
comma
r_int
id|read_size
comma
id|loff_t
op_star
id|poffset
)paren
(brace
r_int
id|rc
op_assign
op_minus
id|EACCES
suffix:semicolon
r_int
r_int
id|bytes_read
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|total_read
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|current_read_size
suffix:semicolon
r_struct
id|cifs_sb_info
op_star
id|cifs_sb
suffix:semicolon
r_struct
id|cifsTconInfo
op_star
id|pTcon
suffix:semicolon
r_int
id|xid
suffix:semicolon
r_struct
id|cifsFileInfo
op_star
id|open_file
suffix:semicolon
r_char
op_star
id|smb_read_data
suffix:semicolon
r_char
id|__user
op_star
id|current_offset
suffix:semicolon
r_struct
id|smb_com_read_rsp
op_star
id|pSMBr
suffix:semicolon
id|xid
op_assign
id|GetXid
c_func
(paren
)paren
suffix:semicolon
id|cifs_sb
op_assign
id|CIFS_SB
c_func
(paren
id|file-&gt;f_dentry-&gt;d_sb
)paren
suffix:semicolon
id|pTcon
op_assign
id|cifs_sb-&gt;tcon
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;private_data
op_eq
l_int|NULL
)paren
(brace
id|FreeXid
c_func
(paren
id|xid
)paren
suffix:semicolon
r_return
op_minus
id|EBADF
suffix:semicolon
)brace
id|open_file
op_assign
(paren
r_struct
id|cifsFileInfo
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
r_if
c_cond
(paren
(paren
id|file-&gt;f_flags
op_amp
id|O_ACCMODE
)paren
op_eq
id|O_WRONLY
)paren
(brace
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;attempting read on write only file instance&quot;
)paren
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|total_read
op_assign
l_int|0
comma
id|current_offset
op_assign
id|read_data
suffix:semicolon
id|read_size
OG
id|total_read
suffix:semicolon
id|total_read
op_add_assign
id|bytes_read
comma
id|current_offset
op_add_assign
id|bytes_read
)paren
(brace
id|current_read_size
op_assign
id|min_t
c_func
(paren
r_const
r_int
comma
id|read_size
op_minus
id|total_read
comma
id|cifs_sb-&gt;rsize
)paren
suffix:semicolon
id|rc
op_assign
op_minus
id|EAGAIN
suffix:semicolon
id|smb_read_data
op_assign
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
id|rc
op_eq
op_minus
id|EAGAIN
)paren
(brace
r_if
c_cond
(paren
(paren
id|open_file-&gt;invalidHandle
)paren
op_logical_and
(paren
op_logical_neg
id|open_file-&gt;closePend
)paren
)paren
(brace
id|rc
op_assign
id|cifs_reopen_file
c_func
(paren
id|file-&gt;f_dentry-&gt;d_inode
comma
id|file
comma
id|TRUE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_ne
l_int|0
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
id|rc
op_assign
id|CIFSSMBRead
c_func
(paren
id|xid
comma
id|pTcon
comma
id|open_file-&gt;netfid
comma
id|current_read_size
comma
op_star
id|poffset
comma
op_amp
id|bytes_read
comma
op_amp
id|smb_read_data
)paren
suffix:semicolon
id|pSMBr
op_assign
(paren
r_struct
id|smb_com_read_rsp
op_star
)paren
id|smb_read_data
suffix:semicolon
id|copy_to_user
c_func
(paren
id|current_offset
comma
id|smb_read_data
op_plus
l_int|4
multiline_comment|/* RFC1001 hdr*/
op_plus
id|le16_to_cpu
c_func
(paren
id|pSMBr-&gt;DataOffset
)paren
comma
id|bytes_read
)paren
suffix:semicolon
r_if
c_cond
(paren
id|smb_read_data
)paren
(brace
id|cifs_buf_release
c_func
(paren
id|smb_read_data
)paren
suffix:semicolon
id|smb_read_data
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|rc
op_logical_or
(paren
id|bytes_read
op_eq
l_int|0
)paren
)paren
(brace
r_if
c_cond
(paren
id|total_read
)paren
(brace
r_break
suffix:semicolon
)brace
r_else
(brace
id|FreeXid
c_func
(paren
id|xid
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
)brace
r_else
(brace
macro_line|#ifdef CONFIG_CIFS_STATS
id|atomic_inc
c_func
(paren
op_amp
id|pTcon-&gt;num_reads
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|pTcon-&gt;stat_lock
)paren
suffix:semicolon
id|pTcon-&gt;bytes_read
op_add_assign
id|total_read
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|pTcon-&gt;stat_lock
)paren
suffix:semicolon
macro_line|#endif
op_star
id|poffset
op_add_assign
id|bytes_read
suffix:semicolon
)brace
)brace
id|FreeXid
c_func
(paren
id|xid
)paren
suffix:semicolon
r_return
id|total_read
suffix:semicolon
)brace
id|ssize_t
DECL|function|cifs_read
id|cifs_read
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_char
op_star
id|read_data
comma
r_int
id|read_size
comma
id|loff_t
op_star
id|poffset
)paren
(brace
r_int
id|rc
op_assign
op_minus
id|EACCES
suffix:semicolon
r_int
r_int
id|bytes_read
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|total_read
suffix:semicolon
r_int
r_int
id|current_read_size
suffix:semicolon
r_struct
id|cifs_sb_info
op_star
id|cifs_sb
suffix:semicolon
r_struct
id|cifsTconInfo
op_star
id|pTcon
suffix:semicolon
r_int
id|xid
suffix:semicolon
r_char
op_star
id|current_offset
suffix:semicolon
r_struct
id|cifsFileInfo
op_star
id|open_file
suffix:semicolon
id|xid
op_assign
id|GetXid
c_func
(paren
)paren
suffix:semicolon
id|cifs_sb
op_assign
id|CIFS_SB
c_func
(paren
id|file-&gt;f_dentry-&gt;d_sb
)paren
suffix:semicolon
id|pTcon
op_assign
id|cifs_sb-&gt;tcon
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;private_data
op_eq
l_int|NULL
)paren
(brace
id|FreeXid
c_func
(paren
id|xid
)paren
suffix:semicolon
r_return
op_minus
id|EBADF
suffix:semicolon
)brace
id|open_file
op_assign
(paren
r_struct
id|cifsFileInfo
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
r_if
c_cond
(paren
(paren
id|file-&gt;f_flags
op_amp
id|O_ACCMODE
)paren
op_eq
id|O_WRONLY
)paren
(brace
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;attempting read on write only file instance&quot;
)paren
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|total_read
op_assign
l_int|0
comma
id|current_offset
op_assign
id|read_data
suffix:semicolon
id|read_size
OG
id|total_read
suffix:semicolon
id|total_read
op_add_assign
id|bytes_read
comma
id|current_offset
op_add_assign
id|bytes_read
)paren
(brace
id|current_read_size
op_assign
id|min_t
c_func
(paren
r_const
r_int
comma
id|read_size
op_minus
id|total_read
comma
id|cifs_sb-&gt;rsize
)paren
suffix:semicolon
id|rc
op_assign
op_minus
id|EAGAIN
suffix:semicolon
r_while
c_loop
(paren
id|rc
op_eq
op_minus
id|EAGAIN
)paren
(brace
r_if
c_cond
(paren
(paren
id|open_file-&gt;invalidHandle
)paren
op_logical_and
(paren
op_logical_neg
id|open_file-&gt;closePend
)paren
)paren
(brace
id|rc
op_assign
id|cifs_reopen_file
c_func
(paren
id|file-&gt;f_dentry-&gt;d_inode
comma
id|file
comma
id|TRUE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_ne
l_int|0
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
id|rc
op_assign
id|CIFSSMBRead
c_func
(paren
id|xid
comma
id|pTcon
comma
id|open_file-&gt;netfid
comma
id|current_read_size
comma
op_star
id|poffset
comma
op_amp
id|bytes_read
comma
op_amp
id|current_offset
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rc
op_logical_or
(paren
id|bytes_read
op_eq
l_int|0
)paren
)paren
(brace
r_if
c_cond
(paren
id|total_read
)paren
(brace
r_break
suffix:semicolon
)brace
r_else
(brace
id|FreeXid
c_func
(paren
id|xid
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
)brace
r_else
(brace
macro_line|#ifdef CONFIG_CIFS_STATS
id|atomic_inc
c_func
(paren
op_amp
id|pTcon-&gt;num_reads
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|pTcon-&gt;stat_lock
)paren
suffix:semicolon
id|pTcon-&gt;bytes_read
op_add_assign
id|total_read
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|pTcon-&gt;stat_lock
)paren
suffix:semicolon
macro_line|#endif
op_star
id|poffset
op_add_assign
id|bytes_read
suffix:semicolon
)brace
)brace
id|FreeXid
c_func
(paren
id|xid
)paren
suffix:semicolon
r_return
id|total_read
suffix:semicolon
)brace
DECL|function|cifs_file_mmap
r_int
id|cifs_file_mmap
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_struct
id|vm_area_struct
op_star
id|vma
)paren
(brace
r_struct
id|dentry
op_star
id|dentry
op_assign
id|file-&gt;f_dentry
suffix:semicolon
r_int
id|rc
comma
id|xid
suffix:semicolon
macro_line|#ifdef CIFS_EXPERIMENTAL   /* BB fixme reenable when cifs_read_wrapper fixed */
r_if
c_cond
(paren
id|dentry-&gt;d_sb
)paren
(brace
r_struct
id|cifs_sb_info
op_star
id|cifs_sb
suffix:semicolon
id|cifs_sb
op_assign
id|CIFS_SB
c_func
(paren
id|sb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cifs_sb
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|cifs_sb-&gt;mnt_cifs_flags
op_amp
id|CIFS_MOUNT_DIRECT_IO
)paren
r_return
op_minus
id|ENODEV
)brace
)brace
macro_line|#endif /* CIFS_EXPERIMENTAL */
id|xid
op_assign
id|GetXid
c_func
(paren
)paren
suffix:semicolon
id|rc
op_assign
id|cifs_revalidate
c_func
(paren
id|dentry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
(brace
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;Validation prior to mmap failed, error=%d&quot;
comma
id|rc
)paren
)paren
suffix:semicolon
id|FreeXid
c_func
(paren
id|xid
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
id|rc
op_assign
id|generic_file_mmap
c_func
(paren
id|file
comma
id|vma
)paren
suffix:semicolon
id|FreeXid
c_func
(paren
id|xid
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
DECL|function|cifs_copy_cache_pages
r_static
r_void
id|cifs_copy_cache_pages
c_func
(paren
r_struct
id|address_space
op_star
id|mapping
comma
r_struct
id|list_head
op_star
id|pages
comma
r_int
id|bytes_read
comma
r_char
op_star
id|data
comma
r_struct
id|pagevec
op_star
id|plru_pvec
)paren
(brace
r_struct
id|page
op_star
id|page
suffix:semicolon
r_char
op_star
id|target
suffix:semicolon
r_while
c_loop
(paren
id|bytes_read
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|list_empty
c_func
(paren
id|pages
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
id|page
op_assign
id|list_entry
c_func
(paren
id|pages-&gt;prev
comma
r_struct
id|page
comma
id|lru
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|page-&gt;lru
)paren
suffix:semicolon
r_if
c_cond
(paren
id|add_to_page_cache
c_func
(paren
id|page
comma
id|mapping
comma
id|page-&gt;index
comma
id|GFP_KERNEL
)paren
)paren
(brace
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;Add page cache failed&quot;
)paren
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|target
op_assign
id|kmap_atomic
c_func
(paren
id|page
comma
id|KM_USER0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PAGE_CACHE_SIZE
OG
id|bytes_read
)paren
(brace
id|memcpy
c_func
(paren
id|target
comma
id|data
comma
id|bytes_read
)paren
suffix:semicolon
multiline_comment|/* zero the tail end of this partial page */
id|memset
c_func
(paren
id|target
op_plus
id|bytes_read
comma
l_int|0
comma
id|PAGE_CACHE_SIZE
op_minus
id|bytes_read
)paren
suffix:semicolon
id|bytes_read
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|memcpy
c_func
(paren
id|target
comma
id|data
comma
id|PAGE_CACHE_SIZE
)paren
suffix:semicolon
id|bytes_read
op_sub_assign
id|PAGE_CACHE_SIZE
suffix:semicolon
)brace
id|kunmap_atomic
c_func
(paren
id|target
comma
id|KM_USER0
)paren
suffix:semicolon
id|flush_dcache_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|SetPageUptodate
c_func
(paren
id|page
)paren
suffix:semicolon
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pagevec_add
c_func
(paren
id|plru_pvec
comma
id|page
)paren
)paren
id|__pagevec_lru_add
c_func
(paren
id|plru_pvec
)paren
suffix:semicolon
id|data
op_add_assign
id|PAGE_CACHE_SIZE
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
r_static
r_int
DECL|function|cifs_readpages
id|cifs_readpages
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_struct
id|address_space
op_star
id|mapping
comma
r_struct
id|list_head
op_star
id|page_list
comma
r_int
id|num_pages
)paren
(brace
r_int
id|rc
op_assign
op_minus
id|EACCES
suffix:semicolon
r_int
id|xid
suffix:semicolon
id|loff_t
id|offset
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
r_struct
id|cifs_sb_info
op_star
id|cifs_sb
suffix:semicolon
r_struct
id|cifsTconInfo
op_star
id|pTcon
suffix:semicolon
r_int
id|bytes_read
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|read_size
comma
id|i
suffix:semicolon
r_char
op_star
id|smb_read_data
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|smb_com_read_rsp
op_star
id|pSMBr
suffix:semicolon
r_struct
id|pagevec
id|lru_pvec
suffix:semicolon
r_struct
id|cifsFileInfo
op_star
id|open_file
suffix:semicolon
id|xid
op_assign
id|GetXid
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;private_data
op_eq
l_int|NULL
)paren
(brace
id|FreeXid
c_func
(paren
id|xid
)paren
suffix:semicolon
r_return
op_minus
id|EBADF
suffix:semicolon
)brace
id|open_file
op_assign
(paren
r_struct
id|cifsFileInfo
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
id|cifs_sb
op_assign
id|CIFS_SB
c_func
(paren
id|file-&gt;f_dentry-&gt;d_sb
)paren
suffix:semicolon
id|pTcon
op_assign
id|cifs_sb-&gt;tcon
suffix:semicolon
id|pagevec_init
c_func
(paren
op_amp
id|lru_pvec
comma
l_int|0
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num_pages
suffix:semicolon
)paren
(brace
r_int
id|contig_pages
suffix:semicolon
r_struct
id|page
op_star
id|tmp_page
suffix:semicolon
r_int
r_int
id|expected_index
suffix:semicolon
r_if
c_cond
(paren
id|list_empty
c_func
(paren
id|page_list
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
id|page
op_assign
id|list_entry
c_func
(paren
id|page_list-&gt;prev
comma
r_struct
id|page
comma
id|lru
)paren
suffix:semicolon
id|offset
op_assign
(paren
id|loff_t
)paren
id|page-&gt;index
op_lshift
id|PAGE_CACHE_SHIFT
suffix:semicolon
multiline_comment|/* count adjacent pages that we will read into */
id|contig_pages
op_assign
l_int|0
suffix:semicolon
id|expected_index
op_assign
id|list_entry
c_func
(paren
id|page_list-&gt;prev
comma
r_struct
id|page
comma
id|lru
)paren
op_member_access_from_pointer
id|index
suffix:semicolon
id|list_for_each_entry_reverse
c_func
(paren
id|tmp_page
comma
id|page_list
comma
id|lru
)paren
(brace
r_if
c_cond
(paren
id|tmp_page-&gt;index
op_eq
id|expected_index
)paren
(brace
id|contig_pages
op_increment
suffix:semicolon
id|expected_index
op_increment
suffix:semicolon
)brace
r_else
(brace
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|contig_pages
op_plus
id|i
OG
id|num_pages
)paren
(brace
id|contig_pages
op_assign
id|num_pages
op_minus
id|i
suffix:semicolon
)brace
multiline_comment|/* for reads over a certain size could initiate async read ahead */
id|read_size
op_assign
id|contig_pages
op_star
id|PAGE_CACHE_SIZE
suffix:semicolon
multiline_comment|/* Read size needs to be in multiples of one page */
id|read_size
op_assign
id|min_t
c_func
(paren
r_const
r_int
r_int
comma
id|read_size
comma
id|cifs_sb-&gt;rsize
op_amp
id|PAGE_CACHE_MASK
)paren
suffix:semicolon
id|rc
op_assign
op_minus
id|EAGAIN
suffix:semicolon
r_while
c_loop
(paren
id|rc
op_eq
op_minus
id|EAGAIN
)paren
(brace
r_if
c_cond
(paren
(paren
id|open_file-&gt;invalidHandle
)paren
op_logical_and
(paren
op_logical_neg
id|open_file-&gt;closePend
)paren
)paren
(brace
id|rc
op_assign
id|cifs_reopen_file
c_func
(paren
id|file-&gt;f_dentry-&gt;d_inode
comma
id|file
comma
id|TRUE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_ne
l_int|0
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
id|rc
op_assign
id|CIFSSMBRead
c_func
(paren
id|xid
comma
id|pTcon
comma
id|open_file-&gt;netfid
comma
id|read_size
comma
id|offset
comma
op_amp
id|bytes_read
comma
op_amp
id|smb_read_data
)paren
suffix:semicolon
multiline_comment|/* BB need to check return code here */
r_if
c_cond
(paren
id|rc
op_eq
op_minus
id|EAGAIN
)paren
(brace
r_if
c_cond
(paren
id|smb_read_data
)paren
(brace
id|cifs_buf_release
c_func
(paren
id|smb_read_data
)paren
suffix:semicolon
id|smb_read_data
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
(paren
id|rc
OL
l_int|0
)paren
op_logical_or
(paren
id|smb_read_data
op_eq
l_int|NULL
)paren
)paren
(brace
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;Read error in readpages: %d&quot;
comma
id|rc
)paren
)paren
suffix:semicolon
multiline_comment|/* clean up remaing pages off list */
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
id|page_list
)paren
op_logical_and
(paren
id|i
OL
id|num_pages
)paren
)paren
(brace
id|page
op_assign
id|list_entry
c_func
(paren
id|page_list-&gt;prev
comma
r_struct
id|page
comma
id|lru
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|page-&gt;lru
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|bytes_read
OG
l_int|0
)paren
(brace
id|pSMBr
op_assign
(paren
r_struct
id|smb_com_read_rsp
op_star
)paren
id|smb_read_data
suffix:semicolon
id|cifs_copy_cache_pages
c_func
(paren
id|mapping
comma
id|page_list
comma
id|bytes_read
comma
id|smb_read_data
op_plus
l_int|4
multiline_comment|/* RFC1001 hdr */
op_plus
id|le16_to_cpu
c_func
(paren
id|pSMBr-&gt;DataOffset
)paren
comma
op_amp
id|lru_pvec
)paren
suffix:semicolon
id|i
op_add_assign
id|bytes_read
op_rshift
id|PAGE_CACHE_SHIFT
suffix:semicolon
macro_line|#ifdef CONFIG_CIFS_STATS
id|atomic_inc
c_func
(paren
op_amp
id|pTcon-&gt;num_reads
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|pTcon-&gt;stat_lock
)paren
suffix:semicolon
id|pTcon-&gt;bytes_read
op_add_assign
id|bytes_read
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|pTcon-&gt;stat_lock
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
(paren
r_int
)paren
(paren
id|bytes_read
op_amp
id|PAGE_CACHE_MASK
)paren
op_ne
id|bytes_read
)paren
(brace
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;Partial page %d of %d read to cache&quot;
comma
id|i
op_increment
comma
id|num_pages
)paren
)paren
suffix:semicolon
id|i
op_increment
suffix:semicolon
multiline_comment|/* account for partial page */
multiline_comment|/* server copy of file can have smaller size than client */
multiline_comment|/* BB do we need to verify this common case ? this case is ok - &n;&t;&t;&t;&t;if we are at server EOF we will hit it on next read */
multiline_comment|/* while(!list_empty(page_list) &amp;&amp; (i &lt; num_pages)) {&n;&t;&t;&t;&t;&t;page = list_entry(page_list-&gt;prev,struct page, list);&n;&t;&t;&t;&t;&t;list_del(&amp;page-&gt;list);&n;&t;&t;&t;&t;&t;page_cache_release(page);&n;&t;&t;&t;&t;}&n;&t;&t;&t;&t;break; */
)brace
)brace
r_else
(brace
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;No bytes read (%d) at offset %lld . Cleaning remaining pages from readahead list&quot;
comma
id|bytes_read
comma
id|offset
)paren
)paren
suffix:semicolon
multiline_comment|/* BB turn off caching and do new lookup on file size at server? */
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
id|page_list
)paren
op_logical_and
(paren
id|i
OL
id|num_pages
)paren
)paren
(brace
id|page
op_assign
id|list_entry
c_func
(paren
id|page_list-&gt;prev
comma
r_struct
id|page
comma
id|lru
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|page-&gt;lru
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
multiline_comment|/* BB removeme - replace with zero of page? */
)brace
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|smb_read_data
)paren
(brace
id|cifs_buf_release
c_func
(paren
id|smb_read_data
)paren
suffix:semicolon
id|smb_read_data
op_assign
l_int|NULL
suffix:semicolon
)brace
id|bytes_read
op_assign
l_int|0
suffix:semicolon
)brace
id|pagevec_lru_add
c_func
(paren
op_amp
id|lru_pvec
)paren
suffix:semicolon
multiline_comment|/* need to free smb_read_data buf before exit */
r_if
c_cond
(paren
id|smb_read_data
)paren
(brace
id|cifs_buf_release
c_func
(paren
id|smb_read_data
)paren
suffix:semicolon
id|smb_read_data
op_assign
l_int|NULL
suffix:semicolon
)brace
id|FreeXid
c_func
(paren
id|xid
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
DECL|function|cifs_readpage_worker
r_static
r_int
id|cifs_readpage_worker
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_struct
id|page
op_star
id|page
comma
id|loff_t
op_star
id|poffset
)paren
(brace
r_char
op_star
id|read_data
suffix:semicolon
r_int
id|rc
suffix:semicolon
id|page_cache_get
c_func
(paren
id|page
)paren
suffix:semicolon
id|read_data
op_assign
id|kmap
c_func
(paren
id|page
)paren
suffix:semicolon
multiline_comment|/* for reads over a certain size could initiate async read ahead */
id|rc
op_assign
id|cifs_read
c_func
(paren
id|file
comma
id|read_data
comma
id|PAGE_CACHE_SIZE
comma
id|poffset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
OL
l_int|0
)paren
r_goto
id|io_error
suffix:semicolon
r_else
(brace
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;Bytes read %d &quot;
comma
id|rc
)paren
)paren
suffix:semicolon
)brace
id|file-&gt;f_dentry-&gt;d_inode-&gt;i_atime
op_assign
id|CURRENT_TIME
suffix:semicolon
r_if
c_cond
(paren
id|PAGE_CACHE_SIZE
OG
id|rc
)paren
(brace
id|memset
c_func
(paren
id|read_data
op_plus
id|rc
comma
l_int|0
comma
id|PAGE_CACHE_SIZE
op_minus
id|rc
)paren
suffix:semicolon
)brace
id|flush_dcache_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|SetPageUptodate
c_func
(paren
id|page
)paren
suffix:semicolon
id|rc
op_assign
l_int|0
suffix:semicolon
id|io_error
suffix:colon
id|kunmap
c_func
(paren
id|page
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
r_static
r_int
DECL|function|cifs_readpage
id|cifs_readpage
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_struct
id|page
op_star
id|page
)paren
(brace
id|loff_t
id|offset
op_assign
(paren
id|loff_t
)paren
id|page-&gt;index
op_lshift
id|PAGE_CACHE_SHIFT
suffix:semicolon
r_int
id|rc
op_assign
op_minus
id|EACCES
suffix:semicolon
r_int
id|xid
suffix:semicolon
id|xid
op_assign
id|GetXid
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;private_data
op_eq
l_int|NULL
)paren
(brace
id|FreeXid
c_func
(paren
id|xid
)paren
suffix:semicolon
r_return
op_minus
id|EBADF
suffix:semicolon
)brace
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;readpage %p at offset %d 0x%x&bslash;n&quot;
comma
id|page
comma
(paren
r_int
)paren
id|offset
comma
(paren
r_int
)paren
id|offset
)paren
)paren
suffix:semicolon
id|rc
op_assign
id|cifs_readpage_worker
c_func
(paren
id|file
comma
id|page
comma
op_amp
id|offset
)paren
suffix:semicolon
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|FreeXid
c_func
(paren
id|xid
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/* We do not want to update the file size from server for inodes&n;   open for write - to avoid races with writepage extending&n;   the file - in the future we could consider allowing&n;   refreshing the inode only on increases in the file size &n;   but this is tricky to do without racing with writebehind&n;   page caching in the current Linux kernel design */
DECL|function|is_size_safe_to_change
r_int
id|is_size_safe_to_change
c_func
(paren
r_struct
id|cifsInodeInfo
op_star
id|cifsInode
)paren
(brace
r_struct
id|list_head
op_star
id|tmp
suffix:semicolon
r_struct
id|list_head
op_star
id|tmp1
suffix:semicolon
r_struct
id|cifsFileInfo
op_star
id|open_file
op_assign
l_int|NULL
suffix:semicolon
r_int
id|rc
op_assign
id|TRUE
suffix:semicolon
r_if
c_cond
(paren
id|cifsInode
op_eq
l_int|NULL
)paren
(brace
r_return
id|rc
suffix:semicolon
)brace
id|read_lock
c_func
(paren
op_amp
id|GlobalSMBSeslock
)paren
suffix:semicolon
id|list_for_each_safe
c_func
(paren
id|tmp
comma
id|tmp1
comma
op_amp
id|cifsInode-&gt;openFileList
)paren
(brace
id|open_file
op_assign
id|list_entry
c_func
(paren
id|tmp
comma
r_struct
id|cifsFileInfo
comma
id|flist
)paren
suffix:semicolon
r_if
c_cond
(paren
id|open_file
op_eq
l_int|NULL
)paren
(brace
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|open_file-&gt;closePend
)paren
(brace
r_continue
suffix:semicolon
)brace
multiline_comment|/* We check if file is open for writing,   &n;&t;BB we could supplement this with a check to see if file size&n;&t;changes have been flushed to server - ie inode metadata dirty */
r_if
c_cond
(paren
(paren
id|open_file-&gt;pfile
)paren
op_logical_and
(paren
(paren
id|open_file-&gt;pfile-&gt;f_flags
op_amp
id|O_RDWR
)paren
op_logical_or
(paren
id|open_file-&gt;pfile-&gt;f_flags
op_amp
id|O_WRONLY
)paren
)paren
)paren
(brace
id|rc
op_assign
id|FALSE
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tmp-&gt;next
op_eq
l_int|NULL
)paren
(brace
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;File instance %p removed&quot;
comma
id|tmp
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|read_unlock
c_func
(paren
op_amp
id|GlobalSMBSeslock
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
r_void
DECL|function|fill_in_inode
id|fill_in_inode
c_func
(paren
r_struct
id|inode
op_star
id|tmp_inode
comma
id|FILE_DIRECTORY_INFO
op_star
id|pfindData
comma
r_int
op_star
id|pobject_type
)paren
(brace
r_struct
id|cifsInodeInfo
op_star
id|cifsInfo
op_assign
id|CIFS_I
c_func
(paren
id|tmp_inode
)paren
suffix:semicolon
r_struct
id|cifs_sb_info
op_star
id|cifs_sb
op_assign
id|CIFS_SB
c_func
(paren
id|tmp_inode-&gt;i_sb
)paren
suffix:semicolon
id|__u32
id|attr
op_assign
id|le32_to_cpu
c_func
(paren
id|pfindData-&gt;ExtFileAttributes
)paren
suffix:semicolon
id|__u64
id|allocation_size
op_assign
id|le64_to_cpu
c_func
(paren
id|pfindData-&gt;AllocationSize
)paren
suffix:semicolon
id|__u64
id|end_of_file
op_assign
id|le64_to_cpu
c_func
(paren
id|pfindData-&gt;EndOfFile
)paren
suffix:semicolon
id|cifsInfo-&gt;cifsAttrs
op_assign
id|attr
suffix:semicolon
id|cifsInfo-&gt;time
op_assign
id|jiffies
suffix:semicolon
multiline_comment|/* Linux can not store file creation time unfortunately so ignore it */
id|tmp_inode-&gt;i_atime
op_assign
id|cifs_NTtimeToUnix
c_func
(paren
id|le64_to_cpu
c_func
(paren
id|pfindData-&gt;LastAccessTime
)paren
)paren
suffix:semicolon
id|tmp_inode-&gt;i_mtime
op_assign
id|cifs_NTtimeToUnix
c_func
(paren
id|le64_to_cpu
c_func
(paren
id|pfindData-&gt;LastWriteTime
)paren
)paren
suffix:semicolon
id|tmp_inode-&gt;i_ctime
op_assign
id|cifs_NTtimeToUnix
c_func
(paren
id|le64_to_cpu
c_func
(paren
id|pfindData-&gt;ChangeTime
)paren
)paren
suffix:semicolon
multiline_comment|/* treat dos attribute of read-only as read-only mode bit e.g. 555? */
multiline_comment|/* 2767 perms - indicate mandatory locking */
multiline_comment|/* BB fill in uid and gid here? with help from winbind? &n;&t;&t;&t;or retrieve from NTFS stream extended attribute */
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|cifsInfo-&gt;inUse
)paren
op_eq
l_int|0
)paren
(brace
id|tmp_inode-&gt;i_uid
op_assign
id|cifs_sb-&gt;mnt_uid
suffix:semicolon
id|tmp_inode-&gt;i_gid
op_assign
id|cifs_sb-&gt;mnt_gid
suffix:semicolon
multiline_comment|/* set default mode. will override for dirs below */
id|tmp_inode-&gt;i_mode
op_assign
id|cifs_sb-&gt;mnt_file_mode
suffix:semicolon
)brace
id|cFYI
c_func
(paren
l_int|0
comma
(paren
l_string|&quot;CIFS FFIRST: Attributes came in as 0x%x&quot;
comma
id|attr
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|attr
op_amp
id|ATTR_DIRECTORY
)paren
(brace
op_star
id|pobject_type
op_assign
id|DT_DIR
suffix:semicolon
multiline_comment|/* override default perms since we do not lock dirs */
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|cifsInfo-&gt;inUse
)paren
op_eq
l_int|0
)paren
(brace
id|tmp_inode-&gt;i_mode
op_assign
id|cifs_sb-&gt;mnt_dir_mode
suffix:semicolon
)brace
id|tmp_inode-&gt;i_mode
op_or_assign
id|S_IFDIR
suffix:semicolon
multiline_comment|/* we no longer mark these because we could not follow them */
multiline_comment|/*        } else if (attr &amp; ATTR_REPARSE) {&n;                *pobject_type = DT_LNK;&n;                tmp_inode-&gt;i_mode |= S_IFLNK;*/
)brace
r_else
(brace
op_star
id|pobject_type
op_assign
id|DT_REG
suffix:semicolon
id|tmp_inode-&gt;i_mode
op_or_assign
id|S_IFREG
suffix:semicolon
r_if
c_cond
(paren
id|attr
op_amp
id|ATTR_READONLY
)paren
(brace
id|tmp_inode-&gt;i_mode
op_and_assign
op_complement
(paren
id|S_IWUGO
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* could add code here - to validate if device or weird share type? */
multiline_comment|/* can not fill in nlink here as in qpathinfo version and Unx search */
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|cifsInfo-&gt;inUse
)paren
op_eq
l_int|0
)paren
(brace
id|atomic_set
c_func
(paren
op_amp
id|cifsInfo-&gt;inUse
comma
l_int|1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|is_size_safe_to_change
c_func
(paren
id|cifsInfo
)paren
)paren
(brace
multiline_comment|/* can not safely change the file size here if the &n;&t;&t;client is writing to it due to potential races */
id|i_size_write
c_func
(paren
id|tmp_inode
comma
id|end_of_file
)paren
suffix:semicolon
multiline_comment|/* 512 bytes (2**9) is the fake blocksize that must be used */
multiline_comment|/* for this calculation, even though the reported blocksize is larger */
id|tmp_inode-&gt;i_blocks
op_assign
(paren
l_int|512
op_minus
l_int|1
op_plus
id|allocation_size
)paren
op_rshift
l_int|9
suffix:semicolon
)brace
r_if
c_cond
(paren
id|allocation_size
OL
id|end_of_file
)paren
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;Possible sparse file: allocation size less than end of file &quot;
)paren
)paren
suffix:semicolon
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;File Size %ld and blocks %ld and blocksize %ld&quot;
comma
(paren
r_int
r_int
)paren
id|tmp_inode-&gt;i_size
comma
id|tmp_inode-&gt;i_blocks
comma
id|tmp_inode-&gt;i_blksize
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|S_ISREG
c_func
(paren
id|tmp_inode-&gt;i_mode
)paren
)paren
(brace
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot; File inode &quot;
)paren
)paren
suffix:semicolon
id|tmp_inode-&gt;i_op
op_assign
op_amp
id|cifs_file_inode_ops
suffix:semicolon
id|tmp_inode-&gt;i_fop
op_assign
op_amp
id|cifs_file_ops
suffix:semicolon
id|tmp_inode-&gt;i_data.a_ops
op_assign
op_amp
id|cifs_addr_ops
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|S_ISDIR
c_func
(paren
id|tmp_inode-&gt;i_mode
)paren
)paren
(brace
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot; Directory inode&quot;
)paren
)paren
suffix:semicolon
id|tmp_inode-&gt;i_op
op_assign
op_amp
id|cifs_dir_inode_ops
suffix:semicolon
id|tmp_inode-&gt;i_fop
op_assign
op_amp
id|cifs_dir_ops
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|S_ISLNK
c_func
(paren
id|tmp_inode-&gt;i_mode
)paren
)paren
(brace
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot; Symbolic Link inode &quot;
)paren
)paren
suffix:semicolon
id|tmp_inode-&gt;i_op
op_assign
op_amp
id|cifs_symlink_inode_ops
suffix:semicolon
)brace
r_else
(brace
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot; Init special inode &quot;
)paren
)paren
suffix:semicolon
id|init_special_inode
c_func
(paren
id|tmp_inode
comma
id|tmp_inode-&gt;i_mode
comma
id|tmp_inode-&gt;i_rdev
)paren
suffix:semicolon
)brace
)brace
r_void
DECL|function|unix_fill_in_inode
id|unix_fill_in_inode
c_func
(paren
r_struct
id|inode
op_star
id|tmp_inode
comma
id|FILE_UNIX_INFO
op_star
id|pfindData
comma
r_int
op_star
id|pobject_type
)paren
(brace
r_struct
id|cifsInodeInfo
op_star
id|cifsInfo
op_assign
id|CIFS_I
c_func
(paren
id|tmp_inode
)paren
suffix:semicolon
id|__u32
id|type
op_assign
id|le32_to_cpu
c_func
(paren
id|pfindData-&gt;Type
)paren
suffix:semicolon
id|__u64
id|num_of_bytes
op_assign
id|le64_to_cpu
c_func
(paren
id|pfindData-&gt;NumOfBytes
)paren
suffix:semicolon
id|__u64
id|end_of_file
op_assign
id|le64_to_cpu
c_func
(paren
id|pfindData-&gt;EndOfFile
)paren
suffix:semicolon
id|cifsInfo-&gt;time
op_assign
id|jiffies
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|cifsInfo-&gt;inUse
)paren
suffix:semicolon
id|tmp_inode-&gt;i_atime
op_assign
id|cifs_NTtimeToUnix
c_func
(paren
id|le64_to_cpu
c_func
(paren
id|pfindData-&gt;LastAccessTime
)paren
)paren
suffix:semicolon
id|tmp_inode-&gt;i_mtime
op_assign
id|cifs_NTtimeToUnix
c_func
(paren
id|le64_to_cpu
c_func
(paren
id|pfindData-&gt;LastModificationTime
)paren
)paren
suffix:semicolon
id|tmp_inode-&gt;i_ctime
op_assign
id|cifs_NTtimeToUnix
c_func
(paren
id|le64_to_cpu
c_func
(paren
id|pfindData-&gt;LastStatusChange
)paren
)paren
suffix:semicolon
id|tmp_inode-&gt;i_mode
op_assign
id|le64_to_cpu
c_func
(paren
id|pfindData-&gt;Permissions
)paren
suffix:semicolon
r_if
c_cond
(paren
id|type
op_eq
id|UNIX_FILE
)paren
(brace
op_star
id|pobject_type
op_assign
id|DT_REG
suffix:semicolon
id|tmp_inode-&gt;i_mode
op_or_assign
id|S_IFREG
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|type
op_eq
id|UNIX_SYMLINK
)paren
(brace
op_star
id|pobject_type
op_assign
id|DT_LNK
suffix:semicolon
id|tmp_inode-&gt;i_mode
op_or_assign
id|S_IFLNK
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|type
op_eq
id|UNIX_DIR
)paren
(brace
op_star
id|pobject_type
op_assign
id|DT_DIR
suffix:semicolon
id|tmp_inode-&gt;i_mode
op_or_assign
id|S_IFDIR
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|type
op_eq
id|UNIX_CHARDEV
)paren
(brace
op_star
id|pobject_type
op_assign
id|DT_CHR
suffix:semicolon
id|tmp_inode-&gt;i_mode
op_or_assign
id|S_IFCHR
suffix:semicolon
id|tmp_inode-&gt;i_rdev
op_assign
id|MKDEV
c_func
(paren
id|le64_to_cpu
c_func
(paren
id|pfindData-&gt;DevMajor
)paren
comma
id|le64_to_cpu
c_func
(paren
id|pfindData-&gt;DevMinor
)paren
op_amp
id|MINORMASK
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|type
op_eq
id|UNIX_BLOCKDEV
)paren
(brace
op_star
id|pobject_type
op_assign
id|DT_BLK
suffix:semicolon
id|tmp_inode-&gt;i_mode
op_or_assign
id|S_IFBLK
suffix:semicolon
id|tmp_inode-&gt;i_rdev
op_assign
id|MKDEV
c_func
(paren
id|le64_to_cpu
c_func
(paren
id|pfindData-&gt;DevMajor
)paren
comma
id|le64_to_cpu
c_func
(paren
id|pfindData-&gt;DevMinor
)paren
op_amp
id|MINORMASK
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|type
op_eq
id|UNIX_FIFO
)paren
(brace
op_star
id|pobject_type
op_assign
id|DT_FIFO
suffix:semicolon
id|tmp_inode-&gt;i_mode
op_or_assign
id|S_IFIFO
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|type
op_eq
id|UNIX_SOCKET
)paren
(brace
op_star
id|pobject_type
op_assign
id|DT_SOCK
suffix:semicolon
id|tmp_inode-&gt;i_mode
op_or_assign
id|S_IFSOCK
suffix:semicolon
)brace
id|tmp_inode-&gt;i_uid
op_assign
id|le64_to_cpu
c_func
(paren
id|pfindData-&gt;Uid
)paren
suffix:semicolon
id|tmp_inode-&gt;i_gid
op_assign
id|le64_to_cpu
c_func
(paren
id|pfindData-&gt;Gid
)paren
suffix:semicolon
id|tmp_inode-&gt;i_nlink
op_assign
id|le64_to_cpu
c_func
(paren
id|pfindData-&gt;Nlinks
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_size_safe_to_change
c_func
(paren
id|cifsInfo
)paren
)paren
(brace
multiline_comment|/* can not safely change the file size here if the &n;&t;&t;client is writing to it due to potential races */
id|i_size_write
c_func
(paren
id|tmp_inode
comma
id|end_of_file
)paren
suffix:semicolon
multiline_comment|/* 512 bytes (2**9) is the fake blocksize that must be used */
multiline_comment|/* for this calculation, not the real blocksize */
id|tmp_inode-&gt;i_blocks
op_assign
(paren
l_int|512
op_minus
l_int|1
op_plus
id|num_of_bytes
)paren
op_rshift
l_int|9
suffix:semicolon
)brace
r_if
c_cond
(paren
id|S_ISREG
c_func
(paren
id|tmp_inode-&gt;i_mode
)paren
)paren
(brace
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;File inode&quot;
)paren
)paren
suffix:semicolon
id|tmp_inode-&gt;i_op
op_assign
op_amp
id|cifs_file_inode_ops
suffix:semicolon
id|tmp_inode-&gt;i_fop
op_assign
op_amp
id|cifs_file_ops
suffix:semicolon
id|tmp_inode-&gt;i_data.a_ops
op_assign
op_amp
id|cifs_addr_ops
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|S_ISDIR
c_func
(paren
id|tmp_inode-&gt;i_mode
)paren
)paren
(brace
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;Directory inode&quot;
)paren
)paren
suffix:semicolon
id|tmp_inode-&gt;i_op
op_assign
op_amp
id|cifs_dir_inode_ops
suffix:semicolon
id|tmp_inode-&gt;i_fop
op_assign
op_amp
id|cifs_dir_ops
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|S_ISLNK
c_func
(paren
id|tmp_inode-&gt;i_mode
)paren
)paren
(brace
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;Symbolic Link inode&quot;
)paren
)paren
suffix:semicolon
id|tmp_inode-&gt;i_op
op_assign
op_amp
id|cifs_symlink_inode_ops
suffix:semicolon
multiline_comment|/* tmp_inode-&gt;i_fop = */
multiline_comment|/* do not need to set to anything */
)brace
r_else
(brace
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;Special inode&quot;
)paren
)paren
suffix:semicolon
id|init_special_inode
c_func
(paren
id|tmp_inode
comma
id|tmp_inode-&gt;i_mode
comma
id|tmp_inode-&gt;i_rdev
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Returns one if new inode created (which therefore needs to be hashed) */
multiline_comment|/* Might check in the future if inode number changed so we can rehash inode */
r_int
DECL|function|construct_dentry
id|construct_dentry
c_func
(paren
r_struct
id|qstr
op_star
id|qstring
comma
r_struct
id|file
op_star
id|file
comma
r_struct
id|inode
op_star
op_star
id|ptmp_inode
comma
r_struct
id|dentry
op_star
op_star
id|pnew_dentry
)paren
(brace
r_struct
id|dentry
op_star
id|tmp_dentry
suffix:semicolon
r_struct
id|cifs_sb_info
op_star
id|cifs_sb
suffix:semicolon
r_struct
id|cifsTconInfo
op_star
id|pTcon
suffix:semicolon
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;For %s &quot;
comma
id|qstring-&gt;name
)paren
)paren
suffix:semicolon
id|cifs_sb
op_assign
id|CIFS_SB
c_func
(paren
id|file-&gt;f_dentry-&gt;d_sb
)paren
suffix:semicolon
id|pTcon
op_assign
id|cifs_sb-&gt;tcon
suffix:semicolon
id|qstring-&gt;hash
op_assign
id|full_name_hash
c_func
(paren
id|qstring-&gt;name
comma
id|qstring-&gt;len
)paren
suffix:semicolon
id|tmp_dentry
op_assign
id|d_lookup
c_func
(paren
id|file-&gt;f_dentry
comma
id|qstring
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp_dentry
)paren
(brace
id|cFYI
c_func
(paren
l_int|0
comma
(paren
l_string|&quot; existing dentry with inode 0x%p&quot;
comma
id|tmp_dentry-&gt;d_inode
)paren
)paren
suffix:semicolon
op_star
id|ptmp_inode
op_assign
id|tmp_dentry-&gt;d_inode
suffix:semicolon
multiline_comment|/* BB overwrite the old name? i.e. tmp_dentry-&gt;d_name and tmp_dentry-&gt;d_name.len ?? */
r_if
c_cond
(paren
op_star
id|ptmp_inode
op_eq
l_int|NULL
)paren
(brace
op_star
id|ptmp_inode
op_assign
id|new_inode
c_func
(paren
id|file-&gt;f_dentry-&gt;d_sb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|ptmp_inode
op_eq
l_int|NULL
)paren
(brace
r_return
id|rc
suffix:semicolon
)brace
id|rc
op_assign
l_int|1
suffix:semicolon
id|d_instantiate
c_func
(paren
id|tmp_dentry
comma
op_star
id|ptmp_inode
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|tmp_dentry
op_assign
id|d_alloc
c_func
(paren
id|file-&gt;f_dentry
comma
id|qstring
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp_dentry
op_eq
l_int|NULL
)paren
(brace
id|cERROR
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;Failed allocating dentry&quot;
)paren
)paren
suffix:semicolon
op_star
id|ptmp_inode
op_assign
l_int|NULL
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
op_star
id|ptmp_inode
op_assign
id|new_inode
c_func
(paren
id|file-&gt;f_dentry-&gt;d_sb
)paren
suffix:semicolon
id|tmp_dentry-&gt;d_op
op_assign
op_amp
id|cifs_dentry_ops
suffix:semicolon
r_if
c_cond
(paren
op_star
id|ptmp_inode
op_eq
l_int|NULL
)paren
(brace
r_return
id|rc
suffix:semicolon
)brace
id|rc
op_assign
l_int|1
suffix:semicolon
id|d_instantiate
c_func
(paren
id|tmp_dentry
comma
op_star
id|ptmp_inode
)paren
suffix:semicolon
id|d_rehash
c_func
(paren
id|tmp_dentry
)paren
suffix:semicolon
)brace
id|tmp_dentry-&gt;d_time
op_assign
id|jiffies
suffix:semicolon
op_star
id|pnew_dentry
op_assign
id|tmp_dentry
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
DECL|function|reset_resume_key
r_static
r_void
id|reset_resume_key
c_func
(paren
r_struct
id|file
op_star
id|dir_file
comma
r_int
r_char
op_star
id|filename
comma
r_int
r_int
id|len
comma
r_int
id|Unicode
comma
r_struct
id|nls_table
op_star
id|nls_tab
)paren
(brace
r_struct
id|cifsFileInfo
op_star
id|cifsFile
suffix:semicolon
id|cifsFile
op_assign
(paren
r_struct
id|cifsFileInfo
op_star
)paren
id|dir_file-&gt;private_data
suffix:semicolon
r_if
c_cond
(paren
id|cifsFile
op_eq
l_int|NULL
)paren
(brace
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cifsFile-&gt;search_resume_name
)paren
(brace
id|kfree
c_func
(paren
id|cifsFile-&gt;search_resume_name
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|Unicode
)paren
(brace
id|len
op_mul_assign
l_int|2
suffix:semicolon
)brace
id|cifsFile-&gt;resume_name_length
op_assign
id|len
suffix:semicolon
id|cifsFile-&gt;search_resume_name
op_assign
id|kmalloc
c_func
(paren
id|cifsFile-&gt;resume_name_length
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cifsFile-&gt;search_resume_name
op_eq
l_int|NULL
)paren
(brace
id|cERROR
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;failed new resume key allocate, length %d&quot;
comma
id|cifsFile-&gt;resume_name_length
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|Unicode
)paren
(brace
id|cifs_strtoUCS
c_func
(paren
(paren
m_wchar_t
op_star
)paren
id|cifsFile-&gt;search_resume_name
comma
id|filename
comma
id|len
comma
id|nls_tab
)paren
suffix:semicolon
)brace
r_else
id|memcpy
c_func
(paren
id|cifsFile-&gt;search_resume_name
comma
id|filename
comma
id|cifsFile-&gt;resume_name_length
)paren
suffix:semicolon
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;Reset resume key to: %s with len %d&quot;
comma
id|filename
comma
id|len
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_static
r_int
DECL|function|cifs_filldir
id|cifs_filldir
c_func
(paren
r_struct
id|qstr
op_star
id|pqstring
comma
id|FILE_DIRECTORY_INFO
op_star
id|pfindData
comma
r_struct
id|file
op_star
id|file
comma
id|filldir_t
id|filldir
comma
r_void
op_star
id|direntry
)paren
(brace
r_struct
id|inode
op_star
id|tmp_inode
suffix:semicolon
r_struct
id|dentry
op_star
id|tmp_dentry
suffix:semicolon
r_int
id|object_type
comma
id|rc
suffix:semicolon
id|pqstring-&gt;name
op_assign
id|pfindData-&gt;FileName
suffix:semicolon
multiline_comment|/* pqstring-&gt;len is already set by caller */
id|rc
op_assign
id|construct_dentry
c_func
(paren
id|pqstring
comma
id|file
comma
op_amp
id|tmp_inode
comma
op_amp
id|tmp_dentry
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tmp_inode
op_eq
l_int|NULL
)paren
op_logical_or
(paren
id|tmp_dentry
op_eq
l_int|NULL
)paren
)paren
(brace
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|fill_in_inode
c_func
(paren
id|tmp_inode
comma
id|pfindData
comma
op_amp
id|object_type
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
(brace
multiline_comment|/* We have no reliable way to get inode numbers&n;&t;&t;from servers w/o Unix extensions yet so we can not set&n;&t;&t;i_ino from pfindData yet */
multiline_comment|/* new inode created, let us hash it */
id|insert_inode_hash
c_func
(paren
id|tmp_inode
)paren
suffix:semicolon
)brace
multiline_comment|/* else if inode number changed do we rehash it? */
id|rc
op_assign
id|filldir
c_func
(paren
id|direntry
comma
id|pfindData-&gt;FileName
comma
id|pqstring-&gt;len
comma
id|file-&gt;f_pos
comma
id|tmp_inode-&gt;i_ino
comma
id|object_type
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
(brace
multiline_comment|/* due to readdir error we need to recalculate resume &n;&t;&t;key so next readdir will restart on right entry */
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;Error %d on filldir of %s&quot;
comma
id|rc
comma
id|pfindData-&gt;FileName
)paren
)paren
suffix:semicolon
)brace
id|dput
c_func
(paren
id|tmp_dentry
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
r_static
r_int
DECL|function|cifs_filldir_unix
id|cifs_filldir_unix
c_func
(paren
r_struct
id|qstr
op_star
id|pqstring
comma
id|FILE_UNIX_INFO
op_star
id|pUnixFindData
comma
r_struct
id|file
op_star
id|file
comma
id|filldir_t
id|filldir
comma
r_void
op_star
id|direntry
)paren
(brace
r_struct
id|inode
op_star
id|tmp_inode
suffix:semicolon
r_struct
id|dentry
op_star
id|tmp_dentry
suffix:semicolon
r_int
id|object_type
comma
id|rc
suffix:semicolon
id|pqstring-&gt;name
op_assign
id|pUnixFindData-&gt;FileName
suffix:semicolon
id|pqstring-&gt;len
op_assign
id|strnlen
c_func
(paren
id|pUnixFindData-&gt;FileName
comma
id|MAX_PATHCONF
)paren
suffix:semicolon
id|rc
op_assign
id|construct_dentry
c_func
(paren
id|pqstring
comma
id|file
comma
op_amp
id|tmp_inode
comma
op_amp
id|tmp_dentry
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tmp_inode
op_eq
l_int|NULL
)paren
op_logical_or
(paren
id|tmp_dentry
op_eq
l_int|NULL
)paren
)paren
(brace
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rc
)paren
(brace
r_struct
id|cifs_sb_info
op_star
id|cifs_sb
op_assign
id|CIFS_SB
c_func
(paren
id|tmp_inode-&gt;i_sb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cifs_sb-&gt;mnt_cifs_flags
op_amp
id|CIFS_MOUNT_SERVER_INUM
)paren
(brace
id|tmp_inode-&gt;i_ino
op_assign
(paren
r_int
r_int
)paren
id|pUnixFindData-&gt;UniqueId
suffix:semicolon
)brace
id|insert_inode_hash
c_func
(paren
id|tmp_inode
)paren
suffix:semicolon
)brace
multiline_comment|/* else if i_ino has changed should we rehash it? */
id|unix_fill_in_inode
c_func
(paren
id|tmp_inode
comma
id|pUnixFindData
comma
op_amp
id|object_type
)paren
suffix:semicolon
id|rc
op_assign
id|filldir
c_func
(paren
id|direntry
comma
id|pUnixFindData-&gt;FileName
comma
id|pqstring-&gt;len
comma
id|file-&gt;f_pos
comma
id|tmp_inode-&gt;i_ino
comma
id|object_type
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
(brace
multiline_comment|/* due to readdir error we need to recalculate resume &n;&t;&t;&t;key so next readdir will restart on right entry */
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;Error %d on filldir of %s&quot;
comma
id|rc
comma
id|pUnixFindData-&gt;FileName
)paren
)paren
suffix:semicolon
)brace
id|dput
c_func
(paren
id|tmp_dentry
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
r_int
DECL|function|cifs_readdir
id|cifs_readdir
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_void
op_star
id|direntry
comma
id|filldir_t
id|filldir
)paren
(brace
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
r_int
id|xid
suffix:semicolon
r_int
id|Unicode
op_assign
id|FALSE
suffix:semicolon
r_int
id|UnixSearch
op_assign
id|FALSE
suffix:semicolon
r_int
r_int
id|bufsize
comma
id|i
suffix:semicolon
id|__u16
id|searchHandle
suffix:semicolon
r_struct
id|cifs_sb_info
op_star
id|cifs_sb
suffix:semicolon
r_struct
id|cifsTconInfo
op_star
id|pTcon
suffix:semicolon
r_struct
id|cifsFileInfo
op_star
id|cifsFile
op_assign
l_int|NULL
suffix:semicolon
r_char
op_star
id|full_path
op_assign
l_int|NULL
suffix:semicolon
r_char
op_star
id|data
suffix:semicolon
r_struct
id|qstr
id|qstring
suffix:semicolon
id|T2_FFIRST_RSP_PARMS
id|findParms
suffix:semicolon
id|T2_FNEXT_RSP_PARMS
id|findNextParms
suffix:semicolon
id|FILE_DIRECTORY_INFO
op_star
id|pfindData
suffix:semicolon
id|FILE_DIRECTORY_INFO
op_star
id|lastFindData
suffix:semicolon
id|FILE_UNIX_INFO
op_star
id|pfindDataUnix
suffix:semicolon
multiline_comment|/* BB removeme begin */
r_if
c_cond
(paren
op_logical_neg
id|experimEnabled
)paren
(brace
r_return
id|cifs_readdir2
c_func
(paren
id|file
comma
id|direntry
comma
id|filldir
)paren
suffix:semicolon
)brace
multiline_comment|/* BB removeme end */
id|xid
op_assign
id|GetXid
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_dentry
op_eq
l_int|NULL
)paren
(brace
id|rc
op_assign
op_minus
id|EIO
suffix:semicolon
id|FreeXid
c_func
(paren
id|xid
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
id|cifs_sb
op_assign
id|CIFS_SB
c_func
(paren
id|file-&gt;f_dentry-&gt;d_sb
)paren
suffix:semicolon
id|pTcon
op_assign
id|cifs_sb-&gt;tcon
suffix:semicolon
id|bufsize
op_assign
id|pTcon-&gt;ses-&gt;server-&gt;maxBuf
op_minus
id|MAX_CIFS_HDR_SIZE
suffix:semicolon
r_if
c_cond
(paren
id|bufsize
OG
id|CIFS_MAX_MSGSIZE
)paren
(brace
id|rc
op_assign
op_minus
id|EIO
suffix:semicolon
id|FreeXid
c_func
(paren
id|xid
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
id|data
op_assign
id|kmalloc
c_func
(paren
id|bufsize
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|pfindData
op_assign
(paren
id|FILE_DIRECTORY_INFO
op_star
)paren
id|data
suffix:semicolon
r_if
c_cond
(paren
id|data
op_eq
l_int|NULL
)paren
(brace
id|rc
op_assign
op_minus
id|ENOMEM
suffix:semicolon
id|FreeXid
c_func
(paren
id|xid
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
id|down
c_func
(paren
op_amp
id|file-&gt;f_dentry-&gt;d_sb-&gt;s_vfs_rename_sem
)paren
suffix:semicolon
id|full_path
op_assign
id|build_wildcard_path_from_dentry
c_func
(paren
id|file-&gt;f_dentry
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|file-&gt;f_dentry-&gt;d_sb-&gt;s_vfs_rename_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|full_path
op_eq
l_int|NULL
)paren
(brace
id|kfree
c_func
(paren
id|data
)paren
suffix:semicolon
id|FreeXid
c_func
(paren
id|xid
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;Full path: %s start at: %lld &quot;
comma
id|full_path
comma
id|file-&gt;f_pos
)paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
(paren
r_int
)paren
id|file-&gt;f_pos
)paren
(brace
r_case
l_int|0
suffix:colon
r_if
c_cond
(paren
id|filldir
c_func
(paren
id|direntry
comma
l_string|&quot;.&quot;
comma
l_int|1
comma
id|file-&gt;f_pos
comma
id|file-&gt;f_dentry-&gt;d_inode-&gt;i_ino
comma
id|DT_DIR
)paren
OL
l_int|0
)paren
(brace
id|cERROR
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;Filldir for current dir failed &quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|file-&gt;f_pos
op_increment
suffix:semicolon
multiline_comment|/* fallthrough */
r_case
l_int|1
suffix:colon
r_if
c_cond
(paren
id|filldir
c_func
(paren
id|direntry
comma
l_string|&quot;..&quot;
comma
l_int|2
comma
id|file-&gt;f_pos
comma
id|file-&gt;f_dentry-&gt;d_parent-&gt;d_inode-&gt;i_ino
comma
id|DT_DIR
)paren
OL
l_int|0
)paren
(brace
id|cERROR
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;Filldir for parent dir failed &quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|file-&gt;f_pos
op_increment
suffix:semicolon
multiline_comment|/* fallthrough */
r_case
l_int|2
suffix:colon
r_if
c_cond
(paren
id|file-&gt;private_data
op_ne
l_int|NULL
)paren
(brace
id|cifsFile
op_assign
(paren
r_struct
id|cifsFileInfo
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
r_if
c_cond
(paren
id|cifsFile-&gt;srch_inf.endOfSearch
)paren
(brace
r_if
c_cond
(paren
id|cifsFile-&gt;srch_inf.emptyDir
)paren
(brace
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;End of search, empty dir&quot;
)paren
)paren
suffix:semicolon
id|rc
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_else
(brace
id|cifsFile-&gt;invalidHandle
op_assign
id|TRUE
suffix:semicolon
id|CIFSFindClose
c_func
(paren
id|xid
comma
id|pTcon
comma
id|cifsFile-&gt;netfid
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cifsFile-&gt;search_resume_name
)paren
(brace
id|kfree
c_func
(paren
id|cifsFile-&gt;search_resume_name
)paren
suffix:semicolon
id|cifsFile-&gt;search_resume_name
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
id|rc
op_assign
id|CIFSFindFirst
c_func
(paren
id|xid
comma
id|pTcon
comma
id|full_path
comma
id|pfindData
comma
op_amp
id|findParms
comma
id|cifs_sb-&gt;local_nls
comma
op_amp
id|Unicode
comma
op_amp
id|UnixSearch
)paren
suffix:semicolon
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;Count: %d  End: %d &quot;
comma
id|le16_to_cpu
c_func
(paren
id|findParms.SearchCount
)paren
comma
id|le16_to_cpu
c_func
(paren
id|findParms.EndofSearch
)paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_eq
l_int|0
)paren
(brace
id|__u16
id|count
op_assign
id|le16_to_cpu
c_func
(paren
id|findParms.SearchCount
)paren
suffix:semicolon
id|searchHandle
op_assign
id|findParms.SearchHandle
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;private_data
op_eq
l_int|NULL
)paren
(brace
id|file-&gt;private_data
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|cifsFileInfo
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|file-&gt;private_data
)paren
(brace
id|memset
c_func
(paren
id|file-&gt;private_data
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|cifsFileInfo
)paren
)paren
suffix:semicolon
id|cifsFile
op_assign
(paren
r_struct
id|cifsFileInfo
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
id|cifsFile-&gt;netfid
op_assign
id|searchHandle
suffix:semicolon
id|cifsFile-&gt;invalidHandle
op_assign
id|FALSE
suffix:semicolon
id|init_MUTEX
c_func
(paren
op_amp
id|cifsFile-&gt;fh_sem
)paren
suffix:semicolon
)brace
r_else
(brace
id|rc
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_break
suffix:semicolon
)brace
id|renew_parental_timestamps
c_func
(paren
id|file-&gt;f_dentry
)paren
suffix:semicolon
id|lastFindData
op_assign
(paren
id|FILE_DIRECTORY_INFO
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|pfindData
op_plus
id|le16_to_cpu
c_func
(paren
id|findParms.LastNameOffset
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
r_char
op_star
)paren
id|lastFindData
OG
(paren
r_char
op_star
)paren
id|pfindData
op_plus
id|bufsize
)paren
(brace
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;last search entry past end of packet&quot;
)paren
)paren
suffix:semicolon
id|rc
op_assign
op_minus
id|EIO
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Offset of resume key same for levels 257 and 514 */
id|cifsFile-&gt;srch_inf.resume_key
op_assign
id|lastFindData-&gt;FileIndex
suffix:semicolon
r_if
c_cond
(paren
id|UnixSearch
op_eq
id|FALSE
)paren
(brace
id|cifsFile-&gt;resume_name_length
op_assign
id|le32_to_cpu
c_func
(paren
id|lastFindData-&gt;FileNameLength
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cifsFile-&gt;resume_name_length
OG
id|bufsize
op_minus
l_int|64
)paren
(brace
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;Illegal resume file name length %d&quot;
comma
id|cifsFile-&gt;resume_name_length
)paren
)paren
suffix:semicolon
id|rc
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_break
suffix:semicolon
)brace
id|cifsFile-&gt;search_resume_name
op_assign
id|kmalloc
c_func
(paren
id|cifsFile-&gt;resume_name_length
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;Last file: %s with name %d bytes long&quot;
comma
id|lastFindData-&gt;FileName
comma
id|cifsFile-&gt;resume_name_length
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cifsFile-&gt;search_resume_name
op_eq
l_int|NULL
)paren
(brace
id|rc
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_break
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|cifsFile-&gt;search_resume_name
comma
id|lastFindData-&gt;FileName
comma
id|cifsFile-&gt;resume_name_length
)paren
suffix:semicolon
)brace
r_else
(brace
id|pfindDataUnix
op_assign
(paren
id|FILE_UNIX_INFO
op_star
)paren
id|lastFindData
suffix:semicolon
r_if
c_cond
(paren
id|Unicode
op_eq
id|TRUE
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
(paren
id|pfindDataUnix-&gt;FileName
(braket
id|i
)braket
op_or
id|pfindDataUnix-&gt;FileName
(braket
id|i
op_plus
l_int|1
)braket
)paren
suffix:semicolon
id|i
op_add_assign
l_int|2
)paren
(brace
r_if
c_cond
(paren
id|i
OG
id|bufsize
op_minus
l_int|64
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
id|cifsFile-&gt;resume_name_length
op_assign
id|i
op_plus
l_int|2
suffix:semicolon
)brace
r_else
(brace
id|cifsFile-&gt;resume_name_length
op_assign
id|strnlen
c_func
(paren
id|pfindDataUnix-&gt;FileName
comma
id|bufsize
op_minus
l_int|63
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cifsFile-&gt;resume_name_length
OG
id|bufsize
op_minus
l_int|64
)paren
(brace
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;Illegal resume file name length %d&quot;
comma
id|cifsFile-&gt;resume_name_length
)paren
)paren
suffix:semicolon
id|rc
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_break
suffix:semicolon
)brace
id|cifsFile-&gt;search_resume_name
op_assign
id|kmalloc
c_func
(paren
id|cifsFile-&gt;resume_name_length
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;Last file: %s with name %d bytes long&quot;
comma
id|pfindDataUnix-&gt;FileName
comma
id|cifsFile-&gt;resume_name_length
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cifsFile-&gt;search_resume_name
op_eq
l_int|NULL
)paren
(brace
id|rc
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_break
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|cifsFile-&gt;search_resume_name
comma
id|pfindDataUnix-&gt;FileName
comma
id|cifsFile-&gt;resume_name_length
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|2
suffix:semicolon
id|i
OL
id|count
op_plus
l_int|2
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|UnixSearch
op_eq
id|FALSE
)paren
(brace
id|__u32
id|len
op_assign
id|le32_to_cpu
c_func
(paren
id|pfindData-&gt;FileNameLength
)paren
suffix:semicolon
r_if
c_cond
(paren
id|Unicode
op_eq
id|TRUE
)paren
id|len
op_assign
id|cifs_strfromUCS_le
(paren
id|pfindData-&gt;FileName
comma
(paren
m_wchar_t
op_star
)paren
id|pfindData-&gt;FileName
comma
id|len
op_div
l_int|2
comma
id|cifs_sb-&gt;local_nls
)paren
suffix:semicolon
id|qstring.len
op_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|len
op_ne
l_int|1
)paren
op_logical_or
(paren
id|pfindData-&gt;FileName
(braket
l_int|0
)braket
op_ne
l_char|&squot;.&squot;
)paren
)paren
op_logical_and
(paren
(paren
id|len
op_ne
l_int|2
)paren
op_logical_or
(paren
id|pfindData
op_member_access_from_pointer
id|FileName
(braket
l_int|0
)braket
op_ne
l_char|&squot;.&squot;
)paren
op_logical_or
(paren
id|pfindData
op_member_access_from_pointer
id|FileName
(braket
l_int|1
)braket
op_ne
l_char|&squot;.&squot;
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|cifs_filldir
c_func
(paren
op_amp
id|qstring
comma
id|pfindData
comma
id|file
comma
id|filldir
comma
id|direntry
)paren
)paren
(brace
multiline_comment|/* do not end search if&n;&t;&t;&t;&t;&t;&t;&t;&t;kernel not ready to take&n;&t;&t;&t;&t;&t;&t;&t;&t;remaining entries yet */
id|reset_resume_key
c_func
(paren
id|file
comma
id|pfindData-&gt;FileName
comma
id|qstring.len
comma
id|Unicode
comma
id|cifs_sb-&gt;local_nls
)paren
suffix:semicolon
id|findParms.EndofSearch
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
id|file-&gt;f_pos
op_increment
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* UnixSearch */
id|pfindDataUnix
op_assign
(paren
id|FILE_UNIX_INFO
op_star
)paren
id|pfindData
suffix:semicolon
r_if
c_cond
(paren
id|Unicode
op_eq
id|TRUE
)paren
id|qstring.len
op_assign
id|cifs_strfromUCS_le
(paren
id|pfindDataUnix-&gt;FileName
comma
(paren
m_wchar_t
op_star
)paren
id|pfindDataUnix-&gt;FileName
comma
id|MAX_PATHCONF
comma
id|cifs_sb-&gt;local_nls
)paren
suffix:semicolon
r_else
id|qstring.len
op_assign
id|strnlen
c_func
(paren
id|pfindDataUnix
op_member_access_from_pointer
id|FileName
comma
id|MAX_PATHCONF
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|qstring.len
op_ne
l_int|1
)paren
op_logical_or
(paren
id|pfindDataUnix
op_member_access_from_pointer
id|FileName
(braket
l_int|0
)braket
op_ne
l_char|&squot;.&squot;
)paren
)paren
op_logical_and
(paren
(paren
id|qstring.len
op_ne
l_int|2
)paren
op_logical_or
(paren
id|pfindDataUnix
op_member_access_from_pointer
id|FileName
(braket
l_int|0
)braket
op_ne
l_char|&squot;.&squot;
)paren
op_logical_or
(paren
id|pfindDataUnix
op_member_access_from_pointer
id|FileName
(braket
l_int|1
)braket
op_ne
l_char|&squot;.&squot;
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|cifs_filldir_unix
c_func
(paren
op_amp
id|qstring
comma
id|pfindDataUnix
comma
id|file
comma
id|filldir
comma
id|direntry
)paren
)paren
(brace
multiline_comment|/* do not end search if&n;&t;&t;&t;&t;&t;&t;&t;&t;kernel not ready to take&n;&t;&t;&t;&t;&t;&t;&t;&t;remaining entries yet */
id|findParms.EndofSearch
op_assign
l_int|0
suffix:semicolon
id|reset_resume_key
c_func
(paren
id|file
comma
id|pfindDataUnix-&gt;FileName
comma
id|qstring.len
comma
id|Unicode
comma
id|cifs_sb-&gt;local_nls
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|file-&gt;f_pos
op_increment
suffix:semicolon
)brace
)brace
multiline_comment|/* works also for Unix ff struct since first field of both */
id|pfindData
op_assign
(paren
id|FILE_DIRECTORY_INFO
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|pfindData
op_plus
id|le32_to_cpu
c_func
(paren
id|pfindData-&gt;NextEntryOffset
)paren
)paren
suffix:semicolon
multiline_comment|/* BB also should check to make sure that pointer is not beyond the end of the SMB */
multiline_comment|/* if(pfindData &gt; lastFindData) rc = -EIO; break; */
)brace
multiline_comment|/* end for loop */
r_if
c_cond
(paren
(paren
id|findParms.EndofSearch
op_ne
l_int|0
)paren
op_logical_and
id|cifsFile
)paren
(brace
id|cifsFile-&gt;srch_inf.endOfSearch
op_assign
id|TRUE
suffix:semicolon
r_if
c_cond
(paren
id|findParms.SearchCount
op_eq
id|cpu_to_le16
c_func
(paren
l_int|2
)paren
)paren
(brace
id|cifsFile-&gt;srch_inf.emptyDir
op_assign
id|TRUE
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|cifsFile
)paren
id|cifsFile-&gt;srch_inf.endOfSearch
op_assign
id|TRUE
suffix:semicolon
multiline_comment|/* unless parent directory gone do not return error */
id|rc
op_assign
l_int|0
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
r_if
c_cond
(paren
id|file-&gt;private_data
op_eq
l_int|NULL
)paren
(brace
id|rc
op_assign
op_minus
id|EBADF
suffix:semicolon
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;Readdir on closed srch, pos = %lld&quot;
comma
id|file-&gt;f_pos
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|cifsFile
op_assign
(paren
r_struct
id|cifsFileInfo
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
r_if
c_cond
(paren
id|cifsFile-&gt;srch_inf.endOfSearch
)paren
(brace
id|rc
op_assign
l_int|0
suffix:semicolon
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;End of search &quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|searchHandle
op_assign
id|cifsFile-&gt;netfid
suffix:semicolon
id|rc
op_assign
id|CIFSFindNext
c_func
(paren
id|xid
comma
id|pTcon
comma
id|pfindData
comma
op_amp
id|findNextParms
comma
id|searchHandle
comma
id|cifsFile-&gt;search_resume_name
comma
id|cifsFile-&gt;resume_name_length
comma
id|cifsFile-&gt;srch_inf.resume_key
comma
op_amp
id|Unicode
comma
op_amp
id|UnixSearch
)paren
suffix:semicolon
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;Count: %d  End: %d &quot;
comma
id|le16_to_cpu
c_func
(paren
id|findNextParms.SearchCount
)paren
comma
id|le16_to_cpu
c_func
(paren
id|findNextParms.EndofSearch
)paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rc
op_eq
l_int|0
)paren
op_logical_and
(paren
id|findNextParms.SearchCount
op_ne
l_int|0
)paren
)paren
(brace
multiline_comment|/* BB save off resume key, key name and name length  */
id|__u16
id|count
op_assign
id|le16_to_cpu
c_func
(paren
id|findNextParms.SearchCount
)paren
suffix:semicolon
id|lastFindData
op_assign
(paren
id|FILE_DIRECTORY_INFO
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|pfindData
op_plus
id|le16_to_cpu
c_func
(paren
id|findNextParms.LastNameOffset
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
r_char
op_star
)paren
id|lastFindData
OG
(paren
r_char
op_star
)paren
id|pfindData
op_plus
id|bufsize
)paren
(brace
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;last search entry past end of packet&quot;
)paren
)paren
suffix:semicolon
id|rc
op_assign
op_minus
id|EIO
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Offset of resume key same for levels 257 and 514 */
id|cifsFile-&gt;srch_inf.resume_key
op_assign
id|lastFindData-&gt;FileIndex
suffix:semicolon
r_if
c_cond
(paren
id|UnixSearch
op_eq
id|FALSE
)paren
(brace
id|cifsFile-&gt;resume_name_length
op_assign
id|le32_to_cpu
c_func
(paren
id|lastFindData-&gt;FileNameLength
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cifsFile-&gt;resume_name_length
OG
id|bufsize
op_minus
l_int|64
)paren
(brace
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;Illegal resume file name length %d&quot;
comma
id|cifsFile-&gt;resume_name_length
)paren
)paren
suffix:semicolon
id|rc
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Free the memory allocated by previous findfirst &n;&t;&t;&t;&t;&t;or findnext call - we can not reuse the memory since&n;&t;&t;&t;&t;&t;the resume name may not be same string length */
r_if
c_cond
(paren
id|cifsFile-&gt;search_resume_name
)paren
(brace
id|kfree
c_func
(paren
id|cifsFile-&gt;search_resume_name
)paren
suffix:semicolon
)brace
id|cifsFile-&gt;search_resume_name
op_assign
id|kmalloc
c_func
(paren
id|cifsFile-&gt;resume_name_length
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;Last file: %s with name %d bytes long&quot;
comma
id|lastFindData-&gt;FileName
comma
id|cifsFile-&gt;resume_name_length
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cifsFile-&gt;search_resume_name
op_eq
l_int|NULL
)paren
(brace
id|rc
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_break
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|cifsFile-&gt;search_resume_name
comma
id|lastFindData-&gt;FileName
comma
id|cifsFile-&gt;resume_name_length
)paren
suffix:semicolon
)brace
r_else
(brace
id|pfindDataUnix
op_assign
(paren
id|FILE_UNIX_INFO
op_star
)paren
id|lastFindData
suffix:semicolon
r_if
c_cond
(paren
id|Unicode
op_eq
id|TRUE
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
(paren
id|pfindDataUnix-&gt;FileName
(braket
id|i
)braket
op_or
id|pfindDataUnix-&gt;FileName
(braket
id|i
op_plus
l_int|1
)braket
)paren
suffix:semicolon
id|i
op_add_assign
l_int|2
)paren
(brace
r_if
c_cond
(paren
id|i
OG
id|bufsize
op_minus
l_int|64
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
id|cifsFile-&gt;resume_name_length
op_assign
id|i
op_plus
l_int|2
suffix:semicolon
)brace
r_else
(brace
id|cifsFile-&gt;resume_name_length
op_assign
id|strnlen
c_func
(paren
id|pfindDataUnix
op_member_access_from_pointer
id|FileName
comma
id|MAX_PATHCONF
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cifsFile-&gt;resume_name_length
OG
id|bufsize
op_minus
l_int|64
)paren
(brace
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;Illegal resume file name length %d&quot;
comma
id|cifsFile-&gt;resume_name_length
)paren
)paren
suffix:semicolon
id|rc
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Free the memory allocated by previous findfirst &n;&t;&t;&t;&t;&t;or findnext call - we can not reuse the memory since&n;&t;&t;&t;&t;&t;the resume name may not be same string length */
r_if
c_cond
(paren
id|cifsFile-&gt;search_resume_name
)paren
(brace
id|kfree
c_func
(paren
id|cifsFile-&gt;search_resume_name
)paren
suffix:semicolon
)brace
id|cifsFile-&gt;search_resume_name
op_assign
id|kmalloc
c_func
(paren
id|cifsFile-&gt;resume_name_length
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;fnext last file: %s with name %d bytes long&quot;
comma
id|pfindDataUnix-&gt;FileName
comma
id|cifsFile-&gt;resume_name_length
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cifsFile-&gt;search_resume_name
op_eq
l_int|NULL
)paren
(brace
id|rc
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_break
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|cifsFile-&gt;search_resume_name
comma
id|pfindDataUnix-&gt;FileName
comma
id|cifsFile-&gt;resume_name_length
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|count
suffix:semicolon
id|i
op_increment
)paren
(brace
id|__u32
id|len
op_assign
id|le32_to_cpu
c_func
(paren
id|pfindData
op_member_access_from_pointer
id|FileNameLength
)paren
suffix:semicolon
r_if
c_cond
(paren
id|UnixSearch
op_eq
id|FALSE
)paren
(brace
r_if
c_cond
(paren
id|Unicode
op_eq
id|TRUE
)paren
id|len
op_assign
id|cifs_strfromUCS_le
(paren
id|pfindData-&gt;FileName
comma
(paren
m_wchar_t
op_star
)paren
id|pfindData-&gt;FileName
comma
id|len
op_div
l_int|2
comma
id|cifs_sb-&gt;local_nls
)paren
suffix:semicolon
id|qstring.len
op_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|len
op_ne
l_int|1
)paren
op_logical_or
(paren
id|pfindData-&gt;FileName
(braket
l_int|0
)braket
op_ne
l_char|&squot;.&squot;
)paren
)paren
op_logical_and
(paren
(paren
id|len
op_ne
l_int|2
)paren
op_logical_or
(paren
id|pfindData-&gt;FileName
(braket
l_int|0
)braket
op_ne
l_char|&squot;.&squot;
)paren
op_logical_or
(paren
id|pfindData-&gt;FileName
(braket
l_int|1
)braket
op_ne
l_char|&squot;.&squot;
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|cifs_filldir
(paren
op_amp
id|qstring
comma
id|pfindData
comma
id|file
comma
id|filldir
comma
id|direntry
)paren
)paren
(brace
multiline_comment|/* do not end search if&n;&t;&t;&t;&t;&t;&t;&t;&t;kernel not ready to take&n;&t;&t;&t;&t;&t;&t;&t;&t;remaining entries yet */
id|findNextParms.EndofSearch
op_assign
l_int|0
suffix:semicolon
id|reset_resume_key
c_func
(paren
id|file
comma
id|pfindData-&gt;FileName
comma
id|qstring.len
comma
id|Unicode
comma
id|cifs_sb-&gt;local_nls
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|file-&gt;f_pos
op_increment
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* UnixSearch */
id|pfindDataUnix
op_assign
(paren
id|FILE_UNIX_INFO
op_star
)paren
id|pfindData
suffix:semicolon
r_if
c_cond
(paren
id|Unicode
op_eq
id|TRUE
)paren
id|qstring.len
op_assign
id|cifs_strfromUCS_le
(paren
id|pfindDataUnix-&gt;FileName
comma
(paren
m_wchar_t
op_star
)paren
id|pfindDataUnix-&gt;FileName
comma
id|MAX_PATHCONF
comma
id|cifs_sb-&gt;local_nls
)paren
suffix:semicolon
r_else
id|qstring.len
op_assign
id|strnlen
(paren
id|pfindDataUnix
op_member_access_from_pointer
id|FileName
comma
id|MAX_PATHCONF
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|qstring.len
op_ne
l_int|1
)paren
op_logical_or
(paren
id|pfindDataUnix
op_member_access_from_pointer
id|FileName
(braket
l_int|0
)braket
op_ne
l_char|&squot;.&squot;
)paren
)paren
op_logical_and
(paren
(paren
id|qstring.len
op_ne
l_int|2
)paren
op_logical_or
(paren
id|pfindDataUnix
op_member_access_from_pointer
id|FileName
(braket
l_int|0
)braket
op_ne
l_char|&squot;.&squot;
)paren
op_logical_or
(paren
id|pfindDataUnix
op_member_access_from_pointer
id|FileName
(braket
l_int|1
)braket
op_ne
l_char|&squot;.&squot;
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|cifs_filldir_unix
(paren
op_amp
id|qstring
comma
id|pfindDataUnix
comma
id|file
comma
id|filldir
comma
id|direntry
)paren
)paren
(brace
multiline_comment|/* do not end search if&n;&t;&t;&t;&t;&t;&t;&t;&t;kernel not ready to take&n;&t;&t;&t;&t;&t;&t;&t;&t;remaining entries yet */
id|findNextParms.EndofSearch
op_assign
l_int|0
suffix:semicolon
id|reset_resume_key
c_func
(paren
id|file
comma
id|pfindDataUnix-&gt;FileName
comma
id|qstring.len
comma
id|Unicode
comma
id|cifs_sb-&gt;local_nls
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|file-&gt;f_pos
op_increment
suffix:semicolon
)brace
)brace
id|pfindData
op_assign
(paren
id|FILE_DIRECTORY_INFO
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|pfindData
op_plus
id|le32_to_cpu
c_func
(paren
id|pfindData-&gt;NextEntryOffset
)paren
)paren
suffix:semicolon
multiline_comment|/* works also for Unix find struct since first field of both */
multiline_comment|/* BB also should check to ensure pointer not beyond end of SMB */
)brace
multiline_comment|/* end for loop */
r_if
c_cond
(paren
id|findNextParms.EndofSearch
op_ne
l_int|0
)paren
(brace
id|cifsFile-&gt;srch_inf.endOfSearch
op_assign
id|TRUE
suffix:semicolon
)brace
)brace
r_else
(brace
id|cifsFile-&gt;srch_inf.endOfSearch
op_assign
id|TRUE
suffix:semicolon
id|rc
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* unless parent directory disappeared - do not&n;&t;&t;&t;&t;return error here (eg Access Denied or no more files) */
)brace
)brace
)brace
multiline_comment|/* end switch */
r_if
c_cond
(paren
id|data
)paren
id|kfree
c_func
(paren
id|data
)paren
suffix:semicolon
r_if
c_cond
(paren
id|full_path
)paren
id|kfree
c_func
(paren
id|full_path
)paren
suffix:semicolon
id|FreeXid
c_func
(paren
id|xid
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
DECL|function|cifs_prepare_write
r_int
id|cifs_prepare_write
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_struct
id|page
op_star
id|page
comma
r_int
id|from
comma
r_int
id|to
)paren
(brace
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
id|loff_t
id|offset
op_assign
(paren
id|loff_t
)paren
id|page-&gt;index
op_lshift
id|PAGE_CACHE_SHIFT
suffix:semicolon
id|cFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;prepare write for page %p from %d to %d&quot;
comma
id|page
comma
id|from
comma
id|to
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|PageUptodate
c_func
(paren
id|page
)paren
)paren
(brace
multiline_comment|/*&t;if (to - from != PAGE_CACHE_SIZE) {&n;&t;&t;&t;void *kaddr = kmap_atomic(page, KM_USER0);&n;&t;&t;&t;memset(kaddr, 0, from);&n;&t;&t;&t;memset(kaddr + to, 0, PAGE_CACHE_SIZE - to);&n;&t;&t;&t;flush_dcache_page(page);&n;&t;&t;&t;kunmap_atomic(kaddr, KM_USER0);&n;&t;&t;} */
multiline_comment|/* If we are writing a full page it will be up to date,&n;&t;&t;no need to read from the server */
r_if
c_cond
(paren
(paren
id|to
op_eq
id|PAGE_CACHE_SIZE
)paren
op_logical_and
(paren
id|from
op_eq
l_int|0
)paren
)paren
(brace
id|SetPageUptodate
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
multiline_comment|/* might as well read a page, it is fast enough */
r_if
c_cond
(paren
(paren
id|file-&gt;f_flags
op_amp
id|O_ACCMODE
)paren
op_ne
id|O_WRONLY
)paren
(brace
id|rc
op_assign
id|cifs_readpage_worker
c_func
(paren
id|file
comma
id|page
comma
op_amp
id|offset
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* should we try using another&n;&t;&t;file handle if there is one - how would we lock it&n;&t;&t;to prevent close of that handle racing with this read? */
multiline_comment|/* In any case this will be written out by commit_write */
)brace
)brace
multiline_comment|/* BB should we pass any errors back? e.g. if we do not have read access to the file */
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|cifs_addr_ops
r_struct
id|address_space_operations
id|cifs_addr_ops
op_assign
(brace
dot
id|readpage
op_assign
id|cifs_readpage
comma
dot
id|readpages
op_assign
id|cifs_readpages
comma
dot
id|writepage
op_assign
id|cifs_writepage
comma
dot
id|prepare_write
op_assign
id|cifs_prepare_write
comma
dot
id|commit_write
op_assign
id|cifs_commit_write
comma
dot
id|set_page_dirty
op_assign
id|__set_page_dirty_nobuffers
comma
multiline_comment|/* .sync_page = cifs_sync_page, */
multiline_comment|/*.direct_IO = */
)brace
suffix:semicolon
eof
