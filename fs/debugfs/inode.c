multiline_comment|/*&n; *  file.c - part of debugfs, a tiny little debug file system&n; *&n; *  Copyright (C) 2004 Greg Kroah-Hartman &lt;greg@kroah.com&gt;&n; *  Copyright (C) 2004 IBM Inc.&n; *&n; *&t;This program is free software; you can redistribute it and/or&n; *&t;modify it under the terms of the GNU General Public License version&n; *&t;2 as published by the Free Software Foundation.&n; *&n; *  debugfs is for people to use instead of /proc or /sys.&n; *  See Documentation/DocBook/kernel-api for more details.&n; *&n; */
multiline_comment|/* uncomment to get debug messages from the debug filesystem, ah the irony. */
multiline_comment|/* #define DEBUG */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/mount.h&gt;
macro_line|#include &lt;linux/pagemap.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/namei.h&gt;
macro_line|#include &lt;linux/debugfs.h&gt;
DECL|macro|DEBUGFS_MAGIC
mdefine_line|#define DEBUGFS_MAGIC&t;0x64626720
multiline_comment|/* declared over in file.c */
r_extern
r_struct
id|file_operations
id|debugfs_file_operations
suffix:semicolon
DECL|variable|debugfs_mount
r_static
r_struct
id|vfsmount
op_star
id|debugfs_mount
suffix:semicolon
DECL|variable|debugfs_mount_count
r_static
r_int
id|debugfs_mount_count
suffix:semicolon
DECL|function|debugfs_get_inode
r_static
r_struct
id|inode
op_star
id|debugfs_get_inode
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_int
id|mode
comma
id|dev_t
id|dev
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|new_inode
c_func
(paren
id|sb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inode
)paren
(brace
id|inode-&gt;i_mode
op_assign
id|mode
suffix:semicolon
id|inode-&gt;i_uid
op_assign
l_int|0
suffix:semicolon
id|inode-&gt;i_gid
op_assign
l_int|0
suffix:semicolon
id|inode-&gt;i_blksize
op_assign
id|PAGE_CACHE_SIZE
suffix:semicolon
id|inode-&gt;i_blocks
op_assign
l_int|0
suffix:semicolon
id|inode-&gt;i_atime
op_assign
id|inode-&gt;i_mtime
op_assign
id|inode-&gt;i_ctime
op_assign
id|CURRENT_TIME
suffix:semicolon
r_switch
c_cond
(paren
id|mode
op_amp
id|S_IFMT
)paren
(brace
r_default
suffix:colon
id|init_special_inode
c_func
(paren
id|inode
comma
id|mode
comma
id|dev
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|S_IFREG
suffix:colon
id|inode-&gt;i_fop
op_assign
op_amp
id|debugfs_file_operations
suffix:semicolon
r_break
suffix:semicolon
r_case
id|S_IFDIR
suffix:colon
id|inode-&gt;i_op
op_assign
op_amp
id|simple_dir_inode_operations
suffix:semicolon
id|inode-&gt;i_fop
op_assign
op_amp
id|simple_dir_operations
suffix:semicolon
multiline_comment|/* directory inodes start off with i_nlink == 2 (for &quot;.&quot; entry) */
id|inode-&gt;i_nlink
op_increment
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_return
id|inode
suffix:semicolon
)brace
multiline_comment|/* SMP-safe */
DECL|function|debugfs_mknod
r_static
r_int
id|debugfs_mknod
c_func
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|dentry
op_star
id|dentry
comma
r_int
id|mode
comma
id|dev_t
id|dev
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|debugfs_get_inode
c_func
(paren
id|dir-&gt;i_sb
comma
id|mode
comma
id|dev
)paren
suffix:semicolon
r_int
id|error
op_assign
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|dentry-&gt;d_inode
)paren
r_return
op_minus
id|EEXIST
suffix:semicolon
r_if
c_cond
(paren
id|inode
)paren
(brace
id|d_instantiate
c_func
(paren
id|dentry
comma
id|inode
)paren
suffix:semicolon
id|dget
c_func
(paren
id|dentry
)paren
suffix:semicolon
id|error
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|error
suffix:semicolon
)brace
DECL|function|debugfs_mkdir
r_static
r_int
id|debugfs_mkdir
c_func
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|dentry
op_star
id|dentry
comma
r_int
id|mode
)paren
(brace
r_int
id|res
suffix:semicolon
id|mode
op_assign
(paren
id|mode
op_amp
(paren
id|S_IRWXUGO
op_or
id|S_ISVTX
)paren
)paren
op_or
id|S_IFDIR
suffix:semicolon
id|res
op_assign
id|debugfs_mknod
c_func
(paren
id|dir
comma
id|dentry
comma
id|mode
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|res
)paren
id|dir-&gt;i_nlink
op_increment
suffix:semicolon
r_return
id|res
suffix:semicolon
)brace
DECL|function|debugfs_create
r_static
r_int
id|debugfs_create
c_func
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|dentry
op_star
id|dentry
comma
r_int
id|mode
)paren
(brace
id|mode
op_assign
(paren
id|mode
op_amp
id|S_IALLUGO
)paren
op_or
id|S_IFREG
suffix:semicolon
r_return
id|debugfs_mknod
c_func
(paren
id|dir
comma
id|dentry
comma
id|mode
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|debugfs_positive
r_static
r_inline
r_int
id|debugfs_positive
c_func
(paren
r_struct
id|dentry
op_star
id|dentry
)paren
(brace
r_return
id|dentry-&gt;d_inode
op_logical_and
op_logical_neg
id|d_unhashed
c_func
(paren
id|dentry
)paren
suffix:semicolon
)brace
DECL|function|debug_fill_super
r_static
r_int
id|debug_fill_super
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_void
op_star
id|data
comma
r_int
id|silent
)paren
(brace
r_static
r_struct
id|tree_descr
id|debug_files
(braket
)braket
op_assign
(brace
(brace
l_string|&quot;&quot;
)brace
)brace
suffix:semicolon
r_return
id|simple_fill_super
c_func
(paren
id|sb
comma
id|DEBUGFS_MAGIC
comma
id|debug_files
)paren
suffix:semicolon
)brace
DECL|function|get_dentry
r_static
r_struct
id|dentry
op_star
id|get_dentry
c_func
(paren
r_struct
id|dentry
op_star
id|parent
comma
r_const
r_char
op_star
id|name
)paren
(brace
r_struct
id|qstr
id|qstr
suffix:semicolon
id|qstr.name
op_assign
id|name
suffix:semicolon
id|qstr.len
op_assign
id|strlen
c_func
(paren
id|name
)paren
suffix:semicolon
id|qstr.hash
op_assign
id|full_name_hash
c_func
(paren
id|name
comma
id|qstr.len
)paren
suffix:semicolon
r_return
id|lookup_hash
c_func
(paren
op_amp
id|qstr
comma
id|parent
)paren
suffix:semicolon
)brace
DECL|function|debug_get_sb
r_static
r_struct
id|super_block
op_star
id|debug_get_sb
c_func
(paren
r_struct
id|file_system_type
op_star
id|fs_type
comma
r_int
id|flags
comma
r_const
r_char
op_star
id|dev_name
comma
r_void
op_star
id|data
)paren
(brace
r_return
id|get_sb_single
c_func
(paren
id|fs_type
comma
id|flags
comma
id|data
comma
id|debug_fill_super
)paren
suffix:semicolon
)brace
DECL|variable|debug_fs_type
r_static
r_struct
id|file_system_type
id|debug_fs_type
op_assign
(brace
dot
id|owner
op_assign
id|THIS_MODULE
comma
dot
id|name
op_assign
l_string|&quot;debugfs&quot;
comma
dot
id|get_sb
op_assign
id|debug_get_sb
comma
dot
id|kill_sb
op_assign
id|kill_litter_super
comma
)brace
suffix:semicolon
DECL|function|debugfs_create_by_name
r_static
r_int
id|debugfs_create_by_name
c_func
(paren
r_const
r_char
op_star
id|name
comma
id|mode_t
id|mode
comma
r_struct
id|dentry
op_star
id|parent
comma
r_struct
id|dentry
op_star
op_star
id|dentry
)paren
(brace
r_int
id|error
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* If the parent is not specified, we create it in the root.&n;&t; * We need the root dentry to do this, which is in the super &n;&t; * block. A pointer to that is in the struct vfsmount that we&n;&t; * have around.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|parent
)paren
(brace
r_if
c_cond
(paren
id|debugfs_mount
op_logical_and
id|debugfs_mount-&gt;mnt_sb
)paren
(brace
id|parent
op_assign
id|debugfs_mount-&gt;mnt_sb-&gt;s_root
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|parent
)paren
(brace
id|pr_debug
c_func
(paren
l_string|&quot;debugfs: Ah! can not find a parent!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
op_star
id|dentry
op_assign
l_int|NULL
suffix:semicolon
id|down
c_func
(paren
op_amp
id|parent-&gt;d_inode-&gt;i_sem
)paren
suffix:semicolon
op_star
id|dentry
op_assign
id|get_dentry
(paren
id|parent
comma
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|IS_ERR
c_func
(paren
id|dentry
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|mode
op_amp
id|S_IFMT
)paren
op_eq
id|S_IFDIR
)paren
id|error
op_assign
id|debugfs_mkdir
c_func
(paren
id|parent-&gt;d_inode
comma
op_star
id|dentry
comma
id|mode
)paren
suffix:semicolon
r_else
id|error
op_assign
id|debugfs_create
c_func
(paren
id|parent-&gt;d_inode
comma
op_star
id|dentry
comma
id|mode
)paren
suffix:semicolon
)brace
r_else
id|error
op_assign
id|PTR_ERR
c_func
(paren
id|dentry
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|parent-&gt;d_inode-&gt;i_sem
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/**&n; * debugfs_create_file - create a file in the debugfs filesystem&n; *&n; * @name: a pointer to a string containing the name of the file to create.&n; * @mode: the permission that the file should have&n; * @parent: a pointer to the parent dentry for this file.  This should be a&n; *          directory dentry if set.  If this paramater is NULL, then the&n; *          file will be created in the root of the debugfs filesystem.&n; * @data: a pointer to something that the caller will want to get to later&n; *        on.  The inode.u.generic_ip pointer will point to this value on&n; *        the open() call.&n; * @fops: a pointer to a struct file_operations that should be used for&n; *        this file.&n; *&n; * This is the basic &quot;create a file&quot; function for debugfs.  It allows for a&n; * wide range of flexibility in createing a file, or a directory (if you&n; * want to create a directory, the debugfs_create_dir() function is&n; * recommended to be used instead.)&n; *&n; * This function will return a pointer to a dentry if it succeeds.  This&n; * pointer must be passed to the debugfs_remove() function when the file is&n; * to be removed (no automatic cleanup happens if your module is unloaded,&n; * you are responsible here.)  If an error occurs, NULL will be returned.&n; *&n; * If debugfs is not enabled in the kernel, the value -ENODEV will be&n; * returned.  It is not wise to check for this value, but rather, check for&n; * NULL or !NULL instead as to eliminate the need for #ifdef in the calling&n; * code.&n; */
DECL|function|debugfs_create_file
r_struct
id|dentry
op_star
id|debugfs_create_file
c_func
(paren
r_const
r_char
op_star
id|name
comma
id|mode_t
id|mode
comma
r_struct
id|dentry
op_star
id|parent
comma
r_void
op_star
id|data
comma
r_struct
id|file_operations
op_star
id|fops
)paren
(brace
r_struct
id|dentry
op_star
id|dentry
op_assign
l_int|NULL
suffix:semicolon
r_int
id|error
suffix:semicolon
id|pr_debug
c_func
(paren
l_string|&quot;debugfs: creating file &squot;%s&squot;&bslash;n&quot;
comma
id|name
)paren
suffix:semicolon
id|error
op_assign
id|simple_pin_fs
c_func
(paren
l_string|&quot;debugfs&quot;
comma
op_amp
id|debugfs_mount
comma
op_amp
id|debugfs_mount_count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
m_exit
suffix:semicolon
id|error
op_assign
id|debugfs_create_by_name
c_func
(paren
id|name
comma
id|mode
comma
id|parent
comma
op_amp
id|dentry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|dentry
op_assign
l_int|NULL
suffix:semicolon
r_goto
m_exit
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dentry-&gt;d_inode
)paren
(brace
r_if
c_cond
(paren
id|data
)paren
id|dentry-&gt;d_inode-&gt;u.generic_ip
op_assign
id|data
suffix:semicolon
r_if
c_cond
(paren
id|fops
)paren
id|dentry-&gt;d_inode-&gt;i_fop
op_assign
id|fops
suffix:semicolon
)brace
m_exit
suffix:colon
r_return
id|dentry
suffix:semicolon
)brace
DECL|variable|debugfs_create_file
id|EXPORT_SYMBOL_GPL
c_func
(paren
id|debugfs_create_file
)paren
suffix:semicolon
multiline_comment|/**&n; * debugfs_create_dir - create a directory in the debugfs filesystem&n; *&n; * @name: a pointer to a string containing the name of the directory to&n; *        create.&n; * @parent: a pointer to the parent dentry for this file.  This should be a&n; *          directory dentry if set.  If this paramater is NULL, then the&n; *          directory will be created in the root of the debugfs filesystem.&n; *&n; * This function creates a directory in debugfs with the given name.&n; *&n; * This function will return a pointer to a dentry if it succeeds.  This&n; * pointer must be passed to the debugfs_remove() function when the file is&n; * to be removed (no automatic cleanup happens if your module is unloaded,&n; * you are responsible here.)  If an error occurs, NULL will be returned.&n; *&n; * If debugfs is not enabled in the kernel, the value -ENODEV will be&n; * returned.  It is not wise to check for this value, but rather, check for&n; * NULL or !NULL instead as to eliminate the need for #ifdef in the calling&n; * code.&n; */
DECL|function|debugfs_create_dir
r_struct
id|dentry
op_star
id|debugfs_create_dir
c_func
(paren
r_const
r_char
op_star
id|name
comma
r_struct
id|dentry
op_star
id|parent
)paren
(brace
r_return
id|debugfs_create_file
c_func
(paren
id|name
comma
id|S_IFDIR
op_or
id|S_IRWXU
op_or
id|S_IRUGO
op_or
id|S_IXUGO
comma
id|parent
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
)brace
DECL|variable|debugfs_create_dir
id|EXPORT_SYMBOL_GPL
c_func
(paren
id|debugfs_create_dir
)paren
suffix:semicolon
multiline_comment|/**&n; * debugfs_remove - removes a file or directory from the debugfs filesystem&n; *&n; * @dentry: a pointer to a the dentry of the file or directory to be&n; *          removed.&n; *&n; * This function removes a file or directory in debugfs that was previously&n; * created with a call to another debugfs function (like&n; * debufs_create_file() or variants thereof.)&n; *&n; * This function is required to be called in order for the file to be&n; * removed, no automatic cleanup of files will happen when a module is&n; * removed, you are responsible here.&n; */
DECL|function|debugfs_remove
r_void
id|debugfs_remove
c_func
(paren
r_struct
id|dentry
op_star
id|dentry
)paren
(brace
r_struct
id|dentry
op_star
id|parent
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dentry
)paren
r_return
suffix:semicolon
id|parent
op_assign
id|dentry-&gt;d_parent
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|parent
op_logical_or
op_logical_neg
id|parent-&gt;d_inode
)paren
r_return
suffix:semicolon
id|down
c_func
(paren
op_amp
id|parent-&gt;d_inode-&gt;i_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|debugfs_positive
c_func
(paren
id|dentry
)paren
)paren
(brace
r_if
c_cond
(paren
id|dentry-&gt;d_inode
)paren
(brace
r_if
c_cond
(paren
id|S_ISDIR
c_func
(paren
id|dentry-&gt;d_inode-&gt;i_mode
)paren
)paren
id|simple_rmdir
c_func
(paren
id|parent-&gt;d_inode
comma
id|dentry
)paren
suffix:semicolon
r_else
id|simple_unlink
c_func
(paren
id|parent-&gt;d_inode
comma
id|dentry
)paren
suffix:semicolon
id|dput
c_func
(paren
id|dentry
)paren
suffix:semicolon
)brace
)brace
id|up
c_func
(paren
op_amp
id|parent-&gt;d_inode-&gt;i_sem
)paren
suffix:semicolon
id|simple_release_fs
c_func
(paren
op_amp
id|debugfs_mount
comma
op_amp
id|debugfs_mount_count
)paren
suffix:semicolon
)brace
DECL|variable|debugfs_remove
id|EXPORT_SYMBOL_GPL
c_func
(paren
id|debugfs_remove
)paren
suffix:semicolon
r_static
id|decl_subsys
c_func
(paren
id|debug
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
DECL|function|debugfs_init
r_static
r_int
id|__init
id|debugfs_init
c_func
(paren
r_void
)paren
(brace
r_int
id|retval
suffix:semicolon
id|kset_set_kset_s
c_func
(paren
op_amp
id|debug_subsys
comma
id|kernel_subsys
)paren
suffix:semicolon
id|retval
op_assign
id|subsystem_register
c_func
(paren
op_amp
id|debug_subsys
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_return
id|retval
suffix:semicolon
id|retval
op_assign
id|register_filesystem
c_func
(paren
op_amp
id|debug_fs_type
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
id|subsystem_unregister
c_func
(paren
op_amp
id|debug_subsys
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
DECL|function|debugfs_exit
r_static
r_void
id|__exit
id|debugfs_exit
c_func
(paren
r_void
)paren
(brace
id|simple_release_fs
c_func
(paren
op_amp
id|debugfs_mount
comma
op_amp
id|debugfs_mount_count
)paren
suffix:semicolon
id|unregister_filesystem
c_func
(paren
op_amp
id|debug_fs_type
)paren
suffix:semicolon
id|subsystem_unregister
c_func
(paren
op_amp
id|debug_subsys
)paren
suffix:semicolon
)brace
DECL|variable|debugfs_init
id|core_initcall
c_func
(paren
id|debugfs_init
)paren
suffix:semicolon
DECL|variable|debugfs_exit
id|module_exit
c_func
(paren
id|debugfs_exit
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
eof
