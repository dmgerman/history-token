multiline_comment|/* -*- c -*- --------------------------------------------------------------- *&n; *&n; * linux/fs/autofs/root.c&n; *&n; *  Copyright 1997-1998 Transmeta Corporation -- All Rights Reserved&n; *  Copyright 1999-2000 Jeremy Fitzhardinge &lt;jeremy@goop.org&gt;&n; *  Copyright 2001-2003 Ian Kent &lt;raven@themaw.net&gt;&n; *&n; * This file is part of the Linux kernel and is made available under&n; * the terms of the GNU General Public License, version 2, or at your&n; * option, any later version, incorporated herein by reference.&n; *&n; * ------------------------------------------------------------------------- */
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/stat.h&gt;
macro_line|#include &lt;linux/param.h&gt;
macro_line|#include &lt;linux/time.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &quot;autofs_i.h&quot;
r_static
r_int
id|autofs4_dir_symlink
c_func
(paren
r_struct
id|inode
op_star
comma
r_struct
id|dentry
op_star
comma
r_const
r_char
op_star
)paren
suffix:semicolon
r_static
r_int
id|autofs4_dir_unlink
c_func
(paren
r_struct
id|inode
op_star
comma
r_struct
id|dentry
op_star
)paren
suffix:semicolon
r_static
r_int
id|autofs4_dir_rmdir
c_func
(paren
r_struct
id|inode
op_star
comma
r_struct
id|dentry
op_star
)paren
suffix:semicolon
r_static
r_int
id|autofs4_dir_mkdir
c_func
(paren
r_struct
id|inode
op_star
comma
r_struct
id|dentry
op_star
comma
r_int
)paren
suffix:semicolon
r_static
r_int
id|autofs4_root_ioctl
c_func
(paren
r_struct
id|inode
op_star
comma
r_struct
id|file
op_star
comma
r_int
r_int
comma
r_int
r_int
)paren
suffix:semicolon
r_static
r_int
id|autofs4_dir_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
suffix:semicolon
r_static
r_int
id|autofs4_dir_close
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
suffix:semicolon
r_static
r_int
id|autofs4_dir_readdir
c_func
(paren
r_struct
id|file
op_star
id|filp
comma
r_void
op_star
id|dirent
comma
id|filldir_t
id|filldir
)paren
suffix:semicolon
r_static
r_int
id|autofs4_root_readdir
c_func
(paren
r_struct
id|file
op_star
id|filp
comma
r_void
op_star
id|dirent
comma
id|filldir_t
id|filldir
)paren
suffix:semicolon
r_static
r_struct
id|dentry
op_star
id|autofs4_lookup
c_func
(paren
r_struct
id|inode
op_star
comma
r_struct
id|dentry
op_star
comma
r_struct
id|nameidata
op_star
)paren
suffix:semicolon
r_static
r_int
id|autofs4_dcache_readdir
c_func
(paren
r_struct
id|file
op_star
comma
r_void
op_star
comma
id|filldir_t
)paren
suffix:semicolon
DECL|variable|autofs4_root_operations
r_struct
id|file_operations
id|autofs4_root_operations
op_assign
(brace
dot
id|open
op_assign
id|dcache_dir_open
comma
dot
id|release
op_assign
id|dcache_dir_close
comma
dot
id|read
op_assign
id|generic_read_dir
comma
dot
id|readdir
op_assign
id|autofs4_root_readdir
comma
dot
id|ioctl
op_assign
id|autofs4_root_ioctl
comma
)brace
suffix:semicolon
DECL|variable|autofs4_dir_operations
r_struct
id|file_operations
id|autofs4_dir_operations
op_assign
(brace
dot
id|open
op_assign
id|autofs4_dir_open
comma
dot
id|release
op_assign
id|autofs4_dir_close
comma
dot
id|read
op_assign
id|generic_read_dir
comma
dot
id|readdir
op_assign
id|autofs4_dir_readdir
comma
)brace
suffix:semicolon
DECL|variable|autofs4_root_inode_operations
r_struct
id|inode_operations
id|autofs4_root_inode_operations
op_assign
(brace
dot
id|lookup
op_assign
id|autofs4_lookup
comma
dot
id|unlink
op_assign
id|autofs4_dir_unlink
comma
dot
id|symlink
op_assign
id|autofs4_dir_symlink
comma
dot
id|mkdir
op_assign
id|autofs4_dir_mkdir
comma
dot
id|rmdir
op_assign
id|autofs4_dir_rmdir
comma
)brace
suffix:semicolon
DECL|variable|autofs4_dir_inode_operations
r_struct
id|inode_operations
id|autofs4_dir_inode_operations
op_assign
(brace
dot
id|lookup
op_assign
id|autofs4_lookup
comma
dot
id|unlink
op_assign
id|autofs4_dir_unlink
comma
dot
id|symlink
op_assign
id|autofs4_dir_symlink
comma
dot
id|mkdir
op_assign
id|autofs4_dir_mkdir
comma
dot
id|rmdir
op_assign
id|autofs4_dir_rmdir
comma
)brace
suffix:semicolon
DECL|function|autofs4_root_readdir
r_static
r_int
id|autofs4_root_readdir
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_void
op_star
id|dirent
comma
id|filldir_t
id|filldir
)paren
(brace
r_struct
id|autofs_sb_info
op_star
id|sbi
op_assign
id|autofs4_sbi
c_func
(paren
id|file-&gt;f_dentry-&gt;d_sb
)paren
suffix:semicolon
r_int
id|oz_mode
op_assign
id|autofs4_oz_mode
c_func
(paren
id|sbi
)paren
suffix:semicolon
id|DPRINTK
c_func
(paren
l_string|&quot;called, filp-&gt;f_pos = %lld&quot;
comma
id|file-&gt;f_pos
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Don&squot;t set reghost flag if:&n;&t; * 1) f_pos is larger than zero -- we&squot;ve already been here.&n;&t; * 2) we haven&squot;t even enabled reghosting in the 1st place.&n;&t; * 3) this is the daemon doing a readdir&n;&t; */
r_if
c_cond
(paren
id|oz_mode
op_logical_and
id|file-&gt;f_pos
op_eq
l_int|0
op_logical_and
id|sbi-&gt;reghost_enabled
)paren
id|sbi-&gt;needs_reghost
op_assign
l_int|1
suffix:semicolon
id|DPRINTK
c_func
(paren
l_string|&quot;needs_reghost = %d&quot;
comma
id|sbi-&gt;needs_reghost
)paren
suffix:semicolon
r_return
id|autofs4_dcache_readdir
c_func
(paren
id|file
comma
id|dirent
comma
id|filldir
)paren
suffix:semicolon
)brace
multiline_comment|/* Update usage from here to top of tree, so that scan of&n;   top-level directories will give a useful result */
DECL|function|autofs4_update_usage
r_static
r_void
id|autofs4_update_usage
c_func
(paren
r_struct
id|dentry
op_star
id|dentry
)paren
(brace
r_struct
id|dentry
op_star
id|top
op_assign
id|dentry-&gt;d_sb-&gt;s_root
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|dcache_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|dentry
op_ne
id|top
suffix:semicolon
id|dentry
op_assign
id|dentry-&gt;d_parent
)paren
(brace
r_struct
id|autofs_info
op_star
id|ino
op_assign
id|autofs4_dentry_ino
c_func
(paren
id|dentry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ino
)paren
(brace
id|update_atime
c_func
(paren
id|dentry-&gt;d_inode
)paren
suffix:semicolon
id|ino-&gt;last_used
op_assign
id|jiffies
suffix:semicolon
)brace
)brace
id|spin_unlock
c_func
(paren
op_amp
id|dcache_lock
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * From 2.4 kernel readdir.c&n; */
DECL|function|autofs4_dcache_readdir
r_static
r_int
id|autofs4_dcache_readdir
c_func
(paren
r_struct
id|file
op_star
id|filp
comma
r_void
op_star
id|dirent
comma
id|filldir_t
id|filldir
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|dentry
op_star
id|dentry
op_assign
id|filp-&gt;f_dentry
suffix:semicolon
id|i
op_assign
id|filp-&gt;f_pos
suffix:semicolon
r_switch
c_cond
(paren
id|i
)paren
(brace
r_case
l_int|0
suffix:colon
r_if
c_cond
(paren
id|filldir
c_func
(paren
id|dirent
comma
l_string|&quot;.&quot;
comma
l_int|1
comma
id|i
comma
id|dentry-&gt;d_inode-&gt;i_ino
comma
id|DT_DIR
)paren
OL
l_int|0
)paren
r_break
suffix:semicolon
id|i
op_increment
suffix:semicolon
id|filp-&gt;f_pos
op_increment
suffix:semicolon
multiline_comment|/* fallthrough */
r_case
l_int|1
suffix:colon
r_if
c_cond
(paren
id|filldir
c_func
(paren
id|dirent
comma
l_string|&quot;..&quot;
comma
l_int|2
comma
id|i
comma
id|dentry-&gt;d_parent-&gt;d_inode-&gt;i_ino
comma
id|DT_DIR
)paren
OL
l_int|0
)paren
r_break
suffix:semicolon
id|i
op_increment
suffix:semicolon
id|filp-&gt;f_pos
op_increment
suffix:semicolon
multiline_comment|/* fallthrough */
r_default
suffix:colon
(brace
)brace
(brace
r_struct
id|list_head
op_star
id|list
suffix:semicolon
r_int
id|j
op_assign
id|i
op_minus
l_int|2
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|dcache_lock
)paren
suffix:semicolon
id|list
op_assign
id|dentry-&gt;d_subdirs.next
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
id|list
op_eq
op_amp
id|dentry-&gt;d_subdirs
)paren
(brace
id|spin_unlock
c_func
(paren
op_amp
id|dcache_lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|j
)paren
r_break
suffix:semicolon
id|j
op_decrement
suffix:semicolon
id|list
op_assign
id|list-&gt;next
suffix:semicolon
)brace
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_struct
id|dentry
op_star
id|de
op_assign
id|list_entry
c_func
(paren
id|list
comma
r_struct
id|dentry
comma
id|d_child
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|d_unhashed
c_func
(paren
id|de
)paren
op_logical_and
id|de-&gt;d_inode
)paren
(brace
id|spin_unlock
c_func
(paren
op_amp
id|dcache_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|filldir
c_func
(paren
id|dirent
comma
id|de-&gt;d_name.name
comma
id|de-&gt;d_name.len
comma
id|filp-&gt;f_pos
comma
id|de-&gt;d_inode-&gt;i_ino
comma
id|DT_UNKNOWN
)paren
OL
l_int|0
)paren
r_break
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|dcache_lock
)paren
suffix:semicolon
)brace
id|filp-&gt;f_pos
op_increment
suffix:semicolon
id|list
op_assign
id|list-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|list
op_ne
op_amp
id|dentry-&gt;d_subdirs
)paren
r_continue
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|dcache_lock
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|autofs4_dir_open
r_static
r_int
id|autofs4_dir_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_struct
id|dentry
op_star
id|dentry
op_assign
id|file-&gt;f_dentry
suffix:semicolon
r_struct
id|vfsmount
op_star
id|mnt
op_assign
id|file-&gt;f_vfsmnt
suffix:semicolon
r_struct
id|autofs_sb_info
op_star
id|sbi
op_assign
id|autofs4_sbi
c_func
(paren
id|dentry-&gt;d_sb
)paren
suffix:semicolon
r_int
id|status
suffix:semicolon
id|DPRINTK
c_func
(paren
l_string|&quot;file=%p dentry=%p %.*s&quot;
comma
id|file
comma
id|dentry
comma
id|dentry-&gt;d_name.len
comma
id|dentry-&gt;d_name.name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|autofs4_oz_mode
c_func
(paren
id|sbi
)paren
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|autofs4_ispending
c_func
(paren
id|dentry
)paren
)paren
(brace
id|DPRINTK
c_func
(paren
l_string|&quot;dentry busy&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|d_mountpoint
c_func
(paren
id|dentry
)paren
op_logical_and
id|dentry-&gt;d_op
op_logical_and
id|dentry-&gt;d_op-&gt;d_revalidate
)paren
(brace
r_struct
id|nameidata
id|nd
suffix:semicolon
r_int
id|empty
suffix:semicolon
multiline_comment|/* In case there are stale directory dentrys from a failed mount */
id|spin_lock
c_func
(paren
op_amp
id|dcache_lock
)paren
suffix:semicolon
id|empty
op_assign
id|list_empty
c_func
(paren
op_amp
id|dentry-&gt;d_subdirs
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|dcache_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|empty
)paren
id|d_invalidate
c_func
(paren
id|dentry
)paren
suffix:semicolon
id|nd.flags
op_assign
id|LOOKUP_DIRECTORY
suffix:semicolon
id|status
op_assign
(paren
id|dentry-&gt;d_op-&gt;d_revalidate
)paren
(paren
id|dentry
comma
op_amp
id|nd
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|status
)paren
r_return
op_minus
id|ENOENT
suffix:semicolon
)brace
r_if
c_cond
(paren
id|d_mountpoint
c_func
(paren
id|dentry
)paren
)paren
(brace
r_struct
id|file
op_star
id|fp
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|vfsmount
op_star
id|fp_mnt
op_assign
id|mntget
c_func
(paren
id|mnt
)paren
suffix:semicolon
r_struct
id|dentry
op_star
id|fp_dentry
op_assign
id|dget
c_func
(paren
id|dentry
)paren
suffix:semicolon
r_while
c_loop
(paren
id|follow_down
c_func
(paren
op_amp
id|fp_mnt
comma
op_amp
id|fp_dentry
)paren
op_logical_and
id|d_mountpoint
c_func
(paren
id|fp_dentry
)paren
)paren
suffix:semicolon
id|fp
op_assign
id|dentry_open
c_func
(paren
id|fp_dentry
comma
id|fp_mnt
comma
id|file-&gt;f_flags
)paren
suffix:semicolon
id|status
op_assign
id|PTR_ERR
c_func
(paren
id|fp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|fp
)paren
)paren
(brace
id|file-&gt;private_data
op_assign
l_int|NULL
suffix:semicolon
r_return
id|status
suffix:semicolon
)brace
id|file-&gt;private_data
op_assign
id|fp
suffix:semicolon
)brace
id|out
suffix:colon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|autofs4_dir_close
r_static
r_int
id|autofs4_dir_close
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_struct
id|dentry
op_star
id|dentry
op_assign
id|file-&gt;f_dentry
suffix:semicolon
r_struct
id|autofs_sb_info
op_star
id|sbi
op_assign
id|autofs4_sbi
c_func
(paren
id|dentry-&gt;d_sb
)paren
suffix:semicolon
id|DPRINTK
c_func
(paren
l_string|&quot;file=%p dentry=%p %.*s&quot;
comma
id|file
comma
id|dentry
comma
id|dentry-&gt;d_name.len
comma
id|dentry-&gt;d_name.name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|autofs4_oz_mode
c_func
(paren
id|sbi
)paren
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|autofs4_ispending
c_func
(paren
id|dentry
)paren
)paren
(brace
id|DPRINTK
c_func
(paren
l_string|&quot;dentry busy&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
r_if
c_cond
(paren
id|d_mountpoint
c_func
(paren
id|dentry
)paren
)paren
(brace
r_struct
id|file
op_star
id|fp
op_assign
id|file-&gt;private_data
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fp
)paren
r_return
op_minus
id|ENOENT
suffix:semicolon
id|filp_close
c_func
(paren
id|fp
comma
id|current-&gt;files
)paren
suffix:semicolon
id|file-&gt;private_data
op_assign
l_int|NULL
suffix:semicolon
)brace
id|out
suffix:colon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|autofs4_dir_readdir
r_static
r_int
id|autofs4_dir_readdir
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_void
op_star
id|dirent
comma
id|filldir_t
id|filldir
)paren
(brace
r_struct
id|dentry
op_star
id|dentry
op_assign
id|file-&gt;f_dentry
suffix:semicolon
r_struct
id|autofs_sb_info
op_star
id|sbi
op_assign
id|autofs4_sbi
c_func
(paren
id|dentry-&gt;d_sb
)paren
suffix:semicolon
r_int
id|status
suffix:semicolon
id|DPRINTK
c_func
(paren
l_string|&quot;file=%p dentry=%p %.*s&quot;
comma
id|file
comma
id|dentry
comma
id|dentry-&gt;d_name.len
comma
id|dentry-&gt;d_name.name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|autofs4_oz_mode
c_func
(paren
id|sbi
)paren
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|autofs4_ispending
c_func
(paren
id|dentry
)paren
)paren
(brace
id|DPRINTK
c_func
(paren
l_string|&quot;dentry busy&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
r_if
c_cond
(paren
id|d_mountpoint
c_func
(paren
id|dentry
)paren
)paren
(brace
r_struct
id|file
op_star
id|fp
op_assign
id|file-&gt;private_data
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fp
)paren
r_return
op_minus
id|ENOENT
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fp-&gt;f_op
op_logical_or
op_logical_neg
id|fp-&gt;f_op-&gt;readdir
)paren
r_goto
id|out
suffix:semicolon
id|status
op_assign
id|vfs_readdir
c_func
(paren
id|fp
comma
id|filldir
comma
id|dirent
)paren
suffix:semicolon
id|file-&gt;f_pos
op_assign
id|fp-&gt;f_pos
suffix:semicolon
r_if
c_cond
(paren
id|status
)paren
id|autofs4_copy_atime
c_func
(paren
id|file
comma
id|fp
)paren
suffix:semicolon
r_return
id|status
suffix:semicolon
)brace
id|out
suffix:colon
r_return
id|autofs4_dcache_readdir
c_func
(paren
id|file
comma
id|dirent
comma
id|filldir
)paren
suffix:semicolon
)brace
DECL|function|try_to_fill_dentry
r_static
r_int
id|try_to_fill_dentry
c_func
(paren
r_struct
id|dentry
op_star
id|dentry
comma
r_struct
id|super_block
op_star
id|sb
comma
r_struct
id|autofs_sb_info
op_star
id|sbi
comma
r_int
id|flags
)paren
(brace
r_struct
id|autofs_info
op_star
id|de_info
op_assign
id|autofs4_dentry_ino
c_func
(paren
id|dentry
)paren
suffix:semicolon
r_int
id|status
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Block on any pending expiry here; invalidate the dentry&n;           when expiration is done to trigger mount request with a new&n;           dentry */
r_if
c_cond
(paren
id|de_info
op_logical_and
(paren
id|de_info-&gt;flags
op_amp
id|AUTOFS_INF_EXPIRING
)paren
)paren
(brace
id|DPRINTK
c_func
(paren
l_string|&quot;waiting for expire %p name=%.*s&quot;
comma
id|dentry
comma
id|dentry-&gt;d_name.len
comma
id|dentry-&gt;d_name.name
)paren
suffix:semicolon
id|status
op_assign
id|autofs4_wait
c_func
(paren
id|sbi
comma
id|dentry
comma
id|NFY_NONE
)paren
suffix:semicolon
id|DPRINTK
c_func
(paren
l_string|&quot;expire done status=%d&quot;
comma
id|status
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|DPRINTK
c_func
(paren
l_string|&quot;dentry=%p %.*s ino=%p&quot;
comma
id|dentry
comma
id|dentry-&gt;d_name.len
comma
id|dentry-&gt;d_name.name
comma
id|dentry-&gt;d_inode
)paren
suffix:semicolon
multiline_comment|/* Wait for a pending mount, triggering one if there isn&squot;t one already */
r_if
c_cond
(paren
id|dentry-&gt;d_inode
op_eq
l_int|NULL
)paren
(brace
id|DPRINTK
c_func
(paren
l_string|&quot;waiting for mount name=%.*s&quot;
comma
id|dentry-&gt;d_name.len
comma
id|dentry-&gt;d_name.name
)paren
suffix:semicolon
id|status
op_assign
id|autofs4_wait
c_func
(paren
id|sbi
comma
id|dentry
comma
id|NFY_MOUNT
)paren
suffix:semicolon
id|DPRINTK
c_func
(paren
l_string|&quot;mount done status=%d&quot;
comma
id|status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_logical_and
id|dentry-&gt;d_inode
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Try to get the kernel to invalidate this dentry */
multiline_comment|/* Turn this into a real negative dentry? */
r_if
c_cond
(paren
id|status
op_eq
op_minus
id|ENOENT
)paren
(brace
id|dentry-&gt;d_time
op_assign
id|jiffies
op_plus
id|AUTOFS_NEGATIVE_TIMEOUT
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|dentry-&gt;d_lock
)paren
suffix:semicolon
id|dentry-&gt;d_flags
op_and_assign
op_complement
id|DCACHE_AUTOFS_PENDING
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|dentry-&gt;d_lock
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|status
)paren
(brace
multiline_comment|/* Return a negative dentry, but leave it &quot;pending&quot; */
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Trigger mount for path component or follow link */
)brace
r_else
r_if
c_cond
(paren
id|flags
op_amp
(paren
id|LOOKUP_CONTINUE
op_or
id|LOOKUP_DIRECTORY
)paren
op_logical_or
id|current-&gt;link_count
)paren
(brace
id|DPRINTK
c_func
(paren
l_string|&quot;waiting for mount name=%.*s&quot;
comma
id|dentry-&gt;d_name.len
comma
id|dentry-&gt;d_name.name
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|dentry-&gt;d_lock
)paren
suffix:semicolon
id|dentry-&gt;d_flags
op_or_assign
id|DCACHE_AUTOFS_PENDING
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|dentry-&gt;d_lock
)paren
suffix:semicolon
id|status
op_assign
id|autofs4_wait
c_func
(paren
id|sbi
comma
id|dentry
comma
id|NFY_MOUNT
)paren
suffix:semicolon
id|DPRINTK
c_func
(paren
l_string|&quot;mount done status=%d&quot;
comma
id|status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
)paren
(brace
id|spin_lock
c_func
(paren
op_amp
id|dentry-&gt;d_lock
)paren
suffix:semicolon
id|dentry-&gt;d_flags
op_and_assign
op_complement
id|DCACHE_AUTOFS_PENDING
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|dentry-&gt;d_lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/* We don&squot;t update the usages for the autofs daemon itself, this&n;&t;   is necessary for recursive autofs mounts */
r_if
c_cond
(paren
op_logical_neg
id|autofs4_oz_mode
c_func
(paren
id|sbi
)paren
)paren
id|autofs4_update_usage
c_func
(paren
id|dentry
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|dentry-&gt;d_lock
)paren
suffix:semicolon
id|dentry-&gt;d_flags
op_and_assign
op_complement
id|DCACHE_AUTOFS_PENDING
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|dentry-&gt;d_lock
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Revalidate is called on every cache lookup.  Some of those&n; * cache lookups may actually happen while the dentry is not&n; * yet completely filled in, and revalidate has to delay such&n; * lookups..&n; */
DECL|function|autofs4_revalidate
r_static
r_int
id|autofs4_revalidate
c_func
(paren
r_struct
id|dentry
op_star
id|dentry
comma
r_struct
id|nameidata
op_star
id|nd
)paren
(brace
r_struct
id|inode
op_star
id|dir
op_assign
id|dentry-&gt;d_parent-&gt;d_inode
suffix:semicolon
r_struct
id|autofs_sb_info
op_star
id|sbi
op_assign
id|autofs4_sbi
c_func
(paren
id|dir-&gt;i_sb
)paren
suffix:semicolon
r_int
id|oz_mode
op_assign
id|autofs4_oz_mode
c_func
(paren
id|sbi
)paren
suffix:semicolon
r_int
id|flags
op_assign
id|nd
ques
c_cond
id|nd-&gt;flags
suffix:colon
l_int|0
suffix:semicolon
r_int
id|status
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Pending dentry */
r_if
c_cond
(paren
id|autofs4_ispending
c_func
(paren
id|dentry
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|oz_mode
)paren
id|status
op_assign
id|try_to_fill_dentry
c_func
(paren
id|dentry
comma
id|dir-&gt;i_sb
comma
id|sbi
comma
id|flags
)paren
suffix:semicolon
r_return
id|status
suffix:semicolon
)brace
multiline_comment|/* Negative dentry.. invalidate if &quot;old&quot; */
r_if
c_cond
(paren
id|dentry-&gt;d_inode
op_eq
l_int|NULL
)paren
r_return
(paren
id|dentry-&gt;d_time
op_minus
id|jiffies
op_le
id|AUTOFS_NEGATIVE_TIMEOUT
)paren
suffix:semicolon
multiline_comment|/* Check for a non-mountpoint directory with no contents */
id|spin_lock
c_func
(paren
op_amp
id|dcache_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|S_ISDIR
c_func
(paren
id|dentry-&gt;d_inode-&gt;i_mode
)paren
op_logical_and
op_logical_neg
id|d_mountpoint
c_func
(paren
id|dentry
)paren
op_logical_and
id|list_empty
c_func
(paren
op_amp
id|dentry-&gt;d_subdirs
)paren
)paren
(brace
id|DPRINTK
c_func
(paren
l_string|&quot;dentry=%p %.*s, emptydir&quot;
comma
id|dentry
comma
id|dentry-&gt;d_name.len
comma
id|dentry-&gt;d_name.name
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|dcache_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|oz_mode
)paren
id|status
op_assign
id|try_to_fill_dentry
c_func
(paren
id|dentry
comma
id|dir-&gt;i_sb
comma
id|sbi
comma
id|flags
)paren
suffix:semicolon
r_return
id|status
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|dcache_lock
)paren
suffix:semicolon
multiline_comment|/* Update the usage list */
r_if
c_cond
(paren
op_logical_neg
id|oz_mode
)paren
id|autofs4_update_usage
c_func
(paren
id|dentry
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|autofs4_dentry_release
r_static
r_void
id|autofs4_dentry_release
c_func
(paren
r_struct
id|dentry
op_star
id|de
)paren
(brace
r_struct
id|autofs_info
op_star
id|inf
suffix:semicolon
id|DPRINTK
c_func
(paren
l_string|&quot;releasing %p&quot;
comma
id|de
)paren
suffix:semicolon
id|inf
op_assign
id|autofs4_dentry_ino
c_func
(paren
id|de
)paren
suffix:semicolon
id|de-&gt;d_fsdata
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|inf
)paren
(brace
id|inf-&gt;dentry
op_assign
l_int|NULL
suffix:semicolon
id|inf-&gt;inode
op_assign
l_int|NULL
suffix:semicolon
id|autofs4_free_ino
c_func
(paren
id|inf
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* For dentries of directories in the root dir */
DECL|variable|autofs4_root_dentry_operations
r_static
r_struct
id|dentry_operations
id|autofs4_root_dentry_operations
op_assign
(brace
dot
id|d_revalidate
op_assign
id|autofs4_revalidate
comma
dot
id|d_release
op_assign
id|autofs4_dentry_release
comma
)brace
suffix:semicolon
multiline_comment|/* For other dentries */
DECL|variable|autofs4_dentry_operations
r_static
r_struct
id|dentry_operations
id|autofs4_dentry_operations
op_assign
(brace
dot
id|d_revalidate
op_assign
id|autofs4_revalidate
comma
dot
id|d_release
op_assign
id|autofs4_dentry_release
comma
)brace
suffix:semicolon
multiline_comment|/* Lookups in the root directory */
DECL|function|autofs4_lookup
r_static
r_struct
id|dentry
op_star
id|autofs4_lookup
c_func
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|dentry
op_star
id|dentry
comma
r_struct
id|nameidata
op_star
id|nd
)paren
(brace
r_struct
id|autofs_sb_info
op_star
id|sbi
suffix:semicolon
r_int
id|oz_mode
suffix:semicolon
id|DPRINTK
c_func
(paren
l_string|&quot;name = %.*s&quot;
comma
id|dentry-&gt;d_name.len
comma
id|dentry-&gt;d_name.name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dentry-&gt;d_name.len
OG
id|NAME_MAX
)paren
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|ENAMETOOLONG
)paren
suffix:semicolon
multiline_comment|/* File name too long to exist */
id|sbi
op_assign
id|autofs4_sbi
c_func
(paren
id|dir-&gt;i_sb
)paren
suffix:semicolon
id|oz_mode
op_assign
id|autofs4_oz_mode
c_func
(paren
id|sbi
)paren
suffix:semicolon
id|DPRINTK
c_func
(paren
l_string|&quot;pid = %u, pgrp = %u, catatonic = %d, oz_mode = %d&quot;
comma
id|current-&gt;pid
comma
id|process_group
c_func
(paren
id|current
)paren
comma
id|sbi-&gt;catatonic
comma
id|oz_mode
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Mark the dentry incomplete, but add it. This is needed so&n;&t; * that the VFS layer knows about the dentry, and we can count&n;&t; * on catching any lookups through the revalidate.&n;&t; *&n;&t; * Let all the hard work be done by the revalidate function that&n;&t; * needs to be able to do this anyway..&n;&t; *&n;&t; * We need to do this before we release the directory semaphore.&n;&t; */
id|dentry-&gt;d_op
op_assign
op_amp
id|autofs4_root_dentry_operations
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|oz_mode
)paren
(brace
id|spin_lock
c_func
(paren
op_amp
id|dentry-&gt;d_lock
)paren
suffix:semicolon
id|dentry-&gt;d_flags
op_or_assign
id|DCACHE_AUTOFS_PENDING
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|dentry-&gt;d_lock
)paren
suffix:semicolon
)brace
id|dentry-&gt;d_fsdata
op_assign
l_int|NULL
suffix:semicolon
id|d_add
c_func
(paren
id|dentry
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dentry-&gt;d_op
op_logical_and
id|dentry-&gt;d_op-&gt;d_revalidate
)paren
(brace
id|up
c_func
(paren
op_amp
id|dir-&gt;i_sem
)paren
suffix:semicolon
(paren
id|dentry-&gt;d_op-&gt;d_revalidate
)paren
(paren
id|dentry
comma
id|nd
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|dir-&gt;i_sem
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If we are still pending, check if we had to handle&n;&t; * a signal. If so we can force a restart..&n;&t; */
r_if
c_cond
(paren
id|dentry-&gt;d_flags
op_amp
id|DCACHE_AUTOFS_PENDING
)paren
(brace
multiline_comment|/* See if we were interrupted */
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
id|sigset_t
op_star
id|sigset
op_assign
op_amp
id|current-&gt;pending.signal
suffix:semicolon
r_if
c_cond
(paren
id|sigismember
(paren
id|sigset
comma
id|SIGKILL
)paren
op_logical_or
id|sigismember
(paren
id|sigset
comma
id|SIGQUIT
)paren
op_logical_or
id|sigismember
(paren
id|sigset
comma
id|SIGINT
)paren
)paren
(brace
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|ERESTARTNOINTR
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;&t; * If this dentry is unhashed, then we shouldn&squot;t honour this&n;&t; * lookup even if the dentry is positive.  Returning ENOENT here&n;&t; * doesn&squot;t do the right thing for all system calls, but it should&n;&t; * be OK for the operations we permit from an autofs.&n;&t; */
r_if
c_cond
(paren
id|dentry-&gt;d_inode
op_logical_and
id|d_unhashed
c_func
(paren
id|dentry
)paren
)paren
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|ENOENT
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|autofs4_dir_symlink
r_static
r_int
id|autofs4_dir_symlink
c_func
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|dentry
op_star
id|dentry
comma
r_const
r_char
op_star
id|symname
)paren
(brace
r_struct
id|autofs_sb_info
op_star
id|sbi
op_assign
id|autofs4_sbi
c_func
(paren
id|dir-&gt;i_sb
)paren
suffix:semicolon
r_struct
id|autofs_info
op_star
id|ino
op_assign
id|autofs4_dentry_ino
c_func
(paren
id|dentry
)paren
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_char
op_star
id|cp
suffix:semicolon
id|DPRINTK
c_func
(paren
l_string|&quot;%s &lt;- %.*s&quot;
comma
id|symname
comma
id|dentry-&gt;d_name.len
comma
id|dentry-&gt;d_name.name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|autofs4_oz_mode
c_func
(paren
id|sbi
)paren
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
id|ino
op_assign
id|autofs4_init_ino
c_func
(paren
id|ino
comma
id|sbi
comma
id|S_IFLNK
op_or
l_int|0555
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ino
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOSPC
suffix:semicolon
id|ino-&gt;size
op_assign
id|strlen
c_func
(paren
id|symname
)paren
suffix:semicolon
id|ino-&gt;u.symlink
op_assign
id|cp
op_assign
id|kmalloc
c_func
(paren
id|ino-&gt;size
op_plus
l_int|1
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cp
op_eq
l_int|NULL
)paren
(brace
id|kfree
c_func
(paren
id|ino
)paren
suffix:semicolon
r_return
op_minus
id|ENOSPC
suffix:semicolon
)brace
id|strcpy
c_func
(paren
id|cp
comma
id|symname
)paren
suffix:semicolon
id|inode
op_assign
id|autofs4_get_inode
c_func
(paren
id|dir-&gt;i_sb
comma
id|ino
)paren
suffix:semicolon
id|d_instantiate
c_func
(paren
id|dentry
comma
id|inode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dir
op_eq
id|dir-&gt;i_sb-&gt;s_root-&gt;d_inode
)paren
id|dentry-&gt;d_op
op_assign
op_amp
id|autofs4_root_dentry_operations
suffix:semicolon
r_else
id|dentry-&gt;d_op
op_assign
op_amp
id|autofs4_dentry_operations
suffix:semicolon
id|dentry-&gt;d_fsdata
op_assign
id|ino
suffix:semicolon
id|ino-&gt;dentry
op_assign
id|dget
c_func
(paren
id|dentry
)paren
suffix:semicolon
id|ino-&gt;inode
op_assign
id|inode
suffix:semicolon
id|dir-&gt;i_mtime
op_assign
id|CURRENT_TIME
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * NOTE!&n; *&n; * Normal filesystems would do a &quot;d_delete()&quot; to tell the VFS dcache&n; * that the file no longer exists. However, doing that means that the&n; * VFS layer can turn the dentry into a negative dentry.  We don&squot;t want&n; * this, because since the unlink is probably the result of an expire.&n; * We simply d_drop it, which allows the dentry lookup to remount it&n; * if necessary.&n; *&n; * If a process is blocked on the dentry waiting for the expire to finish,&n; * it will invalidate the dentry and try to mount with a new one.&n; *&n; * Also see autofs4_dir_rmdir()..&n; */
DECL|function|autofs4_dir_unlink
r_static
r_int
id|autofs4_dir_unlink
c_func
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|dentry
op_star
id|dentry
)paren
(brace
r_struct
id|autofs_sb_info
op_star
id|sbi
op_assign
id|autofs4_sbi
c_func
(paren
id|dir-&gt;i_sb
)paren
suffix:semicolon
r_struct
id|autofs_info
op_star
id|ino
op_assign
id|autofs4_dentry_ino
c_func
(paren
id|dentry
)paren
suffix:semicolon
multiline_comment|/* This allows root to remove symlinks */
r_if
c_cond
(paren
op_logical_neg
id|autofs4_oz_mode
c_func
(paren
id|sbi
)paren
op_logical_and
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_ADMIN
)paren
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
id|dput
c_func
(paren
id|ino-&gt;dentry
)paren
suffix:semicolon
id|dentry-&gt;d_inode-&gt;i_size
op_assign
l_int|0
suffix:semicolon
id|dentry-&gt;d_inode-&gt;i_nlink
op_assign
l_int|0
suffix:semicolon
id|dir-&gt;i_mtime
op_assign
id|CURRENT_TIME
suffix:semicolon
id|d_drop
c_func
(paren
id|dentry
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|autofs4_dir_rmdir
r_static
r_int
id|autofs4_dir_rmdir
c_func
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|dentry
op_star
id|dentry
)paren
(brace
r_struct
id|autofs_sb_info
op_star
id|sbi
op_assign
id|autofs4_sbi
c_func
(paren
id|dir-&gt;i_sb
)paren
suffix:semicolon
r_struct
id|autofs_info
op_star
id|ino
op_assign
id|autofs4_dentry_ino
c_func
(paren
id|dentry
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|autofs4_oz_mode
c_func
(paren
id|sbi
)paren
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|dcache_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|dentry-&gt;d_subdirs
)paren
)paren
(brace
id|spin_unlock
c_func
(paren
op_amp
id|dcache_lock
)paren
suffix:semicolon
r_return
op_minus
id|ENOTEMPTY
suffix:semicolon
)brace
id|__d_drop
c_func
(paren
id|dentry
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|dcache_lock
)paren
suffix:semicolon
id|dput
c_func
(paren
id|ino-&gt;dentry
)paren
suffix:semicolon
id|dentry-&gt;d_inode-&gt;i_size
op_assign
l_int|0
suffix:semicolon
id|dentry-&gt;d_inode-&gt;i_nlink
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|dir-&gt;i_nlink
)paren
id|dir-&gt;i_nlink
op_decrement
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|autofs4_dir_mkdir
r_static
r_int
id|autofs4_dir_mkdir
c_func
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|dentry
op_star
id|dentry
comma
r_int
id|mode
)paren
(brace
r_struct
id|autofs_sb_info
op_star
id|sbi
op_assign
id|autofs4_sbi
c_func
(paren
id|dir-&gt;i_sb
)paren
suffix:semicolon
r_struct
id|autofs_info
op_star
id|ino
op_assign
id|autofs4_dentry_ino
c_func
(paren
id|dentry
)paren
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|autofs4_oz_mode
c_func
(paren
id|sbi
)paren
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
id|DPRINTK
c_func
(paren
l_string|&quot;dentry %p, creating %.*s&quot;
comma
id|dentry
comma
id|dentry-&gt;d_name.len
comma
id|dentry-&gt;d_name.name
)paren
suffix:semicolon
id|ino
op_assign
id|autofs4_init_ino
c_func
(paren
id|ino
comma
id|sbi
comma
id|S_IFDIR
op_or
l_int|0555
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ino
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOSPC
suffix:semicolon
id|inode
op_assign
id|autofs4_get_inode
c_func
(paren
id|dir-&gt;i_sb
comma
id|ino
)paren
suffix:semicolon
id|d_instantiate
c_func
(paren
id|dentry
comma
id|inode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dir
op_eq
id|dir-&gt;i_sb-&gt;s_root-&gt;d_inode
)paren
id|dentry-&gt;d_op
op_assign
op_amp
id|autofs4_root_dentry_operations
suffix:semicolon
r_else
id|dentry-&gt;d_op
op_assign
op_amp
id|autofs4_dentry_operations
suffix:semicolon
id|dentry-&gt;d_fsdata
op_assign
id|ino
suffix:semicolon
id|ino-&gt;dentry
op_assign
id|dget
c_func
(paren
id|dentry
)paren
suffix:semicolon
id|ino-&gt;inode
op_assign
id|inode
suffix:semicolon
id|dir-&gt;i_nlink
op_increment
suffix:semicolon
id|dir-&gt;i_mtime
op_assign
id|CURRENT_TIME
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Get/set timeout ioctl() operation */
DECL|function|autofs4_get_set_timeout
r_static
r_inline
r_int
id|autofs4_get_set_timeout
c_func
(paren
r_struct
id|autofs_sb_info
op_star
id|sbi
comma
r_int
r_int
id|__user
op_star
id|p
)paren
(brace
r_int
id|rv
suffix:semicolon
r_int
r_int
id|ntimeout
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rv
op_assign
id|get_user
c_func
(paren
id|ntimeout
comma
id|p
)paren
)paren
op_logical_or
(paren
id|rv
op_assign
id|put_user
c_func
(paren
id|sbi-&gt;exp_timeout
op_div
id|HZ
comma
id|p
)paren
)paren
)paren
r_return
id|rv
suffix:semicolon
r_if
c_cond
(paren
id|ntimeout
OG
id|ULONG_MAX
op_div
id|HZ
)paren
id|sbi-&gt;exp_timeout
op_assign
l_int|0
suffix:semicolon
r_else
id|sbi-&gt;exp_timeout
op_assign
id|ntimeout
op_star
id|HZ
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Return protocol version */
DECL|function|autofs4_get_protover
r_static
r_inline
r_int
id|autofs4_get_protover
c_func
(paren
r_struct
id|autofs_sb_info
op_star
id|sbi
comma
r_int
id|__user
op_star
id|p
)paren
(brace
r_return
id|put_user
c_func
(paren
id|sbi-&gt;version
comma
id|p
)paren
suffix:semicolon
)brace
multiline_comment|/* Return protocol sub version */
DECL|function|autofs4_get_protosubver
r_static
r_inline
r_int
id|autofs4_get_protosubver
c_func
(paren
r_struct
id|autofs_sb_info
op_star
id|sbi
comma
r_int
id|__user
op_star
id|p
)paren
(brace
r_return
id|put_user
c_func
(paren
id|sbi-&gt;sub_version
comma
id|p
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Tells the daemon whether we need to reghost or not. Also, clears&n; * the reghost_needed flag.&n; */
DECL|function|autofs4_ask_reghost
r_static
r_inline
r_int
id|autofs4_ask_reghost
c_func
(paren
r_struct
id|autofs_sb_info
op_star
id|sbi
comma
r_int
id|__user
op_star
id|p
)paren
(brace
r_int
id|status
suffix:semicolon
id|DPRINTK
c_func
(paren
l_string|&quot;returning %d&quot;
comma
id|sbi-&gt;needs_reghost
)paren
suffix:semicolon
id|status
op_assign
id|put_user
c_func
(paren
id|sbi-&gt;needs_reghost
comma
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
)paren
r_return
id|status
suffix:semicolon
id|sbi-&gt;needs_reghost
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Enable / Disable reghosting ioctl() operation&n; */
DECL|function|autofs4_toggle_reghost
r_static
r_inline
r_int
id|autofs4_toggle_reghost
c_func
(paren
r_struct
id|autofs_sb_info
op_star
id|sbi
comma
r_int
id|__user
op_star
id|p
)paren
(brace
r_int
id|status
suffix:semicolon
r_int
id|val
suffix:semicolon
id|status
op_assign
id|get_user
c_func
(paren
id|val
comma
id|p
)paren
suffix:semicolon
id|DPRINTK
c_func
(paren
l_string|&quot;reghost = %d&quot;
comma
id|val
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
)paren
r_return
id|status
suffix:semicolon
multiline_comment|/* turn on/off reghosting, with the val */
id|sbi-&gt;reghost_enabled
op_assign
id|val
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;* Tells the daemon whether it can umount the autofs mount.&n;*/
DECL|function|autofs4_ask_umount
r_static
r_inline
r_int
id|autofs4_ask_umount
c_func
(paren
r_struct
id|vfsmount
op_star
id|mnt
comma
r_int
id|__user
op_star
id|p
)paren
(brace
r_int
id|status
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|may_umount
c_func
(paren
id|mnt
)paren
op_eq
l_int|0
)paren
id|status
op_assign
l_int|1
suffix:semicolon
id|DPRINTK
c_func
(paren
l_string|&quot;returning %d&quot;
comma
id|status
)paren
suffix:semicolon
id|status
op_assign
id|put_user
c_func
(paren
id|status
comma
id|p
)paren
suffix:semicolon
r_return
id|status
suffix:semicolon
)brace
multiline_comment|/* Identify autofs4_dentries - this is so we can tell if there&squot;s&n;   an extra dentry refcount or not.  We only hold a refcount on the&n;   dentry if its non-negative (ie, d_inode != NULL)&n;*/
DECL|function|is_autofs4_dentry
r_int
id|is_autofs4_dentry
c_func
(paren
r_struct
id|dentry
op_star
id|dentry
)paren
(brace
r_return
id|dentry
op_logical_and
id|dentry-&gt;d_inode
op_logical_and
(paren
id|dentry-&gt;d_op
op_eq
op_amp
id|autofs4_root_dentry_operations
op_logical_or
id|dentry-&gt;d_op
op_eq
op_amp
id|autofs4_dentry_operations
)paren
op_logical_and
id|dentry-&gt;d_fsdata
op_ne
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * ioctl()&squot;s on the root directory is the chief method for the daemon to&n; * generate kernel reactions&n; */
DECL|function|autofs4_root_ioctl
r_static
r_int
id|autofs4_root_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_struct
id|autofs_sb_info
op_star
id|sbi
op_assign
id|autofs4_sbi
c_func
(paren
id|inode-&gt;i_sb
)paren
suffix:semicolon
r_void
id|__user
op_star
id|p
op_assign
(paren
r_void
id|__user
op_star
)paren
id|arg
suffix:semicolon
id|DPRINTK
c_func
(paren
l_string|&quot;cmd = 0x%08x, arg = 0x%08lx, sbi = %p, pgrp = %u&quot;
comma
id|cmd
comma
id|arg
comma
id|sbi
comma
id|process_group
c_func
(paren
id|current
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|_IOC_TYPE
c_func
(paren
id|cmd
)paren
op_ne
id|_IOC_TYPE
c_func
(paren
id|AUTOFS_IOC_FIRST
)paren
op_logical_or
id|_IOC_NR
c_func
(paren
id|cmd
)paren
op_minus
id|_IOC_NR
c_func
(paren
id|AUTOFS_IOC_FIRST
)paren
op_ge
id|AUTOFS_IOC_COUNT
)paren
r_return
op_minus
id|ENOTTY
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|autofs4_oz_mode
c_func
(paren
id|sbi
)paren
op_logical_and
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_ADMIN
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|AUTOFS_IOC_READY
suffix:colon
multiline_comment|/* Wait queue: go ahead and retry */
r_return
id|autofs4_wait_release
c_func
(paren
id|sbi
comma
(paren
id|autofs_wqt_t
)paren
id|arg
comma
l_int|0
)paren
suffix:semicolon
r_case
id|AUTOFS_IOC_FAIL
suffix:colon
multiline_comment|/* Wait queue: fail with ENOENT */
r_return
id|autofs4_wait_release
c_func
(paren
id|sbi
comma
(paren
id|autofs_wqt_t
)paren
id|arg
comma
op_minus
id|ENOENT
)paren
suffix:semicolon
r_case
id|AUTOFS_IOC_CATATONIC
suffix:colon
multiline_comment|/* Enter catatonic mode (daemon shutdown) */
id|autofs4_catatonic_mode
c_func
(paren
id|sbi
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|AUTOFS_IOC_PROTOVER
suffix:colon
multiline_comment|/* Get protocol version */
r_return
id|autofs4_get_protover
c_func
(paren
id|sbi
comma
id|p
)paren
suffix:semicolon
r_case
id|AUTOFS_IOC_PROTOSUBVER
suffix:colon
multiline_comment|/* Get protocol sub version */
r_return
id|autofs4_get_protosubver
c_func
(paren
id|sbi
comma
id|p
)paren
suffix:semicolon
r_case
id|AUTOFS_IOC_SETTIMEOUT
suffix:colon
r_return
id|autofs4_get_set_timeout
c_func
(paren
id|sbi
comma
id|p
)paren
suffix:semicolon
r_case
id|AUTOFS_IOC_TOGGLEREGHOST
suffix:colon
r_return
id|autofs4_toggle_reghost
c_func
(paren
id|sbi
comma
id|p
)paren
suffix:semicolon
r_case
id|AUTOFS_IOC_ASKREGHOST
suffix:colon
r_return
id|autofs4_ask_reghost
c_func
(paren
id|sbi
comma
id|p
)paren
suffix:semicolon
r_case
id|AUTOFS_IOC_ASKUMOUNT
suffix:colon
r_return
id|autofs4_ask_umount
c_func
(paren
id|filp-&gt;f_vfsmnt
comma
id|p
)paren
suffix:semicolon
multiline_comment|/* return a single thing to expire */
r_case
id|AUTOFS_IOC_EXPIRE
suffix:colon
r_return
id|autofs4_expire_run
c_func
(paren
id|inode-&gt;i_sb
comma
id|filp-&gt;f_vfsmnt
comma
id|sbi
comma
id|p
)paren
suffix:semicolon
multiline_comment|/* same as above, but can send multiple expires through pipe */
r_case
id|AUTOFS_IOC_EXPIRE_MULTI
suffix:colon
r_return
id|autofs4_expire_multi
c_func
(paren
id|inode-&gt;i_sb
comma
id|filp-&gt;f_vfsmnt
comma
id|sbi
comma
id|p
)paren
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|ENOSYS
suffix:semicolon
)brace
)brace
eof
