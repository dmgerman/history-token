multiline_comment|/*&n; * POSIX message queues filesystem for Linux.&n; *&n; * Copyright (C) 2003,2004  Krzysztof Benedyczak    (golbi@mat.uni.torun.pl)&n; *                          Michal Wronski          (wrona@mat.uni.torun.pl)&n; *&n; * Spinlocks:               Mohamed Abbas           (abbas.mohamed@intel.com)&n; * Lockless receive &amp; send, fd based notify:&n; * &t;&t;&t;    Manfred Spraul&t;    (manfred@colorfullife.com)&n; *&n; * This file is released under the GPL.&n; */
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/pagemap.h&gt;
macro_line|#include &lt;linux/file.h&gt;
macro_line|#include &lt;linux/mount.h&gt;
macro_line|#include &lt;linux/namei.h&gt;
macro_line|#include &lt;linux/sysctl.h&gt;
macro_line|#include &lt;linux/poll.h&gt;
macro_line|#include &lt;linux/mqueue.h&gt;
macro_line|#include &lt;linux/msg.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;linux/netlink.h&gt;
macro_line|#include &lt;linux/syscalls.h&gt;
macro_line|#include &lt;net/sock.h&gt;
macro_line|#include &quot;util.h&quot;
DECL|macro|MQUEUE_MAGIC
mdefine_line|#define MQUEUE_MAGIC&t;0x19800202
DECL|macro|DIRENT_SIZE
mdefine_line|#define DIRENT_SIZE&t;20
DECL|macro|FILENT_SIZE
mdefine_line|#define FILENT_SIZE&t;80
DECL|macro|SEND
mdefine_line|#define SEND&t;&t;0
DECL|macro|RECV
mdefine_line|#define RECV&t;&t;1
DECL|macro|STATE_NONE
mdefine_line|#define STATE_NONE&t;0
DECL|macro|STATE_PENDING
mdefine_line|#define STATE_PENDING&t;1
DECL|macro|STATE_READY
mdefine_line|#define STATE_READY&t;2
multiline_comment|/* used by sysctl */
DECL|macro|FS_MQUEUE
mdefine_line|#define FS_MQUEUE &t;1
DECL|macro|CTL_QUEUESMAX
mdefine_line|#define CTL_QUEUESMAX &t;2
DECL|macro|CTL_MSGMAX
mdefine_line|#define CTL_MSGMAX &t;3
DECL|macro|CTL_MSGSIZEMAX
mdefine_line|#define CTL_MSGSIZEMAX &t;4
multiline_comment|/* default values */
DECL|macro|DFLT_QUEUESMAX
mdefine_line|#define DFLT_QUEUESMAX&t;256&t;/* max number of message queues */
DECL|macro|DFLT_MSGMAX
mdefine_line|#define DFLT_MSGMAX &t;10&t;/* max number of messages in each queue */
DECL|macro|HARD_MSGMAX
mdefine_line|#define HARD_MSGMAX &t;(131072/sizeof(void*))
DECL|macro|DFLT_MSGSIZEMAX
mdefine_line|#define DFLT_MSGSIZEMAX 8192&t;/* max message size */
DECL|macro|NOTIFY_COOKIE_LEN
mdefine_line|#define NOTIFY_COOKIE_LEN&t;32
DECL|struct|ext_wait_queue
r_struct
id|ext_wait_queue
(brace
multiline_comment|/* queue of sleeping tasks */
DECL|member|task
r_struct
id|task_struct
op_star
id|task
suffix:semicolon
DECL|member|list
r_struct
id|list_head
id|list
suffix:semicolon
DECL|member|msg
r_struct
id|msg_msg
op_star
id|msg
suffix:semicolon
multiline_comment|/* ptr of loaded message */
DECL|member|state
r_int
id|state
suffix:semicolon
multiline_comment|/* one of STATE_* values */
)brace
suffix:semicolon
DECL|struct|mqueue_inode_info
r_struct
id|mqueue_inode_info
(brace
DECL|member|lock
id|spinlock_t
id|lock
suffix:semicolon
DECL|member|vfs_inode
r_struct
id|inode
id|vfs_inode
suffix:semicolon
DECL|member|wait_q
id|wait_queue_head_t
id|wait_q
suffix:semicolon
DECL|member|messages
r_struct
id|msg_msg
op_star
op_star
id|messages
suffix:semicolon
DECL|member|attr
r_struct
id|mq_attr
id|attr
suffix:semicolon
DECL|member|notify
r_struct
id|sigevent
id|notify
suffix:semicolon
DECL|member|notify_owner
id|pid_t
id|notify_owner
suffix:semicolon
DECL|member|user
r_struct
id|user_struct
op_star
id|user
suffix:semicolon
multiline_comment|/* user who created, for accouting */
DECL|member|notify_sock
r_struct
id|sock
op_star
id|notify_sock
suffix:semicolon
DECL|member|notify_cookie
r_struct
id|sk_buff
op_star
id|notify_cookie
suffix:semicolon
multiline_comment|/* for tasks waiting for free space and messages, respectively */
DECL|member|e_wait_q
r_struct
id|ext_wait_queue
id|e_wait_q
(braket
l_int|2
)braket
suffix:semicolon
DECL|member|qsize
r_int
r_int
id|qsize
suffix:semicolon
multiline_comment|/* size of queue in memory (sum of all msgs) */
)brace
suffix:semicolon
DECL|variable|mqueue_dir_inode_operations
r_static
r_struct
id|inode_operations
id|mqueue_dir_inode_operations
suffix:semicolon
DECL|variable|mqueue_file_operations
r_static
r_struct
id|file_operations
id|mqueue_file_operations
suffix:semicolon
DECL|variable|mqueue_super_ops
r_static
r_struct
id|super_operations
id|mqueue_super_ops
suffix:semicolon
r_static
r_void
id|remove_notification
c_func
(paren
r_struct
id|mqueue_inode_info
op_star
id|info
)paren
suffix:semicolon
DECL|variable|mq_lock
r_static
id|spinlock_t
id|mq_lock
suffix:semicolon
DECL|variable|mqueue_inode_cachep
r_static
id|kmem_cache_t
op_star
id|mqueue_inode_cachep
suffix:semicolon
DECL|variable|mqueue_mnt
r_static
r_struct
id|vfsmount
op_star
id|mqueue_mnt
suffix:semicolon
DECL|variable|queues_count
r_static
r_int
r_int
id|queues_count
suffix:semicolon
DECL|variable|queues_max
r_static
r_int
r_int
id|queues_max
op_assign
id|DFLT_QUEUESMAX
suffix:semicolon
DECL|variable|msg_max
r_static
r_int
r_int
id|msg_max
op_assign
id|DFLT_MSGMAX
suffix:semicolon
DECL|variable|msgsize_max
r_static
r_int
r_int
id|msgsize_max
op_assign
id|DFLT_MSGSIZEMAX
suffix:semicolon
DECL|variable|mq_sysctl_table
r_static
r_struct
id|ctl_table_header
op_star
id|mq_sysctl_table
suffix:semicolon
DECL|function|MQUEUE_I
r_static
r_inline
r_struct
id|mqueue_inode_info
op_star
id|MQUEUE_I
c_func
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
r_return
id|container_of
c_func
(paren
id|inode
comma
r_struct
id|mqueue_inode_info
comma
id|vfs_inode
)paren
suffix:semicolon
)brace
DECL|function|mqueue_get_inode
r_static
r_struct
id|inode
op_star
id|mqueue_get_inode
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_int
id|mode
comma
r_struct
id|mq_attr
op_star
id|attr
)paren
(brace
r_struct
id|inode
op_star
id|inode
suffix:semicolon
id|inode
op_assign
id|new_inode
c_func
(paren
id|sb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inode
)paren
(brace
id|inode-&gt;i_mode
op_assign
id|mode
suffix:semicolon
id|inode-&gt;i_uid
op_assign
id|current-&gt;fsuid
suffix:semicolon
id|inode-&gt;i_gid
op_assign
id|current-&gt;fsgid
suffix:semicolon
id|inode-&gt;i_blksize
op_assign
id|PAGE_CACHE_SIZE
suffix:semicolon
id|inode-&gt;i_blocks
op_assign
l_int|0
suffix:semicolon
id|inode-&gt;i_mtime
op_assign
id|inode-&gt;i_ctime
op_assign
id|inode-&gt;i_atime
op_assign
id|CURRENT_TIME
suffix:semicolon
r_if
c_cond
(paren
id|S_ISREG
c_func
(paren
id|mode
)paren
)paren
(brace
r_struct
id|mqueue_inode_info
op_star
id|info
suffix:semicolon
r_struct
id|task_struct
op_star
id|p
op_assign
id|current
suffix:semicolon
r_struct
id|user_struct
op_star
id|u
op_assign
id|p-&gt;user
suffix:semicolon
r_int
r_int
id|mq_bytes
comma
id|mq_msg_tblsz
suffix:semicolon
id|inode-&gt;i_fop
op_assign
op_amp
id|mqueue_file_operations
suffix:semicolon
id|inode-&gt;i_size
op_assign
id|FILENT_SIZE
suffix:semicolon
multiline_comment|/* mqueue specific info */
id|info
op_assign
id|MQUEUE_I
c_func
(paren
id|inode
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|info-&gt;lock
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|info-&gt;wait_q
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|info-&gt;e_wait_q
(braket
l_int|0
)braket
dot
id|list
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|info-&gt;e_wait_q
(braket
l_int|1
)braket
dot
id|list
)paren
suffix:semicolon
id|info-&gt;messages
op_assign
l_int|NULL
suffix:semicolon
id|info-&gt;notify_owner
op_assign
l_int|0
suffix:semicolon
id|info-&gt;qsize
op_assign
l_int|0
suffix:semicolon
id|info-&gt;user
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* set when all is ok */
id|memset
c_func
(paren
op_amp
id|info-&gt;attr
comma
l_int|0
comma
r_sizeof
(paren
id|info-&gt;attr
)paren
)paren
suffix:semicolon
id|info-&gt;attr.mq_maxmsg
op_assign
id|DFLT_MSGMAX
suffix:semicolon
id|info-&gt;attr.mq_msgsize
op_assign
id|DFLT_MSGSIZEMAX
suffix:semicolon
r_if
c_cond
(paren
id|attr
)paren
(brace
id|info-&gt;attr.mq_maxmsg
op_assign
id|attr-&gt;mq_maxmsg
suffix:semicolon
id|info-&gt;attr.mq_msgsize
op_assign
id|attr-&gt;mq_msgsize
suffix:semicolon
)brace
id|mq_msg_tblsz
op_assign
id|info-&gt;attr.mq_maxmsg
op_star
r_sizeof
(paren
r_struct
id|msg_msg
op_star
)paren
suffix:semicolon
id|mq_bytes
op_assign
(paren
id|mq_msg_tblsz
op_plus
(paren
id|info-&gt;attr.mq_maxmsg
op_star
id|info-&gt;attr.mq_msgsize
)paren
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|mq_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|u-&gt;mq_bytes
op_plus
id|mq_bytes
template_param
id|p-&gt;signal-&gt;rlim
(braket
id|RLIMIT_MSGQUEUE
)braket
dot
id|rlim_cur
)paren
(brace
id|spin_unlock
c_func
(paren
op_amp
id|mq_lock
)paren
suffix:semicolon
r_goto
id|out_inode
suffix:semicolon
)brace
id|u-&gt;mq_bytes
op_add_assign
id|mq_bytes
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|mq_lock
)paren
suffix:semicolon
id|info-&gt;messages
op_assign
id|kmalloc
c_func
(paren
id|mq_msg_tblsz
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|info-&gt;messages
)paren
(brace
id|spin_lock
c_func
(paren
op_amp
id|mq_lock
)paren
suffix:semicolon
id|u-&gt;mq_bytes
op_sub_assign
id|mq_bytes
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|mq_lock
)paren
suffix:semicolon
r_goto
id|out_inode
suffix:semicolon
)brace
multiline_comment|/* all is ok */
id|info-&gt;user
op_assign
id|get_uid
c_func
(paren
id|u
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|S_ISDIR
c_func
(paren
id|mode
)paren
)paren
(brace
id|inode-&gt;i_nlink
op_increment
suffix:semicolon
multiline_comment|/* Some things misbehave if size == 0 on a directory */
id|inode-&gt;i_size
op_assign
l_int|2
op_star
id|DIRENT_SIZE
suffix:semicolon
id|inode-&gt;i_op
op_assign
op_amp
id|mqueue_dir_inode_operations
suffix:semicolon
id|inode-&gt;i_fop
op_assign
op_amp
id|simple_dir_operations
suffix:semicolon
)brace
)brace
r_return
id|inode
suffix:semicolon
id|out_inode
suffix:colon
id|make_bad_inode
c_func
(paren
id|inode
)paren
suffix:semicolon
id|iput
c_func
(paren
id|inode
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|mqueue_fill_super
r_static
r_int
id|mqueue_fill_super
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_void
op_star
id|data
comma
r_int
id|silent
)paren
(brace
r_struct
id|inode
op_star
id|inode
suffix:semicolon
id|sb-&gt;s_blocksize
op_assign
id|PAGE_CACHE_SIZE
suffix:semicolon
id|sb-&gt;s_blocksize_bits
op_assign
id|PAGE_CACHE_SHIFT
suffix:semicolon
id|sb-&gt;s_magic
op_assign
id|MQUEUE_MAGIC
suffix:semicolon
id|sb-&gt;s_op
op_assign
op_amp
id|mqueue_super_ops
suffix:semicolon
id|inode
op_assign
id|mqueue_get_inode
c_func
(paren
id|sb
comma
id|S_IFDIR
op_or
id|S_ISVTX
op_or
id|S_IRWXUGO
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inode
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|sb-&gt;s_root
op_assign
id|d_alloc_root
c_func
(paren
id|inode
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sb-&gt;s_root
)paren
(brace
id|iput
c_func
(paren
id|inode
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|mqueue_get_sb
r_static
r_struct
id|super_block
op_star
id|mqueue_get_sb
c_func
(paren
r_struct
id|file_system_type
op_star
id|fs_type
comma
r_int
id|flags
comma
r_const
r_char
op_star
id|dev_name
comma
r_void
op_star
id|data
)paren
(brace
r_return
id|get_sb_single
c_func
(paren
id|fs_type
comma
id|flags
comma
id|data
comma
id|mqueue_fill_super
)paren
suffix:semicolon
)brace
DECL|function|init_once
r_static
r_void
id|init_once
c_func
(paren
r_void
op_star
id|foo
comma
id|kmem_cache_t
op_star
id|cachep
comma
r_int
r_int
id|flags
)paren
(brace
r_struct
id|mqueue_inode_info
op_star
id|p
op_assign
(paren
r_struct
id|mqueue_inode_info
op_star
)paren
id|foo
suffix:semicolon
r_if
c_cond
(paren
(paren
id|flags
op_amp
(paren
id|SLAB_CTOR_VERIFY
op_or
id|SLAB_CTOR_CONSTRUCTOR
)paren
)paren
op_eq
id|SLAB_CTOR_CONSTRUCTOR
)paren
id|inode_init_once
c_func
(paren
op_amp
id|p-&gt;vfs_inode
)paren
suffix:semicolon
)brace
DECL|function|mqueue_alloc_inode
r_static
r_struct
id|inode
op_star
id|mqueue_alloc_inode
c_func
(paren
r_struct
id|super_block
op_star
id|sb
)paren
(brace
r_struct
id|mqueue_inode_info
op_star
id|ei
suffix:semicolon
id|ei
op_assign
id|kmem_cache_alloc
c_func
(paren
id|mqueue_inode_cachep
comma
id|SLAB_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ei
)paren
r_return
l_int|NULL
suffix:semicolon
r_return
op_amp
id|ei-&gt;vfs_inode
suffix:semicolon
)brace
DECL|function|mqueue_destroy_inode
r_static
r_void
id|mqueue_destroy_inode
c_func
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
id|kmem_cache_free
c_func
(paren
id|mqueue_inode_cachep
comma
id|MQUEUE_I
c_func
(paren
id|inode
)paren
)paren
suffix:semicolon
)brace
DECL|function|mqueue_delete_inode
r_static
r_void
id|mqueue_delete_inode
c_func
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
r_struct
id|mqueue_inode_info
op_star
id|info
suffix:semicolon
r_struct
id|user_struct
op_star
id|user
suffix:semicolon
r_int
r_int
id|mq_bytes
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|S_ISDIR
c_func
(paren
id|inode-&gt;i_mode
)paren
)paren
(brace
id|clear_inode
c_func
(paren
id|inode
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|info
op_assign
id|MQUEUE_I
c_func
(paren
id|inode
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|info-&gt;lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|info-&gt;attr.mq_curmsgs
suffix:semicolon
id|i
op_increment
)paren
id|free_msg
c_func
(paren
id|info-&gt;messages
(braket
id|i
)braket
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|info-&gt;messages
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|info-&gt;lock
)paren
suffix:semicolon
id|clear_inode
c_func
(paren
id|inode
)paren
suffix:semicolon
id|mq_bytes
op_assign
(paren
id|info-&gt;attr.mq_maxmsg
op_star
r_sizeof
(paren
r_struct
id|msg_msg
op_star
)paren
op_plus
(paren
id|info-&gt;attr.mq_maxmsg
op_star
id|info-&gt;attr.mq_msgsize
)paren
)paren
suffix:semicolon
id|user
op_assign
id|info-&gt;user
suffix:semicolon
r_if
c_cond
(paren
id|user
)paren
(brace
id|spin_lock
c_func
(paren
op_amp
id|mq_lock
)paren
suffix:semicolon
id|user-&gt;mq_bytes
op_sub_assign
id|mq_bytes
suffix:semicolon
id|queues_count
op_decrement
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|mq_lock
)paren
suffix:semicolon
id|free_uid
c_func
(paren
id|user
)paren
suffix:semicolon
)brace
)brace
DECL|function|mqueue_create
r_static
r_int
id|mqueue_create
c_func
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|dentry
op_star
id|dentry
comma
r_int
id|mode
comma
r_struct
id|nameidata
op_star
id|nd
)paren
(brace
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_struct
id|mq_attr
op_star
id|attr
op_assign
id|dentry-&gt;d_fsdata
suffix:semicolon
r_int
id|error
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|mq_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|queues_count
op_ge
id|queues_max
op_logical_and
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_RESOURCE
)paren
)paren
(brace
id|error
op_assign
op_minus
id|ENOSPC
suffix:semicolon
r_goto
id|out_lock
suffix:semicolon
)brace
id|queues_count
op_increment
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|mq_lock
)paren
suffix:semicolon
id|inode
op_assign
id|mqueue_get_inode
c_func
(paren
id|dir-&gt;i_sb
comma
id|mode
comma
id|attr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inode
)paren
(brace
id|error
op_assign
op_minus
id|ENOMEM
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|mq_lock
)paren
suffix:semicolon
id|queues_count
op_decrement
suffix:semicolon
r_goto
id|out_lock
suffix:semicolon
)brace
id|dir-&gt;i_size
op_add_assign
id|DIRENT_SIZE
suffix:semicolon
id|dir-&gt;i_ctime
op_assign
id|dir-&gt;i_mtime
op_assign
id|dir-&gt;i_atime
op_assign
id|CURRENT_TIME
suffix:semicolon
id|d_instantiate
c_func
(paren
id|dentry
comma
id|inode
)paren
suffix:semicolon
id|dget
c_func
(paren
id|dentry
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|out_lock
suffix:colon
id|spin_unlock
c_func
(paren
op_amp
id|mq_lock
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
DECL|function|mqueue_unlink
r_static
r_int
id|mqueue_unlink
c_func
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|dentry
op_star
id|dentry
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|dentry-&gt;d_inode
suffix:semicolon
id|dir-&gt;i_ctime
op_assign
id|dir-&gt;i_mtime
op_assign
id|dir-&gt;i_atime
op_assign
id|CURRENT_TIME
suffix:semicolon
id|dir-&gt;i_size
op_sub_assign
id|DIRENT_SIZE
suffix:semicolon
id|inode-&gt;i_nlink
op_decrement
suffix:semicolon
id|dput
c_func
(paren
id|dentry
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;*&t;This is routine for system read from queue file.&n;*&t;To avoid mess with doing here some sort of mq_receive we allow&n;*&t;to read only queue size &amp; notification info (the only values&n;*&t;that are interesting from user point of view and aren&squot;t accessible&n;*&t;through std routines)&n;*/
DECL|function|mqueue_read_file
r_static
id|ssize_t
id|mqueue_read_file
c_func
(paren
r_struct
id|file
op_star
id|filp
comma
r_char
id|__user
op_star
id|u_data
comma
r_int
id|count
comma
id|loff_t
op_star
id|off
)paren
(brace
r_struct
id|mqueue_inode_info
op_star
id|info
op_assign
id|MQUEUE_I
c_func
(paren
id|filp-&gt;f_dentry-&gt;d_inode
)paren
suffix:semicolon
r_char
id|buffer
(braket
id|FILENT_SIZE
)braket
suffix:semicolon
r_int
id|slen
suffix:semicolon
id|loff_t
id|o
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|count
)paren
r_return
l_int|0
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|info-&gt;lock
)paren
suffix:semicolon
id|snprintf
c_func
(paren
id|buffer
comma
r_sizeof
(paren
id|buffer
)paren
comma
l_string|&quot;QSIZE:%-10lu NOTIFY:%-5d SIGNO:%-5d NOTIFY_PID:%-6d&bslash;n&quot;
comma
id|info-&gt;qsize
comma
id|info-&gt;notify_owner
ques
c_cond
id|info-&gt;notify.sigev_notify
suffix:colon
l_int|0
comma
(paren
id|info-&gt;notify_owner
op_logical_and
id|info-&gt;notify.sigev_notify
op_eq
id|SIGEV_SIGNAL
)paren
ques
c_cond
id|info-&gt;notify.sigev_signo
suffix:colon
l_int|0
comma
id|info-&gt;notify_owner
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|info-&gt;lock
)paren
suffix:semicolon
id|buffer
(braket
r_sizeof
(paren
id|buffer
)paren
op_minus
l_int|1
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|slen
op_assign
id|strlen
c_func
(paren
id|buffer
)paren
op_plus
l_int|1
suffix:semicolon
id|o
op_assign
op_star
id|off
suffix:semicolon
r_if
c_cond
(paren
id|o
OG
id|slen
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|o
op_plus
id|count
OG
id|slen
)paren
id|count
op_assign
id|slen
op_minus
id|o
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|u_data
comma
id|buffer
op_plus
id|o
comma
id|count
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
op_star
id|off
op_assign
id|o
op_plus
id|count
suffix:semicolon
id|filp-&gt;f_dentry-&gt;d_inode-&gt;i_atime
op_assign
id|filp-&gt;f_dentry-&gt;d_inode-&gt;i_ctime
op_assign
id|CURRENT_TIME
suffix:semicolon
r_return
id|count
suffix:semicolon
)brace
DECL|function|mqueue_flush_file
r_static
r_int
id|mqueue_flush_file
c_func
(paren
r_struct
id|file
op_star
id|filp
)paren
(brace
r_struct
id|mqueue_inode_info
op_star
id|info
op_assign
id|MQUEUE_I
c_func
(paren
id|filp-&gt;f_dentry-&gt;d_inode
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|info-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;tgid
op_eq
id|info-&gt;notify_owner
)paren
id|remove_notification
c_func
(paren
id|info
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|info-&gt;lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|mqueue_poll_file
r_static
r_int
r_int
id|mqueue_poll_file
c_func
(paren
r_struct
id|file
op_star
id|filp
comma
r_struct
id|poll_table_struct
op_star
id|poll_tab
)paren
(brace
r_struct
id|mqueue_inode_info
op_star
id|info
op_assign
id|MQUEUE_I
c_func
(paren
id|filp-&gt;f_dentry-&gt;d_inode
)paren
suffix:semicolon
r_int
id|retval
op_assign
l_int|0
suffix:semicolon
id|poll_wait
c_func
(paren
id|filp
comma
op_amp
id|info-&gt;wait_q
comma
id|poll_tab
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|info-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;attr.mq_curmsgs
)paren
id|retval
op_assign
id|POLLIN
op_or
id|POLLRDNORM
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;attr.mq_curmsgs
OL
id|info-&gt;attr.mq_maxmsg
)paren
id|retval
op_or_assign
id|POLLOUT
op_or
id|POLLWRNORM
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|info-&gt;lock
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/* Adds current to info-&gt;e_wait_q[sr] before element with smaller prio */
DECL|function|wq_add
r_static
r_void
id|wq_add
c_func
(paren
r_struct
id|mqueue_inode_info
op_star
id|info
comma
r_int
id|sr
comma
r_struct
id|ext_wait_queue
op_star
id|ewp
)paren
(brace
r_struct
id|ext_wait_queue
op_star
id|walk
suffix:semicolon
id|ewp-&gt;task
op_assign
id|current
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|walk
comma
op_amp
id|info-&gt;e_wait_q
(braket
id|sr
)braket
dot
id|list
comma
id|list
)paren
(brace
r_if
c_cond
(paren
id|walk-&gt;task-&gt;static_prio
op_le
id|current-&gt;static_prio
)paren
(brace
id|list_add_tail
c_func
(paren
op_amp
id|ewp-&gt;list
comma
op_amp
id|walk-&gt;list
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
id|list_add_tail
c_func
(paren
op_amp
id|ewp-&gt;list
comma
op_amp
id|info-&gt;e_wait_q
(braket
id|sr
)braket
dot
id|list
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Puts current task to sleep. Caller must hold queue lock. After return&n; * lock isn&squot;t held.&n; * sr: SEND or RECV&n; */
DECL|function|wq_sleep
r_static
r_int
id|wq_sleep
c_func
(paren
r_struct
id|mqueue_inode_info
op_star
id|info
comma
r_int
id|sr
comma
r_int
id|timeout
comma
r_struct
id|ext_wait_queue
op_star
id|ewp
)paren
(brace
r_int
id|retval
suffix:semicolon
r_int
r_int
id|time
suffix:semicolon
id|wq_add
c_func
(paren
id|info
comma
id|sr
comma
id|ewp
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|info-&gt;lock
)paren
suffix:semicolon
id|time
op_assign
id|schedule_timeout
c_func
(paren
id|timeout
)paren
suffix:semicolon
r_while
c_loop
(paren
id|ewp-&gt;state
op_eq
id|STATE_PENDING
)paren
id|cpu_relax
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ewp-&gt;state
op_eq
id|STATE_READY
)paren
(brace
id|retval
op_assign
l_int|0
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|spin_lock
c_func
(paren
op_amp
id|info-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ewp-&gt;state
op_eq
id|STATE_READY
)paren
(brace
id|retval
op_assign
l_int|0
suffix:semicolon
r_goto
id|out_unlock
suffix:semicolon
)brace
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
id|retval
op_assign
op_minus
id|ERESTARTSYS
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|time
op_eq
l_int|0
)paren
(brace
id|retval
op_assign
op_minus
id|ETIMEDOUT
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|list_del
c_func
(paren
op_amp
id|ewp-&gt;list
)paren
suffix:semicolon
id|out_unlock
suffix:colon
id|spin_unlock
c_func
(paren
op_amp
id|info-&gt;lock
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*&n; * Returns waiting task that should be serviced first or NULL if none exists&n; */
DECL|function|wq_get_first_waiter
r_static
r_struct
id|ext_wait_queue
op_star
id|wq_get_first_waiter
c_func
(paren
r_struct
id|mqueue_inode_info
op_star
id|info
comma
r_int
id|sr
)paren
(brace
r_struct
id|list_head
op_star
id|ptr
suffix:semicolon
id|ptr
op_assign
id|info-&gt;e_wait_q
(braket
id|sr
)braket
dot
id|list.prev
suffix:semicolon
r_if
c_cond
(paren
id|ptr
op_eq
op_amp
id|info-&gt;e_wait_q
(braket
id|sr
)braket
dot
id|list
)paren
r_return
l_int|NULL
suffix:semicolon
r_return
id|list_entry
c_func
(paren
id|ptr
comma
r_struct
id|ext_wait_queue
comma
id|list
)paren
suffix:semicolon
)brace
multiline_comment|/* Auxiliary functions to manipulate messages&squot; list */
DECL|function|msg_insert
r_static
r_void
id|msg_insert
c_func
(paren
r_struct
id|msg_msg
op_star
id|ptr
comma
r_struct
id|mqueue_inode_info
op_star
id|info
)paren
(brace
r_int
id|k
suffix:semicolon
id|k
op_assign
id|info-&gt;attr.mq_curmsgs
op_minus
l_int|1
suffix:semicolon
r_while
c_loop
(paren
id|k
op_ge
l_int|0
op_logical_and
id|info-&gt;messages
(braket
id|k
)braket
op_member_access_from_pointer
id|m_type
op_ge
id|ptr-&gt;m_type
)paren
(brace
id|info-&gt;messages
(braket
id|k
op_plus
l_int|1
)braket
op_assign
id|info-&gt;messages
(braket
id|k
)braket
suffix:semicolon
id|k
op_decrement
suffix:semicolon
)brace
id|info-&gt;attr.mq_curmsgs
op_increment
suffix:semicolon
id|info-&gt;qsize
op_add_assign
id|ptr-&gt;m_ts
suffix:semicolon
id|info-&gt;messages
(braket
id|k
op_plus
l_int|1
)braket
op_assign
id|ptr
suffix:semicolon
)brace
DECL|function|msg_get
r_static
r_inline
r_struct
id|msg_msg
op_star
id|msg_get
c_func
(paren
r_struct
id|mqueue_inode_info
op_star
id|info
)paren
(brace
id|info-&gt;qsize
op_sub_assign
id|info-&gt;messages
(braket
op_decrement
id|info-&gt;attr.mq_curmsgs
)braket
op_member_access_from_pointer
id|m_ts
suffix:semicolon
r_return
id|info-&gt;messages
(braket
id|info-&gt;attr.mq_curmsgs
)braket
suffix:semicolon
)brace
DECL|function|set_cookie
r_static
r_inline
r_void
id|set_cookie
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_char
id|code
)paren
(brace
(paren
(paren
r_char
op_star
)paren
id|skb-&gt;data
)paren
(braket
id|NOTIFY_COOKIE_LEN
op_minus
l_int|1
)braket
op_assign
id|code
suffix:semicolon
)brace
multiline_comment|/*&n; * The next function is only to split too long sys_mq_timedsend&n; */
DECL|function|__do_notify
r_static
r_void
id|__do_notify
c_func
(paren
r_struct
id|mqueue_inode_info
op_star
id|info
)paren
(brace
multiline_comment|/* notification&n;&t; * invoked when there is registered process and there isn&squot;t process&n;&t; * waiting synchronously for message AND state of queue changed from&n;&t; * empty to not empty. Here we are sure that no one is waiting&n;&t; * synchronously. */
r_if
c_cond
(paren
id|info-&gt;notify_owner
op_logical_and
id|info-&gt;attr.mq_curmsgs
op_eq
l_int|1
)paren
(brace
r_struct
id|siginfo
id|sig_i
suffix:semicolon
r_switch
c_cond
(paren
id|info-&gt;notify.sigev_notify
)paren
(brace
r_case
id|SIGEV_NONE
suffix:colon
r_break
suffix:semicolon
r_case
id|SIGEV_SIGNAL
suffix:colon
multiline_comment|/* sends signal */
id|sig_i.si_signo
op_assign
id|info-&gt;notify.sigev_signo
suffix:semicolon
id|sig_i.si_errno
op_assign
l_int|0
suffix:semicolon
id|sig_i.si_code
op_assign
id|SI_MESGQ
suffix:semicolon
id|sig_i.si_value
op_assign
id|info-&gt;notify.sigev_value
suffix:semicolon
id|sig_i.si_pid
op_assign
id|current-&gt;tgid
suffix:semicolon
id|sig_i.si_uid
op_assign
id|current-&gt;uid
suffix:semicolon
id|kill_proc_info
c_func
(paren
id|info-&gt;notify.sigev_signo
comma
op_amp
id|sig_i
comma
id|info-&gt;notify_owner
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIGEV_THREAD
suffix:colon
id|set_cookie
c_func
(paren
id|info-&gt;notify_cookie
comma
id|NOTIFY_WOKENUP
)paren
suffix:semicolon
id|netlink_sendskb
c_func
(paren
id|info-&gt;notify_sock
comma
id|info-&gt;notify_cookie
comma
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* after notification unregisters process */
id|info-&gt;notify_owner
op_assign
l_int|0
suffix:semicolon
)brace
id|wake_up
c_func
(paren
op_amp
id|info-&gt;wait_q
)paren
suffix:semicolon
)brace
DECL|function|prepare_timeout
r_static
r_int
id|prepare_timeout
c_func
(paren
r_const
r_struct
id|timespec
id|__user
op_star
id|u_arg
)paren
(brace
r_struct
id|timespec
id|ts
comma
id|nowts
suffix:semicolon
r_int
id|timeout
suffix:semicolon
r_if
c_cond
(paren
id|u_arg
)paren
(brace
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|copy_from_user
c_func
(paren
op_amp
id|ts
comma
id|u_arg
comma
r_sizeof
(paren
r_struct
id|timespec
)paren
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|ts.tv_nsec
OL
l_int|0
op_logical_or
id|ts.tv_sec
OL
l_int|0
op_logical_or
id|ts.tv_nsec
op_ge
id|NSEC_PER_SEC
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|nowts
op_assign
id|CURRENT_TIME
suffix:semicolon
multiline_comment|/* first subtract as jiffies can&squot;t be too big */
id|ts.tv_sec
op_sub_assign
id|nowts.tv_sec
suffix:semicolon
r_if
c_cond
(paren
id|ts.tv_nsec
OL
id|nowts.tv_nsec
)paren
(brace
id|ts.tv_nsec
op_add_assign
id|NSEC_PER_SEC
suffix:semicolon
id|ts.tv_sec
op_decrement
suffix:semicolon
)brace
id|ts.tv_nsec
op_sub_assign
id|nowts.tv_nsec
suffix:semicolon
r_if
c_cond
(paren
id|ts.tv_sec
OL
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
id|timeout
op_assign
id|timespec_to_jiffies
c_func
(paren
op_amp
id|ts
)paren
op_plus
l_int|1
suffix:semicolon
)brace
r_else
r_return
id|MAX_SCHEDULE_TIMEOUT
suffix:semicolon
r_return
id|timeout
suffix:semicolon
)brace
DECL|function|remove_notification
r_static
r_void
id|remove_notification
c_func
(paren
r_struct
id|mqueue_inode_info
op_star
id|info
)paren
(brace
r_if
c_cond
(paren
id|info-&gt;notify_owner
op_ne
l_int|0
op_logical_and
id|info-&gt;notify.sigev_notify
op_eq
id|SIGEV_THREAD
)paren
(brace
id|set_cookie
c_func
(paren
id|info-&gt;notify_cookie
comma
id|NOTIFY_REMOVED
)paren
suffix:semicolon
id|netlink_sendskb
c_func
(paren
id|info-&gt;notify_sock
comma
id|info-&gt;notify_cookie
comma
l_int|0
)paren
suffix:semicolon
)brace
id|info-&gt;notify_owner
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|mq_attr_ok
r_static
r_int
id|mq_attr_ok
c_func
(paren
r_struct
id|mq_attr
op_star
id|attr
)paren
(brace
r_if
c_cond
(paren
id|attr-&gt;mq_maxmsg
op_le
l_int|0
op_logical_or
id|attr-&gt;mq_msgsize
op_le
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|capable
c_func
(paren
id|CAP_SYS_RESOURCE
)paren
)paren
(brace
r_if
c_cond
(paren
id|attr-&gt;mq_maxmsg
OG
id|HARD_MSGMAX
)paren
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|attr-&gt;mq_maxmsg
OG
id|msg_max
op_logical_or
id|attr-&gt;mq_msgsize
OG
id|msgsize_max
)paren
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* check for overflow */
r_if
c_cond
(paren
id|attr-&gt;mq_msgsize
OG
id|ULONG_MAX
op_div
id|attr-&gt;mq_maxmsg
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
r_int
)paren
(paren
id|attr-&gt;mq_maxmsg
op_star
id|attr-&gt;mq_msgsize
)paren
op_plus
(paren
id|attr-&gt;mq_maxmsg
op_star
r_sizeof
(paren
r_struct
id|msg_msg
op_star
)paren
)paren
OL
(paren
r_int
r_int
)paren
(paren
id|attr-&gt;mq_maxmsg
op_star
id|attr-&gt;mq_msgsize
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Invoked when creating a new queue via sys_mq_open&n; */
DECL|function|do_create
r_static
r_struct
id|file
op_star
id|do_create
c_func
(paren
r_struct
id|dentry
op_star
id|dir
comma
r_struct
id|dentry
op_star
id|dentry
comma
r_int
id|oflag
comma
id|mode_t
id|mode
comma
r_struct
id|mq_attr
id|__user
op_star
id|u_attr
)paren
(brace
r_struct
id|file
op_star
id|filp
suffix:semicolon
r_struct
id|mq_attr
id|attr
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_if
c_cond
(paren
id|u_attr
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|attr
comma
id|u_attr
comma
r_sizeof
(paren
id|attr
)paren
)paren
)paren
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|EFAULT
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mq_attr_ok
c_func
(paren
op_amp
id|attr
)paren
)paren
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
multiline_comment|/* store for use during create */
id|dentry-&gt;d_fsdata
op_assign
op_amp
id|attr
suffix:semicolon
)brace
id|ret
op_assign
id|vfs_create
c_func
(paren
id|dir-&gt;d_inode
comma
id|dentry
comma
id|mode
comma
l_int|NULL
)paren
suffix:semicolon
id|dentry-&gt;d_fsdata
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_return
id|ERR_PTR
c_func
(paren
id|ret
)paren
suffix:semicolon
id|filp
op_assign
id|dentry_open
c_func
(paren
id|dentry
comma
id|mqueue_mnt
comma
id|oflag
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|IS_ERR
c_func
(paren
id|filp
)paren
)paren
id|dget
c_func
(paren
id|dentry
)paren
suffix:semicolon
r_return
id|filp
suffix:semicolon
)brace
multiline_comment|/* Opens existing queue */
DECL|function|do_open
r_static
r_struct
id|file
op_star
id|do_open
c_func
(paren
r_struct
id|dentry
op_star
id|dentry
comma
r_int
id|oflag
)paren
(brace
r_static
r_int
id|oflag2acc
(braket
id|O_ACCMODE
)braket
op_assign
(brace
id|MAY_READ
comma
id|MAY_WRITE
comma
id|MAY_READ
op_or
id|MAY_WRITE
)brace
suffix:semicolon
r_struct
id|file
op_star
id|filp
suffix:semicolon
r_if
c_cond
(paren
(paren
id|oflag
op_amp
id|O_ACCMODE
)paren
op_eq
(paren
id|O_RDWR
op_or
id|O_WRONLY
)paren
)paren
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|permission
c_func
(paren
id|dentry-&gt;d_inode
comma
id|oflag2acc
(braket
id|oflag
op_amp
id|O_ACCMODE
)braket
comma
l_int|NULL
)paren
)paren
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|EACCES
)paren
suffix:semicolon
id|filp
op_assign
id|dentry_open
c_func
(paren
id|dentry
comma
id|mqueue_mnt
comma
id|oflag
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|IS_ERR
c_func
(paren
id|filp
)paren
)paren
id|dget
c_func
(paren
id|dentry
)paren
suffix:semicolon
r_return
id|filp
suffix:semicolon
)brace
DECL|function|sys_mq_open
id|asmlinkage
r_int
id|sys_mq_open
c_func
(paren
r_const
r_char
id|__user
op_star
id|u_name
comma
r_int
id|oflag
comma
id|mode_t
id|mode
comma
r_struct
id|mq_attr
id|__user
op_star
id|u_attr
)paren
(brace
r_struct
id|dentry
op_star
id|dentry
suffix:semicolon
r_struct
id|file
op_star
id|filp
suffix:semicolon
r_char
op_star
id|name
suffix:semicolon
r_int
id|fd
comma
id|error
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|name
op_assign
id|getname
c_func
(paren
id|u_name
)paren
)paren
)paren
r_return
id|PTR_ERR
c_func
(paren
id|name
)paren
suffix:semicolon
id|fd
op_assign
id|get_unused_fd
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fd
OL
l_int|0
)paren
r_goto
id|out_putname
suffix:semicolon
id|down
c_func
(paren
op_amp
id|mqueue_mnt-&gt;mnt_root-&gt;d_inode-&gt;i_sem
)paren
suffix:semicolon
id|dentry
op_assign
id|lookup_one_len
c_func
(paren
id|name
comma
id|mqueue_mnt-&gt;mnt_root
comma
id|strlen
c_func
(paren
id|name
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|dentry
)paren
)paren
(brace
id|error
op_assign
id|PTR_ERR
c_func
(paren
id|dentry
)paren
suffix:semicolon
r_goto
id|out_err
suffix:semicolon
)brace
id|mntget
c_func
(paren
id|mqueue_mnt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|oflag
op_amp
id|O_CREAT
)paren
(brace
r_if
c_cond
(paren
id|dentry-&gt;d_inode
)paren
(brace
multiline_comment|/* entry already exists */
id|filp
op_assign
(paren
id|oflag
op_amp
id|O_EXCL
)paren
ques
c_cond
id|ERR_PTR
c_func
(paren
op_minus
id|EEXIST
)paren
suffix:colon
id|do_open
c_func
(paren
id|dentry
comma
id|oflag
)paren
suffix:semicolon
)brace
r_else
(brace
id|filp
op_assign
id|do_create
c_func
(paren
id|mqueue_mnt-&gt;mnt_root
comma
id|dentry
comma
id|oflag
comma
id|mode
comma
id|u_attr
)paren
suffix:semicolon
)brace
)brace
r_else
id|filp
op_assign
(paren
id|dentry-&gt;d_inode
)paren
ques
c_cond
id|do_open
c_func
(paren
id|dentry
comma
id|oflag
)paren
suffix:colon
id|ERR_PTR
c_func
(paren
op_minus
id|ENOENT
)paren
suffix:semicolon
id|dput
c_func
(paren
id|dentry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|filp
)paren
)paren
(brace
id|error
op_assign
id|PTR_ERR
c_func
(paren
id|filp
)paren
suffix:semicolon
r_goto
id|out_putfd
suffix:semicolon
)brace
id|set_close_on_exec
c_func
(paren
id|fd
comma
l_int|1
)paren
suffix:semicolon
id|fd_install
c_func
(paren
id|fd
comma
id|filp
)paren
suffix:semicolon
r_goto
id|out_upsem
suffix:semicolon
id|out_putfd
suffix:colon
id|mntput
c_func
(paren
id|mqueue_mnt
)paren
suffix:semicolon
id|put_unused_fd
c_func
(paren
id|fd
)paren
suffix:semicolon
id|out_err
suffix:colon
id|fd
op_assign
id|error
suffix:semicolon
id|out_upsem
suffix:colon
id|up
c_func
(paren
op_amp
id|mqueue_mnt-&gt;mnt_root-&gt;d_inode-&gt;i_sem
)paren
suffix:semicolon
id|out_putname
suffix:colon
id|putname
c_func
(paren
id|name
)paren
suffix:semicolon
r_return
id|fd
suffix:semicolon
)brace
DECL|function|sys_mq_unlink
id|asmlinkage
r_int
id|sys_mq_unlink
c_func
(paren
r_const
r_char
id|__user
op_star
id|u_name
)paren
(brace
r_int
id|err
suffix:semicolon
r_char
op_star
id|name
suffix:semicolon
r_struct
id|dentry
op_star
id|dentry
suffix:semicolon
r_struct
id|inode
op_star
id|inode
op_assign
l_int|NULL
suffix:semicolon
id|name
op_assign
id|getname
c_func
(paren
id|u_name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|name
)paren
)paren
r_return
id|PTR_ERR
c_func
(paren
id|name
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|mqueue_mnt-&gt;mnt_root-&gt;d_inode-&gt;i_sem
)paren
suffix:semicolon
id|dentry
op_assign
id|lookup_one_len
c_func
(paren
id|name
comma
id|mqueue_mnt-&gt;mnt_root
comma
id|strlen
c_func
(paren
id|name
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|dentry
)paren
)paren
(brace
id|err
op_assign
id|PTR_ERR
c_func
(paren
id|dentry
)paren
suffix:semicolon
r_goto
id|out_unlock
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|dentry-&gt;d_inode
)paren
(brace
id|err
op_assign
op_minus
id|ENOENT
suffix:semicolon
r_goto
id|out_err
suffix:semicolon
)brace
id|inode
op_assign
id|dentry-&gt;d_inode
suffix:semicolon
r_if
c_cond
(paren
id|inode
)paren
id|atomic_inc
c_func
(paren
op_amp
id|inode-&gt;i_count
)paren
suffix:semicolon
id|err
op_assign
id|vfs_unlink
c_func
(paren
id|dentry-&gt;d_parent-&gt;d_inode
comma
id|dentry
)paren
suffix:semicolon
id|out_err
suffix:colon
id|dput
c_func
(paren
id|dentry
)paren
suffix:semicolon
id|out_unlock
suffix:colon
id|up
c_func
(paren
op_amp
id|mqueue_mnt-&gt;mnt_root-&gt;d_inode-&gt;i_sem
)paren
suffix:semicolon
id|putname
c_func
(paren
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inode
)paren
id|iput
c_func
(paren
id|inode
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/* Pipelined send and receive functions.&n; *&n; * If a receiver finds no waiting message, then it registers itself in the&n; * list of waiting receivers. A sender checks that list before adding the new&n; * message into the message array. If there is a waiting receiver, then it&n; * bypasses the message array and directly hands the message over to the&n; * receiver.&n; * The receiver accepts the message and returns without grabbing the queue&n; * spinlock. Therefore an intermediate STATE_PENDING state and memory barriers&n; * are necessary. The same algorithm is used for sysv semaphores, see&n; * ipc/sem.c fore more details.&n; *&n; * The same algorithm is used for senders.&n; */
multiline_comment|/* pipelined_send() - send a message directly to the task waiting in&n; * sys_mq_timedreceive() (without inserting message into a queue).&n; */
DECL|function|pipelined_send
r_static
r_inline
r_void
id|pipelined_send
c_func
(paren
r_struct
id|mqueue_inode_info
op_star
id|info
comma
r_struct
id|msg_msg
op_star
id|message
comma
r_struct
id|ext_wait_queue
op_star
id|receiver
)paren
(brace
id|receiver-&gt;msg
op_assign
id|message
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|receiver-&gt;list
)paren
suffix:semicolon
id|receiver-&gt;state
op_assign
id|STATE_PENDING
suffix:semicolon
id|wake_up_process
c_func
(paren
id|receiver-&gt;task
)paren
suffix:semicolon
id|wmb
c_func
(paren
)paren
suffix:semicolon
id|receiver-&gt;state
op_assign
id|STATE_READY
suffix:semicolon
)brace
multiline_comment|/* pipelined_receive() - if there is task waiting in sys_mq_timedsend()&n; * gets its message and put to the queue (we have one free place for sure). */
DECL|function|pipelined_receive
r_static
r_inline
r_void
id|pipelined_receive
c_func
(paren
r_struct
id|mqueue_inode_info
op_star
id|info
)paren
(brace
r_struct
id|ext_wait_queue
op_star
id|sender
op_assign
id|wq_get_first_waiter
c_func
(paren
id|info
comma
id|SEND
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sender
)paren
(brace
multiline_comment|/* for poll */
id|wake_up_interruptible
c_func
(paren
op_amp
id|info-&gt;wait_q
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|msg_insert
c_func
(paren
id|sender-&gt;msg
comma
id|info
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|sender-&gt;list
)paren
suffix:semicolon
id|sender-&gt;state
op_assign
id|STATE_PENDING
suffix:semicolon
id|wake_up_process
c_func
(paren
id|sender-&gt;task
)paren
suffix:semicolon
id|wmb
c_func
(paren
)paren
suffix:semicolon
id|sender-&gt;state
op_assign
id|STATE_READY
suffix:semicolon
)brace
DECL|function|sys_mq_timedsend
id|asmlinkage
r_int
id|sys_mq_timedsend
c_func
(paren
id|mqd_t
id|mqdes
comma
r_const
r_char
id|__user
op_star
id|u_msg_ptr
comma
r_int
id|msg_len
comma
r_int
r_int
id|msg_prio
comma
r_const
r_struct
id|timespec
id|__user
op_star
id|u_abs_timeout
)paren
(brace
r_struct
id|file
op_star
id|filp
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_struct
id|ext_wait_queue
id|wait
suffix:semicolon
r_struct
id|ext_wait_queue
op_star
id|receiver
suffix:semicolon
r_struct
id|msg_msg
op_star
id|msg_ptr
suffix:semicolon
r_struct
id|mqueue_inode_info
op_star
id|info
suffix:semicolon
r_int
id|timeout
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|msg_prio
op_ge
(paren
r_int
r_int
)paren
id|MQ_PRIO_MAX
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|timeout
op_assign
id|prepare_timeout
c_func
(paren
id|u_abs_timeout
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EBADF
suffix:semicolon
id|filp
op_assign
id|fget
c_func
(paren
id|mqdes
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|filp
)paren
)paren
r_goto
id|out
suffix:semicolon
id|inode
op_assign
id|filp-&gt;f_dentry-&gt;d_inode
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|filp-&gt;f_op
op_ne
op_amp
id|mqueue_file_operations
)paren
)paren
r_goto
id|out_fput
suffix:semicolon
id|info
op_assign
id|MQUEUE_I
c_func
(paren
id|inode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
(paren
id|filp-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
)paren
)paren
r_goto
id|out_fput
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|msg_len
OG
id|info-&gt;attr.mq_msgsize
)paren
)paren
(brace
id|ret
op_assign
op_minus
id|EMSGSIZE
suffix:semicolon
r_goto
id|out_fput
suffix:semicolon
)brace
multiline_comment|/* First try to allocate memory, before doing anything with&n;&t; * existing queues. */
id|msg_ptr
op_assign
id|load_msg
c_func
(paren
id|u_msg_ptr
comma
id|msg_len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|msg_ptr
)paren
)paren
(brace
id|ret
op_assign
id|PTR_ERR
c_func
(paren
id|msg_ptr
)paren
suffix:semicolon
r_goto
id|out_fput
suffix:semicolon
)brace
id|msg_ptr-&gt;m_ts
op_assign
id|msg_len
suffix:semicolon
id|msg_ptr-&gt;m_type
op_assign
id|msg_prio
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|info-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;attr.mq_curmsgs
op_eq
id|info-&gt;attr.mq_maxmsg
)paren
(brace
r_if
c_cond
(paren
id|filp-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
(brace
id|spin_unlock
c_func
(paren
op_amp
id|info-&gt;lock
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EAGAIN
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|timeout
OL
l_int|0
)paren
)paren
(brace
id|spin_unlock
c_func
(paren
op_amp
id|info-&gt;lock
)paren
suffix:semicolon
id|ret
op_assign
id|timeout
suffix:semicolon
)brace
r_else
(brace
id|wait.task
op_assign
id|current
suffix:semicolon
id|wait.msg
op_assign
(paren
r_void
op_star
)paren
id|msg_ptr
suffix:semicolon
id|wait.state
op_assign
id|STATE_NONE
suffix:semicolon
id|ret
op_assign
id|wq_sleep
c_func
(paren
id|info
comma
id|SEND
comma
id|timeout
comma
op_amp
id|wait
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
id|free_msg
c_func
(paren
id|msg_ptr
)paren
suffix:semicolon
)brace
r_else
(brace
id|receiver
op_assign
id|wq_get_first_waiter
c_func
(paren
id|info
comma
id|RECV
)paren
suffix:semicolon
r_if
c_cond
(paren
id|receiver
)paren
(brace
id|pipelined_send
c_func
(paren
id|info
comma
id|msg_ptr
comma
id|receiver
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* adds message to the queue */
id|msg_insert
c_func
(paren
id|msg_ptr
comma
id|info
)paren
suffix:semicolon
id|__do_notify
c_func
(paren
id|info
)paren
suffix:semicolon
)brace
id|inode-&gt;i_atime
op_assign
id|inode-&gt;i_mtime
op_assign
id|inode-&gt;i_ctime
op_assign
id|CURRENT_TIME
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|info-&gt;lock
)paren
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
)brace
id|out_fput
suffix:colon
id|fput
c_func
(paren
id|filp
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|sys_mq_timedreceive
id|asmlinkage
id|ssize_t
id|sys_mq_timedreceive
c_func
(paren
id|mqd_t
id|mqdes
comma
r_char
id|__user
op_star
id|u_msg_ptr
comma
r_int
id|msg_len
comma
r_int
r_int
id|__user
op_star
id|u_msg_prio
comma
r_const
r_struct
id|timespec
id|__user
op_star
id|u_abs_timeout
)paren
(brace
r_int
id|timeout
suffix:semicolon
id|ssize_t
id|ret
suffix:semicolon
r_struct
id|msg_msg
op_star
id|msg_ptr
suffix:semicolon
r_struct
id|file
op_star
id|filp
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_struct
id|mqueue_inode_info
op_star
id|info
suffix:semicolon
r_struct
id|ext_wait_queue
id|wait
suffix:semicolon
id|timeout
op_assign
id|prepare_timeout
c_func
(paren
id|u_abs_timeout
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EBADF
suffix:semicolon
id|filp
op_assign
id|fget
c_func
(paren
id|mqdes
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|filp
)paren
)paren
r_goto
id|out
suffix:semicolon
id|inode
op_assign
id|filp-&gt;f_dentry-&gt;d_inode
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|filp-&gt;f_op
op_ne
op_amp
id|mqueue_file_operations
)paren
)paren
r_goto
id|out_fput
suffix:semicolon
id|info
op_assign
id|MQUEUE_I
c_func
(paren
id|inode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
(paren
id|filp-&gt;f_mode
op_amp
id|FMODE_READ
)paren
)paren
)paren
r_goto
id|out_fput
suffix:semicolon
multiline_comment|/* checks if buffer is big enough */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|msg_len
OL
id|info-&gt;attr.mq_msgsize
)paren
)paren
(brace
id|ret
op_assign
op_minus
id|EMSGSIZE
suffix:semicolon
r_goto
id|out_fput
suffix:semicolon
)brace
id|spin_lock
c_func
(paren
op_amp
id|info-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;attr.mq_curmsgs
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|filp-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
(brace
id|spin_unlock
c_func
(paren
op_amp
id|info-&gt;lock
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EAGAIN
suffix:semicolon
id|msg_ptr
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|timeout
OL
l_int|0
)paren
)paren
(brace
id|spin_unlock
c_func
(paren
op_amp
id|info-&gt;lock
)paren
suffix:semicolon
id|ret
op_assign
id|timeout
suffix:semicolon
id|msg_ptr
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
(brace
id|wait.task
op_assign
id|current
suffix:semicolon
id|wait.state
op_assign
id|STATE_NONE
suffix:semicolon
id|ret
op_assign
id|wq_sleep
c_func
(paren
id|info
comma
id|RECV
comma
id|timeout
comma
op_amp
id|wait
)paren
suffix:semicolon
id|msg_ptr
op_assign
id|wait.msg
suffix:semicolon
)brace
)brace
r_else
(brace
id|msg_ptr
op_assign
id|msg_get
c_func
(paren
id|info
)paren
suffix:semicolon
id|inode-&gt;i_atime
op_assign
id|inode-&gt;i_mtime
op_assign
id|inode-&gt;i_ctime
op_assign
id|CURRENT_TIME
suffix:semicolon
multiline_comment|/* There is now free space in queue. */
id|pipelined_receive
c_func
(paren
id|info
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|info-&gt;lock
)paren
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
id|ret
op_assign
id|msg_ptr-&gt;m_ts
suffix:semicolon
r_if
c_cond
(paren
(paren
id|u_msg_prio
op_logical_and
id|put_user
c_func
(paren
id|msg_ptr-&gt;m_type
comma
id|u_msg_prio
)paren
)paren
op_logical_or
id|store_msg
c_func
(paren
id|u_msg_ptr
comma
id|msg_ptr
comma
id|msg_ptr-&gt;m_ts
)paren
)paren
(brace
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
)brace
id|free_msg
c_func
(paren
id|msg_ptr
)paren
suffix:semicolon
)brace
id|out_fput
suffix:colon
id|fput
c_func
(paren
id|filp
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Notes: the case when user wants us to deregister (with NULL as pointer)&n; * and he isn&squot;t currently owner of notification, will be silently discarded.&n; * It isn&squot;t explicitly defined in the POSIX.&n; */
DECL|function|sys_mq_notify
id|asmlinkage
r_int
id|sys_mq_notify
c_func
(paren
id|mqd_t
id|mqdes
comma
r_const
r_struct
id|sigevent
id|__user
op_star
id|u_notification
)paren
(brace
r_int
id|ret
suffix:semicolon
r_struct
id|file
op_star
id|filp
suffix:semicolon
r_struct
id|sock
op_star
id|sock
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_struct
id|sigevent
id|notification
suffix:semicolon
r_struct
id|mqueue_inode_info
op_star
id|info
suffix:semicolon
r_struct
id|sk_buff
op_star
id|nc
suffix:semicolon
id|nc
op_assign
l_int|NULL
suffix:semicolon
id|sock
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|u_notification
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|notification
comma
id|u_notification
comma
r_sizeof
(paren
r_struct
id|sigevent
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|notification.sigev_notify
op_ne
id|SIGEV_NONE
op_logical_and
id|notification.sigev_notify
op_ne
id|SIGEV_SIGNAL
op_logical_and
id|notification.sigev_notify
op_ne
id|SIGEV_THREAD
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|notification.sigev_notify
op_eq
id|SIGEV_SIGNAL
op_logical_and
(paren
id|notification.sigev_signo
template_param
id|_NSIG
)paren
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|notification.sigev_notify
op_eq
id|SIGEV_THREAD
)paren
(brace
multiline_comment|/* create the notify skb */
id|nc
op_assign
id|alloc_skb
c_func
(paren
id|NOTIFY_COOKIE_LEN
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|nc
)paren
r_goto
id|out
suffix:semicolon
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|nc-&gt;data
comma
id|notification.sigev_value.sival_ptr
comma
id|NOTIFY_COOKIE_LEN
)paren
)paren
(brace
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* TODO: add a header? */
id|skb_put
c_func
(paren
id|nc
comma
id|NOTIFY_COOKIE_LEN
)paren
suffix:semicolon
multiline_comment|/* and attach it to the socket */
id|retry
suffix:colon
id|filp
op_assign
id|fget
c_func
(paren
id|notification.sigev_signo
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EBADF
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|filp
)paren
r_goto
id|out
suffix:semicolon
id|sock
op_assign
id|netlink_getsockbyfilp
c_func
(paren
id|filp
)paren
suffix:semicolon
id|fput
c_func
(paren
id|filp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|sock
)paren
)paren
(brace
id|ret
op_assign
id|PTR_ERR
c_func
(paren
id|sock
)paren
suffix:semicolon
id|sock
op_assign
l_int|NULL
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|ret
op_assign
id|netlink_attachskb
c_func
(paren
id|sock
comma
id|nc
comma
l_int|0
comma
id|MAX_SCHEDULE_TIMEOUT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|1
)paren
r_goto
id|retry
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|sock
op_assign
l_int|NULL
suffix:semicolon
id|nc
op_assign
l_int|NULL
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
)brace
)brace
id|ret
op_assign
op_minus
id|EBADF
suffix:semicolon
id|filp
op_assign
id|fget
c_func
(paren
id|mqdes
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|filp
)paren
r_goto
id|out
suffix:semicolon
id|inode
op_assign
id|filp-&gt;f_dentry-&gt;d_inode
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|filp-&gt;f_op
op_ne
op_amp
id|mqueue_file_operations
)paren
)paren
r_goto
id|out_fput
suffix:semicolon
id|info
op_assign
id|MQUEUE_I
c_func
(paren
id|inode
)paren
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|info-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|u_notification
op_eq
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|info-&gt;notify_owner
op_eq
id|current-&gt;tgid
)paren
(brace
id|remove_notification
c_func
(paren
id|info
)paren
suffix:semicolon
id|inode-&gt;i_atime
op_assign
id|inode-&gt;i_ctime
op_assign
id|CURRENT_TIME
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|info-&gt;notify_owner
op_ne
l_int|0
)paren
(brace
id|ret
op_assign
op_minus
id|EBUSY
suffix:semicolon
)brace
r_else
(brace
r_switch
c_cond
(paren
id|notification.sigev_notify
)paren
(brace
r_case
id|SIGEV_NONE
suffix:colon
id|info-&gt;notify.sigev_notify
op_assign
id|SIGEV_NONE
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIGEV_THREAD
suffix:colon
id|info-&gt;notify_sock
op_assign
id|sock
suffix:semicolon
id|info-&gt;notify_cookie
op_assign
id|nc
suffix:semicolon
id|sock
op_assign
l_int|NULL
suffix:semicolon
id|nc
op_assign
l_int|NULL
suffix:semicolon
id|info-&gt;notify.sigev_notify
op_assign
id|SIGEV_THREAD
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIGEV_SIGNAL
suffix:colon
id|info-&gt;notify.sigev_signo
op_assign
id|notification.sigev_signo
suffix:semicolon
id|info-&gt;notify.sigev_value
op_assign
id|notification.sigev_value
suffix:semicolon
id|info-&gt;notify.sigev_notify
op_assign
id|SIGEV_SIGNAL
suffix:semicolon
r_break
suffix:semicolon
)brace
id|info-&gt;notify_owner
op_assign
id|current-&gt;tgid
suffix:semicolon
id|inode-&gt;i_atime
op_assign
id|inode-&gt;i_ctime
op_assign
id|CURRENT_TIME
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|info-&gt;lock
)paren
suffix:semicolon
id|out_fput
suffix:colon
id|fput
c_func
(paren
id|filp
)paren
suffix:semicolon
id|out
suffix:colon
r_if
c_cond
(paren
id|sock
)paren
(brace
id|netlink_detachskb
c_func
(paren
id|sock
comma
id|nc
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|nc
)paren
(brace
id|dev_kfree_skb
c_func
(paren
id|nc
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|function|sys_mq_getsetattr
id|asmlinkage
r_int
id|sys_mq_getsetattr
c_func
(paren
id|mqd_t
id|mqdes
comma
r_const
r_struct
id|mq_attr
id|__user
op_star
id|u_mqstat
comma
r_struct
id|mq_attr
id|__user
op_star
id|u_omqstat
)paren
(brace
r_int
id|ret
suffix:semicolon
r_struct
id|mq_attr
id|mqstat
comma
id|omqstat
suffix:semicolon
r_struct
id|file
op_star
id|filp
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_struct
id|mqueue_inode_info
op_star
id|info
suffix:semicolon
r_if
c_cond
(paren
id|u_mqstat
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|mqstat
comma
id|u_mqstat
comma
r_sizeof
(paren
r_struct
id|mq_attr
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|mqstat.mq_flags
op_amp
(paren
op_complement
id|O_NONBLOCK
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|ret
op_assign
op_minus
id|EBADF
suffix:semicolon
id|filp
op_assign
id|fget
c_func
(paren
id|mqdes
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|filp
)paren
r_goto
id|out
suffix:semicolon
id|inode
op_assign
id|filp-&gt;f_dentry-&gt;d_inode
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|filp-&gt;f_op
op_ne
op_amp
id|mqueue_file_operations
)paren
)paren
r_goto
id|out_fput
suffix:semicolon
id|info
op_assign
id|MQUEUE_I
c_func
(paren
id|inode
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|info-&gt;lock
)paren
suffix:semicolon
id|omqstat
op_assign
id|info-&gt;attr
suffix:semicolon
id|omqstat.mq_flags
op_assign
id|filp-&gt;f_flags
op_amp
id|O_NONBLOCK
suffix:semicolon
r_if
c_cond
(paren
id|u_mqstat
)paren
(brace
r_if
c_cond
(paren
id|mqstat.mq_flags
op_amp
id|O_NONBLOCK
)paren
id|filp-&gt;f_flags
op_or_assign
id|O_NONBLOCK
suffix:semicolon
r_else
id|filp-&gt;f_flags
op_and_assign
op_complement
id|O_NONBLOCK
suffix:semicolon
id|inode-&gt;i_atime
op_assign
id|inode-&gt;i_ctime
op_assign
id|CURRENT_TIME
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|info-&gt;lock
)paren
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|u_omqstat
op_ne
l_int|NULL
op_logical_and
id|copy_to_user
c_func
(paren
id|u_omqstat
comma
op_amp
id|omqstat
comma
r_sizeof
(paren
r_struct
id|mq_attr
)paren
)paren
)paren
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
id|out_fput
suffix:colon
id|fput
c_func
(paren
id|filp
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|ret
suffix:semicolon
)brace
DECL|variable|mqueue_dir_inode_operations
r_static
r_struct
id|inode_operations
id|mqueue_dir_inode_operations
op_assign
(brace
dot
id|lookup
op_assign
id|simple_lookup
comma
dot
id|create
op_assign
id|mqueue_create
comma
dot
id|unlink
op_assign
id|mqueue_unlink
comma
)brace
suffix:semicolon
DECL|variable|mqueue_file_operations
r_static
r_struct
id|file_operations
id|mqueue_file_operations
op_assign
(brace
dot
id|flush
op_assign
id|mqueue_flush_file
comma
dot
id|poll
op_assign
id|mqueue_poll_file
comma
dot
id|read
op_assign
id|mqueue_read_file
comma
)brace
suffix:semicolon
DECL|variable|mqueue_super_ops
r_static
r_struct
id|super_operations
id|mqueue_super_ops
op_assign
(brace
dot
id|alloc_inode
op_assign
id|mqueue_alloc_inode
comma
dot
id|destroy_inode
op_assign
id|mqueue_destroy_inode
comma
dot
id|statfs
op_assign
id|simple_statfs
comma
dot
id|delete_inode
op_assign
id|mqueue_delete_inode
comma
dot
id|drop_inode
op_assign
id|generic_delete_inode
comma
)brace
suffix:semicolon
DECL|variable|mqueue_fs_type
r_static
r_struct
id|file_system_type
id|mqueue_fs_type
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;mqueue&quot;
comma
dot
id|get_sb
op_assign
id|mqueue_get_sb
comma
dot
id|kill_sb
op_assign
id|kill_litter_super
comma
)brace
suffix:semicolon
DECL|variable|msg_max_limit_min
r_static
r_int
id|msg_max_limit_min
op_assign
id|DFLT_MSGMAX
suffix:semicolon
DECL|variable|msg_max_limit_max
r_static
r_int
id|msg_max_limit_max
op_assign
id|HARD_MSGMAX
suffix:semicolon
DECL|variable|msg_maxsize_limit_min
r_static
r_int
id|msg_maxsize_limit_min
op_assign
id|DFLT_MSGSIZEMAX
suffix:semicolon
DECL|variable|msg_maxsize_limit_max
r_static
r_int
id|msg_maxsize_limit_max
op_assign
id|INT_MAX
suffix:semicolon
DECL|variable|mq_sysctls
r_static
id|ctl_table
id|mq_sysctls
(braket
)braket
op_assign
(brace
(brace
dot
id|ctl_name
op_assign
id|CTL_QUEUESMAX
comma
dot
id|procname
op_assign
l_string|&quot;queues_max&quot;
comma
dot
id|data
op_assign
op_amp
id|queues_max
comma
dot
id|maxlen
op_assign
r_sizeof
(paren
r_int
)paren
comma
dot
id|mode
op_assign
l_int|0644
comma
dot
id|proc_handler
op_assign
op_amp
id|proc_dointvec
comma
)brace
comma
(brace
dot
id|ctl_name
op_assign
id|CTL_MSGMAX
comma
dot
id|procname
op_assign
l_string|&quot;msg_max&quot;
comma
dot
id|data
op_assign
op_amp
id|msg_max
comma
dot
id|maxlen
op_assign
r_sizeof
(paren
r_int
)paren
comma
dot
id|mode
op_assign
l_int|0644
comma
dot
id|proc_handler
op_assign
op_amp
id|proc_dointvec_minmax
comma
dot
id|extra1
op_assign
op_amp
id|msg_max_limit_min
comma
dot
id|extra2
op_assign
op_amp
id|msg_max_limit_max
comma
)brace
comma
(brace
dot
id|ctl_name
op_assign
id|CTL_MSGSIZEMAX
comma
dot
id|procname
op_assign
l_string|&quot;msgsize_max&quot;
comma
dot
id|data
op_assign
op_amp
id|msgsize_max
comma
dot
id|maxlen
op_assign
r_sizeof
(paren
r_int
)paren
comma
dot
id|mode
op_assign
l_int|0644
comma
dot
id|proc_handler
op_assign
op_amp
id|proc_dointvec_minmax
comma
dot
id|extra1
op_assign
op_amp
id|msg_maxsize_limit_min
comma
dot
id|extra2
op_assign
op_amp
id|msg_maxsize_limit_max
comma
)brace
comma
(brace
dot
id|ctl_name
op_assign
l_int|0
)brace
)brace
suffix:semicolon
DECL|variable|mq_sysctl_dir
r_static
id|ctl_table
id|mq_sysctl_dir
(braket
)braket
op_assign
(brace
(brace
dot
id|ctl_name
op_assign
id|FS_MQUEUE
comma
dot
id|procname
op_assign
l_string|&quot;mqueue&quot;
comma
dot
id|mode
op_assign
l_int|0555
comma
dot
id|child
op_assign
id|mq_sysctls
comma
)brace
comma
(brace
dot
id|ctl_name
op_assign
l_int|0
)brace
)brace
suffix:semicolon
DECL|variable|mq_sysctl_root
r_static
id|ctl_table
id|mq_sysctl_root
(braket
)braket
op_assign
(brace
(brace
dot
id|ctl_name
op_assign
id|CTL_FS
comma
dot
id|procname
op_assign
l_string|&quot;fs&quot;
comma
dot
id|mode
op_assign
l_int|0555
comma
dot
id|child
op_assign
id|mq_sysctl_dir
comma
)brace
comma
(brace
dot
id|ctl_name
op_assign
l_int|0
)brace
)brace
suffix:semicolon
DECL|function|init_mqueue_fs
r_static
r_int
id|__init
id|init_mqueue_fs
c_func
(paren
r_void
)paren
(brace
r_int
id|error
suffix:semicolon
id|mqueue_inode_cachep
op_assign
id|kmem_cache_create
c_func
(paren
l_string|&quot;mqueue_inode_cache&quot;
comma
r_sizeof
(paren
r_struct
id|mqueue_inode_info
)paren
comma
l_int|0
comma
id|SLAB_HWCACHE_ALIGN
comma
id|init_once
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mqueue_inode_cachep
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
multiline_comment|/* ignore failues - they are not fatal */
id|mq_sysctl_table
op_assign
id|register_sysctl_table
c_func
(paren
id|mq_sysctl_root
comma
l_int|0
)paren
suffix:semicolon
id|error
op_assign
id|register_filesystem
c_func
(paren
op_amp
id|mqueue_fs_type
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|out_sysctl
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|mqueue_mnt
op_assign
id|kern_mount
c_func
(paren
op_amp
id|mqueue_fs_type
)paren
)paren
)paren
(brace
id|error
op_assign
id|PTR_ERR
c_func
(paren
id|mqueue_mnt
)paren
suffix:semicolon
r_goto
id|out_filesystem
suffix:semicolon
)brace
multiline_comment|/* internal initialization - not common for vfs */
id|queues_count
op_assign
l_int|0
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|mq_lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|out_filesystem
suffix:colon
id|unregister_filesystem
c_func
(paren
op_amp
id|mqueue_fs_type
)paren
suffix:semicolon
id|out_sysctl
suffix:colon
r_if
c_cond
(paren
id|mq_sysctl_table
)paren
id|unregister_sysctl_table
c_func
(paren
id|mq_sysctl_table
)paren
suffix:semicolon
r_if
c_cond
(paren
id|kmem_cache_destroy
c_func
(paren
id|mqueue_inode_cachep
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;mqueue_inode_cache: not all structures were freed&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_return
id|error
suffix:semicolon
)brace
DECL|variable|init_mqueue_fs
id|__initcall
c_func
(paren
id|init_mqueue_fs
)paren
suffix:semicolon
eof
