multiline_comment|/*&n; * linux/ipc/msg.c&n; * Copyright (C) 1992 Krishna Balasubramanian &n; *&n; * Removed all the remaining kerneld mess&n; * Catch the -EFAULT stuff properly&n; * Use GFP_KERNEL for messages as in 1.2&n; * Fixed up the unchecked user space derefs&n; * Copyright (C) 1998 Alan Cox &amp; Andi Kleen&n; *&n; * /proc/sysvipc/msg support (c) 1999 Dragos Acostachioaie &lt;dragos@iname.com&gt;&n; *&n; * mostly rewritten, threaded and wake-one semantics added&n; * MSGMAX limit removed, sysctl&squot;s added&n; * (c) 1999 Manfred Spraul &lt;manfreds@colorfullife.com&gt;&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/msg.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;linux/list.h&gt;
macro_line|#include &lt;linux/security.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/syscalls.h&gt;
macro_line|#include &lt;asm/current.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &quot;util.h&quot;
multiline_comment|/* sysctl: */
DECL|variable|msg_ctlmax
r_int
id|msg_ctlmax
op_assign
id|MSGMAX
suffix:semicolon
DECL|variable|msg_ctlmnb
r_int
id|msg_ctlmnb
op_assign
id|MSGMNB
suffix:semicolon
DECL|variable|msg_ctlmni
r_int
id|msg_ctlmni
op_assign
id|MSGMNI
suffix:semicolon
multiline_comment|/* one msg_receiver structure for each sleeping receiver */
DECL|struct|msg_receiver
r_struct
id|msg_receiver
(brace
DECL|member|r_list
r_struct
id|list_head
id|r_list
suffix:semicolon
DECL|member|r_tsk
r_struct
id|task_struct
op_star
id|r_tsk
suffix:semicolon
DECL|member|r_mode
r_int
id|r_mode
suffix:semicolon
DECL|member|r_msgtype
r_int
id|r_msgtype
suffix:semicolon
DECL|member|r_maxsize
r_int
id|r_maxsize
suffix:semicolon
DECL|member|r_msg
r_struct
id|msg_msg
op_star
r_volatile
id|r_msg
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* one msg_sender for each sleeping sender */
DECL|struct|msg_sender
r_struct
id|msg_sender
(brace
DECL|member|list
r_struct
id|list_head
id|list
suffix:semicolon
DECL|member|tsk
r_struct
id|task_struct
op_star
id|tsk
suffix:semicolon
)brace
suffix:semicolon
DECL|macro|SEARCH_ANY
mdefine_line|#define SEARCH_ANY&t;&t;1
DECL|macro|SEARCH_EQUAL
mdefine_line|#define SEARCH_EQUAL&t;&t;2
DECL|macro|SEARCH_NOTEQUAL
mdefine_line|#define SEARCH_NOTEQUAL&t;&t;3
DECL|macro|SEARCH_LESSEQUAL
mdefine_line|#define SEARCH_LESSEQUAL&t;4
DECL|variable|msg_bytes
r_static
id|atomic_t
id|msg_bytes
op_assign
id|ATOMIC_INIT
c_func
(paren
l_int|0
)paren
suffix:semicolon
DECL|variable|msg_hdrs
r_static
id|atomic_t
id|msg_hdrs
op_assign
id|ATOMIC_INIT
c_func
(paren
l_int|0
)paren
suffix:semicolon
DECL|variable|msg_ids
r_static
r_struct
id|ipc_ids
id|msg_ids
suffix:semicolon
DECL|macro|msg_lock
mdefine_line|#define msg_lock(id)&t;((struct msg_queue*)ipc_lock(&amp;msg_ids,id))
DECL|macro|msg_unlock
mdefine_line|#define msg_unlock(msq)&t;ipc_unlock(&amp;(msq)-&gt;q_perm)
DECL|macro|msg_rmid
mdefine_line|#define msg_rmid(id)&t;((struct msg_queue*)ipc_rmid(&amp;msg_ids,id))
DECL|macro|msg_checkid
mdefine_line|#define msg_checkid(msq, msgid)&t;&bslash;&n;&t;ipc_checkid(&amp;msg_ids,&amp;msq-&gt;q_perm,msgid)
DECL|macro|msg_buildid
mdefine_line|#define msg_buildid(id, seq) &bslash;&n;&t;ipc_buildid(&amp;msg_ids, id, seq)
r_static
r_void
id|freeque
(paren
r_struct
id|msg_queue
op_star
id|msq
comma
r_int
id|id
)paren
suffix:semicolon
r_static
r_int
id|newque
(paren
id|key_t
id|key
comma
r_int
id|msgflg
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_PROC_FS
r_static
r_int
id|sysvipc_msg_read_proc
c_func
(paren
r_char
op_star
id|buffer
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|length
comma
r_int
op_star
id|eof
comma
r_void
op_star
id|data
)paren
suffix:semicolon
macro_line|#endif
DECL|function|msg_init
r_void
id|__init
id|msg_init
(paren
r_void
)paren
(brace
id|ipc_init_ids
c_func
(paren
op_amp
id|msg_ids
comma
id|msg_ctlmni
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_PROC_FS
id|create_proc_read_entry
c_func
(paren
l_string|&quot;sysvipc/msg&quot;
comma
l_int|0
comma
l_int|NULL
comma
id|sysvipc_msg_read_proc
comma
l_int|NULL
)paren
suffix:semicolon
macro_line|#endif
)brace
DECL|function|newque
r_static
r_int
id|newque
(paren
id|key_t
id|key
comma
r_int
id|msgflg
)paren
(brace
r_int
id|id
suffix:semicolon
r_int
id|retval
suffix:semicolon
r_struct
id|msg_queue
op_star
id|msq
suffix:semicolon
id|msq
op_assign
id|ipc_rcu_alloc
c_func
(paren
r_sizeof
(paren
op_star
id|msq
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|msq
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|msq-&gt;q_perm.mode
op_assign
(paren
id|msgflg
op_amp
id|S_IRWXUGO
)paren
suffix:semicolon
id|msq-&gt;q_perm.key
op_assign
id|key
suffix:semicolon
id|msq-&gt;q_perm.security
op_assign
l_int|NULL
suffix:semicolon
id|retval
op_assign
id|security_msg_queue_alloc
c_func
(paren
id|msq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
(brace
id|ipc_rcu_putref
c_func
(paren
id|msq
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
id|id
op_assign
id|ipc_addid
c_func
(paren
op_amp
id|msg_ids
comma
op_amp
id|msq-&gt;q_perm
comma
id|msg_ctlmni
)paren
suffix:semicolon
r_if
c_cond
(paren
id|id
op_eq
op_minus
l_int|1
)paren
(brace
id|security_msg_queue_free
c_func
(paren
id|msq
)paren
suffix:semicolon
id|ipc_rcu_putref
c_func
(paren
id|msq
)paren
suffix:semicolon
r_return
op_minus
id|ENOSPC
suffix:semicolon
)brace
id|msq-&gt;q_stime
op_assign
id|msq-&gt;q_rtime
op_assign
l_int|0
suffix:semicolon
id|msq-&gt;q_ctime
op_assign
id|get_seconds
c_func
(paren
)paren
suffix:semicolon
id|msq-&gt;q_cbytes
op_assign
id|msq-&gt;q_qnum
op_assign
l_int|0
suffix:semicolon
id|msq-&gt;q_qbytes
op_assign
id|msg_ctlmnb
suffix:semicolon
id|msq-&gt;q_lspid
op_assign
id|msq-&gt;q_lrpid
op_assign
l_int|0
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|msq-&gt;q_messages
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|msq-&gt;q_receivers
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|msq-&gt;q_senders
)paren
suffix:semicolon
id|msg_unlock
c_func
(paren
id|msq
)paren
suffix:semicolon
r_return
id|msg_buildid
c_func
(paren
id|id
comma
id|msq-&gt;q_perm.seq
)paren
suffix:semicolon
)brace
DECL|function|ss_add
r_static
r_inline
r_void
id|ss_add
c_func
(paren
r_struct
id|msg_queue
op_star
id|msq
comma
r_struct
id|msg_sender
op_star
id|mss
)paren
(brace
id|mss-&gt;tsk
op_assign
id|current
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|mss-&gt;list
comma
op_amp
id|msq-&gt;q_senders
)paren
suffix:semicolon
)brace
DECL|function|ss_del
r_static
r_inline
r_void
id|ss_del
c_func
(paren
r_struct
id|msg_sender
op_star
id|mss
)paren
(brace
r_if
c_cond
(paren
id|mss-&gt;list.next
op_ne
l_int|NULL
)paren
(brace
id|list_del
c_func
(paren
op_amp
id|mss-&gt;list
)paren
suffix:semicolon
)brace
)brace
DECL|function|ss_wakeup
r_static
r_void
id|ss_wakeup
c_func
(paren
r_struct
id|list_head
op_star
id|h
comma
r_int
id|kill
)paren
(brace
r_struct
id|list_head
op_star
id|tmp
suffix:semicolon
id|tmp
op_assign
id|h-&gt;next
suffix:semicolon
r_while
c_loop
(paren
id|tmp
op_ne
id|h
)paren
(brace
r_struct
id|msg_sender
op_star
id|mss
suffix:semicolon
id|mss
op_assign
id|list_entry
c_func
(paren
id|tmp
comma
r_struct
id|msg_sender
comma
id|list
)paren
suffix:semicolon
id|tmp
op_assign
id|tmp-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|kill
)paren
(brace
id|mss-&gt;list.next
op_assign
l_int|NULL
suffix:semicolon
)brace
id|wake_up_process
c_func
(paren
id|mss-&gt;tsk
)paren
suffix:semicolon
)brace
)brace
DECL|function|expunge_all
r_static
r_void
id|expunge_all
c_func
(paren
r_struct
id|msg_queue
op_star
id|msq
comma
r_int
id|res
)paren
(brace
r_struct
id|list_head
op_star
id|tmp
suffix:semicolon
id|tmp
op_assign
id|msq-&gt;q_receivers.next
suffix:semicolon
r_while
c_loop
(paren
id|tmp
op_ne
op_amp
id|msq-&gt;q_receivers
)paren
(brace
r_struct
id|msg_receiver
op_star
id|msr
suffix:semicolon
id|msr
op_assign
id|list_entry
c_func
(paren
id|tmp
comma
r_struct
id|msg_receiver
comma
id|r_list
)paren
suffix:semicolon
id|tmp
op_assign
id|tmp-&gt;next
suffix:semicolon
id|msr-&gt;r_msg
op_assign
l_int|NULL
suffix:semicolon
id|wake_up_process
c_func
(paren
id|msr-&gt;r_tsk
)paren
suffix:semicolon
id|smp_mb
c_func
(paren
)paren
suffix:semicolon
id|msr-&gt;r_msg
op_assign
id|ERR_PTR
c_func
(paren
id|res
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* &n; * freeque() wakes up waiters on the sender and receiver waiting queue, &n; * removes the message queue from message queue ID &n; * array, and cleans up all the messages associated with this queue.&n; *&n; * msg_ids.sem and the spinlock for this message queue is hold&n; * before freeque() is called. msg_ids.sem remains locked on exit.&n; */
DECL|function|freeque
r_static
r_void
id|freeque
(paren
r_struct
id|msg_queue
op_star
id|msq
comma
r_int
id|id
)paren
(brace
r_struct
id|list_head
op_star
id|tmp
suffix:semicolon
id|expunge_all
c_func
(paren
id|msq
comma
op_minus
id|EIDRM
)paren
suffix:semicolon
id|ss_wakeup
c_func
(paren
op_amp
id|msq-&gt;q_senders
comma
l_int|1
)paren
suffix:semicolon
id|msq
op_assign
id|msg_rmid
c_func
(paren
id|id
)paren
suffix:semicolon
id|msg_unlock
c_func
(paren
id|msq
)paren
suffix:semicolon
id|tmp
op_assign
id|msq-&gt;q_messages.next
suffix:semicolon
r_while
c_loop
(paren
id|tmp
op_ne
op_amp
id|msq-&gt;q_messages
)paren
(brace
r_struct
id|msg_msg
op_star
id|msg
op_assign
id|list_entry
c_func
(paren
id|tmp
comma
r_struct
id|msg_msg
comma
id|m_list
)paren
suffix:semicolon
id|tmp
op_assign
id|tmp-&gt;next
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|msg_hdrs
)paren
suffix:semicolon
id|free_msg
c_func
(paren
id|msg
)paren
suffix:semicolon
)brace
id|atomic_sub
c_func
(paren
id|msq-&gt;q_cbytes
comma
op_amp
id|msg_bytes
)paren
suffix:semicolon
id|security_msg_queue_free
c_func
(paren
id|msq
)paren
suffix:semicolon
id|ipc_rcu_putref
c_func
(paren
id|msq
)paren
suffix:semicolon
)brace
DECL|function|sys_msgget
id|asmlinkage
r_int
id|sys_msgget
(paren
id|key_t
id|key
comma
r_int
id|msgflg
)paren
(brace
r_int
id|id
comma
id|ret
op_assign
op_minus
id|EPERM
suffix:semicolon
r_struct
id|msg_queue
op_star
id|msq
suffix:semicolon
id|down
c_func
(paren
op_amp
id|msg_ids.sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|key
op_eq
id|IPC_PRIVATE
)paren
id|ret
op_assign
id|newque
c_func
(paren
id|key
comma
id|msgflg
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|id
op_assign
id|ipc_findkey
c_func
(paren
op_amp
id|msg_ids
comma
id|key
)paren
)paren
op_eq
op_minus
l_int|1
)paren
(brace
multiline_comment|/* key not used */
r_if
c_cond
(paren
op_logical_neg
(paren
id|msgflg
op_amp
id|IPC_CREAT
)paren
)paren
id|ret
op_assign
op_minus
id|ENOENT
suffix:semicolon
r_else
id|ret
op_assign
id|newque
c_func
(paren
id|key
comma
id|msgflg
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|msgflg
op_amp
id|IPC_CREAT
op_logical_and
id|msgflg
op_amp
id|IPC_EXCL
)paren
(brace
id|ret
op_assign
op_minus
id|EEXIST
suffix:semicolon
)brace
r_else
(brace
id|msq
op_assign
id|msg_lock
c_func
(paren
id|id
)paren
suffix:semicolon
r_if
c_cond
(paren
id|msq
op_eq
l_int|NULL
)paren
(brace
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ipcperms
c_func
(paren
op_amp
id|msq-&gt;q_perm
comma
id|msgflg
)paren
)paren
id|ret
op_assign
op_minus
id|EACCES
suffix:semicolon
r_else
(brace
r_int
id|qid
op_assign
id|msg_buildid
c_func
(paren
id|id
comma
id|msq-&gt;q_perm.seq
)paren
suffix:semicolon
id|ret
op_assign
id|security_msg_queue_associate
c_func
(paren
id|msq
comma
id|msgflg
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
id|ret
op_assign
id|qid
suffix:semicolon
)brace
id|msg_unlock
c_func
(paren
id|msq
)paren
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|msg_ids.sem
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|copy_msqid_to_user
r_static
r_inline
r_int
r_int
id|copy_msqid_to_user
c_func
(paren
r_void
id|__user
op_star
id|buf
comma
r_struct
id|msqid64_ds
op_star
id|in
comma
r_int
id|version
)paren
(brace
r_switch
c_cond
(paren
id|version
)paren
(brace
r_case
id|IPC_64
suffix:colon
r_return
id|copy_to_user
(paren
id|buf
comma
id|in
comma
r_sizeof
(paren
op_star
id|in
)paren
)paren
suffix:semicolon
r_case
id|IPC_OLD
suffix:colon
(brace
r_struct
id|msqid_ds
id|out
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|out
comma
l_int|0
comma
r_sizeof
(paren
id|out
)paren
)paren
suffix:semicolon
id|ipc64_perm_to_ipc_perm
c_func
(paren
op_amp
id|in-&gt;msg_perm
comma
op_amp
id|out.msg_perm
)paren
suffix:semicolon
id|out.msg_stime
op_assign
id|in-&gt;msg_stime
suffix:semicolon
id|out.msg_rtime
op_assign
id|in-&gt;msg_rtime
suffix:semicolon
id|out.msg_ctime
op_assign
id|in-&gt;msg_ctime
suffix:semicolon
r_if
c_cond
(paren
id|in-&gt;msg_cbytes
OG
id|USHRT_MAX
)paren
(brace
id|out.msg_cbytes
op_assign
id|USHRT_MAX
suffix:semicolon
)brace
r_else
id|out.msg_cbytes
op_assign
id|in-&gt;msg_cbytes
suffix:semicolon
id|out.msg_lcbytes
op_assign
id|in-&gt;msg_cbytes
suffix:semicolon
r_if
c_cond
(paren
id|in-&gt;msg_qnum
OG
id|USHRT_MAX
)paren
(brace
id|out.msg_qnum
op_assign
id|USHRT_MAX
suffix:semicolon
)brace
r_else
id|out.msg_qnum
op_assign
id|in-&gt;msg_qnum
suffix:semicolon
r_if
c_cond
(paren
id|in-&gt;msg_qbytes
OG
id|USHRT_MAX
)paren
(brace
id|out.msg_qbytes
op_assign
id|USHRT_MAX
suffix:semicolon
)brace
r_else
id|out.msg_qbytes
op_assign
id|in-&gt;msg_qbytes
suffix:semicolon
id|out.msg_lqbytes
op_assign
id|in-&gt;msg_qbytes
suffix:semicolon
id|out.msg_lspid
op_assign
id|in-&gt;msg_lspid
suffix:semicolon
id|out.msg_lrpid
op_assign
id|in-&gt;msg_lrpid
suffix:semicolon
r_return
id|copy_to_user
(paren
id|buf
comma
op_amp
id|out
comma
r_sizeof
(paren
id|out
)paren
)paren
suffix:semicolon
)brace
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
DECL|struct|msq_setbuf
r_struct
id|msq_setbuf
(brace
DECL|member|qbytes
r_int
r_int
id|qbytes
suffix:semicolon
DECL|member|uid
id|uid_t
id|uid
suffix:semicolon
DECL|member|gid
id|gid_t
id|gid
suffix:semicolon
DECL|member|mode
id|mode_t
id|mode
suffix:semicolon
)brace
suffix:semicolon
DECL|function|copy_msqid_from_user
r_static
r_inline
r_int
r_int
id|copy_msqid_from_user
c_func
(paren
r_struct
id|msq_setbuf
op_star
id|out
comma
r_void
id|__user
op_star
id|buf
comma
r_int
id|version
)paren
(brace
r_switch
c_cond
(paren
id|version
)paren
(brace
r_case
id|IPC_64
suffix:colon
(brace
r_struct
id|msqid64_ds
id|tbuf
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
(paren
op_amp
id|tbuf
comma
id|buf
comma
r_sizeof
(paren
id|tbuf
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|out-&gt;qbytes
op_assign
id|tbuf.msg_qbytes
suffix:semicolon
id|out-&gt;uid
op_assign
id|tbuf.msg_perm.uid
suffix:semicolon
id|out-&gt;gid
op_assign
id|tbuf.msg_perm.gid
suffix:semicolon
id|out-&gt;mode
op_assign
id|tbuf.msg_perm.mode
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|IPC_OLD
suffix:colon
(brace
r_struct
id|msqid_ds
id|tbuf_old
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
(paren
op_amp
id|tbuf_old
comma
id|buf
comma
r_sizeof
(paren
id|tbuf_old
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|out-&gt;uid
op_assign
id|tbuf_old.msg_perm.uid
suffix:semicolon
id|out-&gt;gid
op_assign
id|tbuf_old.msg_perm.gid
suffix:semicolon
id|out-&gt;mode
op_assign
id|tbuf_old.msg_perm.mode
suffix:semicolon
r_if
c_cond
(paren
id|tbuf_old.msg_qbytes
op_eq
l_int|0
)paren
(brace
id|out-&gt;qbytes
op_assign
id|tbuf_old.msg_lqbytes
suffix:semicolon
)brace
r_else
id|out-&gt;qbytes
op_assign
id|tbuf_old.msg_qbytes
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
DECL|function|sys_msgctl
id|asmlinkage
r_int
id|sys_msgctl
(paren
r_int
id|msqid
comma
r_int
id|cmd
comma
r_struct
id|msqid_ds
id|__user
op_star
id|buf
)paren
(brace
r_int
id|err
comma
id|version
suffix:semicolon
r_struct
id|msg_queue
op_star
id|msq
suffix:semicolon
r_struct
id|msq_setbuf
id|setbuf
suffix:semicolon
r_struct
id|kern_ipc_perm
op_star
id|ipcp
suffix:semicolon
r_if
c_cond
(paren
id|msqid
OL
l_int|0
op_logical_or
id|cmd
OL
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|version
op_assign
id|ipc_parse_version
c_func
(paren
op_amp
id|cmd
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|IPC_INFO
suffix:colon
r_case
id|MSG_INFO
suffix:colon
(brace
r_struct
id|msginfo
id|msginfo
suffix:semicolon
r_int
id|max_id
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buf
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
multiline_comment|/* We must not return kernel stack data.&n;&t;&t; * due to padding, it&squot;s not enough&n;&t;&t; * to set all member fields.&n;&t;&t; */
id|err
op_assign
id|security_msg_queue_msgctl
c_func
(paren
l_int|NULL
comma
id|cmd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|msginfo
comma
l_int|0
comma
r_sizeof
(paren
id|msginfo
)paren
)paren
suffix:semicolon
id|msginfo.msgmni
op_assign
id|msg_ctlmni
suffix:semicolon
id|msginfo.msgmax
op_assign
id|msg_ctlmax
suffix:semicolon
id|msginfo.msgmnb
op_assign
id|msg_ctlmnb
suffix:semicolon
id|msginfo.msgssz
op_assign
id|MSGSSZ
suffix:semicolon
id|msginfo.msgseg
op_assign
id|MSGSEG
suffix:semicolon
id|down
c_func
(paren
op_amp
id|msg_ids.sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_eq
id|MSG_INFO
)paren
(brace
id|msginfo.msgpool
op_assign
id|msg_ids.in_use
suffix:semicolon
id|msginfo.msgmap
op_assign
id|atomic_read
c_func
(paren
op_amp
id|msg_hdrs
)paren
suffix:semicolon
id|msginfo.msgtql
op_assign
id|atomic_read
c_func
(paren
op_amp
id|msg_bytes
)paren
suffix:semicolon
)brace
r_else
(brace
id|msginfo.msgmap
op_assign
id|MSGMAP
suffix:semicolon
id|msginfo.msgpool
op_assign
id|MSGPOOL
suffix:semicolon
id|msginfo.msgtql
op_assign
id|MSGTQL
suffix:semicolon
)brace
id|max_id
op_assign
id|msg_ids.max_id
suffix:semicolon
id|up
c_func
(paren
op_amp
id|msg_ids.sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
(paren
id|buf
comma
op_amp
id|msginfo
comma
r_sizeof
(paren
r_struct
id|msginfo
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
(paren
id|max_id
OL
l_int|0
)paren
ques
c_cond
l_int|0
suffix:colon
id|max_id
suffix:semicolon
)brace
r_case
id|MSG_STAT
suffix:colon
r_case
id|IPC_STAT
suffix:colon
(brace
r_struct
id|msqid64_ds
id|tbuf
suffix:semicolon
r_int
id|success_return
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buf
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_eq
id|MSG_STAT
op_logical_and
id|msqid
op_ge
id|msg_ids.entries-&gt;size
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|memset
c_func
(paren
op_amp
id|tbuf
comma
l_int|0
comma
r_sizeof
(paren
id|tbuf
)paren
)paren
suffix:semicolon
id|msq
op_assign
id|msg_lock
c_func
(paren
id|msqid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|msq
op_eq
l_int|NULL
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_eq
id|MSG_STAT
)paren
(brace
id|success_return
op_assign
id|msg_buildid
c_func
(paren
id|msqid
comma
id|msq-&gt;q_perm.seq
)paren
suffix:semicolon
)brace
r_else
(brace
id|err
op_assign
op_minus
id|EIDRM
suffix:semicolon
r_if
c_cond
(paren
id|msg_checkid
c_func
(paren
id|msq
comma
id|msqid
)paren
)paren
r_goto
id|out_unlock
suffix:semicolon
id|success_return
op_assign
l_int|0
suffix:semicolon
)brace
id|err
op_assign
op_minus
id|EACCES
suffix:semicolon
r_if
c_cond
(paren
id|ipcperms
(paren
op_amp
id|msq-&gt;q_perm
comma
id|S_IRUGO
)paren
)paren
r_goto
id|out_unlock
suffix:semicolon
id|err
op_assign
id|security_msg_queue_msgctl
c_func
(paren
id|msq
comma
id|cmd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out_unlock
suffix:semicolon
id|kernel_to_ipc64_perm
c_func
(paren
op_amp
id|msq-&gt;q_perm
comma
op_amp
id|tbuf.msg_perm
)paren
suffix:semicolon
id|tbuf.msg_stime
op_assign
id|msq-&gt;q_stime
suffix:semicolon
id|tbuf.msg_rtime
op_assign
id|msq-&gt;q_rtime
suffix:semicolon
id|tbuf.msg_ctime
op_assign
id|msq-&gt;q_ctime
suffix:semicolon
id|tbuf.msg_cbytes
op_assign
id|msq-&gt;q_cbytes
suffix:semicolon
id|tbuf.msg_qnum
op_assign
id|msq-&gt;q_qnum
suffix:semicolon
id|tbuf.msg_qbytes
op_assign
id|msq-&gt;q_qbytes
suffix:semicolon
id|tbuf.msg_lspid
op_assign
id|msq-&gt;q_lspid
suffix:semicolon
id|tbuf.msg_lrpid
op_assign
id|msq-&gt;q_lrpid
suffix:semicolon
id|msg_unlock
c_func
(paren
id|msq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_msqid_to_user
c_func
(paren
id|buf
comma
op_amp
id|tbuf
comma
id|version
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
id|success_return
suffix:semicolon
)brace
r_case
id|IPC_SET
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|buf
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|copy_msqid_from_user
(paren
op_amp
id|setbuf
comma
id|buf
comma
id|version
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IPC_RMID
suffix:colon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|down
c_func
(paren
op_amp
id|msg_ids.sem
)paren
suffix:semicolon
id|msq
op_assign
id|msg_lock
c_func
(paren
id|msqid
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|msq
op_eq
l_int|NULL
)paren
r_goto
id|out_up
suffix:semicolon
id|err
op_assign
op_minus
id|EIDRM
suffix:semicolon
r_if
c_cond
(paren
id|msg_checkid
c_func
(paren
id|msq
comma
id|msqid
)paren
)paren
r_goto
id|out_unlock_up
suffix:semicolon
id|ipcp
op_assign
op_amp
id|msq-&gt;q_perm
suffix:semicolon
id|err
op_assign
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;euid
op_ne
id|ipcp-&gt;cuid
op_logical_and
id|current-&gt;euid
op_ne
id|ipcp-&gt;uid
op_logical_and
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_ADMIN
)paren
)paren
multiline_comment|/* We _could_ check for CAP_CHOWN above, but we don&squot;t */
r_goto
id|out_unlock_up
suffix:semicolon
id|err
op_assign
id|security_msg_queue_msgctl
c_func
(paren
id|msq
comma
id|cmd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out_unlock_up
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|IPC_SET
suffix:colon
(brace
id|err
op_assign
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|setbuf.qbytes
OG
id|msg_ctlmnb
op_logical_and
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_RESOURCE
)paren
)paren
r_goto
id|out_unlock_up
suffix:semicolon
id|msq-&gt;q_qbytes
op_assign
id|setbuf.qbytes
suffix:semicolon
id|ipcp-&gt;uid
op_assign
id|setbuf.uid
suffix:semicolon
id|ipcp-&gt;gid
op_assign
id|setbuf.gid
suffix:semicolon
id|ipcp-&gt;mode
op_assign
(paren
id|ipcp-&gt;mode
op_amp
op_complement
id|S_IRWXUGO
)paren
op_or
(paren
id|S_IRWXUGO
op_amp
id|setbuf.mode
)paren
suffix:semicolon
id|msq-&gt;q_ctime
op_assign
id|get_seconds
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* sleeping receivers might be excluded by&n;&t;&t; * stricter permissions.&n;&t;&t; */
id|expunge_all
c_func
(paren
id|msq
comma
op_minus
id|EAGAIN
)paren
suffix:semicolon
multiline_comment|/* sleeping senders might be able to send&n;&t;&t; * due to a larger queue size.&n;&t;&t; */
id|ss_wakeup
c_func
(paren
op_amp
id|msq-&gt;q_senders
comma
l_int|0
)paren
suffix:semicolon
id|msg_unlock
c_func
(paren
id|msq
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|IPC_RMID
suffix:colon
id|freeque
(paren
id|msq
comma
id|msqid
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|err
op_assign
l_int|0
suffix:semicolon
id|out_up
suffix:colon
id|up
c_func
(paren
op_amp
id|msg_ids.sem
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
id|out_unlock_up
suffix:colon
id|msg_unlock
c_func
(paren
id|msq
)paren
suffix:semicolon
r_goto
id|out_up
suffix:semicolon
id|out_unlock
suffix:colon
id|msg_unlock
c_func
(paren
id|msq
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|function|testmsg
r_static
r_int
id|testmsg
c_func
(paren
r_struct
id|msg_msg
op_star
id|msg
comma
r_int
id|type
comma
r_int
id|mode
)paren
(brace
r_switch
c_cond
(paren
id|mode
)paren
(brace
r_case
id|SEARCH_ANY
suffix:colon
r_return
l_int|1
suffix:semicolon
r_case
id|SEARCH_LESSEQUAL
suffix:colon
r_if
c_cond
(paren
id|msg-&gt;m_type
op_le
id|type
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|SEARCH_EQUAL
suffix:colon
r_if
c_cond
(paren
id|msg-&gt;m_type
op_eq
id|type
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|SEARCH_NOTEQUAL
suffix:colon
r_if
c_cond
(paren
id|msg-&gt;m_type
op_ne
id|type
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|pipelined_send
r_static
r_inline
r_int
id|pipelined_send
c_func
(paren
r_struct
id|msg_queue
op_star
id|msq
comma
r_struct
id|msg_msg
op_star
id|msg
)paren
(brace
r_struct
id|list_head
op_star
id|tmp
suffix:semicolon
id|tmp
op_assign
id|msq-&gt;q_receivers.next
suffix:semicolon
r_while
c_loop
(paren
id|tmp
op_ne
op_amp
id|msq-&gt;q_receivers
)paren
(brace
r_struct
id|msg_receiver
op_star
id|msr
suffix:semicolon
id|msr
op_assign
id|list_entry
c_func
(paren
id|tmp
comma
r_struct
id|msg_receiver
comma
id|r_list
)paren
suffix:semicolon
id|tmp
op_assign
id|tmp-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|testmsg
c_func
(paren
id|msg
comma
id|msr-&gt;r_msgtype
comma
id|msr-&gt;r_mode
)paren
op_logical_and
op_logical_neg
id|security_msg_queue_msgrcv
c_func
(paren
id|msq
comma
id|msg
comma
id|msr-&gt;r_tsk
comma
id|msr-&gt;r_msgtype
comma
id|msr-&gt;r_mode
)paren
)paren
(brace
id|list_del
c_func
(paren
op_amp
id|msr-&gt;r_list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|msr-&gt;r_maxsize
OL
id|msg-&gt;m_ts
)paren
(brace
id|msr-&gt;r_msg
op_assign
l_int|NULL
suffix:semicolon
id|wake_up_process
c_func
(paren
id|msr-&gt;r_tsk
)paren
suffix:semicolon
id|smp_mb
c_func
(paren
)paren
suffix:semicolon
id|msr-&gt;r_msg
op_assign
id|ERR_PTR
c_func
(paren
op_minus
id|E2BIG
)paren
suffix:semicolon
)brace
r_else
(brace
id|msr-&gt;r_msg
op_assign
l_int|NULL
suffix:semicolon
id|msq-&gt;q_lrpid
op_assign
id|msr-&gt;r_tsk-&gt;pid
suffix:semicolon
id|msq-&gt;q_rtime
op_assign
id|get_seconds
c_func
(paren
)paren
suffix:semicolon
id|wake_up_process
c_func
(paren
id|msr-&gt;r_tsk
)paren
suffix:semicolon
id|smp_mb
c_func
(paren
)paren
suffix:semicolon
id|msr-&gt;r_msg
op_assign
id|msg
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|sys_msgsnd
id|asmlinkage
r_int
id|sys_msgsnd
(paren
r_int
id|msqid
comma
r_struct
id|msgbuf
id|__user
op_star
id|msgp
comma
r_int
id|msgsz
comma
r_int
id|msgflg
)paren
(brace
r_struct
id|msg_queue
op_star
id|msq
suffix:semicolon
r_struct
id|msg_msg
op_star
id|msg
suffix:semicolon
r_int
id|mtype
suffix:semicolon
r_int
id|err
suffix:semicolon
r_if
c_cond
(paren
id|msgsz
OG
id|msg_ctlmax
op_logical_or
(paren
r_int
)paren
id|msgsz
OL
l_int|0
op_logical_or
id|msqid
OL
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|mtype
comma
op_amp
id|msgp-&gt;mtype
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|mtype
OL
l_int|1
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|msg
op_assign
id|load_msg
c_func
(paren
id|msgp-&gt;mtext
comma
id|msgsz
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|msg
)paren
)paren
(brace
r_return
id|PTR_ERR
c_func
(paren
id|msg
)paren
suffix:semicolon
)brace
id|msg-&gt;m_type
op_assign
id|mtype
suffix:semicolon
id|msg-&gt;m_ts
op_assign
id|msgsz
suffix:semicolon
id|msq
op_assign
id|msg_lock
c_func
(paren
id|msqid
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|msq
op_eq
l_int|NULL
)paren
(brace
r_goto
id|out_free
suffix:semicolon
)brace
id|err
op_assign
op_minus
id|EIDRM
suffix:semicolon
r_if
c_cond
(paren
id|msg_checkid
c_func
(paren
id|msq
comma
id|msqid
)paren
)paren
r_goto
id|out_unlock_free
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_struct
id|msg_sender
id|s
suffix:semicolon
id|err
op_assign
op_minus
id|EACCES
suffix:semicolon
r_if
c_cond
(paren
id|ipcperms
c_func
(paren
op_amp
id|msq-&gt;q_perm
comma
id|S_IWUGO
)paren
)paren
r_goto
id|out_unlock_free
suffix:semicolon
id|err
op_assign
id|security_msg_queue_msgsnd
c_func
(paren
id|msq
comma
id|msg
comma
id|msgflg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out_unlock_free
suffix:semicolon
r_if
c_cond
(paren
id|msgsz
op_plus
id|msq-&gt;q_cbytes
op_le
id|msq-&gt;q_qbytes
op_logical_and
l_int|1
op_plus
id|msq-&gt;q_qnum
op_le
id|msq-&gt;q_qbytes
)paren
(brace
r_break
suffix:semicolon
)brace
multiline_comment|/* queue full, wait: */
r_if
c_cond
(paren
id|msgflg
op_amp
id|IPC_NOWAIT
)paren
(brace
id|err
op_assign
op_minus
id|EAGAIN
suffix:semicolon
r_goto
id|out_unlock_free
suffix:semicolon
)brace
id|ss_add
c_func
(paren
id|msq
comma
op_amp
id|s
)paren
suffix:semicolon
id|ipc_rcu_getref
c_func
(paren
id|msq
)paren
suffix:semicolon
id|msg_unlock
c_func
(paren
id|msq
)paren
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|ipc_lock_by_ptr
c_func
(paren
op_amp
id|msq-&gt;q_perm
)paren
suffix:semicolon
id|ipc_rcu_putref
c_func
(paren
id|msq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|msq-&gt;q_perm.deleted
)paren
(brace
id|err
op_assign
op_minus
id|EIDRM
suffix:semicolon
r_goto
id|out_unlock_free
suffix:semicolon
)brace
id|ss_del
c_func
(paren
op_amp
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
id|err
op_assign
op_minus
id|ERESTARTNOHAND
suffix:semicolon
r_goto
id|out_unlock_free
suffix:semicolon
)brace
)brace
id|msq-&gt;q_lspid
op_assign
id|current-&gt;tgid
suffix:semicolon
id|msq-&gt;q_stime
op_assign
id|get_seconds
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pipelined_send
c_func
(paren
id|msq
comma
id|msg
)paren
)paren
(brace
multiline_comment|/* noone is waiting for this message, enqueue it */
id|list_add_tail
c_func
(paren
op_amp
id|msg-&gt;m_list
comma
op_amp
id|msq-&gt;q_messages
)paren
suffix:semicolon
id|msq-&gt;q_cbytes
op_add_assign
id|msgsz
suffix:semicolon
id|msq-&gt;q_qnum
op_increment
suffix:semicolon
id|atomic_add
c_func
(paren
id|msgsz
comma
op_amp
id|msg_bytes
)paren
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|msg_hdrs
)paren
suffix:semicolon
)brace
id|err
op_assign
l_int|0
suffix:semicolon
id|msg
op_assign
l_int|NULL
suffix:semicolon
id|out_unlock_free
suffix:colon
id|msg_unlock
c_func
(paren
id|msq
)paren
suffix:semicolon
id|out_free
suffix:colon
r_if
c_cond
(paren
id|msg
op_ne
l_int|NULL
)paren
(brace
id|free_msg
c_func
(paren
id|msg
)paren
suffix:semicolon
)brace
r_return
id|err
suffix:semicolon
)brace
DECL|function|convert_mode
r_static
r_inline
r_int
id|convert_mode
c_func
(paren
r_int
op_star
id|msgtyp
comma
r_int
id|msgflg
)paren
(brace
multiline_comment|/* &n;&t; *  find message of correct type.&n;&t; *  msgtyp = 0 =&gt; get first.&n;&t; *  msgtyp &gt; 0 =&gt; get first message of matching type.&n;&t; *  msgtyp &lt; 0 =&gt; get message with least type must be &lt; abs(msgtype).  &n;&t; */
r_if
c_cond
(paren
op_star
id|msgtyp
op_eq
l_int|0
)paren
(brace
r_return
id|SEARCH_ANY
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|msgtyp
OL
l_int|0
)paren
(brace
op_star
id|msgtyp
op_assign
op_minus
(paren
op_star
id|msgtyp
)paren
suffix:semicolon
r_return
id|SEARCH_LESSEQUAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|msgflg
op_amp
id|MSG_EXCEPT
)paren
(brace
r_return
id|SEARCH_NOTEQUAL
suffix:semicolon
)brace
r_return
id|SEARCH_EQUAL
suffix:semicolon
)brace
DECL|function|sys_msgrcv
id|asmlinkage
r_int
id|sys_msgrcv
(paren
r_int
id|msqid
comma
r_struct
id|msgbuf
id|__user
op_star
id|msgp
comma
r_int
id|msgsz
comma
r_int
id|msgtyp
comma
r_int
id|msgflg
)paren
(brace
r_struct
id|msg_queue
op_star
id|msq
suffix:semicolon
r_struct
id|msg_msg
op_star
id|msg
suffix:semicolon
r_int
id|mode
suffix:semicolon
r_if
c_cond
(paren
id|msqid
OL
l_int|0
op_logical_or
(paren
r_int
)paren
id|msgsz
OL
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|mode
op_assign
id|convert_mode
c_func
(paren
op_amp
id|msgtyp
comma
id|msgflg
)paren
suffix:semicolon
id|msq
op_assign
id|msg_lock
c_func
(paren
id|msqid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|msq
op_eq
l_int|NULL
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|msg
op_assign
id|ERR_PTR
c_func
(paren
op_minus
id|EIDRM
)paren
suffix:semicolon
r_if
c_cond
(paren
id|msg_checkid
c_func
(paren
id|msq
comma
id|msqid
)paren
)paren
r_goto
id|out_unlock
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_struct
id|msg_receiver
id|msr_d
suffix:semicolon
r_struct
id|list_head
op_star
id|tmp
suffix:semicolon
id|msg
op_assign
id|ERR_PTR
c_func
(paren
op_minus
id|EACCES
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ipcperms
(paren
op_amp
id|msq-&gt;q_perm
comma
id|S_IRUGO
)paren
)paren
r_goto
id|out_unlock
suffix:semicolon
id|msg
op_assign
id|ERR_PTR
c_func
(paren
op_minus
id|EAGAIN
)paren
suffix:semicolon
id|tmp
op_assign
id|msq-&gt;q_messages.next
suffix:semicolon
r_while
c_loop
(paren
id|tmp
op_ne
op_amp
id|msq-&gt;q_messages
)paren
(brace
r_struct
id|msg_msg
op_star
id|walk_msg
suffix:semicolon
id|walk_msg
op_assign
id|list_entry
c_func
(paren
id|tmp
comma
r_struct
id|msg_msg
comma
id|m_list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|testmsg
c_func
(paren
id|walk_msg
comma
id|msgtyp
comma
id|mode
)paren
op_logical_and
op_logical_neg
id|security_msg_queue_msgrcv
c_func
(paren
id|msq
comma
id|walk_msg
comma
id|current
comma
id|msgtyp
comma
id|mode
)paren
)paren
(brace
id|msg
op_assign
id|walk_msg
suffix:semicolon
r_if
c_cond
(paren
id|mode
op_eq
id|SEARCH_LESSEQUAL
op_logical_and
id|walk_msg-&gt;m_type
op_ne
l_int|1
)paren
(brace
id|msg
op_assign
id|walk_msg
suffix:semicolon
id|msgtyp
op_assign
id|walk_msg-&gt;m_type
op_minus
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|msg
op_assign
id|walk_msg
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|tmp
op_assign
id|tmp-&gt;next
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|IS_ERR
c_func
(paren
id|msg
)paren
)paren
(brace
multiline_comment|/* Found a suitable message. Unlink it from the queue. */
r_if
c_cond
(paren
(paren
id|msgsz
OL
id|msg-&gt;m_ts
)paren
op_logical_and
op_logical_neg
(paren
id|msgflg
op_amp
id|MSG_NOERROR
)paren
)paren
(brace
id|msg
op_assign
id|ERR_PTR
c_func
(paren
op_minus
id|E2BIG
)paren
suffix:semicolon
r_goto
id|out_unlock
suffix:semicolon
)brace
id|list_del
c_func
(paren
op_amp
id|msg-&gt;m_list
)paren
suffix:semicolon
id|msq-&gt;q_qnum
op_decrement
suffix:semicolon
id|msq-&gt;q_rtime
op_assign
id|get_seconds
c_func
(paren
)paren
suffix:semicolon
id|msq-&gt;q_lrpid
op_assign
id|current-&gt;tgid
suffix:semicolon
id|msq-&gt;q_cbytes
op_sub_assign
id|msg-&gt;m_ts
suffix:semicolon
id|atomic_sub
c_func
(paren
id|msg-&gt;m_ts
comma
op_amp
id|msg_bytes
)paren
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|msg_hdrs
)paren
suffix:semicolon
id|ss_wakeup
c_func
(paren
op_amp
id|msq-&gt;q_senders
comma
l_int|0
)paren
suffix:semicolon
id|msg_unlock
c_func
(paren
id|msq
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* No message waiting. Wait for a message */
r_if
c_cond
(paren
id|msgflg
op_amp
id|IPC_NOWAIT
)paren
(brace
id|msg
op_assign
id|ERR_PTR
c_func
(paren
op_minus
id|ENOMSG
)paren
suffix:semicolon
r_goto
id|out_unlock
suffix:semicolon
)brace
id|list_add_tail
c_func
(paren
op_amp
id|msr_d.r_list
comma
op_amp
id|msq-&gt;q_receivers
)paren
suffix:semicolon
id|msr_d.r_tsk
op_assign
id|current
suffix:semicolon
id|msr_d.r_msgtype
op_assign
id|msgtyp
suffix:semicolon
id|msr_d.r_mode
op_assign
id|mode
suffix:semicolon
r_if
c_cond
(paren
id|msgflg
op_amp
id|MSG_NOERROR
)paren
(brace
id|msr_d.r_maxsize
op_assign
id|INT_MAX
suffix:semicolon
)brace
r_else
id|msr_d.r_maxsize
op_assign
id|msgsz
suffix:semicolon
id|msr_d.r_msg
op_assign
id|ERR_PTR
c_func
(paren
op_minus
id|EAGAIN
)paren
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|msg_unlock
c_func
(paren
id|msq
)paren
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Lockless receive, part 1:&n;&t;&t; * Disable preemption.  We don&squot;t hold a reference to the queue&n;&t;&t; * and getting a reference would defeat the idea of a lockless&n;&t;&t; * operation, thus the code relies on rcu to guarantee the&n;&t;&t; * existance of msq:&n;&t;&t; * Prior to destruction, expunge_all(-EIRDM) changes r_msg.&n;&t;&t; * Thus if r_msg is -EAGAIN, then the queue not yet destroyed.&n;&t;&t; * rcu_read_lock() prevents preemption between reading r_msg&n;&t;&t; * and the spin_lock() inside ipc_lock_by_ptr().&n;&t;&t; */
id|rcu_read_lock
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Lockless receive, part 2:&n;&t;&t; * Wait until pipelined_send or expunge_all are outside of&n;&t;&t; * wake_up_process(). There is a race with exit(), see&n;&t;&t; * ipc/mqueue.c for the details.&n;&t;&t; */
id|msg
op_assign
(paren
r_struct
id|msg_msg
op_star
)paren
id|msr_d.r_msg
suffix:semicolon
r_while
c_loop
(paren
id|msg
op_eq
l_int|NULL
)paren
(brace
id|cpu_relax
c_func
(paren
)paren
suffix:semicolon
id|msg
op_assign
(paren
r_struct
id|msg_msg
op_star
)paren
id|msr_d.r_msg
suffix:semicolon
)brace
multiline_comment|/* Lockless receive, part 3:&n;&t;&t; * If there is a message or an error then accept it without&n;&t;&t; * locking.&n;&t;&t; */
r_if
c_cond
(paren
id|msg
op_ne
id|ERR_PTR
c_func
(paren
op_minus
id|EAGAIN
)paren
)paren
(brace
id|rcu_read_unlock
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Lockless receive, part 3:&n;&t;&t; * Acquire the queue spinlock.&n;&t;&t; */
id|ipc_lock_by_ptr
c_func
(paren
op_amp
id|msq-&gt;q_perm
)paren
suffix:semicolon
id|rcu_read_unlock
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Lockless receive, part 4:&n;&t;&t; * Repeat test after acquiring the spinlock.&n;&t;&t; */
id|msg
op_assign
(paren
r_struct
id|msg_msg
op_star
)paren
id|msr_d.r_msg
suffix:semicolon
r_if
c_cond
(paren
id|msg
op_ne
id|ERR_PTR
c_func
(paren
op_minus
id|EAGAIN
)paren
)paren
(brace
r_goto
id|out_unlock
suffix:semicolon
)brace
id|list_del
c_func
(paren
op_amp
id|msr_d.r_list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
id|msg
op_assign
id|ERR_PTR
c_func
(paren
op_minus
id|ERESTARTNOHAND
)paren
suffix:semicolon
id|out_unlock
suffix:colon
id|msg_unlock
c_func
(paren
id|msq
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|msg
)paren
)paren
r_return
id|PTR_ERR
c_func
(paren
id|msg
)paren
suffix:semicolon
id|msgsz
op_assign
(paren
id|msgsz
OG
id|msg-&gt;m_ts
)paren
ques
c_cond
id|msg-&gt;m_ts
suffix:colon
id|msgsz
suffix:semicolon
r_if
c_cond
(paren
id|put_user
(paren
id|msg-&gt;m_type
comma
op_amp
id|msgp-&gt;mtype
)paren
op_logical_or
id|store_msg
c_func
(paren
id|msgp-&gt;mtext
comma
id|msg
comma
id|msgsz
)paren
)paren
(brace
id|msgsz
op_assign
op_minus
id|EFAULT
suffix:semicolon
)brace
id|free_msg
c_func
(paren
id|msg
)paren
suffix:semicolon
r_return
id|msgsz
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_PROC_FS
DECL|function|sysvipc_msg_read_proc
r_static
r_int
id|sysvipc_msg_read_proc
c_func
(paren
r_char
op_star
id|buffer
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|length
comma
r_int
op_star
id|eof
comma
r_void
op_star
id|data
)paren
(brace
id|off_t
id|pos
op_assign
l_int|0
suffix:semicolon
id|off_t
id|begin
op_assign
l_int|0
suffix:semicolon
r_int
id|i
comma
id|len
op_assign
l_int|0
suffix:semicolon
id|down
c_func
(paren
op_amp
id|msg_ids.sem
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
comma
l_string|&quot;       key      msqid perms      cbytes       qnum lspid lrpid   uid   gid  cuid  cgid      stime      rtime      ctime&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_le
id|msg_ids.max_id
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|msg_queue
op_star
id|msq
suffix:semicolon
id|msq
op_assign
id|msg_lock
c_func
(paren
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|msq
op_ne
l_int|NULL
)paren
(brace
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;%10d %10d  %4o  %10lu %10lu %5u %5u %5u %5u %5u %5u %10lu %10lu %10lu&bslash;n&quot;
comma
id|msq-&gt;q_perm.key
comma
id|msg_buildid
c_func
(paren
id|i
comma
id|msq-&gt;q_perm.seq
)paren
comma
id|msq-&gt;q_perm.mode
comma
id|msq-&gt;q_cbytes
comma
id|msq-&gt;q_qnum
comma
id|msq-&gt;q_lspid
comma
id|msq-&gt;q_lrpid
comma
id|msq-&gt;q_perm.uid
comma
id|msq-&gt;q_perm.gid
comma
id|msq-&gt;q_perm.cuid
comma
id|msq-&gt;q_perm.cgid
comma
id|msq-&gt;q_stime
comma
id|msq-&gt;q_rtime
comma
id|msq-&gt;q_ctime
)paren
suffix:semicolon
id|msg_unlock
c_func
(paren
id|msq
)paren
suffix:semicolon
id|pos
op_add_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
id|pos
OL
id|offset
)paren
(brace
id|len
op_assign
l_int|0
suffix:semicolon
id|begin
op_assign
id|pos
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pos
OG
id|offset
op_plus
id|length
)paren
(brace
r_goto
id|done
suffix:semicolon
)brace
)brace
)brace
op_star
id|eof
op_assign
l_int|1
suffix:semicolon
id|done
suffix:colon
id|up
c_func
(paren
op_amp
id|msg_ids.sem
)paren
suffix:semicolon
op_star
id|start
op_assign
id|buffer
op_plus
(paren
id|offset
op_minus
id|begin
)paren
suffix:semicolon
id|len
op_sub_assign
(paren
id|offset
op_minus
id|begin
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|length
)paren
(brace
id|len
op_assign
id|length
suffix:semicolon
)brace
r_if
c_cond
(paren
id|len
OL
l_int|0
)paren
(brace
id|len
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|len
suffix:semicolon
)brace
macro_line|#endif
eof
