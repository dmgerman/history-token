multiline_comment|/*&n; * linux/ipc/sem.c&n; * Copyright (C) 1992 Krishna Balasubramanian&n; * Copyright (C) 1995 Eric Schenk, Bruno Haible&n; *&n; * IMPLEMENTATION NOTES ON CODE REWRITE (Eric Schenk, January 1995):&n; * This code underwent a massive rewrite in order to solve some problems&n; * with the original code. In particular the original code failed to&n; * wake up processes that were waiting for semval to go to 0 if the&n; * value went to 0 and was then incremented rapidly enough. In solving&n; * this problem I have also modified the implementation so that it&n; * processes pending operations in a FIFO manner, thus give a guarantee&n; * that processes waiting for a lock on the semaphore won&squot;t starve&n; * unless another locking process fails to unlock.&n; * In addition the following two changes in behavior have been introduced:&n; * - The original implementation of semop returned the value&n; *   last semaphore element examined on success. This does not&n; *   match the manual page specifications, and effectively&n; *   allows the user to read the semaphore even if they do not&n; *   have read permissions. The implementation now returns 0&n; *   on success as stated in the manual page.&n; * - There is some confusion over whether the set of undo adjustments&n; *   to be performed at exit should be done in an atomic manner.&n; *   That is, if we are attempting to decrement the semval should we queue&n; *   up and wait until we can do so legally?&n; *   The original implementation attempted to do this.&n; *   The current implementation does not do so. This is because I don&squot;t&n; *   think it is the right thing (TM) to do, and because I couldn&squot;t&n; *   see a clean way to get the old behavior with the new design.&n; *   The POSIX standard and SVID should be consulted to determine&n; *   what behavior is mandated.&n; *&n; * Further notes on refinement (Christoph Rohland, December 1998):&n; * - The POSIX standard says, that the undo adjustments simply should&n; *   redo. So the current implementation is o.K.&n; * - The previous code had two flaws:&n; *   1) It actively gave the semaphore to the next waiting process&n; *      sleeping on the semaphore. Since this process did not have the&n; *      cpu this led to many unnecessary context switches and bad&n; *      performance. Now we only check which process should be able to&n; *      get the semaphore and if this process wants to reduce some&n; *      semaphore value we simply wake it up without doing the&n; *      operation. So it has to try to get it later. Thus e.g. the&n; *      running process may reacquire the semaphore during the current&n; *      time slice. If it only waits for zero or increases the semaphore,&n; *      we do the operation in advance and wake it up.&n; *   2) It did not wake up all zero waiting processes. We try to do&n; *      better but only get the semops right which only wait for zero or&n; *      increase. If there are decrement operations in the operations&n; *      array we do the same as before.&n; *&n; * With the incarnation of O(1) scheduler, it becomes unnecessary to perform&n; * check/retry algorithm for waking up blocked processes as the new scheduler&n; * is better at handling thread switch than the old one.&n; *&n; * /proc/sysvipc/sem support (c) 1999 Dragos Acostachioaie &lt;dragos@iname.com&gt;&n; *&n; * SMP-threaded, sysctl&squot;s added&n; * (c) 1999 Manfred Spraul &lt;manfreds@colorfullife.com&gt;&n; * Enforced range limit on SEM_UNDO&n; * (c) 2001 Red Hat Inc &lt;alan@redhat.com&gt;&n; * Lockless wakeup&n; * (c) 2003 Manfred Spraul &lt;manfred@colorfullife.com&gt;&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;linux/time.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/security.h&gt;
macro_line|#include &lt;linux/syscalls.h&gt;
macro_line|#include &lt;linux/audit.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &quot;util.h&quot;
DECL|macro|sem_lock
mdefine_line|#define sem_lock(id)&t;((struct sem_array*)ipc_lock(&amp;sem_ids,id))
DECL|macro|sem_unlock
mdefine_line|#define sem_unlock(sma)&t;ipc_unlock(&amp;(sma)-&gt;sem_perm)
DECL|macro|sem_rmid
mdefine_line|#define sem_rmid(id)&t;((struct sem_array*)ipc_rmid(&amp;sem_ids,id))
DECL|macro|sem_checkid
mdefine_line|#define sem_checkid(sma, semid)&t;&bslash;&n;&t;ipc_checkid(&amp;sem_ids,&amp;sma-&gt;sem_perm,semid)
DECL|macro|sem_buildid
mdefine_line|#define sem_buildid(id, seq) &bslash;&n;&t;ipc_buildid(&amp;sem_ids, id, seq)
DECL|variable|sem_ids
r_static
r_struct
id|ipc_ids
id|sem_ids
suffix:semicolon
r_static
r_int
id|newary
(paren
id|key_t
comma
r_int
comma
r_int
)paren
suffix:semicolon
r_static
r_void
id|freeary
(paren
r_struct
id|sem_array
op_star
id|sma
comma
r_int
id|id
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_PROC_FS
r_static
r_int
id|sysvipc_sem_read_proc
c_func
(paren
r_char
op_star
id|buffer
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|length
comma
r_int
op_star
id|eof
comma
r_void
op_star
id|data
)paren
suffix:semicolon
macro_line|#endif
DECL|macro|SEMMSL_FAST
mdefine_line|#define SEMMSL_FAST&t;256 /* 512 bytes on stack */
DECL|macro|SEMOPM_FAST
mdefine_line|#define SEMOPM_FAST&t;64  /* ~ 372 bytes on stack */
multiline_comment|/*&n; * linked list protection:&n; *&t;sem_undo.id_next,&n; *&t;sem_array.sem_pending{,last},&n; *&t;sem_array.sem_undo: sem_lock() for read/write&n; *&t;sem_undo.proc_next: only &quot;current&quot; is allowed to read/write that field.&n; *&t;&n; */
DECL|variable|sem_ctls
r_int
id|sem_ctls
(braket
l_int|4
)braket
op_assign
(brace
id|SEMMSL
comma
id|SEMMNS
comma
id|SEMOPM
comma
id|SEMMNI
)brace
suffix:semicolon
DECL|macro|sc_semmsl
mdefine_line|#define sc_semmsl&t;(sem_ctls[0])
DECL|macro|sc_semmns
mdefine_line|#define sc_semmns&t;(sem_ctls[1])
DECL|macro|sc_semopm
mdefine_line|#define sc_semopm&t;(sem_ctls[2])
DECL|macro|sc_semmni
mdefine_line|#define sc_semmni&t;(sem_ctls[3])
DECL|variable|used_sems
r_static
r_int
id|used_sems
suffix:semicolon
DECL|function|sem_init
r_void
id|__init
id|sem_init
(paren
r_void
)paren
(brace
id|used_sems
op_assign
l_int|0
suffix:semicolon
id|ipc_init_ids
c_func
(paren
op_amp
id|sem_ids
comma
id|sc_semmni
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_PROC_FS
id|create_proc_read_entry
c_func
(paren
l_string|&quot;sysvipc/sem&quot;
comma
l_int|0
comma
l_int|NULL
comma
id|sysvipc_sem_read_proc
comma
l_int|NULL
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n; * Lockless wakeup algorithm:&n; * Without the check/retry algorithm a lockless wakeup is possible:&n; * - queue.status is initialized to -EINTR before blocking.&n; * - wakeup is performed by&n; *&t;* unlinking the queue entry from sma-&gt;sem_pending&n; *&t;* setting queue.status to IN_WAKEUP&n; *&t;  This is the notification for the blocked thread that a&n; *&t;  result value is imminent.&n; *&t;* call wake_up_process&n; *&t;* set queue.status to the final value.&n; * - the previously blocked thread checks queue.status:&n; *   &t;* if it&squot;s IN_WAKEUP, then it must wait until the value changes&n; *   &t;* if it&squot;s not -EINTR, then the operation was completed by&n; *   &t;  update_queue. semtimedop can return queue.status without&n; *   &t;  performing any operation on the semaphore array.&n; *   &t;* otherwise it must acquire the spinlock and check what&squot;s up.&n; *&n; * The two-stage algorithm is necessary to protect against the following&n; * races:&n; * - if queue.status is set after wake_up_process, then the woken up idle&n; *   thread could race forward and try (and fail) to acquire sma-&gt;lock&n; *   before update_queue had a chance to set queue.status&n; * - if queue.status is written before wake_up_process and if the&n; *   blocked process is woken up by a signal between writing&n; *   queue.status and the wake_up_process, then the woken up&n; *   process could return from semtimedop and die by calling&n; *   sys_exit before wake_up_process is called. Then wake_up_process&n; *   will oops, because the task structure is already invalid.&n; *   (yes, this happened on s390 with sysv msg).&n; *&n; */
DECL|macro|IN_WAKEUP
mdefine_line|#define IN_WAKEUP&t;1
DECL|function|newary
r_static
r_int
id|newary
(paren
id|key_t
id|key
comma
r_int
id|nsems
comma
r_int
id|semflg
)paren
(brace
r_int
id|id
suffix:semicolon
r_int
id|retval
suffix:semicolon
r_struct
id|sem_array
op_star
id|sma
suffix:semicolon
r_int
id|size
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|nsems
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|used_sems
op_plus
id|nsems
OG
id|sc_semmns
)paren
r_return
op_minus
id|ENOSPC
suffix:semicolon
id|size
op_assign
r_sizeof
(paren
op_star
id|sma
)paren
op_plus
id|nsems
op_star
r_sizeof
(paren
r_struct
id|sem
)paren
suffix:semicolon
id|sma
op_assign
id|ipc_rcu_alloc
c_func
(paren
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sma
)paren
(brace
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|memset
(paren
id|sma
comma
l_int|0
comma
id|size
)paren
suffix:semicolon
id|sma-&gt;sem_perm.mode
op_assign
(paren
id|semflg
op_amp
id|S_IRWXUGO
)paren
suffix:semicolon
id|sma-&gt;sem_perm.key
op_assign
id|key
suffix:semicolon
id|sma-&gt;sem_perm.security
op_assign
l_int|NULL
suffix:semicolon
id|retval
op_assign
id|security_sem_alloc
c_func
(paren
id|sma
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
(brace
id|ipc_rcu_putref
c_func
(paren
id|sma
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
id|id
op_assign
id|ipc_addid
c_func
(paren
op_amp
id|sem_ids
comma
op_amp
id|sma-&gt;sem_perm
comma
id|sc_semmni
)paren
suffix:semicolon
r_if
c_cond
(paren
id|id
op_eq
op_minus
l_int|1
)paren
(brace
id|security_sem_free
c_func
(paren
id|sma
)paren
suffix:semicolon
id|ipc_rcu_putref
c_func
(paren
id|sma
)paren
suffix:semicolon
r_return
op_minus
id|ENOSPC
suffix:semicolon
)brace
id|used_sems
op_add_assign
id|nsems
suffix:semicolon
id|sma-&gt;sem_base
op_assign
(paren
r_struct
id|sem
op_star
)paren
op_amp
id|sma
(braket
l_int|1
)braket
suffix:semicolon
multiline_comment|/* sma-&gt;sem_pending = NULL; */
id|sma-&gt;sem_pending_last
op_assign
op_amp
id|sma-&gt;sem_pending
suffix:semicolon
multiline_comment|/* sma-&gt;undo = NULL; */
id|sma-&gt;sem_nsems
op_assign
id|nsems
suffix:semicolon
id|sma-&gt;sem_ctime
op_assign
id|get_seconds
c_func
(paren
)paren
suffix:semicolon
id|sem_unlock
c_func
(paren
id|sma
)paren
suffix:semicolon
r_return
id|sem_buildid
c_func
(paren
id|id
comma
id|sma-&gt;sem_perm.seq
)paren
suffix:semicolon
)brace
DECL|function|sys_semget
id|asmlinkage
r_int
id|sys_semget
(paren
id|key_t
id|key
comma
r_int
id|nsems
comma
r_int
id|semflg
)paren
(brace
r_int
id|id
comma
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_struct
id|sem_array
op_star
id|sma
suffix:semicolon
r_if
c_cond
(paren
id|nsems
template_param
id|sc_semmsl
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|down
c_func
(paren
op_amp
id|sem_ids.sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|key
op_eq
id|IPC_PRIVATE
)paren
(brace
id|err
op_assign
id|newary
c_func
(paren
id|key
comma
id|nsems
comma
id|semflg
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|id
op_assign
id|ipc_findkey
c_func
(paren
op_amp
id|sem_ids
comma
id|key
)paren
)paren
op_eq
op_minus
l_int|1
)paren
(brace
multiline_comment|/* key not used */
r_if
c_cond
(paren
op_logical_neg
(paren
id|semflg
op_amp
id|IPC_CREAT
)paren
)paren
id|err
op_assign
op_minus
id|ENOENT
suffix:semicolon
r_else
id|err
op_assign
id|newary
c_func
(paren
id|key
comma
id|nsems
comma
id|semflg
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|semflg
op_amp
id|IPC_CREAT
op_logical_and
id|semflg
op_amp
id|IPC_EXCL
)paren
(brace
id|err
op_assign
op_minus
id|EEXIST
suffix:semicolon
)brace
r_else
(brace
id|sma
op_assign
id|sem_lock
c_func
(paren
id|id
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sma
op_eq
l_int|NULL
)paren
(brace
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|nsems
OG
id|sma-&gt;sem_nsems
)paren
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_else
r_if
c_cond
(paren
id|ipcperms
c_func
(paren
op_amp
id|sma-&gt;sem_perm
comma
id|semflg
)paren
)paren
id|err
op_assign
op_minus
id|EACCES
suffix:semicolon
r_else
(brace
r_int
id|semid
op_assign
id|sem_buildid
c_func
(paren
id|id
comma
id|sma-&gt;sem_perm.seq
)paren
suffix:semicolon
id|err
op_assign
id|security_sem_associate
c_func
(paren
id|sma
comma
id|semflg
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|err
)paren
id|err
op_assign
id|semid
suffix:semicolon
)brace
id|sem_unlock
c_func
(paren
id|sma
)paren
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|sem_ids.sem
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/* Manage the doubly linked list sma-&gt;sem_pending as a FIFO:&n; * insert new queue elements at the tail sma-&gt;sem_pending_last.&n; */
DECL|function|append_to_queue
r_static
r_inline
r_void
id|append_to_queue
(paren
r_struct
id|sem_array
op_star
id|sma
comma
r_struct
id|sem_queue
op_star
id|q
)paren
(brace
op_star
(paren
id|q-&gt;prev
op_assign
id|sma-&gt;sem_pending_last
)paren
op_assign
id|q
suffix:semicolon
op_star
(paren
id|sma-&gt;sem_pending_last
op_assign
op_amp
id|q-&gt;next
)paren
op_assign
l_int|NULL
suffix:semicolon
)brace
DECL|function|prepend_to_queue
r_static
r_inline
r_void
id|prepend_to_queue
(paren
r_struct
id|sem_array
op_star
id|sma
comma
r_struct
id|sem_queue
op_star
id|q
)paren
(brace
id|q-&gt;next
op_assign
id|sma-&gt;sem_pending
suffix:semicolon
op_star
(paren
id|q-&gt;prev
op_assign
op_amp
id|sma-&gt;sem_pending
)paren
op_assign
id|q
suffix:semicolon
r_if
c_cond
(paren
id|q-&gt;next
)paren
id|q-&gt;next-&gt;prev
op_assign
op_amp
id|q-&gt;next
suffix:semicolon
r_else
multiline_comment|/* sma-&gt;sem_pending_last == &amp;sma-&gt;sem_pending */
id|sma-&gt;sem_pending_last
op_assign
op_amp
id|q-&gt;next
suffix:semicolon
)brace
DECL|function|remove_from_queue
r_static
r_inline
r_void
id|remove_from_queue
(paren
r_struct
id|sem_array
op_star
id|sma
comma
r_struct
id|sem_queue
op_star
id|q
)paren
(brace
op_star
(paren
id|q-&gt;prev
)paren
op_assign
id|q-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|q-&gt;next
)paren
id|q-&gt;next-&gt;prev
op_assign
id|q-&gt;prev
suffix:semicolon
r_else
multiline_comment|/* sma-&gt;sem_pending_last == &amp;q-&gt;next */
id|sma-&gt;sem_pending_last
op_assign
id|q-&gt;prev
suffix:semicolon
id|q-&gt;prev
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* mark as removed */
)brace
multiline_comment|/*&n; * Determine whether a sequence of semaphore operations would succeed&n; * all at once. Return 0 if yes, 1 if need to sleep, else return error code.&n; */
DECL|function|try_atomic_semop
r_static
r_int
id|try_atomic_semop
(paren
r_struct
id|sem_array
op_star
id|sma
comma
r_struct
id|sembuf
op_star
id|sops
comma
r_int
id|nsops
comma
r_struct
id|sem_undo
op_star
id|un
comma
r_int
id|pid
)paren
(brace
r_int
id|result
comma
id|sem_op
suffix:semicolon
r_struct
id|sembuf
op_star
id|sop
suffix:semicolon
r_struct
id|sem
op_star
id|curr
suffix:semicolon
r_for
c_loop
(paren
id|sop
op_assign
id|sops
suffix:semicolon
id|sop
OL
id|sops
op_plus
id|nsops
suffix:semicolon
id|sop
op_increment
)paren
(brace
id|curr
op_assign
id|sma-&gt;sem_base
op_plus
id|sop-&gt;sem_num
suffix:semicolon
id|sem_op
op_assign
id|sop-&gt;sem_op
suffix:semicolon
id|result
op_assign
id|curr-&gt;semval
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sem_op
op_logical_and
id|result
)paren
r_goto
id|would_block
suffix:semicolon
id|result
op_add_assign
id|sem_op
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
r_goto
id|would_block
suffix:semicolon
r_if
c_cond
(paren
id|result
OG
id|SEMVMX
)paren
r_goto
id|out_of_range
suffix:semicolon
r_if
c_cond
(paren
id|sop-&gt;sem_flg
op_amp
id|SEM_UNDO
)paren
(brace
r_int
id|undo
op_assign
id|un-&gt;semadj
(braket
id|sop-&gt;sem_num
)braket
op_minus
id|sem_op
suffix:semicolon
multiline_comment|/*&n;&t; &t;&t; *&t;Exceeding the undo range is an error.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|undo
template_param
id|SEMAEM
)paren
r_goto
id|out_of_range
suffix:semicolon
)brace
id|curr-&gt;semval
op_assign
id|result
suffix:semicolon
)brace
id|sop
op_decrement
suffix:semicolon
r_while
c_loop
(paren
id|sop
op_ge
id|sops
)paren
(brace
id|sma-&gt;sem_base
(braket
id|sop-&gt;sem_num
)braket
dot
id|sempid
op_assign
id|pid
suffix:semicolon
r_if
c_cond
(paren
id|sop-&gt;sem_flg
op_amp
id|SEM_UNDO
)paren
id|un-&gt;semadj
(braket
id|sop-&gt;sem_num
)braket
op_sub_assign
id|sop-&gt;sem_op
suffix:semicolon
id|sop
op_decrement
suffix:semicolon
)brace
id|sma-&gt;sem_otime
op_assign
id|get_seconds
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|out_of_range
suffix:colon
id|result
op_assign
op_minus
id|ERANGE
suffix:semicolon
r_goto
id|undo
suffix:semicolon
id|would_block
suffix:colon
r_if
c_cond
(paren
id|sop-&gt;sem_flg
op_amp
id|IPC_NOWAIT
)paren
id|result
op_assign
op_minus
id|EAGAIN
suffix:semicolon
r_else
id|result
op_assign
l_int|1
suffix:semicolon
id|undo
suffix:colon
id|sop
op_decrement
suffix:semicolon
r_while
c_loop
(paren
id|sop
op_ge
id|sops
)paren
(brace
id|sma-&gt;sem_base
(braket
id|sop-&gt;sem_num
)braket
dot
id|semval
op_sub_assign
id|sop-&gt;sem_op
suffix:semicolon
id|sop
op_decrement
suffix:semicolon
)brace
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/* Go through the pending queue for the indicated semaphore&n; * looking for tasks that can be completed.&n; */
DECL|function|update_queue
r_static
r_void
id|update_queue
(paren
r_struct
id|sem_array
op_star
id|sma
)paren
(brace
r_int
id|error
suffix:semicolon
r_struct
id|sem_queue
op_star
id|q
suffix:semicolon
id|q
op_assign
id|sma-&gt;sem_pending
suffix:semicolon
r_while
c_loop
(paren
id|q
)paren
(brace
id|error
op_assign
id|try_atomic_semop
c_func
(paren
id|sma
comma
id|q-&gt;sops
comma
id|q-&gt;nsops
comma
id|q-&gt;undo
comma
id|q-&gt;pid
)paren
suffix:semicolon
multiline_comment|/* Does q-&gt;sleeper still need to sleep? */
r_if
c_cond
(paren
id|error
op_le
l_int|0
)paren
(brace
r_struct
id|sem_queue
op_star
id|n
suffix:semicolon
id|remove_from_queue
c_func
(paren
id|sma
comma
id|q
)paren
suffix:semicolon
id|q-&gt;status
op_assign
id|IN_WAKEUP
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Continue scanning. The next operation&n;&t;&t;&t; * that must be checked depends on the type of the&n;&t;&t;&t; * completed operation:&n;&t;&t;&t; * - if the operation modified the array, then&n;&t;&t;&t; *   restart from the head of the queue and&n;&t;&t;&t; *   check for threads that might be waiting&n;&t;&t;&t; *   for semaphore values to become 0.&n;&t;&t;&t; * - if the operation didn&squot;t modify the array,&n;&t;&t;&t; *   then just continue.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|q-&gt;alter
)paren
id|n
op_assign
id|sma-&gt;sem_pending
suffix:semicolon
r_else
id|n
op_assign
id|q-&gt;next
suffix:semicolon
id|wake_up_process
c_func
(paren
id|q-&gt;sleeper
)paren
suffix:semicolon
multiline_comment|/* hands-off: q will disappear immediately after&n;&t;&t;&t; * writing q-&gt;status.&n;&t;&t;&t; */
id|q-&gt;status
op_assign
id|error
suffix:semicolon
id|q
op_assign
id|n
suffix:semicolon
)brace
r_else
(brace
id|q
op_assign
id|q-&gt;next
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* The following counts are associated to each semaphore:&n; *   semncnt        number of tasks waiting on semval being nonzero&n; *   semzcnt        number of tasks waiting on semval being zero&n; * This model assumes that a task waits on exactly one semaphore.&n; * Since semaphore operations are to be performed atomically, tasks actually&n; * wait on a whole sequence of semaphores simultaneously.&n; * The counts we return here are a rough approximation, but still&n; * warrant that semncnt+semzcnt&gt;0 if the task is on the pending queue.&n; */
DECL|function|count_semncnt
r_static
r_int
id|count_semncnt
(paren
r_struct
id|sem_array
op_star
id|sma
comma
id|ushort
id|semnum
)paren
(brace
r_int
id|semncnt
suffix:semicolon
r_struct
id|sem_queue
op_star
id|q
suffix:semicolon
id|semncnt
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|q
op_assign
id|sma-&gt;sem_pending
suffix:semicolon
id|q
suffix:semicolon
id|q
op_assign
id|q-&gt;next
)paren
(brace
r_struct
id|sembuf
op_star
id|sops
op_assign
id|q-&gt;sops
suffix:semicolon
r_int
id|nsops
op_assign
id|q-&gt;nsops
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nsops
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|sops
(braket
id|i
)braket
dot
id|sem_num
op_eq
id|semnum
op_logical_and
(paren
id|sops
(braket
id|i
)braket
dot
id|sem_op
OL
l_int|0
)paren
op_logical_and
op_logical_neg
(paren
id|sops
(braket
id|i
)braket
dot
id|sem_flg
op_amp
id|IPC_NOWAIT
)paren
)paren
id|semncnt
op_increment
suffix:semicolon
)brace
r_return
id|semncnt
suffix:semicolon
)brace
DECL|function|count_semzcnt
r_static
r_int
id|count_semzcnt
(paren
r_struct
id|sem_array
op_star
id|sma
comma
id|ushort
id|semnum
)paren
(brace
r_int
id|semzcnt
suffix:semicolon
r_struct
id|sem_queue
op_star
id|q
suffix:semicolon
id|semzcnt
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|q
op_assign
id|sma-&gt;sem_pending
suffix:semicolon
id|q
suffix:semicolon
id|q
op_assign
id|q-&gt;next
)paren
(brace
r_struct
id|sembuf
op_star
id|sops
op_assign
id|q-&gt;sops
suffix:semicolon
r_int
id|nsops
op_assign
id|q-&gt;nsops
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nsops
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|sops
(braket
id|i
)braket
dot
id|sem_num
op_eq
id|semnum
op_logical_and
(paren
id|sops
(braket
id|i
)braket
dot
id|sem_op
op_eq
l_int|0
)paren
op_logical_and
op_logical_neg
(paren
id|sops
(braket
id|i
)braket
dot
id|sem_flg
op_amp
id|IPC_NOWAIT
)paren
)paren
id|semzcnt
op_increment
suffix:semicolon
)brace
r_return
id|semzcnt
suffix:semicolon
)brace
multiline_comment|/* Free a semaphore set. freeary() is called with sem_ids.sem down and&n; * the spinlock for this semaphore set hold. sem_ids.sem remains locked&n; * on exit.&n; */
DECL|function|freeary
r_static
r_void
id|freeary
(paren
r_struct
id|sem_array
op_star
id|sma
comma
r_int
id|id
)paren
(brace
r_struct
id|sem_undo
op_star
id|un
suffix:semicolon
r_struct
id|sem_queue
op_star
id|q
suffix:semicolon
r_int
id|size
suffix:semicolon
multiline_comment|/* Invalidate the existing undo structures for this semaphore set.&n;&t; * (They will be freed without any further action in exit_sem()&n;&t; * or during the next semop.)&n;&t; */
r_for
c_loop
(paren
id|un
op_assign
id|sma-&gt;undo
suffix:semicolon
id|un
suffix:semicolon
id|un
op_assign
id|un-&gt;id_next
)paren
id|un-&gt;semid
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* Wake up all pending processes and let them fail with EIDRM. */
id|q
op_assign
id|sma-&gt;sem_pending
suffix:semicolon
r_while
c_loop
(paren
id|q
)paren
(brace
r_struct
id|sem_queue
op_star
id|n
suffix:semicolon
multiline_comment|/* lazy remove_from_queue: we are killing the whole queue */
id|q-&gt;prev
op_assign
l_int|NULL
suffix:semicolon
id|n
op_assign
id|q-&gt;next
suffix:semicolon
id|q-&gt;status
op_assign
id|IN_WAKEUP
suffix:semicolon
id|wake_up_process
c_func
(paren
id|q-&gt;sleeper
)paren
suffix:semicolon
multiline_comment|/* doesn&squot;t sleep */
id|q-&gt;status
op_assign
op_minus
id|EIDRM
suffix:semicolon
multiline_comment|/* hands-off q */
id|q
op_assign
id|n
suffix:semicolon
)brace
multiline_comment|/* Remove the semaphore set from the ID array*/
id|sma
op_assign
id|sem_rmid
c_func
(paren
id|id
)paren
suffix:semicolon
id|sem_unlock
c_func
(paren
id|sma
)paren
suffix:semicolon
id|used_sems
op_sub_assign
id|sma-&gt;sem_nsems
suffix:semicolon
id|size
op_assign
r_sizeof
(paren
op_star
id|sma
)paren
op_plus
id|sma-&gt;sem_nsems
op_star
r_sizeof
(paren
r_struct
id|sem
)paren
suffix:semicolon
id|security_sem_free
c_func
(paren
id|sma
)paren
suffix:semicolon
id|ipc_rcu_putref
c_func
(paren
id|sma
)paren
suffix:semicolon
)brace
DECL|function|copy_semid_to_user
r_static
r_int
r_int
id|copy_semid_to_user
c_func
(paren
r_void
id|__user
op_star
id|buf
comma
r_struct
id|semid64_ds
op_star
id|in
comma
r_int
id|version
)paren
(brace
r_switch
c_cond
(paren
id|version
)paren
(brace
r_case
id|IPC_64
suffix:colon
r_return
id|copy_to_user
c_func
(paren
id|buf
comma
id|in
comma
r_sizeof
(paren
op_star
id|in
)paren
)paren
suffix:semicolon
r_case
id|IPC_OLD
suffix:colon
(brace
r_struct
id|semid_ds
id|out
suffix:semicolon
id|ipc64_perm_to_ipc_perm
c_func
(paren
op_amp
id|in-&gt;sem_perm
comma
op_amp
id|out.sem_perm
)paren
suffix:semicolon
id|out.sem_otime
op_assign
id|in-&gt;sem_otime
suffix:semicolon
id|out.sem_ctime
op_assign
id|in-&gt;sem_ctime
suffix:semicolon
id|out.sem_nsems
op_assign
id|in-&gt;sem_nsems
suffix:semicolon
r_return
id|copy_to_user
c_func
(paren
id|buf
comma
op_amp
id|out
comma
r_sizeof
(paren
id|out
)paren
)paren
suffix:semicolon
)brace
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
DECL|function|semctl_nolock
r_static
r_int
id|semctl_nolock
c_func
(paren
r_int
id|semid
comma
r_int
id|semnum
comma
r_int
id|cmd
comma
r_int
id|version
comma
r_union
id|semun
id|arg
)paren
(brace
r_int
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_struct
id|sem_array
op_star
id|sma
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|IPC_INFO
suffix:colon
r_case
id|SEM_INFO
suffix:colon
(brace
r_struct
id|seminfo
id|seminfo
suffix:semicolon
r_int
id|max_id
suffix:semicolon
id|err
op_assign
id|security_sem_semctl
c_func
(paren
l_int|NULL
comma
id|cmd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|seminfo
comma
l_int|0
comma
r_sizeof
(paren
id|seminfo
)paren
)paren
suffix:semicolon
id|seminfo.semmni
op_assign
id|sc_semmni
suffix:semicolon
id|seminfo.semmns
op_assign
id|sc_semmns
suffix:semicolon
id|seminfo.semmsl
op_assign
id|sc_semmsl
suffix:semicolon
id|seminfo.semopm
op_assign
id|sc_semopm
suffix:semicolon
id|seminfo.semvmx
op_assign
id|SEMVMX
suffix:semicolon
id|seminfo.semmnu
op_assign
id|SEMMNU
suffix:semicolon
id|seminfo.semmap
op_assign
id|SEMMAP
suffix:semicolon
id|seminfo.semume
op_assign
id|SEMUME
suffix:semicolon
id|down
c_func
(paren
op_amp
id|sem_ids.sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_eq
id|SEM_INFO
)paren
(brace
id|seminfo.semusz
op_assign
id|sem_ids.in_use
suffix:semicolon
id|seminfo.semaem
op_assign
id|used_sems
suffix:semicolon
)brace
r_else
(brace
id|seminfo.semusz
op_assign
id|SEMUSZ
suffix:semicolon
id|seminfo.semaem
op_assign
id|SEMAEM
suffix:semicolon
)brace
id|max_id
op_assign
id|sem_ids.max_id
suffix:semicolon
id|up
c_func
(paren
op_amp
id|sem_ids.sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
(paren
id|arg.__buf
comma
op_amp
id|seminfo
comma
r_sizeof
(paren
r_struct
id|seminfo
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
(paren
id|max_id
OL
l_int|0
)paren
ques
c_cond
l_int|0
suffix:colon
id|max_id
suffix:semicolon
)brace
r_case
id|SEM_STAT
suffix:colon
(brace
r_struct
id|semid64_ds
id|tbuf
suffix:semicolon
r_int
id|id
suffix:semicolon
r_if
c_cond
(paren
id|semid
op_ge
id|sem_ids.entries-&gt;size
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|memset
c_func
(paren
op_amp
id|tbuf
comma
l_int|0
comma
r_sizeof
(paren
id|tbuf
)paren
)paren
suffix:semicolon
id|sma
op_assign
id|sem_lock
c_func
(paren
id|semid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sma
op_eq
l_int|NULL
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|err
op_assign
op_minus
id|EACCES
suffix:semicolon
r_if
c_cond
(paren
id|ipcperms
(paren
op_amp
id|sma-&gt;sem_perm
comma
id|S_IRUGO
)paren
)paren
r_goto
id|out_unlock
suffix:semicolon
id|err
op_assign
id|security_sem_semctl
c_func
(paren
id|sma
comma
id|cmd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out_unlock
suffix:semicolon
id|id
op_assign
id|sem_buildid
c_func
(paren
id|semid
comma
id|sma-&gt;sem_perm.seq
)paren
suffix:semicolon
id|kernel_to_ipc64_perm
c_func
(paren
op_amp
id|sma-&gt;sem_perm
comma
op_amp
id|tbuf.sem_perm
)paren
suffix:semicolon
id|tbuf.sem_otime
op_assign
id|sma-&gt;sem_otime
suffix:semicolon
id|tbuf.sem_ctime
op_assign
id|sma-&gt;sem_ctime
suffix:semicolon
id|tbuf.sem_nsems
op_assign
id|sma-&gt;sem_nsems
suffix:semicolon
id|sem_unlock
c_func
(paren
id|sma
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_semid_to_user
(paren
id|arg.buf
comma
op_amp
id|tbuf
comma
id|version
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
id|id
suffix:semicolon
)brace
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
id|err
suffix:semicolon
id|out_unlock
suffix:colon
id|sem_unlock
c_func
(paren
id|sma
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|function|semctl_main
r_static
r_int
id|semctl_main
c_func
(paren
r_int
id|semid
comma
r_int
id|semnum
comma
r_int
id|cmd
comma
r_int
id|version
comma
r_union
id|semun
id|arg
)paren
(brace
r_struct
id|sem_array
op_star
id|sma
suffix:semicolon
r_struct
id|sem
op_star
id|curr
suffix:semicolon
r_int
id|err
suffix:semicolon
id|ushort
id|fast_sem_io
(braket
id|SEMMSL_FAST
)braket
suffix:semicolon
id|ushort
op_star
id|sem_io
op_assign
id|fast_sem_io
suffix:semicolon
r_int
id|nsems
suffix:semicolon
id|sma
op_assign
id|sem_lock
c_func
(paren
id|semid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sma
op_eq
l_int|NULL
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|nsems
op_assign
id|sma-&gt;sem_nsems
suffix:semicolon
id|err
op_assign
op_minus
id|EIDRM
suffix:semicolon
r_if
c_cond
(paren
id|sem_checkid
c_func
(paren
id|sma
comma
id|semid
)paren
)paren
r_goto
id|out_unlock
suffix:semicolon
id|err
op_assign
op_minus
id|EACCES
suffix:semicolon
r_if
c_cond
(paren
id|ipcperms
(paren
op_amp
id|sma-&gt;sem_perm
comma
(paren
id|cmd
op_eq
id|SETVAL
op_logical_or
id|cmd
op_eq
id|SETALL
)paren
ques
c_cond
id|S_IWUGO
suffix:colon
id|S_IRUGO
)paren
)paren
r_goto
id|out_unlock
suffix:semicolon
id|err
op_assign
id|security_sem_semctl
c_func
(paren
id|sma
comma
id|cmd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out_unlock
suffix:semicolon
id|err
op_assign
op_minus
id|EACCES
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|GETALL
suffix:colon
(brace
id|ushort
id|__user
op_star
id|array
op_assign
id|arg.array
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|nsems
OG
id|SEMMSL_FAST
)paren
(brace
id|ipc_rcu_getref
c_func
(paren
id|sma
)paren
suffix:semicolon
id|sem_unlock
c_func
(paren
id|sma
)paren
suffix:semicolon
id|sem_io
op_assign
id|ipc_alloc
c_func
(paren
r_sizeof
(paren
id|ushort
)paren
op_star
id|nsems
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sem_io
op_eq
l_int|NULL
)paren
(brace
id|ipc_lock_by_ptr
c_func
(paren
op_amp
id|sma-&gt;sem_perm
)paren
suffix:semicolon
id|ipc_rcu_putref
c_func
(paren
id|sma
)paren
suffix:semicolon
id|sem_unlock
c_func
(paren
id|sma
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|ipc_lock_by_ptr
c_func
(paren
op_amp
id|sma-&gt;sem_perm
)paren
suffix:semicolon
id|ipc_rcu_putref
c_func
(paren
id|sma
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sma-&gt;sem_perm.deleted
)paren
(brace
id|sem_unlock
c_func
(paren
id|sma
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EIDRM
suffix:semicolon
r_goto
id|out_free
suffix:semicolon
)brace
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|sma-&gt;sem_nsems
suffix:semicolon
id|i
op_increment
)paren
id|sem_io
(braket
id|i
)braket
op_assign
id|sma-&gt;sem_base
(braket
id|i
)braket
dot
id|semval
suffix:semicolon
id|sem_unlock
c_func
(paren
id|sma
)paren
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|array
comma
id|sem_io
comma
id|nsems
op_star
r_sizeof
(paren
id|ushort
)paren
)paren
)paren
(brace
id|err
op_assign
op_minus
id|EFAULT
suffix:semicolon
)brace
r_goto
id|out_free
suffix:semicolon
)brace
r_case
id|SETALL
suffix:colon
(brace
r_int
id|i
suffix:semicolon
r_struct
id|sem_undo
op_star
id|un
suffix:semicolon
id|ipc_rcu_getref
c_func
(paren
id|sma
)paren
suffix:semicolon
id|sem_unlock
c_func
(paren
id|sma
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nsems
OG
id|SEMMSL_FAST
)paren
(brace
id|sem_io
op_assign
id|ipc_alloc
c_func
(paren
r_sizeof
(paren
id|ushort
)paren
op_star
id|nsems
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sem_io
op_eq
l_int|NULL
)paren
(brace
id|ipc_lock_by_ptr
c_func
(paren
op_amp
id|sma-&gt;sem_perm
)paren
suffix:semicolon
id|ipc_rcu_putref
c_func
(paren
id|sma
)paren
suffix:semicolon
id|sem_unlock
c_func
(paren
id|sma
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|copy_from_user
(paren
id|sem_io
comma
id|arg.array
comma
id|nsems
op_star
r_sizeof
(paren
id|ushort
)paren
)paren
)paren
(brace
id|ipc_lock_by_ptr
c_func
(paren
op_amp
id|sma-&gt;sem_perm
)paren
suffix:semicolon
id|ipc_rcu_putref
c_func
(paren
id|sma
)paren
suffix:semicolon
id|sem_unlock
c_func
(paren
id|sma
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
id|out_free
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nsems
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|sem_io
(braket
id|i
)braket
OG
id|SEMVMX
)paren
(brace
id|ipc_lock_by_ptr
c_func
(paren
op_amp
id|sma-&gt;sem_perm
)paren
suffix:semicolon
id|ipc_rcu_putref
c_func
(paren
id|sma
)paren
suffix:semicolon
id|sem_unlock
c_func
(paren
id|sma
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|ERANGE
suffix:semicolon
r_goto
id|out_free
suffix:semicolon
)brace
)brace
id|ipc_lock_by_ptr
c_func
(paren
op_amp
id|sma-&gt;sem_perm
)paren
suffix:semicolon
id|ipc_rcu_putref
c_func
(paren
id|sma
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sma-&gt;sem_perm.deleted
)paren
(brace
id|sem_unlock
c_func
(paren
id|sma
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EIDRM
suffix:semicolon
r_goto
id|out_free
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nsems
suffix:semicolon
id|i
op_increment
)paren
id|sma-&gt;sem_base
(braket
id|i
)braket
dot
id|semval
op_assign
id|sem_io
(braket
id|i
)braket
suffix:semicolon
r_for
c_loop
(paren
id|un
op_assign
id|sma-&gt;undo
suffix:semicolon
id|un
suffix:semicolon
id|un
op_assign
id|un-&gt;id_next
)paren
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nsems
suffix:semicolon
id|i
op_increment
)paren
id|un-&gt;semadj
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
id|sma-&gt;sem_ctime
op_assign
id|get_seconds
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* maybe some queued-up processes were waiting for this */
id|update_queue
c_func
(paren
id|sma
)paren
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
r_goto
id|out_unlock
suffix:semicolon
)brace
r_case
id|IPC_STAT
suffix:colon
(brace
r_struct
id|semid64_ds
id|tbuf
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|tbuf
comma
l_int|0
comma
r_sizeof
(paren
id|tbuf
)paren
)paren
suffix:semicolon
id|kernel_to_ipc64_perm
c_func
(paren
op_amp
id|sma-&gt;sem_perm
comma
op_amp
id|tbuf.sem_perm
)paren
suffix:semicolon
id|tbuf.sem_otime
op_assign
id|sma-&gt;sem_otime
suffix:semicolon
id|tbuf.sem_ctime
op_assign
id|sma-&gt;sem_ctime
suffix:semicolon
id|tbuf.sem_nsems
op_assign
id|sma-&gt;sem_nsems
suffix:semicolon
id|sem_unlock
c_func
(paren
id|sma
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_semid_to_user
(paren
id|arg.buf
comma
op_amp
id|tbuf
comma
id|version
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* GETVAL, GETPID, GETNCTN, GETZCNT, SETVAL: fall-through */
)brace
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|semnum
OL
l_int|0
op_logical_or
id|semnum
op_ge
id|nsems
)paren
(brace
r_goto
id|out_unlock
suffix:semicolon
)brace
id|curr
op_assign
op_amp
id|sma-&gt;sem_base
(braket
id|semnum
)braket
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|GETVAL
suffix:colon
id|err
op_assign
id|curr-&gt;semval
suffix:semicolon
r_goto
id|out_unlock
suffix:semicolon
r_case
id|GETPID
suffix:colon
id|err
op_assign
id|curr-&gt;sempid
suffix:semicolon
r_goto
id|out_unlock
suffix:semicolon
r_case
id|GETNCNT
suffix:colon
id|err
op_assign
id|count_semncnt
c_func
(paren
id|sma
comma
id|semnum
)paren
suffix:semicolon
r_goto
id|out_unlock
suffix:semicolon
r_case
id|GETZCNT
suffix:colon
id|err
op_assign
id|count_semzcnt
c_func
(paren
id|sma
comma
id|semnum
)paren
suffix:semicolon
r_goto
id|out_unlock
suffix:semicolon
r_case
id|SETVAL
suffix:colon
(brace
r_int
id|val
op_assign
id|arg.val
suffix:semicolon
r_struct
id|sem_undo
op_star
id|un
suffix:semicolon
id|err
op_assign
op_minus
id|ERANGE
suffix:semicolon
r_if
c_cond
(paren
id|val
OG
id|SEMVMX
op_logical_or
id|val
OL
l_int|0
)paren
r_goto
id|out_unlock
suffix:semicolon
r_for
c_loop
(paren
id|un
op_assign
id|sma-&gt;undo
suffix:semicolon
id|un
suffix:semicolon
id|un
op_assign
id|un-&gt;id_next
)paren
id|un-&gt;semadj
(braket
id|semnum
)braket
op_assign
l_int|0
suffix:semicolon
id|curr-&gt;semval
op_assign
id|val
suffix:semicolon
id|curr-&gt;sempid
op_assign
id|current-&gt;tgid
suffix:semicolon
id|sma-&gt;sem_ctime
op_assign
id|get_seconds
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* maybe some queued-up processes were waiting for this */
id|update_queue
c_func
(paren
id|sma
)paren
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
r_goto
id|out_unlock
suffix:semicolon
)brace
)brace
id|out_unlock
suffix:colon
id|sem_unlock
c_func
(paren
id|sma
)paren
suffix:semicolon
id|out_free
suffix:colon
r_if
c_cond
(paren
id|sem_io
op_ne
id|fast_sem_io
)paren
(brace
id|ipc_free
c_func
(paren
id|sem_io
comma
r_sizeof
(paren
id|ushort
)paren
op_star
id|nsems
)paren
suffix:semicolon
)brace
r_return
id|err
suffix:semicolon
)brace
DECL|struct|sem_setbuf
r_struct
id|sem_setbuf
(brace
DECL|member|uid
id|uid_t
id|uid
suffix:semicolon
DECL|member|gid
id|gid_t
id|gid
suffix:semicolon
DECL|member|mode
id|mode_t
id|mode
suffix:semicolon
)brace
suffix:semicolon
DECL|function|copy_semid_from_user
r_static
r_inline
r_int
r_int
id|copy_semid_from_user
c_func
(paren
r_struct
id|sem_setbuf
op_star
id|out
comma
r_void
id|__user
op_star
id|buf
comma
r_int
id|version
)paren
(brace
r_switch
c_cond
(paren
id|version
)paren
(brace
r_case
id|IPC_64
suffix:colon
(brace
r_struct
id|semid64_ds
id|tbuf
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|tbuf
comma
id|buf
comma
r_sizeof
(paren
id|tbuf
)paren
)paren
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
id|out-&gt;uid
op_assign
id|tbuf.sem_perm.uid
suffix:semicolon
id|out-&gt;gid
op_assign
id|tbuf.sem_perm.gid
suffix:semicolon
id|out-&gt;mode
op_assign
id|tbuf.sem_perm.mode
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|IPC_OLD
suffix:colon
(brace
r_struct
id|semid_ds
id|tbuf_old
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|tbuf_old
comma
id|buf
comma
r_sizeof
(paren
id|tbuf_old
)paren
)paren
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
id|out-&gt;uid
op_assign
id|tbuf_old.sem_perm.uid
suffix:semicolon
id|out-&gt;gid
op_assign
id|tbuf_old.sem_perm.gid
suffix:semicolon
id|out-&gt;mode
op_assign
id|tbuf_old.sem_perm.mode
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
DECL|function|semctl_down
r_static
r_int
id|semctl_down
c_func
(paren
r_int
id|semid
comma
r_int
id|semnum
comma
r_int
id|cmd
comma
r_int
id|version
comma
r_union
id|semun
id|arg
)paren
(brace
r_struct
id|sem_array
op_star
id|sma
suffix:semicolon
r_int
id|err
suffix:semicolon
r_struct
id|sem_setbuf
id|setbuf
suffix:semicolon
r_struct
id|kern_ipc_perm
op_star
id|ipcp
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_eq
id|IPC_SET
)paren
(brace
r_if
c_cond
(paren
id|copy_semid_from_user
(paren
op_amp
id|setbuf
comma
id|arg.buf
comma
id|version
)paren
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|err
op_assign
id|audit_ipc_perms
c_func
(paren
l_int|0
comma
id|setbuf.uid
comma
id|setbuf.gid
comma
id|setbuf.mode
)paren
)paren
)paren
r_return
id|err
suffix:semicolon
)brace
id|sma
op_assign
id|sem_lock
c_func
(paren
id|semid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sma
op_eq
l_int|NULL
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sem_checkid
c_func
(paren
id|sma
comma
id|semid
)paren
)paren
(brace
id|err
op_assign
op_minus
id|EIDRM
suffix:semicolon
r_goto
id|out_unlock
suffix:semicolon
)brace
id|ipcp
op_assign
op_amp
id|sma-&gt;sem_perm
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;euid
op_ne
id|ipcp-&gt;cuid
op_logical_and
id|current-&gt;euid
op_ne
id|ipcp-&gt;uid
op_logical_and
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_ADMIN
)paren
)paren
(brace
id|err
op_assign
op_minus
id|EPERM
suffix:semicolon
r_goto
id|out_unlock
suffix:semicolon
)brace
id|err
op_assign
id|security_sem_semctl
c_func
(paren
id|sma
comma
id|cmd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out_unlock
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|IPC_RMID
suffix:colon
id|freeary
c_func
(paren
id|sma
comma
id|semid
)paren
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IPC_SET
suffix:colon
id|ipcp-&gt;uid
op_assign
id|setbuf.uid
suffix:semicolon
id|ipcp-&gt;gid
op_assign
id|setbuf.gid
suffix:semicolon
id|ipcp-&gt;mode
op_assign
(paren
id|ipcp-&gt;mode
op_amp
op_complement
id|S_IRWXUGO
)paren
op_or
(paren
id|setbuf.mode
op_amp
id|S_IRWXUGO
)paren
suffix:semicolon
id|sma-&gt;sem_ctime
op_assign
id|get_seconds
c_func
(paren
)paren
suffix:semicolon
id|sem_unlock
c_func
(paren
id|sma
)paren
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|sem_unlock
c_func
(paren
id|sma
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|err
suffix:semicolon
id|out_unlock
suffix:colon
id|sem_unlock
c_func
(paren
id|sma
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|function|sys_semctl
id|asmlinkage
r_int
id|sys_semctl
(paren
r_int
id|semid
comma
r_int
id|semnum
comma
r_int
id|cmd
comma
r_union
id|semun
id|arg
)paren
(brace
r_int
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_int
id|version
suffix:semicolon
r_if
c_cond
(paren
id|semid
OL
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|version
op_assign
id|ipc_parse_version
c_func
(paren
op_amp
id|cmd
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|IPC_INFO
suffix:colon
r_case
id|SEM_INFO
suffix:colon
r_case
id|SEM_STAT
suffix:colon
id|err
op_assign
id|semctl_nolock
c_func
(paren
id|semid
comma
id|semnum
comma
id|cmd
comma
id|version
comma
id|arg
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
r_case
id|GETALL
suffix:colon
r_case
id|GETVAL
suffix:colon
r_case
id|GETPID
suffix:colon
r_case
id|GETNCNT
suffix:colon
r_case
id|GETZCNT
suffix:colon
r_case
id|IPC_STAT
suffix:colon
r_case
id|SETVAL
suffix:colon
r_case
id|SETALL
suffix:colon
id|err
op_assign
id|semctl_main
c_func
(paren
id|semid
comma
id|semnum
comma
id|cmd
comma
id|version
comma
id|arg
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
r_case
id|IPC_RMID
suffix:colon
r_case
id|IPC_SET
suffix:colon
id|down
c_func
(paren
op_amp
id|sem_ids.sem
)paren
suffix:semicolon
id|err
op_assign
id|semctl_down
c_func
(paren
id|semid
comma
id|semnum
comma
id|cmd
comma
id|version
comma
id|arg
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|sem_ids.sem
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
DECL|function|lock_semundo
r_static
r_inline
r_void
id|lock_semundo
c_func
(paren
r_void
)paren
(brace
r_struct
id|sem_undo_list
op_star
id|undo_list
suffix:semicolon
id|undo_list
op_assign
id|current-&gt;sysvsem.undo_list
suffix:semicolon
r_if
c_cond
(paren
(paren
id|undo_list
op_ne
l_int|NULL
)paren
op_logical_and
(paren
id|atomic_read
c_func
(paren
op_amp
id|undo_list-&gt;refcnt
)paren
op_ne
l_int|1
)paren
)paren
id|spin_lock
c_func
(paren
op_amp
id|undo_list-&gt;lock
)paren
suffix:semicolon
)brace
multiline_comment|/* This code has an interaction with copy_semundo().&n; * Consider; two tasks are sharing the undo_list. task1&n; * acquires the undo_list lock in lock_semundo().  If task2 now&n; * exits before task1 releases the lock (by calling&n; * unlock_semundo()), then task1 will never call spin_unlock().&n; * This leave the sem_undo_list in a locked state.  If task1 now creats task3&n; * and once again shares the sem_undo_list, the sem_undo_list will still be&n; * locked, and future SEM_UNDO operations will deadlock.  This case is&n; * dealt with in copy_semundo() by having it reinitialize the spin lock when &n; * the refcnt goes from 1 to 2.&n; */
DECL|function|unlock_semundo
r_static
r_inline
r_void
id|unlock_semundo
c_func
(paren
r_void
)paren
(brace
r_struct
id|sem_undo_list
op_star
id|undo_list
suffix:semicolon
id|undo_list
op_assign
id|current-&gt;sysvsem.undo_list
suffix:semicolon
r_if
c_cond
(paren
(paren
id|undo_list
op_ne
l_int|NULL
)paren
op_logical_and
(paren
id|atomic_read
c_func
(paren
op_amp
id|undo_list-&gt;refcnt
)paren
op_ne
l_int|1
)paren
)paren
id|spin_unlock
c_func
(paren
op_amp
id|undo_list-&gt;lock
)paren
suffix:semicolon
)brace
multiline_comment|/* If the task doesn&squot;t already have a undo_list, then allocate one&n; * here.  We guarantee there is only one thread using this undo list,&n; * and current is THE ONE&n; *&n; * If this allocation and assignment succeeds, but later&n; * portions of this code fail, there is no need to free the sem_undo_list.&n; * Just let it stay associated with the task, and it&squot;ll be freed later&n; * at exit time.&n; *&n; * This can block, so callers must hold no locks.&n; */
DECL|function|get_undo_list
r_static
r_inline
r_int
id|get_undo_list
c_func
(paren
r_struct
id|sem_undo_list
op_star
op_star
id|undo_listp
)paren
(brace
r_struct
id|sem_undo_list
op_star
id|undo_list
suffix:semicolon
r_int
id|size
suffix:semicolon
id|undo_list
op_assign
id|current-&gt;sysvsem.undo_list
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|undo_list
)paren
(brace
id|size
op_assign
r_sizeof
(paren
r_struct
id|sem_undo_list
)paren
suffix:semicolon
id|undo_list
op_assign
(paren
r_struct
id|sem_undo_list
op_star
)paren
id|kmalloc
c_func
(paren
id|size
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|undo_list
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|memset
c_func
(paren
id|undo_list
comma
l_int|0
comma
id|size
)paren
suffix:semicolon
multiline_comment|/* don&squot;t initialize unodhd-&gt;lock here.  It&squot;s done&n;&t;&t; * in copy_semundo() instead.&n;&t;&t; */
id|atomic_set
c_func
(paren
op_amp
id|undo_list-&gt;refcnt
comma
l_int|1
)paren
suffix:semicolon
id|current-&gt;sysvsem.undo_list
op_assign
id|undo_list
suffix:semicolon
)brace
op_star
id|undo_listp
op_assign
id|undo_list
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|lookup_undo
r_static
r_struct
id|sem_undo
op_star
id|lookup_undo
c_func
(paren
r_struct
id|sem_undo_list
op_star
id|ulp
comma
r_int
id|semid
)paren
(brace
r_struct
id|sem_undo
op_star
op_star
id|last
comma
op_star
id|un
suffix:semicolon
id|last
op_assign
op_amp
id|ulp-&gt;proc_list
suffix:semicolon
id|un
op_assign
op_star
id|last
suffix:semicolon
r_while
c_loop
(paren
id|un
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|un-&gt;semid
op_eq
id|semid
)paren
(brace
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|un-&gt;semid
op_eq
op_minus
l_int|1
)paren
(brace
op_star
id|last
op_assign
id|un-&gt;proc_next
suffix:semicolon
id|kfree
c_func
(paren
id|un
)paren
suffix:semicolon
)brace
r_else
(brace
id|last
op_assign
op_amp
id|un-&gt;proc_next
suffix:semicolon
)brace
id|un
op_assign
op_star
id|last
suffix:semicolon
)brace
r_return
id|un
suffix:semicolon
)brace
DECL|function|find_undo
r_static
r_struct
id|sem_undo
op_star
id|find_undo
c_func
(paren
r_int
id|semid
)paren
(brace
r_struct
id|sem_array
op_star
id|sma
suffix:semicolon
r_struct
id|sem_undo_list
op_star
id|ulp
suffix:semicolon
r_struct
id|sem_undo
op_star
id|un
comma
op_star
r_new
suffix:semicolon
r_int
id|nsems
suffix:semicolon
r_int
id|error
suffix:semicolon
id|error
op_assign
id|get_undo_list
c_func
(paren
op_amp
id|ulp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|ERR_PTR
c_func
(paren
id|error
)paren
suffix:semicolon
id|lock_semundo
c_func
(paren
)paren
suffix:semicolon
id|un
op_assign
id|lookup_undo
c_func
(paren
id|ulp
comma
id|semid
)paren
suffix:semicolon
id|unlock_semundo
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
id|un
op_ne
l_int|NULL
)paren
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* no undo structure around - allocate one. */
id|sma
op_assign
id|sem_lock
c_func
(paren
id|semid
)paren
suffix:semicolon
id|un
op_assign
id|ERR_PTR
c_func
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sma
op_eq
l_int|NULL
)paren
(brace
r_goto
id|out
suffix:semicolon
)brace
id|un
op_assign
id|ERR_PTR
c_func
(paren
op_minus
id|EIDRM
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sem_checkid
c_func
(paren
id|sma
comma
id|semid
)paren
)paren
(brace
id|sem_unlock
c_func
(paren
id|sma
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|nsems
op_assign
id|sma-&gt;sem_nsems
suffix:semicolon
id|ipc_rcu_getref
c_func
(paren
id|sma
)paren
suffix:semicolon
id|sem_unlock
c_func
(paren
id|sma
)paren
suffix:semicolon
r_new
op_assign
(paren
r_struct
id|sem_undo
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|sem_undo
)paren
op_plus
r_sizeof
(paren
r_int
)paren
op_star
id|nsems
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
r_new
)paren
(brace
id|ipc_lock_by_ptr
c_func
(paren
op_amp
id|sma-&gt;sem_perm
)paren
suffix:semicolon
id|ipc_rcu_putref
c_func
(paren
id|sma
)paren
suffix:semicolon
id|sem_unlock
c_func
(paren
id|sma
)paren
suffix:semicolon
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
)brace
id|memset
c_func
(paren
r_new
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|sem_undo
)paren
op_plus
r_sizeof
(paren
r_int
)paren
op_star
id|nsems
)paren
suffix:semicolon
r_new
op_member_access_from_pointer
id|semadj
op_assign
(paren
r_int
op_star
)paren
op_amp
r_new
(braket
l_int|1
)braket
suffix:semicolon
r_new
op_member_access_from_pointer
id|semid
op_assign
id|semid
suffix:semicolon
id|lock_semundo
c_func
(paren
)paren
suffix:semicolon
id|un
op_assign
id|lookup_undo
c_func
(paren
id|ulp
comma
id|semid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|un
)paren
(brace
id|unlock_semundo
c_func
(paren
)paren
suffix:semicolon
id|kfree
c_func
(paren
r_new
)paren
suffix:semicolon
id|ipc_lock_by_ptr
c_func
(paren
op_amp
id|sma-&gt;sem_perm
)paren
suffix:semicolon
id|ipc_rcu_putref
c_func
(paren
id|sma
)paren
suffix:semicolon
id|sem_unlock
c_func
(paren
id|sma
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|ipc_lock_by_ptr
c_func
(paren
op_amp
id|sma-&gt;sem_perm
)paren
suffix:semicolon
id|ipc_rcu_putref
c_func
(paren
id|sma
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sma-&gt;sem_perm.deleted
)paren
(brace
id|sem_unlock
c_func
(paren
id|sma
)paren
suffix:semicolon
id|unlock_semundo
c_func
(paren
)paren
suffix:semicolon
id|kfree
c_func
(paren
r_new
)paren
suffix:semicolon
id|un
op_assign
id|ERR_PTR
c_func
(paren
op_minus
id|EIDRM
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_new
op_member_access_from_pointer
id|proc_next
op_assign
id|ulp-&gt;proc_list
suffix:semicolon
id|ulp-&gt;proc_list
op_assign
r_new
suffix:semicolon
r_new
op_member_access_from_pointer
id|id_next
op_assign
id|sma-&gt;undo
suffix:semicolon
id|sma-&gt;undo
op_assign
r_new
suffix:semicolon
id|sem_unlock
c_func
(paren
id|sma
)paren
suffix:semicolon
id|un
op_assign
r_new
suffix:semicolon
id|unlock_semundo
c_func
(paren
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|un
suffix:semicolon
)brace
DECL|function|sys_semtimedop
id|asmlinkage
r_int
id|sys_semtimedop
c_func
(paren
r_int
id|semid
comma
r_struct
id|sembuf
id|__user
op_star
id|tsops
comma
r_int
id|nsops
comma
r_const
r_struct
id|timespec
id|__user
op_star
id|timeout
)paren
(brace
r_int
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_struct
id|sem_array
op_star
id|sma
suffix:semicolon
r_struct
id|sembuf
id|fast_sops
(braket
id|SEMOPM_FAST
)braket
suffix:semicolon
r_struct
id|sembuf
op_star
id|sops
op_assign
id|fast_sops
comma
op_star
id|sop
suffix:semicolon
r_struct
id|sem_undo
op_star
id|un
suffix:semicolon
r_int
id|undos
op_assign
l_int|0
comma
id|decrease
op_assign
l_int|0
comma
id|alter
op_assign
l_int|0
comma
id|max
suffix:semicolon
r_struct
id|sem_queue
id|queue
suffix:semicolon
r_int
r_int
id|jiffies_left
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|nsops
OL
l_int|1
op_logical_or
id|semid
OL
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|nsops
OG
id|sc_semopm
)paren
r_return
op_minus
id|E2BIG
suffix:semicolon
r_if
c_cond
(paren
id|nsops
OG
id|SEMOPM_FAST
)paren
(brace
id|sops
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|sops
)paren
op_star
id|nsops
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sops
op_eq
l_int|NULL
)paren
(brace
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|copy_from_user
(paren
id|sops
comma
id|tsops
comma
id|nsops
op_star
r_sizeof
(paren
op_star
id|tsops
)paren
)paren
)paren
(brace
id|error
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
id|out_free
suffix:semicolon
)brace
r_if
c_cond
(paren
id|timeout
)paren
(brace
r_struct
id|timespec
id|_timeout
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|_timeout
comma
id|timeout
comma
r_sizeof
(paren
op_star
id|timeout
)paren
)paren
)paren
(brace
id|error
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
id|out_free
suffix:semicolon
)brace
r_if
c_cond
(paren
id|_timeout.tv_sec
OL
l_int|0
op_logical_or
id|_timeout.tv_nsec
OL
l_int|0
op_logical_or
id|_timeout.tv_nsec
op_ge
l_int|1000000000L
)paren
(brace
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|out_free
suffix:semicolon
)brace
id|jiffies_left
op_assign
id|timespec_to_jiffies
c_func
(paren
op_amp
id|_timeout
)paren
suffix:semicolon
)brace
id|max
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|sop
op_assign
id|sops
suffix:semicolon
id|sop
OL
id|sops
op_plus
id|nsops
suffix:semicolon
id|sop
op_increment
)paren
(brace
r_if
c_cond
(paren
id|sop-&gt;sem_num
op_ge
id|max
)paren
id|max
op_assign
id|sop-&gt;sem_num
suffix:semicolon
r_if
c_cond
(paren
id|sop-&gt;sem_flg
op_amp
id|SEM_UNDO
)paren
id|undos
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|sop-&gt;sem_op
OL
l_int|0
)paren
id|decrease
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|sop-&gt;sem_op
OG
l_int|0
)paren
id|alter
op_assign
l_int|1
suffix:semicolon
)brace
id|alter
op_or_assign
id|decrease
suffix:semicolon
id|retry_undos
suffix:colon
r_if
c_cond
(paren
id|undos
)paren
(brace
id|un
op_assign
id|find_undo
c_func
(paren
id|semid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|un
)paren
)paren
(brace
id|error
op_assign
id|PTR_ERR
c_func
(paren
id|un
)paren
suffix:semicolon
r_goto
id|out_free
suffix:semicolon
)brace
)brace
r_else
id|un
op_assign
l_int|NULL
suffix:semicolon
id|sma
op_assign
id|sem_lock
c_func
(paren
id|semid
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|sma
op_eq
l_int|NULL
)paren
(brace
r_goto
id|out_free
suffix:semicolon
)brace
id|error
op_assign
op_minus
id|EIDRM
suffix:semicolon
r_if
c_cond
(paren
id|sem_checkid
c_func
(paren
id|sma
comma
id|semid
)paren
)paren
r_goto
id|out_unlock_free
suffix:semicolon
multiline_comment|/*&n;&t; * semid identifies are not unique - find_undo may have&n;&t; * allocated an undo structure, it was invalidated by an RMID&n;&t; * and now a new array with received the same id. Check and retry.&n;&t; */
r_if
c_cond
(paren
id|un
op_logical_and
id|un-&gt;semid
op_eq
op_minus
l_int|1
)paren
(brace
id|sem_unlock
c_func
(paren
id|sma
)paren
suffix:semicolon
r_goto
id|retry_undos
suffix:semicolon
)brace
id|error
op_assign
op_minus
id|EFBIG
suffix:semicolon
r_if
c_cond
(paren
id|max
op_ge
id|sma-&gt;sem_nsems
)paren
r_goto
id|out_unlock_free
suffix:semicolon
id|error
op_assign
op_minus
id|EACCES
suffix:semicolon
r_if
c_cond
(paren
id|ipcperms
c_func
(paren
op_amp
id|sma-&gt;sem_perm
comma
id|alter
ques
c_cond
id|S_IWUGO
suffix:colon
id|S_IRUGO
)paren
)paren
r_goto
id|out_unlock_free
suffix:semicolon
id|error
op_assign
id|security_sem_semop
c_func
(paren
id|sma
comma
id|sops
comma
id|nsops
comma
id|alter
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|out_unlock_free
suffix:semicolon
id|error
op_assign
id|try_atomic_semop
(paren
id|sma
comma
id|sops
comma
id|nsops
comma
id|un
comma
id|current-&gt;tgid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_le
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|alter
op_logical_and
id|error
op_eq
l_int|0
)paren
id|update_queue
(paren
id|sma
)paren
suffix:semicolon
r_goto
id|out_unlock_free
suffix:semicolon
)brace
multiline_comment|/* We need to sleep on this operation, so we put the current&n;&t; * task into the pending queue and go to sleep.&n;&t; */
id|queue.sma
op_assign
id|sma
suffix:semicolon
id|queue.sops
op_assign
id|sops
suffix:semicolon
id|queue.nsops
op_assign
id|nsops
suffix:semicolon
id|queue.undo
op_assign
id|un
suffix:semicolon
id|queue.pid
op_assign
id|current-&gt;tgid
suffix:semicolon
id|queue.id
op_assign
id|semid
suffix:semicolon
id|queue.alter
op_assign
id|alter
suffix:semicolon
r_if
c_cond
(paren
id|alter
)paren
id|append_to_queue
c_func
(paren
id|sma
comma
op_amp
id|queue
)paren
suffix:semicolon
r_else
id|prepend_to_queue
c_func
(paren
id|sma
comma
op_amp
id|queue
)paren
suffix:semicolon
id|queue.status
op_assign
op_minus
id|EINTR
suffix:semicolon
id|queue.sleeper
op_assign
id|current
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|sem_unlock
c_func
(paren
id|sma
)paren
suffix:semicolon
r_if
c_cond
(paren
id|timeout
)paren
id|jiffies_left
op_assign
id|schedule_timeout
c_func
(paren
id|jiffies_left
)paren
suffix:semicolon
r_else
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|error
op_assign
id|queue.status
suffix:semicolon
r_while
c_loop
(paren
id|unlikely
c_func
(paren
id|error
op_eq
id|IN_WAKEUP
)paren
)paren
(brace
id|cpu_relax
c_func
(paren
)paren
suffix:semicolon
id|error
op_assign
id|queue.status
suffix:semicolon
)brace
r_if
c_cond
(paren
id|error
op_ne
op_minus
id|EINTR
)paren
(brace
multiline_comment|/* fast path: update_queue already obtained all requested&n;&t;&t; * resources */
r_goto
id|out_free
suffix:semicolon
)brace
id|sma
op_assign
id|sem_lock
c_func
(paren
id|semid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sma
op_eq
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|queue.prev
op_ne
l_int|NULL
)paren
(brace
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
id|error
op_assign
op_minus
id|EIDRM
suffix:semicolon
r_goto
id|out_free
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If queue.status != -EINTR we are woken up by another process&n;&t; */
id|error
op_assign
id|queue.status
suffix:semicolon
r_if
c_cond
(paren
id|error
op_ne
op_minus
id|EINTR
)paren
(brace
r_goto
id|out_unlock_free
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If an interrupt occurred we have to clean up the queue&n;&t; */
r_if
c_cond
(paren
id|timeout
op_logical_and
id|jiffies_left
op_eq
l_int|0
)paren
id|error
op_assign
op_minus
id|EAGAIN
suffix:semicolon
id|remove_from_queue
c_func
(paren
id|sma
comma
op_amp
id|queue
)paren
suffix:semicolon
r_goto
id|out_unlock_free
suffix:semicolon
id|out_unlock_free
suffix:colon
id|sem_unlock
c_func
(paren
id|sma
)paren
suffix:semicolon
id|out_free
suffix:colon
r_if
c_cond
(paren
id|sops
op_ne
id|fast_sops
)paren
(brace
id|kfree
c_func
(paren
id|sops
)paren
suffix:semicolon
)brace
r_return
id|error
suffix:semicolon
)brace
DECL|function|sys_semop
id|asmlinkage
r_int
id|sys_semop
(paren
r_int
id|semid
comma
r_struct
id|sembuf
id|__user
op_star
id|tsops
comma
r_int
id|nsops
)paren
(brace
r_return
id|sys_semtimedop
c_func
(paren
id|semid
comma
id|tsops
comma
id|nsops
comma
l_int|NULL
)paren
suffix:semicolon
)brace
multiline_comment|/* If CLONE_SYSVSEM is set, establish sharing of SEM_UNDO state between&n; * parent and child tasks.&n; *&n; * See the notes above unlock_semundo() regarding the spin_lock_init()&n; * in this code.  Initialize the undo_list-&gt;lock here instead of get_undo_list()&n; * because of the reasoning in the comment above unlock_semundo.&n; */
DECL|function|copy_semundo
r_int
id|copy_semundo
c_func
(paren
r_int
r_int
id|clone_flags
comma
r_struct
id|task_struct
op_star
id|tsk
)paren
(brace
r_struct
id|sem_undo_list
op_star
id|undo_list
suffix:semicolon
r_int
id|error
suffix:semicolon
r_if
c_cond
(paren
id|clone_flags
op_amp
id|CLONE_SYSVSEM
)paren
(brace
id|error
op_assign
id|get_undo_list
c_func
(paren
op_amp
id|undo_list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|undo_list-&gt;refcnt
)paren
op_eq
l_int|1
)paren
id|spin_lock_init
c_func
(paren
op_amp
id|undo_list-&gt;lock
)paren
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|undo_list-&gt;refcnt
)paren
suffix:semicolon
id|tsk-&gt;sysvsem.undo_list
op_assign
id|undo_list
suffix:semicolon
)brace
r_else
id|tsk-&gt;sysvsem.undo_list
op_assign
l_int|NULL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * add semadj values to semaphores, free undo structures.&n; * undo structures are not freed when semaphore arrays are destroyed&n; * so some of them may be out of date.&n; * IMPLEMENTATION NOTE: There is some confusion over whether the&n; * set of adjustments that needs to be done should be done in an atomic&n; * manner or not. That is, if we are attempting to decrement the semval&n; * should we queue up and wait until we can do so legally?&n; * The original implementation attempted to do this (queue and wait).&n; * The current implementation does not do so. The POSIX standard&n; * and SVID should be consulted to determine what behavior is mandated.&n; */
DECL|function|exit_sem
r_void
id|exit_sem
c_func
(paren
r_struct
id|task_struct
op_star
id|tsk
)paren
(brace
r_struct
id|sem_undo_list
op_star
id|undo_list
suffix:semicolon
r_struct
id|sem_undo
op_star
id|u
comma
op_star
op_star
id|up
suffix:semicolon
id|undo_list
op_assign
id|tsk-&gt;sysvsem.undo_list
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|undo_list
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|atomic_dec_and_test
c_func
(paren
op_amp
id|undo_list-&gt;refcnt
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* There&squot;s no need to hold the semundo list lock, as current&n;         * is the last task exiting for this undo list.&n;&t; */
r_for
c_loop
(paren
id|up
op_assign
op_amp
id|undo_list-&gt;proc_list
suffix:semicolon
(paren
id|u
op_assign
op_star
id|up
)paren
suffix:semicolon
op_star
id|up
op_assign
id|u-&gt;proc_next
comma
id|kfree
c_func
(paren
id|u
)paren
)paren
(brace
r_struct
id|sem_array
op_star
id|sma
suffix:semicolon
r_int
id|nsems
comma
id|i
suffix:semicolon
r_struct
id|sem_undo
op_star
id|un
comma
op_star
op_star
id|unp
suffix:semicolon
r_int
id|semid
suffix:semicolon
id|semid
op_assign
id|u-&gt;semid
suffix:semicolon
r_if
c_cond
(paren
id|semid
op_eq
op_minus
l_int|1
)paren
(brace
r_continue
suffix:semicolon
)brace
id|sma
op_assign
id|sem_lock
c_func
(paren
id|semid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sma
op_eq
l_int|NULL
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|u-&gt;semid
op_eq
op_minus
l_int|1
)paren
r_goto
id|next_entry
suffix:semicolon
id|BUG_ON
c_func
(paren
id|sem_checkid
c_func
(paren
id|sma
comma
id|u-&gt;semid
)paren
)paren
suffix:semicolon
multiline_comment|/* remove u from the sma-&gt;undo list */
r_for
c_loop
(paren
id|unp
op_assign
op_amp
id|sma-&gt;undo
suffix:semicolon
(paren
id|un
op_assign
op_star
id|unp
)paren
suffix:semicolon
id|unp
op_assign
op_amp
id|un-&gt;id_next
)paren
(brace
r_if
c_cond
(paren
id|u
op_eq
id|un
)paren
r_goto
id|found
suffix:semicolon
)brace
id|printk
(paren
l_string|&quot;exit_sem undo list error id=%d&bslash;n&quot;
comma
id|u-&gt;semid
)paren
suffix:semicolon
r_goto
id|next_entry
suffix:semicolon
id|found
suffix:colon
op_star
id|unp
op_assign
id|un-&gt;id_next
suffix:semicolon
multiline_comment|/* perform adjustments registered in u */
id|nsems
op_assign
id|sma-&gt;sem_nsems
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nsems
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|sem
op_star
id|sem
op_assign
op_amp
id|sma-&gt;sem_base
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|u-&gt;semadj
(braket
id|i
)braket
)paren
(brace
id|sem-&gt;semval
op_add_assign
id|u-&gt;semadj
(braket
id|i
)braket
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * Range checks of the new semaphore value,&n;&t;&t;&t;&t; * not defined by sus:&n;&t;&t;&t;&t; * - Some unices ignore the undo entirely&n;&t;&t;&t;&t; *   (e.g. HP UX 11i 11.22, Tru64 V5.1)&n;&t;&t;&t;&t; * - some cap the value (e.g. FreeBSD caps&n;&t;&t;&t;&t; *   at 0, but doesn&squot;t enforce SEMVMX)&n;&t;&t;&t;&t; *&n;&t;&t;&t;&t; * Linux caps the semaphore value, both at 0&n;&t;&t;&t;&t; * and at SEMVMX.&n;&t;&t;&t;&t; *&n;&t;&t;&t;&t; * &t;Manfred &lt;manfred@colorfullife.com&gt;&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|sem-&gt;semval
OL
l_int|0
)paren
id|sem-&gt;semval
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|sem-&gt;semval
OG
id|SEMVMX
)paren
id|sem-&gt;semval
op_assign
id|SEMVMX
suffix:semicolon
id|sem-&gt;sempid
op_assign
id|current-&gt;tgid
suffix:semicolon
)brace
)brace
id|sma-&gt;sem_otime
op_assign
id|get_seconds
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* maybe some queued-up processes were waiting for this */
id|update_queue
c_func
(paren
id|sma
)paren
suffix:semicolon
id|next_entry
suffix:colon
id|sem_unlock
c_func
(paren
id|sma
)paren
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|undo_list
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_PROC_FS
DECL|function|sysvipc_sem_read_proc
r_static
r_int
id|sysvipc_sem_read_proc
c_func
(paren
r_char
op_star
id|buffer
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|length
comma
r_int
op_star
id|eof
comma
r_void
op_star
id|data
)paren
(brace
id|off_t
id|pos
op_assign
l_int|0
suffix:semicolon
id|off_t
id|begin
op_assign
l_int|0
suffix:semicolon
r_int
id|i
comma
id|len
op_assign
l_int|0
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
comma
l_string|&quot;       key      semid perms      nsems   uid   gid  cuid  cgid      otime      ctime&bslash;n&quot;
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|sem_ids.sem
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_le
id|sem_ids.max_id
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|sem_array
op_star
id|sma
suffix:semicolon
id|sma
op_assign
id|sem_lock
c_func
(paren
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sma
)paren
(brace
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;%10d %10d  %4o %10lu %5u %5u %5u %5u %10lu %10lu&bslash;n&quot;
comma
id|sma-&gt;sem_perm.key
comma
id|sem_buildid
c_func
(paren
id|i
comma
id|sma-&gt;sem_perm.seq
)paren
comma
id|sma-&gt;sem_perm.mode
comma
id|sma-&gt;sem_nsems
comma
id|sma-&gt;sem_perm.uid
comma
id|sma-&gt;sem_perm.gid
comma
id|sma-&gt;sem_perm.cuid
comma
id|sma-&gt;sem_perm.cgid
comma
id|sma-&gt;sem_otime
comma
id|sma-&gt;sem_ctime
)paren
suffix:semicolon
id|sem_unlock
c_func
(paren
id|sma
)paren
suffix:semicolon
id|pos
op_add_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
id|pos
OL
id|offset
)paren
(brace
id|len
op_assign
l_int|0
suffix:semicolon
id|begin
op_assign
id|pos
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pos
OG
id|offset
op_plus
id|length
)paren
(brace
r_goto
id|done
suffix:semicolon
)brace
)brace
)brace
op_star
id|eof
op_assign
l_int|1
suffix:semicolon
id|done
suffix:colon
id|up
c_func
(paren
op_amp
id|sem_ids.sem
)paren
suffix:semicolon
op_star
id|start
op_assign
id|buffer
op_plus
(paren
id|offset
op_minus
id|begin
)paren
suffix:semicolon
id|len
op_sub_assign
(paren
id|offset
op_minus
id|begin
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|length
)paren
(brace
id|len
op_assign
id|length
suffix:semicolon
)brace
r_if
c_cond
(paren
id|len
OL
l_int|0
)paren
(brace
id|len
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|len
suffix:semicolon
)brace
macro_line|#endif
eof
