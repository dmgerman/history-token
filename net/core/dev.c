multiline_comment|/*&n; * &t;NET3&t;Protocol independent device support routines.&n; *&n; *&t;&t;This program is free software; you can redistribute it and/or&n; *&t;&t;modify it under the terms of the GNU General Public License&n; *&t;&t;as published by the Free Software Foundation; either version&n; *&t;&t;2 of the License, or (at your option) any later version.&n; *&n; *&t;Derived from the non IP parts of dev.c 1.0.19&n; * &t;&t;Authors:&t;Ross Biro, &lt;bir7@leland.Stanford.Edu&gt;&n; *&t;&t;&t;&t;Fred N. van Kempen, &lt;waltje@uWalt.NL.Mugnet.ORG&gt;&n; *&t;&t;&t;&t;Mark Evans, &lt;evansmp@uhura.aston.ac.uk&gt;&n; *&n; *&t;Additional Authors:&n; *&t;&t;Florian la Roche &lt;rzsfl@rz.uni-sb.de&gt;&n; *&t;&t;Alan Cox &lt;gw4pts@gw4pts.ampr.org&gt;&n; *&t;&t;David Hinds &lt;dahinds@users.sourceforge.net&gt;&n; *&t;&t;Alexey Kuznetsov &lt;kuznet@ms2.inr.ac.ru&gt;&n; *&t;&t;Adam Sulmicki &lt;adam@cfar.umd.edu&gt;&n; *              Pekka Riikonen &lt;priikone@poesidon.pspt.fi&gt;&n; *&n; *&t;Changes:&n; *              D.J. Barrow     :       Fixed bug where dev-&gt;refcnt gets set&n; *              &t;&t;&t;to 2 if register_netdev gets called&n; *              &t;&t;&t;before net_dev_init &amp; also removed a&n; *              &t;&t;&t;few lines of code in the process.&n; *&t;&t;Alan Cox&t;:&t;device private ioctl copies fields back.&n; *&t;&t;Alan Cox&t;:&t;Transmit queue code does relevant&n; *&t;&t;&t;&t;&t;stunts to keep the queue safe.&n; *&t;&t;Alan Cox&t;:&t;Fixed double lock.&n; *&t;&t;Alan Cox&t;:&t;Fixed promisc NULL pointer trap&n; *&t;&t;????????&t;:&t;Support the full private ioctl range&n; *&t;&t;Alan Cox&t;:&t;Moved ioctl permission check into&n; *&t;&t;&t;&t;&t;drivers&n; *&t;&t;Tim Kordas&t;:&t;SIOCADDMULTI/SIOCDELMULTI&n; *&t;&t;Alan Cox&t;:&t;100 backlog just doesn&squot;t cut it when&n; *&t;&t;&t;&t;&t;you start doing multicast video 8)&n; *&t;&t;Alan Cox&t;:&t;Rewrote net_bh and list manager.&n; *&t;&t;Alan Cox&t;: &t;Fix ETH_P_ALL echoback lengths.&n; *&t;&t;Alan Cox&t;:&t;Took out transmit every packet pass&n; *&t;&t;&t;&t;&t;Saved a few bytes in the ioctl handler&n; *&t;&t;Alan Cox&t;:&t;Network driver sets packet type before&n; *&t;&t;&t;&t;&t;calling netif_rx. Saves a function&n; *&t;&t;&t;&t;&t;call a packet.&n; *&t;&t;Alan Cox&t;:&t;Hashed net_bh()&n; *&t;&t;Richard Kooijman:&t;Timestamp fixes.&n; *&t;&t;Alan Cox&t;:&t;Wrong field in SIOCGIFDSTADDR&n; *&t;&t;Alan Cox&t;:&t;Device lock protection.&n; *&t;&t;Alan Cox&t;: &t;Fixed nasty side effect of device close&n; *&t;&t;&t;&t;&t;changes.&n; *&t;&t;Rudi Cilibrasi&t;:&t;Pass the right thing to&n; *&t;&t;&t;&t;&t;set_mac_address()&n; *&t;&t;Dave Miller&t;:&t;32bit quantity for the device lock to&n; *&t;&t;&t;&t;&t;make it work out on a Sparc.&n; *&t;&t;Bjorn Ekwall&t;:&t;Added KERNELD hack.&n; *&t;&t;Alan Cox&t;:&t;Cleaned up the backlog initialise.&n; *&t;&t;Craig Metz&t;:&t;SIOCGIFCONF fix if space for under&n; *&t;&t;&t;&t;&t;1 device.&n; *&t;    Thomas Bogendoerfer :&t;Return ENODEV for dev_open, if there&n; *&t;&t;&t;&t;&t;is no device open function.&n; *&t;&t;Andi Kleen&t;:&t;Fix error reporting for SIOCGIFCONF&n; *&t;    Michael Chastain&t;:&t;Fix signed/unsigned for SIOCGIFCONF&n; *&t;&t;Cyrus Durgin&t;:&t;Cleaned for KMOD&n; *&t;&t;Adam Sulmicki   :&t;Bug Fix : Network Device Unload&n; *&t;&t;&t;&t;&t;A network device unload needs to purge&n; *&t;&t;&t;&t;&t;the backlog queue.&n; *&t;Paul Rusty Russell&t;:&t;SIOCSIFNAME&n; *              Pekka Riikonen  :&t;Netdev boot-time settings code&n; *              Andrew Morton   :       Make unregister_netdevice wait&n; *              &t;&t;&t;indefinitely on dev-&gt;refcnt&n; * &t;&t;J Hadi Salim&t;:&t;- Backlog queue sampling&n; *&t;&t;&t;&t;        - netif_rx() feedback&n; */
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;linux/bitops.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/cpu.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/socket.h&gt;
macro_line|#include &lt;linux/sockios.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/if_ether.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/etherdevice.h&gt;
macro_line|#include &lt;linux/notifier.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;net/sock.h&gt;
macro_line|#include &lt;linux/rtnetlink.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;linux/seq_file.h&gt;
macro_line|#include &lt;linux/stat.h&gt;
macro_line|#include &lt;linux/if_bridge.h&gt;
macro_line|#include &lt;linux/divert.h&gt;
macro_line|#include &lt;net/dst.h&gt;
macro_line|#include &lt;net/pkt_sched.h&gt;
macro_line|#include &lt;net/checksum.h&gt;
macro_line|#include &lt;linux/highmem.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/kmod.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/kallsyms.h&gt;
macro_line|#include &lt;linux/netpoll.h&gt;
macro_line|#include &lt;linux/rcupdate.h&gt;
macro_line|#ifdef CONFIG_NET_RADIO
macro_line|#include &lt;linux/wireless.h&gt;&t;&t;/* Note : will define WIRELESS_EXT */
macro_line|#include &lt;net/iw_handler.h&gt;
macro_line|#endif&t;/* CONFIG_NET_RADIO */
macro_line|#include &lt;asm/current.h&gt;
multiline_comment|/* This define, if set, will randomly drop a packet when congestion&n; * is more than moderate.  It helps fairness in the multi-interface&n; * case when one of them is a hog, but it kills performance for the&n; * single interface case so it is off now by default.&n; */
DECL|macro|RAND_LIE
macro_line|#undef RAND_LIE
multiline_comment|/* Setting this will sample the queue lengths and thus congestion&n; * via a timer instead of as each packet is received.&n; */
DECL|macro|OFFLINE_SAMPLE
macro_line|#undef OFFLINE_SAMPLE
multiline_comment|/*&n; *&t;The list of packet types we will receive (as opposed to discard)&n; *&t;and the routines to invoke.&n; *&n; *&t;Why 16. Because with 16 the only overlap we get on a hash of the&n; *&t;low nibble of the protocol value is RARP/SNAP/X.25.&n; *&n; *      NOTE:  That is no longer true with the addition of VLAN tags.  Not&n; *             sure which should go first, but I bet it won&squot;t make much&n; *             difference if we are running VLANs.  The good news is that&n; *             this protocol won&squot;t be in the list unless compiled in, so&n; *             the average user (w/out VLANs) will not be adversly affected.&n; *             --BLG&n; *&n; *&t;&t;0800&t;IP&n; *&t;&t;8100    802.1Q VLAN&n; *&t;&t;0001&t;802.3&n; *&t;&t;0002&t;AX.25&n; *&t;&t;0004&t;802.2&n; *&t;&t;8035&t;RARP&n; *&t;&t;0005&t;SNAP&n; *&t;&t;0805&t;X.25&n; *&t;&t;0806&t;ARP&n; *&t;&t;8137&t;IPX&n; *&t;&t;0009&t;Localtalk&n; *&t;&t;86DD&t;IPv6&n; */
DECL|variable|ptype_lock
r_static
id|spinlock_t
id|ptype_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
DECL|variable|ptype_base
r_static
r_struct
id|list_head
id|ptype_base
(braket
l_int|16
)braket
suffix:semicolon
multiline_comment|/* 16 way hashed list */
DECL|variable|ptype_all
r_static
r_struct
id|list_head
id|ptype_all
suffix:semicolon
multiline_comment|/* Taps */
macro_line|#ifdef OFFLINE_SAMPLE
r_static
r_void
id|sample_queue
c_func
(paren
r_int
r_int
id|dummy
)paren
suffix:semicolon
DECL|variable|samp_timer
r_static
r_struct
id|timer_list
id|samp_timer
op_assign
id|TIMER_INITIALIZER
c_func
(paren
id|sample_queue
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; * The @dev_base list is protected by @dev_base_lock and the rtln&n; * semaphore.&n; *&n; * Pure readers hold dev_base_lock for reading.&n; *&n; * Writers must hold the rtnl semaphore while they loop through the&n; * dev_base list, and hold dev_base_lock for writing when they do the&n; * actual updates.  This allows pure readers to access the list even&n; * while a writer is preparing to update it.&n; *&n; * To put it another way, dev_base_lock is held for writing only to&n; * protect against pure readers; the rtnl semaphore provides the&n; * protection against other writers.&n; *&n; * See, for example usages, register_netdevice() and&n; * unregister_netdevice(), which must be called with the rtnl&n; * semaphore held.&n; */
DECL|variable|dev_base
r_struct
id|net_device
op_star
id|dev_base
suffix:semicolon
DECL|variable|dev_tail
r_static
r_struct
id|net_device
op_star
op_star
id|dev_tail
op_assign
op_amp
id|dev_base
suffix:semicolon
DECL|variable|dev_base_lock
id|rwlock_t
id|dev_base_lock
op_assign
id|RW_LOCK_UNLOCKED
suffix:semicolon
DECL|variable|dev_base
id|EXPORT_SYMBOL
c_func
(paren
id|dev_base
)paren
suffix:semicolon
DECL|variable|dev_base_lock
id|EXPORT_SYMBOL
c_func
(paren
id|dev_base_lock
)paren
suffix:semicolon
DECL|macro|NETDEV_HASHBITS
mdefine_line|#define NETDEV_HASHBITS&t;8
DECL|variable|dev_name_head
r_static
r_struct
id|hlist_head
id|dev_name_head
(braket
l_int|1
op_lshift
id|NETDEV_HASHBITS
)braket
suffix:semicolon
DECL|variable|dev_index_head
r_static
r_struct
id|hlist_head
id|dev_index_head
(braket
l_int|1
op_lshift
id|NETDEV_HASHBITS
)braket
suffix:semicolon
DECL|function|dev_name_hash
r_static
r_inline
r_struct
id|hlist_head
op_star
id|dev_name_hash
c_func
(paren
r_const
r_char
op_star
id|name
)paren
(brace
r_int
id|hash
op_assign
id|full_name_hash
c_func
(paren
id|name
comma
id|strnlen
c_func
(paren
id|name
comma
id|IFNAMSIZ
)paren
)paren
suffix:semicolon
r_return
op_amp
id|dev_name_head
(braket
id|hash
op_amp
(paren
(paren
l_int|1
op_lshift
id|NETDEV_HASHBITS
)paren
op_minus
l_int|1
)paren
)braket
suffix:semicolon
)brace
DECL|function|dev_index_hash
r_static
r_inline
r_struct
id|hlist_head
op_star
id|dev_index_hash
c_func
(paren
r_int
id|ifindex
)paren
(brace
r_return
op_amp
id|dev_index_head
(braket
id|ifindex
op_amp
(paren
(paren
l_int|1
op_lshift
id|NETDEV_HASHBITS
)paren
op_minus
l_int|1
)paren
)braket
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Our notifier list&n; */
DECL|variable|netdev_chain
r_static
r_struct
id|notifier_block
op_star
id|netdev_chain
suffix:semicolon
multiline_comment|/*&n; *&t;Device drivers call our routines to queue packets here. We empty the&n; *&t;queue in the local softnet handler.&n; */
id|DEFINE_PER_CPU
c_func
(paren
r_struct
id|softnet_data
comma
id|softnet_data
)paren
op_assign
(brace
l_int|0
comma
)brace
suffix:semicolon
macro_line|#ifdef CONFIG_SYSFS
r_extern
r_int
id|netdev_sysfs_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_int
id|netdev_register_sysfs
c_func
(paren
r_struct
id|net_device
op_star
)paren
suffix:semicolon
r_extern
r_void
id|netdev_unregister_sysfs
c_func
(paren
r_struct
id|net_device
op_star
)paren
suffix:semicolon
macro_line|#else
DECL|macro|netdev_sysfs_init
mdefine_line|#define netdev_sysfs_init()&t; &t;(0)
DECL|macro|netdev_register_sysfs
mdefine_line|#define netdev_register_sysfs(dev)&t;(0)
DECL|macro|netdev_unregister_sysfs
mdefine_line|#define&t;netdev_unregister_sysfs(dev)&t;do { } while(0)
macro_line|#endif
multiline_comment|/*******************************************************************************&n;&n;&t;&t;Protocol management and registration routines&n;&n;*******************************************************************************/
multiline_comment|/*&n; *&t;For efficiency&n; */
DECL|variable|netdev_nit
r_int
id|netdev_nit
suffix:semicolon
multiline_comment|/*&n; *&t;Add a protocol ID to the list. Now that the input handler is&n; *&t;smarter we can dispense with all the messy stuff that used to be&n; *&t;here.&n; *&n; *&t;BEWARE!!! Protocol handlers, mangling input packets,&n; *&t;MUST BE last in hash buckets and checking protocol handlers&n; *&t;MUST start from promiscuous ptype_all chain in net_bh.&n; *&t;It is true now, do not change it.&n; *&t;Explanation follows: if protocol handler, mangling packet, will&n; *&t;be the first on list, it is not able to sense, that packet&n; *&t;is cloned and should be copied-on-write, so that it will&n; *&t;change it and subsequent readers will get broken packet.&n; *&t;&t;&t;&t;&t;&t;&t;--ANK (980803)&n; */
multiline_comment|/**&n; *&t;dev_add_pack - add packet handler&n; *&t;@pt: packet type declaration&n; *&n; *&t;Add a protocol handler to the networking stack. The passed &amp;packet_type&n; *&t;is linked into kernel lists and may not be freed until it has been&n; *&t;removed from the kernel lists.&n; *&n; *&t;This call does not sleep therefore it can not &n; *&t;guarantee all CPU&squot;s that are in middle of receiving packets&n; *&t;will see the new packet type (until the next received packet).&n; */
DECL|function|dev_add_pack
r_void
id|dev_add_pack
c_func
(paren
r_struct
id|packet_type
op_star
id|pt
)paren
(brace
r_int
id|hash
suffix:semicolon
id|spin_lock_bh
c_func
(paren
op_amp
id|ptype_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pt-&gt;type
op_eq
id|htons
c_func
(paren
id|ETH_P_ALL
)paren
)paren
(brace
id|netdev_nit
op_increment
suffix:semicolon
id|list_add_rcu
c_func
(paren
op_amp
id|pt-&gt;list
comma
op_amp
id|ptype_all
)paren
suffix:semicolon
)brace
r_else
(brace
id|hash
op_assign
id|ntohs
c_func
(paren
id|pt-&gt;type
)paren
op_amp
l_int|15
suffix:semicolon
id|list_add_rcu
c_func
(paren
op_amp
id|pt-&gt;list
comma
op_amp
id|ptype_base
(braket
id|hash
)braket
)paren
suffix:semicolon
)brace
id|spin_unlock_bh
c_func
(paren
op_amp
id|ptype_lock
)paren
suffix:semicolon
)brace
r_extern
r_void
id|linkwatch_run_queue
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/**&n; *&t;__dev_remove_pack&t; - remove packet handler&n; *&t;@pt: packet type declaration&n; *&n; *&t;Remove a protocol handler that was previously added to the kernel&n; *&t;protocol handlers by dev_add_pack(). The passed &amp;packet_type is removed&n; *&t;from the kernel lists and can be freed or reused once this function&n; *&t;returns. &n; *&n; *      The packet type might still be in use by receivers&n; *&t;and must not be freed until after all the CPU&squot;s have gone&n; *&t;through a quiescent state.&n; */
DECL|function|__dev_remove_pack
r_void
id|__dev_remove_pack
c_func
(paren
r_struct
id|packet_type
op_star
id|pt
)paren
(brace
r_struct
id|list_head
op_star
id|head
suffix:semicolon
r_struct
id|packet_type
op_star
id|pt1
suffix:semicolon
id|spin_lock_bh
c_func
(paren
op_amp
id|ptype_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pt-&gt;type
op_eq
id|htons
c_func
(paren
id|ETH_P_ALL
)paren
)paren
(brace
id|netdev_nit
op_decrement
suffix:semicolon
id|head
op_assign
op_amp
id|ptype_all
suffix:semicolon
)brace
r_else
id|head
op_assign
op_amp
id|ptype_base
(braket
id|ntohs
c_func
(paren
id|pt-&gt;type
)paren
op_amp
l_int|15
)braket
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|pt1
comma
id|head
comma
id|list
)paren
(brace
r_if
c_cond
(paren
id|pt
op_eq
id|pt1
)paren
(brace
id|list_del_rcu
c_func
(paren
op_amp
id|pt-&gt;list
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;dev_remove_pack: %p not found.&bslash;n&quot;
comma
id|pt
)paren
suffix:semicolon
id|out
suffix:colon
id|spin_unlock_bh
c_func
(paren
op_amp
id|ptype_lock
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;dev_remove_pack&t; - remove packet handler&n; *&t;@pt: packet type declaration&n; *&n; *&t;Remove a protocol handler that was previously added to the kernel&n; *&t;protocol handlers by dev_add_pack(). The passed &amp;packet_type is removed&n; *&t;from the kernel lists and can be freed or reused once this function&n; *&t;returns.&n; *&n; *&t;This call sleeps to guarantee that no CPU is looking at the packet&n; *&t;type after return.&n; */
DECL|function|dev_remove_pack
r_void
id|dev_remove_pack
c_func
(paren
r_struct
id|packet_type
op_star
id|pt
)paren
(brace
id|__dev_remove_pack
c_func
(paren
id|pt
)paren
suffix:semicolon
id|synchronize_net
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n;&n;&t;&t;      Device Boot-time Settings Routines&n;&n;*******************************************************************************/
multiline_comment|/* Boot time configuration table */
DECL|variable|dev_boot_setup
r_static
r_struct
id|netdev_boot_setup
id|dev_boot_setup
(braket
id|NETDEV_BOOT_SETUP_MAX
)braket
suffix:semicolon
multiline_comment|/**&n; *&t;netdev_boot_setup_add&t;- add new setup entry&n; *&t;@name: name of the device&n; *&t;@map: configured settings for the device&n; *&n; *&t;Adds new setup entry to the dev_boot_setup list.  The function&n; *&t;returns 0 on error and 1 on success.  This is a generic routine to&n; *&t;all netdevices.&n; */
DECL|function|netdev_boot_setup_add
r_static
r_int
id|netdev_boot_setup_add
c_func
(paren
r_char
op_star
id|name
comma
r_struct
id|ifmap
op_star
id|map
)paren
(brace
r_struct
id|netdev_boot_setup
op_star
id|s
suffix:semicolon
r_int
id|i
suffix:semicolon
id|s
op_assign
id|dev_boot_setup
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NETDEV_BOOT_SETUP_MAX
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|s
(braket
id|i
)braket
dot
id|name
(braket
l_int|0
)braket
op_eq
l_char|&squot;&bslash;0&squot;
op_logical_or
id|s
(braket
id|i
)braket
dot
id|name
(braket
l_int|0
)braket
op_eq
l_char|&squot; &squot;
)paren
(brace
id|memset
c_func
(paren
id|s
(braket
id|i
)braket
dot
id|name
comma
l_int|0
comma
r_sizeof
(paren
id|s
(braket
id|i
)braket
dot
id|name
)paren
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|s
(braket
id|i
)braket
dot
id|name
comma
id|name
)paren
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|s
(braket
id|i
)braket
dot
id|map
comma
id|map
comma
r_sizeof
(paren
id|s
(braket
id|i
)braket
dot
id|map
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_return
id|i
op_ge
id|NETDEV_BOOT_SETUP_MAX
ques
c_cond
l_int|0
suffix:colon
l_int|1
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;netdev_boot_setup_check&t;- check boot time settings&n; *&t;@dev: the netdevice&n; *&n; * &t;Check boot time settings for the device.&n; *&t;The found settings are set for the device to be used&n; *&t;later in the device probing.&n; *&t;Returns 0 if no settings found, 1 if they are.&n; */
DECL|function|netdev_boot_setup_check
r_int
id|netdev_boot_setup_check
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|netdev_boot_setup
op_star
id|s
op_assign
id|dev_boot_setup
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NETDEV_BOOT_SETUP_MAX
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|s
(braket
id|i
)braket
dot
id|name
(braket
l_int|0
)braket
op_ne
l_char|&squot;&bslash;0&squot;
op_logical_and
id|s
(braket
id|i
)braket
dot
id|name
(braket
l_int|0
)braket
op_ne
l_char|&squot; &squot;
op_logical_and
op_logical_neg
id|strncmp
c_func
(paren
id|dev-&gt;name
comma
id|s
(braket
id|i
)braket
dot
id|name
comma
id|strlen
c_func
(paren
id|s
(braket
id|i
)braket
dot
id|name
)paren
)paren
)paren
(brace
id|dev-&gt;irq
op_assign
id|s
(braket
id|i
)braket
dot
id|map.irq
suffix:semicolon
id|dev-&gt;base_addr
op_assign
id|s
(braket
id|i
)braket
dot
id|map.base_addr
suffix:semicolon
id|dev-&gt;mem_start
op_assign
id|s
(braket
id|i
)braket
dot
id|map.mem_start
suffix:semicolon
id|dev-&gt;mem_end
op_assign
id|s
(braket
id|i
)braket
dot
id|map.mem_end
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;netdev_boot_base&t;- get address from boot time settings&n; *&t;@prefix: prefix for network device&n; *&t;@unit: id for network device&n; *&n; * &t;Check boot time settings for the base address of device.&n; *&t;The found settings are set for the device to be used&n; *&t;later in the device probing.&n; *&t;Returns 0 if no settings found.&n; */
DECL|function|netdev_boot_base
r_int
r_int
id|netdev_boot_base
c_func
(paren
r_const
r_char
op_star
id|prefix
comma
r_int
id|unit
)paren
(brace
r_const
r_struct
id|netdev_boot_setup
op_star
id|s
op_assign
id|dev_boot_setup
suffix:semicolon
r_char
id|name
(braket
id|IFNAMSIZ
)braket
suffix:semicolon
r_int
id|i
suffix:semicolon
id|sprintf
c_func
(paren
id|name
comma
l_string|&quot;%s%d&quot;
comma
id|prefix
comma
id|unit
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If device already registered then return base of 1&n;&t; * to indicate not to probe for this interface&n;&t; */
r_if
c_cond
(paren
id|__dev_get_by_name
c_func
(paren
id|name
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NETDEV_BOOT_SETUP_MAX
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|name
comma
id|s
(braket
id|i
)braket
dot
id|name
)paren
)paren
r_return
id|s
(braket
id|i
)braket
dot
id|map.base_addr
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Saves at boot time configured settings for any netdevice.&n; */
DECL|function|netdev_boot_setup
r_int
id|__init
id|netdev_boot_setup
c_func
(paren
r_char
op_star
id|str
)paren
(brace
r_int
id|ints
(braket
l_int|5
)braket
suffix:semicolon
r_struct
id|ifmap
id|map
suffix:semicolon
id|str
op_assign
id|get_options
c_func
(paren
id|str
comma
id|ARRAY_SIZE
c_func
(paren
id|ints
)paren
comma
id|ints
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|str
op_logical_or
op_logical_neg
op_star
id|str
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Save settings */
id|memset
c_func
(paren
op_amp
id|map
comma
l_int|0
comma
r_sizeof
(paren
id|map
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ints
(braket
l_int|0
)braket
OG
l_int|0
)paren
id|map.irq
op_assign
id|ints
(braket
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
id|ints
(braket
l_int|0
)braket
OG
l_int|1
)paren
id|map.base_addr
op_assign
id|ints
(braket
l_int|2
)braket
suffix:semicolon
r_if
c_cond
(paren
id|ints
(braket
l_int|0
)braket
OG
l_int|2
)paren
id|map.mem_start
op_assign
id|ints
(braket
l_int|3
)braket
suffix:semicolon
r_if
c_cond
(paren
id|ints
(braket
l_int|0
)braket
OG
l_int|3
)paren
id|map.mem_end
op_assign
id|ints
(braket
l_int|4
)braket
suffix:semicolon
multiline_comment|/* Add new entry to the list */
r_return
id|netdev_boot_setup_add
c_func
(paren
id|str
comma
op_amp
id|map
)paren
suffix:semicolon
)brace
id|__setup
c_func
(paren
l_string|&quot;netdev=&quot;
comma
id|netdev_boot_setup
)paren
suffix:semicolon
multiline_comment|/*******************************************************************************&n;&n;&t;&t;&t;    Device Interface Subroutines&n;&n;*******************************************************************************/
multiline_comment|/**&n; *&t;__dev_get_by_name&t;- find a device by its name&n; *&t;@name: name to find&n; *&n; *&t;Find an interface by name. Must be called under RTNL semaphore&n; *&t;or @dev_base_lock. If the name is found a pointer to the device&n; *&t;is returned. If the name is not found then %NULL is returned. The&n; *&t;reference counters are not incremented so the caller must be&n; *&t;careful with locks.&n; */
DECL|function|__dev_get_by_name
r_struct
id|net_device
op_star
id|__dev_get_by_name
c_func
(paren
r_const
r_char
op_star
id|name
)paren
(brace
r_struct
id|hlist_node
op_star
id|p
suffix:semicolon
id|hlist_for_each
c_func
(paren
id|p
comma
id|dev_name_hash
c_func
(paren
id|name
)paren
)paren
(brace
r_struct
id|net_device
op_star
id|dev
op_assign
id|hlist_entry
c_func
(paren
id|p
comma
r_struct
id|net_device
comma
id|name_hlist
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|dev-&gt;name
comma
id|name
comma
id|IFNAMSIZ
)paren
)paren
r_return
id|dev
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;dev_get_by_name&t;&t;- find a device by its name&n; *&t;@name: name to find&n; *&n; *&t;Find an interface by name. This can be called from any&n; *&t;context and does its own locking. The returned handle has&n; *&t;the usage count incremented and the caller must use dev_put() to&n; *&t;release it when it is no longer needed. %NULL is returned if no&n; *&t;matching device is found.&n; */
DECL|function|dev_get_by_name
r_struct
id|net_device
op_star
id|dev_get_by_name
c_func
(paren
r_const
r_char
op_star
id|name
)paren
(brace
r_struct
id|net_device
op_star
id|dev
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|dev_base_lock
)paren
suffix:semicolon
id|dev
op_assign
id|__dev_get_by_name
c_func
(paren
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev
)paren
id|dev_hold
c_func
(paren
id|dev
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|dev_base_lock
)paren
suffix:semicolon
r_return
id|dev
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;__dev_get_by_index - find a device by its ifindex&n; *&t;@ifindex: index of device&n; *&n; *&t;Search for an interface by index. Returns %NULL if the device&n; *&t;is not found or a pointer to the device. The device has not&n; *&t;had its reference counter increased so the caller must be careful&n; *&t;about locking. The caller must hold either the RTNL semaphore&n; *&t;or @dev_base_lock.&n; */
DECL|function|__dev_get_by_index
r_struct
id|net_device
op_star
id|__dev_get_by_index
c_func
(paren
r_int
id|ifindex
)paren
(brace
r_struct
id|hlist_node
op_star
id|p
suffix:semicolon
id|hlist_for_each
c_func
(paren
id|p
comma
id|dev_index_hash
c_func
(paren
id|ifindex
)paren
)paren
(brace
r_struct
id|net_device
op_star
id|dev
op_assign
id|hlist_entry
c_func
(paren
id|p
comma
r_struct
id|net_device
comma
id|index_hlist
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;ifindex
op_eq
id|ifindex
)paren
r_return
id|dev
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;dev_get_by_index - find a device by its ifindex&n; *&t;@ifindex: index of device&n; *&n; *&t;Search for an interface by index. Returns NULL if the device&n; *&t;is not found or a pointer to the device. The device returned has&n; *&t;had a reference added and the pointer is safe until the user calls&n; *&t;dev_put to indicate they have finished with it.&n; */
DECL|function|dev_get_by_index
r_struct
id|net_device
op_star
id|dev_get_by_index
c_func
(paren
r_int
id|ifindex
)paren
(brace
r_struct
id|net_device
op_star
id|dev
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|dev_base_lock
)paren
suffix:semicolon
id|dev
op_assign
id|__dev_get_by_index
c_func
(paren
id|ifindex
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev
)paren
id|dev_hold
c_func
(paren
id|dev
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|dev_base_lock
)paren
suffix:semicolon
r_return
id|dev
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;dev_getbyhwaddr - find a device by its hardware address&n; *&t;@type: media type of device&n; *&t;@ha: hardware address&n; *&n; *&t;Search for an interface by MAC address. Returns NULL if the device&n; *&t;is not found or a pointer to the device. The caller must hold the&n; *&t;rtnl semaphore. The returned device has not had its ref count increased&n; *&t;and the caller must therefore be careful about locking&n; *&n; *&t;BUGS:&n; *&t;If the API was consistent this would be __dev_get_by_hwaddr&n; */
DECL|function|dev_getbyhwaddr
r_struct
id|net_device
op_star
id|dev_getbyhwaddr
c_func
(paren
r_int
r_int
id|type
comma
r_char
op_star
id|ha
)paren
(brace
r_struct
id|net_device
op_star
id|dev
suffix:semicolon
id|ASSERT_RTNL
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|dev
op_assign
id|dev_base
suffix:semicolon
id|dev
suffix:semicolon
id|dev
op_assign
id|dev-&gt;next
)paren
r_if
c_cond
(paren
id|dev-&gt;type
op_eq
id|type
op_logical_and
op_logical_neg
id|memcmp
c_func
(paren
id|dev-&gt;dev_addr
comma
id|ha
comma
id|dev-&gt;addr_len
)paren
)paren
r_break
suffix:semicolon
r_return
id|dev
suffix:semicolon
)brace
DECL|function|dev_getfirstbyhwtype
r_struct
id|net_device
op_star
id|dev_getfirstbyhwtype
c_func
(paren
r_int
r_int
id|type
)paren
(brace
r_struct
id|net_device
op_star
id|dev
suffix:semicolon
id|rtnl_lock
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|dev
op_assign
id|dev_base
suffix:semicolon
id|dev
suffix:semicolon
id|dev
op_assign
id|dev-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|dev-&gt;type
op_eq
id|type
)paren
(brace
id|dev_hold
c_func
(paren
id|dev
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|rtnl_unlock
c_func
(paren
)paren
suffix:semicolon
r_return
id|dev
suffix:semicolon
)brace
DECL|variable|dev_getfirstbyhwtype
id|EXPORT_SYMBOL
c_func
(paren
id|dev_getfirstbyhwtype
)paren
suffix:semicolon
multiline_comment|/**&n; *&t;dev_get_by_flags - find any device with given flags&n; *&t;@if_flags: IFF_* values&n; *&t;@mask: bitmask of bits in if_flags to check&n; *&n; *&t;Search for any interface with the given flags. Returns NULL if a device&n; *&t;is not found or a pointer to the device. The device returned has &n; *&t;had a reference added and the pointer is safe until the user calls&n; *&t;dev_put to indicate they have finished with it.&n; */
DECL|function|dev_get_by_flags
r_struct
id|net_device
op_star
id|dev_get_by_flags
c_func
(paren
r_int
r_int
id|if_flags
comma
r_int
r_int
id|mask
)paren
(brace
r_struct
id|net_device
op_star
id|dev
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|dev_base_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|dev
op_assign
id|dev_base
suffix:semicolon
id|dev
op_ne
l_int|NULL
suffix:semicolon
id|dev
op_assign
id|dev-&gt;next
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
id|dev-&gt;flags
op_xor
id|if_flags
)paren
op_amp
id|mask
)paren
op_eq
l_int|0
)paren
(brace
id|dev_hold
c_func
(paren
id|dev
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|read_unlock
c_func
(paren
op_amp
id|dev_base_lock
)paren
suffix:semicolon
r_return
id|dev
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;dev_valid_name - check if name is okay for network device&n; *&t;@name: name string&n; *&n; *&t;Network device names need to be valid file names to&n; *&t;to allow sysfs to work&n; */
DECL|function|dev_valid_name
r_static
r_int
id|dev_valid_name
c_func
(paren
r_const
r_char
op_star
id|name
)paren
(brace
r_return
op_logical_neg
(paren
op_star
id|name
op_eq
l_char|&squot;&bslash;0&squot;
op_logical_or
op_logical_neg
id|strcmp
c_func
(paren
id|name
comma
l_string|&quot;.&quot;
)paren
op_logical_or
op_logical_neg
id|strcmp
c_func
(paren
id|name
comma
l_string|&quot;..&quot;
)paren
op_logical_or
id|strchr
c_func
(paren
id|name
comma
l_char|&squot;/&squot;
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;dev_alloc_name - allocate a name for a device&n; *&t;@dev: device&n; *&t;@name: name format string&n; *&n; *&t;Passed a format string - eg &quot;lt%d&quot; it will try and find a suitable&n; *&t;id. Not efficient for many devices, not called a lot. The caller&n; *&t;must hold the dev_base or rtnl lock while allocating the name and&n; *&t;adding the device in order to avoid duplicates. Returns the number&n; *&t;of the unit assigned or a negative errno code.&n; */
DECL|function|dev_alloc_name
r_int
id|dev_alloc_name
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_const
r_char
op_star
id|name
)paren
(brace
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_char
id|buf
(braket
id|IFNAMSIZ
)braket
suffix:semicolon
r_const
r_char
op_star
id|p
suffix:semicolon
r_const
r_int
id|max_netdevices
op_assign
l_int|8
op_star
id|PAGE_SIZE
suffix:semicolon
r_int
op_star
id|inuse
suffix:semicolon
r_struct
id|net_device
op_star
id|d
suffix:semicolon
id|p
op_assign
id|strnchr
c_func
(paren
id|name
comma
id|IFNAMSIZ
op_minus
l_int|1
comma
l_char|&squot;%&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
)paren
(brace
multiline_comment|/*&n;&t;&t; * Verify the string as this thing may have come from&n;&t;&t; * the user.  There must be either one &quot;%d&quot; and no other &quot;%&quot;&n;&t;&t; * characters.&n;&t;&t; */
r_if
c_cond
(paren
id|p
(braket
l_int|1
)braket
op_ne
l_char|&squot;d&squot;
op_logical_or
id|strchr
c_func
(paren
id|p
op_plus
l_int|2
comma
l_char|&squot;%&squot;
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* Use one page as a bit array of possible slots */
id|inuse
op_assign
(paren
r_int
op_star
)paren
id|get_zeroed_page
c_func
(paren
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inuse
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_for
c_loop
(paren
id|d
op_assign
id|dev_base
suffix:semicolon
id|d
suffix:semicolon
id|d
op_assign
id|d-&gt;next
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|sscanf
c_func
(paren
id|d-&gt;name
comma
id|name
comma
op_amp
id|i
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|i
OL
l_int|0
op_logical_or
id|i
op_ge
id|max_netdevices
)paren
r_continue
suffix:semicolon
multiline_comment|/*  avoid cases where sscanf is not exact inverse of printf */
id|snprintf
c_func
(paren
id|buf
comma
r_sizeof
(paren
id|buf
)paren
comma
id|name
comma
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|buf
comma
id|d-&gt;name
comma
id|IFNAMSIZ
)paren
)paren
id|set_bit
c_func
(paren
id|i
comma
id|inuse
)paren
suffix:semicolon
)brace
id|i
op_assign
id|find_first_zero_bit
c_func
(paren
id|inuse
comma
id|max_netdevices
)paren
suffix:semicolon
id|free_page
c_func
(paren
(paren
r_int
r_int
)paren
id|inuse
)paren
suffix:semicolon
)brace
id|snprintf
c_func
(paren
id|buf
comma
r_sizeof
(paren
id|buf
)paren
comma
id|name
comma
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|__dev_get_by_name
c_func
(paren
id|buf
)paren
)paren
(brace
id|strlcpy
c_func
(paren
id|dev-&gt;name
comma
id|buf
comma
id|IFNAMSIZ
)paren
suffix:semicolon
r_return
id|i
suffix:semicolon
)brace
multiline_comment|/* It is possible to run out of possible slots&n;&t; * when the name is long and there isn&squot;t enough space left&n;&t; * for the digits, or if all bits are used.&n;&t; */
r_return
op_minus
id|ENFILE
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;dev_change_name - change name of a device&n; *&t;@dev: device&n; *&t;@newname: name (or format string) must be at least IFNAMSIZ&n; *&n; *&t;Change name of a device, can pass format strings &quot;eth%d&quot;.&n; *&t;for wildcarding.&n; */
DECL|function|dev_change_name
r_int
id|dev_change_name
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_char
op_star
id|newname
)paren
(brace
r_int
id|err
op_assign
l_int|0
suffix:semicolon
id|ASSERT_RTNL
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;flags
op_amp
id|IFF_UP
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev_valid_name
c_func
(paren
id|newname
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|strchr
c_func
(paren
id|newname
comma
l_char|&squot;%&squot;
)paren
)paren
(brace
id|err
op_assign
id|dev_alloc_name
c_func
(paren
id|dev
comma
id|newname
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_return
id|err
suffix:semicolon
id|strcpy
c_func
(paren
id|newname
comma
id|dev-&gt;name
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|__dev_get_by_name
c_func
(paren
id|newname
)paren
)paren
r_return
op_minus
id|EEXIST
suffix:semicolon
r_else
id|strlcpy
c_func
(paren
id|dev-&gt;name
comma
id|newname
comma
id|IFNAMSIZ
)paren
suffix:semicolon
id|err
op_assign
id|class_device_rename
c_func
(paren
op_amp
id|dev-&gt;class_dev
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|err
)paren
(brace
id|hlist_del
c_func
(paren
op_amp
id|dev-&gt;name_hlist
)paren
suffix:semicolon
id|hlist_add_head
c_func
(paren
op_amp
id|dev-&gt;name_hlist
comma
id|dev_name_hash
c_func
(paren
id|dev-&gt;name
)paren
)paren
suffix:semicolon
id|notifier_call_chain
c_func
(paren
op_amp
id|netdev_chain
comma
id|NETDEV_CHANGENAME
comma
id|dev
)paren
suffix:semicolon
)brace
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;netdev_state_change - device changes state&n; *&t;@dev: device to cause notification&n; *&n; *&t;Called to indicate a device has changed state. This function calls&n; *&t;the notifier chains for netdev_chain and sends a NEWLINK message&n; *&t;to the routing socket.&n; */
DECL|function|netdev_state_change
r_void
id|netdev_state_change
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_if
c_cond
(paren
id|dev-&gt;flags
op_amp
id|IFF_UP
)paren
(brace
id|notifier_call_chain
c_func
(paren
op_amp
id|netdev_chain
comma
id|NETDEV_CHANGE
comma
id|dev
)paren
suffix:semicolon
id|rtmsg_ifinfo
c_func
(paren
id|RTM_NEWLINK
comma
id|dev
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; *&t;dev_load &t;- load a network module&n; *&t;@name: name of interface&n; *&n; *&t;If a network interface is not present and the process has suitable&n; *&t;privileges this function loads the module. If module loading is not&n; *&t;available in this kernel then it becomes a nop.&n; */
DECL|function|dev_load
r_void
id|dev_load
c_func
(paren
r_const
r_char
op_star
id|name
)paren
(brace
r_struct
id|net_device
op_star
id|dev
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|dev_base_lock
)paren
suffix:semicolon
id|dev
op_assign
id|__dev_get_by_name
c_func
(paren
id|name
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|dev_base_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
op_logical_and
id|capable
c_func
(paren
id|CAP_SYS_MODULE
)paren
)paren
id|request_module
c_func
(paren
l_string|&quot;%s&quot;
comma
id|name
)paren
suffix:semicolon
)brace
DECL|function|default_rebuild_header
r_static
r_int
id|default_rebuild_header
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: default_rebuild_header called -- BUG!&bslash;n&quot;
comma
id|skb-&gt;dev
ques
c_cond
id|skb-&gt;dev-&gt;name
suffix:colon
l_string|&quot;NULL!!!&quot;
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;dev_open&t;- prepare an interface for use.&n; *&t;@dev:&t;device to open&n; *&n; *&t;Takes a device from down to up state. The device&squot;s private open&n; *&t;function is invoked and then the multicast lists are loaded. Finally&n; *&t;the device is moved into the up state and a %NETDEV_UP message is&n; *&t;sent to the netdev notifier chain.&n; *&n; *&t;Calling this function on an active interface is a nop. On a failure&n; *&t;a negative errno code is returned.&n; */
DECL|function|dev_open
r_int
id|dev_open
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Is it already up?&n;&t; */
r_if
c_cond
(paren
id|dev-&gt;flags
op_amp
id|IFF_UP
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Is it even present?&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|netif_device_present
c_func
(paren
id|dev
)paren
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Call device private open method&n;&t; */
id|set_bit
c_func
(paren
id|__LINK_STATE_START
comma
op_amp
id|dev-&gt;state
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;open
)paren
(brace
id|ret
op_assign
id|dev
op_member_access_from_pointer
id|open
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
id|clear_bit
c_func
(paren
id|__LINK_STATE_START
comma
op_amp
id|dev-&gt;state
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;If it went open OK then:&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
(brace
multiline_comment|/*&n;&t;&t; *&t;Set the flags.&n;&t;&t; */
id|dev-&gt;flags
op_or_assign
id|IFF_UP
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Initialize multicasting status&n;&t;&t; */
id|dev_mc_upload
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Wakeup transmit queue engine&n;&t;&t; */
id|dev_activate
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;... and announce new interface.&n;&t;&t; */
id|notifier_call_chain
c_func
(paren
op_amp
id|netdev_chain
comma
id|NETDEV_UP
comma
id|dev
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;dev_close - shutdown an interface.&n; *&t;@dev: device to shutdown&n; *&n; *&t;This function moves an active device into down state. A&n; *&t;%NETDEV_GOING_DOWN is sent to the netdev notifier chain. The device&n; *&t;is then deactivated and finally a %NETDEV_DOWN is sent to the notifier&n; *&t;chain.&n; */
DECL|function|dev_close
r_int
id|dev_close
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|dev-&gt;flags
op_amp
id|IFF_UP
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Tell people we are going down, so that they can&n;&t; *&t;prepare to death, when device is still operating.&n;&t; */
id|notifier_call_chain
c_func
(paren
op_amp
id|netdev_chain
comma
id|NETDEV_GOING_DOWN
comma
id|dev
)paren
suffix:semicolon
id|dev_deactivate
c_func
(paren
id|dev
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|__LINK_STATE_START
comma
op_amp
id|dev-&gt;state
)paren
suffix:semicolon
multiline_comment|/* Synchronize to scheduled poll. We cannot touch poll list,&n;&t; * it can be even on different cpu. So just clear netif_running(),&n;&t; * and wait when poll really will happen. Actually, the best place&n;&t; * for this is inside dev-&gt;stop() after device stopped its irq&n;&t; * engine, but this requires more changes in devices. */
id|smp_mb__after_clear_bit
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Commit netif_running(). */
r_while
c_loop
(paren
id|test_bit
c_func
(paren
id|__LINK_STATE_RX_SCHED
comma
op_amp
id|dev-&gt;state
)paren
)paren
(brace
multiline_comment|/* No hurry. */
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|schedule_timeout
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Call the device specific close. This cannot fail.&n;&t; *&t;Only if device is UP&n;&t; *&n;&t; *&t;We allow it to be called even after a DETACH hot-plug&n;&t; *&t;event.&n;&t; */
r_if
c_cond
(paren
id|dev-&gt;stop
)paren
id|dev
op_member_access_from_pointer
id|stop
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Device is now down.&n;&t; */
id|dev-&gt;flags
op_and_assign
op_complement
id|IFF_UP
suffix:semicolon
multiline_comment|/*&n;&t; * Tell people we are down&n;&t; */
id|notifier_call_chain
c_func
(paren
op_amp
id|netdev_chain
comma
id|NETDEV_DOWN
comma
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Device change register/unregister. These are not inline or static&n; *&t;as we export them to the world.&n; */
multiline_comment|/**&n; *&t;register_netdevice_notifier - register a network notifier block&n; *&t;@nb: notifier&n; *&n; *&t;Register a notifier to be called when network device events occur.&n; *&t;The notifier passed is linked into the kernel structures and must&n; *&t;not be reused until it has been unregistered. A negative errno code&n; *&t;is returned on a failure.&n; *&n; * &t;When registered all registration and up events are replayed&n; *&t;to the new notifier to allow device to have a race free &n; *&t;view of the network device list.&n; */
DECL|function|register_netdevice_notifier
r_int
id|register_netdevice_notifier
c_func
(paren
r_struct
id|notifier_block
op_star
id|nb
)paren
(brace
r_struct
id|net_device
op_star
id|dev
suffix:semicolon
r_int
id|err
suffix:semicolon
id|rtnl_lock
c_func
(paren
)paren
suffix:semicolon
id|err
op_assign
id|notifier_chain_register
c_func
(paren
op_amp
id|netdev_chain
comma
id|nb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|err
)paren
(brace
r_for
c_loop
(paren
id|dev
op_assign
id|dev_base
suffix:semicolon
id|dev
suffix:semicolon
id|dev
op_assign
id|dev-&gt;next
)paren
(brace
id|nb
op_member_access_from_pointer
id|notifier_call
c_func
(paren
id|nb
comma
id|NETDEV_REGISTER
comma
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;flags
op_amp
id|IFF_UP
)paren
id|nb
op_member_access_from_pointer
id|notifier_call
c_func
(paren
id|nb
comma
id|NETDEV_UP
comma
id|dev
)paren
suffix:semicolon
)brace
)brace
id|rtnl_unlock
c_func
(paren
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;unregister_netdevice_notifier - unregister a network notifier block&n; *&t;@nb: notifier&n; *&n; *&t;Unregister a notifier previously registered by&n; *&t;register_netdevice_notifier(). The notifier is unlinked into the&n; *&t;kernel structures and may then be reused. A negative errno code&n; *&t;is returned on a failure.&n; */
DECL|function|unregister_netdevice_notifier
r_int
id|unregister_netdevice_notifier
c_func
(paren
r_struct
id|notifier_block
op_star
id|nb
)paren
(brace
r_return
id|notifier_chain_unregister
c_func
(paren
op_amp
id|netdev_chain
comma
id|nb
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;call_netdevice_notifiers - call all network notifier blocks&n; *      @val: value passed unmodified to notifier function&n; *      @v:   pointer passed unmodified to notifier function&n; *&n; *&t;Call all network notifier blocks.  Parameters and return value&n; *&t;are as for notifier_call_chain().&n; */
DECL|function|call_netdevice_notifiers
r_int
id|call_netdevice_notifiers
c_func
(paren
r_int
r_int
id|val
comma
r_void
op_star
id|v
)paren
(brace
r_return
id|notifier_call_chain
c_func
(paren
op_amp
id|netdev_chain
comma
id|val
comma
id|v
)paren
suffix:semicolon
)brace
multiline_comment|/* When &gt; 0 there are consumers of rx skb time stamps */
DECL|variable|netstamp_needed
r_static
id|atomic_t
id|netstamp_needed
op_assign
id|ATOMIC_INIT
c_func
(paren
l_int|0
)paren
suffix:semicolon
DECL|function|net_enable_timestamp
r_void
id|net_enable_timestamp
c_func
(paren
r_void
)paren
(brace
id|atomic_inc
c_func
(paren
op_amp
id|netstamp_needed
)paren
suffix:semicolon
)brace
DECL|function|net_disable_timestamp
r_void
id|net_disable_timestamp
c_func
(paren
r_void
)paren
(brace
id|atomic_dec
c_func
(paren
op_amp
id|netstamp_needed
)paren
suffix:semicolon
)brace
DECL|function|net_timestamp
r_static
r_inline
r_void
id|net_timestamp
c_func
(paren
r_struct
id|timeval
op_star
id|stamp
)paren
(brace
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|netstamp_needed
)paren
)paren
id|do_gettimeofday
c_func
(paren
id|stamp
)paren
suffix:semicolon
r_else
(brace
id|stamp-&gt;tv_sec
op_assign
l_int|0
suffix:semicolon
id|stamp-&gt;tv_usec
op_assign
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *&t;Support routine. Sends outgoing frames to any network&n; *&t;taps currently in use.&n; */
DECL|function|dev_queue_xmit_nit
r_void
id|dev_queue_xmit_nit
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|packet_type
op_star
id|ptype
suffix:semicolon
id|net_timestamp
c_func
(paren
op_amp
id|skb-&gt;stamp
)paren
suffix:semicolon
id|rcu_read_lock
c_func
(paren
)paren
suffix:semicolon
id|list_for_each_entry_rcu
c_func
(paren
id|ptype
comma
op_amp
id|ptype_all
comma
id|list
)paren
(brace
multiline_comment|/* Never send packets back to the socket&n;&t;&t; * they originated from - MvS (miquels@drinkel.ow.org)&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|ptype-&gt;dev
op_eq
id|dev
op_logical_or
op_logical_neg
id|ptype-&gt;dev
)paren
op_logical_and
(paren
id|ptype-&gt;af_packet_priv
op_eq
l_int|NULL
op_logical_or
(paren
r_struct
id|sock
op_star
)paren
id|ptype-&gt;af_packet_priv
op_ne
id|skb-&gt;sk
)paren
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb2
op_assign
id|skb_clone
c_func
(paren
id|skb
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skb2
)paren
r_break
suffix:semicolon
multiline_comment|/* skb-&gt;nh should be correctly&n;&t;&t;&t;   set by sender, so that the second statement is&n;&t;&t;&t;   just protection against buggy protocols.&n;&t;&t;&t; */
id|skb2-&gt;mac.raw
op_assign
id|skb2-&gt;data
suffix:semicolon
r_if
c_cond
(paren
id|skb2-&gt;nh.raw
template_param
id|skb2-&gt;tail
)paren
(brace
r_if
c_cond
(paren
id|net_ratelimit
c_func
(paren
)paren
)paren
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;protocol %04x is &quot;
l_string|&quot;buggy, dev %s&bslash;n&quot;
comma
id|skb2-&gt;protocol
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|skb2-&gt;nh.raw
op_assign
id|skb2-&gt;data
suffix:semicolon
)brace
id|skb2-&gt;h.raw
op_assign
id|skb2-&gt;nh.raw
suffix:semicolon
id|skb2-&gt;pkt_type
op_assign
id|PACKET_OUTGOING
suffix:semicolon
id|ptype
op_member_access_from_pointer
id|func
c_func
(paren
id|skb2
comma
id|skb-&gt;dev
comma
id|ptype
)paren
suffix:semicolon
)brace
)brace
id|rcu_read_unlock
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Invalidate hardware checksum when packet is to be mangled, and&n; * complete checksum manually on outgoing path.&n; */
DECL|function|skb_checksum_help
r_int
id|skb_checksum_help
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|inward
)paren
(brace
r_int
r_int
id|csum
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
comma
id|offset
op_assign
id|skb-&gt;h.raw
op_minus
id|skb-&gt;data
suffix:semicolon
r_if
c_cond
(paren
id|inward
)paren
(brace
id|skb-&gt;ip_summed
op_assign
id|CHECKSUM_NONE
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|skb_cloned
c_func
(paren
id|skb
)paren
)paren
(brace
id|ret
op_assign
id|pskb_expand_head
c_func
(paren
id|skb
comma
l_int|0
comma
l_int|0
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|offset
OG
(paren
r_int
)paren
id|skb-&gt;len
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|csum
op_assign
id|skb_checksum
c_func
(paren
id|skb
comma
id|offset
comma
id|skb-&gt;len
op_minus
id|offset
comma
l_int|0
)paren
suffix:semicolon
id|offset
op_assign
id|skb-&gt;tail
op_minus
id|skb-&gt;h.raw
suffix:semicolon
r_if
c_cond
(paren
id|offset
op_le
l_int|0
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb-&gt;csum
op_plus
l_int|2
OG
id|offset
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
op_star
(paren
id|u16
op_star
)paren
(paren
id|skb-&gt;h.raw
op_plus
id|skb-&gt;csum
)paren
op_assign
id|csum_fold
c_func
(paren
id|csum
)paren
suffix:semicolon
id|skb-&gt;ip_summed
op_assign
id|CHECKSUM_NONE
suffix:semicolon
id|out
suffix:colon
r_return
id|ret
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_HIGHMEM
multiline_comment|/* Actually, we should eliminate this check as soon as we know, that:&n; * 1. IOMMU is present and allows to map all the memory.&n; * 2. No high memory really exists on this machine.&n; */
DECL|function|illegal_highdma
r_static
r_inline
r_int
id|illegal_highdma
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;features
op_amp
id|NETIF_F_HIGHDMA
)paren
r_return
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|nr_frags
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|PageHighMem
c_func
(paren
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|frags
(braket
id|i
)braket
dot
id|page
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#else
DECL|macro|illegal_highdma
mdefine_line|#define illegal_highdma(dev, skb)&t;(0)
macro_line|#endif
r_extern
r_void
id|skb_release_data
c_func
(paren
r_struct
id|sk_buff
op_star
)paren
suffix:semicolon
multiline_comment|/* Keep head the same: replace data */
DECL|function|__skb_linearize
r_int
id|__skb_linearize
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|gfp_mask
)paren
(brace
r_int
r_int
id|size
suffix:semicolon
id|u8
op_star
id|data
suffix:semicolon
r_int
id|offset
suffix:semicolon
r_struct
id|skb_shared_info
op_star
id|ninfo
suffix:semicolon
r_int
id|headerlen
op_assign
id|skb-&gt;data
op_minus
id|skb-&gt;head
suffix:semicolon
r_int
id|expand
op_assign
(paren
id|skb-&gt;tail
op_plus
id|skb-&gt;data_len
)paren
op_minus
id|skb-&gt;end
suffix:semicolon
r_if
c_cond
(paren
id|skb_shared
c_func
(paren
id|skb
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|expand
op_le
l_int|0
)paren
id|expand
op_assign
l_int|0
suffix:semicolon
id|size
op_assign
id|skb-&gt;end
op_minus
id|skb-&gt;head
op_plus
id|expand
suffix:semicolon
id|size
op_assign
id|SKB_DATA_ALIGN
c_func
(paren
id|size
)paren
suffix:semicolon
id|data
op_assign
id|kmalloc
c_func
(paren
id|size
op_plus
r_sizeof
(paren
r_struct
id|skb_shared_info
)paren
comma
id|gfp_mask
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|data
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
multiline_comment|/* Copy entire thing */
r_if
c_cond
(paren
id|skb_copy_bits
c_func
(paren
id|skb
comma
op_minus
id|headerlen
comma
id|data
comma
id|headerlen
op_plus
id|skb-&gt;len
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Set up shinfo */
id|ninfo
op_assign
(paren
r_struct
id|skb_shared_info
op_star
)paren
(paren
id|data
op_plus
id|size
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|ninfo-&gt;dataref
comma
l_int|1
)paren
suffix:semicolon
id|ninfo-&gt;tso_size
op_assign
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|tso_size
suffix:semicolon
id|ninfo-&gt;tso_segs
op_assign
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|tso_segs
suffix:semicolon
id|ninfo-&gt;nr_frags
op_assign
l_int|0
suffix:semicolon
id|ninfo-&gt;frag_list
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Offset between the two in bytes */
id|offset
op_assign
id|data
op_minus
id|skb-&gt;head
suffix:semicolon
multiline_comment|/* Free old data. */
id|skb_release_data
c_func
(paren
id|skb
)paren
suffix:semicolon
id|skb-&gt;head
op_assign
id|data
suffix:semicolon
id|skb-&gt;end
op_assign
id|data
op_plus
id|size
suffix:semicolon
multiline_comment|/* Set up new pointers */
id|skb-&gt;h.raw
op_add_assign
id|offset
suffix:semicolon
id|skb-&gt;nh.raw
op_add_assign
id|offset
suffix:semicolon
id|skb-&gt;mac.raw
op_add_assign
id|offset
suffix:semicolon
id|skb-&gt;tail
op_add_assign
id|offset
suffix:semicolon
id|skb-&gt;data
op_add_assign
id|offset
suffix:semicolon
multiline_comment|/* We are no longer a clone, even if we were. */
id|skb-&gt;cloned
op_assign
l_int|0
suffix:semicolon
id|skb-&gt;tail
op_add_assign
id|skb-&gt;data_len
suffix:semicolon
id|skb-&gt;data_len
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|macro|HARD_TX_LOCK
mdefine_line|#define HARD_TX_LOCK(dev, cpu) {&t;&t;&t;&bslash;&n;&t;if ((dev-&gt;features &amp; NETIF_F_LLTX) == 0) {&t;&bslash;&n;&t;&t;spin_lock(&amp;dev-&gt;xmit_lock);&t;&t;&bslash;&n;&t;&t;dev-&gt;xmit_lock_owner = cpu;&t;&t;&bslash;&n;&t;}&t;&t;&t;&t;&t;&t;&bslash;&n;}
DECL|macro|HARD_TX_UNLOCK
mdefine_line|#define HARD_TX_UNLOCK(dev) {&t;&t;&t;&t;&bslash;&n;&t;if ((dev-&gt;features &amp; NETIF_F_LLTX) == 0) {&t;&bslash;&n;&t;&t;dev-&gt;xmit_lock_owner = -1;&t;&t;&bslash;&n;&t;&t;spin_unlock(&amp;dev-&gt;xmit_lock);&t;&t;&bslash;&n;&t;}&t;&t;&t;&t;&t;&t;&bslash;&n;}
multiline_comment|/**&n; *&t;dev_queue_xmit - transmit a buffer&n; *&t;@skb: buffer to transmit&n; *&n; *&t;Queue a buffer for transmission to a network device. The caller must&n; *&t;have set the device and priority and built the buffer before calling&n; *&t;this function. The function can be called from an interrupt.&n; *&n; *&t;A negative errno code is returned on a failure. A success does not&n; *&t;guarantee the frame will be transmitted as it may be dropped due&n; *&t;to congestion or traffic shaping.&n; */
DECL|function|dev_queue_xmit
r_int
id|dev_queue_xmit
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|net_device
op_star
id|dev
op_assign
id|skb-&gt;dev
suffix:semicolon
r_struct
id|Qdisc
op_star
id|q
suffix:semicolon
r_int
id|rc
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|frag_list
op_logical_and
op_logical_neg
(paren
id|dev-&gt;features
op_amp
id|NETIF_F_FRAGLIST
)paren
op_logical_and
id|__skb_linearize
c_func
(paren
id|skb
comma
id|GFP_ATOMIC
)paren
)paren
r_goto
id|out_kfree_skb
suffix:semicolon
multiline_comment|/* Fragmented skb is linearized if device does not support SG,&n;&t; * or if at least one of fragments is in highmem and device&n;&t; * does not support DMA from it.&n;&t; */
r_if
c_cond
(paren
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|nr_frags
op_logical_and
(paren
op_logical_neg
(paren
id|dev-&gt;features
op_amp
id|NETIF_F_SG
)paren
op_logical_or
id|illegal_highdma
c_func
(paren
id|dev
comma
id|skb
)paren
)paren
op_logical_and
id|__skb_linearize
c_func
(paren
id|skb
comma
id|GFP_ATOMIC
)paren
)paren
r_goto
id|out_kfree_skb
suffix:semicolon
multiline_comment|/* If packet is not checksummed and device does not support&n;&t; * checksumming for this protocol, complete checksumming here.&n;&t; */
r_if
c_cond
(paren
id|skb-&gt;ip_summed
op_eq
id|CHECKSUM_HW
op_logical_and
(paren
op_logical_neg
(paren
id|dev-&gt;features
op_amp
(paren
id|NETIF_F_HW_CSUM
op_or
id|NETIF_F_NO_CSUM
)paren
)paren
op_logical_and
(paren
op_logical_neg
(paren
id|dev-&gt;features
op_amp
id|NETIF_F_IP_CSUM
)paren
op_logical_or
id|skb-&gt;protocol
op_ne
id|htons
c_func
(paren
id|ETH_P_IP
)paren
)paren
)paren
)paren
r_if
c_cond
(paren
id|skb_checksum_help
c_func
(paren
id|skb
comma
l_int|0
)paren
)paren
r_goto
id|out_kfree_skb
suffix:semicolon
multiline_comment|/* Disable soft irqs for various locks below. Also &n;&t; * stops preemption for RCU. &n;&t; */
id|local_bh_disable
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Updates of qdisc are serialized by queue_lock. &n;&t; * The struct Qdisc which is pointed to by qdisc is now a &n;&t; * rcu structure - it may be accessed without acquiring &n;&t; * a lock (but the structure may be stale.) The freeing of the&n;&t; * qdisc will be deferred until it&squot;s known that there are no &n;&t; * more references to it.&n;&t; * &n;&t; * If the qdisc has an enqueue function, we still need to &n;&t; * hold the queue_lock before calling it, since queue_lock&n;&t; * also serializes access to the device queue.&n;&t; */
id|q
op_assign
id|rcu_dereference
c_func
(paren
id|dev-&gt;qdisc
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_NET_CLS_ACT
id|skb-&gt;tc_verd
op_assign
id|SET_TC_AT
c_func
(paren
id|skb-&gt;tc_verd
comma
id|AT_EGRESS
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|q-&gt;enqueue
)paren
(brace
multiline_comment|/* Grab device queue */
id|spin_lock
c_func
(paren
op_amp
id|dev-&gt;queue_lock
)paren
suffix:semicolon
id|rc
op_assign
id|q
op_member_access_from_pointer
id|enqueue
c_func
(paren
id|skb
comma
id|q
)paren
suffix:semicolon
id|qdisc_run
c_func
(paren
id|dev
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|dev-&gt;queue_lock
)paren
suffix:semicolon
id|rc
op_assign
id|rc
op_eq
id|NET_XMIT_BYPASS
ques
c_cond
id|NET_XMIT_SUCCESS
suffix:colon
id|rc
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* The device has no queue. Common case for software devices:&n;&t;   loopback, all the sorts of tunnels...&n;&n;&t;   Really, it is unlikely that xmit_lock protection is necessary here.&n;&t;   (f.e. loopback and IP tunnels are clean ignoring statistics&n;&t;   counters.)&n;&t;   However, it is possible, that they rely on protection&n;&t;   made by us here.&n;&n;&t;   Check this and shot the lock. It is not prone from deadlocks.&n;&t;   Either shot noqueue qdisc, it is even simpler 8)&n;&t; */
r_if
c_cond
(paren
id|dev-&gt;flags
op_amp
id|IFF_UP
)paren
(brace
r_int
id|cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* ok because BHs are off */
r_if
c_cond
(paren
id|dev-&gt;xmit_lock_owner
op_ne
id|cpu
)paren
(brace
id|HARD_TX_LOCK
c_func
(paren
id|dev
comma
id|cpu
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|netif_queue_stopped
c_func
(paren
id|dev
)paren
)paren
(brace
r_if
c_cond
(paren
id|netdev_nit
)paren
id|dev_queue_xmit_nit
c_func
(paren
id|skb
comma
id|dev
)paren
suffix:semicolon
id|rc
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
op_member_access_from_pointer
id|hard_start_xmit
c_func
(paren
id|skb
comma
id|dev
)paren
)paren
(brace
id|HARD_TX_UNLOCK
c_func
(paren
id|dev
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
)brace
id|HARD_TX_UNLOCK
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|net_ratelimit
c_func
(paren
)paren
)paren
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;Virtual device %s asks to &quot;
l_string|&quot;queue packet!&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Recursion is detected! It is possible,&n;&t;&t;&t; * unfortunately */
r_if
c_cond
(paren
id|net_ratelimit
c_func
(paren
)paren
)paren
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;Dead loop on virtual device &quot;
l_string|&quot;%s, fix it urgently!&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
)brace
)brace
id|rc
op_assign
op_minus
id|ENETDOWN
suffix:semicolon
id|local_bh_enable
c_func
(paren
)paren
suffix:semicolon
id|out_kfree_skb
suffix:colon
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
id|out
suffix:colon
id|local_bh_enable
c_func
(paren
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/*=======================================================================&n;&t;&t;&t;Receiver routines&n;  =======================================================================*/
DECL|variable|netdev_max_backlog
r_int
id|netdev_max_backlog
op_assign
l_int|300
suffix:semicolon
DECL|variable|weight_p
r_int
id|weight_p
op_assign
l_int|64
suffix:semicolon
multiline_comment|/* old backlog weight */
multiline_comment|/* These numbers are selected based on intuition and some&n; * experimentatiom, if you have more scientific way of doing this&n; * please go ahead and fix things.&n; */
DECL|variable|no_cong_thresh
r_int
id|no_cong_thresh
op_assign
l_int|10
suffix:semicolon
DECL|variable|no_cong
r_int
id|no_cong
op_assign
l_int|20
suffix:semicolon
DECL|variable|lo_cong
r_int
id|lo_cong
op_assign
l_int|100
suffix:semicolon
DECL|variable|mod_cong
r_int
id|mod_cong
op_assign
l_int|290
suffix:semicolon
id|DEFINE_PER_CPU
c_func
(paren
r_struct
id|netif_rx_stats
comma
id|netdev_rx_stat
)paren
op_assign
(brace
l_int|0
comma
)brace
suffix:semicolon
DECL|function|get_sample_stats
r_static
r_void
id|get_sample_stats
c_func
(paren
r_int
id|cpu
)paren
(brace
macro_line|#ifdef RAND_LIE
r_int
r_int
id|rd
suffix:semicolon
r_int
id|rq
suffix:semicolon
macro_line|#endif
r_struct
id|softnet_data
op_star
id|sd
op_assign
op_amp
id|per_cpu
c_func
(paren
id|softnet_data
comma
id|cpu
)paren
suffix:semicolon
r_int
id|blog
op_assign
id|sd-&gt;input_pkt_queue.qlen
suffix:semicolon
r_int
id|avg_blog
op_assign
id|sd-&gt;avg_blog
suffix:semicolon
id|avg_blog
op_assign
(paren
id|avg_blog
op_rshift
l_int|1
)paren
op_plus
(paren
id|blog
op_rshift
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|avg_blog
OG
id|mod_cong
)paren
(brace
multiline_comment|/* Above moderate congestion levels. */
id|sd-&gt;cng_level
op_assign
id|NET_RX_CN_HIGH
suffix:semicolon
macro_line|#ifdef RAND_LIE
id|rd
op_assign
id|net_random
c_func
(paren
)paren
suffix:semicolon
id|rq
op_assign
id|rd
op_mod
id|netdev_max_backlog
suffix:semicolon
r_if
c_cond
(paren
id|rq
OL
id|avg_blog
)paren
multiline_comment|/* unlucky bastard */
id|sd-&gt;cng_level
op_assign
id|NET_RX_DROP
suffix:semicolon
macro_line|#endif
)brace
r_else
r_if
c_cond
(paren
id|avg_blog
OG
id|lo_cong
)paren
(brace
id|sd-&gt;cng_level
op_assign
id|NET_RX_CN_MOD
suffix:semicolon
macro_line|#ifdef RAND_LIE
id|rd
op_assign
id|net_random
c_func
(paren
)paren
suffix:semicolon
id|rq
op_assign
id|rd
op_mod
id|netdev_max_backlog
suffix:semicolon
r_if
c_cond
(paren
id|rq
OL
id|avg_blog
)paren
multiline_comment|/* unlucky bastard */
id|sd-&gt;cng_level
op_assign
id|NET_RX_CN_HIGH
suffix:semicolon
macro_line|#endif
)brace
r_else
r_if
c_cond
(paren
id|avg_blog
OG
id|no_cong
)paren
id|sd-&gt;cng_level
op_assign
id|NET_RX_CN_LOW
suffix:semicolon
r_else
multiline_comment|/* no congestion */
id|sd-&gt;cng_level
op_assign
id|NET_RX_SUCCESS
suffix:semicolon
id|sd-&gt;avg_blog
op_assign
id|avg_blog
suffix:semicolon
)brace
macro_line|#ifdef OFFLINE_SAMPLE
DECL|function|sample_queue
r_static
r_void
id|sample_queue
c_func
(paren
r_int
r_int
id|dummy
)paren
(brace
multiline_comment|/* 10 ms 0r 1ms -- i don&squot;t care -- JHS */
r_int
id|next_tick
op_assign
l_int|1
suffix:semicolon
r_int
id|cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
id|get_sample_stats
c_func
(paren
id|cpu
)paren
suffix:semicolon
id|next_tick
op_add_assign
id|jiffies
suffix:semicolon
id|mod_timer
c_func
(paren
op_amp
id|samp_timer
comma
id|next_tick
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/**&n; *&t;netif_rx&t;-&t;post buffer to the network code&n; *&t;@skb: buffer to post&n; *&n; *&t;This function receives a packet from a device driver and queues it for&n; *&t;the upper (protocol) levels to process.  It always succeeds. The buffer&n; *&t;may be dropped during processing for congestion control or by the&n; *&t;protocol layers.&n; *&n; *&t;return values:&n; *&t;NET_RX_SUCCESS&t;(no congestion)&n; *&t;NET_RX_CN_LOW   (low congestion)&n; *&t;NET_RX_CN_MOD   (moderate congestion)&n; *&t;NET_RX_CN_HIGH  (high congestion)&n; *&t;NET_RX_DROP     (packet was dropped)&n; *&n; */
DECL|function|netif_rx
r_int
id|netif_rx
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_int
id|this_cpu
suffix:semicolon
r_struct
id|softnet_data
op_star
id|queue
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
macro_line|#ifdef CONFIG_NETPOLL
r_if
c_cond
(paren
id|skb-&gt;dev-&gt;netpoll_rx
op_logical_and
id|netpoll_rx
c_func
(paren
id|skb
)paren
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
id|NET_RX_DROP
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|skb-&gt;stamp.tv_sec
)paren
id|net_timestamp
c_func
(paren
op_amp
id|skb-&gt;stamp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * The code is rearranged so that the path is the most&n;&t; * short when CPU is congested, but is still operating.&n;&t; */
id|local_irq_save
c_func
(paren
id|flags
)paren
suffix:semicolon
id|this_cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
id|queue
op_assign
op_amp
id|__get_cpu_var
c_func
(paren
id|softnet_data
)paren
suffix:semicolon
id|__get_cpu_var
c_func
(paren
id|netdev_rx_stat
)paren
dot
id|total
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|queue-&gt;input_pkt_queue.qlen
op_le
id|netdev_max_backlog
)paren
(brace
r_if
c_cond
(paren
id|queue-&gt;input_pkt_queue.qlen
)paren
(brace
r_if
c_cond
(paren
id|queue-&gt;throttle
)paren
r_goto
id|drop
suffix:semicolon
id|enqueue
suffix:colon
id|dev_hold
c_func
(paren
id|skb-&gt;dev
)paren
suffix:semicolon
id|__skb_queue_tail
c_func
(paren
op_amp
id|queue-&gt;input_pkt_queue
comma
id|skb
)paren
suffix:semicolon
macro_line|#ifndef OFFLINE_SAMPLE
id|get_sample_stats
c_func
(paren
id|this_cpu
)paren
suffix:semicolon
macro_line|#endif
id|local_irq_restore
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|queue-&gt;cng_level
suffix:semicolon
)brace
r_if
c_cond
(paren
id|queue-&gt;throttle
)paren
id|queue-&gt;throttle
op_assign
l_int|0
suffix:semicolon
id|netif_rx_schedule
c_func
(paren
op_amp
id|queue-&gt;backlog_dev
)paren
suffix:semicolon
r_goto
id|enqueue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|queue-&gt;throttle
)paren
(brace
id|queue-&gt;throttle
op_assign
l_int|1
suffix:semicolon
id|__get_cpu_var
c_func
(paren
id|netdev_rx_stat
)paren
dot
id|throttled
op_increment
suffix:semicolon
)brace
id|drop
suffix:colon
id|__get_cpu_var
c_func
(paren
id|netdev_rx_stat
)paren
dot
id|dropped
op_increment
suffix:semicolon
id|local_irq_restore
c_func
(paren
id|flags
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
id|NET_RX_DROP
suffix:semicolon
)brace
DECL|function|netif_rx_ni
r_int
id|netif_rx_ni
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_int
id|err
suffix:semicolon
id|preempt_disable
c_func
(paren
)paren
suffix:semicolon
id|err
op_assign
id|netif_rx
c_func
(paren
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|local_softirq_pending
c_func
(paren
)paren
)paren
id|do_softirq
c_func
(paren
)paren
suffix:semicolon
id|preempt_enable
c_func
(paren
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|variable|netif_rx_ni
id|EXPORT_SYMBOL
c_func
(paren
id|netif_rx_ni
)paren
suffix:semicolon
DECL|function|skb_bond
r_static
id|__inline__
r_void
id|skb_bond
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|net_device
op_star
id|dev
op_assign
id|skb-&gt;dev
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;master
)paren
(brace
id|skb-&gt;real_dev
op_assign
id|skb-&gt;dev
suffix:semicolon
id|skb-&gt;dev
op_assign
id|dev-&gt;master
suffix:semicolon
)brace
)brace
DECL|function|net_tx_action
r_static
r_void
id|net_tx_action
c_func
(paren
r_struct
id|softirq_action
op_star
id|h
)paren
(brace
r_struct
id|softnet_data
op_star
id|sd
op_assign
op_amp
id|__get_cpu_var
c_func
(paren
id|softnet_data
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sd-&gt;completion_queue
)paren
(brace
r_struct
id|sk_buff
op_star
id|clist
suffix:semicolon
id|local_irq_disable
c_func
(paren
)paren
suffix:semicolon
id|clist
op_assign
id|sd-&gt;completion_queue
suffix:semicolon
id|sd-&gt;completion_queue
op_assign
l_int|NULL
suffix:semicolon
id|local_irq_enable
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|clist
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
op_assign
id|clist
suffix:semicolon
id|clist
op_assign
id|clist-&gt;next
suffix:semicolon
id|BUG_TRAP
c_func
(paren
op_logical_neg
id|atomic_read
c_func
(paren
op_amp
id|skb-&gt;users
)paren
)paren
suffix:semicolon
id|__kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|sd-&gt;output_queue
)paren
(brace
r_struct
id|net_device
op_star
id|head
suffix:semicolon
id|local_irq_disable
c_func
(paren
)paren
suffix:semicolon
id|head
op_assign
id|sd-&gt;output_queue
suffix:semicolon
id|sd-&gt;output_queue
op_assign
l_int|NULL
suffix:semicolon
id|local_irq_enable
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|head
)paren
(brace
r_struct
id|net_device
op_star
id|dev
op_assign
id|head
suffix:semicolon
id|head
op_assign
id|head-&gt;next_sched
suffix:semicolon
id|smp_mb__before_clear_bit
c_func
(paren
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|__LINK_STATE_SCHED
comma
op_amp
id|dev-&gt;state
)paren
suffix:semicolon
r_if
c_cond
(paren
id|spin_trylock
c_func
(paren
op_amp
id|dev-&gt;queue_lock
)paren
)paren
(brace
id|qdisc_run
c_func
(paren
id|dev
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|dev-&gt;queue_lock
)paren
suffix:semicolon
)brace
r_else
(brace
id|netif_schedule
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
DECL|function|deliver_skb
r_static
id|__inline__
r_int
id|deliver_skb
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|packet_type
op_star
id|pt_prev
)paren
(brace
id|atomic_inc
c_func
(paren
op_amp
id|skb-&gt;users
)paren
suffix:semicolon
r_return
id|pt_prev
op_member_access_from_pointer
id|func
c_func
(paren
id|skb
comma
id|skb-&gt;dev
comma
id|pt_prev
)paren
suffix:semicolon
)brace
macro_line|#if defined(CONFIG_BRIDGE) || defined (CONFIG_BRIDGE_MODULE)
DECL|variable|br_handle_frame_hook
r_int
(paren
op_star
id|br_handle_frame_hook
)paren
(paren
r_struct
id|net_bridge_port
op_star
id|p
comma
r_struct
id|sk_buff
op_star
op_star
id|pskb
)paren
suffix:semicolon
DECL|function|handle_bridge
r_static
id|__inline__
r_int
id|handle_bridge
c_func
(paren
r_struct
id|sk_buff
op_star
op_star
id|pskb
comma
r_struct
id|packet_type
op_star
op_star
id|pt_prev
comma
r_int
op_star
id|ret
)paren
(brace
r_struct
id|net_bridge_port
op_star
id|port
suffix:semicolon
r_if
c_cond
(paren
(paren
op_star
id|pskb
)paren
op_member_access_from_pointer
id|pkt_type
op_eq
id|PACKET_LOOPBACK
op_logical_or
(paren
id|port
op_assign
id|rcu_dereference
c_func
(paren
(paren
op_star
id|pskb
)paren
op_member_access_from_pointer
id|dev-&gt;br_port
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_star
id|pt_prev
)paren
(brace
op_star
id|ret
op_assign
id|deliver_skb
c_func
(paren
op_star
id|pskb
comma
op_star
id|pt_prev
)paren
suffix:semicolon
op_star
id|pt_prev
op_assign
l_int|NULL
suffix:semicolon
)brace
r_return
id|br_handle_frame_hook
c_func
(paren
id|port
comma
id|pskb
)paren
suffix:semicolon
)brace
macro_line|#else
DECL|macro|handle_bridge
mdefine_line|#define handle_bridge(skb, pt_prev, ret)&t;(0)
macro_line|#endif
macro_line|#ifdef CONFIG_NET_CLS_ACT
multiline_comment|/* TODO: Maybe we should just force sch_ingress to be compiled in&n; * when CONFIG_NET_CLS_ACT is? otherwise some useless instructions&n; * a compare and 2 stores extra right now if we dont have it on&n; * but have CONFIG_NET_CLS_ACT&n; * NOTE: This doesnt stop any functionality; if you dont have &n; * the ingress scheduler, you just cant add policies on ingress.&n; *&n; */
DECL|function|ing_filter
r_static
r_int
id|ing_filter
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|Qdisc
op_star
id|q
suffix:semicolon
r_struct
id|net_device
op_star
id|dev
op_assign
id|skb-&gt;dev
suffix:semicolon
r_int
id|result
op_assign
id|TC_ACT_OK
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;qdisc_ingress
)paren
(brace
id|__u32
id|ttl
op_assign
(paren
id|__u32
)paren
id|G_TC_RTTL
c_func
(paren
id|skb-&gt;tc_verd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|MAX_RED_LOOP
OL
id|ttl
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Redir loop detected Dropping packet (%s-&gt;%s)&bslash;n&quot;
comma
id|skb-&gt;input_dev
ques
c_cond
id|skb-&gt;input_dev-&gt;name
suffix:colon
l_string|&quot;??&quot;
comma
id|skb-&gt;dev-&gt;name
)paren
suffix:semicolon
r_return
id|TC_ACT_SHOT
suffix:semicolon
)brace
id|skb-&gt;tc_verd
op_assign
id|SET_TC_RTTL
c_func
(paren
id|skb-&gt;tc_verd
comma
id|ttl
)paren
suffix:semicolon
id|skb-&gt;tc_verd
op_assign
id|SET_TC_AT
c_func
(paren
id|skb-&gt;tc_verd
comma
id|AT_INGRESS
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|NULL
op_eq
id|skb-&gt;input_dev
)paren
(brace
id|skb-&gt;input_dev
op_assign
id|skb-&gt;dev
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ing_filter:  fixed  %s out %s&bslash;n&quot;
comma
id|skb-&gt;input_dev-&gt;name
comma
id|skb-&gt;dev-&gt;name
)paren
suffix:semicolon
)brace
id|spin_lock
c_func
(paren
op_amp
id|dev-&gt;ingress_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|q
op_assign
id|dev-&gt;qdisc_ingress
)paren
op_ne
l_int|NULL
)paren
id|result
op_assign
id|q
op_member_access_from_pointer
id|enqueue
c_func
(paren
id|skb
comma
id|q
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|dev-&gt;ingress_lock
)paren
suffix:semicolon
)brace
r_return
id|result
suffix:semicolon
)brace
macro_line|#endif
DECL|function|netif_receive_skb
r_int
id|netif_receive_skb
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|packet_type
op_star
id|ptype
comma
op_star
id|pt_prev
suffix:semicolon
r_int
id|ret
op_assign
id|NET_RX_DROP
suffix:semicolon
r_int
r_int
id|type
suffix:semicolon
macro_line|#ifdef CONFIG_NETPOLL
r_if
c_cond
(paren
id|skb-&gt;dev-&gt;netpoll_rx
op_logical_and
id|skb-&gt;dev-&gt;poll
op_logical_and
id|netpoll_rx
c_func
(paren
id|skb
)paren
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
id|NET_RX_DROP
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|skb-&gt;stamp.tv_sec
)paren
id|net_timestamp
c_func
(paren
op_amp
id|skb-&gt;stamp
)paren
suffix:semicolon
id|skb_bond
c_func
(paren
id|skb
)paren
suffix:semicolon
id|__get_cpu_var
c_func
(paren
id|netdev_rx_stat
)paren
dot
id|total
op_increment
suffix:semicolon
id|skb-&gt;h.raw
op_assign
id|skb-&gt;nh.raw
op_assign
id|skb-&gt;data
suffix:semicolon
id|skb-&gt;mac_len
op_assign
id|skb-&gt;nh.raw
op_minus
id|skb-&gt;mac.raw
suffix:semicolon
id|pt_prev
op_assign
l_int|NULL
suffix:semicolon
id|rcu_read_lock
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_NET_CLS_ACT
r_if
c_cond
(paren
id|skb-&gt;tc_verd
op_amp
id|TC_NCLS
)paren
(brace
id|skb-&gt;tc_verd
op_assign
id|CLR_TC_NCLS
c_func
(paren
id|skb-&gt;tc_verd
)paren
suffix:semicolon
r_goto
id|ncls
suffix:semicolon
)brace
macro_line|#endif
id|list_for_each_entry_rcu
c_func
(paren
id|ptype
comma
op_amp
id|ptype_all
comma
id|list
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ptype-&gt;dev
op_logical_or
id|ptype-&gt;dev
op_eq
id|skb-&gt;dev
)paren
(brace
r_if
c_cond
(paren
id|pt_prev
)paren
id|ret
op_assign
id|deliver_skb
c_func
(paren
id|skb
comma
id|pt_prev
)paren
suffix:semicolon
id|pt_prev
op_assign
id|ptype
suffix:semicolon
)brace
)brace
macro_line|#ifdef CONFIG_NET_CLS_ACT
r_if
c_cond
(paren
id|pt_prev
)paren
(brace
id|ret
op_assign
id|deliver_skb
c_func
(paren
id|skb
comma
id|pt_prev
)paren
suffix:semicolon
id|pt_prev
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* noone else should process this after*/
)brace
r_else
(brace
id|skb-&gt;tc_verd
op_assign
id|SET_TC_OK2MUNGE
c_func
(paren
id|skb-&gt;tc_verd
)paren
suffix:semicolon
)brace
id|ret
op_assign
id|ing_filter
c_func
(paren
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
id|TC_ACT_SHOT
op_logical_or
(paren
id|ret
op_eq
id|TC_ACT_STOLEN
)paren
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|skb-&gt;tc_verd
op_assign
l_int|0
suffix:semicolon
id|ncls
suffix:colon
macro_line|#endif
id|handle_diverter
c_func
(paren
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|handle_bridge
c_func
(paren
op_amp
id|skb
comma
op_amp
id|pt_prev
comma
op_amp
id|ret
)paren
)paren
r_goto
id|out
suffix:semicolon
id|type
op_assign
id|skb-&gt;protocol
suffix:semicolon
id|list_for_each_entry_rcu
c_func
(paren
id|ptype
comma
op_amp
id|ptype_base
(braket
id|ntohs
c_func
(paren
id|type
)paren
op_amp
l_int|15
)braket
comma
id|list
)paren
(brace
r_if
c_cond
(paren
id|ptype-&gt;type
op_eq
id|type
op_logical_and
(paren
op_logical_neg
id|ptype-&gt;dev
op_logical_or
id|ptype-&gt;dev
op_eq
id|skb-&gt;dev
)paren
)paren
(brace
r_if
c_cond
(paren
id|pt_prev
)paren
id|ret
op_assign
id|deliver_skb
c_func
(paren
id|skb
comma
id|pt_prev
)paren
suffix:semicolon
id|pt_prev
op_assign
id|ptype
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|pt_prev
)paren
(brace
id|ret
op_assign
id|pt_prev
op_member_access_from_pointer
id|func
c_func
(paren
id|skb
comma
id|skb-&gt;dev
comma
id|pt_prev
)paren
suffix:semicolon
)brace
r_else
(brace
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
multiline_comment|/* Jamal, now you will not able to escape explaining&n;&t;&t; * me how you were going to use this. :-)&n;&t;&t; */
id|ret
op_assign
id|NET_RX_DROP
suffix:semicolon
)brace
id|out
suffix:colon
id|rcu_read_unlock
c_func
(paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|process_backlog
r_static
r_int
id|process_backlog
c_func
(paren
r_struct
id|net_device
op_star
id|backlog_dev
comma
r_int
op_star
id|budget
)paren
(brace
r_int
id|work
op_assign
l_int|0
suffix:semicolon
r_int
id|quota
op_assign
id|min
c_func
(paren
id|backlog_dev-&gt;quota
comma
op_star
id|budget
)paren
suffix:semicolon
r_struct
id|softnet_data
op_star
id|queue
op_assign
op_amp
id|__get_cpu_var
c_func
(paren
id|softnet_data
)paren
suffix:semicolon
r_int
r_int
id|start_time
op_assign
id|jiffies
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_struct
id|net_device
op_star
id|dev
suffix:semicolon
id|local_irq_disable
c_func
(paren
)paren
suffix:semicolon
id|skb
op_assign
id|__skb_dequeue
c_func
(paren
op_amp
id|queue-&gt;input_pkt_queue
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skb
)paren
r_goto
id|job_done
suffix:semicolon
id|local_irq_enable
c_func
(paren
)paren
suffix:semicolon
id|dev
op_assign
id|skb-&gt;dev
suffix:semicolon
id|netif_receive_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
id|dev_put
c_func
(paren
id|dev
)paren
suffix:semicolon
id|work
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|work
op_ge
id|quota
op_logical_or
id|jiffies
op_minus
id|start_time
OG
l_int|1
)paren
r_break
suffix:semicolon
)brace
id|backlog_dev-&gt;quota
op_sub_assign
id|work
suffix:semicolon
op_star
id|budget
op_sub_assign
id|work
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
id|job_done
suffix:colon
id|backlog_dev-&gt;quota
op_sub_assign
id|work
suffix:semicolon
op_star
id|budget
op_sub_assign
id|work
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|backlog_dev-&gt;poll_list
)paren
suffix:semicolon
id|smp_mb__before_clear_bit
c_func
(paren
)paren
suffix:semicolon
id|netif_poll_enable
c_func
(paren
id|backlog_dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|queue-&gt;throttle
)paren
id|queue-&gt;throttle
op_assign
l_int|0
suffix:semicolon
id|local_irq_enable
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|net_rx_action
r_static
r_void
id|net_rx_action
c_func
(paren
r_struct
id|softirq_action
op_star
id|h
)paren
(brace
r_struct
id|softnet_data
op_star
id|queue
op_assign
op_amp
id|__get_cpu_var
c_func
(paren
id|softnet_data
)paren
suffix:semicolon
r_int
r_int
id|start_time
op_assign
id|jiffies
suffix:semicolon
r_int
id|budget
op_assign
id|netdev_max_backlog
suffix:semicolon
id|local_irq_disable
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|queue-&gt;poll_list
)paren
)paren
(brace
r_struct
id|net_device
op_star
id|dev
suffix:semicolon
r_if
c_cond
(paren
id|budget
op_le
l_int|0
op_logical_or
id|jiffies
op_minus
id|start_time
OG
l_int|1
)paren
r_goto
id|softnet_break
suffix:semicolon
id|local_irq_enable
c_func
(paren
)paren
suffix:semicolon
id|dev
op_assign
id|list_entry
c_func
(paren
id|queue-&gt;poll_list.next
comma
r_struct
id|net_device
comma
id|poll_list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;quota
op_le
l_int|0
op_logical_or
id|dev
op_member_access_from_pointer
id|poll
c_func
(paren
id|dev
comma
op_amp
id|budget
)paren
)paren
(brace
id|local_irq_disable
c_func
(paren
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|dev-&gt;poll_list
)paren
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|dev-&gt;poll_list
comma
op_amp
id|queue-&gt;poll_list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;quota
OL
l_int|0
)paren
id|dev-&gt;quota
op_add_assign
id|dev-&gt;weight
suffix:semicolon
r_else
id|dev-&gt;quota
op_assign
id|dev-&gt;weight
suffix:semicolon
)brace
r_else
(brace
id|dev_put
c_func
(paren
id|dev
)paren
suffix:semicolon
id|local_irq_disable
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
id|out
suffix:colon
id|local_irq_enable
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
id|softnet_break
suffix:colon
id|__get_cpu_var
c_func
(paren
id|netdev_rx_stat
)paren
dot
id|time_squeeze
op_increment
suffix:semicolon
id|__raise_softirq_irqoff
c_func
(paren
id|NET_RX_SOFTIRQ
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
DECL|variable|gifconf_list
r_static
id|gifconf_func_t
op_star
id|gifconf_list
(braket
id|NPROTO
)braket
suffix:semicolon
multiline_comment|/**&n; *&t;register_gifconf&t;-&t;register a SIOCGIF handler&n; *&t;@family: Address family&n; *&t;@gifconf: Function handler&n; *&n; *&t;Register protocol dependent address dumping routines. The handler&n; *&t;that is passed must not be freed or reused until it has been replaced&n; *&t;by another handler.&n; */
DECL|function|register_gifconf
r_int
id|register_gifconf
c_func
(paren
r_int
r_int
id|family
comma
id|gifconf_func_t
op_star
id|gifconf
)paren
(brace
r_if
c_cond
(paren
id|family
op_ge
id|NPROTO
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|gifconf_list
(braket
id|family
)braket
op_assign
id|gifconf
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Map an interface index to its name (SIOCGIFNAME)&n; */
multiline_comment|/*&n; *&t;We need this ioctl for efficient implementation of the&n; *&t;if_indextoname() function required by the IPv6 API.  Without&n; *&t;it, we would have to search all the interfaces to find a&n; *&t;match.  --pb&n; */
DECL|function|dev_ifname
r_static
r_int
id|dev_ifname
c_func
(paren
r_struct
id|ifreq
id|__user
op_star
id|arg
)paren
(brace
r_struct
id|net_device
op_star
id|dev
suffix:semicolon
r_struct
id|ifreq
id|ifr
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Fetch the caller&squot;s info block.&n;&t; */
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|ifr
comma
id|arg
comma
r_sizeof
(paren
r_struct
id|ifreq
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|dev_base_lock
)paren
suffix:semicolon
id|dev
op_assign
id|__dev_get_by_index
c_func
(paren
id|ifr.ifr_ifindex
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
(brace
id|read_unlock
c_func
(paren
op_amp
id|dev_base_lock
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|strcpy
c_func
(paren
id|ifr.ifr_name
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|dev_base_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|arg
comma
op_amp
id|ifr
comma
r_sizeof
(paren
r_struct
id|ifreq
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Perform a SIOCGIFCONF call. This structure will change&n; *&t;size eventually, and there is nothing I can do about it.&n; *&t;Thus we will need a &squot;compatibility mode&squot;.&n; */
DECL|function|dev_ifconf
r_static
r_int
id|dev_ifconf
c_func
(paren
r_char
id|__user
op_star
id|arg
)paren
(brace
r_struct
id|ifconf
id|ifc
suffix:semicolon
r_struct
id|net_device
op_star
id|dev
suffix:semicolon
r_char
id|__user
op_star
id|pos
suffix:semicolon
r_int
id|len
suffix:semicolon
r_int
id|total
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Fetch the caller&squot;s info block.&n;&t; */
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|ifc
comma
id|arg
comma
r_sizeof
(paren
r_struct
id|ifconf
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|pos
op_assign
id|ifc.ifc_buf
suffix:semicolon
id|len
op_assign
id|ifc.ifc_len
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Loop over the interfaces, and write an info block for each.&n;&t; */
id|total
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|dev
op_assign
id|dev_base
suffix:semicolon
id|dev
suffix:semicolon
id|dev
op_assign
id|dev-&gt;next
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NPROTO
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|gifconf_list
(braket
id|i
)braket
)paren
(brace
r_int
id|done
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pos
)paren
id|done
op_assign
id|gifconf_list
(braket
id|i
)braket
(paren
id|dev
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
r_else
id|done
op_assign
id|gifconf_list
(braket
id|i
)braket
(paren
id|dev
comma
id|pos
op_plus
id|total
comma
id|len
op_minus
id|total
)paren
suffix:semicolon
r_if
c_cond
(paren
id|done
OL
l_int|0
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|total
op_add_assign
id|done
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;&t; *&t;All done.  Write the updated control block back to the caller.&n;&t; */
id|ifc.ifc_len
op_assign
id|total
suffix:semicolon
multiline_comment|/*&n;&t; * &t;Both BSD and Solaris return 0 here, so we do too.&n;&t; */
r_return
id|copy_to_user
c_func
(paren
id|arg
comma
op_amp
id|ifc
comma
r_sizeof
(paren
r_struct
id|ifconf
)paren
)paren
ques
c_cond
op_minus
id|EFAULT
suffix:colon
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_PROC_FS
multiline_comment|/*&n; *&t;This is invoked by the /proc filesystem handler to display a device&n; *&t;in detail.&n; */
DECL|function|dev_get_idx
r_static
id|__inline__
r_struct
id|net_device
op_star
id|dev_get_idx
c_func
(paren
id|loff_t
id|pos
)paren
(brace
r_struct
id|net_device
op_star
id|dev
suffix:semicolon
id|loff_t
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|dev
op_assign
id|dev_base
suffix:semicolon
id|dev
op_logical_and
id|i
OL
id|pos
suffix:semicolon
op_increment
id|i
comma
id|dev
op_assign
id|dev-&gt;next
)paren
suffix:semicolon
r_return
id|i
op_eq
id|pos
ques
c_cond
id|dev
suffix:colon
l_int|NULL
suffix:semicolon
)brace
DECL|function|dev_seq_start
r_void
op_star
id|dev_seq_start
c_func
(paren
r_struct
id|seq_file
op_star
id|seq
comma
id|loff_t
op_star
id|pos
)paren
(brace
id|read_lock
c_func
(paren
op_amp
id|dev_base_lock
)paren
suffix:semicolon
r_return
op_star
id|pos
ques
c_cond
id|dev_get_idx
c_func
(paren
op_star
id|pos
op_minus
l_int|1
)paren
suffix:colon
id|SEQ_START_TOKEN
suffix:semicolon
)brace
DECL|function|dev_seq_next
r_void
op_star
id|dev_seq_next
c_func
(paren
r_struct
id|seq_file
op_star
id|seq
comma
r_void
op_star
id|v
comma
id|loff_t
op_star
id|pos
)paren
(brace
op_increment
op_star
id|pos
suffix:semicolon
r_return
id|v
op_eq
id|SEQ_START_TOKEN
ques
c_cond
id|dev_base
suffix:colon
(paren
(paren
r_struct
id|net_device
op_star
)paren
id|v
)paren
op_member_access_from_pointer
id|next
suffix:semicolon
)brace
DECL|function|dev_seq_stop
r_void
id|dev_seq_stop
c_func
(paren
r_struct
id|seq_file
op_star
id|seq
comma
r_void
op_star
id|v
)paren
(brace
id|read_unlock
c_func
(paren
op_amp
id|dev_base_lock
)paren
suffix:semicolon
)brace
DECL|function|dev_seq_printf_stats
r_static
r_void
id|dev_seq_printf_stats
c_func
(paren
r_struct
id|seq_file
op_star
id|seq
comma
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_if
c_cond
(paren
id|dev-&gt;get_stats
)paren
(brace
r_struct
id|net_device_stats
op_star
id|stats
op_assign
id|dev
op_member_access_from_pointer
id|get_stats
c_func
(paren
id|dev
)paren
suffix:semicolon
id|seq_printf
c_func
(paren
id|seq
comma
l_string|&quot;%6s:%8lu %7lu %4lu %4lu %4lu %5lu %10lu %9lu &quot;
l_string|&quot;%8lu %7lu %4lu %4lu %4lu %5lu %7lu %10lu&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|stats-&gt;rx_bytes
comma
id|stats-&gt;rx_packets
comma
id|stats-&gt;rx_errors
comma
id|stats-&gt;rx_dropped
op_plus
id|stats-&gt;rx_missed_errors
comma
id|stats-&gt;rx_fifo_errors
comma
id|stats-&gt;rx_length_errors
op_plus
id|stats-&gt;rx_over_errors
op_plus
id|stats-&gt;rx_crc_errors
op_plus
id|stats-&gt;rx_frame_errors
comma
id|stats-&gt;rx_compressed
comma
id|stats-&gt;multicast
comma
id|stats-&gt;tx_bytes
comma
id|stats-&gt;tx_packets
comma
id|stats-&gt;tx_errors
comma
id|stats-&gt;tx_dropped
comma
id|stats-&gt;tx_fifo_errors
comma
id|stats-&gt;collisions
comma
id|stats-&gt;tx_carrier_errors
op_plus
id|stats-&gt;tx_aborted_errors
op_plus
id|stats-&gt;tx_window_errors
op_plus
id|stats-&gt;tx_heartbeat_errors
comma
id|stats-&gt;tx_compressed
)paren
suffix:semicolon
)brace
r_else
id|seq_printf
c_func
(paren
id|seq
comma
l_string|&quot;%6s: No statistics available.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Called from the PROCfs module. This now uses the new arbitrary sized&n; *&t;/proc/net interface to create /proc/net/dev&n; */
DECL|function|dev_seq_show
r_static
r_int
id|dev_seq_show
c_func
(paren
r_struct
id|seq_file
op_star
id|seq
comma
r_void
op_star
id|v
)paren
(brace
r_if
c_cond
(paren
id|v
op_eq
id|SEQ_START_TOKEN
)paren
id|seq_puts
c_func
(paren
id|seq
comma
l_string|&quot;Inter-|   Receive                            &quot;
l_string|&quot;                    |  Transmit&bslash;n&quot;
l_string|&quot; face |bytes    packets errs drop fifo frame &quot;
l_string|&quot;compressed multicast|bytes    packets errs &quot;
l_string|&quot;drop fifo colls carrier compressed&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|dev_seq_printf_stats
c_func
(paren
id|seq
comma
id|v
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|softnet_get_online
r_static
r_struct
id|netif_rx_stats
op_star
id|softnet_get_online
c_func
(paren
id|loff_t
op_star
id|pos
)paren
(brace
r_struct
id|netif_rx_stats
op_star
id|rc
op_assign
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
op_star
id|pos
OL
id|NR_CPUS
)paren
r_if
c_cond
(paren
id|cpu_online
c_func
(paren
op_star
id|pos
)paren
)paren
(brace
id|rc
op_assign
op_amp
id|per_cpu
c_func
(paren
id|netdev_rx_stat
comma
op_star
id|pos
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_else
op_increment
op_star
id|pos
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
DECL|function|softnet_seq_start
r_static
r_void
op_star
id|softnet_seq_start
c_func
(paren
r_struct
id|seq_file
op_star
id|seq
comma
id|loff_t
op_star
id|pos
)paren
(brace
r_return
id|softnet_get_online
c_func
(paren
id|pos
)paren
suffix:semicolon
)brace
DECL|function|softnet_seq_next
r_static
r_void
op_star
id|softnet_seq_next
c_func
(paren
r_struct
id|seq_file
op_star
id|seq
comma
r_void
op_star
id|v
comma
id|loff_t
op_star
id|pos
)paren
(brace
op_increment
op_star
id|pos
suffix:semicolon
r_return
id|softnet_get_online
c_func
(paren
id|pos
)paren
suffix:semicolon
)brace
DECL|function|softnet_seq_stop
r_static
r_void
id|softnet_seq_stop
c_func
(paren
r_struct
id|seq_file
op_star
id|seq
comma
r_void
op_star
id|v
)paren
(brace
)brace
DECL|function|softnet_seq_show
r_static
r_int
id|softnet_seq_show
c_func
(paren
r_struct
id|seq_file
op_star
id|seq
comma
r_void
op_star
id|v
)paren
(brace
r_struct
id|netif_rx_stats
op_star
id|s
op_assign
id|v
suffix:semicolon
id|seq_printf
c_func
(paren
id|seq
comma
l_string|&quot;%08x %08x %08x %08x %08x %08x %08x %08x %08x&bslash;n&quot;
comma
id|s-&gt;total
comma
id|s-&gt;dropped
comma
id|s-&gt;time_squeeze
comma
id|s-&gt;throttled
comma
id|s-&gt;fastroute_hit
comma
id|s-&gt;fastroute_success
comma
id|s-&gt;fastroute_defer
comma
id|s-&gt;fastroute_deferred_out
comma
macro_line|#if 0
id|s-&gt;fastroute_latency_reduction
macro_line|#else
id|s-&gt;cpu_collision
macro_line|#endif
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|dev_seq_ops
r_static
r_struct
id|seq_operations
id|dev_seq_ops
op_assign
(brace
dot
id|start
op_assign
id|dev_seq_start
comma
dot
id|next
op_assign
id|dev_seq_next
comma
dot
id|stop
op_assign
id|dev_seq_stop
comma
dot
id|show
op_assign
id|dev_seq_show
comma
)brace
suffix:semicolon
DECL|function|dev_seq_open
r_static
r_int
id|dev_seq_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_return
id|seq_open
c_func
(paren
id|file
comma
op_amp
id|dev_seq_ops
)paren
suffix:semicolon
)brace
DECL|variable|dev_seq_fops
r_static
r_struct
id|file_operations
id|dev_seq_fops
op_assign
(brace
dot
id|owner
op_assign
id|THIS_MODULE
comma
dot
id|open
op_assign
id|dev_seq_open
comma
dot
id|read
op_assign
id|seq_read
comma
dot
id|llseek
op_assign
id|seq_lseek
comma
dot
id|release
op_assign
id|seq_release
comma
)brace
suffix:semicolon
DECL|variable|softnet_seq_ops
r_static
r_struct
id|seq_operations
id|softnet_seq_ops
op_assign
(brace
dot
id|start
op_assign
id|softnet_seq_start
comma
dot
id|next
op_assign
id|softnet_seq_next
comma
dot
id|stop
op_assign
id|softnet_seq_stop
comma
dot
id|show
op_assign
id|softnet_seq_show
comma
)brace
suffix:semicolon
DECL|function|softnet_seq_open
r_static
r_int
id|softnet_seq_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_return
id|seq_open
c_func
(paren
id|file
comma
op_amp
id|softnet_seq_ops
)paren
suffix:semicolon
)brace
DECL|variable|softnet_seq_fops
r_static
r_struct
id|file_operations
id|softnet_seq_fops
op_assign
(brace
dot
id|owner
op_assign
id|THIS_MODULE
comma
dot
id|open
op_assign
id|softnet_seq_open
comma
dot
id|read
op_assign
id|seq_read
comma
dot
id|llseek
op_assign
id|seq_lseek
comma
dot
id|release
op_assign
id|seq_release
comma
)brace
suffix:semicolon
macro_line|#ifdef WIRELESS_EXT
r_extern
r_int
id|wireless_proc_init
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#else
DECL|macro|wireless_proc_init
mdefine_line|#define wireless_proc_init() 0
macro_line|#endif
DECL|function|dev_proc_init
r_static
r_int
id|__init
id|dev_proc_init
c_func
(paren
r_void
)paren
(brace
r_int
id|rc
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|proc_net_fops_create
c_func
(paren
l_string|&quot;dev&quot;
comma
id|S_IRUGO
comma
op_amp
id|dev_seq_fops
)paren
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|proc_net_fops_create
c_func
(paren
l_string|&quot;softnet_stat&quot;
comma
id|S_IRUGO
comma
op_amp
id|softnet_seq_fops
)paren
)paren
r_goto
id|out_dev
suffix:semicolon
r_if
c_cond
(paren
id|wireless_proc_init
c_func
(paren
)paren
)paren
r_goto
id|out_softnet
suffix:semicolon
id|rc
op_assign
l_int|0
suffix:semicolon
id|out
suffix:colon
r_return
id|rc
suffix:semicolon
id|out_softnet
suffix:colon
id|proc_net_remove
c_func
(paren
l_string|&quot;softnet_stat&quot;
)paren
suffix:semicolon
id|out_dev
suffix:colon
id|proc_net_remove
c_func
(paren
l_string|&quot;dev&quot;
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
macro_line|#else
DECL|macro|dev_proc_init
mdefine_line|#define dev_proc_init() 0
macro_line|#endif&t;/* CONFIG_PROC_FS */
multiline_comment|/**&n; *&t;netdev_set_master&t;-&t;set up master/slave pair&n; *&t;@slave: slave device&n; *&t;@master: new master device&n; *&n; *&t;Changes the master device of the slave. Pass %NULL to break the&n; *&t;bonding. The caller must hold the RTNL semaphore. On a failure&n; *&t;a negative errno code is returned. On success the reference counts&n; *&t;are adjusted, %RTM_NEWLINK is sent to the routing socket and the&n; *&t;function returns zero.&n; */
DECL|function|netdev_set_master
r_int
id|netdev_set_master
c_func
(paren
r_struct
id|net_device
op_star
id|slave
comma
r_struct
id|net_device
op_star
id|master
)paren
(brace
r_struct
id|net_device
op_star
id|old
op_assign
id|slave-&gt;master
suffix:semicolon
id|ASSERT_RTNL
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|master
)paren
(brace
r_if
c_cond
(paren
id|old
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
id|dev_hold
c_func
(paren
id|master
)paren
suffix:semicolon
)brace
id|slave-&gt;master
op_assign
id|master
suffix:semicolon
id|synchronize_net
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|old
)paren
id|dev_put
c_func
(paren
id|old
)paren
suffix:semicolon
r_if
c_cond
(paren
id|master
)paren
id|slave-&gt;flags
op_or_assign
id|IFF_SLAVE
suffix:semicolon
r_else
id|slave-&gt;flags
op_and_assign
op_complement
id|IFF_SLAVE
suffix:semicolon
id|rtmsg_ifinfo
c_func
(paren
id|RTM_NEWLINK
comma
id|slave
comma
id|IFF_SLAVE
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;dev_set_promiscuity&t;- update promiscuity count on a device&n; *&t;@dev: device&n; *&t;@inc: modifier&n; *&n; *&t;Add or remove promsicuity from a device. While the count in the device&n; *&t;remains above zero the interface remains promiscuous. Once it hits zero&n; *&t;the device reverts back to normal filtering operation. A negative inc&n; *&t;value is used to drop promiscuity on the device.&n; */
DECL|function|dev_set_promiscuity
r_void
id|dev_set_promiscuity
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|inc
)paren
(brace
r_int
r_int
id|old_flags
op_assign
id|dev-&gt;flags
suffix:semicolon
id|dev-&gt;flags
op_or_assign
id|IFF_PROMISC
suffix:semicolon
r_if
c_cond
(paren
(paren
id|dev-&gt;promiscuity
op_add_assign
id|inc
)paren
op_eq
l_int|0
)paren
id|dev-&gt;flags
op_and_assign
op_complement
id|IFF_PROMISC
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;flags
op_xor
id|old_flags
)paren
(brace
id|dev_mc_upload
c_func
(paren
id|dev
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;device %s %s promiscuous mode&bslash;n&quot;
comma
id|dev-&gt;name
comma
(paren
id|dev-&gt;flags
op_amp
id|IFF_PROMISC
)paren
ques
c_cond
l_string|&quot;entered&quot;
suffix:colon
l_string|&quot;left&quot;
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; *&t;dev_set_allmulti&t;- update allmulti count on a device&n; *&t;@dev: device&n; *&t;@inc: modifier&n; *&n; *&t;Add or remove reception of all multicast frames to a device. While the&n; *&t;count in the device remains above zero the interface remains listening&n; *&t;to all interfaces. Once it hits zero the device reverts back to normal&n; *&t;filtering operation. A negative @inc value is used to drop the counter&n; *&t;when releasing a resource needing all multicasts.&n; */
DECL|function|dev_set_allmulti
r_void
id|dev_set_allmulti
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|inc
)paren
(brace
r_int
r_int
id|old_flags
op_assign
id|dev-&gt;flags
suffix:semicolon
id|dev-&gt;flags
op_or_assign
id|IFF_ALLMULTI
suffix:semicolon
r_if
c_cond
(paren
(paren
id|dev-&gt;allmulti
op_add_assign
id|inc
)paren
op_eq
l_int|0
)paren
id|dev-&gt;flags
op_and_assign
op_complement
id|IFF_ALLMULTI
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;flags
op_xor
id|old_flags
)paren
id|dev_mc_upload
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
DECL|function|dev_get_flags
r_int
id|dev_get_flags
c_func
(paren
r_const
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_int
id|flags
suffix:semicolon
id|flags
op_assign
(paren
id|dev-&gt;flags
op_amp
op_complement
(paren
id|IFF_PROMISC
op_or
id|IFF_ALLMULTI
op_or
id|IFF_RUNNING
)paren
)paren
op_or
(paren
id|dev-&gt;gflags
op_amp
(paren
id|IFF_PROMISC
op_or
id|IFF_ALLMULTI
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|netif_running
c_func
(paren
id|dev
)paren
op_logical_and
id|netif_carrier_ok
c_func
(paren
id|dev
)paren
)paren
id|flags
op_or_assign
id|IFF_RUNNING
suffix:semicolon
r_return
id|flags
suffix:semicolon
)brace
DECL|function|dev_change_flags
r_int
id|dev_change_flags
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|flags
)paren
(brace
r_int
id|ret
suffix:semicolon
r_int
id|old_flags
op_assign
id|dev-&gt;flags
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Set the flags on our device.&n;&t; */
id|dev-&gt;flags
op_assign
(paren
id|flags
op_amp
(paren
id|IFF_DEBUG
op_or
id|IFF_NOTRAILERS
op_or
id|IFF_NOARP
op_or
id|IFF_DYNAMIC
op_or
id|IFF_MULTICAST
op_or
id|IFF_PORTSEL
op_or
id|IFF_AUTOMEDIA
)paren
)paren
op_or
(paren
id|dev-&gt;flags
op_amp
(paren
id|IFF_UP
op_or
id|IFF_VOLATILE
op_or
id|IFF_PROMISC
op_or
id|IFF_ALLMULTI
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Load in the correct multicast list now the flags have changed.&n;&t; */
id|dev_mc_upload
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Have we downed the interface. We handle IFF_UP ourselves&n;&t; *&t;according to user attempts to set it, rather than blindly&n;&t; *&t;setting it.&n;&t; */
id|ret
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|old_flags
op_xor
id|flags
)paren
op_amp
id|IFF_UP
)paren
(brace
multiline_comment|/* Bit is different  ? */
id|ret
op_assign
(paren
(paren
id|old_flags
op_amp
id|IFF_UP
)paren
ques
c_cond
id|dev_close
suffix:colon
id|dev_open
)paren
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
id|dev_mc_upload
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dev-&gt;flags
op_amp
id|IFF_UP
op_logical_and
(paren
(paren
id|old_flags
op_xor
id|dev-&gt;flags
)paren
op_amp
op_complement
(paren
id|IFF_UP
op_or
id|IFF_PROMISC
op_or
id|IFF_ALLMULTI
op_or
id|IFF_VOLATILE
)paren
)paren
)paren
id|notifier_call_chain
c_func
(paren
op_amp
id|netdev_chain
comma
id|NETDEV_CHANGE
comma
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|flags
op_xor
id|dev-&gt;gflags
)paren
op_amp
id|IFF_PROMISC
)paren
(brace
r_int
id|inc
op_assign
(paren
id|flags
op_amp
id|IFF_PROMISC
)paren
ques
c_cond
op_plus
l_int|1
suffix:colon
op_minus
l_int|1
suffix:semicolon
id|dev-&gt;gflags
op_xor_assign
id|IFF_PROMISC
suffix:semicolon
id|dev_set_promiscuity
c_func
(paren
id|dev
comma
id|inc
)paren
suffix:semicolon
)brace
multiline_comment|/* NOTE: order of synchronization of IFF_PROMISC and IFF_ALLMULTI&n;&t;   is important. Some (broken) drivers set IFF_PROMISC, when&n;&t;   IFF_ALLMULTI is requested not asking us and not reporting.&n;&t; */
r_if
c_cond
(paren
(paren
id|flags
op_xor
id|dev-&gt;gflags
)paren
op_amp
id|IFF_ALLMULTI
)paren
(brace
r_int
id|inc
op_assign
(paren
id|flags
op_amp
id|IFF_ALLMULTI
)paren
ques
c_cond
op_plus
l_int|1
suffix:colon
op_minus
l_int|1
suffix:semicolon
id|dev-&gt;gflags
op_xor_assign
id|IFF_ALLMULTI
suffix:semicolon
id|dev_set_allmulti
c_func
(paren
id|dev
comma
id|inc
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|old_flags
op_xor
id|dev-&gt;flags
)paren
id|rtmsg_ifinfo
c_func
(paren
id|RTM_NEWLINK
comma
id|dev
comma
id|old_flags
op_xor
id|dev-&gt;flags
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|dev_set_mtu
r_int
id|dev_set_mtu
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|new_mtu
)paren
(brace
r_int
id|err
suffix:semicolon
r_if
c_cond
(paren
id|new_mtu
op_eq
id|dev-&gt;mtu
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&t;MTU must be positive.&t; */
r_if
c_cond
(paren
id|new_mtu
OL
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|netif_device_present
c_func
(paren
id|dev
)paren
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;change_mtu
)paren
id|err
op_assign
id|dev
op_member_access_from_pointer
id|change_mtu
c_func
(paren
id|dev
comma
id|new_mtu
)paren
suffix:semicolon
r_else
id|dev-&gt;mtu
op_assign
id|new_mtu
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|err
op_logical_and
id|dev-&gt;flags
op_amp
id|IFF_UP
)paren
id|notifier_call_chain
c_func
(paren
op_amp
id|netdev_chain
comma
id|NETDEV_CHANGEMTU
comma
id|dev
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Perform the SIOCxIFxxx calls.&n; */
DECL|function|dev_ifsioc
r_static
r_int
id|dev_ifsioc
c_func
(paren
r_struct
id|ifreq
op_star
id|ifr
comma
r_int
r_int
id|cmd
)paren
(brace
r_int
id|err
suffix:semicolon
r_struct
id|net_device
op_star
id|dev
op_assign
id|__dev_get_by_name
c_func
(paren
id|ifr-&gt;ifr_name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|SIOCGIFFLAGS
suffix:colon
multiline_comment|/* Get interface flags */
id|ifr-&gt;ifr_flags
op_assign
id|dev_get_flags
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SIOCSIFFLAGS
suffix:colon
multiline_comment|/* Set interface flags */
r_return
id|dev_change_flags
c_func
(paren
id|dev
comma
id|ifr-&gt;ifr_flags
)paren
suffix:semicolon
r_case
id|SIOCGIFMETRIC
suffix:colon
multiline_comment|/* Get the metric on the interface&n;&t;&t;&t;&t;&t;   (currently unused) */
id|ifr-&gt;ifr_metric
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SIOCSIFMETRIC
suffix:colon
multiline_comment|/* Set the metric on the interface&n;&t;&t;&t;&t;&t;   (currently unused) */
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
r_case
id|SIOCGIFMTU
suffix:colon
multiline_comment|/* Get the MTU of a device */
id|ifr-&gt;ifr_mtu
op_assign
id|dev-&gt;mtu
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SIOCSIFMTU
suffix:colon
multiline_comment|/* Set the MTU of a device */
r_return
id|dev_set_mtu
c_func
(paren
id|dev
comma
id|ifr-&gt;ifr_mtu
)paren
suffix:semicolon
r_case
id|SIOCGIFHWADDR
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|dev-&gt;addr_len
)paren
id|memset
c_func
(paren
id|ifr-&gt;ifr_hwaddr.sa_data
comma
l_int|0
comma
r_sizeof
id|ifr-&gt;ifr_hwaddr.sa_data
)paren
suffix:semicolon
r_else
id|memcpy
c_func
(paren
id|ifr-&gt;ifr_hwaddr.sa_data
comma
id|dev-&gt;dev_addr
comma
id|min
c_func
(paren
r_sizeof
id|ifr-&gt;ifr_hwaddr.sa_data
comma
(paren
r_int
)paren
id|dev-&gt;addr_len
)paren
)paren
suffix:semicolon
id|ifr-&gt;ifr_hwaddr.sa_family
op_assign
id|dev-&gt;type
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SIOCSIFHWADDR
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|dev-&gt;set_mac_address
)paren
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
r_if
c_cond
(paren
id|ifr-&gt;ifr_hwaddr.sa_family
op_ne
id|dev-&gt;type
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|netif_device_present
c_func
(paren
id|dev
)paren
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|err
op_assign
id|dev
op_member_access_from_pointer
id|set_mac_address
c_func
(paren
id|dev
comma
op_amp
id|ifr-&gt;ifr_hwaddr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|err
)paren
id|notifier_call_chain
c_func
(paren
op_amp
id|netdev_chain
comma
id|NETDEV_CHANGEADDR
comma
id|dev
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
r_case
id|SIOCSIFHWBROADCAST
suffix:colon
r_if
c_cond
(paren
id|ifr-&gt;ifr_hwaddr.sa_family
op_ne
id|dev-&gt;type
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|memcpy
c_func
(paren
id|dev-&gt;broadcast
comma
id|ifr-&gt;ifr_hwaddr.sa_data
comma
id|min
c_func
(paren
r_sizeof
id|ifr-&gt;ifr_hwaddr.sa_data
comma
(paren
r_int
)paren
id|dev-&gt;addr_len
)paren
)paren
suffix:semicolon
id|notifier_call_chain
c_func
(paren
op_amp
id|netdev_chain
comma
id|NETDEV_CHANGEADDR
comma
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SIOCGIFMAP
suffix:colon
id|ifr-&gt;ifr_map.mem_start
op_assign
id|dev-&gt;mem_start
suffix:semicolon
id|ifr-&gt;ifr_map.mem_end
op_assign
id|dev-&gt;mem_end
suffix:semicolon
id|ifr-&gt;ifr_map.base_addr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|ifr-&gt;ifr_map.irq
op_assign
id|dev-&gt;irq
suffix:semicolon
id|ifr-&gt;ifr_map.dma
op_assign
id|dev-&gt;dma
suffix:semicolon
id|ifr-&gt;ifr_map.port
op_assign
id|dev-&gt;if_port
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SIOCSIFMAP
suffix:colon
r_if
c_cond
(paren
id|dev-&gt;set_config
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|netif_device_present
c_func
(paren
id|dev
)paren
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_return
id|dev
op_member_access_from_pointer
id|set_config
c_func
(paren
id|dev
comma
op_amp
id|ifr-&gt;ifr_map
)paren
suffix:semicolon
)brace
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
r_case
id|SIOCADDMULTI
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|dev-&gt;set_multicast_list
op_logical_or
id|ifr-&gt;ifr_hwaddr.sa_family
op_ne
id|AF_UNSPEC
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|netif_device_present
c_func
(paren
id|dev
)paren
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_return
id|dev_mc_add
c_func
(paren
id|dev
comma
id|ifr-&gt;ifr_hwaddr.sa_data
comma
id|dev-&gt;addr_len
comma
l_int|1
)paren
suffix:semicolon
r_case
id|SIOCDELMULTI
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|dev-&gt;set_multicast_list
op_logical_or
id|ifr-&gt;ifr_hwaddr.sa_family
op_ne
id|AF_UNSPEC
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|netif_device_present
c_func
(paren
id|dev
)paren
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_return
id|dev_mc_delete
c_func
(paren
id|dev
comma
id|ifr-&gt;ifr_hwaddr.sa_data
comma
id|dev-&gt;addr_len
comma
l_int|1
)paren
suffix:semicolon
r_case
id|SIOCGIFINDEX
suffix:colon
id|ifr-&gt;ifr_ifindex
op_assign
id|dev-&gt;ifindex
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SIOCGIFTXQLEN
suffix:colon
id|ifr-&gt;ifr_qlen
op_assign
id|dev-&gt;tx_queue_len
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SIOCSIFTXQLEN
suffix:colon
r_if
c_cond
(paren
id|ifr-&gt;ifr_qlen
OL
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|dev-&gt;tx_queue_len
op_assign
id|ifr-&gt;ifr_qlen
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SIOCSIFNAME
suffix:colon
id|ifr-&gt;ifr_newname
(braket
id|IFNAMSIZ
op_minus
l_int|1
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_return
id|dev_change_name
c_func
(paren
id|dev
comma
id|ifr-&gt;ifr_newname
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Unknown or private ioctl&n;&t;&t; */
r_default
suffix:colon
(brace
)brace
r_if
c_cond
(paren
(paren
id|cmd
op_ge
id|SIOCDEVPRIVATE
op_logical_and
id|cmd
op_le
id|SIOCDEVPRIVATE
op_plus
l_int|15
)paren
op_logical_or
id|cmd
op_eq
id|SIOCBONDENSLAVE
op_logical_or
id|cmd
op_eq
id|SIOCBONDRELEASE
op_logical_or
id|cmd
op_eq
id|SIOCBONDSETHWADDR
op_logical_or
id|cmd
op_eq
id|SIOCBONDSLAVEINFOQUERY
op_logical_or
id|cmd
op_eq
id|SIOCBONDINFOQUERY
op_logical_or
id|cmd
op_eq
id|SIOCBONDCHANGEACTIVE
op_logical_or
id|cmd
op_eq
id|SIOCGMIIPHY
op_logical_or
id|cmd
op_eq
id|SIOCGMIIREG
op_logical_or
id|cmd
op_eq
id|SIOCSMIIREG
op_logical_or
id|cmd
op_eq
id|SIOCBRADDIF
op_logical_or
id|cmd
op_eq
id|SIOCBRDELIF
op_logical_or
id|cmd
op_eq
id|SIOCWANDEV
)paren
(brace
id|err
op_assign
op_minus
id|EOPNOTSUPP
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;do_ioctl
)paren
(brace
r_if
c_cond
(paren
id|netif_device_present
c_func
(paren
id|dev
)paren
)paren
id|err
op_assign
id|dev
op_member_access_from_pointer
id|do_ioctl
c_func
(paren
id|dev
comma
id|ifr
comma
id|cmd
)paren
suffix:semicolon
r_else
id|err
op_assign
op_minus
id|ENODEV
suffix:semicolon
)brace
)brace
r_else
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;This function handles all &quot;interface&quot;-type I/O control requests. The actual&n; *&t;&squot;doing&squot; part of this is dev_ifsioc above.&n; */
multiline_comment|/**&n; *&t;dev_ioctl&t;-&t;network device ioctl&n; *&t;@cmd: command to issue&n; *&t;@arg: pointer to a struct ifreq in user space&n; *&n; *&t;Issue ioctl functions to devices. This is normally called by the&n; *&t;user space syscall interfaces but can sometimes be useful for&n; *&t;other purposes. The return value is the return from the syscall if&n; *&t;positive or a negative errno code on error.&n; */
DECL|function|dev_ioctl
r_int
id|dev_ioctl
c_func
(paren
r_int
r_int
id|cmd
comma
r_void
id|__user
op_star
id|arg
)paren
(brace
r_struct
id|ifreq
id|ifr
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_char
op_star
id|colon
suffix:semicolon
multiline_comment|/* One special case: SIOCGIFCONF takes ifconf argument&n;&t;   and requires shared lock, because it sleeps writing&n;&t;   to user space.&n;&t; */
r_if
c_cond
(paren
id|cmd
op_eq
id|SIOCGIFCONF
)paren
(brace
id|rtnl_shlock
c_func
(paren
)paren
suffix:semicolon
id|ret
op_assign
id|dev_ifconf
c_func
(paren
(paren
r_char
id|__user
op_star
)paren
id|arg
)paren
suffix:semicolon
id|rtnl_shunlock
c_func
(paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cmd
op_eq
id|SIOCGIFNAME
)paren
r_return
id|dev_ifname
c_func
(paren
(paren
r_struct
id|ifreq
id|__user
op_star
)paren
id|arg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|ifr
comma
id|arg
comma
r_sizeof
(paren
r_struct
id|ifreq
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|ifr.ifr_name
(braket
id|IFNAMSIZ
op_minus
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
id|colon
op_assign
id|strchr
c_func
(paren
id|ifr.ifr_name
comma
l_char|&squot;:&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|colon
)paren
op_star
id|colon
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; *&t;See which interface the caller is talking about.&n;&t; */
r_switch
c_cond
(paren
id|cmd
)paren
(brace
multiline_comment|/*&n;&t;&t; *&t;These ioctl calls:&n;&t;&t; *&t;- can be done by all.&n;&t;&t; *&t;- atomic and do not require locking.&n;&t;&t; *&t;- return a value&n;&t;&t; */
r_case
id|SIOCGIFFLAGS
suffix:colon
r_case
id|SIOCGIFMETRIC
suffix:colon
r_case
id|SIOCGIFMTU
suffix:colon
r_case
id|SIOCGIFHWADDR
suffix:colon
r_case
id|SIOCGIFSLAVE
suffix:colon
r_case
id|SIOCGIFMAP
suffix:colon
r_case
id|SIOCGIFINDEX
suffix:colon
r_case
id|SIOCGIFTXQLEN
suffix:colon
id|dev_load
c_func
(paren
id|ifr.ifr_name
)paren
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|dev_base_lock
)paren
suffix:semicolon
id|ret
op_assign
id|dev_ifsioc
c_func
(paren
op_amp
id|ifr
comma
id|cmd
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|dev_base_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
(brace
r_if
c_cond
(paren
id|colon
)paren
op_star
id|colon
op_assign
l_char|&squot;:&squot;
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|arg
comma
op_amp
id|ifr
comma
r_sizeof
(paren
r_struct
id|ifreq
)paren
)paren
)paren
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
r_case
id|SIOCETHTOOL
suffix:colon
id|dev_load
c_func
(paren
id|ifr.ifr_name
)paren
suffix:semicolon
id|rtnl_lock
c_func
(paren
)paren
suffix:semicolon
id|ret
op_assign
id|dev_ethtool
c_func
(paren
op_amp
id|ifr
)paren
suffix:semicolon
id|rtnl_unlock
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
(brace
r_if
c_cond
(paren
id|colon
)paren
op_star
id|colon
op_assign
l_char|&squot;:&squot;
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|arg
comma
op_amp
id|ifr
comma
r_sizeof
(paren
r_struct
id|ifreq
)paren
)paren
)paren
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;These ioctl calls:&n;&t;&t; *&t;- require superuser power.&n;&t;&t; *&t;- require strict serialization.&n;&t;&t; *&t;- return a value&n;&t;&t; */
r_case
id|SIOCGMIIPHY
suffix:colon
r_case
id|SIOCGMIIREG
suffix:colon
r_case
id|SIOCSIFNAME
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_NET_ADMIN
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|dev_load
c_func
(paren
id|ifr.ifr_name
)paren
suffix:semicolon
id|rtnl_lock
c_func
(paren
)paren
suffix:semicolon
id|ret
op_assign
id|dev_ifsioc
c_func
(paren
op_amp
id|ifr
comma
id|cmd
)paren
suffix:semicolon
id|rtnl_unlock
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
(brace
r_if
c_cond
(paren
id|colon
)paren
op_star
id|colon
op_assign
l_char|&squot;:&squot;
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|arg
comma
op_amp
id|ifr
comma
r_sizeof
(paren
r_struct
id|ifreq
)paren
)paren
)paren
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;These ioctl calls:&n;&t;&t; *&t;- require superuser power.&n;&t;&t; *&t;- require strict serialization.&n;&t;&t; *&t;- do not return a value&n;&t;&t; */
r_case
id|SIOCSIFFLAGS
suffix:colon
r_case
id|SIOCSIFMETRIC
suffix:colon
r_case
id|SIOCSIFMTU
suffix:colon
r_case
id|SIOCSIFMAP
suffix:colon
r_case
id|SIOCSIFHWADDR
suffix:colon
r_case
id|SIOCSIFSLAVE
suffix:colon
r_case
id|SIOCADDMULTI
suffix:colon
r_case
id|SIOCDELMULTI
suffix:colon
r_case
id|SIOCSIFHWBROADCAST
suffix:colon
r_case
id|SIOCSIFTXQLEN
suffix:colon
r_case
id|SIOCSMIIREG
suffix:colon
r_case
id|SIOCBONDENSLAVE
suffix:colon
r_case
id|SIOCBONDRELEASE
suffix:colon
r_case
id|SIOCBONDSETHWADDR
suffix:colon
r_case
id|SIOCBONDSLAVEINFOQUERY
suffix:colon
r_case
id|SIOCBONDINFOQUERY
suffix:colon
r_case
id|SIOCBONDCHANGEACTIVE
suffix:colon
r_case
id|SIOCBRADDIF
suffix:colon
r_case
id|SIOCBRDELIF
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_NET_ADMIN
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|dev_load
c_func
(paren
id|ifr.ifr_name
)paren
suffix:semicolon
id|rtnl_lock
c_func
(paren
)paren
suffix:semicolon
id|ret
op_assign
id|dev_ifsioc
c_func
(paren
op_amp
id|ifr
comma
id|cmd
)paren
suffix:semicolon
id|rtnl_unlock
c_func
(paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
r_case
id|SIOCGIFMEM
suffix:colon
multiline_comment|/* Get the per device memory space. We can add this but&n;&t;&t;&t; * currently do not support it */
r_case
id|SIOCSIFMEM
suffix:colon
multiline_comment|/* Set the per device memory buffer space.&n;&t;&t;&t; * Not applicable in our case */
r_case
id|SIOCSIFLINK
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Unknown or private ioctl.&n;&t;&t; */
r_default
suffix:colon
(brace
)brace
r_if
c_cond
(paren
id|cmd
op_eq
id|SIOCWANDEV
op_logical_or
(paren
id|cmd
op_ge
id|SIOCDEVPRIVATE
op_logical_and
id|cmd
op_le
id|SIOCDEVPRIVATE
op_plus
l_int|15
)paren
)paren
(brace
id|dev_load
c_func
(paren
id|ifr.ifr_name
)paren
suffix:semicolon
id|rtnl_lock
c_func
(paren
)paren
suffix:semicolon
id|ret
op_assign
id|dev_ifsioc
c_func
(paren
op_amp
id|ifr
comma
id|cmd
)paren
suffix:semicolon
id|rtnl_unlock
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ret
op_logical_and
id|copy_to_user
c_func
(paren
id|arg
comma
op_amp
id|ifr
comma
r_sizeof
(paren
r_struct
id|ifreq
)paren
)paren
)paren
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
macro_line|#ifdef WIRELESS_EXT
multiline_comment|/* Take care of Wireless Extensions */
r_if
c_cond
(paren
id|cmd
op_ge
id|SIOCIWFIRST
op_logical_and
id|cmd
op_le
id|SIOCIWLAST
)paren
(brace
multiline_comment|/* If command is `set a parameter&squot;, or&n;&t;&t;&t;&t; * `get the encoding parameters&squot;, check if&n;&t;&t;&t;&t; * the user has the right to do it */
r_if
c_cond
(paren
id|IW_IS_SET
c_func
(paren
id|cmd
)paren
op_logical_or
id|cmd
op_eq
id|SIOCGIWENCODE
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_NET_ADMIN
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
id|dev_load
c_func
(paren
id|ifr.ifr_name
)paren
suffix:semicolon
id|rtnl_lock
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Follow me in net/core/wireless.c */
id|ret
op_assign
id|wireless_process_ioctl
c_func
(paren
op_amp
id|ifr
comma
id|cmd
)paren
suffix:semicolon
id|rtnl_unlock
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IW_IS_GET
c_func
(paren
id|cmd
)paren
op_logical_and
id|copy_to_user
c_func
(paren
id|arg
comma
op_amp
id|ifr
comma
r_sizeof
(paren
r_struct
id|ifreq
)paren
)paren
)paren
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
macro_line|#endif&t;/* WIRELESS_EXT */
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; *&t;dev_new_index&t;-&t;allocate an ifindex&n; *&n; *&t;Returns a suitable unique value for a new device interface&n; *&t;number.  The caller must hold the rtnl semaphore or the&n; *&t;dev_base_lock to be sure it remains unique.&n; */
DECL|function|dev_new_index
r_static
r_int
id|dev_new_index
c_func
(paren
r_void
)paren
(brace
r_static
r_int
id|ifindex
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
op_increment
id|ifindex
op_le
l_int|0
)paren
id|ifindex
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|__dev_get_by_index
c_func
(paren
id|ifindex
)paren
)paren
r_return
id|ifindex
suffix:semicolon
)brace
)brace
DECL|variable|dev_boot_phase
r_static
r_int
id|dev_boot_phase
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Delayed registration/unregisteration */
DECL|variable|net_todo_list_lock
r_static
id|spinlock_t
id|net_todo_list_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
DECL|variable|net_todo_list
r_static
r_struct
id|list_head
id|net_todo_list
op_assign
id|LIST_HEAD_INIT
c_func
(paren
id|net_todo_list
)paren
suffix:semicolon
DECL|function|net_set_todo
r_static
r_inline
r_void
id|net_set_todo
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
id|spin_lock
c_func
(paren
op_amp
id|net_todo_list_lock
)paren
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|dev-&gt;todo_list
comma
op_amp
id|net_todo_list
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|net_todo_list_lock
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;register_netdevice&t;- register a network device&n; *&t;@dev: device to register&n; *&n; *&t;Take a completed network device structure and add it to the kernel&n; *&t;interfaces. A %NETDEV_REGISTER message is sent to the netdev notifier&n; *&t;chain. 0 is returned on success. A negative errno code is returned&n; *&t;on a failure to set up the device, or if the name is a duplicate.&n; *&n; *&t;Callers must hold the rtnl semaphore. You may want&n; *&t;register_netdev() instead of this.&n; *&n; *&t;BUGS:&n; *&t;The locking appears insufficient to guarantee two parallel registers&n; *&t;will not get the same name.&n; */
DECL|function|register_netdevice
r_int
id|register_netdevice
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|hlist_head
op_star
id|head
suffix:semicolon
r_struct
id|hlist_node
op_star
id|p
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|BUG_ON
c_func
(paren
id|dev_boot_phase
)paren
suffix:semicolon
id|ASSERT_RTNL
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* When net_device&squot;s are persistent, this will be fatal. */
id|BUG_ON
c_func
(paren
id|dev-&gt;reg_state
op_ne
id|NETREG_UNINITIALIZED
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|dev-&gt;queue_lock
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|dev-&gt;xmit_lock
)paren
suffix:semicolon
id|dev-&gt;xmit_lock_owner
op_assign
op_minus
l_int|1
suffix:semicolon
macro_line|#ifdef CONFIG_NET_CLS_ACT
id|spin_lock_init
c_func
(paren
op_amp
id|dev-&gt;ingress_lock
)paren
suffix:semicolon
macro_line|#endif
id|ret
op_assign
id|alloc_divert_blk
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_goto
id|out
suffix:semicolon
id|dev-&gt;iflink
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* Init, if this function is available */
r_if
c_cond
(paren
id|dev-&gt;init
)paren
(brace
id|ret
op_assign
id|dev
op_member_access_from_pointer
id|init
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
r_if
c_cond
(paren
id|ret
OG
l_int|0
)paren
id|ret
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|out_err
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|dev_valid_name
c_func
(paren
id|dev-&gt;name
)paren
)paren
(brace
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|out_err
suffix:semicolon
)brace
id|dev-&gt;ifindex
op_assign
id|dev_new_index
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;iflink
op_eq
op_minus
l_int|1
)paren
id|dev-&gt;iflink
op_assign
id|dev-&gt;ifindex
suffix:semicolon
multiline_comment|/* Check for existence of name */
id|head
op_assign
id|dev_name_hash
c_func
(paren
id|dev-&gt;name
)paren
suffix:semicolon
id|hlist_for_each
c_func
(paren
id|p
comma
id|head
)paren
(brace
r_struct
id|net_device
op_star
id|d
op_assign
id|hlist_entry
c_func
(paren
id|p
comma
r_struct
id|net_device
comma
id|name_hlist
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|d-&gt;name
comma
id|dev-&gt;name
comma
id|IFNAMSIZ
)paren
)paren
(brace
id|ret
op_assign
op_minus
id|EEXIST
suffix:semicolon
r_goto
id|out_err
suffix:semicolon
)brace
)brace
multiline_comment|/* Fix illegal SG+CSUM combinations. */
r_if
c_cond
(paren
(paren
id|dev-&gt;features
op_amp
id|NETIF_F_SG
)paren
op_logical_and
op_logical_neg
(paren
id|dev-&gt;features
op_amp
(paren
id|NETIF_F_IP_CSUM
op_or
id|NETIF_F_NO_CSUM
op_or
id|NETIF_F_HW_CSUM
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: Dropping NETIF_F_SG since no checksum feature.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|dev-&gt;features
op_and_assign
op_complement
id|NETIF_F_SG
suffix:semicolon
)brace
multiline_comment|/* TSO requires that SG is present as well. */
r_if
c_cond
(paren
(paren
id|dev-&gt;features
op_amp
id|NETIF_F_TSO
)paren
op_logical_and
op_logical_neg
(paren
id|dev-&gt;features
op_amp
id|NETIF_F_SG
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: Dropping NETIF_F_TSO since no SG feature.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|dev-&gt;features
op_and_assign
op_complement
id|NETIF_F_TSO
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;nil rebuild_header routine,&n;&t; *&t;that should be never called and used as just bug trap.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|dev-&gt;rebuild_header
)paren
id|dev-&gt;rebuild_header
op_assign
id|default_rebuild_header
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Default initial state at registry is that the&n;&t; *&t;device is present.&n;&t; */
id|set_bit
c_func
(paren
id|__LINK_STATE_PRESENT
comma
op_amp
id|dev-&gt;state
)paren
suffix:semicolon
id|dev-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|dev_init_scheduler
c_func
(paren
id|dev
)paren
suffix:semicolon
id|write_lock_bh
c_func
(paren
op_amp
id|dev_base_lock
)paren
suffix:semicolon
op_star
id|dev_tail
op_assign
id|dev
suffix:semicolon
id|dev_tail
op_assign
op_amp
id|dev-&gt;next
suffix:semicolon
id|hlist_add_head
c_func
(paren
op_amp
id|dev-&gt;name_hlist
comma
id|head
)paren
suffix:semicolon
id|hlist_add_head
c_func
(paren
op_amp
id|dev-&gt;index_hlist
comma
id|dev_index_hash
c_func
(paren
id|dev-&gt;ifindex
)paren
)paren
suffix:semicolon
id|dev_hold
c_func
(paren
id|dev
)paren
suffix:semicolon
id|dev-&gt;reg_state
op_assign
id|NETREG_REGISTERING
suffix:semicolon
id|write_unlock_bh
c_func
(paren
op_amp
id|dev_base_lock
)paren
suffix:semicolon
multiline_comment|/* Notify protocols, that a new device appeared. */
id|notifier_call_chain
c_func
(paren
op_amp
id|netdev_chain
comma
id|NETDEV_REGISTER
comma
id|dev
)paren
suffix:semicolon
multiline_comment|/* Finish registration after unlock */
id|net_set_todo
c_func
(paren
id|dev
)paren
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
id|out
suffix:colon
r_return
id|ret
suffix:semicolon
id|out_err
suffix:colon
id|free_divert_blk
c_func
(paren
id|dev
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;register_netdev&t;- register a network device&n; *&t;@dev: device to register&n; *&n; *&t;Take a completed network device structure and add it to the kernel&n; *&t;interfaces. A %NETDEV_REGISTER message is sent to the netdev notifier&n; *&t;chain. 0 is returned on success. A negative errno code is returned&n; *&t;on a failure to set up the device, or if the name is a duplicate.&n; *&n; *&t;This is a wrapper around register_netdev that takes the rtnl semaphore&n; *&t;and expands the device name if you passed a format string to&n; *&t;alloc_netdev.&n; */
DECL|function|register_netdev
r_int
id|register_netdev
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_int
id|err
suffix:semicolon
id|rtnl_lock
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If the name is a format string the caller wants us to do a&n;&t; * name allocation.&n;&t; */
r_if
c_cond
(paren
id|strchr
c_func
(paren
id|dev-&gt;name
comma
l_char|&squot;%&squot;
)paren
)paren
(brace
id|err
op_assign
id|dev_alloc_name
c_func
(paren
id|dev
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Back compatibility hook. Kill this one in 2.5&n;&t; */
r_if
c_cond
(paren
id|dev-&gt;name
(braket
l_int|0
)braket
op_eq
l_int|0
op_logical_or
id|dev-&gt;name
(braket
l_int|0
)braket
op_eq
l_char|&squot; &squot;
)paren
(brace
id|err
op_assign
id|dev_alloc_name
c_func
(paren
id|dev
comma
l_string|&quot;eth%d&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_goto
id|out
suffix:semicolon
)brace
id|err
op_assign
id|register_netdevice
c_func
(paren
id|dev
)paren
suffix:semicolon
id|out
suffix:colon
id|rtnl_unlock
c_func
(paren
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|variable|register_netdev
id|EXPORT_SYMBOL
c_func
(paren
id|register_netdev
)paren
suffix:semicolon
multiline_comment|/*&n; * netdev_wait_allrefs - wait until all references are gone.&n; *&n; * This is called when unregistering network devices.&n; *&n; * Any protocol or device that holds a reference should register&n; * for netdevice notification, and cleanup and put back the&n; * reference if they receive an UNREGISTER event.&n; * We can get stuck here if buggy protocols don&squot;t correctly&n; * call dev_put. &n; */
DECL|function|netdev_wait_allrefs
r_static
r_void
id|netdev_wait_allrefs
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_int
r_int
id|rebroadcast_time
comma
id|warning_time
suffix:semicolon
id|rebroadcast_time
op_assign
id|warning_time
op_assign
id|jiffies
suffix:semicolon
r_while
c_loop
(paren
id|atomic_read
c_func
(paren
op_amp
id|dev-&gt;refcnt
)paren
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|time_after
c_func
(paren
id|jiffies
comma
id|rebroadcast_time
op_plus
l_int|1
op_star
id|HZ
)paren
)paren
(brace
id|rtnl_shlock
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Rebroadcast unregister notification */
id|notifier_call_chain
c_func
(paren
op_amp
id|netdev_chain
comma
id|NETDEV_UNREGISTER
comma
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|__LINK_STATE_LINKWATCH_PENDING
comma
op_amp
id|dev-&gt;state
)paren
)paren
(brace
multiline_comment|/* We must not have linkwatch events&n;&t;&t;&t;&t; * pending on unregister. If this&n;&t;&t;&t;&t; * happens, we simply run the queue&n;&t;&t;&t;&t; * unscheduled, resulting in a noop&n;&t;&t;&t;&t; * for this device.&n;&t;&t;&t;&t; */
id|linkwatch_run_queue
c_func
(paren
)paren
suffix:semicolon
)brace
id|rtnl_shunlock
c_func
(paren
)paren
suffix:semicolon
id|rebroadcast_time
op_assign
id|jiffies
suffix:semicolon
)brace
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|schedule_timeout
c_func
(paren
id|HZ
op_div
l_int|4
)paren
suffix:semicolon
r_if
c_cond
(paren
id|time_after
c_func
(paren
id|jiffies
comma
id|warning_time
op_plus
l_int|10
op_star
id|HZ
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_EMERG
l_string|&quot;unregister_netdevice: &quot;
l_string|&quot;waiting for %s to become free. Usage &quot;
l_string|&quot;count = %d&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|atomic_read
c_func
(paren
op_amp
id|dev-&gt;refcnt
)paren
)paren
suffix:semicolon
id|warning_time
op_assign
id|jiffies
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* The sequence is:&n; *&n; *&t;rtnl_lock();&n; *&t;...&n; *&t;register_netdevice(x1);&n; *&t;register_netdevice(x2);&n; *&t;...&n; *&t;unregister_netdevice(y1);&n; *&t;unregister_netdevice(y2);&n; *      ...&n; *&t;rtnl_unlock();&n; *&t;free_netdev(y1);&n; *&t;free_netdev(y2);&n; *&n; * We are invoked by rtnl_unlock() after it drops the semaphore.&n; * This allows us to deal with problems:&n; * 1) We can create/delete sysfs objects which invoke hotplug&n; *    without deadlocking with linkwatch via keventd.&n; * 2) Since we run with the RTNL semaphore not held, we can sleep&n; *    safely in order to wait for the netdev refcnt to drop to zero.&n; */
r_static
id|DECLARE_MUTEX
c_func
(paren
id|net_todo_run_mutex
)paren
suffix:semicolon
DECL|function|netdev_run_todo
r_void
id|netdev_run_todo
c_func
(paren
r_void
)paren
(brace
r_struct
id|list_head
id|list
op_assign
id|LIST_HEAD_INIT
c_func
(paren
id|list
)paren
suffix:semicolon
r_int
id|err
suffix:semicolon
multiline_comment|/* Need to guard against multiple cpu&squot;s getting out of order. */
id|down
c_func
(paren
op_amp
id|net_todo_run_mutex
)paren
suffix:semicolon
multiline_comment|/* Not safe to do outside the semaphore.  We must not return&n;&t; * until all unregister events invoked by the local processor&n;&t; * have been completed (either by this todo run, or one on&n;&t; * another cpu).&n;&t; */
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|net_todo_list
)paren
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* Snapshot list, allow later requests */
id|spin_lock
c_func
(paren
op_amp
id|net_todo_list_lock
)paren
suffix:semicolon
id|list_splice_init
c_func
(paren
op_amp
id|net_todo_list
comma
op_amp
id|list
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|net_todo_list_lock
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|list
)paren
)paren
(brace
r_struct
id|net_device
op_star
id|dev
op_assign
id|list_entry
c_func
(paren
id|list.next
comma
r_struct
id|net_device
comma
id|todo_list
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|dev-&gt;todo_list
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|dev-&gt;reg_state
)paren
(brace
r_case
id|NETREG_REGISTERING
suffix:colon
id|err
op_assign
id|netdev_register_sysfs
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: failed sysfs registration (%d)&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|err
)paren
suffix:semicolon
id|dev-&gt;reg_state
op_assign
id|NETREG_REGISTERED
suffix:semicolon
r_break
suffix:semicolon
r_case
id|NETREG_UNREGISTERING
suffix:colon
id|netdev_unregister_sysfs
c_func
(paren
id|dev
)paren
suffix:semicolon
id|dev-&gt;reg_state
op_assign
id|NETREG_UNREGISTERED
suffix:semicolon
id|netdev_wait_allrefs
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* paranoia */
id|BUG_ON
c_func
(paren
id|atomic_read
c_func
(paren
op_amp
id|dev-&gt;refcnt
)paren
)paren
suffix:semicolon
id|BUG_TRAP
c_func
(paren
op_logical_neg
id|dev-&gt;ip_ptr
)paren
suffix:semicolon
id|BUG_TRAP
c_func
(paren
op_logical_neg
id|dev-&gt;ip6_ptr
)paren
suffix:semicolon
id|BUG_TRAP
c_func
(paren
op_logical_neg
id|dev-&gt;dn_ptr
)paren
suffix:semicolon
multiline_comment|/* It must be the very last action, &n;&t;&t;&t; * after this &squot;dev&squot; may point to freed up memory.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|dev-&gt;destructor
)paren
id|dev
op_member_access_from_pointer
id|destructor
c_func
(paren
id|dev
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;network todo &squot;%s&squot; but state %d&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|dev-&gt;reg_state
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|out
suffix:colon
id|up
c_func
(paren
op_amp
id|net_todo_run_mutex
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;alloc_netdev - allocate network device&n; *&t;@sizeof_priv:&t;size of private data to allocate space for&n; *&t;@name:&t;&t;device name format string&n; *&t;@setup:&t;&t;callback to initialize device&n; *&n; *&t;Allocates a struct net_device with private data area for driver use&n; *&t;and performs basic initialization.&n; */
DECL|function|alloc_netdev
r_struct
id|net_device
op_star
id|alloc_netdev
c_func
(paren
r_int
id|sizeof_priv
comma
r_const
r_char
op_star
id|name
comma
r_void
(paren
op_star
id|setup
)paren
(paren
r_struct
id|net_device
op_star
)paren
)paren
(brace
r_void
op_star
id|p
suffix:semicolon
r_struct
id|net_device
op_star
id|dev
suffix:semicolon
r_int
id|alloc_size
suffix:semicolon
multiline_comment|/* ensure 32-byte alignment of both the device and private area */
id|alloc_size
op_assign
(paren
r_sizeof
(paren
op_star
id|dev
)paren
op_plus
id|NETDEV_ALIGN_CONST
)paren
op_amp
op_complement
id|NETDEV_ALIGN_CONST
suffix:semicolon
id|alloc_size
op_add_assign
id|sizeof_priv
op_plus
id|NETDEV_ALIGN_CONST
suffix:semicolon
id|p
op_assign
id|kmalloc
c_func
(paren
id|alloc_size
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;alloc_dev: Unable to allocate device.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|memset
c_func
(paren
id|p
comma
l_int|0
comma
id|alloc_size
)paren
suffix:semicolon
id|dev
op_assign
(paren
r_struct
id|net_device
op_star
)paren
(paren
(paren
(paren
r_int
)paren
id|p
op_plus
id|NETDEV_ALIGN_CONST
)paren
op_amp
op_complement
id|NETDEV_ALIGN_CONST
)paren
suffix:semicolon
id|dev-&gt;padded
op_assign
(paren
r_char
op_star
)paren
id|dev
op_minus
(paren
r_char
op_star
)paren
id|p
suffix:semicolon
r_if
c_cond
(paren
id|sizeof_priv
)paren
id|dev-&gt;priv
op_assign
id|netdev_priv
c_func
(paren
id|dev
)paren
suffix:semicolon
id|setup
c_func
(paren
id|dev
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|dev-&gt;name
comma
id|name
)paren
suffix:semicolon
r_return
id|dev
suffix:semicolon
)brace
DECL|variable|alloc_netdev
id|EXPORT_SYMBOL
c_func
(paren
id|alloc_netdev
)paren
suffix:semicolon
multiline_comment|/**&n; *&t;free_netdev - free network device&n; *&t;@dev: device&n; *&n; *&t;This function does the last stage of destroying an allocated device &n; * &t;interface. The reference to the device object is released.  &n; *&t;If this is the last reference then it will be freed.&n; */
DECL|function|free_netdev
r_void
id|free_netdev
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
macro_line|#ifdef CONFIG_SYSFS
multiline_comment|/*  Compatiablity with error handling in drivers */
r_if
c_cond
(paren
id|dev-&gt;reg_state
op_eq
id|NETREG_UNINITIALIZED
)paren
(brace
id|kfree
c_func
(paren
(paren
r_char
op_star
)paren
id|dev
op_minus
id|dev-&gt;padded
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|BUG_ON
c_func
(paren
id|dev-&gt;reg_state
op_ne
id|NETREG_UNREGISTERED
)paren
suffix:semicolon
id|dev-&gt;reg_state
op_assign
id|NETREG_RELEASED
suffix:semicolon
multiline_comment|/* will free via class release */
id|class_device_put
c_func
(paren
op_amp
id|dev-&gt;class_dev
)paren
suffix:semicolon
macro_line|#else
id|kfree
c_func
(paren
(paren
r_char
op_star
)paren
id|dev
op_minus
id|dev-&gt;padded
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/* Synchronize with packet receive processing. */
DECL|function|synchronize_net
r_void
id|synchronize_net
c_func
(paren
r_void
)paren
(brace
id|might_sleep
c_func
(paren
)paren
suffix:semicolon
id|synchronize_kernel
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;unregister_netdevice - remove device from the kernel&n; *&t;@dev: device&n; *&n; *&t;This function shuts down a device interface and removes it&n; *&t;from the kernel tables. On success 0 is returned, on a failure&n; *&t;a negative errno code is returned.&n; *&n; *&t;Callers must hold the rtnl semaphore.  You may want&n; *&t;unregister_netdev() instead of this.&n; */
DECL|function|unregister_netdevice
r_int
id|unregister_netdevice
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|net_device
op_star
id|d
comma
op_star
op_star
id|dp
suffix:semicolon
id|BUG_ON
c_func
(paren
id|dev_boot_phase
)paren
suffix:semicolon
id|ASSERT_RTNL
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Some devices call without registering for initialization unwind. */
r_if
c_cond
(paren
id|dev-&gt;reg_state
op_eq
id|NETREG_UNINITIALIZED
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;unregister_netdevice: device %s/%p never &quot;
l_string|&quot;was registered&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|dev
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|BUG_ON
c_func
(paren
id|dev-&gt;reg_state
op_ne
id|NETREG_REGISTERED
)paren
suffix:semicolon
multiline_comment|/* If device is running, close it first. */
r_if
c_cond
(paren
id|dev-&gt;flags
op_amp
id|IFF_UP
)paren
id|dev_close
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* And unlink it from device chain. */
r_for
c_loop
(paren
id|dp
op_assign
op_amp
id|dev_base
suffix:semicolon
(paren
id|d
op_assign
op_star
id|dp
)paren
op_ne
l_int|NULL
suffix:semicolon
id|dp
op_assign
op_amp
id|d-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|d
op_eq
id|dev
)paren
(brace
id|write_lock_bh
c_func
(paren
op_amp
id|dev_base_lock
)paren
suffix:semicolon
id|hlist_del
c_func
(paren
op_amp
id|dev-&gt;name_hlist
)paren
suffix:semicolon
id|hlist_del
c_func
(paren
op_amp
id|dev-&gt;index_hlist
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev_tail
op_eq
op_amp
id|dev-&gt;next
)paren
id|dev_tail
op_assign
id|dp
suffix:semicolon
op_star
id|dp
op_assign
id|d-&gt;next
suffix:semicolon
id|write_unlock_bh
c_func
(paren
op_amp
id|dev_base_lock
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|d
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;unregister net_device: &squot;%s&squot; not found&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|dev-&gt;reg_state
op_assign
id|NETREG_UNREGISTERING
suffix:semicolon
id|synchronize_net
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Shutdown queueing discipline. */
id|dev_shutdown
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Notify protocols, that we are about to destroy&n;&t;   this device. They should clean all the things.&n;&t;*/
id|notifier_call_chain
c_func
(paren
op_amp
id|netdev_chain
comma
id|NETDEV_UNREGISTER
comma
id|dev
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Flush the multicast chain&n;&t; */
id|dev_mc_discard
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;uninit
)paren
id|dev
op_member_access_from_pointer
id|uninit
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Notifier chain MUST detach us from master device. */
id|BUG_TRAP
c_func
(paren
op_logical_neg
id|dev-&gt;master
)paren
suffix:semicolon
id|free_divert_blk
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Finish processing unregister after unlock */
id|net_set_todo
c_func
(paren
id|dev
)paren
suffix:semicolon
id|synchronize_net
c_func
(paren
)paren
suffix:semicolon
id|dev_put
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;unregister_netdev - remove device from the kernel&n; *&t;@dev: device&n; *&n; *&t;This function shuts down a device interface and removes it&n; *&t;from the kernel tables. On success 0 is returned, on a failure&n; *&t;a negative errno code is returned.&n; *&n; *&t;This is just a wrapper for unregister_netdevice that takes&n; *&t;the rtnl semaphore.  In general you want to use this and not&n; *&t;unregister_netdevice.&n; */
DECL|function|unregister_netdev
r_void
id|unregister_netdev
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
id|rtnl_lock
c_func
(paren
)paren
suffix:semicolon
id|unregister_netdevice
c_func
(paren
id|dev
)paren
suffix:semicolon
id|rtnl_unlock
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|variable|unregister_netdev
id|EXPORT_SYMBOL
c_func
(paren
id|unregister_netdev
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_HOTPLUG_CPU
DECL|function|dev_cpu_callback
r_static
r_int
id|dev_cpu_callback
c_func
(paren
r_struct
id|notifier_block
op_star
id|nfb
comma
r_int
r_int
id|action
comma
r_void
op_star
id|ocpu
)paren
(brace
r_struct
id|sk_buff
op_star
op_star
id|list_skb
suffix:semicolon
r_struct
id|net_device
op_star
op_star
id|list_net
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_int
r_int
id|cpu
comma
id|oldcpu
op_assign
(paren
r_int
r_int
)paren
id|ocpu
suffix:semicolon
r_struct
id|softnet_data
op_star
id|sd
comma
op_star
id|oldsd
suffix:semicolon
r_if
c_cond
(paren
id|action
op_ne
id|CPU_DEAD
)paren
r_return
id|NOTIFY_OK
suffix:semicolon
id|local_irq_disable
c_func
(paren
)paren
suffix:semicolon
id|cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
id|sd
op_assign
op_amp
id|per_cpu
c_func
(paren
id|softnet_data
comma
id|cpu
)paren
suffix:semicolon
id|oldsd
op_assign
op_amp
id|per_cpu
c_func
(paren
id|softnet_data
comma
id|oldcpu
)paren
suffix:semicolon
multiline_comment|/* Find end of our completion_queue. */
id|list_skb
op_assign
op_amp
id|sd-&gt;completion_queue
suffix:semicolon
r_while
c_loop
(paren
op_star
id|list_skb
)paren
id|list_skb
op_assign
op_amp
(paren
op_star
id|list_skb
)paren
op_member_access_from_pointer
id|next
suffix:semicolon
multiline_comment|/* Append completion queue from offline CPU. */
op_star
id|list_skb
op_assign
id|oldsd-&gt;completion_queue
suffix:semicolon
id|oldsd-&gt;completion_queue
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Find end of our output_queue. */
id|list_net
op_assign
op_amp
id|sd-&gt;output_queue
suffix:semicolon
r_while
c_loop
(paren
op_star
id|list_net
)paren
id|list_net
op_assign
op_amp
(paren
op_star
id|list_net
)paren
op_member_access_from_pointer
id|next_sched
suffix:semicolon
multiline_comment|/* Append output queue from offline CPU. */
op_star
id|list_net
op_assign
id|oldsd-&gt;output_queue
suffix:semicolon
id|oldsd-&gt;output_queue
op_assign
l_int|NULL
suffix:semicolon
id|raise_softirq_irqoff
c_func
(paren
id|NET_TX_SOFTIRQ
)paren
suffix:semicolon
id|local_irq_enable
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Process offline CPU&squot;s input_pkt_queue */
r_while
c_loop
(paren
(paren
id|skb
op_assign
id|__skb_dequeue
c_func
(paren
op_amp
id|oldsd-&gt;input_pkt_queue
)paren
)paren
)paren
id|netif_rx
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
id|NOTIFY_OK
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_HOTPLUG_CPU */
multiline_comment|/*&n; *&t;Initialize the DEV module. At boot time this walks the device list and&n; *&t;unhooks any devices that fail to initialise (normally hardware not&n; *&t;present) and leaves us with a valid list of present and active devices.&n; *&n; */
multiline_comment|/*&n; *       This is called single threaded during boot, so no need&n; *       to take the rtnl semaphore.&n; */
DECL|function|net_dev_init
r_static
r_int
id|__init
id|net_dev_init
c_func
(paren
r_void
)paren
(brace
r_int
id|i
comma
id|rc
op_assign
op_minus
id|ENOMEM
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|dev_boot_phase
)paren
suffix:semicolon
id|net_random_init
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev_proc_init
c_func
(paren
)paren
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|netdev_sysfs_init
c_func
(paren
)paren
)paren
r_goto
id|out
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|ptype_all
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
id|i
op_increment
)paren
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|ptype_base
(braket
id|i
)braket
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ARRAY_SIZE
c_func
(paren
id|dev_name_head
)paren
suffix:semicolon
id|i
op_increment
)paren
id|INIT_HLIST_HEAD
c_func
(paren
op_amp
id|dev_name_head
(braket
id|i
)braket
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ARRAY_SIZE
c_func
(paren
id|dev_index_head
)paren
suffix:semicolon
id|i
op_increment
)paren
id|INIT_HLIST_HEAD
c_func
(paren
op_amp
id|dev_index_head
(braket
id|i
)braket
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Initialise the packet receive queues.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_CPUS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|softnet_data
op_star
id|queue
suffix:semicolon
id|queue
op_assign
op_amp
id|per_cpu
c_func
(paren
id|softnet_data
comma
id|i
)paren
suffix:semicolon
id|skb_queue_head_init
c_func
(paren
op_amp
id|queue-&gt;input_pkt_queue
)paren
suffix:semicolon
id|queue-&gt;throttle
op_assign
l_int|0
suffix:semicolon
id|queue-&gt;cng_level
op_assign
l_int|0
suffix:semicolon
id|queue-&gt;avg_blog
op_assign
l_int|10
suffix:semicolon
multiline_comment|/* arbitrary non-zero */
id|queue-&gt;completion_queue
op_assign
l_int|NULL
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|queue-&gt;poll_list
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|__LINK_STATE_START
comma
op_amp
id|queue-&gt;backlog_dev.state
)paren
suffix:semicolon
id|queue-&gt;backlog_dev.weight
op_assign
id|weight_p
suffix:semicolon
id|queue-&gt;backlog_dev.poll
op_assign
id|process_backlog
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|queue-&gt;backlog_dev.refcnt
comma
l_int|1
)paren
suffix:semicolon
)brace
macro_line|#ifdef OFFLINE_SAMPLE
id|samp_timer.expires
op_assign
id|jiffies
op_plus
(paren
l_int|10
op_star
id|HZ
)paren
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|samp_timer
)paren
suffix:semicolon
macro_line|#endif
id|dev_boot_phase
op_assign
l_int|0
suffix:semicolon
id|open_softirq
c_func
(paren
id|NET_TX_SOFTIRQ
comma
id|net_tx_action
comma
l_int|NULL
)paren
suffix:semicolon
id|open_softirq
c_func
(paren
id|NET_RX_SOFTIRQ
comma
id|net_rx_action
comma
l_int|NULL
)paren
suffix:semicolon
id|hotcpu_notifier
c_func
(paren
id|dev_cpu_callback
comma
l_int|0
)paren
suffix:semicolon
id|dst_init
c_func
(paren
)paren
suffix:semicolon
id|dev_mcast_init
c_func
(paren
)paren
suffix:semicolon
id|rc
op_assign
l_int|0
suffix:semicolon
id|out
suffix:colon
r_return
id|rc
suffix:semicolon
)brace
DECL|variable|net_dev_init
id|subsys_initcall
c_func
(paren
id|net_dev_init
)paren
suffix:semicolon
DECL|variable|__dev_get_by_index
id|EXPORT_SYMBOL
c_func
(paren
id|__dev_get_by_index
)paren
suffix:semicolon
DECL|variable|__dev_get_by_name
id|EXPORT_SYMBOL
c_func
(paren
id|__dev_get_by_name
)paren
suffix:semicolon
DECL|variable|__dev_remove_pack
id|EXPORT_SYMBOL
c_func
(paren
id|__dev_remove_pack
)paren
suffix:semicolon
DECL|variable|__skb_linearize
id|EXPORT_SYMBOL
c_func
(paren
id|__skb_linearize
)paren
suffix:semicolon
DECL|variable|dev_add_pack
id|EXPORT_SYMBOL
c_func
(paren
id|dev_add_pack
)paren
suffix:semicolon
DECL|variable|dev_alloc_name
id|EXPORT_SYMBOL
c_func
(paren
id|dev_alloc_name
)paren
suffix:semicolon
DECL|variable|dev_close
id|EXPORT_SYMBOL
c_func
(paren
id|dev_close
)paren
suffix:semicolon
DECL|variable|dev_get_by_flags
id|EXPORT_SYMBOL
c_func
(paren
id|dev_get_by_flags
)paren
suffix:semicolon
DECL|variable|dev_get_by_index
id|EXPORT_SYMBOL
c_func
(paren
id|dev_get_by_index
)paren
suffix:semicolon
DECL|variable|dev_get_by_name
id|EXPORT_SYMBOL
c_func
(paren
id|dev_get_by_name
)paren
suffix:semicolon
DECL|variable|dev_ioctl
id|EXPORT_SYMBOL
c_func
(paren
id|dev_ioctl
)paren
suffix:semicolon
DECL|variable|dev_open
id|EXPORT_SYMBOL
c_func
(paren
id|dev_open
)paren
suffix:semicolon
DECL|variable|dev_queue_xmit
id|EXPORT_SYMBOL
c_func
(paren
id|dev_queue_xmit
)paren
suffix:semicolon
DECL|variable|dev_remove_pack
id|EXPORT_SYMBOL
c_func
(paren
id|dev_remove_pack
)paren
suffix:semicolon
DECL|variable|dev_set_allmulti
id|EXPORT_SYMBOL
c_func
(paren
id|dev_set_allmulti
)paren
suffix:semicolon
DECL|variable|dev_set_promiscuity
id|EXPORT_SYMBOL
c_func
(paren
id|dev_set_promiscuity
)paren
suffix:semicolon
DECL|variable|dev_change_flags
id|EXPORT_SYMBOL
c_func
(paren
id|dev_change_flags
)paren
suffix:semicolon
DECL|variable|dev_set_mtu
id|EXPORT_SYMBOL
c_func
(paren
id|dev_set_mtu
)paren
suffix:semicolon
DECL|variable|free_netdev
id|EXPORT_SYMBOL
c_func
(paren
id|free_netdev
)paren
suffix:semicolon
DECL|variable|netdev_boot_setup_check
id|EXPORT_SYMBOL
c_func
(paren
id|netdev_boot_setup_check
)paren
suffix:semicolon
DECL|variable|netdev_set_master
id|EXPORT_SYMBOL
c_func
(paren
id|netdev_set_master
)paren
suffix:semicolon
DECL|variable|netdev_state_change
id|EXPORT_SYMBOL
c_func
(paren
id|netdev_state_change
)paren
suffix:semicolon
DECL|variable|netif_receive_skb
id|EXPORT_SYMBOL
c_func
(paren
id|netif_receive_skb
)paren
suffix:semicolon
DECL|variable|netif_rx
id|EXPORT_SYMBOL
c_func
(paren
id|netif_rx
)paren
suffix:semicolon
DECL|variable|register_gifconf
id|EXPORT_SYMBOL
c_func
(paren
id|register_gifconf
)paren
suffix:semicolon
DECL|variable|register_netdevice
id|EXPORT_SYMBOL
c_func
(paren
id|register_netdevice
)paren
suffix:semicolon
DECL|variable|register_netdevice_notifier
id|EXPORT_SYMBOL
c_func
(paren
id|register_netdevice_notifier
)paren
suffix:semicolon
DECL|variable|skb_checksum_help
id|EXPORT_SYMBOL
c_func
(paren
id|skb_checksum_help
)paren
suffix:semicolon
DECL|variable|synchronize_net
id|EXPORT_SYMBOL
c_func
(paren
id|synchronize_net
)paren
suffix:semicolon
DECL|variable|unregister_netdevice
id|EXPORT_SYMBOL
c_func
(paren
id|unregister_netdevice
)paren
suffix:semicolon
DECL|variable|unregister_netdevice_notifier
id|EXPORT_SYMBOL
c_func
(paren
id|unregister_netdevice_notifier
)paren
suffix:semicolon
DECL|variable|net_enable_timestamp
id|EXPORT_SYMBOL
c_func
(paren
id|net_enable_timestamp
)paren
suffix:semicolon
DECL|variable|net_disable_timestamp
id|EXPORT_SYMBOL
c_func
(paren
id|net_disable_timestamp
)paren
suffix:semicolon
macro_line|#if defined(CONFIG_BRIDGE) || defined(CONFIG_BRIDGE_MODULE)
DECL|variable|br_handle_frame_hook
id|EXPORT_SYMBOL
c_func
(paren
id|br_handle_frame_hook
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_KMOD
DECL|variable|dev_load
id|EXPORT_SYMBOL
c_func
(paren
id|dev_load
)paren
suffix:semicolon
macro_line|#endif
DECL|variable|softnet_data
id|EXPORT_PER_CPU_SYMBOL
c_func
(paren
id|softnet_data
)paren
suffix:semicolon
eof
