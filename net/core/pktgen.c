multiline_comment|/*&n; * Authors:&n; * Copyright 2001, 2002 by Robert Olsson &lt;robert.olsson@its.uu.se&gt;&n; *                             Uppsala University and&n; *                             Swedish University of Agricultural Sciences&n; *&n; * Alexey Kuznetsov  &lt;kuznet@ms2.inr.ac.ru&gt;&n; * Ben Greear &lt;greearb@candelatech.com&gt;&n; * Jens L&#xfffd;&#xfffd;s &lt;jens.laas@data.slu.se&gt;&n; *&n; * This program is free software; you can redistribute it and/or&n; * modify it under the terms of the GNU General Public License&n; * as published by the Free Software Foundation; either version&n; * 2 of the License, or (at your option) any later version.&n; *&n; *&n; * A tool for loading the network with preconfigurated packets.&n; * The tool is implemented as a linux module.  Parameters are output &n; * device, delay (to hard_xmit), number of packets, and whether&n; * to use multiple SKBs or just the same one.&n; * pktgen uses the installed interface&squot;s output routine.&n; *&n; * Additional hacking by:&n; *&n; * Jens.Laas@data.slu.se&n; * Improved by ANK. 010120.&n; * Improved by ANK even more. 010212.&n; * MAC address typo fixed. 010417 --ro&n; * Integrated.  020301 --DaveM&n; * Added multiskb option 020301 --DaveM&n; * Scaling of results. 020417--sigurdur@linpro.no&n; * Significant re-work of the module:&n; *   *  Convert to threaded model to more efficiently be able to transmit&n; *       and receive on multiple interfaces at once.&n; *   *  Converted many counters to __u64 to allow longer runs.&n; *   *  Allow configuration of ranges, like min/max IP address, MACs,&n; *       and UDP-ports, for both source and destination, and can&n; *       set to use a random distribution or sequentially walk the range.&n; *   *  Can now change most values after starting.&n; *   *  Place 12-byte packet in UDP payload with magic number,&n; *       sequence number, and timestamp.&n; *   *  Add receiver code that detects dropped pkts, re-ordered pkts, and&n; *       latencies (with micro-second) precision.&n; *   *  Add IOCTL interface to easily get counters &amp; configuration.&n; *   --Ben Greear &lt;greearb@candelatech.com&gt;&n; *&n; * Renamed multiskb to clone_skb and cleaned up sending core for two distinct &n; * skb modes. A clone_skb=0 mode for Ben &quot;ranges&quot; work and a clone_skb != 0 &n; * as a &quot;fastpath&quot; with a configurable number of clones after alloc&squot;s.&n; * clone_skb=0 means all packets are allocated this also means ranges time &n; * stamps etc can be used. clone_skb=100 means 1 malloc is followed by 100 &n; * clones.&n; *&n; * Also moved to /proc/net/pktgen/ &n; * --ro&n; *&n; * Sept 10:  Fixed threading/locking.  Lots of bone-headed and more clever&n; *    mistakes.  Also merged in DaveM&squot;s patch in the -pre6 patch.&n; * --Ben Greear &lt;greearb@candelatech.com&gt;&n; *&n; * Integrated to 2.5.x 021029 --Lucio Maciel (luciomaciel@zipmail.com.br)&n; *&n; * &n; * 021124 Finished major redesign and rewrite for new functionality.&n; * See Documentation/networking/pktgen.txt for how to use this.&n; *&n; * The new operation:&n; * For each CPU one thread/process is created at start. This process checks &n; * for running devices in the if_list and sends packets until count is 0 it &n; * also the thread checks the thread-&gt;control which is used for inter-process &n; * communication. controlling process &quot;posts&quot; operations to the threads this &n; * way. The if_lock should be possible to remove when add/rem_device is merged&n; * into this too.&n; *&n; * By design there should only be *one* &quot;controlling&quot; process. In practice &n; * multiple write accesses gives unpredictable result. Understood by &quot;write&quot; &n; * to /proc gives result code thats should be read be the &quot;writer&quot;.&n; * For pratical use this should be no problem.&n; *&n; * Note when adding devices to a specific CPU there good idea to also assign &n; * /proc/irq/XX/smp_affinity so TX-interrupts gets bound to the same CPU. &n; * --ro&n; *&n; * Fix refcount off by one if first packet fails, potential null deref, &n; * memleak 030710- KJP&n; *&n; * First &quot;ranges&quot; functionality for ipv6 030726 --ro&n; *&n; * Included flow support. 030802 ANK.&n; *&n; * Fixed unaligned access on IA-64 Grant Grundler &lt;grundler@parisc-linux.org&gt;&n; * &n; * Remove if fix from added Harald Welte &lt;laforge@netfilter.org&gt; 040419&n; * ia64 compilation fix from  Aron Griffis &lt;aron@hp.com&gt; 040604&n; *&n; * New xmit() return, do_div and misc clean up by Stephen Hemminger &n; * &lt;shemminger@osdl.org&gt; 040923&n; *&n; * Rany Dunlap fixed u64 printk compiler waring &n; *&n; * Remove FCS from BW calculation.  Lennert Buytenhek &lt;buytenh@wantstofly.org&gt;&n; * New time handling. Lennert Buytenhek &lt;buytenh@wantstofly.org&gt; 041213&n; *&n; * Corrections from Nikolai Malykh (nmalykh@bilim.com) &n; * Removed unused flags F_SET_SRCMAC &amp; F_SET_SRCIP 041230&n; *&n; */
macro_line|#include &lt;linux/sys.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/moduleparam.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/vmalloc.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/unistd.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/inet.h&gt;
macro_line|#include &lt;linux/inetdevice.h&gt;
macro_line|#include &lt;linux/rtnetlink.h&gt;
macro_line|#include &lt;linux/if_arp.h&gt;
macro_line|#include &lt;linux/in.h&gt;
macro_line|#include &lt;linux/ip.h&gt;
macro_line|#include &lt;linux/ipv6.h&gt;
macro_line|#include &lt;linux/udp.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;net/checksum.h&gt;
macro_line|#include &lt;net/ipv6.h&gt;
macro_line|#include &lt;net/addrconf.h&gt;
macro_line|#include &lt;asm/byteorder.h&gt;
macro_line|#include &lt;linux/rcupdate.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/dma.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/div64.h&gt; /* do_div */
macro_line|#include &lt;asm/timex.h&gt;
DECL|macro|VERSION
mdefine_line|#define VERSION  &quot;pktgen v2.54: Packet Generator for packet performance testing.&bslash;n&quot;
multiline_comment|/* #define PG_DEBUG(a) a */
DECL|macro|PG_DEBUG
mdefine_line|#define PG_DEBUG(a) 
multiline_comment|/* The buckets are exponential in &squot;width&squot; */
DECL|macro|LAT_BUCKETS_MAX
mdefine_line|#define LAT_BUCKETS_MAX 32
DECL|macro|IP_NAME_SZ
mdefine_line|#define IP_NAME_SZ 32
multiline_comment|/* Device flag bits */
DECL|macro|F_IPSRC_RND
mdefine_line|#define F_IPSRC_RND   (1&lt;&lt;0)  /* IP-Src Random  */
DECL|macro|F_IPDST_RND
mdefine_line|#define F_IPDST_RND   (1&lt;&lt;1)  /* IP-Dst Random  */
DECL|macro|F_UDPSRC_RND
mdefine_line|#define F_UDPSRC_RND  (1&lt;&lt;2)  /* UDP-Src Random */
DECL|macro|F_UDPDST_RND
mdefine_line|#define F_UDPDST_RND  (1&lt;&lt;3)  /* UDP-Dst Random */
DECL|macro|F_MACSRC_RND
mdefine_line|#define F_MACSRC_RND  (1&lt;&lt;4)  /* MAC-Src Random */
DECL|macro|F_MACDST_RND
mdefine_line|#define F_MACDST_RND  (1&lt;&lt;5)  /* MAC-Dst Random */
DECL|macro|F_TXSIZE_RND
mdefine_line|#define F_TXSIZE_RND  (1&lt;&lt;6)  /* Transmit size is random */
DECL|macro|F_IPV6
mdefine_line|#define F_IPV6        (1&lt;&lt;7)  /* Interface in IPV6 Mode */
DECL|macro|L_PUSH
mdefine_line|#define L_PUSH(t, i)              {i-&gt;next = t; t=i;}
DECL|macro|L_POP
mdefine_line|#define L_POP(t, i)               {i=t; if(i) t = i-&gt;next;}
multiline_comment|/* Thread control flag bits */
DECL|macro|T_TERMINATE
mdefine_line|#define T_TERMINATE   (1&lt;&lt;0)  
DECL|macro|T_STOP
mdefine_line|#define T_STOP        (1&lt;&lt;1)  /* Stop run */
DECL|macro|T_RUN
mdefine_line|#define T_RUN         (1&lt;&lt;2)  /* Start run */
DECL|macro|T_REMDEV
mdefine_line|#define T_REMDEV      (1&lt;&lt;3)  /* Remove all devs */
multiline_comment|/* Locks */
DECL|macro|thread_lock
mdefine_line|#define   thread_lock()        spin_lock(&amp;_thread_lock)
DECL|macro|thread_unlock
mdefine_line|#define   thread_unlock()      spin_unlock(&amp;_thread_lock)
multiline_comment|/* If lock -- can be removed after some work */
DECL|macro|if_lock
mdefine_line|#define   if_lock(t)           spin_lock(&amp;(t-&gt;if_lock));
DECL|macro|if_unlock
mdefine_line|#define   if_unlock(t)           spin_unlock(&amp;(t-&gt;if_lock));
multiline_comment|/* Used to help with determining the pkts on receive */
DECL|macro|PKTGEN_MAGIC
mdefine_line|#define PKTGEN_MAGIC 0xbe9be955
DECL|macro|PG_PROC_DIR
mdefine_line|#define PG_PROC_DIR &quot;pktgen&quot;
DECL|macro|MAX_CFLOWS
mdefine_line|#define MAX_CFLOWS  65536
DECL|struct|flow_state
r_struct
id|flow_state
(brace
DECL|member|cur_daddr
id|__u32
id|cur_daddr
suffix:semicolon
DECL|member|count
r_int
id|count
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|pktgen_dev
r_struct
id|pktgen_dev
(brace
multiline_comment|/*&n;&t; * Try to keep frequent/infrequent used vars. separated.&n;&t; */
DECL|member|ifname
r_char
id|ifname
(braket
l_int|32
)braket
suffix:semicolon
DECL|member|proc_ent
r_struct
id|proc_dir_entry
op_star
id|proc_ent
suffix:semicolon
DECL|member|result
r_char
id|result
(braket
l_int|512
)braket
suffix:semicolon
multiline_comment|/* proc file names */
DECL|member|fname
r_char
id|fname
(braket
l_int|80
)braket
suffix:semicolon
DECL|member|pg_thread
r_struct
id|pktgen_thread
op_star
id|pg_thread
suffix:semicolon
multiline_comment|/* the owner */
DECL|member|next
r_struct
id|pktgen_dev
op_star
id|next
suffix:semicolon
multiline_comment|/* Used for chaining in the thread&squot;s run-queue */
DECL|member|running
r_int
id|running
suffix:semicolon
multiline_comment|/* if this changes to false, the test will stop */
multiline_comment|/* If min != max, then we will either do a linear iteration, or&n;         * we will do a random selection from within the range.&n;         */
DECL|member|flags
id|__u32
id|flags
suffix:semicolon
DECL|member|min_pkt_size
r_int
id|min_pkt_size
suffix:semicolon
multiline_comment|/* = ETH_ZLEN; */
DECL|member|max_pkt_size
r_int
id|max_pkt_size
suffix:semicolon
multiline_comment|/* = ETH_ZLEN; */
DECL|member|nfrags
r_int
id|nfrags
suffix:semicolon
DECL|member|delay_us
id|__u32
id|delay_us
suffix:semicolon
multiline_comment|/* Default delay */
DECL|member|delay_ns
id|__u32
id|delay_ns
suffix:semicolon
DECL|member|count
id|__u64
id|count
suffix:semicolon
multiline_comment|/* Default No packets to send */
DECL|member|sofar
id|__u64
id|sofar
suffix:semicolon
multiline_comment|/* How many pkts we&squot;ve sent so far */
DECL|member|tx_bytes
id|__u64
id|tx_bytes
suffix:semicolon
multiline_comment|/* How many bytes we&squot;ve transmitted */
DECL|member|errors
id|__u64
id|errors
suffix:semicolon
multiline_comment|/* Errors when trying to transmit, pkts will be re-sent */
multiline_comment|/* runtime counters relating to clone_skb */
DECL|member|next_tx_us
id|__u64
id|next_tx_us
suffix:semicolon
multiline_comment|/* timestamp of when to tx next */
DECL|member|next_tx_ns
id|__u32
id|next_tx_ns
suffix:semicolon
DECL|member|allocated_skbs
id|__u64
id|allocated_skbs
suffix:semicolon
DECL|member|clone_count
id|__u32
id|clone_count
suffix:semicolon
DECL|member|last_ok
r_int
id|last_ok
suffix:semicolon
multiline_comment|/* Was last skb sent? &n;&t;                        * Or a failed transmit of some sort?  This will keep&n;                                * sequence numbers in order, for example.&n;&t;&t;&t;&t;*/
DECL|member|started_at
id|__u64
id|started_at
suffix:semicolon
multiline_comment|/* micro-seconds */
DECL|member|stopped_at
id|__u64
id|stopped_at
suffix:semicolon
multiline_comment|/* micro-seconds */
DECL|member|idle_acc
id|__u64
id|idle_acc
suffix:semicolon
multiline_comment|/* micro-seconds */
DECL|member|seq_num
id|__u32
id|seq_num
suffix:semicolon
DECL|member|clone_skb
r_int
id|clone_skb
suffix:semicolon
multiline_comment|/* Use multiple SKBs during packet gen.  If this number&n;                          * is greater than 1, then that many coppies of the same&n;                          * packet will be sent before a new packet is allocated.&n;                          * For instance, if you want to send 1024 identical packets&n;                          * before creating a new packet, set clone_skb to 1024.&n;                          */
DECL|member|dst_min
r_char
id|dst_min
(braket
id|IP_NAME_SZ
)braket
suffix:semicolon
multiline_comment|/* IP, ie 1.2.3.4 */
DECL|member|dst_max
r_char
id|dst_max
(braket
id|IP_NAME_SZ
)braket
suffix:semicolon
multiline_comment|/* IP, ie 1.2.3.4 */
DECL|member|src_min
r_char
id|src_min
(braket
id|IP_NAME_SZ
)braket
suffix:semicolon
multiline_comment|/* IP, ie 1.2.3.4 */
DECL|member|src_max
r_char
id|src_max
(braket
id|IP_NAME_SZ
)braket
suffix:semicolon
multiline_comment|/* IP, ie 1.2.3.4 */
DECL|member|in6_saddr
r_struct
id|in6_addr
id|in6_saddr
suffix:semicolon
DECL|member|in6_daddr
r_struct
id|in6_addr
id|in6_daddr
suffix:semicolon
DECL|member|cur_in6_daddr
r_struct
id|in6_addr
id|cur_in6_daddr
suffix:semicolon
DECL|member|cur_in6_saddr
r_struct
id|in6_addr
id|cur_in6_saddr
suffix:semicolon
multiline_comment|/* For ranges */
DECL|member|min_in6_daddr
r_struct
id|in6_addr
id|min_in6_daddr
suffix:semicolon
DECL|member|max_in6_daddr
r_struct
id|in6_addr
id|max_in6_daddr
suffix:semicolon
DECL|member|min_in6_saddr
r_struct
id|in6_addr
id|min_in6_saddr
suffix:semicolon
DECL|member|max_in6_saddr
r_struct
id|in6_addr
id|max_in6_saddr
suffix:semicolon
multiline_comment|/* If we&squot;re doing ranges, random or incremental, then this&n;         * defines the min/max for those ranges.&n;         */
DECL|member|saddr_min
id|__u32
id|saddr_min
suffix:semicolon
multiline_comment|/* inclusive, source IP address */
DECL|member|saddr_max
id|__u32
id|saddr_max
suffix:semicolon
multiline_comment|/* exclusive, source IP address */
DECL|member|daddr_min
id|__u32
id|daddr_min
suffix:semicolon
multiline_comment|/* inclusive, dest IP address */
DECL|member|daddr_max
id|__u32
id|daddr_max
suffix:semicolon
multiline_comment|/* exclusive, dest IP address */
DECL|member|udp_src_min
id|__u16
id|udp_src_min
suffix:semicolon
multiline_comment|/* inclusive, source UDP port */
DECL|member|udp_src_max
id|__u16
id|udp_src_max
suffix:semicolon
multiline_comment|/* exclusive, source UDP port */
DECL|member|udp_dst_min
id|__u16
id|udp_dst_min
suffix:semicolon
multiline_comment|/* inclusive, dest UDP port */
DECL|member|udp_dst_max
id|__u16
id|udp_dst_max
suffix:semicolon
multiline_comment|/* exclusive, dest UDP port */
DECL|member|src_mac_count
id|__u32
id|src_mac_count
suffix:semicolon
multiline_comment|/* How many MACs to iterate through */
DECL|member|dst_mac_count
id|__u32
id|dst_mac_count
suffix:semicolon
multiline_comment|/* How many MACs to iterate through */
DECL|member|dst_mac
r_int
r_char
id|dst_mac
(braket
l_int|6
)braket
suffix:semicolon
DECL|member|src_mac
r_int
r_char
id|src_mac
(braket
l_int|6
)braket
suffix:semicolon
DECL|member|cur_dst_mac_offset
id|__u32
id|cur_dst_mac_offset
suffix:semicolon
DECL|member|cur_src_mac_offset
id|__u32
id|cur_src_mac_offset
suffix:semicolon
DECL|member|cur_saddr
id|__u32
id|cur_saddr
suffix:semicolon
DECL|member|cur_daddr
id|__u32
id|cur_daddr
suffix:semicolon
DECL|member|cur_udp_dst
id|__u16
id|cur_udp_dst
suffix:semicolon
DECL|member|cur_udp_src
id|__u16
id|cur_udp_src
suffix:semicolon
DECL|member|cur_pkt_size
id|__u32
id|cur_pkt_size
suffix:semicolon
DECL|member|hh
id|__u8
id|hh
(braket
l_int|14
)braket
suffix:semicolon
multiline_comment|/* = { &n;           0x00, 0x80, 0xC8, 0x79, 0xB3, 0xCB, &n;           &n;           We fill in SRC address later&n;           0x00, 0x00, 0x00, 0x00, 0x00, 0x00,&n;           0x08, 0x00&n;           };&n;        */
DECL|member|pad
id|__u16
id|pad
suffix:semicolon
multiline_comment|/* pad out the hh struct to an even 16 bytes */
DECL|member|skb
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
multiline_comment|/* skb we are to transmit next, mainly used for when we&n;                              * are transmitting the same one multiple times&n;                              */
DECL|member|odev
r_struct
id|net_device
op_star
id|odev
suffix:semicolon
multiline_comment|/* The out-going device.  Note that the device should&n;                                  * have it&squot;s pg_info pointer pointing back to this&n;                                  * device.  This will be set when the user specifies&n;                                  * the out-going device name (not when the inject is&n;                                  * started as it used to do.)&n;                                  */
DECL|member|flows
r_struct
id|flow_state
op_star
id|flows
suffix:semicolon
DECL|member|cflows
r_int
id|cflows
suffix:semicolon
multiline_comment|/* Concurrent flows (config) */
DECL|member|lflow
r_int
id|lflow
suffix:semicolon
multiline_comment|/* Flow length  (config) */
DECL|member|nflows
r_int
id|nflows
suffix:semicolon
multiline_comment|/* accumulated flows (stats) */
)brace
suffix:semicolon
DECL|struct|pktgen_hdr
r_struct
id|pktgen_hdr
(brace
DECL|member|pgh_magic
id|__u32
id|pgh_magic
suffix:semicolon
DECL|member|seq_num
id|__u32
id|seq_num
suffix:semicolon
DECL|member|tv_sec
id|__u32
id|tv_sec
suffix:semicolon
DECL|member|tv_usec
id|__u32
id|tv_usec
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|pktgen_thread
r_struct
id|pktgen_thread
(brace
DECL|member|if_lock
id|spinlock_t
id|if_lock
suffix:semicolon
DECL|member|if_list
r_struct
id|pktgen_dev
op_star
id|if_list
suffix:semicolon
multiline_comment|/* All device here */
DECL|member|next
r_struct
id|pktgen_thread
op_star
id|next
suffix:semicolon
DECL|member|name
r_char
id|name
(braket
l_int|32
)braket
suffix:semicolon
DECL|member|fname
r_char
id|fname
(braket
l_int|128
)braket
suffix:semicolon
multiline_comment|/* name of proc file */
DECL|member|proc_ent
r_struct
id|proc_dir_entry
op_star
id|proc_ent
suffix:semicolon
DECL|member|result
r_char
id|result
(braket
l_int|512
)braket
suffix:semicolon
DECL|member|max_before_softirq
id|u32
id|max_before_softirq
suffix:semicolon
multiline_comment|/* We&squot;ll call do_softirq to prevent starvation. */
multiline_comment|/* Field for thread to receive &quot;posted&quot; events terminate, stop ifs etc.*/
DECL|member|control
id|u32
id|control
suffix:semicolon
DECL|member|pid
r_int
id|pid
suffix:semicolon
DECL|member|cpu
r_int
id|cpu
suffix:semicolon
DECL|member|queue
id|wait_queue_head_t
id|queue
suffix:semicolon
)brace
suffix:semicolon
DECL|macro|REMOVE
mdefine_line|#define REMOVE 1
DECL|macro|FIND
mdefine_line|#define FIND   0
multiline_comment|/*  This code works around the fact that do_div cannot handle two 64-bit&n;    numbers, and regular 64-bit division doesn&squot;t work on x86 kernels.&n;    --Ben&n;*/
DECL|macro|PG_DIV
mdefine_line|#define PG_DIV 0
multiline_comment|/* This was emailed to LMKL by: Chris Caputo &lt;ccaputo@alt.net&gt;&n; * Function copied/adapted/optimized from:&n; *&n; *  nemesis.sourceforge.net/browse/lib/static/intmath/ix86/intmath.c.html&n; *&n; * Copyright 1994, University of Cambridge Computer Laboratory&n; * All Rights Reserved.&n; *&n; */
DECL|function|divremdi3
r_inline
r_static
id|s64
id|divremdi3
c_func
(paren
id|s64
id|x
comma
id|s64
id|y
comma
r_int
id|type
)paren
(brace
id|u64
id|a
op_assign
(paren
id|x
OL
l_int|0
)paren
ques
c_cond
op_minus
id|x
suffix:colon
id|x
suffix:semicolon
id|u64
id|b
op_assign
(paren
id|y
OL
l_int|0
)paren
ques
c_cond
op_minus
id|y
suffix:colon
id|y
suffix:semicolon
id|u64
id|res
op_assign
l_int|0
comma
id|d
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|b
OG
l_int|0
)paren
(brace
r_while
c_loop
(paren
id|b
OL
id|a
)paren
(brace
id|b
op_lshift_assign
l_int|1
suffix:semicolon
id|d
op_lshift_assign
l_int|1
suffix:semicolon
)brace
)brace
r_do
(brace
r_if
c_cond
(paren
id|a
op_ge
id|b
)paren
(brace
id|a
op_sub_assign
id|b
suffix:semicolon
id|res
op_add_assign
id|d
suffix:semicolon
)brace
id|b
op_rshift_assign
l_int|1
suffix:semicolon
id|d
op_rshift_assign
l_int|1
suffix:semicolon
)brace
r_while
c_loop
(paren
id|d
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PG_DIV
op_eq
id|type
)paren
(brace
r_return
(paren
(paren
(paren
id|x
op_xor
id|y
)paren
op_amp
(paren
l_int|1ll
op_lshift
l_int|63
)paren
)paren
op_eq
l_int|0
)paren
ques
c_cond
id|res
suffix:colon
op_minus
(paren
id|s64
)paren
id|res
suffix:semicolon
)brace
r_else
(brace
r_return
(paren
(paren
id|x
op_amp
(paren
l_int|1ll
op_lshift
l_int|63
)paren
)paren
op_eq
l_int|0
)paren
ques
c_cond
id|a
suffix:colon
op_minus
(paren
id|s64
)paren
id|a
suffix:semicolon
)brace
)brace
multiline_comment|/* End of hacks to deal with 64-bit math on x86 */
multiline_comment|/** Convert to miliseconds */
DECL|function|tv_to_ms
r_static
r_inline
id|__u64
id|tv_to_ms
c_func
(paren
r_const
r_struct
id|timeval
op_star
id|tv
)paren
(brace
id|__u64
id|ms
op_assign
id|tv-&gt;tv_usec
op_div
l_int|1000
suffix:semicolon
id|ms
op_add_assign
(paren
id|__u64
)paren
id|tv-&gt;tv_sec
op_star
(paren
id|__u64
)paren
l_int|1000
suffix:semicolon
r_return
id|ms
suffix:semicolon
)brace
multiline_comment|/** Convert to micro-seconds */
DECL|function|tv_to_us
r_static
r_inline
id|__u64
id|tv_to_us
c_func
(paren
r_const
r_struct
id|timeval
op_star
id|tv
)paren
(brace
id|__u64
id|us
op_assign
id|tv-&gt;tv_usec
suffix:semicolon
id|us
op_add_assign
(paren
id|__u64
)paren
id|tv-&gt;tv_sec
op_star
(paren
id|__u64
)paren
l_int|1000000
suffix:semicolon
r_return
id|us
suffix:semicolon
)brace
DECL|function|pg_div
r_static
r_inline
id|__u64
id|pg_div
c_func
(paren
id|__u64
id|n
comma
id|__u32
id|base
)paren
(brace
id|__u64
id|tmp
op_assign
id|n
suffix:semicolon
id|do_div
c_func
(paren
id|tmp
comma
id|base
)paren
suffix:semicolon
multiline_comment|/* printk(&quot;pktgen: pg_div, n: %llu  base: %d  rv: %llu&bslash;n&quot;,&n;                  n, base, tmp); */
r_return
id|tmp
suffix:semicolon
)brace
DECL|function|pg_div64
r_static
r_inline
id|__u64
id|pg_div64
c_func
(paren
id|__u64
id|n
comma
id|__u64
id|base
)paren
(brace
id|__u64
id|tmp
op_assign
id|n
suffix:semicolon
multiline_comment|/*&n; * How do we know if the architectrure we are running on&n; * supports division with 64 bit base?&n; * &n; */
macro_line|#if defined(__sparc_v9__) || defined(__powerpc64__) || defined(__alpha__) || defined(__x86_64__) || defined(__ia64__) 
id|do_div
c_func
(paren
id|tmp
comma
id|base
)paren
suffix:semicolon
macro_line|#else
id|tmp
op_assign
id|divremdi3
c_func
(paren
id|n
comma
id|base
comma
id|PG_DIV
)paren
suffix:semicolon
macro_line|#endif
r_return
id|tmp
suffix:semicolon
)brace
DECL|function|pktgen_random
r_static
r_inline
id|u32
id|pktgen_random
c_func
(paren
r_void
)paren
(brace
macro_line|#if 0
id|__u32
id|n
suffix:semicolon
id|get_random_bytes
c_func
(paren
op_amp
id|n
comma
l_int|4
)paren
suffix:semicolon
r_return
id|n
suffix:semicolon
macro_line|#else
r_return
id|net_random
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
)brace
DECL|function|getCurMs
r_static
r_inline
id|__u64
id|getCurMs
c_func
(paren
r_void
)paren
(brace
r_struct
id|timeval
id|tv
suffix:semicolon
id|do_gettimeofday
c_func
(paren
op_amp
id|tv
)paren
suffix:semicolon
r_return
id|tv_to_ms
c_func
(paren
op_amp
id|tv
)paren
suffix:semicolon
)brace
DECL|function|getCurUs
r_static
r_inline
id|__u64
id|getCurUs
c_func
(paren
r_void
)paren
(brace
r_struct
id|timeval
id|tv
suffix:semicolon
id|do_gettimeofday
c_func
(paren
op_amp
id|tv
)paren
suffix:semicolon
r_return
id|tv_to_us
c_func
(paren
op_amp
id|tv
)paren
suffix:semicolon
)brace
DECL|function|tv_diff
r_static
r_inline
id|__u64
id|tv_diff
c_func
(paren
r_const
r_struct
id|timeval
op_star
id|a
comma
r_const
r_struct
id|timeval
op_star
id|b
)paren
(brace
r_return
id|tv_to_us
c_func
(paren
id|a
)paren
op_minus
id|tv_to_us
c_func
(paren
id|b
)paren
suffix:semicolon
)brace
multiline_comment|/* old include end */
DECL|variable|__initdata
r_static
r_char
id|version
(braket
)braket
id|__initdata
op_assign
id|VERSION
suffix:semicolon
r_static
id|ssize_t
id|proc_pgctrl_read
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_char
op_star
id|buf
comma
r_int
id|count
comma
id|loff_t
op_star
id|ppos
)paren
suffix:semicolon
r_static
id|ssize_t
id|proc_pgctrl_write
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_const
r_char
op_star
id|buf
comma
r_int
id|count
comma
id|loff_t
op_star
id|ppos
)paren
suffix:semicolon
r_static
r_int
id|proc_if_read
c_func
(paren
r_char
op_star
id|buf
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|len
comma
r_int
op_star
id|eof
comma
r_void
op_star
id|data
)paren
suffix:semicolon
r_static
r_int
id|proc_thread_read
c_func
(paren
r_char
op_star
id|buf
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|len
comma
r_int
op_star
id|eof
comma
r_void
op_star
id|data
)paren
suffix:semicolon
r_static
r_int
id|proc_if_write
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_const
r_char
op_star
id|user_buffer
comma
r_int
r_int
id|count
comma
r_void
op_star
id|data
)paren
suffix:semicolon
r_static
r_int
id|proc_thread_write
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_const
r_char
op_star
id|user_buffer
comma
r_int
r_int
id|count
comma
r_void
op_star
id|data
)paren
suffix:semicolon
r_static
r_int
id|create_proc_dir
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|remove_proc_dir
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|pktgen_remove_device
c_func
(paren
r_struct
id|pktgen_thread
op_star
id|t
comma
r_struct
id|pktgen_dev
op_star
id|i
)paren
suffix:semicolon
r_static
r_int
id|pktgen_add_device
c_func
(paren
r_struct
id|pktgen_thread
op_star
id|t
comma
r_const
r_char
op_star
id|ifname
)paren
suffix:semicolon
r_static
r_struct
id|pktgen_thread
op_star
id|pktgen_find_thread
c_func
(paren
r_const
r_char
op_star
id|name
)paren
suffix:semicolon
r_static
r_struct
id|pktgen_dev
op_star
id|pktgen_find_dev
c_func
(paren
r_struct
id|pktgen_thread
op_star
id|t
comma
r_const
r_char
op_star
id|ifname
)paren
suffix:semicolon
r_static
r_int
id|pktgen_device_event
c_func
(paren
r_struct
id|notifier_block
op_star
comma
r_int
r_int
comma
r_void
op_star
)paren
suffix:semicolon
r_static
r_void
id|pktgen_run_all_threads
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|pktgen_stop_all_threads_ifs
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|pktgen_stop_device
c_func
(paren
r_struct
id|pktgen_dev
op_star
id|pkt_dev
)paren
suffix:semicolon
r_static
r_void
id|pktgen_stop
c_func
(paren
r_struct
id|pktgen_thread
op_star
id|t
)paren
suffix:semicolon
r_static
r_void
id|pktgen_clear_counters
c_func
(paren
r_struct
id|pktgen_dev
op_star
id|pkt_dev
)paren
suffix:semicolon
r_static
r_struct
id|pktgen_dev
op_star
id|pktgen_NN_threads
c_func
(paren
r_const
r_char
op_star
id|dev_name
comma
r_int
id|remove
)paren
suffix:semicolon
r_static
r_int
r_int
id|scan_ip6
c_func
(paren
r_const
r_char
op_star
id|s
comma
r_char
id|ip
(braket
l_int|16
)braket
)paren
suffix:semicolon
r_static
r_int
r_int
id|fmt_ip6
c_func
(paren
r_char
op_star
id|s
comma
r_const
r_char
id|ip
(braket
l_int|16
)braket
)paren
suffix:semicolon
multiline_comment|/* Module parameters, defaults. */
DECL|variable|pg_count_d
r_static
r_int
id|pg_count_d
op_assign
l_int|1000
suffix:semicolon
multiline_comment|/* 1000 pkts by default */
DECL|variable|pg_delay_d
r_static
r_int
id|pg_delay_d
op_assign
l_int|0
suffix:semicolon
DECL|variable|pg_clone_skb_d
r_static
r_int
id|pg_clone_skb_d
op_assign
l_int|0
suffix:semicolon
DECL|variable|debug
r_static
r_int
id|debug
op_assign
l_int|0
suffix:semicolon
DECL|variable|_thread_lock
r_static
id|spinlock_t
id|_thread_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
DECL|variable|pktgen_threads
r_static
r_struct
id|pktgen_thread
op_star
id|pktgen_threads
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|module_fname
r_static
r_char
id|module_fname
(braket
l_int|128
)braket
suffix:semicolon
DECL|variable|module_proc_ent
r_static
r_struct
id|proc_dir_entry
op_star
id|module_proc_ent
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|pktgen_notifier_block
r_static
r_struct
id|notifier_block
id|pktgen_notifier_block
op_assign
(brace
id|notifier_call
suffix:colon
id|pktgen_device_event
comma
)brace
suffix:semicolon
DECL|variable|pktgen_fops
r_static
r_struct
id|file_operations
id|pktgen_fops
op_assign
(brace
dot
id|read
op_assign
id|proc_pgctrl_read
comma
dot
id|write
op_assign
id|proc_pgctrl_write
comma
multiline_comment|/*  .ioctl    = pktgen_ioctl, later maybe */
)brace
suffix:semicolon
multiline_comment|/*&n; * /proc handling functions &n; *&n; */
DECL|variable|pg_proc_dir
r_static
r_struct
id|proc_dir_entry
op_star
id|pg_proc_dir
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|proc_pgctrl_read_eof
r_static
r_int
id|proc_pgctrl_read_eof
op_assign
l_int|0
suffix:semicolon
DECL|function|proc_pgctrl_read
r_static
id|ssize_t
id|proc_pgctrl_read
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_char
op_star
id|buf
comma
r_int
id|count
comma
id|loff_t
op_star
id|ppos
)paren
(brace
r_char
id|data
(braket
l_int|200
)braket
suffix:semicolon
r_int
id|len
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|proc_pgctrl_read_eof
)paren
(brace
id|proc_pgctrl_read_eof
op_assign
l_int|0
suffix:semicolon
id|len
op_assign
l_int|0
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|sprintf
c_func
(paren
id|data
comma
l_string|&quot;%s&quot;
comma
id|VERSION
)paren
suffix:semicolon
id|len
op_assign
id|strlen
c_func
(paren
id|data
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|count
)paren
(brace
id|len
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|buf
comma
id|data
comma
id|len
)paren
)paren
(brace
id|len
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
op_star
id|ppos
op_add_assign
id|len
suffix:semicolon
id|proc_pgctrl_read_eof
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* EOF next call */
id|out
suffix:colon
r_return
id|len
suffix:semicolon
)brace
DECL|function|proc_pgctrl_write
r_static
id|ssize_t
id|proc_pgctrl_write
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_const
r_char
op_star
id|buf
comma
r_int
id|count
comma
id|loff_t
op_star
id|ppos
)paren
(brace
r_char
op_star
id|data
op_assign
l_int|NULL
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_NET_ADMIN
)paren
)paren
(brace
id|err
op_assign
op_minus
id|EPERM
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|data
op_assign
(paren
r_void
op_star
)paren
id|vmalloc
(paren
(paren
r_int
r_int
)paren
id|count
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|data
)paren
(brace
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|data
comma
id|buf
comma
id|count
)paren
)paren
(brace
id|err
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
id|out_free
suffix:semicolon
)brace
id|data
(braket
id|count
op_minus
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Make string */
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|data
comma
l_string|&quot;stop&quot;
)paren
)paren
id|pktgen_stop_all_threads_ifs
c_func
(paren
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|data
comma
l_string|&quot;start&quot;
)paren
)paren
id|pktgen_run_all_threads
c_func
(paren
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;pktgen: Unknown command: %s&bslash;n&quot;
comma
id|data
)paren
suffix:semicolon
id|err
op_assign
id|count
suffix:semicolon
id|out_free
suffix:colon
id|vfree
(paren
id|data
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|err
suffix:semicolon
)brace
DECL|function|proc_if_read
r_static
r_int
id|proc_if_read
c_func
(paren
r_char
op_star
id|buf
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|len
comma
r_int
op_star
id|eof
comma
r_void
op_star
id|data
)paren
(brace
r_char
op_star
id|p
suffix:semicolon
r_int
id|i
suffix:semicolon
r_struct
id|pktgen_dev
op_star
id|pkt_dev
op_assign
(paren
r_struct
id|pktgen_dev
op_star
)paren
(paren
id|data
)paren
suffix:semicolon
id|__u64
id|sa
suffix:semicolon
id|__u64
id|stopped
suffix:semicolon
id|__u64
id|now
op_assign
id|getCurUs
c_func
(paren
)paren
suffix:semicolon
id|p
op_assign
id|buf
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;Params: count %llu  min_pkt_size: %u  max_pkt_size: %u&bslash;n&quot;
comma
(paren
r_int
r_int
r_int
)paren
id|pkt_dev-&gt;count
comma
id|pkt_dev-&gt;min_pkt_size
comma
id|pkt_dev-&gt;max_pkt_size
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;     frags: %d  delay: %u  clone_skb: %d  ifname: %s&bslash;n&quot;
comma
id|pkt_dev-&gt;nfrags
comma
l_int|1000
op_star
id|pkt_dev-&gt;delay_us
op_plus
id|pkt_dev-&gt;delay_ns
comma
id|pkt_dev-&gt;clone_skb
comma
id|pkt_dev-&gt;ifname
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;     flows: %u flowlen: %u&bslash;n&quot;
comma
id|pkt_dev-&gt;cflows
comma
id|pkt_dev-&gt;lflow
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pkt_dev-&gt;flags
op_amp
id|F_IPV6
)paren
(brace
r_char
id|b1
(braket
l_int|128
)braket
comma
id|b2
(braket
l_int|128
)braket
comma
id|b3
(braket
l_int|128
)braket
suffix:semicolon
id|fmt_ip6
c_func
(paren
id|b1
comma
id|pkt_dev-&gt;in6_saddr.s6_addr
)paren
suffix:semicolon
id|fmt_ip6
c_func
(paren
id|b2
comma
id|pkt_dev-&gt;min_in6_saddr.s6_addr
)paren
suffix:semicolon
id|fmt_ip6
c_func
(paren
id|b3
comma
id|pkt_dev-&gt;max_in6_saddr.s6_addr
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;     saddr: %s  min_saddr: %s  max_saddr: %s&bslash;n&quot;
comma
id|b1
comma
id|b2
comma
id|b3
)paren
suffix:semicolon
id|fmt_ip6
c_func
(paren
id|b1
comma
id|pkt_dev-&gt;in6_daddr.s6_addr
)paren
suffix:semicolon
id|fmt_ip6
c_func
(paren
id|b2
comma
id|pkt_dev-&gt;min_in6_daddr.s6_addr
)paren
suffix:semicolon
id|fmt_ip6
c_func
(paren
id|b3
comma
id|pkt_dev-&gt;max_in6_daddr.s6_addr
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;     daddr: %s  min_daddr: %s  max_daddr: %s&bslash;n&quot;
comma
id|b1
comma
id|b2
comma
id|b3
)paren
suffix:semicolon
)brace
r_else
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;     dst_min: %s  dst_max: %s&bslash;n     src_min: %s  src_max: %s&bslash;n&quot;
comma
id|pkt_dev-&gt;dst_min
comma
id|pkt_dev-&gt;dst_max
comma
id|pkt_dev-&gt;src_min
comma
id|pkt_dev-&gt;src_max
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;     src_mac: &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|pkt_dev-&gt;src_mac
(braket
l_int|0
)braket
op_eq
l_int|0
)paren
op_logical_and
(paren
id|pkt_dev-&gt;src_mac
(braket
l_int|1
)braket
op_eq
l_int|0
)paren
op_logical_and
(paren
id|pkt_dev-&gt;src_mac
(braket
l_int|2
)braket
op_eq
l_int|0
)paren
op_logical_and
(paren
id|pkt_dev-&gt;src_mac
(braket
l_int|3
)braket
op_eq
l_int|0
)paren
op_logical_and
(paren
id|pkt_dev-&gt;src_mac
(braket
l_int|4
)braket
op_eq
l_int|0
)paren
op_logical_and
(paren
id|pkt_dev-&gt;src_mac
(braket
l_int|5
)braket
op_eq
l_int|0
)paren
)paren
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;%02X%s&quot;
comma
id|pkt_dev-&gt;odev-&gt;dev_addr
(braket
id|i
)braket
comma
id|i
op_eq
l_int|5
ques
c_cond
l_string|&quot;  &quot;
suffix:colon
l_string|&quot;:&quot;
)paren
suffix:semicolon
r_else
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;%02X%s&quot;
comma
id|pkt_dev-&gt;src_mac
(braket
id|i
)braket
comma
id|i
op_eq
l_int|5
ques
c_cond
l_string|&quot;  &quot;
suffix:colon
l_string|&quot;:&quot;
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;dst_mac: &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;%02X%s&quot;
comma
id|pkt_dev-&gt;dst_mac
(braket
id|i
)braket
comma
id|i
op_eq
l_int|5
ques
c_cond
l_string|&quot;&bslash;n&quot;
suffix:colon
l_string|&quot;:&quot;
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;     udp_src_min: %d  udp_src_max: %d  udp_dst_min: %d  udp_dst_max: %d&bslash;n&quot;
comma
id|pkt_dev-&gt;udp_src_min
comma
id|pkt_dev-&gt;udp_src_max
comma
id|pkt_dev-&gt;udp_dst_min
comma
id|pkt_dev-&gt;udp_dst_max
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;     src_mac_count: %d  dst_mac_count: %d &bslash;n     Flags: &quot;
comma
id|pkt_dev-&gt;src_mac_count
comma
id|pkt_dev-&gt;dst_mac_count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pkt_dev-&gt;flags
op_amp
id|F_IPV6
)paren
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;IPV6  &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pkt_dev-&gt;flags
op_amp
id|F_IPSRC_RND
)paren
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;IPSRC_RND  &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pkt_dev-&gt;flags
op_amp
id|F_IPDST_RND
)paren
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;IPDST_RND  &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pkt_dev-&gt;flags
op_amp
id|F_TXSIZE_RND
)paren
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;TXSIZE_RND  &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pkt_dev-&gt;flags
op_amp
id|F_UDPSRC_RND
)paren
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;UDPSRC_RND  &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pkt_dev-&gt;flags
op_amp
id|F_UDPDST_RND
)paren
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;UDPDST_RND  &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pkt_dev-&gt;flags
op_amp
id|F_MACSRC_RND
)paren
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;MACSRC_RND  &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pkt_dev-&gt;flags
op_amp
id|F_MACDST_RND
)paren
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;MACDST_RND  &quot;
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|sa
op_assign
id|pkt_dev-&gt;started_at
suffix:semicolon
id|stopped
op_assign
id|pkt_dev-&gt;stopped_at
suffix:semicolon
r_if
c_cond
(paren
id|pkt_dev-&gt;running
)paren
id|stopped
op_assign
id|now
suffix:semicolon
multiline_comment|/* not really stopped, more like last-running-at */
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;Current:&bslash;n     pkts-sofar: %llu  errors: %llu&bslash;n     started: %lluus  stopped: %lluus idle: %lluus&bslash;n&quot;
comma
(paren
r_int
r_int
r_int
)paren
id|pkt_dev-&gt;sofar
comma
(paren
r_int
r_int
r_int
)paren
id|pkt_dev-&gt;errors
comma
(paren
r_int
r_int
r_int
)paren
id|sa
comma
(paren
r_int
r_int
r_int
)paren
id|stopped
comma
(paren
r_int
r_int
r_int
)paren
id|pkt_dev-&gt;idle_acc
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;     seq_num: %d  cur_dst_mac_offset: %d  cur_src_mac_offset: %d&bslash;n&quot;
comma
id|pkt_dev-&gt;seq_num
comma
id|pkt_dev-&gt;cur_dst_mac_offset
comma
id|pkt_dev-&gt;cur_src_mac_offset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pkt_dev-&gt;flags
op_amp
id|F_IPV6
)paren
(brace
r_char
id|b1
(braket
l_int|128
)braket
comma
id|b2
(braket
l_int|128
)braket
suffix:semicolon
id|fmt_ip6
c_func
(paren
id|b1
comma
id|pkt_dev-&gt;cur_in6_daddr.s6_addr
)paren
suffix:semicolon
id|fmt_ip6
c_func
(paren
id|b2
comma
id|pkt_dev-&gt;cur_in6_saddr.s6_addr
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;     cur_saddr: %s  cur_daddr: %s&bslash;n&quot;
comma
id|b2
comma
id|b1
)paren
suffix:semicolon
)brace
r_else
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;     cur_saddr: 0x%x  cur_daddr: 0x%x&bslash;n&quot;
comma
id|pkt_dev-&gt;cur_saddr
comma
id|pkt_dev-&gt;cur_daddr
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;     cur_udp_dst: %d  cur_udp_src: %d&bslash;n&quot;
comma
id|pkt_dev-&gt;cur_udp_dst
comma
id|pkt_dev-&gt;cur_udp_src
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;     flows: %u&bslash;n&quot;
comma
id|pkt_dev-&gt;nflows
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pkt_dev-&gt;result
(braket
l_int|0
)braket
)paren
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;Result: %s&bslash;n&quot;
comma
id|pkt_dev-&gt;result
)paren
suffix:semicolon
r_else
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;Result: Idle&bslash;n&quot;
)paren
suffix:semicolon
op_star
id|eof
op_assign
l_int|1
suffix:semicolon
r_return
id|p
op_minus
id|buf
suffix:semicolon
)brace
DECL|function|count_trail_chars
r_static
r_int
id|count_trail_chars
c_func
(paren
r_const
r_char
op_star
id|user_buffer
comma
r_int
r_int
id|maxlen
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|maxlen
suffix:semicolon
id|i
op_increment
)paren
(brace
r_char
id|c
suffix:semicolon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|c
comma
op_amp
id|user_buffer
(braket
id|i
)braket
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_switch
c_cond
(paren
id|c
)paren
(brace
r_case
l_char|&squot;&bslash;&quot;&squot;
suffix:colon
r_case
l_char|&squot;&bslash;n&squot;
suffix:colon
r_case
l_char|&squot;&bslash;r&squot;
suffix:colon
r_case
l_char|&squot;&bslash;t&squot;
suffix:colon
r_case
l_char|&squot; &squot;
suffix:colon
r_case
l_char|&squot;=&squot;
suffix:colon
r_break
suffix:semicolon
r_default
suffix:colon
r_goto
id|done
suffix:semicolon
)brace
suffix:semicolon
)brace
id|done
suffix:colon
r_return
id|i
suffix:semicolon
)brace
DECL|function|num_arg
r_static
r_int
r_int
id|num_arg
c_func
(paren
r_const
r_char
op_star
id|user_buffer
comma
r_int
r_int
id|maxlen
comma
r_int
r_int
op_star
id|num
)paren
(brace
r_int
id|i
op_assign
l_int|0
suffix:semicolon
op_star
id|num
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|i
OL
id|maxlen
suffix:semicolon
id|i
op_increment
)paren
(brace
r_char
id|c
suffix:semicolon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|c
comma
op_amp
id|user_buffer
(braket
id|i
)braket
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
(paren
id|c
op_ge
l_char|&squot;0&squot;
)paren
op_logical_and
(paren
id|c
op_le
l_char|&squot;9&squot;
)paren
)paren
(brace
op_star
id|num
op_mul_assign
l_int|10
suffix:semicolon
op_star
id|num
op_add_assign
id|c
op_minus
l_char|&squot;0&squot;
suffix:semicolon
)brace
r_else
r_break
suffix:semicolon
)brace
r_return
id|i
suffix:semicolon
)brace
DECL|function|strn_len
r_static
r_int
id|strn_len
c_func
(paren
r_const
r_char
op_star
id|user_buffer
comma
r_int
r_int
id|maxlen
)paren
(brace
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|i
OL
id|maxlen
suffix:semicolon
id|i
op_increment
)paren
(brace
r_char
id|c
suffix:semicolon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|c
comma
op_amp
id|user_buffer
(braket
id|i
)braket
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_switch
c_cond
(paren
id|c
)paren
(brace
r_case
l_char|&squot;&bslash;&quot;&squot;
suffix:colon
r_case
l_char|&squot;&bslash;n&squot;
suffix:colon
r_case
l_char|&squot;&bslash;r&squot;
suffix:colon
r_case
l_char|&squot;&bslash;t&squot;
suffix:colon
r_case
l_char|&squot; &squot;
suffix:colon
r_goto
id|done_str
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
suffix:semicolon
)brace
id|done_str
suffix:colon
r_return
id|i
suffix:semicolon
)brace
DECL|function|proc_if_write
r_static
r_int
id|proc_if_write
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_const
r_char
op_star
id|user_buffer
comma
r_int
r_int
id|count
comma
r_void
op_star
id|data
)paren
(brace
r_int
id|i
op_assign
l_int|0
comma
id|max
comma
id|len
suffix:semicolon
r_char
id|name
(braket
l_int|16
)braket
comma
id|valstr
(braket
l_int|32
)braket
suffix:semicolon
r_int
r_int
id|value
op_assign
l_int|0
suffix:semicolon
r_struct
id|pktgen_dev
op_star
id|pkt_dev
op_assign
(paren
r_struct
id|pktgen_dev
op_star
)paren
(paren
id|data
)paren
suffix:semicolon
r_char
op_star
id|pg_result
op_assign
l_int|NULL
suffix:semicolon
r_int
id|tmp
op_assign
l_int|0
suffix:semicolon
id|pg_result
op_assign
op_amp
(paren
id|pkt_dev-&gt;result
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|count
OL
l_int|1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;pktgen: wrong command format&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|max
op_assign
id|count
op_minus
id|i
suffix:semicolon
id|tmp
op_assign
id|count_trail_chars
c_func
(paren
op_amp
id|user_buffer
(braket
id|i
)braket
comma
id|max
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;pktgen: illegal format&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|tmp
suffix:semicolon
)brace
id|i
op_add_assign
id|tmp
suffix:semicolon
multiline_comment|/* Read variable name */
id|len
op_assign
id|strn_len
c_func
(paren
op_amp
id|user_buffer
(braket
id|i
)braket
comma
r_sizeof
(paren
id|name
)paren
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
l_int|0
)paren
(brace
r_return
id|len
suffix:semicolon
)brace
id|memset
c_func
(paren
id|name
comma
l_int|0
comma
r_sizeof
(paren
id|name
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|name
comma
op_amp
id|user_buffer
(braket
id|i
)braket
comma
id|len
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|i
op_add_assign
id|len
suffix:semicolon
id|max
op_assign
id|count
op_minus
id|i
suffix:semicolon
id|len
op_assign
id|count_trail_chars
c_func
(paren
op_amp
id|user_buffer
(braket
id|i
)braket
comma
id|max
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
l_int|0
)paren
r_return
id|len
suffix:semicolon
id|i
op_add_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
id|debug
)paren
(brace
r_char
id|tb
(braket
id|count
op_plus
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|tb
comma
id|user_buffer
comma
id|count
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|tb
(braket
id|count
)braket
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;pktgen: %s,%lu  buffer -:%s:-&bslash;n&quot;
comma
id|name
comma
id|count
comma
id|tb
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|name
comma
l_string|&quot;min_pkt_size&quot;
)paren
)paren
(brace
id|len
op_assign
id|num_arg
c_func
(paren
op_amp
id|user_buffer
(braket
id|i
)braket
comma
l_int|10
comma
op_amp
id|value
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
l_int|0
)paren
(brace
r_return
id|len
suffix:semicolon
)brace
id|i
op_add_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
id|value
OL
l_int|14
op_plus
l_int|20
op_plus
l_int|8
)paren
id|value
op_assign
l_int|14
op_plus
l_int|20
op_plus
l_int|8
suffix:semicolon
r_if
c_cond
(paren
id|value
op_ne
id|pkt_dev-&gt;min_pkt_size
)paren
(brace
id|pkt_dev-&gt;min_pkt_size
op_assign
id|value
suffix:semicolon
id|pkt_dev-&gt;cur_pkt_size
op_assign
id|value
suffix:semicolon
)brace
id|sprintf
c_func
(paren
id|pg_result
comma
l_string|&quot;OK: min_pkt_size=%u&quot;
comma
id|pkt_dev-&gt;min_pkt_size
)paren
suffix:semicolon
r_return
id|count
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|name
comma
l_string|&quot;max_pkt_size&quot;
)paren
)paren
(brace
id|len
op_assign
id|num_arg
c_func
(paren
op_amp
id|user_buffer
(braket
id|i
)braket
comma
l_int|10
comma
op_amp
id|value
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
l_int|0
)paren
(brace
r_return
id|len
suffix:semicolon
)brace
id|i
op_add_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
id|value
OL
l_int|14
op_plus
l_int|20
op_plus
l_int|8
)paren
id|value
op_assign
l_int|14
op_plus
l_int|20
op_plus
l_int|8
suffix:semicolon
r_if
c_cond
(paren
id|value
op_ne
id|pkt_dev-&gt;max_pkt_size
)paren
(brace
id|pkt_dev-&gt;max_pkt_size
op_assign
id|value
suffix:semicolon
id|pkt_dev-&gt;cur_pkt_size
op_assign
id|value
suffix:semicolon
)brace
id|sprintf
c_func
(paren
id|pg_result
comma
l_string|&quot;OK: max_pkt_size=%u&quot;
comma
id|pkt_dev-&gt;max_pkt_size
)paren
suffix:semicolon
r_return
id|count
suffix:semicolon
)brace
multiline_comment|/* Shortcut for min = max */
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|name
comma
l_string|&quot;pkt_size&quot;
)paren
)paren
(brace
id|len
op_assign
id|num_arg
c_func
(paren
op_amp
id|user_buffer
(braket
id|i
)braket
comma
l_int|10
comma
op_amp
id|value
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
l_int|0
)paren
(brace
r_return
id|len
suffix:semicolon
)brace
id|i
op_add_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
id|value
OL
l_int|14
op_plus
l_int|20
op_plus
l_int|8
)paren
id|value
op_assign
l_int|14
op_plus
l_int|20
op_plus
l_int|8
suffix:semicolon
r_if
c_cond
(paren
id|value
op_ne
id|pkt_dev-&gt;min_pkt_size
)paren
(brace
id|pkt_dev-&gt;min_pkt_size
op_assign
id|value
suffix:semicolon
id|pkt_dev-&gt;max_pkt_size
op_assign
id|value
suffix:semicolon
id|pkt_dev-&gt;cur_pkt_size
op_assign
id|value
suffix:semicolon
)brace
id|sprintf
c_func
(paren
id|pg_result
comma
l_string|&quot;OK: pkt_size=%u&quot;
comma
id|pkt_dev-&gt;min_pkt_size
)paren
suffix:semicolon
r_return
id|count
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|name
comma
l_string|&quot;debug&quot;
)paren
)paren
(brace
id|len
op_assign
id|num_arg
c_func
(paren
op_amp
id|user_buffer
(braket
id|i
)braket
comma
l_int|10
comma
op_amp
id|value
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
l_int|0
)paren
(brace
r_return
id|len
suffix:semicolon
)brace
id|i
op_add_assign
id|len
suffix:semicolon
id|debug
op_assign
id|value
suffix:semicolon
id|sprintf
c_func
(paren
id|pg_result
comma
l_string|&quot;OK: debug=%u&quot;
comma
id|debug
)paren
suffix:semicolon
r_return
id|count
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|name
comma
l_string|&quot;frags&quot;
)paren
)paren
(brace
id|len
op_assign
id|num_arg
c_func
(paren
op_amp
id|user_buffer
(braket
id|i
)braket
comma
l_int|10
comma
op_amp
id|value
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
l_int|0
)paren
(brace
r_return
id|len
suffix:semicolon
)brace
id|i
op_add_assign
id|len
suffix:semicolon
id|pkt_dev-&gt;nfrags
op_assign
id|value
suffix:semicolon
id|sprintf
c_func
(paren
id|pg_result
comma
l_string|&quot;OK: frags=%u&quot;
comma
id|pkt_dev-&gt;nfrags
)paren
suffix:semicolon
r_return
id|count
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|name
comma
l_string|&quot;delay&quot;
)paren
)paren
(brace
id|len
op_assign
id|num_arg
c_func
(paren
op_amp
id|user_buffer
(braket
id|i
)braket
comma
l_int|10
comma
op_amp
id|value
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
l_int|0
)paren
(brace
r_return
id|len
suffix:semicolon
)brace
id|i
op_add_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
id|value
op_eq
l_int|0x7FFFFFFF
)paren
(brace
id|pkt_dev-&gt;delay_us
op_assign
l_int|0x7FFFFFFF
suffix:semicolon
id|pkt_dev-&gt;delay_ns
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|pkt_dev-&gt;delay_us
op_assign
id|value
op_div
l_int|1000
suffix:semicolon
id|pkt_dev-&gt;delay_ns
op_assign
id|value
op_mod
l_int|1000
suffix:semicolon
)brace
id|sprintf
c_func
(paren
id|pg_result
comma
l_string|&quot;OK: delay=%u&quot;
comma
l_int|1000
op_star
id|pkt_dev-&gt;delay_us
op_plus
id|pkt_dev-&gt;delay_ns
)paren
suffix:semicolon
r_return
id|count
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|name
comma
l_string|&quot;udp_src_min&quot;
)paren
)paren
(brace
id|len
op_assign
id|num_arg
c_func
(paren
op_amp
id|user_buffer
(braket
id|i
)braket
comma
l_int|10
comma
op_amp
id|value
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
l_int|0
)paren
(brace
r_return
id|len
suffix:semicolon
)brace
id|i
op_add_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
id|value
op_ne
id|pkt_dev-&gt;udp_src_min
)paren
(brace
id|pkt_dev-&gt;udp_src_min
op_assign
id|value
suffix:semicolon
id|pkt_dev-&gt;cur_udp_src
op_assign
id|value
suffix:semicolon
)brace
id|sprintf
c_func
(paren
id|pg_result
comma
l_string|&quot;OK: udp_src_min=%u&quot;
comma
id|pkt_dev-&gt;udp_src_min
)paren
suffix:semicolon
r_return
id|count
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|name
comma
l_string|&quot;udp_dst_min&quot;
)paren
)paren
(brace
id|len
op_assign
id|num_arg
c_func
(paren
op_amp
id|user_buffer
(braket
id|i
)braket
comma
l_int|10
comma
op_amp
id|value
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
l_int|0
)paren
(brace
r_return
id|len
suffix:semicolon
)brace
id|i
op_add_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
id|value
op_ne
id|pkt_dev-&gt;udp_dst_min
)paren
(brace
id|pkt_dev-&gt;udp_dst_min
op_assign
id|value
suffix:semicolon
id|pkt_dev-&gt;cur_udp_dst
op_assign
id|value
suffix:semicolon
)brace
id|sprintf
c_func
(paren
id|pg_result
comma
l_string|&quot;OK: udp_dst_min=%u&quot;
comma
id|pkt_dev-&gt;udp_dst_min
)paren
suffix:semicolon
r_return
id|count
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|name
comma
l_string|&quot;udp_src_max&quot;
)paren
)paren
(brace
id|len
op_assign
id|num_arg
c_func
(paren
op_amp
id|user_buffer
(braket
id|i
)braket
comma
l_int|10
comma
op_amp
id|value
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
l_int|0
)paren
(brace
r_return
id|len
suffix:semicolon
)brace
id|i
op_add_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
id|value
op_ne
id|pkt_dev-&gt;udp_src_max
)paren
(brace
id|pkt_dev-&gt;udp_src_max
op_assign
id|value
suffix:semicolon
id|pkt_dev-&gt;cur_udp_src
op_assign
id|value
suffix:semicolon
)brace
id|sprintf
c_func
(paren
id|pg_result
comma
l_string|&quot;OK: udp_src_max=%u&quot;
comma
id|pkt_dev-&gt;udp_src_max
)paren
suffix:semicolon
r_return
id|count
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|name
comma
l_string|&quot;udp_dst_max&quot;
)paren
)paren
(brace
id|len
op_assign
id|num_arg
c_func
(paren
op_amp
id|user_buffer
(braket
id|i
)braket
comma
l_int|10
comma
op_amp
id|value
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
l_int|0
)paren
(brace
r_return
id|len
suffix:semicolon
)brace
id|i
op_add_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
id|value
op_ne
id|pkt_dev-&gt;udp_dst_max
)paren
(brace
id|pkt_dev-&gt;udp_dst_max
op_assign
id|value
suffix:semicolon
id|pkt_dev-&gt;cur_udp_dst
op_assign
id|value
suffix:semicolon
)brace
id|sprintf
c_func
(paren
id|pg_result
comma
l_string|&quot;OK: udp_dst_max=%u&quot;
comma
id|pkt_dev-&gt;udp_dst_max
)paren
suffix:semicolon
r_return
id|count
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|name
comma
l_string|&quot;clone_skb&quot;
)paren
)paren
(brace
id|len
op_assign
id|num_arg
c_func
(paren
op_amp
id|user_buffer
(braket
id|i
)braket
comma
l_int|10
comma
op_amp
id|value
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
l_int|0
)paren
(brace
r_return
id|len
suffix:semicolon
)brace
id|i
op_add_assign
id|len
suffix:semicolon
id|pkt_dev-&gt;clone_skb
op_assign
id|value
suffix:semicolon
id|sprintf
c_func
(paren
id|pg_result
comma
l_string|&quot;OK: clone_skb=%d&quot;
comma
id|pkt_dev-&gt;clone_skb
)paren
suffix:semicolon
r_return
id|count
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|name
comma
l_string|&quot;count&quot;
)paren
)paren
(brace
id|len
op_assign
id|num_arg
c_func
(paren
op_amp
id|user_buffer
(braket
id|i
)braket
comma
l_int|10
comma
op_amp
id|value
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
l_int|0
)paren
(brace
r_return
id|len
suffix:semicolon
)brace
id|i
op_add_assign
id|len
suffix:semicolon
id|pkt_dev-&gt;count
op_assign
id|value
suffix:semicolon
id|sprintf
c_func
(paren
id|pg_result
comma
l_string|&quot;OK: count=%llu&quot;
comma
(paren
r_int
r_int
r_int
)paren
id|pkt_dev-&gt;count
)paren
suffix:semicolon
r_return
id|count
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|name
comma
l_string|&quot;src_mac_count&quot;
)paren
)paren
(brace
id|len
op_assign
id|num_arg
c_func
(paren
op_amp
id|user_buffer
(braket
id|i
)braket
comma
l_int|10
comma
op_amp
id|value
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
l_int|0
)paren
(brace
r_return
id|len
suffix:semicolon
)brace
id|i
op_add_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
id|pkt_dev-&gt;src_mac_count
op_ne
id|value
)paren
(brace
id|pkt_dev-&gt;src_mac_count
op_assign
id|value
suffix:semicolon
id|pkt_dev-&gt;cur_src_mac_offset
op_assign
l_int|0
suffix:semicolon
)brace
id|sprintf
c_func
(paren
id|pg_result
comma
l_string|&quot;OK: src_mac_count=%d&quot;
comma
id|pkt_dev-&gt;src_mac_count
)paren
suffix:semicolon
r_return
id|count
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|name
comma
l_string|&quot;dst_mac_count&quot;
)paren
)paren
(brace
id|len
op_assign
id|num_arg
c_func
(paren
op_amp
id|user_buffer
(braket
id|i
)braket
comma
l_int|10
comma
op_amp
id|value
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
l_int|0
)paren
(brace
r_return
id|len
suffix:semicolon
)brace
id|i
op_add_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
id|pkt_dev-&gt;dst_mac_count
op_ne
id|value
)paren
(brace
id|pkt_dev-&gt;dst_mac_count
op_assign
id|value
suffix:semicolon
id|pkt_dev-&gt;cur_dst_mac_offset
op_assign
l_int|0
suffix:semicolon
)brace
id|sprintf
c_func
(paren
id|pg_result
comma
l_string|&quot;OK: dst_mac_count=%d&quot;
comma
id|pkt_dev-&gt;dst_mac_count
)paren
suffix:semicolon
r_return
id|count
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|name
comma
l_string|&quot;flag&quot;
)paren
)paren
(brace
r_char
id|f
(braket
l_int|32
)braket
suffix:semicolon
id|memset
c_func
(paren
id|f
comma
l_int|0
comma
l_int|32
)paren
suffix:semicolon
id|len
op_assign
id|strn_len
c_func
(paren
op_amp
id|user_buffer
(braket
id|i
)braket
comma
r_sizeof
(paren
id|f
)paren
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
l_int|0
)paren
(brace
r_return
id|len
suffix:semicolon
)brace
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|f
comma
op_amp
id|user_buffer
(braket
id|i
)braket
comma
id|len
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|i
op_add_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|f
comma
l_string|&quot;IPSRC_RND&quot;
)paren
op_eq
l_int|0
)paren
id|pkt_dev-&gt;flags
op_or_assign
id|F_IPSRC_RND
suffix:semicolon
r_else
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|f
comma
l_string|&quot;!IPSRC_RND&quot;
)paren
op_eq
l_int|0
)paren
id|pkt_dev-&gt;flags
op_and_assign
op_complement
id|F_IPSRC_RND
suffix:semicolon
r_else
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|f
comma
l_string|&quot;TXSIZE_RND&quot;
)paren
op_eq
l_int|0
)paren
id|pkt_dev-&gt;flags
op_or_assign
id|F_TXSIZE_RND
suffix:semicolon
r_else
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|f
comma
l_string|&quot;!TXSIZE_RND&quot;
)paren
op_eq
l_int|0
)paren
id|pkt_dev-&gt;flags
op_and_assign
op_complement
id|F_TXSIZE_RND
suffix:semicolon
r_else
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|f
comma
l_string|&quot;IPDST_RND&quot;
)paren
op_eq
l_int|0
)paren
id|pkt_dev-&gt;flags
op_or_assign
id|F_IPDST_RND
suffix:semicolon
r_else
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|f
comma
l_string|&quot;!IPDST_RND&quot;
)paren
op_eq
l_int|0
)paren
id|pkt_dev-&gt;flags
op_and_assign
op_complement
id|F_IPDST_RND
suffix:semicolon
r_else
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|f
comma
l_string|&quot;UDPSRC_RND&quot;
)paren
op_eq
l_int|0
)paren
id|pkt_dev-&gt;flags
op_or_assign
id|F_UDPSRC_RND
suffix:semicolon
r_else
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|f
comma
l_string|&quot;!UDPSRC_RND&quot;
)paren
op_eq
l_int|0
)paren
id|pkt_dev-&gt;flags
op_and_assign
op_complement
id|F_UDPSRC_RND
suffix:semicolon
r_else
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|f
comma
l_string|&quot;UDPDST_RND&quot;
)paren
op_eq
l_int|0
)paren
id|pkt_dev-&gt;flags
op_or_assign
id|F_UDPDST_RND
suffix:semicolon
r_else
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|f
comma
l_string|&quot;!UDPDST_RND&quot;
)paren
op_eq
l_int|0
)paren
id|pkt_dev-&gt;flags
op_and_assign
op_complement
id|F_UDPDST_RND
suffix:semicolon
r_else
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|f
comma
l_string|&quot;MACSRC_RND&quot;
)paren
op_eq
l_int|0
)paren
id|pkt_dev-&gt;flags
op_or_assign
id|F_MACSRC_RND
suffix:semicolon
r_else
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|f
comma
l_string|&quot;!MACSRC_RND&quot;
)paren
op_eq
l_int|0
)paren
id|pkt_dev-&gt;flags
op_and_assign
op_complement
id|F_MACSRC_RND
suffix:semicolon
r_else
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|f
comma
l_string|&quot;MACDST_RND&quot;
)paren
op_eq
l_int|0
)paren
id|pkt_dev-&gt;flags
op_or_assign
id|F_MACDST_RND
suffix:semicolon
r_else
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|f
comma
l_string|&quot;!MACDST_RND&quot;
)paren
op_eq
l_int|0
)paren
id|pkt_dev-&gt;flags
op_and_assign
op_complement
id|F_MACDST_RND
suffix:semicolon
r_else
(brace
id|sprintf
c_func
(paren
id|pg_result
comma
l_string|&quot;Flag -:%s:- unknown&bslash;nAvailable flags, (prepend ! to un-set flag):&bslash;n%s&quot;
comma
id|f
comma
l_string|&quot;IPSRC_RND, IPDST_RND, TXSIZE_RND, UDPSRC_RND, UDPDST_RND, MACSRC_RND, MACDST_RND&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|count
suffix:semicolon
)brace
id|sprintf
c_func
(paren
id|pg_result
comma
l_string|&quot;OK: flags=0x%x&quot;
comma
id|pkt_dev-&gt;flags
)paren
suffix:semicolon
r_return
id|count
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|name
comma
l_string|&quot;dst_min&quot;
)paren
op_logical_or
op_logical_neg
id|strcmp
c_func
(paren
id|name
comma
l_string|&quot;dst&quot;
)paren
)paren
(brace
r_char
id|buf
(braket
id|IP_NAME_SZ
)braket
suffix:semicolon
id|len
op_assign
id|strn_len
c_func
(paren
op_amp
id|user_buffer
(braket
id|i
)braket
comma
r_sizeof
(paren
id|pkt_dev-&gt;dst_min
)paren
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
l_int|0
)paren
(brace
r_return
id|len
suffix:semicolon
)brace
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|buf
comma
op_amp
id|user_buffer
(braket
id|i
)braket
comma
id|len
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|buf
(braket
id|len
)braket
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|buf
comma
id|pkt_dev-&gt;dst_min
)paren
op_ne
l_int|0
)paren
(brace
id|memset
c_func
(paren
id|pkt_dev-&gt;dst_min
comma
l_int|0
comma
r_sizeof
(paren
id|pkt_dev-&gt;dst_min
)paren
)paren
suffix:semicolon
id|strncpy
c_func
(paren
id|pkt_dev-&gt;dst_min
comma
id|buf
comma
id|len
)paren
suffix:semicolon
id|pkt_dev-&gt;daddr_min
op_assign
id|in_aton
c_func
(paren
id|pkt_dev-&gt;dst_min
)paren
suffix:semicolon
id|pkt_dev-&gt;cur_daddr
op_assign
id|pkt_dev-&gt;daddr_min
suffix:semicolon
)brace
r_if
c_cond
(paren
id|debug
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;pktgen: dst_min set to: %s&bslash;n&quot;
comma
id|pkt_dev-&gt;dst_min
)paren
suffix:semicolon
)brace
id|i
op_add_assign
id|len
suffix:semicolon
id|sprintf
c_func
(paren
id|pg_result
comma
l_string|&quot;OK: dst_min=%s&quot;
comma
id|pkt_dev-&gt;dst_min
)paren
suffix:semicolon
r_return
id|count
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|name
comma
l_string|&quot;dst_max&quot;
)paren
)paren
(brace
r_char
id|buf
(braket
id|IP_NAME_SZ
)braket
suffix:semicolon
id|len
op_assign
id|strn_len
c_func
(paren
op_amp
id|user_buffer
(braket
id|i
)braket
comma
r_sizeof
(paren
id|pkt_dev-&gt;dst_max
)paren
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
l_int|0
)paren
(brace
r_return
id|len
suffix:semicolon
)brace
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|buf
comma
op_amp
id|user_buffer
(braket
id|i
)braket
comma
id|len
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|buf
(braket
id|len
)braket
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|buf
comma
id|pkt_dev-&gt;dst_max
)paren
op_ne
l_int|0
)paren
(brace
id|memset
c_func
(paren
id|pkt_dev-&gt;dst_max
comma
l_int|0
comma
r_sizeof
(paren
id|pkt_dev-&gt;dst_max
)paren
)paren
suffix:semicolon
id|strncpy
c_func
(paren
id|pkt_dev-&gt;dst_max
comma
id|buf
comma
id|len
)paren
suffix:semicolon
id|pkt_dev-&gt;daddr_max
op_assign
id|in_aton
c_func
(paren
id|pkt_dev-&gt;dst_max
)paren
suffix:semicolon
id|pkt_dev-&gt;cur_daddr
op_assign
id|pkt_dev-&gt;daddr_max
suffix:semicolon
)brace
r_if
c_cond
(paren
id|debug
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;pktgen: dst_max set to: %s&bslash;n&quot;
comma
id|pkt_dev-&gt;dst_max
)paren
suffix:semicolon
)brace
id|i
op_add_assign
id|len
suffix:semicolon
id|sprintf
c_func
(paren
id|pg_result
comma
l_string|&quot;OK: dst_max=%s&quot;
comma
id|pkt_dev-&gt;dst_max
)paren
suffix:semicolon
r_return
id|count
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|name
comma
l_string|&quot;dst6&quot;
)paren
)paren
(brace
r_char
id|buf
(braket
l_int|128
)braket
suffix:semicolon
id|len
op_assign
id|strn_len
c_func
(paren
op_amp
id|user_buffer
(braket
id|i
)braket
comma
l_int|128
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
l_int|0
)paren
r_return
id|len
suffix:semicolon
id|pkt_dev-&gt;flags
op_or_assign
id|F_IPV6
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|buf
comma
op_amp
id|user_buffer
(braket
id|i
)braket
comma
id|len
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|buf
(braket
id|len
)braket
op_assign
l_int|0
suffix:semicolon
id|scan_ip6
c_func
(paren
id|buf
comma
id|pkt_dev-&gt;in6_daddr.s6_addr
)paren
suffix:semicolon
id|fmt_ip6
c_func
(paren
id|buf
comma
id|pkt_dev-&gt;in6_daddr.s6_addr
)paren
suffix:semicolon
id|ipv6_addr_copy
c_func
(paren
op_amp
id|pkt_dev-&gt;cur_in6_daddr
comma
op_amp
id|pkt_dev-&gt;in6_daddr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|debug
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;pktgen: dst6 set to: %s&bslash;n&quot;
comma
id|buf
)paren
suffix:semicolon
)brace
id|i
op_add_assign
id|len
suffix:semicolon
id|sprintf
c_func
(paren
id|pg_result
comma
l_string|&quot;OK: dst6=%s&quot;
comma
id|buf
)paren
suffix:semicolon
r_return
id|count
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|name
comma
l_string|&quot;dst6_min&quot;
)paren
)paren
(brace
r_char
id|buf
(braket
l_int|128
)braket
suffix:semicolon
id|len
op_assign
id|strn_len
c_func
(paren
op_amp
id|user_buffer
(braket
id|i
)braket
comma
l_int|128
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
l_int|0
)paren
r_return
id|len
suffix:semicolon
id|pkt_dev-&gt;flags
op_or_assign
id|F_IPV6
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|buf
comma
op_amp
id|user_buffer
(braket
id|i
)braket
comma
id|len
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|buf
(braket
id|len
)braket
op_assign
l_int|0
suffix:semicolon
id|scan_ip6
c_func
(paren
id|buf
comma
id|pkt_dev-&gt;min_in6_daddr.s6_addr
)paren
suffix:semicolon
id|fmt_ip6
c_func
(paren
id|buf
comma
id|pkt_dev-&gt;min_in6_daddr.s6_addr
)paren
suffix:semicolon
id|ipv6_addr_copy
c_func
(paren
op_amp
id|pkt_dev-&gt;cur_in6_daddr
comma
op_amp
id|pkt_dev-&gt;min_in6_daddr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|debug
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;pktgen: dst6_min set to: %s&bslash;n&quot;
comma
id|buf
)paren
suffix:semicolon
)brace
id|i
op_add_assign
id|len
suffix:semicolon
id|sprintf
c_func
(paren
id|pg_result
comma
l_string|&quot;OK: dst6_min=%s&quot;
comma
id|buf
)paren
suffix:semicolon
r_return
id|count
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|name
comma
l_string|&quot;dst6_max&quot;
)paren
)paren
(brace
r_char
id|buf
(braket
l_int|128
)braket
suffix:semicolon
id|len
op_assign
id|strn_len
c_func
(paren
op_amp
id|user_buffer
(braket
id|i
)braket
comma
l_int|128
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
l_int|0
)paren
r_return
id|len
suffix:semicolon
id|pkt_dev-&gt;flags
op_or_assign
id|F_IPV6
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|buf
comma
op_amp
id|user_buffer
(braket
id|i
)braket
comma
id|len
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|buf
(braket
id|len
)braket
op_assign
l_int|0
suffix:semicolon
id|scan_ip6
c_func
(paren
id|buf
comma
id|pkt_dev-&gt;max_in6_daddr.s6_addr
)paren
suffix:semicolon
id|fmt_ip6
c_func
(paren
id|buf
comma
id|pkt_dev-&gt;max_in6_daddr.s6_addr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|debug
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;pktgen: dst6_max set to: %s&bslash;n&quot;
comma
id|buf
)paren
suffix:semicolon
)brace
id|i
op_add_assign
id|len
suffix:semicolon
id|sprintf
c_func
(paren
id|pg_result
comma
l_string|&quot;OK: dst6_max=%s&quot;
comma
id|buf
)paren
suffix:semicolon
r_return
id|count
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|name
comma
l_string|&quot;src6&quot;
)paren
)paren
(brace
r_char
id|buf
(braket
l_int|128
)braket
suffix:semicolon
id|len
op_assign
id|strn_len
c_func
(paren
op_amp
id|user_buffer
(braket
id|i
)braket
comma
l_int|128
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
l_int|0
)paren
r_return
id|len
suffix:semicolon
id|pkt_dev-&gt;flags
op_or_assign
id|F_IPV6
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|buf
comma
op_amp
id|user_buffer
(braket
id|i
)braket
comma
id|len
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|buf
(braket
id|len
)braket
op_assign
l_int|0
suffix:semicolon
id|scan_ip6
c_func
(paren
id|buf
comma
id|pkt_dev-&gt;in6_saddr.s6_addr
)paren
suffix:semicolon
id|fmt_ip6
c_func
(paren
id|buf
comma
id|pkt_dev-&gt;in6_saddr.s6_addr
)paren
suffix:semicolon
id|ipv6_addr_copy
c_func
(paren
op_amp
id|pkt_dev-&gt;cur_in6_saddr
comma
op_amp
id|pkt_dev-&gt;in6_saddr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|debug
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;pktgen: src6 set to: %s&bslash;n&quot;
comma
id|buf
)paren
suffix:semicolon
)brace
id|i
op_add_assign
id|len
suffix:semicolon
id|sprintf
c_func
(paren
id|pg_result
comma
l_string|&quot;OK: src6=%s&quot;
comma
id|buf
)paren
suffix:semicolon
r_return
id|count
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|name
comma
l_string|&quot;src_min&quot;
)paren
)paren
(brace
r_char
id|buf
(braket
id|IP_NAME_SZ
)braket
suffix:semicolon
id|len
op_assign
id|strn_len
c_func
(paren
op_amp
id|user_buffer
(braket
id|i
)braket
comma
r_sizeof
(paren
id|pkt_dev-&gt;src_min
)paren
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
l_int|0
)paren
(brace
r_return
id|len
suffix:semicolon
)brace
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|buf
comma
op_amp
id|user_buffer
(braket
id|i
)braket
comma
id|len
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|buf
(braket
id|len
)braket
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|buf
comma
id|pkt_dev-&gt;src_min
)paren
op_ne
l_int|0
)paren
(brace
id|memset
c_func
(paren
id|pkt_dev-&gt;src_min
comma
l_int|0
comma
r_sizeof
(paren
id|pkt_dev-&gt;src_min
)paren
)paren
suffix:semicolon
id|strncpy
c_func
(paren
id|pkt_dev-&gt;src_min
comma
id|buf
comma
id|len
)paren
suffix:semicolon
id|pkt_dev-&gt;saddr_min
op_assign
id|in_aton
c_func
(paren
id|pkt_dev-&gt;src_min
)paren
suffix:semicolon
id|pkt_dev-&gt;cur_saddr
op_assign
id|pkt_dev-&gt;saddr_min
suffix:semicolon
)brace
r_if
c_cond
(paren
id|debug
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;pktgen: src_min set to: %s&bslash;n&quot;
comma
id|pkt_dev-&gt;src_min
)paren
suffix:semicolon
)brace
id|i
op_add_assign
id|len
suffix:semicolon
id|sprintf
c_func
(paren
id|pg_result
comma
l_string|&quot;OK: src_min=%s&quot;
comma
id|pkt_dev-&gt;src_min
)paren
suffix:semicolon
r_return
id|count
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|name
comma
l_string|&quot;src_max&quot;
)paren
)paren
(brace
r_char
id|buf
(braket
id|IP_NAME_SZ
)braket
suffix:semicolon
id|len
op_assign
id|strn_len
c_func
(paren
op_amp
id|user_buffer
(braket
id|i
)braket
comma
r_sizeof
(paren
id|pkt_dev-&gt;src_max
)paren
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
l_int|0
)paren
(brace
r_return
id|len
suffix:semicolon
)brace
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|buf
comma
op_amp
id|user_buffer
(braket
id|i
)braket
comma
id|len
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|buf
(braket
id|len
)braket
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|buf
comma
id|pkt_dev-&gt;src_max
)paren
op_ne
l_int|0
)paren
(brace
id|memset
c_func
(paren
id|pkt_dev-&gt;src_max
comma
l_int|0
comma
r_sizeof
(paren
id|pkt_dev-&gt;src_max
)paren
)paren
suffix:semicolon
id|strncpy
c_func
(paren
id|pkt_dev-&gt;src_max
comma
id|buf
comma
id|len
)paren
suffix:semicolon
id|pkt_dev-&gt;saddr_max
op_assign
id|in_aton
c_func
(paren
id|pkt_dev-&gt;src_max
)paren
suffix:semicolon
id|pkt_dev-&gt;cur_saddr
op_assign
id|pkt_dev-&gt;saddr_max
suffix:semicolon
)brace
r_if
c_cond
(paren
id|debug
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;pktgen: src_max set to: %s&bslash;n&quot;
comma
id|pkt_dev-&gt;src_max
)paren
suffix:semicolon
)brace
id|i
op_add_assign
id|len
suffix:semicolon
id|sprintf
c_func
(paren
id|pg_result
comma
l_string|&quot;OK: src_max=%s&quot;
comma
id|pkt_dev-&gt;src_max
)paren
suffix:semicolon
r_return
id|count
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|name
comma
l_string|&quot;dst_mac&quot;
)paren
)paren
(brace
r_char
op_star
id|v
op_assign
id|valstr
suffix:semicolon
r_int
r_char
id|old_dmac
(braket
l_int|6
)braket
suffix:semicolon
r_int
r_char
op_star
id|m
op_assign
id|pkt_dev-&gt;dst_mac
suffix:semicolon
id|memcpy
c_func
(paren
id|old_dmac
comma
id|pkt_dev-&gt;dst_mac
comma
l_int|6
)paren
suffix:semicolon
id|len
op_assign
id|strn_len
c_func
(paren
op_amp
id|user_buffer
(braket
id|i
)braket
comma
r_sizeof
(paren
id|valstr
)paren
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
l_int|0
)paren
(brace
r_return
id|len
suffix:semicolon
)brace
id|memset
c_func
(paren
id|valstr
comma
l_int|0
comma
r_sizeof
(paren
id|valstr
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|valstr
comma
op_amp
id|user_buffer
(braket
id|i
)braket
comma
id|len
)paren
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
id|i
op_add_assign
id|len
suffix:semicolon
r_for
c_loop
(paren
op_star
id|m
op_assign
l_int|0
suffix:semicolon
op_star
id|v
op_logical_and
id|m
OL
id|pkt_dev-&gt;dst_mac
op_plus
l_int|6
suffix:semicolon
id|v
op_increment
)paren
(brace
r_if
c_cond
(paren
op_star
id|v
op_ge
l_char|&squot;0&squot;
op_logical_and
op_star
id|v
op_le
l_char|&squot;9&squot;
)paren
(brace
op_star
id|m
op_mul_assign
l_int|16
suffix:semicolon
op_star
id|m
op_add_assign
op_star
id|v
op_minus
l_char|&squot;0&squot;
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|v
op_ge
l_char|&squot;A&squot;
op_logical_and
op_star
id|v
op_le
l_char|&squot;F&squot;
)paren
(brace
op_star
id|m
op_mul_assign
l_int|16
suffix:semicolon
op_star
id|m
op_add_assign
op_star
id|v
op_minus
l_char|&squot;A&squot;
op_plus
l_int|10
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|v
op_ge
l_char|&squot;a&squot;
op_logical_and
op_star
id|v
op_le
l_char|&squot;f&squot;
)paren
(brace
op_star
id|m
op_mul_assign
l_int|16
suffix:semicolon
op_star
id|m
op_add_assign
op_star
id|v
op_minus
l_char|&squot;a&squot;
op_plus
l_int|10
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|v
op_eq
l_char|&squot;:&squot;
)paren
(brace
id|m
op_increment
suffix:semicolon
op_star
id|m
op_assign
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/* Set up Dest MAC */
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|old_dmac
comma
id|pkt_dev-&gt;dst_mac
comma
l_int|6
)paren
op_ne
l_int|0
)paren
id|memcpy
c_func
(paren
op_amp
(paren
id|pkt_dev-&gt;hh
(braket
l_int|0
)braket
)paren
comma
id|pkt_dev-&gt;dst_mac
comma
l_int|6
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|pg_result
comma
l_string|&quot;OK: dstmac&quot;
)paren
suffix:semicolon
r_return
id|count
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|name
comma
l_string|&quot;src_mac&quot;
)paren
)paren
(brace
r_char
op_star
id|v
op_assign
id|valstr
suffix:semicolon
r_int
r_char
op_star
id|m
op_assign
id|pkt_dev-&gt;src_mac
suffix:semicolon
id|len
op_assign
id|strn_len
c_func
(paren
op_amp
id|user_buffer
(braket
id|i
)braket
comma
r_sizeof
(paren
id|valstr
)paren
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
l_int|0
)paren
(brace
r_return
id|len
suffix:semicolon
)brace
id|memset
c_func
(paren
id|valstr
comma
l_int|0
comma
r_sizeof
(paren
id|valstr
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|valstr
comma
op_amp
id|user_buffer
(braket
id|i
)braket
comma
id|len
)paren
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
id|i
op_add_assign
id|len
suffix:semicolon
r_for
c_loop
(paren
op_star
id|m
op_assign
l_int|0
suffix:semicolon
op_star
id|v
op_logical_and
id|m
OL
id|pkt_dev-&gt;src_mac
op_plus
l_int|6
suffix:semicolon
id|v
op_increment
)paren
(brace
r_if
c_cond
(paren
op_star
id|v
op_ge
l_char|&squot;0&squot;
op_logical_and
op_star
id|v
op_le
l_char|&squot;9&squot;
)paren
(brace
op_star
id|m
op_mul_assign
l_int|16
suffix:semicolon
op_star
id|m
op_add_assign
op_star
id|v
op_minus
l_char|&squot;0&squot;
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|v
op_ge
l_char|&squot;A&squot;
op_logical_and
op_star
id|v
op_le
l_char|&squot;F&squot;
)paren
(brace
op_star
id|m
op_mul_assign
l_int|16
suffix:semicolon
op_star
id|m
op_add_assign
op_star
id|v
op_minus
l_char|&squot;A&squot;
op_plus
l_int|10
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|v
op_ge
l_char|&squot;a&squot;
op_logical_and
op_star
id|v
op_le
l_char|&squot;f&squot;
)paren
(brace
op_star
id|m
op_mul_assign
l_int|16
suffix:semicolon
op_star
id|m
op_add_assign
op_star
id|v
op_minus
l_char|&squot;a&squot;
op_plus
l_int|10
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|v
op_eq
l_char|&squot;:&squot;
)paren
(brace
id|m
op_increment
suffix:semicolon
op_star
id|m
op_assign
l_int|0
suffix:semicolon
)brace
)brace
id|sprintf
c_func
(paren
id|pg_result
comma
l_string|&quot;OK: srcmac&quot;
)paren
suffix:semicolon
r_return
id|count
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|name
comma
l_string|&quot;clear_counters&quot;
)paren
)paren
(brace
id|pktgen_clear_counters
c_func
(paren
id|pkt_dev
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|pg_result
comma
l_string|&quot;OK: Clearing counters.&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|count
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|name
comma
l_string|&quot;flows&quot;
)paren
)paren
(brace
id|len
op_assign
id|num_arg
c_func
(paren
op_amp
id|user_buffer
(braket
id|i
)braket
comma
l_int|10
comma
op_amp
id|value
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
l_int|0
)paren
(brace
r_return
id|len
suffix:semicolon
)brace
id|i
op_add_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
id|value
OG
id|MAX_CFLOWS
)paren
id|value
op_assign
id|MAX_CFLOWS
suffix:semicolon
id|pkt_dev-&gt;cflows
op_assign
id|value
suffix:semicolon
id|sprintf
c_func
(paren
id|pg_result
comma
l_string|&quot;OK: flows=%u&quot;
comma
id|pkt_dev-&gt;cflows
)paren
suffix:semicolon
r_return
id|count
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|name
comma
l_string|&quot;flowlen&quot;
)paren
)paren
(brace
id|len
op_assign
id|num_arg
c_func
(paren
op_amp
id|user_buffer
(braket
id|i
)braket
comma
l_int|10
comma
op_amp
id|value
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
l_int|0
)paren
(brace
r_return
id|len
suffix:semicolon
)brace
id|i
op_add_assign
id|len
suffix:semicolon
id|pkt_dev-&gt;lflow
op_assign
id|value
suffix:semicolon
id|sprintf
c_func
(paren
id|pg_result
comma
l_string|&quot;OK: flowlen=%u&quot;
comma
id|pkt_dev-&gt;lflow
)paren
suffix:semicolon
r_return
id|count
suffix:semicolon
)brace
id|sprintf
c_func
(paren
id|pkt_dev-&gt;result
comma
l_string|&quot;No such parameter &bslash;&quot;%s&bslash;&quot;&quot;
comma
id|name
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
DECL|function|proc_thread_read
r_static
r_int
id|proc_thread_read
c_func
(paren
r_char
op_star
id|buf
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|len
comma
r_int
op_star
id|eof
comma
r_void
op_star
id|data
)paren
(brace
r_char
op_star
id|p
suffix:semicolon
r_struct
id|pktgen_thread
op_star
id|t
op_assign
(paren
r_struct
id|pktgen_thread
op_star
)paren
(paren
id|data
)paren
suffix:semicolon
r_struct
id|pktgen_dev
op_star
id|pkt_dev
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|t
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;pktgen: ERROR: could not find thread in proc_thread_read&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|p
op_assign
id|buf
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;Name: %s  max_before_softirq: %d&bslash;n&quot;
comma
id|t-&gt;name
comma
id|t-&gt;max_before_softirq
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;Running: &quot;
)paren
suffix:semicolon
id|if_lock
c_func
(paren
id|t
)paren
suffix:semicolon
id|pkt_dev
op_assign
id|t-&gt;if_list
suffix:semicolon
r_while
c_loop
(paren
id|pkt_dev
op_logical_and
id|pkt_dev-&gt;running
)paren
(brace
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;%s &quot;
comma
id|pkt_dev-&gt;ifname
)paren
suffix:semicolon
id|pkt_dev
op_assign
id|pkt_dev-&gt;next
suffix:semicolon
)brace
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;&bslash;nStopped: &quot;
)paren
suffix:semicolon
id|pkt_dev
op_assign
id|t-&gt;if_list
suffix:semicolon
r_while
c_loop
(paren
id|pkt_dev
op_logical_and
op_logical_neg
id|pkt_dev-&gt;running
)paren
(brace
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;%s &quot;
comma
id|pkt_dev-&gt;ifname
)paren
suffix:semicolon
id|pkt_dev
op_assign
id|pkt_dev-&gt;next
suffix:semicolon
)brace
r_if
c_cond
(paren
id|t-&gt;result
(braket
l_int|0
)braket
)paren
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;&bslash;nResult: %s&bslash;n&quot;
comma
id|t-&gt;result
)paren
suffix:semicolon
r_else
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;&bslash;nResult: NA&bslash;n&quot;
)paren
suffix:semicolon
op_star
id|eof
op_assign
l_int|1
suffix:semicolon
id|if_unlock
c_func
(paren
id|t
)paren
suffix:semicolon
r_return
id|p
op_minus
id|buf
suffix:semicolon
)brace
DECL|function|proc_thread_write
r_static
r_int
id|proc_thread_write
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_const
r_char
op_star
id|user_buffer
comma
r_int
r_int
id|count
comma
r_void
op_star
id|data
)paren
(brace
r_int
id|i
op_assign
l_int|0
comma
id|max
comma
id|len
comma
id|ret
suffix:semicolon
r_char
id|name
(braket
l_int|40
)braket
suffix:semicolon
r_struct
id|pktgen_thread
op_star
id|t
suffix:semicolon
r_char
op_star
id|pg_result
suffix:semicolon
r_int
r_int
id|value
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|count
OL
l_int|1
)paren
(brace
singleline_comment|//&t;sprintf(pg_result, &quot;Wrong command format&quot;);
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|max
op_assign
id|count
op_minus
id|i
suffix:semicolon
id|len
op_assign
id|count_trail_chars
c_func
(paren
op_amp
id|user_buffer
(braket
id|i
)braket
comma
id|max
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
l_int|0
)paren
r_return
id|len
suffix:semicolon
id|i
op_add_assign
id|len
suffix:semicolon
multiline_comment|/* Read variable name */
id|len
op_assign
id|strn_len
c_func
(paren
op_amp
id|user_buffer
(braket
id|i
)braket
comma
r_sizeof
(paren
id|name
)paren
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
l_int|0
)paren
r_return
id|len
suffix:semicolon
id|memset
c_func
(paren
id|name
comma
l_int|0
comma
r_sizeof
(paren
id|name
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|name
comma
op_amp
id|user_buffer
(braket
id|i
)braket
comma
id|len
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|i
op_add_assign
id|len
suffix:semicolon
id|max
op_assign
id|count
op_minus
id|i
suffix:semicolon
id|len
op_assign
id|count_trail_chars
c_func
(paren
op_amp
id|user_buffer
(braket
id|i
)braket
comma
id|max
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
l_int|0
)paren
r_return
id|len
suffix:semicolon
id|i
op_add_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
id|debug
)paren
id|printk
c_func
(paren
l_string|&quot;pktgen: t=%s, count=%lu&bslash;n&quot;
comma
id|name
comma
id|count
)paren
suffix:semicolon
id|thread_lock
c_func
(paren
)paren
suffix:semicolon
id|t
op_assign
(paren
r_struct
id|pktgen_thread
op_star
)paren
(paren
id|data
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|t
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;pktgen: ERROR: No thread&bslash;n&quot;
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|pg_result
op_assign
op_amp
(paren
id|t-&gt;result
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|name
comma
l_string|&quot;add_device&quot;
)paren
)paren
(brace
r_char
id|f
(braket
l_int|32
)braket
suffix:semicolon
id|memset
c_func
(paren
id|f
comma
l_int|0
comma
l_int|32
)paren
suffix:semicolon
id|len
op_assign
id|strn_len
c_func
(paren
op_amp
id|user_buffer
(braket
id|i
)braket
comma
r_sizeof
(paren
id|f
)paren
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
l_int|0
)paren
(brace
id|ret
op_assign
id|len
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|f
comma
op_amp
id|user_buffer
(braket
id|i
)braket
comma
id|len
)paren
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
id|i
op_add_assign
id|len
suffix:semicolon
id|pktgen_add_device
c_func
(paren
id|t
comma
id|f
)paren
suffix:semicolon
id|ret
op_assign
id|count
suffix:semicolon
id|sprintf
c_func
(paren
id|pg_result
comma
l_string|&quot;OK: add_device=%s&quot;
comma
id|f
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|name
comma
l_string|&quot;rem_device_all&quot;
)paren
)paren
(brace
id|t-&gt;control
op_or_assign
id|T_REMDEV
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|schedule_timeout
c_func
(paren
id|HZ
op_div
l_int|8
)paren
suffix:semicolon
multiline_comment|/* Propagate thread-&gt;control  */
id|ret
op_assign
id|count
suffix:semicolon
id|sprintf
c_func
(paren
id|pg_result
comma
l_string|&quot;OK: rem_device_all&quot;
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|name
comma
l_string|&quot;max_before_softirq&quot;
)paren
)paren
(brace
id|len
op_assign
id|num_arg
c_func
(paren
op_amp
id|user_buffer
(braket
id|i
)braket
comma
l_int|10
comma
op_amp
id|value
)paren
suffix:semicolon
id|t-&gt;max_before_softirq
op_assign
id|value
suffix:semicolon
id|ret
op_assign
id|count
suffix:semicolon
id|sprintf
c_func
(paren
id|pg_result
comma
l_string|&quot;OK: max_before_softirq=%lu&quot;
comma
id|value
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
id|out
suffix:colon
id|thread_unlock
c_func
(paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|create_proc_dir
r_static
r_int
id|create_proc_dir
c_func
(paren
r_void
)paren
(brace
r_int
id|len
suffix:semicolon
multiline_comment|/*  does proc_dir already exists */
id|len
op_assign
id|strlen
c_func
(paren
id|PG_PROC_DIR
)paren
suffix:semicolon
r_for
c_loop
(paren
id|pg_proc_dir
op_assign
id|proc_net-&gt;subdir
suffix:semicolon
id|pg_proc_dir
suffix:semicolon
id|pg_proc_dir
op_assign
id|pg_proc_dir-&gt;next
)paren
(brace
r_if
c_cond
(paren
(paren
id|pg_proc_dir-&gt;namelen
op_eq
id|len
)paren
op_logical_and
(paren
op_logical_neg
id|memcmp
c_func
(paren
id|pg_proc_dir-&gt;name
comma
id|PG_PROC_DIR
comma
id|len
)paren
)paren
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|pg_proc_dir
)paren
id|pg_proc_dir
op_assign
id|create_proc_entry
c_func
(paren
id|PG_PROC_DIR
comma
id|S_IFDIR
comma
id|proc_net
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pg_proc_dir
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|remove_proc_dir
r_static
r_int
id|remove_proc_dir
c_func
(paren
r_void
)paren
(brace
id|remove_proc_entry
c_func
(paren
id|PG_PROC_DIR
comma
id|proc_net
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Think find or remove for NN */
DECL|function|__pktgen_NN_threads
r_static
r_struct
id|pktgen_dev
op_star
id|__pktgen_NN_threads
c_func
(paren
r_const
r_char
op_star
id|ifname
comma
r_int
id|remove
)paren
(brace
r_struct
id|pktgen_thread
op_star
id|t
suffix:semicolon
r_struct
id|pktgen_dev
op_star
id|pkt_dev
op_assign
l_int|NULL
suffix:semicolon
id|t
op_assign
id|pktgen_threads
suffix:semicolon
r_while
c_loop
(paren
id|t
)paren
(brace
id|pkt_dev
op_assign
id|pktgen_find_dev
c_func
(paren
id|t
comma
id|ifname
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pkt_dev
)paren
(brace
r_if
c_cond
(paren
id|remove
)paren
(brace
id|if_lock
c_func
(paren
id|t
)paren
suffix:semicolon
id|pktgen_remove_device
c_func
(paren
id|t
comma
id|pkt_dev
)paren
suffix:semicolon
id|if_unlock
c_func
(paren
id|t
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
id|t
op_assign
id|t-&gt;next
suffix:semicolon
)brace
r_return
id|pkt_dev
suffix:semicolon
)brace
DECL|function|pktgen_NN_threads
r_static
r_struct
id|pktgen_dev
op_star
id|pktgen_NN_threads
c_func
(paren
r_const
r_char
op_star
id|ifname
comma
r_int
id|remove
)paren
(brace
r_struct
id|pktgen_dev
op_star
id|pkt_dev
op_assign
l_int|NULL
suffix:semicolon
id|thread_lock
c_func
(paren
)paren
suffix:semicolon
id|pkt_dev
op_assign
id|__pktgen_NN_threads
c_func
(paren
id|ifname
comma
id|remove
)paren
suffix:semicolon
id|thread_unlock
c_func
(paren
)paren
suffix:semicolon
r_return
id|pkt_dev
suffix:semicolon
)brace
DECL|function|pktgen_device_event
r_static
r_int
id|pktgen_device_event
c_func
(paren
r_struct
id|notifier_block
op_star
id|unused
comma
r_int
r_int
id|event
comma
r_void
op_star
id|ptr
)paren
(brace
r_struct
id|net_device
op_star
id|dev
op_assign
(paren
r_struct
id|net_device
op_star
)paren
(paren
id|ptr
)paren
suffix:semicolon
multiline_comment|/* It is OK that we do not hold the group lock right now,&n;&t; * as we run under the RTNL lock.&n;&t; */
r_switch
c_cond
(paren
id|event
)paren
(brace
r_case
id|NETDEV_CHANGEADDR
suffix:colon
r_case
id|NETDEV_GOING_DOWN
suffix:colon
r_case
id|NETDEV_DOWN
suffix:colon
r_case
id|NETDEV_UP
suffix:colon
multiline_comment|/* Ignore for now */
r_break
suffix:semicolon
r_case
id|NETDEV_UNREGISTER
suffix:colon
id|pktgen_NN_threads
c_func
(paren
id|dev-&gt;name
comma
id|REMOVE
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
suffix:semicolon
r_return
id|NOTIFY_DONE
suffix:semicolon
)brace
multiline_comment|/* Associate pktgen_dev with a device. */
DECL|function|pktgen_setup_dev
r_static
r_struct
id|net_device
op_star
id|pktgen_setup_dev
c_func
(paren
r_struct
id|pktgen_dev
op_star
id|pkt_dev
)paren
(brace
r_struct
id|net_device
op_star
id|odev
suffix:semicolon
multiline_comment|/* Clean old setups */
r_if
c_cond
(paren
id|pkt_dev-&gt;odev
)paren
(brace
id|dev_put
c_func
(paren
id|pkt_dev-&gt;odev
)paren
suffix:semicolon
id|pkt_dev-&gt;odev
op_assign
l_int|NULL
suffix:semicolon
)brace
id|odev
op_assign
id|dev_get_by_name
c_func
(paren
id|pkt_dev-&gt;ifname
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|odev
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;pktgen: no such netdevice: &bslash;&quot;%s&bslash;&quot;&bslash;n&quot;
comma
id|pkt_dev-&gt;ifname
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|odev-&gt;type
op_ne
id|ARPHRD_ETHER
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;pktgen: not an ethernet device: &bslash;&quot;%s&bslash;&quot;&bslash;n&quot;
comma
id|pkt_dev-&gt;ifname
)paren
suffix:semicolon
r_goto
id|out_put
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|netif_running
c_func
(paren
id|odev
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;pktgen: device is down: &bslash;&quot;%s&bslash;&quot;&bslash;n&quot;
comma
id|pkt_dev-&gt;ifname
)paren
suffix:semicolon
r_goto
id|out_put
suffix:semicolon
)brace
id|pkt_dev-&gt;odev
op_assign
id|odev
suffix:semicolon
r_return
id|pkt_dev-&gt;odev
suffix:semicolon
id|out_put
suffix:colon
id|dev_put
c_func
(paren
id|odev
)paren
suffix:semicolon
id|out
suffix:colon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Read pkt_dev from the interface and set up internal pktgen_dev&n; * structure to have the right information to create/send packets&n; */
DECL|function|pktgen_setup_inject
r_static
r_void
id|pktgen_setup_inject
c_func
(paren
r_struct
id|pktgen_dev
op_star
id|pkt_dev
)paren
(brace
multiline_comment|/* Try once more, just in case it works now. */
r_if
c_cond
(paren
op_logical_neg
id|pkt_dev-&gt;odev
)paren
id|pktgen_setup_dev
c_func
(paren
id|pkt_dev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pkt_dev-&gt;odev
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;pktgen: ERROR: pkt_dev-&gt;odev == NULL in setup_inject.&bslash;n&quot;
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|pkt_dev-&gt;result
comma
l_string|&quot;ERROR: pkt_dev-&gt;odev == NULL in setup_inject.&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Default to the interface&squot;s mac if not explicitly set. */
r_if
c_cond
(paren
(paren
id|pkt_dev-&gt;src_mac
(braket
l_int|0
)braket
op_eq
l_int|0
)paren
op_logical_and
(paren
id|pkt_dev-&gt;src_mac
(braket
l_int|1
)braket
op_eq
l_int|0
)paren
op_logical_and
(paren
id|pkt_dev-&gt;src_mac
(braket
l_int|2
)braket
op_eq
l_int|0
)paren
op_logical_and
(paren
id|pkt_dev-&gt;src_mac
(braket
l_int|3
)braket
op_eq
l_int|0
)paren
op_logical_and
(paren
id|pkt_dev-&gt;src_mac
(braket
l_int|4
)braket
op_eq
l_int|0
)paren
op_logical_and
(paren
id|pkt_dev-&gt;src_mac
(braket
l_int|5
)braket
op_eq
l_int|0
)paren
)paren
(brace
id|memcpy
c_func
(paren
op_amp
(paren
id|pkt_dev-&gt;hh
(braket
l_int|6
)braket
)paren
comma
id|pkt_dev-&gt;odev-&gt;dev_addr
comma
l_int|6
)paren
suffix:semicolon
)brace
multiline_comment|/* Set up Dest MAC */
id|memcpy
c_func
(paren
op_amp
(paren
id|pkt_dev-&gt;hh
(braket
l_int|0
)braket
)paren
comma
id|pkt_dev-&gt;dst_mac
comma
l_int|6
)paren
suffix:semicolon
multiline_comment|/* Set up pkt size */
id|pkt_dev-&gt;cur_pkt_size
op_assign
id|pkt_dev-&gt;min_pkt_size
suffix:semicolon
r_if
c_cond
(paren
id|pkt_dev-&gt;flags
op_amp
id|F_IPV6
)paren
(brace
multiline_comment|/*&n;&t;&t; * Skip this automatic address setting until locks or functions &n;&t;&t; * gets exported&n;&t;&t; */
macro_line|#ifdef NOTNOW
r_int
id|i
comma
id|set
op_assign
l_int|0
comma
id|err
op_assign
l_int|1
suffix:semicolon
r_struct
id|inet6_dev
op_star
id|idev
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|IN6_ADDR_HSIZE
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|pkt_dev-&gt;cur_in6_saddr.s6_addr
(braket
id|i
)braket
)paren
(brace
id|set
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|set
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Use linklevel address if unconfigured.&n;&t;&t;&t; *&n;&t;&t;&t; * use ipv6_get_lladdr if/when it&squot;s get exported&n;&t;&t;&t; */
id|read_lock
c_func
(paren
op_amp
id|addrconf_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|idev
op_assign
id|__in6_dev_get
c_func
(paren
id|pkt_dev-&gt;odev
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
r_struct
id|inet6_ifaddr
op_star
id|ifp
suffix:semicolon
id|read_lock_bh
c_func
(paren
op_amp
id|idev-&gt;lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|ifp
op_assign
id|idev-&gt;addr_list
suffix:semicolon
id|ifp
suffix:semicolon
id|ifp
op_assign
id|ifp-&gt;if_next
)paren
(brace
r_if
c_cond
(paren
id|ifp-&gt;scope
op_eq
id|IFA_LINK
op_logical_and
op_logical_neg
(paren
id|ifp-&gt;flags
op_amp
id|IFA_F_TENTATIVE
)paren
)paren
(brace
id|ipv6_addr_copy
c_func
(paren
op_amp
id|pkt_dev-&gt;cur_in6_saddr
comma
op_amp
id|ifp-&gt;addr
)paren
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|read_unlock_bh
c_func
(paren
op_amp
id|idev-&gt;lock
)paren
suffix:semicolon
)brace
id|read_unlock
c_func
(paren
op_amp
id|addrconf_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;pktgen: ERROR: IPv6 link address not availble.&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
)brace
r_else
(brace
id|pkt_dev-&gt;saddr_min
op_assign
l_int|0
suffix:semicolon
id|pkt_dev-&gt;saddr_max
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|strlen
c_func
(paren
id|pkt_dev-&gt;src_min
)paren
op_eq
l_int|0
)paren
(brace
r_struct
id|in_device
op_star
id|in_dev
suffix:semicolon
id|rcu_read_lock
c_func
(paren
)paren
suffix:semicolon
id|in_dev
op_assign
id|__in_dev_get
c_func
(paren
id|pkt_dev-&gt;odev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|in_dev
)paren
(brace
r_if
c_cond
(paren
id|in_dev-&gt;ifa_list
)paren
(brace
id|pkt_dev-&gt;saddr_min
op_assign
id|in_dev-&gt;ifa_list-&gt;ifa_address
suffix:semicolon
id|pkt_dev-&gt;saddr_max
op_assign
id|pkt_dev-&gt;saddr_min
suffix:semicolon
)brace
id|in_dev_put
c_func
(paren
id|in_dev
)paren
suffix:semicolon
)brace
id|rcu_read_unlock
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|pkt_dev-&gt;saddr_min
op_assign
id|in_aton
c_func
(paren
id|pkt_dev-&gt;src_min
)paren
suffix:semicolon
id|pkt_dev-&gt;saddr_max
op_assign
id|in_aton
c_func
(paren
id|pkt_dev-&gt;src_max
)paren
suffix:semicolon
)brace
id|pkt_dev-&gt;daddr_min
op_assign
id|in_aton
c_func
(paren
id|pkt_dev-&gt;dst_min
)paren
suffix:semicolon
id|pkt_dev-&gt;daddr_max
op_assign
id|in_aton
c_func
(paren
id|pkt_dev-&gt;dst_max
)paren
suffix:semicolon
)brace
multiline_comment|/* Initialize current values. */
id|pkt_dev-&gt;cur_dst_mac_offset
op_assign
l_int|0
suffix:semicolon
id|pkt_dev-&gt;cur_src_mac_offset
op_assign
l_int|0
suffix:semicolon
id|pkt_dev-&gt;cur_saddr
op_assign
id|pkt_dev-&gt;saddr_min
suffix:semicolon
id|pkt_dev-&gt;cur_daddr
op_assign
id|pkt_dev-&gt;daddr_min
suffix:semicolon
id|pkt_dev-&gt;cur_udp_dst
op_assign
id|pkt_dev-&gt;udp_dst_min
suffix:semicolon
id|pkt_dev-&gt;cur_udp_src
op_assign
id|pkt_dev-&gt;udp_src_min
suffix:semicolon
id|pkt_dev-&gt;nflows
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|spin
r_static
r_void
id|spin
c_func
(paren
r_struct
id|pktgen_dev
op_star
id|pkt_dev
comma
id|__u64
id|spin_until_us
)paren
(brace
id|__u64
id|start
suffix:semicolon
id|__u64
id|now
suffix:semicolon
id|start
op_assign
id|now
op_assign
id|getCurUs
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;sleeping for %d&bslash;n&quot;
comma
(paren
r_int
)paren
(paren
id|spin_until_us
op_minus
id|now
)paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|now
OL
id|spin_until_us
)paren
(brace
multiline_comment|/* TODO: optimise sleeping behavior */
r_if
c_cond
(paren
id|spin_until_us
op_minus
id|now
OG
(paren
l_int|1000000
op_div
id|HZ
)paren
op_plus
l_int|1
)paren
(brace
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|schedule_timeout
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|spin_until_us
op_minus
id|now
OG
l_int|100
)paren
(brace
id|do_softirq
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pkt_dev-&gt;running
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|need_resched
c_func
(paren
)paren
)paren
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
id|now
op_assign
id|getCurUs
c_func
(paren
)paren
suffix:semicolon
)brace
id|pkt_dev-&gt;idle_acc
op_add_assign
id|now
op_minus
id|start
suffix:semicolon
)brace
multiline_comment|/* Increment/randomize headers according to flags and current values&n; * for IP src/dest, UDP src/dst port, MAC-Addr src/dst&n; */
DECL|function|mod_cur_headers
r_static
r_void
id|mod_cur_headers
c_func
(paren
r_struct
id|pktgen_dev
op_star
id|pkt_dev
)paren
(brace
id|__u32
id|imn
suffix:semicolon
id|__u32
id|imx
suffix:semicolon
r_int
id|flow
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|pkt_dev-&gt;cflows
)paren
(brace
id|flow
op_assign
id|pktgen_random
c_func
(paren
)paren
op_mod
id|pkt_dev-&gt;cflows
suffix:semicolon
r_if
c_cond
(paren
id|pkt_dev-&gt;flows
(braket
id|flow
)braket
dot
id|count
OG
id|pkt_dev-&gt;lflow
)paren
id|pkt_dev-&gt;flows
(braket
id|flow
)braket
dot
id|count
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*  Deal with source MAC */
r_if
c_cond
(paren
id|pkt_dev-&gt;src_mac_count
OG
l_int|1
)paren
(brace
id|__u32
id|mc
suffix:semicolon
id|__u32
id|tmp
suffix:semicolon
r_if
c_cond
(paren
id|pkt_dev-&gt;flags
op_amp
id|F_MACSRC_RND
)paren
id|mc
op_assign
id|pktgen_random
c_func
(paren
)paren
op_mod
(paren
id|pkt_dev-&gt;src_mac_count
)paren
suffix:semicolon
r_else
(brace
id|mc
op_assign
id|pkt_dev-&gt;cur_src_mac_offset
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|pkt_dev-&gt;cur_src_mac_offset
OG
id|pkt_dev-&gt;src_mac_count
)paren
id|pkt_dev-&gt;cur_src_mac_offset
op_assign
l_int|0
suffix:semicolon
)brace
id|tmp
op_assign
id|pkt_dev-&gt;src_mac
(braket
l_int|5
)braket
op_plus
(paren
id|mc
op_amp
l_int|0xFF
)paren
suffix:semicolon
id|pkt_dev-&gt;hh
(braket
l_int|11
)braket
op_assign
id|tmp
suffix:semicolon
id|tmp
op_assign
(paren
id|pkt_dev-&gt;src_mac
(braket
l_int|4
)braket
op_plus
(paren
(paren
id|mc
op_rshift
l_int|8
)paren
op_amp
l_int|0xFF
)paren
op_plus
(paren
id|tmp
op_rshift
l_int|8
)paren
)paren
suffix:semicolon
id|pkt_dev-&gt;hh
(braket
l_int|10
)braket
op_assign
id|tmp
suffix:semicolon
id|tmp
op_assign
(paren
id|pkt_dev-&gt;src_mac
(braket
l_int|3
)braket
op_plus
(paren
(paren
id|mc
op_rshift
l_int|16
)paren
op_amp
l_int|0xFF
)paren
op_plus
(paren
id|tmp
op_rshift
l_int|8
)paren
)paren
suffix:semicolon
id|pkt_dev-&gt;hh
(braket
l_int|9
)braket
op_assign
id|tmp
suffix:semicolon
id|tmp
op_assign
(paren
id|pkt_dev-&gt;src_mac
(braket
l_int|2
)braket
op_plus
(paren
(paren
id|mc
op_rshift
l_int|24
)paren
op_amp
l_int|0xFF
)paren
op_plus
(paren
id|tmp
op_rshift
l_int|8
)paren
)paren
suffix:semicolon
id|pkt_dev-&gt;hh
(braket
l_int|8
)braket
op_assign
id|tmp
suffix:semicolon
id|tmp
op_assign
(paren
id|pkt_dev-&gt;src_mac
(braket
l_int|1
)braket
op_plus
(paren
id|tmp
op_rshift
l_int|8
)paren
)paren
suffix:semicolon
id|pkt_dev-&gt;hh
(braket
l_int|7
)braket
op_assign
id|tmp
suffix:semicolon
)brace
multiline_comment|/*  Deal with Destination MAC */
r_if
c_cond
(paren
id|pkt_dev-&gt;dst_mac_count
OG
l_int|1
)paren
(brace
id|__u32
id|mc
suffix:semicolon
id|__u32
id|tmp
suffix:semicolon
r_if
c_cond
(paren
id|pkt_dev-&gt;flags
op_amp
id|F_MACDST_RND
)paren
id|mc
op_assign
id|pktgen_random
c_func
(paren
)paren
op_mod
(paren
id|pkt_dev-&gt;dst_mac_count
)paren
suffix:semicolon
r_else
(brace
id|mc
op_assign
id|pkt_dev-&gt;cur_dst_mac_offset
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|pkt_dev-&gt;cur_dst_mac_offset
OG
id|pkt_dev-&gt;dst_mac_count
)paren
(brace
id|pkt_dev-&gt;cur_dst_mac_offset
op_assign
l_int|0
suffix:semicolon
)brace
)brace
id|tmp
op_assign
id|pkt_dev-&gt;dst_mac
(braket
l_int|5
)braket
op_plus
(paren
id|mc
op_amp
l_int|0xFF
)paren
suffix:semicolon
id|pkt_dev-&gt;hh
(braket
l_int|5
)braket
op_assign
id|tmp
suffix:semicolon
id|tmp
op_assign
(paren
id|pkt_dev-&gt;dst_mac
(braket
l_int|4
)braket
op_plus
(paren
(paren
id|mc
op_rshift
l_int|8
)paren
op_amp
l_int|0xFF
)paren
op_plus
(paren
id|tmp
op_rshift
l_int|8
)paren
)paren
suffix:semicolon
id|pkt_dev-&gt;hh
(braket
l_int|4
)braket
op_assign
id|tmp
suffix:semicolon
id|tmp
op_assign
(paren
id|pkt_dev-&gt;dst_mac
(braket
l_int|3
)braket
op_plus
(paren
(paren
id|mc
op_rshift
l_int|16
)paren
op_amp
l_int|0xFF
)paren
op_plus
(paren
id|tmp
op_rshift
l_int|8
)paren
)paren
suffix:semicolon
id|pkt_dev-&gt;hh
(braket
l_int|3
)braket
op_assign
id|tmp
suffix:semicolon
id|tmp
op_assign
(paren
id|pkt_dev-&gt;dst_mac
(braket
l_int|2
)braket
op_plus
(paren
(paren
id|mc
op_rshift
l_int|24
)paren
op_amp
l_int|0xFF
)paren
op_plus
(paren
id|tmp
op_rshift
l_int|8
)paren
)paren
suffix:semicolon
id|pkt_dev-&gt;hh
(braket
l_int|2
)braket
op_assign
id|tmp
suffix:semicolon
id|tmp
op_assign
(paren
id|pkt_dev-&gt;dst_mac
(braket
l_int|1
)braket
op_plus
(paren
id|tmp
op_rshift
l_int|8
)paren
)paren
suffix:semicolon
id|pkt_dev-&gt;hh
(braket
l_int|1
)braket
op_assign
id|tmp
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pkt_dev-&gt;udp_src_min
OL
id|pkt_dev-&gt;udp_src_max
)paren
(brace
r_if
c_cond
(paren
id|pkt_dev-&gt;flags
op_amp
id|F_UDPSRC_RND
)paren
id|pkt_dev-&gt;cur_udp_src
op_assign
(paren
(paren
id|pktgen_random
c_func
(paren
)paren
op_mod
(paren
id|pkt_dev-&gt;udp_src_max
op_minus
id|pkt_dev-&gt;udp_src_min
)paren
)paren
op_plus
id|pkt_dev-&gt;udp_src_min
)paren
suffix:semicolon
r_else
(brace
id|pkt_dev-&gt;cur_udp_src
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|pkt_dev-&gt;cur_udp_src
op_ge
id|pkt_dev-&gt;udp_src_max
)paren
id|pkt_dev-&gt;cur_udp_src
op_assign
id|pkt_dev-&gt;udp_src_min
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|pkt_dev-&gt;udp_dst_min
OL
id|pkt_dev-&gt;udp_dst_max
)paren
(brace
r_if
c_cond
(paren
id|pkt_dev-&gt;flags
op_amp
id|F_UDPDST_RND
)paren
(brace
id|pkt_dev-&gt;cur_udp_dst
op_assign
(paren
(paren
id|pktgen_random
c_func
(paren
)paren
op_mod
(paren
id|pkt_dev-&gt;udp_dst_max
op_minus
id|pkt_dev-&gt;udp_dst_min
)paren
)paren
op_plus
id|pkt_dev-&gt;udp_dst_min
)paren
suffix:semicolon
)brace
r_else
(brace
id|pkt_dev-&gt;cur_udp_dst
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|pkt_dev-&gt;cur_udp_dst
op_ge
id|pkt_dev-&gt;udp_dst_max
)paren
id|pkt_dev-&gt;cur_udp_dst
op_assign
id|pkt_dev-&gt;udp_dst_min
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|pkt_dev-&gt;flags
op_amp
id|F_IPV6
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|imn
op_assign
id|ntohl
c_func
(paren
id|pkt_dev-&gt;saddr_min
)paren
)paren
OL
(paren
id|imx
op_assign
id|ntohl
c_func
(paren
id|pkt_dev-&gt;saddr_max
)paren
)paren
)paren
(brace
id|__u32
id|t
suffix:semicolon
r_if
c_cond
(paren
id|pkt_dev-&gt;flags
op_amp
id|F_IPSRC_RND
)paren
id|t
op_assign
(paren
(paren
id|pktgen_random
c_func
(paren
)paren
op_mod
(paren
id|imx
op_minus
id|imn
)paren
)paren
op_plus
id|imn
)paren
suffix:semicolon
r_else
(brace
id|t
op_assign
id|ntohl
c_func
(paren
id|pkt_dev-&gt;cur_saddr
)paren
suffix:semicolon
id|t
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|t
OG
id|imx
)paren
(brace
id|t
op_assign
id|imn
suffix:semicolon
)brace
)brace
id|pkt_dev-&gt;cur_saddr
op_assign
id|htonl
c_func
(paren
id|t
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pkt_dev-&gt;cflows
op_logical_and
id|pkt_dev-&gt;flows
(braket
id|flow
)braket
dot
id|count
op_ne
l_int|0
)paren
(brace
id|pkt_dev-&gt;cur_daddr
op_assign
id|pkt_dev-&gt;flows
(braket
id|flow
)braket
dot
id|cur_daddr
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
(paren
id|imn
op_assign
id|ntohl
c_func
(paren
id|pkt_dev-&gt;daddr_min
)paren
)paren
OL
(paren
id|imx
op_assign
id|ntohl
c_func
(paren
id|pkt_dev-&gt;daddr_max
)paren
)paren
)paren
(brace
id|__u32
id|t
suffix:semicolon
r_if
c_cond
(paren
id|pkt_dev-&gt;flags
op_amp
id|F_IPDST_RND
)paren
(brace
id|t
op_assign
(paren
(paren
id|pktgen_random
c_func
(paren
)paren
op_mod
(paren
id|imx
op_minus
id|imn
)paren
)paren
op_plus
id|imn
)paren
suffix:semicolon
id|t
op_assign
id|htonl
c_func
(paren
id|t
)paren
suffix:semicolon
r_while
c_loop
(paren
id|LOOPBACK
c_func
(paren
id|t
)paren
op_logical_or
id|MULTICAST
c_func
(paren
id|t
)paren
op_logical_or
id|BADCLASS
c_func
(paren
id|t
)paren
op_logical_or
id|ZERONET
c_func
(paren
id|t
)paren
op_logical_or
id|LOCAL_MCAST
c_func
(paren
id|t
)paren
)paren
(brace
id|t
op_assign
(paren
(paren
id|pktgen_random
c_func
(paren
)paren
op_mod
(paren
id|imx
op_minus
id|imn
)paren
)paren
op_plus
id|imn
)paren
suffix:semicolon
id|t
op_assign
id|htonl
c_func
(paren
id|t
)paren
suffix:semicolon
)brace
id|pkt_dev-&gt;cur_daddr
op_assign
id|t
suffix:semicolon
)brace
r_else
(brace
id|t
op_assign
id|ntohl
c_func
(paren
id|pkt_dev-&gt;cur_daddr
)paren
suffix:semicolon
id|t
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|t
OG
id|imx
)paren
(brace
id|t
op_assign
id|imn
suffix:semicolon
)brace
id|pkt_dev-&gt;cur_daddr
op_assign
id|htonl
c_func
(paren
id|t
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|pkt_dev-&gt;cflows
)paren
(brace
id|pkt_dev-&gt;flows
(braket
id|flow
)braket
dot
id|cur_daddr
op_assign
id|pkt_dev-&gt;cur_daddr
suffix:semicolon
id|pkt_dev-&gt;nflows
op_increment
suffix:semicolon
)brace
)brace
)brace
r_else
multiline_comment|/* IPV6 * */
(brace
r_if
c_cond
(paren
id|pkt_dev-&gt;min_in6_daddr.s6_addr32
(braket
l_int|0
)braket
op_eq
l_int|0
op_logical_and
id|pkt_dev-&gt;min_in6_daddr.s6_addr32
(braket
l_int|1
)braket
op_eq
l_int|0
op_logical_and
id|pkt_dev-&gt;min_in6_daddr.s6_addr32
(braket
l_int|2
)braket
op_eq
l_int|0
op_logical_and
id|pkt_dev-&gt;min_in6_daddr.s6_addr32
(braket
l_int|3
)braket
op_eq
l_int|0
)paren
(brace
suffix:semicolon
)brace
r_else
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/* Only random destinations yet */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
id|i
op_increment
)paren
(brace
id|pkt_dev-&gt;cur_in6_daddr.s6_addr32
(braket
id|i
)braket
op_assign
(paren
(paren
id|pktgen_random
c_func
(paren
)paren
op_or
id|pkt_dev-&gt;min_in6_daddr.s6_addr32
(braket
id|i
)braket
)paren
op_amp
id|pkt_dev-&gt;max_in6_daddr.s6_addr32
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|pkt_dev-&gt;min_pkt_size
OL
id|pkt_dev-&gt;max_pkt_size
)paren
(brace
id|__u32
id|t
suffix:semicolon
r_if
c_cond
(paren
id|pkt_dev-&gt;flags
op_amp
id|F_TXSIZE_RND
)paren
(brace
id|t
op_assign
(paren
(paren
id|pktgen_random
c_func
(paren
)paren
op_mod
(paren
id|pkt_dev-&gt;max_pkt_size
op_minus
id|pkt_dev-&gt;min_pkt_size
)paren
)paren
op_plus
id|pkt_dev-&gt;min_pkt_size
)paren
suffix:semicolon
)brace
r_else
(brace
id|t
op_assign
id|pkt_dev-&gt;cur_pkt_size
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|t
OG
id|pkt_dev-&gt;max_pkt_size
)paren
id|t
op_assign
id|pkt_dev-&gt;min_pkt_size
suffix:semicolon
)brace
id|pkt_dev-&gt;cur_pkt_size
op_assign
id|t
suffix:semicolon
)brace
id|pkt_dev-&gt;flows
(braket
id|flow
)braket
dot
id|count
op_increment
suffix:semicolon
)brace
DECL|function|fill_packet_ipv4
r_static
r_struct
id|sk_buff
op_star
id|fill_packet_ipv4
c_func
(paren
r_struct
id|net_device
op_star
id|odev
comma
r_struct
id|pktgen_dev
op_star
id|pkt_dev
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
op_assign
l_int|NULL
suffix:semicolon
id|__u8
op_star
id|eth
suffix:semicolon
r_struct
id|udphdr
op_star
id|udph
suffix:semicolon
r_int
id|datalen
comma
id|iplen
suffix:semicolon
r_struct
id|iphdr
op_star
id|iph
suffix:semicolon
r_struct
id|pktgen_hdr
op_star
id|pgh
op_assign
l_int|NULL
suffix:semicolon
id|skb
op_assign
id|alloc_skb
c_func
(paren
id|pkt_dev-&gt;cur_pkt_size
op_plus
l_int|64
op_plus
l_int|16
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skb
)paren
(brace
id|sprintf
c_func
(paren
id|pkt_dev-&gt;result
comma
l_string|&quot;No memory&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|skb_reserve
c_func
(paren
id|skb
comma
l_int|16
)paren
suffix:semicolon
multiline_comment|/*  Reserve for ethernet and IP header  */
id|eth
op_assign
(paren
id|__u8
op_star
)paren
id|skb_push
c_func
(paren
id|skb
comma
l_int|14
)paren
suffix:semicolon
id|iph
op_assign
(paren
r_struct
id|iphdr
op_star
)paren
id|skb_put
c_func
(paren
id|skb
comma
r_sizeof
(paren
r_struct
id|iphdr
)paren
)paren
suffix:semicolon
id|udph
op_assign
(paren
r_struct
id|udphdr
op_star
)paren
id|skb_put
c_func
(paren
id|skb
comma
r_sizeof
(paren
r_struct
id|udphdr
)paren
)paren
suffix:semicolon
multiline_comment|/* Update any of the values, used when we&squot;re incrementing various&n;         * fields.&n;         */
id|mod_cur_headers
c_func
(paren
id|pkt_dev
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|eth
comma
id|pkt_dev-&gt;hh
comma
l_int|12
)paren
suffix:semicolon
op_star
(paren
id|u16
op_star
)paren
op_amp
id|eth
(braket
l_int|12
)braket
op_assign
id|__constant_htons
c_func
(paren
id|ETH_P_IP
)paren
suffix:semicolon
id|datalen
op_assign
id|pkt_dev-&gt;cur_pkt_size
op_minus
l_int|14
op_minus
l_int|20
op_minus
l_int|8
suffix:semicolon
multiline_comment|/* Eth + IPh + UDPh */
r_if
c_cond
(paren
id|datalen
OL
r_sizeof
(paren
r_struct
id|pktgen_hdr
)paren
)paren
id|datalen
op_assign
r_sizeof
(paren
r_struct
id|pktgen_hdr
)paren
suffix:semicolon
id|udph-&gt;source
op_assign
id|htons
c_func
(paren
id|pkt_dev-&gt;cur_udp_src
)paren
suffix:semicolon
id|udph-&gt;dest
op_assign
id|htons
c_func
(paren
id|pkt_dev-&gt;cur_udp_dst
)paren
suffix:semicolon
id|udph-&gt;len
op_assign
id|htons
c_func
(paren
id|datalen
op_plus
l_int|8
)paren
suffix:semicolon
multiline_comment|/* DATA + udphdr */
id|udph-&gt;check
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* No checksum */
id|iph-&gt;ihl
op_assign
l_int|5
suffix:semicolon
id|iph-&gt;version
op_assign
l_int|4
suffix:semicolon
id|iph-&gt;ttl
op_assign
l_int|32
suffix:semicolon
id|iph-&gt;tos
op_assign
l_int|0
suffix:semicolon
id|iph-&gt;protocol
op_assign
id|IPPROTO_UDP
suffix:semicolon
multiline_comment|/* UDP */
id|iph-&gt;saddr
op_assign
id|pkt_dev-&gt;cur_saddr
suffix:semicolon
id|iph-&gt;daddr
op_assign
id|pkt_dev-&gt;cur_daddr
suffix:semicolon
id|iph-&gt;frag_off
op_assign
l_int|0
suffix:semicolon
id|iplen
op_assign
l_int|20
op_plus
l_int|8
op_plus
id|datalen
suffix:semicolon
id|iph-&gt;tot_len
op_assign
id|htons
c_func
(paren
id|iplen
)paren
suffix:semicolon
id|iph-&gt;check
op_assign
l_int|0
suffix:semicolon
id|iph-&gt;check
op_assign
id|ip_fast_csum
c_func
(paren
(paren
r_void
op_star
)paren
id|iph
comma
id|iph-&gt;ihl
)paren
suffix:semicolon
id|skb-&gt;protocol
op_assign
id|__constant_htons
c_func
(paren
id|ETH_P_IP
)paren
suffix:semicolon
id|skb-&gt;mac.raw
op_assign
(paren
(paren
id|u8
op_star
)paren
id|iph
)paren
op_minus
l_int|14
suffix:semicolon
id|skb-&gt;dev
op_assign
id|odev
suffix:semicolon
id|skb-&gt;pkt_type
op_assign
id|PACKET_HOST
suffix:semicolon
r_if
c_cond
(paren
id|pkt_dev-&gt;nfrags
op_le
l_int|0
)paren
id|pgh
op_assign
(paren
r_struct
id|pktgen_hdr
op_star
)paren
id|skb_put
c_func
(paren
id|skb
comma
id|datalen
)paren
suffix:semicolon
r_else
(brace
r_int
id|frags
op_assign
id|pkt_dev-&gt;nfrags
suffix:semicolon
r_int
id|i
suffix:semicolon
id|pgh
op_assign
(paren
r_struct
id|pktgen_hdr
op_star
)paren
(paren
(paren
(paren
r_char
op_star
)paren
(paren
id|udph
)paren
)paren
op_plus
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
id|frags
OG
id|MAX_SKB_FRAGS
)paren
id|frags
op_assign
id|MAX_SKB_FRAGS
suffix:semicolon
r_if
c_cond
(paren
id|datalen
OG
id|frags
op_star
id|PAGE_SIZE
)paren
(brace
id|skb_put
c_func
(paren
id|skb
comma
id|datalen
op_minus
id|frags
op_star
id|PAGE_SIZE
)paren
suffix:semicolon
id|datalen
op_assign
id|frags
op_star
id|PAGE_SIZE
suffix:semicolon
)brace
id|i
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|datalen
OG
l_int|0
)paren
(brace
r_struct
id|page
op_star
id|page
op_assign
id|alloc_pages
c_func
(paren
id|GFP_KERNEL
comma
l_int|0
)paren
suffix:semicolon
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|frags
(braket
id|i
)braket
dot
id|page
op_assign
id|page
suffix:semicolon
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|frags
(braket
id|i
)braket
dot
id|page_offset
op_assign
l_int|0
suffix:semicolon
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|frags
(braket
id|i
)braket
dot
id|size
op_assign
(paren
id|datalen
OL
id|PAGE_SIZE
ques
c_cond
id|datalen
suffix:colon
id|PAGE_SIZE
)paren
suffix:semicolon
id|datalen
op_sub_assign
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|frags
(braket
id|i
)braket
dot
id|size
suffix:semicolon
id|skb-&gt;len
op_add_assign
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|frags
(braket
id|i
)braket
dot
id|size
suffix:semicolon
id|skb-&gt;data_len
op_add_assign
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|frags
(braket
id|i
)braket
dot
id|size
suffix:semicolon
id|i
op_increment
suffix:semicolon
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|nr_frags
op_assign
id|i
suffix:semicolon
)brace
r_while
c_loop
(paren
id|i
OL
id|frags
)paren
(brace
r_int
id|rem
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
l_int|0
)paren
r_break
suffix:semicolon
id|rem
op_assign
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|frags
(braket
id|i
op_minus
l_int|1
)braket
dot
id|size
op_div
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|rem
op_eq
l_int|0
)paren
r_break
suffix:semicolon
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|frags
(braket
id|i
op_minus
l_int|1
)braket
dot
id|size
op_sub_assign
id|rem
suffix:semicolon
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|frags
(braket
id|i
)braket
op_assign
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|frags
(braket
id|i
op_minus
l_int|1
)braket
suffix:semicolon
id|get_page
c_func
(paren
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|frags
(braket
id|i
)braket
dot
id|page
)paren
suffix:semicolon
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|frags
(braket
id|i
)braket
dot
id|page
op_assign
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|frags
(braket
id|i
op_minus
l_int|1
)braket
dot
id|page
suffix:semicolon
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|frags
(braket
id|i
)braket
dot
id|page_offset
op_add_assign
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|frags
(braket
id|i
op_minus
l_int|1
)braket
dot
id|size
suffix:semicolon
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|frags
(braket
id|i
)braket
dot
id|size
op_assign
id|rem
suffix:semicolon
id|i
op_increment
suffix:semicolon
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|nr_frags
op_assign
id|i
suffix:semicolon
)brace
)brace
multiline_comment|/* Stamp the time, and sequence number, convert them to network byte order */
r_if
c_cond
(paren
id|pgh
)paren
(brace
r_struct
id|timeval
id|timestamp
suffix:semicolon
id|pgh-&gt;pgh_magic
op_assign
id|htonl
c_func
(paren
id|PKTGEN_MAGIC
)paren
suffix:semicolon
id|pgh-&gt;seq_num
op_assign
id|htonl
c_func
(paren
id|pkt_dev-&gt;seq_num
)paren
suffix:semicolon
id|do_gettimeofday
c_func
(paren
op_amp
id|timestamp
)paren
suffix:semicolon
id|pgh-&gt;tv_sec
op_assign
id|htonl
c_func
(paren
id|timestamp.tv_sec
)paren
suffix:semicolon
id|pgh-&gt;tv_usec
op_assign
id|htonl
c_func
(paren
id|timestamp.tv_usec
)paren
suffix:semicolon
)brace
id|pkt_dev-&gt;seq_num
op_increment
suffix:semicolon
r_return
id|skb
suffix:semicolon
)brace
multiline_comment|/*&n; * scan_ip6, fmt_ip taken from dietlibc-0.21 &n; * Author Felix von Leitner &lt;felix-dietlibc@fefe.de&gt;&n; *&n; * Slightly modified for kernel. &n; * Should be candidate for net/ipv4/utils.c&n; * --ro&n; */
DECL|function|scan_ip6
r_static
r_int
r_int
id|scan_ip6
c_func
(paren
r_const
r_char
op_star
id|s
comma
r_char
id|ip
(braket
l_int|16
)braket
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
r_int
r_int
id|len
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|u
suffix:semicolon
r_char
id|suffix
(braket
l_int|16
)braket
suffix:semicolon
r_int
r_int
id|prefixlen
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|suffixlen
op_assign
l_int|0
suffix:semicolon
id|__u32
id|tmp
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
id|i
op_increment
)paren
id|ip
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
op_star
id|s
op_eq
l_char|&squot;:&squot;
)paren
(brace
id|len
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|s
(braket
l_int|1
)braket
op_eq
l_char|&squot;:&squot;
)paren
(brace
multiline_comment|/* Found &quot;::&quot;, skip to part 2 */
id|s
op_add_assign
l_int|2
suffix:semicolon
id|len
op_increment
suffix:semicolon
r_break
suffix:semicolon
)brace
id|s
op_increment
suffix:semicolon
)brace
(brace
r_char
op_star
id|tmp
suffix:semicolon
id|u
op_assign
id|simple_strtoul
c_func
(paren
id|s
comma
op_amp
id|tmp
comma
l_int|16
)paren
suffix:semicolon
id|i
op_assign
id|tmp
op_minus
id|s
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|i
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|prefixlen
op_eq
l_int|12
op_logical_and
id|s
(braket
id|i
)braket
op_eq
l_char|&squot;.&squot;
)paren
(brace
multiline_comment|/* the last 4 bytes may be written as IPv4 address */
id|tmp
op_assign
id|in_aton
c_func
(paren
id|s
)paren
suffix:semicolon
id|memcpy
c_func
(paren
(paren
r_struct
id|in_addr
op_star
)paren
(paren
id|ip
op_plus
l_int|12
)paren
comma
op_amp
id|tmp
comma
r_sizeof
(paren
id|tmp
)paren
)paren
suffix:semicolon
r_return
id|i
op_plus
id|len
suffix:semicolon
)brace
id|ip
(braket
id|prefixlen
op_increment
)braket
op_assign
(paren
id|u
op_rshift
l_int|8
)paren
suffix:semicolon
id|ip
(braket
id|prefixlen
op_increment
)braket
op_assign
(paren
id|u
op_amp
l_int|255
)paren
suffix:semicolon
id|s
op_add_assign
id|i
suffix:semicolon
id|len
op_add_assign
id|i
suffix:semicolon
r_if
c_cond
(paren
id|prefixlen
op_eq
l_int|16
)paren
r_return
id|len
suffix:semicolon
)brace
multiline_comment|/* part 2, after &quot;::&quot; */
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
op_star
id|s
op_eq
l_char|&squot;:&squot;
)paren
(brace
r_if
c_cond
(paren
id|suffixlen
op_eq
l_int|0
)paren
r_break
suffix:semicolon
id|s
op_increment
suffix:semicolon
id|len
op_increment
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|suffixlen
op_ne
l_int|0
)paren
r_break
suffix:semicolon
(brace
r_char
op_star
id|tmp
suffix:semicolon
id|u
op_assign
id|simple_strtol
c_func
(paren
id|s
comma
op_amp
id|tmp
comma
l_int|16
)paren
suffix:semicolon
id|i
op_assign
id|tmp
op_minus
id|s
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|i
)paren
(brace
r_if
c_cond
(paren
op_star
id|s
)paren
id|len
op_decrement
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|suffixlen
op_plus
id|prefixlen
op_le
l_int|12
op_logical_and
id|s
(braket
id|i
)braket
op_eq
l_char|&squot;.&squot;
)paren
(brace
id|tmp
op_assign
id|in_aton
c_func
(paren
id|s
)paren
suffix:semicolon
id|memcpy
c_func
(paren
(paren
r_struct
id|in_addr
op_star
)paren
(paren
id|suffix
op_plus
id|suffixlen
)paren
comma
op_amp
id|tmp
comma
r_sizeof
(paren
id|tmp
)paren
)paren
suffix:semicolon
id|suffixlen
op_add_assign
l_int|4
suffix:semicolon
id|len
op_add_assign
id|strlen
c_func
(paren
id|s
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|suffix
(braket
id|suffixlen
op_increment
)braket
op_assign
(paren
id|u
op_rshift
l_int|8
)paren
suffix:semicolon
id|suffix
(braket
id|suffixlen
op_increment
)braket
op_assign
(paren
id|u
op_amp
l_int|255
)paren
suffix:semicolon
id|s
op_add_assign
id|i
suffix:semicolon
id|len
op_add_assign
id|i
suffix:semicolon
r_if
c_cond
(paren
id|prefixlen
op_plus
id|suffixlen
op_eq
l_int|16
)paren
r_break
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|suffixlen
suffix:semicolon
id|i
op_increment
)paren
id|ip
(braket
l_int|16
op_minus
id|suffixlen
op_plus
id|i
)braket
op_assign
id|suffix
(braket
id|i
)braket
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
DECL|function|tohex
r_static
r_char
id|tohex
c_func
(paren
r_char
id|hexdigit
)paren
(brace
r_return
id|hexdigit
OG
l_int|9
ques
c_cond
id|hexdigit
op_plus
l_char|&squot;a&squot;
op_minus
l_int|10
suffix:colon
id|hexdigit
op_plus
l_char|&squot;0&squot;
suffix:semicolon
)brace
DECL|function|fmt_xlong
r_static
r_int
id|fmt_xlong
c_func
(paren
r_char
op_star
id|s
comma
r_int
r_int
id|i
)paren
(brace
r_char
op_star
id|bak
op_assign
id|s
suffix:semicolon
op_star
id|s
op_assign
id|tohex
c_func
(paren
(paren
id|i
op_rshift
l_int|12
)paren
op_amp
l_int|0xf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|s
op_ne
id|bak
op_logical_or
op_star
id|s
op_ne
l_char|&squot;0&squot;
)paren
op_increment
id|s
suffix:semicolon
op_star
id|s
op_assign
id|tohex
c_func
(paren
(paren
id|i
op_rshift
l_int|8
)paren
op_amp
l_int|0xf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|s
op_ne
id|bak
op_logical_or
op_star
id|s
op_ne
l_char|&squot;0&squot;
)paren
op_increment
id|s
suffix:semicolon
op_star
id|s
op_assign
id|tohex
c_func
(paren
(paren
id|i
op_rshift
l_int|4
)paren
op_amp
l_int|0xf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|s
op_ne
id|bak
op_logical_or
op_star
id|s
op_ne
l_char|&squot;0&squot;
)paren
op_increment
id|s
suffix:semicolon
op_star
id|s
op_assign
id|tohex
c_func
(paren
id|i
op_amp
l_int|0xf
)paren
suffix:semicolon
r_return
id|s
op_minus
id|bak
op_plus
l_int|1
suffix:semicolon
)brace
DECL|function|fmt_ip6
r_static
r_int
r_int
id|fmt_ip6
c_func
(paren
r_char
op_star
id|s
comma
r_const
r_char
id|ip
(braket
l_int|16
)braket
)paren
(brace
r_int
r_int
id|len
suffix:semicolon
r_int
r_int
id|i
suffix:semicolon
r_int
r_int
id|temp
suffix:semicolon
r_int
r_int
id|compressing
suffix:semicolon
r_int
id|j
suffix:semicolon
id|len
op_assign
l_int|0
suffix:semicolon
id|compressing
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
l_int|16
suffix:semicolon
id|j
op_add_assign
l_int|2
)paren
(brace
macro_line|#ifdef V4MAPPEDPREFIX
r_if
c_cond
(paren
id|j
op_eq
l_int|12
op_logical_and
op_logical_neg
id|memcmp
c_func
(paren
id|ip
comma
id|V4mappedprefix
comma
l_int|12
)paren
)paren
(brace
id|inet_ntoa_r
c_func
(paren
op_star
(paren
r_struct
id|in_addr
op_star
)paren
(paren
id|ip
op_plus
l_int|12
)paren
comma
id|s
)paren
suffix:semicolon
id|temp
op_assign
id|strlen
c_func
(paren
id|s
)paren
suffix:semicolon
r_return
id|len
op_plus
id|temp
suffix:semicolon
)brace
macro_line|#endif
id|temp
op_assign
(paren
(paren
r_int
r_int
)paren
(paren
r_int
r_char
)paren
id|ip
(braket
id|j
)braket
op_lshift
l_int|8
)paren
op_plus
(paren
r_int
r_int
)paren
(paren
r_int
r_char
)paren
id|ip
(braket
id|j
op_plus
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
id|temp
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|compressing
)paren
(brace
id|compressing
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|j
op_eq
l_int|0
)paren
(brace
op_star
id|s
op_increment
op_assign
l_char|&squot;:&squot;
suffix:semicolon
op_increment
id|len
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|compressing
)paren
(brace
id|compressing
op_assign
l_int|0
suffix:semicolon
op_star
id|s
op_increment
op_assign
l_char|&squot;:&squot;
suffix:semicolon
op_increment
id|len
suffix:semicolon
)brace
id|i
op_assign
id|fmt_xlong
c_func
(paren
id|s
comma
id|temp
)paren
suffix:semicolon
id|len
op_add_assign
id|i
suffix:semicolon
id|s
op_add_assign
id|i
suffix:semicolon
r_if
c_cond
(paren
id|j
OL
l_int|14
)paren
(brace
op_star
id|s
op_increment
op_assign
l_char|&squot;:&squot;
suffix:semicolon
op_increment
id|len
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|compressing
)paren
(brace
op_star
id|s
op_increment
op_assign
l_char|&squot;:&squot;
suffix:semicolon
op_increment
id|len
suffix:semicolon
)brace
op_star
id|s
op_assign
l_int|0
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
DECL|function|fill_packet_ipv6
r_static
r_struct
id|sk_buff
op_star
id|fill_packet_ipv6
c_func
(paren
r_struct
id|net_device
op_star
id|odev
comma
r_struct
id|pktgen_dev
op_star
id|pkt_dev
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
op_assign
l_int|NULL
suffix:semicolon
id|__u8
op_star
id|eth
suffix:semicolon
r_struct
id|udphdr
op_star
id|udph
suffix:semicolon
r_int
id|datalen
suffix:semicolon
r_struct
id|ipv6hdr
op_star
id|iph
suffix:semicolon
r_struct
id|pktgen_hdr
op_star
id|pgh
op_assign
l_int|NULL
suffix:semicolon
id|skb
op_assign
id|alloc_skb
c_func
(paren
id|pkt_dev-&gt;cur_pkt_size
op_plus
l_int|64
op_plus
l_int|16
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skb
)paren
(brace
id|sprintf
c_func
(paren
id|pkt_dev-&gt;result
comma
l_string|&quot;No memory&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|skb_reserve
c_func
(paren
id|skb
comma
l_int|16
)paren
suffix:semicolon
multiline_comment|/*  Reserve for ethernet and IP header  */
id|eth
op_assign
(paren
id|__u8
op_star
)paren
id|skb_push
c_func
(paren
id|skb
comma
l_int|14
)paren
suffix:semicolon
id|iph
op_assign
(paren
r_struct
id|ipv6hdr
op_star
)paren
id|skb_put
c_func
(paren
id|skb
comma
r_sizeof
(paren
r_struct
id|ipv6hdr
)paren
)paren
suffix:semicolon
id|udph
op_assign
(paren
r_struct
id|udphdr
op_star
)paren
id|skb_put
c_func
(paren
id|skb
comma
r_sizeof
(paren
r_struct
id|udphdr
)paren
)paren
suffix:semicolon
multiline_comment|/* Update any of the values, used when we&squot;re incrementing various&n;         * fields.&n;         */
id|mod_cur_headers
c_func
(paren
id|pkt_dev
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|eth
comma
id|pkt_dev-&gt;hh
comma
l_int|12
)paren
suffix:semicolon
op_star
(paren
id|u16
op_star
)paren
op_amp
id|eth
(braket
l_int|12
)braket
op_assign
id|__constant_htons
c_func
(paren
id|ETH_P_IPV6
)paren
suffix:semicolon
id|datalen
op_assign
id|pkt_dev-&gt;cur_pkt_size
op_minus
l_int|14
op_minus
r_sizeof
(paren
r_struct
id|ipv6hdr
)paren
op_minus
r_sizeof
(paren
r_struct
id|udphdr
)paren
suffix:semicolon
multiline_comment|/* Eth + IPh + UDPh */
r_if
c_cond
(paren
id|datalen
OL
r_sizeof
(paren
r_struct
id|pktgen_hdr
)paren
)paren
(brace
id|datalen
op_assign
r_sizeof
(paren
r_struct
id|pktgen_hdr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|net_ratelimit
c_func
(paren
)paren
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;pktgen: increased datalen to %d&bslash;n&quot;
comma
id|datalen
)paren
suffix:semicolon
)brace
id|udph-&gt;source
op_assign
id|htons
c_func
(paren
id|pkt_dev-&gt;cur_udp_src
)paren
suffix:semicolon
id|udph-&gt;dest
op_assign
id|htons
c_func
(paren
id|pkt_dev-&gt;cur_udp_dst
)paren
suffix:semicolon
id|udph-&gt;len
op_assign
id|htons
c_func
(paren
id|datalen
op_plus
r_sizeof
(paren
r_struct
id|udphdr
)paren
)paren
suffix:semicolon
id|udph-&gt;check
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* No checksum */
op_star
(paren
id|u32
op_star
)paren
id|iph
op_assign
id|__constant_htonl
c_func
(paren
l_int|0x60000000
)paren
suffix:semicolon
multiline_comment|/* Version + flow */
id|iph-&gt;hop_limit
op_assign
l_int|32
suffix:semicolon
id|iph-&gt;payload_len
op_assign
id|htons
c_func
(paren
r_sizeof
(paren
r_struct
id|udphdr
)paren
op_plus
id|datalen
)paren
suffix:semicolon
id|iph-&gt;nexthdr
op_assign
id|IPPROTO_UDP
suffix:semicolon
id|ipv6_addr_copy
c_func
(paren
op_amp
id|iph-&gt;daddr
comma
op_amp
id|pkt_dev-&gt;cur_in6_daddr
)paren
suffix:semicolon
id|ipv6_addr_copy
c_func
(paren
op_amp
id|iph-&gt;saddr
comma
op_amp
id|pkt_dev-&gt;cur_in6_saddr
)paren
suffix:semicolon
id|skb-&gt;mac.raw
op_assign
(paren
(paren
id|u8
op_star
)paren
id|iph
)paren
op_minus
l_int|14
suffix:semicolon
id|skb-&gt;protocol
op_assign
id|__constant_htons
c_func
(paren
id|ETH_P_IPV6
)paren
suffix:semicolon
id|skb-&gt;dev
op_assign
id|odev
suffix:semicolon
id|skb-&gt;pkt_type
op_assign
id|PACKET_HOST
suffix:semicolon
r_if
c_cond
(paren
id|pkt_dev-&gt;nfrags
op_le
l_int|0
)paren
id|pgh
op_assign
(paren
r_struct
id|pktgen_hdr
op_star
)paren
id|skb_put
c_func
(paren
id|skb
comma
id|datalen
)paren
suffix:semicolon
r_else
(brace
r_int
id|frags
op_assign
id|pkt_dev-&gt;nfrags
suffix:semicolon
r_int
id|i
suffix:semicolon
id|pgh
op_assign
(paren
r_struct
id|pktgen_hdr
op_star
)paren
(paren
(paren
(paren
r_char
op_star
)paren
(paren
id|udph
)paren
)paren
op_plus
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
id|frags
OG
id|MAX_SKB_FRAGS
)paren
id|frags
op_assign
id|MAX_SKB_FRAGS
suffix:semicolon
r_if
c_cond
(paren
id|datalen
OG
id|frags
op_star
id|PAGE_SIZE
)paren
(brace
id|skb_put
c_func
(paren
id|skb
comma
id|datalen
op_minus
id|frags
op_star
id|PAGE_SIZE
)paren
suffix:semicolon
id|datalen
op_assign
id|frags
op_star
id|PAGE_SIZE
suffix:semicolon
)brace
id|i
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|datalen
OG
l_int|0
)paren
(brace
r_struct
id|page
op_star
id|page
op_assign
id|alloc_pages
c_func
(paren
id|GFP_KERNEL
comma
l_int|0
)paren
suffix:semicolon
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|frags
(braket
id|i
)braket
dot
id|page
op_assign
id|page
suffix:semicolon
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|frags
(braket
id|i
)braket
dot
id|page_offset
op_assign
l_int|0
suffix:semicolon
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|frags
(braket
id|i
)braket
dot
id|size
op_assign
(paren
id|datalen
OL
id|PAGE_SIZE
ques
c_cond
id|datalen
suffix:colon
id|PAGE_SIZE
)paren
suffix:semicolon
id|datalen
op_sub_assign
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|frags
(braket
id|i
)braket
dot
id|size
suffix:semicolon
id|skb-&gt;len
op_add_assign
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|frags
(braket
id|i
)braket
dot
id|size
suffix:semicolon
id|skb-&gt;data_len
op_add_assign
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|frags
(braket
id|i
)braket
dot
id|size
suffix:semicolon
id|i
op_increment
suffix:semicolon
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|nr_frags
op_assign
id|i
suffix:semicolon
)brace
r_while
c_loop
(paren
id|i
OL
id|frags
)paren
(brace
r_int
id|rem
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
l_int|0
)paren
r_break
suffix:semicolon
id|rem
op_assign
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|frags
(braket
id|i
op_minus
l_int|1
)braket
dot
id|size
op_div
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|rem
op_eq
l_int|0
)paren
r_break
suffix:semicolon
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|frags
(braket
id|i
op_minus
l_int|1
)braket
dot
id|size
op_sub_assign
id|rem
suffix:semicolon
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|frags
(braket
id|i
)braket
op_assign
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|frags
(braket
id|i
op_minus
l_int|1
)braket
suffix:semicolon
id|get_page
c_func
(paren
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|frags
(braket
id|i
)braket
dot
id|page
)paren
suffix:semicolon
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|frags
(braket
id|i
)braket
dot
id|page
op_assign
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|frags
(braket
id|i
op_minus
l_int|1
)braket
dot
id|page
suffix:semicolon
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|frags
(braket
id|i
)braket
dot
id|page_offset
op_add_assign
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|frags
(braket
id|i
op_minus
l_int|1
)braket
dot
id|size
suffix:semicolon
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|frags
(braket
id|i
)braket
dot
id|size
op_assign
id|rem
suffix:semicolon
id|i
op_increment
suffix:semicolon
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|nr_frags
op_assign
id|i
suffix:semicolon
)brace
)brace
multiline_comment|/* Stamp the time, and sequence number, convert them to network byte order */
multiline_comment|/* should we update cloned packets too ? */
r_if
c_cond
(paren
id|pgh
)paren
(brace
r_struct
id|timeval
id|timestamp
suffix:semicolon
id|pgh-&gt;pgh_magic
op_assign
id|htonl
c_func
(paren
id|PKTGEN_MAGIC
)paren
suffix:semicolon
id|pgh-&gt;seq_num
op_assign
id|htonl
c_func
(paren
id|pkt_dev-&gt;seq_num
)paren
suffix:semicolon
id|do_gettimeofday
c_func
(paren
op_amp
id|timestamp
)paren
suffix:semicolon
id|pgh-&gt;tv_sec
op_assign
id|htonl
c_func
(paren
id|timestamp.tv_sec
)paren
suffix:semicolon
id|pgh-&gt;tv_usec
op_assign
id|htonl
c_func
(paren
id|timestamp.tv_usec
)paren
suffix:semicolon
)brace
id|pkt_dev-&gt;seq_num
op_increment
suffix:semicolon
r_return
id|skb
suffix:semicolon
)brace
DECL|function|fill_packet
r_static
r_inline
r_struct
id|sk_buff
op_star
id|fill_packet
c_func
(paren
r_struct
id|net_device
op_star
id|odev
comma
r_struct
id|pktgen_dev
op_star
id|pkt_dev
)paren
(brace
r_if
c_cond
(paren
id|pkt_dev-&gt;flags
op_amp
id|F_IPV6
)paren
(brace
r_return
id|fill_packet_ipv6
c_func
(paren
id|odev
comma
id|pkt_dev
)paren
suffix:semicolon
)brace
r_else
r_return
id|fill_packet_ipv4
c_func
(paren
id|odev
comma
id|pkt_dev
)paren
suffix:semicolon
)brace
DECL|function|pktgen_clear_counters
r_static
r_void
id|pktgen_clear_counters
c_func
(paren
r_struct
id|pktgen_dev
op_star
id|pkt_dev
)paren
(brace
id|pkt_dev-&gt;seq_num
op_assign
l_int|1
suffix:semicolon
id|pkt_dev-&gt;idle_acc
op_assign
l_int|0
suffix:semicolon
id|pkt_dev-&gt;sofar
op_assign
l_int|0
suffix:semicolon
id|pkt_dev-&gt;tx_bytes
op_assign
l_int|0
suffix:semicolon
id|pkt_dev-&gt;errors
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Set up structure for sending pkts, clear counters */
DECL|function|pktgen_run
r_static
r_void
id|pktgen_run
c_func
(paren
r_struct
id|pktgen_thread
op_star
id|t
)paren
(brace
r_struct
id|pktgen_dev
op_star
id|pkt_dev
op_assign
l_int|NULL
suffix:semicolon
r_int
id|started
op_assign
l_int|0
suffix:semicolon
id|PG_DEBUG
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;pktgen: entering pktgen_run. %p&bslash;n&quot;
comma
id|t
)paren
)paren
suffix:semicolon
id|if_lock
c_func
(paren
id|t
)paren
suffix:semicolon
r_for
c_loop
(paren
id|pkt_dev
op_assign
id|t-&gt;if_list
suffix:semicolon
id|pkt_dev
suffix:semicolon
id|pkt_dev
op_assign
id|pkt_dev-&gt;next
)paren
(brace
multiline_comment|/*&n;&t;&t; * setup odev and create initial packet.&n;&t;&t; */
id|pktgen_setup_inject
c_func
(paren
id|pkt_dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pkt_dev-&gt;odev
)paren
(brace
id|pktgen_clear_counters
c_func
(paren
id|pkt_dev
)paren
suffix:semicolon
id|pkt_dev-&gt;running
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Cranke yeself! */
id|pkt_dev-&gt;skb
op_assign
l_int|NULL
suffix:semicolon
id|pkt_dev-&gt;started_at
op_assign
id|getCurUs
c_func
(paren
)paren
suffix:semicolon
id|pkt_dev-&gt;next_tx_us
op_assign
id|getCurUs
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Transmit immediately */
id|pkt_dev-&gt;next_tx_ns
op_assign
l_int|0
suffix:semicolon
id|strcpy
c_func
(paren
id|pkt_dev-&gt;result
comma
l_string|&quot;Starting&quot;
)paren
suffix:semicolon
id|started
op_increment
suffix:semicolon
)brace
r_else
id|strcpy
c_func
(paren
id|pkt_dev-&gt;result
comma
l_string|&quot;Error starting&quot;
)paren
suffix:semicolon
)brace
id|if_unlock
c_func
(paren
id|t
)paren
suffix:semicolon
r_if
c_cond
(paren
id|started
)paren
(brace
id|t-&gt;control
op_and_assign
op_complement
(paren
id|T_STOP
)paren
suffix:semicolon
)brace
)brace
DECL|function|pktgen_stop_all_threads_ifs
r_static
r_void
id|pktgen_stop_all_threads_ifs
c_func
(paren
r_void
)paren
(brace
r_struct
id|pktgen_thread
op_star
id|t
op_assign
id|pktgen_threads
suffix:semicolon
id|PG_DEBUG
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;pktgen: entering pktgen_stop_all_threads.&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|thread_lock
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|t
)paren
(brace
id|pktgen_stop
c_func
(paren
id|t
)paren
suffix:semicolon
id|t
op_assign
id|t-&gt;next
suffix:semicolon
)brace
id|thread_unlock
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|running
r_static
r_int
id|running
c_func
(paren
r_struct
id|pktgen_thread
op_star
id|t
)paren
(brace
r_struct
id|pktgen_dev
op_star
id|next
suffix:semicolon
r_int
id|res
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|next
op_assign
id|t-&gt;if_list
suffix:semicolon
id|next
suffix:semicolon
id|next
op_assign
id|next-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|next-&gt;running
)paren
(brace
id|res
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_return
id|res
suffix:semicolon
)brace
DECL|function|pktgen_wait_thread_run
r_static
r_int
id|pktgen_wait_thread_run
c_func
(paren
r_struct
id|pktgen_thread
op_star
id|t
)paren
(brace
id|wait_queue_head_t
id|queue
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|queue
)paren
suffix:semicolon
id|if_lock
c_func
(paren
id|t
)paren
suffix:semicolon
r_while
c_loop
(paren
id|running
c_func
(paren
id|t
)paren
)paren
(brace
id|if_unlock
c_func
(paren
id|t
)paren
suffix:semicolon
id|interruptible_sleep_on_timeout
c_func
(paren
op_amp
id|queue
comma
id|HZ
op_div
l_int|10
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
r_goto
id|signal
suffix:semicolon
id|if_lock
c_func
(paren
id|t
)paren
suffix:semicolon
)brace
id|if_unlock
c_func
(paren
id|t
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
id|signal
suffix:colon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|pktgen_wait_all_threads_run
r_static
r_int
id|pktgen_wait_all_threads_run
c_func
(paren
r_void
)paren
(brace
r_struct
id|pktgen_thread
op_star
id|t
op_assign
id|pktgen_threads
suffix:semicolon
r_int
id|sig
op_assign
l_int|1
suffix:semicolon
r_while
c_loop
(paren
id|t
)paren
(brace
id|sig
op_assign
id|pktgen_wait_thread_run
c_func
(paren
id|t
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sig
op_eq
l_int|0
)paren
(brace
r_break
suffix:semicolon
)brace
id|thread_lock
c_func
(paren
)paren
suffix:semicolon
id|t
op_assign
id|t-&gt;next
suffix:semicolon
id|thread_unlock
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sig
op_eq
l_int|0
)paren
(brace
id|thread_lock
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|t
)paren
(brace
id|t-&gt;control
op_or_assign
(paren
id|T_STOP
)paren
suffix:semicolon
id|t
op_assign
id|t-&gt;next
suffix:semicolon
)brace
id|thread_unlock
c_func
(paren
)paren
suffix:semicolon
)brace
r_return
id|sig
suffix:semicolon
)brace
DECL|function|pktgen_run_all_threads
r_static
r_void
id|pktgen_run_all_threads
c_func
(paren
r_void
)paren
(brace
r_struct
id|pktgen_thread
op_star
id|t
op_assign
id|pktgen_threads
suffix:semicolon
id|PG_DEBUG
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;pktgen: entering pktgen_run_all_threads.&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|thread_lock
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|t
)paren
(brace
id|t-&gt;control
op_or_assign
(paren
id|T_RUN
)paren
suffix:semicolon
id|t
op_assign
id|t-&gt;next
suffix:semicolon
)brace
id|thread_unlock
c_func
(paren
)paren
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|schedule_timeout
c_func
(paren
id|HZ
op_div
l_int|8
)paren
suffix:semicolon
multiline_comment|/* Propagate thread-&gt;control  */
id|pktgen_wait_all_threads_run
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|show_results
r_static
r_void
id|show_results
c_func
(paren
r_struct
id|pktgen_dev
op_star
id|pkt_dev
comma
r_int
id|nr_frags
)paren
(brace
id|__u64
id|total_us
comma
id|bps
comma
id|mbps
comma
id|pps
comma
id|idle
suffix:semicolon
r_char
op_star
id|p
op_assign
id|pkt_dev-&gt;result
suffix:semicolon
id|total_us
op_assign
id|pkt_dev-&gt;stopped_at
op_minus
id|pkt_dev-&gt;started_at
suffix:semicolon
id|idle
op_assign
id|pkt_dev-&gt;idle_acc
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;OK: %llu(c%llu+d%llu) usec, %llu (%dbyte,%dfrags)&bslash;n&quot;
comma
(paren
r_int
r_int
r_int
)paren
id|total_us
comma
(paren
r_int
r_int
r_int
)paren
(paren
id|total_us
op_minus
id|idle
)paren
comma
(paren
r_int
r_int
r_int
)paren
id|idle
comma
(paren
r_int
r_int
r_int
)paren
id|pkt_dev-&gt;sofar
comma
id|pkt_dev-&gt;cur_pkt_size
comma
id|nr_frags
)paren
suffix:semicolon
id|pps
op_assign
id|pkt_dev-&gt;sofar
op_star
id|USEC_PER_SEC
suffix:semicolon
r_while
c_loop
(paren
(paren
id|total_us
op_rshift
l_int|32
)paren
op_ne
l_int|0
)paren
(brace
id|pps
op_rshift_assign
l_int|1
suffix:semicolon
id|total_us
op_rshift_assign
l_int|1
suffix:semicolon
)brace
id|do_div
c_func
(paren
id|pps
comma
id|total_us
)paren
suffix:semicolon
id|bps
op_assign
id|pps
op_star
l_int|8
op_star
id|pkt_dev-&gt;cur_pkt_size
suffix:semicolon
id|mbps
op_assign
id|bps
suffix:semicolon
id|do_div
c_func
(paren
id|mbps
comma
l_int|1000000
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;  %llupps %lluMb/sec (%llubps) errors: %llu&quot;
comma
(paren
r_int
r_int
r_int
)paren
id|pps
comma
(paren
r_int
r_int
r_int
)paren
id|mbps
comma
(paren
r_int
r_int
r_int
)paren
id|bps
comma
(paren
r_int
r_int
r_int
)paren
id|pkt_dev-&gt;errors
)paren
suffix:semicolon
)brace
multiline_comment|/* Set stopped-at timer, remove from running list, do counters &amp; statistics */
DECL|function|pktgen_stop_device
r_static
r_int
id|pktgen_stop_device
c_func
(paren
r_struct
id|pktgen_dev
op_star
id|pkt_dev
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|pkt_dev-&gt;running
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;pktgen: interface: %s is already stopped&bslash;n&quot;
comma
id|pkt_dev-&gt;ifname
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pkt_dev-&gt;skb
)paren
id|kfree_skb
c_func
(paren
id|pkt_dev-&gt;skb
)paren
suffix:semicolon
id|pkt_dev-&gt;stopped_at
op_assign
id|getCurUs
c_func
(paren
)paren
suffix:semicolon
id|pkt_dev-&gt;running
op_assign
l_int|0
suffix:semicolon
id|show_results
c_func
(paren
id|pkt_dev
comma
id|skb_shinfo
c_func
(paren
id|pkt_dev-&gt;skb
)paren
op_member_access_from_pointer
id|nr_frags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|next_to_run
r_static
r_struct
id|pktgen_dev
op_star
id|next_to_run
c_func
(paren
r_struct
id|pktgen_thread
op_star
id|t
)paren
(brace
r_struct
id|pktgen_dev
op_star
id|next
comma
op_star
id|best
op_assign
l_int|NULL
suffix:semicolon
id|if_lock
c_func
(paren
id|t
)paren
suffix:semicolon
r_for
c_loop
(paren
id|next
op_assign
id|t-&gt;if_list
suffix:semicolon
id|next
suffix:semicolon
id|next
op_assign
id|next-&gt;next
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|next-&gt;running
)paren
(brace
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|best
op_eq
l_int|NULL
)paren
(brace
id|best
op_assign
id|next
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|next-&gt;next_tx_us
OL
id|best-&gt;next_tx_us
)paren
id|best
op_assign
id|next
suffix:semicolon
)brace
id|if_unlock
c_func
(paren
id|t
)paren
suffix:semicolon
r_return
id|best
suffix:semicolon
)brace
DECL|function|pktgen_stop
r_static
r_void
id|pktgen_stop
c_func
(paren
r_struct
id|pktgen_thread
op_star
id|t
)paren
(brace
r_struct
id|pktgen_dev
op_star
id|next
op_assign
l_int|NULL
suffix:semicolon
id|PG_DEBUG
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;pktgen: entering pktgen_stop.&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|if_lock
c_func
(paren
id|t
)paren
suffix:semicolon
r_for
c_loop
(paren
id|next
op_assign
id|t-&gt;if_list
suffix:semicolon
id|next
suffix:semicolon
id|next
op_assign
id|next-&gt;next
)paren
(brace
id|pktgen_stop_device
c_func
(paren
id|next
)paren
suffix:semicolon
)brace
id|if_unlock
c_func
(paren
id|t
)paren
suffix:semicolon
)brace
DECL|function|pktgen_rem_all_ifs
r_static
r_void
id|pktgen_rem_all_ifs
c_func
(paren
r_struct
id|pktgen_thread
op_star
id|t
)paren
(brace
r_struct
id|pktgen_dev
op_star
id|cur
comma
op_star
id|next
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Remove all devices, free mem */
id|if_lock
c_func
(paren
id|t
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cur
op_assign
id|t-&gt;if_list
suffix:semicolon
id|cur
suffix:semicolon
id|cur
op_assign
id|next
)paren
(brace
id|next
op_assign
id|cur-&gt;next
suffix:semicolon
id|pktgen_remove_device
c_func
(paren
id|t
comma
id|cur
)paren
suffix:semicolon
)brace
id|if_unlock
c_func
(paren
id|t
)paren
suffix:semicolon
)brace
DECL|function|pktgen_rem_thread
r_static
r_void
id|pktgen_rem_thread
c_func
(paren
r_struct
id|pktgen_thread
op_star
id|t
)paren
(brace
multiline_comment|/* Remove from the thread list */
r_struct
id|pktgen_thread
op_star
id|tmp
op_assign
id|pktgen_threads
suffix:semicolon
r_if
c_cond
(paren
id|strlen
c_func
(paren
id|t-&gt;fname
)paren
)paren
id|remove_proc_entry
c_func
(paren
id|t-&gt;fname
comma
l_int|NULL
)paren
suffix:semicolon
id|thread_lock
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
op_eq
id|t
)paren
id|pktgen_threads
op_assign
id|tmp-&gt;next
suffix:semicolon
r_else
(brace
r_while
c_loop
(paren
id|tmp
)paren
(brace
r_if
c_cond
(paren
id|tmp-&gt;next
op_eq
id|t
)paren
(brace
id|tmp-&gt;next
op_assign
id|t-&gt;next
suffix:semicolon
id|t-&gt;next
op_assign
l_int|NULL
suffix:semicolon
r_break
suffix:semicolon
)brace
id|tmp
op_assign
id|tmp-&gt;next
suffix:semicolon
)brace
)brace
id|thread_unlock
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|pktgen_xmit
id|__inline__
r_void
id|pktgen_xmit
c_func
(paren
r_struct
id|pktgen_dev
op_star
id|pkt_dev
)paren
(brace
r_struct
id|net_device
op_star
id|odev
op_assign
l_int|NULL
suffix:semicolon
id|__u64
id|idle_start
op_assign
l_int|0
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|odev
op_assign
id|pkt_dev-&gt;odev
suffix:semicolon
r_if
c_cond
(paren
id|pkt_dev-&gt;delay_us
op_logical_or
id|pkt_dev-&gt;delay_ns
)paren
(brace
id|u64
id|now
suffix:semicolon
id|now
op_assign
id|getCurUs
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|now
OL
id|pkt_dev-&gt;next_tx_us
)paren
id|spin
c_func
(paren
id|pkt_dev
comma
id|pkt_dev-&gt;next_tx_us
)paren
suffix:semicolon
multiline_comment|/* This is max DELAY, this has special meaning of&n;&t;&t; * &quot;never transmit&quot;&n;&t;&t; */
r_if
c_cond
(paren
id|pkt_dev-&gt;delay_us
op_eq
l_int|0x7FFFFFFF
)paren
(brace
id|pkt_dev-&gt;next_tx_us
op_assign
id|getCurUs
c_func
(paren
)paren
op_plus
id|pkt_dev-&gt;delay_us
suffix:semicolon
id|pkt_dev-&gt;next_tx_ns
op_assign
id|pkt_dev-&gt;delay_ns
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|netif_queue_stopped
c_func
(paren
id|odev
)paren
op_logical_or
id|need_resched
c_func
(paren
)paren
)paren
(brace
id|idle_start
op_assign
id|getCurUs
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|netif_running
c_func
(paren
id|odev
)paren
)paren
(brace
id|pktgen_stop_device
c_func
(paren
id|pkt_dev
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|need_resched
c_func
(paren
)paren
)paren
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|pkt_dev-&gt;idle_acc
op_add_assign
id|getCurUs
c_func
(paren
)paren
op_minus
id|idle_start
suffix:semicolon
r_if
c_cond
(paren
id|netif_queue_stopped
c_func
(paren
id|odev
)paren
)paren
(brace
id|pkt_dev-&gt;next_tx_us
op_assign
id|getCurUs
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* TODO */
id|pkt_dev-&gt;next_tx_ns
op_assign
l_int|0
suffix:semicolon
r_goto
id|out
suffix:semicolon
multiline_comment|/* Try the next interface */
)brace
)brace
r_if
c_cond
(paren
id|pkt_dev-&gt;last_ok
op_logical_or
op_logical_neg
id|pkt_dev-&gt;skb
)paren
(brace
r_if
c_cond
(paren
(paren
op_increment
id|pkt_dev-&gt;clone_count
op_ge
id|pkt_dev-&gt;clone_skb
)paren
op_logical_or
(paren
op_logical_neg
id|pkt_dev-&gt;skb
)paren
)paren
(brace
multiline_comment|/* build a new pkt */
r_if
c_cond
(paren
id|pkt_dev-&gt;skb
)paren
id|kfree_skb
c_func
(paren
id|pkt_dev-&gt;skb
)paren
suffix:semicolon
id|pkt_dev-&gt;skb
op_assign
id|fill_packet
c_func
(paren
id|odev
comma
id|pkt_dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pkt_dev-&gt;skb
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;pktgen: ERROR: couldn&squot;t allocate skb in fill_packet.&bslash;n&quot;
)paren
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|pkt_dev-&gt;clone_count
op_decrement
suffix:semicolon
multiline_comment|/* back out increment, OOM */
r_goto
id|out
suffix:semicolon
)brace
id|pkt_dev-&gt;allocated_skbs
op_increment
suffix:semicolon
id|pkt_dev-&gt;clone_count
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* reset counter */
)brace
)brace
id|spin_lock_irq
c_func
(paren
op_amp
id|odev-&gt;xmit_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|netif_queue_stopped
c_func
(paren
id|odev
)paren
)paren
(brace
id|u64
id|now
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
(paren
id|pkt_dev-&gt;skb-&gt;users
)paren
)paren
suffix:semicolon
id|ret
op_assign
id|odev
op_member_access_from_pointer
id|hard_start_xmit
c_func
(paren
id|pkt_dev-&gt;skb
comma
id|odev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
id|ret
op_eq
id|NETDEV_TX_OK
)paren
)paren
(brace
id|pkt_dev-&gt;last_ok
op_assign
l_int|1
suffix:semicolon
id|pkt_dev-&gt;sofar
op_increment
suffix:semicolon
id|pkt_dev-&gt;seq_num
op_increment
suffix:semicolon
id|pkt_dev-&gt;tx_bytes
op_add_assign
id|pkt_dev-&gt;cur_pkt_size
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Retry it next time */
id|atomic_dec
c_func
(paren
op_amp
(paren
id|pkt_dev-&gt;skb-&gt;users
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|debug
op_logical_and
id|net_ratelimit
c_func
(paren
)paren
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;pktgen: Hard xmit error&bslash;n&quot;
)paren
suffix:semicolon
id|pkt_dev-&gt;errors
op_increment
suffix:semicolon
id|pkt_dev-&gt;last_ok
op_assign
l_int|0
suffix:semicolon
id|pkt_dev-&gt;next_tx_us
op_assign
id|getCurUs
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* TODO */
id|pkt_dev-&gt;next_tx_ns
op_assign
l_int|0
suffix:semicolon
)brace
id|pkt_dev-&gt;next_tx_us
op_add_assign
id|pkt_dev-&gt;delay_us
suffix:semicolon
id|pkt_dev-&gt;next_tx_ns
op_add_assign
id|pkt_dev-&gt;delay_ns
suffix:semicolon
r_if
c_cond
(paren
id|pkt_dev-&gt;next_tx_ns
OG
l_int|1000
)paren
(brace
id|pkt_dev-&gt;next_tx_us
op_increment
suffix:semicolon
id|pkt_dev-&gt;next_tx_ns
op_sub_assign
l_int|1000
suffix:semicolon
)brace
id|now
op_assign
id|getCurUs
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|now
OG
id|pkt_dev-&gt;next_tx_us
)paren
(brace
multiline_comment|/* TODO: this code is slightly wonky.  */
id|pkt_dev-&gt;errors
op_increment
suffix:semicolon
id|pkt_dev-&gt;next_tx_us
op_assign
id|now
op_minus
id|pkt_dev-&gt;delay_us
suffix:semicolon
id|pkt_dev-&gt;next_tx_ns
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* Retry it next time */
id|pkt_dev-&gt;last_ok
op_assign
l_int|0
suffix:semicolon
id|pkt_dev-&gt;next_tx_us
op_assign
id|getCurUs
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* TODO */
id|pkt_dev-&gt;next_tx_ns
op_assign
l_int|0
suffix:semicolon
)brace
id|spin_unlock_irq
c_func
(paren
op_amp
id|odev-&gt;xmit_lock
)paren
suffix:semicolon
multiline_comment|/* If pkt_dev-&gt;count is zero, then run forever */
r_if
c_cond
(paren
(paren
id|pkt_dev-&gt;count
op_ne
l_int|0
)paren
op_logical_and
(paren
id|pkt_dev-&gt;sofar
op_ge
id|pkt_dev-&gt;count
)paren
)paren
(brace
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
(paren
id|pkt_dev-&gt;skb-&gt;users
)paren
)paren
op_ne
l_int|1
)paren
(brace
id|idle_start
op_assign
id|getCurUs
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|atomic_read
c_func
(paren
op_amp
(paren
id|pkt_dev-&gt;skb-&gt;users
)paren
)paren
op_ne
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
id|pkt_dev-&gt;idle_acc
op_add_assign
id|getCurUs
c_func
(paren
)paren
op_minus
id|idle_start
suffix:semicolon
)brace
multiline_comment|/* Done with this */
id|pktgen_stop_device
c_func
(paren
id|pkt_dev
)paren
suffix:semicolon
)brace
id|out
suffix:colon
suffix:semicolon
)brace
multiline_comment|/* &n; * Main loop of the thread goes here&n; */
DECL|function|pktgen_thread_worker
r_static
r_void
id|pktgen_thread_worker
c_func
(paren
r_struct
id|pktgen_thread
op_star
id|t
)paren
(brace
r_struct
id|pktgen_dev
op_star
id|pkt_dev
op_assign
l_int|NULL
suffix:semicolon
r_int
id|cpu
op_assign
id|t-&gt;cpu
suffix:semicolon
id|sigset_t
id|tmpsig
suffix:semicolon
id|u32
id|max_before_softirq
suffix:semicolon
id|u32
id|tx_since_softirq
op_assign
l_int|0
suffix:semicolon
id|daemonize
c_func
(paren
l_string|&quot;pktgen/%d&quot;
comma
id|cpu
)paren
suffix:semicolon
multiline_comment|/* Block all signals except SIGKILL, SIGSTOP and SIGTERM */
id|spin_lock_irq
c_func
(paren
op_amp
id|current-&gt;sighand-&gt;siglock
)paren
suffix:semicolon
id|tmpsig
op_assign
id|current-&gt;blocked
suffix:semicolon
id|siginitsetinv
c_func
(paren
op_amp
id|current-&gt;blocked
comma
id|sigmask
c_func
(paren
id|SIGKILL
)paren
op_or
id|sigmask
c_func
(paren
id|SIGSTOP
)paren
op_or
id|sigmask
c_func
(paren
id|SIGTERM
)paren
)paren
suffix:semicolon
id|recalc_sigpending
c_func
(paren
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|current-&gt;sighand-&gt;siglock
)paren
suffix:semicolon
multiline_comment|/* Migrate to the right CPU */
id|set_cpus_allowed
c_func
(paren
id|current
comma
id|cpumask_of_cpu
c_func
(paren
id|cpu
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|smp_processor_id
c_func
(paren
)paren
op_ne
id|cpu
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|t-&gt;queue
)paren
suffix:semicolon
id|t-&gt;control
op_and_assign
op_complement
(paren
id|T_TERMINATE
)paren
suffix:semicolon
id|t-&gt;control
op_and_assign
op_complement
(paren
id|T_RUN
)paren
suffix:semicolon
id|t-&gt;control
op_and_assign
op_complement
(paren
id|T_STOP
)paren
suffix:semicolon
id|t-&gt;control
op_and_assign
op_complement
(paren
id|T_REMDEV
)paren
suffix:semicolon
id|t-&gt;pid
op_assign
id|current-&gt;pid
suffix:semicolon
id|PG_DEBUG
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;pktgen: starting pktgen/%d:  pid=%d&bslash;n&quot;
comma
id|cpu
comma
id|current-&gt;pid
)paren
)paren
suffix:semicolon
id|max_before_softirq
op_assign
id|t-&gt;max_before_softirq
suffix:semicolon
id|__set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|__set_current_state
c_func
(paren
id|TASK_RUNNING
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Get next dev to xmit -- if any.&n;&t;&t; */
id|pkt_dev
op_assign
id|next_to_run
c_func
(paren
id|t
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pkt_dev
)paren
(brace
id|pktgen_xmit
c_func
(paren
id|pkt_dev
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * We like to stay RUNNING but must also give&n;&t;&t;&t; * others fair share.&n;&t;&t;&t; */
id|tx_since_softirq
op_add_assign
id|pkt_dev-&gt;last_ok
suffix:semicolon
r_if
c_cond
(paren
id|tx_since_softirq
OG
id|max_before_softirq
)paren
(brace
r_if
c_cond
(paren
id|softirq_pending
c_func
(paren
id|smp_processor_id
c_func
(paren
)paren
)paren
)paren
(brace
id|do_softirq
c_func
(paren
)paren
suffix:semicolon
)brace
id|tx_since_softirq
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_else
id|interruptible_sleep_on_timeout
c_func
(paren
op_amp
(paren
id|t-&gt;queue
)paren
comma
id|HZ
op_div
l_int|10
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t; * Back from sleep, either due to the timeout or signal.&n;&t;&t; * We check if we have any &quot;posted&quot; work for us.&n;&t;&t; */
r_if
c_cond
(paren
id|t-&gt;control
op_amp
id|T_TERMINATE
op_logical_or
id|signal_pending
c_func
(paren
id|current
)paren
)paren
multiline_comment|/* we received a request to terminate ourself */
r_break
suffix:semicolon
r_if
c_cond
(paren
id|t-&gt;control
op_amp
id|T_STOP
)paren
(brace
id|pktgen_stop
c_func
(paren
id|t
)paren
suffix:semicolon
id|t-&gt;control
op_and_assign
op_complement
(paren
id|T_STOP
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|t-&gt;control
op_amp
id|T_RUN
)paren
(brace
id|pktgen_run
c_func
(paren
id|t
)paren
suffix:semicolon
id|t-&gt;control
op_and_assign
op_complement
(paren
id|T_RUN
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|t-&gt;control
op_amp
id|T_REMDEV
)paren
(brace
id|pktgen_rem_all_ifs
c_func
(paren
id|t
)paren
suffix:semicolon
id|t-&gt;control
op_and_assign
op_complement
(paren
id|T_REMDEV
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|need_resched
c_func
(paren
)paren
)paren
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
id|PG_DEBUG
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;pktgen: %s stopping all device&bslash;n&quot;
comma
id|t-&gt;name
)paren
)paren
suffix:semicolon
id|pktgen_stop
c_func
(paren
id|t
)paren
suffix:semicolon
id|PG_DEBUG
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;pktgen: %s removing all device&bslash;n&quot;
comma
id|t-&gt;name
)paren
)paren
suffix:semicolon
id|pktgen_rem_all_ifs
c_func
(paren
id|t
)paren
suffix:semicolon
id|PG_DEBUG
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;pktgen: %s removing thread.&bslash;n&quot;
comma
id|t-&gt;name
)paren
)paren
suffix:semicolon
id|pktgen_rem_thread
c_func
(paren
id|t
)paren
suffix:semicolon
)brace
DECL|function|pktgen_find_dev
r_static
r_struct
id|pktgen_dev
op_star
id|pktgen_find_dev
c_func
(paren
r_struct
id|pktgen_thread
op_star
id|t
comma
r_const
r_char
op_star
id|ifname
)paren
(brace
r_struct
id|pktgen_dev
op_star
id|pkt_dev
op_assign
l_int|NULL
suffix:semicolon
id|if_lock
c_func
(paren
id|t
)paren
suffix:semicolon
r_for
c_loop
(paren
id|pkt_dev
op_assign
id|t-&gt;if_list
suffix:semicolon
id|pkt_dev
suffix:semicolon
id|pkt_dev
op_assign
id|pkt_dev-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|pkt_dev-&gt;ifname
comma
id|ifname
)paren
op_eq
l_int|0
)paren
(brace
r_goto
id|out
suffix:semicolon
)brace
)brace
id|out
suffix:colon
id|if_unlock
c_func
(paren
id|t
)paren
suffix:semicolon
id|PG_DEBUG
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;pktgen: find_dev(%s) returning %p&bslash;n&quot;
comma
id|ifname
comma
id|pkt_dev
)paren
)paren
suffix:semicolon
r_return
id|pkt_dev
suffix:semicolon
)brace
multiline_comment|/* &n; * Adds a dev at front of if_list. &n; */
DECL|function|add_dev_to_thread
r_static
r_int
id|add_dev_to_thread
c_func
(paren
r_struct
id|pktgen_thread
op_star
id|t
comma
r_struct
id|pktgen_dev
op_star
id|pkt_dev
)paren
(brace
r_int
id|rv
op_assign
l_int|0
suffix:semicolon
id|if_lock
c_func
(paren
id|t
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pkt_dev-&gt;pg_thread
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;pktgen: ERROR:  already assigned to a thread.&bslash;n&quot;
)paren
suffix:semicolon
id|rv
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|L_PUSH
c_func
(paren
id|t-&gt;if_list
comma
id|pkt_dev
)paren
suffix:semicolon
id|pkt_dev-&gt;pg_thread
op_assign
id|t
suffix:semicolon
id|pkt_dev-&gt;running
op_assign
l_int|0
suffix:semicolon
id|out
suffix:colon
id|if_unlock
c_func
(paren
id|t
)paren
suffix:semicolon
r_return
id|rv
suffix:semicolon
)brace
multiline_comment|/* Called under thread lock */
DECL|function|pktgen_add_device
r_static
r_int
id|pktgen_add_device
c_func
(paren
r_struct
id|pktgen_thread
op_star
id|t
comma
r_const
r_char
op_star
id|ifname
)paren
(brace
r_struct
id|pktgen_dev
op_star
id|pkt_dev
suffix:semicolon
multiline_comment|/* We don&squot;t allow a device to be on several threads */
r_if
c_cond
(paren
(paren
id|pkt_dev
op_assign
id|__pktgen_NN_threads
c_func
(paren
id|ifname
comma
id|FIND
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|pkt_dev
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|pktgen_dev
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pkt_dev
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|memset
c_func
(paren
id|pkt_dev
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|pktgen_dev
)paren
)paren
suffix:semicolon
id|pkt_dev-&gt;flows
op_assign
id|vmalloc
c_func
(paren
id|MAX_CFLOWS
op_star
r_sizeof
(paren
r_struct
id|flow_state
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pkt_dev-&gt;flows
op_eq
l_int|NULL
)paren
(brace
id|kfree
c_func
(paren
id|pkt_dev
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|memset
c_func
(paren
id|pkt_dev-&gt;flows
comma
l_int|0
comma
id|MAX_CFLOWS
op_star
r_sizeof
(paren
r_struct
id|flow_state
)paren
)paren
suffix:semicolon
id|pkt_dev-&gt;min_pkt_size
op_assign
id|ETH_ZLEN
suffix:semicolon
id|pkt_dev-&gt;max_pkt_size
op_assign
id|ETH_ZLEN
suffix:semicolon
id|pkt_dev-&gt;nfrags
op_assign
l_int|0
suffix:semicolon
id|pkt_dev-&gt;clone_skb
op_assign
id|pg_clone_skb_d
suffix:semicolon
id|pkt_dev-&gt;delay_us
op_assign
id|pg_delay_d
op_div
l_int|1000
suffix:semicolon
id|pkt_dev-&gt;delay_ns
op_assign
id|pg_delay_d
op_mod
l_int|1000
suffix:semicolon
id|pkt_dev-&gt;count
op_assign
id|pg_count_d
suffix:semicolon
id|pkt_dev-&gt;sofar
op_assign
l_int|0
suffix:semicolon
id|pkt_dev-&gt;udp_src_min
op_assign
l_int|9
suffix:semicolon
multiline_comment|/* sink port */
id|pkt_dev-&gt;udp_src_max
op_assign
l_int|9
suffix:semicolon
id|pkt_dev-&gt;udp_dst_min
op_assign
l_int|9
suffix:semicolon
id|pkt_dev-&gt;udp_dst_max
op_assign
l_int|9
suffix:semicolon
id|strncpy
c_func
(paren
id|pkt_dev-&gt;ifname
comma
id|ifname
comma
l_int|31
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|pkt_dev-&gt;fname
comma
l_string|&quot;net/%s/%s&quot;
comma
id|PG_PROC_DIR
comma
id|ifname
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pktgen_setup_dev
c_func
(paren
id|pkt_dev
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;pktgen: ERROR: pktgen_setup_dev failed.&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pkt_dev-&gt;flows
)paren
id|vfree
c_func
(paren
id|pkt_dev-&gt;flows
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|pkt_dev
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|pkt_dev-&gt;proc_ent
op_assign
id|create_proc_entry
c_func
(paren
id|pkt_dev-&gt;fname
comma
l_int|0600
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pkt_dev-&gt;proc_ent
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;pktgen: cannot create %s procfs entry.&bslash;n&quot;
comma
id|pkt_dev-&gt;fname
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pkt_dev-&gt;flows
)paren
id|vfree
c_func
(paren
id|pkt_dev-&gt;flows
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|pkt_dev
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|pkt_dev-&gt;proc_ent-&gt;read_proc
op_assign
id|proc_if_read
suffix:semicolon
id|pkt_dev-&gt;proc_ent-&gt;write_proc
op_assign
id|proc_if_write
suffix:semicolon
id|pkt_dev-&gt;proc_ent-&gt;data
op_assign
(paren
r_void
op_star
)paren
(paren
id|pkt_dev
)paren
suffix:semicolon
id|pkt_dev-&gt;proc_ent-&gt;owner
op_assign
id|THIS_MODULE
suffix:semicolon
r_return
id|add_dev_to_thread
c_func
(paren
id|t
comma
id|pkt_dev
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;pktgen: ERROR: interface already used.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
)brace
DECL|function|pktgen_find_thread
r_static
r_struct
id|pktgen_thread
op_star
id|pktgen_find_thread
c_func
(paren
r_const
r_char
op_star
id|name
)paren
(brace
r_struct
id|pktgen_thread
op_star
id|t
op_assign
l_int|NULL
suffix:semicolon
id|thread_lock
c_func
(paren
)paren
suffix:semicolon
id|t
op_assign
id|pktgen_threads
suffix:semicolon
r_while
c_loop
(paren
id|t
)paren
(brace
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|t-&gt;name
comma
id|name
)paren
op_eq
l_int|0
)paren
r_break
suffix:semicolon
id|t
op_assign
id|t-&gt;next
suffix:semicolon
)brace
id|thread_unlock
c_func
(paren
)paren
suffix:semicolon
r_return
id|t
suffix:semicolon
)brace
DECL|function|pktgen_create_thread
r_static
r_int
id|pktgen_create_thread
c_func
(paren
r_const
r_char
op_star
id|name
comma
r_int
id|cpu
)paren
(brace
r_struct
id|pktgen_thread
op_star
id|t
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|strlen
c_func
(paren
id|name
)paren
OG
l_int|31
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;pktgen: ERROR:  Thread name cannot be more than 31 characters.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pktgen_find_thread
c_func
(paren
id|name
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;pktgen: ERROR: thread: %s already exists&bslash;n&quot;
comma
id|name
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|t
op_assign
(paren
r_struct
id|pktgen_thread
op_star
)paren
(paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|pktgen_thread
)paren
comma
id|GFP_KERNEL
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|t
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;pktgen: ERROR: out of memory, can&squot;t create new thread.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|memset
c_func
(paren
id|t
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|pktgen_thread
)paren
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|t-&gt;name
comma
id|name
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|t-&gt;if_lock
)paren
suffix:semicolon
id|t-&gt;cpu
op_assign
id|cpu
suffix:semicolon
id|sprintf
c_func
(paren
id|t-&gt;fname
comma
l_string|&quot;net/%s/%s&quot;
comma
id|PG_PROC_DIR
comma
id|t-&gt;name
)paren
suffix:semicolon
id|t-&gt;proc_ent
op_assign
id|create_proc_entry
c_func
(paren
id|t-&gt;fname
comma
l_int|0600
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|t-&gt;proc_ent
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;pktgen: cannot create %s procfs entry.&bslash;n&quot;
comma
id|t-&gt;fname
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|t
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|t-&gt;proc_ent-&gt;read_proc
op_assign
id|proc_thread_read
suffix:semicolon
id|t-&gt;proc_ent-&gt;write_proc
op_assign
id|proc_thread_write
suffix:semicolon
id|t-&gt;proc_ent-&gt;data
op_assign
(paren
r_void
op_star
)paren
(paren
id|t
)paren
suffix:semicolon
id|t-&gt;proc_ent-&gt;owner
op_assign
id|THIS_MODULE
suffix:semicolon
id|t-&gt;next
op_assign
id|pktgen_threads
suffix:semicolon
id|pktgen_threads
op_assign
id|t
suffix:semicolon
r_if
c_cond
(paren
id|kernel_thread
c_func
(paren
(paren
r_void
op_star
)paren
id|pktgen_thread_worker
comma
(paren
r_void
op_star
)paren
id|t
comma
id|CLONE_FS
op_or
id|CLONE_FILES
op_or
id|CLONE_SIGHAND
)paren
OL
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;pktgen: kernel_thread() failed for cpu %d&bslash;n&quot;
comma
id|t-&gt;cpu
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* &n; * Removes a device from the thread if_list. &n; */
DECL|function|_rem_dev_from_if_list
r_static
r_void
id|_rem_dev_from_if_list
c_func
(paren
r_struct
id|pktgen_thread
op_star
id|t
comma
r_struct
id|pktgen_dev
op_star
id|pkt_dev
)paren
(brace
r_struct
id|pktgen_dev
op_star
id|i
comma
op_star
id|prev
op_assign
l_int|NULL
suffix:semicolon
id|i
op_assign
id|t-&gt;if_list
suffix:semicolon
r_while
c_loop
(paren
id|i
)paren
(brace
r_if
c_cond
(paren
id|i
op_eq
id|pkt_dev
)paren
(brace
r_if
c_cond
(paren
id|prev
)paren
(brace
id|prev-&gt;next
op_assign
id|i-&gt;next
suffix:semicolon
)brace
r_else
id|t-&gt;if_list
op_assign
l_int|NULL
suffix:semicolon
r_break
suffix:semicolon
)brace
id|prev
op_assign
id|i
suffix:semicolon
id|i
op_assign
id|i-&gt;next
suffix:semicolon
)brace
)brace
DECL|function|pktgen_remove_device
r_static
r_int
id|pktgen_remove_device
c_func
(paren
r_struct
id|pktgen_thread
op_star
id|t
comma
r_struct
id|pktgen_dev
op_star
id|pkt_dev
)paren
(brace
id|PG_DEBUG
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;pktgen: remove_device pkt_dev=%p&bslash;n&quot;
comma
id|pkt_dev
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pkt_dev-&gt;running
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;pktgen:WARNING: trying to remove a running interface, stopping it now.&bslash;n&quot;
)paren
suffix:semicolon
id|pktgen_stop_device
c_func
(paren
id|pkt_dev
)paren
suffix:semicolon
)brace
multiline_comment|/* Dis-associate from the interface */
r_if
c_cond
(paren
id|pkt_dev-&gt;odev
)paren
(brace
id|dev_put
c_func
(paren
id|pkt_dev-&gt;odev
)paren
suffix:semicolon
id|pkt_dev-&gt;odev
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* And update the thread if_list */
id|_rem_dev_from_if_list
c_func
(paren
id|t
comma
id|pkt_dev
)paren
suffix:semicolon
multiline_comment|/* Clean up proc file system */
r_if
c_cond
(paren
id|strlen
c_func
(paren
id|pkt_dev-&gt;fname
)paren
)paren
id|remove_proc_entry
c_func
(paren
id|pkt_dev-&gt;fname
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pkt_dev-&gt;flows
)paren
id|vfree
c_func
(paren
id|pkt_dev-&gt;flows
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|pkt_dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|pg_init
r_static
r_int
id|__init
id|pg_init
c_func
(paren
r_void
)paren
(brace
r_int
id|cpu
suffix:semicolon
id|printk
c_func
(paren
id|version
)paren
suffix:semicolon
id|module_fname
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|create_proc_dir
c_func
(paren
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|module_fname
comma
l_string|&quot;net/%s/pgctrl&quot;
comma
id|PG_PROC_DIR
)paren
suffix:semicolon
id|module_proc_ent
op_assign
id|create_proc_entry
c_func
(paren
id|module_fname
comma
l_int|0600
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|module_proc_ent
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;pktgen: ERROR: cannot create %s procfs entry.&bslash;n&quot;
comma
id|module_fname
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|module_proc_ent-&gt;proc_fops
op_assign
op_amp
id|pktgen_fops
suffix:semicolon
id|module_proc_ent-&gt;data
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Register us to receive netdevice events */
id|register_netdevice_notifier
c_func
(paren
op_amp
id|pktgen_notifier_block
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cpu
op_assign
l_int|0
suffix:semicolon
id|cpu
OL
id|NR_CPUS
suffix:semicolon
id|cpu
op_increment
)paren
(brace
r_char
id|buf
(braket
l_int|30
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cpu_online
c_func
(paren
id|cpu
)paren
)paren
r_continue
suffix:semicolon
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;kpktgend_%i&quot;
comma
id|cpu
)paren
suffix:semicolon
id|pktgen_create_thread
c_func
(paren
id|buf
comma
id|cpu
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|pg_cleanup
r_static
r_void
id|__exit
id|pg_cleanup
c_func
(paren
r_void
)paren
(brace
id|wait_queue_head_t
id|queue
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|queue
)paren
suffix:semicolon
multiline_comment|/* Stop all interfaces &amp; threads */
r_while
c_loop
(paren
id|pktgen_threads
)paren
(brace
r_struct
id|pktgen_thread
op_star
id|t
op_assign
id|pktgen_threads
suffix:semicolon
id|pktgen_threads-&gt;control
op_or_assign
(paren
id|T_TERMINATE
)paren
suffix:semicolon
r_while
c_loop
(paren
id|t
op_eq
id|pktgen_threads
)paren
(brace
id|interruptible_sleep_on_timeout
c_func
(paren
op_amp
id|queue
comma
id|HZ
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Un-register us from receiving netdevice events */
id|unregister_netdevice_notifier
c_func
(paren
op_amp
id|pktgen_notifier_block
)paren
suffix:semicolon
multiline_comment|/* Clean up proc file system */
id|remove_proc_entry
c_func
(paren
id|module_fname
comma
l_int|NULL
)paren
suffix:semicolon
id|remove_proc_dir
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|variable|pg_init
id|module_init
c_func
(paren
id|pg_init
)paren
suffix:semicolon
DECL|variable|pg_cleanup
id|module_exit
c_func
(paren
id|pg_cleanup
)paren
suffix:semicolon
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Robert Olsson &lt;robert.olsson@its.uu.se&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;Packet Generator tool&quot;
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
id|module_param
c_func
(paren
id|pg_count_d
comma
r_int
comma
l_int|0
)paren
suffix:semicolon
id|module_param
c_func
(paren
id|pg_delay_d
comma
r_int
comma
l_int|0
)paren
suffix:semicolon
id|module_param
c_func
(paren
id|pg_clone_skb_d
comma
r_int
comma
l_int|0
)paren
suffix:semicolon
id|module_param
c_func
(paren
id|debug
comma
r_int
comma
l_int|0
)paren
suffix:semicolon
eof
