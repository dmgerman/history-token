multiline_comment|/*&n; *&t;Routines having to do with the &squot;struct sk_buff&squot; memory handlers.&n; *&n; *&t;Authors:&t;Alan Cox &lt;iiitac@pyr.swan.ac.uk&gt;&n; *&t;&t;&t;Florian La Roche &lt;rzsfl@rz.uni-sb.de&gt;&n; *&n; *&t;Version:&t;$Id: skbuff.c,v 1.90 2001/11/07 05:56:19 davem Exp $&n; *&n; *&t;Fixes:&n; *&t;&t;Alan Cox&t;:&t;Fixed the worst of the load&n; *&t;&t;&t;&t;&t;balancer bugs.&n; *&t;&t;Dave Platt&t;:&t;Interrupt stacking fix.&n; *&t;Richard Kooijman&t;:&t;Timestamp fixes.&n; *&t;&t;Alan Cox&t;:&t;Changed buffer format.&n; *&t;&t;Alan Cox&t;:&t;destructor hook for AF_UNIX etc.&n; *&t;&t;Linus Torvalds&t;:&t;Better skb_clone.&n; *&t;&t;Alan Cox&t;:&t;Added skb_copy.&n; *&t;&t;Alan Cox&t;:&t;Added all the changed routines Linus&n; *&t;&t;&t;&t;&t;only put in the headers&n; *&t;&t;Ray VanTassle&t;:&t;Fixed --skb-&gt;lock in free&n; *&t;&t;Alan Cox&t;:&t;skb_copy copy arp field&n; *&t;&t;Andi Kleen&t;:&t;slabified it.&n; *&t;&t;Robert Olsson&t;:&t;Removed skb_head_pool&n; *&n; *&t;NOTE:&n; *&t;&t;The __skb_ routines should be called with interrupts&n; *&t;disabled, or you better be *real* sure that the operation is atomic&n; *&t;with respect to whatever list is being frobbed (e.g. via lock_sock()&n; *&t;or via disabling bottom half handlers, etc).&n; *&n; *&t;This program is free software; you can redistribute it and/or&n; *&t;modify it under the terms of the GNU General Public License&n; *&t;as published by the Free Software Foundation; either version&n; *&t;2 of the License, or (at your option) any later version.&n; */
multiline_comment|/*&n; *&t;The functions in this file will not compile correctly with gcc 2.4.x&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/in.h&gt;
macro_line|#include &lt;linux/inet.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;linux/cache.h&gt;
macro_line|#include &lt;linux/rtnetlink.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/highmem.h&gt;
macro_line|#include &lt;net/protocol.h&gt;
macro_line|#include &lt;net/dst.h&gt;
macro_line|#include &lt;net/sock.h&gt;
macro_line|#include &lt;net/checksum.h&gt;
macro_line|#include &lt;net/xfrm.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/system.h&gt;
DECL|variable|skbuff_head_cache
r_static
id|kmem_cache_t
op_star
id|skbuff_head_cache
suffix:semicolon
multiline_comment|/*&n; *&t;Keep out-of-line to prevent kernel bloat.&n; *&t;__builtin_return_address is not used because it is not always&n; *&t;reliable.&n; */
multiline_comment|/**&n; *&t;skb_over_panic&t;- &t;private function&n; *&t;@skb: buffer&n; *&t;@sz: size&n; *&t;@here: address&n; *&n; *&t;Out of line support code for skb_put(). Not user callable.&n; */
DECL|function|skb_over_panic
r_void
id|skb_over_panic
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|sz
comma
r_void
op_star
id|here
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;skput:over: %p:%d put:%d dev:%s&quot;
comma
id|here
comma
id|skb-&gt;len
comma
id|sz
comma
id|skb-&gt;dev
ques
c_cond
id|skb-&gt;dev-&gt;name
suffix:colon
l_string|&quot;&lt;NULL&gt;&quot;
)paren
suffix:semicolon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;skb_under_panic&t;- &t;private function&n; *&t;@skb: buffer&n; *&t;@sz: size&n; *&t;@here: address&n; *&n; *&t;Out of line support code for skb_push(). Not user callable.&n; */
DECL|function|skb_under_panic
r_void
id|skb_under_panic
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|sz
comma
r_void
op_star
id|here
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;skput:under: %p:%d put:%d dev:%s&quot;
comma
id|here
comma
id|skb-&gt;len
comma
id|sz
comma
id|skb-&gt;dev
ques
c_cond
id|skb-&gt;dev-&gt;name
suffix:colon
l_string|&quot;&lt;NULL&gt;&quot;
)paren
suffix:semicolon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* &t;Allocate a new skbuff. We do this ourselves so we can fill in a few&n; *&t;&squot;private&squot; fields and also do memory statistics to find all the&n; *&t;[BEEP] leaks.&n; *&n; */
multiline_comment|/**&n; *&t;alloc_skb&t;-&t;allocate a network buffer&n; *&t;@size: size to allocate&n; *&t;@gfp_mask: allocation mask&n; *&n; *&t;Allocate a new &amp;sk_buff. The returned buffer has no headroom and a&n; *&t;tail room of size bytes. The object has a reference count of one.&n; *&t;The return is the buffer. On a failure the return is %NULL.&n; *&n; *&t;Buffers may only be allocated from interrupts using a @gfp_mask of&n; *&t;%GFP_ATOMIC.&n; */
DECL|function|alloc_skb
r_struct
id|sk_buff
op_star
id|alloc_skb
c_func
(paren
r_int
r_int
id|size
comma
r_int
id|gfp_mask
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
id|u8
op_star
id|data
suffix:semicolon
multiline_comment|/* Get the HEAD */
id|skb
op_assign
id|kmem_cache_alloc
c_func
(paren
id|skbuff_head_cache
comma
id|gfp_mask
op_amp
op_complement
id|__GFP_DMA
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skb
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* Get the DATA. Size must match skb_add_mtu(). */
id|size
op_assign
id|SKB_DATA_ALIGN
c_func
(paren
id|size
)paren
suffix:semicolon
id|data
op_assign
id|kmalloc
c_func
(paren
id|size
op_plus
r_sizeof
(paren
r_struct
id|skb_shared_info
)paren
comma
id|gfp_mask
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|data
)paren
r_goto
id|nodata
suffix:semicolon
id|memset
c_func
(paren
id|skb
comma
l_int|0
comma
m_offsetof
(paren
r_struct
id|sk_buff
comma
id|truesize
)paren
)paren
suffix:semicolon
id|skb-&gt;truesize
op_assign
id|size
op_plus
r_sizeof
(paren
r_struct
id|sk_buff
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|skb-&gt;users
comma
l_int|1
)paren
suffix:semicolon
id|skb-&gt;head
op_assign
id|data
suffix:semicolon
id|skb-&gt;data
op_assign
id|data
suffix:semicolon
id|skb-&gt;tail
op_assign
id|data
suffix:semicolon
id|skb-&gt;end
op_assign
id|data
op_plus
id|size
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
(paren
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|dataref
)paren
comma
l_int|1
)paren
suffix:semicolon
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|nr_frags
op_assign
l_int|0
suffix:semicolon
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|tso_size
op_assign
l_int|0
suffix:semicolon
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|tso_segs
op_assign
l_int|0
suffix:semicolon
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|frag_list
op_assign
l_int|NULL
suffix:semicolon
id|out
suffix:colon
r_return
id|skb
suffix:semicolon
id|nodata
suffix:colon
id|kmem_cache_free
c_func
(paren
id|skbuff_head_cache
comma
id|skb
)paren
suffix:semicolon
id|skb
op_assign
l_int|NULL
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
DECL|function|skb_drop_fraglist
r_static
r_void
id|skb_drop_fraglist
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|sk_buff
op_star
id|list
op_assign
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|frag_list
suffix:semicolon
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|frag_list
op_assign
l_int|NULL
suffix:semicolon
r_do
(brace
r_struct
id|sk_buff
op_star
id|this
op_assign
id|list
suffix:semicolon
id|list
op_assign
id|list-&gt;next
suffix:semicolon
id|kfree_skb
c_func
(paren
id|this
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|list
)paren
suffix:semicolon
)brace
DECL|function|skb_clone_fraglist
r_static
r_void
id|skb_clone_fraglist
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|sk_buff
op_star
id|list
suffix:semicolon
r_for
c_loop
(paren
id|list
op_assign
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|frag_list
suffix:semicolon
id|list
suffix:semicolon
id|list
op_assign
id|list-&gt;next
)paren
id|skb_get
c_func
(paren
id|list
)paren
suffix:semicolon
)brace
DECL|function|skb_release_data
r_static
r_void
id|skb_release_data
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|skb-&gt;cloned
op_logical_or
id|atomic_dec_and_test
c_func
(paren
op_amp
(paren
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|dataref
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|nr_frags
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|nr_frags
suffix:semicolon
id|i
op_increment
)paren
id|put_page
c_func
(paren
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|frags
(braket
id|i
)braket
dot
id|page
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|frag_list
)paren
id|skb_drop_fraglist
c_func
(paren
id|skb
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|skb-&gt;head
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *&t;Free an skbuff by memory without cleaning the state.&n; */
DECL|function|kfree_skbmem
r_void
id|kfree_skbmem
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
id|skb_release_data
c_func
(paren
id|skb
)paren
suffix:semicolon
id|kmem_cache_free
c_func
(paren
id|skbuff_head_cache
comma
id|skb
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;__kfree_skb - private function&n; *&t;@skb: buffer&n; *&n; *&t;Free an sk_buff. Release anything attached to the buffer.&n; *&t;Clean the state. This is an internal helper function. Users should&n; *&t;always call kfree_skb&n; */
DECL|function|__kfree_skb
r_void
id|__kfree_skb
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_if
c_cond
(paren
id|skb-&gt;list
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Warning: kfree_skb passed an skb still &quot;
l_string|&quot;on a list (from %p).&bslash;n&quot;
comma
id|NET_CALLER
c_func
(paren
id|skb
)paren
)paren
suffix:semicolon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
id|dst_release
c_func
(paren
id|skb-&gt;dst
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_INET
id|secpath_put
c_func
(paren
id|skb-&gt;sp
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|skb-&gt;destructor
)paren
(brace
r_if
c_cond
(paren
id|in_irq
c_func
(paren
)paren
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Warning: kfree_skb on &quot;
l_string|&quot;hard IRQ %p&bslash;n&quot;
comma
id|NET_CALLER
c_func
(paren
id|skb
)paren
)paren
suffix:semicolon
id|skb
op_member_access_from_pointer
id|destructor
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_NETFILTER
id|nf_conntrack_put
c_func
(paren
id|skb-&gt;nfct
)paren
suffix:semicolon
macro_line|#if defined(CONFIG_BRIDGE) || defined(CONFIG_BRIDGE_MODULE)
id|nf_bridge_put
c_func
(paren
id|skb-&gt;nf_bridge
)paren
suffix:semicolon
macro_line|#endif
macro_line|#endif
id|kfree_skbmem
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;skb_clone&t;-&t;duplicate an sk_buff&n; *&t;@skb: buffer to clone&n; *&t;@gfp_mask: allocation priority&n; *&n; *&t;Duplicate an &amp;sk_buff. The new one is not owned by a socket. Both&n; *&t;copies share the same packet data but not structure. The new&n; *&t;buffer has a reference count of 1. If the allocation fails the&n; *&t;function returns %NULL otherwise the new buffer is returned.&n; *&n; *&t;If this function is called from an interrupt gfp_mask() must be&n; *&t;%GFP_ATOMIC.&n; */
DECL|function|skb_clone
r_struct
id|sk_buff
op_star
id|skb_clone
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|gfp_mask
)paren
(brace
r_struct
id|sk_buff
op_star
id|n
op_assign
id|kmem_cache_alloc
c_func
(paren
id|skbuff_head_cache
comma
id|gfp_mask
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|n
)paren
r_return
l_int|NULL
suffix:semicolon
DECL|macro|C
mdefine_line|#define C(x) n-&gt;x = skb-&gt;x
id|n-&gt;next
op_assign
id|n-&gt;prev
op_assign
l_int|NULL
suffix:semicolon
id|n-&gt;list
op_assign
l_int|NULL
suffix:semicolon
id|n-&gt;sk
op_assign
l_int|NULL
suffix:semicolon
id|C
c_func
(paren
id|stamp
)paren
suffix:semicolon
id|C
c_func
(paren
id|dev
)paren
suffix:semicolon
id|C
c_func
(paren
id|real_dev
)paren
suffix:semicolon
id|C
c_func
(paren
id|h
)paren
suffix:semicolon
id|C
c_func
(paren
id|nh
)paren
suffix:semicolon
id|C
c_func
(paren
id|mac
)paren
suffix:semicolon
id|C
c_func
(paren
id|dst
)paren
suffix:semicolon
id|dst_clone
c_func
(paren
id|skb-&gt;dst
)paren
suffix:semicolon
id|C
c_func
(paren
id|sp
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_INET
id|secpath_get
c_func
(paren
id|skb-&gt;sp
)paren
suffix:semicolon
macro_line|#endif
id|memcpy
c_func
(paren
id|n-&gt;cb
comma
id|skb-&gt;cb
comma
r_sizeof
(paren
id|skb-&gt;cb
)paren
)paren
suffix:semicolon
id|C
c_func
(paren
id|len
)paren
suffix:semicolon
id|C
c_func
(paren
id|data_len
)paren
suffix:semicolon
id|C
c_func
(paren
id|csum
)paren
suffix:semicolon
id|C
c_func
(paren
id|local_df
)paren
suffix:semicolon
id|n-&gt;cloned
op_assign
l_int|1
suffix:semicolon
id|C
c_func
(paren
id|pkt_type
)paren
suffix:semicolon
id|C
c_func
(paren
id|ip_summed
)paren
suffix:semicolon
id|C
c_func
(paren
id|priority
)paren
suffix:semicolon
id|C
c_func
(paren
id|protocol
)paren
suffix:semicolon
id|C
c_func
(paren
id|security
)paren
suffix:semicolon
id|n-&gt;destructor
op_assign
l_int|NULL
suffix:semicolon
macro_line|#ifdef CONFIG_NETFILTER
id|C
c_func
(paren
id|nfmark
)paren
suffix:semicolon
id|C
c_func
(paren
id|nfcache
)paren
suffix:semicolon
id|C
c_func
(paren
id|nfct
)paren
suffix:semicolon
id|nf_conntrack_get
c_func
(paren
id|skb-&gt;nfct
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_NETFILTER_DEBUG
id|C
c_func
(paren
id|nf_debug
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if defined(CONFIG_BRIDGE) || defined(CONFIG_BRIDGE_MODULE)
id|C
c_func
(paren
id|nf_bridge
)paren
suffix:semicolon
id|nf_bridge_get
c_func
(paren
id|skb-&gt;nf_bridge
)paren
suffix:semicolon
macro_line|#endif
macro_line|#endif /*CONFIG_NETFILTER*/
macro_line|#if defined(CONFIG_HIPPI)
id|C
c_func
(paren
r_private
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_NET_SCHED
id|C
c_func
(paren
id|tc_index
)paren
suffix:semicolon
macro_line|#endif
id|C
c_func
(paren
id|truesize
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|n-&gt;users
comma
l_int|1
)paren
suffix:semicolon
id|C
c_func
(paren
id|head
)paren
suffix:semicolon
id|C
c_func
(paren
id|data
)paren
suffix:semicolon
id|C
c_func
(paren
id|tail
)paren
suffix:semicolon
id|C
c_func
(paren
id|end
)paren
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
(paren
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|dataref
)paren
)paren
suffix:semicolon
id|skb-&gt;cloned
op_assign
l_int|1
suffix:semicolon
r_return
id|n
suffix:semicolon
)brace
DECL|function|copy_skb_header
r_static
r_void
id|copy_skb_header
c_func
(paren
r_struct
id|sk_buff
op_star
r_new
comma
r_const
r_struct
id|sk_buff
op_star
id|old
)paren
(brace
multiline_comment|/*&n;&t; *&t;Shift between the two data areas in bytes&n;&t; */
r_int
r_int
id|offset
op_assign
r_new
op_member_access_from_pointer
id|data
op_minus
id|old-&gt;data
suffix:semicolon
r_new
op_member_access_from_pointer
id|list
op_assign
l_int|NULL
suffix:semicolon
r_new
op_member_access_from_pointer
id|sk
op_assign
l_int|NULL
suffix:semicolon
r_new
op_member_access_from_pointer
id|dev
op_assign
id|old-&gt;dev
suffix:semicolon
r_new
op_member_access_from_pointer
id|real_dev
op_assign
id|old-&gt;real_dev
suffix:semicolon
r_new
op_member_access_from_pointer
id|priority
op_assign
id|old-&gt;priority
suffix:semicolon
r_new
op_member_access_from_pointer
id|protocol
op_assign
id|old-&gt;protocol
suffix:semicolon
r_new
op_member_access_from_pointer
id|dst
op_assign
id|dst_clone
c_func
(paren
id|old-&gt;dst
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_INET
r_new
op_member_access_from_pointer
id|sp
op_assign
id|secpath_get
c_func
(paren
id|old-&gt;sp
)paren
suffix:semicolon
macro_line|#endif
r_new
op_member_access_from_pointer
id|h.raw
op_assign
id|old-&gt;h.raw
op_plus
id|offset
suffix:semicolon
r_new
op_member_access_from_pointer
id|nh.raw
op_assign
id|old-&gt;nh.raw
op_plus
id|offset
suffix:semicolon
r_new
op_member_access_from_pointer
id|mac.raw
op_assign
id|old-&gt;mac.raw
op_plus
id|offset
suffix:semicolon
id|memcpy
c_func
(paren
r_new
op_member_access_from_pointer
id|cb
comma
id|old-&gt;cb
comma
r_sizeof
(paren
id|old-&gt;cb
)paren
)paren
suffix:semicolon
r_new
op_member_access_from_pointer
id|local_df
op_assign
id|old-&gt;local_df
suffix:semicolon
r_new
op_member_access_from_pointer
id|pkt_type
op_assign
id|old-&gt;pkt_type
suffix:semicolon
r_new
op_member_access_from_pointer
id|stamp
op_assign
id|old-&gt;stamp
suffix:semicolon
r_new
op_member_access_from_pointer
id|destructor
op_assign
l_int|NULL
suffix:semicolon
r_new
op_member_access_from_pointer
id|security
op_assign
id|old-&gt;security
suffix:semicolon
macro_line|#ifdef CONFIG_NETFILTER
r_new
op_member_access_from_pointer
id|nfmark
op_assign
id|old-&gt;nfmark
suffix:semicolon
r_new
op_member_access_from_pointer
id|nfcache
op_assign
id|old-&gt;nfcache
suffix:semicolon
r_new
op_member_access_from_pointer
id|nfct
op_assign
id|old-&gt;nfct
suffix:semicolon
id|nf_conntrack_get
c_func
(paren
id|old-&gt;nfct
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_NETFILTER_DEBUG
r_new
op_member_access_from_pointer
id|nf_debug
op_assign
id|old-&gt;nf_debug
suffix:semicolon
macro_line|#endif
macro_line|#if defined(CONFIG_BRIDGE) || defined(CONFIG_BRIDGE_MODULE)
r_new
op_member_access_from_pointer
id|nf_bridge
op_assign
id|old-&gt;nf_bridge
suffix:semicolon
id|nf_bridge_get
c_func
(paren
id|old-&gt;nf_bridge
)paren
suffix:semicolon
macro_line|#endif
macro_line|#endif
macro_line|#ifdef CONFIG_NET_SCHED
r_new
op_member_access_from_pointer
id|tc_index
op_assign
id|old-&gt;tc_index
suffix:semicolon
macro_line|#endif
id|atomic_set
c_func
(paren
op_amp
r_new
op_member_access_from_pointer
id|users
comma
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;skb_copy&t;-&t;create private copy of an sk_buff&n; *&t;@skb: buffer to copy&n; *&t;@gfp_mask: allocation priority&n; *&n; *&t;Make a copy of both an &amp;sk_buff and its data. This is used when the&n; *&t;caller wishes to modify the data and needs a private copy of the&n; *&t;data to alter. Returns %NULL on failure or the pointer to the buffer&n; *&t;on success. The returned buffer has a reference count of 1.&n; *&n; *&t;As by-product this function converts non-linear &amp;sk_buff to linear&n; *&t;one, so that &amp;sk_buff becomes completely private and caller is allowed&n; *&t;to modify all the data of returned buffer. This means that this&n; *&t;function is not recommended for use in circumstances when only&n; *&t;header is going to be modified. Use pskb_copy() instead.&n; */
DECL|function|skb_copy
r_struct
id|sk_buff
op_star
id|skb_copy
c_func
(paren
r_const
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|gfp_mask
)paren
(brace
r_int
id|headerlen
op_assign
id|skb-&gt;data
op_minus
id|skb-&gt;head
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Allocate the copy buffer&n;&t; */
r_struct
id|sk_buff
op_star
id|n
op_assign
id|alloc_skb
c_func
(paren
id|skb-&gt;end
op_minus
id|skb-&gt;head
op_plus
id|skb-&gt;data_len
comma
id|gfp_mask
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|n
)paren
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/* Set the data pointer */
id|skb_reserve
c_func
(paren
id|n
comma
id|headerlen
)paren
suffix:semicolon
multiline_comment|/* Set the tail pointer and length */
id|skb_put
c_func
(paren
id|n
comma
id|skb-&gt;len
)paren
suffix:semicolon
id|n-&gt;csum
op_assign
id|skb-&gt;csum
suffix:semicolon
id|n-&gt;ip_summed
op_assign
id|skb-&gt;ip_summed
suffix:semicolon
r_if
c_cond
(paren
id|skb_copy_bits
c_func
(paren
id|skb
comma
op_minus
id|headerlen
comma
id|n-&gt;head
comma
id|headerlen
op_plus
id|skb-&gt;len
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|copy_skb_header
c_func
(paren
id|n
comma
id|skb
)paren
suffix:semicolon
r_return
id|n
suffix:semicolon
)brace
multiline_comment|/* Keep head the same: replace data */
DECL|function|skb_linearize
r_int
id|skb_linearize
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|gfp_mask
)paren
(brace
r_int
r_int
id|size
suffix:semicolon
id|u8
op_star
id|data
suffix:semicolon
r_int
id|offset
suffix:semicolon
r_struct
id|skb_shared_info
op_star
id|ninfo
suffix:semicolon
r_int
id|headerlen
op_assign
id|skb-&gt;data
op_minus
id|skb-&gt;head
suffix:semicolon
r_int
id|expand
op_assign
(paren
id|skb-&gt;tail
op_plus
id|skb-&gt;data_len
)paren
op_minus
id|skb-&gt;end
suffix:semicolon
r_if
c_cond
(paren
id|skb_shared
c_func
(paren
id|skb
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|expand
op_le
l_int|0
)paren
id|expand
op_assign
l_int|0
suffix:semicolon
id|size
op_assign
id|skb-&gt;end
op_minus
id|skb-&gt;head
op_plus
id|expand
suffix:semicolon
id|size
op_assign
id|SKB_DATA_ALIGN
c_func
(paren
id|size
)paren
suffix:semicolon
id|data
op_assign
id|kmalloc
c_func
(paren
id|size
op_plus
r_sizeof
(paren
r_struct
id|skb_shared_info
)paren
comma
id|gfp_mask
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|data
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
multiline_comment|/* Copy entire thing */
r_if
c_cond
(paren
id|skb_copy_bits
c_func
(paren
id|skb
comma
op_minus
id|headerlen
comma
id|data
comma
id|headerlen
op_plus
id|skb-&gt;len
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Set up shinfo */
id|ninfo
op_assign
(paren
r_struct
id|skb_shared_info
op_star
)paren
(paren
id|data
op_plus
id|size
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|ninfo-&gt;dataref
comma
l_int|1
)paren
suffix:semicolon
id|ninfo-&gt;tso_size
op_assign
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|tso_size
suffix:semicolon
id|ninfo-&gt;tso_segs
op_assign
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|tso_segs
suffix:semicolon
id|ninfo-&gt;nr_frags
op_assign
l_int|0
suffix:semicolon
id|ninfo-&gt;frag_list
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Offset between the two in bytes */
id|offset
op_assign
id|data
op_minus
id|skb-&gt;head
suffix:semicolon
multiline_comment|/* Free old data. */
id|skb_release_data
c_func
(paren
id|skb
)paren
suffix:semicolon
id|skb-&gt;head
op_assign
id|data
suffix:semicolon
id|skb-&gt;end
op_assign
id|data
op_plus
id|size
suffix:semicolon
multiline_comment|/* Set up new pointers */
id|skb-&gt;h.raw
op_add_assign
id|offset
suffix:semicolon
id|skb-&gt;nh.raw
op_add_assign
id|offset
suffix:semicolon
id|skb-&gt;mac.raw
op_add_assign
id|offset
suffix:semicolon
id|skb-&gt;tail
op_add_assign
id|offset
suffix:semicolon
id|skb-&gt;data
op_add_assign
id|offset
suffix:semicolon
multiline_comment|/* We are no longer a clone, even if we were. */
id|skb-&gt;cloned
op_assign
l_int|0
suffix:semicolon
id|skb-&gt;tail
op_add_assign
id|skb-&gt;data_len
suffix:semicolon
id|skb-&gt;data_len
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;pskb_copy&t;-&t;create copy of an sk_buff with private head.&n; *&t;@skb: buffer to copy&n; *&t;@gfp_mask: allocation priority&n; *&n; *&t;Make a copy of both an &amp;sk_buff and part of its data, located&n; *&t;in header. Fragmented data remain shared. This is used when&n; *&t;the caller wishes to modify only header of &amp;sk_buff and needs&n; *&t;private copy of the header to alter. Returns %NULL on failure&n; *&t;or the pointer to the buffer on success.&n; *&t;The returned buffer has a reference count of 1.&n; */
DECL|function|pskb_copy
r_struct
id|sk_buff
op_star
id|pskb_copy
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|gfp_mask
)paren
(brace
multiline_comment|/*&n;&t; *&t;Allocate the copy buffer&n;&t; */
r_struct
id|sk_buff
op_star
id|n
op_assign
id|alloc_skb
c_func
(paren
id|skb-&gt;end
op_minus
id|skb-&gt;head
comma
id|gfp_mask
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|n
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* Set the data pointer */
id|skb_reserve
c_func
(paren
id|n
comma
id|skb-&gt;data
op_minus
id|skb-&gt;head
)paren
suffix:semicolon
multiline_comment|/* Set the tail pointer and length */
id|skb_put
c_func
(paren
id|n
comma
id|skb_headlen
c_func
(paren
id|skb
)paren
)paren
suffix:semicolon
multiline_comment|/* Copy the bytes */
id|memcpy
c_func
(paren
id|n-&gt;data
comma
id|skb-&gt;data
comma
id|n-&gt;len
)paren
suffix:semicolon
id|n-&gt;csum
op_assign
id|skb-&gt;csum
suffix:semicolon
id|n-&gt;ip_summed
op_assign
id|skb-&gt;ip_summed
suffix:semicolon
id|n-&gt;data_len
op_assign
id|skb-&gt;data_len
suffix:semicolon
id|n-&gt;len
op_assign
id|skb-&gt;len
suffix:semicolon
r_if
c_cond
(paren
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|nr_frags
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|nr_frags
suffix:semicolon
id|i
op_increment
)paren
(brace
id|skb_shinfo
c_func
(paren
id|n
)paren
op_member_access_from_pointer
id|frags
(braket
id|i
)braket
op_assign
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|frags
(braket
id|i
)braket
suffix:semicolon
id|get_page
c_func
(paren
id|skb_shinfo
c_func
(paren
id|n
)paren
op_member_access_from_pointer
id|frags
(braket
id|i
)braket
dot
id|page
)paren
suffix:semicolon
)brace
id|skb_shinfo
c_func
(paren
id|n
)paren
op_member_access_from_pointer
id|nr_frags
op_assign
id|i
suffix:semicolon
)brace
id|skb_shinfo
c_func
(paren
id|n
)paren
op_member_access_from_pointer
id|tso_size
op_assign
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|tso_size
suffix:semicolon
id|skb_shinfo
c_func
(paren
id|n
)paren
op_member_access_from_pointer
id|tso_segs
op_assign
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|tso_segs
suffix:semicolon
r_if
c_cond
(paren
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|frag_list
)paren
(brace
id|skb_shinfo
c_func
(paren
id|n
)paren
op_member_access_from_pointer
id|frag_list
op_assign
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|frag_list
suffix:semicolon
id|skb_clone_fraglist
c_func
(paren
id|n
)paren
suffix:semicolon
)brace
id|copy_skb_header
c_func
(paren
id|n
comma
id|skb
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|n
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;pskb_expand_head - reallocate header of &amp;sk_buff&n; *&t;@skb: buffer to reallocate&n; *&t;@nhead: room to add at head&n; *&t;@ntail: room to add at tail&n; *&t;@gfp_mask: allocation priority&n; *&n; *&t;Expands (or creates identical copy, if &amp;nhead and &amp;ntail are zero)&n; *&t;header of skb. &amp;sk_buff itself is not changed. &amp;sk_buff MUST have&n; *&t;reference count of 1. Returns zero in the case of success or error,&n; *&t;if expansion failed. In the last case, &amp;sk_buff is not changed.&n; *&n; *&t;All the pointers pointing into skb header may change and must be&n; *&t;reloaded after call to this function.&n; */
DECL|function|pskb_expand_head
r_int
id|pskb_expand_head
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|nhead
comma
r_int
id|ntail
comma
r_int
id|gfp_mask
)paren
(brace
r_int
id|i
suffix:semicolon
id|u8
op_star
id|data
suffix:semicolon
r_int
id|size
op_assign
id|nhead
op_plus
(paren
id|skb-&gt;end
op_minus
id|skb-&gt;head
)paren
op_plus
id|ntail
suffix:semicolon
r_int
id|off
suffix:semicolon
r_if
c_cond
(paren
id|skb_shared
c_func
(paren
id|skb
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|size
op_assign
id|SKB_DATA_ALIGN
c_func
(paren
id|size
)paren
suffix:semicolon
id|data
op_assign
id|kmalloc
c_func
(paren
id|size
op_plus
r_sizeof
(paren
r_struct
id|skb_shared_info
)paren
comma
id|gfp_mask
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|data
)paren
r_goto
id|nodata
suffix:semicolon
multiline_comment|/* Copy only real data... and, alas, header. This should be&n;&t; * optimized for the cases when header is void. */
id|memcpy
c_func
(paren
id|data
op_plus
id|nhead
comma
id|skb-&gt;head
comma
id|skb-&gt;tail
op_minus
id|skb-&gt;head
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|data
op_plus
id|size
comma
id|skb-&gt;end
comma
r_sizeof
(paren
r_struct
id|skb_shared_info
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|nr_frags
suffix:semicolon
id|i
op_increment
)paren
id|get_page
c_func
(paren
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|frags
(braket
id|i
)braket
dot
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|frag_list
)paren
id|skb_clone_fraglist
c_func
(paren
id|skb
)paren
suffix:semicolon
id|skb_release_data
c_func
(paren
id|skb
)paren
suffix:semicolon
id|off
op_assign
(paren
id|data
op_plus
id|nhead
)paren
op_minus
id|skb-&gt;head
suffix:semicolon
id|skb-&gt;head
op_assign
id|data
suffix:semicolon
id|skb-&gt;end
op_assign
id|data
op_plus
id|size
suffix:semicolon
id|skb-&gt;data
op_add_assign
id|off
suffix:semicolon
id|skb-&gt;tail
op_add_assign
id|off
suffix:semicolon
id|skb-&gt;mac.raw
op_add_assign
id|off
suffix:semicolon
id|skb-&gt;h.raw
op_add_assign
id|off
suffix:semicolon
id|skb-&gt;nh.raw
op_add_assign
id|off
suffix:semicolon
id|skb-&gt;cloned
op_assign
l_int|0
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|dataref
comma
l_int|1
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|nodata
suffix:colon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
multiline_comment|/* Make private copy of skb with writable head and some headroom */
DECL|function|skb_realloc_headroom
r_struct
id|sk_buff
op_star
id|skb_realloc_headroom
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
r_int
id|headroom
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb2
suffix:semicolon
r_int
id|delta
op_assign
id|headroom
op_minus
id|skb_headroom
c_func
(paren
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|delta
op_le
l_int|0
)paren
id|skb2
op_assign
id|pskb_copy
c_func
(paren
id|skb
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_else
(brace
id|skb2
op_assign
id|skb_clone
c_func
(paren
id|skb
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb2
op_logical_and
id|pskb_expand_head
c_func
(paren
id|skb2
comma
id|SKB_DATA_ALIGN
c_func
(paren
id|delta
)paren
comma
l_int|0
comma
id|GFP_ATOMIC
)paren
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb2
)paren
suffix:semicolon
id|skb2
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
r_return
id|skb2
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;skb_copy_expand&t;-&t;copy and expand sk_buff&n; *&t;@skb: buffer to copy&n; *&t;@newheadroom: new free bytes at head&n; *&t;@newtailroom: new free bytes at tail&n; *&t;@gfp_mask: allocation priority&n; *&n; *&t;Make a copy of both an &amp;sk_buff and its data and while doing so&n; *&t;allocate additional space.&n; *&n; *&t;This is used when the caller wishes to modify the data and needs a&n; *&t;private copy of the data to alter as well as more space for new fields.&n; *&t;Returns %NULL on failure or the pointer to the buffer&n; *&t;on success. The returned buffer has a reference count of 1.&n; *&n; *&t;You must pass %GFP_ATOMIC as the allocation priority if this function&n; *&t;is called from an interrupt.&n; *&n; *&t;BUG ALERT: ip_summed is not copied. Why does this work? Is it used&n; *&t;only by netfilter in the cases when checksum is recalculated? --ANK&n; */
DECL|function|skb_copy_expand
r_struct
id|sk_buff
op_star
id|skb_copy_expand
c_func
(paren
r_const
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|newheadroom
comma
r_int
id|newtailroom
comma
r_int
id|gfp_mask
)paren
(brace
multiline_comment|/*&n;&t; *&t;Allocate the copy buffer&n;&t; */
r_struct
id|sk_buff
op_star
id|n
op_assign
id|alloc_skb
c_func
(paren
id|newheadroom
op_plus
id|skb-&gt;len
op_plus
id|newtailroom
comma
id|gfp_mask
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|n
)paren
r_return
l_int|NULL
suffix:semicolon
id|skb_reserve
c_func
(paren
id|n
comma
id|newheadroom
)paren
suffix:semicolon
multiline_comment|/* Set the tail pointer and length */
id|skb_put
c_func
(paren
id|n
comma
id|skb-&gt;len
)paren
suffix:semicolon
multiline_comment|/* Copy the data only. */
r_if
c_cond
(paren
id|skb_copy_bits
c_func
(paren
id|skb
comma
l_int|0
comma
id|n-&gt;data
comma
id|skb-&gt;len
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|copy_skb_header
c_func
(paren
id|n
comma
id|skb
)paren
suffix:semicolon
id|skb_shinfo
c_func
(paren
id|n
)paren
op_member_access_from_pointer
id|tso_size
op_assign
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|tso_size
suffix:semicolon
id|skb_shinfo
c_func
(paren
id|n
)paren
op_member_access_from_pointer
id|tso_segs
op_assign
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|tso_segs
suffix:semicolon
r_return
id|n
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;skb_pad&t;&t;&t;-&t;zero pad the tail of an skb&n; *&t;@skb: buffer to pad&n; *&t;@pad: space to pad&n; *&n; *&t;Ensure that a buffer is followed by a padding area that is zero&n; *&t;filled. Used by network drivers which may DMA or transfer data&n; *&t;beyond the buffer end onto the wire.&n; *&n; *&t;May return NULL in out of memory cases.&n; */
DECL|function|skb_pad
r_struct
id|sk_buff
op_star
id|skb_pad
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|pad
)paren
(brace
r_struct
id|sk_buff
op_star
id|nskb
suffix:semicolon
multiline_comment|/* If the skbuff is non linear tailroom is always zero.. */
r_if
c_cond
(paren
id|skb_tailroom
c_func
(paren
id|skb
)paren
op_ge
id|pad
)paren
(brace
id|memset
c_func
(paren
id|skb-&gt;data
op_plus
id|skb-&gt;len
comma
l_int|0
comma
id|pad
)paren
suffix:semicolon
r_return
id|skb
suffix:semicolon
)brace
id|nskb
op_assign
id|skb_copy_expand
c_func
(paren
id|skb
comma
id|skb_headroom
c_func
(paren
id|skb
)paren
comma
id|skb_tailroom
c_func
(paren
id|skb
)paren
op_plus
id|pad
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nskb
)paren
id|memset
c_func
(paren
id|nskb-&gt;data
op_plus
id|nskb-&gt;len
comma
l_int|0
comma
id|pad
)paren
suffix:semicolon
r_return
id|nskb
suffix:semicolon
)brace
multiline_comment|/* Trims skb to length len. It can change skb pointers, if &quot;realloc&quot; is 1.&n; * If realloc==0 and trimming is impossible without change of data,&n; * it is BUG().&n; */
DECL|function|___pskb_trim
r_int
id|___pskb_trim
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
r_int
id|len
comma
r_int
id|realloc
)paren
(brace
r_int
id|offset
op_assign
id|skb_headlen
c_func
(paren
id|skb
)paren
suffix:semicolon
r_int
id|nfrags
op_assign
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|nr_frags
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nfrags
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|end
op_assign
id|offset
op_plus
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|frags
(braket
id|i
)braket
dot
id|size
suffix:semicolon
r_if
c_cond
(paren
id|end
OG
id|len
)paren
(brace
r_if
c_cond
(paren
id|skb_cloned
c_func
(paren
id|skb
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|realloc
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pskb_expand_head
c_func
(paren
id|skb
comma
l_int|0
comma
l_int|0
comma
id|GFP_ATOMIC
)paren
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_if
c_cond
(paren
id|len
op_le
id|offset
)paren
(brace
id|put_page
c_func
(paren
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|frags
(braket
id|i
)braket
dot
id|page
)paren
suffix:semicolon
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|nr_frags
op_decrement
suffix:semicolon
)brace
r_else
(brace
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|frags
(braket
id|i
)braket
dot
id|size
op_assign
id|len
op_minus
id|offset
suffix:semicolon
)brace
)brace
id|offset
op_assign
id|end
suffix:semicolon
)brace
r_if
c_cond
(paren
id|offset
OL
id|len
)paren
(brace
id|skb-&gt;data_len
op_sub_assign
id|skb-&gt;len
op_minus
id|len
suffix:semicolon
id|skb-&gt;len
op_assign
id|len
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|len
op_le
id|skb_headlen
c_func
(paren
id|skb
)paren
)paren
(brace
id|skb-&gt;len
op_assign
id|len
suffix:semicolon
id|skb-&gt;data_len
op_assign
l_int|0
suffix:semicolon
id|skb-&gt;tail
op_assign
id|skb-&gt;data
op_plus
id|len
suffix:semicolon
r_if
c_cond
(paren
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|frag_list
op_logical_and
op_logical_neg
id|skb_cloned
c_func
(paren
id|skb
)paren
)paren
id|skb_drop_fraglist
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
r_else
(brace
id|skb-&gt;data_len
op_sub_assign
id|skb-&gt;len
op_minus
id|len
suffix:semicolon
id|skb-&gt;len
op_assign
id|len
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;__pskb_pull_tail - advance tail of skb header&n; *&t;@skb: buffer to reallocate&n; *&t;@delta: number of bytes to advance tail&n; *&n; *&t;The function makes a sense only on a fragmented &amp;sk_buff,&n; *&t;it expands header moving its tail forward and copying necessary&n; *&t;data from fragmented part.&n; *&n; *&t;&amp;sk_buff MUST have reference count of 1.&n; *&n; *&t;Returns %NULL (and &amp;sk_buff does not change) if pull failed&n; *&t;or value of new tail of skb in the case of success.&n; *&n; *&t;All the pointers pointing into skb header may change and must be&n; *&t;reloaded after call to this function.&n; */
multiline_comment|/* Moves tail of skb head forward, copying data from fragmented part,&n; * when it is necessary.&n; * 1. It may fail due to malloc failure.&n; * 2. It may change skb pointers.&n; *&n; * It is pretty complicated. Luckily, it is called only in exceptional cases.&n; */
DECL|function|__pskb_pull_tail
r_int
r_char
op_star
id|__pskb_pull_tail
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|delta
)paren
(brace
multiline_comment|/* If skb has not enough free space at tail, get new one&n;&t; * plus 128 bytes for future expansions. If we have enough&n;&t; * room at tail, reallocate without expansion only if skb is cloned.&n;&t; */
r_int
id|i
comma
id|k
comma
id|eat
op_assign
(paren
id|skb-&gt;tail
op_plus
id|delta
)paren
op_minus
id|skb-&gt;end
suffix:semicolon
r_if
c_cond
(paren
id|eat
OG
l_int|0
op_logical_or
id|skb_cloned
c_func
(paren
id|skb
)paren
)paren
(brace
r_if
c_cond
(paren
id|pskb_expand_head
c_func
(paren
id|skb
comma
l_int|0
comma
id|eat
OG
l_int|0
ques
c_cond
id|eat
op_plus
l_int|128
suffix:colon
l_int|0
comma
id|GFP_ATOMIC
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|skb_copy_bits
c_func
(paren
id|skb
comma
id|skb_headlen
c_func
(paren
id|skb
)paren
comma
id|skb-&gt;tail
comma
id|delta
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Optimization: no fragments, no reasons to preestimate&n;&t; * size of pulled pages. Superb.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|frag_list
)paren
r_goto
id|pull_pages
suffix:semicolon
multiline_comment|/* Estimate size of pulled pages. */
id|eat
op_assign
id|delta
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|nr_frags
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|frags
(braket
id|i
)braket
dot
id|size
op_ge
id|eat
)paren
r_goto
id|pull_pages
suffix:semicolon
id|eat
op_sub_assign
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|frags
(braket
id|i
)braket
dot
id|size
suffix:semicolon
)brace
multiline_comment|/* If we need update frag list, we are in troubles.&n;&t; * Certainly, it possible to add an offset to skb data,&n;&t; * but taking into account that pulling is expected to&n;&t; * be very rare operation, it is worth to fight against&n;&t; * further bloating skb head and crucify ourselves here instead.&n;&t; * Pure masohism, indeed. 8)8)&n;&t; */
r_if
c_cond
(paren
id|eat
)paren
(brace
r_struct
id|sk_buff
op_star
id|list
op_assign
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|frag_list
suffix:semicolon
r_struct
id|sk_buff
op_star
id|clone
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|sk_buff
op_star
id|insp
op_assign
l_int|NULL
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
op_logical_neg
id|list
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|list-&gt;len
op_le
id|eat
)paren
(brace
multiline_comment|/* Eaten as whole. */
id|eat
op_sub_assign
id|list-&gt;len
suffix:semicolon
id|list
op_assign
id|list-&gt;next
suffix:semicolon
id|insp
op_assign
id|list
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Eaten partially. */
r_if
c_cond
(paren
id|skb_shared
c_func
(paren
id|list
)paren
)paren
(brace
multiline_comment|/* Sucks! We need to fork list. :-( */
id|clone
op_assign
id|skb_clone
c_func
(paren
id|list
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|clone
)paren
r_return
l_int|NULL
suffix:semicolon
id|insp
op_assign
id|list-&gt;next
suffix:semicolon
id|list
op_assign
id|clone
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* This may be pulled without&n;&t;&t;&t;&t;&t; * problems. */
id|insp
op_assign
id|list
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|pskb_pull
c_func
(paren
id|list
comma
id|eat
)paren
)paren
(brace
r_if
c_cond
(paren
id|clone
)paren
id|kfree_skb
c_func
(paren
id|clone
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|eat
)paren
suffix:semicolon
multiline_comment|/* Free pulled out fragments. */
r_while
c_loop
(paren
(paren
id|list
op_assign
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|frag_list
)paren
op_ne
id|insp
)paren
(brace
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|frag_list
op_assign
id|list-&gt;next
suffix:semicolon
id|kfree_skb
c_func
(paren
id|list
)paren
suffix:semicolon
)brace
multiline_comment|/* And insert new clone at head. */
r_if
c_cond
(paren
id|clone
)paren
(brace
id|clone-&gt;next
op_assign
id|list
suffix:semicolon
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|frag_list
op_assign
id|clone
suffix:semicolon
)brace
)brace
multiline_comment|/* Success! Now we may commit changes to skb data. */
id|pull_pages
suffix:colon
id|eat
op_assign
id|delta
suffix:semicolon
id|k
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|nr_frags
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|frags
(braket
id|i
)braket
dot
id|size
op_le
id|eat
)paren
(brace
id|put_page
c_func
(paren
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|frags
(braket
id|i
)braket
dot
id|page
)paren
suffix:semicolon
id|eat
op_sub_assign
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|frags
(braket
id|i
)braket
dot
id|size
suffix:semicolon
)brace
r_else
(brace
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|frags
(braket
id|k
)braket
op_assign
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|frags
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|eat
)paren
(brace
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|frags
(braket
id|k
)braket
dot
id|page_offset
op_add_assign
id|eat
suffix:semicolon
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|frags
(braket
id|k
)braket
dot
id|size
op_sub_assign
id|eat
suffix:semicolon
id|eat
op_assign
l_int|0
suffix:semicolon
)brace
id|k
op_increment
suffix:semicolon
)brace
)brace
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|nr_frags
op_assign
id|k
suffix:semicolon
id|skb-&gt;tail
op_add_assign
id|delta
suffix:semicolon
id|skb-&gt;data_len
op_sub_assign
id|delta
suffix:semicolon
r_return
id|skb-&gt;tail
suffix:semicolon
)brace
multiline_comment|/* Copy some data bits from skb to kernel buffer. */
DECL|function|skb_copy_bits
r_int
id|skb_copy_bits
c_func
(paren
r_const
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|offset
comma
r_void
op_star
id|to
comma
r_int
id|len
)paren
(brace
r_int
id|i
comma
id|copy
suffix:semicolon
r_int
id|start
op_assign
id|skb_headlen
c_func
(paren
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|offset
OG
(paren
r_int
)paren
id|skb-&gt;len
op_minus
id|len
)paren
r_goto
id|fault
suffix:semicolon
multiline_comment|/* Copy header. */
r_if
c_cond
(paren
(paren
id|copy
op_assign
id|start
op_minus
id|offset
)paren
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|copy
OG
id|len
)paren
id|copy
op_assign
id|len
suffix:semicolon
id|memcpy
c_func
(paren
id|to
comma
id|skb-&gt;data
op_plus
id|offset
comma
id|copy
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|len
op_sub_assign
id|copy
)paren
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
id|offset
op_add_assign
id|copy
suffix:semicolon
id|to
op_add_assign
id|copy
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|nr_frags
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|end
suffix:semicolon
id|BUG_TRAP
c_func
(paren
id|start
op_le
id|offset
op_plus
id|len
)paren
suffix:semicolon
id|end
op_assign
id|start
op_plus
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|frags
(braket
id|i
)braket
dot
id|size
suffix:semicolon
r_if
c_cond
(paren
(paren
id|copy
op_assign
id|end
op_minus
id|offset
)paren
OG
l_int|0
)paren
(brace
id|u8
op_star
id|vaddr
suffix:semicolon
r_if
c_cond
(paren
id|copy
OG
id|len
)paren
id|copy
op_assign
id|len
suffix:semicolon
id|vaddr
op_assign
id|kmap_skb_frag
c_func
(paren
op_amp
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|frags
(braket
id|i
)braket
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|to
comma
id|vaddr
op_plus
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|frags
(braket
id|i
)braket
dot
id|page_offset
op_plus
id|offset
op_minus
id|start
comma
id|copy
)paren
suffix:semicolon
id|kunmap_skb_frag
c_func
(paren
id|vaddr
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|len
op_sub_assign
id|copy
)paren
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
id|offset
op_add_assign
id|copy
suffix:semicolon
id|to
op_add_assign
id|copy
suffix:semicolon
)brace
id|start
op_assign
id|end
suffix:semicolon
)brace
r_if
c_cond
(paren
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|frag_list
)paren
(brace
r_struct
id|sk_buff
op_star
id|list
op_assign
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|frag_list
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|list
suffix:semicolon
id|list
op_assign
id|list-&gt;next
)paren
(brace
r_int
id|end
suffix:semicolon
id|BUG_TRAP
c_func
(paren
id|start
op_le
id|offset
op_plus
id|len
)paren
suffix:semicolon
id|end
op_assign
id|start
op_plus
id|list-&gt;len
suffix:semicolon
r_if
c_cond
(paren
(paren
id|copy
op_assign
id|end
op_minus
id|offset
)paren
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|copy
OG
id|len
)paren
id|copy
op_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
id|skb_copy_bits
c_func
(paren
id|list
comma
id|offset
op_minus
id|start
comma
id|to
comma
id|copy
)paren
)paren
r_goto
id|fault
suffix:semicolon
r_if
c_cond
(paren
(paren
id|len
op_sub_assign
id|copy
)paren
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
id|offset
op_add_assign
id|copy
suffix:semicolon
id|to
op_add_assign
id|copy
suffix:semicolon
)brace
id|start
op_assign
id|end
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|len
)paren
r_return
l_int|0
suffix:semicolon
id|fault
suffix:colon
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
multiline_comment|/* Checksum skb data. */
DECL|function|skb_checksum
r_int
r_int
id|skb_checksum
c_func
(paren
r_const
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|offset
comma
r_int
id|len
comma
r_int
r_int
id|csum
)paren
(brace
r_int
id|start
op_assign
id|skb_headlen
c_func
(paren
id|skb
)paren
suffix:semicolon
r_int
id|i
comma
id|copy
op_assign
id|start
op_minus
id|offset
suffix:semicolon
r_int
id|pos
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Checksum header. */
r_if
c_cond
(paren
id|copy
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|copy
OG
id|len
)paren
id|copy
op_assign
id|len
suffix:semicolon
id|csum
op_assign
id|csum_partial
c_func
(paren
id|skb-&gt;data
op_plus
id|offset
comma
id|copy
comma
id|csum
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|len
op_sub_assign
id|copy
)paren
op_eq
l_int|0
)paren
r_return
id|csum
suffix:semicolon
id|offset
op_add_assign
id|copy
suffix:semicolon
id|pos
op_assign
id|copy
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|nr_frags
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|end
suffix:semicolon
id|BUG_TRAP
c_func
(paren
id|start
op_le
id|offset
op_plus
id|len
)paren
suffix:semicolon
id|end
op_assign
id|start
op_plus
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|frags
(braket
id|i
)braket
dot
id|size
suffix:semicolon
r_if
c_cond
(paren
(paren
id|copy
op_assign
id|end
op_minus
id|offset
)paren
OG
l_int|0
)paren
(brace
r_int
r_int
id|csum2
suffix:semicolon
id|u8
op_star
id|vaddr
suffix:semicolon
id|skb_frag_t
op_star
id|frag
op_assign
op_amp
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|frags
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|copy
OG
id|len
)paren
id|copy
op_assign
id|len
suffix:semicolon
id|vaddr
op_assign
id|kmap_skb_frag
c_func
(paren
id|frag
)paren
suffix:semicolon
id|csum2
op_assign
id|csum_partial
c_func
(paren
id|vaddr
op_plus
id|frag-&gt;page_offset
op_plus
id|offset
op_minus
id|start
comma
id|copy
comma
l_int|0
)paren
suffix:semicolon
id|kunmap_skb_frag
c_func
(paren
id|vaddr
)paren
suffix:semicolon
id|csum
op_assign
id|csum_block_add
c_func
(paren
id|csum
comma
id|csum2
comma
id|pos
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|len
op_sub_assign
id|copy
)paren
)paren
r_return
id|csum
suffix:semicolon
id|offset
op_add_assign
id|copy
suffix:semicolon
id|pos
op_add_assign
id|copy
suffix:semicolon
)brace
id|start
op_assign
id|end
suffix:semicolon
)brace
r_if
c_cond
(paren
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|frag_list
)paren
(brace
r_struct
id|sk_buff
op_star
id|list
op_assign
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|frag_list
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|list
suffix:semicolon
id|list
op_assign
id|list-&gt;next
)paren
(brace
r_int
id|end
suffix:semicolon
id|BUG_TRAP
c_func
(paren
id|start
op_le
id|offset
op_plus
id|len
)paren
suffix:semicolon
id|end
op_assign
id|start
op_plus
id|list-&gt;len
suffix:semicolon
r_if
c_cond
(paren
(paren
id|copy
op_assign
id|end
op_minus
id|offset
)paren
OG
l_int|0
)paren
(brace
r_int
r_int
id|csum2
suffix:semicolon
r_if
c_cond
(paren
id|copy
OG
id|len
)paren
id|copy
op_assign
id|len
suffix:semicolon
id|csum2
op_assign
id|skb_checksum
c_func
(paren
id|list
comma
id|offset
op_minus
id|start
comma
id|copy
comma
l_int|0
)paren
suffix:semicolon
id|csum
op_assign
id|csum_block_add
c_func
(paren
id|csum
comma
id|csum2
comma
id|pos
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|len
op_sub_assign
id|copy
)paren
op_eq
l_int|0
)paren
r_return
id|csum
suffix:semicolon
id|offset
op_add_assign
id|copy
suffix:semicolon
id|pos
op_add_assign
id|copy
suffix:semicolon
)brace
id|start
op_assign
id|end
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|len
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_return
id|csum
suffix:semicolon
)brace
multiline_comment|/* Both of above in one bottle. */
DECL|function|skb_copy_and_csum_bits
r_int
r_int
id|skb_copy_and_csum_bits
c_func
(paren
r_const
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|offset
comma
id|u8
op_star
id|to
comma
r_int
id|len
comma
r_int
r_int
id|csum
)paren
(brace
r_int
id|start
op_assign
id|skb_headlen
c_func
(paren
id|skb
)paren
suffix:semicolon
r_int
id|i
comma
id|copy
op_assign
id|start
op_minus
id|offset
suffix:semicolon
r_int
id|pos
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Copy header. */
r_if
c_cond
(paren
id|copy
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|copy
OG
id|len
)paren
id|copy
op_assign
id|len
suffix:semicolon
id|csum
op_assign
id|csum_partial_copy_nocheck
c_func
(paren
id|skb-&gt;data
op_plus
id|offset
comma
id|to
comma
id|copy
comma
id|csum
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|len
op_sub_assign
id|copy
)paren
op_eq
l_int|0
)paren
r_return
id|csum
suffix:semicolon
id|offset
op_add_assign
id|copy
suffix:semicolon
id|to
op_add_assign
id|copy
suffix:semicolon
id|pos
op_assign
id|copy
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|nr_frags
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|end
suffix:semicolon
id|BUG_TRAP
c_func
(paren
id|start
op_le
id|offset
op_plus
id|len
)paren
suffix:semicolon
id|end
op_assign
id|start
op_plus
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|frags
(braket
id|i
)braket
dot
id|size
suffix:semicolon
r_if
c_cond
(paren
(paren
id|copy
op_assign
id|end
op_minus
id|offset
)paren
OG
l_int|0
)paren
(brace
r_int
r_int
id|csum2
suffix:semicolon
id|u8
op_star
id|vaddr
suffix:semicolon
id|skb_frag_t
op_star
id|frag
op_assign
op_amp
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|frags
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|copy
OG
id|len
)paren
id|copy
op_assign
id|len
suffix:semicolon
id|vaddr
op_assign
id|kmap_skb_frag
c_func
(paren
id|frag
)paren
suffix:semicolon
id|csum2
op_assign
id|csum_partial_copy_nocheck
c_func
(paren
id|vaddr
op_plus
id|frag-&gt;page_offset
op_plus
id|offset
op_minus
id|start
comma
id|to
comma
id|copy
comma
l_int|0
)paren
suffix:semicolon
id|kunmap_skb_frag
c_func
(paren
id|vaddr
)paren
suffix:semicolon
id|csum
op_assign
id|csum_block_add
c_func
(paren
id|csum
comma
id|csum2
comma
id|pos
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|len
op_sub_assign
id|copy
)paren
)paren
r_return
id|csum
suffix:semicolon
id|offset
op_add_assign
id|copy
suffix:semicolon
id|to
op_add_assign
id|copy
suffix:semicolon
id|pos
op_add_assign
id|copy
suffix:semicolon
)brace
id|start
op_assign
id|end
suffix:semicolon
)brace
r_if
c_cond
(paren
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|frag_list
)paren
(brace
r_struct
id|sk_buff
op_star
id|list
op_assign
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|frag_list
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|list
suffix:semicolon
id|list
op_assign
id|list-&gt;next
)paren
(brace
r_int
r_int
id|csum2
suffix:semicolon
r_int
id|end
suffix:semicolon
id|BUG_TRAP
c_func
(paren
id|start
op_le
id|offset
op_plus
id|len
)paren
suffix:semicolon
id|end
op_assign
id|start
op_plus
id|list-&gt;len
suffix:semicolon
r_if
c_cond
(paren
(paren
id|copy
op_assign
id|end
op_minus
id|offset
)paren
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|copy
OG
id|len
)paren
id|copy
op_assign
id|len
suffix:semicolon
id|csum2
op_assign
id|skb_copy_and_csum_bits
c_func
(paren
id|list
comma
id|offset
op_minus
id|start
comma
id|to
comma
id|copy
comma
l_int|0
)paren
suffix:semicolon
id|csum
op_assign
id|csum_block_add
c_func
(paren
id|csum
comma
id|csum2
comma
id|pos
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|len
op_sub_assign
id|copy
)paren
op_eq
l_int|0
)paren
r_return
id|csum
suffix:semicolon
id|offset
op_add_assign
id|copy
suffix:semicolon
id|to
op_add_assign
id|copy
suffix:semicolon
id|pos
op_add_assign
id|copy
suffix:semicolon
)brace
id|start
op_assign
id|end
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|len
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_return
id|csum
suffix:semicolon
)brace
DECL|function|skb_copy_and_csum_dev
r_void
id|skb_copy_and_csum_dev
c_func
(paren
r_const
r_struct
id|sk_buff
op_star
id|skb
comma
id|u8
op_star
id|to
)paren
(brace
r_int
r_int
id|csum
suffix:semicolon
r_int
id|csstart
suffix:semicolon
r_if
c_cond
(paren
id|skb-&gt;ip_summed
op_eq
id|CHECKSUM_HW
)paren
id|csstart
op_assign
id|skb-&gt;h.raw
op_minus
id|skb-&gt;data
suffix:semicolon
r_else
id|csstart
op_assign
id|skb_headlen
c_func
(paren
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|csstart
OG
id|skb_headlen
c_func
(paren
id|skb
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|to
comma
id|skb-&gt;data
comma
id|csstart
)paren
suffix:semicolon
id|csum
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|csstart
op_ne
id|skb-&gt;len
)paren
id|csum
op_assign
id|skb_copy_and_csum_bits
c_func
(paren
id|skb
comma
id|csstart
comma
id|to
op_plus
id|csstart
comma
id|skb-&gt;len
op_minus
id|csstart
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb-&gt;ip_summed
op_eq
id|CHECKSUM_HW
)paren
(brace
r_int
id|csstuff
op_assign
id|csstart
op_plus
id|skb-&gt;csum
suffix:semicolon
op_star
(paren
(paren
r_int
r_int
op_star
)paren
(paren
id|to
op_plus
id|csstuff
)paren
)paren
op_assign
id|csum_fold
c_func
(paren
id|csum
)paren
suffix:semicolon
)brace
)brace
macro_line|#if 0
multiline_comment|/*&n; * &t;Tune the memory allocator for a new MTU size.&n; */
r_void
id|skb_add_mtu
c_func
(paren
r_int
id|mtu
)paren
(brace
multiline_comment|/* Must match allocation in alloc_skb */
id|mtu
op_assign
id|SKB_DATA_ALIGN
c_func
(paren
id|mtu
)paren
op_plus
r_sizeof
(paren
r_struct
id|skb_shared_info
)paren
suffix:semicolon
id|kmem_add_cache_size
c_func
(paren
id|mtu
)paren
suffix:semicolon
)brace
macro_line|#endif
DECL|function|skb_init
r_void
id|__init
id|skb_init
c_func
(paren
r_void
)paren
(brace
id|skbuff_head_cache
op_assign
id|kmem_cache_create
c_func
(paren
l_string|&quot;skbuff_head_cache&quot;
comma
r_sizeof
(paren
r_struct
id|sk_buff
)paren
comma
l_int|0
comma
id|SLAB_HWCACHE_ALIGN
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skbuff_head_cache
)paren
id|panic
c_func
(paren
l_string|&quot;cannot create skbuff cache&quot;
)paren
suffix:semicolon
)brace
eof
