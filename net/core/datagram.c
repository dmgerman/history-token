multiline_comment|/*&n; *&t;SUCS NET3:&n; *&n; *&t;Generic datagram handling routines. These are generic for all protocols. Possibly a generic IP version on top&n; *&t;of these would make sense. Not tonight however 8-).&n; *&t;This is used because UDP, RAW, PACKET, DDP, IPX, AX.25 and NetROM layer all have identical poll code and mostly&n; *&t;identical recvmsg() code. So we share it here. The poll was shared before but buried in udp.c so I moved it.&n; *&n; *&t;Authors:&t;Alan Cox &lt;alan@redhat.com&gt;. (datagram_poll() from old udp.c code)&n; *&n; *&t;Fixes:&n; *&t;&t;Alan Cox&t;:&t;NULL return from skb_peek_copy() understood&n; *&t;&t;Alan Cox&t;:&t;Rewrote skb_read_datagram to avoid the skb_peek_copy stuff.&n; *&t;&t;Alan Cox&t;:&t;Added support for SOCK_SEQPACKET. IPX can no longer use the SO_TYPE hack but&n; *&t;&t;&t;&t;&t;AX.25 now works right, and SPX is feasible.&n; *&t;&t;Alan Cox&t;:&t;Fixed write poll of non IP protocol crash.&n; *&t;&t;Florian  La Roche:&t;Changed for my new skbuff handling.&n; *&t;&t;Darryl Miles&t;:&t;Fixed non-blocking SOCK_SEQPACKET.&n; *&t;&t;Linus Torvalds&t;:&t;BSD semantic fixes.&n; *&t;&t;Alan Cox&t;:&t;Datagram iovec handling&n; *&t;&t;Darryl Miles&t;:&t;Fixed non-blocking SOCK_STREAM.&n; *&t;&t;Alan Cox&t;:&t;POSIXisms&n; *&t;&t;Pete Wyckoff    :       Unconnected accept() fix.&n; *&n; */
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/inet.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/rtnetlink.h&gt;
macro_line|#include &lt;linux/poll.h&gt;
macro_line|#include &lt;linux/highmem.h&gt;
macro_line|#include &lt;net/protocol.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;net/sock.h&gt;
macro_line|#include &lt;net/checksum.h&gt;
multiline_comment|/*&n; *&t;Is a socket &squot;connection oriented&squot; ?&n; */
DECL|function|connection_based
r_static
r_inline
r_int
id|connection_based
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_return
(paren
id|sk-&gt;type
op_eq
id|SOCK_SEQPACKET
op_logical_or
id|sk-&gt;type
op_eq
id|SOCK_STREAM
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Wait for a packet..&n; */
DECL|function|wait_for_packet
r_static
r_int
id|wait_for_packet
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
op_star
id|err
comma
r_int
op_star
id|timeo_p
)paren
(brace
r_int
id|error
suffix:semicolon
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
id|__set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
id|add_wait_queue_exclusive
c_func
(paren
id|sk-&gt;sleep
comma
op_amp
id|wait
)paren
suffix:semicolon
multiline_comment|/* Socket errors? */
id|error
op_assign
id|sock_error
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|out_err
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skb_queue_empty
c_func
(paren
op_amp
id|sk-&gt;receive_queue
)paren
)paren
r_goto
id|ready
suffix:semicolon
multiline_comment|/* Socket shut down? */
r_if
c_cond
(paren
id|sk-&gt;shutdown
op_amp
id|RCV_SHUTDOWN
)paren
r_goto
id|out_noerr
suffix:semicolon
multiline_comment|/* Sequenced packets can come disconnected. If so we report the problem */
id|error
op_assign
op_minus
id|ENOTCONN
suffix:semicolon
r_if
c_cond
(paren
id|connection_based
c_func
(paren
id|sk
)paren
op_logical_and
op_logical_neg
(paren
id|sk-&gt;state
op_eq
id|TCP_ESTABLISHED
op_logical_or
id|sk-&gt;state
op_eq
id|TCP_LISTEN
)paren
)paren
(brace
r_goto
id|out_err
suffix:semicolon
)brace
multiline_comment|/* handle signals */
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
r_goto
id|interrupted
suffix:semicolon
op_star
id|timeo_p
op_assign
id|schedule_timeout
c_func
(paren
op_star
id|timeo_p
)paren
suffix:semicolon
id|ready
suffix:colon
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
id|remove_wait_queue
c_func
(paren
id|sk-&gt;sleep
comma
op_amp
id|wait
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|interrupted
suffix:colon
id|error
op_assign
id|sock_intr_errno
c_func
(paren
op_star
id|timeo_p
)paren
suffix:semicolon
id|out_err
suffix:colon
op_star
id|err
op_assign
id|error
suffix:semicolon
id|out
suffix:colon
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
id|remove_wait_queue
c_func
(paren
id|sk-&gt;sleep
comma
op_amp
id|wait
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
id|out_noerr
suffix:colon
op_star
id|err
op_assign
l_int|0
suffix:semicolon
id|error
op_assign
l_int|1
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Get a datagram skbuff, understands the peeking, nonblocking wakeups and possible&n; *&t;races. This replaces identical code in packet,raw and udp, as well as the IPX&n; *&t;AX.25 and Appletalk. It also finally fixes the long standing peek and read&n; *&t;race for datagram sockets. If you alter this routine remember it must be&n; *&t;re-entrant.&n; *&n; *&t;This function will lock the socket if a skb is returned, so the caller&n; *&t;needs to unlock the socket in that case (usually by calling skb_free_datagram)&n; *&n; *&t;* It does not lock socket since today. This function is&n; *&t;* free of race conditions. This measure should/can improve&n; *&t;* significantly datagram socket latencies at high loads,&n; *&t;* when data copying to user space takes lots of time.&n; *&t;* (BTW I&squot;ve just killed the last cli() in IP/IPv6/core/netlink/packet&n; *&t;*  8) Great win.)&n; *&t;*&t;&t;&t;                    --ANK (980729)&n; *&n; *&t;The order of the tests when we find no data waiting are specified&n; *&t;quite explicitly by POSIX 1003.1g, don&squot;t change them without having&n; *&t;the standard around please.&n; */
DECL|function|skb_recv_datagram
r_struct
id|sk_buff
op_star
id|skb_recv_datagram
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|flags
comma
r_int
id|noblock
comma
r_int
op_star
id|err
)paren
(brace
r_int
id|error
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_int
id|timeo
suffix:semicolon
multiline_comment|/* Caller is allowed not to check sk-&gt;err before skb_recv_datagram() */
id|error
op_assign
id|sock_error
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|no_packet
suffix:semicolon
id|timeo
op_assign
id|sock_rcvtimeo
c_func
(paren
id|sk
comma
id|noblock
)paren
suffix:semicolon
r_do
(brace
multiline_comment|/* Again only user level code calls this function, so nothing interrupt level&n;&t;&t;   will suddenly eat the receive_queue.&n;&n;&t;&t;   Look at current nfs client by the way...&n;&t;&t;   However, this function was corrent in any case. 8)&n;&t;&t; */
r_if
c_cond
(paren
id|flags
op_amp
id|MSG_PEEK
)paren
(brace
r_int
r_int
id|cpu_flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|sk-&gt;receive_queue.lock
comma
id|cpu_flags
)paren
suffix:semicolon
id|skb
op_assign
id|skb_peek
c_func
(paren
op_amp
id|sk-&gt;receive_queue
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_ne
l_int|NULL
)paren
(brace
id|atomic_inc
c_func
(paren
op_amp
id|skb-&gt;users
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sk-&gt;receive_queue.lock
comma
id|cpu_flags
)paren
suffix:semicolon
)brace
r_else
id|skb
op_assign
id|skb_dequeue
c_func
(paren
op_amp
id|sk-&gt;receive_queue
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
)paren
r_return
id|skb
suffix:semicolon
multiline_comment|/* User doesn&squot;t want to wait */
id|error
op_assign
op_minus
id|EAGAIN
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|timeo
)paren
r_goto
id|no_packet
suffix:semicolon
)brace
r_while
c_loop
(paren
id|wait_for_packet
c_func
(paren
id|sk
comma
id|err
comma
op_amp
id|timeo
)paren
op_eq
l_int|0
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
id|no_packet
suffix:colon
op_star
id|err
op_assign
id|error
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|skb_free_datagram
r_void
id|skb_free_datagram
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Copy a datagram to a linear buffer.&n; */
DECL|function|skb_copy_datagram
r_int
id|skb_copy_datagram
c_func
(paren
r_const
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|offset
comma
r_char
op_star
id|to
comma
r_int
id|size
)paren
(brace
r_struct
id|iovec
id|iov
op_assign
(brace
id|to
comma
id|size
)brace
suffix:semicolon
r_return
id|skb_copy_datagram_iovec
c_func
(paren
id|skb
comma
id|offset
comma
op_amp
id|iov
comma
id|size
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Copy a datagram to an iovec.&n; *&t;Note: the iovec is modified during the copy.&n; */
DECL|function|skb_copy_datagram_iovec
r_int
id|skb_copy_datagram_iovec
c_func
(paren
r_const
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|offset
comma
r_struct
id|iovec
op_star
id|to
comma
r_int
id|len
)paren
(brace
r_int
id|i
comma
id|copy
suffix:semicolon
r_int
id|start
op_assign
id|skb-&gt;len
op_minus
id|skb-&gt;data_len
suffix:semicolon
multiline_comment|/* Copy header. */
r_if
c_cond
(paren
(paren
id|copy
op_assign
id|start
op_minus
id|offset
)paren
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|copy
OG
id|len
)paren
id|copy
op_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
id|memcpy_toiovec
c_func
(paren
id|to
comma
id|skb-&gt;data
op_plus
id|offset
comma
id|copy
)paren
)paren
r_goto
id|fault
suffix:semicolon
r_if
c_cond
(paren
(paren
id|len
op_sub_assign
id|copy
)paren
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
id|offset
op_add_assign
id|copy
suffix:semicolon
)brace
multiline_comment|/* Copy paged appendix. Hmm... why does this look so complicated? */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|nr_frags
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|end
suffix:semicolon
id|BUG_TRAP
c_func
(paren
id|start
op_le
id|offset
op_plus
id|len
)paren
suffix:semicolon
id|end
op_assign
id|start
op_plus
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|frags
(braket
id|i
)braket
dot
id|size
suffix:semicolon
r_if
c_cond
(paren
(paren
id|copy
op_assign
id|end
op_minus
id|offset
)paren
OG
l_int|0
)paren
(brace
r_int
id|err
suffix:semicolon
id|u8
op_star
id|vaddr
suffix:semicolon
id|skb_frag_t
op_star
id|frag
op_assign
op_amp
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|frags
(braket
id|i
)braket
suffix:semicolon
r_struct
id|page
op_star
id|page
op_assign
id|frag-&gt;page
suffix:semicolon
r_if
c_cond
(paren
id|copy
OG
id|len
)paren
id|copy
op_assign
id|len
suffix:semicolon
id|vaddr
op_assign
id|kmap
c_func
(paren
id|page
)paren
suffix:semicolon
id|err
op_assign
id|memcpy_toiovec
c_func
(paren
id|to
comma
id|vaddr
op_plus
id|frag-&gt;page_offset
op_plus
id|offset
op_minus
id|start
comma
id|copy
)paren
suffix:semicolon
id|kunmap
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|fault
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|len
op_sub_assign
id|copy
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|offset
op_add_assign
id|copy
suffix:semicolon
)brace
id|start
op_assign
id|end
suffix:semicolon
)brace
r_if
c_cond
(paren
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|frag_list
)paren
(brace
r_struct
id|sk_buff
op_star
id|list
suffix:semicolon
r_for
c_loop
(paren
id|list
op_assign
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|frag_list
suffix:semicolon
id|list
suffix:semicolon
id|list
op_assign
id|list-&gt;next
)paren
(brace
r_int
id|end
suffix:semicolon
id|BUG_TRAP
c_func
(paren
id|start
op_le
id|offset
op_plus
id|len
)paren
suffix:semicolon
id|end
op_assign
id|start
op_plus
id|list-&gt;len
suffix:semicolon
r_if
c_cond
(paren
(paren
id|copy
op_assign
id|end
op_minus
id|offset
)paren
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|copy
OG
id|len
)paren
id|copy
op_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
id|skb_copy_datagram_iovec
c_func
(paren
id|list
comma
id|offset
op_minus
id|start
comma
id|to
comma
id|copy
)paren
)paren
r_goto
id|fault
suffix:semicolon
r_if
c_cond
(paren
(paren
id|len
op_sub_assign
id|copy
)paren
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
id|offset
op_add_assign
id|copy
suffix:semicolon
)brace
id|start
op_assign
id|end
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|len
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
id|fault
suffix:colon
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
DECL|function|skb_copy_and_csum_datagram
r_int
id|skb_copy_and_csum_datagram
c_func
(paren
r_const
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|offset
comma
id|u8
op_star
id|to
comma
r_int
id|len
comma
r_int
r_int
op_star
id|csump
)paren
(brace
r_int
id|i
comma
id|copy
suffix:semicolon
r_int
id|start
op_assign
id|skb-&gt;len
op_minus
id|skb-&gt;data_len
suffix:semicolon
r_int
id|pos
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Copy header. */
r_if
c_cond
(paren
(paren
id|copy
op_assign
id|start
op_minus
id|offset
)paren
OG
l_int|0
)paren
(brace
r_int
id|err
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|copy
OG
id|len
)paren
id|copy
op_assign
id|len
suffix:semicolon
op_star
id|csump
op_assign
id|csum_and_copy_to_user
c_func
(paren
id|skb-&gt;data
op_plus
id|offset
comma
id|to
comma
id|copy
comma
op_star
id|csump
comma
op_amp
id|err
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|fault
suffix:semicolon
r_if
c_cond
(paren
(paren
id|len
op_sub_assign
id|copy
)paren
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
id|offset
op_add_assign
id|copy
suffix:semicolon
id|to
op_add_assign
id|copy
suffix:semicolon
id|pos
op_assign
id|copy
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|nr_frags
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|end
suffix:semicolon
id|BUG_TRAP
c_func
(paren
id|start
op_le
id|offset
op_plus
id|len
)paren
suffix:semicolon
id|end
op_assign
id|start
op_plus
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|frags
(braket
id|i
)braket
dot
id|size
suffix:semicolon
r_if
c_cond
(paren
(paren
id|copy
op_assign
id|end
op_minus
id|offset
)paren
OG
l_int|0
)paren
(brace
r_int
r_int
id|csum2
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
id|u8
op_star
id|vaddr
suffix:semicolon
id|skb_frag_t
op_star
id|frag
op_assign
op_amp
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|frags
(braket
id|i
)braket
suffix:semicolon
r_struct
id|page
op_star
id|page
op_assign
id|frag-&gt;page
suffix:semicolon
r_if
c_cond
(paren
id|copy
OG
id|len
)paren
id|copy
op_assign
id|len
suffix:semicolon
id|vaddr
op_assign
id|kmap
c_func
(paren
id|page
)paren
suffix:semicolon
id|csum2
op_assign
id|csum_and_copy_to_user
c_func
(paren
id|vaddr
op_plus
id|frag-&gt;page_offset
op_plus
id|offset
op_minus
id|start
comma
id|to
comma
id|copy
comma
l_int|0
comma
op_amp
id|err
)paren
suffix:semicolon
id|kunmap
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|fault
suffix:semicolon
op_star
id|csump
op_assign
id|csum_block_add
c_func
(paren
op_star
id|csump
comma
id|csum2
comma
id|pos
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|len
op_sub_assign
id|copy
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|offset
op_add_assign
id|copy
suffix:semicolon
id|to
op_add_assign
id|copy
suffix:semicolon
id|pos
op_add_assign
id|copy
suffix:semicolon
)brace
id|start
op_assign
id|end
suffix:semicolon
)brace
r_if
c_cond
(paren
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|frag_list
)paren
(brace
r_struct
id|sk_buff
op_star
id|list
suffix:semicolon
r_for
c_loop
(paren
id|list
op_assign
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|frag_list
suffix:semicolon
id|list
suffix:semicolon
id|list
op_assign
id|list-&gt;next
)paren
(brace
r_int
id|end
suffix:semicolon
id|BUG_TRAP
c_func
(paren
id|start
op_le
id|offset
op_plus
id|len
)paren
suffix:semicolon
id|end
op_assign
id|start
op_plus
id|list-&gt;len
suffix:semicolon
r_if
c_cond
(paren
(paren
id|copy
op_assign
id|end
op_minus
id|offset
)paren
OG
l_int|0
)paren
(brace
r_int
r_int
id|csum2
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|copy
OG
id|len
)paren
id|copy
op_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
id|skb_copy_and_csum_datagram
c_func
(paren
id|list
comma
id|offset
op_minus
id|start
comma
id|to
comma
id|copy
comma
op_amp
id|csum2
)paren
)paren
r_goto
id|fault
suffix:semicolon
op_star
id|csump
op_assign
id|csum_block_add
c_func
(paren
op_star
id|csump
comma
id|csum2
comma
id|pos
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|len
op_sub_assign
id|copy
)paren
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
id|offset
op_add_assign
id|copy
suffix:semicolon
id|to
op_add_assign
id|copy
suffix:semicolon
id|pos
op_add_assign
id|copy
suffix:semicolon
)brace
id|start
op_assign
id|end
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|len
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
id|fault
suffix:colon
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
multiline_comment|/* Copy and checkum skb to user iovec. Caller _must_ check that&n;   skb will fit to this iovec.&n;&n;   Returns: 0       - success.&n;            -EINVAL - checksum failure.&n;&t;    -EFAULT - fault during copy. Beware, in this case iovec can be&n;&t;              modified!&n; */
DECL|function|skb_copy_and_csum_datagram_iovec
r_int
id|skb_copy_and_csum_datagram_iovec
c_func
(paren
r_const
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|hlen
comma
r_struct
id|iovec
op_star
id|iov
)paren
(brace
r_int
r_int
id|csum
suffix:semicolon
r_int
id|chunk
op_assign
id|skb-&gt;len
op_minus
id|hlen
suffix:semicolon
multiline_comment|/* Skip filled elements. Pretty silly, look at memcpy_toiovec, though 8) */
r_while
c_loop
(paren
id|iov-&gt;iov_len
op_eq
l_int|0
)paren
id|iov
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|iov-&gt;iov_len
OL
id|chunk
)paren
(brace
r_if
c_cond
(paren
(paren
r_int
r_int
)paren
id|csum_fold
c_func
(paren
id|skb_checksum
c_func
(paren
id|skb
comma
l_int|0
comma
id|chunk
op_plus
id|hlen
comma
id|skb-&gt;csum
)paren
)paren
)paren
r_goto
id|csum_error
suffix:semicolon
r_if
c_cond
(paren
id|skb_copy_datagram_iovec
c_func
(paren
id|skb
comma
id|hlen
comma
id|iov
comma
id|chunk
)paren
)paren
r_goto
id|fault
suffix:semicolon
)brace
r_else
(brace
id|csum
op_assign
id|csum_partial
c_func
(paren
id|skb-&gt;data
comma
id|hlen
comma
id|skb-&gt;csum
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb_copy_and_csum_datagram
c_func
(paren
id|skb
comma
id|hlen
comma
id|iov-&gt;iov_base
comma
id|chunk
comma
op_amp
id|csum
)paren
)paren
r_goto
id|fault
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
r_int
)paren
id|csum_fold
c_func
(paren
id|csum
)paren
)paren
r_goto
id|csum_error
suffix:semicolon
id|iov-&gt;iov_len
op_sub_assign
id|chunk
suffix:semicolon
id|iov-&gt;iov_base
op_add_assign
id|chunk
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
id|csum_error
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
id|fault
suffix:colon
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Datagram poll: Again totally generic. This also handles&n; *&t;sequenced packet sockets providing the socket receive queue&n; *&t;is only ever holding data ready to receive.&n; *&n; *&t;Note: when you _don&squot;t_ use this routine for this protocol,&n; *&t;and you use a different write policy from sock_writeable()&n; *&t;then please supply your own write_space callback.&n; */
DECL|function|datagram_poll
r_int
r_int
id|datagram_poll
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_struct
id|socket
op_star
id|sock
comma
id|poll_table
op_star
id|wait
)paren
(brace
r_struct
id|sock
op_star
id|sk
op_assign
id|sock-&gt;sk
suffix:semicolon
r_int
r_int
id|mask
suffix:semicolon
id|poll_wait
c_func
(paren
id|file
comma
id|sk-&gt;sleep
comma
id|wait
)paren
suffix:semicolon
id|mask
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* exceptional events? */
r_if
c_cond
(paren
id|sk-&gt;err
op_logical_or
op_logical_neg
id|skb_queue_empty
c_func
(paren
op_amp
id|sk-&gt;error_queue
)paren
)paren
id|mask
op_or_assign
id|POLLERR
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;shutdown
op_eq
id|SHUTDOWN_MASK
)paren
id|mask
op_or_assign
id|POLLHUP
suffix:semicolon
multiline_comment|/* readable? */
r_if
c_cond
(paren
op_logical_neg
id|skb_queue_empty
c_func
(paren
op_amp
id|sk-&gt;receive_queue
)paren
op_logical_or
(paren
id|sk-&gt;shutdown
op_amp
id|RCV_SHUTDOWN
)paren
)paren
id|mask
op_or_assign
id|POLLIN
op_or
id|POLLRDNORM
suffix:semicolon
multiline_comment|/* Connection-based need to check for termination and startup */
r_if
c_cond
(paren
id|connection_based
c_func
(paren
id|sk
)paren
)paren
(brace
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|TCP_CLOSE
)paren
id|mask
op_or_assign
id|POLLHUP
suffix:semicolon
multiline_comment|/* connection hasn&squot;t started yet? */
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|TCP_SYN_SENT
)paren
r_return
id|mask
suffix:semicolon
)brace
multiline_comment|/* writable? */
r_if
c_cond
(paren
id|sock_writeable
c_func
(paren
id|sk
)paren
)paren
id|mask
op_or_assign
id|POLLOUT
op_or
id|POLLWRNORM
op_or
id|POLLWRBAND
suffix:semicolon
r_else
id|set_bit
c_func
(paren
id|SOCK_ASYNC_NOSPACE
comma
op_amp
id|sk-&gt;socket-&gt;flags
)paren
suffix:semicolon
r_return
id|mask
suffix:semicolon
)brace
eof
