macro_line|#include &lt;net/xfrm.h&gt;
macro_line|#include &lt;net/ip.h&gt;
DECL|variable|xfrm_policy_genid
r_static
id|u32
id|xfrm_policy_genid
suffix:semicolon
DECL|variable|xfrm_policy_lock
r_static
id|rwlock_t
id|xfrm_policy_lock
op_assign
id|RW_LOCK_UNLOCKED
suffix:semicolon
DECL|variable|xfrm_policy_list
r_struct
id|xfrm_policy
op_star
id|xfrm_policy_list
(braket
id|XFRM_POLICY_MAX
)braket
suffix:semicolon
r_extern
r_struct
id|dst_ops
id|xfrm4_dst_ops
suffix:semicolon
multiline_comment|/* Limited flow cache. Its function now is to accelerate search for&n; * policy rules.&n; *&n; * Flow cache is private to cpus, at the moment this is important&n; * mostly for flows which do not match any rule, so that flow lookups&n; * are absolultely cpu-local. When a rule exists we do some updates&n; * to rule (refcnt, stats), so that locality is broken. Later this&n; * can be repaired.&n; */
DECL|struct|flow_entry
r_struct
id|flow_entry
(brace
DECL|member|next
r_struct
id|flow_entry
op_star
id|next
suffix:semicolon
DECL|member|fl
r_struct
id|flowi
id|fl
suffix:semicolon
DECL|member|dir
id|u8
id|dir
suffix:semicolon
DECL|member|genid
id|u32
id|genid
suffix:semicolon
DECL|member|pol
r_struct
id|xfrm_policy
op_star
id|pol
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|flow_cachep
r_static
id|kmem_cache_t
op_star
id|flow_cachep
suffix:semicolon
DECL|variable|flow_table
r_struct
id|flow_entry
op_star
op_star
id|flow_table
suffix:semicolon
DECL|macro|FLOWCACHE_HASH_SIZE
mdefine_line|#define FLOWCACHE_HASH_SIZE&t;1024
DECL|function|flow_hash
r_static
r_inline
id|u32
id|flow_hash
c_func
(paren
r_struct
id|flowi
op_star
id|fl
)paren
(brace
id|u32
id|hash
op_assign
id|fl-&gt;fl4_src
op_xor
id|fl-&gt;uli_u.ports.sport
suffix:semicolon
id|hash
op_assign
(paren
(paren
id|hash
op_amp
l_int|0xF0F0F0F0
)paren
op_rshift
l_int|4
)paren
op_or
(paren
(paren
id|hash
op_amp
l_int|0x0F0F0F0F
)paren
op_lshift
l_int|4
)paren
suffix:semicolon
id|hash
op_xor_assign
id|fl-&gt;fl4_dst
op_xor
id|fl-&gt;uli_u.ports.dport
suffix:semicolon
id|hash
op_xor_assign
(paren
id|hash
op_rshift
l_int|10
)paren
suffix:semicolon
id|hash
op_xor_assign
(paren
id|hash
op_rshift
l_int|20
)paren
suffix:semicolon
r_return
id|hash
op_amp
(paren
id|FLOWCACHE_HASH_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
)brace
DECL|variable|flow_lwm
r_static
r_int
id|flow_lwm
op_assign
l_int|2
op_star
id|FLOWCACHE_HASH_SIZE
suffix:semicolon
DECL|variable|flow_hwm
r_static
r_int
id|flow_hwm
op_assign
l_int|4
op_star
id|FLOWCACHE_HASH_SIZE
suffix:semicolon
DECL|variable|__cacheline_aligned
r_static
r_int
id|flow_number
(braket
id|NR_CPUS
)braket
id|__cacheline_aligned
suffix:semicolon
DECL|macro|flow_count
mdefine_line|#define flow_count(cpu)&t;&t;(flow_number[cpu])
DECL|function|flow_cache_shrink
r_static
r_void
id|flow_cache_shrink
c_func
(paren
r_int
id|cpu
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|flow_entry
op_star
id|fle
comma
op_star
op_star
id|flp
suffix:semicolon
r_int
id|shrink_to
op_assign
id|flow_lwm
op_div
id|FLOWCACHE_HASH_SIZE
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|FLOWCACHE_HASH_SIZE
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|k
op_assign
l_int|0
suffix:semicolon
id|flp
op_assign
op_amp
id|flow_table
(braket
id|cpu
op_star
id|FLOWCACHE_HASH_SIZE
op_plus
id|i
)braket
suffix:semicolon
r_while
c_loop
(paren
(paren
id|fle
op_assign
op_star
id|flp
)paren
op_ne
l_int|NULL
op_logical_and
id|k
OL
id|shrink_to
)paren
(brace
id|k
op_increment
suffix:semicolon
id|flp
op_assign
op_amp
id|fle-&gt;next
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|fle
op_assign
op_star
id|flp
)paren
op_ne
l_int|NULL
)paren
(brace
op_star
id|flp
op_assign
id|fle-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|fle-&gt;pol
)paren
id|xfrm_pol_put
c_func
(paren
id|fle-&gt;pol
)paren
suffix:semicolon
id|kmem_cache_free
c_func
(paren
id|flow_cachep
comma
id|fle
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|function|flow_lookup
r_struct
id|xfrm_policy
op_star
id|flow_lookup
c_func
(paren
r_int
id|dir
comma
r_struct
id|flowi
op_star
id|fl
)paren
(brace
r_struct
id|xfrm_policy
op_star
id|pol
suffix:semicolon
r_struct
id|flow_entry
op_star
id|fle
suffix:semicolon
id|u32
id|hash
op_assign
id|flow_hash
c_func
(paren
id|fl
)paren
suffix:semicolon
r_int
id|cpu
suffix:semicolon
id|local_bh_disable
c_func
(paren
)paren
suffix:semicolon
id|cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|fle
op_assign
id|flow_table
(braket
id|cpu
op_star
id|FLOWCACHE_HASH_SIZE
op_plus
id|hash
)braket
suffix:semicolon
id|fle
suffix:semicolon
id|fle
op_assign
id|fle-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|fl
comma
op_amp
id|fle-&gt;fl
comma
r_sizeof
(paren
id|fle-&gt;fl
)paren
)paren
op_eq
l_int|0
op_logical_and
id|fle-&gt;dir
op_eq
id|dir
)paren
(brace
r_if
c_cond
(paren
id|fle-&gt;genid
op_eq
id|xfrm_policy_genid
)paren
(brace
r_if
c_cond
(paren
(paren
id|pol
op_assign
id|fle-&gt;pol
)paren
op_ne
l_int|NULL
)paren
id|atomic_inc
c_func
(paren
op_amp
id|pol-&gt;refcnt
)paren
suffix:semicolon
id|local_bh_enable
c_func
(paren
)paren
suffix:semicolon
r_return
id|pol
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
)brace
id|pol
op_assign
id|xfrm_policy_lookup
c_func
(paren
id|dir
comma
id|fl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fle
)paren
(brace
multiline_comment|/* Stale flow entry found. Update it. */
id|fle-&gt;genid
op_assign
id|xfrm_policy_genid
suffix:semicolon
r_if
c_cond
(paren
id|fle-&gt;pol
)paren
id|xfrm_pol_put
c_func
(paren
id|fle-&gt;pol
)paren
suffix:semicolon
id|fle-&gt;pol
op_assign
id|pol
suffix:semicolon
r_if
c_cond
(paren
id|pol
)paren
id|atomic_inc
c_func
(paren
op_amp
id|pol-&gt;refcnt
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|flow_count
c_func
(paren
id|cpu
)paren
OG
id|flow_hwm
)paren
id|flow_cache_shrink
c_func
(paren
id|cpu
)paren
suffix:semicolon
id|fle
op_assign
id|kmem_cache_alloc
c_func
(paren
id|flow_cachep
comma
id|SLAB_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fle
)paren
(brace
id|flow_count
c_func
(paren
id|cpu
)paren
op_increment
suffix:semicolon
id|fle-&gt;fl
op_assign
op_star
id|fl
suffix:semicolon
id|fle-&gt;genid
op_assign
id|xfrm_policy_genid
suffix:semicolon
id|fle-&gt;dir
op_assign
id|dir
suffix:semicolon
id|fle-&gt;pol
op_assign
id|pol
suffix:semicolon
r_if
c_cond
(paren
id|pol
)paren
id|atomic_inc
c_func
(paren
op_amp
id|pol-&gt;refcnt
)paren
suffix:semicolon
id|fle-&gt;next
op_assign
id|flow_table
(braket
id|cpu
op_star
id|FLOWCACHE_HASH_SIZE
op_plus
id|hash
)braket
suffix:semicolon
id|flow_table
(braket
id|cpu
op_star
id|FLOWCACHE_HASH_SIZE
op_plus
id|hash
)braket
op_assign
id|fle
suffix:semicolon
)brace
)brace
id|local_bh_enable
c_func
(paren
)paren
suffix:semicolon
r_return
id|pol
suffix:semicolon
)brace
DECL|function|flow_cache_init
r_void
id|__init
id|flow_cache_init
c_func
(paren
r_void
)paren
(brace
r_int
id|order
suffix:semicolon
id|flow_cachep
op_assign
id|kmem_cache_create
c_func
(paren
l_string|&quot;flow_cache&quot;
comma
r_sizeof
(paren
r_struct
id|flow_entry
)paren
comma
l_int|0
comma
id|SLAB_HWCACHE_ALIGN
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|flow_cachep
)paren
id|panic
c_func
(paren
l_string|&quot;NET: failed to allocate flow cache slab&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|order
op_assign
l_int|0
suffix:semicolon
(paren
id|PAGE_SIZE
op_lshift
id|order
)paren
OL
(paren
id|NR_CPUS
op_star
r_sizeof
(paren
r_struct
id|flow_entry
op_star
)paren
op_star
id|FLOWCACHE_HASH_SIZE
)paren
suffix:semicolon
id|order
op_increment
)paren
multiline_comment|/* NOTHING */
suffix:semicolon
id|flow_table
op_assign
(paren
r_struct
id|flow_entry
op_star
op_star
)paren
id|__get_free_pages
c_func
(paren
id|GFP_ATOMIC
comma
id|order
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|flow_table
)paren
id|panic
c_func
(paren
l_string|&quot;Failed to allocate flow cache hash table&bslash;n&quot;
)paren
suffix:semicolon
id|memset
c_func
(paren
id|flow_table
comma
l_int|0
comma
id|PAGE_SIZE
op_lshift
id|order
)paren
suffix:semicolon
)brace
multiline_comment|/* Allocate xfrm_policy. Not used here, it is supposed to be used by pfkeyv2&n; * SPD calls.&n; */
DECL|function|xfrm_policy_alloc
r_struct
id|xfrm_policy
op_star
id|xfrm_policy_alloc
c_func
(paren
r_void
)paren
(brace
r_struct
id|xfrm_policy
op_star
id|policy
suffix:semicolon
id|policy
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|xfrm_policy
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|policy
)paren
(brace
id|memset
c_func
(paren
id|policy
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|xfrm_policy
)paren
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|policy-&gt;refcnt
comma
l_int|1
)paren
suffix:semicolon
id|policy-&gt;lock
op_assign
id|RW_LOCK_UNLOCKED
suffix:semicolon
)brace
r_return
id|policy
suffix:semicolon
)brace
multiline_comment|/* Destroy xfrm_policy: descendant resources must be released to this moment. */
DECL|function|__xfrm_policy_destroy
r_void
id|__xfrm_policy_destroy
c_func
(paren
r_struct
id|xfrm_policy
op_star
id|policy
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|policy-&gt;dead
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|policy-&gt;xfrm_nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|policy-&gt;xfrm_vec
(braket
id|i
)braket
dot
id|resolved
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|policy-&gt;bundles
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|policy
)paren
suffix:semicolon
)brace
multiline_comment|/* Rule must be locked. Release descentant resources, announce&n; * entry dead. The rule must be unlinked from lists to the moment.&n; */
DECL|function|xfrm_policy_kill
r_void
id|xfrm_policy_kill
c_func
(paren
r_struct
id|xfrm_policy
op_star
id|policy
)paren
(brace
r_struct
id|dst_entry
op_star
id|dst
suffix:semicolon
r_int
id|i
suffix:semicolon
id|policy-&gt;dead
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|policy-&gt;xfrm_nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|policy-&gt;xfrm_vec
(braket
id|i
)braket
dot
id|resolved
)paren
(brace
id|xfrm_state_put
c_func
(paren
id|policy-&gt;xfrm_vec
(braket
id|i
)braket
dot
id|resolved
)paren
suffix:semicolon
id|policy-&gt;xfrm_vec
(braket
id|i
)braket
dot
id|resolved
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
(paren
id|dst
op_assign
id|policy-&gt;bundles
)paren
op_ne
l_int|NULL
)paren
(brace
id|policy-&gt;bundles
op_assign
id|dst-&gt;next
suffix:semicolon
id|dst_free
c_func
(paren
id|dst
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Find policy to apply to this flow. */
DECL|function|xfrm_policy_lookup
r_struct
id|xfrm_policy
op_star
id|xfrm_policy_lookup
c_func
(paren
r_int
id|dir
comma
r_struct
id|flowi
op_star
id|fl
)paren
(brace
r_struct
id|xfrm_policy
op_star
id|pol
suffix:semicolon
r_int
r_int
id|now
op_assign
id|xtime.tv_sec
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|xfrm_policy_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|pol
op_assign
id|xfrm_policy_list
(braket
id|dir
)braket
suffix:semicolon
id|pol
suffix:semicolon
id|pol
op_assign
id|pol-&gt;next
)paren
(brace
r_struct
id|xfrm_selector
op_star
id|sel
op_assign
op_amp
id|pol-&gt;selector
suffix:semicolon
r_if
c_cond
(paren
id|xfrm4_selector_match
c_func
(paren
id|sel
comma
id|fl
)paren
op_logical_and
id|now
OL
id|pol-&gt;expires
)paren
(brace
id|pol-&gt;lastuse
op_assign
id|now
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|pol-&gt;refcnt
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|read_unlock
c_func
(paren
op_amp
id|xfrm_policy_lock
)paren
suffix:semicolon
r_return
id|pol
suffix:semicolon
)brace
multiline_comment|/* Resolve list of templates for the flow, given policy. */
r_static
r_int
DECL|function|xfrm_tmpl_resolve
id|xfrm_tmpl_resolve
c_func
(paren
r_struct
id|xfrm_policy
op_star
id|policy
comma
r_struct
id|flowi
op_star
id|fl
comma
r_struct
id|xfrm_state
op_star
op_star
id|xfrm
)paren
(brace
r_int
id|i
comma
id|error
suffix:semicolon
id|u32
id|daddr
op_assign
id|fl-&gt;fl4_dst
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|policy-&gt;xfrm_nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|xfrm_tmpl
op_star
id|tmpl
op_assign
op_amp
id|policy-&gt;xfrm_vec
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|tmpl-&gt;mode
)paren
id|daddr
op_assign
id|tmpl-&gt;id.daddr.xfrm4_addr
suffix:semicolon
r_if
c_cond
(paren
id|tmpl-&gt;resolved
)paren
(brace
r_if
c_cond
(paren
id|tmpl-&gt;resolved-&gt;km.state
op_ne
id|XFRM_STATE_VALID
)paren
(brace
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|fail
suffix:semicolon
)brace
id|xfrm
(braket
id|i
)braket
op_assign
id|tmpl-&gt;resolved
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|tmpl-&gt;resolved-&gt;refcnt
)paren
suffix:semicolon
)brace
r_else
(brace
id|xfrm
(braket
id|i
)braket
op_assign
id|xfrm_state_find
c_func
(paren
id|daddr
comma
id|fl
comma
id|tmpl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|xfrm
(braket
id|i
)braket
op_eq
l_int|NULL
)paren
(brace
id|error
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|fail
suffix:semicolon
)brace
r_if
c_cond
(paren
id|xfrm
(braket
id|i
)braket
op_member_access_from_pointer
id|km.state
op_eq
id|XFRM_STATE_VALID
)paren
r_continue
suffix:semicolon
id|i
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|xfrm
(braket
id|i
)braket
op_member_access_from_pointer
id|km.state
op_eq
id|XFRM_STATE_ERROR
)paren
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_else
id|error
op_assign
op_minus
id|EAGAIN
suffix:semicolon
r_goto
id|fail
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
id|fail
suffix:colon
r_for
c_loop
(paren
id|i
op_decrement
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
id|xfrm_state_put
c_func
(paren
id|xfrm
(braket
id|i
)braket
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/* Check that the bundle accepts the flow and its components are&n; * still valid.&n; */
DECL|function|xfrm_bundle_ok
r_static
r_int
id|xfrm_bundle_ok
c_func
(paren
r_struct
id|xfrm_dst
op_star
id|xdst
comma
r_struct
id|flowi
op_star
id|fl
)paren
(brace
r_do
(brace
r_if
c_cond
(paren
id|xdst-&gt;u.dst.ops
op_ne
op_amp
id|xfrm4_dst_ops
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|xfrm4_selector_match
c_func
(paren
op_amp
id|xdst-&gt;u.dst.xfrm-&gt;sel
comma
id|fl
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|xdst-&gt;u.dst.xfrm-&gt;km.state
op_ne
id|XFRM_STATE_VALID
op_logical_or
id|xdst-&gt;u.dst.path-&gt;obsolete
OG
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
id|xdst
op_assign
(paren
r_struct
id|xfrm_dst
op_star
)paren
id|xdst-&gt;u.dst.child
suffix:semicolon
)brace
r_while
c_loop
(paren
id|xdst
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Allocate chain of dst_entry&squot;s, attach known xfrm&squot;s, calculate&n; * all the metrics... Shortly, bundle a bundle.&n; */
r_int
DECL|function|xfrm_bundle_create
id|xfrm_bundle_create
c_func
(paren
r_struct
id|xfrm_policy
op_star
id|policy
comma
r_struct
id|xfrm_state
op_star
op_star
id|xfrm
comma
r_struct
id|flowi
op_star
id|fl
comma
r_struct
id|dst_entry
op_star
op_star
id|dst_p
)paren
(brace
r_struct
id|dst_entry
op_star
id|dst
comma
op_star
id|dst_prev
suffix:semicolon
r_struct
id|rtable
op_star
id|rt
op_assign
(paren
r_struct
id|rtable
op_star
)paren
(paren
op_star
id|dst_p
)paren
suffix:semicolon
id|u32
id|remote
op_assign
id|fl-&gt;fl4_dst
suffix:semicolon
id|u32
id|local
op_assign
id|fl-&gt;fl4_src
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|err
suffix:semicolon
r_int
id|header_len
op_assign
l_int|0
suffix:semicolon
id|dst
op_assign
id|dst_prev
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|policy-&gt;xfrm_nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|dst_entry
op_star
id|dst1
op_assign
id|dst_alloc
c_func
(paren
op_amp
id|xfrm4_dst_ops
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|dst1
op_eq
l_int|NULL
)paren
)paren
(brace
id|err
op_assign
op_minus
id|ENOBUFS
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
id|dst1-&gt;xfrm
op_assign
id|xfrm
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dst
)paren
id|dst
op_assign
id|dst1
suffix:semicolon
r_else
id|dst_prev-&gt;child
op_assign
id|dst1
suffix:semicolon
id|dst_prev
op_assign
id|dst1
suffix:semicolon
r_if
c_cond
(paren
id|xfrm
(braket
id|i
)braket
op_member_access_from_pointer
id|props.mode
)paren
(brace
id|remote
op_assign
id|xfrm
(braket
id|i
)braket
op_member_access_from_pointer
id|id.daddr.xfrm4_addr
suffix:semicolon
id|local
op_assign
id|xfrm
(braket
id|i
)braket
op_member_access_from_pointer
id|props.saddr.xfrm4_addr
suffix:semicolon
)brace
id|header_len
op_add_assign
id|xfrm
(braket
id|i
)braket
op_member_access_from_pointer
id|props.header_len
suffix:semicolon
)brace
r_if
c_cond
(paren
id|remote
op_ne
id|fl-&gt;fl4_dst
)paren
(brace
r_struct
id|flowi
id|fl_tunnel
op_assign
(brace
dot
id|nl_u
op_assign
(brace
dot
id|ip4_u
op_assign
(brace
dot
id|daddr
op_assign
id|remote
comma
dot
id|saddr
op_assign
id|local
)brace
)brace
)brace
suffix:semicolon
id|err
op_assign
id|ip_route_output_key
c_func
(paren
op_amp
id|rt
comma
op_amp
id|fl_tunnel
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|error
suffix:semicolon
id|dst_release
c_func
(paren
op_star
id|dst_p
)paren
suffix:semicolon
op_star
id|dst_p
op_assign
op_amp
id|rt-&gt;u.dst
suffix:semicolon
)brace
id|dst_prev-&gt;child
op_assign
op_amp
id|rt-&gt;u.dst
suffix:semicolon
r_for
c_loop
(paren
id|dst_prev
op_assign
id|dst
suffix:semicolon
id|dst_prev
op_ne
op_amp
id|rt-&gt;u.dst
suffix:semicolon
id|dst_prev
op_assign
id|dst_prev-&gt;child
)paren
(brace
r_struct
id|xfrm_dst
op_star
id|x
op_assign
(paren
r_struct
id|xfrm_dst
op_star
)paren
id|dst_prev
suffix:semicolon
id|x-&gt;u.rt.fl
op_assign
op_star
id|fl
suffix:semicolon
id|dst_prev-&gt;dev
op_assign
id|rt-&gt;u.dst.dev
suffix:semicolon
r_if
c_cond
(paren
id|rt-&gt;u.dst.dev
)paren
id|dev_hold
c_func
(paren
id|rt-&gt;u.dst.dev
)paren
suffix:semicolon
id|dst_prev-&gt;flags
op_assign
id|DST_HOST
suffix:semicolon
id|dst_prev-&gt;lastuse
op_assign
id|jiffies
suffix:semicolon
id|dst_prev-&gt;header_len
op_assign
id|header_len
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|dst_prev-&gt;metrics
comma
op_amp
id|rt-&gt;u.dst.metrics
comma
r_sizeof
(paren
op_amp
id|dst_prev-&gt;metrics
)paren
)paren
suffix:semicolon
id|dst_prev-&gt;path
op_assign
op_amp
id|rt-&gt;u.dst
suffix:semicolon
multiline_comment|/* Copy neighbout for reachability confirmation */
id|dst_prev-&gt;neighbour
op_assign
id|neigh_clone
c_func
(paren
id|rt-&gt;u.dst.neighbour
)paren
suffix:semicolon
id|dst_prev-&gt;input
op_assign
id|rt-&gt;u.dst.input
suffix:semicolon
id|dst_prev-&gt;output
op_assign
id|dst_prev-&gt;xfrm-&gt;type-&gt;output
suffix:semicolon
r_if
c_cond
(paren
id|rt-&gt;peer
)paren
id|atomic_inc
c_func
(paren
op_amp
id|rt-&gt;peer-&gt;refcnt
)paren
suffix:semicolon
id|x-&gt;u.rt.peer
op_assign
id|rt-&gt;peer
suffix:semicolon
id|x-&gt;u.rt.rt_flags
op_assign
id|rt-&gt;rt_flags
suffix:semicolon
id|x-&gt;u.rt.rt_type
op_assign
id|rt-&gt;rt_type
suffix:semicolon
id|x-&gt;u.rt.rt_src
op_assign
id|rt-&gt;rt_src
suffix:semicolon
id|x-&gt;u.rt.rt_src
op_assign
id|rt-&gt;rt_src
suffix:semicolon
id|x-&gt;u.rt.rt_dst
op_assign
id|rt-&gt;rt_dst
suffix:semicolon
id|x-&gt;u.rt.rt_gateway
op_assign
id|rt-&gt;rt_gateway
suffix:semicolon
id|x-&gt;u.rt.rt_spec_dst
op_assign
id|rt-&gt;rt_spec_dst
suffix:semicolon
id|header_len
op_sub_assign
id|x-&gt;u.dst.xfrm-&gt;props.header_len
suffix:semicolon
)brace
op_star
id|dst_p
op_assign
id|dst
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|error
suffix:colon
r_if
c_cond
(paren
id|dst
)paren
id|dst_free
c_func
(paren
id|dst
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/* Main function: finds/creates a bundle for given flow.&n; *&n; * At the moment we eat a raw IP route. Mostly to speed up lookups&n; * on interfaces with disabled IPsec.&n; */
DECL|function|xfrm_lookup
r_int
id|xfrm_lookup
c_func
(paren
r_struct
id|dst_entry
op_star
op_star
id|dst_p
comma
r_struct
id|flowi
op_star
id|fl
comma
r_struct
id|sock
op_star
id|sk
comma
r_int
id|flags
)paren
(brace
r_struct
id|xfrm_policy
op_star
id|policy
suffix:semicolon
r_struct
id|xfrm_state
op_star
id|xfrm
(braket
id|XFRM_MAX_DEPTH
)braket
suffix:semicolon
r_struct
id|rtable
op_star
id|rt
op_assign
(paren
r_struct
id|rtable
op_star
)paren
op_star
id|dst_p
suffix:semicolon
r_struct
id|dst_entry
op_star
id|dst
suffix:semicolon
r_int
id|err
suffix:semicolon
id|u32
id|genid
suffix:semicolon
multiline_comment|/* To accelerate a bit...  */
r_if
c_cond
(paren
(paren
id|rt-&gt;u.dst.flags
op_amp
id|DST_NOXFRM
)paren
op_logical_or
op_logical_neg
id|xfrm_policy_list
(braket
id|XFRM_POLICY_OUT
)braket
)paren
r_return
l_int|0
suffix:semicolon
id|fl-&gt;oif
op_assign
id|rt-&gt;u.dst.dev-&gt;ifindex
suffix:semicolon
id|fl-&gt;fl4_src
op_assign
id|rt-&gt;rt_src
suffix:semicolon
id|restart
suffix:colon
id|genid
op_assign
id|xfrm_policy_genid
suffix:semicolon
id|policy
op_assign
id|flow_lookup
c_func
(paren
id|XFRM_POLICY_OUT
comma
id|fl
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|policy
)paren
r_return
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|policy-&gt;action
)paren
(brace
r_case
id|XFRM_POLICY_BLOCK
suffix:colon
multiline_comment|/* Prohibit the flow */
id|xfrm_pol_put
c_func
(paren
id|policy
)paren
suffix:semicolon
r_return
op_minus
id|EPERM
suffix:semicolon
r_case
id|XFRM_POLICY_ALLOW
suffix:colon
r_if
c_cond
(paren
id|policy-&gt;xfrm_nr
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Flow passes not transformed. */
id|xfrm_pol_put
c_func
(paren
id|policy
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Try to find matching bundle.&n;&t;&t; *&n;&t;&t; * LATER: help from flow cache. It is optional, this&n;&t;&t; * is required only for output policy.&n;&t;&t; */
id|read_lock_bh
c_func
(paren
op_amp
id|policy-&gt;lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|dst
op_assign
id|policy-&gt;bundles
suffix:semicolon
id|dst
suffix:semicolon
id|dst
op_assign
id|dst-&gt;next
)paren
(brace
r_struct
id|xfrm_dst
op_star
id|xdst
op_assign
(paren
r_struct
id|xfrm_dst
op_star
)paren
id|dst
suffix:semicolon
r_if
c_cond
(paren
id|xdst-&gt;u.rt.fl.fl4_dst
op_eq
id|fl-&gt;fl4_dst
op_logical_and
id|xdst-&gt;u.rt.fl.fl4_src
op_eq
id|fl-&gt;fl4_src
op_logical_and
id|xdst-&gt;u.rt.fl.oif
op_eq
id|fl-&gt;oif
op_logical_and
id|xfrm_bundle_ok
c_func
(paren
id|xdst
comma
id|fl
)paren
)paren
(brace
id|dst_clone
c_func
(paren
id|dst
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|read_unlock_bh
c_func
(paren
op_amp
id|policy-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dst
)paren
r_break
suffix:semicolon
id|err
op_assign
id|xfrm_tmpl_resolve
c_func
(paren
id|policy
comma
id|fl
comma
id|xfrm
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|err
)paren
)paren
(brace
r_if
c_cond
(paren
id|err
op_eq
op_minus
id|EAGAIN
)paren
(brace
r_struct
id|task_struct
op_star
id|tsk
op_assign
id|current
suffix:semicolon
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|tsk
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|flags
)paren
r_goto
id|error
suffix:semicolon
id|__set_task_state
c_func
(paren
id|tsk
comma
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
id|add_wait_queue
c_func
(paren
id|km_waitq
comma
op_amp
id|wait
)paren
suffix:semicolon
id|err
op_assign
id|xfrm_tmpl_resolve
c_func
(paren
id|policy
comma
id|fl
comma
id|xfrm
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_eq
op_minus
id|EAGAIN
)paren
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|__set_task_state
c_func
(paren
id|tsk
comma
id|TASK_RUNNING
)paren
suffix:semicolon
id|remove_wait_queue
c_func
(paren
id|km_waitq
comma
op_amp
id|wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_eq
op_minus
id|EAGAIN
op_logical_and
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
id|err
op_assign
op_minus
id|ERESTART
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
r_if
c_cond
(paren
id|err
op_eq
op_minus
id|EAGAIN
op_logical_or
id|genid
op_ne
id|xfrm_policy_genid
)paren
r_goto
id|restart
suffix:semicolon
)brace
r_if
c_cond
(paren
id|err
)paren
r_goto
id|error
suffix:semicolon
)brace
id|dst
op_assign
op_amp
id|rt-&gt;u.dst
suffix:semicolon
id|err
op_assign
id|xfrm_bundle_create
c_func
(paren
id|policy
comma
id|xfrm
comma
id|fl
comma
op_amp
id|dst
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|err
)paren
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|policy-&gt;xfrm_nr
suffix:semicolon
id|i
op_increment
)paren
id|xfrm_state_put
c_func
(paren
id|xfrm
(braket
id|i
)braket
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EPERM
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
id|write_lock_bh
c_func
(paren
op_amp
id|policy-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|policy-&gt;dead
)paren
)paren
(brace
multiline_comment|/* Wow! While we worked on resolving, this&n;&t;&t;&t; * policy has gone. Retry. It is not paranoia,&n;&t;&t;&t; * we just cannot enlist new bundle to dead object.&n;&t;&t;&t; */
id|write_unlock_bh
c_func
(paren
op_amp
id|policy-&gt;lock
)paren
suffix:semicolon
id|xfrm_pol_put
c_func
(paren
id|policy
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dst
)paren
(brace
id|dst_release
c_func
(paren
id|dst
)paren
suffix:semicolon
id|dst_free
c_func
(paren
id|dst
)paren
suffix:semicolon
)brace
r_goto
id|restart
suffix:semicolon
)brace
id|dst-&gt;next
op_assign
id|policy-&gt;bundles
suffix:semicolon
id|policy-&gt;bundles
op_assign
id|dst
suffix:semicolon
id|write_unlock_bh
c_func
(paren
op_amp
id|policy-&gt;lock
)paren
suffix:semicolon
)brace
op_star
id|dst_p
op_assign
id|dst
suffix:semicolon
id|ip_rt_put
c_func
(paren
id|rt
)paren
suffix:semicolon
id|xfrm_pol_put
c_func
(paren
id|policy
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|error
suffix:colon
id|ip_rt_put
c_func
(paren
id|rt
)paren
suffix:semicolon
id|xfrm_pol_put
c_func
(paren
id|policy
)paren
suffix:semicolon
op_star
id|dst_p
op_assign
l_int|NULL
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/* When skb is transformed back to its &quot;native&quot; form, we have to&n; * check policy restrictions. At the moment we make this in maximally&n; * stupid way. Shame on me. :-) Of course, connected sockets must&n; * have policy cached at them.&n; */
r_static
r_inline
r_int
DECL|function|xfrm_state_ok
id|xfrm_state_ok
c_func
(paren
r_struct
id|xfrm_tmpl
op_star
id|tmpl
comma
r_struct
id|xfrm_state
op_star
id|x
)paren
(brace
r_return
id|x-&gt;id.proto
op_eq
id|tmpl-&gt;id.proto
op_logical_and
(paren
id|x-&gt;id.spi
op_eq
id|tmpl-&gt;id.spi
op_logical_or
op_logical_neg
id|tmpl-&gt;id.spi
)paren
op_logical_and
id|x-&gt;props.mode
op_eq
id|tmpl-&gt;mode
op_logical_and
(paren
id|tmpl-&gt;algos
op_amp
(paren
l_int|1
op_lshift
id|x-&gt;props.algo
)paren
)paren
op_logical_and
(paren
op_logical_neg
id|x-&gt;props.mode
op_logical_or
op_logical_neg
id|tmpl-&gt;saddr.xfrm4_addr
op_logical_or
id|tmpl-&gt;saddr.xfrm4_addr
op_eq
id|x-&gt;props.saddr.xfrm4_addr
)paren
suffix:semicolon
)brace
r_static
r_inline
r_int
DECL|function|xfrm_policy_ok
id|xfrm_policy_ok
c_func
(paren
r_struct
id|xfrm_tmpl
op_star
id|tmpl
comma
r_struct
id|sec_path
op_star
id|sp
comma
r_int
id|idx
)paren
(brace
r_for
c_loop
(paren
suffix:semicolon
id|idx
OL
id|sp-&gt;len
suffix:semicolon
id|idx
op_increment
)paren
(brace
r_if
c_cond
(paren
id|xfrm_state_ok
c_func
(paren
id|tmpl
comma
id|sp-&gt;xvec
(braket
id|idx
)braket
)paren
)paren
r_return
op_increment
id|idx
suffix:semicolon
)brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|_decode_session
id|_decode_session
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|flowi
op_star
id|fl
)paren
(brace
r_struct
id|iphdr
op_star
id|iph
op_assign
id|skb-&gt;nh.iph
suffix:semicolon
id|u8
op_star
id|xprth
op_assign
id|skb-&gt;nh.raw
op_plus
id|iph-&gt;ihl
op_star
l_int|4
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|iph-&gt;frag_off
op_amp
id|htons
c_func
(paren
id|IP_MF
op_or
id|IP_OFFSET
)paren
)paren
)paren
(brace
r_switch
c_cond
(paren
id|iph-&gt;protocol
)paren
(brace
r_case
id|IPPROTO_UDP
suffix:colon
r_case
id|IPPROTO_TCP
suffix:colon
r_case
id|IPPROTO_SCTP
suffix:colon
r_if
c_cond
(paren
id|pskb_may_pull
c_func
(paren
id|skb
comma
id|xprth
op_plus
l_int|4
op_minus
id|skb-&gt;data
)paren
)paren
(brace
id|u16
op_star
id|ports
op_assign
(paren
id|u16
op_star
)paren
id|xprth
suffix:semicolon
id|fl-&gt;uli_u.ports.sport
op_assign
id|ports
(braket
l_int|0
)braket
suffix:semicolon
id|fl-&gt;uli_u.ports.dport
op_assign
id|ports
(braket
l_int|1
)braket
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|IPPROTO_ESP
suffix:colon
r_if
c_cond
(paren
id|pskb_may_pull
c_func
(paren
id|skb
comma
id|xprth
op_plus
l_int|4
op_minus
id|skb-&gt;data
)paren
)paren
(brace
id|u32
op_star
id|ehdr
op_assign
(paren
id|u32
op_star
)paren
id|xprth
suffix:semicolon
id|fl-&gt;uli_u.spi
op_assign
id|ehdr
(braket
l_int|0
)braket
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|IPPROTO_AH
suffix:colon
r_if
c_cond
(paren
id|pskb_may_pull
c_func
(paren
id|skb
comma
id|xprth
op_plus
l_int|8
op_minus
id|skb-&gt;data
)paren
)paren
(brace
id|u32
op_star
id|ah_hdr
op_assign
(paren
id|u32
op_star
)paren
id|xprth
suffix:semicolon
id|fl-&gt;uli_u.spi
op_assign
id|ah_hdr
(braket
l_int|1
)braket
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|fl-&gt;uli_u.spi
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
suffix:semicolon
)brace
r_else
(brace
id|memset
c_func
(paren
id|fl
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|flowi
)paren
)paren
suffix:semicolon
)brace
id|fl-&gt;proto
op_assign
id|iph-&gt;protocol
suffix:semicolon
id|fl-&gt;fl4_dst
op_assign
id|iph-&gt;daddr
suffix:semicolon
id|fl-&gt;fl4_src
op_assign
id|iph-&gt;saddr
suffix:semicolon
)brace
DECL|function|__xfrm_policy_check
r_int
id|__xfrm_policy_check
c_func
(paren
r_int
id|dir
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|xfrm_policy
op_star
id|pol
suffix:semicolon
r_struct
id|flowi
id|fl
suffix:semicolon
id|_decode_session
c_func
(paren
id|skb
comma
op_amp
id|fl
)paren
suffix:semicolon
multiline_comment|/* First, check used SA against their selectors. */
r_if
c_cond
(paren
id|skb-&gt;sp
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|skb-&gt;sp-&gt;len
op_minus
l_int|1
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|xfrm4_selector_match
c_func
(paren
op_amp
id|skb-&gt;sp-&gt;xvec
(braket
id|i
)braket
op_member_access_from_pointer
id|sel
comma
op_amp
id|fl
)paren
)paren
r_return
l_int|0
suffix:semicolon
)brace
)brace
id|pol
op_assign
id|flow_lookup
c_func
(paren
id|dir
comma
op_amp
id|fl
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pol
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|pol-&gt;action
op_eq
id|XFRM_POLICY_ALLOW
)paren
(brace
r_if
c_cond
(paren
id|pol-&gt;xfrm_nr
op_ne
l_int|0
)paren
(brace
r_struct
id|sec_path
op_star
id|sp
suffix:semicolon
r_int
id|i
comma
id|k
suffix:semicolon
r_if
c_cond
(paren
(paren
id|sp
op_assign
id|skb-&gt;sp
)paren
op_eq
l_int|NULL
)paren
r_goto
id|reject
suffix:semicolon
multiline_comment|/* For each tmpl search corresponding xfrm.&n;&t;&t;&t; * Order is _important_. Later we will implement&n;&t;&t;&t; * some barriers, but at the moment barriers&n;&t;&t;&t; * are implied between each two transformations.&n;&t;&t;&t; */
r_for
c_loop
(paren
id|i
op_assign
id|pol-&gt;xfrm_nr
op_minus
l_int|1
comma
id|k
op_assign
l_int|0
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
id|k
op_assign
id|xfrm_policy_ok
c_func
(paren
id|pol-&gt;xfrm_vec
op_plus
id|i
comma
id|sp
comma
id|k
)paren
suffix:semicolon
r_if
c_cond
(paren
id|k
OL
l_int|0
)paren
r_goto
id|reject
suffix:semicolon
)brace
)brace
id|xfrm_pol_put
c_func
(paren
id|pol
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|reject
suffix:colon
id|xfrm_pol_put
c_func
(paren
id|pol
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|__xfrm_route_forward
r_int
id|__xfrm_route_forward
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|flowi
id|fl
suffix:semicolon
id|_decode_session
c_func
(paren
id|skb
comma
op_amp
id|fl
)paren
suffix:semicolon
r_return
id|xfrm_lookup
c_func
(paren
op_amp
id|skb-&gt;dst
comma
op_amp
id|fl
comma
l_int|NULL
comma
l_int|0
)paren
op_eq
l_int|0
suffix:semicolon
)brace
DECL|function|xfrm4_dst_check
r_static
r_struct
id|dst_entry
op_star
id|xfrm4_dst_check
c_func
(paren
r_struct
id|dst_entry
op_star
id|dst
comma
id|u32
id|cookie
)paren
(brace
id|dst_release
c_func
(paren
id|dst
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|xfrm4_dst_destroy
r_static
r_void
id|xfrm4_dst_destroy
c_func
(paren
r_struct
id|dst_entry
op_star
id|dst
)paren
(brace
id|xfrm_state_put
c_func
(paren
id|dst-&gt;xfrm
)paren
suffix:semicolon
id|dst-&gt;xfrm
op_assign
l_int|NULL
suffix:semicolon
)brace
DECL|function|xfrm4_link_failure
r_static
r_void
id|xfrm4_link_failure
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
multiline_comment|/* Impossible. Such dst must be popped before reaches point of failure. */
r_return
suffix:semicolon
)brace
DECL|function|xfrm4_negative_advice
r_static
r_struct
id|dst_entry
op_star
id|xfrm4_negative_advice
c_func
(paren
r_struct
id|dst_entry
op_star
id|dst
)paren
(brace
r_if
c_cond
(paren
id|dst
)paren
(brace
r_if
c_cond
(paren
id|dst-&gt;obsolete
)paren
(brace
id|dst_release
c_func
(paren
id|dst
)paren
suffix:semicolon
id|dst
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
r_return
id|dst
suffix:semicolon
)brace
DECL|function|xfrm4_garbage_collect
r_static
r_int
id|xfrm4_garbage_collect
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|xfrm_policy
op_star
id|pol
suffix:semicolon
r_struct
id|dst_entry
op_star
id|dst
comma
op_star
op_star
id|dstp
comma
op_star
id|gc_list
op_assign
l_int|NULL
suffix:semicolon
id|read_lock_bh
c_func
(paren
op_amp
id|xfrm_policy_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|XFRM_POLICY_MAX
suffix:semicolon
id|i
op_increment
)paren
(brace
r_for
c_loop
(paren
id|pol
op_assign
id|xfrm_policy_list
(braket
id|i
)braket
suffix:semicolon
id|pol
suffix:semicolon
id|pol
op_assign
id|pol-&gt;next
)paren
(brace
id|write_lock
c_func
(paren
op_amp
id|pol-&gt;lock
)paren
suffix:semicolon
id|dstp
op_assign
op_amp
id|pol-&gt;bundles
suffix:semicolon
r_while
c_loop
(paren
(paren
id|dst
op_assign
op_star
id|dstp
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|dst-&gt;__refcnt
)paren
op_eq
l_int|0
)paren
(brace
op_star
id|dstp
op_assign
id|dst-&gt;next
suffix:semicolon
id|dst-&gt;next
op_assign
id|gc_list
suffix:semicolon
id|gc_list
op_assign
id|dst
suffix:semicolon
)brace
r_else
(brace
id|dstp
op_assign
op_amp
id|dst-&gt;next
suffix:semicolon
)brace
)brace
id|write_unlock
c_func
(paren
op_amp
id|pol-&gt;lock
)paren
suffix:semicolon
)brace
)brace
id|read_unlock_bh
c_func
(paren
op_amp
id|xfrm_policy_lock
)paren
suffix:semicolon
r_while
c_loop
(paren
id|gc_list
)paren
(brace
id|dst
op_assign
id|gc_list
suffix:semicolon
id|gc_list
op_assign
id|dst-&gt;next
suffix:semicolon
id|dst_destroy
c_func
(paren
id|dst
)paren
suffix:semicolon
)brace
r_return
(paren
id|atomic_read
c_func
(paren
op_amp
id|xfrm4_dst_ops.entries
)paren
OG
id|xfrm4_dst_ops.gc_thresh
op_star
l_int|2
)paren
suffix:semicolon
)brace
DECL|function|xfrm4_update_pmtu
r_static
r_void
id|xfrm4_update_pmtu
c_func
(paren
r_struct
id|dst_entry
op_star
id|dst
comma
id|u32
id|mtu
)paren
(brace
r_struct
id|dst_entry
op_star
id|path
op_assign
id|dst-&gt;path
suffix:semicolon
r_if
c_cond
(paren
id|mtu
OL
l_int|68
op_plus
id|dst-&gt;header_len
)paren
r_return
suffix:semicolon
id|path-&gt;ops
op_member_access_from_pointer
id|update_pmtu
c_func
(paren
id|path
comma
id|mtu
)paren
suffix:semicolon
)brace
multiline_comment|/* Well... that&squot;s _TASK_. We need to scan through transformation&n; * list and figure out what mss tcp should generate in order to&n; * final datagram fit to mtu. Mama mia... :-)&n; *&n; * Apparently, some easy way exists, but we used to choose the most&n; * bizarre ones. :-) So, raising Kalashnikov... tra-ta-ta.&n; *&n; * Consider this function as something like dark humour. :-)&n; */
DECL|function|xfrm4_get_mss
r_static
r_int
id|xfrm4_get_mss
c_func
(paren
r_struct
id|dst_entry
op_star
id|dst
comma
id|u32
id|mtu
)paren
(brace
r_int
id|res
op_assign
id|mtu
op_minus
id|dst-&gt;header_len
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_struct
id|dst_entry
op_star
id|d
op_assign
id|dst
suffix:semicolon
r_int
id|m
op_assign
id|res
suffix:semicolon
r_do
(brace
r_struct
id|xfrm_state
op_star
id|x
op_assign
id|d-&gt;xfrm
suffix:semicolon
r_if
c_cond
(paren
id|x
)paren
(brace
r_if
c_cond
(paren
id|x-&gt;type-&gt;get_max_size
)paren
id|m
op_assign
id|x-&gt;type
op_member_access_from_pointer
id|get_max_size
c_func
(paren
id|d-&gt;xfrm
comma
id|m
)paren
suffix:semicolon
r_else
id|m
op_add_assign
id|x-&gt;props.header_len
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
(paren
id|d
op_assign
id|d-&gt;child
)paren
op_ne
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|m
op_le
id|mtu
)paren
r_break
suffix:semicolon
id|res
op_sub_assign
(paren
id|m
op_minus
id|mtu
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res
OL
l_int|88
)paren
r_return
id|mtu
suffix:semicolon
)brace
r_return
id|res
op_plus
id|dst-&gt;header_len
suffix:semicolon
)brace
DECL|variable|xfrm4_dst_ops
r_struct
id|dst_ops
id|xfrm4_dst_ops
op_assign
(brace
dot
id|family
op_assign
id|AF_INET
comma
dot
id|protocol
op_assign
id|__constant_htons
c_func
(paren
id|ETH_P_IP
)paren
comma
dot
id|gc
op_assign
id|xfrm4_garbage_collect
comma
dot
id|check
op_assign
id|xfrm4_dst_check
comma
dot
id|destroy
op_assign
id|xfrm4_dst_destroy
comma
dot
id|negative_advice
op_assign
id|xfrm4_negative_advice
comma
dot
id|link_failure
op_assign
id|xfrm4_link_failure
comma
dot
id|update_pmtu
op_assign
id|xfrm4_update_pmtu
comma
dot
id|get_mss
op_assign
id|xfrm4_get_mss
comma
dot
id|gc_thresh
op_assign
l_int|1024
comma
dot
id|entry_size
op_assign
r_sizeof
(paren
r_struct
id|xfrm_dst
)paren
comma
)brace
suffix:semicolon
DECL|function|xfrm_init
r_void
id|__init
id|xfrm_init
c_func
(paren
r_void
)paren
(brace
id|xfrm4_dst_ops.kmem_cachep
op_assign
id|kmem_cache_create
c_func
(paren
l_string|&quot;xfrm4_dst_cache&quot;
comma
r_sizeof
(paren
r_struct
id|xfrm_dst
)paren
comma
l_int|0
comma
id|SLAB_HWCACHE_ALIGN
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|xfrm4_dst_ops.kmem_cachep
)paren
id|panic
c_func
(paren
l_string|&quot;IP: failed to allocate xfrm4_dst_cache&bslash;n&quot;
)paren
suffix:semicolon
id|flow_cache_init
c_func
(paren
)paren
suffix:semicolon
id|xfrm_state_init
c_func
(paren
)paren
suffix:semicolon
id|xfrm_input_init
c_func
(paren
)paren
suffix:semicolon
id|ah4_init
c_func
(paren
)paren
suffix:semicolon
)brace
eof
