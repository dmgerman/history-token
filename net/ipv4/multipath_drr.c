multiline_comment|/*&n; *              Device round robin policy for multipath.&n; *&n; *&n; * Version:&t;$Id: multipath_drr.c,v 1.1.2.1 2004/09/16 07:42:34 elueck Exp $&n; *&n; * Authors:&t;Einar Lueck &lt;elueck@de.ibm.com&gt;&lt;lkml@einar-lueck.de&gt;&n; *&n; *&t;&t;This program is free software; you can redistribute it and/or&n; *&t;&t;modify it under the terms of the GNU General Public License&n; *&t;&t;as published by the Free Software Foundation; either version&n; *&t;&t;2 of the License, or (at your option) any later version.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/stat.h&gt;
macro_line|#include &lt;linux/socket.h&gt;
macro_line|#include &lt;linux/in.h&gt;
macro_line|#include &lt;linux/inet.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/inetdevice.h&gt;
macro_line|#include &lt;linux/igmp.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;linux/seq_file.h&gt;
macro_line|#include &lt;linux/mroute.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;net/ip.h&gt;
macro_line|#include &lt;net/protocol.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;net/sock.h&gt;
macro_line|#include &lt;net/icmp.h&gt;
macro_line|#include &lt;net/udp.h&gt;
macro_line|#include &lt;net/raw.h&gt;
macro_line|#include &lt;linux/notifier.h&gt;
macro_line|#include &lt;linux/if_arp.h&gt;
macro_line|#include &lt;linux/netfilter_ipv4.h&gt;
macro_line|#include &lt;net/ipip.h&gt;
macro_line|#include &lt;net/checksum.h&gt;
macro_line|#include &lt;net/ip_mp_alg.h&gt;
DECL|struct|multipath_device
r_struct
id|multipath_device
(brace
DECL|member|ifi
r_int
id|ifi
suffix:semicolon
multiline_comment|/* interface index of device */
DECL|member|usecount
id|atomic_t
id|usecount
suffix:semicolon
DECL|member|allocated
r_int
id|allocated
suffix:semicolon
)brace
suffix:semicolon
DECL|macro|MULTIPATH_MAX_DEVICECANDIDATES
mdefine_line|#define MULTIPATH_MAX_DEVICECANDIDATES 10
DECL|variable|state
r_static
r_struct
id|multipath_device
id|state
(braket
id|MULTIPATH_MAX_DEVICECANDIDATES
)braket
suffix:semicolon
DECL|variable|state_lock
r_static
id|spinlock_t
id|state_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
DECL|variable|registered_dev_notifier
r_static
r_int
id|registered_dev_notifier
op_assign
l_int|0
suffix:semicolon
DECL|variable|last_selection
r_static
r_struct
id|rtable
op_star
id|last_selection
op_assign
l_int|NULL
suffix:semicolon
DECL|macro|RTprint
mdefine_line|#define RTprint(a...)&t;
singleline_comment|// printk(KERN_DEBUG a)
DECL|function|__multipath_findslot
r_static
r_int
r_inline
id|__multipath_findslot
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MULTIPATH_MAX_DEVICECANDIDATES
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|state
(braket
id|i
)braket
dot
id|allocated
op_eq
l_int|0
)paren
r_return
id|i
suffix:semicolon
)brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
DECL|function|__multipath_finddev
r_static
r_int
r_inline
id|__multipath_finddev
c_func
(paren
r_int
id|ifindex
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MULTIPATH_MAX_DEVICECANDIDATES
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|state
(braket
id|i
)braket
dot
id|allocated
op_ne
l_int|0
op_logical_and
id|state
(braket
id|i
)braket
dot
id|ifi
op_eq
id|ifindex
)paren
r_return
id|i
suffix:semicolon
)brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
DECL|function|multipath_dev_event
r_static
r_int
id|multipath_dev_event
c_func
(paren
r_struct
id|notifier_block
op_star
id|this
comma
r_int
r_int
id|event
comma
r_void
op_star
id|ptr
)paren
(brace
r_struct
id|net_device
op_star
id|dev
op_assign
id|ptr
suffix:semicolon
r_int
id|devidx
suffix:semicolon
r_switch
c_cond
(paren
id|event
)paren
(brace
r_case
id|NETDEV_UNREGISTER
suffix:colon
r_case
id|NETDEV_DOWN
suffix:colon
id|spin_lock_bh
c_func
(paren
op_amp
id|state_lock
)paren
suffix:semicolon
id|devidx
op_assign
id|__multipath_finddev
c_func
(paren
id|dev-&gt;ifindex
)paren
suffix:semicolon
r_if
c_cond
(paren
id|devidx
op_ne
op_minus
l_int|1
)paren
(brace
id|state
(braket
id|devidx
)braket
dot
id|allocated
op_assign
l_int|0
suffix:semicolon
id|state
(braket
id|devidx
)braket
dot
id|ifi
op_assign
l_int|0
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|state
(braket
id|devidx
)braket
dot
id|usecount
comma
l_int|0
)paren
suffix:semicolon
id|RTprint
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: successfully removed device &quot;
"&bslash;"
l_string|&quot;with index %d&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|devidx
)paren
suffix:semicolon
)brace
r_else
(brace
id|RTprint
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: Device not relevant for &quot;
"&bslash;"
l_string|&quot; multipath: %d&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|devidx
)paren
suffix:semicolon
)brace
id|spin_unlock_bh
c_func
(paren
op_amp
id|state_lock
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
suffix:semicolon
r_return
id|NOTIFY_DONE
suffix:semicolon
)brace
DECL|variable|multipath_dev_notifier
r_struct
id|notifier_block
id|multipath_dev_notifier
op_assign
(brace
dot
id|notifier_call
op_assign
id|multipath_dev_event
comma
)brace
suffix:semicolon
DECL|function|__multipath_remove
r_void
id|__multipath_remove
c_func
(paren
r_struct
id|rtable
op_star
id|rt
)paren
(brace
r_if
c_cond
(paren
id|last_selection
op_eq
id|rt
)paren
id|last_selection
op_assign
l_int|NULL
suffix:semicolon
)brace
DECL|function|__multipath_safe_inc
r_void
id|__multipath_safe_inc
c_func
(paren
id|atomic_t
op_star
id|usecount
)paren
(brace
r_int
id|n
suffix:semicolon
id|atomic_inc
c_func
(paren
id|usecount
)paren
suffix:semicolon
id|n
op_assign
id|atomic_read
c_func
(paren
id|usecount
)paren
suffix:semicolon
r_if
c_cond
(paren
id|n
op_le
l_int|0
)paren
(brace
r_int
id|i
suffix:semicolon
id|RTprint
c_func
(paren
l_string|&quot;%s: detected overflow, now ill will reset all &quot;
"&bslash;"
l_string|&quot;usecounts&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
id|spin_lock_bh
c_func
(paren
op_amp
id|state_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MULTIPATH_MAX_DEVICECANDIDATES
suffix:semicolon
id|i
op_increment
)paren
id|atomic_set
c_func
(paren
op_amp
id|state
(braket
id|i
)braket
dot
id|usecount
comma
l_int|0
)paren
suffix:semicolon
id|spin_unlock_bh
c_func
(paren
op_amp
id|state_lock
)paren
suffix:semicolon
)brace
)brace
DECL|function|__multipath_selectroute
r_void
id|__multipath_selectroute
c_func
(paren
r_const
r_struct
id|flowi
op_star
id|flp
comma
r_struct
id|rtable
op_star
id|first
comma
r_struct
id|rtable
op_star
op_star
id|rp
)paren
(brace
r_struct
id|rtable
op_star
id|nh
comma
op_star
id|result
comma
op_star
id|cur_min
suffix:semicolon
r_int
id|min_usecount
op_assign
op_minus
l_int|1
suffix:semicolon
r_int
id|devidx
op_assign
op_minus
l_int|1
suffix:semicolon
r_int
id|cur_min_devidx
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* register a notifier to stay informed about dying devices */
r_if
c_cond
(paren
op_logical_neg
id|registered_dev_notifier
)paren
(brace
id|registered_dev_notifier
op_assign
l_int|1
suffix:semicolon
id|register_netdevice_notifier
c_func
(paren
op_amp
id|multipath_dev_notifier
)paren
suffix:semicolon
)brace
multiline_comment|/* if necessary and possible utilize the old alternative */
r_if
c_cond
(paren
(paren
id|flp-&gt;flags
op_amp
id|FLOWI_FLAG_MULTIPATHOLDROUTE
)paren
op_ne
l_int|0
op_logical_and
id|last_selection
op_ne
l_int|NULL
)paren
(brace
id|RTprint
c_func
(paren
id|KERN_CRIT
l_string|&quot;%s: holding route &bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
id|result
op_assign
id|last_selection
suffix:semicolon
op_star
id|rp
op_assign
id|result
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* 1. make sure all alt. nexthops have the same GC related data */
multiline_comment|/* 2. determine the new candidate to be returned */
id|result
op_assign
l_int|NULL
suffix:semicolon
id|cur_min
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|nh
op_assign
id|rcu_dereference
c_func
(paren
id|first
)paren
suffix:semicolon
id|nh
suffix:semicolon
id|nh
op_assign
id|rcu_dereference
c_func
(paren
id|nh-&gt;u.rt_next
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|nh-&gt;u.dst.flags
op_amp
id|DST_BALANCED
)paren
op_ne
l_int|0
op_logical_and
id|multipath_comparekeys
c_func
(paren
op_amp
id|nh-&gt;fl
comma
id|flp
)paren
)paren
(brace
r_int
id|nh_ifidx
op_assign
id|nh-&gt;u.dst.dev-&gt;ifindex
suffix:semicolon
id|nh-&gt;u.dst.lastuse
op_assign
id|jiffies
suffix:semicolon
id|nh-&gt;u.dst.__use
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
l_int|NULL
)paren
r_continue
suffix:semicolon
multiline_comment|/* search for the output interface */
multiline_comment|/* this is not SMP safe, only add/remove are&n;&t;&t;&t; * SMP safe as wrong usecount updates have no big&n;&t;&t;&t; * impact&n;&t;&t;&t; */
id|devidx
op_assign
id|__multipath_finddev
c_func
(paren
id|nh_ifidx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|devidx
op_eq
op_minus
l_int|1
)paren
(brace
multiline_comment|/* add the interface to the array &n;&t;&t;&t;&t; * SMP safe&n;&t;&t;&t;&t; */
id|spin_lock_bh
c_func
(paren
op_amp
id|state_lock
)paren
suffix:semicolon
multiline_comment|/* due to SMP: search again */
id|devidx
op_assign
id|__multipath_finddev
c_func
(paren
id|nh_ifidx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|devidx
op_eq
op_minus
l_int|1
)paren
(brace
multiline_comment|/* add entry for device */
id|devidx
op_assign
id|__multipath_findslot
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|devidx
op_eq
op_minus
l_int|1
)paren
(brace
multiline_comment|/* unlikely but possible */
id|RTprint
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: &quot;
"&bslash;"
l_string|&quot;out of space&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|state
(braket
id|devidx
)braket
dot
id|allocated
op_assign
l_int|1
suffix:semicolon
id|state
(braket
id|devidx
)braket
dot
id|ifi
op_assign
id|nh_ifidx
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|state
(braket
id|devidx
)braket
dot
id|usecount
comma
l_int|0
)paren
suffix:semicolon
id|min_usecount
op_assign
l_int|0
suffix:semicolon
id|RTprint
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: created &quot;
"&bslash;"
l_string|&quot; for &quot;
"&bslash;"
l_string|&quot;device %d and &quot;
"&bslash;"
l_string|&quot;min_usecount &quot;
"&bslash;"
l_string|&quot; == -1&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|nh_ifidx
)paren
suffix:semicolon
)brace
id|spin_unlock_bh
c_func
(paren
op_amp
id|state_lock
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|min_usecount
op_eq
l_int|0
)paren
(brace
multiline_comment|/* if the device has not been used it is&n;&t;&t;&t;&t; * the primary target&n;&t;&t;&t;&t; */
id|RTprint
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: now setting &quot;
"&bslash;"
l_string|&quot;result to device %d&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|nh_ifidx
)paren
suffix:semicolon
id|__multipath_safe_inc
c_func
(paren
op_amp
id|state
(braket
id|devidx
)braket
dot
id|usecount
)paren
suffix:semicolon
id|result
op_assign
id|nh
suffix:semicolon
)brace
r_else
(brace
r_int
id|count
op_assign
id|atomic_read
c_func
(paren
op_amp
id|state
(braket
id|devidx
)braket
dot
id|usecount
)paren
suffix:semicolon
r_if
c_cond
(paren
id|min_usecount
op_eq
op_minus
l_int|1
op_logical_or
id|count
OL
id|min_usecount
)paren
(brace
id|cur_min
op_assign
id|nh
suffix:semicolon
id|cur_min_devidx
op_assign
id|devidx
suffix:semicolon
id|min_usecount
op_assign
id|count
suffix:semicolon
id|RTprint
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: found &quot;
"&bslash;"
l_string|&quot;device &quot;
"&bslash;"
l_string|&quot;%d with usecount == %d&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|nh_ifidx
comma
id|min_usecount
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|result
)paren
(brace
r_if
c_cond
(paren
id|cur_min
)paren
(brace
id|RTprint
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: index of device in state &quot;
"&bslash;"
l_string|&quot;array: %d&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|cur_min_devidx
)paren
suffix:semicolon
id|__multipath_safe_inc
c_func
(paren
op_amp
id|state
(braket
id|cur_min_devidx
)braket
dot
id|usecount
)paren
suffix:semicolon
id|result
op_assign
id|cur_min
suffix:semicolon
)brace
r_else
(brace
id|RTprint
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: utilized first&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
id|result
op_assign
id|first
suffix:semicolon
)brace
)brace
r_else
(brace
id|RTprint
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: utilize result: found device &quot;
"&bslash;"
l_string|&quot;%d with usecount == %d&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|result-&gt;u.dst.dev-&gt;ifindex
comma
id|min_usecount
)paren
suffix:semicolon
)brace
op_star
id|rp
op_assign
id|result
suffix:semicolon
id|last_selection
op_assign
id|result
suffix:semicolon
)brace
eof
