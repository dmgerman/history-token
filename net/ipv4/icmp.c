multiline_comment|/*&n; *&t;NET3:&t;Implementation of the ICMP protocol layer.&n; *&n; *&t;&t;Alan Cox, &lt;alan@redhat.com&gt;&n; *&n; *&t;Version: $Id: icmp.c,v 1.85 2002/02/01 22:01:03 davem Exp $&n; *&n; *&t;This program is free software; you can redistribute it and/or&n; *&t;modify it under the terms of the GNU General Public License&n; *&t;as published by the Free Software Foundation; either version&n; *&t;2 of the License, or (at your option) any later version.&n; *&n; *&t;Some of the function names and the icmp unreach table for this&n; *&t;module were derived from [icmp.c 1.0.11 06/02/93] by&n; *&t;Ross Biro, Fred N. van Kempen, Mark Evans, Alan Cox, Gerhard Koerting.&n; *&t;Other than that this module is a complete rewrite.&n; *&n; *&t;Fixes:&n; *&t;Clemens Fruhwirth&t;:&t;introduce global icmp rate limiting&n; *&t;&t;&t;&t;&t;with icmp type masking ability instead&n; *&t;&t;&t;&t;&t;of broken per type icmp timeouts.&n; *&t;&t;Mike Shaver&t;:&t;RFC1122 checks.&n; *&t;&t;Alan Cox&t;:&t;Multicast ping reply as self.&n; *&t;&t;Alan Cox&t;:&t;Fix atomicity lockup in ip_build_xmit&n; *&t;&t;&t;&t;&t;call.&n; *&t;&t;Alan Cox&t;:&t;Added 216,128 byte paths to the MTU&n; *&t;&t;&t;&t;&t;code.&n; *&t;&t;Martin Mares&t;:&t;RFC1812 checks.&n; *&t;&t;Martin Mares&t;:&t;Can be configured to follow redirects&n; *&t;&t;&t;&t;&t;if acting as a router _without_ a&n; *&t;&t;&t;&t;&t;routing protocol (RFC 1812).&n; *&t;&t;Martin Mares&t;:&t;Echo requests may be configured to&n; *&t;&t;&t;&t;&t;be ignored (RFC 1812).&n; *&t;&t;Martin Mares&t;:&t;Limitation of ICMP error message&n; *&t;&t;&t;&t;&t;transmit rate (RFC 1812).&n; *&t;&t;Martin Mares&t;:&t;TOS and Precedence set correctly&n; *&t;&t;&t;&t;&t;(RFC 1812).&n; *&t;&t;Martin Mares&t;:&t;Now copying as much data from the&n; *&t;&t;&t;&t;&t;original packet as we can without&n; *&t;&t;&t;&t;&t;exceeding 576 bytes (RFC 1812).&n; *&t;Willy Konynenberg&t;:&t;Transparent proxying support.&n; *&t;&t;Keith Owens&t;:&t;RFC1191 correction for 4.2BSD based&n; *&t;&t;&t;&t;&t;path MTU bug.&n; *&t;&t;Thomas Quinot&t;:&t;ICMP Dest Unreach codes up to 15 are&n; *&t;&t;&t;&t;&t;valid (RFC 1812).&n; *&t;&t;Andi Kleen&t;:&t;Check all packet lengths properly&n; *&t;&t;&t;&t;&t;and moved all kfree_skb() up to&n; *&t;&t;&t;&t;&t;icmp_rcv.&n; *&t;&t;Andi Kleen&t;:&t;Move the rate limit bookkeeping&n; *&t;&t;&t;&t;&t;into the dest entry and use a token&n; *&t;&t;&t;&t;&t;bucket filter (thanks to ANK). Make&n; *&t;&t;&t;&t;&t;the rates sysctl configurable.&n; *&t;&t;Yu Tianli&t;:&t;Fixed two ugly bugs in icmp_send&n; *&t;&t;&t;&t;&t;- IP option length was accounted wrongly&n; *&t;&t;&t;&t;&t;- ICMP header length was not accounted&n; *&t;&t;&t;&t;&t;  at all.&n; *              Tristan Greaves :       Added sysctl option to ignore bogus&n; *              &t;&t;&t;broadcast responses from broken routers.&n; *&n; * To Fix:&n; *&n; *&t;- Should use skb_pull() instead of all the manual checking.&n; *&t;  This would also greatly simply some upper layer error handlers. --AK&n; *&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/jiffies.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/socket.h&gt;
macro_line|#include &lt;linux/in.h&gt;
macro_line|#include &lt;linux/inet.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/netfilter_ipv4.h&gt;
macro_line|#include &lt;net/snmp.h&gt;
macro_line|#include &lt;net/ip.h&gt;
macro_line|#include &lt;net/route.h&gt;
macro_line|#include &lt;net/protocol.h&gt;
macro_line|#include &lt;net/icmp.h&gt;
macro_line|#include &lt;net/tcp.h&gt;
macro_line|#include &lt;net/udp.h&gt;
macro_line|#include &lt;net/raw.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;net/sock.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;net/checksum.h&gt;
multiline_comment|/*&n; *&t;Build xmit assembly blocks&n; */
DECL|struct|icmp_bxm
r_struct
id|icmp_bxm
(brace
DECL|member|skb
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
DECL|member|offset
r_int
id|offset
suffix:semicolon
DECL|member|data_len
r_int
id|data_len
suffix:semicolon
r_struct
(brace
DECL|member|icmph
r_struct
id|icmphdr
id|icmph
suffix:semicolon
DECL|member|times
id|__u32
id|times
(braket
l_int|3
)braket
suffix:semicolon
DECL|member|data
)brace
id|data
suffix:semicolon
DECL|member|head_len
r_int
id|head_len
suffix:semicolon
DECL|member|replyopts
r_struct
id|ip_options
id|replyopts
suffix:semicolon
DECL|member|optbuf
r_int
r_char
id|optbuf
(braket
l_int|40
)braket
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; *&t;Statistics&n; */
id|DEFINE_SNMP_STAT
c_func
(paren
r_struct
id|icmp_mib
comma
id|icmp_statistics
)paren
suffix:semicolon
multiline_comment|/* An array of errno for error messages from dest unreach. */
multiline_comment|/* RFC 1122: 3.2.2.1 States that NET_UNREACH, HOST_UNREACH and SR_FAILED MUST be considered &squot;transient errs&squot;. */
DECL|variable|icmp_err_convert
r_struct
id|icmp_err
id|icmp_err_convert
(braket
)braket
op_assign
(brace
(brace
dot
id|errno
op_assign
id|ENETUNREACH
comma
multiline_comment|/* ICMP_NET_UNREACH */
dot
id|fatal
op_assign
l_int|0
comma
)brace
comma
(brace
dot
id|errno
op_assign
id|EHOSTUNREACH
comma
multiline_comment|/* ICMP_HOST_UNREACH */
dot
id|fatal
op_assign
l_int|0
comma
)brace
comma
(brace
dot
id|errno
op_assign
id|ENOPROTOOPT
multiline_comment|/* ICMP_PROT_UNREACH */
comma
dot
id|fatal
op_assign
l_int|1
comma
)brace
comma
(brace
dot
id|errno
op_assign
id|ECONNREFUSED
comma
multiline_comment|/* ICMP_PORT_UNREACH */
dot
id|fatal
op_assign
l_int|1
comma
)brace
comma
(brace
dot
id|errno
op_assign
id|EMSGSIZE
comma
multiline_comment|/* ICMP_FRAG_NEEDED */
dot
id|fatal
op_assign
l_int|0
comma
)brace
comma
(brace
dot
id|errno
op_assign
id|EOPNOTSUPP
comma
multiline_comment|/* ICMP_SR_FAILED */
dot
id|fatal
op_assign
l_int|0
comma
)brace
comma
(brace
dot
id|errno
op_assign
id|ENETUNREACH
comma
multiline_comment|/* ICMP_NET_UNKNOWN */
dot
id|fatal
op_assign
l_int|1
comma
)brace
comma
(brace
dot
id|errno
op_assign
id|EHOSTDOWN
comma
multiline_comment|/* ICMP_HOST_UNKNOWN */
dot
id|fatal
op_assign
l_int|1
comma
)brace
comma
(brace
dot
id|errno
op_assign
id|ENONET
comma
multiline_comment|/* ICMP_HOST_ISOLATED */
dot
id|fatal
op_assign
l_int|1
comma
)brace
comma
(brace
dot
id|errno
op_assign
id|ENETUNREACH
comma
multiline_comment|/* ICMP_NET_ANO&t;*/
dot
id|fatal
op_assign
l_int|1
comma
)brace
comma
(brace
dot
id|errno
op_assign
id|EHOSTUNREACH
comma
multiline_comment|/* ICMP_HOST_ANO */
dot
id|fatal
op_assign
l_int|1
comma
)brace
comma
(brace
dot
id|errno
op_assign
id|ENETUNREACH
comma
multiline_comment|/* ICMP_NET_UNR_TOS */
dot
id|fatal
op_assign
l_int|0
comma
)brace
comma
(brace
dot
id|errno
op_assign
id|EHOSTUNREACH
comma
multiline_comment|/* ICMP_HOST_UNR_TOS */
dot
id|fatal
op_assign
l_int|0
comma
)brace
comma
(brace
dot
id|errno
op_assign
id|EHOSTUNREACH
comma
multiline_comment|/* ICMP_PKT_FILTERED */
dot
id|fatal
op_assign
l_int|1
comma
)brace
comma
(brace
dot
id|errno
op_assign
id|EHOSTUNREACH
comma
multiline_comment|/* ICMP_PREC_VIOLATION */
dot
id|fatal
op_assign
l_int|1
comma
)brace
comma
(brace
dot
id|errno
op_assign
id|EHOSTUNREACH
comma
multiline_comment|/* ICMP_PREC_CUTOFF */
dot
id|fatal
op_assign
l_int|1
comma
)brace
comma
)brace
suffix:semicolon
multiline_comment|/* Control parameters for ECHO replies. */
DECL|variable|sysctl_icmp_echo_ignore_all
r_int
id|sysctl_icmp_echo_ignore_all
suffix:semicolon
DECL|variable|sysctl_icmp_echo_ignore_broadcasts
r_int
id|sysctl_icmp_echo_ignore_broadcasts
suffix:semicolon
multiline_comment|/* Control parameter - ignore bogus broadcast responses? */
DECL|variable|sysctl_icmp_ignore_bogus_error_responses
r_int
id|sysctl_icmp_ignore_bogus_error_responses
suffix:semicolon
multiline_comment|/*&n; * &t;Configurable global rate limit.&n; *&n; *&t;ratelimit defines tokens/packet consumed for dst-&gt;rate_token bucket&n; *&t;ratemask defines which icmp types are ratelimited by setting&n; * &t;it&squot;s bit position.&n; *&n; *&t;default:&n; *&t;dest unreachable (3), source quench (4),&n; *&t;time exceeded (11), parameter problem (12)&n; */
DECL|variable|sysctl_icmp_ratelimit
r_int
id|sysctl_icmp_ratelimit
op_assign
l_int|1
op_star
id|HZ
suffix:semicolon
DECL|variable|sysctl_icmp_ratemask
r_int
id|sysctl_icmp_ratemask
op_assign
l_int|0x1818
suffix:semicolon
multiline_comment|/*&n; *&t;ICMP control array. This specifies what to do with each ICMP.&n; */
DECL|struct|icmp_control
r_struct
id|icmp_control
(brace
DECL|member|output_entry
r_int
id|output_entry
suffix:semicolon
multiline_comment|/* Field for increment on output */
DECL|member|input_entry
r_int
id|input_entry
suffix:semicolon
multiline_comment|/* Field for increment on input */
DECL|member|handler
r_void
(paren
op_star
id|handler
)paren
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
suffix:semicolon
DECL|member|error
r_int
id|error
suffix:semicolon
multiline_comment|/* This ICMP is classed as an error message */
)brace
suffix:semicolon
DECL|variable|icmp_pointers
r_static
r_struct
id|icmp_control
id|icmp_pointers
(braket
id|NR_ICMP_TYPES
op_plus
l_int|1
)braket
suffix:semicolon
multiline_comment|/*&n; *&t;The ICMP socket(s). This is the most convenient way to flow control&n; *&t;our ICMP output as well as maintain a clean interface throughout&n; *&t;all layers. All Socketless IP sends will soon be gone.&n; *&n; *&t;On SMP we have one ICMP socket per-cpu.&n; */
r_static
id|DEFINE_PER_CPU
c_func
(paren
r_struct
id|socket
op_star
comma
id|__icmp_socket
)paren
op_assign
l_int|NULL
suffix:semicolon
DECL|macro|icmp_socket
mdefine_line|#define icmp_socket&t;__get_cpu_var(__icmp_socket)
DECL|function|icmp_xmit_lock
r_static
id|__inline__
r_int
id|icmp_xmit_lock
c_func
(paren
r_void
)paren
(brace
id|local_bh_disable
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|spin_trylock
c_func
(paren
op_amp
id|icmp_socket-&gt;sk-&gt;sk_lock.slock
)paren
)paren
)paren
(brace
multiline_comment|/* This can happen if the output path signals a&n;&t;&t; * dst_link_failure() for an outgoing ICMP packet.&n;&t;&t; */
id|local_bh_enable
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|icmp_xmit_unlock
r_static
r_void
id|icmp_xmit_unlock
c_func
(paren
r_void
)paren
(brace
id|spin_unlock_bh
c_func
(paren
op_amp
id|icmp_socket-&gt;sk-&gt;sk_lock.slock
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Send an ICMP frame.&n; */
multiline_comment|/*&n; *&t;Check transmit rate limitation for given message.&n; *&t;The rate information is held in the destination cache now.&n; *&t;This function is generic and could be used for other purposes&n; *&t;too. It uses a Token bucket filter as suggested by Alexey Kuznetsov.&n; *&n; *&t;Note that the same dst_entry fields are modified by functions in&n; *&t;route.c too, but these work for packet destinations while xrlim_allow&n; *&t;works for icmp destinations. This means the rate limiting information&n; *&t;for one &quot;ip object&quot; is shared - and these ICMPs are twice limited:&n; *&t;by source and by destination.&n; *&n; *&t;RFC 1812: 4.3.2.8 SHOULD be able to limit error message rate&n; *&t;&t;&t;  SHOULD allow setting of rate limits&n; *&n; * &t;Shared between ICMPv4 and ICMPv6.&n; */
DECL|macro|XRLIM_BURST_FACTOR
mdefine_line|#define XRLIM_BURST_FACTOR 6
DECL|function|xrlim_allow
r_int
id|xrlim_allow
c_func
(paren
r_struct
id|dst_entry
op_star
id|dst
comma
r_int
id|timeout
)paren
(brace
r_int
r_int
id|now
suffix:semicolon
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
id|now
op_assign
id|jiffies
suffix:semicolon
id|dst-&gt;rate_tokens
op_add_assign
id|now
op_minus
id|dst-&gt;rate_last
suffix:semicolon
id|dst-&gt;rate_last
op_assign
id|now
suffix:semicolon
r_if
c_cond
(paren
id|dst-&gt;rate_tokens
OG
id|XRLIM_BURST_FACTOR
op_star
id|timeout
)paren
id|dst-&gt;rate_tokens
op_assign
id|XRLIM_BURST_FACTOR
op_star
id|timeout
suffix:semicolon
r_if
c_cond
(paren
id|dst-&gt;rate_tokens
op_ge
id|timeout
)paren
(brace
id|dst-&gt;rate_tokens
op_sub_assign
id|timeout
suffix:semicolon
id|rc
op_assign
l_int|1
suffix:semicolon
)brace
r_return
id|rc
suffix:semicolon
)brace
DECL|function|icmpv4_xrlim_allow
r_static
r_inline
r_int
id|icmpv4_xrlim_allow
c_func
(paren
r_struct
id|rtable
op_star
id|rt
comma
r_int
id|type
comma
r_int
id|code
)paren
(brace
r_struct
id|dst_entry
op_star
id|dst
op_assign
op_amp
id|rt-&gt;u.dst
suffix:semicolon
r_int
id|rc
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|type
OG
id|NR_ICMP_TYPES
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* Don&squot;t limit PMTU discovery. */
r_if
c_cond
(paren
id|type
op_eq
id|ICMP_DEST_UNREACH
op_logical_and
id|code
op_eq
id|ICMP_FRAG_NEEDED
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* No rate limit on loopback */
r_if
c_cond
(paren
id|dst-&gt;dev
op_logical_and
(paren
id|dst-&gt;dev-&gt;flags
op_amp
id|IFF_LOOPBACK
)paren
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* Limit if icmp type is enabled in ratemask. */
r_if
c_cond
(paren
(paren
l_int|1
op_lshift
id|type
)paren
op_amp
id|sysctl_icmp_ratemask
)paren
id|rc
op_assign
id|xrlim_allow
c_func
(paren
id|dst
comma
id|sysctl_icmp_ratelimit
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Maintain the counters used in the SNMP statistics for outgoing ICMP&n; */
DECL|function|icmp_out_count
r_static
r_void
id|icmp_out_count
c_func
(paren
r_int
id|type
)paren
(brace
r_if
c_cond
(paren
id|type
op_le
id|NR_ICMP_TYPES
)paren
(brace
id|ICMP_INC_STATS
c_func
(paren
id|icmp_pointers
(braket
id|type
)braket
dot
id|output_entry
)paren
suffix:semicolon
id|ICMP_INC_STATS
c_func
(paren
id|ICMP_MIB_OUTMSGS
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *&t;Checksum each fragment, and on the first include the headers and final&n; *&t;checksum.&n; */
DECL|function|icmp_glue_bits
r_int
id|icmp_glue_bits
c_func
(paren
r_void
op_star
id|from
comma
r_char
op_star
id|to
comma
r_int
id|offset
comma
r_int
id|len
comma
r_int
id|odd
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|icmp_bxm
op_star
id|icmp_param
op_assign
(paren
r_struct
id|icmp_bxm
op_star
)paren
id|from
suffix:semicolon
r_int
r_int
id|csum
suffix:semicolon
id|csum
op_assign
id|skb_copy_and_csum_bits
c_func
(paren
id|icmp_param-&gt;skb
comma
id|icmp_param-&gt;offset
op_plus
id|offset
comma
id|to
comma
id|len
comma
l_int|0
)paren
suffix:semicolon
id|skb-&gt;csum
op_assign
id|csum_block_add
c_func
(paren
id|skb-&gt;csum
comma
id|csum
comma
id|odd
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|icmp_push_reply
r_static
r_void
id|icmp_push_reply
c_func
(paren
r_struct
id|icmp_bxm
op_star
id|icmp_param
comma
r_struct
id|ipcm_cookie
op_star
id|ipc
comma
r_struct
id|rtable
op_star
id|rt
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
id|ip_append_data
c_func
(paren
id|icmp_socket-&gt;sk
comma
id|icmp_glue_bits
comma
id|icmp_param
comma
id|icmp_param-&gt;data_len
op_plus
id|icmp_param-&gt;head_len
comma
id|icmp_param-&gt;head_len
comma
id|ipc
comma
id|rt
comma
id|MSG_DONTWAIT
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|skb
op_assign
id|skb_peek
c_func
(paren
op_amp
id|icmp_socket-&gt;sk-&gt;sk_write_queue
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
r_struct
id|icmphdr
op_star
id|icmph
op_assign
id|skb-&gt;h.icmph
suffix:semicolon
r_int
r_int
id|csum
op_assign
l_int|0
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb1
suffix:semicolon
id|skb_queue_walk
c_func
(paren
op_amp
id|icmp_socket-&gt;sk-&gt;sk_write_queue
comma
id|skb1
)paren
(brace
id|csum
op_assign
id|csum_add
c_func
(paren
id|csum
comma
id|skb1-&gt;csum
)paren
suffix:semicolon
)brace
id|csum
op_assign
id|csum_partial_copy_nocheck
c_func
(paren
(paren
r_void
op_star
)paren
op_amp
id|icmp_param-&gt;data
comma
(paren
r_char
op_star
)paren
id|icmph
comma
id|icmp_param-&gt;head_len
comma
id|csum
)paren
suffix:semicolon
id|icmph-&gt;checksum
op_assign
id|csum_fold
c_func
(paren
id|csum
)paren
suffix:semicolon
id|skb-&gt;ip_summed
op_assign
id|CHECKSUM_NONE
suffix:semicolon
id|ip_push_pending_frames
c_func
(paren
id|icmp_socket-&gt;sk
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *&t;Driving logic for building and sending ICMP messages.&n; */
DECL|function|icmp_reply
r_static
r_void
id|icmp_reply
c_func
(paren
r_struct
id|icmp_bxm
op_star
id|icmp_param
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|sock
op_star
id|sk
op_assign
id|icmp_socket-&gt;sk
suffix:semicolon
r_struct
id|inet_opt
op_star
id|inet
op_assign
id|inet_sk
c_func
(paren
id|sk
)paren
suffix:semicolon
r_struct
id|ipcm_cookie
id|ipc
suffix:semicolon
r_struct
id|rtable
op_star
id|rt
op_assign
(paren
r_struct
id|rtable
op_star
)paren
id|skb-&gt;dst
suffix:semicolon
id|u32
id|daddr
suffix:semicolon
r_if
c_cond
(paren
id|ip_options_echo
c_func
(paren
op_amp
id|icmp_param-&gt;replyopts
comma
id|skb
)paren
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|icmp_xmit_lock
c_func
(paren
)paren
)paren
r_return
suffix:semicolon
id|icmp_param-&gt;data.icmph.checksum
op_assign
l_int|0
suffix:semicolon
id|icmp_out_count
c_func
(paren
id|icmp_param-&gt;data.icmph.type
)paren
suffix:semicolon
id|inet-&gt;tos
op_assign
id|skb-&gt;nh.iph-&gt;tos
suffix:semicolon
id|daddr
op_assign
id|ipc.addr
op_assign
id|rt-&gt;rt_src
suffix:semicolon
id|ipc.opt
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|icmp_param-&gt;replyopts.optlen
)paren
(brace
id|ipc.opt
op_assign
op_amp
id|icmp_param-&gt;replyopts
suffix:semicolon
r_if
c_cond
(paren
id|ipc.opt-&gt;srr
)paren
id|daddr
op_assign
id|icmp_param-&gt;replyopts.faddr
suffix:semicolon
)brace
(brace
r_struct
id|flowi
id|fl
op_assign
(brace
dot
id|nl_u
op_assign
(brace
dot
id|ip4_u
op_assign
(brace
dot
id|daddr
op_assign
id|daddr
comma
dot
id|saddr
op_assign
id|rt-&gt;rt_spec_dst
comma
dot
id|tos
op_assign
id|RT_TOS
c_func
(paren
id|skb-&gt;nh.iph-&gt;tos
)paren
)brace
)brace
comma
dot
id|proto
op_assign
id|IPPROTO_ICMP
)brace
suffix:semicolon
r_if
c_cond
(paren
id|ip_route_output_key
c_func
(paren
op_amp
id|rt
comma
op_amp
id|fl
)paren
)paren
r_goto
id|out_unlock
suffix:semicolon
)brace
r_if
c_cond
(paren
id|icmpv4_xrlim_allow
c_func
(paren
id|rt
comma
id|icmp_param-&gt;data.icmph.type
comma
id|icmp_param-&gt;data.icmph.code
)paren
)paren
id|icmp_push_reply
c_func
(paren
id|icmp_param
comma
op_amp
id|ipc
comma
id|rt
)paren
suffix:semicolon
id|ip_rt_put
c_func
(paren
id|rt
)paren
suffix:semicolon
id|out_unlock
suffix:colon
id|icmp_xmit_unlock
c_func
(paren
)paren
suffix:semicolon
id|out
suffix:colon
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Send an ICMP message in response to a situation&n; *&n; *&t;RFC 1122: 3.2.2&t;MUST send at least the IP header and 8 bytes of header.&n; *&t;&t;  MAY send more (we do).&n; *&t;&t;&t;MUST NOT change this header information.&n; *&t;&t;&t;MUST NOT reply to a multicast/broadcast IP address.&n; *&t;&t;&t;MUST NOT reply to a multicast/broadcast MAC address.&n; *&t;&t;&t;MUST reply to only the first fragment.&n; */
DECL|function|icmp_send
r_void
id|icmp_send
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb_in
comma
r_int
id|type
comma
r_int
id|code
comma
id|u32
id|info
)paren
(brace
r_struct
id|iphdr
op_star
id|iph
suffix:semicolon
r_int
id|room
suffix:semicolon
r_struct
id|icmp_bxm
id|icmp_param
suffix:semicolon
r_struct
id|rtable
op_star
id|rt
op_assign
(paren
r_struct
id|rtable
op_star
)paren
id|skb_in-&gt;dst
suffix:semicolon
r_struct
id|ipcm_cookie
id|ipc
suffix:semicolon
id|u32
id|saddr
suffix:semicolon
id|u8
id|tos
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rt
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Find the original header. It is expected to be valid, of course.&n;&t; *&t;Check this, icmp_send is called from the most obscure devices&n;&t; *&t;sometimes.&n;&t; */
id|iph
op_assign
id|skb_in-&gt;nh.iph
suffix:semicolon
r_if
c_cond
(paren
(paren
id|u8
op_star
)paren
id|iph
template_param
id|skb_in-&gt;tail
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/*&n;&t; *&t;No replies to physical multicast/broadcast&n;&t; */
r_if
c_cond
(paren
id|skb_in-&gt;pkt_type
op_ne
id|PACKET_HOST
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Now check at the protocol level&n;&t; */
r_if
c_cond
(paren
id|rt-&gt;rt_flags
op_amp
(paren
id|RTCF_BROADCAST
op_or
id|RTCF_MULTICAST
)paren
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Only reply to fragment 0. We byte re-order the constant&n;&t; *&t;mask for efficiency.&n;&t; */
r_if
c_cond
(paren
id|iph-&gt;frag_off
op_amp
id|htons
c_func
(paren
id|IP_OFFSET
)paren
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/*&n;&t; *&t;If we send an ICMP error to an ICMP error a mess would result..&n;&t; */
r_if
c_cond
(paren
id|icmp_pointers
(braket
id|type
)braket
dot
id|error
)paren
(brace
multiline_comment|/*&n;&t;&t; *&t;We are an error, check if we are replying to an&n;&t;&t; *&t;ICMP error&n;&t;&t; */
r_if
c_cond
(paren
id|iph-&gt;protocol
op_eq
id|IPPROTO_ICMP
)paren
(brace
id|u8
id|inner_type
suffix:semicolon
r_if
c_cond
(paren
id|skb_copy_bits
c_func
(paren
id|skb_in
comma
id|skb_in-&gt;nh.raw
op_plus
(paren
id|iph-&gt;ihl
op_lshift
l_int|2
)paren
op_plus
m_offsetof
(paren
r_struct
id|icmphdr
comma
id|type
)paren
op_minus
id|skb_in-&gt;data
comma
op_amp
id|inner_type
comma
l_int|1
)paren
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; *&t;Assume any unknown ICMP type is an error. This&n;&t;&t;&t; *&t;isn&squot;t specified by the RFC, but think about it..&n;&t;&t;&t; */
r_if
c_cond
(paren
id|inner_type
OG
id|NR_ICMP_TYPES
op_logical_or
id|icmp_pointers
(braket
id|inner_type
)braket
dot
id|error
)paren
r_goto
id|out
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|icmp_xmit_lock
c_func
(paren
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Construct source address and options.&n;&t; */
id|saddr
op_assign
id|iph-&gt;daddr
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|rt-&gt;rt_flags
op_amp
id|RTCF_LOCAL
)paren
)paren
id|saddr
op_assign
l_int|0
suffix:semicolon
id|tos
op_assign
id|icmp_pointers
(braket
id|type
)braket
dot
id|error
ques
c_cond
(paren
(paren
id|iph-&gt;tos
op_amp
id|IPTOS_TOS_MASK
)paren
op_or
id|IPTOS_PREC_INTERNETCONTROL
)paren
suffix:colon
id|iph-&gt;tos
suffix:semicolon
(brace
r_struct
id|flowi
id|fl
op_assign
(brace
dot
id|nl_u
op_assign
(brace
dot
id|ip4_u
op_assign
(brace
dot
id|daddr
op_assign
id|iph-&gt;saddr
comma
dot
id|saddr
op_assign
id|saddr
comma
dot
id|tos
op_assign
id|RT_TOS
c_func
(paren
id|tos
)paren
)brace
)brace
comma
dot
id|proto
op_assign
id|IPPROTO_ICMP
)brace
suffix:semicolon
r_if
c_cond
(paren
id|ip_route_output_key
c_func
(paren
op_amp
id|rt
comma
op_amp
id|fl
)paren
)paren
r_goto
id|out_unlock
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ip_options_echo
c_func
(paren
op_amp
id|icmp_param.replyopts
comma
id|skb_in
)paren
)paren
r_goto
id|ende
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Prepare data for ICMP header.&n;&t; */
id|icmp_param.data.icmph.type
op_assign
id|type
suffix:semicolon
id|icmp_param.data.icmph.code
op_assign
id|code
suffix:semicolon
id|icmp_param.data.icmph.un.gateway
op_assign
id|info
suffix:semicolon
id|icmp_param.data.icmph.checksum
op_assign
l_int|0
suffix:semicolon
id|icmp_param.skb
op_assign
id|skb_in
suffix:semicolon
id|icmp_param.offset
op_assign
id|skb_in-&gt;nh.raw
op_minus
id|skb_in-&gt;data
suffix:semicolon
id|icmp_out_count
c_func
(paren
id|icmp_param.data.icmph.type
)paren
suffix:semicolon
id|inet_sk
c_func
(paren
id|icmp_socket-&gt;sk
)paren
op_member_access_from_pointer
id|tos
op_assign
id|tos
suffix:semicolon
id|ipc.addr
op_assign
id|iph-&gt;saddr
suffix:semicolon
id|ipc.opt
op_assign
op_amp
id|icmp_param.replyopts
suffix:semicolon
r_if
c_cond
(paren
id|icmp_param.replyopts.srr
)paren
(brace
r_struct
id|flowi
id|fl
op_assign
(brace
dot
id|nl_u
op_assign
(brace
dot
id|ip4_u
op_assign
(brace
dot
id|daddr
op_assign
id|icmp_param.replyopts.faddr
comma
dot
id|saddr
op_assign
id|saddr
comma
dot
id|tos
op_assign
id|RT_TOS
c_func
(paren
id|tos
)paren
)brace
)brace
comma
dot
id|proto
op_assign
id|IPPROTO_ICMP
)brace
suffix:semicolon
id|ip_rt_put
c_func
(paren
id|rt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ip_route_output_key
c_func
(paren
op_amp
id|rt
comma
op_amp
id|fl
)paren
)paren
r_goto
id|out_unlock
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|icmpv4_xrlim_allow
c_func
(paren
id|rt
comma
id|type
comma
id|code
)paren
)paren
r_goto
id|ende
suffix:semicolon
multiline_comment|/* RFC says return as much as we can without exceeding 576 bytes. */
id|room
op_assign
id|dst_pmtu
c_func
(paren
op_amp
id|rt-&gt;u.dst
)paren
suffix:semicolon
r_if
c_cond
(paren
id|room
OG
l_int|576
)paren
id|room
op_assign
l_int|576
suffix:semicolon
id|room
op_sub_assign
r_sizeof
(paren
r_struct
id|iphdr
)paren
op_plus
id|icmp_param.replyopts.optlen
suffix:semicolon
id|room
op_sub_assign
r_sizeof
(paren
r_struct
id|icmphdr
)paren
suffix:semicolon
id|icmp_param.data_len
op_assign
id|skb_in-&gt;len
op_minus
id|icmp_param.offset
suffix:semicolon
r_if
c_cond
(paren
id|icmp_param.data_len
OG
id|room
)paren
id|icmp_param.data_len
op_assign
id|room
suffix:semicolon
id|icmp_param.head_len
op_assign
r_sizeof
(paren
r_struct
id|icmphdr
)paren
suffix:semicolon
id|icmp_push_reply
c_func
(paren
op_amp
id|icmp_param
comma
op_amp
id|ipc
comma
id|rt
)paren
suffix:semicolon
id|ende
suffix:colon
id|ip_rt_put
c_func
(paren
id|rt
)paren
suffix:semicolon
id|out_unlock
suffix:colon
id|icmp_xmit_unlock
c_func
(paren
)paren
suffix:semicolon
id|out
suffix:colon
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Handle ICMP_DEST_UNREACH, ICMP_TIME_EXCEED, and ICMP_QUENCH.&n; */
DECL|function|icmp_unreach
r_static
r_void
id|icmp_unreach
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|iphdr
op_star
id|iph
suffix:semicolon
r_struct
id|icmphdr
op_star
id|icmph
suffix:semicolon
r_int
id|hash
comma
id|protocol
suffix:semicolon
r_struct
id|net_protocol
op_star
id|ipprot
suffix:semicolon
r_struct
id|sock
op_star
id|raw_sk
suffix:semicolon
id|u32
id|info
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Incomplete header ?&n;&t; * &t;Only checks for the IP header, there should be an&n;&t; *&t;additional check for longer headers in upper levels.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|pskb_may_pull
c_func
(paren
id|skb
comma
r_sizeof
(paren
r_struct
id|iphdr
)paren
)paren
)paren
r_goto
id|out_err
suffix:semicolon
id|icmph
op_assign
id|skb-&gt;h.icmph
suffix:semicolon
id|iph
op_assign
(paren
r_struct
id|iphdr
op_star
)paren
id|skb-&gt;data
suffix:semicolon
r_if
c_cond
(paren
id|iph-&gt;ihl
OL
l_int|5
)paren
multiline_comment|/* Mangled header, drop. */
r_goto
id|out_err
suffix:semicolon
r_if
c_cond
(paren
id|icmph-&gt;type
op_eq
id|ICMP_DEST_UNREACH
)paren
(brace
r_switch
c_cond
(paren
id|icmph-&gt;code
op_amp
l_int|15
)paren
(brace
r_case
id|ICMP_NET_UNREACH
suffix:colon
r_case
id|ICMP_HOST_UNREACH
suffix:colon
r_case
id|ICMP_PROT_UNREACH
suffix:colon
r_case
id|ICMP_PORT_UNREACH
suffix:colon
r_break
suffix:semicolon
r_case
id|ICMP_FRAG_NEEDED
suffix:colon
r_if
c_cond
(paren
id|ipv4_config.no_pmtu_disc
)paren
(brace
id|LIMIT_NETDEBUG
c_func
(paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ICMP: %u.%u.%u.%u: &quot;
l_string|&quot;fragmentation needed &quot;
l_string|&quot;and DF set.&bslash;n&quot;
comma
id|NIPQUAD
c_func
(paren
id|iph-&gt;daddr
)paren
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|info
op_assign
id|ip_rt_frag_needed
c_func
(paren
id|iph
comma
id|ntohs
c_func
(paren
id|icmph-&gt;un.frag.mtu
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|info
)paren
r_goto
id|out
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|ICMP_SR_FAILED
suffix:colon
id|LIMIT_NETDEBUG
c_func
(paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ICMP: %u.%u.%u.%u: Source &quot;
l_string|&quot;Route Failed.&bslash;n&quot;
comma
id|NIPQUAD
c_func
(paren
id|iph-&gt;daddr
)paren
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|icmph-&gt;code
OG
id|NR_ICMP_UNREACH
)paren
r_goto
id|out
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|icmph-&gt;type
op_eq
id|ICMP_PARAMETERPROB
)paren
id|info
op_assign
id|ntohl
c_func
(paren
id|icmph-&gt;un.gateway
)paren
op_rshift
l_int|24
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Throw it at our lower layers&n;&t; *&n;&t; *&t;RFC 1122: 3.2.2 MUST extract the protocol ID from the passed&n;&t; *&t;&t;  header.&n;&t; *&t;RFC 1122: 3.2.2.1 MUST pass ICMP unreach messages to the&n;&t; *&t;&t;  transport layer.&n;&t; *&t;RFC 1122: 3.2.2.2 MUST pass ICMP time expired messages to&n;&t; *&t;&t;  transport layer.&n;&t; */
multiline_comment|/*&n;&t; *&t;Check the other end isnt violating RFC 1122. Some routers send&n;&t; *&t;bogus responses to broadcast frames. If you see this message&n;&t; *&t;first check your netmask matches at both ends, if it does then&n;&t; *&t;get the other vendor to fix their kit.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|sysctl_icmp_ignore_bogus_error_responses
op_logical_and
id|inet_addr_type
c_func
(paren
id|iph-&gt;daddr
)paren
op_eq
id|RTN_BROADCAST
)paren
(brace
r_if
c_cond
(paren
id|net_ratelimit
c_func
(paren
)paren
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%u.%u.%u.%u sent an invalid ICMP &quot;
l_string|&quot;type %u, code %u &quot;
l_string|&quot;error to a broadcast: %u.%u.%u.%u on %s&bslash;n&quot;
comma
id|NIPQUAD
c_func
(paren
id|skb-&gt;nh.iph-&gt;saddr
)paren
comma
id|icmph-&gt;type
comma
id|icmph-&gt;code
comma
id|NIPQUAD
c_func
(paren
id|iph-&gt;daddr
)paren
comma
id|skb-&gt;dev-&gt;name
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* Checkin full IP header plus 8 bytes of protocol to&n;&t; * avoid additional coding at protocol handlers.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|pskb_may_pull
c_func
(paren
id|skb
comma
id|iph-&gt;ihl
op_star
l_int|4
op_plus
l_int|8
)paren
)paren
r_goto
id|out
suffix:semicolon
id|iph
op_assign
(paren
r_struct
id|iphdr
op_star
)paren
id|skb-&gt;data
suffix:semicolon
id|protocol
op_assign
id|iph-&gt;protocol
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Deliver ICMP message to raw sockets. Pretty useless feature?&n;&t; */
multiline_comment|/* Note: See raw.c and net/raw.h, RAWV4_HTABLE_SIZE==MAX_INET_PROTOS */
id|hash
op_assign
id|protocol
op_amp
(paren
id|MAX_INET_PROTOS
op_minus
l_int|1
)paren
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|raw_v4_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|raw_sk
op_assign
id|sk_head
c_func
(paren
op_amp
id|raw_v4_htable
(braket
id|hash
)braket
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
r_while
c_loop
(paren
(paren
id|raw_sk
op_assign
id|__raw_v4_lookup
c_func
(paren
id|raw_sk
comma
id|protocol
comma
id|iph-&gt;daddr
comma
id|iph-&gt;saddr
comma
id|skb-&gt;dev-&gt;ifindex
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|raw_err
c_func
(paren
id|raw_sk
comma
id|skb
comma
id|info
)paren
suffix:semicolon
id|raw_sk
op_assign
id|sk_next
c_func
(paren
id|raw_sk
)paren
suffix:semicolon
id|iph
op_assign
(paren
r_struct
id|iphdr
op_star
)paren
id|skb-&gt;data
suffix:semicolon
)brace
)brace
id|read_unlock
c_func
(paren
op_amp
id|raw_v4_lock
)paren
suffix:semicolon
id|rcu_read_lock
c_func
(paren
)paren
suffix:semicolon
id|ipprot
op_assign
id|inet_protos
(braket
id|hash
)braket
suffix:semicolon
id|smp_read_barrier_depends
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ipprot
op_logical_and
id|ipprot-&gt;err_handler
)paren
id|ipprot
op_member_access_from_pointer
id|err_handler
c_func
(paren
id|skb
comma
id|info
)paren
suffix:semicolon
id|rcu_read_unlock
c_func
(paren
)paren
suffix:semicolon
id|out
suffix:colon
r_return
suffix:semicolon
id|out_err
suffix:colon
id|ICMP_INC_STATS_BH
c_func
(paren
id|ICMP_MIB_INERRORS
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Handle ICMP_REDIRECT.&n; */
DECL|function|icmp_redirect
r_static
r_void
id|icmp_redirect
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|iphdr
op_star
id|iph
suffix:semicolon
r_int
r_int
id|ip
suffix:semicolon
r_if
c_cond
(paren
id|skb-&gt;len
OL
r_sizeof
(paren
r_struct
id|iphdr
)paren
)paren
r_goto
id|out_err
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Get the copied header of the packet that caused the redirect&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|pskb_may_pull
c_func
(paren
id|skb
comma
r_sizeof
(paren
r_struct
id|iphdr
)paren
)paren
)paren
r_goto
id|out
suffix:semicolon
id|iph
op_assign
(paren
r_struct
id|iphdr
op_star
)paren
id|skb-&gt;data
suffix:semicolon
id|ip
op_assign
id|iph-&gt;daddr
suffix:semicolon
r_switch
c_cond
(paren
id|skb-&gt;h.icmph-&gt;code
op_amp
l_int|7
)paren
(brace
r_case
id|ICMP_REDIR_NET
suffix:colon
r_case
id|ICMP_REDIR_NETTOS
suffix:colon
multiline_comment|/*&n;&t;&t; * As per RFC recommendations now handle it as a host redirect.&n;&t;&t; */
r_case
id|ICMP_REDIR_HOST
suffix:colon
r_case
id|ICMP_REDIR_HOSTTOS
suffix:colon
id|ip_rt_redirect
c_func
(paren
id|skb-&gt;nh.iph-&gt;saddr
comma
id|ip
comma
id|skb-&gt;h.icmph-&gt;un.gateway
comma
id|iph-&gt;saddr
comma
id|iph-&gt;tos
comma
id|skb-&gt;dev
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|out
suffix:colon
r_return
suffix:semicolon
id|out_err
suffix:colon
id|ICMP_INC_STATS_BH
c_func
(paren
id|ICMP_MIB_INERRORS
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Handle ICMP_ECHO (&quot;ping&quot;) requests.&n; *&n; *&t;RFC 1122: 3.2.2.6 MUST have an echo server that answers ICMP echo&n; *&t;&t;  requests.&n; *&t;RFC 1122: 3.2.2.6 Data received in the ICMP_ECHO request MUST be&n; *&t;&t;  included in the reply.&n; *&t;RFC 1812: 4.3.3.6 SHOULD have a config option for silently ignoring&n; *&t;&t;  echo requests, MUST have default=NOT.&n; *&t;See also WRT handling of options once they are done and working.&n; */
DECL|function|icmp_echo
r_static
r_void
id|icmp_echo
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|sysctl_icmp_echo_ignore_all
)paren
(brace
r_struct
id|icmp_bxm
id|icmp_param
suffix:semicolon
id|icmp_param.data.icmph
op_assign
op_star
id|skb-&gt;h.icmph
suffix:semicolon
id|icmp_param.data.icmph.type
op_assign
id|ICMP_ECHOREPLY
suffix:semicolon
id|icmp_param.skb
op_assign
id|skb
suffix:semicolon
id|icmp_param.offset
op_assign
l_int|0
suffix:semicolon
id|icmp_param.data_len
op_assign
id|skb-&gt;len
suffix:semicolon
id|icmp_param.head_len
op_assign
r_sizeof
(paren
r_struct
id|icmphdr
)paren
suffix:semicolon
id|icmp_reply
c_func
(paren
op_amp
id|icmp_param
comma
id|skb
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *&t;Handle ICMP Timestamp requests.&n; *&t;RFC 1122: 3.2.2.8 MAY implement ICMP timestamp requests.&n; *&t;&t;  SHOULD be in the kernel for minimum random latency.&n; *&t;&t;  MUST be accurate to a few minutes.&n; *&t;&t;  MUST be updated at least at 15Hz.&n; */
DECL|function|icmp_timestamp
r_static
r_void
id|icmp_timestamp
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|timeval
id|tv
suffix:semicolon
r_struct
id|icmp_bxm
id|icmp_param
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Too short.&n;&t; */
r_if
c_cond
(paren
id|skb-&gt;len
OL
l_int|4
)paren
r_goto
id|out_err
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Fill in the current time as ms since midnight UT:&n;&t; */
id|do_gettimeofday
c_func
(paren
op_amp
id|tv
)paren
suffix:semicolon
id|icmp_param.data.times
(braket
l_int|1
)braket
op_assign
id|htonl
c_func
(paren
(paren
id|tv.tv_sec
op_mod
l_int|86400
)paren
op_star
l_int|1000
op_plus
id|tv.tv_usec
op_div
l_int|1000
)paren
suffix:semicolon
id|icmp_param.data.times
(braket
l_int|2
)braket
op_assign
id|icmp_param.data.times
(braket
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
id|skb_copy_bits
c_func
(paren
id|skb
comma
l_int|0
comma
op_amp
id|icmp_param.data.times
(braket
l_int|0
)braket
comma
l_int|4
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|icmp_param.data.icmph
op_assign
op_star
id|skb-&gt;h.icmph
suffix:semicolon
id|icmp_param.data.icmph.type
op_assign
id|ICMP_TIMESTAMPREPLY
suffix:semicolon
id|icmp_param.data.icmph.code
op_assign
l_int|0
suffix:semicolon
id|icmp_param.skb
op_assign
id|skb
suffix:semicolon
id|icmp_param.offset
op_assign
l_int|0
suffix:semicolon
id|icmp_param.data_len
op_assign
l_int|0
suffix:semicolon
id|icmp_param.head_len
op_assign
r_sizeof
(paren
r_struct
id|icmphdr
)paren
op_plus
l_int|12
suffix:semicolon
id|icmp_reply
c_func
(paren
op_amp
id|icmp_param
comma
id|skb
)paren
suffix:semicolon
id|out
suffix:colon
r_return
suffix:semicolon
id|out_err
suffix:colon
id|ICMP_INC_STATS_BH
c_func
(paren
id|ICMP_MIB_INERRORS
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Handle ICMP_ADDRESS_MASK requests.  (RFC950)&n; *&n; * RFC1122 (3.2.2.9).  A host MUST only send replies to&n; * ADDRESS_MASK requests if it&squot;s been configured as an address mask&n; * agent.  Receiving a request doesn&squot;t constitute implicit permission to&n; * act as one. Of course, implementing this correctly requires (SHOULD)&n; * a way to turn the functionality on and off.  Another one for sysctl(),&n; * I guess. -- MS&n; *&n; * RFC1812 (4.3.3.9).&t;A router MUST implement it.&n; *&t;&t;&t;A router SHOULD have switch turning it on/off.&n; *&t;&t;      &t;This switch MUST be ON by default.&n; *&n; * Gratuitous replies, zero-source replies are not implemented,&n; * that complies with RFC. DO NOT implement them!!! All the idea&n; * of broadcast addrmask replies as specified in RFC950 is broken.&n; * The problem is that it is not uncommon to have several prefixes&n; * on one physical interface. Moreover, addrmask agent can even be&n; * not aware of existing another prefixes.&n; * If source is zero, addrmask agent cannot choose correct prefix.&n; * Gratuitous mask announcements suffer from the same problem.&n; * RFC1812 explains it, but still allows to use ADDRMASK,&n; * that is pretty silly. --ANK&n; *&n; * All these rules are so bizarre, that I removed kernel addrmask&n; * support at all. It is wrong, it is obsolete, nobody uses it in&n; * any case. --ANK&n; *&n; * Furthermore you can do it with a usermode address agent program&n; * anyway...&n; */
DECL|function|icmp_address
r_static
r_void
id|icmp_address
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
macro_line|#if 0
r_if
c_cond
(paren
id|net_ratelimit
c_func
(paren
)paren
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;a guy asks for address mask. Who is it?&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n; * RFC1812 (4.3.3.9).&t;A router SHOULD listen all replies, and complain&n; *&t;&t;&t;loudly if an inconsistency is found.&n; */
DECL|function|icmp_address_reply
r_static
r_void
id|icmp_address_reply
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|rtable
op_star
id|rt
op_assign
(paren
r_struct
id|rtable
op_star
)paren
id|skb-&gt;dst
suffix:semicolon
r_struct
id|net_device
op_star
id|dev
op_assign
id|skb-&gt;dev
suffix:semicolon
r_struct
id|in_device
op_star
id|in_dev
suffix:semicolon
r_struct
id|in_ifaddr
op_star
id|ifa
suffix:semicolon
id|u32
id|mask
suffix:semicolon
r_if
c_cond
(paren
id|skb-&gt;len
OL
l_int|4
op_logical_or
op_logical_neg
(paren
id|rt-&gt;rt_flags
op_amp
id|RTCF_DIRECTSRC
)paren
)paren
r_goto
id|out
suffix:semicolon
id|in_dev
op_assign
id|in_dev_get
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|in_dev
)paren
r_goto
id|out
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|in_dev-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|in_dev-&gt;ifa_list
op_logical_and
id|IN_DEV_LOG_MARTIANS
c_func
(paren
id|in_dev
)paren
op_logical_and
id|IN_DEV_FORWARD
c_func
(paren
id|in_dev
)paren
)paren
(brace
r_if
c_cond
(paren
id|skb_copy_bits
c_func
(paren
id|skb
comma
l_int|0
comma
op_amp
id|mask
comma
l_int|4
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|ifa
op_assign
id|in_dev-&gt;ifa_list
suffix:semicolon
id|ifa
suffix:semicolon
id|ifa
op_assign
id|ifa-&gt;ifa_next
)paren
(brace
r_if
c_cond
(paren
id|mask
op_eq
id|ifa-&gt;ifa_mask
op_logical_and
id|inet_ifa_match
c_func
(paren
id|rt-&gt;rt_src
comma
id|ifa
)paren
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|ifa
op_logical_and
id|net_ratelimit
c_func
(paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Wrong address mask %u.%u.%u.%u from &quot;
l_string|&quot;%s/%u.%u.%u.%u&bslash;n&quot;
comma
id|NIPQUAD
c_func
(paren
id|mask
)paren
comma
id|dev-&gt;name
comma
id|NIPQUAD
c_func
(paren
id|rt-&gt;rt_src
)paren
)paren
suffix:semicolon
)brace
)brace
id|read_unlock
c_func
(paren
op_amp
id|in_dev-&gt;lock
)paren
suffix:semicolon
id|in_dev_put
c_func
(paren
id|in_dev
)paren
suffix:semicolon
id|out
suffix:colon
suffix:semicolon
)brace
DECL|function|icmp_discard
r_static
r_void
id|icmp_discard
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
)brace
multiline_comment|/*&n; *&t;Deal with incoming ICMP packets.&n; */
DECL|function|icmp_rcv
r_int
id|icmp_rcv
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|icmphdr
op_star
id|icmph
suffix:semicolon
r_struct
id|rtable
op_star
id|rt
op_assign
(paren
r_struct
id|rtable
op_star
)paren
id|skb-&gt;dst
suffix:semicolon
id|ICMP_INC_STATS_BH
c_func
(paren
id|ICMP_MIB_INMSGS
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|skb-&gt;ip_summed
)paren
(brace
r_case
id|CHECKSUM_HW
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|u16
)paren
id|csum_fold
c_func
(paren
id|skb-&gt;csum
)paren
)paren
r_break
suffix:semicolon
id|NETDEBUG
c_func
(paren
r_if
(paren
id|net_ratelimit
c_func
(paren
)paren
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;icmp v4 hw csum failure&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_case
id|CHECKSUM_NONE
suffix:colon
r_if
c_cond
(paren
(paren
id|u16
)paren
id|csum_fold
c_func
(paren
id|skb_checksum
c_func
(paren
id|skb
comma
l_int|0
comma
id|skb-&gt;len
comma
l_int|0
)paren
)paren
)paren
r_goto
id|error
suffix:semicolon
r_default
suffix:colon
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|pskb_pull
c_func
(paren
id|skb
comma
r_sizeof
(paren
r_struct
id|icmphdr
)paren
)paren
)paren
r_goto
id|error
suffix:semicolon
id|icmph
op_assign
id|skb-&gt;h.icmph
suffix:semicolon
multiline_comment|/*&n;&t; *&t;18 is the highest &squot;known&squot; ICMP type. Anything else is a mystery&n;&t; *&n;&t; *&t;RFC 1122: 3.2.2  Unknown ICMP messages types MUST be silently&n;&t; *&t;&t;  discarded.&n;&t; */
r_if
c_cond
(paren
id|icmph-&gt;type
OG
id|NR_ICMP_TYPES
)paren
r_goto
id|error
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Parse the ICMP message&n;&t; */
r_if
c_cond
(paren
id|rt-&gt;rt_flags
op_amp
(paren
id|RTCF_BROADCAST
op_or
id|RTCF_MULTICAST
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; *&t;RFC 1122: 3.2.2.6 An ICMP_ECHO to broadcast MAY be&n;&t;&t; *&t;  silently ignored (we let user decide with a sysctl).&n;&t;&t; *&t;RFC 1122: 3.2.2.8 An ICMP_TIMESTAMP MAY be silently&n;&t;&t; *&t;  discarded if to broadcast/multicast.&n;&t;&t; */
r_if
c_cond
(paren
id|icmph-&gt;type
op_eq
id|ICMP_ECHO
op_logical_and
id|sysctl_icmp_echo_ignore_broadcasts
)paren
(brace
r_goto
id|error
suffix:semicolon
)brace
r_if
c_cond
(paren
id|icmph-&gt;type
op_ne
id|ICMP_ECHO
op_logical_and
id|icmph-&gt;type
op_ne
id|ICMP_TIMESTAMP
op_logical_and
id|icmph-&gt;type
op_ne
id|ICMP_ADDRESS
op_logical_and
id|icmph-&gt;type
op_ne
id|ICMP_ADDRESSREPLY
)paren
(brace
r_goto
id|error
suffix:semicolon
)brace
)brace
id|ICMP_INC_STATS_BH
c_func
(paren
id|icmp_pointers
(braket
id|icmph-&gt;type
)braket
dot
id|input_entry
)paren
suffix:semicolon
id|icmp_pointers
(braket
id|icmph-&gt;type
)braket
dot
id|handler
c_func
(paren
id|skb
)paren
suffix:semicolon
id|drop
suffix:colon
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|error
suffix:colon
id|ICMP_INC_STATS_BH
c_func
(paren
id|ICMP_MIB_INERRORS
)paren
suffix:semicolon
r_goto
id|drop
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;This table is the definition of how we handle ICMP.&n; */
DECL|variable|icmp_pointers
r_static
r_struct
id|icmp_control
id|icmp_pointers
(braket
id|NR_ICMP_TYPES
op_plus
l_int|1
)braket
op_assign
(brace
(braket
id|ICMP_ECHOREPLY
)braket
op_assign
(brace
dot
id|output_entry
op_assign
id|ICMP_MIB_OUTECHOREPS
comma
dot
id|input_entry
op_assign
id|ICMP_MIB_INECHOREPS
comma
dot
id|handler
op_assign
id|icmp_discard
comma
)brace
comma
(braket
l_int|1
)braket
op_assign
(brace
dot
id|output_entry
op_assign
id|ICMP_MIB_DUMMY
comma
dot
id|input_entry
op_assign
id|ICMP_MIB_INERRORS
comma
dot
id|handler
op_assign
id|icmp_discard
comma
dot
id|error
op_assign
l_int|1
comma
)brace
comma
(braket
l_int|2
)braket
op_assign
(brace
dot
id|output_entry
op_assign
id|ICMP_MIB_DUMMY
comma
dot
id|input_entry
op_assign
id|ICMP_MIB_INERRORS
comma
dot
id|handler
op_assign
id|icmp_discard
comma
dot
id|error
op_assign
l_int|1
comma
)brace
comma
(braket
id|ICMP_DEST_UNREACH
)braket
op_assign
(brace
dot
id|output_entry
op_assign
id|ICMP_MIB_OUTDESTUNREACHS
comma
dot
id|input_entry
op_assign
id|ICMP_MIB_INDESTUNREACHS
comma
dot
id|handler
op_assign
id|icmp_unreach
comma
dot
id|error
op_assign
l_int|1
comma
)brace
comma
(braket
id|ICMP_SOURCE_QUENCH
)braket
op_assign
(brace
dot
id|output_entry
op_assign
id|ICMP_MIB_OUTSRCQUENCHS
comma
dot
id|input_entry
op_assign
id|ICMP_MIB_INSRCQUENCHS
comma
dot
id|handler
op_assign
id|icmp_unreach
comma
dot
id|error
op_assign
l_int|1
comma
)brace
comma
(braket
id|ICMP_REDIRECT
)braket
op_assign
(brace
dot
id|output_entry
op_assign
id|ICMP_MIB_OUTREDIRECTS
comma
dot
id|input_entry
op_assign
id|ICMP_MIB_INREDIRECTS
comma
dot
id|handler
op_assign
id|icmp_redirect
comma
dot
id|error
op_assign
l_int|1
comma
)brace
comma
(braket
l_int|6
)braket
op_assign
(brace
dot
id|output_entry
op_assign
id|ICMP_MIB_DUMMY
comma
dot
id|input_entry
op_assign
id|ICMP_MIB_INERRORS
comma
dot
id|handler
op_assign
id|icmp_discard
comma
dot
id|error
op_assign
l_int|1
comma
)brace
comma
(braket
l_int|7
)braket
op_assign
(brace
dot
id|output_entry
op_assign
id|ICMP_MIB_DUMMY
comma
dot
id|input_entry
op_assign
id|ICMP_MIB_INERRORS
comma
dot
id|handler
op_assign
id|icmp_discard
comma
dot
id|error
op_assign
l_int|1
comma
)brace
comma
(braket
id|ICMP_ECHO
)braket
op_assign
(brace
dot
id|output_entry
op_assign
id|ICMP_MIB_OUTECHOS
comma
dot
id|input_entry
op_assign
id|ICMP_MIB_INECHOS
comma
dot
id|handler
op_assign
id|icmp_echo
comma
)brace
comma
(braket
l_int|9
)braket
op_assign
(brace
dot
id|output_entry
op_assign
id|ICMP_MIB_DUMMY
comma
dot
id|input_entry
op_assign
id|ICMP_MIB_INERRORS
comma
dot
id|handler
op_assign
id|icmp_discard
comma
dot
id|error
op_assign
l_int|1
comma
)brace
comma
(braket
l_int|10
)braket
op_assign
(brace
dot
id|output_entry
op_assign
id|ICMP_MIB_DUMMY
comma
dot
id|input_entry
op_assign
id|ICMP_MIB_INERRORS
comma
dot
id|handler
op_assign
id|icmp_discard
comma
dot
id|error
op_assign
l_int|1
comma
)brace
comma
(braket
id|ICMP_TIME_EXCEEDED
)braket
op_assign
(brace
dot
id|output_entry
op_assign
id|ICMP_MIB_OUTTIMEEXCDS
comma
dot
id|input_entry
op_assign
id|ICMP_MIB_INTIMEEXCDS
comma
dot
id|handler
op_assign
id|icmp_unreach
comma
dot
id|error
op_assign
l_int|1
comma
)brace
comma
(braket
id|ICMP_PARAMETERPROB
)braket
op_assign
(brace
dot
id|output_entry
op_assign
id|ICMP_MIB_OUTPARMPROBS
comma
dot
id|input_entry
op_assign
id|ICMP_MIB_INPARMPROBS
comma
dot
id|handler
op_assign
id|icmp_unreach
comma
dot
id|error
op_assign
l_int|1
comma
)brace
comma
(braket
id|ICMP_TIMESTAMP
)braket
op_assign
(brace
dot
id|output_entry
op_assign
id|ICMP_MIB_OUTTIMESTAMPS
comma
dot
id|input_entry
op_assign
id|ICMP_MIB_INTIMESTAMPS
comma
dot
id|handler
op_assign
id|icmp_timestamp
comma
)brace
comma
(braket
id|ICMP_TIMESTAMPREPLY
)braket
op_assign
(brace
dot
id|output_entry
op_assign
id|ICMP_MIB_OUTTIMESTAMPREPS
comma
dot
id|input_entry
op_assign
id|ICMP_MIB_INTIMESTAMPREPS
comma
dot
id|handler
op_assign
id|icmp_discard
comma
)brace
comma
(braket
id|ICMP_INFO_REQUEST
)braket
op_assign
(brace
dot
id|output_entry
op_assign
id|ICMP_MIB_DUMMY
comma
dot
id|input_entry
op_assign
id|ICMP_MIB_DUMMY
comma
dot
id|handler
op_assign
id|icmp_discard
comma
)brace
comma
(braket
id|ICMP_INFO_REPLY
)braket
op_assign
(brace
dot
id|output_entry
op_assign
id|ICMP_MIB_DUMMY
comma
dot
id|input_entry
op_assign
id|ICMP_MIB_DUMMY
comma
dot
id|handler
op_assign
id|icmp_discard
comma
)brace
comma
(braket
id|ICMP_ADDRESS
)braket
op_assign
(brace
dot
id|output_entry
op_assign
id|ICMP_MIB_OUTADDRMASKS
comma
dot
id|input_entry
op_assign
id|ICMP_MIB_INADDRMASKS
comma
dot
id|handler
op_assign
id|icmp_address
comma
)brace
comma
(braket
id|ICMP_ADDRESSREPLY
)braket
op_assign
(brace
dot
id|output_entry
op_assign
id|ICMP_MIB_OUTADDRMASKREPS
comma
dot
id|input_entry
op_assign
id|ICMP_MIB_INADDRMASKREPS
comma
dot
id|handler
op_assign
id|icmp_address_reply
comma
)brace
comma
)brace
suffix:semicolon
DECL|function|icmp_init
r_void
id|__init
id|icmp_init
c_func
(paren
r_struct
id|net_proto_family
op_star
id|ops
)paren
(brace
r_struct
id|inet_opt
op_star
id|inet
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_CPUS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|err
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cpu_possible
c_func
(paren
id|i
)paren
)paren
r_continue
suffix:semicolon
id|err
op_assign
id|sock_create_kern
c_func
(paren
id|PF_INET
comma
id|SOCK_RAW
comma
id|IPPROTO_ICMP
comma
op_amp
id|per_cpu
c_func
(paren
id|__icmp_socket
comma
id|i
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
id|panic
c_func
(paren
l_string|&quot;Failed to create the ICMP control socket.&bslash;n&quot;
)paren
suffix:semicolon
id|per_cpu
c_func
(paren
id|__icmp_socket
comma
id|i
)paren
op_member_access_from_pointer
id|sk-&gt;sk_allocation
op_assign
id|GFP_ATOMIC
suffix:semicolon
multiline_comment|/* Enough space for 2 64K ICMP packets, including&n;&t;&t; * sk_buff struct overhead.&n;&t;&t; */
id|per_cpu
c_func
(paren
id|__icmp_socket
comma
id|i
)paren
op_member_access_from_pointer
id|sk-&gt;sk_sndbuf
op_assign
(paren
l_int|2
op_star
(paren
(paren
l_int|64
op_star
l_int|1024
)paren
op_plus
r_sizeof
(paren
r_struct
id|sk_buff
)paren
)paren
)paren
suffix:semicolon
id|inet
op_assign
id|inet_sk
c_func
(paren
id|per_cpu
c_func
(paren
id|__icmp_socket
comma
id|i
)paren
op_member_access_from_pointer
id|sk
)paren
suffix:semicolon
id|inet-&gt;uc_ttl
op_assign
op_minus
l_int|1
suffix:semicolon
id|inet-&gt;pmtudisc
op_assign
id|IP_PMTUDISC_DONT
suffix:semicolon
multiline_comment|/* Unhash it so that IP input processing does not even&n;&t;&t; * see it, we do not wish this socket to see incoming&n;&t;&t; * packets.&n;&t;&t; */
id|per_cpu
c_func
(paren
id|__icmp_socket
comma
id|i
)paren
op_member_access_from_pointer
id|sk-&gt;sk_prot
op_member_access_from_pointer
id|unhash
c_func
(paren
id|per_cpu
c_func
(paren
id|__icmp_socket
comma
id|i
)paren
op_member_access_from_pointer
id|sk
)paren
suffix:semicolon
)brace
)brace
DECL|variable|icmp_err_convert
id|EXPORT_SYMBOL
c_func
(paren
id|icmp_err_convert
)paren
suffix:semicolon
DECL|variable|icmp_send
id|EXPORT_SYMBOL
c_func
(paren
id|icmp_send
)paren
suffix:semicolon
DECL|variable|icmp_statistics
id|EXPORT_SYMBOL
c_func
(paren
id|icmp_statistics
)paren
suffix:semicolon
DECL|variable|xrlim_allow
id|EXPORT_SYMBOL
c_func
(paren
id|xrlim_allow
)paren
suffix:semicolon
eof
