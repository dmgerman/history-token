multiline_comment|/* (C) 1999-2001 Paul `Rusty&squot; Russell&n; * (C) 2002-2004 Netfilter Core Team &lt;coreteam@netfilter.org&gt;&n; *&n; * This program is free software; you can redistribute it and/or modify&n; * it under the terms of the GNU General Public License version 2 as&n; * published by the Free Software Foundation.&n; *&n; * Jozsef Kadlecsik &lt;kadlec@blackhole.kfki.hu&gt;:&n; *&t;- Real stateful connection tracking&n; *&t;- Modified state transitions table&n; *&t;- Window scaling support added&n; *&t;- SACK support added&n; *&n; * Willy Tarreau:&n; *&t;- State table bugfixes&n; *&t;- More robust state changes&n; *&t;- Tuning timer parameters&n; *&n; * version 2.2&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/netfilter.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/in.h&gt;
macro_line|#include &lt;linux/ip.h&gt;
macro_line|#include &lt;linux/tcp.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;net/tcp.h&gt;
macro_line|#include &lt;linux/netfilter.h&gt;
macro_line|#include &lt;linux/netfilter_ipv4/ip_conntrack.h&gt;
macro_line|#include &lt;linux/netfilter_ipv4/ip_conntrack_protocol.h&gt;
macro_line|#include &lt;linux/netfilter_ipv4/lockhelp.h&gt;
macro_line|#if 0
mdefine_line|#define DEBUGP printk
mdefine_line|#define DEBUGP_VARS
macro_line|#else
DECL|macro|DEBUGP
mdefine_line|#define DEBUGP(format, args...)
macro_line|#endif
multiline_comment|/* Protects conntrack-&gt;proto.tcp */
r_static
id|DECLARE_RWLOCK
c_func
(paren
id|tcp_lock
)paren
suffix:semicolon
multiline_comment|/* &quot;Be conservative in what you do, &n;    be liberal in what you accept from others.&quot; &n;    If it&squot;s non-zero, we mark only out of window RST segments as INVALID. */
DECL|variable|ip_ct_tcp_be_liberal
r_int
id|ip_ct_tcp_be_liberal
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* When connection is picked up from the middle, how many packets are required&n;   to pass in each direction when we assume we are in sync - if any side uses&n;   window scaling, we lost the game. &n;   If it is set to zero, we disable picking up already established &n;   connections. */
DECL|variable|ip_ct_tcp_loose
r_int
id|ip_ct_tcp_loose
op_assign
l_int|3
suffix:semicolon
multiline_comment|/* Max number of the retransmitted packets without receiving an (acceptable) &n;   ACK from the destination. If this number is reached, a shorter timer &n;   will be started. */
DECL|variable|ip_ct_tcp_max_retrans
r_int
id|ip_ct_tcp_max_retrans
op_assign
l_int|3
suffix:semicolon
multiline_comment|/* FIXME: Examine ipfilter&squot;s timeouts and conntrack transitions more&n;     closely.  They&squot;re more complex. --RR */
DECL|variable|tcp_conntrack_names
r_static
r_const
r_char
op_star
id|tcp_conntrack_names
(braket
)braket
op_assign
(brace
l_string|&quot;NONE&quot;
comma
l_string|&quot;SYN_SENT&quot;
comma
l_string|&quot;SYN_RECV&quot;
comma
l_string|&quot;ESTABLISHED&quot;
comma
l_string|&quot;FIN_WAIT&quot;
comma
l_string|&quot;CLOSE_WAIT&quot;
comma
l_string|&quot;LAST_ACK&quot;
comma
l_string|&quot;TIME_WAIT&quot;
comma
l_string|&quot;CLOSE&quot;
comma
l_string|&quot;LISTEN&quot;
)brace
suffix:semicolon
DECL|macro|SECS
mdefine_line|#define SECS * HZ
DECL|macro|MINS
mdefine_line|#define MINS * 60 SECS
DECL|macro|HOURS
mdefine_line|#define HOURS * 60 MINS
DECL|macro|DAYS
mdefine_line|#define DAYS * 24 HOURS
DECL|variable|ip_ct_tcp_timeout_syn_sent
r_int
r_int
id|ip_ct_tcp_timeout_syn_sent
op_assign
l_int|2
id|MINS
suffix:semicolon
DECL|variable|ip_ct_tcp_timeout_syn_recv
r_int
r_int
id|ip_ct_tcp_timeout_syn_recv
op_assign
l_int|60
id|SECS
suffix:semicolon
DECL|variable|ip_ct_tcp_timeout_established
r_int
r_int
id|ip_ct_tcp_timeout_established
op_assign
l_int|5
id|DAYS
suffix:semicolon
DECL|variable|ip_ct_tcp_timeout_fin_wait
r_int
r_int
id|ip_ct_tcp_timeout_fin_wait
op_assign
l_int|2
id|MINS
suffix:semicolon
DECL|variable|ip_ct_tcp_timeout_close_wait
r_int
r_int
id|ip_ct_tcp_timeout_close_wait
op_assign
l_int|60
id|SECS
suffix:semicolon
DECL|variable|ip_ct_tcp_timeout_last_ack
r_int
r_int
id|ip_ct_tcp_timeout_last_ack
op_assign
l_int|30
id|SECS
suffix:semicolon
DECL|variable|ip_ct_tcp_timeout_time_wait
r_int
r_int
id|ip_ct_tcp_timeout_time_wait
op_assign
l_int|2
id|MINS
suffix:semicolon
DECL|variable|ip_ct_tcp_timeout_close
r_int
r_int
id|ip_ct_tcp_timeout_close
op_assign
l_int|10
id|SECS
suffix:semicolon
multiline_comment|/* RFC1122 says the R2 limit should be at least 100 seconds.&n;   Linux uses 15 packets as limit, which corresponds &n;   to ~13-30min depending on RTO. */
DECL|variable|ip_ct_tcp_timeout_max_retrans
r_int
r_int
id|ip_ct_tcp_timeout_max_retrans
op_assign
l_int|5
id|MINS
suffix:semicolon
DECL|variable|tcp_timeouts
r_static
r_int
r_int
op_star
id|tcp_timeouts
(braket
)braket
op_assign
(brace
l_int|NULL
comma
multiline_comment|/*      TCP_CONNTRACK_NONE */
op_amp
id|ip_ct_tcp_timeout_syn_sent
comma
multiline_comment|/*      TCP_CONNTRACK_SYN_SENT, */
op_amp
id|ip_ct_tcp_timeout_syn_recv
comma
multiline_comment|/*      TCP_CONNTRACK_SYN_RECV, */
op_amp
id|ip_ct_tcp_timeout_established
comma
multiline_comment|/*      TCP_CONNTRACK_ESTABLISHED,      */
op_amp
id|ip_ct_tcp_timeout_fin_wait
comma
multiline_comment|/*      TCP_CONNTRACK_FIN_WAIT, */
op_amp
id|ip_ct_tcp_timeout_close_wait
comma
multiline_comment|/*      TCP_CONNTRACK_CLOSE_WAIT,       */
op_amp
id|ip_ct_tcp_timeout_last_ack
comma
multiline_comment|/*      TCP_CONNTRACK_LAST_ACK, */
op_amp
id|ip_ct_tcp_timeout_time_wait
comma
multiline_comment|/*      TCP_CONNTRACK_TIME_WAIT,        */
op_amp
id|ip_ct_tcp_timeout_close
comma
multiline_comment|/*      TCP_CONNTRACK_CLOSE,    */
l_int|NULL
comma
multiline_comment|/*      TCP_CONNTRACK_LISTEN */
)brace
suffix:semicolon
DECL|macro|sNO
mdefine_line|#define sNO TCP_CONNTRACK_NONE
DECL|macro|sSS
mdefine_line|#define sSS TCP_CONNTRACK_SYN_SENT
DECL|macro|sSR
mdefine_line|#define sSR TCP_CONNTRACK_SYN_RECV
DECL|macro|sES
mdefine_line|#define sES TCP_CONNTRACK_ESTABLISHED
DECL|macro|sFW
mdefine_line|#define sFW TCP_CONNTRACK_FIN_WAIT
DECL|macro|sCW
mdefine_line|#define sCW TCP_CONNTRACK_CLOSE_WAIT
DECL|macro|sLA
mdefine_line|#define sLA TCP_CONNTRACK_LAST_ACK
DECL|macro|sTW
mdefine_line|#define sTW TCP_CONNTRACK_TIME_WAIT
DECL|macro|sCL
mdefine_line|#define sCL TCP_CONNTRACK_CLOSE
DECL|macro|sLI
mdefine_line|#define sLI TCP_CONNTRACK_LISTEN
DECL|macro|sIV
mdefine_line|#define sIV TCP_CONNTRACK_MAX
DECL|macro|sIG
mdefine_line|#define sIG TCP_CONNTRACK_IGNORE
multiline_comment|/* What TCP flags are set from RST/SYN/FIN/ACK. */
DECL|enum|tcp_bit_set
r_enum
id|tcp_bit_set
(brace
DECL|enumerator|TCP_SYN_SET
id|TCP_SYN_SET
comma
DECL|enumerator|TCP_SYNACK_SET
id|TCP_SYNACK_SET
comma
DECL|enumerator|TCP_FIN_SET
id|TCP_FIN_SET
comma
DECL|enumerator|TCP_ACK_SET
id|TCP_ACK_SET
comma
DECL|enumerator|TCP_RST_SET
id|TCP_RST_SET
comma
DECL|enumerator|TCP_NONE_SET
id|TCP_NONE_SET
comma
)brace
suffix:semicolon
multiline_comment|/*&n; * The TCP state transition table needs a few words...&n; *&n; * We are the man in the middle. All the packets go through us&n; * but might get lost in transit to the destination.&n; * It is assumed that the destinations can&squot;t receive segments &n; * we haven&squot;t seen.&n; *&n; * The checked segment is in window, but our windows are *not*&n; * equivalent with the ones of the sender/receiver. We always&n; * try to guess the state of the current sender.&n; *&n; * The meaning of the states are:&n; *&n; * NONE:&t;initial state&n; * SYN_SENT:&t;SYN-only packet seen &n; * SYN_RECV:&t;SYN-ACK packet seen&n; * ESTABLISHED:&t;ACK packet seen&n; * FIN_WAIT:&t;FIN packet seen&n; * CLOSE_WAIT:&t;ACK seen (after FIN) &n; * LAST_ACK:&t;FIN seen (after FIN)&n; * TIME_WAIT:&t;last ACK seen&n; * CLOSE:&t;closed connection&n; *&n; * LISTEN state is not used.&n; *&n; * Packets marked as IGNORED (sIG):&n; *&t;if they may be either invalid or valid &n; *&t;and the receiver may send back a connection &n; *&t;closing RST or a SYN/ACK.&n; *&n; * Packets marked as INVALID (sIV):&n; *&t;if they are invalid&n; *&t;or we do not support the request (simultaneous open)&n; */
DECL|variable|tcp_conntracks
r_static
r_enum
id|tcp_conntrack
id|tcp_conntracks
(braket
l_int|2
)braket
(braket
l_int|6
)braket
(braket
id|TCP_CONNTRACK_MAX
)braket
op_assign
(brace
(brace
multiline_comment|/* ORIGINAL */
multiline_comment|/* &t;     sNO, sSS, sSR, sES, sFW, sCW, sLA, sTW, sCL, sLI&t;*/
multiline_comment|/*syn*/
(brace
id|sSS
comma
id|sSS
comma
id|sIG
comma
id|sIG
comma
id|sIG
comma
id|sIG
comma
id|sIG
comma
id|sSS
comma
id|sSS
comma
id|sIV
)brace
comma
multiline_comment|/*&n; *&t;sNO -&gt; sSS&t;Initialize a new connection&n; *&t;sSS -&gt; sSS&t;Retransmitted SYN&n; *&t;sSR -&gt; sIG&t;Late retransmitted SYN?&n; *&t;sES -&gt; sIG&t;Error: SYNs in window outside the SYN_SENT state&n; *&t;&t;&t;are errors. Receiver will reply with RST &n; *&t;&t;&t;and close the connection.&n; *&t;&t;&t;Or we are not in sync and hold a dead connection.&n; *&t;sFW -&gt; sIG&n; *&t;sCW -&gt; sIG&n; *&t;sLA -&gt; sIG&n; *&t;sTW -&gt; sSS&t;Reopened connection (RFC 1122).&n; *&t;sCL -&gt; sSS&n; */
multiline_comment|/* &t;     sNO, sSS, sSR, sES, sFW, sCW, sLA, sTW, sCL, sLI&t;*/
multiline_comment|/*synack*/
(brace
id|sIV
comma
id|sIV
comma
id|sIV
comma
id|sIV
comma
id|sIV
comma
id|sIV
comma
id|sIV
comma
id|sIV
comma
id|sIV
comma
id|sIV
)brace
comma
multiline_comment|/*&n; * A SYN/ACK from the client is always invalid:&n; *&t;- either it tries to set up a simultaneous open, which is &n; *&t;  not supported;&n; *&t;- or the firewall has just been inserted between the two hosts&n; *&t;  during the session set-up. The SYN will be retransmitted &n; *&t;  by the true client (or it&squot;ll time out).&n; */
multiline_comment|/* &t;     sNO, sSS, sSR, sES, sFW, sCW, sLA, sTW, sCL, sLI&t;*/
multiline_comment|/*fin*/
(brace
id|sIV
comma
id|sIV
comma
id|sFW
comma
id|sFW
comma
id|sLA
comma
id|sLA
comma
id|sLA
comma
id|sTW
comma
id|sCL
comma
id|sIV
)brace
comma
multiline_comment|/*&n; *&t;sNO -&gt; sIV&t;Too late and no reason to do anything...&n; *&t;sSS -&gt; sIV&t;Client migth not send FIN in this state:&n; *&t;&t;&t;we enforce waiting for a SYN/ACK reply first.&n; *&t;sSR -&gt; sFW&t;Close started.&n; *&t;sES -&gt; sFW&t;&n; *&t;sFW -&gt; sLA&t;FIN seen in both directions, waiting for&n; *&t;&t;&t;the last ACK. &n; *&t;&t;&t;Migth be a retransmitted FIN as well...&n; *&t;sCW -&gt; sLA&n; *&t;sLA -&gt; sLA&t;Retransmitted FIN. Remain in the same state.&n; *&t;sTW -&gt; sTW&n; *&t;sCL -&gt; sCL&n; */
multiline_comment|/* &t;     sNO, sSS, sSR, sES, sFW, sCW, sLA, sTW, sCL, sLI&t;*/
multiline_comment|/*ack*/
(brace
id|sES
comma
id|sIV
comma
id|sES
comma
id|sES
comma
id|sCW
comma
id|sCW
comma
id|sTW
comma
id|sTW
comma
id|sCL
comma
id|sIV
)brace
comma
multiline_comment|/*&n; *&t;sNO -&gt; sES&t;Assumed.&n; *&t;sSS -&gt; sIV&t;ACK is invalid: we haven&squot;t seen a SYN/ACK yet.&n; *&t;sSR -&gt; sES&t;Established state is reached.&n; *&t;sES -&gt; sES&t;:-)&n; *&t;sFW -&gt; sCW&t;Normal close request answered by ACK.&n; *&t;sCW -&gt; sCW&n; *&t;sLA -&gt; sTW&t;Last ACK detected.&n; *&t;sTW -&gt; sTW&t;Retransmitted last ACK. Remain in the same state.&n; *&t;sCL -&gt; sCL&n; */
multiline_comment|/* &t;     sNO, sSS, sSR, sES, sFW, sCW, sLA, sTW, sCL, sLI&t;*/
multiline_comment|/*rst*/
(brace
id|sIV
comma
id|sCL
comma
id|sCL
comma
id|sCL
comma
id|sCL
comma
id|sCL
comma
id|sCL
comma
id|sCL
comma
id|sCL
comma
id|sIV
)brace
comma
multiline_comment|/*none*/
(brace
id|sIV
comma
id|sIV
comma
id|sIV
comma
id|sIV
comma
id|sIV
comma
id|sIV
comma
id|sIV
comma
id|sIV
comma
id|sIV
comma
id|sIV
)brace
)brace
comma
(brace
multiline_comment|/* REPLY */
multiline_comment|/* &t;     sNO, sSS, sSR, sES, sFW, sCW, sLA, sTW, sCL, sLI&t;*/
multiline_comment|/*syn*/
(brace
id|sIV
comma
id|sIV
comma
id|sIV
comma
id|sIV
comma
id|sIV
comma
id|sIV
comma
id|sIV
comma
id|sIV
comma
id|sIV
comma
id|sIV
)brace
comma
multiline_comment|/*&n; *&t;sNO -&gt; sIV&t;Never reached.&n; *&t;sSS -&gt; sIV&t;Simultaneous open, not supported&n; *&t;sSR -&gt; sIV&t;Simultaneous open, not supported.&n; *&t;sES -&gt; sIV&t;Server may not initiate a connection.&n; *&t;sFW -&gt; sIV&n; *&t;sCW -&gt; sIV&n; *&t;sLA -&gt; sIV&n; *&t;sTW -&gt; sIV&t;Reopened connection, but server may not do it.&n; *&t;sCL -&gt; sIV&n; */
multiline_comment|/* &t;     sNO, sSS, sSR, sES, sFW, sCW, sLA, sTW, sCL, sLI&t;*/
multiline_comment|/*synack*/
(brace
id|sIV
comma
id|sSR
comma
id|sSR
comma
id|sIG
comma
id|sIG
comma
id|sIG
comma
id|sIG
comma
id|sIG
comma
id|sIG
comma
id|sIV
)brace
comma
multiline_comment|/*&n; *&t;sSS -&gt; sSR&t;Standard open.&n; *&t;sSR -&gt; sSR&t;Retransmitted SYN/ACK.&n; *&t;sES -&gt; sIG&t;Late retransmitted SYN/ACK?&n; *&t;sFW -&gt; sIG&n; *&t;sCW -&gt; sIG&n; *&t;sLA -&gt; sIG&n; *&t;sTW -&gt; sIG&n; *&t;sCL -&gt; sIG&n; */
multiline_comment|/* &t;     sNO, sSS, sSR, sES, sFW, sCW, sLA, sTW, sCL, sLI&t;*/
multiline_comment|/*fin*/
(brace
id|sIV
comma
id|sIV
comma
id|sFW
comma
id|sFW
comma
id|sLA
comma
id|sLA
comma
id|sLA
comma
id|sTW
comma
id|sCL
comma
id|sIV
)brace
comma
multiline_comment|/*&n; *&t;sSS -&gt; sIV&t;Server might not send FIN in this state.&n; *&t;sSR -&gt; sFW&t;Close started.&n; *&t;sES -&gt; sFW&n; *&t;sFW -&gt; sLA&t;FIN seen in both directions.&n; *&t;sCW -&gt; sLA&n; *&t;sLA -&gt; sLA&t;Retransmitted FIN.&n; *&t;sTW -&gt; sTW&n; *&t;sCL -&gt; sCL&n; */
multiline_comment|/* &t;     sNO, sSS, sSR, sES, sFW, sCW, sLA, sTW, sCL, sLI&t;*/
multiline_comment|/*ack*/
(brace
id|sIV
comma
id|sIV
comma
id|sIV
comma
id|sES
comma
id|sCW
comma
id|sCW
comma
id|sTW
comma
id|sTW
comma
id|sCL
comma
id|sIV
)brace
comma
multiline_comment|/*&n; *&t;sSS -&gt; sIV&t;ACK is invalid: we haven&squot;t seen a SYN/ACK yet.&n; *&t;sSR -&gt; sIV&t;Simultaneous open.&n; *&t;sES -&gt; sES&t;:-)&n; *&t;sFW -&gt; sCW&t;Normal close request answered by ACK.&n; *&t;sCW -&gt; sCW&n; *&t;sLA -&gt; sTW&t;Last ACK detected.&n; *&t;sTW -&gt; sTW&t;Retransmitted last ACK.&n; *&t;sCL -&gt; sCL&n; */
multiline_comment|/* &t;     sNO, sSS, sSR, sES, sFW, sCW, sLA, sTW, sCL, sLI&t;*/
multiline_comment|/*rst*/
(brace
id|sIV
comma
id|sCL
comma
id|sCL
comma
id|sCL
comma
id|sCL
comma
id|sCL
comma
id|sCL
comma
id|sCL
comma
id|sCL
comma
id|sIV
)brace
comma
multiline_comment|/*none*/
(brace
id|sIV
comma
id|sIV
comma
id|sIV
comma
id|sIV
comma
id|sIV
comma
id|sIV
comma
id|sIV
comma
id|sIV
comma
id|sIV
comma
id|sIV
)brace
)brace
)brace
suffix:semicolon
DECL|function|tcp_pkt_to_tuple
r_static
r_int
id|tcp_pkt_to_tuple
c_func
(paren
r_const
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
r_int
id|dataoff
comma
r_struct
id|ip_conntrack_tuple
op_star
id|tuple
)paren
(brace
r_struct
id|tcphdr
id|_hdr
comma
op_star
id|hp
suffix:semicolon
multiline_comment|/* Actually only need first 8 bytes. */
id|hp
op_assign
id|skb_header_pointer
c_func
(paren
id|skb
comma
id|dataoff
comma
l_int|8
comma
op_amp
id|_hdr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hp
op_eq
l_int|NULL
)paren
r_return
l_int|0
suffix:semicolon
id|tuple-&gt;src.u.tcp.port
op_assign
id|hp-&gt;source
suffix:semicolon
id|tuple-&gt;dst.u.tcp.port
op_assign
id|hp-&gt;dest
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|tcp_invert_tuple
r_static
r_int
id|tcp_invert_tuple
c_func
(paren
r_struct
id|ip_conntrack_tuple
op_star
id|tuple
comma
r_const
r_struct
id|ip_conntrack_tuple
op_star
id|orig
)paren
(brace
id|tuple-&gt;src.u.tcp.port
op_assign
id|orig-&gt;dst.u.tcp.port
suffix:semicolon
id|tuple-&gt;dst.u.tcp.port
op_assign
id|orig-&gt;src.u.tcp.port
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Print out the per-protocol part of the tuple. */
DECL|function|tcp_print_tuple
r_static
r_int
r_int
id|tcp_print_tuple
c_func
(paren
r_char
op_star
id|buffer
comma
r_const
r_struct
id|ip_conntrack_tuple
op_star
id|tuple
)paren
(brace
r_return
id|sprintf
c_func
(paren
id|buffer
comma
l_string|&quot;sport=%hu dport=%hu &quot;
comma
id|ntohs
c_func
(paren
id|tuple-&gt;src.u.tcp.port
)paren
comma
id|ntohs
c_func
(paren
id|tuple-&gt;dst.u.tcp.port
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Print out the private part of the conntrack. */
DECL|function|tcp_print_conntrack
r_static
r_int
r_int
id|tcp_print_conntrack
c_func
(paren
r_char
op_star
id|buffer
comma
r_const
r_struct
id|ip_conntrack
op_star
id|conntrack
)paren
(brace
r_enum
id|tcp_conntrack
id|state
suffix:semicolon
id|READ_LOCK
c_func
(paren
op_amp
id|tcp_lock
)paren
suffix:semicolon
id|state
op_assign
id|conntrack-&gt;proto.tcp.state
suffix:semicolon
id|READ_UNLOCK
c_func
(paren
op_amp
id|tcp_lock
)paren
suffix:semicolon
r_return
id|sprintf
c_func
(paren
id|buffer
comma
l_string|&quot;%s &quot;
comma
id|tcp_conntrack_names
(braket
id|state
)braket
)paren
suffix:semicolon
)brace
DECL|function|get_conntrack_index
r_static
r_int
r_int
id|get_conntrack_index
c_func
(paren
r_const
r_struct
id|tcphdr
op_star
id|tcph
)paren
(brace
r_if
c_cond
(paren
id|tcph-&gt;rst
)paren
r_return
id|TCP_RST_SET
suffix:semicolon
r_else
r_if
c_cond
(paren
id|tcph-&gt;syn
)paren
r_return
(paren
id|tcph-&gt;ack
ques
c_cond
id|TCP_SYNACK_SET
suffix:colon
id|TCP_SYN_SET
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|tcph-&gt;fin
)paren
r_return
id|TCP_FIN_SET
suffix:semicolon
r_else
r_if
c_cond
(paren
id|tcph-&gt;ack
)paren
r_return
id|TCP_ACK_SET
suffix:semicolon
r_else
r_return
id|TCP_NONE_SET
suffix:semicolon
)brace
multiline_comment|/* TCP connection tracking based on &squot;Real Stateful TCP Packet Filtering&n;   in IP Filter&squot; by Guido van Rooij.&n;   &n;   http://www.nluug.nl/events/sane2000/papers.html&n;   http://www.iae.nl/users/guido/papers/tcp_filtering.ps.gz&n;   &n;   The boundaries and the conditions are slightly changed:&n;   &n;   &t;td_maxend = max(sack + max(win,1)) seen in reply packets&n;&t;td_maxwin = max(max(win, 1)) + (sack - ack) seen in sent packets&n;&t;td_end    = max(seq + len) seen in sent packets&n;   &n;   I. &t;Upper bound for valid data:&t;seq + len &lt;= sender.td_maxend&n;   II. &t;Lower bound for valid data:&t;seq &gt;= sender.td_end - receiver.td_maxwin&n;   III.&t;Upper bound for valid ack:      sack &lt;= receiver.td_end&n;   IV.&t;Lower bound for valid ack:&t;ack &gt;= receiver.td_end - MAXACKWINDOW&n;   &t;&n;   where sack is the highest right edge of sack block found in the packet.&n;   &t;&n;   The upper bound limit for a valid ack is not ignored - &n;   we doesn&squot;t have to deal with fragments. &n;*/
DECL|function|segment_seq_plus_len
r_static
r_inline
id|__u32
id|segment_seq_plus_len
c_func
(paren
id|__u32
id|seq
comma
r_int
id|len
comma
r_struct
id|iphdr
op_star
id|iph
comma
r_struct
id|tcphdr
op_star
id|tcph
)paren
(brace
r_return
(paren
id|seq
op_plus
id|len
op_minus
(paren
id|iph-&gt;ihl
op_plus
id|tcph-&gt;doff
)paren
op_star
l_int|4
op_plus
(paren
id|tcph-&gt;syn
ques
c_cond
l_int|1
suffix:colon
l_int|0
)paren
op_plus
(paren
id|tcph-&gt;fin
ques
c_cond
l_int|1
suffix:colon
l_int|0
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Fixme: what about big packets? */
DECL|macro|MAXACKWINCONST
mdefine_line|#define MAXACKWINCONST&t;&t;&t;66000
DECL|macro|MAXACKWINDOW
mdefine_line|#define MAXACKWINDOW(sender)&t;&t;&t;&t;&t;&t;&bslash;&n;&t;((sender)-&gt;td_maxwin &gt; MAXACKWINCONST ? (sender)-&gt;td_maxwin&t;&bslash;&n;&t;&t;&t;&t;&t;      : MAXACKWINCONST)
multiline_comment|/*&n; * Simplified tcp_parse_options routine from tcp_input.c&n; */
DECL|function|tcp_options
r_static
r_void
id|tcp_options
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|iphdr
op_star
id|iph
comma
r_struct
id|tcphdr
op_star
id|tcph
comma
r_struct
id|ip_ct_tcp_state
op_star
id|state
)paren
(brace
r_int
r_char
id|buff
(braket
(paren
l_int|15
op_star
l_int|4
)paren
op_minus
r_sizeof
(paren
r_struct
id|tcphdr
)paren
)braket
suffix:semicolon
r_int
r_char
op_star
id|ptr
suffix:semicolon
r_int
id|length
op_assign
(paren
id|tcph-&gt;doff
op_star
l_int|4
)paren
op_minus
r_sizeof
(paren
r_struct
id|tcphdr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|length
)paren
r_return
suffix:semicolon
id|ptr
op_assign
id|skb_header_pointer
c_func
(paren
id|skb
comma
(paren
id|iph-&gt;ihl
op_star
l_int|4
)paren
op_plus
r_sizeof
(paren
r_struct
id|tcphdr
)paren
comma
id|length
comma
id|buff
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|ptr
op_eq
l_int|NULL
)paren
suffix:semicolon
id|state-&gt;td_scale
op_assign
id|state-&gt;flags
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|length
OG
l_int|0
)paren
(brace
r_int
id|opcode
op_assign
op_star
id|ptr
op_increment
suffix:semicolon
r_int
id|opsize
suffix:semicolon
r_switch
c_cond
(paren
id|opcode
)paren
(brace
r_case
id|TCPOPT_EOL
suffix:colon
r_return
suffix:semicolon
r_case
id|TCPOPT_NOP
suffix:colon
multiline_comment|/* Ref: RFC 793 section 3.1 */
id|length
op_decrement
suffix:semicolon
r_continue
suffix:semicolon
r_default
suffix:colon
id|opsize
op_assign
op_star
id|ptr
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|opsize
OL
l_int|2
)paren
multiline_comment|/* &quot;silly options&quot; */
r_return
suffix:semicolon
r_if
c_cond
(paren
id|opsize
OG
id|length
)paren
r_break
suffix:semicolon
multiline_comment|/* don&squot;t parse partial options */
r_if
c_cond
(paren
id|opcode
op_eq
id|TCPOPT_SACK_PERM
op_logical_and
id|opsize
op_eq
id|TCPOLEN_SACK_PERM
)paren
id|state-&gt;flags
op_or_assign
id|IP_CT_TCP_FLAG_SACK_PERM
suffix:semicolon
r_else
r_if
c_cond
(paren
id|opcode
op_eq
id|TCPOPT_WINDOW
op_logical_and
id|opsize
op_eq
id|TCPOLEN_WINDOW
)paren
(brace
id|state-&gt;td_scale
op_assign
op_star
(paren
id|u_int8_t
op_star
)paren
id|ptr
suffix:semicolon
r_if
c_cond
(paren
id|state-&gt;td_scale
OG
l_int|14
)paren
(brace
multiline_comment|/* See RFC1323 */
id|state-&gt;td_scale
op_assign
l_int|14
suffix:semicolon
)brace
id|state-&gt;flags
op_or_assign
id|IP_CT_TCP_STATE_FLAG_WINDOW_SCALE
suffix:semicolon
)brace
id|ptr
op_add_assign
id|opsize
op_minus
l_int|2
suffix:semicolon
id|length
op_sub_assign
id|opsize
suffix:semicolon
)brace
)brace
)brace
DECL|function|tcp_sack
r_static
r_void
id|tcp_sack
c_func
(paren
r_struct
id|tcphdr
op_star
id|tcph
comma
id|__u32
op_star
id|sack
)paren
(brace
id|__u32
id|tmp
suffix:semicolon
r_int
r_char
op_star
id|ptr
suffix:semicolon
r_int
id|length
op_assign
(paren
id|tcph-&gt;doff
op_star
l_int|4
)paren
op_minus
r_sizeof
(paren
r_struct
id|tcphdr
)paren
suffix:semicolon
multiline_comment|/* Fast path for timestamp-only option */
r_if
c_cond
(paren
id|length
op_eq
id|TCPOLEN_TSTAMP_ALIGNED
op_star
l_int|4
op_logical_and
op_star
(paren
id|__u32
op_star
)paren
(paren
id|tcph
op_plus
l_int|1
)paren
op_eq
id|__constant_ntohl
c_func
(paren
(paren
id|TCPOPT_NOP
op_lshift
l_int|24
)paren
op_or
(paren
id|TCPOPT_NOP
op_lshift
l_int|16
)paren
op_or
(paren
id|TCPOPT_TIMESTAMP
op_lshift
l_int|8
)paren
op_or
id|TCPOLEN_TIMESTAMP
)paren
)paren
r_return
suffix:semicolon
id|ptr
op_assign
(paren
r_int
r_char
op_star
)paren
(paren
id|tcph
op_plus
l_int|1
)paren
suffix:semicolon
r_while
c_loop
(paren
id|length
OG
l_int|0
)paren
(brace
r_int
id|opcode
op_assign
op_star
id|ptr
op_increment
suffix:semicolon
r_int
id|opsize
comma
id|i
suffix:semicolon
r_switch
c_cond
(paren
id|opcode
)paren
(brace
r_case
id|TCPOPT_EOL
suffix:colon
r_return
suffix:semicolon
r_case
id|TCPOPT_NOP
suffix:colon
multiline_comment|/* Ref: RFC 793 section 3.1 */
id|length
op_decrement
suffix:semicolon
r_continue
suffix:semicolon
r_default
suffix:colon
id|opsize
op_assign
op_star
id|ptr
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|opsize
OL
l_int|2
)paren
multiline_comment|/* &quot;silly options&quot; */
r_return
suffix:semicolon
r_if
c_cond
(paren
id|opsize
OG
id|length
)paren
r_break
suffix:semicolon
multiline_comment|/* don&squot;t parse partial options */
r_if
c_cond
(paren
id|opcode
op_eq
id|TCPOPT_SACK
op_logical_and
id|opsize
op_ge
(paren
id|TCPOLEN_SACK_BASE
op_plus
id|TCPOLEN_SACK_PERBLOCK
)paren
op_logical_and
op_logical_neg
(paren
(paren
id|opsize
op_minus
id|TCPOLEN_SACK_BASE
)paren
op_mod
id|TCPOLEN_SACK_PERBLOCK
)paren
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
id|opsize
op_minus
id|TCPOLEN_SACK_BASE
)paren
suffix:semicolon
id|i
op_add_assign
id|TCPOLEN_SACK_PERBLOCK
)paren
(brace
id|tmp
op_assign
id|ntohl
c_func
(paren
op_star
(paren
(paren
id|u_int32_t
op_star
)paren
(paren
id|ptr
op_plus
id|i
)paren
op_plus
l_int|1
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|after
c_func
(paren
id|tmp
comma
op_star
id|sack
)paren
)paren
op_star
id|sack
op_assign
id|tmp
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
id|ptr
op_add_assign
id|opsize
op_minus
l_int|2
suffix:semicolon
id|length
op_sub_assign
id|opsize
suffix:semicolon
)brace
)brace
)brace
DECL|function|tcp_in_window
r_static
r_int
id|tcp_in_window
c_func
(paren
r_struct
id|ip_ct_tcp
op_star
id|state
comma
r_enum
id|ip_conntrack_dir
id|dir
comma
r_int
r_int
op_star
id|index
comma
r_const
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|iphdr
op_star
id|iph
comma
r_struct
id|tcphdr
op_star
id|tcph
)paren
(brace
r_struct
id|ip_ct_tcp_state
op_star
id|sender
op_assign
op_amp
id|state-&gt;seen
(braket
id|dir
)braket
suffix:semicolon
r_struct
id|ip_ct_tcp_state
op_star
id|receiver
op_assign
op_amp
id|state-&gt;seen
(braket
op_logical_neg
id|dir
)braket
suffix:semicolon
id|__u32
id|seq
comma
id|ack
comma
id|sack
comma
id|end
comma
id|win
comma
id|swin
suffix:semicolon
r_int
id|res
suffix:semicolon
multiline_comment|/*&n;&t; * Get the required data from the packet.&n;&t; */
id|seq
op_assign
id|ntohl
c_func
(paren
id|tcph-&gt;seq
)paren
suffix:semicolon
id|ack
op_assign
id|sack
op_assign
id|ntohl
c_func
(paren
id|tcph-&gt;ack_seq
)paren
suffix:semicolon
id|win
op_assign
id|ntohs
c_func
(paren
id|tcph-&gt;window
)paren
suffix:semicolon
id|end
op_assign
id|segment_seq_plus_len
c_func
(paren
id|seq
comma
id|skb-&gt;len
comma
id|iph
comma
id|tcph
)paren
suffix:semicolon
r_if
c_cond
(paren
id|receiver-&gt;flags
op_amp
id|IP_CT_TCP_FLAG_SACK_PERM
)paren
id|tcp_sack
c_func
(paren
id|tcph
comma
op_amp
id|sack
)paren
suffix:semicolon
id|DEBUGP
c_func
(paren
l_string|&quot;tcp_in_window: START&bslash;n&quot;
)paren
suffix:semicolon
id|DEBUGP
c_func
(paren
l_string|&quot;tcp_in_window: src=%u.%u.%u.%u:%hu dst=%u.%u.%u.%u:%hu &quot;
l_string|&quot;seq=%u ack=%u sack=%u win=%u end=%u&bslash;n&quot;
comma
id|NIPQUAD
c_func
(paren
id|iph-&gt;saddr
)paren
comma
id|ntohs
c_func
(paren
id|tcph-&gt;source
)paren
comma
id|NIPQUAD
c_func
(paren
id|iph-&gt;daddr
)paren
comma
id|ntohs
c_func
(paren
id|tcph-&gt;dest
)paren
comma
id|seq
comma
id|ack
comma
id|sack
comma
id|win
comma
id|end
)paren
suffix:semicolon
id|DEBUGP
c_func
(paren
l_string|&quot;tcp_in_window: sender end=%u maxend=%u maxwin=%u scale=%i &quot;
l_string|&quot;receiver end=%u maxend=%u maxwin=%u scale=%i&bslash;n&quot;
comma
id|sender-&gt;td_end
comma
id|sender-&gt;td_maxend
comma
id|sender-&gt;td_maxwin
comma
id|sender-&gt;td_scale
comma
id|receiver-&gt;td_end
comma
id|receiver-&gt;td_maxend
comma
id|receiver-&gt;td_maxwin
comma
id|receiver-&gt;td_scale
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sender-&gt;td_end
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * Initialize sender data.&n;&t;&t; */
r_if
c_cond
(paren
id|tcph-&gt;syn
op_logical_and
id|tcph-&gt;ack
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Outgoing SYN-ACK in reply to a SYN.&n;&t;&t;&t; */
id|sender-&gt;td_end
op_assign
id|sender-&gt;td_maxend
op_assign
id|end
suffix:semicolon
id|sender-&gt;td_maxwin
op_assign
(paren
id|win
op_eq
l_int|0
ques
c_cond
l_int|1
suffix:colon
id|win
)paren
suffix:semicolon
id|tcp_options
c_func
(paren
id|skb
comma
id|iph
comma
id|tcph
comma
id|sender
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t; * RFC 1323:&n;&t;&t;&t; * Both sides must send the Window Scale option&n;&t;&t;&t; * to enable window scaling in either direction.&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|sender-&gt;flags
op_amp
id|IP_CT_TCP_STATE_FLAG_WINDOW_SCALE
op_logical_and
id|receiver-&gt;flags
op_amp
id|IP_CT_TCP_STATE_FLAG_WINDOW_SCALE
)paren
)paren
id|sender-&gt;td_scale
op_assign
id|receiver-&gt;td_scale
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; * We are in the middle of a connection,&n;&t;&t;&t; * its history is lost for us.&n;&t;&t;&t; * Let&squot;s try to use the data from the packet.&n;&t;&t; &t; */
id|sender-&gt;td_end
op_assign
id|end
suffix:semicolon
id|sender-&gt;td_maxwin
op_assign
(paren
id|win
op_eq
l_int|0
ques
c_cond
l_int|1
suffix:colon
id|win
)paren
suffix:semicolon
id|sender-&gt;td_maxend
op_assign
id|end
op_plus
id|sender-&gt;td_maxwin
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|state-&gt;state
op_eq
id|TCP_CONNTRACK_SYN_SENT
op_logical_and
id|dir
op_eq
id|IP_CT_DIR_ORIGINAL
op_logical_and
id|after
c_func
(paren
id|end
comma
id|sender-&gt;td_end
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * RFC 793: &quot;if a TCP is reinitialized ... then it need&n;&t;&t; * not wait at all; it must only be sure to use sequence &n;&t;&t; * numbers larger than those recently used.&quot;&n;&t;&t; */
id|sender-&gt;td_end
op_assign
id|sender-&gt;td_maxend
op_assign
id|end
suffix:semicolon
id|sender-&gt;td_maxwin
op_assign
(paren
id|win
op_eq
l_int|0
ques
c_cond
l_int|1
suffix:colon
id|win
)paren
suffix:semicolon
id|tcp_options
c_func
(paren
id|skb
comma
id|iph
comma
id|tcph
comma
id|sender
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|tcph-&gt;ack
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * If there is no ACK, just pretend it was set and OK.&n;&t;&t; */
id|ack
op_assign
id|sack
op_assign
id|receiver-&gt;td_end
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
(paren
id|tcp_flag_word
c_func
(paren
id|tcph
)paren
op_amp
(paren
id|TCP_FLAG_ACK
op_or
id|TCP_FLAG_RST
)paren
)paren
op_eq
(paren
id|TCP_FLAG_ACK
op_or
id|TCP_FLAG_RST
)paren
)paren
op_logical_and
(paren
id|ack
op_eq
l_int|0
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * Broken TCP stacks, that set ACK in RST packets as well&n;&t;&t; * with zero ack value.&n;&t;&t; */
id|ack
op_assign
id|sack
op_assign
id|receiver-&gt;td_end
suffix:semicolon
)brace
r_if
c_cond
(paren
id|seq
op_eq
id|end
)paren
multiline_comment|/*&n;&t;&t; * Packets contains no data: we assume it is valid&n;&t;&t; * and check the ack value only.&n;&t;&t; */
id|seq
op_assign
id|end
op_assign
id|sender-&gt;td_end
suffix:semicolon
id|DEBUGP
c_func
(paren
l_string|&quot;tcp_in_window: src=%u.%u.%u.%u:%hu dst=%u.%u.%u.%u:%hu &quot;
l_string|&quot;seq=%u ack=%u sack =%u win=%u end=%u trim=%u&bslash;n&quot;
comma
id|NIPQUAD
c_func
(paren
id|iph-&gt;saddr
)paren
comma
id|ntohs
c_func
(paren
id|tcph-&gt;source
)paren
comma
id|NIPQUAD
c_func
(paren
id|iph-&gt;daddr
)paren
comma
id|ntohs
c_func
(paren
id|tcph-&gt;dest
)paren
comma
id|seq
comma
id|ack
comma
id|sack
comma
id|win
comma
id|end
comma
id|after
c_func
(paren
id|end
comma
id|sender-&gt;td_maxend
)paren
op_logical_and
id|before
c_func
(paren
id|seq
comma
id|sender-&gt;td_maxend
)paren
ques
c_cond
id|sender-&gt;td_maxend
suffix:colon
id|end
)paren
suffix:semicolon
id|DEBUGP
c_func
(paren
l_string|&quot;tcp_in_window: sender end=%u maxend=%u maxwin=%u scale=%i &quot;
l_string|&quot;receiver end=%u maxend=%u maxwin=%u scale=%i&bslash;n&quot;
comma
id|sender-&gt;td_end
comma
id|sender-&gt;td_maxend
comma
id|sender-&gt;td_maxwin
comma
id|sender-&gt;td_scale
comma
id|receiver-&gt;td_end
comma
id|receiver-&gt;td_maxend
comma
id|receiver-&gt;td_maxwin
comma
id|receiver-&gt;td_scale
)paren
suffix:semicolon
multiline_comment|/* Ignore data over the right edge of the receiver&squot;s window. */
r_if
c_cond
(paren
id|after
c_func
(paren
id|end
comma
id|sender-&gt;td_maxend
)paren
op_logical_and
id|before
c_func
(paren
id|seq
comma
id|sender-&gt;td_maxend
)paren
)paren
(brace
id|end
op_assign
id|sender-&gt;td_maxend
suffix:semicolon
r_if
c_cond
(paren
op_star
id|index
op_eq
id|TCP_FIN_SET
)paren
op_star
id|index
op_assign
id|TCP_ACK_SET
suffix:semicolon
)brace
id|DEBUGP
c_func
(paren
l_string|&quot;tcp_in_window: I=%i II=%i III=%i IV=%i&bslash;n&quot;
comma
id|before
c_func
(paren
id|end
comma
id|sender-&gt;td_maxend
op_plus
l_int|1
)paren
op_logical_or
id|before
c_func
(paren
id|seq
comma
id|sender-&gt;td_maxend
op_plus
l_int|1
)paren
comma
id|after
c_func
(paren
id|seq
comma
id|sender-&gt;td_end
op_minus
id|receiver-&gt;td_maxwin
op_minus
l_int|1
)paren
op_logical_or
id|after
c_func
(paren
id|end
comma
id|sender-&gt;td_end
op_minus
id|receiver-&gt;td_maxwin
op_minus
l_int|1
)paren
comma
id|before
c_func
(paren
id|sack
comma
id|receiver-&gt;td_end
op_plus
l_int|1
)paren
comma
id|after
c_func
(paren
id|ack
comma
id|receiver-&gt;td_end
op_minus
id|MAXACKWINDOW
c_func
(paren
id|sender
)paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sender-&gt;loose
op_logical_or
id|receiver-&gt;loose
op_logical_or
(paren
id|before
c_func
(paren
id|end
comma
id|sender-&gt;td_maxend
op_plus
l_int|1
)paren
op_logical_and
id|after
c_func
(paren
id|seq
comma
id|sender-&gt;td_end
op_minus
id|receiver-&gt;td_maxwin
op_minus
l_int|1
)paren
op_logical_and
id|before
c_func
(paren
id|sack
comma
id|receiver-&gt;td_end
op_plus
l_int|1
)paren
op_logical_and
id|after
c_func
(paren
id|ack
comma
id|receiver-&gt;td_end
op_minus
id|MAXACKWINDOW
c_func
(paren
id|sender
)paren
)paren
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * Take into account window scaling (RFC 1323).&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|tcph-&gt;syn
)paren
id|win
op_lshift_assign
id|sender-&gt;td_scale
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Update sender data.&n;&t;&t; */
id|swin
op_assign
id|win
op_plus
(paren
id|sack
op_minus
id|ack
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sender-&gt;td_maxwin
OL
id|swin
)paren
id|sender-&gt;td_maxwin
op_assign
id|swin
suffix:semicolon
r_if
c_cond
(paren
id|after
c_func
(paren
id|end
comma
id|sender-&gt;td_end
)paren
)paren
id|sender-&gt;td_end
op_assign
id|end
suffix:semicolon
r_if
c_cond
(paren
id|after
c_func
(paren
id|sack
op_plus
id|win
comma
id|receiver-&gt;td_maxend
op_minus
l_int|1
)paren
)paren
(brace
id|receiver-&gt;td_maxend
op_assign
id|sack
op_plus
id|win
suffix:semicolon
r_if
c_cond
(paren
id|win
op_eq
l_int|0
)paren
id|receiver-&gt;td_maxend
op_increment
suffix:semicolon
)brace
multiline_comment|/* &n;&t;&t; * Check retransmissions.&n;&t;&t; */
r_if
c_cond
(paren
op_star
id|index
op_eq
id|TCP_ACK_SET
)paren
(brace
r_if
c_cond
(paren
id|state-&gt;last_dir
op_eq
id|dir
op_logical_and
id|state-&gt;last_seq
op_eq
id|seq
op_logical_and
id|state-&gt;last_end
op_eq
id|end
)paren
id|state-&gt;retrans
op_increment
suffix:semicolon
r_else
(brace
id|state-&gt;last_dir
op_assign
id|dir
suffix:semicolon
id|state-&gt;last_seq
op_assign
id|seq
suffix:semicolon
id|state-&gt;last_end
op_assign
id|end
suffix:semicolon
id|state-&gt;retrans
op_assign
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t; * Close the window of disabled window tracking :-)&n;&t;&t; */
r_if
c_cond
(paren
id|sender-&gt;loose
)paren
id|sender-&gt;loose
op_decrement
suffix:semicolon
id|res
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|LOG_INVALID
c_func
(paren
id|IPPROTO_TCP
)paren
)paren
id|nf_log_packet
c_func
(paren
id|PF_INET
comma
l_int|0
comma
id|skb
comma
l_int|NULL
comma
l_int|NULL
comma
l_string|&quot;ip_ct_tcp: %s &quot;
comma
id|before
c_func
(paren
id|end
comma
id|sender-&gt;td_maxend
op_plus
l_int|1
)paren
ques
c_cond
id|after
c_func
(paren
id|seq
comma
id|sender-&gt;td_end
op_minus
id|receiver-&gt;td_maxwin
op_minus
l_int|1
)paren
ques
c_cond
id|before
c_func
(paren
id|ack
comma
id|receiver-&gt;td_end
op_plus
l_int|1
)paren
ques
c_cond
id|after
c_func
(paren
id|ack
comma
id|receiver-&gt;td_end
op_minus
id|MAXACKWINDOW
c_func
(paren
id|sender
)paren
)paren
ques
c_cond
l_string|&quot;BUG&quot;
suffix:colon
l_string|&quot;ACK is under the lower bound (possibly overly delayed ACK)&quot;
suffix:colon
l_string|&quot;ACK is over the upper bound (ACKed data has never seen yet)&quot;
suffix:colon
l_string|&quot;SEQ is under the lower bound (retransmitted already ACKed data)&quot;
suffix:colon
l_string|&quot;SEQ is over the upper bound (over the window of the receiver)&quot;
)paren
suffix:semicolon
id|res
op_assign
id|ip_ct_tcp_be_liberal
op_logical_and
op_logical_neg
id|tcph-&gt;rst
suffix:semicolon
)brace
id|DEBUGP
c_func
(paren
l_string|&quot;tcp_in_window: res=%i sender end=%u maxend=%u maxwin=%u &quot;
l_string|&quot;receiver end=%u maxend=%u maxwin=%u&bslash;n&quot;
comma
id|res
comma
id|sender-&gt;td_end
comma
id|sender-&gt;td_maxend
comma
id|sender-&gt;td_maxwin
comma
id|receiver-&gt;td_end
comma
id|receiver-&gt;td_maxend
comma
id|receiver-&gt;td_maxwin
)paren
suffix:semicolon
r_return
id|res
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_IP_NF_NAT_NEEDED
multiline_comment|/* Update sender-&gt;td_end after NAT successfully mangled the packet */
DECL|function|ip_conntrack_tcp_update
r_int
id|ip_conntrack_tcp_update
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|ip_conntrack
op_star
id|conntrack
comma
r_int
id|dir
)paren
(brace
r_struct
id|iphdr
op_star
id|iph
op_assign
id|skb-&gt;nh.iph
suffix:semicolon
r_struct
id|tcphdr
op_star
id|tcph
op_assign
(paren
r_void
op_star
)paren
id|skb-&gt;nh.iph
op_plus
id|skb-&gt;nh.iph-&gt;ihl
op_star
l_int|4
suffix:semicolon
id|__u32
id|end
suffix:semicolon
macro_line|#ifdef DEBUGP_VARS
r_struct
id|ip_ct_tcp_state
op_star
id|sender
op_assign
op_amp
id|conntrack-&gt;proto.tcp.seen
(braket
id|dir
)braket
suffix:semicolon
r_struct
id|ip_ct_tcp_state
op_star
id|receiver
op_assign
op_amp
id|conntrack-&gt;proto.tcp.seen
(braket
op_logical_neg
id|dir
)braket
suffix:semicolon
macro_line|#endif
id|end
op_assign
id|segment_seq_plus_len
c_func
(paren
id|ntohl
c_func
(paren
id|tcph-&gt;seq
)paren
comma
id|skb-&gt;len
comma
id|iph
comma
id|tcph
)paren
suffix:semicolon
id|WRITE_LOCK
c_func
(paren
op_amp
id|tcp_lock
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We have to worry for the ack in the reply packet only...&n;&t; */
r_if
c_cond
(paren
id|after
c_func
(paren
id|end
comma
id|conntrack-&gt;proto.tcp.seen
(braket
id|dir
)braket
dot
id|td_end
)paren
)paren
id|conntrack-&gt;proto.tcp.seen
(braket
id|dir
)braket
dot
id|td_end
op_assign
id|end
suffix:semicolon
id|conntrack-&gt;proto.tcp.last_end
op_assign
id|end
suffix:semicolon
id|WRITE_UNLOCK
c_func
(paren
op_amp
id|tcp_lock
)paren
suffix:semicolon
id|DEBUGP
c_func
(paren
l_string|&quot;tcp_update: sender end=%u maxend=%u maxwin=%u scale=%i &quot;
l_string|&quot;receiver end=%u maxend=%u maxwin=%u scale=%i&bslash;n&quot;
comma
id|sender-&gt;td_end
comma
id|sender-&gt;td_maxend
comma
id|sender-&gt;td_maxwin
comma
id|sender-&gt;td_scale
comma
id|receiver-&gt;td_end
comma
id|receiver-&gt;td_maxend
comma
id|receiver-&gt;td_maxwin
comma
id|receiver-&gt;td_scale
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|variable|ip_conntrack_tcp_update
id|EXPORT_SYMBOL
c_func
(paren
id|ip_conntrack_tcp_update
)paren
suffix:semicolon
macro_line|#endif
DECL|macro|TH_FIN
mdefine_line|#define&t;TH_FIN&t;0x01
DECL|macro|TH_SYN
mdefine_line|#define&t;TH_SYN&t;0x02
DECL|macro|TH_RST
mdefine_line|#define&t;TH_RST&t;0x04
DECL|macro|TH_PUSH
mdefine_line|#define&t;TH_PUSH&t;0x08
DECL|macro|TH_ACK
mdefine_line|#define&t;TH_ACK&t;0x10
DECL|macro|TH_URG
mdefine_line|#define&t;TH_URG&t;0x20
DECL|macro|TH_ECE
mdefine_line|#define&t;TH_ECE&t;0x40
DECL|macro|TH_CWR
mdefine_line|#define&t;TH_CWR&t;0x80
multiline_comment|/* table of valid flag combinations - ECE and CWR are always valid */
DECL|variable|tcp_valid_flags
r_static
id|u8
id|tcp_valid_flags
(braket
(paren
id|TH_FIN
op_or
id|TH_SYN
op_or
id|TH_RST
op_or
id|TH_PUSH
op_or
id|TH_ACK
op_or
id|TH_URG
)paren
op_plus
l_int|1
)braket
op_assign
(brace
(braket
id|TH_SYN
)braket
op_assign
l_int|1
comma
(braket
id|TH_SYN
op_or
id|TH_ACK
)braket
op_assign
l_int|1
comma
(braket
id|TH_RST
)braket
op_assign
l_int|1
comma
(braket
id|TH_RST
op_or
id|TH_ACK
)braket
op_assign
l_int|1
comma
(braket
id|TH_RST
op_or
id|TH_ACK
op_or
id|TH_PUSH
)braket
op_assign
l_int|1
comma
(braket
id|TH_FIN
op_or
id|TH_ACK
)braket
op_assign
l_int|1
comma
(braket
id|TH_ACK
)braket
op_assign
l_int|1
comma
(braket
id|TH_ACK
op_or
id|TH_PUSH
)braket
op_assign
l_int|1
comma
(braket
id|TH_ACK
op_or
id|TH_URG
)braket
op_assign
l_int|1
comma
(braket
id|TH_ACK
op_or
id|TH_URG
op_or
id|TH_PUSH
)braket
op_assign
l_int|1
comma
(braket
id|TH_FIN
op_or
id|TH_ACK
op_or
id|TH_PUSH
)braket
op_assign
l_int|1
comma
(braket
id|TH_FIN
op_or
id|TH_ACK
op_or
id|TH_URG
)braket
op_assign
l_int|1
comma
(braket
id|TH_FIN
op_or
id|TH_ACK
op_or
id|TH_URG
op_or
id|TH_PUSH
)braket
op_assign
l_int|1
comma
)brace
suffix:semicolon
multiline_comment|/* Protect conntrack agaist broken packets. Code taken from ipt_unclean.c.  */
DECL|function|tcp_error
r_static
r_int
id|tcp_error
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_enum
id|ip_conntrack_info
op_star
id|ctinfo
comma
r_int
r_int
id|hooknum
)paren
(brace
r_struct
id|iphdr
op_star
id|iph
op_assign
id|skb-&gt;nh.iph
suffix:semicolon
r_struct
id|tcphdr
id|_tcph
comma
op_star
id|th
suffix:semicolon
r_int
r_int
id|tcplen
op_assign
id|skb-&gt;len
op_minus
id|iph-&gt;ihl
op_star
l_int|4
suffix:semicolon
id|u_int8_t
id|tcpflags
suffix:semicolon
multiline_comment|/* Smaller that minimal TCP header? */
id|th
op_assign
id|skb_header_pointer
c_func
(paren
id|skb
comma
id|iph-&gt;ihl
op_star
l_int|4
comma
r_sizeof
(paren
id|_tcph
)paren
comma
op_amp
id|_tcph
)paren
suffix:semicolon
r_if
c_cond
(paren
id|th
op_eq
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|LOG_INVALID
c_func
(paren
id|IPPROTO_TCP
)paren
)paren
id|nf_log_packet
c_func
(paren
id|PF_INET
comma
l_int|0
comma
id|skb
comma
l_int|NULL
comma
l_int|NULL
comma
l_string|&quot;ip_ct_tcp: short packet &quot;
)paren
suffix:semicolon
r_return
op_minus
id|NF_ACCEPT
suffix:semicolon
)brace
multiline_comment|/* Not whole TCP header or malformed packet */
r_if
c_cond
(paren
id|th-&gt;doff
op_star
l_int|4
OL
r_sizeof
(paren
r_struct
id|tcphdr
)paren
op_logical_or
id|tcplen
OL
id|th-&gt;doff
op_star
l_int|4
)paren
(brace
r_if
c_cond
(paren
id|LOG_INVALID
c_func
(paren
id|IPPROTO_TCP
)paren
)paren
id|nf_log_packet
c_func
(paren
id|PF_INET
comma
l_int|0
comma
id|skb
comma
l_int|NULL
comma
l_int|NULL
comma
l_string|&quot;ip_ct_tcp: truncated/malformed packet &quot;
)paren
suffix:semicolon
r_return
op_minus
id|NF_ACCEPT
suffix:semicolon
)brace
multiline_comment|/* Checksum invalid? Ignore.&n;&t; * We skip checking packets on the outgoing path&n;&t; * because the semantic of CHECKSUM_HW is different there &n;&t; * and moreover root might send raw packets.&n;&t; */
multiline_comment|/* FIXME: Source route IP option packets --RR */
r_if
c_cond
(paren
id|hooknum
op_eq
id|NF_IP_PRE_ROUTING
op_logical_and
id|csum_tcpudp_magic
c_func
(paren
id|iph-&gt;saddr
comma
id|iph-&gt;daddr
comma
id|tcplen
comma
id|IPPROTO_TCP
comma
id|skb-&gt;ip_summed
op_eq
id|CHECKSUM_HW
ques
c_cond
id|skb-&gt;csum
suffix:colon
id|skb_checksum
c_func
(paren
id|skb
comma
id|iph-&gt;ihl
op_star
l_int|4
comma
id|tcplen
comma
l_int|0
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|LOG_INVALID
c_func
(paren
id|IPPROTO_TCP
)paren
)paren
id|nf_log_packet
c_func
(paren
id|PF_INET
comma
l_int|0
comma
id|skb
comma
l_int|NULL
comma
l_int|NULL
comma
l_string|&quot;ip_ct_tcp: bad TCP checksum &quot;
)paren
suffix:semicolon
r_return
op_minus
id|NF_ACCEPT
suffix:semicolon
)brace
multiline_comment|/* Check TCP flags. */
id|tcpflags
op_assign
(paren
(paren
(paren
id|u_int8_t
op_star
)paren
id|th
)paren
(braket
l_int|13
)braket
op_amp
op_complement
(paren
id|TH_ECE
op_or
id|TH_CWR
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tcp_valid_flags
(braket
id|tcpflags
)braket
)paren
(brace
r_if
c_cond
(paren
id|LOG_INVALID
c_func
(paren
id|IPPROTO_TCP
)paren
)paren
id|nf_log_packet
c_func
(paren
id|PF_INET
comma
l_int|0
comma
id|skb
comma
l_int|NULL
comma
l_int|NULL
comma
l_string|&quot;ip_ct_tcp: invalid TCP flag combination &quot;
)paren
suffix:semicolon
r_return
op_minus
id|NF_ACCEPT
suffix:semicolon
)brace
r_return
id|NF_ACCEPT
suffix:semicolon
)brace
multiline_comment|/* Returns verdict for packet, or -1 for invalid. */
DECL|function|tcp_packet
r_static
r_int
id|tcp_packet
c_func
(paren
r_struct
id|ip_conntrack
op_star
id|conntrack
comma
r_const
r_struct
id|sk_buff
op_star
id|skb
comma
r_enum
id|ip_conntrack_info
id|ctinfo
)paren
(brace
r_enum
id|tcp_conntrack
id|new_state
comma
id|old_state
suffix:semicolon
r_enum
id|ip_conntrack_dir
id|dir
suffix:semicolon
r_struct
id|iphdr
op_star
id|iph
op_assign
id|skb-&gt;nh.iph
suffix:semicolon
r_struct
id|tcphdr
op_star
id|th
comma
id|_tcph
suffix:semicolon
r_int
r_int
id|timeout
suffix:semicolon
r_int
r_int
id|index
suffix:semicolon
id|th
op_assign
id|skb_header_pointer
c_func
(paren
id|skb
comma
id|iph-&gt;ihl
op_star
l_int|4
comma
r_sizeof
(paren
id|_tcph
)paren
comma
op_amp
id|_tcph
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|th
op_eq
l_int|NULL
)paren
suffix:semicolon
id|WRITE_LOCK
c_func
(paren
op_amp
id|tcp_lock
)paren
suffix:semicolon
id|old_state
op_assign
id|conntrack-&gt;proto.tcp.state
suffix:semicolon
id|dir
op_assign
id|CTINFO2DIR
c_func
(paren
id|ctinfo
)paren
suffix:semicolon
id|index
op_assign
id|get_conntrack_index
c_func
(paren
id|th
)paren
suffix:semicolon
id|new_state
op_assign
id|tcp_conntracks
(braket
id|dir
)braket
(braket
id|index
)braket
(braket
id|old_state
)braket
suffix:semicolon
r_switch
c_cond
(paren
id|new_state
)paren
(brace
r_case
id|TCP_CONNTRACK_IGNORE
suffix:colon
multiline_comment|/* Either SYN in ORIGINAL, or SYN/ACK in REPLY direction. */
r_if
c_cond
(paren
id|index
op_eq
id|TCP_SYNACK_SET
op_logical_and
id|conntrack-&gt;proto.tcp.last_index
op_eq
id|TCP_SYN_SET
op_logical_and
id|conntrack-&gt;proto.tcp.last_dir
op_ne
id|dir
op_logical_and
id|after
c_func
(paren
id|ntohl
c_func
(paren
id|th-&gt;ack_seq
)paren
comma
id|conntrack-&gt;proto.tcp.last_seq
)paren
)paren
(brace
multiline_comment|/* This SYN/ACK acknowledges a SYN that we earlier &n;&t;&t;&t; * ignored as invalid. This means that the client and&n;&t;&t;&t; * the server are both in sync, while the firewall is&n;&t;&t;&t; * not. We kill this session and block the SYN/ACK so&n;&t;&t;&t; * that the client cannot but retransmit its SYN and &n;&t;&t;&t; * thus initiate a clean new session.&n;&t;&t;&t; */
id|WRITE_UNLOCK
c_func
(paren
op_amp
id|tcp_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|LOG_INVALID
c_func
(paren
id|IPPROTO_TCP
)paren
)paren
id|nf_log_packet
c_func
(paren
id|PF_INET
comma
l_int|0
comma
id|skb
comma
l_int|NULL
comma
l_int|NULL
comma
l_string|&quot;ip_ct_tcp: killing out of sync session &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|del_timer
c_func
(paren
op_amp
id|conntrack-&gt;timeout
)paren
)paren
id|conntrack-&gt;timeout
dot
id|function
c_func
(paren
(paren
r_int
r_int
)paren
id|conntrack
)paren
suffix:semicolon
r_return
op_minus
id|NF_DROP
suffix:semicolon
)brace
id|conntrack-&gt;proto.tcp.last_index
op_assign
id|index
suffix:semicolon
id|conntrack-&gt;proto.tcp.last_dir
op_assign
id|dir
suffix:semicolon
id|conntrack-&gt;proto.tcp.last_seq
op_assign
id|ntohl
c_func
(paren
id|th-&gt;seq
)paren
suffix:semicolon
id|WRITE_UNLOCK
c_func
(paren
op_amp
id|tcp_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|LOG_INVALID
c_func
(paren
id|IPPROTO_TCP
)paren
)paren
id|nf_log_packet
c_func
(paren
id|PF_INET
comma
l_int|0
comma
id|skb
comma
l_int|NULL
comma
l_int|NULL
comma
l_string|&quot;ip_ct_tcp: invalid SYN (ignored) &quot;
)paren
suffix:semicolon
r_return
id|NF_ACCEPT
suffix:semicolon
r_case
id|TCP_CONNTRACK_MAX
suffix:colon
multiline_comment|/* Invalid packet */
id|DEBUGP
c_func
(paren
l_string|&quot;ip_ct_tcp: Invalid dir=%i index=%u ostate=%u&bslash;n&quot;
comma
id|dir
comma
id|get_conntrack_index
c_func
(paren
id|th
)paren
comma
id|old_state
)paren
suffix:semicolon
id|WRITE_UNLOCK
c_func
(paren
op_amp
id|tcp_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|LOG_INVALID
c_func
(paren
id|IPPROTO_TCP
)paren
)paren
id|nf_log_packet
c_func
(paren
id|PF_INET
comma
l_int|0
comma
id|skb
comma
l_int|NULL
comma
l_int|NULL
comma
l_string|&quot;ip_ct_tcp: invalid state &quot;
)paren
suffix:semicolon
r_return
op_minus
id|NF_ACCEPT
suffix:semicolon
r_case
id|TCP_CONNTRACK_SYN_SENT
suffix:colon
r_if
c_cond
(paren
id|old_state
op_ge
id|TCP_CONNTRACK_TIME_WAIT
)paren
(brace
multiline_comment|/* Attempt to reopen a closed connection.&n;&t;&t;    &t;* Delete this connection and look up again. */
id|WRITE_UNLOCK
c_func
(paren
op_amp
id|tcp_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|del_timer
c_func
(paren
op_amp
id|conntrack-&gt;timeout
)paren
)paren
id|conntrack-&gt;timeout
dot
id|function
c_func
(paren
(paren
r_int
r_int
)paren
id|conntrack
)paren
suffix:semicolon
r_return
op_minus
id|NF_REPEAT
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|TCP_CONNTRACK_CLOSE
suffix:colon
r_if
c_cond
(paren
id|index
op_eq
id|TCP_RST_SET
op_logical_and
id|test_bit
c_func
(paren
id|IPS_SEEN_REPLY_BIT
comma
op_amp
id|conntrack-&gt;status
)paren
op_logical_and
id|conntrack-&gt;proto.tcp.last_index
op_le
id|TCP_SYNACK_SET
op_logical_and
id|after
c_func
(paren
id|ntohl
c_func
(paren
id|th-&gt;ack_seq
)paren
comma
id|conntrack-&gt;proto.tcp.last_seq
)paren
)paren
(brace
multiline_comment|/* Ignore RST closing down invalid SYN &n;&t;&t;&t;   we had let trough. */
id|WRITE_UNLOCK
c_func
(paren
op_amp
id|tcp_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|LOG_INVALID
c_func
(paren
id|IPPROTO_TCP
)paren
)paren
id|nf_log_packet
c_func
(paren
id|PF_INET
comma
l_int|0
comma
id|skb
comma
l_int|NULL
comma
l_int|NULL
comma
l_string|&quot;ip_ct_tcp: invalid RST (ignored) &quot;
)paren
suffix:semicolon
r_return
id|NF_ACCEPT
suffix:semicolon
)brace
multiline_comment|/* Just fall trough */
r_default
suffix:colon
multiline_comment|/* Keep compilers happy. */
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|tcp_in_window
c_func
(paren
op_amp
id|conntrack-&gt;proto.tcp
comma
id|dir
comma
op_amp
id|index
comma
id|skb
comma
id|iph
comma
id|th
)paren
)paren
(brace
id|WRITE_UNLOCK
c_func
(paren
op_amp
id|tcp_lock
)paren
suffix:semicolon
r_return
op_minus
id|NF_ACCEPT
suffix:semicolon
)brace
multiline_comment|/* From now on we have got in-window packets */
multiline_comment|/* If FIN was trimmed off, we don&squot;t change state. */
id|conntrack-&gt;proto.tcp.last_index
op_assign
id|index
suffix:semicolon
id|new_state
op_assign
id|tcp_conntracks
(braket
id|dir
)braket
(braket
id|index
)braket
(braket
id|old_state
)braket
suffix:semicolon
id|DEBUGP
c_func
(paren
l_string|&quot;tcp_conntracks: src=%u.%u.%u.%u:%hu dst=%u.%u.%u.%u:%hu &quot;
l_string|&quot;syn=%i ack=%i fin=%i rst=%i old=%i new=%i&bslash;n&quot;
comma
id|NIPQUAD
c_func
(paren
id|iph-&gt;saddr
)paren
comma
id|ntohs
c_func
(paren
id|th-&gt;source
)paren
comma
id|NIPQUAD
c_func
(paren
id|iph-&gt;daddr
)paren
comma
id|ntohs
c_func
(paren
id|th-&gt;dest
)paren
comma
(paren
id|th-&gt;syn
ques
c_cond
l_int|1
suffix:colon
l_int|0
)paren
comma
(paren
id|th-&gt;ack
ques
c_cond
l_int|1
suffix:colon
l_int|0
)paren
comma
(paren
id|th-&gt;fin
ques
c_cond
l_int|1
suffix:colon
l_int|0
)paren
comma
(paren
id|th-&gt;rst
ques
c_cond
l_int|1
suffix:colon
l_int|0
)paren
comma
id|old_state
comma
id|new_state
)paren
suffix:semicolon
id|conntrack-&gt;proto.tcp.state
op_assign
id|new_state
suffix:semicolon
id|timeout
op_assign
id|conntrack-&gt;proto.tcp.retrans
op_ge
id|ip_ct_tcp_max_retrans
op_logical_and
op_star
id|tcp_timeouts
(braket
id|new_state
)braket
OG
id|ip_ct_tcp_timeout_max_retrans
ques
c_cond
id|ip_ct_tcp_timeout_max_retrans
suffix:colon
op_star
id|tcp_timeouts
(braket
id|new_state
)braket
suffix:semicolon
id|WRITE_UNLOCK
c_func
(paren
op_amp
id|tcp_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|test_bit
c_func
(paren
id|IPS_SEEN_REPLY_BIT
comma
op_amp
id|conntrack-&gt;status
)paren
)paren
(brace
multiline_comment|/* If only reply is a RST, we can consider ourselves not to&n;&t;&t;   have an established connection: this is a fairly common&n;&t;&t;   problem case, so we can delete the conntrack&n;&t;&t;   immediately.  --RR */
r_if
c_cond
(paren
id|th-&gt;rst
)paren
(brace
r_if
c_cond
(paren
id|del_timer
c_func
(paren
op_amp
id|conntrack-&gt;timeout
)paren
)paren
id|conntrack-&gt;timeout
dot
id|function
c_func
(paren
(paren
r_int
r_int
)paren
id|conntrack
)paren
suffix:semicolon
r_return
id|NF_ACCEPT
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|test_bit
c_func
(paren
id|IPS_ASSURED_BIT
comma
op_amp
id|conntrack-&gt;status
)paren
op_logical_and
(paren
id|old_state
op_eq
id|TCP_CONNTRACK_SYN_RECV
op_logical_or
id|old_state
op_eq
id|TCP_CONNTRACK_ESTABLISHED
)paren
op_logical_and
id|new_state
op_eq
id|TCP_CONNTRACK_ESTABLISHED
)paren
(brace
multiline_comment|/* Set ASSURED if we see see valid ack in ESTABLISHED &n;&t;&t;   after SYN_RECV or a valid answer for a picked up &n;&t;&t;   connection. */
id|set_bit
c_func
(paren
id|IPS_ASSURED_BIT
comma
op_amp
id|conntrack-&gt;status
)paren
suffix:semicolon
)brace
id|ip_ct_refresh_acct
c_func
(paren
id|conntrack
comma
id|ctinfo
comma
id|skb
comma
id|timeout
)paren
suffix:semicolon
r_return
id|NF_ACCEPT
suffix:semicolon
)brace
multiline_comment|/* Called when a new connection for this protocol found. */
DECL|function|tcp_new
r_static
r_int
id|tcp_new
c_func
(paren
r_struct
id|ip_conntrack
op_star
id|conntrack
comma
r_const
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_enum
id|tcp_conntrack
id|new_state
suffix:semicolon
r_struct
id|iphdr
op_star
id|iph
op_assign
id|skb-&gt;nh.iph
suffix:semicolon
r_struct
id|tcphdr
op_star
id|th
comma
id|_tcph
suffix:semicolon
macro_line|#ifdef DEBUGP_VARS
r_struct
id|ip_ct_tcp_state
op_star
id|sender
op_assign
op_amp
id|conntrack-&gt;proto.tcp.seen
(braket
l_int|0
)braket
suffix:semicolon
r_struct
id|ip_ct_tcp_state
op_star
id|receiver
op_assign
op_amp
id|conntrack-&gt;proto.tcp.seen
(braket
l_int|1
)braket
suffix:semicolon
macro_line|#endif
id|th
op_assign
id|skb_header_pointer
c_func
(paren
id|skb
comma
id|iph-&gt;ihl
op_star
l_int|4
comma
r_sizeof
(paren
id|_tcph
)paren
comma
op_amp
id|_tcph
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|th
op_eq
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* Don&squot;t need lock here: this conntrack not in circulation yet */
id|new_state
op_assign
id|tcp_conntracks
(braket
l_int|0
)braket
(braket
id|get_conntrack_index
c_func
(paren
id|th
)paren
)braket
(braket
id|TCP_CONNTRACK_NONE
)braket
suffix:semicolon
multiline_comment|/* Invalid: delete conntrack */
r_if
c_cond
(paren
id|new_state
op_ge
id|TCP_CONNTRACK_MAX
)paren
(brace
id|DEBUGP
c_func
(paren
l_string|&quot;ip_ct_tcp: invalid new deleting.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|new_state
op_eq
id|TCP_CONNTRACK_SYN_SENT
)paren
(brace
multiline_comment|/* SYN packet */
id|conntrack-&gt;proto.tcp.seen
(braket
l_int|0
)braket
dot
id|td_end
op_assign
id|segment_seq_plus_len
c_func
(paren
id|ntohl
c_func
(paren
id|th-&gt;seq
)paren
comma
id|skb-&gt;len
comma
id|iph
comma
id|th
)paren
suffix:semicolon
id|conntrack-&gt;proto.tcp.seen
(braket
l_int|0
)braket
dot
id|td_maxwin
op_assign
id|ntohs
c_func
(paren
id|th-&gt;window
)paren
suffix:semicolon
r_if
c_cond
(paren
id|conntrack-&gt;proto.tcp.seen
(braket
l_int|0
)braket
dot
id|td_maxwin
op_eq
l_int|0
)paren
id|conntrack-&gt;proto.tcp.seen
(braket
l_int|0
)braket
dot
id|td_maxwin
op_assign
l_int|1
suffix:semicolon
id|conntrack-&gt;proto.tcp.seen
(braket
l_int|0
)braket
dot
id|td_maxend
op_assign
id|conntrack-&gt;proto.tcp.seen
(braket
l_int|0
)braket
dot
id|td_end
suffix:semicolon
id|tcp_options
c_func
(paren
id|skb
comma
id|iph
comma
id|th
comma
op_amp
id|conntrack-&gt;proto.tcp.seen
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|conntrack-&gt;proto.tcp.seen
(braket
l_int|1
)braket
dot
id|flags
op_assign
l_int|0
suffix:semicolon
id|conntrack-&gt;proto.tcp.seen
(braket
l_int|0
)braket
dot
id|loose
op_assign
id|conntrack-&gt;proto.tcp.seen
(braket
l_int|1
)braket
dot
id|loose
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ip_ct_tcp_loose
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Don&squot;t try to pick up connections. */
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * We are in the middle of a connection,&n;&t;&t; * its history is lost for us.&n;&t;&t; * Let&squot;s try to use the data from the packet.&n;&t;&t; */
id|conntrack-&gt;proto.tcp.seen
(braket
l_int|0
)braket
dot
id|td_end
op_assign
id|segment_seq_plus_len
c_func
(paren
id|ntohl
c_func
(paren
id|th-&gt;seq
)paren
comma
id|skb-&gt;len
comma
id|iph
comma
id|th
)paren
suffix:semicolon
id|conntrack-&gt;proto.tcp.seen
(braket
l_int|0
)braket
dot
id|td_maxwin
op_assign
id|ntohs
c_func
(paren
id|th-&gt;window
)paren
suffix:semicolon
r_if
c_cond
(paren
id|conntrack-&gt;proto.tcp.seen
(braket
l_int|0
)braket
dot
id|td_maxwin
op_eq
l_int|0
)paren
id|conntrack-&gt;proto.tcp.seen
(braket
l_int|0
)braket
dot
id|td_maxwin
op_assign
l_int|1
suffix:semicolon
id|conntrack-&gt;proto.tcp.seen
(braket
l_int|0
)braket
dot
id|td_maxend
op_assign
id|conntrack-&gt;proto.tcp.seen
(braket
l_int|0
)braket
dot
id|td_end
op_plus
id|conntrack-&gt;proto.tcp.seen
(braket
l_int|0
)braket
dot
id|td_maxwin
suffix:semicolon
id|conntrack-&gt;proto.tcp.seen
(braket
l_int|0
)braket
dot
id|td_scale
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* We assume SACK. Should we assume window scaling too? */
id|conntrack-&gt;proto.tcp.seen
(braket
l_int|0
)braket
dot
id|flags
op_assign
id|conntrack-&gt;proto.tcp.seen
(braket
l_int|1
)braket
dot
id|flags
op_assign
id|IP_CT_TCP_FLAG_SACK_PERM
suffix:semicolon
id|conntrack-&gt;proto.tcp.seen
(braket
l_int|0
)braket
dot
id|loose
op_assign
id|conntrack-&gt;proto.tcp.seen
(braket
l_int|1
)braket
dot
id|loose
op_assign
id|ip_ct_tcp_loose
suffix:semicolon
)brace
id|conntrack-&gt;proto.tcp.seen
(braket
l_int|1
)braket
dot
id|td_end
op_assign
l_int|0
suffix:semicolon
id|conntrack-&gt;proto.tcp.seen
(braket
l_int|1
)braket
dot
id|td_maxend
op_assign
l_int|0
suffix:semicolon
id|conntrack-&gt;proto.tcp.seen
(braket
l_int|1
)braket
dot
id|td_maxwin
op_assign
l_int|1
suffix:semicolon
id|conntrack-&gt;proto.tcp.seen
(braket
l_int|1
)braket
dot
id|td_scale
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* tcp_packet will set them */
id|conntrack-&gt;proto.tcp.state
op_assign
id|TCP_CONNTRACK_NONE
suffix:semicolon
id|conntrack-&gt;proto.tcp.last_index
op_assign
id|TCP_NONE_SET
suffix:semicolon
id|DEBUGP
c_func
(paren
l_string|&quot;tcp_new: sender end=%u maxend=%u maxwin=%u scale=%i &quot;
l_string|&quot;receiver end=%u maxend=%u maxwin=%u scale=%i&bslash;n&quot;
comma
id|sender-&gt;td_end
comma
id|sender-&gt;td_maxend
comma
id|sender-&gt;td_maxwin
comma
id|sender-&gt;td_scale
comma
id|receiver-&gt;td_end
comma
id|receiver-&gt;td_maxend
comma
id|receiver-&gt;td_maxwin
comma
id|receiver-&gt;td_scale
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|tcp_exp_matches_pkt
r_static
r_int
id|tcp_exp_matches_pkt
c_func
(paren
r_struct
id|ip_conntrack_expect
op_star
id|exp
comma
r_const
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_const
r_struct
id|iphdr
op_star
id|iph
op_assign
id|skb-&gt;nh.iph
suffix:semicolon
r_struct
id|tcphdr
op_star
id|th
comma
id|_tcph
suffix:semicolon
r_int
r_int
id|datalen
suffix:semicolon
id|th
op_assign
id|skb_header_pointer
c_func
(paren
id|skb
comma
id|iph-&gt;ihl
op_star
l_int|4
comma
r_sizeof
(paren
id|_tcph
)paren
comma
op_amp
id|_tcph
)paren
suffix:semicolon
r_if
c_cond
(paren
id|th
op_eq
l_int|NULL
)paren
r_return
l_int|0
suffix:semicolon
id|datalen
op_assign
id|skb-&gt;len
op_minus
id|iph-&gt;ihl
op_star
l_int|4
op_minus
id|th-&gt;doff
op_star
l_int|4
suffix:semicolon
r_return
id|between
c_func
(paren
id|exp-&gt;seq
comma
id|ntohl
c_func
(paren
id|th-&gt;seq
)paren
comma
id|ntohl
c_func
(paren
id|th-&gt;seq
)paren
op_plus
id|datalen
)paren
suffix:semicolon
)brace
DECL|variable|ip_conntrack_protocol_tcp
r_struct
id|ip_conntrack_protocol
id|ip_conntrack_protocol_tcp
op_assign
(brace
dot
id|proto
op_assign
id|IPPROTO_TCP
comma
dot
id|name
op_assign
l_string|&quot;tcp&quot;
comma
dot
id|pkt_to_tuple
op_assign
id|tcp_pkt_to_tuple
comma
dot
id|invert_tuple
op_assign
id|tcp_invert_tuple
comma
dot
id|print_tuple
op_assign
id|tcp_print_tuple
comma
dot
id|print_conntrack
op_assign
id|tcp_print_conntrack
comma
dot
id|packet
op_assign
id|tcp_packet
comma
dot
r_new
op_assign
id|tcp_new
comma
dot
id|exp_matches_pkt
op_assign
id|tcp_exp_matches_pkt
comma
dot
id|error
op_assign
id|tcp_error
comma
)brace
suffix:semicolon
eof
