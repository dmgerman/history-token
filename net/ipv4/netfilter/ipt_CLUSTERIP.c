multiline_comment|/* Cluster IP hashmark target &n; * (C) 2003-2004 by Harald Welte &lt;laforge@netfilter.org&gt;&n; * based on ideas of Fabio Olive Leite &lt;olive@unixforge.org&gt;&n; *&n; * Development of this code funded by SuSE Linux AG, http://www.suse.com/&n; *&n; * This program is free software; you can redistribute it and/or modify&n; * it under the terms of the GNU General Public License version 2 as&n; * published by the Free Software Foundation.&n; *&n; */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;linux/jhash.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;linux/ip.h&gt;
macro_line|#include &lt;linux/tcp.h&gt;
macro_line|#include &lt;linux/udp.h&gt;
macro_line|#include &lt;linux/icmp.h&gt;
macro_line|#include &lt;linux/if_arp.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;linux/seq_file.h&gt;
macro_line|#include &lt;net/checksum.h&gt;
macro_line|#include &lt;linux/netfilter_arp.h&gt;
macro_line|#include &lt;linux/netfilter_ipv4/ip_tables.h&gt;
macro_line|#include &lt;linux/netfilter_ipv4/ipt_CLUSTERIP.h&gt;
macro_line|#include &lt;linux/netfilter_ipv4/ip_conntrack.h&gt;
macro_line|#include &lt;linux/netfilter_ipv4/lockhelp.h&gt;
DECL|macro|CLUSTERIP_VERSION
mdefine_line|#define CLUSTERIP_VERSION &quot;0.6&quot;
DECL|macro|DEBUG_CLUSTERIP
mdefine_line|#define DEBUG_CLUSTERIP
macro_line|#ifdef DEBUG_CLUSTERIP
DECL|macro|DEBUGP
mdefine_line|#define DEBUGP&t;printk
macro_line|#else
DECL|macro|DEBUGP
mdefine_line|#define DEBUGP
macro_line|#endif
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Harald Welte &lt;laforge@netfilter.org&gt;&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;iptables target for CLUSTERIP&quot;
)paren
suffix:semicolon
DECL|struct|clusterip_config
r_struct
id|clusterip_config
(brace
DECL|member|list
r_struct
id|list_head
id|list
suffix:semicolon
multiline_comment|/* list of all configs */
DECL|member|refcount
id|atomic_t
id|refcount
suffix:semicolon
multiline_comment|/* reference count */
DECL|member|clusterip
id|u_int32_t
id|clusterip
suffix:semicolon
multiline_comment|/* the IP address */
DECL|member|clustermac
id|u_int8_t
id|clustermac
(braket
id|ETH_ALEN
)braket
suffix:semicolon
multiline_comment|/* the MAC address */
DECL|member|dev
r_struct
id|net_device
op_star
id|dev
suffix:semicolon
multiline_comment|/* device */
DECL|member|num_total_nodes
id|u_int16_t
id|num_total_nodes
suffix:semicolon
multiline_comment|/* total number of nodes */
DECL|member|num_local_nodes
id|u_int16_t
id|num_local_nodes
suffix:semicolon
multiline_comment|/* number of local nodes */
DECL|member|local_nodes
id|u_int16_t
id|local_nodes
(braket
id|CLUSTERIP_MAX_NODES
)braket
suffix:semicolon
multiline_comment|/* node number array */
macro_line|#ifdef CONFIG_PROC_FS
DECL|member|pde
r_struct
id|proc_dir_entry
op_star
id|pde
suffix:semicolon
multiline_comment|/* proc dir entry */
macro_line|#endif
DECL|member|hash_mode
r_enum
id|clusterip_hashmode
id|hash_mode
suffix:semicolon
multiline_comment|/* which hashing mode */
DECL|member|hash_initval
id|u_int32_t
id|hash_initval
suffix:semicolon
multiline_comment|/* hash initialization */
)brace
suffix:semicolon
r_static
id|LIST_HEAD
c_func
(paren
id|clusterip_configs
)paren
suffix:semicolon
multiline_comment|/* clusterip_lock protects the clusterip_configs list _AND_ the configurable&n; * data within all structurses (num_local_nodes, local_nodes[]) */
r_static
id|DECLARE_RWLOCK
c_func
(paren
id|clusterip_lock
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_PROC_FS
DECL|variable|clusterip_proc_fops
r_static
r_struct
id|file_operations
id|clusterip_proc_fops
suffix:semicolon
DECL|variable|clusterip_procdir
r_static
r_struct
id|proc_dir_entry
op_star
id|clusterip_procdir
suffix:semicolon
macro_line|#endif
r_static
r_inline
r_void
DECL|function|clusterip_config_get
id|clusterip_config_get
c_func
(paren
r_struct
id|clusterip_config
op_star
id|c
)paren
(brace
id|atomic_inc
c_func
(paren
op_amp
id|c-&gt;refcount
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|clusterip_config_put
id|clusterip_config_put
c_func
(paren
r_struct
id|clusterip_config
op_star
id|c
)paren
(brace
r_if
c_cond
(paren
id|atomic_dec_and_test
c_func
(paren
op_amp
id|c-&gt;refcount
)paren
)paren
(brace
id|WRITE_LOCK
c_func
(paren
op_amp
id|clusterip_lock
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|c-&gt;list
)paren
suffix:semicolon
id|WRITE_UNLOCK
c_func
(paren
op_amp
id|clusterip_lock
)paren
suffix:semicolon
id|dev_mc_delete
c_func
(paren
id|c-&gt;dev
comma
id|c-&gt;clustermac
comma
id|ETH_ALEN
comma
l_int|0
)paren
suffix:semicolon
id|dev_put
c_func
(paren
id|c-&gt;dev
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|c
)paren
suffix:semicolon
)brace
)brace
r_static
r_struct
id|clusterip_config
op_star
DECL|function|__clusterip_config_find
id|__clusterip_config_find
c_func
(paren
id|u_int32_t
id|clusterip
)paren
(brace
r_struct
id|list_head
op_star
id|pos
suffix:semicolon
id|MUST_BE_READ_LOCKED
c_func
(paren
op_amp
id|clusterip_lock
)paren
suffix:semicolon
id|list_for_each
c_func
(paren
id|pos
comma
op_amp
id|clusterip_configs
)paren
(brace
r_struct
id|clusterip_config
op_star
id|c
op_assign
id|list_entry
c_func
(paren
id|pos
comma
r_struct
id|clusterip_config
comma
id|list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c-&gt;clusterip
op_eq
id|clusterip
)paren
(brace
r_return
id|c
suffix:semicolon
)brace
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
r_static
r_inline
r_struct
id|clusterip_config
op_star
DECL|function|clusterip_config_find_get
id|clusterip_config_find_get
c_func
(paren
id|u_int32_t
id|clusterip
)paren
(brace
r_struct
id|clusterip_config
op_star
id|c
suffix:semicolon
id|READ_LOCK
c_func
(paren
op_amp
id|clusterip_lock
)paren
suffix:semicolon
id|c
op_assign
id|__clusterip_config_find
c_func
(paren
id|clusterip
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|c
)paren
(brace
id|READ_UNLOCK
c_func
(paren
op_amp
id|clusterip_lock
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|atomic_inc
c_func
(paren
op_amp
id|c-&gt;refcount
)paren
suffix:semicolon
id|READ_UNLOCK
c_func
(paren
op_amp
id|clusterip_lock
)paren
suffix:semicolon
r_return
id|c
suffix:semicolon
)brace
r_static
r_struct
id|clusterip_config
op_star
DECL|function|clusterip_config_init
id|clusterip_config_init
c_func
(paren
r_struct
id|ipt_clusterip_tgt_info
op_star
id|i
comma
id|u_int32_t
id|ip
comma
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|clusterip_config
op_star
id|c
suffix:semicolon
r_char
id|buffer
(braket
l_int|16
)braket
suffix:semicolon
id|c
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|c
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|c
)paren
r_return
l_int|NULL
suffix:semicolon
id|memset
c_func
(paren
id|c
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|c
)paren
)paren
suffix:semicolon
id|c-&gt;dev
op_assign
id|dev
suffix:semicolon
id|c-&gt;clusterip
op_assign
id|ip
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|c-&gt;clustermac
comma
op_amp
id|i-&gt;clustermac
comma
id|ETH_ALEN
)paren
suffix:semicolon
id|c-&gt;num_total_nodes
op_assign
id|i-&gt;num_total_nodes
suffix:semicolon
id|c-&gt;num_local_nodes
op_assign
id|i-&gt;num_local_nodes
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|c-&gt;local_nodes
comma
op_amp
id|i-&gt;local_nodes
comma
r_sizeof
(paren
op_amp
id|c-&gt;local_nodes
)paren
)paren
suffix:semicolon
id|c-&gt;hash_mode
op_assign
id|i-&gt;hash_mode
suffix:semicolon
id|c-&gt;hash_initval
op_assign
id|i-&gt;hash_initval
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|c-&gt;refcount
comma
l_int|1
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_PROC_FS
multiline_comment|/* create proc dir entry */
id|sprintf
c_func
(paren
id|buffer
comma
l_string|&quot;%u.%u.%u.%u&quot;
comma
id|NIPQUAD
c_func
(paren
id|ip
)paren
)paren
suffix:semicolon
id|c-&gt;pde
op_assign
id|create_proc_entry
c_func
(paren
id|buffer
comma
id|S_IWUSR
op_or
id|S_IRUSR
comma
id|clusterip_procdir
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|c-&gt;pde
)paren
(brace
id|kfree
c_func
(paren
id|c
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|c-&gt;pde-&gt;proc_fops
op_assign
op_amp
id|clusterip_proc_fops
suffix:semicolon
id|c-&gt;pde-&gt;data
op_assign
id|c
suffix:semicolon
macro_line|#endif
id|WRITE_LOCK
c_func
(paren
op_amp
id|clusterip_lock
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|c-&gt;list
comma
op_amp
id|clusterip_configs
)paren
suffix:semicolon
id|WRITE_UNLOCK
c_func
(paren
op_amp
id|clusterip_lock
)paren
suffix:semicolon
r_return
id|c
suffix:semicolon
)brace
r_static
r_int
DECL|function|clusterip_add_node
id|clusterip_add_node
c_func
(paren
r_struct
id|clusterip_config
op_star
id|c
comma
id|u_int16_t
id|nodenum
)paren
(brace
r_int
id|i
suffix:semicolon
id|WRITE_LOCK
c_func
(paren
op_amp
id|clusterip_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c-&gt;num_local_nodes
op_ge
id|CLUSTERIP_MAX_NODES
op_logical_or
id|nodenum
OG
id|CLUSTERIP_MAX_NODES
)paren
(brace
id|WRITE_UNLOCK
c_func
(paren
op_amp
id|clusterip_lock
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* check if we alrady have this number in our array */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|c-&gt;num_local_nodes
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|c-&gt;local_nodes
(braket
id|i
)braket
op_eq
id|nodenum
)paren
(brace
id|WRITE_UNLOCK
c_func
(paren
op_amp
id|clusterip_lock
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
id|c-&gt;local_nodes
(braket
id|c-&gt;num_local_nodes
op_increment
)braket
op_assign
id|nodenum
suffix:semicolon
id|WRITE_UNLOCK
c_func
(paren
op_amp
id|clusterip_lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|clusterip_del_node
id|clusterip_del_node
c_func
(paren
r_struct
id|clusterip_config
op_star
id|c
comma
id|u_int16_t
id|nodenum
)paren
(brace
r_int
id|i
suffix:semicolon
id|WRITE_LOCK
c_func
(paren
op_amp
id|clusterip_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c-&gt;num_local_nodes
op_le
l_int|1
op_logical_or
id|nodenum
OG
id|CLUSTERIP_MAX_NODES
)paren
(brace
id|WRITE_UNLOCK
c_func
(paren
op_amp
id|clusterip_lock
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|c-&gt;num_local_nodes
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|c-&gt;local_nodes
(braket
id|i
)braket
op_eq
id|nodenum
)paren
(brace
r_int
id|size
op_assign
r_sizeof
(paren
id|u_int16_t
)paren
op_star
(paren
id|c-&gt;num_local_nodes
op_minus
(paren
id|i
op_plus
l_int|1
)paren
)paren
suffix:semicolon
id|memmove
c_func
(paren
op_amp
id|c-&gt;local_nodes
(braket
id|i
)braket
comma
op_amp
id|c-&gt;local_nodes
(braket
id|i
op_plus
l_int|1
)braket
comma
id|size
)paren
suffix:semicolon
id|c-&gt;num_local_nodes
op_decrement
suffix:semicolon
id|WRITE_UNLOCK
c_func
(paren
op_amp
id|clusterip_lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
id|WRITE_UNLOCK
c_func
(paren
op_amp
id|clusterip_lock
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_static
r_inline
id|u_int32_t
DECL|function|clusterip_hashfn
id|clusterip_hashfn
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|clusterip_config
op_star
id|config
)paren
(brace
r_struct
id|iphdr
op_star
id|iph
op_assign
id|skb-&gt;nh.iph
suffix:semicolon
r_int
r_int
id|hashval
suffix:semicolon
id|u_int16_t
id|sport
comma
id|dport
suffix:semicolon
r_struct
id|tcphdr
op_star
id|th
suffix:semicolon
r_struct
id|udphdr
op_star
id|uh
suffix:semicolon
r_struct
id|icmphdr
op_star
id|ih
suffix:semicolon
r_switch
c_cond
(paren
id|iph-&gt;protocol
)paren
(brace
r_case
id|IPPROTO_TCP
suffix:colon
id|th
op_assign
(paren
r_void
op_star
)paren
id|iph
op_plus
id|iph-&gt;ihl
op_star
l_int|4
suffix:semicolon
id|sport
op_assign
id|ntohs
c_func
(paren
id|th-&gt;source
)paren
suffix:semicolon
id|dport
op_assign
id|ntohs
c_func
(paren
id|th-&gt;dest
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IPPROTO_UDP
suffix:colon
id|uh
op_assign
(paren
r_void
op_star
)paren
id|iph
op_plus
id|iph-&gt;ihl
op_star
l_int|4
suffix:semicolon
id|sport
op_assign
id|ntohs
c_func
(paren
id|uh-&gt;source
)paren
suffix:semicolon
id|dport
op_assign
id|ntohs
c_func
(paren
id|uh-&gt;dest
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IPPROTO_ICMP
suffix:colon
id|ih
op_assign
(paren
r_void
op_star
)paren
id|iph
op_plus
id|iph-&gt;ihl
op_star
l_int|4
suffix:semicolon
id|sport
op_assign
id|ntohs
c_func
(paren
id|ih-&gt;un.echo.id
)paren
suffix:semicolon
id|dport
op_assign
(paren
id|ih-&gt;type
op_lshift
l_int|8
)paren
op_or
id|ih-&gt;code
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
r_if
c_cond
(paren
id|net_ratelimit
c_func
(paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;CLUSTERIP: unknown protocol `%u&squot;&bslash;n&quot;
comma
id|iph-&gt;protocol
)paren
suffix:semicolon
)brace
id|sport
op_assign
id|dport
op_assign
l_int|0
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|config-&gt;hash_mode
)paren
(brace
r_case
id|CLUSTERIP_HASHMODE_SIP
suffix:colon
id|hashval
op_assign
id|jhash_1word
c_func
(paren
id|ntohl
c_func
(paren
id|iph-&gt;saddr
)paren
comma
id|config-&gt;hash_initval
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CLUSTERIP_HASHMODE_SIP_SPT
suffix:colon
id|hashval
op_assign
id|jhash_2words
c_func
(paren
id|ntohl
c_func
(paren
id|iph-&gt;saddr
)paren
comma
id|sport
comma
id|config-&gt;hash_initval
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CLUSTERIP_HASHMODE_SIP_SPT_DPT
suffix:colon
id|hashval
op_assign
id|jhash_3words
c_func
(paren
id|ntohl
c_func
(paren
id|iph-&gt;saddr
)paren
comma
id|sport
comma
id|dport
comma
id|config-&gt;hash_initval
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* to make gcc happy */
id|hashval
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* This cannot happen, unless the check function wasn&squot;t called&n;&t;&t; * at rule load time */
id|printk
c_func
(paren
l_string|&quot;CLUSTERIP: unknown mode `%u&squot;&bslash;n&quot;
comma
id|config-&gt;hash_mode
)paren
suffix:semicolon
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* node numbers are 1..n, not 0..n */
r_return
(paren
(paren
id|hashval
op_mod
id|config-&gt;num_total_nodes
)paren
op_plus
l_int|1
)paren
suffix:semicolon
)brace
r_static
r_inline
r_int
DECL|function|clusterip_responsible
id|clusterip_responsible
c_func
(paren
r_struct
id|clusterip_config
op_star
id|config
comma
id|u_int32_t
id|hash
)paren
(brace
r_int
id|i
suffix:semicolon
id|READ_LOCK
c_func
(paren
op_amp
id|clusterip_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|config-&gt;num_local_nodes
op_eq
l_int|0
)paren
(brace
id|READ_UNLOCK
c_func
(paren
op_amp
id|clusterip_lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|config-&gt;num_local_nodes
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|config-&gt;local_nodes
(braket
id|i
)braket
op_eq
id|hash
)paren
(brace
id|READ_UNLOCK
c_func
(paren
op_amp
id|clusterip_lock
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
id|READ_UNLOCK
c_func
(paren
op_amp
id|clusterip_lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*********************************************************************** &n; * IPTABLES TARGET &n; ***********************************************************************/
r_static
r_int
r_int
DECL|function|target
id|target
c_func
(paren
r_struct
id|sk_buff
op_star
op_star
id|pskb
comma
r_const
r_struct
id|net_device
op_star
id|in
comma
r_const
r_struct
id|net_device
op_star
id|out
comma
r_int
r_int
id|hooknum
comma
r_const
r_void
op_star
id|targinfo
comma
r_void
op_star
id|userinfo
)paren
(brace
r_const
r_struct
id|ipt_clusterip_tgt_info
op_star
id|cipinfo
op_assign
id|targinfo
suffix:semicolon
r_enum
id|ip_conntrack_info
id|ctinfo
suffix:semicolon
r_struct
id|ip_conntrack
op_star
id|ct
op_assign
id|ip_conntrack_get
c_func
(paren
(paren
op_star
id|pskb
)paren
comma
op_amp
id|ctinfo
)paren
suffix:semicolon
id|u_int32_t
id|hash
suffix:semicolon
multiline_comment|/* don&squot;t need to clusterip_config_get() here, since refcount&n;&t; * is only decremented by destroy() - and ip_tables guarantees&n;&t; * that the -&gt;target() function isn&squot;t called after -&gt;destroy() */
r_if
c_cond
(paren
op_logical_neg
id|ct
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;CLUSTERIP: no conntrack!&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* FIXME: need to drop invalid ones, since replies&n;&t;&t;&t; * to outgoing connections of other nodes will be &n;&t;&t;&t; * marked as INVALID */
r_return
id|NF_DROP
suffix:semicolon
)brace
multiline_comment|/* special case: ICMP error handling. conntrack distinguishes between&n;&t; * error messages (RELATED) and information requests (see below) */
r_if
c_cond
(paren
(paren
op_star
id|pskb
)paren
op_member_access_from_pointer
id|nh.iph-&gt;protocol
op_eq
id|IPPROTO_ICMP
op_logical_and
(paren
id|ctinfo
op_eq
id|IP_CT_RELATED
op_logical_or
id|ctinfo
op_eq
id|IP_CT_IS_REPLY
op_plus
id|IP_CT_IS_REPLY
)paren
)paren
r_return
id|IPT_CONTINUE
suffix:semicolon
multiline_comment|/* ip_conntrack_icmp guarantees us that we only have ICMP_ECHO, &n;&t; * TIMESTAMP, INFO_REQUEST or ADDRESS type icmp packets from here&n;&t; * on, which all have an ID field [relevant for hashing]. */
id|hash
op_assign
id|clusterip_hashfn
c_func
(paren
op_star
id|pskb
comma
id|cipinfo-&gt;config
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|ctinfo
)paren
(brace
r_case
id|IP_CT_NEW
suffix:colon
id|ct-&gt;mark
op_assign
id|hash
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IP_CT_RELATED
suffix:colon
r_case
id|IP_CT_RELATED
op_plus
id|IP_CT_IS_REPLY
suffix:colon
multiline_comment|/* FIXME: we don&squot;t handle expectations at the&n;&t;&t;&t; * moment.  they can arrive on a different node than&n;&t;&t;&t; * the master connection (e.g. FTP passive mode) */
r_case
id|IP_CT_ESTABLISHED
suffix:colon
r_case
id|IP_CT_ESTABLISHED
op_plus
id|IP_CT_IS_REPLY
suffix:colon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
macro_line|#ifdef DEBUG_CLUSTERP
id|DUMP_TUPLE
c_func
(paren
op_amp
id|ct-&gt;tuplehash
(braket
id|IP_CT_DIR_ORIGINAL
)braket
dot
id|tuple
)paren
suffix:semicolon
macro_line|#endif
id|DEBUGP
c_func
(paren
l_string|&quot;hash=%u ct_hash=%lu &quot;
comma
id|hash
comma
id|ct-&gt;mark
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|clusterip_responsible
c_func
(paren
id|cipinfo-&gt;config
comma
id|hash
)paren
)paren
(brace
id|DEBUGP
c_func
(paren
l_string|&quot;not responsible&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|NF_DROP
suffix:semicolon
)brace
id|DEBUGP
c_func
(paren
l_string|&quot;responsible&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* despite being received via linklayer multicast, this is&n;&t; * actually a unicast IP packet. TCP doesn&squot;t like PACKET_MULTICAST */
(paren
op_star
id|pskb
)paren
op_member_access_from_pointer
id|pkt_type
op_assign
id|PACKET_HOST
suffix:semicolon
r_return
id|IPT_CONTINUE
suffix:semicolon
)brace
r_static
r_int
DECL|function|checkentry
id|checkentry
c_func
(paren
r_const
r_char
op_star
id|tablename
comma
r_const
r_struct
id|ipt_entry
op_star
id|e
comma
r_void
op_star
id|targinfo
comma
r_int
r_int
id|targinfosize
comma
r_int
r_int
id|hook_mask
)paren
(brace
r_struct
id|ipt_clusterip_tgt_info
op_star
id|cipinfo
op_assign
id|targinfo
suffix:semicolon
r_struct
id|clusterip_config
op_star
id|config
suffix:semicolon
r_if
c_cond
(paren
id|targinfosize
op_ne
id|IPT_ALIGN
c_func
(paren
r_sizeof
(paren
r_struct
id|ipt_clusterip_tgt_info
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;CLUSTERIP: targinfosize %u != %Zu&bslash;n&quot;
comma
id|targinfosize
comma
id|IPT_ALIGN
c_func
(paren
r_sizeof
(paren
r_struct
id|ipt_clusterip_tgt_info
)paren
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cipinfo-&gt;hash_mode
op_ne
id|CLUSTERIP_HASHMODE_SIP
op_logical_and
id|cipinfo-&gt;hash_mode
op_ne
id|CLUSTERIP_HASHMODE_SIP_SPT
op_logical_and
id|cipinfo-&gt;hash_mode
op_ne
id|CLUSTERIP_HASHMODE_SIP_SPT_DPT
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;CLUSTERIP: unknown mode `%u&squot;&bslash;n&quot;
comma
id|cipinfo-&gt;hash_mode
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|e-&gt;ip.dmsk.s_addr
op_ne
l_int|0xffffffff
op_logical_or
id|e-&gt;ip.dst.s_addr
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;CLUSTERIP: Please specify destination IP&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* FIXME: further sanity checks */
id|config
op_assign
id|clusterip_config_find_get
c_func
(paren
id|e-&gt;ip.dst.s_addr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|config
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|cipinfo-&gt;flags
op_amp
id|CLUSTERIP_FLAG_NEW
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;CLUSTERIP: no config found for %u.%u.%u.%u, need &squot;new&squot;&bslash;n&quot;
comma
id|NIPQUAD
c_func
(paren
id|e-&gt;ip.dst.s_addr
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
r_struct
id|net_device
op_star
id|dev
suffix:semicolon
r_if
c_cond
(paren
id|e-&gt;ip.iniface
(braket
l_int|0
)braket
op_eq
l_char|&squot;&bslash;0&squot;
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;CLUSTERIP: Please specify an interface name&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|dev
op_assign
id|dev_get_by_name
c_func
(paren
id|e-&gt;ip.iniface
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;CLUSTERIP: no such interface %s&bslash;n&quot;
comma
id|e-&gt;ip.iniface
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|config
op_assign
id|clusterip_config_init
c_func
(paren
id|cipinfo
comma
id|e-&gt;ip.dst.s_addr
comma
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|config
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;CLUSTERIP: cannot allocate config&bslash;n&quot;
)paren
suffix:semicolon
id|dev_put
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|dev_mc_add
c_func
(paren
id|config-&gt;dev
comma
id|config-&gt;clustermac
comma
id|ETH_ALEN
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
id|cipinfo-&gt;config
op_assign
id|config
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* drop reference count of cluster config when rule is deleted */
DECL|function|destroy
r_static
r_void
id|destroy
c_func
(paren
r_void
op_star
id|matchinfo
comma
r_int
r_int
id|matchinfosize
)paren
(brace
r_struct
id|ipt_clusterip_tgt_info
op_star
id|cipinfo
op_assign
id|matchinfo
suffix:semicolon
multiline_comment|/* we first remove the proc entry and then drop the reference&n;&t; * count.  In case anyone still accesses the file, the open/close&n;&t; * functions are also incrementing the refcount on their own */
macro_line|#ifdef CONFIG_PROC_FS
id|remove_proc_entry
c_func
(paren
id|cipinfo-&gt;config-&gt;pde-&gt;name
comma
id|cipinfo-&gt;config-&gt;pde-&gt;parent
)paren
suffix:semicolon
macro_line|#endif
id|clusterip_config_put
c_func
(paren
id|cipinfo-&gt;config
)paren
suffix:semicolon
)brace
DECL|variable|clusterip_tgt
r_static
r_struct
id|ipt_target
id|clusterip_tgt
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;CLUSTERIP&quot;
comma
dot
id|target
op_assign
op_amp
id|target
comma
dot
id|checkentry
op_assign
op_amp
id|checkentry
comma
dot
id|destroy
op_assign
op_amp
id|destroy
comma
dot
id|me
op_assign
id|THIS_MODULE
)brace
suffix:semicolon
multiline_comment|/*********************************************************************** &n; * ARP MANGLING CODE &n; ***********************************************************************/
multiline_comment|/* hardcoded for 48bit ethernet and 32bit ipv4 addresses */
DECL|struct|arp_payload
r_struct
id|arp_payload
(brace
DECL|member|src_hw
id|u_int8_t
id|src_hw
(braket
id|ETH_ALEN
)braket
suffix:semicolon
DECL|member|src_ip
id|u_int32_t
id|src_ip
suffix:semicolon
DECL|member|dst_hw
id|u_int8_t
id|dst_hw
(braket
id|ETH_ALEN
)braket
suffix:semicolon
DECL|member|dst_ip
id|u_int32_t
id|dst_ip
suffix:semicolon
)brace
id|__attribute__
(paren
(paren
id|packed
)paren
)paren
suffix:semicolon
macro_line|#ifdef CLUSTERIP_DEBUG
DECL|function|arp_print
r_static
r_void
id|arp_print
c_func
(paren
r_struct
id|arp_payload
op_star
id|payload
)paren
(brace
DECL|macro|HBUFFERLEN
mdefine_line|#define HBUFFERLEN 30
r_char
id|hbuffer
(braket
id|HBUFFERLEN
)braket
suffix:semicolon
r_int
id|j
comma
id|k
suffix:semicolon
r_const
r_char
id|hexbuf
(braket
)braket
op_assign
l_string|&quot;0123456789abcdef&quot;
suffix:semicolon
r_for
c_loop
(paren
id|k
op_assign
l_int|0
comma
id|j
op_assign
l_int|0
suffix:semicolon
id|k
OL
id|HBUFFERLEN
op_minus
l_int|3
op_logical_and
id|j
OL
id|ETH_ALEN
suffix:semicolon
id|j
op_increment
)paren
(brace
id|hbuffer
(braket
id|k
op_increment
)braket
op_assign
id|hexbuf
(braket
(paren
id|payload-&gt;src_hw
(braket
id|j
)braket
op_rshift
l_int|4
)paren
op_amp
l_int|15
)braket
suffix:semicolon
id|hbuffer
(braket
id|k
op_increment
)braket
op_assign
id|hexbuf
(braket
id|payload-&gt;src_hw
(braket
id|j
)braket
op_amp
l_int|15
)braket
suffix:semicolon
id|hbuffer
(braket
id|k
op_increment
)braket
op_assign
l_char|&squot;:&squot;
suffix:semicolon
)brace
id|hbuffer
(braket
op_decrement
id|k
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;src %u.%u.%u.%u@%s, dst %u.%u.%u.%u&bslash;n&quot;
comma
id|NIPQUAD
c_func
(paren
id|payload-&gt;src_ip
)paren
comma
id|hbuffer
comma
id|NIPQUAD
c_func
(paren
id|payload-&gt;dst_ip
)paren
)paren
suffix:semicolon
)brace
macro_line|#endif
r_static
r_int
r_int
DECL|function|arp_mangle
id|arp_mangle
c_func
(paren
r_int
r_int
id|hook
comma
r_struct
id|sk_buff
op_star
op_star
id|pskb
comma
r_const
r_struct
id|net_device
op_star
id|in
comma
r_const
r_struct
id|net_device
op_star
id|out
comma
r_int
(paren
op_star
id|okfn
)paren
(paren
r_struct
id|sk_buff
op_star
)paren
)paren
(brace
r_struct
id|arphdr
op_star
id|arp
op_assign
(paren
op_star
id|pskb
)paren
op_member_access_from_pointer
id|nh.arph
suffix:semicolon
r_struct
id|arp_payload
op_star
id|payload
suffix:semicolon
r_struct
id|clusterip_config
op_star
id|c
suffix:semicolon
multiline_comment|/* we don&squot;t care about non-ethernet and non-ipv4 ARP */
r_if
c_cond
(paren
id|arp-&gt;ar_hrd
op_ne
id|htons
c_func
(paren
id|ARPHRD_ETHER
)paren
op_logical_or
id|arp-&gt;ar_pro
op_ne
id|htons
c_func
(paren
id|ETH_P_IP
)paren
op_logical_or
id|arp-&gt;ar_pln
op_ne
l_int|4
op_logical_or
id|arp-&gt;ar_hln
op_ne
id|ETH_ALEN
)paren
r_return
id|NF_ACCEPT
suffix:semicolon
multiline_comment|/* we only want to mangle arp replies */
r_if
c_cond
(paren
id|arp-&gt;ar_op
op_ne
id|htons
c_func
(paren
id|ARPOP_REPLY
)paren
)paren
r_return
id|NF_ACCEPT
suffix:semicolon
id|payload
op_assign
(paren
r_void
op_star
)paren
(paren
id|arp
op_plus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* if there is no clusterip configuration for the arp reply&squot;s &n;&t; * source ip, we don&squot;t want to mangle it */
id|c
op_assign
id|clusterip_config_find_get
c_func
(paren
id|payload-&gt;src_ip
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|c
)paren
r_return
id|NF_ACCEPT
suffix:semicolon
multiline_comment|/* normally the linux kernel always replies to arp queries of &n;&t; * addresses on different interfacs.  However, in the CLUSTERIP case&n;&t; * this wouldn&squot;t work, since we didn&squot;t subscribe the mcast group on&n;&t; * other interfaces */
r_if
c_cond
(paren
id|c-&gt;dev
op_ne
id|out
)paren
(brace
id|DEBUGP
c_func
(paren
l_string|&quot;CLUSTERIP: not mangling arp reply on different &quot;
l_string|&quot;interface: cip&squot;%s&squot;-skb&squot;%s&squot;&bslash;n&quot;
comma
id|c-&gt;dev-&gt;name
comma
id|out-&gt;name
)paren
suffix:semicolon
id|clusterip_config_put
c_func
(paren
id|c
)paren
suffix:semicolon
r_return
id|NF_ACCEPT
suffix:semicolon
)brace
multiline_comment|/* mangle reply hardware address */
id|memcpy
c_func
(paren
id|payload-&gt;src_hw
comma
id|c-&gt;clustermac
comma
id|arp-&gt;ar_hln
)paren
suffix:semicolon
macro_line|#ifdef CLUSTERIP_DEBUG
id|DEBUGP
c_func
(paren
id|KERN_DEBUG
l_string|&quot;CLUSTERIP mangled arp reply: &quot;
)paren
suffix:semicolon
id|arp_print
c_func
(paren
id|payload
)paren
suffix:semicolon
macro_line|#endif
id|clusterip_config_put
c_func
(paren
id|c
)paren
suffix:semicolon
r_return
id|NF_ACCEPT
suffix:semicolon
)brace
DECL|variable|cip_arp_ops
r_static
r_struct
id|nf_hook_ops
id|cip_arp_ops
op_assign
(brace
dot
id|hook
op_assign
id|arp_mangle
comma
dot
id|pf
op_assign
id|NF_ARP
comma
dot
id|hooknum
op_assign
id|NF_ARP_OUT
comma
dot
id|priority
op_assign
op_minus
l_int|1
)brace
suffix:semicolon
multiline_comment|/*********************************************************************** &n; * PROC DIR HANDLING &n; ***********************************************************************/
macro_line|#ifdef CONFIG_PROC_FS
DECL|function|clusterip_seq_start
r_static
r_void
op_star
id|clusterip_seq_start
c_func
(paren
r_struct
id|seq_file
op_star
id|s
comma
id|loff_t
op_star
id|pos
)paren
(brace
r_struct
id|proc_dir_entry
op_star
id|pde
op_assign
id|s
op_member_access_from_pointer
r_private
suffix:semicolon
r_struct
id|clusterip_config
op_star
id|c
op_assign
id|pde-&gt;data
suffix:semicolon
r_int
r_int
op_star
id|nodeidx
suffix:semicolon
id|READ_LOCK
c_func
(paren
op_amp
id|clusterip_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|pos
op_ge
id|c-&gt;num_local_nodes
)paren
r_return
l_int|NULL
suffix:semicolon
id|nodeidx
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_int
r_int
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|nodeidx
)paren
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
op_star
id|nodeidx
op_assign
op_star
id|pos
suffix:semicolon
r_return
id|nodeidx
suffix:semicolon
)brace
DECL|function|clusterip_seq_next
r_static
r_void
op_star
id|clusterip_seq_next
c_func
(paren
r_struct
id|seq_file
op_star
id|s
comma
r_void
op_star
id|v
comma
id|loff_t
op_star
id|pos
)paren
(brace
r_struct
id|proc_dir_entry
op_star
id|pde
op_assign
id|s
op_member_access_from_pointer
r_private
suffix:semicolon
r_struct
id|clusterip_config
op_star
id|c
op_assign
id|pde-&gt;data
suffix:semicolon
r_int
r_int
op_star
id|nodeidx
op_assign
(paren
r_int
r_int
op_star
)paren
id|v
suffix:semicolon
op_star
id|pos
op_assign
op_increment
(paren
op_star
id|nodeidx
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|pos
op_ge
id|c-&gt;num_local_nodes
)paren
(brace
id|kfree
c_func
(paren
id|v
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_return
id|nodeidx
suffix:semicolon
)brace
DECL|function|clusterip_seq_stop
r_static
r_void
id|clusterip_seq_stop
c_func
(paren
r_struct
id|seq_file
op_star
id|s
comma
r_void
op_star
id|v
)paren
(brace
id|kfree
c_func
(paren
id|v
)paren
suffix:semicolon
id|READ_UNLOCK
c_func
(paren
op_amp
id|clusterip_lock
)paren
suffix:semicolon
)brace
DECL|function|clusterip_seq_show
r_static
r_int
id|clusterip_seq_show
c_func
(paren
r_struct
id|seq_file
op_star
id|s
comma
r_void
op_star
id|v
)paren
(brace
r_struct
id|proc_dir_entry
op_star
id|pde
op_assign
id|s
op_member_access_from_pointer
r_private
suffix:semicolon
r_struct
id|clusterip_config
op_star
id|c
op_assign
id|pde-&gt;data
suffix:semicolon
r_int
r_int
op_star
id|nodeidx
op_assign
(paren
r_int
r_int
op_star
)paren
id|v
suffix:semicolon
r_if
c_cond
(paren
op_star
id|nodeidx
op_ne
l_int|0
)paren
id|seq_putc
c_func
(paren
id|s
comma
l_char|&squot;,&squot;
)paren
suffix:semicolon
id|seq_printf
c_func
(paren
id|s
comma
l_string|&quot;%u&quot;
comma
id|c-&gt;local_nodes
(braket
op_star
id|nodeidx
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|nodeidx
op_eq
id|c-&gt;num_local_nodes
op_minus
l_int|1
)paren
id|seq_putc
c_func
(paren
id|s
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|clusterip_seq_ops
r_static
r_struct
id|seq_operations
id|clusterip_seq_ops
op_assign
(brace
dot
id|start
op_assign
id|clusterip_seq_start
comma
dot
id|next
op_assign
id|clusterip_seq_next
comma
dot
id|stop
op_assign
id|clusterip_seq_stop
comma
dot
id|show
op_assign
id|clusterip_seq_show
comma
)brace
suffix:semicolon
DECL|function|clusterip_proc_open
r_static
r_int
id|clusterip_proc_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_int
id|ret
op_assign
id|seq_open
c_func
(paren
id|file
comma
op_amp
id|clusterip_seq_ops
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
(brace
r_struct
id|seq_file
op_star
id|sf
op_assign
id|file-&gt;private_data
suffix:semicolon
r_struct
id|proc_dir_entry
op_star
id|pde
op_assign
id|PDE
c_func
(paren
id|inode
)paren
suffix:semicolon
r_struct
id|clusterip_config
op_star
id|c
op_assign
id|pde-&gt;data
suffix:semicolon
id|sf
op_member_access_from_pointer
r_private
op_assign
id|pde
suffix:semicolon
id|clusterip_config_get
c_func
(paren
id|c
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|function|clusterip_proc_release
r_static
r_int
id|clusterip_proc_release
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_struct
id|proc_dir_entry
op_star
id|pde
op_assign
id|PDE
c_func
(paren
id|inode
)paren
suffix:semicolon
r_struct
id|clusterip_config
op_star
id|c
op_assign
id|pde-&gt;data
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|ret
op_assign
id|seq_release
c_func
(paren
id|inode
comma
id|file
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
id|clusterip_config_put
c_func
(paren
id|c
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|clusterip_proc_write
r_static
id|ssize_t
id|clusterip_proc_write
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_const
r_char
id|__user
op_star
id|input
comma
r_int
id|size
comma
id|loff_t
op_star
id|ofs
)paren
(brace
DECL|macro|PROC_WRITELEN
mdefine_line|#define PROC_WRITELEN&t;10
r_char
id|buffer
(braket
id|PROC_WRITELEN
op_plus
l_int|1
)braket
suffix:semicolon
r_struct
id|proc_dir_entry
op_star
id|pde
op_assign
id|PDE
c_func
(paren
id|file-&gt;f_dentry-&gt;d_inode
)paren
suffix:semicolon
r_struct
id|clusterip_config
op_star
id|c
op_assign
id|pde-&gt;data
suffix:semicolon
r_int
r_int
id|nodenum
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|buffer
comma
id|input
comma
id|PROC_WRITELEN
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
op_star
id|buffer
op_eq
l_char|&squot;+&squot;
)paren
(brace
id|nodenum
op_assign
id|simple_strtoul
c_func
(paren
id|buffer
op_plus
l_int|1
comma
l_int|NULL
comma
l_int|10
)paren
suffix:semicolon
r_if
c_cond
(paren
id|clusterip_add_node
c_func
(paren
id|c
comma
id|nodenum
)paren
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_star
id|buffer
op_eq
l_char|&squot;-&squot;
)paren
(brace
id|nodenum
op_assign
id|simple_strtoul
c_func
(paren
id|buffer
op_plus
l_int|1
comma
l_int|NULL
comma
l_int|10
)paren
suffix:semicolon
r_if
c_cond
(paren
id|clusterip_del_node
c_func
(paren
id|c
comma
id|nodenum
)paren
)paren
r_return
op_minus
id|ENOENT
suffix:semicolon
)brace
r_else
r_return
op_minus
id|EIO
suffix:semicolon
r_return
id|size
suffix:semicolon
)brace
DECL|variable|clusterip_proc_fops
r_static
r_struct
id|file_operations
id|clusterip_proc_fops
op_assign
(brace
dot
id|owner
op_assign
id|THIS_MODULE
comma
dot
id|open
op_assign
id|clusterip_proc_open
comma
dot
id|read
op_assign
id|seq_read
comma
dot
id|write
op_assign
id|clusterip_proc_write
comma
dot
id|llseek
op_assign
id|seq_lseek
comma
dot
id|release
op_assign
id|clusterip_proc_release
comma
)brace
suffix:semicolon
macro_line|#endif /* CONFIG_PROC_FS */
DECL|function|init_or_cleanup
r_static
r_int
id|init_or_cleanup
c_func
(paren
r_int
id|fini
)paren
(brace
r_int
id|ret
suffix:semicolon
r_if
c_cond
(paren
id|fini
)paren
r_goto
id|cleanup
suffix:semicolon
r_if
c_cond
(paren
id|ipt_register_target
c_func
(paren
op_amp
id|clusterip_tgt
)paren
)paren
(brace
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|cleanup_none
suffix:semicolon
)brace
r_if
c_cond
(paren
id|nf_register_hook
c_func
(paren
op_amp
id|cip_arp_ops
)paren
OL
l_int|0
)paren
(brace
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|cleanup_target
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_PROC_FS
id|clusterip_procdir
op_assign
id|proc_mkdir
c_func
(paren
l_string|&quot;ipt_CLUSTERIP&quot;
comma
id|proc_net
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|clusterip_procdir
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;CLUSTERIP: Unable to proc dir entry&bslash;n&quot;
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|cleanup_hook
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_PROC_FS */
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;ClusterIP Version %s loaded successfully&bslash;n&quot;
comma
id|CLUSTERIP_VERSION
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|cleanup
suffix:colon
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;ClusterIP Version %s unloading&bslash;n&quot;
comma
id|CLUSTERIP_VERSION
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_PROC_FS
id|remove_proc_entry
c_func
(paren
id|clusterip_procdir-&gt;name
comma
id|clusterip_procdir-&gt;parent
)paren
suffix:semicolon
macro_line|#endif
id|cleanup_hook
suffix:colon
id|nf_unregister_hook
c_func
(paren
op_amp
id|cip_arp_ops
)paren
suffix:semicolon
id|cleanup_target
suffix:colon
id|ipt_unregister_target
c_func
(paren
op_amp
id|clusterip_tgt
)paren
suffix:semicolon
id|cleanup_none
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
DECL|function|init
r_static
r_int
id|__init
id|init
c_func
(paren
r_void
)paren
(brace
r_return
id|init_or_cleanup
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|fini
r_static
r_void
id|__exit
id|fini
c_func
(paren
r_void
)paren
(brace
id|init_or_cleanup
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
DECL|variable|init
id|module_init
c_func
(paren
id|init
)paren
suffix:semicolon
DECL|variable|fini
id|module_exit
c_func
(paren
id|fini
)paren
suffix:semicolon
eof
