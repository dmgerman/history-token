multiline_comment|/* NAT for netfilter; shared with compatibility layer. */
multiline_comment|/* (C) 1999-2001 Paul `Rusty&squot; Russell&n; * (C) 2002-2004 Netfilter Core Team &lt;coreteam@netfilter.org&gt;&n; *&n; * This program is free software; you can redistribute it and/or modify&n; * it under the terms of the GNU General Public License version 2 as&n; * published by the Free Software Foundation.&n; */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;linux/netfilter_ipv4.h&gt;
macro_line|#include &lt;linux/vmalloc.h&gt;
macro_line|#include &lt;net/checksum.h&gt;
macro_line|#include &lt;net/icmp.h&gt;
macro_line|#include &lt;net/ip.h&gt;
macro_line|#include &lt;net/tcp.h&gt;  /* For tcp_prot in getorigdst */
macro_line|#include &lt;linux/icmp.h&gt;
macro_line|#include &lt;linux/udp.h&gt;
macro_line|#include &lt;linux/jhash.h&gt;
DECL|macro|ASSERT_READ_LOCK
mdefine_line|#define ASSERT_READ_LOCK(x) MUST_BE_READ_LOCKED(&amp;ip_nat_lock)
DECL|macro|ASSERT_WRITE_LOCK
mdefine_line|#define ASSERT_WRITE_LOCK(x) MUST_BE_WRITE_LOCKED(&amp;ip_nat_lock)
macro_line|#include &lt;linux/netfilter_ipv4/ip_conntrack.h&gt;
macro_line|#include &lt;linux/netfilter_ipv4/ip_conntrack_core.h&gt;
macro_line|#include &lt;linux/netfilter_ipv4/ip_conntrack_protocol.h&gt;
macro_line|#include &lt;linux/netfilter_ipv4/ip_nat.h&gt;
macro_line|#include &lt;linux/netfilter_ipv4/ip_nat_protocol.h&gt;
macro_line|#include &lt;linux/netfilter_ipv4/ip_nat_core.h&gt;
macro_line|#include &lt;linux/netfilter_ipv4/ip_nat_helper.h&gt;
macro_line|#include &lt;linux/netfilter_ipv4/ip_conntrack_helper.h&gt;
macro_line|#include &lt;linux/netfilter_ipv4/listhelp.h&gt;
macro_line|#if 0
mdefine_line|#define DEBUGP printk
macro_line|#else
DECL|macro|DEBUGP
mdefine_line|#define DEBUGP(format, args...)
macro_line|#endif
DECL|variable|ip_nat_lock
id|DECLARE_RWLOCK
c_func
(paren
id|ip_nat_lock
)paren
suffix:semicolon
DECL|variable|ip_conntrack_lock
id|DECLARE_RWLOCK_EXTERN
c_func
(paren
id|ip_conntrack_lock
)paren
suffix:semicolon
multiline_comment|/* Calculated at init based on memory size */
DECL|variable|ip_nat_htable_size
r_static
r_int
r_int
id|ip_nat_htable_size
suffix:semicolon
DECL|variable|bysource
r_static
r_struct
id|list_head
op_star
id|bysource
suffix:semicolon
DECL|variable|ip_nat_protos
r_struct
id|ip_nat_protocol
op_star
id|ip_nat_protos
(braket
id|MAX_IP_NAT_PROTO
)braket
suffix:semicolon
multiline_comment|/* We keep an extra hash for each conntrack, for fast searching. */
r_static
r_inline
r_int
DECL|function|hash_by_src
id|hash_by_src
c_func
(paren
r_const
r_struct
id|ip_conntrack_manip
op_star
id|manip
comma
id|u_int16_t
id|proto
)paren
(brace
multiline_comment|/* Original src, to ensure we map it consistently if poss. */
r_return
(paren
id|manip-&gt;ip
op_plus
id|manip-&gt;u.all
op_plus
id|proto
)paren
op_mod
id|ip_nat_htable_size
suffix:semicolon
)brace
multiline_comment|/* Noone using conntrack by the time this called. */
DECL|function|ip_nat_cleanup_conntrack
r_static
r_void
id|ip_nat_cleanup_conntrack
c_func
(paren
r_struct
id|ip_conntrack
op_star
id|conn
)paren
(brace
r_struct
id|ip_nat_info
op_star
id|info
op_assign
op_amp
id|conn-&gt;nat.info
suffix:semicolon
r_int
r_int
id|hs
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|info-&gt;initialized
)paren
r_return
suffix:semicolon
id|hs
op_assign
id|hash_by_src
c_func
(paren
op_amp
id|conn-&gt;tuplehash
(braket
id|IP_CT_DIR_ORIGINAL
)braket
dot
id|tuple.src
comma
id|conn-&gt;tuplehash
(braket
id|IP_CT_DIR_ORIGINAL
)braket
dot
id|tuple.dst.protonum
)paren
suffix:semicolon
id|WRITE_LOCK
c_func
(paren
op_amp
id|ip_nat_lock
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|info-&gt;bysource
)paren
suffix:semicolon
id|WRITE_UNLOCK
c_func
(paren
op_amp
id|ip_nat_lock
)paren
suffix:semicolon
)brace
multiline_comment|/* We do checksum mangling, so if they were wrong before they&squot;re still&n; * wrong.  Also works for incomplete packets (eg. ICMP dest&n; * unreachables.) */
id|u_int16_t
DECL|function|ip_nat_cheat_check
id|ip_nat_cheat_check
c_func
(paren
id|u_int32_t
id|oldvalinv
comma
id|u_int32_t
id|newval
comma
id|u_int16_t
id|oldcheck
)paren
(brace
id|u_int32_t
id|diffs
(braket
)braket
op_assign
(brace
id|oldvalinv
comma
id|newval
)brace
suffix:semicolon
r_return
id|csum_fold
c_func
(paren
id|csum_partial
c_func
(paren
(paren
r_char
op_star
)paren
id|diffs
comma
r_sizeof
(paren
id|diffs
)paren
comma
id|oldcheck
op_xor
l_int|0xFFFF
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Is this tuple already taken? (not by us) */
r_int
DECL|function|ip_nat_used_tuple
id|ip_nat_used_tuple
c_func
(paren
r_const
r_struct
id|ip_conntrack_tuple
op_star
id|tuple
comma
r_const
r_struct
id|ip_conntrack
op_star
id|ignored_conntrack
)paren
(brace
multiline_comment|/* Conntrack tracking doesn&squot;t keep track of outgoing tuples; only&n;&t;   incoming ones.  NAT means they don&squot;t have a fixed mapping,&n;&t;   so we invert the tuple and look for the incoming reply.&n;&n;&t;   We could keep a separate hash if this proves too slow. */
r_struct
id|ip_conntrack_tuple
id|reply
suffix:semicolon
id|invert_tuplepr
c_func
(paren
op_amp
id|reply
comma
id|tuple
)paren
suffix:semicolon
r_return
id|ip_conntrack_tuple_taken
c_func
(paren
op_amp
id|reply
comma
id|ignored_conntrack
)paren
suffix:semicolon
)brace
multiline_comment|/* Before 2.6.11 we did implicit source NAT if required. Warn about change. */
DECL|function|warn_if_extra_mangle
r_static
r_void
id|warn_if_extra_mangle
c_func
(paren
id|u32
id|dstip
comma
id|u32
id|srcip
)paren
(brace
r_static
r_int
id|warned
op_assign
l_int|0
suffix:semicolon
r_struct
id|flowi
id|fl
op_assign
(brace
dot
id|nl_u
op_assign
(brace
dot
id|ip4_u
op_assign
(brace
dot
id|daddr
op_assign
id|dstip
)brace
)brace
)brace
suffix:semicolon
r_struct
id|rtable
op_star
id|rt
suffix:semicolon
r_if
c_cond
(paren
id|ip_route_output_key
c_func
(paren
op_amp
id|rt
comma
op_amp
id|fl
)paren
op_ne
l_int|0
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|rt-&gt;rt_src
op_ne
id|srcip
op_logical_and
op_logical_neg
id|warned
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;NAT: no longer support implicit source local NAT&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;NAT: packet src %u.%u.%u.%u -&gt; dst %u.%u.%u.%u&bslash;n&quot;
comma
id|NIPQUAD
c_func
(paren
id|srcip
)paren
comma
id|NIPQUAD
c_func
(paren
id|dstip
)paren
)paren
suffix:semicolon
id|warned
op_assign
l_int|1
suffix:semicolon
)brace
id|ip_rt_put
c_func
(paren
id|rt
)paren
suffix:semicolon
)brace
multiline_comment|/* If we source map this tuple so reply looks like reply_tuple, will&n; * that meet the constraints of range. */
r_static
r_int
DECL|function|in_range
id|in_range
c_func
(paren
r_const
r_struct
id|ip_conntrack_tuple
op_star
id|tuple
comma
r_const
r_struct
id|ip_nat_range
op_star
id|range
)paren
(brace
r_struct
id|ip_nat_protocol
op_star
id|proto
op_assign
id|ip_nat_find_proto
c_func
(paren
id|tuple-&gt;dst.protonum
)paren
suffix:semicolon
multiline_comment|/* If we are supposed to map IPs, then we must be in the&n;&t;   range specified, otherwise let this drag us onto a new src IP. */
r_if
c_cond
(paren
id|range-&gt;flags
op_amp
id|IP_NAT_RANGE_MAP_IPS
)paren
(brace
r_if
c_cond
(paren
id|ntohl
c_func
(paren
id|tuple-&gt;src.ip
)paren
template_param
id|ntohl
c_func
(paren
id|range-&gt;max_ip
)paren
)paren
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|range-&gt;flags
op_amp
id|IP_NAT_RANGE_PROTO_SPECIFIED
)paren
op_logical_or
id|proto
op_member_access_from_pointer
id|in_range
c_func
(paren
id|tuple
comma
id|IP_NAT_MANIP_SRC
comma
op_amp
id|range-&gt;min
comma
op_amp
id|range-&gt;max
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_inline
r_int
DECL|function|same_src
id|same_src
c_func
(paren
r_const
r_struct
id|ip_conntrack
op_star
id|ct
comma
r_const
r_struct
id|ip_conntrack_tuple
op_star
id|tuple
)paren
(brace
r_return
(paren
id|ct-&gt;tuplehash
(braket
id|IP_CT_DIR_ORIGINAL
)braket
dot
id|tuple.dst.protonum
op_eq
id|tuple-&gt;dst.protonum
op_logical_and
id|ct-&gt;tuplehash
(braket
id|IP_CT_DIR_ORIGINAL
)braket
dot
id|tuple.src.ip
op_eq
id|tuple-&gt;src.ip
op_logical_and
id|ct-&gt;tuplehash
(braket
id|IP_CT_DIR_ORIGINAL
)braket
dot
id|tuple.src.u.all
op_eq
id|tuple-&gt;src.u.all
)paren
suffix:semicolon
)brace
multiline_comment|/* Only called for SRC manip */
r_static
r_int
DECL|function|find_appropriate_src
id|find_appropriate_src
c_func
(paren
r_const
r_struct
id|ip_conntrack_tuple
op_star
id|tuple
comma
r_struct
id|ip_conntrack_tuple
op_star
id|result
comma
r_const
r_struct
id|ip_nat_range
op_star
id|range
)paren
(brace
r_int
r_int
id|h
op_assign
id|hash_by_src
c_func
(paren
op_amp
id|tuple-&gt;src
comma
id|tuple-&gt;dst.protonum
)paren
suffix:semicolon
r_struct
id|ip_conntrack
op_star
id|ct
suffix:semicolon
id|MUST_BE_READ_LOCKED
c_func
(paren
op_amp
id|ip_nat_lock
)paren
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|ct
comma
op_amp
id|bysource
(braket
id|h
)braket
comma
id|nat.info.bysource
)paren
(brace
r_if
c_cond
(paren
id|same_src
c_func
(paren
id|ct
comma
id|tuple
)paren
)paren
(brace
multiline_comment|/* Copy source part from reply tuple. */
id|invert_tuplepr
c_func
(paren
id|result
comma
op_amp
id|ct-&gt;tuplehash
(braket
id|IP_CT_DIR_REPLY
)braket
dot
id|tuple
)paren
suffix:semicolon
id|result-&gt;dst
op_assign
id|tuple-&gt;dst
suffix:semicolon
r_if
c_cond
(paren
id|in_range
c_func
(paren
id|result
comma
id|range
)paren
)paren
r_return
l_int|1
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* For [FUTURE] fragmentation handling, we want the least-used&n;   src-ip/dst-ip/proto triple.  Fairness doesn&squot;t come into it.  Thus&n;   if the range specifies 1.2.3.4 ports 10000-10005 and 1.2.3.5 ports&n;   1-65535, we don&squot;t do pro-rata allocation based on ports; we choose&n;   the ip with the lowest src-ip/dst-ip/proto usage.&n;*/
r_static
r_void
DECL|function|find_best_ips_proto
id|find_best_ips_proto
c_func
(paren
r_struct
id|ip_conntrack_tuple
op_star
id|tuple
comma
r_const
r_struct
id|ip_nat_range
op_star
id|range
comma
r_const
r_struct
id|ip_conntrack
op_star
id|conntrack
comma
r_int
r_int
id|hooknum
)paren
(brace
id|u_int32_t
op_star
id|var_ipp
suffix:semicolon
multiline_comment|/* Host order */
id|u_int32_t
id|minip
comma
id|maxip
comma
id|j
suffix:semicolon
multiline_comment|/* No IP mapping?  Do nothing. */
r_if
c_cond
(paren
op_logical_neg
(paren
id|range-&gt;flags
op_amp
id|IP_NAT_RANGE_MAP_IPS
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|HOOK2MANIP
c_func
(paren
id|hooknum
)paren
op_eq
id|IP_NAT_MANIP_SRC
)paren
id|var_ipp
op_assign
op_amp
id|tuple-&gt;src.ip
suffix:semicolon
r_else
id|var_ipp
op_assign
op_amp
id|tuple-&gt;dst.ip
suffix:semicolon
multiline_comment|/* Fast path: only one choice. */
r_if
c_cond
(paren
id|range-&gt;min_ip
op_eq
id|range-&gt;max_ip
)paren
(brace
op_star
id|var_ipp
op_assign
id|range-&gt;min_ip
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Hashing source and destination IPs gives a fairly even&n;&t; * spread in practice (if there are a small number of IPs&n;&t; * involved, there usually aren&squot;t that many connections&n;&t; * anyway).  The consistency means that servers see the same&n;&t; * client coming from the same IP (some Internet Backing sites&n;&t; * like this), even across reboots. */
id|minip
op_assign
id|ntohl
c_func
(paren
id|range-&gt;min_ip
)paren
suffix:semicolon
id|maxip
op_assign
id|ntohl
c_func
(paren
id|range-&gt;max_ip
)paren
suffix:semicolon
id|j
op_assign
id|jhash_2words
c_func
(paren
id|tuple-&gt;src.ip
comma
id|tuple-&gt;dst.ip
comma
l_int|0
)paren
suffix:semicolon
op_star
id|var_ipp
op_assign
id|htonl
c_func
(paren
id|minip
op_plus
id|j
op_mod
(paren
id|maxip
op_minus
id|minip
op_plus
l_int|1
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Manipulate the tuple into the range given.  For NF_IP_POST_ROUTING,&n; * we change the source to map into the range.  For NF_IP_PRE_ROUTING&n; * and NF_IP_LOCAL_OUT, we change the destination to map into the&n; * range.  It might not be possible to get a unique tuple, but we try.&n; * At worst (or if we race), we will end up with a final duplicate in&n; * __ip_conntrack_confirm and drop the packet. */
r_static
r_void
DECL|function|get_unique_tuple
id|get_unique_tuple
c_func
(paren
r_struct
id|ip_conntrack_tuple
op_star
id|tuple
comma
r_const
r_struct
id|ip_conntrack_tuple
op_star
id|orig_tuple
comma
r_const
r_struct
id|ip_nat_range
op_star
id|range
comma
r_struct
id|ip_conntrack
op_star
id|conntrack
comma
r_int
r_int
id|hooknum
)paren
(brace
r_struct
id|ip_nat_protocol
op_star
id|proto
op_assign
id|ip_nat_find_proto
c_func
(paren
id|orig_tuple-&gt;dst.protonum
)paren
suffix:semicolon
multiline_comment|/* 1) If this srcip/proto/src-proto-part is currently mapped,&n;&t;   and that same mapping gives a unique tuple within the given&n;&t;   range, use that.&n;&n;&t;   This is only required for source (ie. NAT/masq) mappings.&n;&t;   So far, we don&squot;t do local source mappings, so multiple&n;&t;   manips not an issue.  */
r_if
c_cond
(paren
id|hooknum
op_eq
id|NF_IP_POST_ROUTING
)paren
(brace
r_if
c_cond
(paren
id|find_appropriate_src
c_func
(paren
id|orig_tuple
comma
id|tuple
comma
id|range
)paren
)paren
(brace
id|DEBUGP
c_func
(paren
l_string|&quot;get_unique_tuple: Found current src map&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ip_nat_used_tuple
c_func
(paren
id|tuple
comma
id|conntrack
)paren
)paren
r_return
suffix:semicolon
)brace
)brace
multiline_comment|/* 2) Select the least-used IP/proto combination in the given&n;&t;   range. */
op_star
id|tuple
op_assign
op_star
id|orig_tuple
suffix:semicolon
id|find_best_ips_proto
c_func
(paren
id|tuple
comma
id|range
comma
id|conntrack
comma
id|hooknum
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hooknum
op_eq
id|NF_IP_LOCAL_OUT
op_logical_and
id|tuple-&gt;dst.ip
op_ne
id|orig_tuple-&gt;dst.ip
)paren
id|warn_if_extra_mangle
c_func
(paren
id|tuple-&gt;src.ip
comma
id|tuple-&gt;dst.ip
)paren
suffix:semicolon
multiline_comment|/* 3) The per-protocol part of the manip is made to map into&n;&t;   the range to make a unique tuple. */
multiline_comment|/* Only bother mapping if it&squot;s not already in range and unique */
r_if
c_cond
(paren
(paren
op_logical_neg
(paren
id|range-&gt;flags
op_amp
id|IP_NAT_RANGE_PROTO_SPECIFIED
)paren
op_logical_or
id|proto
op_member_access_from_pointer
id|in_range
c_func
(paren
id|tuple
comma
id|HOOK2MANIP
c_func
(paren
id|hooknum
)paren
comma
op_amp
id|range-&gt;min
comma
op_amp
id|range-&gt;max
)paren
)paren
op_logical_and
op_logical_neg
id|ip_nat_used_tuple
c_func
(paren
id|tuple
comma
id|conntrack
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* Last change: get protocol to try to obtain unique tuple. */
id|proto
op_member_access_from_pointer
id|unique_tuple
c_func
(paren
id|tuple
comma
id|range
comma
id|HOOK2MANIP
c_func
(paren
id|hooknum
)paren
comma
id|conntrack
)paren
suffix:semicolon
)brace
multiline_comment|/* Where to manip the reply packets (will be reverse manip). */
DECL|variable|opposite_hook
r_static
r_int
r_int
id|opposite_hook
(braket
id|NF_IP_NUMHOOKS
)braket
op_assign
(brace
(braket
id|NF_IP_PRE_ROUTING
)braket
op_assign
id|NF_IP_POST_ROUTING
comma
(braket
id|NF_IP_POST_ROUTING
)braket
op_assign
id|NF_IP_PRE_ROUTING
comma
(braket
id|NF_IP_LOCAL_OUT
)braket
op_assign
id|NF_IP_LOCAL_IN
comma
(braket
id|NF_IP_LOCAL_IN
)braket
op_assign
id|NF_IP_LOCAL_OUT
comma
)brace
suffix:semicolon
DECL|function|replace_in_hashes
r_static
r_void
id|replace_in_hashes
c_func
(paren
r_struct
id|ip_conntrack
op_star
id|conntrack
comma
r_struct
id|ip_nat_info
op_star
id|info
)paren
(brace
multiline_comment|/* Source has changed, so replace in hashes. */
r_int
r_int
id|srchash
op_assign
id|hash_by_src
c_func
(paren
op_amp
id|conntrack-&gt;tuplehash
(braket
id|IP_CT_DIR_ORIGINAL
)braket
dot
id|tuple.src
comma
id|conntrack-&gt;tuplehash
(braket
id|IP_CT_DIR_ORIGINAL
)braket
dot
id|tuple.dst.protonum
)paren
suffix:semicolon
id|MUST_BE_WRITE_LOCKED
c_func
(paren
op_amp
id|ip_nat_lock
)paren
suffix:semicolon
id|list_move
c_func
(paren
op_amp
id|info-&gt;bysource
comma
op_amp
id|bysource
(braket
id|srchash
)braket
)paren
suffix:semicolon
)brace
DECL|function|place_in_hashes
r_static
r_void
id|place_in_hashes
c_func
(paren
r_struct
id|ip_conntrack
op_star
id|conntrack
comma
r_struct
id|ip_nat_info
op_star
id|info
)paren
(brace
r_int
r_int
id|srchash
op_assign
id|hash_by_src
c_func
(paren
op_amp
id|conntrack-&gt;tuplehash
(braket
id|IP_CT_DIR_ORIGINAL
)braket
dot
id|tuple.src
comma
id|conntrack-&gt;tuplehash
(braket
id|IP_CT_DIR_ORIGINAL
)braket
dot
id|tuple.dst.protonum
)paren
suffix:semicolon
id|MUST_BE_WRITE_LOCKED
c_func
(paren
op_amp
id|ip_nat_lock
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|info-&gt;bysource
comma
op_amp
id|bysource
(braket
id|srchash
)braket
)paren
suffix:semicolon
)brace
r_int
r_int
DECL|function|ip_nat_setup_info
id|ip_nat_setup_info
c_func
(paren
r_struct
id|ip_conntrack
op_star
id|conntrack
comma
r_const
r_struct
id|ip_nat_range
op_star
id|range
comma
r_int
r_int
id|hooknum
)paren
(brace
r_struct
id|ip_conntrack_tuple
id|new_tuple
comma
id|inv_tuple
comma
id|reply
suffix:semicolon
r_struct
id|ip_conntrack_tuple
id|orig_tp
suffix:semicolon
r_struct
id|ip_nat_info
op_star
id|info
op_assign
op_amp
id|conntrack-&gt;nat.info
suffix:semicolon
r_int
id|in_hashes
op_assign
id|info-&gt;initialized
suffix:semicolon
id|MUST_BE_WRITE_LOCKED
c_func
(paren
op_amp
id|ip_nat_lock
)paren
suffix:semicolon
id|IP_NF_ASSERT
c_func
(paren
id|hooknum
op_eq
id|NF_IP_PRE_ROUTING
op_logical_or
id|hooknum
op_eq
id|NF_IP_POST_ROUTING
op_logical_or
id|hooknum
op_eq
id|NF_IP_LOCAL_IN
op_logical_or
id|hooknum
op_eq
id|NF_IP_LOCAL_OUT
)paren
suffix:semicolon
id|IP_NF_ASSERT
c_func
(paren
id|info-&gt;num_manips
OL
id|IP_NAT_MAX_MANIPS
)paren
suffix:semicolon
id|IP_NF_ASSERT
c_func
(paren
op_logical_neg
(paren
id|info-&gt;initialized
op_amp
(paren
l_int|1
op_lshift
id|HOOK2MANIP
c_func
(paren
id|hooknum
)paren
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/* What we&squot;ve got will look like inverse of reply. Normally&n;&t;   this is what is in the conntrack, except for prior&n;&t;   manipulations (future optimization: if num_manips == 0,&n;&t;   orig_tp =&n;&t;   conntrack-&gt;tuplehash[IP_CT_DIR_ORIGINAL].tuple) */
id|invert_tuplepr
c_func
(paren
op_amp
id|orig_tp
comma
op_amp
id|conntrack-&gt;tuplehash
(braket
id|IP_CT_DIR_REPLY
)braket
dot
id|tuple
)paren
suffix:semicolon
macro_line|#if 0
(brace
r_int
r_int
id|i
suffix:semicolon
id|DEBUGP
c_func
(paren
l_string|&quot;Hook %u (%s), &quot;
comma
id|hooknum
comma
id|HOOK2MANIP
c_func
(paren
id|hooknum
)paren
op_eq
id|IP_NAT_MANIP_SRC
ques
c_cond
l_string|&quot;SRC&quot;
suffix:colon
l_string|&quot;DST&quot;
)paren
suffix:semicolon
id|DUMP_TUPLE
c_func
(paren
op_amp
id|orig_tp
)paren
suffix:semicolon
id|DEBUGP
c_func
(paren
l_string|&quot;Range %p: &quot;
comma
id|mr
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|mr-&gt;rangesize
suffix:semicolon
id|i
op_increment
)paren
(brace
id|DEBUGP
c_func
(paren
l_string|&quot;%u:%s%s %u.%u.%u.%u - %u.%u.%u.%u %u - %u&bslash;n&quot;
comma
id|i
comma
(paren
id|mr-&gt;range
(braket
id|i
)braket
dot
id|flags
op_amp
id|IP_NAT_RANGE_MAP_IPS
)paren
ques
c_cond
l_string|&quot; MAP_IPS&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|mr-&gt;range
(braket
id|i
)braket
dot
id|flags
op_amp
id|IP_NAT_RANGE_PROTO_SPECIFIED
)paren
ques
c_cond
l_string|&quot; PROTO_SPECIFIED&quot;
suffix:colon
l_string|&quot;&quot;
comma
id|NIPQUAD
c_func
(paren
id|mr-&gt;range
(braket
id|i
)braket
dot
id|min_ip
)paren
comma
id|NIPQUAD
c_func
(paren
id|mr-&gt;range
(braket
id|i
)braket
dot
id|max_ip
)paren
comma
id|mr-&gt;range
(braket
id|i
)braket
dot
id|min.all
comma
id|mr-&gt;range
(braket
id|i
)braket
dot
id|max.all
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
id|get_unique_tuple
c_func
(paren
op_amp
id|new_tuple
comma
op_amp
id|orig_tp
comma
id|range
comma
id|conntrack
comma
id|hooknum
)paren
suffix:semicolon
multiline_comment|/* We now have two tuples (SRCIP/SRCPT/DSTIP/DSTPT):&n;&t;   the original (A/B/C/D&squot;) and the mangled one (E/F/G/H&squot;).&n;&n;&t;   We&squot;re only allowed to work with the SRC per-proto&n;&t;   part, so we create inverses of both to start, then&n;&t;   derive the other fields we need.  */
multiline_comment|/* Reply connection: simply invert the new tuple&n;&t;   (G/H/E/F&squot;) */
id|invert_tuplepr
c_func
(paren
op_amp
id|reply
comma
op_amp
id|new_tuple
)paren
suffix:semicolon
multiline_comment|/* Alter conntrack table so will recognize replies. */
id|ip_conntrack_alter_reply
c_func
(paren
id|conntrack
comma
op_amp
id|reply
)paren
suffix:semicolon
multiline_comment|/* FIXME: We can simply used existing conntrack reply tuple&n;           here --RR */
multiline_comment|/* Create inverse of original: C/D/A/B&squot; */
id|invert_tuplepr
c_func
(paren
op_amp
id|inv_tuple
comma
op_amp
id|orig_tp
)paren
suffix:semicolon
multiline_comment|/* Has source changed?. */
r_if
c_cond
(paren
op_logical_neg
id|ip_ct_tuple_src_equal
c_func
(paren
op_amp
id|new_tuple
comma
op_amp
id|orig_tp
)paren
)paren
(brace
id|IP_NF_ASSERT
c_func
(paren
id|HOOK2MANIP
c_func
(paren
id|hooknum
)paren
op_eq
id|IP_NAT_MANIP_SRC
)paren
suffix:semicolon
id|IP_NF_ASSERT
c_func
(paren
id|ip_ct_tuple_dst_equal
c_func
(paren
op_amp
id|new_tuple
comma
op_amp
id|orig_tp
)paren
)paren
suffix:semicolon
multiline_comment|/* In this direction, a source manip. */
id|info-&gt;manips
(braket
id|info-&gt;num_manips
op_increment
)braket
op_assign
(paren
(paren
r_struct
id|ip_nat_info_manip
)paren
(brace
id|IP_CT_DIR_ORIGINAL
comma
id|hooknum
comma
id|IP_NAT_MANIP_SRC
comma
id|new_tuple.src
)brace
)paren
suffix:semicolon
id|IP_NF_ASSERT
c_func
(paren
id|info-&gt;num_manips
OL
id|IP_NAT_MAX_MANIPS
)paren
suffix:semicolon
multiline_comment|/* In the reverse direction, a destination manip. */
id|info-&gt;manips
(braket
id|info-&gt;num_manips
op_increment
)braket
op_assign
(paren
(paren
r_struct
id|ip_nat_info_manip
)paren
(brace
id|IP_CT_DIR_REPLY
comma
id|opposite_hook
(braket
id|hooknum
)braket
comma
id|IP_NAT_MANIP_DST
comma
id|orig_tp.src
)brace
)paren
suffix:semicolon
id|IP_NF_ASSERT
c_func
(paren
id|info-&gt;num_manips
op_le
id|IP_NAT_MAX_MANIPS
)paren
suffix:semicolon
)brace
multiline_comment|/* Has destination changed? */
r_if
c_cond
(paren
op_logical_neg
id|ip_ct_tuple_dst_equal
c_func
(paren
op_amp
id|new_tuple
comma
op_amp
id|orig_tp
)paren
)paren
(brace
id|IP_NF_ASSERT
c_func
(paren
id|HOOK2MANIP
c_func
(paren
id|hooknum
)paren
op_eq
id|IP_NAT_MANIP_DST
)paren
suffix:semicolon
multiline_comment|/* In this direction, a destination manip */
id|info-&gt;manips
(braket
id|info-&gt;num_manips
op_increment
)braket
op_assign
(paren
(paren
r_struct
id|ip_nat_info_manip
)paren
(brace
id|IP_CT_DIR_ORIGINAL
comma
id|hooknum
comma
id|IP_NAT_MANIP_DST
comma
id|reply.src
)brace
)paren
suffix:semicolon
id|IP_NF_ASSERT
c_func
(paren
id|info-&gt;num_manips
OL
id|IP_NAT_MAX_MANIPS
)paren
suffix:semicolon
multiline_comment|/* In the reverse direction, a source manip. */
id|info-&gt;manips
(braket
id|info-&gt;num_manips
op_increment
)braket
op_assign
(paren
(paren
r_struct
id|ip_nat_info_manip
)paren
(brace
id|IP_CT_DIR_REPLY
comma
id|opposite_hook
(braket
id|hooknum
)braket
comma
id|IP_NAT_MANIP_SRC
comma
id|inv_tuple.src
)brace
)paren
suffix:semicolon
id|IP_NF_ASSERT
c_func
(paren
id|info-&gt;num_manips
op_le
id|IP_NAT_MAX_MANIPS
)paren
suffix:semicolon
)brace
multiline_comment|/* It&squot;s done. */
id|info-&gt;initialized
op_or_assign
(paren
l_int|1
op_lshift
id|HOOK2MANIP
c_func
(paren
id|hooknum
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|in_hashes
)paren
id|replace_in_hashes
c_func
(paren
id|conntrack
comma
id|info
)paren
suffix:semicolon
r_else
id|place_in_hashes
c_func
(paren
id|conntrack
comma
id|info
)paren
suffix:semicolon
r_return
id|NF_ACCEPT
suffix:semicolon
)brace
multiline_comment|/* Returns true if succeeded. */
r_static
r_int
DECL|function|manip_pkt
id|manip_pkt
c_func
(paren
id|u_int16_t
id|proto
comma
r_struct
id|sk_buff
op_star
op_star
id|pskb
comma
r_int
r_int
id|iphdroff
comma
r_const
r_struct
id|ip_conntrack_manip
op_star
id|manip
comma
r_enum
id|ip_nat_manip_type
id|maniptype
)paren
(brace
r_struct
id|iphdr
op_star
id|iph
suffix:semicolon
(paren
op_star
id|pskb
)paren
op_member_access_from_pointer
id|nfcache
op_or_assign
id|NFC_ALTERED
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skb_ip_make_writable
c_func
(paren
id|pskb
comma
id|iphdroff
op_plus
r_sizeof
(paren
op_star
id|iph
)paren
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|iph
op_assign
(paren
r_void
op_star
)paren
(paren
op_star
id|pskb
)paren
op_member_access_from_pointer
id|data
op_plus
id|iphdroff
suffix:semicolon
multiline_comment|/* Manipulate protcol part. */
r_if
c_cond
(paren
op_logical_neg
id|ip_nat_find_proto
c_func
(paren
id|proto
)paren
op_member_access_from_pointer
id|manip_pkt
c_func
(paren
id|pskb
comma
id|iphdroff
comma
id|manip
comma
id|maniptype
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|iph
op_assign
(paren
r_void
op_star
)paren
(paren
op_star
id|pskb
)paren
op_member_access_from_pointer
id|data
op_plus
id|iphdroff
suffix:semicolon
r_if
c_cond
(paren
id|maniptype
op_eq
id|IP_NAT_MANIP_SRC
)paren
(brace
id|iph-&gt;check
op_assign
id|ip_nat_cheat_check
c_func
(paren
op_complement
id|iph-&gt;saddr
comma
id|manip-&gt;ip
comma
id|iph-&gt;check
)paren
suffix:semicolon
id|iph-&gt;saddr
op_assign
id|manip-&gt;ip
suffix:semicolon
)brace
r_else
(brace
id|iph-&gt;check
op_assign
id|ip_nat_cheat_check
c_func
(paren
op_complement
id|iph-&gt;daddr
comma
id|manip-&gt;ip
comma
id|iph-&gt;check
)paren
suffix:semicolon
id|iph-&gt;daddr
op_assign
id|manip-&gt;ip
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Do packet manipulations according to binding. */
r_int
r_int
DECL|function|do_bindings
id|do_bindings
c_func
(paren
r_struct
id|ip_conntrack
op_star
id|ct
comma
r_enum
id|ip_conntrack_info
id|ctinfo
comma
r_struct
id|ip_nat_info
op_star
id|info
comma
r_int
r_int
id|hooknum
comma
r_struct
id|sk_buff
op_star
op_star
id|pskb
)paren
(brace
r_int
id|i
comma
id|ret
op_assign
id|NF_ACCEPT
suffix:semicolon
r_enum
id|ip_conntrack_dir
id|dir
op_assign
id|CTINFO2DIR
c_func
(paren
id|ctinfo
)paren
suffix:semicolon
r_int
id|proto
op_assign
(paren
op_star
id|pskb
)paren
op_member_access_from_pointer
id|nh.iph-&gt;protocol
suffix:semicolon
multiline_comment|/* Need nat lock to protect against modification, but neither&n;&t;   conntrack (referenced) and helper (deleted with&n;&t;   synchronize_bh()) can vanish. */
id|READ_LOCK
c_func
(paren
op_amp
id|ip_nat_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|info-&gt;num_manips
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|info-&gt;manips
(braket
id|i
)braket
dot
id|direction
op_eq
id|dir
op_logical_and
id|info-&gt;manips
(braket
id|i
)braket
dot
id|hooknum
op_eq
id|hooknum
)paren
(brace
id|DEBUGP
c_func
(paren
l_string|&quot;Mangling %p: %s to %u.%u.%u.%u %u&bslash;n&quot;
comma
op_star
id|pskb
comma
id|info-&gt;manips
(braket
id|i
)braket
dot
id|maniptype
op_eq
id|IP_NAT_MANIP_SRC
ques
c_cond
l_string|&quot;SRC&quot;
suffix:colon
l_string|&quot;DST&quot;
comma
id|NIPQUAD
c_func
(paren
id|info-&gt;manips
(braket
id|i
)braket
dot
id|manip.ip
)paren
comma
id|htons
c_func
(paren
id|info-&gt;manips
(braket
id|i
)braket
dot
id|manip.u.all
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|manip_pkt
c_func
(paren
id|proto
comma
id|pskb
comma
l_int|0
comma
op_amp
id|info-&gt;manips
(braket
id|i
)braket
dot
id|manip
comma
id|info-&gt;manips
(braket
id|i
)braket
dot
id|maniptype
)paren
)paren
(brace
id|READ_UNLOCK
c_func
(paren
op_amp
id|ip_nat_lock
)paren
suffix:semicolon
r_return
id|NF_DROP
suffix:semicolon
)brace
)brace
)brace
id|READ_UNLOCK
c_func
(paren
op_amp
id|ip_nat_lock
)paren
suffix:semicolon
multiline_comment|/* FIXME: NAT/conntrack helpers should set ctinfo &amp;&n;&t; * CT_INFO_RESYNC on packets, so we don&squot;t have to adjust all&n;&t; * connections with conntrack helpers --RR */
r_if
c_cond
(paren
id|ct-&gt;helper
op_logical_and
id|proto
op_eq
id|IPPROTO_TCP
op_logical_and
(paren
id|hooknum
op_eq
id|NF_IP_POST_ROUTING
op_logical_or
id|hooknum
op_eq
id|NF_IP_LOCAL_IN
)paren
)paren
(brace
id|DEBUGP
c_func
(paren
l_string|&quot;ip_nat_core: adjusting sequence number&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* future: put this in a l4-proto specific function,&n;&t;&t; * and call this function here. */
r_if
c_cond
(paren
op_logical_neg
id|ip_nat_seq_adjust
c_func
(paren
id|pskb
comma
id|ct
comma
id|ctinfo
)paren
)paren
id|ret
op_assign
id|NF_DROP
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|function|tuple_src_equal_dst
r_static
r_inline
r_int
id|tuple_src_equal_dst
c_func
(paren
r_const
r_struct
id|ip_conntrack_tuple
op_star
id|t1
comma
r_const
r_struct
id|ip_conntrack_tuple
op_star
id|t2
)paren
(brace
r_if
c_cond
(paren
id|t1-&gt;dst.protonum
op_ne
id|t2-&gt;dst.protonum
op_logical_or
id|t1-&gt;src.ip
op_ne
id|t2-&gt;dst.ip
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|t1-&gt;dst.protonum
op_ne
id|IPPROTO_ICMP
)paren
r_return
id|t1-&gt;src.u.all
op_eq
id|t2-&gt;dst.u.all
suffix:semicolon
r_else
(brace
r_struct
id|ip_conntrack_tuple
id|inv
suffix:semicolon
multiline_comment|/* ICMP tuples are asymetric */
id|invert_tuplepr
c_func
(paren
op_amp
id|inv
comma
id|t1
)paren
suffix:semicolon
r_return
id|inv.src.u.all
op_eq
id|t2-&gt;src.u.all
op_logical_and
id|inv.dst.u.all
op_eq
id|t2-&gt;dst.u.all
suffix:semicolon
)brace
)brace
r_int
DECL|function|icmp_reply_translation
id|icmp_reply_translation
c_func
(paren
r_struct
id|sk_buff
op_star
op_star
id|pskb
comma
r_struct
id|ip_conntrack
op_star
id|conntrack
comma
r_int
r_int
id|hooknum
comma
r_int
id|dir
)paren
(brace
r_struct
(brace
r_struct
id|icmphdr
id|icmp
suffix:semicolon
r_struct
id|iphdr
id|ip
suffix:semicolon
)brace
op_star
id|inside
suffix:semicolon
r_int
r_int
id|i
suffix:semicolon
r_struct
id|ip_nat_info
op_star
id|info
op_assign
op_amp
id|conntrack-&gt;nat.info
suffix:semicolon
r_struct
id|ip_conntrack_tuple
op_star
id|cttuple
comma
id|innertuple
suffix:semicolon
r_int
id|hdrlen
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skb_ip_make_writable
c_func
(paren
id|pskb
comma
(paren
op_star
id|pskb
)paren
op_member_access_from_pointer
id|nh.iph-&gt;ihl
op_star
l_int|4
op_plus
r_sizeof
(paren
op_star
id|inside
)paren
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|inside
op_assign
(paren
r_void
op_star
)paren
(paren
op_star
id|pskb
)paren
op_member_access_from_pointer
id|data
op_plus
(paren
op_star
id|pskb
)paren
op_member_access_from_pointer
id|nh.iph-&gt;ihl
op_star
l_int|4
suffix:semicolon
multiline_comment|/* We&squot;re actually going to mangle it beyond trivial checksum&n;&t;   adjustment, so make sure the current checksum is correct. */
r_if
c_cond
(paren
(paren
op_star
id|pskb
)paren
op_member_access_from_pointer
id|ip_summed
op_ne
id|CHECKSUM_UNNECESSARY
)paren
(brace
id|hdrlen
op_assign
(paren
op_star
id|pskb
)paren
op_member_access_from_pointer
id|nh.iph-&gt;ihl
op_star
l_int|4
suffix:semicolon
r_if
c_cond
(paren
(paren
id|u16
)paren
id|csum_fold
c_func
(paren
id|skb_checksum
c_func
(paren
op_star
id|pskb
comma
id|hdrlen
comma
(paren
op_star
id|pskb
)paren
op_member_access_from_pointer
id|len
op_minus
id|hdrlen
comma
l_int|0
)paren
)paren
)paren
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Must be RELATED */
id|IP_NF_ASSERT
c_func
(paren
(paren
op_star
id|pskb
)paren
op_member_access_from_pointer
id|nfctinfo
op_eq
id|IP_CT_RELATED
op_logical_or
(paren
op_star
id|pskb
)paren
op_member_access_from_pointer
id|nfctinfo
op_eq
id|IP_CT_RELATED
op_plus
id|IP_CT_IS_REPLY
)paren
suffix:semicolon
multiline_comment|/* Redirects on non-null nats must be dropped, else they&squot;ll&n;           start talking to each other without our translation, and be&n;           confused... --RR */
r_if
c_cond
(paren
id|inside-&gt;icmp.type
op_eq
id|ICMP_REDIRECT
)paren
(brace
multiline_comment|/* Don&squot;t care about races here. */
r_if
c_cond
(paren
id|info-&gt;initialized
op_ne
(paren
(paren
l_int|1
op_lshift
id|IP_NAT_MANIP_SRC
)paren
op_or
(paren
l_int|1
op_lshift
id|IP_NAT_MANIP_DST
)paren
)paren
op_logical_or
id|info-&gt;num_manips
op_ne
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
)brace
id|DEBUGP
c_func
(paren
l_string|&quot;icmp_reply_translation: translating error %p hook %u dir %s&bslash;n&quot;
comma
op_star
id|pskb
comma
id|hooknum
comma
id|dir
op_eq
id|IP_CT_DIR_ORIGINAL
ques
c_cond
l_string|&quot;ORIG&quot;
suffix:colon
l_string|&quot;REPLY&quot;
)paren
suffix:semicolon
multiline_comment|/* Note: May not be from a NAT&squot;d host, but probably safest to&n;&t;   do translation always as if it came from the host itself&n;&t;   (even though a &quot;host unreachable&quot; coming from the host&n;&t;   itself is a bit weird).&n;&n;&t;   More explanation: some people use NAT for anonymizing.&n;&t;   Also, CERT recommends dropping all packets from private IP&n;&t;   addresses (although ICMP errors from internal links with&n;&t;   such addresses are not too uncommon, as Alan Cox points&n;&t;   out) */
r_if
c_cond
(paren
op_logical_neg
id|ip_ct_get_tuple
c_func
(paren
op_amp
id|inside-&gt;ip
comma
op_star
id|pskb
comma
(paren
op_star
id|pskb
)paren
op_member_access_from_pointer
id|nh.iph-&gt;ihl
op_star
l_int|4
op_plus
r_sizeof
(paren
r_struct
id|icmphdr
)paren
op_plus
id|inside-&gt;ip.ihl
op_star
l_int|4
comma
op_amp
id|innertuple
comma
id|ip_ct_find_proto
c_func
(paren
id|inside-&gt;ip.protocol
)paren
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|cttuple
op_assign
op_amp
id|conntrack-&gt;tuplehash
(braket
id|dir
)braket
dot
id|tuple
suffix:semicolon
id|READ_LOCK
c_func
(paren
op_amp
id|ip_nat_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|info-&gt;num_manips
suffix:semicolon
id|i
op_increment
)paren
(brace
id|DEBUGP
c_func
(paren
l_string|&quot;icmp_reply: manip %u dir %s hook %u&bslash;n&quot;
comma
id|i
comma
id|info-&gt;manips
(braket
id|i
)braket
dot
id|direction
op_eq
id|IP_CT_DIR_ORIGINAL
ques
c_cond
l_string|&quot;ORIG&quot;
suffix:colon
l_string|&quot;REPLY&quot;
comma
id|info-&gt;manips
(braket
id|i
)braket
dot
id|hooknum
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;manips
(braket
id|i
)braket
dot
id|direction
op_ne
id|dir
)paren
r_continue
suffix:semicolon
multiline_comment|/* Mapping the inner packet is just like a normal packet, except&n;&t;&t; * it was never src/dst reversed, so where we would normally&n;&t;&t; * apply a dst manip, we apply a src, and vice versa. */
multiline_comment|/* Only true for forwarded packets, locally generated packets&n;&t;&t; * never hit PRE_ROUTING, we need to apply their PRE_ROUTING&n;&t;&t; * manips in LOCAL_OUT. */
r_if
c_cond
(paren
id|hooknum
op_eq
id|NF_IP_LOCAL_OUT
op_logical_and
id|info-&gt;manips
(braket
id|i
)braket
dot
id|hooknum
op_eq
id|NF_IP_PRE_ROUTING
)paren
id|hooknum
op_assign
id|info-&gt;manips
(braket
id|i
)braket
dot
id|hooknum
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;manips
(braket
id|i
)braket
dot
id|hooknum
op_ne
id|hooknum
)paren
r_continue
suffix:semicolon
multiline_comment|/* ICMP errors may be generated locally for packets that&n;&t;&t; * don&squot;t have all NAT manips applied yet. Verify manips&n;&t;&t; * have been applied before reversing them */
r_if
c_cond
(paren
id|info-&gt;manips
(braket
id|i
)braket
dot
id|maniptype
op_eq
id|IP_NAT_MANIP_SRC
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|tuple_src_equal_dst
c_func
(paren
id|cttuple
comma
op_amp
id|innertuple
)paren
)paren
r_continue
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
id|tuple_src_equal_dst
c_func
(paren
op_amp
id|innertuple
comma
id|cttuple
)paren
)paren
r_continue
suffix:semicolon
)brace
id|DEBUGP
c_func
(paren
l_string|&quot;icmp_reply: inner %s -&gt; %u.%u.%u.%u %u&bslash;n&quot;
comma
id|info-&gt;manips
(braket
id|i
)braket
dot
id|maniptype
op_eq
id|IP_NAT_MANIP_SRC
ques
c_cond
l_string|&quot;DST&quot;
suffix:colon
l_string|&quot;SRC&quot;
comma
id|NIPQUAD
c_func
(paren
id|info-&gt;manips
(braket
id|i
)braket
dot
id|manip.ip
)paren
comma
id|ntohs
c_func
(paren
id|info-&gt;manips
(braket
id|i
)braket
dot
id|manip.u.udp.port
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|manip_pkt
c_func
(paren
id|inside-&gt;ip.protocol
comma
id|pskb
comma
(paren
op_star
id|pskb
)paren
op_member_access_from_pointer
id|nh.iph-&gt;ihl
op_star
l_int|4
op_plus
r_sizeof
(paren
id|inside-&gt;icmp
)paren
comma
op_amp
id|info-&gt;manips
(braket
id|i
)braket
dot
id|manip
comma
op_logical_neg
id|info-&gt;manips
(braket
id|i
)braket
dot
id|maniptype
)paren
)paren
r_goto
id|unlock_fail
suffix:semicolon
multiline_comment|/* Outer packet needs to have IP header NATed like&n;                   it&squot;s a reply. */
multiline_comment|/* Use mapping to map outer packet: 0 give no&n;                          per-proto mapping */
id|DEBUGP
c_func
(paren
l_string|&quot;icmp_reply: outer %s -&gt; %u.%u.%u.%u&bslash;n&quot;
comma
id|info-&gt;manips
(braket
id|i
)braket
dot
id|maniptype
op_eq
id|IP_NAT_MANIP_SRC
ques
c_cond
l_string|&quot;SRC&quot;
suffix:colon
l_string|&quot;DST&quot;
comma
id|NIPQUAD
c_func
(paren
id|info-&gt;manips
(braket
id|i
)braket
dot
id|manip.ip
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|manip_pkt
c_func
(paren
l_int|0
comma
id|pskb
comma
l_int|0
comma
op_amp
id|info-&gt;manips
(braket
id|i
)braket
dot
id|manip
comma
id|info-&gt;manips
(braket
id|i
)braket
dot
id|maniptype
)paren
)paren
r_goto
id|unlock_fail
suffix:semicolon
)brace
id|READ_UNLOCK
c_func
(paren
op_amp
id|ip_nat_lock
)paren
suffix:semicolon
id|hdrlen
op_assign
(paren
op_star
id|pskb
)paren
op_member_access_from_pointer
id|nh.iph-&gt;ihl
op_star
l_int|4
suffix:semicolon
id|inside
op_assign
(paren
r_void
op_star
)paren
(paren
op_star
id|pskb
)paren
op_member_access_from_pointer
id|data
op_plus
(paren
op_star
id|pskb
)paren
op_member_access_from_pointer
id|nh.iph-&gt;ihl
op_star
l_int|4
suffix:semicolon
id|inside-&gt;icmp.checksum
op_assign
l_int|0
suffix:semicolon
id|inside-&gt;icmp.checksum
op_assign
id|csum_fold
c_func
(paren
id|skb_checksum
c_func
(paren
op_star
id|pskb
comma
id|hdrlen
comma
(paren
op_star
id|pskb
)paren
op_member_access_from_pointer
id|len
op_minus
id|hdrlen
comma
l_int|0
)paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
id|unlock_fail
suffix:colon
id|READ_UNLOCK
c_func
(paren
op_amp
id|ip_nat_lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ip_nat_init
r_int
id|__init
id|ip_nat_init
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/* Leave them the same for the moment. */
id|ip_nat_htable_size
op_assign
id|ip_conntrack_htable_size
suffix:semicolon
multiline_comment|/* One vmalloc for both hash tables */
id|bysource
op_assign
id|vmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|list_head
)paren
op_star
id|ip_nat_htable_size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bysource
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
multiline_comment|/* Sew in builtin protocols. */
id|WRITE_LOCK
c_func
(paren
op_amp
id|ip_nat_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_IP_NAT_PROTO
suffix:semicolon
id|i
op_increment
)paren
id|ip_nat_protos
(braket
id|i
)braket
op_assign
op_amp
id|ip_nat_unknown_protocol
suffix:semicolon
id|ip_nat_protos
(braket
id|IPPROTO_TCP
)braket
op_assign
op_amp
id|ip_nat_protocol_tcp
suffix:semicolon
id|ip_nat_protos
(braket
id|IPPROTO_UDP
)braket
op_assign
op_amp
id|ip_nat_protocol_udp
suffix:semicolon
id|ip_nat_protos
(braket
id|IPPROTO_ICMP
)braket
op_assign
op_amp
id|ip_nat_protocol_icmp
suffix:semicolon
id|WRITE_UNLOCK
c_func
(paren
op_amp
id|ip_nat_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ip_nat_htable_size
suffix:semicolon
id|i
op_increment
)paren
(brace
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|bysource
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/* FIXME: Man, this is a hack.  &lt;SIGH&gt; */
id|IP_NF_ASSERT
c_func
(paren
id|ip_conntrack_destroyed
op_eq
l_int|NULL
)paren
suffix:semicolon
id|ip_conntrack_destroyed
op_assign
op_amp
id|ip_nat_cleanup_conntrack
suffix:semicolon
multiline_comment|/* Initialize fake conntrack so that NAT will skip it */
id|ip_conntrack_untracked.nat.info.initialized
op_or_assign
(paren
l_int|1
op_lshift
id|IP_NAT_MANIP_SRC
)paren
op_or
(paren
l_int|1
op_lshift
id|IP_NAT_MANIP_DST
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Clear NAT section of all conntracks, in case we&squot;re loaded again. */
DECL|function|clean_nat
r_static
r_int
id|clean_nat
c_func
(paren
r_struct
id|ip_conntrack
op_star
id|i
comma
r_void
op_star
id|data
)paren
(brace
id|memset
c_func
(paren
op_amp
id|i-&gt;nat
comma
l_int|0
comma
r_sizeof
(paren
id|i-&gt;nat
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Not __exit: called from ip_nat_standalone.c:init_or_cleanup() --RR */
DECL|function|ip_nat_cleanup
r_void
id|ip_nat_cleanup
c_func
(paren
r_void
)paren
(brace
id|ip_ct_iterate_cleanup
c_func
(paren
op_amp
id|clean_nat
comma
l_int|NULL
)paren
suffix:semicolon
id|ip_conntrack_destroyed
op_assign
l_int|NULL
suffix:semicolon
id|vfree
c_func
(paren
id|bysource
)paren
suffix:semicolon
)brace
eof
