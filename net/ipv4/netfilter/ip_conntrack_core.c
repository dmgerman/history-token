multiline_comment|/* Connection state tracking for netfilter.  This is separated from,&n;   but required by, the NAT layer; it can also be used by an iptables&n;   extension. */
multiline_comment|/* (C) 1999-2001 Paul `Rusty&squot; Russell  &n; * (C) 2002-2004 Netfilter Core Team &lt;coreteam@netfilter.org&gt;&n; *&n; * This program is free software; you can redistribute it and/or modify&n; * it under the terms of the GNU General Public License version 2 as&n; * published by the Free Software Foundation.&n; *&n; * 23 Apr 2001: Harald Welte &lt;laforge@gnumonks.org&gt;&n; * &t;- new API and handling of conntrack/nat helpers&n; * &t;- now capable of multiple expectations for one master&n; * 16 Jul 2002: Harald Welte &lt;laforge@gnumonks.org&gt;&n; * &t;- add usage/reference counts to ip_conntrack_expect&n; *&t;- export ip_conntrack[_expect]_{find_get,put} functions&n; * */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/icmp.h&gt;
macro_line|#include &lt;linux/ip.h&gt;
macro_line|#include &lt;linux/netfilter.h&gt;
macro_line|#include &lt;linux/netfilter_ipv4.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;linux/vmalloc.h&gt;
macro_line|#include &lt;net/checksum.h&gt;
macro_line|#include &lt;net/ip.h&gt;
macro_line|#include &lt;linux/stddef.h&gt;
macro_line|#include &lt;linux/sysctl.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/random.h&gt;
macro_line|#include &lt;linux/jhash.h&gt;
multiline_comment|/* For ERR_PTR().  Yeah, I know... --RR */
macro_line|#include &lt;linux/fs.h&gt;
multiline_comment|/* This rwlock protects the main hash table, protocol/helper/expected&n;   registrations, conntrack timers*/
DECL|macro|ASSERT_READ_LOCK
mdefine_line|#define ASSERT_READ_LOCK(x) MUST_BE_READ_LOCKED(&amp;ip_conntrack_lock)
DECL|macro|ASSERT_WRITE_LOCK
mdefine_line|#define ASSERT_WRITE_LOCK(x) MUST_BE_WRITE_LOCKED(&amp;ip_conntrack_lock)
macro_line|#include &lt;linux/netfilter_ipv4/ip_conntrack.h&gt;
macro_line|#include &lt;linux/netfilter_ipv4/ip_conntrack_protocol.h&gt;
macro_line|#include &lt;linux/netfilter_ipv4/ip_conntrack_helper.h&gt;
macro_line|#include &lt;linux/netfilter_ipv4/ip_conntrack_core.h&gt;
macro_line|#include &lt;linux/netfilter_ipv4/listhelp.h&gt;
DECL|macro|IP_CONNTRACK_VERSION
mdefine_line|#define IP_CONNTRACK_VERSION&t;&quot;2.1&quot;
macro_line|#if 0
mdefine_line|#define DEBUGP printk
macro_line|#else
DECL|macro|DEBUGP
mdefine_line|#define DEBUGP(format, args...)
macro_line|#endif
DECL|variable|ip_conntrack_lock
id|DECLARE_RWLOCK
c_func
(paren
id|ip_conntrack_lock
)paren
suffix:semicolon
DECL|variable|ip_conntrack_expect_tuple_lock
id|DECLARE_RWLOCK
c_func
(paren
id|ip_conntrack_expect_tuple_lock
)paren
suffix:semicolon
DECL|variable|ip_conntrack_destroyed
r_void
(paren
op_star
id|ip_conntrack_destroyed
)paren
(paren
r_struct
id|ip_conntrack
op_star
id|conntrack
)paren
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|ip_conntrack_expect_list
id|LIST_HEAD
c_func
(paren
id|ip_conntrack_expect_list
)paren
suffix:semicolon
DECL|variable|protocol_list
id|LIST_HEAD
c_func
(paren
id|protocol_list
)paren
suffix:semicolon
r_static
id|LIST_HEAD
c_func
(paren
id|helpers
)paren
suffix:semicolon
DECL|variable|ip_conntrack_htable_size
r_int
r_int
id|ip_conntrack_htable_size
op_assign
l_int|0
suffix:semicolon
DECL|variable|ip_conntrack_max
r_int
id|ip_conntrack_max
suffix:semicolon
DECL|variable|ip_conntrack_count
r_static
id|atomic_t
id|ip_conntrack_count
op_assign
id|ATOMIC_INIT
c_func
(paren
l_int|0
)paren
suffix:semicolon
DECL|variable|ip_conntrack_hash
r_struct
id|list_head
op_star
id|ip_conntrack_hash
suffix:semicolon
DECL|variable|ip_conntrack_cachep
r_static
id|kmem_cache_t
op_star
id|ip_conntrack_cachep
suffix:semicolon
DECL|variable|ip_conntrack_untracked
r_struct
id|ip_conntrack
id|ip_conntrack_untracked
suffix:semicolon
r_extern
r_struct
id|ip_conntrack_protocol
id|ip_conntrack_generic_protocol
suffix:semicolon
DECL|function|proto_cmpfn
r_static
r_inline
r_int
id|proto_cmpfn
c_func
(paren
r_const
r_struct
id|ip_conntrack_protocol
op_star
id|curr
comma
id|u_int8_t
id|protocol
)paren
(brace
r_return
id|protocol
op_eq
id|curr-&gt;proto
suffix:semicolon
)brace
DECL|function|__ip_ct_find_proto
r_struct
id|ip_conntrack_protocol
op_star
id|__ip_ct_find_proto
c_func
(paren
id|u_int8_t
id|protocol
)paren
(brace
r_struct
id|ip_conntrack_protocol
op_star
id|p
suffix:semicolon
id|MUST_BE_READ_LOCKED
c_func
(paren
op_amp
id|ip_conntrack_lock
)paren
suffix:semicolon
id|p
op_assign
id|LIST_FIND
c_func
(paren
op_amp
id|protocol_list
comma
id|proto_cmpfn
comma
r_struct
id|ip_conntrack_protocol
op_star
comma
id|protocol
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p
)paren
id|p
op_assign
op_amp
id|ip_conntrack_generic_protocol
suffix:semicolon
r_return
id|p
suffix:semicolon
)brace
DECL|function|ip_ct_find_proto
r_struct
id|ip_conntrack_protocol
op_star
id|ip_ct_find_proto
c_func
(paren
id|u_int8_t
id|protocol
)paren
(brace
r_struct
id|ip_conntrack_protocol
op_star
id|p
suffix:semicolon
id|READ_LOCK
c_func
(paren
op_amp
id|ip_conntrack_lock
)paren
suffix:semicolon
id|p
op_assign
id|__ip_ct_find_proto
c_func
(paren
id|protocol
)paren
suffix:semicolon
id|READ_UNLOCK
c_func
(paren
op_amp
id|ip_conntrack_lock
)paren
suffix:semicolon
r_return
id|p
suffix:semicolon
)brace
r_inline
r_void
DECL|function|ip_conntrack_put
id|ip_conntrack_put
c_func
(paren
r_struct
id|ip_conntrack
op_star
id|ct
)paren
(brace
id|IP_NF_ASSERT
c_func
(paren
id|ct
)paren
suffix:semicolon
id|IP_NF_ASSERT
c_func
(paren
id|ct-&gt;infos
(braket
l_int|0
)braket
dot
id|master
)paren
suffix:semicolon
multiline_comment|/* nf_conntrack_put wants to go via an info struct, so feed it&n;           one at random. */
id|nf_conntrack_put
c_func
(paren
op_amp
id|ct-&gt;infos
(braket
l_int|0
)braket
)paren
suffix:semicolon
)brace
DECL|variable|ip_conntrack_hash_rnd_initted
r_static
r_int
id|ip_conntrack_hash_rnd_initted
suffix:semicolon
DECL|variable|ip_conntrack_hash_rnd
r_static
r_int
r_int
id|ip_conntrack_hash_rnd
suffix:semicolon
r_static
id|u_int32_t
DECL|function|hash_conntrack
id|hash_conntrack
c_func
(paren
r_const
r_struct
id|ip_conntrack_tuple
op_star
id|tuple
)paren
(brace
macro_line|#if 0
id|dump_tuple
c_func
(paren
id|tuple
)paren
suffix:semicolon
macro_line|#endif
r_return
(paren
id|jhash_3words
c_func
(paren
id|tuple-&gt;src.ip
comma
(paren
id|tuple-&gt;dst.ip
op_xor
id|tuple-&gt;dst.protonum
)paren
comma
(paren
id|tuple-&gt;src.u.all
op_or
(paren
id|tuple-&gt;dst.u.all
op_lshift
l_int|16
)paren
)paren
comma
id|ip_conntrack_hash_rnd
)paren
op_mod
id|ip_conntrack_htable_size
)paren
suffix:semicolon
)brace
r_int
DECL|function|get_tuple
id|get_tuple
c_func
(paren
r_const
r_struct
id|iphdr
op_star
id|iph
comma
r_const
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
r_int
id|dataoff
comma
r_struct
id|ip_conntrack_tuple
op_star
id|tuple
comma
r_const
r_struct
id|ip_conntrack_protocol
op_star
id|protocol
)paren
(brace
multiline_comment|/* Never happen */
r_if
c_cond
(paren
id|iph-&gt;frag_off
op_amp
id|htons
c_func
(paren
id|IP_OFFSET
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ip_conntrack_core: Frag of proto %u.&bslash;n&quot;
comma
id|iph-&gt;protocol
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|tuple-&gt;src.ip
op_assign
id|iph-&gt;saddr
suffix:semicolon
id|tuple-&gt;dst.ip
op_assign
id|iph-&gt;daddr
suffix:semicolon
id|tuple-&gt;dst.protonum
op_assign
id|iph-&gt;protocol
suffix:semicolon
r_return
id|protocol
op_member_access_from_pointer
id|pkt_to_tuple
c_func
(paren
id|skb
comma
id|dataoff
comma
id|tuple
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|invert_tuple
id|invert_tuple
c_func
(paren
r_struct
id|ip_conntrack_tuple
op_star
id|inverse
comma
r_const
r_struct
id|ip_conntrack_tuple
op_star
id|orig
comma
r_const
r_struct
id|ip_conntrack_protocol
op_star
id|protocol
)paren
(brace
id|inverse-&gt;src.ip
op_assign
id|orig-&gt;dst.ip
suffix:semicolon
id|inverse-&gt;dst.ip
op_assign
id|orig-&gt;src.ip
suffix:semicolon
id|inverse-&gt;dst.protonum
op_assign
id|orig-&gt;dst.protonum
suffix:semicolon
r_return
id|protocol
op_member_access_from_pointer
id|invert_tuple
c_func
(paren
id|inverse
comma
id|orig
)paren
suffix:semicolon
)brace
multiline_comment|/* ip_conntrack_expect helper functions */
multiline_comment|/* Compare tuple parts depending on mask. */
DECL|function|expect_cmp
r_static
r_inline
r_int
id|expect_cmp
c_func
(paren
r_const
r_struct
id|ip_conntrack_expect
op_star
id|i
comma
r_const
r_struct
id|ip_conntrack_tuple
op_star
id|tuple
)paren
(brace
id|MUST_BE_READ_LOCKED
c_func
(paren
op_amp
id|ip_conntrack_expect_tuple_lock
)paren
suffix:semicolon
r_return
id|ip_ct_tuple_mask_cmp
c_func
(paren
id|tuple
comma
op_amp
id|i-&gt;tuple
comma
op_amp
id|i-&gt;mask
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|destroy_expect
id|destroy_expect
c_func
(paren
r_struct
id|ip_conntrack_expect
op_star
id|exp
)paren
(brace
id|DEBUGP
c_func
(paren
l_string|&quot;destroy_expect(%p) use=%d&bslash;n&quot;
comma
id|exp
comma
id|atomic_read
c_func
(paren
op_amp
id|exp-&gt;use
)paren
)paren
suffix:semicolon
id|IP_NF_ASSERT
c_func
(paren
id|atomic_read
c_func
(paren
op_amp
id|exp-&gt;use
)paren
op_eq
l_int|0
)paren
suffix:semicolon
id|IP_NF_ASSERT
c_func
(paren
op_logical_neg
id|timer_pending
c_func
(paren
op_amp
id|exp-&gt;timeout
)paren
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|exp
)paren
suffix:semicolon
)brace
DECL|function|ip_conntrack_expect_put
r_inline
r_void
id|ip_conntrack_expect_put
c_func
(paren
r_struct
id|ip_conntrack_expect
op_star
id|exp
)paren
(brace
id|IP_NF_ASSERT
c_func
(paren
id|exp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_dec_and_test
c_func
(paren
op_amp
id|exp-&gt;use
)paren
)paren
(brace
multiline_comment|/* usage count dropped to zero */
id|destroy_expect
c_func
(paren
id|exp
)paren
suffix:semicolon
)brace
)brace
r_static
r_inline
r_struct
id|ip_conntrack_expect
op_star
DECL|function|__ip_ct_expect_find
id|__ip_ct_expect_find
c_func
(paren
r_const
r_struct
id|ip_conntrack_tuple
op_star
id|tuple
)paren
(brace
id|MUST_BE_READ_LOCKED
c_func
(paren
op_amp
id|ip_conntrack_lock
)paren
suffix:semicolon
id|MUST_BE_READ_LOCKED
c_func
(paren
op_amp
id|ip_conntrack_expect_tuple_lock
)paren
suffix:semicolon
r_return
id|LIST_FIND
c_func
(paren
op_amp
id|ip_conntrack_expect_list
comma
id|expect_cmp
comma
r_struct
id|ip_conntrack_expect
op_star
comma
id|tuple
)paren
suffix:semicolon
)brace
multiline_comment|/* Find a expectation corresponding to a tuple. */
r_struct
id|ip_conntrack_expect
op_star
DECL|function|ip_conntrack_expect_find_get
id|ip_conntrack_expect_find_get
c_func
(paren
r_const
r_struct
id|ip_conntrack_tuple
op_star
id|tuple
)paren
(brace
r_struct
id|ip_conntrack_expect
op_star
id|exp
suffix:semicolon
id|READ_LOCK
c_func
(paren
op_amp
id|ip_conntrack_lock
)paren
suffix:semicolon
id|READ_LOCK
c_func
(paren
op_amp
id|ip_conntrack_expect_tuple_lock
)paren
suffix:semicolon
id|exp
op_assign
id|__ip_ct_expect_find
c_func
(paren
id|tuple
)paren
suffix:semicolon
r_if
c_cond
(paren
id|exp
)paren
id|atomic_inc
c_func
(paren
op_amp
id|exp-&gt;use
)paren
suffix:semicolon
id|READ_UNLOCK
c_func
(paren
op_amp
id|ip_conntrack_expect_tuple_lock
)paren
suffix:semicolon
id|READ_UNLOCK
c_func
(paren
op_amp
id|ip_conntrack_lock
)paren
suffix:semicolon
r_return
id|exp
suffix:semicolon
)brace
multiline_comment|/* remove one specific expectation from all lists and drop refcount,&n; * does _NOT_ delete the timer. */
DECL|function|__unexpect_related
r_static
r_void
id|__unexpect_related
c_func
(paren
r_struct
id|ip_conntrack_expect
op_star
id|expect
)paren
(brace
id|DEBUGP
c_func
(paren
l_string|&quot;unexpect_related(%p)&bslash;n&quot;
comma
id|expect
)paren
suffix:semicolon
id|MUST_BE_WRITE_LOCKED
c_func
(paren
op_amp
id|ip_conntrack_lock
)paren
suffix:semicolon
multiline_comment|/* we&squot;re not allowed to unexpect a confirmed expectation! */
id|IP_NF_ASSERT
c_func
(paren
op_logical_neg
id|expect-&gt;sibling
)paren
suffix:semicolon
multiline_comment|/* delete from global and local lists */
id|list_del
c_func
(paren
op_amp
id|expect-&gt;list
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|expect-&gt;expected_list
)paren
suffix:semicolon
multiline_comment|/* decrement expect-count of master conntrack */
r_if
c_cond
(paren
id|expect-&gt;expectant
)paren
id|expect-&gt;expectant-&gt;expecting
op_decrement
suffix:semicolon
id|ip_conntrack_expect_put
c_func
(paren
id|expect
)paren
suffix:semicolon
)brace
multiline_comment|/* remove one specific expecatation from all lists, drop refcount&n; * and expire timer. &n; * This function can _NOT_ be called for confirmed expects! */
DECL|function|unexpect_related
r_static
r_void
id|unexpect_related
c_func
(paren
r_struct
id|ip_conntrack_expect
op_star
id|expect
)paren
(brace
id|IP_NF_ASSERT
c_func
(paren
id|expect-&gt;expectant
)paren
suffix:semicolon
id|IP_NF_ASSERT
c_func
(paren
id|expect-&gt;expectant-&gt;helper
)paren
suffix:semicolon
multiline_comment|/* if we are supposed to have a timer, but we can&squot;t delete&n;&t; * it: race condition.  __unexpect_related will&n;&t; * be calledd by timeout function */
r_if
c_cond
(paren
id|expect-&gt;expectant-&gt;helper-&gt;timeout
op_logical_and
op_logical_neg
id|del_timer
c_func
(paren
op_amp
id|expect-&gt;timeout
)paren
)paren
r_return
suffix:semicolon
id|__unexpect_related
c_func
(paren
id|expect
)paren
suffix:semicolon
)brace
multiline_comment|/* delete all unconfirmed expectations for this conntrack */
DECL|function|remove_expectations
r_static
r_void
id|remove_expectations
c_func
(paren
r_struct
id|ip_conntrack
op_star
id|ct
comma
r_int
id|drop_refcount
)paren
(brace
r_struct
id|list_head
op_star
id|exp_entry
comma
op_star
id|next
suffix:semicolon
r_struct
id|ip_conntrack_expect
op_star
id|exp
suffix:semicolon
id|DEBUGP
c_func
(paren
l_string|&quot;remove_expectations(%p)&bslash;n&quot;
comma
id|ct
)paren
suffix:semicolon
id|list_for_each_safe
c_func
(paren
id|exp_entry
comma
id|next
comma
op_amp
id|ct-&gt;sibling_list
)paren
(brace
id|exp
op_assign
id|list_entry
c_func
(paren
id|exp_entry
comma
r_struct
id|ip_conntrack_expect
comma
id|expected_list
)paren
suffix:semicolon
multiline_comment|/* we skip established expectations, as we want to delete&n;&t;&t; * the un-established ones only */
r_if
c_cond
(paren
id|exp-&gt;sibling
)paren
(brace
id|DEBUGP
c_func
(paren
l_string|&quot;remove_expectations: skipping established %p of %p&bslash;n&quot;
comma
id|exp-&gt;sibling
comma
id|ct
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drop_refcount
)paren
(brace
multiline_comment|/* Indicate that this expectations parent is dead */
id|ip_conntrack_put
c_func
(paren
id|exp-&gt;expectant
)paren
suffix:semicolon
id|exp-&gt;expectant
op_assign
l_int|NULL
suffix:semicolon
)brace
r_continue
suffix:semicolon
)brace
id|IP_NF_ASSERT
c_func
(paren
id|list_inlist
c_func
(paren
op_amp
id|ip_conntrack_expect_list
comma
id|exp
)paren
)paren
suffix:semicolon
id|IP_NF_ASSERT
c_func
(paren
id|exp-&gt;expectant
op_eq
id|ct
)paren
suffix:semicolon
multiline_comment|/* delete expectation from global and private lists */
id|unexpect_related
c_func
(paren
id|exp
)paren
suffix:semicolon
)brace
)brace
r_static
r_void
DECL|function|clean_from_lists
id|clean_from_lists
c_func
(paren
r_struct
id|ip_conntrack
op_star
id|ct
)paren
(brace
r_int
r_int
id|ho
comma
id|hr
suffix:semicolon
id|DEBUGP
c_func
(paren
l_string|&quot;clean_from_lists(%p)&bslash;n&quot;
comma
id|ct
)paren
suffix:semicolon
id|MUST_BE_WRITE_LOCKED
c_func
(paren
op_amp
id|ip_conntrack_lock
)paren
suffix:semicolon
id|ho
op_assign
id|hash_conntrack
c_func
(paren
op_amp
id|ct-&gt;tuplehash
(braket
id|IP_CT_DIR_ORIGINAL
)braket
dot
id|tuple
)paren
suffix:semicolon
id|hr
op_assign
id|hash_conntrack
c_func
(paren
op_amp
id|ct-&gt;tuplehash
(braket
id|IP_CT_DIR_REPLY
)braket
dot
id|tuple
)paren
suffix:semicolon
id|LIST_DELETE
c_func
(paren
op_amp
id|ip_conntrack_hash
(braket
id|ho
)braket
comma
op_amp
id|ct-&gt;tuplehash
(braket
id|IP_CT_DIR_ORIGINAL
)braket
)paren
suffix:semicolon
id|LIST_DELETE
c_func
(paren
op_amp
id|ip_conntrack_hash
(braket
id|hr
)braket
comma
op_amp
id|ct-&gt;tuplehash
(braket
id|IP_CT_DIR_REPLY
)braket
)paren
suffix:semicolon
multiline_comment|/* Destroy all un-established, pending expectations */
id|remove_expectations
c_func
(paren
id|ct
comma
l_int|1
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|destroy_conntrack
id|destroy_conntrack
c_func
(paren
r_struct
id|nf_conntrack
op_star
id|nfct
)paren
(brace
r_struct
id|ip_conntrack
op_star
id|ct
op_assign
(paren
r_struct
id|ip_conntrack
op_star
)paren
id|nfct
comma
op_star
id|master
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|ip_conntrack_protocol
op_star
id|proto
suffix:semicolon
id|DEBUGP
c_func
(paren
l_string|&quot;destroy_conntrack(%p)&bslash;n&quot;
comma
id|ct
)paren
suffix:semicolon
id|IP_NF_ASSERT
c_func
(paren
id|atomic_read
c_func
(paren
op_amp
id|nfct-&gt;use
)paren
op_eq
l_int|0
)paren
suffix:semicolon
id|IP_NF_ASSERT
c_func
(paren
op_logical_neg
id|timer_pending
c_func
(paren
op_amp
id|ct-&gt;timeout
)paren
)paren
suffix:semicolon
multiline_comment|/* To make sure we don&squot;t get any weird locking issues here:&n;&t; * destroy_conntrack() MUST NOT be called with a write lock&n;&t; * to ip_conntrack_lock!!! -HW */
id|proto
op_assign
id|ip_ct_find_proto
c_func
(paren
id|ct-&gt;tuplehash
(braket
id|IP_CT_DIR_REPLY
)braket
dot
id|tuple.dst.protonum
)paren
suffix:semicolon
r_if
c_cond
(paren
id|proto
op_logical_and
id|proto-&gt;destroy
)paren
id|proto
op_member_access_from_pointer
id|destroy
c_func
(paren
id|ct
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ip_conntrack_destroyed
)paren
id|ip_conntrack_destroyed
c_func
(paren
id|ct
)paren
suffix:semicolon
id|WRITE_LOCK
c_func
(paren
op_amp
id|ip_conntrack_lock
)paren
suffix:semicolon
multiline_comment|/* Make sure don&squot;t leave any orphaned expectations lying around */
r_if
c_cond
(paren
id|ct-&gt;expecting
)paren
id|remove_expectations
c_func
(paren
id|ct
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Delete our master expectation */
r_if
c_cond
(paren
id|ct-&gt;master
)paren
(brace
r_if
c_cond
(paren
id|ct-&gt;master-&gt;expectant
)paren
(brace
multiline_comment|/* can&squot;t call __unexpect_related here,&n;&t;&t;&t; * since it would screw up expect_list */
id|list_del
c_func
(paren
op_amp
id|ct-&gt;master-&gt;expected_list
)paren
suffix:semicolon
id|master
op_assign
id|ct-&gt;master-&gt;expectant
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|ct-&gt;master
)paren
suffix:semicolon
)brace
id|WRITE_UNLOCK
c_func
(paren
op_amp
id|ip_conntrack_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|master
)paren
id|ip_conntrack_put
c_func
(paren
id|master
)paren
suffix:semicolon
id|DEBUGP
c_func
(paren
l_string|&quot;destroy_conntrack: returning ct=%p to slab&bslash;n&quot;
comma
id|ct
)paren
suffix:semicolon
id|kmem_cache_free
c_func
(paren
id|ip_conntrack_cachep
comma
id|ct
)paren
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|ip_conntrack_count
)paren
suffix:semicolon
)brace
DECL|function|death_by_timeout
r_static
r_void
id|death_by_timeout
c_func
(paren
r_int
r_int
id|ul_conntrack
)paren
(brace
r_struct
id|ip_conntrack
op_star
id|ct
op_assign
(paren
r_void
op_star
)paren
id|ul_conntrack
suffix:semicolon
id|WRITE_LOCK
c_func
(paren
op_amp
id|ip_conntrack_lock
)paren
suffix:semicolon
id|clean_from_lists
c_func
(paren
id|ct
)paren
suffix:semicolon
id|WRITE_UNLOCK
c_func
(paren
op_amp
id|ip_conntrack_lock
)paren
suffix:semicolon
id|ip_conntrack_put
c_func
(paren
id|ct
)paren
suffix:semicolon
)brace
r_static
r_inline
r_int
DECL|function|conntrack_tuple_cmp
id|conntrack_tuple_cmp
c_func
(paren
r_const
r_struct
id|ip_conntrack_tuple_hash
op_star
id|i
comma
r_const
r_struct
id|ip_conntrack_tuple
op_star
id|tuple
comma
r_const
r_struct
id|ip_conntrack
op_star
id|ignored_conntrack
)paren
(brace
id|MUST_BE_READ_LOCKED
c_func
(paren
op_amp
id|ip_conntrack_lock
)paren
suffix:semicolon
r_return
id|i-&gt;ctrack
op_ne
id|ignored_conntrack
op_logical_and
id|ip_ct_tuple_equal
c_func
(paren
id|tuple
comma
op_amp
id|i-&gt;tuple
)paren
suffix:semicolon
)brace
r_static
r_struct
id|ip_conntrack_tuple_hash
op_star
DECL|function|__ip_conntrack_find
id|__ip_conntrack_find
c_func
(paren
r_const
r_struct
id|ip_conntrack_tuple
op_star
id|tuple
comma
r_const
r_struct
id|ip_conntrack
op_star
id|ignored_conntrack
)paren
(brace
r_struct
id|ip_conntrack_tuple_hash
op_star
id|h
suffix:semicolon
r_int
r_int
id|hash
op_assign
id|hash_conntrack
c_func
(paren
id|tuple
)paren
suffix:semicolon
id|MUST_BE_READ_LOCKED
c_func
(paren
op_amp
id|ip_conntrack_lock
)paren
suffix:semicolon
id|h
op_assign
id|LIST_FIND
c_func
(paren
op_amp
id|ip_conntrack_hash
(braket
id|hash
)braket
comma
id|conntrack_tuple_cmp
comma
r_struct
id|ip_conntrack_tuple_hash
op_star
comma
id|tuple
comma
id|ignored_conntrack
)paren
suffix:semicolon
r_return
id|h
suffix:semicolon
)brace
multiline_comment|/* Find a connection corresponding to a tuple. */
r_struct
id|ip_conntrack_tuple_hash
op_star
DECL|function|ip_conntrack_find_get
id|ip_conntrack_find_get
c_func
(paren
r_const
r_struct
id|ip_conntrack_tuple
op_star
id|tuple
comma
r_const
r_struct
id|ip_conntrack
op_star
id|ignored_conntrack
)paren
(brace
r_struct
id|ip_conntrack_tuple_hash
op_star
id|h
suffix:semicolon
id|READ_LOCK
c_func
(paren
op_amp
id|ip_conntrack_lock
)paren
suffix:semicolon
id|h
op_assign
id|__ip_conntrack_find
c_func
(paren
id|tuple
comma
id|ignored_conntrack
)paren
suffix:semicolon
r_if
c_cond
(paren
id|h
)paren
id|atomic_inc
c_func
(paren
op_amp
id|h-&gt;ctrack-&gt;ct_general.use
)paren
suffix:semicolon
id|READ_UNLOCK
c_func
(paren
op_amp
id|ip_conntrack_lock
)paren
suffix:semicolon
r_return
id|h
suffix:semicolon
)brace
r_static
r_inline
r_struct
id|ip_conntrack
op_star
DECL|function|__ip_conntrack_get
id|__ip_conntrack_get
c_func
(paren
r_struct
id|nf_ct_info
op_star
id|nfct
comma
r_enum
id|ip_conntrack_info
op_star
id|ctinfo
)paren
(brace
r_struct
id|ip_conntrack
op_star
id|ct
op_assign
(paren
r_struct
id|ip_conntrack
op_star
)paren
id|nfct-&gt;master
suffix:semicolon
multiline_comment|/* ctinfo is the index of the nfct inside the conntrack */
op_star
id|ctinfo
op_assign
id|nfct
op_minus
id|ct-&gt;infos
suffix:semicolon
id|IP_NF_ASSERT
c_func
(paren
op_star
id|ctinfo
op_ge
l_int|0
op_logical_and
op_star
id|ctinfo
OL
id|IP_CT_NUMBER
)paren
suffix:semicolon
r_return
id|ct
suffix:semicolon
)brace
multiline_comment|/* Return conntrack and conntrack_info given skb-&gt;nfct-&gt;master */
r_struct
id|ip_conntrack
op_star
DECL|function|ip_conntrack_get
id|ip_conntrack_get
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_enum
id|ip_conntrack_info
op_star
id|ctinfo
)paren
(brace
r_if
c_cond
(paren
id|skb-&gt;nfct
)paren
r_return
id|__ip_conntrack_get
c_func
(paren
id|skb-&gt;nfct
comma
id|ctinfo
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Confirm a connection given skb-&gt;nfct; places it in hash table */
r_int
DECL|function|__ip_conntrack_confirm
id|__ip_conntrack_confirm
c_func
(paren
r_struct
id|nf_ct_info
op_star
id|nfct
)paren
(brace
r_int
r_int
id|hash
comma
id|repl_hash
suffix:semicolon
r_struct
id|ip_conntrack
op_star
id|ct
suffix:semicolon
r_enum
id|ip_conntrack_info
id|ctinfo
suffix:semicolon
id|ct
op_assign
id|__ip_conntrack_get
c_func
(paren
id|nfct
comma
op_amp
id|ctinfo
)paren
suffix:semicolon
multiline_comment|/* ipt_REJECT uses ip_conntrack_attach to attach related&n;&t;   ICMP/TCP RST packets in other direction.  Actual packet&n;&t;   which created connection will be IP_CT_NEW or for an&n;&t;   expected connection, IP_CT_RELATED. */
r_if
c_cond
(paren
id|CTINFO2DIR
c_func
(paren
id|ctinfo
)paren
op_ne
id|IP_CT_DIR_ORIGINAL
)paren
r_return
id|NF_ACCEPT
suffix:semicolon
id|hash
op_assign
id|hash_conntrack
c_func
(paren
op_amp
id|ct-&gt;tuplehash
(braket
id|IP_CT_DIR_ORIGINAL
)braket
dot
id|tuple
)paren
suffix:semicolon
id|repl_hash
op_assign
id|hash_conntrack
c_func
(paren
op_amp
id|ct-&gt;tuplehash
(braket
id|IP_CT_DIR_REPLY
)braket
dot
id|tuple
)paren
suffix:semicolon
multiline_comment|/* We&squot;re not in hash table, and we refuse to set up related&n;&t;   connections for unconfirmed conns.  But packet copies and&n;&t;   REJECT will give spurious warnings here. */
multiline_comment|/* IP_NF_ASSERT(atomic_read(&amp;ct-&gt;ct_general.use) == 1); */
multiline_comment|/* No external references means noone else could have&n;           confirmed us. */
id|IP_NF_ASSERT
c_func
(paren
op_logical_neg
id|is_confirmed
c_func
(paren
id|ct
)paren
)paren
suffix:semicolon
id|DEBUGP
c_func
(paren
l_string|&quot;Confirming conntrack %p&bslash;n&quot;
comma
id|ct
)paren
suffix:semicolon
id|WRITE_LOCK
c_func
(paren
op_amp
id|ip_conntrack_lock
)paren
suffix:semicolon
multiline_comment|/* See if there&squot;s one in the list already, including reverse:&n;           NAT could have grabbed it without realizing, since we&squot;re&n;           not in the hash.  If there is, we lost race. */
r_if
c_cond
(paren
op_logical_neg
id|LIST_FIND
c_func
(paren
op_amp
id|ip_conntrack_hash
(braket
id|hash
)braket
comma
id|conntrack_tuple_cmp
comma
r_struct
id|ip_conntrack_tuple_hash
op_star
comma
op_amp
id|ct-&gt;tuplehash
(braket
id|IP_CT_DIR_ORIGINAL
)braket
dot
id|tuple
comma
l_int|NULL
)paren
op_logical_and
op_logical_neg
id|LIST_FIND
c_func
(paren
op_amp
id|ip_conntrack_hash
(braket
id|repl_hash
)braket
comma
id|conntrack_tuple_cmp
comma
r_struct
id|ip_conntrack_tuple_hash
op_star
comma
op_amp
id|ct-&gt;tuplehash
(braket
id|IP_CT_DIR_REPLY
)braket
dot
id|tuple
comma
l_int|NULL
)paren
)paren
(brace
id|list_prepend
c_func
(paren
op_amp
id|ip_conntrack_hash
(braket
id|hash
)braket
comma
op_amp
id|ct-&gt;tuplehash
(braket
id|IP_CT_DIR_ORIGINAL
)braket
)paren
suffix:semicolon
id|list_prepend
c_func
(paren
op_amp
id|ip_conntrack_hash
(braket
id|repl_hash
)braket
comma
op_amp
id|ct-&gt;tuplehash
(braket
id|IP_CT_DIR_REPLY
)braket
)paren
suffix:semicolon
multiline_comment|/* Timer relative to confirmation time, not original&n;&t;&t;   setting time, otherwise we&squot;d get timer wrap in&n;&t;&t;   weird delay cases. */
id|ct-&gt;timeout.expires
op_add_assign
id|jiffies
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|ct-&gt;timeout
)paren
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|ct-&gt;ct_general.use
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|IPS_CONFIRMED_BIT
comma
op_amp
id|ct-&gt;status
)paren
suffix:semicolon
id|WRITE_UNLOCK
c_func
(paren
op_amp
id|ip_conntrack_lock
)paren
suffix:semicolon
r_return
id|NF_ACCEPT
suffix:semicolon
)brace
id|WRITE_UNLOCK
c_func
(paren
op_amp
id|ip_conntrack_lock
)paren
suffix:semicolon
r_return
id|NF_DROP
suffix:semicolon
)brace
multiline_comment|/* Returns true if a connection correspondings to the tuple (required&n;   for NAT). */
r_int
DECL|function|ip_conntrack_tuple_taken
id|ip_conntrack_tuple_taken
c_func
(paren
r_const
r_struct
id|ip_conntrack_tuple
op_star
id|tuple
comma
r_const
r_struct
id|ip_conntrack
op_star
id|ignored_conntrack
)paren
(brace
r_struct
id|ip_conntrack_tuple_hash
op_star
id|h
suffix:semicolon
id|READ_LOCK
c_func
(paren
op_amp
id|ip_conntrack_lock
)paren
suffix:semicolon
id|h
op_assign
id|__ip_conntrack_find
c_func
(paren
id|tuple
comma
id|ignored_conntrack
)paren
suffix:semicolon
id|READ_UNLOCK
c_func
(paren
op_amp
id|ip_conntrack_lock
)paren
suffix:semicolon
r_return
id|h
op_ne
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Returns conntrack if it dealt with ICMP, and filled in skb fields */
r_struct
id|ip_conntrack
op_star
DECL|function|icmp_error_track
id|icmp_error_track
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_enum
id|ip_conntrack_info
op_star
id|ctinfo
comma
r_int
r_int
id|hooknum
)paren
(brace
r_struct
id|ip_conntrack_tuple
id|innertuple
comma
id|origtuple
suffix:semicolon
r_struct
(brace
r_struct
id|icmphdr
id|icmp
suffix:semicolon
r_struct
id|iphdr
id|ip
suffix:semicolon
)brace
id|inside
suffix:semicolon
r_struct
id|ip_conntrack_protocol
op_star
id|innerproto
suffix:semicolon
r_struct
id|ip_conntrack_tuple_hash
op_star
id|h
suffix:semicolon
r_int
id|dataoff
suffix:semicolon
id|IP_NF_ASSERT
c_func
(paren
id|skb-&gt;nfct
op_eq
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* Not enough header? */
r_if
c_cond
(paren
id|skb_copy_bits
c_func
(paren
id|skb
comma
id|skb-&gt;nh.iph-&gt;ihl
op_star
l_int|4
comma
op_amp
id|inside
comma
r_sizeof
(paren
id|inside
)paren
)paren
op_ne
l_int|0
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|inside.icmp.type
op_ne
id|ICMP_DEST_UNREACH
op_logical_and
id|inside.icmp.type
op_ne
id|ICMP_SOURCE_QUENCH
op_logical_and
id|inside.icmp.type
op_ne
id|ICMP_TIME_EXCEEDED
op_logical_and
id|inside.icmp.type
op_ne
id|ICMP_PARAMETERPROB
op_logical_and
id|inside.icmp.type
op_ne
id|ICMP_REDIRECT
)paren
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/* Ignore ICMP&squot;s containing fragments (shouldn&squot;t happen) */
r_if
c_cond
(paren
id|inside.ip.frag_off
op_amp
id|htons
c_func
(paren
id|IP_OFFSET
)paren
)paren
(brace
id|DEBUGP
c_func
(paren
l_string|&quot;icmp_error_track: fragment of proto %u&bslash;n&quot;
comma
id|inside.ip.protocol
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|innerproto
op_assign
id|ip_ct_find_proto
c_func
(paren
id|inside.ip.protocol
)paren
suffix:semicolon
id|dataoff
op_assign
id|skb-&gt;nh.iph-&gt;ihl
op_star
l_int|4
op_plus
r_sizeof
(paren
id|inside.icmp
)paren
op_plus
id|inside.ip.ihl
op_star
l_int|4
suffix:semicolon
multiline_comment|/* Are they talking about one of our connections? */
r_if
c_cond
(paren
op_logical_neg
id|get_tuple
c_func
(paren
op_amp
id|inside.ip
comma
id|skb
comma
id|dataoff
comma
op_amp
id|origtuple
comma
id|innerproto
)paren
)paren
(brace
id|DEBUGP
c_func
(paren
l_string|&quot;icmp_error: ! get_tuple p=%u&quot;
comma
id|inside.ip.protocol
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Ordinarily, we&squot;d expect the inverted tupleproto, but it&squot;s&n;&t;   been preserved inside the ICMP. */
r_if
c_cond
(paren
op_logical_neg
id|invert_tuple
c_func
(paren
op_amp
id|innertuple
comma
op_amp
id|origtuple
comma
id|innerproto
)paren
)paren
(brace
id|DEBUGP
c_func
(paren
l_string|&quot;icmp_error_track: Can&squot;t invert tuple&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
op_star
id|ctinfo
op_assign
id|IP_CT_RELATED
suffix:semicolon
id|h
op_assign
id|ip_conntrack_find_get
c_func
(paren
op_amp
id|innertuple
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|h
)paren
(brace
multiline_comment|/* Locally generated ICMPs will match inverted if they&n;&t;&t;   haven&squot;t been SNAT&squot;ed yet */
multiline_comment|/* FIXME: NAT code has to handle half-done double NAT --RR */
r_if
c_cond
(paren
id|hooknum
op_eq
id|NF_IP_LOCAL_OUT
)paren
id|h
op_assign
id|ip_conntrack_find_get
c_func
(paren
op_amp
id|origtuple
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|h
)paren
(brace
id|DEBUGP
c_func
(paren
l_string|&quot;icmp_error_track: no match&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Reverse direction from that found */
r_if
c_cond
(paren
id|DIRECTION
c_func
(paren
id|h
)paren
op_ne
id|IP_CT_DIR_REPLY
)paren
op_star
id|ctinfo
op_add_assign
id|IP_CT_IS_REPLY
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|DIRECTION
c_func
(paren
id|h
)paren
op_eq
id|IP_CT_DIR_REPLY
)paren
op_star
id|ctinfo
op_add_assign
id|IP_CT_IS_REPLY
suffix:semicolon
)brace
multiline_comment|/* Update skb to refer to this connection */
id|skb-&gt;nfct
op_assign
op_amp
id|h-&gt;ctrack-&gt;infos
(braket
op_star
id|ctinfo
)braket
suffix:semicolon
r_return
id|h-&gt;ctrack
suffix:semicolon
)brace
multiline_comment|/* There&squot;s a small race here where we may free a just-assured&n;   connection.  Too bad: we&squot;re in trouble anyway. */
DECL|function|unreplied
r_static
r_inline
r_int
id|unreplied
c_func
(paren
r_const
r_struct
id|ip_conntrack_tuple_hash
op_star
id|i
)paren
(brace
r_return
op_logical_neg
(paren
id|test_bit
c_func
(paren
id|IPS_ASSURED_BIT
comma
op_amp
id|i-&gt;ctrack-&gt;status
)paren
)paren
suffix:semicolon
)brace
DECL|function|early_drop
r_static
r_int
id|early_drop
c_func
(paren
r_struct
id|list_head
op_star
id|chain
)paren
(brace
multiline_comment|/* Traverse backwards: gives us oldest, which is roughly LRU */
r_struct
id|ip_conntrack_tuple_hash
op_star
id|h
suffix:semicolon
r_int
id|dropped
op_assign
l_int|0
suffix:semicolon
id|READ_LOCK
c_func
(paren
op_amp
id|ip_conntrack_lock
)paren
suffix:semicolon
id|h
op_assign
id|LIST_FIND_B
c_func
(paren
id|chain
comma
id|unreplied
comma
r_struct
id|ip_conntrack_tuple_hash
op_star
)paren
suffix:semicolon
r_if
c_cond
(paren
id|h
)paren
id|atomic_inc
c_func
(paren
op_amp
id|h-&gt;ctrack-&gt;ct_general.use
)paren
suffix:semicolon
id|READ_UNLOCK
c_func
(paren
op_amp
id|ip_conntrack_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|h
)paren
r_return
id|dropped
suffix:semicolon
r_if
c_cond
(paren
id|del_timer
c_func
(paren
op_amp
id|h-&gt;ctrack-&gt;timeout
)paren
)paren
(brace
id|death_by_timeout
c_func
(paren
(paren
r_int
r_int
)paren
id|h-&gt;ctrack
)paren
suffix:semicolon
id|dropped
op_assign
l_int|1
suffix:semicolon
)brace
id|ip_conntrack_put
c_func
(paren
id|h-&gt;ctrack
)paren
suffix:semicolon
r_return
id|dropped
suffix:semicolon
)brace
DECL|function|helper_cmp
r_static
r_inline
r_int
id|helper_cmp
c_func
(paren
r_const
r_struct
id|ip_conntrack_helper
op_star
id|i
comma
r_const
r_struct
id|ip_conntrack_tuple
op_star
id|rtuple
)paren
(brace
r_return
id|ip_ct_tuple_mask_cmp
c_func
(paren
id|rtuple
comma
op_amp
id|i-&gt;tuple
comma
op_amp
id|i-&gt;mask
)paren
suffix:semicolon
)brace
DECL|function|ip_ct_find_helper
r_struct
id|ip_conntrack_helper
op_star
id|ip_ct_find_helper
c_func
(paren
r_const
r_struct
id|ip_conntrack_tuple
op_star
id|tuple
)paren
(brace
r_return
id|LIST_FIND
c_func
(paren
op_amp
id|helpers
comma
id|helper_cmp
comma
r_struct
id|ip_conntrack_helper
op_star
comma
id|tuple
)paren
suffix:semicolon
)brace
multiline_comment|/* Allocate a new conntrack: we return -ENOMEM if classification&n;   failed due to stress.  Otherwise it really is unclassifiable. */
r_static
r_struct
id|ip_conntrack_tuple_hash
op_star
DECL|function|init_conntrack
id|init_conntrack
c_func
(paren
r_const
r_struct
id|ip_conntrack_tuple
op_star
id|tuple
comma
r_struct
id|ip_conntrack_protocol
op_star
id|protocol
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|ip_conntrack
op_star
id|conntrack
suffix:semicolon
r_struct
id|ip_conntrack_tuple
id|repl_tuple
suffix:semicolon
r_int
id|hash
suffix:semicolon
r_struct
id|ip_conntrack_expect
op_star
id|expected
suffix:semicolon
r_int
id|i
suffix:semicolon
r_static
r_int
r_int
id|drop_next
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ip_conntrack_hash_rnd_initted
)paren
(brace
id|get_random_bytes
c_func
(paren
op_amp
id|ip_conntrack_hash_rnd
comma
l_int|4
)paren
suffix:semicolon
id|ip_conntrack_hash_rnd_initted
op_assign
l_int|1
suffix:semicolon
)brace
id|hash
op_assign
id|hash_conntrack
c_func
(paren
id|tuple
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ip_conntrack_max
op_logical_and
id|atomic_read
c_func
(paren
op_amp
id|ip_conntrack_count
)paren
op_ge
id|ip_conntrack_max
)paren
(brace
multiline_comment|/* Try dropping from random chain, or else from the&n;                   chain about to put into (in case they&squot;re trying to&n;                   bomb one hash chain). */
r_int
r_int
id|next
op_assign
(paren
id|drop_next
op_increment
)paren
op_mod
id|ip_conntrack_htable_size
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|early_drop
c_func
(paren
op_amp
id|ip_conntrack_hash
(braket
id|next
)braket
)paren
op_logical_and
op_logical_neg
id|early_drop
c_func
(paren
op_amp
id|ip_conntrack_hash
(braket
id|hash
)braket
)paren
)paren
(brace
r_if
c_cond
(paren
id|net_ratelimit
c_func
(paren
)paren
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;ip_conntrack: table full, dropping&quot;
l_string|&quot; packet.&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|invert_tuple
c_func
(paren
op_amp
id|repl_tuple
comma
id|tuple
comma
id|protocol
)paren
)paren
(brace
id|DEBUGP
c_func
(paren
l_string|&quot;Can&squot;t invert tuple.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|conntrack
op_assign
id|kmem_cache_alloc
c_func
(paren
id|ip_conntrack_cachep
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|conntrack
)paren
(brace
id|DEBUGP
c_func
(paren
l_string|&quot;Can&squot;t allocate conntrack.&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
)brace
id|memset
c_func
(paren
id|conntrack
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|conntrack
)paren
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|conntrack-&gt;ct_general.use
comma
l_int|1
)paren
suffix:semicolon
id|conntrack-&gt;ct_general.destroy
op_assign
id|destroy_conntrack
suffix:semicolon
id|conntrack-&gt;tuplehash
(braket
id|IP_CT_DIR_ORIGINAL
)braket
dot
id|tuple
op_assign
op_star
id|tuple
suffix:semicolon
id|conntrack-&gt;tuplehash
(braket
id|IP_CT_DIR_ORIGINAL
)braket
dot
id|ctrack
op_assign
id|conntrack
suffix:semicolon
id|conntrack-&gt;tuplehash
(braket
id|IP_CT_DIR_REPLY
)braket
dot
id|tuple
op_assign
id|repl_tuple
suffix:semicolon
id|conntrack-&gt;tuplehash
(braket
id|IP_CT_DIR_REPLY
)braket
dot
id|ctrack
op_assign
id|conntrack
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|IP_CT_NUMBER
suffix:semicolon
id|i
op_increment
)paren
id|conntrack-&gt;infos
(braket
id|i
)braket
dot
id|master
op_assign
op_amp
id|conntrack-&gt;ct_general
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|protocol
op_member_access_from_pointer
r_new
(paren
id|conntrack
comma
id|skb
)paren
)paren
(brace
id|kmem_cache_free
c_func
(paren
id|ip_conntrack_cachep
comma
id|conntrack
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Don&squot;t set timer yet: wait for confirmation */
id|init_timer
c_func
(paren
op_amp
id|conntrack-&gt;timeout
)paren
suffix:semicolon
id|conntrack-&gt;timeout.data
op_assign
(paren
r_int
r_int
)paren
id|conntrack
suffix:semicolon
id|conntrack-&gt;timeout.function
op_assign
id|death_by_timeout
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|conntrack-&gt;sibling_list
)paren
suffix:semicolon
id|WRITE_LOCK
c_func
(paren
op_amp
id|ip_conntrack_lock
)paren
suffix:semicolon
multiline_comment|/* Need finding and deleting of expected ONLY if we win race */
id|READ_LOCK
c_func
(paren
op_amp
id|ip_conntrack_expect_tuple_lock
)paren
suffix:semicolon
id|expected
op_assign
id|LIST_FIND
c_func
(paren
op_amp
id|ip_conntrack_expect_list
comma
id|expect_cmp
comma
r_struct
id|ip_conntrack_expect
op_star
comma
id|tuple
)paren
suffix:semicolon
id|READ_UNLOCK
c_func
(paren
op_amp
id|ip_conntrack_expect_tuple_lock
)paren
suffix:semicolon
multiline_comment|/* If master is not in hash table yet (ie. packet hasn&squot;t left&n;&t;   this machine yet), how can other end know about expected?&n;&t;   Hence these are not the droids you are looking for (if&n;&t;   master ct never got confirmed, we&squot;d hold a reference to it&n;&t;   and weird things would happen to future packets). */
r_if
c_cond
(paren
id|expected
op_logical_and
op_logical_neg
id|is_confirmed
c_func
(paren
id|expected-&gt;expectant
)paren
)paren
id|expected
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Look up the conntrack helper for master connections only */
r_if
c_cond
(paren
op_logical_neg
id|expected
)paren
id|conntrack-&gt;helper
op_assign
id|ip_ct_find_helper
c_func
(paren
op_amp
id|repl_tuple
)paren
suffix:semicolon
multiline_comment|/* If the expectation is dying, then this is a loser. */
r_if
c_cond
(paren
id|expected
op_logical_and
id|expected-&gt;expectant-&gt;helper-&gt;timeout
op_logical_and
op_logical_neg
id|del_timer
c_func
(paren
op_amp
id|expected-&gt;timeout
)paren
)paren
id|expected
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|expected
)paren
(brace
id|DEBUGP
c_func
(paren
l_string|&quot;conntrack: expectation arrives ct=%p exp=%p&bslash;n&quot;
comma
id|conntrack
comma
id|expected
)paren
suffix:semicolon
multiline_comment|/* Welcome, Mr. Bond.  We&squot;ve been expecting you... */
id|__set_bit
c_func
(paren
id|IPS_EXPECTED_BIT
comma
op_amp
id|conntrack-&gt;status
)paren
suffix:semicolon
id|conntrack-&gt;master
op_assign
id|expected
suffix:semicolon
id|expected-&gt;sibling
op_assign
id|conntrack
suffix:semicolon
id|LIST_DELETE
c_func
(paren
op_amp
id|ip_conntrack_expect_list
comma
id|expected
)paren
suffix:semicolon
id|expected-&gt;expectant-&gt;expecting
op_decrement
suffix:semicolon
id|nf_conntrack_get
c_func
(paren
op_amp
id|master_ct
c_func
(paren
id|conntrack
)paren
op_member_access_from_pointer
id|infos
(braket
l_int|0
)braket
)paren
suffix:semicolon
)brace
id|atomic_inc
c_func
(paren
op_amp
id|ip_conntrack_count
)paren
suffix:semicolon
id|WRITE_UNLOCK
c_func
(paren
op_amp
id|ip_conntrack_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|expected
op_logical_and
id|expected-&gt;expectfn
)paren
id|expected
op_member_access_from_pointer
id|expectfn
c_func
(paren
id|conntrack
)paren
suffix:semicolon
r_return
op_amp
id|conntrack-&gt;tuplehash
(braket
id|IP_CT_DIR_ORIGINAL
)braket
suffix:semicolon
)brace
multiline_comment|/* On success, returns conntrack ptr, sets skb-&gt;nfct and ctinfo */
r_static
r_inline
r_struct
id|ip_conntrack
op_star
DECL|function|resolve_normal_ct
id|resolve_normal_ct
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|ip_conntrack_protocol
op_star
id|proto
comma
r_int
op_star
id|set_reply
comma
r_int
r_int
id|hooknum
comma
r_enum
id|ip_conntrack_info
op_star
id|ctinfo
)paren
(brace
r_struct
id|ip_conntrack_tuple
id|tuple
suffix:semicolon
r_struct
id|ip_conntrack_tuple_hash
op_star
id|h
suffix:semicolon
id|IP_NF_ASSERT
c_func
(paren
(paren
id|skb-&gt;nh.iph-&gt;frag_off
op_amp
id|htons
c_func
(paren
id|IP_OFFSET
)paren
)paren
op_eq
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|get_tuple
c_func
(paren
id|skb-&gt;nh.iph
comma
id|skb
comma
id|skb-&gt;nh.iph-&gt;ihl
op_star
l_int|4
comma
op_amp
id|tuple
comma
id|proto
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/* look for tuple match */
id|h
op_assign
id|ip_conntrack_find_get
c_func
(paren
op_amp
id|tuple
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|h
)paren
(brace
id|h
op_assign
id|init_conntrack
c_func
(paren
op_amp
id|tuple
comma
id|proto
comma
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|h
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|h
)paren
)paren
r_return
(paren
r_void
op_star
)paren
id|h
suffix:semicolon
)brace
multiline_comment|/* It exists; we have (non-exclusive) reference. */
r_if
c_cond
(paren
id|DIRECTION
c_func
(paren
id|h
)paren
op_eq
id|IP_CT_DIR_REPLY
)paren
(brace
op_star
id|ctinfo
op_assign
id|IP_CT_ESTABLISHED
op_plus
id|IP_CT_IS_REPLY
suffix:semicolon
multiline_comment|/* Please set reply bit if this packet OK */
op_star
id|set_reply
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Once we&squot;ve had two way comms, always ESTABLISHED. */
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|IPS_SEEN_REPLY_BIT
comma
op_amp
id|h-&gt;ctrack-&gt;status
)paren
)paren
(brace
id|DEBUGP
c_func
(paren
l_string|&quot;ip_conntrack_in: normal packet for %p&bslash;n&quot;
comma
id|h-&gt;ctrack
)paren
suffix:semicolon
op_star
id|ctinfo
op_assign
id|IP_CT_ESTABLISHED
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|IPS_EXPECTED_BIT
comma
op_amp
id|h-&gt;ctrack-&gt;status
)paren
)paren
(brace
id|DEBUGP
c_func
(paren
l_string|&quot;ip_conntrack_in: related packet for %p&bslash;n&quot;
comma
id|h-&gt;ctrack
)paren
suffix:semicolon
op_star
id|ctinfo
op_assign
id|IP_CT_RELATED
suffix:semicolon
)brace
r_else
(brace
id|DEBUGP
c_func
(paren
l_string|&quot;ip_conntrack_in: new packet for %p&bslash;n&quot;
comma
id|h-&gt;ctrack
)paren
suffix:semicolon
op_star
id|ctinfo
op_assign
id|IP_CT_NEW
suffix:semicolon
)brace
op_star
id|set_reply
op_assign
l_int|0
suffix:semicolon
)brace
id|skb-&gt;nfct
op_assign
op_amp
id|h-&gt;ctrack-&gt;infos
(braket
op_star
id|ctinfo
)braket
suffix:semicolon
r_return
id|h-&gt;ctrack
suffix:semicolon
)brace
multiline_comment|/* Netfilter hook itself. */
DECL|function|ip_conntrack_in
r_int
r_int
id|ip_conntrack_in
c_func
(paren
r_int
r_int
id|hooknum
comma
r_struct
id|sk_buff
op_star
op_star
id|pskb
comma
r_const
r_struct
id|net_device
op_star
id|in
comma
r_const
r_struct
id|net_device
op_star
id|out
comma
r_int
(paren
op_star
id|okfn
)paren
(paren
r_struct
id|sk_buff
op_star
)paren
)paren
(brace
r_struct
id|ip_conntrack
op_star
id|ct
suffix:semicolon
r_enum
id|ip_conntrack_info
id|ctinfo
suffix:semicolon
r_struct
id|ip_conntrack_protocol
op_star
id|proto
suffix:semicolon
r_int
id|set_reply
suffix:semicolon
r_int
id|ret
suffix:semicolon
multiline_comment|/* Never happen */
r_if
c_cond
(paren
(paren
op_star
id|pskb
)paren
op_member_access_from_pointer
id|nh.iph-&gt;frag_off
op_amp
id|htons
c_func
(paren
id|IP_OFFSET
)paren
)paren
(brace
r_if
c_cond
(paren
id|net_ratelimit
c_func
(paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ip_conntrack_in: Frag of proto %u (hook=%u)&bslash;n&quot;
comma
(paren
op_star
id|pskb
)paren
op_member_access_from_pointer
id|nh.iph-&gt;protocol
comma
id|hooknum
)paren
suffix:semicolon
)brace
r_return
id|NF_DROP
suffix:semicolon
)brace
multiline_comment|/* FIXME: Do this right please. --RR */
(paren
op_star
id|pskb
)paren
op_member_access_from_pointer
id|nfcache
op_or_assign
id|NFC_UNKNOWN
suffix:semicolon
multiline_comment|/* Doesn&squot;t cover locally-generated broadcast, so not worth it. */
macro_line|#if 0
multiline_comment|/* Ignore broadcast: no `connection&squot;. */
r_if
c_cond
(paren
(paren
op_star
id|pskb
)paren
op_member_access_from_pointer
id|pkt_type
op_eq
id|PACKET_BROADCAST
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Broadcast packet!&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|NF_ACCEPT
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
(paren
op_star
id|pskb
)paren
op_member_access_from_pointer
id|nh.iph-&gt;daddr
op_amp
id|htonl
c_func
(paren
l_int|0x000000FF
)paren
)paren
op_eq
id|htonl
c_func
(paren
l_int|0x000000FF
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Should bcast: %u.%u.%u.%u-&gt;%u.%u.%u.%u (sk=%p, ptype=%u)&bslash;n&quot;
comma
id|NIPQUAD
c_func
(paren
(paren
op_star
id|pskb
)paren
op_member_access_from_pointer
id|nh.iph-&gt;saddr
)paren
comma
id|NIPQUAD
c_func
(paren
(paren
op_star
id|pskb
)paren
op_member_access_from_pointer
id|nh.iph-&gt;daddr
)paren
comma
(paren
op_star
id|pskb
)paren
op_member_access_from_pointer
id|sk
comma
(paren
op_star
id|pskb
)paren
op_member_access_from_pointer
id|pkt_type
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* Previously seen (loopback or untracked)?  Ignore. */
r_if
c_cond
(paren
(paren
op_star
id|pskb
)paren
op_member_access_from_pointer
id|nfct
)paren
r_return
id|NF_ACCEPT
suffix:semicolon
id|proto
op_assign
id|ip_ct_find_proto
c_func
(paren
(paren
op_star
id|pskb
)paren
op_member_access_from_pointer
id|nh.iph-&gt;protocol
)paren
suffix:semicolon
multiline_comment|/* It may be an icmp error... */
r_if
c_cond
(paren
(paren
op_star
id|pskb
)paren
op_member_access_from_pointer
id|nh.iph-&gt;protocol
op_eq
id|IPPROTO_ICMP
op_logical_and
id|icmp_error_track
c_func
(paren
op_star
id|pskb
comma
op_amp
id|ctinfo
comma
id|hooknum
)paren
)paren
r_return
id|NF_ACCEPT
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|ct
op_assign
id|resolve_normal_ct
c_func
(paren
op_star
id|pskb
comma
id|proto
comma
op_amp
id|set_reply
comma
id|hooknum
comma
op_amp
id|ctinfo
)paren
)paren
)paren
multiline_comment|/* Not valid part of a connection */
r_return
id|NF_ACCEPT
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|ct
)paren
)paren
multiline_comment|/* Too stressed to deal. */
r_return
id|NF_DROP
suffix:semicolon
id|IP_NF_ASSERT
c_func
(paren
(paren
op_star
id|pskb
)paren
op_member_access_from_pointer
id|nfct
)paren
suffix:semicolon
id|ret
op_assign
id|proto
op_member_access_from_pointer
id|packet
c_func
(paren
id|ct
comma
op_star
id|pskb
comma
id|ctinfo
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
op_minus
l_int|1
)paren
(brace
multiline_comment|/* Invalid */
id|nf_conntrack_put
c_func
(paren
(paren
op_star
id|pskb
)paren
op_member_access_from_pointer
id|nfct
)paren
suffix:semicolon
(paren
op_star
id|pskb
)paren
op_member_access_from_pointer
id|nfct
op_assign
l_int|NULL
suffix:semicolon
r_return
id|NF_ACCEPT
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ret
op_ne
id|NF_DROP
op_logical_and
id|ct-&gt;helper
)paren
(brace
id|ret
op_assign
id|ct-&gt;helper
op_member_access_from_pointer
id|help
c_func
(paren
op_star
id|pskb
comma
id|ct
comma
id|ctinfo
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
op_minus
l_int|1
)paren
(brace
multiline_comment|/* Invalid */
id|nf_conntrack_put
c_func
(paren
(paren
op_star
id|pskb
)paren
op_member_access_from_pointer
id|nfct
)paren
suffix:semicolon
(paren
op_star
id|pskb
)paren
op_member_access_from_pointer
id|nfct
op_assign
l_int|NULL
suffix:semicolon
r_return
id|NF_ACCEPT
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|set_reply
)paren
id|set_bit
c_func
(paren
id|IPS_SEEN_REPLY_BIT
comma
op_amp
id|ct-&gt;status
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|invert_tuplepr
r_int
id|invert_tuplepr
c_func
(paren
r_struct
id|ip_conntrack_tuple
op_star
id|inverse
comma
r_const
r_struct
id|ip_conntrack_tuple
op_star
id|orig
)paren
(brace
r_return
id|invert_tuple
c_func
(paren
id|inverse
comma
id|orig
comma
id|ip_ct_find_proto
c_func
(paren
id|orig-&gt;dst.protonum
)paren
)paren
suffix:semicolon
)brace
DECL|function|resent_expect
r_static
r_inline
r_int
id|resent_expect
c_func
(paren
r_const
r_struct
id|ip_conntrack_expect
op_star
id|i
comma
r_const
r_struct
id|ip_conntrack_tuple
op_star
id|tuple
comma
r_const
r_struct
id|ip_conntrack_tuple
op_star
id|mask
)paren
(brace
id|DEBUGP
c_func
(paren
l_string|&quot;resent_expect&bslash;n&quot;
)paren
suffix:semicolon
id|DEBUGP
c_func
(paren
l_string|&quot;   tuple:   &quot;
)paren
suffix:semicolon
id|DUMP_TUPLE
c_func
(paren
op_amp
id|i-&gt;tuple
)paren
suffix:semicolon
id|DEBUGP
c_func
(paren
l_string|&quot;ct_tuple:   &quot;
)paren
suffix:semicolon
id|DUMP_TUPLE
c_func
(paren
op_amp
id|i-&gt;ct_tuple
)paren
suffix:semicolon
id|DEBUGP
c_func
(paren
l_string|&quot;test tuple: &quot;
)paren
suffix:semicolon
id|DUMP_TUPLE
c_func
(paren
id|tuple
)paren
suffix:semicolon
r_return
(paren
(paren
(paren
id|i-&gt;ct_tuple.dst.protonum
op_eq
l_int|0
op_logical_and
id|ip_ct_tuple_equal
c_func
(paren
op_amp
id|i-&gt;tuple
comma
id|tuple
)paren
)paren
op_logical_or
(paren
id|i-&gt;ct_tuple.dst.protonum
op_logical_and
id|ip_ct_tuple_equal
c_func
(paren
op_amp
id|i-&gt;ct_tuple
comma
id|tuple
)paren
)paren
)paren
op_logical_and
id|ip_ct_tuple_equal
c_func
(paren
op_amp
id|i-&gt;mask
comma
id|mask
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Would two expected things clash? */
DECL|function|expect_clash
r_static
r_inline
r_int
id|expect_clash
c_func
(paren
r_const
r_struct
id|ip_conntrack_expect
op_star
id|i
comma
r_const
r_struct
id|ip_conntrack_tuple
op_star
id|tuple
comma
r_const
r_struct
id|ip_conntrack_tuple
op_star
id|mask
)paren
(brace
multiline_comment|/* Part covered by intersection of masks must be unequal,&n;           otherwise they clash */
r_struct
id|ip_conntrack_tuple
id|intersect_mask
op_assign
(brace
(brace
id|i-&gt;mask.src.ip
op_amp
id|mask-&gt;src.ip
comma
(brace
id|i-&gt;mask.src.u.all
op_amp
id|mask-&gt;src.u.all
)brace
)brace
comma
(brace
id|i-&gt;mask.dst.ip
op_amp
id|mask-&gt;dst.ip
comma
(brace
id|i-&gt;mask.dst.u.all
op_amp
id|mask-&gt;dst.u.all
)brace
comma
id|i-&gt;mask.dst.protonum
op_amp
id|mask-&gt;dst.protonum
)brace
)brace
suffix:semicolon
r_return
id|ip_ct_tuple_mask_cmp
c_func
(paren
op_amp
id|i-&gt;tuple
comma
id|tuple
comma
op_amp
id|intersect_mask
)paren
suffix:semicolon
)brace
DECL|function|ip_conntrack_unexpect_related
r_inline
r_void
id|ip_conntrack_unexpect_related
c_func
(paren
r_struct
id|ip_conntrack_expect
op_star
id|expect
)paren
(brace
id|WRITE_LOCK
c_func
(paren
op_amp
id|ip_conntrack_lock
)paren
suffix:semicolon
id|unexpect_related
c_func
(paren
id|expect
)paren
suffix:semicolon
id|WRITE_UNLOCK
c_func
(paren
op_amp
id|ip_conntrack_lock
)paren
suffix:semicolon
)brace
DECL|function|expectation_timed_out
r_static
r_void
id|expectation_timed_out
c_func
(paren
r_int
r_int
id|ul_expect
)paren
(brace
r_struct
id|ip_conntrack_expect
op_star
id|expect
op_assign
(paren
r_void
op_star
)paren
id|ul_expect
suffix:semicolon
id|DEBUGP
c_func
(paren
l_string|&quot;expectation %p timed out&bslash;n&quot;
comma
id|expect
)paren
suffix:semicolon
id|WRITE_LOCK
c_func
(paren
op_amp
id|ip_conntrack_lock
)paren
suffix:semicolon
id|__unexpect_related
c_func
(paren
id|expect
)paren
suffix:semicolon
id|WRITE_UNLOCK
c_func
(paren
op_amp
id|ip_conntrack_lock
)paren
suffix:semicolon
)brace
r_struct
id|ip_conntrack_expect
op_star
DECL|function|ip_conntrack_expect_alloc
id|ip_conntrack_expect_alloc
c_func
(paren
r_void
)paren
(brace
r_struct
id|ip_conntrack_expect
op_star
r_new
suffix:semicolon
r_new
op_assign
(paren
r_struct
id|ip_conntrack_expect
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|ip_conntrack_expect
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
r_new
)paren
(brace
id|DEBUGP
c_func
(paren
l_string|&quot;expect_related: OOM allocating expect&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* tuple_cmp compares whole union, we have to initialized cleanly */
id|memset
c_func
(paren
r_new
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|ip_conntrack_expect
)paren
)paren
suffix:semicolon
r_return
r_new
suffix:semicolon
)brace
r_static
r_void
DECL|function|ip_conntrack_expect_insert
id|ip_conntrack_expect_insert
c_func
(paren
r_struct
id|ip_conntrack_expect
op_star
r_new
comma
r_struct
id|ip_conntrack
op_star
id|related_to
)paren
(brace
id|DEBUGP
c_func
(paren
l_string|&quot;new expectation %p of conntrack %p&bslash;n&quot;
comma
r_new
comma
id|related_to
)paren
suffix:semicolon
r_new
op_member_access_from_pointer
id|expectant
op_assign
id|related_to
suffix:semicolon
r_new
op_member_access_from_pointer
id|sibling
op_assign
l_int|NULL
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
r_new
op_member_access_from_pointer
id|use
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* add to expected list for this connection */
id|list_add_tail
c_func
(paren
op_amp
r_new
op_member_access_from_pointer
id|expected_list
comma
op_amp
id|related_to-&gt;sibling_list
)paren
suffix:semicolon
multiline_comment|/* add to global list of expectations */
id|list_prepend
c_func
(paren
op_amp
id|ip_conntrack_expect_list
comma
op_amp
r_new
op_member_access_from_pointer
id|list
)paren
suffix:semicolon
multiline_comment|/* add and start timer if required */
r_if
c_cond
(paren
id|related_to-&gt;helper-&gt;timeout
)paren
(brace
id|init_timer
c_func
(paren
op_amp
r_new
op_member_access_from_pointer
id|timeout
)paren
suffix:semicolon
r_new
op_member_access_from_pointer
id|timeout.data
op_assign
(paren
r_int
r_int
)paren
r_new
suffix:semicolon
r_new
op_member_access_from_pointer
id|timeout.function
op_assign
id|expectation_timed_out
suffix:semicolon
r_new
op_member_access_from_pointer
id|timeout.expires
op_assign
id|jiffies
op_plus
id|related_to-&gt;helper-&gt;timeout
op_star
id|HZ
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
r_new
op_member_access_from_pointer
id|timeout
)paren
suffix:semicolon
)brace
id|related_to-&gt;expecting
op_increment
suffix:semicolon
)brace
multiline_comment|/* Add a related connection. */
DECL|function|ip_conntrack_expect_related
r_int
id|ip_conntrack_expect_related
c_func
(paren
r_struct
id|ip_conntrack_expect
op_star
id|expect
comma
r_struct
id|ip_conntrack
op_star
id|related_to
)paren
(brace
r_struct
id|ip_conntrack_expect
op_star
id|old
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|WRITE_LOCK
c_func
(paren
op_amp
id|ip_conntrack_lock
)paren
suffix:semicolon
multiline_comment|/* Because of the write lock, no reader can walk the lists,&n;&t; * so there is no need to use the tuple lock too */
id|DEBUGP
c_func
(paren
l_string|&quot;ip_conntrack_expect_related %p&bslash;n&quot;
comma
id|related_to
)paren
suffix:semicolon
id|DEBUGP
c_func
(paren
l_string|&quot;tuple: &quot;
)paren
suffix:semicolon
id|DUMP_TUPLE
c_func
(paren
op_amp
id|expect-&gt;tuple
)paren
suffix:semicolon
id|DEBUGP
c_func
(paren
l_string|&quot;mask:  &quot;
)paren
suffix:semicolon
id|DUMP_TUPLE
c_func
(paren
op_amp
id|expect-&gt;mask
)paren
suffix:semicolon
id|old
op_assign
id|LIST_FIND
c_func
(paren
op_amp
id|ip_conntrack_expect_list
comma
id|resent_expect
comma
r_struct
id|ip_conntrack_expect
op_star
comma
op_amp
id|expect-&gt;tuple
comma
op_amp
id|expect-&gt;mask
)paren
suffix:semicolon
r_if
c_cond
(paren
id|old
)paren
(brace
multiline_comment|/* Helper private data may contain offsets but no pointers&n;&t;&t;   pointing into the payload - otherwise we should have to copy &n;&t;&t;   the data filled out by the helper over the old one */
id|DEBUGP
c_func
(paren
l_string|&quot;expect_related: resent packet&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|related_to-&gt;helper-&gt;timeout
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|del_timer
c_func
(paren
op_amp
id|old-&gt;timeout
)paren
)paren
(brace
multiline_comment|/* expectation is dying. Fall through */
r_goto
id|out
suffix:semicolon
)brace
r_else
(brace
id|old-&gt;timeout.expires
op_assign
id|jiffies
op_plus
id|related_to-&gt;helper-&gt;timeout
op_star
id|HZ
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|old-&gt;timeout
)paren
suffix:semicolon
)brace
)brace
id|WRITE_UNLOCK
c_func
(paren
op_amp
id|ip_conntrack_lock
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|expect
)paren
suffix:semicolon
r_return
op_minus
id|EEXIST
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|related_to-&gt;helper-&gt;max_expected
op_logical_and
id|related_to-&gt;expecting
op_ge
id|related_to-&gt;helper-&gt;max_expected
)paren
(brace
multiline_comment|/* old == NULL */
r_if
c_cond
(paren
op_logical_neg
(paren
id|related_to-&gt;helper-&gt;flags
op_amp
id|IP_CT_HELPER_F_REUSE_EXPECT
)paren
)paren
(brace
id|WRITE_UNLOCK
c_func
(paren
op_amp
id|ip_conntrack_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|net_ratelimit
c_func
(paren
)paren
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;ip_conntrack: max number of expected &quot;
l_string|&quot;connections %i of %s reached for &quot;
l_string|&quot;%u.%u.%u.%u-&gt;%u.%u.%u.%u&bslash;n&quot;
comma
id|related_to-&gt;helper-&gt;max_expected
comma
id|related_to-&gt;helper-&gt;name
comma
id|NIPQUAD
c_func
(paren
id|related_to-&gt;tuplehash
(braket
id|IP_CT_DIR_ORIGINAL
)braket
dot
id|tuple.src.ip
)paren
comma
id|NIPQUAD
c_func
(paren
id|related_to-&gt;tuplehash
(braket
id|IP_CT_DIR_ORIGINAL
)braket
dot
id|tuple.dst.ip
)paren
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|expect
)paren
suffix:semicolon
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
id|DEBUGP
c_func
(paren
l_string|&quot;ip_conntrack: max number of expected &quot;
l_string|&quot;connections %i of %s reached for &quot;
l_string|&quot;%u.%u.%u.%u-&gt;%u.%u.%u.%u, reusing&bslash;n&quot;
comma
id|related_to-&gt;helper-&gt;max_expected
comma
id|related_to-&gt;helper-&gt;name
comma
id|NIPQUAD
c_func
(paren
id|related_to-&gt;tuplehash
(braket
id|IP_CT_DIR_ORIGINAL
)braket
dot
id|tuple.src.ip
)paren
comma
id|NIPQUAD
c_func
(paren
id|related_to-&gt;tuplehash
(braket
id|IP_CT_DIR_ORIGINAL
)braket
dot
id|tuple.dst.ip
)paren
)paren
suffix:semicolon
multiline_comment|/* choose the the oldest expectation to evict */
id|list_for_each_entry
c_func
(paren
id|old
comma
op_amp
id|related_to-&gt;sibling_list
comma
id|expected_list
)paren
r_if
c_cond
(paren
id|old-&gt;sibling
op_eq
l_int|NULL
)paren
r_break
suffix:semicolon
multiline_comment|/* We cannot fail since related_to-&gt;expecting is the number&n;&t;&t; * of unconfirmed expectations */
id|IP_NF_ASSERT
c_func
(paren
id|old
op_logical_and
id|old-&gt;sibling
op_eq
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* newnat14 does not reuse the real allocated memory&n;&t;&t; * structures but rather unexpects the old and&n;&t;&t; * allocates a new.  unexpect_related will decrement&n;&t;&t; * related_to-&gt;expecting. &n;&t;&t; */
id|unexpect_related
c_func
(paren
id|old
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EPERM
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|LIST_FIND
c_func
(paren
op_amp
id|ip_conntrack_expect_list
comma
id|expect_clash
comma
r_struct
id|ip_conntrack_expect
op_star
comma
op_amp
id|expect-&gt;tuple
comma
op_amp
id|expect-&gt;mask
)paren
)paren
(brace
id|WRITE_UNLOCK
c_func
(paren
op_amp
id|ip_conntrack_lock
)paren
suffix:semicolon
id|DEBUGP
c_func
(paren
l_string|&quot;expect_related: busy!&bslash;n&quot;
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|expect
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|out
suffix:colon
id|ip_conntrack_expect_insert
c_func
(paren
id|expect
comma
id|related_to
)paren
suffix:semicolon
id|WRITE_UNLOCK
c_func
(paren
op_amp
id|ip_conntrack_lock
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* Change tuple in an existing expectation */
DECL|function|ip_conntrack_change_expect
r_int
id|ip_conntrack_change_expect
c_func
(paren
r_struct
id|ip_conntrack_expect
op_star
id|expect
comma
r_struct
id|ip_conntrack_tuple
op_star
id|newtuple
)paren
(brace
r_int
id|ret
suffix:semicolon
id|MUST_BE_READ_LOCKED
c_func
(paren
op_amp
id|ip_conntrack_lock
)paren
suffix:semicolon
id|WRITE_LOCK
c_func
(paren
op_amp
id|ip_conntrack_expect_tuple_lock
)paren
suffix:semicolon
id|DEBUGP
c_func
(paren
l_string|&quot;change_expect:&bslash;n&quot;
)paren
suffix:semicolon
id|DEBUGP
c_func
(paren
l_string|&quot;exp tuple: &quot;
)paren
suffix:semicolon
id|DUMP_TUPLE
c_func
(paren
op_amp
id|expect-&gt;tuple
)paren
suffix:semicolon
id|DEBUGP
c_func
(paren
l_string|&quot;exp mask:  &quot;
)paren
suffix:semicolon
id|DUMP_TUPLE
c_func
(paren
op_amp
id|expect-&gt;mask
)paren
suffix:semicolon
id|DEBUGP
c_func
(paren
l_string|&quot;newtuple:  &quot;
)paren
suffix:semicolon
id|DUMP_TUPLE
c_func
(paren
id|newtuple
)paren
suffix:semicolon
r_if
c_cond
(paren
id|expect-&gt;ct_tuple.dst.protonum
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Never seen before */
id|DEBUGP
c_func
(paren
l_string|&quot;change expect: never seen before&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ip_ct_tuple_equal
c_func
(paren
op_amp
id|expect-&gt;tuple
comma
id|newtuple
)paren
op_logical_and
id|LIST_FIND
c_func
(paren
op_amp
id|ip_conntrack_expect_list
comma
id|expect_clash
comma
r_struct
id|ip_conntrack_expect
op_star
comma
id|newtuple
comma
op_amp
id|expect-&gt;mask
)paren
)paren
(brace
multiline_comment|/* Force NAT to find an unused tuple */
id|ret
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|memcpy
c_func
(paren
op_amp
id|expect-&gt;ct_tuple
comma
op_amp
id|expect-&gt;tuple
comma
r_sizeof
(paren
id|expect-&gt;tuple
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|expect-&gt;tuple
comma
id|newtuple
comma
r_sizeof
(paren
id|expect-&gt;tuple
)paren
)paren
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* Resent packet */
id|DEBUGP
c_func
(paren
l_string|&quot;change expect: resent packet&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ip_ct_tuple_equal
c_func
(paren
op_amp
id|expect-&gt;tuple
comma
id|newtuple
)paren
)paren
(brace
id|ret
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Force NAT to choose again the same port */
id|ret
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
)brace
id|WRITE_UNLOCK
c_func
(paren
op_amp
id|ip_conntrack_expect_tuple_lock
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* Alter reply tuple (maybe alter helper).  If it&squot;s already taken,&n;   return 0 and don&squot;t do alteration. */
DECL|function|ip_conntrack_alter_reply
r_int
id|ip_conntrack_alter_reply
c_func
(paren
r_struct
id|ip_conntrack
op_star
id|conntrack
comma
r_const
r_struct
id|ip_conntrack_tuple
op_star
id|newreply
)paren
(brace
id|WRITE_LOCK
c_func
(paren
op_amp
id|ip_conntrack_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|__ip_conntrack_find
c_func
(paren
id|newreply
comma
id|conntrack
)paren
)paren
(brace
id|WRITE_UNLOCK
c_func
(paren
op_amp
id|ip_conntrack_lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Should be unconfirmed, so not in hash table yet */
id|IP_NF_ASSERT
c_func
(paren
op_logical_neg
id|is_confirmed
c_func
(paren
id|conntrack
)paren
)paren
suffix:semicolon
id|DEBUGP
c_func
(paren
l_string|&quot;Altering reply tuple of %p to &quot;
comma
id|conntrack
)paren
suffix:semicolon
id|DUMP_TUPLE
c_func
(paren
id|newreply
)paren
suffix:semicolon
id|conntrack-&gt;tuplehash
(braket
id|IP_CT_DIR_REPLY
)braket
dot
id|tuple
op_assign
op_star
id|newreply
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|conntrack-&gt;master
op_logical_and
id|list_empty
c_func
(paren
op_amp
id|conntrack-&gt;sibling_list
)paren
)paren
id|conntrack-&gt;helper
op_assign
id|ip_ct_find_helper
c_func
(paren
id|newreply
)paren
suffix:semicolon
id|WRITE_UNLOCK
c_func
(paren
op_amp
id|ip_conntrack_lock
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|ip_conntrack_helper_register
r_int
id|ip_conntrack_helper_register
c_func
(paren
r_struct
id|ip_conntrack_helper
op_star
id|me
)paren
(brace
id|WRITE_LOCK
c_func
(paren
op_amp
id|ip_conntrack_lock
)paren
suffix:semicolon
id|list_prepend
c_func
(paren
op_amp
id|helpers
comma
id|me
)paren
suffix:semicolon
id|WRITE_UNLOCK
c_func
(paren
op_amp
id|ip_conntrack_lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|unhelp
r_static
r_inline
r_int
id|unhelp
c_func
(paren
r_struct
id|ip_conntrack_tuple_hash
op_star
id|i
comma
r_const
r_struct
id|ip_conntrack_helper
op_star
id|me
)paren
(brace
r_if
c_cond
(paren
id|i-&gt;ctrack-&gt;helper
op_eq
id|me
)paren
(brace
multiline_comment|/* Get rid of any expected. */
id|remove_expectations
c_func
(paren
id|i-&gt;ctrack
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* And *then* set helper to NULL */
id|i-&gt;ctrack-&gt;helper
op_assign
l_int|NULL
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ip_conntrack_helper_unregister
r_void
id|ip_conntrack_helper_unregister
c_func
(paren
r_struct
id|ip_conntrack_helper
op_star
id|me
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
multiline_comment|/* Need write lock here, to delete helper. */
id|WRITE_LOCK
c_func
(paren
op_amp
id|ip_conntrack_lock
)paren
suffix:semicolon
id|LIST_DELETE
c_func
(paren
op_amp
id|helpers
comma
id|me
)paren
suffix:semicolon
multiline_comment|/* Get rid of expecteds, set helpers to NULL. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ip_conntrack_htable_size
suffix:semicolon
id|i
op_increment
)paren
id|LIST_FIND_W
c_func
(paren
op_amp
id|ip_conntrack_hash
(braket
id|i
)braket
comma
id|unhelp
comma
r_struct
id|ip_conntrack_tuple_hash
op_star
comma
id|me
)paren
suffix:semicolon
id|WRITE_UNLOCK
c_func
(paren
op_amp
id|ip_conntrack_lock
)paren
suffix:semicolon
multiline_comment|/* Someone could be still looking at the helper in a bh. */
id|synchronize_net
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Refresh conntrack for this many jiffies. */
DECL|function|ip_ct_refresh
r_void
id|ip_ct_refresh
c_func
(paren
r_struct
id|ip_conntrack
op_star
id|ct
comma
r_int
r_int
id|extra_jiffies
)paren
(brace
id|IP_NF_ASSERT
c_func
(paren
id|ct-&gt;timeout.data
op_eq
(paren
r_int
r_int
)paren
id|ct
)paren
suffix:semicolon
multiline_comment|/* If not in hash table, timer will not be active yet */
r_if
c_cond
(paren
op_logical_neg
id|is_confirmed
c_func
(paren
id|ct
)paren
)paren
id|ct-&gt;timeout.expires
op_assign
id|extra_jiffies
suffix:semicolon
r_else
(brace
id|WRITE_LOCK
c_func
(paren
op_amp
id|ip_conntrack_lock
)paren
suffix:semicolon
multiline_comment|/* Need del_timer for race avoidance (may already be dying). */
r_if
c_cond
(paren
id|del_timer
c_func
(paren
op_amp
id|ct-&gt;timeout
)paren
)paren
(brace
id|ct-&gt;timeout.expires
op_assign
id|jiffies
op_plus
id|extra_jiffies
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|ct-&gt;timeout
)paren
suffix:semicolon
)brace
id|WRITE_UNLOCK
c_func
(paren
op_amp
id|ip_conntrack_lock
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Returns new sk_buff, or NULL */
r_struct
id|sk_buff
op_star
DECL|function|ip_ct_gather_frags
id|ip_ct_gather_frags
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|sock
op_star
id|sk
op_assign
id|skb-&gt;sk
suffix:semicolon
macro_line|#ifdef CONFIG_NETFILTER_DEBUG
r_int
r_int
id|olddebug
op_assign
id|skb-&gt;nf_debug
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|sk
)paren
(brace
id|sock_hold
c_func
(paren
id|sk
)paren
suffix:semicolon
id|skb_orphan
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
id|local_bh_disable
c_func
(paren
)paren
suffix:semicolon
id|skb
op_assign
id|ip_defrag
c_func
(paren
id|skb
)paren
suffix:semicolon
id|local_bh_enable
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skb
)paren
(brace
r_if
c_cond
(paren
id|sk
)paren
id|sock_put
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
id|skb
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sk
)paren
(brace
id|skb_set_owner_w
c_func
(paren
id|skb
comma
id|sk
)paren
suffix:semicolon
id|sock_put
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
id|ip_send_check
c_func
(paren
id|skb-&gt;nh.iph
)paren
suffix:semicolon
id|skb-&gt;nfcache
op_or_assign
id|NFC_ALTERED
suffix:semicolon
macro_line|#ifdef CONFIG_NETFILTER_DEBUG
multiline_comment|/* Packet path as if nothing had happened. */
id|skb-&gt;nf_debug
op_assign
id|olddebug
suffix:semicolon
macro_line|#endif
r_return
id|skb
suffix:semicolon
)brace
multiline_comment|/* Used by ipt_REJECT. */
DECL|function|ip_conntrack_attach
r_static
r_void
id|ip_conntrack_attach
c_func
(paren
r_struct
id|sk_buff
op_star
id|nskb
comma
r_struct
id|nf_ct_info
op_star
id|nfct
)paren
(brace
r_struct
id|ip_conntrack
op_star
id|ct
suffix:semicolon
r_enum
id|ip_conntrack_info
id|ctinfo
suffix:semicolon
id|ct
op_assign
id|__ip_conntrack_get
c_func
(paren
id|nfct
comma
op_amp
id|ctinfo
)paren
suffix:semicolon
multiline_comment|/* This ICMP is in reverse direction to the packet which&n;           caused it */
r_if
c_cond
(paren
id|CTINFO2DIR
c_func
(paren
id|ctinfo
)paren
op_eq
id|IP_CT_DIR_ORIGINAL
)paren
id|ctinfo
op_assign
id|IP_CT_RELATED
op_plus
id|IP_CT_IS_REPLY
suffix:semicolon
r_else
id|ctinfo
op_assign
id|IP_CT_RELATED
suffix:semicolon
multiline_comment|/* Attach new skbuff, and increment count */
id|nskb-&gt;nfct
op_assign
op_amp
id|ct-&gt;infos
(braket
id|ctinfo
)braket
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|ct-&gt;ct_general.use
)paren
suffix:semicolon
)brace
r_static
r_inline
r_int
DECL|function|do_kill
id|do_kill
c_func
(paren
r_const
r_struct
id|ip_conntrack_tuple_hash
op_star
id|i
comma
r_int
(paren
op_star
id|kill
)paren
(paren
r_const
r_struct
id|ip_conntrack
op_star
id|i
comma
r_void
op_star
id|data
)paren
comma
r_void
op_star
id|data
)paren
(brace
r_return
id|kill
c_func
(paren
id|i-&gt;ctrack
comma
id|data
)paren
suffix:semicolon
)brace
multiline_comment|/* Bring out ya dead! */
r_static
r_struct
id|ip_conntrack_tuple_hash
op_star
DECL|function|get_next_corpse
id|get_next_corpse
c_func
(paren
r_int
(paren
op_star
id|kill
)paren
(paren
r_const
r_struct
id|ip_conntrack
op_star
id|i
comma
r_void
op_star
id|data
)paren
comma
r_void
op_star
id|data
comma
r_int
r_int
op_star
id|bucket
)paren
(brace
r_struct
id|ip_conntrack_tuple_hash
op_star
id|h
op_assign
l_int|NULL
suffix:semicolon
id|READ_LOCK
c_func
(paren
op_amp
id|ip_conntrack_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
op_logical_neg
id|h
op_logical_and
op_star
id|bucket
OL
id|ip_conntrack_htable_size
suffix:semicolon
(paren
op_star
id|bucket
)paren
op_increment
)paren
(brace
id|h
op_assign
id|LIST_FIND
c_func
(paren
op_amp
id|ip_conntrack_hash
(braket
op_star
id|bucket
)braket
comma
id|do_kill
comma
r_struct
id|ip_conntrack_tuple_hash
op_star
comma
id|kill
comma
id|data
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|h
)paren
id|atomic_inc
c_func
(paren
op_amp
id|h-&gt;ctrack-&gt;ct_general.use
)paren
suffix:semicolon
id|READ_UNLOCK
c_func
(paren
op_amp
id|ip_conntrack_lock
)paren
suffix:semicolon
r_return
id|h
suffix:semicolon
)brace
r_void
DECL|function|ip_ct_selective_cleanup
id|ip_ct_selective_cleanup
c_func
(paren
r_int
(paren
op_star
id|kill
)paren
(paren
r_const
r_struct
id|ip_conntrack
op_star
id|i
comma
r_void
op_star
id|data
)paren
comma
r_void
op_star
id|data
)paren
(brace
r_struct
id|ip_conntrack_tuple_hash
op_star
id|h
suffix:semicolon
r_int
r_int
id|bucket
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
(paren
id|h
op_assign
id|get_next_corpse
c_func
(paren
id|kill
comma
id|data
comma
op_amp
id|bucket
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* Time to push up daises... */
r_if
c_cond
(paren
id|del_timer
c_func
(paren
op_amp
id|h-&gt;ctrack-&gt;timeout
)paren
)paren
id|death_by_timeout
c_func
(paren
(paren
r_int
r_int
)paren
id|h-&gt;ctrack
)paren
suffix:semicolon
multiline_comment|/* ... else the timer will get him soon. */
id|ip_conntrack_put
c_func
(paren
id|h-&gt;ctrack
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Fast function for those who don&squot;t want to parse /proc (and I don&squot;t&n;   blame them). */
multiline_comment|/* Reversing the socket&squot;s dst/src point of view gives us the reply&n;   mapping. */
r_static
r_int
DECL|function|getorigdst
id|getorigdst
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|optval
comma
r_void
id|__user
op_star
id|user
comma
r_int
op_star
id|len
)paren
(brace
r_struct
id|inet_opt
op_star
id|inet
op_assign
id|inet_sk
c_func
(paren
id|sk
)paren
suffix:semicolon
r_struct
id|ip_conntrack_tuple_hash
op_star
id|h
suffix:semicolon
r_struct
id|ip_conntrack_tuple
id|tuple
suffix:semicolon
id|IP_CT_TUPLE_U_BLANK
c_func
(paren
op_amp
id|tuple
)paren
suffix:semicolon
id|tuple.src.ip
op_assign
id|inet-&gt;rcv_saddr
suffix:semicolon
id|tuple.src.u.tcp.port
op_assign
id|inet-&gt;sport
suffix:semicolon
id|tuple.dst.ip
op_assign
id|inet-&gt;daddr
suffix:semicolon
id|tuple.dst.u.tcp.port
op_assign
id|inet-&gt;dport
suffix:semicolon
id|tuple.dst.protonum
op_assign
id|IPPROTO_TCP
suffix:semicolon
multiline_comment|/* We only do TCP at the moment: is there a better way? */
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|sk-&gt;sk_prot-&gt;name
comma
l_string|&quot;TCP&quot;
)paren
)paren
(brace
id|DEBUGP
c_func
(paren
l_string|&quot;SO_ORIGINAL_DST: Not a TCP socket&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOPROTOOPT
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
r_int
r_int
)paren
op_star
id|len
OL
r_sizeof
(paren
r_struct
id|sockaddr_in
)paren
)paren
(brace
id|DEBUGP
c_func
(paren
l_string|&quot;SO_ORIGINAL_DST: len %u not %u&bslash;n&quot;
comma
op_star
id|len
comma
r_sizeof
(paren
r_struct
id|sockaddr_in
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|h
op_assign
id|ip_conntrack_find_get
c_func
(paren
op_amp
id|tuple
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|h
)paren
(brace
r_struct
id|sockaddr_in
id|sin
suffix:semicolon
id|sin.sin_family
op_assign
id|AF_INET
suffix:semicolon
id|sin.sin_port
op_assign
id|h-&gt;ctrack-&gt;tuplehash
(braket
id|IP_CT_DIR_ORIGINAL
)braket
dot
id|tuple.dst.u.tcp.port
suffix:semicolon
id|sin.sin_addr.s_addr
op_assign
id|h-&gt;ctrack-&gt;tuplehash
(braket
id|IP_CT_DIR_ORIGINAL
)braket
dot
id|tuple.dst.ip
suffix:semicolon
id|DEBUGP
c_func
(paren
l_string|&quot;SO_ORIGINAL_DST: %u.%u.%u.%u %u&bslash;n&quot;
comma
id|NIPQUAD
c_func
(paren
id|sin.sin_addr.s_addr
)paren
comma
id|ntohs
c_func
(paren
id|sin.sin_port
)paren
)paren
suffix:semicolon
id|ip_conntrack_put
c_func
(paren
id|h-&gt;ctrack
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|user
comma
op_amp
id|sin
comma
r_sizeof
(paren
id|sin
)paren
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_else
r_return
l_int|0
suffix:semicolon
)brace
id|DEBUGP
c_func
(paren
l_string|&quot;SO_ORIGINAL_DST: Can&squot;t find %u.%u.%u.%u/%u-%u.%u.%u.%u/%u.&bslash;n&quot;
comma
id|NIPQUAD
c_func
(paren
id|tuple.src.ip
)paren
comma
id|ntohs
c_func
(paren
id|tuple.src.u.tcp.port
)paren
comma
id|NIPQUAD
c_func
(paren
id|tuple.dst.ip
)paren
comma
id|ntohs
c_func
(paren
id|tuple.dst.u.tcp.port
)paren
)paren
suffix:semicolon
r_return
op_minus
id|ENOENT
suffix:semicolon
)brace
DECL|variable|so_getorigdst
r_static
r_struct
id|nf_sockopt_ops
id|so_getorigdst
op_assign
(brace
dot
id|pf
op_assign
id|PF_INET
comma
dot
id|get_optmin
op_assign
id|SO_ORIGINAL_DST
comma
dot
id|get_optmax
op_assign
id|SO_ORIGINAL_DST
op_plus
l_int|1
comma
dot
id|get
op_assign
op_amp
id|getorigdst
comma
)brace
suffix:semicolon
DECL|function|kill_all
r_static
r_int
id|kill_all
c_func
(paren
r_const
r_struct
id|ip_conntrack
op_star
id|i
comma
r_void
op_star
id|data
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Mishearing the voices in his head, our hero wonders how he&squot;s&n;   supposed to kill the mall. */
DECL|function|ip_conntrack_cleanup
r_void
id|ip_conntrack_cleanup
c_func
(paren
r_void
)paren
(brace
id|ip_ct_attach
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* This makes sure all current packets have passed through&n;           netfilter framework.  Roll on, two-stage module&n;           delete... */
id|synchronize_net
c_func
(paren
)paren
suffix:semicolon
id|i_see_dead_people
suffix:colon
id|ip_ct_selective_cleanup
c_func
(paren
id|kill_all
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|ip_conntrack_count
)paren
op_ne
l_int|0
)paren
(brace
id|schedule
c_func
(paren
)paren
suffix:semicolon
r_goto
id|i_see_dead_people
suffix:semicolon
)brace
id|kmem_cache_destroy
c_func
(paren
id|ip_conntrack_cachep
)paren
suffix:semicolon
id|vfree
c_func
(paren
id|ip_conntrack_hash
)paren
suffix:semicolon
id|nf_unregister_sockopt
c_func
(paren
op_amp
id|so_getorigdst
)paren
suffix:semicolon
)brace
DECL|variable|hashsize
r_static
r_int
id|hashsize
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|hashsize
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
DECL|function|ip_conntrack_init
r_int
id|__init
id|ip_conntrack_init
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
r_int
id|ret
suffix:semicolon
multiline_comment|/* Idea from tcp.c: use 1/16384 of memory.  On i386: 32MB&n;&t; * machine has 256 buckets.  &gt;= 1GB machines have 8192 buckets. */
r_if
c_cond
(paren
id|hashsize
)paren
(brace
id|ip_conntrack_htable_size
op_assign
id|hashsize
suffix:semicolon
)brace
r_else
(brace
id|ip_conntrack_htable_size
op_assign
(paren
(paren
(paren
id|num_physpages
op_lshift
id|PAGE_SHIFT
)paren
op_div
l_int|16384
)paren
op_div
r_sizeof
(paren
r_struct
id|list_head
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|num_physpages
OG
(paren
l_int|1024
op_star
l_int|1024
op_star
l_int|1024
op_div
id|PAGE_SIZE
)paren
)paren
id|ip_conntrack_htable_size
op_assign
l_int|8192
suffix:semicolon
r_if
c_cond
(paren
id|ip_conntrack_htable_size
OL
l_int|16
)paren
id|ip_conntrack_htable_size
op_assign
l_int|16
suffix:semicolon
)brace
id|ip_conntrack_max
op_assign
l_int|8
op_star
id|ip_conntrack_htable_size
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ip_conntrack version %s (%u buckets, %d max)&quot;
l_string|&quot; - %Zd bytes per conntrack&bslash;n&quot;
comma
id|IP_CONNTRACK_VERSION
comma
id|ip_conntrack_htable_size
comma
id|ip_conntrack_max
comma
r_sizeof
(paren
r_struct
id|ip_conntrack
)paren
)paren
suffix:semicolon
id|ret
op_assign
id|nf_register_sockopt
c_func
(paren
op_amp
id|so_getorigdst
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Unable to register netfilter socket option&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
id|ip_conntrack_hash
op_assign
id|vmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|list_head
)paren
op_star
id|ip_conntrack_htable_size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ip_conntrack_hash
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Unable to create ip_conntrack_hash&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|err_unreg_sockopt
suffix:semicolon
)brace
id|ip_conntrack_cachep
op_assign
id|kmem_cache_create
c_func
(paren
l_string|&quot;ip_conntrack&quot;
comma
r_sizeof
(paren
r_struct
id|ip_conntrack
)paren
comma
l_int|0
comma
id|SLAB_HWCACHE_ALIGN
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ip_conntrack_cachep
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Unable to create ip_conntrack slab cache&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|err_free_hash
suffix:semicolon
)brace
multiline_comment|/* Don&squot;t NEED lock here, but good form anyway. */
id|WRITE_LOCK
c_func
(paren
op_amp
id|ip_conntrack_lock
)paren
suffix:semicolon
multiline_comment|/* Sew in builtin protocols. */
id|list_append
c_func
(paren
op_amp
id|protocol_list
comma
op_amp
id|ip_conntrack_protocol_tcp
)paren
suffix:semicolon
id|list_append
c_func
(paren
op_amp
id|protocol_list
comma
op_amp
id|ip_conntrack_protocol_udp
)paren
suffix:semicolon
id|list_append
c_func
(paren
op_amp
id|protocol_list
comma
op_amp
id|ip_conntrack_protocol_icmp
)paren
suffix:semicolon
id|WRITE_UNLOCK
c_func
(paren
op_amp
id|ip_conntrack_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ip_conntrack_htable_size
suffix:semicolon
id|i
op_increment
)paren
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|ip_conntrack_hash
(braket
id|i
)braket
)paren
suffix:semicolon
multiline_comment|/* For use by ipt_REJECT */
id|ip_ct_attach
op_assign
id|ip_conntrack_attach
suffix:semicolon
multiline_comment|/* Set up fake conntrack:&n;&t;    - to never be deleted, not in any hashes */
id|atomic_set
c_func
(paren
op_amp
id|ip_conntrack_untracked.ct_general.use
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/*  - and look it like as a confirmed connection */
id|set_bit
c_func
(paren
id|IPS_CONFIRMED_BIT
comma
op_amp
id|ip_conntrack_untracked.status
)paren
suffix:semicolon
multiline_comment|/*  - and prepare the ctinfo field for REJECT &amp; NAT. */
id|ip_conntrack_untracked.infos
(braket
id|IP_CT_NEW
)braket
dot
id|master
op_assign
id|ip_conntrack_untracked.infos
(braket
id|IP_CT_RELATED
)braket
dot
id|master
op_assign
id|ip_conntrack_untracked.infos
(braket
id|IP_CT_RELATED
op_plus
id|IP_CT_IS_REPLY
)braket
dot
id|master
op_assign
op_amp
id|ip_conntrack_untracked.ct_general
suffix:semicolon
r_return
id|ret
suffix:semicolon
id|err_free_hash
suffix:colon
id|vfree
c_func
(paren
id|ip_conntrack_hash
)paren
suffix:semicolon
id|err_unreg_sockopt
suffix:colon
id|nf_unregister_sockopt
c_func
(paren
op_amp
id|so_getorigdst
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
eof
