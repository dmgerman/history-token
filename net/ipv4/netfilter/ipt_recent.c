multiline_comment|/* Kernel module to check if the source address has been seen recently. */
multiline_comment|/* Copyright 2002-2003, Stephen Frost, 2.5.x port by laforge@netfilter.org */
multiline_comment|/* Author: Stephen Frost &lt;sfrost@snowman.net&gt; */
multiline_comment|/* Project Page: http://snowman.net/projects/ipt_recent/ */
multiline_comment|/* This software is distributed under the terms of the GPL, Version 2 */
multiline_comment|/* This copyright does not cover user programs that use kernel services&n; * by normal system calls. */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;linux/ctype.h&gt;
macro_line|#include &lt;linux/ip.h&gt;
macro_line|#include &lt;linux/vmalloc.h&gt;
macro_line|#include &lt;linux/moduleparam.h&gt;
macro_line|#include &lt;linux/netfilter_ipv4/ip_tables.h&gt;
macro_line|#include &lt;linux/netfilter_ipv4/ipt_recent.h&gt;
DECL|macro|DEBUG
macro_line|#undef DEBUG
DECL|macro|HASH_LOG
mdefine_line|#define HASH_LOG 9
multiline_comment|/* Defaults, these can be overridden on the module command-line. */
DECL|variable|ip_list_tot
r_static
r_int
id|ip_list_tot
op_assign
l_int|100
suffix:semicolon
DECL|variable|ip_pkt_list_tot
r_static
r_int
id|ip_pkt_list_tot
op_assign
l_int|20
suffix:semicolon
DECL|variable|ip_list_hash_size
r_static
r_int
id|ip_list_hash_size
op_assign
l_int|0
suffix:semicolon
DECL|variable|ip_list_perms
r_static
r_int
id|ip_list_perms
op_assign
l_int|0644
suffix:semicolon
macro_line|#ifdef DEBUG
DECL|variable|debug
r_static
r_int
id|debug
op_assign
l_int|1
suffix:semicolon
macro_line|#endif
DECL|variable|version
r_static
r_char
id|version
(braket
)braket
op_assign
id|KERN_INFO
id|RECENT_NAME
l_string|&quot; &quot;
id|RECENT_VER
l_string|&quot;: Stephen Frost &lt;sfrost@snowman.net&gt;.  http://snowman.net/projects/ipt_recent/&bslash;n&quot;
suffix:semicolon
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Stephen Frost &lt;sfrost@snowman.net&gt;&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;IP tables recently seen matching module &quot;
id|RECENT_VER
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
id|module_param
c_func
(paren
id|ip_list_tot
comma
r_int
comma
l_int|0400
)paren
suffix:semicolon
id|module_param
c_func
(paren
id|ip_pkt_list_tot
comma
r_int
comma
l_int|0400
)paren
suffix:semicolon
id|module_param
c_func
(paren
id|ip_list_hash_size
comma
r_int
comma
l_int|0400
)paren
suffix:semicolon
id|module_param
c_func
(paren
id|ip_list_perms
comma
r_int
comma
l_int|0400
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
id|module_param
c_func
(paren
id|debug
comma
r_int
comma
l_int|0600
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|debug
comma
l_string|&quot;debugging level, defaults to 1&quot;
)paren
suffix:semicolon
macro_line|#endif
id|MODULE_PARM_DESC
c_func
(paren
id|ip_list_tot
comma
l_string|&quot;number of IPs to remember per list&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|ip_pkt_list_tot
comma
l_string|&quot;number of packets per IP to remember&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|ip_list_hash_size
comma
l_string|&quot;size of hash table used to look up IPs&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|ip_list_perms
comma
l_string|&quot;permissions on /proc/net/ipt_recent/* files&quot;
)paren
suffix:semicolon
multiline_comment|/* Structure of our list of recently seen addresses. */
DECL|struct|recent_ip_list
r_struct
id|recent_ip_list
(brace
DECL|member|addr
id|u_int32_t
id|addr
suffix:semicolon
DECL|member|ttl
id|u_int8_t
id|ttl
suffix:semicolon
DECL|member|last_seen
r_int
r_int
id|last_seen
suffix:semicolon
DECL|member|last_pkts
r_int
r_int
op_star
id|last_pkts
suffix:semicolon
DECL|member|oldest_pkt
id|u_int32_t
id|oldest_pkt
suffix:semicolon
DECL|member|hash_entry
id|u_int32_t
id|hash_entry
suffix:semicolon
DECL|member|time_pos
id|u_int32_t
id|time_pos
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|time_info_list
r_struct
id|time_info_list
(brace
DECL|member|position
id|u_int32_t
id|position
suffix:semicolon
DECL|member|time
id|u_int32_t
id|time
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* Structure of our linked list of tables of recent lists. */
DECL|struct|recent_ip_tables
r_struct
id|recent_ip_tables
(brace
DECL|member|name
r_char
id|name
(braket
id|IPT_RECENT_NAME_LEN
)braket
suffix:semicolon
DECL|member|count
r_int
id|count
suffix:semicolon
DECL|member|time_pos
r_int
id|time_pos
suffix:semicolon
DECL|member|table
r_struct
id|recent_ip_list
op_star
id|table
suffix:semicolon
DECL|member|next
r_struct
id|recent_ip_tables
op_star
id|next
suffix:semicolon
DECL|member|list_lock
id|spinlock_t
id|list_lock
suffix:semicolon
DECL|member|hash_table
r_int
op_star
id|hash_table
suffix:semicolon
DECL|member|time_info
r_struct
id|time_info_list
op_star
id|time_info
suffix:semicolon
macro_line|#ifdef CONFIG_PROC_FS
DECL|member|status_proc
r_struct
id|proc_dir_entry
op_star
id|status_proc
suffix:semicolon
macro_line|#endif /* CONFIG_PROC_FS */
)brace
suffix:semicolon
multiline_comment|/* Our current list of addresses we have recently seen.&n; * Only added to on a --set, and only updated on --set || --update &n; */
DECL|variable|r_tables
r_static
r_struct
id|recent_ip_tables
op_star
id|r_tables
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* We protect r_list with this spinlock so two processors are not modifying&n; * the list at the same time. &n; */
DECL|variable|recent_lock
r_static
id|spinlock_t
id|recent_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
macro_line|#ifdef CONFIG_PROC_FS
multiline_comment|/* Our /proc/net/ipt_recent entry */
DECL|variable|proc_net_ipt_recent
r_static
r_struct
id|proc_dir_entry
op_star
id|proc_net_ipt_recent
op_assign
l_int|NULL
suffix:semicolon
macro_line|#endif
multiline_comment|/* Function declaration for later. */
r_static
r_int
id|match
c_func
(paren
r_const
r_struct
id|sk_buff
op_star
id|skb
comma
r_const
r_struct
id|net_device
op_star
id|in
comma
r_const
r_struct
id|net_device
op_star
id|out
comma
r_const
r_void
op_star
id|matchinfo
comma
r_int
id|offset
comma
r_int
op_star
id|hotdrop
)paren
suffix:semicolon
multiline_comment|/* Function to hash a given address into the hash table of table_size size */
DECL|function|hash_func
r_int
id|hash_func
c_func
(paren
r_int
r_int
id|addr
comma
r_int
id|table_size
)paren
(brace
r_int
id|result
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|value
op_assign
id|addr
suffix:semicolon
r_do
(brace
id|result
op_xor_assign
id|value
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|value
op_rshift_assign
id|HASH_LOG
)paren
)paren
(brace
suffix:semicolon
)brace
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
id|debug
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
id|RECENT_NAME
l_string|&quot;: %d = hash_func(%u,%d)&bslash;n&quot;
comma
id|result
op_amp
(paren
id|table_size
op_minus
l_int|1
)paren
comma
id|addr
comma
id|table_size
)paren
suffix:semicolon
)brace
macro_line|#endif
r_return
id|result
op_amp
(paren
id|table_size
op_minus
l_int|1
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_PROC_FS
multiline_comment|/* This is the function which produces the output for our /proc output&n; * interface which lists each IP address, the last seen time and the &n; * other recent times the address was seen.&n; */
DECL|function|ip_recent_get_info
r_static
r_int
id|ip_recent_get_info
c_func
(paren
r_char
op_star
id|buffer
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|length
comma
r_int
op_star
id|eof
comma
r_void
op_star
id|data
)paren
(brace
r_int
id|len
op_assign
l_int|0
comma
id|count
comma
id|last_len
op_assign
l_int|0
comma
id|pkt_count
suffix:semicolon
id|off_t
id|pos
op_assign
l_int|0
suffix:semicolon
id|off_t
id|begin
op_assign
l_int|0
suffix:semicolon
r_struct
id|recent_ip_tables
op_star
id|curr_table
suffix:semicolon
id|curr_table
op_assign
(paren
r_struct
id|recent_ip_tables
op_star
)paren
id|data
suffix:semicolon
id|spin_lock_bh
c_func
(paren
op_amp
id|curr_table-&gt;list_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|count
op_assign
l_int|0
suffix:semicolon
id|count
OL
id|ip_list_tot
suffix:semicolon
id|count
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|curr_table-&gt;table
(braket
id|count
)braket
dot
id|addr
)paren
(brace
r_continue
suffix:semicolon
)brace
id|last_len
op_assign
id|len
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;src=%u.%u.%u.%u &quot;
comma
id|NIPQUAD
c_func
(paren
id|curr_table-&gt;table
(braket
id|count
)braket
dot
id|addr
)paren
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;ttl: %u &quot;
comma
id|curr_table-&gt;table
(braket
id|count
)braket
dot
id|ttl
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;last_seen: %lu &quot;
comma
id|curr_table-&gt;table
(braket
id|count
)braket
dot
id|last_seen
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;oldest_pkt: %u &quot;
comma
id|curr_table-&gt;table
(braket
id|count
)braket
dot
id|oldest_pkt
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;last_pkts: %lu&quot;
comma
id|curr_table-&gt;table
(braket
id|count
)braket
dot
id|last_pkts
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_for
c_loop
(paren
id|pkt_count
op_assign
l_int|1
suffix:semicolon
id|pkt_count
OL
id|ip_pkt_list_tot
suffix:semicolon
id|pkt_count
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|curr_table-&gt;table
(braket
id|count
)braket
dot
id|last_pkts
(braket
id|pkt_count
)braket
)paren
(brace
r_break
suffix:semicolon
)brace
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;, %lu&quot;
comma
id|curr_table-&gt;table
(braket
id|count
)braket
dot
id|last_pkts
(braket
id|pkt_count
)braket
)paren
suffix:semicolon
)brace
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|pos
op_assign
id|begin
op_plus
id|len
suffix:semicolon
r_if
c_cond
(paren
id|pos
OL
id|offset
)paren
(brace
id|len
op_assign
l_int|0
suffix:semicolon
id|begin
op_assign
id|pos
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pos
OG
id|offset
op_plus
id|length
)paren
(brace
id|len
op_assign
id|last_len
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
op_star
id|start
op_assign
id|buffer
op_plus
(paren
id|offset
op_minus
id|begin
)paren
suffix:semicolon
id|len
op_sub_assign
(paren
id|offset
op_minus
id|begin
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|length
)paren
(brace
id|len
op_assign
id|length
suffix:semicolon
)brace
id|spin_unlock_bh
c_func
(paren
op_amp
id|curr_table-&gt;list_lock
)paren
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
multiline_comment|/* ip_recent_ctrl provides an interface for users to modify the table&n; * directly.  This allows adding entries, removing entries, and&n; * flushing the entire table.&n; * This is done by opening up the appropriate table for writing and&n; * sending one of:&n; * xx.xx.xx.xx   -- Add entry to table with current time&n; * +xx.xx.xx.xx  -- Add entry to table with current time&n; * -xx.xx.xx.xx  -- Remove entry from table&n; * clear         -- Flush table, remove all entries&n; */
DECL|function|ip_recent_ctrl
r_static
r_int
id|ip_recent_ctrl
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_const
r_char
id|__user
op_star
id|input
comma
r_int
r_int
id|size
comma
r_void
op_star
id|data
)paren
(brace
r_static
r_const
id|u_int32_t
id|max
(braket
l_int|4
)braket
op_assign
(brace
l_int|0xffffffff
comma
l_int|0xffffff
comma
l_int|0xffff
comma
l_int|0xff
)brace
suffix:semicolon
id|u_int32_t
id|val
suffix:semicolon
r_int
id|base
comma
id|used
op_assign
l_int|0
suffix:semicolon
r_char
id|c
comma
op_star
id|cp
suffix:semicolon
r_union
id|iaddr
(brace
r_uint8
id|bytes
(braket
l_int|4
)braket
suffix:semicolon
r_uint32
id|word
suffix:semicolon
)brace
id|res
suffix:semicolon
r_uint8
op_star
id|pp
op_assign
id|res.bytes
suffix:semicolon
r_int
id|digit
suffix:semicolon
r_char
id|buffer
(braket
l_int|20
)braket
suffix:semicolon
r_int
id|len
comma
id|check_set
op_assign
l_int|0
comma
id|count
suffix:semicolon
id|u_int32_t
id|addr
op_assign
l_int|0
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_struct
id|ipt_recent_info
op_star
id|info
suffix:semicolon
r_struct
id|recent_ip_tables
op_star
id|curr_table
suffix:semicolon
id|curr_table
op_assign
(paren
r_struct
id|recent_ip_tables
op_star
)paren
id|data
suffix:semicolon
r_if
c_cond
(paren
id|size
OG
l_int|20
)paren
(brace
id|len
op_assign
l_int|20
suffix:semicolon
)brace
r_else
id|len
op_assign
id|size
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|buffer
comma
id|input
comma
id|len
)paren
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_if
c_cond
(paren
id|len
OL
l_int|20
)paren
(brace
id|buffer
(braket
id|len
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
)brace
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
id|debug
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
id|RECENT_NAME
l_string|&quot;: ip_recent_ctrl len: %d, input: `%.20s&squot;&bslash;n&quot;
comma
id|len
comma
id|buffer
)paren
suffix:semicolon
)brace
macro_line|#endif
id|cp
op_assign
id|buffer
suffix:semicolon
r_while
c_loop
(paren
id|isspace
c_func
(paren
op_star
id|cp
)paren
)paren
(brace
id|cp
op_increment
suffix:semicolon
id|used
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|used
op_ge
id|len
op_minus
l_int|5
)paren
(brace
r_return
id|used
suffix:semicolon
)brace
)brace
multiline_comment|/* Check if we are asked to flush the entire table */
r_if
c_cond
(paren
op_logical_neg
id|memcmp
c_func
(paren
id|cp
comma
l_string|&quot;clear&quot;
comma
l_int|5
)paren
)paren
(brace
id|used
op_add_assign
l_int|5
suffix:semicolon
id|spin_lock_bh
c_func
(paren
op_amp
id|curr_table-&gt;list_lock
)paren
suffix:semicolon
id|curr_table-&gt;time_pos
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|count
op_assign
l_int|0
suffix:semicolon
id|count
OL
id|ip_list_hash_size
suffix:semicolon
id|count
op_increment
)paren
(brace
id|curr_table-&gt;hash_table
(braket
id|count
)braket
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
r_for
c_loop
(paren
id|count
op_assign
l_int|0
suffix:semicolon
id|count
OL
id|ip_list_tot
suffix:semicolon
id|count
op_increment
)paren
(brace
id|curr_table-&gt;table
(braket
id|count
)braket
dot
id|last_seen
op_assign
l_int|0
suffix:semicolon
id|curr_table-&gt;table
(braket
id|count
)braket
dot
id|addr
op_assign
l_int|0
suffix:semicolon
id|curr_table-&gt;table
(braket
id|count
)braket
dot
id|ttl
op_assign
l_int|0
suffix:semicolon
id|memset
c_func
(paren
id|curr_table-&gt;table
(braket
id|count
)braket
dot
id|last_pkts
comma
l_int|0
comma
id|ip_pkt_list_tot
op_star
r_sizeof
(paren
id|u_int32_t
)paren
)paren
suffix:semicolon
id|curr_table-&gt;table
(braket
id|count
)braket
dot
id|oldest_pkt
op_assign
l_int|0
suffix:semicolon
id|curr_table-&gt;table
(braket
id|count
)braket
dot
id|time_pos
op_assign
l_int|0
suffix:semicolon
id|curr_table-&gt;time_info
(braket
id|count
)braket
dot
id|position
op_assign
id|count
suffix:semicolon
id|curr_table-&gt;time_info
(braket
id|count
)braket
dot
id|time
op_assign
l_int|0
suffix:semicolon
)brace
id|spin_unlock_bh
c_func
(paren
op_amp
id|curr_table-&gt;list_lock
)paren
suffix:semicolon
r_return
id|used
suffix:semicolon
)brace
id|check_set
op_assign
id|IPT_RECENT_SET
suffix:semicolon
r_switch
c_cond
(paren
op_star
id|cp
)paren
(brace
r_case
l_char|&squot;+&squot;
suffix:colon
id|check_set
op_assign
id|IPT_RECENT_SET
suffix:semicolon
id|cp
op_increment
suffix:semicolon
id|used
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;-&squot;
suffix:colon
id|check_set
op_assign
id|IPT_RECENT_REMOVE
suffix:semicolon
id|cp
op_increment
suffix:semicolon
id|used
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|isdigit
c_func
(paren
op_star
id|cp
)paren
)paren
(brace
r_return
(paren
id|used
op_plus
l_int|1
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
id|debug
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
id|RECENT_NAME
l_string|&quot;: ip_recent_ctrl cp: `%c&squot;, check_set: %d&bslash;n&quot;
comma
op_star
id|cp
comma
id|check_set
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* Get addr (effectively inet_aton()) */
multiline_comment|/* Shamelessly stolen from libc, a function in the kernel for doing&n;&t; * this would, of course, be greatly preferred, but our options appear&n;&t; * to be rather limited, so we will just do it ourselves here.&n;&t; */
id|res.word
op_assign
l_int|0
suffix:semicolon
id|c
op_assign
op_star
id|cp
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|isdigit
c_func
(paren
id|c
)paren
)paren
(brace
r_return
id|used
suffix:semicolon
)brace
id|val
op_assign
l_int|0
suffix:semicolon
id|base
op_assign
l_int|10
suffix:semicolon
id|digit
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;0&squot;
)paren
(brace
id|c
op_assign
op_star
op_increment
id|cp
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;x&squot;
op_logical_or
id|c
op_eq
l_char|&squot;X&squot;
)paren
(brace
id|base
op_assign
l_int|16
comma
id|c
op_assign
op_star
op_increment
id|cp
suffix:semicolon
)brace
r_else
(brace
id|base
op_assign
l_int|8
suffix:semicolon
id|digit
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
id|isascii
c_func
(paren
id|c
)paren
op_logical_and
id|isdigit
c_func
(paren
id|c
)paren
)paren
(brace
r_if
c_cond
(paren
id|base
op_eq
l_int|8
op_logical_and
(paren
id|c
op_eq
l_char|&squot;8&squot;
op_logical_or
id|c
op_eq
l_char|&squot;0&squot;
)paren
)paren
(brace
r_return
id|used
suffix:semicolon
)brace
id|val
op_assign
(paren
id|val
op_star
id|base
)paren
op_plus
(paren
id|c
op_minus
l_char|&squot;0&squot;
)paren
suffix:semicolon
id|c
op_assign
op_star
op_increment
id|cp
suffix:semicolon
id|digit
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|base
op_eq
l_int|16
op_logical_and
id|isascii
c_func
(paren
id|c
)paren
op_logical_and
id|isxdigit
c_func
(paren
id|c
)paren
)paren
(brace
id|val
op_assign
(paren
id|val
op_lshift
l_int|4
)paren
op_or
(paren
id|c
op_plus
l_int|10
op_minus
(paren
id|islower
c_func
(paren
id|c
)paren
ques
c_cond
l_char|&squot;a&squot;
suffix:colon
l_char|&squot;A&squot;
)paren
)paren
suffix:semicolon
id|c
op_assign
op_star
op_increment
id|cp
suffix:semicolon
id|digit
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;.&squot;
)paren
(brace
r_if
c_cond
(paren
id|pp
OG
id|res.bytes
op_plus
l_int|2
op_logical_or
id|val
OG
l_int|0xff
)paren
(brace
r_return
id|used
suffix:semicolon
)brace
op_star
id|pp
op_increment
op_assign
id|val
suffix:semicolon
id|c
op_assign
op_star
op_increment
id|cp
suffix:semicolon
)brace
r_else
r_break
suffix:semicolon
)brace
id|used
op_assign
id|cp
op_minus
id|buffer
suffix:semicolon
r_if
c_cond
(paren
id|c
op_ne
l_char|&squot;&bslash;0&squot;
op_logical_and
(paren
op_logical_neg
id|isascii
c_func
(paren
id|c
)paren
op_logical_or
op_logical_neg
id|isspace
c_func
(paren
id|c
)paren
)paren
)paren
(brace
r_return
id|used
suffix:semicolon
)brace
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;&bslash;n&squot;
)paren
(brace
id|used
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|digit
)paren
(brace
r_return
id|used
suffix:semicolon
)brace
r_if
c_cond
(paren
id|val
OG
id|max
(braket
id|pp
op_minus
id|res.bytes
)braket
)paren
(brace
r_return
id|used
suffix:semicolon
)brace
id|addr
op_assign
id|res.word
op_or
id|htonl
c_func
(paren
id|val
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|addr
op_logical_and
id|check_set
op_eq
id|IPT_RECENT_SET
)paren
(brace
r_return
id|used
suffix:semicolon
)brace
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
id|debug
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
id|RECENT_NAME
l_string|&quot;: ip_recent_ctrl c: %c, addr: %u used: %d&bslash;n&quot;
comma
id|c
comma
id|addr
comma
id|used
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* Set up and just call match */
id|info
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|ipt_recent_info
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|info
)paren
(brace
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|info-&gt;seconds
op_assign
l_int|0
suffix:semicolon
id|info-&gt;hit_count
op_assign
l_int|0
suffix:semicolon
id|info-&gt;check_set
op_assign
id|check_set
suffix:semicolon
id|info-&gt;invert
op_assign
l_int|0
suffix:semicolon
id|info-&gt;side
op_assign
id|IPT_RECENT_SOURCE
suffix:semicolon
id|strncpy
c_func
(paren
id|info-&gt;name
comma
id|curr_table-&gt;name
comma
id|IPT_RECENT_NAME_LEN
)paren
suffix:semicolon
id|info-&gt;name
(braket
id|IPT_RECENT_NAME_LEN
op_minus
l_int|1
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|skb
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|sk_buff
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skb
)paren
(brace
id|used
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|out_free_info
suffix:semicolon
)brace
id|skb-&gt;nh.iph
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|iphdr
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skb-&gt;nh.iph
)paren
(brace
id|used
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|out_free_skb
suffix:semicolon
)brace
id|skb-&gt;nh.iph-&gt;saddr
op_assign
id|addr
suffix:semicolon
id|skb-&gt;nh.iph-&gt;daddr
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Clear ttl since we have no way of knowing it */
id|skb-&gt;nh.iph-&gt;ttl
op_assign
l_int|0
suffix:semicolon
id|match
c_func
(paren
id|skb
comma
l_int|NULL
comma
l_int|NULL
comma
id|info
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|skb-&gt;nh.iph
)paren
suffix:semicolon
id|out_free_skb
suffix:colon
id|kfree
c_func
(paren
id|skb
)paren
suffix:semicolon
id|out_free_info
suffix:colon
id|kfree
c_func
(paren
id|info
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
id|debug
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
id|RECENT_NAME
l_string|&quot;: Leaving ip_recent_ctrl addr: %u used: %d&bslash;n&quot;
comma
id|addr
comma
id|used
)paren
suffix:semicolon
)brace
macro_line|#endif
r_return
id|used
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_PROC_FS */
multiline_comment|/* &squot;match&squot; is our primary function, called by the kernel whenever a rule is&n; * hit with our module as an option to it.&n; * What this function does depends on what was specifically asked of it by&n; * the user:&n; * --set -- Add or update last seen time of the source address of the packet&n; *   -- matchinfo-&gt;check_set == IPT_RECENT_SET&n; * --rcheck -- Just check if the source address is in the list&n; *   -- matchinfo-&gt;check_set == IPT_RECENT_CHECK&n; * --update -- If the source address is in the list, update last_seen&n; *   -- matchinfo-&gt;check_set == IPT_RECENT_UPDATE&n; * --remove -- If the source address is in the list, remove it&n; *   -- matchinfo-&gt;check_set == IPT_RECENT_REMOVE&n; * --seconds -- Option to --rcheck/--update, only match if last_seen within seconds&n; *   -- matchinfo-&gt;seconds&n; * --hitcount -- Option to --rcheck/--update, only match if seen hitcount times&n; *   -- matchinfo-&gt;hit_count&n; * --seconds and --hitcount can be combined&n; */
r_static
r_int
DECL|function|match
id|match
c_func
(paren
r_const
r_struct
id|sk_buff
op_star
id|skb
comma
r_const
r_struct
id|net_device
op_star
id|in
comma
r_const
r_struct
id|net_device
op_star
id|out
comma
r_const
r_void
op_star
id|matchinfo
comma
r_int
id|offset
comma
r_int
op_star
id|hotdrop
)paren
(brace
r_int
id|pkt_count
comma
id|hits_found
comma
id|ans
suffix:semicolon
r_int
r_int
id|now
suffix:semicolon
r_const
r_struct
id|ipt_recent_info
op_star
id|info
op_assign
id|matchinfo
suffix:semicolon
id|u_int32_t
id|addr
op_assign
l_int|0
comma
id|time_temp
suffix:semicolon
id|u_int8_t
id|ttl
op_assign
id|skb-&gt;nh.iph-&gt;ttl
suffix:semicolon
r_int
op_star
id|hash_table
suffix:semicolon
r_int
id|orig_hash_result
comma
id|hash_result
comma
id|temp
comma
id|location
op_assign
l_int|0
comma
id|time_loc
comma
id|end_collision_chain
op_assign
op_minus
l_int|1
suffix:semicolon
r_struct
id|time_info_list
op_star
id|time_info
suffix:semicolon
r_struct
id|recent_ip_tables
op_star
id|curr_table
suffix:semicolon
r_struct
id|recent_ip_tables
op_star
id|last_table
suffix:semicolon
r_struct
id|recent_ip_list
op_star
id|r_list
suffix:semicolon
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
id|debug
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
id|RECENT_NAME
l_string|&quot;: match() called&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* Default is false ^ info-&gt;invert */
id|ans
op_assign
id|info-&gt;invert
suffix:semicolon
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
id|debug
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
id|RECENT_NAME
l_string|&quot;: match(): name = &squot;%s&squot;&bslash;n&quot;
comma
id|info-&gt;name
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* if out != NULL then routing has been done and TTL changed.&n;&t; * We change it back here internally for match what came in before routing. */
r_if
c_cond
(paren
id|out
)paren
(brace
id|ttl
op_increment
suffix:semicolon
)brace
multiline_comment|/* Find the right table */
id|spin_lock_bh
c_func
(paren
op_amp
id|recent_lock
)paren
suffix:semicolon
id|curr_table
op_assign
id|r_tables
suffix:semicolon
r_while
c_loop
(paren
(paren
id|last_table
op_assign
id|curr_table
)paren
op_logical_and
id|strncmp
c_func
(paren
id|info-&gt;name
comma
id|curr_table-&gt;name
comma
id|IPT_RECENT_NAME_LEN
)paren
op_logical_and
(paren
id|curr_table
op_assign
id|curr_table-&gt;next
)paren
)paren
(brace
suffix:semicolon
)brace
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
id|debug
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
id|RECENT_NAME
l_string|&quot;: match(): table found(&squot;%s&squot;)&bslash;n&quot;
comma
id|info-&gt;name
)paren
suffix:semicolon
)brace
macro_line|#endif
id|spin_unlock_bh
c_func
(paren
op_amp
id|recent_lock
)paren
suffix:semicolon
multiline_comment|/* Table with this name not found, match impossible */
r_if
c_cond
(paren
op_logical_neg
id|curr_table
)paren
(brace
r_return
id|ans
suffix:semicolon
)brace
multiline_comment|/* Make sure no one is changing the list while we work with it */
id|spin_lock_bh
c_func
(paren
op_amp
id|curr_table-&gt;list_lock
)paren
suffix:semicolon
id|r_list
op_assign
id|curr_table-&gt;table
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;side
op_eq
id|IPT_RECENT_DEST
)paren
(brace
id|addr
op_assign
id|skb-&gt;nh.iph-&gt;daddr
suffix:semicolon
)brace
r_else
id|addr
op_assign
id|skb-&gt;nh.iph-&gt;saddr
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|addr
)paren
(brace
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
id|debug
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
id|RECENT_NAME
l_string|&quot;: match() address (%u) invalid, leaving.&bslash;n&quot;
comma
id|addr
)paren
suffix:semicolon
)brace
macro_line|#endif
id|spin_unlock_bh
c_func
(paren
op_amp
id|curr_table-&gt;list_lock
)paren
suffix:semicolon
r_return
id|ans
suffix:semicolon
)brace
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
id|debug
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
id|RECENT_NAME
l_string|&quot;: match(): checking table, addr: %u, ttl: %u, orig_ttl: %u&bslash;n&quot;
comma
id|addr
comma
id|ttl
comma
id|skb-&gt;nh.iph-&gt;ttl
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* Get jiffies now in case they changed while we were waiting for a lock */
id|now
op_assign
id|jiffies
suffix:semicolon
id|hash_table
op_assign
id|curr_table-&gt;hash_table
suffix:semicolon
id|time_info
op_assign
id|curr_table-&gt;time_info
suffix:semicolon
id|orig_hash_result
op_assign
id|hash_result
op_assign
id|hash_func
c_func
(paren
id|addr
comma
id|ip_list_hash_size
)paren
suffix:semicolon
multiline_comment|/* Hash entry at this result used */
multiline_comment|/* Check for TTL match if requested.  If TTL is zero then a match would never&n;&t; * happen, so match regardless of existing TTL in that case.  Zero means the&n;&t; * entry was added via the /proc interface anyway, so we will just use the&n;&t; * first TTL we get for that IP address. */
r_if
c_cond
(paren
id|info-&gt;check_set
op_amp
id|IPT_RECENT_TTL
)paren
(brace
r_while
c_loop
(paren
id|hash_table
(braket
id|hash_result
)braket
op_ne
op_minus
l_int|1
op_logical_and
op_logical_neg
(paren
id|r_list
(braket
id|hash_table
(braket
id|hash_result
)braket
)braket
dot
id|addr
op_eq
id|addr
op_logical_and
(paren
op_logical_neg
id|r_list
(braket
id|hash_table
(braket
id|hash_result
)braket
)braket
dot
id|ttl
op_logical_or
id|r_list
(braket
id|hash_table
(braket
id|hash_result
)braket
)braket
dot
id|ttl
op_eq
id|ttl
)paren
)paren
)paren
(brace
multiline_comment|/* Collision in hash table */
id|hash_result
op_assign
(paren
id|hash_result
op_plus
l_int|1
)paren
op_mod
id|ip_list_hash_size
suffix:semicolon
)brace
)brace
r_else
(brace
r_while
c_loop
(paren
id|hash_table
(braket
id|hash_result
)braket
op_ne
op_minus
l_int|1
op_logical_and
id|r_list
(braket
id|hash_table
(braket
id|hash_result
)braket
)braket
dot
id|addr
op_ne
id|addr
)paren
(brace
multiline_comment|/* Collision in hash table */
id|hash_result
op_assign
(paren
id|hash_result
op_plus
l_int|1
)paren
op_mod
id|ip_list_hash_size
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|hash_table
(braket
id|hash_result
)braket
op_eq
op_minus
l_int|1
op_logical_and
op_logical_neg
(paren
id|info-&gt;check_set
op_amp
id|IPT_RECENT_SET
)paren
)paren
(brace
multiline_comment|/* IP not in list and not asked to SET */
id|spin_unlock_bh
c_func
(paren
op_amp
id|curr_table-&gt;list_lock
)paren
suffix:semicolon
r_return
id|ans
suffix:semicolon
)brace
multiline_comment|/* Check if we need to handle the collision, do not need to on REMOVE */
r_if
c_cond
(paren
id|orig_hash_result
op_ne
id|hash_result
op_logical_and
op_logical_neg
(paren
id|info-&gt;check_set
op_amp
id|IPT_RECENT_REMOVE
)paren
)paren
(brace
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
id|debug
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
id|RECENT_NAME
l_string|&quot;: match(): Collision in hash table. (or: %d,hr: %d,oa: %u,ha: %u)&bslash;n&quot;
comma
id|orig_hash_result
comma
id|hash_result
comma
id|r_list
(braket
id|hash_table
(braket
id|orig_hash_result
)braket
)braket
dot
id|addr
comma
id|addr
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* We had a collision.&n;&t;&t; * orig_hash_result is where we started, hash_result is where we ended up.&n;&t;&t; * So, swap them because we are likely to see the same guy again sooner */
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
id|debug
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
id|RECENT_NAME
l_string|&quot;: match(): Collision; hash_table[orig_hash_result] = %d&bslash;n&quot;
comma
id|hash_table
(braket
id|orig_hash_result
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
id|RECENT_NAME
l_string|&quot;: match(): Collision; r_list[hash_table[orig_hash_result]].hash_entry = %d&bslash;n&quot;
comma
id|r_list
(braket
id|hash_table
(braket
id|orig_hash_result
)braket
)braket
dot
id|hash_entry
)paren
suffix:semicolon
)brace
macro_line|#endif
id|r_list
(braket
id|hash_table
(braket
id|orig_hash_result
)braket
)braket
dot
id|hash_entry
op_assign
id|hash_result
suffix:semicolon
id|temp
op_assign
id|hash_table
(braket
id|orig_hash_result
)braket
suffix:semicolon
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
id|debug
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
id|RECENT_NAME
l_string|&quot;: match(): Collision; hash_table[hash_result] = %d&bslash;n&quot;
comma
id|hash_table
(braket
id|hash_result
)braket
)paren
suffix:semicolon
)brace
macro_line|#endif
id|hash_table
(braket
id|orig_hash_result
)braket
op_assign
id|hash_table
(braket
id|hash_result
)braket
suffix:semicolon
id|hash_table
(braket
id|hash_result
)braket
op_assign
id|temp
suffix:semicolon
id|temp
op_assign
id|hash_result
suffix:semicolon
id|hash_result
op_assign
id|orig_hash_result
suffix:semicolon
id|orig_hash_result
op_assign
id|temp
suffix:semicolon
id|time_info
(braket
id|r_list
(braket
id|hash_table
(braket
id|orig_hash_result
)braket
)braket
dot
id|time_pos
)braket
dot
id|position
op_assign
id|hash_table
(braket
id|orig_hash_result
)braket
suffix:semicolon
r_if
c_cond
(paren
id|hash_table
(braket
id|hash_result
)braket
op_ne
op_minus
l_int|1
)paren
(brace
id|r_list
(braket
id|hash_table
(braket
id|hash_result
)braket
)braket
dot
id|hash_entry
op_assign
id|hash_result
suffix:semicolon
id|time_info
(braket
id|r_list
(braket
id|hash_table
(braket
id|hash_result
)braket
)braket
dot
id|time_pos
)braket
dot
id|position
op_assign
id|hash_table
(braket
id|hash_result
)braket
suffix:semicolon
)brace
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
id|debug
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
id|RECENT_NAME
l_string|&quot;: match(): Collision handled.&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
)brace
r_if
c_cond
(paren
id|hash_table
(braket
id|hash_result
)braket
op_eq
op_minus
l_int|1
)paren
(brace
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
id|debug
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
id|RECENT_NAME
l_string|&quot;: match(): New table entry. (hr: %d,ha: %u)&bslash;n&quot;
comma
id|hash_result
comma
id|addr
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* New item found and IPT_RECENT_SET, so we need to add it */
id|location
op_assign
id|time_info
(braket
id|curr_table-&gt;time_pos
)braket
dot
id|position
suffix:semicolon
id|hash_table
(braket
id|r_list
(braket
id|location
)braket
dot
id|hash_entry
)braket
op_assign
op_minus
l_int|1
suffix:semicolon
id|hash_table
(braket
id|hash_result
)braket
op_assign
id|location
suffix:semicolon
id|memset
c_func
(paren
id|r_list
(braket
id|location
)braket
dot
id|last_pkts
comma
l_int|0
comma
id|ip_pkt_list_tot
op_star
r_sizeof
(paren
id|u_int32_t
)paren
)paren
suffix:semicolon
id|r_list
(braket
id|location
)braket
dot
id|time_pos
op_assign
id|curr_table-&gt;time_pos
suffix:semicolon
id|r_list
(braket
id|location
)braket
dot
id|addr
op_assign
id|addr
suffix:semicolon
id|r_list
(braket
id|location
)braket
dot
id|ttl
op_assign
id|ttl
suffix:semicolon
id|r_list
(braket
id|location
)braket
dot
id|last_seen
op_assign
id|now
suffix:semicolon
id|r_list
(braket
id|location
)braket
dot
id|oldest_pkt
op_assign
l_int|1
suffix:semicolon
id|r_list
(braket
id|location
)braket
dot
id|last_pkts
(braket
l_int|0
)braket
op_assign
id|now
suffix:semicolon
id|r_list
(braket
id|location
)braket
dot
id|hash_entry
op_assign
id|hash_result
suffix:semicolon
id|time_info
(braket
id|curr_table-&gt;time_pos
)braket
dot
id|time
op_assign
id|r_list
(braket
id|location
)braket
dot
id|last_seen
suffix:semicolon
id|curr_table-&gt;time_pos
op_assign
(paren
id|curr_table-&gt;time_pos
op_plus
l_int|1
)paren
op_mod
id|ip_list_tot
suffix:semicolon
id|ans
op_assign
op_logical_neg
id|info-&gt;invert
suffix:semicolon
)brace
r_else
(brace
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
id|debug
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
id|RECENT_NAME
l_string|&quot;: match(): Existing table entry. (hr: %d,ha: %u)&bslash;n&quot;
comma
id|hash_result
comma
id|addr
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* Existing item found */
id|location
op_assign
id|hash_table
(braket
id|hash_result
)braket
suffix:semicolon
multiline_comment|/* We have a match on address, now to make sure it meets all requirements for a&n;&t;&t; * full match. */
r_if
c_cond
(paren
id|info-&gt;check_set
op_amp
id|IPT_RECENT_CHECK
op_logical_or
id|info-&gt;check_set
op_amp
id|IPT_RECENT_UPDATE
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|info-&gt;seconds
op_logical_and
op_logical_neg
id|info-&gt;hit_count
)paren
(brace
id|ans
op_assign
op_logical_neg
id|info-&gt;invert
suffix:semicolon
)brace
r_else
id|ans
op_assign
id|info-&gt;invert
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;seconds
op_logical_and
op_logical_neg
id|info-&gt;hit_count
)paren
(brace
r_if
c_cond
(paren
id|time_before_eq
c_func
(paren
id|now
comma
id|r_list
(braket
id|location
)braket
dot
id|last_seen
op_plus
id|info-&gt;seconds
op_star
id|HZ
)paren
)paren
(brace
id|ans
op_assign
op_logical_neg
id|info-&gt;invert
suffix:semicolon
)brace
r_else
id|ans
op_assign
id|info-&gt;invert
suffix:semicolon
)brace
r_if
c_cond
(paren
id|info-&gt;seconds
op_logical_and
id|info-&gt;hit_count
)paren
(brace
r_for
c_loop
(paren
id|pkt_count
op_assign
l_int|0
comma
id|hits_found
op_assign
l_int|0
suffix:semicolon
id|pkt_count
OL
id|ip_pkt_list_tot
suffix:semicolon
id|pkt_count
op_increment
)paren
(brace
r_if
c_cond
(paren
id|time_before_eq
c_func
(paren
id|now
comma
id|r_list
(braket
id|location
)braket
dot
id|last_pkts
(braket
id|pkt_count
)braket
op_plus
id|info-&gt;seconds
op_star
id|HZ
)paren
)paren
(brace
id|hits_found
op_increment
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|hits_found
op_ge
id|info-&gt;hit_count
)paren
(brace
id|ans
op_assign
op_logical_neg
id|info-&gt;invert
suffix:semicolon
)brace
r_else
id|ans
op_assign
id|info-&gt;invert
suffix:semicolon
)brace
r_if
c_cond
(paren
id|info-&gt;hit_count
op_logical_and
op_logical_neg
id|info-&gt;seconds
)paren
(brace
r_for
c_loop
(paren
id|pkt_count
op_assign
l_int|0
comma
id|hits_found
op_assign
l_int|0
suffix:semicolon
id|pkt_count
OL
id|ip_pkt_list_tot
suffix:semicolon
id|pkt_count
op_increment
)paren
(brace
r_if
c_cond
(paren
id|r_list
(braket
id|location
)braket
dot
id|last_pkts
(braket
id|pkt_count
)braket
op_eq
l_int|0
)paren
(brace
r_break
suffix:semicolon
)brace
id|hits_found
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hits_found
op_ge
id|info-&gt;hit_count
)paren
(brace
id|ans
op_assign
op_logical_neg
id|info-&gt;invert
suffix:semicolon
)brace
r_else
id|ans
op_assign
id|info-&gt;invert
suffix:semicolon
)brace
)brace
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
id|debug
)paren
(brace
r_if
c_cond
(paren
id|ans
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
id|RECENT_NAME
l_string|&quot;: match(): match addr: %u&bslash;n&quot;
comma
id|addr
)paren
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
id|KERN_INFO
id|RECENT_NAME
l_string|&quot;: match(): no match addr: %u&bslash;n&quot;
comma
id|addr
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* If and only if we have been asked to SET, or to UPDATE (on match) do we add the&n;&t;&t; * current timestamp to the last_seen. */
r_if
c_cond
(paren
(paren
id|info-&gt;check_set
op_amp
id|IPT_RECENT_SET
op_logical_and
(paren
id|ans
op_assign
op_logical_neg
id|info-&gt;invert
)paren
)paren
op_logical_or
(paren
id|info-&gt;check_set
op_amp
id|IPT_RECENT_UPDATE
op_logical_and
id|ans
)paren
)paren
(brace
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
id|debug
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
id|RECENT_NAME
l_string|&quot;: match(): SET or UPDATE; updating time info.&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* Have to update our time info */
id|time_loc
op_assign
id|r_list
(braket
id|location
)braket
dot
id|time_pos
suffix:semicolon
id|time_info
(braket
id|time_loc
)braket
dot
id|time
op_assign
id|now
suffix:semicolon
id|time_info
(braket
id|time_loc
)braket
dot
id|position
op_assign
id|location
suffix:semicolon
r_while
c_loop
(paren
(paren
id|time_info
(braket
(paren
id|time_loc
op_plus
l_int|1
)paren
op_mod
id|ip_list_tot
)braket
dot
id|time
OL
id|time_info
(braket
id|time_loc
)braket
dot
id|time
)paren
op_logical_and
(paren
(paren
id|time_loc
op_plus
l_int|1
)paren
op_mod
id|ip_list_tot
)paren
op_ne
id|curr_table-&gt;time_pos
)paren
(brace
id|time_temp
op_assign
id|time_info
(braket
id|time_loc
)braket
dot
id|time
suffix:semicolon
id|time_info
(braket
id|time_loc
)braket
dot
id|time
op_assign
id|time_info
(braket
(paren
id|time_loc
op_plus
l_int|1
)paren
op_mod
id|ip_list_tot
)braket
dot
id|time
suffix:semicolon
id|time_info
(braket
(paren
id|time_loc
op_plus
l_int|1
)paren
op_mod
id|ip_list_tot
)braket
dot
id|time
op_assign
id|time_temp
suffix:semicolon
id|time_temp
op_assign
id|time_info
(braket
id|time_loc
)braket
dot
id|position
suffix:semicolon
id|time_info
(braket
id|time_loc
)braket
dot
id|position
op_assign
id|time_info
(braket
(paren
id|time_loc
op_plus
l_int|1
)paren
op_mod
id|ip_list_tot
)braket
dot
id|position
suffix:semicolon
id|time_info
(braket
(paren
id|time_loc
op_plus
l_int|1
)paren
op_mod
id|ip_list_tot
)braket
dot
id|position
op_assign
id|time_temp
suffix:semicolon
id|r_list
(braket
id|time_info
(braket
id|time_loc
)braket
dot
id|position
)braket
dot
id|time_pos
op_assign
id|time_loc
suffix:semicolon
id|r_list
(braket
id|time_info
(braket
(paren
id|time_loc
op_plus
l_int|1
)paren
op_mod
id|ip_list_tot
)braket
dot
id|position
)braket
dot
id|time_pos
op_assign
(paren
id|time_loc
op_plus
l_int|1
)paren
op_mod
id|ip_list_tot
suffix:semicolon
id|time_loc
op_assign
(paren
id|time_loc
op_plus
l_int|1
)paren
op_mod
id|ip_list_tot
suffix:semicolon
)brace
id|r_list
(braket
id|location
)braket
dot
id|time_pos
op_assign
id|time_loc
suffix:semicolon
id|r_list
(braket
id|location
)braket
dot
id|ttl
op_assign
id|ttl
suffix:semicolon
id|r_list
(braket
id|location
)braket
dot
id|last_pkts
(braket
id|r_list
(braket
id|location
)braket
dot
id|oldest_pkt
)braket
op_assign
id|now
suffix:semicolon
id|r_list
(braket
id|location
)braket
dot
id|oldest_pkt
op_assign
op_increment
id|r_list
(braket
id|location
)braket
dot
id|oldest_pkt
op_mod
id|ip_pkt_list_tot
suffix:semicolon
id|r_list
(braket
id|location
)braket
dot
id|last_seen
op_assign
id|now
suffix:semicolon
)brace
multiline_comment|/* If we have been asked to remove the entry from the list, just set it to 0 */
r_if
c_cond
(paren
id|info-&gt;check_set
op_amp
id|IPT_RECENT_REMOVE
)paren
(brace
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
id|debug
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
id|RECENT_NAME
l_string|&quot;: match(): REMOVE; clearing entry (or: %d, hr: %d).&bslash;n&quot;
comma
id|orig_hash_result
comma
id|hash_result
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* Check if this is part of a collision chain */
r_while
c_loop
(paren
id|hash_table
(braket
(paren
id|orig_hash_result
op_plus
l_int|1
)paren
op_mod
id|ip_list_hash_size
)braket
op_ne
op_minus
l_int|1
)paren
(brace
id|orig_hash_result
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|hash_func
c_func
(paren
id|r_list
(braket
id|hash_table
(braket
id|orig_hash_result
)braket
)braket
dot
id|addr
comma
id|ip_list_hash_size
)paren
op_eq
id|hash_result
)paren
(brace
multiline_comment|/* Found collision chain, how deep does this rabbit hole go? */
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
id|debug
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
id|RECENT_NAME
l_string|&quot;: match(): REMOVE; found collision chain.&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
id|end_collision_chain
op_assign
id|orig_hash_result
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|end_collision_chain
op_ne
op_minus
l_int|1
)paren
(brace
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
id|debug
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
id|RECENT_NAME
l_string|&quot;: match(): REMOVE; part of collision chain, moving to end.&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* Part of a collision chain, swap it with the end of the chain&n;&t;&t;&t;&t; * before removing. */
id|r_list
(braket
id|hash_table
(braket
id|end_collision_chain
)braket
)braket
dot
id|hash_entry
op_assign
id|hash_result
suffix:semicolon
id|temp
op_assign
id|hash_table
(braket
id|end_collision_chain
)braket
suffix:semicolon
id|hash_table
(braket
id|end_collision_chain
)braket
op_assign
id|hash_table
(braket
id|hash_result
)braket
suffix:semicolon
id|hash_table
(braket
id|hash_result
)braket
op_assign
id|temp
suffix:semicolon
id|time_info
(braket
id|r_list
(braket
id|hash_table
(braket
id|hash_result
)braket
)braket
dot
id|time_pos
)braket
dot
id|position
op_assign
id|hash_table
(braket
id|hash_result
)braket
suffix:semicolon
id|hash_result
op_assign
id|end_collision_chain
suffix:semicolon
id|r_list
(braket
id|hash_table
(braket
id|hash_result
)braket
)braket
dot
id|hash_entry
op_assign
id|hash_result
suffix:semicolon
id|time_info
(braket
id|r_list
(braket
id|hash_table
(braket
id|hash_result
)braket
)braket
dot
id|time_pos
)braket
dot
id|position
op_assign
id|hash_table
(braket
id|hash_result
)braket
suffix:semicolon
)brace
id|location
op_assign
id|hash_table
(braket
id|hash_result
)braket
suffix:semicolon
id|hash_table
(braket
id|r_list
(braket
id|location
)braket
dot
id|hash_entry
)braket
op_assign
op_minus
l_int|1
suffix:semicolon
id|time_loc
op_assign
id|r_list
(braket
id|location
)braket
dot
id|time_pos
suffix:semicolon
id|time_info
(braket
id|time_loc
)braket
dot
id|time
op_assign
l_int|0
suffix:semicolon
id|time_info
(braket
id|time_loc
)braket
dot
id|position
op_assign
id|location
suffix:semicolon
r_while
c_loop
(paren
(paren
id|time_info
(braket
(paren
id|time_loc
op_plus
l_int|1
)paren
op_mod
id|ip_list_tot
)braket
dot
id|time
OL
id|time_info
(braket
id|time_loc
)braket
dot
id|time
)paren
op_logical_and
(paren
(paren
id|time_loc
op_plus
l_int|1
)paren
op_mod
id|ip_list_tot
)paren
op_ne
id|curr_table-&gt;time_pos
)paren
(brace
id|time_temp
op_assign
id|time_info
(braket
id|time_loc
)braket
dot
id|time
suffix:semicolon
id|time_info
(braket
id|time_loc
)braket
dot
id|time
op_assign
id|time_info
(braket
(paren
id|time_loc
op_plus
l_int|1
)paren
op_mod
id|ip_list_tot
)braket
dot
id|time
suffix:semicolon
id|time_info
(braket
(paren
id|time_loc
op_plus
l_int|1
)paren
op_mod
id|ip_list_tot
)braket
dot
id|time
op_assign
id|time_temp
suffix:semicolon
id|time_temp
op_assign
id|time_info
(braket
id|time_loc
)braket
dot
id|position
suffix:semicolon
id|time_info
(braket
id|time_loc
)braket
dot
id|position
op_assign
id|time_info
(braket
(paren
id|time_loc
op_plus
l_int|1
)paren
op_mod
id|ip_list_tot
)braket
dot
id|position
suffix:semicolon
id|time_info
(braket
(paren
id|time_loc
op_plus
l_int|1
)paren
op_mod
id|ip_list_tot
)braket
dot
id|position
op_assign
id|time_temp
suffix:semicolon
id|r_list
(braket
id|time_info
(braket
id|time_loc
)braket
dot
id|position
)braket
dot
id|time_pos
op_assign
id|time_loc
suffix:semicolon
id|r_list
(braket
id|time_info
(braket
(paren
id|time_loc
op_plus
l_int|1
)paren
op_mod
id|ip_list_tot
)braket
dot
id|position
)braket
dot
id|time_pos
op_assign
(paren
id|time_loc
op_plus
l_int|1
)paren
op_mod
id|ip_list_tot
suffix:semicolon
id|time_loc
op_assign
(paren
id|time_loc
op_plus
l_int|1
)paren
op_mod
id|ip_list_tot
suffix:semicolon
)brace
id|r_list
(braket
id|location
)braket
dot
id|time_pos
op_assign
id|time_loc
suffix:semicolon
id|r_list
(braket
id|location
)braket
dot
id|last_seen
op_assign
l_int|0
suffix:semicolon
id|r_list
(braket
id|location
)braket
dot
id|addr
op_assign
l_int|0
suffix:semicolon
id|r_list
(braket
id|location
)braket
dot
id|ttl
op_assign
l_int|0
suffix:semicolon
id|memset
c_func
(paren
id|r_list
(braket
id|location
)braket
dot
id|last_pkts
comma
l_int|0
comma
id|ip_pkt_list_tot
op_star
r_sizeof
(paren
id|u_int32_t
)paren
)paren
suffix:semicolon
id|r_list
(braket
id|location
)braket
dot
id|oldest_pkt
op_assign
l_int|0
suffix:semicolon
id|ans
op_assign
op_logical_neg
id|info-&gt;invert
suffix:semicolon
)brace
id|spin_unlock_bh
c_func
(paren
op_amp
id|curr_table-&gt;list_lock
)paren
suffix:semicolon
r_return
id|ans
suffix:semicolon
)brace
id|spin_unlock_bh
c_func
(paren
op_amp
id|curr_table-&gt;list_lock
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
id|debug
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
id|RECENT_NAME
l_string|&quot;: match() left.&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
r_return
id|ans
suffix:semicolon
)brace
multiline_comment|/* This function is to verify that the rule given during the userspace iptables&n; * command is correct.&n; * If the command is valid then we check if the table name referred to by the&n; * rule exists, if not it is created.&n; */
r_static
r_int
DECL|function|checkentry
id|checkentry
c_func
(paren
r_const
r_char
op_star
id|tablename
comma
r_const
r_struct
id|ipt_ip
op_star
id|ip
comma
r_void
op_star
id|matchinfo
comma
r_int
r_int
id|matchsize
comma
r_int
r_int
id|hook_mask
)paren
(brace
r_int
id|flag
op_assign
l_int|0
comma
id|c
suffix:semicolon
r_int
r_int
op_star
id|hold
suffix:semicolon
r_const
r_struct
id|ipt_recent_info
op_star
id|info
op_assign
id|matchinfo
suffix:semicolon
r_struct
id|recent_ip_tables
op_star
id|curr_table
comma
op_star
id|find_table
comma
op_star
id|last_table
suffix:semicolon
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
id|debug
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
id|RECENT_NAME
l_string|&quot;: checkentry() entered.&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|matchsize
op_ne
id|IPT_ALIGN
c_func
(paren
r_sizeof
(paren
r_struct
id|ipt_recent_info
)paren
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* seconds and hit_count only valid for CHECK/UPDATE */
r_if
c_cond
(paren
id|info-&gt;check_set
op_amp
id|IPT_RECENT_SET
)paren
(brace
id|flag
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;seconds
op_logical_or
id|info-&gt;hit_count
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|info-&gt;check_set
op_amp
id|IPT_RECENT_REMOVE
)paren
(brace
id|flag
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;seconds
op_logical_or
id|info-&gt;hit_count
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|info-&gt;check_set
op_amp
id|IPT_RECENT_CHECK
)paren
(brace
id|flag
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|info-&gt;check_set
op_amp
id|IPT_RECENT_UPDATE
)paren
(brace
id|flag
op_increment
suffix:semicolon
)brace
multiline_comment|/* One and only one of these should ever be set */
r_if
c_cond
(paren
id|flag
op_ne
l_int|1
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Name must be set to something */
r_if
c_cond
(paren
op_logical_neg
id|info-&gt;name
op_logical_or
op_logical_neg
id|info-&gt;name
(braket
l_int|0
)braket
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Things look good, create a list for this if it does not exist */
multiline_comment|/* Lock the linked list while we play with it */
id|spin_lock_bh
c_func
(paren
op_amp
id|recent_lock
)paren
suffix:semicolon
multiline_comment|/* Look for an entry with this name already created */
multiline_comment|/* Finds the end of the list and the entry before the end if current name does not exist */
id|find_table
op_assign
id|r_tables
suffix:semicolon
r_while
c_loop
(paren
(paren
id|last_table
op_assign
id|find_table
)paren
op_logical_and
id|strncmp
c_func
(paren
id|info-&gt;name
comma
id|find_table-&gt;name
comma
id|IPT_RECENT_NAME_LEN
)paren
op_logical_and
(paren
id|find_table
op_assign
id|find_table-&gt;next
)paren
)paren
(brace
suffix:semicolon
)brace
multiline_comment|/* If a table already exists just increment the count on that table and return */
r_if
c_cond
(paren
id|find_table
)paren
(brace
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
id|debug
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
id|RECENT_NAME
l_string|&quot;: checkentry: table found (%s), incrementing count.&bslash;n&quot;
comma
id|info-&gt;name
)paren
suffix:semicolon
)brace
macro_line|#endif
id|find_table-&gt;count
op_increment
suffix:semicolon
id|spin_unlock_bh
c_func
(paren
op_amp
id|recent_lock
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|spin_unlock_bh
c_func
(paren
op_amp
id|recent_lock
)paren
suffix:semicolon
multiline_comment|/* Table with this name not found */
multiline_comment|/* Allocate memory for new linked list item */
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
id|debug
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
id|RECENT_NAME
l_string|&quot;: checkentry: no table found (%s)&bslash;n&quot;
comma
id|info-&gt;name
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
id|RECENT_NAME
l_string|&quot;: checkentry: Allocationg %d for link-list entry.&bslash;n&quot;
comma
r_sizeof
(paren
r_struct
id|recent_ip_tables
)paren
)paren
suffix:semicolon
)brace
macro_line|#endif
id|curr_table
op_assign
id|vmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|recent_ip_tables
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|curr_table
op_eq
l_int|NULL
)paren
(brace
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|curr_table-&gt;list_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
id|curr_table-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|curr_table-&gt;count
op_assign
l_int|1
suffix:semicolon
id|curr_table-&gt;time_pos
op_assign
l_int|0
suffix:semicolon
id|strncpy
c_func
(paren
id|curr_table-&gt;name
comma
id|info-&gt;name
comma
id|IPT_RECENT_NAME_LEN
)paren
suffix:semicolon
id|curr_table-&gt;name
(braket
id|IPT_RECENT_NAME_LEN
op_minus
l_int|1
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
multiline_comment|/* Allocate memory for this table and the list of packets in each entry. */
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
id|debug
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
id|RECENT_NAME
l_string|&quot;: checkentry: Allocating %d for table (%s).&bslash;n&quot;
comma
r_sizeof
(paren
r_struct
id|recent_ip_list
)paren
op_star
id|ip_list_tot
comma
id|info-&gt;name
)paren
suffix:semicolon
)brace
macro_line|#endif
id|curr_table-&gt;table
op_assign
id|vmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|recent_ip_list
)paren
op_star
id|ip_list_tot
)paren
suffix:semicolon
r_if
c_cond
(paren
id|curr_table-&gt;table
op_eq
l_int|NULL
)paren
(brace
id|vfree
c_func
(paren
id|curr_table
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|memset
c_func
(paren
id|curr_table-&gt;table
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|recent_ip_list
)paren
op_star
id|ip_list_tot
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
id|debug
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
id|RECENT_NAME
l_string|&quot;: checkentry: Allocating %d for pkt_list.&bslash;n&quot;
comma
r_sizeof
(paren
id|u_int32_t
)paren
op_star
id|ip_pkt_list_tot
op_star
id|ip_list_tot
)paren
suffix:semicolon
)brace
macro_line|#endif
id|hold
op_assign
id|vmalloc
c_func
(paren
r_sizeof
(paren
id|u_int32_t
)paren
op_star
id|ip_pkt_list_tot
op_star
id|ip_list_tot
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
id|debug
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
id|RECENT_NAME
l_string|&quot;: checkentry: After pkt_list allocation.&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|hold
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
id|RECENT_NAME
l_string|&quot;: checkentry: unable to allocate for pkt_list.&bslash;n&quot;
)paren
suffix:semicolon
id|vfree
c_func
(paren
id|curr_table-&gt;table
)paren
suffix:semicolon
id|vfree
c_func
(paren
id|curr_table
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_for
c_loop
(paren
id|c
op_assign
l_int|0
suffix:semicolon
id|c
OL
id|ip_list_tot
suffix:semicolon
id|c
op_increment
)paren
(brace
id|curr_table-&gt;table
(braket
id|c
)braket
dot
id|last_pkts
op_assign
id|hold
op_plus
id|c
op_star
id|ip_pkt_list_tot
suffix:semicolon
)brace
multiline_comment|/* Allocate memory for the hash table */
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
id|debug
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
id|RECENT_NAME
l_string|&quot;: checkentry: Allocating %d for hash_table.&bslash;n&quot;
comma
r_sizeof
(paren
r_int
)paren
op_star
id|ip_list_hash_size
)paren
suffix:semicolon
)brace
macro_line|#endif
id|curr_table-&gt;hash_table
op_assign
id|vmalloc
c_func
(paren
r_sizeof
(paren
r_int
)paren
op_star
id|ip_list_hash_size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|curr_table-&gt;hash_table
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
id|RECENT_NAME
l_string|&quot;: checkentry: unable to allocate for hash_table.&bslash;n&quot;
)paren
suffix:semicolon
id|vfree
c_func
(paren
id|hold
)paren
suffix:semicolon
id|vfree
c_func
(paren
id|curr_table-&gt;table
)paren
suffix:semicolon
id|vfree
c_func
(paren
id|curr_table
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_for
c_loop
(paren
id|c
op_assign
l_int|0
suffix:semicolon
id|c
OL
id|ip_list_hash_size
suffix:semicolon
id|c
op_increment
)paren
(brace
id|curr_table-&gt;hash_table
(braket
id|c
)braket
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Allocate memory for the time info */
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
id|debug
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
id|RECENT_NAME
l_string|&quot;: checkentry: Allocating %d for time_info.&bslash;n&quot;
comma
r_sizeof
(paren
r_struct
id|time_info_list
)paren
op_star
id|ip_list_tot
)paren
suffix:semicolon
)brace
macro_line|#endif
id|curr_table-&gt;time_info
op_assign
id|vmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|time_info_list
)paren
op_star
id|ip_list_tot
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|curr_table-&gt;time_info
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
id|RECENT_NAME
l_string|&quot;: checkentry: unable to allocate for time_info.&bslash;n&quot;
)paren
suffix:semicolon
id|vfree
c_func
(paren
id|curr_table-&gt;hash_table
)paren
suffix:semicolon
id|vfree
c_func
(paren
id|hold
)paren
suffix:semicolon
id|vfree
c_func
(paren
id|curr_table-&gt;table
)paren
suffix:semicolon
id|vfree
c_func
(paren
id|curr_table
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_for
c_loop
(paren
id|c
op_assign
l_int|0
suffix:semicolon
id|c
OL
id|ip_list_tot
suffix:semicolon
id|c
op_increment
)paren
(brace
id|curr_table-&gt;time_info
(braket
id|c
)braket
dot
id|position
op_assign
id|c
suffix:semicolon
id|curr_table-&gt;time_info
(braket
id|c
)braket
dot
id|time
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Put the new table in place */
id|spin_lock_bh
c_func
(paren
op_amp
id|recent_lock
)paren
suffix:semicolon
id|find_table
op_assign
id|r_tables
suffix:semicolon
r_while
c_loop
(paren
(paren
id|last_table
op_assign
id|find_table
)paren
op_logical_and
id|strncmp
c_func
(paren
id|info-&gt;name
comma
id|find_table-&gt;name
comma
id|IPT_RECENT_NAME_LEN
)paren
op_logical_and
(paren
id|find_table
op_assign
id|find_table-&gt;next
)paren
)paren
(brace
suffix:semicolon
)brace
multiline_comment|/* If a table already exists just increment the count on that table and return */
r_if
c_cond
(paren
id|find_table
)paren
(brace
id|find_table-&gt;count
op_increment
suffix:semicolon
id|spin_unlock_bh
c_func
(paren
op_amp
id|recent_lock
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
id|debug
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
id|RECENT_NAME
l_string|&quot;: checkentry: table found (%s), created by other process.&bslash;n&quot;
comma
id|info-&gt;name
)paren
suffix:semicolon
)brace
macro_line|#endif
id|vfree
c_func
(paren
id|curr_table-&gt;time_info
)paren
suffix:semicolon
id|vfree
c_func
(paren
id|curr_table-&gt;hash_table
)paren
suffix:semicolon
id|vfree
c_func
(paren
id|hold
)paren
suffix:semicolon
id|vfree
c_func
(paren
id|curr_table-&gt;table
)paren
suffix:semicolon
id|vfree
c_func
(paren
id|curr_table
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|last_table
)paren
(brace
id|r_tables
op_assign
id|curr_table
suffix:semicolon
)brace
r_else
id|last_table-&gt;next
op_assign
id|curr_table
suffix:semicolon
id|spin_unlock_bh
c_func
(paren
op_amp
id|recent_lock
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_PROC_FS
multiline_comment|/* Create our proc &squot;status&squot; entry. */
id|curr_table-&gt;status_proc
op_assign
id|create_proc_entry
c_func
(paren
id|curr_table-&gt;name
comma
id|ip_list_perms
comma
id|proc_net_ipt_recent
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|curr_table-&gt;status_proc
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
id|RECENT_NAME
l_string|&quot;: checkentry: unable to allocate for /proc entry.&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Destroy the created table */
id|spin_lock_bh
c_func
(paren
op_amp
id|recent_lock
)paren
suffix:semicolon
id|last_table
op_assign
l_int|NULL
suffix:semicolon
id|curr_table
op_assign
id|r_tables
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|curr_table
)paren
(brace
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
id|debug
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
id|RECENT_NAME
l_string|&quot;: checkentry() create_proc failed, no tables.&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
id|spin_unlock_bh
c_func
(paren
op_amp
id|recent_lock
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_while
c_loop
(paren
id|strncmp
c_func
(paren
id|info-&gt;name
comma
id|curr_table-&gt;name
comma
id|IPT_RECENT_NAME_LEN
)paren
op_logical_and
(paren
id|last_table
op_assign
id|curr_table
)paren
op_logical_and
(paren
id|curr_table
op_assign
id|curr_table-&gt;next
)paren
)paren
(brace
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|curr_table
)paren
(brace
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
id|debug
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
id|RECENT_NAME
l_string|&quot;: checkentry() create_proc failed, table already destroyed.&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
id|spin_unlock_bh
c_func
(paren
op_amp
id|recent_lock
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_if
c_cond
(paren
id|last_table
)paren
(brace
id|last_table-&gt;next
op_assign
id|curr_table-&gt;next
suffix:semicolon
)brace
r_else
id|r_tables
op_assign
id|curr_table-&gt;next
suffix:semicolon
id|spin_unlock_bh
c_func
(paren
op_amp
id|recent_lock
)paren
suffix:semicolon
id|vfree
c_func
(paren
id|curr_table-&gt;time_info
)paren
suffix:semicolon
id|vfree
c_func
(paren
id|curr_table-&gt;hash_table
)paren
suffix:semicolon
id|vfree
c_func
(paren
id|hold
)paren
suffix:semicolon
id|vfree
c_func
(paren
id|curr_table-&gt;table
)paren
suffix:semicolon
id|vfree
c_func
(paren
id|curr_table
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|curr_table-&gt;status_proc-&gt;owner
op_assign
id|THIS_MODULE
suffix:semicolon
id|curr_table-&gt;status_proc-&gt;data
op_assign
id|curr_table
suffix:semicolon
id|wmb
c_func
(paren
)paren
suffix:semicolon
id|curr_table-&gt;status_proc-&gt;read_proc
op_assign
id|ip_recent_get_info
suffix:semicolon
id|curr_table-&gt;status_proc-&gt;write_proc
op_assign
id|ip_recent_ctrl
suffix:semicolon
macro_line|#endif /* CONFIG_PROC_FS */
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
id|debug
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
id|RECENT_NAME
l_string|&quot;: checkentry() left.&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* This function is called in the event that a rule matching this module is&n; * removed.&n; * When this happens we need to check if there are no other rules matching&n; * the table given.  If that is the case then we remove the table and clean&n; * up its memory.&n; */
r_static
r_void
DECL|function|destroy
id|destroy
c_func
(paren
r_void
op_star
id|matchinfo
comma
r_int
r_int
id|matchsize
)paren
(brace
r_const
r_struct
id|ipt_recent_info
op_star
id|info
op_assign
id|matchinfo
suffix:semicolon
r_struct
id|recent_ip_tables
op_star
id|curr_table
comma
op_star
id|last_table
suffix:semicolon
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
id|debug
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
id|RECENT_NAME
l_string|&quot;: destroy() entered.&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|matchsize
op_ne
id|IPT_ALIGN
c_func
(paren
r_sizeof
(paren
r_struct
id|ipt_recent_info
)paren
)paren
)paren
(brace
r_return
suffix:semicolon
)brace
multiline_comment|/* Lock the linked list while we play with it */
id|spin_lock_bh
c_func
(paren
op_amp
id|recent_lock
)paren
suffix:semicolon
multiline_comment|/* Look for an entry with this name already created */
multiline_comment|/* Finds the end of the list and the entry before the end if current name does not exist */
id|last_table
op_assign
l_int|NULL
suffix:semicolon
id|curr_table
op_assign
id|r_tables
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|curr_table
)paren
(brace
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
id|debug
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
id|RECENT_NAME
l_string|&quot;: destroy() No tables found, leaving.&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
id|spin_unlock_bh
c_func
(paren
op_amp
id|recent_lock
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_while
c_loop
(paren
id|strncmp
c_func
(paren
id|info-&gt;name
comma
id|curr_table-&gt;name
comma
id|IPT_RECENT_NAME_LEN
)paren
op_logical_and
(paren
id|last_table
op_assign
id|curr_table
)paren
op_logical_and
(paren
id|curr_table
op_assign
id|curr_table-&gt;next
)paren
)paren
(brace
suffix:semicolon
)brace
multiline_comment|/* If a table does not exist then do nothing and return */
r_if
c_cond
(paren
op_logical_neg
id|curr_table
)paren
(brace
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
id|debug
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
id|RECENT_NAME
l_string|&quot;: destroy() table not found, leaving.&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
id|spin_unlock_bh
c_func
(paren
op_amp
id|recent_lock
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|curr_table-&gt;count
op_decrement
suffix:semicolon
multiline_comment|/* If count is still non-zero then there are still rules referenceing it so we do nothing */
r_if
c_cond
(paren
id|curr_table-&gt;count
)paren
(brace
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
id|debug
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
id|RECENT_NAME
l_string|&quot;: destroy() table found, non-zero count, leaving.&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
id|spin_unlock_bh
c_func
(paren
op_amp
id|recent_lock
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
id|debug
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
id|RECENT_NAME
l_string|&quot;: destroy() table found, zero count, removing.&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* Count must be zero so we remove this table from the list */
r_if
c_cond
(paren
id|last_table
)paren
(brace
id|last_table-&gt;next
op_assign
id|curr_table-&gt;next
suffix:semicolon
)brace
r_else
id|r_tables
op_assign
id|curr_table-&gt;next
suffix:semicolon
id|spin_unlock_bh
c_func
(paren
op_amp
id|recent_lock
)paren
suffix:semicolon
multiline_comment|/* lock to make sure any late-runners still using this after we removed it from&n;&t; * the list finish up then remove everything */
id|spin_lock_bh
c_func
(paren
op_amp
id|curr_table-&gt;list_lock
)paren
suffix:semicolon
id|spin_unlock_bh
c_func
(paren
op_amp
id|curr_table-&gt;list_lock
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_PROC_FS
r_if
c_cond
(paren
id|curr_table-&gt;status_proc
)paren
(brace
id|remove_proc_entry
c_func
(paren
id|curr_table-&gt;name
comma
id|proc_net_ipt_recent
)paren
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_PROC_FS */
id|vfree
c_func
(paren
id|curr_table-&gt;table
(braket
l_int|0
)braket
dot
id|last_pkts
)paren
suffix:semicolon
id|vfree
c_func
(paren
id|curr_table-&gt;table
)paren
suffix:semicolon
id|vfree
c_func
(paren
id|curr_table-&gt;hash_table
)paren
suffix:semicolon
id|vfree
c_func
(paren
id|curr_table-&gt;time_info
)paren
suffix:semicolon
id|vfree
c_func
(paren
id|curr_table
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
id|debug
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
id|RECENT_NAME
l_string|&quot;: destroy() left.&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
r_return
suffix:semicolon
)brace
multiline_comment|/* This is the structure we pass to ipt_register to register our&n; * module with iptables.&n; */
DECL|variable|recent_match
r_static
r_struct
id|ipt_match
id|recent_match
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;recent&quot;
comma
dot
id|match
op_assign
op_amp
id|match
comma
dot
id|checkentry
op_assign
op_amp
id|checkentry
comma
dot
id|destroy
op_assign
op_amp
id|destroy
comma
dot
id|me
op_assign
id|THIS_MODULE
)brace
suffix:semicolon
multiline_comment|/* Kernel module initialization. */
DECL|function|init
r_static
r_int
id|__init
id|init
c_func
(paren
r_void
)paren
(brace
r_int
id|count
suffix:semicolon
id|printk
c_func
(paren
id|version
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_PROC_FS
id|proc_net_ipt_recent
op_assign
id|proc_mkdir
c_func
(paren
l_string|&quot;ipt_recent&quot;
comma
id|proc_net
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|proc_net_ipt_recent
)paren
(brace
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|ip_list_hash_size
op_logical_and
id|ip_list_hash_size
op_le
id|ip_list_tot
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
id|RECENT_NAME
l_string|&quot;: ip_list_hash_size too small, resetting to default.&bslash;n&quot;
)paren
suffix:semicolon
id|ip_list_hash_size
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|ip_list_hash_size
)paren
(brace
id|ip_list_hash_size
op_assign
id|ip_list_tot
op_star
l_int|3
suffix:semicolon
id|count
op_assign
l_int|2
op_star
l_int|2
suffix:semicolon
r_while
c_loop
(paren
id|ip_list_hash_size
OG
id|count
)paren
(brace
id|count
op_assign
id|count
op_star
l_int|2
suffix:semicolon
)brace
id|ip_list_hash_size
op_assign
id|count
suffix:semicolon
)brace
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
id|debug
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
id|RECENT_NAME
l_string|&quot;: ip_list_hash_size: %d&bslash;n&quot;
comma
id|ip_list_hash_size
)paren
suffix:semicolon
)brace
macro_line|#endif
r_return
id|ipt_register_match
c_func
(paren
op_amp
id|recent_match
)paren
suffix:semicolon
)brace
multiline_comment|/* Kernel module destruction. */
DECL|function|fini
r_static
r_void
id|__exit
id|fini
c_func
(paren
r_void
)paren
(brace
id|ipt_unregister_match
c_func
(paren
op_amp
id|recent_match
)paren
suffix:semicolon
id|remove_proc_entry
c_func
(paren
l_string|&quot;ipt_recent&quot;
comma
id|proc_net
)paren
suffix:semicolon
)brace
multiline_comment|/* Register our module with the kernel. */
DECL|variable|init
id|module_init
c_func
(paren
id|init
)paren
suffix:semicolon
DECL|variable|fini
id|module_exit
c_func
(paren
id|fini
)paren
suffix:semicolon
eof
