multiline_comment|/*&n; * Packet matching code for ARP packets.&n; *&n; * Based heavily, if not almost entirely, upon ip_tables.c framework.&n; *&n; * Some ARP specific bits are:&n; *&n; * Copyright (C) 2002 David S. Miller (davem@redhat.com)&n; *&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/if_arp.h&gt;
macro_line|#include &lt;linux/kmod.h&gt;
macro_line|#include &lt;linux/vmalloc.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/semaphore.h&gt;
macro_line|#include &lt;linux/netfilter_arp/arp_tables.h&gt;
multiline_comment|/*#define DEBUG_ARP_TABLES*/
multiline_comment|/*#define DEBUG_ARP_TABLES_USER*/
macro_line|#ifdef DEBUG_ARP_TABLES
DECL|macro|dprintf
mdefine_line|#define dprintf(format, args...)  printk(format , ## args)
macro_line|#else
DECL|macro|dprintf
mdefine_line|#define dprintf(format, args...)
macro_line|#endif
macro_line|#ifdef DEBUG_ARP_TABLES_USER
DECL|macro|duprintf
mdefine_line|#define duprintf(format, args...) printk(format , ## args)
macro_line|#else
DECL|macro|duprintf
mdefine_line|#define duprintf(format, args...)
macro_line|#endif
macro_line|#ifdef CONFIG_NETFILTER_DEBUG
DECL|macro|ARP_NF_ASSERT
mdefine_line|#define ARP_NF_ASSERT(x)&t;&t;&t;&t;&t;&bslash;&n;do {&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;if (!(x))&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;printk(&quot;ARP_NF_ASSERT: %s:%s:%u&bslash;n&quot;,&t;&t;&bslash;&n;&t;&t;       __FUNCTION__, __FILE__, __LINE__);&t;&bslash;&n;} while(0)
macro_line|#else
DECL|macro|ARP_NF_ASSERT
mdefine_line|#define ARP_NF_ASSERT(x)
macro_line|#endif
DECL|macro|SMP_ALIGN
mdefine_line|#define SMP_ALIGN(x) (((x) + SMP_CACHE_BYTES-1) &amp; ~(SMP_CACHE_BYTES-1))
r_static
id|DECLARE_MUTEX
c_func
(paren
id|arpt_mutex
)paren
suffix:semicolon
DECL|macro|ASSERT_READ_LOCK
mdefine_line|#define ASSERT_READ_LOCK(x) ARP_NF_ASSERT(down_trylock(&amp;arpt_mutex) != 0)
DECL|macro|ASSERT_WRITE_LOCK
mdefine_line|#define ASSERT_WRITE_LOCK(x) ARP_NF_ASSERT(down_trylock(&amp;arpt_mutex) != 0)
macro_line|#include &lt;linux/netfilter_ipv4/lockhelp.h&gt;
macro_line|#include &lt;linux/netfilter_ipv4/listhelp.h&gt;
DECL|struct|arpt_table_info
r_struct
id|arpt_table_info
(brace
DECL|member|size
r_int
r_int
id|size
suffix:semicolon
DECL|member|number
r_int
r_int
id|number
suffix:semicolon
DECL|member|initial_entries
r_int
r_int
id|initial_entries
suffix:semicolon
DECL|member|hook_entry
r_int
r_int
id|hook_entry
(braket
id|NF_ARP_NUMHOOKS
)braket
suffix:semicolon
DECL|member|underflow
r_int
r_int
id|underflow
(braket
id|NF_ARP_NUMHOOKS
)braket
suffix:semicolon
DECL|member|entries
r_char
id|entries
(braket
l_int|0
)braket
id|__attribute__
c_func
(paren
(paren
id|aligned
c_func
(paren
id|SMP_CACHE_BYTES
)paren
)paren
)paren
suffix:semicolon
)brace
suffix:semicolon
r_static
id|LIST_HEAD
c_func
(paren
id|arpt_target
)paren
suffix:semicolon
r_static
id|LIST_HEAD
c_func
(paren
id|arpt_tables
)paren
suffix:semicolon
DECL|macro|ADD_COUNTER
mdefine_line|#define ADD_COUNTER(c,b,p) do { (c).bcnt += (b); (c).pcnt += (p); } while(0)
macro_line|#ifdef CONFIG_SMP
DECL|macro|TABLE_OFFSET
mdefine_line|#define TABLE_OFFSET(t,p) (SMP_ALIGN((t)-&gt;size)*(p))
macro_line|#else
DECL|macro|TABLE_OFFSET
mdefine_line|#define TABLE_OFFSET(t,p) 0
macro_line|#endif
DECL|function|arp_devaddr_compare
r_static
r_inline
r_int
id|arp_devaddr_compare
c_func
(paren
r_const
r_struct
id|arpt_devaddr_info
op_star
id|ap
comma
r_char
op_star
id|hdr_addr
comma
r_int
id|len
)paren
(brace
r_int
id|i
comma
id|ret
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|ARPT_DEV_ADDR_LEN_MAX
)paren
id|len
op_assign
id|ARPT_DEV_ADDR_LEN_MAX
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
suffix:semicolon
id|i
op_increment
)paren
id|ret
op_or_assign
(paren
id|hdr_addr
(braket
id|i
)braket
op_xor
id|ap-&gt;addr
(braket
id|i
)braket
)paren
op_amp
id|ap-&gt;mask
(braket
id|i
)braket
suffix:semicolon
r_return
(paren
id|ret
op_ne
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* Returns whether packet matches rule or not. */
DECL|function|arp_packet_match
r_static
r_inline
r_int
id|arp_packet_match
c_func
(paren
r_const
r_struct
id|arphdr
op_star
id|arphdr
comma
r_struct
id|net_device
op_star
id|dev
comma
r_const
r_char
op_star
id|indev
comma
r_const
r_char
op_star
id|outdev
comma
r_const
r_struct
id|arpt_arp
op_star
id|arpinfo
)paren
(brace
r_char
op_star
id|arpptr
op_assign
(paren
r_char
op_star
)paren
(paren
id|arphdr
op_plus
l_int|1
)paren
suffix:semicolon
r_char
op_star
id|src_devaddr
comma
op_star
id|tgt_devaddr
suffix:semicolon
id|u32
op_star
id|src_ipaddr
comma
op_star
id|tgt_ipaddr
suffix:semicolon
r_int
id|i
comma
id|ret
suffix:semicolon
DECL|macro|FWINV
mdefine_line|#define FWINV(bool,invflg) ((bool) ^ !!(arpinfo-&gt;invflags &amp; invflg))
r_if
c_cond
(paren
id|FWINV
c_func
(paren
(paren
id|arphdr-&gt;ar_op
op_amp
id|arpinfo-&gt;arpop_mask
)paren
op_ne
id|arpinfo-&gt;arpop
comma
id|ARPT_INV_ARPOP
)paren
)paren
(brace
id|dprintf
c_func
(paren
l_string|&quot;ARP operation field mismatch.&bslash;n&quot;
)paren
suffix:semicolon
id|dprintf
c_func
(paren
l_string|&quot;ar_op: %04x info-&gt;arpop: %04x info-&gt;arpop_mask: %04x&bslash;n&quot;
comma
id|arphdr-&gt;ar_op
comma
id|arpinfo-&gt;arpop
comma
id|arpinfo-&gt;arpop_mask
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|FWINV
c_func
(paren
(paren
id|arphdr-&gt;ar_hrd
op_amp
id|arpinfo-&gt;arhrd_mask
)paren
op_ne
id|arpinfo-&gt;arhrd
comma
id|ARPT_INV_ARPHRD
)paren
)paren
(brace
id|dprintf
c_func
(paren
l_string|&quot;ARP hardware address format mismatch.&bslash;n&quot;
)paren
suffix:semicolon
id|dprintf
c_func
(paren
l_string|&quot;ar_hrd: %04x info-&gt;arhrd: %04x info-&gt;arhrd_mask: %04x&bslash;n&quot;
comma
id|arphdr-&gt;ar_hrd
comma
id|arpinfo-&gt;arhrd
comma
id|arpinfo-&gt;arhrd_mask
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|FWINV
c_func
(paren
(paren
id|arphdr-&gt;ar_pro
op_amp
id|arpinfo-&gt;arpro_mask
)paren
op_ne
id|arpinfo-&gt;arpro
comma
id|ARPT_INV_ARPPRO
)paren
)paren
(brace
id|dprintf
c_func
(paren
l_string|&quot;ARP protocol address format mismatch.&bslash;n&quot;
)paren
suffix:semicolon
id|dprintf
c_func
(paren
l_string|&quot;ar_pro: %04x info-&gt;arpro: %04x info-&gt;arpro_mask: %04x&bslash;n&quot;
comma
id|arphdr-&gt;ar_pro
comma
id|arpinfo-&gt;arpro
comma
id|arpinfo-&gt;arpro_mask
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|FWINV
c_func
(paren
(paren
id|arphdr-&gt;ar_hln
op_amp
id|arpinfo-&gt;arhln_mask
)paren
op_ne
id|arpinfo-&gt;arhln
comma
id|ARPT_INV_ARPHLN
)paren
)paren
(brace
id|dprintf
c_func
(paren
l_string|&quot;ARP hardware address length mismatch.&bslash;n&quot;
)paren
suffix:semicolon
id|dprintf
c_func
(paren
l_string|&quot;ar_hln: %02x info-&gt;arhln: %02x info-&gt;arhln_mask: %02x&bslash;n&quot;
comma
id|arphdr-&gt;ar_hln
comma
id|arpinfo-&gt;arhln
comma
id|arpinfo-&gt;arhln_mask
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|src_devaddr
op_assign
id|arpptr
suffix:semicolon
id|arpptr
op_add_assign
id|dev-&gt;addr_len
suffix:semicolon
id|src_ipaddr
op_assign
(paren
id|u32
op_star
)paren
id|arpptr
suffix:semicolon
id|arpptr
op_add_assign
r_sizeof
(paren
id|u32
)paren
suffix:semicolon
id|tgt_devaddr
op_assign
id|arpptr
suffix:semicolon
id|arpptr
op_add_assign
id|dev-&gt;addr_len
suffix:semicolon
id|tgt_ipaddr
op_assign
(paren
id|u32
op_star
)paren
id|arpptr
suffix:semicolon
r_if
c_cond
(paren
id|FWINV
c_func
(paren
id|arp_devaddr_compare
c_func
(paren
op_amp
id|arpinfo-&gt;src_devaddr
comma
id|src_devaddr
comma
id|dev-&gt;addr_len
)paren
comma
id|ARPT_INV_SRCDEVADDR
)paren
op_logical_or
id|FWINV
c_func
(paren
id|arp_devaddr_compare
c_func
(paren
op_amp
id|arpinfo-&gt;tgt_devaddr
comma
id|tgt_devaddr
comma
id|dev-&gt;addr_len
)paren
comma
id|ARPT_INV_TGTDEVADDR
)paren
)paren
(brace
id|dprintf
c_func
(paren
l_string|&quot;Source or target device address mismatch.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|FWINV
c_func
(paren
(paren
(paren
op_star
id|src_ipaddr
)paren
op_amp
id|arpinfo-&gt;smsk.s_addr
)paren
op_ne
id|arpinfo-&gt;src.s_addr
comma
id|ARPT_INV_SRCIP
)paren
op_logical_or
id|FWINV
c_func
(paren
(paren
(paren
(paren
op_star
id|tgt_ipaddr
)paren
op_amp
id|arpinfo-&gt;tmsk.s_addr
)paren
op_ne
id|arpinfo-&gt;tgt.s_addr
)paren
comma
id|ARPT_INV_TGTIP
)paren
)paren
(brace
id|dprintf
c_func
(paren
l_string|&quot;Source or target IP address mismatch.&bslash;n&quot;
)paren
suffix:semicolon
id|dprintf
c_func
(paren
l_string|&quot;SRC: %u.%u.%u.%u. Mask: %u.%u.%u.%u. Target: %u.%u.%u.%u.%s&bslash;n&quot;
comma
id|NIPQUAD
c_func
(paren
op_star
id|src_ipaddr
)paren
comma
id|NIPQUAD
c_func
(paren
id|arpinfo-&gt;smsk.s_addr
)paren
comma
id|NIPQUAD
c_func
(paren
id|arpinfo-&gt;src.s_addr
)paren
comma
id|arpinfo-&gt;invflags
op_amp
id|ARPT_INV_SRCIP
ques
c_cond
l_string|&quot; (INV)&quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
id|dprintf
c_func
(paren
l_string|&quot;TGT: %u.%u.%u.%u Mask: %u.%u.%u.%u Target: %u.%u.%u.%u.%s&bslash;n&quot;
comma
id|NIPQUAD
c_func
(paren
op_star
id|tgt_ipaddr
)paren
comma
id|NIPQUAD
c_func
(paren
id|arpinfo-&gt;tmsk.s_addr
)paren
comma
id|NIPQUAD
c_func
(paren
id|arpinfo-&gt;tgt.s_addr
)paren
comma
id|arpinfo-&gt;invflags
op_amp
id|ARPT_INV_TGTIP
ques
c_cond
l_string|&quot; (INV)&quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Look for ifname matches; this should unroll nicely. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|ret
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|IFNAMSIZ
op_div
r_sizeof
(paren
r_int
r_int
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|ret
op_or_assign
(paren
(paren
(paren
r_const
r_int
r_int
op_star
)paren
id|indev
)paren
(braket
id|i
)braket
op_xor
(paren
(paren
r_const
r_int
r_int
op_star
)paren
id|arpinfo-&gt;iniface
)paren
(braket
id|i
)braket
)paren
op_amp
(paren
(paren
r_const
r_int
r_int
op_star
)paren
id|arpinfo-&gt;iniface_mask
)paren
(braket
id|i
)braket
suffix:semicolon
)brace
r_if
c_cond
(paren
id|FWINV
c_func
(paren
id|ret
op_ne
l_int|0
comma
id|ARPT_INV_VIA_IN
)paren
)paren
(brace
id|dprintf
c_func
(paren
l_string|&quot;VIA in mismatch (%s vs %s).%s&bslash;n&quot;
comma
id|indev
comma
id|arpinfo-&gt;iniface
comma
id|arpinfo-&gt;invflags
op_amp
id|ARPT_INV_VIA_IN
ques
c_cond
l_string|&quot; (INV)&quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|ret
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|IFNAMSIZ
op_div
r_sizeof
(paren
r_int
r_int
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|ret
op_or_assign
(paren
(paren
(paren
r_const
r_int
r_int
op_star
)paren
id|outdev
)paren
(braket
id|i
)braket
op_xor
(paren
(paren
r_const
r_int
r_int
op_star
)paren
id|arpinfo-&gt;outiface
)paren
(braket
id|i
)braket
)paren
op_amp
(paren
(paren
r_const
r_int
r_int
op_star
)paren
id|arpinfo-&gt;outiface_mask
)paren
(braket
id|i
)braket
suffix:semicolon
)brace
r_if
c_cond
(paren
id|FWINV
c_func
(paren
id|ret
op_ne
l_int|0
comma
id|ARPT_INV_VIA_OUT
)paren
)paren
(brace
id|dprintf
c_func
(paren
l_string|&quot;VIA out mismatch (%s vs %s).%s&bslash;n&quot;
comma
id|outdev
comma
id|arpinfo-&gt;outiface
comma
id|arpinfo-&gt;invflags
op_amp
id|ARPT_INV_VIA_OUT
ques
c_cond
l_string|&quot; (INV)&quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|arp_checkentry
r_static
r_inline
r_int
id|arp_checkentry
c_func
(paren
r_const
r_struct
id|arpt_arp
op_star
id|arp
)paren
(brace
r_if
c_cond
(paren
id|arp-&gt;flags
op_amp
op_complement
id|ARPT_F_MASK
)paren
(brace
id|duprintf
c_func
(paren
l_string|&quot;Unknown flag bits set: %08X&bslash;n&quot;
comma
id|arp-&gt;flags
op_amp
op_complement
id|ARPT_F_MASK
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|arp-&gt;invflags
op_amp
op_complement
id|ARPT_INV_MASK
)paren
(brace
id|duprintf
c_func
(paren
l_string|&quot;Unknown invflag bits set: %08X&bslash;n&quot;
comma
id|arp-&gt;invflags
op_amp
op_complement
id|ARPT_INV_MASK
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|arpt_error
r_static
r_int
r_int
id|arpt_error
c_func
(paren
r_struct
id|sk_buff
op_star
op_star
id|pskb
comma
r_int
r_int
id|hooknum
comma
r_const
r_struct
id|net_device
op_star
id|in
comma
r_const
r_struct
id|net_device
op_star
id|out
comma
r_const
r_void
op_star
id|targinfo
comma
r_void
op_star
id|userinfo
)paren
(brace
r_if
c_cond
(paren
id|net_ratelimit
c_func
(paren
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;arp_tables: error: &squot;%s&squot;&bslash;n&quot;
comma
(paren
r_char
op_star
)paren
id|targinfo
)paren
suffix:semicolon
r_return
id|NF_DROP
suffix:semicolon
)brace
DECL|function|get_entry
r_static
r_inline
r_struct
id|arpt_entry
op_star
id|get_entry
c_func
(paren
r_void
op_star
id|base
comma
r_int
r_int
id|offset
)paren
(brace
r_return
(paren
r_struct
id|arpt_entry
op_star
)paren
(paren
id|base
op_plus
id|offset
)paren
suffix:semicolon
)brace
DECL|function|arpt_do_table
r_int
r_int
id|arpt_do_table
c_func
(paren
r_struct
id|sk_buff
op_star
op_star
id|pskb
comma
r_int
r_int
id|hook
comma
r_const
r_struct
id|net_device
op_star
id|in
comma
r_const
r_struct
id|net_device
op_star
id|out
comma
r_struct
id|arpt_table
op_star
id|table
comma
r_void
op_star
id|userdata
)paren
(brace
r_static
r_const
r_char
id|nulldevname
(braket
id|IFNAMSIZ
)braket
suffix:semicolon
r_int
r_int
id|verdict
op_assign
id|NF_DROP
suffix:semicolon
r_struct
id|arphdr
op_star
id|arp
suffix:semicolon
r_int
id|hotdrop
op_assign
l_int|0
suffix:semicolon
r_struct
id|arpt_entry
op_star
id|e
comma
op_star
id|back
suffix:semicolon
r_const
r_char
op_star
id|indev
comma
op_star
id|outdev
suffix:semicolon
r_void
op_star
id|table_base
suffix:semicolon
multiline_comment|/* ARP header, plus 2 device addresses, plus 2 IP addresses.  */
r_if
c_cond
(paren
op_logical_neg
id|pskb_may_pull
c_func
(paren
(paren
op_star
id|pskb
)paren
comma
(paren
r_sizeof
(paren
r_struct
id|arphdr
)paren
op_plus
(paren
l_int|2
op_star
(paren
op_star
id|pskb
)paren
op_member_access_from_pointer
id|dev-&gt;addr_len
)paren
op_plus
(paren
l_int|2
op_star
r_sizeof
(paren
id|u32
)paren
)paren
)paren
)paren
)paren
r_return
id|NF_DROP
suffix:semicolon
id|indev
op_assign
id|in
ques
c_cond
id|in-&gt;name
suffix:colon
id|nulldevname
suffix:semicolon
id|outdev
op_assign
id|out
ques
c_cond
id|out-&gt;name
suffix:colon
id|nulldevname
suffix:semicolon
id|read_lock_bh
c_func
(paren
op_amp
id|table-&gt;lock
)paren
suffix:semicolon
id|table_base
op_assign
(paren
r_void
op_star
)paren
id|table
op_member_access_from_pointer
r_private
op_member_access_from_pointer
id|entries
op_plus
id|TABLE_OFFSET
c_func
(paren
id|table
op_member_access_from_pointer
r_private
comma
id|smp_processor_id
c_func
(paren
)paren
)paren
suffix:semicolon
id|e
op_assign
id|get_entry
c_func
(paren
id|table_base
comma
id|table
op_member_access_from_pointer
r_private
op_member_access_from_pointer
id|hook_entry
(braket
id|hook
)braket
)paren
suffix:semicolon
id|back
op_assign
id|get_entry
c_func
(paren
id|table_base
comma
id|table
op_member_access_from_pointer
r_private
op_member_access_from_pointer
id|underflow
(braket
id|hook
)braket
)paren
suffix:semicolon
id|arp
op_assign
(paren
op_star
id|pskb
)paren
op_member_access_from_pointer
id|nh.arph
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|arp_packet_match
c_func
(paren
id|arp
comma
(paren
op_star
id|pskb
)paren
op_member_access_from_pointer
id|dev
comma
id|indev
comma
id|outdev
comma
op_amp
id|e-&gt;arp
)paren
)paren
(brace
r_struct
id|arpt_entry_target
op_star
id|t
suffix:semicolon
r_int
id|hdr_len
suffix:semicolon
id|hdr_len
op_assign
r_sizeof
(paren
op_star
id|arp
)paren
op_plus
(paren
l_int|2
op_star
r_sizeof
(paren
r_struct
id|in_addr
)paren
)paren
op_plus
(paren
l_int|2
op_star
(paren
op_star
id|pskb
)paren
op_member_access_from_pointer
id|dev-&gt;addr_len
)paren
suffix:semicolon
id|ADD_COUNTER
c_func
(paren
id|e-&gt;counters
comma
id|hdr_len
comma
l_int|1
)paren
suffix:semicolon
id|t
op_assign
id|arpt_get_target
c_func
(paren
id|e
)paren
suffix:semicolon
multiline_comment|/* Standard target? */
r_if
c_cond
(paren
op_logical_neg
id|t-&gt;u.kernel.target-&gt;target
)paren
(brace
r_int
id|v
suffix:semicolon
id|v
op_assign
(paren
(paren
r_struct
id|arpt_standard_target
op_star
)paren
id|t
)paren
op_member_access_from_pointer
id|verdict
suffix:semicolon
r_if
c_cond
(paren
id|v
OL
l_int|0
)paren
(brace
multiline_comment|/* Pop from stack? */
r_if
c_cond
(paren
id|v
op_ne
id|ARPT_RETURN
)paren
(brace
id|verdict
op_assign
(paren
r_int
)paren
(paren
op_minus
id|v
)paren
op_minus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
id|e
op_assign
id|back
suffix:semicolon
id|back
op_assign
id|get_entry
c_func
(paren
id|table_base
comma
id|back-&gt;comefrom
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|table_base
op_plus
id|v
op_ne
(paren
r_void
op_star
)paren
id|e
op_plus
id|e-&gt;next_offset
)paren
(brace
multiline_comment|/* Save old back ptr in next entry */
r_struct
id|arpt_entry
op_star
id|next
op_assign
(paren
r_void
op_star
)paren
id|e
op_plus
id|e-&gt;next_offset
suffix:semicolon
id|next-&gt;comefrom
op_assign
(paren
r_void
op_star
)paren
id|back
op_minus
id|table_base
suffix:semicolon
multiline_comment|/* set back pointer to next entry */
id|back
op_assign
id|next
suffix:semicolon
)brace
id|e
op_assign
id|get_entry
c_func
(paren
id|table_base
comma
id|v
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Targets which reenter must return&n;&t;&t;&t;&t; * abs. verdicts&n;&t;&t;&t;&t; */
id|verdict
op_assign
id|t-&gt;u.kernel.target
op_member_access_from_pointer
id|target
c_func
(paren
id|pskb
comma
id|hook
comma
id|in
comma
id|out
comma
id|t-&gt;data
comma
id|userdata
)paren
suffix:semicolon
multiline_comment|/* Target might have changed stuff. */
id|arp
op_assign
(paren
op_star
id|pskb
)paren
op_member_access_from_pointer
id|nh.arph
suffix:semicolon
r_if
c_cond
(paren
id|verdict
op_eq
id|ARPT_CONTINUE
)paren
id|e
op_assign
(paren
r_void
op_star
)paren
id|e
op_plus
id|e-&gt;next_offset
suffix:semicolon
r_else
multiline_comment|/* Verdict */
r_break
suffix:semicolon
)brace
)brace
r_else
(brace
id|e
op_assign
(paren
r_void
op_star
)paren
id|e
op_plus
id|e-&gt;next_offset
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
op_logical_neg
id|hotdrop
)paren
suffix:semicolon
id|read_unlock_bh
c_func
(paren
op_amp
id|table-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hotdrop
)paren
r_return
id|NF_DROP
suffix:semicolon
r_else
r_return
id|verdict
suffix:semicolon
)brace
DECL|function|find_inlist_lock_noload
r_static
r_inline
r_void
op_star
id|find_inlist_lock_noload
c_func
(paren
r_struct
id|list_head
op_star
id|head
comma
r_const
r_char
op_star
id|name
comma
r_int
op_star
id|error
comma
r_struct
id|semaphore
op_star
id|mutex
)paren
(brace
r_void
op_star
id|ret
suffix:semicolon
op_star
id|error
op_assign
id|down_interruptible
c_func
(paren
id|mutex
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|error
op_ne
l_int|0
)paren
r_return
l_int|NULL
suffix:semicolon
id|ret
op_assign
id|list_named_find
c_func
(paren
id|head
comma
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
(brace
op_star
id|error
op_assign
op_minus
id|ENOENT
suffix:semicolon
id|up
c_func
(paren
id|mutex
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
macro_line|#ifndef CONFIG_KMOD
DECL|macro|find_inlist_lock
mdefine_line|#define find_inlist_lock(h,n,p,e,m) find_inlist_lock_noload((h),(n),(e),(m))
macro_line|#else
r_static
r_void
op_star
DECL|function|find_inlist_lock
id|find_inlist_lock
c_func
(paren
r_struct
id|list_head
op_star
id|head
comma
r_const
r_char
op_star
id|name
comma
r_const
r_char
op_star
id|prefix
comma
r_int
op_star
id|error
comma
r_struct
id|semaphore
op_star
id|mutex
)paren
(brace
r_void
op_star
id|ret
suffix:semicolon
id|ret
op_assign
id|find_inlist_lock_noload
c_func
(paren
id|head
comma
id|name
comma
id|error
comma
id|mutex
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
(brace
id|duprintf
c_func
(paren
l_string|&quot;find_inlist: loading `%s%s&squot;.&bslash;n&quot;
comma
id|prefix
comma
id|name
)paren
suffix:semicolon
id|request_module
c_func
(paren
l_string|&quot;%s%s&quot;
comma
id|prefix
comma
id|name
)paren
suffix:semicolon
id|ret
op_assign
id|find_inlist_lock_noload
c_func
(paren
id|head
comma
id|name
comma
id|error
comma
id|mutex
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
macro_line|#endif
DECL|function|find_table_lock
r_static
r_inline
r_struct
id|arpt_table
op_star
id|find_table_lock
c_func
(paren
r_const
r_char
op_star
id|name
comma
r_int
op_star
id|error
comma
r_struct
id|semaphore
op_star
id|mutex
)paren
(brace
r_return
id|find_inlist_lock
c_func
(paren
op_amp
id|arpt_tables
comma
id|name
comma
l_string|&quot;arptable_&quot;
comma
id|error
comma
id|mutex
)paren
suffix:semicolon
)brace
DECL|function|find_target_lock
r_static
r_inline
r_struct
id|arpt_target
op_star
id|find_target_lock
c_func
(paren
r_const
r_char
op_star
id|name
comma
r_int
op_star
id|error
comma
r_struct
id|semaphore
op_star
id|mutex
)paren
(brace
r_return
id|find_inlist_lock
c_func
(paren
op_amp
id|arpt_target
comma
id|name
comma
l_string|&quot;arpt_&quot;
comma
id|error
comma
id|mutex
)paren
suffix:semicolon
)brace
multiline_comment|/* All zeroes == unconditional rule. */
DECL|function|unconditional
r_static
r_inline
r_int
id|unconditional
c_func
(paren
r_const
r_struct
id|arpt_arp
op_star
id|arp
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
op_star
id|arp
)paren
op_div
r_sizeof
(paren
id|__u32
)paren
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
(paren
(paren
id|__u32
op_star
)paren
id|arp
)paren
(braket
id|i
)braket
)paren
r_return
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Figures out from what hook each rule can be called: returns 0 if&n; * there are loops.  Puts hook bitmask in comefrom.&n; */
DECL|function|mark_source_chains
r_static
r_int
id|mark_source_chains
c_func
(paren
r_struct
id|arpt_table_info
op_star
id|newinfo
comma
r_int
r_int
id|valid_hooks
)paren
(brace
r_int
r_int
id|hook
suffix:semicolon
multiline_comment|/* No recursion; use packet counter to save back ptrs (reset&n;&t; * to 0 as we leave), and comefrom to save source hook bitmask.&n;&t; */
r_for
c_loop
(paren
id|hook
op_assign
l_int|0
suffix:semicolon
id|hook
OL
id|NF_ARP_NUMHOOKS
suffix:semicolon
id|hook
op_increment
)paren
(brace
r_int
r_int
id|pos
op_assign
id|newinfo-&gt;hook_entry
(braket
id|hook
)braket
suffix:semicolon
r_struct
id|arpt_entry
op_star
id|e
op_assign
(paren
r_struct
id|arpt_entry
op_star
)paren
(paren
id|newinfo-&gt;entries
op_plus
id|pos
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|valid_hooks
op_amp
(paren
l_int|1
op_lshift
id|hook
)paren
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/* Set initial back pointer. */
id|e-&gt;counters.pcnt
op_assign
id|pos
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_struct
id|arpt_standard_target
op_star
id|t
op_assign
(paren
r_void
op_star
)paren
id|arpt_get_target
c_func
(paren
id|e
)paren
suffix:semicolon
r_if
c_cond
(paren
id|e-&gt;comefrom
op_amp
(paren
l_int|1
op_lshift
id|NF_ARP_NUMHOOKS
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;arptables: loop hook %u pos %u %08X.&bslash;n&quot;
comma
id|hook
comma
id|pos
comma
id|e-&gt;comefrom
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|e-&gt;comefrom
op_or_assign
(paren
(paren
l_int|1
op_lshift
id|hook
)paren
op_or
(paren
l_int|1
op_lshift
id|NF_ARP_NUMHOOKS
)paren
)paren
suffix:semicolon
multiline_comment|/* Unconditional return/END. */
r_if
c_cond
(paren
id|e-&gt;target_offset
op_eq
r_sizeof
(paren
r_struct
id|arpt_entry
)paren
op_logical_and
(paren
id|strcmp
c_func
(paren
id|t-&gt;target.u.user.name
comma
id|ARPT_STANDARD_TARGET
)paren
op_eq
l_int|0
)paren
op_logical_and
id|t-&gt;verdict
OL
l_int|0
op_logical_and
id|unconditional
c_func
(paren
op_amp
id|e-&gt;arp
)paren
)paren
(brace
r_int
r_int
id|oldpos
comma
id|size
suffix:semicolon
multiline_comment|/* Return: backtrack through the last&n;&t;&t;&t;&t; * big jump.&n;&t;&t;&t;&t; */
r_do
(brace
id|e-&gt;comefrom
op_xor_assign
(paren
l_int|1
op_lshift
id|NF_ARP_NUMHOOKS
)paren
suffix:semicolon
id|oldpos
op_assign
id|pos
suffix:semicolon
id|pos
op_assign
id|e-&gt;counters.pcnt
suffix:semicolon
id|e-&gt;counters.pcnt
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* We&squot;re at the start. */
r_if
c_cond
(paren
id|pos
op_eq
id|oldpos
)paren
r_goto
id|next
suffix:semicolon
id|e
op_assign
(paren
r_struct
id|arpt_entry
op_star
)paren
(paren
id|newinfo-&gt;entries
op_plus
id|pos
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|oldpos
op_eq
id|pos
op_plus
id|e-&gt;next_offset
)paren
suffix:semicolon
multiline_comment|/* Move along one */
id|size
op_assign
id|e-&gt;next_offset
suffix:semicolon
id|e
op_assign
(paren
r_struct
id|arpt_entry
op_star
)paren
(paren
id|newinfo-&gt;entries
op_plus
id|pos
op_plus
id|size
)paren
suffix:semicolon
id|e-&gt;counters.pcnt
op_assign
id|pos
suffix:semicolon
id|pos
op_add_assign
id|size
suffix:semicolon
)brace
r_else
(brace
r_int
id|newpos
op_assign
id|t-&gt;verdict
suffix:semicolon
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|t-&gt;target.u.user.name
comma
id|ARPT_STANDARD_TARGET
)paren
op_eq
l_int|0
op_logical_and
id|newpos
op_ge
l_int|0
)paren
(brace
multiline_comment|/* This a jump; chase it. */
id|duprintf
c_func
(paren
l_string|&quot;Jump rule %u -&gt; %u&bslash;n&quot;
comma
id|pos
comma
id|newpos
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* ... this is a fallthru */
id|newpos
op_assign
id|pos
op_plus
id|e-&gt;next_offset
suffix:semicolon
)brace
id|e
op_assign
(paren
r_struct
id|arpt_entry
op_star
)paren
(paren
id|newinfo-&gt;entries
op_plus
id|newpos
)paren
suffix:semicolon
id|e-&gt;counters.pcnt
op_assign
id|pos
suffix:semicolon
id|pos
op_assign
id|newpos
suffix:semicolon
)brace
)brace
id|next
suffix:colon
id|duprintf
c_func
(paren
l_string|&quot;Finished chain %u&bslash;n&quot;
comma
id|hook
)paren
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|standard_check
r_static
r_inline
r_int
id|standard_check
c_func
(paren
r_const
r_struct
id|arpt_entry_target
op_star
id|t
comma
r_int
r_int
id|max_offset
)paren
(brace
r_struct
id|arpt_standard_target
op_star
id|targ
op_assign
(paren
r_void
op_star
)paren
id|t
suffix:semicolon
multiline_comment|/* Check standard info. */
r_if
c_cond
(paren
id|t-&gt;u.target_size
op_ne
id|ARPT_ALIGN
c_func
(paren
r_sizeof
(paren
r_struct
id|arpt_standard_target
)paren
)paren
)paren
(brace
id|duprintf
c_func
(paren
l_string|&quot;arpt_standard_check: target size %u != %Zu&bslash;n&quot;
comma
id|t-&gt;u.target_size
comma
id|ARPT_ALIGN
c_func
(paren
r_sizeof
(paren
r_struct
id|arpt_standard_target
)paren
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|targ-&gt;verdict
op_ge
l_int|0
op_logical_and
id|targ-&gt;verdict
OG
id|max_offset
op_minus
r_sizeof
(paren
r_struct
id|arpt_entry
)paren
)paren
(brace
id|duprintf
c_func
(paren
l_string|&quot;arpt_standard_check: bad verdict (%i)&bslash;n&quot;
comma
id|targ-&gt;verdict
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|targ-&gt;verdict
OL
op_minus
id|NF_MAX_VERDICT
op_minus
l_int|1
)paren
(brace
id|duprintf
c_func
(paren
l_string|&quot;arpt_standard_check: bad negative verdict (%i)&bslash;n&quot;
comma
id|targ-&gt;verdict
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|variable|arpt_standard_target
r_static
r_struct
id|arpt_target
id|arpt_standard_target
suffix:semicolon
DECL|function|check_entry
r_static
r_inline
r_int
id|check_entry
c_func
(paren
r_struct
id|arpt_entry
op_star
id|e
comma
r_const
r_char
op_star
id|name
comma
r_int
r_int
id|size
comma
r_int
r_int
op_star
id|i
)paren
(brace
r_struct
id|arpt_entry_target
op_star
id|t
suffix:semicolon
r_struct
id|arpt_target
op_star
id|target
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|arp_checkentry
c_func
(paren
op_amp
id|e-&gt;arp
)paren
)paren
(brace
id|duprintf
c_func
(paren
l_string|&quot;arp_tables: arp check failed %p %s.&bslash;n&quot;
comma
id|e
comma
id|name
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|t
op_assign
id|arpt_get_target
c_func
(paren
id|e
)paren
suffix:semicolon
id|target
op_assign
id|find_target_lock
c_func
(paren
id|t-&gt;u.user.name
comma
op_amp
id|ret
comma
op_amp
id|arpt_mutex
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|target
)paren
(brace
id|duprintf
c_func
(paren
l_string|&quot;check_entry: `%s&squot; not found&bslash;n&quot;
comma
id|t-&gt;u.user.name
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|try_module_get
c_func
(paren
(paren
id|target-&gt;me
)paren
)paren
)paren
(brace
id|ret
op_assign
op_minus
id|ENOENT
suffix:semicolon
r_goto
id|out_unlock
suffix:semicolon
)brace
id|t-&gt;u.kernel.target
op_assign
id|target
suffix:semicolon
id|up
c_func
(paren
op_amp
id|arpt_mutex
)paren
suffix:semicolon
r_if
c_cond
(paren
id|t-&gt;u.kernel.target
op_eq
op_amp
id|arpt_standard_target
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|standard_check
c_func
(paren
id|t
comma
id|size
)paren
)paren
(brace
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|t-&gt;u.kernel.target-&gt;checkentry
op_logical_and
op_logical_neg
id|t-&gt;u.kernel.target
op_member_access_from_pointer
id|checkentry
c_func
(paren
id|name
comma
id|e
comma
id|t-&gt;data
comma
id|t-&gt;u.target_size
op_minus
r_sizeof
(paren
op_star
id|t
)paren
comma
id|e-&gt;comefrom
)paren
)paren
(brace
id|module_put
c_func
(paren
id|t-&gt;u.kernel.target-&gt;me
)paren
suffix:semicolon
id|duprintf
c_func
(paren
l_string|&quot;arp_tables: check failed for `%s&squot;.&bslash;n&quot;
comma
id|t-&gt;u.kernel.target-&gt;name
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
(paren
op_star
id|i
)paren
op_increment
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|out_unlock
suffix:colon
id|up
c_func
(paren
op_amp
id|arpt_mutex
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|check_entry_size_and_hooks
r_static
r_inline
r_int
id|check_entry_size_and_hooks
c_func
(paren
r_struct
id|arpt_entry
op_star
id|e
comma
r_struct
id|arpt_table_info
op_star
id|newinfo
comma
r_int
r_char
op_star
id|base
comma
r_int
r_char
op_star
id|limit
comma
r_const
r_int
r_int
op_star
id|hook_entries
comma
r_const
r_int
r_int
op_star
id|underflows
comma
r_int
r_int
op_star
id|i
)paren
(brace
r_int
r_int
id|h
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
r_int
)paren
id|e
op_mod
id|__alignof__
c_func
(paren
r_struct
id|arpt_entry
)paren
op_ne
l_int|0
op_logical_or
(paren
r_int
r_char
op_star
)paren
id|e
op_plus
r_sizeof
(paren
r_struct
id|arpt_entry
)paren
op_ge
id|limit
)paren
(brace
id|duprintf
c_func
(paren
l_string|&quot;Bad offset %p&bslash;n&quot;
comma
id|e
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|e-&gt;next_offset
OL
r_sizeof
(paren
r_struct
id|arpt_entry
)paren
op_plus
r_sizeof
(paren
r_struct
id|arpt_entry_target
)paren
)paren
(brace
id|duprintf
c_func
(paren
l_string|&quot;checking: element %p size %u&bslash;n&quot;
comma
id|e
comma
id|e-&gt;next_offset
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* Check hooks &amp; underflows */
r_for
c_loop
(paren
id|h
op_assign
l_int|0
suffix:semicolon
id|h
OL
id|NF_ARP_NUMHOOKS
suffix:semicolon
id|h
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
r_int
r_char
op_star
)paren
id|e
op_minus
id|base
op_eq
id|hook_entries
(braket
id|h
)braket
)paren
id|newinfo-&gt;hook_entry
(braket
id|h
)braket
op_assign
id|hook_entries
(braket
id|h
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
r_char
op_star
)paren
id|e
op_minus
id|base
op_eq
id|underflows
(braket
id|h
)braket
)paren
id|newinfo-&gt;underflow
(braket
id|h
)braket
op_assign
id|underflows
(braket
id|h
)braket
suffix:semicolon
)brace
multiline_comment|/* FIXME: underflows must be unconditional, standard verdicts&n;           &lt; 0 (not ARPT_RETURN). --RR */
multiline_comment|/* Clear counters and comefrom */
id|e-&gt;counters
op_assign
(paren
(paren
r_struct
id|arpt_counters
)paren
(brace
l_int|0
comma
l_int|0
)brace
)paren
suffix:semicolon
id|e-&gt;comefrom
op_assign
l_int|0
suffix:semicolon
(paren
op_star
id|i
)paren
op_increment
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cleanup_entry
r_static
r_inline
r_int
id|cleanup_entry
c_func
(paren
r_struct
id|arpt_entry
op_star
id|e
comma
r_int
r_int
op_star
id|i
)paren
(brace
r_struct
id|arpt_entry_target
op_star
id|t
suffix:semicolon
r_if
c_cond
(paren
id|i
op_logical_and
(paren
op_star
id|i
)paren
op_decrement
op_eq
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
id|t
op_assign
id|arpt_get_target
c_func
(paren
id|e
)paren
suffix:semicolon
r_if
c_cond
(paren
id|t-&gt;u.kernel.target-&gt;destroy
)paren
id|t-&gt;u.kernel.target
op_member_access_from_pointer
id|destroy
c_func
(paren
id|t-&gt;data
comma
id|t-&gt;u.target_size
op_minus
r_sizeof
(paren
op_star
id|t
)paren
)paren
suffix:semicolon
id|module_put
c_func
(paren
id|t-&gt;u.kernel.target-&gt;me
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Checks and translates the user-supplied table segment (held in&n; * newinfo).&n; */
DECL|function|translate_table
r_static
r_int
id|translate_table
c_func
(paren
r_const
r_char
op_star
id|name
comma
r_int
r_int
id|valid_hooks
comma
r_struct
id|arpt_table_info
op_star
id|newinfo
comma
r_int
r_int
id|size
comma
r_int
r_int
id|number
comma
r_const
r_int
r_int
op_star
id|hook_entries
comma
r_const
r_int
r_int
op_star
id|underflows
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|newinfo-&gt;size
op_assign
id|size
suffix:semicolon
id|newinfo-&gt;number
op_assign
id|number
suffix:semicolon
multiline_comment|/* Init all hooks to impossible value. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NF_ARP_NUMHOOKS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|newinfo-&gt;hook_entry
(braket
id|i
)braket
op_assign
l_int|0xFFFFFFFF
suffix:semicolon
id|newinfo-&gt;underflow
(braket
id|i
)braket
op_assign
l_int|0xFFFFFFFF
suffix:semicolon
)brace
id|duprintf
c_func
(paren
l_string|&quot;translate_table: size %u&bslash;n&quot;
comma
id|newinfo-&gt;size
)paren
suffix:semicolon
id|i
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Walk through entries, checking offsets. */
id|ret
op_assign
id|ARPT_ENTRY_ITERATE
c_func
(paren
id|newinfo-&gt;entries
comma
id|newinfo-&gt;size
comma
id|check_entry_size_and_hooks
comma
id|newinfo
comma
id|newinfo-&gt;entries
comma
id|newinfo-&gt;entries
op_plus
id|size
comma
id|hook_entries
comma
id|underflows
comma
op_amp
id|i
)paren
suffix:semicolon
id|duprintf
c_func
(paren
l_string|&quot;translate_table: ARPT_ENTRY_ITERATE gives %d&bslash;n&quot;
comma
id|ret
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
l_int|0
)paren
r_return
id|ret
suffix:semicolon
r_if
c_cond
(paren
id|i
op_ne
id|number
)paren
(brace
id|duprintf
c_func
(paren
l_string|&quot;translate_table: %u not %u entries&bslash;n&quot;
comma
id|i
comma
id|number
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* Check hooks all assigned */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NF_ARP_NUMHOOKS
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* Only hooks which are valid */
r_if
c_cond
(paren
op_logical_neg
(paren
id|valid_hooks
op_amp
(paren
l_int|1
op_lshift
id|i
)paren
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|newinfo-&gt;hook_entry
(braket
id|i
)braket
op_eq
l_int|0xFFFFFFFF
)paren
(brace
id|duprintf
c_func
(paren
l_string|&quot;Invalid hook entry %u %u&bslash;n&quot;
comma
id|i
comma
id|hook_entries
(braket
id|i
)braket
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|newinfo-&gt;underflow
(braket
id|i
)braket
op_eq
l_int|0xFFFFFFFF
)paren
(brace
id|duprintf
c_func
(paren
l_string|&quot;Invalid underflow %u %u&bslash;n&quot;
comma
id|i
comma
id|underflows
(braket
id|i
)braket
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|mark_source_chains
c_func
(paren
id|newinfo
comma
id|valid_hooks
)paren
)paren
(brace
id|duprintf
c_func
(paren
l_string|&quot;Looping hook&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ELOOP
suffix:semicolon
)brace
multiline_comment|/* Finally, each sanity check must pass */
id|i
op_assign
l_int|0
suffix:semicolon
id|ret
op_assign
id|ARPT_ENTRY_ITERATE
c_func
(paren
id|newinfo-&gt;entries
comma
id|newinfo-&gt;size
comma
id|check_entry
comma
id|name
comma
id|size
comma
op_amp
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
l_int|0
)paren
(brace
id|ARPT_ENTRY_ITERATE
c_func
(paren
id|newinfo-&gt;entries
comma
id|newinfo-&gt;size
comma
id|cleanup_entry
comma
op_amp
id|i
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* And one copy for every other CPU */
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|NR_CPUS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|memcpy
c_func
(paren
id|newinfo-&gt;entries
op_plus
id|SMP_ALIGN
c_func
(paren
id|newinfo-&gt;size
)paren
op_star
id|i
comma
id|newinfo-&gt;entries
comma
id|SMP_ALIGN
c_func
(paren
id|newinfo-&gt;size
)paren
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|function|replace_table
r_static
r_struct
id|arpt_table_info
op_star
id|replace_table
c_func
(paren
r_struct
id|arpt_table
op_star
id|table
comma
r_int
r_int
id|num_counters
comma
r_struct
id|arpt_table_info
op_star
id|newinfo
comma
r_int
op_star
id|error
)paren
(brace
r_struct
id|arpt_table_info
op_star
id|oldinfo
suffix:semicolon
multiline_comment|/* Do the substitution. */
id|write_lock_bh
c_func
(paren
op_amp
id|table-&gt;lock
)paren
suffix:semicolon
multiline_comment|/* Check inside lock: is the old number correct? */
r_if
c_cond
(paren
id|num_counters
op_ne
id|table
op_member_access_from_pointer
r_private
op_member_access_from_pointer
id|number
)paren
(brace
id|duprintf
c_func
(paren
l_string|&quot;num_counters != table-&gt;private-&gt;number (%u/%u)&bslash;n&quot;
comma
id|num_counters
comma
id|table
op_member_access_from_pointer
r_private
op_member_access_from_pointer
id|number
)paren
suffix:semicolon
id|write_unlock_bh
c_func
(paren
op_amp
id|table-&gt;lock
)paren
suffix:semicolon
op_star
id|error
op_assign
op_minus
id|EAGAIN
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|oldinfo
op_assign
id|table
op_member_access_from_pointer
r_private
suffix:semicolon
id|table
op_member_access_from_pointer
r_private
op_assign
id|newinfo
suffix:semicolon
id|newinfo-&gt;initial_entries
op_assign
id|oldinfo-&gt;initial_entries
suffix:semicolon
id|write_unlock_bh
c_func
(paren
op_amp
id|table-&gt;lock
)paren
suffix:semicolon
r_return
id|oldinfo
suffix:semicolon
)brace
multiline_comment|/* Gets counters. */
DECL|function|add_entry_to_counter
r_static
r_inline
r_int
id|add_entry_to_counter
c_func
(paren
r_const
r_struct
id|arpt_entry
op_star
id|e
comma
r_struct
id|arpt_counters
id|total
(braket
)braket
comma
r_int
r_int
op_star
id|i
)paren
(brace
id|ADD_COUNTER
c_func
(paren
id|total
(braket
op_star
id|i
)braket
comma
id|e-&gt;counters.bcnt
comma
id|e-&gt;counters.pcnt
)paren
suffix:semicolon
(paren
op_star
id|i
)paren
op_increment
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|get_counters
r_static
r_void
id|get_counters
c_func
(paren
r_const
r_struct
id|arpt_table_info
op_star
id|t
comma
r_struct
id|arpt_counters
id|counters
(braket
)braket
)paren
(brace
r_int
r_int
id|cpu
suffix:semicolon
r_int
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|cpu
op_assign
l_int|0
suffix:semicolon
id|cpu
OL
id|NR_CPUS
suffix:semicolon
id|cpu
op_increment
)paren
(brace
id|i
op_assign
l_int|0
suffix:semicolon
id|ARPT_ENTRY_ITERATE
c_func
(paren
id|t-&gt;entries
op_plus
id|TABLE_OFFSET
c_func
(paren
id|t
comma
id|cpu
)paren
comma
id|t-&gt;size
comma
id|add_entry_to_counter
comma
id|counters
comma
op_amp
id|i
)paren
suffix:semicolon
)brace
)brace
DECL|function|copy_entries_to_user
r_static
r_int
id|copy_entries_to_user
c_func
(paren
r_int
r_int
id|total_size
comma
r_struct
id|arpt_table
op_star
id|table
comma
r_void
op_star
id|userptr
)paren
(brace
r_int
r_int
id|off
comma
id|num
comma
id|countersize
suffix:semicolon
r_struct
id|arpt_entry
op_star
id|e
suffix:semicolon
r_struct
id|arpt_counters
op_star
id|counters
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* We need atomic snapshot of counters: rest doesn&squot;t change&n;&t; * (other than comefrom, which userspace doesn&squot;t care&n;&t; * about).&n;&t; */
id|countersize
op_assign
r_sizeof
(paren
r_struct
id|arpt_counters
)paren
op_star
id|table
op_member_access_from_pointer
r_private
op_member_access_from_pointer
id|number
suffix:semicolon
id|counters
op_assign
id|vmalloc
c_func
(paren
id|countersize
)paren
suffix:semicolon
r_if
c_cond
(paren
id|counters
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
multiline_comment|/* First, sum counters... */
id|memset
c_func
(paren
id|counters
comma
l_int|0
comma
id|countersize
)paren
suffix:semicolon
id|write_lock_bh
c_func
(paren
op_amp
id|table-&gt;lock
)paren
suffix:semicolon
id|get_counters
c_func
(paren
id|table
op_member_access_from_pointer
r_private
comma
id|counters
)paren
suffix:semicolon
id|write_unlock_bh
c_func
(paren
op_amp
id|table-&gt;lock
)paren
suffix:semicolon
multiline_comment|/* ... then copy entire thing from CPU 0... */
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|userptr
comma
id|table
op_member_access_from_pointer
r_private
op_member_access_from_pointer
id|entries
comma
id|total_size
)paren
op_ne
l_int|0
)paren
(brace
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
id|free_counters
suffix:semicolon
)brace
multiline_comment|/* FIXME: use iterator macros --RR */
multiline_comment|/* ... then go back and fix counters and names */
r_for
c_loop
(paren
id|off
op_assign
l_int|0
comma
id|num
op_assign
l_int|0
suffix:semicolon
id|off
OL
id|total_size
suffix:semicolon
id|off
op_add_assign
id|e-&gt;next_offset
comma
id|num
op_increment
)paren
(brace
r_struct
id|arpt_entry_target
op_star
id|t
suffix:semicolon
id|e
op_assign
(paren
r_struct
id|arpt_entry
op_star
)paren
(paren
id|table
op_member_access_from_pointer
r_private
op_member_access_from_pointer
id|entries
op_plus
id|off
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|userptr
op_plus
id|off
op_plus
m_offsetof
(paren
r_struct
id|arpt_entry
comma
id|counters
)paren
comma
op_amp
id|counters
(braket
id|num
)braket
comma
r_sizeof
(paren
id|counters
(braket
id|num
)braket
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
id|free_counters
suffix:semicolon
)brace
id|t
op_assign
id|arpt_get_target
c_func
(paren
id|e
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|userptr
op_plus
id|off
op_plus
id|e-&gt;target_offset
op_plus
m_offsetof
(paren
r_struct
id|arpt_entry_target
comma
id|u.user.name
)paren
comma
id|t-&gt;u.kernel.target-&gt;name
comma
id|strlen
c_func
(paren
id|t-&gt;u.kernel.target-&gt;name
)paren
op_plus
l_int|1
)paren
op_ne
l_int|0
)paren
(brace
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
id|free_counters
suffix:semicolon
)brace
)brace
id|free_counters
suffix:colon
id|vfree
c_func
(paren
id|counters
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|get_entries
r_static
r_int
id|get_entries
c_func
(paren
r_const
r_struct
id|arpt_get_entries
op_star
id|entries
comma
r_struct
id|arpt_get_entries
op_star
id|uptr
)paren
(brace
r_int
id|ret
suffix:semicolon
r_struct
id|arpt_table
op_star
id|t
suffix:semicolon
id|t
op_assign
id|find_table_lock
c_func
(paren
id|entries-&gt;name
comma
op_amp
id|ret
comma
op_amp
id|arpt_mutex
)paren
suffix:semicolon
r_if
c_cond
(paren
id|t
)paren
(brace
id|duprintf
c_func
(paren
l_string|&quot;t-&gt;private-&gt;number = %u&bslash;n&quot;
comma
id|t
op_member_access_from_pointer
r_private
op_member_access_from_pointer
id|number
)paren
suffix:semicolon
r_if
c_cond
(paren
id|entries-&gt;size
op_eq
id|t
op_member_access_from_pointer
r_private
op_member_access_from_pointer
id|size
)paren
id|ret
op_assign
id|copy_entries_to_user
c_func
(paren
id|t
op_member_access_from_pointer
r_private
op_member_access_from_pointer
id|size
comma
id|t
comma
id|uptr-&gt;entrytable
)paren
suffix:semicolon
r_else
(brace
id|duprintf
c_func
(paren
l_string|&quot;get_entries: I&squot;ve got %u not %u!&bslash;n&quot;
comma
id|t
op_member_access_from_pointer
r_private
op_member_access_from_pointer
id|size
comma
id|entries-&gt;size
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|arpt_mutex
)paren
suffix:semicolon
)brace
r_else
id|duprintf
c_func
(paren
l_string|&quot;get_entries: Can&squot;t find %s!&bslash;n&quot;
comma
id|entries-&gt;name
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|do_replace
r_static
r_int
id|do_replace
c_func
(paren
r_void
op_star
id|user
comma
r_int
r_int
id|len
)paren
(brace
r_int
id|ret
suffix:semicolon
r_struct
id|arpt_replace
id|tmp
suffix:semicolon
r_struct
id|arpt_table
op_star
id|t
suffix:semicolon
r_struct
id|arpt_table_info
op_star
id|newinfo
comma
op_star
id|oldinfo
suffix:semicolon
r_struct
id|arpt_counters
op_star
id|counters
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|tmp
comma
id|user
comma
r_sizeof
(paren
id|tmp
)paren
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
multiline_comment|/* Hack: Causes ipchains to give correct error msg --RR */
r_if
c_cond
(paren
id|len
op_ne
r_sizeof
(paren
id|tmp
)paren
op_plus
id|tmp.size
)paren
r_return
op_minus
id|ENOPROTOOPT
suffix:semicolon
multiline_comment|/* Pedantry: prevent them from hitting BUG() in vmalloc.c --RR */
r_if
c_cond
(paren
(paren
id|SMP_ALIGN
c_func
(paren
id|tmp.size
)paren
op_rshift
id|PAGE_SHIFT
)paren
op_plus
l_int|2
OG
id|num_physpages
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|newinfo
op_assign
id|vmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|arpt_table_info
)paren
op_plus
id|SMP_ALIGN
c_func
(paren
id|tmp.size
)paren
op_star
id|NR_CPUS
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|newinfo
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|newinfo-&gt;entries
comma
id|user
op_plus
r_sizeof
(paren
id|tmp
)paren
comma
id|tmp.size
)paren
op_ne
l_int|0
)paren
(brace
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
id|free_newinfo
suffix:semicolon
)brace
id|counters
op_assign
id|vmalloc
c_func
(paren
id|tmp.num_counters
op_star
r_sizeof
(paren
r_struct
id|arpt_counters
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|counters
)paren
(brace
id|ret
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|free_newinfo
suffix:semicolon
)brace
id|memset
c_func
(paren
id|counters
comma
l_int|0
comma
id|tmp.num_counters
op_star
r_sizeof
(paren
r_struct
id|arpt_counters
)paren
)paren
suffix:semicolon
id|ret
op_assign
id|translate_table
c_func
(paren
id|tmp.name
comma
id|tmp.valid_hooks
comma
id|newinfo
comma
id|tmp.size
comma
id|tmp.num_entries
comma
id|tmp.hook_entry
comma
id|tmp.underflow
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
l_int|0
)paren
r_goto
id|free_newinfo_counters
suffix:semicolon
id|duprintf
c_func
(paren
l_string|&quot;arp_tables: Translated table&bslash;n&quot;
)paren
suffix:semicolon
id|t
op_assign
id|find_table_lock
c_func
(paren
id|tmp.name
comma
op_amp
id|ret
comma
op_amp
id|arpt_mutex
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|t
)paren
r_goto
id|free_newinfo_counters_untrans
suffix:semicolon
multiline_comment|/* You lied! */
r_if
c_cond
(paren
id|tmp.valid_hooks
op_ne
id|t-&gt;valid_hooks
)paren
(brace
id|duprintf
c_func
(paren
l_string|&quot;Valid hook crap: %08X vs %08X&bslash;n&quot;
comma
id|tmp.valid_hooks
comma
id|t-&gt;valid_hooks
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|free_newinfo_counters_untrans_unlock
suffix:semicolon
)brace
multiline_comment|/* Get a reference in advance, we&squot;re not allowed fail later */
r_if
c_cond
(paren
op_logical_neg
id|try_module_get
c_func
(paren
id|t-&gt;me
)paren
)paren
(brace
id|ret
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_goto
id|free_newinfo_counters_untrans_unlock
suffix:semicolon
)brace
id|oldinfo
op_assign
id|replace_table
c_func
(paren
id|t
comma
id|tmp.num_counters
comma
id|newinfo
comma
op_amp
id|ret
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|oldinfo
)paren
r_goto
id|put_module
suffix:semicolon
multiline_comment|/* Update module usage count based on number of rules */
id|duprintf
c_func
(paren
l_string|&quot;do_replace: oldnum=%u, initnum=%u, newnum=%u&bslash;n&quot;
comma
id|oldinfo-&gt;number
comma
id|oldinfo-&gt;initial_entries
comma
id|newinfo-&gt;number
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|oldinfo-&gt;number
OG
id|oldinfo-&gt;initial_entries
)paren
op_logical_or
(paren
id|newinfo-&gt;number
op_le
id|oldinfo-&gt;initial_entries
)paren
)paren
id|module_put
c_func
(paren
id|t-&gt;me
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|oldinfo-&gt;number
OG
id|oldinfo-&gt;initial_entries
)paren
op_logical_and
(paren
id|newinfo-&gt;number
op_le
id|oldinfo-&gt;initial_entries
)paren
)paren
id|module_put
c_func
(paren
id|t-&gt;me
)paren
suffix:semicolon
multiline_comment|/* Get the old counters. */
id|get_counters
c_func
(paren
id|oldinfo
comma
id|counters
)paren
suffix:semicolon
multiline_comment|/* Decrease module usage counts and free resource */
id|ARPT_ENTRY_ITERATE
c_func
(paren
id|oldinfo-&gt;entries
comma
id|oldinfo-&gt;size
comma
id|cleanup_entry
comma
l_int|NULL
)paren
suffix:semicolon
id|vfree
c_func
(paren
id|oldinfo
)paren
suffix:semicolon
multiline_comment|/* Silent error: too late now. */
id|copy_to_user
c_func
(paren
id|tmp.counters
comma
id|counters
comma
r_sizeof
(paren
r_struct
id|arpt_counters
)paren
op_star
id|tmp.num_counters
)paren
suffix:semicolon
id|vfree
c_func
(paren
id|counters
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|arpt_mutex
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|put_module
suffix:colon
id|module_put
c_func
(paren
id|t-&gt;me
)paren
suffix:semicolon
id|free_newinfo_counters_untrans_unlock
suffix:colon
id|up
c_func
(paren
op_amp
id|arpt_mutex
)paren
suffix:semicolon
id|free_newinfo_counters_untrans
suffix:colon
id|ARPT_ENTRY_ITERATE
c_func
(paren
id|newinfo-&gt;entries
comma
id|newinfo-&gt;size
comma
id|cleanup_entry
comma
l_int|NULL
)paren
suffix:semicolon
id|free_newinfo_counters
suffix:colon
id|vfree
c_func
(paren
id|counters
)paren
suffix:semicolon
id|free_newinfo
suffix:colon
id|vfree
c_func
(paren
id|newinfo
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* We&squot;re lazy, and add to the first CPU; overflow works its fey magic&n; * and everything is OK.&n; */
DECL|function|add_counter_to_entry
r_static
r_inline
r_int
id|add_counter_to_entry
c_func
(paren
r_struct
id|arpt_entry
op_star
id|e
comma
r_const
r_struct
id|arpt_counters
id|addme
(braket
)braket
comma
r_int
r_int
op_star
id|i
)paren
(brace
id|ADD_COUNTER
c_func
(paren
id|e-&gt;counters
comma
id|addme
(braket
op_star
id|i
)braket
dot
id|bcnt
comma
id|addme
(braket
op_star
id|i
)braket
dot
id|pcnt
)paren
suffix:semicolon
(paren
op_star
id|i
)paren
op_increment
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|do_add_counters
r_static
r_int
id|do_add_counters
c_func
(paren
r_void
op_star
id|user
comma
r_int
r_int
id|len
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
r_struct
id|arpt_counters_info
id|tmp
comma
op_star
id|paddc
suffix:semicolon
r_struct
id|arpt_table
op_star
id|t
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|tmp
comma
id|user
comma
r_sizeof
(paren
id|tmp
)paren
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|len
op_ne
r_sizeof
(paren
id|tmp
)paren
op_plus
id|tmp.num_counters
op_star
r_sizeof
(paren
r_struct
id|arpt_counters
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|paddc
op_assign
id|vmalloc
c_func
(paren
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|paddc
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|paddc
comma
id|user
comma
id|len
)paren
op_ne
l_int|0
)paren
(brace
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
id|free
suffix:semicolon
)brace
id|t
op_assign
id|find_table_lock
c_func
(paren
id|tmp.name
comma
op_amp
id|ret
comma
op_amp
id|arpt_mutex
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|t
)paren
r_goto
id|free
suffix:semicolon
id|write_lock_bh
c_func
(paren
op_amp
id|t-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|t
op_member_access_from_pointer
r_private
op_member_access_from_pointer
id|number
op_ne
id|paddc-&gt;num_counters
)paren
(brace
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|unlock_up_free
suffix:semicolon
)brace
id|i
op_assign
l_int|0
suffix:semicolon
id|ARPT_ENTRY_ITERATE
c_func
(paren
id|t
op_member_access_from_pointer
r_private
op_member_access_from_pointer
id|entries
comma
id|t
op_member_access_from_pointer
r_private
op_member_access_from_pointer
id|size
comma
id|add_counter_to_entry
comma
id|paddc-&gt;counters
comma
op_amp
id|i
)paren
suffix:semicolon
id|unlock_up_free
suffix:colon
id|write_unlock_bh
c_func
(paren
op_amp
id|t-&gt;lock
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|arpt_mutex
)paren
suffix:semicolon
id|free
suffix:colon
id|vfree
c_func
(paren
id|paddc
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|do_arpt_set_ctl
r_static
r_int
id|do_arpt_set_ctl
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|cmd
comma
r_void
op_star
id|user
comma
r_int
r_int
id|len
)paren
(brace
r_int
id|ret
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_NET_ADMIN
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|ARPT_SO_SET_REPLACE
suffix:colon
id|ret
op_assign
id|do_replace
c_func
(paren
id|user
comma
id|len
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ARPT_SO_SET_ADD_COUNTERS
suffix:colon
id|ret
op_assign
id|do_add_counters
c_func
(paren
id|user
comma
id|len
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|duprintf
c_func
(paren
l_string|&quot;do_arpt_set_ctl:  unknown request %i&bslash;n&quot;
comma
id|cmd
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|function|do_arpt_get_ctl
r_static
r_int
id|do_arpt_get_ctl
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|cmd
comma
r_void
op_star
id|user
comma
r_int
op_star
id|len
)paren
(brace
r_int
id|ret
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_NET_ADMIN
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|ARPT_SO_GET_INFO
suffix:colon
(brace
r_char
id|name
(braket
id|ARPT_TABLE_MAXNAMELEN
)braket
suffix:semicolon
r_struct
id|arpt_table
op_star
id|t
suffix:semicolon
r_if
c_cond
(paren
op_star
id|len
op_ne
r_sizeof
(paren
r_struct
id|arpt_getinfo
)paren
)paren
(brace
id|duprintf
c_func
(paren
l_string|&quot;length %u != %Zu&bslash;n&quot;
comma
op_star
id|len
comma
r_sizeof
(paren
r_struct
id|arpt_getinfo
)paren
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|name
comma
id|user
comma
r_sizeof
(paren
id|name
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
)brace
id|name
(braket
id|ARPT_TABLE_MAXNAMELEN
op_minus
l_int|1
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|t
op_assign
id|find_table_lock
c_func
(paren
id|name
comma
op_amp
id|ret
comma
op_amp
id|arpt_mutex
)paren
suffix:semicolon
r_if
c_cond
(paren
id|t
)paren
(brace
r_struct
id|arpt_getinfo
id|info
suffix:semicolon
id|info.valid_hooks
op_assign
id|t-&gt;valid_hooks
suffix:semicolon
id|memcpy
c_func
(paren
id|info.hook_entry
comma
id|t
op_member_access_from_pointer
r_private
op_member_access_from_pointer
id|hook_entry
comma
r_sizeof
(paren
id|info.hook_entry
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|info.underflow
comma
id|t
op_member_access_from_pointer
r_private
op_member_access_from_pointer
id|underflow
comma
r_sizeof
(paren
id|info.underflow
)paren
)paren
suffix:semicolon
id|info.num_entries
op_assign
id|t
op_member_access_from_pointer
r_private
op_member_access_from_pointer
id|number
suffix:semicolon
id|info.size
op_assign
id|t
op_member_access_from_pointer
r_private
op_member_access_from_pointer
id|size
suffix:semicolon
id|strcpy
c_func
(paren
id|info.name
comma
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|user
comma
op_amp
id|info
comma
op_star
id|len
)paren
op_ne
l_int|0
)paren
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_else
id|ret
op_assign
l_int|0
suffix:semicolon
id|up
c_func
(paren
op_amp
id|arpt_mutex
)paren
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
r_case
id|ARPT_SO_GET_ENTRIES
suffix:colon
(brace
r_struct
id|arpt_get_entries
id|get
suffix:semicolon
r_if
c_cond
(paren
op_star
id|len
OL
r_sizeof
(paren
id|get
)paren
)paren
(brace
id|duprintf
c_func
(paren
l_string|&quot;get_entries: %u &lt; %Zu&bslash;n&quot;
comma
op_star
id|len
comma
r_sizeof
(paren
id|get
)paren
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|get
comma
id|user
comma
r_sizeof
(paren
id|get
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_star
id|len
op_ne
r_sizeof
(paren
r_struct
id|arpt_get_entries
)paren
op_plus
id|get.size
)paren
(brace
id|duprintf
c_func
(paren
l_string|&quot;get_entries: %u != %Zu&bslash;n&quot;
comma
op_star
id|len
comma
r_sizeof
(paren
r_struct
id|arpt_get_entries
)paren
op_plus
id|get.size
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
)brace
r_else
id|ret
op_assign
id|get_entries
c_func
(paren
op_amp
id|get
comma
id|user
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_default
suffix:colon
id|duprintf
c_func
(paren
l_string|&quot;do_arpt_get_ctl: unknown request %i&bslash;n&quot;
comma
id|cmd
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* Registration hooks for targets. */
DECL|function|arpt_register_target
r_int
id|arpt_register_target
c_func
(paren
r_struct
id|arpt_target
op_star
id|target
)paren
(brace
r_int
id|ret
suffix:semicolon
id|ret
op_assign
id|down_interruptible
c_func
(paren
op_amp
id|arpt_mutex
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
l_int|0
)paren
r_return
id|ret
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list_named_insert
c_func
(paren
op_amp
id|arpt_target
comma
id|target
)paren
)paren
(brace
id|duprintf
c_func
(paren
l_string|&quot;arpt_register_target: `%s&squot; already in list!&bslash;n&quot;
comma
id|target-&gt;name
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|arpt_mutex
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|arpt_unregister_target
r_void
id|arpt_unregister_target
c_func
(paren
r_struct
id|arpt_target
op_star
id|target
)paren
(brace
id|down
c_func
(paren
op_amp
id|arpt_mutex
)paren
suffix:semicolon
id|LIST_DELETE
c_func
(paren
op_amp
id|arpt_target
comma
id|target
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|arpt_mutex
)paren
suffix:semicolon
)brace
DECL|function|arpt_register_table
r_int
id|arpt_register_table
c_func
(paren
r_struct
id|arpt_table
op_star
id|table
)paren
(brace
r_int
id|ret
suffix:semicolon
r_struct
id|arpt_table_info
op_star
id|newinfo
suffix:semicolon
r_static
r_struct
id|arpt_table_info
id|bootstrap
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_int|0
comma
(brace
l_int|0
)brace
comma
(brace
l_int|0
)brace
comma
(brace
)brace
)brace
suffix:semicolon
id|newinfo
op_assign
id|vmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|arpt_table_info
)paren
op_plus
id|SMP_ALIGN
c_func
(paren
id|table-&gt;table-&gt;size
)paren
op_star
id|NR_CPUS
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|newinfo
)paren
(brace
id|ret
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|newinfo-&gt;entries
comma
id|table-&gt;table-&gt;entries
comma
id|table-&gt;table-&gt;size
)paren
suffix:semicolon
id|ret
op_assign
id|translate_table
c_func
(paren
id|table-&gt;name
comma
id|table-&gt;valid_hooks
comma
id|newinfo
comma
id|table-&gt;table-&gt;size
comma
id|table-&gt;table-&gt;num_entries
comma
id|table-&gt;table-&gt;hook_entry
comma
id|table-&gt;table-&gt;underflow
)paren
suffix:semicolon
id|duprintf
c_func
(paren
l_string|&quot;arpt_register_table: translate table gives %d&bslash;n&quot;
comma
id|ret
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
l_int|0
)paren
(brace
id|vfree
c_func
(paren
id|newinfo
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
id|ret
op_assign
id|down_interruptible
c_func
(paren
op_amp
id|arpt_mutex
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
l_int|0
)paren
(brace
id|vfree
c_func
(paren
id|newinfo
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* Don&squot;t autoload: we&squot;d eat our tail... */
r_if
c_cond
(paren
id|list_named_find
c_func
(paren
op_amp
id|arpt_tables
comma
id|table-&gt;name
)paren
)paren
(brace
id|ret
op_assign
op_minus
id|EEXIST
suffix:semicolon
r_goto
id|free_unlock
suffix:semicolon
)brace
multiline_comment|/* Simplifies replace_table code. */
id|table
op_member_access_from_pointer
r_private
op_assign
op_amp
id|bootstrap
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|replace_table
c_func
(paren
id|table
comma
l_int|0
comma
id|newinfo
comma
op_amp
id|ret
)paren
)paren
r_goto
id|free_unlock
suffix:semicolon
id|duprintf
c_func
(paren
l_string|&quot;table-&gt;private-&gt;number = %u&bslash;n&quot;
comma
id|table
op_member_access_from_pointer
r_private
op_member_access_from_pointer
id|number
)paren
suffix:semicolon
multiline_comment|/* save number of initial entries */
id|table
op_member_access_from_pointer
r_private
op_member_access_from_pointer
id|initial_entries
op_assign
id|table
op_member_access_from_pointer
r_private
op_member_access_from_pointer
id|number
suffix:semicolon
id|table-&gt;lock
op_assign
id|RW_LOCK_UNLOCKED
suffix:semicolon
id|list_prepend
c_func
(paren
op_amp
id|arpt_tables
comma
id|table
)paren
suffix:semicolon
id|unlock
suffix:colon
id|up
c_func
(paren
op_amp
id|arpt_mutex
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
id|free_unlock
suffix:colon
id|vfree
c_func
(paren
id|newinfo
)paren
suffix:semicolon
r_goto
id|unlock
suffix:semicolon
)brace
DECL|function|arpt_unregister_table
r_void
id|arpt_unregister_table
c_func
(paren
r_struct
id|arpt_table
op_star
id|table
)paren
(brace
id|down
c_func
(paren
op_amp
id|arpt_mutex
)paren
suffix:semicolon
id|LIST_DELETE
c_func
(paren
op_amp
id|arpt_tables
comma
id|table
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|arpt_mutex
)paren
suffix:semicolon
multiline_comment|/* Decrease module usage counts and free resources */
id|ARPT_ENTRY_ITERATE
c_func
(paren
id|table
op_member_access_from_pointer
r_private
op_member_access_from_pointer
id|entries
comma
id|table
op_member_access_from_pointer
r_private
op_member_access_from_pointer
id|size
comma
id|cleanup_entry
comma
l_int|NULL
)paren
suffix:semicolon
id|vfree
c_func
(paren
id|table
op_member_access_from_pointer
r_private
)paren
suffix:semicolon
)brace
multiline_comment|/* The built-in targets: standard (NULL) and error. */
DECL|variable|arpt_standard_target
r_static
r_struct
id|arpt_target
id|arpt_standard_target
op_assign
(brace
dot
id|name
op_assign
id|ARPT_STANDARD_TARGET
comma
)brace
suffix:semicolon
DECL|variable|arpt_error_target
r_static
r_struct
id|arpt_target
id|arpt_error_target
op_assign
(brace
dot
id|name
op_assign
id|ARPT_ERROR_TARGET
comma
dot
id|target
op_assign
id|arpt_error
comma
)brace
suffix:semicolon
DECL|variable|arpt_sockopts
r_static
r_struct
id|nf_sockopt_ops
id|arpt_sockopts
op_assign
(brace
dot
id|pf
op_assign
id|PF_INET
comma
dot
id|set_optmin
op_assign
id|ARPT_BASE_CTL
comma
dot
id|set_optmax
op_assign
id|ARPT_SO_SET_MAX
op_plus
l_int|1
comma
dot
id|set
op_assign
id|do_arpt_set_ctl
comma
dot
id|get_optmin
op_assign
id|ARPT_BASE_CTL
comma
dot
id|get_optmax
op_assign
id|ARPT_SO_GET_MAX
op_plus
l_int|1
comma
dot
id|get
op_assign
id|do_arpt_get_ctl
comma
)brace
suffix:semicolon
macro_line|#ifdef CONFIG_PROC_FS
DECL|function|print_name
r_static
r_inline
r_int
id|print_name
c_func
(paren
r_const
r_struct
id|arpt_table
op_star
id|t
comma
id|off_t
id|start_offset
comma
r_char
op_star
id|buffer
comma
r_int
id|length
comma
id|off_t
op_star
id|pos
comma
r_int
r_int
op_star
id|count
)paren
(brace
r_if
c_cond
(paren
(paren
op_star
id|count
)paren
op_increment
op_ge
id|start_offset
)paren
(brace
r_int
r_int
id|namelen
suffix:semicolon
id|namelen
op_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
op_star
id|pos
comma
l_string|&quot;%s&bslash;n&quot;
comma
id|t-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|pos
op_plus
id|namelen
OG
id|length
)paren
(brace
multiline_comment|/* Stop iterating */
r_return
l_int|1
suffix:semicolon
)brace
op_star
id|pos
op_add_assign
id|namelen
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|arpt_get_tables
r_static
r_int
id|arpt_get_tables
c_func
(paren
r_char
op_star
id|buffer
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|length
)paren
(brace
id|off_t
id|pos
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|count
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|down_interruptible
c_func
(paren
op_amp
id|arpt_mutex
)paren
op_ne
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
id|LIST_FIND
c_func
(paren
op_amp
id|arpt_tables
comma
id|print_name
comma
r_struct
id|arpt_table
op_star
comma
id|offset
comma
id|buffer
comma
id|length
comma
op_amp
id|pos
comma
op_amp
id|count
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|arpt_mutex
)paren
suffix:semicolon
multiline_comment|/* `start&squot; hack - see fs/proc/generic.c line ~105 */
op_star
id|start
op_assign
(paren
r_char
op_star
)paren
(paren
(paren
r_int
r_int
)paren
id|count
op_minus
id|offset
)paren
suffix:semicolon
r_return
id|pos
suffix:semicolon
)brace
macro_line|#endif /*CONFIG_PROC_FS*/
DECL|function|init
r_static
r_int
id|__init
id|init
c_func
(paren
r_void
)paren
(brace
r_int
id|ret
suffix:semicolon
multiline_comment|/* Noone else will be downing sem now, so we won&squot;t sleep */
id|down
c_func
(paren
op_amp
id|arpt_mutex
)paren
suffix:semicolon
id|list_append
c_func
(paren
op_amp
id|arpt_target
comma
op_amp
id|arpt_standard_target
)paren
suffix:semicolon
id|list_append
c_func
(paren
op_amp
id|arpt_target
comma
op_amp
id|arpt_error_target
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|arpt_mutex
)paren
suffix:semicolon
multiline_comment|/* Register setsockopt */
id|ret
op_assign
id|nf_register_sockopt
c_func
(paren
op_amp
id|arpt_sockopts
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
(brace
id|duprintf
c_func
(paren
l_string|&quot;Unable to register sockopts.&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_PROC_FS
(brace
r_struct
id|proc_dir_entry
op_star
id|proc
suffix:semicolon
id|proc
op_assign
id|proc_net_create
c_func
(paren
l_string|&quot;arp_tables_names&quot;
comma
l_int|0
comma
id|arpt_get_tables
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|proc
)paren
(brace
id|nf_unregister_sockopt
c_func
(paren
op_amp
id|arpt_sockopts
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|proc-&gt;owner
op_assign
id|THIS_MODULE
suffix:semicolon
)brace
macro_line|#endif
id|printk
c_func
(paren
l_string|&quot;arp_tables: (C) 2002 David S. Miller&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|fini
r_static
r_void
id|__exit
id|fini
c_func
(paren
r_void
)paren
(brace
id|nf_unregister_sockopt
c_func
(paren
op_amp
id|arpt_sockopts
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_PROC_FS
id|proc_net_remove
c_func
(paren
l_string|&quot;arp_tables_names&quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
DECL|variable|arpt_register_table
id|EXPORT_SYMBOL
c_func
(paren
id|arpt_register_table
)paren
suffix:semicolon
DECL|variable|arpt_unregister_table
id|EXPORT_SYMBOL
c_func
(paren
id|arpt_unregister_table
)paren
suffix:semicolon
DECL|variable|arpt_do_table
id|EXPORT_SYMBOL
c_func
(paren
id|arpt_do_table
)paren
suffix:semicolon
DECL|variable|arpt_register_target
id|EXPORT_SYMBOL
c_func
(paren
id|arpt_register_target
)paren
suffix:semicolon
DECL|variable|arpt_unregister_target
id|EXPORT_SYMBOL
c_func
(paren
id|arpt_unregister_target
)paren
suffix:semicolon
DECL|variable|init
id|module_init
c_func
(paren
id|init
)paren
suffix:semicolon
DECL|variable|fini
id|module_exit
c_func
(paren
id|fini
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
eof
