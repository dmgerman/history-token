multiline_comment|/* Kernel module to match suspect packets. */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;linux/ip.h&gt;
macro_line|#include &lt;linux/udp.h&gt;
macro_line|#include &lt;linux/tcp.h&gt;
macro_line|#include &lt;linux/icmp.h&gt;
macro_line|#include &lt;net/checksum.h&gt;
macro_line|#include &lt;linux/netfilter_ipv4/ip_tables.h&gt;
DECL|macro|limpk
mdefine_line|#define limpk(format, args...)&t;&t;&t;&t;&t;&t; &bslash;&n;do {&t;&t;&t;&t;&t;&t;&t;&t;&t; &bslash;&n;&t;if (net_ratelimit())&t;&t;&t;&t;&t;&t; &bslash;&n;&t;&t;printk(&quot;ipt_unclean: %s&quot; format,&t;&t;&t; &bslash;&n;&t;&t;       embedded ? &quot;(embedded packet) &quot; : &quot;&quot; , ## args);  &bslash;&n;} while(0)
DECL|enum|icmp_error_status
r_enum
id|icmp_error_status
(brace
DECL|enumerator|ICMP_MAY_BE_ERROR
id|ICMP_MAY_BE_ERROR
comma
DECL|enumerator|ICMP_IS_ERROR
id|ICMP_IS_ERROR
comma
DECL|enumerator|ICMP_NOT_ERROR
id|ICMP_NOT_ERROR
)brace
suffix:semicolon
DECL|struct|icmp_info
r_struct
id|icmp_info
(brace
DECL|member|min_len
DECL|member|max_len
r_int
id|min_len
comma
id|max_len
suffix:semicolon
DECL|member|err
r_enum
id|icmp_error_status
id|err
suffix:semicolon
DECL|member|min_code
DECL|member|max_code
id|u_int8_t
id|min_code
comma
id|max_code
suffix:semicolon
)brace
suffix:semicolon
r_static
r_int
id|check_ip
c_func
(paren
r_const
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
r_int
id|offset
)paren
suffix:semicolon
multiline_comment|/* ICMP-specific checks. */
r_static
r_int
DECL|function|check_icmp
id|check_icmp
c_func
(paren
r_const
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
r_int
id|offset
comma
r_int
r_int
id|fragoff
comma
r_int
id|more_frags
comma
r_int
id|embedded
)paren
(brace
r_struct
id|icmphdr
id|icmph
suffix:semicolon
r_static
r_struct
id|icmp_info
id|info
(braket
)braket
op_assign
(brace
(braket
id|ICMP_ECHOREPLY
)braket
op_assign
(brace
l_int|8
comma
l_int|65536
comma
id|ICMP_NOT_ERROR
comma
l_int|0
comma
l_int|0
)brace
comma
(braket
id|ICMP_DEST_UNREACH
)braket
op_assign
(brace
l_int|8
op_plus
l_int|28
comma
l_int|65536
comma
id|ICMP_IS_ERROR
comma
l_int|0
comma
l_int|15
)brace
comma
(braket
id|ICMP_SOURCE_QUENCH
)braket
op_assign
(brace
l_int|8
op_plus
l_int|28
comma
l_int|65536
comma
id|ICMP_IS_ERROR
comma
l_int|0
comma
l_int|0
)brace
comma
(braket
id|ICMP_REDIRECT
)braket
op_assign
(brace
l_int|8
op_plus
l_int|28
comma
l_int|65536
comma
id|ICMP_IS_ERROR
comma
l_int|0
comma
l_int|3
)brace
comma
(braket
id|ICMP_ECHO
)braket
op_assign
(brace
l_int|8
comma
l_int|65536
comma
id|ICMP_NOT_ERROR
comma
l_int|0
comma
l_int|0
)brace
comma
multiline_comment|/* Router advertisement. */
(braket
l_int|9
)braket
op_assign
(brace
l_int|8
comma
l_int|8
op_plus
l_int|255
op_star
l_int|8
comma
id|ICMP_NOT_ERROR
comma
l_int|0
comma
l_int|0
)brace
comma
multiline_comment|/* Router solicitation. */
(braket
l_int|10
)braket
op_assign
(brace
l_int|8
comma
l_int|8
comma
id|ICMP_NOT_ERROR
comma
l_int|0
comma
l_int|0
)brace
comma
(braket
id|ICMP_TIME_EXCEEDED
)braket
op_assign
(brace
l_int|8
op_plus
l_int|28
comma
l_int|65536
comma
id|ICMP_IS_ERROR
comma
l_int|0
comma
l_int|1
)brace
comma
(braket
id|ICMP_PARAMETERPROB
)braket
op_assign
(brace
l_int|8
op_plus
l_int|28
comma
l_int|65536
comma
id|ICMP_IS_ERROR
comma
l_int|0
comma
l_int|1
)brace
comma
(braket
id|ICMP_TIMESTAMP
)braket
op_assign
(brace
l_int|20
comma
l_int|20
comma
id|ICMP_NOT_ERROR
comma
l_int|0
comma
l_int|0
)brace
comma
(braket
id|ICMP_TIMESTAMPREPLY
)braket
op_assign
(brace
l_int|20
comma
l_int|20
comma
id|ICMP_NOT_ERROR
comma
l_int|0
comma
l_int|0
)brace
comma
(braket
id|ICMP_INFO_REQUEST
)braket
op_assign
(brace
l_int|8
comma
l_int|65536
comma
id|ICMP_NOT_ERROR
comma
l_int|0
comma
l_int|0
)brace
comma
(braket
id|ICMP_INFO_REPLY
)braket
op_assign
(brace
l_int|8
comma
l_int|65536
comma
id|ICMP_NOT_ERROR
comma
l_int|0
comma
l_int|0
)brace
comma
(braket
id|ICMP_ADDRESS
)braket
op_assign
(brace
l_int|12
comma
l_int|12
comma
id|ICMP_NOT_ERROR
comma
l_int|0
comma
l_int|0
)brace
comma
(braket
id|ICMP_ADDRESSREPLY
)braket
op_assign
(brace
l_int|12
comma
l_int|12
comma
id|ICMP_NOT_ERROR
comma
l_int|0
comma
l_int|0
)brace
)brace
suffix:semicolon
multiline_comment|/* Can&squot;t do anything if it&squot;s a fragment. */
r_if
c_cond
(paren
id|fragoff
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* CHECK: Must have whole header.. */
r_if
c_cond
(paren
id|skb_copy_bits
c_func
(paren
id|skb
comma
id|offset
comma
op_amp
id|icmph
comma
r_sizeof
(paren
id|icmph
)paren
)paren
OL
l_int|0
)paren
(brace
id|limpk
c_func
(paren
l_string|&quot;ICMP len=%u too short&bslash;n&quot;
comma
id|skb-&gt;len
op_minus
id|offset
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* If not embedded in an ICMP error already. */
r_if
c_cond
(paren
op_logical_neg
id|embedded
)paren
(brace
multiline_comment|/* CHECK: Truncated ICMP (even if first fragment). */
r_if
c_cond
(paren
id|icmph.type
OL
r_sizeof
(paren
id|info
)paren
op_div
r_sizeof
(paren
r_struct
id|icmp_info
)paren
op_logical_and
id|info
(braket
id|icmph.type
)braket
dot
id|min_len
op_ne
l_int|0
op_logical_and
id|skb-&gt;len
op_minus
id|offset
OL
id|info
(braket
id|icmph.type
)braket
dot
id|min_len
)paren
(brace
id|limpk
c_func
(paren
l_string|&quot;ICMP type %u len %u too short&bslash;n&quot;
comma
id|icmph.type
comma
id|skb-&gt;len
op_minus
id|offset
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* CHECK: Check within known error ICMPs. */
r_if
c_cond
(paren
id|icmph.type
OL
r_sizeof
(paren
id|info
)paren
op_div
r_sizeof
(paren
r_struct
id|icmp_info
)paren
op_logical_and
id|info
(braket
id|icmph.type
)braket
dot
id|err
op_eq
id|ICMP_IS_ERROR
)paren
(brace
multiline_comment|/* Max IP header size = 60 */
r_char
id|inner
(braket
l_int|60
op_plus
l_int|8
)braket
suffix:semicolon
r_struct
id|iphdr
op_star
id|inner_ip
op_assign
(paren
r_struct
id|iphdr
op_star
)paren
id|inner
suffix:semicolon
multiline_comment|/* CHECK: Embedded packet must be at least&n;&t;&t;&t;   length of iph + 8 bytes. */
r_if
c_cond
(paren
id|skb_copy_bits
c_func
(paren
id|skb
comma
id|offset
op_plus
r_sizeof
(paren
id|icmph
)paren
comma
id|inner
comma
r_sizeof
(paren
r_struct
id|iphdr
)paren
op_plus
l_int|8
)paren
OL
l_int|0
)paren
(brace
id|limpk
c_func
(paren
l_string|&quot;ICMP error internal way too short&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* iphhdr may actually be longer: still need 8&n;                           actual protocol bytes. */
r_if
c_cond
(paren
id|offset
op_plus
r_sizeof
(paren
id|icmph
)paren
op_plus
id|inner_ip-&gt;ihl
op_star
l_int|4
op_plus
l_int|8
OG
id|skb-&gt;len
)paren
(brace
id|limpk
c_func
(paren
l_string|&quot;ICMP error internal too short&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|check_ip
c_func
(paren
id|skb
comma
id|offset
op_plus
r_sizeof
(paren
id|icmph
)paren
)paren
)paren
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* CHECK: Can&squot;t embed ICMP unless known non-error. */
r_if
c_cond
(paren
id|icmph.type
op_ge
r_sizeof
(paren
id|info
)paren
op_div
r_sizeof
(paren
r_struct
id|icmp_info
)paren
op_logical_or
id|info
(braket
id|icmph.type
)braket
dot
id|err
op_ne
id|ICMP_NOT_ERROR
)paren
(brace
id|limpk
c_func
(paren
l_string|&quot;ICMP type %u not embeddable&bslash;n&quot;
comma
id|icmph.type
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/* CHECK: Invalid ICMP codes. */
r_if
c_cond
(paren
id|icmph.type
OL
r_sizeof
(paren
id|info
)paren
op_div
r_sizeof
(paren
r_struct
id|icmp_info
)paren
op_logical_and
(paren
id|icmph.code
template_param
id|info
(braket
id|icmph.type
)braket
dot
id|max_code
)paren
)paren
(brace
id|limpk
c_func
(paren
l_string|&quot;ICMP type=%u code=%u&bslash;n&quot;
comma
id|icmph.type
comma
id|icmph.code
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* CHECK: Above maximum length. */
r_if
c_cond
(paren
id|icmph.type
template_param
id|info
(braket
id|icmph.type
)braket
dot
id|max_len
)paren
(brace
id|limpk
c_func
(paren
l_string|&quot;ICMP type=%u too long: %u bytes&bslash;n&quot;
comma
id|icmph.type
comma
id|skb-&gt;len
op_minus
id|offset
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|icmph.type
)paren
(brace
r_case
id|ICMP_PARAMETERPROB
suffix:colon
(brace
multiline_comment|/* CHECK: Problem param must be within error packet&squot;s&n;&t;&t; * IP header. */
id|u_int32_t
id|arg
op_assign
id|ntohl
c_func
(paren
id|icmph.un.gateway
)paren
suffix:semicolon
r_if
c_cond
(paren
id|icmph.code
op_eq
l_int|0
)paren
(brace
multiline_comment|/* We&squot;ve already made sure it&squot;s long enough. */
r_struct
id|iphdr
id|iph
suffix:semicolon
id|skb_copy_bits
c_func
(paren
id|skb
comma
id|offset
op_plus
r_sizeof
(paren
id|icmph
)paren
comma
op_amp
id|iph
comma
r_sizeof
(paren
id|iph
)paren
)paren
suffix:semicolon
multiline_comment|/* Code 0 means that upper 8 bits is pointer&n;                           to problem. */
r_if
c_cond
(paren
(paren
id|arg
op_rshift
l_int|24
)paren
op_ge
id|iph.ihl
op_star
l_int|4
)paren
(brace
id|limpk
c_func
(paren
l_string|&quot;ICMP PARAMETERPROB ptr = %u&bslash;n&quot;
comma
id|ntohl
c_func
(paren
id|icmph.un.gateway
)paren
op_rshift
l_int|24
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|arg
op_and_assign
l_int|0x00FFFFFF
suffix:semicolon
)brace
multiline_comment|/* CHECK: Rest must be zero. */
r_if
c_cond
(paren
id|arg
)paren
(brace
id|limpk
c_func
(paren
l_string|&quot;ICMP PARAMETERPROB nonzero arg = %u&bslash;n&quot;
comma
id|arg
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
r_case
id|ICMP_TIME_EXCEEDED
suffix:colon
r_case
id|ICMP_SOURCE_QUENCH
suffix:colon
multiline_comment|/* CHECK: Unused must be zero. */
r_if
c_cond
(paren
id|icmph.un.gateway
op_ne
l_int|0
)paren
(brace
id|limpk
c_func
(paren
l_string|&quot;ICMP type=%u unused = %u&bslash;n&quot;
comma
id|icmph.type
comma
id|ntohl
c_func
(paren
id|icmph.un.gateway
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* UDP-specific checks. */
r_static
r_int
DECL|function|check_udp
id|check_udp
c_func
(paren
r_const
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
r_int
id|offset
comma
r_int
r_int
id|fragoff
comma
r_int
id|more_frags
comma
r_int
id|embedded
)paren
(brace
r_struct
id|udphdr
id|udph
suffix:semicolon
multiline_comment|/* Can&squot;t do anything if it&squot;s a fragment. */
r_if
c_cond
(paren
id|fragoff
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* CHECK: Must cover UDP header. */
r_if
c_cond
(paren
id|skb_copy_bits
c_func
(paren
id|skb
comma
id|offset
comma
op_amp
id|udph
comma
r_sizeof
(paren
id|udph
)paren
)paren
OL
l_int|0
)paren
(brace
id|limpk
c_func
(paren
l_string|&quot;UDP len=%u too short&bslash;n&quot;
comma
id|skb-&gt;len
op_minus
id|offset
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* CHECK: Destination port can&squot;t be zero. */
r_if
c_cond
(paren
op_logical_neg
id|udph.dest
)paren
(brace
id|limpk
c_func
(paren
l_string|&quot;UDP zero destination port&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|more_frags
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|embedded
)paren
(brace
multiline_comment|/* CHECK: UDP length must match. */
r_if
c_cond
(paren
id|ntohs
c_func
(paren
id|udph.len
)paren
op_ne
id|skb-&gt;len
op_minus
id|offset
)paren
(brace
id|limpk
c_func
(paren
l_string|&quot;UDP len too short %u vs %u&bslash;n&quot;
comma
id|ntohs
c_func
(paren
id|udph.len
)paren
comma
id|skb-&gt;len
op_minus
id|offset
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* CHECK: UDP length be &gt;= this truncated pkt. */
r_if
c_cond
(paren
id|ntohs
c_func
(paren
id|udph.len
)paren
OL
id|skb-&gt;len
op_minus
id|offset
)paren
(brace
id|limpk
c_func
(paren
l_string|&quot;UDP len too long %u vs %u&bslash;n&quot;
comma
id|ntohs
c_func
(paren
id|udph.len
)paren
comma
id|skb-&gt;len
op_minus
id|offset
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
multiline_comment|/* CHECK: UDP length must be &gt; this frag&squot;s length. */
r_if
c_cond
(paren
id|ntohs
c_func
(paren
id|udph.len
)paren
op_le
id|skb-&gt;len
op_minus
id|offset
)paren
(brace
id|limpk
c_func
(paren
l_string|&quot;UDP fragment len too short %u vs %u&bslash;n&quot;
comma
id|ntohs
c_func
(paren
id|udph.len
)paren
comma
id|skb-&gt;len
op_minus
id|offset
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* TCP-specific checks. */
r_static
r_int
DECL|function|check_tcp
id|check_tcp
c_func
(paren
r_const
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
r_int
id|offset
comma
r_int
r_int
id|fragoff
comma
r_int
id|more_frags
comma
r_int
id|embedded
)paren
(brace
r_struct
id|tcphdr
id|tcph
suffix:semicolon
r_int
r_char
id|opt
(braket
l_int|15
op_star
l_int|4
op_minus
r_sizeof
(paren
r_struct
id|tcphdr
)paren
)braket
suffix:semicolon
id|u32
id|tcpflags
suffix:semicolon
r_int
id|end_of_options
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|i
comma
id|optlen
suffix:semicolon
multiline_comment|/* CHECK: Can&squot;t have offset=1: used to override TCP syn-checks. */
multiline_comment|/* In fact, this is caught below (offset &lt; 516). */
multiline_comment|/* Can&squot;t do anything if it&squot;s a fragment. */
r_if
c_cond
(paren
id|fragoff
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* CHECK: Smaller than minimal TCP hdr. */
r_if
c_cond
(paren
id|skb_copy_bits
c_func
(paren
id|skb
comma
id|offset
comma
op_amp
id|tcph
comma
r_sizeof
(paren
id|tcph
)paren
)paren
OL
l_int|0
)paren
(brace
id|u16
id|ports
(braket
l_int|2
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|embedded
)paren
(brace
id|limpk
c_func
(paren
l_string|&quot;Packet length %u &lt; TCP header.&bslash;n&quot;
comma
id|skb-&gt;len
op_minus
id|offset
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Must have ports available (datalen &gt;= 8), from&n;                   check_icmp which set embedded = 1 */
multiline_comment|/* CHECK: TCP ports inside ICMP error */
id|skb_copy_bits
c_func
(paren
id|skb
comma
id|offset
comma
id|ports
comma
r_sizeof
(paren
id|ports
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ports
(braket
l_int|0
)braket
op_logical_or
op_logical_neg
id|ports
(braket
l_int|1
)braket
)paren
(brace
id|limpk
c_func
(paren
l_string|&quot;Zero TCP ports %u/%u.&bslash;n&quot;
comma
id|htons
c_func
(paren
id|ports
(braket
l_int|0
)braket
)paren
comma
id|htons
c_func
(paren
id|ports
(braket
l_int|1
)braket
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* CHECK: TCP header claims tiny size. */
r_if
c_cond
(paren
id|tcph.doff
op_star
l_int|4
OL
r_sizeof
(paren
id|tcph
)paren
)paren
(brace
id|limpk
c_func
(paren
l_string|&quot;TCP header claims tiny size %u&bslash;n&quot;
comma
id|tcph.doff
op_star
l_int|4
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* CHECK: Packet smaller than actual TCP hdr. */
id|optlen
op_assign
id|tcph.doff
op_star
l_int|4
op_minus
r_sizeof
(paren
id|tcph
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb_copy_bits
c_func
(paren
id|skb
comma
id|offset
op_plus
r_sizeof
(paren
id|tcph
)paren
comma
id|opt
comma
id|optlen
)paren
OL
l_int|0
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|embedded
)paren
(brace
id|limpk
c_func
(paren
l_string|&quot;Packet length %u &lt; actual TCP header.&bslash;n&quot;
comma
id|skb-&gt;len
op_minus
id|offset
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* CHECK: TCP ports non-zero */
r_if
c_cond
(paren
op_logical_neg
id|tcph.source
op_logical_or
op_logical_neg
id|tcph.dest
)paren
(brace
id|limpk
c_func
(paren
l_string|&quot;Zero TCP ports %u/%u.&bslash;n&quot;
comma
id|htons
c_func
(paren
id|tcph.source
)paren
comma
id|htons
c_func
(paren
id|tcph.dest
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|tcpflags
op_assign
id|tcp_flag_word
c_func
(paren
op_amp
id|tcph
)paren
suffix:semicolon
multiline_comment|/* CHECK: TCP reserved bits zero. */
r_if
c_cond
(paren
id|tcpflags
op_amp
id|TCP_RESERVED_BITS
)paren
(brace
id|limpk
c_func
(paren
l_string|&quot;TCP reserved bits not zero&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|tcpflags
op_and_assign
op_complement
(paren
id|TCP_DATA_OFFSET
op_or
id|TCP_FLAG_CWR
op_or
id|TCP_FLAG_ECE
op_or
id|__constant_htonl
c_func
(paren
l_int|0x0000FFFF
)paren
)paren
suffix:semicolon
multiline_comment|/* CHECK: TCP flags. */
r_if
c_cond
(paren
id|tcpflags
op_ne
id|TCP_FLAG_SYN
op_logical_and
id|tcpflags
op_ne
(paren
id|TCP_FLAG_SYN
op_or
id|TCP_FLAG_ACK
)paren
op_logical_and
id|tcpflags
op_ne
id|TCP_FLAG_RST
op_logical_and
id|tcpflags
op_ne
(paren
id|TCP_FLAG_RST
op_or
id|TCP_FLAG_ACK
)paren
op_logical_and
id|tcpflags
op_ne
(paren
id|TCP_FLAG_RST
op_or
id|TCP_FLAG_ACK
op_or
id|TCP_FLAG_PSH
)paren
op_logical_and
id|tcpflags
op_ne
(paren
id|TCP_FLAG_FIN
op_or
id|TCP_FLAG_ACK
)paren
op_logical_and
id|tcpflags
op_ne
id|TCP_FLAG_ACK
op_logical_and
id|tcpflags
op_ne
(paren
id|TCP_FLAG_ACK
op_or
id|TCP_FLAG_PSH
)paren
op_logical_and
id|tcpflags
op_ne
(paren
id|TCP_FLAG_ACK
op_or
id|TCP_FLAG_URG
)paren
op_logical_and
id|tcpflags
op_ne
(paren
id|TCP_FLAG_ACK
op_or
id|TCP_FLAG_URG
op_or
id|TCP_FLAG_PSH
)paren
op_logical_and
id|tcpflags
op_ne
(paren
id|TCP_FLAG_FIN
op_or
id|TCP_FLAG_ACK
op_or
id|TCP_FLAG_PSH
)paren
op_logical_and
id|tcpflags
op_ne
(paren
id|TCP_FLAG_FIN
op_or
id|TCP_FLAG_ACK
op_or
id|TCP_FLAG_URG
)paren
op_logical_and
id|tcpflags
op_ne
(paren
id|TCP_FLAG_FIN
op_or
id|TCP_FLAG_ACK
op_or
id|TCP_FLAG_URG
op_or
id|TCP_FLAG_PSH
)paren
)paren
(brace
id|limpk
c_func
(paren
l_string|&quot;TCP flags bad: 0x%04X&bslash;n&quot;
comma
id|ntohl
c_func
(paren
id|tcpflags
)paren
op_rshift
l_int|16
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|optlen
suffix:semicolon
)paren
(brace
r_switch
c_cond
(paren
id|opt
(braket
id|i
)braket
)paren
(brace
r_case
l_int|0
suffix:colon
id|end_of_options
op_assign
l_int|1
suffix:semicolon
id|i
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|i
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
multiline_comment|/* CHECK: options after EOO. */
r_if
c_cond
(paren
id|end_of_options
)paren
(brace
id|limpk
c_func
(paren
l_string|&quot;TCP option %u after end&bslash;n&quot;
comma
id|opt
(braket
id|i
)braket
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* CHECK: options at tail. */
r_else
r_if
c_cond
(paren
id|i
op_plus
l_int|1
op_ge
id|optlen
)paren
(brace
id|limpk
c_func
(paren
l_string|&quot;TCP option %u at tail&bslash;n&quot;
comma
id|opt
(braket
id|i
)braket
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* CHECK: zero-length options. */
r_else
r_if
c_cond
(paren
id|opt
(braket
id|i
op_plus
l_int|1
)braket
op_eq
l_int|0
)paren
(brace
id|limpk
c_func
(paren
l_string|&quot;TCP option %u 0 len&bslash;n&quot;
comma
id|opt
(braket
id|i
)braket
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* CHECK: oversize options. */
r_else
r_if
c_cond
(paren
id|i
op_plus
id|opt
(braket
id|i
op_plus
l_int|1
)braket
OG
id|optlen
)paren
(brace
id|limpk
c_func
(paren
l_string|&quot;TCP option %u at %u too long&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|opt
(braket
id|i
)braket
comma
id|i
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Move to next option */
id|i
op_add_assign
id|opt
(braket
id|i
op_plus
l_int|1
)braket
suffix:semicolon
)brace
)brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Returns 1 if ok */
multiline_comment|/* Standard IP checks. */
r_static
r_int
DECL|function|check_ip
id|check_ip
c_func
(paren
r_const
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
r_int
id|offset
)paren
(brace
r_int
id|end_of_options
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|datalen
comma
id|optlen
suffix:semicolon
r_int
r_int
id|i
suffix:semicolon
r_int
r_int
id|fragoff
suffix:semicolon
r_struct
id|iphdr
id|iph
suffix:semicolon
r_int
r_char
id|opt
(braket
l_int|15
op_star
l_int|4
op_minus
r_sizeof
(paren
r_struct
id|iphdr
)paren
)braket
suffix:semicolon
r_int
id|embedded
op_assign
id|offset
suffix:semicolon
multiline_comment|/* Should only happen for local outgoing raw-socket packets. */
multiline_comment|/* CHECK: length &gt;= ip header. */
r_if
c_cond
(paren
id|skb_copy_bits
c_func
(paren
id|skb
comma
id|offset
comma
op_amp
id|iph
comma
r_sizeof
(paren
id|iph
)paren
)paren
OL
l_int|0
)paren
(brace
id|limpk
c_func
(paren
l_string|&quot;Packet length %u &lt; IP header.&bslash;n&quot;
comma
id|skb-&gt;len
op_minus
id|offset
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|iph.ihl
op_star
l_int|4
OL
r_sizeof
(paren
id|iph
)paren
)paren
(brace
id|limpk
c_func
(paren
l_string|&quot;IP len %u &lt; minimum IP header.&bslash;n&quot;
comma
id|iph.ihl
op_star
l_int|4
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|optlen
op_assign
id|iph.ihl
op_star
l_int|4
op_minus
r_sizeof
(paren
id|iph
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb_copy_bits
c_func
(paren
id|skb
comma
id|offset
op_plus
r_sizeof
(paren
r_struct
id|iphdr
)paren
comma
id|opt
comma
id|optlen
)paren
OL
l_int|0
)paren
(brace
id|limpk
c_func
(paren
l_string|&quot;Packet length %u &lt; IP header %u.&bslash;n&quot;
comma
id|skb-&gt;len
op_minus
id|offset
comma
id|iph.ihl
op_star
l_int|4
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|fragoff
op_assign
(paren
id|ntohs
c_func
(paren
id|iph.frag_off
)paren
op_amp
id|IP_OFFSET
)paren
suffix:semicolon
id|datalen
op_assign
id|skb-&gt;len
op_minus
(paren
id|offset
op_plus
r_sizeof
(paren
r_struct
id|iphdr
)paren
op_plus
id|optlen
)paren
suffix:semicolon
multiline_comment|/* CHECK: Embedded fragment. */
r_if
c_cond
(paren
id|offset
op_logical_and
id|fragoff
)paren
(brace
id|limpk
c_func
(paren
l_string|&quot;Embedded fragment.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|optlen
suffix:semicolon
)paren
(brace
r_switch
c_cond
(paren
id|opt
(braket
id|i
)braket
)paren
(brace
r_case
l_int|0
suffix:colon
id|end_of_options
op_assign
l_int|1
suffix:semicolon
id|i
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|i
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
multiline_comment|/* CHECK: options after EOO. */
r_if
c_cond
(paren
id|end_of_options
)paren
(brace
id|limpk
c_func
(paren
l_string|&quot;IP option %u after end&bslash;n&quot;
comma
id|opt
(braket
id|i
)braket
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* CHECK: options at tail. */
r_else
r_if
c_cond
(paren
id|i
op_plus
l_int|1
op_ge
id|optlen
)paren
(brace
id|limpk
c_func
(paren
l_string|&quot;IP option %u at tail&bslash;n&quot;
comma
id|opt
(braket
id|i
)braket
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* CHECK: zero-length or one-length options. */
r_else
r_if
c_cond
(paren
id|opt
(braket
id|i
op_plus
l_int|1
)braket
OL
l_int|2
)paren
(brace
id|limpk
c_func
(paren
l_string|&quot;IP option %u %u len&bslash;n&quot;
comma
id|opt
(braket
id|i
)braket
comma
id|opt
(braket
id|i
op_plus
l_int|1
)braket
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* CHECK: oversize options. */
r_else
r_if
c_cond
(paren
id|i
op_plus
id|opt
(braket
id|i
op_plus
l_int|1
)braket
OG
id|optlen
)paren
(brace
id|limpk
c_func
(paren
l_string|&quot;IP option %u at %u too long&bslash;n&quot;
comma
id|opt
(braket
id|i
)braket
comma
id|i
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Move to next option */
id|i
op_add_assign
id|opt
(braket
id|i
op_plus
l_int|1
)braket
suffix:semicolon
)brace
)brace
multiline_comment|/* Fragment checks. */
multiline_comment|/* CHECK: More fragments, but doesn&squot;t fill 8-byte boundary. */
r_if
c_cond
(paren
(paren
id|ntohs
c_func
(paren
id|iph.frag_off
)paren
op_amp
id|IP_MF
)paren
op_logical_and
(paren
id|ntohs
c_func
(paren
id|iph.tot_len
)paren
op_mod
l_int|8
)paren
op_ne
l_int|0
)paren
(brace
id|limpk
c_func
(paren
l_string|&quot;Truncated fragment %u long.&bslash;n&quot;
comma
id|ntohs
c_func
(paren
id|iph.tot_len
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* CHECK: Oversize fragment a-la Ping of Death. */
r_if
c_cond
(paren
id|fragoff
op_star
l_int|8
op_plus
id|datalen
OG
l_int|65535
)paren
(brace
id|limpk
c_func
(paren
l_string|&quot;Oversize fragment to %u.&bslash;n&quot;
comma
id|fragoff
op_star
l_int|8
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* CHECK: DF set and fragoff or MF set. */
r_if
c_cond
(paren
(paren
id|ntohs
c_func
(paren
id|iph.frag_off
)paren
op_amp
id|IP_DF
)paren
op_logical_and
(paren
id|fragoff
op_logical_or
(paren
id|ntohs
c_func
(paren
id|iph.frag_off
)paren
op_amp
id|IP_MF
)paren
)paren
)paren
(brace
id|limpk
c_func
(paren
l_string|&quot;DF set and offset=%u, MF=%u.&bslash;n&quot;
comma
id|fragoff
comma
id|ntohs
c_func
(paren
id|iph.frag_off
)paren
op_amp
id|IP_MF
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* CHECK: Zero-sized fragments. */
r_if
c_cond
(paren
(paren
id|fragoff
op_logical_or
(paren
id|ntohs
c_func
(paren
id|iph.frag_off
)paren
op_amp
id|IP_MF
)paren
)paren
op_logical_and
id|datalen
op_eq
l_int|0
)paren
(brace
id|limpk
c_func
(paren
l_string|&quot;Zero size fragment offset=%u&bslash;n&quot;
comma
id|fragoff
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Note: we can have even middle fragments smaller than this:&n;&t;   consider a large packet passing through a 600MTU then&n;&t;   576MTU link: this gives a fragment of 24 data bytes.  But&n;&t;   everyone packs fragments largest first, hence a fragment&n;&t;   can&squot;t START before 576 - MAX_IP_HEADER_LEN. */
multiline_comment|/* Used to be min-size 576: I recall Alan Cox saying ax25 goes&n;&t;   down to 128 (576 taken from RFC 791: All hosts must be&n;&t;   prepared to accept datagrams of up to 576 octets).  Use 128&n;&t;   here. */
DECL|macro|MIN_LIKELY_MTU
mdefine_line|#define MIN_LIKELY_MTU 128
multiline_comment|/* CHECK: Min size of first frag = 128. */
r_if
c_cond
(paren
(paren
id|ntohs
c_func
(paren
id|iph.frag_off
)paren
op_amp
id|IP_MF
)paren
op_logical_and
id|fragoff
op_eq
l_int|0
op_logical_and
id|ntohs
c_func
(paren
id|iph.tot_len
)paren
OL
id|MIN_LIKELY_MTU
)paren
(brace
id|limpk
c_func
(paren
l_string|&quot;First fragment size %u &lt; %u&bslash;n&quot;
comma
id|ntohs
c_func
(paren
id|iph.tot_len
)paren
comma
id|MIN_LIKELY_MTU
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* CHECK: Min offset of frag = 128 - IP hdr len. */
r_if
c_cond
(paren
id|fragoff
op_logical_and
id|fragoff
op_star
l_int|8
OL
id|MIN_LIKELY_MTU
op_minus
id|iph.ihl
op_star
l_int|4
)paren
(brace
id|limpk
c_func
(paren
l_string|&quot;Fragment starts at %u &lt; %u&bslash;n&quot;
comma
id|fragoff
op_star
l_int|8
comma
id|MIN_LIKELY_MTU
op_minus
id|iph.ihl
op_star
l_int|4
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* CHECK: Protocol specification non-zero. */
r_if
c_cond
(paren
id|iph.protocol
op_eq
l_int|0
)paren
(brace
id|limpk
c_func
(paren
l_string|&quot;Zero protocol&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* FIXME: This is already checked for in &quot;Oversize fragment&quot;&n;           above --RR */
multiline_comment|/* CHECK: Do not use what is unused.&n;&t; * First bit of fragmentation flags should be unused.&n;&t; * May be used by OS fingerprinting tools.&n;&t; * 04 Jun 2002, Maciej Soltysiak, solt@dns.toxicfilms.tv&n;&t; */
r_if
c_cond
(paren
id|ntohs
c_func
(paren
id|iph.frag_off
)paren
op_rshift
l_int|15
)paren
(brace
id|limpk
c_func
(paren
l_string|&quot;IP unused bit set&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Per-protocol checks. */
r_switch
c_cond
(paren
id|iph.protocol
)paren
(brace
r_case
id|IPPROTO_ICMP
suffix:colon
r_return
id|check_icmp
c_func
(paren
id|skb
comma
id|offset
op_plus
id|iph.ihl
op_star
l_int|4
comma
id|fragoff
comma
(paren
id|ntohs
c_func
(paren
id|iph.frag_off
)paren
op_amp
id|IP_MF
)paren
comma
id|embedded
)paren
suffix:semicolon
r_case
id|IPPROTO_UDP
suffix:colon
r_return
id|check_udp
c_func
(paren
id|skb
comma
id|offset
op_plus
id|iph.ihl
op_star
l_int|4
comma
id|fragoff
comma
(paren
id|ntohs
c_func
(paren
id|iph.frag_off
)paren
op_amp
id|IP_MF
)paren
comma
id|embedded
)paren
suffix:semicolon
r_case
id|IPPROTO_TCP
suffix:colon
r_return
id|check_tcp
c_func
(paren
id|skb
comma
id|offset
op_plus
id|iph.ihl
op_star
l_int|4
comma
id|fragoff
comma
(paren
id|ntohs
c_func
(paren
id|iph.frag_off
)paren
op_amp
id|IP_MF
)paren
comma
id|embedded
)paren
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* Ignorance is bliss. */
r_return
l_int|1
suffix:semicolon
)brace
)brace
r_static
r_int
DECL|function|match
id|match
c_func
(paren
r_const
r_struct
id|sk_buff
op_star
id|skb
comma
r_const
r_struct
id|net_device
op_star
id|in
comma
r_const
r_struct
id|net_device
op_star
id|out
comma
r_const
r_void
op_star
id|matchinfo
comma
r_int
id|offset
comma
r_int
op_star
id|hotdrop
)paren
(brace
r_return
op_logical_neg
id|check_ip
c_func
(paren
id|skb
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* Called when user tries to insert an entry of this type. */
r_static
r_int
DECL|function|checkentry
id|checkentry
c_func
(paren
r_const
r_char
op_star
id|tablename
comma
r_const
r_struct
id|ipt_ip
op_star
id|ip
comma
r_void
op_star
id|matchinfo
comma
r_int
r_int
id|matchsize
comma
r_int
r_int
id|hook_mask
)paren
(brace
r_if
c_cond
(paren
id|matchsize
op_ne
id|IPT_ALIGN
c_func
(paren
l_int|0
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|variable|unclean_match
r_static
r_struct
id|ipt_match
id|unclean_match
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;unclean&quot;
comma
dot
id|match
op_assign
op_amp
id|match
comma
dot
id|checkentry
op_assign
op_amp
id|checkentry
comma
dot
id|me
op_assign
id|THIS_MODULE
comma
)brace
suffix:semicolon
DECL|function|init
r_static
r_int
id|__init
id|init
c_func
(paren
r_void
)paren
(brace
r_return
id|ipt_register_match
c_func
(paren
op_amp
id|unclean_match
)paren
suffix:semicolon
)brace
DECL|function|fini
r_static
r_void
id|__exit
id|fini
c_func
(paren
r_void
)paren
(brace
id|ipt_unregister_match
c_func
(paren
op_amp
id|unclean_match
)paren
suffix:semicolon
)brace
DECL|variable|init
id|module_init
c_func
(paren
id|init
)paren
suffix:semicolon
DECL|variable|fini
id|module_exit
c_func
(paren
id|fini
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
eof
