multiline_comment|/*&n; * IPVS         An implementation of the IP virtual server support for the&n; *              LINUX operating system.  IPVS is now implemented as a module&n; *              over the Netfilter framework. IPVS can be used to build a&n; *              high-performance and highly available server based on a&n; *              cluster of servers.&n; *&n; * Version:     $Id: ip_vs_conn.c,v 1.31 2003/04/18 09:03:16 wensong Exp $&n; *&n; * Authors:     Wensong Zhang &lt;wensong@linuxvirtualserver.org&gt;&n; *              Peter Kese &lt;peter.kese@ijs.si&gt;&n; *              Julian Anastasov &lt;ja@ssi.bg&gt;&n; *&n; *              This program is free software; you can redistribute it and/or&n; *              modify it under the terms of the GNU General Public License&n; *              as published by the Free Software Foundation; either version&n; *              2 of the License, or (at your option) any later version.&n; *&n; * The IPVS code for kernel 2.2 was done by Wensong Zhang and Peter Kese,&n; * with changes/fixes from Julian Anastasov, Lars Marowsky-Bree, Horms&n; * and others. Many code here is taken from IP MASQ code of kernel 2.2.&n; *&n; * Changes:&n; *&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/compiler.h&gt;
macro_line|#include &lt;linux/vmalloc.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;&t;&t;/* for proc_net_* */
macro_line|#include &lt;linux/seq_file.h&gt;
macro_line|#include &lt;linux/jhash.h&gt;
macro_line|#include &lt;linux/random.h&gt;
macro_line|#include &lt;net/ip_vs.h&gt;
multiline_comment|/*&n; *  Connection hash table: for input and output packets lookups of IPVS&n; */
DECL|variable|ip_vs_conn_tab
r_static
r_struct
id|list_head
op_star
id|ip_vs_conn_tab
suffix:semicolon
multiline_comment|/*  SLAB cache for IPVS connections */
DECL|variable|ip_vs_conn_cachep
r_static
id|kmem_cache_t
op_star
id|ip_vs_conn_cachep
suffix:semicolon
multiline_comment|/*  counter for current IPVS connections */
DECL|variable|ip_vs_conn_count
r_static
id|atomic_t
id|ip_vs_conn_count
op_assign
id|ATOMIC_INIT
c_func
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/*  counter for no client port connections */
DECL|variable|ip_vs_conn_no_cport_cnt
r_static
id|atomic_t
id|ip_vs_conn_no_cport_cnt
op_assign
id|ATOMIC_INIT
c_func
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* random value for IPVS connection hash */
DECL|variable|ip_vs_conn_rnd
r_static
r_int
r_int
id|ip_vs_conn_rnd
suffix:semicolon
multiline_comment|/*&n; *  Fine locking granularity for big connection hash table&n; */
DECL|macro|CT_LOCKARRAY_BITS
mdefine_line|#define CT_LOCKARRAY_BITS  4
DECL|macro|CT_LOCKARRAY_SIZE
mdefine_line|#define CT_LOCKARRAY_SIZE  (1&lt;&lt;CT_LOCKARRAY_BITS)
DECL|macro|CT_LOCKARRAY_MASK
mdefine_line|#define CT_LOCKARRAY_MASK  (CT_LOCKARRAY_SIZE-1)
DECL|struct|ip_vs_aligned_lock
r_struct
id|ip_vs_aligned_lock
(brace
DECL|member|l
id|rwlock_t
id|l
suffix:semicolon
)brace
id|__attribute__
c_func
(paren
(paren
id|__aligned__
c_func
(paren
id|SMP_CACHE_BYTES
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/* lock array for conn table */
r_struct
id|ip_vs_aligned_lock
DECL|variable|__cacheline_aligned
id|__ip_vs_conntbl_lock_array
(braket
id|CT_LOCKARRAY_SIZE
)braket
id|__cacheline_aligned
suffix:semicolon
DECL|function|ct_read_lock
r_static
r_inline
r_void
id|ct_read_lock
c_func
(paren
r_int
id|key
)paren
(brace
id|read_lock
c_func
(paren
op_amp
id|__ip_vs_conntbl_lock_array
(braket
id|key
op_amp
id|CT_LOCKARRAY_MASK
)braket
dot
id|l
)paren
suffix:semicolon
)brace
DECL|function|ct_read_unlock
r_static
r_inline
r_void
id|ct_read_unlock
c_func
(paren
r_int
id|key
)paren
(brace
id|read_unlock
c_func
(paren
op_amp
id|__ip_vs_conntbl_lock_array
(braket
id|key
op_amp
id|CT_LOCKARRAY_MASK
)braket
dot
id|l
)paren
suffix:semicolon
)brace
DECL|function|ct_write_lock
r_static
r_inline
r_void
id|ct_write_lock
c_func
(paren
r_int
id|key
)paren
(brace
id|write_lock
c_func
(paren
op_amp
id|__ip_vs_conntbl_lock_array
(braket
id|key
op_amp
id|CT_LOCKARRAY_MASK
)braket
dot
id|l
)paren
suffix:semicolon
)brace
DECL|function|ct_write_unlock
r_static
r_inline
r_void
id|ct_write_unlock
c_func
(paren
r_int
id|key
)paren
(brace
id|write_unlock
c_func
(paren
op_amp
id|__ip_vs_conntbl_lock_array
(braket
id|key
op_amp
id|CT_LOCKARRAY_MASK
)braket
dot
id|l
)paren
suffix:semicolon
)brace
DECL|function|ct_read_lock_bh
r_static
r_inline
r_void
id|ct_read_lock_bh
c_func
(paren
r_int
id|key
)paren
(brace
id|read_lock_bh
c_func
(paren
op_amp
id|__ip_vs_conntbl_lock_array
(braket
id|key
op_amp
id|CT_LOCKARRAY_MASK
)braket
dot
id|l
)paren
suffix:semicolon
)brace
DECL|function|ct_read_unlock_bh
r_static
r_inline
r_void
id|ct_read_unlock_bh
c_func
(paren
r_int
id|key
)paren
(brace
id|read_unlock_bh
c_func
(paren
op_amp
id|__ip_vs_conntbl_lock_array
(braket
id|key
op_amp
id|CT_LOCKARRAY_MASK
)braket
dot
id|l
)paren
suffix:semicolon
)brace
DECL|function|ct_write_lock_bh
r_static
r_inline
r_void
id|ct_write_lock_bh
c_func
(paren
r_int
id|key
)paren
(brace
id|write_lock_bh
c_func
(paren
op_amp
id|__ip_vs_conntbl_lock_array
(braket
id|key
op_amp
id|CT_LOCKARRAY_MASK
)braket
dot
id|l
)paren
suffix:semicolon
)brace
DECL|function|ct_write_unlock_bh
r_static
r_inline
r_void
id|ct_write_unlock_bh
c_func
(paren
r_int
id|key
)paren
(brace
id|write_unlock_bh
c_func
(paren
op_amp
id|__ip_vs_conntbl_lock_array
(braket
id|key
op_amp
id|CT_LOCKARRAY_MASK
)braket
dot
id|l
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Returns hash value for IPVS connection entry&n; */
DECL|function|ip_vs_conn_hashkey
r_static
r_int
r_int
id|ip_vs_conn_hashkey
c_func
(paren
r_int
id|proto
comma
id|__u32
id|addr
comma
id|__u16
id|port
)paren
(brace
r_return
id|jhash_3words
c_func
(paren
id|addr
comma
id|port
comma
id|proto
comma
id|ip_vs_conn_rnd
)paren
op_amp
id|IP_VS_CONN_TAB_MASK
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Hashes ip_vs_conn in ip_vs_conn_tab by proto,addr,port.&n; *&t;returns bool success.&n; */
DECL|function|ip_vs_conn_hash
r_static
r_inline
r_int
id|ip_vs_conn_hash
c_func
(paren
r_struct
id|ip_vs_conn
op_star
id|cp
)paren
(brace
r_int
id|hash
suffix:semicolon
r_if
c_cond
(paren
id|cp-&gt;flags
op_amp
id|IP_VS_CONN_F_HASHED
)paren
(brace
id|IP_VS_ERR
c_func
(paren
l_string|&quot;ip_vs_conn_hash(): request for already hashed, &quot;
l_string|&quot;called from %p&bslash;n&quot;
comma
id|__builtin_return_address
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Hash by protocol, client address and port */
id|hash
op_assign
id|ip_vs_conn_hashkey
c_func
(paren
id|cp-&gt;protocol
comma
id|cp-&gt;caddr
comma
id|cp-&gt;cport
)paren
suffix:semicolon
id|ct_write_lock
c_func
(paren
id|hash
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|cp-&gt;c_list
comma
op_amp
id|ip_vs_conn_tab
(braket
id|hash
)braket
)paren
suffix:semicolon
id|cp-&gt;flags
op_or_assign
id|IP_VS_CONN_F_HASHED
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|cp-&gt;refcnt
)paren
suffix:semicolon
id|ct_write_unlock
c_func
(paren
id|hash
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;UNhashes ip_vs_conn from ip_vs_conn_tab.&n; *&t;returns bool success.&n; */
DECL|function|ip_vs_conn_unhash
r_static
r_inline
r_int
id|ip_vs_conn_unhash
c_func
(paren
r_struct
id|ip_vs_conn
op_star
id|cp
)paren
(brace
r_int
id|hash
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|cp-&gt;flags
op_amp
id|IP_VS_CONN_F_HASHED
)paren
)paren
(brace
id|IP_VS_ERR
c_func
(paren
l_string|&quot;ip_vs_conn_unhash(): request for unhash flagged, &quot;
l_string|&quot;called from %p&bslash;n&quot;
comma
id|__builtin_return_address
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* unhash it and decrease its reference counter */
id|hash
op_assign
id|ip_vs_conn_hashkey
c_func
(paren
id|cp-&gt;protocol
comma
id|cp-&gt;caddr
comma
id|cp-&gt;cport
)paren
suffix:semicolon
id|ct_write_lock
c_func
(paren
id|hash
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|cp-&gt;c_list
)paren
suffix:semicolon
id|cp-&gt;flags
op_and_assign
op_complement
id|IP_VS_CONN_F_HASHED
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|cp-&gt;refcnt
)paren
suffix:semicolon
id|ct_write_unlock
c_func
(paren
id|hash
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; *  Gets ip_vs_conn associated with supplied parameters in the ip_vs_conn_tab.&n; *  Called for pkts coming from OUTside-to-INside.&n; *&t;s_addr, s_port: pkt source address (foreign host)&n; *&t;d_addr, d_port: pkt dest address (load balancer)&n; */
DECL|function|__ip_vs_conn_in_get
r_static
r_inline
r_struct
id|ip_vs_conn
op_star
id|__ip_vs_conn_in_get
(paren
r_int
id|protocol
comma
id|__u32
id|s_addr
comma
id|__u16
id|s_port
comma
id|__u32
id|d_addr
comma
id|__u16
id|d_port
)paren
(brace
r_int
id|hash
suffix:semicolon
r_struct
id|ip_vs_conn
op_star
id|cp
suffix:semicolon
id|hash
op_assign
id|ip_vs_conn_hashkey
c_func
(paren
id|protocol
comma
id|s_addr
comma
id|s_port
)paren
suffix:semicolon
id|ct_read_lock
c_func
(paren
id|hash
)paren
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|cp
comma
op_amp
id|ip_vs_conn_tab
(braket
id|hash
)braket
comma
id|c_list
)paren
(brace
r_if
c_cond
(paren
id|s_addr
op_eq
id|cp-&gt;caddr
op_logical_and
id|s_port
op_eq
id|cp-&gt;cport
op_logical_and
id|d_port
op_eq
id|cp-&gt;vport
op_logical_and
id|d_addr
op_eq
id|cp-&gt;vaddr
op_logical_and
id|protocol
op_eq
id|cp-&gt;protocol
)paren
(brace
multiline_comment|/* HIT */
id|atomic_inc
c_func
(paren
op_amp
id|cp-&gt;refcnt
)paren
suffix:semicolon
id|ct_read_unlock
c_func
(paren
id|hash
)paren
suffix:semicolon
r_return
id|cp
suffix:semicolon
)brace
)brace
id|ct_read_unlock
c_func
(paren
id|hash
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|ip_vs_conn_in_get
r_struct
id|ip_vs_conn
op_star
id|ip_vs_conn_in_get
(paren
r_int
id|protocol
comma
id|__u32
id|s_addr
comma
id|__u16
id|s_port
comma
id|__u32
id|d_addr
comma
id|__u16
id|d_port
)paren
(brace
r_struct
id|ip_vs_conn
op_star
id|cp
suffix:semicolon
id|cp
op_assign
id|__ip_vs_conn_in_get
c_func
(paren
id|protocol
comma
id|s_addr
comma
id|s_port
comma
id|d_addr
comma
id|d_port
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cp
op_logical_and
id|atomic_read
c_func
(paren
op_amp
id|ip_vs_conn_no_cport_cnt
)paren
)paren
id|cp
op_assign
id|__ip_vs_conn_in_get
c_func
(paren
id|protocol
comma
id|s_addr
comma
l_int|0
comma
id|d_addr
comma
id|d_port
)paren
suffix:semicolon
id|IP_VS_DBG
c_func
(paren
l_int|7
comma
l_string|&quot;lookup/in %s %u.%u.%u.%u:%d-&gt;%u.%u.%u.%u:%d %s&bslash;n&quot;
comma
id|ip_vs_proto_name
c_func
(paren
id|protocol
)paren
comma
id|NIPQUAD
c_func
(paren
id|s_addr
)paren
comma
id|ntohs
c_func
(paren
id|s_port
)paren
comma
id|NIPQUAD
c_func
(paren
id|d_addr
)paren
comma
id|ntohs
c_func
(paren
id|d_port
)paren
comma
id|cp
ques
c_cond
l_string|&quot;hit&quot;
suffix:colon
l_string|&quot;not hit&quot;
)paren
suffix:semicolon
r_return
id|cp
suffix:semicolon
)brace
multiline_comment|/*&n; *  Gets ip_vs_conn associated with supplied parameters in the ip_vs_conn_tab.&n; *  Called for pkts coming from inside-to-OUTside.&n; *&t;s_addr, s_port: pkt source address (inside host)&n; *&t;d_addr, d_port: pkt dest address (foreign host)&n; */
DECL|function|ip_vs_conn_out_get
r_struct
id|ip_vs_conn
op_star
id|ip_vs_conn_out_get
(paren
r_int
id|protocol
comma
id|__u32
id|s_addr
comma
id|__u16
id|s_port
comma
id|__u32
id|d_addr
comma
id|__u16
id|d_port
)paren
(brace
r_int
id|hash
suffix:semicolon
r_struct
id|ip_vs_conn
op_star
id|cp
comma
op_star
id|ret
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Check for &quot;full&quot; addressed entries&n;&t; */
id|hash
op_assign
id|ip_vs_conn_hashkey
c_func
(paren
id|protocol
comma
id|d_addr
comma
id|d_port
)paren
suffix:semicolon
id|ct_read_lock
c_func
(paren
id|hash
)paren
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|cp
comma
op_amp
id|ip_vs_conn_tab
(braket
id|hash
)braket
comma
id|c_list
)paren
(brace
r_if
c_cond
(paren
id|d_addr
op_eq
id|cp-&gt;caddr
op_logical_and
id|d_port
op_eq
id|cp-&gt;cport
op_logical_and
id|s_port
op_eq
id|cp-&gt;dport
op_logical_and
id|s_addr
op_eq
id|cp-&gt;daddr
op_logical_and
id|protocol
op_eq
id|cp-&gt;protocol
)paren
(brace
multiline_comment|/* HIT */
id|atomic_inc
c_func
(paren
op_amp
id|cp-&gt;refcnt
)paren
suffix:semicolon
id|ret
op_assign
id|cp
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|ct_read_unlock
c_func
(paren
id|hash
)paren
suffix:semicolon
id|IP_VS_DBG
c_func
(paren
l_int|7
comma
l_string|&quot;lookup/out %s %u.%u.%u.%u:%d-&gt;%u.%u.%u.%u:%d %s&bslash;n&quot;
comma
id|ip_vs_proto_name
c_func
(paren
id|protocol
)paren
comma
id|NIPQUAD
c_func
(paren
id|s_addr
)paren
comma
id|ntohs
c_func
(paren
id|s_port
)paren
comma
id|NIPQUAD
c_func
(paren
id|d_addr
)paren
comma
id|ntohs
c_func
(paren
id|d_port
)paren
comma
id|ret
ques
c_cond
l_string|&quot;hit&quot;
suffix:colon
l_string|&quot;not hit&quot;
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; *      Put back the conn and restart its timer with its timeout&n; */
DECL|function|ip_vs_conn_put
r_void
id|ip_vs_conn_put
c_func
(paren
r_struct
id|ip_vs_conn
op_star
id|cp
)paren
(brace
multiline_comment|/* reset it expire in its timeout */
id|mod_timer
c_func
(paren
op_amp
id|cp-&gt;timer
comma
id|jiffies
op_plus
id|cp-&gt;timeout
)paren
suffix:semicolon
id|__ip_vs_conn_put
c_func
(paren
id|cp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Fill a no_client_port connection with a client port number&n; */
DECL|function|ip_vs_conn_fill_cport
r_void
id|ip_vs_conn_fill_cport
c_func
(paren
r_struct
id|ip_vs_conn
op_star
id|cp
comma
id|__u16
id|cport
)paren
(brace
id|atomic_dec
c_func
(paren
op_amp
id|ip_vs_conn_no_cport_cnt
)paren
suffix:semicolon
id|ip_vs_conn_unhash
c_func
(paren
id|cp
)paren
suffix:semicolon
id|cp-&gt;flags
op_and_assign
op_complement
id|IP_VS_CONN_F_NO_CPORT
suffix:semicolon
id|cp-&gt;cport
op_assign
id|cport
suffix:semicolon
multiline_comment|/* hash on new dport */
id|ip_vs_conn_hash
c_func
(paren
id|cp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Bind a connection entry with the corresponding packet_xmit.&n; *&t;Called by ip_vs_conn_new.&n; */
DECL|function|ip_vs_bind_xmit
r_static
r_inline
r_void
id|ip_vs_bind_xmit
c_func
(paren
r_struct
id|ip_vs_conn
op_star
id|cp
)paren
(brace
r_switch
c_cond
(paren
id|IP_VS_FWD_METHOD
c_func
(paren
id|cp
)paren
)paren
(brace
r_case
id|IP_VS_CONN_F_MASQ
suffix:colon
id|cp-&gt;packet_xmit
op_assign
id|ip_vs_nat_xmit
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IP_VS_CONN_F_TUNNEL
suffix:colon
id|cp-&gt;packet_xmit
op_assign
id|ip_vs_tunnel_xmit
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IP_VS_CONN_F_DROUTE
suffix:colon
id|cp-&gt;packet_xmit
op_assign
id|ip_vs_dr_xmit
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IP_VS_CONN_F_LOCALNODE
suffix:colon
id|cp-&gt;packet_xmit
op_assign
id|ip_vs_null_xmit
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IP_VS_CONN_F_BYPASS
suffix:colon
id|cp-&gt;packet_xmit
op_assign
id|ip_vs_bypass_xmit
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
DECL|function|ip_vs_dest_totalconns
r_static
r_inline
r_int
id|ip_vs_dest_totalconns
c_func
(paren
r_struct
id|ip_vs_dest
op_star
id|dest
)paren
(brace
r_return
id|atomic_read
c_func
(paren
op_amp
id|dest-&gt;activeconns
)paren
op_plus
id|atomic_read
c_func
(paren
op_amp
id|dest-&gt;inactconns
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Bind a connection entry with a virtual service destination&n; *&t;Called just after a new connection entry is created.&n; */
r_static
r_inline
r_void
DECL|function|ip_vs_bind_dest
id|ip_vs_bind_dest
c_func
(paren
r_struct
id|ip_vs_conn
op_star
id|cp
comma
r_struct
id|ip_vs_dest
op_star
id|dest
)paren
(brace
multiline_comment|/* if dest is NULL, then return directly */
r_if
c_cond
(paren
op_logical_neg
id|dest
)paren
r_return
suffix:semicolon
multiline_comment|/* Increase the refcnt counter of the dest */
id|atomic_inc
c_func
(paren
op_amp
id|dest-&gt;refcnt
)paren
suffix:semicolon
multiline_comment|/* Bind with the destination and its corresponding transmitter */
id|cp-&gt;flags
op_or_assign
id|atomic_read
c_func
(paren
op_amp
id|dest-&gt;conn_flags
)paren
suffix:semicolon
id|cp-&gt;dest
op_assign
id|dest
suffix:semicolon
id|IP_VS_DBG
c_func
(paren
l_int|9
comma
l_string|&quot;Bind-dest %s c:%u.%u.%u.%u:%d v:%u.%u.%u.%u:%d &quot;
l_string|&quot;d:%u.%u.%u.%u:%d fwd:%c s:%u flg:%X cnt:%d destcnt:%d&bslash;n&quot;
comma
id|ip_vs_proto_name
c_func
(paren
id|cp-&gt;protocol
)paren
comma
id|NIPQUAD
c_func
(paren
id|cp-&gt;caddr
)paren
comma
id|ntohs
c_func
(paren
id|cp-&gt;cport
)paren
comma
id|NIPQUAD
c_func
(paren
id|cp-&gt;vaddr
)paren
comma
id|ntohs
c_func
(paren
id|cp-&gt;vport
)paren
comma
id|NIPQUAD
c_func
(paren
id|cp-&gt;daddr
)paren
comma
id|ntohs
c_func
(paren
id|cp-&gt;dport
)paren
comma
id|ip_vs_fwd_tag
c_func
(paren
id|cp
)paren
comma
id|cp-&gt;state
comma
id|cp-&gt;flags
comma
id|atomic_read
c_func
(paren
op_amp
id|cp-&gt;refcnt
)paren
comma
id|atomic_read
c_func
(paren
op_amp
id|dest-&gt;refcnt
)paren
)paren
suffix:semicolon
multiline_comment|/* Update the connection counters */
r_if
c_cond
(paren
id|cp-&gt;cport
op_logical_or
(paren
id|cp-&gt;flags
op_amp
id|IP_VS_CONN_F_NO_CPORT
)paren
)paren
(brace
multiline_comment|/* It is a normal connection, so increase the inactive&n;&t;&t;   connection counter because it is in TCP SYNRECV&n;&t;&t;   state (inactive) or other protocol inacive state */
id|atomic_inc
c_func
(paren
op_amp
id|dest-&gt;inactconns
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* It is a persistent connection/template, so increase&n;&t;&t;   the peristent connection counter */
id|atomic_inc
c_func
(paren
op_amp
id|dest-&gt;persistconns
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dest-&gt;u_threshold
op_ne
l_int|0
op_logical_and
id|ip_vs_dest_totalconns
c_func
(paren
id|dest
)paren
op_ge
id|dest-&gt;u_threshold
)paren
id|dest-&gt;flags
op_or_assign
id|IP_VS_DEST_F_OVERLOAD
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Unbind a connection entry with its VS destination&n; *&t;Called by the ip_vs_conn_expire function.&n; */
DECL|function|ip_vs_unbind_dest
r_static
r_inline
r_void
id|ip_vs_unbind_dest
c_func
(paren
r_struct
id|ip_vs_conn
op_star
id|cp
)paren
(brace
r_struct
id|ip_vs_dest
op_star
id|dest
op_assign
id|cp-&gt;dest
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dest
)paren
r_return
suffix:semicolon
id|IP_VS_DBG
c_func
(paren
l_int|9
comma
l_string|&quot;Unbind-dest %s c:%u.%u.%u.%u:%d v:%u.%u.%u.%u:%d &quot;
l_string|&quot;d:%u.%u.%u.%u:%d fwd:%c s:%u flg:%X cnt:%d destcnt:%d&bslash;n&quot;
comma
id|ip_vs_proto_name
c_func
(paren
id|cp-&gt;protocol
)paren
comma
id|NIPQUAD
c_func
(paren
id|cp-&gt;caddr
)paren
comma
id|ntohs
c_func
(paren
id|cp-&gt;cport
)paren
comma
id|NIPQUAD
c_func
(paren
id|cp-&gt;vaddr
)paren
comma
id|ntohs
c_func
(paren
id|cp-&gt;vport
)paren
comma
id|NIPQUAD
c_func
(paren
id|cp-&gt;daddr
)paren
comma
id|ntohs
c_func
(paren
id|cp-&gt;dport
)paren
comma
id|ip_vs_fwd_tag
c_func
(paren
id|cp
)paren
comma
id|cp-&gt;state
comma
id|cp-&gt;flags
comma
id|atomic_read
c_func
(paren
op_amp
id|cp-&gt;refcnt
)paren
comma
id|atomic_read
c_func
(paren
op_amp
id|dest-&gt;refcnt
)paren
)paren
suffix:semicolon
multiline_comment|/* Update the connection counters */
r_if
c_cond
(paren
id|cp-&gt;cport
op_logical_or
(paren
id|cp-&gt;flags
op_amp
id|IP_VS_CONN_F_NO_CPORT
)paren
)paren
(brace
multiline_comment|/* It is a normal connection, so decrease the inactconns&n;&t;&t;   or activeconns counter */
r_if
c_cond
(paren
id|cp-&gt;flags
op_amp
id|IP_VS_CONN_F_INACTIVE
)paren
(brace
id|atomic_dec
c_func
(paren
op_amp
id|dest-&gt;inactconns
)paren
suffix:semicolon
)brace
r_else
(brace
id|atomic_dec
c_func
(paren
op_amp
id|dest-&gt;activeconns
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* It is a persistent connection/template, so decrease&n;&t;&t;   the peristent connection counter */
id|atomic_dec
c_func
(paren
op_amp
id|dest-&gt;persistconns
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dest-&gt;l_threshold
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|ip_vs_dest_totalconns
c_func
(paren
id|dest
)paren
OL
id|dest-&gt;l_threshold
)paren
id|dest-&gt;flags
op_and_assign
op_complement
id|IP_VS_DEST_F_OVERLOAD
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|dest-&gt;u_threshold
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|ip_vs_dest_totalconns
c_func
(paren
id|dest
)paren
op_star
l_int|4
OL
id|dest-&gt;u_threshold
op_star
l_int|3
)paren
id|dest-&gt;flags
op_and_assign
op_complement
id|IP_VS_DEST_F_OVERLOAD
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|dest-&gt;flags
op_amp
id|IP_VS_DEST_F_OVERLOAD
)paren
id|dest-&gt;flags
op_and_assign
op_complement
id|IP_VS_DEST_F_OVERLOAD
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Simply decrease the refcnt of the dest, because the&n;&t; * dest will be either in service&squot;s destination list&n;&t; * or in the trash.&n;&t; */
id|atomic_dec
c_func
(paren
op_amp
id|dest-&gt;refcnt
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Checking if the destination of a connection template is available.&n; *&t;If available, return 1, otherwise invalidate this connection&n; *&t;template and return 0.&n; */
DECL|function|ip_vs_check_template
r_int
id|ip_vs_check_template
c_func
(paren
r_struct
id|ip_vs_conn
op_star
id|ct
)paren
(brace
r_struct
id|ip_vs_dest
op_star
id|dest
op_assign
id|ct-&gt;dest
suffix:semicolon
multiline_comment|/*&n;&t; * Checking the dest server status.&n;&t; */
r_if
c_cond
(paren
(paren
id|dest
op_eq
l_int|NULL
)paren
op_logical_or
op_logical_neg
(paren
id|dest-&gt;flags
op_amp
id|IP_VS_DEST_F_AVAILABLE
)paren
)paren
(brace
id|IP_VS_DBG
c_func
(paren
l_int|9
comma
l_string|&quot;check_template: dest not available for &quot;
l_string|&quot;protocol %s s:%u.%u.%u.%u:%d v:%u.%u.%u.%u:%d &quot;
l_string|&quot;-&gt; d:%u.%u.%u.%u:%d&bslash;n&quot;
comma
id|ip_vs_proto_name
c_func
(paren
id|ct-&gt;protocol
)paren
comma
id|NIPQUAD
c_func
(paren
id|ct-&gt;caddr
)paren
comma
id|ntohs
c_func
(paren
id|ct-&gt;cport
)paren
comma
id|NIPQUAD
c_func
(paren
id|ct-&gt;vaddr
)paren
comma
id|ntohs
c_func
(paren
id|ct-&gt;vport
)paren
comma
id|NIPQUAD
c_func
(paren
id|ct-&gt;daddr
)paren
comma
id|ntohs
c_func
(paren
id|ct-&gt;dport
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Invalidate the connection template&n;&t;&t; */
id|ip_vs_conn_unhash
c_func
(paren
id|ct
)paren
suffix:semicolon
id|ct-&gt;dport
op_assign
l_int|65535
suffix:semicolon
id|ct-&gt;vport
op_assign
l_int|65535
suffix:semicolon
id|ct-&gt;cport
op_assign
l_int|0
suffix:semicolon
id|ip_vs_conn_hash
c_func
(paren
id|ct
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Simply decrease the refcnt of the template,&n;&t;&t; * don&squot;t restart its timer.&n;&t;&t; */
id|atomic_dec
c_func
(paren
op_amp
id|ct-&gt;refcnt
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|ip_vs_conn_expire
r_static
r_void
id|ip_vs_conn_expire
c_func
(paren
r_int
r_int
id|data
)paren
(brace
r_struct
id|ip_vs_conn
op_star
id|cp
op_assign
(paren
r_struct
id|ip_vs_conn
op_star
)paren
id|data
suffix:semicolon
id|cp-&gt;timeout
op_assign
l_int|60
op_star
id|HZ
suffix:semicolon
multiline_comment|/*&n;&t; *&t;hey, I&squot;m using it&n;&t; */
id|atomic_inc
c_func
(paren
op_amp
id|cp-&gt;refcnt
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;do I control anybody?&n;&t; */
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|cp-&gt;n_control
)paren
)paren
r_goto
id|expire_later
suffix:semicolon
multiline_comment|/*&n;&t; *&t;unhash it if it is hashed in the conn table&n;&t; */
id|ip_vs_conn_unhash
c_func
(paren
id|cp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;refcnt==1 implies I&squot;m the only one referrer&n;&t; */
r_if
c_cond
(paren
id|likely
c_func
(paren
id|atomic_read
c_func
(paren
op_amp
id|cp-&gt;refcnt
)paren
op_eq
l_int|1
)paren
)paren
(brace
multiline_comment|/* delete the timer if it is activated by other users */
r_if
c_cond
(paren
id|timer_pending
c_func
(paren
op_amp
id|cp-&gt;timer
)paren
)paren
id|del_timer
c_func
(paren
op_amp
id|cp-&gt;timer
)paren
suffix:semicolon
multiline_comment|/* does anybody control me? */
r_if
c_cond
(paren
id|cp-&gt;control
)paren
id|ip_vs_control_del
c_func
(paren
id|cp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|cp-&gt;app
op_ne
l_int|NULL
)paren
)paren
id|ip_vs_unbind_app
c_func
(paren
id|cp
)paren
suffix:semicolon
id|ip_vs_unbind_dest
c_func
(paren
id|cp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cp-&gt;flags
op_amp
id|IP_VS_CONN_F_NO_CPORT
)paren
id|atomic_dec
c_func
(paren
op_amp
id|ip_vs_conn_no_cport_cnt
)paren
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|ip_vs_conn_count
)paren
suffix:semicolon
id|kmem_cache_free
c_func
(paren
id|ip_vs_conn_cachep
comma
id|cp
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* hash it back to the table */
id|ip_vs_conn_hash
c_func
(paren
id|cp
)paren
suffix:semicolon
id|expire_later
suffix:colon
id|IP_VS_DBG
c_func
(paren
l_int|7
comma
l_string|&quot;delayed: refcnt-1=%d conn.n_control=%d&bslash;n&quot;
comma
id|atomic_read
c_func
(paren
op_amp
id|cp-&gt;refcnt
)paren
op_minus
l_int|1
comma
id|atomic_read
c_func
(paren
op_amp
id|cp-&gt;n_control
)paren
)paren
suffix:semicolon
id|ip_vs_conn_put
c_func
(paren
id|cp
)paren
suffix:semicolon
)brace
DECL|function|ip_vs_conn_expire_now
r_void
id|ip_vs_conn_expire_now
c_func
(paren
r_struct
id|ip_vs_conn
op_star
id|cp
)paren
(brace
id|cp-&gt;timeout
op_assign
l_int|0
suffix:semicolon
id|mod_timer
c_func
(paren
op_amp
id|cp-&gt;timer
comma
id|jiffies
)paren
suffix:semicolon
id|__ip_vs_conn_put
c_func
(paren
id|cp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Create a new connection entry and hash it into the ip_vs_conn_tab&n; */
r_struct
id|ip_vs_conn
op_star
DECL|function|ip_vs_conn_new
id|ip_vs_conn_new
c_func
(paren
r_int
id|proto
comma
id|__u32
id|caddr
comma
id|__u16
id|cport
comma
id|__u32
id|vaddr
comma
id|__u16
id|vport
comma
id|__u32
id|daddr
comma
id|__u16
id|dport
comma
r_int
id|flags
comma
r_struct
id|ip_vs_dest
op_star
id|dest
)paren
(brace
r_struct
id|ip_vs_conn
op_star
id|cp
suffix:semicolon
r_struct
id|ip_vs_protocol
op_star
id|pp
op_assign
id|ip_vs_proto_get
c_func
(paren
id|proto
)paren
suffix:semicolon
id|cp
op_assign
id|kmem_cache_alloc
c_func
(paren
id|ip_vs_conn_cachep
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cp
op_eq
l_int|NULL
)paren
(brace
id|IP_VS_ERR_RL
c_func
(paren
l_string|&quot;ip_vs_conn_new: no memory available.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|memset
c_func
(paren
id|cp
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|cp
)paren
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|cp-&gt;c_list
)paren
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|cp-&gt;timer
)paren
suffix:semicolon
id|cp-&gt;timer.data
op_assign
(paren
r_int
r_int
)paren
id|cp
suffix:semicolon
id|cp-&gt;timer.function
op_assign
id|ip_vs_conn_expire
suffix:semicolon
id|cp-&gt;protocol
op_assign
id|proto
suffix:semicolon
id|cp-&gt;caddr
op_assign
id|caddr
suffix:semicolon
id|cp-&gt;cport
op_assign
id|cport
suffix:semicolon
id|cp-&gt;vaddr
op_assign
id|vaddr
suffix:semicolon
id|cp-&gt;vport
op_assign
id|vport
suffix:semicolon
id|cp-&gt;daddr
op_assign
id|daddr
suffix:semicolon
id|cp-&gt;dport
op_assign
id|dport
suffix:semicolon
id|cp-&gt;flags
op_assign
id|flags
suffix:semicolon
id|cp-&gt;lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
multiline_comment|/*&n;&t; * Set the entry is referenced by the current thread before hashing&n;&t; * it in the table, so that other thread run ip_vs_random_dropentry&n;&t; * but cannot drop this entry.&n;&t; */
id|atomic_set
c_func
(paren
op_amp
id|cp-&gt;refcnt
comma
l_int|1
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|cp-&gt;n_control
comma
l_int|0
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|cp-&gt;in_pkts
comma
l_int|0
)paren
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|ip_vs_conn_count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|IP_VS_CONN_F_NO_CPORT
)paren
id|atomic_inc
c_func
(paren
op_amp
id|ip_vs_conn_no_cport_cnt
)paren
suffix:semicolon
multiline_comment|/* Bind the connection with a destination server */
id|ip_vs_bind_dest
c_func
(paren
id|cp
comma
id|dest
)paren
suffix:semicolon
multiline_comment|/* Set its state and timeout */
id|cp-&gt;state
op_assign
l_int|0
suffix:semicolon
id|cp-&gt;timeout
op_assign
l_int|3
op_star
id|HZ
suffix:semicolon
multiline_comment|/* Bind its packet transmitter */
id|ip_vs_bind_xmit
c_func
(paren
id|cp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|pp
op_logical_and
id|atomic_read
c_func
(paren
op_amp
id|pp-&gt;appcnt
)paren
)paren
)paren
id|ip_vs_bind_app
c_func
(paren
id|cp
comma
id|pp
)paren
suffix:semicolon
multiline_comment|/* Hash it in the ip_vs_conn_tab finally */
id|ip_vs_conn_hash
c_func
(paren
id|cp
)paren
suffix:semicolon
r_return
id|cp
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;/proc/net/ip_vs_conn entries&n; */
macro_line|#ifdef CONFIG_PROC_FS
DECL|function|ip_vs_conn_array
r_static
r_void
op_star
id|ip_vs_conn_array
c_func
(paren
r_struct
id|seq_file
op_star
id|seq
comma
id|loff_t
id|pos
)paren
(brace
r_int
id|idx
suffix:semicolon
r_struct
id|ip_vs_conn
op_star
id|cp
suffix:semicolon
r_for
c_loop
(paren
id|idx
op_assign
l_int|0
suffix:semicolon
id|idx
OL
id|IP_VS_CONN_TAB_SIZE
suffix:semicolon
id|idx
op_increment
)paren
(brace
id|ct_read_lock_bh
c_func
(paren
id|idx
)paren
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|cp
comma
op_amp
id|ip_vs_conn_tab
(braket
id|idx
)braket
comma
id|c_list
)paren
(brace
r_if
c_cond
(paren
id|pos
op_decrement
op_eq
l_int|0
)paren
(brace
id|seq
op_member_access_from_pointer
r_private
op_assign
op_amp
id|ip_vs_conn_tab
(braket
id|idx
)braket
suffix:semicolon
r_return
id|cp
suffix:semicolon
)brace
)brace
id|ct_read_unlock_bh
c_func
(paren
id|idx
)paren
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|ip_vs_conn_seq_start
r_static
r_void
op_star
id|ip_vs_conn_seq_start
c_func
(paren
r_struct
id|seq_file
op_star
id|seq
comma
id|loff_t
op_star
id|pos
)paren
(brace
id|seq
op_member_access_from_pointer
r_private
op_assign
l_int|NULL
suffix:semicolon
r_return
op_star
id|pos
ques
c_cond
id|ip_vs_conn_array
c_func
(paren
id|seq
comma
op_star
id|pos
op_minus
l_int|1
)paren
suffix:colon
id|SEQ_START_TOKEN
suffix:semicolon
)brace
DECL|function|ip_vs_conn_seq_next
r_static
r_void
op_star
id|ip_vs_conn_seq_next
c_func
(paren
r_struct
id|seq_file
op_star
id|seq
comma
r_void
op_star
id|v
comma
id|loff_t
op_star
id|pos
)paren
(brace
r_struct
id|ip_vs_conn
op_star
id|cp
op_assign
id|v
suffix:semicolon
r_struct
id|list_head
op_star
id|e
comma
op_star
id|l
op_assign
id|seq
op_member_access_from_pointer
r_private
suffix:semicolon
r_int
id|idx
suffix:semicolon
op_increment
op_star
id|pos
suffix:semicolon
r_if
c_cond
(paren
id|v
op_eq
id|SEQ_START_TOKEN
)paren
r_return
id|ip_vs_conn_array
c_func
(paren
id|seq
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* more on same hash chain? */
r_if
c_cond
(paren
(paren
id|e
op_assign
id|cp-&gt;c_list.next
)paren
op_ne
id|l
)paren
r_return
id|list_entry
c_func
(paren
id|e
comma
r_struct
id|ip_vs_conn
comma
id|c_list
)paren
suffix:semicolon
id|idx
op_assign
id|l
op_minus
id|ip_vs_conn_tab
suffix:semicolon
id|ct_read_unlock_bh
c_func
(paren
id|idx
)paren
suffix:semicolon
r_while
c_loop
(paren
op_increment
id|idx
OL
id|IP_VS_CONN_TAB_SIZE
)paren
(brace
id|ct_read_lock_bh
c_func
(paren
id|idx
)paren
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|cp
comma
op_amp
id|ip_vs_conn_tab
(braket
id|idx
)braket
comma
id|c_list
)paren
(brace
id|seq
op_member_access_from_pointer
r_private
op_assign
op_amp
id|ip_vs_conn_tab
(braket
id|idx
)braket
suffix:semicolon
r_return
id|cp
suffix:semicolon
)brace
id|ct_read_unlock_bh
c_func
(paren
id|idx
)paren
suffix:semicolon
)brace
id|seq
op_member_access_from_pointer
r_private
op_assign
l_int|NULL
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|ip_vs_conn_seq_stop
r_static
r_void
id|ip_vs_conn_seq_stop
c_func
(paren
r_struct
id|seq_file
op_star
id|seq
comma
r_void
op_star
id|v
)paren
(brace
r_struct
id|list_head
op_star
id|l
op_assign
id|seq
op_member_access_from_pointer
r_private
suffix:semicolon
r_if
c_cond
(paren
id|l
)paren
id|ct_read_unlock_bh
c_func
(paren
id|l
op_minus
id|ip_vs_conn_tab
)paren
suffix:semicolon
)brace
DECL|function|ip_vs_conn_seq_show
r_static
r_int
id|ip_vs_conn_seq_show
c_func
(paren
r_struct
id|seq_file
op_star
id|seq
comma
r_void
op_star
id|v
)paren
(brace
r_if
c_cond
(paren
id|v
op_eq
id|SEQ_START_TOKEN
)paren
id|seq_puts
c_func
(paren
id|seq
comma
l_string|&quot;Pro FromIP   FPrt ToIP     TPrt DestIP   DPrt State       Expires&bslash;n&quot;
)paren
suffix:semicolon
r_else
(brace
r_const
r_struct
id|ip_vs_conn
op_star
id|cp
op_assign
id|v
suffix:semicolon
id|seq_printf
c_func
(paren
id|seq
comma
l_string|&quot;%-3s %08X %04X %08X %04X %08X %04X %-11s %7lu&bslash;n&quot;
comma
id|ip_vs_proto_name
c_func
(paren
id|cp-&gt;protocol
)paren
comma
id|ntohl
c_func
(paren
id|cp-&gt;caddr
)paren
comma
id|ntohs
c_func
(paren
id|cp-&gt;cport
)paren
comma
id|ntohl
c_func
(paren
id|cp-&gt;vaddr
)paren
comma
id|ntohs
c_func
(paren
id|cp-&gt;vport
)paren
comma
id|ntohl
c_func
(paren
id|cp-&gt;daddr
)paren
comma
id|ntohs
c_func
(paren
id|cp-&gt;dport
)paren
comma
id|ip_vs_state_name
c_func
(paren
id|cp-&gt;protocol
comma
id|cp-&gt;state
)paren
comma
(paren
id|cp-&gt;timer.expires
op_minus
id|jiffies
)paren
op_div
id|HZ
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|ip_vs_conn_seq_ops
r_static
r_struct
id|seq_operations
id|ip_vs_conn_seq_ops
op_assign
(brace
dot
id|start
op_assign
id|ip_vs_conn_seq_start
comma
dot
id|next
op_assign
id|ip_vs_conn_seq_next
comma
dot
id|stop
op_assign
id|ip_vs_conn_seq_stop
comma
dot
id|show
op_assign
id|ip_vs_conn_seq_show
comma
)brace
suffix:semicolon
DECL|function|ip_vs_conn_open
r_static
r_int
id|ip_vs_conn_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_return
id|seq_open
c_func
(paren
id|file
comma
op_amp
id|ip_vs_conn_seq_ops
)paren
suffix:semicolon
)brace
DECL|variable|ip_vs_conn_fops
r_static
r_struct
id|file_operations
id|ip_vs_conn_fops
op_assign
(brace
dot
id|owner
op_assign
id|THIS_MODULE
comma
dot
id|open
op_assign
id|ip_vs_conn_open
comma
dot
id|read
op_assign
id|seq_read
comma
dot
id|llseek
op_assign
id|seq_lseek
comma
dot
id|release
op_assign
id|seq_release
comma
)brace
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; *      Randomly drop connection entries before running out of memory&n; */
DECL|function|todrop_entry
r_static
r_inline
r_int
id|todrop_entry
c_func
(paren
r_struct
id|ip_vs_conn
op_star
id|cp
)paren
(brace
multiline_comment|/*&n;&t; * The drop rate array needs tuning for real environments.&n;&t; * Called from timer bh only =&gt; no locking&n;&t; */
r_static
r_char
id|todrop_rate
(braket
l_int|9
)braket
op_assign
(brace
l_int|0
comma
l_int|1
comma
l_int|2
comma
l_int|3
comma
l_int|4
comma
l_int|5
comma
l_int|6
comma
l_int|7
comma
l_int|8
)brace
suffix:semicolon
r_static
r_char
id|todrop_counter
(braket
l_int|9
)braket
op_assign
(brace
l_int|0
)brace
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/* if the conn entry hasn&squot;t lasted for 60 seconds, don&squot;t drop it.&n;&t;   This will leave enough time for normal connection to get&n;&t;   through. */
r_if
c_cond
(paren
id|time_before
c_func
(paren
id|cp-&gt;timeout
op_plus
id|jiffies
comma
id|cp-&gt;timer.expires
op_plus
l_int|60
op_star
id|HZ
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Don&squot;t drop the entry if its number of incoming packets is not&n;&t;   located in [0, 8] */
id|i
op_assign
id|atomic_read
c_func
(paren
op_amp
id|cp-&gt;in_pkts
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
OG
l_int|8
op_logical_or
id|i
OL
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|todrop_rate
(braket
id|i
)braket
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_decrement
id|todrop_counter
(braket
id|i
)braket
OG
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
id|todrop_counter
(braket
id|i
)braket
op_assign
id|todrop_rate
(braket
id|i
)braket
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|ip_vs_random_dropentry
r_void
id|ip_vs_random_dropentry
c_func
(paren
r_void
)paren
(brace
r_int
id|idx
suffix:semicolon
r_struct
id|ip_vs_conn
op_star
id|cp
suffix:semicolon
r_struct
id|ip_vs_conn
op_star
id|ct
suffix:semicolon
multiline_comment|/*&n;&t; * Randomly scan 1/32 of the whole table every second&n;&t; */
r_for
c_loop
(paren
id|idx
op_assign
l_int|0
suffix:semicolon
id|idx
OL
(paren
id|IP_VS_CONN_TAB_SIZE
op_rshift
l_int|5
)paren
suffix:semicolon
id|idx
op_increment
)paren
(brace
r_int
id|hash
op_assign
id|net_random
c_func
(paren
)paren
op_amp
id|IP_VS_CONN_TAB_MASK
suffix:semicolon
multiline_comment|/*&n;&t;&t; *  Lock is actually needed in this loop.&n;&t;&t; */
id|ct_write_lock
c_func
(paren
id|hash
)paren
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|cp
comma
op_amp
id|ip_vs_conn_tab
(braket
id|hash
)braket
comma
id|c_list
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|cp-&gt;cport
op_logical_and
op_logical_neg
(paren
id|cp-&gt;flags
op_amp
id|IP_VS_CONN_F_NO_CPORT
)paren
)paren
multiline_comment|/* connection template */
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|cp-&gt;protocol
op_eq
id|IPPROTO_TCP
)paren
(brace
r_switch
c_cond
(paren
id|cp-&gt;state
)paren
(brace
r_case
id|IP_VS_TCP_S_SYN_RECV
suffix:colon
r_case
id|IP_VS_TCP_S_SYNACK
suffix:colon
r_break
suffix:semicolon
r_case
id|IP_VS_TCP_S_ESTABLISHED
suffix:colon
r_if
c_cond
(paren
id|todrop_entry
c_func
(paren
id|cp
)paren
)paren
r_break
suffix:semicolon
r_continue
suffix:semicolon
r_default
suffix:colon
r_continue
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
id|todrop_entry
c_func
(paren
id|cp
)paren
)paren
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * Drop the entry, and drop its ct if not referenced&n;&t;&t;&t; */
id|atomic_inc
c_func
(paren
op_amp
id|cp-&gt;refcnt
)paren
suffix:semicolon
id|ct_write_unlock
c_func
(paren
id|hash
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ct
op_assign
id|cp-&gt;control
)paren
)paren
id|atomic_inc
c_func
(paren
op_amp
id|ct-&gt;refcnt
)paren
suffix:semicolon
id|IP_VS_DBG
c_func
(paren
l_int|4
comma
l_string|&quot;del connection&bslash;n&quot;
)paren
suffix:semicolon
id|ip_vs_conn_expire_now
c_func
(paren
id|cp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ct
)paren
(brace
id|IP_VS_DBG
c_func
(paren
l_int|4
comma
l_string|&quot;del conn template&bslash;n&quot;
)paren
suffix:semicolon
id|ip_vs_conn_expire_now
c_func
(paren
id|ct
)paren
suffix:semicolon
)brace
id|ct_write_lock
c_func
(paren
id|hash
)paren
suffix:semicolon
)brace
id|ct_write_unlock
c_func
(paren
id|hash
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *      Flush all the connection entries in the ip_vs_conn_tab&n; */
DECL|function|ip_vs_conn_flush
r_static
r_void
id|ip_vs_conn_flush
c_func
(paren
r_void
)paren
(brace
r_int
id|idx
suffix:semicolon
r_struct
id|ip_vs_conn
op_star
id|cp
suffix:semicolon
r_struct
id|ip_vs_conn
op_star
id|ct
suffix:semicolon
id|flush_again
suffix:colon
r_for
c_loop
(paren
id|idx
op_assign
l_int|0
suffix:semicolon
id|idx
OL
id|IP_VS_CONN_TAB_SIZE
suffix:semicolon
id|idx
op_increment
)paren
(brace
multiline_comment|/*&n;&t;&t; *  Lock is actually needed in this loop.&n;&t;&t; */
id|ct_write_lock_bh
c_func
(paren
id|idx
)paren
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|cp
comma
op_amp
id|ip_vs_conn_tab
(braket
id|idx
)braket
comma
id|c_list
)paren
(brace
id|atomic_inc
c_func
(paren
op_amp
id|cp-&gt;refcnt
)paren
suffix:semicolon
id|ct_write_unlock
c_func
(paren
id|idx
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ct
op_assign
id|cp-&gt;control
)paren
)paren
id|atomic_inc
c_func
(paren
op_amp
id|ct-&gt;refcnt
)paren
suffix:semicolon
id|IP_VS_DBG
c_func
(paren
l_int|4
comma
l_string|&quot;del connection&bslash;n&quot;
)paren
suffix:semicolon
id|ip_vs_conn_expire_now
c_func
(paren
id|cp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ct
)paren
(brace
id|IP_VS_DBG
c_func
(paren
l_int|4
comma
l_string|&quot;del conn template&bslash;n&quot;
)paren
suffix:semicolon
id|ip_vs_conn_expire_now
c_func
(paren
id|ct
)paren
suffix:semicolon
)brace
id|ct_write_lock
c_func
(paren
id|idx
)paren
suffix:semicolon
)brace
id|ct_write_unlock_bh
c_func
(paren
id|idx
)paren
suffix:semicolon
)brace
multiline_comment|/* the counter may be not NULL, because maybe some conn entries&n;&t;   are run by slow timer handler or unhashed but still referred */
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|ip_vs_conn_count
)paren
op_ne
l_int|0
)paren
(brace
id|schedule
c_func
(paren
)paren
suffix:semicolon
r_goto
id|flush_again
suffix:semicolon
)brace
)brace
DECL|function|ip_vs_conn_init
r_int
id|ip_vs_conn_init
c_func
(paren
r_void
)paren
(brace
r_int
id|idx
suffix:semicolon
multiline_comment|/*&n;&t; * Allocate the connection hash table and initialize its list heads&n;&t; */
id|ip_vs_conn_tab
op_assign
id|vmalloc
c_func
(paren
id|IP_VS_CONN_TAB_SIZE
op_star
r_sizeof
(paren
r_struct
id|list_head
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ip_vs_conn_tab
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
multiline_comment|/* Allocate ip_vs_conn slab cache */
id|ip_vs_conn_cachep
op_assign
id|kmem_cache_create
c_func
(paren
l_string|&quot;ip_vs_conn&quot;
comma
r_sizeof
(paren
r_struct
id|ip_vs_conn
)paren
comma
l_int|0
comma
id|SLAB_HWCACHE_ALIGN
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ip_vs_conn_cachep
)paren
(brace
id|vfree
c_func
(paren
id|ip_vs_conn_tab
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|IP_VS_INFO
c_func
(paren
l_string|&quot;Connection hash table configured &quot;
l_string|&quot;(size=%d, memory=%ldKbytes)&bslash;n&quot;
comma
id|IP_VS_CONN_TAB_SIZE
comma
(paren
r_int
)paren
(paren
id|IP_VS_CONN_TAB_SIZE
op_star
r_sizeof
(paren
r_struct
id|list_head
)paren
)paren
op_div
l_int|1024
)paren
suffix:semicolon
id|IP_VS_DBG
c_func
(paren
l_int|0
comma
l_string|&quot;Each connection entry needs %Zd bytes at least&bslash;n&quot;
comma
r_sizeof
(paren
r_struct
id|ip_vs_conn
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|idx
op_assign
l_int|0
suffix:semicolon
id|idx
OL
id|IP_VS_CONN_TAB_SIZE
suffix:semicolon
id|idx
op_increment
)paren
(brace
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|ip_vs_conn_tab
(braket
id|idx
)braket
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|idx
op_assign
l_int|0
suffix:semicolon
id|idx
OL
id|CT_LOCKARRAY_SIZE
suffix:semicolon
id|idx
op_increment
)paren
(brace
id|__ip_vs_conntbl_lock_array
(braket
id|idx
)braket
dot
id|l
op_assign
id|RW_LOCK_UNLOCKED
suffix:semicolon
)brace
id|proc_net_fops_create
c_func
(paren
l_string|&quot;ip_vs_conn&quot;
comma
l_int|0
comma
op_amp
id|ip_vs_conn_fops
)paren
suffix:semicolon
multiline_comment|/* calculate the random value for connection hash */
id|get_random_bytes
c_func
(paren
op_amp
id|ip_vs_conn_rnd
comma
r_sizeof
(paren
id|ip_vs_conn_rnd
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ip_vs_conn_cleanup
r_void
id|ip_vs_conn_cleanup
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* flush all the connection entries first */
id|ip_vs_conn_flush
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Release the empty cache */
id|kmem_cache_destroy
c_func
(paren
id|ip_vs_conn_cachep
)paren
suffix:semicolon
id|proc_net_remove
c_func
(paren
l_string|&quot;ip_vs_conn&quot;
)paren
suffix:semicolon
id|vfree
c_func
(paren
id|ip_vs_conn_tab
)paren
suffix:semicolon
)brace
eof
