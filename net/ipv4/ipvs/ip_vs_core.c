multiline_comment|/*&n; * IPVS         An implementation of the IP virtual server support for the&n; *              LINUX operating system.  IPVS is now implemented as a module&n; *              over the Netfilter framework. IPVS can be used to build a&n; *              high-performance and highly available server based on a&n; *              cluster of servers.&n; *&n; * Version:     $Id: ip_vs_core.c,v 1.34 2003/05/10 03:05:23 wensong Exp $&n; *&n; * Authors:     Wensong Zhang &lt;wensong@linuxvirtualserver.org&gt;&n; *              Peter Kese &lt;peter.kese@ijs.si&gt;&n; *              Julian Anastasov &lt;ja@ssi.bg&gt;&n; *&n; *              This program is free software; you can redistribute it and/or&n; *              modify it under the terms of the GNU General Public License&n; *              as published by the Free Software Foundation; either version&n; *              2 of the License, or (at your option) any later version.&n; *&n; * The IPVS code for kernel 2.2 was done by Wensong Zhang and Peter Kese,&n; * with changes/fixes from Julian Anastasov, Lars Marowsky-Bree, Horms&n; * and others.&n; *&n; * Changes:&n; *&t;Paul `Rusty&squot; Russell&t;&t;properly handle non-linear skbs&n; *&n; */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/ip.h&gt;
macro_line|#include &lt;linux/tcp.h&gt;
macro_line|#include &lt;linux/icmp.h&gt;
macro_line|#include &lt;net/ip.h&gt;
macro_line|#include &lt;net/tcp.h&gt;
macro_line|#include &lt;net/udp.h&gt;
macro_line|#include &lt;net/icmp.h&gt;                   /* for icmp_send */
macro_line|#include &lt;net/route.h&gt;
macro_line|#include &lt;linux/netfilter.h&gt;
macro_line|#include &lt;linux/netfilter_ipv4.h&gt;
macro_line|#include &lt;net/ip_vs.h&gt;
DECL|variable|register_ip_vs_scheduler
id|EXPORT_SYMBOL
c_func
(paren
id|register_ip_vs_scheduler
)paren
suffix:semicolon
DECL|variable|unregister_ip_vs_scheduler
id|EXPORT_SYMBOL
c_func
(paren
id|unregister_ip_vs_scheduler
)paren
suffix:semicolon
DECL|variable|ip_vs_skb_replace
id|EXPORT_SYMBOL
c_func
(paren
id|ip_vs_skb_replace
)paren
suffix:semicolon
DECL|variable|ip_vs_proto_name
id|EXPORT_SYMBOL
c_func
(paren
id|ip_vs_proto_name
)paren
suffix:semicolon
DECL|variable|ip_vs_conn_new
id|EXPORT_SYMBOL
c_func
(paren
id|ip_vs_conn_new
)paren
suffix:semicolon
DECL|variable|ip_vs_conn_in_get
id|EXPORT_SYMBOL
c_func
(paren
id|ip_vs_conn_in_get
)paren
suffix:semicolon
DECL|variable|ip_vs_conn_out_get
id|EXPORT_SYMBOL
c_func
(paren
id|ip_vs_conn_out_get
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_IP_VS_PROTO_TCP
DECL|variable|ip_vs_tcp_conn_listen
id|EXPORT_SYMBOL
c_func
(paren
id|ip_vs_tcp_conn_listen
)paren
suffix:semicolon
macro_line|#endif
DECL|variable|ip_vs_conn_put
id|EXPORT_SYMBOL
c_func
(paren
id|ip_vs_conn_put
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_IP_VS_DEBUG
DECL|variable|ip_vs_get_debug_level
id|EXPORT_SYMBOL
c_func
(paren
id|ip_vs_get_debug_level
)paren
suffix:semicolon
macro_line|#endif
DECL|variable|ip_vs_make_skb_writable
id|EXPORT_SYMBOL
c_func
(paren
id|ip_vs_make_skb_writable
)paren
suffix:semicolon
multiline_comment|/* ID used in ICMP lookups */
DECL|macro|icmp_id
mdefine_line|#define icmp_id(icmph)          (((icmph)-&gt;un).echo.id)
DECL|function|ip_vs_proto_name
r_const
r_char
op_star
id|ip_vs_proto_name
c_func
(paren
r_int
id|proto
)paren
(brace
r_static
r_char
id|buf
(braket
l_int|20
)braket
suffix:semicolon
r_switch
c_cond
(paren
id|proto
)paren
(brace
r_case
id|IPPROTO_IP
suffix:colon
r_return
l_string|&quot;IP&quot;
suffix:semicolon
r_case
id|IPPROTO_UDP
suffix:colon
r_return
l_string|&quot;UDP&quot;
suffix:semicolon
r_case
id|IPPROTO_TCP
suffix:colon
r_return
l_string|&quot;TCP&quot;
suffix:semicolon
r_case
id|IPPROTO_ICMP
suffix:colon
r_return
l_string|&quot;ICMP&quot;
suffix:semicolon
r_default
suffix:colon
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;IP_%d&quot;
comma
id|proto
)paren
suffix:semicolon
r_return
id|buf
suffix:semicolon
)brace
)brace
DECL|function|ip_vs_init_hash_table
r_void
id|ip_vs_init_hash_table
c_func
(paren
r_struct
id|list_head
op_star
id|table
comma
r_int
id|rows
)paren
(brace
r_while
c_loop
(paren
op_decrement
id|rows
op_ge
l_int|0
)paren
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|table
(braket
id|rows
)braket
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|ip_vs_in_stats
id|ip_vs_in_stats
c_func
(paren
r_struct
id|ip_vs_conn
op_star
id|cp
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|ip_vs_dest
op_star
id|dest
op_assign
id|cp-&gt;dest
suffix:semicolon
r_if
c_cond
(paren
id|dest
op_logical_and
(paren
id|dest-&gt;flags
op_amp
id|IP_VS_DEST_F_AVAILABLE
)paren
)paren
(brace
id|spin_lock
c_func
(paren
op_amp
id|dest-&gt;stats.lock
)paren
suffix:semicolon
id|dest-&gt;stats.inpkts
op_increment
suffix:semicolon
id|dest-&gt;stats.inbytes
op_add_assign
id|skb-&gt;len
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|dest-&gt;stats.lock
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|dest-&gt;svc-&gt;stats.lock
)paren
suffix:semicolon
id|dest-&gt;svc-&gt;stats.inpkts
op_increment
suffix:semicolon
id|dest-&gt;svc-&gt;stats.inbytes
op_add_assign
id|skb-&gt;len
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|dest-&gt;svc-&gt;stats.lock
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|ip_vs_stats.lock
)paren
suffix:semicolon
id|ip_vs_stats.inpkts
op_increment
suffix:semicolon
id|ip_vs_stats.inbytes
op_add_assign
id|skb-&gt;len
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|ip_vs_stats.lock
)paren
suffix:semicolon
)brace
)brace
r_static
r_inline
r_void
DECL|function|ip_vs_out_stats
id|ip_vs_out_stats
c_func
(paren
r_struct
id|ip_vs_conn
op_star
id|cp
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|ip_vs_dest
op_star
id|dest
op_assign
id|cp-&gt;dest
suffix:semicolon
r_if
c_cond
(paren
id|dest
op_logical_and
(paren
id|dest-&gt;flags
op_amp
id|IP_VS_DEST_F_AVAILABLE
)paren
)paren
(brace
id|spin_lock
c_func
(paren
op_amp
id|dest-&gt;stats.lock
)paren
suffix:semicolon
id|dest-&gt;stats.outpkts
op_increment
suffix:semicolon
id|dest-&gt;stats.outbytes
op_add_assign
id|skb-&gt;len
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|dest-&gt;stats.lock
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|dest-&gt;svc-&gt;stats.lock
)paren
suffix:semicolon
id|dest-&gt;svc-&gt;stats.outpkts
op_increment
suffix:semicolon
id|dest-&gt;svc-&gt;stats.outbytes
op_add_assign
id|skb-&gt;len
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|dest-&gt;svc-&gt;stats.lock
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|ip_vs_stats.lock
)paren
suffix:semicolon
id|ip_vs_stats.outpkts
op_increment
suffix:semicolon
id|ip_vs_stats.outbytes
op_add_assign
id|skb-&gt;len
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|ip_vs_stats.lock
)paren
suffix:semicolon
)brace
)brace
r_static
r_inline
r_void
DECL|function|ip_vs_conn_stats
id|ip_vs_conn_stats
c_func
(paren
r_struct
id|ip_vs_conn
op_star
id|cp
comma
r_struct
id|ip_vs_service
op_star
id|svc
)paren
(brace
id|spin_lock
c_func
(paren
op_amp
id|cp-&gt;dest-&gt;stats.lock
)paren
suffix:semicolon
id|cp-&gt;dest-&gt;stats.conns
op_increment
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|cp-&gt;dest-&gt;stats.lock
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|svc-&gt;stats.lock
)paren
suffix:semicolon
id|svc-&gt;stats.conns
op_increment
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|svc-&gt;stats.lock
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|ip_vs_stats.lock
)paren
suffix:semicolon
id|ip_vs_stats.conns
op_increment
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|ip_vs_stats.lock
)paren
suffix:semicolon
)brace
r_static
r_inline
r_int
DECL|function|ip_vs_set_state
id|ip_vs_set_state
c_func
(paren
r_struct
id|ip_vs_conn
op_star
id|cp
comma
r_int
id|direction
comma
r_const
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|ip_vs_protocol
op_star
id|pp
)paren
(brace
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|pp-&gt;state_transition
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_return
id|pp
op_member_access_from_pointer
id|state_transition
c_func
(paren
id|cp
comma
id|direction
comma
id|skb
comma
id|pp
)paren
suffix:semicolon
)brace
DECL|function|ip_vs_make_skb_writable
r_int
id|ip_vs_make_skb_writable
c_func
(paren
r_struct
id|sk_buff
op_star
op_star
id|pskb
comma
r_int
id|writable_len
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
op_assign
op_star
id|pskb
suffix:semicolon
multiline_comment|/* skb is already used, better copy skb and its payload */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|skb_shared
c_func
(paren
id|skb
)paren
op_logical_or
id|skb-&gt;sk
)paren
)paren
r_goto
id|copy_skb
suffix:semicolon
multiline_comment|/* skb data is already used, copy it */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|skb_cloned
c_func
(paren
id|skb
)paren
)paren
)paren
r_goto
id|copy_data
suffix:semicolon
r_return
id|pskb_may_pull
c_func
(paren
id|skb
comma
id|writable_len
)paren
suffix:semicolon
id|copy_data
suffix:colon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|writable_len
OG
id|skb-&gt;len
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_return
op_logical_neg
id|pskb_expand_head
c_func
(paren
id|skb
comma
l_int|0
comma
l_int|0
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
id|copy_skb
suffix:colon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|writable_len
OG
id|skb-&gt;len
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|skb
op_assign
id|skb_copy
c_func
(paren
id|skb
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skb
)paren
r_return
l_int|0
suffix:semicolon
id|BUG_ON
c_func
(paren
id|skb_is_nonlinear
c_func
(paren
id|skb
)paren
)paren
suffix:semicolon
multiline_comment|/* Rest of kernel will get very unhappy if we pass it a&n;&t;   suddenly-orphaned skbuff */
r_if
c_cond
(paren
(paren
op_star
id|pskb
)paren
op_member_access_from_pointer
id|sk
)paren
id|skb_set_owner_w
c_func
(paren
id|skb
comma
(paren
op_star
id|pskb
)paren
op_member_access_from_pointer
id|sk
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
op_star
id|pskb
)paren
suffix:semicolon
op_star
id|pskb
op_assign
id|skb
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; *  IPVS persistent scheduling function&n; *  It creates a connection entry according to its template if exists,&n; *  or selects a server and creates a connection entry plus a template.&n; *  Locking: we are svc user (svc-&gt;refcnt), so we hold all dests too&n; *  Protocols supported: TCP, UDP&n; */
r_static
r_struct
id|ip_vs_conn
op_star
DECL|function|ip_vs_sched_persist
id|ip_vs_sched_persist
c_func
(paren
r_struct
id|ip_vs_service
op_star
id|svc
comma
r_const
r_struct
id|sk_buff
op_star
id|skb
comma
id|__u16
id|ports
(braket
l_int|2
)braket
)paren
(brace
r_struct
id|ip_vs_conn
op_star
id|cp
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|iphdr
op_star
id|iph
op_assign
id|skb-&gt;nh.iph
suffix:semicolon
r_struct
id|ip_vs_dest
op_star
id|dest
suffix:semicolon
r_struct
id|ip_vs_conn
op_star
id|ct
suffix:semicolon
id|__u16
id|dport
suffix:semicolon
multiline_comment|/* destination port to forward */
id|__u32
id|snet
suffix:semicolon
multiline_comment|/* source network of the client, after masking */
multiline_comment|/* Mask saddr with the netmask to adjust template granularity */
id|snet
op_assign
id|iph-&gt;saddr
op_amp
id|svc-&gt;netmask
suffix:semicolon
id|IP_VS_DBG
c_func
(paren
l_int|6
comma
l_string|&quot;p-schedule: src %u.%u.%u.%u:%u dest %u.%u.%u.%u:%u &quot;
l_string|&quot;mnet %u.%u.%u.%u&bslash;n&quot;
comma
id|NIPQUAD
c_func
(paren
id|iph-&gt;saddr
)paren
comma
id|ntohs
c_func
(paren
id|ports
(braket
l_int|0
)braket
)paren
comma
id|NIPQUAD
c_func
(paren
id|iph-&gt;daddr
)paren
comma
id|ntohs
c_func
(paren
id|ports
(braket
l_int|1
)braket
)paren
comma
id|NIPQUAD
c_func
(paren
id|snet
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * As far as we know, FTP is a very complicated network protocol, and&n;&t; * it uses control connection and data connections. For active FTP,&n;&t; * FTP server initialize data connection to the client, its source port&n;&t; * is often 20. For passive FTP, FTP server tells the clients the port&n;&t; * that it passively listens to,  and the client issues the data&n;&t; * connection. In the tunneling or direct routing mode, the load&n;&t; * balancer is on the client-to-server half of connection, the port&n;&t; * number is unknown to the load balancer. So, a conn template like&n;&t; * &lt;caddr, 0, vaddr, 0, daddr, 0&gt; is created for persistent FTP&n;&t; * service, and a template like &lt;caddr, 0, vaddr, vport, daddr, dport&gt;&n;&t; * is created for other persistent services.&n;&t; */
r_if
c_cond
(paren
id|ports
(braket
l_int|1
)braket
op_eq
id|svc-&gt;port
)paren
(brace
multiline_comment|/* Check if a template already exists */
r_if
c_cond
(paren
id|svc-&gt;port
op_ne
id|FTPPORT
)paren
id|ct
op_assign
id|ip_vs_conn_in_get
c_func
(paren
id|iph-&gt;protocol
comma
id|snet
comma
l_int|0
comma
id|iph-&gt;daddr
comma
id|ports
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_else
id|ct
op_assign
id|ip_vs_conn_in_get
c_func
(paren
id|iph-&gt;protocol
comma
id|snet
comma
l_int|0
comma
id|iph-&gt;daddr
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ct
op_logical_or
op_logical_neg
id|ip_vs_check_template
c_func
(paren
id|ct
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * No template found or the dest of the connection&n;&t;&t;&t; * template is not available.&n;&t;&t;&t; */
id|dest
op_assign
id|svc-&gt;scheduler
op_member_access_from_pointer
id|schedule
c_func
(paren
id|svc
comma
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dest
op_eq
l_int|NULL
)paren
(brace
id|IP_VS_DBG
c_func
(paren
l_int|1
comma
l_string|&quot;p-schedule: no dest found.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * Create a template like &lt;protocol,caddr,0,&n;&t;&t;&t; * vaddr,vport,daddr,dport&gt; for non-ftp service,&n;&t;&t;&t; * and &lt;protocol,caddr,0,vaddr,0,daddr,0&gt;&n;&t;&t;&t; * for ftp service.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|svc-&gt;port
op_ne
id|FTPPORT
)paren
id|ct
op_assign
id|ip_vs_conn_new
c_func
(paren
id|iph-&gt;protocol
comma
id|snet
comma
l_int|0
comma
id|iph-&gt;daddr
comma
id|ports
(braket
l_int|1
)braket
comma
id|dest-&gt;addr
comma
id|dest-&gt;port
comma
l_int|0
comma
id|dest
)paren
suffix:semicolon
r_else
id|ct
op_assign
id|ip_vs_conn_new
c_func
(paren
id|iph-&gt;protocol
comma
id|snet
comma
l_int|0
comma
id|iph-&gt;daddr
comma
l_int|0
comma
id|dest-&gt;addr
comma
l_int|0
comma
l_int|0
comma
id|dest
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ct
op_eq
l_int|NULL
)paren
r_return
l_int|NULL
suffix:semicolon
id|ct-&gt;timeout
op_assign
id|svc-&gt;timeout
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* set destination with the found template */
id|dest
op_assign
id|ct-&gt;dest
suffix:semicolon
)brace
id|dport
op_assign
id|dest-&gt;port
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * Note: persistent fwmark-based services and persistent&n;&t;&t; * port zero service are handled here.&n;&t;&t; * fwmark template: &lt;IPPROTO_IP,caddr,0,fwmark,0,daddr,0&gt;&n;&t;&t; * port zero template: &lt;protocol,caddr,0,vaddr,0,daddr,0&gt;&n;&t;&t; */
r_if
c_cond
(paren
id|svc-&gt;fwmark
)paren
id|ct
op_assign
id|ip_vs_conn_in_get
c_func
(paren
id|IPPROTO_IP
comma
id|snet
comma
l_int|0
comma
id|htonl
c_func
(paren
id|svc-&gt;fwmark
)paren
comma
l_int|0
)paren
suffix:semicolon
r_else
id|ct
op_assign
id|ip_vs_conn_in_get
c_func
(paren
id|iph-&gt;protocol
comma
id|snet
comma
l_int|0
comma
id|iph-&gt;daddr
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ct
op_logical_or
op_logical_neg
id|ip_vs_check_template
c_func
(paren
id|ct
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * If it is not persistent port zero, return NULL,&n;&t;&t;&t; * otherwise create a connection template.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|svc-&gt;port
)paren
r_return
l_int|NULL
suffix:semicolon
id|dest
op_assign
id|svc-&gt;scheduler
op_member_access_from_pointer
id|schedule
c_func
(paren
id|svc
comma
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dest
op_eq
l_int|NULL
)paren
(brace
id|IP_VS_DBG
c_func
(paren
l_int|1
comma
l_string|&quot;p-schedule: no dest found.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * Create a template according to the service&n;&t;&t;&t; */
r_if
c_cond
(paren
id|svc-&gt;fwmark
)paren
id|ct
op_assign
id|ip_vs_conn_new
c_func
(paren
id|IPPROTO_IP
comma
id|snet
comma
l_int|0
comma
id|htonl
c_func
(paren
id|svc-&gt;fwmark
)paren
comma
l_int|0
comma
id|dest-&gt;addr
comma
l_int|0
comma
l_int|0
comma
id|dest
)paren
suffix:semicolon
r_else
id|ct
op_assign
id|ip_vs_conn_new
c_func
(paren
id|iph-&gt;protocol
comma
id|snet
comma
l_int|0
comma
id|iph-&gt;daddr
comma
l_int|0
comma
id|dest-&gt;addr
comma
l_int|0
comma
l_int|0
comma
id|dest
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ct
op_eq
l_int|NULL
)paren
r_return
l_int|NULL
suffix:semicolon
id|ct-&gt;timeout
op_assign
id|svc-&gt;timeout
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* set destination with the found template */
id|dest
op_assign
id|ct-&gt;dest
suffix:semicolon
)brace
id|dport
op_assign
id|ports
(braket
l_int|1
)braket
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *    Create a new connection according to the template&n;&t; */
id|cp
op_assign
id|ip_vs_conn_new
c_func
(paren
id|iph-&gt;protocol
comma
id|iph-&gt;saddr
comma
id|ports
(braket
l_int|0
)braket
comma
id|iph-&gt;daddr
comma
id|ports
(braket
l_int|1
)braket
comma
id|dest-&gt;addr
comma
id|dport
comma
l_int|0
comma
id|dest
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cp
op_eq
l_int|NULL
)paren
(brace
id|ip_vs_conn_put
c_func
(paren
id|ct
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *    Add its control&n;&t; */
id|ip_vs_control_add
c_func
(paren
id|cp
comma
id|ct
)paren
suffix:semicolon
id|ip_vs_conn_put
c_func
(paren
id|ct
)paren
suffix:semicolon
id|ip_vs_conn_stats
c_func
(paren
id|cp
comma
id|svc
)paren
suffix:semicolon
r_return
id|cp
suffix:semicolon
)brace
multiline_comment|/*&n; *  IPVS main scheduling function&n; *  It selects a server according to the virtual service, and&n; *  creates a connection entry.&n; *  Protocols supported: TCP, UDP&n; */
r_struct
id|ip_vs_conn
op_star
DECL|function|ip_vs_schedule
id|ip_vs_schedule
c_func
(paren
r_struct
id|ip_vs_service
op_star
id|svc
comma
r_const
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|ip_vs_conn
op_star
id|cp
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|iphdr
op_star
id|iph
op_assign
id|skb-&gt;nh.iph
suffix:semicolon
r_struct
id|ip_vs_dest
op_star
id|dest
suffix:semicolon
id|__u16
id|_ports
(braket
l_int|2
)braket
comma
op_star
id|pptr
suffix:semicolon
id|pptr
op_assign
id|skb_header_pointer
c_func
(paren
id|skb
comma
id|iph-&gt;ihl
op_star
l_int|4
comma
r_sizeof
(paren
id|_ports
)paren
comma
id|_ports
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pptr
op_eq
l_int|NULL
)paren
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; *    Persistent service&n;&t; */
r_if
c_cond
(paren
id|svc-&gt;flags
op_amp
id|IP_VS_SVC_F_PERSISTENT
)paren
r_return
id|ip_vs_sched_persist
c_func
(paren
id|svc
comma
id|skb
comma
id|pptr
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *    Non-persistent service&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|svc-&gt;fwmark
op_logical_and
id|pptr
(braket
l_int|1
)braket
op_ne
id|svc-&gt;port
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|svc-&gt;port
)paren
id|IP_VS_ERR
c_func
(paren
l_string|&quot;Schedule: port zero only supported &quot;
l_string|&quot;in persistent services, &quot;
l_string|&quot;check your ipvs configuration&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|dest
op_assign
id|svc-&gt;scheduler
op_member_access_from_pointer
id|schedule
c_func
(paren
id|svc
comma
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dest
op_eq
l_int|NULL
)paren
(brace
id|IP_VS_DBG
c_func
(paren
l_int|1
comma
l_string|&quot;Schedule: no dest found.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *    Create a connection entry.&n;&t; */
id|cp
op_assign
id|ip_vs_conn_new
c_func
(paren
id|iph-&gt;protocol
comma
id|iph-&gt;saddr
comma
id|pptr
(braket
l_int|0
)braket
comma
id|iph-&gt;daddr
comma
id|pptr
(braket
l_int|1
)braket
comma
id|dest-&gt;addr
comma
id|dest-&gt;port
ques
c_cond
id|dest-&gt;port
suffix:colon
id|pptr
(braket
l_int|1
)braket
comma
l_int|0
comma
id|dest
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cp
op_eq
l_int|NULL
)paren
r_return
l_int|NULL
suffix:semicolon
id|IP_VS_DBG
c_func
(paren
l_int|6
comma
l_string|&quot;Schedule fwd:%c c:%u.%u.%u.%u:%u v:%u.%u.%u.%u:%u &quot;
l_string|&quot;d:%u.%u.%u.%u:%u flg:%X cnt:%d&bslash;n&quot;
comma
id|ip_vs_fwd_tag
c_func
(paren
id|cp
)paren
comma
id|NIPQUAD
c_func
(paren
id|cp-&gt;caddr
)paren
comma
id|ntohs
c_func
(paren
id|cp-&gt;cport
)paren
comma
id|NIPQUAD
c_func
(paren
id|cp-&gt;vaddr
)paren
comma
id|ntohs
c_func
(paren
id|cp-&gt;vport
)paren
comma
id|NIPQUAD
c_func
(paren
id|cp-&gt;daddr
)paren
comma
id|ntohs
c_func
(paren
id|cp-&gt;dport
)paren
comma
id|cp-&gt;flags
comma
id|atomic_read
c_func
(paren
op_amp
id|cp-&gt;refcnt
)paren
)paren
suffix:semicolon
id|ip_vs_conn_stats
c_func
(paren
id|cp
comma
id|svc
)paren
suffix:semicolon
r_return
id|cp
suffix:semicolon
)brace
multiline_comment|/*&n; *  Pass or drop the packet.&n; *  Called by ip_vs_in, when the virtual service is available but&n; *  no destination is available for a new connection.&n; */
DECL|function|ip_vs_leave
r_int
id|ip_vs_leave
c_func
(paren
r_struct
id|ip_vs_service
op_star
id|svc
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|ip_vs_protocol
op_star
id|pp
)paren
(brace
id|__u16
id|_ports
(braket
l_int|2
)braket
comma
op_star
id|pptr
suffix:semicolon
r_struct
id|iphdr
op_star
id|iph
op_assign
id|skb-&gt;nh.iph
suffix:semicolon
id|pptr
op_assign
id|skb_header_pointer
c_func
(paren
id|skb
comma
id|iph-&gt;ihl
op_star
l_int|4
comma
r_sizeof
(paren
id|_ports
)paren
comma
id|_ports
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pptr
op_eq
l_int|NULL
)paren
(brace
id|ip_vs_service_put
c_func
(paren
id|svc
)paren
suffix:semicolon
r_return
id|NF_DROP
suffix:semicolon
)brace
multiline_comment|/* if it is fwmark-based service, the cache_bypass sysctl is up&n;&t;   and the destination is RTN_UNICAST (and not local), then create&n;&t;   a cache_bypass connection entry */
r_if
c_cond
(paren
id|sysctl_ip_vs_cache_bypass
op_logical_and
id|svc-&gt;fwmark
op_logical_and
(paren
id|inet_addr_type
c_func
(paren
id|iph-&gt;daddr
)paren
op_eq
id|RTN_UNICAST
)paren
)paren
(brace
r_int
id|ret
comma
id|cs
suffix:semicolon
r_struct
id|ip_vs_conn
op_star
id|cp
suffix:semicolon
id|ip_vs_service_put
c_func
(paren
id|svc
)paren
suffix:semicolon
multiline_comment|/* create a new connection entry */
id|IP_VS_DBG
c_func
(paren
l_int|6
comma
l_string|&quot;ip_vs_leave: create a cache_bypass entry&bslash;n&quot;
)paren
suffix:semicolon
id|cp
op_assign
id|ip_vs_conn_new
c_func
(paren
id|iph-&gt;protocol
comma
id|iph-&gt;saddr
comma
id|pptr
(braket
l_int|0
)braket
comma
id|iph-&gt;daddr
comma
id|pptr
(braket
l_int|1
)braket
comma
l_int|0
comma
l_int|0
comma
id|IP_VS_CONN_F_BYPASS
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cp
op_eq
l_int|NULL
)paren
r_return
id|NF_DROP
suffix:semicolon
multiline_comment|/* statistics */
id|ip_vs_in_stats
c_func
(paren
id|cp
comma
id|skb
)paren
suffix:semicolon
multiline_comment|/* set state */
id|cs
op_assign
id|ip_vs_set_state
c_func
(paren
id|cp
comma
id|IP_VS_DIR_INPUT
comma
id|skb
comma
id|pp
)paren
suffix:semicolon
multiline_comment|/* transmit the first SYN packet */
id|ret
op_assign
id|cp
op_member_access_from_pointer
id|packet_xmit
c_func
(paren
id|skb
comma
id|cp
comma
id|pp
)paren
suffix:semicolon
multiline_comment|/* do not touch skb anymore */
id|atomic_inc
c_func
(paren
op_amp
id|cp-&gt;in_pkts
)paren
suffix:semicolon
id|ip_vs_conn_put
c_func
(paren
id|cp
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * When the virtual ftp service is presented, packets destined&n;&t; * for other services on the VIP may get here (except services&n;&t; * listed in the ipvs table), pass the packets, because it is&n;&t; * not ipvs job to decide to drop the packets.&n;&t; */
r_if
c_cond
(paren
(paren
id|svc-&gt;port
op_eq
id|FTPPORT
)paren
op_logical_and
(paren
id|pptr
(braket
l_int|1
)braket
op_ne
id|FTPPORT
)paren
)paren
(brace
id|ip_vs_service_put
c_func
(paren
id|svc
)paren
suffix:semicolon
r_return
id|NF_ACCEPT
suffix:semicolon
)brace
id|ip_vs_service_put
c_func
(paren
id|svc
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Notify the client that the destination is unreachable, and&n;&t; * release the socket buffer.&n;&t; * Since it is in IP layer, the TCP socket is not actually&n;&t; * created, the TCP RST packet cannot be sent, instead that&n;&t; * ICMP_PORT_UNREACH is sent here no matter it is TCP/UDP. --WZ&n;&t; */
id|icmp_send
c_func
(paren
id|skb
comma
id|ICMP_DEST_UNREACH
comma
id|ICMP_PORT_UNREACH
comma
l_int|0
)paren
suffix:semicolon
r_return
id|NF_DROP
suffix:semicolon
)brace
multiline_comment|/*&n; *      It is hooked before NF_IP_PRI_NAT_SRC at the NF_IP_POST_ROUTING&n; *      chain, and is used for VS/NAT.&n; *      It detects packets for VS/NAT connections and sends the packets&n; *      immediately. This can avoid that iptable_nat mangles the packets&n; *      for VS/NAT.&n; */
DECL|function|ip_vs_post_routing
r_static
r_int
r_int
id|ip_vs_post_routing
c_func
(paren
r_int
r_int
id|hooknum
comma
r_struct
id|sk_buff
op_star
op_star
id|pskb
comma
r_const
r_struct
id|net_device
op_star
id|in
comma
r_const
r_struct
id|net_device
op_star
id|out
comma
r_int
(paren
op_star
id|okfn
)paren
(paren
r_struct
id|sk_buff
op_star
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
op_star
id|pskb
)paren
op_member_access_from_pointer
id|nfcache
op_amp
id|NFC_IPVS_PROPERTY
)paren
)paren
r_return
id|NF_ACCEPT
suffix:semicolon
multiline_comment|/* The packet was sent from IPVS, exit this chain */
(paren
op_star
id|okfn
)paren
(paren
op_star
id|pskb
)paren
suffix:semicolon
r_return
id|NF_STOLEN
suffix:semicolon
)brace
DECL|function|ip_vs_checksum_complete
id|u16
id|ip_vs_checksum_complete
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|offset
)paren
(brace
r_return
(paren
id|u16
)paren
id|csum_fold
c_func
(paren
id|skb_checksum
c_func
(paren
id|skb
comma
id|offset
comma
id|skb-&gt;len
op_minus
id|offset
comma
l_int|0
)paren
)paren
suffix:semicolon
)brace
r_static
r_inline
r_struct
id|sk_buff
op_star
DECL|function|ip_vs_gather_frags
id|ip_vs_gather_frags
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
id|u_int32_t
id|user
)paren
(brace
id|skb
op_assign
id|ip_defrag
c_func
(paren
id|skb
comma
id|user
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
)paren
id|ip_send_check
c_func
(paren
id|skb-&gt;nh.iph
)paren
suffix:semicolon
r_return
id|skb
suffix:semicolon
)brace
multiline_comment|/*&n; * Packet has been made sufficiently writable in caller&n; * - inout: 1=in-&gt;out, 0=out-&gt;in&n; */
DECL|function|ip_vs_nat_icmp
r_void
id|ip_vs_nat_icmp
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|ip_vs_protocol
op_star
id|pp
comma
r_struct
id|ip_vs_conn
op_star
id|cp
comma
r_int
id|inout
)paren
(brace
r_struct
id|iphdr
op_star
id|iph
op_assign
id|skb-&gt;nh.iph
suffix:semicolon
r_int
r_int
id|icmp_offset
op_assign
id|iph-&gt;ihl
op_star
l_int|4
suffix:semicolon
r_struct
id|icmphdr
op_star
id|icmph
op_assign
(paren
r_struct
id|icmphdr
op_star
)paren
(paren
id|skb-&gt;nh.raw
op_plus
id|icmp_offset
)paren
suffix:semicolon
r_struct
id|iphdr
op_star
id|ciph
op_assign
(paren
r_struct
id|iphdr
op_star
)paren
(paren
id|icmph
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inout
)paren
(brace
id|iph-&gt;saddr
op_assign
id|cp-&gt;vaddr
suffix:semicolon
id|ip_send_check
c_func
(paren
id|iph
)paren
suffix:semicolon
id|ciph-&gt;daddr
op_assign
id|cp-&gt;vaddr
suffix:semicolon
id|ip_send_check
c_func
(paren
id|ciph
)paren
suffix:semicolon
)brace
r_else
(brace
id|iph-&gt;daddr
op_assign
id|cp-&gt;daddr
suffix:semicolon
id|ip_send_check
c_func
(paren
id|iph
)paren
suffix:semicolon
id|ciph-&gt;saddr
op_assign
id|cp-&gt;daddr
suffix:semicolon
id|ip_send_check
c_func
(paren
id|ciph
)paren
suffix:semicolon
)brace
multiline_comment|/* the TCP/UDP port */
r_if
c_cond
(paren
id|IPPROTO_TCP
op_eq
id|ciph-&gt;protocol
op_logical_or
id|IPPROTO_UDP
op_eq
id|ciph-&gt;protocol
)paren
(brace
id|__u16
op_star
id|ports
op_assign
(paren
r_void
op_star
)paren
id|ciph
op_plus
id|ciph-&gt;ihl
op_star
l_int|4
suffix:semicolon
r_if
c_cond
(paren
id|inout
)paren
id|ports
(braket
l_int|1
)braket
op_assign
id|cp-&gt;vport
suffix:semicolon
r_else
id|ports
(braket
l_int|0
)braket
op_assign
id|cp-&gt;dport
suffix:semicolon
)brace
multiline_comment|/* And finally the ICMP checksum */
id|icmph-&gt;checksum
op_assign
l_int|0
suffix:semicolon
id|icmph-&gt;checksum
op_assign
id|ip_vs_checksum_complete
c_func
(paren
id|skb
comma
id|icmp_offset
)paren
suffix:semicolon
id|skb-&gt;ip_summed
op_assign
id|CHECKSUM_UNNECESSARY
suffix:semicolon
r_if
c_cond
(paren
id|inout
)paren
id|IP_VS_DBG_PKT
c_func
(paren
l_int|11
comma
id|pp
comma
id|skb
comma
(paren
r_void
op_star
)paren
id|ciph
op_minus
(paren
r_void
op_star
)paren
id|iph
comma
l_string|&quot;Forwarding altered outgoing ICMP&quot;
)paren
suffix:semicolon
r_else
id|IP_VS_DBG_PKT
c_func
(paren
l_int|11
comma
id|pp
comma
id|skb
comma
(paren
r_void
op_star
)paren
id|ciph
op_minus
(paren
r_void
op_star
)paren
id|iph
comma
l_string|&quot;Forwarding altered incoming ICMP&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Handle ICMP messages in the inside-to-outside direction (outgoing).&n; *&t;Find any that might be relevant, check against existing connections,&n; *&t;forward to the right destination host if relevant.&n; *&t;Currently handles error types - unreachable, quench, ttl exceeded.&n; *&t;(Only used in VS/NAT)&n; */
DECL|function|ip_vs_out_icmp
r_static
r_int
id|ip_vs_out_icmp
c_func
(paren
r_struct
id|sk_buff
op_star
op_star
id|pskb
comma
r_int
op_star
id|related
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
op_assign
op_star
id|pskb
suffix:semicolon
r_struct
id|iphdr
op_star
id|iph
suffix:semicolon
r_struct
id|icmphdr
id|_icmph
comma
op_star
id|ic
suffix:semicolon
r_struct
id|iphdr
id|_ciph
comma
op_star
id|cih
suffix:semicolon
multiline_comment|/* The ip header contained within the ICMP */
r_struct
id|ip_vs_conn
op_star
id|cp
suffix:semicolon
r_struct
id|ip_vs_protocol
op_star
id|pp
suffix:semicolon
r_int
r_int
id|offset
comma
id|ihl
comma
id|verdict
suffix:semicolon
op_star
id|related
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* reassemble IP fragments */
r_if
c_cond
(paren
id|skb-&gt;nh.iph-&gt;frag_off
op_amp
id|__constant_htons
c_func
(paren
id|IP_MF
op_or
id|IP_OFFSET
)paren
)paren
(brace
id|skb
op_assign
id|ip_vs_gather_frags
c_func
(paren
id|skb
comma
id|IP_DEFRAG_VS_OUT
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skb
)paren
r_return
id|NF_STOLEN
suffix:semicolon
op_star
id|pskb
op_assign
id|skb
suffix:semicolon
)brace
id|iph
op_assign
id|skb-&gt;nh.iph
suffix:semicolon
id|offset
op_assign
id|ihl
op_assign
id|iph-&gt;ihl
op_star
l_int|4
suffix:semicolon
id|ic
op_assign
id|skb_header_pointer
c_func
(paren
id|skb
comma
id|offset
comma
r_sizeof
(paren
id|_icmph
)paren
comma
op_amp
id|_icmph
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ic
op_eq
l_int|NULL
)paren
r_return
id|NF_DROP
suffix:semicolon
id|IP_VS_DBG
c_func
(paren
l_int|12
comma
l_string|&quot;Outgoing ICMP (%d,%d) %u.%u.%u.%u-&gt;%u.%u.%u.%u&bslash;n&quot;
comma
id|ic-&gt;type
comma
id|ntohs
c_func
(paren
id|icmp_id
c_func
(paren
id|ic
)paren
)paren
comma
id|NIPQUAD
c_func
(paren
id|iph-&gt;saddr
)paren
comma
id|NIPQUAD
c_func
(paren
id|iph-&gt;daddr
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Work through seeing if this is for us.&n;&t; * These checks are supposed to be in an order that means easy&n;&t; * things are checked first to speed up processing.... however&n;&t; * this means that some packets will manage to get a long way&n;&t; * down this stack and then be rejected, but that&squot;s life.&n;&t; */
r_if
c_cond
(paren
(paren
id|ic-&gt;type
op_ne
id|ICMP_DEST_UNREACH
)paren
op_logical_and
(paren
id|ic-&gt;type
op_ne
id|ICMP_SOURCE_QUENCH
)paren
op_logical_and
(paren
id|ic-&gt;type
op_ne
id|ICMP_TIME_EXCEEDED
)paren
)paren
(brace
op_star
id|related
op_assign
l_int|0
suffix:semicolon
r_return
id|NF_ACCEPT
suffix:semicolon
)brace
multiline_comment|/* Now find the contained IP header */
id|offset
op_add_assign
r_sizeof
(paren
id|_icmph
)paren
suffix:semicolon
id|cih
op_assign
id|skb_header_pointer
c_func
(paren
id|skb
comma
id|offset
comma
r_sizeof
(paren
id|_ciph
)paren
comma
op_amp
id|_ciph
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cih
op_eq
l_int|NULL
)paren
r_return
id|NF_ACCEPT
suffix:semicolon
multiline_comment|/* The packet looks wrong, ignore */
id|pp
op_assign
id|ip_vs_proto_get
c_func
(paren
id|cih-&gt;protocol
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pp
)paren
r_return
id|NF_ACCEPT
suffix:semicolon
multiline_comment|/* Is the embedded protocol header present? */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|cih-&gt;frag_off
op_amp
id|__constant_htons
c_func
(paren
id|IP_OFFSET
)paren
op_logical_and
id|pp-&gt;dont_defrag
)paren
)paren
r_return
id|NF_ACCEPT
suffix:semicolon
id|IP_VS_DBG_PKT
c_func
(paren
l_int|11
comma
id|pp
comma
id|skb
comma
id|offset
comma
l_string|&quot;Checking outgoing ICMP for&quot;
)paren
suffix:semicolon
id|offset
op_add_assign
id|cih-&gt;ihl
op_star
l_int|4
suffix:semicolon
multiline_comment|/* The embedded headers contain source and dest in reverse order */
id|cp
op_assign
id|pp
op_member_access_from_pointer
id|conn_out_get
c_func
(paren
id|skb
comma
id|pp
comma
id|cih
comma
id|offset
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cp
)paren
r_return
id|NF_ACCEPT
suffix:semicolon
id|verdict
op_assign
id|NF_DROP
suffix:semicolon
r_if
c_cond
(paren
id|IP_VS_FWD_METHOD
c_func
(paren
id|cp
)paren
op_ne
l_int|0
)paren
(brace
id|IP_VS_ERR
c_func
(paren
l_string|&quot;shouldn&squot;t reach here, because the box is on the&quot;
l_string|&quot;half connection in the tun/dr module.&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* Ensure the checksum is correct */
r_if
c_cond
(paren
id|skb-&gt;ip_summed
op_ne
id|CHECKSUM_UNNECESSARY
op_logical_and
id|ip_vs_checksum_complete
c_func
(paren
id|skb
comma
id|ihl
)paren
)paren
(brace
multiline_comment|/* Failed checksum! */
id|IP_VS_DBG
c_func
(paren
l_int|1
comma
l_string|&quot;Forward ICMP: failed checksum from %d.%d.%d.%d!&bslash;n&quot;
comma
id|NIPQUAD
c_func
(paren
id|iph-&gt;saddr
)paren
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|IPPROTO_TCP
op_eq
id|cih-&gt;protocol
op_logical_or
id|IPPROTO_UDP
op_eq
id|cih-&gt;protocol
)paren
id|offset
op_add_assign
l_int|2
op_star
r_sizeof
(paren
id|__u16
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ip_vs_make_skb_writable
c_func
(paren
id|pskb
comma
id|offset
)paren
)paren
r_goto
id|out
suffix:semicolon
id|skb
op_assign
op_star
id|pskb
suffix:semicolon
id|ip_vs_nat_icmp
c_func
(paren
id|skb
comma
id|pp
comma
id|cp
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* do the statistics and put it back */
id|ip_vs_out_stats
c_func
(paren
id|cp
comma
id|skb
)paren
suffix:semicolon
id|skb-&gt;nfcache
op_or_assign
id|NFC_IPVS_PROPERTY
suffix:semicolon
id|verdict
op_assign
id|NF_ACCEPT
suffix:semicolon
id|out
suffix:colon
id|__ip_vs_conn_put
c_func
(paren
id|cp
)paren
suffix:semicolon
r_return
id|verdict
suffix:semicolon
)brace
DECL|function|is_tcp_reset
r_static
r_inline
r_int
id|is_tcp_reset
c_func
(paren
r_const
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|tcphdr
id|_tcph
comma
op_star
id|th
suffix:semicolon
id|th
op_assign
id|skb_header_pointer
c_func
(paren
id|skb
comma
id|skb-&gt;nh.iph-&gt;ihl
op_star
l_int|4
comma
r_sizeof
(paren
id|_tcph
)paren
comma
op_amp
id|_tcph
)paren
suffix:semicolon
r_if
c_cond
(paren
id|th
op_eq
l_int|NULL
)paren
r_return
l_int|0
suffix:semicolon
r_return
id|th-&gt;rst
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;It is hooked at the NF_IP_FORWARD chain, used only for VS/NAT.&n; *&t;Check if outgoing packet belongs to the established ip_vs_conn,&n; *      rewrite addresses of the packet and send it on its way...&n; */
r_static
r_int
r_int
DECL|function|ip_vs_out
id|ip_vs_out
c_func
(paren
r_int
r_int
id|hooknum
comma
r_struct
id|sk_buff
op_star
op_star
id|pskb
comma
r_const
r_struct
id|net_device
op_star
id|in
comma
r_const
r_struct
id|net_device
op_star
id|out
comma
r_int
(paren
op_star
id|okfn
)paren
(paren
r_struct
id|sk_buff
op_star
)paren
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
op_assign
op_star
id|pskb
suffix:semicolon
r_struct
id|iphdr
op_star
id|iph
suffix:semicolon
r_struct
id|ip_vs_protocol
op_star
id|pp
suffix:semicolon
r_struct
id|ip_vs_conn
op_star
id|cp
suffix:semicolon
r_int
id|ihl
suffix:semicolon
id|EnterFunction
c_func
(paren
l_int|11
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb-&gt;nfcache
op_amp
id|NFC_IPVS_PROPERTY
)paren
r_return
id|NF_ACCEPT
suffix:semicolon
id|iph
op_assign
id|skb-&gt;nh.iph
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|iph-&gt;protocol
op_eq
id|IPPROTO_ICMP
)paren
)paren
(brace
r_int
id|related
comma
id|verdict
op_assign
id|ip_vs_out_icmp
c_func
(paren
id|pskb
comma
op_amp
id|related
)paren
suffix:semicolon
r_if
c_cond
(paren
id|related
)paren
r_return
id|verdict
suffix:semicolon
id|skb
op_assign
op_star
id|pskb
suffix:semicolon
id|iph
op_assign
id|skb-&gt;nh.iph
suffix:semicolon
)brace
id|pp
op_assign
id|ip_vs_proto_get
c_func
(paren
id|iph-&gt;protocol
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|pp
)paren
)paren
r_return
id|NF_ACCEPT
suffix:semicolon
multiline_comment|/* reassemble IP fragments */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|iph-&gt;frag_off
op_amp
id|__constant_htons
c_func
(paren
id|IP_MF
op_or
id|IP_OFFSET
)paren
op_logical_and
op_logical_neg
id|pp-&gt;dont_defrag
)paren
)paren
(brace
id|skb
op_assign
id|ip_vs_gather_frags
c_func
(paren
id|skb
comma
id|IP_DEFRAG_VS_OUT
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skb
)paren
r_return
id|NF_STOLEN
suffix:semicolon
id|iph
op_assign
id|skb-&gt;nh.iph
suffix:semicolon
op_star
id|pskb
op_assign
id|skb
suffix:semicolon
)brace
id|ihl
op_assign
id|iph-&gt;ihl
op_lshift
l_int|2
suffix:semicolon
multiline_comment|/*&n;&t; * Check if the packet belongs to an existing entry&n;&t; */
id|cp
op_assign
id|pp
op_member_access_from_pointer
id|conn_out_get
c_func
(paren
id|skb
comma
id|pp
comma
id|iph
comma
id|ihl
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|cp
)paren
)paren
(brace
r_if
c_cond
(paren
id|sysctl_ip_vs_nat_icmp_send
op_logical_and
(paren
id|pp-&gt;protocol
op_eq
id|IPPROTO_TCP
op_logical_or
id|pp-&gt;protocol
op_eq
id|IPPROTO_UDP
)paren
)paren
(brace
id|__u16
id|_ports
(braket
l_int|2
)braket
comma
op_star
id|pptr
suffix:semicolon
id|pptr
op_assign
id|skb_header_pointer
c_func
(paren
id|skb
comma
id|ihl
comma
r_sizeof
(paren
id|_ports
)paren
comma
id|_ports
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pptr
op_eq
l_int|NULL
)paren
r_return
id|NF_ACCEPT
suffix:semicolon
multiline_comment|/* Not for me */
r_if
c_cond
(paren
id|ip_vs_lookup_real_service
c_func
(paren
id|iph-&gt;protocol
comma
id|iph-&gt;saddr
comma
id|pptr
(braket
l_int|0
)braket
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * Notify the real server: there is no&n;&t;&t;&t;&t; * existing entry if it is not RST&n;&t;&t;&t;&t; * packet or not TCP packet.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|iph-&gt;protocol
op_ne
id|IPPROTO_TCP
op_logical_or
op_logical_neg
id|is_tcp_reset
c_func
(paren
id|skb
)paren
)paren
(brace
id|icmp_send
c_func
(paren
id|skb
comma
id|ICMP_DEST_UNREACH
comma
id|ICMP_PORT_UNREACH
comma
l_int|0
)paren
suffix:semicolon
r_return
id|NF_DROP
suffix:semicolon
)brace
)brace
)brace
id|IP_VS_DBG_PKT
c_func
(paren
l_int|12
comma
id|pp
comma
id|skb
comma
l_int|0
comma
l_string|&quot;packet continues traversal as normal&quot;
)paren
suffix:semicolon
r_return
id|NF_ACCEPT
suffix:semicolon
)brace
id|IP_VS_DBG_PKT
c_func
(paren
l_int|11
comma
id|pp
comma
id|skb
comma
l_int|0
comma
l_string|&quot;Outgoing packet&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ip_vs_make_skb_writable
c_func
(paren
id|pskb
comma
id|ihl
)paren
)paren
r_goto
id|drop
suffix:semicolon
multiline_comment|/* mangle the packet */
r_if
c_cond
(paren
id|pp-&gt;snat_handler
op_logical_and
op_logical_neg
id|pp
op_member_access_from_pointer
id|snat_handler
c_func
(paren
id|pskb
comma
id|pp
comma
id|cp
)paren
)paren
r_goto
id|drop
suffix:semicolon
id|skb
op_assign
op_star
id|pskb
suffix:semicolon
id|skb-&gt;nh.iph-&gt;saddr
op_assign
id|cp-&gt;vaddr
suffix:semicolon
id|ip_send_check
c_func
(paren
id|skb-&gt;nh.iph
)paren
suffix:semicolon
id|IP_VS_DBG_PKT
c_func
(paren
l_int|10
comma
id|pp
comma
id|skb
comma
l_int|0
comma
l_string|&quot;After SNAT&quot;
)paren
suffix:semicolon
id|ip_vs_out_stats
c_func
(paren
id|cp
comma
id|skb
)paren
suffix:semicolon
id|ip_vs_set_state
c_func
(paren
id|cp
comma
id|IP_VS_DIR_OUTPUT
comma
id|skb
comma
id|pp
)paren
suffix:semicolon
id|ip_vs_conn_put
c_func
(paren
id|cp
)paren
suffix:semicolon
id|skb-&gt;nfcache
op_or_assign
id|NFC_IPVS_PROPERTY
suffix:semicolon
id|LeaveFunction
c_func
(paren
l_int|11
)paren
suffix:semicolon
r_return
id|NF_ACCEPT
suffix:semicolon
id|drop
suffix:colon
id|ip_vs_conn_put
c_func
(paren
id|cp
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
op_star
id|pskb
)paren
suffix:semicolon
r_return
id|NF_STOLEN
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Handle ICMP messages in the outside-to-inside direction (incoming).&n; *&t;Find any that might be relevant, check against existing connections,&n; *&t;forward to the right destination host if relevant.&n; *&t;Currently handles error types - unreachable, quench, ttl exceeded.&n; */
r_static
r_int
DECL|function|ip_vs_in_icmp
id|ip_vs_in_icmp
c_func
(paren
r_struct
id|sk_buff
op_star
op_star
id|pskb
comma
r_int
op_star
id|related
comma
r_int
r_int
id|hooknum
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
op_assign
op_star
id|pskb
suffix:semicolon
r_struct
id|iphdr
op_star
id|iph
suffix:semicolon
r_struct
id|icmphdr
id|_icmph
comma
op_star
id|ic
suffix:semicolon
r_struct
id|iphdr
id|_ciph
comma
op_star
id|cih
suffix:semicolon
multiline_comment|/* The ip header contained within the ICMP */
r_struct
id|ip_vs_conn
op_star
id|cp
suffix:semicolon
r_struct
id|ip_vs_protocol
op_star
id|pp
suffix:semicolon
r_int
r_int
id|offset
comma
id|ihl
comma
id|verdict
suffix:semicolon
op_star
id|related
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* reassemble IP fragments */
r_if
c_cond
(paren
id|skb-&gt;nh.iph-&gt;frag_off
op_amp
id|__constant_htons
c_func
(paren
id|IP_MF
op_or
id|IP_OFFSET
)paren
)paren
(brace
id|skb
op_assign
id|ip_vs_gather_frags
c_func
(paren
id|skb
comma
id|hooknum
op_eq
id|NF_IP_LOCAL_IN
ques
c_cond
id|IP_DEFRAG_VS_IN
suffix:colon
id|IP_DEFRAG_VS_FWD
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skb
)paren
r_return
id|NF_STOLEN
suffix:semicolon
op_star
id|pskb
op_assign
id|skb
suffix:semicolon
)brace
id|iph
op_assign
id|skb-&gt;nh.iph
suffix:semicolon
id|offset
op_assign
id|ihl
op_assign
id|iph-&gt;ihl
op_star
l_int|4
suffix:semicolon
id|ic
op_assign
id|skb_header_pointer
c_func
(paren
id|skb
comma
id|offset
comma
r_sizeof
(paren
id|_icmph
)paren
comma
op_amp
id|_icmph
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ic
op_eq
l_int|NULL
)paren
r_return
id|NF_DROP
suffix:semicolon
id|IP_VS_DBG
c_func
(paren
l_int|12
comma
l_string|&quot;Incoming ICMP (%d,%d) %u.%u.%u.%u-&gt;%u.%u.%u.%u&bslash;n&quot;
comma
id|ic-&gt;type
comma
id|ntohs
c_func
(paren
id|icmp_id
c_func
(paren
id|ic
)paren
)paren
comma
id|NIPQUAD
c_func
(paren
id|iph-&gt;saddr
)paren
comma
id|NIPQUAD
c_func
(paren
id|iph-&gt;daddr
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Work through seeing if this is for us.&n;&t; * These checks are supposed to be in an order that means easy&n;&t; * things are checked first to speed up processing.... however&n;&t; * this means that some packets will manage to get a long way&n;&t; * down this stack and then be rejected, but that&squot;s life.&n;&t; */
r_if
c_cond
(paren
(paren
id|ic-&gt;type
op_ne
id|ICMP_DEST_UNREACH
)paren
op_logical_and
(paren
id|ic-&gt;type
op_ne
id|ICMP_SOURCE_QUENCH
)paren
op_logical_and
(paren
id|ic-&gt;type
op_ne
id|ICMP_TIME_EXCEEDED
)paren
)paren
(brace
op_star
id|related
op_assign
l_int|0
suffix:semicolon
r_return
id|NF_ACCEPT
suffix:semicolon
)brace
multiline_comment|/* Now find the contained IP header */
id|offset
op_add_assign
r_sizeof
(paren
id|_icmph
)paren
suffix:semicolon
id|cih
op_assign
id|skb_header_pointer
c_func
(paren
id|skb
comma
id|offset
comma
r_sizeof
(paren
id|_ciph
)paren
comma
op_amp
id|_ciph
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cih
op_eq
l_int|NULL
)paren
r_return
id|NF_ACCEPT
suffix:semicolon
multiline_comment|/* The packet looks wrong, ignore */
id|pp
op_assign
id|ip_vs_proto_get
c_func
(paren
id|cih-&gt;protocol
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pp
)paren
r_return
id|NF_ACCEPT
suffix:semicolon
multiline_comment|/* Is the embedded protocol header present? */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|cih-&gt;frag_off
op_amp
id|__constant_htons
c_func
(paren
id|IP_OFFSET
)paren
op_logical_and
id|pp-&gt;dont_defrag
)paren
)paren
r_return
id|NF_ACCEPT
suffix:semicolon
id|IP_VS_DBG_PKT
c_func
(paren
l_int|11
comma
id|pp
comma
id|skb
comma
id|offset
comma
l_string|&quot;Checking incoming ICMP for&quot;
)paren
suffix:semicolon
id|offset
op_add_assign
id|cih-&gt;ihl
op_star
l_int|4
suffix:semicolon
multiline_comment|/* The embedded headers contain source and dest in reverse order */
id|cp
op_assign
id|pp
op_member_access_from_pointer
id|conn_in_get
c_func
(paren
id|skb
comma
id|pp
comma
id|cih
comma
id|offset
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cp
)paren
r_return
id|NF_ACCEPT
suffix:semicolon
id|verdict
op_assign
id|NF_DROP
suffix:semicolon
multiline_comment|/* Ensure the checksum is correct */
r_if
c_cond
(paren
id|skb-&gt;ip_summed
op_ne
id|CHECKSUM_UNNECESSARY
op_logical_and
id|ip_vs_checksum_complete
c_func
(paren
id|skb
comma
id|ihl
)paren
)paren
(brace
multiline_comment|/* Failed checksum! */
id|IP_VS_DBG
c_func
(paren
l_int|1
comma
l_string|&quot;Incoming ICMP: failed checksum from %d.%d.%d.%d!&bslash;n&quot;
comma
id|NIPQUAD
c_func
(paren
id|iph-&gt;saddr
)paren
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* do the statistics and put it back */
id|ip_vs_in_stats
c_func
(paren
id|cp
comma
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IPPROTO_TCP
op_eq
id|cih-&gt;protocol
op_logical_or
id|IPPROTO_UDP
op_eq
id|cih-&gt;protocol
)paren
id|offset
op_add_assign
l_int|2
op_star
r_sizeof
(paren
id|__u16
)paren
suffix:semicolon
id|verdict
op_assign
id|ip_vs_icmp_xmit
c_func
(paren
id|skb
comma
id|cp
comma
id|pp
comma
id|offset
)paren
suffix:semicolon
multiline_comment|/* do not touch skb anymore */
id|out
suffix:colon
id|__ip_vs_conn_put
c_func
(paren
id|cp
)paren
suffix:semicolon
r_return
id|verdict
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Check if it&squot;s for virtual services, look it up,&n; *&t;and send it on its way...&n; */
r_static
r_int
r_int
DECL|function|ip_vs_in
id|ip_vs_in
c_func
(paren
r_int
r_int
id|hooknum
comma
r_struct
id|sk_buff
op_star
op_star
id|pskb
comma
r_const
r_struct
id|net_device
op_star
id|in
comma
r_const
r_struct
id|net_device
op_star
id|out
comma
r_int
(paren
op_star
id|okfn
)paren
(paren
r_struct
id|sk_buff
op_star
)paren
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
op_assign
op_star
id|pskb
suffix:semicolon
r_struct
id|iphdr
op_star
id|iph
suffix:semicolon
r_struct
id|ip_vs_protocol
op_star
id|pp
suffix:semicolon
r_struct
id|ip_vs_conn
op_star
id|cp
suffix:semicolon
r_int
id|ret
comma
id|restart
suffix:semicolon
r_int
id|ihl
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Big tappo: only PACKET_HOST (neither loopback nor mcasts)&n;&t; *&t;... don&squot;t know why 1st test DOES NOT include 2nd (?)&n;&t; */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|skb-&gt;pkt_type
op_ne
id|PACKET_HOST
op_logical_or
id|skb-&gt;dev
op_eq
op_amp
id|loopback_dev
op_logical_or
id|skb-&gt;sk
)paren
)paren
(brace
id|IP_VS_DBG
c_func
(paren
l_int|12
comma
l_string|&quot;packet type=%d proto=%d daddr=%d.%d.%d.%d ignored&bslash;n&quot;
comma
id|skb-&gt;pkt_type
comma
id|skb-&gt;nh.iph-&gt;protocol
comma
id|NIPQUAD
c_func
(paren
id|skb-&gt;nh.iph-&gt;daddr
)paren
)paren
suffix:semicolon
r_return
id|NF_ACCEPT
suffix:semicolon
)brace
id|iph
op_assign
id|skb-&gt;nh.iph
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|iph-&gt;protocol
op_eq
id|IPPROTO_ICMP
)paren
)paren
(brace
r_int
id|related
comma
id|verdict
op_assign
id|ip_vs_in_icmp
c_func
(paren
id|pskb
comma
op_amp
id|related
comma
id|hooknum
)paren
suffix:semicolon
r_if
c_cond
(paren
id|related
)paren
r_return
id|verdict
suffix:semicolon
id|skb
op_assign
op_star
id|pskb
suffix:semicolon
id|iph
op_assign
id|skb-&gt;nh.iph
suffix:semicolon
)brace
multiline_comment|/* Protocol supported? */
id|pp
op_assign
id|ip_vs_proto_get
c_func
(paren
id|iph-&gt;protocol
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|pp
)paren
)paren
r_return
id|NF_ACCEPT
suffix:semicolon
id|ihl
op_assign
id|iph-&gt;ihl
op_lshift
l_int|2
suffix:semicolon
multiline_comment|/*&n;&t; * Check if the packet belongs to an existing connection entry&n;&t; */
id|cp
op_assign
id|pp
op_member_access_from_pointer
id|conn_in_get
c_func
(paren
id|skb
comma
id|pp
comma
id|iph
comma
id|ihl
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|cp
)paren
)paren
(brace
r_int
id|v
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pp
op_member_access_from_pointer
id|conn_schedule
c_func
(paren
id|skb
comma
id|pp
comma
op_amp
id|v
comma
op_amp
id|cp
)paren
)paren
r_return
id|v
suffix:semicolon
)brace
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|cp
)paren
)paren
(brace
multiline_comment|/* sorry, all this trouble for a no-hit :) */
id|IP_VS_DBG_PKT
c_func
(paren
l_int|12
comma
id|pp
comma
id|skb
comma
l_int|0
comma
l_string|&quot;packet continues traversal as normal&quot;
)paren
suffix:semicolon
r_return
id|NF_ACCEPT
suffix:semicolon
)brace
id|IP_VS_DBG_PKT
c_func
(paren
l_int|11
comma
id|pp
comma
id|skb
comma
l_int|0
comma
l_string|&quot;Incoming packet&quot;
)paren
suffix:semicolon
multiline_comment|/* Check the server status */
r_if
c_cond
(paren
id|cp-&gt;dest
op_logical_and
op_logical_neg
(paren
id|cp-&gt;dest-&gt;flags
op_amp
id|IP_VS_DEST_F_AVAILABLE
)paren
)paren
(brace
multiline_comment|/* the destination server is not availabe */
r_if
c_cond
(paren
id|sysctl_ip_vs_expire_nodest_conn
)paren
(brace
multiline_comment|/* try to expire the connection immediately */
id|ip_vs_conn_expire_now
c_func
(paren
id|cp
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* don&squot;t restart its timer, and silently&n;&t;&t;&t;   drop the packet. */
id|__ip_vs_conn_put
c_func
(paren
id|cp
)paren
suffix:semicolon
)brace
r_return
id|NF_DROP
suffix:semicolon
)brace
id|ip_vs_in_stats
c_func
(paren
id|cp
comma
id|skb
)paren
suffix:semicolon
id|restart
op_assign
id|ip_vs_set_state
c_func
(paren
id|cp
comma
id|IP_VS_DIR_INPUT
comma
id|skb
comma
id|pp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cp-&gt;packet_xmit
)paren
id|ret
op_assign
id|cp
op_member_access_from_pointer
id|packet_xmit
c_func
(paren
id|skb
comma
id|cp
comma
id|pp
)paren
suffix:semicolon
multiline_comment|/* do not touch skb anymore */
r_else
(brace
id|IP_VS_DBG_RL
c_func
(paren
l_string|&quot;warning: packet_xmit is null&quot;
)paren
suffix:semicolon
id|ret
op_assign
id|NF_ACCEPT
suffix:semicolon
)brace
multiline_comment|/* increase its packet counter and check if it is needed&n;&t;   to be synchronized */
id|atomic_inc
c_func
(paren
op_amp
id|cp-&gt;in_pkts
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ip_vs_sync_state
op_amp
id|IP_VS_STATE_MASTER
)paren
op_logical_and
(paren
id|cp-&gt;protocol
op_ne
id|IPPROTO_TCP
op_logical_or
id|cp-&gt;state
op_eq
id|IP_VS_TCP_S_ESTABLISHED
)paren
op_logical_and
(paren
id|atomic_read
c_func
(paren
op_amp
id|cp-&gt;in_pkts
)paren
op_mod
id|sysctl_ip_vs_sync_threshold
(braket
l_int|1
)braket
op_eq
id|sysctl_ip_vs_sync_threshold
(braket
l_int|0
)braket
)paren
)paren
id|ip_vs_sync_conn
c_func
(paren
id|cp
)paren
suffix:semicolon
id|ip_vs_conn_put
c_func
(paren
id|cp
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;It is hooked at the NF_IP_FORWARD chain, in order to catch ICMP&n; *      related packets destined for 0.0.0.0/0.&n; *      When fwmark-based virtual service is used, such as transparent&n; *      cache cluster, TCP packets can be marked and routed to ip_vs_in,&n; *      but ICMP destined for 0.0.0.0/0 cannot not be easily marked and&n; *      sent to ip_vs_in_icmp. So, catch them at the NF_IP_FORWARD chain&n; *      and send them to ip_vs_in_icmp.&n; */
r_static
r_int
r_int
DECL|function|ip_vs_forward_icmp
id|ip_vs_forward_icmp
c_func
(paren
r_int
r_int
id|hooknum
comma
r_struct
id|sk_buff
op_star
op_star
id|pskb
comma
r_const
r_struct
id|net_device
op_star
id|in
comma
r_const
r_struct
id|net_device
op_star
id|out
comma
r_int
(paren
op_star
id|okfn
)paren
(paren
r_struct
id|sk_buff
op_star
)paren
)paren
(brace
r_int
id|r
suffix:semicolon
r_if
c_cond
(paren
(paren
op_star
id|pskb
)paren
op_member_access_from_pointer
id|nh.iph-&gt;protocol
op_ne
id|IPPROTO_ICMP
)paren
r_return
id|NF_ACCEPT
suffix:semicolon
r_return
id|ip_vs_in_icmp
c_func
(paren
id|pskb
comma
op_amp
id|r
comma
id|hooknum
)paren
suffix:semicolon
)brace
multiline_comment|/* After packet filtering, forward packet through VS/DR, VS/TUN,&n;   or VS/NAT(change destination), so that filtering rules can be&n;   applied to IPVS. */
DECL|variable|ip_vs_in_ops
r_static
r_struct
id|nf_hook_ops
id|ip_vs_in_ops
op_assign
(brace
dot
id|hook
op_assign
id|ip_vs_in
comma
dot
id|owner
op_assign
id|THIS_MODULE
comma
dot
id|pf
op_assign
id|PF_INET
comma
dot
id|hooknum
op_assign
id|NF_IP_LOCAL_IN
comma
dot
id|priority
op_assign
l_int|100
comma
)brace
suffix:semicolon
multiline_comment|/* After packet filtering, change source only for VS/NAT */
DECL|variable|ip_vs_out_ops
r_static
r_struct
id|nf_hook_ops
id|ip_vs_out_ops
op_assign
(brace
dot
id|hook
op_assign
id|ip_vs_out
comma
dot
id|owner
op_assign
id|THIS_MODULE
comma
dot
id|pf
op_assign
id|PF_INET
comma
dot
id|hooknum
op_assign
id|NF_IP_FORWARD
comma
dot
id|priority
op_assign
l_int|100
comma
)brace
suffix:semicolon
multiline_comment|/* After packet filtering (but before ip_vs_out_icmp), catch icmp&n;   destined for 0.0.0.0/0, which is for incoming IPVS connections */
DECL|variable|ip_vs_forward_icmp_ops
r_static
r_struct
id|nf_hook_ops
id|ip_vs_forward_icmp_ops
op_assign
(brace
dot
id|hook
op_assign
id|ip_vs_forward_icmp
comma
dot
id|owner
op_assign
id|THIS_MODULE
comma
dot
id|pf
op_assign
id|PF_INET
comma
dot
id|hooknum
op_assign
id|NF_IP_FORWARD
comma
dot
id|priority
op_assign
l_int|99
comma
)brace
suffix:semicolon
multiline_comment|/* Before the netfilter connection tracking, exit from POST_ROUTING */
DECL|variable|ip_vs_post_routing_ops
r_static
r_struct
id|nf_hook_ops
id|ip_vs_post_routing_ops
op_assign
(brace
dot
id|hook
op_assign
id|ip_vs_post_routing
comma
dot
id|owner
op_assign
id|THIS_MODULE
comma
dot
id|pf
op_assign
id|PF_INET
comma
dot
id|hooknum
op_assign
id|NF_IP_POST_ROUTING
comma
dot
id|priority
op_assign
id|NF_IP_PRI_NAT_SRC
op_minus
l_int|1
comma
)brace
suffix:semicolon
multiline_comment|/*&n; *&t;Initialize IP Virtual Server&n; */
DECL|function|ip_vs_init
r_static
r_int
id|__init
id|ip_vs_init
c_func
(paren
r_void
)paren
(brace
r_int
id|ret
suffix:semicolon
id|ret
op_assign
id|ip_vs_control_init
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
(brace
id|IP_VS_ERR
c_func
(paren
l_string|&quot;can&squot;t setup control.&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|cleanup_nothing
suffix:semicolon
)brace
id|ip_vs_protocol_init
c_func
(paren
)paren
suffix:semicolon
id|ret
op_assign
id|ip_vs_app_init
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
(brace
id|IP_VS_ERR
c_func
(paren
l_string|&quot;can&squot;t setup application helper.&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|cleanup_protocol
suffix:semicolon
)brace
id|ret
op_assign
id|ip_vs_conn_init
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
(brace
id|IP_VS_ERR
c_func
(paren
l_string|&quot;can&squot;t setup connection table.&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|cleanup_app
suffix:semicolon
)brace
id|ret
op_assign
id|nf_register_hook
c_func
(paren
op_amp
id|ip_vs_in_ops
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
(brace
id|IP_VS_ERR
c_func
(paren
l_string|&quot;can&squot;t register in hook.&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|cleanup_conn
suffix:semicolon
)brace
id|ret
op_assign
id|nf_register_hook
c_func
(paren
op_amp
id|ip_vs_out_ops
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
(brace
id|IP_VS_ERR
c_func
(paren
l_string|&quot;can&squot;t register out hook.&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|cleanup_inops
suffix:semicolon
)brace
id|ret
op_assign
id|nf_register_hook
c_func
(paren
op_amp
id|ip_vs_post_routing_ops
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
(brace
id|IP_VS_ERR
c_func
(paren
l_string|&quot;can&squot;t register post_routing hook.&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|cleanup_outops
suffix:semicolon
)brace
id|ret
op_assign
id|nf_register_hook
c_func
(paren
op_amp
id|ip_vs_forward_icmp_ops
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
(brace
id|IP_VS_ERR
c_func
(paren
l_string|&quot;can&squot;t register forward_icmp hook.&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|cleanup_postroutingops
suffix:semicolon
)brace
id|IP_VS_INFO
c_func
(paren
l_string|&quot;ipvs loaded.&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
id|cleanup_postroutingops
suffix:colon
id|nf_unregister_hook
c_func
(paren
op_amp
id|ip_vs_post_routing_ops
)paren
suffix:semicolon
id|cleanup_outops
suffix:colon
id|nf_unregister_hook
c_func
(paren
op_amp
id|ip_vs_out_ops
)paren
suffix:semicolon
id|cleanup_inops
suffix:colon
id|nf_unregister_hook
c_func
(paren
op_amp
id|ip_vs_in_ops
)paren
suffix:semicolon
id|cleanup_conn
suffix:colon
id|ip_vs_conn_cleanup
c_func
(paren
)paren
suffix:semicolon
id|cleanup_app
suffix:colon
id|ip_vs_app_cleanup
c_func
(paren
)paren
suffix:semicolon
id|cleanup_protocol
suffix:colon
id|ip_vs_protocol_cleanup
c_func
(paren
)paren
suffix:semicolon
id|ip_vs_control_cleanup
c_func
(paren
)paren
suffix:semicolon
id|cleanup_nothing
suffix:colon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|ip_vs_cleanup
r_static
r_void
id|__exit
id|ip_vs_cleanup
c_func
(paren
r_void
)paren
(brace
id|nf_unregister_hook
c_func
(paren
op_amp
id|ip_vs_forward_icmp_ops
)paren
suffix:semicolon
id|nf_unregister_hook
c_func
(paren
op_amp
id|ip_vs_post_routing_ops
)paren
suffix:semicolon
id|nf_unregister_hook
c_func
(paren
op_amp
id|ip_vs_out_ops
)paren
suffix:semicolon
id|nf_unregister_hook
c_func
(paren
op_amp
id|ip_vs_in_ops
)paren
suffix:semicolon
id|ip_vs_conn_cleanup
c_func
(paren
)paren
suffix:semicolon
id|ip_vs_app_cleanup
c_func
(paren
)paren
suffix:semicolon
id|ip_vs_protocol_cleanup
c_func
(paren
)paren
suffix:semicolon
id|ip_vs_control_cleanup
c_func
(paren
)paren
suffix:semicolon
id|IP_VS_INFO
c_func
(paren
l_string|&quot;ipvs unloaded.&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|variable|ip_vs_init
id|module_init
c_func
(paren
id|ip_vs_init
)paren
suffix:semicolon
DECL|variable|ip_vs_cleanup
id|module_exit
c_func
(paren
id|ip_vs_cleanup
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
eof
