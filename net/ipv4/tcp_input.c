multiline_comment|/*&n; * INET&t;&t;An implementation of the TCP/IP protocol suite for the LINUX&n; *&t;&t;operating system.  INET is implemented using the  BSD Socket&n; *&t;&t;interface as the means of communication with the user level.&n; *&n; *&t;&t;Implementation of the Transmission Control Protocol(TCP).&n; *&n; * Version:&t;$Id: tcp_input.c,v 1.243 2002/02/01 22:01:04 davem Exp $&n; *&n; * Authors:&t;Ross Biro, &lt;bir7@leland.Stanford.Edu&gt;&n; *&t;&t;Fred N. van Kempen, &lt;waltje@uWalt.NL.Mugnet.ORG&gt;&n; *&t;&t;Mark Evans, &lt;evansmp@uhura.aston.ac.uk&gt;&n; *&t;&t;Corey Minyard &lt;wf-rch!minyard@relay.EU.net&gt;&n; *&t;&t;Florian La Roche, &lt;flla@stud.uni-sb.de&gt;&n; *&t;&t;Charles Hedrick, &lt;hedrick@klinzhai.rutgers.edu&gt;&n; *&t;&t;Linus Torvalds, &lt;torvalds@cs.helsinki.fi&gt;&n; *&t;&t;Alan Cox, &lt;gw4pts@gw4pts.ampr.org&gt;&n; *&t;&t;Matthew Dillon, &lt;dillon@apollo.west.oic.com&gt;&n; *&t;&t;Arnt Gulbrandsen, &lt;agulbra@nvg.unit.no&gt;&n; *&t;&t;Jorge Cwik, &lt;jorge@laser.satlink.net&gt;&n; */
multiline_comment|/*&n; * Changes:&n; *&t;&t;Pedro Roque&t;:&t;Fast Retransmit/Recovery.&n; *&t;&t;&t;&t;&t;Two receive queues.&n; *&t;&t;&t;&t;&t;Retransmit queue handled by TCP.&n; *&t;&t;&t;&t;&t;Better retransmit timer handling.&n; *&t;&t;&t;&t;&t;New congestion avoidance.&n; *&t;&t;&t;&t;&t;Header prediction.&n; *&t;&t;&t;&t;&t;Variable renaming.&n; *&n; *&t;&t;Eric&t;&t;:&t;Fast Retransmit.&n; *&t;&t;Randy Scott&t;:&t;MSS option defines.&n; *&t;&t;Eric Schenk&t;:&t;Fixes to slow start algorithm.&n; *&t;&t;Eric Schenk&t;:&t;Yet another double ACK bug.&n; *&t;&t;Eric Schenk&t;:&t;Delayed ACK bug fixes.&n; *&t;&t;Eric Schenk&t;:&t;Floyd style fast retrans war avoidance.&n; *&t;&t;David S. Miller&t;:&t;Don&squot;t allow zero congestion window.&n; *&t;&t;Eric Schenk&t;:&t;Fix retransmitter so that it sends&n; *&t;&t;&t;&t;&t;next packet on ack of previous packet.&n; *&t;&t;Andi Kleen&t;:&t;Moved open_request checking here&n; *&t;&t;&t;&t;&t;and process RSTs for open_requests.&n; *&t;&t;Andi Kleen&t;:&t;Better prune_queue, and other fixes.&n; *&t;&t;Andrey Savochkin:&t;Fix RTT measurements in the presnce of&n; *&t;&t;&t;&t;&t;timestamps.&n; *&t;&t;Andrey Savochkin:&t;Check sequence numbers correctly when&n; *&t;&t;&t;&t;&t;removing SACKs due to in sequence incoming&n; *&t;&t;&t;&t;&t;data segments.&n; *&t;&t;Andi Kleen:&t;&t;Make sure we never ack data there is not&n; *&t;&t;&t;&t;&t;enough room for. Also make this condition&n; *&t;&t;&t;&t;&t;a fatal error if it might still happen.&n; *&t;&t;Andi Kleen:&t;&t;Add tcp_measure_rcv_mss to make &n; *&t;&t;&t;&t;&t;connections with MSS&lt;min(MTU,ann. MSS)&n; *&t;&t;&t;&t;&t;work without delayed acks. &n; *&t;&t;Andi Kleen:&t;&t;Process packets with PSH set in the&n; *&t;&t;&t;&t;&t;fast path.&n; *&t;&t;J Hadi Salim:&t;&t;ECN support&n; *&t; &t;Andrei Gurtov,&n; *&t;&t;Pasi Sarolahti,&n; *&t;&t;Panu Kuhlberg:&t;&t;Experimental audit of TCP (re)transmission&n; *&t;&t;&t;&t;&t;engine. Lots of bugs are found.&n; *&t;&t;Pasi Sarolahti:&t;&t;F-RTO for dealing with spurious RTOs&n; *&t;&t;Angelo Dell&squot;Aera:&t;TCP Westwood+ support&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/sysctl.h&gt;
macro_line|#include &lt;net/tcp.h&gt;
macro_line|#include &lt;net/inet_common.h&gt;
macro_line|#include &lt;linux/ipsec.h&gt;
DECL|variable|sysctl_tcp_timestamps
r_int
id|sysctl_tcp_timestamps
op_assign
l_int|1
suffix:semicolon
DECL|variable|sysctl_tcp_window_scaling
r_int
id|sysctl_tcp_window_scaling
op_assign
l_int|1
suffix:semicolon
DECL|variable|sysctl_tcp_sack
r_int
id|sysctl_tcp_sack
op_assign
l_int|1
suffix:semicolon
DECL|variable|sysctl_tcp_fack
r_int
id|sysctl_tcp_fack
op_assign
l_int|1
suffix:semicolon
DECL|variable|sysctl_tcp_reordering
r_int
id|sysctl_tcp_reordering
op_assign
id|TCP_FASTRETRANS_THRESH
suffix:semicolon
DECL|variable|sysctl_tcp_ecn
r_int
id|sysctl_tcp_ecn
suffix:semicolon
DECL|variable|sysctl_tcp_dsack
r_int
id|sysctl_tcp_dsack
op_assign
l_int|1
suffix:semicolon
DECL|variable|sysctl_tcp_app_win
r_int
id|sysctl_tcp_app_win
op_assign
l_int|31
suffix:semicolon
DECL|variable|sysctl_tcp_adv_win_scale
r_int
id|sysctl_tcp_adv_win_scale
op_assign
l_int|2
suffix:semicolon
DECL|variable|sysctl_tcp_stdurg
r_int
id|sysctl_tcp_stdurg
suffix:semicolon
DECL|variable|sysctl_tcp_rfc1337
r_int
id|sysctl_tcp_rfc1337
suffix:semicolon
DECL|variable|sysctl_tcp_max_orphans
r_int
id|sysctl_tcp_max_orphans
op_assign
id|NR_FILE
suffix:semicolon
DECL|variable|sysctl_tcp_frto
r_int
id|sysctl_tcp_frto
suffix:semicolon
DECL|variable|sysctl_tcp_nometrics_save
r_int
id|sysctl_tcp_nometrics_save
suffix:semicolon
DECL|variable|sysctl_tcp_westwood
r_int
id|sysctl_tcp_westwood
suffix:semicolon
DECL|variable|sysctl_tcp_vegas_cong_avoid
r_int
id|sysctl_tcp_vegas_cong_avoid
suffix:semicolon
DECL|variable|sysctl_tcp_moderate_rcvbuf
r_int
id|sysctl_tcp_moderate_rcvbuf
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Default values of the Vegas variables, in fixed-point representation&n; * with V_PARAM_SHIFT bits to the right of the binary point.&n; */
DECL|macro|V_PARAM_SHIFT
mdefine_line|#define V_PARAM_SHIFT 1
DECL|variable|sysctl_tcp_vegas_alpha
r_int
id|sysctl_tcp_vegas_alpha
op_assign
l_int|1
op_lshift
id|V_PARAM_SHIFT
suffix:semicolon
DECL|variable|sysctl_tcp_vegas_beta
r_int
id|sysctl_tcp_vegas_beta
op_assign
l_int|3
op_lshift
id|V_PARAM_SHIFT
suffix:semicolon
DECL|variable|sysctl_tcp_vegas_gamma
r_int
id|sysctl_tcp_vegas_gamma
op_assign
l_int|1
op_lshift
id|V_PARAM_SHIFT
suffix:semicolon
DECL|variable|sysctl_tcp_bic
r_int
id|sysctl_tcp_bic
op_assign
l_int|1
suffix:semicolon
DECL|variable|sysctl_tcp_bic_fast_convergence
r_int
id|sysctl_tcp_bic_fast_convergence
op_assign
l_int|1
suffix:semicolon
DECL|variable|sysctl_tcp_bic_low_window
r_int
id|sysctl_tcp_bic_low_window
op_assign
l_int|14
suffix:semicolon
DECL|macro|FLAG_DATA
mdefine_line|#define FLAG_DATA&t;&t;0x01 /* Incoming frame contained data.&t;&t;*/
DECL|macro|FLAG_WIN_UPDATE
mdefine_line|#define FLAG_WIN_UPDATE&t;&t;0x02 /* Incoming ACK was a window update.&t;*/
DECL|macro|FLAG_DATA_ACKED
mdefine_line|#define FLAG_DATA_ACKED&t;&t;0x04 /* This ACK acknowledged new data.&t;&t;*/
DECL|macro|FLAG_RETRANS_DATA_ACKED
mdefine_line|#define FLAG_RETRANS_DATA_ACKED&t;0x08 /* &quot;&quot; &quot;&quot; some of which was retransmitted.&t;*/
DECL|macro|FLAG_SYN_ACKED
mdefine_line|#define FLAG_SYN_ACKED&t;&t;0x10 /* This ACK acknowledged SYN.&t;&t;*/
DECL|macro|FLAG_DATA_SACKED
mdefine_line|#define FLAG_DATA_SACKED&t;0x20 /* New SACK.&t;&t;&t;&t;*/
DECL|macro|FLAG_ECE
mdefine_line|#define FLAG_ECE&t;&t;0x40 /* ECE in this ACK&t;&t;&t;&t;*/
DECL|macro|FLAG_DATA_LOST
mdefine_line|#define FLAG_DATA_LOST&t;&t;0x80 /* SACK detected data lossage.&t;&t;*/
DECL|macro|FLAG_SLOWPATH
mdefine_line|#define FLAG_SLOWPATH&t;&t;0x100 /* Do not skip RFC checks for window update.*/
DECL|macro|FLAG_ACKED
mdefine_line|#define FLAG_ACKED&t;&t;(FLAG_DATA_ACKED|FLAG_SYN_ACKED)
DECL|macro|FLAG_NOT_DUP
mdefine_line|#define FLAG_NOT_DUP&t;&t;(FLAG_DATA|FLAG_WIN_UPDATE|FLAG_ACKED)
DECL|macro|FLAG_CA_ALERT
mdefine_line|#define FLAG_CA_ALERT&t;&t;(FLAG_DATA_SACKED|FLAG_ECE)
DECL|macro|FLAG_FORWARD_PROGRESS
mdefine_line|#define FLAG_FORWARD_PROGRESS&t;(FLAG_ACKED|FLAG_DATA_SACKED)
DECL|macro|IsReno
mdefine_line|#define IsReno(tp) ((tp)-&gt;sack_ok == 0)
DECL|macro|IsFack
mdefine_line|#define IsFack(tp) ((tp)-&gt;sack_ok &amp; 2)
DECL|macro|IsDSack
mdefine_line|#define IsDSack(tp) ((tp)-&gt;sack_ok &amp; 4)
DECL|macro|TCP_REMNANT
mdefine_line|#define TCP_REMNANT (TCP_FLAG_FIN|TCP_FLAG_URG|TCP_FLAG_SYN|TCP_FLAG_PSH)
multiline_comment|/* Adapt the MSS value used to make delayed ack decision to the &n; * real world.&n; */
DECL|function|tcp_measure_rcv_mss
r_static
r_inline
r_void
id|tcp_measure_rcv_mss
c_func
(paren
r_struct
id|tcp_sock
op_star
id|tp
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_int
r_int
id|len
comma
id|lss
suffix:semicolon
id|lss
op_assign
id|tp-&gt;ack.last_seg_size
suffix:semicolon
id|tp-&gt;ack.last_seg_size
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* skb-&gt;len may jitter because of SACKs, even if peer&n;&t; * sends good full-sized frames.&n;&t; */
id|len
op_assign
id|skb-&gt;len
suffix:semicolon
r_if
c_cond
(paren
id|len
op_ge
id|tp-&gt;ack.rcv_mss
)paren
(brace
id|tp-&gt;ack.rcv_mss
op_assign
id|len
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Otherwise, we make more careful check taking into account,&n;&t;&t; * that SACKs block is variable.&n;&t;&t; *&n;&t;&t; * &quot;len&quot; is invariant segment length, including TCP header.&n;&t;&t; */
id|len
op_add_assign
id|skb-&gt;data
op_minus
id|skb-&gt;h.raw
suffix:semicolon
r_if
c_cond
(paren
id|len
op_ge
id|TCP_MIN_RCVMSS
op_plus
r_sizeof
(paren
r_struct
id|tcphdr
)paren
op_logical_or
multiline_comment|/* If PSH is not set, packet should be&n;&t;&t;     * full sized, provided peer TCP is not badly broken.&n;&t;&t;     * This observation (if it is correct 8)) allows&n;&t;&t;     * to handle super-low mtu links fairly.&n;&t;&t;     */
(paren
id|len
op_ge
id|TCP_MIN_MSS
op_plus
r_sizeof
(paren
r_struct
id|tcphdr
)paren
op_logical_and
op_logical_neg
(paren
id|tcp_flag_word
c_func
(paren
id|skb-&gt;h.th
)paren
op_amp
id|TCP_REMNANT
)paren
)paren
)paren
(brace
multiline_comment|/* Subtract also invariant (if peer is RFC compliant),&n;&t;&t;&t; * tcp header plus fixed timestamp option length.&n;&t;&t;&t; * Resulting &quot;len&quot; is MSS free of SACK jitter.&n;&t;&t;&t; */
id|len
op_sub_assign
id|tp-&gt;tcp_header_len
suffix:semicolon
id|tp-&gt;ack.last_seg_size
op_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
id|len
op_eq
id|lss
)paren
(brace
id|tp-&gt;ack.rcv_mss
op_assign
id|len
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
id|tp-&gt;ack.pending
op_or_assign
id|TCP_ACK_PUSHED
suffix:semicolon
)brace
)brace
DECL|function|tcp_incr_quickack
r_static
r_void
id|tcp_incr_quickack
c_func
(paren
r_struct
id|tcp_sock
op_star
id|tp
)paren
(brace
r_int
id|quickacks
op_assign
id|tp-&gt;rcv_wnd
op_div
(paren
l_int|2
op_star
id|tp-&gt;ack.rcv_mss
)paren
suffix:semicolon
r_if
c_cond
(paren
id|quickacks
op_eq
l_int|0
)paren
id|quickacks
op_assign
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|quickacks
OG
id|tp-&gt;ack.quick
)paren
id|tp-&gt;ack.quick
op_assign
id|min
c_func
(paren
id|quickacks
comma
id|TCP_MAX_QUICKACKS
)paren
suffix:semicolon
)brace
DECL|function|tcp_enter_quickack_mode
r_void
id|tcp_enter_quickack_mode
c_func
(paren
r_struct
id|tcp_sock
op_star
id|tp
)paren
(brace
id|tcp_incr_quickack
c_func
(paren
id|tp
)paren
suffix:semicolon
id|tp-&gt;ack.pingpong
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;ack.ato
op_assign
id|TCP_ATO_MIN
suffix:semicolon
)brace
multiline_comment|/* Send ACKs quickly, if &quot;quick&quot; count is not exhausted&n; * and the session is not interactive.&n; */
DECL|function|tcp_in_quickack_mode
r_static
id|__inline__
r_int
id|tcp_in_quickack_mode
c_func
(paren
r_struct
id|tcp_sock
op_star
id|tp
)paren
(brace
r_return
(paren
id|tp-&gt;ack.quick
op_logical_and
op_logical_neg
id|tp-&gt;ack.pingpong
)paren
suffix:semicolon
)brace
multiline_comment|/* Buffer size and advertised window tuning.&n; *&n; * 1. Tuning sk-&gt;sk_sndbuf, when connection enters established state.&n; */
DECL|function|tcp_fixup_sndbuf
r_static
r_void
id|tcp_fixup_sndbuf
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_int
id|sndmem
op_assign
id|tcp_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|mss_clamp
op_plus
id|MAX_TCP_HEADER
op_plus
l_int|16
op_plus
r_sizeof
(paren
r_struct
id|sk_buff
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;sk_sndbuf
OL
l_int|3
op_star
id|sndmem
)paren
id|sk-&gt;sk_sndbuf
op_assign
id|min
c_func
(paren
l_int|3
op_star
id|sndmem
comma
id|sysctl_tcp_wmem
(braket
l_int|2
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/* 2. Tuning advertised window (window_clamp, rcv_ssthresh)&n; *&n; * All tcp_full_space() is split to two parts: &quot;network&quot; buffer, allocated&n; * forward and advertised in receiver window (tp-&gt;rcv_wnd) and&n; * &quot;application buffer&quot;, required to isolate scheduling/application&n; * latencies from network.&n; * window_clamp is maximal advertised window. It can be less than&n; * tcp_full_space(), in this case tcp_full_space() - window_clamp&n; * is reserved for &quot;application&quot; buffer. The less window_clamp is&n; * the smoother our behaviour from viewpoint of network, but the lower&n; * throughput and the higher sensitivity of the connection to losses. 8)&n; *&n; * rcv_ssthresh is more strict window_clamp used at &quot;slow start&quot;&n; * phase to predict further behaviour of this connection.&n; * It is used for two goals:&n; * - to enforce header prediction at sender, even when application&n; *   requires some significant &quot;application buffer&quot;. It is check #1.&n; * - to prevent pruning of receive queue because of misprediction&n; *   of receiver window. Check #2.&n; *&n; * The scheme does not work when sender sends good segments opening&n; * window and then starts to feed us spagetti. But it should work&n; * in common situations. Otherwise, we have to rely on queue collapsing.&n; */
multiline_comment|/* Slow part of check#2. */
DECL|function|__tcp_grow_window
r_static
r_int
id|__tcp_grow_window
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|tcp_sock
op_star
id|tp
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
multiline_comment|/* Optimize this! */
r_int
id|truesize
op_assign
id|tcp_win_from_space
c_func
(paren
id|skb-&gt;truesize
)paren
op_div
l_int|2
suffix:semicolon
r_int
id|window
op_assign
id|tcp_full_space
c_func
(paren
id|sk
)paren
op_div
l_int|2
suffix:semicolon
r_while
c_loop
(paren
id|tp-&gt;rcv_ssthresh
op_le
id|window
)paren
(brace
r_if
c_cond
(paren
id|truesize
op_le
id|skb-&gt;len
)paren
r_return
l_int|2
op_star
id|tp-&gt;ack.rcv_mss
suffix:semicolon
id|truesize
op_rshift_assign
l_int|1
suffix:semicolon
id|window
op_rshift_assign
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|tcp_grow_window
r_static
r_inline
r_void
id|tcp_grow_window
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|tcp_sock
op_star
id|tp
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
multiline_comment|/* Check #1 */
r_if
c_cond
(paren
id|tp-&gt;rcv_ssthresh
OL
id|tp-&gt;window_clamp
op_logical_and
(paren
r_int
)paren
id|tp-&gt;rcv_ssthresh
OL
id|tcp_space
c_func
(paren
id|sk
)paren
op_logical_and
op_logical_neg
id|tcp_memory_pressure
)paren
(brace
r_int
id|incr
suffix:semicolon
multiline_comment|/* Check #2. Increase window, if skb with such overhead&n;&t;&t; * will fit to rcvbuf in future.&n;&t;&t; */
r_if
c_cond
(paren
id|tcp_win_from_space
c_func
(paren
id|skb-&gt;truesize
)paren
op_le
id|skb-&gt;len
)paren
id|incr
op_assign
l_int|2
op_star
id|tp-&gt;advmss
suffix:semicolon
r_else
id|incr
op_assign
id|__tcp_grow_window
c_func
(paren
id|sk
comma
id|tp
comma
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|incr
)paren
(brace
id|tp-&gt;rcv_ssthresh
op_assign
id|min
c_func
(paren
id|tp-&gt;rcv_ssthresh
op_plus
id|incr
comma
id|tp-&gt;window_clamp
)paren
suffix:semicolon
id|tp-&gt;ack.quick
op_or_assign
l_int|1
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* 3. Tuning rcvbuf, when connection enters established state. */
DECL|function|tcp_fixup_rcvbuf
r_static
r_void
id|tcp_fixup_rcvbuf
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|tcp_sock
op_star
id|tp
op_assign
id|tcp_sk
c_func
(paren
id|sk
)paren
suffix:semicolon
r_int
id|rcvmem
op_assign
id|tp-&gt;advmss
op_plus
id|MAX_TCP_HEADER
op_plus
l_int|16
op_plus
r_sizeof
(paren
r_struct
id|sk_buff
)paren
suffix:semicolon
multiline_comment|/* Try to select rcvbuf so that 4 mss-sized segments&n;&t; * will fit to window and correspoding skbs will fit to our rcvbuf.&n;&t; * (was 3; 4 is minimum to allow fast retransmit to work.)&n;&t; */
r_while
c_loop
(paren
id|tcp_win_from_space
c_func
(paren
id|rcvmem
)paren
OL
id|tp-&gt;advmss
)paren
id|rcvmem
op_add_assign
l_int|128
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;sk_rcvbuf
OL
l_int|4
op_star
id|rcvmem
)paren
id|sk-&gt;sk_rcvbuf
op_assign
id|min
c_func
(paren
l_int|4
op_star
id|rcvmem
comma
id|sysctl_tcp_rmem
(braket
l_int|2
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/* 4. Try to fixup all. It is made iimediately after connection enters&n; *    established state.&n; */
DECL|function|tcp_init_buffer_space
r_static
r_void
id|tcp_init_buffer_space
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|tcp_sock
op_star
id|tp
op_assign
id|tcp_sk
c_func
(paren
id|sk
)paren
suffix:semicolon
r_int
id|maxwin
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|sk-&gt;sk_userlocks
op_amp
id|SOCK_RCVBUF_LOCK
)paren
)paren
id|tcp_fixup_rcvbuf
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|sk-&gt;sk_userlocks
op_amp
id|SOCK_SNDBUF_LOCK
)paren
)paren
id|tcp_fixup_sndbuf
c_func
(paren
id|sk
)paren
suffix:semicolon
id|tp-&gt;rcvq_space.space
op_assign
id|tp-&gt;rcv_wnd
suffix:semicolon
id|maxwin
op_assign
id|tcp_full_space
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;window_clamp
op_ge
id|maxwin
)paren
(brace
id|tp-&gt;window_clamp
op_assign
id|maxwin
suffix:semicolon
r_if
c_cond
(paren
id|sysctl_tcp_app_win
op_logical_and
id|maxwin
OG
l_int|4
op_star
id|tp-&gt;advmss
)paren
id|tp-&gt;window_clamp
op_assign
id|max
c_func
(paren
id|maxwin
op_minus
(paren
id|maxwin
op_rshift
id|sysctl_tcp_app_win
)paren
comma
l_int|4
op_star
id|tp-&gt;advmss
)paren
suffix:semicolon
)brace
multiline_comment|/* Force reservation of one segment. */
r_if
c_cond
(paren
id|sysctl_tcp_app_win
op_logical_and
id|tp-&gt;window_clamp
OG
l_int|2
op_star
id|tp-&gt;advmss
op_logical_and
id|tp-&gt;window_clamp
op_plus
id|tp-&gt;advmss
OG
id|maxwin
)paren
id|tp-&gt;window_clamp
op_assign
id|max
c_func
(paren
l_int|2
op_star
id|tp-&gt;advmss
comma
id|maxwin
op_minus
id|tp-&gt;advmss
)paren
suffix:semicolon
id|tp-&gt;rcv_ssthresh
op_assign
id|min
c_func
(paren
id|tp-&gt;rcv_ssthresh
comma
id|tp-&gt;window_clamp
)paren
suffix:semicolon
id|tp-&gt;snd_cwnd_stamp
op_assign
id|tcp_time_stamp
suffix:semicolon
)brace
DECL|function|init_bictcp
r_static
r_void
id|init_bictcp
c_func
(paren
r_struct
id|tcp_sock
op_star
id|tp
)paren
(brace
id|tp-&gt;bictcp.cnt
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;bictcp.last_max_cwnd
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;bictcp.last_cwnd
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;bictcp.last_stamp
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* 5. Recalculate window clamp after socket hit its memory bounds. */
DECL|function|tcp_clamp_window
r_static
r_void
id|tcp_clamp_window
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|tcp_sock
op_star
id|tp
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_int
r_int
id|app_win
op_assign
id|tp-&gt;rcv_nxt
op_minus
id|tp-&gt;copied_seq
suffix:semicolon
r_int
id|ofo_win
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;ack.quick
op_assign
l_int|0
suffix:semicolon
id|skb_queue_walk
c_func
(paren
op_amp
id|tp-&gt;out_of_order_queue
comma
id|skb
)paren
(brace
id|ofo_win
op_add_assign
id|skb-&gt;len
suffix:semicolon
)brace
multiline_comment|/* If overcommit is due to out of order segments,&n;&t; * do not clamp window. Try to expand rcvbuf instead.&n;&t; */
r_if
c_cond
(paren
id|ofo_win
)paren
(brace
r_if
c_cond
(paren
id|sk-&gt;sk_rcvbuf
OL
id|sysctl_tcp_rmem
(braket
l_int|2
)braket
op_logical_and
op_logical_neg
(paren
id|sk-&gt;sk_userlocks
op_amp
id|SOCK_RCVBUF_LOCK
)paren
op_logical_and
op_logical_neg
id|tcp_memory_pressure
op_logical_and
id|atomic_read
c_func
(paren
op_amp
id|tcp_memory_allocated
)paren
OL
id|sysctl_tcp_mem
(braket
l_int|0
)braket
)paren
id|sk-&gt;sk_rcvbuf
op_assign
id|min
c_func
(paren
id|atomic_read
c_func
(paren
op_amp
id|sk-&gt;sk_rmem_alloc
)paren
comma
id|sysctl_tcp_rmem
(braket
l_int|2
)braket
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|sk-&gt;sk_rmem_alloc
)paren
OG
id|sk-&gt;sk_rcvbuf
)paren
(brace
id|app_win
op_add_assign
id|ofo_win
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|sk-&gt;sk_rmem_alloc
)paren
op_ge
l_int|2
op_star
id|sk-&gt;sk_rcvbuf
)paren
id|app_win
op_rshift_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|app_win
OG
id|tp-&gt;ack.rcv_mss
)paren
id|app_win
op_sub_assign
id|tp-&gt;ack.rcv_mss
suffix:semicolon
id|app_win
op_assign
id|max
c_func
(paren
id|app_win
comma
l_int|2U
op_star
id|tp-&gt;advmss
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ofo_win
)paren
id|tp-&gt;window_clamp
op_assign
id|min
c_func
(paren
id|tp-&gt;window_clamp
comma
id|app_win
)paren
suffix:semicolon
id|tp-&gt;rcv_ssthresh
op_assign
id|min
c_func
(paren
id|tp-&gt;window_clamp
comma
l_int|2U
op_star
id|tp-&gt;advmss
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Receiver &quot;autotuning&quot; code.&n; *&n; * The algorithm for RTT estimation w/o timestamps is based on&n; * Dynamic Right-Sizing (DRS) by Wu Feng and Mike Fisk of LANL.&n; * &lt;http://www.lanl.gov/radiant/website/pubs/drs/lacsi2001.ps&gt;&n; *&n; * More detail on this code can be found at&n; * &lt;http://www.psc.edu/~jheffner/senior_thesis.ps&gt;,&n; * though this reference is out of date.  A new paper&n; * is pending.&n; */
DECL|function|tcp_rcv_rtt_update
r_static
r_void
id|tcp_rcv_rtt_update
c_func
(paren
r_struct
id|tcp_sock
op_star
id|tp
comma
id|u32
id|sample
comma
r_int
id|win_dep
)paren
(brace
id|u32
id|new_sample
op_assign
id|tp-&gt;rcv_rtt_est.rtt
suffix:semicolon
r_int
id|m
op_assign
id|sample
suffix:semicolon
r_if
c_cond
(paren
id|m
op_eq
l_int|0
)paren
id|m
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|new_sample
op_ne
l_int|0
)paren
(brace
multiline_comment|/* If we sample in larger samples in the non-timestamp&n;&t;&t; * case, we could grossly overestimate the RTT especially&n;&t;&t; * with chatty applications or bulk transfer apps which&n;&t;&t; * are stalled on filesystem I/O.&n;&t;&t; *&n;&t;&t; * Also, since we are only going for a minimum in the&n;&t;&t; * non-timestamp case, we do not smoothe things out&n;&t;&t; * else with timestamps disabled convergance takes too&n;&t;&t; * long.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|win_dep
)paren
(brace
id|m
op_sub_assign
(paren
id|new_sample
op_rshift
l_int|3
)paren
suffix:semicolon
id|new_sample
op_add_assign
id|m
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|m
OL
id|new_sample
)paren
id|new_sample
op_assign
id|m
op_lshift
l_int|3
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* No previous mesaure. */
id|new_sample
op_assign
id|m
op_lshift
l_int|3
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tp-&gt;rcv_rtt_est.rtt
op_ne
id|new_sample
)paren
id|tp-&gt;rcv_rtt_est.rtt
op_assign
id|new_sample
suffix:semicolon
)brace
DECL|function|tcp_rcv_rtt_measure
r_static
r_inline
r_void
id|tcp_rcv_rtt_measure
c_func
(paren
r_struct
id|tcp_sock
op_star
id|tp
)paren
(brace
r_if
c_cond
(paren
id|tp-&gt;rcv_rtt_est.time
op_eq
l_int|0
)paren
r_goto
id|new_measure
suffix:semicolon
r_if
c_cond
(paren
id|before
c_func
(paren
id|tp-&gt;rcv_nxt
comma
id|tp-&gt;rcv_rtt_est.seq
)paren
)paren
r_return
suffix:semicolon
id|tcp_rcv_rtt_update
c_func
(paren
id|tp
comma
id|jiffies
op_minus
id|tp-&gt;rcv_rtt_est.time
comma
l_int|1
)paren
suffix:semicolon
id|new_measure
suffix:colon
id|tp-&gt;rcv_rtt_est.seq
op_assign
id|tp-&gt;rcv_nxt
op_plus
id|tp-&gt;rcv_wnd
suffix:semicolon
id|tp-&gt;rcv_rtt_est.time
op_assign
id|tcp_time_stamp
suffix:semicolon
)brace
DECL|function|tcp_rcv_rtt_measure_ts
r_static
r_inline
r_void
id|tcp_rcv_rtt_measure_ts
c_func
(paren
r_struct
id|tcp_sock
op_star
id|tp
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_if
c_cond
(paren
id|tp-&gt;rcv_tsecr
op_logical_and
(paren
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
op_minus
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
op_ge
id|tp-&gt;ack.rcv_mss
)paren
)paren
id|tcp_rcv_rtt_update
c_func
(paren
id|tp
comma
id|tcp_time_stamp
op_minus
id|tp-&gt;rcv_tsecr
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This function should be called every time data is copied to user space.&n; * It calculates the appropriate TCP receive buffer space.&n; */
DECL|function|tcp_rcv_space_adjust
r_void
id|tcp_rcv_space_adjust
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|tcp_sock
op_star
id|tp
op_assign
id|tcp_sk
c_func
(paren
id|sk
)paren
suffix:semicolon
r_int
id|time
suffix:semicolon
r_int
id|space
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;rcvq_space.time
op_eq
l_int|0
)paren
r_goto
id|new_measure
suffix:semicolon
id|time
op_assign
id|tcp_time_stamp
op_minus
id|tp-&gt;rcvq_space.time
suffix:semicolon
r_if
c_cond
(paren
id|time
OL
(paren
id|tp-&gt;rcv_rtt_est.rtt
op_rshift
l_int|3
)paren
op_logical_or
id|tp-&gt;rcv_rtt_est.rtt
op_eq
l_int|0
)paren
r_return
suffix:semicolon
id|space
op_assign
l_int|2
op_star
(paren
id|tp-&gt;copied_seq
op_minus
id|tp-&gt;rcvq_space.seq
)paren
suffix:semicolon
id|space
op_assign
id|max
c_func
(paren
id|tp-&gt;rcvq_space.space
comma
id|space
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;rcvq_space.space
op_ne
id|space
)paren
(brace
r_int
id|rcvmem
suffix:semicolon
id|tp-&gt;rcvq_space.space
op_assign
id|space
suffix:semicolon
r_if
c_cond
(paren
id|sysctl_tcp_moderate_rcvbuf
)paren
(brace
r_int
id|new_clamp
op_assign
id|space
suffix:semicolon
multiline_comment|/* Receive space grows, normalize in order to&n;&t;&t;&t; * take into account packet headers and sk_buff&n;&t;&t;&t; * structure overhead.&n;&t;&t;&t; */
id|space
op_div_assign
id|tp-&gt;advmss
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|space
)paren
id|space
op_assign
l_int|1
suffix:semicolon
id|rcvmem
op_assign
(paren
id|tp-&gt;advmss
op_plus
id|MAX_TCP_HEADER
op_plus
l_int|16
op_plus
r_sizeof
(paren
r_struct
id|sk_buff
)paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|tcp_win_from_space
c_func
(paren
id|rcvmem
)paren
OL
id|tp-&gt;advmss
)paren
id|rcvmem
op_add_assign
l_int|128
suffix:semicolon
id|space
op_mul_assign
id|rcvmem
suffix:semicolon
id|space
op_assign
id|min
c_func
(paren
id|space
comma
id|sysctl_tcp_rmem
(braket
l_int|2
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|space
OG
id|sk-&gt;sk_rcvbuf
)paren
(brace
id|sk-&gt;sk_rcvbuf
op_assign
id|space
suffix:semicolon
multiline_comment|/* Make the window clamp follow along.  */
id|tp-&gt;window_clamp
op_assign
id|new_clamp
suffix:semicolon
)brace
)brace
)brace
id|new_measure
suffix:colon
id|tp-&gt;rcvq_space.seq
op_assign
id|tp-&gt;copied_seq
suffix:semicolon
id|tp-&gt;rcvq_space.time
op_assign
id|tcp_time_stamp
suffix:semicolon
)brace
multiline_comment|/* There is something which you must keep in mind when you analyze the&n; * behavior of the tp-&gt;ato delayed ack timeout interval.  When a&n; * connection starts up, we want to ack as quickly as possible.  The&n; * problem is that &quot;good&quot; TCP&squot;s do slow start at the beginning of data&n; * transmission.  The means that until we send the first few ACK&squot;s the&n; * sender will sit on his end and only queue most of his data, because&n; * he can only send snd_cwnd unacked packets at any given time.  For&n; * each ACK we send, he increments snd_cwnd and transmits more of his&n; * queue.  -DaveM&n; */
DECL|function|tcp_event_data_recv
r_static
r_void
id|tcp_event_data_recv
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|tcp_sock
op_star
id|tp
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
id|u32
id|now
suffix:semicolon
id|tcp_schedule_ack
c_func
(paren
id|tp
)paren
suffix:semicolon
id|tcp_measure_rcv_mss
c_func
(paren
id|tp
comma
id|skb
)paren
suffix:semicolon
id|tcp_rcv_rtt_measure
c_func
(paren
id|tp
)paren
suffix:semicolon
id|now
op_assign
id|tcp_time_stamp
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tp-&gt;ack.ato
)paren
(brace
multiline_comment|/* The _first_ data packet received, initialize&n;&t;&t; * delayed ACK engine.&n;&t;&t; */
id|tcp_incr_quickack
c_func
(paren
id|tp
)paren
suffix:semicolon
id|tp-&gt;ack.ato
op_assign
id|TCP_ATO_MIN
suffix:semicolon
)brace
r_else
(brace
r_int
id|m
op_assign
id|now
op_minus
id|tp-&gt;ack.lrcvtime
suffix:semicolon
r_if
c_cond
(paren
id|m
op_le
id|TCP_ATO_MIN
op_div
l_int|2
)paren
(brace
multiline_comment|/* The fastest case is the first. */
id|tp-&gt;ack.ato
op_assign
(paren
id|tp-&gt;ack.ato
op_rshift
l_int|1
)paren
op_plus
id|TCP_ATO_MIN
op_div
l_int|2
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|m
OL
id|tp-&gt;ack.ato
)paren
(brace
id|tp-&gt;ack.ato
op_assign
(paren
id|tp-&gt;ack.ato
op_rshift
l_int|1
)paren
op_plus
id|m
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;ack.ato
OG
id|tp-&gt;rto
)paren
id|tp-&gt;ack.ato
op_assign
id|tp-&gt;rto
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|m
OG
id|tp-&gt;rto
)paren
(brace
multiline_comment|/* Too long gap. Apparently sender falled to&n;&t;&t;&t; * restart window, so that we send ACKs quickly.&n;&t;&t;&t; */
id|tcp_incr_quickack
c_func
(paren
id|tp
)paren
suffix:semicolon
id|sk_stream_mem_reclaim
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
)brace
id|tp-&gt;ack.lrcvtime
op_assign
id|now
suffix:semicolon
id|TCP_ECN_check_ce
c_func
(paren
id|tp
comma
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb-&gt;len
op_ge
l_int|128
)paren
id|tcp_grow_window
c_func
(paren
id|sk
comma
id|tp
comma
id|skb
)paren
suffix:semicolon
)brace
multiline_comment|/* When starting a new connection, pin down the current choice of &n; * congestion algorithm.&n; */
DECL|function|tcp_ca_init
r_void
id|tcp_ca_init
c_func
(paren
r_struct
id|tcp_sock
op_star
id|tp
)paren
(brace
r_if
c_cond
(paren
id|sysctl_tcp_westwood
)paren
id|tp-&gt;adv_cong
op_assign
id|TCP_WESTWOOD
suffix:semicolon
r_else
r_if
c_cond
(paren
id|sysctl_tcp_bic
)paren
id|tp-&gt;adv_cong
op_assign
id|TCP_BIC
suffix:semicolon
r_else
r_if
c_cond
(paren
id|sysctl_tcp_vegas_cong_avoid
)paren
(brace
id|tp-&gt;adv_cong
op_assign
id|TCP_VEGAS
suffix:semicolon
id|tp-&gt;vegas.baseRTT
op_assign
l_int|0x7fffffff
suffix:semicolon
id|tcp_vegas_enable
c_func
(paren
id|tp
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Do RTT sampling needed for Vegas.&n; * Basically we:&n; *   o min-filter RTT samples from within an RTT to get the current&n; *     propagation delay + queuing delay (we are min-filtering to try to&n; *     avoid the effects of delayed ACKs)&n; *   o min-filter RTT samples from a much longer window (forever for now)&n; *     to find the propagation delay (baseRTT)&n; */
DECL|function|vegas_rtt_calc
r_static
r_inline
r_void
id|vegas_rtt_calc
c_func
(paren
r_struct
id|tcp_sock
op_star
id|tp
comma
id|__u32
id|rtt
)paren
(brace
id|__u32
id|vrtt
op_assign
id|rtt
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* Never allow zero rtt or baseRTT */
multiline_comment|/* Filter to find propagation delay: */
r_if
c_cond
(paren
id|vrtt
OL
id|tp-&gt;vegas.baseRTT
)paren
id|tp-&gt;vegas.baseRTT
op_assign
id|vrtt
suffix:semicolon
multiline_comment|/* Find the min RTT during the last RTT to find&n;&t; * the current prop. delay + queuing delay:&n;&t; */
id|tp-&gt;vegas.minRTT
op_assign
id|min
c_func
(paren
id|tp-&gt;vegas.minRTT
comma
id|vrtt
)paren
suffix:semicolon
id|tp-&gt;vegas.cntRTT
op_increment
suffix:semicolon
)brace
multiline_comment|/* Called to compute a smoothed rtt estimate. The data fed to this&n; * routine either comes from timestamps, or from segments that were&n; * known _not_ to have been retransmitted [see Karn/Partridge&n; * Proceedings SIGCOMM 87]. The algorithm is from the SIGCOMM 88&n; * piece by Van Jacobson.&n; * NOTE: the next three routines used to be one big routine.&n; * To save cycles in the RFC 1323 implementation it was better to break&n; * it up into three procedures. -- erics&n; */
DECL|function|tcp_rtt_estimator
r_static
r_void
id|tcp_rtt_estimator
c_func
(paren
r_struct
id|tcp_sock
op_star
id|tp
comma
id|__u32
id|mrtt
)paren
(brace
r_int
id|m
op_assign
id|mrtt
suffix:semicolon
multiline_comment|/* RTT */
r_if
c_cond
(paren
id|tcp_vegas_enabled
c_func
(paren
id|tp
)paren
)paren
id|vegas_rtt_calc
c_func
(paren
id|tp
comma
id|mrtt
)paren
suffix:semicolon
multiline_comment|/*&t;The following amusing code comes from Jacobson&squot;s&n;&t; *&t;article in SIGCOMM &squot;88.  Note that rtt and mdev&n;&t; *&t;are scaled versions of rtt and mean deviation.&n;&t; *&t;This is designed to be as fast as possible &n;&t; *&t;m stands for &quot;measurement&quot;.&n;&t; *&n;&t; *&t;On a 1990 paper the rto value is changed to:&n;&t; *&t;RTO = rtt + 4 * mdev&n;&t; *&n;&t; * Funny. This algorithm seems to be very broken.&n;&t; * These formulae increase RTO, when it should be decreased, increase&n;&t; * too slowly, when it should be incresed fastly, decrease too fastly&n;&t; * etc. I guess in BSD RTO takes ONE value, so that it is absolutely&n;&t; * does not matter how to _calculate_ it. Seems, it was trap&n;&t; * that VJ failed to avoid. 8)&n;&t; */
r_if
c_cond
(paren
id|m
op_eq
l_int|0
)paren
(brace
id|m
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tp-&gt;srtt
op_ne
l_int|0
)paren
(brace
id|m
op_sub_assign
(paren
id|tp-&gt;srtt
op_rshift
l_int|3
)paren
suffix:semicolon
multiline_comment|/* m is now error in rtt est */
id|tp-&gt;srtt
op_add_assign
id|m
suffix:semicolon
multiline_comment|/* rtt = 7/8 rtt + 1/8 new */
r_if
c_cond
(paren
id|m
OL
l_int|0
)paren
(brace
id|m
op_assign
op_minus
id|m
suffix:semicolon
multiline_comment|/* m is now abs(error) */
id|m
op_sub_assign
(paren
id|tp-&gt;mdev
op_rshift
l_int|2
)paren
suffix:semicolon
multiline_comment|/* similar update on mdev */
multiline_comment|/* This is similar to one of Eifel findings.&n;&t;&t;&t; * Eifel blocks mdev updates when rtt decreases.&n;&t;&t;&t; * This solution is a bit different: we use finer gain&n;&t;&t;&t; * for mdev in this case (alpha*beta).&n;&t;&t;&t; * Like Eifel it also prevents growth of rto,&n;&t;&t;&t; * but also it limits too fast rto decreases,&n;&t;&t;&t; * happening in pure Eifel.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|m
OG
l_int|0
)paren
id|m
op_rshift_assign
l_int|3
suffix:semicolon
)brace
r_else
(brace
id|m
op_sub_assign
(paren
id|tp-&gt;mdev
op_rshift
l_int|2
)paren
suffix:semicolon
multiline_comment|/* similar update on mdev */
)brace
id|tp-&gt;mdev
op_add_assign
id|m
suffix:semicolon
multiline_comment|/* mdev = 3/4 mdev + 1/4 new */
r_if
c_cond
(paren
id|tp-&gt;mdev
OG
id|tp-&gt;mdev_max
)paren
(brace
id|tp-&gt;mdev_max
op_assign
id|tp-&gt;mdev
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;mdev_max
OG
id|tp-&gt;rttvar
)paren
id|tp-&gt;rttvar
op_assign
id|tp-&gt;mdev_max
suffix:semicolon
)brace
r_if
c_cond
(paren
id|after
c_func
(paren
id|tp-&gt;snd_una
comma
id|tp-&gt;rtt_seq
)paren
)paren
(brace
r_if
c_cond
(paren
id|tp-&gt;mdev_max
OL
id|tp-&gt;rttvar
)paren
id|tp-&gt;rttvar
op_sub_assign
(paren
id|tp-&gt;rttvar
op_minus
id|tp-&gt;mdev_max
)paren
op_rshift
l_int|2
suffix:semicolon
id|tp-&gt;rtt_seq
op_assign
id|tp-&gt;snd_nxt
suffix:semicolon
id|tp-&gt;mdev_max
op_assign
id|TCP_RTO_MIN
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* no previous measure. */
id|tp-&gt;srtt
op_assign
id|m
op_lshift
l_int|3
suffix:semicolon
multiline_comment|/* take the measured time to be rtt */
id|tp-&gt;mdev
op_assign
id|m
op_lshift
l_int|1
suffix:semicolon
multiline_comment|/* make sure rto = 3*rtt */
id|tp-&gt;mdev_max
op_assign
id|tp-&gt;rttvar
op_assign
id|max
c_func
(paren
id|tp-&gt;mdev
comma
id|TCP_RTO_MIN
)paren
suffix:semicolon
id|tp-&gt;rtt_seq
op_assign
id|tp-&gt;snd_nxt
suffix:semicolon
)brace
id|tcp_westwood_update_rtt
c_func
(paren
id|tp
comma
id|tp-&gt;srtt
op_rshift
l_int|3
)paren
suffix:semicolon
)brace
multiline_comment|/* Calculate rto without backoff.  This is the second half of Van Jacobson&squot;s&n; * routine referred to above.&n; */
DECL|function|tcp_set_rto
r_static
r_inline
r_void
id|tcp_set_rto
c_func
(paren
r_struct
id|tcp_sock
op_star
id|tp
)paren
(brace
multiline_comment|/* Old crap is replaced with new one. 8)&n;&t; *&n;&t; * More seriously:&n;&t; * 1. If rtt variance happened to be less 50msec, it is hallucination.&n;&t; *    It cannot be less due to utterly erratic ACK generation made&n;&t; *    at least by solaris and freebsd. &quot;Erratic ACKs&quot; has _nothing_&n;&t; *    to do with delayed acks, because at cwnd&gt;2 true delack timeout&n;&t; *    is invisible. Actually, Linux-2.4 also generates erratic&n;&t; *    ACKs in some curcumstances.&n;&t; */
id|tp-&gt;rto
op_assign
(paren
id|tp-&gt;srtt
op_rshift
l_int|3
)paren
op_plus
id|tp-&gt;rttvar
suffix:semicolon
multiline_comment|/* 2. Fixups made earlier cannot be right.&n;&t; *    If we do not estimate RTO correctly without them,&n;&t; *    all the algo is pure shit and should be replaced&n;&t; *    with correct one. It is exaclty, which we pretend to do.&n;&t; */
)brace
multiline_comment|/* NOTE: clamping at TCP_RTO_MIN is not required, current algo&n; * guarantees that rto is higher.&n; */
DECL|function|tcp_bound_rto
r_static
r_inline
r_void
id|tcp_bound_rto
c_func
(paren
r_struct
id|tcp_sock
op_star
id|tp
)paren
(brace
r_if
c_cond
(paren
id|tp-&gt;rto
OG
id|TCP_RTO_MAX
)paren
id|tp-&gt;rto
op_assign
id|TCP_RTO_MAX
suffix:semicolon
)brace
multiline_comment|/* Save metrics learned by this TCP session.&n;   This function is called only, when TCP finishes successfully&n;   i.e. when it enters TIME-WAIT or goes from LAST-ACK to CLOSE.&n; */
DECL|function|tcp_update_metrics
r_void
id|tcp_update_metrics
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|tcp_sock
op_star
id|tp
op_assign
id|tcp_sk
c_func
(paren
id|sk
)paren
suffix:semicolon
r_struct
id|dst_entry
op_star
id|dst
op_assign
id|__sk_dst_get
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sysctl_tcp_nometrics_save
)paren
r_return
suffix:semicolon
id|dst_confirm
c_func
(paren
id|dst
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dst
op_logical_and
(paren
id|dst-&gt;flags
op_amp
id|DST_HOST
)paren
)paren
(brace
r_int
id|m
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;backoff
op_logical_or
op_logical_neg
id|tp-&gt;srtt
)paren
(brace
multiline_comment|/* This session failed to estimate rtt. Why?&n;&t;&t;&t; * Probably, no packets returned in time.&n;&t;&t;&t; * Reset our results.&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|dst_metric_locked
c_func
(paren
id|dst
comma
id|RTAX_RTT
)paren
)paren
)paren
id|dst-&gt;metrics
(braket
id|RTAX_RTT
op_minus
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
r_return
suffix:semicolon
)brace
id|m
op_assign
id|dst_metric
c_func
(paren
id|dst
comma
id|RTAX_RTT
)paren
op_minus
id|tp-&gt;srtt
suffix:semicolon
multiline_comment|/* If newly calculated rtt larger than stored one,&n;&t;&t; * store new one. Otherwise, use EWMA. Remember,&n;&t;&t; * rtt overestimation is always better than underestimation.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|dst_metric_locked
c_func
(paren
id|dst
comma
id|RTAX_RTT
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|m
op_le
l_int|0
)paren
id|dst-&gt;metrics
(braket
id|RTAX_RTT
op_minus
l_int|1
)braket
op_assign
id|tp-&gt;srtt
suffix:semicolon
r_else
id|dst-&gt;metrics
(braket
id|RTAX_RTT
op_minus
l_int|1
)braket
op_sub_assign
(paren
id|m
op_rshift
l_int|3
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|dst_metric_locked
c_func
(paren
id|dst
comma
id|RTAX_RTTVAR
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|m
OL
l_int|0
)paren
id|m
op_assign
op_minus
id|m
suffix:semicolon
multiline_comment|/* Scale deviation to rttvar fixed point */
id|m
op_rshift_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|m
OL
id|tp-&gt;mdev
)paren
id|m
op_assign
id|tp-&gt;mdev
suffix:semicolon
r_if
c_cond
(paren
id|m
op_ge
id|dst_metric
c_func
(paren
id|dst
comma
id|RTAX_RTTVAR
)paren
)paren
id|dst-&gt;metrics
(braket
id|RTAX_RTTVAR
op_minus
l_int|1
)braket
op_assign
id|m
suffix:semicolon
r_else
id|dst-&gt;metrics
(braket
id|RTAX_RTTVAR
op_minus
l_int|1
)braket
op_sub_assign
(paren
id|dst-&gt;metrics
(braket
id|RTAX_RTTVAR
op_minus
l_int|1
)braket
op_minus
id|m
)paren
op_rshift
l_int|2
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tp-&gt;snd_ssthresh
op_ge
l_int|0xFFFF
)paren
(brace
multiline_comment|/* Slow start still did not finish. */
r_if
c_cond
(paren
id|dst_metric
c_func
(paren
id|dst
comma
id|RTAX_SSTHRESH
)paren
op_logical_and
op_logical_neg
id|dst_metric_locked
c_func
(paren
id|dst
comma
id|RTAX_SSTHRESH
)paren
op_logical_and
(paren
id|tp-&gt;snd_cwnd
op_rshift
l_int|1
)paren
OG
id|dst_metric
c_func
(paren
id|dst
comma
id|RTAX_SSTHRESH
)paren
)paren
id|dst-&gt;metrics
(braket
id|RTAX_SSTHRESH
op_minus
l_int|1
)braket
op_assign
id|tp-&gt;snd_cwnd
op_rshift
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dst_metric_locked
c_func
(paren
id|dst
comma
id|RTAX_CWND
)paren
op_logical_and
id|tp-&gt;snd_cwnd
OG
id|dst_metric
c_func
(paren
id|dst
comma
id|RTAX_CWND
)paren
)paren
id|dst-&gt;metrics
(braket
id|RTAX_CWND
op_minus
l_int|1
)braket
op_assign
id|tp-&gt;snd_cwnd
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|tp-&gt;snd_cwnd
OG
id|tp-&gt;snd_ssthresh
op_logical_and
id|tp-&gt;ca_state
op_eq
id|TCP_CA_Open
)paren
(brace
multiline_comment|/* Cong. avoidance phase, cwnd is reliable. */
r_if
c_cond
(paren
op_logical_neg
id|dst_metric_locked
c_func
(paren
id|dst
comma
id|RTAX_SSTHRESH
)paren
)paren
id|dst-&gt;metrics
(braket
id|RTAX_SSTHRESH
op_minus
l_int|1
)braket
op_assign
id|max
c_func
(paren
id|tp-&gt;snd_cwnd
op_rshift
l_int|1
comma
id|tp-&gt;snd_ssthresh
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dst_metric_locked
c_func
(paren
id|dst
comma
id|RTAX_CWND
)paren
)paren
id|dst-&gt;metrics
(braket
id|RTAX_CWND
op_minus
l_int|1
)braket
op_assign
(paren
id|dst-&gt;metrics
(braket
id|RTAX_CWND
op_minus
l_int|1
)braket
op_plus
id|tp-&gt;snd_cwnd
)paren
op_rshift
l_int|1
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Else slow start did not finish, cwnd is non-sense,&n;&t;&t;&t;   ssthresh may be also invalid.&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|dst_metric_locked
c_func
(paren
id|dst
comma
id|RTAX_CWND
)paren
)paren
id|dst-&gt;metrics
(braket
id|RTAX_CWND
op_minus
l_int|1
)braket
op_assign
(paren
id|dst-&gt;metrics
(braket
id|RTAX_CWND
op_minus
l_int|1
)braket
op_plus
id|tp-&gt;snd_ssthresh
)paren
op_rshift
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|dst-&gt;metrics
(braket
id|RTAX_SSTHRESH
op_minus
l_int|1
)braket
op_logical_and
op_logical_neg
id|dst_metric_locked
c_func
(paren
id|dst
comma
id|RTAX_SSTHRESH
)paren
op_logical_and
id|tp-&gt;snd_ssthresh
OG
id|dst-&gt;metrics
(braket
id|RTAX_SSTHRESH
op_minus
l_int|1
)braket
)paren
id|dst-&gt;metrics
(braket
id|RTAX_SSTHRESH
op_minus
l_int|1
)braket
op_assign
id|tp-&gt;snd_ssthresh
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|dst_metric_locked
c_func
(paren
id|dst
comma
id|RTAX_REORDERING
)paren
)paren
(brace
r_if
c_cond
(paren
id|dst-&gt;metrics
(braket
id|RTAX_REORDERING
op_minus
l_int|1
)braket
OL
id|tp-&gt;reordering
op_logical_and
id|tp-&gt;reordering
op_ne
id|sysctl_tcp_reordering
)paren
id|dst-&gt;metrics
(braket
id|RTAX_REORDERING
op_minus
l_int|1
)braket
op_assign
id|tp-&gt;reordering
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Numbers are taken from RFC2414.  */
DECL|function|tcp_init_cwnd
id|__u32
id|tcp_init_cwnd
c_func
(paren
r_struct
id|tcp_sock
op_star
id|tp
comma
r_struct
id|dst_entry
op_star
id|dst
)paren
(brace
id|__u32
id|cwnd
op_assign
(paren
id|dst
ques
c_cond
id|dst_metric
c_func
(paren
id|dst
comma
id|RTAX_INITCWND
)paren
suffix:colon
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cwnd
)paren
(brace
r_if
c_cond
(paren
id|tp-&gt;mss_cache_std
OG
l_int|1460
)paren
id|cwnd
op_assign
l_int|2
suffix:semicolon
r_else
id|cwnd
op_assign
(paren
id|tp-&gt;mss_cache_std
OG
l_int|1095
)paren
ques
c_cond
l_int|3
suffix:colon
l_int|4
suffix:semicolon
)brace
r_return
id|min_t
c_func
(paren
id|__u32
comma
id|cwnd
comma
id|tp-&gt;snd_cwnd_clamp
)paren
suffix:semicolon
)brace
multiline_comment|/* Initialize metrics on socket. */
DECL|function|tcp_init_metrics
r_static
r_void
id|tcp_init_metrics
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|tcp_sock
op_star
id|tp
op_assign
id|tcp_sk
c_func
(paren
id|sk
)paren
suffix:semicolon
r_struct
id|dst_entry
op_star
id|dst
op_assign
id|__sk_dst_get
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dst
op_eq
l_int|NULL
)paren
r_goto
id|reset
suffix:semicolon
id|dst_confirm
c_func
(paren
id|dst
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dst_metric_locked
c_func
(paren
id|dst
comma
id|RTAX_CWND
)paren
)paren
id|tp-&gt;snd_cwnd_clamp
op_assign
id|dst_metric
c_func
(paren
id|dst
comma
id|RTAX_CWND
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dst_metric
c_func
(paren
id|dst
comma
id|RTAX_SSTHRESH
)paren
)paren
(brace
id|tp-&gt;snd_ssthresh
op_assign
id|dst_metric
c_func
(paren
id|dst
comma
id|RTAX_SSTHRESH
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;snd_ssthresh
OG
id|tp-&gt;snd_cwnd_clamp
)paren
id|tp-&gt;snd_ssthresh
op_assign
id|tp-&gt;snd_cwnd_clamp
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dst_metric
c_func
(paren
id|dst
comma
id|RTAX_REORDERING
)paren
op_logical_and
id|tp-&gt;reordering
op_ne
id|dst_metric
c_func
(paren
id|dst
comma
id|RTAX_REORDERING
)paren
)paren
(brace
id|tp-&gt;sack_ok
op_and_assign
op_complement
l_int|2
suffix:semicolon
id|tp-&gt;reordering
op_assign
id|dst_metric
c_func
(paren
id|dst
comma
id|RTAX_REORDERING
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dst_metric
c_func
(paren
id|dst
comma
id|RTAX_RTT
)paren
op_eq
l_int|0
)paren
r_goto
id|reset
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tp-&gt;srtt
op_logical_and
id|dst_metric
c_func
(paren
id|dst
comma
id|RTAX_RTT
)paren
OL
(paren
id|TCP_TIMEOUT_INIT
op_lshift
l_int|3
)paren
)paren
r_goto
id|reset
suffix:semicolon
multiline_comment|/* Initial rtt is determined from SYN,SYN-ACK.&n;&t; * The segment is small and rtt may appear much&n;&t; * less than real one. Use per-dst memory&n;&t; * to make it more realistic.&n;&t; *&n;&t; * A bit of theory. RTT is time passed after &quot;normal&quot; sized packet&n;&t; * is sent until it is ACKed. In normal curcumstances sending small&n;&t; * packets force peer to delay ACKs and calculation is correct too.&n;&t; * The algorithm is adaptive and, provided we follow specs, it&n;&t; * NEVER underestimate RTT. BUT! If peer tries to make some clever&n;&t; * tricks sort of &quot;quick acks&quot; for time long enough to decrease RTT&n;&t; * to low value, and then abruptly stops to do it and starts to delay&n;&t; * ACKs, wait for troubles.&n;&t; */
r_if
c_cond
(paren
id|dst_metric
c_func
(paren
id|dst
comma
id|RTAX_RTT
)paren
OG
id|tp-&gt;srtt
)paren
(brace
id|tp-&gt;srtt
op_assign
id|dst_metric
c_func
(paren
id|dst
comma
id|RTAX_RTT
)paren
suffix:semicolon
id|tp-&gt;rtt_seq
op_assign
id|tp-&gt;snd_nxt
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dst_metric
c_func
(paren
id|dst
comma
id|RTAX_RTTVAR
)paren
OG
id|tp-&gt;mdev
)paren
(brace
id|tp-&gt;mdev
op_assign
id|dst_metric
c_func
(paren
id|dst
comma
id|RTAX_RTTVAR
)paren
suffix:semicolon
id|tp-&gt;mdev_max
op_assign
id|tp-&gt;rttvar
op_assign
id|max
c_func
(paren
id|tp-&gt;mdev
comma
id|TCP_RTO_MIN
)paren
suffix:semicolon
)brace
id|tcp_set_rto
c_func
(paren
id|tp
)paren
suffix:semicolon
id|tcp_bound_rto
c_func
(paren
id|tp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;rto
OL
id|TCP_TIMEOUT_INIT
op_logical_and
op_logical_neg
id|tp-&gt;saw_tstamp
)paren
r_goto
id|reset
suffix:semicolon
id|tp-&gt;snd_cwnd
op_assign
id|tcp_init_cwnd
c_func
(paren
id|tp
comma
id|dst
)paren
suffix:semicolon
id|tp-&gt;snd_cwnd_stamp
op_assign
id|tcp_time_stamp
suffix:semicolon
r_return
suffix:semicolon
id|reset
suffix:colon
multiline_comment|/* Play conservative. If timestamps are not&n;&t; * supported, TCP will fail to recalculate correct&n;&t; * rtt, if initial rto is too small. FORGET ALL AND RESET!&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|tp-&gt;saw_tstamp
op_logical_and
id|tp-&gt;srtt
)paren
(brace
id|tp-&gt;srtt
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;mdev
op_assign
id|tp-&gt;mdev_max
op_assign
id|tp-&gt;rttvar
op_assign
id|TCP_TIMEOUT_INIT
suffix:semicolon
id|tp-&gt;rto
op_assign
id|TCP_TIMEOUT_INIT
suffix:semicolon
)brace
)brace
DECL|function|tcp_update_reordering
r_static
r_void
id|tcp_update_reordering
c_func
(paren
r_struct
id|tcp_sock
op_star
id|tp
comma
r_int
id|metric
comma
r_int
id|ts
)paren
(brace
r_if
c_cond
(paren
id|metric
OG
id|tp-&gt;reordering
)paren
(brace
id|tp-&gt;reordering
op_assign
id|min
c_func
(paren
id|TCP_MAX_REORDERING
comma
id|metric
)paren
suffix:semicolon
multiline_comment|/* This exciting event is worth to be remembered. 8) */
r_if
c_cond
(paren
id|ts
)paren
id|NET_INC_STATS_BH
c_func
(paren
id|LINUX_MIB_TCPTSREORDER
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|IsReno
c_func
(paren
id|tp
)paren
)paren
id|NET_INC_STATS_BH
c_func
(paren
id|LINUX_MIB_TCPRENOREORDER
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|IsFack
c_func
(paren
id|tp
)paren
)paren
id|NET_INC_STATS_BH
c_func
(paren
id|LINUX_MIB_TCPFACKREORDER
)paren
suffix:semicolon
r_else
id|NET_INC_STATS_BH
c_func
(paren
id|LINUX_MIB_TCPSACKREORDER
)paren
suffix:semicolon
macro_line|#if FASTRETRANS_DEBUG &gt; 1
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Disorder%d %d %u f%u s%u rr%d&bslash;n&quot;
comma
id|tp-&gt;sack_ok
comma
id|tp-&gt;ca_state
comma
id|tp-&gt;reordering
comma
id|tp-&gt;fackets_out
comma
id|tp-&gt;sacked_out
comma
id|tp-&gt;undo_marker
ques
c_cond
id|tp-&gt;undo_retrans
suffix:colon
l_int|0
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Disable FACK yet. */
id|tp-&gt;sack_ok
op_and_assign
op_complement
l_int|2
suffix:semicolon
)brace
)brace
multiline_comment|/* This procedure tags the retransmission queue when SACKs arrive.&n; *&n; * We have three tag bits: SACKED(S), RETRANS(R) and LOST(L).&n; * Packets in queue with these bits set are counted in variables&n; * sacked_out, retrans_out and lost_out, correspondingly.&n; *&n; * Valid combinations are:&n; * Tag  InFlight&t;Description&n; * 0&t;1&t;&t;- orig segment is in flight.&n; * S&t;0&t;&t;- nothing flies, orig reached receiver.&n; * L&t;0&t;&t;- nothing flies, orig lost by net.&n; * R&t;2&t;&t;- both orig and retransmit are in flight.&n; * L|R&t;1&t;&t;- orig is lost, retransmit is in flight.&n; * S|R  1&t;&t;- orig reached receiver, retrans is still in flight.&n; * (L|S|R is logically valid, it could occur when L|R is sacked,&n; *  but it is equivalent to plain S and code short-curcuits it to S.&n; *  L|S is logically invalid, it would mean -1 packet in flight 8))&n; *&n; * These 6 states form finite state machine, controlled by the following events:&n; * 1. New ACK (+SACK) arrives. (tcp_sacktag_write_queue())&n; * 2. Retransmission. (tcp_retransmit_skb(), tcp_xmit_retransmit_queue())&n; * 3. Loss detection event of one of three flavors:&n; *&t;A. Scoreboard estimator decided the packet is lost.&n; *&t;   A&squot;. Reno &quot;three dupacks&quot; marks head of queue lost.&n; *&t;   A&squot;&squot;. Its FACK modfication, head until snd.fack is lost.&n; *&t;B. SACK arrives sacking data transmitted after never retransmitted&n; *&t;   hole was sent out.&n; *&t;C. SACK arrives sacking SND.NXT at the moment, when the&n; *&t;   segment was retransmitted.&n; * 4. D-SACK added new rule: D-SACK changes any tag to S.&n; *&n; * It is pleasant to note, that state diagram turns out to be commutative,&n; * so that we are allowed not to be bothered by order of our actions,&n; * when multiple events arrive simultaneously. (see the function below).&n; *&n; * Reordering detection.&n; * --------------------&n; * Reordering metric is maximal distance, which a packet can be displaced&n; * in packet stream. With SACKs we can estimate it:&n; *&n; * 1. SACK fills old hole and the corresponding segment was not&n; *    ever retransmitted -&gt; reordering. Alas, we cannot use it&n; *    when segment was retransmitted.&n; * 2. The last flaw is solved with D-SACK. D-SACK arrives&n; *    for retransmitted and already SACKed segment -&gt; reordering..&n; * Both of these heuristics are not used in Loss state, when we cannot&n; * account for retransmits accurately.&n; */
r_static
r_int
DECL|function|tcp_sacktag_write_queue
id|tcp_sacktag_write_queue
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|ack_skb
comma
id|u32
id|prior_snd_una
)paren
(brace
r_struct
id|tcp_sock
op_star
id|tp
op_assign
id|tcp_sk
c_func
(paren
id|sk
)paren
suffix:semicolon
r_int
r_char
op_star
id|ptr
op_assign
id|ack_skb-&gt;h.raw
op_plus
id|TCP_SKB_CB
c_func
(paren
id|ack_skb
)paren
op_member_access_from_pointer
id|sacked
suffix:semicolon
r_struct
id|tcp_sack_block
op_star
id|sp
op_assign
(paren
r_struct
id|tcp_sack_block
op_star
)paren
(paren
id|ptr
op_plus
l_int|2
)paren
suffix:semicolon
r_int
id|num_sacks
op_assign
(paren
id|ptr
(braket
l_int|1
)braket
op_minus
id|TCPOLEN_SACK_BASE
)paren
op_rshift
l_int|3
suffix:semicolon
r_int
id|reord
op_assign
id|tp-&gt;packets_out
suffix:semicolon
r_int
id|prior_fackets
suffix:semicolon
id|u32
id|lost_retrans
op_assign
l_int|0
suffix:semicolon
r_int
id|flag
op_assign
l_int|0
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/* So, SACKs for already sent large segments will be lost.&n;&t; * Not good, but alternative is to resegment the queue. */
r_if
c_cond
(paren
id|sk-&gt;sk_route_caps
op_amp
id|NETIF_F_TSO
)paren
(brace
id|sk-&gt;sk_route_caps
op_and_assign
op_complement
id|NETIF_F_TSO
suffix:semicolon
id|sk-&gt;sk_no_largesend
op_assign
l_int|1
suffix:semicolon
id|tp-&gt;mss_cache
op_assign
id|tp-&gt;mss_cache_std
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|tp-&gt;sacked_out
)paren
id|tp-&gt;fackets_out
op_assign
l_int|0
suffix:semicolon
id|prior_fackets
op_assign
id|tp-&gt;fackets_out
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num_sacks
suffix:semicolon
id|i
op_increment
comma
id|sp
op_increment
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
id|__u32
id|start_seq
op_assign
id|ntohl
c_func
(paren
id|sp-&gt;start_seq
)paren
suffix:semicolon
id|__u32
id|end_seq
op_assign
id|ntohl
c_func
(paren
id|sp-&gt;end_seq
)paren
suffix:semicolon
r_int
id|fack_count
op_assign
l_int|0
suffix:semicolon
r_int
id|dup_sack
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Check for D-SACK. */
r_if
c_cond
(paren
id|i
op_eq
l_int|0
)paren
(brace
id|u32
id|ack
op_assign
id|TCP_SKB_CB
c_func
(paren
id|ack_skb
)paren
op_member_access_from_pointer
id|ack_seq
suffix:semicolon
r_if
c_cond
(paren
id|before
c_func
(paren
id|start_seq
comma
id|ack
)paren
)paren
(brace
id|dup_sack
op_assign
l_int|1
suffix:semicolon
id|tp-&gt;sack_ok
op_or_assign
l_int|4
suffix:semicolon
id|NET_INC_STATS_BH
c_func
(paren
id|LINUX_MIB_TCPDSACKRECV
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|num_sacks
OG
l_int|1
op_logical_and
op_logical_neg
id|after
c_func
(paren
id|end_seq
comma
id|ntohl
c_func
(paren
id|sp
(braket
l_int|1
)braket
dot
id|end_seq
)paren
)paren
op_logical_and
op_logical_neg
id|before
c_func
(paren
id|start_seq
comma
id|ntohl
c_func
(paren
id|sp
(braket
l_int|1
)braket
dot
id|start_seq
)paren
)paren
)paren
(brace
id|dup_sack
op_assign
l_int|1
suffix:semicolon
id|tp-&gt;sack_ok
op_or_assign
l_int|4
suffix:semicolon
id|NET_INC_STATS_BH
c_func
(paren
id|LINUX_MIB_TCPDSACKOFORECV
)paren
suffix:semicolon
)brace
multiline_comment|/* D-SACK for already forgotten data...&n;&t;&t;&t; * Do dumb counting. */
r_if
c_cond
(paren
id|dup_sack
op_logical_and
op_logical_neg
id|after
c_func
(paren
id|end_seq
comma
id|prior_snd_una
)paren
op_logical_and
id|after
c_func
(paren
id|end_seq
comma
id|tp-&gt;undo_marker
)paren
)paren
id|tp-&gt;undo_retrans
op_decrement
suffix:semicolon
multiline_comment|/* Eliminate too old ACKs, but take into&n;&t;&t;&t; * account more or less fresh ones, they can&n;&t;&t;&t; * contain valid SACK info.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|before
c_func
(paren
id|ack
comma
id|prior_snd_una
op_minus
id|tp-&gt;max_window
)paren
)paren
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Event &quot;B&quot; in the comment above. */
r_if
c_cond
(paren
id|after
c_func
(paren
id|end_seq
comma
id|tp-&gt;high_seq
)paren
)paren
id|flag
op_or_assign
id|FLAG_DATA_LOST
suffix:semicolon
id|sk_stream_for_retrans_queue
c_func
(paren
id|skb
comma
id|sk
)paren
(brace
id|u8
id|sacked
op_assign
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|sacked
suffix:semicolon
r_int
id|in_sack
suffix:semicolon
multiline_comment|/* The retransmission queue is always in order, so&n;&t;&t;&t; * we can short-circuit the walk early.&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|before
c_func
(paren
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
comma
id|end_seq
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
id|fack_count
op_add_assign
id|tcp_skb_pcount
c_func
(paren
id|skb
)paren
suffix:semicolon
id|in_sack
op_assign
op_logical_neg
id|after
c_func
(paren
id|start_seq
comma
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
)paren
op_logical_and
op_logical_neg
id|before
c_func
(paren
id|end_seq
comma
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
)paren
suffix:semicolon
multiline_comment|/* Account D-SACK for retransmitted packet. */
r_if
c_cond
(paren
(paren
id|dup_sack
op_logical_and
id|in_sack
)paren
op_logical_and
(paren
id|sacked
op_amp
id|TCPCB_RETRANS
)paren
op_logical_and
id|after
c_func
(paren
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
comma
id|tp-&gt;undo_marker
)paren
)paren
id|tp-&gt;undo_retrans
op_decrement
suffix:semicolon
multiline_comment|/* The frame is ACKed. */
r_if
c_cond
(paren
op_logical_neg
id|after
c_func
(paren
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
comma
id|tp-&gt;snd_una
)paren
)paren
(brace
r_if
c_cond
(paren
id|sacked
op_amp
id|TCPCB_RETRANS
)paren
(brace
r_if
c_cond
(paren
(paren
id|dup_sack
op_logical_and
id|in_sack
)paren
op_logical_and
(paren
id|sacked
op_amp
id|TCPCB_SACKED_ACKED
)paren
)paren
id|reord
op_assign
id|min
c_func
(paren
id|fack_count
comma
id|reord
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* If it was in a hole, we detected reordering. */
r_if
c_cond
(paren
id|fack_count
OL
id|prior_fackets
op_logical_and
op_logical_neg
(paren
id|sacked
op_amp
id|TCPCB_SACKED_ACKED
)paren
)paren
id|reord
op_assign
id|min
c_func
(paren
id|fack_count
comma
id|reord
)paren
suffix:semicolon
)brace
multiline_comment|/* Nothing to do; acked frame is about to be dropped. */
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|sacked
op_amp
id|TCPCB_SACKED_RETRANS
)paren
op_logical_and
id|after
c_func
(paren
id|end_seq
comma
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|ack_seq
)paren
op_logical_and
(paren
op_logical_neg
id|lost_retrans
op_logical_or
id|after
c_func
(paren
id|end_seq
comma
id|lost_retrans
)paren
)paren
)paren
id|lost_retrans
op_assign
id|end_seq
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|in_sack
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|sacked
op_amp
id|TCPCB_SACKED_ACKED
)paren
)paren
(brace
r_if
c_cond
(paren
id|sacked
op_amp
id|TCPCB_SACKED_RETRANS
)paren
(brace
multiline_comment|/* If the segment is not tagged as lost,&n;&t;&t;&t;&t;&t; * we do not clear RETRANS, believing&n;&t;&t;&t;&t;&t; * that retransmission is still in flight.&n;&t;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|sacked
op_amp
id|TCPCB_LOST
)paren
(brace
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|sacked
op_and_assign
op_complement
(paren
id|TCPCB_LOST
op_or
id|TCPCB_SACKED_RETRANS
)paren
suffix:semicolon
id|tp-&gt;lost_out
op_sub_assign
id|tcp_skb_pcount
c_func
(paren
id|skb
)paren
suffix:semicolon
id|tp-&gt;retrans_out
op_sub_assign
id|tcp_skb_pcount
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* New sack for not retransmitted frame,&n;&t;&t;&t;&t;&t; * which was in hole. It is reordering.&n;&t;&t;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|sacked
op_amp
id|TCPCB_RETRANS
)paren
op_logical_and
id|fack_count
OL
id|prior_fackets
)paren
id|reord
op_assign
id|min
c_func
(paren
id|fack_count
comma
id|reord
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sacked
op_amp
id|TCPCB_LOST
)paren
(brace
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|sacked
op_and_assign
op_complement
id|TCPCB_LOST
suffix:semicolon
id|tp-&gt;lost_out
op_sub_assign
id|tcp_skb_pcount
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
)brace
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|sacked
op_or_assign
id|TCPCB_SACKED_ACKED
suffix:semicolon
id|flag
op_or_assign
id|FLAG_DATA_SACKED
suffix:semicolon
id|tp-&gt;sacked_out
op_add_assign
id|tcp_skb_pcount
c_func
(paren
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fack_count
OG
id|tp-&gt;fackets_out
)paren
id|tp-&gt;fackets_out
op_assign
id|fack_count
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|dup_sack
op_logical_and
(paren
id|sacked
op_amp
id|TCPCB_RETRANS
)paren
)paren
id|reord
op_assign
id|min
c_func
(paren
id|fack_count
comma
id|reord
)paren
suffix:semicolon
)brace
multiline_comment|/* D-SACK. We can detect redundant retransmission&n;&t;&t;&t; * in S|R and plain R frames and clear it.&n;&t;&t;&t; * undo_retrans is decreased above, L|R frames&n;&t;&t;&t; * are accounted above as well.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|dup_sack
op_logical_and
(paren
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|sacked
op_amp
id|TCPCB_SACKED_RETRANS
)paren
)paren
(brace
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|sacked
op_and_assign
op_complement
id|TCPCB_SACKED_RETRANS
suffix:semicolon
id|tp-&gt;retrans_out
op_sub_assign
id|tcp_skb_pcount
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Check for lost retransmit. This superb idea is&n;&t; * borrowed from &quot;ratehalving&quot;. Event &quot;C&quot;.&n;&t; * Later note: FACK people cheated me again 8),&n;&t; * we have to account for reordering! Ugly,&n;&t; * but should help.&n;&t; */
r_if
c_cond
(paren
id|lost_retrans
op_logical_and
id|tp-&gt;ca_state
op_eq
id|TCP_CA_Recovery
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
id|sk_stream_for_retrans_queue
c_func
(paren
id|skb
comma
id|sk
)paren
(brace
r_if
c_cond
(paren
id|after
c_func
(paren
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
comma
id|lost_retrans
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|after
c_func
(paren
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
comma
id|tp-&gt;snd_una
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
(paren
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|sacked
op_amp
id|TCPCB_SACKED_RETRANS
)paren
op_logical_and
id|after
c_func
(paren
id|lost_retrans
comma
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|ack_seq
)paren
op_logical_and
(paren
id|IsFack
c_func
(paren
id|tp
)paren
op_logical_or
op_logical_neg
id|before
c_func
(paren
id|lost_retrans
comma
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|ack_seq
op_plus
id|tp-&gt;reordering
op_star
id|tp-&gt;mss_cache_std
)paren
)paren
)paren
(brace
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|sacked
op_and_assign
op_complement
id|TCPCB_SACKED_RETRANS
suffix:semicolon
id|tp-&gt;retrans_out
op_sub_assign
id|tcp_skb_pcount
c_func
(paren
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|sacked
op_amp
(paren
id|TCPCB_LOST
op_or
id|TCPCB_SACKED_ACKED
)paren
)paren
)paren
(brace
id|tp-&gt;lost_out
op_add_assign
id|tcp_skb_pcount
c_func
(paren
id|skb
)paren
suffix:semicolon
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|sacked
op_or_assign
id|TCPCB_LOST
suffix:semicolon
id|flag
op_or_assign
id|FLAG_DATA_SACKED
suffix:semicolon
id|NET_INC_STATS_BH
c_func
(paren
id|LINUX_MIB_TCPLOSTRETRANSMIT
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
id|tp-&gt;left_out
op_assign
id|tp-&gt;sacked_out
op_plus
id|tp-&gt;lost_out
suffix:semicolon
r_if
c_cond
(paren
(paren
id|reord
OL
id|tp-&gt;fackets_out
)paren
op_logical_and
id|tp-&gt;ca_state
op_ne
id|TCP_CA_Loss
)paren
id|tcp_update_reordering
c_func
(paren
id|tp
comma
(paren
(paren
id|tp-&gt;fackets_out
op_plus
l_int|1
)paren
op_minus
id|reord
)paren
comma
l_int|0
)paren
suffix:semicolon
macro_line|#if FASTRETRANS_DEBUG &gt; 0
id|BUG_TRAP
c_func
(paren
(paren
r_int
)paren
id|tp-&gt;sacked_out
op_ge
l_int|0
)paren
suffix:semicolon
id|BUG_TRAP
c_func
(paren
(paren
r_int
)paren
id|tp-&gt;lost_out
op_ge
l_int|0
)paren
suffix:semicolon
id|BUG_TRAP
c_func
(paren
(paren
r_int
)paren
id|tp-&gt;retrans_out
op_ge
l_int|0
)paren
suffix:semicolon
id|BUG_TRAP
c_func
(paren
(paren
r_int
)paren
id|tcp_packets_in_flight
c_func
(paren
id|tp
)paren
op_ge
l_int|0
)paren
suffix:semicolon
macro_line|#endif
r_return
id|flag
suffix:semicolon
)brace
multiline_comment|/* RTO occurred, but do not yet enter loss state. Instead, transmit two new&n; * segments to see from the next ACKs whether any data was really missing.&n; * If the RTO was spurious, new ACKs should arrive.&n; */
DECL|function|tcp_enter_frto
r_void
id|tcp_enter_frto
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|tcp_sock
op_star
id|tp
op_assign
id|tcp_sk
c_func
(paren
id|sk
)paren
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
id|tp-&gt;frto_counter
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;ca_state
op_le
id|TCP_CA_Disorder
op_logical_or
id|tp-&gt;snd_una
op_eq
id|tp-&gt;high_seq
op_logical_or
(paren
id|tp-&gt;ca_state
op_eq
id|TCP_CA_Loss
op_logical_and
op_logical_neg
id|tp-&gt;retransmits
)paren
)paren
(brace
id|tp-&gt;prior_ssthresh
op_assign
id|tcp_current_ssthresh
c_func
(paren
id|tp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tcp_westwood_ssthresh
c_func
(paren
id|tp
)paren
)paren
id|tp-&gt;snd_ssthresh
op_assign
id|tcp_recalc_ssthresh
c_func
(paren
id|tp
)paren
suffix:semicolon
)brace
multiline_comment|/* Have to clear retransmission markers here to keep the bookkeeping&n;&t; * in shape, even though we are not yet in Loss state.&n;&t; * If something was really lost, it is eventually caught up&n;&t; * in tcp_enter_frto_loss.&n;&t; */
id|tp-&gt;retrans_out
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;undo_marker
op_assign
id|tp-&gt;snd_una
suffix:semicolon
id|tp-&gt;undo_retrans
op_assign
l_int|0
suffix:semicolon
id|sk_stream_for_retrans_queue
c_func
(paren
id|skb
comma
id|sk
)paren
(brace
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|sacked
op_and_assign
op_complement
id|TCPCB_RETRANS
suffix:semicolon
)brace
id|tcp_sync_left_out
c_func
(paren
id|tp
)paren
suffix:semicolon
id|tcp_set_ca_state
c_func
(paren
id|tp
comma
id|TCP_CA_Open
)paren
suffix:semicolon
id|tp-&gt;frto_highmark
op_assign
id|tp-&gt;snd_nxt
suffix:semicolon
)brace
multiline_comment|/* Enter Loss state after F-RTO was applied. Dupack arrived after RTO,&n; * which indicates that we should follow the traditional RTO recovery,&n; * i.e. mark everything lost and do go-back-N retransmission.&n; */
DECL|function|tcp_enter_frto_loss
r_static
r_void
id|tcp_enter_frto_loss
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|tcp_sock
op_star
id|tp
op_assign
id|tcp_sk
c_func
(paren
id|sk
)paren
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_int
id|cnt
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;sacked_out
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;lost_out
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;fackets_out
op_assign
l_int|0
suffix:semicolon
id|sk_stream_for_retrans_queue
c_func
(paren
id|skb
comma
id|sk
)paren
(brace
id|cnt
op_add_assign
id|tcp_skb_pcount
c_func
(paren
id|skb
)paren
suffix:semicolon
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|sacked
op_and_assign
op_complement
id|TCPCB_LOST
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|sacked
op_amp
id|TCPCB_SACKED_ACKED
)paren
)paren
(brace
multiline_comment|/* Do not mark those segments lost that were&n;&t;&t;&t; * forward transmitted after RTO&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|after
c_func
(paren
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
comma
id|tp-&gt;frto_highmark
)paren
)paren
(brace
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|sacked
op_or_assign
id|TCPCB_LOST
suffix:semicolon
id|tp-&gt;lost_out
op_add_assign
id|tcp_skb_pcount
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|tp-&gt;sacked_out
op_add_assign
id|tcp_skb_pcount
c_func
(paren
id|skb
)paren
suffix:semicolon
id|tp-&gt;fackets_out
op_assign
id|cnt
suffix:semicolon
)brace
)brace
id|tcp_sync_left_out
c_func
(paren
id|tp
)paren
suffix:semicolon
id|tp-&gt;snd_cwnd
op_assign
id|tp-&gt;frto_counter
op_plus
id|tcp_packets_in_flight
c_func
(paren
id|tp
)paren
op_plus
l_int|1
suffix:semicolon
id|tp-&gt;snd_cwnd_cnt
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;snd_cwnd_stamp
op_assign
id|tcp_time_stamp
suffix:semicolon
id|tp-&gt;undo_marker
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;frto_counter
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;reordering
op_assign
id|min_t
c_func
(paren
r_int
r_int
comma
id|tp-&gt;reordering
comma
id|sysctl_tcp_reordering
)paren
suffix:semicolon
id|tcp_set_ca_state
c_func
(paren
id|tp
comma
id|TCP_CA_Loss
)paren
suffix:semicolon
id|tp-&gt;high_seq
op_assign
id|tp-&gt;frto_highmark
suffix:semicolon
id|TCP_ECN_queue_cwr
c_func
(paren
id|tp
)paren
suffix:semicolon
id|init_bictcp
c_func
(paren
id|tp
)paren
suffix:semicolon
)brace
DECL|function|tcp_clear_retrans
r_void
id|tcp_clear_retrans
c_func
(paren
r_struct
id|tcp_sock
op_star
id|tp
)paren
(brace
id|tp-&gt;left_out
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;retrans_out
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;fackets_out
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;sacked_out
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;lost_out
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;undo_marker
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;undo_retrans
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Enter Loss state. If &quot;how&quot; is not zero, forget all SACK information&n; * and reset tags completely, otherwise preserve SACKs. If receiver&n; * dropped its ofo queue, we will know this due to reneging detection.&n; */
DECL|function|tcp_enter_loss
r_void
id|tcp_enter_loss
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|how
)paren
(brace
r_struct
id|tcp_sock
op_star
id|tp
op_assign
id|tcp_sk
c_func
(paren
id|sk
)paren
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_int
id|cnt
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Reduce ssthresh if it has not yet been made inside this window. */
r_if
c_cond
(paren
id|tp-&gt;ca_state
op_le
id|TCP_CA_Disorder
op_logical_or
id|tp-&gt;snd_una
op_eq
id|tp-&gt;high_seq
op_logical_or
(paren
id|tp-&gt;ca_state
op_eq
id|TCP_CA_Loss
op_logical_and
op_logical_neg
id|tp-&gt;retransmits
)paren
)paren
(brace
id|tp-&gt;prior_ssthresh
op_assign
id|tcp_current_ssthresh
c_func
(paren
id|tp
)paren
suffix:semicolon
id|tp-&gt;snd_ssthresh
op_assign
id|tcp_recalc_ssthresh
c_func
(paren
id|tp
)paren
suffix:semicolon
)brace
id|tp-&gt;snd_cwnd
op_assign
l_int|1
suffix:semicolon
id|tp-&gt;snd_cwnd_cnt
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;snd_cwnd_stamp
op_assign
id|tcp_time_stamp
suffix:semicolon
id|tcp_clear_retrans
c_func
(paren
id|tp
)paren
suffix:semicolon
multiline_comment|/* Push undo marker, if it was plain RTO and nothing&n;&t; * was retransmitted. */
r_if
c_cond
(paren
op_logical_neg
id|how
)paren
id|tp-&gt;undo_marker
op_assign
id|tp-&gt;snd_una
suffix:semicolon
id|sk_stream_for_retrans_queue
c_func
(paren
id|skb
comma
id|sk
)paren
(brace
id|cnt
op_add_assign
id|tcp_skb_pcount
c_func
(paren
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|sacked
op_amp
id|TCPCB_RETRANS
)paren
id|tp-&gt;undo_marker
op_assign
l_int|0
suffix:semicolon
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|sacked
op_and_assign
(paren
op_complement
id|TCPCB_TAGBITS
)paren
op_or
id|TCPCB_SACKED_ACKED
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|sacked
op_amp
id|TCPCB_SACKED_ACKED
)paren
op_logical_or
id|how
)paren
(brace
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|sacked
op_and_assign
op_complement
id|TCPCB_SACKED_ACKED
suffix:semicolon
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|sacked
op_or_assign
id|TCPCB_LOST
suffix:semicolon
id|tp-&gt;lost_out
op_add_assign
id|tcp_skb_pcount
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
r_else
(brace
id|tp-&gt;sacked_out
op_add_assign
id|tcp_skb_pcount
c_func
(paren
id|skb
)paren
suffix:semicolon
id|tp-&gt;fackets_out
op_assign
id|cnt
suffix:semicolon
)brace
)brace
id|tcp_sync_left_out
c_func
(paren
id|tp
)paren
suffix:semicolon
id|tp-&gt;reordering
op_assign
id|min_t
c_func
(paren
r_int
r_int
comma
id|tp-&gt;reordering
comma
id|sysctl_tcp_reordering
)paren
suffix:semicolon
id|tcp_set_ca_state
c_func
(paren
id|tp
comma
id|TCP_CA_Loss
)paren
suffix:semicolon
id|tp-&gt;high_seq
op_assign
id|tp-&gt;snd_nxt
suffix:semicolon
id|TCP_ECN_queue_cwr
c_func
(paren
id|tp
)paren
suffix:semicolon
)brace
DECL|function|tcp_check_sack_reneging
r_static
r_int
id|tcp_check_sack_reneging
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|tcp_sock
op_star
id|tp
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
multiline_comment|/* If ACK arrived pointing to a remembered SACK,&n;&t; * it means that our remembered SACKs do not reflect&n;&t; * real state of receiver i.e.&n;&t; * receiver _host_ is heavily congested (or buggy).&n;&t; * Do processing similar to RTO timeout.&n;&t; */
r_if
c_cond
(paren
(paren
id|skb
op_assign
id|skb_peek
c_func
(paren
op_amp
id|sk-&gt;sk_write_queue
)paren
)paren
op_ne
l_int|NULL
op_logical_and
(paren
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|sacked
op_amp
id|TCPCB_SACKED_ACKED
)paren
)paren
(brace
id|NET_INC_STATS_BH
c_func
(paren
id|LINUX_MIB_TCPSACKRENEGING
)paren
suffix:semicolon
id|tcp_enter_loss
c_func
(paren
id|sk
comma
l_int|1
)paren
suffix:semicolon
id|tp-&gt;retransmits
op_increment
suffix:semicolon
id|tcp_retransmit_skb
c_func
(paren
id|sk
comma
id|skb_peek
c_func
(paren
op_amp
id|sk-&gt;sk_write_queue
)paren
)paren
suffix:semicolon
id|tcp_reset_xmit_timer
c_func
(paren
id|sk
comma
id|TCP_TIME_RETRANS
comma
id|tp-&gt;rto
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|tcp_fackets_out
r_static
r_inline
r_int
id|tcp_fackets_out
c_func
(paren
r_struct
id|tcp_sock
op_star
id|tp
)paren
(brace
r_return
id|IsReno
c_func
(paren
id|tp
)paren
ques
c_cond
id|tp-&gt;sacked_out
op_plus
l_int|1
suffix:colon
id|tp-&gt;fackets_out
suffix:semicolon
)brace
DECL|function|tcp_skb_timedout
r_static
r_inline
r_int
id|tcp_skb_timedout
c_func
(paren
r_struct
id|tcp_sock
op_star
id|tp
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_return
(paren
id|tcp_time_stamp
op_minus
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|when
OG
id|tp-&gt;rto
)paren
suffix:semicolon
)brace
DECL|function|tcp_head_timedout
r_static
r_inline
r_int
id|tcp_head_timedout
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|tcp_sock
op_star
id|tp
)paren
(brace
r_return
id|tp-&gt;packets_out
op_logical_and
id|tcp_skb_timedout
c_func
(paren
id|tp
comma
id|skb_peek
c_func
(paren
op_amp
id|sk-&gt;sk_write_queue
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Linux NewReno/SACK/FACK/ECN state machine.&n; * --------------------------------------&n; *&n; * &quot;Open&quot;&t;Normal state, no dubious events, fast path.&n; * &quot;Disorder&quot;   In all the respects it is &quot;Open&quot;,&n; *&t;&t;but requires a bit more attention. It is entered when&n; *&t;&t;we see some SACKs or dupacks. It is split of &quot;Open&quot;&n; *&t;&t;mainly to move some processing from fast path to slow one.&n; * &quot;CWR&quot;&t;CWND was reduced due to some Congestion Notification event.&n; *&t;&t;It can be ECN, ICMP source quench, local device congestion.&n; * &quot;Recovery&quot;&t;CWND was reduced, we are fast-retransmitting.&n; * &quot;Loss&quot;&t;CWND was reduced due to RTO timeout or SACK reneging.&n; *&n; * tcp_fastretrans_alert() is entered:&n; * - each incoming ACK, if state is not &quot;Open&quot;&n; * - when arrived ACK is unusual, namely:&n; *&t;* SACK&n; *&t;* Duplicate ACK.&n; *&t;* ECN ECE.&n; *&n; * Counting packets in flight is pretty simple.&n; *&n; *&t;in_flight = packets_out - left_out + retrans_out&n; *&n; *&t;packets_out is SND.NXT-SND.UNA counted in packets.&n; *&n; *&t;retrans_out is number of retransmitted segments.&n; *&n; *&t;left_out is number of segments left network, but not ACKed yet.&n; *&n; *&t;&t;left_out = sacked_out + lost_out&n; *&n; *     sacked_out: Packets, which arrived to receiver out of order&n; *&t;&t;   and hence not ACKed. With SACKs this number is simply&n; *&t;&t;   amount of SACKed data. Even without SACKs&n; *&t;&t;   it is easy to give pretty reliable estimate of this number,&n; *&t;&t;   counting duplicate ACKs.&n; *&n; *       lost_out: Packets lost by network. TCP has no explicit&n; *&t;&t;   &quot;loss notification&quot; feedback from network (for now).&n; *&t;&t;   It means that this number can be only _guessed_.&n; *&t;&t;   Actually, it is the heuristics to predict lossage that&n; *&t;&t;   distinguishes different algorithms.&n; *&n; *&t;F.e. after RTO, when all the queue is considered as lost,&n; *&t;lost_out = packets_out and in_flight = retrans_out.&n; *&n; *&t;&t;Essentially, we have now two algorithms counting&n; *&t;&t;lost packets.&n; *&n; *&t;&t;FACK: It is the simplest heuristics. As soon as we decided&n; *&t;&t;that something is lost, we decide that _all_ not SACKed&n; *&t;&t;packets until the most forward SACK are lost. I.e.&n; *&t;&t;lost_out = fackets_out - sacked_out and left_out = fackets_out.&n; *&t;&t;It is absolutely correct estimate, if network does not reorder&n; *&t;&t;packets. And it loses any connection to reality when reordering&n; *&t;&t;takes place. We use FACK by default until reordering&n; *&t;&t;is suspected on the path to this destination.&n; *&n; *&t;&t;NewReno: when Recovery is entered, we assume that one segment&n; *&t;&t;is lost (classic Reno). While we are in Recovery and&n; *&t;&t;a partial ACK arrives, we assume that one more packet&n; *&t;&t;is lost (NewReno). This heuristics are the same in NewReno&n; *&t;&t;and SACK.&n; *&n; *  Imagine, that&squot;s all! Forget about all this shamanism about CWND inflation&n; *  deflation etc. CWND is real congestion window, never inflated, changes&n; *  only according to classic VJ rules.&n; *&n; * Really tricky (and requiring careful tuning) part of algorithm&n; * is hidden in functions tcp_time_to_recover() and tcp_xmit_retransmit_queue().&n; * The first determines the moment _when_ we should reduce CWND and,&n; * hence, slow down forward transmission. In fact, it determines the moment&n; * when we decide that hole is caused by loss, rather than by a reorder.&n; *&n; * tcp_xmit_retransmit_queue() decides, _what_ we should retransmit to fill&n; * holes, caused by lost packets.&n; *&n; * And the most logically complicated part of algorithm is undo&n; * heuristics. We detect false retransmits due to both too early&n; * fast retransmit (reordering) and underestimated RTO, analyzing&n; * timestamps and D-SACKs. When we detect that some segments were&n; * retransmitted by mistake and CWND reduction was wrong, we undo&n; * window reduction and abort recovery phase. This logic is hidden&n; * inside several functions named tcp_try_undo_&lt;something&gt;.&n; */
multiline_comment|/* This function decides, when we should leave Disordered state&n; * and enter Recovery phase, reducing congestion window.&n; *&n; * Main question: may we further continue forward transmission&n; * with the same cwnd?&n; */
DECL|function|tcp_time_to_recover
r_static
r_int
id|tcp_time_to_recover
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|tcp_sock
op_star
id|tp
)paren
(brace
id|__u32
id|packets_out
suffix:semicolon
multiline_comment|/* Trick#1: The loss is proven. */
r_if
c_cond
(paren
id|tp-&gt;lost_out
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* Not-A-Trick#2 : Classic rule... */
r_if
c_cond
(paren
id|tcp_fackets_out
c_func
(paren
id|tp
)paren
OG
id|tp-&gt;reordering
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* Trick#3 : when we use RFC2988 timer restart, fast&n;&t; * retransmit can be triggered by timeout of queue head.&n;&t; */
r_if
c_cond
(paren
id|tcp_head_timedout
c_func
(paren
id|sk
comma
id|tp
)paren
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* Trick#4: It is still not OK... But will it be useful to delay&n;&t; * recovery more?&n;&t; */
id|packets_out
op_assign
id|tp-&gt;packets_out
suffix:semicolon
r_if
c_cond
(paren
id|packets_out
op_le
id|tp-&gt;reordering
op_logical_and
id|tp-&gt;sacked_out
op_ge
id|max_t
c_func
(paren
id|__u32
comma
id|packets_out
op_div
l_int|2
comma
id|sysctl_tcp_reordering
)paren
op_logical_and
op_logical_neg
id|tcp_may_send_now
c_func
(paren
id|sk
comma
id|tp
)paren
)paren
(brace
multiline_comment|/* We have nothing to send. This connection is limited&n;&t;&t; * either by receiver window or by application.&n;&t;&t; */
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* If we receive more dupacks than we expected counting segments&n; * in assumption of absent reordering, interpret this as reordering.&n; * The only another reason could be bug in receiver TCP.&n; */
DECL|function|tcp_check_reno_reordering
r_static
r_void
id|tcp_check_reno_reordering
c_func
(paren
r_struct
id|tcp_sock
op_star
id|tp
comma
r_int
id|addend
)paren
(brace
id|u32
id|holes
suffix:semicolon
id|holes
op_assign
id|max
c_func
(paren
id|tp-&gt;lost_out
comma
l_int|1U
)paren
suffix:semicolon
id|holes
op_assign
id|min
c_func
(paren
id|holes
comma
id|tp-&gt;packets_out
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tp-&gt;sacked_out
op_plus
id|holes
)paren
OG
id|tp-&gt;packets_out
)paren
(brace
id|tp-&gt;sacked_out
op_assign
id|tp-&gt;packets_out
op_minus
id|holes
suffix:semicolon
id|tcp_update_reordering
c_func
(paren
id|tp
comma
id|tp-&gt;packets_out
op_plus
id|addend
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Emulate SACKs for SACKless connection: account for a new dupack. */
DECL|function|tcp_add_reno_sack
r_static
r_void
id|tcp_add_reno_sack
c_func
(paren
r_struct
id|tcp_sock
op_star
id|tp
)paren
(brace
id|tp-&gt;sacked_out
op_increment
suffix:semicolon
id|tcp_check_reno_reordering
c_func
(paren
id|tp
comma
l_int|0
)paren
suffix:semicolon
id|tcp_sync_left_out
c_func
(paren
id|tp
)paren
suffix:semicolon
)brace
multiline_comment|/* Account for ACK, ACKing some data in Reno Recovery phase. */
DECL|function|tcp_remove_reno_sacks
r_static
r_void
id|tcp_remove_reno_sacks
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|tcp_sock
op_star
id|tp
comma
r_int
id|acked
)paren
(brace
r_if
c_cond
(paren
id|acked
OG
l_int|0
)paren
(brace
multiline_comment|/* One ACK acked hole. The rest eat duplicate ACKs. */
r_if
c_cond
(paren
id|acked
op_minus
l_int|1
op_ge
id|tp-&gt;sacked_out
)paren
id|tp-&gt;sacked_out
op_assign
l_int|0
suffix:semicolon
r_else
id|tp-&gt;sacked_out
op_sub_assign
id|acked
op_minus
l_int|1
suffix:semicolon
)brace
id|tcp_check_reno_reordering
c_func
(paren
id|tp
comma
id|acked
)paren
suffix:semicolon
id|tcp_sync_left_out
c_func
(paren
id|tp
)paren
suffix:semicolon
)brace
DECL|function|tcp_reset_reno_sack
r_static
r_inline
r_void
id|tcp_reset_reno_sack
c_func
(paren
r_struct
id|tcp_sock
op_star
id|tp
)paren
(brace
id|tp-&gt;sacked_out
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;left_out
op_assign
id|tp-&gt;lost_out
suffix:semicolon
)brace
multiline_comment|/* Mark head of queue up as lost. */
DECL|function|tcp_mark_head_lost
r_static
r_void
id|tcp_mark_head_lost
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|tcp_sock
op_star
id|tp
comma
r_int
id|packets
comma
id|u32
id|high_seq
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_int
id|cnt
op_assign
id|packets
suffix:semicolon
id|BUG_TRAP
c_func
(paren
id|cnt
op_le
id|tp-&gt;packets_out
)paren
suffix:semicolon
id|sk_stream_for_retrans_queue
c_func
(paren
id|skb
comma
id|sk
)paren
(brace
id|cnt
op_sub_assign
id|tcp_skb_pcount
c_func
(paren
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cnt
OL
l_int|0
op_logical_or
id|after
c_func
(paren
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
comma
id|high_seq
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|sacked
op_amp
id|TCPCB_TAGBITS
)paren
)paren
(brace
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|sacked
op_or_assign
id|TCPCB_LOST
suffix:semicolon
id|tp-&gt;lost_out
op_add_assign
id|tcp_skb_pcount
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
)brace
id|tcp_sync_left_out
c_func
(paren
id|tp
)paren
suffix:semicolon
)brace
multiline_comment|/* Account newly detected lost packet(s) */
DECL|function|tcp_update_scoreboard
r_static
r_void
id|tcp_update_scoreboard
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|tcp_sock
op_star
id|tp
)paren
(brace
r_if
c_cond
(paren
id|IsFack
c_func
(paren
id|tp
)paren
)paren
(brace
r_int
id|lost
op_assign
id|tp-&gt;fackets_out
op_minus
id|tp-&gt;reordering
suffix:semicolon
r_if
c_cond
(paren
id|lost
op_le
l_int|0
)paren
id|lost
op_assign
l_int|1
suffix:semicolon
id|tcp_mark_head_lost
c_func
(paren
id|sk
comma
id|tp
comma
id|lost
comma
id|tp-&gt;high_seq
)paren
suffix:semicolon
)brace
r_else
(brace
id|tcp_mark_head_lost
c_func
(paren
id|sk
comma
id|tp
comma
l_int|1
comma
id|tp-&gt;high_seq
)paren
suffix:semicolon
)brace
multiline_comment|/* New heuristics: it is possible only after we switched&n;&t; * to restart timer each time when something is ACKed.&n;&t; * Hence, we can detect timed out packets during fast&n;&t; * retransmit without falling to slow start.&n;&t; */
r_if
c_cond
(paren
id|tcp_head_timedout
c_func
(paren
id|sk
comma
id|tp
)paren
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
id|sk_stream_for_retrans_queue
c_func
(paren
id|skb
comma
id|sk
)paren
(brace
r_if
c_cond
(paren
id|tcp_skb_timedout
c_func
(paren
id|tp
comma
id|skb
)paren
op_logical_and
op_logical_neg
(paren
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|sacked
op_amp
id|TCPCB_TAGBITS
)paren
)paren
(brace
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|sacked
op_or_assign
id|TCPCB_LOST
suffix:semicolon
id|tp-&gt;lost_out
op_add_assign
id|tcp_skb_pcount
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
)brace
id|tcp_sync_left_out
c_func
(paren
id|tp
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* CWND moderation, preventing bursts due to too big ACKs&n; * in dubious situations.&n; */
DECL|function|tcp_moderate_cwnd
r_static
r_inline
r_void
id|tcp_moderate_cwnd
c_func
(paren
r_struct
id|tcp_sock
op_star
id|tp
)paren
(brace
id|tp-&gt;snd_cwnd
op_assign
id|min
c_func
(paren
id|tp-&gt;snd_cwnd
comma
id|tcp_packets_in_flight
c_func
(paren
id|tp
)paren
op_plus
id|tcp_max_burst
c_func
(paren
id|tp
)paren
)paren
suffix:semicolon
id|tp-&gt;snd_cwnd_stamp
op_assign
id|tcp_time_stamp
suffix:semicolon
)brace
multiline_comment|/* Decrease cwnd each second ack. */
DECL|function|tcp_cwnd_down
r_static
r_void
id|tcp_cwnd_down
c_func
(paren
r_struct
id|tcp_sock
op_star
id|tp
)paren
(brace
r_int
id|decr
op_assign
id|tp-&gt;snd_cwnd_cnt
op_plus
l_int|1
suffix:semicolon
id|__u32
id|limit
suffix:semicolon
multiline_comment|/*&n;&t; * TCP Westwood&n;&t; * Here limit is evaluated as BWestimation*RTTmin (for obtaining it&n;&t; * in packets we use mss_cache). If sysctl_tcp_westwood is off&n;&t; * tcp_westwood_bw_rttmin() returns 0. In such case snd_ssthresh is&n;&t; * still used as usual. It prevents other strange cases in which&n;&t; * BWE*RTTmin could assume value 0. It should not happen but...&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|limit
op_assign
id|tcp_westwood_bw_rttmin
c_func
(paren
id|tp
)paren
)paren
)paren
id|limit
op_assign
id|tp-&gt;snd_ssthresh
op_div
l_int|2
suffix:semicolon
id|tp-&gt;snd_cwnd_cnt
op_assign
id|decr
op_amp
l_int|1
suffix:semicolon
id|decr
op_rshift_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|decr
op_logical_and
id|tp-&gt;snd_cwnd
OG
id|limit
)paren
id|tp-&gt;snd_cwnd
op_sub_assign
id|decr
suffix:semicolon
id|tp-&gt;snd_cwnd
op_assign
id|min
c_func
(paren
id|tp-&gt;snd_cwnd
comma
id|tcp_packets_in_flight
c_func
(paren
id|tp
)paren
op_plus
l_int|1
)paren
suffix:semicolon
id|tp-&gt;snd_cwnd_stamp
op_assign
id|tcp_time_stamp
suffix:semicolon
)brace
multiline_comment|/* Nothing was retransmitted or returned timestamp is less&n; * than timestamp of the first retransmission.&n; */
DECL|function|tcp_packet_delayed
r_static
r_inline
r_int
id|tcp_packet_delayed
c_func
(paren
r_struct
id|tcp_sock
op_star
id|tp
)paren
(brace
r_return
op_logical_neg
id|tp-&gt;retrans_stamp
op_logical_or
(paren
id|tp-&gt;saw_tstamp
op_logical_and
id|tp-&gt;rcv_tsecr
op_logical_and
(paren
id|__s32
)paren
(paren
id|tp-&gt;rcv_tsecr
op_minus
id|tp-&gt;retrans_stamp
)paren
OL
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* Undo procedures. */
macro_line|#if FASTRETRANS_DEBUG &gt; 1
DECL|function|DBGUNDO
r_static
r_void
id|DBGUNDO
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|tcp_sock
op_star
id|tp
comma
r_const
r_char
op_star
id|msg
)paren
(brace
r_struct
id|inet_sock
op_star
id|inet
op_assign
id|inet_sk
c_func
(paren
id|sk
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Undo %s %u.%u.%u.%u/%u c%u l%u ss%u/%u p%u&bslash;n&quot;
comma
id|msg
comma
id|NIPQUAD
c_func
(paren
id|inet-&gt;daddr
)paren
comma
id|ntohs
c_func
(paren
id|inet-&gt;dport
)paren
comma
id|tp-&gt;snd_cwnd
comma
id|tp-&gt;left_out
comma
id|tp-&gt;snd_ssthresh
comma
id|tp-&gt;prior_ssthresh
comma
id|tp-&gt;packets_out
)paren
suffix:semicolon
)brace
macro_line|#else
DECL|macro|DBGUNDO
mdefine_line|#define DBGUNDO(x...) do { } while (0)
macro_line|#endif
DECL|function|tcp_undo_cwr
r_static
r_void
id|tcp_undo_cwr
c_func
(paren
r_struct
id|tcp_sock
op_star
id|tp
comma
r_int
id|undo
)paren
(brace
r_if
c_cond
(paren
id|tp-&gt;prior_ssthresh
)paren
(brace
id|tp-&gt;snd_cwnd
op_assign
id|max
c_func
(paren
id|tp-&gt;snd_cwnd
comma
id|tp-&gt;snd_ssthresh
op_lshift
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|undo
op_logical_and
id|tp-&gt;prior_ssthresh
OG
id|tp-&gt;snd_ssthresh
)paren
(brace
id|tp-&gt;snd_ssthresh
op_assign
id|tp-&gt;prior_ssthresh
suffix:semicolon
id|TCP_ECN_withdraw_cwr
c_func
(paren
id|tp
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|tp-&gt;snd_cwnd
op_assign
id|max
c_func
(paren
id|tp-&gt;snd_cwnd
comma
id|tp-&gt;snd_ssthresh
)paren
suffix:semicolon
)brace
id|tcp_moderate_cwnd
c_func
(paren
id|tp
)paren
suffix:semicolon
id|tp-&gt;snd_cwnd_stamp
op_assign
id|tcp_time_stamp
suffix:semicolon
)brace
DECL|function|tcp_may_undo
r_static
r_inline
r_int
id|tcp_may_undo
c_func
(paren
r_struct
id|tcp_sock
op_star
id|tp
)paren
(brace
r_return
id|tp-&gt;undo_marker
op_logical_and
(paren
op_logical_neg
id|tp-&gt;undo_retrans
op_logical_or
id|tcp_packet_delayed
c_func
(paren
id|tp
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* People celebrate: &quot;We love our President!&quot; */
DECL|function|tcp_try_undo_recovery
r_static
r_int
id|tcp_try_undo_recovery
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|tcp_sock
op_star
id|tp
)paren
(brace
r_if
c_cond
(paren
id|tcp_may_undo
c_func
(paren
id|tp
)paren
)paren
(brace
multiline_comment|/* Happy end! We did not retransmit anything&n;&t;&t; * or our original transmission succeeded.&n;&t;&t; */
id|DBGUNDO
c_func
(paren
id|sk
comma
id|tp
comma
id|tp-&gt;ca_state
op_eq
id|TCP_CA_Loss
ques
c_cond
l_string|&quot;loss&quot;
suffix:colon
l_string|&quot;retrans&quot;
)paren
suffix:semicolon
id|tcp_undo_cwr
c_func
(paren
id|tp
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;ca_state
op_eq
id|TCP_CA_Loss
)paren
id|NET_INC_STATS_BH
c_func
(paren
id|LINUX_MIB_TCPLOSSUNDO
)paren
suffix:semicolon
r_else
id|NET_INC_STATS_BH
c_func
(paren
id|LINUX_MIB_TCPFULLUNDO
)paren
suffix:semicolon
id|tp-&gt;undo_marker
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tp-&gt;snd_una
op_eq
id|tp-&gt;high_seq
op_logical_and
id|IsReno
c_func
(paren
id|tp
)paren
)paren
(brace
multiline_comment|/* Hold old state until something *above* high_seq&n;&t;&t; * is ACKed. For Reno it is MUST to prevent false&n;&t;&t; * fast retransmits (RFC2582). SACK TCP is safe. */
id|tcp_moderate_cwnd
c_func
(paren
id|tp
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|tcp_set_ca_state
c_func
(paren
id|tp
comma
id|TCP_CA_Open
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Try to undo cwnd reduction, because D-SACKs acked all retransmitted data */
DECL|function|tcp_try_undo_dsack
r_static
r_void
id|tcp_try_undo_dsack
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|tcp_sock
op_star
id|tp
)paren
(brace
r_if
c_cond
(paren
id|tp-&gt;undo_marker
op_logical_and
op_logical_neg
id|tp-&gt;undo_retrans
)paren
(brace
id|DBGUNDO
c_func
(paren
id|sk
comma
id|tp
comma
l_string|&quot;D-SACK&quot;
)paren
suffix:semicolon
id|tcp_undo_cwr
c_func
(paren
id|tp
comma
l_int|1
)paren
suffix:semicolon
id|tp-&gt;undo_marker
op_assign
l_int|0
suffix:semicolon
id|NET_INC_STATS_BH
c_func
(paren
id|LINUX_MIB_TCPDSACKUNDO
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Undo during fast recovery after partial ACK. */
DECL|function|tcp_try_undo_partial
r_static
r_int
id|tcp_try_undo_partial
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|tcp_sock
op_star
id|tp
comma
r_int
id|acked
)paren
(brace
multiline_comment|/* Partial ACK arrived. Force Hoe&squot;s retransmit. */
r_int
id|failed
op_assign
id|IsReno
c_func
(paren
id|tp
)paren
op_logical_or
id|tp-&gt;fackets_out
OG
id|tp-&gt;reordering
suffix:semicolon
r_if
c_cond
(paren
id|tcp_may_undo
c_func
(paren
id|tp
)paren
)paren
(brace
multiline_comment|/* Plain luck! Hole if filled with delayed&n;&t;&t; * packet, rather than with a retransmit.&n;&t;&t; */
r_if
c_cond
(paren
id|tp-&gt;retrans_out
op_eq
l_int|0
)paren
id|tp-&gt;retrans_stamp
op_assign
l_int|0
suffix:semicolon
id|tcp_update_reordering
c_func
(paren
id|tp
comma
id|tcp_fackets_out
c_func
(paren
id|tp
)paren
op_plus
id|acked
comma
l_int|1
)paren
suffix:semicolon
id|DBGUNDO
c_func
(paren
id|sk
comma
id|tp
comma
l_string|&quot;Hoe&quot;
)paren
suffix:semicolon
id|tcp_undo_cwr
c_func
(paren
id|tp
comma
l_int|0
)paren
suffix:semicolon
id|NET_INC_STATS_BH
c_func
(paren
id|LINUX_MIB_TCPPARTIALUNDO
)paren
suffix:semicolon
multiline_comment|/* So... Do not make Hoe&squot;s retransmit yet.&n;&t;&t; * If the first packet was delayed, the rest&n;&t;&t; * ones are most probably delayed as well.&n;&t;&t; */
id|failed
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|failed
suffix:semicolon
)brace
multiline_comment|/* Undo during loss recovery after partial ACK. */
DECL|function|tcp_try_undo_loss
r_static
r_int
id|tcp_try_undo_loss
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|tcp_sock
op_star
id|tp
)paren
(brace
r_if
c_cond
(paren
id|tcp_may_undo
c_func
(paren
id|tp
)paren
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
id|sk_stream_for_retrans_queue
c_func
(paren
id|skb
comma
id|sk
)paren
(brace
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|sacked
op_and_assign
op_complement
id|TCPCB_LOST
suffix:semicolon
)brace
id|DBGUNDO
c_func
(paren
id|sk
comma
id|tp
comma
l_string|&quot;partial loss&quot;
)paren
suffix:semicolon
id|tp-&gt;lost_out
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;left_out
op_assign
id|tp-&gt;sacked_out
suffix:semicolon
id|tcp_undo_cwr
c_func
(paren
id|tp
comma
l_int|1
)paren
suffix:semicolon
id|NET_INC_STATS_BH
c_func
(paren
id|LINUX_MIB_TCPLOSSUNDO
)paren
suffix:semicolon
id|tp-&gt;retransmits
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;undo_marker
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|IsReno
c_func
(paren
id|tp
)paren
)paren
id|tcp_set_ca_state
c_func
(paren
id|tp
comma
id|TCP_CA_Open
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|tcp_complete_cwr
r_static
r_inline
r_void
id|tcp_complete_cwr
c_func
(paren
r_struct
id|tcp_sock
op_star
id|tp
)paren
(brace
r_if
c_cond
(paren
id|tcp_westwood_cwnd
c_func
(paren
id|tp
)paren
)paren
id|tp-&gt;snd_ssthresh
op_assign
id|tp-&gt;snd_cwnd
suffix:semicolon
r_else
id|tp-&gt;snd_cwnd
op_assign
id|min
c_func
(paren
id|tp-&gt;snd_cwnd
comma
id|tp-&gt;snd_ssthresh
)paren
suffix:semicolon
id|tp-&gt;snd_cwnd_stamp
op_assign
id|tcp_time_stamp
suffix:semicolon
)brace
DECL|function|tcp_try_to_open
r_static
r_void
id|tcp_try_to_open
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|tcp_sock
op_star
id|tp
comma
r_int
id|flag
)paren
(brace
id|tp-&gt;left_out
op_assign
id|tp-&gt;sacked_out
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;retrans_out
op_eq
l_int|0
)paren
id|tp-&gt;retrans_stamp
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|flag
op_amp
id|FLAG_ECE
)paren
id|tcp_enter_cwr
c_func
(paren
id|tp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;ca_state
op_ne
id|TCP_CA_CWR
)paren
(brace
r_int
id|state
op_assign
id|TCP_CA_Open
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;left_out
op_logical_or
id|tp-&gt;retrans_out
op_logical_or
id|tp-&gt;undo_marker
)paren
id|state
op_assign
id|TCP_CA_Disorder
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;ca_state
op_ne
id|state
)paren
(brace
id|tcp_set_ca_state
c_func
(paren
id|tp
comma
id|state
)paren
suffix:semicolon
id|tp-&gt;high_seq
op_assign
id|tp-&gt;snd_nxt
suffix:semicolon
)brace
id|tcp_moderate_cwnd
c_func
(paren
id|tp
)paren
suffix:semicolon
)brace
r_else
(brace
id|tcp_cwnd_down
c_func
(paren
id|tp
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Process an event, which can update packets-in-flight not trivially.&n; * Main goal of this function is to calculate new estimate for left_out,&n; * taking into account both packets sitting in receiver&squot;s buffer and&n; * packets lost by network.&n; *&n; * Besides that it does CWND reduction, when packet loss is detected&n; * and changes state of machine.&n; *&n; * It does _not_ decide what to send, it is made in function&n; * tcp_xmit_retransmit_queue().&n; */
r_static
r_void
DECL|function|tcp_fastretrans_alert
id|tcp_fastretrans_alert
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
id|u32
id|prior_snd_una
comma
r_int
id|prior_packets
comma
r_int
id|flag
)paren
(brace
r_struct
id|tcp_sock
op_star
id|tp
op_assign
id|tcp_sk
c_func
(paren
id|sk
)paren
suffix:semicolon
r_int
id|is_dupack
op_assign
(paren
id|tp-&gt;snd_una
op_eq
id|prior_snd_una
op_logical_and
op_logical_neg
(paren
id|flag
op_amp
id|FLAG_NOT_DUP
)paren
)paren
suffix:semicolon
multiline_comment|/* Some technical things:&n;&t; * 1. Reno does not count dupacks (sacked_out) automatically. */
r_if
c_cond
(paren
op_logical_neg
id|tp-&gt;packets_out
)paren
id|tp-&gt;sacked_out
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* 2. SACK counts snd_fack in packets inaccurately. */
r_if
c_cond
(paren
id|tp-&gt;sacked_out
op_eq
l_int|0
)paren
id|tp-&gt;fackets_out
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Now state machine starts.&n;&t; * A. ECE, hence prohibit cwnd undoing, the reduction is required. */
r_if
c_cond
(paren
id|flag
op_amp
id|FLAG_ECE
)paren
id|tp-&gt;prior_ssthresh
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* B. In all the states check for reneging SACKs. */
r_if
c_cond
(paren
id|tp-&gt;sacked_out
op_logical_and
id|tcp_check_sack_reneging
c_func
(paren
id|sk
comma
id|tp
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* C. Process data loss notification, provided it is valid. */
r_if
c_cond
(paren
(paren
id|flag
op_amp
id|FLAG_DATA_LOST
)paren
op_logical_and
id|before
c_func
(paren
id|tp-&gt;snd_una
comma
id|tp-&gt;high_seq
)paren
op_logical_and
id|tp-&gt;ca_state
op_ne
id|TCP_CA_Open
op_logical_and
id|tp-&gt;fackets_out
OG
id|tp-&gt;reordering
)paren
(brace
id|tcp_mark_head_lost
c_func
(paren
id|sk
comma
id|tp
comma
id|tp-&gt;fackets_out
op_minus
id|tp-&gt;reordering
comma
id|tp-&gt;high_seq
)paren
suffix:semicolon
id|NET_INC_STATS_BH
c_func
(paren
id|LINUX_MIB_TCPLOSS
)paren
suffix:semicolon
)brace
multiline_comment|/* D. Synchronize left_out to current state. */
id|tcp_sync_left_out
c_func
(paren
id|tp
)paren
suffix:semicolon
multiline_comment|/* E. Check state exit conditions. State can be terminated&n;&t; *    when high_seq is ACKed. */
r_if
c_cond
(paren
id|tp-&gt;ca_state
op_eq
id|TCP_CA_Open
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|sysctl_tcp_frto
)paren
id|BUG_TRAP
c_func
(paren
id|tp-&gt;retrans_out
op_eq
l_int|0
)paren
suffix:semicolon
id|tp-&gt;retrans_stamp
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|before
c_func
(paren
id|tp-&gt;snd_una
comma
id|tp-&gt;high_seq
)paren
)paren
(brace
r_switch
c_cond
(paren
id|tp-&gt;ca_state
)paren
(brace
r_case
id|TCP_CA_Loss
suffix:colon
id|tp-&gt;retransmits
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|tcp_try_undo_recovery
c_func
(paren
id|sk
comma
id|tp
)paren
)paren
r_return
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TCP_CA_CWR
suffix:colon
multiline_comment|/* CWR is to be held something *above* high_seq&n;&t;&t;&t; * is ACKed for CWR bit to reach receiver. */
r_if
c_cond
(paren
id|tp-&gt;snd_una
op_ne
id|tp-&gt;high_seq
)paren
(brace
id|tcp_complete_cwr
c_func
(paren
id|tp
)paren
suffix:semicolon
id|tcp_set_ca_state
c_func
(paren
id|tp
comma
id|TCP_CA_Open
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|TCP_CA_Disorder
suffix:colon
id|tcp_try_undo_dsack
c_func
(paren
id|sk
comma
id|tp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tp-&gt;undo_marker
op_logical_or
multiline_comment|/* For SACK case do not Open to allow to undo&n;&t;&t;&t;     * catching for all duplicate ACKs. */
id|IsReno
c_func
(paren
id|tp
)paren
op_logical_or
id|tp-&gt;snd_una
op_ne
id|tp-&gt;high_seq
)paren
(brace
id|tp-&gt;undo_marker
op_assign
l_int|0
suffix:semicolon
id|tcp_set_ca_state
c_func
(paren
id|tp
comma
id|TCP_CA_Open
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|TCP_CA_Recovery
suffix:colon
r_if
c_cond
(paren
id|IsReno
c_func
(paren
id|tp
)paren
)paren
id|tcp_reset_reno_sack
c_func
(paren
id|tp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tcp_try_undo_recovery
c_func
(paren
id|sk
comma
id|tp
)paren
)paren
r_return
suffix:semicolon
id|tcp_complete_cwr
c_func
(paren
id|tp
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* F. Process state. */
r_switch
c_cond
(paren
id|tp-&gt;ca_state
)paren
(brace
r_case
id|TCP_CA_Recovery
suffix:colon
r_if
c_cond
(paren
id|prior_snd_una
op_eq
id|tp-&gt;snd_una
)paren
(brace
r_if
c_cond
(paren
id|IsReno
c_func
(paren
id|tp
)paren
op_logical_and
id|is_dupack
)paren
id|tcp_add_reno_sack
c_func
(paren
id|tp
)paren
suffix:semicolon
)brace
r_else
(brace
r_int
id|acked
op_assign
id|prior_packets
op_minus
id|tp-&gt;packets_out
suffix:semicolon
r_if
c_cond
(paren
id|IsReno
c_func
(paren
id|tp
)paren
)paren
id|tcp_remove_reno_sacks
c_func
(paren
id|sk
comma
id|tp
comma
id|acked
)paren
suffix:semicolon
id|is_dupack
op_assign
id|tcp_try_undo_partial
c_func
(paren
id|sk
comma
id|tp
comma
id|acked
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|TCP_CA_Loss
suffix:colon
r_if
c_cond
(paren
id|flag
op_amp
id|FLAG_DATA_ACKED
)paren
id|tp-&gt;retransmits
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tcp_try_undo_loss
c_func
(paren
id|sk
comma
id|tp
)paren
)paren
(brace
id|tcp_moderate_cwnd
c_func
(paren
id|tp
)paren
suffix:semicolon
id|tcp_xmit_retransmit_queue
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tp-&gt;ca_state
op_ne
id|TCP_CA_Open
)paren
r_return
suffix:semicolon
multiline_comment|/* Loss is undone; fall through to processing in Open state. */
r_default
suffix:colon
(brace
)brace
r_if
c_cond
(paren
id|IsReno
c_func
(paren
id|tp
)paren
)paren
(brace
r_if
c_cond
(paren
id|tp-&gt;snd_una
op_ne
id|prior_snd_una
)paren
id|tcp_reset_reno_sack
c_func
(paren
id|tp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_dupack
)paren
id|tcp_add_reno_sack
c_func
(paren
id|tp
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tp-&gt;ca_state
op_eq
id|TCP_CA_Disorder
)paren
id|tcp_try_undo_dsack
c_func
(paren
id|sk
comma
id|tp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tcp_time_to_recover
c_func
(paren
id|sk
comma
id|tp
)paren
)paren
(brace
id|tcp_try_to_open
c_func
(paren
id|sk
comma
id|tp
comma
id|flag
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Otherwise enter Recovery state */
r_if
c_cond
(paren
id|IsReno
c_func
(paren
id|tp
)paren
)paren
id|NET_INC_STATS_BH
c_func
(paren
id|LINUX_MIB_TCPRENORECOVERY
)paren
suffix:semicolon
r_else
id|NET_INC_STATS_BH
c_func
(paren
id|LINUX_MIB_TCPSACKRECOVERY
)paren
suffix:semicolon
id|tp-&gt;high_seq
op_assign
id|tp-&gt;snd_nxt
suffix:semicolon
id|tp-&gt;prior_ssthresh
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;undo_marker
op_assign
id|tp-&gt;snd_una
suffix:semicolon
id|tp-&gt;undo_retrans
op_assign
id|tp-&gt;retrans_out
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;ca_state
OL
id|TCP_CA_CWR
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|flag
op_amp
id|FLAG_ECE
)paren
)paren
id|tp-&gt;prior_ssthresh
op_assign
id|tcp_current_ssthresh
c_func
(paren
id|tp
)paren
suffix:semicolon
id|tp-&gt;snd_ssthresh
op_assign
id|tcp_recalc_ssthresh
c_func
(paren
id|tp
)paren
suffix:semicolon
id|TCP_ECN_queue_cwr
c_func
(paren
id|tp
)paren
suffix:semicolon
)brace
id|tp-&gt;snd_cwnd_cnt
op_assign
l_int|0
suffix:semicolon
id|tcp_set_ca_state
c_func
(paren
id|tp
comma
id|TCP_CA_Recovery
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|is_dupack
op_logical_or
id|tcp_head_timedout
c_func
(paren
id|sk
comma
id|tp
)paren
)paren
id|tcp_update_scoreboard
c_func
(paren
id|sk
comma
id|tp
)paren
suffix:semicolon
id|tcp_cwnd_down
c_func
(paren
id|tp
)paren
suffix:semicolon
id|tcp_xmit_retransmit_queue
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
multiline_comment|/* Read draft-ietf-tcplw-high-performance before mucking&n; * with this code. (Superceeds RFC1323)&n; */
DECL|function|tcp_ack_saw_tstamp
r_static
r_void
id|tcp_ack_saw_tstamp
c_func
(paren
r_struct
id|tcp_sock
op_star
id|tp
comma
r_int
id|flag
)paren
(brace
id|__u32
id|seq_rtt
suffix:semicolon
multiline_comment|/* RTTM Rule: A TSecr value received in a segment is used to&n;&t; * update the averaged RTT measurement only if the segment&n;&t; * acknowledges some new data, i.e., only if it advances the&n;&t; * left edge of the send window.&n;&t; *&n;&t; * See draft-ietf-tcplw-high-performance-00, section 3.3.&n;&t; * 1998/04/10 Andrey V. Savochkin &lt;saw@msu.ru&gt;&n;&t; *&n;&t; * Changed: reset backoff as soon as we see the first valid sample.&n;&t; * If we do not, we get strongly overstimated rto. With timestamps&n;&t; * samples are accepted even from very old segments: f.e., when rtt=1&n;&t; * increases to 8, we retransmit 5 times and after 8 seconds delayed&n;&t; * answer arrives rto becomes 120 seconds! If at least one of segments&n;&t; * in window is lost... Voila.&t; &t;&t;&t;--ANK (010210)&n;&t; */
id|seq_rtt
op_assign
id|tcp_time_stamp
op_minus
id|tp-&gt;rcv_tsecr
suffix:semicolon
id|tcp_rtt_estimator
c_func
(paren
id|tp
comma
id|seq_rtt
)paren
suffix:semicolon
id|tcp_set_rto
c_func
(paren
id|tp
)paren
suffix:semicolon
id|tp-&gt;backoff
op_assign
l_int|0
suffix:semicolon
id|tcp_bound_rto
c_func
(paren
id|tp
)paren
suffix:semicolon
)brace
DECL|function|tcp_ack_no_tstamp
r_static
r_void
id|tcp_ack_no_tstamp
c_func
(paren
r_struct
id|tcp_sock
op_star
id|tp
comma
id|u32
id|seq_rtt
comma
r_int
id|flag
)paren
(brace
multiline_comment|/* We don&squot;t have a timestamp. Can only use&n;&t; * packets that are not retransmitted to determine&n;&t; * rtt estimates. Also, we must not reset the&n;&t; * backoff for rto until we get a non-retransmitted&n;&t; * packet. This allows us to deal with a situation&n;&t; * where the network delay has increased suddenly.&n;&t; * I.e. Karn&squot;s algorithm. (SIGCOMM &squot;87, p5.)&n;&t; */
r_if
c_cond
(paren
id|flag
op_amp
id|FLAG_RETRANS_DATA_ACKED
)paren
r_return
suffix:semicolon
id|tcp_rtt_estimator
c_func
(paren
id|tp
comma
id|seq_rtt
)paren
suffix:semicolon
id|tcp_set_rto
c_func
(paren
id|tp
)paren
suffix:semicolon
id|tp-&gt;backoff
op_assign
l_int|0
suffix:semicolon
id|tcp_bound_rto
c_func
(paren
id|tp
)paren
suffix:semicolon
)brace
DECL|function|tcp_ack_update_rtt
r_static
r_inline
r_void
id|tcp_ack_update_rtt
c_func
(paren
r_struct
id|tcp_sock
op_star
id|tp
comma
r_int
id|flag
comma
id|s32
id|seq_rtt
)paren
(brace
multiline_comment|/* Note that peer MAY send zero echo. In this case it is ignored. (rfc1323) */
r_if
c_cond
(paren
id|tp-&gt;saw_tstamp
op_logical_and
id|tp-&gt;rcv_tsecr
)paren
id|tcp_ack_saw_tstamp
c_func
(paren
id|tp
comma
id|flag
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|seq_rtt
op_ge
l_int|0
)paren
id|tcp_ack_no_tstamp
c_func
(paren
id|tp
comma
id|seq_rtt
comma
id|flag
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Compute congestion window to use.&n; *&n; * This is from the implementation of BICTCP in&n; * Lison-Xu, Kahaled Harfoush, and Injog Rhee.&n; *  &quot;Binary Increase Congestion Control for Fast, Long Distance&n; *  Networks&quot; in InfoComm 2004&n; * Available from:&n; *  http://www.csc.ncsu.edu/faculty/rhee/export/bitcp.pdf&n; *&n; * Unless BIC is enabled and congestion window is large&n; * this behaves the same as the original Reno.&n; */
DECL|function|bictcp_cwnd
r_static
r_inline
id|__u32
id|bictcp_cwnd
c_func
(paren
r_struct
id|tcp_sock
op_star
id|tp
)paren
(brace
multiline_comment|/* orignal Reno behaviour */
r_if
c_cond
(paren
op_logical_neg
id|tcp_is_bic
c_func
(paren
id|tp
)paren
)paren
r_return
id|tp-&gt;snd_cwnd
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;bictcp.last_cwnd
op_eq
id|tp-&gt;snd_cwnd
op_logical_and
(paren
id|s32
)paren
(paren
id|tcp_time_stamp
op_minus
id|tp-&gt;bictcp.last_stamp
)paren
op_le
(paren
id|HZ
op_rshift
l_int|5
)paren
)paren
r_return
id|tp-&gt;bictcp.cnt
suffix:semicolon
id|tp-&gt;bictcp.last_cwnd
op_assign
id|tp-&gt;snd_cwnd
suffix:semicolon
id|tp-&gt;bictcp.last_stamp
op_assign
id|tcp_time_stamp
suffix:semicolon
multiline_comment|/* start off normal */
r_if
c_cond
(paren
id|tp-&gt;snd_cwnd
op_le
id|sysctl_tcp_bic_low_window
)paren
id|tp-&gt;bictcp.cnt
op_assign
id|tp-&gt;snd_cwnd
suffix:semicolon
multiline_comment|/* binary increase */
r_else
r_if
c_cond
(paren
id|tp-&gt;snd_cwnd
OL
id|tp-&gt;bictcp.last_max_cwnd
)paren
(brace
id|__u32
id|dist
op_assign
(paren
id|tp-&gt;bictcp.last_max_cwnd
op_minus
id|tp-&gt;snd_cwnd
)paren
op_div
id|BICTCP_B
suffix:semicolon
r_if
c_cond
(paren
id|dist
OG
id|BICTCP_MAX_INCREMENT
)paren
multiline_comment|/* linear increase */
id|tp-&gt;bictcp.cnt
op_assign
id|tp-&gt;snd_cwnd
op_div
id|BICTCP_MAX_INCREMENT
suffix:semicolon
r_else
r_if
c_cond
(paren
id|dist
op_le
l_int|1U
)paren
multiline_comment|/* binary search increase */
id|tp-&gt;bictcp.cnt
op_assign
id|tp-&gt;snd_cwnd
op_star
id|BICTCP_FUNC_OF_MIN_INCR
op_div
id|BICTCP_B
suffix:semicolon
r_else
multiline_comment|/* binary search increase */
id|tp-&gt;bictcp.cnt
op_assign
id|tp-&gt;snd_cwnd
op_div
id|dist
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* slow start amd linear increase */
r_if
c_cond
(paren
id|tp-&gt;snd_cwnd
OL
id|tp-&gt;bictcp.last_max_cwnd
op_plus
id|BICTCP_B
)paren
multiline_comment|/* slow start */
id|tp-&gt;bictcp.cnt
op_assign
id|tp-&gt;snd_cwnd
op_star
id|BICTCP_FUNC_OF_MIN_INCR
op_div
id|BICTCP_B
suffix:semicolon
r_else
r_if
c_cond
(paren
id|tp-&gt;snd_cwnd
OL
id|tp-&gt;bictcp.last_max_cwnd
op_plus
id|BICTCP_MAX_INCREMENT
op_star
(paren
id|BICTCP_B
op_minus
l_int|1
)paren
)paren
multiline_comment|/* slow start */
id|tp-&gt;bictcp.cnt
op_assign
id|tp-&gt;snd_cwnd
op_star
(paren
id|BICTCP_B
op_minus
l_int|1
)paren
op_div
(paren
id|tp-&gt;snd_cwnd
op_minus
id|tp-&gt;bictcp.last_max_cwnd
)paren
suffix:semicolon
r_else
multiline_comment|/* linear increase */
id|tp-&gt;bictcp.cnt
op_assign
id|tp-&gt;snd_cwnd
op_div
id|BICTCP_MAX_INCREMENT
suffix:semicolon
)brace
r_return
id|tp-&gt;bictcp.cnt
suffix:semicolon
)brace
multiline_comment|/* This is Jacobson&squot;s slow start and congestion avoidance. &n; * SIGCOMM &squot;88, p. 328.&n; */
DECL|function|reno_cong_avoid
r_static
r_inline
r_void
id|reno_cong_avoid
c_func
(paren
r_struct
id|tcp_sock
op_star
id|tp
)paren
(brace
r_if
c_cond
(paren
id|tp-&gt;snd_cwnd
op_le
id|tp-&gt;snd_ssthresh
)paren
(brace
multiline_comment|/* In &quot;safe&quot; area, increase. */
r_if
c_cond
(paren
id|tp-&gt;snd_cwnd
OL
id|tp-&gt;snd_cwnd_clamp
)paren
id|tp-&gt;snd_cwnd
op_increment
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* In dangerous area, increase slowly.&n;&t;&t; * In theory this is tp-&gt;snd_cwnd += 1 / tp-&gt;snd_cwnd&n;&t;&t; */
r_if
c_cond
(paren
id|tp-&gt;snd_cwnd_cnt
op_ge
id|bictcp_cwnd
c_func
(paren
id|tp
)paren
)paren
(brace
r_if
c_cond
(paren
id|tp-&gt;snd_cwnd
OL
id|tp-&gt;snd_cwnd_clamp
)paren
id|tp-&gt;snd_cwnd
op_increment
suffix:semicolon
id|tp-&gt;snd_cwnd_cnt
op_assign
l_int|0
suffix:semicolon
)brace
r_else
id|tp-&gt;snd_cwnd_cnt
op_increment
suffix:semicolon
)brace
id|tp-&gt;snd_cwnd_stamp
op_assign
id|tcp_time_stamp
suffix:semicolon
)brace
multiline_comment|/* This is based on the congestion detection/avoidance scheme described in&n; *    Lawrence S. Brakmo and Larry L. Peterson.&n; *    &quot;TCP Vegas: End to end congestion avoidance on a global internet.&quot;&n; *    IEEE Journal on Selected Areas in Communication, 13(8):1465--1480,&n; *    October 1995. Available from:&n; *&t;ftp://ftp.cs.arizona.edu/xkernel/Papers/jsac.ps&n; *&n; * See http://www.cs.arizona.edu/xkernel/ for their implementation.&n; * The main aspects that distinguish this implementation from the&n; * Arizona Vegas implementation are:&n; *   o We do not change the loss detection or recovery mechanisms of&n; *     Linux in any way. Linux already recovers from losses quite well,&n; *     using fine-grained timers, NewReno, and FACK.&n; *   o To avoid the performance penalty imposed by increasing cwnd&n; *     only every-other RTT during slow start, we increase during&n; *     every RTT during slow start, just like Reno.&n; *   o Largely to allow continuous cwnd growth during slow start,&n; *     we use the rate at which ACKs come back as the &quot;actual&quot;&n; *     rate, rather than the rate at which data is sent.&n; *   o To speed convergence to the right rate, we set the cwnd&n; *     to achieve the right (&quot;actual&quot;) rate when we exit slow start.&n; *   o To filter out the noise caused by delayed ACKs, we use the&n; *     minimum RTT sample observed during the last RTT to calculate&n; *     the actual rate.&n; *   o When the sender re-starts from idle, it waits until it has&n; *     received ACKs for an entire flight of new data before making&n; *     a cwnd adjustment decision. The original Vegas implementation&n; *     assumed senders never went idle.&n; */
DECL|function|vegas_cong_avoid
r_static
r_void
id|vegas_cong_avoid
c_func
(paren
r_struct
id|tcp_sock
op_star
id|tp
comma
id|u32
id|ack
comma
id|u32
id|seq_rtt
)paren
(brace
multiline_comment|/* The key players are v_beg_snd_una and v_beg_snd_nxt.&n;&t; *&n;&t; * These are so named because they represent the approximate values&n;&t; * of snd_una and snd_nxt at the beginning of the current RTT. More&n;&t; * precisely, they represent the amount of data sent during the RTT.&n;&t; * At the end of the RTT, when we receive an ACK for v_beg_snd_nxt,&n;&t; * we will calculate that (v_beg_snd_nxt - v_beg_snd_una) outstanding&n;&t; * bytes of data have been ACKed during the course of the RTT, giving&n;&t; * an &quot;actual&quot; rate of:&n;&t; *&n;&t; *     (v_beg_snd_nxt - v_beg_snd_una) / (rtt duration)&n;&t; *&n;&t; * Unfortunately, v_beg_snd_una is not exactly equal to snd_una,&n;&t; * because delayed ACKs can cover more than one segment, so they&n;&t; * don&squot;t line up nicely with the boundaries of RTTs.&n;&t; *&n;&t; * Another unfortunate fact of life is that delayed ACKs delay the&n;&t; * advance of the left edge of our send window, so that the number&n;&t; * of bytes we send in an RTT is often less than our cwnd will allow.&n;&t; * So we keep track of our cwnd separately, in v_beg_snd_cwnd.&n;&t; */
r_if
c_cond
(paren
id|after
c_func
(paren
id|ack
comma
id|tp-&gt;vegas.beg_snd_nxt
)paren
)paren
(brace
multiline_comment|/* Do the Vegas once-per-RTT cwnd adjustment. */
id|u32
id|old_wnd
comma
id|old_snd_cwnd
suffix:semicolon
multiline_comment|/* Here old_wnd is essentially the window of data that was&n;&t;&t; * sent during the previous RTT, and has all&n;&t;&t; * been acknowledged in the course of the RTT that ended&n;&t;&t; * with the ACK we just received. Likewise, old_snd_cwnd&n;&t;&t; * is the cwnd during the previous RTT.&n;&t;&t; */
id|old_wnd
op_assign
(paren
id|tp-&gt;vegas.beg_snd_nxt
op_minus
id|tp-&gt;vegas.beg_snd_una
)paren
op_div
id|tp-&gt;mss_cache_std
suffix:semicolon
id|old_snd_cwnd
op_assign
id|tp-&gt;vegas.beg_snd_cwnd
suffix:semicolon
multiline_comment|/* Save the extent of the current window so we can use this&n;&t;&t; * at the end of the next RTT.&n;&t;&t; */
id|tp-&gt;vegas.beg_snd_una
op_assign
id|tp-&gt;vegas.beg_snd_nxt
suffix:semicolon
id|tp-&gt;vegas.beg_snd_nxt
op_assign
id|tp-&gt;snd_nxt
suffix:semicolon
id|tp-&gt;vegas.beg_snd_cwnd
op_assign
id|tp-&gt;snd_cwnd
suffix:semicolon
multiline_comment|/* Take into account the current RTT sample too, to&n;&t;&t; * decrease the impact of delayed acks. This double counts&n;&t;&t; * this sample since we count it for the next window as well,&n;&t;&t; * but that&squot;s not too awful, since we&squot;re taking the min,&n;&t;&t; * rather than averaging.&n;&t;&t; */
id|vegas_rtt_calc
c_func
(paren
id|tp
comma
id|seq_rtt
)paren
suffix:semicolon
multiline_comment|/* We do the Vegas calculations only if we got enough RTT&n;&t;&t; * samples that we can be reasonably sure that we got&n;&t;&t; * at least one RTT sample that wasn&squot;t from a delayed ACK.&n;&t;&t; * If we only had 2 samples total,&n;&t;&t; * then that means we&squot;re getting only 1 ACK per RTT, which&n;&t;&t; * means they&squot;re almost certainly delayed ACKs.&n;&t;&t; * If  we have 3 samples, we should be OK.&n;&t;&t; */
r_if
c_cond
(paren
id|tp-&gt;vegas.cntRTT
op_le
l_int|2
)paren
(brace
multiline_comment|/* We don&squot;t have enough RTT samples to do the Vegas&n;&t;&t;&t; * calculation, so we&squot;ll behave like Reno.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|tp-&gt;snd_cwnd
OG
id|tp-&gt;snd_ssthresh
)paren
id|tp-&gt;snd_cwnd
op_increment
suffix:semicolon
)brace
r_else
(brace
id|u32
id|rtt
comma
id|target_cwnd
comma
id|diff
suffix:semicolon
multiline_comment|/* We have enough RTT samples, so, using the Vegas&n;&t;&t;&t; * algorithm, we determine if we should increase or&n;&t;&t;&t; * decrease cwnd, and by how much.&n;&t;&t;&t; */
multiline_comment|/* Pluck out the RTT we are using for the Vegas&n;&t;&t;&t; * calculations. This is the min RTT seen during the&n;&t;&t;&t; * last RTT. Taking the min filters out the effects&n;&t;&t;&t; * of delayed ACKs, at the cost of noticing congestion&n;&t;&t;&t; * a bit later.&n;&t;&t;&t; */
id|rtt
op_assign
id|tp-&gt;vegas.minRTT
suffix:semicolon
multiline_comment|/* Calculate the cwnd we should have, if we weren&squot;t&n;&t;&t;&t; * going too fast.&n;&t;&t;&t; *&n;&t;&t;&t; * This is:&n;&t;&t;&t; *     (actual rate in segments) * baseRTT&n;&t;&t;&t; * We keep it as a fixed point number with&n;&t;&t;&t; * V_PARAM_SHIFT bits to the right of the binary point.&n;&t;&t;&t; */
id|target_cwnd
op_assign
(paren
(paren
id|old_wnd
op_star
id|tp-&gt;vegas.baseRTT
)paren
op_lshift
id|V_PARAM_SHIFT
)paren
op_div
id|rtt
suffix:semicolon
multiline_comment|/* Calculate the difference between the window we had,&n;&t;&t;&t; * and the window we would like to have. This quantity&n;&t;&t;&t; * is the &quot;Diff&quot; from the Arizona Vegas papers.&n;&t;&t;&t; *&n;&t;&t;&t; * Again, this is a fixed point number with&n;&t;&t;&t; * V_PARAM_SHIFT bits to the right of the binary&n;&t;&t;&t; * point.&n;&t;&t;&t; */
id|diff
op_assign
(paren
id|old_wnd
op_lshift
id|V_PARAM_SHIFT
)paren
op_minus
id|target_cwnd
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;snd_cwnd
OL
id|tp-&gt;snd_ssthresh
)paren
(brace
multiline_comment|/* Slow start.  */
r_if
c_cond
(paren
id|diff
OG
id|sysctl_tcp_vegas_gamma
)paren
(brace
multiline_comment|/* Going too fast. Time to slow down&n;&t;&t;&t;&t;&t; * and switch to congestion avoidance.&n;&t;&t;&t;&t;&t; */
id|tp-&gt;snd_ssthresh
op_assign
l_int|2
suffix:semicolon
multiline_comment|/* Set cwnd to match the actual rate&n;&t;&t;&t;&t;&t; * exactly:&n;&t;&t;&t;&t;&t; *   cwnd = (actual rate) * baseRTT&n;&t;&t;&t;&t;&t; * Then we add 1 because the integer&n;&t;&t;&t;&t;&t; * truncation robs us of full link&n;&t;&t;&t;&t;&t; * utilization.&n;&t;&t;&t;&t;&t; */
id|tp-&gt;snd_cwnd
op_assign
id|min
c_func
(paren
id|tp-&gt;snd_cwnd
comma
(paren
id|target_cwnd
op_rshift
id|V_PARAM_SHIFT
)paren
op_plus
l_int|1
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* Congestion avoidance. */
id|u32
id|next_snd_cwnd
suffix:semicolon
multiline_comment|/* Figure out where we would like cwnd&n;&t;&t;&t;&t; * to be.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|diff
OG
id|sysctl_tcp_vegas_beta
)paren
(brace
multiline_comment|/* The old window was too fast, so&n;&t;&t;&t;&t;&t; * we slow down.&n;&t;&t;&t;&t;&t; */
id|next_snd_cwnd
op_assign
id|old_snd_cwnd
op_minus
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|diff
OL
id|sysctl_tcp_vegas_alpha
)paren
(brace
multiline_comment|/* We don&squot;t have enough extra packets&n;&t;&t;&t;&t;&t; * in the network, so speed up.&n;&t;&t;&t;&t;&t; */
id|next_snd_cwnd
op_assign
id|old_snd_cwnd
op_plus
l_int|1
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Sending just as fast as we&n;&t;&t;&t;&t;&t; * should be.&n;&t;&t;&t;&t;&t; */
id|next_snd_cwnd
op_assign
id|old_snd_cwnd
suffix:semicolon
)brace
multiline_comment|/* Adjust cwnd upward or downward, toward the&n;&t;&t;&t;&t; * desired value.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|next_snd_cwnd
OG
id|tp-&gt;snd_cwnd
)paren
id|tp-&gt;snd_cwnd
op_increment
suffix:semicolon
r_else
r_if
c_cond
(paren
id|next_snd_cwnd
OL
id|tp-&gt;snd_cwnd
)paren
id|tp-&gt;snd_cwnd
op_decrement
suffix:semicolon
)brace
)brace
multiline_comment|/* Wipe the slate clean for the next RTT. */
id|tp-&gt;vegas.cntRTT
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;vegas.minRTT
op_assign
l_int|0x7fffffff
suffix:semicolon
)brace
multiline_comment|/* The following code is executed for every ack we receive,&n;&t; * except for conditions checked in should_advance_cwnd()&n;&t; * before the call to tcp_cong_avoid(). Mainly this means that&n;&t; * we only execute this code if the ack actually acked some&n;&t; * data.&n;&t; */
multiline_comment|/* If we are in slow start, increase our cwnd in response to this ACK.&n;&t; * (If we are not in slow start then we are in congestion avoidance,&n;&t; * and adjust our congestion window only once per RTT. See the code&n;&t; * above.)&n;&t; */
r_if
c_cond
(paren
id|tp-&gt;snd_cwnd
op_le
id|tp-&gt;snd_ssthresh
)paren
id|tp-&gt;snd_cwnd
op_increment
suffix:semicolon
multiline_comment|/* to keep cwnd from growing without bound */
id|tp-&gt;snd_cwnd
op_assign
id|min_t
c_func
(paren
id|u32
comma
id|tp-&gt;snd_cwnd
comma
id|tp-&gt;snd_cwnd_clamp
)paren
suffix:semicolon
multiline_comment|/* Make sure that we are never so timid as to reduce our cwnd below&n;&t; * 2 MSS.&n;&t; *&n;&t; * Going below 2 MSS would risk huge delayed ACKs from our receiver.&n;&t; */
id|tp-&gt;snd_cwnd
op_assign
id|max
c_func
(paren
id|tp-&gt;snd_cwnd
comma
l_int|2U
)paren
suffix:semicolon
id|tp-&gt;snd_cwnd_stamp
op_assign
id|tcp_time_stamp
suffix:semicolon
)brace
DECL|function|tcp_cong_avoid
r_static
r_inline
r_void
id|tcp_cong_avoid
c_func
(paren
r_struct
id|tcp_sock
op_star
id|tp
comma
id|u32
id|ack
comma
id|u32
id|seq_rtt
)paren
(brace
r_if
c_cond
(paren
id|tcp_vegas_enabled
c_func
(paren
id|tp
)paren
)paren
id|vegas_cong_avoid
c_func
(paren
id|tp
comma
id|ack
comma
id|seq_rtt
)paren
suffix:semicolon
r_else
id|reno_cong_avoid
c_func
(paren
id|tp
)paren
suffix:semicolon
)brace
multiline_comment|/* Restart timer after forward progress on connection.&n; * RFC2988 recommends to restart timer to now+rto.&n; */
DECL|function|tcp_ack_packets_out
r_static
r_inline
r_void
id|tcp_ack_packets_out
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|tcp_sock
op_star
id|tp
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|tp-&gt;packets_out
)paren
(brace
id|tcp_clear_xmit_timer
c_func
(paren
id|sk
comma
id|TCP_TIME_RETRANS
)paren
suffix:semicolon
)brace
r_else
(brace
id|tcp_reset_xmit_timer
c_func
(paren
id|sk
comma
id|TCP_TIME_RETRANS
comma
id|tp-&gt;rto
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* There is one downside to this scheme.  Although we keep the&n; * ACK clock ticking, adjusting packet counters and advancing&n; * congestion window, we do not liberate socket send buffer&n; * space.&n; *&n; * Mucking with skb-&gt;truesize and sk-&gt;sk_wmem_alloc et al.&n; * then making a write space wakeup callback is a possible&n; * future enhancement.  WARNING: it is not trivial to make.&n; */
DECL|function|tcp_tso_acked
r_static
r_int
id|tcp_tso_acked
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
comma
id|__u32
id|now
comma
id|__s32
op_star
id|seq_rtt
)paren
(brace
r_struct
id|tcp_sock
op_star
id|tp
op_assign
id|tcp_sk
c_func
(paren
id|sk
)paren
suffix:semicolon
r_struct
id|tcp_skb_cb
op_star
id|scb
op_assign
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
suffix:semicolon
id|__u32
id|seq
op_assign
id|tp-&gt;snd_una
suffix:semicolon
id|__u32
id|packets_acked
suffix:semicolon
r_int
id|acked
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* If we get here, the whole TSO packet has not been&n;&t; * acked.&n;&t; */
id|BUG_ON
c_func
(paren
op_logical_neg
id|after
c_func
(paren
id|scb-&gt;end_seq
comma
id|seq
)paren
)paren
suffix:semicolon
id|packets_acked
op_assign
id|tcp_skb_pcount
c_func
(paren
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tcp_trim_head
c_func
(paren
id|sk
comma
id|skb
comma
id|seq
op_minus
id|scb-&gt;seq
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|packets_acked
op_sub_assign
id|tcp_skb_pcount
c_func
(paren
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|packets_acked
)paren
(brace
id|__u8
id|sacked
op_assign
id|scb-&gt;sacked
suffix:semicolon
id|acked
op_or_assign
id|FLAG_DATA_ACKED
suffix:semicolon
r_if
c_cond
(paren
id|sacked
)paren
(brace
r_if
c_cond
(paren
id|sacked
op_amp
id|TCPCB_RETRANS
)paren
(brace
r_if
c_cond
(paren
id|sacked
op_amp
id|TCPCB_SACKED_RETRANS
)paren
id|tp-&gt;retrans_out
op_sub_assign
id|packets_acked
suffix:semicolon
id|acked
op_or_assign
id|FLAG_RETRANS_DATA_ACKED
suffix:semicolon
op_star
id|seq_rtt
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_star
id|seq_rtt
OL
l_int|0
)paren
op_star
id|seq_rtt
op_assign
id|now
op_minus
id|scb-&gt;when
suffix:semicolon
r_if
c_cond
(paren
id|sacked
op_amp
id|TCPCB_SACKED_ACKED
)paren
id|tp-&gt;sacked_out
op_sub_assign
id|packets_acked
suffix:semicolon
r_if
c_cond
(paren
id|sacked
op_amp
id|TCPCB_LOST
)paren
id|tp-&gt;lost_out
op_sub_assign
id|packets_acked
suffix:semicolon
r_if
c_cond
(paren
id|sacked
op_amp
id|TCPCB_URG
)paren
(brace
r_if
c_cond
(paren
id|tp-&gt;urg_mode
op_logical_and
op_logical_neg
id|before
c_func
(paren
id|seq
comma
id|tp-&gt;snd_up
)paren
)paren
id|tp-&gt;urg_mode
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
op_star
id|seq_rtt
OL
l_int|0
)paren
op_star
id|seq_rtt
op_assign
id|now
op_minus
id|scb-&gt;when
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;fackets_out
)paren
(brace
id|__u32
id|dval
op_assign
id|min
c_func
(paren
id|tp-&gt;fackets_out
comma
id|packets_acked
)paren
suffix:semicolon
id|tp-&gt;fackets_out
op_sub_assign
id|dval
suffix:semicolon
)brace
id|tp-&gt;packets_out
op_sub_assign
id|packets_acked
suffix:semicolon
id|BUG_ON
c_func
(paren
id|tcp_skb_pcount
c_func
(paren
id|skb
)paren
op_eq
l_int|0
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|before
c_func
(paren
id|scb-&gt;seq
comma
id|scb-&gt;end_seq
)paren
)paren
suffix:semicolon
)brace
r_return
id|acked
suffix:semicolon
)brace
multiline_comment|/* Remove acknowledged frames from the retransmission queue. */
DECL|function|tcp_clean_rtx_queue
r_static
r_int
id|tcp_clean_rtx_queue
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
id|__s32
op_star
id|seq_rtt_p
)paren
(brace
r_struct
id|tcp_sock
op_star
id|tp
op_assign
id|tcp_sk
c_func
(paren
id|sk
)paren
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
id|__u32
id|now
op_assign
id|tcp_time_stamp
suffix:semicolon
r_int
id|acked
op_assign
l_int|0
suffix:semicolon
id|__s32
id|seq_rtt
op_assign
op_minus
l_int|1
suffix:semicolon
r_while
c_loop
(paren
(paren
id|skb
op_assign
id|skb_peek
c_func
(paren
op_amp
id|sk-&gt;sk_write_queue
)paren
)paren
op_logical_and
id|skb
op_ne
id|sk-&gt;sk_send_head
)paren
(brace
r_struct
id|tcp_skb_cb
op_star
id|scb
op_assign
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
suffix:semicolon
id|__u8
id|sacked
op_assign
id|scb-&gt;sacked
suffix:semicolon
multiline_comment|/* If our packet is before the ack sequence we can&n;&t;&t; * discard it as it&squot;s confirmed to have arrived at&n;&t;&t; * the other end.&n;&t;&t; */
r_if
c_cond
(paren
id|after
c_func
(paren
id|scb-&gt;end_seq
comma
id|tp-&gt;snd_una
)paren
)paren
(brace
r_if
c_cond
(paren
id|tcp_skb_pcount
c_func
(paren
id|skb
)paren
OG
l_int|1
)paren
id|acked
op_or_assign
id|tcp_tso_acked
c_func
(paren
id|sk
comma
id|skb
comma
id|now
comma
op_amp
id|seq_rtt
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Initial outgoing SYN&squot;s get put onto the write_queue&n;&t;&t; * just like anything else we transmit.  It is not&n;&t;&t; * true data, and if we misinform our callers that&n;&t;&t; * this ACK acks real data, we will erroneously exit&n;&t;&t; * connection startup slow start one packet too&n;&t;&t; * quickly.  This is severely frowned upon behavior.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|scb-&gt;flags
op_amp
id|TCPCB_FLAG_SYN
)paren
)paren
(brace
id|acked
op_or_assign
id|FLAG_DATA_ACKED
suffix:semicolon
)brace
r_else
(brace
id|acked
op_or_assign
id|FLAG_SYN_ACKED
suffix:semicolon
id|tp-&gt;retrans_stamp
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sacked
)paren
(brace
r_if
c_cond
(paren
id|sacked
op_amp
id|TCPCB_RETRANS
)paren
(brace
r_if
c_cond
(paren
id|sacked
op_amp
id|TCPCB_SACKED_RETRANS
)paren
(brace
id|tp-&gt;retrans_out
op_sub_assign
id|tcp_skb_pcount
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
id|acked
op_or_assign
id|FLAG_RETRANS_DATA_ACKED
suffix:semicolon
id|seq_rtt
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|seq_rtt
OL
l_int|0
)paren
id|seq_rtt
op_assign
id|now
op_minus
id|scb-&gt;when
suffix:semicolon
r_if
c_cond
(paren
id|sacked
op_amp
id|TCPCB_SACKED_ACKED
)paren
id|tp-&gt;sacked_out
op_sub_assign
id|tcp_skb_pcount
c_func
(paren
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sacked
op_amp
id|TCPCB_LOST
)paren
id|tp-&gt;lost_out
op_sub_assign
id|tcp_skb_pcount
c_func
(paren
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sacked
op_amp
id|TCPCB_URG
)paren
(brace
r_if
c_cond
(paren
id|tp-&gt;urg_mode
op_logical_and
op_logical_neg
id|before
c_func
(paren
id|scb-&gt;end_seq
comma
id|tp-&gt;snd_up
)paren
)paren
id|tp-&gt;urg_mode
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|seq_rtt
OL
l_int|0
)paren
id|seq_rtt
op_assign
id|now
op_minus
id|scb-&gt;when
suffix:semicolon
id|tcp_dec_pcount_approx
c_func
(paren
op_amp
id|tp-&gt;fackets_out
comma
id|skb
)paren
suffix:semicolon
id|tcp_packets_out_dec
c_func
(paren
id|tp
comma
id|skb
)paren
suffix:semicolon
id|__skb_unlink
c_func
(paren
id|skb
comma
id|skb-&gt;list
)paren
suffix:semicolon
id|sk_stream_free_skb
c_func
(paren
id|sk
comma
id|skb
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|acked
op_amp
id|FLAG_ACKED
)paren
(brace
id|tcp_ack_update_rtt
c_func
(paren
id|tp
comma
id|acked
comma
id|seq_rtt
)paren
suffix:semicolon
id|tcp_ack_packets_out
c_func
(paren
id|sk
comma
id|tp
)paren
suffix:semicolon
)brace
macro_line|#if FASTRETRANS_DEBUG &gt; 0
id|BUG_TRAP
c_func
(paren
(paren
r_int
)paren
id|tp-&gt;sacked_out
op_ge
l_int|0
)paren
suffix:semicolon
id|BUG_TRAP
c_func
(paren
(paren
r_int
)paren
id|tp-&gt;lost_out
op_ge
l_int|0
)paren
suffix:semicolon
id|BUG_TRAP
c_func
(paren
(paren
r_int
)paren
id|tp-&gt;retrans_out
op_ge
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tp-&gt;packets_out
op_logical_and
id|tp-&gt;sack_ok
)paren
(brace
r_if
c_cond
(paren
id|tp-&gt;lost_out
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Leak l=%u %d&bslash;n&quot;
comma
id|tp-&gt;lost_out
comma
id|tp-&gt;ca_state
)paren
suffix:semicolon
id|tp-&gt;lost_out
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tp-&gt;sacked_out
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Leak s=%u %d&bslash;n&quot;
comma
id|tp-&gt;sacked_out
comma
id|tp-&gt;ca_state
)paren
suffix:semicolon
id|tp-&gt;sacked_out
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tp-&gt;retrans_out
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Leak r=%u %d&bslash;n&quot;
comma
id|tp-&gt;retrans_out
comma
id|tp-&gt;ca_state
)paren
suffix:semicolon
id|tp-&gt;retrans_out
op_assign
l_int|0
suffix:semicolon
)brace
)brace
macro_line|#endif
op_star
id|seq_rtt_p
op_assign
id|seq_rtt
suffix:semicolon
r_return
id|acked
suffix:semicolon
)brace
DECL|function|tcp_ack_probe
r_static
r_void
id|tcp_ack_probe
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|tcp_sock
op_star
id|tp
op_assign
id|tcp_sk
c_func
(paren
id|sk
)paren
suffix:semicolon
multiline_comment|/* Was it a usable window open? */
r_if
c_cond
(paren
op_logical_neg
id|after
c_func
(paren
id|TCP_SKB_CB
c_func
(paren
id|sk-&gt;sk_send_head
)paren
op_member_access_from_pointer
id|end_seq
comma
id|tp-&gt;snd_una
op_plus
id|tp-&gt;snd_wnd
)paren
)paren
(brace
id|tp-&gt;backoff
op_assign
l_int|0
suffix:semicolon
id|tcp_clear_xmit_timer
c_func
(paren
id|sk
comma
id|TCP_TIME_PROBE0
)paren
suffix:semicolon
multiline_comment|/* Socket must be waked up by subsequent tcp_data_snd_check().&n;&t;&t; * This function is not for random using!&n;&t;&t; */
)brace
r_else
(brace
id|tcp_reset_xmit_timer
c_func
(paren
id|sk
comma
id|TCP_TIME_PROBE0
comma
id|min
c_func
(paren
id|tp-&gt;rto
op_lshift
id|tp-&gt;backoff
comma
id|TCP_RTO_MAX
)paren
)paren
suffix:semicolon
)brace
)brace
DECL|function|tcp_ack_is_dubious
r_static
r_inline
r_int
id|tcp_ack_is_dubious
c_func
(paren
r_struct
id|tcp_sock
op_star
id|tp
comma
r_int
id|flag
)paren
(brace
r_return
(paren
op_logical_neg
(paren
id|flag
op_amp
id|FLAG_NOT_DUP
)paren
op_logical_or
(paren
id|flag
op_amp
id|FLAG_CA_ALERT
)paren
op_logical_or
id|tp-&gt;ca_state
op_ne
id|TCP_CA_Open
)paren
suffix:semicolon
)brace
DECL|function|tcp_may_raise_cwnd
r_static
r_inline
r_int
id|tcp_may_raise_cwnd
c_func
(paren
r_struct
id|tcp_sock
op_star
id|tp
comma
r_int
id|flag
)paren
(brace
r_return
(paren
op_logical_neg
(paren
id|flag
op_amp
id|FLAG_ECE
)paren
op_logical_or
id|tp-&gt;snd_cwnd
OL
id|tp-&gt;snd_ssthresh
)paren
op_logical_and
op_logical_neg
(paren
(paren
l_int|1
op_lshift
id|tp-&gt;ca_state
)paren
op_amp
(paren
id|TCPF_CA_Recovery
op_or
id|TCPF_CA_CWR
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Check that window update is acceptable.&n; * The function assumes that snd_una&lt;=ack&lt;=snd_next.&n; */
DECL|function|tcp_may_update_window
r_static
r_inline
r_int
id|tcp_may_update_window
c_func
(paren
r_struct
id|tcp_sock
op_star
id|tp
comma
id|u32
id|ack
comma
id|u32
id|ack_seq
comma
id|u32
id|nwin
)paren
(brace
r_return
(paren
id|after
c_func
(paren
id|ack
comma
id|tp-&gt;snd_una
)paren
op_logical_or
id|after
c_func
(paren
id|ack_seq
comma
id|tp-&gt;snd_wl1
)paren
op_logical_or
(paren
id|ack_seq
op_eq
id|tp-&gt;snd_wl1
op_logical_and
id|nwin
OG
id|tp-&gt;snd_wnd
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Update our send window.&n; *&n; * Window update algorithm, described in RFC793/RFC1122 (used in linux-2.2&n; * and in FreeBSD. NetBSD&squot;s one is even worse.) is wrong.&n; */
DECL|function|tcp_ack_update_window
r_static
r_int
id|tcp_ack_update_window
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|tcp_sock
op_star
id|tp
comma
r_struct
id|sk_buff
op_star
id|skb
comma
id|u32
id|ack
comma
id|u32
id|ack_seq
)paren
(brace
r_int
id|flag
op_assign
l_int|0
suffix:semicolon
id|u32
id|nwin
op_assign
id|ntohs
c_func
(paren
id|skb-&gt;h.th-&gt;window
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
op_logical_neg
id|skb-&gt;h.th-&gt;syn
)paren
)paren
id|nwin
op_lshift_assign
id|tp-&gt;snd_wscale
suffix:semicolon
r_if
c_cond
(paren
id|tcp_may_update_window
c_func
(paren
id|tp
comma
id|ack
comma
id|ack_seq
comma
id|nwin
)paren
)paren
(brace
id|flag
op_or_assign
id|FLAG_WIN_UPDATE
suffix:semicolon
id|tcp_update_wl
c_func
(paren
id|tp
comma
id|ack
comma
id|ack_seq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;snd_wnd
op_ne
id|nwin
)paren
(brace
id|tp-&gt;snd_wnd
op_assign
id|nwin
suffix:semicolon
multiline_comment|/* Note, it is the only place, where&n;&t;&t;&t; * fast path is recovered for sending TCP.&n;&t;&t;&t; */
id|tcp_fast_path_check
c_func
(paren
id|sk
comma
id|tp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nwin
OG
id|tp-&gt;max_window
)paren
(brace
id|tp-&gt;max_window
op_assign
id|nwin
suffix:semicolon
id|tcp_sync_mss
c_func
(paren
id|sk
comma
id|tp-&gt;pmtu_cookie
)paren
suffix:semicolon
)brace
)brace
)brace
id|tp-&gt;snd_una
op_assign
id|ack
suffix:semicolon
r_return
id|flag
suffix:semicolon
)brace
DECL|function|tcp_process_frto
r_static
r_void
id|tcp_process_frto
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
id|u32
id|prior_snd_una
)paren
(brace
r_struct
id|tcp_sock
op_star
id|tp
op_assign
id|tcp_sk
c_func
(paren
id|sk
)paren
suffix:semicolon
id|tcp_sync_left_out
c_func
(paren
id|tp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;snd_una
op_eq
id|prior_snd_una
op_logical_or
op_logical_neg
id|before
c_func
(paren
id|tp-&gt;snd_una
comma
id|tp-&gt;frto_highmark
)paren
)paren
(brace
multiline_comment|/* RTO was caused by loss, start retransmitting in&n;&t;&t; * go-back-N slow start&n;&t;&t; */
id|tcp_enter_frto_loss
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tp-&gt;frto_counter
op_eq
l_int|1
)paren
(brace
multiline_comment|/* First ACK after RTO advances the window: allow two new&n;&t;&t; * segments out.&n;&t;&t; */
id|tp-&gt;snd_cwnd
op_assign
id|tcp_packets_in_flight
c_func
(paren
id|tp
)paren
op_plus
l_int|2
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Also the second ACK after RTO advances the window.&n;&t;&t; * The RTO was likely spurious. Reduce cwnd and continue&n;&t;&t; * in congestion avoidance&n;&t;&t; */
id|tp-&gt;snd_cwnd
op_assign
id|min
c_func
(paren
id|tp-&gt;snd_cwnd
comma
id|tp-&gt;snd_ssthresh
)paren
suffix:semicolon
id|tcp_moderate_cwnd
c_func
(paren
id|tp
)paren
suffix:semicolon
)brace
multiline_comment|/* F-RTO affects on two new ACKs following RTO.&n;&t; * At latest on third ACK the TCP behavor is back to normal.&n;&t; */
id|tp-&gt;frto_counter
op_assign
(paren
id|tp-&gt;frto_counter
op_plus
l_int|1
)paren
op_mod
l_int|3
suffix:semicolon
)brace
multiline_comment|/*&n; * TCP Westwood+&n; */
multiline_comment|/*&n; * @init_westwood&n; * This function initializes fields used in TCP Westwood+. We can&squot;t&n; * get no information about RTTmin at this time so we simply set it to&n; * TCP_WESTWOOD_INIT_RTT. This value was chosen to be too conservative&n; * since in this way we&squot;re sure it will be updated in a consistent&n; * way as soon as possible. It will reasonably happen within the first&n; * RTT period of the connection lifetime.&n; */
DECL|function|init_westwood
r_static
r_void
id|init_westwood
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|tcp_sock
op_star
id|tp
op_assign
id|tcp_sk
c_func
(paren
id|sk
)paren
suffix:semicolon
id|tp-&gt;westwood.bw_ns_est
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;westwood.bw_est
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;westwood.accounted
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;westwood.cumul_ack
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;westwood.rtt_win_sx
op_assign
id|tcp_time_stamp
suffix:semicolon
id|tp-&gt;westwood.rtt
op_assign
id|TCP_WESTWOOD_INIT_RTT
suffix:semicolon
id|tp-&gt;westwood.rtt_min
op_assign
id|TCP_WESTWOOD_INIT_RTT
suffix:semicolon
id|tp-&gt;westwood.snd_una
op_assign
id|tp-&gt;snd_una
suffix:semicolon
)brace
multiline_comment|/*&n; * @westwood_do_filter&n; * Low-pass filter. Implemented using constant coeffients.&n; */
DECL|function|westwood_do_filter
r_static
r_inline
id|__u32
id|westwood_do_filter
c_func
(paren
id|__u32
id|a
comma
id|__u32
id|b
)paren
(brace
r_return
(paren
(paren
(paren
l_int|7
op_star
id|a
)paren
op_plus
id|b
)paren
op_rshift
l_int|3
)paren
suffix:semicolon
)brace
DECL|function|westwood_filter
r_static
r_void
id|westwood_filter
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
id|__u32
id|delta
)paren
(brace
r_struct
id|tcp_sock
op_star
id|tp
op_assign
id|tcp_sk
c_func
(paren
id|sk
)paren
suffix:semicolon
id|tp-&gt;westwood.bw_ns_est
op_assign
id|westwood_do_filter
c_func
(paren
id|tp-&gt;westwood.bw_ns_est
comma
id|tp-&gt;westwood.bk
op_div
id|delta
)paren
suffix:semicolon
id|tp-&gt;westwood.bw_est
op_assign
id|westwood_do_filter
c_func
(paren
id|tp-&gt;westwood.bw_est
comma
id|tp-&gt;westwood.bw_ns_est
)paren
suffix:semicolon
)brace
multiline_comment|/* &n; * @westwood_update_rttmin&n; * It is used to update RTTmin. In this case we MUST NOT use&n; * WESTWOOD_RTT_MIN minimum bound since we could be on a LAN!&n; */
DECL|function|westwood_update_rttmin
r_static
r_inline
id|__u32
id|westwood_update_rttmin
c_func
(paren
r_const
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_const
r_struct
id|tcp_sock
op_star
id|tp
op_assign
id|tcp_sk
c_func
(paren
id|sk
)paren
suffix:semicolon
id|__u32
id|rttmin
op_assign
id|tp-&gt;westwood.rtt_min
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;westwood.rtt
op_ne
l_int|0
op_logical_and
(paren
id|tp-&gt;westwood.rtt
OL
id|tp-&gt;westwood.rtt_min
op_logical_or
op_logical_neg
id|rttmin
)paren
)paren
id|rttmin
op_assign
id|tp-&gt;westwood.rtt
suffix:semicolon
r_return
id|rttmin
suffix:semicolon
)brace
multiline_comment|/*&n; * @westwood_acked&n; * Evaluate increases for dk. &n; */
DECL|function|westwood_acked
r_static
r_inline
id|__u32
id|westwood_acked
c_func
(paren
r_const
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_const
r_struct
id|tcp_sock
op_star
id|tp
op_assign
id|tcp_sk
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
id|tp-&gt;snd_una
op_minus
id|tp-&gt;westwood.snd_una
suffix:semicolon
)brace
multiline_comment|/*&n; * @westwood_new_window&n; * It evaluates if we are receiving data inside the same RTT window as&n; * when we started.&n; * Return value:&n; * It returns 0 if we are still evaluating samples in the same RTT&n; * window, 1 if the sample has to be considered in the next window.&n; */
DECL|function|westwood_new_window
r_static
r_int
id|westwood_new_window
c_func
(paren
r_const
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_const
r_struct
id|tcp_sock
op_star
id|tp
op_assign
id|tcp_sk
c_func
(paren
id|sk
)paren
suffix:semicolon
id|__u32
id|left_bound
suffix:semicolon
id|__u32
id|rtt
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|left_bound
op_assign
id|tp-&gt;westwood.rtt_win_sx
suffix:semicolon
id|rtt
op_assign
id|max
c_func
(paren
id|tp-&gt;westwood.rtt
comma
(paren
id|u32
)paren
id|TCP_WESTWOOD_RTT_MIN
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * A RTT-window has passed. Be careful since if RTT is less than&n;&t; * 50ms we don&squot;t filter but we continue &squot;building the sample&squot;.&n;&t; * This minimum limit was choosen since an estimation on small&n;&t; * time intervals is better to avoid...&n;&t; * Obvioulsy on a LAN we reasonably will always have&n;&t; * right_bound = left_bound + WESTWOOD_RTT_MIN&n;         */
r_if
c_cond
(paren
(paren
id|left_bound
op_plus
id|rtt
)paren
OL
id|tcp_time_stamp
)paren
id|ret
op_assign
l_int|1
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * @westwood_update_window&n; * It updates RTT evaluation window if it is the right moment to do&n; * it. If so it calls filter for evaluating bandwidth. &n; */
DECL|function|__westwood_update_window
r_static
r_void
id|__westwood_update_window
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
id|__u32
id|now
)paren
(brace
r_struct
id|tcp_sock
op_star
id|tp
op_assign
id|tcp_sk
c_func
(paren
id|sk
)paren
suffix:semicolon
id|__u32
id|delta
op_assign
id|now
op_minus
id|tp-&gt;westwood.rtt_win_sx
suffix:semicolon
r_if
c_cond
(paren
id|delta
)paren
(brace
r_if
c_cond
(paren
id|tp-&gt;westwood.rtt
)paren
id|westwood_filter
c_func
(paren
id|sk
comma
id|delta
)paren
suffix:semicolon
id|tp-&gt;westwood.bk
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;westwood.rtt_win_sx
op_assign
id|tcp_time_stamp
suffix:semicolon
)brace
)brace
DECL|function|westwood_update_window
r_static
r_void
id|westwood_update_window
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
id|__u32
id|now
)paren
(brace
r_if
c_cond
(paren
id|westwood_new_window
c_func
(paren
id|sk
)paren
)paren
id|__westwood_update_window
c_func
(paren
id|sk
comma
id|now
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * @__tcp_westwood_fast_bw&n; * It is called when we are in fast path. In particular it is called when&n; * header prediction is successfull. In such case infact update is&n; * straight forward and doesn&squot;t need any particular care.&n; */
DECL|function|__tcp_westwood_fast_bw
r_static
r_void
id|__tcp_westwood_fast_bw
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|tcp_sock
op_star
id|tp
op_assign
id|tcp_sk
c_func
(paren
id|sk
)paren
suffix:semicolon
id|westwood_update_window
c_func
(paren
id|sk
comma
id|tcp_time_stamp
)paren
suffix:semicolon
id|tp-&gt;westwood.bk
op_add_assign
id|westwood_acked
c_func
(paren
id|sk
)paren
suffix:semicolon
id|tp-&gt;westwood.snd_una
op_assign
id|tp-&gt;snd_una
suffix:semicolon
id|tp-&gt;westwood.rtt_min
op_assign
id|westwood_update_rttmin
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
DECL|function|tcp_westwood_fast_bw
r_static
r_inline
r_void
id|tcp_westwood_fast_bw
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_if
c_cond
(paren
id|tcp_is_westwood
c_func
(paren
id|tcp_sk
c_func
(paren
id|sk
)paren
)paren
)paren
id|__tcp_westwood_fast_bw
c_func
(paren
id|sk
comma
id|skb
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * @westwood_dupack_update&n; * It updates accounted and cumul_ack when receiving a dupack.&n; */
DECL|function|westwood_dupack_update
r_static
r_void
id|westwood_dupack_update
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|tcp_sock
op_star
id|tp
op_assign
id|tcp_sk
c_func
(paren
id|sk
)paren
suffix:semicolon
id|tp-&gt;westwood.accounted
op_add_assign
id|tp-&gt;mss_cache_std
suffix:semicolon
id|tp-&gt;westwood.cumul_ack
op_assign
id|tp-&gt;mss_cache_std
suffix:semicolon
)brace
DECL|function|westwood_may_change_cumul
r_static
r_inline
r_int
id|westwood_may_change_cumul
c_func
(paren
r_struct
id|tcp_sock
op_star
id|tp
)paren
(brace
r_return
(paren
id|tp-&gt;westwood.cumul_ack
OG
id|tp-&gt;mss_cache_std
)paren
suffix:semicolon
)brace
DECL|function|westwood_partial_update
r_static
r_inline
r_void
id|westwood_partial_update
c_func
(paren
r_struct
id|tcp_sock
op_star
id|tp
)paren
(brace
id|tp-&gt;westwood.accounted
op_sub_assign
id|tp-&gt;westwood.cumul_ack
suffix:semicolon
id|tp-&gt;westwood.cumul_ack
op_assign
id|tp-&gt;mss_cache_std
suffix:semicolon
)brace
DECL|function|westwood_complete_update
r_static
r_inline
r_void
id|westwood_complete_update
c_func
(paren
r_struct
id|tcp_sock
op_star
id|tp
)paren
(brace
id|tp-&gt;westwood.cumul_ack
op_sub_assign
id|tp-&gt;westwood.accounted
suffix:semicolon
id|tp-&gt;westwood.accounted
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * @westwood_acked_count&n; * This function evaluates cumul_ack for evaluating dk in case of&n; * delayed or partial acks.&n; */
DECL|function|westwood_acked_count
r_static
r_inline
id|__u32
id|westwood_acked_count
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|tcp_sock
op_star
id|tp
op_assign
id|tcp_sk
c_func
(paren
id|sk
)paren
suffix:semicolon
id|tp-&gt;westwood.cumul_ack
op_assign
id|westwood_acked
c_func
(paren
id|sk
)paren
suffix:semicolon
multiline_comment|/* If cumul_ack is 0 this is a dupack since it&squot;s not moving&n;         * tp-&gt;snd_una.&n;         */
r_if
c_cond
(paren
op_logical_neg
(paren
id|tp-&gt;westwood.cumul_ack
)paren
)paren
id|westwood_dupack_update
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|westwood_may_change_cumul
c_func
(paren
id|tp
)paren
)paren
(brace
multiline_comment|/* Partial or delayed ack */
r_if
c_cond
(paren
id|tp-&gt;westwood.accounted
op_ge
id|tp-&gt;westwood.cumul_ack
)paren
id|westwood_partial_update
c_func
(paren
id|tp
)paren
suffix:semicolon
r_else
id|westwood_complete_update
c_func
(paren
id|tp
)paren
suffix:semicolon
)brace
id|tp-&gt;westwood.snd_una
op_assign
id|tp-&gt;snd_una
suffix:semicolon
r_return
id|tp-&gt;westwood.cumul_ack
suffix:semicolon
)brace
multiline_comment|/*&n; * @__tcp_westwood_slow_bw&n; * It is called when something is going wrong..even if there could&n; * be no problems! Infact a simple delayed packet may trigger a&n; * dupack. But we need to be careful in such case.&n; */
DECL|function|__tcp_westwood_slow_bw
r_static
r_void
id|__tcp_westwood_slow_bw
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|tcp_sock
op_star
id|tp
op_assign
id|tcp_sk
c_func
(paren
id|sk
)paren
suffix:semicolon
id|westwood_update_window
c_func
(paren
id|sk
comma
id|tcp_time_stamp
)paren
suffix:semicolon
id|tp-&gt;westwood.bk
op_add_assign
id|westwood_acked_count
c_func
(paren
id|sk
)paren
suffix:semicolon
id|tp-&gt;westwood.rtt_min
op_assign
id|westwood_update_rttmin
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
DECL|function|tcp_westwood_slow_bw
r_static
r_inline
r_void
id|tcp_westwood_slow_bw
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_if
c_cond
(paren
id|tcp_is_westwood
c_func
(paren
id|tcp_sk
c_func
(paren
id|sk
)paren
)paren
)paren
id|__tcp_westwood_slow_bw
c_func
(paren
id|sk
comma
id|skb
)paren
suffix:semicolon
)brace
multiline_comment|/* This routine deals with incoming acks, but not outgoing ones. */
DECL|function|tcp_ack
r_static
r_int
id|tcp_ack
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|flag
)paren
(brace
r_struct
id|tcp_sock
op_star
id|tp
op_assign
id|tcp_sk
c_func
(paren
id|sk
)paren
suffix:semicolon
id|u32
id|prior_snd_una
op_assign
id|tp-&gt;snd_una
suffix:semicolon
id|u32
id|ack_seq
op_assign
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
suffix:semicolon
id|u32
id|ack
op_assign
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|ack_seq
suffix:semicolon
id|u32
id|prior_in_flight
suffix:semicolon
id|s32
id|seq_rtt
suffix:semicolon
r_int
id|prior_packets
suffix:semicolon
multiline_comment|/* If the ack is newer than sent or older than previous acks&n;&t; * then we can probably ignore it.&n;&t; */
r_if
c_cond
(paren
id|after
c_func
(paren
id|ack
comma
id|tp-&gt;snd_nxt
)paren
)paren
r_goto
id|uninteresting_ack
suffix:semicolon
r_if
c_cond
(paren
id|before
c_func
(paren
id|ack
comma
id|prior_snd_una
)paren
)paren
r_goto
id|old_ack
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|flag
op_amp
id|FLAG_SLOWPATH
)paren
op_logical_and
id|after
c_func
(paren
id|ack
comma
id|prior_snd_una
)paren
)paren
(brace
multiline_comment|/* Window is constant, pure forward advance.&n;&t;&t; * No more checks are required.&n;&t;&t; * Note, we use the fact that SND.UNA&gt;=SND.WL2.&n;&t;&t; */
id|tcp_update_wl
c_func
(paren
id|tp
comma
id|ack
comma
id|ack_seq
)paren
suffix:semicolon
id|tp-&gt;snd_una
op_assign
id|ack
suffix:semicolon
id|tcp_westwood_fast_bw
c_func
(paren
id|sk
comma
id|skb
)paren
suffix:semicolon
id|flag
op_or_assign
id|FLAG_WIN_UPDATE
suffix:semicolon
id|NET_INC_STATS_BH
c_func
(paren
id|LINUX_MIB_TCPHPACKS
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|ack_seq
op_ne
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
)paren
id|flag
op_or_assign
id|FLAG_DATA
suffix:semicolon
r_else
id|NET_INC_STATS_BH
c_func
(paren
id|LINUX_MIB_TCPPUREACKS
)paren
suffix:semicolon
id|flag
op_or_assign
id|tcp_ack_update_window
c_func
(paren
id|sk
comma
id|tp
comma
id|skb
comma
id|ack
comma
id|ack_seq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|sacked
)paren
id|flag
op_or_assign
id|tcp_sacktag_write_queue
c_func
(paren
id|sk
comma
id|skb
comma
id|prior_snd_una
)paren
suffix:semicolon
r_if
c_cond
(paren
id|TCP_ECN_rcv_ecn_echo
c_func
(paren
id|tp
comma
id|skb-&gt;h.th
)paren
)paren
id|flag
op_or_assign
id|FLAG_ECE
suffix:semicolon
id|tcp_westwood_slow_bw
c_func
(paren
id|sk
comma
id|skb
)paren
suffix:semicolon
)brace
multiline_comment|/* We passed data and got it acked, remove any soft error&n;&t; * log. Something worked...&n;&t; */
id|sk-&gt;sk_err_soft
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;rcv_tstamp
op_assign
id|tcp_time_stamp
suffix:semicolon
id|prior_packets
op_assign
id|tp-&gt;packets_out
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|prior_packets
)paren
r_goto
id|no_queue
suffix:semicolon
id|prior_in_flight
op_assign
id|tcp_packets_in_flight
c_func
(paren
id|tp
)paren
suffix:semicolon
multiline_comment|/* See if we can take anything off of the retransmit queue. */
id|flag
op_or_assign
id|tcp_clean_rtx_queue
c_func
(paren
id|sk
comma
op_amp
id|seq_rtt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;frto_counter
)paren
id|tcp_process_frto
c_func
(paren
id|sk
comma
id|prior_snd_una
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tcp_ack_is_dubious
c_func
(paren
id|tp
comma
id|flag
)paren
)paren
(brace
multiline_comment|/* Advanve CWND, if state allows this. */
r_if
c_cond
(paren
(paren
id|flag
op_amp
id|FLAG_DATA_ACKED
)paren
op_logical_and
(paren
id|tcp_vegas_enabled
c_func
(paren
id|tp
)paren
op_logical_or
id|prior_in_flight
op_ge
id|tp-&gt;snd_cwnd
)paren
op_logical_and
id|tcp_may_raise_cwnd
c_func
(paren
id|tp
comma
id|flag
)paren
)paren
id|tcp_cong_avoid
c_func
(paren
id|tp
comma
id|ack
comma
id|seq_rtt
)paren
suffix:semicolon
id|tcp_fastretrans_alert
c_func
(paren
id|sk
comma
id|prior_snd_una
comma
id|prior_packets
comma
id|flag
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
(paren
id|flag
op_amp
id|FLAG_DATA_ACKED
)paren
op_logical_and
(paren
id|tcp_vegas_enabled
c_func
(paren
id|tp
)paren
op_logical_or
id|prior_in_flight
op_ge
id|tp-&gt;snd_cwnd
)paren
)paren
id|tcp_cong_avoid
c_func
(paren
id|tp
comma
id|ack
comma
id|seq_rtt
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|flag
op_amp
id|FLAG_FORWARD_PROGRESS
)paren
op_logical_or
op_logical_neg
(paren
id|flag
op_amp
id|FLAG_NOT_DUP
)paren
)paren
id|dst_confirm
c_func
(paren
id|sk-&gt;sk_dst_cache
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
id|no_queue
suffix:colon
id|tp-&gt;probes_out
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* If this ack opens up a zero window, clear backoff.  It was&n;&t; * being used to time the probes, and is probably far higher than&n;&t; * it needs to be for normal retransmission.&n;&t; */
r_if
c_cond
(paren
id|sk-&gt;sk_send_head
)paren
id|tcp_ack_probe
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
id|old_ack
suffix:colon
r_if
c_cond
(paren
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|sacked
)paren
id|tcp_sacktag_write_queue
c_func
(paren
id|sk
comma
id|skb
comma
id|prior_snd_una
)paren
suffix:semicolon
id|uninteresting_ack
suffix:colon
id|SOCK_DEBUG
c_func
(paren
id|sk
comma
l_string|&quot;Ack %u out of %u:%u&bslash;n&quot;
comma
id|ack
comma
id|tp-&gt;snd_una
comma
id|tp-&gt;snd_nxt
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Look for tcp options. Normally only called on SYN and SYNACK packets.&n; * But, this can also be called on packets in the established flow when&n; * the fast version below fails.&n; */
DECL|function|tcp_parse_options
r_void
id|tcp_parse_options
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|tcp_sock
op_star
id|tp
comma
r_int
id|estab
)paren
(brace
r_int
r_char
op_star
id|ptr
suffix:semicolon
r_struct
id|tcphdr
op_star
id|th
op_assign
id|skb-&gt;h.th
suffix:semicolon
r_int
id|length
op_assign
(paren
id|th-&gt;doff
op_star
l_int|4
)paren
op_minus
r_sizeof
(paren
r_struct
id|tcphdr
)paren
suffix:semicolon
id|ptr
op_assign
(paren
r_int
r_char
op_star
)paren
(paren
id|th
op_plus
l_int|1
)paren
suffix:semicolon
id|tp-&gt;saw_tstamp
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|length
OG
l_int|0
)paren
(brace
r_int
id|opcode
op_assign
op_star
id|ptr
op_increment
suffix:semicolon
r_int
id|opsize
suffix:semicolon
r_switch
c_cond
(paren
id|opcode
)paren
(brace
r_case
id|TCPOPT_EOL
suffix:colon
r_return
suffix:semicolon
r_case
id|TCPOPT_NOP
suffix:colon
multiline_comment|/* Ref: RFC 793 section 3.1 */
id|length
op_decrement
suffix:semicolon
r_continue
suffix:semicolon
r_default
suffix:colon
id|opsize
op_assign
op_star
id|ptr
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|opsize
OL
l_int|2
)paren
multiline_comment|/* &quot;silly options&quot; */
r_return
suffix:semicolon
r_if
c_cond
(paren
id|opsize
OG
id|length
)paren
r_return
suffix:semicolon
multiline_comment|/* don&squot;t parse partial options */
r_switch
c_cond
(paren
id|opcode
)paren
(brace
r_case
id|TCPOPT_MSS
suffix:colon
r_if
c_cond
(paren
id|opsize
op_eq
id|TCPOLEN_MSS
op_logical_and
id|th-&gt;syn
op_logical_and
op_logical_neg
id|estab
)paren
(brace
id|u16
id|in_mss
op_assign
id|ntohs
c_func
(paren
op_star
(paren
id|__u16
op_star
)paren
id|ptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|in_mss
)paren
(brace
r_if
c_cond
(paren
id|tp-&gt;user_mss
op_logical_and
id|tp-&gt;user_mss
OL
id|in_mss
)paren
id|in_mss
op_assign
id|tp-&gt;user_mss
suffix:semicolon
id|tp-&gt;mss_clamp
op_assign
id|in_mss
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
r_case
id|TCPOPT_WINDOW
suffix:colon
r_if
c_cond
(paren
id|opsize
op_eq
id|TCPOLEN_WINDOW
op_logical_and
id|th-&gt;syn
op_logical_and
op_logical_neg
id|estab
)paren
r_if
c_cond
(paren
id|sysctl_tcp_window_scaling
)paren
(brace
id|tp-&gt;wscale_ok
op_assign
l_int|1
suffix:semicolon
id|tp-&gt;snd_wscale
op_assign
op_star
(paren
id|__u8
op_star
)paren
id|ptr
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;snd_wscale
OG
l_int|14
)paren
(brace
r_if
c_cond
(paren
id|net_ratelimit
c_func
(paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;tcp_parse_options: Illegal window &quot;
l_string|&quot;scaling value %d &gt;14 received.&bslash;n&quot;
comma
id|tp-&gt;snd_wscale
)paren
suffix:semicolon
)brace
id|tp-&gt;snd_wscale
op_assign
l_int|14
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
r_case
id|TCPOPT_TIMESTAMP
suffix:colon
r_if
c_cond
(paren
id|opsize
op_eq
id|TCPOLEN_TIMESTAMP
)paren
(brace
r_if
c_cond
(paren
(paren
id|estab
op_logical_and
id|tp-&gt;tstamp_ok
)paren
op_logical_or
(paren
op_logical_neg
id|estab
op_logical_and
id|sysctl_tcp_timestamps
)paren
)paren
(brace
id|tp-&gt;saw_tstamp
op_assign
l_int|1
suffix:semicolon
id|tp-&gt;rcv_tsval
op_assign
id|ntohl
c_func
(paren
op_star
(paren
id|__u32
op_star
)paren
id|ptr
)paren
suffix:semicolon
id|tp-&gt;rcv_tsecr
op_assign
id|ntohl
c_func
(paren
op_star
(paren
id|__u32
op_star
)paren
(paren
id|ptr
op_plus
l_int|4
)paren
)paren
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
r_case
id|TCPOPT_SACK_PERM
suffix:colon
r_if
c_cond
(paren
id|opsize
op_eq
id|TCPOLEN_SACK_PERM
op_logical_and
id|th-&gt;syn
op_logical_and
op_logical_neg
id|estab
)paren
(brace
r_if
c_cond
(paren
id|sysctl_tcp_sack
)paren
(brace
id|tp-&gt;sack_ok
op_assign
l_int|1
suffix:semicolon
id|tcp_sack_reset
c_func
(paren
id|tp
)paren
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
r_case
id|TCPOPT_SACK
suffix:colon
r_if
c_cond
(paren
(paren
id|opsize
op_ge
(paren
id|TCPOLEN_SACK_BASE
op_plus
id|TCPOLEN_SACK_PERBLOCK
)paren
)paren
op_logical_and
op_logical_neg
(paren
(paren
id|opsize
op_minus
id|TCPOLEN_SACK_BASE
)paren
op_mod
id|TCPOLEN_SACK_PERBLOCK
)paren
op_logical_and
id|tp-&gt;sack_ok
)paren
(brace
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|sacked
op_assign
(paren
id|ptr
op_minus
l_int|2
)paren
op_minus
(paren
r_int
r_char
op_star
)paren
id|th
suffix:semicolon
)brace
)brace
suffix:semicolon
id|ptr
op_add_assign
id|opsize
op_minus
l_int|2
suffix:semicolon
id|length
op_sub_assign
id|opsize
suffix:semicolon
)brace
suffix:semicolon
)brace
)brace
multiline_comment|/* Fast parse options. This hopes to only see timestamps.&n; * If it is wrong it falls back on tcp_parse_options().&n; */
DECL|function|tcp_fast_parse_options
r_static
r_inline
r_int
id|tcp_fast_parse_options
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|tcphdr
op_star
id|th
comma
r_struct
id|tcp_sock
op_star
id|tp
)paren
(brace
r_if
c_cond
(paren
id|th-&gt;doff
op_eq
r_sizeof
(paren
r_struct
id|tcphdr
)paren
op_rshift
l_int|2
)paren
(brace
id|tp-&gt;saw_tstamp
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|tp-&gt;tstamp_ok
op_logical_and
id|th-&gt;doff
op_eq
(paren
r_sizeof
(paren
r_struct
id|tcphdr
)paren
op_rshift
l_int|2
)paren
op_plus
(paren
id|TCPOLEN_TSTAMP_ALIGNED
op_rshift
l_int|2
)paren
)paren
(brace
id|__u32
op_star
id|ptr
op_assign
(paren
id|__u32
op_star
)paren
(paren
id|th
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|ptr
op_eq
id|ntohl
c_func
(paren
(paren
id|TCPOPT_NOP
op_lshift
l_int|24
)paren
op_or
(paren
id|TCPOPT_NOP
op_lshift
l_int|16
)paren
op_or
(paren
id|TCPOPT_TIMESTAMP
op_lshift
l_int|8
)paren
op_or
id|TCPOLEN_TIMESTAMP
)paren
)paren
(brace
id|tp-&gt;saw_tstamp
op_assign
l_int|1
suffix:semicolon
op_increment
id|ptr
suffix:semicolon
id|tp-&gt;rcv_tsval
op_assign
id|ntohl
c_func
(paren
op_star
id|ptr
)paren
suffix:semicolon
op_increment
id|ptr
suffix:semicolon
id|tp-&gt;rcv_tsecr
op_assign
id|ntohl
c_func
(paren
op_star
id|ptr
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
id|tcp_parse_options
c_func
(paren
id|skb
comma
id|tp
comma
l_int|1
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|tcp_store_ts_recent
r_static
r_inline
r_void
id|tcp_store_ts_recent
c_func
(paren
r_struct
id|tcp_sock
op_star
id|tp
)paren
(brace
id|tp-&gt;ts_recent
op_assign
id|tp-&gt;rcv_tsval
suffix:semicolon
id|tp-&gt;ts_recent_stamp
op_assign
id|xtime.tv_sec
suffix:semicolon
)brace
DECL|function|tcp_replace_ts_recent
r_static
r_inline
r_void
id|tcp_replace_ts_recent
c_func
(paren
r_struct
id|tcp_sock
op_star
id|tp
comma
id|u32
id|seq
)paren
(brace
r_if
c_cond
(paren
id|tp-&gt;saw_tstamp
op_logical_and
op_logical_neg
id|after
c_func
(paren
id|seq
comma
id|tp-&gt;rcv_wup
)paren
)paren
(brace
multiline_comment|/* PAWS bug workaround wrt. ACK frames, the PAWS discard&n;&t;&t; * extra check below makes sure this can only happen&n;&t;&t; * for pure ACK frames.  -DaveM&n;&t;&t; *&n;&t;&t; * Not only, also it occurs for expired timestamps.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|s32
)paren
(paren
id|tp-&gt;rcv_tsval
op_minus
id|tp-&gt;ts_recent
)paren
op_ge
l_int|0
op_logical_or
id|xtime.tv_sec
op_ge
id|tp-&gt;ts_recent_stamp
op_plus
id|TCP_PAWS_24DAYS
)paren
(brace
id|tcp_store_ts_recent
c_func
(paren
id|tp
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Sorry, PAWS as specified is broken wrt. pure-ACKs -DaveM&n; *&n; * It is not fatal. If this ACK does _not_ change critical state (seqs, window)&n; * it can pass through stack. So, the following predicate verifies that&n; * this segment is not used for anything but congestion avoidance or&n; * fast retransmit. Moreover, we even are able to eliminate most of such&n; * second order effects, if we apply some small &quot;replay&quot; window (~RTO)&n; * to timestamp space.&n; *&n; * All these measures still do not guarantee that we reject wrapped ACKs&n; * on networks with high bandwidth, when sequence space is recycled fastly,&n; * but it guarantees that such events will be very rare and do not affect&n; * connection seriously. This doesn&squot;t look nice, but alas, PAWS is really&n; * buggy extension.&n; *&n; * [ Later note. Even worse! It is buggy for segments _with_ data. RFC&n; * states that events when retransmit arrives after original data are rare.&n; * It is a blatant lie. VJ forgot about fast retransmit! 8)8) It is&n; * the biggest problem on large power networks even with minor reordering.&n; * OK, let&squot;s give it small replay window. If peer clock is even 1hz, it is safe&n; * up to bandwidth of 18Gigabit/sec. 8) ]&n; */
DECL|function|tcp_disordered_ack
r_static
r_int
id|tcp_disordered_ack
c_func
(paren
r_struct
id|tcp_sock
op_star
id|tp
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|tcphdr
op_star
id|th
op_assign
id|skb-&gt;h.th
suffix:semicolon
id|u32
id|seq
op_assign
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
suffix:semicolon
id|u32
id|ack
op_assign
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|ack_seq
suffix:semicolon
r_return
(paren
multiline_comment|/* 1. Pure ACK with correct sequence number. */
(paren
id|th-&gt;ack
op_logical_and
id|seq
op_eq
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
op_logical_and
id|seq
op_eq
id|tp-&gt;rcv_nxt
)paren
op_logical_and
multiline_comment|/* 2. ... and duplicate ACK. */
id|ack
op_eq
id|tp-&gt;snd_una
op_logical_and
multiline_comment|/* 3. ... and does not update window. */
op_logical_neg
id|tcp_may_update_window
c_func
(paren
id|tp
comma
id|ack
comma
id|seq
comma
id|ntohs
c_func
(paren
id|th-&gt;window
)paren
op_lshift
id|tp-&gt;snd_wscale
)paren
op_logical_and
multiline_comment|/* 4. ... and sits in replay window. */
(paren
id|s32
)paren
(paren
id|tp-&gt;ts_recent
op_minus
id|tp-&gt;rcv_tsval
)paren
op_le
(paren
id|tp-&gt;rto
op_star
l_int|1024
)paren
op_div
id|HZ
)paren
suffix:semicolon
)brace
DECL|function|tcp_paws_discard
r_static
r_inline
r_int
id|tcp_paws_discard
c_func
(paren
r_struct
id|tcp_sock
op_star
id|tp
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_return
(paren
(paren
id|s32
)paren
(paren
id|tp-&gt;ts_recent
op_minus
id|tp-&gt;rcv_tsval
)paren
OG
id|TCP_PAWS_WINDOW
op_logical_and
id|xtime.tv_sec
OL
id|tp-&gt;ts_recent_stamp
op_plus
id|TCP_PAWS_24DAYS
op_logical_and
op_logical_neg
id|tcp_disordered_ack
c_func
(paren
id|tp
comma
id|skb
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Check segment sequence number for validity.&n; *&n; * Segment controls are considered valid, if the segment&n; * fits to the window after truncation to the window. Acceptability&n; * of data (and SYN, FIN, of course) is checked separately.&n; * See tcp_data_queue(), for example.&n; *&n; * Also, controls (RST is main one) are accepted using RCV.WUP instead&n; * of RCV.NXT. Peer still did not advance his SND.UNA when we&n; * delayed ACK, so that hisSND.UNA&lt;=ourRCV.WUP.&n; * (borrowed from freebsd)&n; */
DECL|function|tcp_sequence
r_static
r_inline
r_int
id|tcp_sequence
c_func
(paren
r_struct
id|tcp_sock
op_star
id|tp
comma
id|u32
id|seq
comma
id|u32
id|end_seq
)paren
(brace
r_return
op_logical_neg
id|before
c_func
(paren
id|end_seq
comma
id|tp-&gt;rcv_wup
)paren
op_logical_and
op_logical_neg
id|after
c_func
(paren
id|seq
comma
id|tp-&gt;rcv_nxt
op_plus
id|tcp_receive_window
c_func
(paren
id|tp
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* When we get a reset we do this. */
DECL|function|tcp_reset
r_static
r_void
id|tcp_reset
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
multiline_comment|/* We want the right error as BSD sees it (and indeed as we do). */
r_switch
c_cond
(paren
id|sk-&gt;sk_state
)paren
(brace
r_case
id|TCP_SYN_SENT
suffix:colon
id|sk-&gt;sk_err
op_assign
id|ECONNREFUSED
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TCP_CLOSE_WAIT
suffix:colon
id|sk-&gt;sk_err
op_assign
id|EPIPE
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TCP_CLOSE
suffix:colon
r_return
suffix:semicolon
r_default
suffix:colon
id|sk-&gt;sk_err
op_assign
id|ECONNRESET
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|sock_flag
c_func
(paren
id|sk
comma
id|SOCK_DEAD
)paren
)paren
id|sk
op_member_access_from_pointer
id|sk_error_report
c_func
(paren
id|sk
)paren
suffix:semicolon
id|tcp_done
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * &t;Process the FIN bit. This now behaves as it is supposed to work&n; *&t;and the FIN takes effect when it is validly part of sequence&n; *&t;space. Not before when we get holes.&n; *&n; *&t;If we are ESTABLISHED, a received fin moves us to CLOSE-WAIT&n; *&t;(and thence onto LAST-ACK and finally, CLOSE, we never enter&n; *&t;TIME-WAIT)&n; *&n; *&t;If we are in FINWAIT-1, a received FIN indicates simultaneous&n; *&t;close and we go into CLOSING (and later onto TIME-WAIT)&n; *&n; *&t;If we are in FINWAIT-2, a received FIN moves us to TIME-WAIT.&n; */
DECL|function|tcp_fin
r_static
r_void
id|tcp_fin
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|tcphdr
op_star
id|th
)paren
(brace
r_struct
id|tcp_sock
op_star
id|tp
op_assign
id|tcp_sk
c_func
(paren
id|sk
)paren
suffix:semicolon
id|tcp_schedule_ack
c_func
(paren
id|tp
)paren
suffix:semicolon
id|sk-&gt;sk_shutdown
op_or_assign
id|RCV_SHUTDOWN
suffix:semicolon
id|sock_set_flag
c_func
(paren
id|sk
comma
id|SOCK_DONE
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|sk-&gt;sk_state
)paren
(brace
r_case
id|TCP_SYN_RECV
suffix:colon
r_case
id|TCP_ESTABLISHED
suffix:colon
multiline_comment|/* Move to CLOSE_WAIT */
id|tcp_set_state
c_func
(paren
id|sk
comma
id|TCP_CLOSE_WAIT
)paren
suffix:semicolon
id|tp-&gt;ack.pingpong
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TCP_CLOSE_WAIT
suffix:colon
r_case
id|TCP_CLOSING
suffix:colon
multiline_comment|/* Received a retransmission of the FIN, do&n;&t;&t;&t; * nothing.&n;&t;&t;&t; */
r_break
suffix:semicolon
r_case
id|TCP_LAST_ACK
suffix:colon
multiline_comment|/* RFC793: Remain in the LAST-ACK state. */
r_break
suffix:semicolon
r_case
id|TCP_FIN_WAIT1
suffix:colon
multiline_comment|/* This case occurs when a simultaneous close&n;&t;&t;&t; * happens, we must ack the received FIN and&n;&t;&t;&t; * enter the CLOSING state.&n;&t;&t;&t; */
id|tcp_send_ack
c_func
(paren
id|sk
)paren
suffix:semicolon
id|tcp_set_state
c_func
(paren
id|sk
comma
id|TCP_CLOSING
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TCP_FIN_WAIT2
suffix:colon
multiline_comment|/* Received a FIN -- send ACK and enter TIME_WAIT. */
id|tcp_send_ack
c_func
(paren
id|sk
)paren
suffix:semicolon
id|tcp_time_wait
c_func
(paren
id|sk
comma
id|TCP_TIME_WAIT
comma
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* Only TCP_LISTEN and TCP_CLOSE are left, in these&n;&t;&t;&t; * cases we should never reach this piece of code.&n;&t;&t;&t; */
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: Impossible, sk-&gt;sk_state=%d&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|sk-&gt;sk_state
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* It _is_ possible, that we have something out-of-order _after_ FIN.&n;&t; * Probably, we should reset in this case. For now drop them.&n;&t; */
id|__skb_queue_purge
c_func
(paren
op_amp
id|tp-&gt;out_of_order_queue
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;sack_ok
)paren
id|tcp_sack_reset
c_func
(paren
id|tp
)paren
suffix:semicolon
id|sk_stream_mem_reclaim
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sock_flag
c_func
(paren
id|sk
comma
id|SOCK_DEAD
)paren
)paren
(brace
id|sk
op_member_access_from_pointer
id|sk_state_change
c_func
(paren
id|sk
)paren
suffix:semicolon
multiline_comment|/* Do not send POLL_HUP for half duplex close. */
r_if
c_cond
(paren
id|sk-&gt;sk_shutdown
op_eq
id|SHUTDOWN_MASK
op_logical_or
id|sk-&gt;sk_state
op_eq
id|TCP_CLOSE
)paren
id|sk_wake_async
c_func
(paren
id|sk
comma
l_int|1
comma
id|POLL_HUP
)paren
suffix:semicolon
r_else
id|sk_wake_async
c_func
(paren
id|sk
comma
l_int|1
comma
id|POLL_IN
)paren
suffix:semicolon
)brace
)brace
r_static
id|__inline__
r_int
DECL|function|tcp_sack_extend
id|tcp_sack_extend
c_func
(paren
r_struct
id|tcp_sack_block
op_star
id|sp
comma
id|u32
id|seq
comma
id|u32
id|end_seq
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|after
c_func
(paren
id|seq
comma
id|sp-&gt;end_seq
)paren
op_logical_and
op_logical_neg
id|after
c_func
(paren
id|sp-&gt;start_seq
comma
id|end_seq
)paren
)paren
(brace
r_if
c_cond
(paren
id|before
c_func
(paren
id|seq
comma
id|sp-&gt;start_seq
)paren
)paren
id|sp-&gt;start_seq
op_assign
id|seq
suffix:semicolon
r_if
c_cond
(paren
id|after
c_func
(paren
id|end_seq
comma
id|sp-&gt;end_seq
)paren
)paren
id|sp-&gt;end_seq
op_assign
id|end_seq
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|tcp_dsack_set
r_static
r_inline
r_void
id|tcp_dsack_set
c_func
(paren
r_struct
id|tcp_sock
op_star
id|tp
comma
id|u32
id|seq
comma
id|u32
id|end_seq
)paren
(brace
r_if
c_cond
(paren
id|tp-&gt;sack_ok
op_logical_and
id|sysctl_tcp_dsack
)paren
(brace
r_if
c_cond
(paren
id|before
c_func
(paren
id|seq
comma
id|tp-&gt;rcv_nxt
)paren
)paren
id|NET_INC_STATS_BH
c_func
(paren
id|LINUX_MIB_TCPDSACKOLDSENT
)paren
suffix:semicolon
r_else
id|NET_INC_STATS_BH
c_func
(paren
id|LINUX_MIB_TCPDSACKOFOSENT
)paren
suffix:semicolon
id|tp-&gt;dsack
op_assign
l_int|1
suffix:semicolon
id|tp-&gt;duplicate_sack
(braket
l_int|0
)braket
dot
id|start_seq
op_assign
id|seq
suffix:semicolon
id|tp-&gt;duplicate_sack
(braket
l_int|0
)braket
dot
id|end_seq
op_assign
id|end_seq
suffix:semicolon
id|tp-&gt;eff_sacks
op_assign
id|min
c_func
(paren
id|tp-&gt;num_sacks
op_plus
l_int|1
comma
l_int|4
op_minus
id|tp-&gt;tstamp_ok
)paren
suffix:semicolon
)brace
)brace
DECL|function|tcp_dsack_extend
r_static
r_inline
r_void
id|tcp_dsack_extend
c_func
(paren
r_struct
id|tcp_sock
op_star
id|tp
comma
id|u32
id|seq
comma
id|u32
id|end_seq
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|tp-&gt;dsack
)paren
id|tcp_dsack_set
c_func
(paren
id|tp
comma
id|seq
comma
id|end_seq
)paren
suffix:semicolon
r_else
id|tcp_sack_extend
c_func
(paren
id|tp-&gt;duplicate_sack
comma
id|seq
comma
id|end_seq
)paren
suffix:semicolon
)brace
DECL|function|tcp_send_dupack
r_static
r_void
id|tcp_send_dupack
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|tcp_sock
op_star
id|tp
op_assign
id|tcp_sk
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
op_ne
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
op_logical_and
id|before
c_func
(paren
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
comma
id|tp-&gt;rcv_nxt
)paren
)paren
(brace
id|NET_INC_STATS_BH
c_func
(paren
id|LINUX_MIB_DELAYEDACKLOST
)paren
suffix:semicolon
id|tcp_enter_quickack_mode
c_func
(paren
id|tp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;sack_ok
op_logical_and
id|sysctl_tcp_dsack
)paren
(brace
id|u32
id|end_seq
op_assign
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
suffix:semicolon
r_if
c_cond
(paren
id|after
c_func
(paren
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
comma
id|tp-&gt;rcv_nxt
)paren
)paren
id|end_seq
op_assign
id|tp-&gt;rcv_nxt
suffix:semicolon
id|tcp_dsack_set
c_func
(paren
id|tp
comma
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
comma
id|end_seq
)paren
suffix:semicolon
)brace
)brace
id|tcp_send_ack
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
multiline_comment|/* These routines update the SACK block as out-of-order packets arrive or&n; * in-order packets close up the sequence space.&n; */
DECL|function|tcp_sack_maybe_coalesce
r_static
r_void
id|tcp_sack_maybe_coalesce
c_func
(paren
r_struct
id|tcp_sock
op_star
id|tp
)paren
(brace
r_int
id|this_sack
suffix:semicolon
r_struct
id|tcp_sack_block
op_star
id|sp
op_assign
op_amp
id|tp-&gt;selective_acks
(braket
l_int|0
)braket
suffix:semicolon
r_struct
id|tcp_sack_block
op_star
id|swalk
op_assign
id|sp
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* See if the recent change to the first SACK eats into&n;&t; * or hits the sequence space of other SACK blocks, if so coalesce.&n;&t; */
r_for
c_loop
(paren
id|this_sack
op_assign
l_int|1
suffix:semicolon
id|this_sack
OL
id|tp-&gt;num_sacks
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
id|tcp_sack_extend
c_func
(paren
id|sp
comma
id|swalk-&gt;start_seq
comma
id|swalk-&gt;end_seq
)paren
)paren
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/* Zap SWALK, by moving every further SACK up by one slot.&n;&t;&t;&t; * Decrease num_sacks.&n;&t;&t;&t; */
id|tp-&gt;num_sacks
op_decrement
suffix:semicolon
id|tp-&gt;eff_sacks
op_assign
id|min
c_func
(paren
id|tp-&gt;num_sacks
op_plus
id|tp-&gt;dsack
comma
l_int|4
op_minus
id|tp-&gt;tstamp_ok
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|this_sack
suffix:semicolon
id|i
OL
id|tp-&gt;num_sacks
suffix:semicolon
id|i
op_increment
)paren
(brace
id|sp
(braket
id|i
)braket
op_assign
id|sp
(braket
id|i
op_plus
l_int|1
)braket
suffix:semicolon
)brace
r_continue
suffix:semicolon
)brace
id|this_sack
op_increment
comma
id|swalk
op_increment
suffix:semicolon
)brace
)brace
DECL|function|tcp_sack_swap
r_static
id|__inline__
r_void
id|tcp_sack_swap
c_func
(paren
r_struct
id|tcp_sack_block
op_star
id|sack1
comma
r_struct
id|tcp_sack_block
op_star
id|sack2
)paren
(brace
id|__u32
id|tmp
suffix:semicolon
id|tmp
op_assign
id|sack1-&gt;start_seq
suffix:semicolon
id|sack1-&gt;start_seq
op_assign
id|sack2-&gt;start_seq
suffix:semicolon
id|sack2-&gt;start_seq
op_assign
id|tmp
suffix:semicolon
id|tmp
op_assign
id|sack1-&gt;end_seq
suffix:semicolon
id|sack1-&gt;end_seq
op_assign
id|sack2-&gt;end_seq
suffix:semicolon
id|sack2-&gt;end_seq
op_assign
id|tmp
suffix:semicolon
)brace
DECL|function|tcp_sack_new_ofo_skb
r_static
r_void
id|tcp_sack_new_ofo_skb
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
id|u32
id|seq
comma
id|u32
id|end_seq
)paren
(brace
r_struct
id|tcp_sock
op_star
id|tp
op_assign
id|tcp_sk
c_func
(paren
id|sk
)paren
suffix:semicolon
r_struct
id|tcp_sack_block
op_star
id|sp
op_assign
op_amp
id|tp-&gt;selective_acks
(braket
l_int|0
)braket
suffix:semicolon
r_int
id|cur_sacks
op_assign
id|tp-&gt;num_sacks
suffix:semicolon
r_int
id|this_sack
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cur_sacks
)paren
r_goto
id|new_sack
suffix:semicolon
r_for
c_loop
(paren
id|this_sack
op_assign
l_int|0
suffix:semicolon
id|this_sack
OL
id|cur_sacks
suffix:semicolon
id|this_sack
op_increment
comma
id|sp
op_increment
)paren
(brace
r_if
c_cond
(paren
id|tcp_sack_extend
c_func
(paren
id|sp
comma
id|seq
comma
id|end_seq
)paren
)paren
(brace
multiline_comment|/* Rotate this_sack to the first one. */
r_for
c_loop
(paren
suffix:semicolon
id|this_sack
OG
l_int|0
suffix:semicolon
id|this_sack
op_decrement
comma
id|sp
op_decrement
)paren
id|tcp_sack_swap
c_func
(paren
id|sp
comma
id|sp
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cur_sacks
OG
l_int|1
)paren
id|tcp_sack_maybe_coalesce
c_func
(paren
id|tp
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
multiline_comment|/* Could not find an adjacent existing SACK, build a new one,&n;&t; * put it at the front, and shift everyone else down.  We&n;&t; * always know there is at least one SACK present already here.&n;&t; *&n;&t; * If the sack array is full, forget about the last one.&n;&t; */
r_if
c_cond
(paren
id|this_sack
op_ge
l_int|4
)paren
(brace
id|this_sack
op_decrement
suffix:semicolon
id|tp-&gt;num_sacks
op_decrement
suffix:semicolon
id|sp
op_decrement
suffix:semicolon
)brace
r_for
c_loop
(paren
suffix:semicolon
id|this_sack
OG
l_int|0
suffix:semicolon
id|this_sack
op_decrement
comma
id|sp
op_decrement
)paren
(brace
op_star
id|sp
op_assign
op_star
(paren
id|sp
op_minus
l_int|1
)paren
suffix:semicolon
)brace
id|new_sack
suffix:colon
multiline_comment|/* Build the new head SACK, and we&squot;re done. */
id|sp-&gt;start_seq
op_assign
id|seq
suffix:semicolon
id|sp-&gt;end_seq
op_assign
id|end_seq
suffix:semicolon
id|tp-&gt;num_sacks
op_increment
suffix:semicolon
id|tp-&gt;eff_sacks
op_assign
id|min
c_func
(paren
id|tp-&gt;num_sacks
op_plus
id|tp-&gt;dsack
comma
l_int|4
op_minus
id|tp-&gt;tstamp_ok
)paren
suffix:semicolon
)brace
multiline_comment|/* RCV.NXT advances, some SACKs should be eaten. */
DECL|function|tcp_sack_remove
r_static
r_void
id|tcp_sack_remove
c_func
(paren
r_struct
id|tcp_sock
op_star
id|tp
)paren
(brace
r_struct
id|tcp_sack_block
op_star
id|sp
op_assign
op_amp
id|tp-&gt;selective_acks
(braket
l_int|0
)braket
suffix:semicolon
r_int
id|num_sacks
op_assign
id|tp-&gt;num_sacks
suffix:semicolon
r_int
id|this_sack
suffix:semicolon
multiline_comment|/* Empty ofo queue, hence, all the SACKs are eaten. Clear. */
r_if
c_cond
(paren
id|skb_queue_len
c_func
(paren
op_amp
id|tp-&gt;out_of_order_queue
)paren
op_eq
l_int|0
)paren
(brace
id|tp-&gt;num_sacks
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;eff_sacks
op_assign
id|tp-&gt;dsack
suffix:semicolon
r_return
suffix:semicolon
)brace
r_for
c_loop
(paren
id|this_sack
op_assign
l_int|0
suffix:semicolon
id|this_sack
OL
id|num_sacks
suffix:semicolon
)paren
(brace
multiline_comment|/* Check if the start of the sack is covered by RCV.NXT. */
r_if
c_cond
(paren
op_logical_neg
id|before
c_func
(paren
id|tp-&gt;rcv_nxt
comma
id|sp-&gt;start_seq
)paren
)paren
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/* RCV.NXT must cover all the block! */
id|BUG_TRAP
c_func
(paren
op_logical_neg
id|before
c_func
(paren
id|tp-&gt;rcv_nxt
comma
id|sp-&gt;end_seq
)paren
)paren
suffix:semicolon
multiline_comment|/* Zap this SACK, by moving forward any other SACKS. */
r_for
c_loop
(paren
id|i
op_assign
id|this_sack
op_plus
l_int|1
suffix:semicolon
id|i
OL
id|num_sacks
suffix:semicolon
id|i
op_increment
)paren
id|tp-&gt;selective_acks
(braket
id|i
op_minus
l_int|1
)braket
op_assign
id|tp-&gt;selective_acks
(braket
id|i
)braket
suffix:semicolon
id|num_sacks
op_decrement
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|this_sack
op_increment
suffix:semicolon
id|sp
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|num_sacks
op_ne
id|tp-&gt;num_sacks
)paren
(brace
id|tp-&gt;num_sacks
op_assign
id|num_sacks
suffix:semicolon
id|tp-&gt;eff_sacks
op_assign
id|min
c_func
(paren
id|tp-&gt;num_sacks
op_plus
id|tp-&gt;dsack
comma
l_int|4
op_minus
id|tp-&gt;tstamp_ok
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* This one checks to see if we can put data from the&n; * out_of_order queue into the receive_queue.&n; */
DECL|function|tcp_ofo_queue
r_static
r_void
id|tcp_ofo_queue
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|tcp_sock
op_star
id|tp
op_assign
id|tcp_sk
c_func
(paren
id|sk
)paren
suffix:semicolon
id|__u32
id|dsack_high
op_assign
id|tp-&gt;rcv_nxt
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_while
c_loop
(paren
(paren
id|skb
op_assign
id|skb_peek
c_func
(paren
op_amp
id|tp-&gt;out_of_order_queue
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|after
c_func
(paren
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
comma
id|tp-&gt;rcv_nxt
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|before
c_func
(paren
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
comma
id|dsack_high
)paren
)paren
(brace
id|__u32
id|dsack
op_assign
id|dsack_high
suffix:semicolon
r_if
c_cond
(paren
id|before
c_func
(paren
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
comma
id|dsack_high
)paren
)paren
id|dsack_high
op_assign
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
suffix:semicolon
id|tcp_dsack_extend
c_func
(paren
id|tp
comma
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
comma
id|dsack
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|after
c_func
(paren
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
comma
id|tp-&gt;rcv_nxt
)paren
)paren
(brace
id|SOCK_DEBUG
c_func
(paren
id|sk
comma
l_string|&quot;ofo packet was already received &bslash;n&quot;
)paren
suffix:semicolon
id|__skb_unlink
c_func
(paren
id|skb
comma
id|skb-&gt;list
)paren
suffix:semicolon
id|__kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|SOCK_DEBUG
c_func
(paren
id|sk
comma
l_string|&quot;ofo requeuing : rcv_next %X seq %X - %X&bslash;n&quot;
comma
id|tp-&gt;rcv_nxt
comma
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
comma
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
)paren
suffix:semicolon
id|__skb_unlink
c_func
(paren
id|skb
comma
id|skb-&gt;list
)paren
suffix:semicolon
id|__skb_queue_tail
c_func
(paren
op_amp
id|sk-&gt;sk_receive_queue
comma
id|skb
)paren
suffix:semicolon
id|tp-&gt;rcv_nxt
op_assign
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
suffix:semicolon
r_if
c_cond
(paren
id|skb-&gt;h.th-&gt;fin
)paren
(brace
id|tcp_fin
c_func
(paren
id|skb
comma
id|sk
comma
id|skb-&gt;h.th
)paren
suffix:semicolon
)brace
)brace
)brace
r_static
r_int
id|tcp_prune_queue
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
suffix:semicolon
DECL|function|tcp_data_queue
r_static
r_void
id|tcp_data_queue
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|tcphdr
op_star
id|th
op_assign
id|skb-&gt;h.th
suffix:semicolon
r_struct
id|tcp_sock
op_star
id|tp
op_assign
id|tcp_sk
c_func
(paren
id|sk
)paren
suffix:semicolon
r_int
id|eaten
op_assign
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
op_eq
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
)paren
r_goto
id|drop
suffix:semicolon
id|th
op_assign
id|skb-&gt;h.th
suffix:semicolon
id|__skb_pull
c_func
(paren
id|skb
comma
id|th-&gt;doff
op_star
l_int|4
)paren
suffix:semicolon
id|TCP_ECN_accept_cwr
c_func
(paren
id|tp
comma
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;dsack
)paren
(brace
id|tp-&gt;dsack
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;eff_sacks
op_assign
id|min_t
c_func
(paren
r_int
r_int
comma
id|tp-&gt;num_sacks
comma
l_int|4
op_minus
id|tp-&gt;tstamp_ok
)paren
suffix:semicolon
)brace
multiline_comment|/*  Queue data for delivery to the user.&n;&t; *  Packets in sequence go to the receive queue.&n;&t; *  Out of sequence packets to the out_of_order_queue.&n;&t; */
r_if
c_cond
(paren
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
op_eq
id|tp-&gt;rcv_nxt
)paren
(brace
r_if
c_cond
(paren
id|tcp_receive_window
c_func
(paren
id|tp
)paren
op_eq
l_int|0
)paren
r_goto
id|out_of_window
suffix:semicolon
multiline_comment|/* Ok. In sequence. In window. */
r_if
c_cond
(paren
id|tp-&gt;ucopy.task
op_eq
id|current
op_logical_and
id|tp-&gt;copied_seq
op_eq
id|tp-&gt;rcv_nxt
op_logical_and
id|tp-&gt;ucopy.len
op_logical_and
id|sock_owned_by_user
c_func
(paren
id|sk
)paren
op_logical_and
op_logical_neg
id|tp-&gt;urg_data
)paren
(brace
r_int
id|chunk
op_assign
id|min_t
c_func
(paren
r_int
r_int
comma
id|skb-&gt;len
comma
id|tp-&gt;ucopy.len
)paren
suffix:semicolon
id|__set_current_state
c_func
(paren
id|TASK_RUNNING
)paren
suffix:semicolon
id|local_bh_enable
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skb_copy_datagram_iovec
c_func
(paren
id|skb
comma
l_int|0
comma
id|tp-&gt;ucopy.iov
comma
id|chunk
)paren
)paren
(brace
id|tp-&gt;ucopy.len
op_sub_assign
id|chunk
suffix:semicolon
id|tp-&gt;copied_seq
op_add_assign
id|chunk
suffix:semicolon
id|eaten
op_assign
(paren
id|chunk
op_eq
id|skb-&gt;len
op_logical_and
op_logical_neg
id|th-&gt;fin
)paren
suffix:semicolon
id|tcp_rcv_space_adjust
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
id|local_bh_disable
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|eaten
op_le
l_int|0
)paren
(brace
id|queue_and_out
suffix:colon
r_if
c_cond
(paren
id|eaten
OL
l_int|0
op_logical_and
(paren
id|atomic_read
c_func
(paren
op_amp
id|sk-&gt;sk_rmem_alloc
)paren
OG
id|sk-&gt;sk_rcvbuf
op_logical_or
op_logical_neg
id|sk_stream_rmem_schedule
c_func
(paren
id|sk
comma
id|skb
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|tcp_prune_queue
c_func
(paren
id|sk
)paren
OL
l_int|0
op_logical_or
op_logical_neg
id|sk_stream_rmem_schedule
c_func
(paren
id|sk
comma
id|skb
)paren
)paren
r_goto
id|drop
suffix:semicolon
)brace
id|sk_stream_set_owner_r
c_func
(paren
id|skb
comma
id|sk
)paren
suffix:semicolon
id|__skb_queue_tail
c_func
(paren
op_amp
id|sk-&gt;sk_receive_queue
comma
id|skb
)paren
suffix:semicolon
)brace
id|tp-&gt;rcv_nxt
op_assign
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
suffix:semicolon
r_if
c_cond
(paren
id|skb-&gt;len
)paren
(brace
id|tcp_event_data_recv
c_func
(paren
id|sk
comma
id|tp
comma
id|skb
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|th-&gt;fin
)paren
(brace
id|tcp_fin
c_func
(paren
id|skb
comma
id|sk
comma
id|th
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|skb_queue_len
c_func
(paren
op_amp
id|tp-&gt;out_of_order_queue
)paren
)paren
(brace
id|tcp_ofo_queue
c_func
(paren
id|sk
)paren
suffix:semicolon
multiline_comment|/* RFC2581. 4.2. SHOULD send immediate ACK, when&n;&t;&t;&t; * gap in queue is filled.&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|skb_queue_len
c_func
(paren
op_amp
id|tp-&gt;out_of_order_queue
)paren
)paren
id|tp-&gt;ack.pingpong
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tp-&gt;num_sacks
)paren
id|tcp_sack_remove
c_func
(paren
id|tp
)paren
suffix:semicolon
id|tcp_fast_path_check
c_func
(paren
id|sk
comma
id|tp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|eaten
OG
l_int|0
)paren
id|__kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|sock_flag
c_func
(paren
id|sk
comma
id|SOCK_DEAD
)paren
)paren
id|sk
op_member_access_from_pointer
id|sk_data_ready
c_func
(paren
id|sk
comma
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|after
c_func
(paren
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
comma
id|tp-&gt;rcv_nxt
)paren
)paren
(brace
multiline_comment|/* A retransmit, 2nd most common case.  Force an immediate ack. */
id|NET_INC_STATS_BH
c_func
(paren
id|LINUX_MIB_DELAYEDACKLOST
)paren
suffix:semicolon
id|tcp_dsack_set
c_func
(paren
id|tp
comma
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
comma
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
)paren
suffix:semicolon
id|out_of_window
suffix:colon
id|tcp_enter_quickack_mode
c_func
(paren
id|tp
)paren
suffix:semicolon
id|tcp_schedule_ack
c_func
(paren
id|tp
)paren
suffix:semicolon
id|drop
suffix:colon
id|__kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Out of window. F.e. zero window probe. */
r_if
c_cond
(paren
op_logical_neg
id|before
c_func
(paren
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
comma
id|tp-&gt;rcv_nxt
op_plus
id|tcp_receive_window
c_func
(paren
id|tp
)paren
)paren
)paren
r_goto
id|out_of_window
suffix:semicolon
id|tcp_enter_quickack_mode
c_func
(paren
id|tp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|before
c_func
(paren
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
comma
id|tp-&gt;rcv_nxt
)paren
)paren
(brace
multiline_comment|/* Partial packet, seq &lt; rcv_next &lt; end_seq */
id|SOCK_DEBUG
c_func
(paren
id|sk
comma
l_string|&quot;partial packet: rcv_next %X seq %X - %X&bslash;n&quot;
comma
id|tp-&gt;rcv_nxt
comma
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
comma
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
)paren
suffix:semicolon
id|tcp_dsack_set
c_func
(paren
id|tp
comma
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
comma
id|tp-&gt;rcv_nxt
)paren
suffix:semicolon
multiline_comment|/* If window is closed, drop tail of packet. But after&n;&t;&t; * remembering D-SACK for its head made in previous line.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|tcp_receive_window
c_func
(paren
id|tp
)paren
)paren
r_goto
id|out_of_window
suffix:semicolon
r_goto
id|queue_and_out
suffix:semicolon
)brace
id|TCP_ECN_check_ce
c_func
(paren
id|tp
comma
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|sk-&gt;sk_rmem_alloc
)paren
OG
id|sk-&gt;sk_rcvbuf
op_logical_or
op_logical_neg
id|sk_stream_rmem_schedule
c_func
(paren
id|sk
comma
id|skb
)paren
)paren
(brace
r_if
c_cond
(paren
id|tcp_prune_queue
c_func
(paren
id|sk
)paren
OL
l_int|0
op_logical_or
op_logical_neg
id|sk_stream_rmem_schedule
c_func
(paren
id|sk
comma
id|skb
)paren
)paren
r_goto
id|drop
suffix:semicolon
)brace
multiline_comment|/* Disable header prediction. */
id|tp-&gt;pred_flags
op_assign
l_int|0
suffix:semicolon
id|tcp_schedule_ack
c_func
(paren
id|tp
)paren
suffix:semicolon
id|SOCK_DEBUG
c_func
(paren
id|sk
comma
l_string|&quot;out of order segment: rcv_next %X seq %X - %X&bslash;n&quot;
comma
id|tp-&gt;rcv_nxt
comma
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
comma
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
)paren
suffix:semicolon
id|sk_stream_set_owner_r
c_func
(paren
id|skb
comma
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skb_peek
c_func
(paren
op_amp
id|tp-&gt;out_of_order_queue
)paren
)paren
(brace
multiline_comment|/* Initial out of order segment, build 1 SACK. */
r_if
c_cond
(paren
id|tp-&gt;sack_ok
)paren
(brace
id|tp-&gt;num_sacks
op_assign
l_int|1
suffix:semicolon
id|tp-&gt;dsack
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;eff_sacks
op_assign
l_int|1
suffix:semicolon
id|tp-&gt;selective_acks
(braket
l_int|0
)braket
dot
id|start_seq
op_assign
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
suffix:semicolon
id|tp-&gt;selective_acks
(braket
l_int|0
)braket
dot
id|end_seq
op_assign
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
suffix:semicolon
)brace
id|__skb_queue_head
c_func
(paren
op_amp
id|tp-&gt;out_of_order_queue
comma
id|skb
)paren
suffix:semicolon
)brace
r_else
(brace
r_struct
id|sk_buff
op_star
id|skb1
op_assign
id|tp-&gt;out_of_order_queue.prev
suffix:semicolon
id|u32
id|seq
op_assign
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
suffix:semicolon
id|u32
id|end_seq
op_assign
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
suffix:semicolon
r_if
c_cond
(paren
id|seq
op_eq
id|TCP_SKB_CB
c_func
(paren
id|skb1
)paren
op_member_access_from_pointer
id|end_seq
)paren
(brace
id|__skb_append
c_func
(paren
id|skb1
comma
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tp-&gt;num_sacks
op_logical_or
id|tp-&gt;selective_acks
(braket
l_int|0
)braket
dot
id|end_seq
op_ne
id|seq
)paren
r_goto
id|add_sack
suffix:semicolon
multiline_comment|/* Common case: data arrive in order after hole. */
id|tp-&gt;selective_acks
(braket
l_int|0
)braket
dot
id|end_seq
op_assign
id|end_seq
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Find place to insert this segment. */
r_do
(brace
r_if
c_cond
(paren
op_logical_neg
id|after
c_func
(paren
id|TCP_SKB_CB
c_func
(paren
id|skb1
)paren
op_member_access_from_pointer
id|seq
comma
id|seq
)paren
)paren
r_break
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|skb1
op_assign
id|skb1-&gt;prev
)paren
op_ne
(paren
r_struct
id|sk_buff
op_star
)paren
op_amp
id|tp-&gt;out_of_order_queue
)paren
suffix:semicolon
multiline_comment|/* Do skb overlap to previous one? */
r_if
c_cond
(paren
id|skb1
op_ne
(paren
r_struct
id|sk_buff
op_star
)paren
op_amp
id|tp-&gt;out_of_order_queue
op_logical_and
id|before
c_func
(paren
id|seq
comma
id|TCP_SKB_CB
c_func
(paren
id|skb1
)paren
op_member_access_from_pointer
id|end_seq
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|after
c_func
(paren
id|end_seq
comma
id|TCP_SKB_CB
c_func
(paren
id|skb1
)paren
op_member_access_from_pointer
id|end_seq
)paren
)paren
(brace
multiline_comment|/* All the bits are present. Drop. */
id|__kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
id|tcp_dsack_set
c_func
(paren
id|tp
comma
id|seq
comma
id|end_seq
)paren
suffix:semicolon
r_goto
id|add_sack
suffix:semicolon
)brace
r_if
c_cond
(paren
id|after
c_func
(paren
id|seq
comma
id|TCP_SKB_CB
c_func
(paren
id|skb1
)paren
op_member_access_from_pointer
id|seq
)paren
)paren
(brace
multiline_comment|/* Partial overlap. */
id|tcp_dsack_set
c_func
(paren
id|tp
comma
id|seq
comma
id|TCP_SKB_CB
c_func
(paren
id|skb1
)paren
op_member_access_from_pointer
id|end_seq
)paren
suffix:semicolon
)brace
r_else
(brace
id|skb1
op_assign
id|skb1-&gt;prev
suffix:semicolon
)brace
)brace
id|__skb_insert
c_func
(paren
id|skb
comma
id|skb1
comma
id|skb1-&gt;next
comma
op_amp
id|tp-&gt;out_of_order_queue
)paren
suffix:semicolon
multiline_comment|/* And clean segments covered by new one as whole. */
r_while
c_loop
(paren
(paren
id|skb1
op_assign
id|skb-&gt;next
)paren
op_ne
(paren
r_struct
id|sk_buff
op_star
)paren
op_amp
id|tp-&gt;out_of_order_queue
op_logical_and
id|after
c_func
(paren
id|end_seq
comma
id|TCP_SKB_CB
c_func
(paren
id|skb1
)paren
op_member_access_from_pointer
id|seq
)paren
)paren
(brace
r_if
c_cond
(paren
id|before
c_func
(paren
id|end_seq
comma
id|TCP_SKB_CB
c_func
(paren
id|skb1
)paren
op_member_access_from_pointer
id|end_seq
)paren
)paren
(brace
id|tcp_dsack_extend
c_func
(paren
id|tp
comma
id|TCP_SKB_CB
c_func
(paren
id|skb1
)paren
op_member_access_from_pointer
id|seq
comma
id|end_seq
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|__skb_unlink
c_func
(paren
id|skb1
comma
id|skb1-&gt;list
)paren
suffix:semicolon
id|tcp_dsack_extend
c_func
(paren
id|tp
comma
id|TCP_SKB_CB
c_func
(paren
id|skb1
)paren
op_member_access_from_pointer
id|seq
comma
id|TCP_SKB_CB
c_func
(paren
id|skb1
)paren
op_member_access_from_pointer
id|end_seq
)paren
suffix:semicolon
id|__kfree_skb
c_func
(paren
id|skb1
)paren
suffix:semicolon
)brace
id|add_sack
suffix:colon
r_if
c_cond
(paren
id|tp-&gt;sack_ok
)paren
id|tcp_sack_new_ofo_skb
c_func
(paren
id|sk
comma
id|seq
comma
id|end_seq
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Collapse contiguous sequence of skbs head..tail with&n; * sequence numbers start..end.&n; * Segments with FIN/SYN are not collapsed (only because this&n; * simplifies code)&n; */
r_static
r_void
DECL|function|tcp_collapse
id|tcp_collapse
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|head
comma
r_struct
id|sk_buff
op_star
id|tail
comma
id|u32
id|start
comma
id|u32
id|end
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
multiline_comment|/* First, check that queue is collapsable and find&n;&t; * the point where collapsing can be useful. */
r_for
c_loop
(paren
id|skb
op_assign
id|head
suffix:semicolon
id|skb
op_ne
id|tail
suffix:semicolon
)paren
(brace
multiline_comment|/* No new bits? It is possible on ofo queue. */
r_if
c_cond
(paren
op_logical_neg
id|before
c_func
(paren
id|start
comma
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
)paren
)paren
(brace
r_struct
id|sk_buff
op_star
id|next
op_assign
id|skb-&gt;next
suffix:semicolon
id|__skb_unlink
c_func
(paren
id|skb
comma
id|skb-&gt;list
)paren
suffix:semicolon
id|__kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
id|NET_INC_STATS_BH
c_func
(paren
id|LINUX_MIB_TCPRCVCOLLAPSED
)paren
suffix:semicolon
id|skb
op_assign
id|next
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* The first skb to collapse is:&n;&t;&t; * - not SYN/FIN and&n;&t;&t; * - bloated or contains data before &quot;start&quot; or&n;&t;&t; *   overlaps to the next one.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|skb-&gt;h.th-&gt;syn
op_logical_and
op_logical_neg
id|skb-&gt;h.th-&gt;fin
op_logical_and
(paren
id|tcp_win_from_space
c_func
(paren
id|skb-&gt;truesize
)paren
OG
id|skb-&gt;len
op_logical_or
id|before
c_func
(paren
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
comma
id|start
)paren
op_logical_or
(paren
id|skb-&gt;next
op_ne
id|tail
op_logical_and
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
op_ne
id|TCP_SKB_CB
c_func
(paren
id|skb-&gt;next
)paren
op_member_access_from_pointer
id|seq
)paren
)paren
)paren
r_break
suffix:semicolon
multiline_comment|/* Decided to skip this, advance start seq. */
id|start
op_assign
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
suffix:semicolon
id|skb
op_assign
id|skb-&gt;next
suffix:semicolon
)brace
r_if
c_cond
(paren
id|skb
op_eq
id|tail
op_logical_or
id|skb-&gt;h.th-&gt;syn
op_logical_or
id|skb-&gt;h.th-&gt;fin
)paren
r_return
suffix:semicolon
r_while
c_loop
(paren
id|before
c_func
(paren
id|start
comma
id|end
)paren
)paren
(brace
r_struct
id|sk_buff
op_star
id|nskb
suffix:semicolon
r_int
id|header
op_assign
id|skb_headroom
c_func
(paren
id|skb
)paren
suffix:semicolon
r_int
id|copy
op_assign
(paren
id|PAGE_SIZE
op_minus
r_sizeof
(paren
r_struct
id|sk_buff
)paren
op_minus
r_sizeof
(paren
r_struct
id|skb_shared_info
)paren
op_minus
id|header
op_minus
l_int|31
)paren
op_amp
op_complement
l_int|15
suffix:semicolon
multiline_comment|/* Too big header? This can happen with IPv6. */
r_if
c_cond
(paren
id|copy
OL
l_int|0
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|end
op_minus
id|start
OL
id|copy
)paren
id|copy
op_assign
id|end
op_minus
id|start
suffix:semicolon
id|nskb
op_assign
id|alloc_skb
c_func
(paren
id|copy
op_plus
id|header
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|nskb
)paren
r_return
suffix:semicolon
id|skb_reserve
c_func
(paren
id|nskb
comma
id|header
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|nskb-&gt;head
comma
id|skb-&gt;head
comma
id|header
)paren
suffix:semicolon
id|nskb-&gt;nh.raw
op_assign
id|nskb-&gt;head
op_plus
(paren
id|skb-&gt;nh.raw
op_minus
id|skb-&gt;head
)paren
suffix:semicolon
id|nskb-&gt;h.raw
op_assign
id|nskb-&gt;head
op_plus
(paren
id|skb-&gt;h.raw
op_minus
id|skb-&gt;head
)paren
suffix:semicolon
id|nskb-&gt;mac.raw
op_assign
id|nskb-&gt;head
op_plus
(paren
id|skb-&gt;mac.raw
op_minus
id|skb-&gt;head
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|nskb-&gt;cb
comma
id|skb-&gt;cb
comma
r_sizeof
(paren
id|skb-&gt;cb
)paren
)paren
suffix:semicolon
id|TCP_SKB_CB
c_func
(paren
id|nskb
)paren
op_member_access_from_pointer
id|seq
op_assign
id|TCP_SKB_CB
c_func
(paren
id|nskb
)paren
op_member_access_from_pointer
id|end_seq
op_assign
id|start
suffix:semicolon
id|__skb_insert
c_func
(paren
id|nskb
comma
id|skb-&gt;prev
comma
id|skb
comma
id|skb-&gt;list
)paren
suffix:semicolon
id|sk_stream_set_owner_r
c_func
(paren
id|nskb
comma
id|sk
)paren
suffix:semicolon
multiline_comment|/* Copy data, releasing collapsed skbs. */
r_while
c_loop
(paren
id|copy
OG
l_int|0
)paren
(brace
r_int
id|offset
op_assign
id|start
op_minus
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
suffix:semicolon
r_int
id|size
op_assign
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
op_minus
id|start
suffix:semicolon
r_if
c_cond
(paren
id|offset
OL
l_int|0
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|size
OG
l_int|0
)paren
(brace
id|size
op_assign
id|min
c_func
(paren
id|copy
comma
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb_copy_bits
c_func
(paren
id|skb
comma
id|offset
comma
id|skb_put
c_func
(paren
id|nskb
comma
id|size
)paren
comma
id|size
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|TCP_SKB_CB
c_func
(paren
id|nskb
)paren
op_member_access_from_pointer
id|end_seq
op_add_assign
id|size
suffix:semicolon
id|copy
op_sub_assign
id|size
suffix:semicolon
id|start
op_add_assign
id|size
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|before
c_func
(paren
id|start
comma
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
)paren
)paren
(brace
r_struct
id|sk_buff
op_star
id|next
op_assign
id|skb-&gt;next
suffix:semicolon
id|__skb_unlink
c_func
(paren
id|skb
comma
id|skb-&gt;list
)paren
suffix:semicolon
id|__kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
id|NET_INC_STATS_BH
c_func
(paren
id|LINUX_MIB_TCPRCVCOLLAPSED
)paren
suffix:semicolon
id|skb
op_assign
id|next
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
id|tail
op_logical_or
id|skb-&gt;h.th-&gt;syn
op_logical_or
id|skb-&gt;h.th-&gt;fin
)paren
r_return
suffix:semicolon
)brace
)brace
)brace
)brace
multiline_comment|/* Collapse ofo queue. Algorithm: select contiguous sequence of skbs&n; * and tcp_collapse() them until all the queue is collapsed.&n; */
DECL|function|tcp_collapse_ofo_queue
r_static
r_void
id|tcp_collapse_ofo_queue
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|tcp_sock
op_star
id|tp
op_assign
id|tcp_sk
c_func
(paren
id|sk
)paren
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
op_assign
id|skb_peek
c_func
(paren
op_amp
id|tp-&gt;out_of_order_queue
)paren
suffix:semicolon
r_struct
id|sk_buff
op_star
id|head
suffix:semicolon
id|u32
id|start
comma
id|end
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
id|start
op_assign
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
suffix:semicolon
id|end
op_assign
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
suffix:semicolon
id|head
op_assign
id|skb
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|skb
op_assign
id|skb-&gt;next
suffix:semicolon
multiline_comment|/* Segment is terminated when we see gap or when&n;&t;&t; * we are at the end of all the queue. */
r_if
c_cond
(paren
id|skb
op_eq
(paren
r_struct
id|sk_buff
op_star
)paren
op_amp
id|tp-&gt;out_of_order_queue
op_logical_or
id|after
c_func
(paren
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
comma
id|end
)paren
op_logical_or
id|before
c_func
(paren
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
comma
id|start
)paren
)paren
(brace
id|tcp_collapse
c_func
(paren
id|sk
comma
id|head
comma
id|skb
comma
id|start
comma
id|end
)paren
suffix:semicolon
id|head
op_assign
id|skb
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
(paren
r_struct
id|sk_buff
op_star
)paren
op_amp
id|tp-&gt;out_of_order_queue
)paren
r_break
suffix:semicolon
multiline_comment|/* Start new segment */
id|start
op_assign
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
suffix:semicolon
id|end
op_assign
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|before
c_func
(paren
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
comma
id|start
)paren
)paren
id|start
op_assign
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
suffix:semicolon
r_if
c_cond
(paren
id|after
c_func
(paren
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
comma
id|end
)paren
)paren
id|end
op_assign
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Reduce allocated memory if we can, trying to get&n; * the socket within its memory limits again.&n; *&n; * Return less than zero if we should start dropping frames&n; * until the socket owning process reads some of the data&n; * to stabilize the situation.&n; */
DECL|function|tcp_prune_queue
r_static
r_int
id|tcp_prune_queue
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|tcp_sock
op_star
id|tp
op_assign
id|tcp_sk
c_func
(paren
id|sk
)paren
suffix:semicolon
id|SOCK_DEBUG
c_func
(paren
id|sk
comma
l_string|&quot;prune_queue: c=%x&bslash;n&quot;
comma
id|tp-&gt;copied_seq
)paren
suffix:semicolon
id|NET_INC_STATS_BH
c_func
(paren
id|LINUX_MIB_PRUNECALLED
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|sk-&gt;sk_rmem_alloc
)paren
op_ge
id|sk-&gt;sk_rcvbuf
)paren
id|tcp_clamp_window
c_func
(paren
id|sk
comma
id|tp
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|tcp_memory_pressure
)paren
id|tp-&gt;rcv_ssthresh
op_assign
id|min
c_func
(paren
id|tp-&gt;rcv_ssthresh
comma
l_int|4U
op_star
id|tp-&gt;advmss
)paren
suffix:semicolon
id|tcp_collapse_ofo_queue
c_func
(paren
id|sk
)paren
suffix:semicolon
id|tcp_collapse
c_func
(paren
id|sk
comma
id|sk-&gt;sk_receive_queue.next
comma
(paren
r_struct
id|sk_buff
op_star
)paren
op_amp
id|sk-&gt;sk_receive_queue
comma
id|tp-&gt;copied_seq
comma
id|tp-&gt;rcv_nxt
)paren
suffix:semicolon
id|sk_stream_mem_reclaim
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|sk-&gt;sk_rmem_alloc
)paren
op_le
id|sk-&gt;sk_rcvbuf
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Collapsing did not help, destructive actions follow.&n;&t; * This must not ever occur. */
multiline_comment|/* First, purge the out_of_order queue. */
r_if
c_cond
(paren
id|skb_queue_len
c_func
(paren
op_amp
id|tp-&gt;out_of_order_queue
)paren
)paren
(brace
id|NET_ADD_STATS_BH
c_func
(paren
id|LINUX_MIB_OFOPRUNED
comma
id|skb_queue_len
c_func
(paren
op_amp
id|tp-&gt;out_of_order_queue
)paren
)paren
suffix:semicolon
id|__skb_queue_purge
c_func
(paren
op_amp
id|tp-&gt;out_of_order_queue
)paren
suffix:semicolon
multiline_comment|/* Reset SACK state.  A conforming SACK implementation will&n;&t;&t; * do the same at a timeout based retransmit.  When a connection&n;&t;&t; * is in a sad state like this, we care only about integrity&n;&t;&t; * of the connection not performance.&n;&t;&t; */
r_if
c_cond
(paren
id|tp-&gt;sack_ok
)paren
id|tcp_sack_reset
c_func
(paren
id|tp
)paren
suffix:semicolon
id|sk_stream_mem_reclaim
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|sk-&gt;sk_rmem_alloc
)paren
op_le
id|sk-&gt;sk_rcvbuf
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* If we are really being abused, tell the caller to silently&n;&t; * drop receive data on the floor.  It will get retransmitted&n;&t; * and hopefully then we&squot;ll have sufficient space.&n;&t; */
id|NET_INC_STATS_BH
c_func
(paren
id|LINUX_MIB_RCVPRUNED
)paren
suffix:semicolon
multiline_comment|/* Massive buffer overcommit. */
id|tp-&gt;pred_flags
op_assign
l_int|0
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* RFC2861, slow part. Adjust cwnd, after it was not full during one rto.&n; * As additional protections, we do not touch cwnd in retransmission phases,&n; * and if application hit its sndbuf limit recently.&n; */
DECL|function|tcp_cwnd_application_limited
r_void
id|tcp_cwnd_application_limited
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|tcp_sock
op_star
id|tp
op_assign
id|tcp_sk
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;ca_state
op_eq
id|TCP_CA_Open
op_logical_and
id|sk-&gt;sk_socket
op_logical_and
op_logical_neg
id|test_bit
c_func
(paren
id|SOCK_NOSPACE
comma
op_amp
id|sk-&gt;sk_socket-&gt;flags
)paren
)paren
(brace
multiline_comment|/* Limited by application or receiver window. */
id|u32
id|win_used
op_assign
id|max
c_func
(paren
id|tp-&gt;snd_cwnd_used
comma
l_int|2U
)paren
suffix:semicolon
r_if
c_cond
(paren
id|win_used
OL
id|tp-&gt;snd_cwnd
)paren
(brace
id|tp-&gt;snd_ssthresh
op_assign
id|tcp_current_ssthresh
c_func
(paren
id|tp
)paren
suffix:semicolon
id|tp-&gt;snd_cwnd
op_assign
(paren
id|tp-&gt;snd_cwnd
op_plus
id|win_used
)paren
op_rshift
l_int|1
suffix:semicolon
)brace
id|tp-&gt;snd_cwnd_used
op_assign
l_int|0
suffix:semicolon
)brace
id|tp-&gt;snd_cwnd_stamp
op_assign
id|tcp_time_stamp
suffix:semicolon
)brace
multiline_comment|/* When incoming ACK allowed to free some skb from write_queue,&n; * we remember this event in flag sk-&gt;sk_queue_shrunk and wake up socket&n; * on the exit from tcp input handler.&n; *&n; * PROBLEM: sndbuf expansion does not work well with largesend.&n; */
DECL|function|tcp_new_space
r_static
r_void
id|tcp_new_space
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|tcp_sock
op_star
id|tp
op_assign
id|tcp_sk
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;packets_out
OL
id|tp-&gt;snd_cwnd
op_logical_and
op_logical_neg
(paren
id|sk-&gt;sk_userlocks
op_amp
id|SOCK_SNDBUF_LOCK
)paren
op_logical_and
op_logical_neg
id|tcp_memory_pressure
op_logical_and
id|atomic_read
c_func
(paren
op_amp
id|tcp_memory_allocated
)paren
OL
id|sysctl_tcp_mem
(braket
l_int|0
)braket
)paren
(brace
r_int
id|sndmem
op_assign
id|max_t
c_func
(paren
id|u32
comma
id|tp-&gt;mss_clamp
comma
id|tp-&gt;mss_cache_std
)paren
op_plus
id|MAX_TCP_HEADER
op_plus
l_int|16
op_plus
r_sizeof
(paren
r_struct
id|sk_buff
)paren
comma
id|demanded
op_assign
id|max_t
c_func
(paren
r_int
r_int
comma
id|tp-&gt;snd_cwnd
comma
id|tp-&gt;reordering
op_plus
l_int|1
)paren
suffix:semicolon
id|sndmem
op_mul_assign
l_int|2
op_star
id|demanded
suffix:semicolon
r_if
c_cond
(paren
id|sndmem
OG
id|sk-&gt;sk_sndbuf
)paren
id|sk-&gt;sk_sndbuf
op_assign
id|min
c_func
(paren
id|sndmem
comma
id|sysctl_tcp_wmem
(braket
l_int|2
)braket
)paren
suffix:semicolon
id|tp-&gt;snd_cwnd_stamp
op_assign
id|tcp_time_stamp
suffix:semicolon
)brace
id|sk
op_member_access_from_pointer
id|sk_write_space
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
DECL|function|tcp_check_space
r_static
r_inline
r_void
id|tcp_check_space
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_if
c_cond
(paren
id|sk-&gt;sk_queue_shrunk
)paren
(brace
id|sk-&gt;sk_queue_shrunk
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;sk_socket
op_logical_and
id|test_bit
c_func
(paren
id|SOCK_NOSPACE
comma
op_amp
id|sk-&gt;sk_socket-&gt;flags
)paren
)paren
id|tcp_new_space
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
)brace
DECL|function|__tcp_data_snd_check
r_static
r_void
id|__tcp_data_snd_check
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|tcp_sock
op_star
id|tp
op_assign
id|tcp_sk
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|after
c_func
(paren
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
comma
id|tp-&gt;snd_una
op_plus
id|tp-&gt;snd_wnd
)paren
op_logical_or
id|tcp_packets_in_flight
c_func
(paren
id|tp
)paren
op_ge
id|tp-&gt;snd_cwnd
op_logical_or
id|tcp_write_xmit
c_func
(paren
id|sk
comma
id|tp-&gt;nonagle
)paren
)paren
id|tcp_check_probe_timer
c_func
(paren
id|sk
comma
id|tp
)paren
suffix:semicolon
)brace
DECL|function|tcp_data_snd_check
r_static
id|__inline__
r_void
id|tcp_data_snd_check
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
op_assign
id|sk-&gt;sk_send_head
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_ne
l_int|NULL
)paren
id|__tcp_data_snd_check
c_func
(paren
id|sk
comma
id|skb
)paren
suffix:semicolon
id|tcp_check_space
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Check if sending an ack is needed.&n; */
DECL|function|__tcp_ack_snd_check
r_static
r_void
id|__tcp_ack_snd_check
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|ofo_possible
)paren
(brace
r_struct
id|tcp_sock
op_star
id|tp
op_assign
id|tcp_sk
c_func
(paren
id|sk
)paren
suffix:semicolon
multiline_comment|/* More than one full frame received... */
r_if
c_cond
(paren
(paren
(paren
id|tp-&gt;rcv_nxt
op_minus
id|tp-&gt;rcv_wup
)paren
OG
id|tp-&gt;ack.rcv_mss
multiline_comment|/* ... and right edge of window advances far enough.&n;&t;      * (tcp_recvmsg() will send ACK otherwise). Or...&n;&t;      */
op_logical_and
id|__tcp_select_window
c_func
(paren
id|sk
)paren
op_ge
id|tp-&gt;rcv_wnd
)paren
op_logical_or
multiline_comment|/* We ACK each frame or... */
id|tcp_in_quickack_mode
c_func
(paren
id|tp
)paren
op_logical_or
multiline_comment|/* We have out of order data. */
(paren
id|ofo_possible
op_logical_and
id|skb_peek
c_func
(paren
op_amp
id|tp-&gt;out_of_order_queue
)paren
)paren
)paren
(brace
multiline_comment|/* Then ack it now */
id|tcp_send_ack
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Else, send delayed ack. */
id|tcp_send_delayed_ack
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
)brace
DECL|function|tcp_ack_snd_check
r_static
id|__inline__
r_void
id|tcp_ack_snd_check
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|tcp_sock
op_star
id|tp
op_assign
id|tcp_sk
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tcp_ack_scheduled
c_func
(paren
id|tp
)paren
)paren
(brace
multiline_comment|/* We sent a data segment already. */
r_return
suffix:semicolon
)brace
id|__tcp_ack_snd_check
c_func
(paren
id|sk
comma
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;This routine is only called when we have urgent data&n; *&t;signalled. Its the &squot;slow&squot; part of tcp_urg. It could be&n; *&t;moved inline now as tcp_urg is only called from one&n; *&t;place. We handle URGent data wrong. We have to - as&n; *&t;BSD still doesn&squot;t use the correction from RFC961.&n; *&t;For 1003.1g we should support a new option TCP_STDURG to permit&n; *&t;either form (or just set the sysctl tcp_stdurg).&n; */
DECL|function|tcp_check_urg
r_static
r_void
id|tcp_check_urg
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|tcphdr
op_star
id|th
)paren
(brace
r_struct
id|tcp_sock
op_star
id|tp
op_assign
id|tcp_sk
c_func
(paren
id|sk
)paren
suffix:semicolon
id|u32
id|ptr
op_assign
id|ntohs
c_func
(paren
id|th-&gt;urg_ptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ptr
op_logical_and
op_logical_neg
id|sysctl_tcp_stdurg
)paren
id|ptr
op_decrement
suffix:semicolon
id|ptr
op_add_assign
id|ntohl
c_func
(paren
id|th-&gt;seq
)paren
suffix:semicolon
multiline_comment|/* Ignore urgent data that we&squot;ve already seen and read. */
r_if
c_cond
(paren
id|after
c_func
(paren
id|tp-&gt;copied_seq
comma
id|ptr
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* Do not replay urg ptr.&n;&t; *&n;&t; * NOTE: interesting situation not covered by specs.&n;&t; * Misbehaving sender may send urg ptr, pointing to segment,&n;&t; * which we already have in ofo queue. We are not able to fetch&n;&t; * such data and will stay in TCP_URG_NOTYET until will be eaten&n;&t; * by recvmsg(). Seems, we are not obliged to handle such wicked&n;&t; * situations. But it is worth to think about possibility of some&n;&t; * DoSes using some hypothetical application level deadlock.&n;&t; */
r_if
c_cond
(paren
id|before
c_func
(paren
id|ptr
comma
id|tp-&gt;rcv_nxt
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* Do we already have a newer (or duplicate) urgent pointer? */
r_if
c_cond
(paren
id|tp-&gt;urg_data
op_logical_and
op_logical_neg
id|after
c_func
(paren
id|ptr
comma
id|tp-&gt;urg_seq
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* Tell the world about our new urgent pointer. */
id|sk_send_sigurg
c_func
(paren
id|sk
)paren
suffix:semicolon
multiline_comment|/* We may be adding urgent data when the last byte read was&n;&t; * urgent. To do this requires some care. We cannot just ignore&n;&t; * tp-&gt;copied_seq since we would read the last urgent byte again&n;&t; * as data, nor can we alter copied_seq until this data arrives&n;&t; * or we break the sematics of SIOCATMARK (and thus sockatmark())&n;&t; *&n;&t; * NOTE. Double Dutch. Rendering to plain English: author of comment&n;&t; * above did something sort of &t;send(&quot;A&quot;, MSG_OOB); send(&quot;B&quot;, MSG_OOB);&n;&t; * and expect that both A and B disappear from stream. This is _wrong_.&n;&t; * Though this happens in BSD with high probability, this is occasional.&n;&t; * Any application relying on this is buggy. Note also, that fix &quot;works&quot;&n;&t; * only in this artificial test. Insert some normal data between A and B and we will&n;&t; * decline of BSD again. Verdict: it is better to remove to trap&n;&t; * buggy users.&n;&t; */
r_if
c_cond
(paren
id|tp-&gt;urg_seq
op_eq
id|tp-&gt;copied_seq
op_logical_and
id|tp-&gt;urg_data
op_logical_and
op_logical_neg
id|sock_flag
c_func
(paren
id|sk
comma
id|SOCK_URGINLINE
)paren
op_logical_and
id|tp-&gt;copied_seq
op_ne
id|tp-&gt;rcv_nxt
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
op_assign
id|skb_peek
c_func
(paren
op_amp
id|sk-&gt;sk_receive_queue
)paren
suffix:semicolon
id|tp-&gt;copied_seq
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_logical_and
op_logical_neg
id|before
c_func
(paren
id|tp-&gt;copied_seq
comma
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
)paren
)paren
(brace
id|__skb_unlink
c_func
(paren
id|skb
comma
id|skb-&gt;list
)paren
suffix:semicolon
id|__kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
)brace
id|tp-&gt;urg_data
op_assign
id|TCP_URG_NOTYET
suffix:semicolon
id|tp-&gt;urg_seq
op_assign
id|ptr
suffix:semicolon
multiline_comment|/* Disable header prediction. */
id|tp-&gt;pred_flags
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* This is the &squot;fast&squot; part of urgent handling. */
DECL|function|tcp_urg
r_static
r_void
id|tcp_urg
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|tcphdr
op_star
id|th
)paren
(brace
r_struct
id|tcp_sock
op_star
id|tp
op_assign
id|tcp_sk
c_func
(paren
id|sk
)paren
suffix:semicolon
multiline_comment|/* Check if we get a new urgent pointer - normally not. */
r_if
c_cond
(paren
id|th-&gt;urg
)paren
id|tcp_check_urg
c_func
(paren
id|sk
comma
id|th
)paren
suffix:semicolon
multiline_comment|/* Do we wait for any urgent data? - normally not... */
r_if
c_cond
(paren
id|tp-&gt;urg_data
op_eq
id|TCP_URG_NOTYET
)paren
(brace
id|u32
id|ptr
op_assign
id|tp-&gt;urg_seq
op_minus
id|ntohl
c_func
(paren
id|th-&gt;seq
)paren
op_plus
(paren
id|th-&gt;doff
op_star
l_int|4
)paren
op_minus
id|th-&gt;syn
suffix:semicolon
multiline_comment|/* Is the urgent pointer pointing into this packet? */
r_if
c_cond
(paren
id|ptr
OL
id|skb-&gt;len
)paren
(brace
id|u8
id|tmp
suffix:semicolon
r_if
c_cond
(paren
id|skb_copy_bits
c_func
(paren
id|skb
comma
id|ptr
comma
op_amp
id|tmp
comma
l_int|1
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|tp-&gt;urg_data
op_assign
id|TCP_URG_VALID
op_or
id|tmp
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sock_flag
c_func
(paren
id|sk
comma
id|SOCK_DEAD
)paren
)paren
id|sk
op_member_access_from_pointer
id|sk_data_ready
c_func
(paren
id|sk
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|function|tcp_copy_to_iovec
r_static
r_int
id|tcp_copy_to_iovec
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|hlen
)paren
(brace
r_struct
id|tcp_sock
op_star
id|tp
op_assign
id|tcp_sk
c_func
(paren
id|sk
)paren
suffix:semicolon
r_int
id|chunk
op_assign
id|skb-&gt;len
op_minus
id|hlen
suffix:semicolon
r_int
id|err
suffix:semicolon
id|local_bh_enable
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb-&gt;ip_summed
op_eq
id|CHECKSUM_UNNECESSARY
)paren
id|err
op_assign
id|skb_copy_datagram_iovec
c_func
(paren
id|skb
comma
id|hlen
comma
id|tp-&gt;ucopy.iov
comma
id|chunk
)paren
suffix:semicolon
r_else
id|err
op_assign
id|skb_copy_and_csum_datagram_iovec
c_func
(paren
id|skb
comma
id|hlen
comma
id|tp-&gt;ucopy.iov
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|err
)paren
(brace
id|tp-&gt;ucopy.len
op_sub_assign
id|chunk
suffix:semicolon
id|tp-&gt;copied_seq
op_add_assign
id|chunk
suffix:semicolon
id|tcp_rcv_space_adjust
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
id|local_bh_disable
c_func
(paren
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|function|__tcp_checksum_complete_user
r_static
r_int
id|__tcp_checksum_complete_user
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_int
id|result
suffix:semicolon
r_if
c_cond
(paren
id|sock_owned_by_user
c_func
(paren
id|sk
)paren
)paren
(brace
id|local_bh_enable
c_func
(paren
)paren
suffix:semicolon
id|result
op_assign
id|__tcp_checksum_complete
c_func
(paren
id|skb
)paren
suffix:semicolon
id|local_bh_disable
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|result
op_assign
id|__tcp_checksum_complete
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
r_return
id|result
suffix:semicolon
)brace
r_static
id|__inline__
r_int
DECL|function|tcp_checksum_complete_user
id|tcp_checksum_complete_user
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_return
id|skb-&gt;ip_summed
op_ne
id|CHECKSUM_UNNECESSARY
op_logical_and
id|__tcp_checksum_complete_user
c_func
(paren
id|sk
comma
id|skb
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;TCP receive function for the ESTABLISHED state. &n; *&n; *&t;It is split into a fast path and a slow path. The fast path is &n; * &t;disabled when:&n; *&t;- A zero window was announced from us - zero window probing&n; *        is only handled properly in the slow path. &n; *&t;- Out of order segments arrived.&n; *&t;- Urgent data is expected.&n; *&t;- There is no buffer space left&n; *&t;- Unexpected TCP flags/window values/header lengths are received&n; *&t;  (detected by checking the TCP header against pred_flags) &n; *&t;- Data is sent in both directions. Fast path only supports pure senders&n; *&t;  or pure receivers (this means either the sequence number or the ack&n; *&t;  value must stay constant)&n; *&t;- Unexpected TCP option.&n; *&n; *&t;When these conditions are not satisfied it drops into a standard &n; *&t;receive procedure patterned after RFC793 to handle all cases.&n; *&t;The first three cases are guaranteed by proper pred_flags setting,&n; *&t;the rest is checked inline. Fast processing is turned on in &n; *&t;tcp_data_queue when everything is OK.&n; */
DECL|function|tcp_rcv_established
r_int
id|tcp_rcv_established
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|tcphdr
op_star
id|th
comma
r_int
id|len
)paren
(brace
r_struct
id|tcp_sock
op_star
id|tp
op_assign
id|tcp_sk
c_func
(paren
id|sk
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Header prediction.&n;&t; *&t;The code loosely follows the one in the famous &n;&t; *&t;&quot;30 instruction TCP receive&quot; Van Jacobson mail.&n;&t; *&t;&n;&t; *&t;Van&squot;s trick is to deposit buffers into socket queue &n;&t; *&t;on a device interrupt, to call tcp_recv function&n;&t; *&t;on the receive process context and checksum and copy&n;&t; *&t;the buffer to user space. smart...&n;&t; *&n;&t; *&t;Our current scheme is not silly either but we take the &n;&t; *&t;extra cost of the net_bh soft interrupt processing...&n;&t; *&t;We do checksum and copy also but from device to kernel.&n;&t; */
id|tp-&gt;saw_tstamp
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&t;pred_flags is 0xS?10 &lt;&lt; 16 + snd_wnd&n;&t; *&t;if header_predition is to be made&n;&t; *&t;&squot;S&squot; will always be tp-&gt;tcp_header_len &gt;&gt; 2&n;&t; *&t;&squot;?&squot; will be 0 for the fast path, otherwise pred_flags is 0 to&n;&t; *  turn it off&t;(when there are holes in the receive &n;&t; *&t; space for instance)&n;&t; *&t;PSH flag is ignored.&n;&t; */
r_if
c_cond
(paren
(paren
id|tcp_flag_word
c_func
(paren
id|th
)paren
op_amp
id|TCP_HP_BITS
)paren
op_eq
id|tp-&gt;pred_flags
op_logical_and
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
op_eq
id|tp-&gt;rcv_nxt
)paren
(brace
r_int
id|tcp_header_len
op_assign
id|tp-&gt;tcp_header_len
suffix:semicolon
multiline_comment|/* Timestamp header prediction: tcp_header_len&n;&t;&t; * is automatically equal to th-&gt;doff*4 due to pred_flags&n;&t;&t; * match.&n;&t;&t; */
multiline_comment|/* Check timestamp */
r_if
c_cond
(paren
id|tcp_header_len
op_eq
r_sizeof
(paren
r_struct
id|tcphdr
)paren
op_plus
id|TCPOLEN_TSTAMP_ALIGNED
)paren
(brace
id|__u32
op_star
id|ptr
op_assign
(paren
id|__u32
op_star
)paren
(paren
id|th
op_plus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* No? Slow path! */
r_if
c_cond
(paren
op_star
id|ptr
op_ne
id|ntohl
c_func
(paren
(paren
id|TCPOPT_NOP
op_lshift
l_int|24
)paren
op_or
(paren
id|TCPOPT_NOP
op_lshift
l_int|16
)paren
op_or
(paren
id|TCPOPT_TIMESTAMP
op_lshift
l_int|8
)paren
op_or
id|TCPOLEN_TIMESTAMP
)paren
)paren
r_goto
id|slow_path
suffix:semicolon
id|tp-&gt;saw_tstamp
op_assign
l_int|1
suffix:semicolon
op_increment
id|ptr
suffix:semicolon
id|tp-&gt;rcv_tsval
op_assign
id|ntohl
c_func
(paren
op_star
id|ptr
)paren
suffix:semicolon
op_increment
id|ptr
suffix:semicolon
id|tp-&gt;rcv_tsecr
op_assign
id|ntohl
c_func
(paren
op_star
id|ptr
)paren
suffix:semicolon
multiline_comment|/* If PAWS failed, check it more carefully in slow path */
r_if
c_cond
(paren
(paren
id|s32
)paren
(paren
id|tp-&gt;rcv_tsval
op_minus
id|tp-&gt;ts_recent
)paren
OL
l_int|0
)paren
r_goto
id|slow_path
suffix:semicolon
multiline_comment|/* DO NOT update ts_recent here, if checksum fails&n;&t;&t;&t; * and timestamp was corrupted part, it will result&n;&t;&t;&t; * in a hung connection since we will drop all&n;&t;&t;&t; * future packets due to the PAWS test.&n;&t;&t;&t; */
)brace
r_if
c_cond
(paren
id|len
op_le
id|tcp_header_len
)paren
(brace
multiline_comment|/* Bulk data transfer: sender */
r_if
c_cond
(paren
id|len
op_eq
id|tcp_header_len
)paren
(brace
multiline_comment|/* Predicted packet is in window by definition.&n;&t;&t;&t;&t; * seq == rcv_nxt and rcv_wup &lt;= rcv_nxt.&n;&t;&t;&t;&t; * Hence, check seq&lt;=rcv_wup reduces to:&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|tcp_header_len
op_eq
(paren
r_sizeof
(paren
r_struct
id|tcphdr
)paren
op_plus
id|TCPOLEN_TSTAMP_ALIGNED
)paren
op_logical_and
id|tp-&gt;rcv_nxt
op_eq
id|tp-&gt;rcv_wup
)paren
id|tcp_store_ts_recent
c_func
(paren
id|tp
)paren
suffix:semicolon
id|tcp_rcv_rtt_measure_ts
c_func
(paren
id|tp
comma
id|skb
)paren
suffix:semicolon
multiline_comment|/* We know that such packets are checksummed&n;&t;&t;&t;&t; * on entry.&n;&t;&t;&t;&t; */
id|tcp_ack
c_func
(paren
id|sk
comma
id|skb
comma
l_int|0
)paren
suffix:semicolon
id|__kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
id|tcp_data_snd_check
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Header too small */
id|TCP_INC_STATS_BH
c_func
(paren
id|TCP_MIB_INERRS
)paren
suffix:semicolon
r_goto
id|discard
suffix:semicolon
)brace
)brace
r_else
(brace
r_int
id|eaten
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;ucopy.task
op_eq
id|current
op_logical_and
id|tp-&gt;copied_seq
op_eq
id|tp-&gt;rcv_nxt
op_logical_and
id|len
op_minus
id|tcp_header_len
op_le
id|tp-&gt;ucopy.len
op_logical_and
id|sock_owned_by_user
c_func
(paren
id|sk
)paren
)paren
(brace
id|__set_current_state
c_func
(paren
id|TASK_RUNNING
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tcp_copy_to_iovec
c_func
(paren
id|sk
comma
id|skb
comma
id|tcp_header_len
)paren
)paren
(brace
multiline_comment|/* Predicted packet is in window by definition.&n;&t;&t;&t;&t;&t; * seq == rcv_nxt and rcv_wup &lt;= rcv_nxt.&n;&t;&t;&t;&t;&t; * Hence, check seq&lt;=rcv_wup reduces to:&n;&t;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|tcp_header_len
op_eq
(paren
r_sizeof
(paren
r_struct
id|tcphdr
)paren
op_plus
id|TCPOLEN_TSTAMP_ALIGNED
)paren
op_logical_and
id|tp-&gt;rcv_nxt
op_eq
id|tp-&gt;rcv_wup
)paren
id|tcp_store_ts_recent
c_func
(paren
id|tp
)paren
suffix:semicolon
id|tcp_rcv_rtt_measure_ts
c_func
(paren
id|tp
comma
id|skb
)paren
suffix:semicolon
id|__skb_pull
c_func
(paren
id|skb
comma
id|tcp_header_len
)paren
suffix:semicolon
id|tp-&gt;rcv_nxt
op_assign
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
suffix:semicolon
id|NET_INC_STATS_BH
c_func
(paren
id|LINUX_MIB_TCPHPHITSTOUSER
)paren
suffix:semicolon
id|eaten
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|eaten
)paren
(brace
r_if
c_cond
(paren
id|tcp_checksum_complete_user
c_func
(paren
id|sk
comma
id|skb
)paren
)paren
r_goto
id|csum_error
suffix:semicolon
multiline_comment|/* Predicted packet is in window by definition.&n;&t;&t;&t;&t; * seq == rcv_nxt and rcv_wup &lt;= rcv_nxt.&n;&t;&t;&t;&t; * Hence, check seq&lt;=rcv_wup reduces to:&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|tcp_header_len
op_eq
(paren
r_sizeof
(paren
r_struct
id|tcphdr
)paren
op_plus
id|TCPOLEN_TSTAMP_ALIGNED
)paren
op_logical_and
id|tp-&gt;rcv_nxt
op_eq
id|tp-&gt;rcv_wup
)paren
id|tcp_store_ts_recent
c_func
(paren
id|tp
)paren
suffix:semicolon
id|tcp_rcv_rtt_measure_ts
c_func
(paren
id|tp
comma
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
)paren
id|skb-&gt;truesize
OG
id|sk-&gt;sk_forward_alloc
)paren
r_goto
id|step5
suffix:semicolon
id|NET_INC_STATS_BH
c_func
(paren
id|LINUX_MIB_TCPHPHITS
)paren
suffix:semicolon
multiline_comment|/* Bulk data transfer: receiver */
id|__skb_pull
c_func
(paren
id|skb
comma
id|tcp_header_len
)paren
suffix:semicolon
id|__skb_queue_tail
c_func
(paren
op_amp
id|sk-&gt;sk_receive_queue
comma
id|skb
)paren
suffix:semicolon
id|sk_stream_set_owner_r
c_func
(paren
id|skb
comma
id|sk
)paren
suffix:semicolon
id|tp-&gt;rcv_nxt
op_assign
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
suffix:semicolon
)brace
id|tcp_event_data_recv
c_func
(paren
id|sk
comma
id|tp
comma
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|ack_seq
op_ne
id|tp-&gt;snd_una
)paren
(brace
multiline_comment|/* Well, only one small jumplet in fast path... */
id|tcp_ack
c_func
(paren
id|sk
comma
id|skb
comma
id|FLAG_DATA
)paren
suffix:semicolon
id|tcp_data_snd_check
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tcp_ack_scheduled
c_func
(paren
id|tp
)paren
)paren
r_goto
id|no_ack
suffix:semicolon
)brace
r_if
c_cond
(paren
id|eaten
)paren
(brace
r_if
c_cond
(paren
id|tcp_in_quickack_mode
c_func
(paren
id|tp
)paren
)paren
(brace
id|tcp_send_ack
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
r_else
(brace
id|tcp_send_delayed_ack
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|__tcp_ack_snd_check
c_func
(paren
id|sk
comma
l_int|0
)paren
suffix:semicolon
)brace
id|no_ack
suffix:colon
r_if
c_cond
(paren
id|eaten
)paren
id|__kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_else
id|sk
op_member_access_from_pointer
id|sk_data_ready
c_func
(paren
id|sk
comma
l_int|0
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
id|slow_path
suffix:colon
r_if
c_cond
(paren
id|len
OL
(paren
id|th-&gt;doff
op_lshift
l_int|2
)paren
op_logical_or
id|tcp_checksum_complete_user
c_func
(paren
id|sk
comma
id|skb
)paren
)paren
r_goto
id|csum_error
suffix:semicolon
multiline_comment|/*&n;&t; * RFC1323: H1. Apply PAWS check first.&n;&t; */
r_if
c_cond
(paren
id|tcp_fast_parse_options
c_func
(paren
id|skb
comma
id|th
comma
id|tp
)paren
op_logical_and
id|tp-&gt;saw_tstamp
op_logical_and
id|tcp_paws_discard
c_func
(paren
id|tp
comma
id|skb
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|th-&gt;rst
)paren
(brace
id|NET_INC_STATS_BH
c_func
(paren
id|LINUX_MIB_PAWSESTABREJECTED
)paren
suffix:semicolon
id|tcp_send_dupack
c_func
(paren
id|sk
comma
id|skb
)paren
suffix:semicolon
r_goto
id|discard
suffix:semicolon
)brace
multiline_comment|/* Resets are accepted even if PAWS failed.&n;&n;&t;&t;   ts_recent update must be made after we are sure&n;&t;&t;   that the packet is in window.&n;&t;&t; */
)brace
multiline_comment|/*&n;&t; *&t;Standard slow path.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|tcp_sequence
c_func
(paren
id|tp
comma
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
comma
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
)paren
)paren
(brace
multiline_comment|/* RFC793, page 37: &quot;In all states except SYN-SENT, all reset&n;&t;&t; * (RST) segments are validated by checking their SEQ-fields.&quot;&n;&t;&t; * And page 69: &quot;If an incoming segment is not acceptable,&n;&t;&t; * an acknowledgment should be sent in reply (unless the RST bit&n;&t;&t; * is set, if so drop the segment and return)&quot;.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|th-&gt;rst
)paren
id|tcp_send_dupack
c_func
(paren
id|sk
comma
id|skb
)paren
suffix:semicolon
r_goto
id|discard
suffix:semicolon
)brace
r_if
c_cond
(paren
id|th-&gt;rst
)paren
(brace
id|tcp_reset
c_func
(paren
id|sk
)paren
suffix:semicolon
r_goto
id|discard
suffix:semicolon
)brace
id|tcp_replace_ts_recent
c_func
(paren
id|tp
comma
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|th-&gt;syn
op_logical_and
op_logical_neg
id|before
c_func
(paren
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
comma
id|tp-&gt;rcv_nxt
)paren
)paren
(brace
id|TCP_INC_STATS_BH
c_func
(paren
id|TCP_MIB_INERRS
)paren
suffix:semicolon
id|NET_INC_STATS_BH
c_func
(paren
id|LINUX_MIB_TCPABORTONSYN
)paren
suffix:semicolon
id|tcp_reset
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|step5
suffix:colon
r_if
c_cond
(paren
id|th-&gt;ack
)paren
(brace
id|tcp_ack
c_func
(paren
id|sk
comma
id|skb
comma
id|FLAG_SLOWPATH
)paren
suffix:semicolon
)brace
id|tcp_rcv_rtt_measure_ts
c_func
(paren
id|tp
comma
id|skb
)paren
suffix:semicolon
multiline_comment|/* Process urgent data. */
id|tcp_urg
c_func
(paren
id|sk
comma
id|skb
comma
id|th
)paren
suffix:semicolon
multiline_comment|/* step 7: process the segment text */
id|tcp_data_queue
c_func
(paren
id|sk
comma
id|skb
)paren
suffix:semicolon
id|tcp_data_snd_check
c_func
(paren
id|sk
)paren
suffix:semicolon
id|tcp_ack_snd_check
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|csum_error
suffix:colon
id|TCP_INC_STATS_BH
c_func
(paren
id|TCP_MIB_INERRS
)paren
suffix:semicolon
id|discard
suffix:colon
id|__kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|tcp_rcv_synsent_state_process
r_static
r_int
id|tcp_rcv_synsent_state_process
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|tcphdr
op_star
id|th
comma
r_int
id|len
)paren
(brace
r_struct
id|tcp_sock
op_star
id|tp
op_assign
id|tcp_sk
c_func
(paren
id|sk
)paren
suffix:semicolon
r_int
id|saved_clamp
op_assign
id|tp-&gt;mss_clamp
suffix:semicolon
id|tcp_parse_options
c_func
(paren
id|skb
comma
id|tp
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|th-&gt;ack
)paren
(brace
multiline_comment|/* rfc793:&n;&t;&t; * &quot;If the state is SYN-SENT then&n;&t;&t; *    first check the ACK bit&n;&t;&t; *      If the ACK bit is set&n;&t;&t; *&t;  If SEG.ACK =&lt; ISS, or SEG.ACK &gt; SND.NXT, send&n;&t;&t; *        a reset (unless the RST bit is set, if so drop&n;&t;&t; *        the segment and return)&quot;&n;&t;&t; *&n;&t;&t; *  We do not send data with SYN, so that RFC-correct&n;&t;&t; *  test reduces to:&n;&t;&t; */
r_if
c_cond
(paren
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|ack_seq
op_ne
id|tp-&gt;snd_nxt
)paren
r_goto
id|reset_and_undo
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;saw_tstamp
op_logical_and
id|tp-&gt;rcv_tsecr
op_logical_and
op_logical_neg
id|between
c_func
(paren
id|tp-&gt;rcv_tsecr
comma
id|tp-&gt;retrans_stamp
comma
id|tcp_time_stamp
)paren
)paren
(brace
id|NET_INC_STATS_BH
c_func
(paren
id|LINUX_MIB_PAWSACTIVEREJECTED
)paren
suffix:semicolon
r_goto
id|reset_and_undo
suffix:semicolon
)brace
multiline_comment|/* Now ACK is acceptable.&n;&t;&t; *&n;&t;&t; * &quot;If the RST bit is set&n;&t;&t; *    If the ACK was acceptable then signal the user &quot;error:&n;&t;&t; *    connection reset&quot;, drop the segment, enter CLOSED state,&n;&t;&t; *    delete TCB, and return.&quot;&n;&t;&t; */
r_if
c_cond
(paren
id|th-&gt;rst
)paren
(brace
id|tcp_reset
c_func
(paren
id|sk
)paren
suffix:semicolon
r_goto
id|discard
suffix:semicolon
)brace
multiline_comment|/* rfc793:&n;&t;&t; *   &quot;fifth, if neither of the SYN or RST bits is set then&n;&t;&t; *    drop the segment and return.&quot;&n;&t;&t; *&n;&t;&t; *    See note below!&n;&t;&t; *                                        --ANK(990513)&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|th-&gt;syn
)paren
r_goto
id|discard_and_undo
suffix:semicolon
multiline_comment|/* rfc793:&n;&t;&t; *   &quot;If the SYN bit is on ...&n;&t;&t; *    are acceptable then ...&n;&t;&t; *    (our SYN has been ACKed), change the connection&n;&t;&t; *    state to ESTABLISHED...&quot;&n;&t;&t; */
id|TCP_ECN_rcv_synack
c_func
(paren
id|tp
comma
id|th
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;ecn_flags
op_amp
id|TCP_ECN_OK
)paren
id|sk-&gt;sk_no_largesend
op_assign
l_int|1
suffix:semicolon
id|tp-&gt;snd_wl1
op_assign
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
suffix:semicolon
id|tcp_ack
c_func
(paren
id|sk
comma
id|skb
comma
id|FLAG_SLOWPATH
)paren
suffix:semicolon
multiline_comment|/* Ok.. it&squot;s good. Set up sequence numbers and&n;&t;&t; * move to established.&n;&t;&t; */
id|tp-&gt;rcv_nxt
op_assign
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
op_plus
l_int|1
suffix:semicolon
id|tp-&gt;rcv_wup
op_assign
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* RFC1323: The window in SYN &amp; SYN/ACK segments is&n;&t;&t; * never scaled.&n;&t;&t; */
id|tp-&gt;snd_wnd
op_assign
id|ntohs
c_func
(paren
id|th-&gt;window
)paren
suffix:semicolon
id|tcp_init_wl
c_func
(paren
id|tp
comma
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|ack_seq
comma
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tp-&gt;wscale_ok
)paren
(brace
id|tp-&gt;snd_wscale
op_assign
id|tp-&gt;rcv_wscale
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;window_clamp
op_assign
id|min
c_func
(paren
id|tp-&gt;window_clamp
comma
l_int|65535U
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tp-&gt;saw_tstamp
)paren
(brace
id|tp-&gt;tstamp_ok
op_assign
l_int|1
suffix:semicolon
id|tp-&gt;tcp_header_len
op_assign
r_sizeof
(paren
r_struct
id|tcphdr
)paren
op_plus
id|TCPOLEN_TSTAMP_ALIGNED
suffix:semicolon
id|tp-&gt;advmss
op_sub_assign
id|TCPOLEN_TSTAMP_ALIGNED
suffix:semicolon
id|tcp_store_ts_recent
c_func
(paren
id|tp
)paren
suffix:semicolon
)brace
r_else
(brace
id|tp-&gt;tcp_header_len
op_assign
r_sizeof
(paren
r_struct
id|tcphdr
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tp-&gt;sack_ok
op_logical_and
id|sysctl_tcp_fack
)paren
id|tp-&gt;sack_ok
op_or_assign
l_int|2
suffix:semicolon
id|tcp_sync_mss
c_func
(paren
id|sk
comma
id|tp-&gt;pmtu_cookie
)paren
suffix:semicolon
id|tcp_initialize_rcv_mss
c_func
(paren
id|sk
)paren
suffix:semicolon
multiline_comment|/* Remember, tcp_poll() does not lock socket!&n;&t;&t; * Change state from SYN-SENT only after copied_seq&n;&t;&t; * is initialized. */
id|tp-&gt;copied_seq
op_assign
id|tp-&gt;rcv_nxt
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
id|tcp_set_state
c_func
(paren
id|sk
comma
id|TCP_ESTABLISHED
)paren
suffix:semicolon
multiline_comment|/* Make sure socket is routed, for correct metrics.  */
id|tp-&gt;af_specific
op_member_access_from_pointer
id|rebuild_header
c_func
(paren
id|sk
)paren
suffix:semicolon
id|tcp_init_metrics
c_func
(paren
id|sk
)paren
suffix:semicolon
multiline_comment|/* Prevent spurious tcp_cwnd_restart() on first data&n;&t;&t; * packet.&n;&t;&t; */
id|tp-&gt;lsndtime
op_assign
id|tcp_time_stamp
suffix:semicolon
id|tcp_init_buffer_space
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sock_flag
c_func
(paren
id|sk
comma
id|SOCK_KEEPOPEN
)paren
)paren
id|tcp_reset_keepalive_timer
c_func
(paren
id|sk
comma
id|keepalive_time_when
c_func
(paren
id|tp
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tp-&gt;snd_wscale
)paren
id|__tcp_fast_path_on
c_func
(paren
id|tp
comma
id|tp-&gt;snd_wnd
)paren
suffix:semicolon
r_else
id|tp-&gt;pred_flags
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sock_flag
c_func
(paren
id|sk
comma
id|SOCK_DEAD
)paren
)paren
(brace
id|sk
op_member_access_from_pointer
id|sk_state_change
c_func
(paren
id|sk
)paren
suffix:semicolon
id|sk_wake_async
c_func
(paren
id|sk
comma
l_int|0
comma
id|POLL_OUT
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sk-&gt;sk_write_pending
op_logical_or
id|tp-&gt;defer_accept
op_logical_or
id|tp-&gt;ack.pingpong
)paren
(brace
multiline_comment|/* Save one ACK. Data will be ready after&n;&t;&t;&t; * several ticks, if write_pending is set.&n;&t;&t;&t; *&n;&t;&t;&t; * It may be deleted, but with this feature tcpdumps&n;&t;&t;&t; * look so _wonderfully_ clever, that I was not able&n;&t;&t;&t; * to stand against the temptation 8)     --ANK&n;&t;&t;&t; */
id|tcp_schedule_ack
c_func
(paren
id|tp
)paren
suffix:semicolon
id|tp-&gt;ack.lrcvtime
op_assign
id|tcp_time_stamp
suffix:semicolon
id|tp-&gt;ack.ato
op_assign
id|TCP_ATO_MIN
suffix:semicolon
id|tcp_incr_quickack
c_func
(paren
id|tp
)paren
suffix:semicolon
id|tcp_enter_quickack_mode
c_func
(paren
id|tp
)paren
suffix:semicolon
id|tcp_reset_xmit_timer
c_func
(paren
id|sk
comma
id|TCP_TIME_DACK
comma
id|TCP_DELACK_MAX
)paren
suffix:semicolon
id|discard
suffix:colon
id|__kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|tcp_send_ack
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* No ACK in the segment */
r_if
c_cond
(paren
id|th-&gt;rst
)paren
(brace
multiline_comment|/* rfc793:&n;&t;&t; * &quot;If the RST bit is set&n;&t;&t; *&n;&t;&t; *      Otherwise (no ACK) drop the segment and return.&quot;&n;&t;&t; */
r_goto
id|discard_and_undo
suffix:semicolon
)brace
multiline_comment|/* PAWS check. */
r_if
c_cond
(paren
id|tp-&gt;ts_recent_stamp
op_logical_and
id|tp-&gt;saw_tstamp
op_logical_and
id|tcp_paws_check
c_func
(paren
id|tp
comma
l_int|0
)paren
)paren
r_goto
id|discard_and_undo
suffix:semicolon
r_if
c_cond
(paren
id|th-&gt;syn
)paren
(brace
multiline_comment|/* We see SYN without ACK. It is attempt of&n;&t;&t; * simultaneous connect with crossed SYNs.&n;&t;&t; * Particularly, it can be connect to self.&n;&t;&t; */
id|tcp_set_state
c_func
(paren
id|sk
comma
id|TCP_SYN_RECV
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;saw_tstamp
)paren
(brace
id|tp-&gt;tstamp_ok
op_assign
l_int|1
suffix:semicolon
id|tcp_store_ts_recent
c_func
(paren
id|tp
)paren
suffix:semicolon
id|tp-&gt;tcp_header_len
op_assign
r_sizeof
(paren
r_struct
id|tcphdr
)paren
op_plus
id|TCPOLEN_TSTAMP_ALIGNED
suffix:semicolon
)brace
r_else
(brace
id|tp-&gt;tcp_header_len
op_assign
r_sizeof
(paren
r_struct
id|tcphdr
)paren
suffix:semicolon
)brace
id|tp-&gt;rcv_nxt
op_assign
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
op_plus
l_int|1
suffix:semicolon
id|tp-&gt;rcv_wup
op_assign
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* RFC1323: The window in SYN &amp; SYN/ACK segments is&n;&t;&t; * never scaled.&n;&t;&t; */
id|tp-&gt;snd_wnd
op_assign
id|ntohs
c_func
(paren
id|th-&gt;window
)paren
suffix:semicolon
id|tp-&gt;snd_wl1
op_assign
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
suffix:semicolon
id|tp-&gt;max_window
op_assign
id|tp-&gt;snd_wnd
suffix:semicolon
id|TCP_ECN_rcv_syn
c_func
(paren
id|tp
comma
id|th
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;ecn_flags
op_amp
id|TCP_ECN_OK
)paren
id|sk-&gt;sk_no_largesend
op_assign
l_int|1
suffix:semicolon
id|tcp_sync_mss
c_func
(paren
id|sk
comma
id|tp-&gt;pmtu_cookie
)paren
suffix:semicolon
id|tcp_initialize_rcv_mss
c_func
(paren
id|sk
)paren
suffix:semicolon
id|tcp_send_synack
c_func
(paren
id|sk
)paren
suffix:semicolon
macro_line|#if 0
multiline_comment|/* Note, we could accept data and URG from this segment.&n;&t;&t; * There are no obstacles to make this.&n;&t;&t; *&n;&t;&t; * However, if we ignore data in ACKless segments sometimes,&n;&t;&t; * we have no reasons to accept it sometimes.&n;&t;&t; * Also, seems the code doing it in step6 of tcp_rcv_state_process&n;&t;&t; * is not flawless. So, discard packet for sanity.&n;&t;&t; * Uncomment this return to process the data.&n;&t;&t; */
r_return
op_minus
l_int|1
suffix:semicolon
macro_line|#else
r_goto
id|discard
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/* &quot;fifth, if neither of the SYN or RST bits is set then&n;&t; * drop the segment and return.&quot;&n;&t; */
id|discard_and_undo
suffix:colon
id|tcp_clear_options
c_func
(paren
id|tp
)paren
suffix:semicolon
id|tp-&gt;mss_clamp
op_assign
id|saved_clamp
suffix:semicolon
r_goto
id|discard
suffix:semicolon
id|reset_and_undo
suffix:colon
id|tcp_clear_options
c_func
(paren
id|tp
)paren
suffix:semicolon
id|tp-&gt;mss_clamp
op_assign
id|saved_clamp
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;This function implements the receiving procedure of RFC 793 for&n; *&t;all states except ESTABLISHED and TIME_WAIT. &n; *&t;It&squot;s called from both tcp_v4_rcv and tcp_v6_rcv and should be&n; *&t;address independent.&n; */
DECL|function|tcp_rcv_state_process
r_int
id|tcp_rcv_state_process
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|tcphdr
op_star
id|th
comma
r_int
id|len
)paren
(brace
r_struct
id|tcp_sock
op_star
id|tp
op_assign
id|tcp_sk
c_func
(paren
id|sk
)paren
suffix:semicolon
r_int
id|queued
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;saw_tstamp
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|sk-&gt;sk_state
)paren
(brace
r_case
id|TCP_CLOSE
suffix:colon
r_goto
id|discard
suffix:semicolon
r_case
id|TCP_LISTEN
suffix:colon
r_if
c_cond
(paren
id|th-&gt;ack
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|th-&gt;rst
)paren
(brace
r_goto
id|discard
suffix:semicolon
)brace
r_if
c_cond
(paren
id|th-&gt;syn
)paren
(brace
r_if
c_cond
(paren
id|tp-&gt;af_specific
op_member_access_from_pointer
id|conn_request
c_func
(paren
id|sk
comma
id|skb
)paren
OL
l_int|0
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
id|init_westwood
c_func
(paren
id|sk
)paren
suffix:semicolon
id|init_bictcp
c_func
(paren
id|tp
)paren
suffix:semicolon
multiline_comment|/* Now we have several options: In theory there is &n;&t;&t;&t; * nothing else in the frame. KA9Q has an option to &n;&t;&t;&t; * send data with the syn, BSD accepts data with the&n;&t;&t;&t; * syn up to the [to be] advertised window and &n;&t;&t;&t; * Solaris 2.1 gives you a protocol error. For now &n;&t;&t;&t; * we just ignore it, that fits the spec precisely &n;&t;&t;&t; * and avoids incompatibilities. It would be nice in&n;&t;&t;&t; * future to drop through and process the data.&n;&t;&t;&t; *&n;&t;&t;&t; * Now that TTCP is starting to be used we ought to &n;&t;&t;&t; * queue this data.&n;&t;&t;&t; * But, this leaves one open to an easy denial of&n;&t;&t; &t; * service attack, and SYN cookies can&squot;t defend&n;&t;&t;&t; * against this problem. So, we drop the data&n;&t;&t;&t; * in the interest of security over speed.&n;&t;&t;&t; */
r_goto
id|discard
suffix:semicolon
)brace
r_goto
id|discard
suffix:semicolon
r_case
id|TCP_SYN_SENT
suffix:colon
id|init_westwood
c_func
(paren
id|sk
)paren
suffix:semicolon
id|init_bictcp
c_func
(paren
id|tp
)paren
suffix:semicolon
id|queued
op_assign
id|tcp_rcv_synsent_state_process
c_func
(paren
id|sk
comma
id|skb
comma
id|th
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|queued
op_ge
l_int|0
)paren
r_return
id|queued
suffix:semicolon
multiline_comment|/* Do step6 onward by hand. */
id|tcp_urg
c_func
(paren
id|sk
comma
id|skb
comma
id|th
)paren
suffix:semicolon
id|__kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
id|tcp_data_snd_check
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tcp_fast_parse_options
c_func
(paren
id|skb
comma
id|th
comma
id|tp
)paren
op_logical_and
id|tp-&gt;saw_tstamp
op_logical_and
id|tcp_paws_discard
c_func
(paren
id|tp
comma
id|skb
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|th-&gt;rst
)paren
(brace
id|NET_INC_STATS_BH
c_func
(paren
id|LINUX_MIB_PAWSESTABREJECTED
)paren
suffix:semicolon
id|tcp_send_dupack
c_func
(paren
id|sk
comma
id|skb
)paren
suffix:semicolon
r_goto
id|discard
suffix:semicolon
)brace
multiline_comment|/* Reset is accepted even if it did not pass PAWS. */
)brace
multiline_comment|/* step 1: check sequence number */
r_if
c_cond
(paren
op_logical_neg
id|tcp_sequence
c_func
(paren
id|tp
comma
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
comma
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|th-&gt;rst
)paren
id|tcp_send_dupack
c_func
(paren
id|sk
comma
id|skb
)paren
suffix:semicolon
r_goto
id|discard
suffix:semicolon
)brace
multiline_comment|/* step 2: check RST bit */
r_if
c_cond
(paren
id|th-&gt;rst
)paren
(brace
id|tcp_reset
c_func
(paren
id|sk
)paren
suffix:semicolon
r_goto
id|discard
suffix:semicolon
)brace
id|tcp_replace_ts_recent
c_func
(paren
id|tp
comma
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
)paren
suffix:semicolon
multiline_comment|/* step 3: check security and precedence [ignored] */
multiline_comment|/*&t;step 4:&n;&t; *&n;&t; *&t;Check for a SYN in window.&n;&t; */
r_if
c_cond
(paren
id|th-&gt;syn
op_logical_and
op_logical_neg
id|before
c_func
(paren
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
comma
id|tp-&gt;rcv_nxt
)paren
)paren
(brace
id|NET_INC_STATS_BH
c_func
(paren
id|LINUX_MIB_TCPABORTONSYN
)paren
suffix:semicolon
id|tcp_reset
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* step 5: check the ACK field */
r_if
c_cond
(paren
id|th-&gt;ack
)paren
(brace
r_int
id|acceptable
op_assign
id|tcp_ack
c_func
(paren
id|sk
comma
id|skb
comma
id|FLAG_SLOWPATH
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|sk-&gt;sk_state
)paren
(brace
r_case
id|TCP_SYN_RECV
suffix:colon
r_if
c_cond
(paren
id|acceptable
)paren
(brace
id|tp-&gt;copied_seq
op_assign
id|tp-&gt;rcv_nxt
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
id|tcp_set_state
c_func
(paren
id|sk
comma
id|TCP_ESTABLISHED
)paren
suffix:semicolon
id|sk
op_member_access_from_pointer
id|sk_state_change
c_func
(paren
id|sk
)paren
suffix:semicolon
multiline_comment|/* Note, that this wakeup is only for marginal&n;&t;&t;&t;&t; * crossed SYN case. Passively open sockets&n;&t;&t;&t;&t; * are not waked up, because sk-&gt;sk_sleep ==&n;&t;&t;&t;&t; * NULL and sk-&gt;sk_socket == NULL.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|sk-&gt;sk_socket
)paren
(brace
id|sk_wake_async
c_func
(paren
id|sk
comma
l_int|0
comma
id|POLL_OUT
)paren
suffix:semicolon
)brace
id|tp-&gt;snd_una
op_assign
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|ack_seq
suffix:semicolon
id|tp-&gt;snd_wnd
op_assign
id|ntohs
c_func
(paren
id|th-&gt;window
)paren
op_lshift
id|tp-&gt;snd_wscale
suffix:semicolon
id|tcp_init_wl
c_func
(paren
id|tp
comma
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|ack_seq
comma
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
)paren
suffix:semicolon
multiline_comment|/* tcp_ack considers this ACK as duplicate&n;&t;&t;&t;&t; * and does not calculate rtt.&n;&t;&t;&t;&t; * Fix it at least with timestamps.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|tp-&gt;saw_tstamp
op_logical_and
id|tp-&gt;rcv_tsecr
op_logical_and
op_logical_neg
id|tp-&gt;srtt
)paren
id|tcp_ack_saw_tstamp
c_func
(paren
id|tp
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;tstamp_ok
)paren
id|tp-&gt;advmss
op_sub_assign
id|TCPOLEN_TSTAMP_ALIGNED
suffix:semicolon
multiline_comment|/* Make sure socket is routed, for&n;&t;&t;&t;&t; * correct metrics.&n;&t;&t;&t;&t; */
id|tp-&gt;af_specific
op_member_access_from_pointer
id|rebuild_header
c_func
(paren
id|sk
)paren
suffix:semicolon
id|tcp_init_metrics
c_func
(paren
id|sk
)paren
suffix:semicolon
multiline_comment|/* Prevent spurious tcp_cwnd_restart() on&n;&t;&t;&t;&t; * first data packet.&n;&t;&t;&t;&t; */
id|tp-&gt;lsndtime
op_assign
id|tcp_time_stamp
suffix:semicolon
id|tcp_initialize_rcv_mss
c_func
(paren
id|sk
)paren
suffix:semicolon
id|tcp_init_buffer_space
c_func
(paren
id|sk
)paren
suffix:semicolon
id|tcp_fast_path_on
c_func
(paren
id|tp
)paren
suffix:semicolon
)brace
r_else
(brace
r_return
l_int|1
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|TCP_FIN_WAIT1
suffix:colon
r_if
c_cond
(paren
id|tp-&gt;snd_una
op_eq
id|tp-&gt;write_seq
)paren
(brace
id|tcp_set_state
c_func
(paren
id|sk
comma
id|TCP_FIN_WAIT2
)paren
suffix:semicolon
id|sk-&gt;sk_shutdown
op_or_assign
id|SEND_SHUTDOWN
suffix:semicolon
id|dst_confirm
c_func
(paren
id|sk-&gt;sk_dst_cache
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sock_flag
c_func
(paren
id|sk
comma
id|SOCK_DEAD
)paren
)paren
multiline_comment|/* Wake up lingering close() */
id|sk
op_member_access_from_pointer
id|sk_state_change
c_func
(paren
id|sk
)paren
suffix:semicolon
r_else
(brace
r_int
id|tmo
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;linger2
OL
l_int|0
op_logical_or
(paren
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
op_ne
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
op_logical_and
id|after
c_func
(paren
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
op_minus
id|th-&gt;fin
comma
id|tp-&gt;rcv_nxt
)paren
)paren
)paren
(brace
id|tcp_done
c_func
(paren
id|sk
)paren
suffix:semicolon
id|NET_INC_STATS_BH
c_func
(paren
id|LINUX_MIB_TCPABORTONDATA
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|tmo
op_assign
id|tcp_fin_time
c_func
(paren
id|tp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmo
OG
id|TCP_TIMEWAIT_LEN
)paren
(brace
id|tcp_reset_keepalive_timer
c_func
(paren
id|sk
comma
id|tmo
op_minus
id|TCP_TIMEWAIT_LEN
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|th-&gt;fin
op_logical_or
id|sock_owned_by_user
c_func
(paren
id|sk
)paren
)paren
(brace
multiline_comment|/* Bad case. We could lose such FIN otherwise.&n;&t;&t;&t;&t;&t;&t; * It is not a big problem, but it looks confusing&n;&t;&t;&t;&t;&t;&t; * and not so rare event. We still can lose it now,&n;&t;&t;&t;&t;&t;&t; * if it spins in bh_lock_sock(), but it is really&n;&t;&t;&t;&t;&t;&t; * marginal case.&n;&t;&t;&t;&t;&t;&t; */
id|tcp_reset_keepalive_timer
c_func
(paren
id|sk
comma
id|tmo
)paren
suffix:semicolon
)brace
r_else
(brace
id|tcp_time_wait
c_func
(paren
id|sk
comma
id|TCP_FIN_WAIT2
comma
id|tmo
)paren
suffix:semicolon
r_goto
id|discard
suffix:semicolon
)brace
)brace
)brace
r_break
suffix:semicolon
r_case
id|TCP_CLOSING
suffix:colon
r_if
c_cond
(paren
id|tp-&gt;snd_una
op_eq
id|tp-&gt;write_seq
)paren
(brace
id|tcp_time_wait
c_func
(paren
id|sk
comma
id|TCP_TIME_WAIT
comma
l_int|0
)paren
suffix:semicolon
r_goto
id|discard
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|TCP_LAST_ACK
suffix:colon
r_if
c_cond
(paren
id|tp-&gt;snd_una
op_eq
id|tp-&gt;write_seq
)paren
(brace
id|tcp_update_metrics
c_func
(paren
id|sk
)paren
suffix:semicolon
id|tcp_done
c_func
(paren
id|sk
)paren
suffix:semicolon
r_goto
id|discard
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
)brace
r_else
r_goto
id|discard
suffix:semicolon
multiline_comment|/* step 6: check the URG bit */
id|tcp_urg
c_func
(paren
id|sk
comma
id|skb
comma
id|th
)paren
suffix:semicolon
multiline_comment|/* step 7: process the segment text */
r_switch
c_cond
(paren
id|sk-&gt;sk_state
)paren
(brace
r_case
id|TCP_CLOSE_WAIT
suffix:colon
r_case
id|TCP_CLOSING
suffix:colon
r_case
id|TCP_LAST_ACK
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|before
c_func
(paren
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
comma
id|tp-&gt;rcv_nxt
)paren
)paren
r_break
suffix:semicolon
r_case
id|TCP_FIN_WAIT1
suffix:colon
r_case
id|TCP_FIN_WAIT2
suffix:colon
multiline_comment|/* RFC 793 says to queue data in these states,&n;&t;&t; * RFC 1122 says we MUST send a reset. &n;&t;&t; * BSD 4.4 also does reset.&n;&t;&t; */
r_if
c_cond
(paren
id|sk-&gt;sk_shutdown
op_amp
id|RCV_SHUTDOWN
)paren
(brace
r_if
c_cond
(paren
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
op_ne
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
op_logical_and
id|after
c_func
(paren
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
op_minus
id|th-&gt;fin
comma
id|tp-&gt;rcv_nxt
)paren
)paren
(brace
id|NET_INC_STATS_BH
c_func
(paren
id|LINUX_MIB_TCPABORTONDATA
)paren
suffix:semicolon
id|tcp_reset
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/* Fall through */
r_case
id|TCP_ESTABLISHED
suffix:colon
id|tcp_data_queue
c_func
(paren
id|sk
comma
id|skb
)paren
suffix:semicolon
id|queued
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* tcp_data could move socket to TIME-WAIT */
r_if
c_cond
(paren
id|sk-&gt;sk_state
op_ne
id|TCP_CLOSE
)paren
(brace
id|tcp_data_snd_check
c_func
(paren
id|sk
)paren
suffix:semicolon
id|tcp_ack_snd_check
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|queued
)paren
(brace
id|discard
suffix:colon
id|__kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|sysctl_tcp_ecn
id|EXPORT_SYMBOL
c_func
(paren
id|sysctl_tcp_ecn
)paren
suffix:semicolon
DECL|variable|sysctl_tcp_reordering
id|EXPORT_SYMBOL
c_func
(paren
id|sysctl_tcp_reordering
)paren
suffix:semicolon
DECL|variable|tcp_parse_options
id|EXPORT_SYMBOL
c_func
(paren
id|tcp_parse_options
)paren
suffix:semicolon
DECL|variable|tcp_rcv_established
id|EXPORT_SYMBOL
c_func
(paren
id|tcp_rcv_established
)paren
suffix:semicolon
DECL|variable|tcp_rcv_state_process
id|EXPORT_SYMBOL
c_func
(paren
id|tcp_rcv_state_process
)paren
suffix:semicolon
eof
