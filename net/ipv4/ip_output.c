multiline_comment|/*&n; * INET&t;&t;An implementation of the TCP/IP protocol suite for the LINUX&n; *&t;&t;operating system.  INET is implemented using the  BSD Socket&n; *&t;&t;interface as the means of communication with the user level.&n; *&n; *&t;&t;The Internet Protocol (IP) output module.&n; *&n; * Version:&t;$Id: ip_output.c,v 1.100 2002/02/01 22:01:03 davem Exp $&n; *&n; * Authors:&t;Ross Biro, &lt;bir7@leland.Stanford.Edu&gt;&n; *&t;&t;Fred N. van Kempen, &lt;waltje@uWalt.NL.Mugnet.ORG&gt;&n; *&t;&t;Donald Becker, &lt;becker@super.org&gt;&n; *&t;&t;Alan Cox, &lt;Alan.Cox@linux.org&gt;&n; *&t;&t;Richard Underwood&n; *&t;&t;Stefan Becker, &lt;stefanb@yello.ping.de&gt;&n; *&t;&t;Jorge Cwik, &lt;jorge@laser.satlink.net&gt;&n; *&t;&t;Arnt Gulbrandsen, &lt;agulbra@nvg.unit.no&gt;&n; *&t;&t;Hirokazu Takahashi, &lt;taka@valinux.co.jp&gt;&n; *&n; *&t;See ip_input.c for original log&n; *&n; *&t;Fixes:&n; *&t;&t;Alan Cox&t;:&t;Missing nonblock feature in ip_build_xmit.&n; *&t;&t;Mike Kilburn&t;:&t;htons() missing in ip_build_xmit.&n; *&t;&t;Bradford Johnson:&t;Fix faulty handling of some frames when &n; *&t;&t;&t;&t;&t;no route is found.&n; *&t;&t;Alexander Demenshin:&t;Missing sk/skb free in ip_queue_xmit&n; *&t;&t;&t;&t;&t;(in case if packet not accepted by&n; *&t;&t;&t;&t;&t;output firewall rules)&n; *&t;&t;Mike McLagan&t;:&t;Routing by source&n; *&t;&t;Alexey Kuznetsov:&t;use new route cache&n; *&t;&t;Andi Kleen:&t;&t;Fix broken PMTU recovery and remove&n; *&t;&t;&t;&t;&t;some redundant tests.&n; *&t;Vitaly E. Lavrov&t;:&t;Transparent proxy revived after year coma.&n; *&t;&t;Andi Kleen&t;: &t;Replace ip_reply with ip_send_reply.&n; *&t;&t;Andi Kleen&t;:&t;Split fast and slow ip_build_xmit path &n; *&t;&t;&t;&t;&t;for decreased register pressure on x86 &n; *&t;&t;&t;&t;&t;and more readibility. &n; *&t;&t;Marc Boucher&t;:&t;When call_out_firewall returns FW_QUEUE,&n; *&t;&t;&t;&t;&t;silently drop skb instead of failing with -EPERM.&n; *&t;&t;Detlev Wengorz&t;:&t;Copy protocol for fragments.&n; *&t;&t;Hirokazu Takahashi:&t;HW checksumming for outgoing UDP&n; *&t;&t;&t;&t;&t;datagrams.&n; *&t;&t;Hirokazu Takahashi:&t;sendfile() on UDP works now.&n; */
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/socket.h&gt;
macro_line|#include &lt;linux/sockios.h&gt;
macro_line|#include &lt;linux/in.h&gt;
macro_line|#include &lt;linux/inet.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/etherdevice.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;linux/stat.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;net/snmp.h&gt;
macro_line|#include &lt;net/ip.h&gt;
macro_line|#include &lt;net/protocol.h&gt;
macro_line|#include &lt;net/route.h&gt;
macro_line|#include &lt;net/tcp.h&gt;
macro_line|#include &lt;net/udp.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;net/sock.h&gt;
macro_line|#include &lt;net/arp.h&gt;
macro_line|#include &lt;net/icmp.h&gt;
macro_line|#include &lt;net/raw.h&gt;
macro_line|#include &lt;net/checksum.h&gt;
macro_line|#include &lt;net/inetpeer.h&gt;
macro_line|#include &lt;net/checksum.h&gt;
macro_line|#include &lt;linux/igmp.h&gt;
macro_line|#include &lt;linux/netfilter_ipv4.h&gt;
macro_line|#include &lt;linux/netfilter_bridge.h&gt;
macro_line|#include &lt;linux/mroute.h&gt;
macro_line|#include &lt;linux/netlink.h&gt;
multiline_comment|/*&n; *      Shall we try to damage output packets if routing dev changes?&n; */
DECL|variable|sysctl_ip_dynaddr
r_int
id|sysctl_ip_dynaddr
suffix:semicolon
DECL|variable|sysctl_ip_default_ttl
r_int
id|sysctl_ip_default_ttl
op_assign
id|IPDEFTTL
suffix:semicolon
multiline_comment|/* Generate a checksum for an outgoing IP datagram. */
DECL|function|ip_send_check
id|__inline__
r_void
id|ip_send_check
c_func
(paren
r_struct
id|iphdr
op_star
id|iph
)paren
(brace
id|iph-&gt;check
op_assign
l_int|0
suffix:semicolon
id|iph-&gt;check
op_assign
id|ip_fast_csum
c_func
(paren
(paren
r_int
r_char
op_star
)paren
id|iph
comma
id|iph-&gt;ihl
)paren
suffix:semicolon
)brace
multiline_comment|/* dev_loopback_xmit for use with netfilter. */
DECL|function|ip_dev_loopback_xmit
r_static
r_int
id|ip_dev_loopback_xmit
c_func
(paren
r_struct
id|sk_buff
op_star
id|newskb
)paren
(brace
id|newskb-&gt;mac.raw
op_assign
id|newskb-&gt;data
suffix:semicolon
id|__skb_pull
c_func
(paren
id|newskb
comma
id|newskb-&gt;nh.raw
op_minus
id|newskb-&gt;data
)paren
suffix:semicolon
id|newskb-&gt;pkt_type
op_assign
id|PACKET_LOOPBACK
suffix:semicolon
id|newskb-&gt;ip_summed
op_assign
id|CHECKSUM_UNNECESSARY
suffix:semicolon
id|BUG_TRAP
c_func
(paren
id|newskb-&gt;dst
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_NETFILTER_DEBUG
id|nf_debug_ip_loopback_xmit
c_func
(paren
id|newskb
)paren
suffix:semicolon
macro_line|#endif
id|netif_rx
c_func
(paren
id|newskb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ip_select_ttl
r_static
r_inline
r_int
id|ip_select_ttl
c_func
(paren
r_struct
id|inet_opt
op_star
id|inet
comma
r_struct
id|dst_entry
op_star
id|dst
)paren
(brace
r_int
id|ttl
op_assign
id|inet-&gt;uc_ttl
suffix:semicolon
r_if
c_cond
(paren
id|ttl
OL
l_int|0
)paren
id|ttl
op_assign
id|dst_metric
c_func
(paren
id|dst
comma
id|RTAX_HOPLIMIT
)paren
suffix:semicolon
r_return
id|ttl
suffix:semicolon
)brace
multiline_comment|/* &n; *&t;&t;Add an ip header to a skbuff and send it out.&n; *&n; */
DECL|function|ip_build_and_send_pkt
r_int
id|ip_build_and_send_pkt
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|sock
op_star
id|sk
comma
id|u32
id|saddr
comma
id|u32
id|daddr
comma
r_struct
id|ip_options
op_star
id|opt
)paren
(brace
r_struct
id|inet_opt
op_star
id|inet
op_assign
id|inet_sk
c_func
(paren
id|sk
)paren
suffix:semicolon
r_struct
id|rtable
op_star
id|rt
op_assign
(paren
r_struct
id|rtable
op_star
)paren
id|skb-&gt;dst
suffix:semicolon
r_struct
id|iphdr
op_star
id|iph
suffix:semicolon
multiline_comment|/* Build the IP header. */
r_if
c_cond
(paren
id|opt
)paren
id|iph
op_assign
(paren
r_struct
id|iphdr
op_star
)paren
id|skb_push
c_func
(paren
id|skb
comma
r_sizeof
(paren
r_struct
id|iphdr
)paren
op_plus
id|opt-&gt;optlen
)paren
suffix:semicolon
r_else
id|iph
op_assign
(paren
r_struct
id|iphdr
op_star
)paren
id|skb_push
c_func
(paren
id|skb
comma
r_sizeof
(paren
r_struct
id|iphdr
)paren
)paren
suffix:semicolon
id|iph-&gt;version
op_assign
l_int|4
suffix:semicolon
id|iph-&gt;ihl
op_assign
l_int|5
suffix:semicolon
id|iph-&gt;tos
op_assign
id|inet-&gt;tos
suffix:semicolon
r_if
c_cond
(paren
id|ip_dont_fragment
c_func
(paren
id|sk
comma
op_amp
id|rt-&gt;u.dst
)paren
)paren
id|iph-&gt;frag_off
op_assign
id|htons
c_func
(paren
id|IP_DF
)paren
suffix:semicolon
r_else
id|iph-&gt;frag_off
op_assign
l_int|0
suffix:semicolon
id|iph-&gt;ttl
op_assign
id|ip_select_ttl
c_func
(paren
id|inet
comma
op_amp
id|rt-&gt;u.dst
)paren
suffix:semicolon
id|iph-&gt;daddr
op_assign
id|rt-&gt;rt_dst
suffix:semicolon
id|iph-&gt;saddr
op_assign
id|rt-&gt;rt_src
suffix:semicolon
id|iph-&gt;protocol
op_assign
id|sk-&gt;sk_protocol
suffix:semicolon
id|iph-&gt;tot_len
op_assign
id|htons
c_func
(paren
id|skb-&gt;len
)paren
suffix:semicolon
id|ip_select_ident
c_func
(paren
id|iph
comma
op_amp
id|rt-&gt;u.dst
comma
id|sk
)paren
suffix:semicolon
id|skb-&gt;nh.iph
op_assign
id|iph
suffix:semicolon
r_if
c_cond
(paren
id|opt
op_logical_and
id|opt-&gt;optlen
)paren
(brace
id|iph-&gt;ihl
op_add_assign
id|opt-&gt;optlen
op_rshift
l_int|2
suffix:semicolon
id|ip_options_build
c_func
(paren
id|skb
comma
id|opt
comma
id|daddr
comma
id|rt
comma
l_int|0
)paren
suffix:semicolon
)brace
id|ip_send_check
c_func
(paren
id|iph
)paren
suffix:semicolon
id|skb-&gt;priority
op_assign
id|sk-&gt;sk_priority
suffix:semicolon
multiline_comment|/* Send it out. */
r_return
id|NF_HOOK
c_func
(paren
id|PF_INET
comma
id|NF_IP_LOCAL_OUT
comma
id|skb
comma
l_int|NULL
comma
id|rt-&gt;u.dst.dev
comma
id|dst_output
)paren
suffix:semicolon
)brace
DECL|function|ip_finish_output2
r_static
r_inline
r_int
id|ip_finish_output2
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|dst_entry
op_star
id|dst
op_assign
id|skb-&gt;dst
suffix:semicolon
r_struct
id|hh_cache
op_star
id|hh
op_assign
id|dst-&gt;hh
suffix:semicolon
r_struct
id|net_device
op_star
id|dev
op_assign
id|dst-&gt;dev
suffix:semicolon
r_int
id|hh_len
op_assign
id|LL_RESERVED_SPACE
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Be paranoid, rather than too clever. */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|skb_headroom
c_func
(paren
id|skb
)paren
OL
id|hh_len
op_logical_and
id|dev-&gt;hard_header
)paren
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb2
suffix:semicolon
id|skb2
op_assign
id|skb_realloc_headroom
c_func
(paren
id|skb
comma
id|LL_RESERVED_SPACE
c_func
(paren
id|dev
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb2
op_eq
l_int|NULL
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_if
c_cond
(paren
id|skb-&gt;sk
)paren
id|skb_set_owner_w
c_func
(paren
id|skb2
comma
id|skb-&gt;sk
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
id|skb
op_assign
id|skb2
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_NETFILTER_DEBUG
id|nf_debug_ip_finish_output2
c_func
(paren
id|skb
)paren
suffix:semicolon
macro_line|#endif /*CONFIG_NETFILTER_DEBUG*/
r_if
c_cond
(paren
id|hh
)paren
(brace
r_int
id|hh_alen
suffix:semicolon
id|read_lock_bh
c_func
(paren
op_amp
id|hh-&gt;hh_lock
)paren
suffix:semicolon
id|hh_alen
op_assign
id|HH_DATA_ALIGN
c_func
(paren
id|hh-&gt;hh_len
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|skb-&gt;data
op_minus
id|hh_alen
comma
id|hh-&gt;hh_data
comma
id|hh_alen
)paren
suffix:semicolon
id|read_unlock_bh
c_func
(paren
op_amp
id|hh-&gt;hh_lock
)paren
suffix:semicolon
id|skb_push
c_func
(paren
id|skb
comma
id|hh-&gt;hh_len
)paren
suffix:semicolon
r_return
id|hh
op_member_access_from_pointer
id|hh_output
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|dst-&gt;neighbour
)paren
r_return
id|dst-&gt;neighbour
op_member_access_from_pointer
id|output
c_func
(paren
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|net_ratelimit
c_func
(paren
)paren
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;ip_finish_output2: No header cache and no neighbour!&bslash;n&quot;
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
DECL|function|ip_finish_output
r_int
id|ip_finish_output
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|net_device
op_star
id|dev
op_assign
id|skb-&gt;dst-&gt;dev
suffix:semicolon
id|skb-&gt;dev
op_assign
id|dev
suffix:semicolon
id|skb-&gt;protocol
op_assign
id|htons
c_func
(paren
id|ETH_P_IP
)paren
suffix:semicolon
r_return
id|NF_HOOK
c_func
(paren
id|PF_INET
comma
id|NF_IP_POST_ROUTING
comma
id|skb
comma
l_int|NULL
comma
id|dev
comma
id|ip_finish_output2
)paren
suffix:semicolon
)brace
DECL|function|ip_mc_output
r_int
id|ip_mc_output
c_func
(paren
r_struct
id|sk_buff
op_star
op_star
id|pskb
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
op_assign
op_star
id|pskb
suffix:semicolon
r_struct
id|sock
op_star
id|sk
op_assign
id|skb-&gt;sk
suffix:semicolon
r_struct
id|rtable
op_star
id|rt
op_assign
(paren
r_struct
id|rtable
op_star
)paren
id|skb-&gt;dst
suffix:semicolon
r_struct
id|net_device
op_star
id|dev
op_assign
id|rt-&gt;u.dst.dev
suffix:semicolon
multiline_comment|/*&n;&t; *&t;If the indicated interface is up and running, send the packet.&n;&t; */
id|IP_INC_STATS
c_func
(paren
id|IPSTATS_MIB_OUTREQUESTS
)paren
suffix:semicolon
id|skb-&gt;dev
op_assign
id|dev
suffix:semicolon
id|skb-&gt;protocol
op_assign
id|htons
c_func
(paren
id|ETH_P_IP
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Multicasts are looped back for other local users&n;&t; */
r_if
c_cond
(paren
id|rt-&gt;rt_flags
op_amp
id|RTCF_MULTICAST
)paren
(brace
r_if
c_cond
(paren
(paren
op_logical_neg
id|sk
op_logical_or
id|inet_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|mc_loop
)paren
macro_line|#ifdef CONFIG_IP_MROUTE
multiline_comment|/* Small optimization: do not loopback not local frames,&n;&t;&t;   which returned after forwarding; they will be  dropped&n;&t;&t;   by ip_mr_input in any case.&n;&t;&t;   Note, that local frames are looped back to be delivered&n;&t;&t;   to local recipients.&n;&n;&t;&t;   This check is duplicated in ip_mr_input at the moment.&n;&t;&t; */
op_logical_and
(paren
(paren
id|rt-&gt;rt_flags
op_amp
id|RTCF_LOCAL
)paren
op_logical_or
op_logical_neg
(paren
id|IPCB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|flags
op_amp
id|IPSKB_FORWARDED
)paren
)paren
macro_line|#endif
)paren
(brace
r_struct
id|sk_buff
op_star
id|newskb
op_assign
id|skb_clone
c_func
(paren
id|skb
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|newskb
)paren
id|NF_HOOK
c_func
(paren
id|PF_INET
comma
id|NF_IP_POST_ROUTING
comma
id|newskb
comma
l_int|NULL
comma
id|newskb-&gt;dev
comma
id|ip_dev_loopback_xmit
)paren
suffix:semicolon
)brace
multiline_comment|/* Multicasts with ttl 0 must not go beyond the host */
r_if
c_cond
(paren
id|skb-&gt;nh.iph-&gt;ttl
op_eq
l_int|0
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|rt-&gt;rt_flags
op_amp
id|RTCF_BROADCAST
)paren
(brace
r_struct
id|sk_buff
op_star
id|newskb
op_assign
id|skb_clone
c_func
(paren
id|skb
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|newskb
)paren
id|NF_HOOK
c_func
(paren
id|PF_INET
comma
id|NF_IP_POST_ROUTING
comma
id|newskb
comma
l_int|NULL
comma
id|newskb-&gt;dev
comma
id|ip_dev_loopback_xmit
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|skb-&gt;len
OG
id|dst_pmtu
c_func
(paren
op_amp
id|rt-&gt;u.dst
)paren
op_logical_or
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|frag_list
)paren
r_return
id|ip_fragment
c_func
(paren
id|skb
comma
id|ip_finish_output
)paren
suffix:semicolon
r_else
r_return
id|ip_finish_output
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
DECL|function|ip_output
r_int
id|ip_output
c_func
(paren
r_struct
id|sk_buff
op_star
op_star
id|pskb
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
op_assign
op_star
id|pskb
suffix:semicolon
id|IP_INC_STATS
c_func
(paren
id|IPSTATS_MIB_OUTREQUESTS
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|skb-&gt;len
OG
id|dst_pmtu
c_func
(paren
id|skb-&gt;dst
)paren
op_logical_or
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|frag_list
)paren
op_logical_and
op_logical_neg
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|tso_size
)paren
r_return
id|ip_fragment
c_func
(paren
id|skb
comma
id|ip_finish_output
)paren
suffix:semicolon
r_else
r_return
id|ip_finish_output
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
DECL|function|ip_queue_xmit
r_int
id|ip_queue_xmit
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|ipfragok
)paren
(brace
r_struct
id|sock
op_star
id|sk
op_assign
id|skb-&gt;sk
suffix:semicolon
r_struct
id|inet_opt
op_star
id|inet
op_assign
id|inet_sk
c_func
(paren
id|sk
)paren
suffix:semicolon
r_struct
id|ip_options
op_star
id|opt
op_assign
id|inet-&gt;opt
suffix:semicolon
r_struct
id|rtable
op_star
id|rt
suffix:semicolon
r_struct
id|iphdr
op_star
id|iph
suffix:semicolon
id|u32
id|mtu
suffix:semicolon
multiline_comment|/* Skip all of this if the packet is already routed,&n;&t; * f.e. by something like SCTP.&n;&t; */
id|rt
op_assign
(paren
r_struct
id|rtable
op_star
)paren
id|skb-&gt;dst
suffix:semicolon
r_if
c_cond
(paren
id|rt
op_ne
l_int|NULL
)paren
r_goto
id|packet_routed
suffix:semicolon
multiline_comment|/* Make sure we can route this packet. */
id|rt
op_assign
(paren
r_struct
id|rtable
op_star
)paren
id|__sk_dst_check
c_func
(paren
id|sk
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rt
op_eq
l_int|NULL
)paren
(brace
id|u32
id|daddr
suffix:semicolon
multiline_comment|/* Use correct destination address if we have options. */
id|daddr
op_assign
id|inet-&gt;daddr
suffix:semicolon
r_if
c_cond
(paren
id|opt
op_logical_and
id|opt-&gt;srr
)paren
(brace
id|daddr
op_assign
id|opt-&gt;faddr
suffix:semicolon
)brace
(brace
r_struct
id|flowi
id|fl
op_assign
(brace
dot
id|oif
op_assign
id|sk-&gt;sk_bound_dev_if
comma
dot
id|nl_u
op_assign
(brace
dot
id|ip4_u
op_assign
(brace
dot
id|daddr
op_assign
id|daddr
comma
dot
id|saddr
op_assign
id|inet-&gt;saddr
comma
dot
id|tos
op_assign
id|RT_CONN_FLAGS
c_func
(paren
id|sk
)paren
)brace
)brace
comma
dot
id|proto
op_assign
id|sk-&gt;sk_protocol
comma
dot
id|uli_u
op_assign
(brace
dot
id|ports
op_assign
(brace
dot
id|sport
op_assign
id|inet-&gt;sport
comma
dot
id|dport
op_assign
id|inet-&gt;dport
)brace
)brace
)brace
suffix:semicolon
multiline_comment|/* If this fails, retransmit mechanism of transport layer will&n;&t;&t;&t; * keep trying until route appears or the connection times&n;&t;&t;&t; * itself out.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|ip_route_output_flow
c_func
(paren
op_amp
id|rt
comma
op_amp
id|fl
comma
id|sk
comma
l_int|0
)paren
)paren
r_goto
id|no_route
suffix:semicolon
)brace
id|__sk_dst_set
c_func
(paren
id|sk
comma
op_amp
id|rt-&gt;u.dst
)paren
suffix:semicolon
id|tcp_v4_setup_caps
c_func
(paren
id|sk
comma
op_amp
id|rt-&gt;u.dst
)paren
suffix:semicolon
)brace
id|skb-&gt;dst
op_assign
id|dst_clone
c_func
(paren
op_amp
id|rt-&gt;u.dst
)paren
suffix:semicolon
id|packet_routed
suffix:colon
r_if
c_cond
(paren
id|opt
op_logical_and
id|opt-&gt;is_strictroute
op_logical_and
id|rt-&gt;rt_dst
op_ne
id|rt-&gt;rt_gateway
)paren
r_goto
id|no_route
suffix:semicolon
multiline_comment|/* OK, we know where to send it, allocate and build IP header. */
id|iph
op_assign
(paren
r_struct
id|iphdr
op_star
)paren
id|skb_push
c_func
(paren
id|skb
comma
r_sizeof
(paren
r_struct
id|iphdr
)paren
op_plus
(paren
id|opt
ques
c_cond
id|opt-&gt;optlen
suffix:colon
l_int|0
)paren
)paren
suffix:semicolon
op_star
(paren
(paren
id|__u16
op_star
)paren
id|iph
)paren
op_assign
id|htons
c_func
(paren
(paren
l_int|4
op_lshift
l_int|12
)paren
op_or
(paren
l_int|5
op_lshift
l_int|8
)paren
op_or
(paren
id|inet-&gt;tos
op_amp
l_int|0xff
)paren
)paren
suffix:semicolon
id|iph-&gt;tot_len
op_assign
id|htons
c_func
(paren
id|skb-&gt;len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ip_dont_fragment
c_func
(paren
id|sk
comma
op_amp
id|rt-&gt;u.dst
)paren
op_logical_and
op_logical_neg
id|ipfragok
)paren
id|iph-&gt;frag_off
op_assign
id|htons
c_func
(paren
id|IP_DF
)paren
suffix:semicolon
r_else
id|iph-&gt;frag_off
op_assign
l_int|0
suffix:semicolon
id|iph-&gt;ttl
op_assign
id|ip_select_ttl
c_func
(paren
id|inet
comma
op_amp
id|rt-&gt;u.dst
)paren
suffix:semicolon
id|iph-&gt;protocol
op_assign
id|sk-&gt;sk_protocol
suffix:semicolon
id|iph-&gt;saddr
op_assign
id|rt-&gt;rt_src
suffix:semicolon
id|iph-&gt;daddr
op_assign
id|rt-&gt;rt_dst
suffix:semicolon
id|skb-&gt;nh.iph
op_assign
id|iph
suffix:semicolon
multiline_comment|/* Transport layer set skb-&gt;h.foo itself. */
r_if
c_cond
(paren
id|opt
op_logical_and
id|opt-&gt;optlen
)paren
(brace
id|iph-&gt;ihl
op_add_assign
id|opt-&gt;optlen
op_rshift
l_int|2
suffix:semicolon
id|ip_options_build
c_func
(paren
id|skb
comma
id|opt
comma
id|inet-&gt;daddr
comma
id|rt
comma
l_int|0
)paren
suffix:semicolon
)brace
id|mtu
op_assign
id|dst_pmtu
c_func
(paren
op_amp
id|rt-&gt;u.dst
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb-&gt;len
OG
id|mtu
op_logical_and
(paren
id|sk-&gt;sk_route_caps
op_amp
id|NETIF_F_TSO
)paren
)paren
(brace
r_int
r_int
id|hlen
suffix:semicolon
multiline_comment|/* Hack zone: all this must be done by TCP. */
id|hlen
op_assign
(paren
(paren
id|skb-&gt;h.raw
op_minus
id|skb-&gt;data
)paren
op_plus
(paren
id|skb-&gt;h.th-&gt;doff
op_lshift
l_int|2
)paren
)paren
suffix:semicolon
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|tso_size
op_assign
id|mtu
op_minus
id|hlen
suffix:semicolon
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|tso_segs
op_assign
(paren
id|skb-&gt;len
op_minus
id|hlen
op_plus
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|tso_size
op_minus
l_int|1
)paren
op_div
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|tso_size
op_minus
l_int|1
suffix:semicolon
)brace
id|ip_select_ident_more
c_func
(paren
id|iph
comma
op_amp
id|rt-&gt;u.dst
comma
id|sk
comma
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|tso_segs
)paren
suffix:semicolon
multiline_comment|/* Add an IP checksum. */
id|ip_send_check
c_func
(paren
id|iph
)paren
suffix:semicolon
id|skb-&gt;priority
op_assign
id|sk-&gt;sk_priority
suffix:semicolon
r_return
id|NF_HOOK
c_func
(paren
id|PF_INET
comma
id|NF_IP_LOCAL_OUT
comma
id|skb
comma
l_int|NULL
comma
id|rt-&gt;u.dst.dev
comma
id|dst_output
)paren
suffix:semicolon
id|no_route
suffix:colon
id|IP_INC_STATS
c_func
(paren
id|IPSTATS_MIB_OUTNOROUTES
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
op_minus
id|EHOSTUNREACH
suffix:semicolon
)brace
DECL|function|ip_copy_metadata
r_static
r_void
id|ip_copy_metadata
c_func
(paren
r_struct
id|sk_buff
op_star
id|to
comma
r_struct
id|sk_buff
op_star
id|from
)paren
(brace
id|to-&gt;pkt_type
op_assign
id|from-&gt;pkt_type
suffix:semicolon
id|to-&gt;priority
op_assign
id|from-&gt;priority
suffix:semicolon
id|to-&gt;protocol
op_assign
id|from-&gt;protocol
suffix:semicolon
id|to-&gt;security
op_assign
id|from-&gt;security
suffix:semicolon
id|to-&gt;dst
op_assign
id|dst_clone
c_func
(paren
id|from-&gt;dst
)paren
suffix:semicolon
id|to-&gt;dev
op_assign
id|from-&gt;dev
suffix:semicolon
multiline_comment|/* Copy the flags to each fragment. */
id|IPCB
c_func
(paren
id|to
)paren
op_member_access_from_pointer
id|flags
op_assign
id|IPCB
c_func
(paren
id|from
)paren
op_member_access_from_pointer
id|flags
suffix:semicolon
macro_line|#ifdef CONFIG_NET_SCHED
id|to-&gt;tc_index
op_assign
id|from-&gt;tc_index
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_NETFILTER
id|to-&gt;nfmark
op_assign
id|from-&gt;nfmark
suffix:semicolon
id|to-&gt;nfcache
op_assign
id|from-&gt;nfcache
suffix:semicolon
multiline_comment|/* Connection association is same as pre-frag packet */
id|nf_conntrack_put
c_func
(paren
id|to-&gt;nfct
)paren
suffix:semicolon
id|to-&gt;nfct
op_assign
id|from-&gt;nfct
suffix:semicolon
id|nf_conntrack_get
c_func
(paren
id|to-&gt;nfct
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_BRIDGE_NETFILTER
id|nf_bridge_put
c_func
(paren
id|to-&gt;nf_bridge
)paren
suffix:semicolon
id|to-&gt;nf_bridge
op_assign
id|from-&gt;nf_bridge
suffix:semicolon
id|nf_bridge_get
c_func
(paren
id|to-&gt;nf_bridge
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_NETFILTER_DEBUG
id|to-&gt;nf_debug
op_assign
id|from-&gt;nf_debug
suffix:semicolon
macro_line|#endif
macro_line|#endif
)brace
multiline_comment|/*&n; *&t;This IP datagram is too large to be sent in one piece.  Break it up into&n; *&t;smaller pieces (each of size equal to IP header plus&n; *&t;a block of the data of the original IP data part) that will yet fit in a&n; *&t;single device frame, and queue such a frame for sending.&n; */
DECL|function|ip_fragment
r_int
id|ip_fragment
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
(paren
op_star
id|output
)paren
(paren
r_struct
id|sk_buff
op_star
)paren
)paren
(brace
r_struct
id|iphdr
op_star
id|iph
suffix:semicolon
r_int
id|raw
op_assign
l_int|0
suffix:semicolon
r_int
id|ptr
suffix:semicolon
r_struct
id|net_device
op_star
id|dev
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb2
suffix:semicolon
r_int
r_int
id|mtu
comma
id|hlen
comma
id|left
comma
id|len
comma
id|ll_rs
suffix:semicolon
r_int
id|offset
suffix:semicolon
r_int
id|not_last_frag
suffix:semicolon
r_struct
id|rtable
op_star
id|rt
op_assign
(paren
r_struct
id|rtable
op_star
)paren
id|skb-&gt;dst
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
id|dev
op_assign
id|rt-&gt;u.dst.dev
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Point into the IP datagram header.&n;&t; */
id|iph
op_assign
id|skb-&gt;nh.iph
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
(paren
id|iph-&gt;frag_off
op_amp
id|htons
c_func
(paren
id|IP_DF
)paren
)paren
op_logical_and
op_logical_neg
id|skb-&gt;local_df
)paren
)paren
(brace
id|icmp_send
c_func
(paren
id|skb
comma
id|ICMP_DEST_UNREACH
comma
id|ICMP_FRAG_NEEDED
comma
id|htonl
c_func
(paren
id|dst_pmtu
c_func
(paren
op_amp
id|rt-&gt;u.dst
)paren
)paren
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
op_minus
id|EMSGSIZE
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Setup starting values.&n;&t; */
id|hlen
op_assign
id|iph-&gt;ihl
op_star
l_int|4
suffix:semicolon
id|mtu
op_assign
id|dst_pmtu
c_func
(paren
op_amp
id|rt-&gt;u.dst
)paren
op_minus
id|hlen
suffix:semicolon
multiline_comment|/* Size of data space */
multiline_comment|/* When frag_list is given, use it. First, check its validity:&n;&t; * some transformers could create wrong frag_list or break existing&n;&t; * one, it is not prohibited. In this case fall back to copying.&n;&t; *&n;&t; * LATER: this step can be merged to real generation of fragments,&n;&t; * we can switch to copy when see the first bad fragment.&n;&t; */
r_if
c_cond
(paren
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|frag_list
)paren
(brace
r_struct
id|sk_buff
op_star
id|frag
suffix:semicolon
r_int
id|first_len
op_assign
id|skb_pagelen
c_func
(paren
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|first_len
op_minus
id|hlen
OG
id|mtu
op_logical_or
(paren
(paren
id|first_len
op_minus
id|hlen
)paren
op_amp
l_int|7
)paren
op_logical_or
(paren
id|iph-&gt;frag_off
op_amp
id|htons
c_func
(paren
id|IP_MF
op_or
id|IP_OFFSET
)paren
)paren
op_logical_or
id|skb_cloned
c_func
(paren
id|skb
)paren
)paren
r_goto
id|slow_path
suffix:semicolon
r_for
c_loop
(paren
id|frag
op_assign
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|frag_list
suffix:semicolon
id|frag
suffix:semicolon
id|frag
op_assign
id|frag-&gt;next
)paren
(brace
multiline_comment|/* Correct geometry. */
r_if
c_cond
(paren
id|frag-&gt;len
OG
id|mtu
op_logical_or
(paren
(paren
id|frag-&gt;len
op_amp
l_int|7
)paren
op_logical_and
id|frag-&gt;next
)paren
op_logical_or
id|skb_headroom
c_func
(paren
id|frag
)paren
OL
id|hlen
)paren
r_goto
id|slow_path
suffix:semicolon
multiline_comment|/* Partially cloned skb? */
r_if
c_cond
(paren
id|skb_shared
c_func
(paren
id|frag
)paren
)paren
r_goto
id|slow_path
suffix:semicolon
)brace
multiline_comment|/* Everything is OK. Generate! */
id|err
op_assign
l_int|0
suffix:semicolon
id|offset
op_assign
l_int|0
suffix:semicolon
id|frag
op_assign
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|frag_list
suffix:semicolon
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|frag_list
op_assign
l_int|NULL
suffix:semicolon
id|skb-&gt;data_len
op_assign
id|first_len
op_minus
id|skb_headlen
c_func
(paren
id|skb
)paren
suffix:semicolon
id|skb-&gt;len
op_assign
id|first_len
suffix:semicolon
id|iph-&gt;tot_len
op_assign
id|htons
c_func
(paren
id|first_len
)paren
suffix:semicolon
id|iph-&gt;frag_off
op_or_assign
id|htons
c_func
(paren
id|IP_MF
)paren
suffix:semicolon
id|ip_send_check
c_func
(paren
id|iph
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
multiline_comment|/* Prepare header of the next frame,&n;&t;&t;&t; * before previous one went down. */
r_if
c_cond
(paren
id|frag
)paren
(brace
id|frag-&gt;h.raw
op_assign
id|frag-&gt;data
suffix:semicolon
id|frag-&gt;nh.raw
op_assign
id|__skb_push
c_func
(paren
id|frag
comma
id|hlen
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|frag-&gt;nh.raw
comma
id|iph
comma
id|hlen
)paren
suffix:semicolon
id|iph
op_assign
id|frag-&gt;nh.iph
suffix:semicolon
id|iph-&gt;tot_len
op_assign
id|htons
c_func
(paren
id|frag-&gt;len
)paren
suffix:semicolon
id|ip_copy_metadata
c_func
(paren
id|frag
comma
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|offset
op_eq
l_int|0
)paren
id|ip_options_fragment
c_func
(paren
id|frag
)paren
suffix:semicolon
id|offset
op_add_assign
id|skb-&gt;len
op_minus
id|hlen
suffix:semicolon
id|iph-&gt;frag_off
op_assign
id|htons
c_func
(paren
id|offset
op_rshift
l_int|3
)paren
suffix:semicolon
r_if
c_cond
(paren
id|frag-&gt;next
op_ne
l_int|NULL
)paren
id|iph-&gt;frag_off
op_or_assign
id|htons
c_func
(paren
id|IP_MF
)paren
suffix:semicolon
multiline_comment|/* Ready, complete checksum */
id|ip_send_check
c_func
(paren
id|iph
)paren
suffix:semicolon
)brace
id|err
op_assign
id|output
c_func
(paren
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_logical_or
op_logical_neg
id|frag
)paren
r_break
suffix:semicolon
id|skb
op_assign
id|frag
suffix:semicolon
id|frag
op_assign
id|skb-&gt;next
suffix:semicolon
id|skb-&gt;next
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|err
op_eq
l_int|0
)paren
(brace
id|IP_INC_STATS
c_func
(paren
id|IPSTATS_MIB_FRAGOKS
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_while
c_loop
(paren
id|frag
)paren
(brace
id|skb
op_assign
id|frag-&gt;next
suffix:semicolon
id|kfree_skb
c_func
(paren
id|frag
)paren
suffix:semicolon
id|frag
op_assign
id|skb
suffix:semicolon
)brace
id|IP_INC_STATS
c_func
(paren
id|IPSTATS_MIB_FRAGFAILS
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
id|slow_path
suffix:colon
id|left
op_assign
id|skb-&gt;len
op_minus
id|hlen
suffix:semicolon
multiline_comment|/* Space per frame */
id|ptr
op_assign
id|raw
op_plus
id|hlen
suffix:semicolon
multiline_comment|/* Where to start from */
macro_line|#ifdef CONFIG_BRIDGE_NETFILTER
multiline_comment|/* for bridged IP traffic encapsulated inside f.e. a vlan header,&n;&t; * we need to make room for the encapsulating header */
id|ll_rs
op_assign
id|LL_RESERVED_SPACE_EXTRA
c_func
(paren
id|rt-&gt;u.dst.dev
comma
id|nf_bridge_pad
c_func
(paren
id|skb
)paren
)paren
suffix:semicolon
id|mtu
op_sub_assign
id|nf_bridge_pad
c_func
(paren
id|skb
)paren
suffix:semicolon
macro_line|#else
id|ll_rs
op_assign
id|LL_RESERVED_SPACE
c_func
(paren
id|rt-&gt;u.dst.dev
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; *&t;Fragment the datagram.&n;&t; */
id|offset
op_assign
(paren
id|ntohs
c_func
(paren
id|iph-&gt;frag_off
)paren
op_amp
id|IP_OFFSET
)paren
op_lshift
l_int|3
suffix:semicolon
id|not_last_frag
op_assign
id|iph-&gt;frag_off
op_amp
id|htons
c_func
(paren
id|IP_MF
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Keep copying data until we run out.&n;&t; */
r_while
c_loop
(paren
id|left
OG
l_int|0
)paren
(brace
id|len
op_assign
id|left
suffix:semicolon
multiline_comment|/* IF: it doesn&squot;t fit, use &squot;mtu&squot; - the data space left */
r_if
c_cond
(paren
id|len
OG
id|mtu
)paren
id|len
op_assign
id|mtu
suffix:semicolon
multiline_comment|/* IF: we are not sending upto and including the packet end&n;&t;&t;   then align the next start on an eight byte boundary */
r_if
c_cond
(paren
id|len
OL
id|left
)paren
(brace
id|len
op_and_assign
op_complement
l_int|7
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; *&t;Allocate buffer.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|skb2
op_assign
id|alloc_skb
c_func
(paren
id|len
op_plus
id|hlen
op_plus
id|ll_rs
comma
id|GFP_ATOMIC
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|NETDEBUG
c_func
(paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;IP: frag: no memory for new fragment!&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|fail
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; *&t;Set up data on packet&n;&t;&t; */
id|ip_copy_metadata
c_func
(paren
id|skb2
comma
id|skb
)paren
suffix:semicolon
id|skb_reserve
c_func
(paren
id|skb2
comma
id|ll_rs
)paren
suffix:semicolon
id|skb_put
c_func
(paren
id|skb2
comma
id|len
op_plus
id|hlen
)paren
suffix:semicolon
id|skb2-&gt;nh.raw
op_assign
id|skb2-&gt;data
suffix:semicolon
id|skb2-&gt;h.raw
op_assign
id|skb2-&gt;data
op_plus
id|hlen
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Charge the memory for the fragment to any owner&n;&t;&t; *&t;it might possess&n;&t;&t; */
r_if
c_cond
(paren
id|skb-&gt;sk
)paren
id|skb_set_owner_w
c_func
(paren
id|skb2
comma
id|skb-&gt;sk
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Copy the packet header into the new buffer.&n;&t;&t; */
id|memcpy
c_func
(paren
id|skb2-&gt;nh.raw
comma
id|skb-&gt;data
comma
id|hlen
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Copy a block of the IP datagram.&n;&t;&t; */
r_if
c_cond
(paren
id|skb_copy_bits
c_func
(paren
id|skb
comma
id|ptr
comma
id|skb2-&gt;h.raw
comma
id|len
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|left
op_sub_assign
id|len
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Fill in the new header fields.&n;&t;&t; */
id|iph
op_assign
id|skb2-&gt;nh.iph
suffix:semicolon
id|iph-&gt;frag_off
op_assign
id|htons
c_func
(paren
(paren
id|offset
op_rshift
l_int|3
)paren
)paren
suffix:semicolon
multiline_comment|/* ANK: dirty, but effective trick. Upgrade options only if&n;&t;&t; * the segment to be fragmented was THE FIRST (otherwise,&n;&t;&t; * options are already fixed) and make it ONCE&n;&t;&t; * on the initial skb, so that all the following fragments&n;&t;&t; * will inherit fixed options.&n;&t;&t; */
r_if
c_cond
(paren
id|offset
op_eq
l_int|0
)paren
id|ip_options_fragment
c_func
(paren
id|skb
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Added AC : If we are fragmenting a fragment that&squot;s not the&n;&t;&t; *&t;&t;   last fragment then keep MF on each bit&n;&t;&t; */
r_if
c_cond
(paren
id|left
OG
l_int|0
op_logical_or
id|not_last_frag
)paren
id|iph-&gt;frag_off
op_or_assign
id|htons
c_func
(paren
id|IP_MF
)paren
suffix:semicolon
id|ptr
op_add_assign
id|len
suffix:semicolon
id|offset
op_add_assign
id|len
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Put this fragment into the sending queue.&n;&t;&t; */
id|IP_INC_STATS
c_func
(paren
id|IPSTATS_MIB_FRAGCREATES
)paren
suffix:semicolon
id|iph-&gt;tot_len
op_assign
id|htons
c_func
(paren
id|len
op_plus
id|hlen
)paren
suffix:semicolon
id|ip_send_check
c_func
(paren
id|iph
)paren
suffix:semicolon
id|err
op_assign
id|output
c_func
(paren
id|skb2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|fail
suffix:semicolon
)brace
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
id|IP_INC_STATS
c_func
(paren
id|IPSTATS_MIB_FRAGOKS
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
id|fail
suffix:colon
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
id|IP_INC_STATS
c_func
(paren
id|IPSTATS_MIB_FRAGFAILS
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
r_int
DECL|function|ip_generic_getfrag
id|ip_generic_getfrag
c_func
(paren
r_void
op_star
id|from
comma
r_char
op_star
id|to
comma
r_int
id|offset
comma
r_int
id|len
comma
r_int
id|odd
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|iovec
op_star
id|iov
op_assign
id|from
suffix:semicolon
r_if
c_cond
(paren
id|skb-&gt;ip_summed
op_eq
id|CHECKSUM_HW
)paren
(brace
r_if
c_cond
(paren
id|memcpy_fromiovecend
c_func
(paren
id|to
comma
id|iov
comma
id|offset
comma
id|len
)paren
OL
l_int|0
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_else
(brace
r_int
r_int
id|csum
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|csum_partial_copy_fromiovecend
c_func
(paren
id|to
comma
id|iov
comma
id|offset
comma
id|len
comma
op_amp
id|csum
)paren
OL
l_int|0
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|skb-&gt;csum
op_assign
id|csum_block_add
c_func
(paren
id|skb-&gt;csum
comma
id|csum
comma
id|odd
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_inline
r_int
r_int
DECL|function|csum_page
id|csum_page
c_func
(paren
r_struct
id|page
op_star
id|page
comma
r_int
id|offset
comma
r_int
id|copy
)paren
(brace
r_char
op_star
id|kaddr
suffix:semicolon
r_int
r_int
id|csum
suffix:semicolon
id|kaddr
op_assign
id|kmap
c_func
(paren
id|page
)paren
suffix:semicolon
id|csum
op_assign
id|csum_partial
c_func
(paren
id|kaddr
op_plus
id|offset
comma
id|copy
comma
l_int|0
)paren
suffix:semicolon
id|kunmap
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
id|csum
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;ip_append_data() and ip_append_page() can make one large IP datagram&n; *&t;from many pieces of data. Each pieces will be holded on the socket&n; *&t;until ip_push_pending_frames() is called. Each piece can be a page&n; *&t;or non-page data.&n; *&t;&n; *&t;Not only UDP, other transport protocols - e.g. raw sockets - can use&n; *&t;this interface potentially.&n; *&n; *&t;LATER: length must be adjusted by pad at tail, when it is required.&n; */
DECL|function|ip_append_data
r_int
id|ip_append_data
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|getfrag
c_func
(paren
r_void
op_star
id|from
comma
r_char
op_star
id|to
comma
r_int
id|offset
comma
r_int
id|len
comma
r_int
id|odd
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
comma
r_void
op_star
id|from
comma
r_int
id|length
comma
r_int
id|transhdrlen
comma
r_struct
id|ipcm_cookie
op_star
id|ipc
comma
r_struct
id|rtable
op_star
id|rt
comma
r_int
r_int
id|flags
)paren
(brace
r_struct
id|inet_opt
op_star
id|inet
op_assign
id|inet_sk
c_func
(paren
id|sk
)paren
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_struct
id|ip_options
op_star
id|opt
op_assign
l_int|NULL
suffix:semicolon
r_int
id|hh_len
suffix:semicolon
r_int
id|exthdrlen
suffix:semicolon
r_int
id|mtu
suffix:semicolon
r_int
id|copy
suffix:semicolon
r_int
id|err
suffix:semicolon
r_int
id|offset
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|maxfraglen
comma
id|fragheaderlen
suffix:semicolon
r_int
id|csummode
op_assign
id|CHECKSUM_NONE
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|MSG_PROBE
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|skb_queue_empty
c_func
(paren
op_amp
id|sk-&gt;sk_write_queue
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * setup for corking.&n;&t;&t; */
id|opt
op_assign
id|ipc-&gt;opt
suffix:semicolon
r_if
c_cond
(paren
id|opt
)paren
(brace
r_if
c_cond
(paren
id|inet-&gt;cork.opt
op_eq
l_int|NULL
)paren
(brace
id|inet-&gt;cork.opt
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|ip_options
)paren
op_plus
l_int|40
comma
id|sk-&gt;sk_allocation
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|inet-&gt;cork.opt
op_eq
l_int|NULL
)paren
)paren
r_return
op_minus
id|ENOBUFS
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|inet-&gt;cork.opt
comma
id|opt
comma
r_sizeof
(paren
r_struct
id|ip_options
)paren
op_plus
id|opt-&gt;optlen
)paren
suffix:semicolon
id|inet-&gt;cork.flags
op_or_assign
id|IPCORK_OPT
suffix:semicolon
id|inet-&gt;cork.addr
op_assign
id|ipc-&gt;addr
suffix:semicolon
)brace
id|dst_hold
c_func
(paren
op_amp
id|rt-&gt;u.dst
)paren
suffix:semicolon
id|inet-&gt;cork.fragsize
op_assign
id|mtu
op_assign
id|dst_pmtu
c_func
(paren
op_amp
id|rt-&gt;u.dst
)paren
suffix:semicolon
id|inet-&gt;cork.rt
op_assign
id|rt
suffix:semicolon
id|inet-&gt;cork.length
op_assign
l_int|0
suffix:semicolon
id|sk-&gt;sk_sndmsg_page
op_assign
l_int|NULL
suffix:semicolon
id|sk-&gt;sk_sndmsg_off
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|exthdrlen
op_assign
id|rt-&gt;u.dst.header_len
)paren
op_ne
l_int|0
)paren
(brace
id|length
op_add_assign
id|exthdrlen
suffix:semicolon
id|transhdrlen
op_add_assign
id|exthdrlen
suffix:semicolon
)brace
)brace
r_else
(brace
id|rt
op_assign
id|inet-&gt;cork.rt
suffix:semicolon
r_if
c_cond
(paren
id|inet-&gt;cork.flags
op_amp
id|IPCORK_OPT
)paren
id|opt
op_assign
id|inet-&gt;cork.opt
suffix:semicolon
id|transhdrlen
op_assign
l_int|0
suffix:semicolon
id|exthdrlen
op_assign
l_int|0
suffix:semicolon
id|mtu
op_assign
id|inet-&gt;cork.fragsize
suffix:semicolon
)brace
id|hh_len
op_assign
id|LL_RESERVED_SPACE
c_func
(paren
id|rt-&gt;u.dst.dev
)paren
suffix:semicolon
id|fragheaderlen
op_assign
r_sizeof
(paren
r_struct
id|iphdr
)paren
op_plus
(paren
id|opt
ques
c_cond
id|opt-&gt;optlen
suffix:colon
l_int|0
)paren
suffix:semicolon
id|maxfraglen
op_assign
(paren
(paren
id|mtu
op_minus
id|fragheaderlen
)paren
op_amp
op_complement
l_int|7
)paren
op_plus
id|fragheaderlen
suffix:semicolon
r_if
c_cond
(paren
id|inet-&gt;cork.length
op_plus
id|length
OG
l_int|0xFFFF
op_minus
id|fragheaderlen
)paren
(brace
id|ip_local_error
c_func
(paren
id|sk
comma
id|EMSGSIZE
comma
id|rt-&gt;rt_dst
comma
id|inet-&gt;dport
comma
id|mtu
op_minus
id|exthdrlen
)paren
suffix:semicolon
r_return
op_minus
id|EMSGSIZE
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * transhdrlen &gt; 0 means that this is the first fragment and we wish&n;&t; * it won&squot;t be fragmented in the future.&n;&t; */
r_if
c_cond
(paren
id|transhdrlen
op_logical_and
id|length
op_plus
id|fragheaderlen
op_le
id|mtu
op_logical_and
id|rt-&gt;u.dst.dev-&gt;features
op_amp
(paren
id|NETIF_F_IP_CSUM
op_or
id|NETIF_F_NO_CSUM
op_or
id|NETIF_F_HW_CSUM
)paren
op_logical_and
op_logical_neg
id|exthdrlen
)paren
id|csummode
op_assign
id|CHECKSUM_HW
suffix:semicolon
id|inet-&gt;cork.length
op_add_assign
id|length
suffix:semicolon
multiline_comment|/* So, what&squot;s going on in the loop below?&n;&t; *&n;&t; * We use calculated fragment length to generate chained skb,&n;&t; * each of segments is IP fragment ready for sending to network after&n;&t; * adding appropriate IP header.&n;&t; */
r_if
c_cond
(paren
(paren
id|skb
op_assign
id|skb_peek_tail
c_func
(paren
op_amp
id|sk-&gt;sk_write_queue
)paren
)paren
op_eq
l_int|NULL
)paren
r_goto
id|alloc_new_skb
suffix:semicolon
r_while
c_loop
(paren
id|length
OG
l_int|0
)paren
(brace
multiline_comment|/* Check if the remaining data fits into current packet. */
id|copy
op_assign
id|mtu
op_minus
id|skb-&gt;len
suffix:semicolon
r_if
c_cond
(paren
id|copy
OL
id|length
)paren
id|copy
op_assign
id|maxfraglen
op_minus
id|skb-&gt;len
suffix:semicolon
r_if
c_cond
(paren
id|copy
op_le
l_int|0
)paren
(brace
r_char
op_star
id|data
suffix:semicolon
r_int
r_int
id|datalen
suffix:semicolon
r_int
r_int
id|fraglen
suffix:semicolon
r_int
r_int
id|fraggap
suffix:semicolon
r_int
r_int
id|alloclen
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb_prev
suffix:semicolon
id|alloc_new_skb
suffix:colon
id|skb_prev
op_assign
id|skb
suffix:semicolon
r_if
c_cond
(paren
id|skb_prev
)paren
id|fraggap
op_assign
id|skb_prev-&gt;len
op_minus
id|maxfraglen
suffix:semicolon
r_else
id|fraggap
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * If remaining data exceeds the mtu,&n;&t;&t;&t; * we know we need more fragment(s).&n;&t;&t;&t; */
id|datalen
op_assign
id|length
op_plus
id|fraggap
suffix:semicolon
r_if
c_cond
(paren
id|datalen
OG
id|mtu
op_minus
id|fragheaderlen
)paren
id|datalen
op_assign
id|maxfraglen
op_minus
id|fragheaderlen
suffix:semicolon
id|fraglen
op_assign
id|datalen
op_plus
id|fragheaderlen
suffix:semicolon
r_if
c_cond
(paren
(paren
id|flags
op_amp
id|MSG_MORE
)paren
op_logical_and
op_logical_neg
(paren
id|rt-&gt;u.dst.dev-&gt;features
op_amp
id|NETIF_F_SG
)paren
)paren
id|alloclen
op_assign
id|mtu
suffix:semicolon
r_else
id|alloclen
op_assign
id|datalen
op_plus
id|fragheaderlen
suffix:semicolon
multiline_comment|/* The last fragment gets additional space at tail.&n;&t;&t;&t; * Note, with MSG_MORE we overallocate on fragments,&n;&t;&t;&t; * because we have no idea what fragment will be&n;&t;&t;&t; * the last.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|datalen
op_eq
id|length
)paren
id|alloclen
op_add_assign
id|rt-&gt;u.dst.trailer_len
suffix:semicolon
r_if
c_cond
(paren
id|transhdrlen
)paren
(brace
id|skb
op_assign
id|sock_alloc_send_skb
c_func
(paren
id|sk
comma
id|alloclen
op_plus
id|hh_len
op_plus
l_int|15
comma
(paren
id|flags
op_amp
id|MSG_DONTWAIT
)paren
comma
op_amp
id|err
)paren
suffix:semicolon
)brace
r_else
(brace
id|skb
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|sk-&gt;sk_wmem_alloc
)paren
op_le
l_int|2
op_star
id|sk-&gt;sk_sndbuf
)paren
id|skb
op_assign
id|sock_wmalloc
c_func
(paren
id|sk
comma
id|alloclen
op_plus
id|hh_len
op_plus
l_int|15
comma
l_int|1
comma
id|sk-&gt;sk_allocation
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|skb
op_eq
l_int|NULL
)paren
)paren
id|err
op_assign
op_minus
id|ENOBUFS
suffix:semicolon
)brace
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
r_goto
id|error
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; *&t;Fill in the control structures&n;&t;&t;&t; */
id|skb-&gt;ip_summed
op_assign
id|csummode
suffix:semicolon
id|skb-&gt;csum
op_assign
l_int|0
suffix:semicolon
id|skb_reserve
c_func
(paren
id|skb
comma
id|hh_len
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; *&t;Find where to start putting bytes.&n;&t;&t;&t; */
id|data
op_assign
id|skb_put
c_func
(paren
id|skb
comma
id|fraglen
)paren
suffix:semicolon
id|skb-&gt;nh.raw
op_assign
id|data
op_plus
id|exthdrlen
suffix:semicolon
id|data
op_add_assign
id|fragheaderlen
suffix:semicolon
id|skb-&gt;h.raw
op_assign
id|data
op_plus
id|exthdrlen
suffix:semicolon
r_if
c_cond
(paren
id|fraggap
)paren
(brace
id|skb-&gt;csum
op_assign
id|skb_copy_and_csum_bits
c_func
(paren
id|skb_prev
comma
id|maxfraglen
comma
id|data
op_plus
id|transhdrlen
comma
id|fraggap
comma
l_int|0
)paren
suffix:semicolon
id|skb_prev-&gt;csum
op_assign
id|csum_sub
c_func
(paren
id|skb_prev-&gt;csum
comma
id|skb-&gt;csum
)paren
suffix:semicolon
id|data
op_add_assign
id|fraggap
suffix:semicolon
id|skb_trim
c_func
(paren
id|skb_prev
comma
id|maxfraglen
)paren
suffix:semicolon
)brace
id|copy
op_assign
id|datalen
op_minus
id|transhdrlen
op_minus
id|fraggap
suffix:semicolon
r_if
c_cond
(paren
id|copy
OG
l_int|0
op_logical_and
id|getfrag
c_func
(paren
id|from
comma
id|data
op_plus
id|transhdrlen
comma
id|offset
comma
id|copy
comma
id|fraggap
comma
id|skb
)paren
OL
l_int|0
)paren
(brace
id|err
op_assign
op_minus
id|EFAULT
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
id|offset
op_add_assign
id|copy
suffix:semicolon
id|length
op_sub_assign
id|datalen
op_minus
id|fraggap
suffix:semicolon
id|transhdrlen
op_assign
l_int|0
suffix:semicolon
id|exthdrlen
op_assign
l_int|0
suffix:semicolon
id|csummode
op_assign
id|CHECKSUM_NONE
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Put the packet on the pending queue.&n;&t;&t;&t; */
id|__skb_queue_tail
c_func
(paren
op_amp
id|sk-&gt;sk_write_queue
comma
id|skb
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|copy
OG
id|length
)paren
id|copy
op_assign
id|length
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|rt-&gt;u.dst.dev-&gt;features
op_amp
id|NETIF_F_SG
)paren
)paren
(brace
r_int
r_int
id|off
suffix:semicolon
id|off
op_assign
id|skb-&gt;len
suffix:semicolon
r_if
c_cond
(paren
id|getfrag
c_func
(paren
id|from
comma
id|skb_put
c_func
(paren
id|skb
comma
id|copy
)paren
comma
id|offset
comma
id|copy
comma
id|off
comma
id|skb
)paren
OL
l_int|0
)paren
(brace
id|__skb_trim
c_func
(paren
id|skb
comma
id|off
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
)brace
r_else
(brace
r_int
id|i
op_assign
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|nr_frags
suffix:semicolon
id|skb_frag_t
op_star
id|frag
op_assign
op_amp
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|frags
(braket
id|i
op_minus
l_int|1
)braket
suffix:semicolon
r_struct
id|page
op_star
id|page
op_assign
id|sk-&gt;sk_sndmsg_page
suffix:semicolon
r_int
id|off
op_assign
id|sk-&gt;sk_sndmsg_off
suffix:semicolon
r_int
r_int
id|left
suffix:semicolon
r_if
c_cond
(paren
id|page
op_logical_and
(paren
id|left
op_assign
id|PAGE_SIZE
op_minus
id|off
)paren
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|copy
op_ge
id|left
)paren
id|copy
op_assign
id|left
suffix:semicolon
r_if
c_cond
(paren
id|page
op_ne
id|frag-&gt;page
)paren
(brace
r_if
c_cond
(paren
id|i
op_eq
id|MAX_SKB_FRAGS
)paren
(brace
id|err
op_assign
op_minus
id|EMSGSIZE
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
id|get_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|skb_fill_page_desc
c_func
(paren
id|skb
comma
id|i
comma
id|page
comma
id|sk-&gt;sk_sndmsg_off
comma
l_int|0
)paren
suffix:semicolon
id|frag
op_assign
op_amp
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|frags
(braket
id|i
)braket
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|i
OL
id|MAX_SKB_FRAGS
)paren
(brace
r_if
c_cond
(paren
id|copy
OG
id|PAGE_SIZE
)paren
id|copy
op_assign
id|PAGE_SIZE
suffix:semicolon
id|page
op_assign
id|alloc_pages
c_func
(paren
id|sk-&gt;sk_allocation
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|page
op_eq
l_int|NULL
)paren
(brace
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
id|sk-&gt;sk_sndmsg_page
op_assign
id|page
suffix:semicolon
id|sk-&gt;sk_sndmsg_off
op_assign
l_int|0
suffix:semicolon
id|skb_fill_page_desc
c_func
(paren
id|skb
comma
id|i
comma
id|page
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|frag
op_assign
op_amp
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|frags
(braket
id|i
)braket
suffix:semicolon
id|skb-&gt;truesize
op_add_assign
id|PAGE_SIZE
suffix:semicolon
id|atomic_add
c_func
(paren
id|PAGE_SIZE
comma
op_amp
id|sk-&gt;sk_wmem_alloc
)paren
suffix:semicolon
)brace
r_else
(brace
id|err
op_assign
op_minus
id|EMSGSIZE
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
r_if
c_cond
(paren
id|getfrag
c_func
(paren
id|from
comma
id|page_address
c_func
(paren
id|frag-&gt;page
)paren
op_plus
id|frag-&gt;page_offset
op_plus
id|frag-&gt;size
comma
id|offset
comma
id|copy
comma
id|skb-&gt;len
comma
id|skb
)paren
OL
l_int|0
)paren
(brace
id|err
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
id|sk-&gt;sk_sndmsg_off
op_add_assign
id|copy
suffix:semicolon
id|frag-&gt;size
op_add_assign
id|copy
suffix:semicolon
id|skb-&gt;len
op_add_assign
id|copy
suffix:semicolon
id|skb-&gt;data_len
op_add_assign
id|copy
suffix:semicolon
)brace
id|offset
op_add_assign
id|copy
suffix:semicolon
id|length
op_sub_assign
id|copy
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
id|error
suffix:colon
id|inet-&gt;cork.length
op_sub_assign
id|length
suffix:semicolon
id|IP_INC_STATS
c_func
(paren
id|IPSTATS_MIB_OUTDISCARDS
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|function|ip_append_page
id|ssize_t
id|ip_append_page
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|page
op_star
id|page
comma
r_int
id|offset
comma
r_int
id|size
comma
r_int
id|flags
)paren
(brace
r_struct
id|inet_opt
op_star
id|inet
op_assign
id|inet_sk
c_func
(paren
id|sk
)paren
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_struct
id|rtable
op_star
id|rt
suffix:semicolon
r_struct
id|ip_options
op_star
id|opt
op_assign
l_int|NULL
suffix:semicolon
r_int
id|hh_len
suffix:semicolon
r_int
id|mtu
suffix:semicolon
r_int
id|len
suffix:semicolon
r_int
id|err
suffix:semicolon
r_int
r_int
id|maxfraglen
comma
id|fragheaderlen
comma
id|fraggap
suffix:semicolon
r_if
c_cond
(paren
id|inet-&gt;hdrincl
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|MSG_PROBE
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|skb_queue_empty
c_func
(paren
op_amp
id|sk-&gt;sk_write_queue
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|rt
op_assign
id|inet-&gt;cork.rt
suffix:semicolon
r_if
c_cond
(paren
id|inet-&gt;cork.flags
op_amp
id|IPCORK_OPT
)paren
id|opt
op_assign
id|inet-&gt;cork.opt
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|rt-&gt;u.dst.dev-&gt;features
op_amp
id|NETIF_F_SG
)paren
)paren
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
id|hh_len
op_assign
id|LL_RESERVED_SPACE
c_func
(paren
id|rt-&gt;u.dst.dev
)paren
suffix:semicolon
id|mtu
op_assign
id|inet-&gt;cork.fragsize
suffix:semicolon
id|fragheaderlen
op_assign
r_sizeof
(paren
r_struct
id|iphdr
)paren
op_plus
(paren
id|opt
ques
c_cond
id|opt-&gt;optlen
suffix:colon
l_int|0
)paren
suffix:semicolon
id|maxfraglen
op_assign
(paren
(paren
id|mtu
op_minus
id|fragheaderlen
)paren
op_amp
op_complement
l_int|7
)paren
op_plus
id|fragheaderlen
suffix:semicolon
r_if
c_cond
(paren
id|inet-&gt;cork.length
op_plus
id|size
OG
l_int|0xFFFF
op_minus
id|fragheaderlen
)paren
(brace
id|ip_local_error
c_func
(paren
id|sk
comma
id|EMSGSIZE
comma
id|rt-&gt;rt_dst
comma
id|inet-&gt;dport
comma
id|mtu
)paren
suffix:semicolon
r_return
op_minus
id|EMSGSIZE
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|skb
op_assign
id|skb_peek_tail
c_func
(paren
op_amp
id|sk-&gt;sk_write_queue
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|inet-&gt;cork.length
op_add_assign
id|size
suffix:semicolon
r_while
c_loop
(paren
id|size
OG
l_int|0
)paren
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/* Check if the remaining data fits into current packet. */
id|len
op_assign
id|mtu
op_minus
id|skb-&gt;len
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
id|size
)paren
id|len
op_assign
id|maxfraglen
op_minus
id|skb-&gt;len
suffix:semicolon
r_if
c_cond
(paren
id|len
op_le
l_int|0
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb_prev
suffix:semicolon
r_char
op_star
id|data
suffix:semicolon
r_struct
id|iphdr
op_star
id|iph
suffix:semicolon
r_int
id|alloclen
suffix:semicolon
id|skb_prev
op_assign
id|skb
suffix:semicolon
r_if
c_cond
(paren
id|skb_prev
)paren
id|fraggap
op_assign
id|skb_prev-&gt;len
op_minus
id|maxfraglen
suffix:semicolon
r_else
id|fraggap
op_assign
l_int|0
suffix:semicolon
id|alloclen
op_assign
id|fragheaderlen
op_plus
id|hh_len
op_plus
id|fraggap
op_plus
l_int|15
suffix:semicolon
id|skb
op_assign
id|sock_wmalloc
c_func
(paren
id|sk
comma
id|alloclen
comma
l_int|1
comma
id|sk-&gt;sk_allocation
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|skb
)paren
)paren
(brace
id|err
op_assign
op_minus
id|ENOBUFS
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; *&t;Fill in the control structures&n;&t;&t;&t; */
id|skb-&gt;ip_summed
op_assign
id|CHECKSUM_NONE
suffix:semicolon
id|skb-&gt;csum
op_assign
l_int|0
suffix:semicolon
id|skb_reserve
c_func
(paren
id|skb
comma
id|hh_len
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; *&t;Find where to start putting bytes.&n;&t;&t;&t; */
id|data
op_assign
id|skb_put
c_func
(paren
id|skb
comma
id|fragheaderlen
op_plus
id|fraggap
)paren
suffix:semicolon
id|skb-&gt;nh.iph
op_assign
id|iph
op_assign
(paren
r_struct
id|iphdr
op_star
)paren
id|data
suffix:semicolon
id|data
op_add_assign
id|fragheaderlen
suffix:semicolon
id|skb-&gt;h.raw
op_assign
id|data
suffix:semicolon
r_if
c_cond
(paren
id|fraggap
)paren
(brace
id|skb-&gt;csum
op_assign
id|skb_copy_and_csum_bits
c_func
(paren
id|skb_prev
comma
id|maxfraglen
comma
id|data
comma
id|fraggap
comma
l_int|0
)paren
suffix:semicolon
id|skb_prev-&gt;csum
op_assign
id|csum_sub
c_func
(paren
id|skb_prev-&gt;csum
comma
id|skb-&gt;csum
)paren
suffix:semicolon
id|skb_trim
c_func
(paren
id|skb_prev
comma
id|maxfraglen
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * Put the packet on the pending queue.&n;&t;&t;&t; */
id|__skb_queue_tail
c_func
(paren
op_amp
id|sk-&gt;sk_write_queue
comma
id|skb
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|i
op_assign
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|nr_frags
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|size
)paren
id|len
op_assign
id|size
suffix:semicolon
r_if
c_cond
(paren
id|skb_can_coalesce
c_func
(paren
id|skb
comma
id|i
comma
id|page
comma
id|offset
)paren
)paren
(brace
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|frags
(braket
id|i
op_minus
l_int|1
)braket
dot
id|size
op_add_assign
id|len
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|i
OL
id|MAX_SKB_FRAGS
)paren
(brace
id|get_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|skb_fill_page_desc
c_func
(paren
id|skb
comma
id|i
comma
id|page
comma
id|offset
comma
id|len
)paren
suffix:semicolon
)brace
r_else
(brace
id|err
op_assign
op_minus
id|EMSGSIZE
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
r_if
c_cond
(paren
id|skb-&gt;ip_summed
op_eq
id|CHECKSUM_NONE
)paren
(brace
r_int
r_int
id|csum
suffix:semicolon
id|csum
op_assign
id|csum_page
c_func
(paren
id|page
comma
id|offset
comma
id|len
)paren
suffix:semicolon
id|skb-&gt;csum
op_assign
id|csum_block_add
c_func
(paren
id|skb-&gt;csum
comma
id|csum
comma
id|skb-&gt;len
)paren
suffix:semicolon
)brace
id|skb-&gt;len
op_add_assign
id|len
suffix:semicolon
id|skb-&gt;data_len
op_add_assign
id|len
suffix:semicolon
id|offset
op_add_assign
id|len
suffix:semicolon
id|size
op_sub_assign
id|len
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
id|error
suffix:colon
id|inet-&gt;cork.length
op_sub_assign
id|size
suffix:semicolon
id|IP_INC_STATS
c_func
(paren
id|IPSTATS_MIB_OUTDISCARDS
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Combined all pending IP fragments on the socket as one IP datagram&n; *&t;and push them out.&n; */
DECL|function|ip_push_pending_frames
r_int
id|ip_push_pending_frames
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
comma
op_star
id|tmp_skb
suffix:semicolon
r_struct
id|sk_buff
op_star
op_star
id|tail_skb
suffix:semicolon
r_struct
id|inet_opt
op_star
id|inet
op_assign
id|inet_sk
c_func
(paren
id|sk
)paren
suffix:semicolon
r_struct
id|ip_options
op_star
id|opt
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|rtable
op_star
id|rt
op_assign
id|inet-&gt;cork.rt
suffix:semicolon
r_struct
id|iphdr
op_star
id|iph
suffix:semicolon
r_int
id|df
op_assign
l_int|0
suffix:semicolon
id|__u8
id|ttl
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|skb
op_assign
id|__skb_dequeue
c_func
(paren
op_amp
id|sk-&gt;sk_write_queue
)paren
)paren
op_eq
l_int|NULL
)paren
r_goto
id|out
suffix:semicolon
id|tail_skb
op_assign
op_amp
(paren
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|frag_list
)paren
suffix:semicolon
multiline_comment|/* move skb-&gt;data to ip header from ext header */
r_if
c_cond
(paren
id|skb-&gt;data
OL
id|skb-&gt;nh.raw
)paren
id|__skb_pull
c_func
(paren
id|skb
comma
id|skb-&gt;nh.raw
op_minus
id|skb-&gt;data
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|tmp_skb
op_assign
id|__skb_dequeue
c_func
(paren
op_amp
id|sk-&gt;sk_write_queue
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|__skb_pull
c_func
(paren
id|tmp_skb
comma
id|skb-&gt;h.raw
op_minus
id|skb-&gt;nh.raw
)paren
suffix:semicolon
op_star
id|tail_skb
op_assign
id|tmp_skb
suffix:semicolon
id|tail_skb
op_assign
op_amp
(paren
id|tmp_skb-&gt;next
)paren
suffix:semicolon
id|skb-&gt;len
op_add_assign
id|tmp_skb-&gt;len
suffix:semicolon
id|skb-&gt;data_len
op_add_assign
id|tmp_skb-&gt;len
suffix:semicolon
id|skb-&gt;truesize
op_add_assign
id|tmp_skb-&gt;truesize
suffix:semicolon
id|__sock_put
c_func
(paren
id|tmp_skb-&gt;sk
)paren
suffix:semicolon
id|tmp_skb-&gt;destructor
op_assign
l_int|NULL
suffix:semicolon
id|tmp_skb-&gt;sk
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Unless user demanded real pmtu discovery (IP_PMTUDISC_DO), we allow&n;&t; * to fragment the frame generated here. No matter, what transforms&n;&t; * how transforms change size of the packet, it will come out.&n;&t; */
r_if
c_cond
(paren
id|inet-&gt;pmtudisc
op_ne
id|IP_PMTUDISC_DO
)paren
id|skb-&gt;local_df
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* DF bit is set when we want to see DF on outgoing frames.&n;&t; * If local_df is set too, we still allow to fragment this frame&n;&t; * locally. */
r_if
c_cond
(paren
id|inet-&gt;pmtudisc
op_eq
id|IP_PMTUDISC_DO
op_logical_or
(paren
op_logical_neg
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|frag_list
op_logical_and
id|ip_dont_fragment
c_func
(paren
id|sk
comma
op_amp
id|rt-&gt;u.dst
)paren
)paren
)paren
id|df
op_assign
id|htons
c_func
(paren
id|IP_DF
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inet-&gt;cork.flags
op_amp
id|IPCORK_OPT
)paren
id|opt
op_assign
id|inet-&gt;cork.opt
suffix:semicolon
r_if
c_cond
(paren
id|rt-&gt;rt_type
op_eq
id|RTN_MULTICAST
)paren
id|ttl
op_assign
id|inet-&gt;mc_ttl
suffix:semicolon
r_else
id|ttl
op_assign
id|ip_select_ttl
c_func
(paren
id|inet
comma
op_amp
id|rt-&gt;u.dst
)paren
suffix:semicolon
id|iph
op_assign
(paren
r_struct
id|iphdr
op_star
)paren
id|skb-&gt;data
suffix:semicolon
id|iph-&gt;version
op_assign
l_int|4
suffix:semicolon
id|iph-&gt;ihl
op_assign
l_int|5
suffix:semicolon
r_if
c_cond
(paren
id|opt
)paren
(brace
id|iph-&gt;ihl
op_add_assign
id|opt-&gt;optlen
op_rshift
l_int|2
suffix:semicolon
id|ip_options_build
c_func
(paren
id|skb
comma
id|opt
comma
id|inet-&gt;cork.addr
comma
id|rt
comma
l_int|0
)paren
suffix:semicolon
)brace
id|iph-&gt;tos
op_assign
id|inet-&gt;tos
suffix:semicolon
id|iph-&gt;tot_len
op_assign
id|htons
c_func
(paren
id|skb-&gt;len
)paren
suffix:semicolon
id|iph-&gt;frag_off
op_assign
id|df
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|df
)paren
(brace
id|__ip_select_ident
c_func
(paren
id|iph
comma
op_amp
id|rt-&gt;u.dst
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
(brace
id|iph-&gt;id
op_assign
id|htons
c_func
(paren
id|inet-&gt;id
op_increment
)paren
suffix:semicolon
)brace
id|iph-&gt;ttl
op_assign
id|ttl
suffix:semicolon
id|iph-&gt;protocol
op_assign
id|sk-&gt;sk_protocol
suffix:semicolon
id|iph-&gt;saddr
op_assign
id|rt-&gt;rt_src
suffix:semicolon
id|iph-&gt;daddr
op_assign
id|rt-&gt;rt_dst
suffix:semicolon
id|ip_send_check
c_func
(paren
id|iph
)paren
suffix:semicolon
id|skb-&gt;priority
op_assign
id|sk-&gt;sk_priority
suffix:semicolon
id|skb-&gt;dst
op_assign
id|dst_clone
c_func
(paren
op_amp
id|rt-&gt;u.dst
)paren
suffix:semicolon
multiline_comment|/* Netfilter gets whole the not fragmented skb. */
id|err
op_assign
id|NF_HOOK
c_func
(paren
id|PF_INET
comma
id|NF_IP_LOCAL_OUT
comma
id|skb
comma
l_int|NULL
comma
id|skb-&gt;dst-&gt;dev
comma
id|dst_output
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
r_if
c_cond
(paren
id|err
OG
l_int|0
)paren
id|err
op_assign
id|inet-&gt;recverr
ques
c_cond
id|net_xmit_errno
c_func
(paren
id|err
)paren
suffix:colon
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|error
suffix:semicolon
)brace
id|out
suffix:colon
id|inet-&gt;cork.flags
op_and_assign
op_complement
id|IPCORK_OPT
suffix:semicolon
r_if
c_cond
(paren
id|inet-&gt;cork.opt
)paren
(brace
id|kfree
c_func
(paren
id|inet-&gt;cork.opt
)paren
suffix:semicolon
id|inet-&gt;cork.opt
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|inet-&gt;cork.rt
)paren
(brace
id|ip_rt_put
c_func
(paren
id|inet-&gt;cork.rt
)paren
suffix:semicolon
id|inet-&gt;cork.rt
op_assign
l_int|NULL
suffix:semicolon
)brace
r_return
id|err
suffix:semicolon
id|error
suffix:colon
id|IP_INC_STATS
c_func
(paren
id|IPSTATS_MIB_OUTDISCARDS
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Throw away all pending data on the socket.&n; */
DECL|function|ip_flush_pending_frames
r_void
id|ip_flush_pending_frames
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|inet_opt
op_star
id|inet
op_assign
id|inet_sk
c_func
(paren
id|sk
)paren
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_while
c_loop
(paren
(paren
id|skb
op_assign
id|__skb_dequeue_tail
c_func
(paren
op_amp
id|sk-&gt;sk_write_queue
)paren
)paren
op_ne
l_int|NULL
)paren
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
id|inet-&gt;cork.flags
op_and_assign
op_complement
id|IPCORK_OPT
suffix:semicolon
r_if
c_cond
(paren
id|inet-&gt;cork.opt
)paren
(brace
id|kfree
c_func
(paren
id|inet-&gt;cork.opt
)paren
suffix:semicolon
id|inet-&gt;cork.opt
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|inet-&gt;cork.rt
)paren
(brace
id|ip_rt_put
c_func
(paren
id|inet-&gt;cork.rt
)paren
suffix:semicolon
id|inet-&gt;cork.rt
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *&t;Fetch data from kernel space and fill in checksum if needed.&n; */
DECL|function|ip_reply_glue_bits
r_static
r_int
id|ip_reply_glue_bits
c_func
(paren
r_void
op_star
id|dptr
comma
r_char
op_star
id|to
comma
r_int
id|offset
comma
r_int
id|len
comma
r_int
id|odd
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_int
r_int
id|csum
suffix:semicolon
id|csum
op_assign
id|csum_partial_copy_nocheck
c_func
(paren
id|dptr
op_plus
id|offset
comma
id|to
comma
id|len
comma
l_int|0
)paren
suffix:semicolon
id|skb-&gt;csum
op_assign
id|csum_block_add
c_func
(paren
id|skb-&gt;csum
comma
id|csum
comma
id|odd
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* &n; *&t;Generic function to send a packet as reply to another packet.&n; *&t;Used to send TCP resets so far. ICMP should use this function too.&n; *&n; *&t;Should run single threaded per socket because it uses the sock &n; *     &t;structure to pass arguments.&n; *&n; *&t;LATER: switch from ip_build_xmit to ip_append_*&n; */
DECL|function|ip_send_reply
r_void
id|ip_send_reply
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|ip_reply_arg
op_star
id|arg
comma
r_int
r_int
id|len
)paren
(brace
r_struct
id|inet_opt
op_star
id|inet
op_assign
id|inet_sk
c_func
(paren
id|sk
)paren
suffix:semicolon
r_struct
(brace
r_struct
id|ip_options
id|opt
suffix:semicolon
r_char
id|data
(braket
l_int|40
)braket
suffix:semicolon
)brace
id|replyopts
suffix:semicolon
r_struct
id|ipcm_cookie
id|ipc
suffix:semicolon
id|u32
id|daddr
suffix:semicolon
r_struct
id|rtable
op_star
id|rt
op_assign
(paren
r_struct
id|rtable
op_star
)paren
id|skb-&gt;dst
suffix:semicolon
r_if
c_cond
(paren
id|ip_options_echo
c_func
(paren
op_amp
id|replyopts.opt
comma
id|skb
)paren
)paren
r_return
suffix:semicolon
id|daddr
op_assign
id|ipc.addr
op_assign
id|rt-&gt;rt_src
suffix:semicolon
id|ipc.opt
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|replyopts.opt.optlen
)paren
(brace
id|ipc.opt
op_assign
op_amp
id|replyopts.opt
suffix:semicolon
r_if
c_cond
(paren
id|ipc.opt-&gt;srr
)paren
id|daddr
op_assign
id|replyopts.opt.faddr
suffix:semicolon
)brace
(brace
r_struct
id|flowi
id|fl
op_assign
(brace
dot
id|nl_u
op_assign
(brace
dot
id|ip4_u
op_assign
(brace
dot
id|daddr
op_assign
id|daddr
comma
dot
id|saddr
op_assign
id|rt-&gt;rt_spec_dst
comma
dot
id|tos
op_assign
id|RT_TOS
c_func
(paren
id|skb-&gt;nh.iph-&gt;tos
)paren
)brace
)brace
comma
multiline_comment|/* Not quite clean, but right. */
dot
id|uli_u
op_assign
(brace
dot
id|ports
op_assign
(brace
dot
id|sport
op_assign
id|skb-&gt;h.th-&gt;dest
comma
dot
id|dport
op_assign
id|skb-&gt;h.th-&gt;source
)brace
)brace
comma
dot
id|proto
op_assign
id|sk-&gt;sk_protocol
)brace
suffix:semicolon
r_if
c_cond
(paren
id|ip_route_output_key
c_func
(paren
op_amp
id|rt
comma
op_amp
id|fl
)paren
)paren
r_return
suffix:semicolon
)brace
multiline_comment|/* And let IP do all the hard work.&n;&n;&t;   This chunk is not reenterable, hence spinlock.&n;&t;   Note that it uses the fact, that this function is called&n;&t;   with locally disabled BH and that sk cannot be already spinlocked.&n;&t; */
id|bh_lock_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
id|inet-&gt;tos
op_assign
id|skb-&gt;nh.iph-&gt;tos
suffix:semicolon
id|sk-&gt;sk_priority
op_assign
id|skb-&gt;priority
suffix:semicolon
id|sk-&gt;sk_protocol
op_assign
id|skb-&gt;nh.iph-&gt;protocol
suffix:semicolon
id|ip_append_data
c_func
(paren
id|sk
comma
id|ip_reply_glue_bits
comma
id|arg-&gt;iov-&gt;iov_base
comma
id|len
comma
l_int|0
comma
op_amp
id|ipc
comma
id|rt
comma
id|MSG_DONTWAIT
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|skb
op_assign
id|skb_peek
c_func
(paren
op_amp
id|sk-&gt;sk_write_queue
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|arg-&gt;csumoffset
op_ge
l_int|0
)paren
op_star
(paren
(paren
id|u16
op_star
)paren
id|skb-&gt;h.raw
op_plus
id|arg-&gt;csumoffset
)paren
op_assign
id|csum_fold
c_func
(paren
id|csum_add
c_func
(paren
id|skb-&gt;csum
comma
id|arg-&gt;csum
)paren
)paren
suffix:semicolon
id|skb-&gt;ip_summed
op_assign
id|CHECKSUM_NONE
suffix:semicolon
id|ip_push_pending_frames
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
id|bh_unlock_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
id|ip_rt_put
c_func
(paren
id|rt
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;IP protocol layer initialiser&n; */
DECL|variable|ip_packet_type
r_static
r_struct
id|packet_type
id|ip_packet_type
op_assign
(brace
dot
id|type
op_assign
id|__constant_htons
c_func
(paren
id|ETH_P_IP
)paren
comma
dot
id|func
op_assign
id|ip_rcv
comma
)brace
suffix:semicolon
multiline_comment|/*&n; *&t;IP registers the packet type and then calls the subprotocol initialisers&n; */
DECL|function|ip_init
r_void
id|__init
id|ip_init
c_func
(paren
r_void
)paren
(brace
id|dev_add_pack
c_func
(paren
op_amp
id|ip_packet_type
)paren
suffix:semicolon
id|ip_rt_init
c_func
(paren
)paren
suffix:semicolon
id|inet_initpeers
c_func
(paren
)paren
suffix:semicolon
macro_line|#if defined(CONFIG_IP_MULTICAST) &amp;&amp; defined(CONFIG_PROC_FS)
id|igmp_mc_proc_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
)brace
DECL|variable|ip_finish_output
id|EXPORT_SYMBOL
c_func
(paren
id|ip_finish_output
)paren
suffix:semicolon
DECL|variable|ip_fragment
id|EXPORT_SYMBOL
c_func
(paren
id|ip_fragment
)paren
suffix:semicolon
DECL|variable|ip_generic_getfrag
id|EXPORT_SYMBOL
c_func
(paren
id|ip_generic_getfrag
)paren
suffix:semicolon
DECL|variable|ip_queue_xmit
id|EXPORT_SYMBOL
c_func
(paren
id|ip_queue_xmit
)paren
suffix:semicolon
DECL|variable|ip_send_check
id|EXPORT_SYMBOL
c_func
(paren
id|ip_send_check
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_SYSCTL
DECL|variable|sysctl_ip_default_ttl
id|EXPORT_SYMBOL
c_func
(paren
id|sysctl_ip_default_ttl
)paren
suffix:semicolon
macro_line|#endif
eof
