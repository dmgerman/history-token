multiline_comment|/*&n; * INET&t;&t;802.1Q VLAN&n; *&t;&t;Ethernet-type device handling.&n; *&n; * Authors:&t;Ben Greear &lt;greearb@candelatech.com&gt;&n; *              Please send support related email to: vlan@scry.wanfear.com&n; *              VLAN Home Page: http://www.candelatech.com/~greear/vlan.html&n; * &n; * Fixes:       Mar 22 2001: Martin Bokaemper &lt;mbokaemper@unispherenetworks.com&gt;&n; *                - reset skb-&gt;pkt_type on incoming packets when MAC was changed&n; *                - see that changed MAC is saddr for outgoing packets&n; *              Oct 20, 2001:  Ard van Breeman:&n; *                - Fix MC-list, finally.&n; *                - Flush MC-list on VLAN destroy.&n; *                &n; *&n; *&t;&t;This program is free software; you can redistribute it and/or&n; *&t;&t;modify it under the terms of the GNU General Public License&n; *&t;&t;as published by the Free Software Foundation; either version&n; *&t;&t;2 of the License, or (at your option) any later version.&n; */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/in.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt; /* for copy_from_user */
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/etherdevice.h&gt;
macro_line|#include &lt;net/datalink.h&gt;
macro_line|#include &lt;net/p8022.h&gt;
macro_line|#include &lt;net/arp.h&gt;
macro_line|#include &lt;linux/brlock.h&gt;
macro_line|#include &quot;vlan.h&quot;
macro_line|#include &quot;vlanproc.h&quot;
macro_line|#include &lt;linux/if_vlan.h&gt;
macro_line|#include &lt;net/ip.h&gt;
multiline_comment|/*&n; *&t;Rebuild the Ethernet MAC header. This is called after an ARP&n; *&t;(or in future other address resolution) has completed on this&n; *&t;sk_buff. We now let ARP fill in the other fields.&n; *&n; *&t;This routine CANNOT use cached dst-&gt;neigh!&n; *&t;Really, it is used only when dst-&gt;neigh is wrong.&n; *&n; * TODO:  This needs a checkup, I&squot;m ignorant here. --BLG&n; */
DECL|function|vlan_dev_rebuild_header
r_int
id|vlan_dev_rebuild_header
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|net_device
op_star
id|dev
op_assign
id|skb-&gt;dev
suffix:semicolon
r_struct
id|vlan_ethhdr
op_star
id|veth
op_assign
(paren
r_struct
id|vlan_ethhdr
op_star
)paren
(paren
id|skb-&gt;data
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|veth-&gt;h_vlan_encapsulated_proto
)paren
(brace
macro_line|#ifdef CONFIG_INET
r_case
id|__constant_htons
c_func
(paren
id|ETH_P_IP
)paren
suffix:colon
multiline_comment|/* TODO:  Confirm this will work with VLAN headers... */
r_return
id|arp_find
c_func
(paren
id|veth-&gt;h_dest
comma
id|skb
)paren
suffix:semicolon
macro_line|#endif&t;
r_default
suffix:colon
id|printk
c_func
(paren
id|VLAN_DBG
l_string|&quot;%s: unable to resolve type %X addresses.&bslash;n&quot;
comma
id|dev-&gt;name
comma
(paren
r_int
)paren
id|veth-&gt;h_vlan_encapsulated_proto
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|veth-&gt;h_source
comma
id|dev-&gt;dev_addr
comma
id|ETH_ALEN
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|vlan_check_reorder_header
r_static
r_inline
r_struct
id|sk_buff
op_star
id|vlan_check_reorder_header
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_if
c_cond
(paren
id|VLAN_DEV_INFO
c_func
(paren
id|skb-&gt;dev
)paren
op_member_access_from_pointer
id|flags
op_amp
l_int|1
)paren
(brace
id|skb
op_assign
id|skb_share_check
c_func
(paren
id|skb
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
)paren
(brace
multiline_comment|/* Lifted from Gleb&squot;s VLAN code... */
id|memmove
c_func
(paren
id|skb-&gt;data
op_minus
id|ETH_HLEN
comma
id|skb-&gt;data
op_minus
id|VLAN_ETH_HLEN
comma
l_int|12
)paren
suffix:semicolon
id|skb-&gt;mac.raw
op_add_assign
id|VLAN_HLEN
suffix:semicolon
)brace
)brace
r_return
id|skb
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Determine the packet&squot;s protocol ID. The rule here is that we &n; *&t;assume 802.3 if the type field is short enough to be a length.&n; *&t;This is normal practice and works for any &squot;now in use&squot; protocol.&n; *&n; *  Also, at this point we assume that we ARE dealing exclusively with&n; *  VLAN packets, or packets that should be made into VLAN packets based&n; *  on a default VLAN ID.&n; *&n; *  NOTE:  Should be similar to ethernet/eth.c.&n; *&n; *  SANITY NOTE:  This method is called when a packet is moving up the stack&n; *                towards userland.  To get here, it would have already passed&n; *                through the ethernet/eth.c eth_type_trans() method.&n; *  SANITY NOTE 2: We are referencing to the VLAN_HDR frields, which MAY be&n; *                 stored UNALIGNED in the memory.  RISC systems don&squot;t like&n; *                 such cases very much...&n; *  SANITY NOTE 2a:  According to Dave Miller &amp; Alexey, it will always be aligned,&n; *                 so there doesn&squot;t need to be any of the unaligned stuff.  It has&n; *                 been commented out now...  --Ben&n; *&n; */
DECL|function|vlan_skb_recv
r_int
id|vlan_skb_recv
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|packet_type
op_star
id|ptype
)paren
(brace
r_int
r_char
op_star
id|rawp
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|vlan_hdr
op_star
id|vhdr
op_assign
(paren
r_struct
id|vlan_hdr
op_star
)paren
(paren
id|skb-&gt;data
)paren
suffix:semicolon
r_int
r_int
id|vid
suffix:semicolon
r_struct
id|net_device_stats
op_star
id|stats
suffix:semicolon
r_int
r_int
id|vlan_TCI
suffix:semicolon
r_int
r_int
id|proto
suffix:semicolon
multiline_comment|/* vlan_TCI = ntohs(get_unaligned(&amp;vhdr-&gt;h_vlan_TCI)); */
id|vlan_TCI
op_assign
id|ntohs
c_func
(paren
id|vhdr-&gt;h_vlan_TCI
)paren
suffix:semicolon
id|vid
op_assign
(paren
id|vlan_TCI
op_amp
id|VLAN_VID_MASK
)paren
suffix:semicolon
macro_line|#ifdef VLAN_DEBUG
id|printk
c_func
(paren
id|VLAN_DBG
id|__FUNCTION__
l_string|&quot;: skb: %p vlan_id: %hx&bslash;n&quot;
comma
id|skb
comma
id|vid
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Ok, we will find the correct VLAN device, strip the header,&n;&t; * and then go on as usual.&n;&t; */
multiline_comment|/* We have 12 bits of vlan ID.&n;&t; *&n;&t; * We must not drop the vlan_group_lock until we hold a&n;&t; * reference to the device (netif_rx does that) or we&n;&t; * fail.&n;&t; */
id|spin_lock_bh
c_func
(paren
op_amp
id|vlan_group_lock
)paren
suffix:semicolon
id|skb-&gt;dev
op_assign
id|__find_vlan_dev
c_func
(paren
id|dev
comma
id|vid
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skb-&gt;dev
)paren
(brace
id|spin_unlock_bh
c_func
(paren
op_amp
id|vlan_group_lock
)paren
suffix:semicolon
macro_line|#ifdef VLAN_DEBUG
id|printk
c_func
(paren
id|VLAN_DBG
id|__FUNCTION__
l_string|&quot;: ERROR:&t;No net_device for VID: %i on dev: %s [%i]&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
(paren
id|vid
)paren
comma
id|dev-&gt;name
comma
id|dev-&gt;ifindex
)paren
suffix:semicolon
macro_line|#endif
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|skb-&gt;dev-&gt;last_rx
op_assign
id|jiffies
suffix:semicolon
multiline_comment|/* Bump the rx counters for the VLAN device. */
id|stats
op_assign
id|vlan_dev_get_stats
c_func
(paren
id|skb-&gt;dev
)paren
suffix:semicolon
id|stats-&gt;rx_packets
op_increment
suffix:semicolon
id|stats-&gt;rx_bytes
op_add_assign
id|skb-&gt;len
suffix:semicolon
id|skb_pull
c_func
(paren
id|skb
comma
id|VLAN_HLEN
)paren
suffix:semicolon
multiline_comment|/* take off the VLAN header (4 bytes currently) */
multiline_comment|/* Ok, lets check to make sure the device (dev) we&n;&t; * came in on is what this VLAN is attached to.&n;&t; */
r_if
c_cond
(paren
id|dev
op_ne
id|VLAN_DEV_INFO
c_func
(paren
id|skb-&gt;dev
)paren
op_member_access_from_pointer
id|real_dev
)paren
(brace
id|spin_unlock_bh
c_func
(paren
op_amp
id|vlan_group_lock
)paren
suffix:semicolon
macro_line|#ifdef VLAN_DEBUG
id|printk
c_func
(paren
id|VLAN_DBG
id|__FUNCTION__
l_string|&quot;: dropping skb: %p because came in on wrong device, dev: %s  real_dev: %s, skb_dev: %s&bslash;n&quot;
comma
id|skb
comma
id|dev-&gt;name
comma
id|VLAN_DEV_INFO
c_func
(paren
id|skb-&gt;dev
)paren
op_member_access_from_pointer
id|real_dev-&gt;name
comma
id|skb-&gt;dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
id|stats-&gt;rx_errors
op_increment
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Deal with ingress priority mapping.&n;&t; */
id|skb-&gt;priority
op_assign
id|vlan_get_ingress_priority
c_func
(paren
id|skb-&gt;dev
comma
id|ntohs
c_func
(paren
id|vhdr-&gt;h_vlan_TCI
)paren
)paren
suffix:semicolon
macro_line|#ifdef VLAN_DEBUG
id|printk
c_func
(paren
id|VLAN_DBG
id|__FUNCTION__
l_string|&quot;: priority: %lu  for TCI: %hu (hbo)&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
(paren
id|skb-&gt;priority
)paren
comma
id|ntohs
c_func
(paren
id|vhdr-&gt;h_vlan_TCI
)paren
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* The ethernet driver already did the pkt_type calculations&n;&t; * for us...&n;&t; */
r_switch
c_cond
(paren
id|skb-&gt;pkt_type
)paren
(brace
r_case
id|PACKET_BROADCAST
suffix:colon
multiline_comment|/* Yeah, stats collect these together.. */
singleline_comment|// stats-&gt;broadcast ++; // no such counter :-(
r_break
suffix:semicolon
r_case
id|PACKET_MULTICAST
suffix:colon
id|stats-&gt;multicast
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PACKET_OTHERHOST
suffix:colon
multiline_comment|/* Our lower layer thinks this is not local, let&squot;s make sure.&n;&t;&t; * This allows the VLAN to have a different MAC than the underlying&n;&t;&t; * device, and still route correctly.&n;&t;&t; */
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|skb-&gt;mac.ethernet-&gt;h_dest
comma
id|skb-&gt;dev-&gt;dev_addr
comma
id|ETH_ALEN
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* It is for our (changed) MAC-address! */
id|skb-&gt;pkt_type
op_assign
id|PACKET_HOST
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*  Was a VLAN packet, grab the encapsulated protocol, which the layer&n;&t; * three protocols care about.&n;&t; */
multiline_comment|/* proto = get_unaligned(&amp;vhdr-&gt;h_vlan_encapsulated_proto); */
id|proto
op_assign
id|vhdr-&gt;h_vlan_encapsulated_proto
suffix:semicolon
id|skb-&gt;protocol
op_assign
id|proto
suffix:semicolon
r_if
c_cond
(paren
id|ntohs
c_func
(paren
id|proto
)paren
op_ge
l_int|1536
)paren
(brace
multiline_comment|/* place it back on the queue to be handled by&n;&t;&t; * true layer 3 protocols.&n;&t;&t; */
multiline_comment|/* See if we are configured to re-write the VLAN header&n;&t;&t; * to make it look like ethernet...&n;&t;&t; */
id|skb
op_assign
id|vlan_check_reorder_header
c_func
(paren
id|skb
)paren
suffix:semicolon
multiline_comment|/* Can be null if skb-clone fails when re-ordering */
r_if
c_cond
(paren
id|skb
)paren
(brace
id|netif_rx
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* TODO:  Add a more specific counter here. */
id|stats-&gt;rx_errors
op_increment
suffix:semicolon
)brace
id|spin_unlock_bh
c_func
(paren
op_amp
id|vlan_group_lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|rawp
op_assign
id|skb-&gt;data
suffix:semicolon
multiline_comment|/*&n;&t; * This is a magic hack to spot IPX packets. Older Novell breaks&n;&t; * the protocol design and runs IPX over 802.3 without an 802.2 LLC&n;&t; * layer. We look for FFFF which isn&squot;t a used 802.2 SSAP/DSAP. This&n;&t; * won&squot;t work for fault tolerant netware but does for the rest.&n;&t; */
r_if
c_cond
(paren
op_star
(paren
r_int
r_int
op_star
)paren
id|rawp
op_eq
l_int|0xFFFF
)paren
(brace
id|skb-&gt;protocol
op_assign
id|__constant_htons
c_func
(paren
id|ETH_P_802_3
)paren
suffix:semicolon
multiline_comment|/* place it back on the queue to be handled by true layer 3 protocols.&n;&t;&t; */
multiline_comment|/* See if we are configured to re-write the VLAN header&n;&t;&t; * to make it look like ethernet...&n;&t;&t; */
id|skb
op_assign
id|vlan_check_reorder_header
c_func
(paren
id|skb
)paren
suffix:semicolon
multiline_comment|/* Can be null if skb-clone fails when re-ordering */
r_if
c_cond
(paren
id|skb
)paren
(brace
id|netif_rx
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* TODO:  Add a more specific counter here. */
id|stats-&gt;rx_errors
op_increment
suffix:semicolon
)brace
id|spin_unlock_bh
c_func
(paren
op_amp
id|vlan_group_lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Real 802.2 LLC&n;&t; */
id|skb-&gt;protocol
op_assign
id|__constant_htons
c_func
(paren
id|ETH_P_802_2
)paren
suffix:semicolon
multiline_comment|/* place it back on the queue to be handled by upper layer protocols.&n;&t; */
multiline_comment|/* See if we are configured to re-write the VLAN header&n;&t; * to make it look like ethernet...&n;&t; */
id|skb
op_assign
id|vlan_check_reorder_header
c_func
(paren
id|skb
)paren
suffix:semicolon
multiline_comment|/* Can be null if skb-clone fails when re-ordering */
r_if
c_cond
(paren
id|skb
)paren
(brace
id|netif_rx
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* TODO:  Add a more specific counter here. */
id|stats-&gt;rx_errors
op_increment
suffix:semicolon
)brace
id|spin_unlock_bh
c_func
(paren
op_amp
id|vlan_group_lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|vlan_dev_get_egress_qos_mask
r_static
r_inline
r_int
r_int
id|vlan_dev_get_egress_qos_mask
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|vlan_priority_tci_mapping
op_star
id|mp
op_assign
id|VLAN_DEV_INFO
c_func
(paren
id|dev
)paren
op_member_access_from_pointer
id|egress_priority_map
(braket
(paren
id|skb-&gt;priority
op_amp
l_int|0xF
)paren
)braket
suffix:semicolon
r_while
c_loop
(paren
id|mp
)paren
(brace
r_if
c_cond
(paren
id|mp-&gt;priority
op_eq
id|skb-&gt;priority
)paren
(brace
r_return
id|mp-&gt;vlan_qos
suffix:semicolon
multiline_comment|/* This should already be shifted to mask&n;&t;&t;&t;&t;&t;      * correctly with the VLAN&squot;s TCI&n;&t;&t;&t;&t;&t;      */
)brace
id|mp
op_assign
id|mp-&gt;next
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Create the VLAN header for an arbitrary protocol layer &n; *&n; *&t;saddr=NULL&t;means use device source address&n; *&t;daddr=NULL&t;means leave destination address (eg unresolved arp)&n; *&n; *  This is called when the SKB is moving down the stack towards the&n; *  physical devices.&n; */
DECL|function|vlan_dev_hard_header
r_int
id|vlan_dev_hard_header
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
comma
r_int
r_int
id|type
comma
r_void
op_star
id|daddr
comma
r_void
op_star
id|saddr
comma
r_int
id|len
)paren
(brace
r_struct
id|vlan_hdr
op_star
id|vhdr
suffix:semicolon
r_int
r_int
id|veth_TCI
op_assign
l_int|0
suffix:semicolon
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
r_int
id|build_vlan_header
op_assign
l_int|0
suffix:semicolon
r_struct
id|net_device
op_star
id|vdev
op_assign
id|dev
suffix:semicolon
multiline_comment|/* save this for the bottom of the method */
macro_line|#ifdef VLAN_DEBUG
id|printk
c_func
(paren
id|VLAN_DBG
id|__FUNCTION__
l_string|&quot;: skb: %p type: %hx len: %x vlan_id: %hx, daddr: %p&bslash;n&quot;
comma
id|skb
comma
id|type
comma
id|len
comma
id|VLAN_DEV_INFO
c_func
(paren
id|dev
)paren
op_member_access_from_pointer
id|vlan_id
comma
id|daddr
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* build vlan header only if re_order_header flag is NOT set.  This&n;&t; * fixes some programs that get confused when they see a VLAN device&n;&t; * sending a frame that is VLAN encoded (the consensus is that the VLAN&n;&t; * device should look completely like an Ethernet device when the&n;&t; * REORDER_HEADER flag is set)&t;The drawback to this is some extra &n;&t; * header shuffling in the hard_start_xmit.  Users can turn off this&n;&t; * REORDER behaviour with the vconfig tool.&n;&t; */
id|build_vlan_header
op_assign
(paren
(paren
id|VLAN_DEV_INFO
c_func
(paren
id|dev
)paren
op_member_access_from_pointer
id|flags
op_amp
l_int|1
)paren
op_eq
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|build_vlan_header
)paren
(brace
id|vhdr
op_assign
(paren
r_struct
id|vlan_hdr
op_star
)paren
id|skb_push
c_func
(paren
id|skb
comma
id|VLAN_HLEN
)paren
suffix:semicolon
multiline_comment|/* build the four bytes that make this a VLAN header. */
multiline_comment|/* Now, construct the second two bytes. This field looks something&n;&t;&t; * like:&n;&t;&t; * usr_priority: 3 bits&t; (high bits)&n;&t;&t; * CFI&t;&t; 1 bit&n;&t;&t; * VLAN ID&t; 12 bits (low bits)&n;&t;&t; *&n;&t;&t; */
id|veth_TCI
op_assign
id|VLAN_DEV_INFO
c_func
(paren
id|dev
)paren
op_member_access_from_pointer
id|vlan_id
suffix:semicolon
id|veth_TCI
op_or_assign
id|vlan_dev_get_egress_qos_mask
c_func
(paren
id|dev
comma
id|skb
)paren
suffix:semicolon
id|vhdr-&gt;h_vlan_TCI
op_assign
id|htons
c_func
(paren
id|veth_TCI
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *  Set the protocol type.&n;&t;&t; *  For a packet of type ETH_P_802_3 we put the length in here instead.&n;&t;&t; *  It is up to the 802.2 layer to carry protocol information.&n;&t;&t; */
r_if
c_cond
(paren
id|type
op_ne
id|ETH_P_802_3
)paren
(brace
id|vhdr-&gt;h_vlan_encapsulated_proto
op_assign
id|htons
c_func
(paren
id|type
)paren
suffix:semicolon
)brace
r_else
(brace
id|vhdr-&gt;h_vlan_encapsulated_proto
op_assign
id|htons
c_func
(paren
id|len
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Before delegating work to the lower layer, enter our MAC-address */
r_if
c_cond
(paren
id|saddr
op_eq
l_int|NULL
)paren
id|saddr
op_assign
id|dev-&gt;dev_addr
suffix:semicolon
id|dev
op_assign
id|VLAN_DEV_INFO
c_func
(paren
id|dev
)paren
op_member_access_from_pointer
id|real_dev
suffix:semicolon
multiline_comment|/* MPLS can send us skbuffs w/out enough space.&t; This check will grow the&n;&t; * skb if it doesn&squot;t have enough headroom.  Not a beautiful solution, so&n;&t; * I&squot;ll tick a counter so that users can know it&squot;s happening...&t; If they&n;&t; * care...&n;&t; */
multiline_comment|/* NOTE:  This may still break if the underlying device is not the final&n;&t; * device (and thus there are more headers to add...)  It should work for&n;&t; * good-ole-ethernet though.&n;&t; */
r_if
c_cond
(paren
id|skb_headroom
c_func
(paren
id|skb
)paren
OL
id|dev-&gt;hard_header_len
)paren
(brace
r_struct
id|sk_buff
op_star
id|sk_tmp
op_assign
id|skb
suffix:semicolon
id|skb
op_assign
id|skb_realloc_headroom
c_func
(paren
id|sk_tmp
comma
id|dev-&gt;hard_header_len
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|sk_tmp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
(brace
r_struct
id|net_device_stats
op_star
id|stats
op_assign
id|vlan_dev_get_stats
c_func
(paren
id|vdev
)paren
suffix:semicolon
id|stats-&gt;tx_dropped
op_increment
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|VLAN_DEV_INFO
c_func
(paren
id|vdev
)paren
op_member_access_from_pointer
id|cnt_inc_headroom_on_tx
op_increment
suffix:semicolon
macro_line|#ifdef VLAN_DEBUG
id|printk
c_func
(paren
id|VLAN_DBG
id|__FUNCTION__
l_string|&quot;: %s: had to grow skb.&bslash;n&quot;
comma
id|vdev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
)brace
r_if
c_cond
(paren
id|build_vlan_header
)paren
(brace
multiline_comment|/* Now make the underlying real hard header */
id|rc
op_assign
id|dev
op_member_access_from_pointer
id|hard_header
c_func
(paren
id|skb
comma
id|dev
comma
id|ETH_P_8021Q
comma
id|daddr
comma
id|saddr
comma
id|len
op_plus
id|VLAN_HLEN
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
OG
l_int|0
)paren
(brace
id|rc
op_add_assign
id|VLAN_HLEN
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|rc
OL
l_int|0
)paren
(brace
id|rc
op_sub_assign
id|VLAN_HLEN
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* If here, then we&squot;ll just make a normal looking ethernet frame,&n;&t;&t; * but, the hard_start_xmit method will insert the tag (it has to&n;&t;&t; * be able to do this for bridged and other skbs that don&squot;t come&n;&t;&t; * down the protocol stack in an orderly manner.&n;&t;&t; */
id|rc
op_assign
id|dev
op_member_access_from_pointer
id|hard_header
c_func
(paren
id|skb
comma
id|dev
comma
id|type
comma
id|daddr
comma
id|saddr
comma
id|len
)paren
suffix:semicolon
)brace
r_return
id|rc
suffix:semicolon
)brace
DECL|function|vlan_dev_hard_start_xmit
r_int
id|vlan_dev_hard_start_xmit
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|net_device_stats
op_star
id|stats
op_assign
id|vlan_dev_get_stats
c_func
(paren
id|dev
)paren
suffix:semicolon
r_struct
id|vlan_ethhdr
op_star
id|veth
op_assign
(paren
r_struct
id|vlan_ethhdr
op_star
)paren
(paren
id|skb-&gt;data
)paren
suffix:semicolon
multiline_comment|/* Handle non-VLAN frames if they are sent to us, for example by DHCP.&n;&t; *&n;&t; * NOTE: THIS ASSUMES DIX ETHERNET, SPECIFICALLY NOT SUPPORTING&n;&t; * OTHER THINGS LIKE FDDI/TokenRing/802.3 SNAPs...&n;&t; */
r_if
c_cond
(paren
id|veth-&gt;h_vlan_proto
op_ne
id|__constant_htons
c_func
(paren
id|ETH_P_8021Q
)paren
)paren
(brace
r_int
r_int
id|veth_TCI
suffix:semicolon
multiline_comment|/* This is not a VLAN frame...but we can fix that! */
id|VLAN_DEV_INFO
c_func
(paren
id|dev
)paren
op_member_access_from_pointer
id|cnt_encap_on_xmit
op_increment
suffix:semicolon
macro_line|#ifdef VLAN_DEBUG
id|printk
c_func
(paren
id|VLAN_DBG
id|__FUNCTION__
l_string|&quot;: proto to encap: 0x%hx (hbo)&bslash;n&quot;
comma
id|htons
c_func
(paren
id|veth-&gt;h_vlan_proto
)paren
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|skb_headroom
c_func
(paren
id|skb
)paren
OL
id|VLAN_HLEN
)paren
(brace
r_struct
id|sk_buff
op_star
id|sk_tmp
op_assign
id|skb
suffix:semicolon
id|skb
op_assign
id|skb_realloc_headroom
c_func
(paren
id|sk_tmp
comma
id|VLAN_HLEN
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|sk_tmp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
(brace
id|stats-&gt;tx_dropped
op_increment
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|VLAN_DEV_INFO
c_func
(paren
id|dev
)paren
op_member_access_from_pointer
id|cnt_inc_headroom_on_tx
op_increment
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|skb
op_assign
id|skb_unshare
c_func
(paren
id|skb
comma
id|GFP_ATOMIC
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;vlan: failed to unshare skbuff&bslash;n&quot;
)paren
suffix:semicolon
id|stats-&gt;tx_dropped
op_increment
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
)brace
id|veth
op_assign
(paren
r_struct
id|vlan_ethhdr
op_star
)paren
id|skb_push
c_func
(paren
id|skb
comma
id|VLAN_HLEN
)paren
suffix:semicolon
multiline_comment|/* Move the mac addresses to the beginning of the new header. */
id|memmove
c_func
(paren
id|skb-&gt;data
comma
id|skb-&gt;data
op_plus
id|VLAN_HLEN
comma
l_int|12
)paren
suffix:semicolon
multiline_comment|/* first, the ethernet type */
multiline_comment|/* put_unaligned(__constant_htons(ETH_P_8021Q), &amp;veth-&gt;h_vlan_proto); */
id|veth-&gt;h_vlan_proto
op_assign
id|__constant_htons
c_func
(paren
id|ETH_P_8021Q
)paren
suffix:semicolon
multiline_comment|/* Now, construct the second two bytes. This field looks something&n;&t;&t; * like:&n;&t;&t; * usr_priority: 3 bits&t; (high bits)&n;&t;&t; * CFI&t;&t; 1 bit&n;&t;&t; * VLAN ID&t; 12 bits (low bits)&n;&t;&t; */
id|veth_TCI
op_assign
id|VLAN_DEV_INFO
c_func
(paren
id|dev
)paren
op_member_access_from_pointer
id|vlan_id
suffix:semicolon
id|veth_TCI
op_or_assign
id|vlan_dev_get_egress_qos_mask
c_func
(paren
id|dev
comma
id|skb
)paren
suffix:semicolon
id|veth-&gt;h_vlan_TCI
op_assign
id|htons
c_func
(paren
id|veth_TCI
)paren
suffix:semicolon
)brace
id|skb-&gt;dev
op_assign
id|VLAN_DEV_INFO
c_func
(paren
id|dev
)paren
op_member_access_from_pointer
id|real_dev
suffix:semicolon
macro_line|#ifdef VLAN_DEBUG
id|printk
c_func
(paren
id|VLAN_DBG
id|__FUNCTION__
l_string|&quot;: about to send skb: %p to dev: %s&bslash;n&quot;
comma
id|skb
comma
id|skb-&gt;dev-&gt;name
)paren
suffix:semicolon
id|printk
c_func
(paren
id|VLAN_DBG
l_string|&quot;  %2hx.%2hx.%2hx.%2xh.%2hx.%2hx %2hx.%2hx.%2hx.%2hx.%2hx.%2hx %4hx %4hx %4hx&bslash;n&quot;
comma
id|veth-&gt;h_dest
(braket
l_int|0
)braket
comma
id|veth-&gt;h_dest
(braket
l_int|1
)braket
comma
id|veth-&gt;h_dest
(braket
l_int|2
)braket
comma
id|veth-&gt;h_dest
(braket
l_int|3
)braket
comma
id|veth-&gt;h_dest
(braket
l_int|4
)braket
comma
id|veth-&gt;h_dest
(braket
l_int|5
)braket
comma
id|veth-&gt;h_source
(braket
l_int|0
)braket
comma
id|veth-&gt;h_source
(braket
l_int|1
)braket
comma
id|veth-&gt;h_source
(braket
l_int|2
)braket
comma
id|veth-&gt;h_source
(braket
l_int|3
)braket
comma
id|veth-&gt;h_source
(braket
l_int|4
)braket
comma
id|veth-&gt;h_source
(braket
l_int|5
)braket
comma
id|veth-&gt;h_vlan_proto
comma
id|veth-&gt;h_vlan_TCI
comma
id|veth-&gt;h_vlan_encapsulated_proto
)paren
suffix:semicolon
macro_line|#endif
id|stats-&gt;tx_packets
op_increment
suffix:semicolon
multiline_comment|/* for statics only */
id|stats-&gt;tx_bytes
op_add_assign
id|skb-&gt;len
suffix:semicolon
id|dev_queue_xmit
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|vlan_dev_hwaccel_hard_start_xmit
r_int
id|vlan_dev_hwaccel_hard_start_xmit
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|net_device_stats
op_star
id|stats
op_assign
id|vlan_dev_get_stats
c_func
(paren
id|dev
)paren
suffix:semicolon
r_struct
id|vlan_skb_tx_cookie
op_star
id|cookie
suffix:semicolon
id|stats-&gt;tx_packets
op_increment
suffix:semicolon
id|stats-&gt;tx_bytes
op_add_assign
id|skb-&gt;len
suffix:semicolon
id|skb-&gt;dev
op_assign
id|VLAN_DEV_INFO
c_func
(paren
id|dev
)paren
op_member_access_from_pointer
id|real_dev
suffix:semicolon
id|cookie
op_assign
id|VLAN_TX_SKB_CB
c_func
(paren
id|skb
)paren
suffix:semicolon
id|cookie-&gt;magic
op_assign
id|VLAN_TX_COOKIE_MAGIC
suffix:semicolon
id|cookie-&gt;vlan_tag
op_assign
(paren
id|VLAN_DEV_INFO
c_func
(paren
id|dev
)paren
op_member_access_from_pointer
id|vlan_id
op_or
id|vlan_dev_get_egress_qos_mask
c_func
(paren
id|dev
comma
id|skb
)paren
)paren
suffix:semicolon
id|dev_queue_xmit
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|vlan_dev_change_mtu
r_int
id|vlan_dev_change_mtu
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|new_mtu
)paren
(brace
multiline_comment|/* TODO: gotta make sure the underlying layer can handle it,&n;&t; * maybe an IFF_VLAN_CAPABLE flag for devices?&n;&t; */
r_if
c_cond
(paren
id|VLAN_DEV_INFO
c_func
(paren
id|dev
)paren
op_member_access_from_pointer
id|real_dev-&gt;mtu
OL
id|new_mtu
)paren
r_return
op_minus
id|ERANGE
suffix:semicolon
id|dev-&gt;mtu
op_assign
id|new_mtu
suffix:semicolon
r_return
id|new_mtu
suffix:semicolon
)brace
DECL|function|vlan_dev_set_ingress_priority
r_int
id|vlan_dev_set_ingress_priority
c_func
(paren
r_char
op_star
id|dev_name
comma
id|__u32
id|skb_prio
comma
r_int
id|vlan_prio
)paren
(brace
r_struct
id|net_device
op_star
id|dev
op_assign
id|dev_get_by_name
c_func
(paren
id|dev_name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev
)paren
(brace
r_if
c_cond
(paren
id|dev-&gt;priv_flags
op_amp
id|IFF_802_1Q_VLAN
)paren
(brace
multiline_comment|/* see if a priority mapping exists.. */
id|VLAN_DEV_INFO
c_func
(paren
id|dev
)paren
op_member_access_from_pointer
id|ingress_priority_map
(braket
id|vlan_prio
op_amp
l_int|0x7
)braket
op_assign
id|skb_prio
suffix:semicolon
id|dev_put
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|dev_put
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
DECL|function|vlan_dev_set_egress_priority
r_int
id|vlan_dev_set_egress_priority
c_func
(paren
r_char
op_star
id|dev_name
comma
id|__u32
id|skb_prio
comma
r_int
id|vlan_prio
)paren
(brace
r_struct
id|net_device
op_star
id|dev
op_assign
id|dev_get_by_name
c_func
(paren
id|dev_name
)paren
suffix:semicolon
r_struct
id|vlan_priority_tci_mapping
op_star
id|mp
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|vlan_priority_tci_mapping
op_star
id|np
suffix:semicolon
r_if
c_cond
(paren
id|dev
)paren
(brace
r_if
c_cond
(paren
id|dev-&gt;priv_flags
op_amp
id|IFF_802_1Q_VLAN
)paren
(brace
multiline_comment|/* See if a priority mapping exists.. */
id|mp
op_assign
id|VLAN_DEV_INFO
c_func
(paren
id|dev
)paren
op_member_access_from_pointer
id|egress_priority_map
(braket
id|skb_prio
op_amp
l_int|0xF
)braket
suffix:semicolon
r_while
c_loop
(paren
id|mp
)paren
(brace
r_if
c_cond
(paren
id|mp-&gt;priority
op_eq
id|skb_prio
)paren
(brace
id|mp-&gt;vlan_qos
op_assign
(paren
(paren
id|vlan_prio
op_lshift
l_int|13
)paren
op_amp
l_int|0xE000
)paren
suffix:semicolon
id|dev_put
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/* Create a new mapping then. */
id|mp
op_assign
id|VLAN_DEV_INFO
c_func
(paren
id|dev
)paren
op_member_access_from_pointer
id|egress_priority_map
(braket
id|skb_prio
op_amp
l_int|0xF
)braket
suffix:semicolon
id|np
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|vlan_priority_tci_mapping
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|np
)paren
(brace
id|np-&gt;next
op_assign
id|mp
suffix:semicolon
id|np-&gt;priority
op_assign
id|skb_prio
suffix:semicolon
id|np-&gt;vlan_qos
op_assign
(paren
(paren
id|vlan_prio
op_lshift
l_int|13
)paren
op_amp
l_int|0xE000
)paren
suffix:semicolon
id|VLAN_DEV_INFO
c_func
(paren
id|dev
)paren
op_member_access_from_pointer
id|egress_priority_map
(braket
id|skb_prio
op_amp
l_int|0xF
)braket
op_assign
id|np
suffix:semicolon
id|dev_put
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|dev_put
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
op_minus
id|ENOBUFS
suffix:semicolon
)brace
)brace
id|dev_put
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* Flags are defined in the vlan_dev_info class in include/linux/if_vlan.h file. */
DECL|function|vlan_dev_set_vlan_flag
r_int
id|vlan_dev_set_vlan_flag
c_func
(paren
r_char
op_star
id|dev_name
comma
id|__u32
id|flag
comma
r_int
id|flag_val
)paren
(brace
r_struct
id|net_device
op_star
id|dev
op_assign
id|dev_get_by_name
c_func
(paren
id|dev_name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev
)paren
(brace
r_if
c_cond
(paren
id|dev-&gt;priv_flags
op_amp
id|IFF_802_1Q_VLAN
)paren
(brace
multiline_comment|/* verify flag is supported */
r_if
c_cond
(paren
id|flag
op_eq
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|flag_val
)paren
(brace
id|VLAN_DEV_INFO
c_func
(paren
id|dev
)paren
op_member_access_from_pointer
id|flags
op_or_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|VLAN_DEV_INFO
c_func
(paren
id|dev
)paren
op_member_access_from_pointer
id|flags
op_and_assign
op_complement
l_int|1
suffix:semicolon
)brace
id|dev_put
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_ERR
id|__FUNCTION__
l_string|&quot;: flag %i is not valid.&bslash;n&quot;
comma
(paren
r_int
)paren
(paren
id|flag
)paren
)paren
suffix:semicolon
id|dev_put
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_ERR
id|__FUNCTION__
l_string|&quot;: %s is not a vlan device, priv_flags: %hX.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|dev-&gt;priv_flags
)paren
suffix:semicolon
id|dev_put
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_ERR
id|__FUNCTION__
l_string|&quot;: Could not find device: %s&bslash;n&quot;
comma
id|dev_name
)paren
suffix:semicolon
)brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
DECL|function|vlan_dev_set_mac_address
r_int
id|vlan_dev_set_mac_address
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_void
op_star
id|addr_struct_p
)paren
(brace
r_struct
id|sockaddr
op_star
id|addr
op_assign
(paren
r_struct
id|sockaddr
op_star
)paren
(paren
id|addr_struct_p
)paren
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|netif_running
c_func
(paren
id|dev
)paren
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
id|memcpy
c_func
(paren
id|dev-&gt;dev_addr
comma
id|addr-&gt;sa_data
comma
id|dev-&gt;addr_len
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: Setting MAC address to &quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot; %2.2x&quot;
comma
id|dev-&gt;dev_addr
(braket
id|i
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;.&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|VLAN_DEV_INFO
c_func
(paren
id|dev
)paren
op_member_access_from_pointer
id|real_dev-&gt;dev_addr
comma
id|dev-&gt;dev_addr
comma
id|dev-&gt;addr_len
)paren
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|VLAN_DEV_INFO
c_func
(paren
id|dev
)paren
op_member_access_from_pointer
id|real_dev-&gt;flags
op_amp
id|IFF_PROMISC
)paren
)paren
(brace
r_int
id|flgs
op_assign
id|VLAN_DEV_INFO
c_func
(paren
id|dev
)paren
op_member_access_from_pointer
id|real_dev-&gt;flags
suffix:semicolon
multiline_comment|/* Increment our in-use promiscuity counter */
id|dev_set_promiscuity
c_func
(paren
id|VLAN_DEV_INFO
c_func
(paren
id|dev
)paren
op_member_access_from_pointer
id|real_dev
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Make PROMISC visible to the user. */
id|flgs
op_or_assign
id|IFF_PROMISC
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;VLAN (%s):  Setting underlying device (%s) to promiscious mode.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|VLAN_DEV_INFO
c_func
(paren
id|dev
)paren
op_member_access_from_pointer
id|real_dev-&gt;name
)paren
suffix:semicolon
id|dev_change_flags
c_func
(paren
id|VLAN_DEV_INFO
c_func
(paren
id|dev
)paren
op_member_access_from_pointer
id|real_dev
comma
id|flgs
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;VLAN (%s):  Underlying device (%s) has same MAC, not checking promiscious mode.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|VLAN_DEV_INFO
c_func
(paren
id|dev
)paren
op_member_access_from_pointer
id|real_dev-&gt;name
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|vlan_dmi_equals
r_static
r_inline
r_int
id|vlan_dmi_equals
c_func
(paren
r_struct
id|dev_mc_list
op_star
id|dmi1
comma
r_struct
id|dev_mc_list
op_star
id|dmi2
)paren
(brace
r_return
(paren
(paren
id|dmi1-&gt;dmi_addrlen
op_eq
id|dmi2-&gt;dmi_addrlen
)paren
op_logical_and
(paren
id|memcmp
c_func
(paren
id|dmi1-&gt;dmi_addr
comma
id|dmi2-&gt;dmi_addr
comma
id|dmi1-&gt;dmi_addrlen
)paren
op_eq
l_int|0
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/** dmi is a single entry into a dev_mc_list, a single node.  mc_list is&n; *  an entire list, and we&squot;ll iterate through it.&n; */
DECL|function|vlan_should_add_mc
r_static
r_int
id|vlan_should_add_mc
c_func
(paren
r_struct
id|dev_mc_list
op_star
id|dmi
comma
r_struct
id|dev_mc_list
op_star
id|mc_list
)paren
(brace
r_struct
id|dev_mc_list
op_star
id|idmi
suffix:semicolon
r_for
c_loop
(paren
id|idmi
op_assign
id|mc_list
suffix:semicolon
id|idmi
op_ne
l_int|NULL
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
id|vlan_dmi_equals
c_func
(paren
id|dmi
comma
id|idmi
)paren
)paren
(brace
r_if
c_cond
(paren
id|dmi-&gt;dmi_users
OG
id|idmi-&gt;dmi_users
)paren
r_return
l_int|1
suffix:semicolon
r_else
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|idmi
op_assign
id|idmi-&gt;next
suffix:semicolon
)brace
)brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|vlan_destroy_mc_list
r_static
r_inline
r_void
id|vlan_destroy_mc_list
c_func
(paren
r_struct
id|dev_mc_list
op_star
id|mc_list
)paren
(brace
r_struct
id|dev_mc_list
op_star
id|dmi
op_assign
id|mc_list
suffix:semicolon
r_struct
id|dev_mc_list
op_star
id|next
suffix:semicolon
r_while
c_loop
(paren
id|dmi
)paren
(brace
id|next
op_assign
id|dmi-&gt;next
suffix:semicolon
id|kfree
c_func
(paren
id|dmi
)paren
suffix:semicolon
id|dmi
op_assign
id|next
suffix:semicolon
)brace
)brace
DECL|function|vlan_copy_mc_list
r_static
r_void
id|vlan_copy_mc_list
c_func
(paren
r_struct
id|dev_mc_list
op_star
id|mc_list
comma
r_struct
id|vlan_dev_info
op_star
id|vlan_info
)paren
(brace
r_struct
id|dev_mc_list
op_star
id|dmi
comma
op_star
id|new_dmi
suffix:semicolon
id|vlan_destroy_mc_list
c_func
(paren
id|vlan_info-&gt;old_mc_list
)paren
suffix:semicolon
id|vlan_info-&gt;old_mc_list
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|dmi
op_assign
id|mc_list
suffix:semicolon
id|dmi
op_ne
l_int|NULL
suffix:semicolon
id|dmi
op_assign
id|dmi-&gt;next
)paren
(brace
id|new_dmi
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|new_dmi
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|new_dmi
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;vlan: cannot allocate memory. &quot;
l_string|&quot;Multicast may not work properly from now.&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Copy whole structure, then make new &squot;next&squot; pointer */
op_star
id|new_dmi
op_assign
op_star
id|dmi
suffix:semicolon
id|new_dmi-&gt;next
op_assign
id|vlan_info-&gt;old_mc_list
suffix:semicolon
id|vlan_info-&gt;old_mc_list
op_assign
id|new_dmi
suffix:semicolon
)brace
)brace
DECL|function|vlan_flush_mc_list
r_static
r_void
id|vlan_flush_mc_list
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|dev_mc_list
op_star
id|dmi
op_assign
id|dev-&gt;mc_list
suffix:semicolon
r_while
c_loop
(paren
id|dmi
)paren
(brace
id|dev_mc_delete
c_func
(paren
id|dev
comma
id|dmi-&gt;dmi_addr
comma
id|dmi-&gt;dmi_addrlen
comma
l_int|0
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: del %.2x:%.2x:%.2x:%.2x:%.2x:%.2x mcast address from vlan interface&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|dmi-&gt;dmi_addr
(braket
l_int|0
)braket
comma
id|dmi-&gt;dmi_addr
(braket
l_int|1
)braket
comma
id|dmi-&gt;dmi_addr
(braket
l_int|2
)braket
comma
id|dmi-&gt;dmi_addr
(braket
l_int|3
)braket
comma
id|dmi-&gt;dmi_addr
(braket
l_int|4
)braket
comma
id|dmi-&gt;dmi_addr
(braket
l_int|5
)braket
)paren
suffix:semicolon
id|dmi
op_assign
id|dev-&gt;mc_list
suffix:semicolon
)brace
multiline_comment|/* dev-&gt;mc_list is NULL by the time we get here. */
id|vlan_destroy_mc_list
c_func
(paren
id|VLAN_DEV_INFO
c_func
(paren
id|dev
)paren
op_member_access_from_pointer
id|old_mc_list
)paren
suffix:semicolon
id|VLAN_DEV_INFO
c_func
(paren
id|dev
)paren
op_member_access_from_pointer
id|old_mc_list
op_assign
l_int|NULL
suffix:semicolon
)brace
DECL|function|vlan_dev_open
r_int
id|vlan_dev_open
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|VLAN_DEV_INFO
c_func
(paren
id|dev
)paren
op_member_access_from_pointer
id|real_dev-&gt;flags
op_amp
id|IFF_UP
)paren
)paren
r_return
op_minus
id|ENETDOWN
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|vlan_dev_stop
r_int
id|vlan_dev_stop
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
id|vlan_flush_mc_list
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|vlan_dev_init
r_int
id|vlan_dev_init
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
multiline_comment|/* TODO:  figure this out, maybe do nothing?? */
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|vlan_dev_destruct
r_void
id|vlan_dev_destruct
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_if
c_cond
(paren
id|dev
)paren
(brace
id|vlan_flush_mc_list
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;priv
)paren
(brace
r_if
c_cond
(paren
id|VLAN_DEV_INFO
c_func
(paren
id|dev
)paren
op_member_access_from_pointer
id|dent
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|dev-&gt;priv
)paren
suffix:semicolon
id|dev-&gt;priv
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/** Taken from Gleb + Lennert&squot;s VLAN code, and modified... */
DECL|function|vlan_dev_set_multicast_list
r_void
id|vlan_dev_set_multicast_list
c_func
(paren
r_struct
id|net_device
op_star
id|vlan_dev
)paren
(brace
r_struct
id|dev_mc_list
op_star
id|dmi
suffix:semicolon
r_struct
id|net_device
op_star
id|real_dev
suffix:semicolon
r_int
id|inc
suffix:semicolon
r_if
c_cond
(paren
id|vlan_dev
op_logical_and
(paren
id|vlan_dev-&gt;priv_flags
op_amp
id|IFF_802_1Q_VLAN
)paren
)paren
(brace
multiline_comment|/* Then it&squot;s a real vlan device, as far as we can tell.. */
id|real_dev
op_assign
id|VLAN_DEV_INFO
c_func
(paren
id|vlan_dev
)paren
op_member_access_from_pointer
id|real_dev
suffix:semicolon
multiline_comment|/* compare the current promiscuity to the last promisc we had.. */
id|inc
op_assign
id|vlan_dev-&gt;promiscuity
op_minus
id|VLAN_DEV_INFO
c_func
(paren
id|vlan_dev
)paren
op_member_access_from_pointer
id|old_promiscuity
suffix:semicolon
r_if
c_cond
(paren
id|inc
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: dev_set_promiscuity(master, %d)&bslash;n&quot;
comma
id|vlan_dev-&gt;name
comma
id|inc
)paren
suffix:semicolon
id|dev_set_promiscuity
c_func
(paren
id|real_dev
comma
id|inc
)paren
suffix:semicolon
multiline_comment|/* found in dev.c */
id|VLAN_DEV_INFO
c_func
(paren
id|vlan_dev
)paren
op_member_access_from_pointer
id|old_promiscuity
op_assign
id|vlan_dev-&gt;promiscuity
suffix:semicolon
)brace
id|inc
op_assign
id|vlan_dev-&gt;allmulti
op_minus
id|VLAN_DEV_INFO
c_func
(paren
id|vlan_dev
)paren
op_member_access_from_pointer
id|old_allmulti
suffix:semicolon
r_if
c_cond
(paren
id|inc
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: dev_set_allmulti(master, %d)&bslash;n&quot;
comma
id|vlan_dev-&gt;name
comma
id|inc
)paren
suffix:semicolon
id|dev_set_allmulti
c_func
(paren
id|real_dev
comma
id|inc
)paren
suffix:semicolon
multiline_comment|/* dev.c */
id|VLAN_DEV_INFO
c_func
(paren
id|vlan_dev
)paren
op_member_access_from_pointer
id|old_allmulti
op_assign
id|vlan_dev-&gt;allmulti
suffix:semicolon
)brace
multiline_comment|/* looking for addresses to add to master&squot;s list */
r_for
c_loop
(paren
id|dmi
op_assign
id|vlan_dev-&gt;mc_list
suffix:semicolon
id|dmi
op_ne
l_int|NULL
suffix:semicolon
id|dmi
op_assign
id|dmi-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|vlan_should_add_mc
c_func
(paren
id|dmi
comma
id|VLAN_DEV_INFO
c_func
(paren
id|vlan_dev
)paren
op_member_access_from_pointer
id|old_mc_list
)paren
)paren
(brace
id|dev_mc_add
c_func
(paren
id|real_dev
comma
id|dmi-&gt;dmi_addr
comma
id|dmi-&gt;dmi_addrlen
comma
l_int|0
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: add %.2x:%.2x:%.2x:%.2x:%.2x:%.2x mcast address to master interface&bslash;n&quot;
comma
id|vlan_dev-&gt;name
comma
id|dmi-&gt;dmi_addr
(braket
l_int|0
)braket
comma
id|dmi-&gt;dmi_addr
(braket
l_int|1
)braket
comma
id|dmi-&gt;dmi_addr
(braket
l_int|2
)braket
comma
id|dmi-&gt;dmi_addr
(braket
l_int|3
)braket
comma
id|dmi-&gt;dmi_addr
(braket
l_int|4
)braket
comma
id|dmi-&gt;dmi_addr
(braket
l_int|5
)braket
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* looking for addresses to delete from master&squot;s list */
r_for
c_loop
(paren
id|dmi
op_assign
id|VLAN_DEV_INFO
c_func
(paren
id|vlan_dev
)paren
op_member_access_from_pointer
id|old_mc_list
suffix:semicolon
id|dmi
op_ne
l_int|NULL
suffix:semicolon
id|dmi
op_assign
id|dmi-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|vlan_should_add_mc
c_func
(paren
id|dmi
comma
id|vlan_dev-&gt;mc_list
)paren
)paren
(brace
multiline_comment|/* if we think we should add it to the new list, then we should really&n;&t;&t;&t;&t; * delete it from the real list on the underlying device.&n;&t;&t;&t;&t; */
id|dev_mc_delete
c_func
(paren
id|real_dev
comma
id|dmi-&gt;dmi_addr
comma
id|dmi-&gt;dmi_addrlen
comma
l_int|0
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: del %.2x:%.2x:%.2x:%.2x:%.2x:%.2x mcast address from master interface&bslash;n&quot;
comma
id|vlan_dev-&gt;name
comma
id|dmi-&gt;dmi_addr
(braket
l_int|0
)braket
comma
id|dmi-&gt;dmi_addr
(braket
l_int|1
)braket
comma
id|dmi-&gt;dmi_addr
(braket
l_int|2
)braket
comma
id|dmi-&gt;dmi_addr
(braket
l_int|3
)braket
comma
id|dmi-&gt;dmi_addr
(braket
l_int|4
)braket
comma
id|dmi-&gt;dmi_addr
(braket
l_int|5
)braket
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* save multicast list */
id|vlan_copy_mc_list
c_func
(paren
id|vlan_dev-&gt;mc_list
comma
id|VLAN_DEV_INFO
c_func
(paren
id|vlan_dev
)paren
)paren
suffix:semicolon
)brace
)brace
eof
