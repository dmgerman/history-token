multiline_comment|/*********************************************************************&n; *                &n; * Filename:      irlan_eth.c&n; * Version:       &n; * Description:   &n; * Status:        Experimental.&n; * Author:        Dag Brattli &lt;dagb@cs.uit.no&gt;&n; * Created at:    Thu Oct 15 08:37:58 1998&n; * Modified at:   Tue Mar 21 09:06:41 2000&n; * Modified by:   Dag Brattli &lt;dagb@cs.uit.no&gt;&n; * Sources:       skeleton.c by Donald Becker &lt;becker@CESDIS.gsfc.nasa.gov&gt;&n; *                slip.c by Laurence Culhane,   &lt;loz@holmes.demon.co.uk&gt;&n; *                          Fred N. van Kempen, &lt;waltje@uwalt.nl.mugnet.org&gt;&n; * &n; *     Copyright (c) 1998-2000 Dag Brattli, All Rights Reserved.&n; *      &n; *     This program is free software; you can redistribute it and/or &n; *     modify it under the terms of the GNU General Public License as &n; *     published by the Free Software Foundation; either version 2 of &n; *     the License, or (at your option) any later version.&n; *  &n; *     Neither Dag Brattli nor University of Troms&#xfffd; admit liability nor&n; *     provide warranty for any of this software. This material is &n; *     provided &quot;AS-IS&quot; and at no charge.&n; *     &n; ********************************************************************/
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/etherdevice.h&gt;
macro_line|#include &lt;linux/inetdevice.h&gt;
macro_line|#include &lt;linux/if_arp.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;net/arp.h&gt;
macro_line|#include &lt;net/irda/irda.h&gt;
macro_line|#include &lt;net/irda/irmod.h&gt;
macro_line|#include &lt;net/irda/irlan_common.h&gt;
macro_line|#include &lt;net/irda/irlan_client.h&gt;
macro_line|#include &lt;net/irda/irlan_event.h&gt;
macro_line|#include &lt;net/irda/irlan_eth.h&gt;
r_static
r_int
id|irlan_eth_open
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|irlan_eth_close
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|irlan_eth_xmit
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|irlan_eth_set_multicast_list
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_struct
id|net_device_stats
op_star
id|irlan_eth_get_stats
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
multiline_comment|/*&n; * Function irlan_eth_setup (dev)&n; *&n; *    The network device initialization function.&n; *&n; */
DECL|function|irlan_eth_setup
r_static
r_void
id|irlan_eth_setup
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
id|dev-&gt;open
op_assign
id|irlan_eth_open
suffix:semicolon
id|dev-&gt;stop
op_assign
id|irlan_eth_close
suffix:semicolon
id|dev-&gt;hard_start_xmit
op_assign
id|irlan_eth_xmit
suffix:semicolon
id|dev-&gt;get_stats
op_assign
id|irlan_eth_get_stats
suffix:semicolon
id|dev-&gt;set_multicast_list
op_assign
id|irlan_eth_set_multicast_list
suffix:semicolon
id|dev-&gt;destructor
op_assign
id|free_netdev
suffix:semicolon
id|SET_MODULE_OWNER
c_func
(paren
id|dev
)paren
suffix:semicolon
id|ether_setup
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * Lets do all queueing in IrTTP instead of this device driver.&n;&t; * Queueing here as well can introduce some strange latency&n;&t; * problems, which we will avoid by setting the queue size to 0.&n;&t; */
multiline_comment|/*&n;&t; * The bugs in IrTTP and IrLAN that created this latency issue&n;&t; * have now been fixed, and we can propagate flow control properly&n;&t; * to the network layer. However, this requires a minimal queue of&n;&t; * packets for the device.&n;&t; * Without flow control, the Tx Queue is 14 (ttp) + 0 (dev) = 14&n;&t; * With flow control, the Tx Queue is 7 (ttp) + 4 (dev) = 11&n;&t; * See irlan_eth_flow_indication()...&n;&t; * Note : this number was randomly selected and would need to&n;&t; * be adjusted.&n;&t; * Jean II */
id|dev-&gt;tx_queue_len
op_assign
l_int|4
suffix:semicolon
)brace
multiline_comment|/*&n; * Function alloc_irlandev&n; *&n; *    Allocate network device and control block&n; *&n; */
DECL|function|alloc_irlandev
r_struct
id|net_device
op_star
id|alloc_irlandev
c_func
(paren
r_const
r_char
op_star
id|name
)paren
(brace
r_return
id|alloc_netdev
c_func
(paren
r_sizeof
(paren
r_struct
id|irlan_cb
)paren
comma
id|name
comma
id|irlan_eth_setup
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irlan_eth_open (dev)&n; *&n; *    Network device has been opened by user&n; *&n; */
DECL|function|irlan_eth_open
r_static
r_int
id|irlan_eth_open
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|irlan_cb
op_star
id|self
op_assign
id|netdev_priv
c_func
(paren
id|dev
)paren
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|2
comma
l_string|&quot;%s()&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
multiline_comment|/* Ready to play! */
id|netif_stop_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Wait until data link is ready */
multiline_comment|/* We are now open, so time to do some work */
id|self-&gt;disconnect_reason
op_assign
l_int|0
suffix:semicolon
id|irlan_client_wakeup
c_func
(paren
id|self
comma
id|self-&gt;saddr
comma
id|self-&gt;daddr
)paren
suffix:semicolon
multiline_comment|/* Make sure we have a hardware address before we return, so DHCP clients gets happy */
id|interruptible_sleep_on
c_func
(paren
op_amp
id|self-&gt;open_wait
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irlan_eth_close (dev)&n; *&n; *    Stop the ether network device, his function will usually be called by&n; *    ifconfig down. We should now disconnect the link, We start the &n; *    close timer, so that the instance will be removed if we are unable&n; *    to discover the remote device after the disconnect.&n; */
DECL|function|irlan_eth_close
r_static
r_int
id|irlan_eth_close
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|irlan_cb
op_star
id|self
op_assign
id|netdev_priv
c_func
(paren
id|dev
)paren
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|2
comma
l_string|&quot;%s()&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
multiline_comment|/* Stop device */
id|netif_stop_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
id|irlan_close_data_channel
c_func
(paren
id|self
)paren
suffix:semicolon
id|irlan_close_tsaps
c_func
(paren
id|self
)paren
suffix:semicolon
id|irlan_do_client_event
c_func
(paren
id|self
comma
id|IRLAN_LMP_DISCONNECT
comma
l_int|NULL
)paren
suffix:semicolon
id|irlan_do_provider_event
c_func
(paren
id|self
comma
id|IRLAN_LMP_DISCONNECT
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* Remove frames queued on the control channel */
id|skb_queue_purge
c_func
(paren
op_amp
id|self-&gt;client.txq
)paren
suffix:semicolon
id|self-&gt;client.tx_busy
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irlan_eth_tx (skb)&n; *&n; *    Transmits ethernet frames over IrDA link.&n; *&n; */
DECL|function|irlan_eth_xmit
r_static
r_int
id|irlan_eth_xmit
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|irlan_cb
op_star
id|self
op_assign
id|netdev_priv
c_func
(paren
id|dev
)paren
suffix:semicolon
r_int
id|ret
suffix:semicolon
multiline_comment|/* skb headroom large enough to contain all IrDA-headers? */
r_if
c_cond
(paren
(paren
id|skb_headroom
c_func
(paren
id|skb
)paren
OL
id|self-&gt;max_header_size
)paren
op_logical_or
(paren
id|skb_shared
c_func
(paren
id|skb
)paren
)paren
)paren
(brace
r_struct
id|sk_buff
op_star
id|new_skb
op_assign
id|skb_realloc_headroom
c_func
(paren
id|skb
comma
id|self-&gt;max_header_size
)paren
suffix:semicolon
multiline_comment|/*  We have to free the original skb anyway */
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
multiline_comment|/* Did the realloc succeed? */
r_if
c_cond
(paren
id|new_skb
op_eq
l_int|NULL
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Use the new skb instead */
id|skb
op_assign
id|new_skb
suffix:semicolon
)brace
id|dev-&gt;trans_start
op_assign
id|jiffies
suffix:semicolon
multiline_comment|/* Now queue the packet in the transport layer */
r_if
c_cond
(paren
id|self-&gt;use_udata
)paren
id|ret
op_assign
id|irttp_udata_request
c_func
(paren
id|self-&gt;tsap_data
comma
id|skb
)paren
suffix:semicolon
r_else
id|ret
op_assign
id|irttp_data_request
c_func
(paren
id|self-&gt;tsap_data
comma
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
(brace
multiline_comment|/*   &n;&t;&t; * IrTTPs tx queue is full, so we just have to&n;&t;&t; * drop the frame! You might think that we should&n;&t;&t; * just return -1 and don&squot;t deallocate the frame,&n;&t;&t; * but that is dangerous since it&squot;s possible that&n;&t;&t; * we have replaced the original skb with a new&n;&t;&t; * one with larger headroom, and that would really&n;&t;&t; * confuse do_dev_queue_xmit() in dev.c! I have&n;&t;&t; * tried :-) DB &n;&t;&t; */
multiline_comment|/* irttp_data_request already free the packet */
id|self-&gt;stats.tx_dropped
op_increment
suffix:semicolon
)brace
r_else
(brace
id|self-&gt;stats.tx_packets
op_increment
suffix:semicolon
id|self-&gt;stats.tx_bytes
op_add_assign
id|skb-&gt;len
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irlan_eth_receive (handle, skb)&n; *&n; *    This function gets the data that is received on the data channel&n; *&n; */
DECL|function|irlan_eth_receive
r_int
id|irlan_eth_receive
c_func
(paren
r_void
op_star
id|instance
comma
r_void
op_star
id|sap
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|irlan_cb
op_star
id|self
op_assign
id|instance
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
(brace
op_increment
id|self-&gt;stats.rx_dropped
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|skb-&gt;len
OG
l_int|1
comma
r_return
l_int|0
suffix:semicolon
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * Adopt this frame! Important to set all these fields since they &n;&t; * might have been previously set by the low level IrDA network&n;&t; * device driver &n;&t; */
id|skb-&gt;dev
op_assign
id|self-&gt;dev
suffix:semicolon
id|skb-&gt;protocol
op_assign
id|eth_type_trans
c_func
(paren
id|skb
comma
id|skb-&gt;dev
)paren
suffix:semicolon
multiline_comment|/* Remove eth header */
id|self-&gt;stats.rx_packets
op_increment
suffix:semicolon
id|self-&gt;stats.rx_bytes
op_add_assign
id|skb-&gt;len
suffix:semicolon
id|netif_rx
c_func
(paren
id|skb
)paren
suffix:semicolon
multiline_comment|/* Eat it! */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irlan_eth_flow (status)&n; *&n; *    Do flow control between IP/Ethernet and IrLAN/IrTTP. This is done by &n; *    controlling the queue stop/start.&n; *&n; * The IrDA link layer has the advantage to have flow control, and&n; * IrTTP now properly handles that. Flow controlling the higher layers&n; * prevent us to drop Tx packets in here (up to 15% for a TCP socket,&n; * more for UDP socket).&n; * Also, this allow us to reduce the overall transmit queue, which means&n; * less latency in case of mixed traffic.&n; * Jean II&n; */
DECL|function|irlan_eth_flow_indication
r_void
id|irlan_eth_flow_indication
c_func
(paren
r_void
op_star
id|instance
comma
r_void
op_star
id|sap
comma
id|LOCAL_FLOW
id|flow
)paren
(brace
r_struct
id|irlan_cb
op_star
id|self
suffix:semicolon
r_struct
id|net_device
op_star
id|dev
suffix:semicolon
id|self
op_assign
(paren
r_struct
id|irlan_cb
op_star
)paren
id|instance
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|IRLAN_MAGIC
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|dev
op_assign
id|self-&gt;dev
suffix:semicolon
id|ASSERT
c_func
(paren
id|dev
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
l_string|&quot;%s() : flow %s ; running %d&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|flow
op_eq
id|FLOW_STOP
ques
c_cond
l_string|&quot;FLOW_STOP&quot;
suffix:colon
l_string|&quot;FLOW_START&quot;
comma
id|netif_running
c_func
(paren
id|dev
)paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|flow
)paren
(brace
r_case
id|FLOW_STOP
suffix:colon
multiline_comment|/* IrTTP is full, stop higher layers */
id|netif_stop_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FLOW_START
suffix:colon
r_default
suffix:colon
multiline_comment|/* Tell upper layers that its time to transmit frames again */
multiline_comment|/* Schedule network layer */
id|netif_wake_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Function irlan_etc_send_gratuitous_arp (dev)&n; *&n; *    Send gratuitous ARP to announce that we have changed&n; *    hardware address, so that all peers updates their ARP tables&n; */
DECL|function|irlan_eth_send_gratuitous_arp
r_void
id|irlan_eth_send_gratuitous_arp
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|in_device
op_star
id|in_dev
suffix:semicolon
multiline_comment|/* &n;&t; * When we get a new MAC address do a gratuitous ARP. This&n;&t; * is useful if we have changed access points on the same&n;&t; * subnet.  &n;&t; */
macro_line|#ifdef CONFIG_INET
id|IRDA_DEBUG
c_func
(paren
l_int|4
comma
l_string|&quot;IrLAN: Sending gratuitous ARP&bslash;n&quot;
)paren
suffix:semicolon
id|in_dev
op_assign
id|in_dev_get
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|in_dev
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|in_dev-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|in_dev-&gt;ifa_list
)paren
id|arp_send
c_func
(paren
id|ARPOP_REQUEST
comma
id|ETH_P_ARP
comma
id|in_dev-&gt;ifa_list-&gt;ifa_address
comma
id|dev
comma
id|in_dev-&gt;ifa_list-&gt;ifa_address
comma
l_int|NULL
comma
id|dev-&gt;dev_addr
comma
l_int|NULL
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|in_dev-&gt;lock
)paren
suffix:semicolon
id|in_dev_put
c_func
(paren
id|in_dev
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_INET */
)brace
multiline_comment|/*&n; * Function set_multicast_list (dev)&n; *&n; *    Configure the filtering of the device&n; *&n; */
DECL|macro|HW_MAX_ADDRS
mdefine_line|#define HW_MAX_ADDRS 4 /* Must query to get it! */
DECL|function|irlan_eth_set_multicast_list
r_static
r_void
id|irlan_eth_set_multicast_list
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|irlan_cb
op_star
id|self
op_assign
id|netdev_priv
c_func
(paren
id|dev
)paren
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|2
comma
l_string|&quot;%s()&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
multiline_comment|/* Check if data channel has been connected yet */
r_if
c_cond
(paren
id|self-&gt;client.state
op_ne
id|IRLAN_DATA
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;%s(), delaying!&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dev-&gt;flags
op_amp
id|IFF_PROMISC
)paren
(brace
multiline_comment|/* Enable promiscuous mode */
id|WARNING
c_func
(paren
l_string|&quot;Promiscous mode not implemented by IrLAN!&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|dev-&gt;flags
op_amp
id|IFF_ALLMULTI
)paren
op_logical_or
id|dev-&gt;mc_count
OG
id|HW_MAX_ADDRS
)paren
(brace
multiline_comment|/* Disable promiscuous mode, use normal mode. */
id|IRDA_DEBUG
c_func
(paren
l_int|4
comma
l_string|&quot;%s(), Setting multicast filter&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
multiline_comment|/* hardware_set_filter(NULL); */
id|irlan_set_multicast_filter
c_func
(paren
id|self
comma
id|TRUE
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|dev-&gt;mc_count
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|4
comma
l_string|&quot;%s(), Setting multicast filter&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
multiline_comment|/* Walk the address list, and load the filter */
multiline_comment|/* hardware_set_filter(dev-&gt;mc_list); */
id|irlan_set_multicast_filter
c_func
(paren
id|self
comma
id|TRUE
)paren
suffix:semicolon
)brace
r_else
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|4
comma
l_string|&quot;%s(), Clearing multicast filter&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
id|irlan_set_multicast_filter
c_func
(paren
id|self
comma
id|FALSE
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dev-&gt;flags
op_amp
id|IFF_BROADCAST
)paren
id|irlan_set_broadcast_filter
c_func
(paren
id|self
comma
id|TRUE
)paren
suffix:semicolon
r_else
id|irlan_set_broadcast_filter
c_func
(paren
id|self
comma
id|FALSE
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irlan_get_stats (dev)&n; *&n; *    Get the current statistics for this device&n; *&n; */
DECL|function|irlan_eth_get_stats
r_static
r_struct
id|net_device_stats
op_star
id|irlan_eth_get_stats
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|irlan_cb
op_star
id|self
op_assign
id|netdev_priv
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
op_amp
id|self-&gt;stats
suffix:semicolon
)brace
eof
