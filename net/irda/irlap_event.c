multiline_comment|/*********************************************************************&n; *&n; * Filename:      irlap_event.c&n; * Version:       0.9&n; * Description:   IrLAP state machine implementation&n; * Status:        Experimental.&n; * Author:        Dag Brattli &lt;dag@brattli.net&gt;&n; * Created at:    Sat Aug 16 00:59:29 1997&n; * Modified at:   Sat Dec 25 21:07:57 1999&n; * Modified by:   Dag Brattli &lt;dag@brattli.net&gt;&n; *&n; *     Copyright (c) 1998-2000 Dag Brattli &lt;dag@brattli.net&gt;,&n; *     Copyright (c) 1998      Thomas Davis &lt;ratbert@radiks.net&gt;&n; *     All Rights Reserved.&n; *     Copyright (c) 2000-2001 Jean Tourrilhes &lt;jt@hpl.hp.com&gt;&n; *&n; *     This program is free software; you can redistribute it and/or&n; *     modify it under the terms of the GNU General Public License as&n; *     published by the Free Software Foundation; either version 2 of&n; *     the License, or (at your option) any later version.&n; *&n; *     Neither Dag Brattli nor University of Troms&#xfffd; admit liability nor&n; *     provide warranty for any of this software. This material is&n; *     provided &quot;AS-IS&quot; and at no charge.&n; *&n; ********************************************************************/
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;net/irda/irda.h&gt;
macro_line|#include &lt;net/irda/irlap_event.h&gt;
macro_line|#include &lt;net/irda/timer.h&gt;
macro_line|#include &lt;net/irda/irlap.h&gt;
macro_line|#include &lt;net/irda/irlap_frame.h&gt;
macro_line|#include &lt;net/irda/qos.h&gt;
macro_line|#include &lt;net/irda/parameters.h&gt;
macro_line|#include &lt;net/irda/irlmp.h&gt;&t;&t;/* irlmp_flow_indication(), ... */
macro_line|#include &lt;net/irda/irda_device.h&gt;
macro_line|#if CONFIG_IRDA_FAST_RR
DECL|variable|sysctl_fast_poll_increase
r_int
id|sysctl_fast_poll_increase
op_assign
l_int|50
suffix:semicolon
macro_line|#endif
r_static
r_int
id|irlap_state_ndm
(paren
r_struct
id|irlap_cb
op_star
id|self
comma
id|IRLAP_EVENT
id|event
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|irlap_info
op_star
id|info
)paren
suffix:semicolon
r_static
r_int
id|irlap_state_query
(paren
r_struct
id|irlap_cb
op_star
id|self
comma
id|IRLAP_EVENT
id|event
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|irlap_info
op_star
id|info
)paren
suffix:semicolon
r_static
r_int
id|irlap_state_reply
(paren
r_struct
id|irlap_cb
op_star
id|self
comma
id|IRLAP_EVENT
id|event
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|irlap_info
op_star
id|info
)paren
suffix:semicolon
r_static
r_int
id|irlap_state_conn
(paren
r_struct
id|irlap_cb
op_star
id|self
comma
id|IRLAP_EVENT
id|event
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|irlap_info
op_star
id|info
)paren
suffix:semicolon
r_static
r_int
id|irlap_state_setup
(paren
r_struct
id|irlap_cb
op_star
id|self
comma
id|IRLAP_EVENT
id|event
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|irlap_info
op_star
id|info
)paren
suffix:semicolon
r_static
r_int
id|irlap_state_offline
c_func
(paren
r_struct
id|irlap_cb
op_star
id|self
comma
id|IRLAP_EVENT
id|event
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|irlap_info
op_star
id|info
)paren
suffix:semicolon
r_static
r_int
id|irlap_state_xmit_p
(paren
r_struct
id|irlap_cb
op_star
id|self
comma
id|IRLAP_EVENT
id|event
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|irlap_info
op_star
id|info
)paren
suffix:semicolon
r_static
r_int
id|irlap_state_pclose
(paren
r_struct
id|irlap_cb
op_star
id|self
comma
id|IRLAP_EVENT
id|event
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|irlap_info
op_star
id|info
)paren
suffix:semicolon
r_static
r_int
id|irlap_state_nrm_p
(paren
r_struct
id|irlap_cb
op_star
id|self
comma
id|IRLAP_EVENT
id|event
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|irlap_info
op_star
id|info
)paren
suffix:semicolon
r_static
r_int
id|irlap_state_reset_wait
c_func
(paren
r_struct
id|irlap_cb
op_star
id|self
comma
id|IRLAP_EVENT
id|event
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|irlap_info
op_star
id|info
)paren
suffix:semicolon
r_static
r_int
id|irlap_state_reset
(paren
r_struct
id|irlap_cb
op_star
id|self
comma
id|IRLAP_EVENT
id|event
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|irlap_info
op_star
id|info
)paren
suffix:semicolon
r_static
r_int
id|irlap_state_nrm_s
(paren
r_struct
id|irlap_cb
op_star
id|self
comma
id|IRLAP_EVENT
id|event
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|irlap_info
op_star
id|info
)paren
suffix:semicolon
r_static
r_int
id|irlap_state_xmit_s
(paren
r_struct
id|irlap_cb
op_star
id|self
comma
id|IRLAP_EVENT
id|event
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|irlap_info
op_star
id|info
)paren
suffix:semicolon
r_static
r_int
id|irlap_state_sclose
(paren
r_struct
id|irlap_cb
op_star
id|self
comma
id|IRLAP_EVENT
id|event
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|irlap_info
op_star
id|info
)paren
suffix:semicolon
r_static
r_int
id|irlap_state_reset_check
c_func
(paren
r_struct
id|irlap_cb
op_star
comma
id|IRLAP_EVENT
id|event
comma
r_struct
id|sk_buff
op_star
comma
r_struct
id|irlap_info
op_star
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_IRDA_DEBUG
DECL|variable|irlap_event
r_static
r_const
r_char
op_star
id|irlap_event
(braket
)braket
op_assign
(brace
l_string|&quot;DISCOVERY_REQUEST&quot;
comma
l_string|&quot;CONNECT_REQUEST&quot;
comma
l_string|&quot;CONNECT_RESPONSE&quot;
comma
l_string|&quot;DISCONNECT_REQUEST&quot;
comma
l_string|&quot;DATA_REQUEST&quot;
comma
l_string|&quot;RESET_REQUEST&quot;
comma
l_string|&quot;RESET_RESPONSE&quot;
comma
l_string|&quot;SEND_I_CMD&quot;
comma
l_string|&quot;SEND_UI_FRAME&quot;
comma
l_string|&quot;RECV_DISCOVERY_XID_CMD&quot;
comma
l_string|&quot;RECV_DISCOVERY_XID_RSP&quot;
comma
l_string|&quot;RECV_SNRM_CMD&quot;
comma
l_string|&quot;RECV_TEST_CMD&quot;
comma
l_string|&quot;RECV_TEST_RSP&quot;
comma
l_string|&quot;RECV_UA_RSP&quot;
comma
l_string|&quot;RECV_DM_RSP&quot;
comma
l_string|&quot;RECV_RD_RSP&quot;
comma
l_string|&quot;RECV_I_CMD&quot;
comma
l_string|&quot;RECV_I_RSP&quot;
comma
l_string|&quot;RECV_UI_FRAME&quot;
comma
l_string|&quot;RECV_FRMR_RSP&quot;
comma
l_string|&quot;RECV_RR_CMD&quot;
comma
l_string|&quot;RECV_RR_RSP&quot;
comma
l_string|&quot;RECV_RNR_CMD&quot;
comma
l_string|&quot;RECV_RNR_RSP&quot;
comma
l_string|&quot;RECV_REJ_CMD&quot;
comma
l_string|&quot;RECV_REJ_RSP&quot;
comma
l_string|&quot;RECV_SREJ_CMD&quot;
comma
l_string|&quot;RECV_SREJ_RSP&quot;
comma
l_string|&quot;RECV_DISC_CMD&quot;
comma
l_string|&quot;SLOT_TIMER_EXPIRED&quot;
comma
l_string|&quot;QUERY_TIMER_EXPIRED&quot;
comma
l_string|&quot;FINAL_TIMER_EXPIRED&quot;
comma
l_string|&quot;POLL_TIMER_EXPIRED&quot;
comma
l_string|&quot;DISCOVERY_TIMER_EXPIRED&quot;
comma
l_string|&quot;WD_TIMER_EXPIRED&quot;
comma
l_string|&quot;BACKOFF_TIMER_EXPIRED&quot;
comma
l_string|&quot;MEDIA_BUSY_TIMER_EXPIRED&quot;
comma
)brace
suffix:semicolon
macro_line|#endif&t;/* CONFIG_IRDA_DEBUG */
DECL|variable|irlap_state
r_const
r_char
op_star
id|irlap_state
(braket
)braket
op_assign
(brace
l_string|&quot;LAP_NDM&quot;
comma
l_string|&quot;LAP_QUERY&quot;
comma
l_string|&quot;LAP_REPLY&quot;
comma
l_string|&quot;LAP_CONN&quot;
comma
l_string|&quot;LAP_SETUP&quot;
comma
l_string|&quot;LAP_OFFLINE&quot;
comma
l_string|&quot;LAP_XMIT_P&quot;
comma
l_string|&quot;LAP_PCLOSE&quot;
comma
l_string|&quot;LAP_NRM_P&quot;
comma
l_string|&quot;LAP_RESET_WAIT&quot;
comma
l_string|&quot;LAP_RESET&quot;
comma
l_string|&quot;LAP_NRM_S&quot;
comma
l_string|&quot;LAP_XMIT_S&quot;
comma
l_string|&quot;LAP_SCLOSE&quot;
comma
l_string|&quot;LAP_RESET_CHECK&quot;
comma
)brace
suffix:semicolon
DECL|variable|state
r_static
r_int
(paren
op_star
id|state
(braket
)braket
)paren
(paren
r_struct
id|irlap_cb
op_star
id|self
comma
id|IRLAP_EVENT
id|event
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|irlap_info
op_star
id|info
)paren
op_assign
(brace
id|irlap_state_ndm
comma
id|irlap_state_query
comma
id|irlap_state_reply
comma
id|irlap_state_conn
comma
id|irlap_state_setup
comma
id|irlap_state_offline
comma
id|irlap_state_xmit_p
comma
id|irlap_state_pclose
comma
id|irlap_state_nrm_p
comma
id|irlap_state_reset_wait
comma
id|irlap_state_reset
comma
id|irlap_state_nrm_s
comma
id|irlap_state_xmit_s
comma
id|irlap_state_sclose
comma
id|irlap_state_reset_check
comma
)brace
suffix:semicolon
multiline_comment|/*&n; * Function irda_poll_timer_expired (data)&n; *&n; *    Poll timer has expired. Normally we must now send a RR frame to the&n; *    remote device&n; */
DECL|function|irlap_poll_timer_expired
r_static
r_void
id|irlap_poll_timer_expired
c_func
(paren
r_void
op_star
id|data
)paren
(brace
r_struct
id|irlap_cb
op_star
id|self
op_assign
(paren
r_struct
id|irlap_cb
op_star
)paren
id|data
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|LAP_MAGIC
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|irlap_do_event
c_func
(paren
id|self
comma
id|POLL_TIMER_EXPIRED
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Calculate and set time before we will have to send back the pf bit&n; * to the peer. Use in primary.&n; * Make sure that state is XMIT_P/XMIT_S when calling this function&n; * (and that nobody messed up with the state). - Jean II&n; */
DECL|function|irlap_start_poll_timer
r_void
id|irlap_start_poll_timer
c_func
(paren
r_struct
id|irlap_cb
op_star
id|self
comma
r_int
id|timeout
)paren
(brace
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|LAP_MAGIC
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_IRDA_FAST_RR
multiline_comment|/*&n;&t; * Send out the RR frames faster if our own transmit queue is empty, or&n;&t; * if the peer is busy. The effect is a much faster conversation&n;&t; */
r_if
c_cond
(paren
(paren
id|skb_queue_len
c_func
(paren
op_amp
id|self-&gt;txq
)paren
op_eq
l_int|0
)paren
op_logical_or
(paren
id|self-&gt;remote_busy
)paren
)paren
(brace
r_if
c_cond
(paren
id|self-&gt;fast_RR
op_eq
id|TRUE
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; *  Assert that the fast poll timer has not reached the&n;&t;&t;&t; *  normal poll timer yet&n;&t;&t;&t; */
r_if
c_cond
(paren
id|self-&gt;fast_RR_timeout
OL
id|timeout
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; *  FIXME: this should be a more configurable&n;&t;&t;&t;&t; *         function&n;&t;&t;&t;&t; */
id|self-&gt;fast_RR_timeout
op_add_assign
(paren
id|sysctl_fast_poll_increase
op_star
id|HZ
op_div
l_int|1000
)paren
suffix:semicolon
multiline_comment|/* Use this fast(er) timeout instead */
id|timeout
op_assign
id|self-&gt;fast_RR_timeout
suffix:semicolon
)brace
)brace
r_else
(brace
id|self-&gt;fast_RR
op_assign
id|TRUE
suffix:semicolon
multiline_comment|/* Start with just 0 ms */
id|self-&gt;fast_RR_timeout
op_assign
l_int|0
suffix:semicolon
id|timeout
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_else
id|self-&gt;fast_RR
op_assign
id|FALSE
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|3
comma
l_string|&quot;%s(), timeout=%d (%ld)&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|timeout
comma
id|jiffies
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_IRDA_FAST_RR */
r_if
c_cond
(paren
id|timeout
op_eq
l_int|0
)paren
id|irlap_do_event
c_func
(paren
id|self
comma
id|POLL_TIMER_EXPIRED
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
r_else
id|irda_start_timer
c_func
(paren
op_amp
id|self-&gt;poll_timer
comma
id|timeout
comma
id|self
comma
id|irlap_poll_timer_expired
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irlap_do_event (event, skb, info)&n; *&n; *    Rushes through the state machine without any delay. If state == XMIT&n; *    then send queued data frames.&n; */
DECL|function|irlap_do_event
r_void
id|irlap_do_event
c_func
(paren
r_struct
id|irlap_cb
op_star
id|self
comma
id|IRLAP_EVENT
id|event
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|irlap_info
op_star
id|info
)paren
(brace
r_int
id|ret
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|self
op_logical_or
id|self-&gt;magic
op_ne
id|LAP_MAGIC
)paren
r_return
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|3
comma
l_string|&quot;%s(), event = %s, state = %s&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|irlap_event
(braket
id|event
)braket
comma
id|irlap_state
(braket
id|self-&gt;state
)braket
)paren
suffix:semicolon
id|ret
op_assign
(paren
op_star
id|state
(braket
id|self-&gt;state
)braket
)paren
(paren
id|self
comma
id|event
comma
id|skb
comma
id|info
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Check if there are any pending events that needs to be executed&n;&t; */
r_switch
c_cond
(paren
id|self-&gt;state
)paren
(brace
r_case
id|LAP_XMIT_P
suffix:colon
multiline_comment|/* FALLTHROUGH */
r_case
id|LAP_XMIT_S
suffix:colon
multiline_comment|/*&n;&t;&t; * We just received the pf bit and are at the beginning&n;&t;&t; * of a new LAP transmit window.&n;&t;&t; * Check if there are any queued data frames, and do not&n;&t;&t; * try to disconnect link if we send any data frames, since&n;&t;&t; * that will change the state away form XMIT&n;&t;&t; */
id|IRDA_DEBUG
c_func
(paren
l_int|2
comma
l_string|&quot;%s() : queue len = %d&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|skb_queue_len
c_func
(paren
op_amp
id|self-&gt;txq
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb_queue_len
c_func
(paren
op_amp
id|self-&gt;txq
)paren
)paren
(brace
multiline_comment|/* Prevent race conditions with irlap_data_request() */
id|self-&gt;local_busy
op_assign
id|TRUE
suffix:semicolon
multiline_comment|/* Theory of operation.&n;&t;&t;&t; * We send frames up to when we fill the window or&n;&t;&t;&t; * reach line capacity. Those frames will queue up&n;&t;&t;&t; * in the device queue, and the driver will slowly&n;&t;&t;&t; * send them.&n;&t;&t;&t; * After each frame that we send, we poll the higher&n;&t;&t;&t; * layer for more data. It&squot;s the right time to do&n;&t;&t;&t; * that because the link layer need to perform the mtt&n;&t;&t;&t; * and then send the first frame, so we can afford&n;&t;&t;&t; * to send a bit of time in kernel space.&n;&t;&t;&t; * The explicit flow indication allow to minimise&n;&t;&t;&t; * buffers (== lower latency), to avoid higher layer&n;&t;&t;&t; * polling via timers (== less context switches) and&n;&t;&t;&t; * to implement a crude scheduler - Jean II */
multiline_comment|/* Try to send away all queued data frames */
r_while
c_loop
(paren
(paren
id|skb
op_assign
id|skb_dequeue
c_func
(paren
op_amp
id|self-&gt;txq
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* Send one frame */
id|ret
op_assign
(paren
op_star
id|state
(braket
id|self-&gt;state
)braket
)paren
(paren
id|self
comma
id|SEND_I_CMD
comma
id|skb
comma
l_int|NULL
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
multiline_comment|/* Poll the higher layers for one more frame */
id|irlmp_flow_indication
c_func
(paren
id|self-&gt;notify.instance
comma
id|FLOW_START
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
op_minus
id|EPROTO
)paren
r_break
suffix:semicolon
multiline_comment|/* Try again later! */
)brace
multiline_comment|/* Finished transmitting */
id|self-&gt;local_busy
op_assign
id|FALSE
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|self-&gt;disconnect_pending
)paren
(brace
id|self-&gt;disconnect_pending
op_assign
id|FALSE
suffix:semicolon
id|ret
op_assign
(paren
op_star
id|state
(braket
id|self-&gt;state
)braket
)paren
(paren
id|self
comma
id|DISCONNECT_REQUEST
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
multiline_comment|/*&t;case LAP_NDM: */
multiline_comment|/*&t;case LAP_CONN: */
multiline_comment|/*&t;case LAP_RESET_WAIT: */
multiline_comment|/*&t;case LAP_RESET_CHECK: */
r_default
suffix:colon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Function irlap_next_state (self, state)&n; *&n; *    Switches state and provides debug information&n; *&n; */
DECL|function|irlap_next_state
r_static
r_inline
r_void
id|irlap_next_state
c_func
(paren
r_struct
id|irlap_cb
op_star
id|self
comma
id|IRLAP_STATE
id|state
)paren
(brace
multiline_comment|/*&n;&t;if (!self || self-&gt;magic != LAP_MAGIC)&n;&t;&t;return;&n;&n;&t;IRDA_DEBUG(4, &quot;next LAP state = %s&bslash;n&quot;, irlap_state[state]);&n;&t;*/
id|self-&gt;state
op_assign
id|state
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irlap_state_ndm (event, skb, frame)&n; *&n; *    NDM (Normal Disconnected Mode) state&n; *&n; */
DECL|function|irlap_state_ndm
r_static
r_int
id|irlap_state_ndm
c_func
(paren
r_struct
id|irlap_cb
op_star
id|self
comma
id|IRLAP_EVENT
id|event
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|irlap_info
op_star
id|info
)paren
(brace
id|discovery_t
op_star
id|discovery_rsp
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|LAP_MAGIC
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|event
)paren
(brace
r_case
id|CONNECT_REQUEST
suffix:colon
id|ASSERT
c_func
(paren
id|self-&gt;netdev
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
r_if
c_cond
(paren
id|self-&gt;media_busy
)paren
(brace
multiline_comment|/* Note : this will never happen, because we test&n;&t;&t;&t; * media busy in irlap_connect_request() and&n;&t;&t;&t; * postpone the event... - Jean II */
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
l_string|&quot;%s(), CONNECT_REQUEST: media busy!&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
multiline_comment|/* Always switch state before calling upper layers */
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NDM
)paren
suffix:semicolon
id|irlap_disconnect_indication
c_func
(paren
id|self
comma
id|LAP_MEDIA_BUSY
)paren
suffix:semicolon
)brace
r_else
(brace
id|irlap_send_snrm_frame
c_func
(paren
id|self
comma
op_amp
id|self-&gt;qos_rx
)paren
suffix:semicolon
multiline_comment|/* Start Final-bit timer */
id|irlap_start_final_timer
c_func
(paren
id|self
comma
id|self-&gt;final_timeout
)paren
suffix:semicolon
id|self-&gt;retry_count
op_assign
l_int|0
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_SETUP
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|RECV_SNRM_CMD
suffix:colon
multiline_comment|/* Check if the frame contains and I field */
r_if
c_cond
(paren
id|info
)paren
(brace
id|self-&gt;daddr
op_assign
id|info-&gt;daddr
suffix:semicolon
id|self-&gt;caddr
op_assign
id|info-&gt;caddr
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_CONN
)paren
suffix:semicolon
id|irlap_connect_indication
c_func
(paren
id|self
comma
id|skb
)paren
suffix:semicolon
)brace
r_else
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
l_string|&quot;%s(), SNRM frame does not &quot;
l_string|&quot;contain an I field!&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|DISCOVERY_REQUEST
suffix:colon
id|ASSERT
c_func
(paren
id|info
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
r_if
c_cond
(paren
id|self-&gt;media_busy
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
l_string|&quot;%s(), media busy!&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
multiline_comment|/* irlap-&gt;log.condition = MEDIA_BUSY; */
multiline_comment|/* This will make IrLMP try again */
id|irlap_discovery_confirm
c_func
(paren
id|self
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* Note : the discovery log is not cleaned up here,&n;&t;&t;&t; * it will be done in irlap_discovery_request()&n;&t;&t;&t; * Jean II */
r_return
l_int|0
suffix:semicolon
)brace
id|self-&gt;S
op_assign
id|info-&gt;S
suffix:semicolon
id|self-&gt;s
op_assign
id|info-&gt;s
suffix:semicolon
id|irlap_send_discovery_xid_frame
c_func
(paren
id|self
comma
id|info-&gt;S
comma
id|info-&gt;s
comma
id|TRUE
comma
id|info-&gt;discovery
)paren
suffix:semicolon
id|self-&gt;frame_sent
op_assign
id|FALSE
suffix:semicolon
id|self-&gt;s
op_increment
suffix:semicolon
id|irlap_start_slot_timer
c_func
(paren
id|self
comma
id|self-&gt;slot_timeout
)paren
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_QUERY
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RECV_DISCOVERY_XID_CMD
suffix:colon
id|ASSERT
c_func
(paren
id|info
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
multiline_comment|/* Assert that this is not the final slot */
r_if
c_cond
(paren
id|info-&gt;s
op_le
id|info-&gt;S
)paren
(brace
id|self-&gt;slot
op_assign
id|irlap_generate_rand_time_slot
c_func
(paren
id|info-&gt;S
comma
id|info-&gt;s
)paren
suffix:semicolon
r_if
c_cond
(paren
id|self-&gt;slot
op_eq
id|info-&gt;s
)paren
(brace
id|discovery_rsp
op_assign
id|irlmp_get_discovery_response
c_func
(paren
)paren
suffix:semicolon
id|discovery_rsp-&gt;daddr
op_assign
id|info-&gt;daddr
suffix:semicolon
id|irlap_send_discovery_xid_frame
c_func
(paren
id|self
comma
id|info-&gt;S
comma
id|self-&gt;slot
comma
id|FALSE
comma
id|discovery_rsp
)paren
suffix:semicolon
id|self-&gt;frame_sent
op_assign
id|TRUE
suffix:semicolon
)brace
r_else
id|self-&gt;frame_sent
op_assign
id|FALSE
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Remember to multiply the query timeout value with&n;&t;&t;&t; * the number of slots used&n;&t;&t;&t; */
id|irlap_start_query_timer
c_func
(paren
id|self
comma
id|QUERY_TIMEOUT
op_star
id|info-&gt;S
)paren
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_REPLY
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* This is the final slot. How is it possible ?&n;&t;&t; * This would happen is both discoveries are just slightly&n;&t;&t; * offset (if they are in sync, all packets are lost).&n;&t;&t; * Most often, all the discovery requests will be received&n;&t;&t; * in QUERY state (see my comment there), except for the&n;&t;&t; * last frame that will come here.&n;&t;&t; * The big trouble when it happen is that active discovery&n;&t;&t; * doesn&squot;t happen, because nobody answer the discoveries&n;&t;&t; * frame of the other guy, so the log shows up empty.&n;&t;&t; * What should we do ?&n;&t;&t; * Not much. It&squot;s too late to answer those discovery frames,&n;&t;&t; * so we just pass the info to IrLMP who will put it in the&n;&t;&t; * log (and post an event).&n;&t;&t; * Jean II&n;&t;&t; */
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;%s(), Receiving final discovery request, missed the discovery slots :-(&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
multiline_comment|/* Last discovery request -&gt; in the log */
id|irlap_discovery_indication
c_func
(paren
id|self
comma
id|info-&gt;discovery
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|MEDIA_BUSY_TIMER_EXPIRED
suffix:colon
multiline_comment|/* A bunch of events may be postponed because the media is&n;&t;&t; * busy (usually immediately after we close a connection),&n;&t;&t; * or while we are doing discovery (state query/reply).&n;&t;&t; * In all those cases, the media busy flag will be cleared&n;&t;&t; * when it&squot;s OK for us to process those postponed events.&n;&t;&t; * This event is not mentioned in the state machines in the&n;&t;&t; * IrLAP spec. It&squot;s because they didn&squot;t consider Ultra and&n;&t;&t; * postponing connection request is optional.&n;&t;&t; * Jean II */
macro_line|#ifdef CONFIG_IRDA_ULTRA
multiline_comment|/* Send any pending Ultra frames if any */
r_if
c_cond
(paren
op_logical_neg
id|skb_queue_empty
c_func
(paren
op_amp
id|self-&gt;txq_ultra
)paren
)paren
(brace
multiline_comment|/* We don&squot;t send the frame, just post an event.&n;&t;&t;&t; * Also, previously this code was in timer.c...&n;&t;&t;&t; * Jean II */
id|ret
op_assign
(paren
op_star
id|state
(braket
id|self-&gt;state
)braket
)paren
(paren
id|self
comma
id|SEND_UI_FRAME
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_IRDA_ULTRA */
multiline_comment|/* Check if we should try to connect.&n;&t;&t; * This code was previously in irlap_do_event() */
r_if
c_cond
(paren
id|self-&gt;connect_pending
)paren
(brace
id|self-&gt;connect_pending
op_assign
id|FALSE
suffix:semicolon
multiline_comment|/* This one *should* not pend in this state, except&n;&t;&t;&t; * if a socket try to connect and immediately&n;&t;&t;&t; * disconnect. - clear - Jean II */
r_if
c_cond
(paren
id|self-&gt;disconnect_pending
)paren
id|irlap_disconnect_indication
c_func
(paren
id|self
comma
id|LAP_DISC_INDICATION
)paren
suffix:semicolon
r_else
id|ret
op_assign
(paren
op_star
id|state
(braket
id|self-&gt;state
)braket
)paren
(paren
id|self
comma
id|CONNECT_REQUEST
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
id|self-&gt;disconnect_pending
op_assign
id|FALSE
suffix:semicolon
)brace
multiline_comment|/* Note : one way to test if this code works well (including&n;&t;&t; * media busy and small busy) is to create a user space&n;&t;&t; * application generating an Ultra packet every 3.05 sec (or&n;&t;&t; * 2.95 sec) and to see how it interact with discovery.&n;&t;&t; * It&squot;s fairly easy to check that no packet is lost, that the&n;&t;&t; * packets are postponed during discovery and that after&n;&t;&t; * discovery indication you have a 100ms &quot;gap&quot;.&n;&t;&t; * As connection request and Ultra are now processed the same&n;&t;&t; * way, this avoid the tedious job of trying IrLAP connection&n;&t;&t; * in all those cases...&n;&t;&t; * Jean II */
r_break
suffix:semicolon
macro_line|#ifdef CONFIG_IRDA_ULTRA
r_case
id|SEND_UI_FRAME
suffix:colon
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/* Only allowed to repeat an operation twice */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
(paren
(paren
id|i
OL
l_int|2
)paren
op_logical_and
(paren
id|self-&gt;media_busy
op_eq
id|FALSE
)paren
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|skb
op_assign
id|skb_dequeue
c_func
(paren
op_amp
id|self-&gt;txq_ultra
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
)paren
id|irlap_send_ui_frame
c_func
(paren
id|self
comma
id|skb
comma
id|CBROADCAST
comma
id|CMD_FRAME
)paren
suffix:semicolon
r_else
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_eq
l_int|2
)paren
(brace
multiline_comment|/* Force us to listen 500 ms again */
id|irda_device_set_media_busy
c_func
(paren
id|self-&gt;netdev
comma
id|TRUE
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
r_case
id|RECV_UI_FRAME
suffix:colon
multiline_comment|/* Only accept broadcast frames in NDM mode */
r_if
c_cond
(paren
id|info-&gt;caddr
op_ne
id|CBROADCAST
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
l_string|&quot;%s(), not a broadcast frame!&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
)brace
r_else
id|irlap_unitdata_indication
c_func
(paren
id|self
comma
id|skb
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif /* CONFIG_IRDA_ULTRA */
r_case
id|RECV_TEST_CMD
suffix:colon
multiline_comment|/* Remove test frame header */
id|skb_pull
c_func
(paren
id|skb
comma
r_sizeof
(paren
r_struct
id|test_frame
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Send response. This skb will not be sent out again, and&n;&t;&t; * will only be used to send out the same info as the cmd&n;&t;&t; */
id|irlap_send_test_frame
c_func
(paren
id|self
comma
id|CBROADCAST
comma
id|info-&gt;daddr
comma
id|skb
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RECV_TEST_RSP
suffix:colon
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
l_string|&quot;%s() not implemented!&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|IRDA_DEBUG
c_func
(paren
l_int|2
comma
l_string|&quot;%s(), Unknown event %s&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|irlap_event
(braket
id|event
)braket
)paren
suffix:semicolon
id|ret
op_assign
op_minus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irlap_state_query (event, skb, info)&n; *&n; *    QUERY state&n; *&n; */
DECL|function|irlap_state_query
r_static
r_int
id|irlap_state_query
c_func
(paren
r_struct
id|irlap_cb
op_star
id|self
comma
id|IRLAP_EVENT
id|event
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|irlap_info
op_star
id|info
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|LAP_MAGIC
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|event
)paren
(brace
r_case
id|RECV_DISCOVERY_XID_RSP
suffix:colon
id|ASSERT
c_func
(paren
id|info
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|info-&gt;discovery
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|4
comma
l_string|&quot;%s(), daddr=%08x&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|info-&gt;discovery-&gt;daddr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|self-&gt;discovery_log
)paren
(brace
id|WARNING
c_func
(paren
l_string|&quot;%s: discovery log is gone! &quot;
l_string|&quot;maybe the discovery timeout has been set to &quot;
l_string|&quot;short?&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|hashbin_insert
c_func
(paren
id|self-&gt;discovery_log
comma
(paren
id|irda_queue_t
op_star
)paren
id|info-&gt;discovery
comma
id|info-&gt;discovery-&gt;daddr
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* Keep state */
multiline_comment|/* irlap_next_state(self, LAP_QUERY);  */
r_break
suffix:semicolon
r_case
id|RECV_DISCOVERY_XID_CMD
suffix:colon
multiline_comment|/* Yes, it is possible to receive those frames in this mode.&n;&t;&t; * Note that most often the last discovery request won&squot;t&n;&t;&t; * occur here but in NDM state (see my comment there).&n;&t;&t; * What should we do ?&n;&t;&t; * Not much. We are currently performing our own discovery,&n;&t;&t; * therefore we can&squot;t answer those frames. We don&squot;t want&n;&t;&t; * to change state either. We just pass the info to&n;&t;&t; * IrLMP who will put it in the log (and post an event).&n;&t;&t; * Jean II&n;&t;&t; */
id|ASSERT
c_func
(paren
id|info
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;%s(), Receiving discovery request (s = %d) while performing discovery :-(&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|info-&gt;s
)paren
suffix:semicolon
multiline_comment|/* Last discovery request ? */
r_if
c_cond
(paren
id|info-&gt;s
op_eq
l_int|0xff
)paren
id|irlap_discovery_indication
c_func
(paren
id|self
comma
id|info-&gt;discovery
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SLOT_TIMER_EXPIRED
suffix:colon
multiline_comment|/*&n;&t;&t; * Wait a little longer if we detect an incoming frame. This&n;&t;&t; * is not mentioned in the spec, but is a good thing to do,&n;&t;&t; * since we want to work even with devices that violate the&n;&t;&t; * timing requirements.&n;&t;&t; */
r_if
c_cond
(paren
id|irda_device_is_receiving
c_func
(paren
id|self-&gt;netdev
)paren
op_logical_and
op_logical_neg
id|self-&gt;add_wait
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|2
comma
l_string|&quot;%s(), device is slow to answer, &quot;
l_string|&quot;waiting some more!&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
id|irlap_start_slot_timer
c_func
(paren
id|self
comma
id|MSECS_TO_JIFFIES
c_func
(paren
l_int|10
)paren
)paren
suffix:semicolon
id|self-&gt;add_wait
op_assign
id|TRUE
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
id|self-&gt;add_wait
op_assign
id|FALSE
suffix:semicolon
r_if
c_cond
(paren
id|self-&gt;s
OL
id|self-&gt;S
)paren
(brace
id|irlap_send_discovery_xid_frame
c_func
(paren
id|self
comma
id|self-&gt;S
comma
id|self-&gt;s
comma
id|TRUE
comma
id|self-&gt;discovery_cmd
)paren
suffix:semicolon
id|self-&gt;s
op_increment
suffix:semicolon
id|irlap_start_slot_timer
c_func
(paren
id|self
comma
id|self-&gt;slot_timeout
)paren
suffix:semicolon
multiline_comment|/* Keep state */
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_QUERY
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* This is the final slot! */
id|irlap_send_discovery_xid_frame
c_func
(paren
id|self
comma
id|self-&gt;S
comma
l_int|0xff
comma
id|TRUE
comma
id|self-&gt;discovery_cmd
)paren
suffix:semicolon
multiline_comment|/* Always switch state before calling upper layers */
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NDM
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; *  We are now finished with the discovery procedure,&n;&t;&t;&t; *  so now we must return the results&n;&t;&t;&t; */
id|irlap_discovery_confirm
c_func
(paren
id|self
comma
id|self-&gt;discovery_log
)paren
suffix:semicolon
multiline_comment|/* IrLMP should now have taken care of the log */
id|self-&gt;discovery_log
op_assign
l_int|NULL
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|IRDA_DEBUG
c_func
(paren
l_int|2
comma
l_string|&quot;%s(), Unknown event %s&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|irlap_event
(braket
id|event
)braket
)paren
suffix:semicolon
id|ret
op_assign
op_minus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irlap_state_reply (self, event, skb, info)&n; *&n; *    REPLY, we have received a XID discovery frame from a device and we&n; *    are waiting for the right time slot to send a response XID frame&n; *&n; */
DECL|function|irlap_state_reply
r_static
r_int
id|irlap_state_reply
c_func
(paren
r_struct
id|irlap_cb
op_star
id|self
comma
id|IRLAP_EVENT
id|event
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|irlap_info
op_star
id|info
)paren
(brace
id|discovery_t
op_star
id|discovery_rsp
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|4
comma
l_string|&quot;%s()&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|LAP_MAGIC
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|event
)paren
(brace
r_case
id|QUERY_TIMER_EXPIRED
suffix:colon
id|IRDA_DEBUG
c_func
(paren
l_int|2
comma
l_string|&quot;%s(), QUERY_TIMER_EXPIRED &lt;%ld&gt;&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|jiffies
)paren
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NDM
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RECV_DISCOVERY_XID_CMD
suffix:colon
id|ASSERT
c_func
(paren
id|info
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
multiline_comment|/* Last frame? */
r_if
c_cond
(paren
id|info-&gt;s
op_eq
l_int|0xff
)paren
(brace
id|del_timer
c_func
(paren
op_amp
id|self-&gt;query_timer
)paren
suffix:semicolon
multiline_comment|/* info-&gt;log.condition = REMOTE; */
multiline_comment|/* Always switch state before calling upper layers */
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NDM
)paren
suffix:semicolon
id|irlap_discovery_indication
c_func
(paren
id|self
comma
id|info-&gt;discovery
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|info-&gt;s
op_ge
id|self-&gt;slot
)paren
op_logical_and
(paren
op_logical_neg
id|self-&gt;frame_sent
)paren
)paren
(brace
id|discovery_rsp
op_assign
id|irlmp_get_discovery_response
c_func
(paren
)paren
suffix:semicolon
id|discovery_rsp-&gt;daddr
op_assign
id|info-&gt;daddr
suffix:semicolon
id|irlap_send_discovery_xid_frame
c_func
(paren
id|self
comma
id|info-&gt;S
comma
id|self-&gt;slot
comma
id|FALSE
comma
id|discovery_rsp
)paren
suffix:semicolon
id|self-&gt;frame_sent
op_assign
id|TRUE
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_REPLY
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;%s(), Unknown event %d, %s&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|event
comma
id|irlap_event
(braket
id|event
)braket
)paren
suffix:semicolon
id|ret
op_assign
op_minus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irlap_state_conn (event, skb, info)&n; *&n; *    CONN, we have received a SNRM command and is waiting for the upper&n; *    layer to accept or refuse connection&n; *&n; */
DECL|function|irlap_state_conn
r_static
r_int
id|irlap_state_conn
c_func
(paren
r_struct
id|irlap_cb
op_star
id|self
comma
id|IRLAP_EVENT
id|event
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|irlap_info
op_star
id|info
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|4
comma
l_string|&quot;%s(), event=%s&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|irlap_event
(braket
id|event
)braket
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|LAP_MAGIC
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|event
)paren
(brace
r_case
id|CONNECT_RESPONSE
suffix:colon
id|skb_pull
c_func
(paren
id|skb
comma
r_sizeof
(paren
r_struct
id|snrm_frame
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;netdev
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|irlap_qos_negotiate
c_func
(paren
id|self
comma
id|skb
)paren
suffix:semicolon
id|irlap_initiate_connection_state
c_func
(paren
id|self
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Applying the parameters now will make sure we change speed&n;&t;&t; * *after* we have sent the next frame&n;&t;&t; */
id|irlap_apply_connection_parameters
c_func
(paren
id|self
comma
id|FALSE
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Sending this frame will force a speed change after it has&n;&t;&t; * been sent (i.e. the frame will be sent at 9600).&n;&t;&t; */
id|irlap_send_ua_response_frame
c_func
(paren
id|self
comma
op_amp
id|self-&gt;qos_rx
)paren
suffix:semicolon
macro_line|#if 0
multiline_comment|/*&n;&t;&t; * We are allowed to send two frames, but this may increase&n;&t;&t; * the connect latency, so lets not do it for now.&n;&t;&t; */
multiline_comment|/* This is full of good intentions, but doesn&squot;t work in&n;&t;&t; * practice.&n;&t;&t; * After sending the first UA response, we switch the&n;&t;&t; * dongle to the negociated speed, which is usually&n;&t;&t; * different than 9600 kb/s.&n;&t;&t; * From there, there is two solutions :&n;&t;&t; * 1) The other end has received the first UA response :&n;&t;&t; * it will set up the connection, move to state LAP_NRM_P,&n;&t;&t; * and will ignore and drop the second UA response.&n;&t;&t; * Actually, it&squot;s even worse : the other side will almost&n;&t;&t; * immediately send a RR that will likely collide with the&n;&t;&t; * UA response (depending on negociated turnaround).&n;&t;&t; * 2) The other end has not received the first UA response,&n;&t;&t; * will stay at 9600 and will never see the second UA response.&n;&t;&t; * Jean II */
id|irlap_send_ua_response_frame
c_func
(paren
id|self
comma
op_amp
id|self-&gt;qos_rx
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t;&t; *  The WD-timer could be set to the duration of the P-timer&n;&t;&t; *  for this case, but it is recommended to use twice the&n;&t;&t; *  value (note 3 IrLAP p. 60).&n;&t;&t; */
id|irlap_start_wd_timer
c_func
(paren
id|self
comma
id|self-&gt;wd_timeout
)paren
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NRM_S
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RECV_DISCOVERY_XID_CMD
suffix:colon
id|IRDA_DEBUG
c_func
(paren
l_int|3
comma
l_string|&quot;%s(), event RECV_DISCOVER_XID_CMD!&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NDM
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DISCONNECT_REQUEST
suffix:colon
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
l_string|&quot;%s(), Disconnect request!&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
id|irlap_send_dm_frame
c_func
(paren
id|self
)paren
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NDM
)paren
suffix:semicolon
id|irlap_disconnect_indication
c_func
(paren
id|self
comma
id|LAP_DISC_INDICATION
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;%s(), Unknown event %d, %s&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|event
comma
id|irlap_event
(braket
id|event
)braket
)paren
suffix:semicolon
id|ret
op_assign
op_minus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irlap_state_setup (event, skb, frame)&n; *&n; *    SETUP state, The local layer has transmitted a SNRM command frame to&n; *    a remote peer layer and is awaiting a reply .&n; *&n; */
DECL|function|irlap_state_setup
r_static
r_int
id|irlap_state_setup
c_func
(paren
r_struct
id|irlap_cb
op_star
id|self
comma
id|IRLAP_EVENT
id|event
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|irlap_info
op_star
id|info
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|4
comma
l_string|&quot;%s()&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|LAP_MAGIC
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|event
)paren
(brace
r_case
id|FINAL_TIMER_EXPIRED
suffix:colon
r_if
c_cond
(paren
id|self-&gt;retry_count
OL
id|self-&gt;N3
)paren
(brace
multiline_comment|/*&n; *  Perform random backoff, Wait a random number of time units, minimum&n; *  duration half the time taken to transmitt a SNRM frame, maximum duration&n; *  1.5 times the time taken to transmit a SNRM frame. So this time should&n; *  between 15 msecs and 45 msecs.&n; */
id|irlap_start_backoff_timer
c_func
(paren
id|self
comma
id|MSECS_TO_JIFFIES
c_func
(paren
l_int|20
op_plus
(paren
id|jiffies
op_mod
l_int|30
)paren
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Always switch state before calling upper layers */
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NDM
)paren
suffix:semicolon
id|irlap_disconnect_indication
c_func
(paren
id|self
comma
id|LAP_FOUND_NONE
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|BACKOFF_TIMER_EXPIRED
suffix:colon
id|irlap_send_snrm_frame
c_func
(paren
id|self
comma
op_amp
id|self-&gt;qos_rx
)paren
suffix:semicolon
id|irlap_start_final_timer
c_func
(paren
id|self
comma
id|self-&gt;final_timeout
)paren
suffix:semicolon
id|self-&gt;retry_count
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RECV_SNRM_CMD
suffix:colon
id|IRDA_DEBUG
c_func
(paren
l_int|4
comma
l_string|&quot;%s(), SNRM battle!&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|skb
op_ne
l_int|NULL
comma
r_return
l_int|0
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|info
op_ne
l_int|NULL
comma
r_return
l_int|0
suffix:semicolon
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *  The device with the largest device address wins the battle&n;&t;&t; *  (both have sent a SNRM command!)&n;&t;&t; */
r_if
c_cond
(paren
id|info
op_logical_and
(paren
id|info-&gt;daddr
OG
id|self-&gt;saddr
)paren
)paren
(brace
id|del_timer
c_func
(paren
op_amp
id|self-&gt;final_timer
)paren
suffix:semicolon
id|irlap_initiate_connection_state
c_func
(paren
id|self
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;netdev
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|skb_pull
c_func
(paren
id|skb
comma
r_sizeof
(paren
r_struct
id|snrm_frame
)paren
)paren
suffix:semicolon
id|irlap_qos_negotiate
c_func
(paren
id|self
comma
id|skb
)paren
suffix:semicolon
multiline_comment|/* Send UA frame and then change link settings */
id|irlap_apply_connection_parameters
c_func
(paren
id|self
comma
id|FALSE
)paren
suffix:semicolon
id|irlap_send_ua_response_frame
c_func
(paren
id|self
comma
op_amp
id|self-&gt;qos_rx
)paren
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NRM_S
)paren
suffix:semicolon
id|irlap_connect_confirm
c_func
(paren
id|self
comma
id|skb
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; *  The WD-timer could be set to the duration of the&n;&t;&t;&t; *  P-timer for this case, but it is recommended&n;&t;&t;&t; *  to use twice the value (note 3 IrLAP p. 60).&n;&t;&t;&t; */
id|irlap_start_wd_timer
c_func
(paren
id|self
comma
id|self-&gt;wd_timeout
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* We just ignore the other device! */
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_SETUP
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|RECV_UA_RSP
suffix:colon
multiline_comment|/* Stop F-timer */
id|del_timer
c_func
(paren
op_amp
id|self-&gt;final_timer
)paren
suffix:semicolon
multiline_comment|/* Initiate connection state */
id|irlap_initiate_connection_state
c_func
(paren
id|self
)paren
suffix:semicolon
multiline_comment|/* Negotiate connection parameters */
id|ASSERT
c_func
(paren
id|skb-&gt;len
OG
l_int|10
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|skb_pull
c_func
(paren
id|skb
comma
r_sizeof
(paren
r_struct
id|ua_frame
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;netdev
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|irlap_qos_negotiate
c_func
(paren
id|self
comma
id|skb
)paren
suffix:semicolon
multiline_comment|/* Set the new link setting *now* (before the rr frame) */
id|irlap_apply_connection_parameters
c_func
(paren
id|self
comma
id|TRUE
)paren
suffix:semicolon
id|self-&gt;retry_count
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Wait for turnaround time to give a chance to the other&n;&t;&t; * device to be ready to receive us.&n;&t;&t; * Note : the time to switch speed is typically larger&n;&t;&t; * than the turnaround time, but as we don&squot;t have the other&n;&t;&t; * side speed switch time, that&squot;s our best guess...&n;&t;&t; * Jean II */
id|irlap_wait_min_turn_around
c_func
(paren
id|self
comma
op_amp
id|self-&gt;qos_tx
)paren
suffix:semicolon
multiline_comment|/* This frame will actually be sent at the new speed */
id|irlap_send_rr_frame
c_func
(paren
id|self
comma
id|CMD_FRAME
)paren
suffix:semicolon
id|irlap_start_final_timer
c_func
(paren
id|self
comma
id|self-&gt;final_timeout
op_div
l_int|2
)paren
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NRM_P
)paren
suffix:semicolon
id|irlap_connect_confirm
c_func
(paren
id|self
comma
id|skb
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RECV_DM_RSP
suffix:colon
multiline_comment|/* FALLTHROUGH */
r_case
id|RECV_DISC_CMD
suffix:colon
id|del_timer
c_func
(paren
op_amp
id|self-&gt;final_timer
)paren
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NDM
)paren
suffix:semicolon
id|irlap_disconnect_indication
c_func
(paren
id|self
comma
id|LAP_DISC_INDICATION
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;%s(), Unknown event %d, %s&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|event
comma
id|irlap_event
(braket
id|event
)braket
)paren
suffix:semicolon
id|ret
op_assign
op_minus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irlap_state_offline (self, event, skb, info)&n; *&n; *    OFFLINE state, not used for now!&n; *&n; */
DECL|function|irlap_state_offline
r_static
r_int
id|irlap_state_offline
c_func
(paren
r_struct
id|irlap_cb
op_star
id|self
comma
id|IRLAP_EVENT
id|event
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|irlap_info
op_star
id|info
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
l_string|&quot;%s(), Unknown event&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irlap_state_xmit_p (self, event, skb, info)&n; *&n; *    XMIT, Only the primary station has right to transmit, and we&n; *    therefore do not expect to receive any transmissions from other&n; *    stations.&n; *&n; */
DECL|function|irlap_state_xmit_p
r_static
r_int
id|irlap_state_xmit_p
c_func
(paren
r_struct
id|irlap_cb
op_star
id|self
comma
id|IRLAP_EVENT
id|event
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|irlap_info
op_star
id|info
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|event
)paren
(brace
r_case
id|SEND_I_CMD
suffix:colon
multiline_comment|/*&n;&t;&t; *  Only send frame if send-window &gt; 0.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|self-&gt;window
OG
l_int|0
)paren
op_logical_and
(paren
op_logical_neg
id|self-&gt;remote_busy
)paren
)paren
(brace
macro_line|#ifdef CONFIG_IRDA_DYNAMIC_WINDOW
multiline_comment|/*&n;&t;&t;&t; *  Test if we have transmitted more bytes over the&n;&t;&t;&t; *  link than its possible to do with the current&n;&t;&t;&t; *  speed and turn-around-time.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|skb-&gt;len
OG
id|self-&gt;bytes_left
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|4
comma
l_string|&quot;%s(), Not allowed to transmit&quot;
l_string|&quot; more bytes!&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
id|skb_queue_head
c_func
(paren
op_amp
id|self-&gt;txq
comma
id|skb_get
c_func
(paren
id|skb
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; *  We should switch state to LAP_NRM_P, but&n;&t;&t;&t;&t; *  that is not possible since we must be sure&n;&t;&t;&t;&t; *  that we poll the other side. Since we have&n;&t;&t;&t;&t; *  used up our time, the poll timer should&n;&t;&t;&t;&t; *  trigger anyway now, so we just wait for it&n;&t;&t;&t;&t; *  DB&n;&t;&t;&t;&t; */
r_return
op_minus
id|EPROTO
suffix:semicolon
)brace
id|self-&gt;bytes_left
op_sub_assign
id|skb-&gt;len
suffix:semicolon
macro_line|#endif /* CONFIG_IRDA_DYNAMIC_WINDOW */
multiline_comment|/*&n;&t;&t;&t; *  Send data with poll bit cleared only if window &gt; 1&n;&t;&t;&t; *  and there is more frames after this one to be sent&n;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|self-&gt;window
OG
l_int|1
)paren
op_logical_and
id|skb_queue_len
c_func
(paren
op_amp
id|self-&gt;txq
)paren
OG
l_int|0
)paren
(brace
id|irlap_send_data_primary
c_func
(paren
id|self
comma
id|skb
)paren
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_XMIT_P
)paren
suffix:semicolon
)brace
r_else
(brace
id|irlap_send_data_primary_poll
c_func
(paren
id|self
comma
id|skb
)paren
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NRM_P
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * Make sure state machine does not try to send&n;&t;&t;&t;&t; * any more frames&n;&t;&t;&t;&t; */
id|ret
op_assign
op_minus
id|EPROTO
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_IRDA_FAST_RR
multiline_comment|/* Peer may want to reply immediately */
id|self-&gt;fast_RR
op_assign
id|FALSE
suffix:semicolon
macro_line|#endif /* CONFIG_IRDA_FAST_RR */
)brace
r_else
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|4
comma
l_string|&quot;%s(), Unable to send! remote busy?&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
id|skb_queue_head
c_func
(paren
op_amp
id|self-&gt;txq
comma
id|skb_get
c_func
(paren
id|skb
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; *  The next ret is important, because it tells&n;&t;&t;&t; *  irlap_next_state _not_ to deliver more frames&n;&t;&t;&t; */
id|ret
op_assign
op_minus
id|EPROTO
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|POLL_TIMER_EXPIRED
suffix:colon
id|IRDA_DEBUG
c_func
(paren
l_int|3
comma
l_string|&quot;%s(), POLL_TIMER_EXPIRED &lt;%ld&gt;&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|jiffies
)paren
suffix:semicolon
id|irlap_send_rr_frame
c_func
(paren
id|self
comma
id|CMD_FRAME
)paren
suffix:semicolon
multiline_comment|/* Return to NRM properly - Jean II  */
id|self-&gt;window
op_assign
id|self-&gt;window_size
suffix:semicolon
macro_line|#ifdef CONFIG_IRDA_DYNAMIC_WINDOW
multiline_comment|/* Allowed to transmit a maximum number of bytes again. */
id|self-&gt;bytes_left
op_assign
id|self-&gt;line_capacity
suffix:semicolon
macro_line|#endif /* CONFIG_IRDA_DYNAMIC_WINDOW */
id|irlap_start_final_timer
c_func
(paren
id|self
comma
id|self-&gt;final_timeout
)paren
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NRM_P
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DISCONNECT_REQUEST
suffix:colon
id|del_timer
c_func
(paren
op_amp
id|self-&gt;poll_timer
)paren
suffix:semicolon
id|irlap_wait_min_turn_around
c_func
(paren
id|self
comma
op_amp
id|self-&gt;qos_tx
)paren
suffix:semicolon
id|irlap_send_disc_frame
c_func
(paren
id|self
)paren
suffix:semicolon
id|irlap_flush_all_queues
c_func
(paren
id|self
)paren
suffix:semicolon
id|irlap_start_final_timer
c_func
(paren
id|self
comma
id|self-&gt;final_timeout
)paren
suffix:semicolon
id|self-&gt;retry_count
op_assign
l_int|0
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_PCLOSE
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DATA_REQUEST
suffix:colon
multiline_comment|/* Nothing to do, irlap_do_event() will send the packet&n;&t;&t; * when we return... - Jean II */
r_break
suffix:semicolon
r_default
suffix:colon
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
l_string|&quot;%s(), Unknown event %s&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|irlap_event
(braket
id|event
)braket
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irlap_state_pclose (event, skb, info)&n; *&n; *    PCLOSE state&n; */
DECL|function|irlap_state_pclose
r_static
r_int
id|irlap_state_pclose
c_func
(paren
r_struct
id|irlap_cb
op_star
id|self
comma
id|IRLAP_EVENT
id|event
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|irlap_info
op_star
id|info
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;%s()&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|LAP_MAGIC
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|event
)paren
(brace
r_case
id|RECV_UA_RSP
suffix:colon
multiline_comment|/* FALLTHROUGH */
r_case
id|RECV_DM_RSP
suffix:colon
id|del_timer
c_func
(paren
op_amp
id|self-&gt;final_timer
)paren
suffix:semicolon
multiline_comment|/* Set new link parameters */
id|irlap_apply_default_connection_parameters
c_func
(paren
id|self
)paren
suffix:semicolon
multiline_comment|/* Always switch state before calling upper layers */
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NDM
)paren
suffix:semicolon
id|irlap_disconnect_indication
c_func
(paren
id|self
comma
id|LAP_DISC_INDICATION
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FINAL_TIMER_EXPIRED
suffix:colon
r_if
c_cond
(paren
id|self-&gt;retry_count
OL
id|self-&gt;N3
)paren
(brace
id|irlap_wait_min_turn_around
c_func
(paren
id|self
comma
op_amp
id|self-&gt;qos_tx
)paren
suffix:semicolon
id|irlap_send_disc_frame
c_func
(paren
id|self
)paren
suffix:semicolon
id|irlap_start_final_timer
c_func
(paren
id|self
comma
id|self-&gt;final_timeout
)paren
suffix:semicolon
id|self-&gt;retry_count
op_increment
suffix:semicolon
multiline_comment|/* Keep state */
)brace
r_else
(brace
id|irlap_apply_default_connection_parameters
c_func
(paren
id|self
)paren
suffix:semicolon
multiline_comment|/*  Always switch state before calling upper layers */
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NDM
)paren
suffix:semicolon
id|irlap_disconnect_indication
c_func
(paren
id|self
comma
id|LAP_NO_RESPONSE
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;%s(), Unknown event %d&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|event
)paren
suffix:semicolon
id|ret
op_assign
op_minus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irlap_state_nrm_p (self, event, skb, info)&n; *&n; *   NRM_P (Normal Response Mode as Primary), The primary station has given&n; *   permissions to a secondary station to transmit IrLAP resonse frames&n; *   (by sending a frame with the P bit set). The primary station will not&n; *   transmit any frames and is expecting to receive frames only from the&n; *   secondary to which transmission permissions has been given.&n; */
DECL|function|irlap_state_nrm_p
r_static
r_int
id|irlap_state_nrm_p
c_func
(paren
r_struct
id|irlap_cb
op_star
id|self
comma
id|IRLAP_EVENT
id|event
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|irlap_info
op_star
id|info
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_int
id|ns_status
suffix:semicolon
r_int
id|nr_status
suffix:semicolon
r_switch
c_cond
(paren
id|event
)paren
(brace
r_case
id|RECV_I_RSP
suffix:colon
multiline_comment|/* Optimize for the common case */
multiline_comment|/* FIXME: must check for remote_busy below */
macro_line|#ifdef CONFIG_IRDA_FAST_RR
multiline_comment|/*&n;&t;&t; *  Reset the fast_RR so we can use the fast RR code with&n;&t;&t; *  full speed the next time since peer may have more frames&n;&t;&t; *  to transmitt&n;&t;&t; */
id|self-&gt;fast_RR
op_assign
id|FALSE
suffix:semicolon
macro_line|#endif /* CONFIG_IRDA_FAST_RR */
id|ASSERT
c_func
(paren
id|info
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|ns_status
op_assign
id|irlap_validate_ns_received
c_func
(paren
id|self
comma
id|info-&gt;ns
)paren
suffix:semicolon
id|nr_status
op_assign
id|irlap_validate_nr_received
c_func
(paren
id|self
comma
id|info-&gt;nr
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *  Check for expected I(nformation) frame&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|ns_status
op_eq
id|NS_EXPECTED
)paren
op_logical_and
(paren
id|nr_status
op_eq
id|NR_EXPECTED
)paren
)paren
(brace
multiline_comment|/*  poll bit cleared?  */
r_if
c_cond
(paren
op_logical_neg
id|info-&gt;pf
)paren
(brace
id|self-&gt;vr
op_assign
(paren
id|self-&gt;vr
op_plus
l_int|1
)paren
op_mod
l_int|8
suffix:semicolon
multiline_comment|/* Update Nr received */
id|irlap_update_nr_received
c_func
(paren
id|self
comma
id|info-&gt;nr
)paren
suffix:semicolon
id|self-&gt;ack_required
op_assign
id|TRUE
suffix:semicolon
multiline_comment|/* Keep state, do not move this line */
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NRM_P
)paren
suffix:semicolon
id|irlap_data_indication
c_func
(paren
id|self
comma
id|skb
comma
id|FALSE
)paren
suffix:semicolon
)brace
r_else
(brace
id|del_timer
c_func
(paren
op_amp
id|self-&gt;final_timer
)paren
suffix:semicolon
id|self-&gt;vr
op_assign
(paren
id|self-&gt;vr
op_plus
l_int|1
)paren
op_mod
l_int|8
suffix:semicolon
multiline_comment|/* Update Nr received */
id|irlap_update_nr_received
c_func
(paren
id|self
comma
id|info-&gt;nr
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; *  Got expected NR, so reset the&n;&t;&t;&t;&t; *  retry_count. This is not done by IrLAP,&n;&t;&t;&t;&t; *  which is strange!&n;&t;&t;&t;&t; */
id|self-&gt;retry_count
op_assign
l_int|0
suffix:semicolon
id|self-&gt;ack_required
op_assign
id|TRUE
suffix:semicolon
id|irlap_wait_min_turn_around
c_func
(paren
id|self
comma
op_amp
id|self-&gt;qos_tx
)paren
suffix:semicolon
multiline_comment|/* Call higher layer *before* changing state&n;&t;&t;&t;&t; * to give them a chance to send data in the&n;&t;&t;&t;&t; * next LAP frame.&n;&t;&t;&t;&t; * Jean II */
id|irlap_data_indication
c_func
(paren
id|self
comma
id|skb
comma
id|FALSE
)paren
suffix:semicolon
multiline_comment|/* XMIT states are the most dangerous state&n;&t;&t;&t;&t; * to be in, because user requests are&n;&t;&t;&t;&t; * processed directly and may change state.&n;&t;&t;&t;&t; * On the other hand, in NDM_P, those&n;&t;&t;&t;&t; * requests are queued and we will process&n;&t;&t;&t;&t; * them when we return to irlap_do_event().&n;&t;&t;&t;&t; * Jean II&n;&t;&t;&t;&t; */
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_XMIT_P
)paren
suffix:semicolon
multiline_comment|/* This is the last frame.&n;&t;&t;&t;&t; * Make sure it&squot;s always called in XMIT state.&n;&t;&t;&t;&t; * - Jean II */
id|irlap_start_poll_timer
c_func
(paren
id|self
comma
id|self-&gt;poll_timeout
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
multiline_comment|/* Unexpected next to send (Ns) */
r_if
c_cond
(paren
(paren
id|ns_status
op_eq
id|NS_UNEXPECTED
)paren
op_logical_and
(paren
id|nr_status
op_eq
id|NR_EXPECTED
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|info-&gt;pf
)paren
(brace
id|irlap_update_nr_received
c_func
(paren
id|self
comma
id|info-&gt;nr
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; *  Wait until the last frame before doing&n;&t;&t;&t;&t; *  anything&n;&t;&t;&t;&t; */
multiline_comment|/* Keep state */
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NRM_P
)paren
suffix:semicolon
)brace
r_else
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|4
comma
l_string|&quot;%s(), missing or duplicate frame!&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
multiline_comment|/* Update Nr received */
id|irlap_update_nr_received
c_func
(paren
id|self
comma
id|info-&gt;nr
)paren
suffix:semicolon
id|irlap_wait_min_turn_around
c_func
(paren
id|self
comma
op_amp
id|self-&gt;qos_tx
)paren
suffix:semicolon
id|irlap_send_rr_frame
c_func
(paren
id|self
comma
id|CMD_FRAME
)paren
suffix:semicolon
id|self-&gt;ack_required
op_assign
id|FALSE
suffix:semicolon
id|irlap_start_final_timer
c_func
(paren
id|self
comma
id|self-&gt;final_timeout
)paren
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NRM_P
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; *  Unexpected next to receive (Nr)&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|ns_status
op_eq
id|NS_EXPECTED
)paren
op_logical_and
(paren
id|nr_status
op_eq
id|NR_UNEXPECTED
)paren
)paren
(brace
r_if
c_cond
(paren
id|info-&gt;pf
)paren
(brace
id|self-&gt;vr
op_assign
(paren
id|self-&gt;vr
op_plus
l_int|1
)paren
op_mod
l_int|8
suffix:semicolon
multiline_comment|/* Update Nr received */
id|irlap_update_nr_received
c_func
(paren
id|self
comma
id|info-&gt;nr
)paren
suffix:semicolon
multiline_comment|/* Resend rejected frames */
id|irlap_resend_rejected_frames
c_func
(paren
id|self
comma
id|CMD_FRAME
)paren
suffix:semicolon
id|self-&gt;ack_required
op_assign
id|FALSE
suffix:semicolon
id|irlap_start_final_timer
c_func
(paren
id|self
comma
id|self-&gt;final_timeout
)paren
suffix:semicolon
multiline_comment|/* Keep state, do not move this line */
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NRM_P
)paren
suffix:semicolon
id|irlap_data_indication
c_func
(paren
id|self
comma
id|skb
comma
id|FALSE
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t;&t; *  Do not resend frames until the last&n;&t;&t;&t;&t; *  frame has arrived from the other&n;&t;&t;&t;&t; *  device. This is not documented in&n;&t;&t;&t;&t; *  IrLAP!!&n;&t;&t;&t;&t; */
id|self-&gt;vr
op_assign
(paren
id|self-&gt;vr
op_plus
l_int|1
)paren
op_mod
l_int|8
suffix:semicolon
multiline_comment|/* Update Nr received */
id|irlap_update_nr_received
c_func
(paren
id|self
comma
id|info-&gt;nr
)paren
suffix:semicolon
id|self-&gt;ack_required
op_assign
id|FALSE
suffix:semicolon
multiline_comment|/* Keep state, do not move this line!*/
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NRM_P
)paren
suffix:semicolon
id|irlap_data_indication
c_func
(paren
id|self
comma
id|skb
comma
id|FALSE
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; *  Unexpected next to send (Ns) and next to receive (Nr)&n;&t;&t; *  Not documented by IrLAP!&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|ns_status
op_eq
id|NS_UNEXPECTED
)paren
op_logical_and
(paren
id|nr_status
op_eq
id|NR_UNEXPECTED
)paren
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|4
comma
l_string|&quot;%s(), unexpected nr and ns!&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;pf
)paren
(brace
multiline_comment|/* Resend rejected frames */
id|irlap_resend_rejected_frames
c_func
(paren
id|self
comma
id|CMD_FRAME
)paren
suffix:semicolon
multiline_comment|/* Give peer some time to retransmit! */
id|irlap_start_final_timer
c_func
(paren
id|self
comma
id|self-&gt;final_timeout
)paren
suffix:semicolon
multiline_comment|/* Keep state, do not move this line */
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NRM_P
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Update Nr received */
multiline_comment|/* irlap_update_nr_received( info-&gt;nr); */
id|self-&gt;ack_required
op_assign
id|FALSE
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; *  Invalid NR or NS&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|nr_status
op_eq
id|NR_INVALID
)paren
op_logical_or
(paren
id|ns_status
op_eq
id|NS_INVALID
)paren
)paren
(brace
r_if
c_cond
(paren
id|info-&gt;pf
)paren
(brace
id|del_timer
c_func
(paren
op_amp
id|self-&gt;final_timer
)paren
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_RESET_WAIT
)paren
suffix:semicolon
id|irlap_disconnect_indication
c_func
(paren
id|self
comma
id|LAP_RESET_INDICATION
)paren
suffix:semicolon
id|self-&gt;xmitflag
op_assign
id|TRUE
suffix:semicolon
)brace
r_else
(brace
id|del_timer
c_func
(paren
op_amp
id|self-&gt;final_timer
)paren
suffix:semicolon
id|irlap_disconnect_indication
c_func
(paren
id|self
comma
id|LAP_RESET_INDICATION
)paren
suffix:semicolon
id|self-&gt;xmitflag
op_assign
id|FALSE
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;%s(), Not implemented!&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;%s(), event=%s, ns_status=%d, nr_status=%d&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|irlap_event
(braket
id|event
)braket
comma
id|ns_status
comma
id|nr_status
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RECV_UI_FRAME
suffix:colon
multiline_comment|/* Poll bit cleared? */
r_if
c_cond
(paren
op_logical_neg
id|info-&gt;pf
)paren
(brace
id|irlap_data_indication
c_func
(paren
id|self
comma
id|skb
comma
id|TRUE
)paren
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NRM_P
)paren
suffix:semicolon
)brace
r_else
(brace
id|del_timer
c_func
(paren
op_amp
id|self-&gt;final_timer
)paren
suffix:semicolon
id|irlap_data_indication
c_func
(paren
id|self
comma
id|skb
comma
id|TRUE
)paren
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_XMIT_P
)paren
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;%s: RECV_UI_FRAME: next state %s&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|irlap_state
(braket
id|self-&gt;state
)braket
)paren
suffix:semicolon
id|irlap_start_poll_timer
c_func
(paren
id|self
comma
id|self-&gt;poll_timeout
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|RECV_RR_RSP
suffix:colon
multiline_comment|/*&n;&t;&t; *  If you get a RR, the remote isn&squot;t busy anymore,&n;&t;&t; *  no matter what the NR&n;&t;&t; */
id|self-&gt;remote_busy
op_assign
id|FALSE
suffix:semicolon
multiline_comment|/*&n;&t;&t; *  Nr as expected?&n;&t;&t; */
id|ret
op_assign
id|irlap_validate_nr_received
c_func
(paren
id|self
comma
id|info-&gt;nr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
id|NR_EXPECTED
)paren
(brace
multiline_comment|/* Stop final timer */
id|del_timer
c_func
(paren
op_amp
id|self-&gt;final_timer
)paren
suffix:semicolon
multiline_comment|/* Update Nr received */
id|irlap_update_nr_received
c_func
(paren
id|self
comma
id|info-&gt;nr
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; *  Got expected NR, so reset the retry_count. This&n;&t;&t;&t; *  is not done by the IrLAP standard , which is&n;&t;&t;&t; *  strange! DB.&n;&t;&t;&t; */
id|self-&gt;retry_count
op_assign
l_int|0
suffix:semicolon
id|irlap_wait_min_turn_around
c_func
(paren
id|self
comma
op_amp
id|self-&gt;qos_tx
)paren
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_XMIT_P
)paren
suffix:semicolon
multiline_comment|/* Start poll timer */
id|irlap_start_poll_timer
c_func
(paren
id|self
comma
id|self-&gt;poll_timeout
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ret
op_eq
id|NR_UNEXPECTED
)paren
(brace
id|ASSERT
c_func
(paren
id|info
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; *  Unexpected nr!&n;&t;&t;&t; */
multiline_comment|/* Update Nr received */
id|irlap_update_nr_received
c_func
(paren
id|self
comma
id|info-&gt;nr
)paren
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|4
comma
l_string|&quot;RECV_RR_FRAME: Retrans:%d, nr=%d, va=%d, &quot;
l_string|&quot;vs=%d, vr=%d&bslash;n&quot;
comma
id|self-&gt;retry_count
comma
id|info-&gt;nr
comma
id|self-&gt;va
comma
id|self-&gt;vs
comma
id|self-&gt;vr
)paren
suffix:semicolon
multiline_comment|/* Resend rejected frames */
id|irlap_resend_rejected_frames
c_func
(paren
id|self
comma
id|CMD_FRAME
)paren
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NRM_P
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ret
op_eq
id|NR_INVALID
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;%s(), Received RR with &quot;
l_string|&quot;invalid nr !&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|self-&gt;final_timer
)paren
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_RESET_WAIT
)paren
suffix:semicolon
id|irlap_disconnect_indication
c_func
(paren
id|self
comma
id|LAP_RESET_INDICATION
)paren
suffix:semicolon
id|self-&gt;xmitflag
op_assign
id|TRUE
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|RECV_RNR_RSP
suffix:colon
id|ASSERT
c_func
(paren
id|info
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
multiline_comment|/* Stop final timer */
id|del_timer
c_func
(paren
op_amp
id|self-&gt;final_timer
)paren
suffix:semicolon
id|self-&gt;remote_busy
op_assign
id|TRUE
suffix:semicolon
multiline_comment|/* Update Nr received */
id|irlap_update_nr_received
c_func
(paren
id|self
comma
id|info-&gt;nr
)paren
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_XMIT_P
)paren
suffix:semicolon
multiline_comment|/* Start poll timer */
id|irlap_start_poll_timer
c_func
(paren
id|self
comma
id|self-&gt;poll_timeout
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RECV_FRMR_RSP
suffix:colon
id|del_timer
c_func
(paren
op_amp
id|self-&gt;final_timer
)paren
suffix:semicolon
id|self-&gt;xmitflag
op_assign
id|TRUE
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_RESET_WAIT
)paren
suffix:semicolon
id|irlap_reset_indication
c_func
(paren
id|self
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FINAL_TIMER_EXPIRED
suffix:colon
multiline_comment|/*&n;&t;&t; *  We are allowed to wait for additional 300 ms if&n;&t;&t; *  final timer expires when we are in the middle&n;&t;&t; *  of receiving a frame (page 45, IrLAP). Check that&n;&t;&t; *  we only do this once for each frame.&n;&t;&t; */
r_if
c_cond
(paren
id|irda_device_is_receiving
c_func
(paren
id|self-&gt;netdev
)paren
op_logical_and
op_logical_neg
id|self-&gt;add_wait
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;FINAL_TIMER_EXPIRED when receiving a &quot;
l_string|&quot;frame! Waiting a little bit more!&bslash;n&quot;
)paren
suffix:semicolon
id|irlap_start_final_timer
c_func
(paren
id|self
comma
id|MSECS_TO_JIFFIES
c_func
(paren
l_int|300
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; *  Don&squot;t allow this to happen one more time in a row,&n;&t;&t;&t; *  or else we can get a pretty tight loop here if&n;&t;&t;&t; *  if we only receive half a frame. DB.&n;&t;&t;&t; */
id|self-&gt;add_wait
op_assign
id|TRUE
suffix:semicolon
r_break
suffix:semicolon
)brace
id|self-&gt;add_wait
op_assign
id|FALSE
suffix:semicolon
multiline_comment|/* N2 is the disconnect timer. Until we reach it, we retry */
r_if
c_cond
(paren
id|self-&gt;retry_count
OL
id|self-&gt;N2
)paren
(brace
multiline_comment|/* Retry sending the pf bit to the secondary */
id|irlap_wait_min_turn_around
c_func
(paren
id|self
comma
op_amp
id|self-&gt;qos_tx
)paren
suffix:semicolon
id|irlap_send_rr_frame
c_func
(paren
id|self
comma
id|CMD_FRAME
)paren
suffix:semicolon
id|irlap_start_final_timer
c_func
(paren
id|self
comma
id|self-&gt;final_timeout
)paren
suffix:semicolon
id|self-&gt;retry_count
op_increment
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|4
comma
l_string|&quot;irlap_state_nrm_p: FINAL_TIMER_EXPIRED:&quot;
l_string|&quot; retry_count=%d&bslash;n&quot;
comma
id|self-&gt;retry_count
)paren
suffix:semicolon
multiline_comment|/* Early warning event. I&squot;m using a pretty liberal&n;&t;&t;&t; * interpretation of the spec and generate an event&n;&t;&t;&t; * every time the timer is multiple of N1 (and not&n;&t;&t;&t; * only the first time). This allow application&n;&t;&t;&t; * to know precisely if connectivity restart...&n;&t;&t;&t; * Jean II */
r_if
c_cond
(paren
(paren
id|self-&gt;retry_count
op_mod
id|self-&gt;N1
)paren
op_eq
l_int|0
)paren
(brace
id|irlap_status_indication
c_func
(paren
id|self
comma
id|STATUS_NO_ACTIVITY
)paren
suffix:semicolon
)brace
multiline_comment|/* Keep state */
)brace
r_else
(brace
id|irlap_apply_default_connection_parameters
c_func
(paren
id|self
)paren
suffix:semicolon
multiline_comment|/* Always switch state before calling upper layers */
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NDM
)paren
suffix:semicolon
id|irlap_disconnect_indication
c_func
(paren
id|self
comma
id|LAP_NO_RESPONSE
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|RECV_REJ_RSP
suffix:colon
id|irlap_update_nr_received
c_func
(paren
id|self
comma
id|info-&gt;nr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|self-&gt;remote_busy
)paren
(brace
id|irlap_wait_min_turn_around
c_func
(paren
id|self
comma
op_amp
id|self-&gt;qos_tx
)paren
suffix:semicolon
id|irlap_send_rr_frame
c_func
(paren
id|self
comma
id|CMD_FRAME
)paren
suffix:semicolon
)brace
r_else
id|irlap_resend_rejected_frames
c_func
(paren
id|self
comma
id|CMD_FRAME
)paren
suffix:semicolon
id|irlap_start_final_timer
c_func
(paren
id|self
comma
id|self-&gt;final_timeout
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RECV_SREJ_RSP
suffix:colon
id|irlap_update_nr_received
c_func
(paren
id|self
comma
id|info-&gt;nr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|self-&gt;remote_busy
)paren
(brace
id|irlap_wait_min_turn_around
c_func
(paren
id|self
comma
op_amp
id|self-&gt;qos_tx
)paren
suffix:semicolon
id|irlap_send_rr_frame
c_func
(paren
id|self
comma
id|CMD_FRAME
)paren
suffix:semicolon
)brace
r_else
id|irlap_resend_rejected_frame
c_func
(paren
id|self
comma
id|CMD_FRAME
)paren
suffix:semicolon
id|irlap_start_final_timer
c_func
(paren
id|self
comma
id|self-&gt;final_timeout
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RECV_RD_RSP
suffix:colon
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;%s(), RECV_RD_RSP&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
id|irlap_flush_all_queues
c_func
(paren
id|self
)paren
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_XMIT_P
)paren
suffix:semicolon
multiline_comment|/* Call back the LAP state machine to do a proper disconnect */
id|irlap_disconnect_request
c_func
(paren
id|self
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;%s(), Unknown event %s&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|irlap_event
(braket
id|event
)braket
)paren
suffix:semicolon
id|ret
op_assign
op_minus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irlap_state_reset_wait (event, skb, info)&n; *&n; *    We have informed the service user of a reset condition, and is&n; *    awaiting reset of disconnect request.&n; *&n; */
DECL|function|irlap_state_reset_wait
r_static
r_int
id|irlap_state_reset_wait
c_func
(paren
r_struct
id|irlap_cb
op_star
id|self
comma
id|IRLAP_EVENT
id|event
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|irlap_info
op_star
id|info
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|3
comma
l_string|&quot;%s(), event = %s&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|irlap_event
(braket
id|event
)braket
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|LAP_MAGIC
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|event
)paren
(brace
r_case
id|RESET_REQUEST
suffix:colon
r_if
c_cond
(paren
id|self-&gt;xmitflag
)paren
(brace
id|irlap_wait_min_turn_around
c_func
(paren
id|self
comma
op_amp
id|self-&gt;qos_tx
)paren
suffix:semicolon
id|irlap_send_snrm_frame
c_func
(paren
id|self
comma
l_int|NULL
)paren
suffix:semicolon
id|irlap_start_final_timer
c_func
(paren
id|self
comma
id|self-&gt;final_timeout
)paren
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_RESET
)paren
suffix:semicolon
)brace
r_else
(brace
id|irlap_start_final_timer
c_func
(paren
id|self
comma
id|self-&gt;final_timeout
)paren
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_RESET
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|DISCONNECT_REQUEST
suffix:colon
id|irlap_wait_min_turn_around
c_func
(paren
id|self
comma
op_amp
id|self-&gt;qos_tx
)paren
suffix:semicolon
id|irlap_send_disc_frame
c_func
(paren
id|self
)paren
suffix:semicolon
id|irlap_flush_all_queues
c_func
(paren
id|self
)paren
suffix:semicolon
id|irlap_start_final_timer
c_func
(paren
id|self
comma
id|self-&gt;final_timeout
)paren
suffix:semicolon
id|self-&gt;retry_count
op_assign
l_int|0
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_PCLOSE
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|IRDA_DEBUG
c_func
(paren
l_int|2
comma
l_string|&quot;%s(), Unknown event %s&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|irlap_event
(braket
id|event
)braket
)paren
suffix:semicolon
id|ret
op_assign
op_minus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irlap_state_reset (self, event, skb, info)&n; *&n; *    We have sent a SNRM reset command to the peer layer, and is awaiting&n; *    reply.&n; *&n; */
DECL|function|irlap_state_reset
r_static
r_int
id|irlap_state_reset
c_func
(paren
r_struct
id|irlap_cb
op_star
id|self
comma
id|IRLAP_EVENT
id|event
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|irlap_info
op_star
id|info
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|3
comma
l_string|&quot;%s(), event = %s&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|irlap_event
(braket
id|event
)braket
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|LAP_MAGIC
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|event
)paren
(brace
r_case
id|RECV_DISC_CMD
suffix:colon
id|del_timer
c_func
(paren
op_amp
id|self-&gt;final_timer
)paren
suffix:semicolon
id|irlap_apply_default_connection_parameters
c_func
(paren
id|self
)paren
suffix:semicolon
multiline_comment|/* Always switch state before calling upper layers */
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NDM
)paren
suffix:semicolon
id|irlap_disconnect_indication
c_func
(paren
id|self
comma
id|LAP_NO_RESPONSE
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RECV_UA_RSP
suffix:colon
id|del_timer
c_func
(paren
op_amp
id|self-&gt;final_timer
)paren
suffix:semicolon
multiline_comment|/* Initiate connection state */
id|irlap_initiate_connection_state
c_func
(paren
id|self
)paren
suffix:semicolon
id|irlap_reset_confirm
c_func
(paren
)paren
suffix:semicolon
id|self-&gt;remote_busy
op_assign
id|FALSE
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_XMIT_P
)paren
suffix:semicolon
id|irlap_start_poll_timer
c_func
(paren
id|self
comma
id|self-&gt;poll_timeout
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FINAL_TIMER_EXPIRED
suffix:colon
r_if
c_cond
(paren
id|self-&gt;retry_count
OL
l_int|3
)paren
(brace
id|irlap_wait_min_turn_around
c_func
(paren
id|self
comma
op_amp
id|self-&gt;qos_tx
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;netdev
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|irlap_send_snrm_frame
c_func
(paren
id|self
comma
id|self-&gt;qos_dev
)paren
suffix:semicolon
id|self-&gt;retry_count
op_increment
suffix:semicolon
multiline_comment|/* Experimental!! */
id|irlap_start_final_timer
c_func
(paren
id|self
comma
id|self-&gt;final_timeout
)paren
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_RESET
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|self-&gt;retry_count
op_ge
id|self-&gt;N3
)paren
(brace
id|irlap_apply_default_connection_parameters
c_func
(paren
id|self
)paren
suffix:semicolon
multiline_comment|/* Always switch state before calling upper layers */
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NDM
)paren
suffix:semicolon
id|irlap_disconnect_indication
c_func
(paren
id|self
comma
id|LAP_NO_RESPONSE
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|RECV_SNRM_CMD
suffix:colon
multiline_comment|/*&n;&t;&t; * SNRM frame is not allowed to contain an I-field in this&n;&t;&t; * state&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|info
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|3
comma
l_string|&quot;%s(), RECV_SNRM_CMD&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
id|irlap_initiate_connection_state
c_func
(paren
id|self
)paren
suffix:semicolon
id|irlap_wait_min_turn_around
c_func
(paren
id|self
comma
op_amp
id|self-&gt;qos_tx
)paren
suffix:semicolon
id|irlap_send_ua_response_frame
c_func
(paren
id|self
comma
op_amp
id|self-&gt;qos_rx
)paren
suffix:semicolon
id|irlap_reset_confirm
c_func
(paren
)paren
suffix:semicolon
id|irlap_start_wd_timer
c_func
(paren
id|self
comma
id|self-&gt;wd_timeout
)paren
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NDM
)paren
suffix:semicolon
)brace
r_else
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
l_string|&quot;%s(), SNRM frame contained an I field!&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;%s(), Unknown event %s&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|irlap_event
(braket
id|event
)braket
)paren
suffix:semicolon
id|ret
op_assign
op_minus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irlap_state_xmit_s (event, skb, info)&n; *&n; *   XMIT_S, The secondary station has been given the right to transmit,&n; *   and we therefor do not expect to receive any transmissions from other&n; *   stations.&n; */
DECL|function|irlap_state_xmit_s
r_static
r_int
id|irlap_state_xmit_s
c_func
(paren
r_struct
id|irlap_cb
op_star
id|self
comma
id|IRLAP_EVENT
id|event
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|irlap_info
op_star
id|info
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|4
comma
l_string|&quot;%s(), event=%s&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|irlap_event
(braket
id|event
)braket
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
op_minus
id|ENODEV
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|LAP_MAGIC
comma
r_return
op_minus
id|EBADR
suffix:semicolon
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|event
)paren
(brace
r_case
id|SEND_I_CMD
suffix:colon
multiline_comment|/*&n;&t;&t; *  Send frame only if send window &gt; 1&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|self-&gt;window
OG
l_int|0
)paren
op_logical_and
(paren
op_logical_neg
id|self-&gt;remote_busy
)paren
)paren
(brace
macro_line|#ifdef CONFIG_IRDA_DYNAMIC_WINDOW
multiline_comment|/*&n;&t;&t;&t; *  Test if we have transmitted more bytes over the&n;&t;&t;&t; *  link than its possible to do with the current&n;&t;&t;&t; *  speed and turn-around-time.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|skb-&gt;len
OG
id|self-&gt;bytes_left
)paren
(brace
id|skb_queue_head
c_func
(paren
op_amp
id|self-&gt;txq
comma
id|skb_get
c_func
(paren
id|skb
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; *  Switch to NRM_S, this is only possible&n;&t;&t;&t;&t; *  when we are in secondary mode, since we&n;&t;&t;&t;&t; *  must be sure that we don&squot;t miss any RR&n;&t;&t;&t;&t; *  frames&n;&t;&t;&t;&t; */
id|self-&gt;window
op_assign
id|self-&gt;window_size
suffix:semicolon
id|self-&gt;bytes_left
op_assign
id|self-&gt;line_capacity
suffix:semicolon
id|irlap_start_wd_timer
c_func
(paren
id|self
comma
id|self-&gt;wd_timeout
)paren
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NRM_S
)paren
suffix:semicolon
r_return
op_minus
id|EPROTO
suffix:semicolon
multiline_comment|/* Try again later */
)brace
id|self-&gt;bytes_left
op_sub_assign
id|skb-&gt;len
suffix:semicolon
macro_line|#endif /* CONFIG_IRDA_DYNAMIC_WINDOW */
multiline_comment|/*&n;&t;&t;&t; *  Send data with final bit cleared only if window &gt; 1&n;&t;&t;&t; *  and there is more frames to be sent&n;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|self-&gt;window
OG
l_int|1
)paren
op_logical_and
id|skb_queue_len
c_func
(paren
op_amp
id|self-&gt;txq
)paren
OG
l_int|0
)paren
(brace
id|irlap_send_data_secondary
c_func
(paren
id|self
comma
id|skb
)paren
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_XMIT_S
)paren
suffix:semicolon
)brace
r_else
(brace
id|irlap_send_data_secondary_final
c_func
(paren
id|self
comma
id|skb
)paren
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NRM_S
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * Make sure state machine does not try to send&n;&t;&t;&t;&t; * any more frames&n;&t;&t;&t;&t; */
id|ret
op_assign
op_minus
id|EPROTO
suffix:semicolon
)brace
)brace
r_else
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|2
comma
l_string|&quot;%s(), Unable to send!&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
id|skb_queue_head
c_func
(paren
op_amp
id|self-&gt;txq
comma
id|skb_get
c_func
(paren
id|skb
)paren
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EPROTO
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|DISCONNECT_REQUEST
suffix:colon
id|irlap_send_rd_frame
c_func
(paren
id|self
)paren
suffix:semicolon
id|irlap_flush_all_queues
c_func
(paren
id|self
)paren
suffix:semicolon
id|irlap_start_wd_timer
c_func
(paren
id|self
comma
id|self-&gt;wd_timeout
)paren
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_SCLOSE
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DATA_REQUEST
suffix:colon
multiline_comment|/* Nothing to do, irlap_do_event() will send the packet&n;&t;&t; * when we return... - Jean II */
r_break
suffix:semicolon
r_default
suffix:colon
id|IRDA_DEBUG
c_func
(paren
l_int|2
comma
l_string|&quot;%s(), Unknown event %s&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|irlap_event
(braket
id|event
)braket
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irlap_state_nrm_s (event, skb, info)&n; *&n; *    NRM_S (Normal Response Mode as Secondary) state, in this state we are&n; *    expecting to receive frames from the primary station&n; *&n; */
DECL|function|irlap_state_nrm_s
r_static
r_int
id|irlap_state_nrm_s
c_func
(paren
r_struct
id|irlap_cb
op_star
id|self
comma
id|IRLAP_EVENT
id|event
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|irlap_info
op_star
id|info
)paren
(brace
r_int
id|ns_status
suffix:semicolon
r_int
id|nr_status
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|4
comma
l_string|&quot;%s(), event=%s&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|irlap_event
(braket
id|event
)braket
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|LAP_MAGIC
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|event
)paren
(brace
r_case
id|RECV_I_CMD
suffix:colon
multiline_comment|/* Optimize for the common case */
multiline_comment|/* FIXME: must check for remote_busy below */
id|IRDA_DEBUG
c_func
(paren
l_int|4
comma
l_string|&quot;%s(), event=%s nr=%d, vs=%d, ns=%d, &quot;
l_string|&quot;vr=%d, pf=%d&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|irlap_event
(braket
id|event
)braket
comma
id|info-&gt;nr
comma
id|self-&gt;vs
comma
id|info-&gt;ns
comma
id|self-&gt;vr
comma
id|info-&gt;pf
)paren
suffix:semicolon
id|self-&gt;retry_count
op_assign
l_int|0
suffix:semicolon
id|ns_status
op_assign
id|irlap_validate_ns_received
c_func
(paren
id|self
comma
id|info-&gt;ns
)paren
suffix:semicolon
id|nr_status
op_assign
id|irlap_validate_nr_received
c_func
(paren
id|self
comma
id|info-&gt;nr
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *  Check for expected I(nformation) frame&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|ns_status
op_eq
id|NS_EXPECTED
)paren
op_logical_and
(paren
id|nr_status
op_eq
id|NR_EXPECTED
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; *  poll bit cleared?&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|info-&gt;pf
)paren
(brace
id|self-&gt;vr
op_assign
(paren
id|self-&gt;vr
op_plus
l_int|1
)paren
op_mod
l_int|8
suffix:semicolon
multiline_comment|/* Update Nr received */
id|irlap_update_nr_received
c_func
(paren
id|self
comma
id|info-&gt;nr
)paren
suffix:semicolon
id|self-&gt;ack_required
op_assign
id|TRUE
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; *  Starting WD-timer here is optional, but&n;&t;&t;&t;&t; *  not recommended. Note 6 IrLAP p. 83&n;&t;&t;&t;&t; */
macro_line|#if 0
id|irda_start_timer
c_func
(paren
id|WD_TIMER
comma
id|self-&gt;wd_timeout
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Keep state, do not move this line */
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NRM_S
)paren
suffix:semicolon
id|irlap_data_indication
c_func
(paren
id|self
comma
id|skb
comma
id|FALSE
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_else
(brace
id|self-&gt;vr
op_assign
(paren
id|self-&gt;vr
op_plus
l_int|1
)paren
op_mod
l_int|8
suffix:semicolon
multiline_comment|/* Update Nr received */
id|irlap_update_nr_received
c_func
(paren
id|self
comma
id|info-&gt;nr
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; *  We should wait before sending RR, and&n;&t;&t;&t;&t; *  also before changing to XMIT_S&n;&t;&t;&t;&t; *  state. (note 1, IrLAP p. 82)&n;&t;&t;&t;&t; */
id|irlap_wait_min_turn_around
c_func
(paren
id|self
comma
op_amp
id|self-&gt;qos_tx
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * Give higher layers a chance to&n;&t;&t;&t;&t; * immediately reply with some data before&n;&t;&t;&t;&t; * we decide if we should send a RR frame&n;&t;&t;&t;&t; * or not&n;&t;&t;&t;&t; */
id|irlap_data_indication
c_func
(paren
id|self
comma
id|skb
comma
id|FALSE
)paren
suffix:semicolon
multiline_comment|/* Any pending data requests?  */
r_if
c_cond
(paren
(paren
id|skb_queue_len
c_func
(paren
op_amp
id|self-&gt;txq
)paren
OG
l_int|0
)paren
op_logical_and
(paren
id|self-&gt;window
OG
l_int|0
)paren
)paren
(brace
id|self-&gt;ack_required
op_assign
id|TRUE
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|self-&gt;wd_timer
)paren
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_XMIT_S
)paren
suffix:semicolon
)brace
r_else
(brace
id|irlap_send_rr_frame
c_func
(paren
id|self
comma
id|RSP_FRAME
)paren
suffix:semicolon
id|irlap_start_wd_timer
c_func
(paren
id|self
comma
id|self-&gt;wd_timeout
)paren
suffix:semicolon
multiline_comment|/* Keep the state */
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NRM_S
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t; *  Check for Unexpected next to send (Ns)&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|ns_status
op_eq
id|NS_UNEXPECTED
)paren
op_logical_and
(paren
id|nr_status
op_eq
id|NR_EXPECTED
)paren
)paren
(brace
multiline_comment|/* Unexpected next to send, with final bit cleared */
r_if
c_cond
(paren
op_logical_neg
id|info-&gt;pf
)paren
(brace
id|irlap_update_nr_received
c_func
(paren
id|self
comma
id|info-&gt;nr
)paren
suffix:semicolon
id|irlap_start_wd_timer
c_func
(paren
id|self
comma
id|self-&gt;wd_timeout
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Update Nr received */
id|irlap_update_nr_received
c_func
(paren
id|self
comma
id|info-&gt;nr
)paren
suffix:semicolon
id|irlap_wait_min_turn_around
c_func
(paren
id|self
comma
op_amp
id|self-&gt;qos_tx
)paren
suffix:semicolon
id|irlap_send_rr_frame
c_func
(paren
id|self
comma
id|CMD_FRAME
)paren
suffix:semicolon
id|irlap_start_wd_timer
c_func
(paren
id|self
comma
id|self-&gt;wd_timeout
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; *  Unexpected Next to Receive(NR) ?&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|ns_status
op_eq
id|NS_EXPECTED
)paren
op_logical_and
(paren
id|nr_status
op_eq
id|NR_UNEXPECTED
)paren
)paren
(brace
r_if
c_cond
(paren
id|info-&gt;pf
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|4
comma
l_string|&quot;RECV_I_RSP: frame(s) lost&bslash;n&quot;
)paren
suffix:semicolon
id|self-&gt;vr
op_assign
(paren
id|self-&gt;vr
op_plus
l_int|1
)paren
op_mod
l_int|8
suffix:semicolon
multiline_comment|/* Update Nr received */
id|irlap_update_nr_received
c_func
(paren
id|self
comma
id|info-&gt;nr
)paren
suffix:semicolon
multiline_comment|/* Resend rejected frames */
id|irlap_resend_rejected_frames
c_func
(paren
id|self
comma
id|RSP_FRAME
)paren
suffix:semicolon
multiline_comment|/* Keep state, do not move this line */
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NRM_S
)paren
suffix:semicolon
id|irlap_data_indication
c_func
(paren
id|self
comma
id|skb
comma
id|FALSE
)paren
suffix:semicolon
id|irlap_start_wd_timer
c_func
(paren
id|self
comma
id|self-&gt;wd_timeout
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; *  This is not documented in IrLAP!! Unexpected NR&n;&t;&t;&t; *  with poll bit cleared&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|info-&gt;pf
)paren
(brace
id|self-&gt;vr
op_assign
(paren
id|self-&gt;vr
op_plus
l_int|1
)paren
op_mod
l_int|8
suffix:semicolon
multiline_comment|/* Update Nr received */
id|irlap_update_nr_received
c_func
(paren
id|self
comma
id|info-&gt;nr
)paren
suffix:semicolon
multiline_comment|/* Keep state, do not move this line */
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NRM_S
)paren
suffix:semicolon
id|irlap_data_indication
c_func
(paren
id|self
comma
id|skb
comma
id|FALSE
)paren
suffix:semicolon
id|irlap_start_wd_timer
c_func
(paren
id|self
comma
id|self-&gt;wd_timeout
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ret
op_eq
id|NR_INVALID
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
l_string|&quot;NRM_S, NR_INVALID not implemented!&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ret
op_eq
id|NS_INVALID
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
l_string|&quot;NRM_S, NS_INVALID not implemented!&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|RECV_UI_FRAME
suffix:colon
multiline_comment|/*&n;&t;&t; *  poll bit cleared?&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|info-&gt;pf
)paren
(brace
id|irlap_data_indication
c_func
(paren
id|self
comma
id|skb
comma
id|TRUE
)paren
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NRM_S
)paren
suffix:semicolon
multiline_comment|/* Keep state */
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; *  Any pending data requests?&n;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|skb_queue_len
c_func
(paren
op_amp
id|self-&gt;txq
)paren
OG
l_int|0
)paren
op_logical_and
(paren
id|self-&gt;window
OG
l_int|0
)paren
op_logical_and
op_logical_neg
id|self-&gt;remote_busy
)paren
(brace
id|irlap_data_indication
c_func
(paren
id|self
comma
id|skb
comma
id|TRUE
)paren
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|self-&gt;wd_timer
)paren
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_XMIT_S
)paren
suffix:semicolon
)brace
r_else
(brace
id|irlap_data_indication
c_func
(paren
id|self
comma
id|skb
comma
id|TRUE
)paren
suffix:semicolon
id|irlap_wait_min_turn_around
c_func
(paren
id|self
comma
op_amp
id|self-&gt;qos_tx
)paren
suffix:semicolon
id|irlap_send_rr_frame
c_func
(paren
id|self
comma
id|RSP_FRAME
)paren
suffix:semicolon
id|self-&gt;ack_required
op_assign
id|FALSE
suffix:semicolon
id|irlap_start_wd_timer
c_func
(paren
id|self
comma
id|self-&gt;wd_timeout
)paren
suffix:semicolon
multiline_comment|/* Keep the state */
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NRM_S
)paren
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
r_case
id|RECV_RR_CMD
suffix:colon
id|self-&gt;retry_count
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t; *  Nr as expected?&n;&t;&t; */
id|nr_status
op_assign
id|irlap_validate_nr_received
c_func
(paren
id|self
comma
id|info-&gt;nr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nr_status
op_eq
id|NR_EXPECTED
)paren
(brace
r_if
c_cond
(paren
(paren
id|skb_queue_len
c_func
(paren
op_amp
id|self-&gt;txq
)paren
OG
l_int|0
)paren
op_logical_and
(paren
id|self-&gt;window
OG
l_int|0
)paren
)paren
(brace
id|self-&gt;remote_busy
op_assign
id|FALSE
suffix:semicolon
multiline_comment|/* Update Nr received */
id|irlap_update_nr_received
c_func
(paren
id|self
comma
id|info-&gt;nr
)paren
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|self-&gt;wd_timer
)paren
suffix:semicolon
id|irlap_wait_min_turn_around
c_func
(paren
id|self
comma
op_amp
id|self-&gt;qos_tx
)paren
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_XMIT_S
)paren
suffix:semicolon
)brace
r_else
(brace
id|self-&gt;remote_busy
op_assign
id|FALSE
suffix:semicolon
multiline_comment|/* Update Nr received */
id|irlap_update_nr_received
c_func
(paren
id|self
comma
id|info-&gt;nr
)paren
suffix:semicolon
id|irlap_wait_min_turn_around
c_func
(paren
id|self
comma
op_amp
id|self-&gt;qos_tx
)paren
suffix:semicolon
id|irlap_start_wd_timer
c_func
(paren
id|self
comma
id|self-&gt;wd_timeout
)paren
suffix:semicolon
multiline_comment|/* Note : if the link is idle (this case),&n;&t;&t;&t;&t; * we never go in XMIT_S, so we never get a&n;&t;&t;&t;&t; * chance to process any DISCONNECT_REQUEST.&n;&t;&t;&t;&t; * Do it now ! - Jean II */
r_if
c_cond
(paren
id|self-&gt;disconnect_pending
)paren
(brace
multiline_comment|/* Disconnect */
id|irlap_send_rd_frame
c_func
(paren
id|self
)paren
suffix:semicolon
id|irlap_flush_all_queues
c_func
(paren
id|self
)paren
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_SCLOSE
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Just send back pf bit */
id|irlap_send_rr_frame
c_func
(paren
id|self
comma
id|RSP_FRAME
)paren
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NRM_S
)paren
suffix:semicolon
)brace
)brace
)brace
r_else
r_if
c_cond
(paren
id|nr_status
op_eq
id|NR_UNEXPECTED
)paren
(brace
id|self-&gt;remote_busy
op_assign
id|FALSE
suffix:semicolon
id|irlap_update_nr_received
c_func
(paren
id|self
comma
id|info-&gt;nr
)paren
suffix:semicolon
id|irlap_resend_rejected_frames
c_func
(paren
id|self
comma
id|RSP_FRAME
)paren
suffix:semicolon
id|irlap_start_wd_timer
c_func
(paren
id|self
comma
id|self-&gt;wd_timeout
)paren
suffix:semicolon
multiline_comment|/* Keep state */
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NRM_S
)paren
suffix:semicolon
)brace
r_else
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;%s(), invalid nr not implemented!&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|RECV_SNRM_CMD
suffix:colon
multiline_comment|/* SNRM frame is not allowed to contain an I-field */
r_if
c_cond
(paren
op_logical_neg
id|info
)paren
(brace
id|del_timer
c_func
(paren
op_amp
id|self-&gt;wd_timer
)paren
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;%s(), received SNRM cmd&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_RESET_CHECK
)paren
suffix:semicolon
id|irlap_reset_indication
c_func
(paren
id|self
)paren
suffix:semicolon
)brace
r_else
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
l_string|&quot;%s(), SNRM frame contained an I-field!&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|RECV_REJ_CMD
suffix:colon
id|irlap_update_nr_received
c_func
(paren
id|self
comma
id|info-&gt;nr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|self-&gt;remote_busy
)paren
(brace
id|irlap_wait_min_turn_around
c_func
(paren
id|self
comma
op_amp
id|self-&gt;qos_tx
)paren
suffix:semicolon
id|irlap_send_rr_frame
c_func
(paren
id|self
comma
id|CMD_FRAME
)paren
suffix:semicolon
)brace
r_else
id|irlap_resend_rejected_frames
c_func
(paren
id|self
comma
id|CMD_FRAME
)paren
suffix:semicolon
id|irlap_start_wd_timer
c_func
(paren
id|self
comma
id|self-&gt;wd_timeout
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RECV_SREJ_CMD
suffix:colon
id|irlap_update_nr_received
c_func
(paren
id|self
comma
id|info-&gt;nr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|self-&gt;remote_busy
)paren
(brace
id|irlap_wait_min_turn_around
c_func
(paren
id|self
comma
op_amp
id|self-&gt;qos_tx
)paren
suffix:semicolon
id|irlap_send_rr_frame
c_func
(paren
id|self
comma
id|CMD_FRAME
)paren
suffix:semicolon
)brace
r_else
id|irlap_resend_rejected_frame
c_func
(paren
id|self
comma
id|CMD_FRAME
)paren
suffix:semicolon
id|irlap_start_wd_timer
c_func
(paren
id|self
comma
id|self-&gt;wd_timeout
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|WD_TIMER_EXPIRED
suffix:colon
multiline_comment|/*&n;&t;&t; *  Wait until retry_count * n matches negotiated threshold/&n;&t;&t; *  disconnect time (note 2 in IrLAP p. 82)&n;&t;&t; *&n;&t;&t; * Similar to irlap_state_nrm_p() -&gt; FINAL_TIMER_EXPIRED&n;&t;&t; * Note : self-&gt;wd_timeout = (self-&gt;final_timeout * 2),&n;&t;&t; *   which explain why we use (self-&gt;N2 / 2) here !!!&n;&t;&t; * Jean II&n;&t;&t; */
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;%s(), retry_count = %d&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|self-&gt;retry_count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|self-&gt;retry_count
OL
(paren
id|self-&gt;N2
op_div
l_int|2
)paren
)paren
(brace
multiline_comment|/* No retry, just wait for primary */
id|irlap_start_wd_timer
c_func
(paren
id|self
comma
id|self-&gt;wd_timeout
)paren
suffix:semicolon
id|self-&gt;retry_count
op_increment
suffix:semicolon
r_if
c_cond
(paren
(paren
id|self-&gt;retry_count
op_mod
(paren
id|self-&gt;N1
op_div
l_int|2
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|irlap_status_indication
c_func
(paren
id|self
comma
id|STATUS_NO_ACTIVITY
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|irlap_apply_default_connection_parameters
c_func
(paren
id|self
)paren
suffix:semicolon
multiline_comment|/* Always switch state before calling upper layers */
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NDM
)paren
suffix:semicolon
id|irlap_disconnect_indication
c_func
(paren
id|self
comma
id|LAP_NO_RESPONSE
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|RECV_DISC_CMD
suffix:colon
multiline_comment|/* Always switch state before calling upper layers */
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NDM
)paren
suffix:semicolon
multiline_comment|/* Send disconnect response */
id|irlap_wait_min_turn_around
c_func
(paren
id|self
comma
op_amp
id|self-&gt;qos_tx
)paren
suffix:semicolon
id|irlap_send_ua_response_frame
c_func
(paren
id|self
comma
l_int|NULL
)paren
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|self-&gt;wd_timer
)paren
suffix:semicolon
id|irlap_flush_all_queues
c_func
(paren
id|self
)paren
suffix:semicolon
multiline_comment|/* Set default link parameters */
id|irlap_apply_default_connection_parameters
c_func
(paren
id|self
)paren
suffix:semicolon
id|irlap_disconnect_indication
c_func
(paren
id|self
comma
id|LAP_DISC_INDICATION
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RECV_DISCOVERY_XID_CMD
suffix:colon
id|irlap_wait_min_turn_around
c_func
(paren
id|self
comma
op_amp
id|self-&gt;qos_tx
)paren
suffix:semicolon
id|irlap_send_rr_frame
c_func
(paren
id|self
comma
id|RSP_FRAME
)paren
suffix:semicolon
id|self-&gt;ack_required
op_assign
id|TRUE
suffix:semicolon
id|irlap_start_wd_timer
c_func
(paren
id|self
comma
id|self-&gt;wd_timeout
)paren
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NRM_S
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RECV_TEST_CMD
suffix:colon
multiline_comment|/* Remove test frame header (only LAP header in NRM) */
id|skb_pull
c_func
(paren
id|skb
comma
id|LAP_ADDR_HEADER
op_plus
id|LAP_CTRL_HEADER
)paren
suffix:semicolon
id|irlap_wait_min_turn_around
c_func
(paren
id|self
comma
op_amp
id|self-&gt;qos_tx
)paren
suffix:semicolon
id|irlap_start_wd_timer
c_func
(paren
id|self
comma
id|self-&gt;wd_timeout
)paren
suffix:semicolon
multiline_comment|/* Send response (info will be copied) */
id|irlap_send_test_frame
c_func
(paren
id|self
comma
id|self-&gt;caddr
comma
id|info-&gt;daddr
comma
id|skb
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;%s(), Unknown event %d, (%s)&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|event
comma
id|irlap_event
(braket
id|event
)braket
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irlap_state_sclose (self, event, skb, info)&n; */
DECL|function|irlap_state_sclose
r_static
r_int
id|irlap_state_sclose
c_func
(paren
r_struct
id|irlap_cb
op_star
id|self
comma
id|IRLAP_EVENT
id|event
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|irlap_info
op_star
id|info
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;%s()&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
op_minus
id|ENODEV
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|LAP_MAGIC
comma
r_return
op_minus
id|EBADR
suffix:semicolon
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|event
)paren
(brace
r_case
id|RECV_DISC_CMD
suffix:colon
multiline_comment|/* Always switch state before calling upper layers */
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NDM
)paren
suffix:semicolon
multiline_comment|/* Send disconnect response */
id|irlap_wait_min_turn_around
c_func
(paren
id|self
comma
op_amp
id|self-&gt;qos_tx
)paren
suffix:semicolon
id|irlap_send_ua_response_frame
c_func
(paren
id|self
comma
l_int|NULL
)paren
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|self-&gt;wd_timer
)paren
suffix:semicolon
multiline_comment|/* Set default link parameters */
id|irlap_apply_default_connection_parameters
c_func
(paren
id|self
)paren
suffix:semicolon
id|irlap_disconnect_indication
c_func
(paren
id|self
comma
id|LAP_DISC_INDICATION
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RECV_DM_RSP
suffix:colon
multiline_comment|/* Always switch state before calling upper layers */
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NDM
)paren
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|self-&gt;wd_timer
)paren
suffix:semicolon
id|irlap_apply_default_connection_parameters
c_func
(paren
id|self
)paren
suffix:semicolon
id|irlap_disconnect_indication
c_func
(paren
id|self
comma
id|LAP_DISC_INDICATION
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|WD_TIMER_EXPIRED
suffix:colon
multiline_comment|/* Always switch state before calling upper layers */
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NDM
)paren
suffix:semicolon
id|irlap_apply_default_connection_parameters
c_func
(paren
id|self
)paren
suffix:semicolon
id|irlap_disconnect_indication
c_func
(paren
id|self
comma
id|LAP_DISC_INDICATION
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;%s(), Unknown event %d, (%s)&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|event
comma
id|irlap_event
(braket
id|event
)braket
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
DECL|function|irlap_state_reset_check
r_static
r_int
id|irlap_state_reset_check
c_func
(paren
r_struct
id|irlap_cb
op_star
id|self
comma
id|IRLAP_EVENT
id|event
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|irlap_info
op_star
id|info
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;%s(), event=%s&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|irlap_event
(braket
id|event
)braket
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
op_minus
id|ENODEV
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|LAP_MAGIC
comma
r_return
op_minus
id|EBADR
suffix:semicolon
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|event
)paren
(brace
r_case
id|RESET_RESPONSE
suffix:colon
id|irlap_send_ua_response_frame
c_func
(paren
id|self
comma
op_amp
id|self-&gt;qos_rx
)paren
suffix:semicolon
id|irlap_initiate_connection_state
c_func
(paren
id|self
)paren
suffix:semicolon
id|irlap_start_wd_timer
c_func
(paren
id|self
comma
id|WD_TIMEOUT
)paren
suffix:semicolon
id|irlap_flush_all_queues
c_func
(paren
id|self
)paren
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NRM_S
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DISCONNECT_REQUEST
suffix:colon
id|irlap_wait_min_turn_around
c_func
(paren
id|self
comma
op_amp
id|self-&gt;qos_tx
)paren
suffix:semicolon
id|irlap_send_rd_frame
c_func
(paren
id|self
)paren
suffix:semicolon
id|irlap_start_wd_timer
c_func
(paren
id|self
comma
id|WD_TIMEOUT
)paren
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_SCLOSE
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;%s(), Unknown event %d, (%s)&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|event
comma
id|irlap_event
(braket
id|event
)braket
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
eof
