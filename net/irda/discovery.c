multiline_comment|/*********************************************************************&n; *                &n; * Filename:      discovery.c&n; * Version:       0.1&n; * Description:   Routines for handling discoveries at the IrLMP layer&n; * Status:        Experimental.&n; * Author:        Dag Brattli &lt;dagb@cs.uit.no&gt;&n; * Created at:    Tue Apr  6 15:33:50 1999&n; * Modified at:   Sat Oct  9 17:11:31 1999&n; * Modified by:   Dag Brattli &lt;dagb@cs.uit.no&gt;&n; * Modified at:   Fri May 28  3:11 CST 1999&n; * Modified by:   Horst von Brand &lt;vonbrand@sleipnir.valparaiso.cl&gt;&n; * &n; *     Copyright (c) 1999 Dag Brattli, All Rights Reserved.&n; *     &n; *     This program is free software; you can redistribute it and/or &n; *     modify it under the terms of the GNU General Public License as &n; *     published by the Free Software Foundation; either version 2 of &n; *     the License, or (at your option) any later version.&n; * &n; *     This program is distributed in the hope that it will be useful,&n; *     but WITHOUT ANY WARRANTY; without even the implied warranty of&n; *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the&n; *     GNU General Public License for more details.&n; * &n; *     You should have received a copy of the GNU General Public License &n; *     along with this program; if not, write to the Free Software &n; *     Foundation, Inc., 59 Temple Place, Suite 330, Boston, &n; *     MA 02111-1307 USA&n; *     &n; ********************************************************************/
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/socket.h&gt;
macro_line|#include &lt;linux/seq_file.h&gt;
macro_line|#include &lt;net/irda/irda.h&gt;
macro_line|#include &lt;net/irda/irlmp.h&gt;
macro_line|#include &lt;net/irda/discovery.h&gt;
multiline_comment|/*&n; * Function irlmp_add_discovery (cachelog, discovery)&n; *&n; *    Add a new discovery to the cachelog, and remove any old discoveries&n; *    from the same device&n; *&n; * Note : we try to preserve the time this device was *first* discovered&n; * (as opposed to the time of last discovery used for cleanup). This is&n; * used by clients waiting for discovery events to tell if the device&n; * discovered is &quot;new&quot; or just the same old one. They can&squot;t rely there&n; * on a binary flag (new/old), because not all discovery events are&n; * propagated to them, and they might not always listen, so they would&n; * miss some new devices popping up...&n; * Jean II&n; */
DECL|function|irlmp_add_discovery
r_void
id|irlmp_add_discovery
c_func
(paren
id|hashbin_t
op_star
id|cachelog
comma
id|discovery_t
op_star
r_new
)paren
(brace
id|discovery_t
op_star
id|discovery
comma
op_star
id|node
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/* Set time of first discovery if node is new (see below) */
r_new
op_member_access_from_pointer
id|firststamp
op_assign
r_new
op_member_access_from_pointer
id|timestamp
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|cachelog-&gt;hb_spinlock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * Remove all discoveries of devices that has previously been &n;&t; * discovered on the same link with the same name (info), or the &n;&t; * same daddr. We do this since some devices (mostly PDAs) change&n;&t; * their device address between every discovery.&n;&t; */
id|discovery
op_assign
(paren
id|discovery_t
op_star
)paren
id|hashbin_get_first
c_func
(paren
id|cachelog
)paren
suffix:semicolon
r_while
c_loop
(paren
id|discovery
op_ne
l_int|NULL
)paren
(brace
id|node
op_assign
id|discovery
suffix:semicolon
multiline_comment|/* Be sure to stay one item ahead */
id|discovery
op_assign
(paren
id|discovery_t
op_star
)paren
id|hashbin_get_next
c_func
(paren
id|cachelog
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|node-&gt;data.saddr
op_eq
r_new
op_member_access_from_pointer
id|data.saddr
)paren
op_logical_and
(paren
(paren
id|node-&gt;data.daddr
op_eq
r_new
op_member_access_from_pointer
id|data.daddr
)paren
op_logical_or
(paren
id|strcmp
c_func
(paren
id|node-&gt;data.info
comma
r_new
op_member_access_from_pointer
id|data.info
)paren
op_eq
l_int|0
)paren
)paren
)paren
(brace
multiline_comment|/* This discovery is a previous discovery &n;&t;&t;&t; * from the same device, so just remove it&n;&t;&t;&t; */
id|hashbin_remove_this
c_func
(paren
id|cachelog
comma
(paren
id|irda_queue_t
op_star
)paren
id|node
)paren
suffix:semicolon
multiline_comment|/* Check if hints bits are unchanged */
r_if
c_cond
(paren
id|u16ho
c_func
(paren
id|node-&gt;data.hints
)paren
op_eq
id|u16ho
c_func
(paren
r_new
op_member_access_from_pointer
id|data.hints
)paren
)paren
(brace
multiline_comment|/* Set time of first discovery for this node */
r_new
op_member_access_from_pointer
id|firststamp
op_assign
id|node-&gt;firststamp
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|node
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Insert the new and updated version */
id|hashbin_insert
c_func
(paren
id|cachelog
comma
(paren
id|irda_queue_t
op_star
)paren
r_new
comma
r_new
op_member_access_from_pointer
id|data.daddr
comma
l_int|NULL
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|cachelog-&gt;hb_spinlock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irlmp_add_discovery_log (cachelog, log)&n; *&n; *    Merge a disovery log into the cachelog.&n; *&n; */
DECL|function|irlmp_add_discovery_log
r_void
id|irlmp_add_discovery_log
c_func
(paren
id|hashbin_t
op_star
id|cachelog
comma
id|hashbin_t
op_star
id|log
)paren
(brace
id|discovery_t
op_star
id|discovery
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|4
comma
l_string|&quot;%s()&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  If log is missing this means that IrLAP was unable to perform the&n;&t; *  discovery, so restart discovery again with just the half timeout&n;&t; *  of the normal one.&n;&t; */
multiline_comment|/* Well... It means that there was nobody out there - Jean II */
r_if
c_cond
(paren
id|log
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* irlmp_start_discovery_timer(irlmp, 150); */
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Locking : we are the only owner of this discovery log, so&n;&t; * no need to lock it.&n;&t; * We just need to lock the global log in irlmp_add_discovery().&n;&t; */
id|discovery
op_assign
(paren
id|discovery_t
op_star
)paren
id|hashbin_remove_first
c_func
(paren
id|log
)paren
suffix:semicolon
r_while
c_loop
(paren
id|discovery
op_ne
l_int|NULL
)paren
(brace
id|irlmp_add_discovery
c_func
(paren
id|cachelog
comma
id|discovery
)paren
suffix:semicolon
id|discovery
op_assign
(paren
id|discovery_t
op_star
)paren
id|hashbin_remove_first
c_func
(paren
id|log
)paren
suffix:semicolon
)brace
multiline_comment|/* Delete the now empty log */
id|hashbin_delete
c_func
(paren
id|log
comma
(paren
id|FREE_FUNC
)paren
id|kfree
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irlmp_expire_discoveries (log, saddr, force)&n; *&n; *    Go through all discoveries and expire all that has stayed too long&n; *&n; * Note : this assume that IrLAP won&squot;t change its saddr, which&n; * currently is a valid assumption...&n; */
DECL|function|irlmp_expire_discoveries
r_void
id|irlmp_expire_discoveries
c_func
(paren
id|hashbin_t
op_star
id|log
comma
id|__u32
id|saddr
comma
r_int
id|force
)paren
(brace
id|discovery_t
op_star
id|discovery
suffix:semicolon
id|discovery_t
op_star
id|curr
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|discinfo_t
op_star
id|buffer
op_assign
l_int|NULL
suffix:semicolon
r_int
id|n
suffix:semicolon
multiline_comment|/* Size of the full log */
r_int
id|i
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* How many we expired */
id|ASSERT
c_func
(paren
id|log
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|4
comma
l_string|&quot;%s()&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|log-&gt;hb_spinlock
comma
id|flags
)paren
suffix:semicolon
id|discovery
op_assign
(paren
id|discovery_t
op_star
)paren
id|hashbin_get_first
c_func
(paren
id|log
)paren
suffix:semicolon
r_while
c_loop
(paren
id|discovery
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* Be sure to be one item ahead */
id|curr
op_assign
id|discovery
suffix:semicolon
id|discovery
op_assign
(paren
id|discovery_t
op_star
)paren
id|hashbin_get_next
c_func
(paren
id|log
)paren
suffix:semicolon
multiline_comment|/* Test if it&squot;s time to expire this discovery */
r_if
c_cond
(paren
(paren
id|curr-&gt;data.saddr
op_eq
id|saddr
)paren
op_logical_and
(paren
id|force
op_logical_or
(paren
(paren
id|jiffies
op_minus
id|curr-&gt;timestamp
)paren
OG
id|DISCOVERY_EXPIRE_TIMEOUT
)paren
)paren
)paren
(brace
multiline_comment|/* Create buffer as needed.&n;&t;&t;&t; * As this function get called a lot and most time&n;&t;&t;&t; * we don&squot;t have anything to put in the log (we are&n;&t;&t;&t; * quite picky), we can save a lot of overhead&n;&t;&t;&t; * by not calling kmalloc. Jean II */
r_if
c_cond
(paren
id|buffer
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* Create the client specific buffer */
id|n
op_assign
id|HASHBIN_GET_SIZE
c_func
(paren
id|log
)paren
suffix:semicolon
id|buffer
op_assign
id|kmalloc
c_func
(paren
id|n
op_star
r_sizeof
(paren
r_struct
id|irda_device_info
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buffer
op_eq
l_int|NULL
)paren
(brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|log-&gt;hb_spinlock
comma
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
multiline_comment|/* Copy discovery information */
id|memcpy
c_func
(paren
op_amp
(paren
id|buffer
(braket
id|i
)braket
)paren
comma
op_amp
(paren
id|curr-&gt;data
)paren
comma
r_sizeof
(paren
id|discinfo_t
)paren
)paren
suffix:semicolon
id|i
op_increment
suffix:semicolon
multiline_comment|/* Remove it from the log */
id|curr
op_assign
id|hashbin_remove_this
c_func
(paren
id|log
comma
(paren
id|irda_queue_t
op_star
)paren
id|curr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|curr
)paren
id|kfree
c_func
(paren
id|curr
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Drop the spinlock before calling the higher layers, as&n;&t; * we can&squot;t guarantee they won&squot;t call us back and create a&n;&t; * deadlock. We will work on our own private data, so we&n;&t; * don&squot;t care to be interupted. - Jean II */
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|log-&gt;hb_spinlock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buffer
op_eq
l_int|NULL
)paren
(brace
r_return
suffix:semicolon
)brace
multiline_comment|/* Tell IrLMP and registered clients about it */
id|irlmp_discovery_expiry
c_func
(paren
id|buffer
comma
id|i
)paren
suffix:semicolon
multiline_comment|/* Free up our buffer */
id|kfree
c_func
(paren
id|buffer
)paren
suffix:semicolon
)brace
macro_line|#if 0
multiline_comment|/*&n; * Function irlmp_dump_discoveries (log)&n; *&n; *    Print out all discoveries in log&n; *&n; */
r_void
id|irlmp_dump_discoveries
c_func
(paren
id|hashbin_t
op_star
id|log
)paren
(brace
id|discovery_t
op_star
id|discovery
suffix:semicolon
id|ASSERT
c_func
(paren
id|log
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|discovery
op_assign
(paren
id|discovery_t
op_star
)paren
id|hashbin_get_first
c_func
(paren
id|log
)paren
suffix:semicolon
r_while
c_loop
(paren
id|discovery
op_ne
l_int|NULL
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
l_string|&quot;Discovery:&bslash;n&quot;
)paren
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
l_string|&quot;  daddr=%08x&bslash;n&quot;
comma
id|discovery-&gt;data.daddr
)paren
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
l_string|&quot;  saddr=%08x&bslash;n&quot;
comma
id|discovery-&gt;data.saddr
)paren
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
l_string|&quot;  nickname=%s&bslash;n&quot;
comma
id|discovery-&gt;data.info
)paren
suffix:semicolon
id|discovery
op_assign
(paren
id|discovery_t
op_star
)paren
id|hashbin_get_next
c_func
(paren
id|log
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
multiline_comment|/*&n; * Function irlmp_copy_discoveries (log, pn, mask)&n; *&n; *    Copy all discoveries in a buffer&n; *&n; * This function implement a safe way for lmp clients to access the&n; * discovery log. The basic problem is that we don&squot;t want the log&n; * to change (add/remove) while the client is reading it. If the&n; * lmp client manipulate directly the hashbin, he is sure to get&n; * into troubles...&n; * The idea is that we copy all the current discovery log in a buffer&n; * which is specific to the client and pass this copy to him. As we&n; * do this operation with the spinlock grabbed, we are safe...&n; * Note : we don&squot;t want those clients to grab the spinlock, because&n; * we have no control on how long they will hold it...&n; * Note : we choose to copy the log in &quot;struct irda_device_info&quot; to&n; * save space...&n; * Note : the client must kfree himself() the log...&n; * Jean II&n; */
DECL|function|irlmp_copy_discoveries
r_struct
id|irda_device_info
op_star
id|irlmp_copy_discoveries
c_func
(paren
id|hashbin_t
op_star
id|log
comma
r_int
op_star
id|pn
comma
id|__u16
id|mask
comma
r_int
id|old_entries
)paren
(brace
id|discovery_t
op_star
id|discovery
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|discinfo_t
op_star
id|buffer
op_assign
l_int|NULL
suffix:semicolon
r_int
id|j_timeout
op_assign
(paren
id|sysctl_discovery_timeout
op_star
id|HZ
)paren
suffix:semicolon
r_int
id|n
suffix:semicolon
multiline_comment|/* Size of the full log */
r_int
id|i
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* How many we picked */
id|ASSERT
c_func
(paren
id|pn
op_ne
l_int|NULL
comma
r_return
l_int|NULL
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|log
op_ne
l_int|NULL
comma
r_return
l_int|NULL
suffix:semicolon
)paren
suffix:semicolon
multiline_comment|/* Save spin lock */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|log-&gt;hb_spinlock
comma
id|flags
)paren
suffix:semicolon
id|discovery
op_assign
(paren
id|discovery_t
op_star
)paren
id|hashbin_get_first
c_func
(paren
id|log
)paren
suffix:semicolon
r_while
c_loop
(paren
id|discovery
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* Mask out the ones we don&squot;t want :&n;&t;&t; * We want to match the discovery mask, and to get only&n;&t;&t; * the most recent one (unless we want old ones) */
r_if
c_cond
(paren
(paren
id|u16ho
c_func
(paren
id|discovery-&gt;data.hints
)paren
op_amp
id|mask
)paren
op_logical_and
(paren
(paren
id|old_entries
)paren
op_logical_or
(paren
(paren
id|jiffies
op_minus
id|discovery-&gt;firststamp
)paren
OL
id|j_timeout
)paren
)paren
)paren
(brace
multiline_comment|/* Create buffer as needed.&n;&t;&t;&t; * As this function get called a lot and most time&n;&t;&t;&t; * we don&squot;t have anything to put in the log (we are&n;&t;&t;&t; * quite picky), we can save a lot of overhead&n;&t;&t;&t; * by not calling kmalloc. Jean II */
r_if
c_cond
(paren
id|buffer
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* Create the client specific buffer */
id|n
op_assign
id|HASHBIN_GET_SIZE
c_func
(paren
id|log
)paren
suffix:semicolon
id|buffer
op_assign
id|kmalloc
c_func
(paren
id|n
op_star
r_sizeof
(paren
r_struct
id|irda_device_info
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buffer
op_eq
l_int|NULL
)paren
(brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|log-&gt;hb_spinlock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
)brace
multiline_comment|/* Copy discovery information */
id|memcpy
c_func
(paren
op_amp
(paren
id|buffer
(braket
id|i
)braket
)paren
comma
op_amp
(paren
id|discovery-&gt;data
)paren
comma
r_sizeof
(paren
id|discinfo_t
)paren
)paren
suffix:semicolon
id|i
op_increment
suffix:semicolon
)brace
id|discovery
op_assign
(paren
id|discovery_t
op_star
)paren
id|hashbin_get_next
c_func
(paren
id|log
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|log-&gt;hb_spinlock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* Get the actual number of device in the buffer and return */
op_star
id|pn
op_assign
id|i
suffix:semicolon
r_return
id|buffer
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_PROC_FS
DECL|function|discovery_seq_idx
r_static
r_inline
id|discovery_t
op_star
id|discovery_seq_idx
c_func
(paren
id|loff_t
id|pos
)paren
(brace
id|discovery_t
op_star
id|discovery
suffix:semicolon
r_for
c_loop
(paren
id|discovery
op_assign
(paren
id|discovery_t
op_star
)paren
id|hashbin_get_first
c_func
(paren
id|irlmp-&gt;cachelog
)paren
suffix:semicolon
id|discovery
op_ne
l_int|NULL
suffix:semicolon
id|discovery
op_assign
(paren
id|discovery_t
op_star
)paren
id|hashbin_get_next
c_func
(paren
id|irlmp-&gt;cachelog
)paren
)paren
(brace
r_if
c_cond
(paren
id|pos
op_decrement
op_eq
l_int|0
)paren
r_break
suffix:semicolon
)brace
r_return
id|discovery
suffix:semicolon
)brace
DECL|function|discovery_seq_start
r_static
r_void
op_star
id|discovery_seq_start
c_func
(paren
r_struct
id|seq_file
op_star
id|seq
comma
id|loff_t
op_star
id|pos
)paren
(brace
id|spin_lock_irq
c_func
(paren
op_amp
id|irlmp-&gt;cachelog-&gt;hb_spinlock
)paren
suffix:semicolon
r_return
op_star
id|pos
ques
c_cond
id|discovery_seq_idx
c_func
(paren
op_star
id|pos
op_minus
l_int|1
)paren
suffix:colon
id|SEQ_START_TOKEN
suffix:semicolon
)brace
DECL|function|discovery_seq_next
r_static
r_void
op_star
id|discovery_seq_next
c_func
(paren
r_struct
id|seq_file
op_star
id|seq
comma
r_void
op_star
id|v
comma
id|loff_t
op_star
id|pos
)paren
(brace
op_increment
op_star
id|pos
suffix:semicolon
r_return
(paren
id|v
op_eq
id|SEQ_START_TOKEN
)paren
ques
c_cond
(paren
r_void
op_star
)paren
id|hashbin_get_first
c_func
(paren
id|irlmp-&gt;cachelog
)paren
suffix:colon
(paren
r_void
op_star
)paren
id|hashbin_get_next
c_func
(paren
id|irlmp-&gt;cachelog
)paren
suffix:semicolon
)brace
DECL|function|discovery_seq_stop
r_static
r_void
id|discovery_seq_stop
c_func
(paren
r_struct
id|seq_file
op_star
id|seq
comma
r_void
op_star
id|v
)paren
(brace
id|spin_unlock_irq
c_func
(paren
op_amp
id|irlmp-&gt;cachelog-&gt;hb_spinlock
)paren
suffix:semicolon
)brace
DECL|function|discovery_seq_show
r_static
r_int
id|discovery_seq_show
c_func
(paren
r_struct
id|seq_file
op_star
id|seq
comma
r_void
op_star
id|v
)paren
(brace
r_if
c_cond
(paren
id|v
op_eq
id|SEQ_START_TOKEN
)paren
id|seq_puts
c_func
(paren
id|seq
comma
l_string|&quot;IrLMP: Discovery log:&bslash;n&bslash;n&quot;
)paren
suffix:semicolon
r_else
(brace
r_const
id|discovery_t
op_star
id|discovery
op_assign
id|v
suffix:semicolon
id|seq_printf
c_func
(paren
id|seq
comma
l_string|&quot;nickname: %s, hint: 0x%02x%02x&quot;
comma
id|discovery-&gt;data.info
comma
id|discovery-&gt;data.hints
(braket
l_int|0
)braket
comma
id|discovery-&gt;data.hints
(braket
l_int|1
)braket
)paren
suffix:semicolon
macro_line|#if 0
r_if
c_cond
(paren
id|discovery-&gt;data.hints
(braket
l_int|0
)braket
op_amp
id|HINT_PNP
)paren
id|seq_puts
c_func
(paren
id|seq
comma
l_string|&quot;PnP Compatible &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|discovery-&gt;data.hints
(braket
l_int|0
)braket
op_amp
id|HINT_PDA
)paren
id|seq_puts
c_func
(paren
id|seq
comma
l_string|&quot;PDA/Palmtop &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|discovery-&gt;data.hints
(braket
l_int|0
)braket
op_amp
id|HINT_COMPUTER
)paren
id|seq_puts
c_func
(paren
id|seq
comma
l_string|&quot;Computer &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|discovery-&gt;data.hints
(braket
l_int|0
)braket
op_amp
id|HINT_PRINTER
)paren
id|seq_puts
c_func
(paren
id|seq
comma
l_string|&quot;Printer &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|discovery-&gt;data.hints
(braket
l_int|0
)braket
op_amp
id|HINT_MODEM
)paren
id|seq_puts
c_func
(paren
id|seq
comma
l_string|&quot;Modem &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|discovery-&gt;data.hints
(braket
l_int|0
)braket
op_amp
id|HINT_FAX
)paren
id|seq_puts
c_func
(paren
id|seq
comma
l_string|&quot;Fax &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|discovery-&gt;data.hints
(braket
l_int|0
)braket
op_amp
id|HINT_LAN
)paren
id|seq_puts
c_func
(paren
id|seq
comma
l_string|&quot;LAN Access &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|discovery-&gt;data.hints
(braket
l_int|1
)braket
op_amp
id|HINT_TELEPHONY
)paren
id|seq_puts
c_func
(paren
id|seq
comma
l_string|&quot;Telephony &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|discovery-&gt;data.hints
(braket
l_int|1
)braket
op_amp
id|HINT_FILE_SERVER
)paren
id|seq_puts
c_func
(paren
id|seq
comma
l_string|&quot;File Server &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|discovery-&gt;data.hints
(braket
l_int|1
)braket
op_amp
id|HINT_COMM
)paren
id|seq_puts
c_func
(paren
id|seq
comma
l_string|&quot;IrCOMM &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|discovery-&gt;data.hints
(braket
l_int|1
)braket
op_amp
id|HINT_OBEX
)paren
id|seq_puts
c_func
(paren
id|seq
comma
l_string|&quot;IrOBEX &quot;
)paren
suffix:semicolon
macro_line|#endif&t;&t;
id|seq_printf
c_func
(paren
id|seq
comma
l_string|&quot;, saddr: 0x%08x, daddr: 0x%08x&bslash;n&bslash;n&quot;
comma
id|discovery-&gt;data.saddr
comma
id|discovery-&gt;data.daddr
)paren
suffix:semicolon
id|seq_putc
c_func
(paren
id|seq
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|discovery_seq_ops
r_static
r_struct
id|seq_operations
id|discovery_seq_ops
op_assign
(brace
dot
id|start
op_assign
id|discovery_seq_start
comma
dot
id|next
op_assign
id|discovery_seq_next
comma
dot
id|stop
op_assign
id|discovery_seq_stop
comma
dot
id|show
op_assign
id|discovery_seq_show
comma
)brace
suffix:semicolon
DECL|function|discovery_seq_open
r_static
r_int
id|discovery_seq_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
id|ASSERT
c_func
(paren
id|irlmp
op_ne
l_int|NULL
comma
r_return
op_minus
id|EINVAL
suffix:semicolon
)paren
suffix:semicolon
r_return
id|seq_open
c_func
(paren
id|file
comma
op_amp
id|discovery_seq_ops
)paren
suffix:semicolon
)brace
DECL|variable|discovery_seq_fops
r_struct
id|file_operations
id|discovery_seq_fops
op_assign
(brace
dot
id|owner
op_assign
id|THIS_MODULE
comma
dot
id|open
op_assign
id|discovery_seq_open
comma
dot
id|read
op_assign
id|seq_read
comma
dot
id|llseek
op_assign
id|seq_lseek
comma
dot
id|release
op_assign
id|seq_release
comma
)brace
suffix:semicolon
macro_line|#endif
eof
