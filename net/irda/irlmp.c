multiline_comment|/*********************************************************************&n; *&n; * Filename:      irlmp.c&n; * Version:       1.0&n; * Description:   IrDA Link Management Protocol (LMP) layer&n; * Status:        Stable.&n; * Author:        Dag Brattli &lt;dagb@cs.uit.no&gt;&n; * Created at:    Sun Aug 17 20:54:32 1997&n; * Modified at:   Wed Jan  5 11:26:03 2000&n; * Modified by:   Dag Brattli &lt;dagb@cs.uit.no&gt;&n; *&n; *     Copyright (c) 1998-2000 Dag Brattli &lt;dagb@cs.uit.no&gt;,&n; *     All Rights Reserved.&n; *     Copyright (c) 2000-2003 Jean Tourrilhes &lt;jt@hpl.hp.com&gt;&n; *&n; *     This program is free software; you can redistribute it and/or&n; *     modify it under the terms of the GNU General Public License as&n; *     published by the Free Software Foundation; either version 2 of&n; *     the License, or (at your option) any later version.&n; *&n; *     Neither Dag Brattli nor University of Troms&#xfffd; admit liability nor&n; *     provide warranty for any of this software. This material is&n; *     provided &quot;AS-IS&quot; and at no charge.&n; *&n; ********************************************************************/
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/kmod.h&gt;
macro_line|#include &lt;linux/random.h&gt;
macro_line|#include &lt;linux/seq_file.h&gt;
macro_line|#include &lt;net/irda/irda.h&gt;
macro_line|#include &lt;net/irda/timer.h&gt;
macro_line|#include &lt;net/irda/qos.h&gt;
macro_line|#include &lt;net/irda/irlap.h&gt;
macro_line|#include &lt;net/irda/iriap.h&gt;
macro_line|#include &lt;net/irda/irlmp.h&gt;
macro_line|#include &lt;net/irda/irlmp_frame.h&gt;
r_static
id|__u8
id|irlmp_find_free_slsap
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|irlmp_slsap_inuse
c_func
(paren
id|__u8
id|slsap_sel
)paren
suffix:semicolon
multiline_comment|/* Master structure */
DECL|variable|irlmp
r_struct
id|irlmp_cb
op_star
id|irlmp
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* These can be altered by the sysctl interface */
DECL|variable|sysctl_discovery
r_int
id|sysctl_discovery
op_assign
l_int|0
suffix:semicolon
DECL|variable|sysctl_discovery_timeout
r_int
id|sysctl_discovery_timeout
op_assign
l_int|3
suffix:semicolon
multiline_comment|/* 3 seconds by default */
DECL|variable|sysctl_discovery_timeout
id|EXPORT_SYMBOL
c_func
(paren
id|sysctl_discovery_timeout
)paren
suffix:semicolon
DECL|variable|sysctl_discovery_slots
r_int
id|sysctl_discovery_slots
op_assign
l_int|6
suffix:semicolon
multiline_comment|/* 6 slots by default */
DECL|variable|sysctl_lap_keepalive_time
r_int
id|sysctl_lap_keepalive_time
op_assign
id|LM_IDLE_TIMEOUT
op_star
l_int|1000
op_div
id|HZ
suffix:semicolon
DECL|variable|sysctl_devname
r_char
id|sysctl_devname
(braket
l_int|65
)braket
suffix:semicolon
DECL|variable|irlmp_reasons
r_const
r_char
op_star
id|irlmp_reasons
(braket
)braket
op_assign
(brace
l_string|&quot;ERROR, NOT USED&quot;
comma
l_string|&quot;LM_USER_REQUEST&quot;
comma
l_string|&quot;LM_LAP_DISCONNECT&quot;
comma
l_string|&quot;LM_CONNECT_FAILURE&quot;
comma
l_string|&quot;LM_LAP_RESET&quot;
comma
l_string|&quot;LM_INIT_DISCONNECT&quot;
comma
l_string|&quot;ERROR, NOT USED&quot;
comma
)brace
suffix:semicolon
DECL|variable|irlmp_reasons
id|EXPORT_SYMBOL
c_func
(paren
id|irlmp_reasons
)paren
suffix:semicolon
multiline_comment|/*&n; * Function irlmp_init (void)&n; *&n; *    Create (allocate) the main IrLMP structure&n; *&n; */
DECL|function|irlmp_init
r_int
id|__init
id|irlmp_init
c_func
(paren
r_void
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;%s()&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
multiline_comment|/* Initialize the irlmp structure. */
id|irlmp
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|irlmp_cb
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|irlmp
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|memset
c_func
(paren
id|irlmp
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|irlmp_cb
)paren
)paren
suffix:semicolon
id|irlmp-&gt;magic
op_assign
id|LMP_MAGIC
suffix:semicolon
id|irlmp-&gt;clients
op_assign
id|hashbin_new
c_func
(paren
id|HB_LOCK
)paren
suffix:semicolon
id|irlmp-&gt;services
op_assign
id|hashbin_new
c_func
(paren
id|HB_LOCK
)paren
suffix:semicolon
id|irlmp-&gt;links
op_assign
id|hashbin_new
c_func
(paren
id|HB_LOCK
)paren
suffix:semicolon
id|irlmp-&gt;unconnected_lsaps
op_assign
id|hashbin_new
c_func
(paren
id|HB_LOCK
)paren
suffix:semicolon
id|irlmp-&gt;cachelog
op_assign
id|hashbin_new
c_func
(paren
id|HB_NOLOCK
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|irlmp-&gt;clients
op_eq
l_int|NULL
)paren
op_logical_or
(paren
id|irlmp-&gt;services
op_eq
l_int|NULL
)paren
op_logical_or
(paren
id|irlmp-&gt;links
op_eq
l_int|NULL
)paren
op_logical_or
(paren
id|irlmp-&gt;unconnected_lsaps
op_eq
l_int|NULL
)paren
op_logical_or
(paren
id|irlmp-&gt;cachelog
op_eq
l_int|NULL
)paren
)paren
(brace
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|spin_lock_init
c_func
(paren
op_amp
id|irlmp-&gt;cachelog-&gt;hb_spinlock
)paren
suffix:semicolon
id|irlmp-&gt;last_lsap_sel
op_assign
l_int|0x0f
suffix:semicolon
multiline_comment|/* Reserved 0x00-0x0f */
id|strcpy
c_func
(paren
id|sysctl_devname
comma
l_string|&quot;Linux&quot;
)paren
suffix:semicolon
multiline_comment|/* Do discovery every 3 seconds */
id|init_timer
c_func
(paren
op_amp
id|irlmp-&gt;discovery_timer
)paren
suffix:semicolon
id|irlmp_start_discovery_timer
c_func
(paren
id|irlmp
comma
id|sysctl_discovery_timeout
op_star
id|HZ
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irlmp_cleanup (void)&n; *&n; *    Remove IrLMP layer&n; *&n; */
DECL|function|irlmp_cleanup
r_void
id|__exit
id|irlmp_cleanup
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* Check for main structure */
id|ASSERT
c_func
(paren
id|irlmp
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|irlmp-&gt;magic
op_eq
id|LMP_MAGIC
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|irlmp-&gt;discovery_timer
)paren
suffix:semicolon
id|hashbin_delete
c_func
(paren
id|irlmp-&gt;links
comma
(paren
id|FREE_FUNC
)paren
id|kfree
)paren
suffix:semicolon
id|hashbin_delete
c_func
(paren
id|irlmp-&gt;unconnected_lsaps
comma
(paren
id|FREE_FUNC
)paren
id|kfree
)paren
suffix:semicolon
id|hashbin_delete
c_func
(paren
id|irlmp-&gt;clients
comma
(paren
id|FREE_FUNC
)paren
id|kfree
)paren
suffix:semicolon
id|hashbin_delete
c_func
(paren
id|irlmp-&gt;services
comma
(paren
id|FREE_FUNC
)paren
id|kfree
)paren
suffix:semicolon
id|hashbin_delete
c_func
(paren
id|irlmp-&gt;cachelog
comma
(paren
id|FREE_FUNC
)paren
id|kfree
)paren
suffix:semicolon
multiline_comment|/* De-allocate main structure */
id|kfree
c_func
(paren
id|irlmp
)paren
suffix:semicolon
id|irlmp
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irlmp_open_lsap (slsap, notify)&n; *&n; *   Register with IrLMP and create a local LSAP,&n; *   returns handle to LSAP.&n; */
DECL|function|irlmp_open_lsap
r_struct
id|lsap_cb
op_star
id|irlmp_open_lsap
c_func
(paren
id|__u8
id|slsap_sel
comma
id|notify_t
op_star
id|notify
comma
id|__u8
id|pid
)paren
(brace
r_struct
id|lsap_cb
op_star
id|self
suffix:semicolon
id|ASSERT
c_func
(paren
id|notify
op_ne
l_int|NULL
comma
r_return
l_int|NULL
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|irlmp
op_ne
l_int|NULL
comma
r_return
l_int|NULL
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|irlmp-&gt;magic
op_eq
id|LMP_MAGIC
comma
r_return
l_int|NULL
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|notify-&gt;instance
op_ne
l_int|NULL
comma
r_return
l_int|NULL
suffix:semicolon
)paren
suffix:semicolon
multiline_comment|/*  Does the client care which Source LSAP selector it gets?  */
r_if
c_cond
(paren
id|slsap_sel
op_eq
id|LSAP_ANY
)paren
(brace
id|slsap_sel
op_assign
id|irlmp_find_free_slsap
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|slsap_sel
)paren
r_return
l_int|NULL
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|irlmp_slsap_inuse
c_func
(paren
id|slsap_sel
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/* Allocate new instance of a LSAP connection */
id|self
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|lsap_cb
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|self
op_eq
l_int|NULL
)paren
(brace
id|ERROR
c_func
(paren
l_string|&quot;%s: can&squot;t allocate memory&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|memset
c_func
(paren
id|self
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|lsap_cb
)paren
)paren
suffix:semicolon
id|self-&gt;magic
op_assign
id|LMP_LSAP_MAGIC
suffix:semicolon
id|self-&gt;slsap_sel
op_assign
id|slsap_sel
suffix:semicolon
multiline_comment|/* Fix connectionless LSAP&squot;s */
r_if
c_cond
(paren
id|slsap_sel
op_eq
id|LSAP_CONNLESS
)paren
(brace
macro_line|#ifdef CONFIG_IRDA_ULTRA
id|self-&gt;dlsap_sel
op_assign
id|LSAP_CONNLESS
suffix:semicolon
id|self-&gt;pid
op_assign
id|pid
suffix:semicolon
macro_line|#endif /* CONFIG_IRDA_ULTRA */
)brace
r_else
id|self-&gt;dlsap_sel
op_assign
id|LSAP_ANY
suffix:semicolon
multiline_comment|/* self-&gt;connected = FALSE; -&gt; already NULL via memset() */
id|init_timer
c_func
(paren
op_amp
id|self-&gt;watchdog_timer
)paren
suffix:semicolon
id|self-&gt;notify
op_assign
op_star
id|notify
suffix:semicolon
id|self-&gt;lsap_state
op_assign
id|LSAP_DISCONNECTED
suffix:semicolon
multiline_comment|/* Insert into queue of unconnected LSAPs */
id|hashbin_insert
c_func
(paren
id|irlmp-&gt;unconnected_lsaps
comma
(paren
id|irda_queue_t
op_star
)paren
id|self
comma
(paren
r_int
)paren
id|self
comma
l_int|NULL
)paren
suffix:semicolon
r_return
id|self
suffix:semicolon
)brace
DECL|variable|irlmp_open_lsap
id|EXPORT_SYMBOL
c_func
(paren
id|irlmp_open_lsap
)paren
suffix:semicolon
multiline_comment|/*&n; * Function __irlmp_close_lsap (self)&n; *&n; *    Remove an instance of LSAP&n; */
DECL|function|__irlmp_close_lsap
r_static
r_void
id|__irlmp_close_lsap
c_func
(paren
r_struct
id|lsap_cb
op_star
id|self
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|4
comma
l_string|&quot;%s()&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|LMP_LSAP_MAGIC
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Set some of the variables to preset values&n;&t; */
id|self-&gt;magic
op_assign
l_int|0
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|self-&gt;watchdog_timer
)paren
suffix:semicolon
multiline_comment|/* Important! */
r_if
c_cond
(paren
id|self-&gt;conn_skb
)paren
id|dev_kfree_skb
c_func
(paren
id|self-&gt;conn_skb
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|self
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irlmp_close_lsap (self)&n; *&n; *    Close and remove LSAP&n; *&n; */
DECL|function|irlmp_close_lsap
r_void
id|irlmp_close_lsap
c_func
(paren
r_struct
id|lsap_cb
op_star
id|self
)paren
(brace
r_struct
id|lap_cb
op_star
id|lap
suffix:semicolon
r_struct
id|lsap_cb
op_star
id|lsap
op_assign
l_int|NULL
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|LMP_LSAP_MAGIC
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Find out if we should remove this LSAP from a link or from the&n;&t; *  list of unconnected lsaps (not associated with a link)&n;&t; */
id|lap
op_assign
id|self-&gt;lap
suffix:semicolon
r_if
c_cond
(paren
id|lap
)paren
(brace
id|ASSERT
c_func
(paren
id|lap-&gt;magic
op_eq
id|LMP_LAP_MAGIC
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
multiline_comment|/* We might close a LSAP before it has completed the&n;&t;&t; * connection setup. In those case, higher layers won&squot;t&n;&t;&t; * send a proper disconnect request. Harmless, except&n;&t;&t; * that we will forget to close LAP... - Jean II */
r_if
c_cond
(paren
id|self-&gt;lsap_state
op_ne
id|LSAP_DISCONNECTED
)paren
(brace
id|self-&gt;lsap_state
op_assign
id|LSAP_DISCONNECTED
suffix:semicolon
id|irlmp_do_lap_event
c_func
(paren
id|self-&gt;lap
comma
id|LM_LAP_DISCONNECT_REQUEST
comma
l_int|NULL
)paren
suffix:semicolon
)brace
multiline_comment|/* Now, remove from the link */
id|lsap
op_assign
id|hashbin_remove
c_func
(paren
id|lap-&gt;lsaps
comma
(paren
r_int
)paren
id|self
comma
l_int|NULL
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_IRDA_CACHE_LAST_LSAP
id|lap-&gt;cache.valid
op_assign
id|FALSE
suffix:semicolon
macro_line|#endif
)brace
id|self-&gt;lap
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Check if we found the LSAP! If not then try the unconnected lsaps */
r_if
c_cond
(paren
op_logical_neg
id|lsap
)paren
(brace
id|lsap
op_assign
id|hashbin_remove
c_func
(paren
id|irlmp-&gt;unconnected_lsaps
comma
(paren
r_int
)paren
id|self
comma
l_int|NULL
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|lsap
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
l_string|&quot;%s(), Looks like somebody has removed me already!&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|__irlmp_close_lsap
c_func
(paren
id|self
)paren
suffix:semicolon
)brace
DECL|variable|irlmp_close_lsap
id|EXPORT_SYMBOL
c_func
(paren
id|irlmp_close_lsap
)paren
suffix:semicolon
multiline_comment|/*&n; * Function irlmp_register_irlap (saddr, notify)&n; *&n; *    Register IrLAP layer with IrLMP. There is possible to have multiple&n; *    instances of the IrLAP layer, each connected to different IrDA ports&n; *&n; */
DECL|function|irlmp_register_link
r_void
id|irlmp_register_link
c_func
(paren
r_struct
id|irlap_cb
op_star
id|irlap
comma
id|__u32
id|saddr
comma
id|notify_t
op_star
id|notify
)paren
(brace
r_struct
id|lap_cb
op_star
id|lap
suffix:semicolon
id|ASSERT
c_func
(paren
id|irlmp
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|irlmp-&gt;magic
op_eq
id|LMP_MAGIC
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|notify
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Allocate new instance of a LSAP connection&n;&t; */
id|lap
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|lap_cb
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lap
op_eq
l_int|NULL
)paren
(brace
id|ERROR
c_func
(paren
l_string|&quot;%s: unable to kmalloc&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|memset
c_func
(paren
id|lap
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|lap_cb
)paren
)paren
suffix:semicolon
id|lap-&gt;irlap
op_assign
id|irlap
suffix:semicolon
id|lap-&gt;magic
op_assign
id|LMP_LAP_MAGIC
suffix:semicolon
id|lap-&gt;saddr
op_assign
id|saddr
suffix:semicolon
id|lap-&gt;daddr
op_assign
id|DEV_ADDR_ANY
suffix:semicolon
macro_line|#ifdef CONFIG_IRDA_CACHE_LAST_LSAP
id|lap-&gt;cache.valid
op_assign
id|FALSE
suffix:semicolon
macro_line|#endif
id|lap-&gt;lsaps
op_assign
id|hashbin_new
c_func
(paren
id|HB_LOCK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lap-&gt;lsaps
op_eq
l_int|NULL
)paren
(brace
id|WARNING
c_func
(paren
l_string|&quot;%s(), unable to kmalloc lsaps&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|lap
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|lap-&gt;lap_state
op_assign
id|LAP_STANDBY
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|lap-&gt;idle_timer
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Insert into queue of LMP links&n;&t; */
id|hashbin_insert
c_func
(paren
id|irlmp-&gt;links
comma
(paren
id|irda_queue_t
op_star
)paren
id|lap
comma
id|lap-&gt;saddr
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  We set only this variable so IrLAP can tell us on which link the&n;&t; *  different events happened on&n;&t; */
id|irda_notify_init
c_func
(paren
id|notify
)paren
suffix:semicolon
id|notify-&gt;instance
op_assign
id|lap
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irlmp_unregister_irlap (saddr)&n; *&n; *    IrLAP layer has been removed!&n; *&n; */
DECL|function|irlmp_unregister_link
r_void
id|irlmp_unregister_link
c_func
(paren
id|__u32
id|saddr
)paren
(brace
r_struct
id|lap_cb
op_star
id|link
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|4
comma
l_string|&quot;%s()&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
multiline_comment|/* We must remove ourselves from the hashbin *first*. This ensure&n;&t; * that no more LSAPs will be open on this link and no discovery&n;&t; * will be triggered anymore. Jean II */
id|link
op_assign
id|hashbin_remove
c_func
(paren
id|irlmp-&gt;links
comma
id|saddr
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|link
)paren
(brace
id|ASSERT
c_func
(paren
id|link-&gt;magic
op_eq
id|LMP_LAP_MAGIC
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
multiline_comment|/* Kill all the LSAPs on this link. Jean II */
id|link-&gt;reason
op_assign
id|LAP_DISC_INDICATION
suffix:semicolon
id|link-&gt;daddr
op_assign
id|DEV_ADDR_ANY
suffix:semicolon
id|irlmp_do_lap_event
c_func
(paren
id|link
comma
id|LM_LAP_DISCONNECT_INDICATION
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* Remove all discoveries discovered at this link */
id|irlmp_expire_discoveries
c_func
(paren
id|irlmp-&gt;cachelog
comma
id|link-&gt;saddr
comma
id|TRUE
)paren
suffix:semicolon
multiline_comment|/* Final cleanup */
id|del_timer
c_func
(paren
op_amp
id|link-&gt;idle_timer
)paren
suffix:semicolon
id|link-&gt;magic
op_assign
l_int|0
suffix:semicolon
id|kfree
c_func
(paren
id|link
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Function irlmp_connect_request (handle, dlsap, userdata)&n; *&n; *    Connect with a peer LSAP&n; *&n; */
DECL|function|irlmp_connect_request
r_int
id|irlmp_connect_request
c_func
(paren
r_struct
id|lsap_cb
op_star
id|self
comma
id|__u8
id|dlsap_sel
comma
id|__u32
id|saddr
comma
id|__u32
id|daddr
comma
r_struct
id|qos_info
op_star
id|qos
comma
r_struct
id|sk_buff
op_star
id|userdata
)paren
(brace
r_struct
id|sk_buff
op_star
id|tx_skb
op_assign
id|userdata
suffix:semicolon
r_struct
id|lap_cb
op_star
id|lap
suffix:semicolon
r_struct
id|lsap_cb
op_star
id|lsap
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
op_minus
id|EBADR
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|LMP_LSAP_MAGIC
comma
r_return
op_minus
id|EBADR
suffix:semicolon
)paren
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|2
comma
l_string|&quot;%s(), slsap_sel=%02x, dlsap_sel=%02x, saddr=%08x, daddr=%08x&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|self-&gt;slsap_sel
comma
id|dlsap_sel
comma
id|saddr
comma
id|daddr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|test_bit
c_func
(paren
l_int|0
comma
op_amp
id|self-&gt;connected
)paren
)paren
(brace
id|ret
op_assign
op_minus
id|EISCONN
suffix:semicolon
r_goto
id|err
suffix:semicolon
)brace
multiline_comment|/* Client must supply destination device address */
r_if
c_cond
(paren
op_logical_neg
id|daddr
)paren
(brace
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|err
suffix:semicolon
)brace
multiline_comment|/* Any userdata? */
r_if
c_cond
(paren
id|tx_skb
op_eq
l_int|NULL
)paren
(brace
id|tx_skb
op_assign
id|dev_alloc_skb
c_func
(paren
l_int|64
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tx_skb
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|skb_reserve
c_func
(paren
id|tx_skb
comma
id|LMP_MAX_HEADER
)paren
suffix:semicolon
)brace
multiline_comment|/* Make room for MUX control header (3 bytes) */
id|ASSERT
c_func
(paren
id|skb_headroom
c_func
(paren
id|tx_skb
)paren
op_ge
id|LMP_CONTROL_HEADER
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|skb_push
c_func
(paren
id|tx_skb
comma
id|LMP_CONTROL_HEADER
)paren
suffix:semicolon
id|self-&gt;dlsap_sel
op_assign
id|dlsap_sel
suffix:semicolon
multiline_comment|/*&n;&t; * Find the link to where we should try to connect since there may&n;&t; * be more than one IrDA port on this machine. If the client has&n;&t; * passed us the saddr (and already knows which link to use), then&n;&t; * we use that to find the link, if not then we have to look in the&n;&t; * discovery log and check if any of the links has discovered a&n;&t; * device with the given daddr&n;&t; */
r_if
c_cond
(paren
(paren
op_logical_neg
id|saddr
)paren
op_logical_or
(paren
id|saddr
op_eq
id|DEV_ADDR_ANY
)paren
)paren
(brace
id|discovery_t
op_star
id|discovery
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|irlmp-&gt;cachelog-&gt;hb_spinlock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|daddr
op_ne
id|DEV_ADDR_ANY
)paren
id|discovery
op_assign
id|hashbin_find
c_func
(paren
id|irlmp-&gt;cachelog
comma
id|daddr
comma
l_int|NULL
)paren
suffix:semicolon
r_else
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|2
comma
l_string|&quot;%s(), no daddr&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
id|discovery
op_assign
(paren
id|discovery_t
op_star
)paren
id|hashbin_get_first
c_func
(paren
id|irlmp-&gt;cachelog
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|discovery
)paren
(brace
id|saddr
op_assign
id|discovery-&gt;data.saddr
suffix:semicolon
id|daddr
op_assign
id|discovery-&gt;data.daddr
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|irlmp-&gt;cachelog-&gt;hb_spinlock
comma
id|flags
)paren
suffix:semicolon
)brace
id|lap
op_assign
id|hashbin_lock_find
c_func
(paren
id|irlmp-&gt;links
comma
id|saddr
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lap
op_eq
l_int|NULL
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;%s(), Unable to find a usable link!&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EHOSTUNREACH
suffix:semicolon
r_goto
id|err
suffix:semicolon
)brace
multiline_comment|/* Check if LAP is disconnected or already connected */
r_if
c_cond
(paren
id|lap-&gt;daddr
op_eq
id|DEV_ADDR_ANY
)paren
id|lap-&gt;daddr
op_assign
id|daddr
suffix:semicolon
r_else
r_if
c_cond
(paren
id|lap-&gt;daddr
op_ne
id|daddr
)paren
(brace
multiline_comment|/* Check if some LSAPs are active on this LAP */
r_if
c_cond
(paren
id|HASHBIN_GET_SIZE
c_func
(paren
id|lap-&gt;lsaps
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* No active connection, but LAP hasn&squot;t been&n;&t;&t;&t; * disconnected yet (waiting for timeout in LAP).&n;&t;&t;&t; * Maybe we could give LAP a bit of help in this case.&n;&t;&t;&t; */
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
l_string|&quot;%s(), sorry, but I&squot;m waiting for LAP to timeout!&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EAGAIN
suffix:semicolon
r_goto
id|err
suffix:semicolon
)brace
multiline_comment|/* LAP is already connected to a different node, and LAP&n;&t;&t; * can only talk to one node at a time */
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
l_string|&quot;%s(), sorry, but link is busy!&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_goto
id|err
suffix:semicolon
)brace
id|self-&gt;lap
op_assign
id|lap
suffix:semicolon
multiline_comment|/*&n;&t; *  Remove LSAP from list of unconnected LSAPs and insert it into the&n;&t; *  list of connected LSAPs for the particular link&n;&t; */
id|lsap
op_assign
id|hashbin_remove
c_func
(paren
id|irlmp-&gt;unconnected_lsaps
comma
(paren
r_int
)paren
id|self
comma
l_int|NULL
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|lsap
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|lsap-&gt;magic
op_eq
id|LMP_LSAP_MAGIC
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|lsap-&gt;lap
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|lsap-&gt;lap-&gt;magic
op_eq
id|LMP_LAP_MAGIC
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|hashbin_insert
c_func
(paren
id|self-&gt;lap-&gt;lsaps
comma
(paren
id|irda_queue_t
op_star
)paren
id|self
comma
(paren
r_int
)paren
id|self
comma
l_int|NULL
)paren
suffix:semicolon
id|set_bit
c_func
(paren
l_int|0
comma
op_amp
id|self-&gt;connected
)paren
suffix:semicolon
multiline_comment|/* TRUE */
multiline_comment|/*&n;&t; *  User supplied qos specifications?&n;&t; */
r_if
c_cond
(paren
id|qos
)paren
id|self-&gt;qos
op_assign
op_star
id|qos
suffix:semicolon
id|irlmp_do_lsap_event
c_func
(paren
id|self
comma
id|LM_CONNECT_REQUEST
comma
id|tx_skb
)paren
suffix:semicolon
multiline_comment|/* Drop reference count - see irlap_data_request(). */
id|dev_kfree_skb
c_func
(paren
id|tx_skb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|err
suffix:colon
multiline_comment|/* Cleanup */
r_if
c_cond
(paren
id|tx_skb
)paren
(brace
id|dev_kfree_skb
c_func
(paren
id|tx_skb
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|variable|irlmp_connect_request
id|EXPORT_SYMBOL
c_func
(paren
id|irlmp_connect_request
)paren
suffix:semicolon
multiline_comment|/*&n; * Function irlmp_connect_indication (self)&n; *&n; *    Incoming connection&n; *&n; */
DECL|function|irlmp_connect_indication
r_void
id|irlmp_connect_indication
c_func
(paren
r_struct
id|lsap_cb
op_star
id|self
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_int
id|max_seg_size
suffix:semicolon
r_int
id|lap_header_size
suffix:semicolon
r_int
id|max_header_size
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|LMP_LSAP_MAGIC
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|skb
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;lap
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|2
comma
l_string|&quot;%s(), slsap_sel=%02x, dlsap_sel=%02x&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|self-&gt;slsap_sel
comma
id|self-&gt;dlsap_sel
)paren
suffix:semicolon
multiline_comment|/* Note : self-&gt;lap is set in irlmp_link_data_indication(),&n;&t; * (case CONNECT_CMD:) because we have no way to set it here.&n;&t; * Similarly, self-&gt;dlsap_sel is usually set in irlmp_find_lsap().&n;&t; * Jean II */
id|self-&gt;qos
op_assign
op_star
id|self-&gt;lap-&gt;qos
suffix:semicolon
id|max_seg_size
op_assign
id|self-&gt;lap-&gt;qos-&gt;data_size.value
op_minus
id|LMP_HEADER
suffix:semicolon
id|lap_header_size
op_assign
id|IRLAP_GET_HEADER_SIZE
c_func
(paren
id|self-&gt;lap-&gt;irlap
)paren
suffix:semicolon
id|max_header_size
op_assign
id|LMP_HEADER
op_plus
id|lap_header_size
suffix:semicolon
multiline_comment|/* Hide LMP_CONTROL_HEADER header from layer above */
id|skb_pull
c_func
(paren
id|skb
comma
id|LMP_CONTROL_HEADER
)paren
suffix:semicolon
r_if
c_cond
(paren
id|self-&gt;notify.connect_indication
)paren
(brace
multiline_comment|/* Don&squot;t forget to refcount it - see irlap_driver_rcv(). */
id|skb_get
c_func
(paren
id|skb
)paren
suffix:semicolon
id|self-&gt;notify
dot
id|connect_indication
c_func
(paren
id|self-&gt;notify.instance
comma
id|self
comma
op_amp
id|self-&gt;qos
comma
id|max_seg_size
comma
id|max_header_size
comma
id|skb
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Function irlmp_connect_response (handle, userdata)&n; *&n; *    Service user is accepting connection&n; *&n; */
DECL|function|irlmp_connect_response
r_int
id|irlmp_connect_response
c_func
(paren
r_struct
id|lsap_cb
op_star
id|self
comma
r_struct
id|sk_buff
op_star
id|userdata
)paren
(brace
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|LMP_LSAP_MAGIC
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|userdata
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
multiline_comment|/* We set the connected bit and move the lsap to the connected list&n;&t; * in the state machine itself. Jean II */
id|IRDA_DEBUG
c_func
(paren
l_int|2
comma
l_string|&quot;%s(), slsap_sel=%02x, dlsap_sel=%02x&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|self-&gt;slsap_sel
comma
id|self-&gt;dlsap_sel
)paren
suffix:semicolon
multiline_comment|/* Make room for MUX control header (3 bytes) */
id|ASSERT
c_func
(paren
id|skb_headroom
c_func
(paren
id|userdata
)paren
op_ge
id|LMP_CONTROL_HEADER
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|skb_push
c_func
(paren
id|userdata
comma
id|LMP_CONTROL_HEADER
)paren
suffix:semicolon
id|irlmp_do_lsap_event
c_func
(paren
id|self
comma
id|LM_CONNECT_RESPONSE
comma
id|userdata
)paren
suffix:semicolon
multiline_comment|/* Drop reference count - see irlap_data_request(). */
id|dev_kfree_skb
c_func
(paren
id|userdata
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|irlmp_connect_response
id|EXPORT_SYMBOL
c_func
(paren
id|irlmp_connect_response
)paren
suffix:semicolon
multiline_comment|/*&n; * Function irlmp_connect_confirm (handle, skb)&n; *&n; *    LSAP connection confirmed peer device!&n; */
DECL|function|irlmp_connect_confirm
r_void
id|irlmp_connect_confirm
c_func
(paren
r_struct
id|lsap_cb
op_star
id|self
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_int
id|max_header_size
suffix:semicolon
r_int
id|lap_header_size
suffix:semicolon
r_int
id|max_seg_size
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|3
comma
l_string|&quot;%s()&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|skb
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|LMP_LSAP_MAGIC
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;lap
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|self-&gt;qos
op_assign
op_star
id|self-&gt;lap-&gt;qos
suffix:semicolon
id|max_seg_size
op_assign
id|self-&gt;lap-&gt;qos-&gt;data_size.value
op_minus
id|LMP_HEADER
suffix:semicolon
id|lap_header_size
op_assign
id|IRLAP_GET_HEADER_SIZE
c_func
(paren
id|self-&gt;lap-&gt;irlap
)paren
suffix:semicolon
id|max_header_size
op_assign
id|LMP_HEADER
op_plus
id|lap_header_size
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|2
comma
l_string|&quot;%s(), max_header_size=%d&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|max_header_size
)paren
suffix:semicolon
multiline_comment|/* Hide LMP_CONTROL_HEADER header from layer above */
id|skb_pull
c_func
(paren
id|skb
comma
id|LMP_CONTROL_HEADER
)paren
suffix:semicolon
r_if
c_cond
(paren
id|self-&gt;notify.connect_confirm
)paren
(brace
multiline_comment|/* Don&squot;t forget to refcount it - see irlap_driver_rcv() */
id|skb_get
c_func
(paren
id|skb
)paren
suffix:semicolon
id|self-&gt;notify
dot
id|connect_confirm
c_func
(paren
id|self-&gt;notify.instance
comma
id|self
comma
op_amp
id|self-&gt;qos
comma
id|max_seg_size
comma
id|max_header_size
comma
id|skb
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Function irlmp_dup (orig, instance)&n; *&n; *    Duplicate LSAP, can be used by servers to confirm a connection on a&n; *    new LSAP so it can keep listening on the old one.&n; *&n; */
DECL|function|irlmp_dup
r_struct
id|lsap_cb
op_star
id|irlmp_dup
c_func
(paren
r_struct
id|lsap_cb
op_star
id|orig
comma
r_void
op_star
id|instance
)paren
(brace
r_struct
id|lsap_cb
op_star
r_new
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;%s()&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|irlmp-&gt;unconnected_lsaps-&gt;hb_spinlock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* Only allowed to duplicate unconnected LSAP&squot;s, and only LSAPs&n;&t; * that have received a connect indication. Jean II */
r_if
c_cond
(paren
(paren
op_logical_neg
id|hashbin_find
c_func
(paren
id|irlmp-&gt;unconnected_lsaps
comma
(paren
r_int
)paren
id|orig
comma
l_int|NULL
)paren
)paren
op_logical_or
(paren
id|orig-&gt;lap
op_eq
l_int|NULL
)paren
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
l_string|&quot;%s(), invalid LSAP (wrong state)&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|irlmp-&gt;unconnected_lsaps-&gt;hb_spinlock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Allocate a new instance */
r_new
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|lsap_cb
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
r_new
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
l_string|&quot;%s(), unable to kmalloc&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|irlmp-&gt;unconnected_lsaps-&gt;hb_spinlock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Dup */
id|memcpy
c_func
(paren
r_new
comma
id|orig
comma
r_sizeof
(paren
r_struct
id|lsap_cb
)paren
)paren
suffix:semicolon
multiline_comment|/* new-&gt;lap = orig-&gt;lap; =&gt; done in the memcpy() */
multiline_comment|/* new-&gt;slsap_sel = orig-&gt;slsap_sel; =&gt; done in the memcpy() */
r_new
op_member_access_from_pointer
id|conn_skb
op_assign
l_int|NULL
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|irlmp-&gt;unconnected_lsaps-&gt;hb_spinlock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* Not everything is the same */
r_new
op_member_access_from_pointer
id|notify.instance
op_assign
id|instance
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
r_new
op_member_access_from_pointer
id|watchdog_timer
)paren
suffix:semicolon
id|hashbin_insert
c_func
(paren
id|irlmp-&gt;unconnected_lsaps
comma
(paren
id|irda_queue_t
op_star
)paren
r_new
comma
(paren
r_int
)paren
r_new
comma
l_int|NULL
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_IRDA_CACHE_LAST_LSAP
multiline_comment|/* Make sure that we invalidate the LSAP cache */
r_new
op_member_access_from_pointer
id|lap-&gt;cache.valid
op_assign
id|FALSE
suffix:semicolon
macro_line|#endif /* CONFIG_IRDA_CACHE_LAST_LSAP */
r_return
r_new
suffix:semicolon
)brace
DECL|variable|irlmp_dup
id|EXPORT_SYMBOL
c_func
(paren
id|irlmp_dup
)paren
suffix:semicolon
multiline_comment|/*&n; * Function irlmp_disconnect_request (handle, userdata)&n; *&n; *    The service user is requesting disconnection, this will not remove the&n; *    LSAP, but only mark it as disconnected&n; */
DECL|function|irlmp_disconnect_request
r_int
id|irlmp_disconnect_request
c_func
(paren
r_struct
id|lsap_cb
op_star
id|self
comma
r_struct
id|sk_buff
op_star
id|userdata
)paren
(brace
r_struct
id|lsap_cb
op_star
id|lsap
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|LMP_LSAP_MAGIC
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|userdata
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
multiline_comment|/* Already disconnected ?&n;&t; * There is a race condition between irlmp_disconnect_indication()&n;&t; * and us that might mess up the hashbins below. This fixes it.&n;&t; * Jean II */
r_if
c_cond
(paren
op_logical_neg
id|test_and_clear_bit
c_func
(paren
l_int|0
comma
op_amp
id|self-&gt;connected
)paren
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
l_string|&quot;%s(), already disconnected!&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
id|dev_kfree_skb
c_func
(paren
id|userdata
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|skb_push
c_func
(paren
id|userdata
comma
id|LMP_CONTROL_HEADER
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Do the event before the other stuff since we must know&n;&t; *  which lap layer that the frame should be transmitted on&n;&t; */
id|irlmp_do_lsap_event
c_func
(paren
id|self
comma
id|LM_DISCONNECT_REQUEST
comma
id|userdata
)paren
suffix:semicolon
multiline_comment|/* Drop reference count - see irlap_data_request(). */
id|dev_kfree_skb
c_func
(paren
id|userdata
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Remove LSAP from list of connected LSAPs for the particular link&n;&t; *  and insert it into the list of unconnected LSAPs&n;&t; */
id|ASSERT
c_func
(paren
id|self-&gt;lap
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;lap-&gt;magic
op_eq
id|LMP_LAP_MAGIC
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;lap-&gt;lsaps
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|lsap
op_assign
id|hashbin_remove
c_func
(paren
id|self-&gt;lap-&gt;lsaps
comma
(paren
r_int
)paren
id|self
comma
l_int|NULL
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_IRDA_CACHE_LAST_LSAP
id|self-&gt;lap-&gt;cache.valid
op_assign
id|FALSE
suffix:semicolon
macro_line|#endif
id|ASSERT
c_func
(paren
id|lsap
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|lsap-&gt;magic
op_eq
id|LMP_LSAP_MAGIC
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|lsap
op_eq
id|self
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|hashbin_insert
c_func
(paren
id|irlmp-&gt;unconnected_lsaps
comma
(paren
id|irda_queue_t
op_star
)paren
id|self
comma
(paren
r_int
)paren
id|self
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* Reset some values */
id|self-&gt;dlsap_sel
op_assign
id|LSAP_ANY
suffix:semicolon
id|self-&gt;lap
op_assign
l_int|NULL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|irlmp_disconnect_request
id|EXPORT_SYMBOL
c_func
(paren
id|irlmp_disconnect_request
)paren
suffix:semicolon
multiline_comment|/*&n; * Function irlmp_disconnect_indication (reason, userdata)&n; *&n; *    LSAP is being closed!&n; */
DECL|function|irlmp_disconnect_indication
r_void
id|irlmp_disconnect_indication
c_func
(paren
r_struct
id|lsap_cb
op_star
id|self
comma
id|LM_REASON
id|reason
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|lsap_cb
op_star
id|lsap
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;%s(), reason=%s&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|irlmp_reasons
(braket
id|reason
)braket
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|LMP_LSAP_MAGIC
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|3
comma
l_string|&quot;%s(), slsap_sel=%02x, dlsap_sel=%02x&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|self-&gt;slsap_sel
comma
id|self-&gt;dlsap_sel
)paren
suffix:semicolon
multiline_comment|/* Already disconnected ?&n;&t; * There is a race condition between irlmp_disconnect_request()&n;&t; * and us that might mess up the hashbins below. This fixes it.&n;&t; * Jean II */
r_if
c_cond
(paren
op_logical_neg
id|test_and_clear_bit
c_func
(paren
l_int|0
comma
op_amp
id|self-&gt;connected
)paren
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
l_string|&quot;%s(), already disconnected!&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  Remove association between this LSAP and the link it used&n;&t; */
id|ASSERT
c_func
(paren
id|self-&gt;lap
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;lap-&gt;lsaps
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|lsap
op_assign
id|hashbin_remove
c_func
(paren
id|self-&gt;lap-&gt;lsaps
comma
(paren
r_int
)paren
id|self
comma
l_int|NULL
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_IRDA_CACHE_LAST_LSAP
id|self-&gt;lap-&gt;cache.valid
op_assign
id|FALSE
suffix:semicolon
macro_line|#endif
id|ASSERT
c_func
(paren
id|lsap
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|lsap
op_eq
id|self
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|hashbin_insert
c_func
(paren
id|irlmp-&gt;unconnected_lsaps
comma
(paren
id|irda_queue_t
op_star
)paren
id|lsap
comma
(paren
r_int
)paren
id|lsap
comma
l_int|NULL
)paren
suffix:semicolon
id|self-&gt;dlsap_sel
op_assign
id|LSAP_ANY
suffix:semicolon
id|self-&gt;lap
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; *  Inform service user&n;&t; */
r_if
c_cond
(paren
id|self-&gt;notify.disconnect_indication
)paren
(brace
multiline_comment|/* Don&squot;t forget to refcount it - see irlap_driver_rcv(). */
r_if
c_cond
(paren
id|skb
)paren
(brace
id|skb_get
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
id|self-&gt;notify
dot
id|disconnect_indication
c_func
(paren
id|self-&gt;notify.instance
comma
id|self
comma
id|reason
comma
id|skb
)paren
suffix:semicolon
)brace
r_else
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
l_string|&quot;%s(), no handler&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Function irlmp_do_expiry (void)&n; *&n; *    Do a cleanup of the discovery log (remove old entries)&n; *&n; * Note : separate from irlmp_do_discovery() so that we can handle&n; * passive discovery properly.&n; */
DECL|function|irlmp_do_expiry
r_void
id|irlmp_do_expiry
c_func
(paren
r_void
)paren
(brace
r_struct
id|lap_cb
op_star
id|lap
suffix:semicolon
multiline_comment|/*&n;&t; * Expire discovery on all links which are *not* connected.&n;&t; * On links which are connected, we can&squot;t do discovery&n;&t; * anymore and can&squot;t refresh the log, so we freeze the&n;&t; * discovery log to keep info about the device we are&n;&t; * connected to.&n;&t; * This info is mandatory if we want irlmp_connect_request()&n;&t; * to work properly. - Jean II&n;&t; */
id|lap
op_assign
(paren
r_struct
id|lap_cb
op_star
)paren
id|hashbin_get_first
c_func
(paren
id|irlmp-&gt;links
)paren
suffix:semicolon
r_while
c_loop
(paren
id|lap
op_ne
l_int|NULL
)paren
(brace
id|ASSERT
c_func
(paren
id|lap-&gt;magic
op_eq
id|LMP_LAP_MAGIC
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lap-&gt;lap_state
op_eq
id|LAP_STANDBY
)paren
(brace
multiline_comment|/* Expire discoveries discovered on this link */
id|irlmp_expire_discoveries
c_func
(paren
id|irlmp-&gt;cachelog
comma
id|lap-&gt;saddr
comma
id|FALSE
)paren
suffix:semicolon
)brace
id|lap
op_assign
(paren
r_struct
id|lap_cb
op_star
)paren
id|hashbin_get_next
c_func
(paren
id|irlmp-&gt;links
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Function irlmp_do_discovery (nslots)&n; *&n; *    Do some discovery on all links&n; *&n; * Note : log expiry is done above.&n; */
DECL|function|irlmp_do_discovery
r_void
id|irlmp_do_discovery
c_func
(paren
r_int
id|nslots
)paren
(brace
r_struct
id|lap_cb
op_star
id|lap
suffix:semicolon
multiline_comment|/* Make sure the value is sane */
r_if
c_cond
(paren
(paren
id|nslots
op_ne
l_int|1
)paren
op_logical_and
(paren
id|nslots
op_ne
l_int|6
)paren
op_logical_and
(paren
id|nslots
op_ne
l_int|8
)paren
op_logical_and
(paren
id|nslots
op_ne
l_int|16
)paren
)paren
(brace
id|WARNING
c_func
(paren
l_string|&quot;%s: invalid value for number of slots!&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
id|nslots
op_assign
id|sysctl_discovery_slots
op_assign
l_int|8
suffix:semicolon
)brace
multiline_comment|/* Construct new discovery info to be used by IrLAP, */
id|u16ho
c_func
(paren
id|irlmp-&gt;discovery_cmd.data.hints
)paren
op_assign
id|irlmp-&gt;hints.word
suffix:semicolon
multiline_comment|/*&n;&t; *  Set character set for device name (we use ASCII), and&n;&t; *  copy device name. Remember to make room for a &bslash;0 at the&n;&t; *  end&n;&t; */
id|irlmp-&gt;discovery_cmd.data.charset
op_assign
id|CS_ASCII
suffix:semicolon
id|strncpy
c_func
(paren
id|irlmp-&gt;discovery_cmd.data.info
comma
id|sysctl_devname
comma
id|NICKNAME_MAX_LEN
)paren
suffix:semicolon
id|irlmp-&gt;discovery_cmd.name_len
op_assign
id|strlen
c_func
(paren
id|irlmp-&gt;discovery_cmd.data.info
)paren
suffix:semicolon
id|irlmp-&gt;discovery_cmd.nslots
op_assign
id|nslots
suffix:semicolon
multiline_comment|/*&n;&t; * Try to send discovery packets on all links&n;&t; */
id|lap
op_assign
(paren
r_struct
id|lap_cb
op_star
)paren
id|hashbin_get_first
c_func
(paren
id|irlmp-&gt;links
)paren
suffix:semicolon
r_while
c_loop
(paren
id|lap
op_ne
l_int|NULL
)paren
(brace
id|ASSERT
c_func
(paren
id|lap-&gt;magic
op_eq
id|LMP_LAP_MAGIC
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lap-&gt;lap_state
op_eq
id|LAP_STANDBY
)paren
(brace
multiline_comment|/* Try to discover */
id|irlmp_do_lap_event
c_func
(paren
id|lap
comma
id|LM_LAP_DISCOVERY_REQUEST
comma
l_int|NULL
)paren
suffix:semicolon
)brace
id|lap
op_assign
(paren
r_struct
id|lap_cb
op_star
)paren
id|hashbin_get_next
c_func
(paren
id|irlmp-&gt;links
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Function irlmp_discovery_request (nslots)&n; *&n; *    Do a discovery of devices in front of the computer&n; *&n; * If the caller has registered a client discovery callback, this&n; * allow him to receive the full content of the discovery log through&n; * this callback (as normally he will receive only new discoveries).&n; */
DECL|function|irlmp_discovery_request
r_void
id|irlmp_discovery_request
c_func
(paren
r_int
id|nslots
)paren
(brace
multiline_comment|/* Return current cached discovery log (in full) */
id|irlmp_discovery_confirm
c_func
(paren
id|irlmp-&gt;cachelog
comma
id|DISCOVERY_LOG
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Start a single discovery operation if discovery is not already&n;         * running&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|sysctl_discovery
)paren
(brace
multiline_comment|/* Check if user wants to override the default */
r_if
c_cond
(paren
id|nslots
op_eq
id|DISCOVERY_DEFAULT_SLOTS
)paren
id|nslots
op_assign
id|sysctl_discovery_slots
suffix:semicolon
id|irlmp_do_discovery
c_func
(paren
id|nslots
)paren
suffix:semicolon
multiline_comment|/* Note : we never do expiry here. Expiry will run on the&n;&t;&t; * discovery timer regardless of the state of sysctl_discovery&n;&t;&t; * Jean II */
)brace
)brace
DECL|variable|irlmp_discovery_request
id|EXPORT_SYMBOL
c_func
(paren
id|irlmp_discovery_request
)paren
suffix:semicolon
multiline_comment|/*&n; * Function irlmp_get_discoveries (pn, mask, slots)&n; *&n; *    Return the current discovery log&n; *&n; * If discovery is not enabled, you should call this function again&n; * after 1 or 2 seconds (i.e. after discovery has been done).&n; */
DECL|function|irlmp_get_discoveries
r_struct
id|irda_device_info
op_star
id|irlmp_get_discoveries
c_func
(paren
r_int
op_star
id|pn
comma
id|__u16
id|mask
comma
r_int
id|nslots
)paren
(brace
multiline_comment|/* If discovery is not enabled, it&squot;s likely that the discovery log&n;&t; * will be empty. So, we trigger a single discovery, so that next&n;&t; * time the user call us there might be some results in the log.&n;&t; * Jean II&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|sysctl_discovery
)paren
(brace
multiline_comment|/* Check if user wants to override the default */
r_if
c_cond
(paren
id|nslots
op_eq
id|DISCOVERY_DEFAULT_SLOTS
)paren
id|nslots
op_assign
id|sysctl_discovery_slots
suffix:semicolon
multiline_comment|/* Start discovery - will complete sometime later */
id|irlmp_do_discovery
c_func
(paren
id|nslots
)paren
suffix:semicolon
multiline_comment|/* Note : we never do expiry here. Expiry will run on the&n;&t;&t; * discovery timer regardless of the state of sysctl_discovery&n;&t;&t; * Jean II */
)brace
multiline_comment|/* Return current cached discovery log */
r_return
id|irlmp_copy_discoveries
c_func
(paren
id|irlmp-&gt;cachelog
comma
id|pn
comma
id|mask
comma
id|TRUE
)paren
suffix:semicolon
)brace
DECL|variable|irlmp_get_discoveries
id|EXPORT_SYMBOL
c_func
(paren
id|irlmp_get_discoveries
)paren
suffix:semicolon
multiline_comment|/*&n; * Function irlmp_notify_client (log)&n; *&n; *    Notify all about discovered devices&n; *&n; * Clients registered with IrLMP are :&n; *&t;o IrComm&n; *&t;o IrLAN&n; *&t;o Any socket (in any state - ouch, that may be a lot !)&n; * The client may have defined a callback to be notified in case of&n; * partial/selective discovery based on the hints that it passed to IrLMP.&n; */
r_static
r_inline
r_void
DECL|function|irlmp_notify_client
id|irlmp_notify_client
c_func
(paren
id|irlmp_client_t
op_star
id|client
comma
id|hashbin_t
op_star
id|log
comma
id|DISCOVERY_MODE
id|mode
)paren
(brace
id|discinfo_t
op_star
id|discoveries
suffix:semicolon
multiline_comment|/* Copy of the discovery log */
r_int
id|number
suffix:semicolon
multiline_comment|/* Number of nodes in the log */
r_int
id|i
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|3
comma
l_string|&quot;%s()&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
multiline_comment|/* Check if client wants or not partial/selective log (optimisation) */
r_if
c_cond
(paren
op_logical_neg
id|client-&gt;disco_callback
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t; * Locking notes :&n;&t; * the old code was manipulating the log directly, which was&n;&t; * very racy. Now, we use copy_discoveries, that protects&n;&t; * itself while dumping the log for us.&n;&t; * The overhead of the copy is compensated by the fact that&n;&t; * we only pass new discoveries in normal mode and don&squot;t&n;&t; * pass the same old entry every 3s to the caller as we used&n;&t; * to do (virtual function calling is expensive).&n;&t; * Jean II&n;&t; */
multiline_comment|/*&n;&t; * Now, check all discovered devices (if any), and notify client&n;&t; * only about the services that the client is interested in&n;&t; * We also notify only about the new devices unless the caller&n;&t; * explicitly request a dump of the log. Jean II&n;&t; */
id|discoveries
op_assign
id|irlmp_copy_discoveries
c_func
(paren
id|log
comma
op_amp
id|number
comma
id|client-&gt;hint_mask.word
comma
(paren
id|mode
op_eq
id|DISCOVERY_LOG
)paren
)paren
suffix:semicolon
multiline_comment|/* Check if the we got some results */
r_if
c_cond
(paren
id|discoveries
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
multiline_comment|/* No nodes discovered */
multiline_comment|/* Pass all entries to the listener */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|number
suffix:semicolon
id|i
op_increment
)paren
(brace
id|client
op_member_access_from_pointer
id|disco_callback
c_func
(paren
op_amp
(paren
id|discoveries
(braket
id|i
)braket
)paren
comma
id|mode
comma
id|client-&gt;priv
)paren
suffix:semicolon
)brace
multiline_comment|/* Free up our buffer */
id|kfree
c_func
(paren
id|discoveries
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irlmp_discovery_confirm ( self, log)&n; *&n; *    Some device(s) answered to our discovery request! Check to see which&n; *    device it is, and give indication to the client(s)&n; *&n; */
DECL|function|irlmp_discovery_confirm
r_void
id|irlmp_discovery_confirm
c_func
(paren
id|hashbin_t
op_star
id|log
comma
id|DISCOVERY_MODE
id|mode
)paren
(brace
id|irlmp_client_t
op_star
id|client
suffix:semicolon
id|irlmp_client_t
op_star
id|client_next
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|3
comma
l_string|&quot;%s()&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|log
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|HASHBIN_GET_SIZE
c_func
(paren
id|log
)paren
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* For each client - notify callback may touch client list */
id|client
op_assign
(paren
id|irlmp_client_t
op_star
)paren
id|hashbin_get_first
c_func
(paren
id|irlmp-&gt;clients
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|NULL
op_ne
id|hashbin_find_next
c_func
(paren
id|irlmp-&gt;clients
comma
(paren
r_int
)paren
id|client
comma
l_int|NULL
comma
(paren
r_void
op_star
)paren
op_amp
id|client_next
)paren
)paren
(brace
multiline_comment|/* Check if we should notify client */
id|irlmp_notify_client
c_func
(paren
id|client
comma
id|log
comma
id|mode
)paren
suffix:semicolon
id|client
op_assign
id|client_next
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Function irlmp_discovery_expiry (expiry)&n; *&n; *&t;This device is no longer been discovered, and therefore it is being&n; *&t;purged from the discovery log. Inform all clients who have&n; *&t;registered for this event...&n; *&n; *&t;Note : called exclusively from discovery.c&n; *&t;Note : this is no longer called under discovery spinlock, so the&n; *&t;&t;client can do whatever he wants in the callback.&n; */
DECL|function|irlmp_discovery_expiry
r_void
id|irlmp_discovery_expiry
c_func
(paren
id|discinfo_t
op_star
id|expiries
comma
r_int
id|number
)paren
(brace
id|irlmp_client_t
op_star
id|client
suffix:semicolon
id|irlmp_client_t
op_star
id|client_next
suffix:semicolon
r_int
id|i
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|3
comma
l_string|&quot;%s()&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|expiries
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
multiline_comment|/* For each client - notify callback may touch client list */
id|client
op_assign
(paren
id|irlmp_client_t
op_star
)paren
id|hashbin_get_first
c_func
(paren
id|irlmp-&gt;clients
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|NULL
op_ne
id|hashbin_find_next
c_func
(paren
id|irlmp-&gt;clients
comma
(paren
r_int
)paren
id|client
comma
l_int|NULL
comma
(paren
r_void
op_star
)paren
op_amp
id|client_next
)paren
)paren
(brace
multiline_comment|/* Pass all entries to the listener */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|number
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* Check if we should notify client */
r_if
c_cond
(paren
(paren
id|client-&gt;expir_callback
)paren
op_logical_and
(paren
id|client-&gt;hint_mask.word
op_amp
id|u16ho
c_func
(paren
id|expiries
(braket
id|i
)braket
dot
id|hints
)paren
op_amp
l_int|0x7f7f
)paren
)paren
id|client
op_member_access_from_pointer
id|expir_callback
c_func
(paren
op_amp
(paren
id|expiries
(braket
id|i
)braket
)paren
comma
id|EXPIRY_TIMEOUT
comma
id|client-&gt;priv
)paren
suffix:semicolon
)brace
multiline_comment|/* Next client */
id|client
op_assign
id|client_next
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Function irlmp_get_discovery_response ()&n; *&n; *    Used by IrLAP to get the discovery info it needs when answering&n; *    discovery requests by other devices.&n; */
DECL|function|irlmp_get_discovery_response
id|discovery_t
op_star
id|irlmp_get_discovery_response
c_func
(paren
r_void
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|4
comma
l_string|&quot;%s()&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|irlmp
op_ne
l_int|NULL
comma
r_return
l_int|NULL
suffix:semicolon
)paren
suffix:semicolon
id|u16ho
c_func
(paren
id|irlmp-&gt;discovery_rsp.data.hints
)paren
op_assign
id|irlmp-&gt;hints.word
suffix:semicolon
multiline_comment|/*&n;&t; *  Set character set for device name (we use ASCII), and&n;&t; *  copy device name. Remember to make room for a &bslash;0 at the&n;&t; *  end&n;&t; */
id|irlmp-&gt;discovery_rsp.data.charset
op_assign
id|CS_ASCII
suffix:semicolon
id|strncpy
c_func
(paren
id|irlmp-&gt;discovery_rsp.data.info
comma
id|sysctl_devname
comma
id|NICKNAME_MAX_LEN
)paren
suffix:semicolon
id|irlmp-&gt;discovery_rsp.name_len
op_assign
id|strlen
c_func
(paren
id|irlmp-&gt;discovery_rsp.data.info
)paren
suffix:semicolon
r_return
op_amp
id|irlmp-&gt;discovery_rsp
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irlmp_data_request (self, skb)&n; *&n; *    Send some data to peer device&n; *&n; * Note on skb management :&n; * After calling the lower layers of the IrDA stack, we always&n; * kfree() the skb, which drop the reference count (and potentially&n; * destroy it).&n; * IrLMP and IrLAP may queue the packet, and in those cases will need&n; * to use skb_get() to keep it around.&n; * Jean II&n; */
DECL|function|irlmp_data_request
r_int
id|irlmp_data_request
c_func
(paren
r_struct
id|lsap_cb
op_star
id|self
comma
r_struct
id|sk_buff
op_star
id|userdata
)paren
(brace
r_int
id|ret
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|LMP_LSAP_MAGIC
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
multiline_comment|/* Make room for MUX header */
id|ASSERT
c_func
(paren
id|skb_headroom
c_func
(paren
id|userdata
)paren
op_ge
id|LMP_HEADER
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|skb_push
c_func
(paren
id|userdata
comma
id|LMP_HEADER
)paren
suffix:semicolon
id|ret
op_assign
id|irlmp_do_lsap_event
c_func
(paren
id|self
comma
id|LM_DATA_REQUEST
comma
id|userdata
)paren
suffix:semicolon
multiline_comment|/* Drop reference count - see irlap_data_request(). */
id|dev_kfree_skb
c_func
(paren
id|userdata
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|variable|irlmp_data_request
id|EXPORT_SYMBOL
c_func
(paren
id|irlmp_data_request
)paren
suffix:semicolon
multiline_comment|/*&n; * Function irlmp_data_indication (handle, skb)&n; *&n; *    Got data from LAP layer so pass it up to upper layer&n; *&n; */
DECL|function|irlmp_data_indication
r_void
id|irlmp_data_indication
c_func
(paren
r_struct
id|lsap_cb
op_star
id|self
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
multiline_comment|/* Hide LMP header from layer above */
id|skb_pull
c_func
(paren
id|skb
comma
id|LMP_HEADER
)paren
suffix:semicolon
r_if
c_cond
(paren
id|self-&gt;notify.data_indication
)paren
(brace
multiline_comment|/* Don&squot;t forget to refcount it - see irlap_driver_rcv(). */
id|skb_get
c_func
(paren
id|skb
)paren
suffix:semicolon
id|self-&gt;notify
dot
id|data_indication
c_func
(paren
id|self-&gt;notify.instance
comma
id|self
comma
id|skb
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Function irlmp_udata_request (self, skb)&n; */
DECL|function|irlmp_udata_request
r_int
id|irlmp_udata_request
c_func
(paren
r_struct
id|lsap_cb
op_star
id|self
comma
r_struct
id|sk_buff
op_star
id|userdata
)paren
(brace
r_int
id|ret
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|4
comma
l_string|&quot;%s()&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|userdata
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
multiline_comment|/* Make room for MUX header */
id|ASSERT
c_func
(paren
id|skb_headroom
c_func
(paren
id|userdata
)paren
op_ge
id|LMP_HEADER
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|skb_push
c_func
(paren
id|userdata
comma
id|LMP_HEADER
)paren
suffix:semicolon
id|ret
op_assign
id|irlmp_do_lsap_event
c_func
(paren
id|self
comma
id|LM_UDATA_REQUEST
comma
id|userdata
)paren
suffix:semicolon
multiline_comment|/* Drop reference count - see irlap_data_request(). */
id|dev_kfree_skb
c_func
(paren
id|userdata
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irlmp_udata_indication (self, skb)&n; *&n; *    Send unreliable data (but still within the connection)&n; *&n; */
DECL|function|irlmp_udata_indication
r_void
id|irlmp_udata_indication
c_func
(paren
r_struct
id|lsap_cb
op_star
id|self
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|4
comma
l_string|&quot;%s()&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|LMP_LSAP_MAGIC
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|skb
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
multiline_comment|/* Hide LMP header from layer above */
id|skb_pull
c_func
(paren
id|skb
comma
id|LMP_HEADER
)paren
suffix:semicolon
r_if
c_cond
(paren
id|self-&gt;notify.udata_indication
)paren
(brace
multiline_comment|/* Don&squot;t forget to refcount it - see irlap_driver_rcv(). */
id|skb_get
c_func
(paren
id|skb
)paren
suffix:semicolon
id|self-&gt;notify
dot
id|udata_indication
c_func
(paren
id|self-&gt;notify.instance
comma
id|self
comma
id|skb
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Function irlmp_connless_data_request (self, skb)&n; */
macro_line|#ifdef CONFIG_IRDA_ULTRA
DECL|function|irlmp_connless_data_request
r_int
id|irlmp_connless_data_request
c_func
(paren
r_struct
id|lsap_cb
op_star
id|self
comma
r_struct
id|sk_buff
op_star
id|userdata
comma
id|__u8
id|pid
)paren
(brace
r_struct
id|sk_buff
op_star
id|clone_skb
suffix:semicolon
r_struct
id|lap_cb
op_star
id|lap
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|4
comma
l_string|&quot;%s()&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|userdata
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
multiline_comment|/* Make room for MUX and PID header */
id|ASSERT
c_func
(paren
id|skb_headroom
c_func
(paren
id|userdata
)paren
op_ge
id|LMP_HEADER
op_plus
id|LMP_PID_HEADER
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
multiline_comment|/* Insert protocol identifier */
id|skb_push
c_func
(paren
id|userdata
comma
id|LMP_PID_HEADER
)paren
suffix:semicolon
r_if
c_cond
(paren
id|self
op_ne
l_int|NULL
)paren
(brace
id|userdata-&gt;data
(braket
l_int|0
)braket
op_assign
id|self-&gt;pid
suffix:semicolon
)brace
r_else
id|userdata-&gt;data
(braket
l_int|0
)braket
op_assign
id|pid
suffix:semicolon
multiline_comment|/* Connectionless sockets must use 0x70 */
id|skb_push
c_func
(paren
id|userdata
comma
id|LMP_HEADER
)paren
suffix:semicolon
id|userdata-&gt;data
(braket
l_int|0
)braket
op_assign
id|userdata-&gt;data
(braket
l_int|1
)braket
op_assign
id|LSAP_CONNLESS
suffix:semicolon
multiline_comment|/* Try to send Connectionless  packets out on all links */
id|lap
op_assign
(paren
r_struct
id|lap_cb
op_star
)paren
id|hashbin_get_first
c_func
(paren
id|irlmp-&gt;links
)paren
suffix:semicolon
r_while
c_loop
(paren
id|lap
op_ne
l_int|NULL
)paren
(brace
id|ASSERT
c_func
(paren
id|lap-&gt;magic
op_eq
id|LMP_LAP_MAGIC
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|clone_skb
op_assign
id|skb_clone
c_func
(paren
id|userdata
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|clone_skb
)paren
(brace
id|dev_kfree_skb
c_func
(paren
id|userdata
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|irlap_unitdata_request
c_func
(paren
id|lap-&gt;irlap
comma
id|clone_skb
)paren
suffix:semicolon
multiline_comment|/* irlap_unitdata_request() don&squot;t increase refcount,&n;&t;&t; * so no dev_kfree_skb() - Jean II */
id|lap
op_assign
(paren
r_struct
id|lap_cb
op_star
)paren
id|hashbin_get_next
c_func
(paren
id|irlmp-&gt;links
)paren
suffix:semicolon
)brace
id|dev_kfree_skb
c_func
(paren
id|userdata
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_IRDA_ULTRA */
multiline_comment|/*&n; * Function irlmp_connless_data_indication (self, skb)&n; *&n; *    Receive unreliable data outside any connection. Mostly used by Ultra&n; *&n; */
macro_line|#ifdef CONFIG_IRDA_ULTRA
DECL|function|irlmp_connless_data_indication
r_void
id|irlmp_connless_data_indication
c_func
(paren
r_struct
id|lsap_cb
op_star
id|self
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|4
comma
l_string|&quot;%s()&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|LMP_LSAP_MAGIC
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|skb
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
multiline_comment|/* Hide LMP and PID header from layer above */
id|skb_pull
c_func
(paren
id|skb
comma
id|LMP_HEADER
op_plus
id|LMP_PID_HEADER
)paren
suffix:semicolon
r_if
c_cond
(paren
id|self-&gt;notify.udata_indication
)paren
(brace
multiline_comment|/* Don&squot;t forget to refcount it - see irlap_driver_rcv(). */
id|skb_get
c_func
(paren
id|skb
)paren
suffix:semicolon
id|self-&gt;notify
dot
id|udata_indication
c_func
(paren
id|self-&gt;notify.instance
comma
id|self
comma
id|skb
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif /* CONFIG_IRDA_ULTRA */
multiline_comment|/*&n; * Propagate status indication from LAP to LSAPs (via LMP)&n; * This don&squot;t trigger any change of state in lap_cb, lmp_cb or lsap_cb,&n; * and the event is stateless, therefore we can bypass both state machines&n; * and send the event direct to the LSAP user.&n; * Jean II&n; */
DECL|function|irlmp_status_indication
r_void
id|irlmp_status_indication
c_func
(paren
r_struct
id|lap_cb
op_star
id|self
comma
id|LINK_STATUS
id|link
comma
id|LOCK_STATUS
id|lock
)paren
(brace
r_struct
id|lsap_cb
op_star
id|next
suffix:semicolon
r_struct
id|lsap_cb
op_star
id|curr
suffix:semicolon
multiline_comment|/* Send status_indication to all LSAPs using this link */
id|curr
op_assign
(paren
r_struct
id|lsap_cb
op_star
)paren
id|hashbin_get_first
c_func
(paren
id|self-&gt;lsaps
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|NULL
op_ne
id|hashbin_find_next
c_func
(paren
id|self-&gt;lsaps
comma
(paren
r_int
)paren
id|curr
comma
l_int|NULL
comma
(paren
r_void
op_star
)paren
op_amp
id|next
)paren
)paren
(brace
id|ASSERT
c_func
(paren
id|curr-&gt;magic
op_eq
id|LMP_LSAP_MAGIC
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *  Inform service user if he has requested it&n;&t;&t; */
r_if
c_cond
(paren
id|curr-&gt;notify.status_indication
op_ne
l_int|NULL
)paren
id|curr-&gt;notify
dot
id|status_indication
c_func
(paren
id|curr-&gt;notify.instance
comma
id|link
comma
id|lock
)paren
suffix:semicolon
r_else
id|IRDA_DEBUG
c_func
(paren
l_int|2
comma
l_string|&quot;%s(), no handler&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
id|curr
op_assign
id|next
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Receive flow control indication from LAP.&n; * LAP want us to send it one more frame. We implement a simple round&n; * robin scheduler between the active sockets so that we get a bit of&n; * fairness. Note that the round robin is far from perfect, but it&squot;s&n; * better than nothing.&n; * We then poll the selected socket so that we can do synchronous&n; * refilling of IrLAP (which allow to minimise the number of buffers).&n; * Jean II&n; */
DECL|function|irlmp_flow_indication
r_void
id|irlmp_flow_indication
c_func
(paren
r_struct
id|lap_cb
op_star
id|self
comma
id|LOCAL_FLOW
id|flow
)paren
(brace
r_struct
id|lsap_cb
op_star
id|next
suffix:semicolon
r_struct
id|lsap_cb
op_star
id|curr
suffix:semicolon
r_int
id|lsap_todo
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|LMP_LAP_MAGIC
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|flow
op_eq
id|FLOW_START
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
multiline_comment|/* Get the number of lsap. That&squot;s the only safe way to know&n;&t; * that we have looped around... - Jean II */
id|lsap_todo
op_assign
id|HASHBIN_GET_SIZE
c_func
(paren
id|self-&gt;lsaps
)paren
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|4
comma
l_string|&quot;%s() : %d lsaps to scan&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|lsap_todo
)paren
suffix:semicolon
multiline_comment|/* Poll lsap in order until the queue is full or until we&n;&t; * tried them all.&n;&t; * Most often, the current LSAP will have something to send,&n;&t; * so we will go through this loop only once. - Jean II */
r_while
c_loop
(paren
(paren
id|lsap_todo
op_decrement
)paren
op_logical_and
(paren
id|IRLAP_GET_TX_QUEUE_LEN
c_func
(paren
id|self-&gt;irlap
)paren
OL
id|LAP_HIGH_THRESHOLD
)paren
)paren
(brace
multiline_comment|/* Try to find the next lsap we should poll. */
id|next
op_assign
id|self-&gt;flow_next
suffix:semicolon
multiline_comment|/* If we have no lsap, restart from first one */
r_if
c_cond
(paren
id|next
op_eq
l_int|NULL
)paren
(brace
id|next
op_assign
(paren
r_struct
id|lsap_cb
op_star
)paren
id|hashbin_get_first
c_func
(paren
id|self-&gt;lsaps
)paren
suffix:semicolon
)brace
multiline_comment|/* Verify current one and find the next one */
id|curr
op_assign
id|hashbin_find_next
c_func
(paren
id|self-&gt;lsaps
comma
(paren
r_int
)paren
id|next
comma
l_int|NULL
comma
(paren
r_void
op_star
)paren
op_amp
id|self-&gt;flow_next
)paren
suffix:semicolon
multiline_comment|/* Uh-oh... Paranoia */
r_if
c_cond
(paren
id|curr
op_eq
l_int|NULL
)paren
(brace
r_break
suffix:semicolon
)brace
id|IRDA_DEBUG
c_func
(paren
l_int|4
comma
l_string|&quot;%s() : curr is %p, next was %p and is now %p, still %d to go - queue len = %d&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|curr
comma
id|next
comma
id|self-&gt;flow_next
comma
id|lsap_todo
comma
id|IRLAP_GET_TX_QUEUE_LEN
c_func
(paren
id|self-&gt;irlap
)paren
)paren
suffix:semicolon
multiline_comment|/* Inform lsap user that it can send one more packet. */
r_if
c_cond
(paren
id|curr-&gt;notify.flow_indication
op_ne
l_int|NULL
)paren
id|curr-&gt;notify
dot
id|flow_indication
c_func
(paren
id|curr-&gt;notify.instance
comma
id|curr
comma
id|flow
)paren
suffix:semicolon
r_else
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;%s(), no handler&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
)brace
)brace
macro_line|#if 0
multiline_comment|/*&n; * Function irlmp_hint_to_service (hint)&n; *&n; *    Returns a list of all servics contained in the given hint bits. This&n; *    function assumes that the hint bits have the size of two bytes only&n; */
id|__u8
op_star
id|irlmp_hint_to_service
c_func
(paren
id|__u8
op_star
id|hint
)paren
(brace
id|__u8
op_star
id|service
suffix:semicolon
r_int
id|i
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Allocate array to store services in. 16 entries should be safe&n;&t; * since we currently only support 2 hint bytes&n;&t; */
id|service
op_assign
id|kmalloc
c_func
(paren
l_int|16
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|service
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;%s(), Unable to kmalloc!&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|hint
(braket
l_int|0
)braket
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;&lt;None&gt;&bslash;n&quot;
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|service
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hint
(braket
l_int|0
)braket
op_amp
id|HINT_PNP
)paren
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;PnP Compatible &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hint
(braket
l_int|0
)braket
op_amp
id|HINT_PDA
)paren
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;PDA/Palmtop &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hint
(braket
l_int|0
)braket
op_amp
id|HINT_COMPUTER
)paren
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;Computer &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hint
(braket
l_int|0
)braket
op_amp
id|HINT_PRINTER
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;Printer &quot;
)paren
suffix:semicolon
id|service
(braket
id|i
op_increment
)braket
op_assign
id|S_PRINTER
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hint
(braket
l_int|0
)braket
op_amp
id|HINT_MODEM
)paren
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;Modem &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hint
(braket
l_int|0
)braket
op_amp
id|HINT_FAX
)paren
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;Fax &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hint
(braket
l_int|0
)braket
op_amp
id|HINT_LAN
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;LAN Access &quot;
)paren
suffix:semicolon
id|service
(braket
id|i
op_increment
)braket
op_assign
id|S_LAN
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  Test if extension byte exists. This byte will usually be&n;&t; *  there, but this is not really required by the standard.&n;&t; *  (IrLMP p. 29)&n;&t; */
r_if
c_cond
(paren
id|hint
(braket
l_int|0
)braket
op_amp
id|HINT_EXTENSION
)paren
(brace
r_if
c_cond
(paren
id|hint
(braket
l_int|1
)braket
op_amp
id|HINT_TELEPHONY
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;Telephony &quot;
)paren
suffix:semicolon
id|service
(braket
id|i
op_increment
)braket
op_assign
id|S_TELEPHONY
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hint
(braket
l_int|1
)braket
op_amp
id|HINT_FILE_SERVER
)paren
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;File Server &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hint
(braket
l_int|1
)braket
op_amp
id|HINT_COMM
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;IrCOMM &quot;
)paren
suffix:semicolon
id|service
(braket
id|i
op_increment
)braket
op_assign
id|S_COMM
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hint
(braket
l_int|1
)braket
op_amp
id|HINT_OBEX
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;IrOBEX &quot;
)paren
suffix:semicolon
id|service
(braket
id|i
op_increment
)braket
op_assign
id|S_OBEX
suffix:semicolon
)brace
)brace
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* So that client can be notified about any discovery */
id|service
(braket
id|i
op_increment
)braket
op_assign
id|S_ANY
suffix:semicolon
id|service
(braket
id|i
)braket
op_assign
id|S_END
suffix:semicolon
r_return
id|service
suffix:semicolon
)brace
macro_line|#endif
DECL|variable|service_hint_mapping
r_static
r_const
id|__u16
id|service_hint_mapping
(braket
id|S_END
)braket
(braket
l_int|2
)braket
op_assign
(brace
(brace
id|HINT_PNP
comma
l_int|0
)brace
comma
multiline_comment|/* S_PNP */
(brace
id|HINT_PDA
comma
l_int|0
)brace
comma
multiline_comment|/* S_PDA */
(brace
id|HINT_COMPUTER
comma
l_int|0
)brace
comma
multiline_comment|/* S_COMPUTER */
(brace
id|HINT_PRINTER
comma
l_int|0
)brace
comma
multiline_comment|/* S_PRINTER */
(brace
id|HINT_MODEM
comma
l_int|0
)brace
comma
multiline_comment|/* S_MODEM */
(brace
id|HINT_FAX
comma
l_int|0
)brace
comma
multiline_comment|/* S_FAX */
(brace
id|HINT_LAN
comma
l_int|0
)brace
comma
multiline_comment|/* S_LAN */
(brace
id|HINT_EXTENSION
comma
id|HINT_TELEPHONY
)brace
comma
multiline_comment|/* S_TELEPHONY */
(brace
id|HINT_EXTENSION
comma
id|HINT_COMM
)brace
comma
multiline_comment|/* S_COMM */
(brace
id|HINT_EXTENSION
comma
id|HINT_OBEX
)brace
comma
multiline_comment|/* S_OBEX */
(brace
l_int|0xFF
comma
l_int|0xFF
)brace
comma
multiline_comment|/* S_ANY */
)brace
suffix:semicolon
multiline_comment|/*&n; * Function irlmp_service_to_hint (service)&n; *&n; *    Converts a service type, to a hint bit&n; *&n; *    Returns: a 16 bit hint value, with the service bit set&n; */
DECL|function|irlmp_service_to_hint
id|__u16
id|irlmp_service_to_hint
c_func
(paren
r_int
id|service
)paren
(brace
id|__u16_host_order
id|hint
suffix:semicolon
id|hint.byte
(braket
l_int|0
)braket
op_assign
id|service_hint_mapping
(braket
id|service
)braket
(braket
l_int|0
)braket
suffix:semicolon
id|hint.byte
(braket
l_int|1
)braket
op_assign
id|service_hint_mapping
(braket
id|service
)braket
(braket
l_int|1
)braket
suffix:semicolon
r_return
id|hint.word
suffix:semicolon
)brace
DECL|variable|irlmp_service_to_hint
id|EXPORT_SYMBOL
c_func
(paren
id|irlmp_service_to_hint
)paren
suffix:semicolon
multiline_comment|/*&n; * Function irlmp_register_service (service)&n; *&n; *    Register local service with IrLMP&n; *&n; */
DECL|function|irlmp_register_service
r_void
op_star
id|irlmp_register_service
c_func
(paren
id|__u16
id|hints
)paren
(brace
id|irlmp_service_t
op_star
id|service
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|4
comma
l_string|&quot;%s(), hints = %04x&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|hints
)paren
suffix:semicolon
multiline_comment|/* Make a new registration */
id|service
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|irlmp_service_t
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|service
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;%s(), Unable to kmalloc!&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|service-&gt;hints.word
op_assign
id|hints
suffix:semicolon
id|hashbin_insert
c_func
(paren
id|irlmp-&gt;services
comma
(paren
id|irda_queue_t
op_star
)paren
id|service
comma
(paren
r_int
)paren
id|service
comma
l_int|NULL
)paren
suffix:semicolon
id|irlmp-&gt;hints.word
op_or_assign
id|hints
suffix:semicolon
r_return
(paren
r_void
op_star
)paren
id|service
suffix:semicolon
)brace
DECL|variable|irlmp_register_service
id|EXPORT_SYMBOL
c_func
(paren
id|irlmp_register_service
)paren
suffix:semicolon
multiline_comment|/*&n; * Function irlmp_unregister_service (handle)&n; *&n; *    Unregister service with IrLMP.&n; *&n; *    Returns: 0 on success, -1 on error&n; */
DECL|function|irlmp_unregister_service
r_int
id|irlmp_unregister_service
c_func
(paren
r_void
op_star
id|handle
)paren
(brace
id|irlmp_service_t
op_star
id|service
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|4
comma
l_string|&quot;%s()&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|handle
)paren
r_return
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* Caller may call with invalid handle (it&squot;s legal) - Jean II */
id|service
op_assign
id|hashbin_lock_find
c_func
(paren
id|irlmp-&gt;services
comma
(paren
r_int
)paren
id|handle
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|service
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;%s(), Unknown service!&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|hashbin_remove_this
c_func
(paren
id|irlmp-&gt;services
comma
(paren
id|irda_queue_t
op_star
)paren
id|service
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|service
)paren
suffix:semicolon
multiline_comment|/* Remove old hint bits */
id|irlmp-&gt;hints.word
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Refresh current hint bits */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|irlmp-&gt;services-&gt;hb_spinlock
comma
id|flags
)paren
suffix:semicolon
id|service
op_assign
(paren
id|irlmp_service_t
op_star
)paren
id|hashbin_get_first
c_func
(paren
id|irlmp-&gt;services
)paren
suffix:semicolon
r_while
c_loop
(paren
id|service
)paren
(brace
id|irlmp-&gt;hints.word
op_or_assign
id|service-&gt;hints.word
suffix:semicolon
id|service
op_assign
(paren
id|irlmp_service_t
op_star
)paren
id|hashbin_get_next
c_func
(paren
id|irlmp-&gt;services
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|irlmp-&gt;services-&gt;hb_spinlock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|irlmp_unregister_service
id|EXPORT_SYMBOL
c_func
(paren
id|irlmp_unregister_service
)paren
suffix:semicolon
multiline_comment|/*&n; * Function irlmp_register_client (hint_mask, callback1, callback2)&n; *&n; *    Register a local client with IrLMP&n; *&t;First callback is selective discovery (based on hints)&n; *&t;Second callback is for selective discovery expiries&n; *&n; *    Returns: handle &gt; 0 on success, 0 on error&n; */
DECL|function|irlmp_register_client
r_void
op_star
id|irlmp_register_client
c_func
(paren
id|__u16
id|hint_mask
comma
id|DISCOVERY_CALLBACK1
id|disco_clb
comma
id|DISCOVERY_CALLBACK2
id|expir_clb
comma
r_void
op_star
id|priv
)paren
(brace
id|irlmp_client_t
op_star
id|client
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;%s()&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|irlmp
op_ne
l_int|NULL
comma
r_return
l_int|NULL
suffix:semicolon
)paren
suffix:semicolon
multiline_comment|/* Make a new registration */
id|client
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|irlmp_client_t
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|client
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;%s(), Unable to kmalloc!&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Register the details */
id|client-&gt;hint_mask.word
op_assign
id|hint_mask
suffix:semicolon
id|client-&gt;disco_callback
op_assign
id|disco_clb
suffix:semicolon
id|client-&gt;expir_callback
op_assign
id|expir_clb
suffix:semicolon
id|client-&gt;priv
op_assign
id|priv
suffix:semicolon
id|hashbin_insert
c_func
(paren
id|irlmp-&gt;clients
comma
(paren
id|irda_queue_t
op_star
)paren
id|client
comma
(paren
r_int
)paren
id|client
comma
l_int|NULL
)paren
suffix:semicolon
r_return
(paren
r_void
op_star
)paren
id|client
suffix:semicolon
)brace
DECL|variable|irlmp_register_client
id|EXPORT_SYMBOL
c_func
(paren
id|irlmp_register_client
)paren
suffix:semicolon
multiline_comment|/*&n; * Function irlmp_update_client (handle, hint_mask, callback1, callback2)&n; *&n; *    Updates specified client (handle) with possibly new hint_mask and&n; *    callback&n; *&n; *    Returns: 0 on success, -1 on error&n; */
DECL|function|irlmp_update_client
r_int
id|irlmp_update_client
c_func
(paren
r_void
op_star
id|handle
comma
id|__u16
id|hint_mask
comma
id|DISCOVERY_CALLBACK1
id|disco_clb
comma
id|DISCOVERY_CALLBACK2
id|expir_clb
comma
r_void
op_star
id|priv
)paren
(brace
id|irlmp_client_t
op_star
id|client
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|handle
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|client
op_assign
id|hashbin_lock_find
c_func
(paren
id|irlmp-&gt;clients
comma
(paren
r_int
)paren
id|handle
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|client
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;%s(), Unknown client!&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|client-&gt;hint_mask.word
op_assign
id|hint_mask
suffix:semicolon
id|client-&gt;disco_callback
op_assign
id|disco_clb
suffix:semicolon
id|client-&gt;expir_callback
op_assign
id|expir_clb
suffix:semicolon
id|client-&gt;priv
op_assign
id|priv
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|irlmp_update_client
id|EXPORT_SYMBOL
c_func
(paren
id|irlmp_update_client
)paren
suffix:semicolon
multiline_comment|/*&n; * Function irlmp_unregister_client (handle)&n; *&n; *    Returns: 0 on success, -1 on error&n; *&n; */
DECL|function|irlmp_unregister_client
r_int
id|irlmp_unregister_client
c_func
(paren
r_void
op_star
id|handle
)paren
(brace
r_struct
id|irlmp_client
op_star
id|client
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|4
comma
l_string|&quot;%s()&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|handle
)paren
r_return
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* Caller may call with invalid handle (it&squot;s legal) - Jean II */
id|client
op_assign
id|hashbin_lock_find
c_func
(paren
id|irlmp-&gt;clients
comma
(paren
r_int
)paren
id|handle
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|client
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;%s(), Unknown client!&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|IRDA_DEBUG
c_func
(paren
l_int|4
comma
l_string|&quot;%s(), removing client!&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
id|hashbin_remove_this
c_func
(paren
id|irlmp-&gt;clients
comma
(paren
id|irda_queue_t
op_star
)paren
id|client
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|client
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|irlmp_unregister_client
id|EXPORT_SYMBOL
c_func
(paren
id|irlmp_unregister_client
)paren
suffix:semicolon
multiline_comment|/*&n; * Function irlmp_slsap_inuse (slsap)&n; *&n; *    Check if the given source LSAP selector is in use&n; *&n; * This function is clearly not very efficient. On the mitigating side, the&n; * stack make sure that in 99% of the cases, we are called only once&n; * for each socket allocation. We could probably keep a bitmap&n; * of the allocated LSAP, but I&squot;m not sure the complexity is worth it.&n; * Jean II&n; */
DECL|function|irlmp_slsap_inuse
r_static
r_int
id|irlmp_slsap_inuse
c_func
(paren
id|__u8
id|slsap_sel
)paren
(brace
r_struct
id|lsap_cb
op_star
id|self
suffix:semicolon
r_struct
id|lap_cb
op_star
id|lap
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|ASSERT
c_func
(paren
id|irlmp
op_ne
l_int|NULL
comma
r_return
id|TRUE
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|irlmp-&gt;magic
op_eq
id|LMP_MAGIC
comma
r_return
id|TRUE
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|slsap_sel
op_ne
id|LSAP_ANY
comma
r_return
id|TRUE
suffix:semicolon
)paren
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|4
comma
l_string|&quot;%s()&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_IRDA_ULTRA
multiline_comment|/* Accept all bindings to the connectionless LSAP */
r_if
c_cond
(paren
id|slsap_sel
op_eq
id|LSAP_CONNLESS
)paren
r_return
id|FALSE
suffix:semicolon
macro_line|#endif /* CONFIG_IRDA_ULTRA */
multiline_comment|/* Valid values are between 0 and 127 (0x0-0x6F) */
r_if
c_cond
(paren
id|slsap_sel
OG
id|LSAP_MAX
)paren
r_return
id|TRUE
suffix:semicolon
multiline_comment|/*&n;&t; *  Check if slsap is already in use. To do this we have to loop over&n;&t; *  every IrLAP connection and check every LSAP associated with each&n;&t; *  the connection.&n;&t; */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|irlmp-&gt;links-&gt;hb_spinlock
comma
id|flags
)paren
suffix:semicolon
id|lap
op_assign
(paren
r_struct
id|lap_cb
op_star
)paren
id|hashbin_get_first
c_func
(paren
id|irlmp-&gt;links
)paren
suffix:semicolon
r_while
c_loop
(paren
id|lap
op_ne
l_int|NULL
)paren
(brace
id|ASSERT
c_func
(paren
id|lap-&gt;magic
op_eq
id|LMP_LAP_MAGIC
comma
r_goto
id|errlap
suffix:semicolon
)paren
suffix:semicolon
multiline_comment|/* Careful for priority inversions here !&n;&t;&t; * irlmp-&gt;links is never taken while another IrDA&n;&t;&t; * spinlock is held, so we are safe. Jean II */
id|spin_lock
c_func
(paren
op_amp
id|lap-&gt;lsaps-&gt;hb_spinlock
)paren
suffix:semicolon
multiline_comment|/* For this IrLAP, check all the LSAPs */
id|self
op_assign
(paren
r_struct
id|lsap_cb
op_star
)paren
id|hashbin_get_first
c_func
(paren
id|lap-&gt;lsaps
)paren
suffix:semicolon
r_while
c_loop
(paren
id|self
op_ne
l_int|NULL
)paren
(brace
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|LMP_LSAP_MAGIC
comma
r_goto
id|errlsap
suffix:semicolon
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|self-&gt;slsap_sel
op_eq
id|slsap_sel
)paren
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|4
comma
l_string|&quot;Source LSAP selector=%02x in use&bslash;n&quot;
comma
id|self-&gt;slsap_sel
)paren
suffix:semicolon
r_goto
id|errlsap
suffix:semicolon
)brace
id|self
op_assign
(paren
r_struct
id|lsap_cb
op_star
)paren
id|hashbin_get_next
c_func
(paren
id|lap-&gt;lsaps
)paren
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|lap-&gt;lsaps-&gt;hb_spinlock
)paren
suffix:semicolon
multiline_comment|/* Next LAP */
id|lap
op_assign
(paren
r_struct
id|lap_cb
op_star
)paren
id|hashbin_get_next
c_func
(paren
id|irlmp-&gt;links
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|irlmp-&gt;links-&gt;hb_spinlock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Server sockets are typically waiting for connections and&n;&t; * therefore reside in the unconnected list. We don&squot;t want&n;&t; * to give out their LSAPs for obvious reasons...&n;&t; * Jean II&n;&t; */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|irlmp-&gt;unconnected_lsaps-&gt;hb_spinlock
comma
id|flags
)paren
suffix:semicolon
id|self
op_assign
(paren
r_struct
id|lsap_cb
op_star
)paren
id|hashbin_get_first
c_func
(paren
id|irlmp-&gt;unconnected_lsaps
)paren
suffix:semicolon
r_while
c_loop
(paren
id|self
op_ne
l_int|NULL
)paren
(brace
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|LMP_LSAP_MAGIC
comma
r_goto
id|erruncon
suffix:semicolon
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|self-&gt;slsap_sel
op_eq
id|slsap_sel
)paren
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|4
comma
l_string|&quot;Source LSAP selector=%02x in use (unconnected)&bslash;n&quot;
comma
id|self-&gt;slsap_sel
)paren
suffix:semicolon
r_goto
id|erruncon
suffix:semicolon
)brace
id|self
op_assign
(paren
r_struct
id|lsap_cb
op_star
)paren
id|hashbin_get_next
c_func
(paren
id|irlmp-&gt;unconnected_lsaps
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|irlmp-&gt;unconnected_lsaps-&gt;hb_spinlock
comma
id|flags
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
multiline_comment|/* Error exit from within one of the two nested loops.&n;&t; * Make sure we release the right spinlock in the righ order.&n;&t; * Jean II */
id|errlsap
suffix:colon
id|spin_unlock
c_func
(paren
op_amp
id|lap-&gt;lsaps-&gt;hb_spinlock
)paren
suffix:semicolon
id|errlap
suffix:colon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|irlmp-&gt;links-&gt;hb_spinlock
comma
id|flags
)paren
suffix:semicolon
r_return
id|TRUE
suffix:semicolon
multiline_comment|/* Error exit from within the unconnected loop.&n;&t; * Just one spinlock to release... Jean II */
id|erruncon
suffix:colon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|irlmp-&gt;unconnected_lsaps-&gt;hb_spinlock
comma
id|flags
)paren
suffix:semicolon
r_return
id|TRUE
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irlmp_find_free_slsap ()&n; *&n; *    Find a free source LSAP to use. This function is called if the service&n; *    user has requested a source LSAP equal to LM_ANY&n; */
DECL|function|irlmp_find_free_slsap
r_static
id|__u8
id|irlmp_find_free_slsap
c_func
(paren
r_void
)paren
(brace
id|__u8
id|lsap_sel
suffix:semicolon
r_int
id|wrapped
op_assign
l_int|0
suffix:semicolon
id|ASSERT
c_func
(paren
id|irlmp
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|irlmp-&gt;magic
op_eq
id|LMP_MAGIC
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
multiline_comment|/* Most users don&squot;t really care which LSAPs they are given,&n;&t; * and therefore we automatically give them a free LSAP.&n;&t; * This function try to find a suitable LSAP, i.e. which is&n;&t; * not in use and is within the acceptable range. Jean II */
r_do
(brace
multiline_comment|/* Always increment to LSAP number before using it.&n;&t;&t; * In theory, we could reuse the last LSAP number, as long&n;&t;&t; * as it is no longer in use. Some IrDA stack do that.&n;&t;&t; * However, the previous socket may be half closed, i.e.&n;&t;&t; * we closed it, we think it&squot;s no longer in use, but the&n;&t;&t; * other side did not receive our close and think it&squot;s&n;&t;&t; * active and still send data on it.&n;&t;&t; * This is similar to what is done with PIDs and TCP ports.&n;&t;&t; * Also, this reduce the number of calls to irlmp_slsap_inuse()&n;&t;&t; * which is an expensive function to call.&n;&t;&t; * Jean II */
id|irlmp-&gt;last_lsap_sel
op_increment
suffix:semicolon
multiline_comment|/* Check if we need to wraparound (0x70-0x7f are reserved) */
r_if
c_cond
(paren
id|irlmp-&gt;last_lsap_sel
OG
id|LSAP_MAX
)paren
(brace
multiline_comment|/* 0x00-0x10 are also reserved for well know ports */
id|irlmp-&gt;last_lsap_sel
op_assign
l_int|0x10
suffix:semicolon
multiline_comment|/* Make sure we terminate the loop */
r_if
c_cond
(paren
id|wrapped
op_increment
)paren
(brace
id|ERROR
c_func
(paren
l_string|&quot;%s: no more free LSAPs !&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/* If the LSAP is in use, try the next one.&n;&t;&t; * Despite the autoincrement, we need to check if the lsap&n;&t;&t; * is really in use or not, first because LSAP may be&n;&t;&t; * directly allocated in irlmp_open_lsap(), and also because&n;&t;&t; * we may wraparound on old sockets. Jean II */
)brace
r_while
c_loop
(paren
id|irlmp_slsap_inuse
c_func
(paren
id|irlmp-&gt;last_lsap_sel
)paren
)paren
suffix:semicolon
multiline_comment|/* Got it ! */
id|lsap_sel
op_assign
id|irlmp-&gt;last_lsap_sel
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|4
comma
l_string|&quot;%s(), found free lsap_sel=%02x&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|lsap_sel
)paren
suffix:semicolon
r_return
id|lsap_sel
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irlmp_convert_lap_reason (lap_reason)&n; *&n; *    Converts IrLAP disconnect reason codes to IrLMP disconnect reason&n; *    codes&n; *&n; */
DECL|function|irlmp_convert_lap_reason
id|LM_REASON
id|irlmp_convert_lap_reason
c_func
(paren
id|LAP_REASON
id|lap_reason
)paren
(brace
r_int
id|reason
op_assign
id|LM_LAP_DISCONNECT
suffix:semicolon
r_switch
c_cond
(paren
id|lap_reason
)paren
(brace
r_case
id|LAP_DISC_INDICATION
suffix:colon
multiline_comment|/* Received a disconnect request from peer */
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;%s(), LAP_DISC_INDICATION&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
id|reason
op_assign
id|LM_USER_REQUEST
suffix:semicolon
r_break
suffix:semicolon
r_case
id|LAP_NO_RESPONSE
suffix:colon
multiline_comment|/* To many retransmits without response */
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;%s(), LAP_NO_RESPONSE&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
id|reason
op_assign
id|LM_LAP_DISCONNECT
suffix:semicolon
r_break
suffix:semicolon
r_case
id|LAP_RESET_INDICATION
suffix:colon
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;%s(), LAP_RESET_INDICATION&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
id|reason
op_assign
id|LM_LAP_RESET
suffix:semicolon
r_break
suffix:semicolon
r_case
id|LAP_FOUND_NONE
suffix:colon
r_case
id|LAP_MEDIA_BUSY
suffix:colon
r_case
id|LAP_PRIMARY_CONFLICT
suffix:colon
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;%s(), LAP_FOUND_NONE, LAP_MEDIA_BUSY or LAP_PRIMARY_CONFLICT&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
id|reason
op_assign
id|LM_CONNECT_FAILURE
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;%s(), Unknow IrLAP disconnect reason %d!&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|lap_reason
)paren
suffix:semicolon
id|reason
op_assign
id|LM_LAP_DISCONNECT
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|reason
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_PROC_FS
DECL|struct|irlmp_iter_state
r_struct
id|irlmp_iter_state
(brace
DECL|member|hashbin
id|hashbin_t
op_star
id|hashbin
suffix:semicolon
)brace
suffix:semicolon
DECL|macro|LSAP_START_TOKEN
mdefine_line|#define LSAP_START_TOKEN&t;((void *)1)
DECL|macro|LINK_START_TOKEN
mdefine_line|#define LINK_START_TOKEN&t;((void *)2)
DECL|function|irlmp_seq_hb_idx
r_static
r_void
op_star
id|irlmp_seq_hb_idx
c_func
(paren
r_struct
id|irlmp_iter_state
op_star
id|iter
comma
id|loff_t
op_star
id|off
)paren
(brace
r_void
op_star
id|element
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|iter-&gt;hashbin-&gt;hb_spinlock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|element
op_assign
id|hashbin_get_first
c_func
(paren
id|iter-&gt;hashbin
)paren
suffix:semicolon
id|element
op_ne
l_int|NULL
suffix:semicolon
id|element
op_assign
id|hashbin_get_next
c_func
(paren
id|iter-&gt;hashbin
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|off
op_logical_or
op_star
id|off
op_decrement
op_eq
l_int|0
)paren
(brace
multiline_comment|/* NB: hashbin left locked */
r_return
id|element
suffix:semicolon
)brace
)brace
id|spin_unlock_irq
c_func
(paren
op_amp
id|iter-&gt;hashbin-&gt;hb_spinlock
)paren
suffix:semicolon
id|iter-&gt;hashbin
op_assign
l_int|NULL
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|irlmp_seq_start
r_static
r_void
op_star
id|irlmp_seq_start
c_func
(paren
r_struct
id|seq_file
op_star
id|seq
comma
id|loff_t
op_star
id|pos
)paren
(brace
r_struct
id|irlmp_iter_state
op_star
id|iter
op_assign
id|seq
op_member_access_from_pointer
r_private
suffix:semicolon
r_void
op_star
id|v
suffix:semicolon
id|loff_t
id|off
op_assign
op_star
id|pos
suffix:semicolon
id|iter-&gt;hashbin
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|off
op_decrement
op_eq
l_int|0
)paren
r_return
id|LSAP_START_TOKEN
suffix:semicolon
id|iter-&gt;hashbin
op_assign
id|irlmp-&gt;unconnected_lsaps
suffix:semicolon
id|v
op_assign
id|irlmp_seq_hb_idx
c_func
(paren
id|iter
comma
op_amp
id|off
)paren
suffix:semicolon
r_if
c_cond
(paren
id|v
)paren
r_return
id|v
suffix:semicolon
r_if
c_cond
(paren
id|off
op_decrement
op_eq
l_int|0
)paren
r_return
id|LINK_START_TOKEN
suffix:semicolon
id|iter-&gt;hashbin
op_assign
id|irlmp-&gt;links
suffix:semicolon
r_return
id|irlmp_seq_hb_idx
c_func
(paren
id|iter
comma
op_amp
id|off
)paren
suffix:semicolon
)brace
DECL|function|irlmp_seq_next
r_static
r_void
op_star
id|irlmp_seq_next
c_func
(paren
r_struct
id|seq_file
op_star
id|seq
comma
r_void
op_star
id|v
comma
id|loff_t
op_star
id|pos
)paren
(brace
r_struct
id|irlmp_iter_state
op_star
id|iter
op_assign
id|seq
op_member_access_from_pointer
r_private
suffix:semicolon
op_increment
op_star
id|pos
suffix:semicolon
r_if
c_cond
(paren
id|v
op_eq
id|LSAP_START_TOKEN
)paren
(brace
multiline_comment|/* start of list of lsaps */
id|iter-&gt;hashbin
op_assign
id|irlmp-&gt;unconnected_lsaps
suffix:semicolon
id|v
op_assign
id|irlmp_seq_hb_idx
c_func
(paren
id|iter
comma
l_int|NULL
)paren
suffix:semicolon
r_return
id|v
ques
c_cond
id|v
suffix:colon
id|LINK_START_TOKEN
suffix:semicolon
)brace
r_if
c_cond
(paren
id|v
op_eq
id|LINK_START_TOKEN
)paren
(brace
multiline_comment|/* start of list of links */
id|iter-&gt;hashbin
op_assign
id|irlmp-&gt;links
suffix:semicolon
r_return
id|irlmp_seq_hb_idx
c_func
(paren
id|iter
comma
l_int|NULL
)paren
suffix:semicolon
)brace
id|v
op_assign
id|hashbin_get_next
c_func
(paren
id|iter-&gt;hashbin
)paren
suffix:semicolon
r_if
c_cond
(paren
id|v
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* no more in this hash bin */
id|spin_unlock_irq
c_func
(paren
op_amp
id|iter-&gt;hashbin-&gt;hb_spinlock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|iter-&gt;hashbin
op_eq
id|irlmp-&gt;unconnected_lsaps
)paren
id|v
op_assign
id|LINK_START_TOKEN
suffix:semicolon
id|iter-&gt;hashbin
op_assign
l_int|NULL
suffix:semicolon
)brace
r_return
id|v
suffix:semicolon
)brace
DECL|function|irlmp_seq_stop
r_static
r_void
id|irlmp_seq_stop
c_func
(paren
r_struct
id|seq_file
op_star
id|seq
comma
r_void
op_star
id|v
)paren
(brace
r_struct
id|irlmp_iter_state
op_star
id|iter
op_assign
id|seq
op_member_access_from_pointer
r_private
suffix:semicolon
r_if
c_cond
(paren
id|iter-&gt;hashbin
)paren
id|spin_unlock_irq
c_func
(paren
op_amp
id|iter-&gt;hashbin-&gt;hb_spinlock
)paren
suffix:semicolon
)brace
DECL|function|irlmp_seq_show
r_static
r_int
id|irlmp_seq_show
c_func
(paren
r_struct
id|seq_file
op_star
id|seq
comma
r_void
op_star
id|v
)paren
(brace
r_const
r_struct
id|irlmp_iter_state
op_star
id|iter
op_assign
id|seq
op_member_access_from_pointer
r_private
suffix:semicolon
r_struct
id|lsap_cb
op_star
id|self
op_assign
id|v
suffix:semicolon
r_if
c_cond
(paren
id|v
op_eq
id|LSAP_START_TOKEN
)paren
id|seq_puts
c_func
(paren
id|seq
comma
l_string|&quot;Unconnected LSAPs:&bslash;n&quot;
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|v
op_eq
id|LINK_START_TOKEN
)paren
id|seq_puts
c_func
(paren
id|seq
comma
l_string|&quot;&bslash;nRegistered Link Layers:&bslash;n&quot;
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|iter-&gt;hashbin
op_eq
id|irlmp-&gt;unconnected_lsaps
)paren
(brace
id|self
op_assign
id|v
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|LMP_LSAP_MAGIC
comma
r_return
op_minus
id|EINVAL
suffix:semicolon
)paren
suffix:semicolon
id|seq_printf
c_func
(paren
id|seq
comma
l_string|&quot;lsap state: %s, &quot;
comma
id|irlsap_state
(braket
id|self-&gt;lsap_state
)braket
)paren
suffix:semicolon
id|seq_printf
c_func
(paren
id|seq
comma
l_string|&quot;slsap_sel: %#02x, dlsap_sel: %#02x, &quot;
comma
id|self-&gt;slsap_sel
comma
id|self-&gt;dlsap_sel
)paren
suffix:semicolon
id|seq_printf
c_func
(paren
id|seq
comma
l_string|&quot;(%s)&quot;
comma
id|self-&gt;notify.name
)paren
suffix:semicolon
id|seq_printf
c_func
(paren
id|seq
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|iter-&gt;hashbin
op_eq
id|irlmp-&gt;links
)paren
(brace
r_struct
id|lap_cb
op_star
id|lap
op_assign
id|v
suffix:semicolon
id|seq_printf
c_func
(paren
id|seq
comma
l_string|&quot;lap state: %s, &quot;
comma
id|irlmp_state
(braket
id|lap-&gt;lap_state
)braket
)paren
suffix:semicolon
id|seq_printf
c_func
(paren
id|seq
comma
l_string|&quot;saddr: %#08x, daddr: %#08x, &quot;
comma
id|lap-&gt;saddr
comma
id|lap-&gt;daddr
)paren
suffix:semicolon
id|seq_printf
c_func
(paren
id|seq
comma
l_string|&quot;num lsaps: %d&quot;
comma
id|HASHBIN_GET_SIZE
c_func
(paren
id|lap-&gt;lsaps
)paren
)paren
suffix:semicolon
id|seq_printf
c_func
(paren
id|seq
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Careful for priority inversions here !&n;&t;&t; * All other uses of attrib spinlock are independent of&n;&t;&t; * the object spinlock, so we are safe. Jean II */
id|spin_lock
c_func
(paren
op_amp
id|lap-&gt;lsaps-&gt;hb_spinlock
)paren
suffix:semicolon
id|seq_printf
c_func
(paren
id|seq
comma
l_string|&quot;&bslash;n  Connected LSAPs:&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|self
op_assign
(paren
r_struct
id|lsap_cb
op_star
)paren
id|hashbin_get_first
c_func
(paren
id|lap-&gt;lsaps
)paren
suffix:semicolon
id|self
op_ne
l_int|NULL
suffix:semicolon
id|self
op_assign
(paren
r_struct
id|lsap_cb
op_star
)paren
id|hashbin_get_next
c_func
(paren
id|lap-&gt;lsaps
)paren
)paren
(brace
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|LMP_LSAP_MAGIC
comma
r_break
suffix:semicolon
)paren
suffix:semicolon
id|seq_printf
c_func
(paren
id|seq
comma
l_string|&quot;  lsap state: %s, &quot;
comma
id|irlsap_state
(braket
id|self-&gt;lsap_state
)braket
)paren
suffix:semicolon
id|seq_printf
c_func
(paren
id|seq
comma
l_string|&quot;slsap_sel: %#02x, dlsap_sel: %#02x, &quot;
comma
id|self-&gt;slsap_sel
comma
id|self-&gt;dlsap_sel
)paren
suffix:semicolon
id|seq_printf
c_func
(paren
id|seq
comma
l_string|&quot;(%s)&quot;
comma
id|self-&gt;notify.name
)paren
suffix:semicolon
id|seq_putc
c_func
(paren
id|seq
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|lap-&gt;lsaps-&gt;hb_spinlock
)paren
suffix:semicolon
id|seq_putc
c_func
(paren
id|seq
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
)brace
r_else
r_return
op_minus
id|EINVAL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|irlmp_seq_ops
r_static
r_struct
id|seq_operations
id|irlmp_seq_ops
op_assign
(brace
dot
id|start
op_assign
id|irlmp_seq_start
comma
dot
id|next
op_assign
id|irlmp_seq_next
comma
dot
id|stop
op_assign
id|irlmp_seq_stop
comma
dot
id|show
op_assign
id|irlmp_seq_show
comma
)brace
suffix:semicolon
DECL|function|irlmp_seq_open
r_static
r_int
id|irlmp_seq_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_struct
id|seq_file
op_star
id|seq
suffix:semicolon
r_int
id|rc
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_struct
id|irlmp_iter_state
op_star
id|s
suffix:semicolon
id|ASSERT
c_func
(paren
id|irlmp
op_ne
l_int|NULL
comma
r_return
op_minus
id|EINVAL
suffix:semicolon
)paren
suffix:semicolon
id|s
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|s
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|s
)paren
r_goto
id|out
suffix:semicolon
id|rc
op_assign
id|seq_open
c_func
(paren
id|file
comma
op_amp
id|irlmp_seq_ops
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_goto
id|out_kfree
suffix:semicolon
id|seq
op_assign
id|file-&gt;private_data
suffix:semicolon
id|seq
op_member_access_from_pointer
r_private
op_assign
id|s
suffix:semicolon
id|out
suffix:colon
r_return
id|rc
suffix:semicolon
id|out_kfree
suffix:colon
id|kfree
c_func
(paren
id|s
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
DECL|variable|irlmp_seq_fops
r_struct
id|file_operations
id|irlmp_seq_fops
op_assign
(brace
dot
id|owner
op_assign
id|THIS_MODULE
comma
dot
id|open
op_assign
id|irlmp_seq_open
comma
dot
id|read
op_assign
id|seq_read
comma
dot
id|llseek
op_assign
id|seq_lseek
comma
dot
id|release
op_assign
id|seq_release_private
comma
)brace
suffix:semicolon
macro_line|#endif /* PROC_FS */
eof
