multiline_comment|/*&n; *&t;IrNET protocol module : Synchronous PPP over an IrDA socket.&n; *&n; *&t;&t;Jean II - HPL `00 - &lt;jt@hpl.hp.com&gt;&n; *&n; * This file implement the IRDA interface of IrNET.&n; * Basically, we sit on top of IrTTP. We set up IrTTP, IrIAS properly,&n; * and exchange frames with IrTTP.&n; */
macro_line|#include &quot;irnet_irda.h&quot;&t;&t;/* Private header */
multiline_comment|/************************* CONTROL CHANNEL *************************/
multiline_comment|/*&n; * When ppp is not active, /dev/irnet act as a control channel.&n; * Writing allow to set up the IrDA destination of the IrNET channel,&n; * and any application may be read events happening on IrNET...&n; */
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Post an event to the control channel...&n; * Put the event in the log, and then wait all process blocked on read&n; * so they can read the log...&n; */
r_static
r_void
DECL|function|irnet_post_event
id|irnet_post_event
c_func
(paren
id|irnet_socket
op_star
id|ap
comma
id|irnet_event
id|event
comma
id|__u32
id|saddr
comma
id|__u32
id|daddr
comma
r_char
op_star
id|name
comma
id|__u16
id|hints
)paren
(brace
r_int
id|index
suffix:semicolon
multiline_comment|/* In the log */
id|DENTER
c_func
(paren
id|CTRL_TRACE
comma
l_string|&quot;(ap=0x%X, event=%d, daddr=%08x, name=``%s&squot;&squot;)&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|ap
comma
id|event
comma
id|daddr
comma
id|name
)paren
suffix:semicolon
multiline_comment|/* Protect this section via spinlock.&n;   * Note : as we are the only event producer, we only need to exclude&n;   * ourself when touching the log, which is nice and easy.&n;   */
id|spin_lock_bh
c_func
(paren
op_amp
id|irnet_events.spinlock
)paren
suffix:semicolon
multiline_comment|/* Copy the event in the log */
id|index
op_assign
id|irnet_events.index
suffix:semicolon
id|irnet_events.log
(braket
id|index
)braket
dot
id|event
op_assign
id|event
suffix:semicolon
id|irnet_events.log
(braket
id|index
)braket
dot
id|daddr
op_assign
id|daddr
suffix:semicolon
id|irnet_events.log
(braket
id|index
)braket
dot
id|saddr
op_assign
id|saddr
suffix:semicolon
multiline_comment|/* Try to copy IrDA nickname */
r_if
c_cond
(paren
id|name
)paren
(brace
id|strcpy
c_func
(paren
id|irnet_events.log
(braket
id|index
)braket
dot
id|name
comma
id|name
)paren
suffix:semicolon
)brace
r_else
id|irnet_events.log
(braket
id|index
)braket
dot
id|name
(braket
l_int|0
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
multiline_comment|/* Copy hints */
id|irnet_events.log
(braket
id|index
)braket
dot
id|hints.word
op_assign
id|hints
suffix:semicolon
multiline_comment|/* Try to get ppp unit number */
r_if
c_cond
(paren
(paren
id|ap
op_ne
(paren
id|irnet_socket
op_star
)paren
l_int|NULL
)paren
op_logical_and
(paren
id|ap-&gt;ppp_open
)paren
)paren
(brace
id|irnet_events.log
(braket
id|index
)braket
dot
id|unit
op_assign
id|ppp_unit_number
c_func
(paren
op_amp
id|ap-&gt;chan
)paren
suffix:semicolon
)brace
r_else
id|irnet_events.log
(braket
id|index
)braket
dot
id|unit
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* Increment the index&n;   * Note that we increment the index only after the event is written,&n;   * to make sure that the readers don&squot;t get garbage... */
id|irnet_events.index
op_assign
(paren
id|index
op_plus
l_int|1
)paren
op_mod
id|IRNET_MAX_EVENTS
suffix:semicolon
id|DEBUG
c_func
(paren
id|CTRL_INFO
comma
l_string|&quot;New event index is %d&bslash;n&quot;
comma
id|irnet_events.index
)paren
suffix:semicolon
multiline_comment|/* Spin lock end */
id|spin_unlock_bh
c_func
(paren
op_amp
id|irnet_events.spinlock
)paren
suffix:semicolon
multiline_comment|/* Now : wake up everybody waiting for events... */
id|wake_up_interruptible_all
c_func
(paren
op_amp
id|irnet_events.rwait
)paren
suffix:semicolon
id|DEXIT
c_func
(paren
id|CTRL_TRACE
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/************************* IRDA SUBROUTINES *************************/
multiline_comment|/*&n; * These are a bunch of subroutines called from other functions&n; * down there, mostly common code or to improve readability...&n; *&n; * Note : we duplicate quite heavily some routines of af_irda.c,&n; * because our input structure (self) is quite different&n; * (struct irnet instead of struct irda_sock), which make sharing&n; * the same code impossible (at least, without templates).&n; */
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Function irda_open_tsap (self)&n; *&n; *    Open local Transport Service Access Point (TSAP)&n; *&n; * Create a IrTTP instance for us and set all the IrTTP callbacks.&n; */
r_static
r_inline
r_int
DECL|function|irnet_open_tsap
id|irnet_open_tsap
c_func
(paren
id|irnet_socket
op_star
id|self
)paren
(brace
id|notify_t
id|notify
suffix:semicolon
multiline_comment|/* Callback structure */
id|DENTER
c_func
(paren
id|IRDA_SR_TRACE
comma
l_string|&quot;(self=0x%X)&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|self
)paren
suffix:semicolon
id|DABORT
c_func
(paren
id|self-&gt;tsap
op_ne
l_int|NULL
comma
op_minus
id|EBUSY
comma
id|IRDA_SR_ERROR
comma
l_string|&quot;Already busy !&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Initialize IrTTP callbacks to be used by the IrDA stack */
id|irda_notify_init
c_func
(paren
op_amp
id|notify
)paren
suffix:semicolon
id|notify.connect_confirm
op_assign
id|irnet_connect_confirm
suffix:semicolon
id|notify.connect_indication
op_assign
id|irnet_connect_indication
suffix:semicolon
id|notify.disconnect_indication
op_assign
id|irnet_disconnect_indication
suffix:semicolon
id|notify.data_indication
op_assign
id|irnet_data_indication
suffix:semicolon
multiline_comment|/*notify.udata_indication&t;= NULL;*/
id|notify.flow_indication
op_assign
id|irnet_flow_indication
suffix:semicolon
id|notify.status_indication
op_assign
id|irnet_status_indication
suffix:semicolon
id|notify.instance
op_assign
id|self
suffix:semicolon
id|strlcpy
c_func
(paren
id|notify.name
comma
id|IRNET_NOTIFY_NAME
comma
r_sizeof
(paren
id|notify.name
)paren
)paren
suffix:semicolon
multiline_comment|/* Open an IrTTP instance */
id|self-&gt;tsap
op_assign
id|irttp_open_tsap
c_func
(paren
id|LSAP_ANY
comma
id|DEFAULT_INITIAL_CREDIT
comma
op_amp
id|notify
)paren
suffix:semicolon
id|DABORT
c_func
(paren
id|self-&gt;tsap
op_eq
l_int|NULL
comma
op_minus
id|ENOMEM
comma
id|IRDA_SR_ERROR
comma
l_string|&quot;Unable to allocate TSAP !&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Remember which TSAP selector we actually got */
id|self-&gt;stsap_sel
op_assign
id|self-&gt;tsap-&gt;stsap_sel
suffix:semicolon
id|DEXIT
c_func
(paren
id|IRDA_SR_TRACE
comma
l_string|&quot; - tsap=0x%X, sel=0x%X&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|self-&gt;tsap
comma
id|self-&gt;stsap_sel
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Function irnet_ias_to_tsap (self, result, value)&n; *&n; *    Examine an IAS object and extract TSAP&n; *&n; * We do an IAP query to find the TSAP associated with the IrNET service.&n; * When IrIAP pass us the result of the query, this function look at&n; * the return values to check for failures and extract the TSAP if&n; * possible.&n; * Also deallocate value&n; * The failure is in self-&gt;errno&n; * Return TSAP or -1&n; */
r_static
r_inline
id|__u8
DECL|function|irnet_ias_to_tsap
id|irnet_ias_to_tsap
c_func
(paren
id|irnet_socket
op_star
id|self
comma
r_int
id|result
comma
r_struct
id|ias_value
op_star
id|value
)paren
(brace
id|__u8
id|dtsap_sel
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* TSAP we are looking for */
id|DENTER
c_func
(paren
id|IRDA_SR_TRACE
comma
l_string|&quot;(self=0x%X)&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|self
)paren
suffix:semicolon
multiline_comment|/* By default, no error */
id|self-&gt;errno
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Check if request succeeded */
r_switch
c_cond
(paren
id|result
)paren
(brace
multiline_comment|/* Standard errors : service not available */
r_case
id|IAS_CLASS_UNKNOWN
suffix:colon
r_case
id|IAS_ATTRIB_UNKNOWN
suffix:colon
id|DEBUG
c_func
(paren
id|IRDA_SR_INFO
comma
l_string|&quot;IAS object doesn&squot;t exist ! (%d)&bslash;n&quot;
comma
id|result
)paren
suffix:semicolon
id|self-&gt;errno
op_assign
op_minus
id|EADDRNOTAVAIL
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* Other errors, most likely IrDA stack failure */
r_default
suffix:colon
id|DEBUG
c_func
(paren
id|IRDA_SR_INFO
comma
l_string|&quot;IAS query failed ! (%d)&bslash;n&quot;
comma
id|result
)paren
suffix:semicolon
id|self-&gt;errno
op_assign
op_minus
id|EHOSTUNREACH
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* Success : we got what we wanted */
r_case
id|IAS_SUCCESS
suffix:colon
r_break
suffix:semicolon
)brace
multiline_comment|/* Check what was returned to us */
r_if
c_cond
(paren
id|value
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* What type of argument have we got ? */
r_switch
c_cond
(paren
id|value-&gt;type
)paren
(brace
r_case
id|IAS_INTEGER
suffix:colon
id|DEBUG
c_func
(paren
id|IRDA_SR_INFO
comma
l_string|&quot;result=%d&bslash;n&quot;
comma
id|value-&gt;t.integer
)paren
suffix:semicolon
r_if
c_cond
(paren
id|value-&gt;t.integer
op_ne
op_minus
l_int|1
)paren
(brace
multiline_comment|/* Get the remote TSAP selector */
id|dtsap_sel
op_assign
id|value-&gt;t.integer
suffix:semicolon
)brace
r_else
id|self-&gt;errno
op_assign
op_minus
id|EADDRNOTAVAIL
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|self-&gt;errno
op_assign
op_minus
id|EADDRNOTAVAIL
suffix:semicolon
id|DERROR
c_func
(paren
id|IRDA_SR_ERROR
comma
l_string|&quot;bad type ! (0x%X)&bslash;n&quot;
comma
id|value-&gt;type
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Cleanup */
id|irias_delete_value
c_func
(paren
id|value
)paren
suffix:semicolon
)brace
r_else
multiline_comment|/* value == NULL */
(brace
multiline_comment|/* Nothing returned to us - usually result != SUCCESS */
r_if
c_cond
(paren
op_logical_neg
(paren
id|self-&gt;errno
)paren
)paren
(brace
id|DERROR
c_func
(paren
id|IRDA_SR_ERROR
comma
l_string|&quot;IrDA bug : result == SUCCESS &amp;&amp; value == NULL&bslash;n&quot;
)paren
suffix:semicolon
id|self-&gt;errno
op_assign
op_minus
id|EHOSTUNREACH
suffix:semicolon
)brace
)brace
id|DEXIT
c_func
(paren
id|IRDA_SR_TRACE
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Return the TSAP */
r_return
id|dtsap_sel
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Function irnet_find_lsap_sel (self)&n; *&n; *    Try to lookup LSAP selector in remote LM-IAS&n; *&n; * Basically, we start a IAP query, and then go to sleep. When the query&n; * return, irnet_getvalue_confirm will wake us up, and we can examine the&n; * result of the query...&n; * Note that in some case, the query fail even before we go to sleep,&n; * creating some races...&n; */
r_static
r_inline
r_int
DECL|function|irnet_find_lsap_sel
id|irnet_find_lsap_sel
c_func
(paren
id|irnet_socket
op_star
id|self
)paren
(brace
id|DENTER
c_func
(paren
id|IRDA_SR_TRACE
comma
l_string|&quot;(self=0x%X)&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|self
)paren
suffix:semicolon
multiline_comment|/* This should not happen */
id|DABORT
c_func
(paren
id|self-&gt;iriap
comma
op_minus
id|EBUSY
comma
id|IRDA_SR_ERROR
comma
l_string|&quot;busy with a previous query.&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Create an IAP instance, will be closed in irnet_getvalue_confirm() */
id|self-&gt;iriap
op_assign
id|iriap_open
c_func
(paren
id|LSAP_ANY
comma
id|IAS_CLIENT
comma
id|self
comma
id|irnet_getvalue_confirm
)paren
suffix:semicolon
multiline_comment|/* Treat unexpected signals as disconnect */
id|self-&gt;errno
op_assign
op_minus
id|EHOSTUNREACH
suffix:semicolon
multiline_comment|/* Query remote LM-IAS */
id|iriap_getvaluebyclass_request
c_func
(paren
id|self-&gt;iriap
comma
id|self-&gt;rsaddr
comma
id|self-&gt;daddr
comma
id|IRNET_SERVICE_NAME
comma
id|IRNET_IAS_VALUE
)paren
suffix:semicolon
multiline_comment|/* The above request is non-blocking.&n;   * After a while, IrDA will call us back in irnet_getvalue_confirm()&n;   * We will then call irnet_ias_to_tsap() and finish the&n;   * connection procedure */
id|DEXIT
c_func
(paren
id|IRDA_SR_TRACE
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Function irnet_connect_tsap (self)&n; *&n; *    Initialise the TTP socket and initiate TTP connection&n; *&n; */
r_static
r_inline
r_int
DECL|function|irnet_connect_tsap
id|irnet_connect_tsap
c_func
(paren
id|irnet_socket
op_star
id|self
)paren
(brace
r_int
id|err
suffix:semicolon
id|DENTER
c_func
(paren
id|IRDA_SR_TRACE
comma
l_string|&quot;(self=0x%X)&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|self
)paren
suffix:semicolon
multiline_comment|/* Open a local TSAP (an IrTTP instance) */
id|err
op_assign
id|irnet_open_tsap
c_func
(paren
id|self
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_ne
l_int|0
)paren
(brace
id|clear_bit
c_func
(paren
l_int|0
comma
op_amp
id|self-&gt;ttp_connect
)paren
suffix:semicolon
id|DERROR
c_func
(paren
id|IRDA_SR_ERROR
comma
l_string|&quot;connect aborted!&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/* Connect to remote device */
id|err
op_assign
id|irttp_connect_request
c_func
(paren
id|self-&gt;tsap
comma
id|self-&gt;dtsap_sel
comma
id|self-&gt;rsaddr
comma
id|self-&gt;daddr
comma
l_int|NULL
comma
id|self-&gt;max_sdu_size_rx
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_ne
l_int|0
)paren
(brace
id|clear_bit
c_func
(paren
l_int|0
comma
op_amp
id|self-&gt;ttp_connect
)paren
suffix:semicolon
id|DERROR
c_func
(paren
id|IRDA_SR_ERROR
comma
l_string|&quot;connect aborted!&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/* The above call is non-blocking.&n;   * After a while, the IrDA stack will either call us back in&n;   * irnet_connect_confirm() or irnet_disconnect_indication()&n;   * See you there ;-) */
id|DEXIT
c_func
(paren
id|IRDA_SR_TRACE
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Function irnet_discover_next_daddr (self)&n; *&n; *    Query the IrNET TSAP of the next device in the log.&n; *&n; * Used in the TSAP discovery procedure.&n; */
r_static
r_inline
r_int
DECL|function|irnet_discover_next_daddr
id|irnet_discover_next_daddr
c_func
(paren
id|irnet_socket
op_star
id|self
)paren
(brace
multiline_comment|/* Close the last instance of IrIAP, and open a new one.&n;   * We can&squot;t reuse the IrIAP instance in the IrIAP callback */
r_if
c_cond
(paren
id|self-&gt;iriap
)paren
(brace
id|iriap_close
c_func
(paren
id|self-&gt;iriap
)paren
suffix:semicolon
id|self-&gt;iriap
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Create a new IAP instance */
id|self-&gt;iriap
op_assign
id|iriap_open
c_func
(paren
id|LSAP_ANY
comma
id|IAS_CLIENT
comma
id|self
comma
id|irnet_discovervalue_confirm
)paren
suffix:semicolon
multiline_comment|/* Next discovery - before the call to avoid races */
id|self-&gt;disco_index
op_increment
suffix:semicolon
multiline_comment|/* Check if we have one more address to try */
r_if
c_cond
(paren
id|self-&gt;disco_index
OL
id|self-&gt;disco_number
)paren
(brace
multiline_comment|/* Query remote LM-IAS */
id|iriap_getvaluebyclass_request
c_func
(paren
id|self-&gt;iriap
comma
id|self-&gt;discoveries
(braket
id|self-&gt;disco_index
)braket
dot
id|saddr
comma
id|self-&gt;discoveries
(braket
id|self-&gt;disco_index
)braket
dot
id|daddr
comma
id|IRNET_SERVICE_NAME
comma
id|IRNET_IAS_VALUE
)paren
suffix:semicolon
multiline_comment|/* The above request is non-blocking.&n;       * After a while, IrDA will call us back in irnet_discovervalue_confirm()&n;       * We will then call irnet_ias_to_tsap() and come back here again... */
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Function irnet_discover_daddr_and_lsap_sel (self)&n; *&n; *    This try to find a device with the requested service.&n; *&n; * Initiate a TSAP discovery procedure.&n; * It basically look into the discovery log. For each address in the list,&n; * it queries the LM-IAS of the device to find if this device offer&n; * the requested service.&n; * If there is more than one node supporting the service, we complain&n; * to the user (it should move devices around).&n; * If we find one node which have the requested TSAP, we connect to it.&n; *&n; * This function just start the whole procedure. It request the discovery&n; * log and submit the first IAS query.&n; * The bulk of the job is handled in irnet_discovervalue_confirm()&n; *&n; * Note : this procedure fails if there is more than one device in range&n; * on the same dongle, because IrLMP doesn&squot;t disconnect the LAP when the&n; * last LSAP is closed. Moreover, we would need to wait the LAP&n; * disconnection...&n; */
r_static
r_inline
r_int
DECL|function|irnet_discover_daddr_and_lsap_sel
id|irnet_discover_daddr_and_lsap_sel
c_func
(paren
id|irnet_socket
op_star
id|self
)paren
(brace
r_int
id|ret
suffix:semicolon
id|DENTER
c_func
(paren
id|IRDA_SR_TRACE
comma
l_string|&quot;(self=0x%X)&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|self
)paren
suffix:semicolon
multiline_comment|/* Ask lmp for the current discovery log */
id|self-&gt;discoveries
op_assign
id|irlmp_get_discoveries
c_func
(paren
op_amp
id|self-&gt;disco_number
comma
id|self-&gt;mask
comma
id|DISCOVERY_DEFAULT_SLOTS
)paren
suffix:semicolon
multiline_comment|/* Check if the we got some results */
r_if
c_cond
(paren
id|self-&gt;discoveries
op_eq
l_int|NULL
)paren
(brace
id|self-&gt;disco_number
op_assign
op_minus
l_int|1
suffix:semicolon
id|clear_bit
c_func
(paren
l_int|0
comma
op_amp
id|self-&gt;ttp_connect
)paren
suffix:semicolon
id|DRETURN
c_func
(paren
op_minus
id|ENETUNREACH
comma
id|IRDA_SR_INFO
comma
l_string|&quot;No Cachelog...&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|DEBUG
c_func
(paren
id|IRDA_SR_INFO
comma
l_string|&quot;Got the log (0x%X), size is %d&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|self-&gt;discoveries
comma
id|self-&gt;disco_number
)paren
suffix:semicolon
multiline_comment|/* Start with the first discovery */
id|self-&gt;disco_index
op_assign
op_minus
l_int|1
suffix:semicolon
id|self-&gt;daddr
op_assign
id|DEV_ADDR_ANY
suffix:semicolon
multiline_comment|/* This will fail if the log is empty - this is non-blocking */
id|ret
op_assign
id|irnet_discover_next_daddr
c_func
(paren
id|self
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
multiline_comment|/* Close IAP */
id|iriap_close
c_func
(paren
id|self-&gt;iriap
)paren
suffix:semicolon
id|self-&gt;iriap
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Cleanup our copy of the discovery log */
id|kfree
c_func
(paren
id|self-&gt;discoveries
)paren
suffix:semicolon
id|self-&gt;discoveries
op_assign
l_int|NULL
suffix:semicolon
id|clear_bit
c_func
(paren
l_int|0
comma
op_amp
id|self-&gt;ttp_connect
)paren
suffix:semicolon
id|DRETURN
c_func
(paren
op_minus
id|ENETUNREACH
comma
id|IRDA_SR_INFO
comma
l_string|&quot;Cachelog empty...&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* Follow me in irnet_discovervalue_confirm() */
id|DEXIT
c_func
(paren
id|IRDA_SR_TRACE
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Function irnet_dname_to_daddr (self)&n; *&n; *    Convert an IrDA nickname to a valid IrDA address&n; *&n; * It basically look into the discovery log until there is a match.&n; */
r_static
r_inline
r_int
DECL|function|irnet_dname_to_daddr
id|irnet_dname_to_daddr
c_func
(paren
id|irnet_socket
op_star
id|self
)paren
(brace
r_struct
id|irda_device_info
op_star
id|discoveries
suffix:semicolon
multiline_comment|/* Copy of the discovery log */
r_int
id|number
suffix:semicolon
multiline_comment|/* Number of nodes in the log */
r_int
id|i
suffix:semicolon
id|DENTER
c_func
(paren
id|IRDA_SR_TRACE
comma
l_string|&quot;(self=0x%X)&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|self
)paren
suffix:semicolon
multiline_comment|/* Ask lmp for the current discovery log */
id|discoveries
op_assign
id|irlmp_get_discoveries
c_func
(paren
op_amp
id|number
comma
l_int|0xffff
comma
id|DISCOVERY_DEFAULT_SLOTS
)paren
suffix:semicolon
multiline_comment|/* Check if the we got some results */
r_if
c_cond
(paren
id|discoveries
op_eq
l_int|NULL
)paren
(brace
id|DRETURN
c_func
(paren
op_minus
id|ENETUNREACH
comma
id|IRDA_SR_INFO
comma
l_string|&quot;Cachelog empty...&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* &n;   * Now, check all discovered devices (if any), and connect&n;   * client only about the services that the client is&n;   * interested in...&n;   */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|number
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* Does the name match ? */
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|discoveries
(braket
id|i
)braket
dot
id|info
comma
id|self-&gt;rname
comma
id|NICKNAME_MAX_LEN
)paren
)paren
(brace
multiline_comment|/* Yes !!! Get it.. */
id|self-&gt;daddr
op_assign
id|discoveries
(braket
id|i
)braket
dot
id|daddr
suffix:semicolon
id|DEBUG
c_func
(paren
id|IRDA_SR_INFO
comma
l_string|&quot;discovered device ``%s&squot;&squot; at address 0x%08x.&bslash;n&quot;
comma
id|self-&gt;rname
comma
id|self-&gt;daddr
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|discoveries
)paren
suffix:semicolon
id|DEXIT
c_func
(paren
id|IRDA_SR_TRACE
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/* No luck ! */
id|DEBUG
c_func
(paren
id|IRDA_SR_INFO
comma
l_string|&quot;cannot discover device ``%s&squot;&squot; !!!&bslash;n&quot;
comma
id|self-&gt;rname
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|discoveries
)paren
suffix:semicolon
r_return
op_minus
id|EADDRNOTAVAIL
suffix:semicolon
)brace
multiline_comment|/************************* SOCKET ROUTINES *************************/
multiline_comment|/*&n; * This are the main operations on IrNET sockets, basically to create&n; * and destroy IrNET sockets. These are called from the PPP part...&n; */
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Create a IrNET instance : just initialise some parameters...&n; */
r_int
DECL|function|irda_irnet_create
id|irda_irnet_create
c_func
(paren
id|irnet_socket
op_star
id|self
)paren
(brace
id|DENTER
c_func
(paren
id|IRDA_SOCK_TRACE
comma
l_string|&quot;(self=0x%X)&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|self
)paren
suffix:semicolon
id|self-&gt;magic
op_assign
id|IRNET_MAGIC
suffix:semicolon
multiline_comment|/* Paranoia */
id|self-&gt;ttp_open
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Prevent higher layer from accessing IrTTP */
id|self-&gt;ttp_connect
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Not connecting yet */
id|self-&gt;rname
(braket
l_int|0
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
multiline_comment|/* May be set via control channel */
id|self-&gt;rdaddr
op_assign
id|DEV_ADDR_ANY
suffix:semicolon
multiline_comment|/* May be set via control channel */
id|self-&gt;rsaddr
op_assign
id|DEV_ADDR_ANY
suffix:semicolon
multiline_comment|/* May be set via control channel */
id|self-&gt;daddr
op_assign
id|DEV_ADDR_ANY
suffix:semicolon
multiline_comment|/* Until we get connected */
id|self-&gt;saddr
op_assign
id|DEV_ADDR_ANY
suffix:semicolon
multiline_comment|/* Until we get connected */
id|self-&gt;max_sdu_size_rx
op_assign
id|TTP_SAR_UNBOUND
suffix:semicolon
multiline_comment|/* Register as a client with IrLMP */
id|self-&gt;ckey
op_assign
id|irlmp_register_client
c_func
(paren
l_int|0
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
macro_line|#ifdef DISCOVERY_NOMASK
id|self-&gt;mask
op_assign
l_int|0xffff
suffix:semicolon
multiline_comment|/* For W2k compatibility */
macro_line|#else /* DISCOVERY_NOMASK */
id|self-&gt;mask
op_assign
id|irlmp_service_to_hint
c_func
(paren
id|S_LAN
)paren
suffix:semicolon
macro_line|#endif /* DISCOVERY_NOMASK */
id|self-&gt;tx_flow
op_assign
id|FLOW_START
suffix:semicolon
multiline_comment|/* Flow control from IrTTP */
id|DEXIT
c_func
(paren
id|IRDA_SOCK_TRACE
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Connect to the other side :&n; *&t;o convert device name to an address&n; *&t;o find the socket number (dlsap)&n; *&t;o Establish the connection&n; *&n; * Note : We no longer mimic af_irda. The IAS query for finding the TSAP&n; * is done asynchronously, like the TTP connection. This allow us to&n; * call this function from any context (not only process).&n; * The downside is that following what&squot;s happening in there is tricky&n; * because it involve various functions all over the place...&n; */
r_int
DECL|function|irda_irnet_connect
id|irda_irnet_connect
c_func
(paren
id|irnet_socket
op_star
id|self
)paren
(brace
r_int
id|err
suffix:semicolon
id|DENTER
c_func
(paren
id|IRDA_SOCK_TRACE
comma
l_string|&quot;(self=0x%X)&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|self
)paren
suffix:semicolon
multiline_comment|/* Check if we are already trying to connect.&n;   * Because irda_irnet_connect() can be called directly by pppd plus&n;   * packet retries in ppp_generic and connect may take time, plus we may&n;   * race with irnet_connect_indication(), we need to be careful there... */
r_if
c_cond
(paren
id|test_and_set_bit
c_func
(paren
l_int|0
comma
op_amp
id|self-&gt;ttp_connect
)paren
)paren
(brace
id|DRETURN
c_func
(paren
op_minus
id|EBUSY
comma
id|IRDA_SOCK_INFO
comma
l_string|&quot;Already connecting...&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|self-&gt;iriap
op_ne
l_int|NULL
)paren
op_logical_or
(paren
id|self-&gt;tsap
op_ne
l_int|NULL
)paren
)paren
(brace
id|DERROR
c_func
(paren
id|IRDA_SOCK_ERROR
comma
l_string|&quot;Socket not cleaned up...&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* Insert ourselves in the hashbin so that the IrNET server can find us.&n;   * Notes : 4th arg is string of 32 char max and must be null terminated&n;   *&t;     When 4th arg is used (string), 3rd arg isn&squot;t (int)&n;   *&t;     Can&squot;t re-insert (MUST remove first) so check for that... */
r_if
c_cond
(paren
(paren
id|irnet_server.running
)paren
op_logical_and
(paren
id|self-&gt;q.q_next
op_eq
l_int|NULL
)paren
)paren
(brace
id|spin_lock_bh
c_func
(paren
op_amp
id|irnet_server.spinlock
)paren
suffix:semicolon
id|hashbin_insert
c_func
(paren
id|irnet_server.list
comma
(paren
id|irda_queue_t
op_star
)paren
id|self
comma
l_int|0
comma
id|self-&gt;rname
)paren
suffix:semicolon
id|spin_unlock_bh
c_func
(paren
op_amp
id|irnet_server.spinlock
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
id|IRDA_SOCK_INFO
comma
l_string|&quot;Inserted ``%s&squot;&squot; in hashbin...&bslash;n&quot;
comma
id|self-&gt;rname
)paren
suffix:semicolon
)brace
multiline_comment|/* If we don&squot;t have anything (no address, no name) */
r_if
c_cond
(paren
(paren
id|self-&gt;rdaddr
op_eq
id|DEV_ADDR_ANY
)paren
op_logical_and
(paren
id|self-&gt;rname
(braket
l_int|0
)braket
op_eq
l_char|&squot;&bslash;0&squot;
)paren
)paren
(brace
multiline_comment|/* Try to find a suitable address */
r_if
c_cond
(paren
(paren
id|err
op_assign
id|irnet_discover_daddr_and_lsap_sel
c_func
(paren
id|self
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|DRETURN
c_func
(paren
id|err
comma
id|IRDA_SOCK_INFO
comma
l_string|&quot;auto-connect failed!&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* In most cases, the call above is non-blocking */
)brace
r_else
(brace
multiline_comment|/* If we have only the name (no address), try to get an address */
r_if
c_cond
(paren
id|self-&gt;rdaddr
op_eq
id|DEV_ADDR_ANY
)paren
(brace
r_if
c_cond
(paren
(paren
id|err
op_assign
id|irnet_dname_to_daddr
c_func
(paren
id|self
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|DRETURN
c_func
(paren
id|err
comma
id|IRDA_SOCK_INFO
comma
l_string|&quot;name connect failed!&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
r_else
multiline_comment|/* Use the requested destination address */
id|self-&gt;daddr
op_assign
id|self-&gt;rdaddr
suffix:semicolon
multiline_comment|/* Query remote LM-IAS to find LSAP selector */
id|irnet_find_lsap_sel
c_func
(paren
id|self
)paren
suffix:semicolon
multiline_comment|/* The above call is non blocking */
)brace
multiline_comment|/* At this point, we are waiting for the IrDA stack to call us back,&n;   * or we have already failed.&n;   * We will finish the connection procedure in irnet_connect_tsap().&n;   */
id|DEXIT
c_func
(paren
id|IRDA_SOCK_TRACE
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Function irda_irnet_destroy(self)&n; *&n; *    Destroy irnet instance&n; *&n; * Note : this need to be called from a process context.&n; */
r_void
DECL|function|irda_irnet_destroy
id|irda_irnet_destroy
c_func
(paren
id|irnet_socket
op_star
id|self
)paren
(brace
id|DENTER
c_func
(paren
id|IRDA_SOCK_TRACE
comma
l_string|&quot;(self=0x%X)&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|self
)paren
suffix:semicolon
r_if
c_cond
(paren
id|self
op_eq
l_int|NULL
)paren
(brace
r_return
suffix:semicolon
)brace
multiline_comment|/* Remove ourselves from hashbin (if we are queued in hashbin)&n;   * Note : `irnet_server.running&squot; protect us from calls in hashbin_delete() */
r_if
c_cond
(paren
(paren
id|irnet_server.running
)paren
op_logical_and
(paren
id|self-&gt;q.q_next
op_ne
l_int|NULL
)paren
)paren
(brace
r_struct
id|irnet_socket
op_star
id|entry
suffix:semicolon
id|DEBUG
c_func
(paren
id|IRDA_SOCK_INFO
comma
l_string|&quot;Removing from hash..&bslash;n&quot;
)paren
suffix:semicolon
id|spin_lock_bh
c_func
(paren
op_amp
id|irnet_server.spinlock
)paren
suffix:semicolon
id|entry
op_assign
id|hashbin_remove_this
c_func
(paren
id|irnet_server.list
comma
(paren
id|irda_queue_t
op_star
)paren
id|self
)paren
suffix:semicolon
id|self-&gt;q.q_next
op_assign
l_int|NULL
suffix:semicolon
id|spin_unlock_bh
c_func
(paren
op_amp
id|irnet_server.spinlock
)paren
suffix:semicolon
id|DASSERT
c_func
(paren
id|entry
op_eq
id|self
comma
comma
id|IRDA_SOCK_ERROR
comma
l_string|&quot;Can&squot;t remove from hash.&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* If we were connected, post a message */
r_if
c_cond
(paren
id|test_bit
c_func
(paren
l_int|0
comma
op_amp
id|self-&gt;ttp_open
)paren
)paren
(brace
multiline_comment|/* Note : as the disconnect comes from ppp_generic, the unit number&n;       * doesn&squot;t exist anymore when we post the event, so we need to pass&n;       * NULL as the first arg... */
id|irnet_post_event
c_func
(paren
l_int|NULL
comma
id|IRNET_DISCONNECT_TO
comma
id|self-&gt;saddr
comma
id|self-&gt;daddr
comma
id|self-&gt;rname
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* Prevent various IrDA callbacks from messing up things&n;   * Need to be first */
id|clear_bit
c_func
(paren
l_int|0
comma
op_amp
id|self-&gt;ttp_connect
)paren
suffix:semicolon
multiline_comment|/* Prevent higher layer from accessing IrTTP */
id|clear_bit
c_func
(paren
l_int|0
comma
op_amp
id|self-&gt;ttp_open
)paren
suffix:semicolon
multiline_comment|/* Unregister with IrLMP */
id|irlmp_unregister_client
c_func
(paren
id|self-&gt;ckey
)paren
suffix:semicolon
multiline_comment|/* Unregister with LM-IAS */
r_if
c_cond
(paren
id|self-&gt;iriap
)paren
(brace
id|iriap_close
c_func
(paren
id|self-&gt;iriap
)paren
suffix:semicolon
id|self-&gt;iriap
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Cleanup eventual discoveries from connection attempt */
r_if
c_cond
(paren
id|self-&gt;discoveries
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* Cleanup our copy of the discovery log */
id|kfree
c_func
(paren
id|self-&gt;discoveries
)paren
suffix:semicolon
id|self-&gt;discoveries
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Close our IrTTP connection */
r_if
c_cond
(paren
id|self-&gt;tsap
)paren
(brace
id|DEBUG
c_func
(paren
id|IRDA_SOCK_INFO
comma
l_string|&quot;Closing our TTP connection.&bslash;n&quot;
)paren
suffix:semicolon
id|irttp_disconnect_request
c_func
(paren
id|self-&gt;tsap
comma
l_int|NULL
comma
id|P_NORMAL
)paren
suffix:semicolon
id|irttp_close_tsap
c_func
(paren
id|self-&gt;tsap
)paren
suffix:semicolon
id|self-&gt;tsap
op_assign
l_int|NULL
suffix:semicolon
)brace
id|self-&gt;stsap_sel
op_assign
l_int|0
suffix:semicolon
id|DEXIT
c_func
(paren
id|IRDA_SOCK_TRACE
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/************************** SERVER SOCKET **************************/
multiline_comment|/*&n; * The IrNET service is composed of one server socket and a variable&n; * number of regular IrNET sockets. The server socket is supposed to&n; * handle incoming connections and redirect them to one IrNET sockets.&n; * It&squot;s a superset of the regular IrNET socket, but has a very distinct&n; * behaviour...&n; */
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Function irnet_daddr_to_dname (self)&n; *&n; *    Convert an IrDA address to a IrDA nickname&n; *&n; * It basically look into the discovery log until there is a match.&n; */
r_static
r_inline
r_int
DECL|function|irnet_daddr_to_dname
id|irnet_daddr_to_dname
c_func
(paren
id|irnet_socket
op_star
id|self
)paren
(brace
r_struct
id|irda_device_info
op_star
id|discoveries
suffix:semicolon
multiline_comment|/* Copy of the discovery log */
r_int
id|number
suffix:semicolon
multiline_comment|/* Number of nodes in the log */
r_int
id|i
suffix:semicolon
id|DENTER
c_func
(paren
id|IRDA_SERV_TRACE
comma
l_string|&quot;(self=0x%X)&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|self
)paren
suffix:semicolon
multiline_comment|/* Ask lmp for the current discovery log */
id|discoveries
op_assign
id|irlmp_get_discoveries
c_func
(paren
op_amp
id|number
comma
l_int|0xffff
comma
id|DISCOVERY_DEFAULT_SLOTS
)paren
suffix:semicolon
multiline_comment|/* Check if the we got some results */
r_if
c_cond
(paren
id|discoveries
op_eq
l_int|NULL
)paren
id|DRETURN
c_func
(paren
op_minus
id|ENETUNREACH
comma
id|IRDA_SERV_INFO
comma
l_string|&quot;Cachelog empty...&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Now, check all discovered devices (if any) */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|number
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* Does the name match ? */
r_if
c_cond
(paren
id|discoveries
(braket
id|i
)braket
dot
id|daddr
op_eq
id|self-&gt;daddr
)paren
(brace
multiline_comment|/* Yes !!! Get it.. */
id|strlcpy
c_func
(paren
id|self-&gt;rname
comma
id|discoveries
(braket
id|i
)braket
dot
id|info
comma
r_sizeof
(paren
id|self-&gt;rname
)paren
)paren
suffix:semicolon
id|self-&gt;rname
(braket
id|NICKNAME_MAX_LEN
op_plus
l_int|1
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|DEBUG
c_func
(paren
id|IRDA_SERV_INFO
comma
l_string|&quot;Device 0x%08x is in fact ``%s&squot;&squot;.&bslash;n&quot;
comma
id|self-&gt;daddr
comma
id|self-&gt;rname
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|discoveries
)paren
suffix:semicolon
id|DEXIT
c_func
(paren
id|IRDA_SERV_TRACE
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/* No luck ! */
id|DEXIT
c_func
(paren
id|IRDA_SERV_INFO
comma
l_string|&quot;: cannot discover device 0x%08x !!!&bslash;n&quot;
comma
id|self-&gt;daddr
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|discoveries
)paren
suffix:semicolon
r_return
op_minus
id|EADDRNOTAVAIL
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Function irda_find_socket (self)&n; *&n; *    Find the correct IrNET socket&n; *&n; * Look into the list of IrNET sockets and finds one with the right&n; * properties...&n; */
r_static
r_inline
id|irnet_socket
op_star
DECL|function|irnet_find_socket
id|irnet_find_socket
c_func
(paren
id|irnet_socket
op_star
id|self
)paren
(brace
id|irnet_socket
op_star
r_new
op_assign
(paren
id|irnet_socket
op_star
)paren
l_int|NULL
suffix:semicolon
r_int
id|err
suffix:semicolon
id|DENTER
c_func
(paren
id|IRDA_SERV_TRACE
comma
l_string|&quot;(self=0x%X)&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|self
)paren
suffix:semicolon
multiline_comment|/* Get the addresses of the requester */
id|self-&gt;daddr
op_assign
id|irttp_get_daddr
c_func
(paren
id|self-&gt;tsap
)paren
suffix:semicolon
id|self-&gt;saddr
op_assign
id|irttp_get_saddr
c_func
(paren
id|self-&gt;tsap
)paren
suffix:semicolon
multiline_comment|/* Try to get the IrDA nickname of the requester */
id|err
op_assign
id|irnet_daddr_to_dname
c_func
(paren
id|self
)paren
suffix:semicolon
multiline_comment|/* Protect access to the instance list */
id|spin_lock_bh
c_func
(paren
op_amp
id|irnet_server.spinlock
)paren
suffix:semicolon
multiline_comment|/* So now, try to get an socket having specifically&n;   * requested that nickname */
r_if
c_cond
(paren
id|err
op_eq
l_int|0
)paren
(brace
r_new
op_assign
(paren
id|irnet_socket
op_star
)paren
id|hashbin_find
c_func
(paren
id|irnet_server.list
comma
l_int|0
comma
id|self-&gt;rname
)paren
suffix:semicolon
r_if
c_cond
(paren
r_new
)paren
(brace
id|DEBUG
c_func
(paren
id|IRDA_SERV_INFO
comma
l_string|&quot;Socket 0x%X matches rname ``%s&squot;&squot;.&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
r_new
comma
r_new
op_member_access_from_pointer
id|rname
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* If no name matches, try to find an socket by the destination address */
multiline_comment|/* It can be either the requested destination address (set via the&n;   * control channel), or the current destination address if the&n;   * socket is in the middle of a connection request */
r_if
c_cond
(paren
r_new
op_eq
(paren
id|irnet_socket
op_star
)paren
l_int|NULL
)paren
(brace
r_new
op_assign
(paren
id|irnet_socket
op_star
)paren
id|hashbin_get_first
c_func
(paren
id|irnet_server.list
)paren
suffix:semicolon
r_while
c_loop
(paren
r_new
op_ne
(paren
id|irnet_socket
op_star
)paren
l_int|NULL
)paren
(brace
multiline_comment|/* Does it have the same address ? */
r_if
c_cond
(paren
(paren
r_new
op_member_access_from_pointer
id|rdaddr
op_eq
id|self-&gt;daddr
)paren
op_logical_or
(paren
r_new
op_member_access_from_pointer
id|daddr
op_eq
id|self-&gt;daddr
)paren
)paren
(brace
multiline_comment|/* Yes !!! Get it.. */
id|DEBUG
c_func
(paren
id|IRDA_SERV_INFO
comma
l_string|&quot;Socket 0x%X matches daddr %#08x.&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
r_new
comma
id|self-&gt;daddr
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_new
op_assign
(paren
id|irnet_socket
op_star
)paren
id|hashbin_get_next
c_func
(paren
id|irnet_server.list
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* If we don&squot;t have any socket, get the first unconnected socket */
r_if
c_cond
(paren
r_new
op_eq
(paren
id|irnet_socket
op_star
)paren
l_int|NULL
)paren
(brace
r_new
op_assign
(paren
id|irnet_socket
op_star
)paren
id|hashbin_get_first
c_func
(paren
id|irnet_server.list
)paren
suffix:semicolon
r_while
c_loop
(paren
r_new
op_ne
(paren
id|irnet_socket
op_star
)paren
l_int|NULL
)paren
(brace
multiline_comment|/* Is it available ? */
r_if
c_cond
(paren
op_logical_neg
(paren
id|test_bit
c_func
(paren
l_int|0
comma
op_amp
r_new
op_member_access_from_pointer
id|ttp_open
)paren
)paren
op_logical_and
(paren
r_new
op_member_access_from_pointer
id|rdaddr
op_eq
id|DEV_ADDR_ANY
)paren
op_logical_and
(paren
r_new
op_member_access_from_pointer
id|rname
(braket
l_int|0
)braket
op_eq
l_char|&squot;&bslash;0&squot;
)paren
op_logical_and
(paren
r_new
op_member_access_from_pointer
id|ppp_open
)paren
)paren
(brace
multiline_comment|/* Yes !!! Get it.. */
id|DEBUG
c_func
(paren
id|IRDA_SERV_INFO
comma
l_string|&quot;Socket 0x%X is free.&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
r_new
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_new
op_assign
(paren
id|irnet_socket
op_star
)paren
id|hashbin_get_next
c_func
(paren
id|irnet_server.list
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Spin lock end */
id|spin_unlock_bh
c_func
(paren
op_amp
id|irnet_server.spinlock
)paren
suffix:semicolon
id|DEXIT
c_func
(paren
id|IRDA_SERV_TRACE
comma
l_string|&quot; - new = 0x%X&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
r_new
)paren
suffix:semicolon
r_return
r_new
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Function irda_connect_socket (self)&n; *&n; *    Connect an incoming connection to the socket&n; *&n; */
r_static
r_inline
r_int
DECL|function|irnet_connect_socket
id|irnet_connect_socket
c_func
(paren
id|irnet_socket
op_star
id|server
comma
id|irnet_socket
op_star
r_new
comma
r_struct
id|qos_info
op_star
id|qos
comma
id|__u32
id|max_sdu_size
comma
id|__u8
id|max_header_size
)paren
(brace
id|DENTER
c_func
(paren
id|IRDA_SERV_TRACE
comma
l_string|&quot;(server=0x%X, new=0x%X)&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|server
comma
(paren
r_int
r_int
)paren
r_new
)paren
suffix:semicolon
multiline_comment|/* Now attach up the new socket */
r_new
op_member_access_from_pointer
id|tsap
op_assign
id|irttp_dup
c_func
(paren
id|server-&gt;tsap
comma
r_new
)paren
suffix:semicolon
id|DABORT
c_func
(paren
r_new
op_member_access_from_pointer
id|tsap
op_eq
l_int|NULL
comma
op_minus
l_int|1
comma
id|IRDA_SERV_ERROR
comma
l_string|&quot;dup failed!&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Set up all the relevant parameters on the new socket */
r_new
op_member_access_from_pointer
id|stsap_sel
op_assign
r_new
op_member_access_from_pointer
id|tsap-&gt;stsap_sel
suffix:semicolon
r_new
op_member_access_from_pointer
id|dtsap_sel
op_assign
r_new
op_member_access_from_pointer
id|tsap-&gt;dtsap_sel
suffix:semicolon
r_new
op_member_access_from_pointer
id|saddr
op_assign
id|irttp_get_saddr
c_func
(paren
r_new
op_member_access_from_pointer
id|tsap
)paren
suffix:semicolon
r_new
op_member_access_from_pointer
id|daddr
op_assign
id|irttp_get_daddr
c_func
(paren
r_new
op_member_access_from_pointer
id|tsap
)paren
suffix:semicolon
r_new
op_member_access_from_pointer
id|max_header_size
op_assign
id|max_header_size
suffix:semicolon
r_new
op_member_access_from_pointer
id|max_sdu_size_tx
op_assign
id|max_sdu_size
suffix:semicolon
r_new
op_member_access_from_pointer
id|max_data_size
op_assign
id|max_sdu_size
suffix:semicolon
macro_line|#ifdef STREAM_COMPAT
multiline_comment|/* If we want to receive &quot;stream sockets&quot; */
r_if
c_cond
(paren
id|max_sdu_size
op_eq
l_int|0
)paren
(brace
r_new
op_member_access_from_pointer
id|max_data_size
op_assign
id|irttp_get_max_seg_size
c_func
(paren
r_new
op_member_access_from_pointer
id|tsap
)paren
suffix:semicolon
)brace
macro_line|#endif /* STREAM_COMPAT */
multiline_comment|/* Clean up the original one to keep it in listen state */
id|irttp_listen
c_func
(paren
id|server-&gt;tsap
)paren
suffix:semicolon
multiline_comment|/* Send a connection response on the new socket */
id|irttp_connect_response
c_func
(paren
r_new
op_member_access_from_pointer
id|tsap
comma
r_new
op_member_access_from_pointer
id|max_sdu_size_rx
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* Allow PPP to send its junk over the new socket... */
id|set_bit
c_func
(paren
l_int|0
comma
op_amp
r_new
op_member_access_from_pointer
id|ttp_open
)paren
suffix:semicolon
multiline_comment|/* Not connecting anymore, and clean up last possible remains&n;   * of connection attempts on the socket */
id|clear_bit
c_func
(paren
l_int|0
comma
op_amp
r_new
op_member_access_from_pointer
id|ttp_connect
)paren
suffix:semicolon
r_if
c_cond
(paren
r_new
op_member_access_from_pointer
id|iriap
)paren
(brace
id|iriap_close
c_func
(paren
r_new
op_member_access_from_pointer
id|iriap
)paren
suffix:semicolon
r_new
op_member_access_from_pointer
id|iriap
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
r_new
op_member_access_from_pointer
id|discoveries
op_ne
l_int|NULL
)paren
(brace
id|kfree
c_func
(paren
r_new
op_member_access_from_pointer
id|discoveries
)paren
suffix:semicolon
r_new
op_member_access_from_pointer
id|discoveries
op_assign
l_int|NULL
suffix:semicolon
)brace
macro_line|#ifdef CONNECT_INDIC_KICK
multiline_comment|/* As currently we don&squot;t block packets in ppp_irnet_send() while passive,&n;   * this is not really needed...&n;   * Also, not doing it give IrDA a chance to finish the setup properly&n;   * before being swamped with packets... */
id|ppp_output_wakeup
c_func
(paren
op_amp
r_new
op_member_access_from_pointer
id|chan
)paren
suffix:semicolon
macro_line|#endif /* CONNECT_INDIC_KICK */
multiline_comment|/* Notify the control channel */
id|irnet_post_event
c_func
(paren
r_new
comma
id|IRNET_CONNECT_FROM
comma
r_new
op_member_access_from_pointer
id|saddr
comma
r_new
op_member_access_from_pointer
id|daddr
comma
id|server-&gt;rname
comma
l_int|0
)paren
suffix:semicolon
id|DEXIT
c_func
(paren
id|IRDA_SERV_TRACE
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Function irda_disconnect_server (self)&n; *&n; *    Cleanup the server socket when the incoming connection abort&n; *&n; */
r_static
r_inline
r_void
DECL|function|irnet_disconnect_server
id|irnet_disconnect_server
c_func
(paren
id|irnet_socket
op_star
id|self
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
id|DENTER
c_func
(paren
id|IRDA_SERV_TRACE
comma
l_string|&quot;(self=0x%X)&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|self
)paren
suffix:semicolon
multiline_comment|/* Put the received packet in the black hole */
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
macro_line|#ifdef FAIL_SEND_DISCONNECT
multiline_comment|/* Tell the other party we don&squot;t want to be connected */
multiline_comment|/* Hum... Is it the right thing to do ? And do we need to send&n;   * a connect response before ? It looks ok without this... */
id|irttp_disconnect_request
c_func
(paren
id|self-&gt;tsap
comma
l_int|NULL
comma
id|P_NORMAL
)paren
suffix:semicolon
macro_line|#endif /* FAIL_SEND_DISCONNECT */
multiline_comment|/* Notify the control channel (see irnet_find_socket()) */
id|irnet_post_event
c_func
(paren
l_int|NULL
comma
id|IRNET_REQUEST_FROM
comma
id|self-&gt;saddr
comma
id|self-&gt;daddr
comma
id|self-&gt;rname
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Clean up the server to keep it in listen state */
id|irttp_listen
c_func
(paren
id|self-&gt;tsap
)paren
suffix:semicolon
id|DEXIT
c_func
(paren
id|IRDA_SERV_TRACE
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Function irda_setup_server (self)&n; *&n; *    Create a IrTTP server and set it up...&n; *&n; * Register the IrLAN hint bit, create a IrTTP instance for us,&n; * set all the IrTTP callbacks and create an IrIAS entry...&n; */
r_static
r_inline
r_int
DECL|function|irnet_setup_server
id|irnet_setup_server
c_func
(paren
r_void
)paren
(brace
id|__u16
id|hints
suffix:semicolon
id|DENTER
c_func
(paren
id|IRDA_SERV_TRACE
comma
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Initialise the regular socket part of the server */
id|irda_irnet_create
c_func
(paren
op_amp
id|irnet_server.s
)paren
suffix:semicolon
multiline_comment|/* Open a local TSAP (an IrTTP instance) for the server */
id|irnet_open_tsap
c_func
(paren
op_amp
id|irnet_server.s
)paren
suffix:semicolon
multiline_comment|/* PPP part setup */
id|irnet_server.s.ppp_open
op_assign
l_int|0
suffix:semicolon
id|irnet_server.s.chan
dot
r_private
op_assign
l_int|NULL
suffix:semicolon
id|irnet_server.s.file
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Get the hint bit corresponding to IrLAN */
multiline_comment|/* Note : we overload the IrLAN hint bit. As it is only a &quot;hint&quot;, and as&n;   * we provide roughly the same functionality as IrLAN, this is ok.&n;   * In fact, the situation is similar as JetSend overloading the Obex hint&n;   */
id|hints
op_assign
id|irlmp_service_to_hint
c_func
(paren
id|S_LAN
)paren
suffix:semicolon
macro_line|#ifdef ADVERTISE_HINT
multiline_comment|/* Register with IrLMP as a service (advertise our hint bit) */
id|irnet_server.skey
op_assign
id|irlmp_register_service
c_func
(paren
id|hints
)paren
suffix:semicolon
macro_line|#endif /* ADVERTISE_HINT */
multiline_comment|/* Register with LM-IAS (so that people can connect to us) */
id|irnet_server.ias_obj
op_assign
id|irias_new_object
c_func
(paren
id|IRNET_SERVICE_NAME
comma
id|jiffies
)paren
suffix:semicolon
id|irias_add_integer_attrib
c_func
(paren
id|irnet_server.ias_obj
comma
id|IRNET_IAS_VALUE
comma
id|irnet_server.s.stsap_sel
comma
id|IAS_KERNEL_ATTR
)paren
suffix:semicolon
id|irias_insert_object
c_func
(paren
id|irnet_server.ias_obj
)paren
suffix:semicolon
macro_line|#ifdef DISCOVERY_EVENTS
multiline_comment|/* Tell IrLMP we want to be notified of newly discovered nodes */
id|irlmp_update_client
c_func
(paren
id|irnet_server.s.ckey
comma
id|hints
comma
id|irnet_discovery_indication
comma
id|irnet_expiry_indication
comma
(paren
r_void
op_star
)paren
op_amp
id|irnet_server.s
)paren
suffix:semicolon
macro_line|#endif
id|DEXIT
c_func
(paren
id|IRDA_SERV_TRACE
comma
l_string|&quot; - self=0x%X&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
op_amp
id|irnet_server.s
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Function irda_destroy_server (self)&n; *&n; *    Destroy the IrTTP server...&n; *&n; * Reverse of the previous function...&n; */
r_static
r_inline
r_void
DECL|function|irnet_destroy_server
id|irnet_destroy_server
c_func
(paren
r_void
)paren
(brace
id|DENTER
c_func
(paren
id|IRDA_SERV_TRACE
comma
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#ifdef ADVERTISE_HINT
multiline_comment|/* Unregister with IrLMP */
id|irlmp_unregister_service
c_func
(paren
id|irnet_server.skey
)paren
suffix:semicolon
macro_line|#endif /* ADVERTISE_HINT */
multiline_comment|/* Unregister with LM-IAS */
r_if
c_cond
(paren
id|irnet_server.ias_obj
)paren
(brace
id|irias_delete_object
c_func
(paren
id|irnet_server.ias_obj
)paren
suffix:semicolon
)brace
multiline_comment|/* Cleanup the socket part */
id|irda_irnet_destroy
c_func
(paren
op_amp
id|irnet_server.s
)paren
suffix:semicolon
id|DEXIT
c_func
(paren
id|IRDA_SERV_TRACE
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/************************ IRDA-TTP CALLBACKS ************************/
multiline_comment|/*&n; * When we create a IrTTP instance, we pass to it a set of callbacks&n; * that IrTTP will call in case of various events.&n; * We take care of those events here.&n; */
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Function irnet_data_indication (instance, sap, skb)&n; *&n; *    Received some data from TinyTP. Just queue it on the receive queue&n; *&n; */
r_static
r_int
DECL|function|irnet_data_indication
id|irnet_data_indication
c_func
(paren
r_void
op_star
id|instance
comma
r_void
op_star
id|sap
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
id|irnet_socket
op_star
id|ap
op_assign
(paren
id|irnet_socket
op_star
)paren
id|instance
suffix:semicolon
r_int
r_char
op_star
id|p
suffix:semicolon
r_int
id|code
op_assign
l_int|0
suffix:semicolon
id|DENTER
c_func
(paren
id|IRDA_TCB_TRACE
comma
l_string|&quot;(self/ap=0x%X, skb=0x%X)&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|ap
comma
(paren
r_int
r_int
)paren
id|skb
)paren
suffix:semicolon
id|DASSERT
c_func
(paren
id|skb
op_ne
l_int|NULL
comma
l_int|0
comma
id|IRDA_CB_ERROR
comma
l_string|&quot;skb is NULL !!!&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Check is ppp is ready to receive our packet */
r_if
c_cond
(paren
op_logical_neg
id|ap-&gt;ppp_open
)paren
(brace
id|DERROR
c_func
(paren
id|IRDA_CB_ERROR
comma
l_string|&quot;PPP not ready, dropping packet...&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* When we return error, TTP will need to requeue the skb and&n;       * will stop the sender. IrTTP will stall until we send it a&n;       * flow control request... */
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
multiline_comment|/* strip address/control field if present */
id|p
op_assign
id|skb-&gt;data
suffix:semicolon
r_if
c_cond
(paren
(paren
id|p
(braket
l_int|0
)braket
op_eq
id|PPP_ALLSTATIONS
)paren
op_logical_and
(paren
id|p
(braket
l_int|1
)braket
op_eq
id|PPP_UI
)paren
)paren
(brace
multiline_comment|/* chop off address/control */
r_if
c_cond
(paren
id|skb-&gt;len
OL
l_int|3
)paren
(brace
r_goto
id|err_exit
suffix:semicolon
)brace
id|p
op_assign
id|skb_pull
c_func
(paren
id|skb
comma
l_int|2
)paren
suffix:semicolon
)brace
multiline_comment|/* decompress protocol field if compressed */
r_if
c_cond
(paren
id|p
(braket
l_int|0
)braket
op_amp
l_int|1
)paren
(brace
multiline_comment|/* protocol is compressed */
id|skb_push
c_func
(paren
id|skb
comma
l_int|1
)paren
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|skb-&gt;len
OL
l_int|2
)paren
(brace
r_goto
id|err_exit
suffix:semicolon
)brace
multiline_comment|/* pass to generic ppp layer */
multiline_comment|/* Note : how do I know if ppp can accept or not the packet ? This is&n;   * essential if I want to manage flow control smoothly... */
id|ppp_input
c_func
(paren
op_amp
id|ap-&gt;chan
comma
id|skb
)paren
suffix:semicolon
id|DEXIT
c_func
(paren
id|IRDA_TCB_TRACE
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|err_exit
suffix:colon
id|DERROR
c_func
(paren
id|IRDA_CB_ERROR
comma
l_string|&quot;Packet too small, dropping...&bslash;n&quot;
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
id|ppp_input_error
c_func
(paren
op_amp
id|ap-&gt;chan
comma
id|code
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Don&squot;t return an error code, only for flow control... */
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Function irnet_disconnect_indication (instance, sap, reason, skb)&n; *&n; *    Connection has been closed. Chech reason to find out why&n; *&n; * Note : there are many cases where we come here :&n; *&t;o attempted to connect, timeout&n; *&t;o connected, link is broken, LAP has timeout&n; *&t;o connected, other side close the link&n; *&t;o connection request on the server not handled&n; */
r_static
r_void
DECL|function|irnet_disconnect_indication
id|irnet_disconnect_indication
c_func
(paren
r_void
op_star
id|instance
comma
r_void
op_star
id|sap
comma
id|LM_REASON
id|reason
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
id|irnet_socket
op_star
id|self
op_assign
(paren
id|irnet_socket
op_star
)paren
id|instance
suffix:semicolon
r_int
id|test_open
suffix:semicolon
r_int
id|test_connect
suffix:semicolon
id|DENTER
c_func
(paren
id|IRDA_TCB_TRACE
comma
l_string|&quot;(self=0x%X)&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|self
)paren
suffix:semicolon
id|DASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
comma
id|IRDA_CB_ERROR
comma
l_string|&quot;Self is NULL !!!&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Don&squot;t care about it, but let&squot;s not leak it */
r_if
c_cond
(paren
id|skb
)paren
(brace
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
multiline_comment|/* Prevent higher layer from accessing IrTTP */
id|test_open
op_assign
id|test_and_clear_bit
c_func
(paren
l_int|0
comma
op_amp
id|self-&gt;ttp_open
)paren
suffix:semicolon
multiline_comment|/* Not connecting anymore...&n;   * (note : TSAP is open, so IAP callbacks are no longer pending...) */
id|test_connect
op_assign
id|test_and_clear_bit
c_func
(paren
l_int|0
comma
op_amp
id|self-&gt;ttp_connect
)paren
suffix:semicolon
multiline_comment|/* If both self-&gt;ttp_open and self-&gt;ttp_connect are NULL, it mean that we&n;   * have a race condition with irda_irnet_destroy() or&n;   * irnet_connect_indication(), so don&squot;t mess up tsap...&n;   */
r_if
c_cond
(paren
op_logical_neg
(paren
id|test_open
op_logical_or
id|test_connect
)paren
)paren
(brace
id|DERROR
c_func
(paren
id|IRDA_CB_ERROR
comma
l_string|&quot;Race condition detected...&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* If we were active, notify the control channel */
r_if
c_cond
(paren
id|test_open
)paren
(brace
id|irnet_post_event
c_func
(paren
id|self
comma
id|IRNET_DISCONNECT_FROM
comma
id|self-&gt;saddr
comma
id|self-&gt;daddr
comma
id|self-&gt;rname
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
multiline_comment|/* If we were trying to connect, notify the control channel */
r_if
c_cond
(paren
(paren
id|self-&gt;tsap
)paren
op_logical_and
(paren
id|self
op_ne
op_amp
id|irnet_server.s
)paren
)paren
(brace
id|irnet_post_event
c_func
(paren
id|self
comma
id|IRNET_NOANSWER_FROM
comma
id|self-&gt;saddr
comma
id|self-&gt;daddr
comma
id|self-&gt;rname
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* Close our IrTTP connection, cleanup tsap */
r_if
c_cond
(paren
(paren
id|self-&gt;tsap
)paren
op_logical_and
(paren
id|self
op_ne
op_amp
id|irnet_server.s
)paren
)paren
(brace
id|DEBUG
c_func
(paren
id|IRDA_CB_INFO
comma
l_string|&quot;Closing our TTP connection.&bslash;n&quot;
)paren
suffix:semicolon
id|irttp_close_tsap
c_func
(paren
id|self-&gt;tsap
)paren
suffix:semicolon
id|self-&gt;tsap
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Cleanup the socket in case we want to reconnect in ppp_output_wakeup() */
id|self-&gt;stsap_sel
op_assign
l_int|0
suffix:semicolon
id|self-&gt;daddr
op_assign
id|DEV_ADDR_ANY
suffix:semicolon
id|self-&gt;tx_flow
op_assign
id|FLOW_START
suffix:semicolon
multiline_comment|/* Deal with the ppp instance if it&squot;s still alive */
r_if
c_cond
(paren
id|self-&gt;ppp_open
)paren
(brace
r_if
c_cond
(paren
id|test_open
)paren
(brace
macro_line|#ifdef MISSING_PPP_API
multiline_comment|/* ppp_unregister_channel() wants a user context, which we&n;&t;   * are guaranteed to NOT have here. What are we supposed&n;&t;   * to do here ? Jean II */
multiline_comment|/* If we were connected, cleanup &amp; close the PPP channel,&n;&t;   * which will kill pppd (hangup) and the rest */
id|ppp_unregister_channel
c_func
(paren
op_amp
id|self-&gt;chan
)paren
suffix:semicolon
id|self-&gt;ppp_open
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
)brace
r_else
(brace
multiline_comment|/* If we were trying to connect, flush (drain) ppp_generic&n;&t;   * Tx queue (most often we have blocked it), which will&n;&t;   * trigger an other attempt to connect. If we are passive,&n;&t;   * this will empty the Tx queue after last try. */
id|ppp_output_wakeup
c_func
(paren
op_amp
id|self-&gt;chan
)paren
suffix:semicolon
)brace
)brace
id|DEXIT
c_func
(paren
id|IRDA_TCB_TRACE
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Function irnet_connect_confirm (instance, sap, qos, max_sdu_size, skb)&n; *&n; *    Connections has been confirmed by the remote device&n; *&n; */
r_static
r_void
DECL|function|irnet_connect_confirm
id|irnet_connect_confirm
c_func
(paren
r_void
op_star
id|instance
comma
r_void
op_star
id|sap
comma
r_struct
id|qos_info
op_star
id|qos
comma
id|__u32
id|max_sdu_size
comma
id|__u8
id|max_header_size
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
id|irnet_socket
op_star
id|self
op_assign
(paren
id|irnet_socket
op_star
)paren
id|instance
suffix:semicolon
id|DENTER
c_func
(paren
id|IRDA_TCB_TRACE
comma
l_string|&quot;(self=0x%X)&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|self
)paren
suffix:semicolon
multiline_comment|/* Check if socket is closing down (via irda_irnet_destroy()) */
r_if
c_cond
(paren
op_logical_neg
id|test_bit
c_func
(paren
l_int|0
comma
op_amp
id|self-&gt;ttp_connect
)paren
)paren
(brace
id|DERROR
c_func
(paren
id|IRDA_CB_ERROR
comma
l_string|&quot;Socket no longer connecting. Ouch !&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* How much header space do we need to reserve */
id|self-&gt;max_header_size
op_assign
id|max_header_size
suffix:semicolon
multiline_comment|/* IrTTP max SDU size in transmit direction */
id|self-&gt;max_sdu_size_tx
op_assign
id|max_sdu_size
suffix:semicolon
id|self-&gt;max_data_size
op_assign
id|max_sdu_size
suffix:semicolon
macro_line|#ifdef STREAM_COMPAT
r_if
c_cond
(paren
id|max_sdu_size
op_eq
l_int|0
)paren
(brace
id|self-&gt;max_data_size
op_assign
id|irttp_get_max_seg_size
c_func
(paren
id|self-&gt;tsap
)paren
suffix:semicolon
)brace
macro_line|#endif /* STREAM_COMPAT */
multiline_comment|/* At this point, IrLMP has assigned our source address */
id|self-&gt;saddr
op_assign
id|irttp_get_saddr
c_func
(paren
id|self-&gt;tsap
)paren
suffix:semicolon
multiline_comment|/* Allow higher layer to access IrTTP */
id|set_bit
c_func
(paren
l_int|0
comma
op_amp
id|self-&gt;ttp_open
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
l_int|0
comma
op_amp
id|self-&gt;ttp_connect
)paren
suffix:semicolon
multiline_comment|/* Not racy, IrDA traffic is serial */
multiline_comment|/* Give a kick in the ass of ppp_generic so that he sends us some data */
id|ppp_output_wakeup
c_func
(paren
op_amp
id|self-&gt;chan
)paren
suffix:semicolon
multiline_comment|/* Check size of received packet */
r_if
c_cond
(paren
id|skb-&gt;len
OG
l_int|0
)paren
(brace
macro_line|#ifdef PASS_CONNECT_PACKETS
id|DEBUG
c_func
(paren
id|IRDA_CB_INFO
comma
l_string|&quot;Passing connect packet to PPP.&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Try to pass it to PPP */
id|irnet_data_indication
c_func
(paren
id|instance
comma
id|sap
comma
id|skb
)paren
suffix:semicolon
macro_line|#else /* PASS_CONNECT_PACKETS */
id|DERROR
c_func
(paren
id|IRDA_CB_ERROR
comma
l_string|&quot;Dropping non empty packet.&bslash;n&quot;
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
multiline_comment|/* Note : will be optimised with other kfree... */
macro_line|#endif /* PASS_CONNECT_PACKETS */
)brace
r_else
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
multiline_comment|/* Notify the control channel */
id|irnet_post_event
c_func
(paren
id|self
comma
id|IRNET_CONNECT_TO
comma
id|self-&gt;saddr
comma
id|self-&gt;daddr
comma
id|self-&gt;rname
comma
l_int|0
)paren
suffix:semicolon
id|DEXIT
c_func
(paren
id|IRDA_TCB_TRACE
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Function irnet_flow_indication (instance, sap, flow)&n; *&n; *    Used by TinyTP to tell us if it can accept more data or not&n; *&n; */
r_static
r_void
DECL|function|irnet_flow_indication
id|irnet_flow_indication
c_func
(paren
r_void
op_star
id|instance
comma
r_void
op_star
id|sap
comma
id|LOCAL_FLOW
id|flow
)paren
(brace
id|irnet_socket
op_star
id|self
op_assign
(paren
id|irnet_socket
op_star
)paren
id|instance
suffix:semicolon
id|LOCAL_FLOW
id|oldflow
op_assign
id|self-&gt;tx_flow
suffix:semicolon
id|DENTER
c_func
(paren
id|IRDA_TCB_TRACE
comma
l_string|&quot;(self=0x%X, flow=%d)&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|self
comma
id|flow
)paren
suffix:semicolon
multiline_comment|/* Update our state */
id|self-&gt;tx_flow
op_assign
id|flow
suffix:semicolon
multiline_comment|/* Check what IrTTP want us to do... */
r_switch
c_cond
(paren
id|flow
)paren
(brace
r_case
id|FLOW_START
suffix:colon
id|DEBUG
c_func
(paren
id|IRDA_CB_INFO
comma
l_string|&quot;IrTTP wants us to start again&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Check if we really need to wake up PPP */
r_if
c_cond
(paren
id|oldflow
op_eq
id|FLOW_STOP
)paren
(brace
id|ppp_output_wakeup
c_func
(paren
op_amp
id|self-&gt;chan
)paren
suffix:semicolon
)brace
r_else
id|DEBUG
c_func
(paren
id|IRDA_CB_INFO
comma
l_string|&quot;But we were already transmitting !!!&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FLOW_STOP
suffix:colon
id|DEBUG
c_func
(paren
id|IRDA_CB_INFO
comma
l_string|&quot;IrTTP wants us to slow down&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|DEBUG
c_func
(paren
id|IRDA_CB_INFO
comma
l_string|&quot;Unknown flow command!&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|DEXIT
c_func
(paren
id|IRDA_TCB_TRACE
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Function irnet_status_indication (instance, sap, reason, skb)&n; *&n; *    Link (IrLAP) status report.&n; *&n; */
r_static
r_void
DECL|function|irnet_status_indication
id|irnet_status_indication
c_func
(paren
r_void
op_star
id|instance
comma
id|LINK_STATUS
id|link
comma
id|LOCK_STATUS
id|lock
)paren
(brace
id|irnet_socket
op_star
id|self
op_assign
(paren
id|irnet_socket
op_star
)paren
id|instance
suffix:semicolon
id|DENTER
c_func
(paren
id|IRDA_TCB_TRACE
comma
l_string|&quot;(self=0x%X)&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|self
)paren
suffix:semicolon
id|DASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
comma
id|IRDA_CB_ERROR
comma
l_string|&quot;Self is NULL !!!&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* We can only get this event if we are connected */
r_switch
c_cond
(paren
id|link
)paren
(brace
r_case
id|STATUS_NO_ACTIVITY
suffix:colon
id|irnet_post_event
c_func
(paren
id|self
comma
id|IRNET_BLOCKED_LINK
comma
id|self-&gt;saddr
comma
id|self-&gt;daddr
comma
id|self-&gt;rname
comma
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|DEBUG
c_func
(paren
id|IRDA_CB_INFO
comma
l_string|&quot;Unknown status...&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|DEXIT
c_func
(paren
id|IRDA_TCB_TRACE
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Function irnet_connect_indication(instance, sap, qos, max_sdu_size, userdata)&n; *&n; *    Incoming connection&n; *&n; * In theory, this function is called only on the server socket.&n; * Some other node is attempting to connect to the IrNET service, and has&n; * sent a connection request on our server socket.&n; * We just redirect the connection to the relevant IrNET socket.&n; * &n; * Note : we also make sure that between 2 irnet nodes, there can&n; * exist only one irnet connection.&n; */
r_static
r_void
DECL|function|irnet_connect_indication
id|irnet_connect_indication
c_func
(paren
r_void
op_star
id|instance
comma
r_void
op_star
id|sap
comma
r_struct
id|qos_info
op_star
id|qos
comma
id|__u32
id|max_sdu_size
comma
id|__u8
id|max_header_size
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
id|irnet_socket
op_star
id|server
op_assign
op_amp
id|irnet_server.s
suffix:semicolon
id|irnet_socket
op_star
r_new
op_assign
(paren
id|irnet_socket
op_star
)paren
l_int|NULL
suffix:semicolon
id|DENTER
c_func
(paren
id|IRDA_TCB_TRACE
comma
l_string|&quot;(server=0x%X)&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|server
)paren
suffix:semicolon
id|DASSERT
c_func
(paren
id|instance
op_eq
op_amp
id|irnet_server
comma
comma
id|IRDA_CB_ERROR
comma
l_string|&quot;Invalid instance (0x%X) !!!&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|instance
)paren
suffix:semicolon
id|DASSERT
c_func
(paren
id|sap
op_eq
id|irnet_server.s.tsap
comma
comma
id|IRDA_CB_ERROR
comma
l_string|&quot;Invalid sap !!!&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Try to find the most appropriate IrNET socket */
r_new
op_assign
id|irnet_find_socket
c_func
(paren
id|server
)paren
suffix:semicolon
multiline_comment|/* After all this hard work, do we have an socket ? */
r_if
c_cond
(paren
r_new
op_eq
(paren
id|irnet_socket
op_star
)paren
l_int|NULL
)paren
(brace
id|DEXIT
c_func
(paren
id|IRDA_CB_INFO
comma
l_string|&quot;: No socket waiting for this connection.&bslash;n&quot;
)paren
suffix:semicolon
id|irnet_disconnect_server
c_func
(paren
id|server
comma
id|skb
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Is the socket already busy ? */
r_if
c_cond
(paren
id|test_bit
c_func
(paren
l_int|0
comma
op_amp
r_new
op_member_access_from_pointer
id|ttp_open
)paren
)paren
(brace
id|DEXIT
c_func
(paren
id|IRDA_CB_INFO
comma
l_string|&quot;: Socket already connected.&bslash;n&quot;
)paren
suffix:semicolon
id|irnet_disconnect_server
c_func
(paren
id|server
comma
id|skb
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* The following code is a bit tricky, so need comments ;-)&n;   */
multiline_comment|/* If ttp_connect is set, the socket is trying to connect to the other&n;   * end and may have sent a IrTTP connection request and is waiting for&n;   * a connection response (that may never come).&n;   * Now, the pain is that the socket may have opened a tsap and is&n;   * waiting on it, while the other end is trying to connect to it on&n;   * another tsap.&n;   * Because IrNET can be peer to peer, we need to workaround this.&n;   * Furthermore, the way the irnetd script is implemented, the&n;   * target will create a second IrNET connection back to the&n;   * originator and expect the originator to bind this new connection&n;   * to the original PPPD instance.&n;   * And of course, if we don&squot;t use irnetd, we can have a race when&n;   * both side try to connect simultaneously, which could leave both&n;   * connections half closed (yuck).&n;   * Conclusions :&n;   *&t;1) The &quot;originator&quot; must accept the new connection and get rid&n;   *&t;   of the old one so that irnetd works&n;   *&t;2) One side must deny the new connection to avoid races,&n;   *&t;   but both side must agree on which side it is...&n;   * Most often, the originator is primary at the LAP layer.&n;   * Jean II&n;   */
multiline_comment|/* Now, let&squot;s look at the way I wrote the test...&n;   * We need to clear up the ttp_connect flag atomically to prevent&n;   * irnet_disconnect_indication() to mess up the tsap we are going to close.&n;   * We want to clear the ttp_connect flag only if we close the tsap,&n;   * otherwise we will never close it, so we need to check for primary&n;   * *before* doing the test on the flag.&n;   * And of course, ALLOW_SIMULT_CONNECT can disable this entirely...&n;   * Jean II&n;   */
multiline_comment|/* Socket already connecting ? On primary ? */
r_if
c_cond
(paren
l_int|0
macro_line|#ifdef ALLOW_SIMULT_CONNECT
op_logical_or
(paren
(paren
id|irttp_is_primary
c_func
(paren
id|server-&gt;tsap
)paren
op_eq
l_int|1
)paren
multiline_comment|/* primary */
op_logical_and
(paren
id|test_and_clear_bit
c_func
(paren
l_int|0
comma
op_amp
r_new
op_member_access_from_pointer
id|ttp_connect
)paren
)paren
)paren
macro_line|#endif /* ALLOW_SIMULT_CONNECT */
)paren
(brace
id|DERROR
c_func
(paren
id|IRDA_CB_ERROR
comma
l_string|&quot;Socket already connecting, but going to reuse it !&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Cleanup the old TSAP if necessary - IrIAP will be cleaned up later */
r_if
c_cond
(paren
r_new
op_member_access_from_pointer
id|tsap
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* Close the old connection the new socket was attempting,&n;&t;   * so that we can hook it up to the new connection.&n;&t;   * It&squot;s now safe to do it... */
id|irttp_close_tsap
c_func
(paren
r_new
op_member_access_from_pointer
id|tsap
)paren
suffix:semicolon
r_new
op_member_access_from_pointer
id|tsap
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* Three options :&n;       * 1) socket was not connecting or connected : ttp_connect should be 0.&n;       * 2) we don&squot;t want to connect the socket because we are secondary or&n;       * ALLOW_SIMULT_CONNECT is undefined. ttp_connect should be 1.&n;       * 3) we are half way in irnet_disconnect_indication(), and it&squot;s a&n;       * nice race condition... Fortunately, we can detect that by checking&n;       * if tsap is still alive. On the other hand, we can&squot;t be in&n;       * irda_irnet_destroy() otherwise we would not have found this&n;       * socket in the hashbin.&n;       * Jean II */
r_if
c_cond
(paren
(paren
id|test_bit
c_func
(paren
l_int|0
comma
op_amp
r_new
op_member_access_from_pointer
id|ttp_connect
)paren
)paren
op_logical_or
(paren
r_new
op_member_access_from_pointer
id|tsap
op_ne
l_int|NULL
)paren
)paren
(brace
multiline_comment|/* Don&squot;t mess this socket, somebody else in in charge... */
id|DERROR
c_func
(paren
id|IRDA_CB_ERROR
comma
l_string|&quot;Race condition detected, socket in use, abort connect...&bslash;n&quot;
)paren
suffix:semicolon
id|irnet_disconnect_server
c_func
(paren
id|server
comma
id|skb
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
multiline_comment|/* So : at this point, we have a socket, and it is idle. Good ! */
id|irnet_connect_socket
c_func
(paren
id|server
comma
r_new
comma
id|qos
comma
id|max_sdu_size
comma
id|max_header_size
)paren
suffix:semicolon
multiline_comment|/* Check size of received packet */
r_if
c_cond
(paren
id|skb-&gt;len
OG
l_int|0
)paren
(brace
macro_line|#ifdef PASS_CONNECT_PACKETS
id|DEBUG
c_func
(paren
id|IRDA_CB_INFO
comma
l_string|&quot;Passing connect packet to PPP.&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Try to pass it to PPP */
id|irnet_data_indication
c_func
(paren
r_new
comma
r_new
op_member_access_from_pointer
id|tsap
comma
id|skb
)paren
suffix:semicolon
macro_line|#else /* PASS_CONNECT_PACKETS */
id|DERROR
c_func
(paren
id|IRDA_CB_ERROR
comma
l_string|&quot;Dropping non empty packet.&bslash;n&quot;
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
multiline_comment|/* Note : will be optimised with other kfree... */
macro_line|#endif /* PASS_CONNECT_PACKETS */
)brace
r_else
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
id|DEXIT
c_func
(paren
id|IRDA_TCB_TRACE
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/********************** IRDA-IAS/LMP CALLBACKS **********************/
multiline_comment|/*&n; * These are the callbacks called by other layers of the IrDA stack,&n; * mainly LMP for discovery and IAS for name queries.&n; */
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Function irnet_getvalue_confirm (result, obj_id, value, priv)&n; *&n; *    Got answer from remote LM-IAS, just connect&n; *&n; * This is the reply to a IAS query we were doing to find the TSAP of&n; * the device we want to connect to.&n; * If we have found a valid TSAP, just initiate the TTP connection&n; * on this TSAP.&n; */
r_static
r_void
DECL|function|irnet_getvalue_confirm
id|irnet_getvalue_confirm
c_func
(paren
r_int
id|result
comma
id|__u16
id|obj_id
comma
r_struct
id|ias_value
op_star
id|value
comma
r_void
op_star
id|priv
)paren
(brace
id|irnet_socket
op_star
id|self
op_assign
(paren
id|irnet_socket
op_star
)paren
id|priv
suffix:semicolon
id|DENTER
c_func
(paren
id|IRDA_OCB_TRACE
comma
l_string|&quot;(self=0x%X)&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|self
)paren
suffix:semicolon
id|DASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
comma
id|IRDA_OCB_ERROR
comma
l_string|&quot;Self is NULL !!!&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Check if already connected (via irnet_connect_socket())&n;   * or socket is closing down (via irda_irnet_destroy()) */
r_if
c_cond
(paren
op_logical_neg
id|test_bit
c_func
(paren
l_int|0
comma
op_amp
id|self-&gt;ttp_connect
)paren
)paren
(brace
id|DERROR
c_func
(paren
id|IRDA_OCB_ERROR
comma
l_string|&quot;Socket no longer connecting. Ouch !&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* We probably don&squot;t need to make any more queries */
id|iriap_close
c_func
(paren
id|self-&gt;iriap
)paren
suffix:semicolon
id|self-&gt;iriap
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Post process the IAS reply */
id|self-&gt;dtsap_sel
op_assign
id|irnet_ias_to_tsap
c_func
(paren
id|self
comma
id|result
comma
id|value
)paren
suffix:semicolon
multiline_comment|/* If error, just go out */
r_if
c_cond
(paren
id|self-&gt;errno
)paren
(brace
id|clear_bit
c_func
(paren
l_int|0
comma
op_amp
id|self-&gt;ttp_connect
)paren
suffix:semicolon
id|DERROR
c_func
(paren
id|IRDA_OCB_ERROR
comma
l_string|&quot;IAS connect failed ! (0x%X)&bslash;n&quot;
comma
id|self-&gt;errno
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|DEBUG
c_func
(paren
id|IRDA_OCB_INFO
comma
l_string|&quot;daddr = %08x, lsap = %d, starting IrTTP connection&bslash;n&quot;
comma
id|self-&gt;daddr
comma
id|self-&gt;dtsap_sel
)paren
suffix:semicolon
multiline_comment|/* Start up TTP - non blocking */
id|irnet_connect_tsap
c_func
(paren
id|self
)paren
suffix:semicolon
id|DEXIT
c_func
(paren
id|IRDA_OCB_TRACE
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Function irnet_discovervalue_confirm (result, obj_id, value, priv)&n; *&n; *    Handle the TSAP discovery procedure state machine.&n; *    Got answer from remote LM-IAS, try next device&n; *&n; * We are doing a  TSAP discovery procedure, and we got an answer to&n; * a IAS query we were doing to find the TSAP on one of the address&n; * in the discovery log.&n; *&n; * If we have found a valid TSAP for the first time, save it. If it&squot;s&n; * not the first time we found one, complain.&n; *&n; * If we have more addresses in the log, just initiate a new query.&n; * Note that those query may fail (see irnet_discover_daddr_and_lsap_sel())&n; *&n; * Otherwise, wrap up the procedure (cleanup), check if we have found&n; * any device and connect to it.&n; */
r_static
r_void
DECL|function|irnet_discovervalue_confirm
id|irnet_discovervalue_confirm
c_func
(paren
r_int
id|result
comma
id|__u16
id|obj_id
comma
r_struct
id|ias_value
op_star
id|value
comma
r_void
op_star
id|priv
)paren
(brace
id|irnet_socket
op_star
id|self
op_assign
(paren
id|irnet_socket
op_star
)paren
id|priv
suffix:semicolon
id|__u8
id|dtsap_sel
suffix:semicolon
multiline_comment|/* TSAP we are looking for */
id|DENTER
c_func
(paren
id|IRDA_OCB_TRACE
comma
l_string|&quot;(self=0x%X)&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|self
)paren
suffix:semicolon
id|DASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
comma
id|IRDA_OCB_ERROR
comma
l_string|&quot;Self is NULL !!!&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Check if already connected (via irnet_connect_socket())&n;   * or socket is closing down (via irda_irnet_destroy()) */
r_if
c_cond
(paren
op_logical_neg
id|test_bit
c_func
(paren
l_int|0
comma
op_amp
id|self-&gt;ttp_connect
)paren
)paren
(brace
id|DERROR
c_func
(paren
id|IRDA_OCB_ERROR
comma
l_string|&quot;Socket no longer connecting. Ouch !&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Post process the IAS reply */
id|dtsap_sel
op_assign
id|irnet_ias_to_tsap
c_func
(paren
id|self
comma
id|result
comma
id|value
)paren
suffix:semicolon
multiline_comment|/* Have we got something ? */
r_if
c_cond
(paren
id|self-&gt;errno
op_eq
l_int|0
)paren
(brace
multiline_comment|/* We found the requested service */
r_if
c_cond
(paren
id|self-&gt;daddr
op_ne
id|DEV_ADDR_ANY
)paren
(brace
id|DERROR
c_func
(paren
id|IRDA_OCB_ERROR
comma
l_string|&quot;More than one device in range supports IrNET...&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* First time we found that one, save it ! */
id|self-&gt;daddr
op_assign
id|self-&gt;discoveries
(braket
id|self-&gt;disco_index
)braket
dot
id|daddr
suffix:semicolon
id|self-&gt;dtsap_sel
op_assign
id|dtsap_sel
suffix:semicolon
)brace
)brace
multiline_comment|/* If no failure */
r_if
c_cond
(paren
(paren
id|self-&gt;errno
op_eq
op_minus
id|EADDRNOTAVAIL
)paren
op_logical_or
(paren
id|self-&gt;errno
op_eq
l_int|0
)paren
)paren
(brace
r_int
id|ret
suffix:semicolon
multiline_comment|/* Search the next node */
id|ret
op_assign
id|irnet_discover_next_daddr
c_func
(paren
id|self
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
(brace
multiline_comment|/* In this case, the above request was non-blocking.&n;&t;   * We will return here after a while... */
r_return
suffix:semicolon
)brace
multiline_comment|/* In this case, we have processed the last discovery item */
)brace
multiline_comment|/* No more queries to be done (failure or last one) */
multiline_comment|/* We probably don&squot;t need to make any more queries */
id|iriap_close
c_func
(paren
id|self-&gt;iriap
)paren
suffix:semicolon
id|self-&gt;iriap
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* No more items : remove the log and signal termination */
id|DEBUG
c_func
(paren
id|IRDA_OCB_INFO
comma
l_string|&quot;Cleaning up log (0x%X)&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|self-&gt;discoveries
)paren
suffix:semicolon
r_if
c_cond
(paren
id|self-&gt;discoveries
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* Cleanup our copy of the discovery log */
id|kfree
c_func
(paren
id|self-&gt;discoveries
)paren
suffix:semicolon
id|self-&gt;discoveries
op_assign
l_int|NULL
suffix:semicolon
)brace
id|self-&gt;disco_number
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* Check out what we found */
r_if
c_cond
(paren
id|self-&gt;daddr
op_eq
id|DEV_ADDR_ANY
)paren
(brace
id|self-&gt;daddr
op_assign
id|DEV_ADDR_ANY
suffix:semicolon
id|clear_bit
c_func
(paren
l_int|0
comma
op_amp
id|self-&gt;ttp_connect
)paren
suffix:semicolon
id|DEXIT
c_func
(paren
id|IRDA_OCB_TRACE
comma
l_string|&quot;: cannot discover IrNET in any device !!!&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* We have a valid address - just connect */
id|DEBUG
c_func
(paren
id|IRDA_OCB_INFO
comma
l_string|&quot;daddr = %08x, lsap = %d, starting IrTTP connection&bslash;n&quot;
comma
id|self-&gt;daddr
comma
id|self-&gt;dtsap_sel
)paren
suffix:semicolon
multiline_comment|/* Start up TTP - non blocking */
id|irnet_connect_tsap
c_func
(paren
id|self
)paren
suffix:semicolon
id|DEXIT
c_func
(paren
id|IRDA_OCB_TRACE
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#ifdef DISCOVERY_EVENTS
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Function irnet_discovery_indication (discovery)&n; *&n; *    Got a discovery indication from IrLMP, post an event&n; *&n; * Note : IrLMP take care of matching the hint mask for us, and also&n; * check if it is a &quot;new&quot; node for us...&n; *&n; * As IrLMP filter on the IrLAN hint bit, we get both IrLAN and IrNET&n; * nodes, so it&squot;s only at connection time that we will know if the&n; * node support IrNET, IrLAN or both. The other solution is to check&n; * in IAS the PNP ids and service name.&n; * Note : even if a node support IrNET (or IrLAN), it&squot;s no guarantee&n; * that we will be able to connect to it, the node might already be&n; * busy...&n; *&n; * One last thing : in some case, this function will trigger duplicate&n; * discovery events. On the other hand, we should catch all&n; * discoveries properly (i.e. not miss one). Filtering duplicate here&n; * is to messy, so we leave that to user space...&n; */
r_static
r_void
DECL|function|irnet_discovery_indication
id|irnet_discovery_indication
c_func
(paren
id|discinfo_t
op_star
id|discovery
comma
id|DISCOVERY_MODE
id|mode
comma
r_void
op_star
id|priv
)paren
(brace
id|irnet_socket
op_star
id|self
op_assign
op_amp
id|irnet_server.s
suffix:semicolon
id|DENTER
c_func
(paren
id|IRDA_OCB_TRACE
comma
l_string|&quot;(self=0x%X)&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|self
)paren
suffix:semicolon
id|DASSERT
c_func
(paren
id|priv
op_eq
op_amp
id|irnet_server
comma
comma
id|IRDA_OCB_ERROR
comma
l_string|&quot;Invalid instance (0x%X) !!!&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|priv
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
id|IRDA_OCB_INFO
comma
l_string|&quot;Discovered new IrNET/IrLAN node %s...&bslash;n&quot;
comma
id|discovery-&gt;info
)paren
suffix:semicolon
multiline_comment|/* Notify the control channel */
id|irnet_post_event
c_func
(paren
l_int|NULL
comma
id|IRNET_DISCOVER
comma
id|discovery-&gt;saddr
comma
id|discovery-&gt;daddr
comma
id|discovery-&gt;info
comma
id|u16ho
c_func
(paren
id|discovery-&gt;hints
)paren
)paren
suffix:semicolon
id|DEXIT
c_func
(paren
id|IRDA_OCB_TRACE
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Function irnet_expiry_indication (expiry)&n; *&n; *    Got a expiry indication from IrLMP, post an event&n; *&n; * Note : IrLMP take care of matching the hint mask for us, we only&n; * check if it is a &quot;new&quot; node...&n; */
r_static
r_void
DECL|function|irnet_expiry_indication
id|irnet_expiry_indication
c_func
(paren
id|discinfo_t
op_star
id|expiry
comma
id|DISCOVERY_MODE
id|mode
comma
r_void
op_star
id|priv
)paren
(brace
id|irnet_socket
op_star
id|self
op_assign
op_amp
id|irnet_server.s
suffix:semicolon
id|DENTER
c_func
(paren
id|IRDA_OCB_TRACE
comma
l_string|&quot;(self=0x%X)&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|self
)paren
suffix:semicolon
id|DASSERT
c_func
(paren
id|priv
op_eq
op_amp
id|irnet_server
comma
comma
id|IRDA_OCB_ERROR
comma
l_string|&quot;Invalid instance (0x%X) !!!&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|priv
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
id|IRDA_OCB_INFO
comma
l_string|&quot;IrNET/IrLAN node %s expired...&bslash;n&quot;
comma
id|expiry-&gt;info
)paren
suffix:semicolon
multiline_comment|/* Notify the control channel */
id|irnet_post_event
c_func
(paren
l_int|NULL
comma
id|IRNET_EXPIRE
comma
id|expiry-&gt;saddr
comma
id|expiry-&gt;daddr
comma
id|expiry-&gt;info
comma
id|u16ho
c_func
(paren
id|expiry-&gt;hints
)paren
)paren
suffix:semicolon
id|DEXIT
c_func
(paren
id|IRDA_OCB_TRACE
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif /* DISCOVERY_EVENTS */
multiline_comment|/*********************** PROC ENTRY CALLBACKS ***********************/
multiline_comment|/*&n; * We create a instance in the /proc filesystem, and here we take care&n; * of that...&n; */
macro_line|#ifdef CONFIG_PROC_FS
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Function irnet_proc_read (buf, start, offset, len, unused)&n; *&n; *    Give some info to the /proc file system&n; */
r_static
r_int
DECL|function|irnet_proc_read
id|irnet_proc_read
c_func
(paren
r_char
op_star
id|buf
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|len
)paren
(brace
id|irnet_socket
op_star
id|self
suffix:semicolon
r_char
op_star
id|state
suffix:semicolon
r_int
id|i
op_assign
l_int|0
suffix:semicolon
id|len
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Get the IrNET server information... */
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;IrNET server - &quot;
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;IrDA state: %s, &quot;
comma
(paren
id|irnet_server.running
ques
c_cond
l_string|&quot;running&quot;
suffix:colon
l_string|&quot;dead&quot;
)paren
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;stsap_sel: %02x, &quot;
comma
id|irnet_server.s.stsap_sel
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;dtsap_sel: %02x&bslash;n&quot;
comma
id|irnet_server.s.dtsap_sel
)paren
suffix:semicolon
multiline_comment|/* Do we need to continue ? */
r_if
c_cond
(paren
op_logical_neg
id|irnet_server.running
)paren
(brace
r_return
id|len
suffix:semicolon
)brace
multiline_comment|/* Protect access to the instance list */
id|spin_lock_bh
c_func
(paren
op_amp
id|irnet_server.spinlock
)paren
suffix:semicolon
multiline_comment|/* Get the sockets one by one... */
id|self
op_assign
(paren
id|irnet_socket
op_star
)paren
id|hashbin_get_first
c_func
(paren
id|irnet_server.list
)paren
suffix:semicolon
r_while
c_loop
(paren
id|self
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* Start printing info about the socket. */
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;&bslash;nIrNET socket %d - &quot;
comma
id|i
op_increment
)paren
suffix:semicolon
multiline_comment|/* First, get the requested configuration */
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;Requested IrDA name: &bslash;&quot;%s&bslash;&quot;, &quot;
comma
id|self-&gt;rname
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;daddr: %08x, &quot;
comma
id|self-&gt;rdaddr
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;saddr: %08x&bslash;n&quot;
comma
id|self-&gt;rsaddr
)paren
suffix:semicolon
multiline_comment|/* Second, get all the PPP info */
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;&t;PPP state: %s&quot;
comma
(paren
id|self-&gt;ppp_open
ques
c_cond
l_string|&quot;registered&quot;
suffix:colon
l_string|&quot;unregistered&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|self-&gt;ppp_open
)paren
(brace
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;, unit: ppp%d&quot;
comma
id|ppp_unit_number
c_func
(paren
op_amp
id|self-&gt;chan
)paren
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;, channel: %d&quot;
comma
id|ppp_channel_index
c_func
(paren
op_amp
id|self-&gt;chan
)paren
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;, mru: %d&quot;
comma
id|self-&gt;mru
)paren
suffix:semicolon
multiline_comment|/* Maybe add self-&gt;flags ? Later... */
)brace
multiline_comment|/* Then, get all the IrDA specific info... */
r_if
c_cond
(paren
id|self-&gt;ttp_open
)paren
(brace
id|state
op_assign
l_string|&quot;connected&quot;
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|self-&gt;tsap
op_ne
l_int|NULL
)paren
(brace
id|state
op_assign
l_string|&quot;connecting&quot;
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|self-&gt;iriap
op_ne
l_int|NULL
)paren
(brace
id|state
op_assign
l_string|&quot;searching&quot;
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|self-&gt;ttp_connect
)paren
(brace
id|state
op_assign
l_string|&quot;weird&quot;
suffix:semicolon
)brace
r_else
id|state
op_assign
l_string|&quot;idle&quot;
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;&bslash;n&t;IrDA state: %s, &quot;
comma
id|state
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;daddr: %08x, &quot;
comma
id|self-&gt;daddr
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;stsap_sel: %02x, &quot;
comma
id|self-&gt;stsap_sel
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;dtsap_sel: %02x&bslash;n&quot;
comma
id|self-&gt;dtsap_sel
)paren
suffix:semicolon
multiline_comment|/* Next socket, please... */
id|self
op_assign
(paren
id|irnet_socket
op_star
)paren
id|hashbin_get_next
c_func
(paren
id|irnet_server.list
)paren
suffix:semicolon
)brace
multiline_comment|/* Spin lock end */
id|spin_unlock_bh
c_func
(paren
op_amp
id|irnet_server.spinlock
)paren
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
macro_line|#endif /* PROC_FS */
multiline_comment|/********************** CONFIGURATION/CLEANUP **********************/
multiline_comment|/*&n; * Initialisation and teardown of the IrDA part, called at module&n; * insertion and removal...&n; */
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Prepare the IrNET layer for operation...&n; */
r_int
id|__init
DECL|function|irda_irnet_init
id|irda_irnet_init
c_func
(paren
r_void
)paren
(brace
r_int
id|err
op_assign
l_int|0
suffix:semicolon
id|DENTER
c_func
(paren
id|MODULE_TRACE
comma
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Pure paranoia - should be redundant */
id|memset
c_func
(paren
op_amp
id|irnet_server
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|irnet_root
)paren
)paren
suffix:semicolon
multiline_comment|/* Setup start of irnet instance list */
id|irnet_server.list
op_assign
id|hashbin_new
c_func
(paren
id|HB_NOLOCK
)paren
suffix:semicolon
id|DABORT
c_func
(paren
id|irnet_server.list
op_eq
l_int|NULL
comma
op_minus
id|ENOMEM
comma
id|MODULE_ERROR
comma
l_string|&quot;Can&squot;t allocate hashbin!&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Init spinlock for instance list */
id|spin_lock_init
c_func
(paren
op_amp
id|irnet_server.spinlock
)paren
suffix:semicolon
multiline_comment|/* Initialise control channel */
id|init_waitqueue_head
c_func
(paren
op_amp
id|irnet_events.rwait
)paren
suffix:semicolon
id|irnet_events.index
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Init spinlock for event logging */
id|spin_lock_init
c_func
(paren
op_amp
id|irnet_events.spinlock
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_PROC_FS
multiline_comment|/* Add a /proc file for irnet infos */
id|create_proc_info_entry
c_func
(paren
l_string|&quot;irnet&quot;
comma
l_int|0
comma
id|proc_irda
comma
id|irnet_proc_read
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_PROC_FS */
multiline_comment|/* Setup the IrNET server */
id|err
op_assign
id|irnet_setup_server
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|err
)paren
(brace
multiline_comment|/* We are no longer functional... */
id|irnet_server.running
op_assign
l_int|1
suffix:semicolon
)brace
id|DEXIT
c_func
(paren
id|MODULE_TRACE
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Cleanup at exit...&n; */
r_void
id|__exit
DECL|function|irda_irnet_cleanup
id|irda_irnet_cleanup
c_func
(paren
r_void
)paren
(brace
id|DENTER
c_func
(paren
id|MODULE_TRACE
comma
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* We are no longer there... */
id|irnet_server.running
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef CONFIG_PROC_FS
multiline_comment|/* Remove our /proc file */
id|remove_proc_entry
c_func
(paren
l_string|&quot;irnet&quot;
comma
id|proc_irda
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_PROC_FS */
multiline_comment|/* Remove our IrNET server from existence */
id|irnet_destroy_server
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Remove all instances of IrNET socket still present */
id|hashbin_delete
c_func
(paren
id|irnet_server.list
comma
(paren
id|FREE_FUNC
)paren
id|irda_irnet_destroy
)paren
suffix:semicolon
id|DEXIT
c_func
(paren
id|MODULE_TRACE
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
eof
