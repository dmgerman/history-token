multiline_comment|/*********************************************************************&n; *&n; * Filename:      wrapper.c&n; * Version:       1.2&n; * Description:   IrDA SIR async wrapper layer&n; * Status:        Stable&n; * Author:        Dag Brattli &lt;dagb@cs.uit.no&gt;&n; * Created at:    Mon Aug  4 20:40:53 1997&n; * Modified at:   Fri Jan 28 13:21:09 2000&n; * Modified by:   Dag Brattli &lt;dagb@cs.uit.no&gt;&n; * Modified at:   Fri May 28  3:11 CST 1999&n; * Modified by:   Horst von Brand &lt;vonbrand@sleipnir.valparaiso.cl&gt;&n; *&n; *     Copyright (c) 1998-2000 Dag Brattli &lt;dagb@cs.uit.no&gt;,&n; *     All Rights Reserved.&n; *     Copyright (c) 2000-2002 Jean Tourrilhes &lt;jt@hpl.hp.com&gt;&n; *&n; *     This program is free software; you can redistribute it and/or&n; *     modify it under the terms of the GNU General Public License as&n; *     published by the Free Software Foundation; either version 2 of&n; *     the License, or (at your option) any later version.&n; *&n; *     Neither Dag Brattli nor University of Troms&#xfffd; admit liability nor&n; *     provide warranty for any of this software. This material is&n; *     provided &quot;AS-IS&quot; and at no charge.&n; *&n; ********************************************************************/
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;asm/byteorder.h&gt;
macro_line|#include &lt;net/irda/irda.h&gt;
macro_line|#include &lt;net/irda/wrapper.h&gt;
macro_line|#include &lt;net/irda/crc.h&gt;
macro_line|#include &lt;net/irda/irlap.h&gt;
macro_line|#include &lt;net/irda/irlap_frame.h&gt;
macro_line|#include &lt;net/irda/irda_device.h&gt;
multiline_comment|/************************** FRAME WRAPPING **************************/
multiline_comment|/*&n; * Unwrap and unstuff SIR frames&n; *&n; * Note : at FIR and MIR, HDLC framing is used and usually handled&n; * by the controller, so we come here only for SIR... Jean II&n; */
multiline_comment|/*&n; * Function stuff_byte (byte, buf)&n; *&n; *    Byte stuff one single byte and put the result in buffer pointed to by&n; *    buf. The buffer must at all times be able to have two bytes inserted.&n; *&n; * This is in a tight loop, better inline it, so need to be prior to callers.&n; * (2000 bytes on P6 200MHz, non-inlined ~370us, inline ~170us) - Jean II&n; */
DECL|function|stuff_byte
r_static
r_inline
r_int
id|stuff_byte
c_func
(paren
id|__u8
id|byte
comma
id|__u8
op_star
id|buf
)paren
(brace
r_switch
c_cond
(paren
id|byte
)paren
(brace
r_case
id|BOF
suffix:colon
multiline_comment|/* FALLTHROUGH */
r_case
id|EOF
suffix:colon
multiline_comment|/* FALLTHROUGH */
r_case
id|CE
suffix:colon
multiline_comment|/* Insert transparently coded */
id|buf
(braket
l_int|0
)braket
op_assign
id|CE
suffix:semicolon
multiline_comment|/* Send link escape */
id|buf
(braket
l_int|1
)braket
op_assign
id|byte
op_xor
id|IRDA_TRANS
suffix:semicolon
multiline_comment|/* Complement bit 5 */
r_return
l_int|2
suffix:semicolon
multiline_comment|/* break; */
r_default
suffix:colon
multiline_comment|/* Non-special value, no transparency required */
id|buf
(braket
l_int|0
)braket
op_assign
id|byte
suffix:semicolon
r_return
l_int|1
suffix:semicolon
multiline_comment|/* break; */
)brace
)brace
multiline_comment|/*&n; * Function async_wrap (skb, *tx_buff, buffsize)&n; *&n; *    Makes a new buffer with wrapping and stuffing, should check that&n; *    we don&squot;t get tx buffer overflow.&n; */
DECL|function|async_wrap_skb
r_int
id|async_wrap_skb
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
id|__u8
op_star
id|tx_buff
comma
r_int
id|buffsize
)paren
(brace
r_struct
id|irda_skb_cb
op_star
id|cb
op_assign
(paren
r_struct
id|irda_skb_cb
op_star
)paren
id|skb-&gt;cb
suffix:semicolon
r_int
id|xbofs
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|n
suffix:semicolon
r_union
(brace
id|__u16
id|value
suffix:semicolon
id|__u8
id|bytes
(braket
l_int|2
)braket
suffix:semicolon
)brace
id|fcs
suffix:semicolon
multiline_comment|/* Initialize variables */
id|fcs.value
op_assign
id|INIT_FCS
suffix:semicolon
id|n
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; *  Send  XBOF&squot;s for required min. turn time and for the negotiated&n;&t; *  additional XBOFS&n;&t; */
r_if
c_cond
(paren
id|cb-&gt;magic
op_ne
id|LAP_MAGIC
)paren
(brace
multiline_comment|/*&n;&t;&t; * This will happen for all frames sent from user-space.&n;&t;&t; * Nothing to worry about, but we set the default number of&n;&t;&t; * BOF&squot;s&n;&t;&t; */
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;%s(), wrong magic in skb!&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
id|xbofs
op_assign
l_int|10
suffix:semicolon
)brace
r_else
id|xbofs
op_assign
id|cb-&gt;xbofs
op_plus
id|cb-&gt;xbofs_delay
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|4
comma
l_string|&quot;%s(), xbofs=%d&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|xbofs
)paren
suffix:semicolon
multiline_comment|/* Check that we never use more than 115 + 48 xbofs */
r_if
c_cond
(paren
id|xbofs
OG
l_int|163
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
l_string|&quot;%s(), too many xbofs (%d)&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|xbofs
)paren
suffix:semicolon
id|xbofs
op_assign
l_int|163
suffix:semicolon
)brace
id|memset
c_func
(paren
id|tx_buff
op_plus
id|n
comma
id|XBOF
comma
id|xbofs
)paren
suffix:semicolon
id|n
op_add_assign
id|xbofs
suffix:semicolon
multiline_comment|/* Start of packet character BOF */
id|tx_buff
(braket
id|n
op_increment
)braket
op_assign
id|BOF
suffix:semicolon
multiline_comment|/* Insert frame and calc CRC */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|skb-&gt;len
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/*&n;&t;&t; *  Check for the possibility of tx buffer overflow. We use&n;&t;&t; *  bufsize-5 since the maximum number of bytes that can be&n;&t;&t; *  transmitted after this point is 5.&n;&t;&t; */
r_if
c_cond
(paren
id|n
op_ge
(paren
id|buffsize
op_minus
l_int|5
)paren
)paren
(brace
id|IRDA_ERROR
c_func
(paren
l_string|&quot;%s(), tx buffer overflow (n=%d)&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|n
)paren
suffix:semicolon
r_return
id|n
suffix:semicolon
)brace
id|n
op_add_assign
id|stuff_byte
c_func
(paren
id|skb-&gt;data
(braket
id|i
)braket
comma
id|tx_buff
op_plus
id|n
)paren
suffix:semicolon
id|fcs.value
op_assign
id|irda_fcs
c_func
(paren
id|fcs.value
comma
id|skb-&gt;data
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/* Insert CRC in little endian format (LSB first) */
id|fcs.value
op_assign
op_complement
id|fcs.value
suffix:semicolon
macro_line|#ifdef __LITTLE_ENDIAN
id|n
op_add_assign
id|stuff_byte
c_func
(paren
id|fcs.bytes
(braket
l_int|0
)braket
comma
id|tx_buff
op_plus
id|n
)paren
suffix:semicolon
id|n
op_add_assign
id|stuff_byte
c_func
(paren
id|fcs.bytes
(braket
l_int|1
)braket
comma
id|tx_buff
op_plus
id|n
)paren
suffix:semicolon
macro_line|#else /* ifdef __BIG_ENDIAN */
id|n
op_add_assign
id|stuff_byte
c_func
(paren
id|fcs.bytes
(braket
l_int|1
)braket
comma
id|tx_buff
op_plus
id|n
)paren
suffix:semicolon
id|n
op_add_assign
id|stuff_byte
c_func
(paren
id|fcs.bytes
(braket
l_int|0
)braket
comma
id|tx_buff
op_plus
id|n
)paren
suffix:semicolon
macro_line|#endif
id|tx_buff
(braket
id|n
op_increment
)braket
op_assign
id|EOF
suffix:semicolon
r_return
id|n
suffix:semicolon
)brace
DECL|variable|async_wrap_skb
id|EXPORT_SYMBOL
c_func
(paren
id|async_wrap_skb
)paren
suffix:semicolon
multiline_comment|/************************* FRAME UNWRAPPING *************************/
multiline_comment|/*&n; * Unwrap and unstuff SIR frames&n; *&n; * Complete rewrite by Jean II :&n; * More inline, faster, more compact, more logical. Jean II&n; * (16 bytes on P6 200MHz, old 5 to 7 us, new 4 to 6 us)&n; * (24 bytes on P6 200MHz, old 9 to 10 us, new 7 to 8 us)&n; * (for reference, 115200 b/s is 1 byte every 69 us)&n; * And reduce wrapper.o by ~900B in the process ;-)&n; *&n; * Then, we have the addition of ZeroCopy, which is optional&n; * (i.e. the driver must initiate it) and improve final processing.&n; * (2005 B frame + EOF on P6 200MHz, without 30 to 50 us, with 10 to 25 us)&n; *&n; * Note : at FIR and MIR, HDLC framing is used and usually handled&n; * by the controller, so we come here only for SIR... Jean II&n; */
multiline_comment|/*&n; * We can also choose where we want to do the CRC calculation. We can&n; * do it &quot;inline&quot;, as we receive the bytes, or &quot;postponed&quot;, when&n; * receiving the End-Of-Frame.&n; * (16 bytes on P6 200MHz, inlined 4 to 6 us, postponed 4 to 5 us)&n; * (24 bytes on P6 200MHz, inlined 7 to 8 us, postponed 5 to 7 us)&n; * With ZeroCopy :&n; * (2005 B frame on P6 200MHz, inlined 10 to 25 us, postponed 140 to 180 us)&n; * Without ZeroCopy :&n; * (2005 B frame on P6 200MHz, inlined 30 to 50 us, postponed 150 to 180 us)&n; * (Note : numbers taken with irq disabled)&n; *&n; * From those numbers, it&squot;s not clear which is the best strategy, because&n; * we end up running through a lot of data one way or another (i.e. cache&n; * misses). I personally prefer to avoid the huge latency spike of the&n; * &quot;postponed&quot; solution, because it come just at the time when we have&n; * lot&squot;s of protocol processing to do and it will hurt our ability to&n; * reach low link turnaround times... Jean II&n; */
singleline_comment|//#define POSTPONE_RX_CRC
multiline_comment|/*&n; * Function async_bump (buf, len, stats)&n; *&n; *    Got a frame, make a copy of it, and pass it up the stack! We can try&n; *    to inline it since it&squot;s only called from state_inside_frame&n; */
r_static
r_inline
r_void
DECL|function|async_bump
id|async_bump
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|net_device_stats
op_star
id|stats
comma
id|iobuff_t
op_star
id|rx_buff
)paren
(brace
r_struct
id|sk_buff
op_star
id|newskb
suffix:semicolon
r_struct
id|sk_buff
op_star
id|dataskb
suffix:semicolon
r_int
id|docopy
suffix:semicolon
multiline_comment|/* Check if we need to copy the data to a new skb or not.&n;&t; * If the driver doesn&squot;t use ZeroCopy Rx, we have to do it.&n;&t; * With ZeroCopy Rx, the rx_buff already point to a valid&n;&t; * skb. But, if the frame is small, it is more efficient to&n;&t; * copy it to save memory (copy will be fast anyway - that&squot;s&n;&t; * called Rx-copy-break). Jean II */
id|docopy
op_assign
(paren
(paren
id|rx_buff-&gt;skb
op_eq
l_int|NULL
)paren
op_logical_or
(paren
id|rx_buff-&gt;len
OL
id|IRDA_RX_COPY_THRESHOLD
)paren
)paren
suffix:semicolon
multiline_comment|/* Allocate a new skb */
id|newskb
op_assign
id|dev_alloc_skb
c_func
(paren
id|docopy
ques
c_cond
id|rx_buff-&gt;len
op_plus
l_int|1
suffix:colon
id|rx_buff-&gt;truesize
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|newskb
)paren
(brace
id|stats-&gt;rx_dropped
op_increment
suffix:semicolon
multiline_comment|/* We could deliver the current skb if doing ZeroCopy Rx,&n;&t;&t; * but this would stall the Rx path. Better drop the&n;&t;&t; * packet... Jean II */
r_return
suffix:semicolon
)brace
multiline_comment|/* Align IP header to 20 bytes (i.e. increase skb-&gt;data)&n;&t; * Note this is only useful with IrLAN, as PPP has a variable&n;&t; * header size (2 or 1 bytes) - Jean II */
id|skb_reserve
c_func
(paren
id|newskb
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|docopy
)paren
(brace
multiline_comment|/* Copy data without CRC (lenght already checked) */
id|memcpy
c_func
(paren
id|newskb-&gt;data
comma
id|rx_buff-&gt;data
comma
id|rx_buff-&gt;len
op_minus
l_int|2
)paren
suffix:semicolon
multiline_comment|/* Deliver this skb */
id|dataskb
op_assign
id|newskb
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* We are using ZeroCopy. Deliver old skb */
id|dataskb
op_assign
id|rx_buff-&gt;skb
suffix:semicolon
multiline_comment|/* And hook the new skb to the rx_buff */
id|rx_buff-&gt;skb
op_assign
id|newskb
suffix:semicolon
id|rx_buff-&gt;head
op_assign
id|newskb-&gt;data
suffix:semicolon
multiline_comment|/* NOT newskb-&gt;head */
singleline_comment|//printk(KERN_DEBUG &quot;ZeroCopy : len = %d, dataskb = %p, newskb = %p&bslash;n&quot;, rx_buff-&gt;len, dataskb, newskb);
)brace
multiline_comment|/* Set proper length on skb (without CRC) */
id|skb_put
c_func
(paren
id|dataskb
comma
id|rx_buff-&gt;len
op_minus
l_int|2
)paren
suffix:semicolon
multiline_comment|/* Feed it to IrLAP layer */
id|dataskb-&gt;dev
op_assign
id|dev
suffix:semicolon
id|dataskb-&gt;mac.raw
op_assign
id|dataskb-&gt;data
suffix:semicolon
id|dataskb-&gt;protocol
op_assign
id|htons
c_func
(paren
id|ETH_P_IRDA
)paren
suffix:semicolon
id|netif_rx
c_func
(paren
id|dataskb
)paren
suffix:semicolon
id|stats-&gt;rx_packets
op_increment
suffix:semicolon
id|stats-&gt;rx_bytes
op_add_assign
id|rx_buff-&gt;len
suffix:semicolon
multiline_comment|/* Clean up rx_buff (redundant with async_unwrap_bof() ???) */
id|rx_buff-&gt;data
op_assign
id|rx_buff-&gt;head
suffix:semicolon
id|rx_buff-&gt;len
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Function async_unwrap_bof(dev, byte)&n; *&n; *    Handle Beginning Of Frame character received within a frame&n; *&n; */
r_static
r_inline
r_void
DECL|function|async_unwrap_bof
id|async_unwrap_bof
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|net_device_stats
op_star
id|stats
comma
id|iobuff_t
op_star
id|rx_buff
comma
id|__u8
id|byte
)paren
(brace
r_switch
c_cond
(paren
id|rx_buff-&gt;state
)paren
(brace
r_case
id|LINK_ESCAPE
suffix:colon
r_case
id|INSIDE_FRAME
suffix:colon
multiline_comment|/* Not supposed to happen, the previous frame is not&n;&t;&t; * finished - Jean II */
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;%s(), Discarding incomplete frame&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
id|stats-&gt;rx_errors
op_increment
suffix:semicolon
id|stats-&gt;rx_missed_errors
op_increment
suffix:semicolon
id|irda_device_set_media_busy
c_func
(paren
id|dev
comma
id|TRUE
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OUTSIDE_FRAME
suffix:colon
r_case
id|BEGIN_FRAME
suffix:colon
r_default
suffix:colon
multiline_comment|/* We may receive multiple BOF at the start of frame */
r_break
suffix:semicolon
)brace
multiline_comment|/* Now receiving frame */
id|rx_buff-&gt;state
op_assign
id|BEGIN_FRAME
suffix:semicolon
id|rx_buff-&gt;in_frame
op_assign
id|TRUE
suffix:semicolon
multiline_comment|/* Time to initialize receive buffer */
id|rx_buff-&gt;data
op_assign
id|rx_buff-&gt;head
suffix:semicolon
id|rx_buff-&gt;len
op_assign
l_int|0
suffix:semicolon
id|rx_buff-&gt;fcs
op_assign
id|INIT_FCS
suffix:semicolon
)brace
multiline_comment|/*&n; * Function async_unwrap_eof(dev, byte)&n; *&n; *    Handle End Of Frame character received within a frame&n; *&n; */
r_static
r_inline
r_void
DECL|function|async_unwrap_eof
id|async_unwrap_eof
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|net_device_stats
op_star
id|stats
comma
id|iobuff_t
op_star
id|rx_buff
comma
id|__u8
id|byte
)paren
(brace
macro_line|#ifdef POSTPONE_RX_CRC
r_int
id|i
suffix:semicolon
macro_line|#endif
r_switch
c_cond
(paren
id|rx_buff-&gt;state
)paren
(brace
r_case
id|OUTSIDE_FRAME
suffix:colon
multiline_comment|/* Probably missed the BOF */
id|stats-&gt;rx_errors
op_increment
suffix:semicolon
id|stats-&gt;rx_missed_errors
op_increment
suffix:semicolon
id|irda_device_set_media_busy
c_func
(paren
id|dev
comma
id|TRUE
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BEGIN_FRAME
suffix:colon
r_case
id|LINK_ESCAPE
suffix:colon
r_case
id|INSIDE_FRAME
suffix:colon
r_default
suffix:colon
multiline_comment|/* Note : in the case of BEGIN_FRAME and LINK_ESCAPE,&n;&t;&t; * the fcs will most likely not match and generate an&n;&t;&t; * error, as expected - Jean II */
id|rx_buff-&gt;state
op_assign
id|OUTSIDE_FRAME
suffix:semicolon
id|rx_buff-&gt;in_frame
op_assign
id|FALSE
suffix:semicolon
macro_line|#ifdef POSTPONE_RX_CRC
multiline_comment|/* If we haven&squot;t done the CRC as we receive bytes, we&n;&t;&t; * must do it now... Jean II */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|rx_buff-&gt;len
suffix:semicolon
id|i
op_increment
)paren
(brace
id|rx_buff-&gt;fcs
op_assign
id|irda_fcs
c_func
(paren
id|rx_buff-&gt;fcs
comma
id|rx_buff-&gt;data
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* Test FCS and signal success if the frame is good */
r_if
c_cond
(paren
id|rx_buff-&gt;fcs
op_eq
id|GOOD_FCS
)paren
(brace
multiline_comment|/* Deliver frame */
id|async_bump
c_func
(paren
id|dev
comma
id|stats
comma
id|rx_buff
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Wrong CRC, discard frame!  */
id|irda_device_set_media_busy
c_func
(paren
id|dev
comma
id|TRUE
)paren
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;%s(), crc error&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
id|stats-&gt;rx_errors
op_increment
suffix:semicolon
id|stats-&gt;rx_crc_errors
op_increment
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Function async_unwrap_ce(dev, byte)&n; *&n; *    Handle Character Escape character received within a frame&n; *&n; */
r_static
r_inline
r_void
DECL|function|async_unwrap_ce
id|async_unwrap_ce
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|net_device_stats
op_star
id|stats
comma
id|iobuff_t
op_star
id|rx_buff
comma
id|__u8
id|byte
)paren
(brace
r_switch
c_cond
(paren
id|rx_buff-&gt;state
)paren
(brace
r_case
id|OUTSIDE_FRAME
suffix:colon
multiline_comment|/* Activate carrier sense */
id|irda_device_set_media_busy
c_func
(paren
id|dev
comma
id|TRUE
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|LINK_ESCAPE
suffix:colon
id|IRDA_WARNING
c_func
(paren
l_string|&quot;%s: state not defined&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BEGIN_FRAME
suffix:colon
r_case
id|INSIDE_FRAME
suffix:colon
r_default
suffix:colon
multiline_comment|/* Stuffed byte coming */
id|rx_buff-&gt;state
op_assign
id|LINK_ESCAPE
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Function async_unwrap_other(dev, byte)&n; *&n; *    Handle other characters received within a frame&n; *&n; */
r_static
r_inline
r_void
DECL|function|async_unwrap_other
id|async_unwrap_other
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|net_device_stats
op_star
id|stats
comma
id|iobuff_t
op_star
id|rx_buff
comma
id|__u8
id|byte
)paren
(brace
r_switch
c_cond
(paren
id|rx_buff-&gt;state
)paren
(brace
multiline_comment|/* This is on the critical path, case are ordered by&n;&t;&t; * probability (most frequent first) - Jean II */
r_case
id|INSIDE_FRAME
suffix:colon
multiline_comment|/* Must be the next byte of the frame */
r_if
c_cond
(paren
id|rx_buff-&gt;len
OL
id|rx_buff-&gt;truesize
)paren
(brace
id|rx_buff-&gt;data
(braket
id|rx_buff-&gt;len
op_increment
)braket
op_assign
id|byte
suffix:semicolon
macro_line|#ifndef POSTPONE_RX_CRC
id|rx_buff-&gt;fcs
op_assign
id|irda_fcs
c_func
(paren
id|rx_buff-&gt;fcs
comma
id|byte
)paren
suffix:semicolon
macro_line|#endif
)brace
r_else
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;%s(), Rx buffer overflow, aborting&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
id|rx_buff-&gt;state
op_assign
id|OUTSIDE_FRAME
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|LINK_ESCAPE
suffix:colon
multiline_comment|/*&n;&t;&t; *  Stuffed char, complement bit 5 of byte&n;&t;&t; *  following CE, IrLAP p.114&n;&t;&t; */
id|byte
op_xor_assign
id|IRDA_TRANS
suffix:semicolon
r_if
c_cond
(paren
id|rx_buff-&gt;len
OL
id|rx_buff-&gt;truesize
)paren
(brace
id|rx_buff-&gt;data
(braket
id|rx_buff-&gt;len
op_increment
)braket
op_assign
id|byte
suffix:semicolon
macro_line|#ifndef POSTPONE_RX_CRC
id|rx_buff-&gt;fcs
op_assign
id|irda_fcs
c_func
(paren
id|rx_buff-&gt;fcs
comma
id|byte
)paren
suffix:semicolon
macro_line|#endif
id|rx_buff-&gt;state
op_assign
id|INSIDE_FRAME
suffix:semicolon
)brace
r_else
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;%s(), Rx buffer overflow, aborting&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
id|rx_buff-&gt;state
op_assign
id|OUTSIDE_FRAME
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|OUTSIDE_FRAME
suffix:colon
multiline_comment|/* Activate carrier sense */
r_if
c_cond
(paren
id|byte
op_ne
id|XBOF
)paren
(brace
id|irda_device_set_media_busy
c_func
(paren
id|dev
comma
id|TRUE
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|BEGIN_FRAME
suffix:colon
r_default
suffix:colon
id|rx_buff-&gt;data
(braket
id|rx_buff-&gt;len
op_increment
)braket
op_assign
id|byte
suffix:semicolon
macro_line|#ifndef POSTPONE_RX_CRC
id|rx_buff-&gt;fcs
op_assign
id|irda_fcs
c_func
(paren
id|rx_buff-&gt;fcs
comma
id|byte
)paren
suffix:semicolon
macro_line|#endif
id|rx_buff-&gt;state
op_assign
id|INSIDE_FRAME
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Function async_unwrap_char (dev, rx_buff, byte)&n; *&n; *    Parse and de-stuff frame received from the IrDA-port&n; *&n; * This is the main entry point for SIR drivers.&n; */
DECL|function|async_unwrap_char
r_void
id|async_unwrap_char
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|net_device_stats
op_star
id|stats
comma
id|iobuff_t
op_star
id|rx_buff
comma
id|__u8
id|byte
)paren
(brace
r_switch
c_cond
(paren
id|byte
)paren
(brace
r_case
id|CE
suffix:colon
id|async_unwrap_ce
c_func
(paren
id|dev
comma
id|stats
comma
id|rx_buff
comma
id|byte
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BOF
suffix:colon
id|async_unwrap_bof
c_func
(paren
id|dev
comma
id|stats
comma
id|rx_buff
comma
id|byte
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|EOF
suffix:colon
id|async_unwrap_eof
c_func
(paren
id|dev
comma
id|stats
comma
id|rx_buff
comma
id|byte
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|async_unwrap_other
c_func
(paren
id|dev
comma
id|stats
comma
id|rx_buff
comma
id|byte
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
DECL|variable|async_unwrap_char
id|EXPORT_SYMBOL
c_func
(paren
id|async_unwrap_char
)paren
suffix:semicolon
eof
