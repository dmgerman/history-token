multiline_comment|/*****************************************************************************&n;* af_wanpipe.c&t;WANPIPE(tm) Secure Socket Layer.&n;*&n;* Author:&t;Nenad Corbic&t;&lt;ncorbic@sangoma.com&gt;&n;*&n;* Copyright:&t;(c) 2000 Sangoma Technologies Inc.&n;*&n;*&t;&t;This program is free software; you can redistribute it and/or&n;*&t;&t;modify it under the terms of the GNU General Public License&n;*&t;&t;as published by the Free Software Foundation; either version&n;*&t;&t;2 of the License, or (at your option) any later version.&n;* ============================================================================&n;* Due Credit:&n;*               Wanpipe socket layer is based on Packet and &n;*               the X25 socket layers. The above sockets were &n;*               used for the specific use of Sangoma Technoloiges &n;*               API programs. &n;*               Packet socket Authors: Ross Biro, Fred N. van Kempen and &n;*                                      Alan Cox.&n;*               X25 socket Author: Jonathan Naylor.&n;* ============================================================================&n;* Apr 25, 2000  Nenad Corbic     o Added the ability to send zero length packets.&n;* Mar 13, 2000  Nenad Corbic&t; o Added a tx buffer check via ioctl call.&n;* Mar 06, 2000  Nenad Corbic     o Fixed the corrupt sock lcn problem.&n;*                                  Server and client applicaton can run&n;*                                  simultaneously without conflicts.&n;* Feb 29, 2000  Nenad Corbic     o Added support for PVC protocols, such as&n;*                                  CHDLC, Frame Relay and HDLC API.&n;* Jan 17, 2000 &t;Nenad Corbic&t; o Initial version, based on AF_PACKET socket.&n;*&t;&t;&t;           X25API support only. &n;*&n;******************************************************************************/
macro_line|#include &lt;linux/version.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/socket.h&gt;
macro_line|#include &lt;linux/in.h&gt;
macro_line|#include &lt;linux/inet.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/poll.h&gt;
macro_line|#include &lt;linux/wireless.h&gt;
macro_line|#include &lt;linux/kmod.h&gt;
macro_line|#include &lt;net/ip.h&gt;
macro_line|#include &lt;net/protocol.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;net/sock.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/wanpipe.h&gt;
macro_line|#include &lt;linux/if_wanpipe.h&gt;
macro_line|#include &lt;linux/pkt_sched.h&gt;
macro_line|#include &lt;linux/tcp.h&gt;
macro_line|#include &lt;linux/if_wanpipe_common.h&gt;
macro_line|#include &lt;linux/sdla_x25.h&gt;
macro_line|#ifdef CONFIG_INET
macro_line|#include &lt;net/inet_common.h&gt;
macro_line|#endif
DECL|macro|SLOW_BACKOFF
mdefine_line|#define SLOW_BACKOFF 0.1*HZ
DECL|macro|FAST_BACKOFF
mdefine_line|#define FAST_BACKOFF 0.01*HZ
singleline_comment|//#define PRINT_DEBUG
macro_line|#ifdef PRINT_DEBUG
DECL|macro|DBG_PRINTK
mdefine_line|#define DBG_PRINTK(format, a...) printk(format, ## a)
macro_line|#else
DECL|macro|DBG_PRINTK
mdefine_line|#define DBG_PRINTK(format, a...)
macro_line|#endif      
macro_line|#if defined(LINUX_2_1)
DECL|macro|dev_put
mdefine_line|#define dev_put(a)
DECL|macro|__sock_put
mdefine_line|#define __sock_put(a)
DECL|macro|sock_hold
mdefine_line|#define sock_hold(a)
DECL|macro|DECLARE_WAITQUEUE
mdefine_line|#define DECLARE_WAITQUEUE(a,b) &bslash;&n;&t;&t;struct wait_queue a = { b, NULL }
macro_line|#endif
multiline_comment|/* SECURE SOCKET IMPLEMENTATION &n; * &n; *   TRANSMIT:&n; *&n; *      When the user sends a packet via send() system call&n; *      the wanpipe_sendmsg() function is executed.  &n; *      &n; *      Each packet is enqueud into sk-&gt;write_queue transmit&n; *      queue. When the packet is enqueued, a delayed transmit&n; *      timer is triggerd which acts as a Bottom Half hander. &n; *&n; *      wanpipe_delay_transmit() function (BH), dequeues packets&n; *      from the sk-&gt;write_queue transmit queue and sends it &n; *      to the deriver via dev-&gt;hard_start_xmit(skb, dev) function.  &n; *      Note, this function is actual a function pointer of if_send()&n; *      routine in the wanpipe driver.&n; *&n; *      X25API GUARANTEED DELIVERY:&n; *&n; *         In order to provide 100% guaranteed packet delivery, &n; *         an atomic &squot;packet_sent&squot; counter is implemented.  Counter &n; *         is incremented for each packet enqueued &n; *         into sk-&gt;write_queue.  Counter is decremented each&n; *         time wanpipe_delayed_transmit() function successfuly &n; *         passes the packet to the driver. Before each send(), a poll&n; *         routine checks the sock resources The maximum value of&n; *         packet sent counter is 1, thus if one packet is queued, the&n; *         application will block untill that packet is passed to the&n; *         driver.&n; *&n; *   RECEIVE:&n; *&n; *      Wanpipe device drivers call the socket bottom half&n; *      function, wanpipe_rcv() to queue the incoming packets&n; *      into an AF_WANPIPE socket queue.  Based on wanpipe_rcv()&n; *      return code, the driver knows whether the packet was&n; *      sucessfully queued.  If the socket queue is full, &n; *      protocol flow control is used by the driver, if any, &n; *      to slow down the traffic untill the sock queue is free.&n; *&n; *      Every time a packet arrives into a socket queue the &n; *      socket wakes up processes which are waiting to receive&n; *      data.&n; *&n; *      If the socket queue is full, the driver sets a block&n; *      bit which signals the socket to kick the wanpipe driver&n; *      bottom half hander when the socket queue is partialy&n; *      empty. wanpipe_recvmsg() function performs this action.&n; * &n; *      In case of x25api, packets will never be dropped, since&n; *      flow control is available. &n; *      &n; *      In case of streaming protocols like CHDLC, packets will &n; *      be dropped but the statistics will be generated. &n; */
multiline_comment|/* The code below is used to test memory leaks. It prints out&n; * a message every time kmalloc and kfree system calls get executed.&n; * If the calls match there is no leak :)&n; */
multiline_comment|/***********FOR DEBUGGING PURPOSES*********************************************&n;#define KMEM_SAFETYZONE 8&n;&n;static void * dbg_kmalloc(unsigned int size, int prio, int line) {&n;&t;void * v = kmalloc(size,prio);&n;&t;printk(KERN_INFO &quot;line %d  kmalloc(%d,%d) = %p&bslash;n&quot;,line,size,prio,v);&n;&t;return v;&n;}&n;static void dbg_kfree(void * v, int line) {&n;&t;printk(KERN_INFO &quot;line %d  kfree(%p)&bslash;n&quot;,line,v);&n;&t;kfree(v);&n;}&n;&n;#define kmalloc(x,y) dbg_kmalloc(x,y,__LINE__)&n;#define kfree(x) dbg_kfree(x,__LINE__)&n;******************************************************************************/
multiline_comment|/* List of all wanpipe sockets. */
DECL|variable|wanpipe_sklist
r_struct
id|sock
op_star
id|wanpipe_sklist
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|wanpipe_sklist_lock
r_static
id|rwlock_t
id|wanpipe_sklist_lock
op_assign
id|RW_LOCK_UNLOCKED
suffix:semicolon
DECL|variable|wanpipe_socks_nr
id|atomic_t
id|wanpipe_socks_nr
suffix:semicolon
DECL|variable|wanpipe_tx_critical
r_static
r_int
r_int
id|wanpipe_tx_critical
op_assign
l_int|0
suffix:semicolon
macro_line|#if 0
multiline_comment|/* Private wanpipe socket structures. */
r_struct
id|wanpipe_opt
(brace
r_void
op_star
id|mbox
suffix:semicolon
multiline_comment|/* Mail box  */
r_void
op_star
id|card
suffix:semicolon
multiline_comment|/* Card bouded to */
id|netdevice_t
op_star
id|dev
suffix:semicolon
multiline_comment|/* Bounded device */
r_int
r_int
id|lcn
suffix:semicolon
multiline_comment|/* Binded LCN */
r_int
r_char
id|svc
suffix:semicolon
multiline_comment|/* 0=pvc, 1=svc */
r_int
r_char
id|timer
suffix:semicolon
multiline_comment|/* flag for delayed transmit*/
r_struct
id|timer_list
id|tx_timer
suffix:semicolon
r_int
id|poll_cnt
suffix:semicolon
r_int
r_char
id|force
suffix:semicolon
multiline_comment|/* Used to force sock release */
id|atomic_t
id|packet_sent
suffix:semicolon
)brace
suffix:semicolon
macro_line|#endif
DECL|variable|sk_count
r_static
r_int
id|sk_count
op_assign
l_int|0
suffix:semicolon
r_extern
r_struct
id|proto_ops
id|wanpipe_ops
suffix:semicolon
DECL|variable|find_free_critical
r_static
r_int
r_int
id|find_free_critical
op_assign
l_int|0
suffix:semicolon
r_static
r_void
id|wanpipe_unlink_driver
(paren
r_struct
id|sock
op_star
)paren
suffix:semicolon
r_static
r_void
id|wanpipe_link_driver
(paren
id|netdevice_t
op_star
comma
r_struct
id|sock
op_star
id|sk
)paren
suffix:semicolon
r_static
r_void
id|wanpipe_wakeup_driver
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
suffix:semicolon
r_static
r_int
id|execute_command
c_func
(paren
r_struct
id|sock
op_star
comma
r_int
r_char
comma
r_int
r_int
)paren
suffix:semicolon
r_static
r_int
id|check_dev
(paren
id|netdevice_t
op_star
comma
id|sdla_t
op_star
)paren
suffix:semicolon
id|netdevice_t
op_star
id|wanpipe_find_free_dev
(paren
id|sdla_t
op_star
)paren
suffix:semicolon
r_static
r_void
id|wanpipe_unlink_card
(paren
r_struct
id|sock
op_star
)paren
suffix:semicolon
r_static
r_int
id|wanpipe_link_card
(paren
r_struct
id|sock
op_star
)paren
suffix:semicolon
r_static
r_struct
id|sock
op_star
id|wanpipe_make_new
c_func
(paren
r_struct
id|sock
op_star
)paren
suffix:semicolon
r_static
r_struct
id|sock
op_star
id|wanpipe_alloc_socket
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_inline
r_int
id|get_atomic_device
(paren
id|netdevice_t
op_star
)paren
suffix:semicolon
r_static
r_int
id|wanpipe_exec_cmd
c_func
(paren
r_struct
id|sock
op_star
comma
r_int
comma
r_int
r_int
)paren
suffix:semicolon
r_static
r_int
id|get_ioctl_cmd
(paren
r_struct
id|sock
op_star
comma
r_void
op_star
)paren
suffix:semicolon
r_static
r_int
id|set_ioctl_cmd
(paren
r_struct
id|sock
op_star
comma
r_void
op_star
)paren
suffix:semicolon
r_static
r_void
id|release_device
(paren
id|netdevice_t
op_star
)paren
suffix:semicolon
r_static
r_void
id|wanpipe_kill_sock_timer
(paren
r_int
r_int
id|data
)paren
suffix:semicolon
r_static
r_void
id|wanpipe_kill_sock_irq
(paren
r_struct
id|sock
op_star
)paren
suffix:semicolon
r_static
r_void
id|wanpipe_kill_sock_accept
(paren
r_struct
id|sock
op_star
)paren
suffix:semicolon
r_static
r_int
id|wanpipe_do_bind
c_func
(paren
r_struct
id|sock
op_star
comma
id|netdevice_t
op_star
comma
r_int
)paren
suffix:semicolon
r_struct
id|sock
op_star
id|get_newsk_from_skb
(paren
r_struct
id|sk_buff
op_star
)paren
suffix:semicolon
r_static
r_int
id|wanpipe_debug
(paren
r_struct
id|sock
op_star
comma
r_void
op_star
)paren
suffix:semicolon
r_static
r_void
id|wanpipe_delayed_transmit
(paren
r_int
r_int
id|data
)paren
suffix:semicolon
r_static
r_void
id|release_driver
c_func
(paren
r_struct
id|sock
op_star
)paren
suffix:semicolon
r_static
r_void
id|start_cleanup_timer
(paren
r_struct
id|sock
op_star
)paren
suffix:semicolon
r_static
r_void
id|check_write_queue
c_func
(paren
r_struct
id|sock
op_star
)paren
suffix:semicolon
r_static
r_int
id|check_driver_busy
(paren
r_struct
id|sock
op_star
)paren
suffix:semicolon
multiline_comment|/*============================================================&n; * wanpipe_rcv&n; *&n; *&t;Wanpipe socket bottom half handler.  This function&n; *      is called by the WANPIPE device drivers to queue a&n; *      incomming packet into the socket receive queue. &n; *      Once the packet is queued, all processes waiting to &n; *      read are woken up.&n; *&n; *      During socket bind, this function is bounded into&n; *      WANPIPE driver private.&n; *===========================================================*/
DECL|function|wanpipe_rcv
r_static
r_int
id|wanpipe_rcv
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
id|netdevice_t
op_star
id|dev
comma
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|wan_sockaddr_ll
op_star
id|sll
op_assign
(paren
r_struct
id|wan_sockaddr_ll
op_star
)paren
id|skb-&gt;cb
suffix:semicolon
id|wanpipe_common_t
op_star
id|chan
op_assign
id|dev-&gt;priv
suffix:semicolon
multiline_comment|/*&n;&t; *&t;When we registered the protocol we saved the socket in the data&n;&t; *&t;field for just this event.&n;&t; */
id|skb-&gt;dev
op_assign
id|dev
suffix:semicolon
id|sll-&gt;sll_family
op_assign
id|AF_WANPIPE
suffix:semicolon
id|sll-&gt;sll_hatype
op_assign
id|dev-&gt;type
suffix:semicolon
id|sll-&gt;sll_protocol
op_assign
id|skb-&gt;protocol
suffix:semicolon
id|sll-&gt;sll_pkttype
op_assign
id|skb-&gt;pkt_type
suffix:semicolon
id|sll-&gt;sll_ifindex
op_assign
id|dev-&gt;ifindex
suffix:semicolon
id|sll-&gt;sll_halen
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;hard_header_parse
)paren
id|sll-&gt;sll_halen
op_assign
id|dev
op_member_access_from_pointer
id|hard_header_parse
c_func
(paren
id|skb
comma
id|sll-&gt;sll_addr
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * WAN_PACKET_DATA : Data which should be passed up the receive queue.&n;         * WAN_PACKET_ASYC : Asynchronous data like place call, which should&n;         *                   be passed up the listening sock.&n;         * WAN_PACKET_ERR  : Asynchronous data like clear call or restart &n;         *                   which should go into an error queue.&n;         */
r_switch
c_cond
(paren
id|skb-&gt;pkt_type
)paren
(brace
r_case
id|WAN_PACKET_DATA
suffix:colon
r_if
c_cond
(paren
id|sock_queue_rcv_skb
c_func
(paren
id|sk
comma
id|skb
)paren
OL
l_int|0
)paren
(brace
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|WAN_PACKET_CMD
suffix:colon
id|sk-&gt;state
op_assign
id|chan-&gt;state
suffix:semicolon
multiline_comment|/* Bug fix: update Mar6. &n;                         * Do not set the sock lcn number here, since&n;         &t;&t; * cmd is not guaranteed to be executed on the&n;                         * board, thus Lcn could be wrong */
id|sk
op_member_access_from_pointer
id|data_ready
c_func
(paren
id|sk
comma
id|skb-&gt;len
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|WAN_PACKET_ERR
suffix:colon
id|sk-&gt;state
op_assign
id|chan-&gt;state
suffix:semicolon
r_if
c_cond
(paren
id|sock_queue_err_skb
c_func
(paren
id|sk
comma
id|skb
)paren
OL
l_int|0
)paren
(brace
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;wansock: BH Illegal Packet Type Dropping&bslash;n&quot;
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
singleline_comment|//??????????????????????
singleline_comment|//&t;if (sk-&gt;state == WANSOCK_DISCONNECTED){
singleline_comment|//&t;&t;if (sk-&gt;zapped){
singleline_comment|//&t;&t;&t;//printk(KERN_INFO &quot;wansock: Disconnected, killing early&bslash;n&quot;);
singleline_comment|//&t;&t;&t;wanpipe_unlink_driver(sk);
singleline_comment|//&t;&t;&t;sk-&gt;bound_dev_if = 0;
singleline_comment|//&t;&t;}
singleline_comment|//&t;}
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*============================================================&n; * wanpipe_listen_rcv&n; *&n; *&t;Wanpipe LISTEN socket bottom half handler.  This function&n; *      is called by the WANPIPE device drivers to queue an&n; *      incomming call into the socket listening queue. &n; *      Once the packet is queued, the waiting accept() process &n; *      is woken up.&n; *&n; *      During socket bind, this function is bounded into&n; *      WANPIPE driver private. &n; * &n; *      IMPORTANT NOTE:&n; *          The accept call() is waiting for an skb packet&n; *          which contains a pointer to a device structure.&n; *&n; *          When we do a bind to a device structre, we &n; *          bind a newly created socket into &quot;chan-&gt;sk&quot;.  Thus, &n; *          when accept receives the skb packet, it will know &n; *          from which dev it came form, and in turn it will know&n; *          the address of the new sock.&n; *&n; *  &t;NOTE: This function gets called from driver ISR.&n; *===========================================================*/
DECL|function|wanpipe_listen_rcv
r_static
r_int
id|wanpipe_listen_rcv
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|sock
op_star
id|sk
)paren
(brace
id|wanpipe_opt
op_star
id|wp
op_assign
id|wp_sk
c_func
(paren
id|sk
)paren
comma
op_star
id|newwp
suffix:semicolon
r_struct
id|wan_sockaddr_ll
op_star
id|sll
op_assign
(paren
r_struct
id|wan_sockaddr_ll
op_star
)paren
id|skb-&gt;cb
suffix:semicolon
r_struct
id|sock
op_star
id|newsk
suffix:semicolon
id|netdevice_t
op_star
id|dev
suffix:semicolon
id|sdla_t
op_star
id|card
suffix:semicolon
id|mbox_cmd_t
op_star
id|mbox_ptr
suffix:semicolon
id|wanpipe_common_t
op_star
id|chan
suffix:semicolon
multiline_comment|/* Find a free device, if none found, all svc&squot;s are busy &n;         */
id|card
op_assign
(paren
id|sdla_t
op_star
)paren
id|wp-&gt;card
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|card
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;wansock: LISTEN ERROR, No Card&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|dev
op_assign
id|wanpipe_find_free_dev
c_func
(paren
id|card
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;wansock: LISTEN ERROR, No Free Device&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|chan
op_assign
id|dev-&gt;priv
suffix:semicolon
id|chan-&gt;state
op_assign
id|WANSOCK_CONNECTING
suffix:semicolon
multiline_comment|/* Allocate a new sock, which accept will bind&n;         * and pass up to the user &n;&t; */
r_if
c_cond
(paren
(paren
id|newsk
op_assign
id|wanpipe_make_new
c_func
(paren
id|sk
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|release_device
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
multiline_comment|/* Initialize the new sock structure &n;&t; */
id|newsk-&gt;bound_dev_if
op_assign
id|dev-&gt;ifindex
suffix:semicolon
id|newwp
op_assign
id|wp_sk
c_func
(paren
id|newsk
)paren
suffix:semicolon
id|newwp-&gt;card
op_assign
id|wp-&gt;card
suffix:semicolon
multiline_comment|/* Insert the sock into the main wanpipe&n;         * sock list.&n;         */
id|atomic_inc
c_func
(paren
op_amp
id|wanpipe_socks_nr
)paren
suffix:semicolon
multiline_comment|/* Allocate and fill in the new Mail Box. Then&n;         * bind the mail box to the sock. It will be &n;         * used by the ioctl call to read call information&n;         * and to execute commands. &n;         */
r_if
c_cond
(paren
(paren
id|mbox_ptr
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|mbox_cmd_t
)paren
comma
id|GFP_ATOMIC
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|wanpipe_kill_sock_irq
(paren
id|newsk
)paren
suffix:semicolon
id|release_device
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|memset
c_func
(paren
id|mbox_ptr
comma
l_int|0
comma
r_sizeof
(paren
id|mbox_cmd_t
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|mbox_ptr
comma
id|skb-&gt;data
comma
id|skb-&gt;len
)paren
suffix:semicolon
multiline_comment|/* Register the lcn on which incoming call came&n;         * from. Thus, if we have to clear it, we know&n;         * whic lcn to clear &n;&t; */
id|newwp-&gt;lcn
op_assign
id|mbox_ptr-&gt;cmd.lcn
suffix:semicolon
id|newwp-&gt;mbox
op_assign
(paren
r_void
op_star
)paren
id|mbox_ptr
suffix:semicolon
id|DBG_PRINTK
c_func
(paren
id|KERN_INFO
l_string|&quot;NEWSOCK : Device %s, bind to lcn %i&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|mbox_ptr-&gt;cmd.lcn
)paren
suffix:semicolon
id|chan-&gt;lcn
op_assign
id|mbox_ptr-&gt;cmd.lcn
suffix:semicolon
id|card-&gt;u.x.svc_to_dev_map
(braket
(paren
id|chan-&gt;lcn
op_mod
id|MAX_X25_LCN
)paren
)braket
op_assign
id|dev
suffix:semicolon
id|newsk-&gt;zapped
op_assign
l_int|0
suffix:semicolon
id|newsk-&gt;num
op_assign
id|htons
c_func
(paren
id|X25_PROT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|wanpipe_do_bind
c_func
(paren
id|newsk
comma
id|dev
comma
id|newsk-&gt;num
)paren
)paren
(brace
id|wanpipe_kill_sock_irq
(paren
id|newsk
)paren
suffix:semicolon
id|release_device
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|newsk-&gt;state
op_assign
id|WANSOCK_CONNECTING
suffix:semicolon
multiline_comment|/* Fill in the standard sock address info */
id|sll-&gt;sll_family
op_assign
id|AF_WANPIPE
suffix:semicolon
id|sll-&gt;sll_hatype
op_assign
id|dev-&gt;type
suffix:semicolon
id|sll-&gt;sll_protocol
op_assign
id|skb-&gt;protocol
suffix:semicolon
id|sll-&gt;sll_pkttype
op_assign
id|skb-&gt;pkt_type
suffix:semicolon
id|sll-&gt;sll_ifindex
op_assign
id|dev-&gt;ifindex
suffix:semicolon
id|sll-&gt;sll_halen
op_assign
l_int|0
suffix:semicolon
id|skb-&gt;dev
op_assign
id|dev
suffix:semicolon
id|sk-&gt;ack_backlog
op_increment
suffix:semicolon
multiline_comment|/* We must do this manually, since the sock_queue_rcv_skb()&n;&t; * function sets the skb-&gt;dev to NULL.  However, we use&n;&t; * the dev field in the accept function.*/
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|sk-&gt;rmem_alloc
)paren
op_plus
id|skb-&gt;truesize
op_ge
(paren
r_int
)paren
id|sk-&gt;rcvbuf
)paren
(brace
id|wanpipe_unlink_driver
c_func
(paren
id|newsk
)paren
suffix:semicolon
id|wanpipe_kill_sock_irq
(paren
id|newsk
)paren
suffix:semicolon
op_decrement
id|sk-&gt;ack_backlog
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|skb_set_owner_r
c_func
(paren
id|skb
comma
id|sk
)paren
suffix:semicolon
id|skb_queue_tail
c_func
(paren
op_amp
id|sk-&gt;receive_queue
comma
id|skb
)paren
suffix:semicolon
id|sk
op_member_access_from_pointer
id|data_ready
c_func
(paren
id|sk
comma
id|skb-&gt;len
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*============================================================&n; * wanpipe_make_new&n; *&n; *&t;Create a new sock, and allocate a wanpipe private&n; *      structure to it. Also, copy the important data&n; *      from the original sock to the new sock.&n; *&n; *      This function is used by wanpipe_listen_rcv() listen&n; *      bottom half handler.  A copy of the listening sock&n; *      is created using this function.&n; *&n; *===========================================================*/
DECL|function|wanpipe_make_new
r_static
r_struct
id|sock
op_star
id|wanpipe_make_new
c_func
(paren
r_struct
id|sock
op_star
id|osk
)paren
(brace
r_struct
id|sock
op_star
id|sk
suffix:semicolon
r_if
c_cond
(paren
id|osk-&gt;type
op_ne
id|SOCK_RAW
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
(paren
id|sk
op_assign
id|wanpipe_alloc_socket
c_func
(paren
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
l_int|NULL
suffix:semicolon
id|sk-&gt;type
op_assign
id|osk-&gt;type
suffix:semicolon
id|sk-&gt;socket
op_assign
id|osk-&gt;socket
suffix:semicolon
id|sk-&gt;priority
op_assign
id|osk-&gt;priority
suffix:semicolon
id|sk-&gt;protocol
op_assign
id|osk-&gt;protocol
suffix:semicolon
id|sk-&gt;num
op_assign
id|osk-&gt;num
suffix:semicolon
id|sk-&gt;rcvbuf
op_assign
id|osk-&gt;rcvbuf
suffix:semicolon
id|sk-&gt;sndbuf
op_assign
id|osk-&gt;sndbuf
suffix:semicolon
id|sk-&gt;debug
op_assign
id|osk-&gt;debug
suffix:semicolon
id|sk-&gt;state
op_assign
id|WANSOCK_CONNECTING
suffix:semicolon
id|sk-&gt;sleep
op_assign
id|osk-&gt;sleep
suffix:semicolon
r_return
id|sk
suffix:semicolon
)brace
multiline_comment|/*============================================================&n; * wanpipe_make_new&n; *&n; *&t;Allocate memory for the a new sock, and sock&n; *      private data.  &n; *&t;&n; *&t;Increment the module use count.&n; *       &t;&n; *      This function is used by wanpipe_create() and &n; *      wanpipe_make_new() functions. &n; *&n; *===========================================================*/
DECL|function|wanpipe_alloc_socket
r_static
r_struct
id|sock
op_star
id|wanpipe_alloc_socket
c_func
(paren
r_void
)paren
(brace
r_struct
id|sock
op_star
id|sk
suffix:semicolon
r_struct
id|wanpipe_opt
op_star
id|wan_opt
suffix:semicolon
r_if
c_cond
(paren
(paren
id|sk
op_assign
id|sk_alloc
c_func
(paren
id|PF_WANPIPE
comma
id|GFP_ATOMIC
comma
l_int|1
comma
l_int|NULL
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
(paren
id|wan_opt
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|wanpipe_opt
)paren
comma
id|GFP_ATOMIC
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|sk_free
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|memset
c_func
(paren
id|wan_opt
comma
l_int|0x00
comma
r_sizeof
(paren
r_struct
id|wanpipe_opt
)paren
)paren
suffix:semicolon
id|wp_sk
c_func
(paren
id|sk
)paren
op_assign
id|wan_opt
suffix:semicolon
multiline_comment|/* Use timer to send data to the driver. This will act&n;         * as a BH handler for sendmsg functions */
id|wan_opt-&gt;tx_timer.data
op_assign
(paren
r_int
r_int
)paren
id|sk
suffix:semicolon
id|wan_opt-&gt;tx_timer.function
op_assign
id|wanpipe_delayed_transmit
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
id|sock_init_data
c_func
(paren
l_int|NULL
comma
id|sk
)paren
suffix:semicolon
r_return
id|sk
suffix:semicolon
)brace
multiline_comment|/*============================================================&n; * wanpipe_sendmsg&n; *&n; *&t;This function implements a sendto() system call,&n; *      for AF_WANPIPE socket family. &n; *      During socket bind() sk-&gt;bound_dev_if is initialized&n; *      to a correct network device. This number is used&n; *      to find a network device to which the packet should&n; *      be passed to.&n; *&n; *      Each packet is queued into sk-&gt;write_queue and &n; *      delayed transmit bottom half handler is marked for &n; *      execution.&n; *&n; *      A socket must be in WANSOCK_CONNECTED state before&n; *      a packet is queued into sk-&gt;write_queue.&n; *===========================================================*/
DECL|function|wanpipe_sendmsg
r_static
r_int
id|wanpipe_sendmsg
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_struct
id|msghdr
op_star
id|msg
comma
r_int
id|len
comma
r_struct
id|scm_cookie
op_star
id|scm
)paren
(brace
id|wanpipe_opt
op_star
id|wp
suffix:semicolon
r_struct
id|sock
op_star
id|sk
op_assign
id|sock-&gt;sk
suffix:semicolon
r_struct
id|wan_sockaddr_ll
op_star
id|saddr
op_assign
(paren
r_struct
id|wan_sockaddr_ll
op_star
)paren
id|msg-&gt;msg_name
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
id|netdevice_t
op_star
id|dev
suffix:semicolon
r_int
r_int
id|proto
suffix:semicolon
r_int
r_char
op_star
id|addr
suffix:semicolon
r_int
id|ifindex
comma
id|err
comma
id|reserve
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;zapped
)paren
r_return
op_minus
id|ENETDOWN
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;state
op_ne
id|WANSOCK_CONNECTED
)paren
r_return
op_minus
id|ENOTCONN
suffix:semicolon
r_if
c_cond
(paren
id|msg-&gt;msg_flags
op_amp
op_complement
id|MSG_DONTWAIT
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* it was &lt;=, now one can send&n;         * zero length packets */
r_if
c_cond
(paren
id|len
OL
r_sizeof
(paren
id|x25api_hdr_t
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|saddr
op_eq
l_int|NULL
)paren
(brace
id|ifindex
op_assign
id|sk-&gt;bound_dev_if
suffix:semicolon
id|proto
op_assign
id|sk-&gt;num
suffix:semicolon
id|addr
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|msg-&gt;msg_namelen
OL
r_sizeof
(paren
r_struct
id|wan_sockaddr_ll
)paren
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|ifindex
op_assign
id|sk-&gt;bound_dev_if
suffix:semicolon
id|proto
op_assign
id|saddr-&gt;sll_protocol
suffix:semicolon
id|addr
op_assign
id|saddr-&gt;sll_addr
suffix:semicolon
)brace
id|dev
op_assign
id|dev_get_by_index
c_func
(paren
id|ifindex
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;wansock: Send failed, dev index: %i&bslash;n&quot;
comma
id|ifindex
)paren
suffix:semicolon
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
id|dev_put
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sock-&gt;type
op_eq
id|SOCK_RAW
)paren
id|reserve
op_assign
id|dev-&gt;hard_header_len
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|dev-&gt;mtu
op_plus
id|reserve
)paren
(brace
r_return
op_minus
id|EMSGSIZE
suffix:semicolon
)brace
macro_line|#ifndef LINUX_2_4
id|dev_lock_list
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,4,3)
id|skb
op_assign
id|sock_alloc_send_skb
c_func
(paren
id|sk
comma
id|len
op_plus
id|dev-&gt;hard_header_len
op_plus
l_int|15
comma
id|msg-&gt;msg_flags
op_amp
id|MSG_DONTWAIT
comma
op_amp
id|err
)paren
suffix:semicolon
macro_line|#else
id|skb
op_assign
id|sock_alloc_send_skb
c_func
(paren
id|sk
comma
id|len
op_plus
id|dev-&gt;hard_header_len
op_plus
l_int|15
comma
l_int|0
comma
id|msg-&gt;msg_flags
op_amp
id|MSG_DONTWAIT
comma
op_amp
id|err
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
(brace
r_goto
id|out_unlock
suffix:semicolon
)brace
id|skb_reserve
c_func
(paren
id|skb
comma
(paren
id|dev-&gt;hard_header_len
op_plus
l_int|15
)paren
op_amp
op_complement
l_int|15
)paren
suffix:semicolon
id|skb-&gt;nh.raw
op_assign
id|skb-&gt;data
suffix:semicolon
multiline_comment|/* Returns -EFAULT on error */
id|err
op_assign
id|memcpy_fromiovec
c_func
(paren
id|skb_put
c_func
(paren
id|skb
comma
id|len
)paren
comma
id|msg-&gt;msg_iov
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
r_goto
id|out_free
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dev-&gt;hard_header
)paren
(brace
r_int
id|res
suffix:semicolon
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
id|res
op_assign
id|dev
op_member_access_from_pointer
id|hard_header
c_func
(paren
id|skb
comma
id|dev
comma
id|ntohs
c_func
(paren
id|proto
)paren
comma
id|addr
comma
l_int|NULL
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res
OL
l_int|0
)paren
(brace
r_goto
id|out_free
suffix:semicolon
)brace
)brace
id|skb-&gt;protocol
op_assign
id|proto
suffix:semicolon
id|skb-&gt;dev
op_assign
id|dev
suffix:semicolon
id|skb-&gt;priority
op_assign
id|sk-&gt;priority
suffix:semicolon
id|skb-&gt;pkt_type
op_assign
id|WAN_PACKET_DATA
suffix:semicolon
id|err
op_assign
op_minus
id|ENETDOWN
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|dev-&gt;flags
op_amp
id|IFF_UP
)paren
)paren
r_goto
id|out_free
suffix:semicolon
macro_line|#ifndef LINUX_2_4
id|dev_unlock_list
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|sk-&gt;wmem_alloc
)paren
op_plus
id|skb-&gt;truesize
OG
(paren
r_int
r_int
)paren
id|sk-&gt;sndbuf
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
op_minus
id|ENOBUFS
suffix:semicolon
)brace
id|skb_queue_tail
c_func
(paren
op_amp
id|sk-&gt;write_queue
comma
id|skb
)paren
suffix:semicolon
id|wp
op_assign
id|wp_sk
c_func
(paren
id|sk
)paren
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|wp-&gt;packet_sent
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|test_and_set_bit
c_func
(paren
l_int|0
comma
op_amp
id|wp-&gt;timer
)paren
)paren
)paren
(brace
id|del_timer
c_func
(paren
op_amp
id|wp-&gt;tx_timer
)paren
suffix:semicolon
id|wp-&gt;tx_timer.expires
op_assign
id|jiffies
op_plus
l_int|1
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|wp-&gt;tx_timer
)paren
suffix:semicolon
)brace
r_return
id|len
suffix:semicolon
id|out_free
suffix:colon
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
id|out_unlock
suffix:colon
macro_line|#ifndef LINUX_2_4
id|dev_unlock_list
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*============================================================&n; * wanpipe_delayed_tarnsmit&n; *&n; *&t;Transmit bottom half handeler. It dequeues packets&n; *      from sk-&gt;write_queue and passes them to the &n; *      driver.  If the driver is busy, the packet is &n; *      re-enqueued.  &n; *&n; *      Packet Sent counter is decremented on successful&n; *      transmission. &n; *===========================================================*/
DECL|function|wanpipe_delayed_transmit
r_static
r_void
id|wanpipe_delayed_transmit
(paren
r_int
r_int
id|data
)paren
(brace
r_struct
id|sock
op_star
id|sk
op_assign
(paren
r_struct
id|sock
op_star
)paren
id|data
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
id|wanpipe_opt
op_star
id|wp
op_assign
id|wp_sk
c_func
(paren
id|sk
)paren
suffix:semicolon
id|netdevice_t
op_star
id|dev
op_assign
id|wp-&gt;dev
suffix:semicolon
id|sdla_t
op_star
id|card
op_assign
(paren
id|sdla_t
op_star
)paren
id|wp-&gt;card
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|card
op_logical_or
op_logical_neg
id|dev
)paren
(brace
id|clear_bit
c_func
(paren
l_int|0
comma
op_amp
id|wp-&gt;timer
)paren
suffix:semicolon
id|DBG_PRINTK
c_func
(paren
id|KERN_INFO
l_string|&quot;wansock: Transmit delay, no dev or card&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sk-&gt;state
op_ne
id|WANSOCK_CONNECTED
op_logical_or
op_logical_neg
id|sk-&gt;zapped
)paren
(brace
id|clear_bit
c_func
(paren
l_int|0
comma
op_amp
id|wp-&gt;timer
)paren
suffix:semicolon
id|DBG_PRINTK
c_func
(paren
id|KERN_INFO
l_string|&quot;wansock: Tx Timer, State not CONNECTED&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* If driver is executing command, we must offload&n;         * the board by not sending data. Otherwise a &n;         * pending command will never get a free buffer&n;         * to execute */
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|card-&gt;u.x.command_busy
)paren
)paren
(brace
id|wp-&gt;tx_timer.expires
op_assign
id|jiffies
op_plus
id|SLOW_BACKOFF
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|wp-&gt;tx_timer
)paren
suffix:semicolon
id|DBG_PRINTK
c_func
(paren
id|KERN_INFO
l_string|&quot;wansock: Tx Timer, command bys BACKOFF&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|test_and_set_bit
c_func
(paren
l_int|0
comma
op_amp
id|wanpipe_tx_critical
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;WanSock: Tx timer critical %s&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|wp-&gt;tx_timer.expires
op_assign
id|jiffies
op_plus
id|SLOW_BACKOFF
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|wp-&gt;tx_timer
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Check for a packet in the fifo and send */
r_if
c_cond
(paren
(paren
id|skb
op_assign
id|skb_dequeue
c_func
(paren
op_amp
id|sk-&gt;write_queue
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|dev
op_member_access_from_pointer
id|hard_start_xmit
c_func
(paren
id|skb
comma
id|dev
)paren
op_ne
l_int|0
)paren
(brace
multiline_comment|/* Driver failed to transmit, re-enqueue&n;                         * the packet and retry again later */
id|skb_queue_head
c_func
(paren
op_amp
id|sk-&gt;write_queue
comma
id|skb
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
l_int|0
comma
op_amp
id|wanpipe_tx_critical
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Packet Sent successful. Check for more packets&n;                         * if more packets, re-trigger the transmit routine &n;                         * other wise exit&n;                         */
id|atomic_dec
c_func
(paren
op_amp
id|wp-&gt;packet_sent
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb_peek
c_func
(paren
op_amp
id|sk-&gt;write_queue
)paren
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* If there is nothing to send, kick&n;&t;&t;&t;&t; * the poll routine, which will trigger&n;&t;&t;&t;&t; * the application to send more data */
id|sk
op_member_access_from_pointer
id|data_ready
c_func
(paren
id|sk
comma
l_int|0
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
l_int|0
comma
op_amp
id|wp-&gt;timer
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Reschedule as fast as possible */
id|wp-&gt;tx_timer.expires
op_assign
id|jiffies
op_plus
l_int|1
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|wp-&gt;tx_timer
)paren
suffix:semicolon
)brace
)brace
)brace
id|clear_bit
c_func
(paren
l_int|0
comma
op_amp
id|wanpipe_tx_critical
)paren
suffix:semicolon
)brace
multiline_comment|/*============================================================&n; * execute_command &n; *&n; *&t;Execute x25api commands.  The atomic variable&n; *      chan-&gt;command is used to indicate to the driver that&n; *      command is pending for exection.  The acutal command&n; *      structure is placed into a sock mbox structure &n; *      (wp_sk(sk)-&gt;mbox).&n; *&n; *      The sock private structure, mbox is&n; *      used as shared memory between sock and the driver.&n; *      Driver uses the sock mbox to execute the command&n; *      and return the result.  &n; *&n; *      For all command except PLACE CALL, the function&n; *      waits for the result.  PLACE CALL can be ether&n; *      blocking or nonblocking. The user sets this option&n; *      via ioctl call.&n; *===========================================================*/
DECL|function|execute_command
r_static
r_int
id|execute_command
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
r_char
id|cmd
comma
r_int
r_int
id|flags
)paren
(brace
id|wanpipe_opt
op_star
id|wp
op_assign
id|wp_sk
c_func
(paren
id|sk
)paren
suffix:semicolon
id|netdevice_t
op_star
id|dev
suffix:semicolon
id|wanpipe_common_t
op_star
id|chan
op_assign
l_int|NULL
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
id|dev
op_assign
id|dev_get_by_index
c_func
(paren
id|sk-&gt;bound_dev_if
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;wansock: Exec failed no dev %i&bslash;n&quot;
comma
id|sk-&gt;bound_dev_if
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|dev_put
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|chan
op_assign
id|dev-&gt;priv
)paren
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;wansock: Exec cmd failed no priv area&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|chan-&gt;command
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;wansock: ERROR: Command already running %x, %s&bslash;n&quot;
comma
id|atomic_read
c_func
(paren
op_amp
id|chan-&gt;command
)paren
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|wp-&gt;mbox
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;wansock: In execute without MBOX&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
(paren
(paren
id|mbox_cmd_t
op_star
)paren
id|wp-&gt;mbox
)paren
op_member_access_from_pointer
id|cmd.command
op_assign
id|cmd
suffix:semicolon
(paren
(paren
id|mbox_cmd_t
op_star
)paren
id|wp-&gt;mbox
)paren
op_member_access_from_pointer
id|cmd.lcn
op_assign
id|wp-&gt;lcn
suffix:semicolon
(paren
(paren
id|mbox_cmd_t
op_star
)paren
id|wp-&gt;mbox
)paren
op_member_access_from_pointer
id|cmd.result
op_assign
l_int|0x7F
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|O_NONBLOCK
)paren
(brace
id|cmd
op_or_assign
l_int|0x80
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|chan-&gt;command
comma
id|cmd
)paren
suffix:semicolon
)brace
r_else
(brace
id|atomic_set
c_func
(paren
op_amp
id|chan-&gt;command
comma
id|cmd
)paren
suffix:semicolon
)brace
id|add_wait_queue
c_func
(paren
id|sk-&gt;sleep
comma
op_amp
id|wait
)paren
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
id|mbox_cmd_t
op_star
)paren
id|wp-&gt;mbox
)paren
op_member_access_from_pointer
id|cmd.result
op_ne
l_int|0x7F
)paren
(brace
id|err
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
id|err
op_assign
op_minus
id|ERESTARTSYS
suffix:semicolon
r_break
suffix:semicolon
)brace
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
id|remove_wait_queue
c_func
(paren
id|sk-&gt;sleep
comma
op_amp
id|wait
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*============================================================&n; * wanpipe_destroy_timer &n; *&n; *&t;Used by wanpipe_release, to delay release of&n; *      the socket.&n; *===========================================================*/
DECL|function|wanpipe_destroy_timer
r_static
r_void
id|wanpipe_destroy_timer
c_func
(paren
r_int
r_int
id|data
)paren
(brace
r_struct
id|sock
op_star
id|sk
op_assign
(paren
r_struct
id|sock
op_star
)paren
id|data
suffix:semicolon
id|wanpipe_opt
op_star
id|wp
op_assign
id|wp_sk
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
op_logical_neg
id|atomic_read
c_func
(paren
op_amp
id|sk-&gt;wmem_alloc
)paren
op_logical_and
op_logical_neg
id|atomic_read
c_func
(paren
op_amp
id|sk-&gt;rmem_alloc
)paren
)paren
op_logical_or
(paren
op_increment
id|wp-&gt;force
op_eq
l_int|5
)paren
)paren
(brace
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|sk-&gt;wmem_alloc
)paren
op_logical_or
id|atomic_read
c_func
(paren
op_amp
id|sk-&gt;rmem_alloc
)paren
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;wansock: Warning, Packet Discarded due to sock shutdown!&bslash;n&quot;
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|wp
)paren
suffix:semicolon
id|wp_sk
c_func
(paren
id|sk
)paren
op_assign
l_int|NULL
suffix:semicolon
macro_line|#ifdef LINUX_2_4
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|sk-&gt;refcnt
)paren
op_ne
l_int|1
)paren
(brace
id|atomic_set
c_func
(paren
op_amp
id|sk-&gt;refcnt
comma
l_int|1
)paren
suffix:semicolon
id|DBG_PRINTK
c_func
(paren
id|KERN_INFO
l_string|&quot;wansock: Error, wrong reference count: %i ! :delay.&bslash;n&quot;
comma
id|atomic_read
c_func
(paren
op_amp
id|sk-&gt;refcnt
)paren
)paren
suffix:semicolon
)brace
id|sock_put
c_func
(paren
id|sk
)paren
suffix:semicolon
macro_line|#else
id|sk_free
c_func
(paren
id|sk
)paren
suffix:semicolon
macro_line|#endif
id|atomic_dec
c_func
(paren
op_amp
id|wanpipe_socks_nr
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
suffix:semicolon
)brace
id|sk-&gt;timer.expires
op_assign
id|jiffies
op_plus
l_int|5
op_star
id|HZ
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|sk-&gt;timer
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;wansock: packet sk destroy delayed&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*============================================================&n; * wanpipe_unlink_driver&n; *&n; * &t;When the socket is released, this function is &n; *      used to remove links that bind the sock and the&n; *      driver together.  &n; *===========================================================*/
DECL|function|wanpipe_unlink_driver
r_static
r_void
id|wanpipe_unlink_driver
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
id|netdevice_t
op_star
id|dev
suffix:semicolon
id|wanpipe_common_t
op_star
id|chan
op_assign
l_int|NULL
suffix:semicolon
id|sk-&gt;zapped
op_assign
l_int|0
suffix:semicolon
id|sk-&gt;state
op_assign
id|WANSOCK_DISCONNECTED
suffix:semicolon
id|wp_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|dev
op_assign
l_int|NULL
suffix:semicolon
id|dev
op_assign
id|dev_get_by_index
c_func
(paren
id|sk-&gt;bound_dev_if
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;wansock: No dev on release&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|dev_put
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|chan
op_assign
id|dev-&gt;priv
)paren
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;wansock: No Priv Area on release&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|set_bit
c_func
(paren
l_int|0
comma
op_amp
id|chan-&gt;common_critical
)paren
suffix:semicolon
id|chan-&gt;sk
op_assign
l_int|NULL
suffix:semicolon
id|chan-&gt;func
op_assign
l_int|NULL
suffix:semicolon
id|chan-&gt;mbox
op_assign
l_int|NULL
suffix:semicolon
id|chan-&gt;tx_timer
op_assign
l_int|NULL
suffix:semicolon
id|clear_bit
c_func
(paren
l_int|0
comma
op_amp
id|chan-&gt;common_critical
)paren
suffix:semicolon
id|release_device
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*============================================================&n; * wanpipe_link_driver&n; *&n; * &t;Upon successful bind(), sock is linked to a driver&n; *      by binding in the wanpipe_rcv() bottom half handler&n; *      to the driver function pointer, as well as sock and&n; *      sock mailbox addresses.  This way driver can pass&n; *      data up the socket.&n; *===========================================================*/
DECL|function|wanpipe_link_driver
r_static
r_void
id|wanpipe_link_driver
(paren
id|netdevice_t
op_star
id|dev
comma
r_struct
id|sock
op_star
id|sk
)paren
(brace
id|wanpipe_opt
op_star
id|wp
op_assign
id|wp_sk
c_func
(paren
id|sk
)paren
suffix:semicolon
id|wanpipe_common_t
op_star
id|chan
op_assign
id|dev-&gt;priv
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|chan
)paren
r_return
suffix:semicolon
id|set_bit
c_func
(paren
l_int|0
comma
op_amp
id|chan-&gt;common_critical
)paren
suffix:semicolon
id|chan-&gt;sk
op_assign
id|sk
suffix:semicolon
id|chan-&gt;func
op_assign
id|wanpipe_rcv
suffix:semicolon
id|chan-&gt;mbox
op_assign
id|wp-&gt;mbox
suffix:semicolon
id|chan-&gt;tx_timer
op_assign
op_amp
id|wp-&gt;tx_timer
suffix:semicolon
id|wp-&gt;dev
op_assign
id|dev
suffix:semicolon
id|sk-&gt;zapped
op_assign
l_int|1
suffix:semicolon
id|clear_bit
c_func
(paren
l_int|0
comma
op_amp
id|chan-&gt;common_critical
)paren
suffix:semicolon
)brace
multiline_comment|/*============================================================&n; * release_device&n; *&n; *   &t;During sock release, clear a critical bit, which &n; *      marks the device a being taken.&n; *===========================================================*/
DECL|function|release_device
r_static
r_void
id|release_device
(paren
id|netdevice_t
op_star
id|dev
)paren
(brace
id|wanpipe_common_t
op_star
id|chan
op_assign
id|dev-&gt;priv
suffix:semicolon
id|clear_bit
c_func
(paren
l_int|0
comma
(paren
r_void
op_star
)paren
op_amp
id|chan-&gt;rw_bind
)paren
suffix:semicolon
)brace
multiline_comment|/*============================================================&n; * wanpipe_release&n; *&n; *&t;Close a PACKET socket. This is fairly simple. We &n; *      immediately go to &squot;closed&squot; state and remove our &n; *      protocol entry in the device list.&n; *===========================================================*/
macro_line|#ifdef LINUX_2_4
DECL|function|wanpipe_release
r_static
r_int
id|wanpipe_release
c_func
(paren
r_struct
id|socket
op_star
id|sock
)paren
macro_line|#else
r_static
r_int
id|wanpipe_release
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_struct
id|socket
op_star
id|peersock
)paren
macro_line|#endif
(brace
macro_line|#ifndef LINUX_2_4
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
macro_line|#endif
id|wanpipe_opt
op_star
id|wp
suffix:semicolon
r_struct
id|sock
op_star
id|sk
op_assign
id|sock-&gt;sk
suffix:semicolon
r_struct
id|sock
op_star
op_star
id|skp
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sk
)paren
r_return
l_int|0
suffix:semicolon
id|wp
op_assign
id|wp_sk
c_func
(paren
id|sk
)paren
suffix:semicolon
id|check_write_queue
c_func
(paren
id|sk
)paren
suffix:semicolon
multiline_comment|/* Kill the tx timer, if we don&squot;t kill it now, the timer&n;         * will run after we kill the sock.  Timer code will &n;         * try to access the sock which has been killed and cause&n;         * kernel panic */
id|del_timer
c_func
(paren
op_amp
id|wp-&gt;tx_timer
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Unhook packet receive handler.&n;&t; */
r_if
c_cond
(paren
id|sk-&gt;num
op_eq
id|htons
c_func
(paren
id|X25_PROT
)paren
op_logical_and
id|sk-&gt;state
op_ne
id|WANSOCK_DISCONNECTED
op_logical_and
id|sk-&gt;zapped
)paren
(brace
id|netdevice_t
op_star
id|dev
op_assign
id|dev_get_by_index
c_func
(paren
id|sk-&gt;bound_dev_if
)paren
suffix:semicolon
id|wanpipe_common_t
op_star
id|chan
suffix:semicolon
r_if
c_cond
(paren
id|dev
)paren
(brace
id|chan
op_assign
id|dev-&gt;priv
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|chan-&gt;disconnect
comma
l_int|1
)paren
suffix:semicolon
id|DBG_PRINTK
c_func
(paren
id|KERN_INFO
l_string|&quot;wansock: Sending Clear Indication %i&bslash;n&quot;
comma
id|sk-&gt;state
)paren
suffix:semicolon
id|dev_put
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
)brace
id|set_bit
c_func
(paren
l_int|1
comma
op_amp
id|wanpipe_tx_critical
)paren
suffix:semicolon
id|write_lock
c_func
(paren
op_amp
id|wanpipe_sklist_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|skp
op_assign
op_amp
id|wanpipe_sklist
suffix:semicolon
op_star
id|skp
suffix:semicolon
id|skp
op_assign
op_amp
(paren
op_star
id|skp
)paren
op_member_access_from_pointer
id|next
)paren
(brace
r_if
c_cond
(paren
op_star
id|skp
op_eq
id|sk
)paren
(brace
op_star
id|skp
op_assign
id|sk-&gt;next
suffix:semicolon
id|__sock_put
c_func
(paren
id|sk
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|write_unlock
c_func
(paren
op_amp
id|wanpipe_sklist_lock
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
l_int|1
comma
op_amp
id|wanpipe_tx_critical
)paren
suffix:semicolon
id|release_driver
c_func
(paren
id|sk
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Now the socket is dead. No more input will appear.&n;&t; */
id|sk
op_member_access_from_pointer
id|state_change
c_func
(paren
id|sk
)paren
suffix:semicolon
multiline_comment|/* It is useless. Just for sanity. */
id|sock-&gt;sk
op_assign
l_int|NULL
suffix:semicolon
id|sk-&gt;socket
op_assign
l_int|NULL
suffix:semicolon
id|sk-&gt;dead
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Purge queues */
macro_line|#ifdef LINUX_2_4
id|skb_queue_purge
c_func
(paren
op_amp
id|sk-&gt;receive_queue
)paren
suffix:semicolon
id|skb_queue_purge
c_func
(paren
op_amp
id|sk-&gt;write_queue
)paren
suffix:semicolon
id|skb_queue_purge
c_func
(paren
op_amp
id|sk-&gt;error_queue
)paren
suffix:semicolon
macro_line|#else&t;
r_while
c_loop
(paren
(paren
id|skb
op_assign
id|skb_dequeue
c_func
(paren
op_amp
id|sk-&gt;receive_queue
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|skb
op_assign
id|skb_dequeue
c_func
(paren
op_amp
id|sk-&gt;error_queue
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|skb
op_assign
id|skb_dequeue
c_func
(paren
op_amp
id|sk-&gt;write_queue
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
macro_line|#endif&t;
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|sk-&gt;rmem_alloc
)paren
op_logical_or
id|atomic_read
c_func
(paren
op_amp
id|sk-&gt;wmem_alloc
)paren
)paren
(brace
id|del_timer
c_func
(paren
op_amp
id|sk-&gt;timer
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;wansock: Killing in Timer R %i , W %i&bslash;n&quot;
comma
id|atomic_read
c_func
(paren
op_amp
id|sk-&gt;rmem_alloc
)paren
comma
id|atomic_read
c_func
(paren
op_amp
id|sk-&gt;wmem_alloc
)paren
)paren
suffix:semicolon
id|sk-&gt;timer.data
op_assign
(paren
r_int
r_int
)paren
id|sk
suffix:semicolon
id|sk-&gt;timer.expires
op_assign
id|jiffies
op_plus
id|HZ
suffix:semicolon
id|sk-&gt;timer.function
op_assign
id|wanpipe_destroy_timer
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|sk-&gt;timer
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|wp
)paren
suffix:semicolon
id|wp_sk
c_func
(paren
id|sk
)paren
op_assign
l_int|NULL
suffix:semicolon
macro_line|#ifdef LINUX_2_4
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|sk-&gt;refcnt
)paren
op_ne
l_int|1
)paren
(brace
id|DBG_PRINTK
c_func
(paren
id|KERN_INFO
l_string|&quot;wansock: Error, wrong reference count: %i !:release.&bslash;n&quot;
comma
id|atomic_read
c_func
(paren
op_amp
id|sk-&gt;refcnt
)paren
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|sk-&gt;refcnt
comma
l_int|1
)paren
suffix:semicolon
)brace
id|sock_put
c_func
(paren
id|sk
)paren
suffix:semicolon
macro_line|#else&t;
id|sk_free
c_func
(paren
id|sk
)paren
suffix:semicolon
macro_line|#endif
id|atomic_dec
c_func
(paren
op_amp
id|wanpipe_socks_nr
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*============================================================&n; * check_write_queue&n; *&n; *  &t;During sock shutdown, if the sock state is &n; *      WANSOCK_CONNECTED and there is transmit data &n; *      pending. Wait until data is released &n; *      before proceeding.&n; *===========================================================*/
DECL|function|check_write_queue
r_static
r_void
id|check_write_queue
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_if
c_cond
(paren
id|sk-&gt;state
op_ne
id|WANSOCK_CONNECTED
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|atomic_read
c_func
(paren
op_amp
id|sk-&gt;wmem_alloc
)paren
)paren
r_return
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;wansock: MAJOR ERROR, Data lost on sock release !!!&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*============================================================&n; * release_driver&n; *&n; *&t;This function is called during sock shutdown, to &n; *      release any resources and links that bind the sock&n; *      to the driver.  It also changes the state of the&n; *      sock to WANSOCK_DISCONNECTED&n; *===========================================================*/
DECL|function|release_driver
r_static
r_void
id|release_driver
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
id|wanpipe_opt
op_star
id|wp
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|sock
op_star
id|deadsk
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|WANSOCK_LISTEN
op_logical_or
id|sk-&gt;state
op_eq
id|WANSOCK_BIND_LISTEN
)paren
(brace
r_while
c_loop
(paren
(paren
id|skb
op_assign
id|skb_dequeue
c_func
(paren
op_amp
id|sk-&gt;receive_queue
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
(paren
id|deadsk
op_assign
id|get_newsk_from_skb
c_func
(paren
id|skb
)paren
)paren
)paren
(brace
id|DBG_PRINTK
(paren
id|KERN_INFO
l_string|&quot;wansock: RELEASE: FOUND DEAD SOCK&bslash;n&quot;
)paren
suffix:semicolon
id|deadsk-&gt;dead
op_assign
l_int|1
suffix:semicolon
id|start_cleanup_timer
c_func
(paren
id|deadsk
)paren
suffix:semicolon
)brace
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sk-&gt;zapped
)paren
id|wanpipe_unlink_card
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|sk-&gt;zapped
)paren
id|wanpipe_unlink_driver
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
id|sk-&gt;state
op_assign
id|WANSOCK_DISCONNECTED
suffix:semicolon
id|sk-&gt;bound_dev_if
op_assign
l_int|0
suffix:semicolon
id|sk-&gt;zapped
op_assign
l_int|0
suffix:semicolon
id|wp
op_assign
id|wp_sk
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|wp
op_logical_and
id|wp-&gt;mbox
)paren
(brace
id|kfree
c_func
(paren
id|wp-&gt;mbox
)paren
suffix:semicolon
id|wp-&gt;mbox
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
multiline_comment|/*============================================================&n; *  start_cleanup_timer&n; *&n; *  &t;If new incoming call&squot;s are pending but the socket&n; *      is being released, start the timer which will &n; *      envoke the kill routines for pending socks.&n; *===========================================================*/
DECL|function|start_cleanup_timer
r_static
r_void
id|start_cleanup_timer
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
id|del_timer
c_func
(paren
op_amp
id|sk-&gt;timer
)paren
suffix:semicolon
id|sk-&gt;timer.data
op_assign
(paren
r_int
r_int
)paren
id|sk
suffix:semicolon
id|sk-&gt;timer.expires
op_assign
id|jiffies
op_plus
id|HZ
suffix:semicolon
id|sk-&gt;timer.function
op_assign
id|wanpipe_kill_sock_timer
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|sk-&gt;timer
)paren
suffix:semicolon
)brace
multiline_comment|/*============================================================&n; *  wanpipe_kill_sock&n; *&n; *&t;This is a function which performs actual killing&n; *      of the sock.  It releases socket resources,&n; *      and unlinks the sock from the driver. &n; *===========================================================*/
DECL|function|wanpipe_kill_sock_timer
r_static
r_void
id|wanpipe_kill_sock_timer
(paren
r_int
r_int
id|data
)paren
(brace
r_struct
id|sock
op_star
id|sk
op_assign
(paren
r_struct
id|sock
op_star
)paren
id|data
suffix:semicolon
macro_line|#ifndef LINUX_2_4
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
macro_line|#endif
r_struct
id|sock
op_star
op_star
id|skp
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sk
)paren
r_return
suffix:semicolon
multiline_comment|/* This functin can be called from interrupt. We must use&n;&t; * appropriate locks */
r_if
c_cond
(paren
id|test_bit
c_func
(paren
l_int|1
comma
op_amp
id|wanpipe_tx_critical
)paren
)paren
(brace
id|sk-&gt;timer.expires
op_assign
id|jiffies
op_plus
l_int|10
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|sk-&gt;timer
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|write_lock
c_func
(paren
op_amp
id|wanpipe_sklist_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|skp
op_assign
op_amp
id|wanpipe_sklist
suffix:semicolon
op_star
id|skp
suffix:semicolon
id|skp
op_assign
op_amp
(paren
op_star
id|skp
)paren
op_member_access_from_pointer
id|next
)paren
(brace
r_if
c_cond
(paren
op_star
id|skp
op_eq
id|sk
)paren
(brace
op_star
id|skp
op_assign
id|sk-&gt;next
suffix:semicolon
id|__sock_put
c_func
(paren
id|sk
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|write_unlock
c_func
(paren
op_amp
id|wanpipe_sklist_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;num
op_eq
id|htons
c_func
(paren
id|X25_PROT
)paren
op_logical_and
id|sk-&gt;state
op_ne
id|WANSOCK_DISCONNECTED
)paren
(brace
id|netdevice_t
op_star
id|dev
op_assign
id|dev_get_by_index
c_func
(paren
id|sk-&gt;bound_dev_if
)paren
suffix:semicolon
id|wanpipe_common_t
op_star
id|chan
suffix:semicolon
r_if
c_cond
(paren
id|dev
)paren
(brace
id|chan
op_assign
id|dev-&gt;priv
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|chan-&gt;disconnect
comma
l_int|1
)paren
suffix:semicolon
id|dev_put
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
)brace
id|release_driver
c_func
(paren
id|sk
)paren
suffix:semicolon
id|sk-&gt;socket
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Purge queues */
macro_line|#ifdef LINUX_2_4
id|skb_queue_purge
c_func
(paren
op_amp
id|sk-&gt;receive_queue
)paren
suffix:semicolon
id|skb_queue_purge
c_func
(paren
op_amp
id|sk-&gt;write_queue
)paren
suffix:semicolon
id|skb_queue_purge
c_func
(paren
op_amp
id|sk-&gt;error_queue
)paren
suffix:semicolon
macro_line|#else&t;
r_while
c_loop
(paren
(paren
id|skb
op_assign
id|skb_dequeue
c_func
(paren
op_amp
id|sk-&gt;receive_queue
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|skb
op_assign
id|skb_dequeue
c_func
(paren
op_amp
id|sk-&gt;write_queue
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|skb
op_assign
id|skb_dequeue
c_func
(paren
op_amp
id|sk-&gt;error_queue
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|sk-&gt;rmem_alloc
)paren
op_logical_or
id|atomic_read
c_func
(paren
op_amp
id|sk-&gt;wmem_alloc
)paren
)paren
(brace
id|del_timer
c_func
(paren
op_amp
id|sk-&gt;timer
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;wansock: Killing SOCK in Timer&bslash;n&quot;
)paren
suffix:semicolon
id|sk-&gt;timer.data
op_assign
(paren
r_int
r_int
)paren
id|sk
suffix:semicolon
id|sk-&gt;timer.expires
op_assign
id|jiffies
op_plus
id|HZ
suffix:semicolon
id|sk-&gt;timer.function
op_assign
id|wanpipe_destroy_timer
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|sk-&gt;timer
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|wp_sk
c_func
(paren
id|sk
)paren
)paren
(brace
id|kfree
c_func
(paren
id|wp_sk
c_func
(paren
id|sk
)paren
)paren
suffix:semicolon
id|wp_sk
c_func
(paren
id|sk
)paren
op_assign
l_int|NULL
suffix:semicolon
)brace
macro_line|#ifdef LINUX_2_4
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|sk-&gt;refcnt
)paren
op_ne
l_int|1
)paren
(brace
id|atomic_set
c_func
(paren
op_amp
id|sk-&gt;refcnt
comma
l_int|1
)paren
suffix:semicolon
id|DBG_PRINTK
c_func
(paren
id|KERN_INFO
l_string|&quot;wansock: Error, wrong reference count: %i ! :timer.&bslash;n&quot;
comma
id|atomic_read
c_func
(paren
op_amp
id|sk-&gt;refcnt
)paren
)paren
suffix:semicolon
)brace
id|sock_put
c_func
(paren
id|sk
)paren
suffix:semicolon
macro_line|#else
id|sk_free
c_func
(paren
id|sk
)paren
suffix:semicolon
macro_line|#endif
id|atomic_dec
c_func
(paren
op_amp
id|wanpipe_socks_nr
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|function|wanpipe_kill_sock_accept
r_static
r_void
id|wanpipe_kill_sock_accept
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|sock
op_star
op_star
id|skp
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sk
)paren
r_return
suffix:semicolon
multiline_comment|/* This functin can be called from interrupt. We must use&n;&t; * appropriate locks */
id|write_lock
c_func
(paren
op_amp
id|wanpipe_sklist_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|skp
op_assign
op_amp
id|wanpipe_sklist
suffix:semicolon
op_star
id|skp
suffix:semicolon
id|skp
op_assign
op_amp
(paren
op_star
id|skp
)paren
op_member_access_from_pointer
id|next
)paren
(brace
r_if
c_cond
(paren
op_star
id|skp
op_eq
id|sk
)paren
(brace
op_star
id|skp
op_assign
id|sk-&gt;next
suffix:semicolon
id|__sock_put
c_func
(paren
id|sk
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|write_unlock
c_func
(paren
op_amp
id|wanpipe_sklist_lock
)paren
suffix:semicolon
id|sk-&gt;socket
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|wp_sk
c_func
(paren
id|sk
)paren
)paren
(brace
id|kfree
c_func
(paren
id|wp_sk
c_func
(paren
id|sk
)paren
)paren
suffix:semicolon
id|wp_sk
c_func
(paren
id|sk
)paren
op_assign
l_int|NULL
suffix:semicolon
)brace
macro_line|#ifdef LINUX_2_4
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|sk-&gt;refcnt
)paren
op_ne
l_int|1
)paren
(brace
id|atomic_set
c_func
(paren
op_amp
id|sk-&gt;refcnt
comma
l_int|1
)paren
suffix:semicolon
id|DBG_PRINTK
c_func
(paren
id|KERN_INFO
l_string|&quot;wansock: Error, wrong reference count: %i ! :timer.&bslash;n&quot;
comma
id|atomic_read
c_func
(paren
op_amp
id|sk-&gt;refcnt
)paren
)paren
suffix:semicolon
)brace
id|sock_put
c_func
(paren
id|sk
)paren
suffix:semicolon
macro_line|#else
id|sk_free
c_func
(paren
id|sk
)paren
suffix:semicolon
macro_line|#endif
id|atomic_dec
c_func
(paren
op_amp
id|wanpipe_socks_nr
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|function|wanpipe_kill_sock_irq
r_static
r_void
id|wanpipe_kill_sock_irq
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|sk
)paren
r_return
suffix:semicolon
id|sk-&gt;socket
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|wp_sk
c_func
(paren
id|sk
)paren
)paren
(brace
id|kfree
c_func
(paren
id|wp_sk
c_func
(paren
id|sk
)paren
)paren
suffix:semicolon
id|wp_sk
c_func
(paren
id|sk
)paren
op_assign
l_int|NULL
suffix:semicolon
)brace
macro_line|#ifdef LINUX_2_4
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|sk-&gt;refcnt
)paren
op_ne
l_int|1
)paren
(brace
id|atomic_set
c_func
(paren
op_amp
id|sk-&gt;refcnt
comma
l_int|1
)paren
suffix:semicolon
id|DBG_PRINTK
c_func
(paren
id|KERN_INFO
l_string|&quot;wansock: Error, wrong reference count: %i !:listen.&bslash;n&quot;
comma
id|atomic_read
c_func
(paren
op_amp
id|sk-&gt;refcnt
)paren
)paren
suffix:semicolon
)brace
id|sock_put
c_func
(paren
id|sk
)paren
suffix:semicolon
macro_line|#else
id|sk_free
c_func
(paren
id|sk
)paren
suffix:semicolon
macro_line|#endif
id|atomic_dec
c_func
(paren
op_amp
id|wanpipe_socks_nr
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*============================================================&n; *  wanpipe_do_bind&n; *&n; * &t;Bottom half of the binding system call.&n; *      Once the wanpipe_bind() function checks  the&n; *      legality of the call, this function binds the&n; *      sock to the driver.&n; *===========================================================*/
DECL|function|wanpipe_do_bind
r_static
r_int
id|wanpipe_do_bind
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
id|netdevice_t
op_star
id|dev
comma
r_int
id|protocol
)paren
(brace
id|wanpipe_common_t
op_star
id|chan
op_assign
l_int|NULL
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;zapped
)paren
(brace
id|err
op_assign
op_minus
id|EALREADY
suffix:semicolon
r_goto
id|bind_unlock_exit
suffix:semicolon
)brace
id|sk-&gt;num
op_assign
id|protocol
suffix:semicolon
r_if
c_cond
(paren
id|protocol
op_eq
l_int|0
)paren
(brace
id|release_device
c_func
(paren
id|dev
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|bind_unlock_exit
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dev
)paren
(brace
r_if
c_cond
(paren
id|dev-&gt;flags
op_amp
id|IFF_UP
)paren
(brace
id|chan
op_assign
id|dev-&gt;priv
suffix:semicolon
id|sk-&gt;state
op_assign
id|chan-&gt;state
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;num
op_eq
id|htons
c_func
(paren
id|X25_PROT
)paren
op_logical_and
id|sk-&gt;state
op_ne
id|WANSOCK_DISCONNECTED
op_logical_and
id|sk-&gt;state
op_ne
id|WANSOCK_CONNECTING
)paren
(brace
id|DBG_PRINTK
c_func
(paren
id|KERN_INFO
l_string|&quot;wansock: Binding to Device not DISCONNECTED %i&bslash;n&quot;
comma
id|sk-&gt;state
)paren
suffix:semicolon
id|release_device
c_func
(paren
id|dev
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EAGAIN
suffix:semicolon
r_goto
id|bind_unlock_exit
suffix:semicolon
)brace
id|wanpipe_link_driver
c_func
(paren
id|dev
comma
id|sk
)paren
suffix:semicolon
id|sk-&gt;bound_dev_if
op_assign
id|dev-&gt;ifindex
suffix:semicolon
multiline_comment|/* X25 Specific option */
r_if
c_cond
(paren
id|sk-&gt;num
op_eq
id|htons
c_func
(paren
id|X25_PROT
)paren
)paren
id|wp_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|svc
op_assign
id|chan-&gt;svc
suffix:semicolon
)brace
r_else
(brace
id|sk-&gt;err
op_assign
id|ENETDOWN
suffix:semicolon
id|sk
op_member_access_from_pointer
id|error_report
c_func
(paren
id|sk
)paren
suffix:semicolon
id|release_device
c_func
(paren
id|dev
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
r_else
(brace
id|err
op_assign
op_minus
id|ENODEV
suffix:semicolon
)brace
id|bind_unlock_exit
suffix:colon
multiline_comment|/* FIXME where is this lock */
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*============================================================&n; *  wanpipe_bind&n; *&n; *      BIND() System call, which is bound to the AF_WANPIPE&n; *      operations structure.  It checks for correct wanpipe&n; *      card name, and cross references interface names with&n; *      the card names.  Thus, interface name must belong to&n; *      the actual card.&n; *===========================================================*/
DECL|function|wanpipe_bind
r_static
r_int
id|wanpipe_bind
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_struct
id|sockaddr
op_star
id|uaddr
comma
r_int
id|addr_len
)paren
(brace
r_struct
id|wan_sockaddr_ll
op_star
id|sll
op_assign
(paren
r_struct
id|wan_sockaddr_ll
op_star
)paren
id|uaddr
suffix:semicolon
r_struct
id|sock
op_star
id|sk
op_assign
id|sock-&gt;sk
suffix:semicolon
id|netdevice_t
op_star
id|dev
op_assign
l_int|NULL
suffix:semicolon
id|sdla_t
op_star
id|card
op_assign
l_int|NULL
suffix:semicolon
r_char
id|name
(braket
l_int|15
)braket
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Check legality&n;&t; */
r_if
c_cond
(paren
id|addr_len
OL
r_sizeof
(paren
r_struct
id|wan_sockaddr_ll
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;wansock: Address length error&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sll-&gt;sll_family
op_ne
id|AF_WANPIPE
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;wansock: Illegal family name specified.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|card
op_assign
id|wanpipe_find_card
(paren
id|sll-&gt;sll_card
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|card
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;wansock: Wanpipe card not found: %s&bslash;n&quot;
comma
id|sll-&gt;sll_card
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_else
(brace
id|wp_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|card
op_assign
(paren
r_void
op_star
)paren
id|card
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|sll-&gt;sll_device
comma
l_string|&quot;svc_listen&quot;
)paren
)paren
(brace
multiline_comment|/* Bind a sock to a card structure for listening &n;&t;&t; */
r_int
id|err
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* This is x25 specific area if protocol doesn&squot;t&n;                 * match, return error */
r_if
c_cond
(paren
id|sll-&gt;sll_protocol
op_ne
id|htons
c_func
(paren
id|X25_PROT
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|err
op_assign
id|wanpipe_link_card
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_return
id|err
suffix:semicolon
r_if
c_cond
(paren
id|sll-&gt;sll_protocol
)paren
id|sk-&gt;num
op_assign
id|sll-&gt;sll_protocol
suffix:semicolon
id|sk-&gt;state
op_assign
id|WANSOCK_BIND_LISTEN
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|sll-&gt;sll_device
comma
l_string|&quot;svc_connect&quot;
)paren
)paren
(brace
multiline_comment|/* This is x25 specific area if protocol doesn&squot;t&n;                 * match, return error */
r_if
c_cond
(paren
id|sll-&gt;sll_protocol
op_ne
id|htons
c_func
(paren
id|X25_PROT
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* Find a free device &n;&t;&t; */
id|dev
op_assign
id|wanpipe_find_free_dev
c_func
(paren
id|card
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_eq
l_int|NULL
)paren
(brace
id|DBG_PRINTK
c_func
(paren
id|KERN_INFO
l_string|&quot;wansock: No free network devices for card %s&bslash;n&quot;
comma
id|card-&gt;devname
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* Bind a socket to a interface name &n;                 * This is used by PVC mostly&n;                 */
id|strncpy
c_func
(paren
id|name
comma
id|sll-&gt;sll_device
comma
l_int|14
)paren
suffix:semicolon
id|name
(braket
l_int|14
)braket
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef LINUX_2_4
id|dev
op_assign
id|dev_get_by_name
c_func
(paren
id|name
)paren
suffix:semicolon
macro_line|#else
id|dev
op_assign
id|dev_get
c_func
(paren
id|name
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|dev
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;wansock: Failed to get Dev from name: %s,&bslash;n&quot;
comma
id|name
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|dev_put
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|check_dev
c_func
(paren
id|dev
comma
id|card
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;wansock: Device %s, doesn&squot;t belong to card %s&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|card-&gt;devname
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|get_atomic_device
(paren
id|dev
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
id|wanpipe_do_bind
c_func
(paren
id|sk
comma
id|dev
comma
id|sll-&gt;sll_protocol
ques
c_cond
suffix:colon
id|sk-&gt;num
)paren
suffix:semicolon
)brace
multiline_comment|/*============================================================&n; * get_atomic_device&n; *&t;&n; *&t;Sets a bit atomically which indicates that &n; *      the interface is taken. This avoids race conditions.&n; *===========================================================*/
DECL|function|get_atomic_device
r_static
r_inline
r_int
id|get_atomic_device
(paren
id|netdevice_t
op_star
id|dev
)paren
(brace
id|wanpipe_common_t
op_star
id|chan
op_assign
id|dev-&gt;priv
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|test_and_set_bit
c_func
(paren
l_int|0
comma
(paren
r_void
op_star
)paren
op_amp
id|chan-&gt;rw_bind
)paren
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*============================================================&n; * check_dev&n; *&t;&n; *  &t;Check that device name belongs to a particular card.&n; *===========================================================*/
DECL|function|check_dev
r_static
r_int
id|check_dev
(paren
id|netdevice_t
op_star
id|dev
comma
id|sdla_t
op_star
id|card
)paren
(brace
id|netdevice_t
op_star
id|tmp_dev
suffix:semicolon
r_for
c_loop
(paren
id|tmp_dev
op_assign
id|card-&gt;wandev.dev
suffix:semicolon
id|tmp_dev
suffix:semicolon
id|tmp_dev
op_assign
op_star
(paren
(paren
id|netdevice_t
op_star
op_star
)paren
id|tmp_dev-&gt;priv
)paren
)paren
(brace
r_if
c_cond
(paren
id|tmp_dev-&gt;ifindex
op_eq
id|dev-&gt;ifindex
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*============================================================&n; *  wanpipe_find_free_dev&n; *&t;&n; *&t;Find a free network interface. If found set atomic&n; *      bit indicating that the interface is taken.&n; *      X25API Specific.&n; *===========================================================*/
DECL|function|wanpipe_find_free_dev
id|netdevice_t
op_star
id|wanpipe_find_free_dev
(paren
id|sdla_t
op_star
id|card
)paren
(brace
id|netdevice_t
op_star
id|dev
suffix:semicolon
r_volatile
id|wanpipe_common_t
op_star
id|chan
suffix:semicolon
r_if
c_cond
(paren
id|test_and_set_bit
c_func
(paren
l_int|0
comma
op_amp
id|find_free_critical
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;CRITICAL in Find Free&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|dev
op_assign
id|card-&gt;wandev.dev
suffix:semicolon
id|dev
suffix:semicolon
id|dev
op_assign
op_star
(paren
(paren
id|netdevice_t
op_star
op_star
)paren
id|dev-&gt;priv
)paren
)paren
(brace
id|chan
op_assign
id|dev-&gt;priv
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|chan
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|chan-&gt;usedby
op_eq
id|API
op_logical_and
id|chan-&gt;svc
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|get_atomic_device
(paren
id|dev
)paren
)paren
(brace
r_if
c_cond
(paren
id|chan-&gt;state
op_ne
id|WANSOCK_DISCONNECTED
)paren
(brace
id|release_device
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_else
(brace
id|clear_bit
c_func
(paren
l_int|0
comma
op_amp
id|find_free_critical
)paren
suffix:semicolon
r_return
id|dev
suffix:semicolon
)brace
)brace
)brace
)brace
id|clear_bit
c_func
(paren
l_int|0
comma
op_amp
id|find_free_critical
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*============================================================&n; *  wanpipe_create&n; *&t;&n; * &t;SOCKET() System call.  It allocates a sock structure&n; *      and adds the socket to the wanpipe_sk_list. &n; *      Crates AF_WANPIPE socket.&n; *===========================================================*/
DECL|function|wanpipe_create
r_static
r_int
id|wanpipe_create
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_int
id|protocol
)paren
(brace
r_struct
id|sock
op_star
id|sk
suffix:semicolon
singleline_comment|//FIXME: This checks for root user, SECURITY ?
singleline_comment|//if (!capable(CAP_NET_RAW))
singleline_comment|//&t;return -EPERM;
r_if
c_cond
(paren
id|sock-&gt;type
op_ne
id|SOCK_DGRAM
op_logical_and
id|sock-&gt;type
op_ne
id|SOCK_RAW
)paren
r_return
op_minus
id|ESOCKTNOSUPPORT
suffix:semicolon
id|sock-&gt;state
op_assign
id|SS_UNCONNECTED
suffix:semicolon
r_if
c_cond
(paren
(paren
id|sk
op_assign
id|wanpipe_alloc_socket
c_func
(paren
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOBUFS
suffix:semicolon
id|sk-&gt;reuse
op_assign
l_int|1
suffix:semicolon
id|sock-&gt;ops
op_assign
op_amp
id|wanpipe_ops
suffix:semicolon
id|sock_init_data
c_func
(paren
id|sock
comma
id|sk
)paren
suffix:semicolon
id|sk-&gt;zapped
op_assign
l_int|0
suffix:semicolon
id|sk-&gt;family
op_assign
id|PF_WANPIPE
suffix:semicolon
id|sk-&gt;num
op_assign
id|protocol
suffix:semicolon
id|sk-&gt;state
op_assign
id|WANSOCK_DISCONNECTED
suffix:semicolon
id|sk-&gt;ack_backlog
op_assign
l_int|0
suffix:semicolon
id|sk-&gt;bound_dev_if
op_assign
l_int|0
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|wanpipe_socks_nr
)paren
suffix:semicolon
multiline_comment|/* We must disable interrupts because the ISR&n;&t; * can also change the list */
id|set_bit
c_func
(paren
l_int|1
comma
op_amp
id|wanpipe_tx_critical
)paren
suffix:semicolon
id|write_lock
c_func
(paren
op_amp
id|wanpipe_sklist_lock
)paren
suffix:semicolon
id|sk-&gt;next
op_assign
id|wanpipe_sklist
suffix:semicolon
id|wanpipe_sklist
op_assign
id|sk
suffix:semicolon
id|sock_hold
c_func
(paren
id|sk
)paren
suffix:semicolon
id|write_unlock
c_func
(paren
op_amp
id|wanpipe_sklist_lock
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
l_int|1
comma
op_amp
id|wanpipe_tx_critical
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*============================================================&n; *  wanpipe_recvmsg&n; *&t;&n; *&t;Pull a packet from our receive queue and hand it &n; *      to the user. If necessary we block.&n; *===========================================================*/
DECL|function|wanpipe_recvmsg
r_static
r_int
id|wanpipe_recvmsg
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_struct
id|msghdr
op_star
id|msg
comma
r_int
id|len
comma
r_int
id|flags
comma
r_struct
id|scm_cookie
op_star
id|scm
)paren
(brace
r_struct
id|sock
op_star
id|sk
op_assign
id|sock-&gt;sk
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_int
id|copied
comma
id|err
op_assign
op_minus
id|ENOBUFS
suffix:semicolon
multiline_comment|/*&n;&t; *&t;If the address length field is there to be filled in, we fill&n;&t; *&t;it in now.&n;&t; */
id|msg-&gt;msg_namelen
op_assign
r_sizeof
(paren
r_struct
id|wan_sockaddr_ll
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Call the generic datagram receiver. This handles all sorts&n;&t; *&t;of horrible races and re-entrancy so we can forget about it&n;&t; *&t;in the protocol layers.&n;&t; *&n;&t; *&t;Now it will return ENETDOWN, if device have just gone down,&n;&t; *&t;but then it will block.&n;&t; */
r_if
c_cond
(paren
id|flags
op_amp
id|MSG_OOB
)paren
(brace
id|skb
op_assign
id|skb_dequeue
c_func
(paren
op_amp
id|sk-&gt;error_queue
)paren
suffix:semicolon
)brace
r_else
(brace
id|skb
op_assign
id|skb_recv_datagram
c_func
(paren
id|sk
comma
id|flags
comma
l_int|1
comma
op_amp
id|err
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;An error occurred so return it. Because skb_recv_datagram() &n;&t; *&t;handles the blocking we don&squot;t see and worry about blocking&n;&t; *&t;retries.&n;&t; */
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
(brace
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;You lose any data beyond the buffer you gave. If it worries a&n;&t; *&t;user program they can ask the device for its MTU anyway.&n;&t; */
id|copied
op_assign
id|skb-&gt;len
suffix:semicolon
r_if
c_cond
(paren
id|copied
OG
id|len
)paren
(brace
id|copied
op_assign
id|len
suffix:semicolon
id|msg-&gt;msg_flags
op_or_assign
id|MSG_TRUNC
suffix:semicolon
)brace
id|wanpipe_wakeup_driver
c_func
(paren
id|sk
)paren
suffix:semicolon
multiline_comment|/* We can&squot;t use skb_copy_datagram here */
id|err
op_assign
id|memcpy_toiovec
c_func
(paren
id|msg-&gt;msg_iov
comma
id|skb-&gt;data
comma
id|copied
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out_free
suffix:semicolon
macro_line|#ifdef LINUX_2_1
id|sk-&gt;stamp
op_assign
id|skb-&gt;stamp
suffix:semicolon
macro_line|#else
id|sock_recv_timestamp
c_func
(paren
id|msg
comma
id|sk
comma
id|skb
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|msg-&gt;msg_name
)paren
id|memcpy
c_func
(paren
id|msg-&gt;msg_name
comma
id|skb-&gt;cb
comma
id|msg-&gt;msg_namelen
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Free or return the buffer as appropriate. Again this&n;&t; *&t;hides all the races and re-entrancy issues from us.&n;&t; */
id|err
op_assign
(paren
id|flags
op_amp
id|MSG_TRUNC
)paren
ques
c_cond
id|skb-&gt;len
suffix:colon
id|copied
suffix:semicolon
id|out_free
suffix:colon
id|skb_free_datagram
c_func
(paren
id|sk
comma
id|skb
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*============================================================&n; *  wanpipe_wakeup_driver&n; *&t;&n; * &t;If socket receive buffer is full and driver cannot&n; *      pass data up the sock, it sets a packet_block flag.&n; *      This function check that flag and if sock receive &n; *      queue has room it kicks the driver BH handler. &n; *&n; * &t;This way, driver doesn&squot;t have to poll the sock &n; *      receive queue.&n; *===========================================================*/
DECL|function|wanpipe_wakeup_driver
r_static
r_void
id|wanpipe_wakeup_driver
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
id|netdevice_t
op_star
id|dev
op_assign
l_int|NULL
suffix:semicolon
id|wanpipe_common_t
op_star
id|chan
op_assign
l_int|NULL
suffix:semicolon
id|dev
op_assign
id|dev_get_by_index
c_func
(paren
id|sk-&gt;bound_dev_if
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
r_return
suffix:semicolon
id|dev_put
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|chan
op_assign
id|dev-&gt;priv
)paren
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|chan-&gt;receive_block
)paren
)paren
(brace
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|sk-&gt;rmem_alloc
)paren
OL
(paren
(paren
r_int
)paren
id|sk-&gt;rcvbuf
op_star
l_float|0.9
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;wansock: Queuing task for wanpipe&bslash;n&quot;
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|chan-&gt;receive_block
comma
l_int|0
)paren
suffix:semicolon
id|wanpipe_queue_tq
c_func
(paren
op_amp
id|chan-&gt;wanpipe_task
)paren
suffix:semicolon
id|wanpipe_mark_bh
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*============================================================&n; *  wanpipe_getname&n; *&t;&n; * &t;I don&squot;t know what to do with this yet. &n; *      User can use this function to get sock address&n; *      information. Not very useful for Sangoma&squot;s purposes.&n; *===========================================================*/
DECL|function|wanpipe_getname
r_static
r_int
id|wanpipe_getname
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_struct
id|sockaddr
op_star
id|uaddr
comma
r_int
op_star
id|uaddr_len
comma
r_int
id|peer
)paren
(brace
id|netdevice_t
op_star
id|dev
suffix:semicolon
r_struct
id|sock
op_star
id|sk
op_assign
id|sock-&gt;sk
suffix:semicolon
r_struct
id|wan_sockaddr_ll
op_star
id|sll
op_assign
(paren
r_struct
id|wan_sockaddr_ll
op_star
)paren
id|uaddr
suffix:semicolon
id|sll-&gt;sll_family
op_assign
id|AF_WANPIPE
suffix:semicolon
id|sll-&gt;sll_ifindex
op_assign
id|sk-&gt;bound_dev_if
suffix:semicolon
id|sll-&gt;sll_protocol
op_assign
id|sk-&gt;num
suffix:semicolon
id|dev
op_assign
id|dev_get_by_index
c_func
(paren
id|sk-&gt;bound_dev_if
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev
)paren
(brace
id|sll-&gt;sll_hatype
op_assign
id|dev-&gt;type
suffix:semicolon
id|sll-&gt;sll_halen
op_assign
id|dev-&gt;addr_len
suffix:semicolon
id|memcpy
c_func
(paren
id|sll-&gt;sll_addr
comma
id|dev-&gt;dev_addr
comma
id|dev-&gt;addr_len
)paren
suffix:semicolon
)brace
r_else
(brace
id|sll-&gt;sll_hatype
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Bad: we have no ARPHRD_UNSPEC */
id|sll-&gt;sll_halen
op_assign
l_int|0
suffix:semicolon
)brace
op_star
id|uaddr_len
op_assign
r_sizeof
(paren
op_star
id|sll
)paren
suffix:semicolon
id|dev_put
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*============================================================&n; *  wanpipe_notifier&n; *&t;&n; *&t;If driver turns off network interface, this function&n; *      will be envoked. Currently I treate it as a &n; *      call disconnect. More thought should go into this&n; *      function.&n; *&n; * FIXME: More thought should go into this function.&n; *&n; *===========================================================*/
DECL|function|wanpipe_notifier
r_static
r_int
id|wanpipe_notifier
c_func
(paren
r_struct
id|notifier_block
op_star
id|this
comma
r_int
r_int
id|msg
comma
r_void
op_star
id|data
)paren
(brace
r_struct
id|sock
op_star
id|sk
suffix:semicolon
id|netdevice_t
op_star
id|dev
op_assign
(paren
id|netdevice_t
op_star
)paren
id|data
suffix:semicolon
r_struct
id|wanpipe_opt
op_star
id|po
suffix:semicolon
r_for
c_loop
(paren
id|sk
op_assign
id|wanpipe_sklist
suffix:semicolon
id|sk
suffix:semicolon
id|sk
op_assign
id|sk-&gt;next
)paren
(brace
r_if
c_cond
(paren
(paren
id|po
op_assign
id|wp_sk
c_func
(paren
id|sk
)paren
)paren
op_eq
l_int|NULL
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_eq
l_int|NULL
)paren
r_continue
suffix:semicolon
r_switch
c_cond
(paren
id|msg
)paren
(brace
r_case
id|NETDEV_DOWN
suffix:colon
r_case
id|NETDEV_UNREGISTER
suffix:colon
r_if
c_cond
(paren
id|dev-&gt;ifindex
op_eq
id|sk-&gt;bound_dev_if
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;wansock: Device down %s&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;zapped
)paren
(brace
id|wanpipe_unlink_driver
c_func
(paren
id|sk
)paren
suffix:semicolon
id|sk-&gt;err
op_assign
id|ENETDOWN
suffix:semicolon
id|sk
op_member_access_from_pointer
id|error_report
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|msg
op_eq
id|NETDEV_UNREGISTER
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;wansock: Unregistering Device: %s&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|wanpipe_unlink_driver
c_func
(paren
id|sk
)paren
suffix:semicolon
id|sk-&gt;bound_dev_if
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
r_case
id|NETDEV_UP
suffix:colon
r_if
c_cond
(paren
id|dev-&gt;ifindex
op_eq
id|sk-&gt;bound_dev_if
op_logical_and
id|sk-&gt;num
op_logical_and
op_logical_neg
id|sk-&gt;zapped
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;wansock: Registering Device: %s&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|wanpipe_link_driver
c_func
(paren
id|dev
comma
id|sk
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
)brace
r_return
id|NOTIFY_DONE
suffix:semicolon
)brace
multiline_comment|/*============================================================&n; *  wanpipe_ioctl&n; *&t;&n; * &t;Execute a user commands, and set socket options.&n; *&n; * FIXME: More thought should go into this function.&n; *&n; *===========================================================*/
DECL|function|wanpipe_ioctl
r_static
r_int
id|wanpipe_ioctl
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_struct
id|sock
op_star
id|sk
op_assign
id|sock-&gt;sk
suffix:semicolon
r_int
id|err
suffix:semicolon
r_int
id|pid
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|FIOSETOWN
suffix:colon
r_case
id|SIOCSPGRP
suffix:colon
id|err
op_assign
id|get_user
c_func
(paren
id|pid
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;pid
op_ne
id|pid
op_logical_and
id|current-&gt;pgrp
op_ne
op_minus
id|pid
op_logical_and
op_logical_neg
id|capable
c_func
(paren
id|CAP_NET_ADMIN
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|sk-&gt;proc
op_assign
id|pid
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|FIOGETOWN
suffix:colon
r_case
id|SIOCGPGRP
suffix:colon
r_return
id|put_user
c_func
(paren
id|sk-&gt;proc
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SIOCGSTAMP
suffix:colon
r_if
c_cond
(paren
id|sk-&gt;stamp.tv_sec
op_eq
l_int|0
)paren
(brace
r_return
op_minus
id|ENOENT
suffix:semicolon
)brace
id|err
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|sk-&gt;stamp
comma
r_sizeof
(paren
r_struct
id|timeval
)paren
)paren
)paren
id|err
op_assign
l_int|0
suffix:semicolon
r_return
id|err
suffix:semicolon
r_case
id|SIOC_WANPIPE_CHECK_TX
suffix:colon
r_return
id|atomic_read
c_func
(paren
op_amp
id|sk-&gt;wmem_alloc
)paren
suffix:semicolon
r_case
id|SIOC_WANPIPE_SOCK_STATE
suffix:colon
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|WANSOCK_CONNECTED
)paren
r_return
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
r_case
id|SIOC_WANPIPE_GET_CALL_DATA
suffix:colon
r_return
id|get_ioctl_cmd
(paren
id|sk
comma
(paren
r_void
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SIOC_WANPIPE_SET_CALL_DATA
suffix:colon
r_return
id|set_ioctl_cmd
(paren
id|sk
comma
(paren
r_void
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SIOC_WANPIPE_ACCEPT_CALL
suffix:colon
r_case
id|SIOC_WANPIPE_CLEAR_CALL
suffix:colon
r_case
id|SIOC_WANPIPE_RESET_CALL
suffix:colon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|set_ioctl_cmd
c_func
(paren
id|sk
comma
(paren
r_void
op_star
)paren
id|arg
)paren
)paren
OL
l_int|0
)paren
r_return
id|err
suffix:semicolon
id|err
op_assign
id|wanpipe_exec_cmd
c_func
(paren
id|sk
comma
id|cmd
comma
l_int|0
)paren
suffix:semicolon
id|get_ioctl_cmd
c_func
(paren
id|sk
comma
(paren
r_void
op_star
)paren
id|arg
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
r_case
id|SIOC_WANPIPE_DEBUG
suffix:colon
r_return
id|wanpipe_debug
c_func
(paren
id|sk
comma
(paren
r_void
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SIOC_WANPIPE_SET_NONBLOCK
suffix:colon
r_if
c_cond
(paren
id|sk-&gt;state
op_ne
id|WANSOCK_DISCONNECTED
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|sock-&gt;file-&gt;f_flags
op_or_assign
id|O_NONBLOCK
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SIOCGIFFLAGS
suffix:colon
macro_line|#ifndef CONFIG_INET
r_case
id|SIOCSIFFLAGS
suffix:colon
macro_line|#endif
r_case
id|SIOCGIFCONF
suffix:colon
r_case
id|SIOCGIFMETRIC
suffix:colon
r_case
id|SIOCSIFMETRIC
suffix:colon
r_case
id|SIOCGIFMEM
suffix:colon
r_case
id|SIOCSIFMEM
suffix:colon
r_case
id|SIOCGIFMTU
suffix:colon
r_case
id|SIOCSIFMTU
suffix:colon
r_case
id|SIOCSIFLINK
suffix:colon
r_case
id|SIOCGIFHWADDR
suffix:colon
r_case
id|SIOCSIFHWADDR
suffix:colon
r_case
id|SIOCSIFMAP
suffix:colon
r_case
id|SIOCGIFMAP
suffix:colon
r_case
id|SIOCSIFSLAVE
suffix:colon
r_case
id|SIOCGIFSLAVE
suffix:colon
r_case
id|SIOCGIFINDEX
suffix:colon
r_case
id|SIOCGIFNAME
suffix:colon
r_case
id|SIOCGIFCOUNT
suffix:colon
r_case
id|SIOCSIFHWBROADCAST
suffix:colon
r_return
id|dev_ioctl
c_func
(paren
id|cmd
comma
(paren
r_void
op_star
)paren
id|arg
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_INET
r_case
id|SIOCADDRT
suffix:colon
r_case
id|SIOCDELRT
suffix:colon
r_case
id|SIOCDARP
suffix:colon
r_case
id|SIOCGARP
suffix:colon
r_case
id|SIOCSARP
suffix:colon
r_case
id|SIOCDRARP
suffix:colon
r_case
id|SIOCGRARP
suffix:colon
r_case
id|SIOCSRARP
suffix:colon
r_case
id|SIOCGIFADDR
suffix:colon
r_case
id|SIOCSIFADDR
suffix:colon
r_case
id|SIOCGIFBRDADDR
suffix:colon
r_case
id|SIOCSIFBRDADDR
suffix:colon
r_case
id|SIOCGIFNETMASK
suffix:colon
r_case
id|SIOCSIFNETMASK
suffix:colon
r_case
id|SIOCGIFDSTADDR
suffix:colon
r_case
id|SIOCSIFDSTADDR
suffix:colon
r_case
id|SIOCSIFFLAGS
suffix:colon
r_case
id|SIOCADDDLCI
suffix:colon
r_case
id|SIOCDELDLCI
suffix:colon
r_return
id|inet_dgram_ops
dot
id|ioctl
c_func
(paren
id|sock
comma
id|cmd
comma
id|arg
)paren
suffix:semicolon
macro_line|#endif
r_default
suffix:colon
(brace
)brace
r_if
c_cond
(paren
(paren
id|cmd
op_ge
id|SIOCDEVPRIVATE
)paren
op_logical_and
(paren
id|cmd
op_le
(paren
id|SIOCDEVPRIVATE
op_plus
l_int|15
)paren
)paren
)paren
r_return
id|dev_ioctl
c_func
(paren
id|cmd
comma
(paren
r_void
op_star
)paren
id|arg
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_NET_RADIO
r_if
c_cond
(paren
(paren
id|cmd
op_ge
id|SIOCIWFIRST
)paren
op_logical_and
(paren
id|cmd
op_le
id|SIOCIWLAST
)paren
)paren
(brace
r_return
id|dev_ioctl
c_func
(paren
id|cmd
comma
(paren
r_void
op_star
)paren
id|arg
)paren
suffix:semicolon
)brace
macro_line|#endif
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
multiline_comment|/*NOTREACHED*/
)brace
multiline_comment|/*============================================================&n; *  wanpipe_debug&n; *&t;&n; *&t;This function will pass up information about all&n; *      active sockets.&n; *&n; * FIXME: More thought should go into this function.&n; *&n; *===========================================================*/
DECL|function|wanpipe_debug
r_static
r_int
id|wanpipe_debug
(paren
r_struct
id|sock
op_star
id|origsk
comma
r_void
op_star
id|arg
)paren
(brace
r_struct
id|sock
op_star
id|sk
op_assign
l_int|NULL
suffix:semicolon
id|netdevice_t
op_star
id|dev
op_assign
l_int|NULL
suffix:semicolon
id|wanpipe_common_t
op_star
id|chan
op_assign
l_int|NULL
suffix:semicolon
r_int
id|cnt
op_assign
l_int|0
comma
id|err
op_assign
l_int|0
suffix:semicolon
id|wan_debug_t
op_star
id|dbg_data
op_assign
(paren
id|wan_debug_t
op_star
)paren
id|arg
suffix:semicolon
r_for
c_loop
(paren
id|sk
op_assign
id|wanpipe_sklist
suffix:semicolon
id|sk
suffix:semicolon
id|sk
op_assign
id|sk-&gt;next
)paren
(brace
id|wanpipe_opt
op_star
id|wp
op_assign
id|wp_sk
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk
op_eq
id|origsk
)paren
(brace
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|err
op_assign
id|put_user
c_func
(paren
l_int|1
comma
op_amp
id|dbg_data-&gt;debug
(braket
id|cnt
)braket
dot
id|free
)paren
)paren
)paren
r_return
id|err
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|put_user
c_func
(paren
id|sk-&gt;state
comma
op_amp
id|dbg_data-&gt;debug
(braket
id|cnt
)braket
dot
id|sk_state
)paren
)paren
)paren
r_return
id|err
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|put_user
c_func
(paren
id|sk-&gt;rcvbuf
comma
op_amp
id|dbg_data-&gt;debug
(braket
id|cnt
)braket
dot
id|rcvbuf
)paren
)paren
)paren
r_return
id|err
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|put_user
c_func
(paren
id|atomic_read
c_func
(paren
op_amp
id|sk-&gt;rmem_alloc
)paren
comma
op_amp
id|dbg_data-&gt;debug
(braket
id|cnt
)braket
dot
id|rmem
)paren
)paren
)paren
r_return
id|err
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|put_user
c_func
(paren
id|atomic_read
c_func
(paren
op_amp
id|sk-&gt;wmem_alloc
)paren
comma
op_amp
id|dbg_data-&gt;debug
(braket
id|cnt
)braket
dot
id|wmem
)paren
)paren
)paren
r_return
id|err
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|put_user
c_func
(paren
id|sk-&gt;sndbuf
comma
op_amp
id|dbg_data-&gt;debug
(braket
id|cnt
)braket
dot
id|sndbuf
)paren
)paren
)paren
r_return
id|err
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|put_user
c_func
(paren
id|sk_count
comma
op_amp
id|dbg_data-&gt;debug
(braket
id|cnt
)braket
dot
id|sk_count
)paren
)paren
)paren
r_return
id|err
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|put_user
c_func
(paren
id|wp-&gt;poll_cnt
comma
op_amp
id|dbg_data-&gt;debug
(braket
id|cnt
)braket
dot
id|poll_cnt
)paren
)paren
)paren
r_return
id|err
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|put_user
c_func
(paren
id|sk-&gt;bound_dev_if
comma
op_amp
id|dbg_data-&gt;debug
(braket
id|cnt
)braket
dot
id|bound
)paren
)paren
)paren
r_return
id|err
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;bound_dev_if
)paren
(brace
id|dev
op_assign
id|dev_get_by_index
c_func
(paren
id|sk-&gt;bound_dev_if
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
r_continue
suffix:semicolon
id|chan
op_assign
id|dev-&gt;priv
suffix:semicolon
id|dev_put
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|put_user
c_func
(paren
id|chan-&gt;state
comma
op_amp
id|dbg_data-&gt;debug
(braket
id|cnt
)braket
dot
id|d_state
)paren
)paren
)paren
r_return
id|err
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|put_user
c_func
(paren
id|chan-&gt;svc
comma
op_amp
id|dbg_data-&gt;debug
(braket
id|cnt
)braket
dot
id|svc
)paren
)paren
)paren
r_return
id|err
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|put_user
c_func
(paren
id|atomic_read
c_func
(paren
op_amp
id|chan-&gt;command
)paren
comma
op_amp
id|dbg_data-&gt;debug
(braket
id|cnt
)braket
dot
id|command
)paren
)paren
)paren
r_return
id|err
suffix:semicolon
r_if
c_cond
(paren
id|wp
)paren
(brace
id|sdla_t
op_star
id|card
op_assign
(paren
id|sdla_t
op_star
)paren
id|wp-&gt;card
suffix:semicolon
r_if
c_cond
(paren
id|card
)paren
(brace
r_if
c_cond
(paren
(paren
id|err
op_assign
id|put_user
c_func
(paren
id|atomic_read
c_func
(paren
op_amp
id|card-&gt;u.x.command_busy
)paren
comma
op_amp
id|dbg_data-&gt;debug
(braket
id|cnt
)braket
dot
id|cmd_busy
)paren
)paren
)paren
r_return
id|err
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|err
op_assign
id|put_user
c_func
(paren
id|wp-&gt;lcn
comma
op_amp
id|dbg_data-&gt;debug
(braket
id|cnt
)braket
dot
id|lcn
)paren
)paren
)paren
r_return
id|err
suffix:semicolon
r_if
c_cond
(paren
id|wp-&gt;mbox
)paren
(brace
r_if
c_cond
(paren
(paren
id|err
op_assign
id|put_user
c_func
(paren
l_int|1
comma
op_amp
id|dbg_data-&gt;debug
(braket
id|cnt
)braket
dot
id|mbox
)paren
)paren
)paren
r_return
id|err
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
(paren
id|err
op_assign
id|put_user
c_func
(paren
id|atomic_read
c_func
(paren
op_amp
id|chan-&gt;receive_block
)paren
comma
op_amp
id|dbg_data-&gt;debug
(braket
id|cnt
)braket
dot
id|rblock
)paren
)paren
)paren
r_return
id|err
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|dbg_data-&gt;debug
(braket
id|cnt
)braket
dot
id|name
comma
id|dev-&gt;name
comma
id|strlen
c_func
(paren
id|dev-&gt;name
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_if
c_cond
(paren
op_increment
id|cnt
op_eq
id|MAX_NUM_DEBUG
)paren
r_break
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*============================================================&n; *  get_ioctl_cmd&n; *&t;&n; *&t;Pass up the contents of socket MBOX to the user.&n; *===========================================================*/
DECL|function|get_ioctl_cmd
r_static
r_int
id|get_ioctl_cmd
(paren
r_struct
id|sock
op_star
id|sk
comma
r_void
op_star
id|arg
)paren
(brace
id|x25api_t
op_star
id|usr_data
op_assign
(paren
id|x25api_t
op_star
)paren
id|arg
suffix:semicolon
id|mbox_cmd_t
op_star
id|mbox_ptr
suffix:semicolon
r_int
id|err
suffix:semicolon
r_if
c_cond
(paren
id|usr_data
op_eq
l_int|NULL
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wp_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|mbox
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|mbox_ptr
op_assign
(paren
id|mbox_cmd_t
op_star
)paren
id|wp_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|mbox
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|put_user
c_func
(paren
id|mbox_ptr-&gt;cmd.qdm
comma
op_amp
id|usr_data-&gt;hdr.qdm
)paren
)paren
)paren
r_return
id|err
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|put_user
c_func
(paren
id|mbox_ptr-&gt;cmd.cause
comma
op_amp
id|usr_data-&gt;hdr.cause
)paren
)paren
)paren
r_return
id|err
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|put_user
c_func
(paren
id|mbox_ptr-&gt;cmd.diagn
comma
op_amp
id|usr_data-&gt;hdr.diagn
)paren
)paren
)paren
r_return
id|err
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|put_user
c_func
(paren
id|mbox_ptr-&gt;cmd.length
comma
op_amp
id|usr_data-&gt;hdr.length
)paren
)paren
)paren
r_return
id|err
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|put_user
c_func
(paren
id|mbox_ptr-&gt;cmd.result
comma
op_amp
id|usr_data-&gt;hdr.result
)paren
)paren
)paren
r_return
id|err
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|put_user
c_func
(paren
id|mbox_ptr-&gt;cmd.lcn
comma
op_amp
id|usr_data-&gt;hdr.lcn
)paren
)paren
)paren
r_return
id|err
suffix:semicolon
r_if
c_cond
(paren
id|mbox_ptr-&gt;cmd.length
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|mbox_ptr-&gt;cmd.length
OG
id|X25_MAX_DATA
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|usr_data-&gt;data
comma
id|mbox_ptr-&gt;data
comma
id|mbox_ptr-&gt;cmd.length
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;wansock: Copy failed !!!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*============================================================&n; *  set_ioctl_cmd&n; *&t;&n; *&t;Before command can be execute, socket MBOX must&n; *      be created, and initialized with user data.&t;&n; *===========================================================*/
DECL|function|set_ioctl_cmd
r_static
r_int
id|set_ioctl_cmd
(paren
r_struct
id|sock
op_star
id|sk
comma
r_void
op_star
id|arg
)paren
(brace
id|x25api_t
op_star
id|usr_data
op_assign
(paren
id|x25api_t
op_star
)paren
id|arg
suffix:semicolon
id|mbox_cmd_t
op_star
id|mbox_ptr
suffix:semicolon
r_int
id|err
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wp_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|mbox
)paren
(brace
r_void
op_star
id|mbox_ptr
suffix:semicolon
id|netdevice_t
op_star
id|dev
op_assign
id|dev_get_by_index
c_func
(paren
id|sk-&gt;bound_dev_if
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|dev_put
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|mbox_ptr
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|mbox_cmd_t
)paren
comma
id|GFP_ATOMIC
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|memset
c_func
(paren
id|mbox_ptr
comma
l_int|0
comma
r_sizeof
(paren
id|mbox_cmd_t
)paren
)paren
suffix:semicolon
id|wp_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|mbox
op_assign
id|mbox_ptr
suffix:semicolon
id|wanpipe_link_driver
c_func
(paren
id|dev
comma
id|sk
)paren
suffix:semicolon
)brace
id|mbox_ptr
op_assign
(paren
id|mbox_cmd_t
op_star
)paren
id|wp_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|mbox
suffix:semicolon
id|memset
c_func
(paren
id|mbox_ptr
comma
l_int|0
comma
r_sizeof
(paren
id|mbox_cmd_t
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|usr_data
op_eq
l_int|NULL
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|err
op_assign
id|get_user
c_func
(paren
id|mbox_ptr-&gt;cmd.qdm
comma
op_amp
id|usr_data-&gt;hdr.qdm
)paren
)paren
)paren
r_return
id|err
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|get_user
c_func
(paren
id|mbox_ptr-&gt;cmd.cause
comma
op_amp
id|usr_data-&gt;hdr.cause
)paren
)paren
)paren
r_return
id|err
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|get_user
c_func
(paren
id|mbox_ptr-&gt;cmd.diagn
comma
op_amp
id|usr_data-&gt;hdr.diagn
)paren
)paren
)paren
r_return
id|err
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|get_user
c_func
(paren
id|mbox_ptr-&gt;cmd.length
comma
op_amp
id|usr_data-&gt;hdr.length
)paren
)paren
)paren
r_return
id|err
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|get_user
c_func
(paren
id|mbox_ptr-&gt;cmd.result
comma
op_amp
id|usr_data-&gt;hdr.result
)paren
)paren
)paren
r_return
id|err
suffix:semicolon
r_if
c_cond
(paren
id|mbox_ptr-&gt;cmd.length
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|mbox_ptr-&gt;cmd.length
OG
id|X25_MAX_DATA
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|mbox_ptr-&gt;data
comma
id|usr_data-&gt;data
comma
id|mbox_ptr-&gt;cmd.length
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Copy failed&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*======================================================================&n; * wanpipe_poll&n; *&n; *&t;Datagram poll: Again totally generic. This also handles&n; *&t;sequenced packet sockets providing the socket receive queue&n; *&t;is only ever holding data ready to receive.&n; *&n; *&t;Note: when you _don&squot;t_ use this routine for this protocol,&n; *&t;and you use a different write policy from sock_writeable()&n; *&t;then please supply your own write_space callback.&n; *=====================================================================*/
DECL|function|wanpipe_poll
r_int
r_int
id|wanpipe_poll
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_struct
id|socket
op_star
id|sock
comma
id|poll_table
op_star
id|wait
)paren
(brace
r_struct
id|sock
op_star
id|sk
op_assign
id|sock-&gt;sk
suffix:semicolon
r_int
r_int
id|mask
suffix:semicolon
op_increment
id|wp_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|poll_cnt
suffix:semicolon
id|poll_wait
c_func
(paren
id|file
comma
id|sk-&gt;sleep
comma
id|wait
)paren
suffix:semicolon
id|mask
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* exceptional events? */
r_if
c_cond
(paren
id|sk-&gt;err
op_logical_or
op_logical_neg
id|skb_queue_empty
c_func
(paren
op_amp
id|sk-&gt;error_queue
)paren
)paren
(brace
id|mask
op_or_assign
id|POLLPRI
suffix:semicolon
r_return
id|mask
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sk-&gt;shutdown
op_amp
id|RCV_SHUTDOWN
)paren
id|mask
op_or_assign
id|POLLHUP
suffix:semicolon
multiline_comment|/* readable? */
r_if
c_cond
(paren
op_logical_neg
id|skb_queue_empty
c_func
(paren
op_amp
id|sk-&gt;receive_queue
)paren
)paren
(brace
id|mask
op_or_assign
id|POLLIN
op_or
id|POLLRDNORM
suffix:semicolon
)brace
multiline_comment|/* connection hasn&squot;t started yet */
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|WANSOCK_CONNECTING
)paren
(brace
r_return
id|mask
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|WANSOCK_DISCONNECTED
)paren
(brace
id|mask
op_assign
id|POLLPRI
suffix:semicolon
r_return
id|mask
suffix:semicolon
)brace
multiline_comment|/* This check blocks the user process if there is   &n;&t; * a packet already queued in the socket write queue.&n;         * This option is only for X25API protocol, for other&n;         * protocol like chdlc enable streaming mode, &n;         * where multiple packets can be pending in the socket &n;         * transmit queue */
r_if
c_cond
(paren
id|sk-&gt;num
op_eq
id|htons
c_func
(paren
id|X25_PROT
)paren
)paren
(brace
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|wp_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|packet_sent
)paren
)paren
r_return
id|mask
suffix:semicolon
)brace
multiline_comment|/* writable? */
r_if
c_cond
(paren
id|sock_writeable
c_func
(paren
id|sk
)paren
)paren
(brace
id|mask
op_or_assign
id|POLLOUT
op_or
id|POLLWRNORM
op_or
id|POLLWRBAND
suffix:semicolon
)brace
r_else
(brace
macro_line|#ifdef LINUX_2_4
id|set_bit
c_func
(paren
id|SOCK_ASYNC_NOSPACE
comma
op_amp
id|sk-&gt;socket-&gt;flags
)paren
suffix:semicolon
macro_line|#else
id|sk-&gt;socket-&gt;flags
op_or_assign
id|SO_NOSPACE
suffix:semicolon
macro_line|#endif
)brace
r_return
id|mask
suffix:semicolon
)brace
multiline_comment|/*======================================================================&n; * wanpipe_listen&n; *&n; *&t;X25API Specific function. Set a socket into LISTENING  MODE.&n; *=====================================================================*/
DECL|function|wanpipe_listen
r_static
r_int
id|wanpipe_listen
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_int
id|backlog
)paren
(brace
r_struct
id|sock
op_star
id|sk
op_assign
id|sock-&gt;sk
suffix:semicolon
multiline_comment|/* This is x25 specific area if protocol doesn&squot;t&n;         * match, return error */
r_if
c_cond
(paren
id|sk-&gt;num
op_ne
id|htons
c_func
(paren
id|X25_PROT
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|WANSOCK_BIND_LISTEN
)paren
(brace
id|sk-&gt;max_ack_backlog
op_assign
id|backlog
suffix:semicolon
id|sk-&gt;state
op_assign
id|WANSOCK_LISTEN
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;wansock: Listening sock was not binded&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/*======================================================================&n; * wanpipe_link_card&n; *&n; *&t;Connects the listening socket to the driver&n; *=====================================================================*/
DECL|function|wanpipe_link_card
r_static
r_int
id|wanpipe_link_card
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
id|sdla_t
op_star
id|card
op_assign
(paren
id|sdla_t
op_star
)paren
id|wp_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|card
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|card
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
(paren
id|card-&gt;sk
op_ne
l_int|NULL
)paren
op_logical_or
(paren
id|card-&gt;func
op_ne
l_int|NULL
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;wansock: Listening queue is already established&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|card-&gt;sk
op_assign
id|sk
suffix:semicolon
id|card-&gt;func
op_assign
id|wanpipe_listen_rcv
suffix:semicolon
id|sk-&gt;zapped
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*======================================================================&n; * wanpipe_listen&n; *&n; *&t;X25API Specific function. Disconnect listening socket from&n; *      the driver.&n; *=====================================================================*/
DECL|function|wanpipe_unlink_card
r_static
r_void
id|wanpipe_unlink_card
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
id|sdla_t
op_star
id|card
op_assign
(paren
id|sdla_t
op_star
)paren
id|wp_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|card
suffix:semicolon
r_if
c_cond
(paren
id|card
)paren
(brace
id|card-&gt;sk
op_assign
l_int|NULL
suffix:semicolon
id|card-&gt;func
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
multiline_comment|/*======================================================================&n; * wanpipe_exec_cmd&n; *&n; *&t;Ioctl function calls this function to execute user command.&n; *      Connect() sytem call also calls this function to execute&n; *      place call.  This function blocks until command is executed.&n; *=====================================================================*/
DECL|function|wanpipe_exec_cmd
r_static
r_int
id|wanpipe_exec_cmd
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|cmd
comma
r_int
r_int
id|flags
)paren
(brace
r_int
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
id|wanpipe_opt
op_star
id|wp
op_assign
id|wp_sk
c_func
(paren
id|sk
)paren
suffix:semicolon
id|mbox_cmd_t
op_star
id|mbox_ptr
op_assign
(paren
id|mbox_cmd_t
op_star
)paren
id|wp-&gt;mbox
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mbox_ptr
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;NO MBOX PTR !!!!!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* This is x25 specific area if protocol doesn&squot;t&n;         * match, return error */
r_if
c_cond
(paren
id|sk-&gt;num
op_ne
id|htons
c_func
(paren
id|X25_PROT
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|SIOC_WANPIPE_ACCEPT_CALL
suffix:colon
r_if
c_cond
(paren
id|sk-&gt;state
op_ne
id|WANSOCK_CONNECTING
)paren
(brace
id|err
op_assign
op_minus
id|EHOSTDOWN
suffix:semicolon
r_break
suffix:semicolon
)brace
id|err
op_assign
id|execute_command
c_func
(paren
id|sk
comma
id|X25_ACCEPT_CALL
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_break
suffix:semicolon
multiline_comment|/* Update. Mar6 2000. &n;                         * Do not set the sock lcn number here, since&n;                         * it is done in wanpipe_listen_rcv(). &n;                         */
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|WANSOCK_CONNECTED
)paren
(brace
id|wp-&gt;lcn
op_assign
(paren
(paren
id|mbox_cmd_t
op_star
)paren
id|wp-&gt;mbox
)paren
op_member_access_from_pointer
id|cmd.lcn
suffix:semicolon
id|DBG_PRINTK
c_func
(paren
id|KERN_INFO
l_string|&quot;&bslash;nwansock: Accept OK %i&bslash;n&quot;
comma
id|wp-&gt;lcn
)paren
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|DBG_PRINTK
(paren
id|KERN_INFO
l_string|&quot;&bslash;nwansock: Accept Failed %i&bslash;n&quot;
comma
id|wp-&gt;lcn
)paren
suffix:semicolon
id|wp-&gt;lcn
op_assign
l_int|0
suffix:semicolon
id|err
op_assign
op_minus
id|ECONNREFUSED
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|SIOC_WANPIPE_CLEAR_CALL
suffix:colon
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|WANSOCK_DISCONNECTED
)paren
(brace
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Check if data buffers are pending for transmission,&n;                         * if so, check wheter user wants to wait untill data&n;                         * is transmitted, or clear a call and drop packets */
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|sk-&gt;wmem_alloc
)paren
op_logical_or
id|check_driver_busy
c_func
(paren
id|sk
)paren
)paren
(brace
id|mbox_cmd_t
op_star
id|mbox
op_assign
id|wp-&gt;mbox
suffix:semicolon
r_if
c_cond
(paren
id|mbox-&gt;cmd.qdm
op_amp
l_int|0x80
)paren
(brace
id|mbox-&gt;cmd.result
op_assign
l_int|0x35
suffix:semicolon
id|err
op_assign
op_minus
id|EAGAIN
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|sk-&gt;state
op_assign
id|WANSOCK_DISCONNECTING
suffix:semicolon
id|err
op_assign
id|execute_command
c_func
(paren
id|sk
comma
id|X25_CLEAR_CALL
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_break
suffix:semicolon
id|err
op_assign
op_minus
id|ECONNREFUSED
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|WANSOCK_DISCONNECTED
)paren
(brace
id|DBG_PRINTK
c_func
(paren
id|KERN_INFO
l_string|&quot;&bslash;nwansock: CLEAR OK %i&bslash;n&quot;
comma
id|wp-&gt;lcn
)paren
suffix:semicolon
id|wp-&gt;lcn
op_assign
l_int|0
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|SIOC_WANPIPE_RESET_CALL
suffix:colon
r_if
c_cond
(paren
id|sk-&gt;state
op_ne
id|WANSOCK_CONNECTED
)paren
(brace
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Check if data buffers are pending for transmission,&n;                         * if so, check wheter user wants to wait untill data&n;                         * is transmitted, or reset a call and drop packets */
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|sk-&gt;wmem_alloc
)paren
op_logical_or
id|check_driver_busy
c_func
(paren
id|sk
)paren
)paren
(brace
id|mbox_cmd_t
op_star
id|mbox
op_assign
id|wp-&gt;mbox
suffix:semicolon
r_if
c_cond
(paren
id|mbox-&gt;cmd.qdm
op_amp
l_int|0x80
)paren
(brace
id|mbox-&gt;cmd.result
op_assign
l_int|0x35
suffix:semicolon
id|err
op_assign
op_minus
id|EAGAIN
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|err
op_assign
id|execute_command
c_func
(paren
id|sk
comma
id|X25_RESET
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_break
suffix:semicolon
id|err
op_assign
id|mbox_ptr-&gt;cmd.result
suffix:semicolon
r_break
suffix:semicolon
r_case
id|X25_PLACE_CALL
suffix:colon
id|err
op_assign
id|execute_command
c_func
(paren
id|sk
comma
id|X25_PLACE_CALL
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|WANSOCK_CONNECTED
)paren
(brace
id|wp-&gt;lcn
op_assign
(paren
(paren
id|mbox_cmd_t
op_star
)paren
id|wp-&gt;mbox
)paren
op_member_access_from_pointer
id|cmd.lcn
suffix:semicolon
id|DBG_PRINTK
c_func
(paren
id|KERN_INFO
l_string|&quot;&bslash;nwansock: PLACE CALL OK %i&bslash;n&quot;
comma
id|wp-&gt;lcn
)paren
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|WANSOCK_CONNECTING
op_logical_and
(paren
id|flags
op_amp
id|O_NONBLOCK
)paren
)paren
(brace
id|wp-&gt;lcn
op_assign
(paren
(paren
id|mbox_cmd_t
op_star
)paren
id|wp-&gt;mbox
)paren
op_member_access_from_pointer
id|cmd.lcn
suffix:semicolon
id|DBG_PRINTK
c_func
(paren
id|KERN_INFO
l_string|&quot;&bslash;nwansock: Place Call OK: Waiting %i&bslash;n&quot;
comma
id|wp-&gt;lcn
)paren
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|DBG_PRINTK
c_func
(paren
id|KERN_INFO
l_string|&quot;&bslash;nwansock: Place call Failed&bslash;n&quot;
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|ECONNREFUSED
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
id|err
suffix:semicolon
)brace
DECL|function|check_driver_busy
r_static
r_int
id|check_driver_busy
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
id|netdevice_t
op_star
id|dev
op_assign
id|dev_get_by_index
c_func
(paren
id|sk-&gt;bound_dev_if
)paren
suffix:semicolon
id|wanpipe_common_t
op_star
id|chan
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
r_return
l_int|0
suffix:semicolon
id|dev_put
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|chan
op_assign
id|dev-&gt;priv
)paren
op_eq
l_int|NULL
)paren
r_return
l_int|0
suffix:semicolon
r_return
id|atomic_read
c_func
(paren
op_amp
id|chan-&gt;driver_busy
)paren
suffix:semicolon
)brace
multiline_comment|/*======================================================================&n; * wanpipe_accept&n; *&n; *&t;ACCEPT() System call.&t;X25API Specific function. &n; *&t;For each incoming call, create a new socket and &n; *      return it to the user.&t;&n; *=====================================================================*/
DECL|function|wanpipe_accept
r_static
r_int
id|wanpipe_accept
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_struct
id|socket
op_star
id|newsock
comma
r_int
id|flags
)paren
(brace
r_struct
id|sock
op_star
id|sk
suffix:semicolon
r_struct
id|sock
op_star
id|newsk
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|newsock-&gt;sk
op_ne
l_int|NULL
)paren
(brace
id|wanpipe_kill_sock_accept
c_func
(paren
id|newsock-&gt;sk
)paren
suffix:semicolon
id|newsock-&gt;sk
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|sk
op_assign
id|sock-&gt;sk
)paren
op_eq
l_int|NULL
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;type
op_ne
id|SOCK_RAW
)paren
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;state
op_ne
id|WANSOCK_LISTEN
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;num
op_ne
id|htons
c_func
(paren
id|X25_PROT
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|add_wait_queue
c_func
(paren
id|sk-&gt;sleep
comma
op_amp
id|wait
)paren
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|skb
op_assign
id|skb_dequeue
c_func
(paren
op_amp
id|sk-&gt;receive_queue
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
)paren
(brace
id|err
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
id|err
op_assign
op_minus
id|ERESTARTSYS
suffix:semicolon
r_break
suffix:semicolon
)brace
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
id|remove_wait_queue
c_func
(paren
id|sk-&gt;sleep
comma
op_amp
id|wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_ne
l_int|0
)paren
r_return
id|err
suffix:semicolon
id|newsk
op_assign
id|get_newsk_from_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|newsk
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|set_bit
c_func
(paren
l_int|1
comma
op_amp
id|wanpipe_tx_critical
)paren
suffix:semicolon
id|write_lock
c_func
(paren
op_amp
id|wanpipe_sklist_lock
)paren
suffix:semicolon
id|newsk-&gt;next
op_assign
id|wanpipe_sklist
suffix:semicolon
id|wanpipe_sklist
op_assign
id|newsk
suffix:semicolon
id|sock_hold
c_func
(paren
id|sk
)paren
suffix:semicolon
id|write_unlock
c_func
(paren
op_amp
id|wanpipe_sklist_lock
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
l_int|1
comma
op_amp
id|wanpipe_tx_critical
)paren
suffix:semicolon
id|newsk-&gt;pair
op_assign
l_int|NULL
suffix:semicolon
id|newsk-&gt;socket
op_assign
id|newsock
suffix:semicolon
id|newsk-&gt;sleep
op_assign
op_amp
id|newsock-&gt;wait
suffix:semicolon
multiline_comment|/* Now attach up the new socket */
id|sk-&gt;ack_backlog
op_decrement
suffix:semicolon
id|newsock-&gt;sk
op_assign
id|newsk
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
id|DBG_PRINTK
c_func
(paren
id|KERN_INFO
l_string|&quot;&bslash;nwansock: ACCEPT Got LCN %i&bslash;n&quot;
comma
id|wp_sk
c_func
(paren
id|newsk
)paren
op_member_access_from_pointer
id|lcn
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*======================================================================&n; *  get_newsk_from_skb&n; *&n; *&t;Accept() uses this function to get the address of the new&n; *      socket structure.&n; *=====================================================================*/
DECL|function|get_newsk_from_skb
r_struct
id|sock
op_star
id|get_newsk_from_skb
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
id|netdevice_t
op_star
id|dev
op_assign
id|skb-&gt;dev
suffix:semicolon
id|wanpipe_common_t
op_star
id|chan
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|chan
op_assign
id|dev-&gt;priv
)paren
op_eq
l_int|NULL
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|chan-&gt;sk
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
r_return
(paren
r_struct
id|sock
op_star
)paren
id|chan-&gt;sk
suffix:semicolon
)brace
multiline_comment|/*======================================================================&n; *  wanpipe_connect&n; *&n; *  &t;CONNECT() System Call. X25API specific function&n; * &t;Check the state of the sock, and execute PLACE_CALL command.&n; *      Connect can ether block or return without waiting for connection, &n; *      if specified by user.&n; *=====================================================================*/
DECL|function|wanpipe_connect
r_static
r_int
id|wanpipe_connect
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_struct
id|sockaddr
op_star
id|uaddr
comma
r_int
id|addr_len
comma
r_int
id|flags
)paren
(brace
r_struct
id|sock
op_star
id|sk
op_assign
id|sock-&gt;sk
suffix:semicolon
r_struct
id|wan_sockaddr_ll
op_star
id|addr
op_assign
(paren
r_struct
id|wan_sockaddr_ll
op_star
)paren
id|uaddr
suffix:semicolon
id|netdevice_t
op_star
id|dev
suffix:semicolon
r_int
id|err
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;num
op_ne
id|htons
c_func
(paren
id|X25_PROT
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|WANSOCK_CONNECTED
)paren
r_return
op_minus
id|EISCONN
suffix:semicolon
multiline_comment|/* No reconnect on a seqpacket socket */
r_if
c_cond
(paren
id|sk-&gt;state
op_ne
id|WAN_DISCONNECTED
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;wansock: Trying to connect on channel NON DISCONNECT&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ECONNREFUSED
suffix:semicolon
)brace
id|sk-&gt;state
op_assign
id|WANSOCK_DISCONNECTED
suffix:semicolon
id|sock-&gt;state
op_assign
id|SS_UNCONNECTED
suffix:semicolon
r_if
c_cond
(paren
id|addr_len
op_ne
r_sizeof
(paren
r_struct
id|wan_sockaddr_ll
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|addr-&gt;sll_family
op_ne
id|AF_WANPIPE
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
(paren
id|dev
op_assign
id|dev_get_by_index
c_func
(paren
id|sk-&gt;bound_dev_if
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENETUNREACH
suffix:semicolon
id|dev_put
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;zapped
)paren
multiline_comment|/* Must bind first - autobinding does not work */
r_return
op_minus
id|EINVAL
suffix:semicolon
id|sock-&gt;state
op_assign
id|SS_CONNECTING
suffix:semicolon
id|sk-&gt;state
op_assign
id|WANSOCK_CONNECTING
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wp_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|mbox
)paren
(brace
r_if
c_cond
(paren
id|wp_sk
(paren
id|sk
)paren
op_member_access_from_pointer
id|svc
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_else
(brace
r_int
id|err
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|set_ioctl_cmd
c_func
(paren
id|sk
comma
l_int|NULL
)paren
)paren
OL
l_int|0
)paren
r_return
id|err
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
(paren
id|err
op_assign
id|wanpipe_exec_cmd
c_func
(paren
id|sk
comma
id|X25_PLACE_CALL
comma
id|flags
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|sock-&gt;state
op_assign
id|SS_UNCONNECTED
suffix:semicolon
id|sk-&gt;state
op_assign
id|WANSOCK_CONNECTED
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sk-&gt;state
op_ne
id|WANSOCK_CONNECTED
op_logical_and
(paren
id|flags
op_amp
id|O_NONBLOCK
)paren
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sk-&gt;state
op_ne
id|WANSOCK_CONNECTED
)paren
(brace
id|sock-&gt;state
op_assign
id|SS_UNCONNECTED
suffix:semicolon
r_return
op_minus
id|ECONNREFUSED
suffix:semicolon
)brace
id|sock-&gt;state
op_assign
id|SS_CONNECTED
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef LINUX_2_4
DECL|variable|wanpipe_ops
r_struct
id|proto_ops
id|wanpipe_ops
op_assign
(brace
id|family
suffix:colon
id|PF_WANPIPE
comma
id|release
suffix:colon
id|wanpipe_release
comma
id|bind
suffix:colon
id|wanpipe_bind
comma
id|connect
suffix:colon
id|wanpipe_connect
comma
id|socketpair
suffix:colon
id|sock_no_socketpair
comma
id|accept
suffix:colon
id|wanpipe_accept
comma
id|getname
suffix:colon
id|wanpipe_getname
comma
id|poll
suffix:colon
id|wanpipe_poll
comma
id|ioctl
suffix:colon
id|wanpipe_ioctl
comma
id|listen
suffix:colon
id|wanpipe_listen
comma
id|shutdown
suffix:colon
id|sock_no_shutdown
comma
id|setsockopt
suffix:colon
id|sock_no_setsockopt
comma
id|getsockopt
suffix:colon
id|sock_no_getsockopt
comma
id|sendmsg
suffix:colon
id|wanpipe_sendmsg
comma
id|recvmsg
suffix:colon
id|wanpipe_recvmsg
)brace
suffix:semicolon
macro_line|#else
DECL|variable|wanpipe_ops
r_struct
id|proto_ops
id|wanpipe_ops
op_assign
(brace
id|PF_WANPIPE
comma
id|sock_no_dup
comma
id|wanpipe_release
comma
id|wanpipe_bind
comma
id|wanpipe_connect
comma
id|sock_no_socketpair
comma
id|wanpipe_accept
comma
id|wanpipe_getname
comma
id|wanpipe_poll
comma
id|wanpipe_ioctl
comma
id|wanpipe_listen
comma
id|sock_no_shutdown
comma
id|sock_no_setsockopt
comma
id|sock_no_getsockopt
comma
id|sock_no_fcntl
comma
id|wanpipe_sendmsg
comma
id|wanpipe_recvmsg
)brace
suffix:semicolon
macro_line|#endif
DECL|variable|wanpipe_family_ops
r_static
r_struct
id|net_proto_family
id|wanpipe_family_ops
op_assign
(brace
id|family
suffix:colon
id|PF_WANPIPE
comma
id|create
suffix:colon
id|wanpipe_create
comma
)brace
suffix:semicolon
DECL|variable|wanpipe_netdev_notifier
r_struct
id|notifier_block
id|wanpipe_netdev_notifier
op_assign
(brace
id|notifier_call
suffix:colon
id|wanpipe_notifier
comma
)brace
suffix:semicolon
macro_line|#ifdef MODULE
DECL|function|cleanup_module
r_void
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;wansock: Cleaning up &bslash;n&quot;
)paren
suffix:semicolon
id|unregister_netdevice_notifier
c_func
(paren
op_amp
id|wanpipe_netdev_notifier
)paren
suffix:semicolon
id|sock_unregister
c_func
(paren
id|PF_WANPIPE
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|function|init_module
r_int
id|init_module
c_func
(paren
r_void
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;wansock: Registering Socket &bslash;n&quot;
)paren
suffix:semicolon
id|sock_register
c_func
(paren
op_amp
id|wanpipe_family_ops
)paren
suffix:semicolon
id|register_netdevice_notifier
c_func
(paren
op_amp
id|wanpipe_netdev_notifier
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
eof
