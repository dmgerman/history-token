multiline_comment|/*&n; * net/sched/ematch.c&t;&t;Extended Match API&n; *&n; *&t;&t;This program is free software; you can redistribute it and/or&n; *&t;&t;modify it under the terms of the GNU General Public License&n; *&t;&t;as published by the Free Software Foundation; either version&n; *&t;&t;2 of the License, or (at your option) any later version.&n; *&n; * Authors:&t;Thomas Graf &lt;tgraf@suug.ch&gt;&n; *&n; * ==========================================================================&n; *&n; * An extended match (ematch) is a small classification tool not worth&n; * writing a full classifier for. Ematches can be interconnected to form&n; * a logic expression and get attached to classifiers to extend their&n; * functionatlity.&n; *&n; * The userspace part transforms the logic expressions into an array&n; * consisting of multiple sequences of interconnected ematches separated&n; * by markers. Precedence is implemented by a special ematch kind&n; * referencing a sequence beyond the marker of the current sequence&n; * causing the current position in the sequence to be pushed onto a stack&n; * to allow the current position to be overwritten by the position referenced&n; * in the special ematch. Matching continues in the new sequence until a&n; * marker is reached causing the position to be restored from the stack.&n; *&n; * Example:&n; *          A AND (B1 OR B2) AND C AND D&n; *&n; *              -------&gt;-PUSH-------&n; *    --&gt;--    /         --&gt;--      &bslash;   --&gt;--&n; *   /     &bslash;  /         /     &bslash;      &bslash; /     &bslash;&n; * +-------+-------+-------+-------+-------+--------+&n; * | A AND | B AND | C AND | D END | B1 OR | B2 END |&n; * +-------+-------+-------+-------+-------+--------+&n; *                    &bslash;                      /&n; *                     --------&lt;-POP---------&n; *&n; * where B is a virtual ematch referencing to sequence starting with B1.&n; * &n; * ==========================================================================&n; *&n; * How to write an ematch in 60 seconds&n; * ------------------------------------&n; * &n; *   1) Provide a matcher function:&n; *      static int my_match(struct sk_buff *skb, struct tcf_ematch *m,&n; *                          struct tcf_pkt_info *info)&n; *      {&n; *      &t;struct mydata *d = (struct mydata *) m-&gt;data;&n; *&n; *      &t;if (...matching goes here...)&n; *      &t;&t;return 1;&n; *      &t;else&n; *      &t;&t;return 0;&n; *      }&n; *&n; *   2) Fill out a struct tcf_ematch_ops:&n; *      static struct tcf_ematch_ops my_ops = {&n; *      &t;.kind = unique id,&n; *      &t;.datalen = sizeof(struct mydata),&n; *      &t;.match = my_match,&n; *      &t;.owner = THIS_MODULE,&n; *      };&n; *&n; *   3) Register/Unregister your ematch:&n; *      static int __init init_my_ematch(void)&n; *      {&n; *      &t;return tcf_em_register(&amp;my_ops);&n; *      }&n; *&n; *      static void __exit exit_my_ematch(void)&n; *      {&n; *      &t;return tcf_em_unregister(&amp;my_ops);&n; *      }&n; *&n; *      module_init(init_my_ematch);&n; *      module_exit(exit_my_ematch);&n; *&n; *   4) By now you should have two more seconds left, barely enough to&n; *      open up a beer to watch the compilation going.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/rtnetlink.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;net/pkt_cls.h&gt;
macro_line|#include &lt;config/net/ematch/stack.h&gt;
r_static
id|LIST_HEAD
c_func
(paren
id|ematch_ops
)paren
suffix:semicolon
r_static
id|DEFINE_RWLOCK
c_func
(paren
id|ematch_mod_lock
)paren
suffix:semicolon
DECL|function|tcf_em_lookup
r_static
r_inline
r_struct
id|tcf_ematch_ops
op_star
id|tcf_em_lookup
c_func
(paren
id|u16
id|kind
)paren
(brace
r_struct
id|tcf_ematch_ops
op_star
id|e
op_assign
l_int|NULL
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|ematch_mod_lock
)paren
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|e
comma
op_amp
id|ematch_ops
comma
id|link
)paren
(brace
r_if
c_cond
(paren
id|kind
op_eq
id|e-&gt;kind
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|try_module_get
c_func
(paren
id|e-&gt;owner
)paren
)paren
id|e
op_assign
l_int|NULL
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|ematch_mod_lock
)paren
suffix:semicolon
r_return
id|e
suffix:semicolon
)brace
)brace
id|read_unlock
c_func
(paren
op_amp
id|ematch_mod_lock
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/**&n; * tcf_em_register - register an extended match&n; * &n; * @ops: ematch operations lookup table&n; *&n; * This function must be called by ematches to announce their presence.&n; * The given @ops must have kind set to a unique identifier and the&n; * callback match() must be implemented. All other callbacks are optional&n; * and a fallback implementation is used instead.&n; *&n; * Returns -EEXISTS if an ematch of the same kind has already registered.&n; */
DECL|function|tcf_em_register
r_int
id|tcf_em_register
c_func
(paren
r_struct
id|tcf_ematch_ops
op_star
id|ops
)paren
(brace
r_int
id|err
op_assign
op_minus
id|EEXIST
suffix:semicolon
r_struct
id|tcf_ematch_ops
op_star
id|e
suffix:semicolon
r_if
c_cond
(paren
id|ops-&gt;match
op_eq
l_int|NULL
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|write_lock
c_func
(paren
op_amp
id|ematch_mod_lock
)paren
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|e
comma
op_amp
id|ematch_ops
comma
id|link
)paren
r_if
c_cond
(paren
id|ops-&gt;kind
op_eq
id|e-&gt;kind
)paren
r_goto
id|errout
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|ops-&gt;link
comma
op_amp
id|ematch_ops
)paren
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
id|errout
suffix:colon
id|write_unlock
c_func
(paren
op_amp
id|ematch_mod_lock
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/**&n; * tcf_em_unregister - unregster and extended match&n; *&n; * @ops: ematch operations lookup table&n; *&n; * This function must be called by ematches to announce their disappearance&n; * for examples when the module gets unloaded. The @ops parameter must be&n; * the same as the one used for registration.&n; *&n; * Returns -ENOENT if no matching ematch was found.&n; */
DECL|function|tcf_em_unregister
r_int
id|tcf_em_unregister
c_func
(paren
r_struct
id|tcf_ematch_ops
op_star
id|ops
)paren
(brace
r_int
id|err
op_assign
l_int|0
suffix:semicolon
r_struct
id|tcf_ematch_ops
op_star
id|e
suffix:semicolon
id|write_lock
c_func
(paren
op_amp
id|ematch_mod_lock
)paren
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|e
comma
op_amp
id|ematch_ops
comma
id|link
)paren
(brace
r_if
c_cond
(paren
id|e
op_eq
id|ops
)paren
(brace
id|list_del
c_func
(paren
op_amp
id|e-&gt;link
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
)brace
id|err
op_assign
op_minus
id|ENOENT
suffix:semicolon
id|out
suffix:colon
id|write_unlock
c_func
(paren
op_amp
id|ematch_mod_lock
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|function|tcf_em_get_match
r_static
r_inline
r_struct
id|tcf_ematch
op_star
id|tcf_em_get_match
c_func
(paren
r_struct
id|tcf_ematch_tree
op_star
id|tree
comma
r_int
id|index
)paren
(brace
r_return
op_amp
id|tree-&gt;matches
(braket
id|index
)braket
suffix:semicolon
)brace
DECL|function|tcf_em_validate
r_static
r_int
id|tcf_em_validate
c_func
(paren
r_struct
id|tcf_proto
op_star
id|tp
comma
r_struct
id|tcf_ematch_tree_hdr
op_star
id|tree_hdr
comma
r_struct
id|tcf_ematch
op_star
id|em
comma
r_struct
id|rtattr
op_star
id|rta
comma
r_int
id|idx
)paren
(brace
r_int
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_struct
id|tcf_ematch_hdr
op_star
id|em_hdr
op_assign
id|RTA_DATA
c_func
(paren
id|rta
)paren
suffix:semicolon
r_int
id|data_len
op_assign
id|RTA_PAYLOAD
c_func
(paren
id|rta
)paren
op_minus
r_sizeof
(paren
op_star
id|em_hdr
)paren
suffix:semicolon
r_void
op_star
id|data
op_assign
(paren
r_void
op_star
)paren
id|em_hdr
op_plus
r_sizeof
(paren
op_star
id|em_hdr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|TCF_EM_REL_VALID
c_func
(paren
id|em_hdr-&gt;flags
)paren
)paren
r_goto
id|errout
suffix:semicolon
r_if
c_cond
(paren
id|em_hdr-&gt;kind
op_eq
id|TCF_EM_CONTAINER
)paren
(brace
multiline_comment|/* Special ematch called &quot;container&quot;, carries an index&n;&t;&t; * referencing an external ematch sequence. */
id|u32
id|ref
suffix:semicolon
r_if
c_cond
(paren
id|data_len
OL
r_sizeof
(paren
id|ref
)paren
)paren
r_goto
id|errout
suffix:semicolon
id|ref
op_assign
op_star
(paren
id|u32
op_star
)paren
id|data
suffix:semicolon
r_if
c_cond
(paren
id|ref
op_ge
id|tree_hdr-&gt;nmatches
)paren
r_goto
id|errout
suffix:semicolon
multiline_comment|/* We do not allow backward jumps to avoid loops and jumps&n;&t;&t; * to our own position are of course illegal. */
r_if
c_cond
(paren
id|ref
op_le
id|idx
)paren
r_goto
id|errout
suffix:semicolon
id|em-&gt;data
op_assign
id|ref
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Note: This lookup will increase the module refcnt&n;&t;&t; * of the ematch module referenced. In case of a failure,&n;&t;&t; * a destroy function is called by the underlying layer&n;&t;&t; * which automatically releases the reference again, therefore&n;&t;&t; * the module MUST not be given back under any circumstances&n;&t;&t; * here. Be aware, the destroy function assumes that the&n;&t;&t; * module is held if the ops field is non zero. */
id|em-&gt;ops
op_assign
id|tcf_em_lookup
c_func
(paren
id|em_hdr-&gt;kind
)paren
suffix:semicolon
r_if
c_cond
(paren
id|em-&gt;ops
op_eq
l_int|NULL
)paren
(brace
id|err
op_assign
op_minus
id|ENOENT
suffix:semicolon
r_goto
id|errout
suffix:semicolon
)brace
multiline_comment|/* ematch module provides expected length of data, so we&n;&t;&t; * can do a basic sanity check. */
r_if
c_cond
(paren
id|em-&gt;ops-&gt;datalen
op_logical_and
id|data_len
OL
id|em-&gt;ops-&gt;datalen
)paren
r_goto
id|errout
suffix:semicolon
r_if
c_cond
(paren
id|em-&gt;ops-&gt;change
)paren
(brace
id|err
op_assign
id|em-&gt;ops
op_member_access_from_pointer
id|change
c_func
(paren
id|tp
comma
id|data
comma
id|data_len
comma
id|em
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_goto
id|errout
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|data_len
OG
l_int|0
)paren
(brace
multiline_comment|/* ematch module doesn&squot;t provide an own change&n;&t;&t;&t; * procedure and expects us to allocate and copy&n;&t;&t;&t; * the ematch data.&n;&t;&t;&t; *&n;&t;&t;&t; * TCF_EM_SIMPLE may be specified stating that the&n;&t;&t;&t; * data only consists of a u32 integer and the module&n;&t;&t;&t; * does not expected a memory reference but rather&n;&t;&t;&t; * the value carried. */
r_if
c_cond
(paren
id|em_hdr-&gt;flags
op_amp
id|TCF_EM_SIMPLE
)paren
(brace
r_if
c_cond
(paren
id|data_len
OL
r_sizeof
(paren
id|u32
)paren
)paren
r_goto
id|errout
suffix:semicolon
id|em-&gt;data
op_assign
op_star
(paren
id|u32
op_star
)paren
id|data
suffix:semicolon
)brace
r_else
(brace
r_void
op_star
id|v
op_assign
id|kmalloc
c_func
(paren
id|data_len
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|v
op_eq
l_int|NULL
)paren
(brace
id|err
op_assign
op_minus
id|ENOBUFS
suffix:semicolon
r_goto
id|errout
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|v
comma
id|data
comma
id|data_len
)paren
suffix:semicolon
id|em-&gt;data
op_assign
(paren
r_int
r_int
)paren
id|v
suffix:semicolon
)brace
)brace
)brace
id|em-&gt;matchid
op_assign
id|em_hdr-&gt;matchid
suffix:semicolon
id|em-&gt;flags
op_assign
id|em_hdr-&gt;flags
suffix:semicolon
id|em-&gt;datalen
op_assign
id|data_len
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
id|errout
suffix:colon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/**&n; * tcf_em_tree_validate - validate ematch config TLV and build ematch tree&n; *&n; * @tp: classifier kind handle&n; * @rta: ematch tree configuration TLV&n; * @tree: destination ematch tree variable to store the resulting&n; *        ematch tree.&n; *&n; * This function validates the given configuration TLV @rta and builds an&n; * ematch tree in @tree. The resulting tree must later be copied into&n; * the private classifier data using tcf_em_tree_change(). You MUST NOT&n; * provide the ematch tree variable of the private classifier data directly,&n; * the changes would not be locked properly.&n; *&n; * Returns a negative error code if the configuration TLV contains errors.&n; */
DECL|function|tcf_em_tree_validate
r_int
id|tcf_em_tree_validate
c_func
(paren
r_struct
id|tcf_proto
op_star
id|tp
comma
r_struct
id|rtattr
op_star
id|rta
comma
r_struct
id|tcf_ematch_tree
op_star
id|tree
)paren
(brace
r_int
id|idx
comma
id|list_len
comma
id|matches_len
comma
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_struct
id|rtattr
op_star
id|tb
(braket
id|TCA_EMATCH_TREE_MAX
)braket
suffix:semicolon
r_struct
id|rtattr
op_star
id|rt_match
comma
op_star
id|rt_hdr
comma
op_star
id|rt_list
suffix:semicolon
r_struct
id|tcf_ematch_tree_hdr
op_star
id|tree_hdr
suffix:semicolon
r_struct
id|tcf_ematch
op_star
id|em
suffix:semicolon
r_if
c_cond
(paren
id|rtattr_parse_nested
c_func
(paren
id|tb
comma
id|TCA_EMATCH_TREE_MAX
comma
id|rta
)paren
OL
l_int|0
)paren
r_goto
id|errout
suffix:semicolon
id|rt_hdr
op_assign
id|tb
(braket
id|TCA_EMATCH_TREE_HDR
op_minus
l_int|1
)braket
suffix:semicolon
id|rt_list
op_assign
id|tb
(braket
id|TCA_EMATCH_TREE_LIST
op_minus
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
id|rt_hdr
op_eq
l_int|NULL
op_logical_or
id|rt_list
op_eq
l_int|NULL
)paren
r_goto
id|errout
suffix:semicolon
r_if
c_cond
(paren
id|RTA_PAYLOAD
c_func
(paren
id|rt_hdr
)paren
OL
r_sizeof
(paren
op_star
id|tree_hdr
)paren
op_logical_or
id|RTA_PAYLOAD
c_func
(paren
id|rt_list
)paren
OL
r_sizeof
(paren
op_star
id|rt_match
)paren
)paren
r_goto
id|errout
suffix:semicolon
id|tree_hdr
op_assign
id|RTA_DATA
c_func
(paren
id|rt_hdr
)paren
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|tree-&gt;hdr
comma
id|tree_hdr
comma
r_sizeof
(paren
op_star
id|tree_hdr
)paren
)paren
suffix:semicolon
id|rt_match
op_assign
id|RTA_DATA
c_func
(paren
id|rt_list
)paren
suffix:semicolon
id|list_len
op_assign
id|RTA_PAYLOAD
c_func
(paren
id|rt_list
)paren
suffix:semicolon
id|matches_len
op_assign
id|tree_hdr-&gt;nmatches
op_star
r_sizeof
(paren
op_star
id|em
)paren
suffix:semicolon
id|tree-&gt;matches
op_assign
id|kmalloc
c_func
(paren
id|matches_len
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tree-&gt;matches
op_eq
l_int|NULL
)paren
r_goto
id|errout
suffix:semicolon
id|memset
c_func
(paren
id|tree-&gt;matches
comma
l_int|0
comma
id|matches_len
)paren
suffix:semicolon
multiline_comment|/* We do not use rtattr_parse_nested here because the maximum&n;&t; * number of attributes is unknown. This saves us the allocation&n;&t; * for a tb buffer which would serve no purpose at all.&n;&t; * &n;&t; * The array of rt attributes is parsed in the order as they are&n;&t; * provided, their type must be incremental from 1 to n. Even&n;&t; * if it does not serve any real purpose, a failure of sticking&n;&t; * to this policy will result in parsing failure. */
r_for
c_loop
(paren
id|idx
op_assign
l_int|0
suffix:semicolon
id|RTA_OK
c_func
(paren
id|rt_match
comma
id|list_len
)paren
suffix:semicolon
id|idx
op_increment
)paren
(brace
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|rt_match-&gt;rta_type
op_ne
(paren
id|idx
op_plus
l_int|1
)paren
)paren
r_goto
id|errout_abort
suffix:semicolon
r_if
c_cond
(paren
id|idx
op_ge
id|tree_hdr-&gt;nmatches
)paren
r_goto
id|errout_abort
suffix:semicolon
r_if
c_cond
(paren
id|RTA_PAYLOAD
c_func
(paren
id|rt_match
)paren
OL
r_sizeof
(paren
r_struct
id|tcf_ematch_hdr
)paren
)paren
r_goto
id|errout_abort
suffix:semicolon
id|em
op_assign
id|tcf_em_get_match
c_func
(paren
id|tree
comma
id|idx
)paren
suffix:semicolon
id|err
op_assign
id|tcf_em_validate
c_func
(paren
id|tp
comma
id|tree_hdr
comma
id|em
comma
id|rt_match
comma
id|idx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_goto
id|errout_abort
suffix:semicolon
id|rt_match
op_assign
id|RTA_NEXT
c_func
(paren
id|rt_match
comma
id|list_len
)paren
suffix:semicolon
)brace
multiline_comment|/* Check if the number of matches provided by userspace actually&n;&t; * complies with the array of matches. The number was used for&n;&t; * the validation of references and a mismatch could lead to&n;&t; * undefined references during the matching process. */
r_if
c_cond
(paren
id|idx
op_ne
id|tree_hdr-&gt;nmatches
)paren
(brace
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|errout_abort
suffix:semicolon
)brace
id|err
op_assign
l_int|0
suffix:semicolon
id|errout
suffix:colon
r_return
id|err
suffix:semicolon
id|errout_abort
suffix:colon
id|tcf_em_tree_destroy
c_func
(paren
id|tp
comma
id|tree
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/**&n; * tcf_em_tree_destroy - destroy an ematch tree&n; *&n; * @tp: classifier kind handle&n; * @tree: ematch tree to be deleted&n; *&n; * This functions destroys an ematch tree previously created by&n; * tcf_em_tree_validate()/tcf_em_tree_change(). You must ensure that&n; * the ematch tree is not in use before calling this function.&n; */
DECL|function|tcf_em_tree_destroy
r_void
id|tcf_em_tree_destroy
c_func
(paren
r_struct
id|tcf_proto
op_star
id|tp
comma
r_struct
id|tcf_ematch_tree
op_star
id|tree
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|tree-&gt;matches
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|tree-&gt;hdr.nmatches
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|tcf_ematch
op_star
id|em
op_assign
id|tcf_em_get_match
c_func
(paren
id|tree
comma
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|em-&gt;ops
)paren
(brace
r_if
c_cond
(paren
id|em-&gt;ops-&gt;destroy
)paren
id|em-&gt;ops
op_member_access_from_pointer
id|destroy
c_func
(paren
id|tp
comma
id|em
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|tcf_em_is_simple
c_func
(paren
id|em
)paren
op_logical_and
id|em-&gt;data
)paren
id|kfree
c_func
(paren
(paren
r_void
op_star
)paren
id|em-&gt;data
)paren
suffix:semicolon
id|module_put
c_func
(paren
id|em-&gt;ops-&gt;owner
)paren
suffix:semicolon
)brace
)brace
id|tree-&gt;hdr.nmatches
op_assign
l_int|0
suffix:semicolon
id|kfree
c_func
(paren
id|tree-&gt;matches
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * tcf_em_tree_dump - dump ematch tree into a rtnl message&n; *&n; * @skb: skb holding the rtnl message&n; * @t: ematch tree to be dumped&n; * @tlv: TLV type to be used to encapsulate the tree&n; *&n; * This function dumps a ematch tree into a rtnl message. It is valid to&n; * call this function while the ematch tree is in use.&n; *&n; * Returns -1 if the skb tailroom is insufficient.&n; */
DECL|function|tcf_em_tree_dump
r_int
id|tcf_em_tree_dump
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|tcf_ematch_tree
op_star
id|tree
comma
r_int
id|tlv
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|rtattr
op_star
id|top_start
op_assign
(paren
r_struct
id|rtattr
op_star
)paren
id|skb-&gt;tail
suffix:semicolon
r_struct
id|rtattr
op_star
id|list_start
suffix:semicolon
id|RTA_PUT
c_func
(paren
id|skb
comma
id|tlv
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
id|RTA_PUT
c_func
(paren
id|skb
comma
id|TCA_EMATCH_TREE_HDR
comma
r_sizeof
(paren
id|tree-&gt;hdr
)paren
comma
op_amp
id|tree-&gt;hdr
)paren
suffix:semicolon
id|list_start
op_assign
(paren
r_struct
id|rtattr
op_star
)paren
id|skb-&gt;tail
suffix:semicolon
id|RTA_PUT
c_func
(paren
id|skb
comma
id|TCA_EMATCH_TREE_LIST
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|tree-&gt;hdr.nmatches
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|rtattr
op_star
id|match_start
op_assign
(paren
r_struct
id|rtattr
op_star
)paren
id|skb-&gt;tail
suffix:semicolon
r_struct
id|tcf_ematch
op_star
id|em
op_assign
id|tcf_em_get_match
c_func
(paren
id|tree
comma
id|i
)paren
suffix:semicolon
r_struct
id|tcf_ematch_hdr
id|em_hdr
op_assign
(brace
dot
id|kind
op_assign
id|em-&gt;ops
ques
c_cond
id|em-&gt;ops-&gt;kind
suffix:colon
id|TCF_EM_CONTAINER
comma
dot
id|matchid
op_assign
id|em-&gt;matchid
comma
dot
id|flags
op_assign
id|em-&gt;flags
)brace
suffix:semicolon
id|RTA_PUT
c_func
(paren
id|skb
comma
id|i
op_plus
l_int|1
comma
r_sizeof
(paren
id|em_hdr
)paren
comma
op_amp
id|em_hdr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|em-&gt;ops
op_logical_and
id|em-&gt;ops-&gt;dump
)paren
(brace
r_if
c_cond
(paren
id|em-&gt;ops
op_member_access_from_pointer
id|dump
c_func
(paren
id|skb
comma
id|em
)paren
OL
l_int|0
)paren
r_goto
id|rtattr_failure
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|tcf_em_is_container
c_func
(paren
id|em
)paren
op_logical_or
id|tcf_em_is_simple
c_func
(paren
id|em
)paren
)paren
(brace
id|u32
id|u
op_assign
id|em-&gt;data
suffix:semicolon
id|RTA_PUT_NOHDR
c_func
(paren
id|skb
comma
r_sizeof
(paren
id|u
)paren
comma
op_amp
id|u
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|em-&gt;datalen
OG
l_int|0
)paren
id|RTA_PUT_NOHDR
c_func
(paren
id|skb
comma
id|em-&gt;datalen
comma
(paren
r_void
op_star
)paren
id|em-&gt;data
)paren
suffix:semicolon
id|match_start-&gt;rta_len
op_assign
id|skb-&gt;tail
op_minus
(paren
id|u8
op_star
)paren
id|match_start
suffix:semicolon
)brace
id|list_start-&gt;rta_len
op_assign
id|skb-&gt;tail
op_minus
(paren
id|u8
op_star
)paren
id|list_start
suffix:semicolon
id|top_start-&gt;rta_len
op_assign
id|skb-&gt;tail
op_minus
(paren
id|u8
op_star
)paren
id|top_start
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|rtattr_failure
suffix:colon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
DECL|function|tcf_em_match
r_static
r_inline
r_int
id|tcf_em_match
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|tcf_ematch
op_star
id|em
comma
r_struct
id|tcf_pkt_info
op_star
id|info
)paren
(brace
r_int
id|r
op_assign
id|em-&gt;ops
op_member_access_from_pointer
id|match
c_func
(paren
id|skb
comma
id|em
comma
id|info
)paren
suffix:semicolon
r_return
id|tcf_em_is_inverted
c_func
(paren
id|em
)paren
ques
c_cond
op_logical_neg
id|r
suffix:colon
id|r
suffix:semicolon
)brace
multiline_comment|/* Do not use this function directly, use tcf_em_tree_match instead */
DECL|function|__tcf_em_tree_match
r_int
id|__tcf_em_tree_match
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|tcf_ematch_tree
op_star
id|tree
comma
r_struct
id|tcf_pkt_info
op_star
id|info
)paren
(brace
r_int
id|stackp
op_assign
l_int|0
comma
id|match_idx
op_assign
l_int|0
comma
id|res
op_assign
l_int|0
suffix:semicolon
r_struct
id|tcf_ematch
op_star
id|cur_match
suffix:semicolon
r_int
id|stack
(braket
id|CONFIG_NET_EMATCH_STACK
)braket
suffix:semicolon
id|proceed
suffix:colon
r_while
c_loop
(paren
id|match_idx
OL
id|tree-&gt;hdr.nmatches
)paren
(brace
id|cur_match
op_assign
id|tcf_em_get_match
c_func
(paren
id|tree
comma
id|match_idx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tcf_em_is_container
c_func
(paren
id|cur_match
)paren
)paren
(brace
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|stackp
op_ge
id|CONFIG_NET_EMATCH_STACK
)paren
)paren
r_goto
id|stack_overflow
suffix:semicolon
id|stack
(braket
id|stackp
op_increment
)braket
op_assign
id|match_idx
suffix:semicolon
id|match_idx
op_assign
id|cur_match-&gt;data
suffix:semicolon
r_goto
id|proceed
suffix:semicolon
)brace
id|res
op_assign
id|tcf_em_match
c_func
(paren
id|skb
comma
id|cur_match
comma
id|info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tcf_em_early_end
c_func
(paren
id|cur_match
comma
id|res
)paren
)paren
r_break
suffix:semicolon
id|match_idx
op_increment
suffix:semicolon
)brace
id|pop_stack
suffix:colon
r_if
c_cond
(paren
id|stackp
OG
l_int|0
)paren
(brace
id|match_idx
op_assign
id|stack
(braket
op_decrement
id|stackp
)braket
suffix:semicolon
id|cur_match
op_assign
id|tcf_em_get_match
c_func
(paren
id|tree
comma
id|match_idx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tcf_em_early_end
c_func
(paren
id|cur_match
comma
id|res
)paren
)paren
r_goto
id|pop_stack
suffix:semicolon
r_else
(brace
id|match_idx
op_increment
suffix:semicolon
r_goto
id|proceed
suffix:semicolon
)brace
)brace
r_return
id|res
suffix:semicolon
id|stack_overflow
suffix:colon
r_if
c_cond
(paren
id|net_ratelimit
c_func
(paren
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;Local stack overflow, increase NET_EMATCH_STACK&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
DECL|variable|tcf_em_register
id|EXPORT_SYMBOL
c_func
(paren
id|tcf_em_register
)paren
suffix:semicolon
DECL|variable|tcf_em_unregister
id|EXPORT_SYMBOL
c_func
(paren
id|tcf_em_unregister
)paren
suffix:semicolon
DECL|variable|tcf_em_tree_validate
id|EXPORT_SYMBOL
c_func
(paren
id|tcf_em_tree_validate
)paren
suffix:semicolon
DECL|variable|tcf_em_tree_destroy
id|EXPORT_SYMBOL
c_func
(paren
id|tcf_em_tree_destroy
)paren
suffix:semicolon
DECL|variable|tcf_em_tree_dump
id|EXPORT_SYMBOL
c_func
(paren
id|tcf_em_tree_dump
)paren
suffix:semicolon
DECL|variable|__tcf_em_tree_match
id|EXPORT_SYMBOL
c_func
(paren
id|__tcf_em_tree_match
)paren
suffix:semicolon
eof
