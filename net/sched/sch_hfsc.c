multiline_comment|/*&n; * Copyright (c) 2003 Patrick McHardy, &lt;kaber@trash.net&gt;&n; *&n; * This program is free software; you can redistribute it and/or&n; * modify it under the terms of the GNU General Public License&n; * as published by the Free Software Foundation; either version 2&n; * of the License, or (at your option) any later version.&n; *&n; * 2003-10-17 - Ported from altq&n; */
multiline_comment|/*&n; * Copyright (c) 1997-1999 Carnegie Mellon University. All Rights Reserved.&n; *&n; * Permission to use, copy, modify, and distribute this software and&n; * its documentation is hereby granted (including for commercial or&n; * for-profit use), provided that both the copyright notice and this&n; * permission notice appear in all copies of the software, derivative&n; * works, or modified versions, and any portions thereof.&n; *&n; * THIS SOFTWARE IS EXPERIMENTAL AND IS KNOWN TO HAVE BUGS, SOME OF&n; * WHICH MAY HAVE SERIOUS CONSEQUENCES.  CARNEGIE MELLON PROVIDES THIS&n; * SOFTWARE IN ITS ``AS IS&squot;&squot; CONDITION, AND ANY EXPRESS OR IMPLIED&n; * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES&n; * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE&n; * DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE&n; * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR&n; * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT&n; * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR&n; * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF&n; * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT&n; * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE&n; * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH&n; * DAMAGE.&n; *&n; * Carnegie Mellon encourages (but does not require) users of this&n; * software to return any improvements or extensions that they make,&n; * and to grant Carnegie Mellon the rights to redistribute these&n; * changes without encumbrance.&n; */
multiline_comment|/*&n; * H-FSC is described in Proceedings of SIGCOMM&squot;97,&n; * &quot;A Hierarchical Fair Service Curve Algorithm for Link-Sharing,&n; * Real-Time and Priority Service&quot;&n; * by Ion Stoica, Hui Zhang, and T. S. Eugene Ng.&n; *&n; * Oleg Cherevko &lt;olwi@aq.ml.com.ua&gt; added the upperlimit for link-sharing.&n; * when a class has an upperlimit, the fit-time is computed from the&n; * upperlimit service curve.  the link-sharing scheduler does not schedule&n; * a class whose fit-time exceeds the current time.&n; */
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/jiffies.h&gt;
macro_line|#include &lt;linux/compiler.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/list.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/rtnetlink.h&gt;
macro_line|#include &lt;linux/pkt_sched.h&gt;
macro_line|#include &lt;net/pkt_sched.h&gt;
macro_line|#include &lt;net/pkt_cls.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/div64.h&gt;
DECL|macro|HFSC_DEBUG
mdefine_line|#define HFSC_DEBUG 1
multiline_comment|/*&n; * kernel internal service curve representation:&n; *   coordinates are given by 64 bit unsigned integers.&n; *   x-axis: unit is clock count.&n; *   y-axis: unit is byte.&n; *&n; *   The service curve parameters are converted to the internal&n; *   representation. The slope values are scaled to avoid overflow.&n; *   the inverse slope values as well as the y-projection of the 1st&n; *   segment are kept in order to to avoid 64-bit divide operations&n; *   that are expensive on 32-bit architectures.&n; */
DECL|struct|internal_sc
r_struct
id|internal_sc
(brace
DECL|member|sm1
id|u64
id|sm1
suffix:semicolon
multiline_comment|/* scaled slope of the 1st segment */
DECL|member|ism1
id|u64
id|ism1
suffix:semicolon
multiline_comment|/* scaled inverse-slope of the 1st segment */
DECL|member|dx
id|u64
id|dx
suffix:semicolon
multiline_comment|/* the x-projection of the 1st segment */
DECL|member|dy
id|u64
id|dy
suffix:semicolon
multiline_comment|/* the y-projection of the 1st segment */
DECL|member|sm2
id|u64
id|sm2
suffix:semicolon
multiline_comment|/* scaled slope of the 2nd segment */
DECL|member|ism2
id|u64
id|ism2
suffix:semicolon
multiline_comment|/* scaled inverse-slope of the 2nd segment */
)brace
suffix:semicolon
multiline_comment|/* runtime service curve */
DECL|struct|runtime_sc
r_struct
id|runtime_sc
(brace
DECL|member|x
id|u64
id|x
suffix:semicolon
multiline_comment|/* current starting position on x-axis */
DECL|member|y
id|u64
id|y
suffix:semicolon
multiline_comment|/* current starting position on y-axis */
DECL|member|sm1
id|u64
id|sm1
suffix:semicolon
multiline_comment|/* scaled slope of the 1st segment */
DECL|member|ism1
id|u64
id|ism1
suffix:semicolon
multiline_comment|/* scaled inverse-slope of the 1st segment */
DECL|member|dx
id|u64
id|dx
suffix:semicolon
multiline_comment|/* the x-projection of the 1st segment */
DECL|member|dy
id|u64
id|dy
suffix:semicolon
multiline_comment|/* the y-projection of the 1st segment */
DECL|member|sm2
id|u64
id|sm2
suffix:semicolon
multiline_comment|/* scaled slope of the 2nd segment */
DECL|member|ism2
id|u64
id|ism2
suffix:semicolon
multiline_comment|/* scaled inverse-slope of the 2nd segment */
)brace
suffix:semicolon
DECL|enum|hfsc_class_flags
r_enum
id|hfsc_class_flags
(brace
DECL|enumerator|HFSC_RSC
id|HFSC_RSC
op_assign
l_int|0x1
comma
DECL|enumerator|HFSC_FSC
id|HFSC_FSC
op_assign
l_int|0x2
comma
DECL|enumerator|HFSC_USC
id|HFSC_USC
op_assign
l_int|0x4
)brace
suffix:semicolon
DECL|struct|hfsc_class
r_struct
id|hfsc_class
(brace
DECL|member|classid
id|u32
id|classid
suffix:semicolon
multiline_comment|/* class id */
DECL|member|refcnt
r_int
r_int
id|refcnt
suffix:semicolon
multiline_comment|/* usage count */
DECL|member|stats
r_struct
id|tc_stats
id|stats
suffix:semicolon
multiline_comment|/* generic statistics */
DECL|member|level
r_int
r_int
id|level
suffix:semicolon
multiline_comment|/* class level in hierarchy */
DECL|member|filter_list
r_struct
id|tcf_proto
op_star
id|filter_list
suffix:semicolon
multiline_comment|/* filter list */
DECL|member|filter_cnt
r_int
r_int
id|filter_cnt
suffix:semicolon
multiline_comment|/* filter count */
DECL|member|sched
r_struct
id|hfsc_sched
op_star
id|sched
suffix:semicolon
multiline_comment|/* scheduler data */
DECL|member|cl_parent
r_struct
id|hfsc_class
op_star
id|cl_parent
suffix:semicolon
multiline_comment|/* parent class */
DECL|member|siblings
r_struct
id|list_head
id|siblings
suffix:semicolon
multiline_comment|/* sibling classes */
DECL|member|children
r_struct
id|list_head
id|children
suffix:semicolon
multiline_comment|/* child classes */
DECL|member|qdisc
r_struct
id|Qdisc
op_star
id|qdisc
suffix:semicolon
multiline_comment|/* leaf qdisc */
DECL|member|actlist
r_struct
id|list_head
id|actlist
suffix:semicolon
multiline_comment|/* active children list */
DECL|member|alist
r_struct
id|list_head
id|alist
suffix:semicolon
multiline_comment|/* active children list member */
DECL|member|ellist
r_struct
id|list_head
id|ellist
suffix:semicolon
multiline_comment|/* eligible list member */
DECL|member|hlist
r_struct
id|list_head
id|hlist
suffix:semicolon
multiline_comment|/* hash list member */
DECL|member|dlist
r_struct
id|list_head
id|dlist
suffix:semicolon
multiline_comment|/* drop list member */
DECL|member|cl_total
id|u64
id|cl_total
suffix:semicolon
multiline_comment|/* total work in bytes */
DECL|member|cl_cumul
id|u64
id|cl_cumul
suffix:semicolon
multiline_comment|/* cumulative work in bytes done by&n;&t;&t;&t;&t;&t;   real-time criteria */
DECL|member|cl_d
id|u64
id|cl_d
suffix:semicolon
multiline_comment|/* deadline*/
DECL|member|cl_e
id|u64
id|cl_e
suffix:semicolon
multiline_comment|/* eligible time */
DECL|member|cl_vt
id|u64
id|cl_vt
suffix:semicolon
multiline_comment|/* virtual time */
DECL|member|cl_f
id|u64
id|cl_f
suffix:semicolon
multiline_comment|/* time when this class will fit for&n;&t;&t;&t;&t;&t;   link-sharing, max(myf, cfmin) */
DECL|member|cl_myf
id|u64
id|cl_myf
suffix:semicolon
multiline_comment|/* my fit-time (calculated from this&n;&t;&t;&t;&t;&t;   class&squot;s own upperlimit curve) */
DECL|member|cl_myfadj
id|u64
id|cl_myfadj
suffix:semicolon
multiline_comment|/* my fit-time adjustment (to cancel&n;&t;&t;&t;&t;&t;   history dependence) */
DECL|member|cl_cfmin
id|u64
id|cl_cfmin
suffix:semicolon
multiline_comment|/* earliest children&squot;s fit-time (used&n;&t;&t;&t;&t;&t;   with cl_myf to obtain cl_f) */
DECL|member|cl_cvtmin
id|u64
id|cl_cvtmin
suffix:semicolon
multiline_comment|/* minimal virtual time among the&n;&t;&t;&t;&t;&t;   children fit for link-sharing&n;&t;&t;&t;&t;&t;   (monotonic within a period) */
DECL|member|cl_vtadj
id|u64
id|cl_vtadj
suffix:semicolon
multiline_comment|/* intra-period cumulative vt&n;&t;&t;&t;&t;&t;   adjustment */
DECL|member|cl_vtoff
id|u64
id|cl_vtoff
suffix:semicolon
multiline_comment|/* inter-period cumulative vt offset */
DECL|member|cl_cvtmax
id|u64
id|cl_cvtmax
suffix:semicolon
multiline_comment|/* max child&squot;s vt in the last period */
DECL|member|cl_rsc
r_struct
id|internal_sc
id|cl_rsc
suffix:semicolon
multiline_comment|/* internal real-time service curve */
DECL|member|cl_fsc
r_struct
id|internal_sc
id|cl_fsc
suffix:semicolon
multiline_comment|/* internal fair service curve */
DECL|member|cl_usc
r_struct
id|internal_sc
id|cl_usc
suffix:semicolon
multiline_comment|/* internal upperlimit service curve */
DECL|member|cl_deadline
r_struct
id|runtime_sc
id|cl_deadline
suffix:semicolon
multiline_comment|/* deadline curve */
DECL|member|cl_eligible
r_struct
id|runtime_sc
id|cl_eligible
suffix:semicolon
multiline_comment|/* eligible curve */
DECL|member|cl_virtual
r_struct
id|runtime_sc
id|cl_virtual
suffix:semicolon
multiline_comment|/* virtual curve */
DECL|member|cl_ulimit
r_struct
id|runtime_sc
id|cl_ulimit
suffix:semicolon
multiline_comment|/* upperlimit curve */
DECL|member|cl_flags
r_int
r_int
id|cl_flags
suffix:semicolon
multiline_comment|/* which curves are valid */
DECL|member|cl_vtperiod
r_int
r_int
id|cl_vtperiod
suffix:semicolon
multiline_comment|/* vt period sequence number */
DECL|member|cl_parentperiod
r_int
r_int
id|cl_parentperiod
suffix:semicolon
multiline_comment|/* parent&squot;s vt period sequence number*/
DECL|member|cl_nactive
r_int
r_int
id|cl_nactive
suffix:semicolon
multiline_comment|/* number of active children */
)brace
suffix:semicolon
DECL|macro|HFSC_HSIZE
mdefine_line|#define HFSC_HSIZE&t;16
DECL|struct|hfsc_sched
r_struct
id|hfsc_sched
(brace
DECL|member|defcls
id|u16
id|defcls
suffix:semicolon
multiline_comment|/* default class id */
DECL|member|root
r_struct
id|hfsc_class
id|root
suffix:semicolon
multiline_comment|/* root class */
DECL|member|clhash
r_struct
id|list_head
id|clhash
(braket
id|HFSC_HSIZE
)braket
suffix:semicolon
multiline_comment|/* class hash */
DECL|member|eligible
r_struct
id|list_head
id|eligible
suffix:semicolon
multiline_comment|/* eligible list */
DECL|member|droplist
r_struct
id|list_head
id|droplist
suffix:semicolon
multiline_comment|/* active leaf class list (for&n;&t;&t;&t;&t;&t;&t;   dropping) */
DECL|member|requeue
r_struct
id|sk_buff_head
id|requeue
suffix:semicolon
multiline_comment|/* requeued packet */
DECL|member|wd_timer
r_struct
id|timer_list
id|wd_timer
suffix:semicolon
multiline_comment|/* watchdog timer */
)brace
suffix:semicolon
multiline_comment|/*&n; * macros&n; */
macro_line|#if PSCHED_CLOCK_SOURCE == PSCHED_GETTIMEOFDAY
macro_line|#include &lt;linux/time.h&gt;
DECL|macro|PSCHED_GET_TIME
macro_line|#undef PSCHED_GET_TIME
DECL|macro|PSCHED_GET_TIME
mdefine_line|#define PSCHED_GET_TIME(stamp)&t;&t;&t;&t;&t;&t;&bslash;&n;do {&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;struct timeval tv;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;do_gettimeofday(&amp;tv);&t;&t;&t;&t;&t;&t;&bslash;&n;&t;(stamp) = 1000000ULL * tv.tv_sec + tv.tv_usec;&t;&t;&t;&bslash;&n;} while (0)
macro_line|#endif
macro_line|#if HFSC_DEBUG
DECL|macro|ASSERT
mdefine_line|#define ASSERT(cond)&t;&t;&t;&t;&t;&t;&t;&bslash;&n;do {&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;if (unlikely(!(cond)))&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;printk(&quot;assertion %s failed at %s:%i (%s)&bslash;n&quot;,&t;&t;&bslash;&n;&t;&t;       #cond, __FILE__, __LINE__, __FUNCTION__);&t;&bslash;&n;} while (0)
macro_line|#else
DECL|macro|ASSERT
mdefine_line|#define ASSERT(cond)
macro_line|#endif /* HFSC_DEBUG */
DECL|macro|HT_INFINITY
mdefine_line|#define&t;HT_INFINITY&t;0xffffffffffffffffULL&t;/* infinite time value */
multiline_comment|/*&n; * eligible list holds backlogged classes being sorted by their eligible times.&n; * there is one eligible list per hfsc instance.&n; */
r_static
r_void
DECL|function|ellist_insert
id|ellist_insert
c_func
(paren
r_struct
id|hfsc_class
op_star
id|cl
)paren
(brace
r_struct
id|list_head
op_star
id|head
op_assign
op_amp
id|cl-&gt;sched-&gt;eligible
suffix:semicolon
r_struct
id|hfsc_class
op_star
id|p
suffix:semicolon
multiline_comment|/* check the last entry first */
r_if
c_cond
(paren
id|list_empty
c_func
(paren
id|head
)paren
op_logical_or
(paren
(paren
id|p
op_assign
id|list_entry
c_func
(paren
id|head-&gt;prev
comma
r_struct
id|hfsc_class
comma
id|ellist
)paren
)paren
op_logical_and
id|p-&gt;cl_e
op_le
id|cl-&gt;cl_e
)paren
)paren
(brace
id|list_add_tail
c_func
(paren
op_amp
id|cl-&gt;ellist
comma
id|head
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|list_for_each_entry
c_func
(paren
id|p
comma
id|head
comma
id|ellist
)paren
(brace
r_if
c_cond
(paren
id|cl-&gt;cl_e
OL
id|p-&gt;cl_e
)paren
(brace
multiline_comment|/* insert cl before p */
id|list_add_tail
c_func
(paren
op_amp
id|cl-&gt;ellist
comma
op_amp
id|p-&gt;ellist
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
id|ASSERT
c_func
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* should not reach here */
)brace
r_static
r_inline
r_void
DECL|function|ellist_remove
id|ellist_remove
c_func
(paren
r_struct
id|hfsc_class
op_star
id|cl
)paren
(brace
id|list_del
c_func
(paren
op_amp
id|cl-&gt;ellist
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|ellist_update
id|ellist_update
c_func
(paren
r_struct
id|hfsc_class
op_star
id|cl
)paren
(brace
r_struct
id|list_head
op_star
id|head
op_assign
op_amp
id|cl-&gt;sched-&gt;eligible
suffix:semicolon
r_struct
id|hfsc_class
op_star
id|p
comma
op_star
id|last
suffix:semicolon
multiline_comment|/*&n;&t; * the eligible time of a class increases monotonically.&n;&t; * if the next entry has a larger eligible time, nothing to do.&n;&t; */
r_if
c_cond
(paren
id|cl-&gt;ellist.next
op_eq
id|head
op_logical_or
(paren
(paren
id|p
op_assign
id|list_entry
c_func
(paren
id|cl-&gt;ellist.next
comma
r_struct
id|hfsc_class
comma
id|ellist
)paren
)paren
op_logical_and
id|cl-&gt;cl_e
op_le
id|p-&gt;cl_e
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* check the last entry */
id|last
op_assign
id|list_entry
c_func
(paren
id|head-&gt;prev
comma
r_struct
id|hfsc_class
comma
id|ellist
)paren
suffix:semicolon
r_if
c_cond
(paren
id|last-&gt;cl_e
op_le
id|cl-&gt;cl_e
)paren
(brace
id|list_move_tail
c_func
(paren
op_amp
id|cl-&gt;ellist
comma
id|head
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * the new position must be between the next entry&n;&t; * and the last entry&n;&t; */
id|list_for_each_entry_continue
c_func
(paren
id|p
comma
id|head
comma
id|ellist
)paren
(brace
r_if
c_cond
(paren
id|cl-&gt;cl_e
OL
id|p-&gt;cl_e
)paren
(brace
id|list_move_tail
c_func
(paren
op_amp
id|cl-&gt;ellist
comma
op_amp
id|p-&gt;ellist
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
id|ASSERT
c_func
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* should not reach here */
)brace
multiline_comment|/* find the class with the minimum deadline among the eligible classes */
r_static
r_inline
r_struct
id|hfsc_class
op_star
DECL|function|ellist_get_mindl
id|ellist_get_mindl
c_func
(paren
r_struct
id|list_head
op_star
id|head
comma
id|u64
id|cur_time
)paren
(brace
r_struct
id|hfsc_class
op_star
id|p
comma
op_star
id|cl
op_assign
l_int|NULL
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|p
comma
id|head
comma
id|ellist
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;cl_e
OG
id|cur_time
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|cl
op_eq
l_int|NULL
op_logical_or
id|p-&gt;cl_d
OL
id|cl-&gt;cl_d
)paren
id|cl
op_assign
id|p
suffix:semicolon
)brace
r_return
id|cl
suffix:semicolon
)brace
multiline_comment|/* find the class with minimum eligible time among the eligible classes */
r_static
r_inline
r_struct
id|hfsc_class
op_star
DECL|function|ellist_get_minel
id|ellist_get_minel
c_func
(paren
r_struct
id|list_head
op_star
id|head
)paren
(brace
r_if
c_cond
(paren
id|list_empty
c_func
(paren
id|head
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
r_return
id|list_entry
c_func
(paren
id|head-&gt;next
comma
r_struct
id|hfsc_class
comma
id|ellist
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * active children list holds backlogged child classes being sorted&n; * by their virtual time. each intermediate class has one active&n; * children list.&n; */
r_static
r_void
DECL|function|actlist_insert
id|actlist_insert
c_func
(paren
r_struct
id|hfsc_class
op_star
id|cl
)paren
(brace
r_struct
id|list_head
op_star
id|head
op_assign
op_amp
id|cl-&gt;cl_parent-&gt;actlist
suffix:semicolon
r_struct
id|hfsc_class
op_star
id|p
suffix:semicolon
multiline_comment|/* check the last entry first */
r_if
c_cond
(paren
id|list_empty
c_func
(paren
id|head
)paren
op_logical_or
(paren
(paren
id|p
op_assign
id|list_entry
c_func
(paren
id|head-&gt;prev
comma
r_struct
id|hfsc_class
comma
id|alist
)paren
)paren
op_logical_and
id|p-&gt;cl_vt
op_le
id|cl-&gt;cl_vt
)paren
)paren
(brace
id|list_add_tail
c_func
(paren
op_amp
id|cl-&gt;alist
comma
id|head
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|list_for_each_entry
c_func
(paren
id|p
comma
id|head
comma
id|alist
)paren
(brace
r_if
c_cond
(paren
id|cl-&gt;cl_vt
OL
id|p-&gt;cl_vt
)paren
(brace
multiline_comment|/* insert cl before p */
id|list_add_tail
c_func
(paren
op_amp
id|cl-&gt;alist
comma
op_amp
id|p-&gt;alist
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
id|ASSERT
c_func
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* should not reach here */
)brace
r_static
r_inline
r_void
DECL|function|actlist_remove
id|actlist_remove
c_func
(paren
r_struct
id|hfsc_class
op_star
id|cl
)paren
(brace
id|list_del
c_func
(paren
op_amp
id|cl-&gt;alist
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|actlist_update
id|actlist_update
c_func
(paren
r_struct
id|hfsc_class
op_star
id|cl
)paren
(brace
r_struct
id|list_head
op_star
id|head
op_assign
op_amp
id|cl-&gt;cl_parent-&gt;actlist
suffix:semicolon
r_struct
id|hfsc_class
op_star
id|p
comma
op_star
id|last
suffix:semicolon
multiline_comment|/*&n;&t; * the virtual time of a class increases monotonically.&n;&t; * if the next entry has a larger virtual time, nothing to do.&n;&t; */
r_if
c_cond
(paren
id|cl-&gt;alist.next
op_eq
id|head
op_logical_or
(paren
(paren
id|p
op_assign
id|list_entry
c_func
(paren
id|cl-&gt;alist.next
comma
r_struct
id|hfsc_class
comma
id|alist
)paren
)paren
op_logical_and
id|cl-&gt;cl_vt
op_le
id|p-&gt;cl_vt
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* check the last entry */
id|last
op_assign
id|list_entry
c_func
(paren
id|head-&gt;prev
comma
r_struct
id|hfsc_class
comma
id|alist
)paren
suffix:semicolon
r_if
c_cond
(paren
id|last-&gt;cl_vt
op_le
id|cl-&gt;cl_vt
)paren
(brace
id|list_move_tail
c_func
(paren
op_amp
id|cl-&gt;alist
comma
id|head
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * the new position must be between the next entry&n;&t; * and the last entry&n;&t; */
id|list_for_each_entry_continue
c_func
(paren
id|p
comma
id|head
comma
id|alist
)paren
(brace
r_if
c_cond
(paren
id|cl-&gt;cl_vt
OL
id|p-&gt;cl_vt
)paren
(brace
id|list_move_tail
c_func
(paren
op_amp
id|cl-&gt;alist
comma
op_amp
id|p-&gt;alist
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
id|ASSERT
c_func
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* should not reach here */
)brace
r_static
r_inline
r_struct
id|hfsc_class
op_star
DECL|function|actlist_firstfit
id|actlist_firstfit
c_func
(paren
r_struct
id|hfsc_class
op_star
id|cl
comma
id|u64
id|cur_time
)paren
(brace
r_struct
id|hfsc_class
op_star
id|p
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|p
comma
op_amp
id|cl-&gt;actlist
comma
id|alist
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;cl_f
op_le
id|cur_time
)paren
(brace
r_return
id|p
suffix:semicolon
)brace
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * get the leaf class with the minimum vt in the hierarchy&n; */
r_static
r_struct
id|hfsc_class
op_star
DECL|function|actlist_get_minvt
id|actlist_get_minvt
c_func
(paren
r_struct
id|hfsc_class
op_star
id|cl
comma
id|u64
id|cur_time
)paren
(brace
multiline_comment|/* if root-class&squot;s cfmin is bigger than cur_time nothing to do */
r_if
c_cond
(paren
id|cl-&gt;cl_cfmin
OG
id|cur_time
)paren
r_return
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
id|cl-&gt;level
OG
l_int|0
)paren
(brace
id|cl
op_assign
id|actlist_firstfit
c_func
(paren
id|cl
comma
id|cur_time
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cl
op_eq
l_int|NULL
)paren
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t;&t; * update parent&squot;s cl_cvtmin.&n;&t;&t; */
r_if
c_cond
(paren
id|cl-&gt;cl_parent-&gt;cl_cvtmin
OL
id|cl-&gt;cl_vt
)paren
id|cl-&gt;cl_parent-&gt;cl_cvtmin
op_assign
id|cl-&gt;cl_vt
suffix:semicolon
)brace
r_return
id|cl
suffix:semicolon
)brace
multiline_comment|/*&n; * service curve support functions&n; *&n; *  external service curve parameters&n; *&t;m: bps&n; *&t;d: us&n; *  internal service curve parameters&n; *&t;sm: (bytes/psched_us) &lt;&lt; SM_SHIFT&n; *&t;ism: (psched_us/byte) &lt;&lt; ISM_SHIFT&n; *&t;dx: psched_us&n; *&n; * Time source resolution&n; *  PSCHED_JIFFIES: for 48&lt;=HZ&lt;=1534 resolution is between 0.63us and 1.27us.&n; *  PSCHED_CPU: resolution is between 0.5us and 1us.&n; *  PSCHED_GETTIMEOFDAY: resolution is exactly 1us.&n; *&n; * sm and ism are scaled in order to keep effective digits.&n; * SM_SHIFT and ISM_SHIFT are selected to keep at least 4 effective&n; * digits in decimal using the following table.&n; *&n; * Note: We can afford the additional accuracy (altq hfsc keeps at most&n; * 3 effective digits) thanks to the fact that linux clock is bounded&n; * much more tightly.&n; *&n; *  bits/sec      100Kbps     1Mbps     10Mbps     100Mbps    1Gbps&n; *  ------------+-------------------------------------------------------&n; *  bytes/0.5us   6.25e-3    62.5e-3    625e-3     6250e-e    62500e-3&n; *  bytes/us      12.5e-3    125e-3     1250e-3    12500e-3   125000e-3&n; *  bytes/1.27us  15.875e-3  158.75e-3  1587.5e-3  15875e-3   158750e-3&n; *&n; *  0.5us/byte    160        16         1.6        0.16       0.016&n; *  us/byte       80         8          0.8        0.08       0.008&n; *  1.27us/byte   63         6.3        0.63       0.063      0.0063&n; */
DECL|macro|SM_SHIFT
mdefine_line|#define&t;SM_SHIFT&t;20
DECL|macro|ISM_SHIFT
mdefine_line|#define&t;ISM_SHIFT&t;18
DECL|macro|SM_MASK
mdefine_line|#define&t;SM_MASK&t;&t;((1ULL &lt;&lt; SM_SHIFT) - 1)
DECL|macro|ISM_MASK
mdefine_line|#define&t;ISM_MASK&t;((1ULL &lt;&lt; ISM_SHIFT) - 1)
r_static
r_inline
id|u64
DECL|function|seg_x2y
id|seg_x2y
c_func
(paren
id|u64
id|x
comma
id|u64
id|sm
)paren
(brace
id|u64
id|y
suffix:semicolon
multiline_comment|/*&n;&t; * compute&n;&t; *&t;y = x * sm &gt;&gt; SM_SHIFT&n;&t; * but divide it for the upper and lower bits to avoid overflow&n;&t; */
id|y
op_assign
(paren
id|x
op_rshift
id|SM_SHIFT
)paren
op_star
id|sm
op_plus
(paren
(paren
(paren
id|x
op_amp
id|SM_MASK
)paren
op_star
id|sm
)paren
op_rshift
id|SM_SHIFT
)paren
suffix:semicolon
r_return
id|y
suffix:semicolon
)brace
r_static
r_inline
id|u64
DECL|function|seg_y2x
id|seg_y2x
c_func
(paren
id|u64
id|y
comma
id|u64
id|ism
)paren
(brace
id|u64
id|x
suffix:semicolon
r_if
c_cond
(paren
id|y
op_eq
l_int|0
)paren
id|x
op_assign
l_int|0
suffix:semicolon
r_else
r_if
c_cond
(paren
id|ism
op_eq
id|HT_INFINITY
)paren
id|x
op_assign
id|HT_INFINITY
suffix:semicolon
r_else
(brace
id|x
op_assign
(paren
id|y
op_rshift
id|ISM_SHIFT
)paren
op_star
id|ism
op_plus
(paren
(paren
(paren
id|y
op_amp
id|ISM_MASK
)paren
op_star
id|ism
)paren
op_rshift
id|ISM_SHIFT
)paren
suffix:semicolon
)brace
r_return
id|x
suffix:semicolon
)brace
multiline_comment|/* Convert m (bps) into sm (bytes/psched us) */
r_static
id|u64
DECL|function|m2sm
id|m2sm
c_func
(paren
id|u32
id|m
)paren
(brace
id|u64
id|sm
suffix:semicolon
id|sm
op_assign
(paren
(paren
id|u64
)paren
id|m
op_lshift
id|SM_SHIFT
)paren
suffix:semicolon
id|sm
op_add_assign
id|PSCHED_JIFFIE2US
c_func
(paren
id|HZ
)paren
op_minus
l_int|1
suffix:semicolon
id|do_div
c_func
(paren
id|sm
comma
id|PSCHED_JIFFIE2US
c_func
(paren
id|HZ
)paren
)paren
suffix:semicolon
r_return
id|sm
suffix:semicolon
)brace
multiline_comment|/* convert m (bps) into ism (psched us/byte) */
r_static
id|u64
DECL|function|m2ism
id|m2ism
c_func
(paren
id|u32
id|m
)paren
(brace
id|u64
id|ism
suffix:semicolon
r_if
c_cond
(paren
id|m
op_eq
l_int|0
)paren
id|ism
op_assign
id|HT_INFINITY
suffix:semicolon
r_else
(brace
id|ism
op_assign
(paren
(paren
id|u64
)paren
id|PSCHED_JIFFIE2US
c_func
(paren
id|HZ
)paren
op_lshift
id|ISM_SHIFT
)paren
suffix:semicolon
id|ism
op_add_assign
id|m
op_minus
l_int|1
suffix:semicolon
id|do_div
c_func
(paren
id|ism
comma
id|m
)paren
suffix:semicolon
)brace
r_return
id|ism
suffix:semicolon
)brace
multiline_comment|/* convert d (us) into dx (psched us) */
r_static
id|u64
DECL|function|d2dx
id|d2dx
c_func
(paren
id|u32
id|d
)paren
(brace
id|u64
id|dx
suffix:semicolon
id|dx
op_assign
(paren
(paren
id|u64
)paren
id|d
op_star
id|PSCHED_JIFFIE2US
c_func
(paren
id|HZ
)paren
)paren
suffix:semicolon
id|dx
op_add_assign
l_int|1000000
op_minus
l_int|1
suffix:semicolon
id|do_div
c_func
(paren
id|dx
comma
l_int|1000000
)paren
suffix:semicolon
r_return
id|dx
suffix:semicolon
)brace
multiline_comment|/* convert sm (bytes/psched us) into m (bps) */
r_static
id|u32
DECL|function|sm2m
id|sm2m
c_func
(paren
id|u64
id|sm
)paren
(brace
id|u64
id|m
suffix:semicolon
id|m
op_assign
(paren
id|sm
op_star
id|PSCHED_JIFFIE2US
c_func
(paren
id|HZ
)paren
)paren
op_rshift
id|SM_SHIFT
suffix:semicolon
r_return
(paren
id|u32
)paren
id|m
suffix:semicolon
)brace
multiline_comment|/* convert dx (psched us) into d (us) */
r_static
id|u32
DECL|function|dx2d
id|dx2d
c_func
(paren
id|u64
id|dx
)paren
(brace
id|u64
id|d
suffix:semicolon
id|d
op_assign
id|dx
op_star
l_int|1000000
suffix:semicolon
id|do_div
c_func
(paren
id|d
comma
id|PSCHED_JIFFIE2US
c_func
(paren
id|HZ
)paren
)paren
suffix:semicolon
r_return
(paren
id|u32
)paren
id|d
suffix:semicolon
)brace
r_static
r_void
DECL|function|sc2isc
id|sc2isc
c_func
(paren
r_struct
id|tc_service_curve
op_star
id|sc
comma
r_struct
id|internal_sc
op_star
id|isc
)paren
(brace
id|isc-&gt;sm1
op_assign
id|m2sm
c_func
(paren
id|sc-&gt;m1
)paren
suffix:semicolon
id|isc-&gt;ism1
op_assign
id|m2ism
c_func
(paren
id|sc-&gt;m1
)paren
suffix:semicolon
id|isc-&gt;dx
op_assign
id|d2dx
c_func
(paren
id|sc-&gt;d
)paren
suffix:semicolon
id|isc-&gt;dy
op_assign
id|seg_x2y
c_func
(paren
id|isc-&gt;dx
comma
id|isc-&gt;sm1
)paren
suffix:semicolon
id|isc-&gt;sm2
op_assign
id|m2sm
c_func
(paren
id|sc-&gt;m2
)paren
suffix:semicolon
id|isc-&gt;ism2
op_assign
id|m2ism
c_func
(paren
id|sc-&gt;m2
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * initialize the runtime service curve with the given internal&n; * service curve starting at (x, y).&n; */
r_static
r_void
DECL|function|rtsc_init
id|rtsc_init
c_func
(paren
r_struct
id|runtime_sc
op_star
id|rtsc
comma
r_struct
id|internal_sc
op_star
id|isc
comma
id|u64
id|x
comma
id|u64
id|y
)paren
(brace
id|rtsc-&gt;x
op_assign
id|x
suffix:semicolon
id|rtsc-&gt;y
op_assign
id|y
suffix:semicolon
id|rtsc-&gt;sm1
op_assign
id|isc-&gt;sm1
suffix:semicolon
id|rtsc-&gt;ism1
op_assign
id|isc-&gt;ism1
suffix:semicolon
id|rtsc-&gt;dx
op_assign
id|isc-&gt;dx
suffix:semicolon
id|rtsc-&gt;dy
op_assign
id|isc-&gt;dy
suffix:semicolon
id|rtsc-&gt;sm2
op_assign
id|isc-&gt;sm2
suffix:semicolon
id|rtsc-&gt;ism2
op_assign
id|isc-&gt;ism2
suffix:semicolon
)brace
multiline_comment|/*&n; * calculate the y-projection of the runtime service curve by the&n; * given x-projection value&n; */
r_static
id|u64
DECL|function|rtsc_y2x
id|rtsc_y2x
c_func
(paren
r_struct
id|runtime_sc
op_star
id|rtsc
comma
id|u64
id|y
)paren
(brace
id|u64
id|x
suffix:semicolon
r_if
c_cond
(paren
id|y
OL
id|rtsc-&gt;y
)paren
id|x
op_assign
id|rtsc-&gt;x
suffix:semicolon
r_else
r_if
c_cond
(paren
id|y
op_le
id|rtsc-&gt;y
op_plus
id|rtsc-&gt;dy
)paren
(brace
multiline_comment|/* x belongs to the 1st segment */
r_if
c_cond
(paren
id|rtsc-&gt;dy
op_eq
l_int|0
)paren
id|x
op_assign
id|rtsc-&gt;x
op_plus
id|rtsc-&gt;dx
suffix:semicolon
r_else
id|x
op_assign
id|rtsc-&gt;x
op_plus
id|seg_y2x
c_func
(paren
id|y
op_minus
id|rtsc-&gt;y
comma
id|rtsc-&gt;ism1
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* x belongs to the 2nd segment */
id|x
op_assign
id|rtsc-&gt;x
op_plus
id|rtsc-&gt;dx
op_plus
id|seg_y2x
c_func
(paren
id|y
op_minus
id|rtsc-&gt;y
op_minus
id|rtsc-&gt;dy
comma
id|rtsc-&gt;ism2
)paren
suffix:semicolon
)brace
r_return
id|x
suffix:semicolon
)brace
r_static
id|u64
DECL|function|rtsc_x2y
id|rtsc_x2y
c_func
(paren
r_struct
id|runtime_sc
op_star
id|rtsc
comma
id|u64
id|x
)paren
(brace
id|u64
id|y
suffix:semicolon
r_if
c_cond
(paren
id|x
op_le
id|rtsc-&gt;x
)paren
id|y
op_assign
id|rtsc-&gt;y
suffix:semicolon
r_else
r_if
c_cond
(paren
id|x
op_le
id|rtsc-&gt;x
op_plus
id|rtsc-&gt;dx
)paren
multiline_comment|/* y belongs to the 1st segment */
id|y
op_assign
id|rtsc-&gt;y
op_plus
id|seg_x2y
c_func
(paren
id|x
op_minus
id|rtsc-&gt;x
comma
id|rtsc-&gt;sm1
)paren
suffix:semicolon
r_else
multiline_comment|/* y belongs to the 2nd segment */
id|y
op_assign
id|rtsc-&gt;y
op_plus
id|rtsc-&gt;dy
op_plus
id|seg_x2y
c_func
(paren
id|x
op_minus
id|rtsc-&gt;x
op_minus
id|rtsc-&gt;dx
comma
id|rtsc-&gt;sm2
)paren
suffix:semicolon
r_return
id|y
suffix:semicolon
)brace
multiline_comment|/*&n; * update the runtime service curve by taking the minimum of the current&n; * runtime service curve and the service curve starting at (x, y).&n; */
r_static
r_void
DECL|function|rtsc_min
id|rtsc_min
c_func
(paren
r_struct
id|runtime_sc
op_star
id|rtsc
comma
r_struct
id|internal_sc
op_star
id|isc
comma
id|u64
id|x
comma
id|u64
id|y
)paren
(brace
id|u64
id|y1
comma
id|y2
comma
id|dx
comma
id|dy
suffix:semicolon
id|u32
id|dsm
suffix:semicolon
r_if
c_cond
(paren
id|isc-&gt;sm1
op_le
id|isc-&gt;sm2
)paren
(brace
multiline_comment|/* service curve is convex */
id|y1
op_assign
id|rtsc_x2y
c_func
(paren
id|rtsc
comma
id|x
)paren
suffix:semicolon
r_if
c_cond
(paren
id|y1
OL
id|y
)paren
multiline_comment|/* the current rtsc is smaller */
r_return
suffix:semicolon
id|rtsc-&gt;x
op_assign
id|x
suffix:semicolon
id|rtsc-&gt;y
op_assign
id|y
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * service curve is concave&n;&t; * compute the two y values of the current rtsc&n;&t; *&t;y1: at x&n;&t; *&t;y2: at (x + dx)&n;&t; */
id|y1
op_assign
id|rtsc_x2y
c_func
(paren
id|rtsc
comma
id|x
)paren
suffix:semicolon
r_if
c_cond
(paren
id|y1
op_le
id|y
)paren
(brace
multiline_comment|/* rtsc is below isc, no change to rtsc */
r_return
suffix:semicolon
)brace
id|y2
op_assign
id|rtsc_x2y
c_func
(paren
id|rtsc
comma
id|x
op_plus
id|isc-&gt;dx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|y2
op_ge
id|y
op_plus
id|isc-&gt;dy
)paren
(brace
multiline_comment|/* rtsc is above isc, replace rtsc by isc */
id|rtsc-&gt;x
op_assign
id|x
suffix:semicolon
id|rtsc-&gt;y
op_assign
id|y
suffix:semicolon
id|rtsc-&gt;dx
op_assign
id|isc-&gt;dx
suffix:semicolon
id|rtsc-&gt;dy
op_assign
id|isc-&gt;dy
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * the two curves intersect&n;&t; * compute the offsets (dx, dy) using the reverse&n;&t; * function of seg_x2y()&n;&t; *&t;seg_x2y(dx, sm1) == seg_x2y(dx, sm2) + (y1 - y)&n;&t; */
id|dx
op_assign
(paren
id|y1
op_minus
id|y
)paren
op_lshift
id|SM_SHIFT
suffix:semicolon
id|dsm
op_assign
id|isc-&gt;sm1
op_minus
id|isc-&gt;sm2
suffix:semicolon
id|do_div
c_func
(paren
id|dx
comma
id|dsm
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * check if (x, y1) belongs to the 1st segment of rtsc.&n;&t; * if so, add the offset.&n;&t; */
r_if
c_cond
(paren
id|rtsc-&gt;x
op_plus
id|rtsc-&gt;dx
OG
id|x
)paren
id|dx
op_add_assign
id|rtsc-&gt;x
op_plus
id|rtsc-&gt;dx
op_minus
id|x
suffix:semicolon
id|dy
op_assign
id|seg_x2y
c_func
(paren
id|dx
comma
id|isc-&gt;sm1
)paren
suffix:semicolon
id|rtsc-&gt;x
op_assign
id|x
suffix:semicolon
id|rtsc-&gt;y
op_assign
id|y
suffix:semicolon
id|rtsc-&gt;dx
op_assign
id|dx
suffix:semicolon
id|rtsc-&gt;dy
op_assign
id|dy
suffix:semicolon
r_return
suffix:semicolon
)brace
r_static
r_void
DECL|function|init_ed
id|init_ed
c_func
(paren
r_struct
id|hfsc_class
op_star
id|cl
comma
r_int
r_int
id|next_len
)paren
(brace
id|u64
id|cur_time
suffix:semicolon
id|PSCHED_GET_TIME
c_func
(paren
id|cur_time
)paren
suffix:semicolon
multiline_comment|/* update the deadline curve */
id|rtsc_min
c_func
(paren
op_amp
id|cl-&gt;cl_deadline
comma
op_amp
id|cl-&gt;cl_rsc
comma
id|cur_time
comma
id|cl-&gt;cl_cumul
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * update the eligible curve.&n;&t; * for concave, it is equal to the deadline curve.&n;&t; * for convex, it is a linear curve with slope m2.&n;&t; */
id|cl-&gt;cl_eligible
op_assign
id|cl-&gt;cl_deadline
suffix:semicolon
r_if
c_cond
(paren
id|cl-&gt;cl_rsc.sm1
op_le
id|cl-&gt;cl_rsc.sm2
)paren
(brace
id|cl-&gt;cl_eligible.dx
op_assign
l_int|0
suffix:semicolon
id|cl-&gt;cl_eligible.dy
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* compute e and d */
id|cl-&gt;cl_e
op_assign
id|rtsc_y2x
c_func
(paren
op_amp
id|cl-&gt;cl_eligible
comma
id|cl-&gt;cl_cumul
)paren
suffix:semicolon
id|cl-&gt;cl_d
op_assign
id|rtsc_y2x
c_func
(paren
op_amp
id|cl-&gt;cl_deadline
comma
id|cl-&gt;cl_cumul
op_plus
id|next_len
)paren
suffix:semicolon
id|ellist_insert
c_func
(paren
id|cl
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|update_ed
id|update_ed
c_func
(paren
r_struct
id|hfsc_class
op_star
id|cl
comma
r_int
r_int
id|next_len
)paren
(brace
id|cl-&gt;cl_e
op_assign
id|rtsc_y2x
c_func
(paren
op_amp
id|cl-&gt;cl_eligible
comma
id|cl-&gt;cl_cumul
)paren
suffix:semicolon
id|cl-&gt;cl_d
op_assign
id|rtsc_y2x
c_func
(paren
op_amp
id|cl-&gt;cl_deadline
comma
id|cl-&gt;cl_cumul
op_plus
id|next_len
)paren
suffix:semicolon
id|ellist_update
c_func
(paren
id|cl
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|update_d
id|update_d
c_func
(paren
r_struct
id|hfsc_class
op_star
id|cl
comma
r_int
r_int
id|next_len
)paren
(brace
id|cl-&gt;cl_d
op_assign
id|rtsc_y2x
c_func
(paren
op_amp
id|cl-&gt;cl_deadline
comma
id|cl-&gt;cl_cumul
op_plus
id|next_len
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|update_cfmin
id|update_cfmin
c_func
(paren
r_struct
id|hfsc_class
op_star
id|cl
)paren
(brace
r_struct
id|hfsc_class
op_star
id|p
suffix:semicolon
id|u64
id|cfmin
suffix:semicolon
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|cl-&gt;actlist
)paren
)paren
(brace
id|cl-&gt;cl_cfmin
op_assign
l_int|0
suffix:semicolon
r_return
suffix:semicolon
)brace
id|cfmin
op_assign
id|HT_INFINITY
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|p
comma
op_amp
id|cl-&gt;actlist
comma
id|alist
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;cl_f
op_eq
l_int|0
)paren
(brace
id|cl-&gt;cl_cfmin
op_assign
l_int|0
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|p-&gt;cl_f
OL
id|cfmin
)paren
id|cfmin
op_assign
id|p-&gt;cl_f
suffix:semicolon
)brace
id|cl-&gt;cl_cfmin
op_assign
id|cfmin
suffix:semicolon
)brace
r_static
r_void
DECL|function|init_vf
id|init_vf
c_func
(paren
r_struct
id|hfsc_class
op_star
id|cl
comma
r_int
r_int
id|len
)paren
(brace
r_struct
id|hfsc_class
op_star
id|max_cl
comma
op_star
id|p
suffix:semicolon
id|u64
id|vt
comma
id|f
comma
id|cur_time
suffix:semicolon
r_int
id|go_active
suffix:semicolon
id|cur_time
op_assign
l_int|0
suffix:semicolon
id|go_active
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|cl-&gt;cl_parent
op_ne
l_int|NULL
suffix:semicolon
id|cl
op_assign
id|cl-&gt;cl_parent
)paren
(brace
r_if
c_cond
(paren
id|go_active
op_logical_and
id|cl-&gt;cl_nactive
op_increment
op_eq
l_int|0
)paren
id|go_active
op_assign
l_int|1
suffix:semicolon
r_else
id|go_active
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|go_active
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|cl-&gt;cl_parent-&gt;actlist
)paren
)paren
(brace
id|max_cl
op_assign
id|list_entry
c_func
(paren
id|cl-&gt;cl_parent-&gt;actlist.prev
comma
r_struct
id|hfsc_class
comma
id|alist
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * set vt to the average of the min and max&n;&t;&t;&t;&t; * classes.  if the parent&squot;s period didn&squot;t&n;&t;&t;&t;&t; * change, don&squot;t decrease vt of the class.&n;&t;&t;&t;&t; */
id|vt
op_assign
id|max_cl-&gt;cl_vt
suffix:semicolon
r_if
c_cond
(paren
id|cl-&gt;cl_parent-&gt;cl_cvtmin
op_ne
l_int|0
)paren
id|vt
op_assign
(paren
id|cl-&gt;cl_parent-&gt;cl_cvtmin
op_plus
id|vt
)paren
op_div
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|cl-&gt;cl_parent-&gt;cl_vtperiod
op_ne
id|cl-&gt;cl_parentperiod
op_logical_or
id|vt
OG
id|cl-&gt;cl_vt
)paren
id|cl-&gt;cl_vt
op_assign
id|vt
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * first child for a new parent backlog period.&n;&t;&t;&t;&t; * add parent&squot;s cvtmax to vtoff of children&n;&t;&t;&t;&t; * to make a new vt (vtoff + vt) larger than&n;&t;&t;&t;&t; * the vt in the last period for all children.&n;&t;&t;&t;&t; */
id|vt
op_assign
id|cl-&gt;cl_parent-&gt;cl_cvtmax
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|p
comma
op_amp
id|cl-&gt;cl_parent-&gt;children
comma
id|siblings
)paren
id|p-&gt;cl_vtoff
op_add_assign
id|vt
suffix:semicolon
id|cl-&gt;cl_vt
op_assign
l_int|0
suffix:semicolon
id|cl-&gt;cl_parent-&gt;cl_cvtmax
op_assign
l_int|0
suffix:semicolon
id|cl-&gt;cl_parent-&gt;cl_cvtmin
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* update the virtual curve */
id|vt
op_assign
id|cl-&gt;cl_vt
op_plus
id|cl-&gt;cl_vtoff
suffix:semicolon
id|rtsc_min
c_func
(paren
op_amp
id|cl-&gt;cl_virtual
comma
op_amp
id|cl-&gt;cl_fsc
comma
id|vt
comma
id|cl-&gt;cl_total
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cl-&gt;cl_virtual.x
op_eq
id|vt
)paren
(brace
id|cl-&gt;cl_virtual.x
op_sub_assign
id|cl-&gt;cl_vtoff
suffix:semicolon
id|cl-&gt;cl_vtoff
op_assign
l_int|0
suffix:semicolon
)brace
id|cl-&gt;cl_vtadj
op_assign
l_int|0
suffix:semicolon
id|cl-&gt;cl_vtperiod
op_increment
suffix:semicolon
multiline_comment|/* increment vt period */
id|cl-&gt;cl_parentperiod
op_assign
id|cl-&gt;cl_parent-&gt;cl_vtperiod
suffix:semicolon
r_if
c_cond
(paren
id|cl-&gt;cl_parent-&gt;cl_nactive
op_eq
l_int|0
)paren
id|cl-&gt;cl_parentperiod
op_increment
suffix:semicolon
id|cl-&gt;cl_f
op_assign
l_int|0
suffix:semicolon
id|actlist_insert
c_func
(paren
id|cl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cl-&gt;cl_flags
op_amp
id|HFSC_USC
)paren
(brace
multiline_comment|/* class has upper limit curve */
r_if
c_cond
(paren
id|cur_time
op_eq
l_int|0
)paren
id|PSCHED_GET_TIME
c_func
(paren
id|cur_time
)paren
suffix:semicolon
multiline_comment|/* update the ulimit curve */
id|rtsc_min
c_func
(paren
op_amp
id|cl-&gt;cl_ulimit
comma
op_amp
id|cl-&gt;cl_usc
comma
id|cur_time
comma
id|cl-&gt;cl_total
)paren
suffix:semicolon
multiline_comment|/* compute myf */
id|cl-&gt;cl_myf
op_assign
id|rtsc_y2x
c_func
(paren
op_amp
id|cl-&gt;cl_ulimit
comma
id|cl-&gt;cl_total
)paren
suffix:semicolon
id|cl-&gt;cl_myfadj
op_assign
l_int|0
suffix:semicolon
)brace
)brace
id|f
op_assign
id|max
c_func
(paren
id|cl-&gt;cl_myf
comma
id|cl-&gt;cl_cfmin
)paren
suffix:semicolon
r_if
c_cond
(paren
id|f
op_ne
id|cl-&gt;cl_f
)paren
(brace
id|cl-&gt;cl_f
op_assign
id|f
suffix:semicolon
id|update_cfmin
c_func
(paren
id|cl-&gt;cl_parent
)paren
suffix:semicolon
)brace
)brace
)brace
r_static
r_void
DECL|function|update_vf
id|update_vf
c_func
(paren
r_struct
id|hfsc_class
op_star
id|cl
comma
r_int
r_int
id|len
comma
id|u64
id|cur_time
)paren
(brace
id|u64
id|f
suffix:semicolon
multiline_comment|/* , myf_bound, delta; */
r_int
id|go_passive
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|cl-&gt;qdisc-&gt;q.qlen
op_eq
l_int|0
op_logical_and
id|cl-&gt;cl_flags
op_amp
id|HFSC_FSC
)paren
id|go_passive
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|cl-&gt;cl_parent
op_ne
l_int|NULL
suffix:semicolon
id|cl
op_assign
id|cl-&gt;cl_parent
)paren
(brace
id|cl-&gt;cl_total
op_add_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|cl-&gt;cl_flags
op_amp
id|HFSC_FSC
)paren
op_logical_or
id|cl-&gt;cl_nactive
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|go_passive
op_logical_and
op_decrement
id|cl-&gt;cl_nactive
op_eq
l_int|0
)paren
id|go_passive
op_assign
l_int|1
suffix:semicolon
r_else
id|go_passive
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|go_passive
)paren
(brace
multiline_comment|/* no more active child, going passive */
multiline_comment|/* update cvtmax of the parent class */
r_if
c_cond
(paren
id|cl-&gt;cl_vt
OG
id|cl-&gt;cl_parent-&gt;cl_cvtmax
)paren
id|cl-&gt;cl_parent-&gt;cl_cvtmax
op_assign
id|cl-&gt;cl_vt
suffix:semicolon
multiline_comment|/* remove this class from the vt list */
id|actlist_remove
c_func
(paren
id|cl
)paren
suffix:semicolon
id|update_cfmin
c_func
(paren
id|cl-&gt;cl_parent
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * update vt and f&n;&t;&t; */
id|cl-&gt;cl_vt
op_assign
id|rtsc_y2x
c_func
(paren
op_amp
id|cl-&gt;cl_virtual
comma
id|cl-&gt;cl_total
)paren
op_minus
id|cl-&gt;cl_vtoff
op_plus
id|cl-&gt;cl_vtadj
suffix:semicolon
multiline_comment|/*&n;&t;&t; * if vt of the class is smaller than cvtmin,&n;&t;&t; * the class was skipped in the past due to non-fit.&n;&t;&t; * if so, we need to adjust vtadj.&n;&t;&t; */
r_if
c_cond
(paren
id|cl-&gt;cl_vt
OL
id|cl-&gt;cl_parent-&gt;cl_cvtmin
)paren
(brace
id|cl-&gt;cl_vtadj
op_add_assign
id|cl-&gt;cl_parent-&gt;cl_cvtmin
op_minus
id|cl-&gt;cl_vt
suffix:semicolon
id|cl-&gt;cl_vt
op_assign
id|cl-&gt;cl_parent-&gt;cl_cvtmin
suffix:semicolon
)brace
multiline_comment|/* update the vt list */
id|actlist_update
c_func
(paren
id|cl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cl-&gt;cl_flags
op_amp
id|HFSC_USC
)paren
(brace
id|cl-&gt;cl_myf
op_assign
id|cl-&gt;cl_myfadj
op_plus
id|rtsc_y2x
c_func
(paren
op_amp
id|cl-&gt;cl_ulimit
comma
id|cl-&gt;cl_total
)paren
suffix:semicolon
macro_line|#if 0
multiline_comment|/*&n;&t;&t;&t; * This code causes classes to stay way under their&n;&t;&t;&t; * limit when multiple classes are used at gigabit&n;&t;&t;&t; * speed. needs investigation. -kaber&n;&t;&t;&t; */
multiline_comment|/*&n;&t;&t;&t; * if myf lags behind by more than one clock tick&n;&t;&t;&t; * from the current time, adjust myfadj to prevent&n;&t;&t;&t; * a rate-limited class from going greedy.&n;&t;&t;&t; * in a steady state under rate-limiting, myf&n;&t;&t;&t; * fluctuates within one clock tick.&n;&t;&t;&t; */
id|myf_bound
op_assign
id|cur_time
op_minus
id|PSCHED_JIFFIE2US
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cl-&gt;cl_myf
OL
id|myf_bound
)paren
(brace
id|delta
op_assign
id|cur_time
op_minus
id|cl-&gt;cl_myf
suffix:semicolon
id|cl-&gt;cl_myfadj
op_add_assign
id|delta
suffix:semicolon
id|cl-&gt;cl_myf
op_add_assign
id|delta
suffix:semicolon
)brace
macro_line|#endif
)brace
id|f
op_assign
id|max
c_func
(paren
id|cl-&gt;cl_myf
comma
id|cl-&gt;cl_cfmin
)paren
suffix:semicolon
r_if
c_cond
(paren
id|f
op_ne
id|cl-&gt;cl_f
)paren
(brace
id|cl-&gt;cl_f
op_assign
id|f
suffix:semicolon
id|update_cfmin
c_func
(paren
id|cl-&gt;cl_parent
)paren
suffix:semicolon
)brace
)brace
)brace
r_static
r_void
DECL|function|set_active
id|set_active
c_func
(paren
r_struct
id|hfsc_class
op_star
id|cl
comma
r_int
r_int
id|len
)paren
(brace
r_if
c_cond
(paren
id|cl-&gt;cl_flags
op_amp
id|HFSC_RSC
)paren
id|init_ed
c_func
(paren
id|cl
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cl-&gt;cl_flags
op_amp
id|HFSC_FSC
)paren
id|init_vf
c_func
(paren
id|cl
comma
id|len
)paren
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|cl-&gt;dlist
comma
op_amp
id|cl-&gt;sched-&gt;droplist
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|set_passive
id|set_passive
c_func
(paren
r_struct
id|hfsc_class
op_star
id|cl
)paren
(brace
r_if
c_cond
(paren
id|cl-&gt;cl_flags
op_amp
id|HFSC_RSC
)paren
id|ellist_remove
c_func
(paren
id|cl
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|cl-&gt;dlist
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * actlist is now handled in update_vf() so that update_vf(cl, 0, 0)&n;&t; * needs to be called explicitly to remove a class from actlist&n;&t; */
)brace
multiline_comment|/*&n; * hack to get length of first packet in queue.&n; */
r_static
r_int
r_int
DECL|function|qdisc_peek_len
id|qdisc_peek_len
c_func
(paren
r_struct
id|Qdisc
op_star
id|sch
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_int
r_int
id|len
suffix:semicolon
id|skb
op_assign
id|sch
op_member_access_from_pointer
id|dequeue
c_func
(paren
id|sch
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|net_ratelimit
c_func
(paren
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;qdisc_peek_len: non work-conserving qdisc ?&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|len
op_assign
id|skb-&gt;len
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|sch-&gt;ops
op_member_access_from_pointer
id|requeue
c_func
(paren
id|skb
comma
id|sch
)paren
op_ne
id|NET_XMIT_SUCCESS
)paren
)paren
(brace
r_if
c_cond
(paren
id|net_ratelimit
c_func
(paren
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;qdisc_peek_len: failed to requeue&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
id|len
suffix:semicolon
)brace
r_static
r_void
DECL|function|hfsc_purge_queue
id|hfsc_purge_queue
c_func
(paren
r_struct
id|Qdisc
op_star
id|sch
comma
r_struct
id|hfsc_class
op_star
id|cl
)paren
(brace
r_int
r_int
id|len
op_assign
id|cl-&gt;qdisc-&gt;q.qlen
suffix:semicolon
id|qdisc_reset
c_func
(paren
id|cl-&gt;qdisc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
l_int|0
)paren
(brace
id|update_vf
c_func
(paren
id|cl
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|set_passive
c_func
(paren
id|cl
)paren
suffix:semicolon
id|sch-&gt;q.qlen
op_sub_assign
id|len
suffix:semicolon
)brace
)brace
r_static
r_void
DECL|function|hfsc_adjust_levels
id|hfsc_adjust_levels
c_func
(paren
r_struct
id|hfsc_class
op_star
id|cl
)paren
(brace
r_struct
id|hfsc_class
op_star
id|p
suffix:semicolon
r_int
r_int
id|level
suffix:semicolon
r_do
(brace
id|level
op_assign
l_int|0
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|p
comma
op_amp
id|cl-&gt;children
comma
id|siblings
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;level
OG
id|level
)paren
id|level
op_assign
id|p-&gt;level
suffix:semicolon
)brace
id|cl-&gt;level
op_assign
id|level
op_plus
l_int|1
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|cl
op_assign
id|cl-&gt;cl_parent
)paren
op_ne
l_int|NULL
)paren
suffix:semicolon
)brace
r_static
r_inline
r_int
r_int
DECL|function|hfsc_hash
id|hfsc_hash
c_func
(paren
id|u32
id|h
)paren
(brace
id|h
op_xor_assign
id|h
op_rshift
l_int|8
suffix:semicolon
id|h
op_xor_assign
id|h
op_rshift
l_int|4
suffix:semicolon
r_return
id|h
op_amp
(paren
id|HFSC_HSIZE
op_minus
l_int|1
)paren
suffix:semicolon
)brace
r_static
r_inline
r_struct
id|hfsc_class
op_star
DECL|function|hfsc_find_class
id|hfsc_find_class
c_func
(paren
id|u32
id|classid
comma
r_struct
id|Qdisc
op_star
id|sch
)paren
(brace
r_struct
id|hfsc_sched
op_star
id|q
op_assign
(paren
r_struct
id|hfsc_sched
op_star
)paren
id|sch-&gt;data
suffix:semicolon
r_struct
id|hfsc_class
op_star
id|cl
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|cl
comma
op_amp
id|q-&gt;clhash
(braket
id|hfsc_hash
c_func
(paren
id|classid
)paren
)braket
comma
id|hlist
)paren
(brace
r_if
c_cond
(paren
id|cl-&gt;classid
op_eq
id|classid
)paren
r_return
id|cl
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
r_static
r_void
DECL|function|hfsc_change_rsc
id|hfsc_change_rsc
c_func
(paren
r_struct
id|hfsc_class
op_star
id|cl
comma
r_struct
id|tc_service_curve
op_star
id|rsc
comma
id|u64
id|cur_time
)paren
(brace
id|sc2isc
c_func
(paren
id|rsc
comma
op_amp
id|cl-&gt;cl_rsc
)paren
suffix:semicolon
id|rtsc_init
c_func
(paren
op_amp
id|cl-&gt;cl_deadline
comma
op_amp
id|cl-&gt;cl_rsc
comma
id|cur_time
comma
id|cl-&gt;cl_cumul
)paren
suffix:semicolon
id|cl-&gt;cl_eligible
op_assign
id|cl-&gt;cl_deadline
suffix:semicolon
r_if
c_cond
(paren
id|cl-&gt;cl_rsc.sm1
op_le
id|cl-&gt;cl_rsc.sm2
)paren
(brace
id|cl-&gt;cl_eligible.dx
op_assign
l_int|0
suffix:semicolon
id|cl-&gt;cl_eligible.dy
op_assign
l_int|0
suffix:semicolon
)brace
id|cl-&gt;cl_flags
op_or_assign
id|HFSC_RSC
suffix:semicolon
)brace
r_static
r_void
DECL|function|hfsc_change_fsc
id|hfsc_change_fsc
c_func
(paren
r_struct
id|hfsc_class
op_star
id|cl
comma
r_struct
id|tc_service_curve
op_star
id|fsc
)paren
(brace
id|sc2isc
c_func
(paren
id|fsc
comma
op_amp
id|cl-&gt;cl_fsc
)paren
suffix:semicolon
id|rtsc_init
c_func
(paren
op_amp
id|cl-&gt;cl_virtual
comma
op_amp
id|cl-&gt;cl_fsc
comma
id|cl-&gt;cl_vt
comma
id|cl-&gt;cl_total
)paren
suffix:semicolon
id|cl-&gt;cl_flags
op_or_assign
id|HFSC_FSC
suffix:semicolon
)brace
r_static
r_void
DECL|function|hfsc_change_usc
id|hfsc_change_usc
c_func
(paren
r_struct
id|hfsc_class
op_star
id|cl
comma
r_struct
id|tc_service_curve
op_star
id|usc
comma
id|u64
id|cur_time
)paren
(brace
id|sc2isc
c_func
(paren
id|usc
comma
op_amp
id|cl-&gt;cl_usc
)paren
suffix:semicolon
id|rtsc_init
c_func
(paren
op_amp
id|cl-&gt;cl_ulimit
comma
op_amp
id|cl-&gt;cl_usc
comma
id|cur_time
comma
id|cl-&gt;cl_total
)paren
suffix:semicolon
id|cl-&gt;cl_flags
op_or_assign
id|HFSC_USC
suffix:semicolon
)brace
r_static
r_int
DECL|function|hfsc_change_class
id|hfsc_change_class
c_func
(paren
r_struct
id|Qdisc
op_star
id|sch
comma
id|u32
id|classid
comma
id|u32
id|parentid
comma
r_struct
id|rtattr
op_star
op_star
id|tca
comma
r_int
r_int
op_star
id|arg
)paren
(brace
r_struct
id|hfsc_sched
op_star
id|q
op_assign
(paren
r_struct
id|hfsc_sched
op_star
)paren
id|sch-&gt;data
suffix:semicolon
r_struct
id|hfsc_class
op_star
id|cl
op_assign
(paren
r_struct
id|hfsc_class
op_star
)paren
op_star
id|arg
suffix:semicolon
r_struct
id|hfsc_class
op_star
id|parent
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|rtattr
op_star
id|opt
op_assign
id|tca
(braket
id|TCA_OPTIONS
op_minus
l_int|1
)braket
suffix:semicolon
r_struct
id|rtattr
op_star
id|tb
(braket
id|TCA_HFSC_MAX
)braket
suffix:semicolon
r_struct
id|tc_service_curve
op_star
id|rsc
op_assign
l_int|NULL
comma
op_star
id|fsc
op_assign
l_int|NULL
comma
op_star
id|usc
op_assign
l_int|NULL
suffix:semicolon
id|u64
id|cur_time
suffix:semicolon
r_if
c_cond
(paren
id|opt
op_eq
l_int|NULL
op_logical_or
id|rtattr_parse
c_func
(paren
id|tb
comma
id|TCA_HFSC_MAX
comma
id|RTA_DATA
c_func
(paren
id|opt
)paren
comma
id|RTA_PAYLOAD
c_func
(paren
id|opt
)paren
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|tb
(braket
id|TCA_HFSC_RSC
op_minus
l_int|1
)braket
)paren
(brace
r_if
c_cond
(paren
id|RTA_PAYLOAD
c_func
(paren
id|tb
(braket
id|TCA_HFSC_RSC
op_minus
l_int|1
)braket
)paren
OL
r_sizeof
(paren
op_star
id|rsc
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|rsc
op_assign
id|RTA_DATA
c_func
(paren
id|tb
(braket
id|TCA_HFSC_RSC
op_minus
l_int|1
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rsc-&gt;m1
op_eq
l_int|0
op_logical_and
id|rsc-&gt;m2
op_eq
l_int|0
)paren
id|rsc
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tb
(braket
id|TCA_HFSC_FSC
op_minus
l_int|1
)braket
)paren
(brace
r_if
c_cond
(paren
id|RTA_PAYLOAD
c_func
(paren
id|tb
(braket
id|TCA_HFSC_FSC
op_minus
l_int|1
)braket
)paren
OL
r_sizeof
(paren
op_star
id|fsc
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|fsc
op_assign
id|RTA_DATA
c_func
(paren
id|tb
(braket
id|TCA_HFSC_FSC
op_minus
l_int|1
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fsc-&gt;m1
op_eq
l_int|0
op_logical_and
id|fsc-&gt;m2
op_eq
l_int|0
)paren
id|fsc
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tb
(braket
id|TCA_HFSC_USC
op_minus
l_int|1
)braket
)paren
(brace
r_if
c_cond
(paren
id|RTA_PAYLOAD
c_func
(paren
id|tb
(braket
id|TCA_HFSC_USC
op_minus
l_int|1
)braket
)paren
OL
r_sizeof
(paren
op_star
id|usc
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|usc
op_assign
id|RTA_DATA
c_func
(paren
id|tb
(braket
id|TCA_HFSC_USC
op_minus
l_int|1
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|usc-&gt;m1
op_eq
l_int|0
op_logical_and
id|usc-&gt;m2
op_eq
l_int|0
)paren
id|usc
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cl
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|parentid
)paren
(brace
r_if
c_cond
(paren
id|cl-&gt;cl_parent
op_logical_and
id|cl-&gt;cl_parent-&gt;classid
op_ne
id|parentid
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|cl-&gt;cl_parent
op_eq
l_int|NULL
op_logical_and
id|parentid
op_ne
id|TC_H_ROOT
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|PSCHED_GET_TIME
c_func
(paren
id|cur_time
)paren
suffix:semicolon
id|sch_tree_lock
c_func
(paren
id|sch
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rsc
op_ne
l_int|NULL
)paren
id|hfsc_change_rsc
c_func
(paren
id|cl
comma
id|rsc
comma
id|cur_time
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fsc
op_ne
l_int|NULL
)paren
id|hfsc_change_fsc
c_func
(paren
id|cl
comma
id|fsc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|usc
op_ne
l_int|NULL
)paren
id|hfsc_change_usc
c_func
(paren
id|cl
comma
id|usc
comma
id|cur_time
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cl-&gt;qdisc-&gt;q.qlen
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|cl-&gt;cl_flags
op_amp
id|HFSC_RSC
)paren
id|update_ed
c_func
(paren
id|cl
comma
id|qdisc_peek_len
c_func
(paren
id|cl-&gt;qdisc
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cl-&gt;cl_flags
op_amp
id|HFSC_FSC
)paren
id|update_vf
c_func
(paren
id|cl
comma
l_int|0
comma
id|cur_time
)paren
suffix:semicolon
)brace
id|sch_tree_unlock
c_func
(paren
id|sch
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_NET_ESTIMATOR
r_if
c_cond
(paren
id|tca
(braket
id|TCA_RATE
op_minus
l_int|1
)braket
)paren
(brace
id|qdisc_kill_estimator
c_func
(paren
op_amp
id|cl-&gt;stats
)paren
suffix:semicolon
id|qdisc_new_estimator
c_func
(paren
op_amp
id|cl-&gt;stats
comma
id|tca
(braket
id|TCA_RATE
op_minus
l_int|1
)braket
)paren
suffix:semicolon
)brace
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|parentid
op_eq
id|TC_H_ROOT
)paren
r_return
op_minus
id|EEXIST
suffix:semicolon
id|parent
op_assign
op_amp
id|q-&gt;root
suffix:semicolon
r_if
c_cond
(paren
id|parentid
)paren
(brace
id|parent
op_assign
id|hfsc_find_class
c_func
(paren
id|parentid
comma
id|sch
)paren
suffix:semicolon
r_if
c_cond
(paren
id|parent
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOENT
suffix:semicolon
)brace
r_if
c_cond
(paren
id|classid
op_eq
l_int|0
op_logical_or
id|TC_H_MAJ
c_func
(paren
id|classid
op_xor
id|sch-&gt;handle
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|hfsc_find_class
c_func
(paren
id|classid
comma
id|sch
)paren
)paren
r_return
op_minus
id|EEXIST
suffix:semicolon
r_if
c_cond
(paren
id|rsc
op_eq
l_int|NULL
op_logical_and
id|fsc
op_eq
l_int|NULL
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|cl
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|hfsc_class
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cl
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOBUFS
suffix:semicolon
id|memset
c_func
(paren
id|cl
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|hfsc_class
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rsc
op_ne
l_int|NULL
)paren
id|hfsc_change_rsc
c_func
(paren
id|cl
comma
id|rsc
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fsc
op_ne
l_int|NULL
)paren
id|hfsc_change_fsc
c_func
(paren
id|cl
comma
id|fsc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|usc
op_ne
l_int|NULL
)paren
id|hfsc_change_usc
c_func
(paren
id|cl
comma
id|usc
comma
l_int|0
)paren
suffix:semicolon
id|cl-&gt;refcnt
op_assign
l_int|1
suffix:semicolon
id|cl-&gt;classid
op_assign
id|classid
suffix:semicolon
id|cl-&gt;sched
op_assign
id|q
suffix:semicolon
id|cl-&gt;cl_parent
op_assign
id|parent
suffix:semicolon
id|cl-&gt;qdisc
op_assign
id|qdisc_create_dflt
c_func
(paren
id|sch-&gt;dev
comma
op_amp
id|pfifo_qdisc_ops
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cl-&gt;qdisc
op_eq
l_int|NULL
)paren
id|cl-&gt;qdisc
op_assign
op_amp
id|noop_qdisc
suffix:semicolon
id|cl-&gt;stats.lock
op_assign
op_amp
id|sch-&gt;dev-&gt;queue_lock
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|cl-&gt;children
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|cl-&gt;actlist
)paren
suffix:semicolon
id|sch_tree_lock
c_func
(paren
id|sch
)paren
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|cl-&gt;hlist
comma
op_amp
id|q-&gt;clhash
(braket
id|hfsc_hash
c_func
(paren
id|classid
)paren
)braket
)paren
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|cl-&gt;siblings
comma
op_amp
id|parent-&gt;children
)paren
suffix:semicolon
r_if
c_cond
(paren
id|parent-&gt;level
op_eq
l_int|0
)paren
id|hfsc_purge_queue
c_func
(paren
id|sch
comma
id|parent
)paren
suffix:semicolon
id|hfsc_adjust_levels
c_func
(paren
id|parent
)paren
suffix:semicolon
id|sch_tree_unlock
c_func
(paren
id|sch
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_NET_ESTIMATOR
r_if
c_cond
(paren
id|tca
(braket
id|TCA_RATE
op_minus
l_int|1
)braket
)paren
id|qdisc_new_estimator
c_func
(paren
op_amp
id|cl-&gt;stats
comma
id|tca
(braket
id|TCA_RATE
op_minus
l_int|1
)braket
)paren
suffix:semicolon
macro_line|#endif
op_star
id|arg
op_assign
(paren
r_int
r_int
)paren
id|cl
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_void
DECL|function|hfsc_destroy_filters
id|hfsc_destroy_filters
c_func
(paren
r_struct
id|tcf_proto
op_star
op_star
id|fl
)paren
(brace
r_struct
id|tcf_proto
op_star
id|tp
suffix:semicolon
r_while
c_loop
(paren
(paren
id|tp
op_assign
op_star
id|fl
)paren
op_ne
l_int|NULL
)paren
(brace
op_star
id|fl
op_assign
id|tp-&gt;next
suffix:semicolon
id|tcf_destroy
c_func
(paren
id|tp
)paren
suffix:semicolon
)brace
)brace
r_static
r_void
DECL|function|hfsc_destroy_class
id|hfsc_destroy_class
c_func
(paren
r_struct
id|Qdisc
op_star
id|sch
comma
r_struct
id|hfsc_class
op_star
id|cl
)paren
(brace
r_struct
id|hfsc_sched
op_star
id|q
op_assign
(paren
r_struct
id|hfsc_sched
op_star
)paren
id|sch-&gt;data
suffix:semicolon
id|hfsc_destroy_filters
c_func
(paren
op_amp
id|cl-&gt;filter_list
)paren
suffix:semicolon
id|qdisc_destroy
c_func
(paren
id|cl-&gt;qdisc
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_NET_ESTIMATOR
id|qdisc_kill_estimator
c_func
(paren
op_amp
id|cl-&gt;stats
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|cl
op_ne
op_amp
id|q-&gt;root
)paren
id|kfree
c_func
(paren
id|cl
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|hfsc_delete_class
id|hfsc_delete_class
c_func
(paren
r_struct
id|Qdisc
op_star
id|sch
comma
r_int
r_int
id|arg
)paren
(brace
r_struct
id|hfsc_sched
op_star
id|q
op_assign
(paren
r_struct
id|hfsc_sched
op_star
)paren
id|sch-&gt;data
suffix:semicolon
r_struct
id|hfsc_class
op_star
id|cl
op_assign
(paren
r_struct
id|hfsc_class
op_star
)paren
id|arg
suffix:semicolon
r_if
c_cond
(paren
id|cl-&gt;level
OG
l_int|0
op_logical_or
id|cl-&gt;filter_cnt
OG
l_int|0
op_logical_or
id|cl
op_eq
op_amp
id|q-&gt;root
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
id|sch_tree_lock
c_func
(paren
id|sch
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|cl-&gt;hlist
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|cl-&gt;siblings
)paren
suffix:semicolon
id|hfsc_adjust_levels
c_func
(paren
id|cl-&gt;cl_parent
)paren
suffix:semicolon
id|hfsc_purge_queue
c_func
(paren
id|sch
comma
id|cl
)paren
suffix:semicolon
r_if
c_cond
(paren
op_decrement
id|cl-&gt;refcnt
op_eq
l_int|0
)paren
id|hfsc_destroy_class
c_func
(paren
id|sch
comma
id|cl
)paren
suffix:semicolon
id|sch_tree_unlock
c_func
(paren
id|sch
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_struct
id|hfsc_class
op_star
DECL|function|hfsc_classify
id|hfsc_classify
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|Qdisc
op_star
id|sch
)paren
(brace
r_struct
id|hfsc_sched
op_star
id|q
op_assign
(paren
r_struct
id|hfsc_sched
op_star
)paren
id|sch-&gt;data
suffix:semicolon
r_struct
id|hfsc_class
op_star
id|cl
suffix:semicolon
r_struct
id|tcf_result
id|res
suffix:semicolon
r_struct
id|tcf_proto
op_star
id|tcf
suffix:semicolon
r_int
id|result
suffix:semicolon
r_if
c_cond
(paren
id|TC_H_MAJ
c_func
(paren
id|skb-&gt;priority
op_xor
id|sch-&gt;handle
)paren
op_eq
l_int|0
op_logical_and
(paren
id|cl
op_assign
id|hfsc_find_class
c_func
(paren
id|skb-&gt;priority
comma
id|sch
)paren
)paren
op_ne
l_int|NULL
)paren
r_if
c_cond
(paren
id|cl-&gt;level
op_eq
l_int|0
)paren
r_return
id|cl
suffix:semicolon
id|tcf
op_assign
id|q-&gt;root.filter_list
suffix:semicolon
r_while
c_loop
(paren
id|tcf
op_logical_and
(paren
id|result
op_assign
id|tc_classify
c_func
(paren
id|skb
comma
id|tcf
comma
op_amp
id|res
)paren
)paren
op_ge
l_int|0
)paren
(brace
macro_line|#ifdef CONFIG_NET_CLS_POLICE
r_if
c_cond
(paren
id|result
op_eq
id|TC_POLICE_SHOT
)paren
r_return
l_int|NULL
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
(paren
id|cl
op_assign
(paren
r_struct
id|hfsc_class
op_star
)paren
id|res
dot
r_class
)paren
op_eq
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
(paren
id|cl
op_assign
id|hfsc_find_class
c_func
(paren
id|res.classid
comma
id|sch
)paren
)paren
op_eq
l_int|NULL
)paren
r_break
suffix:semicolon
multiline_comment|/* filter selected invalid classid */
)brace
r_if
c_cond
(paren
id|cl-&gt;level
op_eq
l_int|0
)paren
r_return
id|cl
suffix:semicolon
multiline_comment|/* hit leaf class */
multiline_comment|/* apply inner filter chain */
id|tcf
op_assign
id|cl-&gt;filter_list
suffix:semicolon
)brace
multiline_comment|/* classification failed, try default class */
id|cl
op_assign
id|hfsc_find_class
c_func
(paren
id|TC_H_MAKE
c_func
(paren
id|TC_H_MAJ
c_func
(paren
id|sch-&gt;handle
)paren
comma
id|q-&gt;defcls
)paren
comma
id|sch
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cl
op_eq
l_int|NULL
op_logical_or
id|cl-&gt;level
OG
l_int|0
)paren
r_return
l_int|NULL
suffix:semicolon
r_return
id|cl
suffix:semicolon
)brace
r_static
r_int
DECL|function|hfsc_graft_class
id|hfsc_graft_class
c_func
(paren
r_struct
id|Qdisc
op_star
id|sch
comma
r_int
r_int
id|arg
comma
r_struct
id|Qdisc
op_star
r_new
comma
r_struct
id|Qdisc
op_star
op_star
id|old
)paren
(brace
r_struct
id|hfsc_class
op_star
id|cl
op_assign
(paren
r_struct
id|hfsc_class
op_star
)paren
id|arg
suffix:semicolon
r_if
c_cond
(paren
id|cl
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOENT
suffix:semicolon
r_if
c_cond
(paren
id|cl-&gt;level
OG
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
r_new
op_eq
l_int|NULL
)paren
(brace
r_new
op_assign
id|qdisc_create_dflt
c_func
(paren
id|sch-&gt;dev
comma
op_amp
id|pfifo_qdisc_ops
)paren
suffix:semicolon
r_if
c_cond
(paren
r_new
op_eq
l_int|NULL
)paren
r_new
op_assign
op_amp
id|noop_qdisc
suffix:semicolon
)brace
id|sch_tree_lock
c_func
(paren
id|sch
)paren
suffix:semicolon
id|hfsc_purge_queue
c_func
(paren
id|sch
comma
id|cl
)paren
suffix:semicolon
op_star
id|old
op_assign
id|xchg
c_func
(paren
op_amp
id|cl-&gt;qdisc
comma
r_new
)paren
suffix:semicolon
id|sch_tree_unlock
c_func
(paren
id|sch
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_struct
id|Qdisc
op_star
DECL|function|hfsc_class_leaf
id|hfsc_class_leaf
c_func
(paren
r_struct
id|Qdisc
op_star
id|sch
comma
r_int
r_int
id|arg
)paren
(brace
r_struct
id|hfsc_class
op_star
id|cl
op_assign
(paren
r_struct
id|hfsc_class
op_star
)paren
id|arg
suffix:semicolon
r_if
c_cond
(paren
id|cl
op_ne
l_int|NULL
op_logical_and
id|cl-&gt;level
op_eq
l_int|0
)paren
r_return
id|cl-&gt;qdisc
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_static
r_int
r_int
DECL|function|hfsc_get_class
id|hfsc_get_class
c_func
(paren
r_struct
id|Qdisc
op_star
id|sch
comma
id|u32
id|classid
)paren
(brace
r_struct
id|hfsc_class
op_star
id|cl
op_assign
id|hfsc_find_class
c_func
(paren
id|classid
comma
id|sch
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cl
op_ne
l_int|NULL
)paren
id|cl-&gt;refcnt
op_increment
suffix:semicolon
r_return
(paren
r_int
r_int
)paren
id|cl
suffix:semicolon
)brace
r_static
r_void
DECL|function|hfsc_put_class
id|hfsc_put_class
c_func
(paren
r_struct
id|Qdisc
op_star
id|sch
comma
r_int
r_int
id|arg
)paren
(brace
r_struct
id|hfsc_class
op_star
id|cl
op_assign
(paren
r_struct
id|hfsc_class
op_star
)paren
id|arg
suffix:semicolon
r_if
c_cond
(paren
op_decrement
id|cl-&gt;refcnt
op_eq
l_int|0
)paren
id|hfsc_destroy_class
c_func
(paren
id|sch
comma
id|cl
)paren
suffix:semicolon
)brace
r_static
r_int
r_int
DECL|function|hfsc_bind_tcf
id|hfsc_bind_tcf
c_func
(paren
r_struct
id|Qdisc
op_star
id|sch
comma
r_int
r_int
id|parent
comma
id|u32
id|classid
)paren
(brace
r_struct
id|hfsc_class
op_star
id|p
op_assign
(paren
r_struct
id|hfsc_class
op_star
)paren
id|parent
suffix:semicolon
r_struct
id|hfsc_class
op_star
id|cl
op_assign
id|hfsc_find_class
c_func
(paren
id|classid
comma
id|sch
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cl
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|p
op_ne
l_int|NULL
op_logical_and
id|p-&gt;level
op_le
id|cl-&gt;level
)paren
r_return
l_int|0
suffix:semicolon
id|cl-&gt;filter_cnt
op_increment
suffix:semicolon
)brace
r_return
(paren
r_int
r_int
)paren
id|cl
suffix:semicolon
)brace
r_static
r_void
DECL|function|hfsc_unbind_tcf
id|hfsc_unbind_tcf
c_func
(paren
r_struct
id|Qdisc
op_star
id|sch
comma
r_int
r_int
id|arg
)paren
(brace
r_struct
id|hfsc_class
op_star
id|cl
op_assign
(paren
r_struct
id|hfsc_class
op_star
)paren
id|arg
suffix:semicolon
id|cl-&gt;filter_cnt
op_decrement
suffix:semicolon
)brace
r_static
r_struct
id|tcf_proto
op_star
op_star
DECL|function|hfsc_tcf_chain
id|hfsc_tcf_chain
c_func
(paren
r_struct
id|Qdisc
op_star
id|sch
comma
r_int
r_int
id|arg
)paren
(brace
r_struct
id|hfsc_sched
op_star
id|q
op_assign
(paren
r_struct
id|hfsc_sched
op_star
)paren
id|sch-&gt;data
suffix:semicolon
r_struct
id|hfsc_class
op_star
id|cl
op_assign
(paren
r_struct
id|hfsc_class
op_star
)paren
id|arg
suffix:semicolon
r_if
c_cond
(paren
id|cl
op_eq
l_int|NULL
)paren
id|cl
op_assign
op_amp
id|q-&gt;root
suffix:semicolon
r_return
op_amp
id|cl-&gt;filter_list
suffix:semicolon
)brace
r_static
r_int
DECL|function|hfsc_dump_sc
id|hfsc_dump_sc
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|attr
comma
r_struct
id|internal_sc
op_star
id|sc
)paren
(brace
r_struct
id|tc_service_curve
id|tsc
suffix:semicolon
id|tsc.m1
op_assign
id|sm2m
c_func
(paren
id|sc-&gt;sm1
)paren
suffix:semicolon
id|tsc.d
op_assign
id|dx2d
c_func
(paren
id|sc-&gt;dx
)paren
suffix:semicolon
id|tsc.m2
op_assign
id|sm2m
c_func
(paren
id|sc-&gt;sm2
)paren
suffix:semicolon
id|RTA_PUT
c_func
(paren
id|skb
comma
id|attr
comma
r_sizeof
(paren
id|tsc
)paren
comma
op_amp
id|tsc
)paren
suffix:semicolon
r_return
id|skb-&gt;len
suffix:semicolon
id|rtattr_failure
suffix:colon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_static
r_inline
r_int
DECL|function|hfsc_dump_curves
id|hfsc_dump_curves
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|hfsc_class
op_star
id|cl
)paren
(brace
r_if
c_cond
(paren
(paren
id|cl-&gt;cl_flags
op_amp
id|HFSC_RSC
)paren
op_logical_and
(paren
id|hfsc_dump_sc
c_func
(paren
id|skb
comma
id|TCA_HFSC_RSC
comma
op_amp
id|cl-&gt;cl_rsc
)paren
OL
l_int|0
)paren
)paren
r_goto
id|rtattr_failure
suffix:semicolon
r_if
c_cond
(paren
(paren
id|cl-&gt;cl_flags
op_amp
id|HFSC_FSC
)paren
op_logical_and
(paren
id|hfsc_dump_sc
c_func
(paren
id|skb
comma
id|TCA_HFSC_FSC
comma
op_amp
id|cl-&gt;cl_fsc
)paren
OL
l_int|0
)paren
)paren
r_goto
id|rtattr_failure
suffix:semicolon
r_if
c_cond
(paren
(paren
id|cl-&gt;cl_flags
op_amp
id|HFSC_USC
)paren
op_logical_and
(paren
id|hfsc_dump_sc
c_func
(paren
id|skb
comma
id|TCA_HFSC_USC
comma
op_amp
id|cl-&gt;cl_usc
)paren
OL
l_int|0
)paren
)paren
r_goto
id|rtattr_failure
suffix:semicolon
r_return
id|skb-&gt;len
suffix:semicolon
id|rtattr_failure
suffix:colon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_static
r_inline
r_int
DECL|function|hfsc_dump_stats
id|hfsc_dump_stats
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|hfsc_class
op_star
id|cl
)paren
(brace
id|cl-&gt;stats.qlen
op_assign
id|cl-&gt;qdisc-&gt;q.qlen
suffix:semicolon
r_if
c_cond
(paren
id|qdisc_copy_stats
c_func
(paren
id|skb
comma
op_amp
id|cl-&gt;stats
)paren
OL
l_int|0
)paren
r_goto
id|rtattr_failure
suffix:semicolon
r_return
id|skb-&gt;len
suffix:semicolon
id|rtattr_failure
suffix:colon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_static
r_inline
r_int
DECL|function|hfsc_dump_xstats
id|hfsc_dump_xstats
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|hfsc_class
op_star
id|cl
)paren
(brace
r_struct
id|tc_hfsc_stats
id|xstats
suffix:semicolon
id|xstats.level
op_assign
id|cl-&gt;level
suffix:semicolon
id|xstats.period
op_assign
id|cl-&gt;cl_vtperiod
suffix:semicolon
id|xstats.work
op_assign
id|cl-&gt;cl_total
suffix:semicolon
id|xstats.rtwork
op_assign
id|cl-&gt;cl_cumul
suffix:semicolon
id|RTA_PUT
c_func
(paren
id|skb
comma
id|TCA_XSTATS
comma
r_sizeof
(paren
id|xstats
)paren
comma
op_amp
id|xstats
)paren
suffix:semicolon
r_return
id|skb-&gt;len
suffix:semicolon
id|rtattr_failure
suffix:colon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_static
r_int
DECL|function|hfsc_dump_class
id|hfsc_dump_class
c_func
(paren
r_struct
id|Qdisc
op_star
id|sch
comma
r_int
r_int
id|arg
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|tcmsg
op_star
id|tcm
)paren
(brace
r_struct
id|hfsc_class
op_star
id|cl
op_assign
(paren
r_struct
id|hfsc_class
op_star
)paren
id|arg
suffix:semicolon
r_int
r_char
op_star
id|b
op_assign
id|skb-&gt;tail
suffix:semicolon
r_struct
id|rtattr
op_star
id|rta
op_assign
(paren
r_struct
id|rtattr
op_star
)paren
id|b
suffix:semicolon
id|tcm-&gt;tcm_parent
op_assign
id|cl-&gt;cl_parent
ques
c_cond
id|cl-&gt;cl_parent-&gt;classid
suffix:colon
id|TC_H_ROOT
suffix:semicolon
id|tcm-&gt;tcm_handle
op_assign
id|cl-&gt;classid
suffix:semicolon
r_if
c_cond
(paren
id|cl-&gt;level
op_eq
l_int|0
)paren
id|tcm-&gt;tcm_info
op_assign
id|cl-&gt;qdisc-&gt;handle
suffix:semicolon
id|RTA_PUT
c_func
(paren
id|skb
comma
id|TCA_OPTIONS
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hfsc_dump_curves
c_func
(paren
id|skb
comma
id|cl
)paren
OL
l_int|0
)paren
r_goto
id|rtattr_failure
suffix:semicolon
id|rta-&gt;rta_len
op_assign
id|skb-&gt;tail
op_minus
id|b
suffix:semicolon
r_if
c_cond
(paren
(paren
id|hfsc_dump_stats
c_func
(paren
id|skb
comma
id|cl
)paren
OL
l_int|0
)paren
op_logical_or
(paren
id|hfsc_dump_xstats
c_func
(paren
id|skb
comma
id|cl
)paren
OL
l_int|0
)paren
)paren
r_goto
id|rtattr_failure
suffix:semicolon
r_return
id|skb-&gt;len
suffix:semicolon
id|rtattr_failure
suffix:colon
id|skb_trim
c_func
(paren
id|skb
comma
id|b
op_minus
id|skb-&gt;data
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_static
r_void
DECL|function|hfsc_walk
id|hfsc_walk
c_func
(paren
r_struct
id|Qdisc
op_star
id|sch
comma
r_struct
id|qdisc_walker
op_star
id|arg
)paren
(brace
r_struct
id|hfsc_sched
op_star
id|q
op_assign
(paren
r_struct
id|hfsc_sched
op_star
)paren
id|sch-&gt;data
suffix:semicolon
r_struct
id|hfsc_class
op_star
id|cl
suffix:semicolon
r_int
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|arg-&gt;stop
)paren
r_return
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|HFSC_HSIZE
suffix:semicolon
id|i
op_increment
)paren
(brace
id|list_for_each_entry
c_func
(paren
id|cl
comma
op_amp
id|q-&gt;clhash
(braket
id|i
)braket
comma
id|hlist
)paren
(brace
r_if
c_cond
(paren
id|arg-&gt;count
OL
id|arg-&gt;skip
)paren
(brace
id|arg-&gt;count
op_increment
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|arg
op_member_access_from_pointer
id|fn
c_func
(paren
id|sch
comma
(paren
r_int
r_int
)paren
id|cl
comma
id|arg
)paren
OL
l_int|0
)paren
(brace
id|arg-&gt;stop
op_assign
l_int|1
suffix:semicolon
r_return
suffix:semicolon
)brace
id|arg-&gt;count
op_increment
suffix:semicolon
)brace
)brace
)brace
r_static
r_void
DECL|function|hfsc_watchdog
id|hfsc_watchdog
c_func
(paren
r_int
r_int
id|arg
)paren
(brace
r_struct
id|Qdisc
op_star
id|sch
op_assign
(paren
r_struct
id|Qdisc
op_star
)paren
id|arg
suffix:semicolon
id|sch-&gt;flags
op_and_assign
op_complement
id|TCQ_F_THROTTLED
suffix:semicolon
id|netif_schedule
c_func
(paren
id|sch-&gt;dev
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|hfsc_schedule_watchdog
id|hfsc_schedule_watchdog
c_func
(paren
r_struct
id|Qdisc
op_star
id|sch
comma
id|u64
id|cur_time
)paren
(brace
r_struct
id|hfsc_sched
op_star
id|q
op_assign
(paren
r_struct
id|hfsc_sched
op_star
)paren
id|sch-&gt;data
suffix:semicolon
r_struct
id|hfsc_class
op_star
id|cl
suffix:semicolon
id|u64
id|next_time
op_assign
l_int|0
suffix:semicolon
r_int
id|delay
suffix:semicolon
r_if
c_cond
(paren
(paren
id|cl
op_assign
id|ellist_get_minel
c_func
(paren
op_amp
id|q-&gt;eligible
)paren
)paren
op_ne
l_int|NULL
)paren
id|next_time
op_assign
id|cl-&gt;cl_e
suffix:semicolon
r_if
c_cond
(paren
id|q-&gt;root.cl_cfmin
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|next_time
op_eq
l_int|0
op_logical_or
id|next_time
OG
id|q-&gt;root.cl_cfmin
)paren
id|next_time
op_assign
id|q-&gt;root.cl_cfmin
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|next_time
op_ne
l_int|0
)paren
suffix:semicolon
id|delay
op_assign
id|next_time
op_minus
id|cur_time
suffix:semicolon
id|delay
op_assign
id|PSCHED_US2JIFFIE
c_func
(paren
id|delay
)paren
suffix:semicolon
id|sch-&gt;flags
op_or_assign
id|TCQ_F_THROTTLED
suffix:semicolon
id|mod_timer
c_func
(paren
op_amp
id|q-&gt;wd_timer
comma
id|jiffies
op_plus
id|delay
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|hfsc_init_qdisc
id|hfsc_init_qdisc
c_func
(paren
r_struct
id|Qdisc
op_star
id|sch
comma
r_struct
id|rtattr
op_star
id|opt
)paren
(brace
r_struct
id|hfsc_sched
op_star
id|q
op_assign
(paren
r_struct
id|hfsc_sched
op_star
)paren
id|sch-&gt;data
suffix:semicolon
r_struct
id|tc_hfsc_qopt
op_star
id|qopt
suffix:semicolon
r_int
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|opt
op_eq
l_int|NULL
op_logical_or
id|RTA_PAYLOAD
c_func
(paren
id|opt
)paren
OL
r_sizeof
(paren
op_star
id|qopt
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|qopt
op_assign
id|RTA_DATA
c_func
(paren
id|opt
)paren
suffix:semicolon
id|memset
c_func
(paren
id|q
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|hfsc_sched
)paren
)paren
suffix:semicolon
id|sch-&gt;stats.lock
op_assign
op_amp
id|sch-&gt;dev-&gt;queue_lock
suffix:semicolon
id|q-&gt;defcls
op_assign
id|qopt-&gt;defcls
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|HFSC_HSIZE
suffix:semicolon
id|i
op_increment
)paren
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|q-&gt;clhash
(braket
id|i
)braket
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|q-&gt;eligible
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|q-&gt;droplist
)paren
suffix:semicolon
id|skb_queue_head_init
c_func
(paren
op_amp
id|q-&gt;requeue
)paren
suffix:semicolon
id|q-&gt;root.refcnt
op_assign
l_int|1
suffix:semicolon
id|q-&gt;root.classid
op_assign
id|sch-&gt;handle
suffix:semicolon
id|q-&gt;root.sched
op_assign
id|q
suffix:semicolon
id|q-&gt;root.qdisc
op_assign
id|qdisc_create_dflt
c_func
(paren
id|sch-&gt;dev
comma
op_amp
id|pfifo_qdisc_ops
)paren
suffix:semicolon
r_if
c_cond
(paren
id|q-&gt;root.qdisc
op_eq
l_int|NULL
)paren
id|q-&gt;root.qdisc
op_assign
op_amp
id|noop_qdisc
suffix:semicolon
id|q-&gt;root.stats.lock
op_assign
op_amp
id|sch-&gt;dev-&gt;queue_lock
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|q-&gt;root.children
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|q-&gt;root.actlist
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|q-&gt;root.hlist
comma
op_amp
id|q-&gt;clhash
(braket
id|hfsc_hash
c_func
(paren
id|q-&gt;root.classid
)paren
)braket
)paren
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|q-&gt;wd_timer
)paren
suffix:semicolon
id|q-&gt;wd_timer.function
op_assign
id|hfsc_watchdog
suffix:semicolon
id|q-&gt;wd_timer.data
op_assign
(paren
r_int
r_int
)paren
id|sch
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|hfsc_change_qdisc
id|hfsc_change_qdisc
c_func
(paren
r_struct
id|Qdisc
op_star
id|sch
comma
r_struct
id|rtattr
op_star
id|opt
)paren
(brace
r_struct
id|hfsc_sched
op_star
id|q
op_assign
(paren
r_struct
id|hfsc_sched
op_star
)paren
id|sch-&gt;data
suffix:semicolon
r_struct
id|tc_hfsc_qopt
op_star
id|qopt
suffix:semicolon
r_if
c_cond
(paren
id|opt
op_eq
l_int|NULL
op_logical_or
id|RTA_PAYLOAD
c_func
(paren
id|opt
)paren
OL
r_sizeof
(paren
op_star
id|qopt
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|qopt
op_assign
id|RTA_DATA
c_func
(paren
id|opt
)paren
suffix:semicolon
id|sch_tree_lock
c_func
(paren
id|sch
)paren
suffix:semicolon
id|q-&gt;defcls
op_assign
id|qopt-&gt;defcls
suffix:semicolon
id|sch_tree_unlock
c_func
(paren
id|sch
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_void
DECL|function|hfsc_reset_class
id|hfsc_reset_class
c_func
(paren
r_struct
id|hfsc_class
op_star
id|cl
)paren
(brace
id|cl-&gt;cl_total
op_assign
l_int|0
suffix:semicolon
id|cl-&gt;cl_cumul
op_assign
l_int|0
suffix:semicolon
id|cl-&gt;cl_d
op_assign
l_int|0
suffix:semicolon
id|cl-&gt;cl_e
op_assign
l_int|0
suffix:semicolon
id|cl-&gt;cl_vt
op_assign
l_int|0
suffix:semicolon
id|cl-&gt;cl_vtadj
op_assign
l_int|0
suffix:semicolon
id|cl-&gt;cl_vtoff
op_assign
l_int|0
suffix:semicolon
id|cl-&gt;cl_cvtmin
op_assign
l_int|0
suffix:semicolon
id|cl-&gt;cl_cvtmax
op_assign
l_int|0
suffix:semicolon
id|cl-&gt;cl_vtperiod
op_assign
l_int|0
suffix:semicolon
id|cl-&gt;cl_parentperiod
op_assign
l_int|0
suffix:semicolon
id|cl-&gt;cl_f
op_assign
l_int|0
suffix:semicolon
id|cl-&gt;cl_myf
op_assign
l_int|0
suffix:semicolon
id|cl-&gt;cl_myfadj
op_assign
l_int|0
suffix:semicolon
id|cl-&gt;cl_cfmin
op_assign
l_int|0
suffix:semicolon
id|cl-&gt;cl_nactive
op_assign
l_int|0
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|cl-&gt;actlist
)paren
suffix:semicolon
id|qdisc_reset
c_func
(paren
id|cl-&gt;qdisc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cl-&gt;cl_flags
op_amp
id|HFSC_RSC
)paren
id|rtsc_init
c_func
(paren
op_amp
id|cl-&gt;cl_deadline
comma
op_amp
id|cl-&gt;cl_rsc
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cl-&gt;cl_flags
op_amp
id|HFSC_FSC
)paren
id|rtsc_init
c_func
(paren
op_amp
id|cl-&gt;cl_virtual
comma
op_amp
id|cl-&gt;cl_fsc
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cl-&gt;cl_flags
op_amp
id|HFSC_USC
)paren
id|rtsc_init
c_func
(paren
op_amp
id|cl-&gt;cl_ulimit
comma
op_amp
id|cl-&gt;cl_usc
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|hfsc_reset_qdisc
id|hfsc_reset_qdisc
c_func
(paren
r_struct
id|Qdisc
op_star
id|sch
)paren
(brace
r_struct
id|hfsc_sched
op_star
id|q
op_assign
(paren
r_struct
id|hfsc_sched
op_star
)paren
id|sch-&gt;data
suffix:semicolon
r_struct
id|hfsc_class
op_star
id|cl
suffix:semicolon
r_int
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|HFSC_HSIZE
suffix:semicolon
id|i
op_increment
)paren
(brace
id|list_for_each_entry
c_func
(paren
id|cl
comma
op_amp
id|q-&gt;clhash
(braket
id|i
)braket
comma
id|hlist
)paren
id|hfsc_reset_class
c_func
(paren
id|cl
)paren
suffix:semicolon
)brace
id|__skb_queue_purge
c_func
(paren
op_amp
id|q-&gt;requeue
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|q-&gt;eligible
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|q-&gt;droplist
)paren
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|q-&gt;wd_timer
)paren
suffix:semicolon
id|sch-&gt;flags
op_and_assign
op_complement
id|TCQ_F_THROTTLED
suffix:semicolon
id|sch-&gt;q.qlen
op_assign
l_int|0
suffix:semicolon
)brace
r_static
r_void
DECL|function|hfsc_destroy_qdisc
id|hfsc_destroy_qdisc
c_func
(paren
r_struct
id|Qdisc
op_star
id|sch
)paren
(brace
r_struct
id|hfsc_sched
op_star
id|q
op_assign
(paren
r_struct
id|hfsc_sched
op_star
)paren
id|sch-&gt;data
suffix:semicolon
r_struct
id|hfsc_class
op_star
id|cl
comma
op_star
id|next
suffix:semicolon
r_int
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|HFSC_HSIZE
suffix:semicolon
id|i
op_increment
)paren
(brace
id|list_for_each_entry_safe
c_func
(paren
id|cl
comma
id|next
comma
op_amp
id|q-&gt;clhash
(braket
id|i
)braket
comma
id|hlist
)paren
id|hfsc_destroy_class
c_func
(paren
id|sch
comma
id|cl
)paren
suffix:semicolon
)brace
id|__skb_queue_purge
c_func
(paren
op_amp
id|q-&gt;requeue
)paren
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|q-&gt;wd_timer
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|hfsc_dump_qdisc
id|hfsc_dump_qdisc
c_func
(paren
r_struct
id|Qdisc
op_star
id|sch
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|hfsc_sched
op_star
id|q
op_assign
(paren
r_struct
id|hfsc_sched
op_star
)paren
id|sch-&gt;data
suffix:semicolon
r_int
r_char
op_star
id|b
op_assign
id|skb-&gt;tail
suffix:semicolon
r_struct
id|tc_hfsc_qopt
id|qopt
suffix:semicolon
id|qopt.defcls
op_assign
id|q-&gt;defcls
suffix:semicolon
id|RTA_PUT
c_func
(paren
id|skb
comma
id|TCA_OPTIONS
comma
r_sizeof
(paren
id|qopt
)paren
comma
op_amp
id|qopt
)paren
suffix:semicolon
id|sch-&gt;stats.qlen
op_assign
id|sch-&gt;q.qlen
suffix:semicolon
r_if
c_cond
(paren
id|qdisc_copy_stats
c_func
(paren
id|skb
comma
op_amp
id|sch-&gt;stats
)paren
OL
l_int|0
)paren
r_goto
id|rtattr_failure
suffix:semicolon
r_return
id|skb-&gt;len
suffix:semicolon
id|rtattr_failure
suffix:colon
id|skb_trim
c_func
(paren
id|skb
comma
id|b
op_minus
id|skb-&gt;data
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_static
r_int
DECL|function|hfsc_enqueue
id|hfsc_enqueue
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|Qdisc
op_star
id|sch
)paren
(brace
r_struct
id|hfsc_class
op_star
id|cl
op_assign
id|hfsc_classify
c_func
(paren
id|skb
comma
id|sch
)paren
suffix:semicolon
r_int
r_int
id|len
op_assign
id|skb-&gt;len
suffix:semicolon
r_int
id|err
suffix:semicolon
r_if
c_cond
(paren
id|cl
op_eq
l_int|NULL
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
id|sch-&gt;stats.drops
op_increment
suffix:semicolon
r_return
id|NET_XMIT_DROP
suffix:semicolon
)brace
id|err
op_assign
id|cl-&gt;qdisc
op_member_access_from_pointer
id|enqueue
c_func
(paren
id|skb
comma
id|cl-&gt;qdisc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|err
op_ne
id|NET_XMIT_SUCCESS
)paren
)paren
(brace
id|cl-&gt;stats.drops
op_increment
suffix:semicolon
id|sch-&gt;stats.drops
op_increment
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cl-&gt;qdisc-&gt;q.qlen
op_eq
l_int|1
)paren
id|set_active
c_func
(paren
id|cl
comma
id|len
)paren
suffix:semicolon
id|cl-&gt;stats.packets
op_increment
suffix:semicolon
id|cl-&gt;stats.bytes
op_add_assign
id|len
suffix:semicolon
id|sch-&gt;stats.packets
op_increment
suffix:semicolon
id|sch-&gt;stats.bytes
op_add_assign
id|len
suffix:semicolon
id|sch-&gt;q.qlen
op_increment
suffix:semicolon
r_return
id|NET_XMIT_SUCCESS
suffix:semicolon
)brace
r_static
r_struct
id|sk_buff
op_star
DECL|function|hfsc_dequeue
id|hfsc_dequeue
c_func
(paren
r_struct
id|Qdisc
op_star
id|sch
)paren
(brace
r_struct
id|hfsc_sched
op_star
id|q
op_assign
(paren
r_struct
id|hfsc_sched
op_star
)paren
id|sch-&gt;data
suffix:semicolon
r_struct
id|hfsc_class
op_star
id|cl
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
id|u64
id|cur_time
suffix:semicolon
r_int
r_int
id|next_len
suffix:semicolon
r_int
id|realtime
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|sch-&gt;q.qlen
op_eq
l_int|0
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
(paren
id|skb
op_assign
id|__skb_dequeue
c_func
(paren
op_amp
id|q-&gt;requeue
)paren
)paren
)paren
r_goto
id|out
suffix:semicolon
id|PSCHED_GET_TIME
c_func
(paren
id|cur_time
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * if there are eligible classes, use real-time criteria.&n;&t; * find the class with the minimum deadline among&n;&t; * the eligible classes.&n;&t; */
r_if
c_cond
(paren
(paren
id|cl
op_assign
id|ellist_get_mindl
c_func
(paren
op_amp
id|q-&gt;eligible
comma
id|cur_time
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|realtime
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * use link-sharing criteria&n;&t;&t; * get the class with the minimum vt in the hierarchy&n;&t;&t; */
id|cl
op_assign
id|actlist_get_minvt
c_func
(paren
op_amp
id|q-&gt;root
comma
id|cur_time
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cl
op_eq
l_int|NULL
)paren
(brace
id|sch-&gt;stats.overlimits
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|netif_queue_stopped
c_func
(paren
id|sch-&gt;dev
)paren
)paren
id|hfsc_schedule_watchdog
c_func
(paren
id|sch
comma
id|cur_time
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
)brace
id|skb
op_assign
id|cl-&gt;qdisc
op_member_access_from_pointer
id|dequeue
c_func
(paren
id|cl-&gt;qdisc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|net_ratelimit
c_func
(paren
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;HFSC: Non-work-conserving qdisc ?&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|update_vf
c_func
(paren
id|cl
comma
id|skb-&gt;len
comma
id|cur_time
)paren
suffix:semicolon
r_if
c_cond
(paren
id|realtime
)paren
id|cl-&gt;cl_cumul
op_add_assign
id|skb-&gt;len
suffix:semicolon
r_if
c_cond
(paren
id|cl-&gt;qdisc-&gt;q.qlen
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|cl-&gt;cl_flags
op_amp
id|HFSC_RSC
)paren
(brace
multiline_comment|/* update ed */
id|next_len
op_assign
id|qdisc_peek_len
c_func
(paren
id|cl-&gt;qdisc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|realtime
)paren
id|update_ed
c_func
(paren
id|cl
comma
id|next_len
)paren
suffix:semicolon
r_else
id|update_d
c_func
(paren
id|cl
comma
id|next_len
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* the class becomes passive */
id|set_passive
c_func
(paren
id|cl
)paren
suffix:semicolon
)brace
id|out
suffix:colon
id|sch-&gt;flags
op_and_assign
op_complement
id|TCQ_F_THROTTLED
suffix:semicolon
id|sch-&gt;q.qlen
op_decrement
suffix:semicolon
r_return
id|skb
suffix:semicolon
)brace
r_static
r_int
DECL|function|hfsc_requeue
id|hfsc_requeue
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|Qdisc
op_star
id|sch
)paren
(brace
r_struct
id|hfsc_sched
op_star
id|q
op_assign
(paren
r_struct
id|hfsc_sched
op_star
)paren
id|sch-&gt;data
suffix:semicolon
id|__skb_queue_head
c_func
(paren
op_amp
id|q-&gt;requeue
comma
id|skb
)paren
suffix:semicolon
id|sch-&gt;q.qlen
op_increment
suffix:semicolon
r_return
id|NET_XMIT_SUCCESS
suffix:semicolon
)brace
r_static
r_int
r_int
DECL|function|hfsc_drop
id|hfsc_drop
c_func
(paren
r_struct
id|Qdisc
op_star
id|sch
)paren
(brace
r_struct
id|hfsc_sched
op_star
id|q
op_assign
(paren
r_struct
id|hfsc_sched
op_star
)paren
id|sch-&gt;data
suffix:semicolon
r_struct
id|hfsc_class
op_star
id|cl
suffix:semicolon
r_int
r_int
id|len
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|cl
comma
op_amp
id|q-&gt;droplist
comma
id|dlist
)paren
(brace
r_if
c_cond
(paren
id|cl-&gt;qdisc-&gt;ops-&gt;drop
op_ne
l_int|NULL
op_logical_and
(paren
id|len
op_assign
id|cl-&gt;qdisc-&gt;ops
op_member_access_from_pointer
id|drop
c_func
(paren
id|cl-&gt;qdisc
)paren
)paren
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|cl-&gt;qdisc-&gt;q.qlen
op_eq
l_int|0
)paren
(brace
id|update_vf
c_func
(paren
id|cl
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|set_passive
c_func
(paren
id|cl
)paren
suffix:semicolon
)brace
r_else
(brace
id|list_move_tail
c_func
(paren
op_amp
id|cl-&gt;dlist
comma
op_amp
id|q-&gt;droplist
)paren
suffix:semicolon
)brace
id|cl-&gt;stats.drops
op_increment
suffix:semicolon
id|sch-&gt;stats.drops
op_increment
suffix:semicolon
id|sch-&gt;q.qlen
op_decrement
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|hfsc_class_ops
r_static
r_struct
id|Qdisc_class_ops
id|hfsc_class_ops
op_assign
(brace
dot
id|change
op_assign
id|hfsc_change_class
comma
dot
r_delete
op_assign
id|hfsc_delete_class
comma
dot
id|graft
op_assign
id|hfsc_graft_class
comma
dot
id|leaf
op_assign
id|hfsc_class_leaf
comma
dot
id|get
op_assign
id|hfsc_get_class
comma
dot
id|put
op_assign
id|hfsc_put_class
comma
dot
id|bind_tcf
op_assign
id|hfsc_bind_tcf
comma
dot
id|unbind_tcf
op_assign
id|hfsc_unbind_tcf
comma
dot
id|tcf_chain
op_assign
id|hfsc_tcf_chain
comma
dot
id|dump
op_assign
id|hfsc_dump_class
comma
dot
id|walk
op_assign
id|hfsc_walk
)brace
suffix:semicolon
DECL|variable|hfsc_qdisc_ops
r_static
r_struct
id|Qdisc_ops
id|hfsc_qdisc_ops
op_assign
(brace
dot
id|id
op_assign
l_string|&quot;hfsc&quot;
comma
dot
id|init
op_assign
id|hfsc_init_qdisc
comma
dot
id|change
op_assign
id|hfsc_change_qdisc
comma
dot
id|reset
op_assign
id|hfsc_reset_qdisc
comma
dot
id|destroy
op_assign
id|hfsc_destroy_qdisc
comma
dot
id|dump
op_assign
id|hfsc_dump_qdisc
comma
dot
id|enqueue
op_assign
id|hfsc_enqueue
comma
dot
id|dequeue
op_assign
id|hfsc_dequeue
comma
dot
id|requeue
op_assign
id|hfsc_requeue
comma
dot
id|drop
op_assign
id|hfsc_drop
comma
dot
id|cl_ops
op_assign
op_amp
id|hfsc_class_ops
comma
dot
id|priv_size
op_assign
r_sizeof
(paren
r_struct
id|hfsc_sched
)paren
comma
dot
id|owner
op_assign
id|THIS_MODULE
)brace
suffix:semicolon
r_static
r_int
id|__init
DECL|function|hfsc_init
id|hfsc_init
c_func
(paren
r_void
)paren
(brace
r_return
id|register_qdisc
c_func
(paren
op_amp
id|hfsc_qdisc_ops
)paren
suffix:semicolon
)brace
r_static
r_void
id|__exit
DECL|function|hfsc_cleanup
id|hfsc_cleanup
c_func
(paren
r_void
)paren
(brace
id|unregister_qdisc
c_func
(paren
op_amp
id|hfsc_qdisc_ops
)paren
suffix:semicolon
)brace
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
DECL|variable|hfsc_init
id|module_init
c_func
(paren
id|hfsc_init
)paren
suffix:semicolon
DECL|variable|hfsc_cleanup
id|module_exit
c_func
(paren
id|hfsc_cleanup
)paren
suffix:semicolon
eof
