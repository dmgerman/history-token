multiline_comment|/* vim: ts=8 sw=8&n; * net/sched/sch_htb.c&t;Hierarchical token bucket, feed tree version&n; *&n; *&t;&t;This program is free software; you can redistribute it and/or&n; *&t;&t;modify it under the terms of the GNU General Public License&n; *&t;&t;as published by the Free Software Foundation; either version&n; *&t;&t;2 of the License, or (at your option) any later version.&n; *&n; * Authors:&t;Martin Devera, &lt;devik@cdi.cz&gt;&n; *&n; * Credits (in time order) for older HTB versions:&n; *              Stef Coene &lt;stef.coene@docum.org&gt;&n; *&t;&t;&t;HTB support at LARTC mailing list&n; *&t;&t;Ondrej Kraus, &lt;krauso@barr.cz&gt; &n; *&t;&t;&t;found missing INIT_QDISC(htb)&n; *&t;&t;Vladimir Smelhaus, Aamer Akhter, Bert Hubert&n; *&t;&t;&t;helped a lot to locate nasty class stall bug&n; *&t;&t;Andi Kleen, Jamal Hadi, Bert Hubert&n; *&t;&t;&t;code review and helpful comments on shaping&n; *&t;&t;Tomasz Wrona, &lt;tw@eter.tym.pl&gt;&n; *&t;&t;&t;created test case so that I was able to fix nasty bug&n; *&t;&t;Wilfried Weissmann&n; *&t;&t;&t;spotted bug in dequeue code and helped with fix&n; *&t;&t;and many others. thanks.&n; *&n; * $Id: sch_htb.c,v 1.24 2003/07/28 15:25:23 devik Exp devik $&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/socket.h&gt;
macro_line|#include &lt;linux/sockios.h&gt;
macro_line|#include &lt;linux/in.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/if_ether.h&gt;
macro_line|#include &lt;linux/inet.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/etherdevice.h&gt;
macro_line|#include &lt;linux/notifier.h&gt;
macro_line|#include &lt;net/ip.h&gt;
macro_line|#include &lt;net/route.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;linux/list.h&gt;
macro_line|#include &lt;linux/compiler.h&gt;
macro_line|#include &lt;net/sock.h&gt;
macro_line|#include &lt;net/pkt_sched.h&gt;
macro_line|#include &lt;linux/rbtree.h&gt;
multiline_comment|/* HTB algorithm.&n;    Author: devik@cdi.cz&n;    ========================================================================&n;    HTB is like TBF with multiple classes. It is also similar to CBQ because&n;    it allows to assign priority to each class in hierarchy. &n;    In fact it is another implementation of Floyd&squot;s formal sharing.&n;&n;    Levels:&n;    Each class is assigned level. Leaf has ALWAYS level 0 and root &n;    classes have level TC_HTB_MAXDEPTH-1. Interior nodes has level&n;    one less than their parent.&n;*/
DECL|macro|HTB_HSIZE
mdefine_line|#define HTB_HSIZE 16&t;/* classid hash size */
DECL|macro|HTB_EWMAC
mdefine_line|#define HTB_EWMAC 2&t;/* rate average over HTB_EWMAC*HTB_HSIZE sec */
DECL|macro|HTB_DEBUG
mdefine_line|#define HTB_DEBUG 1&t;/* compile debugging support (activated by tc tool) */
DECL|macro|HTB_RATECM
mdefine_line|#define HTB_RATECM 1    /* whether to use rate computer */
DECL|macro|HTB_HYSTERESIS
mdefine_line|#define HTB_HYSTERESIS 1/* whether to use mode hysteresis for speedup */
DECL|macro|HTB_QLOCK
mdefine_line|#define HTB_QLOCK(S) spin_lock_bh(&amp;(S)-&gt;dev-&gt;queue_lock)
DECL|macro|HTB_QUNLOCK
mdefine_line|#define HTB_QUNLOCK(S) spin_unlock_bh(&amp;(S)-&gt;dev-&gt;queue_lock)
DECL|macro|HTB_VER
mdefine_line|#define HTB_VER 0x3000f&t;/* major must be matched with number suplied by TC as version */
macro_line|#if HTB_VER &gt;&gt; 16 != TC_HTB_PROTOVER
macro_line|#error &quot;Mismatched sch_htb.c and pkt_sch.h&quot;
macro_line|#endif
multiline_comment|/* debugging support; S is subsystem, these are defined:&n;  0 - netlink messages&n;  1 - enqueue&n;  2 - drop &amp; requeue&n;  3 - dequeue main&n;  4 - dequeue one prio DRR part&n;  5 - dequeue class accounting&n;  6 - class overlimit status computation&n;  7 - hint tree&n;  8 - event queue&n; 10 - rate estimator&n; 11 - classifier &n; 12 - fast dequeue cache&n;&n; L is level; 0 = none, 1 = basic info, 2 = detailed, 3 = full&n; q-&gt;debug uint32 contains 16 2-bit fields one for subsystem starting&n; from LSB&n; */
macro_line|#ifdef HTB_DEBUG
DECL|macro|HTB_DBG_COND
mdefine_line|#define HTB_DBG_COND(S,L) (((q-&gt;debug&gt;&gt;(2*S))&amp;3) &gt;= L)
DECL|macro|HTB_DBG
mdefine_line|#define HTB_DBG(S,L,FMT,ARG...) if (HTB_DBG_COND(S,L)) &bslash;&n;&t;printk(KERN_DEBUG FMT,##ARG)
DECL|macro|HTB_CHCL
mdefine_line|#define HTB_CHCL(cl) BUG_TRAP((cl)-&gt;magic == HTB_CMAGIC)
DECL|macro|HTB_PASSQ
mdefine_line|#define HTB_PASSQ q,
DECL|macro|HTB_ARGQ
mdefine_line|#define HTB_ARGQ struct htb_sched *q,
DECL|macro|static
mdefine_line|#define static
DECL|macro|__inline__
macro_line|#undef __inline__
DECL|macro|__inline__
mdefine_line|#define __inline__
DECL|macro|inline
macro_line|#undef inline
DECL|macro|inline
mdefine_line|#define inline
DECL|macro|HTB_CMAGIC
mdefine_line|#define HTB_CMAGIC 0xFEFAFEF1
DECL|macro|htb_safe_rb_erase
mdefine_line|#define htb_safe_rb_erase(N,R) do { BUG_TRAP((N)-&gt;rb_color != -1); &bslash;&n;&t;&t;if ((N)-&gt;rb_color == -1) break; &bslash;&n;&t;&t;rb_erase(N,R); &bslash;&n;&t;&t;(N)-&gt;rb_color = -1; } while (0)
macro_line|#else
DECL|macro|HTB_DBG_COND
mdefine_line|#define HTB_DBG_COND(S,L) (0)
DECL|macro|HTB_DBG
mdefine_line|#define HTB_DBG(S,L,FMT,ARG...)
DECL|macro|HTB_PASSQ
mdefine_line|#define HTB_PASSQ
DECL|macro|HTB_ARGQ
mdefine_line|#define HTB_ARGQ
DECL|macro|HTB_CHCL
mdefine_line|#define HTB_CHCL(cl)
DECL|macro|htb_safe_rb_erase
mdefine_line|#define htb_safe_rb_erase(N,R) rb_erase(N,R)
macro_line|#endif
multiline_comment|/* used internaly to keep status of single class */
DECL|enum|htb_cmode
r_enum
id|htb_cmode
(brace
DECL|enumerator|HTB_CANT_SEND
id|HTB_CANT_SEND
comma
multiline_comment|/* class can&squot;t send and can&squot;t borrow */
DECL|enumerator|HTB_MAY_BORROW
id|HTB_MAY_BORROW
comma
multiline_comment|/* class can&squot;t send but may borrow */
DECL|enumerator|HTB_CAN_SEND
id|HTB_CAN_SEND
multiline_comment|/* class can send */
)brace
suffix:semicolon
multiline_comment|/* interior &amp; leaf nodes; props specific to leaves are marked L: */
DECL|struct|htb_class
r_struct
id|htb_class
(brace
macro_line|#ifdef HTB_DEBUG
DECL|member|magic
r_int
id|magic
suffix:semicolon
macro_line|#endif
multiline_comment|/* general class parameters */
DECL|member|classid
id|u32
id|classid
suffix:semicolon
DECL|member|stats
r_struct
id|tc_stats
id|stats
suffix:semicolon
multiline_comment|/* generic stats */
DECL|member|xstats
r_struct
id|tc_htb_xstats
id|xstats
suffix:semicolon
multiline_comment|/* our special stats */
DECL|member|refcnt
r_int
id|refcnt
suffix:semicolon
multiline_comment|/* usage count of this class */
macro_line|#ifdef HTB_RATECM
multiline_comment|/* rate measurement counters */
DECL|member|rate_bytes
DECL|member|sum_bytes
r_int
r_int
id|rate_bytes
comma
id|sum_bytes
suffix:semicolon
DECL|member|rate_packets
DECL|member|sum_packets
r_int
r_int
id|rate_packets
comma
id|sum_packets
suffix:semicolon
macro_line|#endif
multiline_comment|/* topology */
DECL|member|level
r_int
id|level
suffix:semicolon
multiline_comment|/* our level (see above) */
DECL|member|parent
r_struct
id|htb_class
op_star
id|parent
suffix:semicolon
multiline_comment|/* parent class */
DECL|member|hlist
r_struct
id|list_head
id|hlist
suffix:semicolon
multiline_comment|/* classid hash list item */
DECL|member|sibling
r_struct
id|list_head
id|sibling
suffix:semicolon
multiline_comment|/* sibling list item */
DECL|member|children
r_struct
id|list_head
id|children
suffix:semicolon
multiline_comment|/* children list */
r_union
(brace
DECL|struct|htb_class_leaf
r_struct
id|htb_class_leaf
(brace
DECL|member|q
r_struct
id|Qdisc
op_star
id|q
suffix:semicolon
DECL|member|prio
r_int
id|prio
suffix:semicolon
DECL|member|aprio
r_int
id|aprio
suffix:semicolon
DECL|member|quantum
r_int
id|quantum
suffix:semicolon
DECL|member|deficit
r_int
id|deficit
(braket
id|TC_HTB_MAXDEPTH
)braket
suffix:semicolon
DECL|member|drop_list
r_struct
id|list_head
id|drop_list
suffix:semicolon
DECL|member|leaf
)brace
id|leaf
suffix:semicolon
DECL|struct|htb_class_inner
r_struct
id|htb_class_inner
(brace
DECL|member|feed
r_struct
id|rb_root
id|feed
(braket
id|TC_HTB_NUMPRIO
)braket
suffix:semicolon
multiline_comment|/* feed trees */
DECL|member|ptr
r_struct
id|rb_node
op_star
id|ptr
(braket
id|TC_HTB_NUMPRIO
)braket
suffix:semicolon
multiline_comment|/* current class ptr */
DECL|member|inner
)brace
id|inner
suffix:semicolon
DECL|member|un
)brace
id|un
suffix:semicolon
DECL|member|node
r_struct
id|rb_node
id|node
(braket
id|TC_HTB_NUMPRIO
)braket
suffix:semicolon
multiline_comment|/* node for self or feed tree */
DECL|member|pq_node
r_struct
id|rb_node
id|pq_node
suffix:semicolon
multiline_comment|/* node for event queue */
DECL|member|pq_key
r_int
r_int
id|pq_key
suffix:semicolon
multiline_comment|/* the same type as jiffies global */
DECL|member|prio_activity
r_int
id|prio_activity
suffix:semicolon
multiline_comment|/* for which prios are we active */
DECL|member|cmode
r_enum
id|htb_cmode
id|cmode
suffix:semicolon
multiline_comment|/* current mode of the class */
multiline_comment|/* class attached filters */
DECL|member|filter_list
r_struct
id|tcf_proto
op_star
id|filter_list
suffix:semicolon
DECL|member|filter_cnt
r_int
id|filter_cnt
suffix:semicolon
DECL|member|warned
r_int
id|warned
suffix:semicolon
multiline_comment|/* only one warning about non work conserving .. */
multiline_comment|/* token bucket parameters */
DECL|member|rate
r_struct
id|qdisc_rate_table
op_star
id|rate
suffix:semicolon
multiline_comment|/* rate table of the class itself */
DECL|member|ceil
r_struct
id|qdisc_rate_table
op_star
id|ceil
suffix:semicolon
multiline_comment|/* ceiling rate (limits borrows too) */
DECL|member|buffer
DECL|member|cbuffer
r_int
id|buffer
comma
id|cbuffer
suffix:semicolon
multiline_comment|/* token bucket depth/rate */
DECL|member|mbuffer
r_int
id|mbuffer
suffix:semicolon
multiline_comment|/* max wait time */
DECL|member|tokens
DECL|member|ctokens
r_int
id|tokens
comma
id|ctokens
suffix:semicolon
multiline_comment|/* current number of tokens */
DECL|member|t_c
id|psched_time_t
id|t_c
suffix:semicolon
multiline_comment|/* checkpoint time */
)brace
suffix:semicolon
multiline_comment|/* TODO: maybe compute rate when size is too large .. or drop ? */
DECL|function|L2T
r_static
id|__inline__
r_int
id|L2T
c_func
(paren
r_struct
id|htb_class
op_star
id|cl
comma
r_struct
id|qdisc_rate_table
op_star
id|rate
comma
r_int
id|size
)paren
(brace
r_int
id|slot
op_assign
id|size
op_rshift
id|rate-&gt;rate.cell_log
suffix:semicolon
r_if
c_cond
(paren
id|slot
OG
l_int|255
)paren
(brace
id|cl-&gt;xstats.giants
op_increment
suffix:semicolon
id|slot
op_assign
l_int|255
suffix:semicolon
)brace
r_return
id|rate-&gt;data
(braket
id|slot
)braket
suffix:semicolon
)brace
DECL|struct|htb_sched
r_struct
id|htb_sched
(brace
DECL|member|root
r_struct
id|list_head
id|root
suffix:semicolon
multiline_comment|/* root classes list */
DECL|member|hash
r_struct
id|list_head
id|hash
(braket
id|HTB_HSIZE
)braket
suffix:semicolon
multiline_comment|/* hashed by classid */
DECL|member|drops
r_struct
id|list_head
id|drops
(braket
id|TC_HTB_NUMPRIO
)braket
suffix:semicolon
multiline_comment|/* active leaves (for drops) */
multiline_comment|/* self list - roots of self generating tree */
DECL|member|row
r_struct
id|rb_root
id|row
(braket
id|TC_HTB_MAXDEPTH
)braket
(braket
id|TC_HTB_NUMPRIO
)braket
suffix:semicolon
DECL|member|row_mask
r_int
id|row_mask
(braket
id|TC_HTB_MAXDEPTH
)braket
suffix:semicolon
DECL|member|ptr
r_struct
id|rb_node
op_star
id|ptr
(braket
id|TC_HTB_MAXDEPTH
)braket
(braket
id|TC_HTB_NUMPRIO
)braket
suffix:semicolon
multiline_comment|/* self wait list - roots of wait PQs per row */
DECL|member|wait_pq
r_struct
id|rb_root
id|wait_pq
(braket
id|TC_HTB_MAXDEPTH
)braket
suffix:semicolon
multiline_comment|/* time of nearest event per level (row) */
DECL|member|near_ev_cache
r_int
r_int
id|near_ev_cache
(braket
id|TC_HTB_MAXDEPTH
)braket
suffix:semicolon
multiline_comment|/* cached value of jiffies in dequeue */
DECL|member|jiffies
r_int
r_int
id|jiffies
suffix:semicolon
multiline_comment|/* whether we hit non-work conserving class during this dequeue; we use */
DECL|member|nwc_hit
r_int
id|nwc_hit
suffix:semicolon
multiline_comment|/* this to disable mindelay complaint in dequeue */
DECL|member|defcls
r_int
id|defcls
suffix:semicolon
multiline_comment|/* class where unclassified flows go to */
DECL|member|debug
id|u32
id|debug
suffix:semicolon
multiline_comment|/* subsystem debug levels */
multiline_comment|/* filters for qdisc itself */
DECL|member|filter_list
r_struct
id|tcf_proto
op_star
id|filter_list
suffix:semicolon
DECL|member|filter_cnt
r_int
id|filter_cnt
suffix:semicolon
DECL|member|rate2quantum
r_int
id|rate2quantum
suffix:semicolon
multiline_comment|/* quant = rate / rate2quantum */
DECL|member|now
id|psched_time_t
id|now
suffix:semicolon
multiline_comment|/* cached dequeue time */
DECL|member|timer
r_struct
id|timer_list
id|timer
suffix:semicolon
multiline_comment|/* send delay timer */
macro_line|#ifdef HTB_RATECM
DECL|member|rttim
r_struct
id|timer_list
id|rttim
suffix:semicolon
multiline_comment|/* rate computer timer */
DECL|member|recmp_bucket
r_int
id|recmp_bucket
suffix:semicolon
multiline_comment|/* which hash bucket to recompute next */
macro_line|#endif
multiline_comment|/* non shaped skbs; let them go directly thru */
DECL|member|direct_queue
r_struct
id|sk_buff_head
id|direct_queue
suffix:semicolon
DECL|member|direct_qlen
r_int
id|direct_qlen
suffix:semicolon
multiline_comment|/* max qlen of above */
DECL|member|direct_pkts
r_int
id|direct_pkts
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* compute hash of size HTB_HSIZE for given handle */
DECL|function|htb_hash
r_static
id|__inline__
r_int
id|htb_hash
c_func
(paren
id|u32
id|h
)paren
(brace
macro_line|#if HTB_HSIZE != 16
macro_line|#error &quot;Declare new hash for your HTB_HSIZE&quot;
macro_line|#endif
id|h
op_xor_assign
id|h
op_rshift
l_int|8
suffix:semicolon
multiline_comment|/* stolen from cbq_hash */
id|h
op_xor_assign
id|h
op_rshift
l_int|4
suffix:semicolon
r_return
id|h
op_amp
l_int|0xf
suffix:semicolon
)brace
multiline_comment|/* find class in global hash table using given handle */
DECL|function|htb_find
r_static
id|__inline__
r_struct
id|htb_class
op_star
id|htb_find
c_func
(paren
id|u32
id|handle
comma
r_struct
id|Qdisc
op_star
id|sch
)paren
(brace
r_struct
id|htb_sched
op_star
id|q
op_assign
(paren
r_struct
id|htb_sched
op_star
)paren
id|sch-&gt;data
suffix:semicolon
r_struct
id|list_head
op_star
id|p
suffix:semicolon
r_if
c_cond
(paren
id|TC_H_MAJ
c_func
(paren
id|handle
)paren
op_ne
id|sch-&gt;handle
)paren
r_return
l_int|NULL
suffix:semicolon
id|list_for_each
(paren
id|p
comma
id|q-&gt;hash
op_plus
id|htb_hash
c_func
(paren
id|handle
)paren
)paren
(brace
r_struct
id|htb_class
op_star
id|cl
op_assign
id|list_entry
c_func
(paren
id|p
comma
r_struct
id|htb_class
comma
id|hlist
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cl-&gt;classid
op_eq
id|handle
)paren
r_return
id|cl
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/**&n; * htb_classify - classify a packet into class&n; *&n; * It returns NULL if the packet should be dropped or -1 if the packet&n; * should be passed directly thru. In all other cases leaf class is returned.&n; * We allow direct class selection by classid in priority. The we examine&n; * filters in qdisc and in inner nodes (if higher filter points to the inner&n; * node). If we end up with classid MAJOR:0 we enqueue the skb into special&n; * internal fifo (direct). These packets then go directly thru. If we still &n; * have no valid leaf we try to use MAJOR:default leaf. It still unsuccessfull&n; * then finish and return direct queue.&n; */
DECL|macro|HTB_DIRECT
mdefine_line|#define HTB_DIRECT (struct htb_class*)-1
DECL|function|htb_classid
r_static
r_inline
id|u32
id|htb_classid
c_func
(paren
r_struct
id|htb_class
op_star
id|cl
)paren
(brace
r_return
(paren
id|cl
op_logical_and
id|cl
op_ne
id|HTB_DIRECT
)paren
ques
c_cond
id|cl-&gt;classid
suffix:colon
id|TC_H_UNSPEC
suffix:semicolon
)brace
DECL|function|htb_classify
r_static
r_struct
id|htb_class
op_star
id|htb_classify
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|Qdisc
op_star
id|sch
)paren
(brace
r_struct
id|htb_sched
op_star
id|q
op_assign
(paren
r_struct
id|htb_sched
op_star
)paren
id|sch-&gt;data
suffix:semicolon
r_struct
id|htb_class
op_star
id|cl
suffix:semicolon
r_struct
id|tcf_result
id|res
suffix:semicolon
r_struct
id|tcf_proto
op_star
id|tcf
suffix:semicolon
r_int
id|result
suffix:semicolon
multiline_comment|/* allow to select class by setting skb-&gt;priority to valid classid;&n;&t;   note that nfmark can be used too by attaching filter fw with no&n;&t;   rules in it */
r_if
c_cond
(paren
id|skb-&gt;priority
op_eq
id|sch-&gt;handle
)paren
r_return
id|HTB_DIRECT
suffix:semicolon
multiline_comment|/* X:0 (direct flow) selected */
r_if
c_cond
(paren
(paren
id|cl
op_assign
id|htb_find
c_func
(paren
id|skb-&gt;priority
comma
id|sch
)paren
)paren
op_ne
l_int|NULL
op_logical_and
id|cl-&gt;level
op_eq
l_int|0
)paren
r_return
id|cl
suffix:semicolon
id|tcf
op_assign
id|q-&gt;filter_list
suffix:semicolon
r_while
c_loop
(paren
id|tcf
op_logical_and
(paren
id|result
op_assign
id|tc_classify
c_func
(paren
id|skb
comma
id|tcf
comma
op_amp
id|res
)paren
)paren
op_ge
l_int|0
)paren
(brace
macro_line|#ifdef CONFIG_NET_CLS_POLICE
r_if
c_cond
(paren
id|result
op_eq
id|TC_POLICE_SHOT
)paren
r_return
l_int|NULL
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
(paren
id|cl
op_assign
(paren
r_void
op_star
)paren
id|res
dot
r_class
)paren
op_eq
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|res.classid
op_eq
id|sch-&gt;handle
)paren
r_return
id|HTB_DIRECT
suffix:semicolon
multiline_comment|/* X:0 (direct flow) */
r_if
c_cond
(paren
(paren
id|cl
op_assign
id|htb_find
c_func
(paren
id|res.classid
comma
id|sch
)paren
)paren
op_eq
l_int|NULL
)paren
r_break
suffix:semicolon
multiline_comment|/* filter selected invalid classid */
)brace
r_if
c_cond
(paren
op_logical_neg
id|cl-&gt;level
)paren
r_return
id|cl
suffix:semicolon
multiline_comment|/* we hit leaf; return it */
multiline_comment|/* we have got inner class; apply inner filter chain */
id|tcf
op_assign
id|cl-&gt;filter_list
suffix:semicolon
)brace
multiline_comment|/* classification failed; try to use default class */
id|cl
op_assign
id|htb_find
c_func
(paren
id|TC_H_MAKE
c_func
(paren
id|TC_H_MAJ
c_func
(paren
id|sch-&gt;handle
)paren
comma
id|q-&gt;defcls
)paren
comma
id|sch
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cl
op_logical_or
id|cl-&gt;level
)paren
r_return
id|HTB_DIRECT
suffix:semicolon
multiline_comment|/* bad default .. this is safe bet */
r_return
id|cl
suffix:semicolon
)brace
macro_line|#ifdef HTB_DEBUG
r_static
r_void
id|htb_next_rb_node
c_func
(paren
r_struct
id|rb_node
op_star
op_star
id|n
)paren
suffix:semicolon
DECL|macro|HTB_DUMTREE
mdefine_line|#define HTB_DUMTREE(root,memb) if(root) { &bslash;&n;&t;struct rb_node *n = (root)-&gt;rb_node; &bslash;&n;&t;while (n-&gt;rb_left) n = n-&gt;rb_left; &bslash;&n;&t;while (n) { &bslash;&n;&t;&t;struct htb_class *cl = rb_entry(n, struct htb_class, memb); &bslash;&n;&t;&t;printk(&quot; %x&quot;,cl-&gt;classid); htb_next_rb_node (&amp;n); &bslash;&n;&t;} }
DECL|function|htb_debug_dump
r_static
r_void
id|htb_debug_dump
(paren
r_struct
id|htb_sched
op_star
id|q
)paren
(brace
r_int
id|i
comma
id|p
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;htb*g j=%lu lj=%lu&bslash;n&quot;
comma
id|jiffies
comma
id|q-&gt;jiffies
)paren
suffix:semicolon
multiline_comment|/* rows */
r_for
c_loop
(paren
id|i
op_assign
id|TC_HTB_MAXDEPTH
op_minus
l_int|1
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;htb*r%d m=%x&quot;
comma
id|i
comma
id|q-&gt;row_mask
(braket
id|i
)braket
)paren
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
l_int|0
suffix:semicolon
id|p
OL
id|TC_HTB_NUMPRIO
suffix:semicolon
id|p
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|q-&gt;row
(braket
id|i
)braket
(braket
id|p
)braket
dot
id|rb_node
)paren
r_continue
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; p%d:&quot;
comma
id|p
)paren
suffix:semicolon
id|HTB_DUMTREE
c_func
(paren
id|q-&gt;row
(braket
id|i
)braket
op_plus
id|p
comma
id|node
(braket
id|p
)braket
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* classes */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|HTB_HSIZE
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|list_head
op_star
id|l
suffix:semicolon
id|list_for_each
(paren
id|l
comma
id|q-&gt;hash
op_plus
id|i
)paren
(brace
r_struct
id|htb_class
op_star
id|cl
op_assign
id|list_entry
c_func
(paren
id|l
comma
r_struct
id|htb_class
comma
id|hlist
)paren
suffix:semicolon
r_int
id|diff
op_assign
id|PSCHED_TDIFF_SAFE
c_func
(paren
id|q-&gt;now
comma
id|cl-&gt;t_c
comma
(paren
id|u32
)paren
id|cl-&gt;mbuffer
comma
l_int|0
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;htb*c%x m=%d t=%ld c=%ld pq=%lu df=%ld ql=%d &quot;
l_string|&quot;pa=%x f:&quot;
comma
id|cl-&gt;classid
comma
id|cl-&gt;cmode
comma
id|cl-&gt;tokens
comma
id|cl-&gt;ctokens
comma
id|cl-&gt;pq_node.rb_color
op_eq
op_minus
l_int|1
ques
c_cond
l_int|0
suffix:colon
id|cl-&gt;pq_key
comma
id|diff
comma
id|cl-&gt;level
ques
c_cond
l_int|0
suffix:colon
id|cl-&gt;un.leaf.q-&gt;q.qlen
comma
id|cl-&gt;prio_activity
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cl-&gt;level
)paren
r_for
c_loop
(paren
id|p
op_assign
l_int|0
suffix:semicolon
id|p
OL
id|TC_HTB_NUMPRIO
suffix:semicolon
id|p
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|cl-&gt;un.inner.feed
(braket
id|p
)braket
dot
id|rb_node
)paren
r_continue
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; p%d a=%x:&quot;
comma
id|p
comma
id|cl-&gt;un.inner.ptr
(braket
id|p
)braket
ques
c_cond
id|rb_entry
c_func
(paren
id|cl-&gt;un.inner.ptr
(braket
id|p
)braket
comma
r_struct
id|htb_class
comma
id|node
(braket
id|p
)braket
)paren
op_member_access_from_pointer
id|classid
suffix:colon
l_int|0
)paren
suffix:semicolon
id|HTB_DUMTREE
c_func
(paren
id|cl-&gt;un.inner.feed
op_plus
id|p
comma
id|node
(braket
id|p
)braket
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
)brace
macro_line|#endif
multiline_comment|/**&n; * htb_add_to_id_tree - adds class to the round robin list&n; *&n; * Routine adds class to the list (actually tree) sorted by classid.&n; * Make sure that class is not already on such list for given prio.&n; */
DECL|function|htb_add_to_id_tree
r_static
r_void
id|htb_add_to_id_tree
(paren
id|HTB_ARGQ
r_struct
id|rb_root
op_star
id|root
comma
r_struct
id|htb_class
op_star
id|cl
comma
r_int
id|prio
)paren
(brace
r_struct
id|rb_node
op_star
op_star
id|p
op_assign
op_amp
id|root-&gt;rb_node
comma
op_star
id|parent
op_assign
l_int|NULL
suffix:semicolon
id|HTB_DBG
c_func
(paren
l_int|7
comma
l_int|3
comma
l_string|&quot;htb_add_id_tree cl=%X prio=%d&bslash;n&quot;
comma
id|cl-&gt;classid
comma
id|prio
)paren
suffix:semicolon
macro_line|#ifdef HTB_DEBUG
r_if
c_cond
(paren
id|cl-&gt;node
(braket
id|prio
)braket
dot
id|rb_color
op_ne
op_minus
l_int|1
)paren
(brace
id|BUG_TRAP
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|HTB_CHCL
c_func
(paren
id|cl
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|p
)paren
(brace
r_struct
id|htb_class
op_star
id|x
op_assign
id|rb_entry
c_func
(paren
op_star
id|p
comma
r_struct
id|htb_class
comma
id|node
(braket
id|prio
)braket
)paren
suffix:semicolon
id|HTB_CHCL
c_func
(paren
id|x
)paren
suffix:semicolon
)brace
macro_line|#endif
r_while
c_loop
(paren
op_star
id|p
)paren
(brace
r_struct
id|htb_class
op_star
id|c
suffix:semicolon
id|parent
op_assign
op_star
id|p
suffix:semicolon
id|c
op_assign
id|rb_entry
c_func
(paren
id|parent
comma
r_struct
id|htb_class
comma
id|node
(braket
id|prio
)braket
)paren
suffix:semicolon
id|HTB_CHCL
c_func
(paren
id|c
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cl-&gt;classid
OG
id|c-&gt;classid
)paren
id|p
op_assign
op_amp
id|parent-&gt;rb_right
suffix:semicolon
r_else
id|p
op_assign
op_amp
id|parent-&gt;rb_left
suffix:semicolon
)brace
id|rb_link_node
c_func
(paren
op_amp
id|cl-&gt;node
(braket
id|prio
)braket
comma
id|parent
comma
id|p
)paren
suffix:semicolon
id|rb_insert_color
c_func
(paren
op_amp
id|cl-&gt;node
(braket
id|prio
)braket
comma
id|root
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * htb_add_to_wait_tree - adds class to the event queue with delay&n; *&n; * The class is added to priority event queue to indicate that class will&n; * change its mode in cl-&gt;pq_key microseconds. Make sure that class is not&n; * already in the queue.&n; */
DECL|function|htb_add_to_wait_tree
r_static
r_void
id|htb_add_to_wait_tree
(paren
r_struct
id|htb_sched
op_star
id|q
comma
r_struct
id|htb_class
op_star
id|cl
comma
r_int
id|delay
comma
r_int
id|debug_hint
)paren
(brace
r_struct
id|rb_node
op_star
op_star
id|p
op_assign
op_amp
id|q-&gt;wait_pq
(braket
id|cl-&gt;level
)braket
dot
id|rb_node
comma
op_star
id|parent
op_assign
l_int|NULL
suffix:semicolon
id|HTB_DBG
c_func
(paren
l_int|7
comma
l_int|3
comma
l_string|&quot;htb_add_wt cl=%X key=%lu&bslash;n&quot;
comma
id|cl-&gt;classid
comma
id|cl-&gt;pq_key
)paren
suffix:semicolon
macro_line|#ifdef HTB_DEBUG
r_if
c_cond
(paren
id|cl-&gt;pq_node.rb_color
op_ne
op_minus
l_int|1
)paren
(brace
id|BUG_TRAP
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|HTB_CHCL
c_func
(paren
id|cl
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|delay
op_le
l_int|0
op_logical_or
id|delay
OG
id|cl-&gt;mbuffer
)paren
op_logical_and
id|net_ratelimit
c_func
(paren
)paren
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;HTB: suspicious delay in wait_tree d=%ld cl=%X h=%d&bslash;n&quot;
comma
id|delay
comma
id|cl-&gt;classid
comma
id|debug_hint
)paren
suffix:semicolon
macro_line|#endif
id|cl-&gt;pq_key
op_assign
id|q-&gt;jiffies
op_plus
id|PSCHED_US2JIFFIE
c_func
(paren
id|delay
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cl-&gt;pq_key
op_eq
id|q-&gt;jiffies
)paren
id|cl-&gt;pq_key
op_increment
suffix:semicolon
multiline_comment|/* update the nearest event cache */
r_if
c_cond
(paren
id|q-&gt;near_ev_cache
(braket
id|cl-&gt;level
)braket
op_minus
id|cl-&gt;pq_key
OL
l_int|0x80000000
)paren
id|q-&gt;near_ev_cache
(braket
id|cl-&gt;level
)braket
op_assign
id|cl-&gt;pq_key
suffix:semicolon
r_while
c_loop
(paren
op_star
id|p
)paren
(brace
r_struct
id|htb_class
op_star
id|c
suffix:semicolon
id|parent
op_assign
op_star
id|p
suffix:semicolon
id|c
op_assign
id|rb_entry
c_func
(paren
id|parent
comma
r_struct
id|htb_class
comma
id|pq_node
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cl-&gt;pq_key
op_minus
id|c-&gt;pq_key
OL
l_int|0x80000000
)paren
id|p
op_assign
op_amp
id|parent-&gt;rb_right
suffix:semicolon
r_else
id|p
op_assign
op_amp
id|parent-&gt;rb_left
suffix:semicolon
)brace
id|rb_link_node
c_func
(paren
op_amp
id|cl-&gt;pq_node
comma
id|parent
comma
id|p
)paren
suffix:semicolon
id|rb_insert_color
c_func
(paren
op_amp
id|cl-&gt;pq_node
comma
op_amp
id|q-&gt;wait_pq
(braket
id|cl-&gt;level
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * htb_next_rb_node - finds next node in binary tree&n; *&n; * When we are past last key we return NULL.&n; * Average complexity is 2 steps per call.&n; */
DECL|function|htb_next_rb_node
r_static
r_void
id|htb_next_rb_node
c_func
(paren
r_struct
id|rb_node
op_star
op_star
id|n
)paren
(brace
op_star
id|n
op_assign
id|rb_next
c_func
(paren
op_star
id|n
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * htb_add_class_to_row - add class to its row&n; *&n; * The class is added to row at priorities marked in mask.&n; * It does nothing if mask == 0.&n; */
DECL|function|htb_add_class_to_row
r_static
r_inline
r_void
id|htb_add_class_to_row
c_func
(paren
r_struct
id|htb_sched
op_star
id|q
comma
r_struct
id|htb_class
op_star
id|cl
comma
r_int
id|mask
)paren
(brace
id|HTB_DBG
c_func
(paren
l_int|7
comma
l_int|2
comma
l_string|&quot;htb_addrow cl=%X mask=%X rmask=%X&bslash;n&quot;
comma
id|cl-&gt;classid
comma
id|mask
comma
id|q-&gt;row_mask
(braket
id|cl-&gt;level
)braket
)paren
suffix:semicolon
id|HTB_CHCL
c_func
(paren
id|cl
)paren
suffix:semicolon
id|q-&gt;row_mask
(braket
id|cl-&gt;level
)braket
op_or_assign
id|mask
suffix:semicolon
r_while
c_loop
(paren
id|mask
)paren
(brace
r_int
id|prio
op_assign
id|ffz
c_func
(paren
op_complement
id|mask
)paren
suffix:semicolon
id|mask
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|prio
)paren
suffix:semicolon
id|htb_add_to_id_tree
c_func
(paren
id|HTB_PASSQ
id|q-&gt;row
(braket
id|cl-&gt;level
)braket
op_plus
id|prio
comma
id|cl
comma
id|prio
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; * htb_remove_class_from_row - removes class from its row&n; *&n; * The class is removed from row at priorities marked in mask.&n; * It does nothing if mask == 0.&n; */
DECL|function|htb_remove_class_from_row
r_static
id|__inline__
r_void
id|htb_remove_class_from_row
c_func
(paren
r_struct
id|htb_sched
op_star
id|q
comma
r_struct
id|htb_class
op_star
id|cl
comma
r_int
id|mask
)paren
(brace
r_int
id|m
op_assign
l_int|0
suffix:semicolon
id|HTB_CHCL
c_func
(paren
id|cl
)paren
suffix:semicolon
r_while
c_loop
(paren
id|mask
)paren
(brace
r_int
id|prio
op_assign
id|ffz
c_func
(paren
op_complement
id|mask
)paren
suffix:semicolon
id|mask
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|prio
)paren
suffix:semicolon
r_if
c_cond
(paren
id|q-&gt;ptr
(braket
id|cl-&gt;level
)braket
(braket
id|prio
)braket
op_eq
id|cl-&gt;node
op_plus
id|prio
)paren
id|htb_next_rb_node
c_func
(paren
id|q-&gt;ptr
(braket
id|cl-&gt;level
)braket
op_plus
id|prio
)paren
suffix:semicolon
id|htb_safe_rb_erase
c_func
(paren
id|cl-&gt;node
op_plus
id|prio
comma
id|q-&gt;row
(braket
id|cl-&gt;level
)braket
op_plus
id|prio
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|q-&gt;row
(braket
id|cl-&gt;level
)braket
(braket
id|prio
)braket
dot
id|rb_node
)paren
id|m
op_or_assign
l_int|1
op_lshift
id|prio
suffix:semicolon
)brace
id|HTB_DBG
c_func
(paren
l_int|7
comma
l_int|2
comma
l_string|&quot;htb_delrow cl=%X mask=%X rmask=%X maskdel=%X&bslash;n&quot;
comma
id|cl-&gt;classid
comma
id|mask
comma
id|q-&gt;row_mask
(braket
id|cl-&gt;level
)braket
comma
id|m
)paren
suffix:semicolon
id|q-&gt;row_mask
(braket
id|cl-&gt;level
)braket
op_and_assign
op_complement
id|m
suffix:semicolon
)brace
multiline_comment|/**&n; * htb_activate_prios - creates active classe&squot;s feed chain&n; *&n; * The class is connected to ancestors and/or appropriate rows&n; * for priorities it is participating on. cl-&gt;cmode must be new &n; * (activated) mode. It does nothing if cl-&gt;prio_activity == 0.&n; */
DECL|function|htb_activate_prios
r_static
r_void
id|htb_activate_prios
c_func
(paren
r_struct
id|htb_sched
op_star
id|q
comma
r_struct
id|htb_class
op_star
id|cl
)paren
(brace
r_struct
id|htb_class
op_star
id|p
op_assign
id|cl-&gt;parent
suffix:semicolon
r_int
id|m
comma
id|mask
op_assign
id|cl-&gt;prio_activity
suffix:semicolon
id|HTB_DBG
c_func
(paren
l_int|7
comma
l_int|2
comma
l_string|&quot;htb_act_prios cl=%X mask=%lX cmode=%d&bslash;n&quot;
comma
id|cl-&gt;classid
comma
id|mask
comma
id|cl-&gt;cmode
)paren
suffix:semicolon
id|HTB_CHCL
c_func
(paren
id|cl
)paren
suffix:semicolon
r_while
c_loop
(paren
id|cl-&gt;cmode
op_eq
id|HTB_MAY_BORROW
op_logical_and
id|p
op_logical_and
id|mask
)paren
(brace
id|HTB_CHCL
c_func
(paren
id|p
)paren
suffix:semicolon
id|m
op_assign
id|mask
suffix:semicolon
r_while
c_loop
(paren
id|m
)paren
(brace
r_int
id|prio
op_assign
id|ffz
c_func
(paren
op_complement
id|m
)paren
suffix:semicolon
id|m
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|prio
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;un.inner.feed
(braket
id|prio
)braket
dot
id|rb_node
)paren
multiline_comment|/* parent already has its feed in use so that&n;&t;&t;&t;&t;   reset bit in mask as parent is already ok */
id|mask
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|prio
)paren
suffix:semicolon
id|htb_add_to_id_tree
c_func
(paren
id|HTB_PASSQ
id|p-&gt;un.inner.feed
op_plus
id|prio
comma
id|cl
comma
id|prio
)paren
suffix:semicolon
)brace
id|HTB_DBG
c_func
(paren
l_int|7
comma
l_int|3
comma
l_string|&quot;htb_act_pr_aft p=%X pact=%X mask=%lX pmode=%d&bslash;n&quot;
comma
id|p-&gt;classid
comma
id|p-&gt;prio_activity
comma
id|mask
comma
id|p-&gt;cmode
)paren
suffix:semicolon
id|p-&gt;prio_activity
op_or_assign
id|mask
suffix:semicolon
id|cl
op_assign
id|p
suffix:semicolon
id|p
op_assign
id|cl-&gt;parent
suffix:semicolon
id|HTB_CHCL
c_func
(paren
id|cl
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cl-&gt;cmode
op_eq
id|HTB_CAN_SEND
op_logical_and
id|mask
)paren
id|htb_add_class_to_row
c_func
(paren
id|q
comma
id|cl
comma
id|mask
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * htb_deactivate_prios - remove class from feed chain&n; *&n; * cl-&gt;cmode must represent old mode (before deactivation). It does &n; * nothing if cl-&gt;prio_activity == 0. Class is removed from all feed&n; * chains and rows.&n; */
DECL|function|htb_deactivate_prios
r_static
r_void
id|htb_deactivate_prios
c_func
(paren
r_struct
id|htb_sched
op_star
id|q
comma
r_struct
id|htb_class
op_star
id|cl
)paren
(brace
r_struct
id|htb_class
op_star
id|p
op_assign
id|cl-&gt;parent
suffix:semicolon
r_int
id|m
comma
id|mask
op_assign
id|cl-&gt;prio_activity
suffix:semicolon
id|HTB_DBG
c_func
(paren
l_int|7
comma
l_int|2
comma
l_string|&quot;htb_deact_prios cl=%X mask=%lX cmode=%d&bslash;n&quot;
comma
id|cl-&gt;classid
comma
id|mask
comma
id|cl-&gt;cmode
)paren
suffix:semicolon
id|HTB_CHCL
c_func
(paren
id|cl
)paren
suffix:semicolon
r_while
c_loop
(paren
id|cl-&gt;cmode
op_eq
id|HTB_MAY_BORROW
op_logical_and
id|p
op_logical_and
id|mask
)paren
(brace
id|m
op_assign
id|mask
suffix:semicolon
id|mask
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|m
)paren
(brace
r_int
id|prio
op_assign
id|ffz
c_func
(paren
op_complement
id|m
)paren
suffix:semicolon
id|m
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|prio
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;un.inner.ptr
(braket
id|prio
)braket
op_eq
id|cl-&gt;node
op_plus
id|prio
)paren
id|htb_next_rb_node
c_func
(paren
id|p-&gt;un.inner.ptr
op_plus
id|prio
)paren
suffix:semicolon
id|htb_safe_rb_erase
c_func
(paren
id|cl-&gt;node
op_plus
id|prio
comma
id|p-&gt;un.inner.feed
op_plus
id|prio
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p-&gt;un.inner.feed
(braket
id|prio
)braket
dot
id|rb_node
)paren
id|mask
op_or_assign
l_int|1
op_lshift
id|prio
suffix:semicolon
)brace
id|HTB_DBG
c_func
(paren
l_int|7
comma
l_int|3
comma
l_string|&quot;htb_deact_pr_aft p=%X pact=%X mask=%lX pmode=%d&bslash;n&quot;
comma
id|p-&gt;classid
comma
id|p-&gt;prio_activity
comma
id|mask
comma
id|p-&gt;cmode
)paren
suffix:semicolon
id|p-&gt;prio_activity
op_and_assign
op_complement
id|mask
suffix:semicolon
id|cl
op_assign
id|p
suffix:semicolon
id|p
op_assign
id|cl-&gt;parent
suffix:semicolon
id|HTB_CHCL
c_func
(paren
id|cl
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cl-&gt;cmode
op_eq
id|HTB_CAN_SEND
op_logical_and
id|mask
)paren
id|htb_remove_class_from_row
c_func
(paren
id|q
comma
id|cl
comma
id|mask
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * htb_class_mode - computes and returns current class mode&n; *&n; * It computes cl&squot;s mode at time cl-&gt;t_c+diff and returns it. If mode&n; * is not HTB_CAN_SEND then cl-&gt;pq_key is updated to time difference&n; * from now to time when cl will change its state. &n; * Also it is worth to note that class mode doesn&squot;t change simply&n; * at cl-&gt;{c,}tokens == 0 but there can rather be hysteresis of &n; * 0 .. -cl-&gt;{c,}buffer range. It is meant to limit number of&n; * mode transitions per time unit. The speed gain is about 1/6.&n; */
r_static
id|__inline__
r_enum
id|htb_cmode
DECL|function|htb_class_mode
id|htb_class_mode
c_func
(paren
r_struct
id|htb_class
op_star
id|cl
comma
r_int
op_star
id|diff
)paren
(brace
r_int
id|toks
suffix:semicolon
r_if
c_cond
(paren
(paren
id|toks
op_assign
(paren
id|cl-&gt;ctokens
op_plus
op_star
id|diff
)paren
)paren
OL
(paren
macro_line|#if HTB_HYSTERESIS
id|cl-&gt;cmode
op_ne
id|HTB_CANT_SEND
ques
c_cond
op_minus
id|cl-&gt;cbuffer
suffix:colon
macro_line|#endif
l_int|0
)paren
)paren
(brace
op_star
id|diff
op_assign
op_minus
id|toks
suffix:semicolon
r_return
id|HTB_CANT_SEND
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|toks
op_assign
(paren
id|cl-&gt;tokens
op_plus
op_star
id|diff
)paren
)paren
op_ge
(paren
macro_line|#if HTB_HYSTERESIS
id|cl-&gt;cmode
op_eq
id|HTB_CAN_SEND
ques
c_cond
op_minus
id|cl-&gt;buffer
suffix:colon
macro_line|#endif
l_int|0
)paren
)paren
r_return
id|HTB_CAN_SEND
suffix:semicolon
op_star
id|diff
op_assign
op_minus
id|toks
suffix:semicolon
r_return
id|HTB_MAY_BORROW
suffix:semicolon
)brace
multiline_comment|/**&n; * htb_change_class_mode - changes classe&squot;s mode&n; *&n; * This should be the only way how to change classe&squot;s mode under normal&n; * cirsumstances. Routine will update feed lists linkage, change mode&n; * and add class to the wait event queue if appropriate. New mode should&n; * be different from old one and cl-&gt;pq_key has to be valid if changing&n; * to mode other than HTB_CAN_SEND (see htb_add_to_wait_tree).&n; */
r_static
r_void
DECL|function|htb_change_class_mode
id|htb_change_class_mode
c_func
(paren
r_struct
id|htb_sched
op_star
id|q
comma
r_struct
id|htb_class
op_star
id|cl
comma
r_int
op_star
id|diff
)paren
(brace
r_enum
id|htb_cmode
id|new_mode
op_assign
id|htb_class_mode
c_func
(paren
id|cl
comma
id|diff
)paren
suffix:semicolon
id|HTB_CHCL
c_func
(paren
id|cl
)paren
suffix:semicolon
id|HTB_DBG
c_func
(paren
l_int|7
comma
l_int|1
comma
l_string|&quot;htb_chging_clmode %d-&gt;%d cl=%X&bslash;n&quot;
comma
id|cl-&gt;cmode
comma
id|new_mode
comma
id|cl-&gt;classid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|new_mode
op_eq
id|cl-&gt;cmode
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|cl-&gt;prio_activity
)paren
(brace
multiline_comment|/* not necessary: speed optimization */
r_if
c_cond
(paren
id|cl-&gt;cmode
op_ne
id|HTB_CANT_SEND
)paren
id|htb_deactivate_prios
c_func
(paren
id|q
comma
id|cl
)paren
suffix:semicolon
id|cl-&gt;cmode
op_assign
id|new_mode
suffix:semicolon
r_if
c_cond
(paren
id|new_mode
op_ne
id|HTB_CANT_SEND
)paren
id|htb_activate_prios
c_func
(paren
id|q
comma
id|cl
)paren
suffix:semicolon
)brace
r_else
id|cl-&gt;cmode
op_assign
id|new_mode
suffix:semicolon
)brace
multiline_comment|/**&n; * htb_activate - inserts leaf cl into appropriate active feeds &n; *&n; * Routine learns (new) priority of leaf and activates feed chain&n; * for the prio. It can be called on already active leaf safely.&n; * It also adds leaf into droplist.&n; */
DECL|function|htb_activate
r_static
id|__inline__
r_void
id|htb_activate
c_func
(paren
r_struct
id|htb_sched
op_star
id|q
comma
r_struct
id|htb_class
op_star
id|cl
)paren
(brace
id|BUG_TRAP
c_func
(paren
op_logical_neg
id|cl-&gt;level
op_logical_and
id|cl-&gt;un.leaf.q
op_logical_and
id|cl-&gt;un.leaf.q-&gt;q.qlen
)paren
suffix:semicolon
id|HTB_CHCL
c_func
(paren
id|cl
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cl-&gt;prio_activity
)paren
(brace
id|cl-&gt;prio_activity
op_assign
l_int|1
op_lshift
(paren
id|cl-&gt;un.leaf.aprio
op_assign
id|cl-&gt;un.leaf.prio
)paren
suffix:semicolon
id|htb_activate_prios
c_func
(paren
id|q
comma
id|cl
)paren
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|cl-&gt;un.leaf.drop_list
comma
id|q-&gt;drops
op_plus
id|cl-&gt;un.leaf.aprio
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; * htb_deactivate - remove leaf cl from active feeds &n; *&n; * Make sure that leaf is active. In the other words it can&squot;t be called&n; * with non-active leaf. It also removes class from the drop list.&n; */
r_static
id|__inline__
r_void
DECL|function|htb_deactivate
id|htb_deactivate
c_func
(paren
r_struct
id|htb_sched
op_star
id|q
comma
r_struct
id|htb_class
op_star
id|cl
)paren
(brace
id|BUG_TRAP
c_func
(paren
id|cl-&gt;prio_activity
)paren
suffix:semicolon
id|HTB_CHCL
c_func
(paren
id|cl
)paren
suffix:semicolon
id|htb_deactivate_prios
c_func
(paren
id|q
comma
id|cl
)paren
suffix:semicolon
id|cl-&gt;prio_activity
op_assign
l_int|0
suffix:semicolon
id|list_del_init
c_func
(paren
op_amp
id|cl-&gt;un.leaf.drop_list
)paren
suffix:semicolon
)brace
DECL|function|htb_enqueue
r_static
r_int
id|htb_enqueue
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|Qdisc
op_star
id|sch
)paren
(brace
r_struct
id|htb_sched
op_star
id|q
op_assign
(paren
r_struct
id|htb_sched
op_star
)paren
id|sch-&gt;data
suffix:semicolon
r_struct
id|htb_class
op_star
id|cl
op_assign
id|htb_classify
c_func
(paren
id|skb
comma
id|sch
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cl
op_eq
id|HTB_DIRECT
op_logical_or
op_logical_neg
id|cl
)paren
(brace
multiline_comment|/* enqueue to helper queue */
r_if
c_cond
(paren
id|q-&gt;direct_queue.qlen
OL
id|q-&gt;direct_qlen
op_logical_and
id|cl
)paren
(brace
id|__skb_queue_tail
c_func
(paren
op_amp
id|q-&gt;direct_queue
comma
id|skb
)paren
suffix:semicolon
id|q-&gt;direct_pkts
op_increment
suffix:semicolon
)brace
r_else
(brace
id|kfree_skb
(paren
id|skb
)paren
suffix:semicolon
id|sch-&gt;stats.drops
op_increment
suffix:semicolon
r_return
id|NET_XMIT_DROP
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|cl-&gt;un.leaf.q
op_member_access_from_pointer
id|enqueue
c_func
(paren
id|skb
comma
id|cl-&gt;un.leaf.q
)paren
op_ne
id|NET_XMIT_SUCCESS
)paren
(brace
id|sch-&gt;stats.drops
op_increment
suffix:semicolon
id|cl-&gt;stats.drops
op_increment
suffix:semicolon
r_return
id|NET_XMIT_DROP
suffix:semicolon
)brace
r_else
(brace
id|cl-&gt;stats.packets
op_increment
suffix:semicolon
id|cl-&gt;stats.bytes
op_add_assign
id|skb-&gt;len
suffix:semicolon
id|htb_activate
(paren
id|q
comma
id|cl
)paren
suffix:semicolon
)brace
id|sch-&gt;q.qlen
op_increment
suffix:semicolon
id|sch-&gt;stats.packets
op_increment
suffix:semicolon
id|sch-&gt;stats.bytes
op_add_assign
id|skb-&gt;len
suffix:semicolon
id|HTB_DBG
c_func
(paren
l_int|1
comma
l_int|1
comma
l_string|&quot;htb_enq_ok cl=%X skb=%p&bslash;n&quot;
comma
id|htb_classid
c_func
(paren
id|cl
)paren
comma
id|skb
)paren
suffix:semicolon
r_return
id|NET_XMIT_SUCCESS
suffix:semicolon
)brace
multiline_comment|/* TODO: requeuing packet charges it to policers again !! */
DECL|function|htb_requeue
r_static
r_int
id|htb_requeue
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|Qdisc
op_star
id|sch
)paren
(brace
r_struct
id|htb_sched
op_star
id|q
op_assign
(paren
r_struct
id|htb_sched
op_star
)paren
id|sch-&gt;data
suffix:semicolon
r_struct
id|htb_class
op_star
id|cl
op_assign
id|htb_classify
c_func
(paren
id|skb
comma
id|sch
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cl
op_eq
id|HTB_DIRECT
op_logical_or
op_logical_neg
id|cl
)paren
(brace
multiline_comment|/* enqueue to helper queue */
r_if
c_cond
(paren
id|q-&gt;direct_queue.qlen
OL
id|q-&gt;direct_qlen
op_logical_and
id|cl
)paren
(brace
id|__skb_queue_tail
c_func
(paren
op_amp
id|q-&gt;direct_queue
comma
id|skb
)paren
suffix:semicolon
id|q-&gt;direct_pkts
op_increment
suffix:semicolon
)brace
r_else
(brace
id|kfree_skb
(paren
id|skb
)paren
suffix:semicolon
id|sch-&gt;stats.drops
op_increment
suffix:semicolon
r_return
id|NET_XMIT_DROP
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|cl-&gt;un.leaf.q-&gt;ops
op_member_access_from_pointer
id|requeue
c_func
(paren
id|skb
comma
id|cl-&gt;un.leaf.q
)paren
op_ne
id|NET_XMIT_SUCCESS
)paren
(brace
id|sch-&gt;stats.drops
op_increment
suffix:semicolon
id|cl-&gt;stats.drops
op_increment
suffix:semicolon
r_return
id|NET_XMIT_DROP
suffix:semicolon
)brace
r_else
id|htb_activate
(paren
id|q
comma
id|cl
)paren
suffix:semicolon
id|sch-&gt;q.qlen
op_increment
suffix:semicolon
id|HTB_DBG
c_func
(paren
l_int|1
comma
l_int|1
comma
l_string|&quot;htb_req_ok cl=%X skb=%p&bslash;n&quot;
comma
id|htb_classid
c_func
(paren
id|cl
)paren
comma
id|skb
)paren
suffix:semicolon
r_return
id|NET_XMIT_SUCCESS
suffix:semicolon
)brace
DECL|function|htb_timer
r_static
r_void
id|htb_timer
c_func
(paren
r_int
r_int
id|arg
)paren
(brace
r_struct
id|Qdisc
op_star
id|sch
op_assign
(paren
r_struct
id|Qdisc
op_star
)paren
id|arg
suffix:semicolon
id|sch-&gt;flags
op_and_assign
op_complement
id|TCQ_F_THROTTLED
suffix:semicolon
id|wmb
c_func
(paren
)paren
suffix:semicolon
id|netif_schedule
c_func
(paren
id|sch-&gt;dev
)paren
suffix:semicolon
)brace
macro_line|#ifdef HTB_RATECM
DECL|macro|RT_GEN
mdefine_line|#define RT_GEN(D,R) R+=D-(R/HTB_EWMAC);D=0
DECL|function|htb_rate_timer
r_static
r_void
id|htb_rate_timer
c_func
(paren
r_int
r_int
id|arg
)paren
(brace
r_struct
id|Qdisc
op_star
id|sch
op_assign
(paren
r_struct
id|Qdisc
op_star
)paren
id|arg
suffix:semicolon
r_struct
id|htb_sched
op_star
id|q
op_assign
(paren
r_struct
id|htb_sched
op_star
)paren
id|sch-&gt;data
suffix:semicolon
r_struct
id|list_head
op_star
id|p
suffix:semicolon
multiline_comment|/* lock queue so that we can muck with it */
id|HTB_QLOCK
c_func
(paren
id|sch
)paren
suffix:semicolon
id|HTB_DBG
c_func
(paren
l_int|10
comma
l_int|1
comma
l_string|&quot;htb_rttmr j=%ld&bslash;n&quot;
comma
id|jiffies
)paren
suffix:semicolon
id|q-&gt;rttim.expires
op_assign
id|jiffies
op_plus
id|HZ
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|q-&gt;rttim
)paren
suffix:semicolon
multiline_comment|/* scan and recompute one bucket at time */
r_if
c_cond
(paren
op_increment
id|q-&gt;recmp_bucket
op_ge
id|HTB_HSIZE
)paren
id|q-&gt;recmp_bucket
op_assign
l_int|0
suffix:semicolon
id|list_for_each
(paren
id|p
comma
id|q-&gt;hash
op_plus
id|q-&gt;recmp_bucket
)paren
(brace
r_struct
id|htb_class
op_star
id|cl
op_assign
id|list_entry
c_func
(paren
id|p
comma
r_struct
id|htb_class
comma
id|hlist
)paren
suffix:semicolon
id|HTB_DBG
c_func
(paren
l_int|10
comma
l_int|2
comma
l_string|&quot;htb_rttmr_cl cl=%X sbyte=%lu spkt=%lu&bslash;n&quot;
comma
id|cl-&gt;classid
comma
id|cl-&gt;sum_bytes
comma
id|cl-&gt;sum_packets
)paren
suffix:semicolon
id|RT_GEN
(paren
id|cl-&gt;sum_bytes
comma
id|cl-&gt;rate_bytes
)paren
suffix:semicolon
id|RT_GEN
(paren
id|cl-&gt;sum_packets
comma
id|cl-&gt;rate_packets
)paren
suffix:semicolon
)brace
id|HTB_QUNLOCK
c_func
(paren
id|sch
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/**&n; * htb_charge_class - charges amount &quot;bytes&quot; to leaf and ancestors&n; *&n; * Routine assumes that packet &quot;bytes&quot; long was dequeued from leaf cl&n; * borrowing from &quot;level&quot;. It accounts bytes to ceil leaky bucket for&n; * leaf and all ancestors and to rate bucket for ancestors at levels&n; * &quot;level&quot; and higher. It also handles possible change of mode resulting&n; * from the update. Note that mode can also increase here (MAY_BORROW to&n; * CAN_SEND) because we can use more precise clock that event queue here.&n; * In such case we remove class from event queue first.&n; */
DECL|function|htb_charge_class
r_static
r_void
id|htb_charge_class
c_func
(paren
r_struct
id|htb_sched
op_star
id|q
comma
r_struct
id|htb_class
op_star
id|cl
comma
r_int
id|level
comma
r_int
id|bytes
)paren
(brace
r_int
id|toks
comma
id|diff
suffix:semicolon
r_enum
id|htb_cmode
id|old_mode
suffix:semicolon
id|HTB_DBG
c_func
(paren
l_int|5
comma
l_int|1
comma
l_string|&quot;htb_chrg_cl cl=%X lev=%d len=%d&bslash;n&quot;
comma
id|cl-&gt;classid
comma
id|level
comma
id|bytes
)paren
suffix:semicolon
DECL|macro|HTB_ACCNT
mdefine_line|#define HTB_ACCNT(T,B,R) toks = diff + cl-&gt;T; &bslash;&n;&t;if (toks &gt; cl-&gt;B) toks = cl-&gt;B; &bslash;&n;&t;toks -= L2T(cl, cl-&gt;R, bytes); &bslash;&n;&t;if (toks &lt;= -cl-&gt;mbuffer) toks = 1-cl-&gt;mbuffer; &bslash;&n;&t;cl-&gt;T = toks
r_while
c_loop
(paren
id|cl
)paren
(brace
id|HTB_CHCL
c_func
(paren
id|cl
)paren
suffix:semicolon
id|diff
op_assign
id|PSCHED_TDIFF_SAFE
c_func
(paren
id|q-&gt;now
comma
id|cl-&gt;t_c
comma
(paren
id|u32
)paren
id|cl-&gt;mbuffer
comma
l_int|0
)paren
suffix:semicolon
macro_line|#ifdef HTB_DEBUG
r_if
c_cond
(paren
id|diff
OG
id|cl-&gt;mbuffer
op_logical_or
id|diff
OL
l_int|0
op_logical_or
id|PSCHED_TLESS
c_func
(paren
id|q-&gt;now
comma
id|cl-&gt;t_c
)paren
)paren
(brace
r_if
c_cond
(paren
id|net_ratelimit
c_func
(paren
)paren
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;HTB: bad diff in charge, cl=%X diff=%lX now=%Lu then=%Lu j=%lu&bslash;n&quot;
comma
id|cl-&gt;classid
comma
id|diff
comma
(paren
r_int
r_int
r_int
)paren
id|q-&gt;now
comma
(paren
r_int
r_int
r_int
)paren
id|cl-&gt;t_c
comma
id|q-&gt;jiffies
)paren
suffix:semicolon
id|diff
op_assign
l_int|1000
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|cl-&gt;level
op_ge
id|level
)paren
(brace
r_if
c_cond
(paren
id|cl-&gt;level
op_eq
id|level
)paren
id|cl-&gt;xstats.lends
op_increment
suffix:semicolon
id|HTB_ACCNT
(paren
id|tokens
comma
id|buffer
comma
id|rate
)paren
suffix:semicolon
)brace
r_else
(brace
id|cl-&gt;xstats.borrows
op_increment
suffix:semicolon
id|cl-&gt;tokens
op_add_assign
id|diff
suffix:semicolon
multiline_comment|/* we moved t_c; update tokens */
)brace
id|HTB_ACCNT
(paren
id|ctokens
comma
id|cbuffer
comma
id|ceil
)paren
suffix:semicolon
id|cl-&gt;t_c
op_assign
id|q-&gt;now
suffix:semicolon
id|HTB_DBG
c_func
(paren
l_int|5
comma
l_int|2
comma
l_string|&quot;htb_chrg_clp cl=%X diff=%ld tok=%ld ctok=%ld&bslash;n&quot;
comma
id|cl-&gt;classid
comma
id|diff
comma
id|cl-&gt;tokens
comma
id|cl-&gt;ctokens
)paren
suffix:semicolon
id|old_mode
op_assign
id|cl-&gt;cmode
suffix:semicolon
id|diff
op_assign
l_int|0
suffix:semicolon
id|htb_change_class_mode
c_func
(paren
id|q
comma
id|cl
comma
op_amp
id|diff
)paren
suffix:semicolon
r_if
c_cond
(paren
id|old_mode
op_ne
id|cl-&gt;cmode
)paren
(brace
r_if
c_cond
(paren
id|old_mode
op_ne
id|HTB_CAN_SEND
)paren
id|htb_safe_rb_erase
c_func
(paren
op_amp
id|cl-&gt;pq_node
comma
id|q-&gt;wait_pq
op_plus
id|cl-&gt;level
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cl-&gt;cmode
op_ne
id|HTB_CAN_SEND
)paren
id|htb_add_to_wait_tree
(paren
id|q
comma
id|cl
comma
id|diff
comma
l_int|1
)paren
suffix:semicolon
)brace
macro_line|#ifdef HTB_RATECM
multiline_comment|/* update rate counters */
id|cl-&gt;sum_bytes
op_add_assign
id|bytes
suffix:semicolon
id|cl-&gt;sum_packets
op_increment
suffix:semicolon
macro_line|#endif
multiline_comment|/* update byte stats except for leaves which are already updated */
r_if
c_cond
(paren
id|cl-&gt;level
)paren
(brace
id|cl-&gt;stats.bytes
op_add_assign
id|bytes
suffix:semicolon
id|cl-&gt;stats.packets
op_increment
suffix:semicolon
)brace
id|cl
op_assign
id|cl-&gt;parent
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; * htb_do_events - make mode changes to classes at the level&n; *&n; * Scans event queue for pending events and applies them. Returns jiffies to&n; * next pending event (0 for no event in pq).&n; * Note: Aplied are events whose have cl-&gt;pq_key &lt;= jiffies.&n; */
DECL|function|htb_do_events
r_static
r_int
id|htb_do_events
c_func
(paren
r_struct
id|htb_sched
op_star
id|q
comma
r_int
id|level
)paren
(brace
r_int
id|i
suffix:semicolon
id|HTB_DBG
c_func
(paren
l_int|8
comma
l_int|1
comma
l_string|&quot;htb_do_events l=%d root=%p rmask=%X&bslash;n&quot;
comma
id|level
comma
id|q-&gt;wait_pq
(braket
id|level
)braket
dot
id|rb_node
comma
id|q-&gt;row_mask
(braket
id|level
)braket
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|500
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|htb_class
op_star
id|cl
suffix:semicolon
r_int
id|diff
suffix:semicolon
r_struct
id|rb_node
op_star
id|p
op_assign
id|q-&gt;wait_pq
(braket
id|level
)braket
dot
id|rb_node
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p
)paren
r_return
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|p-&gt;rb_left
)paren
id|p
op_assign
id|p-&gt;rb_left
suffix:semicolon
id|cl
op_assign
id|rb_entry
c_func
(paren
id|p
comma
r_struct
id|htb_class
comma
id|pq_node
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cl-&gt;pq_key
op_minus
(paren
id|q-&gt;jiffies
op_plus
l_int|1
)paren
OL
l_int|0x80000000
)paren
(brace
id|HTB_DBG
c_func
(paren
l_int|8
comma
l_int|3
comma
l_string|&quot;htb_do_ev_ret delay=%ld&bslash;n&quot;
comma
id|cl-&gt;pq_key
op_minus
id|q-&gt;jiffies
)paren
suffix:semicolon
r_return
id|cl-&gt;pq_key
op_minus
id|q-&gt;jiffies
suffix:semicolon
)brace
id|htb_safe_rb_erase
c_func
(paren
id|p
comma
id|q-&gt;wait_pq
op_plus
id|level
)paren
suffix:semicolon
id|diff
op_assign
id|PSCHED_TDIFF_SAFE
c_func
(paren
id|q-&gt;now
comma
id|cl-&gt;t_c
comma
(paren
id|u32
)paren
id|cl-&gt;mbuffer
comma
l_int|0
)paren
suffix:semicolon
macro_line|#ifdef HTB_DEBUG
r_if
c_cond
(paren
id|diff
OG
id|cl-&gt;mbuffer
op_logical_or
id|diff
OL
l_int|0
op_logical_or
id|PSCHED_TLESS
c_func
(paren
id|q-&gt;now
comma
id|cl-&gt;t_c
)paren
)paren
(brace
r_if
c_cond
(paren
id|net_ratelimit
c_func
(paren
)paren
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;HTB: bad diff in events, cl=%X diff=%lX now=%Lu then=%Lu j=%lu&bslash;n&quot;
comma
id|cl-&gt;classid
comma
id|diff
comma
(paren
r_int
r_int
r_int
)paren
id|q-&gt;now
comma
(paren
r_int
r_int
r_int
)paren
id|cl-&gt;t_c
comma
id|q-&gt;jiffies
)paren
suffix:semicolon
id|diff
op_assign
l_int|1000
suffix:semicolon
)brace
macro_line|#endif
id|htb_change_class_mode
c_func
(paren
id|q
comma
id|cl
comma
op_amp
id|diff
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cl-&gt;cmode
op_ne
id|HTB_CAN_SEND
)paren
id|htb_add_to_wait_tree
(paren
id|q
comma
id|cl
comma
id|diff
comma
l_int|2
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|net_ratelimit
c_func
(paren
)paren
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;htb: too many events !&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|HZ
op_div
l_int|10
suffix:semicolon
)brace
multiline_comment|/**&n; * htb_lookup_leaf - returns next leaf class in DRR order&n; *&n; * Find leaf where current feed pointers points to.&n; */
r_static
r_struct
id|htb_class
op_star
DECL|function|htb_lookup_leaf
id|htb_lookup_leaf
c_func
(paren
r_struct
id|rb_root
op_star
id|tree
comma
r_int
id|prio
comma
r_struct
id|rb_node
op_star
op_star
id|pptr
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
(brace
r_struct
id|rb_node
op_star
id|root
suffix:semicolon
r_struct
id|rb_node
op_star
op_star
id|pptr
suffix:semicolon
)brace
id|stk
(braket
id|TC_HTB_MAXDEPTH
)braket
comma
op_star
id|sp
op_assign
id|stk
suffix:semicolon
id|BUG_TRAP
c_func
(paren
id|tree-&gt;rb_node
)paren
suffix:semicolon
id|sp-&gt;root
op_assign
id|tree-&gt;rb_node
suffix:semicolon
id|sp-&gt;pptr
op_assign
id|pptr
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|65535
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
op_star
id|sp-&gt;pptr
)paren
(brace
multiline_comment|/* we are at right end; rewind &amp; go up */
op_star
id|sp-&gt;pptr
op_assign
id|sp-&gt;root
suffix:semicolon
r_while
c_loop
(paren
(paren
op_star
id|sp-&gt;pptr
)paren
op_member_access_from_pointer
id|rb_left
)paren
op_star
id|sp-&gt;pptr
op_assign
(paren
op_star
id|sp-&gt;pptr
)paren
op_member_access_from_pointer
id|rb_left
suffix:semicolon
r_if
c_cond
(paren
id|sp
OG
id|stk
)paren
(brace
id|sp
op_decrement
suffix:semicolon
id|BUG_TRAP
c_func
(paren
op_star
id|sp-&gt;pptr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_star
id|sp-&gt;pptr
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
id|htb_next_rb_node
(paren
id|sp-&gt;pptr
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
r_struct
id|htb_class
op_star
id|cl
suffix:semicolon
id|cl
op_assign
id|rb_entry
c_func
(paren
op_star
id|sp-&gt;pptr
comma
r_struct
id|htb_class
comma
id|node
(braket
id|prio
)braket
)paren
suffix:semicolon
id|HTB_CHCL
c_func
(paren
id|cl
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cl-&gt;level
)paren
r_return
id|cl
suffix:semicolon
(paren
op_increment
id|sp
)paren
op_member_access_from_pointer
id|root
op_assign
id|cl-&gt;un.inner.feed
(braket
id|prio
)braket
dot
id|rb_node
suffix:semicolon
id|sp-&gt;pptr
op_assign
id|cl-&gt;un.inner.ptr
op_plus
id|prio
suffix:semicolon
)brace
)brace
id|BUG_TRAP
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* dequeues packet at given priority and level; call only if&n;   you are sure that there is active class at prio/level */
r_static
r_struct
id|sk_buff
op_star
DECL|function|htb_dequeue_tree
id|htb_dequeue_tree
c_func
(paren
r_struct
id|htb_sched
op_star
id|q
comma
r_int
id|prio
comma
r_int
id|level
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|htb_class
op_star
id|cl
comma
op_star
id|start
suffix:semicolon
multiline_comment|/* look initial class up in the row */
id|start
op_assign
id|cl
op_assign
id|htb_lookup_leaf
(paren
id|q-&gt;row
(braket
id|level
)braket
op_plus
id|prio
comma
id|prio
comma
id|q-&gt;ptr
(braket
id|level
)braket
op_plus
id|prio
)paren
suffix:semicolon
r_do
(brace
id|next
suffix:colon
id|BUG_TRAP
c_func
(paren
id|cl
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cl
)paren
r_return
l_int|NULL
suffix:semicolon
id|HTB_DBG
c_func
(paren
l_int|4
comma
l_int|1
comma
l_string|&quot;htb_deq_tr prio=%d lev=%d cl=%X defic=%d&bslash;n&quot;
comma
id|prio
comma
id|level
comma
id|cl-&gt;classid
comma
id|cl-&gt;un.leaf.deficit
(braket
id|level
)braket
)paren
suffix:semicolon
multiline_comment|/* class can be empty - it is unlikely but can be true if leaf&n;&t;&t;   qdisc drops packets in enqueue routine or if someone used&n;&t;&t;   graft operation on the leaf since last dequeue; &n;&t;&t;   simply deactivate and skip such class */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|cl-&gt;un.leaf.q-&gt;q.qlen
op_eq
l_int|0
)paren
)paren
(brace
r_struct
id|htb_class
op_star
id|next
suffix:semicolon
id|htb_deactivate
c_func
(paren
id|q
comma
id|cl
)paren
suffix:semicolon
multiline_comment|/* row/level might become empty */
r_if
c_cond
(paren
(paren
id|q-&gt;row_mask
(braket
id|level
)braket
op_amp
(paren
l_int|1
op_lshift
id|prio
)paren
)paren
op_eq
l_int|0
)paren
r_return
l_int|NULL
suffix:semicolon
id|next
op_assign
id|htb_lookup_leaf
(paren
id|q-&gt;row
(braket
id|level
)braket
op_plus
id|prio
comma
id|prio
comma
id|q-&gt;ptr
(braket
id|level
)braket
op_plus
id|prio
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cl
op_eq
id|start
)paren
multiline_comment|/* fix start if we just deleted it */
id|start
op_assign
id|next
suffix:semicolon
id|cl
op_assign
id|next
suffix:semicolon
r_goto
id|next
suffix:semicolon
)brace
r_if
c_cond
(paren
id|likely
c_func
(paren
(paren
id|skb
op_assign
id|cl-&gt;un.leaf.q
op_member_access_from_pointer
id|dequeue
c_func
(paren
id|cl-&gt;un.leaf.q
)paren
)paren
op_ne
l_int|NULL
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cl-&gt;warned
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;htb: class %X isn&squot;t work conserving ?!&bslash;n&quot;
comma
id|cl-&gt;classid
)paren
suffix:semicolon
id|cl-&gt;warned
op_assign
l_int|1
suffix:semicolon
)brace
id|q-&gt;nwc_hit
op_increment
suffix:semicolon
id|htb_next_rb_node
c_func
(paren
(paren
id|level
ques
c_cond
id|cl-&gt;parent-&gt;un.inner.ptr
suffix:colon
id|q-&gt;ptr
(braket
l_int|0
)braket
)paren
op_plus
id|prio
)paren
suffix:semicolon
id|cl
op_assign
id|htb_lookup_leaf
(paren
id|q-&gt;row
(braket
id|level
)braket
op_plus
id|prio
comma
id|prio
comma
id|q-&gt;ptr
(braket
id|level
)braket
op_plus
id|prio
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|cl
op_ne
id|start
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
id|skb
op_ne
l_int|NULL
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|cl-&gt;un.leaf.deficit
(braket
id|level
)braket
op_sub_assign
id|skb-&gt;len
)paren
OL
l_int|0
)paren
(brace
id|HTB_DBG
c_func
(paren
l_int|4
comma
l_int|2
comma
l_string|&quot;htb_next_cl oldptr=%p quant_add=%d&bslash;n&quot;
comma
id|level
ques
c_cond
id|cl-&gt;parent-&gt;un.inner.ptr
(braket
id|prio
)braket
suffix:colon
id|q-&gt;ptr
(braket
l_int|0
)braket
(braket
id|prio
)braket
comma
id|cl-&gt;un.leaf.quantum
)paren
suffix:semicolon
id|cl-&gt;un.leaf.deficit
(braket
id|level
)braket
op_add_assign
id|cl-&gt;un.leaf.quantum
suffix:semicolon
id|htb_next_rb_node
c_func
(paren
(paren
id|level
ques
c_cond
id|cl-&gt;parent-&gt;un.inner.ptr
suffix:colon
id|q-&gt;ptr
(braket
l_int|0
)braket
)paren
op_plus
id|prio
)paren
suffix:semicolon
)brace
multiline_comment|/* this used to be after charge_class but this constelation&n;&t;&t;   gives us slightly better performance */
r_if
c_cond
(paren
op_logical_neg
id|cl-&gt;un.leaf.q-&gt;q.qlen
)paren
id|htb_deactivate
(paren
id|q
comma
id|cl
)paren
suffix:semicolon
id|htb_charge_class
(paren
id|q
comma
id|cl
comma
id|level
comma
id|skb-&gt;len
)paren
suffix:semicolon
)brace
r_return
id|skb
suffix:semicolon
)brace
DECL|function|htb_delay_by
r_static
r_void
id|htb_delay_by
c_func
(paren
r_struct
id|Qdisc
op_star
id|sch
comma
r_int
id|delay
)paren
(brace
r_struct
id|htb_sched
op_star
id|q
op_assign
(paren
r_struct
id|htb_sched
op_star
)paren
id|sch-&gt;data
suffix:semicolon
r_if
c_cond
(paren
id|netif_queue_stopped
c_func
(paren
id|sch-&gt;dev
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|delay
op_le
l_int|0
)paren
id|delay
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|delay
OG
l_int|5
op_star
id|HZ
)paren
)paren
(brace
r_if
c_cond
(paren
id|net_ratelimit
c_func
(paren
)paren
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;HTB delay %ld &gt; 5sec&bslash;n&quot;
comma
id|delay
)paren
suffix:semicolon
id|delay
op_assign
l_int|5
op_star
id|HZ
suffix:semicolon
)brace
multiline_comment|/* why don&squot;t use jiffies here ? because expires can be in past */
id|mod_timer
c_func
(paren
op_amp
id|q-&gt;timer
comma
id|q-&gt;jiffies
op_plus
id|delay
)paren
suffix:semicolon
id|sch-&gt;flags
op_or_assign
id|TCQ_F_THROTTLED
suffix:semicolon
id|sch-&gt;stats.overlimits
op_increment
suffix:semicolon
id|HTB_DBG
c_func
(paren
l_int|3
comma
l_int|1
comma
l_string|&quot;htb_deq t_delay=%ld&bslash;n&quot;
comma
id|delay
)paren
suffix:semicolon
)brace
DECL|function|htb_dequeue
r_static
r_struct
id|sk_buff
op_star
id|htb_dequeue
c_func
(paren
r_struct
id|Qdisc
op_star
id|sch
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|htb_sched
op_star
id|q
op_assign
(paren
r_struct
id|htb_sched
op_star
)paren
id|sch-&gt;data
suffix:semicolon
r_int
id|level
suffix:semicolon
r_int
id|min_delay
suffix:semicolon
macro_line|#ifdef HTB_DEBUG
r_int
id|evs_used
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
id|q-&gt;jiffies
op_assign
id|jiffies
suffix:semicolon
id|HTB_DBG
c_func
(paren
l_int|3
comma
l_int|1
comma
l_string|&quot;htb_deq dircnt=%d qlen=%d&bslash;n&quot;
comma
id|skb_queue_len
c_func
(paren
op_amp
id|q-&gt;direct_queue
)paren
comma
id|sch-&gt;q.qlen
)paren
suffix:semicolon
multiline_comment|/* try to dequeue direct packets as high prio (!) to minimize cpu work */
r_if
c_cond
(paren
(paren
id|skb
op_assign
id|__skb_dequeue
c_func
(paren
op_amp
id|q-&gt;direct_queue
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|sch-&gt;flags
op_and_assign
op_complement
id|TCQ_F_THROTTLED
suffix:semicolon
id|sch-&gt;q.qlen
op_decrement
suffix:semicolon
r_return
id|skb
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|sch-&gt;q.qlen
)paren
r_goto
id|fin
suffix:semicolon
id|PSCHED_GET_TIME
c_func
(paren
id|q-&gt;now
)paren
suffix:semicolon
id|min_delay
op_assign
id|LONG_MAX
suffix:semicolon
id|q-&gt;nwc_hit
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|level
op_assign
l_int|0
suffix:semicolon
id|level
OL
id|TC_HTB_MAXDEPTH
suffix:semicolon
id|level
op_increment
)paren
(brace
multiline_comment|/* common case optimization - skip event handler quickly */
r_int
id|m
suffix:semicolon
r_int
id|delay
suffix:semicolon
r_if
c_cond
(paren
id|q-&gt;jiffies
op_minus
id|q-&gt;near_ev_cache
(braket
id|level
)braket
OL
l_int|0x80000000
op_logical_or
l_int|0
)paren
(brace
id|delay
op_assign
id|htb_do_events
c_func
(paren
id|q
comma
id|level
)paren
suffix:semicolon
id|q-&gt;near_ev_cache
(braket
id|level
)braket
op_assign
id|q-&gt;jiffies
op_plus
(paren
id|delay
ques
c_cond
id|delay
suffix:colon
id|HZ
)paren
suffix:semicolon
macro_line|#ifdef HTB_DEBUG
id|evs_used
op_increment
suffix:semicolon
macro_line|#endif
)brace
r_else
id|delay
op_assign
id|q-&gt;near_ev_cache
(braket
id|level
)braket
op_minus
id|q-&gt;jiffies
suffix:semicolon
r_if
c_cond
(paren
id|delay
op_logical_and
id|min_delay
OG
id|delay
)paren
id|min_delay
op_assign
id|delay
suffix:semicolon
id|m
op_assign
op_complement
id|q-&gt;row_mask
(braket
id|level
)braket
suffix:semicolon
r_while
c_loop
(paren
id|m
op_ne
(paren
r_int
)paren
(paren
op_minus
l_int|1
)paren
)paren
(brace
r_int
id|prio
op_assign
id|ffz
(paren
id|m
)paren
suffix:semicolon
id|m
op_or_assign
l_int|1
op_lshift
id|prio
suffix:semicolon
id|skb
op_assign
id|htb_dequeue_tree
c_func
(paren
id|q
comma
id|prio
comma
id|level
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
id|skb
op_ne
l_int|NULL
)paren
)paren
(brace
id|sch-&gt;q.qlen
op_decrement
suffix:semicolon
id|sch-&gt;flags
op_and_assign
op_complement
id|TCQ_F_THROTTLED
suffix:semicolon
r_goto
id|fin
suffix:semicolon
)brace
)brace
)brace
macro_line|#ifdef HTB_DEBUG
r_if
c_cond
(paren
op_logical_neg
id|q-&gt;nwc_hit
op_logical_and
id|min_delay
op_ge
l_int|10
op_star
id|HZ
op_logical_and
id|net_ratelimit
c_func
(paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|min_delay
op_eq
id|LONG_MAX
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;HTB: dequeue bug (%d,%lu,%lu), report it please !&bslash;n&quot;
comma
id|evs_used
comma
id|q-&gt;jiffies
comma
id|jiffies
)paren
suffix:semicolon
id|htb_debug_dump
c_func
(paren
id|q
)paren
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;HTB: mindelay=%ld, some class has &quot;
l_string|&quot;too small rate&bslash;n&quot;
comma
id|min_delay
)paren
suffix:semicolon
)brace
macro_line|#endif
id|htb_delay_by
(paren
id|sch
comma
id|min_delay
OG
l_int|5
op_star
id|HZ
ques
c_cond
l_int|5
op_star
id|HZ
suffix:colon
id|min_delay
)paren
suffix:semicolon
id|fin
suffix:colon
id|HTB_DBG
c_func
(paren
l_int|3
comma
l_int|1
comma
l_string|&quot;htb_deq_end %s j=%lu skb=%p&bslash;n&quot;
comma
id|sch-&gt;dev-&gt;name
comma
id|q-&gt;jiffies
comma
id|skb
)paren
suffix:semicolon
r_return
id|skb
suffix:semicolon
)brace
multiline_comment|/* try to drop from each class (by prio) until one succeed */
DECL|function|htb_drop
r_static
r_int
r_int
id|htb_drop
c_func
(paren
r_struct
id|Qdisc
op_star
id|sch
)paren
(brace
r_struct
id|htb_sched
op_star
id|q
op_assign
(paren
r_struct
id|htb_sched
op_star
)paren
id|sch-&gt;data
suffix:semicolon
r_int
id|prio
suffix:semicolon
r_for
c_loop
(paren
id|prio
op_assign
id|TC_HTB_NUMPRIO
op_minus
l_int|1
suffix:semicolon
id|prio
op_ge
l_int|0
suffix:semicolon
id|prio
op_decrement
)paren
(brace
r_struct
id|list_head
op_star
id|p
suffix:semicolon
id|list_for_each
(paren
id|p
comma
id|q-&gt;drops
op_plus
id|prio
)paren
(brace
r_struct
id|htb_class
op_star
id|cl
op_assign
id|list_entry
c_func
(paren
id|p
comma
r_struct
id|htb_class
comma
id|un.leaf.drop_list
)paren
suffix:semicolon
r_int
r_int
id|len
suffix:semicolon
r_if
c_cond
(paren
id|cl-&gt;un.leaf.q-&gt;ops-&gt;drop
op_logical_and
(paren
id|len
op_assign
id|cl-&gt;un.leaf.q-&gt;ops
op_member_access_from_pointer
id|drop
c_func
(paren
id|cl-&gt;un.leaf.q
)paren
)paren
)paren
(brace
id|sch-&gt;q.qlen
op_decrement
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cl-&gt;un.leaf.q-&gt;q.qlen
)paren
id|htb_deactivate
(paren
id|q
comma
id|cl
)paren
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* reset all classes */
multiline_comment|/* always caled under BH &amp; queue lock */
DECL|function|htb_reset
r_static
r_void
id|htb_reset
c_func
(paren
r_struct
id|Qdisc
op_star
id|sch
)paren
(brace
r_struct
id|htb_sched
op_star
id|q
op_assign
(paren
r_struct
id|htb_sched
op_star
)paren
id|sch-&gt;data
suffix:semicolon
r_int
id|i
suffix:semicolon
id|HTB_DBG
c_func
(paren
l_int|0
comma
l_int|1
comma
l_string|&quot;htb_reset sch=%p, handle=%X&bslash;n&quot;
comma
id|sch
comma
id|sch-&gt;handle
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|HTB_HSIZE
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|list_head
op_star
id|p
suffix:semicolon
id|list_for_each
(paren
id|p
comma
id|q-&gt;hash
op_plus
id|i
)paren
(brace
r_struct
id|htb_class
op_star
id|cl
op_assign
id|list_entry
c_func
(paren
id|p
comma
r_struct
id|htb_class
comma
id|hlist
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cl-&gt;level
)paren
id|memset
c_func
(paren
op_amp
id|cl-&gt;un.inner
comma
l_int|0
comma
r_sizeof
(paren
id|cl-&gt;un.inner
)paren
)paren
suffix:semicolon
r_else
(brace
r_if
c_cond
(paren
id|cl-&gt;un.leaf.q
)paren
id|qdisc_reset
c_func
(paren
id|cl-&gt;un.leaf.q
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|cl-&gt;un.leaf.drop_list
)paren
suffix:semicolon
)brace
id|cl-&gt;prio_activity
op_assign
l_int|0
suffix:semicolon
id|cl-&gt;cmode
op_assign
id|HTB_CAN_SEND
suffix:semicolon
macro_line|#ifdef HTB_DEBUG
id|cl-&gt;pq_node.rb_color
op_assign
op_minus
l_int|1
suffix:semicolon
id|memset
c_func
(paren
id|cl-&gt;node
comma
l_int|255
comma
r_sizeof
(paren
id|cl-&gt;node
)paren
)paren
suffix:semicolon
macro_line|#endif
)brace
)brace
id|sch-&gt;flags
op_and_assign
op_complement
id|TCQ_F_THROTTLED
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|q-&gt;timer
)paren
suffix:semicolon
id|__skb_queue_purge
c_func
(paren
op_amp
id|q-&gt;direct_queue
)paren
suffix:semicolon
id|sch-&gt;q.qlen
op_assign
l_int|0
suffix:semicolon
id|memset
c_func
(paren
id|q-&gt;row
comma
l_int|0
comma
r_sizeof
(paren
id|q-&gt;row
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|q-&gt;row_mask
comma
l_int|0
comma
r_sizeof
(paren
id|q-&gt;row_mask
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|q-&gt;wait_pq
comma
l_int|0
comma
r_sizeof
(paren
id|q-&gt;wait_pq
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|q-&gt;ptr
comma
l_int|0
comma
r_sizeof
(paren
id|q-&gt;ptr
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|TC_HTB_NUMPRIO
suffix:semicolon
id|i
op_increment
)paren
id|INIT_LIST_HEAD
c_func
(paren
id|q-&gt;drops
op_plus
id|i
)paren
suffix:semicolon
)brace
DECL|function|htb_init
r_static
r_int
id|htb_init
c_func
(paren
r_struct
id|Qdisc
op_star
id|sch
comma
r_struct
id|rtattr
op_star
id|opt
)paren
(brace
r_struct
id|htb_sched
op_star
id|q
op_assign
(paren
r_struct
id|htb_sched
op_star
)paren
id|sch-&gt;data
suffix:semicolon
r_struct
id|rtattr
op_star
id|tb
(braket
id|TCA_HTB_INIT
)braket
suffix:semicolon
r_struct
id|tc_htb_glob
op_star
id|gopt
suffix:semicolon
r_int
id|i
suffix:semicolon
macro_line|#ifdef HTB_DEBUG
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;HTB init, kernel part version %d.%d&bslash;n&quot;
comma
id|HTB_VER
op_rshift
l_int|16
comma
id|HTB_VER
op_amp
l_int|0xffff
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|opt
op_logical_or
id|rtattr_parse
c_func
(paren
id|tb
comma
id|TCA_HTB_INIT
comma
id|RTA_DATA
c_func
(paren
id|opt
)paren
comma
id|RTA_PAYLOAD
c_func
(paren
id|opt
)paren
)paren
op_logical_or
id|tb
(braket
id|TCA_HTB_INIT
op_minus
l_int|1
)braket
op_eq
l_int|NULL
op_logical_or
id|RTA_PAYLOAD
c_func
(paren
id|tb
(braket
id|TCA_HTB_INIT
op_minus
l_int|1
)braket
)paren
OL
r_sizeof
(paren
op_star
id|gopt
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;HTB: hey probably you have bad tc tool ?&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|gopt
op_assign
id|RTA_DATA
c_func
(paren
id|tb
(braket
id|TCA_HTB_INIT
op_minus
l_int|1
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|gopt-&gt;version
op_ne
id|HTB_VER
op_rshift
l_int|16
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;HTB: need tc/htb version %d (minor is %d), you have %d&bslash;n&quot;
comma
id|HTB_VER
op_rshift
l_int|16
comma
id|HTB_VER
op_amp
l_int|0xffff
comma
id|gopt-&gt;version
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|memset
c_func
(paren
id|q
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|q
)paren
)paren
suffix:semicolon
id|q-&gt;debug
op_assign
id|gopt-&gt;debug
suffix:semicolon
id|HTB_DBG
c_func
(paren
l_int|0
comma
l_int|1
comma
l_string|&quot;htb_init sch=%p handle=%X r2q=%d&bslash;n&quot;
comma
id|sch
comma
id|sch-&gt;handle
comma
id|gopt-&gt;rate2quantum
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|q-&gt;root
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|HTB_HSIZE
suffix:semicolon
id|i
op_increment
)paren
id|INIT_LIST_HEAD
c_func
(paren
id|q-&gt;hash
op_plus
id|i
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|TC_HTB_NUMPRIO
suffix:semicolon
id|i
op_increment
)paren
id|INIT_LIST_HEAD
c_func
(paren
id|q-&gt;drops
op_plus
id|i
)paren
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|q-&gt;timer
)paren
suffix:semicolon
id|skb_queue_head_init
c_func
(paren
op_amp
id|q-&gt;direct_queue
)paren
suffix:semicolon
id|q-&gt;direct_qlen
op_assign
id|sch-&gt;dev-&gt;tx_queue_len
suffix:semicolon
r_if
c_cond
(paren
id|q-&gt;direct_qlen
OL
l_int|2
)paren
multiline_comment|/* some devices have zero tx_queue_len */
id|q-&gt;direct_qlen
op_assign
l_int|2
suffix:semicolon
id|q-&gt;timer.function
op_assign
id|htb_timer
suffix:semicolon
id|q-&gt;timer.data
op_assign
(paren
r_int
r_int
)paren
id|sch
suffix:semicolon
macro_line|#ifdef HTB_RATECM
id|init_timer
c_func
(paren
op_amp
id|q-&gt;rttim
)paren
suffix:semicolon
id|q-&gt;rttim.function
op_assign
id|htb_rate_timer
suffix:semicolon
id|q-&gt;rttim.data
op_assign
(paren
r_int
r_int
)paren
id|sch
suffix:semicolon
id|q-&gt;rttim.expires
op_assign
id|jiffies
op_plus
id|HZ
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|q-&gt;rttim
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
(paren
id|q-&gt;rate2quantum
op_assign
id|gopt-&gt;rate2quantum
)paren
OL
l_int|1
)paren
id|q-&gt;rate2quantum
op_assign
l_int|1
suffix:semicolon
id|q-&gt;defcls
op_assign
id|gopt-&gt;defcls
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|htb_dump
r_static
r_int
id|htb_dump
c_func
(paren
r_struct
id|Qdisc
op_star
id|sch
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|htb_sched
op_star
id|q
op_assign
(paren
r_struct
id|htb_sched
op_star
)paren
id|sch-&gt;data
suffix:semicolon
r_int
r_char
op_star
id|b
op_assign
id|skb-&gt;tail
suffix:semicolon
r_struct
id|rtattr
op_star
id|rta
suffix:semicolon
r_struct
id|tc_htb_glob
id|gopt
suffix:semicolon
id|HTB_DBG
c_func
(paren
l_int|0
comma
l_int|1
comma
l_string|&quot;htb_dump sch=%p, handle=%X&bslash;n&quot;
comma
id|sch
comma
id|sch-&gt;handle
)paren
suffix:semicolon
multiline_comment|/* stats */
id|HTB_QLOCK
c_func
(paren
id|sch
)paren
suffix:semicolon
id|gopt.direct_pkts
op_assign
id|q-&gt;direct_pkts
suffix:semicolon
macro_line|#ifdef HTB_DEBUG
r_if
c_cond
(paren
id|HTB_DBG_COND
c_func
(paren
l_int|0
comma
l_int|2
)paren
)paren
id|htb_debug_dump
c_func
(paren
id|q
)paren
suffix:semicolon
macro_line|#endif
id|gopt.version
op_assign
id|HTB_VER
suffix:semicolon
id|gopt.rate2quantum
op_assign
id|q-&gt;rate2quantum
suffix:semicolon
id|gopt.defcls
op_assign
id|q-&gt;defcls
suffix:semicolon
id|gopt.debug
op_assign
id|q-&gt;debug
suffix:semicolon
id|rta
op_assign
(paren
r_struct
id|rtattr
op_star
)paren
id|b
suffix:semicolon
id|RTA_PUT
c_func
(paren
id|skb
comma
id|TCA_OPTIONS
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
id|RTA_PUT
c_func
(paren
id|skb
comma
id|TCA_HTB_INIT
comma
r_sizeof
(paren
id|gopt
)paren
comma
op_amp
id|gopt
)paren
suffix:semicolon
id|rta-&gt;rta_len
op_assign
id|skb-&gt;tail
op_minus
id|b
suffix:semicolon
id|sch-&gt;stats.qlen
op_assign
id|sch-&gt;q.qlen
suffix:semicolon
id|RTA_PUT
c_func
(paren
id|skb
comma
id|TCA_STATS
comma
r_sizeof
(paren
id|sch-&gt;stats
)paren
comma
op_amp
id|sch-&gt;stats
)paren
suffix:semicolon
id|HTB_QUNLOCK
c_func
(paren
id|sch
)paren
suffix:semicolon
r_return
id|skb-&gt;len
suffix:semicolon
id|rtattr_failure
suffix:colon
id|HTB_QUNLOCK
c_func
(paren
id|sch
)paren
suffix:semicolon
id|skb_trim
c_func
(paren
id|skb
comma
id|skb-&gt;tail
op_minus
id|skb-&gt;data
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
DECL|function|htb_dump_class
r_static
r_int
id|htb_dump_class
c_func
(paren
r_struct
id|Qdisc
op_star
id|sch
comma
r_int
r_int
id|arg
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|tcmsg
op_star
id|tcm
)paren
(brace
macro_line|#ifdef HTB_DEBUG
r_struct
id|htb_sched
op_star
id|q
op_assign
(paren
r_struct
id|htb_sched
op_star
)paren
id|sch-&gt;data
suffix:semicolon
macro_line|#endif
r_struct
id|htb_class
op_star
id|cl
op_assign
(paren
r_struct
id|htb_class
op_star
)paren
id|arg
suffix:semicolon
r_int
r_char
op_star
id|b
op_assign
id|skb-&gt;tail
suffix:semicolon
r_struct
id|rtattr
op_star
id|rta
suffix:semicolon
r_struct
id|tc_htb_opt
id|opt
suffix:semicolon
id|HTB_DBG
c_func
(paren
l_int|0
comma
l_int|1
comma
l_string|&quot;htb_dump_class handle=%X clid=%X&bslash;n&quot;
comma
id|sch-&gt;handle
comma
id|cl-&gt;classid
)paren
suffix:semicolon
id|HTB_QLOCK
c_func
(paren
id|sch
)paren
suffix:semicolon
id|tcm-&gt;tcm_parent
op_assign
id|cl-&gt;parent
ques
c_cond
id|cl-&gt;parent-&gt;classid
suffix:colon
id|TC_H_ROOT
suffix:semicolon
id|tcm-&gt;tcm_handle
op_assign
id|cl-&gt;classid
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cl-&gt;level
op_logical_and
id|cl-&gt;un.leaf.q
)paren
(brace
id|tcm-&gt;tcm_info
op_assign
id|cl-&gt;un.leaf.q-&gt;handle
suffix:semicolon
id|cl-&gt;stats.qlen
op_assign
id|cl-&gt;un.leaf.q-&gt;q.qlen
suffix:semicolon
)brace
id|rta
op_assign
(paren
r_struct
id|rtattr
op_star
)paren
id|b
suffix:semicolon
id|RTA_PUT
c_func
(paren
id|skb
comma
id|TCA_OPTIONS
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
id|memset
(paren
op_amp
id|opt
comma
l_int|0
comma
r_sizeof
(paren
id|opt
)paren
)paren
suffix:semicolon
id|opt.rate
op_assign
id|cl-&gt;rate-&gt;rate
suffix:semicolon
id|opt.buffer
op_assign
id|cl-&gt;buffer
suffix:semicolon
id|opt.ceil
op_assign
id|cl-&gt;ceil-&gt;rate
suffix:semicolon
id|opt.cbuffer
op_assign
id|cl-&gt;cbuffer
suffix:semicolon
id|opt.quantum
op_assign
id|cl-&gt;un.leaf.quantum
suffix:semicolon
id|opt.prio
op_assign
id|cl-&gt;un.leaf.prio
suffix:semicolon
id|opt.level
op_assign
id|cl-&gt;level
suffix:semicolon
id|RTA_PUT
c_func
(paren
id|skb
comma
id|TCA_HTB_PARMS
comma
r_sizeof
(paren
id|opt
)paren
comma
op_amp
id|opt
)paren
suffix:semicolon
id|rta-&gt;rta_len
op_assign
id|skb-&gt;tail
op_minus
id|b
suffix:semicolon
macro_line|#ifdef HTB_RATECM
id|cl-&gt;stats.bps
op_assign
id|cl-&gt;rate_bytes
op_div
(paren
id|HTB_EWMAC
op_star
id|HTB_HSIZE
)paren
suffix:semicolon
id|cl-&gt;stats.pps
op_assign
id|cl-&gt;rate_packets
op_div
(paren
id|HTB_EWMAC
op_star
id|HTB_HSIZE
)paren
suffix:semicolon
macro_line|#endif
id|cl-&gt;xstats.tokens
op_assign
id|cl-&gt;tokens
suffix:semicolon
id|cl-&gt;xstats.ctokens
op_assign
id|cl-&gt;ctokens
suffix:semicolon
id|RTA_PUT
c_func
(paren
id|skb
comma
id|TCA_STATS
comma
r_sizeof
(paren
id|cl-&gt;stats
)paren
comma
op_amp
id|cl-&gt;stats
)paren
suffix:semicolon
id|RTA_PUT
c_func
(paren
id|skb
comma
id|TCA_XSTATS
comma
r_sizeof
(paren
id|cl-&gt;xstats
)paren
comma
op_amp
id|cl-&gt;xstats
)paren
suffix:semicolon
id|HTB_QUNLOCK
c_func
(paren
id|sch
)paren
suffix:semicolon
r_return
id|skb-&gt;len
suffix:semicolon
id|rtattr_failure
suffix:colon
id|HTB_QUNLOCK
c_func
(paren
id|sch
)paren
suffix:semicolon
id|skb_trim
c_func
(paren
id|skb
comma
id|b
op_minus
id|skb-&gt;data
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
DECL|function|htb_graft
r_static
r_int
id|htb_graft
c_func
(paren
r_struct
id|Qdisc
op_star
id|sch
comma
r_int
r_int
id|arg
comma
r_struct
id|Qdisc
op_star
r_new
comma
r_struct
id|Qdisc
op_star
op_star
id|old
)paren
(brace
r_struct
id|htb_class
op_star
id|cl
op_assign
(paren
r_struct
id|htb_class
op_star
)paren
id|arg
suffix:semicolon
r_if
c_cond
(paren
id|cl
op_logical_and
op_logical_neg
id|cl-&gt;level
)paren
(brace
r_if
c_cond
(paren
r_new
op_eq
l_int|NULL
op_logical_and
(paren
r_new
op_assign
id|qdisc_create_dflt
c_func
(paren
id|sch-&gt;dev
comma
op_amp
id|pfifo_qdisc_ops
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOBUFS
suffix:semicolon
id|sch_tree_lock
c_func
(paren
id|sch
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
op_star
id|old
op_assign
id|xchg
c_func
(paren
op_amp
id|cl-&gt;un.leaf.q
comma
r_new
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|cl-&gt;prio_activity
)paren
id|htb_deactivate
(paren
(paren
r_struct
id|htb_sched
op_star
)paren
id|sch-&gt;data
comma
id|cl
)paren
suffix:semicolon
multiline_comment|/* TODO: is it correct ? Why CBQ doesn&squot;t do it ? */
id|sch-&gt;q.qlen
op_sub_assign
(paren
op_star
id|old
)paren
op_member_access_from_pointer
id|q.qlen
suffix:semicolon
id|qdisc_reset
c_func
(paren
op_star
id|old
)paren
suffix:semicolon
)brace
id|sch_tree_unlock
c_func
(paren
id|sch
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
op_minus
id|ENOENT
suffix:semicolon
)brace
DECL|function|htb_leaf
r_static
r_struct
id|Qdisc
op_star
id|htb_leaf
c_func
(paren
r_struct
id|Qdisc
op_star
id|sch
comma
r_int
r_int
id|arg
)paren
(brace
r_struct
id|htb_class
op_star
id|cl
op_assign
(paren
r_struct
id|htb_class
op_star
)paren
id|arg
suffix:semicolon
r_return
(paren
id|cl
op_logical_and
op_logical_neg
id|cl-&gt;level
)paren
ques
c_cond
id|cl-&gt;un.leaf.q
suffix:colon
l_int|NULL
suffix:semicolon
)brace
DECL|function|htb_get
r_static
r_int
r_int
id|htb_get
c_func
(paren
r_struct
id|Qdisc
op_star
id|sch
comma
id|u32
id|classid
)paren
(brace
macro_line|#ifdef HTB_DEBUG
r_struct
id|htb_sched
op_star
id|q
op_assign
(paren
r_struct
id|htb_sched
op_star
)paren
id|sch-&gt;data
suffix:semicolon
macro_line|#endif
r_struct
id|htb_class
op_star
id|cl
op_assign
id|htb_find
c_func
(paren
id|classid
comma
id|sch
)paren
suffix:semicolon
id|HTB_DBG
c_func
(paren
l_int|0
comma
l_int|1
comma
l_string|&quot;htb_get clid=%X q=%p cl=%p ref=%d&bslash;n&quot;
comma
id|classid
comma
id|q
comma
id|cl
comma
id|cl
ques
c_cond
id|cl-&gt;refcnt
suffix:colon
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cl
)paren
id|cl-&gt;refcnt
op_increment
suffix:semicolon
r_return
(paren
r_int
r_int
)paren
id|cl
suffix:semicolon
)brace
DECL|function|htb_destroy_filters
r_static
r_void
id|htb_destroy_filters
c_func
(paren
r_struct
id|tcf_proto
op_star
op_star
id|fl
)paren
(brace
r_struct
id|tcf_proto
op_star
id|tp
suffix:semicolon
r_while
c_loop
(paren
(paren
id|tp
op_assign
op_star
id|fl
)paren
op_ne
l_int|NULL
)paren
(brace
op_star
id|fl
op_assign
id|tp-&gt;next
suffix:semicolon
id|tcf_destroy
c_func
(paren
id|tp
)paren
suffix:semicolon
)brace
)brace
DECL|function|htb_destroy_class
r_static
r_void
id|htb_destroy_class
c_func
(paren
r_struct
id|Qdisc
op_star
id|sch
comma
r_struct
id|htb_class
op_star
id|cl
)paren
(brace
r_struct
id|htb_sched
op_star
id|q
op_assign
(paren
r_struct
id|htb_sched
op_star
)paren
id|sch-&gt;data
suffix:semicolon
id|HTB_DBG
c_func
(paren
l_int|0
comma
l_int|1
comma
l_string|&quot;htb_destrycls clid=%X ref=%d&bslash;n&quot;
comma
id|cl
ques
c_cond
id|cl-&gt;classid
suffix:colon
l_int|0
comma
id|cl
ques
c_cond
id|cl-&gt;refcnt
suffix:colon
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cl-&gt;level
)paren
(brace
id|BUG_TRAP
c_func
(paren
id|cl-&gt;un.leaf.q
)paren
suffix:semicolon
id|sch-&gt;q.qlen
op_sub_assign
id|cl-&gt;un.leaf.q-&gt;q.qlen
suffix:semicolon
id|qdisc_destroy
c_func
(paren
id|cl-&gt;un.leaf.q
)paren
suffix:semicolon
)brace
id|qdisc_put_rtab
c_func
(paren
id|cl-&gt;rate
)paren
suffix:semicolon
id|qdisc_put_rtab
c_func
(paren
id|cl-&gt;ceil
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_NET_ESTIMATOR
id|qdisc_kill_estimator
c_func
(paren
op_amp
id|cl-&gt;stats
)paren
suffix:semicolon
macro_line|#endif
id|htb_destroy_filters
(paren
op_amp
id|cl-&gt;filter_list
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|cl-&gt;children
)paren
)paren
id|htb_destroy_class
(paren
id|sch
comma
id|list_entry
c_func
(paren
id|cl-&gt;children.next
comma
r_struct
id|htb_class
comma
id|sibling
)paren
)paren
suffix:semicolon
multiline_comment|/* note: this delete may happen twice (see htb_delete) */
id|list_del
c_func
(paren
op_amp
id|cl-&gt;hlist
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|cl-&gt;sibling
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cl-&gt;prio_activity
)paren
id|htb_deactivate
(paren
id|q
comma
id|cl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cl-&gt;cmode
op_ne
id|HTB_CAN_SEND
)paren
id|htb_safe_rb_erase
c_func
(paren
op_amp
id|cl-&gt;pq_node
comma
id|q-&gt;wait_pq
op_plus
id|cl-&gt;level
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|cl
)paren
suffix:semicolon
)brace
multiline_comment|/* always caled under BH &amp; queue lock */
DECL|function|htb_destroy
r_static
r_void
id|htb_destroy
c_func
(paren
r_struct
id|Qdisc
op_star
id|sch
)paren
(brace
r_struct
id|htb_sched
op_star
id|q
op_assign
(paren
r_struct
id|htb_sched
op_star
)paren
id|sch-&gt;data
suffix:semicolon
id|HTB_DBG
c_func
(paren
l_int|0
comma
l_int|1
comma
l_string|&quot;htb_destroy q=%p&bslash;n&quot;
comma
id|q
)paren
suffix:semicolon
id|del_timer_sync
(paren
op_amp
id|q-&gt;timer
)paren
suffix:semicolon
macro_line|#ifdef HTB_RATECM
id|del_timer_sync
(paren
op_amp
id|q-&gt;rttim
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* This line used to be after htb_destroy_class call below&n;&t;   and surprisingly it worked in 2.4. But it must precede it &n;&t;   because filter need its target class alive to be able to call&n;&t;   unbind_filter on it (without Oops). */
id|htb_destroy_filters
c_func
(paren
op_amp
id|q-&gt;filter_list
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|q-&gt;root
)paren
)paren
id|htb_destroy_class
(paren
id|sch
comma
id|list_entry
c_func
(paren
id|q-&gt;root.next
comma
r_struct
id|htb_class
comma
id|sibling
)paren
)paren
suffix:semicolon
id|__skb_queue_purge
c_func
(paren
op_amp
id|q-&gt;direct_queue
)paren
suffix:semicolon
)brace
DECL|function|htb_delete
r_static
r_int
id|htb_delete
c_func
(paren
r_struct
id|Qdisc
op_star
id|sch
comma
r_int
r_int
id|arg
)paren
(brace
r_struct
id|htb_sched
op_star
id|q
op_assign
(paren
r_struct
id|htb_sched
op_star
)paren
id|sch-&gt;data
suffix:semicolon
r_struct
id|htb_class
op_star
id|cl
op_assign
(paren
r_struct
id|htb_class
op_star
)paren
id|arg
suffix:semicolon
id|HTB_DBG
c_func
(paren
l_int|0
comma
l_int|1
comma
l_string|&quot;htb_delete q=%p cl=%X ref=%d&bslash;n&quot;
comma
id|q
comma
id|cl
ques
c_cond
id|cl-&gt;classid
suffix:colon
l_int|0
comma
id|cl
ques
c_cond
id|cl-&gt;refcnt
suffix:colon
l_int|0
)paren
suffix:semicolon
singleline_comment|// TODO: why don&squot;t allow to delete subtree ? references ? does
singleline_comment|// tc subsys quarantee us that in htb_destroy it holds no class
singleline_comment|// refs so that we can remove children safely there ?
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|cl-&gt;children
)paren
op_logical_or
id|cl-&gt;filter_cnt
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
id|sch_tree_lock
c_func
(paren
id|sch
)paren
suffix:semicolon
multiline_comment|/* delete from hash and active; remainder in destroy_class */
id|list_del_init
c_func
(paren
op_amp
id|cl-&gt;hlist
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cl-&gt;prio_activity
)paren
id|htb_deactivate
(paren
id|q
comma
id|cl
)paren
suffix:semicolon
r_if
c_cond
(paren
op_decrement
id|cl-&gt;refcnt
op_eq
l_int|0
)paren
id|htb_destroy_class
c_func
(paren
id|sch
comma
id|cl
)paren
suffix:semicolon
id|sch_tree_unlock
c_func
(paren
id|sch
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|htb_put
r_static
r_void
id|htb_put
c_func
(paren
r_struct
id|Qdisc
op_star
id|sch
comma
r_int
r_int
id|arg
)paren
(brace
macro_line|#ifdef HTB_DEBUG
r_struct
id|htb_sched
op_star
id|q
op_assign
(paren
r_struct
id|htb_sched
op_star
)paren
id|sch-&gt;data
suffix:semicolon
macro_line|#endif
r_struct
id|htb_class
op_star
id|cl
op_assign
(paren
r_struct
id|htb_class
op_star
)paren
id|arg
suffix:semicolon
id|HTB_DBG
c_func
(paren
l_int|0
comma
l_int|1
comma
l_string|&quot;htb_put q=%p cl=%X ref=%d&bslash;n&quot;
comma
id|q
comma
id|cl
ques
c_cond
id|cl-&gt;classid
suffix:colon
l_int|0
comma
id|cl
ques
c_cond
id|cl-&gt;refcnt
suffix:colon
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_decrement
id|cl-&gt;refcnt
op_eq
l_int|0
)paren
id|htb_destroy_class
c_func
(paren
id|sch
comma
id|cl
)paren
suffix:semicolon
)brace
DECL|function|htb_change_class
r_static
r_int
id|htb_change_class
c_func
(paren
r_struct
id|Qdisc
op_star
id|sch
comma
id|u32
id|classid
comma
id|u32
id|parentid
comma
r_struct
id|rtattr
op_star
op_star
id|tca
comma
r_int
r_int
op_star
id|arg
)paren
(brace
r_int
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_struct
id|htb_sched
op_star
id|q
op_assign
(paren
r_struct
id|htb_sched
op_star
)paren
id|sch-&gt;data
suffix:semicolon
r_struct
id|htb_class
op_star
id|cl
op_assign
(paren
r_struct
id|htb_class
op_star
)paren
op_star
id|arg
comma
op_star
id|parent
suffix:semicolon
r_struct
id|rtattr
op_star
id|opt
op_assign
id|tca
(braket
id|TCA_OPTIONS
op_minus
l_int|1
)braket
suffix:semicolon
r_struct
id|qdisc_rate_table
op_star
id|rtab
op_assign
l_int|NULL
comma
op_star
id|ctab
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|rtattr
op_star
id|tb
(braket
id|TCA_HTB_RTAB
)braket
suffix:semicolon
r_struct
id|tc_htb_opt
op_star
id|hopt
suffix:semicolon
multiline_comment|/* extract all subattrs from opt attr */
r_if
c_cond
(paren
op_logical_neg
id|opt
op_logical_or
id|rtattr_parse
c_func
(paren
id|tb
comma
id|TCA_HTB_RTAB
comma
id|RTA_DATA
c_func
(paren
id|opt
)paren
comma
id|RTA_PAYLOAD
c_func
(paren
id|opt
)paren
)paren
op_logical_or
id|tb
(braket
id|TCA_HTB_PARMS
op_minus
l_int|1
)braket
op_eq
l_int|NULL
op_logical_or
id|RTA_PAYLOAD
c_func
(paren
id|tb
(braket
id|TCA_HTB_PARMS
op_minus
l_int|1
)braket
)paren
OL
r_sizeof
(paren
op_star
id|hopt
)paren
)paren
r_goto
id|failure
suffix:semicolon
id|parent
op_assign
id|parentid
op_eq
id|TC_H_ROOT
ques
c_cond
l_int|NULL
suffix:colon
id|htb_find
(paren
id|parentid
comma
id|sch
)paren
suffix:semicolon
id|hopt
op_assign
id|RTA_DATA
c_func
(paren
id|tb
(braket
id|TCA_HTB_PARMS
op_minus
l_int|1
)braket
)paren
suffix:semicolon
id|HTB_DBG
c_func
(paren
l_int|0
comma
l_int|1
comma
l_string|&quot;htb_chg cl=%p(%X), clid=%X, parid=%X, opt/prio=%d, rate=%u, buff=%d, quant=%d&bslash;n&quot;
comma
id|cl
comma
id|cl
ques
c_cond
id|cl-&gt;classid
suffix:colon
l_int|0
comma
id|classid
comma
id|parentid
comma
(paren
r_int
)paren
id|hopt-&gt;prio
comma
id|hopt-&gt;rate.rate
comma
id|hopt-&gt;buffer
comma
id|hopt-&gt;quantum
)paren
suffix:semicolon
id|rtab
op_assign
id|qdisc_get_rtab
c_func
(paren
op_amp
id|hopt-&gt;rate
comma
id|tb
(braket
id|TCA_HTB_RTAB
op_minus
l_int|1
)braket
)paren
suffix:semicolon
id|ctab
op_assign
id|qdisc_get_rtab
c_func
(paren
op_amp
id|hopt-&gt;ceil
comma
id|tb
(braket
id|TCA_HTB_CTAB
op_minus
l_int|1
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rtab
op_logical_or
op_logical_neg
id|ctab
)paren
r_goto
id|failure
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cl
)paren
(brace
multiline_comment|/* new class */
r_struct
id|Qdisc
op_star
id|new_q
suffix:semicolon
multiline_comment|/* check for valid classid */
r_if
c_cond
(paren
op_logical_neg
id|classid
op_logical_or
id|TC_H_MAJ
c_func
(paren
id|classid
op_xor
id|sch-&gt;handle
)paren
op_logical_or
id|htb_find
c_func
(paren
id|classid
comma
id|sch
)paren
)paren
r_goto
id|failure
suffix:semicolon
multiline_comment|/* check maximal depth */
r_if
c_cond
(paren
id|parent
op_logical_and
id|parent-&gt;parent
op_logical_and
id|parent-&gt;parent-&gt;level
OL
l_int|2
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;htb: tree is too deep&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|failure
suffix:semicolon
)brace
id|err
op_assign
op_minus
id|ENOBUFS
suffix:semicolon
r_if
c_cond
(paren
(paren
id|cl
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|cl
)paren
comma
id|GFP_KERNEL
)paren
)paren
op_eq
l_int|NULL
)paren
r_goto
id|failure
suffix:semicolon
id|memset
c_func
(paren
id|cl
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|cl
)paren
)paren
suffix:semicolon
id|cl-&gt;refcnt
op_assign
l_int|1
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|cl-&gt;sibling
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|cl-&gt;hlist
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|cl-&gt;children
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|cl-&gt;un.leaf.drop_list
)paren
suffix:semicolon
macro_line|#ifdef HTB_DEBUG
id|cl-&gt;magic
op_assign
id|HTB_CMAGIC
suffix:semicolon
macro_line|#endif
multiline_comment|/* create leaf qdisc early because it uses kmalloc(GPF_KERNEL)&n;&t;&t;   so that can&squot;t be used inside of sch_tree_lock&n;&t;&t;   -- thanks to Karlis Peisenieks */
id|new_q
op_assign
id|qdisc_create_dflt
c_func
(paren
id|sch-&gt;dev
comma
op_amp
id|pfifo_qdisc_ops
)paren
suffix:semicolon
id|sch_tree_lock
c_func
(paren
id|sch
)paren
suffix:semicolon
r_if
c_cond
(paren
id|parent
op_logical_and
op_logical_neg
id|parent-&gt;level
)paren
(brace
multiline_comment|/* turn parent into inner node */
id|sch-&gt;q.qlen
op_sub_assign
id|parent-&gt;un.leaf.q-&gt;q.qlen
suffix:semicolon
id|qdisc_destroy
(paren
id|parent-&gt;un.leaf.q
)paren
suffix:semicolon
r_if
c_cond
(paren
id|parent-&gt;prio_activity
)paren
id|htb_deactivate
(paren
id|q
comma
id|parent
)paren
suffix:semicolon
multiline_comment|/* remove from evt list because of level change */
r_if
c_cond
(paren
id|parent-&gt;cmode
op_ne
id|HTB_CAN_SEND
)paren
(brace
id|htb_safe_rb_erase
c_func
(paren
op_amp
id|parent-&gt;pq_node
comma
id|q-&gt;wait_pq
multiline_comment|/*+0*/
)paren
suffix:semicolon
id|parent-&gt;cmode
op_assign
id|HTB_CAN_SEND
suffix:semicolon
)brace
id|parent-&gt;level
op_assign
(paren
id|parent-&gt;parent
ques
c_cond
id|parent-&gt;parent-&gt;level
suffix:colon
id|TC_HTB_MAXDEPTH
)paren
op_minus
l_int|1
suffix:semicolon
id|memset
(paren
op_amp
id|parent-&gt;un.inner
comma
l_int|0
comma
r_sizeof
(paren
id|parent-&gt;un.inner
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* leaf (we) needs elementary qdisc */
id|cl-&gt;un.leaf.q
op_assign
id|new_q
ques
c_cond
id|new_q
suffix:colon
op_amp
id|noop_qdisc
suffix:semicolon
id|cl-&gt;classid
op_assign
id|classid
suffix:semicolon
id|cl-&gt;parent
op_assign
id|parent
suffix:semicolon
multiline_comment|/* set class to be in HTB_CAN_SEND state */
id|cl-&gt;tokens
op_assign
id|hopt-&gt;buffer
suffix:semicolon
id|cl-&gt;ctokens
op_assign
id|hopt-&gt;cbuffer
suffix:semicolon
id|cl-&gt;mbuffer
op_assign
l_int|60000000
suffix:semicolon
multiline_comment|/* 1min */
id|PSCHED_GET_TIME
c_func
(paren
id|cl-&gt;t_c
)paren
suffix:semicolon
id|cl-&gt;cmode
op_assign
id|HTB_CAN_SEND
suffix:semicolon
multiline_comment|/* attach to the hash list and parent&squot;s family */
id|list_add_tail
c_func
(paren
op_amp
id|cl-&gt;hlist
comma
id|q-&gt;hash
op_plus
id|htb_hash
c_func
(paren
id|classid
)paren
)paren
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|cl-&gt;sibling
comma
id|parent
ques
c_cond
op_amp
id|parent-&gt;children
suffix:colon
op_amp
id|q-&gt;root
)paren
suffix:semicolon
macro_line|#ifdef HTB_DEBUG
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|TC_HTB_NUMPRIO
suffix:semicolon
id|i
op_increment
)paren
id|cl-&gt;node
(braket
id|i
)braket
dot
id|rb_color
op_assign
op_minus
l_int|1
suffix:semicolon
id|cl-&gt;pq_node.rb_color
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
macro_line|#endif
)brace
r_else
id|sch_tree_lock
c_func
(paren
id|sch
)paren
suffix:semicolon
multiline_comment|/* it used to be a nasty bug here, we have to check that node&n;           is really leaf before changing cl-&gt;un.leaf ! */
r_if
c_cond
(paren
op_logical_neg
id|cl-&gt;level
)paren
(brace
id|cl-&gt;un.leaf.quantum
op_assign
id|rtab-&gt;rate.rate
op_div
id|q-&gt;rate2quantum
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hopt-&gt;quantum
op_logical_and
id|cl-&gt;un.leaf.quantum
OL
l_int|1000
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;HTB: quantum of class %X is small. Consider r2q change.&bslash;n&quot;
comma
id|cl-&gt;classid
)paren
suffix:semicolon
id|cl-&gt;un.leaf.quantum
op_assign
l_int|1000
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|hopt-&gt;quantum
op_logical_and
id|cl-&gt;un.leaf.quantum
OG
l_int|200000
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;HTB: quantum of class %X is big. Consider r2q change.&bslash;n&quot;
comma
id|cl-&gt;classid
)paren
suffix:semicolon
id|cl-&gt;un.leaf.quantum
op_assign
l_int|200000
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hopt-&gt;quantum
)paren
id|cl-&gt;un.leaf.quantum
op_assign
id|hopt-&gt;quantum
suffix:semicolon
r_if
c_cond
(paren
(paren
id|cl-&gt;un.leaf.prio
op_assign
id|hopt-&gt;prio
)paren
op_ge
id|TC_HTB_NUMPRIO
)paren
id|cl-&gt;un.leaf.prio
op_assign
id|TC_HTB_NUMPRIO
op_minus
l_int|1
suffix:semicolon
)brace
id|cl-&gt;buffer
op_assign
id|hopt-&gt;buffer
suffix:semicolon
id|cl-&gt;cbuffer
op_assign
id|hopt-&gt;cbuffer
suffix:semicolon
r_if
c_cond
(paren
id|cl-&gt;rate
)paren
id|qdisc_put_rtab
c_func
(paren
id|cl-&gt;rate
)paren
suffix:semicolon
id|cl-&gt;rate
op_assign
id|rtab
suffix:semicolon
r_if
c_cond
(paren
id|cl-&gt;ceil
)paren
id|qdisc_put_rtab
c_func
(paren
id|cl-&gt;ceil
)paren
suffix:semicolon
id|cl-&gt;ceil
op_assign
id|ctab
suffix:semicolon
id|sch_tree_unlock
c_func
(paren
id|sch
)paren
suffix:semicolon
op_star
id|arg
op_assign
(paren
r_int
r_int
)paren
id|cl
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|failure
suffix:colon
r_if
c_cond
(paren
id|rtab
)paren
id|qdisc_put_rtab
c_func
(paren
id|rtab
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ctab
)paren
id|qdisc_put_rtab
c_func
(paren
id|ctab
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|function|htb_find_tcf
r_static
r_struct
id|tcf_proto
op_star
op_star
id|htb_find_tcf
c_func
(paren
r_struct
id|Qdisc
op_star
id|sch
comma
r_int
r_int
id|arg
)paren
(brace
r_struct
id|htb_sched
op_star
id|q
op_assign
(paren
r_struct
id|htb_sched
op_star
)paren
id|sch-&gt;data
suffix:semicolon
r_struct
id|htb_class
op_star
id|cl
op_assign
(paren
r_struct
id|htb_class
op_star
)paren
id|arg
suffix:semicolon
r_struct
id|tcf_proto
op_star
op_star
id|fl
op_assign
id|cl
ques
c_cond
op_amp
id|cl-&gt;filter_list
suffix:colon
op_amp
id|q-&gt;filter_list
suffix:semicolon
id|HTB_DBG
c_func
(paren
l_int|0
comma
l_int|2
comma
l_string|&quot;htb_tcf q=%p clid=%X fref=%d fl=%p&bslash;n&quot;
comma
id|q
comma
id|cl
ques
c_cond
id|cl-&gt;classid
suffix:colon
l_int|0
comma
id|cl
ques
c_cond
id|cl-&gt;filter_cnt
suffix:colon
id|q-&gt;filter_cnt
comma
op_star
id|fl
)paren
suffix:semicolon
r_return
id|fl
suffix:semicolon
)brace
DECL|function|htb_bind_filter
r_static
r_int
r_int
id|htb_bind_filter
c_func
(paren
r_struct
id|Qdisc
op_star
id|sch
comma
r_int
r_int
id|parent
comma
id|u32
id|classid
)paren
(brace
r_struct
id|htb_sched
op_star
id|q
op_assign
(paren
r_struct
id|htb_sched
op_star
)paren
id|sch-&gt;data
suffix:semicolon
r_struct
id|htb_class
op_star
id|cl
op_assign
id|htb_find
(paren
id|classid
comma
id|sch
)paren
suffix:semicolon
id|HTB_DBG
c_func
(paren
l_int|0
comma
l_int|2
comma
l_string|&quot;htb_bind q=%p clid=%X cl=%p fref=%d&bslash;n&quot;
comma
id|q
comma
id|classid
comma
id|cl
comma
id|cl
ques
c_cond
id|cl-&gt;filter_cnt
suffix:colon
id|q-&gt;filter_cnt
)paren
suffix:semicolon
multiline_comment|/*if (cl &amp;&amp; !cl-&gt;level) return 0;&n;&t;  The line above used to be there to prevent attaching filters to &n;&t;  leaves. But at least tc_index filter uses this just to get class &n;&t;  for other reasons so that we have to allow for it.&n;&t;  ----&n;&t;  19.6.2002 As Werner explained it is ok - bind filter is just&n;&t;  another way to &quot;lock&quot; the class - unlike &quot;get&quot; this lock can&n;&t;  be broken by class during destroy IIUC.&n;&t; */
r_if
c_cond
(paren
id|cl
)paren
id|cl-&gt;filter_cnt
op_increment
suffix:semicolon
r_else
id|q-&gt;filter_cnt
op_increment
suffix:semicolon
r_return
(paren
r_int
r_int
)paren
id|cl
suffix:semicolon
)brace
DECL|function|htb_unbind_filter
r_static
r_void
id|htb_unbind_filter
c_func
(paren
r_struct
id|Qdisc
op_star
id|sch
comma
r_int
r_int
id|arg
)paren
(brace
r_struct
id|htb_sched
op_star
id|q
op_assign
(paren
r_struct
id|htb_sched
op_star
)paren
id|sch-&gt;data
suffix:semicolon
r_struct
id|htb_class
op_star
id|cl
op_assign
(paren
r_struct
id|htb_class
op_star
)paren
id|arg
suffix:semicolon
id|HTB_DBG
c_func
(paren
l_int|0
comma
l_int|2
comma
l_string|&quot;htb_unbind q=%p cl=%p fref=%d&bslash;n&quot;
comma
id|q
comma
id|cl
comma
id|cl
ques
c_cond
id|cl-&gt;filter_cnt
suffix:colon
id|q-&gt;filter_cnt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cl
)paren
id|cl-&gt;filter_cnt
op_decrement
suffix:semicolon
r_else
id|q-&gt;filter_cnt
op_decrement
suffix:semicolon
)brace
DECL|function|htb_walk
r_static
r_void
id|htb_walk
c_func
(paren
r_struct
id|Qdisc
op_star
id|sch
comma
r_struct
id|qdisc_walker
op_star
id|arg
)paren
(brace
r_struct
id|htb_sched
op_star
id|q
op_assign
(paren
r_struct
id|htb_sched
op_star
)paren
id|sch-&gt;data
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|arg-&gt;stop
)paren
r_return
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|HTB_HSIZE
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|list_head
op_star
id|p
suffix:semicolon
id|list_for_each
(paren
id|p
comma
id|q-&gt;hash
op_plus
id|i
)paren
(brace
r_struct
id|htb_class
op_star
id|cl
op_assign
id|list_entry
c_func
(paren
id|p
comma
r_struct
id|htb_class
comma
id|hlist
)paren
suffix:semicolon
r_if
c_cond
(paren
id|arg-&gt;count
OL
id|arg-&gt;skip
)paren
(brace
id|arg-&gt;count
op_increment
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|arg
op_member_access_from_pointer
id|fn
c_func
(paren
id|sch
comma
(paren
r_int
r_int
)paren
id|cl
comma
id|arg
)paren
OL
l_int|0
)paren
(brace
id|arg-&gt;stop
op_assign
l_int|1
suffix:semicolon
r_return
suffix:semicolon
)brace
id|arg-&gt;count
op_increment
suffix:semicolon
)brace
)brace
)brace
DECL|variable|htb_class_ops
r_static
r_struct
id|Qdisc_class_ops
id|htb_class_ops
op_assign
(brace
dot
id|graft
op_assign
id|htb_graft
comma
dot
id|leaf
op_assign
id|htb_leaf
comma
dot
id|get
op_assign
id|htb_get
comma
dot
id|put
op_assign
id|htb_put
comma
dot
id|change
op_assign
id|htb_change_class
comma
dot
r_delete
op_assign
id|htb_delete
comma
dot
id|walk
op_assign
id|htb_walk
comma
dot
id|tcf_chain
op_assign
id|htb_find_tcf
comma
dot
id|bind_tcf
op_assign
id|htb_bind_filter
comma
dot
id|unbind_tcf
op_assign
id|htb_unbind_filter
comma
dot
id|dump
op_assign
id|htb_dump_class
comma
)brace
suffix:semicolon
DECL|variable|htb_qdisc_ops
r_static
r_struct
id|Qdisc_ops
id|htb_qdisc_ops
op_assign
(brace
dot
id|next
op_assign
l_int|NULL
comma
dot
id|cl_ops
op_assign
op_amp
id|htb_class_ops
comma
dot
id|id
op_assign
l_string|&quot;htb&quot;
comma
dot
id|priv_size
op_assign
r_sizeof
(paren
r_struct
id|htb_sched
)paren
comma
dot
id|enqueue
op_assign
id|htb_enqueue
comma
dot
id|dequeue
op_assign
id|htb_dequeue
comma
dot
id|requeue
op_assign
id|htb_requeue
comma
dot
id|drop
op_assign
id|htb_drop
comma
dot
id|init
op_assign
id|htb_init
comma
dot
id|reset
op_assign
id|htb_reset
comma
dot
id|destroy
op_assign
id|htb_destroy
comma
dot
id|change
op_assign
l_int|NULL
multiline_comment|/* htb_change */
comma
dot
id|dump
op_assign
id|htb_dump
comma
dot
id|owner
op_assign
id|THIS_MODULE
comma
)brace
suffix:semicolon
DECL|function|htb_module_init
r_static
r_int
id|__init
id|htb_module_init
c_func
(paren
r_void
)paren
(brace
r_return
id|register_qdisc
c_func
(paren
op_amp
id|htb_qdisc_ops
)paren
suffix:semicolon
)brace
DECL|function|htb_module_exit
r_static
r_void
id|__exit
id|htb_module_exit
c_func
(paren
r_void
)paren
(brace
id|unregister_qdisc
c_func
(paren
op_amp
id|htb_qdisc_ops
)paren
suffix:semicolon
)brace
id|module_init
c_func
(paren
id|htb_module_init
)paren
id|module_exit
c_func
(paren
id|htb_module_exit
)paren
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
eof
