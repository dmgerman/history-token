multiline_comment|/*&n; * net/sched/cls_tcindex.c&t;Packet classifier for skb-&gt;tc_index&n; *&n; * Written 1998,1999 by Werner Almesberger, EPFL ICA&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;net/ip.h&gt;
macro_line|#include &lt;net/act_api.h&gt;
macro_line|#include &lt;net/pkt_cls.h&gt;
macro_line|#include &lt;net/route.h&gt;
multiline_comment|/*&n; * Not quite sure if we need all the xchgs Alexey uses when accessing things.&n; * Can always add them later ... :)&n; */
multiline_comment|/*&n; * Passing parameters to the root seems to be done more awkwardly than really&n; * necessary. At least, u32 doesn&squot;t seem to use such dirty hacks. To be&n; * verified. FIXME.&n; */
DECL|macro|PERFECT_HASH_THRESHOLD
mdefine_line|#define PERFECT_HASH_THRESHOLD&t;64&t;/* use perfect hash if not bigger */
DECL|macro|DEFAULT_HASH_SIZE
mdefine_line|#define DEFAULT_HASH_SIZE&t;64&t;/* optimized for diffserv */
macro_line|#if 1 /* control */
DECL|macro|DPRINTK
mdefine_line|#define DPRINTK(format,args...) printk(KERN_DEBUG format,##args)
macro_line|#else
DECL|macro|DPRINTK
mdefine_line|#define DPRINTK(format,args...)
macro_line|#endif
macro_line|#if 0 /* data */
mdefine_line|#define D2PRINTK(format,args...) printk(KERN_DEBUG format,##args)
macro_line|#else
DECL|macro|D2PRINTK
mdefine_line|#define D2PRINTK(format,args...)
macro_line|#endif
DECL|macro|PRIV
mdefine_line|#define&t;PRIV(tp)&t;((struct tcindex_data *) (tp)-&gt;root)
DECL|struct|tcindex_filter_result
r_struct
id|tcindex_filter_result
(brace
DECL|member|exts
r_struct
id|tcf_exts
id|exts
suffix:semicolon
DECL|member|res
r_struct
id|tcf_result
id|res
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|tcindex_filter
r_struct
id|tcindex_filter
(brace
DECL|member|key
id|u16
id|key
suffix:semicolon
DECL|member|result
r_struct
id|tcindex_filter_result
id|result
suffix:semicolon
DECL|member|next
r_struct
id|tcindex_filter
op_star
id|next
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|tcindex_data
r_struct
id|tcindex_data
(brace
DECL|member|perfect
r_struct
id|tcindex_filter_result
op_star
id|perfect
suffix:semicolon
multiline_comment|/* perfect hash; NULL if none */
DECL|member|h
r_struct
id|tcindex_filter
op_star
op_star
id|h
suffix:semicolon
multiline_comment|/* imperfect hash; only used if !perfect;&n;&t;&t;&t;&t;      NULL if unused */
DECL|member|mask
id|u16
id|mask
suffix:semicolon
multiline_comment|/* AND key with mask */
DECL|member|shift
r_int
id|shift
suffix:semicolon
multiline_comment|/* shift ANDed key to the right */
DECL|member|hash
r_int
id|hash
suffix:semicolon
multiline_comment|/* hash table size; 0 if undefined */
DECL|member|alloc_hash
r_int
id|alloc_hash
suffix:semicolon
multiline_comment|/* allocated size */
DECL|member|fall_through
r_int
id|fall_through
suffix:semicolon
multiline_comment|/* 0: only classify if explicit match */
)brace
suffix:semicolon
DECL|variable|tcindex_ext_map
r_static
r_struct
id|tcf_ext_map
id|tcindex_ext_map
op_assign
(brace
dot
id|police
op_assign
id|TCA_TCINDEX_POLICE
comma
dot
id|action
op_assign
id|TCA_TCINDEX_ACT
)brace
suffix:semicolon
r_static
r_inline
r_int
DECL|function|tcindex_filter_is_set
id|tcindex_filter_is_set
c_func
(paren
r_struct
id|tcindex_filter_result
op_star
id|r
)paren
(brace
r_return
id|tcf_exts_is_predicative
c_func
(paren
op_amp
id|r-&gt;exts
)paren
op_logical_or
id|r-&gt;res.classid
suffix:semicolon
)brace
r_static
r_struct
id|tcindex_filter_result
op_star
DECL|function|tcindex_lookup
id|tcindex_lookup
c_func
(paren
r_struct
id|tcindex_data
op_star
id|p
comma
id|u16
id|key
)paren
(brace
r_struct
id|tcindex_filter
op_star
id|f
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;perfect
)paren
r_return
id|tcindex_filter_is_set
c_func
(paren
id|p-&gt;perfect
op_plus
id|key
)paren
ques
c_cond
id|p-&gt;perfect
op_plus
id|key
suffix:colon
l_int|NULL
suffix:semicolon
r_else
r_if
c_cond
(paren
id|p-&gt;h
)paren
(brace
r_for
c_loop
(paren
id|f
op_assign
id|p-&gt;h
(braket
id|key
op_mod
id|p-&gt;hash
)braket
suffix:semicolon
id|f
suffix:semicolon
id|f
op_assign
id|f-&gt;next
)paren
r_if
c_cond
(paren
id|f-&gt;key
op_eq
id|key
)paren
r_return
op_amp
id|f-&gt;result
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|tcindex_classify
r_static
r_int
id|tcindex_classify
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|tcf_proto
op_star
id|tp
comma
r_struct
id|tcf_result
op_star
id|res
)paren
(brace
r_struct
id|tcindex_data
op_star
id|p
op_assign
id|PRIV
c_func
(paren
id|tp
)paren
suffix:semicolon
r_struct
id|tcindex_filter_result
op_star
id|f
suffix:semicolon
r_int
id|key
op_assign
(paren
id|skb-&gt;tc_index
op_amp
id|p-&gt;mask
)paren
op_rshift
id|p-&gt;shift
suffix:semicolon
id|D2PRINTK
c_func
(paren
l_string|&quot;tcindex_classify(skb %p,tp %p,res %p),p %p&bslash;n&quot;
comma
id|skb
comma
id|tp
comma
id|res
comma
id|p
)paren
suffix:semicolon
id|f
op_assign
id|tcindex_lookup
c_func
(paren
id|p
comma
id|key
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|f
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|p-&gt;fall_through
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|res-&gt;classid
op_assign
id|TC_H_MAKE
c_func
(paren
id|TC_H_MAJ
c_func
(paren
id|tp-&gt;q-&gt;handle
)paren
comma
id|key
)paren
suffix:semicolon
id|res
op_member_access_from_pointer
r_class
op_assign
l_int|0
suffix:semicolon
id|D2PRINTK
c_func
(paren
l_string|&quot;alg 0x%x&bslash;n&quot;
comma
id|res-&gt;classid
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
op_star
id|res
op_assign
id|f-&gt;res
suffix:semicolon
id|D2PRINTK
c_func
(paren
l_string|&quot;map 0x%x&bslash;n&quot;
comma
id|res-&gt;classid
)paren
suffix:semicolon
r_return
id|tcf_exts_exec
c_func
(paren
id|skb
comma
op_amp
id|f-&gt;exts
comma
id|res
)paren
suffix:semicolon
)brace
DECL|function|tcindex_get
r_static
r_int
r_int
id|tcindex_get
c_func
(paren
r_struct
id|tcf_proto
op_star
id|tp
comma
id|u32
id|handle
)paren
(brace
r_struct
id|tcindex_data
op_star
id|p
op_assign
id|PRIV
c_func
(paren
id|tp
)paren
suffix:semicolon
r_struct
id|tcindex_filter_result
op_star
id|r
suffix:semicolon
id|DPRINTK
c_func
(paren
l_string|&quot;tcindex_get(tp %p,handle 0x%08x)&bslash;n&quot;
comma
id|tp
comma
id|handle
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;perfect
op_logical_and
id|handle
op_ge
id|p-&gt;alloc_hash
)paren
r_return
l_int|0
suffix:semicolon
id|r
op_assign
id|tcindex_lookup
c_func
(paren
id|p
comma
id|handle
)paren
suffix:semicolon
r_return
id|r
op_logical_and
id|tcindex_filter_is_set
c_func
(paren
id|r
)paren
ques
c_cond
(paren
r_int
r_int
)paren
id|r
suffix:colon
l_int|0UL
suffix:semicolon
)brace
DECL|function|tcindex_put
r_static
r_void
id|tcindex_put
c_func
(paren
r_struct
id|tcf_proto
op_star
id|tp
comma
r_int
r_int
id|f
)paren
(brace
id|DPRINTK
c_func
(paren
l_string|&quot;tcindex_put(tp %p,f 0x%lx)&bslash;n&quot;
comma
id|tp
comma
id|f
)paren
suffix:semicolon
)brace
DECL|function|tcindex_init
r_static
r_int
id|tcindex_init
c_func
(paren
r_struct
id|tcf_proto
op_star
id|tp
)paren
(brace
r_struct
id|tcindex_data
op_star
id|p
suffix:semicolon
id|DPRINTK
c_func
(paren
l_string|&quot;tcindex_init(tp %p)&bslash;n&quot;
comma
id|tp
)paren
suffix:semicolon
id|p
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|tcindex_data
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|memset
c_func
(paren
id|p
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|p
)paren
)paren
suffix:semicolon
id|p-&gt;mask
op_assign
l_int|0xffff
suffix:semicolon
id|p-&gt;hash
op_assign
id|DEFAULT_HASH_SIZE
suffix:semicolon
id|p-&gt;fall_through
op_assign
l_int|1
suffix:semicolon
id|tp-&gt;root
op_assign
id|p
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|__tcindex_delete
id|__tcindex_delete
c_func
(paren
r_struct
id|tcf_proto
op_star
id|tp
comma
r_int
r_int
id|arg
comma
r_int
id|lock
)paren
(brace
r_struct
id|tcindex_data
op_star
id|p
op_assign
id|PRIV
c_func
(paren
id|tp
)paren
suffix:semicolon
r_struct
id|tcindex_filter_result
op_star
id|r
op_assign
(paren
r_struct
id|tcindex_filter_result
op_star
)paren
id|arg
suffix:semicolon
r_struct
id|tcindex_filter
op_star
id|f
op_assign
l_int|NULL
suffix:semicolon
id|DPRINTK
c_func
(paren
l_string|&quot;tcindex_delete(tp %p,arg 0x%lx),p %p,f %p&bslash;n&quot;
comma
id|tp
comma
id|arg
comma
id|p
comma
id|f
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;perfect
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|r-&gt;res
dot
r_class
)paren
r_return
op_minus
id|ENOENT
suffix:semicolon
)brace
r_else
(brace
r_int
id|i
suffix:semicolon
r_struct
id|tcindex_filter
op_star
op_star
id|walk
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|p-&gt;hash
suffix:semicolon
id|i
op_increment
)paren
r_for
c_loop
(paren
id|walk
op_assign
id|p-&gt;h
op_plus
id|i
suffix:semicolon
op_star
id|walk
suffix:semicolon
id|walk
op_assign
op_amp
(paren
op_star
id|walk
)paren
op_member_access_from_pointer
id|next
)paren
r_if
c_cond
(paren
op_amp
(paren
op_star
id|walk
)paren
op_member_access_from_pointer
id|result
op_eq
id|r
)paren
r_goto
id|found
suffix:semicolon
r_return
op_minus
id|ENOENT
suffix:semicolon
id|found
suffix:colon
id|f
op_assign
op_star
id|walk
suffix:semicolon
r_if
c_cond
(paren
id|lock
)paren
id|tcf_tree_lock
c_func
(paren
id|tp
)paren
suffix:semicolon
op_star
id|walk
op_assign
id|f-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|lock
)paren
id|tcf_tree_unlock
c_func
(paren
id|tp
)paren
suffix:semicolon
)brace
id|tcf_unbind_filter
c_func
(paren
id|tp
comma
op_amp
id|r-&gt;res
)paren
suffix:semicolon
id|tcf_exts_destroy
c_func
(paren
id|tp
comma
op_amp
id|r-&gt;exts
)paren
suffix:semicolon
r_if
c_cond
(paren
id|f
)paren
id|kfree
c_func
(paren
id|f
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|tcindex_delete
r_static
r_int
id|tcindex_delete
c_func
(paren
r_struct
id|tcf_proto
op_star
id|tp
comma
r_int
r_int
id|arg
)paren
(brace
r_return
id|__tcindex_delete
c_func
(paren
id|tp
comma
id|arg
comma
l_int|1
)paren
suffix:semicolon
)brace
r_static
r_inline
r_int
DECL|function|valid_perfect_hash
id|valid_perfect_hash
c_func
(paren
r_struct
id|tcindex_data
op_star
id|p
)paren
(brace
r_return
id|p-&gt;hash
OG
(paren
id|p-&gt;mask
op_rshift
id|p-&gt;shift
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|tcindex_set_parms
id|tcindex_set_parms
c_func
(paren
r_struct
id|tcf_proto
op_star
id|tp
comma
r_int
r_int
id|base
comma
id|u32
id|handle
comma
r_struct
id|tcindex_data
op_star
id|p
comma
r_struct
id|tcindex_filter_result
op_star
id|r
comma
r_struct
id|rtattr
op_star
op_star
id|tb
comma
r_struct
id|rtattr
op_star
id|est
)paren
(brace
r_int
id|err
comma
id|balloc
op_assign
l_int|0
suffix:semicolon
r_struct
id|tcindex_filter_result
id|new_filter_result
comma
op_star
id|old_r
op_assign
id|r
suffix:semicolon
r_struct
id|tcindex_filter_result
id|cr
suffix:semicolon
r_struct
id|tcindex_data
id|cp
suffix:semicolon
r_struct
id|tcindex_filter
op_star
id|f
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* make gcc behave */
r_struct
id|tcf_exts
id|e
suffix:semicolon
id|err
op_assign
id|tcf_exts_validate
c_func
(paren
id|tp
comma
id|tb
comma
id|est
comma
op_amp
id|e
comma
op_amp
id|tcindex_ext_map
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_return
id|err
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|cp
comma
id|p
comma
r_sizeof
(paren
id|cp
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|new_filter_result
comma
l_int|0
comma
r_sizeof
(paren
id|new_filter_result
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|old_r
)paren
id|memcpy
c_func
(paren
op_amp
id|cr
comma
id|r
comma
r_sizeof
(paren
id|cr
)paren
)paren
suffix:semicolon
r_else
id|memset
c_func
(paren
op_amp
id|cr
comma
l_int|0
comma
r_sizeof
(paren
id|cr
)paren
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|tb
(braket
id|TCA_TCINDEX_HASH
op_minus
l_int|1
)braket
)paren
(brace
r_if
c_cond
(paren
id|RTA_PAYLOAD
c_func
(paren
id|tb
(braket
id|TCA_TCINDEX_HASH
op_minus
l_int|1
)braket
)paren
OL
r_sizeof
(paren
id|u32
)paren
)paren
r_goto
id|errout
suffix:semicolon
id|cp.hash
op_assign
op_star
(paren
id|u32
op_star
)paren
id|RTA_DATA
c_func
(paren
id|tb
(braket
id|TCA_TCINDEX_HASH
op_minus
l_int|1
)braket
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tb
(braket
id|TCA_TCINDEX_MASK
op_minus
l_int|1
)braket
)paren
(brace
r_if
c_cond
(paren
id|RTA_PAYLOAD
c_func
(paren
id|tb
(braket
id|TCA_TCINDEX_MASK
op_minus
l_int|1
)braket
)paren
OL
r_sizeof
(paren
id|u16
)paren
)paren
r_goto
id|errout
suffix:semicolon
id|cp.mask
op_assign
op_star
(paren
id|u16
op_star
)paren
id|RTA_DATA
c_func
(paren
id|tb
(braket
id|TCA_TCINDEX_MASK
op_minus
l_int|1
)braket
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tb
(braket
id|TCA_TCINDEX_SHIFT
op_minus
l_int|1
)braket
)paren
(brace
r_if
c_cond
(paren
id|RTA_PAYLOAD
c_func
(paren
id|tb
(braket
id|TCA_TCINDEX_SHIFT
op_minus
l_int|1
)braket
)paren
OL
r_sizeof
(paren
id|u16
)paren
)paren
r_goto
id|errout
suffix:semicolon
id|cp.shift
op_assign
op_star
(paren
id|u16
op_star
)paren
id|RTA_DATA
c_func
(paren
id|tb
(braket
id|TCA_TCINDEX_SHIFT
op_minus
l_int|1
)braket
)paren
suffix:semicolon
)brace
id|err
op_assign
op_minus
id|EBUSY
suffix:semicolon
multiline_comment|/* Hash already allocated, make sure that we still meet the&n;&t; * requirements for the allocated hash.&n;&t; */
r_if
c_cond
(paren
id|cp.perfect
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|valid_perfect_hash
c_func
(paren
op_amp
id|cp
)paren
op_logical_or
id|cp.hash
OG
id|cp.alloc_hash
)paren
r_goto
id|errout
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|cp.h
op_logical_and
id|cp.hash
op_ne
id|cp.alloc_hash
)paren
r_goto
id|errout
suffix:semicolon
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|tb
(braket
id|TCA_TCINDEX_FALL_THROUGH
op_minus
l_int|1
)braket
)paren
(brace
r_if
c_cond
(paren
id|RTA_PAYLOAD
c_func
(paren
id|tb
(braket
id|TCA_TCINDEX_FALL_THROUGH
op_minus
l_int|1
)braket
)paren
OL
r_sizeof
(paren
id|u32
)paren
)paren
r_goto
id|errout
suffix:semicolon
id|cp.fall_through
op_assign
op_star
(paren
id|u32
op_star
)paren
id|RTA_DATA
c_func
(paren
id|tb
(braket
id|TCA_TCINDEX_FALL_THROUGH
op_minus
l_int|1
)braket
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|cp.hash
)paren
(brace
multiline_comment|/* Hash not specified, use perfect hash if the upper limit&n;&t;&t; * of the hashing index is below the threshold.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|cp.mask
op_rshift
id|cp.shift
)paren
OL
id|PERFECT_HASH_THRESHOLD
)paren
id|cp.hash
op_assign
(paren
id|cp.mask
op_rshift
id|cp.shift
)paren
op_plus
l_int|1
suffix:semicolon
r_else
id|cp.hash
op_assign
id|DEFAULT_HASH_SIZE
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|cp.perfect
op_logical_and
op_logical_neg
id|cp.h
)paren
id|cp.alloc_hash
op_assign
id|cp.hash
suffix:semicolon
multiline_comment|/* Note: this could be as restrictive as if (handle &amp; ~(mask &gt;&gt; shift))&n;&t; * but then, we&squot;d fail handles that may become valid after some future&n;&t; * mask change. While this is extremely unlikely to ever matter,&n;&t; * the check below is safer (and also more backwards-compatible).&n;&t; */
r_if
c_cond
(paren
id|cp.perfect
op_logical_or
id|valid_perfect_hash
c_func
(paren
op_amp
id|cp
)paren
)paren
r_if
c_cond
(paren
id|handle
op_ge
id|cp.alloc_hash
)paren
r_goto
id|errout
suffix:semicolon
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cp.perfect
op_logical_and
op_logical_neg
id|cp.h
)paren
(brace
r_if
c_cond
(paren
id|valid_perfect_hash
c_func
(paren
op_amp
id|cp
)paren
)paren
(brace
id|cp.perfect
op_assign
id|kmalloc
c_func
(paren
id|cp.hash
op_star
r_sizeof
(paren
op_star
id|r
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cp.perfect
)paren
r_goto
id|errout
suffix:semicolon
id|memset
c_func
(paren
id|cp.perfect
comma
l_int|0
comma
id|cp.hash
op_star
r_sizeof
(paren
op_star
id|r
)paren
)paren
suffix:semicolon
id|balloc
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|cp.h
op_assign
id|kmalloc
c_func
(paren
id|cp.hash
op_star
r_sizeof
(paren
id|f
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cp.h
)paren
r_goto
id|errout
suffix:semicolon
id|memset
c_func
(paren
id|cp.h
comma
l_int|0
comma
id|cp.hash
op_star
r_sizeof
(paren
id|f
)paren
)paren
suffix:semicolon
id|balloc
op_assign
l_int|2
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|cp.perfect
)paren
id|r
op_assign
id|cp.perfect
op_plus
id|handle
suffix:semicolon
r_else
id|r
op_assign
id|tcindex_lookup
c_func
(paren
op_amp
id|cp
comma
id|handle
)paren
ques
c_cond
suffix:colon
op_amp
id|new_filter_result
suffix:semicolon
r_if
c_cond
(paren
id|r
op_eq
op_amp
id|new_filter_result
)paren
(brace
id|f
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|f
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|f
)paren
r_goto
id|errout_alloc
suffix:semicolon
id|memset
c_func
(paren
id|f
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|f
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tb
(braket
id|TCA_TCINDEX_CLASSID
op_minus
l_int|1
)braket
)paren
(brace
id|cr.res.classid
op_assign
op_star
(paren
id|u32
op_star
)paren
id|RTA_DATA
c_func
(paren
id|tb
(braket
id|TCA_TCINDEX_CLASSID
op_minus
l_int|1
)braket
)paren
suffix:semicolon
id|tcf_bind_filter
c_func
(paren
id|tp
comma
op_amp
id|cr.res
comma
id|base
)paren
suffix:semicolon
)brace
id|tcf_exts_change
c_func
(paren
id|tp
comma
op_amp
id|cr.exts
comma
op_amp
id|e
)paren
suffix:semicolon
id|tcf_tree_lock
c_func
(paren
id|tp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|old_r
op_logical_and
id|old_r
op_ne
id|r
)paren
id|memset
c_func
(paren
id|old_r
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|old_r
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|p
comma
op_amp
id|cp
comma
r_sizeof
(paren
id|cp
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|r
comma
op_amp
id|cr
comma
r_sizeof
(paren
id|cr
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
op_eq
op_amp
id|new_filter_result
)paren
(brace
r_struct
id|tcindex_filter
op_star
op_star
id|fp
suffix:semicolon
id|f-&gt;key
op_assign
id|handle
suffix:semicolon
id|f-&gt;result
op_assign
id|new_filter_result
suffix:semicolon
id|f-&gt;next
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|fp
op_assign
id|p-&gt;h
op_plus
(paren
id|handle
op_mod
id|p-&gt;hash
)paren
suffix:semicolon
op_star
id|fp
suffix:semicolon
id|fp
op_assign
op_amp
(paren
op_star
id|fp
)paren
op_member_access_from_pointer
id|next
)paren
multiline_comment|/* nothing */
suffix:semicolon
op_star
id|fp
op_assign
id|f
suffix:semicolon
)brace
id|tcf_tree_unlock
c_func
(paren
id|tp
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|errout_alloc
suffix:colon
r_if
c_cond
(paren
id|balloc
op_eq
l_int|1
)paren
id|kfree
c_func
(paren
id|cp.perfect
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|balloc
op_eq
l_int|2
)paren
id|kfree
c_func
(paren
id|cp.h
)paren
suffix:semicolon
id|errout
suffix:colon
id|tcf_exts_destroy
c_func
(paren
id|tp
comma
op_amp
id|e
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
r_static
r_int
DECL|function|tcindex_change
id|tcindex_change
c_func
(paren
r_struct
id|tcf_proto
op_star
id|tp
comma
r_int
r_int
id|base
comma
id|u32
id|handle
comma
r_struct
id|rtattr
op_star
op_star
id|tca
comma
r_int
r_int
op_star
id|arg
)paren
(brace
r_struct
id|rtattr
op_star
id|opt
op_assign
id|tca
(braket
id|TCA_OPTIONS
op_minus
l_int|1
)braket
suffix:semicolon
r_struct
id|rtattr
op_star
id|tb
(braket
id|TCA_TCINDEX_MAX
)braket
suffix:semicolon
r_struct
id|tcindex_data
op_star
id|p
op_assign
id|PRIV
c_func
(paren
id|tp
)paren
suffix:semicolon
r_struct
id|tcindex_filter_result
op_star
id|r
op_assign
(paren
r_struct
id|tcindex_filter_result
op_star
)paren
op_star
id|arg
suffix:semicolon
id|DPRINTK
c_func
(paren
l_string|&quot;tcindex_change(tp %p,handle 0x%08x,tca %p,arg %p),opt %p,&quot;
l_string|&quot;p %p,r %p,*arg 0x%lx&bslash;n&quot;
comma
id|tp
comma
id|handle
comma
id|tca
comma
id|arg
comma
id|opt
comma
id|p
comma
id|r
comma
id|arg
ques
c_cond
op_star
id|arg
suffix:colon
l_int|0L
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|opt
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|rtattr_parse_nested
c_func
(paren
id|tb
comma
id|TCA_TCINDEX_MAX
comma
id|opt
)paren
OL
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_return
id|tcindex_set_parms
c_func
(paren
id|tp
comma
id|base
comma
id|handle
comma
id|p
comma
id|r
comma
id|tb
comma
id|tca
(braket
id|TCA_RATE
op_minus
l_int|1
)braket
)paren
suffix:semicolon
)brace
DECL|function|tcindex_walk
r_static
r_void
id|tcindex_walk
c_func
(paren
r_struct
id|tcf_proto
op_star
id|tp
comma
r_struct
id|tcf_walker
op_star
id|walker
)paren
(brace
r_struct
id|tcindex_data
op_star
id|p
op_assign
id|PRIV
c_func
(paren
id|tp
)paren
suffix:semicolon
r_struct
id|tcindex_filter
op_star
id|f
comma
op_star
id|next
suffix:semicolon
r_int
id|i
suffix:semicolon
id|DPRINTK
c_func
(paren
l_string|&quot;tcindex_walk(tp %p,walker %p),p %p&bslash;n&quot;
comma
id|tp
comma
id|walker
comma
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;perfect
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|p-&gt;hash
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|p-&gt;perfect
(braket
id|i
)braket
dot
id|res
dot
r_class
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|walker-&gt;count
op_ge
id|walker-&gt;skip
)paren
(brace
r_if
c_cond
(paren
id|walker
op_member_access_from_pointer
id|fn
c_func
(paren
id|tp
comma
(paren
r_int
r_int
)paren
(paren
id|p-&gt;perfect
op_plus
id|i
)paren
comma
id|walker
)paren
OL
l_int|0
)paren
(brace
id|walker-&gt;stop
op_assign
l_int|1
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
id|walker-&gt;count
op_increment
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|p-&gt;h
)paren
r_return
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|p-&gt;hash
suffix:semicolon
id|i
op_increment
)paren
(brace
r_for
c_loop
(paren
id|f
op_assign
id|p-&gt;h
(braket
id|i
)braket
suffix:semicolon
id|f
suffix:semicolon
id|f
op_assign
id|next
)paren
(brace
id|next
op_assign
id|f-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|walker-&gt;count
op_ge
id|walker-&gt;skip
)paren
(brace
r_if
c_cond
(paren
id|walker
op_member_access_from_pointer
id|fn
c_func
(paren
id|tp
comma
(paren
r_int
r_int
)paren
op_amp
id|f-&gt;result
comma
id|walker
)paren
OL
l_int|0
)paren
(brace
id|walker-&gt;stop
op_assign
l_int|1
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
id|walker-&gt;count
op_increment
suffix:semicolon
)brace
)brace
)brace
DECL|function|tcindex_destroy_element
r_static
r_int
id|tcindex_destroy_element
c_func
(paren
r_struct
id|tcf_proto
op_star
id|tp
comma
r_int
r_int
id|arg
comma
r_struct
id|tcf_walker
op_star
id|walker
)paren
(brace
r_return
id|__tcindex_delete
c_func
(paren
id|tp
comma
id|arg
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|tcindex_destroy
r_static
r_void
id|tcindex_destroy
c_func
(paren
r_struct
id|tcf_proto
op_star
id|tp
)paren
(brace
r_struct
id|tcindex_data
op_star
id|p
op_assign
id|PRIV
c_func
(paren
id|tp
)paren
suffix:semicolon
r_struct
id|tcf_walker
id|walker
suffix:semicolon
id|DPRINTK
c_func
(paren
l_string|&quot;tcindex_destroy(tp %p),p %p&bslash;n&quot;
comma
id|tp
comma
id|p
)paren
suffix:semicolon
id|walker.count
op_assign
l_int|0
suffix:semicolon
id|walker.skip
op_assign
l_int|0
suffix:semicolon
id|walker.fn
op_assign
op_amp
id|tcindex_destroy_element
suffix:semicolon
id|tcindex_walk
c_func
(paren
id|tp
comma
op_amp
id|walker
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;perfect
)paren
id|kfree
c_func
(paren
id|p-&gt;perfect
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;h
)paren
id|kfree
c_func
(paren
id|p-&gt;h
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|p
)paren
suffix:semicolon
id|tp-&gt;root
op_assign
l_int|NULL
suffix:semicolon
)brace
DECL|function|tcindex_dump
r_static
r_int
id|tcindex_dump
c_func
(paren
r_struct
id|tcf_proto
op_star
id|tp
comma
r_int
r_int
id|fh
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|tcmsg
op_star
id|t
)paren
(brace
r_struct
id|tcindex_data
op_star
id|p
op_assign
id|PRIV
c_func
(paren
id|tp
)paren
suffix:semicolon
r_struct
id|tcindex_filter_result
op_star
id|r
op_assign
(paren
r_struct
id|tcindex_filter_result
op_star
)paren
id|fh
suffix:semicolon
r_int
r_char
op_star
id|b
op_assign
id|skb-&gt;tail
suffix:semicolon
r_struct
id|rtattr
op_star
id|rta
suffix:semicolon
id|DPRINTK
c_func
(paren
l_string|&quot;tcindex_dump(tp %p,fh 0x%lx,skb %p,t %p),p %p,r %p,b %p&bslash;n&quot;
comma
id|tp
comma
id|fh
comma
id|skb
comma
id|t
comma
id|p
comma
id|r
comma
id|b
)paren
suffix:semicolon
id|DPRINTK
c_func
(paren
l_string|&quot;p-&gt;perfect %p p-&gt;h %p&bslash;n&quot;
comma
id|p-&gt;perfect
comma
id|p-&gt;h
)paren
suffix:semicolon
id|rta
op_assign
(paren
r_struct
id|rtattr
op_star
)paren
id|b
suffix:semicolon
id|RTA_PUT
c_func
(paren
id|skb
comma
id|TCA_OPTIONS
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fh
)paren
(brace
id|t-&gt;tcm_handle
op_assign
op_complement
l_int|0
suffix:semicolon
multiline_comment|/* whatever ... */
id|RTA_PUT
c_func
(paren
id|skb
comma
id|TCA_TCINDEX_HASH
comma
r_sizeof
(paren
id|p-&gt;hash
)paren
comma
op_amp
id|p-&gt;hash
)paren
suffix:semicolon
id|RTA_PUT
c_func
(paren
id|skb
comma
id|TCA_TCINDEX_MASK
comma
r_sizeof
(paren
id|p-&gt;mask
)paren
comma
op_amp
id|p-&gt;mask
)paren
suffix:semicolon
id|RTA_PUT
c_func
(paren
id|skb
comma
id|TCA_TCINDEX_SHIFT
comma
r_sizeof
(paren
id|p-&gt;shift
)paren
comma
op_amp
id|p-&gt;shift
)paren
suffix:semicolon
id|RTA_PUT
c_func
(paren
id|skb
comma
id|TCA_TCINDEX_FALL_THROUGH
comma
r_sizeof
(paren
id|p-&gt;fall_through
)paren
comma
op_amp
id|p-&gt;fall_through
)paren
suffix:semicolon
id|rta-&gt;rta_len
op_assign
id|skb-&gt;tail
op_minus
id|b
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|p-&gt;perfect
)paren
(brace
id|t-&gt;tcm_handle
op_assign
id|r
op_minus
id|p-&gt;perfect
suffix:semicolon
)brace
r_else
(brace
r_struct
id|tcindex_filter
op_star
id|f
suffix:semicolon
r_int
id|i
suffix:semicolon
id|t-&gt;tcm_handle
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
op_logical_neg
id|t-&gt;tcm_handle
op_logical_and
id|i
OL
id|p-&gt;hash
suffix:semicolon
id|i
op_increment
)paren
(brace
r_for
c_loop
(paren
id|f
op_assign
id|p-&gt;h
(braket
id|i
)braket
suffix:semicolon
op_logical_neg
id|t-&gt;tcm_handle
op_logical_and
id|f
suffix:semicolon
id|f
op_assign
id|f-&gt;next
)paren
(brace
r_if
c_cond
(paren
op_amp
id|f-&gt;result
op_eq
id|r
)paren
id|t-&gt;tcm_handle
op_assign
id|f-&gt;key
suffix:semicolon
)brace
)brace
)brace
id|DPRINTK
c_func
(paren
l_string|&quot;handle = %d&bslash;n&quot;
comma
id|t-&gt;tcm_handle
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r-&gt;res
dot
r_class
)paren
id|RTA_PUT
c_func
(paren
id|skb
comma
id|TCA_TCINDEX_CLASSID
comma
l_int|4
comma
op_amp
id|r-&gt;res.classid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tcf_exts_dump
c_func
(paren
id|skb
comma
op_amp
id|r-&gt;exts
comma
op_amp
id|tcindex_ext_map
)paren
OL
l_int|0
)paren
r_goto
id|rtattr_failure
suffix:semicolon
id|rta-&gt;rta_len
op_assign
id|skb-&gt;tail
op_minus
id|b
suffix:semicolon
r_if
c_cond
(paren
id|tcf_exts_dump_stats
c_func
(paren
id|skb
comma
op_amp
id|r-&gt;exts
comma
op_amp
id|tcindex_ext_map
)paren
OL
l_int|0
)paren
r_goto
id|rtattr_failure
suffix:semicolon
)brace
r_return
id|skb-&gt;len
suffix:semicolon
id|rtattr_failure
suffix:colon
id|skb_trim
c_func
(paren
id|skb
comma
id|b
op_minus
id|skb-&gt;data
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
DECL|variable|cls_tcindex_ops
r_static
r_struct
id|tcf_proto_ops
id|cls_tcindex_ops
op_assign
(brace
dot
id|next
op_assign
l_int|NULL
comma
dot
id|kind
op_assign
l_string|&quot;tcindex&quot;
comma
dot
id|classify
op_assign
id|tcindex_classify
comma
dot
id|init
op_assign
id|tcindex_init
comma
dot
id|destroy
op_assign
id|tcindex_destroy
comma
dot
id|get
op_assign
id|tcindex_get
comma
dot
id|put
op_assign
id|tcindex_put
comma
dot
id|change
op_assign
id|tcindex_change
comma
dot
r_delete
op_assign
id|tcindex_delete
comma
dot
id|walk
op_assign
id|tcindex_walk
comma
dot
id|dump
op_assign
id|tcindex_dump
comma
dot
id|owner
op_assign
id|THIS_MODULE
comma
)brace
suffix:semicolon
DECL|function|init_tcindex
r_static
r_int
id|__init
id|init_tcindex
c_func
(paren
r_void
)paren
(brace
r_return
id|register_tcf_proto_ops
c_func
(paren
op_amp
id|cls_tcindex_ops
)paren
suffix:semicolon
)brace
DECL|function|exit_tcindex
r_static
r_void
id|__exit
id|exit_tcindex
c_func
(paren
r_void
)paren
(brace
id|unregister_tcf_proto_ops
c_func
(paren
op_amp
id|cls_tcindex_ops
)paren
suffix:semicolon
)brace
id|module_init
c_func
(paren
id|init_tcindex
)paren
id|module_exit
c_func
(paren
id|exit_tcindex
)paren
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
eof
