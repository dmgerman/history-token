multiline_comment|/*&n; * IPv6 library code, needed by static components when full IPv6 support is&n; * not configured or static.&n; */
macro_line|#include &lt;net/ipv6.h&gt;
multiline_comment|/* &n; * find out if nexthdr is a well-known extension header or a protocol&n; */
DECL|function|ipv6_ext_hdr
r_int
id|ipv6_ext_hdr
c_func
(paren
id|u8
id|nexthdr
)paren
(brace
multiline_comment|/* &n;&t; * find out if nexthdr is an extension header or a protocol&n;&t; */
r_return
(paren
(paren
id|nexthdr
op_eq
id|NEXTHDR_HOP
)paren
op_logical_or
(paren
id|nexthdr
op_eq
id|NEXTHDR_ROUTING
)paren
op_logical_or
(paren
id|nexthdr
op_eq
id|NEXTHDR_FRAGMENT
)paren
op_logical_or
(paren
id|nexthdr
op_eq
id|NEXTHDR_AUTH
)paren
op_logical_or
(paren
id|nexthdr
op_eq
id|NEXTHDR_NONE
)paren
op_logical_or
(paren
id|nexthdr
op_eq
id|NEXTHDR_DEST
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Skip any extension headers. This is used by the ICMP module.&n; *&n; * Note that strictly speaking this conflicts with RFC 2460 4.0:&n; * ...The contents and semantics of each extension header determine whether &n; * or not to proceed to the next header.  Therefore, extension headers must&n; * be processed strictly in the order they appear in the packet; a&n; * receiver must not, for example, scan through a packet looking for a&n; * particular kind of extension header and process that header prior to&n; * processing all preceding ones.&n; * &n; * We do exactly this. This is a protocol bug. We can&squot;t decide after a&n; * seeing an unknown discard-with-error flavour TLV option if it&squot;s a &n; * ICMP error message or not (errors should never be send in reply to&n; * ICMP error messages).&n; * &n; * But I see no other way to do this. This might need to be reexamined&n; * when Linux implements ESP (and maybe AUTH) headers.&n; * --AK&n; *&n; * This function parses (probably truncated) exthdr set &quot;hdr&quot;&n; * of length &quot;len&quot;. &quot;nexthdrp&quot; initially points to some place,&n; * where type of the first header can be found.&n; *&n; * It skips all well-known exthdrs, and returns pointer to the start&n; * of unparsable area i.e. the first header with unknown type.&n; * If it is not NULL *nexthdr is updated by type/protocol of this header.&n; *&n; * NOTES: - if packet terminated with NEXTHDR_NONE it returns NULL.&n; *        - it may return pointer pointing beyond end of packet,&n; *&t;    if the last recognized header is truncated in the middle.&n; *        - if packet is truncated, so that all parsed headers are skipped,&n; *&t;    it returns NULL.&n; *&t;  - First fragment header is skipped, not-first ones&n; *&t;    are considered as unparsable.&n; *&t;  - ESP is unparsable for now and considered like&n; *&t;    normal payload protocol.&n; *&t;  - Note also special handling of AUTH header. Thanks to IPsec wizards.&n; *&n; * --ANK (980726)&n; */
DECL|function|ipv6_skip_exthdr
r_int
id|ipv6_skip_exthdr
c_func
(paren
r_const
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|start
comma
id|u8
op_star
id|nexthdrp
comma
r_int
id|len
)paren
(brace
id|u8
id|nexthdr
op_assign
op_star
id|nexthdrp
suffix:semicolon
r_while
c_loop
(paren
id|ipv6_ext_hdr
c_func
(paren
id|nexthdr
)paren
)paren
(brace
r_struct
id|ipv6_opt_hdr
id|_hdr
comma
op_star
id|hp
suffix:semicolon
r_int
id|hdrlen
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
(paren
r_int
)paren
r_sizeof
(paren
r_struct
id|ipv6_opt_hdr
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|nexthdr
op_eq
id|NEXTHDR_NONE
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|hp
op_assign
id|skb_header_pointer
c_func
(paren
id|skb
comma
id|start
comma
r_sizeof
(paren
id|_hdr
)paren
comma
op_amp
id|_hdr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hp
op_eq
l_int|NULL
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nexthdr
op_eq
id|NEXTHDR_FRAGMENT
)paren
(brace
r_int
r_int
id|_frag_off
comma
op_star
id|fp
suffix:semicolon
id|fp
op_assign
id|skb_header_pointer
c_func
(paren
id|skb
comma
id|start
op_plus
m_offsetof
(paren
r_struct
id|frag_hdr
comma
id|frag_off
)paren
comma
r_sizeof
(paren
id|_frag_off
)paren
comma
op_amp
id|_frag_off
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fp
op_eq
l_int|NULL
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|ntohs
c_func
(paren
op_star
id|fp
)paren
op_amp
op_complement
l_int|0x7
)paren
r_break
suffix:semicolon
id|hdrlen
op_assign
l_int|8
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|nexthdr
op_eq
id|NEXTHDR_AUTH
)paren
id|hdrlen
op_assign
(paren
id|hp-&gt;hdrlen
op_plus
l_int|2
)paren
op_lshift
l_int|2
suffix:semicolon
r_else
id|hdrlen
op_assign
id|ipv6_optlen
c_func
(paren
id|hp
)paren
suffix:semicolon
id|nexthdr
op_assign
id|hp-&gt;nexthdr
suffix:semicolon
id|len
op_sub_assign
id|hdrlen
suffix:semicolon
id|start
op_add_assign
id|hdrlen
suffix:semicolon
)brace
op_star
id|nexthdrp
op_assign
id|nexthdr
suffix:semicolon
r_return
id|start
suffix:semicolon
)brace
DECL|variable|ipv6_ext_hdr
id|EXPORT_SYMBOL
c_func
(paren
id|ipv6_ext_hdr
)paren
suffix:semicolon
DECL|variable|ipv6_skip_exthdr
id|EXPORT_SYMBOL
c_func
(paren
id|ipv6_skip_exthdr
)paren
suffix:semicolon
eof
