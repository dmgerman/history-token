multiline_comment|/*&n; *  ebtables&n; *&n; *  Author:&n; *  Bart De Schuymer&t;&t;&lt;bdschuym@pandora.be&gt;&n; *&n; *  ebtables.c,v 2.0, July, 2002&n; *&n; *  This code is stongly inspired on the iptables code which is&n; *  Copyright (C) 1999 Paul `Rusty&squot; Russell &amp; Michael J. Neuling&n; *&n; *  This program is free software; you can redistribute it and/or&n; *  modify it under the terms of the GNU General Public License&n; *  as published by the Free Software Foundation; either version&n; *  2 of the License, or (at your option) any later version.&n; */
multiline_comment|/* used for print_string */
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/tty.h&gt;
macro_line|#include &lt;linux/kmod.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/vmalloc.h&gt;
macro_line|#include &lt;linux/netfilter_bridge/ebtables.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;linux/smp.h&gt;
macro_line|#include &lt;net/sock.h&gt;
multiline_comment|/* needed for logical [in,out]-dev filtering */
macro_line|#include &quot;../br_private.h&quot;
multiline_comment|/* list_named_find */
DECL|macro|ASSERT_READ_LOCK
mdefine_line|#define ASSERT_READ_LOCK(x)
DECL|macro|ASSERT_WRITE_LOCK
mdefine_line|#define ASSERT_WRITE_LOCK(x)
macro_line|#include &lt;linux/netfilter_ipv4/listhelp.h&gt;
macro_line|#if 0
multiline_comment|/* use this for remote debugging&n; * Copyright (C) 1998 by Ori Pomerantz&n; * Print the string to the appropriate tty, the one&n; * the current task uses&n; */
r_static
r_void
id|print_string
c_func
(paren
r_char
op_star
id|str
)paren
(brace
r_struct
id|tty_struct
op_star
id|my_tty
suffix:semicolon
multiline_comment|/* The tty for the current task */
id|my_tty
op_assign
id|current-&gt;signal-&gt;tty
suffix:semicolon
r_if
c_cond
(paren
id|my_tty
op_ne
l_int|NULL
)paren
(brace
id|my_tty-&gt;driver
op_member_access_from_pointer
id|write
c_func
(paren
id|my_tty
comma
l_int|0
comma
id|str
comma
id|strlen
c_func
(paren
id|str
)paren
)paren
suffix:semicolon
id|my_tty-&gt;driver
op_member_access_from_pointer
id|write
c_func
(paren
id|my_tty
comma
l_int|0
comma
l_string|&quot;&bslash;015&bslash;012&quot;
comma
l_int|2
)paren
suffix:semicolon
)brace
)brace
mdefine_line|#define BUGPRINT(args) print_string(args);
macro_line|#else
DECL|macro|BUGPRINT
mdefine_line|#define BUGPRINT(format, args...) printk(&quot;kernel msg: ebtables bug: please &quot;&bslash;&n;                                         &quot;report to author: &quot;format, ## args)
multiline_comment|/* #define BUGPRINT(format, args...) */
macro_line|#endif
DECL|macro|MEMPRINT
mdefine_line|#define MEMPRINT(format, args...) printk(&quot;kernel msg: ebtables &quot;&bslash;&n;                                         &quot;: out of memory: &quot;format, ## args)
multiline_comment|/* #define MEMPRINT(format, args...) */
multiline_comment|/*&n; * Each cpu has its own set of counters, so there is no need for write_lock in&n; * the softirq&n; * For reading or updating the counters, the user context needs to&n; * get a write_lock&n; */
multiline_comment|/* The size of each set of counters is altered to get cache alignment */
DECL|macro|SMP_ALIGN
mdefine_line|#define SMP_ALIGN(x) (((x) + SMP_CACHE_BYTES-1) &amp; ~(SMP_CACHE_BYTES-1))
DECL|macro|COUNTER_OFFSET
mdefine_line|#define COUNTER_OFFSET(n) (SMP_ALIGN(n * sizeof(struct ebt_counter)))
DECL|macro|COUNTER_BASE
mdefine_line|#define COUNTER_BASE(c, n, cpu) ((struct ebt_counter *)(((char *)c) + &bslash;&n;   COUNTER_OFFSET(n) * cpu))
r_static
id|DECLARE_MUTEX
c_func
(paren
id|ebt_mutex
)paren
suffix:semicolon
r_static
id|LIST_HEAD
c_func
(paren
id|ebt_tables
)paren
suffix:semicolon
r_static
id|LIST_HEAD
c_func
(paren
id|ebt_targets
)paren
suffix:semicolon
r_static
id|LIST_HEAD
c_func
(paren
id|ebt_matches
)paren
suffix:semicolon
r_static
id|LIST_HEAD
c_func
(paren
id|ebt_watchers
)paren
suffix:semicolon
DECL|variable|ebt_standard_target
r_static
r_struct
id|ebt_target
id|ebt_standard_target
op_assign
(brace
(brace
l_int|NULL
comma
l_int|NULL
)brace
comma
id|EBT_STANDARD_TARGET
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
)brace
suffix:semicolon
DECL|function|ebt_do_watcher
r_static
r_inline
r_int
id|ebt_do_watcher
(paren
r_struct
id|ebt_entry_watcher
op_star
id|w
comma
r_const
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
r_int
id|hooknr
comma
r_const
r_struct
id|net_device
op_star
id|in
comma
r_const
r_struct
id|net_device
op_star
id|out
)paren
(brace
id|w-&gt;u.watcher
op_member_access_from_pointer
id|watcher
c_func
(paren
id|skb
comma
id|hooknr
comma
id|in
comma
id|out
comma
id|w-&gt;data
comma
id|w-&gt;watcher_size
)paren
suffix:semicolon
multiline_comment|/* watchers don&squot;t give a verdict */
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ebt_do_match
r_static
r_inline
r_int
id|ebt_do_match
(paren
r_struct
id|ebt_entry_match
op_star
id|m
comma
r_const
r_struct
id|sk_buff
op_star
id|skb
comma
r_const
r_struct
id|net_device
op_star
id|in
comma
r_const
r_struct
id|net_device
op_star
id|out
)paren
(brace
r_return
id|m-&gt;u.match
op_member_access_from_pointer
id|match
c_func
(paren
id|skb
comma
id|in
comma
id|out
comma
id|m-&gt;data
comma
id|m-&gt;match_size
)paren
suffix:semicolon
)brace
DECL|function|ebt_dev_check
r_static
r_inline
r_int
id|ebt_dev_check
c_func
(paren
r_char
op_star
id|entry
comma
r_const
r_struct
id|net_device
op_star
id|device
)paren
(brace
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_char
op_star
id|devname
op_assign
id|device-&gt;name
suffix:semicolon
r_if
c_cond
(paren
op_star
id|entry
op_eq
l_char|&squot;&bslash;0&squot;
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|device
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* 1 is the wildcard token */
r_while
c_loop
(paren
id|entry
(braket
id|i
)braket
op_ne
l_char|&squot;&bslash;0&squot;
op_logical_and
id|entry
(braket
id|i
)braket
op_ne
l_int|1
op_logical_and
id|entry
(braket
id|i
)braket
op_eq
id|devname
(braket
id|i
)braket
)paren
id|i
op_increment
suffix:semicolon
r_return
(paren
id|devname
(braket
id|i
)braket
op_ne
id|entry
(braket
id|i
)braket
op_logical_and
id|entry
(braket
id|i
)braket
op_ne
l_int|1
)paren
suffix:semicolon
)brace
DECL|macro|FWINV2
mdefine_line|#define FWINV2(bool,invflg) ((bool) ^ !!(e-&gt;invflags &amp; invflg))
multiline_comment|/* process standard matches */
DECL|function|ebt_basic_match
r_static
r_inline
r_int
id|ebt_basic_match
c_func
(paren
r_struct
id|ebt_entry
op_star
id|e
comma
r_struct
id|ethhdr
op_star
id|h
comma
r_const
r_struct
id|net_device
op_star
id|in
comma
r_const
r_struct
id|net_device
op_star
id|out
)paren
(brace
r_int
id|verdict
comma
id|i
suffix:semicolon
r_if
c_cond
(paren
id|e-&gt;bitmask
op_amp
id|EBT_802_3
)paren
(brace
r_if
c_cond
(paren
id|FWINV2
c_func
(paren
id|ntohs
c_func
(paren
id|h-&gt;h_proto
)paren
op_ge
l_int|1536
comma
id|EBT_IPROTO
)paren
)paren
r_return
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
(paren
id|e-&gt;bitmask
op_amp
id|EBT_NOPROTO
)paren
op_logical_and
id|FWINV2
c_func
(paren
id|e-&gt;ethproto
op_ne
id|h-&gt;h_proto
comma
id|EBT_IPROTO
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|FWINV2
c_func
(paren
id|ebt_dev_check
c_func
(paren
id|e-&gt;in
comma
id|in
)paren
comma
id|EBT_IIN
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|FWINV2
c_func
(paren
id|ebt_dev_check
c_func
(paren
id|e-&gt;out
comma
id|out
)paren
comma
id|EBT_IOUT
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
op_logical_neg
id|in
op_logical_or
op_logical_neg
id|in-&gt;br_port
)paren
ques
c_cond
l_int|0
suffix:colon
id|FWINV2
c_func
(paren
id|ebt_dev_check
c_func
(paren
id|e-&gt;logical_in
comma
id|in-&gt;br_port-&gt;br-&gt;dev
)paren
comma
id|EBT_ILOGICALIN
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
op_logical_neg
id|out
op_logical_or
op_logical_neg
id|out-&gt;br_port
)paren
ques
c_cond
l_int|0
suffix:colon
id|FWINV2
c_func
(paren
id|ebt_dev_check
c_func
(paren
id|e-&gt;logical_out
comma
id|out-&gt;br_port-&gt;br-&gt;dev
)paren
comma
id|EBT_ILOGICALOUT
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|e-&gt;bitmask
op_amp
id|EBT_SOURCEMAC
)paren
(brace
id|verdict
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
id|verdict
op_or_assign
(paren
id|h-&gt;h_source
(braket
id|i
)braket
op_xor
id|e-&gt;sourcemac
(braket
id|i
)braket
)paren
op_amp
id|e-&gt;sourcemsk
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|FWINV2
c_func
(paren
id|verdict
op_ne
l_int|0
comma
id|EBT_ISOURCE
)paren
)paren
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|e-&gt;bitmask
op_amp
id|EBT_DESTMAC
)paren
(brace
id|verdict
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
id|verdict
op_or_assign
(paren
id|h-&gt;h_dest
(braket
id|i
)braket
op_xor
id|e-&gt;destmac
(braket
id|i
)braket
)paren
op_amp
id|e-&gt;destmsk
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|FWINV2
c_func
(paren
id|verdict
op_ne
l_int|0
comma
id|EBT_IDEST
)paren
)paren
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Do some firewalling */
DECL|function|ebt_do_table
r_int
r_int
id|ebt_do_table
(paren
r_int
r_int
id|hook
comma
r_struct
id|sk_buff
op_star
op_star
id|pskb
comma
r_const
r_struct
id|net_device
op_star
id|in
comma
r_const
r_struct
id|net_device
op_star
id|out
comma
r_struct
id|ebt_table
op_star
id|table
)paren
(brace
r_int
id|i
comma
id|nentries
suffix:semicolon
r_struct
id|ebt_entry
op_star
id|point
suffix:semicolon
r_struct
id|ebt_counter
op_star
id|counter_base
comma
op_star
id|cb_base
suffix:semicolon
r_struct
id|ebt_entry_target
op_star
id|t
suffix:semicolon
r_int
id|verdict
comma
id|sp
op_assign
l_int|0
suffix:semicolon
r_struct
id|ebt_chainstack
op_star
id|cs
suffix:semicolon
r_struct
id|ebt_entries
op_star
id|chaininfo
suffix:semicolon
r_char
op_star
id|base
suffix:semicolon
r_struct
id|ebt_table_info
op_star
r_private
op_assign
id|table
op_member_access_from_pointer
r_private
suffix:semicolon
id|read_lock_bh
c_func
(paren
op_amp
id|table-&gt;lock
)paren
suffix:semicolon
id|cb_base
op_assign
id|COUNTER_BASE
c_func
(paren
r_private
op_member_access_from_pointer
id|counters
comma
r_private
op_member_access_from_pointer
id|nentries
comma
id|smp_processor_id
c_func
(paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
r_private
op_member_access_from_pointer
id|chainstack
)paren
id|cs
op_assign
r_private
op_member_access_from_pointer
id|chainstack
(braket
id|smp_processor_id
c_func
(paren
)paren
)braket
suffix:semicolon
r_else
id|cs
op_assign
l_int|NULL
suffix:semicolon
id|chaininfo
op_assign
r_private
op_member_access_from_pointer
id|hook_entry
(braket
id|hook
)braket
suffix:semicolon
id|nentries
op_assign
r_private
op_member_access_from_pointer
id|hook_entry
(braket
id|hook
)braket
op_member_access_from_pointer
id|nentries
suffix:semicolon
id|point
op_assign
(paren
r_struct
id|ebt_entry
op_star
)paren
(paren
r_private
op_member_access_from_pointer
id|hook_entry
(braket
id|hook
)braket
op_member_access_from_pointer
id|data
)paren
suffix:semicolon
id|counter_base
op_assign
id|cb_base
op_plus
r_private
op_member_access_from_pointer
id|hook_entry
(braket
id|hook
)braket
op_member_access_from_pointer
id|counter_offset
suffix:semicolon
multiline_comment|/* base for chain jumps */
id|base
op_assign
r_private
op_member_access_from_pointer
id|entries
suffix:semicolon
id|i
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|i
OL
id|nentries
)paren
(brace
r_if
c_cond
(paren
id|ebt_basic_match
c_func
(paren
id|point
comma
id|eth_hdr
c_func
(paren
op_star
id|pskb
)paren
comma
id|in
comma
id|out
)paren
)paren
r_goto
id|letscontinue
suffix:semicolon
r_if
c_cond
(paren
id|EBT_MATCH_ITERATE
c_func
(paren
id|point
comma
id|ebt_do_match
comma
op_star
id|pskb
comma
id|in
comma
id|out
)paren
op_ne
l_int|0
)paren
r_goto
id|letscontinue
suffix:semicolon
multiline_comment|/* increase counter */
(paren
id|counter_base
op_plus
id|i
)paren
op_member_access_from_pointer
id|pcnt
op_increment
suffix:semicolon
(paren
id|counter_base
op_plus
id|i
)paren
op_member_access_from_pointer
id|bcnt
op_add_assign
op_star
id|pskb.len
suffix:semicolon
multiline_comment|/* these should only watch: not modify, nor tell us&n;&t;&t;   what to do with the packet */
id|EBT_WATCHER_ITERATE
c_func
(paren
id|point
comma
id|ebt_do_watcher
comma
op_star
id|pskb
comma
id|hook
comma
id|in
comma
id|out
)paren
suffix:semicolon
id|t
op_assign
(paren
r_struct
id|ebt_entry_target
op_star
)paren
(paren
(paren
(paren
r_char
op_star
)paren
id|point
)paren
op_plus
id|point-&gt;target_offset
)paren
suffix:semicolon
multiline_comment|/* standard target */
r_if
c_cond
(paren
op_logical_neg
id|t-&gt;u.target-&gt;target
)paren
id|verdict
op_assign
(paren
(paren
r_struct
id|ebt_standard_target
op_star
)paren
id|t
)paren
op_member_access_from_pointer
id|verdict
suffix:semicolon
r_else
id|verdict
op_assign
id|t-&gt;u.target
op_member_access_from_pointer
id|target
c_func
(paren
id|pskb
comma
id|hook
comma
id|in
comma
id|out
comma
id|t-&gt;data
comma
id|t-&gt;target_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|verdict
op_eq
id|EBT_ACCEPT
)paren
(brace
id|read_unlock_bh
c_func
(paren
op_amp
id|table-&gt;lock
)paren
suffix:semicolon
r_return
id|NF_ACCEPT
suffix:semicolon
)brace
r_if
c_cond
(paren
id|verdict
op_eq
id|EBT_DROP
)paren
(brace
id|read_unlock_bh
c_func
(paren
op_amp
id|table-&gt;lock
)paren
suffix:semicolon
r_return
id|NF_DROP
suffix:semicolon
)brace
r_if
c_cond
(paren
id|verdict
op_eq
id|EBT_RETURN
)paren
(brace
id|letsreturn
suffix:colon
macro_line|#ifdef CONFIG_NETFILTER_DEBUG
r_if
c_cond
(paren
id|sp
op_eq
l_int|0
)paren
(brace
id|BUGPRINT
c_func
(paren
l_string|&quot;RETURN on base chain&quot;
)paren
suffix:semicolon
multiline_comment|/* act like this is EBT_CONTINUE */
r_goto
id|letscontinue
suffix:semicolon
)brace
macro_line|#endif
id|sp
op_decrement
suffix:semicolon
multiline_comment|/* put all the local variables right */
id|i
op_assign
id|cs
(braket
id|sp
)braket
dot
id|n
suffix:semicolon
id|chaininfo
op_assign
id|cs
(braket
id|sp
)braket
dot
id|chaininfo
suffix:semicolon
id|nentries
op_assign
id|chaininfo-&gt;nentries
suffix:semicolon
id|point
op_assign
id|cs
(braket
id|sp
)braket
dot
id|e
suffix:semicolon
id|counter_base
op_assign
id|cb_base
op_plus
id|chaininfo-&gt;counter_offset
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|verdict
op_eq
id|EBT_CONTINUE
)paren
r_goto
id|letscontinue
suffix:semicolon
macro_line|#ifdef CONFIG_NETFILTER_DEBUG
r_if
c_cond
(paren
id|verdict
OL
l_int|0
)paren
(brace
id|BUGPRINT
c_func
(paren
l_string|&quot;bogus standard verdict&bslash;n&quot;
)paren
suffix:semicolon
id|read_unlock_bh
c_func
(paren
op_amp
id|table-&gt;lock
)paren
suffix:semicolon
r_return
id|NF_DROP
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* jump to a udc */
id|cs
(braket
id|sp
)braket
dot
id|n
op_assign
id|i
op_plus
l_int|1
suffix:semicolon
id|cs
(braket
id|sp
)braket
dot
id|chaininfo
op_assign
id|chaininfo
suffix:semicolon
id|cs
(braket
id|sp
)braket
dot
id|e
op_assign
(paren
r_struct
id|ebt_entry
op_star
)paren
(paren
(paren
(paren
r_char
op_star
)paren
id|point
)paren
op_plus
id|point-&gt;next_offset
)paren
suffix:semicolon
id|i
op_assign
l_int|0
suffix:semicolon
id|chaininfo
op_assign
(paren
r_struct
id|ebt_entries
op_star
)paren
(paren
id|base
op_plus
id|verdict
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_NETFILTER_DEBUG
r_if
c_cond
(paren
id|chaininfo-&gt;distinguisher
)paren
(brace
id|BUGPRINT
c_func
(paren
l_string|&quot;jump to non-chain&bslash;n&quot;
)paren
suffix:semicolon
id|read_unlock_bh
c_func
(paren
op_amp
id|table-&gt;lock
)paren
suffix:semicolon
r_return
id|NF_DROP
suffix:semicolon
)brace
macro_line|#endif
id|nentries
op_assign
id|chaininfo-&gt;nentries
suffix:semicolon
id|point
op_assign
(paren
r_struct
id|ebt_entry
op_star
)paren
id|chaininfo-&gt;data
suffix:semicolon
id|counter_base
op_assign
id|cb_base
op_plus
id|chaininfo-&gt;counter_offset
suffix:semicolon
id|sp
op_increment
suffix:semicolon
r_continue
suffix:semicolon
id|letscontinue
suffix:colon
id|point
op_assign
(paren
r_struct
id|ebt_entry
op_star
)paren
(paren
(paren
(paren
r_char
op_star
)paren
id|point
)paren
op_plus
id|point-&gt;next_offset
)paren
suffix:semicolon
id|i
op_increment
suffix:semicolon
)brace
multiline_comment|/* I actually like this :) */
r_if
c_cond
(paren
id|chaininfo-&gt;policy
op_eq
id|EBT_RETURN
)paren
r_goto
id|letsreturn
suffix:semicolon
r_if
c_cond
(paren
id|chaininfo-&gt;policy
op_eq
id|EBT_ACCEPT
)paren
(brace
id|read_unlock_bh
c_func
(paren
op_amp
id|table-&gt;lock
)paren
suffix:semicolon
r_return
id|NF_ACCEPT
suffix:semicolon
)brace
id|read_unlock_bh
c_func
(paren
op_amp
id|table-&gt;lock
)paren
suffix:semicolon
r_return
id|NF_DROP
suffix:semicolon
)brace
multiline_comment|/* If it succeeds, returns element and locks mutex */
r_static
r_inline
r_void
op_star
DECL|function|find_inlist_lock_noload
id|find_inlist_lock_noload
c_func
(paren
r_struct
id|list_head
op_star
id|head
comma
r_const
r_char
op_star
id|name
comma
r_int
op_star
id|error
comma
r_struct
id|semaphore
op_star
id|mutex
)paren
(brace
r_void
op_star
id|ret
suffix:semicolon
op_star
id|error
op_assign
id|down_interruptible
c_func
(paren
id|mutex
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|error
op_ne
l_int|0
)paren
r_return
l_int|NULL
suffix:semicolon
id|ret
op_assign
id|list_named_find
c_func
(paren
id|head
comma
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
(brace
op_star
id|error
op_assign
op_minus
id|ENOENT
suffix:semicolon
id|up
c_func
(paren
id|mutex
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
macro_line|#ifndef CONFIG_KMOD
DECL|macro|find_inlist_lock
mdefine_line|#define find_inlist_lock(h,n,p,e,m) find_inlist_lock_noload((h),(n),(e),(m))
macro_line|#else
r_static
r_void
op_star
DECL|function|find_inlist_lock
id|find_inlist_lock
c_func
(paren
r_struct
id|list_head
op_star
id|head
comma
r_const
r_char
op_star
id|name
comma
r_const
r_char
op_star
id|prefix
comma
r_int
op_star
id|error
comma
r_struct
id|semaphore
op_star
id|mutex
)paren
(brace
r_void
op_star
id|ret
suffix:semicolon
id|ret
op_assign
id|find_inlist_lock_noload
c_func
(paren
id|head
comma
id|name
comma
id|error
comma
id|mutex
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
(brace
id|request_module
c_func
(paren
l_string|&quot;%s%s&quot;
comma
id|prefix
comma
id|name
)paren
suffix:semicolon
id|ret
op_assign
id|find_inlist_lock_noload
c_func
(paren
id|head
comma
id|name
comma
id|error
comma
id|mutex
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
macro_line|#endif
r_static
r_inline
r_struct
id|ebt_table
op_star
DECL|function|find_table_lock
id|find_table_lock
c_func
(paren
r_const
r_char
op_star
id|name
comma
r_int
op_star
id|error
comma
r_struct
id|semaphore
op_star
id|mutex
)paren
(brace
r_return
id|find_inlist_lock
c_func
(paren
op_amp
id|ebt_tables
comma
id|name
comma
l_string|&quot;ebtable_&quot;
comma
id|error
comma
id|mutex
)paren
suffix:semicolon
)brace
r_static
r_inline
r_struct
id|ebt_match
op_star
DECL|function|find_match_lock
id|find_match_lock
c_func
(paren
r_const
r_char
op_star
id|name
comma
r_int
op_star
id|error
comma
r_struct
id|semaphore
op_star
id|mutex
)paren
(brace
r_return
id|find_inlist_lock
c_func
(paren
op_amp
id|ebt_matches
comma
id|name
comma
l_string|&quot;ebt_&quot;
comma
id|error
comma
id|mutex
)paren
suffix:semicolon
)brace
r_static
r_inline
r_struct
id|ebt_watcher
op_star
DECL|function|find_watcher_lock
id|find_watcher_lock
c_func
(paren
r_const
r_char
op_star
id|name
comma
r_int
op_star
id|error
comma
r_struct
id|semaphore
op_star
id|mutex
)paren
(brace
r_return
id|find_inlist_lock
c_func
(paren
op_amp
id|ebt_watchers
comma
id|name
comma
l_string|&quot;ebt_&quot;
comma
id|error
comma
id|mutex
)paren
suffix:semicolon
)brace
r_static
r_inline
r_struct
id|ebt_target
op_star
DECL|function|find_target_lock
id|find_target_lock
c_func
(paren
r_const
r_char
op_star
id|name
comma
r_int
op_star
id|error
comma
r_struct
id|semaphore
op_star
id|mutex
)paren
(brace
r_return
id|find_inlist_lock
c_func
(paren
op_amp
id|ebt_targets
comma
id|name
comma
l_string|&quot;ebt_&quot;
comma
id|error
comma
id|mutex
)paren
suffix:semicolon
)brace
r_static
r_inline
r_int
DECL|function|ebt_check_match
id|ebt_check_match
c_func
(paren
r_struct
id|ebt_entry_match
op_star
id|m
comma
r_struct
id|ebt_entry
op_star
id|e
comma
r_const
r_char
op_star
id|name
comma
r_int
r_int
id|hookmask
comma
r_int
r_int
op_star
id|cnt
)paren
(brace
r_struct
id|ebt_match
op_star
id|match
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
r_char
op_star
)paren
id|m
)paren
op_plus
id|m-&gt;match_size
op_plus
r_sizeof
(paren
r_struct
id|ebt_entry_match
)paren
OG
(paren
(paren
r_char
op_star
)paren
id|e
)paren
op_plus
id|e-&gt;watchers_offset
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|match
op_assign
id|find_match_lock
c_func
(paren
id|m-&gt;u.name
comma
op_amp
id|ret
comma
op_amp
id|ebt_mutex
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|match
)paren
r_return
id|ret
suffix:semicolon
id|m-&gt;u.match
op_assign
id|match
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|try_module_get
c_func
(paren
id|match-&gt;me
)paren
)paren
(brace
id|up
c_func
(paren
op_amp
id|ebt_mutex
)paren
suffix:semicolon
r_return
op_minus
id|ENOENT
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|ebt_mutex
)paren
suffix:semicolon
r_if
c_cond
(paren
id|match-&gt;check
op_logical_and
id|match
op_member_access_from_pointer
id|check
c_func
(paren
id|name
comma
id|hookmask
comma
id|e
comma
id|m-&gt;data
comma
id|m-&gt;match_size
)paren
op_ne
l_int|0
)paren
(brace
id|BUGPRINT
c_func
(paren
l_string|&quot;match-&gt;check failed&bslash;n&quot;
)paren
suffix:semicolon
id|module_put
c_func
(paren
id|match-&gt;me
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
(paren
op_star
id|cnt
)paren
op_increment
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_inline
r_int
DECL|function|ebt_check_watcher
id|ebt_check_watcher
c_func
(paren
r_struct
id|ebt_entry_watcher
op_star
id|w
comma
r_struct
id|ebt_entry
op_star
id|e
comma
r_const
r_char
op_star
id|name
comma
r_int
r_int
id|hookmask
comma
r_int
r_int
op_star
id|cnt
)paren
(brace
r_struct
id|ebt_watcher
op_star
id|watcher
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
r_char
op_star
)paren
id|w
)paren
op_plus
id|w-&gt;watcher_size
op_plus
r_sizeof
(paren
r_struct
id|ebt_entry_watcher
)paren
OG
(paren
(paren
r_char
op_star
)paren
id|e
)paren
op_plus
id|e-&gt;target_offset
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|watcher
op_assign
id|find_watcher_lock
c_func
(paren
id|w-&gt;u.name
comma
op_amp
id|ret
comma
op_amp
id|ebt_mutex
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|watcher
)paren
r_return
id|ret
suffix:semicolon
id|w-&gt;u.watcher
op_assign
id|watcher
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|try_module_get
c_func
(paren
id|watcher-&gt;me
)paren
)paren
(brace
id|up
c_func
(paren
op_amp
id|ebt_mutex
)paren
suffix:semicolon
r_return
op_minus
id|ENOENT
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|ebt_mutex
)paren
suffix:semicolon
r_if
c_cond
(paren
id|watcher-&gt;check
op_logical_and
id|watcher
op_member_access_from_pointer
id|check
c_func
(paren
id|name
comma
id|hookmask
comma
id|e
comma
id|w-&gt;data
comma
id|w-&gt;watcher_size
)paren
op_ne
l_int|0
)paren
(brace
id|BUGPRINT
c_func
(paren
l_string|&quot;watcher-&gt;check failed&bslash;n&quot;
)paren
suffix:semicolon
id|module_put
c_func
(paren
id|watcher-&gt;me
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
(paren
op_star
id|cnt
)paren
op_increment
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * this one is very careful, as it is the first function&n; * to parse the userspace data&n; */
r_static
r_inline
r_int
DECL|function|ebt_check_entry_size_and_hooks
id|ebt_check_entry_size_and_hooks
c_func
(paren
r_struct
id|ebt_entry
op_star
id|e
comma
r_struct
id|ebt_table_info
op_star
id|newinfo
comma
r_char
op_star
id|base
comma
r_char
op_star
id|limit
comma
r_struct
id|ebt_entries
op_star
op_star
id|hook_entries
comma
r_int
r_int
op_star
id|n
comma
r_int
r_int
op_star
id|cnt
comma
r_int
r_int
op_star
id|totalcnt
comma
r_int
r_int
op_star
id|udc_cnt
comma
r_int
r_int
id|valid_hooks
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NF_BR_NUMHOOKS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|valid_hooks
op_amp
(paren
l_int|1
op_lshift
id|i
)paren
)paren
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
(paren
r_char
op_star
)paren
id|hook_entries
(braket
id|i
)braket
op_minus
id|base
op_eq
(paren
r_char
op_star
)paren
id|e
op_minus
id|newinfo-&gt;entries
)paren
r_break
suffix:semicolon
)brace
multiline_comment|/* beginning of a new chain&n;&t;   if i == NF_BR_NUMHOOKS it must be a user defined chain */
r_if
c_cond
(paren
id|i
op_ne
id|NF_BR_NUMHOOKS
op_logical_or
op_logical_neg
(paren
id|e-&gt;bitmask
op_amp
id|EBT_ENTRY_OR_ENTRIES
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|e-&gt;bitmask
op_amp
id|EBT_ENTRY_OR_ENTRIES
)paren
op_ne
l_int|0
)paren
(brace
multiline_comment|/* we make userspace set this right,&n;&t;&t;&t;   so there is no misunderstanding */
id|BUGPRINT
c_func
(paren
l_string|&quot;EBT_ENTRY_OR_ENTRIES shouldn&squot;t be set &quot;
l_string|&quot;in distinguisher&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* this checks if the previous chain has as many entries&n;&t;&t;   as it said it has */
r_if
c_cond
(paren
op_star
id|n
op_ne
op_star
id|cnt
)paren
(brace
id|BUGPRINT
c_func
(paren
l_string|&quot;nentries does not equal the nr of entries &quot;
l_string|&quot;in the chain&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* before we look at the struct, be sure it is not too big */
r_if
c_cond
(paren
(paren
r_char
op_star
)paren
id|hook_entries
(braket
id|i
)braket
op_plus
r_sizeof
(paren
r_struct
id|ebt_entries
)paren
OG
id|limit
)paren
(brace
id|BUGPRINT
c_func
(paren
l_string|&quot;entries_size too small&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
(paren
r_struct
id|ebt_entries
op_star
)paren
id|e
)paren
op_member_access_from_pointer
id|policy
op_ne
id|EBT_DROP
op_logical_and
(paren
(paren
r_struct
id|ebt_entries
op_star
)paren
id|e
)paren
op_member_access_from_pointer
id|policy
op_ne
id|EBT_ACCEPT
)paren
(brace
multiline_comment|/* only RETURN from udc */
r_if
c_cond
(paren
id|i
op_ne
id|NF_BR_NUMHOOKS
op_logical_or
(paren
(paren
r_struct
id|ebt_entries
op_star
)paren
id|e
)paren
op_member_access_from_pointer
id|policy
op_ne
id|EBT_RETURN
)paren
(brace
id|BUGPRINT
c_func
(paren
l_string|&quot;bad policy&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|i
op_eq
id|NF_BR_NUMHOOKS
)paren
multiline_comment|/* it&squot;s a user defined chain */
(paren
op_star
id|udc_cnt
)paren
op_increment
suffix:semicolon
r_else
id|newinfo-&gt;hook_entry
(braket
id|i
)braket
op_assign
(paren
r_struct
id|ebt_entries
op_star
)paren
id|e
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
r_struct
id|ebt_entries
op_star
)paren
id|e
)paren
op_member_access_from_pointer
id|counter_offset
op_ne
op_star
id|totalcnt
)paren
(brace
id|BUGPRINT
c_func
(paren
l_string|&quot;counter_offset != totalcnt&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
op_star
id|n
op_assign
(paren
(paren
r_struct
id|ebt_entries
op_star
)paren
id|e
)paren
op_member_access_from_pointer
id|nentries
suffix:semicolon
op_star
id|cnt
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* a plain old entry, heh */
r_if
c_cond
(paren
r_sizeof
(paren
r_struct
id|ebt_entry
)paren
OG
id|e-&gt;watchers_offset
op_logical_or
id|e-&gt;watchers_offset
OG
id|e-&gt;target_offset
op_logical_or
id|e-&gt;target_offset
op_ge
id|e-&gt;next_offset
)paren
(brace
id|BUGPRINT
c_func
(paren
l_string|&quot;entry offsets not in right order&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* this is not checked anywhere else */
r_if
c_cond
(paren
id|e-&gt;next_offset
op_minus
id|e-&gt;target_offset
OL
r_sizeof
(paren
r_struct
id|ebt_entry_target
)paren
)paren
(brace
id|BUGPRINT
c_func
(paren
l_string|&quot;target size too small&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
(paren
op_star
id|cnt
)paren
op_increment
suffix:semicolon
(paren
op_star
id|totalcnt
)paren
op_increment
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|struct|ebt_cl_stack
r_struct
id|ebt_cl_stack
(brace
DECL|member|cs
r_struct
id|ebt_chainstack
id|cs
suffix:semicolon
DECL|member|from
r_int
id|from
suffix:semicolon
DECL|member|hookmask
r_int
r_int
id|hookmask
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * we need these positions to check that the jumps to a different part of the&n; * entries is a jump to the beginning of a new chain.&n; */
r_static
r_inline
r_int
DECL|function|ebt_get_udc_positions
id|ebt_get_udc_positions
c_func
(paren
r_struct
id|ebt_entry
op_star
id|e
comma
r_struct
id|ebt_table_info
op_star
id|newinfo
comma
r_struct
id|ebt_entries
op_star
op_star
id|hook_entries
comma
r_int
r_int
op_star
id|n
comma
r_int
r_int
id|valid_hooks
comma
r_struct
id|ebt_cl_stack
op_star
id|udc
)paren
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/* we&squot;re only interested in chain starts */
r_if
c_cond
(paren
id|e-&gt;bitmask
op_amp
id|EBT_ENTRY_OR_ENTRIES
)paren
r_return
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NF_BR_NUMHOOKS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|valid_hooks
op_amp
(paren
l_int|1
op_lshift
id|i
)paren
)paren
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|newinfo-&gt;hook_entry
(braket
id|i
)braket
op_eq
(paren
r_struct
id|ebt_entries
op_star
)paren
id|e
)paren
r_break
suffix:semicolon
)brace
multiline_comment|/* only care about udc */
r_if
c_cond
(paren
id|i
op_ne
id|NF_BR_NUMHOOKS
)paren
r_return
l_int|0
suffix:semicolon
id|udc
(braket
op_star
id|n
)braket
dot
id|cs.chaininfo
op_assign
(paren
r_struct
id|ebt_entries
op_star
)paren
id|e
suffix:semicolon
multiline_comment|/* these initialisations are depended on later in check_chainloops() */
id|udc
(braket
op_star
id|n
)braket
dot
id|cs.n
op_assign
l_int|0
suffix:semicolon
id|udc
(braket
op_star
id|n
)braket
dot
id|hookmask
op_assign
l_int|0
suffix:semicolon
(paren
op_star
id|n
)paren
op_increment
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_inline
r_int
DECL|function|ebt_cleanup_match
id|ebt_cleanup_match
c_func
(paren
r_struct
id|ebt_entry_match
op_star
id|m
comma
r_int
r_int
op_star
id|i
)paren
(brace
r_if
c_cond
(paren
id|i
op_logical_and
(paren
op_star
id|i
)paren
op_decrement
op_eq
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|m-&gt;u.match-&gt;destroy
)paren
id|m-&gt;u.match
op_member_access_from_pointer
id|destroy
c_func
(paren
id|m-&gt;data
comma
id|m-&gt;match_size
)paren
suffix:semicolon
id|module_put
c_func
(paren
id|m-&gt;u.match-&gt;me
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_inline
r_int
DECL|function|ebt_cleanup_watcher
id|ebt_cleanup_watcher
c_func
(paren
r_struct
id|ebt_entry_watcher
op_star
id|w
comma
r_int
r_int
op_star
id|i
)paren
(brace
r_if
c_cond
(paren
id|i
op_logical_and
(paren
op_star
id|i
)paren
op_decrement
op_eq
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|w-&gt;u.watcher-&gt;destroy
)paren
id|w-&gt;u.watcher
op_member_access_from_pointer
id|destroy
c_func
(paren
id|w-&gt;data
comma
id|w-&gt;watcher_size
)paren
suffix:semicolon
id|module_put
c_func
(paren
id|w-&gt;u.watcher-&gt;me
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_inline
r_int
DECL|function|ebt_cleanup_entry
id|ebt_cleanup_entry
c_func
(paren
r_struct
id|ebt_entry
op_star
id|e
comma
r_int
r_int
op_star
id|cnt
)paren
(brace
r_struct
id|ebt_entry_target
op_star
id|t
suffix:semicolon
r_if
c_cond
(paren
(paren
id|e-&gt;bitmask
op_amp
id|EBT_ENTRY_OR_ENTRIES
)paren
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* we&squot;re done */
r_if
c_cond
(paren
id|cnt
op_logical_and
(paren
op_star
id|cnt
)paren
op_decrement
op_eq
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
id|EBT_WATCHER_ITERATE
c_func
(paren
id|e
comma
id|ebt_cleanup_watcher
comma
l_int|NULL
)paren
suffix:semicolon
id|EBT_MATCH_ITERATE
c_func
(paren
id|e
comma
id|ebt_cleanup_match
comma
l_int|NULL
)paren
suffix:semicolon
id|t
op_assign
(paren
r_struct
id|ebt_entry_target
op_star
)paren
(paren
(paren
(paren
r_char
op_star
)paren
id|e
)paren
op_plus
id|e-&gt;target_offset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|t-&gt;u.target-&gt;destroy
)paren
id|t-&gt;u.target
op_member_access_from_pointer
id|destroy
c_func
(paren
id|t-&gt;data
comma
id|t-&gt;target_size
)paren
suffix:semicolon
id|module_put
c_func
(paren
id|t-&gt;u.target-&gt;me
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_inline
r_int
DECL|function|ebt_check_entry
id|ebt_check_entry
c_func
(paren
r_struct
id|ebt_entry
op_star
id|e
comma
r_struct
id|ebt_table_info
op_star
id|newinfo
comma
r_const
r_char
op_star
id|name
comma
r_int
r_int
op_star
id|cnt
comma
r_int
r_int
id|valid_hooks
comma
r_struct
id|ebt_cl_stack
op_star
id|cl_s
comma
r_int
r_int
id|udc_cnt
)paren
(brace
r_struct
id|ebt_entry_target
op_star
id|t
suffix:semicolon
r_struct
id|ebt_target
op_star
id|target
suffix:semicolon
r_int
r_int
id|i
comma
id|j
comma
id|hook
op_assign
l_int|0
comma
id|hookmask
op_assign
l_int|0
suffix:semicolon
r_int
id|ret
suffix:semicolon
multiline_comment|/* don&squot;t mess with the struct ebt_entries */
r_if
c_cond
(paren
(paren
id|e-&gt;bitmask
op_amp
id|EBT_ENTRY_OR_ENTRIES
)paren
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|e-&gt;bitmask
op_amp
op_complement
id|EBT_F_MASK
)paren
(brace
id|BUGPRINT
c_func
(paren
l_string|&quot;Unknown flag for bitmask&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|e-&gt;invflags
op_amp
op_complement
id|EBT_INV_MASK
)paren
(brace
id|BUGPRINT
c_func
(paren
l_string|&quot;Unknown flag for inv bitmask&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|e-&gt;bitmask
op_amp
id|EBT_NOPROTO
)paren
op_logical_and
(paren
id|e-&gt;bitmask
op_amp
id|EBT_802_3
)paren
)paren
(brace
id|BUGPRINT
c_func
(paren
l_string|&quot;NOPROTO &amp; 802_3 not allowed&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* what hook do we belong to? */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NF_BR_NUMHOOKS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|valid_hooks
op_amp
(paren
l_int|1
op_lshift
id|i
)paren
)paren
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
(paren
r_char
op_star
)paren
id|newinfo-&gt;hook_entry
(braket
id|i
)braket
OL
(paren
r_char
op_star
)paren
id|e
)paren
id|hook
op_assign
id|i
suffix:semicolon
r_else
r_break
suffix:semicolon
)brace
multiline_comment|/* (1 &lt;&lt; NF_BR_NUMHOOKS) tells the check functions the rule is on&n;&t;   a base chain */
r_if
c_cond
(paren
id|i
OL
id|NF_BR_NUMHOOKS
)paren
id|hookmask
op_assign
(paren
l_int|1
op_lshift
id|hook
)paren
op_or
(paren
l_int|1
op_lshift
id|NF_BR_NUMHOOKS
)paren
suffix:semicolon
r_else
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|udc_cnt
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
(paren
r_char
op_star
)paren
(paren
id|cl_s
(braket
id|i
)braket
dot
id|cs.chaininfo
)paren
OG
(paren
r_char
op_star
)paren
id|e
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
l_int|0
)paren
id|hookmask
op_assign
(paren
l_int|1
op_lshift
id|hook
)paren
op_or
(paren
l_int|1
op_lshift
id|NF_BR_NUMHOOKS
)paren
suffix:semicolon
r_else
id|hookmask
op_assign
id|cl_s
(braket
id|i
op_minus
l_int|1
)braket
dot
id|hookmask
suffix:semicolon
)brace
id|i
op_assign
l_int|0
suffix:semicolon
id|ret
op_assign
id|EBT_MATCH_ITERATE
c_func
(paren
id|e
comma
id|ebt_check_match
comma
id|e
comma
id|name
comma
id|hookmask
comma
op_amp
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
l_int|0
)paren
r_goto
id|cleanup_matches
suffix:semicolon
id|j
op_assign
l_int|0
suffix:semicolon
id|ret
op_assign
id|EBT_WATCHER_ITERATE
c_func
(paren
id|e
comma
id|ebt_check_watcher
comma
id|e
comma
id|name
comma
id|hookmask
comma
op_amp
id|j
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
l_int|0
)paren
r_goto
id|cleanup_watchers
suffix:semicolon
id|t
op_assign
(paren
r_struct
id|ebt_entry_target
op_star
)paren
(paren
(paren
(paren
r_char
op_star
)paren
id|e
)paren
op_plus
id|e-&gt;target_offset
)paren
suffix:semicolon
id|target
op_assign
id|find_target_lock
c_func
(paren
id|t-&gt;u.name
comma
op_amp
id|ret
comma
op_amp
id|ebt_mutex
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|target
)paren
r_goto
id|cleanup_watchers
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|try_module_get
c_func
(paren
id|target-&gt;me
)paren
)paren
(brace
id|up
c_func
(paren
op_amp
id|ebt_mutex
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|ENOENT
suffix:semicolon
r_goto
id|cleanup_watchers
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|ebt_mutex
)paren
suffix:semicolon
id|t-&gt;u.target
op_assign
id|target
suffix:semicolon
r_if
c_cond
(paren
id|t-&gt;u.target
op_eq
op_amp
id|ebt_standard_target
)paren
(brace
r_if
c_cond
(paren
id|e-&gt;target_offset
op_plus
r_sizeof
(paren
r_struct
id|ebt_standard_target
)paren
OG
id|e-&gt;next_offset
)paren
(brace
id|BUGPRINT
c_func
(paren
l_string|&quot;Standard target size too big&bslash;n&quot;
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
id|cleanup_watchers
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
(paren
r_struct
id|ebt_standard_target
op_star
)paren
id|t
)paren
op_member_access_from_pointer
id|verdict
OL
op_minus
id|NUM_STANDARD_TARGETS
)paren
(brace
id|BUGPRINT
c_func
(paren
l_string|&quot;Invalid standard target&bslash;n&quot;
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
id|cleanup_watchers
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
(paren
id|e-&gt;target_offset
op_plus
id|t-&gt;target_size
op_plus
r_sizeof
(paren
r_struct
id|ebt_entry_target
)paren
OG
id|e-&gt;next_offset
)paren
op_logical_or
(paren
id|t-&gt;u.target-&gt;check
op_logical_and
id|t-&gt;u.target
op_member_access_from_pointer
id|check
c_func
(paren
id|name
comma
id|hookmask
comma
id|e
comma
id|t-&gt;data
comma
id|t-&gt;target_size
)paren
op_ne
l_int|0
)paren
)paren
(brace
id|module_put
c_func
(paren
id|t-&gt;u.target-&gt;me
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
id|cleanup_watchers
suffix:semicolon
)brace
(paren
op_star
id|cnt
)paren
op_increment
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|cleanup_watchers
suffix:colon
id|EBT_WATCHER_ITERATE
c_func
(paren
id|e
comma
id|ebt_cleanup_watcher
comma
op_amp
id|j
)paren
suffix:semicolon
id|cleanup_matches
suffix:colon
id|EBT_MATCH_ITERATE
c_func
(paren
id|e
comma
id|ebt_cleanup_match
comma
op_amp
id|i
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * checks for loops and sets the hook mask for udc&n; * the hook mask for udc tells us from which base chains the udc can be&n; * accessed. This mask is a parameter to the check() functions of the extensions&n; */
DECL|function|check_chainloops
r_static
r_int
id|check_chainloops
c_func
(paren
r_struct
id|ebt_entries
op_star
id|chain
comma
r_struct
id|ebt_cl_stack
op_star
id|cl_s
comma
r_int
r_int
id|udc_cnt
comma
r_int
r_int
id|hooknr
comma
r_char
op_star
id|base
)paren
(brace
r_int
id|i
comma
id|chain_nr
op_assign
op_minus
l_int|1
comma
id|pos
op_assign
l_int|0
comma
id|nentries
op_assign
id|chain-&gt;nentries
comma
id|verdict
suffix:semicolon
r_struct
id|ebt_entry
op_star
id|e
op_assign
(paren
r_struct
id|ebt_entry
op_star
)paren
id|chain-&gt;data
suffix:semicolon
r_struct
id|ebt_entry_target
op_star
id|t
suffix:semicolon
r_while
c_loop
(paren
id|pos
OL
id|nentries
op_logical_or
id|chain_nr
op_ne
op_minus
l_int|1
)paren
(brace
multiline_comment|/* end of udc, go back one &squot;recursion&squot; step */
r_if
c_cond
(paren
id|pos
op_eq
id|nentries
)paren
(brace
multiline_comment|/* put back values of the time when this chain was called */
id|e
op_assign
id|cl_s
(braket
id|chain_nr
)braket
dot
id|cs.e
suffix:semicolon
r_if
c_cond
(paren
id|cl_s
(braket
id|chain_nr
)braket
dot
id|from
op_ne
op_minus
l_int|1
)paren
id|nentries
op_assign
id|cl_s
(braket
id|cl_s
(braket
id|chain_nr
)braket
dot
id|from
)braket
dot
id|cs.chaininfo-&gt;nentries
suffix:semicolon
r_else
id|nentries
op_assign
id|chain-&gt;nentries
suffix:semicolon
id|pos
op_assign
id|cl_s
(braket
id|chain_nr
)braket
dot
id|cs.n
suffix:semicolon
multiline_comment|/* make sure we won&squot;t see a loop that isn&squot;t one */
id|cl_s
(braket
id|chain_nr
)braket
dot
id|cs.n
op_assign
l_int|0
suffix:semicolon
id|chain_nr
op_assign
id|cl_s
(braket
id|chain_nr
)braket
dot
id|from
suffix:semicolon
r_if
c_cond
(paren
id|pos
op_eq
id|nentries
)paren
r_continue
suffix:semicolon
)brace
id|t
op_assign
(paren
r_struct
id|ebt_entry_target
op_star
)paren
(paren
(paren
(paren
r_char
op_star
)paren
id|e
)paren
op_plus
id|e-&gt;target_offset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|t-&gt;u.name
comma
id|EBT_STANDARD_TARGET
)paren
)paren
r_goto
id|letscontinue
suffix:semicolon
r_if
c_cond
(paren
id|e-&gt;target_offset
op_plus
r_sizeof
(paren
r_struct
id|ebt_standard_target
)paren
OG
id|e-&gt;next_offset
)paren
(brace
id|BUGPRINT
c_func
(paren
l_string|&quot;Standard target size too big&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|verdict
op_assign
(paren
(paren
r_struct
id|ebt_standard_target
op_star
)paren
id|t
)paren
op_member_access_from_pointer
id|verdict
suffix:semicolon
r_if
c_cond
(paren
id|verdict
op_ge
l_int|0
)paren
(brace
multiline_comment|/* jump to another chain */
r_struct
id|ebt_entries
op_star
id|hlp2
op_assign
(paren
r_struct
id|ebt_entries
op_star
)paren
(paren
id|base
op_plus
id|verdict
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|udc_cnt
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|hlp2
op_eq
id|cl_s
(braket
id|i
)braket
dot
id|cs.chaininfo
)paren
r_break
suffix:semicolon
multiline_comment|/* bad destination or loop */
r_if
c_cond
(paren
id|i
op_eq
id|udc_cnt
)paren
(brace
id|BUGPRINT
c_func
(paren
l_string|&quot;bad destination&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cl_s
(braket
id|i
)braket
dot
id|cs.n
)paren
(brace
id|BUGPRINT
c_func
(paren
l_string|&quot;loop&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* this can&squot;t be 0, so the above test is correct */
id|cl_s
(braket
id|i
)braket
dot
id|cs.n
op_assign
id|pos
op_plus
l_int|1
suffix:semicolon
id|pos
op_assign
l_int|0
suffix:semicolon
id|cl_s
(braket
id|i
)braket
dot
id|cs.e
op_assign
(paren
(paren
r_void
op_star
)paren
id|e
op_plus
id|e-&gt;next_offset
)paren
suffix:semicolon
id|e
op_assign
(paren
r_struct
id|ebt_entry
op_star
)paren
(paren
id|hlp2-&gt;data
)paren
suffix:semicolon
id|nentries
op_assign
id|hlp2-&gt;nentries
suffix:semicolon
id|cl_s
(braket
id|i
)braket
dot
id|from
op_assign
id|chain_nr
suffix:semicolon
id|chain_nr
op_assign
id|i
suffix:semicolon
multiline_comment|/* this udc is accessible from the base chain for hooknr */
id|cl_s
(braket
id|i
)braket
dot
id|hookmask
op_or_assign
(paren
l_int|1
op_lshift
id|hooknr
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|letscontinue
suffix:colon
id|e
op_assign
(paren
r_void
op_star
)paren
id|e
op_plus
id|e-&gt;next_offset
suffix:semicolon
id|pos
op_increment
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* do the parsing of the table/chains/entries/matches/watchers/targets, heh */
DECL|function|translate_table
r_static
r_int
id|translate_table
c_func
(paren
r_struct
id|ebt_replace
op_star
id|repl
comma
r_struct
id|ebt_table_info
op_star
id|newinfo
)paren
(brace
r_int
r_int
id|i
comma
id|j
comma
id|k
comma
id|udc_cnt
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_struct
id|ebt_cl_stack
op_star
id|cl_s
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* used in the checking for chain loops */
id|i
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|i
OL
id|NF_BR_NUMHOOKS
op_logical_and
op_logical_neg
(paren
id|repl-&gt;valid_hooks
op_amp
(paren
l_int|1
op_lshift
id|i
)paren
)paren
)paren
id|i
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
id|NF_BR_NUMHOOKS
)paren
(brace
id|BUGPRINT
c_func
(paren
l_string|&quot;No valid hooks specified&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|repl-&gt;hook_entry
(braket
id|i
)braket
op_ne
(paren
r_struct
id|ebt_entries
op_star
)paren
id|repl-&gt;entries
)paren
(brace
id|BUGPRINT
c_func
(paren
l_string|&quot;Chains don&squot;t start at beginning&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* make sure chains are ordered after each other in same order&n;&t;   as their corresponding hooks */
r_for
c_loop
(paren
id|j
op_assign
id|i
op_plus
l_int|1
suffix:semicolon
id|j
OL
id|NF_BR_NUMHOOKS
suffix:semicolon
id|j
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|repl-&gt;valid_hooks
op_amp
(paren
l_int|1
op_lshift
id|j
)paren
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|repl-&gt;hook_entry
(braket
id|j
)braket
op_le
id|repl-&gt;hook_entry
(braket
id|i
)braket
)paren
(brace
id|BUGPRINT
c_func
(paren
l_string|&quot;Hook order must be followed&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|i
op_assign
id|j
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NF_BR_NUMHOOKS
suffix:semicolon
id|i
op_increment
)paren
id|newinfo-&gt;hook_entry
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
id|newinfo-&gt;entries_size
op_assign
id|repl-&gt;entries_size
suffix:semicolon
id|newinfo-&gt;nentries
op_assign
id|repl-&gt;nentries
suffix:semicolon
multiline_comment|/* do some early checkings and initialize some things */
id|i
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* holds the expected nr. of entries for the chain */
id|j
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* holds the up to now counted entries for the chain */
id|k
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* holds the total nr. of entries, should equal&n;&t;          newinfo-&gt;nentries afterwards */
id|udc_cnt
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* will hold the nr. of user defined chains (udc) */
id|ret
op_assign
id|EBT_ENTRY_ITERATE
c_func
(paren
id|newinfo-&gt;entries
comma
id|newinfo-&gt;entries_size
comma
id|ebt_check_entry_size_and_hooks
comma
id|newinfo
comma
id|repl-&gt;entries
comma
id|repl-&gt;entries
op_plus
id|repl-&gt;entries_size
comma
id|repl-&gt;hook_entry
comma
op_amp
id|i
comma
op_amp
id|j
comma
op_amp
id|k
comma
op_amp
id|udc_cnt
comma
id|repl-&gt;valid_hooks
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
l_int|0
)paren
r_return
id|ret
suffix:semicolon
r_if
c_cond
(paren
id|i
op_ne
id|j
)paren
(brace
id|BUGPRINT
c_func
(paren
l_string|&quot;nentries does not equal the nr of entries in the &quot;
l_string|&quot;(last) chain&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|k
op_ne
id|newinfo-&gt;nentries
)paren
(brace
id|BUGPRINT
c_func
(paren
l_string|&quot;Total nentries is wrong&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* check if all valid hooks have a chain */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NF_BR_NUMHOOKS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|newinfo-&gt;hook_entry
(braket
id|i
)braket
op_eq
l_int|NULL
op_logical_and
(paren
id|repl-&gt;valid_hooks
op_amp
(paren
l_int|1
op_lshift
id|i
)paren
)paren
)paren
(brace
id|BUGPRINT
c_func
(paren
l_string|&quot;Valid hook without chain&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
multiline_comment|/* get the location of the udc, put them in an array&n;&t;   while we&squot;re at it, allocate the chainstack */
r_if
c_cond
(paren
id|udc_cnt
)paren
(brace
multiline_comment|/* this will get free&squot;d in do_replace()/ebt_register_table()&n;&t;&t;   if an error occurs */
id|newinfo-&gt;chainstack
op_assign
(paren
r_struct
id|ebt_chainstack
op_star
op_star
)paren
id|vmalloc
c_func
(paren
id|NR_CPUS
op_star
r_sizeof
(paren
r_struct
id|ebt_chainstack
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|newinfo-&gt;chainstack
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_CPUS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|newinfo-&gt;chainstack
(braket
id|i
)braket
op_assign
id|vmalloc
c_func
(paren
id|udc_cnt
op_star
r_sizeof
(paren
r_struct
id|ebt_chainstack
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|newinfo-&gt;chainstack
(braket
id|i
)braket
)paren
(brace
r_while
c_loop
(paren
id|i
)paren
id|vfree
c_func
(paren
id|newinfo-&gt;chainstack
(braket
op_decrement
id|i
)braket
)paren
suffix:semicolon
id|vfree
c_func
(paren
id|newinfo-&gt;chainstack
)paren
suffix:semicolon
id|newinfo-&gt;chainstack
op_assign
l_int|NULL
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
)brace
id|cl_s
op_assign
(paren
r_struct
id|ebt_cl_stack
op_star
)paren
id|vmalloc
c_func
(paren
id|udc_cnt
op_star
r_sizeof
(paren
r_struct
id|ebt_cl_stack
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cl_s
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|i
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* the i&squot;th udc */
id|EBT_ENTRY_ITERATE
c_func
(paren
id|newinfo-&gt;entries
comma
id|newinfo-&gt;entries_size
comma
id|ebt_get_udc_positions
comma
id|newinfo
comma
id|repl-&gt;hook_entry
comma
op_amp
id|i
comma
id|repl-&gt;valid_hooks
comma
id|cl_s
)paren
suffix:semicolon
multiline_comment|/* sanity check */
r_if
c_cond
(paren
id|i
op_ne
id|udc_cnt
)paren
(brace
id|BUGPRINT
c_func
(paren
l_string|&quot;i != udc_cnt&bslash;n&quot;
)paren
suffix:semicolon
id|vfree
c_func
(paren
id|cl_s
)paren
suffix:semicolon
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
)brace
multiline_comment|/* Check for loops */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NF_BR_NUMHOOKS
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|repl-&gt;valid_hooks
op_amp
(paren
l_int|1
op_lshift
id|i
)paren
)paren
r_if
c_cond
(paren
id|check_chainloops
c_func
(paren
id|newinfo-&gt;hook_entry
(braket
id|i
)braket
comma
id|cl_s
comma
id|udc_cnt
comma
id|i
comma
id|newinfo-&gt;entries
)paren
)paren
(brace
r_if
c_cond
(paren
id|cl_s
)paren
id|vfree
c_func
(paren
id|cl_s
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* we now know the following (along with E=mc&#xfffd;):&n;&t;   - the nr of entries in each chain is right&n;&t;   - the size of the allocated space is right&n;&t;   - all valid hooks have a corresponding chain&n;&t;   - there are no loops&n;&t;   - wrong data can still be on the level of a single entry&n;&t;   - could be there are jumps to places that are not the&n;&t;     beginning of a chain. This can only occur in chains that&n;&t;     are not accessible from any base chains, so we don&squot;t care. */
multiline_comment|/* used to know what we need to clean up if something goes wrong */
id|i
op_assign
l_int|0
suffix:semicolon
id|ret
op_assign
id|EBT_ENTRY_ITERATE
c_func
(paren
id|newinfo-&gt;entries
comma
id|newinfo-&gt;entries_size
comma
id|ebt_check_entry
comma
id|newinfo
comma
id|repl-&gt;name
comma
op_amp
id|i
comma
id|repl-&gt;valid_hooks
comma
id|cl_s
comma
id|udc_cnt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
l_int|0
)paren
(brace
id|EBT_ENTRY_ITERATE
c_func
(paren
id|newinfo-&gt;entries
comma
id|newinfo-&gt;entries_size
comma
id|ebt_cleanup_entry
comma
op_amp
id|i
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cl_s
)paren
id|vfree
c_func
(paren
id|cl_s
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* called under write_lock */
DECL|function|get_counters
r_static
r_void
id|get_counters
c_func
(paren
r_struct
id|ebt_counter
op_star
id|oldcounters
comma
r_struct
id|ebt_counter
op_star
id|counters
comma
r_int
r_int
id|nentries
)paren
(brace
r_int
id|i
comma
id|cpu
suffix:semicolon
r_struct
id|ebt_counter
op_star
id|counter_base
suffix:semicolon
multiline_comment|/* counters of cpu 0 */
id|memcpy
c_func
(paren
id|counters
comma
id|oldcounters
comma
r_sizeof
(paren
r_struct
id|ebt_counter
)paren
op_star
id|nentries
)paren
suffix:semicolon
multiline_comment|/* add other counters to those of cpu 0 */
r_for
c_loop
(paren
id|cpu
op_assign
l_int|1
suffix:semicolon
id|cpu
OL
id|NR_CPUS
suffix:semicolon
id|cpu
op_increment
)paren
(brace
id|counter_base
op_assign
id|COUNTER_BASE
c_func
(paren
id|oldcounters
comma
id|nentries
comma
id|cpu
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nentries
suffix:semicolon
id|i
op_increment
)paren
(brace
id|counters
(braket
id|i
)braket
dot
id|pcnt
op_add_assign
id|counter_base
(braket
id|i
)braket
dot
id|pcnt
suffix:semicolon
id|counters
(braket
id|i
)braket
dot
id|bcnt
op_add_assign
id|counter_base
(braket
id|i
)braket
dot
id|bcnt
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* replace the table */
DECL|function|do_replace
r_static
r_int
id|do_replace
c_func
(paren
r_void
id|__user
op_star
id|user
comma
r_int
r_int
id|len
)paren
(brace
r_int
id|ret
comma
id|i
comma
id|countersize
suffix:semicolon
r_struct
id|ebt_table_info
op_star
id|newinfo
suffix:semicolon
r_struct
id|ebt_replace
id|tmp
suffix:semicolon
r_struct
id|ebt_table
op_star
id|t
suffix:semicolon
r_struct
id|ebt_counter
op_star
id|counterstmp
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* used to be able to unlock earlier */
r_struct
id|ebt_table_info
op_star
id|table
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|tmp
comma
id|user
comma
r_sizeof
(paren
id|tmp
)paren
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|len
op_ne
r_sizeof
(paren
id|tmp
)paren
op_plus
id|tmp.entries_size
)paren
(brace
id|BUGPRINT
c_func
(paren
l_string|&quot;Wrong len argument&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tmp.entries_size
op_eq
l_int|0
)paren
(brace
id|BUGPRINT
c_func
(paren
l_string|&quot;Entries_size never zero&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|countersize
op_assign
id|COUNTER_OFFSET
c_func
(paren
id|tmp.nentries
)paren
op_star
id|NR_CPUS
suffix:semicolon
id|newinfo
op_assign
(paren
r_struct
id|ebt_table_info
op_star
)paren
id|vmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|ebt_table_info
)paren
op_plus
id|countersize
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|newinfo
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
id|countersize
)paren
id|memset
c_func
(paren
id|newinfo-&gt;counters
comma
l_int|0
comma
id|countersize
)paren
suffix:semicolon
id|newinfo-&gt;entries
op_assign
(paren
r_char
op_star
)paren
id|vmalloc
c_func
(paren
id|tmp.entries_size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|newinfo-&gt;entries
)paren
(brace
id|ret
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|free_newinfo
suffix:semicolon
)brace
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|newinfo-&gt;entries
comma
id|tmp.entries
comma
id|tmp.entries_size
)paren
op_ne
l_int|0
)paren
(brace
id|BUGPRINT
c_func
(paren
l_string|&quot;Couldn&squot;t copy entries from userspace&bslash;n&quot;
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
id|free_entries
suffix:semicolon
)brace
multiline_comment|/* the user wants counters back&n;&t;   the check on the size is done later, when we have the lock */
r_if
c_cond
(paren
id|tmp.num_counters
)paren
(brace
id|counterstmp
op_assign
(paren
r_struct
id|ebt_counter
op_star
)paren
id|vmalloc
c_func
(paren
id|tmp.num_counters
op_star
r_sizeof
(paren
r_struct
id|ebt_counter
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|counterstmp
)paren
(brace
id|ret
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|free_entries
suffix:semicolon
)brace
)brace
r_else
id|counterstmp
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* this can get initialized by translate_table() */
id|newinfo-&gt;chainstack
op_assign
l_int|NULL
suffix:semicolon
id|ret
op_assign
id|translate_table
c_func
(paren
op_amp
id|tmp
comma
id|newinfo
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
l_int|0
)paren
r_goto
id|free_counterstmp
suffix:semicolon
id|t
op_assign
id|find_table_lock
c_func
(paren
id|tmp.name
comma
op_amp
id|ret
comma
op_amp
id|ebt_mutex
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|t
)paren
(brace
id|ret
op_assign
op_minus
id|ENOENT
suffix:semicolon
r_goto
id|free_iterate
suffix:semicolon
)brace
multiline_comment|/* the table doesn&squot;t like it */
r_if
c_cond
(paren
id|t-&gt;check
op_logical_and
(paren
id|ret
op_assign
id|t
op_member_access_from_pointer
id|check
c_func
(paren
id|newinfo
comma
id|tmp.valid_hooks
)paren
)paren
)paren
r_goto
id|free_unlock
suffix:semicolon
r_if
c_cond
(paren
id|tmp.num_counters
op_logical_and
id|tmp.num_counters
op_ne
id|t
op_member_access_from_pointer
r_private
op_member_access_from_pointer
id|nentries
)paren
(brace
id|BUGPRINT
c_func
(paren
l_string|&quot;Wrong nr. of counters requested&bslash;n&quot;
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|free_unlock
suffix:semicolon
)brace
multiline_comment|/* we have the mutex lock, so no danger in reading this pointer */
id|table
op_assign
id|t
op_member_access_from_pointer
r_private
suffix:semicolon
multiline_comment|/* make sure the table can only be rmmod&squot;ed if it contains no rules */
r_if
c_cond
(paren
op_logical_neg
id|table-&gt;nentries
op_logical_and
id|newinfo-&gt;nentries
op_logical_and
op_logical_neg
id|try_module_get
c_func
(paren
id|t-&gt;me
)paren
)paren
(brace
id|ret
op_assign
op_minus
id|ENOENT
suffix:semicolon
r_goto
id|free_unlock
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|table-&gt;nentries
op_logical_and
op_logical_neg
id|newinfo-&gt;nentries
)paren
id|module_put
c_func
(paren
id|t-&gt;me
)paren
suffix:semicolon
multiline_comment|/* we need an atomic snapshot of the counters */
id|write_lock_bh
c_func
(paren
op_amp
id|t-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp.num_counters
)paren
id|get_counters
c_func
(paren
id|t
op_member_access_from_pointer
r_private
op_member_access_from_pointer
id|counters
comma
id|counterstmp
comma
id|t
op_member_access_from_pointer
r_private
op_member_access_from_pointer
id|nentries
)paren
suffix:semicolon
id|t
op_member_access_from_pointer
r_private
op_assign
id|newinfo
suffix:semicolon
id|write_unlock_bh
c_func
(paren
op_amp
id|t-&gt;lock
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|ebt_mutex
)paren
suffix:semicolon
multiline_comment|/* so, a user can change the chains while having messed up her counter&n;&t;   allocation. Only reason why this is done is because this way the lock&n;&t;   is held only once, while this doesn&squot;t bring the kernel into a&n;&t;   dangerous state. */
r_if
c_cond
(paren
id|tmp.num_counters
op_logical_and
id|copy_to_user
c_func
(paren
id|tmp.counters
comma
id|counterstmp
comma
id|tmp.num_counters
op_star
r_sizeof
(paren
r_struct
id|ebt_counter
)paren
)paren
)paren
(brace
id|BUGPRINT
c_func
(paren
l_string|&quot;Couldn&squot;t copy counters to userspace&bslash;n&quot;
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
)brace
r_else
id|ret
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* decrease module count and free resources */
id|EBT_ENTRY_ITERATE
c_func
(paren
id|table-&gt;entries
comma
id|table-&gt;entries_size
comma
id|ebt_cleanup_entry
comma
l_int|NULL
)paren
suffix:semicolon
id|vfree
c_func
(paren
id|table-&gt;entries
)paren
suffix:semicolon
r_if
c_cond
(paren
id|table-&gt;chainstack
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_CPUS
suffix:semicolon
id|i
op_increment
)paren
id|vfree
c_func
(paren
id|table-&gt;chainstack
(braket
id|i
)braket
)paren
suffix:semicolon
id|vfree
c_func
(paren
id|table-&gt;chainstack
)paren
suffix:semicolon
)brace
id|vfree
c_func
(paren
id|table
)paren
suffix:semicolon
r_if
c_cond
(paren
id|counterstmp
)paren
id|vfree
c_func
(paren
id|counterstmp
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
id|free_unlock
suffix:colon
id|up
c_func
(paren
op_amp
id|ebt_mutex
)paren
suffix:semicolon
id|free_iterate
suffix:colon
id|EBT_ENTRY_ITERATE
c_func
(paren
id|newinfo-&gt;entries
comma
id|newinfo-&gt;entries_size
comma
id|ebt_cleanup_entry
comma
l_int|NULL
)paren
suffix:semicolon
id|free_counterstmp
suffix:colon
r_if
c_cond
(paren
id|counterstmp
)paren
id|vfree
c_func
(paren
id|counterstmp
)paren
suffix:semicolon
multiline_comment|/* can be initialized in translate_table() */
r_if
c_cond
(paren
id|newinfo-&gt;chainstack
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_CPUS
suffix:semicolon
id|i
op_increment
)paren
id|vfree
c_func
(paren
id|newinfo-&gt;chainstack
(braket
id|i
)braket
)paren
suffix:semicolon
id|vfree
c_func
(paren
id|newinfo-&gt;chainstack
)paren
suffix:semicolon
)brace
id|free_entries
suffix:colon
r_if
c_cond
(paren
id|newinfo-&gt;entries
)paren
id|vfree
c_func
(paren
id|newinfo-&gt;entries
)paren
suffix:semicolon
id|free_newinfo
suffix:colon
r_if
c_cond
(paren
id|newinfo
)paren
id|vfree
c_func
(paren
id|newinfo
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|ebt_register_target
r_int
id|ebt_register_target
c_func
(paren
r_struct
id|ebt_target
op_star
id|target
)paren
(brace
r_int
id|ret
suffix:semicolon
id|ret
op_assign
id|down_interruptible
c_func
(paren
op_amp
id|ebt_mutex
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
l_int|0
)paren
r_return
id|ret
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list_named_insert
c_func
(paren
op_amp
id|ebt_targets
comma
id|target
)paren
)paren
(brace
id|up
c_func
(paren
op_amp
id|ebt_mutex
)paren
suffix:semicolon
r_return
op_minus
id|EEXIST
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|ebt_mutex
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ebt_unregister_target
r_void
id|ebt_unregister_target
c_func
(paren
r_struct
id|ebt_target
op_star
id|target
)paren
(brace
id|down
c_func
(paren
op_amp
id|ebt_mutex
)paren
suffix:semicolon
id|LIST_DELETE
c_func
(paren
op_amp
id|ebt_targets
comma
id|target
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|ebt_mutex
)paren
suffix:semicolon
)brace
DECL|function|ebt_register_match
r_int
id|ebt_register_match
c_func
(paren
r_struct
id|ebt_match
op_star
id|match
)paren
(brace
r_int
id|ret
suffix:semicolon
id|ret
op_assign
id|down_interruptible
c_func
(paren
op_amp
id|ebt_mutex
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
l_int|0
)paren
r_return
id|ret
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list_named_insert
c_func
(paren
op_amp
id|ebt_matches
comma
id|match
)paren
)paren
(brace
id|up
c_func
(paren
op_amp
id|ebt_mutex
)paren
suffix:semicolon
r_return
op_minus
id|EEXIST
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|ebt_mutex
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ebt_unregister_match
r_void
id|ebt_unregister_match
c_func
(paren
r_struct
id|ebt_match
op_star
id|match
)paren
(brace
id|down
c_func
(paren
op_amp
id|ebt_mutex
)paren
suffix:semicolon
id|LIST_DELETE
c_func
(paren
op_amp
id|ebt_matches
comma
id|match
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|ebt_mutex
)paren
suffix:semicolon
)brace
DECL|function|ebt_register_watcher
r_int
id|ebt_register_watcher
c_func
(paren
r_struct
id|ebt_watcher
op_star
id|watcher
)paren
(brace
r_int
id|ret
suffix:semicolon
id|ret
op_assign
id|down_interruptible
c_func
(paren
op_amp
id|ebt_mutex
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
l_int|0
)paren
r_return
id|ret
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list_named_insert
c_func
(paren
op_amp
id|ebt_watchers
comma
id|watcher
)paren
)paren
(brace
id|up
c_func
(paren
op_amp
id|ebt_mutex
)paren
suffix:semicolon
r_return
op_minus
id|EEXIST
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|ebt_mutex
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ebt_unregister_watcher
r_void
id|ebt_unregister_watcher
c_func
(paren
r_struct
id|ebt_watcher
op_star
id|watcher
)paren
(brace
id|down
c_func
(paren
op_amp
id|ebt_mutex
)paren
suffix:semicolon
id|LIST_DELETE
c_func
(paren
op_amp
id|ebt_watchers
comma
id|watcher
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|ebt_mutex
)paren
suffix:semicolon
)brace
DECL|function|ebt_register_table
r_int
id|ebt_register_table
c_func
(paren
r_struct
id|ebt_table
op_star
id|table
)paren
(brace
r_struct
id|ebt_table_info
op_star
id|newinfo
suffix:semicolon
r_int
id|ret
comma
id|i
comma
id|countersize
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|table
op_logical_or
op_logical_neg
id|table-&gt;table
op_logical_or
op_logical_neg
id|table-&gt;table-&gt;entries
op_logical_or
id|table-&gt;table-&gt;entries_size
op_eq
l_int|0
op_logical_or
id|table-&gt;table-&gt;counters
op_logical_or
id|table
op_member_access_from_pointer
r_private
)paren
(brace
id|BUGPRINT
c_func
(paren
l_string|&quot;Bad table data for ebt_register_table!!!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|countersize
op_assign
id|COUNTER_OFFSET
c_func
(paren
id|table-&gt;table-&gt;nentries
)paren
op_star
id|NR_CPUS
suffix:semicolon
id|newinfo
op_assign
(paren
r_struct
id|ebt_table_info
op_star
)paren
id|vmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|ebt_table_info
)paren
op_plus
id|countersize
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|newinfo
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|newinfo-&gt;entries
op_assign
(paren
r_char
op_star
)paren
id|vmalloc
c_func
(paren
id|table-&gt;table-&gt;entries_size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|newinfo-&gt;entries
)paren
)paren
r_goto
id|free_newinfo
suffix:semicolon
id|memcpy
c_func
(paren
id|newinfo-&gt;entries
comma
id|table-&gt;table-&gt;entries
comma
id|table-&gt;table-&gt;entries_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|countersize
)paren
id|memset
c_func
(paren
id|newinfo-&gt;counters
comma
l_int|0
comma
id|countersize
)paren
suffix:semicolon
multiline_comment|/* fill in newinfo and parse the entries */
id|newinfo-&gt;chainstack
op_assign
l_int|NULL
suffix:semicolon
id|ret
op_assign
id|translate_table
c_func
(paren
id|table-&gt;table
comma
id|newinfo
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
l_int|0
)paren
(brace
id|BUGPRINT
c_func
(paren
l_string|&quot;Translate_table failed&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|free_chainstack
suffix:semicolon
)brace
r_if
c_cond
(paren
id|table-&gt;check
op_logical_and
id|table
op_member_access_from_pointer
id|check
c_func
(paren
id|newinfo
comma
id|table-&gt;valid_hooks
)paren
)paren
(brace
id|BUGPRINT
c_func
(paren
l_string|&quot;The table doesn&squot;t like its own initial data, lol&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|table
op_member_access_from_pointer
r_private
op_assign
id|newinfo
suffix:semicolon
id|rwlock_init
c_func
(paren
op_amp
id|table-&gt;lock
)paren
suffix:semicolon
id|ret
op_assign
id|down_interruptible
c_func
(paren
op_amp
id|ebt_mutex
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
l_int|0
)paren
r_goto
id|free_chainstack
suffix:semicolon
r_if
c_cond
(paren
id|list_named_find
c_func
(paren
op_amp
id|ebt_tables
comma
id|table-&gt;name
)paren
)paren
(brace
id|ret
op_assign
op_minus
id|EEXIST
suffix:semicolon
id|BUGPRINT
c_func
(paren
l_string|&quot;Table name already exists&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|free_unlock
suffix:semicolon
)brace
multiline_comment|/* Hold a reference count if the chains aren&squot;t empty */
r_if
c_cond
(paren
id|newinfo-&gt;nentries
op_logical_and
op_logical_neg
id|try_module_get
c_func
(paren
id|table-&gt;me
)paren
)paren
(brace
id|ret
op_assign
op_minus
id|ENOENT
suffix:semicolon
r_goto
id|free_unlock
suffix:semicolon
)brace
id|list_prepend
c_func
(paren
op_amp
id|ebt_tables
comma
id|table
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|ebt_mutex
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|free_unlock
suffix:colon
id|up
c_func
(paren
op_amp
id|ebt_mutex
)paren
suffix:semicolon
id|free_chainstack
suffix:colon
r_if
c_cond
(paren
id|newinfo-&gt;chainstack
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_CPUS
suffix:semicolon
id|i
op_increment
)paren
id|vfree
c_func
(paren
id|newinfo-&gt;chainstack
(braket
id|i
)braket
)paren
suffix:semicolon
id|vfree
c_func
(paren
id|newinfo-&gt;chainstack
)paren
suffix:semicolon
)brace
id|vfree
c_func
(paren
id|newinfo-&gt;entries
)paren
suffix:semicolon
id|free_newinfo
suffix:colon
id|vfree
c_func
(paren
id|newinfo
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|ebt_unregister_table
r_void
id|ebt_unregister_table
c_func
(paren
r_struct
id|ebt_table
op_star
id|table
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|table
)paren
(brace
id|BUGPRINT
c_func
(paren
l_string|&quot;Request to unregister NULL table!!!&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|down
c_func
(paren
op_amp
id|ebt_mutex
)paren
suffix:semicolon
id|LIST_DELETE
c_func
(paren
op_amp
id|ebt_tables
comma
id|table
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|ebt_mutex
)paren
suffix:semicolon
r_if
c_cond
(paren
id|table
op_member_access_from_pointer
r_private
op_member_access_from_pointer
id|entries
)paren
id|vfree
c_func
(paren
id|table
op_member_access_from_pointer
r_private
op_member_access_from_pointer
id|entries
)paren
suffix:semicolon
r_if
c_cond
(paren
id|table
op_member_access_from_pointer
r_private
op_member_access_from_pointer
id|chainstack
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_CPUS
suffix:semicolon
id|i
op_increment
)paren
id|vfree
c_func
(paren
id|table
op_member_access_from_pointer
r_private
op_member_access_from_pointer
id|chainstack
(braket
id|i
)braket
)paren
suffix:semicolon
id|vfree
c_func
(paren
id|table
op_member_access_from_pointer
r_private
op_member_access_from_pointer
id|chainstack
)paren
suffix:semicolon
)brace
id|vfree
c_func
(paren
id|table
op_member_access_from_pointer
r_private
)paren
suffix:semicolon
)brace
multiline_comment|/* userspace just supplied us with counters */
DECL|function|update_counters
r_static
r_int
id|update_counters
c_func
(paren
r_void
id|__user
op_star
id|user
comma
r_int
r_int
id|len
)paren
(brace
r_int
id|i
comma
id|ret
suffix:semicolon
r_struct
id|ebt_counter
op_star
id|tmp
suffix:semicolon
r_struct
id|ebt_replace
id|hlp
suffix:semicolon
r_struct
id|ebt_table
op_star
id|t
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|hlp
comma
id|user
comma
r_sizeof
(paren
id|hlp
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|len
op_ne
r_sizeof
(paren
id|hlp
)paren
op_plus
id|hlp.num_counters
op_star
r_sizeof
(paren
r_struct
id|ebt_counter
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|hlp.num_counters
op_eq
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|tmp
op_assign
(paren
r_struct
id|ebt_counter
op_star
)paren
id|vmalloc
c_func
(paren
id|hlp.num_counters
op_star
r_sizeof
(paren
r_struct
id|ebt_counter
)paren
)paren
)paren
)paren
(brace
id|MEMPRINT
c_func
(paren
l_string|&quot;Update_counters &amp;&amp; nomemory&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|t
op_assign
id|find_table_lock
c_func
(paren
id|hlp.name
comma
op_amp
id|ret
comma
op_amp
id|ebt_mutex
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|t
)paren
r_goto
id|free_tmp
suffix:semicolon
r_if
c_cond
(paren
id|hlp.num_counters
op_ne
id|t
op_member_access_from_pointer
r_private
op_member_access_from_pointer
id|nentries
)paren
(brace
id|BUGPRINT
c_func
(paren
l_string|&quot;Wrong nr of counters&bslash;n&quot;
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|unlock_mutex
suffix:semicolon
)brace
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|tmp
comma
id|hlp.counters
comma
id|hlp.num_counters
op_star
r_sizeof
(paren
r_struct
id|ebt_counter
)paren
)paren
)paren
(brace
id|BUGPRINT
c_func
(paren
l_string|&quot;Updata_counters &amp;&amp; !cfu&bslash;n&quot;
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
id|unlock_mutex
suffix:semicolon
)brace
multiline_comment|/* we want an atomic add of the counters */
id|write_lock_bh
c_func
(paren
op_amp
id|t-&gt;lock
)paren
suffix:semicolon
multiline_comment|/* we add to the counters of the first cpu */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|hlp.num_counters
suffix:semicolon
id|i
op_increment
)paren
(brace
id|t
op_member_access_from_pointer
r_private
op_member_access_from_pointer
id|counters
(braket
id|i
)braket
dot
id|pcnt
op_add_assign
id|tmp
(braket
id|i
)braket
dot
id|pcnt
suffix:semicolon
id|t
op_member_access_from_pointer
r_private
op_member_access_from_pointer
id|counters
(braket
id|i
)braket
dot
id|bcnt
op_add_assign
id|tmp
(braket
id|i
)braket
dot
id|bcnt
suffix:semicolon
)brace
id|write_unlock_bh
c_func
(paren
op_amp
id|t-&gt;lock
)paren
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
id|unlock_mutex
suffix:colon
id|up
c_func
(paren
op_amp
id|ebt_mutex
)paren
suffix:semicolon
id|free_tmp
suffix:colon
id|vfree
c_func
(paren
id|tmp
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|ebt_make_matchname
r_static
r_inline
r_int
id|ebt_make_matchname
c_func
(paren
r_struct
id|ebt_entry_match
op_star
id|m
comma
r_char
op_star
id|base
comma
r_char
op_star
id|ubase
)paren
(brace
r_char
op_star
id|hlp
op_assign
id|ubase
op_minus
id|base
op_plus
(paren
r_char
op_star
)paren
id|m
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|hlp
comma
id|m-&gt;u.match-&gt;name
comma
id|EBT_FUNCTION_MAXNAMELEN
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ebt_make_watchername
r_static
r_inline
r_int
id|ebt_make_watchername
c_func
(paren
r_struct
id|ebt_entry_watcher
op_star
id|w
comma
r_char
op_star
id|base
comma
r_char
op_star
id|ubase
)paren
(brace
r_char
op_star
id|hlp
op_assign
id|ubase
op_minus
id|base
op_plus
(paren
r_char
op_star
)paren
id|w
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|hlp
comma
id|w-&gt;u.watcher-&gt;name
comma
id|EBT_FUNCTION_MAXNAMELEN
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ebt_make_names
r_static
r_inline
r_int
id|ebt_make_names
c_func
(paren
r_struct
id|ebt_entry
op_star
id|e
comma
r_char
op_star
id|base
comma
r_char
op_star
id|ubase
)paren
(brace
r_int
id|ret
suffix:semicolon
r_char
op_star
id|hlp
suffix:semicolon
r_struct
id|ebt_entry_target
op_star
id|t
suffix:semicolon
r_if
c_cond
(paren
(paren
id|e-&gt;bitmask
op_amp
id|EBT_ENTRY_OR_ENTRIES
)paren
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
id|hlp
op_assign
id|ubase
op_minus
id|base
op_plus
(paren
r_char
op_star
)paren
id|e
op_plus
id|e-&gt;target_offset
suffix:semicolon
id|t
op_assign
(paren
r_struct
id|ebt_entry_target
op_star
)paren
(paren
(paren
(paren
r_char
op_star
)paren
id|e
)paren
op_plus
id|e-&gt;target_offset
)paren
suffix:semicolon
id|ret
op_assign
id|EBT_MATCH_ITERATE
c_func
(paren
id|e
comma
id|ebt_make_matchname
comma
id|base
comma
id|ubase
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
l_int|0
)paren
r_return
id|ret
suffix:semicolon
id|ret
op_assign
id|EBT_WATCHER_ITERATE
c_func
(paren
id|e
comma
id|ebt_make_watchername
comma
id|base
comma
id|ubase
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
l_int|0
)paren
r_return
id|ret
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|hlp
comma
id|t-&gt;u.target-&gt;name
comma
id|EBT_FUNCTION_MAXNAMELEN
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* called with ebt_mutex down */
DECL|function|copy_everything_to_user
r_static
r_int
id|copy_everything_to_user
c_func
(paren
r_struct
id|ebt_table
op_star
id|t
comma
r_void
id|__user
op_star
id|user
comma
r_int
op_star
id|len
comma
r_int
id|cmd
)paren
(brace
r_struct
id|ebt_replace
id|tmp
suffix:semicolon
r_struct
id|ebt_counter
op_star
id|counterstmp
comma
op_star
id|oldcounters
suffix:semicolon
r_int
r_int
id|entries_size
comma
id|nentries
suffix:semicolon
r_char
op_star
id|entries
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_eq
id|EBT_SO_GET_ENTRIES
)paren
(brace
id|entries_size
op_assign
id|t
op_member_access_from_pointer
r_private
op_member_access_from_pointer
id|entries_size
suffix:semicolon
id|nentries
op_assign
id|t
op_member_access_from_pointer
r_private
op_member_access_from_pointer
id|nentries
suffix:semicolon
id|entries
op_assign
id|t
op_member_access_from_pointer
r_private
op_member_access_from_pointer
id|entries
suffix:semicolon
id|oldcounters
op_assign
id|t
op_member_access_from_pointer
r_private
op_member_access_from_pointer
id|counters
suffix:semicolon
)brace
r_else
(brace
id|entries_size
op_assign
id|t-&gt;table-&gt;entries_size
suffix:semicolon
id|nentries
op_assign
id|t-&gt;table-&gt;nentries
suffix:semicolon
id|entries
op_assign
id|t-&gt;table-&gt;entries
suffix:semicolon
id|oldcounters
op_assign
id|t-&gt;table-&gt;counters
suffix:semicolon
)brace
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|tmp
comma
id|user
comma
r_sizeof
(paren
id|tmp
)paren
)paren
)paren
(brace
id|BUGPRINT
c_func
(paren
l_string|&quot;Cfu didn&squot;t work&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|len
op_ne
r_sizeof
(paren
r_struct
id|ebt_replace
)paren
op_plus
id|entries_size
op_plus
(paren
id|tmp.num_counters
ques
c_cond
id|nentries
op_star
r_sizeof
(paren
r_struct
id|ebt_counter
)paren
suffix:colon
l_int|0
)paren
)paren
(brace
id|BUGPRINT
c_func
(paren
l_string|&quot;Wrong size&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tmp.nentries
op_ne
id|nentries
)paren
(brace
id|BUGPRINT
c_func
(paren
l_string|&quot;Nentries wrong&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tmp.entries_size
op_ne
id|entries_size
)paren
(brace
id|BUGPRINT
c_func
(paren
l_string|&quot;Wrong size&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* userspace might not need the counters */
r_if
c_cond
(paren
id|tmp.num_counters
)paren
(brace
r_if
c_cond
(paren
id|tmp.num_counters
op_ne
id|nentries
)paren
(brace
id|BUGPRINT
c_func
(paren
l_string|&quot;Num_counters wrong&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|counterstmp
op_assign
(paren
r_struct
id|ebt_counter
op_star
)paren
id|vmalloc
c_func
(paren
id|nentries
op_star
r_sizeof
(paren
r_struct
id|ebt_counter
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|counterstmp
)paren
(brace
id|MEMPRINT
c_func
(paren
l_string|&quot;Couldn&squot;t copy counters, out of memory&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|write_lock_bh
c_func
(paren
op_amp
id|t-&gt;lock
)paren
suffix:semicolon
id|get_counters
c_func
(paren
id|oldcounters
comma
id|counterstmp
comma
id|nentries
)paren
suffix:semicolon
id|write_unlock_bh
c_func
(paren
op_amp
id|t-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|tmp.counters
comma
id|counterstmp
comma
id|nentries
op_star
r_sizeof
(paren
r_struct
id|ebt_counter
)paren
)paren
)paren
(brace
id|BUGPRINT
c_func
(paren
l_string|&quot;Couldn&squot;t copy counters to userspace&bslash;n&quot;
)paren
suffix:semicolon
id|vfree
c_func
(paren
id|counterstmp
)paren
suffix:semicolon
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
id|vfree
c_func
(paren
id|counterstmp
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|tmp.entries
comma
id|entries
comma
id|entries_size
)paren
)paren
(brace
id|BUGPRINT
c_func
(paren
l_string|&quot;Couldn&squot;t copy entries to userspace&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
multiline_comment|/* set the match/watcher/target names right */
r_return
id|EBT_ENTRY_ITERATE
c_func
(paren
id|entries
comma
id|entries_size
comma
id|ebt_make_names
comma
id|entries
comma
id|tmp.entries
)paren
suffix:semicolon
)brace
DECL|function|do_ebt_set_ctl
r_static
r_int
id|do_ebt_set_ctl
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|cmd
comma
r_void
id|__user
op_star
id|user
comma
r_int
r_int
id|len
)paren
(brace
r_int
id|ret
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|EBT_SO_SET_ENTRIES
suffix:colon
id|ret
op_assign
id|do_replace
c_func
(paren
id|user
comma
id|len
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|EBT_SO_SET_COUNTERS
suffix:colon
id|ret
op_assign
id|update_counters
c_func
(paren
id|user
comma
id|len
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|function|do_ebt_get_ctl
r_static
r_int
id|do_ebt_get_ctl
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|cmd
comma
r_void
id|__user
op_star
id|user
comma
r_int
op_star
id|len
)paren
(brace
r_int
id|ret
suffix:semicolon
r_struct
id|ebt_replace
id|tmp
suffix:semicolon
r_struct
id|ebt_table
op_star
id|t
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|tmp
comma
id|user
comma
r_sizeof
(paren
id|tmp
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|t
op_assign
id|find_table_lock
c_func
(paren
id|tmp.name
comma
op_amp
id|ret
comma
op_amp
id|ebt_mutex
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|t
)paren
r_return
id|ret
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|EBT_SO_GET_INFO
suffix:colon
r_case
id|EBT_SO_GET_INIT_INFO
suffix:colon
r_if
c_cond
(paren
op_star
id|len
op_ne
r_sizeof
(paren
r_struct
id|ebt_replace
)paren
)paren
(brace
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
id|up
c_func
(paren
op_amp
id|ebt_mutex
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cmd
op_eq
id|EBT_SO_GET_INFO
)paren
(brace
id|tmp.nentries
op_assign
id|t
op_member_access_from_pointer
r_private
op_member_access_from_pointer
id|nentries
suffix:semicolon
id|tmp.entries_size
op_assign
id|t
op_member_access_from_pointer
r_private
op_member_access_from_pointer
id|entries_size
suffix:semicolon
id|tmp.valid_hooks
op_assign
id|t-&gt;valid_hooks
suffix:semicolon
)brace
r_else
(brace
id|tmp.nentries
op_assign
id|t-&gt;table-&gt;nentries
suffix:semicolon
id|tmp.entries_size
op_assign
id|t-&gt;table-&gt;entries_size
suffix:semicolon
id|tmp.valid_hooks
op_assign
id|t-&gt;table-&gt;valid_hooks
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|ebt_mutex
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|user
comma
op_amp
id|tmp
comma
op_star
id|len
)paren
op_ne
l_int|0
)paren
(brace
id|BUGPRINT
c_func
(paren
l_string|&quot;c2u Didn&squot;t work&bslash;n&quot;
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
)brace
id|ret
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|EBT_SO_GET_ENTRIES
suffix:colon
r_case
id|EBT_SO_GET_INIT_ENTRIES
suffix:colon
id|ret
op_assign
id|copy_everything_to_user
c_func
(paren
id|t
comma
id|user
comma
id|len
comma
id|cmd
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|ebt_mutex
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|up
c_func
(paren
op_amp
id|ebt_mutex
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|variable|ebt_sockopts
r_static
r_struct
id|nf_sockopt_ops
id|ebt_sockopts
op_assign
(brace
(brace
l_int|NULL
comma
l_int|NULL
)brace
comma
id|PF_INET
comma
id|EBT_BASE_CTL
comma
id|EBT_SO_SET_MAX
op_plus
l_int|1
comma
id|do_ebt_set_ctl
comma
id|EBT_BASE_CTL
comma
id|EBT_SO_GET_MAX
op_plus
l_int|1
comma
id|do_ebt_get_ctl
comma
l_int|0
comma
l_int|NULL
)brace
suffix:semicolon
DECL|function|init
r_static
r_int
id|__init
id|init
c_func
(paren
r_void
)paren
(brace
r_int
id|ret
suffix:semicolon
id|down
c_func
(paren
op_amp
id|ebt_mutex
)paren
suffix:semicolon
id|list_named_insert
c_func
(paren
op_amp
id|ebt_targets
comma
op_amp
id|ebt_standard_target
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|ebt_mutex
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|nf_register_sockopt
c_func
(paren
op_amp
id|ebt_sockopts
)paren
)paren
OL
l_int|0
)paren
r_return
id|ret
suffix:semicolon
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;Ebtables v2.0 registered&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|fini
r_static
r_void
id|__exit
id|fini
c_func
(paren
r_void
)paren
(brace
id|nf_unregister_sockopt
c_func
(paren
op_amp
id|ebt_sockopts
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;Ebtables v2.0 unregistered&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|variable|ebt_register_table
id|EXPORT_SYMBOL
c_func
(paren
id|ebt_register_table
)paren
suffix:semicolon
DECL|variable|ebt_unregister_table
id|EXPORT_SYMBOL
c_func
(paren
id|ebt_unregister_table
)paren
suffix:semicolon
DECL|variable|ebt_register_match
id|EXPORT_SYMBOL
c_func
(paren
id|ebt_register_match
)paren
suffix:semicolon
DECL|variable|ebt_unregister_match
id|EXPORT_SYMBOL
c_func
(paren
id|ebt_unregister_match
)paren
suffix:semicolon
DECL|variable|ebt_register_watcher
id|EXPORT_SYMBOL
c_func
(paren
id|ebt_register_watcher
)paren
suffix:semicolon
DECL|variable|ebt_unregister_watcher
id|EXPORT_SYMBOL
c_func
(paren
id|ebt_unregister_watcher
)paren
suffix:semicolon
DECL|variable|ebt_register_target
id|EXPORT_SYMBOL
c_func
(paren
id|ebt_register_target
)paren
suffix:semicolon
DECL|variable|ebt_unregister_target
id|EXPORT_SYMBOL
c_func
(paren
id|ebt_unregister_target
)paren
suffix:semicolon
DECL|variable|ebt_do_table
id|EXPORT_SYMBOL
c_func
(paren
id|ebt_do_table
)paren
suffix:semicolon
DECL|variable|init
id|module_init
c_func
(paren
id|init
)paren
suffix:semicolon
DECL|variable|fini
id|module_exit
c_func
(paren
id|fini
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
eof
