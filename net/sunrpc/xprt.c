multiline_comment|/*&n; *  linux/net/sunrpc/xprt.c&n; *&n; *  This is a generic RPC call interface supporting congestion avoidance,&n; *  and asynchronous calls.&n; *&n; *  The interface works like this:&n; *&n; *  -&t;When a process places a call, it allocates a request slot if&n; *&t;one is available. Otherwise, it sleeps on the backlog queue&n; *&t;(xprt_reserve).&n; *  -&t;Next, the caller puts together the RPC message, stuffs it into&n; *&t;the request struct, and calls xprt_call().&n; *  -&t;xprt_call transmits the message and installs the caller on the&n; *&t;socket&squot;s wait list. At the same time, it installs a timer that&n; *&t;is run after the packet&squot;s timeout has expired.&n; *  -&t;When a packet arrives, the data_ready handler walks the list of&n; *&t;pending requests for that socket. If a matching XID is found, the&n; *&t;caller is woken up, and the timer removed.&n; *  -&t;When no reply arrives within the timeout interval, the timer is&n; *&t;fired by the kernel and runs xprt_timer(). It either adjusts the&n; *&t;timeout values (minor timeout) or wakes up the caller with a status&n; *&t;of -ETIMEDOUT.&n; *  -&t;When the caller receives a notification from RPC that a reply arrived,&n; *&t;it should release the RPC slot, and process the reply.&n; *&t;If the call timed out, it may choose to retry the operation by&n; *&t;adjusting the initial timeout value, and simply calling rpc_call&n; *&t;again.&n; *&n; *  Support for async RPC is done through a set of RPC-specific scheduling&n; *  primitives that `transparently&squot; work for processes as well as async&n; *  tasks that rely on callbacks.&n; *&n; *  Copyright (C) 1995-1997, Olaf Kirch &lt;okir@monad.swb.de&gt;&n; *&n; *  TCP callback races fixes (C) 1998 Red Hat Software &lt;alan@redhat.com&gt;&n; *  TCP send fixes (C) 1998 Red Hat Software &lt;alan@redhat.com&gt;&n; *  TCP NFS related read + write fixes&n; *   (C) 1999 Dave Airlie, University of Limerick, Ireland &lt;airlied@linux.ie&gt;&n; *&n; *  Rewrite of larges part of the code in order to stabilize TCP stuff.&n; *  Fix behaviour when socket buffer is full.&n; *   (C) 1999 Trond Myklebust &lt;trond.myklebust@fys.uio.no&gt;&n; */
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/capability.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/socket.h&gt;
macro_line|#include &lt;linux/in.h&gt;
macro_line|#include &lt;linux/net.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/udp.h&gt;
macro_line|#include &lt;linux/tcp.h&gt;
macro_line|#include &lt;linux/sunrpc/clnt.h&gt;
macro_line|#include &lt;linux/file.h&gt;
macro_line|#include &lt;linux/workqueue.h&gt;
macro_line|#include &lt;linux/random.h&gt;
macro_line|#include &lt;net/sock.h&gt;
macro_line|#include &lt;net/checksum.h&gt;
macro_line|#include &lt;net/udp.h&gt;
macro_line|#include &lt;net/tcp.h&gt;
multiline_comment|/*&n; * Local variables&n; */
macro_line|#ifdef RPC_DEBUG
DECL|macro|RPC_DEBUG_DATA
macro_line|# undef  RPC_DEBUG_DATA
DECL|macro|RPCDBG_FACILITY
macro_line|# define RPCDBG_FACILITY&t;RPCDBG_XPRT
macro_line|#endif
DECL|macro|XPRT_MAX_BACKOFF
mdefine_line|#define XPRT_MAX_BACKOFF&t;(8)
DECL|macro|XPRT_IDLE_TIMEOUT
mdefine_line|#define XPRT_IDLE_TIMEOUT&t;(5*60*HZ)
DECL|macro|XPRT_MAX_RESVPORT
mdefine_line|#define XPRT_MAX_RESVPORT&t;(800)
multiline_comment|/*&n; * Local functions&n; */
r_static
r_void
id|xprt_request_init
c_func
(paren
r_struct
id|rpc_task
op_star
comma
r_struct
id|rpc_xprt
op_star
)paren
suffix:semicolon
r_static
r_inline
r_void
id|do_xprt_reserve
c_func
(paren
r_struct
id|rpc_task
op_star
)paren
suffix:semicolon
r_static
r_void
id|xprt_disconnect
c_func
(paren
r_struct
id|rpc_xprt
op_star
)paren
suffix:semicolon
r_static
r_void
id|xprt_connect_status
c_func
(paren
r_struct
id|rpc_task
op_star
id|task
)paren
suffix:semicolon
r_static
r_struct
id|rpc_xprt
op_star
id|xprt_setup
c_func
(paren
r_int
id|proto
comma
r_struct
id|sockaddr_in
op_star
id|ap
comma
r_struct
id|rpc_timeout
op_star
id|to
)paren
suffix:semicolon
r_static
r_struct
id|socket
op_star
id|xprt_create_socket
c_func
(paren
r_struct
id|rpc_xprt
op_star
comma
r_int
comma
r_int
)paren
suffix:semicolon
r_static
r_void
id|xprt_bind_socket
c_func
(paren
r_struct
id|rpc_xprt
op_star
comma
r_struct
id|socket
op_star
)paren
suffix:semicolon
r_static
r_int
id|__xprt_get_cong
c_func
(paren
r_struct
id|rpc_xprt
op_star
comma
r_struct
id|rpc_task
op_star
)paren
suffix:semicolon
r_static
r_int
id|xprt_clear_backlog
c_func
(paren
r_struct
id|rpc_xprt
op_star
id|xprt
)paren
suffix:semicolon
macro_line|#ifdef RPC_DEBUG_DATA
multiline_comment|/*&n; * Print the buffer contents (first 128 bytes only--just enough for&n; * diropres return).&n; */
r_static
r_void
DECL|function|xprt_pktdump
id|xprt_pktdump
c_func
(paren
r_char
op_star
id|msg
comma
id|u32
op_star
id|packet
comma
r_int
r_int
id|count
)paren
(brace
id|u8
op_star
id|buf
op_assign
(paren
id|u8
op_star
)paren
id|packet
suffix:semicolon
r_int
id|j
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;RPC:      %s&bslash;n&quot;
comma
id|msg
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|count
op_logical_and
id|j
OL
l_int|128
suffix:semicolon
id|j
op_add_assign
l_int|4
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|j
op_amp
l_int|31
)paren
)paren
(brace
r_if
c_cond
(paren
id|j
)paren
id|dprintk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;0x%04x &quot;
comma
id|j
)paren
suffix:semicolon
)brace
id|dprintk
c_func
(paren
l_string|&quot;%02x%02x%02x%02x &quot;
comma
id|buf
(braket
id|j
)braket
comma
id|buf
(braket
id|j
op_plus
l_int|1
)braket
comma
id|buf
(braket
id|j
op_plus
l_int|2
)braket
comma
id|buf
(braket
id|j
op_plus
l_int|3
)braket
)paren
suffix:semicolon
)brace
id|dprintk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#else
r_static
r_inline
r_void
DECL|function|xprt_pktdump
id|xprt_pktdump
c_func
(paren
r_char
op_star
id|msg
comma
id|u32
op_star
id|packet
comma
r_int
r_int
id|count
)paren
(brace
multiline_comment|/* NOP */
)brace
macro_line|#endif
multiline_comment|/*&n; * Look up RPC transport given an INET socket&n; */
r_static
r_inline
r_struct
id|rpc_xprt
op_star
DECL|function|xprt_from_sock
id|xprt_from_sock
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_return
(paren
r_struct
id|rpc_xprt
op_star
)paren
id|sk-&gt;sk_user_data
suffix:semicolon
)brace
multiline_comment|/*&n; * Serialize write access to sockets, in order to prevent different&n; * requests from interfering with each other.&n; * Also prevents TCP socket connects from colliding with writes.&n; */
r_static
r_int
DECL|function|__xprt_lock_write
id|__xprt_lock_write
c_func
(paren
r_struct
id|rpc_xprt
op_star
id|xprt
comma
r_struct
id|rpc_task
op_star
id|task
)paren
(brace
r_struct
id|rpc_rqst
op_star
id|req
op_assign
id|task-&gt;tk_rqstp
suffix:semicolon
r_if
c_cond
(paren
id|test_and_set_bit
c_func
(paren
id|XPRT_LOCKED
comma
op_amp
id|xprt-&gt;sockstate
)paren
)paren
(brace
r_if
c_cond
(paren
id|task
op_eq
id|xprt-&gt;snd_task
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|task
op_eq
l_int|NULL
)paren
r_return
l_int|0
suffix:semicolon
r_goto
id|out_sleep
suffix:semicolon
)brace
r_if
c_cond
(paren
id|xprt-&gt;nocong
op_logical_or
id|__xprt_get_cong
c_func
(paren
id|xprt
comma
id|task
)paren
)paren
(brace
id|xprt-&gt;snd_task
op_assign
id|task
suffix:semicolon
r_if
c_cond
(paren
id|req
)paren
(brace
id|req-&gt;rq_bytes_sent
op_assign
l_int|0
suffix:semicolon
id|req-&gt;rq_ntrans
op_increment
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
id|smp_mb__before_clear_bit
c_func
(paren
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|XPRT_LOCKED
comma
op_amp
id|xprt-&gt;sockstate
)paren
suffix:semicolon
id|smp_mb__after_clear_bit
c_func
(paren
)paren
suffix:semicolon
id|out_sleep
suffix:colon
id|dprintk
c_func
(paren
l_string|&quot;RPC: %4d failed to lock socket %p&bslash;n&quot;
comma
id|task-&gt;tk_pid
comma
id|xprt
)paren
suffix:semicolon
id|task-&gt;tk_timeout
op_assign
l_int|0
suffix:semicolon
id|task-&gt;tk_status
op_assign
op_minus
id|EAGAIN
suffix:semicolon
r_if
c_cond
(paren
id|req
op_logical_and
id|req-&gt;rq_ntrans
)paren
id|rpc_sleep_on
c_func
(paren
op_amp
id|xprt-&gt;resend
comma
id|task
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
r_else
id|rpc_sleep_on
c_func
(paren
op_amp
id|xprt-&gt;sending
comma
id|task
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_inline
r_int
DECL|function|xprt_lock_write
id|xprt_lock_write
c_func
(paren
r_struct
id|rpc_xprt
op_star
id|xprt
comma
r_struct
id|rpc_task
op_star
id|task
)paren
(brace
r_int
id|retval
suffix:semicolon
id|spin_lock_bh
c_func
(paren
op_amp
id|xprt-&gt;sock_lock
)paren
suffix:semicolon
id|retval
op_assign
id|__xprt_lock_write
c_func
(paren
id|xprt
comma
id|task
)paren
suffix:semicolon
id|spin_unlock_bh
c_func
(paren
op_amp
id|xprt-&gt;sock_lock
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
r_static
r_void
DECL|function|__xprt_lock_write_next
id|__xprt_lock_write_next
c_func
(paren
r_struct
id|rpc_xprt
op_star
id|xprt
)paren
(brace
r_struct
id|rpc_task
op_star
id|task
suffix:semicolon
r_if
c_cond
(paren
id|test_and_set_bit
c_func
(paren
id|XPRT_LOCKED
comma
op_amp
id|xprt-&gt;sockstate
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|xprt-&gt;nocong
op_logical_and
id|RPCXPRT_CONGESTED
c_func
(paren
id|xprt
)paren
)paren
r_goto
id|out_unlock
suffix:semicolon
id|task
op_assign
id|rpc_wake_up_next
c_func
(paren
op_amp
id|xprt-&gt;resend
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|task
)paren
(brace
id|task
op_assign
id|rpc_wake_up_next
c_func
(paren
op_amp
id|xprt-&gt;sending
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|task
)paren
r_goto
id|out_unlock
suffix:semicolon
)brace
r_if
c_cond
(paren
id|xprt-&gt;nocong
op_logical_or
id|__xprt_get_cong
c_func
(paren
id|xprt
comma
id|task
)paren
)paren
(brace
r_struct
id|rpc_rqst
op_star
id|req
op_assign
id|task-&gt;tk_rqstp
suffix:semicolon
id|xprt-&gt;snd_task
op_assign
id|task
suffix:semicolon
r_if
c_cond
(paren
id|req
)paren
(brace
id|req-&gt;rq_bytes_sent
op_assign
l_int|0
suffix:semicolon
id|req-&gt;rq_ntrans
op_increment
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
id|out_unlock
suffix:colon
id|smp_mb__before_clear_bit
c_func
(paren
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|XPRT_LOCKED
comma
op_amp
id|xprt-&gt;sockstate
)paren
suffix:semicolon
id|smp_mb__after_clear_bit
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Releases the socket for use by other requests.&n; */
r_static
r_void
DECL|function|__xprt_release_write
id|__xprt_release_write
c_func
(paren
r_struct
id|rpc_xprt
op_star
id|xprt
comma
r_struct
id|rpc_task
op_star
id|task
)paren
(brace
r_if
c_cond
(paren
id|xprt-&gt;snd_task
op_eq
id|task
)paren
(brace
id|xprt-&gt;snd_task
op_assign
l_int|NULL
suffix:semicolon
id|smp_mb__before_clear_bit
c_func
(paren
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|XPRT_LOCKED
comma
op_amp
id|xprt-&gt;sockstate
)paren
suffix:semicolon
id|smp_mb__after_clear_bit
c_func
(paren
)paren
suffix:semicolon
id|__xprt_lock_write_next
c_func
(paren
id|xprt
)paren
suffix:semicolon
)brace
)brace
r_static
r_inline
r_void
DECL|function|xprt_release_write
id|xprt_release_write
c_func
(paren
r_struct
id|rpc_xprt
op_star
id|xprt
comma
r_struct
id|rpc_task
op_star
id|task
)paren
(brace
id|spin_lock_bh
c_func
(paren
op_amp
id|xprt-&gt;sock_lock
)paren
suffix:semicolon
id|__xprt_release_write
c_func
(paren
id|xprt
comma
id|task
)paren
suffix:semicolon
id|spin_unlock_bh
c_func
(paren
op_amp
id|xprt-&gt;sock_lock
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Write data to socket.&n; */
r_static
r_inline
r_int
DECL|function|xprt_sendmsg
id|xprt_sendmsg
c_func
(paren
r_struct
id|rpc_xprt
op_star
id|xprt
comma
r_struct
id|rpc_rqst
op_star
id|req
)paren
(brace
r_struct
id|socket
op_star
id|sock
op_assign
id|xprt-&gt;sock
suffix:semicolon
r_struct
id|xdr_buf
op_star
id|xdr
op_assign
op_amp
id|req-&gt;rq_snd_buf
suffix:semicolon
r_struct
id|sockaddr
op_star
id|addr
op_assign
l_int|NULL
suffix:semicolon
r_int
id|addrlen
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|skip
suffix:semicolon
r_int
id|result
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sock
)paren
r_return
op_minus
id|ENOTCONN
suffix:semicolon
id|xprt_pktdump
c_func
(paren
l_string|&quot;packet data:&quot;
comma
id|req-&gt;rq_svec-&gt;iov_base
comma
id|req-&gt;rq_svec-&gt;iov_len
)paren
suffix:semicolon
multiline_comment|/* For UDP, we need to provide an address */
r_if
c_cond
(paren
op_logical_neg
id|xprt-&gt;stream
)paren
(brace
id|addr
op_assign
(paren
r_struct
id|sockaddr
op_star
)paren
op_amp
id|xprt-&gt;addr
suffix:semicolon
id|addrlen
op_assign
r_sizeof
(paren
id|xprt-&gt;addr
)paren
suffix:semicolon
)brace
multiline_comment|/* Dont repeat bytes */
id|skip
op_assign
id|req-&gt;rq_bytes_sent
suffix:semicolon
id|clear_bit
c_func
(paren
id|SOCK_ASYNC_NOSPACE
comma
op_amp
id|sock-&gt;flags
)paren
suffix:semicolon
id|result
op_assign
id|xdr_sendpages
c_func
(paren
id|sock
comma
id|addr
comma
id|addrlen
comma
id|xdr
comma
id|skip
comma
id|MSG_DONTWAIT
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;RPC:      xprt_sendmsg(%d) = %d&bslash;n&quot;
comma
id|xdr-&gt;len
op_minus
id|skip
comma
id|result
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ge
l_int|0
)paren
r_return
id|result
suffix:semicolon
r_switch
c_cond
(paren
id|result
)paren
(brace
r_case
op_minus
id|ECONNREFUSED
suffix:colon
multiline_comment|/* When the server has died, an ICMP port unreachable message&n;&t;&t; * prompts ECONNREFUSED.&n;&t;&t; */
r_case
op_minus
id|EAGAIN
suffix:colon
r_break
suffix:semicolon
r_case
op_minus
id|ECONNRESET
suffix:colon
r_case
op_minus
id|ENOTCONN
suffix:colon
r_case
op_minus
id|EPIPE
suffix:colon
multiline_comment|/* connection broken */
r_if
c_cond
(paren
id|xprt-&gt;stream
)paren
id|result
op_assign
op_minus
id|ENOTCONN
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;RPC: sendmsg returned error %d&bslash;n&quot;
comma
op_minus
id|result
)paren
suffix:semicolon
)brace
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/*&n; * Van Jacobson congestion avoidance. Check if the congestion window&n; * overflowed. Put the task to sleep if this is the case.&n; */
r_static
r_int
DECL|function|__xprt_get_cong
id|__xprt_get_cong
c_func
(paren
r_struct
id|rpc_xprt
op_star
id|xprt
comma
r_struct
id|rpc_task
op_star
id|task
)paren
(brace
r_struct
id|rpc_rqst
op_star
id|req
op_assign
id|task-&gt;tk_rqstp
suffix:semicolon
r_if
c_cond
(paren
id|req-&gt;rq_cong
)paren
r_return
l_int|1
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;RPC: %4d xprt_cwnd_limited cong = %ld cwnd = %ld&bslash;n&quot;
comma
id|task-&gt;tk_pid
comma
id|xprt-&gt;cong
comma
id|xprt-&gt;cwnd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|RPCXPRT_CONGESTED
c_func
(paren
id|xprt
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|req-&gt;rq_cong
op_assign
l_int|1
suffix:semicolon
id|xprt-&gt;cong
op_add_assign
id|RPC_CWNDSCALE
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Adjust the congestion window, and wake up the next task&n; * that has been sleeping due to congestion&n; */
r_static
r_void
DECL|function|__xprt_put_cong
id|__xprt_put_cong
c_func
(paren
r_struct
id|rpc_xprt
op_star
id|xprt
comma
r_struct
id|rpc_rqst
op_star
id|req
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|req-&gt;rq_cong
)paren
r_return
suffix:semicolon
id|req-&gt;rq_cong
op_assign
l_int|0
suffix:semicolon
id|xprt-&gt;cong
op_sub_assign
id|RPC_CWNDSCALE
suffix:semicolon
id|__xprt_lock_write_next
c_func
(paren
id|xprt
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Adjust RPC congestion window&n; * We use a time-smoothed congestion estimator to avoid heavy oscillation.&n; */
r_static
r_void
DECL|function|xprt_adjust_cwnd
id|xprt_adjust_cwnd
c_func
(paren
r_struct
id|rpc_xprt
op_star
id|xprt
comma
r_int
id|result
)paren
(brace
r_int
r_int
id|cwnd
suffix:semicolon
id|cwnd
op_assign
id|xprt-&gt;cwnd
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ge
l_int|0
op_logical_and
id|cwnd
op_le
id|xprt-&gt;cong
)paren
(brace
multiline_comment|/* The (cwnd &gt;&gt; 1) term makes sure&n;&t;&t; * the result gets rounded properly. */
id|cwnd
op_add_assign
(paren
id|RPC_CWNDSCALE
op_star
id|RPC_CWNDSCALE
op_plus
(paren
id|cwnd
op_rshift
l_int|1
)paren
)paren
op_div
id|cwnd
suffix:semicolon
r_if
c_cond
(paren
id|cwnd
OG
id|RPC_MAXCWND
c_func
(paren
id|xprt
)paren
)paren
id|cwnd
op_assign
id|RPC_MAXCWND
c_func
(paren
id|xprt
)paren
suffix:semicolon
id|__xprt_lock_write_next
c_func
(paren
id|xprt
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|result
op_eq
op_minus
id|ETIMEDOUT
)paren
(brace
id|cwnd
op_rshift_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|cwnd
OL
id|RPC_CWNDSCALE
)paren
id|cwnd
op_assign
id|RPC_CWNDSCALE
suffix:semicolon
)brace
id|dprintk
c_func
(paren
l_string|&quot;RPC:      cong %ld, cwnd was %ld, now %ld&bslash;n&quot;
comma
id|xprt-&gt;cong
comma
id|xprt-&gt;cwnd
comma
id|cwnd
)paren
suffix:semicolon
id|xprt-&gt;cwnd
op_assign
id|cwnd
suffix:semicolon
)brace
multiline_comment|/*&n; * Reset the major timeout value&n; */
DECL|function|xprt_reset_majortimeo
r_static
r_void
id|xprt_reset_majortimeo
c_func
(paren
r_struct
id|rpc_rqst
op_star
id|req
)paren
(brace
r_struct
id|rpc_timeout
op_star
id|to
op_assign
op_amp
id|req-&gt;rq_xprt-&gt;timeout
suffix:semicolon
id|req-&gt;rq_majortimeo
op_assign
id|req-&gt;rq_timeout
suffix:semicolon
r_if
c_cond
(paren
id|to-&gt;to_exponential
)paren
id|req-&gt;rq_majortimeo
op_lshift_assign
id|to-&gt;to_retries
suffix:semicolon
r_else
id|req-&gt;rq_majortimeo
op_add_assign
id|to-&gt;to_increment
op_star
id|to-&gt;to_retries
suffix:semicolon
r_if
c_cond
(paren
id|req-&gt;rq_majortimeo
OG
id|to-&gt;to_maxval
op_logical_or
id|req-&gt;rq_majortimeo
op_eq
l_int|0
)paren
id|req-&gt;rq_majortimeo
op_assign
id|to-&gt;to_maxval
suffix:semicolon
id|req-&gt;rq_majortimeo
op_add_assign
id|jiffies
suffix:semicolon
)brace
multiline_comment|/*&n; * Adjust timeout values etc for next retransmit&n; */
DECL|function|xprt_adjust_timeout
r_int
id|xprt_adjust_timeout
c_func
(paren
r_struct
id|rpc_rqst
op_star
id|req
)paren
(brace
r_struct
id|rpc_xprt
op_star
id|xprt
op_assign
id|req-&gt;rq_xprt
suffix:semicolon
r_struct
id|rpc_timeout
op_star
id|to
op_assign
op_amp
id|xprt-&gt;timeout
suffix:semicolon
r_int
id|status
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|time_before
c_func
(paren
id|jiffies
comma
id|req-&gt;rq_majortimeo
)paren
)paren
(brace
r_if
c_cond
(paren
id|to-&gt;to_exponential
)paren
id|req-&gt;rq_timeout
op_lshift_assign
l_int|1
suffix:semicolon
r_else
id|req-&gt;rq_timeout
op_add_assign
id|to-&gt;to_increment
suffix:semicolon
r_if
c_cond
(paren
id|to-&gt;to_maxval
op_logical_and
id|req-&gt;rq_timeout
op_ge
id|to-&gt;to_maxval
)paren
id|req-&gt;rq_timeout
op_assign
id|to-&gt;to_maxval
suffix:semicolon
id|req-&gt;rq_retries
op_increment
suffix:semicolon
id|pprintk
c_func
(paren
l_string|&quot;RPC: %lu retrans&bslash;n&quot;
comma
id|jiffies
)paren
suffix:semicolon
)brace
r_else
(brace
id|req-&gt;rq_timeout
op_assign
id|to-&gt;to_initval
suffix:semicolon
id|req-&gt;rq_retries
op_assign
l_int|0
suffix:semicolon
id|xprt_reset_majortimeo
c_func
(paren
id|req
)paren
suffix:semicolon
multiline_comment|/* Reset the RTT counters == &quot;slow start&quot; */
id|spin_lock_bh
c_func
(paren
op_amp
id|xprt-&gt;sock_lock
)paren
suffix:semicolon
id|rpc_init_rtt
c_func
(paren
id|req-&gt;rq_task-&gt;tk_client-&gt;cl_rtt
comma
id|to-&gt;to_initval
)paren
suffix:semicolon
id|spin_unlock_bh
c_func
(paren
op_amp
id|xprt-&gt;sock_lock
)paren
suffix:semicolon
id|pprintk
c_func
(paren
l_string|&quot;RPC: %lu timeout&bslash;n&quot;
comma
id|jiffies
)paren
suffix:semicolon
id|status
op_assign
op_minus
id|ETIMEDOUT
suffix:semicolon
)brace
r_if
c_cond
(paren
id|req-&gt;rq_timeout
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;xprt_adjust_timeout: rq_timeout = 0!&bslash;n&quot;
)paren
suffix:semicolon
id|req-&gt;rq_timeout
op_assign
l_int|5
op_star
id|HZ
suffix:semicolon
)brace
r_return
id|status
suffix:semicolon
)brace
multiline_comment|/*&n; * Close down a transport socket&n; */
r_static
r_void
DECL|function|xprt_close
id|xprt_close
c_func
(paren
r_struct
id|rpc_xprt
op_star
id|xprt
)paren
(brace
r_struct
id|socket
op_star
id|sock
op_assign
id|xprt-&gt;sock
suffix:semicolon
r_struct
id|sock
op_star
id|sk
op_assign
id|xprt-&gt;inet
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sk
)paren
r_return
suffix:semicolon
id|write_lock_bh
c_func
(paren
op_amp
id|sk-&gt;sk_callback_lock
)paren
suffix:semicolon
id|xprt-&gt;inet
op_assign
l_int|NULL
suffix:semicolon
id|xprt-&gt;sock
op_assign
l_int|NULL
suffix:semicolon
id|sk-&gt;sk_user_data
op_assign
l_int|NULL
suffix:semicolon
id|sk-&gt;sk_data_ready
op_assign
id|xprt-&gt;old_data_ready
suffix:semicolon
id|sk-&gt;sk_state_change
op_assign
id|xprt-&gt;old_state_change
suffix:semicolon
id|sk-&gt;sk_write_space
op_assign
id|xprt-&gt;old_write_space
suffix:semicolon
id|write_unlock_bh
c_func
(paren
op_amp
id|sk-&gt;sk_callback_lock
)paren
suffix:semicolon
id|sk-&gt;sk_no_check
op_assign
l_int|0
suffix:semicolon
id|sock_release
c_func
(paren
id|sock
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|xprt_socket_autoclose
id|xprt_socket_autoclose
c_func
(paren
r_void
op_star
id|args
)paren
(brace
r_struct
id|rpc_xprt
op_star
id|xprt
op_assign
(paren
r_struct
id|rpc_xprt
op_star
)paren
id|args
suffix:semicolon
id|xprt_disconnect
c_func
(paren
id|xprt
)paren
suffix:semicolon
id|xprt_close
c_func
(paren
id|xprt
)paren
suffix:semicolon
id|xprt_release_write
c_func
(paren
id|xprt
comma
l_int|NULL
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Mark a transport as disconnected&n; */
r_static
r_void
DECL|function|xprt_disconnect
id|xprt_disconnect
c_func
(paren
r_struct
id|rpc_xprt
op_star
id|xprt
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;RPC:      disconnected transport %p&bslash;n&quot;
comma
id|xprt
)paren
suffix:semicolon
id|spin_lock_bh
c_func
(paren
op_amp
id|xprt-&gt;sock_lock
)paren
suffix:semicolon
id|xprt_clear_connected
c_func
(paren
id|xprt
)paren
suffix:semicolon
id|rpc_wake_up_status
c_func
(paren
op_amp
id|xprt-&gt;pending
comma
op_minus
id|ENOTCONN
)paren
suffix:semicolon
id|spin_unlock_bh
c_func
(paren
op_amp
id|xprt-&gt;sock_lock
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Used to allow disconnection when we&squot;ve been idle&n; */
r_static
r_void
DECL|function|xprt_init_autodisconnect
id|xprt_init_autodisconnect
c_func
(paren
r_int
r_int
id|data
)paren
(brace
r_struct
id|rpc_xprt
op_star
id|xprt
op_assign
(paren
r_struct
id|rpc_xprt
op_star
)paren
id|data
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|xprt-&gt;sock_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|xprt-&gt;recv
)paren
op_logical_or
id|xprt-&gt;shutdown
)paren
r_goto
id|out_abort
suffix:semicolon
r_if
c_cond
(paren
id|test_and_set_bit
c_func
(paren
id|XPRT_LOCKED
comma
op_amp
id|xprt-&gt;sockstate
)paren
)paren
r_goto
id|out_abort
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|xprt-&gt;sock_lock
)paren
suffix:semicolon
multiline_comment|/* Let keventd close the socket */
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|XPRT_CONNECTING
comma
op_amp
id|xprt-&gt;sockstate
)paren
op_ne
l_int|0
)paren
id|xprt_release_write
c_func
(paren
id|xprt
comma
l_int|NULL
)paren
suffix:semicolon
r_else
id|schedule_work
c_func
(paren
op_amp
id|xprt-&gt;task_cleanup
)paren
suffix:semicolon
r_return
suffix:semicolon
id|out_abort
suffix:colon
id|spin_unlock
c_func
(paren
op_amp
id|xprt-&gt;sock_lock
)paren
suffix:semicolon
)brace
DECL|function|xprt_socket_connect
r_static
r_void
id|xprt_socket_connect
c_func
(paren
r_void
op_star
id|args
)paren
(brace
r_struct
id|rpc_xprt
op_star
id|xprt
op_assign
(paren
r_struct
id|rpc_xprt
op_star
)paren
id|args
suffix:semicolon
r_struct
id|socket
op_star
id|sock
op_assign
id|xprt-&gt;sock
suffix:semicolon
r_int
id|status
op_assign
op_minus
id|EIO
suffix:semicolon
r_if
c_cond
(paren
id|xprt-&gt;shutdown
op_logical_or
id|xprt-&gt;addr.sin_port
op_eq
l_int|0
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/*&n;&t; * Start by resetting any existing state&n;&t; */
id|xprt_close
c_func
(paren
id|xprt
)paren
suffix:semicolon
id|sock
op_assign
id|xprt_create_socket
c_func
(paren
id|xprt
comma
id|xprt-&gt;prot
comma
id|xprt-&gt;resvport
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sock
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* couldn&squot;t create socket or bind to reserved port;&n;&t;&t; * this is likely a permanent error, so cause an abort */
r_goto
id|out
suffix:semicolon
)brace
id|xprt_bind_socket
c_func
(paren
id|xprt
comma
id|sock
)paren
suffix:semicolon
id|xprt_sock_setbufsize
c_func
(paren
id|xprt
)paren
suffix:semicolon
id|status
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|xprt-&gt;stream
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/*&n;&t; * Tell the socket layer to start connecting...&n;&t; */
id|status
op_assign
id|sock-&gt;ops
op_member_access_from_pointer
id|connect
c_func
(paren
id|sock
comma
(paren
r_struct
id|sockaddr
op_star
)paren
op_amp
id|xprt-&gt;addr
comma
r_sizeof
(paren
id|xprt-&gt;addr
)paren
comma
id|O_NONBLOCK
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;RPC: %p  connect status %d connected %d sock state %d&bslash;n&quot;
comma
id|xprt
comma
op_minus
id|status
comma
id|xprt_connected
c_func
(paren
id|xprt
)paren
comma
id|sock-&gt;sk-&gt;sk_state
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
OL
l_int|0
)paren
(brace
r_switch
c_cond
(paren
id|status
)paren
(brace
r_case
op_minus
id|EINPROGRESS
suffix:colon
r_case
op_minus
id|EALREADY
suffix:colon
r_goto
id|out_clear
suffix:semicolon
)brace
)brace
id|out
suffix:colon
r_if
c_cond
(paren
id|status
OL
l_int|0
)paren
id|rpc_wake_up_status
c_func
(paren
op_amp
id|xprt-&gt;pending
comma
id|status
)paren
suffix:semicolon
r_else
id|rpc_wake_up
c_func
(paren
op_amp
id|xprt-&gt;pending
)paren
suffix:semicolon
id|out_clear
suffix:colon
id|smp_mb__before_clear_bit
c_func
(paren
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|XPRT_CONNECTING
comma
op_amp
id|xprt-&gt;sockstate
)paren
suffix:semicolon
id|smp_mb__after_clear_bit
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Attempt to connect a TCP socket.&n; *&n; */
DECL|function|xprt_connect
r_void
id|xprt_connect
c_func
(paren
r_struct
id|rpc_task
op_star
id|task
)paren
(brace
r_struct
id|rpc_xprt
op_star
id|xprt
op_assign
id|task-&gt;tk_xprt
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;RPC: %4d xprt_connect xprt %p %s connected&bslash;n&quot;
comma
id|task-&gt;tk_pid
comma
id|xprt
comma
(paren
id|xprt_connected
c_func
(paren
id|xprt
)paren
ques
c_cond
l_string|&quot;is&quot;
suffix:colon
l_string|&quot;is not&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|xprt-&gt;shutdown
)paren
(brace
id|task-&gt;tk_status
op_assign
op_minus
id|EIO
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|xprt-&gt;addr.sin_port
)paren
(brace
id|task-&gt;tk_status
op_assign
op_minus
id|EIO
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|xprt_lock_write
c_func
(paren
id|xprt
comma
id|task
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|xprt_connected
c_func
(paren
id|xprt
)paren
)paren
r_goto
id|out_write
suffix:semicolon
r_if
c_cond
(paren
id|task-&gt;tk_rqstp
)paren
id|task-&gt;tk_rqstp-&gt;rq_bytes_sent
op_assign
l_int|0
suffix:semicolon
id|task-&gt;tk_timeout
op_assign
id|RPC_CONNECT_TIMEOUT
suffix:semicolon
id|rpc_sleep_on
c_func
(paren
op_amp
id|xprt-&gt;pending
comma
id|task
comma
id|xprt_connect_status
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|test_and_set_bit
c_func
(paren
id|XPRT_CONNECTING
comma
op_amp
id|xprt-&gt;sockstate
)paren
)paren
(brace
multiline_comment|/* Note: if we are here due to a dropped connection&n;&t;&t; * &t; we delay reconnecting by RPC_REESTABLISH_TIMEOUT/HZ&n;&t;&t; * &t; seconds&n;&t;&t; */
r_if
c_cond
(paren
id|xprt-&gt;sock
op_ne
l_int|NULL
)paren
id|schedule_delayed_work
c_func
(paren
op_amp
id|xprt-&gt;sock_connect
comma
id|RPC_REESTABLISH_TIMEOUT
)paren
suffix:semicolon
r_else
id|schedule_work
c_func
(paren
op_amp
id|xprt-&gt;sock_connect
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
id|out_write
suffix:colon
id|xprt_release_write
c_func
(paren
id|xprt
comma
id|task
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * We arrive here when awoken from waiting on connection establishment.&n; */
r_static
r_void
DECL|function|xprt_connect_status
id|xprt_connect_status
c_func
(paren
r_struct
id|rpc_task
op_star
id|task
)paren
(brace
r_struct
id|rpc_xprt
op_star
id|xprt
op_assign
id|task-&gt;tk_xprt
suffix:semicolon
r_if
c_cond
(paren
id|task-&gt;tk_status
op_ge
l_int|0
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;RPC: %4d xprt_connect_status: connection established&bslash;n&quot;
comma
id|task-&gt;tk_pid
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* if soft mounted, just cause this RPC to fail */
r_if
c_cond
(paren
id|RPC_IS_SOFT
c_func
(paren
id|task
)paren
)paren
id|task-&gt;tk_status
op_assign
op_minus
id|EIO
suffix:semicolon
r_switch
c_cond
(paren
id|task-&gt;tk_status
)paren
(brace
r_case
op_minus
id|ECONNREFUSED
suffix:colon
r_case
op_minus
id|ECONNRESET
suffix:colon
r_case
op_minus
id|ENOTCONN
suffix:colon
r_return
suffix:semicolon
r_case
op_minus
id|ETIMEDOUT
suffix:colon
id|dprintk
c_func
(paren
l_string|&quot;RPC: %4d xprt_connect_status: timed out&bslash;n&quot;
comma
id|task-&gt;tk_pid
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;RPC: error %d connecting to server %s&bslash;n&quot;
comma
op_minus
id|task-&gt;tk_status
comma
id|task-&gt;tk_client-&gt;cl_server
)paren
suffix:semicolon
)brace
id|xprt_release_write
c_func
(paren
id|xprt
comma
id|task
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Look up the RPC request corresponding to a reply, and then lock it.&n; */
r_static
r_inline
r_struct
id|rpc_rqst
op_star
DECL|function|xprt_lookup_rqst
id|xprt_lookup_rqst
c_func
(paren
r_struct
id|rpc_xprt
op_star
id|xprt
comma
id|u32
id|xid
)paren
(brace
r_struct
id|list_head
op_star
id|pos
suffix:semicolon
r_struct
id|rpc_rqst
op_star
id|req
op_assign
l_int|NULL
suffix:semicolon
id|list_for_each
c_func
(paren
id|pos
comma
op_amp
id|xprt-&gt;recv
)paren
(brace
r_struct
id|rpc_rqst
op_star
id|entry
op_assign
id|list_entry
c_func
(paren
id|pos
comma
r_struct
id|rpc_rqst
comma
id|rq_list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|entry-&gt;rq_xid
op_eq
id|xid
)paren
(brace
id|req
op_assign
id|entry
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_return
id|req
suffix:semicolon
)brace
multiline_comment|/*&n; * Complete reply received.&n; * The TCP code relies on us to remove the request from xprt-&gt;pending.&n; */
r_static
r_void
DECL|function|xprt_complete_rqst
id|xprt_complete_rqst
c_func
(paren
r_struct
id|rpc_xprt
op_star
id|xprt
comma
r_struct
id|rpc_rqst
op_star
id|req
comma
r_int
id|copied
)paren
(brace
r_struct
id|rpc_task
op_star
id|task
op_assign
id|req-&gt;rq_task
suffix:semicolon
r_struct
id|rpc_clnt
op_star
id|clnt
op_assign
id|task-&gt;tk_client
suffix:semicolon
multiline_comment|/* Adjust congestion window */
r_if
c_cond
(paren
op_logical_neg
id|xprt-&gt;nocong
)paren
(brace
r_int
id|timer
op_assign
id|task-&gt;tk_msg.rpc_proc-&gt;p_timer
suffix:semicolon
id|xprt_adjust_cwnd
c_func
(paren
id|xprt
comma
id|copied
)paren
suffix:semicolon
id|__xprt_put_cong
c_func
(paren
id|xprt
comma
id|req
)paren
suffix:semicolon
r_if
c_cond
(paren
id|timer
)paren
(brace
r_if
c_cond
(paren
id|req-&gt;rq_ntrans
op_eq
l_int|1
)paren
id|rpc_update_rtt
c_func
(paren
id|clnt-&gt;cl_rtt
comma
id|timer
comma
(paren
r_int
)paren
id|jiffies
op_minus
id|req-&gt;rq_xtime
)paren
suffix:semicolon
id|rpc_set_timeo
c_func
(paren
id|clnt-&gt;cl_rtt
comma
id|timer
comma
id|req-&gt;rq_ntrans
op_minus
l_int|1
)paren
suffix:semicolon
)brace
)brace
macro_line|#ifdef RPC_PROFILE
multiline_comment|/* Profile only reads for now */
r_if
c_cond
(paren
id|copied
OG
l_int|1024
)paren
(brace
r_static
r_int
r_int
id|nextstat
suffix:semicolon
r_static
r_int
r_int
id|pkt_rtt
comma
id|pkt_len
comma
id|pkt_cnt
suffix:semicolon
id|pkt_cnt
op_increment
suffix:semicolon
id|pkt_len
op_add_assign
id|req-&gt;rq_slen
op_plus
id|copied
suffix:semicolon
id|pkt_rtt
op_add_assign
id|jiffies
op_minus
id|req-&gt;rq_xtime
suffix:semicolon
r_if
c_cond
(paren
id|time_before
c_func
(paren
id|nextstat
comma
id|jiffies
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;RPC: %lu %ld cwnd&bslash;n&quot;
comma
id|jiffies
comma
id|xprt-&gt;cwnd
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;RPC: %ld %ld %ld %ld stat&bslash;n&quot;
comma
id|jiffies
comma
id|pkt_cnt
comma
id|pkt_len
comma
id|pkt_rtt
)paren
suffix:semicolon
id|pkt_rtt
op_assign
id|pkt_len
op_assign
id|pkt_cnt
op_assign
l_int|0
suffix:semicolon
id|nextstat
op_assign
id|jiffies
op_plus
l_int|5
op_star
id|HZ
suffix:semicolon
)brace
)brace
macro_line|#endif
id|dprintk
c_func
(paren
l_string|&quot;RPC: %4d has input (%d bytes)&bslash;n&quot;
comma
id|task-&gt;tk_pid
comma
id|copied
)paren
suffix:semicolon
id|list_del_init
c_func
(paren
op_amp
id|req-&gt;rq_list
)paren
suffix:semicolon
id|req-&gt;rq_received
op_assign
id|req-&gt;rq_private_buf.len
op_assign
id|copied
suffix:semicolon
multiline_comment|/* ... and wake up the process. */
id|rpc_wake_up_task
c_func
(paren
id|task
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_static
r_int
DECL|function|skb_read_bits
id|skb_read_bits
c_func
(paren
id|skb_reader_t
op_star
id|desc
comma
r_void
op_star
id|to
comma
r_int
id|len
)paren
(brace
r_if
c_cond
(paren
id|len
OG
id|desc-&gt;count
)paren
id|len
op_assign
id|desc-&gt;count
suffix:semicolon
r_if
c_cond
(paren
id|skb_copy_bits
c_func
(paren
id|desc-&gt;skb
comma
id|desc-&gt;offset
comma
id|to
comma
id|len
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|desc-&gt;count
op_sub_assign
id|len
suffix:semicolon
id|desc-&gt;offset
op_add_assign
id|len
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
r_static
r_int
DECL|function|skb_read_and_csum_bits
id|skb_read_and_csum_bits
c_func
(paren
id|skb_reader_t
op_star
id|desc
comma
r_void
op_star
id|to
comma
r_int
id|len
)paren
(brace
r_int
r_int
id|csum2
comma
id|pos
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|desc-&gt;count
)paren
id|len
op_assign
id|desc-&gt;count
suffix:semicolon
id|pos
op_assign
id|desc-&gt;offset
suffix:semicolon
id|csum2
op_assign
id|skb_copy_and_csum_bits
c_func
(paren
id|desc-&gt;skb
comma
id|pos
comma
id|to
comma
id|len
comma
l_int|0
)paren
suffix:semicolon
id|desc-&gt;csum
op_assign
id|csum_block_add
c_func
(paren
id|desc-&gt;csum
comma
id|csum2
comma
id|pos
)paren
suffix:semicolon
id|desc-&gt;count
op_sub_assign
id|len
suffix:semicolon
id|desc-&gt;offset
op_add_assign
id|len
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
multiline_comment|/*&n; * We have set things up such that we perform the checksum of the UDP&n; * packet in parallel with the copies into the RPC client iovec.  -DaveM&n; */
r_int
DECL|function|csum_partial_copy_to_xdr
id|csum_partial_copy_to_xdr
c_func
(paren
r_struct
id|xdr_buf
op_star
id|xdr
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
id|skb_reader_t
id|desc
suffix:semicolon
id|desc.skb
op_assign
id|skb
suffix:semicolon
id|desc.offset
op_assign
r_sizeof
(paren
r_struct
id|udphdr
)paren
suffix:semicolon
id|desc.count
op_assign
id|skb-&gt;len
op_minus
id|desc.offset
suffix:semicolon
r_if
c_cond
(paren
id|skb-&gt;ip_summed
op_eq
id|CHECKSUM_UNNECESSARY
)paren
r_goto
id|no_checksum
suffix:semicolon
id|desc.csum
op_assign
id|csum_partial
c_func
(paren
id|skb-&gt;data
comma
id|desc.offset
comma
id|skb-&gt;csum
)paren
suffix:semicolon
id|xdr_partial_copy_from_skb
c_func
(paren
id|xdr
comma
l_int|0
comma
op_amp
id|desc
comma
id|skb_read_and_csum_bits
)paren
suffix:semicolon
r_if
c_cond
(paren
id|desc.offset
op_ne
id|skb-&gt;len
)paren
(brace
r_int
r_int
id|csum2
suffix:semicolon
id|csum2
op_assign
id|skb_checksum
c_func
(paren
id|skb
comma
id|desc.offset
comma
id|skb-&gt;len
op_minus
id|desc.offset
comma
l_int|0
)paren
suffix:semicolon
id|desc.csum
op_assign
id|csum_block_add
c_func
(paren
id|desc.csum
comma
id|csum2
comma
id|desc.offset
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|desc.count
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
r_int
)paren
id|csum_fold
c_func
(paren
id|desc.csum
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|no_checksum
suffix:colon
id|xdr_partial_copy_from_skb
c_func
(paren
id|xdr
comma
l_int|0
comma
op_amp
id|desc
comma
id|skb_read_bits
)paren
suffix:semicolon
r_if
c_cond
(paren
id|desc.count
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Input handler for RPC replies. Called from a bottom half and hence&n; * atomic.&n; */
r_static
r_void
DECL|function|udp_data_ready
id|udp_data_ready
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|len
)paren
(brace
r_struct
id|rpc_task
op_star
id|task
suffix:semicolon
r_struct
id|rpc_xprt
op_star
id|xprt
suffix:semicolon
r_struct
id|rpc_rqst
op_star
id|rovr
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_int
id|err
comma
id|repsize
comma
id|copied
suffix:semicolon
id|u32
id|_xid
comma
op_star
id|xp
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|sk-&gt;sk_callback_lock
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;RPC:      udp_data_ready...&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|xprt
op_assign
id|xprt_from_sock
c_func
(paren
id|sk
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;RPC:      udp_data_ready request not found!&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|dprintk
c_func
(paren
l_string|&quot;RPC:      udp_data_ready client %p&bslash;n&quot;
comma
id|xprt
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|skb
op_assign
id|skb_recv_datagram
c_func
(paren
id|sk
comma
l_int|0
comma
l_int|1
comma
op_amp
id|err
)paren
)paren
op_eq
l_int|NULL
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|xprt-&gt;shutdown
)paren
r_goto
id|dropit
suffix:semicolon
id|repsize
op_assign
id|skb-&gt;len
op_minus
r_sizeof
(paren
r_struct
id|udphdr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|repsize
OL
l_int|4
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;RPC: impossible RPC reply size %d!&bslash;n&quot;
comma
id|repsize
)paren
suffix:semicolon
r_goto
id|dropit
suffix:semicolon
)brace
multiline_comment|/* Copy the XID from the skb... */
id|xp
op_assign
id|skb_header_pointer
c_func
(paren
id|skb
comma
r_sizeof
(paren
r_struct
id|udphdr
)paren
comma
r_sizeof
(paren
id|_xid
)paren
comma
op_amp
id|_xid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|xp
op_eq
l_int|NULL
)paren
r_goto
id|dropit
suffix:semicolon
multiline_comment|/* Look up and lock the request corresponding to the given XID */
id|spin_lock
c_func
(paren
op_amp
id|xprt-&gt;sock_lock
)paren
suffix:semicolon
id|rovr
op_assign
id|xprt_lookup_rqst
c_func
(paren
id|xprt
comma
op_star
id|xp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rovr
)paren
r_goto
id|out_unlock
suffix:semicolon
id|task
op_assign
id|rovr-&gt;rq_task
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;RPC: %4d received reply&bslash;n&quot;
comma
id|task-&gt;tk_pid
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|copied
op_assign
id|rovr-&gt;rq_private_buf.buflen
)paren
OG
id|repsize
)paren
id|copied
op_assign
id|repsize
suffix:semicolon
multiline_comment|/* Suck it into the iovec, verify checksum if not done by hw. */
r_if
c_cond
(paren
id|csum_partial_copy_to_xdr
c_func
(paren
op_amp
id|rovr-&gt;rq_private_buf
comma
id|skb
)paren
)paren
r_goto
id|out_unlock
suffix:semicolon
multiline_comment|/* Something worked... */
id|dst_confirm
c_func
(paren
id|skb-&gt;dst
)paren
suffix:semicolon
id|xprt_complete_rqst
c_func
(paren
id|xprt
comma
id|rovr
comma
id|copied
)paren
suffix:semicolon
id|out_unlock
suffix:colon
id|spin_unlock
c_func
(paren
op_amp
id|xprt-&gt;sock_lock
)paren
suffix:semicolon
id|dropit
suffix:colon
id|skb_free_datagram
c_func
(paren
id|sk
comma
id|skb
)paren
suffix:semicolon
id|out
suffix:colon
id|read_unlock
c_func
(paren
op_amp
id|sk-&gt;sk_callback_lock
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Copy from an skb into memory and shrink the skb.&n; */
r_static
r_inline
r_int
DECL|function|tcp_copy_data
id|tcp_copy_data
c_func
(paren
id|skb_reader_t
op_star
id|desc
comma
r_void
op_star
id|p
comma
r_int
id|len
)paren
(brace
r_if
c_cond
(paren
id|len
OG
id|desc-&gt;count
)paren
id|len
op_assign
id|desc-&gt;count
suffix:semicolon
r_if
c_cond
(paren
id|skb_copy_bits
c_func
(paren
id|desc-&gt;skb
comma
id|desc-&gt;offset
comma
id|p
comma
id|len
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|desc-&gt;offset
op_add_assign
id|len
suffix:semicolon
id|desc-&gt;count
op_sub_assign
id|len
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
multiline_comment|/*&n; * TCP read fragment marker&n; */
r_static
r_inline
r_void
DECL|function|tcp_read_fraghdr
id|tcp_read_fraghdr
c_func
(paren
r_struct
id|rpc_xprt
op_star
id|xprt
comma
id|skb_reader_t
op_star
id|desc
)paren
(brace
r_int
id|len
comma
id|used
suffix:semicolon
r_char
op_star
id|p
suffix:semicolon
id|p
op_assign
(paren
(paren
r_char
op_star
)paren
op_amp
id|xprt-&gt;tcp_recm
)paren
op_plus
id|xprt-&gt;tcp_offset
suffix:semicolon
id|len
op_assign
r_sizeof
(paren
id|xprt-&gt;tcp_recm
)paren
op_minus
id|xprt-&gt;tcp_offset
suffix:semicolon
id|used
op_assign
id|tcp_copy_data
c_func
(paren
id|desc
comma
id|p
comma
id|len
)paren
suffix:semicolon
id|xprt-&gt;tcp_offset
op_add_assign
id|used
suffix:semicolon
r_if
c_cond
(paren
id|used
op_ne
id|len
)paren
r_return
suffix:semicolon
id|xprt-&gt;tcp_reclen
op_assign
id|ntohl
c_func
(paren
id|xprt-&gt;tcp_recm
)paren
suffix:semicolon
r_if
c_cond
(paren
id|xprt-&gt;tcp_reclen
op_amp
l_int|0x80000000
)paren
id|xprt-&gt;tcp_flags
op_or_assign
id|XPRT_LAST_FRAG
suffix:semicolon
r_else
id|xprt-&gt;tcp_flags
op_and_assign
op_complement
id|XPRT_LAST_FRAG
suffix:semicolon
id|xprt-&gt;tcp_reclen
op_and_assign
l_int|0x7fffffff
suffix:semicolon
id|xprt-&gt;tcp_flags
op_and_assign
op_complement
id|XPRT_COPY_RECM
suffix:semicolon
id|xprt-&gt;tcp_offset
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Sanity check of the record length */
r_if
c_cond
(paren
id|xprt-&gt;tcp_reclen
OL
l_int|4
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;RPC: Invalid TCP record fragment length&bslash;n&quot;
)paren
suffix:semicolon
id|xprt_disconnect
c_func
(paren
id|xprt
)paren
suffix:semicolon
)brace
id|dprintk
c_func
(paren
l_string|&quot;RPC:      reading TCP record fragment of length %d&bslash;n&quot;
comma
id|xprt-&gt;tcp_reclen
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|tcp_check_recm
id|tcp_check_recm
c_func
(paren
r_struct
id|rpc_xprt
op_star
id|xprt
)paren
(brace
r_if
c_cond
(paren
id|xprt-&gt;tcp_offset
op_eq
id|xprt-&gt;tcp_reclen
)paren
(brace
id|xprt-&gt;tcp_flags
op_or_assign
id|XPRT_COPY_RECM
suffix:semicolon
id|xprt-&gt;tcp_offset
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|xprt-&gt;tcp_flags
op_amp
id|XPRT_LAST_FRAG
)paren
(brace
id|xprt-&gt;tcp_flags
op_and_assign
op_complement
id|XPRT_COPY_DATA
suffix:semicolon
id|xprt-&gt;tcp_flags
op_or_assign
id|XPRT_COPY_XID
suffix:semicolon
id|xprt-&gt;tcp_copied
op_assign
l_int|0
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * TCP read xid&n; */
r_static
r_inline
r_void
DECL|function|tcp_read_xid
id|tcp_read_xid
c_func
(paren
r_struct
id|rpc_xprt
op_star
id|xprt
comma
id|skb_reader_t
op_star
id|desc
)paren
(brace
r_int
id|len
comma
id|used
suffix:semicolon
r_char
op_star
id|p
suffix:semicolon
id|len
op_assign
r_sizeof
(paren
id|xprt-&gt;tcp_xid
)paren
op_minus
id|xprt-&gt;tcp_offset
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;RPC:      reading XID (%Zu bytes)&bslash;n&quot;
comma
id|len
)paren
suffix:semicolon
id|p
op_assign
(paren
(paren
r_char
op_star
)paren
op_amp
id|xprt-&gt;tcp_xid
)paren
op_plus
id|xprt-&gt;tcp_offset
suffix:semicolon
id|used
op_assign
id|tcp_copy_data
c_func
(paren
id|desc
comma
id|p
comma
id|len
)paren
suffix:semicolon
id|xprt-&gt;tcp_offset
op_add_assign
id|used
suffix:semicolon
r_if
c_cond
(paren
id|used
op_ne
id|len
)paren
r_return
suffix:semicolon
id|xprt-&gt;tcp_flags
op_and_assign
op_complement
id|XPRT_COPY_XID
suffix:semicolon
id|xprt-&gt;tcp_flags
op_or_assign
id|XPRT_COPY_DATA
suffix:semicolon
id|xprt-&gt;tcp_copied
op_assign
l_int|4
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;RPC:      reading reply for XID %08x&bslash;n&quot;
comma
id|ntohl
c_func
(paren
id|xprt-&gt;tcp_xid
)paren
)paren
suffix:semicolon
id|tcp_check_recm
c_func
(paren
id|xprt
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * TCP read and complete request&n; */
r_static
r_inline
r_void
DECL|function|tcp_read_request
id|tcp_read_request
c_func
(paren
r_struct
id|rpc_xprt
op_star
id|xprt
comma
id|skb_reader_t
op_star
id|desc
)paren
(brace
r_struct
id|rpc_rqst
op_star
id|req
suffix:semicolon
r_struct
id|xdr_buf
op_star
id|rcvbuf
suffix:semicolon
r_int
id|len
suffix:semicolon
multiline_comment|/* Find and lock the request corresponding to this xid */
id|spin_lock
c_func
(paren
op_amp
id|xprt-&gt;sock_lock
)paren
suffix:semicolon
id|req
op_assign
id|xprt_lookup_rqst
c_func
(paren
id|xprt
comma
id|xprt-&gt;tcp_xid
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|req
)paren
(brace
id|xprt-&gt;tcp_flags
op_and_assign
op_complement
id|XPRT_COPY_DATA
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;RPC:      XID %08x request not found!&bslash;n&quot;
comma
id|ntohl
c_func
(paren
id|xprt-&gt;tcp_xid
)paren
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|xprt-&gt;sock_lock
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|rcvbuf
op_assign
op_amp
id|req-&gt;rq_private_buf
suffix:semicolon
id|len
op_assign
id|desc-&gt;count
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|xprt-&gt;tcp_reclen
op_minus
id|xprt-&gt;tcp_offset
)paren
(brace
id|skb_reader_t
id|my_desc
suffix:semicolon
id|len
op_assign
id|xprt-&gt;tcp_reclen
op_minus
id|xprt-&gt;tcp_offset
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|my_desc
comma
id|desc
comma
r_sizeof
(paren
id|my_desc
)paren
)paren
suffix:semicolon
id|my_desc.count
op_assign
id|len
suffix:semicolon
id|xdr_partial_copy_from_skb
c_func
(paren
id|rcvbuf
comma
id|xprt-&gt;tcp_copied
comma
op_amp
id|my_desc
comma
id|tcp_copy_data
)paren
suffix:semicolon
id|desc-&gt;count
op_sub_assign
id|len
suffix:semicolon
id|desc-&gt;offset
op_add_assign
id|len
suffix:semicolon
)brace
r_else
id|xdr_partial_copy_from_skb
c_func
(paren
id|rcvbuf
comma
id|xprt-&gt;tcp_copied
comma
id|desc
comma
id|tcp_copy_data
)paren
suffix:semicolon
id|xprt-&gt;tcp_copied
op_add_assign
id|len
suffix:semicolon
id|xprt-&gt;tcp_offset
op_add_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
id|xprt-&gt;tcp_copied
op_eq
id|req-&gt;rq_private_buf.buflen
)paren
id|xprt-&gt;tcp_flags
op_and_assign
op_complement
id|XPRT_COPY_DATA
suffix:semicolon
r_else
r_if
c_cond
(paren
id|xprt-&gt;tcp_offset
op_eq
id|xprt-&gt;tcp_reclen
)paren
(brace
r_if
c_cond
(paren
id|xprt-&gt;tcp_flags
op_amp
id|XPRT_LAST_FRAG
)paren
id|xprt-&gt;tcp_flags
op_and_assign
op_complement
id|XPRT_COPY_DATA
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|xprt-&gt;tcp_flags
op_amp
id|XPRT_COPY_DATA
)paren
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;RPC: %4d received reply complete&bslash;n&quot;
comma
id|req-&gt;rq_task-&gt;tk_pid
)paren
suffix:semicolon
id|xprt_complete_rqst
c_func
(paren
id|xprt
comma
id|req
comma
id|xprt-&gt;tcp_copied
)paren
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|xprt-&gt;sock_lock
)paren
suffix:semicolon
id|tcp_check_recm
c_func
(paren
id|xprt
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * TCP discard extra bytes from a short read&n; */
r_static
r_inline
r_void
DECL|function|tcp_read_discard
id|tcp_read_discard
c_func
(paren
r_struct
id|rpc_xprt
op_star
id|xprt
comma
id|skb_reader_t
op_star
id|desc
)paren
(brace
r_int
id|len
suffix:semicolon
id|len
op_assign
id|xprt-&gt;tcp_reclen
op_minus
id|xprt-&gt;tcp_offset
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|desc-&gt;count
)paren
id|len
op_assign
id|desc-&gt;count
suffix:semicolon
id|desc-&gt;count
op_sub_assign
id|len
suffix:semicolon
id|desc-&gt;offset
op_add_assign
id|len
suffix:semicolon
id|xprt-&gt;tcp_offset
op_add_assign
id|len
suffix:semicolon
id|tcp_check_recm
c_func
(paren
id|xprt
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * TCP record receive routine&n; * We first have to grab the record marker, then the XID, then the data.&n; */
r_static
r_int
DECL|function|tcp_data_recv
id|tcp_data_recv
c_func
(paren
id|read_descriptor_t
op_star
id|rd_desc
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
r_int
id|offset
comma
r_int
id|len
)paren
(brace
r_struct
id|rpc_xprt
op_star
id|xprt
op_assign
id|rd_desc-&gt;arg.data
suffix:semicolon
id|skb_reader_t
id|desc
op_assign
(brace
dot
id|skb
op_assign
id|skb
comma
dot
id|offset
op_assign
id|offset
comma
dot
id|count
op_assign
id|len
comma
dot
id|csum
op_assign
l_int|0
)brace
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;RPC:      tcp_data_recv&bslash;n&quot;
)paren
suffix:semicolon
r_do
(brace
multiline_comment|/* Read in a new fragment marker if necessary */
multiline_comment|/* Can we ever really expect to get completely empty fragments? */
r_if
c_cond
(paren
id|xprt-&gt;tcp_flags
op_amp
id|XPRT_COPY_RECM
)paren
(brace
id|tcp_read_fraghdr
c_func
(paren
id|xprt
comma
op_amp
id|desc
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* Read in the xid if necessary */
r_if
c_cond
(paren
id|xprt-&gt;tcp_flags
op_amp
id|XPRT_COPY_XID
)paren
(brace
id|tcp_read_xid
c_func
(paren
id|xprt
comma
op_amp
id|desc
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* Read in the request data */
r_if
c_cond
(paren
id|xprt-&gt;tcp_flags
op_amp
id|XPRT_COPY_DATA
)paren
(brace
id|tcp_read_request
c_func
(paren
id|xprt
comma
op_amp
id|desc
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* Skip over any trailing bytes on short reads */
id|tcp_read_discard
c_func
(paren
id|xprt
comma
op_amp
id|desc
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|desc.count
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;RPC:      tcp_data_recv done&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|len
op_minus
id|desc.count
suffix:semicolon
)brace
DECL|function|tcp_data_ready
r_static
r_void
id|tcp_data_ready
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|bytes
)paren
(brace
r_struct
id|rpc_xprt
op_star
id|xprt
suffix:semicolon
id|read_descriptor_t
id|rd_desc
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|sk-&gt;sk_callback_lock
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;RPC:      tcp_data_ready...&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|xprt
op_assign
id|xprt_from_sock
c_func
(paren
id|sk
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;RPC:      tcp_data_ready socket info not found!&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|xprt-&gt;shutdown
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* We use rd_desc to pass struct xprt to tcp_data_recv */
id|rd_desc.arg.data
op_assign
id|xprt
suffix:semicolon
id|rd_desc.count
op_assign
l_int|65536
suffix:semicolon
id|tcp_read_sock
c_func
(paren
id|sk
comma
op_amp
id|rd_desc
comma
id|tcp_data_recv
)paren
suffix:semicolon
id|out
suffix:colon
id|read_unlock
c_func
(paren
op_amp
id|sk-&gt;sk_callback_lock
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|tcp_state_change
id|tcp_state_change
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|rpc_xprt
op_star
id|xprt
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|sk-&gt;sk_callback_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|xprt
op_assign
id|xprt_from_sock
c_func
(paren
id|sk
)paren
)paren
)paren
r_goto
id|out
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;RPC:      tcp_state_change client %p...&bslash;n&quot;
comma
id|xprt
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;RPC:      state %x conn %d dead %d zapped %d&bslash;n&quot;
comma
id|sk-&gt;sk_state
comma
id|xprt_connected
c_func
(paren
id|xprt
)paren
comma
id|sock_flag
c_func
(paren
id|sk
comma
id|SOCK_DEAD
)paren
comma
id|sk-&gt;sk_zapped
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|sk-&gt;sk_state
)paren
(brace
r_case
id|TCP_ESTABLISHED
suffix:colon
id|spin_lock_bh
c_func
(paren
op_amp
id|xprt-&gt;sock_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|xprt_test_and_set_connected
c_func
(paren
id|xprt
)paren
)paren
(brace
multiline_comment|/* Reset TCP record info */
id|xprt-&gt;tcp_offset
op_assign
l_int|0
suffix:semicolon
id|xprt-&gt;tcp_reclen
op_assign
l_int|0
suffix:semicolon
id|xprt-&gt;tcp_copied
op_assign
l_int|0
suffix:semicolon
id|xprt-&gt;tcp_flags
op_assign
id|XPRT_COPY_RECM
op_or
id|XPRT_COPY_XID
suffix:semicolon
id|rpc_wake_up
c_func
(paren
op_amp
id|xprt-&gt;pending
)paren
suffix:semicolon
)brace
id|spin_unlock_bh
c_func
(paren
op_amp
id|xprt-&gt;sock_lock
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TCP_SYN_SENT
suffix:colon
r_case
id|TCP_SYN_RECV
suffix:colon
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
r_if
c_cond
(paren
id|xprt_test_and_clear_connected
c_func
(paren
id|xprt
)paren
)paren
id|rpc_wake_up_status
c_func
(paren
op_amp
id|xprt-&gt;pending
comma
op_minus
id|ENOTCONN
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|out
suffix:colon
id|read_unlock
c_func
(paren
op_amp
id|sk-&gt;sk_callback_lock
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Called when more output buffer space is available for this socket.&n; * We try not to wake our writers until they can make &quot;significant&quot;&n; * progress, otherwise we&squot;ll waste resources thrashing sock_sendmsg&n; * with a bunch of small requests.&n; */
r_static
r_void
DECL|function|xprt_write_space
id|xprt_write_space
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|rpc_xprt
op_star
id|xprt
suffix:semicolon
r_struct
id|socket
op_star
id|sock
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|sk-&gt;sk_callback_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|xprt
op_assign
id|xprt_from_sock
c_func
(paren
id|sk
)paren
)paren
op_logical_or
op_logical_neg
(paren
id|sock
op_assign
id|sk-&gt;sk_socket
)paren
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|xprt-&gt;shutdown
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* Wait until we have enough socket memory */
r_if
c_cond
(paren
id|xprt-&gt;stream
)paren
(brace
multiline_comment|/* from net/core/stream.c:sk_stream_write_space */
r_if
c_cond
(paren
id|sk_stream_wspace
c_func
(paren
id|sk
)paren
OL
id|sk_stream_min_wspace
c_func
(paren
id|sk
)paren
)paren
r_goto
id|out
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* from net/core/sock.c:sock_def_write_space */
r_if
c_cond
(paren
op_logical_neg
id|sock_writeable
c_func
(paren
id|sk
)paren
)paren
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|test_and_clear_bit
c_func
(paren
id|SOCK_NOSPACE
comma
op_amp
id|sock-&gt;flags
)paren
)paren
r_goto
id|out
suffix:semicolon
id|spin_lock_bh
c_func
(paren
op_amp
id|xprt-&gt;sock_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|xprt-&gt;snd_task
)paren
id|rpc_wake_up_task
c_func
(paren
id|xprt-&gt;snd_task
)paren
suffix:semicolon
id|spin_unlock_bh
c_func
(paren
op_amp
id|xprt-&gt;sock_lock
)paren
suffix:semicolon
id|out
suffix:colon
id|read_unlock
c_func
(paren
op_amp
id|sk-&gt;sk_callback_lock
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * RPC receive timeout handler.&n; */
r_static
r_void
DECL|function|xprt_timer
id|xprt_timer
c_func
(paren
r_struct
id|rpc_task
op_star
id|task
)paren
(brace
r_struct
id|rpc_rqst
op_star
id|req
op_assign
id|task-&gt;tk_rqstp
suffix:semicolon
r_struct
id|rpc_xprt
op_star
id|xprt
op_assign
id|req-&gt;rq_xprt
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|xprt-&gt;sock_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|req-&gt;rq_received
)paren
r_goto
id|out
suffix:semicolon
id|xprt_adjust_cwnd
c_func
(paren
id|req-&gt;rq_xprt
comma
op_minus
id|ETIMEDOUT
)paren
suffix:semicolon
id|__xprt_put_cong
c_func
(paren
id|xprt
comma
id|req
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;RPC: %4d xprt_timer (%s request)&bslash;n&quot;
comma
id|task-&gt;tk_pid
comma
id|req
ques
c_cond
l_string|&quot;pending&quot;
suffix:colon
l_string|&quot;backlogged&quot;
)paren
suffix:semicolon
id|task-&gt;tk_status
op_assign
op_minus
id|ETIMEDOUT
suffix:semicolon
id|out
suffix:colon
id|task-&gt;tk_timeout
op_assign
l_int|0
suffix:semicolon
id|rpc_wake_up_task
c_func
(paren
id|task
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|xprt-&gt;sock_lock
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Place the actual RPC call.&n; * We have to copy the iovec because sendmsg fiddles with its contents.&n; */
r_int
DECL|function|xprt_prepare_transmit
id|xprt_prepare_transmit
c_func
(paren
r_struct
id|rpc_task
op_star
id|task
)paren
(brace
r_struct
id|rpc_rqst
op_star
id|req
op_assign
id|task-&gt;tk_rqstp
suffix:semicolon
r_struct
id|rpc_xprt
op_star
id|xprt
op_assign
id|req-&gt;rq_xprt
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;RPC: %4d xprt_prepare_transmit&bslash;n&quot;
comma
id|task-&gt;tk_pid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|xprt-&gt;shutdown
)paren
r_return
op_minus
id|EIO
suffix:semicolon
id|spin_lock_bh
c_func
(paren
op_amp
id|xprt-&gt;sock_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|req-&gt;rq_received
op_logical_and
op_logical_neg
id|req-&gt;rq_bytes_sent
)paren
(brace
id|err
op_assign
id|req-&gt;rq_received
suffix:semicolon
r_goto
id|out_unlock
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|__xprt_lock_write
c_func
(paren
id|xprt
comma
id|task
)paren
)paren
(brace
id|err
op_assign
op_minus
id|EAGAIN
suffix:semicolon
r_goto
id|out_unlock
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|xprt_connected
c_func
(paren
id|xprt
)paren
)paren
(brace
id|err
op_assign
op_minus
id|ENOTCONN
suffix:semicolon
r_goto
id|out_unlock
suffix:semicolon
)brace
id|out_unlock
suffix:colon
id|spin_unlock_bh
c_func
(paren
op_amp
id|xprt-&gt;sock_lock
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
r_void
DECL|function|xprt_transmit
id|xprt_transmit
c_func
(paren
r_struct
id|rpc_task
op_star
id|task
)paren
(brace
r_struct
id|rpc_clnt
op_star
id|clnt
op_assign
id|task-&gt;tk_client
suffix:semicolon
r_struct
id|rpc_rqst
op_star
id|req
op_assign
id|task-&gt;tk_rqstp
suffix:semicolon
r_struct
id|rpc_xprt
op_star
id|xprt
op_assign
id|req-&gt;rq_xprt
suffix:semicolon
r_int
id|status
comma
id|retry
op_assign
l_int|0
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;RPC: %4d xprt_transmit(%u)&bslash;n&quot;
comma
id|task-&gt;tk_pid
comma
id|req-&gt;rq_slen
)paren
suffix:semicolon
multiline_comment|/* set up everything as needed. */
multiline_comment|/* Write the record marker */
r_if
c_cond
(paren
id|xprt-&gt;stream
)paren
(brace
id|u32
op_star
id|marker
op_assign
id|req-&gt;rq_svec
(braket
l_int|0
)braket
dot
id|iov_base
suffix:semicolon
op_star
id|marker
op_assign
id|htonl
c_func
(paren
l_int|0x80000000
op_or
(paren
id|req-&gt;rq_slen
op_minus
r_sizeof
(paren
op_star
id|marker
)paren
)paren
)paren
suffix:semicolon
)brace
id|smp_rmb
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|req-&gt;rq_received
)paren
(brace
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|req-&gt;rq_list
)paren
)paren
(brace
id|spin_lock_bh
c_func
(paren
op_amp
id|xprt-&gt;sock_lock
)paren
suffix:semicolon
multiline_comment|/* Update the softirq receive buffer */
id|memcpy
c_func
(paren
op_amp
id|req-&gt;rq_private_buf
comma
op_amp
id|req-&gt;rq_rcv_buf
comma
r_sizeof
(paren
id|req-&gt;rq_private_buf
)paren
)paren
suffix:semicolon
multiline_comment|/* Add request to the receive list */
id|list_add_tail
c_func
(paren
op_amp
id|req-&gt;rq_list
comma
op_amp
id|xprt-&gt;recv
)paren
suffix:semicolon
id|spin_unlock_bh
c_func
(paren
op_amp
id|xprt-&gt;sock_lock
)paren
suffix:semicolon
id|xprt_reset_majortimeo
c_func
(paren
id|req
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|req-&gt;rq_bytes_sent
)paren
r_return
suffix:semicolon
multiline_comment|/* Continue transmitting the packet/record. We must be careful&n;&t; * to cope with writespace callbacks arriving _after_ we have&n;&t; * called xprt_sendmsg().&n;&t; */
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|req-&gt;rq_xtime
op_assign
id|jiffies
suffix:semicolon
id|status
op_assign
id|xprt_sendmsg
c_func
(paren
id|xprt
comma
id|req
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
OL
l_int|0
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|xprt-&gt;stream
)paren
(brace
id|req-&gt;rq_bytes_sent
op_add_assign
id|status
suffix:semicolon
multiline_comment|/* If we&squot;ve sent the entire packet, immediately&n;&t;&t;&t; * reset the count of bytes sent. */
r_if
c_cond
(paren
id|req-&gt;rq_bytes_sent
op_ge
id|req-&gt;rq_slen
)paren
(brace
id|req-&gt;rq_bytes_sent
op_assign
l_int|0
suffix:semicolon
r_goto
id|out_receive
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|status
op_ge
id|req-&gt;rq_slen
)paren
r_goto
id|out_receive
suffix:semicolon
id|status
op_assign
op_minus
id|EAGAIN
suffix:semicolon
r_break
suffix:semicolon
)brace
id|dprintk
c_func
(paren
l_string|&quot;RPC: %4d xmit incomplete (%d left of %d)&bslash;n&quot;
comma
id|task-&gt;tk_pid
comma
id|req-&gt;rq_slen
op_minus
id|req-&gt;rq_bytes_sent
comma
id|req-&gt;rq_slen
)paren
suffix:semicolon
id|status
op_assign
op_minus
id|EAGAIN
suffix:semicolon
r_if
c_cond
(paren
id|retry
op_increment
OG
l_int|50
)paren
r_break
suffix:semicolon
)brace
multiline_comment|/* Note: at this point, task-&gt;tk_sleeping has not yet been set,&n;&t; *&t; hence there is no danger of the waking up task being put on&n;&t; *&t; schedq, and being picked up by a parallel run of rpciod().&n;&t; */
id|task-&gt;tk_status
op_assign
id|status
suffix:semicolon
r_switch
c_cond
(paren
id|status
)paren
(brace
r_case
op_minus
id|EAGAIN
suffix:colon
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|SOCK_ASYNC_NOSPACE
comma
op_amp
id|xprt-&gt;sock-&gt;flags
)paren
)paren
(brace
multiline_comment|/* Protect against races with xprt_write_space */
id|spin_lock_bh
c_func
(paren
op_amp
id|xprt-&gt;sock_lock
)paren
suffix:semicolon
multiline_comment|/* Don&squot;t race with disconnect */
r_if
c_cond
(paren
op_logical_neg
id|xprt_connected
c_func
(paren
id|xprt
)paren
)paren
id|task-&gt;tk_status
op_assign
op_minus
id|ENOTCONN
suffix:semicolon
r_else
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|SOCK_NOSPACE
comma
op_amp
id|xprt-&gt;sock-&gt;flags
)paren
)paren
(brace
id|task-&gt;tk_timeout
op_assign
id|req-&gt;rq_timeout
suffix:semicolon
id|rpc_sleep_on
c_func
(paren
op_amp
id|xprt-&gt;pending
comma
id|task
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
)brace
id|spin_unlock_bh
c_func
(paren
op_amp
id|xprt-&gt;sock_lock
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Keep holding the socket if it is blocked */
id|rpc_delay
c_func
(paren
id|task
comma
id|HZ
op_rshift
l_int|4
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
op_minus
id|ECONNREFUSED
suffix:colon
id|task-&gt;tk_timeout
op_assign
id|RPC_REESTABLISH_TIMEOUT
suffix:semicolon
id|rpc_sleep_on
c_func
(paren
op_amp
id|xprt-&gt;sending
comma
id|task
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
r_case
op_minus
id|ENOTCONN
suffix:colon
r_return
suffix:semicolon
r_default
suffix:colon
(brace
)brace
r_if
c_cond
(paren
id|xprt-&gt;stream
)paren
id|xprt_disconnect
c_func
(paren
id|xprt
)paren
suffix:semicolon
)brace
id|xprt_release_write
c_func
(paren
id|xprt
comma
id|task
)paren
suffix:semicolon
r_return
suffix:semicolon
id|out_receive
suffix:colon
id|dprintk
c_func
(paren
l_string|&quot;RPC: %4d xmit complete&bslash;n&quot;
comma
id|task-&gt;tk_pid
)paren
suffix:semicolon
multiline_comment|/* Set the task&squot;s receive timeout value */
id|spin_lock_bh
c_func
(paren
op_amp
id|xprt-&gt;sock_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|xprt-&gt;nocong
)paren
(brace
r_int
id|timer
op_assign
id|task-&gt;tk_msg.rpc_proc-&gt;p_timer
suffix:semicolon
id|task-&gt;tk_timeout
op_assign
id|rpc_calc_rto
c_func
(paren
id|clnt-&gt;cl_rtt
comma
id|timer
)paren
suffix:semicolon
id|task-&gt;tk_timeout
op_lshift_assign
id|rpc_ntimeo
c_func
(paren
id|clnt-&gt;cl_rtt
comma
id|timer
)paren
op_plus
id|req-&gt;rq_retries
suffix:semicolon
r_if
c_cond
(paren
id|task-&gt;tk_timeout
OG
id|xprt-&gt;timeout.to_maxval
op_logical_or
id|task-&gt;tk_timeout
op_eq
l_int|0
)paren
id|task-&gt;tk_timeout
op_assign
id|xprt-&gt;timeout.to_maxval
suffix:semicolon
)brace
r_else
id|task-&gt;tk_timeout
op_assign
id|req-&gt;rq_timeout
suffix:semicolon
multiline_comment|/* Don&squot;t race with disconnect */
r_if
c_cond
(paren
op_logical_neg
id|xprt_connected
c_func
(paren
id|xprt
)paren
)paren
id|task-&gt;tk_status
op_assign
op_minus
id|ENOTCONN
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|req-&gt;rq_received
)paren
id|rpc_sleep_on
c_func
(paren
op_amp
id|xprt-&gt;pending
comma
id|task
comma
l_int|NULL
comma
id|xprt_timer
)paren
suffix:semicolon
id|__xprt_release_write
c_func
(paren
id|xprt
comma
id|task
)paren
suffix:semicolon
id|spin_unlock_bh
c_func
(paren
op_amp
id|xprt-&gt;sock_lock
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Reserve an RPC call slot.&n; */
r_static
r_inline
r_void
DECL|function|do_xprt_reserve
id|do_xprt_reserve
c_func
(paren
r_struct
id|rpc_task
op_star
id|task
)paren
(brace
r_struct
id|rpc_xprt
op_star
id|xprt
op_assign
id|task-&gt;tk_xprt
suffix:semicolon
id|task-&gt;tk_status
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|task-&gt;tk_rqstp
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|xprt-&gt;free
)paren
)paren
(brace
r_struct
id|rpc_rqst
op_star
id|req
op_assign
id|list_entry
c_func
(paren
id|xprt-&gt;free.next
comma
r_struct
id|rpc_rqst
comma
id|rq_list
)paren
suffix:semicolon
id|list_del_init
c_func
(paren
op_amp
id|req-&gt;rq_list
)paren
suffix:semicolon
id|task-&gt;tk_rqstp
op_assign
id|req
suffix:semicolon
id|xprt_request_init
c_func
(paren
id|task
comma
id|xprt
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|dprintk
c_func
(paren
l_string|&quot;RPC:      waiting for request slot&bslash;n&quot;
)paren
suffix:semicolon
id|task-&gt;tk_status
op_assign
op_minus
id|EAGAIN
suffix:semicolon
id|task-&gt;tk_timeout
op_assign
l_int|0
suffix:semicolon
id|rpc_sleep_on
c_func
(paren
op_amp
id|xprt-&gt;backlog
comma
id|task
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
)brace
r_void
DECL|function|xprt_reserve
id|xprt_reserve
c_func
(paren
r_struct
id|rpc_task
op_star
id|task
)paren
(brace
r_struct
id|rpc_xprt
op_star
id|xprt
op_assign
id|task-&gt;tk_xprt
suffix:semicolon
id|task-&gt;tk_status
op_assign
op_minus
id|EIO
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|xprt-&gt;shutdown
)paren
(brace
id|spin_lock
c_func
(paren
op_amp
id|xprt-&gt;xprt_lock
)paren
suffix:semicolon
id|do_xprt_reserve
c_func
(paren
id|task
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|xprt-&gt;xprt_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|task-&gt;tk_rqstp
)paren
id|del_timer_sync
c_func
(paren
op_amp
id|xprt-&gt;timer
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Allocate a &squot;unique&squot; XID&n; */
DECL|function|xprt_alloc_xid
r_static
r_inline
id|u32
id|xprt_alloc_xid
c_func
(paren
r_struct
id|rpc_xprt
op_star
id|xprt
)paren
(brace
r_return
id|xprt-&gt;xid
op_increment
suffix:semicolon
)brace
DECL|function|xprt_init_xid
r_static
r_inline
r_void
id|xprt_init_xid
c_func
(paren
r_struct
id|rpc_xprt
op_star
id|xprt
)paren
(brace
id|get_random_bytes
c_func
(paren
op_amp
id|xprt-&gt;xid
comma
r_sizeof
(paren
id|xprt-&gt;xid
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Initialize RPC request&n; */
r_static
r_void
DECL|function|xprt_request_init
id|xprt_request_init
c_func
(paren
r_struct
id|rpc_task
op_star
id|task
comma
r_struct
id|rpc_xprt
op_star
id|xprt
)paren
(brace
r_struct
id|rpc_rqst
op_star
id|req
op_assign
id|task-&gt;tk_rqstp
suffix:semicolon
id|req-&gt;rq_timeout
op_assign
id|xprt-&gt;timeout.to_initval
suffix:semicolon
id|req-&gt;rq_task
op_assign
id|task
suffix:semicolon
id|req-&gt;rq_xprt
op_assign
id|xprt
suffix:semicolon
id|req-&gt;rq_xid
op_assign
id|xprt_alloc_xid
c_func
(paren
id|xprt
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;RPC: %4d reserved req %p xid %08x&bslash;n&quot;
comma
id|task-&gt;tk_pid
comma
id|req
comma
id|ntohl
c_func
(paren
id|req-&gt;rq_xid
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Release an RPC call slot&n; */
r_void
DECL|function|xprt_release
id|xprt_release
c_func
(paren
r_struct
id|rpc_task
op_star
id|task
)paren
(brace
r_struct
id|rpc_xprt
op_star
id|xprt
op_assign
id|task-&gt;tk_xprt
suffix:semicolon
r_struct
id|rpc_rqst
op_star
id|req
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|req
op_assign
id|task-&gt;tk_rqstp
)paren
)paren
r_return
suffix:semicolon
id|spin_lock_bh
c_func
(paren
op_amp
id|xprt-&gt;sock_lock
)paren
suffix:semicolon
id|__xprt_release_write
c_func
(paren
id|xprt
comma
id|task
)paren
suffix:semicolon
id|__xprt_put_cong
c_func
(paren
id|xprt
comma
id|req
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|req-&gt;rq_list
)paren
)paren
id|list_del
c_func
(paren
op_amp
id|req-&gt;rq_list
)paren
suffix:semicolon
id|xprt-&gt;last_used
op_assign
id|jiffies
suffix:semicolon
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|xprt-&gt;recv
)paren
op_logical_and
op_logical_neg
id|xprt-&gt;shutdown
)paren
id|mod_timer
c_func
(paren
op_amp
id|xprt-&gt;timer
comma
id|xprt-&gt;last_used
op_plus
id|XPRT_IDLE_TIMEOUT
)paren
suffix:semicolon
id|spin_unlock_bh
c_func
(paren
op_amp
id|xprt-&gt;sock_lock
)paren
suffix:semicolon
id|task-&gt;tk_rqstp
op_assign
l_int|NULL
suffix:semicolon
id|memset
c_func
(paren
id|req
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|req
)paren
)paren
suffix:semicolon
multiline_comment|/* mark unused */
id|dprintk
c_func
(paren
l_string|&quot;RPC: %4d release request %p&bslash;n&quot;
comma
id|task-&gt;tk_pid
comma
id|req
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|xprt-&gt;xprt_lock
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|req-&gt;rq_list
comma
op_amp
id|xprt-&gt;free
)paren
suffix:semicolon
id|xprt_clear_backlog
c_func
(paren
id|xprt
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|xprt-&gt;xprt_lock
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Set default timeout parameters&n; */
r_static
r_void
DECL|function|xprt_default_timeout
id|xprt_default_timeout
c_func
(paren
r_struct
id|rpc_timeout
op_star
id|to
comma
r_int
id|proto
)paren
(brace
r_if
c_cond
(paren
id|proto
op_eq
id|IPPROTO_UDP
)paren
id|xprt_set_timeout
c_func
(paren
id|to
comma
l_int|5
comma
l_int|5
op_star
id|HZ
)paren
suffix:semicolon
r_else
id|xprt_set_timeout
c_func
(paren
id|to
comma
l_int|5
comma
l_int|60
op_star
id|HZ
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Set constant timeout&n; */
r_void
DECL|function|xprt_set_timeout
id|xprt_set_timeout
c_func
(paren
r_struct
id|rpc_timeout
op_star
id|to
comma
r_int
r_int
id|retr
comma
r_int
r_int
id|incr
)paren
(brace
id|to-&gt;to_initval
op_assign
id|to-&gt;to_increment
op_assign
id|incr
suffix:semicolon
id|to-&gt;to_maxval
op_assign
id|incr
op_star
id|retr
suffix:semicolon
id|to-&gt;to_retries
op_assign
id|retr
suffix:semicolon
id|to-&gt;to_exponential
op_assign
l_int|0
suffix:semicolon
)brace
DECL|variable|xprt_udp_slot_table_entries
r_int
r_int
id|xprt_udp_slot_table_entries
op_assign
id|RPC_DEF_SLOT_TABLE
suffix:semicolon
DECL|variable|xprt_tcp_slot_table_entries
r_int
r_int
id|xprt_tcp_slot_table_entries
op_assign
id|RPC_DEF_SLOT_TABLE
suffix:semicolon
multiline_comment|/*&n; * Initialize an RPC client&n; */
r_static
r_struct
id|rpc_xprt
op_star
DECL|function|xprt_setup
id|xprt_setup
c_func
(paren
r_int
id|proto
comma
r_struct
id|sockaddr_in
op_star
id|ap
comma
r_struct
id|rpc_timeout
op_star
id|to
)paren
(brace
r_struct
id|rpc_xprt
op_star
id|xprt
suffix:semicolon
r_int
r_int
id|entries
suffix:semicolon
r_int
id|slot_table_size
suffix:semicolon
r_struct
id|rpc_rqst
op_star
id|req
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;RPC:      setting up %s transport...&bslash;n&quot;
comma
id|proto
op_eq
id|IPPROTO_UDP
ques
c_cond
l_string|&quot;UDP&quot;
suffix:colon
l_string|&quot;TCP&quot;
)paren
suffix:semicolon
id|entries
op_assign
(paren
id|proto
op_eq
id|IPPROTO_TCP
)paren
ques
c_cond
id|xprt_tcp_slot_table_entries
suffix:colon
id|xprt_udp_slot_table_entries
suffix:semicolon
r_if
c_cond
(paren
(paren
id|xprt
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|rpc_xprt
)paren
comma
id|GFP_KERNEL
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
id|memset
c_func
(paren
id|xprt
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|xprt
)paren
)paren
suffix:semicolon
multiline_comment|/* Nnnngh! */
id|xprt-&gt;max_reqs
op_assign
id|entries
suffix:semicolon
id|slot_table_size
op_assign
id|entries
op_star
r_sizeof
(paren
id|xprt-&gt;slot
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|xprt-&gt;slot
op_assign
id|kmalloc
c_func
(paren
id|slot_table_size
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|xprt-&gt;slot
op_eq
l_int|NULL
)paren
(brace
id|kfree
c_func
(paren
id|xprt
)paren
suffix:semicolon
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
)brace
id|memset
c_func
(paren
id|xprt-&gt;slot
comma
l_int|0
comma
id|slot_table_size
)paren
suffix:semicolon
id|xprt-&gt;addr
op_assign
op_star
id|ap
suffix:semicolon
id|xprt-&gt;prot
op_assign
id|proto
suffix:semicolon
id|xprt-&gt;stream
op_assign
(paren
id|proto
op_eq
id|IPPROTO_TCP
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|xprt-&gt;stream
)paren
(brace
id|xprt-&gt;cwnd
op_assign
id|RPC_MAXCWND
c_func
(paren
id|xprt
)paren
suffix:semicolon
id|xprt-&gt;nocong
op_assign
l_int|1
suffix:semicolon
)brace
r_else
id|xprt-&gt;cwnd
op_assign
id|RPC_INITCWND
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|xprt-&gt;sock_lock
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|xprt-&gt;xprt_lock
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|xprt-&gt;cong_wait
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|xprt-&gt;free
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|xprt-&gt;recv
)paren
suffix:semicolon
id|INIT_WORK
c_func
(paren
op_amp
id|xprt-&gt;sock_connect
comma
id|xprt_socket_connect
comma
id|xprt
)paren
suffix:semicolon
id|INIT_WORK
c_func
(paren
op_amp
id|xprt-&gt;task_cleanup
comma
id|xprt_socket_autoclose
comma
id|xprt
)paren
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|xprt-&gt;timer
)paren
suffix:semicolon
id|xprt-&gt;timer.function
op_assign
id|xprt_init_autodisconnect
suffix:semicolon
id|xprt-&gt;timer.data
op_assign
(paren
r_int
r_int
)paren
id|xprt
suffix:semicolon
id|xprt-&gt;last_used
op_assign
id|jiffies
suffix:semicolon
id|xprt-&gt;port
op_assign
id|XPRT_MAX_RESVPORT
suffix:semicolon
multiline_comment|/* Set timeout parameters */
r_if
c_cond
(paren
id|to
)paren
(brace
id|xprt-&gt;timeout
op_assign
op_star
id|to
suffix:semicolon
)brace
r_else
id|xprt_default_timeout
c_func
(paren
op_amp
id|xprt-&gt;timeout
comma
id|xprt-&gt;prot
)paren
suffix:semicolon
id|rpc_init_wait_queue
c_func
(paren
op_amp
id|xprt-&gt;pending
comma
l_string|&quot;xprt_pending&quot;
)paren
suffix:semicolon
id|rpc_init_wait_queue
c_func
(paren
op_amp
id|xprt-&gt;sending
comma
l_string|&quot;xprt_sending&quot;
)paren
suffix:semicolon
id|rpc_init_wait_queue
c_func
(paren
op_amp
id|xprt-&gt;resend
comma
l_string|&quot;xprt_resend&quot;
)paren
suffix:semicolon
id|rpc_init_priority_wait_queue
c_func
(paren
op_amp
id|xprt-&gt;backlog
comma
l_string|&quot;xprt_backlog&quot;
)paren
suffix:semicolon
multiline_comment|/* initialize free list */
r_for
c_loop
(paren
id|req
op_assign
op_amp
id|xprt-&gt;slot
(braket
id|entries
op_minus
l_int|1
)braket
suffix:semicolon
id|req
op_ge
op_amp
id|xprt-&gt;slot
(braket
l_int|0
)braket
suffix:semicolon
id|req
op_decrement
)paren
id|list_add
c_func
(paren
op_amp
id|req-&gt;rq_list
comma
op_amp
id|xprt-&gt;free
)paren
suffix:semicolon
id|xprt_init_xid
c_func
(paren
id|xprt
)paren
suffix:semicolon
multiline_comment|/* Check whether we want to use a reserved port */
id|xprt-&gt;resvport
op_assign
id|capable
c_func
(paren
id|CAP_NET_BIND_SERVICE
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;RPC:      created transport %p with %u slots&bslash;n&quot;
comma
id|xprt
comma
id|xprt-&gt;max_reqs
)paren
suffix:semicolon
r_return
id|xprt
suffix:semicolon
)brace
multiline_comment|/*&n; * Bind to a reserved port&n; */
DECL|function|xprt_bindresvport
r_static
r_inline
r_int
id|xprt_bindresvport
c_func
(paren
r_struct
id|rpc_xprt
op_star
id|xprt
comma
r_struct
id|socket
op_star
id|sock
)paren
(brace
r_struct
id|sockaddr_in
id|myaddr
op_assign
(brace
dot
id|sin_family
op_assign
id|AF_INET
comma
)brace
suffix:semicolon
r_int
id|err
comma
id|port
suffix:semicolon
multiline_comment|/* Were we already bound to a given port? Try to reuse it */
id|port
op_assign
id|xprt-&gt;port
suffix:semicolon
r_do
(brace
id|myaddr.sin_port
op_assign
id|htons
c_func
(paren
id|port
)paren
suffix:semicolon
id|err
op_assign
id|sock-&gt;ops
op_member_access_from_pointer
id|bind
c_func
(paren
id|sock
comma
(paren
r_struct
id|sockaddr
op_star
)paren
op_amp
id|myaddr
comma
r_sizeof
(paren
id|myaddr
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_eq
l_int|0
)paren
(brace
id|xprt-&gt;port
op_assign
id|port
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_decrement
id|port
op_eq
l_int|0
)paren
id|port
op_assign
id|XPRT_MAX_RESVPORT
suffix:semicolon
)brace
r_while
c_loop
(paren
id|err
op_eq
op_minus
id|EADDRINUSE
op_logical_and
id|port
op_ne
id|xprt-&gt;port
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;RPC: Can&squot;t bind to reserved port (%d).&bslash;n&quot;
comma
op_minus
id|err
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
r_static
r_void
DECL|function|xprt_bind_socket
id|xprt_bind_socket
c_func
(paren
r_struct
id|rpc_xprt
op_star
id|xprt
comma
r_struct
id|socket
op_star
id|sock
)paren
(brace
r_struct
id|sock
op_star
id|sk
op_assign
id|sock-&gt;sk
suffix:semicolon
r_if
c_cond
(paren
id|xprt-&gt;inet
)paren
r_return
suffix:semicolon
id|write_lock_bh
c_func
(paren
op_amp
id|sk-&gt;sk_callback_lock
)paren
suffix:semicolon
id|sk-&gt;sk_user_data
op_assign
id|xprt
suffix:semicolon
id|xprt-&gt;old_data_ready
op_assign
id|sk-&gt;sk_data_ready
suffix:semicolon
id|xprt-&gt;old_state_change
op_assign
id|sk-&gt;sk_state_change
suffix:semicolon
id|xprt-&gt;old_write_space
op_assign
id|sk-&gt;sk_write_space
suffix:semicolon
r_if
c_cond
(paren
id|xprt-&gt;prot
op_eq
id|IPPROTO_UDP
)paren
(brace
id|sk-&gt;sk_data_ready
op_assign
id|udp_data_ready
suffix:semicolon
id|sk-&gt;sk_no_check
op_assign
id|UDP_CSUM_NORCV
suffix:semicolon
id|xprt_set_connected
c_func
(paren
id|xprt
)paren
suffix:semicolon
)brace
r_else
(brace
id|tcp_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|nonagle
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* disable Nagle&squot;s algorithm */
id|sk-&gt;sk_data_ready
op_assign
id|tcp_data_ready
suffix:semicolon
id|sk-&gt;sk_state_change
op_assign
id|tcp_state_change
suffix:semicolon
id|xprt_clear_connected
c_func
(paren
id|xprt
)paren
suffix:semicolon
)brace
id|sk-&gt;sk_write_space
op_assign
id|xprt_write_space
suffix:semicolon
multiline_comment|/* Reset to new socket */
id|xprt-&gt;sock
op_assign
id|sock
suffix:semicolon
id|xprt-&gt;inet
op_assign
id|sk
suffix:semicolon
id|write_unlock_bh
c_func
(paren
op_amp
id|sk-&gt;sk_callback_lock
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * Set socket buffer length&n; */
r_void
DECL|function|xprt_sock_setbufsize
id|xprt_sock_setbufsize
c_func
(paren
r_struct
id|rpc_xprt
op_star
id|xprt
)paren
(brace
r_struct
id|sock
op_star
id|sk
op_assign
id|xprt-&gt;inet
suffix:semicolon
r_if
c_cond
(paren
id|xprt-&gt;stream
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|xprt-&gt;rcvsize
)paren
(brace
id|sk-&gt;sk_userlocks
op_or_assign
id|SOCK_RCVBUF_LOCK
suffix:semicolon
id|sk-&gt;sk_rcvbuf
op_assign
id|xprt-&gt;rcvsize
op_star
id|xprt-&gt;max_reqs
op_star
l_int|2
suffix:semicolon
)brace
r_if
c_cond
(paren
id|xprt-&gt;sndsize
)paren
(brace
id|sk-&gt;sk_userlocks
op_or_assign
id|SOCK_SNDBUF_LOCK
suffix:semicolon
id|sk-&gt;sk_sndbuf
op_assign
id|xprt-&gt;sndsize
op_star
id|xprt-&gt;max_reqs
op_star
l_int|2
suffix:semicolon
id|sk
op_member_access_from_pointer
id|sk_write_space
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Datastream sockets are created here, but xprt_connect will create&n; * and connect stream sockets.&n; */
DECL|function|xprt_create_socket
r_static
r_struct
id|socket
op_star
id|xprt_create_socket
c_func
(paren
r_struct
id|rpc_xprt
op_star
id|xprt
comma
r_int
id|proto
comma
r_int
id|resvport
)paren
(brace
r_struct
id|socket
op_star
id|sock
suffix:semicolon
r_int
id|type
comma
id|err
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;RPC:      xprt_create_socket(%s %d)&bslash;n&quot;
comma
(paren
id|proto
op_eq
id|IPPROTO_UDP
)paren
ques
c_cond
l_string|&quot;udp&quot;
suffix:colon
l_string|&quot;tcp&quot;
comma
id|proto
)paren
suffix:semicolon
id|type
op_assign
(paren
id|proto
op_eq
id|IPPROTO_UDP
)paren
ques
c_cond
id|SOCK_DGRAM
suffix:colon
id|SOCK_STREAM
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|sock_create_kern
c_func
(paren
id|PF_INET
comma
id|type
comma
id|proto
comma
op_amp
id|sock
)paren
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;RPC: can&squot;t create socket (%d).&bslash;n&quot;
comma
op_minus
id|err
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* If the caller has the capability, bind to a reserved port */
r_if
c_cond
(paren
id|resvport
op_logical_and
id|xprt_bindresvport
c_func
(paren
id|xprt
comma
id|sock
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;RPC: can&squot;t bind to reserved port.&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|failed
suffix:semicolon
)brace
r_return
id|sock
suffix:semicolon
id|failed
suffix:colon
id|sock_release
c_func
(paren
id|sock
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * Create an RPC client transport given the protocol and peer address.&n; */
r_struct
id|rpc_xprt
op_star
DECL|function|xprt_create_proto
id|xprt_create_proto
c_func
(paren
r_int
id|proto
comma
r_struct
id|sockaddr_in
op_star
id|sap
comma
r_struct
id|rpc_timeout
op_star
id|to
)paren
(brace
r_struct
id|rpc_xprt
op_star
id|xprt
suffix:semicolon
id|xprt
op_assign
id|xprt_setup
c_func
(paren
id|proto
comma
id|sap
comma
id|to
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|xprt
)paren
)paren
id|dprintk
c_func
(paren
l_string|&quot;RPC:      xprt_create_proto failed&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|dprintk
c_func
(paren
l_string|&quot;RPC:      xprt_create_proto created xprt %p&bslash;n&quot;
comma
id|xprt
)paren
suffix:semicolon
r_return
id|xprt
suffix:semicolon
)brace
multiline_comment|/*&n; * Prepare for transport shutdown.&n; */
r_static
r_void
DECL|function|xprt_shutdown
id|xprt_shutdown
c_func
(paren
r_struct
id|rpc_xprt
op_star
id|xprt
)paren
(brace
id|xprt-&gt;shutdown
op_assign
l_int|1
suffix:semicolon
id|rpc_wake_up
c_func
(paren
op_amp
id|xprt-&gt;sending
)paren
suffix:semicolon
id|rpc_wake_up
c_func
(paren
op_amp
id|xprt-&gt;resend
)paren
suffix:semicolon
id|rpc_wake_up
c_func
(paren
op_amp
id|xprt-&gt;pending
)paren
suffix:semicolon
id|rpc_wake_up
c_func
(paren
op_amp
id|xprt-&gt;backlog
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|xprt-&gt;cong_wait
)paren
suffix:semicolon
id|del_timer_sync
c_func
(paren
op_amp
id|xprt-&gt;timer
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Clear the xprt backlog queue&n; */
r_static
r_int
DECL|function|xprt_clear_backlog
id|xprt_clear_backlog
c_func
(paren
r_struct
id|rpc_xprt
op_star
id|xprt
)paren
(brace
id|rpc_wake_up_next
c_func
(paren
op_amp
id|xprt-&gt;backlog
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|xprt-&gt;cong_wait
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Destroy an RPC transport, killing off all requests.&n; */
r_int
DECL|function|xprt_destroy
id|xprt_destroy
c_func
(paren
r_struct
id|rpc_xprt
op_star
id|xprt
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;RPC:      destroying transport %p&bslash;n&quot;
comma
id|xprt
)paren
suffix:semicolon
id|xprt_shutdown
c_func
(paren
id|xprt
)paren
suffix:semicolon
id|xprt_disconnect
c_func
(paren
id|xprt
)paren
suffix:semicolon
id|xprt_close
c_func
(paren
id|xprt
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|xprt-&gt;slot
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|xprt
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
eof
