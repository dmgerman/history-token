multiline_comment|/*&n; * net/sunrpc/cache.c&n; *&n; * Generic code for various authentication-related caches&n; * used by sunrpc clients and servers.&n; *&n; * Copyright (C) 2002 Neil Brown &lt;neilb@cse.unsw.edu.au&gt;&n; *&n; * Released under terms in GPL version 2.  See COPYING.&n; *&n; */
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/file.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/signal.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/kmod.h&gt;
macro_line|#include &lt;linux/list.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;linux/sunrpc/types.h&gt;
macro_line|#include &lt;linux/sunrpc/cache.h&gt;
DECL|macro|RPCDBG_FACILITY
mdefine_line|#define&t; RPCDBG_FACILITY RPCDBG_CACHE
DECL|function|cache_init
r_void
id|cache_init
c_func
(paren
r_struct
id|cache_head
op_star
id|h
)paren
(brace
id|time_t
id|now
op_assign
id|CURRENT_TIME
suffix:semicolon
id|h-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|h-&gt;flags
op_assign
l_int|0
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|h-&gt;refcnt
comma
l_int|0
)paren
suffix:semicolon
id|h-&gt;expiry_time
op_assign
id|now
op_plus
id|CACHE_NEW_EXPIRY
suffix:semicolon
id|h-&gt;last_refresh
op_assign
id|now
suffix:semicolon
)brace
multiline_comment|/*&n; * This is the generic cache management routine for all&n; * the authentication caches.&n; * It checks the currency of a cache item and will (later)&n; * initiate an upcall to fill it if needed.&n; *&n; *&n; * Returns 0 if the cache_head can be used, or cache_puts it and returns&n; * -EAGAIN if upcall is pending,&n; * -ENOENT if cache entry was negative&n; */
DECL|function|cache_check
r_int
id|cache_check
c_func
(paren
r_struct
id|cache_detail
op_star
id|detail
comma
r_struct
id|cache_head
op_star
id|h
)paren
(brace
r_int
id|rv
suffix:semicolon
multiline_comment|/* First decide return status as best we can */
r_if
c_cond
(paren
op_logical_neg
id|test_bit
c_func
(paren
id|CACHE_VALID
comma
op_amp
id|h-&gt;flags
)paren
op_logical_or
id|h-&gt;expiry_time
OL
id|CURRENT_TIME
)paren
id|rv
op_assign
op_minus
id|EAGAIN
suffix:semicolon
r_else
r_if
c_cond
(paren
id|detail-&gt;flush_time
OG
id|h-&gt;last_refresh
)paren
id|rv
op_assign
op_minus
id|EAGAIN
suffix:semicolon
r_else
(brace
multiline_comment|/* entry is valid */
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|CACHE_NEGATIVE
comma
op_amp
id|h-&gt;flags
)paren
)paren
id|rv
op_assign
op_minus
id|ENOENT
suffix:semicolon
r_else
id|rv
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* up-call processing goes here later */
r_if
c_cond
(paren
id|rv
op_eq
op_minus
id|EAGAIN
multiline_comment|/* &amp;&amp; cannot do upcall */
)paren
id|rv
op_assign
op_minus
id|ENOENT
suffix:semicolon
r_if
c_cond
(paren
id|rv
op_logical_and
id|h
)paren
id|detail
op_member_access_from_pointer
id|cache_put
c_func
(paren
id|h
comma
id|detail
)paren
suffix:semicolon
r_return
id|rv
suffix:semicolon
)brace
DECL|function|cache_fresh
r_void
id|cache_fresh
c_func
(paren
r_struct
id|cache_detail
op_star
id|detail
comma
r_struct
id|cache_head
op_star
id|head
comma
id|time_t
id|expiry
)paren
(brace
id|head-&gt;expiry_time
op_assign
id|expiry
suffix:semicolon
id|head-&gt;last_refresh
op_assign
id|CURRENT_TIME
suffix:semicolon
id|set_bit
c_func
(paren
id|CACHE_VALID
comma
op_amp
id|head-&gt;flags
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|CACHE_PENDING
comma
op_amp
id|head-&gt;flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * caches need to be periodically cleaned.&n; * For this we maintain a list of cache_detail and&n; * a current pointer into that list and into the table&n; * for that entry.&n; *&n; * Each time clean_cache is called it finds the next non-empty entry&n; * in the current table and walks the list in that entry&n; * looking for entries that can be removed.&n; *&n; * An entry gets removed if:&n; * - The expiry is before current time&n; * - The last_refresh time is before the flush_time for that cache&n; *&n; * later we might drop old entries with non-NEVER expiry if that table&n; * is getting &squot;full&squot; for some definition of &squot;full&squot;&n; *&n; * The question of &quot;how often to scan a table&quot; is an interesting one&n; * and is answered in part by the use of the &quot;nextcheck&quot; field in the&n; * cache_detail.&n; * When a scan of a table begins, the nextcheck field is set to a time&n; * that is well into the future.&n; * While scanning, if an expiry time is found that is earlier than the&n; * current nextcheck time, nextcheck is set to that expiry time.&n; * If the flush_time is ever set to a time earlier than the nextcheck&n; * time, the nextcheck time is then set to that flush_time.&n; *&n; * A table is then only scanned if the current time is at least&n; * the nextcheck time.&n; * &n; */
r_static
id|LIST_HEAD
c_func
(paren
id|cache_list
)paren
suffix:semicolon
DECL|variable|cache_list_lock
r_static
id|spinlock_t
id|cache_list_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
DECL|variable|current_detail
r_static
r_struct
id|cache_detail
op_star
id|current_detail
suffix:semicolon
DECL|variable|current_index
r_static
r_int
id|current_index
suffix:semicolon
DECL|function|cache_register
r_void
id|cache_register
c_func
(paren
r_struct
id|cache_detail
op_star
id|cd
)paren
(brace
id|rwlock_init
c_func
(paren
op_amp
id|cd-&gt;hash_lock
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|cache_list_lock
)paren
suffix:semicolon
id|cd-&gt;nextcheck
op_assign
l_int|0
suffix:semicolon
id|cd-&gt;entries
op_assign
l_int|0
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|cd-&gt;others
comma
op_amp
id|cache_list
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|cache_list_lock
)paren
suffix:semicolon
)brace
DECL|function|cache_unregister
r_int
id|cache_unregister
c_func
(paren
r_struct
id|cache_detail
op_star
id|cd
)paren
(brace
id|cache_purge
c_func
(paren
id|cd
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|cache_list_lock
)paren
suffix:semicolon
id|write_lock
c_func
(paren
op_amp
id|cd-&gt;hash_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cd-&gt;entries
op_logical_or
id|atomic_read
c_func
(paren
op_amp
id|cd-&gt;inuse
)paren
)paren
(brace
id|write_unlock
c_func
(paren
op_amp
id|cd-&gt;hash_lock
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|cache_list_lock
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
r_if
c_cond
(paren
id|current_detail
op_eq
id|cd
)paren
id|current_detail
op_assign
l_int|NULL
suffix:semicolon
id|list_del_init
c_func
(paren
op_amp
id|cd-&gt;others
)paren
suffix:semicolon
id|write_unlock
c_func
(paren
op_amp
id|cd-&gt;hash_lock
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|cache_list_lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cache_find
r_struct
id|cache_detail
op_star
id|cache_find
c_func
(paren
r_char
op_star
id|name
)paren
(brace
r_struct
id|list_head
op_star
id|l
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|cache_list_lock
)paren
suffix:semicolon
id|list_for_each
c_func
(paren
id|l
comma
op_amp
id|cache_list
)paren
(brace
r_struct
id|cache_detail
op_star
id|cd
op_assign
id|list_entry
c_func
(paren
id|l
comma
r_struct
id|cache_detail
comma
id|others
)paren
suffix:semicolon
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|cd-&gt;name
comma
id|name
)paren
op_eq
l_int|0
)paren
(brace
id|atomic_inc
c_func
(paren
op_amp
id|cd-&gt;inuse
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|cache_list_lock
)paren
suffix:semicolon
r_return
id|cd
suffix:semicolon
)brace
)brace
id|spin_unlock
c_func
(paren
op_amp
id|cache_list_lock
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* cache_drop must be called on any cache returned by&n; * cache_find, after it has been used&n; */
DECL|function|cache_drop
r_void
id|cache_drop
c_func
(paren
r_struct
id|cache_detail
op_star
id|detail
)paren
(brace
id|atomic_dec
c_func
(paren
op_amp
id|detail-&gt;inuse
)paren
suffix:semicolon
)brace
multiline_comment|/* clean cache tries to find something to clean&n; * and cleans it.&n; * It returns 1 if it cleaned something,&n; *            0 if it didn&squot;t find anything this time&n; *           -1 if it fell off the end of the list.&n; */
DECL|function|cache_clean
r_int
id|cache_clean
c_func
(paren
r_void
)paren
(brace
r_int
id|rv
op_assign
l_int|0
suffix:semicolon
r_struct
id|list_head
op_star
id|next
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|cache_list_lock
)paren
suffix:semicolon
multiline_comment|/* find a suitable table if we don&squot;t already have one */
r_while
c_loop
(paren
id|current_detail
op_eq
l_int|NULL
op_logical_or
id|current_index
op_ge
id|current_detail-&gt;hash_size
)paren
(brace
r_if
c_cond
(paren
id|current_detail
)paren
id|next
op_assign
id|current_detail-&gt;others.next
suffix:semicolon
r_else
id|next
op_assign
id|cache_list.next
suffix:semicolon
r_if
c_cond
(paren
id|next
op_eq
op_amp
id|cache_list
)paren
(brace
id|current_detail
op_assign
l_int|NULL
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|cache_list_lock
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|current_detail
op_assign
id|list_entry
c_func
(paren
id|next
comma
r_struct
id|cache_detail
comma
id|others
)paren
suffix:semicolon
r_if
c_cond
(paren
id|current_detail-&gt;nextcheck
OG
id|CURRENT_TIME
)paren
id|current_index
op_assign
id|current_detail-&gt;hash_size
suffix:semicolon
r_else
(brace
id|current_index
op_assign
l_int|0
suffix:semicolon
id|current_detail-&gt;nextcheck
op_assign
id|CURRENT_TIME
op_plus
l_int|30
op_star
l_int|60
suffix:semicolon
)brace
)brace
multiline_comment|/* find a non-empty bucket in the table */
r_while
c_loop
(paren
id|current_detail
op_logical_and
id|current_index
OL
id|current_detail-&gt;hash_size
op_logical_and
id|current_detail-&gt;hash_table
(braket
id|current_index
)braket
op_eq
l_int|NULL
)paren
id|current_index
op_increment
suffix:semicolon
multiline_comment|/* find a cleanable entry in the bucket and clean it, or set to next bucket */
r_if
c_cond
(paren
id|current_detail
op_logical_and
id|current_index
OL
id|current_detail-&gt;hash_size
)paren
(brace
r_struct
id|cache_head
op_star
id|ch
comma
op_star
op_star
id|cp
suffix:semicolon
id|write_lock
c_func
(paren
op_amp
id|current_detail-&gt;hash_lock
)paren
suffix:semicolon
multiline_comment|/* Ok, now to clean this strand */
id|cp
op_assign
op_amp
id|current_detail-&gt;hash_table
(braket
id|current_index
)braket
suffix:semicolon
id|ch
op_assign
op_star
id|cp
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|ch
suffix:semicolon
id|cp
op_assign
op_amp
id|ch-&gt;next
comma
id|ch
op_assign
op_star
id|cp
)paren
(brace
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|ch-&gt;refcnt
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|ch-&gt;expiry_time
OL
id|CURRENT_TIME
op_logical_or
id|ch-&gt;last_refresh
OL
id|current_detail-&gt;flush_time
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|current_detail-&gt;nextcheck
OG
id|ch-&gt;expiry_time
)paren
id|current_detail-&gt;nextcheck
op_assign
id|ch-&gt;expiry_time
op_plus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ch
)paren
(brace
id|cache_get
c_func
(paren
id|ch
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|CACHE_HASHED
comma
op_amp
id|ch-&gt;flags
)paren
suffix:semicolon
op_star
id|cp
op_assign
id|ch-&gt;next
suffix:semicolon
id|ch-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|current_detail-&gt;entries
op_decrement
suffix:semicolon
id|rv
op_assign
l_int|1
suffix:semicolon
)brace
id|write_unlock
c_func
(paren
op_amp
id|current_detail-&gt;hash_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ch
)paren
id|current_detail
op_member_access_from_pointer
id|cache_put
c_func
(paren
id|ch
comma
id|current_detail
)paren
suffix:semicolon
r_else
id|current_index
op_increment
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|cache_list_lock
)paren
suffix:semicolon
r_return
id|rv
suffix:semicolon
)brace
multiline_comment|/* &n; * Clean all caches promptly.  This just calls cache_clean&n; * repeatedly until we are sure that every cache has had a chance to &n; * be fully cleaned&n; */
DECL|function|cache_flush
r_void
id|cache_flush
c_func
(paren
r_void
)paren
(brace
r_while
c_loop
(paren
id|cache_clean
c_func
(paren
)paren
op_ne
op_minus
l_int|1
)paren
id|cond_resched
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|cache_clean
c_func
(paren
)paren
op_ne
op_minus
l_int|1
)paren
id|cond_resched
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|cache_purge
r_void
id|cache_purge
c_func
(paren
r_struct
id|cache_detail
op_star
id|detail
)paren
(brace
id|detail-&gt;flush_time
op_assign
id|CURRENT_TIME
op_plus
l_int|1
suffix:semicolon
id|detail-&gt;nextcheck
op_assign
id|CURRENT_TIME
suffix:semicolon
id|cache_flush
c_func
(paren
)paren
suffix:semicolon
)brace
eof
