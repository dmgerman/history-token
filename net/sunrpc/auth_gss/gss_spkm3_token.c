multiline_comment|/*&n; *  linux/net/sunrpc/gss_spkm3_token.c&n; *&n; *  Copyright (c) 2003 The Regents of the University of Michigan.&n; *  All rights reserved.&n; *&n; *  Andy Adamson &lt;andros@umich.edu&gt;&n; *&n; *  Redistribution and use in source and binary forms, with or without&n; *  modification, are permitted provided that the following conditions&n; *  are met:&n; *&n; *  1. Redistributions of source code must retain the above copyright&n; *     notice, this list of conditions and the following disclaimer.&n; *  2. Redistributions in binary form must reproduce the above copyright&n; *     notice, this list of conditions and the following disclaimer in the&n; *     documentation and/or other materials provided with the distribution.&n; *  3. Neither the name of the University nor the names of its&n; *     contributors may be used to endorse or promote products derived&n; *     from this software without specific prior written permission.&n; *&n; *  THIS SOFTWARE IS PROVIDED ``AS IS&squot;&squot; AND ANY EXPRESS OR IMPLIED&n; *  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF&n; *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE&n; *  DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE&n; *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR&n; *  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF&n; *  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR&n; *  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF&n; *  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING&n; *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS&n; *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.&n; *&n; */
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/jiffies.h&gt;
macro_line|#include &lt;linux/sunrpc/gss_spkm3.h&gt;
macro_line|#include &lt;linux/random.h&gt;
macro_line|#include &lt;linux/crypto.h&gt;
macro_line|#ifdef RPC_DEBUG
DECL|macro|RPCDBG_FACILITY
macro_line|# define RPCDBG_FACILITY        RPCDBG_AUTH
macro_line|#endif
multiline_comment|/*&n; * asn1_bitstring_len()&n; *&n; * calculate the asn1 bitstring length of the xdr_netobject&n; */
r_void
DECL|function|asn1_bitstring_len
id|asn1_bitstring_len
c_func
(paren
r_struct
id|xdr_netobj
op_star
id|in
comma
r_int
op_star
id|enclen
comma
r_int
op_star
id|zerobits
)paren
(brace
r_int
id|i
comma
id|zbit
op_assign
l_int|0
comma
id|elen
op_assign
id|in-&gt;len
suffix:semicolon
r_char
op_star
id|ptr
suffix:semicolon
id|ptr
op_assign
op_amp
id|in-&gt;data
(braket
id|in-&gt;len
op_minus
l_int|1
)braket
suffix:semicolon
multiline_comment|/* count trailing 0&squot;s */
r_for
c_loop
(paren
id|i
op_assign
id|in-&gt;len
suffix:semicolon
id|i
OG
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
r_if
c_cond
(paren
op_star
id|ptr
op_eq
l_int|0
)paren
(brace
id|ptr
op_decrement
suffix:semicolon
id|elen
op_decrement
suffix:semicolon
)brace
r_else
r_break
suffix:semicolon
)brace
multiline_comment|/* count number of 0 bits in final octet */
id|ptr
op_assign
op_amp
id|in-&gt;data
(braket
id|elen
op_minus
l_int|1
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|mask
op_assign
l_int|0x01
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|mask
op_lshift
id|i
)paren
op_amp
op_star
id|ptr
)paren
)paren
id|zbit
op_increment
suffix:semicolon
r_else
r_break
suffix:semicolon
)brace
op_star
id|enclen
op_assign
id|elen
suffix:semicolon
op_star
id|zerobits
op_assign
id|zbit
suffix:semicolon
)brace
multiline_comment|/*&n; * decode_asn1_bitstring()&n; * &n; * decode a bitstring into a buffer of the expected length.&n; * enclen = bit string length&n; * explen = expected length (define in rfc)&n; */
r_int
DECL|function|decode_asn1_bitstring
id|decode_asn1_bitstring
c_func
(paren
r_struct
id|xdr_netobj
op_star
id|out
comma
r_char
op_star
id|in
comma
r_int
id|enclen
comma
r_int
id|explen
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|out-&gt;data
op_assign
id|kmalloc
c_func
(paren
id|explen
comma
id|GFP_KERNEL
)paren
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|out-&gt;len
op_assign
id|explen
suffix:semicolon
id|memset
c_func
(paren
id|out-&gt;data
comma
l_int|0
comma
id|explen
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|out-&gt;data
comma
id|in
comma
id|enclen
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* &n; * SPKMInnerContextToken choice SPKM_MIC asn1 token layout&n; * &n; * contextid is always 16 bytes plain data. max asn1 bitstring len = 17.&n; *&n; * tokenlen = pos[0] to end of token (max pos[45] with MD5 cksum)&n; *&n; * pos  value&n; * ----------&n; * [0]&t;a4  SPKM-MIC tag&n; * [1]&t;??  innertoken length  (max 44) &n; * &n; * &n; * tok_hdr piece of checksum data starts here &n; *&n; * the maximum mic-header len = 9 + 17 = 26 &n; *&t;mic-header&n; *&t;----------&n; * [2]&t;30      SEQUENCE tag  &n; * [3]&t;??&t;mic-header length: (max 23) = TokenID + ContextID &n; *&n; *&t;&t;TokenID  - all fields constant and can be hardcoded&n; *&t;&t;-------&n; * [4]&t;  02&t;Type 2&n; * [5]&t;  02&t;Length 2 &n; * [6][7] 01 01&t;TokenID (SPKM_MIC_TOK)&n; *&n; *&t;&t;ContextID  - encoded length not constant, calculated&n; *&t;&t;---------&n; * [8]&t;03&t;Type 3&n; * [9]&t;??&t;encoded length&n; * [10]&t;??&t;ctxzbit&n; * [11]&t; &t;contextid&n; *&n; * mic_header piece of checksum data ends here. &n; *&n; *&t;int-cksum - encoded length not constant, calculated&n; *&t;---------&n; * [??]&t;03&t;Type 3&n; * [??]&t;??&t;encoded length &n; * [??]&t;??&t;md5zbit&t;&t;&n; * [??]&t; &t;int-cksum (NID_md5 = 16)&n; *&n; * maximum SPKM-MIC innercontext token length = &n; *&t; 10 + encoded contextid_size(17 max) + 2 + encoded  &n; *       cksum_size (17 maxfor NID_md5) = 46&n; */
multiline_comment|/*&n; * spkm3_mic_header()&n; *&n; * Prepare the SPKM_MIC_TOK mic-header for check-sum calculation&n; * elen: 16 byte context id asn1 bitstring encoded length&n; */
r_void
DECL|function|spkm3_mic_header
id|spkm3_mic_header
c_func
(paren
r_int
r_char
op_star
op_star
id|hdrbuf
comma
r_int
r_int
op_star
id|hdrlen
comma
r_int
r_char
op_star
id|ctxdata
comma
r_int
id|elen
comma
r_int
id|zbit
)paren
(brace
r_char
op_star
id|hptr
op_assign
op_star
id|hdrbuf
suffix:semicolon
r_char
op_star
id|top
op_assign
op_star
id|hdrbuf
suffix:semicolon
op_star
(paren
id|u8
op_star
)paren
id|hptr
op_increment
op_assign
l_int|0x30
suffix:semicolon
op_star
(paren
id|u8
op_star
)paren
id|hptr
op_increment
op_assign
id|elen
op_plus
l_int|7
suffix:semicolon
multiline_comment|/* on the wire header length */
multiline_comment|/* tokenid */
op_star
(paren
id|u8
op_star
)paren
id|hptr
op_increment
op_assign
l_int|0x02
suffix:semicolon
op_star
(paren
id|u8
op_star
)paren
id|hptr
op_increment
op_assign
l_int|0x02
suffix:semicolon
op_star
(paren
id|u8
op_star
)paren
id|hptr
op_increment
op_assign
l_int|0x01
suffix:semicolon
op_star
(paren
id|u8
op_star
)paren
id|hptr
op_increment
op_assign
l_int|0x01
suffix:semicolon
multiline_comment|/* coniextid */
op_star
(paren
id|u8
op_star
)paren
id|hptr
op_increment
op_assign
l_int|0x03
suffix:semicolon
op_star
(paren
id|u8
op_star
)paren
id|hptr
op_increment
op_assign
id|elen
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* add 1 to include zbit */
op_star
(paren
id|u8
op_star
)paren
id|hptr
op_increment
op_assign
id|zbit
suffix:semicolon
id|memcpy
c_func
(paren
id|hptr
comma
id|ctxdata
comma
id|elen
)paren
suffix:semicolon
id|hptr
op_add_assign
id|elen
suffix:semicolon
op_star
id|hdrlen
op_assign
id|hptr
op_minus
id|top
suffix:semicolon
)brace
multiline_comment|/* &n; * spkm3_mic_innercontext_token()&n; *&n; * *tokp points to the beginning of the SPKM_MIC token  described &n; * in rfc 2025, section 3.2.1: &n; *&n; */
r_void
DECL|function|spkm3_make_mic_token
id|spkm3_make_mic_token
c_func
(paren
r_int
r_char
op_star
op_star
id|tokp
comma
r_int
id|toklen
comma
r_struct
id|xdr_netobj
op_star
id|mic_hdr
comma
r_struct
id|xdr_netobj
op_star
id|md5cksum
comma
r_int
id|md5elen
comma
r_int
id|md5zbit
)paren
(brace
r_int
r_char
op_star
id|ict
op_assign
op_star
id|tokp
suffix:semicolon
op_star
(paren
id|u8
op_star
)paren
id|ict
op_increment
op_assign
l_int|0xa4
suffix:semicolon
op_star
(paren
id|u8
op_star
)paren
id|ict
op_increment
op_assign
id|toklen
op_minus
l_int|2
suffix:semicolon
id|memcpy
c_func
(paren
id|ict
comma
id|mic_hdr-&gt;data
comma
id|mic_hdr-&gt;len
)paren
suffix:semicolon
id|ict
op_add_assign
id|mic_hdr-&gt;len
suffix:semicolon
op_star
(paren
id|u8
op_star
)paren
id|ict
op_increment
op_assign
l_int|0x03
suffix:semicolon
op_star
(paren
id|u8
op_star
)paren
id|ict
op_increment
op_assign
id|md5elen
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* add 1 to include zbit */
op_star
(paren
id|u8
op_star
)paren
id|ict
op_increment
op_assign
id|md5zbit
suffix:semicolon
id|memcpy
c_func
(paren
id|ict
comma
id|md5cksum-&gt;data
comma
id|md5elen
)paren
suffix:semicolon
)brace
id|u32
DECL|function|spkm3_verify_mic_token
id|spkm3_verify_mic_token
c_func
(paren
r_int
r_char
op_star
op_star
id|tokp
comma
r_int
op_star
id|mic_hdrlen
comma
r_int
r_char
op_star
op_star
id|cksum
)paren
(brace
r_struct
id|xdr_netobj
id|spkm3_ctx_id
op_assign
(brace
dot
id|len
op_assign
l_int|0
comma
dot
id|data
op_assign
l_int|NULL
)brace
suffix:semicolon
r_int
r_char
op_star
id|ptr
op_assign
op_star
id|tokp
suffix:semicolon
r_int
id|ctxelen
suffix:semicolon
id|u32
id|ret
op_assign
id|GSS_S_DEFECTIVE_TOKEN
suffix:semicolon
multiline_comment|/* spkm3 innercontext token preamble */
r_if
c_cond
(paren
(paren
id|ptr
(braket
l_int|0
)braket
op_ne
l_int|0xa4
)paren
op_logical_or
(paren
id|ptr
(braket
l_int|2
)braket
op_ne
l_int|0x30
)paren
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;RPC: BAD SPKM ictoken preamble&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
op_star
id|mic_hdrlen
op_assign
id|ptr
(braket
l_int|3
)braket
suffix:semicolon
multiline_comment|/* token type */
r_if
c_cond
(paren
(paren
id|ptr
(braket
l_int|4
)braket
op_ne
l_int|0x02
)paren
op_logical_or
(paren
id|ptr
(braket
l_int|5
)braket
op_ne
l_int|0x02
)paren
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;RPC: BAD asn1 SPKM3 token type&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* only support SPKM_MIC_TOK */
r_if
c_cond
(paren
(paren
id|ptr
(braket
l_int|6
)braket
op_ne
l_int|0x01
)paren
op_logical_or
(paren
id|ptr
(braket
l_int|7
)braket
op_ne
l_int|0x01
)paren
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;RPC: ERROR unsupported SPKM3 token &bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* contextid */
r_if
c_cond
(paren
id|ptr
(braket
l_int|8
)braket
op_ne
l_int|0x03
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;RPC: BAD SPKM3 asn1 context-id type&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|ctxelen
op_assign
id|ptr
(braket
l_int|9
)braket
suffix:semicolon
r_if
c_cond
(paren
id|ctxelen
OG
l_int|17
)paren
(brace
multiline_comment|/* length includes asn1 zbit octet */
id|dprintk
c_func
(paren
l_string|&quot;RPC: BAD SPKM3 contextid len %d&bslash;n&quot;
comma
id|ctxelen
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* ignore ptr[10] */
r_if
c_cond
(paren
op_logical_neg
id|decode_asn1_bitstring
c_func
(paren
op_amp
id|spkm3_ctx_id
comma
op_amp
id|ptr
(braket
l_int|11
)braket
comma
id|ctxelen
op_minus
l_int|1
comma
l_int|16
)paren
)paren
(brace
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n;&t;* in the current implementation: the optional int-alg is not present &n;&t;* so the default int-alg (md5) is used the optional snd-seq field is &n;&t;* also not present &n;&t;*/
r_if
c_cond
(paren
op_star
id|mic_hdrlen
op_ne
l_int|6
op_plus
id|ctxelen
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;RPC: BAD SPKM_ MIC_TOK header len %d: we only support default int-alg (should be absent) and do not support snd-seq&bslash;n&quot;
comma
op_star
id|mic_hdrlen
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* checksum */
op_star
id|cksum
op_assign
(paren
op_amp
id|ptr
(braket
l_int|10
)braket
op_plus
id|ctxelen
)paren
suffix:semicolon
multiline_comment|/* ctxelen includes ptr[10] */
id|ret
op_assign
id|GSS_S_COMPLETE
suffix:semicolon
id|out
suffix:colon
r_if
c_cond
(paren
id|spkm3_ctx_id.data
)paren
id|kfree
c_func
(paren
id|spkm3_ctx_id.data
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
eof
