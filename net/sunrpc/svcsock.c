multiline_comment|/*&n; * linux/net/sunrpc/svcsock.c&n; *&n; * These are the RPC server socket internals.&n; *&n; * The server scheduling algorithm does not always distribute the load&n; * evenly when servicing a single client. May need to modify the&n; * svc_sock_enqueue procedure...&n; *&n; * TCP support is largely untested and may be a little slow. The problem&n; * is that we currently do two separate recvfrom&squot;s, one for the 4-byte&n; * record length, and the second for the actual record. This could possibly&n; * be improved by always reading a minimum size of around 100 bytes and&n; * tucking any superfluous bytes away in a temporary store. Still, that&n; * leaves write requests out in the rain. An alternative may be to peek at&n; * the first skb in the queue, and if it matches the next TCP sequence&n; * number, to extract the record marker. Yuck.&n; *&n; * Copyright (C) 1995, 1996 Olaf Kirch &lt;okir@monad.swb.de&gt;&n; */
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/net.h&gt;
macro_line|#include &lt;linux/in.h&gt;
macro_line|#include &lt;linux/inet.h&gt;
macro_line|#include &lt;linux/udp.h&gt;
macro_line|#include &lt;linux/tcp.h&gt;
macro_line|#include &lt;linux/unistd.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;net/sock.h&gt;
macro_line|#include &lt;net/checksum.h&gt;
macro_line|#include &lt;net/ip.h&gt;
macro_line|#include &lt;net/tcp.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/ioctls.h&gt;
macro_line|#include &lt;linux/sunrpc/types.h&gt;
macro_line|#include &lt;linux/sunrpc/xdr.h&gt;
macro_line|#include &lt;linux/sunrpc/svcsock.h&gt;
macro_line|#include &lt;linux/sunrpc/stats.h&gt;
multiline_comment|/* SMP locking strategy:&n; *&n; * &t;svc_serv-&gt;sv_lock protects most stuff for that service.&n; *&n; *&t;Some flags can be set to certain values at any time&n; *&t;providing that certain rules are followed:&n; *&n; *&t;SK_BUSY  can be set to 0 at any time.  &n; *&t;&t;svc_sock_enqueue must be called afterwards&n; *&t;SK_CONN, SK_DATA, can be set or cleared at any time.&n; *&t;&t;after a set, svc_sock_enqueue must be called.&t;&n; *&t;&t;after a clear, the socket must be read/accepted&n; *&t;&t; if this succeeds, it must be set again.&n; *&t;SK_CLOSE can set at any time. It is never cleared.&n; *&n; */
DECL|macro|RPCDBG_FACILITY
mdefine_line|#define RPCDBG_FACILITY&t;RPCDBG_SVCSOCK
r_static
r_struct
id|svc_sock
op_star
id|svc_setup_socket
c_func
(paren
r_struct
id|svc_serv
op_star
comma
r_struct
id|socket
op_star
comma
r_int
op_star
id|errp
comma
r_int
id|pmap_reg
)paren
suffix:semicolon
r_static
r_void
id|svc_udp_data_ready
c_func
(paren
r_struct
id|sock
op_star
comma
r_int
)paren
suffix:semicolon
r_static
r_int
id|svc_udp_recvfrom
c_func
(paren
r_struct
id|svc_rqst
op_star
)paren
suffix:semicolon
r_static
r_int
id|svc_udp_sendto
c_func
(paren
r_struct
id|svc_rqst
op_star
)paren
suffix:semicolon
r_static
r_struct
id|svc_deferred_req
op_star
id|svc_deferred_dequeue
c_func
(paren
r_struct
id|svc_sock
op_star
id|svsk
)paren
suffix:semicolon
r_static
r_int
id|svc_deferred_recv
c_func
(paren
r_struct
id|svc_rqst
op_star
id|rqstp
)paren
suffix:semicolon
r_static
r_struct
id|cache_deferred_req
op_star
id|svc_defer
c_func
(paren
r_struct
id|cache_req
op_star
id|req
)paren
suffix:semicolon
multiline_comment|/*&n; * Queue up an idle server thread.  Must have serv-&gt;sv_lock held.&n; * Note: this is really a stack rather than a queue, so that we only&n; * use as many different threads as we need, and the rest don&squot;t polute&n; * the cache.&n; */
r_static
r_inline
r_void
DECL|function|svc_serv_enqueue
id|svc_serv_enqueue
c_func
(paren
r_struct
id|svc_serv
op_star
id|serv
comma
r_struct
id|svc_rqst
op_star
id|rqstp
)paren
(brace
id|list_add
c_func
(paren
op_amp
id|rqstp-&gt;rq_list
comma
op_amp
id|serv-&gt;sv_threads
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Dequeue an nfsd thread.  Must have serv-&gt;sv_lock held.&n; */
r_static
r_inline
r_void
DECL|function|svc_serv_dequeue
id|svc_serv_dequeue
c_func
(paren
r_struct
id|svc_serv
op_star
id|serv
comma
r_struct
id|svc_rqst
op_star
id|rqstp
)paren
(brace
id|list_del
c_func
(paren
op_amp
id|rqstp-&gt;rq_list
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Release an skbuff after use&n; */
r_static
r_inline
r_void
DECL|function|svc_release_skb
id|svc_release_skb
c_func
(paren
r_struct
id|svc_rqst
op_star
id|rqstp
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
op_assign
id|rqstp-&gt;rq_skbuff
suffix:semicolon
r_struct
id|svc_deferred_req
op_star
id|dr
op_assign
id|rqstp-&gt;rq_deferred
suffix:semicolon
r_if
c_cond
(paren
id|skb
)paren
(brace
id|rqstp-&gt;rq_skbuff
op_assign
l_int|NULL
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;svc: service %p, releasing skb %p&bslash;n&quot;
comma
id|rqstp
comma
id|skb
)paren
suffix:semicolon
id|skb_free_datagram
c_func
(paren
id|rqstp-&gt;rq_sock-&gt;sk_sk
comma
id|skb
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dr
)paren
(brace
id|rqstp-&gt;rq_deferred
op_assign
l_int|NULL
suffix:semicolon
id|kfree
c_func
(paren
id|dr
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Any space to write?&n; */
r_static
r_inline
r_int
r_int
DECL|function|svc_sock_wspace
id|svc_sock_wspace
c_func
(paren
r_struct
id|svc_sock
op_star
id|svsk
)paren
(brace
r_int
id|wspace
suffix:semicolon
r_if
c_cond
(paren
id|svsk-&gt;sk_sock-&gt;type
op_eq
id|SOCK_STREAM
)paren
id|wspace
op_assign
id|sk_stream_wspace
c_func
(paren
id|svsk-&gt;sk_sk
)paren
suffix:semicolon
r_else
id|wspace
op_assign
id|sock_wspace
c_func
(paren
id|svsk-&gt;sk_sk
)paren
suffix:semicolon
r_return
id|wspace
suffix:semicolon
)brace
multiline_comment|/*&n; * Queue up a socket with data pending. If there are idle nfsd&n; * processes, wake &squot;em up.&n; *&n; */
r_static
r_void
DECL|function|svc_sock_enqueue
id|svc_sock_enqueue
c_func
(paren
r_struct
id|svc_sock
op_star
id|svsk
)paren
(brace
r_struct
id|svc_serv
op_star
id|serv
op_assign
id|svsk-&gt;sk_server
suffix:semicolon
r_struct
id|svc_rqst
op_star
id|rqstp
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|svsk-&gt;sk_flags
op_amp
(paren
(paren
l_int|1
op_lshift
id|SK_CONN
)paren
op_or
(paren
l_int|1
op_lshift
id|SK_DATA
)paren
op_or
(paren
l_int|1
op_lshift
id|SK_CLOSE
)paren
op_or
(paren
l_int|1
op_lshift
id|SK_DEFERRED
)paren
)paren
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|SK_DEAD
comma
op_amp
id|svsk-&gt;sk_flags
)paren
)paren
r_return
suffix:semicolon
id|spin_lock_bh
c_func
(paren
op_amp
id|serv-&gt;sv_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|serv-&gt;sv_threads
)paren
op_logical_and
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|serv-&gt;sv_sockets
)paren
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;svc_sock_enqueue: threads and sockets both waiting??&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|SK_DEAD
comma
op_amp
id|svsk-&gt;sk_flags
)paren
)paren
(brace
multiline_comment|/* Don&squot;t enqueue dead sockets */
id|dprintk
c_func
(paren
l_string|&quot;svc: socket %p is dead, not enqueued&bslash;n&quot;
comma
id|svsk-&gt;sk_sk
)paren
suffix:semicolon
r_goto
id|out_unlock
suffix:semicolon
)brace
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|SK_BUSY
comma
op_amp
id|svsk-&gt;sk_flags
)paren
)paren
(brace
multiline_comment|/* Don&squot;t enqueue socket while daemon is receiving */
id|dprintk
c_func
(paren
l_string|&quot;svc: socket %p busy, not enqueued&bslash;n&quot;
comma
id|svsk-&gt;sk_sk
)paren
suffix:semicolon
r_goto
id|out_unlock
suffix:semicolon
)brace
id|set_bit
c_func
(paren
id|SOCK_NOSPACE
comma
op_amp
id|svsk-&gt;sk_sock-&gt;flags
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|svsk-&gt;sk_reserved
op_plus
id|serv-&gt;sv_bufsz
)paren
op_star
l_int|2
OG
id|svc_sock_wspace
c_func
(paren
id|svsk
)paren
)paren
op_logical_and
op_logical_neg
id|test_bit
c_func
(paren
id|SK_CLOSE
comma
op_amp
id|svsk-&gt;sk_flags
)paren
op_logical_and
op_logical_neg
id|test_bit
c_func
(paren
id|SK_CONN
comma
op_amp
id|svsk-&gt;sk_flags
)paren
)paren
(brace
multiline_comment|/* Don&squot;t enqueue while not enough space for reply */
id|dprintk
c_func
(paren
l_string|&quot;svc: socket %p  no space, %d*2 &gt; %ld, not enqueued&bslash;n&quot;
comma
id|svsk-&gt;sk_sk
comma
id|svsk-&gt;sk_reserved
op_plus
id|serv-&gt;sv_bufsz
comma
id|svc_sock_wspace
c_func
(paren
id|svsk
)paren
)paren
suffix:semicolon
r_goto
id|out_unlock
suffix:semicolon
)brace
id|clear_bit
c_func
(paren
id|SOCK_NOSPACE
comma
op_amp
id|svsk-&gt;sk_sock-&gt;flags
)paren
suffix:semicolon
multiline_comment|/* Mark socket as busy. It will remain in this state until the&n;&t; * server has processed all pending data and put the socket back&n;&t; * on the idle list.&n;&t; */
id|set_bit
c_func
(paren
id|SK_BUSY
comma
op_amp
id|svsk-&gt;sk_flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|serv-&gt;sv_threads
)paren
)paren
(brace
id|rqstp
op_assign
id|list_entry
c_func
(paren
id|serv-&gt;sv_threads.next
comma
r_struct
id|svc_rqst
comma
id|rq_list
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;svc: socket %p served by daemon %p&bslash;n&quot;
comma
id|svsk-&gt;sk_sk
comma
id|rqstp
)paren
suffix:semicolon
id|svc_serv_dequeue
c_func
(paren
id|serv
comma
id|rqstp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rqstp-&gt;rq_sock
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;svc_sock_enqueue: server %p, rq_sock=%p!&bslash;n&quot;
comma
id|rqstp
comma
id|rqstp-&gt;rq_sock
)paren
suffix:semicolon
id|rqstp-&gt;rq_sock
op_assign
id|svsk
suffix:semicolon
id|svsk-&gt;sk_inuse
op_increment
suffix:semicolon
id|rqstp-&gt;rq_reserved
op_assign
id|serv-&gt;sv_bufsz
suffix:semicolon
id|svsk-&gt;sk_reserved
op_add_assign
id|rqstp-&gt;rq_reserved
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|rqstp-&gt;rq_wait
)paren
suffix:semicolon
)brace
r_else
(brace
id|dprintk
c_func
(paren
l_string|&quot;svc: socket %p put into queue&bslash;n&quot;
comma
id|svsk-&gt;sk_sk
)paren
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|svsk-&gt;sk_ready
comma
op_amp
id|serv-&gt;sv_sockets
)paren
suffix:semicolon
)brace
id|out_unlock
suffix:colon
id|spin_unlock_bh
c_func
(paren
op_amp
id|serv-&gt;sv_lock
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Dequeue the first socket.  Must be called with the serv-&gt;sv_lock held.&n; */
r_static
r_inline
r_struct
id|svc_sock
op_star
DECL|function|svc_sock_dequeue
id|svc_sock_dequeue
c_func
(paren
r_struct
id|svc_serv
op_star
id|serv
)paren
(brace
r_struct
id|svc_sock
op_star
id|svsk
suffix:semicolon
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|serv-&gt;sv_sockets
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
id|svsk
op_assign
id|list_entry
c_func
(paren
id|serv-&gt;sv_sockets.next
comma
r_struct
id|svc_sock
comma
id|sk_ready
)paren
suffix:semicolon
id|list_del_init
c_func
(paren
op_amp
id|svsk-&gt;sk_ready
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;svc: socket %p dequeued, inuse=%d&bslash;n&quot;
comma
id|svsk-&gt;sk_sk
comma
id|svsk-&gt;sk_inuse
)paren
suffix:semicolon
r_return
id|svsk
suffix:semicolon
)brace
multiline_comment|/*&n; * Having read something from a socket, check whether it&n; * needs to be re-enqueued.&n; * Note: SK_DATA only gets cleared when a read-attempt finds&n; * no (or insufficient) data.&n; */
r_static
r_inline
r_void
DECL|function|svc_sock_received
id|svc_sock_received
c_func
(paren
r_struct
id|svc_sock
op_star
id|svsk
)paren
(brace
id|clear_bit
c_func
(paren
id|SK_BUSY
comma
op_amp
id|svsk-&gt;sk_flags
)paren
suffix:semicolon
id|svc_sock_enqueue
c_func
(paren
id|svsk
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * svc_reserve - change the space reserved for the reply to a request.&n; * @rqstp:  The request in question&n; * @space: new max space to reserve&n; *&n; * Each request reserves some space on the output queue of the socket&n; * to make sure the reply fits.  This function reduces that reserved&n; * space to be the amount of space used already, plus @space.&n; *&n; */
DECL|function|svc_reserve
r_void
id|svc_reserve
c_func
(paren
r_struct
id|svc_rqst
op_star
id|rqstp
comma
r_int
id|space
)paren
(brace
id|space
op_add_assign
id|rqstp-&gt;rq_res.head
(braket
l_int|0
)braket
dot
id|iov_len
suffix:semicolon
r_if
c_cond
(paren
id|space
OL
id|rqstp-&gt;rq_reserved
)paren
(brace
r_struct
id|svc_sock
op_star
id|svsk
op_assign
id|rqstp-&gt;rq_sock
suffix:semicolon
id|spin_lock_bh
c_func
(paren
op_amp
id|svsk-&gt;sk_server-&gt;sv_lock
)paren
suffix:semicolon
id|svsk-&gt;sk_reserved
op_sub_assign
(paren
id|rqstp-&gt;rq_reserved
op_minus
id|space
)paren
suffix:semicolon
id|rqstp-&gt;rq_reserved
op_assign
id|space
suffix:semicolon
id|spin_unlock_bh
c_func
(paren
op_amp
id|svsk-&gt;sk_server-&gt;sv_lock
)paren
suffix:semicolon
id|svc_sock_enqueue
c_func
(paren
id|svsk
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Release a socket after use.&n; */
r_static
r_inline
r_void
DECL|function|svc_sock_put
id|svc_sock_put
c_func
(paren
r_struct
id|svc_sock
op_star
id|svsk
)paren
(brace
r_struct
id|svc_serv
op_star
id|serv
op_assign
id|svsk-&gt;sk_server
suffix:semicolon
id|spin_lock_bh
c_func
(paren
op_amp
id|serv-&gt;sv_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_decrement
(paren
id|svsk-&gt;sk_inuse
)paren
op_logical_and
id|test_bit
c_func
(paren
id|SK_DEAD
comma
op_amp
id|svsk-&gt;sk_flags
)paren
)paren
(brace
id|spin_unlock_bh
c_func
(paren
op_amp
id|serv-&gt;sv_lock
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;svc: releasing dead socket&bslash;n&quot;
)paren
suffix:semicolon
id|sock_release
c_func
(paren
id|svsk-&gt;sk_sock
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|svsk
)paren
suffix:semicolon
)brace
r_else
id|spin_unlock_bh
c_func
(paren
op_amp
id|serv-&gt;sv_lock
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|svc_sock_release
id|svc_sock_release
c_func
(paren
r_struct
id|svc_rqst
op_star
id|rqstp
)paren
(brace
r_struct
id|svc_sock
op_star
id|svsk
op_assign
id|rqstp-&gt;rq_sock
suffix:semicolon
id|svc_release_skb
c_func
(paren
id|rqstp
)paren
suffix:semicolon
id|svc_free_allpages
c_func
(paren
id|rqstp
)paren
suffix:semicolon
id|rqstp-&gt;rq_res.page_len
op_assign
l_int|0
suffix:semicolon
id|rqstp-&gt;rq_res.page_base
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Reset response buffer and release&n;&t; * the reservation.&n;&t; * But first, check that enough space was reserved&n;&t; * for the reply, otherwise we have a bug!&n;&t; */
r_if
c_cond
(paren
(paren
id|rqstp-&gt;rq_res.len
)paren
OG
id|rqstp-&gt;rq_reserved
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;RPC request reserved %d but used %d&bslash;n&quot;
comma
id|rqstp-&gt;rq_reserved
comma
id|rqstp-&gt;rq_res.len
)paren
suffix:semicolon
id|rqstp-&gt;rq_res.head
(braket
l_int|0
)braket
dot
id|iov_len
op_assign
l_int|0
suffix:semicolon
id|svc_reserve
c_func
(paren
id|rqstp
comma
l_int|0
)paren
suffix:semicolon
id|rqstp-&gt;rq_sock
op_assign
l_int|NULL
suffix:semicolon
id|svc_sock_put
c_func
(paren
id|svsk
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * External function to wake up a server waiting for data&n; */
r_void
DECL|function|svc_wake_up
id|svc_wake_up
c_func
(paren
r_struct
id|svc_serv
op_star
id|serv
)paren
(brace
r_struct
id|svc_rqst
op_star
id|rqstp
suffix:semicolon
id|spin_lock_bh
c_func
(paren
op_amp
id|serv-&gt;sv_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|serv-&gt;sv_threads
)paren
)paren
(brace
id|rqstp
op_assign
id|list_entry
c_func
(paren
id|serv-&gt;sv_threads.next
comma
r_struct
id|svc_rqst
comma
id|rq_list
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;svc: daemon %p woken up.&bslash;n&quot;
comma
id|rqstp
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;svc_serv_dequeue(serv, rqstp);&n;&t;&t;rqstp-&gt;rq_sock = NULL;&n;&t;&t; */
id|wake_up
c_func
(paren
op_amp
id|rqstp-&gt;rq_wait
)paren
suffix:semicolon
)brace
id|spin_unlock_bh
c_func
(paren
op_amp
id|serv-&gt;sv_lock
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Generic sendto routine&n; */
r_static
r_int
DECL|function|svc_sendto
id|svc_sendto
c_func
(paren
r_struct
id|svc_rqst
op_star
id|rqstp
comma
r_struct
id|xdr_buf
op_star
id|xdr
)paren
(brace
r_struct
id|svc_sock
op_star
id|svsk
op_assign
id|rqstp-&gt;rq_sock
suffix:semicolon
r_struct
id|socket
op_star
id|sock
op_assign
id|svsk-&gt;sk_sock
suffix:semicolon
r_int
id|slen
suffix:semicolon
r_char
id|buffer
(braket
id|CMSG_SPACE
c_func
(paren
r_sizeof
(paren
r_struct
id|in_pktinfo
)paren
)paren
)braket
suffix:semicolon
r_struct
id|cmsghdr
op_star
id|cmh
op_assign
(paren
r_struct
id|cmsghdr
op_star
)paren
id|buffer
suffix:semicolon
r_struct
id|in_pktinfo
op_star
id|pki
op_assign
(paren
r_struct
id|in_pktinfo
op_star
)paren
id|CMSG_DATA
c_func
(paren
id|cmh
)paren
suffix:semicolon
r_int
id|len
op_assign
l_int|0
suffix:semicolon
r_int
id|result
suffix:semicolon
r_int
id|size
suffix:semicolon
r_struct
id|page
op_star
op_star
id|ppage
op_assign
id|xdr-&gt;pages
suffix:semicolon
r_int
id|base
op_assign
id|xdr-&gt;page_base
suffix:semicolon
r_int
r_int
id|pglen
op_assign
id|xdr-&gt;page_len
suffix:semicolon
r_int
r_int
id|flags
op_assign
id|MSG_MORE
suffix:semicolon
id|slen
op_assign
id|xdr-&gt;len
suffix:semicolon
r_if
c_cond
(paren
id|rqstp-&gt;rq_prot
op_eq
id|IPPROTO_UDP
)paren
(brace
multiline_comment|/* set the source and destination */
r_struct
id|msghdr
id|msg
suffix:semicolon
id|msg.msg_name
op_assign
op_amp
id|rqstp-&gt;rq_addr
suffix:semicolon
id|msg.msg_namelen
op_assign
r_sizeof
(paren
id|rqstp-&gt;rq_addr
)paren
suffix:semicolon
id|msg.msg_iov
op_assign
l_int|NULL
suffix:semicolon
id|msg.msg_iovlen
op_assign
l_int|0
suffix:semicolon
id|msg.msg_flags
op_assign
id|MSG_MORE
suffix:semicolon
id|msg.msg_control
op_assign
id|cmh
suffix:semicolon
id|msg.msg_controllen
op_assign
r_sizeof
(paren
id|buffer
)paren
suffix:semicolon
id|cmh-&gt;cmsg_len
op_assign
id|CMSG_LEN
c_func
(paren
r_sizeof
(paren
op_star
id|pki
)paren
)paren
suffix:semicolon
id|cmh-&gt;cmsg_level
op_assign
id|SOL_IP
suffix:semicolon
id|cmh-&gt;cmsg_type
op_assign
id|IP_PKTINFO
suffix:semicolon
id|pki-&gt;ipi_ifindex
op_assign
l_int|0
suffix:semicolon
id|pki-&gt;ipi_spec_dst.s_addr
op_assign
id|rqstp-&gt;rq_daddr
suffix:semicolon
r_if
c_cond
(paren
id|sock_sendmsg
c_func
(paren
id|sock
comma
op_amp
id|msg
comma
l_int|0
)paren
OL
l_int|0
)paren
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* send head */
r_if
c_cond
(paren
id|slen
op_eq
id|xdr-&gt;head
(braket
l_int|0
)braket
dot
id|iov_len
)paren
id|flags
op_assign
l_int|0
suffix:semicolon
id|len
op_assign
id|sock-&gt;ops
op_member_access_from_pointer
id|sendpage
c_func
(paren
id|sock
comma
id|rqstp-&gt;rq_respages
(braket
l_int|0
)braket
comma
l_int|0
comma
id|xdr-&gt;head
(braket
l_int|0
)braket
dot
id|iov_len
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
op_ne
id|xdr-&gt;head
(braket
l_int|0
)braket
dot
id|iov_len
)paren
r_goto
id|out
suffix:semicolon
id|slen
op_sub_assign
id|xdr-&gt;head
(braket
l_int|0
)braket
dot
id|iov_len
suffix:semicolon
r_if
c_cond
(paren
id|slen
op_eq
l_int|0
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* send page data */
id|size
op_assign
id|PAGE_SIZE
op_minus
id|base
OL
id|pglen
ques
c_cond
id|PAGE_SIZE
op_minus
id|base
suffix:colon
id|pglen
suffix:semicolon
r_while
c_loop
(paren
id|pglen
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|slen
op_eq
id|size
)paren
id|flags
op_assign
l_int|0
suffix:semicolon
id|result
op_assign
id|sock-&gt;ops
op_member_access_from_pointer
id|sendpage
c_func
(paren
id|sock
comma
op_star
id|ppage
comma
id|base
comma
id|size
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OG
l_int|0
)paren
id|len
op_add_assign
id|result
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|size
)paren
r_goto
id|out
suffix:semicolon
id|slen
op_sub_assign
id|size
suffix:semicolon
id|pglen
op_sub_assign
id|size
suffix:semicolon
id|size
op_assign
id|PAGE_SIZE
OL
id|pglen
ques
c_cond
id|PAGE_SIZE
suffix:colon
id|pglen
suffix:semicolon
id|base
op_assign
l_int|0
suffix:semicolon
id|ppage
op_increment
suffix:semicolon
)brace
multiline_comment|/* send tail */
r_if
c_cond
(paren
id|xdr-&gt;tail
(braket
l_int|0
)braket
dot
id|iov_len
)paren
(brace
id|result
op_assign
id|sock-&gt;ops
op_member_access_from_pointer
id|sendpage
c_func
(paren
id|sock
comma
id|rqstp-&gt;rq_respages
(braket
id|rqstp-&gt;rq_restailpage
)braket
comma
(paren
(paren
r_int
r_int
)paren
id|xdr-&gt;tail
(braket
l_int|0
)braket
dot
id|iov_base
)paren
op_amp
(paren
id|PAGE_SIZE
op_minus
l_int|1
)paren
comma
id|xdr-&gt;tail
(braket
l_int|0
)braket
dot
id|iov_len
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OG
l_int|0
)paren
id|len
op_add_assign
id|result
suffix:semicolon
)brace
id|out
suffix:colon
id|dprintk
c_func
(paren
l_string|&quot;svc: socket %p sendto([%p %Zu... ], %d) = %d (addr %x)&bslash;n&quot;
comma
id|rqstp-&gt;rq_sock
comma
id|xdr-&gt;head
(braket
l_int|0
)braket
dot
id|iov_base
comma
id|xdr-&gt;head
(braket
l_int|0
)braket
dot
id|iov_len
comma
id|xdr-&gt;len
comma
id|len
comma
id|rqstp-&gt;rq_addr.sin_addr.s_addr
)paren
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
multiline_comment|/*&n; * Check input queue length&n; */
r_static
r_int
DECL|function|svc_recv_available
id|svc_recv_available
c_func
(paren
r_struct
id|svc_sock
op_star
id|svsk
)paren
(brace
id|mm_segment_t
id|oldfs
suffix:semicolon
r_struct
id|socket
op_star
id|sock
op_assign
id|svsk-&gt;sk_sock
suffix:semicolon
r_int
id|avail
comma
id|err
suffix:semicolon
id|oldfs
op_assign
id|get_fs
c_func
(paren
)paren
suffix:semicolon
id|set_fs
c_func
(paren
id|KERNEL_DS
)paren
suffix:semicolon
id|err
op_assign
id|sock-&gt;ops
op_member_access_from_pointer
id|ioctl
c_func
(paren
id|sock
comma
id|TIOCINQ
comma
(paren
r_int
r_int
)paren
op_amp
id|avail
)paren
suffix:semicolon
id|set_fs
c_func
(paren
id|oldfs
)paren
suffix:semicolon
r_return
(paren
id|err
op_ge
l_int|0
)paren
ques
c_cond
id|avail
suffix:colon
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; * Generic recvfrom routine.&n; */
r_static
r_int
DECL|function|svc_recvfrom
id|svc_recvfrom
c_func
(paren
r_struct
id|svc_rqst
op_star
id|rqstp
comma
r_struct
id|kvec
op_star
id|iov
comma
r_int
id|nr
comma
r_int
id|buflen
)paren
(brace
r_struct
id|msghdr
id|msg
suffix:semicolon
r_struct
id|socket
op_star
id|sock
suffix:semicolon
r_int
id|len
comma
id|alen
suffix:semicolon
id|rqstp-&gt;rq_addrlen
op_assign
r_sizeof
(paren
id|rqstp-&gt;rq_addr
)paren
suffix:semicolon
id|sock
op_assign
id|rqstp-&gt;rq_sock-&gt;sk_sock
suffix:semicolon
id|msg.msg_name
op_assign
op_amp
id|rqstp-&gt;rq_addr
suffix:semicolon
id|msg.msg_namelen
op_assign
r_sizeof
(paren
id|rqstp-&gt;rq_addr
)paren
suffix:semicolon
id|msg.msg_control
op_assign
l_int|NULL
suffix:semicolon
id|msg.msg_controllen
op_assign
l_int|0
suffix:semicolon
id|msg.msg_flags
op_assign
id|MSG_DONTWAIT
suffix:semicolon
id|len
op_assign
id|kernel_recvmsg
c_func
(paren
id|sock
comma
op_amp
id|msg
comma
id|iov
comma
id|nr
comma
id|buflen
comma
id|MSG_DONTWAIT
)paren
suffix:semicolon
multiline_comment|/* sock_recvmsg doesn&squot;t fill in the name/namelen, so we must..&n;&t; * possibly we should cache this in the svc_sock structure&n;&t; * at accept time. FIXME&n;&t; */
id|alen
op_assign
r_sizeof
(paren
id|rqstp-&gt;rq_addr
)paren
suffix:semicolon
id|sock-&gt;ops
op_member_access_from_pointer
id|getname
c_func
(paren
id|sock
comma
(paren
r_struct
id|sockaddr
op_star
)paren
op_amp
id|rqstp-&gt;rq_addr
comma
op_amp
id|alen
comma
l_int|1
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;svc: socket %p recvfrom(%p, %Zu) = %d&bslash;n&quot;
comma
id|rqstp-&gt;rq_sock
comma
id|iov
(braket
l_int|0
)braket
dot
id|iov_base
comma
id|iov
(braket
l_int|0
)braket
dot
id|iov_len
comma
id|len
)paren
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
multiline_comment|/*&n; * Set socket snd and rcv buffer lengths&n; */
r_static
r_inline
r_void
DECL|function|svc_sock_setbufsize
id|svc_sock_setbufsize
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_int
r_int
id|snd
comma
r_int
r_int
id|rcv
)paren
(brace
macro_line|#if 0
id|mm_segment_t
id|oldfs
suffix:semicolon
id|oldfs
op_assign
id|get_fs
c_func
(paren
)paren
suffix:semicolon
id|set_fs
c_func
(paren
id|KERNEL_DS
)paren
suffix:semicolon
id|sock_setsockopt
c_func
(paren
id|sock
comma
id|SOL_SOCKET
comma
id|SO_SNDBUF
comma
(paren
r_char
op_star
)paren
op_amp
id|snd
comma
r_sizeof
(paren
id|snd
)paren
)paren
suffix:semicolon
id|sock_setsockopt
c_func
(paren
id|sock
comma
id|SOL_SOCKET
comma
id|SO_RCVBUF
comma
(paren
r_char
op_star
)paren
op_amp
id|rcv
comma
r_sizeof
(paren
id|rcv
)paren
)paren
suffix:semicolon
macro_line|#else
multiline_comment|/* sock_setsockopt limits use to sysctl_?mem_max,&n;&t; * which isn&squot;t acceptable.  Until that is made conditional&n;&t; * on not having CAP_SYS_RESOURCE or similar, we go direct...&n;&t; * DaveM said I could!&n;&t; */
id|lock_sock
c_func
(paren
id|sock-&gt;sk
)paren
suffix:semicolon
id|sock-&gt;sk-&gt;sk_sndbuf
op_assign
id|snd
op_star
l_int|2
suffix:semicolon
id|sock-&gt;sk-&gt;sk_rcvbuf
op_assign
id|rcv
op_star
l_int|2
suffix:semicolon
id|sock-&gt;sk-&gt;sk_userlocks
op_or_assign
id|SOCK_SNDBUF_LOCK
op_or
id|SOCK_RCVBUF_LOCK
suffix:semicolon
id|release_sock
c_func
(paren
id|sock-&gt;sk
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n; * INET callback when data has been received on the socket.&n; */
r_static
r_void
DECL|function|svc_udp_data_ready
id|svc_udp_data_ready
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|count
)paren
(brace
r_struct
id|svc_sock
op_star
id|svsk
op_assign
(paren
r_struct
id|svc_sock
op_star
)paren
(paren
id|sk-&gt;sk_user_data
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|svsk
)paren
r_goto
id|out
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;svc: socket %p(inet %p), count=%d, busy=%d&bslash;n&quot;
comma
id|svsk
comma
id|sk
comma
id|count
comma
id|test_bit
c_func
(paren
id|SK_BUSY
comma
op_amp
id|svsk-&gt;sk_flags
)paren
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|SK_DATA
comma
op_amp
id|svsk-&gt;sk_flags
)paren
suffix:semicolon
id|svc_sock_enqueue
c_func
(paren
id|svsk
)paren
suffix:semicolon
id|out
suffix:colon
r_if
c_cond
(paren
id|sk-&gt;sk_sleep
op_logical_and
id|waitqueue_active
c_func
(paren
id|sk-&gt;sk_sleep
)paren
)paren
id|wake_up_interruptible
c_func
(paren
id|sk-&gt;sk_sleep
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * INET callback when space is newly available on the socket.&n; */
r_static
r_void
DECL|function|svc_write_space
id|svc_write_space
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|svc_sock
op_star
id|svsk
op_assign
(paren
r_struct
id|svc_sock
op_star
)paren
(paren
id|sk-&gt;sk_user_data
)paren
suffix:semicolon
r_if
c_cond
(paren
id|svsk
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;svc: socket %p(inet %p), write_space busy=%d&bslash;n&quot;
comma
id|svsk
comma
id|sk
comma
id|test_bit
c_func
(paren
id|SK_BUSY
comma
op_amp
id|svsk-&gt;sk_flags
)paren
)paren
suffix:semicolon
id|svc_sock_enqueue
c_func
(paren
id|svsk
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sk-&gt;sk_sleep
op_logical_and
id|waitqueue_active
c_func
(paren
id|sk-&gt;sk_sleep
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;RPC svc_write_space: some sleeping on %p&bslash;n&quot;
comma
id|svsk
)paren
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
id|sk-&gt;sk_sleep
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Receive a datagram from a UDP socket.&n; */
r_extern
r_int
id|csum_partial_copy_to_xdr
c_func
(paren
r_struct
id|xdr_buf
op_star
id|xdr
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
suffix:semicolon
r_static
r_int
DECL|function|svc_udp_recvfrom
id|svc_udp_recvfrom
c_func
(paren
r_struct
id|svc_rqst
op_star
id|rqstp
)paren
(brace
r_struct
id|svc_sock
op_star
id|svsk
op_assign
id|rqstp-&gt;rq_sock
suffix:semicolon
r_struct
id|svc_serv
op_star
id|serv
op_assign
id|svsk-&gt;sk_server
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_int
id|err
comma
id|len
suffix:semicolon
r_if
c_cond
(paren
id|test_and_clear_bit
c_func
(paren
id|SK_CHNGBUF
comma
op_amp
id|svsk-&gt;sk_flags
)paren
)paren
multiline_comment|/* udp sockets need large rcvbuf as all pending&n;&t;     * requests are still in that buffer.  sndbuf must&n;&t;     * also be large enough that there is enough space&n;&t;     * for one reply per thread.&n;&t;     */
id|svc_sock_setbufsize
c_func
(paren
id|svsk-&gt;sk_sock
comma
(paren
id|serv-&gt;sv_nrthreads
op_plus
l_int|3
)paren
op_star
id|serv-&gt;sv_bufsz
comma
(paren
id|serv-&gt;sv_nrthreads
op_plus
l_int|3
)paren
op_star
id|serv-&gt;sv_bufsz
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rqstp-&gt;rq_deferred
op_assign
id|svc_deferred_dequeue
c_func
(paren
id|svsk
)paren
)paren
)paren
(brace
id|svc_sock_received
c_func
(paren
id|svsk
)paren
suffix:semicolon
r_return
id|svc_deferred_recv
c_func
(paren
id|rqstp
)paren
suffix:semicolon
)brace
id|clear_bit
c_func
(paren
id|SK_DATA
comma
op_amp
id|svsk-&gt;sk_flags
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|skb
op_assign
id|skb_recv_datagram
c_func
(paren
id|svsk-&gt;sk_sk
comma
l_int|0
comma
l_int|1
comma
op_amp
id|err
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|err
op_eq
op_minus
id|EAGAIN
)paren
(brace
id|svc_sock_received
c_func
(paren
id|svsk
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/* possibly an icmp error */
id|dprintk
c_func
(paren
l_string|&quot;svc: recvfrom returned error %d&bslash;n&quot;
comma
op_minus
id|err
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|skb-&gt;stamp.tv_sec
op_eq
l_int|0
)paren
(brace
id|skb-&gt;stamp.tv_sec
op_assign
id|xtime.tv_sec
suffix:semicolon
id|skb-&gt;stamp.tv_usec
op_assign
id|xtime.tv_nsec
op_star
l_int|1000
suffix:semicolon
multiline_comment|/* Don&squot;t enable netstamp, sunrpc doesn&squot;t &n;&t;&t;   need that much accuracy */
)brace
id|svsk-&gt;sk_sk-&gt;sk_stamp
op_assign
id|skb-&gt;stamp
suffix:semicolon
id|set_bit
c_func
(paren
id|SK_DATA
comma
op_amp
id|svsk-&gt;sk_flags
)paren
suffix:semicolon
multiline_comment|/* there may be more data... */
multiline_comment|/*&n;&t; * Maybe more packets - kick another thread ASAP.&n;&t; */
id|svc_sock_received
c_func
(paren
id|svsk
)paren
suffix:semicolon
id|len
op_assign
id|skb-&gt;len
op_minus
r_sizeof
(paren
r_struct
id|udphdr
)paren
suffix:semicolon
id|rqstp-&gt;rq_arg.len
op_assign
id|len
suffix:semicolon
id|rqstp-&gt;rq_prot
op_assign
id|IPPROTO_UDP
suffix:semicolon
multiline_comment|/* Get sender address */
id|rqstp-&gt;rq_addr.sin_family
op_assign
id|AF_INET
suffix:semicolon
id|rqstp-&gt;rq_addr.sin_port
op_assign
id|skb-&gt;h.uh-&gt;source
suffix:semicolon
id|rqstp-&gt;rq_addr.sin_addr.s_addr
op_assign
id|skb-&gt;nh.iph-&gt;saddr
suffix:semicolon
id|rqstp-&gt;rq_daddr
op_assign
id|skb-&gt;nh.iph-&gt;daddr
suffix:semicolon
r_if
c_cond
(paren
id|skb_is_nonlinear
c_func
(paren
id|skb
)paren
)paren
(brace
multiline_comment|/* we have to copy */
id|local_bh_disable
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|csum_partial_copy_to_xdr
c_func
(paren
op_amp
id|rqstp-&gt;rq_arg
comma
id|skb
)paren
)paren
(brace
id|local_bh_enable
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* checksum error */
id|skb_free_datagram
c_func
(paren
id|svsk-&gt;sk_sk
comma
id|skb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|local_bh_enable
c_func
(paren
)paren
suffix:semicolon
id|skb_free_datagram
c_func
(paren
id|svsk-&gt;sk_sk
comma
id|skb
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* we can use it in-place */
id|rqstp-&gt;rq_arg.head
(braket
l_int|0
)braket
dot
id|iov_base
op_assign
id|skb-&gt;data
op_plus
r_sizeof
(paren
r_struct
id|udphdr
)paren
suffix:semicolon
id|rqstp-&gt;rq_arg.head
(braket
l_int|0
)braket
dot
id|iov_len
op_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
id|skb-&gt;ip_summed
op_ne
id|CHECKSUM_UNNECESSARY
)paren
(brace
r_if
c_cond
(paren
(paren
r_int
r_int
)paren
id|csum_fold
c_func
(paren
id|skb_checksum
c_func
(paren
id|skb
comma
l_int|0
comma
id|skb-&gt;len
comma
id|skb-&gt;csum
)paren
)paren
)paren
(brace
id|skb_free_datagram
c_func
(paren
id|svsk-&gt;sk_sk
comma
id|skb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|skb-&gt;ip_summed
op_assign
id|CHECKSUM_UNNECESSARY
suffix:semicolon
)brace
id|rqstp-&gt;rq_skbuff
op_assign
id|skb
suffix:semicolon
)brace
id|rqstp-&gt;rq_arg.page_base
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|len
op_le
id|rqstp-&gt;rq_arg.head
(braket
l_int|0
)braket
dot
id|iov_len
)paren
(brace
id|rqstp-&gt;rq_arg.head
(braket
l_int|0
)braket
dot
id|iov_len
op_assign
id|len
suffix:semicolon
id|rqstp-&gt;rq_arg.page_len
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|rqstp-&gt;rq_arg.page_len
op_assign
id|len
op_minus
id|rqstp-&gt;rq_arg.head
(braket
l_int|0
)braket
dot
id|iov_len
suffix:semicolon
id|rqstp-&gt;rq_argused
op_add_assign
(paren
id|rqstp-&gt;rq_arg.page_len
op_plus
id|PAGE_SIZE
op_minus
l_int|1
)paren
op_div
id|PAGE_SIZE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|serv-&gt;sv_stats
)paren
id|serv-&gt;sv_stats-&gt;netudpcnt
op_increment
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
r_static
r_int
DECL|function|svc_udp_sendto
id|svc_udp_sendto
c_func
(paren
r_struct
id|svc_rqst
op_star
id|rqstp
)paren
(brace
r_int
id|error
suffix:semicolon
id|error
op_assign
id|svc_sendto
c_func
(paren
id|rqstp
comma
op_amp
id|rqstp-&gt;rq_res
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_eq
op_minus
id|ECONNREFUSED
)paren
multiline_comment|/* ICMP error on earlier request. */
id|error
op_assign
id|svc_sendto
c_func
(paren
id|rqstp
comma
op_amp
id|rqstp-&gt;rq_res
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
r_static
r_void
DECL|function|svc_udp_init
id|svc_udp_init
c_func
(paren
r_struct
id|svc_sock
op_star
id|svsk
)paren
(brace
id|svsk-&gt;sk_sk-&gt;sk_data_ready
op_assign
id|svc_udp_data_ready
suffix:semicolon
id|svsk-&gt;sk_sk-&gt;sk_write_space
op_assign
id|svc_write_space
suffix:semicolon
id|svsk-&gt;sk_recvfrom
op_assign
id|svc_udp_recvfrom
suffix:semicolon
id|svsk-&gt;sk_sendto
op_assign
id|svc_udp_sendto
suffix:semicolon
multiline_comment|/* initialise setting must have enough space to&n;&t; * receive and respond to one request.  &n;&t; * svc_udp_recvfrom will re-adjust if necessary&n;&t; */
id|svc_sock_setbufsize
c_func
(paren
id|svsk-&gt;sk_sock
comma
l_int|3
op_star
id|svsk-&gt;sk_server-&gt;sv_bufsz
comma
l_int|3
op_star
id|svsk-&gt;sk_server-&gt;sv_bufsz
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|SK_DATA
comma
op_amp
id|svsk-&gt;sk_flags
)paren
suffix:semicolon
multiline_comment|/* might have come in before data_ready set up */
id|set_bit
c_func
(paren
id|SK_CHNGBUF
comma
op_amp
id|svsk-&gt;sk_flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * A data_ready event on a listening socket means there&squot;s a connection&n; * pending. Do not use state_change as a substitute for it.&n; */
r_static
r_void
DECL|function|svc_tcp_listen_data_ready
id|svc_tcp_listen_data_ready
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|count_unused
)paren
(brace
r_struct
id|svc_sock
op_star
id|svsk
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;svc: socket %p TCP (listen) state change %d&bslash;n&quot;
comma
id|sk
comma
id|sk-&gt;sk_state
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;sk_state
op_ne
id|TCP_LISTEN
)paren
(brace
multiline_comment|/*&n;&t;&t; * This callback may called twice when a new connection&n;&t;&t; * is established as a child socket inherits everything&n;&t;&t; * from a parent LISTEN socket.&n;&t;&t; * 1) data_ready method of the parent socket will be called&n;&t;&t; *    when one of child sockets become ESTABLISHED.&n;&t;&t; * 2) data_ready method of the child socket may be called&n;&t;&t; *    when it receives data before the socket is accepted.&n;&t;&t; * In case of 2, we should ignore it silently.&n;&t;&t; */
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|svsk
op_assign
(paren
r_struct
id|svc_sock
op_star
)paren
id|sk-&gt;sk_user_data
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;svc: socket %p: no user data&bslash;n&quot;
comma
id|sk
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|set_bit
c_func
(paren
id|SK_CONN
comma
op_amp
id|svsk-&gt;sk_flags
)paren
suffix:semicolon
id|svc_sock_enqueue
c_func
(paren
id|svsk
)paren
suffix:semicolon
id|out
suffix:colon
r_if
c_cond
(paren
id|sk-&gt;sk_sleep
op_logical_and
id|waitqueue_active
c_func
(paren
id|sk-&gt;sk_sleep
)paren
)paren
id|wake_up_interruptible_all
c_func
(paren
id|sk-&gt;sk_sleep
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * A state change on a connected socket means it&squot;s dying or dead.&n; */
r_static
r_void
DECL|function|svc_tcp_state_change
id|svc_tcp_state_change
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|svc_sock
op_star
id|svsk
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;svc: socket %p TCP (connected) state change %d (svsk %p)&bslash;n&quot;
comma
id|sk
comma
id|sk-&gt;sk_state
comma
id|sk-&gt;sk_user_data
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|svsk
op_assign
(paren
r_struct
id|svc_sock
op_star
)paren
id|sk-&gt;sk_user_data
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;svc: socket %p: no user data&bslash;n&quot;
comma
id|sk
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|set_bit
c_func
(paren
id|SK_CLOSE
comma
op_amp
id|svsk-&gt;sk_flags
)paren
suffix:semicolon
id|svc_sock_enqueue
c_func
(paren
id|svsk
)paren
suffix:semicolon
id|out
suffix:colon
r_if
c_cond
(paren
id|sk-&gt;sk_sleep
op_logical_and
id|waitqueue_active
c_func
(paren
id|sk-&gt;sk_sleep
)paren
)paren
id|wake_up_interruptible_all
c_func
(paren
id|sk-&gt;sk_sleep
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|svc_tcp_data_ready
id|svc_tcp_data_ready
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|count
)paren
(brace
r_struct
id|svc_sock
op_star
id|svsk
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;svc: socket %p TCP data ready (svsk %p)&bslash;n&quot;
comma
id|sk
comma
id|sk-&gt;sk_user_data
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|svsk
op_assign
(paren
r_struct
id|svc_sock
op_star
)paren
(paren
id|sk-&gt;sk_user_data
)paren
)paren
)paren
r_goto
id|out
suffix:semicolon
id|set_bit
c_func
(paren
id|SK_DATA
comma
op_amp
id|svsk-&gt;sk_flags
)paren
suffix:semicolon
id|svc_sock_enqueue
c_func
(paren
id|svsk
)paren
suffix:semicolon
id|out
suffix:colon
r_if
c_cond
(paren
id|sk-&gt;sk_sleep
op_logical_and
id|waitqueue_active
c_func
(paren
id|sk-&gt;sk_sleep
)paren
)paren
id|wake_up_interruptible
c_func
(paren
id|sk-&gt;sk_sleep
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Accept a TCP connection&n; */
r_static
r_void
DECL|function|svc_tcp_accept
id|svc_tcp_accept
c_func
(paren
r_struct
id|svc_sock
op_star
id|svsk
)paren
(brace
r_struct
id|sockaddr_in
id|sin
suffix:semicolon
r_struct
id|svc_serv
op_star
id|serv
op_assign
id|svsk-&gt;sk_server
suffix:semicolon
r_struct
id|socket
op_star
id|sock
op_assign
id|svsk-&gt;sk_sock
suffix:semicolon
r_struct
id|socket
op_star
id|newsock
suffix:semicolon
r_struct
id|proto_ops
op_star
id|ops
suffix:semicolon
r_struct
id|svc_sock
op_star
id|newsvsk
suffix:semicolon
r_int
id|err
comma
id|slen
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;svc: tcp_accept %p sock %p&bslash;n&quot;
comma
id|svsk
comma
id|sock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sock
)paren
r_return
suffix:semicolon
id|err
op_assign
id|sock_create_lite
c_func
(paren
id|PF_INET
comma
id|SOCK_STREAM
comma
id|IPPROTO_TCP
comma
op_amp
id|newsock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
r_if
c_cond
(paren
id|err
op_eq
op_minus
id|ENOMEM
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: no more sockets!&bslash;n&quot;
comma
id|serv-&gt;sv_name
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|dprintk
c_func
(paren
l_string|&quot;svc: tcp_accept %p allocated&bslash;n&quot;
comma
id|newsock
)paren
suffix:semicolon
id|newsock-&gt;ops
op_assign
id|ops
op_assign
id|sock-&gt;ops
suffix:semicolon
id|clear_bit
c_func
(paren
id|SK_CONN
comma
op_amp
id|svsk-&gt;sk_flags
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|ops
op_member_access_from_pointer
id|accept
c_func
(paren
id|sock
comma
id|newsock
comma
id|O_NONBLOCK
)paren
)paren
OL
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|err
op_ne
op_minus
id|EAGAIN
op_logical_and
id|net_ratelimit
c_func
(paren
)paren
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: accept failed (err %d)!&bslash;n&quot;
comma
id|serv-&gt;sv_name
comma
op_minus
id|err
)paren
suffix:semicolon
r_goto
id|failed
suffix:semicolon
multiline_comment|/* aborted connection or whatever */
)brace
id|set_bit
c_func
(paren
id|SK_CONN
comma
op_amp
id|svsk-&gt;sk_flags
)paren
suffix:semicolon
id|svc_sock_enqueue
c_func
(paren
id|svsk
)paren
suffix:semicolon
id|slen
op_assign
r_sizeof
(paren
id|sin
)paren
suffix:semicolon
id|err
op_assign
id|ops
op_member_access_from_pointer
id|getname
c_func
(paren
id|newsock
comma
(paren
r_struct
id|sockaddr
op_star
)paren
op_amp
id|sin
comma
op_amp
id|slen
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|net_ratelimit
c_func
(paren
)paren
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: peername failed (err %d)!&bslash;n&quot;
comma
id|serv-&gt;sv_name
comma
op_minus
id|err
)paren
suffix:semicolon
r_goto
id|failed
suffix:semicolon
multiline_comment|/* aborted connection or whatever */
)brace
multiline_comment|/* Ideally, we would want to reject connections from unauthorized&n;&t; * hosts here, but when we get encription, the IP of the host won&squot;t&n;&t; * tell us anything. For now just warn about unpriv connections.&n;&t; */
r_if
c_cond
(paren
id|ntohs
c_func
(paren
id|sin.sin_port
)paren
op_ge
l_int|1024
)paren
(brace
id|dprintk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: connect from unprivileged port: %u.%u.%u.%u:%d&bslash;n&quot;
comma
id|serv-&gt;sv_name
comma
id|NIPQUAD
c_func
(paren
id|sin.sin_addr.s_addr
)paren
comma
id|ntohs
c_func
(paren
id|sin.sin_port
)paren
)paren
suffix:semicolon
)brace
id|dprintk
c_func
(paren
l_string|&quot;%s: connect from %u.%u.%u.%u:%04x&bslash;n&quot;
comma
id|serv-&gt;sv_name
comma
id|NIPQUAD
c_func
(paren
id|sin.sin_addr.s_addr
)paren
comma
id|ntohs
c_func
(paren
id|sin.sin_port
)paren
)paren
suffix:semicolon
multiline_comment|/* make sure that a write doesn&squot;t block forever when&n;&t; * low on memory&n;&t; */
id|newsock-&gt;sk-&gt;sk_sndtimeo
op_assign
id|HZ
op_star
l_int|30
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|newsvsk
op_assign
id|svc_setup_socket
c_func
(paren
id|serv
comma
id|newsock
comma
op_amp
id|err
comma
l_int|0
)paren
)paren
)paren
r_goto
id|failed
suffix:semicolon
multiline_comment|/* make sure that we don&squot;t have too many active connections.&n;&t; * If we have, something must be dropped.&n;&t; *&n;&t; * There&squot;s no point in trying to do random drop here for&n;&t; * DoS prevention. The NFS clients does 1 reconnect in 15&n;&t; * seconds. An attacker can easily beat that.&n;&t; *&n;&t; * The only somewhat efficient mechanism would be if drop&n;&t; * old connections from the same IP first. But right now&n;&t; * we don&squot;t even record the client IP in svc_sock.&n;&t; */
r_if
c_cond
(paren
id|serv-&gt;sv_tmpcnt
OG
(paren
id|serv-&gt;sv_nrthreads
op_plus
l_int|3
)paren
op_star
l_int|20
)paren
(brace
r_struct
id|svc_sock
op_star
id|svsk
op_assign
l_int|NULL
suffix:semicolon
id|spin_lock_bh
c_func
(paren
op_amp
id|serv-&gt;sv_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|serv-&gt;sv_tempsocks
)paren
)paren
(brace
r_if
c_cond
(paren
id|net_ratelimit
c_func
(paren
)paren
)paren
(brace
multiline_comment|/* Try to help the admin */
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;%s: too many open TCP &quot;
l_string|&quot;sockets, consider increasing the &quot;
l_string|&quot;number of nfsd threads&bslash;n&quot;
comma
id|serv-&gt;sv_name
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;%s: last TCP connect from &quot;
l_string|&quot;%u.%u.%u.%u:%d&bslash;n&quot;
comma
id|serv-&gt;sv_name
comma
id|NIPQUAD
c_func
(paren
id|sin.sin_addr.s_addr
)paren
comma
id|ntohs
c_func
(paren
id|sin.sin_port
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * Always select the oldest socket. It&squot;s not fair,&n;&t;&t;&t; * but so is life&n;&t;&t;&t; */
id|svsk
op_assign
id|list_entry
c_func
(paren
id|serv-&gt;sv_tempsocks.prev
comma
r_struct
id|svc_sock
comma
id|sk_list
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|SK_CLOSE
comma
op_amp
id|svsk-&gt;sk_flags
)paren
suffix:semicolon
id|svsk-&gt;sk_inuse
op_increment
suffix:semicolon
)brace
id|spin_unlock_bh
c_func
(paren
op_amp
id|serv-&gt;sv_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|svsk
)paren
(brace
id|svc_sock_enqueue
c_func
(paren
id|svsk
)paren
suffix:semicolon
id|svc_sock_put
c_func
(paren
id|svsk
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|serv-&gt;sv_stats
)paren
id|serv-&gt;sv_stats-&gt;nettcpconn
op_increment
suffix:semicolon
r_return
suffix:semicolon
id|failed
suffix:colon
id|sock_release
c_func
(paren
id|newsock
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * Receive data from a TCP socket.&n; */
r_static
r_int
DECL|function|svc_tcp_recvfrom
id|svc_tcp_recvfrom
c_func
(paren
r_struct
id|svc_rqst
op_star
id|rqstp
)paren
(brace
r_struct
id|svc_sock
op_star
id|svsk
op_assign
id|rqstp-&gt;rq_sock
suffix:semicolon
r_struct
id|svc_serv
op_star
id|serv
op_assign
id|svsk-&gt;sk_server
suffix:semicolon
r_int
id|len
suffix:semicolon
r_struct
id|kvec
id|vec
(braket
id|RPCSVC_MAXPAGES
)braket
suffix:semicolon
r_int
id|pnum
comma
id|vlen
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;svc: tcp_recv %p data %d conn %d close %d&bslash;n&quot;
comma
id|svsk
comma
id|test_bit
c_func
(paren
id|SK_DATA
comma
op_amp
id|svsk-&gt;sk_flags
)paren
comma
id|test_bit
c_func
(paren
id|SK_CONN
comma
op_amp
id|svsk-&gt;sk_flags
)paren
comma
id|test_bit
c_func
(paren
id|SK_CLOSE
comma
op_amp
id|svsk-&gt;sk_flags
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rqstp-&gt;rq_deferred
op_assign
id|svc_deferred_dequeue
c_func
(paren
id|svsk
)paren
)paren
)paren
(brace
id|svc_sock_received
c_func
(paren
id|svsk
)paren
suffix:semicolon
r_return
id|svc_deferred_recv
c_func
(paren
id|rqstp
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|SK_CLOSE
comma
op_amp
id|svsk-&gt;sk_flags
)paren
)paren
(brace
id|svc_delete_socket
c_func
(paren
id|svsk
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|SK_CONN
comma
op_amp
id|svsk-&gt;sk_flags
)paren
)paren
(brace
id|svc_tcp_accept
c_func
(paren
id|svsk
)paren
suffix:semicolon
id|svc_sock_received
c_func
(paren
id|svsk
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|test_and_clear_bit
c_func
(paren
id|SK_CHNGBUF
comma
op_amp
id|svsk-&gt;sk_flags
)paren
)paren
multiline_comment|/* sndbuf needs to have room for one request&n;&t;&t; * per thread, otherwise we can stall even when the&n;&t;&t; * network isn&squot;t a bottleneck.&n;&t;&t; * rcvbuf just needs to be able to hold a few requests.&n;&t;&t; * Normally they will be removed from the queue &n;&t;&t; * as soon a a complete request arrives.&n;&t;&t; */
id|svc_sock_setbufsize
c_func
(paren
id|svsk-&gt;sk_sock
comma
(paren
id|serv-&gt;sv_nrthreads
op_plus
l_int|3
)paren
op_star
id|serv-&gt;sv_bufsz
comma
l_int|3
op_star
id|serv-&gt;sv_bufsz
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|SK_DATA
comma
op_amp
id|svsk-&gt;sk_flags
)paren
suffix:semicolon
multiline_comment|/* Receive data. If we haven&squot;t got the record length yet, get&n;&t; * the next four bytes. Otherwise try to gobble up as much as&n;&t; * possible up to the complete record length.&n;&t; */
r_if
c_cond
(paren
id|svsk-&gt;sk_tcplen
OL
l_int|4
)paren
(brace
r_int
r_int
id|want
op_assign
l_int|4
op_minus
id|svsk-&gt;sk_tcplen
suffix:semicolon
r_struct
id|kvec
id|iov
suffix:semicolon
id|iov.iov_base
op_assign
(paren
(paren
r_char
op_star
)paren
op_amp
id|svsk-&gt;sk_reclen
)paren
op_plus
id|svsk-&gt;sk_tcplen
suffix:semicolon
id|iov.iov_len
op_assign
id|want
suffix:semicolon
r_if
c_cond
(paren
(paren
id|len
op_assign
id|svc_recvfrom
c_func
(paren
id|rqstp
comma
op_amp
id|iov
comma
l_int|1
comma
id|want
)paren
)paren
OL
l_int|0
)paren
r_goto
id|error
suffix:semicolon
id|svsk-&gt;sk_tcplen
op_add_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
id|want
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;svc: short recvfrom while reading record length (%d of %lu)&bslash;n&quot;
comma
id|len
comma
id|want
)paren
suffix:semicolon
id|svc_sock_received
c_func
(paren
id|svsk
)paren
suffix:semicolon
r_return
op_minus
id|EAGAIN
suffix:semicolon
multiline_comment|/* record header not complete */
)brace
id|svsk-&gt;sk_reclen
op_assign
id|ntohl
c_func
(paren
id|svsk-&gt;sk_reclen
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|svsk-&gt;sk_reclen
op_amp
l_int|0x80000000
)paren
)paren
(brace
multiline_comment|/* FIXME: technically, a record can be fragmented,&n;&t;&t;&t; *  and non-terminal fragments will not have the top&n;&t;&t;&t; *  bit set in the fragment length header.&n;&t;&t;&t; *  But apparently no known nfs clients send fragmented&n;&t;&t;&t; *  records. */
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;RPC: bad TCP reclen 0x%08lx (non-terminal)&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|svsk-&gt;sk_reclen
)paren
suffix:semicolon
r_goto
id|err_delete
suffix:semicolon
)brace
id|svsk-&gt;sk_reclen
op_and_assign
l_int|0x7fffffff
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;svc: TCP record, %d bytes&bslash;n&quot;
comma
id|svsk-&gt;sk_reclen
)paren
suffix:semicolon
r_if
c_cond
(paren
id|svsk-&gt;sk_reclen
OG
id|serv-&gt;sv_bufsz
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;RPC: bad TCP reclen 0x%08lx (large)&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|svsk-&gt;sk_reclen
)paren
suffix:semicolon
r_goto
id|err_delete
suffix:semicolon
)brace
)brace
multiline_comment|/* Check whether enough data is available */
id|len
op_assign
id|svc_recv_available
c_func
(paren
id|svsk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
l_int|0
)paren
r_goto
id|error
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
id|svsk-&gt;sk_reclen
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;svc: incomplete TCP record (%d of %d)&bslash;n&quot;
comma
id|len
comma
id|svsk-&gt;sk_reclen
)paren
suffix:semicolon
id|svc_sock_received
c_func
(paren
id|svsk
)paren
suffix:semicolon
r_return
op_minus
id|EAGAIN
suffix:semicolon
multiline_comment|/* record not complete */
)brace
id|len
op_assign
id|svsk-&gt;sk_reclen
suffix:semicolon
id|set_bit
c_func
(paren
id|SK_DATA
comma
op_amp
id|svsk-&gt;sk_flags
)paren
suffix:semicolon
id|vec
(braket
l_int|0
)braket
op_assign
id|rqstp-&gt;rq_arg.head
(braket
l_int|0
)braket
suffix:semicolon
id|vlen
op_assign
id|PAGE_SIZE
suffix:semicolon
id|pnum
op_assign
l_int|1
suffix:semicolon
r_while
c_loop
(paren
id|vlen
OL
id|len
)paren
(brace
id|vec
(braket
id|pnum
)braket
dot
id|iov_base
op_assign
id|page_address
c_func
(paren
id|rqstp-&gt;rq_argpages
(braket
id|rqstp-&gt;rq_argused
op_increment
)braket
)paren
suffix:semicolon
id|vec
(braket
id|pnum
)braket
dot
id|iov_len
op_assign
id|PAGE_SIZE
suffix:semicolon
id|pnum
op_increment
suffix:semicolon
id|vlen
op_add_assign
id|PAGE_SIZE
suffix:semicolon
)brace
multiline_comment|/* Now receive data */
id|len
op_assign
id|svc_recvfrom
c_func
(paren
id|rqstp
comma
id|vec
comma
id|pnum
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
l_int|0
)paren
r_goto
id|error
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;svc: TCP complete record (%d bytes)&bslash;n&quot;
comma
id|len
)paren
suffix:semicolon
id|rqstp-&gt;rq_arg.len
op_assign
id|len
suffix:semicolon
id|rqstp-&gt;rq_arg.page_base
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|len
op_le
id|rqstp-&gt;rq_arg.head
(braket
l_int|0
)braket
dot
id|iov_len
)paren
(brace
id|rqstp-&gt;rq_arg.head
(braket
l_int|0
)braket
dot
id|iov_len
op_assign
id|len
suffix:semicolon
id|rqstp-&gt;rq_arg.page_len
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|rqstp-&gt;rq_arg.page_len
op_assign
id|len
op_minus
id|rqstp-&gt;rq_arg.head
(braket
l_int|0
)braket
dot
id|iov_len
suffix:semicolon
)brace
id|rqstp-&gt;rq_skbuff
op_assign
l_int|NULL
suffix:semicolon
id|rqstp-&gt;rq_prot
op_assign
id|IPPROTO_TCP
suffix:semicolon
multiline_comment|/* Reset TCP read info */
id|svsk-&gt;sk_reclen
op_assign
l_int|0
suffix:semicolon
id|svsk-&gt;sk_tcplen
op_assign
l_int|0
suffix:semicolon
id|svc_sock_received
c_func
(paren
id|svsk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|serv-&gt;sv_stats
)paren
id|serv-&gt;sv_stats-&gt;nettcpcnt
op_increment
suffix:semicolon
r_return
id|len
suffix:semicolon
id|err_delete
suffix:colon
id|svc_delete_socket
c_func
(paren
id|svsk
)paren
suffix:semicolon
r_return
op_minus
id|EAGAIN
suffix:semicolon
id|error
suffix:colon
r_if
c_cond
(paren
id|len
op_eq
op_minus
id|EAGAIN
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;RPC: TCP recvfrom got EAGAIN&bslash;n&quot;
)paren
suffix:semicolon
id|svc_sock_received
c_func
(paren
id|svsk
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;%s: recvfrom returned errno %d&bslash;n&quot;
comma
id|svsk-&gt;sk_server-&gt;sv_name
comma
op_minus
id|len
)paren
suffix:semicolon
id|svc_sock_received
c_func
(paren
id|svsk
)paren
suffix:semicolon
)brace
r_return
id|len
suffix:semicolon
)brace
multiline_comment|/*&n; * Send out data on TCP socket.&n; */
r_static
r_int
DECL|function|svc_tcp_sendto
id|svc_tcp_sendto
c_func
(paren
r_struct
id|svc_rqst
op_star
id|rqstp
)paren
(brace
r_struct
id|xdr_buf
op_star
id|xbufp
op_assign
op_amp
id|rqstp-&gt;rq_res
suffix:semicolon
r_int
id|sent
suffix:semicolon
id|u32
id|reclen
suffix:semicolon
multiline_comment|/* Set up the first element of the reply kvec.&n;&t; * Any other kvecs that may be in use have been taken&n;&t; * care of by the server implementation itself.&n;&t; */
id|reclen
op_assign
id|htonl
c_func
(paren
l_int|0x80000000
op_or
(paren
(paren
id|xbufp-&gt;len
)paren
op_minus
l_int|4
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|xbufp-&gt;head
(braket
l_int|0
)braket
dot
id|iov_base
comma
op_amp
id|reclen
comma
l_int|4
)paren
suffix:semicolon
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|SK_DEAD
comma
op_amp
id|rqstp-&gt;rq_sock-&gt;sk_flags
)paren
)paren
r_return
op_minus
id|ENOTCONN
suffix:semicolon
id|sent
op_assign
id|svc_sendto
c_func
(paren
id|rqstp
comma
op_amp
id|rqstp-&gt;rq_res
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sent
op_ne
id|xbufp-&gt;len
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;rpc-srv/tcp: %s: %s %d when sending %d bytes - shutting down socket&bslash;n&quot;
comma
id|rqstp-&gt;rq_sock-&gt;sk_server-&gt;sv_name
comma
(paren
id|sent
OL
l_int|0
)paren
ques
c_cond
l_string|&quot;got error&quot;
suffix:colon
l_string|&quot;sent only&quot;
comma
id|sent
comma
id|xbufp-&gt;len
)paren
suffix:semicolon
id|svc_delete_socket
c_func
(paren
id|rqstp-&gt;rq_sock
)paren
suffix:semicolon
id|sent
op_assign
op_minus
id|EAGAIN
suffix:semicolon
)brace
r_return
id|sent
suffix:semicolon
)brace
r_static
r_void
DECL|function|svc_tcp_init
id|svc_tcp_init
c_func
(paren
r_struct
id|svc_sock
op_star
id|svsk
)paren
(brace
r_struct
id|sock
op_star
id|sk
op_assign
id|svsk-&gt;sk_sk
suffix:semicolon
r_struct
id|tcp_sock
op_star
id|tp
op_assign
id|tcp_sk
c_func
(paren
id|sk
)paren
suffix:semicolon
id|svsk-&gt;sk_recvfrom
op_assign
id|svc_tcp_recvfrom
suffix:semicolon
id|svsk-&gt;sk_sendto
op_assign
id|svc_tcp_sendto
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;sk_state
op_eq
id|TCP_LISTEN
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;setting up TCP socket for listening&bslash;n&quot;
)paren
suffix:semicolon
id|sk-&gt;sk_data_ready
op_assign
id|svc_tcp_listen_data_ready
suffix:semicolon
id|set_bit
c_func
(paren
id|SK_CONN
comma
op_amp
id|svsk-&gt;sk_flags
)paren
suffix:semicolon
)brace
r_else
(brace
id|dprintk
c_func
(paren
l_string|&quot;setting up TCP socket for reading&bslash;n&quot;
)paren
suffix:semicolon
id|sk-&gt;sk_state_change
op_assign
id|svc_tcp_state_change
suffix:semicolon
id|sk-&gt;sk_data_ready
op_assign
id|svc_tcp_data_ready
suffix:semicolon
id|sk-&gt;sk_write_space
op_assign
id|svc_write_space
suffix:semicolon
id|svsk-&gt;sk_reclen
op_assign
l_int|0
suffix:semicolon
id|svsk-&gt;sk_tcplen
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;nonagle
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* disable Nagle&squot;s algorithm */
multiline_comment|/* initialise setting must have enough space to&n;&t;&t; * receive and respond to one request.  &n;&t;&t; * svc_tcp_recvfrom will re-adjust if necessary&n;&t;&t; */
id|svc_sock_setbufsize
c_func
(paren
id|svsk-&gt;sk_sock
comma
l_int|3
op_star
id|svsk-&gt;sk_server-&gt;sv_bufsz
comma
l_int|3
op_star
id|svsk-&gt;sk_server-&gt;sv_bufsz
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|SK_CHNGBUF
comma
op_amp
id|svsk-&gt;sk_flags
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|SK_DATA
comma
op_amp
id|svsk-&gt;sk_flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;sk_state
op_ne
id|TCP_ESTABLISHED
)paren
id|set_bit
c_func
(paren
id|SK_CLOSE
comma
op_amp
id|svsk-&gt;sk_flags
)paren
suffix:semicolon
)brace
)brace
r_void
DECL|function|svc_sock_update_bufs
id|svc_sock_update_bufs
c_func
(paren
r_struct
id|svc_serv
op_star
id|serv
)paren
(brace
multiline_comment|/*&n;&t; * The number of server threads has changed. Update&n;&t; * rcvbuf and sndbuf accordingly on all sockets&n;&t; */
r_struct
id|list_head
op_star
id|le
suffix:semicolon
id|spin_lock_bh
c_func
(paren
op_amp
id|serv-&gt;sv_lock
)paren
suffix:semicolon
id|list_for_each
c_func
(paren
id|le
comma
op_amp
id|serv-&gt;sv_permsocks
)paren
(brace
r_struct
id|svc_sock
op_star
id|svsk
op_assign
id|list_entry
c_func
(paren
id|le
comma
r_struct
id|svc_sock
comma
id|sk_list
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|SK_CHNGBUF
comma
op_amp
id|svsk-&gt;sk_flags
)paren
suffix:semicolon
)brace
id|list_for_each
c_func
(paren
id|le
comma
op_amp
id|serv-&gt;sv_tempsocks
)paren
(brace
r_struct
id|svc_sock
op_star
id|svsk
op_assign
id|list_entry
c_func
(paren
id|le
comma
r_struct
id|svc_sock
comma
id|sk_list
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|SK_CHNGBUF
comma
op_amp
id|svsk-&gt;sk_flags
)paren
suffix:semicolon
)brace
id|spin_unlock_bh
c_func
(paren
op_amp
id|serv-&gt;sv_lock
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Receive the next request on any socket.&n; */
r_int
DECL|function|svc_recv
id|svc_recv
c_func
(paren
r_struct
id|svc_serv
op_star
id|serv
comma
r_struct
id|svc_rqst
op_star
id|rqstp
comma
r_int
id|timeout
)paren
(brace
r_struct
id|svc_sock
op_star
id|svsk
op_assign
l_int|NULL
suffix:semicolon
r_int
id|len
suffix:semicolon
r_int
id|pages
suffix:semicolon
r_struct
id|xdr_buf
op_star
id|arg
suffix:semicolon
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;svc: server %p waiting for data (to = %ld)&bslash;n&quot;
comma
id|rqstp
comma
id|timeout
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rqstp-&gt;rq_sock
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;svc_recv: service %p, socket not NULL!&bslash;n&quot;
comma
id|rqstp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|waitqueue_active
c_func
(paren
op_amp
id|rqstp-&gt;rq_wait
)paren
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;svc_recv: service %p, wait queue active!&bslash;n&quot;
comma
id|rqstp
)paren
suffix:semicolon
multiline_comment|/* Initialize the buffers */
multiline_comment|/* first reclaim pages that were moved to response list */
id|svc_pushback_allpages
c_func
(paren
id|rqstp
)paren
suffix:semicolon
multiline_comment|/* now allocate needed pages.  If we get a failure, sleep briefly */
id|pages
op_assign
l_int|2
op_plus
(paren
id|serv-&gt;sv_bufsz
op_plus
id|PAGE_SIZE
op_minus
l_int|1
)paren
op_div
id|PAGE_SIZE
suffix:semicolon
r_while
c_loop
(paren
id|rqstp-&gt;rq_arghi
OL
id|pages
)paren
(brace
r_struct
id|page
op_star
id|p
op_assign
id|alloc_page
c_func
(paren
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p
)paren
(brace
id|set_current_state
c_func
(paren
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
id|schedule_timeout
c_func
(paren
id|HZ
op_div
l_int|2
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|rqstp-&gt;rq_argpages
(braket
id|rqstp-&gt;rq_arghi
op_increment
)braket
op_assign
id|p
suffix:semicolon
)brace
multiline_comment|/* Make arg-&gt;head point to first page and arg-&gt;pages point to rest */
id|arg
op_assign
op_amp
id|rqstp-&gt;rq_arg
suffix:semicolon
id|arg-&gt;head
(braket
l_int|0
)braket
dot
id|iov_base
op_assign
id|page_address
c_func
(paren
id|rqstp-&gt;rq_argpages
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|arg-&gt;head
(braket
l_int|0
)braket
dot
id|iov_len
op_assign
id|PAGE_SIZE
suffix:semicolon
id|rqstp-&gt;rq_argused
op_assign
l_int|1
suffix:semicolon
id|arg-&gt;pages
op_assign
id|rqstp-&gt;rq_argpages
op_plus
l_int|1
suffix:semicolon
id|arg-&gt;page_base
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* save at least one page for response */
id|arg-&gt;page_len
op_assign
(paren
id|pages
op_minus
l_int|2
)paren
op_star
id|PAGE_SIZE
suffix:semicolon
id|arg-&gt;len
op_assign
(paren
id|pages
op_minus
l_int|1
)paren
op_star
id|PAGE_SIZE
suffix:semicolon
id|arg-&gt;tail
(braket
l_int|0
)braket
dot
id|iov_len
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|signalled
c_func
(paren
)paren
)paren
r_return
op_minus
id|EINTR
suffix:semicolon
id|spin_lock_bh
c_func
(paren
op_amp
id|serv-&gt;sv_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|serv-&gt;sv_tempsocks
)paren
)paren
(brace
id|svsk
op_assign
id|list_entry
c_func
(paren
id|serv-&gt;sv_tempsocks.next
comma
r_struct
id|svc_sock
comma
id|sk_list
)paren
suffix:semicolon
multiline_comment|/* apparently the &quot;standard&quot; is that clients close&n;&t;&t; * idle connections after 5 minutes, servers after&n;&t;&t; * 6 minutes&n;&t;&t; *   http://www.connectathon.org/talks96/nfstcp.pdf &n;&t;&t; */
r_if
c_cond
(paren
id|get_seconds
c_func
(paren
)paren
op_minus
id|svsk-&gt;sk_lastrecv
OL
l_int|6
op_star
l_int|60
op_logical_or
id|test_bit
c_func
(paren
id|SK_BUSY
comma
op_amp
id|svsk-&gt;sk_flags
)paren
)paren
id|svsk
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|svsk
)paren
(brace
id|set_bit
c_func
(paren
id|SK_BUSY
comma
op_amp
id|svsk-&gt;sk_flags
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|SK_CLOSE
comma
op_amp
id|svsk-&gt;sk_flags
)paren
suffix:semicolon
id|rqstp-&gt;rq_sock
op_assign
id|svsk
suffix:semicolon
id|svsk-&gt;sk_inuse
op_increment
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|svsk
op_assign
id|svc_sock_dequeue
c_func
(paren
id|serv
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|rqstp-&gt;rq_sock
op_assign
id|svsk
suffix:semicolon
id|svsk-&gt;sk_inuse
op_increment
suffix:semicolon
id|rqstp-&gt;rq_reserved
op_assign
id|serv-&gt;sv_bufsz
suffix:semicolon
id|svsk-&gt;sk_reserved
op_add_assign
id|rqstp-&gt;rq_reserved
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* No data pending. Go to sleep */
id|svc_serv_enqueue
c_func
(paren
id|serv
comma
id|rqstp
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * We have to be able to interrupt this wait&n;&t;&t; * to bring down the daemons ...&n;&t;&t; */
id|set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
id|add_wait_queue
c_func
(paren
op_amp
id|rqstp-&gt;rq_wait
comma
op_amp
id|wait
)paren
suffix:semicolon
id|spin_unlock_bh
c_func
(paren
op_amp
id|serv-&gt;sv_lock
)paren
suffix:semicolon
id|schedule_timeout
c_func
(paren
id|timeout
)paren
suffix:semicolon
id|try_to_freeze
c_func
(paren
id|PF_FREEZE
)paren
suffix:semicolon
id|spin_lock_bh
c_func
(paren
op_amp
id|serv-&gt;sv_lock
)paren
suffix:semicolon
id|remove_wait_queue
c_func
(paren
op_amp
id|rqstp-&gt;rq_wait
comma
op_amp
id|wait
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|svsk
op_assign
id|rqstp-&gt;rq_sock
)paren
)paren
(brace
id|svc_serv_dequeue
c_func
(paren
id|serv
comma
id|rqstp
)paren
suffix:semicolon
id|spin_unlock_bh
c_func
(paren
op_amp
id|serv-&gt;sv_lock
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;svc: server %p, no data yet&bslash;n&quot;
comma
id|rqstp
)paren
suffix:semicolon
r_return
id|signalled
c_func
(paren
)paren
ques
c_cond
op_minus
id|EINTR
suffix:colon
op_minus
id|EAGAIN
suffix:semicolon
)brace
)brace
id|spin_unlock_bh
c_func
(paren
op_amp
id|serv-&gt;sv_lock
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;svc: server %p, socket %p, inuse=%d&bslash;n&quot;
comma
id|rqstp
comma
id|svsk
comma
id|svsk-&gt;sk_inuse
)paren
suffix:semicolon
id|len
op_assign
id|svsk
op_member_access_from_pointer
id|sk_recvfrom
c_func
(paren
id|rqstp
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;svc: got len=%d&bslash;n&quot;
comma
id|len
)paren
suffix:semicolon
multiline_comment|/* No data, incomplete (TCP) read, or accept() */
r_if
c_cond
(paren
id|len
op_eq
l_int|0
op_logical_or
id|len
op_eq
op_minus
id|EAGAIN
)paren
(brace
id|rqstp-&gt;rq_res.len
op_assign
l_int|0
suffix:semicolon
id|svc_sock_release
c_func
(paren
id|rqstp
)paren
suffix:semicolon
r_return
op_minus
id|EAGAIN
suffix:semicolon
)brace
id|svsk-&gt;sk_lastrecv
op_assign
id|get_seconds
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|SK_TEMP
comma
op_amp
id|svsk-&gt;sk_flags
)paren
)paren
(brace
multiline_comment|/* push active sockets to end of list */
id|spin_lock_bh
c_func
(paren
op_amp
id|serv-&gt;sv_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|svsk-&gt;sk_list
)paren
)paren
id|list_move_tail
c_func
(paren
op_amp
id|svsk-&gt;sk_list
comma
op_amp
id|serv-&gt;sv_tempsocks
)paren
suffix:semicolon
id|spin_unlock_bh
c_func
(paren
op_amp
id|serv-&gt;sv_lock
)paren
suffix:semicolon
)brace
id|rqstp-&gt;rq_secure
op_assign
id|ntohs
c_func
(paren
id|rqstp-&gt;rq_addr.sin_port
)paren
OL
l_int|1024
suffix:semicolon
id|rqstp-&gt;rq_chandle.defer
op_assign
id|svc_defer
suffix:semicolon
r_if
c_cond
(paren
id|serv-&gt;sv_stats
)paren
id|serv-&gt;sv_stats-&gt;netcnt
op_increment
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
multiline_comment|/* &n; * Drop request&n; */
r_void
DECL|function|svc_drop
id|svc_drop
c_func
(paren
r_struct
id|svc_rqst
op_star
id|rqstp
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;svc: socket %p dropped request&bslash;n&quot;
comma
id|rqstp-&gt;rq_sock
)paren
suffix:semicolon
id|svc_sock_release
c_func
(paren
id|rqstp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Return reply to client.&n; */
r_int
DECL|function|svc_send
id|svc_send
c_func
(paren
r_struct
id|svc_rqst
op_star
id|rqstp
)paren
(brace
r_struct
id|svc_sock
op_star
id|svsk
suffix:semicolon
r_int
id|len
suffix:semicolon
r_struct
id|xdr_buf
op_star
id|xb
suffix:semicolon
r_if
c_cond
(paren
(paren
id|svsk
op_assign
id|rqstp-&gt;rq_sock
)paren
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;NULL socket pointer in %s:%d&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
)paren
suffix:semicolon
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
multiline_comment|/* release the receive skb before sending the reply */
id|svc_release_skb
c_func
(paren
id|rqstp
)paren
suffix:semicolon
multiline_comment|/* calculate over-all length */
id|xb
op_assign
op_amp
id|rqstp-&gt;rq_res
suffix:semicolon
id|xb-&gt;len
op_assign
id|xb-&gt;head
(braket
l_int|0
)braket
dot
id|iov_len
op_plus
id|xb-&gt;page_len
op_plus
id|xb-&gt;tail
(braket
l_int|0
)braket
dot
id|iov_len
suffix:semicolon
multiline_comment|/* Grab svsk-&gt;sk_sem to serialize outgoing data. */
id|down
c_func
(paren
op_amp
id|svsk-&gt;sk_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|SK_DEAD
comma
op_amp
id|svsk-&gt;sk_flags
)paren
)paren
id|len
op_assign
op_minus
id|ENOTCONN
suffix:semicolon
r_else
id|len
op_assign
id|svsk
op_member_access_from_pointer
id|sk_sendto
c_func
(paren
id|rqstp
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|svsk-&gt;sk_sem
)paren
suffix:semicolon
id|svc_sock_release
c_func
(paren
id|rqstp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
op_eq
op_minus
id|ECONNREFUSED
op_logical_or
id|len
op_eq
op_minus
id|ENOTCONN
op_logical_or
id|len
op_eq
op_minus
id|EAGAIN
)paren
r_return
l_int|0
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
multiline_comment|/*&n; * Initialize socket for RPC use and create svc_sock struct&n; * XXX: May want to setsockopt SO_SNDBUF and SO_RCVBUF.&n; */
r_static
r_struct
id|svc_sock
op_star
DECL|function|svc_setup_socket
id|svc_setup_socket
c_func
(paren
r_struct
id|svc_serv
op_star
id|serv
comma
r_struct
id|socket
op_star
id|sock
comma
r_int
op_star
id|errp
comma
r_int
id|pmap_register
)paren
(brace
r_struct
id|svc_sock
op_star
id|svsk
suffix:semicolon
r_struct
id|sock
op_star
id|inet
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;svc: svc_setup_socket %p&bslash;n&quot;
comma
id|sock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|svsk
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|svsk
)paren
comma
id|GFP_KERNEL
)paren
)paren
)paren
(brace
op_star
id|errp
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|memset
c_func
(paren
id|svsk
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|svsk
)paren
)paren
suffix:semicolon
id|inet
op_assign
id|sock-&gt;sk
suffix:semicolon
multiline_comment|/* Register socket with portmapper */
r_if
c_cond
(paren
op_star
id|errp
op_ge
l_int|0
op_logical_and
id|pmap_register
)paren
op_star
id|errp
op_assign
id|svc_register
c_func
(paren
id|serv
comma
id|inet-&gt;sk_protocol
comma
id|ntohs
c_func
(paren
id|inet_sk
c_func
(paren
id|inet
)paren
op_member_access_from_pointer
id|sport
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|errp
OL
l_int|0
)paren
(brace
id|kfree
c_func
(paren
id|svsk
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|set_bit
c_func
(paren
id|SK_BUSY
comma
op_amp
id|svsk-&gt;sk_flags
)paren
suffix:semicolon
id|inet-&gt;sk_user_data
op_assign
id|svsk
suffix:semicolon
id|svsk-&gt;sk_sock
op_assign
id|sock
suffix:semicolon
id|svsk-&gt;sk_sk
op_assign
id|inet
suffix:semicolon
id|svsk-&gt;sk_ostate
op_assign
id|inet-&gt;sk_state_change
suffix:semicolon
id|svsk-&gt;sk_odata
op_assign
id|inet-&gt;sk_data_ready
suffix:semicolon
id|svsk-&gt;sk_owspace
op_assign
id|inet-&gt;sk_write_space
suffix:semicolon
id|svsk-&gt;sk_server
op_assign
id|serv
suffix:semicolon
id|svsk-&gt;sk_lastrecv
op_assign
id|get_seconds
c_func
(paren
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|svsk-&gt;sk_deferred
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|svsk-&gt;sk_ready
)paren
suffix:semicolon
id|sema_init
c_func
(paren
op_amp
id|svsk-&gt;sk_sem
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Initialize the socket */
r_if
c_cond
(paren
id|sock-&gt;type
op_eq
id|SOCK_DGRAM
)paren
id|svc_udp_init
c_func
(paren
id|svsk
)paren
suffix:semicolon
r_else
id|svc_tcp_init
c_func
(paren
id|svsk
)paren
suffix:semicolon
id|spin_lock_bh
c_func
(paren
op_amp
id|serv-&gt;sv_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pmap_register
)paren
(brace
id|set_bit
c_func
(paren
id|SK_TEMP
comma
op_amp
id|svsk-&gt;sk_flags
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|svsk-&gt;sk_list
comma
op_amp
id|serv-&gt;sv_tempsocks
)paren
suffix:semicolon
id|serv-&gt;sv_tmpcnt
op_increment
suffix:semicolon
)brace
r_else
(brace
id|clear_bit
c_func
(paren
id|SK_TEMP
comma
op_amp
id|svsk-&gt;sk_flags
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|svsk-&gt;sk_list
comma
op_amp
id|serv-&gt;sv_permsocks
)paren
suffix:semicolon
)brace
id|spin_unlock_bh
c_func
(paren
op_amp
id|serv-&gt;sv_lock
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;svc: svc_setup_socket created %p (inet %p)&bslash;n&quot;
comma
id|svsk
comma
id|svsk-&gt;sk_sk
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|SK_BUSY
comma
op_amp
id|svsk-&gt;sk_flags
)paren
suffix:semicolon
id|svc_sock_enqueue
c_func
(paren
id|svsk
)paren
suffix:semicolon
r_return
id|svsk
suffix:semicolon
)brace
multiline_comment|/*&n; * Create socket for RPC service.&n; */
r_static
r_int
DECL|function|svc_create_socket
id|svc_create_socket
c_func
(paren
r_struct
id|svc_serv
op_star
id|serv
comma
r_int
id|protocol
comma
r_struct
id|sockaddr_in
op_star
id|sin
)paren
(brace
r_struct
id|svc_sock
op_star
id|svsk
suffix:semicolon
r_struct
id|socket
op_star
id|sock
suffix:semicolon
r_int
id|error
suffix:semicolon
r_int
id|type
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;svc: svc_create_socket(%s, %d, %u.%u.%u.%u:%d)&bslash;n&quot;
comma
id|serv-&gt;sv_program-&gt;pg_name
comma
id|protocol
comma
id|NIPQUAD
c_func
(paren
id|sin-&gt;sin_addr.s_addr
)paren
comma
id|ntohs
c_func
(paren
id|sin-&gt;sin_port
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|protocol
op_ne
id|IPPROTO_UDP
op_logical_and
id|protocol
op_ne
id|IPPROTO_TCP
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;svc: only UDP and TCP &quot;
l_string|&quot;sockets supported&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|type
op_assign
(paren
id|protocol
op_eq
id|IPPROTO_UDP
)paren
ques
c_cond
id|SOCK_DGRAM
suffix:colon
id|SOCK_STREAM
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|sock_create_kern
c_func
(paren
id|PF_INET
comma
id|type
comma
id|protocol
comma
op_amp
id|sock
)paren
)paren
OL
l_int|0
)paren
r_return
id|error
suffix:semicolon
r_if
c_cond
(paren
id|sin
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|type
op_eq
id|SOCK_STREAM
)paren
id|sock-&gt;sk-&gt;sk_reuse
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* allow address reuse */
id|error
op_assign
id|sock-&gt;ops
op_member_access_from_pointer
id|bind
c_func
(paren
id|sock
comma
(paren
r_struct
id|sockaddr
op_star
)paren
id|sin
comma
r_sizeof
(paren
op_star
id|sin
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
OL
l_int|0
)paren
r_goto
id|bummer
suffix:semicolon
)brace
r_if
c_cond
(paren
id|protocol
op_eq
id|IPPROTO_TCP
)paren
(brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|sock-&gt;ops
op_member_access_from_pointer
id|listen
c_func
(paren
id|sock
comma
l_int|64
)paren
)paren
OL
l_int|0
)paren
r_goto
id|bummer
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|svsk
op_assign
id|svc_setup_socket
c_func
(paren
id|serv
comma
id|sock
comma
op_amp
id|error
comma
l_int|1
)paren
)paren
op_ne
l_int|NULL
)paren
r_return
l_int|0
suffix:semicolon
id|bummer
suffix:colon
id|dprintk
c_func
(paren
l_string|&quot;svc: svc_create_socket error = %d&bslash;n&quot;
comma
op_minus
id|error
)paren
suffix:semicolon
id|sock_release
c_func
(paren
id|sock
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * Remove a dead socket&n; */
r_void
DECL|function|svc_delete_socket
id|svc_delete_socket
c_func
(paren
r_struct
id|svc_sock
op_star
id|svsk
)paren
(brace
r_struct
id|svc_serv
op_star
id|serv
suffix:semicolon
r_struct
id|sock
op_star
id|sk
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;svc: svc_delete_socket(%p)&bslash;n&quot;
comma
id|svsk
)paren
suffix:semicolon
id|serv
op_assign
id|svsk-&gt;sk_server
suffix:semicolon
id|sk
op_assign
id|svsk-&gt;sk_sk
suffix:semicolon
id|sk-&gt;sk_state_change
op_assign
id|svsk-&gt;sk_ostate
suffix:semicolon
id|sk-&gt;sk_data_ready
op_assign
id|svsk-&gt;sk_odata
suffix:semicolon
id|sk-&gt;sk_write_space
op_assign
id|svsk-&gt;sk_owspace
suffix:semicolon
id|spin_lock_bh
c_func
(paren
op_amp
id|serv-&gt;sv_lock
)paren
suffix:semicolon
id|list_del_init
c_func
(paren
op_amp
id|svsk-&gt;sk_list
)paren
suffix:semicolon
id|list_del_init
c_func
(paren
op_amp
id|svsk-&gt;sk_ready
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|test_and_set_bit
c_func
(paren
id|SK_DEAD
comma
op_amp
id|svsk-&gt;sk_flags
)paren
)paren
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|SK_TEMP
comma
op_amp
id|svsk-&gt;sk_flags
)paren
)paren
id|serv-&gt;sv_tmpcnt
op_decrement
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|svsk-&gt;sk_inuse
)paren
(brace
id|spin_unlock_bh
c_func
(paren
op_amp
id|serv-&gt;sv_lock
)paren
suffix:semicolon
id|sock_release
c_func
(paren
id|svsk-&gt;sk_sock
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|svsk
)paren
suffix:semicolon
)brace
r_else
(brace
id|spin_unlock_bh
c_func
(paren
op_amp
id|serv-&gt;sv_lock
)paren
suffix:semicolon
id|dprintk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;svc: server socket destroy delayed&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* svsk-&gt;sk_server = NULL; */
)brace
)brace
multiline_comment|/*&n; * Make a socket for nfsd and lockd&n; */
r_int
DECL|function|svc_makesock
id|svc_makesock
c_func
(paren
r_struct
id|svc_serv
op_star
id|serv
comma
r_int
id|protocol
comma
r_int
r_int
id|port
)paren
(brace
r_struct
id|sockaddr_in
id|sin
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;svc: creating socket proto = %d&bslash;n&quot;
comma
id|protocol
)paren
suffix:semicolon
id|sin.sin_family
op_assign
id|AF_INET
suffix:semicolon
id|sin.sin_addr.s_addr
op_assign
id|INADDR_ANY
suffix:semicolon
id|sin.sin_port
op_assign
id|htons
c_func
(paren
id|port
)paren
suffix:semicolon
r_return
id|svc_create_socket
c_func
(paren
id|serv
comma
id|protocol
comma
op_amp
id|sin
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Handle defer and revisit of requests &n; */
DECL|function|svc_revisit
r_static
r_void
id|svc_revisit
c_func
(paren
r_struct
id|cache_deferred_req
op_star
id|dreq
comma
r_int
id|too_many
)paren
(brace
r_struct
id|svc_deferred_req
op_star
id|dr
op_assign
id|container_of
c_func
(paren
id|dreq
comma
r_struct
id|svc_deferred_req
comma
id|handle
)paren
suffix:semicolon
r_struct
id|svc_serv
op_star
id|serv
op_assign
id|dreq-&gt;owner
suffix:semicolon
r_struct
id|svc_sock
op_star
id|svsk
suffix:semicolon
r_if
c_cond
(paren
id|too_many
)paren
(brace
id|svc_sock_put
c_func
(paren
id|dr-&gt;svsk
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|dr
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|dprintk
c_func
(paren
l_string|&quot;revisit queued&bslash;n&quot;
)paren
suffix:semicolon
id|svsk
op_assign
id|dr-&gt;svsk
suffix:semicolon
id|dr-&gt;svsk
op_assign
l_int|NULL
suffix:semicolon
id|spin_lock_bh
c_func
(paren
op_amp
id|serv-&gt;sv_lock
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|dr-&gt;handle.recent
comma
op_amp
id|svsk-&gt;sk_deferred
)paren
suffix:semicolon
id|spin_unlock_bh
c_func
(paren
op_amp
id|serv-&gt;sv_lock
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|SK_DEFERRED
comma
op_amp
id|svsk-&gt;sk_flags
)paren
suffix:semicolon
id|svc_sock_enqueue
c_func
(paren
id|svsk
)paren
suffix:semicolon
id|svc_sock_put
c_func
(paren
id|svsk
)paren
suffix:semicolon
)brace
r_static
r_struct
id|cache_deferred_req
op_star
DECL|function|svc_defer
id|svc_defer
c_func
(paren
r_struct
id|cache_req
op_star
id|req
)paren
(brace
r_struct
id|svc_rqst
op_star
id|rqstp
op_assign
id|container_of
c_func
(paren
id|req
comma
r_struct
id|svc_rqst
comma
id|rq_chandle
)paren
suffix:semicolon
r_int
id|size
op_assign
r_sizeof
(paren
r_struct
id|svc_deferred_req
)paren
op_plus
(paren
id|rqstp-&gt;rq_arg.len
)paren
suffix:semicolon
r_struct
id|svc_deferred_req
op_star
id|dr
suffix:semicolon
r_if
c_cond
(paren
id|rqstp-&gt;rq_arg.page_len
)paren
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/* if more than a page, give up FIXME */
r_if
c_cond
(paren
id|rqstp-&gt;rq_deferred
)paren
(brace
id|dr
op_assign
id|rqstp-&gt;rq_deferred
suffix:semicolon
id|rqstp-&gt;rq_deferred
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
(brace
r_int
id|skip
op_assign
id|rqstp-&gt;rq_arg.len
op_minus
id|rqstp-&gt;rq_arg.head
(braket
l_int|0
)braket
dot
id|iov_len
suffix:semicolon
multiline_comment|/* FIXME maybe discard if size too large */
id|dr
op_assign
id|kmalloc
c_func
(paren
id|size
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dr
op_eq
l_int|NULL
)paren
r_return
l_int|NULL
suffix:semicolon
id|dr-&gt;handle.owner
op_assign
id|rqstp-&gt;rq_server
suffix:semicolon
id|dr-&gt;prot
op_assign
id|rqstp-&gt;rq_prot
suffix:semicolon
id|dr-&gt;addr
op_assign
id|rqstp-&gt;rq_addr
suffix:semicolon
id|dr-&gt;argslen
op_assign
id|rqstp-&gt;rq_arg.len
op_rshift
l_int|2
suffix:semicolon
id|memcpy
c_func
(paren
id|dr-&gt;args
comma
id|rqstp-&gt;rq_arg.head
(braket
l_int|0
)braket
dot
id|iov_base
op_minus
id|skip
comma
id|dr-&gt;argslen
op_lshift
l_int|2
)paren
suffix:semicolon
)brace
id|spin_lock_bh
c_func
(paren
op_amp
id|rqstp-&gt;rq_server-&gt;sv_lock
)paren
suffix:semicolon
id|rqstp-&gt;rq_sock-&gt;sk_inuse
op_increment
suffix:semicolon
id|dr-&gt;svsk
op_assign
id|rqstp-&gt;rq_sock
suffix:semicolon
id|spin_unlock_bh
c_func
(paren
op_amp
id|rqstp-&gt;rq_server-&gt;sv_lock
)paren
suffix:semicolon
id|dr-&gt;handle.revisit
op_assign
id|svc_revisit
suffix:semicolon
r_return
op_amp
id|dr-&gt;handle
suffix:semicolon
)brace
multiline_comment|/*&n; * recv data from a deferred request into an active one&n; */
DECL|function|svc_deferred_recv
r_static
r_int
id|svc_deferred_recv
c_func
(paren
r_struct
id|svc_rqst
op_star
id|rqstp
)paren
(brace
r_struct
id|svc_deferred_req
op_star
id|dr
op_assign
id|rqstp-&gt;rq_deferred
suffix:semicolon
id|rqstp-&gt;rq_arg.head
(braket
l_int|0
)braket
dot
id|iov_base
op_assign
id|dr-&gt;args
suffix:semicolon
id|rqstp-&gt;rq_arg.head
(braket
l_int|0
)braket
dot
id|iov_len
op_assign
id|dr-&gt;argslen
op_lshift
l_int|2
suffix:semicolon
id|rqstp-&gt;rq_arg.page_len
op_assign
l_int|0
suffix:semicolon
id|rqstp-&gt;rq_arg.len
op_assign
id|dr-&gt;argslen
op_lshift
l_int|2
suffix:semicolon
id|rqstp-&gt;rq_prot
op_assign
id|dr-&gt;prot
suffix:semicolon
id|rqstp-&gt;rq_addr
op_assign
id|dr-&gt;addr
suffix:semicolon
r_return
id|dr-&gt;argslen
op_lshift
l_int|2
suffix:semicolon
)brace
DECL|function|svc_deferred_dequeue
r_static
r_struct
id|svc_deferred_req
op_star
id|svc_deferred_dequeue
c_func
(paren
r_struct
id|svc_sock
op_star
id|svsk
)paren
(brace
r_struct
id|svc_deferred_req
op_star
id|dr
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|svc_serv
op_star
id|serv
op_assign
id|svsk-&gt;sk_server
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|test_bit
c_func
(paren
id|SK_DEFERRED
comma
op_amp
id|svsk-&gt;sk_flags
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
id|spin_lock_bh
c_func
(paren
op_amp
id|serv-&gt;sv_lock
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|SK_DEFERRED
comma
op_amp
id|svsk-&gt;sk_flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|svsk-&gt;sk_deferred
)paren
)paren
(brace
id|dr
op_assign
id|list_entry
c_func
(paren
id|svsk-&gt;sk_deferred.next
comma
r_struct
id|svc_deferred_req
comma
id|handle.recent
)paren
suffix:semicolon
id|list_del_init
c_func
(paren
op_amp
id|dr-&gt;handle.recent
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|SK_DEFERRED
comma
op_amp
id|svsk-&gt;sk_flags
)paren
suffix:semicolon
)brace
id|spin_unlock_bh
c_func
(paren
op_amp
id|serv-&gt;sv_lock
)paren
suffix:semicolon
r_return
id|dr
suffix:semicolon
)brace
eof
