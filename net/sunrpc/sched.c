multiline_comment|/*&n; * linux/net/sunrpc/sched.c&n; *&n; * Scheduling for synchronous and asynchronous RPC requests.&n; *&n; * Copyright (C) 1996 Olaf Kirch, &lt;okir@monad.swb.de&gt;&n; * &n; * TCP NFS related read + write fixes&n; * (C) 1999 Dave Airlie, University of Limerick, Ireland &lt;airlied@linux.ie&gt;&n; */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/mempool.h&gt;
macro_line|#include &lt;linux/smp.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/suspend.h&gt;
macro_line|#include &lt;linux/sunrpc/clnt.h&gt;
macro_line|#include &lt;linux/sunrpc/xprt.h&gt;
macro_line|#ifdef RPC_DEBUG
DECL|macro|RPCDBG_FACILITY
mdefine_line|#define RPCDBG_FACILITY&t;&t;RPCDBG_SCHED
DECL|variable|rpc_task_id
r_static
r_int
id|rpc_task_id
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; * RPC slabs and memory pools&n; */
DECL|macro|RPC_BUFFER_MAXSIZE
mdefine_line|#define RPC_BUFFER_MAXSIZE&t;(2048)
DECL|macro|RPC_BUFFER_POOLSIZE
mdefine_line|#define RPC_BUFFER_POOLSIZE&t;(8)
DECL|macro|RPC_TASK_POOLSIZE
mdefine_line|#define RPC_TASK_POOLSIZE&t;(8)
DECL|variable|rpc_task_slabp
r_static
id|kmem_cache_t
op_star
id|rpc_task_slabp
suffix:semicolon
DECL|variable|rpc_buffer_slabp
r_static
id|kmem_cache_t
op_star
id|rpc_buffer_slabp
suffix:semicolon
DECL|variable|rpc_task_mempool
r_static
id|mempool_t
op_star
id|rpc_task_mempool
suffix:semicolon
DECL|variable|rpc_buffer_mempool
r_static
id|mempool_t
op_star
id|rpc_buffer_mempool
suffix:semicolon
r_static
r_void
id|__rpc_default_timer
c_func
(paren
r_struct
id|rpc_task
op_star
id|task
)paren
suffix:semicolon
r_static
r_void
id|rpciod_killall
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|rpc_free
c_func
(paren
r_struct
id|rpc_task
op_star
id|task
)paren
suffix:semicolon
multiline_comment|/*&n; * When an asynchronous RPC task is activated within a bottom half&n; * handler, or while executing another RPC task, it is put on&n; * schedq, and rpciod is woken up.&n; */
r_static
id|RPC_WAITQ
c_func
(paren
id|schedq
comma
l_string|&quot;schedq&quot;
)paren
suffix:semicolon
multiline_comment|/*&n; * RPC tasks that create another task (e.g. for contacting the portmapper)&n; * will wait on this queue for their child&squot;s completion&n; */
r_static
id|RPC_WAITQ
c_func
(paren
id|childq
comma
l_string|&quot;childq&quot;
)paren
suffix:semicolon
multiline_comment|/*&n; * RPC tasks sit here while waiting for conditions to improve.&n; */
r_static
id|RPC_WAITQ
c_func
(paren
id|delay_queue
comma
l_string|&quot;delayq&quot;
)paren
suffix:semicolon
multiline_comment|/*&n; * All RPC tasks are linked into this list&n; */
r_static
id|LIST_HEAD
c_func
(paren
id|all_tasks
)paren
suffix:semicolon
multiline_comment|/*&n; * rpciod-related stuff&n; */
r_static
id|DECLARE_WAIT_QUEUE_HEAD
c_func
(paren
id|rpciod_idle
)paren
suffix:semicolon
r_static
id|DECLARE_COMPLETION
c_func
(paren
id|rpciod_killer
)paren
suffix:semicolon
r_static
id|DECLARE_MUTEX
c_func
(paren
id|rpciod_sema
)paren
suffix:semicolon
DECL|variable|rpciod_users
r_static
r_int
r_int
id|rpciod_users
suffix:semicolon
DECL|variable|rpciod_pid
r_static
id|pid_t
id|rpciod_pid
suffix:semicolon
DECL|variable|rpc_inhibit
r_static
r_int
id|rpc_inhibit
suffix:semicolon
multiline_comment|/*&n; * Spinlock for wait queues. Access to the latter also has to be&n; * interrupt-safe in order to allow timers to wake up sleeping tasks.&n; */
DECL|variable|rpc_queue_lock
r_static
id|spinlock_t
id|rpc_queue_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
multiline_comment|/*&n; * Spinlock for other critical sections of code.&n; */
DECL|variable|rpc_sched_lock
r_static
id|spinlock_t
id|rpc_sched_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
multiline_comment|/*&n; * Disable the timer for a given RPC task. Should be called with&n; * rpc_queue_lock and bh_disabled in order to avoid races within&n; * rpc_run_timer().&n; */
r_static
r_inline
r_void
DECL|function|__rpc_disable_timer
id|__rpc_disable_timer
c_func
(paren
r_struct
id|rpc_task
op_star
id|task
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;RPC: %4d disabling timer&bslash;n&quot;
comma
id|task-&gt;tk_pid
)paren
suffix:semicolon
id|task-&gt;tk_timeout_fn
op_assign
l_int|NULL
suffix:semicolon
id|task-&gt;tk_timeout
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Run a timeout function.&n; * We use the callback in order to allow __rpc_wake_up_task()&n; * and friends to disable the timer synchronously on SMP systems&n; * without calling del_timer_sync(). The latter could cause a&n; * deadlock if called while we&squot;re holding spinlocks...&n; */
r_static
r_void
DECL|function|rpc_run_timer
id|rpc_run_timer
c_func
(paren
r_struct
id|rpc_task
op_star
id|task
)paren
(brace
r_void
(paren
op_star
id|callback
)paren
(paren
r_struct
id|rpc_task
op_star
)paren
suffix:semicolon
id|spin_lock_bh
c_func
(paren
op_amp
id|rpc_queue_lock
)paren
suffix:semicolon
id|callback
op_assign
id|task-&gt;tk_timeout_fn
suffix:semicolon
id|task-&gt;tk_timeout_fn
op_assign
l_int|NULL
suffix:semicolon
id|spin_unlock_bh
c_func
(paren
op_amp
id|rpc_queue_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|callback
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;RPC: %4d running timer&bslash;n&quot;
comma
id|task-&gt;tk_pid
)paren
suffix:semicolon
id|callback
c_func
(paren
id|task
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Set up a timer for the current task.&n; */
r_static
r_inline
r_void
DECL|function|__rpc_add_timer
id|__rpc_add_timer
c_func
(paren
r_struct
id|rpc_task
op_star
id|task
comma
id|rpc_action
id|timer
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|task-&gt;tk_timeout
)paren
r_return
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;RPC: %4d setting alarm for %lu ms&bslash;n&quot;
comma
id|task-&gt;tk_pid
comma
id|task-&gt;tk_timeout
op_star
l_int|1000
op_div
id|HZ
)paren
suffix:semicolon
r_if
c_cond
(paren
id|timer
)paren
id|task-&gt;tk_timeout_fn
op_assign
id|timer
suffix:semicolon
r_else
id|task-&gt;tk_timeout_fn
op_assign
id|__rpc_default_timer
suffix:semicolon
id|mod_timer
c_func
(paren
op_amp
id|task-&gt;tk_timer
comma
id|jiffies
op_plus
id|task-&gt;tk_timeout
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Set up a timer for an already sleeping task.&n; */
DECL|function|rpc_add_timer
r_void
id|rpc_add_timer
c_func
(paren
r_struct
id|rpc_task
op_star
id|task
comma
id|rpc_action
id|timer
)paren
(brace
id|spin_lock_bh
c_func
(paren
op_amp
id|rpc_queue_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|RPC_IS_RUNNING
c_func
(paren
id|task
)paren
)paren
id|__rpc_add_timer
c_func
(paren
id|task
comma
id|timer
)paren
suffix:semicolon
id|spin_unlock_bh
c_func
(paren
op_amp
id|rpc_queue_lock
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Delete any timer for the current task. Because we use del_timer_sync(),&n; * this function should never be called while holding rpc_queue_lock.&n; */
r_static
r_inline
r_void
DECL|function|rpc_delete_timer
id|rpc_delete_timer
c_func
(paren
r_struct
id|rpc_task
op_star
id|task
)paren
(brace
r_if
c_cond
(paren
id|del_timer_sync
c_func
(paren
op_amp
id|task-&gt;tk_timer
)paren
)paren
id|dprintk
c_func
(paren
l_string|&quot;RPC: %4d deleting timer&bslash;n&quot;
comma
id|task-&gt;tk_pid
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Add new request to a priority queue.&n; */
DECL|function|__rpc_add_wait_queue_priority
r_static
r_void
id|__rpc_add_wait_queue_priority
c_func
(paren
r_struct
id|rpc_wait_queue
op_star
id|queue
comma
r_struct
id|rpc_task
op_star
id|task
)paren
(brace
r_struct
id|list_head
op_star
id|q
suffix:semicolon
r_struct
id|rpc_task
op_star
id|t
suffix:semicolon
id|q
op_assign
op_amp
id|queue-&gt;tasks
(braket
id|task-&gt;tk_priority
)braket
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|task-&gt;tk_priority
OG
id|queue-&gt;maxpriority
)paren
)paren
id|q
op_assign
op_amp
id|queue-&gt;tasks
(braket
id|queue-&gt;maxpriority
)braket
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|t
comma
id|q
comma
id|tk_list
)paren
(brace
r_if
c_cond
(paren
id|t-&gt;tk_cookie
op_eq
id|task-&gt;tk_cookie
)paren
(brace
id|list_add_tail
c_func
(paren
op_amp
id|task-&gt;tk_list
comma
op_amp
id|t-&gt;tk_links
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
id|list_add_tail
c_func
(paren
op_amp
id|task-&gt;tk_list
comma
id|q
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Add new request to wait queue.&n; *&n; * Swapper tasks always get inserted at the head of the queue.&n; * This should avoid many nasty memory deadlocks and hopefully&n; * improve overall performance.&n; * Everyone else gets appended to the queue to ensure proper FIFO behavior.&n; */
DECL|function|__rpc_add_wait_queue
r_static
r_int
id|__rpc_add_wait_queue
c_func
(paren
r_struct
id|rpc_wait_queue
op_star
id|queue
comma
r_struct
id|rpc_task
op_star
id|task
)paren
(brace
r_if
c_cond
(paren
id|task-&gt;tk_rpcwait
op_eq
id|queue
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|task-&gt;tk_rpcwait
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;RPC: doubly enqueued task!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EWOULDBLOCK
suffix:semicolon
)brace
r_if
c_cond
(paren
id|RPC_IS_PRIORITY
c_func
(paren
id|queue
)paren
)paren
id|__rpc_add_wait_queue_priority
c_func
(paren
id|queue
comma
id|task
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|RPC_IS_SWAPPER
c_func
(paren
id|task
)paren
)paren
id|list_add
c_func
(paren
op_amp
id|task-&gt;tk_list
comma
op_amp
id|queue-&gt;tasks
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_else
id|list_add_tail
c_func
(paren
op_amp
id|task-&gt;tk_list
comma
op_amp
id|queue-&gt;tasks
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|task-&gt;tk_rpcwait
op_assign
id|queue
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;RPC: %4d added to queue %p &bslash;&quot;%s&bslash;&quot;&bslash;n&quot;
comma
id|task-&gt;tk_pid
comma
id|queue
comma
id|rpc_qname
c_func
(paren
id|queue
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|rpc_add_wait_queue
r_int
id|rpc_add_wait_queue
c_func
(paren
r_struct
id|rpc_wait_queue
op_star
id|q
comma
r_struct
id|rpc_task
op_star
id|task
)paren
(brace
r_int
id|result
suffix:semicolon
id|spin_lock_bh
c_func
(paren
op_amp
id|rpc_queue_lock
)paren
suffix:semicolon
id|result
op_assign
id|__rpc_add_wait_queue
c_func
(paren
id|q
comma
id|task
)paren
suffix:semicolon
id|spin_unlock_bh
c_func
(paren
op_amp
id|rpc_queue_lock
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/*&n; * Remove request from a priority queue.&n; */
DECL|function|__rpc_remove_wait_queue_priority
r_static
r_void
id|__rpc_remove_wait_queue_priority
c_func
(paren
r_struct
id|rpc_task
op_star
id|task
)paren
(brace
r_struct
id|rpc_task
op_star
id|t
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|task-&gt;tk_links
)paren
)paren
(brace
id|t
op_assign
id|list_entry
c_func
(paren
id|task-&gt;tk_links.next
comma
r_struct
id|rpc_task
comma
id|tk_list
)paren
suffix:semicolon
id|list_move
c_func
(paren
op_amp
id|t-&gt;tk_list
comma
op_amp
id|task-&gt;tk_list
)paren
suffix:semicolon
id|list_splice_init
c_func
(paren
op_amp
id|task-&gt;tk_links
comma
op_amp
id|t-&gt;tk_links
)paren
suffix:semicolon
)brace
id|list_del
c_func
(paren
op_amp
id|task-&gt;tk_list
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Remove request from queue.&n; * Note: must be called with spin lock held.&n; */
DECL|function|__rpc_remove_wait_queue
r_static
r_void
id|__rpc_remove_wait_queue
c_func
(paren
r_struct
id|rpc_task
op_star
id|task
)paren
(brace
r_struct
id|rpc_wait_queue
op_star
id|queue
op_assign
id|task-&gt;tk_rpcwait
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|queue
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|RPC_IS_PRIORITY
c_func
(paren
id|queue
)paren
)paren
id|__rpc_remove_wait_queue_priority
c_func
(paren
id|task
)paren
suffix:semicolon
r_else
id|list_del
c_func
(paren
op_amp
id|task-&gt;tk_list
)paren
suffix:semicolon
id|task-&gt;tk_rpcwait
op_assign
l_int|NULL
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;RPC: %4d removed from queue %p &bslash;&quot;%s&bslash;&quot;&bslash;n&quot;
comma
id|task-&gt;tk_pid
comma
id|queue
comma
id|rpc_qname
c_func
(paren
id|queue
)paren
)paren
suffix:semicolon
)brace
r_void
DECL|function|rpc_remove_wait_queue
id|rpc_remove_wait_queue
c_func
(paren
r_struct
id|rpc_task
op_star
id|task
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|task-&gt;tk_rpcwait
)paren
r_return
suffix:semicolon
id|spin_lock_bh
c_func
(paren
op_amp
id|rpc_queue_lock
)paren
suffix:semicolon
id|__rpc_remove_wait_queue
c_func
(paren
id|task
)paren
suffix:semicolon
id|spin_unlock_bh
c_func
(paren
op_amp
id|rpc_queue_lock
)paren
suffix:semicolon
)brace
DECL|function|rpc_set_waitqueue_priority
r_static
r_inline
r_void
id|rpc_set_waitqueue_priority
c_func
(paren
r_struct
id|rpc_wait_queue
op_star
id|queue
comma
r_int
id|priority
)paren
(brace
id|queue-&gt;priority
op_assign
id|priority
suffix:semicolon
id|queue-&gt;count
op_assign
l_int|1
op_lshift
(paren
id|priority
op_star
l_int|2
)paren
suffix:semicolon
)brace
DECL|function|rpc_set_waitqueue_cookie
r_static
r_inline
r_void
id|rpc_set_waitqueue_cookie
c_func
(paren
r_struct
id|rpc_wait_queue
op_star
id|queue
comma
r_int
r_int
id|cookie
)paren
(brace
id|queue-&gt;cookie
op_assign
id|cookie
suffix:semicolon
id|queue-&gt;nr
op_assign
id|RPC_BATCH_COUNT
suffix:semicolon
)brace
DECL|function|rpc_reset_waitqueue_priority
r_static
r_inline
r_void
id|rpc_reset_waitqueue_priority
c_func
(paren
r_struct
id|rpc_wait_queue
op_star
id|queue
)paren
(brace
id|rpc_set_waitqueue_priority
c_func
(paren
id|queue
comma
id|queue-&gt;maxpriority
)paren
suffix:semicolon
id|rpc_set_waitqueue_cookie
c_func
(paren
id|queue
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|__rpc_init_priority_wait_queue
r_static
r_void
id|__rpc_init_priority_wait_queue
c_func
(paren
r_struct
id|rpc_wait_queue
op_star
id|queue
comma
r_const
r_char
op_star
id|qname
comma
r_int
id|maxprio
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ARRAY_SIZE
c_func
(paren
id|queue-&gt;tasks
)paren
suffix:semicolon
id|i
op_increment
)paren
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|queue-&gt;tasks
(braket
id|i
)braket
)paren
suffix:semicolon
id|queue-&gt;maxpriority
op_assign
id|maxprio
suffix:semicolon
id|rpc_reset_waitqueue_priority
c_func
(paren
id|queue
)paren
suffix:semicolon
macro_line|#ifdef RPC_DEBUG
id|queue-&gt;name
op_assign
id|qname
suffix:semicolon
macro_line|#endif
)brace
DECL|function|rpc_init_priority_wait_queue
r_void
id|rpc_init_priority_wait_queue
c_func
(paren
r_struct
id|rpc_wait_queue
op_star
id|queue
comma
r_const
r_char
op_star
id|qname
)paren
(brace
id|__rpc_init_priority_wait_queue
c_func
(paren
id|queue
comma
id|qname
comma
id|RPC_PRIORITY_HIGH
)paren
suffix:semicolon
)brace
DECL|function|rpc_init_wait_queue
r_void
id|rpc_init_wait_queue
c_func
(paren
r_struct
id|rpc_wait_queue
op_star
id|queue
comma
r_const
r_char
op_star
id|qname
)paren
(brace
id|__rpc_init_priority_wait_queue
c_func
(paren
id|queue
comma
id|qname
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|variable|rpc_init_wait_queue
id|EXPORT_SYMBOL
c_func
(paren
id|rpc_init_wait_queue
)paren
suffix:semicolon
multiline_comment|/*&n; * Make an RPC task runnable.&n; *&n; * Note: If the task is ASYNC, this must be called with &n; * the spinlock held to protect the wait queue operation.&n; */
r_static
r_inline
r_void
DECL|function|rpc_make_runnable
id|rpc_make_runnable
c_func
(paren
r_struct
id|rpc_task
op_star
id|task
)paren
(brace
r_if
c_cond
(paren
id|task-&gt;tk_timeout_fn
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;RPC: task w/ running timer in rpc_make_runnable!!&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|rpc_set_running
c_func
(paren
id|task
)paren
suffix:semicolon
r_if
c_cond
(paren
id|RPC_IS_ASYNC
c_func
(paren
id|task
)paren
)paren
(brace
r_if
c_cond
(paren
id|RPC_IS_SLEEPING
c_func
(paren
id|task
)paren
)paren
(brace
r_int
id|status
suffix:semicolon
id|status
op_assign
id|__rpc_add_wait_queue
c_func
(paren
op_amp
id|schedq
comma
id|task
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;RPC: failed to add task to queue: error: %d!&bslash;n&quot;
comma
id|status
)paren
suffix:semicolon
id|task-&gt;tk_status
op_assign
id|status
suffix:semicolon
r_return
suffix:semicolon
)brace
id|rpc_clear_sleeping
c_func
(paren
id|task
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|rpciod_idle
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|rpc_clear_sleeping
c_func
(paren
id|task
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|task-&gt;tk_wait
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Place a newly initialized task on the schedq.&n; */
r_static
r_inline
r_void
DECL|function|rpc_schedule_run
id|rpc_schedule_run
c_func
(paren
r_struct
id|rpc_task
op_star
id|task
)paren
(brace
multiline_comment|/* Don&squot;t run a child twice! */
r_if
c_cond
(paren
id|RPC_IS_ACTIVATED
c_func
(paren
id|task
)paren
)paren
r_return
suffix:semicolon
id|task-&gt;tk_active
op_assign
l_int|1
suffix:semicolon
id|rpc_set_sleeping
c_func
(paren
id|task
)paren
suffix:semicolon
id|rpc_make_runnable
c_func
(paren
id|task
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;For other people who may need to wake the I/O daemon&n; *&t;but should (for now) know nothing about its innards&n; */
DECL|function|rpciod_wake_up
r_void
id|rpciod_wake_up
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|rpciod_pid
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;rpciod: wot no daemon?&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|wake_up
c_func
(paren
op_amp
id|rpciod_idle
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Prepare for sleeping on a wait queue.&n; * By always appending tasks to the list we ensure FIFO behavior.&n; * NB: An RPC task will only receive interrupt-driven events as long&n; * as it&squot;s on a wait queue.&n; */
r_static
r_void
DECL|function|__rpc_sleep_on
id|__rpc_sleep_on
c_func
(paren
r_struct
id|rpc_wait_queue
op_star
id|q
comma
r_struct
id|rpc_task
op_star
id|task
comma
id|rpc_action
id|action
comma
id|rpc_action
id|timer
)paren
(brace
r_int
id|status
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;RPC: %4d sleep_on(queue &bslash;&quot;%s&bslash;&quot; time %ld)&bslash;n&quot;
comma
id|task-&gt;tk_pid
comma
id|rpc_qname
c_func
(paren
id|q
)paren
comma
id|jiffies
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|RPC_IS_ASYNC
c_func
(paren
id|task
)paren
op_logical_and
op_logical_neg
id|RPC_IS_ACTIVATED
c_func
(paren
id|task
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;RPC: Inactive synchronous task put to sleep!&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Mark the task as being activated if so needed */
r_if
c_cond
(paren
op_logical_neg
id|RPC_IS_ACTIVATED
c_func
(paren
id|task
)paren
)paren
(brace
id|task-&gt;tk_active
op_assign
l_int|1
suffix:semicolon
id|rpc_set_sleeping
c_func
(paren
id|task
)paren
suffix:semicolon
)brace
id|status
op_assign
id|__rpc_add_wait_queue
c_func
(paren
id|q
comma
id|task
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;RPC: failed to add task to queue: error: %d!&bslash;n&quot;
comma
id|status
)paren
suffix:semicolon
id|task-&gt;tk_status
op_assign
id|status
suffix:semicolon
)brace
r_else
(brace
id|rpc_clear_running
c_func
(paren
id|task
)paren
suffix:semicolon
r_if
c_cond
(paren
id|task-&gt;tk_callback
)paren
(brace
id|dprintk
c_func
(paren
id|KERN_ERR
l_string|&quot;RPC: %4d overwrites an active callback&bslash;n&quot;
comma
id|task-&gt;tk_pid
)paren
suffix:semicolon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
id|task-&gt;tk_callback
op_assign
id|action
suffix:semicolon
id|__rpc_add_timer
c_func
(paren
id|task
comma
id|timer
)paren
suffix:semicolon
)brace
)brace
r_void
DECL|function|rpc_sleep_on
id|rpc_sleep_on
c_func
(paren
r_struct
id|rpc_wait_queue
op_star
id|q
comma
r_struct
id|rpc_task
op_star
id|task
comma
id|rpc_action
id|action
comma
id|rpc_action
id|timer
)paren
(brace
multiline_comment|/*&n;&t; * Protect the queue operations.&n;&t; */
id|spin_lock_bh
c_func
(paren
op_amp
id|rpc_queue_lock
)paren
suffix:semicolon
id|__rpc_sleep_on
c_func
(paren
id|q
comma
id|task
comma
id|action
comma
id|timer
)paren
suffix:semicolon
id|spin_unlock_bh
c_func
(paren
op_amp
id|rpc_queue_lock
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * __rpc_wake_up_task - wake up a single rpc_task&n; * @task: task to be woken up&n; *&n; * Caller must hold rpc_queue_lock&n; */
r_static
r_void
DECL|function|__rpc_wake_up_task
id|__rpc_wake_up_task
c_func
(paren
r_struct
id|rpc_task
op_star
id|task
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;RPC: %4d __rpc_wake_up_task (now %ld inh %d)&bslash;n&quot;
comma
id|task-&gt;tk_pid
comma
id|jiffies
comma
id|rpc_inhibit
)paren
suffix:semicolon
macro_line|#ifdef RPC_DEBUG
r_if
c_cond
(paren
id|task-&gt;tk_magic
op_ne
l_int|0xf00baa
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;RPC: attempt to wake up non-existing task!&bslash;n&quot;
)paren
suffix:semicolon
id|rpc_debug
op_assign
op_complement
l_int|0
suffix:semicolon
id|rpc_show_tasks
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* Has the task been executed yet? If not, we cannot wake it up! */
r_if
c_cond
(paren
op_logical_neg
id|RPC_IS_ACTIVATED
c_func
(paren
id|task
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;RPC: Inactive task (%p) being woken up!&bslash;n&quot;
comma
id|task
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|RPC_IS_RUNNING
c_func
(paren
id|task
)paren
)paren
r_return
suffix:semicolon
id|__rpc_disable_timer
c_func
(paren
id|task
)paren
suffix:semicolon
r_if
c_cond
(paren
id|task-&gt;tk_rpcwait
op_ne
op_amp
id|schedq
)paren
id|__rpc_remove_wait_queue
c_func
(paren
id|task
)paren
suffix:semicolon
id|rpc_make_runnable
c_func
(paren
id|task
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;RPC:      __rpc_wake_up_task done&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Default timeout handler if none specified by user&n; */
r_static
r_void
DECL|function|__rpc_default_timer
id|__rpc_default_timer
c_func
(paren
r_struct
id|rpc_task
op_star
id|task
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;RPC: %d timeout (default timer)&bslash;n&quot;
comma
id|task-&gt;tk_pid
)paren
suffix:semicolon
id|task-&gt;tk_status
op_assign
op_minus
id|ETIMEDOUT
suffix:semicolon
id|rpc_wake_up_task
c_func
(paren
id|task
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Wake up the specified task&n; */
r_void
DECL|function|rpc_wake_up_task
id|rpc_wake_up_task
c_func
(paren
r_struct
id|rpc_task
op_star
id|task
)paren
(brace
r_if
c_cond
(paren
id|RPC_IS_RUNNING
c_func
(paren
id|task
)paren
)paren
r_return
suffix:semicolon
id|spin_lock_bh
c_func
(paren
op_amp
id|rpc_queue_lock
)paren
suffix:semicolon
id|__rpc_wake_up_task
c_func
(paren
id|task
)paren
suffix:semicolon
id|spin_unlock_bh
c_func
(paren
op_amp
id|rpc_queue_lock
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Wake up the next task on a priority queue.&n; */
DECL|function|__rpc_wake_up_next_priority
r_static
r_struct
id|rpc_task
op_star
id|__rpc_wake_up_next_priority
c_func
(paren
r_struct
id|rpc_wait_queue
op_star
id|queue
)paren
(brace
r_struct
id|list_head
op_star
id|q
suffix:semicolon
r_struct
id|rpc_task
op_star
id|task
suffix:semicolon
multiline_comment|/*&n;&t; * Service a batch of tasks from a single cookie.&n;&t; */
id|q
op_assign
op_amp
id|queue-&gt;tasks
(braket
id|queue-&gt;priority
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
id|q
)paren
)paren
(brace
id|task
op_assign
id|list_entry
c_func
(paren
id|q-&gt;next
comma
r_struct
id|rpc_task
comma
id|tk_list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|queue-&gt;cookie
op_eq
id|task-&gt;tk_cookie
)paren
(brace
r_if
c_cond
(paren
op_decrement
id|queue-&gt;nr
)paren
r_goto
id|out
suffix:semicolon
id|list_move_tail
c_func
(paren
op_amp
id|task-&gt;tk_list
comma
id|q
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Check if we need to switch queues.&n;&t;&t; */
r_if
c_cond
(paren
op_decrement
id|queue-&gt;count
)paren
r_goto
id|new_cookie
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Service the next queue.&n;&t; */
r_do
(brace
r_if
c_cond
(paren
id|q
op_eq
op_amp
id|queue-&gt;tasks
(braket
l_int|0
)braket
)paren
id|q
op_assign
op_amp
id|queue-&gt;tasks
(braket
id|queue-&gt;maxpriority
)braket
suffix:semicolon
r_else
id|q
op_assign
id|q
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
id|q
)paren
)paren
(brace
id|task
op_assign
id|list_entry
c_func
(paren
id|q-&gt;next
comma
r_struct
id|rpc_task
comma
id|tk_list
)paren
suffix:semicolon
r_goto
id|new_queue
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|q
op_ne
op_amp
id|queue-&gt;tasks
(braket
id|queue-&gt;priority
)braket
)paren
suffix:semicolon
id|rpc_reset_waitqueue_priority
c_func
(paren
id|queue
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
id|new_queue
suffix:colon
id|rpc_set_waitqueue_priority
c_func
(paren
id|queue
comma
(paren
r_int
r_int
)paren
(paren
id|q
op_minus
op_amp
id|queue-&gt;tasks
(braket
l_int|0
)braket
)paren
)paren
suffix:semicolon
id|new_cookie
suffix:colon
id|rpc_set_waitqueue_cookie
c_func
(paren
id|queue
comma
id|task-&gt;tk_cookie
)paren
suffix:semicolon
id|out
suffix:colon
id|__rpc_wake_up_task
c_func
(paren
id|task
)paren
suffix:semicolon
r_return
id|task
suffix:semicolon
)brace
multiline_comment|/*&n; * Wake up the next task on the wait queue.&n; */
DECL|function|rpc_wake_up_next
r_struct
id|rpc_task
op_star
id|rpc_wake_up_next
c_func
(paren
r_struct
id|rpc_wait_queue
op_star
id|queue
)paren
(brace
r_struct
id|rpc_task
op_star
id|task
op_assign
l_int|NULL
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;RPC:      wake_up_next(%p &bslash;&quot;%s&bslash;&quot;)&bslash;n&quot;
comma
id|queue
comma
id|rpc_qname
c_func
(paren
id|queue
)paren
)paren
suffix:semicolon
id|spin_lock_bh
c_func
(paren
op_amp
id|rpc_queue_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|RPC_IS_PRIORITY
c_func
(paren
id|queue
)paren
)paren
id|task
op_assign
id|__rpc_wake_up_next_priority
c_func
(paren
id|queue
)paren
suffix:semicolon
r_else
(brace
id|task_for_first
c_func
(paren
id|task
comma
op_amp
id|queue-&gt;tasks
(braket
l_int|0
)braket
)paren
id|__rpc_wake_up_task
c_func
(paren
id|task
)paren
suffix:semicolon
)brace
id|spin_unlock_bh
c_func
(paren
op_amp
id|rpc_queue_lock
)paren
suffix:semicolon
r_return
id|task
suffix:semicolon
)brace
multiline_comment|/**&n; * rpc_wake_up - wake up all rpc_tasks&n; * @queue: rpc_wait_queue on which the tasks are sleeping&n; *&n; * Grabs rpc_queue_lock&n; */
DECL|function|rpc_wake_up
r_void
id|rpc_wake_up
c_func
(paren
r_struct
id|rpc_wait_queue
op_star
id|queue
)paren
(brace
r_struct
id|rpc_task
op_star
id|task
suffix:semicolon
r_struct
id|list_head
op_star
id|head
suffix:semicolon
id|spin_lock_bh
c_func
(paren
op_amp
id|rpc_queue_lock
)paren
suffix:semicolon
id|head
op_assign
op_amp
id|queue-&gt;tasks
(braket
id|queue-&gt;maxpriority
)braket
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
id|head
)paren
)paren
(brace
id|task
op_assign
id|list_entry
c_func
(paren
id|head-&gt;next
comma
r_struct
id|rpc_task
comma
id|tk_list
)paren
suffix:semicolon
id|__rpc_wake_up_task
c_func
(paren
id|task
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|head
op_eq
op_amp
id|queue-&gt;tasks
(braket
l_int|0
)braket
)paren
r_break
suffix:semicolon
id|head
op_decrement
suffix:semicolon
)brace
id|spin_unlock_bh
c_func
(paren
op_amp
id|rpc_queue_lock
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * rpc_wake_up_status - wake up all rpc_tasks and set their status value.&n; * @queue: rpc_wait_queue on which the tasks are sleeping&n; * @status: status value to set&n; *&n; * Grabs rpc_queue_lock&n; */
DECL|function|rpc_wake_up_status
r_void
id|rpc_wake_up_status
c_func
(paren
r_struct
id|rpc_wait_queue
op_star
id|queue
comma
r_int
id|status
)paren
(brace
r_struct
id|list_head
op_star
id|head
suffix:semicolon
r_struct
id|rpc_task
op_star
id|task
suffix:semicolon
id|spin_lock_bh
c_func
(paren
op_amp
id|rpc_queue_lock
)paren
suffix:semicolon
id|head
op_assign
op_amp
id|queue-&gt;tasks
(braket
id|queue-&gt;maxpriority
)braket
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
id|head
)paren
)paren
(brace
id|task
op_assign
id|list_entry
c_func
(paren
id|head-&gt;next
comma
r_struct
id|rpc_task
comma
id|tk_list
)paren
suffix:semicolon
id|task-&gt;tk_status
op_assign
id|status
suffix:semicolon
id|__rpc_wake_up_task
c_func
(paren
id|task
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|head
op_eq
op_amp
id|queue-&gt;tasks
(braket
l_int|0
)braket
)paren
r_break
suffix:semicolon
id|head
op_decrement
suffix:semicolon
)brace
id|spin_unlock_bh
c_func
(paren
op_amp
id|rpc_queue_lock
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Run a task at a later time&n; */
r_static
r_void
id|__rpc_atrun
c_func
(paren
r_struct
id|rpc_task
op_star
)paren
suffix:semicolon
r_void
DECL|function|rpc_delay
id|rpc_delay
c_func
(paren
r_struct
id|rpc_task
op_star
id|task
comma
r_int
r_int
id|delay
)paren
(brace
id|task-&gt;tk_timeout
op_assign
id|delay
suffix:semicolon
id|rpc_sleep_on
c_func
(paren
op_amp
id|delay_queue
comma
id|task
comma
l_int|NULL
comma
id|__rpc_atrun
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|__rpc_atrun
id|__rpc_atrun
c_func
(paren
r_struct
id|rpc_task
op_star
id|task
)paren
(brace
id|task-&gt;tk_status
op_assign
l_int|0
suffix:semicolon
id|rpc_wake_up_task
c_func
(paren
id|task
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This is the RPC `scheduler&squot; (or rather, the finite state machine).&n; */
r_static
r_int
DECL|function|__rpc_execute
id|__rpc_execute
c_func
(paren
r_struct
id|rpc_task
op_star
id|task
)paren
(brace
r_int
id|status
op_assign
l_int|0
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;RPC: %4d rpc_execute flgs %x&bslash;n&quot;
comma
id|task-&gt;tk_pid
comma
id|task-&gt;tk_flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|RPC_IS_RUNNING
c_func
(paren
id|task
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;RPC: rpc_execute called for sleeping task!!&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|restarted
suffix:colon
r_while
c_loop
(paren
l_int|1
)paren
(brace
multiline_comment|/*&n;&t;&t; * Execute any pending callback.&n;&t;&t; */
r_if
c_cond
(paren
id|RPC_DO_CALLBACK
c_func
(paren
id|task
)paren
)paren
(brace
multiline_comment|/* Define a callback save pointer */
r_void
(paren
op_star
id|save_callback
)paren
(paren
r_struct
id|rpc_task
op_star
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t; * If a callback exists, save it, reset it,&n;&t;&t;&t; * call it.&n;&t;&t;&t; * The save is needed to stop from resetting&n;&t;&t;&t; * another callback set within the callback handler&n;&t;&t;&t; * - Dave&n;&t;&t;&t; */
id|save_callback
op_assign
id|task-&gt;tk_callback
suffix:semicolon
id|task-&gt;tk_callback
op_assign
l_int|NULL
suffix:semicolon
id|save_callback
c_func
(paren
id|task
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Perform the next FSM step.&n;&t;&t; * tk_action may be NULL when the task has been killed&n;&t;&t; * by someone else.&n;&t;&t; */
r_if
c_cond
(paren
id|RPC_IS_RUNNING
c_func
(paren
id|task
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Garbage collection of pending timers...&n;&t;&t;&t; */
id|rpc_delete_timer
c_func
(paren
id|task
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|task-&gt;tk_action
)paren
r_break
suffix:semicolon
id|task
op_member_access_from_pointer
id|tk_action
c_func
(paren
id|task
)paren
suffix:semicolon
multiline_comment|/* micro-optimization to avoid spinlock */
r_if
c_cond
(paren
id|RPC_IS_RUNNING
c_func
(paren
id|task
)paren
)paren
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Check whether task is sleeping.&n;&t;&t; */
id|spin_lock_bh
c_func
(paren
op_amp
id|rpc_queue_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|RPC_IS_RUNNING
c_func
(paren
id|task
)paren
)paren
(brace
id|rpc_set_sleeping
c_func
(paren
id|task
)paren
suffix:semicolon
r_if
c_cond
(paren
id|RPC_IS_ASYNC
c_func
(paren
id|task
)paren
)paren
(brace
id|spin_unlock_bh
c_func
(paren
op_amp
id|rpc_queue_lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
id|spin_unlock_bh
c_func
(paren
op_amp
id|rpc_queue_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|RPC_IS_SLEEPING
c_func
(paren
id|task
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/* sync task: sleep here */
id|dprintk
c_func
(paren
l_string|&quot;RPC: %4d sync task going to sleep&bslash;n&quot;
comma
id|task-&gt;tk_pid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;pid
op_eq
id|rpciod_pid
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;RPC: rpciod waiting on sync task!&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|RPC_TASK_UNINTERRUPTIBLE
c_func
(paren
id|task
)paren
)paren
(brace
id|__wait_event
c_func
(paren
id|task-&gt;tk_wait
comma
op_logical_neg
id|RPC_IS_SLEEPING
c_func
(paren
id|task
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|__wait_event_interruptible
c_func
(paren
id|task-&gt;tk_wait
comma
op_logical_neg
id|RPC_IS_SLEEPING
c_func
(paren
id|task
)paren
comma
id|status
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * When a sync task receives a signal, it exits with&n;&t;&t;&t; * -ERESTARTSYS. In order to catch any callbacks that&n;&t;&t;&t; * clean up after sleeping on some queue, we don&squot;t&n;&t;&t;&t; * break the loop here, but go around once more.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|status
op_eq
op_minus
id|ERESTARTSYS
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;RPC: %4d got signal&bslash;n&quot;
comma
id|task-&gt;tk_pid
)paren
suffix:semicolon
id|task-&gt;tk_flags
op_or_assign
id|RPC_TASK_KILLED
suffix:semicolon
id|rpc_exit
c_func
(paren
id|task
comma
op_minus
id|ERESTARTSYS
)paren
suffix:semicolon
id|rpc_wake_up_task
c_func
(paren
id|task
)paren
suffix:semicolon
)brace
)brace
id|dprintk
c_func
(paren
l_string|&quot;RPC: %4d sync task resuming&bslash;n&quot;
comma
id|task-&gt;tk_pid
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|task-&gt;tk_exit
)paren
(brace
id|task
op_member_access_from_pointer
id|tk_exit
c_func
(paren
id|task
)paren
suffix:semicolon
multiline_comment|/* If tk_action is non-null, the user wants us to restart */
r_if
c_cond
(paren
id|task-&gt;tk_action
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|RPC_ASSASSINATED
c_func
(paren
id|task
)paren
)paren
(brace
multiline_comment|/* Release RPC slot and buffer memory */
r_if
c_cond
(paren
id|task-&gt;tk_rqstp
)paren
id|xprt_release
c_func
(paren
id|task
)paren
suffix:semicolon
id|rpc_free
c_func
(paren
id|task
)paren
suffix:semicolon
r_goto
id|restarted
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;RPC: dead task tries to walk away.&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
id|dprintk
c_func
(paren
l_string|&quot;RPC: %4d exit() = %d&bslash;n&quot;
comma
id|task-&gt;tk_pid
comma
id|task-&gt;tk_status
)paren
suffix:semicolon
id|status
op_assign
id|task-&gt;tk_status
suffix:semicolon
multiline_comment|/* Release all resources associated with the task */
id|rpc_release_task
c_func
(paren
id|task
)paren
suffix:semicolon
r_return
id|status
suffix:semicolon
)brace
multiline_comment|/*&n; * User-visible entry point to the scheduler.&n; *&n; * This may be called recursively if e.g. an async NFS task updates&n; * the attributes and finds that dirty pages must be flushed.&n; * NOTE: Upon exit of this function the task is guaranteed to be&n; *&t; released. In particular note that tk_release() will have&n; *&t; been called, so your task memory may have been freed.&n; */
r_int
DECL|function|rpc_execute
id|rpc_execute
c_func
(paren
r_struct
id|rpc_task
op_star
id|task
)paren
(brace
r_int
id|status
op_assign
op_minus
id|EIO
suffix:semicolon
r_if
c_cond
(paren
id|rpc_inhibit
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;RPC: execution inhibited!&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|out_release
suffix:semicolon
)brace
id|status
op_assign
op_minus
id|EWOULDBLOCK
suffix:semicolon
r_if
c_cond
(paren
id|task-&gt;tk_active
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;RPC: active task was run twice!&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|out_err
suffix:semicolon
)brace
id|task-&gt;tk_active
op_assign
l_int|1
suffix:semicolon
id|rpc_set_running
c_func
(paren
id|task
)paren
suffix:semicolon
r_return
id|__rpc_execute
c_func
(paren
id|task
)paren
suffix:semicolon
id|out_release
suffix:colon
id|rpc_release_task
c_func
(paren
id|task
)paren
suffix:semicolon
id|out_err
suffix:colon
r_return
id|status
suffix:semicolon
)brace
multiline_comment|/*&n; * This is our own little scheduler for async RPC tasks.&n; */
r_static
r_void
DECL|function|__rpc_schedule
id|__rpc_schedule
c_func
(paren
r_void
)paren
(brace
r_struct
id|rpc_task
op_star
id|task
suffix:semicolon
r_int
id|count
op_assign
l_int|0
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;RPC:      rpc_schedule enter&bslash;n&quot;
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|task_for_first
c_func
(paren
id|task
comma
op_amp
id|schedq.tasks
(braket
l_int|0
)braket
)paren
(brace
id|__rpc_remove_wait_queue
c_func
(paren
id|task
)paren
suffix:semicolon
id|spin_unlock_bh
c_func
(paren
op_amp
id|rpc_queue_lock
)paren
suffix:semicolon
id|__rpc_execute
c_func
(paren
id|task
)paren
suffix:semicolon
id|spin_lock_bh
c_func
(paren
op_amp
id|rpc_queue_lock
)paren
suffix:semicolon
)brace
r_else
(brace
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_increment
id|count
op_ge
l_int|200
op_logical_or
id|need_resched
c_func
(paren
)paren
)paren
(brace
id|count
op_assign
l_int|0
suffix:semicolon
id|spin_unlock_bh
c_func
(paren
op_amp
id|rpc_queue_lock
)paren
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|spin_lock_bh
c_func
(paren
op_amp
id|rpc_queue_lock
)paren
suffix:semicolon
)brace
)brace
id|dprintk
c_func
(paren
l_string|&quot;RPC:      rpc_schedule leave&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Allocate memory for RPC purposes.&n; *&n; * We try to ensure that some NFS reads and writes can always proceed&n; * by using a mempool when allocating &squot;small&squot; buffers.&n; * In order to avoid memory starvation triggering more writebacks of&n; * NFS requests, we use GFP_NOFS rather than GFP_KERNEL.&n; */
r_void
op_star
DECL|function|rpc_malloc
id|rpc_malloc
c_func
(paren
r_struct
id|rpc_task
op_star
id|task
comma
r_int
id|size
)paren
(brace
r_int
id|gfp
suffix:semicolon
r_if
c_cond
(paren
id|task-&gt;tk_flags
op_amp
id|RPC_TASK_SWAPPER
)paren
id|gfp
op_assign
id|GFP_ATOMIC
suffix:semicolon
r_else
id|gfp
op_assign
id|GFP_NOFS
suffix:semicolon
r_if
c_cond
(paren
id|size
OG
id|RPC_BUFFER_MAXSIZE
)paren
(brace
id|task-&gt;tk_buffer
op_assign
id|kmalloc
c_func
(paren
id|size
comma
id|gfp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|task-&gt;tk_buffer
)paren
id|task-&gt;tk_bufsize
op_assign
id|size
suffix:semicolon
)brace
r_else
(brace
id|task-&gt;tk_buffer
op_assign
id|mempool_alloc
c_func
(paren
id|rpc_buffer_mempool
comma
id|gfp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|task-&gt;tk_buffer
)paren
id|task-&gt;tk_bufsize
op_assign
id|RPC_BUFFER_MAXSIZE
suffix:semicolon
)brace
r_return
id|task-&gt;tk_buffer
suffix:semicolon
)brace
r_static
r_void
DECL|function|rpc_free
id|rpc_free
c_func
(paren
r_struct
id|rpc_task
op_star
id|task
)paren
(brace
r_if
c_cond
(paren
id|task-&gt;tk_buffer
)paren
(brace
r_if
c_cond
(paren
id|task-&gt;tk_bufsize
op_eq
id|RPC_BUFFER_MAXSIZE
)paren
id|mempool_free
c_func
(paren
id|task-&gt;tk_buffer
comma
id|rpc_buffer_mempool
)paren
suffix:semicolon
r_else
id|kfree
c_func
(paren
id|task-&gt;tk_buffer
)paren
suffix:semicolon
id|task-&gt;tk_buffer
op_assign
l_int|NULL
suffix:semicolon
id|task-&gt;tk_bufsize
op_assign
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Creation and deletion of RPC task structures&n; */
DECL|function|rpc_init_task
r_void
id|rpc_init_task
c_func
(paren
r_struct
id|rpc_task
op_star
id|task
comma
r_struct
id|rpc_clnt
op_star
id|clnt
comma
id|rpc_action
id|callback
comma
r_int
id|flags
)paren
(brace
id|memset
c_func
(paren
id|task
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|task
)paren
)paren
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|task-&gt;tk_timer
)paren
suffix:semicolon
id|task-&gt;tk_timer.data
op_assign
(paren
r_int
r_int
)paren
id|task
suffix:semicolon
id|task-&gt;tk_timer.function
op_assign
(paren
r_void
(paren
op_star
)paren
(paren
r_int
r_int
)paren
)paren
id|rpc_run_timer
suffix:semicolon
id|task-&gt;tk_client
op_assign
id|clnt
suffix:semicolon
id|task-&gt;tk_flags
op_assign
id|flags
suffix:semicolon
id|task-&gt;tk_exit
op_assign
id|callback
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|task-&gt;tk_wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;uid
op_ne
id|current-&gt;fsuid
op_logical_or
id|current-&gt;gid
op_ne
id|current-&gt;fsgid
)paren
id|task-&gt;tk_flags
op_or_assign
id|RPC_TASK_SETUID
suffix:semicolon
multiline_comment|/* Initialize retry counters */
id|task-&gt;tk_garb_retry
op_assign
l_int|2
suffix:semicolon
id|task-&gt;tk_cred_retry
op_assign
l_int|2
suffix:semicolon
id|task-&gt;tk_suid_retry
op_assign
l_int|1
suffix:semicolon
id|task-&gt;tk_priority
op_assign
id|RPC_PRIORITY_NORMAL
suffix:semicolon
id|task-&gt;tk_cookie
op_assign
(paren
r_int
r_int
)paren
id|current
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|task-&gt;tk_links
)paren
suffix:semicolon
multiline_comment|/* Add to global list of all tasks */
id|spin_lock
c_func
(paren
op_amp
id|rpc_sched_lock
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|task-&gt;tk_task
comma
op_amp
id|all_tasks
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|rpc_sched_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|clnt
)paren
(brace
id|atomic_inc
c_func
(paren
op_amp
id|clnt-&gt;cl_users
)paren
suffix:semicolon
r_if
c_cond
(paren
id|clnt-&gt;cl_softrtry
)paren
id|task-&gt;tk_flags
op_or_assign
id|RPC_TASK_SOFT
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|clnt-&gt;cl_intr
)paren
id|task-&gt;tk_flags
op_or_assign
id|RPC_TASK_NOINTR
suffix:semicolon
)brace
macro_line|#ifdef RPC_DEBUG
id|task-&gt;tk_magic
op_assign
l_int|0xf00baa
suffix:semicolon
id|task-&gt;tk_pid
op_assign
id|rpc_task_id
op_increment
suffix:semicolon
macro_line|#endif
id|dprintk
c_func
(paren
l_string|&quot;RPC: %4d new task procpid %d&bslash;n&quot;
comma
id|task-&gt;tk_pid
comma
id|current-&gt;pid
)paren
suffix:semicolon
)brace
r_static
r_struct
id|rpc_task
op_star
DECL|function|rpc_alloc_task
id|rpc_alloc_task
c_func
(paren
r_void
)paren
(brace
r_return
(paren
r_struct
id|rpc_task
op_star
)paren
id|mempool_alloc
c_func
(paren
id|rpc_task_mempool
comma
id|GFP_NOFS
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|rpc_default_free_task
id|rpc_default_free_task
c_func
(paren
r_struct
id|rpc_task
op_star
id|task
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;RPC: %4d freeing task&bslash;n&quot;
comma
id|task-&gt;tk_pid
)paren
suffix:semicolon
id|mempool_free
c_func
(paren
id|task
comma
id|rpc_task_mempool
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Create a new task for the specified client.  We have to&n; * clean up after an allocation failure, as the client may&n; * have specified &quot;oneshot&quot;.&n; */
r_struct
id|rpc_task
op_star
DECL|function|rpc_new_task
id|rpc_new_task
c_func
(paren
r_struct
id|rpc_clnt
op_star
id|clnt
comma
id|rpc_action
id|callback
comma
r_int
id|flags
)paren
(brace
r_struct
id|rpc_task
op_star
id|task
suffix:semicolon
id|task
op_assign
id|rpc_alloc_task
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|task
)paren
r_goto
id|cleanup
suffix:semicolon
id|rpc_init_task
c_func
(paren
id|task
comma
id|clnt
comma
id|callback
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* Replace tk_release */
id|task-&gt;tk_release
op_assign
id|rpc_default_free_task
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;RPC: %4d allocated task&bslash;n&quot;
comma
id|task-&gt;tk_pid
)paren
suffix:semicolon
id|task-&gt;tk_flags
op_or_assign
id|RPC_TASK_DYNAMIC
suffix:semicolon
id|out
suffix:colon
r_return
id|task
suffix:semicolon
id|cleanup
suffix:colon
multiline_comment|/* Check whether to release the client */
r_if
c_cond
(paren
id|clnt
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;rpc_new_task: failed, users=%d, oneshot=%d&bslash;n&quot;
comma
id|atomic_read
c_func
(paren
op_amp
id|clnt-&gt;cl_users
)paren
comma
id|clnt-&gt;cl_oneshot
)paren
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|clnt-&gt;cl_users
)paren
suffix:semicolon
multiline_comment|/* pretend we were used ... */
id|rpc_release_client
c_func
(paren
id|clnt
)paren
suffix:semicolon
)brace
r_goto
id|out
suffix:semicolon
)brace
r_void
DECL|function|rpc_release_task
id|rpc_release_task
c_func
(paren
r_struct
id|rpc_task
op_star
id|task
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;RPC: %4d release task&bslash;n&quot;
comma
id|task-&gt;tk_pid
)paren
suffix:semicolon
macro_line|#ifdef RPC_DEBUG
r_if
c_cond
(paren
id|task-&gt;tk_magic
op_ne
l_int|0xf00baa
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;RPC: attempt to release a non-existing task!&bslash;n&quot;
)paren
suffix:semicolon
id|rpc_debug
op_assign
op_complement
l_int|0
suffix:semicolon
id|rpc_show_tasks
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* Remove from global task list */
id|spin_lock
c_func
(paren
op_amp
id|rpc_sched_lock
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|task-&gt;tk_task
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|rpc_sched_lock
)paren
suffix:semicolon
multiline_comment|/* Protect the execution below. */
id|spin_lock_bh
c_func
(paren
op_amp
id|rpc_queue_lock
)paren
suffix:semicolon
multiline_comment|/* Disable timer to prevent zombie wakeup */
id|__rpc_disable_timer
c_func
(paren
id|task
)paren
suffix:semicolon
multiline_comment|/* Remove from any wait queue we&squot;re still on */
id|__rpc_remove_wait_queue
c_func
(paren
id|task
)paren
suffix:semicolon
id|task-&gt;tk_active
op_assign
l_int|0
suffix:semicolon
id|spin_unlock_bh
c_func
(paren
op_amp
id|rpc_queue_lock
)paren
suffix:semicolon
multiline_comment|/* Synchronously delete any running timer */
id|rpc_delete_timer
c_func
(paren
id|task
)paren
suffix:semicolon
multiline_comment|/* Release resources */
r_if
c_cond
(paren
id|task-&gt;tk_rqstp
)paren
id|xprt_release
c_func
(paren
id|task
)paren
suffix:semicolon
r_if
c_cond
(paren
id|task-&gt;tk_msg.rpc_cred
)paren
id|rpcauth_unbindcred
c_func
(paren
id|task
)paren
suffix:semicolon
id|rpc_free
c_func
(paren
id|task
)paren
suffix:semicolon
r_if
c_cond
(paren
id|task-&gt;tk_client
)paren
(brace
id|rpc_release_client
c_func
(paren
id|task-&gt;tk_client
)paren
suffix:semicolon
id|task-&gt;tk_client
op_assign
l_int|NULL
suffix:semicolon
)brace
macro_line|#ifdef RPC_DEBUG
id|task-&gt;tk_magic
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|task-&gt;tk_release
)paren
id|task
op_member_access_from_pointer
id|tk_release
c_func
(paren
id|task
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * rpc_find_parent - find the parent of a child task.&n; * @child: child task&n; *&n; * Checks that the parent task is still sleeping on the&n; * queue &squot;childq&squot;. If so returns a pointer to the parent.&n; * Upon failure returns NULL.&n; *&n; * Caller must hold rpc_queue_lock&n; */
r_static
r_inline
r_struct
id|rpc_task
op_star
DECL|function|rpc_find_parent
id|rpc_find_parent
c_func
(paren
r_struct
id|rpc_task
op_star
id|child
)paren
(brace
r_struct
id|rpc_task
op_star
id|task
comma
op_star
id|parent
suffix:semicolon
r_struct
id|list_head
op_star
id|le
suffix:semicolon
id|parent
op_assign
(paren
r_struct
id|rpc_task
op_star
)paren
id|child-&gt;tk_calldata
suffix:semicolon
id|task_for_each
c_func
(paren
id|task
comma
id|le
comma
op_amp
id|childq.tasks
(braket
l_int|0
)braket
)paren
r_if
c_cond
(paren
id|task
op_eq
id|parent
)paren
r_return
id|parent
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_static
r_void
DECL|function|rpc_child_exit
id|rpc_child_exit
c_func
(paren
r_struct
id|rpc_task
op_star
id|child
)paren
(brace
r_struct
id|rpc_task
op_star
id|parent
suffix:semicolon
id|spin_lock_bh
c_func
(paren
op_amp
id|rpc_queue_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|parent
op_assign
id|rpc_find_parent
c_func
(paren
id|child
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|parent-&gt;tk_status
op_assign
id|child-&gt;tk_status
suffix:semicolon
id|__rpc_wake_up_task
c_func
(paren
id|parent
)paren
suffix:semicolon
)brace
id|spin_unlock_bh
c_func
(paren
op_amp
id|rpc_queue_lock
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Note: rpc_new_task releases the client after a failure.&n; */
r_struct
id|rpc_task
op_star
DECL|function|rpc_new_child
id|rpc_new_child
c_func
(paren
r_struct
id|rpc_clnt
op_star
id|clnt
comma
r_struct
id|rpc_task
op_star
id|parent
)paren
(brace
r_struct
id|rpc_task
op_star
id|task
suffix:semicolon
id|task
op_assign
id|rpc_new_task
c_func
(paren
id|clnt
comma
l_int|NULL
comma
id|RPC_TASK_ASYNC
op_or
id|RPC_TASK_CHILD
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|task
)paren
r_goto
id|fail
suffix:semicolon
id|task-&gt;tk_exit
op_assign
id|rpc_child_exit
suffix:semicolon
id|task-&gt;tk_calldata
op_assign
id|parent
suffix:semicolon
r_return
id|task
suffix:semicolon
id|fail
suffix:colon
id|parent-&gt;tk_status
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_void
DECL|function|rpc_run_child
id|rpc_run_child
c_func
(paren
r_struct
id|rpc_task
op_star
id|task
comma
r_struct
id|rpc_task
op_star
id|child
comma
id|rpc_action
id|func
)paren
(brace
id|spin_lock_bh
c_func
(paren
op_amp
id|rpc_queue_lock
)paren
suffix:semicolon
multiline_comment|/* N.B. Is it possible for the child to have already finished? */
id|__rpc_sleep_on
c_func
(paren
op_amp
id|childq
comma
id|task
comma
id|func
comma
l_int|NULL
)paren
suffix:semicolon
id|rpc_schedule_run
c_func
(paren
id|child
)paren
suffix:semicolon
id|spin_unlock_bh
c_func
(paren
op_amp
id|rpc_queue_lock
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Kill all tasks for the given client.&n; * XXX: kill their descendants as well?&n; */
r_void
DECL|function|rpc_killall_tasks
id|rpc_killall_tasks
c_func
(paren
r_struct
id|rpc_clnt
op_star
id|clnt
)paren
(brace
r_struct
id|rpc_task
op_star
id|rovr
suffix:semicolon
r_struct
id|list_head
op_star
id|le
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;RPC:      killing all tasks for client %p&bslash;n&quot;
comma
id|clnt
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Spin lock all_tasks to prevent changes...&n;&t; */
id|spin_lock
c_func
(paren
op_amp
id|rpc_sched_lock
)paren
suffix:semicolon
id|alltask_for_each
c_func
(paren
id|rovr
comma
id|le
comma
op_amp
id|all_tasks
)paren
r_if
c_cond
(paren
op_logical_neg
id|clnt
op_logical_or
id|rovr-&gt;tk_client
op_eq
id|clnt
)paren
(brace
id|rovr-&gt;tk_flags
op_or_assign
id|RPC_TASK_KILLED
suffix:semicolon
id|rpc_exit
c_func
(paren
id|rovr
comma
op_minus
id|EIO
)paren
suffix:semicolon
id|rpc_wake_up_task
c_func
(paren
id|rovr
)paren
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|rpc_sched_lock
)paren
suffix:semicolon
)brace
r_static
id|DECLARE_MUTEX_LOCKED
c_func
(paren
id|rpciod_running
)paren
suffix:semicolon
r_static
r_inline
r_int
DECL|function|rpciod_task_pending
id|rpciod_task_pending
c_func
(paren
r_void
)paren
(brace
r_return
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|schedq.tasks
(braket
l_int|0
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This is the rpciod kernel thread&n; */
r_static
r_int
DECL|function|rpciod
id|rpciod
c_func
(paren
r_void
op_star
id|ptr
)paren
(brace
r_int
id|rounds
op_assign
l_int|0
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Let our maker know we&squot;re running ...&n;&t; */
id|rpciod_pid
op_assign
id|current-&gt;pid
suffix:semicolon
id|up
c_func
(paren
op_amp
id|rpciod_running
)paren
suffix:semicolon
id|daemonize
c_func
(paren
l_string|&quot;rpciod&quot;
)paren
suffix:semicolon
id|allow_signal
c_func
(paren
id|SIGKILL
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;RPC: rpciod starting (pid %d)&bslash;n&quot;
comma
id|rpciod_pid
)paren
suffix:semicolon
id|spin_lock_bh
c_func
(paren
op_amp
id|rpc_queue_lock
)paren
suffix:semicolon
r_while
c_loop
(paren
id|rpciod_users
)paren
(brace
id|DEFINE_WAIT
c_func
(paren
id|wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signalled
c_func
(paren
)paren
)paren
(brace
id|spin_unlock_bh
c_func
(paren
op_amp
id|rpc_queue_lock
)paren
suffix:semicolon
id|rpciod_killall
c_func
(paren
)paren
suffix:semicolon
id|flush_signals
c_func
(paren
id|current
)paren
suffix:semicolon
id|spin_lock_bh
c_func
(paren
op_amp
id|rpc_queue_lock
)paren
suffix:semicolon
)brace
id|__rpc_schedule
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;flags
op_amp
id|PF_FREEZE
)paren
(brace
id|spin_unlock_bh
c_func
(paren
op_amp
id|rpc_queue_lock
)paren
suffix:semicolon
id|refrigerator
c_func
(paren
id|PF_FREEZE
)paren
suffix:semicolon
id|spin_lock_bh
c_func
(paren
op_amp
id|rpc_queue_lock
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_increment
id|rounds
op_ge
l_int|64
)paren
(brace
multiline_comment|/* safeguard */
id|spin_unlock_bh
c_func
(paren
op_amp
id|rpc_queue_lock
)paren
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|rounds
op_assign
l_int|0
suffix:semicolon
id|spin_lock_bh
c_func
(paren
op_amp
id|rpc_queue_lock
)paren
suffix:semicolon
)brace
id|dprintk
c_func
(paren
l_string|&quot;RPC: rpciod back to sleep&bslash;n&quot;
)paren
suffix:semicolon
id|prepare_to_wait
c_func
(paren
op_amp
id|rpciod_idle
comma
op_amp
id|wait
comma
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rpciod_task_pending
c_func
(paren
)paren
op_logical_and
op_logical_neg
id|signalled
c_func
(paren
)paren
)paren
(brace
id|spin_unlock_bh
c_func
(paren
op_amp
id|rpc_queue_lock
)paren
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|rounds
op_assign
l_int|0
suffix:semicolon
id|spin_lock_bh
c_func
(paren
op_amp
id|rpc_queue_lock
)paren
suffix:semicolon
)brace
id|finish_wait
c_func
(paren
op_amp
id|rpciod_idle
comma
op_amp
id|wait
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;RPC: switch to rpciod&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|spin_unlock_bh
c_func
(paren
op_amp
id|rpc_queue_lock
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;RPC: rpciod shutdown commences&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|all_tasks
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;rpciod: active tasks at shutdown?!&bslash;n&quot;
)paren
suffix:semicolon
id|rpciod_killall
c_func
(paren
)paren
suffix:semicolon
)brace
id|dprintk
c_func
(paren
l_string|&quot;RPC: rpciod exiting&bslash;n&quot;
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
id|rpciod_pid
op_assign
l_int|0
suffix:semicolon
id|complete_and_exit
c_func
(paren
op_amp
id|rpciod_killer
comma
l_int|0
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_void
DECL|function|rpciod_killall
id|rpciod_killall
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|all_tasks
)paren
)paren
(brace
id|clear_thread_flag
c_func
(paren
id|TIF_SIGPENDING
)paren
suffix:semicolon
id|rpc_killall_tasks
c_func
(paren
l_int|NULL
)paren
suffix:semicolon
id|spin_lock_bh
c_func
(paren
op_amp
id|rpc_queue_lock
)paren
suffix:semicolon
id|__rpc_schedule
c_func
(paren
)paren
suffix:semicolon
id|spin_unlock_bh
c_func
(paren
op_amp
id|rpc_queue_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|all_tasks
)paren
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;rpciod_killall: waiting for tasks to exit&bslash;n&quot;
)paren
suffix:semicolon
id|yield
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|current-&gt;sighand-&gt;siglock
comma
id|flags
)paren
suffix:semicolon
id|recalc_sigpending
c_func
(paren
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|current-&gt;sighand-&gt;siglock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Start up the rpciod process if it&squot;s not already running.&n; */
r_int
DECL|function|rpciod_up
id|rpciod_up
c_func
(paren
r_void
)paren
(brace
r_int
id|error
op_assign
l_int|0
suffix:semicolon
id|down
c_func
(paren
op_amp
id|rpciod_sema
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;rpciod_up: pid %d, users %d&bslash;n&quot;
comma
id|rpciod_pid
comma
id|rpciod_users
)paren
suffix:semicolon
id|rpciod_users
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|rpciod_pid
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/*&n;&t; * If there&squot;s no pid, we should be the first user.&n;&t; */
r_if
c_cond
(paren
id|rpciod_users
OG
l_int|1
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;rpciod_up: no pid, %d users??&bslash;n&quot;
comma
id|rpciod_users
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Create the rpciod thread and wait for it to start.&n;&t; */
id|error
op_assign
id|kernel_thread
c_func
(paren
id|rpciod
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;rpciod_up: create thread failed, error=%d&bslash;n&quot;
comma
id|error
)paren
suffix:semicolon
id|rpciod_users
op_decrement
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|down
c_func
(paren
op_amp
id|rpciod_running
)paren
suffix:semicolon
id|error
op_assign
l_int|0
suffix:semicolon
id|out
suffix:colon
id|up
c_func
(paren
op_amp
id|rpciod_sema
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
r_void
DECL|function|rpciod_down
id|rpciod_down
c_func
(paren
r_void
)paren
(brace
id|down
c_func
(paren
op_amp
id|rpciod_sema
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;rpciod_down pid %d sema %d&bslash;n&quot;
comma
id|rpciod_pid
comma
id|rpciod_users
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rpciod_users
)paren
(brace
r_if
c_cond
(paren
op_decrement
id|rpciod_users
)paren
r_goto
id|out
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;rpciod_down: pid=%d, no users??&bslash;n&quot;
comma
id|rpciod_pid
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rpciod_pid
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;rpciod_down: Nothing to do!&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|kill_proc
c_func
(paren
id|rpciod_pid
comma
id|SIGKILL
comma
l_int|1
)paren
suffix:semicolon
id|wait_for_completion
c_func
(paren
op_amp
id|rpciod_killer
)paren
suffix:semicolon
id|out
suffix:colon
id|up
c_func
(paren
op_amp
id|rpciod_sema
)paren
suffix:semicolon
)brace
macro_line|#ifdef RPC_DEBUG
DECL|function|rpc_show_tasks
r_void
id|rpc_show_tasks
c_func
(paren
r_void
)paren
(brace
r_struct
id|list_head
op_star
id|le
suffix:semicolon
r_struct
id|rpc_task
op_star
id|t
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|rpc_sched_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|all_tasks
)paren
)paren
(brace
id|spin_unlock
c_func
(paren
op_amp
id|rpc_sched_lock
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;-pid- proc flgs status -client- -prog- --rqstp- -timeout &quot;
l_string|&quot;-rpcwait -action- --exit--&bslash;n&quot;
)paren
suffix:semicolon
id|alltask_for_each
c_func
(paren
id|t
comma
id|le
comma
op_amp
id|all_tasks
)paren
id|printk
c_func
(paren
l_string|&quot;%05d %04d %04x %06d %8p %6d %8p %08ld %8s %8p %8p&bslash;n&quot;
comma
id|t-&gt;tk_pid
comma
(paren
id|t-&gt;tk_msg.rpc_proc
ques
c_cond
id|t-&gt;tk_msg.rpc_proc-&gt;p_proc
suffix:colon
op_minus
l_int|1
)paren
comma
id|t-&gt;tk_flags
comma
id|t-&gt;tk_status
comma
id|t-&gt;tk_client
comma
(paren
id|t-&gt;tk_client
ques
c_cond
id|t-&gt;tk_client-&gt;cl_prog
suffix:colon
l_int|0
)paren
comma
id|t-&gt;tk_rqstp
comma
id|t-&gt;tk_timeout
comma
id|rpc_qname
c_func
(paren
id|t-&gt;tk_rpcwait
)paren
comma
id|t-&gt;tk_action
comma
id|t-&gt;tk_exit
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|rpc_sched_lock
)paren
suffix:semicolon
)brace
macro_line|#endif
r_void
DECL|function|rpc_destroy_mempool
id|rpc_destroy_mempool
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|rpc_buffer_mempool
)paren
id|mempool_destroy
c_func
(paren
id|rpc_buffer_mempool
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rpc_task_mempool
)paren
id|mempool_destroy
c_func
(paren
id|rpc_task_mempool
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rpc_task_slabp
op_logical_and
id|kmem_cache_destroy
c_func
(paren
id|rpc_task_slabp
)paren
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;rpc_task: not all structures were freed&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rpc_buffer_slabp
op_logical_and
id|kmem_cache_destroy
c_func
(paren
id|rpc_buffer_slabp
)paren
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;rpc_buffers: not all structures were freed&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_int
DECL|function|rpc_init_mempool
id|rpc_init_mempool
c_func
(paren
r_void
)paren
(brace
id|rpc_task_slabp
op_assign
id|kmem_cache_create
c_func
(paren
l_string|&quot;rpc_tasks&quot;
comma
r_sizeof
(paren
r_struct
id|rpc_task
)paren
comma
l_int|0
comma
id|SLAB_HWCACHE_ALIGN
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rpc_task_slabp
)paren
r_goto
id|err_nomem
suffix:semicolon
id|rpc_buffer_slabp
op_assign
id|kmem_cache_create
c_func
(paren
l_string|&quot;rpc_buffers&quot;
comma
id|RPC_BUFFER_MAXSIZE
comma
l_int|0
comma
id|SLAB_HWCACHE_ALIGN
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rpc_buffer_slabp
)paren
r_goto
id|err_nomem
suffix:semicolon
id|rpc_task_mempool
op_assign
id|mempool_create
c_func
(paren
id|RPC_TASK_POOLSIZE
comma
id|mempool_alloc_slab
comma
id|mempool_free_slab
comma
id|rpc_task_slabp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rpc_task_mempool
)paren
r_goto
id|err_nomem
suffix:semicolon
id|rpc_buffer_mempool
op_assign
id|mempool_create
c_func
(paren
id|RPC_BUFFER_POOLSIZE
comma
id|mempool_alloc_slab
comma
id|mempool_free_slab
comma
id|rpc_buffer_slabp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rpc_buffer_mempool
)paren
r_goto
id|err_nomem
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|err_nomem
suffix:colon
id|rpc_destroy_mempool
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
eof
