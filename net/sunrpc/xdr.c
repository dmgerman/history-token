multiline_comment|/*&n; * linux/net/sunrpc/xdr.c&n; *&n; * Generic XDR support.&n; *&n; * Copyright (C) 1995, 1996 Olaf Kirch &lt;okir@monad.swb.de&gt;&n; */
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/socket.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/pagemap.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/in.h&gt;
macro_line|#include &lt;linux/net.h&gt;
macro_line|#include &lt;net/sock.h&gt;
macro_line|#include &lt;linux/sunrpc/xdr.h&gt;
macro_line|#include &lt;linux/sunrpc/msg_prot.h&gt;
multiline_comment|/*&n; * XDR functions for basic NFS types&n; */
id|u32
op_star
DECL|function|xdr_encode_netobj
id|xdr_encode_netobj
c_func
(paren
id|u32
op_star
id|p
comma
r_const
r_struct
id|xdr_netobj
op_star
id|obj
)paren
(brace
r_int
r_int
id|quadlen
op_assign
id|XDR_QUADLEN
c_func
(paren
id|obj-&gt;len
)paren
suffix:semicolon
id|p
(braket
id|quadlen
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* zero trailing bytes */
op_star
id|p
op_increment
op_assign
id|htonl
c_func
(paren
id|obj-&gt;len
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|p
comma
id|obj-&gt;data
comma
id|obj-&gt;len
)paren
suffix:semicolon
r_return
id|p
op_plus
id|XDR_QUADLEN
c_func
(paren
id|obj-&gt;len
)paren
suffix:semicolon
)brace
id|u32
op_star
DECL|function|xdr_decode_netobj_fixed
id|xdr_decode_netobj_fixed
c_func
(paren
id|u32
op_star
id|p
comma
r_void
op_star
id|obj
comma
r_int
r_int
id|len
)paren
(brace
r_if
c_cond
(paren
id|ntohl
c_func
(paren
op_star
id|p
op_increment
)paren
op_ne
id|len
)paren
r_return
l_int|NULL
suffix:semicolon
id|memcpy
c_func
(paren
id|obj
comma
id|p
comma
id|len
)paren
suffix:semicolon
r_return
id|p
op_plus
id|XDR_QUADLEN
c_func
(paren
id|len
)paren
suffix:semicolon
)brace
id|u32
op_star
DECL|function|xdr_decode_netobj
id|xdr_decode_netobj
c_func
(paren
id|u32
op_star
id|p
comma
r_struct
id|xdr_netobj
op_star
id|obj
)paren
(brace
r_int
r_int
id|len
suffix:semicolon
r_if
c_cond
(paren
(paren
id|len
op_assign
id|ntohl
c_func
(paren
op_star
id|p
op_increment
)paren
)paren
OG
id|XDR_MAX_NETOBJ
)paren
r_return
l_int|NULL
suffix:semicolon
id|obj-&gt;len
op_assign
id|len
suffix:semicolon
id|obj-&gt;data
op_assign
(paren
id|u8
op_star
)paren
id|p
suffix:semicolon
r_return
id|p
op_plus
id|XDR_QUADLEN
c_func
(paren
id|len
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * xdr_encode_opaque_fixed - Encode fixed length opaque data&n; * @p - pointer to current position in XDR buffer.&n; * @ptr - pointer to data to encode (or NULL)&n; * @nbytes - size of data.&n; *&n; * Copy the array of data of length nbytes at ptr to the XDR buffer&n; * at position p, then align to the next 32-bit boundary by padding&n; * with zero bytes (see RFC1832).&n; * Note: if ptr is NULL, only the padding is performed.&n; *&n; * Returns the updated current XDR buffer position&n; *&n; */
DECL|function|xdr_encode_opaque_fixed
id|u32
op_star
id|xdr_encode_opaque_fixed
c_func
(paren
id|u32
op_star
id|p
comma
r_const
r_void
op_star
id|ptr
comma
r_int
r_int
id|nbytes
)paren
(brace
r_if
c_cond
(paren
id|likely
c_func
(paren
id|nbytes
op_ne
l_int|0
)paren
)paren
(brace
r_int
r_int
id|quadlen
op_assign
id|XDR_QUADLEN
c_func
(paren
id|nbytes
)paren
suffix:semicolon
r_int
r_int
id|padding
op_assign
(paren
id|quadlen
op_lshift
l_int|2
)paren
op_minus
id|nbytes
suffix:semicolon
r_if
c_cond
(paren
id|ptr
op_ne
l_int|NULL
)paren
id|memcpy
c_func
(paren
id|p
comma
id|ptr
comma
id|nbytes
)paren
suffix:semicolon
r_if
c_cond
(paren
id|padding
op_ne
l_int|0
)paren
id|memset
c_func
(paren
(paren
r_char
op_star
)paren
id|p
op_plus
id|nbytes
comma
l_int|0
comma
id|padding
)paren
suffix:semicolon
id|p
op_add_assign
id|quadlen
suffix:semicolon
)brace
r_return
id|p
suffix:semicolon
)brace
DECL|variable|xdr_encode_opaque_fixed
id|EXPORT_SYMBOL
c_func
(paren
id|xdr_encode_opaque_fixed
)paren
suffix:semicolon
multiline_comment|/**&n; * xdr_encode_opaque - Encode variable length opaque data&n; * @p - pointer to current position in XDR buffer.&n; * @ptr - pointer to data to encode (or NULL)&n; * @nbytes - size of data.&n; *&n; * Returns the updated current XDR buffer position&n; */
DECL|function|xdr_encode_opaque
id|u32
op_star
id|xdr_encode_opaque
c_func
(paren
id|u32
op_star
id|p
comma
r_const
r_void
op_star
id|ptr
comma
r_int
r_int
id|nbytes
)paren
(brace
op_star
id|p
op_increment
op_assign
id|htonl
c_func
(paren
id|nbytes
)paren
suffix:semicolon
r_return
id|xdr_encode_opaque_fixed
c_func
(paren
id|p
comma
id|ptr
comma
id|nbytes
)paren
suffix:semicolon
)brace
DECL|variable|xdr_encode_opaque
id|EXPORT_SYMBOL
c_func
(paren
id|xdr_encode_opaque
)paren
suffix:semicolon
id|u32
op_star
DECL|function|xdr_encode_string
id|xdr_encode_string
c_func
(paren
id|u32
op_star
id|p
comma
r_const
r_char
op_star
id|string
)paren
(brace
r_return
id|xdr_encode_array
c_func
(paren
id|p
comma
id|string
comma
id|strlen
c_func
(paren
id|string
)paren
)paren
suffix:semicolon
)brace
id|u32
op_star
DECL|function|xdr_decode_string
id|xdr_decode_string
c_func
(paren
id|u32
op_star
id|p
comma
r_char
op_star
op_star
id|sp
comma
r_int
op_star
id|lenp
comma
r_int
id|maxlen
)paren
(brace
r_int
r_int
id|len
suffix:semicolon
r_char
op_star
id|string
suffix:semicolon
r_if
c_cond
(paren
(paren
id|len
op_assign
id|ntohl
c_func
(paren
op_star
id|p
op_increment
)paren
)paren
OG
id|maxlen
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|lenp
)paren
op_star
id|lenp
op_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
(paren
id|len
op_mod
l_int|4
)paren
op_ne
l_int|0
)paren
(brace
id|string
op_assign
(paren
r_char
op_star
)paren
id|p
suffix:semicolon
)brace
r_else
(brace
id|string
op_assign
(paren
r_char
op_star
)paren
(paren
id|p
op_minus
l_int|1
)paren
suffix:semicolon
id|memmove
c_func
(paren
id|string
comma
id|p
comma
id|len
)paren
suffix:semicolon
)brace
id|string
(braket
id|len
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
op_star
id|sp
op_assign
id|string
suffix:semicolon
r_return
id|p
op_plus
id|XDR_QUADLEN
c_func
(paren
id|len
)paren
suffix:semicolon
)brace
id|u32
op_star
DECL|function|xdr_decode_string_inplace
id|xdr_decode_string_inplace
c_func
(paren
id|u32
op_star
id|p
comma
r_char
op_star
op_star
id|sp
comma
r_int
op_star
id|lenp
comma
r_int
id|maxlen
)paren
(brace
r_int
r_int
id|len
suffix:semicolon
r_if
c_cond
(paren
(paren
id|len
op_assign
id|ntohl
c_func
(paren
op_star
id|p
op_increment
)paren
)paren
OG
id|maxlen
)paren
r_return
l_int|NULL
suffix:semicolon
op_star
id|lenp
op_assign
id|len
suffix:semicolon
op_star
id|sp
op_assign
(paren
r_char
op_star
)paren
id|p
suffix:semicolon
r_return
id|p
op_plus
id|XDR_QUADLEN
c_func
(paren
id|len
)paren
suffix:semicolon
)brace
r_void
DECL|function|xdr_encode_pages
id|xdr_encode_pages
c_func
(paren
r_struct
id|xdr_buf
op_star
id|xdr
comma
r_struct
id|page
op_star
op_star
id|pages
comma
r_int
r_int
id|base
comma
r_int
r_int
id|len
)paren
(brace
r_struct
id|kvec
op_star
id|tail
op_assign
id|xdr-&gt;tail
suffix:semicolon
id|u32
op_star
id|p
suffix:semicolon
id|xdr-&gt;pages
op_assign
id|pages
suffix:semicolon
id|xdr-&gt;page_base
op_assign
id|base
suffix:semicolon
id|xdr-&gt;page_len
op_assign
id|len
suffix:semicolon
id|p
op_assign
(paren
id|u32
op_star
)paren
id|xdr-&gt;head
(braket
l_int|0
)braket
dot
id|iov_base
op_plus
id|XDR_QUADLEN
c_func
(paren
id|xdr-&gt;head
(braket
l_int|0
)braket
dot
id|iov_len
)paren
suffix:semicolon
id|tail-&gt;iov_base
op_assign
id|p
suffix:semicolon
id|tail-&gt;iov_len
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|len
op_amp
l_int|3
)paren
(brace
r_int
r_int
id|pad
op_assign
l_int|4
op_minus
(paren
id|len
op_amp
l_int|3
)paren
suffix:semicolon
op_star
id|p
op_assign
l_int|0
suffix:semicolon
id|tail-&gt;iov_base
op_assign
(paren
r_char
op_star
)paren
id|p
op_plus
(paren
id|len
op_amp
l_int|3
)paren
suffix:semicolon
id|tail-&gt;iov_len
op_assign
id|pad
suffix:semicolon
id|len
op_add_assign
id|pad
suffix:semicolon
)brace
id|xdr-&gt;buflen
op_add_assign
id|len
suffix:semicolon
id|xdr-&gt;len
op_add_assign
id|len
suffix:semicolon
)brace
r_void
DECL|function|xdr_inline_pages
id|xdr_inline_pages
c_func
(paren
r_struct
id|xdr_buf
op_star
id|xdr
comma
r_int
r_int
id|offset
comma
r_struct
id|page
op_star
op_star
id|pages
comma
r_int
r_int
id|base
comma
r_int
r_int
id|len
)paren
(brace
r_struct
id|kvec
op_star
id|head
op_assign
id|xdr-&gt;head
suffix:semicolon
r_struct
id|kvec
op_star
id|tail
op_assign
id|xdr-&gt;tail
suffix:semicolon
r_char
op_star
id|buf
op_assign
(paren
r_char
op_star
)paren
id|head-&gt;iov_base
suffix:semicolon
r_int
r_int
id|buflen
op_assign
id|head-&gt;iov_len
suffix:semicolon
id|head-&gt;iov_len
op_assign
id|offset
suffix:semicolon
id|xdr-&gt;pages
op_assign
id|pages
suffix:semicolon
id|xdr-&gt;page_base
op_assign
id|base
suffix:semicolon
id|xdr-&gt;page_len
op_assign
id|len
suffix:semicolon
id|tail-&gt;iov_base
op_assign
id|buf
op_plus
id|offset
suffix:semicolon
id|tail-&gt;iov_len
op_assign
id|buflen
op_minus
id|offset
suffix:semicolon
id|xdr-&gt;buflen
op_add_assign
id|len
suffix:semicolon
)brace
multiline_comment|/*&n; * Realign the kvec if the server missed out some reply elements&n; * (such as post-op attributes,...)&n; * Note: This is a simple implementation that assumes that&n; *            len &lt;= iov-&gt;iov_len !!!&n; *       The RPC header (assumed to be the 1st element in the iov array)&n; *            is not shifted.&n; */
DECL|function|xdr_shift_iovec
r_void
id|xdr_shift_iovec
c_func
(paren
r_struct
id|kvec
op_star
id|iov
comma
r_int
id|nr
comma
r_int
id|len
)paren
(brace
r_struct
id|kvec
op_star
id|pvec
suffix:semicolon
r_for
c_loop
(paren
id|pvec
op_assign
id|iov
op_plus
id|nr
op_minus
l_int|1
suffix:semicolon
id|nr
OG
l_int|1
suffix:semicolon
id|nr
op_decrement
comma
id|pvec
op_decrement
)paren
(brace
r_struct
id|kvec
op_star
id|svec
op_assign
id|pvec
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|pvec-&gt;iov_len
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;RPC: Urk! Large shift of short iovec.&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|memmove
c_func
(paren
(paren
r_char
op_star
)paren
id|pvec-&gt;iov_base
op_plus
id|len
comma
id|pvec-&gt;iov_base
comma
id|pvec-&gt;iov_len
op_minus
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|svec-&gt;iov_len
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;RPC: Urk! Large shift of short iovec.&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|pvec-&gt;iov_base
comma
(paren
r_char
op_star
)paren
id|svec-&gt;iov_base
op_plus
id|svec-&gt;iov_len
op_minus
id|len
comma
id|len
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Map a struct xdr_buf into an kvec array.&n; */
DECL|function|xdr_kmap
r_int
id|xdr_kmap
c_func
(paren
r_struct
id|kvec
op_star
id|iov_base
comma
r_struct
id|xdr_buf
op_star
id|xdr
comma
r_int
id|base
)paren
(brace
r_struct
id|kvec
op_star
id|iov
op_assign
id|iov_base
suffix:semicolon
r_struct
id|page
op_star
op_star
id|ppage
op_assign
id|xdr-&gt;pages
suffix:semicolon
r_int
r_int
id|len
comma
id|pglen
op_assign
id|xdr-&gt;page_len
suffix:semicolon
id|len
op_assign
id|xdr-&gt;head
(braket
l_int|0
)braket
dot
id|iov_len
suffix:semicolon
r_if
c_cond
(paren
id|base
OL
id|len
)paren
(brace
id|iov-&gt;iov_len
op_assign
id|len
op_minus
id|base
suffix:semicolon
id|iov-&gt;iov_base
op_assign
(paren
r_char
op_star
)paren
id|xdr-&gt;head
(braket
l_int|0
)braket
dot
id|iov_base
op_plus
id|base
suffix:semicolon
id|iov
op_increment
suffix:semicolon
id|base
op_assign
l_int|0
suffix:semicolon
)brace
r_else
id|base
op_sub_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
id|pglen
op_eq
l_int|0
)paren
r_goto
id|map_tail
suffix:semicolon
r_if
c_cond
(paren
id|base
op_ge
id|pglen
)paren
(brace
id|base
op_sub_assign
id|pglen
suffix:semicolon
r_goto
id|map_tail
suffix:semicolon
)brace
r_if
c_cond
(paren
id|base
op_logical_or
id|xdr-&gt;page_base
)paren
(brace
id|pglen
op_sub_assign
id|base
suffix:semicolon
id|base
op_add_assign
id|xdr-&gt;page_base
suffix:semicolon
id|ppage
op_add_assign
id|base
op_rshift
id|PAGE_CACHE_SHIFT
suffix:semicolon
id|base
op_and_assign
op_complement
id|PAGE_CACHE_MASK
suffix:semicolon
)brace
r_do
(brace
id|len
op_assign
id|PAGE_CACHE_SIZE
suffix:semicolon
id|iov-&gt;iov_base
op_assign
id|kmap
c_func
(paren
op_star
id|ppage
)paren
suffix:semicolon
r_if
c_cond
(paren
id|base
)paren
(brace
id|iov-&gt;iov_base
op_add_assign
id|base
suffix:semicolon
id|len
op_sub_assign
id|base
suffix:semicolon
id|base
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pglen
OL
id|len
)paren
id|len
op_assign
id|pglen
suffix:semicolon
id|iov-&gt;iov_len
op_assign
id|len
suffix:semicolon
id|iov
op_increment
suffix:semicolon
id|ppage
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|pglen
op_sub_assign
id|len
)paren
op_ne
l_int|0
)paren
suffix:semicolon
id|map_tail
suffix:colon
r_if
c_cond
(paren
id|xdr-&gt;tail
(braket
l_int|0
)braket
dot
id|iov_len
)paren
(brace
id|iov-&gt;iov_len
op_assign
id|xdr-&gt;tail
(braket
l_int|0
)braket
dot
id|iov_len
op_minus
id|base
suffix:semicolon
id|iov-&gt;iov_base
op_assign
(paren
r_char
op_star
)paren
id|xdr-&gt;tail
(braket
l_int|0
)braket
dot
id|iov_base
op_plus
id|base
suffix:semicolon
id|iov
op_increment
suffix:semicolon
)brace
r_return
(paren
id|iov
op_minus
id|iov_base
)paren
suffix:semicolon
)brace
DECL|function|xdr_kunmap
r_void
id|xdr_kunmap
c_func
(paren
r_struct
id|xdr_buf
op_star
id|xdr
comma
r_int
id|base
)paren
(brace
r_struct
id|page
op_star
op_star
id|ppage
op_assign
id|xdr-&gt;pages
suffix:semicolon
r_int
r_int
id|pglen
op_assign
id|xdr-&gt;page_len
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pglen
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|base
OG
id|xdr-&gt;head
(braket
l_int|0
)braket
dot
id|iov_len
)paren
id|base
op_sub_assign
id|xdr-&gt;head
(braket
l_int|0
)braket
dot
id|iov_len
suffix:semicolon
r_else
id|base
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|base
op_ge
id|pglen
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|base
op_logical_or
id|xdr-&gt;page_base
)paren
(brace
id|pglen
op_sub_assign
id|base
suffix:semicolon
id|base
op_add_assign
id|xdr-&gt;page_base
suffix:semicolon
id|ppage
op_add_assign
id|base
op_rshift
id|PAGE_CACHE_SHIFT
suffix:semicolon
multiline_comment|/* Note: The offset means that the length of the first&n;&t;&t; * page is really (PAGE_CACHE_SIZE - (base &amp; ~PAGE_CACHE_MASK)).&n;&t;&t; * In order to avoid an extra test inside the loop,&n;&t;&t; * we bump pglen here, and just subtract PAGE_CACHE_SIZE... */
id|pglen
op_add_assign
id|base
op_amp
op_complement
id|PAGE_CACHE_MASK
suffix:semicolon
)brace
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|flush_dcache_page
c_func
(paren
op_star
id|ppage
)paren
suffix:semicolon
id|kunmap
c_func
(paren
op_star
id|ppage
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pglen
op_le
id|PAGE_CACHE_SIZE
)paren
r_break
suffix:semicolon
id|pglen
op_sub_assign
id|PAGE_CACHE_SIZE
suffix:semicolon
id|ppage
op_increment
suffix:semicolon
)brace
)brace
r_void
DECL|function|xdr_partial_copy_from_skb
id|xdr_partial_copy_from_skb
c_func
(paren
r_struct
id|xdr_buf
op_star
id|xdr
comma
r_int
r_int
id|base
comma
id|skb_reader_t
op_star
id|desc
comma
id|skb_read_actor_t
id|copy_actor
)paren
(brace
r_struct
id|page
op_star
op_star
id|ppage
op_assign
id|xdr-&gt;pages
suffix:semicolon
r_int
r_int
id|len
comma
id|pglen
op_assign
id|xdr-&gt;page_len
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|len
op_assign
id|xdr-&gt;head
(braket
l_int|0
)braket
dot
id|iov_len
suffix:semicolon
r_if
c_cond
(paren
id|base
OL
id|len
)paren
(brace
id|len
op_sub_assign
id|base
suffix:semicolon
id|ret
op_assign
id|copy_actor
c_func
(paren
id|desc
comma
(paren
r_char
op_star
)paren
id|xdr-&gt;head
(braket
l_int|0
)braket
dot
id|iov_base
op_plus
id|base
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
id|len
op_logical_or
op_logical_neg
id|desc-&gt;count
)paren
r_return
suffix:semicolon
id|base
op_assign
l_int|0
suffix:semicolon
)brace
r_else
id|base
op_sub_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
id|pglen
op_eq
l_int|0
)paren
r_goto
id|copy_tail
suffix:semicolon
r_if
c_cond
(paren
id|base
op_ge
id|pglen
)paren
(brace
id|base
op_sub_assign
id|pglen
suffix:semicolon
r_goto
id|copy_tail
suffix:semicolon
)brace
r_if
c_cond
(paren
id|base
op_logical_or
id|xdr-&gt;page_base
)paren
(brace
id|pglen
op_sub_assign
id|base
suffix:semicolon
id|base
op_add_assign
id|xdr-&gt;page_base
suffix:semicolon
id|ppage
op_add_assign
id|base
op_rshift
id|PAGE_CACHE_SHIFT
suffix:semicolon
id|base
op_and_assign
op_complement
id|PAGE_CACHE_MASK
suffix:semicolon
)brace
r_do
(brace
r_char
op_star
id|kaddr
suffix:semicolon
id|len
op_assign
id|PAGE_CACHE_SIZE
suffix:semicolon
id|kaddr
op_assign
id|kmap_atomic
c_func
(paren
op_star
id|ppage
comma
id|KM_SKB_SUNRPC_DATA
)paren
suffix:semicolon
r_if
c_cond
(paren
id|base
)paren
(brace
id|len
op_sub_assign
id|base
suffix:semicolon
r_if
c_cond
(paren
id|pglen
OL
id|len
)paren
id|len
op_assign
id|pglen
suffix:semicolon
id|ret
op_assign
id|copy_actor
c_func
(paren
id|desc
comma
id|kaddr
op_plus
id|base
comma
id|len
)paren
suffix:semicolon
id|base
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|pglen
OL
id|len
)paren
id|len
op_assign
id|pglen
suffix:semicolon
id|ret
op_assign
id|copy_actor
c_func
(paren
id|desc
comma
id|kaddr
comma
id|len
)paren
suffix:semicolon
)brace
id|flush_dcache_page
c_func
(paren
op_star
id|ppage
)paren
suffix:semicolon
id|kunmap_atomic
c_func
(paren
id|kaddr
comma
id|KM_SKB_SUNRPC_DATA
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
id|len
op_logical_or
op_logical_neg
id|desc-&gt;count
)paren
r_return
suffix:semicolon
id|ppage
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|pglen
op_sub_assign
id|len
)paren
op_ne
l_int|0
)paren
suffix:semicolon
id|copy_tail
suffix:colon
id|len
op_assign
id|xdr-&gt;tail
(braket
l_int|0
)braket
dot
id|iov_len
suffix:semicolon
r_if
c_cond
(paren
id|base
OL
id|len
)paren
id|copy_actor
c_func
(paren
id|desc
comma
(paren
r_char
op_star
)paren
id|xdr-&gt;tail
(braket
l_int|0
)braket
dot
id|iov_base
op_plus
id|base
comma
id|len
op_minus
id|base
)paren
suffix:semicolon
)brace
r_int
DECL|function|xdr_sendpages
id|xdr_sendpages
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_struct
id|sockaddr
op_star
id|addr
comma
r_int
id|addrlen
comma
r_struct
id|xdr_buf
op_star
id|xdr
comma
r_int
r_int
id|base
comma
r_int
id|msgflags
)paren
(brace
r_struct
id|page
op_star
op_star
id|ppage
op_assign
id|xdr-&gt;pages
suffix:semicolon
r_int
r_int
id|len
comma
id|pglen
op_assign
id|xdr-&gt;page_len
suffix:semicolon
r_int
id|err
comma
id|ret
op_assign
l_int|0
suffix:semicolon
id|ssize_t
(paren
op_star
id|sendpage
)paren
(paren
r_struct
id|socket
op_star
comma
r_struct
id|page
op_star
comma
r_int
comma
r_int
comma
r_int
)paren
suffix:semicolon
id|len
op_assign
id|xdr-&gt;head
(braket
l_int|0
)braket
dot
id|iov_len
suffix:semicolon
r_if
c_cond
(paren
id|base
OL
id|len
op_logical_or
(paren
id|addr
op_ne
l_int|NULL
op_logical_and
id|base
op_eq
l_int|0
)paren
)paren
(brace
r_struct
id|kvec
id|iov
op_assign
(brace
dot
id|iov_base
op_assign
id|xdr-&gt;head
(braket
l_int|0
)braket
dot
id|iov_base
op_plus
id|base
comma
dot
id|iov_len
op_assign
id|len
op_minus
id|base
comma
)brace
suffix:semicolon
r_struct
id|msghdr
id|msg
op_assign
(brace
dot
id|msg_name
op_assign
id|addr
comma
dot
id|msg_namelen
op_assign
id|addrlen
comma
dot
id|msg_flags
op_assign
id|msgflags
comma
)brace
suffix:semicolon
r_if
c_cond
(paren
id|xdr-&gt;len
OG
id|len
)paren
id|msg.msg_flags
op_or_assign
id|MSG_MORE
suffix:semicolon
r_if
c_cond
(paren
id|iov.iov_len
op_ne
l_int|0
)paren
id|err
op_assign
id|kernel_sendmsg
c_func
(paren
id|sock
comma
op_amp
id|msg
comma
op_amp
id|iov
comma
l_int|1
comma
id|iov.iov_len
)paren
suffix:semicolon
r_else
id|err
op_assign
id|kernel_sendmsg
c_func
(paren
id|sock
comma
op_amp
id|msg
comma
l_int|NULL
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
id|ret
op_assign
id|err
suffix:semicolon
r_else
r_if
c_cond
(paren
id|err
OG
l_int|0
)paren
id|ret
op_add_assign
id|err
suffix:semicolon
r_if
c_cond
(paren
id|err
op_ne
id|iov.iov_len
)paren
r_goto
id|out
suffix:semicolon
id|base
op_assign
l_int|0
suffix:semicolon
)brace
r_else
id|base
op_sub_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
id|pglen
op_eq
l_int|0
)paren
r_goto
id|copy_tail
suffix:semicolon
r_if
c_cond
(paren
id|base
op_ge
id|pglen
)paren
(brace
id|base
op_sub_assign
id|pglen
suffix:semicolon
r_goto
id|copy_tail
suffix:semicolon
)brace
r_if
c_cond
(paren
id|base
op_logical_or
id|xdr-&gt;page_base
)paren
(brace
id|pglen
op_sub_assign
id|base
suffix:semicolon
id|base
op_add_assign
id|xdr-&gt;page_base
suffix:semicolon
id|ppage
op_add_assign
id|base
op_rshift
id|PAGE_CACHE_SHIFT
suffix:semicolon
id|base
op_and_assign
op_complement
id|PAGE_CACHE_MASK
suffix:semicolon
)brace
id|sendpage
op_assign
id|sock-&gt;ops-&gt;sendpage
ques
c_cond
suffix:colon
id|sock_no_sendpage
suffix:semicolon
r_do
(brace
r_int
id|flags
op_assign
id|msgflags
suffix:semicolon
id|len
op_assign
id|PAGE_CACHE_SIZE
suffix:semicolon
r_if
c_cond
(paren
id|base
)paren
id|len
op_sub_assign
id|base
suffix:semicolon
r_if
c_cond
(paren
id|pglen
OL
id|len
)paren
id|len
op_assign
id|pglen
suffix:semicolon
r_if
c_cond
(paren
id|pglen
op_ne
id|len
op_logical_or
id|xdr-&gt;tail
(braket
l_int|0
)braket
dot
id|iov_len
op_ne
l_int|0
)paren
id|flags
op_or_assign
id|MSG_MORE
suffix:semicolon
multiline_comment|/* Hmm... We might be dealing with highmem pages */
r_if
c_cond
(paren
id|PageHighMem
c_func
(paren
op_star
id|ppage
)paren
)paren
id|sendpage
op_assign
id|sock_no_sendpage
suffix:semicolon
id|err
op_assign
id|sendpage
c_func
(paren
id|sock
comma
op_star
id|ppage
comma
id|base
comma
id|len
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
id|ret
op_assign
id|err
suffix:semicolon
r_else
r_if
c_cond
(paren
id|err
OG
l_int|0
)paren
id|ret
op_add_assign
id|err
suffix:semicolon
r_if
c_cond
(paren
id|err
op_ne
id|len
)paren
r_goto
id|out
suffix:semicolon
id|base
op_assign
l_int|0
suffix:semicolon
id|ppage
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|pglen
op_sub_assign
id|len
)paren
op_ne
l_int|0
)paren
suffix:semicolon
id|copy_tail
suffix:colon
id|len
op_assign
id|xdr-&gt;tail
(braket
l_int|0
)braket
dot
id|iov_len
suffix:semicolon
r_if
c_cond
(paren
id|base
OL
id|len
)paren
(brace
r_struct
id|kvec
id|iov
op_assign
(brace
dot
id|iov_base
op_assign
id|xdr-&gt;tail
(braket
l_int|0
)braket
dot
id|iov_base
op_plus
id|base
comma
dot
id|iov_len
op_assign
id|len
op_minus
id|base
comma
)brace
suffix:semicolon
r_struct
id|msghdr
id|msg
op_assign
(brace
dot
id|msg_flags
op_assign
id|msgflags
comma
)brace
suffix:semicolon
id|err
op_assign
id|kernel_sendmsg
c_func
(paren
id|sock
comma
op_amp
id|msg
comma
op_amp
id|iov
comma
l_int|1
comma
id|iov.iov_len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
id|ret
op_assign
id|err
suffix:semicolon
r_else
r_if
c_cond
(paren
id|err
OG
l_int|0
)paren
id|ret
op_add_assign
id|err
suffix:semicolon
)brace
id|out
suffix:colon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Helper routines for doing &squot;memmove&squot; like operations on a struct xdr_buf&n; *&n; * _shift_data_right_pages&n; * @pages: vector of pages containing both the source and dest memory area.&n; * @pgto_base: page vector address of destination&n; * @pgfrom_base: page vector address of source&n; * @len: number of bytes to copy&n; *&n; * Note: the addresses pgto_base and pgfrom_base are both calculated in&n; *       the same way:&n; *            if a memory area starts at byte &squot;base&squot; in page &squot;pages[i]&squot;,&n; *            then its address is given as (i &lt;&lt; PAGE_CACHE_SHIFT) + base&n; * Also note: pgfrom_base must be &lt; pgto_base, but the memory areas&n; * &t;they point to may overlap.&n; */
r_static
r_void
DECL|function|_shift_data_right_pages
id|_shift_data_right_pages
c_func
(paren
r_struct
id|page
op_star
op_star
id|pages
comma
r_int
id|pgto_base
comma
r_int
id|pgfrom_base
comma
r_int
id|len
)paren
(brace
r_struct
id|page
op_star
op_star
id|pgfrom
comma
op_star
op_star
id|pgto
suffix:semicolon
r_char
op_star
id|vfrom
comma
op_star
id|vto
suffix:semicolon
r_int
id|copy
suffix:semicolon
id|BUG_ON
c_func
(paren
id|pgto_base
op_le
id|pgfrom_base
)paren
suffix:semicolon
id|pgto_base
op_add_assign
id|len
suffix:semicolon
id|pgfrom_base
op_add_assign
id|len
suffix:semicolon
id|pgto
op_assign
id|pages
op_plus
(paren
id|pgto_base
op_rshift
id|PAGE_CACHE_SHIFT
)paren
suffix:semicolon
id|pgfrom
op_assign
id|pages
op_plus
(paren
id|pgfrom_base
op_rshift
id|PAGE_CACHE_SHIFT
)paren
suffix:semicolon
id|pgto_base
op_and_assign
op_complement
id|PAGE_CACHE_MASK
suffix:semicolon
id|pgfrom_base
op_and_assign
op_complement
id|PAGE_CACHE_MASK
suffix:semicolon
r_do
(brace
multiline_comment|/* Are any pointers crossing a page boundary? */
r_if
c_cond
(paren
id|pgto_base
op_eq
l_int|0
)paren
(brace
id|pgto_base
op_assign
id|PAGE_CACHE_SIZE
suffix:semicolon
id|pgto
op_decrement
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pgfrom_base
op_eq
l_int|0
)paren
(brace
id|pgfrom_base
op_assign
id|PAGE_CACHE_SIZE
suffix:semicolon
id|pgfrom
op_decrement
suffix:semicolon
)brace
id|copy
op_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
id|copy
OG
id|pgto_base
)paren
id|copy
op_assign
id|pgto_base
suffix:semicolon
r_if
c_cond
(paren
id|copy
OG
id|pgfrom_base
)paren
id|copy
op_assign
id|pgfrom_base
suffix:semicolon
id|pgto_base
op_sub_assign
id|copy
suffix:semicolon
id|pgfrom_base
op_sub_assign
id|copy
suffix:semicolon
id|vto
op_assign
id|kmap_atomic
c_func
(paren
op_star
id|pgto
comma
id|KM_USER0
)paren
suffix:semicolon
id|vfrom
op_assign
id|kmap_atomic
c_func
(paren
op_star
id|pgfrom
comma
id|KM_USER1
)paren
suffix:semicolon
id|memmove
c_func
(paren
id|vto
op_plus
id|pgto_base
comma
id|vfrom
op_plus
id|pgfrom_base
comma
id|copy
)paren
suffix:semicolon
id|kunmap_atomic
c_func
(paren
id|vfrom
comma
id|KM_USER1
)paren
suffix:semicolon
id|kunmap_atomic
c_func
(paren
id|vto
comma
id|KM_USER0
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|len
op_sub_assign
id|copy
)paren
op_ne
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * _copy_to_pages&n; * @pages: array of pages&n; * @pgbase: page vector address of destination&n; * @p: pointer to source data&n; * @len: length&n; *&n; * Copies data from an arbitrary memory location into an array of pages&n; * The copy is assumed to be non-overlapping.&n; */
r_static
r_void
DECL|function|_copy_to_pages
id|_copy_to_pages
c_func
(paren
r_struct
id|page
op_star
op_star
id|pages
comma
r_int
id|pgbase
comma
r_const
r_char
op_star
id|p
comma
r_int
id|len
)paren
(brace
r_struct
id|page
op_star
op_star
id|pgto
suffix:semicolon
r_char
op_star
id|vto
suffix:semicolon
r_int
id|copy
suffix:semicolon
id|pgto
op_assign
id|pages
op_plus
(paren
id|pgbase
op_rshift
id|PAGE_CACHE_SHIFT
)paren
suffix:semicolon
id|pgbase
op_and_assign
op_complement
id|PAGE_CACHE_MASK
suffix:semicolon
r_do
(brace
id|copy
op_assign
id|PAGE_CACHE_SIZE
op_minus
id|pgbase
suffix:semicolon
r_if
c_cond
(paren
id|copy
OG
id|len
)paren
id|copy
op_assign
id|len
suffix:semicolon
id|vto
op_assign
id|kmap_atomic
c_func
(paren
op_star
id|pgto
comma
id|KM_USER0
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|vto
op_plus
id|pgbase
comma
id|p
comma
id|copy
)paren
suffix:semicolon
id|kunmap_atomic
c_func
(paren
id|vto
comma
id|KM_USER0
)paren
suffix:semicolon
id|pgbase
op_add_assign
id|copy
suffix:semicolon
r_if
c_cond
(paren
id|pgbase
op_eq
id|PAGE_CACHE_SIZE
)paren
(brace
id|pgbase
op_assign
l_int|0
suffix:semicolon
id|pgto
op_increment
suffix:semicolon
)brace
id|p
op_add_assign
id|copy
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|len
op_sub_assign
id|copy
)paren
op_ne
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * _copy_from_pages&n; * @p: pointer to destination&n; * @pages: array of pages&n; * @pgbase: offset of source data&n; * @len: length&n; *&n; * Copies data into an arbitrary memory location from an array of pages&n; * The copy is assumed to be non-overlapping.&n; */
r_void
DECL|function|_copy_from_pages
id|_copy_from_pages
c_func
(paren
r_char
op_star
id|p
comma
r_struct
id|page
op_star
op_star
id|pages
comma
r_int
id|pgbase
comma
r_int
id|len
)paren
(brace
r_struct
id|page
op_star
op_star
id|pgfrom
suffix:semicolon
r_char
op_star
id|vfrom
suffix:semicolon
r_int
id|copy
suffix:semicolon
id|pgfrom
op_assign
id|pages
op_plus
(paren
id|pgbase
op_rshift
id|PAGE_CACHE_SHIFT
)paren
suffix:semicolon
id|pgbase
op_and_assign
op_complement
id|PAGE_CACHE_MASK
suffix:semicolon
r_do
(brace
id|copy
op_assign
id|PAGE_CACHE_SIZE
op_minus
id|pgbase
suffix:semicolon
r_if
c_cond
(paren
id|copy
OG
id|len
)paren
id|copy
op_assign
id|len
suffix:semicolon
id|vfrom
op_assign
id|kmap_atomic
c_func
(paren
op_star
id|pgfrom
comma
id|KM_USER0
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|p
comma
id|vfrom
op_plus
id|pgbase
comma
id|copy
)paren
suffix:semicolon
id|kunmap_atomic
c_func
(paren
id|vfrom
comma
id|KM_USER0
)paren
suffix:semicolon
id|pgbase
op_add_assign
id|copy
suffix:semicolon
r_if
c_cond
(paren
id|pgbase
op_eq
id|PAGE_CACHE_SIZE
)paren
(brace
id|pgbase
op_assign
l_int|0
suffix:semicolon
id|pgfrom
op_increment
suffix:semicolon
)brace
id|p
op_add_assign
id|copy
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|len
op_sub_assign
id|copy
)paren
op_ne
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * xdr_shrink_bufhead&n; * @buf: xdr_buf&n; * @len: bytes to remove from buf-&gt;head[0]&n; *&n; * Shrinks XDR buffer&squot;s header kvec buf-&gt;head[0] by &n; * &squot;len&squot; bytes. The extra data is not lost, but is instead&n; * moved into the inlined pages and/or the tail.&n; */
r_void
DECL|function|xdr_shrink_bufhead
id|xdr_shrink_bufhead
c_func
(paren
r_struct
id|xdr_buf
op_star
id|buf
comma
r_int
id|len
)paren
(brace
r_struct
id|kvec
op_star
id|head
comma
op_star
id|tail
suffix:semicolon
r_int
id|copy
comma
id|offs
suffix:semicolon
r_int
r_int
id|pglen
op_assign
id|buf-&gt;page_len
suffix:semicolon
id|tail
op_assign
id|buf-&gt;tail
suffix:semicolon
id|head
op_assign
id|buf-&gt;head
suffix:semicolon
id|BUG_ON
(paren
id|len
OG
id|head-&gt;iov_len
)paren
suffix:semicolon
multiline_comment|/* Shift the tail first */
r_if
c_cond
(paren
id|tail-&gt;iov_len
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|tail-&gt;iov_len
OG
id|len
)paren
(brace
id|copy
op_assign
id|tail-&gt;iov_len
op_minus
id|len
suffix:semicolon
id|memmove
c_func
(paren
(paren
r_char
op_star
)paren
id|tail-&gt;iov_base
op_plus
id|len
comma
id|tail-&gt;iov_base
comma
id|copy
)paren
suffix:semicolon
)brace
multiline_comment|/* Copy from the inlined pages into the tail */
id|copy
op_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
id|copy
OG
id|pglen
)paren
id|copy
op_assign
id|pglen
suffix:semicolon
id|offs
op_assign
id|len
op_minus
id|copy
suffix:semicolon
r_if
c_cond
(paren
id|offs
op_ge
id|tail-&gt;iov_len
)paren
id|copy
op_assign
l_int|0
suffix:semicolon
r_else
r_if
c_cond
(paren
id|copy
OG
id|tail-&gt;iov_len
op_minus
id|offs
)paren
id|copy
op_assign
id|tail-&gt;iov_len
op_minus
id|offs
suffix:semicolon
r_if
c_cond
(paren
id|copy
op_ne
l_int|0
)paren
id|_copy_from_pages
c_func
(paren
(paren
r_char
op_star
)paren
id|tail-&gt;iov_base
op_plus
id|offs
comma
id|buf-&gt;pages
comma
id|buf-&gt;page_base
op_plus
id|pglen
op_plus
id|offs
op_minus
id|len
comma
id|copy
)paren
suffix:semicolon
multiline_comment|/* Do we also need to copy data from the head into the tail ? */
r_if
c_cond
(paren
id|len
OG
id|pglen
)paren
(brace
id|offs
op_assign
id|copy
op_assign
id|len
op_minus
id|pglen
suffix:semicolon
r_if
c_cond
(paren
id|copy
OG
id|tail-&gt;iov_len
)paren
id|copy
op_assign
id|tail-&gt;iov_len
suffix:semicolon
id|memcpy
c_func
(paren
id|tail-&gt;iov_base
comma
(paren
r_char
op_star
)paren
id|head-&gt;iov_base
op_plus
id|head-&gt;iov_len
op_minus
id|offs
comma
id|copy
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Now handle pages */
r_if
c_cond
(paren
id|pglen
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|pglen
OG
id|len
)paren
id|_shift_data_right_pages
c_func
(paren
id|buf-&gt;pages
comma
id|buf-&gt;page_base
op_plus
id|len
comma
id|buf-&gt;page_base
comma
id|pglen
op_minus
id|len
)paren
suffix:semicolon
id|copy
op_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|pglen
)paren
id|copy
op_assign
id|pglen
suffix:semicolon
id|_copy_to_pages
c_func
(paren
id|buf-&gt;pages
comma
id|buf-&gt;page_base
comma
(paren
r_char
op_star
)paren
id|head-&gt;iov_base
op_plus
id|head-&gt;iov_len
op_minus
id|len
comma
id|copy
)paren
suffix:semicolon
)brace
id|head-&gt;iov_len
op_sub_assign
id|len
suffix:semicolon
id|buf-&gt;buflen
op_sub_assign
id|len
suffix:semicolon
multiline_comment|/* Have we truncated the message? */
r_if
c_cond
(paren
id|buf-&gt;len
OG
id|buf-&gt;buflen
)paren
id|buf-&gt;len
op_assign
id|buf-&gt;buflen
suffix:semicolon
)brace
multiline_comment|/*&n; * xdr_shrink_pagelen&n; * @buf: xdr_buf&n; * @len: bytes to remove from buf-&gt;pages&n; *&n; * Shrinks XDR buffer&squot;s page array buf-&gt;pages by &n; * &squot;len&squot; bytes. The extra data is not lost, but is instead&n; * moved into the tail.&n; */
r_void
DECL|function|xdr_shrink_pagelen
id|xdr_shrink_pagelen
c_func
(paren
r_struct
id|xdr_buf
op_star
id|buf
comma
r_int
id|len
)paren
(brace
r_struct
id|kvec
op_star
id|tail
suffix:semicolon
r_int
id|copy
suffix:semicolon
r_char
op_star
id|p
suffix:semicolon
r_int
r_int
id|pglen
op_assign
id|buf-&gt;page_len
suffix:semicolon
id|tail
op_assign
id|buf-&gt;tail
suffix:semicolon
id|BUG_ON
(paren
id|len
OG
id|pglen
)paren
suffix:semicolon
multiline_comment|/* Shift the tail first */
r_if
c_cond
(paren
id|tail-&gt;iov_len
op_ne
l_int|0
)paren
(brace
id|p
op_assign
(paren
r_char
op_star
)paren
id|tail-&gt;iov_base
op_plus
id|len
suffix:semicolon
r_if
c_cond
(paren
id|tail-&gt;iov_len
OG
id|len
)paren
(brace
id|copy
op_assign
id|tail-&gt;iov_len
op_minus
id|len
suffix:semicolon
id|memmove
c_func
(paren
id|p
comma
id|tail-&gt;iov_base
comma
id|copy
)paren
suffix:semicolon
)brace
r_else
id|buf-&gt;buflen
op_sub_assign
id|len
suffix:semicolon
multiline_comment|/* Copy from the inlined pages into the tail */
id|copy
op_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
id|copy
OG
id|tail-&gt;iov_len
)paren
id|copy
op_assign
id|tail-&gt;iov_len
suffix:semicolon
id|_copy_from_pages
c_func
(paren
(paren
r_char
op_star
)paren
id|tail-&gt;iov_base
comma
id|buf-&gt;pages
comma
id|buf-&gt;page_base
op_plus
id|pglen
op_minus
id|len
comma
id|copy
)paren
suffix:semicolon
)brace
id|buf-&gt;page_len
op_sub_assign
id|len
suffix:semicolon
id|buf-&gt;buflen
op_sub_assign
id|len
suffix:semicolon
multiline_comment|/* Have we truncated the message? */
r_if
c_cond
(paren
id|buf-&gt;len
OG
id|buf-&gt;buflen
)paren
id|buf-&gt;len
op_assign
id|buf-&gt;buflen
suffix:semicolon
)brace
r_void
DECL|function|xdr_shift_buf
id|xdr_shift_buf
c_func
(paren
r_struct
id|xdr_buf
op_star
id|buf
comma
r_int
id|len
)paren
(brace
id|xdr_shrink_bufhead
c_func
(paren
id|buf
comma
id|len
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * xdr_init_encode - Initialize a struct xdr_stream for sending data.&n; * @xdr: pointer to xdr_stream struct&n; * @buf: pointer to XDR buffer in which to encode data&n; * @p: current pointer inside XDR buffer&n; *&n; * Note: at the moment the RPC client only passes the length of our&n; *&t; scratch buffer in the xdr_buf&squot;s header kvec. Previously this&n; *&t; meant we needed to call xdr_adjust_iovec() after encoding the&n; *&t; data. With the new scheme, the xdr_stream manages the details&n; *&t; of the buffer length, and takes care of adjusting the kvec&n; *&t; length for us.&n; */
DECL|function|xdr_init_encode
r_void
id|xdr_init_encode
c_func
(paren
r_struct
id|xdr_stream
op_star
id|xdr
comma
r_struct
id|xdr_buf
op_star
id|buf
comma
r_uint32
op_star
id|p
)paren
(brace
r_struct
id|kvec
op_star
id|iov
op_assign
id|buf-&gt;head
suffix:semicolon
id|xdr-&gt;buf
op_assign
id|buf
suffix:semicolon
id|xdr-&gt;iov
op_assign
id|iov
suffix:semicolon
id|xdr-&gt;end
op_assign
(paren
r_uint32
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|iov-&gt;iov_base
op_plus
id|iov-&gt;iov_len
)paren
suffix:semicolon
id|buf-&gt;len
op_assign
id|iov-&gt;iov_len
op_assign
(paren
r_char
op_star
)paren
id|p
op_minus
(paren
r_char
op_star
)paren
id|iov-&gt;iov_base
suffix:semicolon
id|xdr-&gt;p
op_assign
id|p
suffix:semicolon
)brace
DECL|variable|xdr_init_encode
id|EXPORT_SYMBOL
c_func
(paren
id|xdr_init_encode
)paren
suffix:semicolon
multiline_comment|/**&n; * xdr_reserve_space - Reserve buffer space for sending&n; * @xdr: pointer to xdr_stream&n; * @nbytes: number of bytes to reserve&n; *&n; * Checks that we have enough buffer space to encode &squot;nbytes&squot; more&n; * bytes of data. If so, update the total xdr_buf length, and&n; * adjust the length of the current kvec.&n; */
DECL|function|xdr_reserve_space
r_uint32
op_star
id|xdr_reserve_space
c_func
(paren
r_struct
id|xdr_stream
op_star
id|xdr
comma
r_int
id|nbytes
)paren
(brace
r_uint32
op_star
id|p
op_assign
id|xdr-&gt;p
suffix:semicolon
r_uint32
op_star
id|q
suffix:semicolon
multiline_comment|/* align nbytes on the next 32-bit boundary */
id|nbytes
op_add_assign
l_int|3
suffix:semicolon
id|nbytes
op_and_assign
op_complement
l_int|3
suffix:semicolon
id|q
op_assign
id|p
op_plus
(paren
id|nbytes
op_rshift
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|q
OG
id|xdr-&gt;end
op_logical_or
id|q
OL
id|p
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
id|xdr-&gt;p
op_assign
id|q
suffix:semicolon
id|xdr-&gt;iov-&gt;iov_len
op_add_assign
id|nbytes
suffix:semicolon
id|xdr-&gt;buf-&gt;len
op_add_assign
id|nbytes
suffix:semicolon
r_return
id|p
suffix:semicolon
)brace
DECL|variable|xdr_reserve_space
id|EXPORT_SYMBOL
c_func
(paren
id|xdr_reserve_space
)paren
suffix:semicolon
multiline_comment|/**&n; * xdr_write_pages - Insert a list of pages into an XDR buffer for sending&n; * @xdr: pointer to xdr_stream&n; * @pages: list of pages&n; * @base: offset of first byte&n; * @len: length of data in bytes&n; *&n; */
DECL|function|xdr_write_pages
r_void
id|xdr_write_pages
c_func
(paren
r_struct
id|xdr_stream
op_star
id|xdr
comma
r_struct
id|page
op_star
op_star
id|pages
comma
r_int
r_int
id|base
comma
r_int
r_int
id|len
)paren
(brace
r_struct
id|xdr_buf
op_star
id|buf
op_assign
id|xdr-&gt;buf
suffix:semicolon
r_struct
id|kvec
op_star
id|iov
op_assign
id|buf-&gt;tail
suffix:semicolon
id|buf-&gt;pages
op_assign
id|pages
suffix:semicolon
id|buf-&gt;page_base
op_assign
id|base
suffix:semicolon
id|buf-&gt;page_len
op_assign
id|len
suffix:semicolon
id|iov-&gt;iov_base
op_assign
(paren
r_char
op_star
)paren
id|xdr-&gt;p
suffix:semicolon
id|iov-&gt;iov_len
op_assign
l_int|0
suffix:semicolon
id|xdr-&gt;iov
op_assign
id|iov
suffix:semicolon
r_if
c_cond
(paren
id|len
op_amp
l_int|3
)paren
(brace
r_int
r_int
id|pad
op_assign
l_int|4
op_minus
(paren
id|len
op_amp
l_int|3
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|xdr-&gt;p
op_ge
id|xdr-&gt;end
)paren
suffix:semicolon
id|iov-&gt;iov_base
op_assign
(paren
r_char
op_star
)paren
id|xdr-&gt;p
op_plus
(paren
id|len
op_amp
l_int|3
)paren
suffix:semicolon
id|iov-&gt;iov_len
op_add_assign
id|pad
suffix:semicolon
id|len
op_add_assign
id|pad
suffix:semicolon
op_star
id|xdr-&gt;p
op_increment
op_assign
l_int|0
suffix:semicolon
)brace
id|buf-&gt;buflen
op_add_assign
id|len
suffix:semicolon
id|buf-&gt;len
op_add_assign
id|len
suffix:semicolon
)brace
DECL|variable|xdr_write_pages
id|EXPORT_SYMBOL
c_func
(paren
id|xdr_write_pages
)paren
suffix:semicolon
multiline_comment|/**&n; * xdr_init_decode - Initialize an xdr_stream for decoding data.&n; * @xdr: pointer to xdr_stream struct&n; * @buf: pointer to XDR buffer from which to decode data&n; * @p: current pointer inside XDR buffer&n; */
DECL|function|xdr_init_decode
r_void
id|xdr_init_decode
c_func
(paren
r_struct
id|xdr_stream
op_star
id|xdr
comma
r_struct
id|xdr_buf
op_star
id|buf
comma
r_uint32
op_star
id|p
)paren
(brace
r_struct
id|kvec
op_star
id|iov
op_assign
id|buf-&gt;head
suffix:semicolon
r_int
r_int
id|len
op_assign
id|iov-&gt;iov_len
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|buf-&gt;len
)paren
id|len
op_assign
id|buf-&gt;len
suffix:semicolon
id|xdr-&gt;buf
op_assign
id|buf
suffix:semicolon
id|xdr-&gt;iov
op_assign
id|iov
suffix:semicolon
id|xdr-&gt;p
op_assign
id|p
suffix:semicolon
id|xdr-&gt;end
op_assign
(paren
r_uint32
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|iov-&gt;iov_base
op_plus
id|len
)paren
suffix:semicolon
)brace
DECL|variable|xdr_init_decode
id|EXPORT_SYMBOL
c_func
(paren
id|xdr_init_decode
)paren
suffix:semicolon
multiline_comment|/**&n; * xdr_inline_decode - Retrieve non-page XDR data to decode&n; * @xdr: pointer to xdr_stream struct&n; * @nbytes: number of bytes of data to decode&n; *&n; * Check if the input buffer is long enough to enable us to decode&n; * &squot;nbytes&squot; more bytes of data starting at the current position.&n; * If so return the current pointer, then update the current&n; * pointer position.&n; */
DECL|function|xdr_inline_decode
r_uint32
op_star
id|xdr_inline_decode
c_func
(paren
r_struct
id|xdr_stream
op_star
id|xdr
comma
r_int
id|nbytes
)paren
(brace
r_uint32
op_star
id|p
op_assign
id|xdr-&gt;p
suffix:semicolon
r_uint32
op_star
id|q
op_assign
id|p
op_plus
id|XDR_QUADLEN
c_func
(paren
id|nbytes
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|q
OG
id|xdr-&gt;end
op_logical_or
id|q
OL
id|p
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
id|xdr-&gt;p
op_assign
id|q
suffix:semicolon
r_return
id|p
suffix:semicolon
)brace
DECL|variable|xdr_inline_decode
id|EXPORT_SYMBOL
c_func
(paren
id|xdr_inline_decode
)paren
suffix:semicolon
multiline_comment|/**&n; * xdr_read_pages - Ensure page-based XDR data to decode is aligned at current pointer position&n; * @xdr: pointer to xdr_stream struct&n; * @len: number of bytes of page data&n; *&n; * Moves data beyond the current pointer position from the XDR head[] buffer&n; * into the page list. Any data that lies beyond current position + &quot;len&quot;&n; * bytes is moved into the XDR tail[]. The current pointer is then&n; * repositioned at the beginning of the XDR tail.&n; */
DECL|function|xdr_read_pages
r_void
id|xdr_read_pages
c_func
(paren
r_struct
id|xdr_stream
op_star
id|xdr
comma
r_int
r_int
id|len
)paren
(brace
r_struct
id|xdr_buf
op_star
id|buf
op_assign
id|xdr-&gt;buf
suffix:semicolon
r_struct
id|kvec
op_star
id|iov
suffix:semicolon
id|ssize_t
id|shift
suffix:semicolon
r_int
r_int
id|end
suffix:semicolon
r_int
id|padding
suffix:semicolon
multiline_comment|/* Realign pages to current pointer position */
id|iov
op_assign
id|buf-&gt;head
suffix:semicolon
id|shift
op_assign
id|iov-&gt;iov_len
op_plus
(paren
r_char
op_star
)paren
id|iov-&gt;iov_base
op_minus
(paren
r_char
op_star
)paren
id|xdr-&gt;p
suffix:semicolon
r_if
c_cond
(paren
id|shift
OG
l_int|0
)paren
id|xdr_shrink_bufhead
c_func
(paren
id|buf
comma
id|shift
)paren
suffix:semicolon
multiline_comment|/* Truncate page data and move it into the tail */
r_if
c_cond
(paren
id|buf-&gt;page_len
OG
id|len
)paren
id|xdr_shrink_pagelen
c_func
(paren
id|buf
comma
id|buf-&gt;page_len
op_minus
id|len
)paren
suffix:semicolon
id|padding
op_assign
(paren
id|XDR_QUADLEN
c_func
(paren
id|len
)paren
op_lshift
l_int|2
)paren
op_minus
id|len
suffix:semicolon
id|xdr-&gt;iov
op_assign
id|iov
op_assign
id|buf-&gt;tail
suffix:semicolon
multiline_comment|/* Compute remaining message length.  */
id|end
op_assign
id|iov-&gt;iov_len
suffix:semicolon
id|shift
op_assign
id|buf-&gt;buflen
op_minus
id|buf-&gt;len
suffix:semicolon
r_if
c_cond
(paren
id|shift
OL
id|end
)paren
id|end
op_sub_assign
id|shift
suffix:semicolon
r_else
r_if
c_cond
(paren
id|shift
OG
l_int|0
)paren
id|end
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Position current pointer at beginning of tail, and&n;&t; * set remaining message length.&n;&t; */
id|xdr-&gt;p
op_assign
(paren
r_uint32
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|iov-&gt;iov_base
op_plus
id|padding
)paren
suffix:semicolon
id|xdr-&gt;end
op_assign
(paren
r_uint32
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|iov-&gt;iov_base
op_plus
id|end
)paren
suffix:semicolon
)brace
DECL|variable|xdr_read_pages
id|EXPORT_SYMBOL
c_func
(paren
id|xdr_read_pages
)paren
suffix:semicolon
DECL|variable|empty_iov
r_static
r_struct
id|kvec
id|empty_iov
op_assign
(brace
dot
id|iov_base
op_assign
l_int|NULL
comma
dot
id|iov_len
op_assign
l_int|0
)brace
suffix:semicolon
r_void
DECL|function|xdr_buf_from_iov
id|xdr_buf_from_iov
c_func
(paren
r_struct
id|kvec
op_star
id|iov
comma
r_struct
id|xdr_buf
op_star
id|buf
)paren
(brace
id|buf-&gt;head
(braket
l_int|0
)braket
op_assign
op_star
id|iov
suffix:semicolon
id|buf-&gt;tail
(braket
l_int|0
)braket
op_assign
id|empty_iov
suffix:semicolon
id|buf-&gt;page_len
op_assign
l_int|0
suffix:semicolon
id|buf-&gt;buflen
op_assign
id|buf-&gt;len
op_assign
id|iov-&gt;iov_len
suffix:semicolon
)brace
multiline_comment|/* Sets subiov to the intersection of iov with the buffer of length len&n; * starting base bytes after iov.  Indicates empty intersection by setting&n; * length of subiov to zero.  Decrements len by length of subiov, sets base&n; * to zero (or decrements it by length of iov if subiov is empty). */
r_static
r_void
DECL|function|iov_subsegment
id|iov_subsegment
c_func
(paren
r_struct
id|kvec
op_star
id|iov
comma
r_struct
id|kvec
op_star
id|subiov
comma
r_int
op_star
id|base
comma
r_int
op_star
id|len
)paren
(brace
r_if
c_cond
(paren
op_star
id|base
OG
id|iov-&gt;iov_len
)paren
(brace
id|subiov-&gt;iov_base
op_assign
l_int|NULL
suffix:semicolon
id|subiov-&gt;iov_len
op_assign
l_int|0
suffix:semicolon
op_star
id|base
op_sub_assign
id|iov-&gt;iov_len
suffix:semicolon
)brace
r_else
(brace
id|subiov-&gt;iov_base
op_assign
id|iov-&gt;iov_base
op_plus
op_star
id|base
suffix:semicolon
id|subiov-&gt;iov_len
op_assign
id|min
c_func
(paren
op_star
id|len
comma
(paren
r_int
)paren
id|iov-&gt;iov_len
op_minus
op_star
id|base
)paren
suffix:semicolon
op_star
id|base
op_assign
l_int|0
suffix:semicolon
)brace
op_star
id|len
op_sub_assign
id|subiov-&gt;iov_len
suffix:semicolon
)brace
multiline_comment|/* Sets subbuf to the portion of buf of length len beginning base bytes&n; * from the start of buf. Returns -1 if base of length are out of bounds. */
r_int
DECL|function|xdr_buf_subsegment
id|xdr_buf_subsegment
c_func
(paren
r_struct
id|xdr_buf
op_star
id|buf
comma
r_struct
id|xdr_buf
op_star
id|subbuf
comma
r_int
id|base
comma
r_int
id|len
)paren
(brace
r_int
id|i
suffix:semicolon
id|subbuf-&gt;buflen
op_assign
id|subbuf-&gt;len
op_assign
id|len
suffix:semicolon
id|iov_subsegment
c_func
(paren
id|buf-&gt;head
comma
id|subbuf-&gt;head
comma
op_amp
id|base
comma
op_amp
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|base
OL
id|buf-&gt;page_len
)paren
(brace
id|i
op_assign
(paren
id|base
op_plus
id|buf-&gt;page_base
)paren
op_rshift
id|PAGE_CACHE_SHIFT
suffix:semicolon
id|subbuf-&gt;pages
op_assign
op_amp
id|buf-&gt;pages
(braket
id|i
)braket
suffix:semicolon
id|subbuf-&gt;page_base
op_assign
(paren
id|base
op_plus
id|buf-&gt;page_base
)paren
op_amp
op_complement
id|PAGE_CACHE_MASK
suffix:semicolon
id|subbuf-&gt;page_len
op_assign
id|min
c_func
(paren
(paren
r_int
)paren
id|buf-&gt;page_len
op_minus
id|base
comma
id|len
)paren
suffix:semicolon
id|len
op_sub_assign
id|subbuf-&gt;page_len
suffix:semicolon
id|base
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|base
op_sub_assign
id|buf-&gt;page_len
suffix:semicolon
id|subbuf-&gt;page_len
op_assign
l_int|0
suffix:semicolon
)brace
id|iov_subsegment
c_func
(paren
id|buf-&gt;tail
comma
id|subbuf-&gt;tail
comma
op_amp
id|base
comma
op_amp
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|base
op_logical_or
id|len
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* obj is assumed to point to allocated memory of size at least len: */
r_int
DECL|function|read_bytes_from_xdr_buf
id|read_bytes_from_xdr_buf
c_func
(paren
r_struct
id|xdr_buf
op_star
id|buf
comma
r_int
id|base
comma
r_void
op_star
id|obj
comma
r_int
id|len
)paren
(brace
r_struct
id|xdr_buf
id|subbuf
suffix:semicolon
r_int
id|this_len
suffix:semicolon
r_int
id|status
suffix:semicolon
id|status
op_assign
id|xdr_buf_subsegment
c_func
(paren
id|buf
comma
op_amp
id|subbuf
comma
id|base
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
)paren
r_goto
id|out
suffix:semicolon
id|this_len
op_assign
id|min
c_func
(paren
id|len
comma
(paren
r_int
)paren
id|subbuf.head
(braket
l_int|0
)braket
dot
id|iov_len
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|obj
comma
id|subbuf.head
(braket
l_int|0
)braket
dot
id|iov_base
comma
id|this_len
)paren
suffix:semicolon
id|len
op_sub_assign
id|this_len
suffix:semicolon
id|obj
op_add_assign
id|this_len
suffix:semicolon
id|this_len
op_assign
id|min
c_func
(paren
id|len
comma
(paren
r_int
)paren
id|subbuf.page_len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|this_len
)paren
id|_copy_from_pages
c_func
(paren
id|obj
comma
id|subbuf.pages
comma
id|subbuf.page_base
comma
id|this_len
)paren
suffix:semicolon
id|len
op_sub_assign
id|this_len
suffix:semicolon
id|obj
op_add_assign
id|this_len
suffix:semicolon
id|this_len
op_assign
id|min
c_func
(paren
id|len
comma
(paren
r_int
)paren
id|subbuf.tail
(braket
l_int|0
)braket
dot
id|iov_len
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|obj
comma
id|subbuf.tail
(braket
l_int|0
)braket
dot
id|iov_base
comma
id|this_len
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|status
suffix:semicolon
)brace
r_static
r_int
DECL|function|read_u32_from_xdr_buf
id|read_u32_from_xdr_buf
c_func
(paren
r_struct
id|xdr_buf
op_star
id|buf
comma
r_int
id|base
comma
id|u32
op_star
id|obj
)paren
(brace
id|u32
id|raw
suffix:semicolon
r_int
id|status
suffix:semicolon
id|status
op_assign
id|read_bytes_from_xdr_buf
c_func
(paren
id|buf
comma
id|base
comma
op_amp
id|raw
comma
r_sizeof
(paren
op_star
id|obj
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
)paren
r_return
id|status
suffix:semicolon
op_star
id|obj
op_assign
id|ntohl
c_func
(paren
id|raw
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* If the netobj starting offset bytes from the start of xdr_buf is contained&n; * entirely in the head or the tail, set object to point to it; otherwise&n; * try to find space for it at the end of the tail, copy it there, and&n; * set obj to point to it. */
r_int
DECL|function|xdr_buf_read_netobj
id|xdr_buf_read_netobj
c_func
(paren
r_struct
id|xdr_buf
op_star
id|buf
comma
r_struct
id|xdr_netobj
op_star
id|obj
comma
r_int
id|offset
)paren
(brace
id|u32
id|tail_offset
op_assign
id|buf-&gt;head
(braket
l_int|0
)braket
dot
id|iov_len
op_plus
id|buf-&gt;page_len
suffix:semicolon
id|u32
id|obj_end_offset
suffix:semicolon
r_if
c_cond
(paren
id|read_u32_from_xdr_buf
c_func
(paren
id|buf
comma
id|offset
comma
op_amp
id|obj-&gt;len
)paren
)paren
r_goto
id|out
suffix:semicolon
id|obj_end_offset
op_assign
id|offset
op_plus
l_int|4
op_plus
id|obj-&gt;len
suffix:semicolon
r_if
c_cond
(paren
id|obj_end_offset
op_le
id|buf-&gt;head
(braket
l_int|0
)braket
dot
id|iov_len
)paren
(brace
multiline_comment|/* The obj is contained entirely in the head: */
id|obj-&gt;data
op_assign
id|buf-&gt;head
(braket
l_int|0
)braket
dot
id|iov_base
op_plus
id|offset
op_plus
l_int|4
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|offset
op_plus
l_int|4
op_ge
id|tail_offset
)paren
(brace
r_if
c_cond
(paren
id|obj_end_offset
op_minus
id|tail_offset
OG
id|buf-&gt;tail
(braket
l_int|0
)braket
dot
id|iov_len
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* The obj is contained entirely in the tail: */
id|obj-&gt;data
op_assign
id|buf-&gt;tail
(braket
l_int|0
)braket
dot
id|iov_base
op_plus
id|offset
op_minus
id|tail_offset
op_plus
l_int|4
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* use end of tail as storage for obj:&n;&t;&t; * (We don&squot;t copy to the beginning because then we&squot;d have&n;&t;&t; * to worry about doing a potentially overlapping copy.&n;&t;&t; * This assumes the object is at most half the length of the&n;&t;&t; * tail.) */
r_if
c_cond
(paren
id|obj-&gt;len
OG
id|buf-&gt;tail
(braket
l_int|0
)braket
dot
id|iov_len
)paren
r_goto
id|out
suffix:semicolon
id|obj-&gt;data
op_assign
id|buf-&gt;tail
(braket
l_int|0
)braket
dot
id|iov_base
op_plus
id|buf-&gt;tail
(braket
l_int|0
)braket
dot
id|iov_len
op_minus
id|obj-&gt;len
suffix:semicolon
r_if
c_cond
(paren
id|read_bytes_from_xdr_buf
c_func
(paren
id|buf
comma
id|offset
op_plus
l_int|4
comma
id|obj-&gt;data
comma
id|obj-&gt;len
)paren
)paren
r_goto
id|out
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
id|out
suffix:colon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
eof
