multiline_comment|/* Copyright (c) 1999-2000 Cisco, Inc.&n; * Copyright (c) 1999-2001 Motorola, Inc.&n; * Copyright (c) 2001-2003 International Business Machines, Corp.&n; * Copyright (c) 2001-2003 Intel Corp.&n; * Copyright (c) 2001-2002 Nokia, Inc.&n; * Copyright (c) 2001 La Monte H.P. Yarroll&n; *&n; * This file is part of the SCTP kernel reference Implementation&n; *&n; * These functions interface with the sockets layer to implement the&n; * SCTP Extensions for the Sockets API.&n; *&n; * Note that the descriptions from the specification are USER level&n; * functions--this file is the functions which populate the struct proto&n; * for SCTP which is the BOTTOM of the sockets interface.&n; *&n; * The SCTP reference implementation is free software;&n; * you can redistribute it and/or modify it under the terms of&n; * the GNU General Public License as published by&n; * the Free Software Foundation; either version 2, or (at your option)&n; * any later version.&n; *&n; * The SCTP reference implementation is distributed in the hope that it&n; * will be useful, but WITHOUT ANY WARRANTY; without even the implied&n; *                 ************************&n; * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&n; * See the GNU General Public License for more details.&n; *&n; * You should have received a copy of the GNU General Public License&n; * along with GNU CC; see the file COPYING.  If not, write to&n; * the Free Software Foundation, 59 Temple Place - Suite 330,&n; * Boston, MA 02111-1307, USA.&n; *&n; * Please send any bug reports or fixes you make to the&n; * email address(es):&n; *    lksctp developers &lt;lksctp-developers@lists.sourceforge.net&gt;&n; *&n; * Or submit a bug report through the following website:&n; *    http://www.sf.net/projects/lksctp&n; *&n; * Written or modified by:&n; *    La Monte H.P. Yarroll &lt;piggy@acm.org&gt;&n; *    Narasimha Budihal     &lt;narsi@refcode.org&gt;&n; *    Karl Knutson          &lt;karl@athena.chicago.il.us&gt;&n; *    Jon Grimm             &lt;jgrimm@us.ibm.com&gt;&n; *    Xingang Guo           &lt;xingang.guo@intel.com&gt;&n; *    Daisy Chang           &lt;daisyc@us.ibm.com&gt;&n; *    Sridhar Samudrala     &lt;samudrala@us.ibm.com&gt;&n; *    Inaky Perez-Gonzalez  &lt;inaky.gonzalez@intel.com&gt;&n; *    Ardelle Fan&t;    &lt;ardelle.fan@intel.com&gt;&n; *&n; * Any bugs reported given to us we will try to fix... any fixes shared will&n; * be incorporated into the next SCTP release.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/compiler.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/wait.h&gt;
macro_line|#include &lt;linux/time.h&gt;
macro_line|#include &lt;linux/ip.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/poll.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;net/ip.h&gt;
macro_line|#include &lt;net/icmp.h&gt;
macro_line|#include &lt;net/route.h&gt;
macro_line|#include &lt;net/ipv6.h&gt;
macro_line|#include &lt;net/inet_common.h&gt;
macro_line|#include &lt;linux/socket.h&gt; /* for sa_family_t */
macro_line|#include &lt;net/sock.h&gt;
macro_line|#include &lt;net/sctp/sctp.h&gt;
multiline_comment|/* WARNING:  Please do not remove the SCTP_STATIC attribute to&n; * any of the functions below as they are used to export functions&n; * used by a project regression testsuite.&n; */
multiline_comment|/* Forward declarations for internal helper functions. */
r_static
r_int
id|sctp_writeable
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
suffix:semicolon
r_static
r_inline
r_int
id|sctp_wspace
c_func
(paren
id|sctp_association_t
op_star
id|asoc
)paren
suffix:semicolon
r_static
r_inline
r_void
id|sctp_set_owner_w
c_func
(paren
id|sctp_chunk_t
op_star
id|chunk
)paren
suffix:semicolon
r_static
r_void
id|sctp_wfree
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
suffix:semicolon
r_static
r_int
id|sctp_wait_for_sndbuf
c_func
(paren
id|sctp_association_t
op_star
id|asoc
comma
r_int
op_star
id|timeo_p
comma
r_int
id|msg_len
)paren
suffix:semicolon
r_static
r_int
id|sctp_wait_for_packet
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
op_star
id|err
comma
r_int
op_star
id|timeo_p
)paren
suffix:semicolon
r_static
r_int
id|sctp_wait_for_connect
c_func
(paren
id|sctp_association_t
op_star
id|asoc
comma
r_int
op_star
id|timeo_p
)paren
suffix:semicolon
r_static
r_inline
r_int
id|sctp_verify_addr
c_func
(paren
r_struct
id|sock
op_star
comma
r_union
id|sctp_addr
op_star
comma
r_int
)paren
suffix:semicolon
r_static
r_int
id|sctp_bindx_add
c_func
(paren
r_struct
id|sock
op_star
comma
r_struct
id|sockaddr_storage
op_star
comma
r_int
)paren
suffix:semicolon
r_static
r_int
id|sctp_bindx_rem
c_func
(paren
r_struct
id|sock
op_star
comma
r_struct
id|sockaddr_storage
op_star
comma
r_int
)paren
suffix:semicolon
r_static
r_int
id|sctp_do_bind
c_func
(paren
r_struct
id|sock
op_star
comma
r_union
id|sctp_addr
op_star
comma
r_int
)paren
suffix:semicolon
r_static
r_int
id|sctp_autobind
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
suffix:semicolon
multiline_comment|/* API 3.1.2 bind() - UDP Style Syntax&n; * The syntax of bind() is,&n; *&n; *   ret = bind(int sd, struct sockaddr *addr, int addrlen);&n; *&n; *   sd      - the socket descriptor returned by socket().&n; *   addr    - the address structure (struct sockaddr_in or struct&n; *             sockaddr_in6 [RFC 2553]),&n; *   addrlen - the size of the address structure.&n; *&n; * The caller should use struct sockaddr_storage described in RFC 2553&n; * to represent addr for portability reason.&n; */
DECL|function|sctp_bind
r_int
id|sctp_bind
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sockaddr
op_star
id|uaddr
comma
r_int
id|addr_len
)paren
(brace
r_int
id|retval
op_assign
l_int|0
suffix:semicolon
id|sctp_lock_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;sctp_bind(sk: %p, uaddr: %p, addr_len: %d)&bslash;n&quot;
comma
id|sk
comma
id|uaddr
comma
id|addr_len
)paren
suffix:semicolon
multiline_comment|/* Disallow binding twice. */
r_if
c_cond
(paren
op_logical_neg
id|sctp_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|ep-&gt;base.bind_addr.port
)paren
id|retval
op_assign
id|sctp_do_bind
c_func
(paren
id|sk
comma
(paren
r_union
id|sctp_addr
op_star
)paren
id|uaddr
comma
id|addr_len
)paren
suffix:semicolon
r_else
id|retval
op_assign
op_minus
id|EINVAL
suffix:semicolon
id|sctp_release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
r_static
r_int
id|sctp_get_port_local
c_func
(paren
r_struct
id|sock
op_star
comma
r_union
id|sctp_addr
op_star
)paren
suffix:semicolon
multiline_comment|/* Verify this is a valid sockaddr. */
DECL|function|sctp_sockaddr_af
r_static
r_struct
id|sctp_af
op_star
id|sctp_sockaddr_af
c_func
(paren
r_struct
id|sctp_opt
op_star
id|opt
comma
r_union
id|sctp_addr
op_star
id|addr
comma
r_int
id|len
)paren
(brace
r_struct
id|sctp_af
op_star
id|af
suffix:semicolon
multiline_comment|/* Check minimum size.  */
r_if
c_cond
(paren
id|len
OL
r_sizeof
(paren
r_struct
id|sockaddr
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/* Does this PF support this AF? */
r_if
c_cond
(paren
op_logical_neg
id|opt-&gt;pf
op_member_access_from_pointer
id|af_supported
c_func
(paren
id|addr-&gt;sa.sa_family
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/* If we get this far, af is valid. */
id|af
op_assign
id|sctp_get_af_specific
c_func
(paren
id|addr-&gt;sa.sa_family
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
id|af-&gt;sockaddr_len
)paren
r_return
l_int|NULL
suffix:semicolon
r_return
id|af
suffix:semicolon
)brace
multiline_comment|/* Bind a local address either to an endpoint or to an association.  */
DECL|function|sctp_do_bind
id|SCTP_STATIC
r_int
id|sctp_do_bind
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_union
id|sctp_addr
op_star
id|addr
comma
r_int
id|len
)paren
(brace
id|sctp_opt_t
op_star
id|sp
op_assign
id|sctp_sk
c_func
(paren
id|sk
)paren
suffix:semicolon
id|sctp_endpoint_t
op_star
id|ep
op_assign
id|sp-&gt;ep
suffix:semicolon
id|sctp_bind_addr_t
op_star
id|bp
op_assign
op_amp
id|ep-&gt;base.bind_addr
suffix:semicolon
r_struct
id|sctp_af
op_star
id|af
suffix:semicolon
r_int
r_int
id|snum
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;sctp_do_bind(sk: %p, newaddr: %p, len: %d)&bslash;n&quot;
comma
id|sk
comma
id|addr
comma
id|len
)paren
suffix:semicolon
multiline_comment|/* Common sockaddr verification. */
id|af
op_assign
id|sctp_sockaddr_af
c_func
(paren
id|sp
comma
id|addr
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|af
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* PF specific bind() address verification. */
r_if
c_cond
(paren
op_logical_neg
id|sp-&gt;pf
op_member_access_from_pointer
id|bind_verify
c_func
(paren
id|sp
comma
id|addr
)paren
)paren
r_return
op_minus
id|EADDRNOTAVAIL
suffix:semicolon
id|snum
op_assign
id|ntohs
c_func
(paren
id|addr-&gt;v4.sin_port
)paren
suffix:semicolon
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;sctp_do_bind: port: %d, new port: %d&bslash;n&quot;
comma
id|bp-&gt;port
comma
id|snum
)paren
suffix:semicolon
multiline_comment|/* We must either be unbound, or bind to the same port.  */
r_if
c_cond
(paren
id|bp-&gt;port
op_logical_and
(paren
id|snum
op_ne
id|bp-&gt;port
)paren
)paren
(brace
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;sctp_do_bind:&quot;
l_string|&quot; New port %d does not match existing port &quot;
l_string|&quot;%d.&bslash;n&quot;
comma
id|snum
comma
id|bp-&gt;port
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|snum
op_logical_and
id|snum
OL
id|PROT_SOCK
op_logical_and
op_logical_neg
id|capable
c_func
(paren
id|CAP_NET_BIND_SERVICE
)paren
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
multiline_comment|/* Make sure we are allowed to bind here.&n;&t; * The function sctp_get_port_local() does duplicate address&n;&t; * detection.&n;&t; */
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|sctp_get_port_local
c_func
(paren
id|sk
comma
id|addr
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|ret
op_eq
(paren
r_int
)paren
id|sk
)paren
(brace
multiline_comment|/* This endpoint has a conflicting address. */
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_else
(brace
r_return
op_minus
id|EADDRINUSE
suffix:semicolon
)brace
)brace
multiline_comment|/* Refresh ephemeral port.  */
r_if
c_cond
(paren
op_logical_neg
id|snum
)paren
id|snum
op_assign
id|inet_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|num
suffix:semicolon
multiline_comment|/* Add the address to the bind address list.  */
id|sctp_local_bh_disable
c_func
(paren
)paren
suffix:semicolon
id|sctp_write_lock
c_func
(paren
op_amp
id|ep-&gt;base.addr_lock
)paren
suffix:semicolon
multiline_comment|/* Use GFP_ATOMIC since BHs are disabled.  */
id|addr-&gt;v4.sin_port
op_assign
id|ntohs
c_func
(paren
id|addr-&gt;v4.sin_port
)paren
suffix:semicolon
id|ret
op_assign
id|sctp_add_bind_addr
c_func
(paren
id|bp
comma
id|addr
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
id|addr-&gt;v4.sin_port
op_assign
id|htons
c_func
(paren
id|addr-&gt;v4.sin_port
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ret
op_logical_and
op_logical_neg
id|bp-&gt;port
)paren
id|bp-&gt;port
op_assign
id|snum
suffix:semicolon
id|sctp_write_unlock
c_func
(paren
op_amp
id|ep-&gt;base.addr_lock
)paren
suffix:semicolon
id|sctp_local_bh_enable
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Copy back into socket for getsockname() use. */
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
(brace
id|inet_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|sport
op_assign
id|htons
c_func
(paren
id|inet_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|num
)paren
suffix:semicolon
id|af
op_member_access_from_pointer
id|to_sk
c_func
(paren
id|addr
comma
id|sk
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* API 8.1 sctp_bindx()&n; *&n; * The syntax of sctp_bindx() is,&n; *&n; *   ret = sctp_bindx(int sd,&n; *                    struct sockaddr_storage *addrs,&n; * &t;&t;      int addrcnt,&n; * &t;&t;      int flags);&n; *&n; * If sd is an IPv4 socket, the addresses passed must be IPv4 addresses.&n; * If the sd is an IPv6 socket, the addresses passed can either be IPv4&n; * or IPv6 addresses.&n; *&n; * A single address may be specified as INADDR_ANY or IPV6_ADDR_ANY, see&n; * section 3.1.2 for this usage.&n; *&n; * addrs is a pointer to an array of one or more socket addresses.  Each&n; * address is contained in a struct sockaddr_storage, so each address is&n; * fixed length. The caller specifies the number of addresses in the&n; * array with addrcnt.&n; *&n; * On success, sctp_bindx() returns 0. On failure, sctp_bindx() returns -1,&n; * and sets errno to the appropriate error code. [ Editor&squot;s note: need&n; * to fill in all error code? ]&n; *&n; * For SCTP, the port given in each socket address must be the same, or&n; * sctp_bindx() will fail, setting errno to EINVAL .&n; *&n; * The flags parameter is formed from the bitwise OR of zero or&n; * more of the following currently defined flags:&n; *&n; *     SCTP_BINDX_ADD_ADDR&n; *     SCTP_BINDX_REM_ADDR&n; *&n; * SCTP_BIND_ADD_ADDR directs SCTP to add the given addresses to the&n; * association, and SCTP_BIND_REM_ADDR directs SCTP to remove the given&n; * addresses from the association. The two flags are mutually exclusive;&n; * if both are given, sctp_bindx() will fail with EINVAL.  A caller may not&n; * remove all addresses from an association; sctp_bindx() will reject such&n; * an attempt with EINVAL.&n; *&n; * An application can use sctp_bindx(SCTP_BINDX_ADD_ADDR) to associate&n; * additional addresses with an endpoint after calling bind().  Or use&n; * sctp_bindx(SCTP_BINDX_REM_ADDR) to remove some addresses a listening&n; * socket is associated with so that no new association accepted will be&n; * associated with those addresses.&n; *&n; * SCTP_BIND_ADD_ADDR is defined as 0, so that it becomes the default&n; * behavior for sctp_bindx() when no flags are given.&n; *&n; * Adding and removing addresses from a connected association is optional&n; * functionality. Implementations that do not support this functionality&n; * should return EOPNOTSUPP.&n; *&n; * NOTE: This could be integrated into sctp_setsockopt_bindx(),&n; * but keeping it this way makes it easier if sometime sys_bindx is&n; * added.&n; */
multiline_comment|/* Unprotected by locks. Call only with socket lock sk-&gt;lock held! See&n; * sctp_bindx() for a lock-protected call.&n; */
DECL|function|__sctp_bindx
r_static
r_int
id|__sctp_bindx
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sockaddr_storage
op_star
id|addrs
comma
r_int
id|addrcnt
comma
r_int
id|flags
)paren
(brace
r_int
id|retval
op_assign
l_int|0
suffix:semicolon
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;__sctp_bindx(sk: %p, addrs: %p, addrcnt: %d, &quot;
l_string|&quot;flags: %s)&bslash;n&quot;
comma
id|sk
comma
id|addrs
comma
id|addrcnt
comma
(paren
id|BINDX_ADD_ADDR
op_eq
id|flags
)paren
ques
c_cond
l_string|&quot;ADD&quot;
suffix:colon
(paren
(paren
id|BINDX_REM_ADDR
op_eq
id|flags
)paren
ques
c_cond
l_string|&quot;REM&quot;
suffix:colon
l_string|&quot;BOGUS&quot;
)paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|flags
)paren
(brace
r_case
id|BINDX_ADD_ADDR
suffix:colon
id|retval
op_assign
id|sctp_bindx_add
c_func
(paren
id|sk
comma
id|addrs
comma
id|addrcnt
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BINDX_REM_ADDR
suffix:colon
id|retval
op_assign
id|sctp_bindx_rem
c_func
(paren
id|sk
comma
id|addrs
comma
id|addrcnt
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|retval
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
)brace
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/* BINDX with locks.&n; *&n; * NOTE: Currently unused at all ...&n; */
DECL|function|sctp_bindx
r_int
id|sctp_bindx
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sockaddr_storage
op_star
id|addrs
comma
r_int
id|addrcnt
comma
r_int
id|flags
)paren
(brace
r_int
id|retval
suffix:semicolon
id|sctp_lock_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
id|retval
op_assign
id|__sctp_bindx
c_func
(paren
id|sk
comma
id|addrs
comma
id|addrcnt
comma
id|flags
)paren
suffix:semicolon
id|sctp_release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/* Add a list of addresses as bind addresses to local endpoint or&n; * association.&n; *&n; * Basically run through each address specified in the addrs/addrcnt&n; * array/length pair, determine if it is IPv6 or IPv4 and call&n; * sctp_do_bind() on it.&n; *&n; * If any of them fails, then the operation will be reversed and the&n; * ones that were added will be removed.&n; *&n; * Only __sctp_bindx() is supposed to call this function.&n; */
DECL|function|sctp_bindx_add
r_int
id|sctp_bindx_add
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sockaddr_storage
op_star
id|addrs
comma
r_int
id|addrcnt
)paren
(brace
r_int
id|cnt
suffix:semicolon
r_int
id|retval
op_assign
l_int|0
suffix:semicolon
r_int
id|addr_len
suffix:semicolon
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;sctp_bindx_add (sk: %p, addrs: %p, addrcnt: %d)&bslash;n&quot;
comma
id|sk
comma
id|addrs
comma
id|addrcnt
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
suffix:semicolon
id|cnt
OL
id|addrcnt
suffix:semicolon
id|cnt
op_increment
)paren
(brace
multiline_comment|/* The list may contain either IPv4 or IPv6 address;&n;&t;&t; * determine the address length for walking thru the list.&n;&t;&t; */
r_switch
c_cond
(paren
(paren
(paren
r_struct
id|sockaddr
op_star
)paren
op_amp
id|addrs
(braket
id|cnt
)braket
)paren
op_member_access_from_pointer
id|sa_family
)paren
(brace
r_case
id|AF_INET
suffix:colon
id|addr_len
op_assign
r_sizeof
(paren
r_struct
id|sockaddr_in
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AF_INET6
suffix:colon
id|addr_len
op_assign
r_sizeof
(paren
r_struct
id|sockaddr_in6
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|retval
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|err_bindx_add
suffix:semicolon
)brace
suffix:semicolon
id|retval
op_assign
id|sctp_do_bind
c_func
(paren
id|sk
comma
(paren
r_union
id|sctp_addr
op_star
)paren
op_amp
id|addrs
(braket
id|cnt
)braket
comma
id|addr_len
)paren
suffix:semicolon
id|err_bindx_add
suffix:colon
r_if
c_cond
(paren
id|retval
OL
l_int|0
)paren
(brace
multiline_comment|/* Failed. Cleanup the ones that has been added */
r_if
c_cond
(paren
id|cnt
OG
l_int|0
)paren
id|sctp_bindx_rem
c_func
(paren
id|sk
comma
id|addrs
comma
id|cnt
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
)brace
multiline_comment|/* Notify the peer(s), assuming we have (an) association(s).&n;&t; * FIXME: for UDP, we have a 1-1-many mapping amongst sk, ep and asoc,&n;&t; *        so we don&squot;t have to do much work on locating associations.&n;&t; *&n;&t; * However, when the separation of ep and asoc kicks in, especially&n;&t; * for TCP style connection, it becomes n-1-n mapping.  We will need&n;&t; * to do more fine work.  Until then, hold my peace.&n;&t; *&t;&t;&t;&t;&t;&t;&t;--xguo&n;&t; *&n;&t; * Really, I don&squot;t think that will be a problem.  The bind()&n;&t; * call on a socket will either know the endpoint&n;&t; * (e.g. TCP-style listen()ing socket, or UDP-style socket),&n;&t; * or exactly one association.  The former case is EXACTLY&n;&t; * what we have now.  In the former case we know the&n;&t; * association already.&t;&t;&t;&t;&t;--piggy&n;&t; *&n;&t; * This code will be working on either a UDP style or a TCP style&n;&t; * socket, or say either an endpoint or an association. The socket&n;&t; * type verification code need to be added later before calling the&n;&t; * ADDIP code.&n;&t; * &t;&t;&t;&t;&t;&t;&t;--daisy&n;&t; */
macro_line|#if CONFIG_IP_SCTP_ADDIP
multiline_comment|/* Add these addresses to all associations on this endpoint.  */
r_if
c_cond
(paren
id|retval
op_ge
l_int|0
)paren
(brace
r_struct
id|list_head
op_star
id|pos
suffix:semicolon
id|sctp_endpoint_t
op_star
id|ep
suffix:semicolon
id|sctp_association_t
op_star
id|asoc
suffix:semicolon
id|ep
op_assign
id|sctp_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|ep
suffix:semicolon
id|list_for_each
c_func
(paren
id|pos
comma
op_amp
id|ep-&gt;asocs
)paren
(brace
id|asoc
op_assign
id|list_entry
c_func
(paren
id|pos
comma
id|sctp_association_t
comma
id|asocs
)paren
suffix:semicolon
id|sctp_addip_addr_config
c_func
(paren
id|asoc
comma
id|SCTP_PARAM_ADD_IP
comma
id|addrs
comma
id|addrcnt
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/* Remove a list of addresses from bind addresses list.  Do not remove the&n; * last address.&n; *&n; * Basically run through each address specified in the addrs/addrcnt&n; * array/length pair, determine if it is IPv6 or IPv4 and call&n; * sctp_del_bind() on it.&n; *&n; * If any of them fails, then the operation will be reversed and the&n; * ones that were removed will be added back.&n; *&n; * At least one address has to be left; if only one address is&n; * available, the operation will return -EBUSY.&n; *&n; * Only __sctp_bindx() is supposed to call this function.&n; */
DECL|function|sctp_bindx_rem
r_int
id|sctp_bindx_rem
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sockaddr_storage
op_star
id|addrs
comma
r_int
id|addrcnt
)paren
(brace
id|sctp_opt_t
op_star
id|sp
op_assign
id|sctp_sk
c_func
(paren
id|sk
)paren
suffix:semicolon
id|sctp_endpoint_t
op_star
id|ep
op_assign
id|sp-&gt;ep
suffix:semicolon
r_int
id|cnt
suffix:semicolon
id|sctp_bind_addr_t
op_star
id|bp
op_assign
op_amp
id|ep-&gt;base.bind_addr
suffix:semicolon
r_int
id|retval
op_assign
l_int|0
suffix:semicolon
r_union
id|sctp_addr
id|saveaddr
suffix:semicolon
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;sctp_bindx_rem (sk: %p, addrs: %p, addrcnt: %d)&bslash;n&quot;
comma
id|sk
comma
id|addrs
comma
id|addrcnt
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
suffix:semicolon
id|cnt
OL
id|addrcnt
suffix:semicolon
id|cnt
op_increment
)paren
(brace
multiline_comment|/* If there is only one bind address, there is nothing more&n;&t;&t; * to be removed (we need at least one address here).&n;&t;&t; */
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|bp-&gt;address_list
)paren
)paren
(brace
id|retval
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_goto
id|err_bindx_rem
suffix:semicolon
)brace
multiline_comment|/* The list may contain either IPv4 or IPv6 address;&n;&t;&t; * determine the address length for walking thru the list.&n;&t;&t; */
r_switch
c_cond
(paren
(paren
(paren
r_struct
id|sockaddr
op_star
)paren
op_amp
id|addrs
(braket
id|cnt
)braket
)paren
op_member_access_from_pointer
id|sa_family
)paren
(brace
r_case
id|AF_INET
suffix:colon
id|saveaddr
op_assign
op_star
(paren
(paren
r_union
id|sctp_addr
op_star
)paren
op_amp
id|addrs
(braket
id|cnt
)braket
)paren
suffix:semicolon
id|saveaddr.v4.sin_port
op_assign
id|ntohs
c_func
(paren
id|saveaddr.v4.sin_port
)paren
suffix:semicolon
multiline_comment|/* Verify the port.  */
r_if
c_cond
(paren
id|saveaddr.v4.sin_port
op_ne
id|bp-&gt;port
)paren
(brace
id|retval
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|err_bindx_rem
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|AF_INET6
suffix:colon
id|saveaddr
op_assign
op_star
(paren
(paren
r_union
id|sctp_addr
op_star
)paren
op_amp
id|addrs
(braket
id|cnt
)braket
)paren
suffix:semicolon
id|saveaddr.v6.sin6_port
op_assign
id|ntohs
c_func
(paren
id|saveaddr.v6.sin6_port
)paren
suffix:semicolon
multiline_comment|/* verify the port */
r_if
c_cond
(paren
id|saveaddr.v6.sin6_port
op_ne
id|bp-&gt;port
)paren
(brace
id|retval
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|err_bindx_rem
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|retval
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|err_bindx_rem
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* FIXME - There is probably a need to check if sk-&gt;saddr and&n;&t;&t; * sk-&gt;rcv_addr are currently set to one of the addresses to&n;&t;&t; * be removed. This is something which needs to be looked into&n;&t;&t; * when we are fixing the outstanding issues with multi-homing&n;&t;&t; * socket routing and failover schemes. Refer to comments in&n;&t;&t; * sctp_do_bind(). -daisy&n;&t;&t; */
id|sctp_local_bh_disable
c_func
(paren
)paren
suffix:semicolon
id|sctp_write_lock
c_func
(paren
op_amp
id|ep-&gt;base.addr_lock
)paren
suffix:semicolon
id|retval
op_assign
id|sctp_del_bind_addr
c_func
(paren
id|bp
comma
op_amp
id|saveaddr
)paren
suffix:semicolon
id|sctp_write_unlock
c_func
(paren
op_amp
id|ep-&gt;base.addr_lock
)paren
suffix:semicolon
id|sctp_local_bh_enable
c_func
(paren
)paren
suffix:semicolon
id|err_bindx_rem
suffix:colon
r_if
c_cond
(paren
id|retval
OL
l_int|0
)paren
(brace
multiline_comment|/* Failed. Add the ones that has been removed back */
r_if
c_cond
(paren
id|cnt
OG
l_int|0
)paren
id|sctp_bindx_add
c_func
(paren
id|sk
comma
id|addrs
comma
id|cnt
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * This code will be working on either a UDP style or a TCP style&n;&t; * socket, * or say either an endpoint or an association. The socket&n;&t; * type verification code need to be added later before calling the&n;&t; * ADDIP code.&n;&t; * &t;&t;&t;&t;&t;&t;&t;--daisy&n;&t; */
macro_line|#if CONFIG_IP_SCTP_ADDIP
multiline_comment|/* Remove these addresses from all associations on this endpoint.  */
r_if
c_cond
(paren
id|retval
op_ge
l_int|0
)paren
(brace
r_struct
id|list_head
op_star
id|pos
suffix:semicolon
id|sctp_endpoint_t
op_star
id|ep
suffix:semicolon
id|sctp_association_t
op_star
id|asoc
suffix:semicolon
id|ep
op_assign
id|sctp_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|ep
suffix:semicolon
id|list_for_each
c_func
(paren
id|pos
comma
op_amp
id|ep-&gt;asocs
)paren
(brace
id|asoc
op_assign
id|list_entry
c_func
(paren
id|pos
comma
id|sctp_association_t
comma
id|asocs
)paren
suffix:semicolon
id|sctp_addip_addr_config
c_func
(paren
id|asoc
comma
id|SCTP_PARAM_DEL_IP
comma
id|addrs
comma
id|addrcnt
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/* Helper for tunneling sys_bindx() requests through sctp_setsockopt()&n; *&n; * Basically do nothing but copying the addresses from user to kernel&n; * land and invoking sctp_bindx on the sk. This is used for tunneling&n; * the sctp_bindx() [sys_bindx()] request through sctp_setsockopt()&n; * from userspace.&n; *&n; * Note I don&squot;t use move_addr_to_kernel(): the reason is we would be&n; * iterating over an array of struct sockaddr_storage passing always&n; * what we know is a good size (sizeof (struct sock...)), so it is&n; * pointless. Instead check the whole area for read access and copy&n; * it.&n; *&n; * We don&squot;t use copy_from_user() for optimization: we first do the&n; * sanity checks (buffer size -fast- and access check-healthy&n; * pointer); if all of those succeed, then we can alloc the memory&n; * (expensive operation) needed to copy the data to kernel. Then we do&n; * the copying without checking the user space area&n; * (__copy_from_user()).&n; *&n; * On exit there is no need to do sockfd_put(), sys_setsockopt() does&n; * it.&n; *&n; * sk        The sk of the socket&n; * addrs     The pointer to the addresses in user land&n; * addrssize Size of the addrs buffer&n; * op        Operation to perform (add or remove, see the flags of&n; *           sctp_bindx)&n; *&n; * Returns 0 if ok, &lt;0 errno code on error.&n; */
DECL|function|sctp_setsockopt_bindx
id|SCTP_STATIC
r_int
id|sctp_setsockopt_bindx
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sockaddr_storage
op_star
id|addrs
comma
r_int
id|addrssize
comma
r_int
id|op
)paren
(brace
r_struct
id|sockaddr_storage
op_star
id|kaddrs
suffix:semicolon
r_int
id|err
suffix:semicolon
r_int
id|addrcnt
suffix:semicolon
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;sctp_do_setsocktopt_bindx: sk %p addrs %p&quot;
l_string|&quot; addrssize %d opt %d&bslash;n&quot;
comma
id|sk
comma
id|addrs
comma
id|addrssize
comma
id|op
)paren
suffix:semicolon
multiline_comment|/* Do we have an integer number of structs sockaddr_storage?  */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|addrssize
op_le
l_int|0
op_logical_or
id|addrssize
op_mod
r_sizeof
(paren
r_struct
id|sockaddr_storage
)paren
op_ne
l_int|0
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* Check the user passed a healthy pointer.  */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|access_ok
c_func
(paren
id|VERIFY_READ
comma
id|addrs
comma
id|addrssize
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
multiline_comment|/* Alloc space for the address array in kernel memory.  */
id|kaddrs
op_assign
(paren
r_struct
id|sockaddr_storage
op_star
)paren
id|kmalloc
c_func
(paren
id|addrssize
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
l_int|NULL
op_eq
id|kaddrs
)paren
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|kaddrs
comma
id|addrs
comma
id|addrssize
)paren
)paren
(brace
id|kfree
c_func
(paren
id|kaddrs
)paren
suffix:semicolon
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
id|addrcnt
op_assign
id|addrssize
op_div
r_sizeof
(paren
r_struct
id|sockaddr_storage
)paren
suffix:semicolon
id|err
op_assign
id|__sctp_bindx
c_func
(paren
id|sk
comma
id|kaddrs
comma
id|addrcnt
comma
id|op
)paren
suffix:semicolon
multiline_comment|/* Do the work. */
id|kfree
c_func
(paren
id|kaddrs
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/* API 3.1.4 close() - UDP Style Syntax&n; * Applications use close() to perform graceful shutdown (as described in&n; * Section 10.1 of [SCTP]) on ALL the associations currently represented&n; * by a UDP-style socket.&n; *&n; * The syntax is&n; *&n; *   ret = close(int sd);&n; *&n; *   sd      - the socket descriptor of the associations to be closed.&n; *&n; * To gracefully shutdown a specific association represented by the&n; * UDP-style socket, an application should use the sendmsg() call,&n; * passing no user data, but including the appropriate flag in the&n; * ancillary data (see Section xxxx).&n; *&n; * If sd in the close() call is a branched-off socket representing only&n; * one association, the shutdown is performed on that association only.&n; */
DECL|function|sctp_close
id|SCTP_STATIC
r_void
id|sctp_close
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|timeout
)paren
(brace
id|sctp_endpoint_t
op_star
id|ep
suffix:semicolon
id|sctp_association_t
op_star
id|asoc
suffix:semicolon
r_struct
id|list_head
op_star
id|pos
comma
op_star
id|temp
suffix:semicolon
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;sctp_close(sk: 0x%p...)&bslash;n&quot;
comma
id|sk
)paren
suffix:semicolon
id|sctp_lock_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
id|sk-&gt;shutdown
op_assign
id|SHUTDOWN_MASK
suffix:semicolon
id|ep
op_assign
id|sctp_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|ep
suffix:semicolon
multiline_comment|/* Walk all associations on a socket, not on an endpoint.  */
id|list_for_each_safe
c_func
(paren
id|pos
comma
id|temp
comma
op_amp
id|ep-&gt;asocs
)paren
(brace
id|asoc
op_assign
id|list_entry
c_func
(paren
id|pos
comma
id|sctp_association_t
comma
id|asocs
)paren
suffix:semicolon
id|sctp_primitive_SHUTDOWN
c_func
(paren
id|asoc
comma
l_int|NULL
)paren
suffix:semicolon
)brace
multiline_comment|/* Clean up any skbs sitting on the receive queue.  */
id|skb_queue_purge
c_func
(paren
op_amp
id|sk-&gt;receive_queue
)paren
suffix:semicolon
multiline_comment|/* This will run the backlog queue.  */
id|sctp_release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
multiline_comment|/* Supposedly, no process has access to the socket, but&n;&t; * the net layers still may.&n;&t; */
id|sctp_local_bh_disable
c_func
(paren
)paren
suffix:semicolon
id|sctp_bh_lock_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
multiline_comment|/* Hold the sock, since inet_sock_release() will put sock_put()&n;&t; * and we have just a little more cleanup.&n;&t; */
id|sock_hold
c_func
(paren
id|sk
)paren
suffix:semicolon
id|inet_sock_release
c_func
(paren
id|sk
)paren
suffix:semicolon
id|sctp_bh_unlock_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
id|sctp_local_bh_enable
c_func
(paren
)paren
suffix:semicolon
id|sock_put
c_func
(paren
id|sk
)paren
suffix:semicolon
id|SCTP_DBG_OBJCNT_DEC
c_func
(paren
id|sock
)paren
suffix:semicolon
)brace
multiline_comment|/* API 3.1.3 sendmsg() - UDP Style Syntax&n; *&n; * An application uses sendmsg() and recvmsg() calls to transmit data to&n; * and receive data from its peer.&n; *&n; *  ssize_t sendmsg(int socket, const struct msghdr *message,&n; *                  int flags);&n; *&n; *  socket  - the socket descriptor of the endpoint.&n; *  message - pointer to the msghdr structure which contains a single&n; *            user message and possibly some ancillary data.&n; *&n; *            See Section 5 for complete description of the data&n; *            structures.&n; *&n; *  flags   - flags sent or received with the user message, see Section&n; *            5 for complete description of the flags.&n; *&n; * Note:  This function could use a rewrite especially when explicit&n; * connect support comes in.&n; */
multiline_comment|/* BUG:  We do not implement the equivalent of wait_for_tcp_memory(). */
id|SCTP_STATIC
r_int
id|sctp_msghdr_parse
c_func
(paren
r_const
r_struct
id|msghdr
op_star
comma
id|sctp_cmsgs_t
op_star
)paren
suffix:semicolon
DECL|function|sctp_sendmsg
id|SCTP_STATIC
r_int
id|sctp_sendmsg
c_func
(paren
r_struct
id|kiocb
op_star
id|iocb
comma
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|msghdr
op_star
id|msg
comma
r_int
id|msg_len
)paren
(brace
id|sctp_opt_t
op_star
id|sp
suffix:semicolon
id|sctp_endpoint_t
op_star
id|ep
suffix:semicolon
id|sctp_association_t
op_star
id|new_asoc
op_assign
l_int|NULL
comma
op_star
id|asoc
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|sctp_transport
op_star
id|transport
suffix:semicolon
id|sctp_chunk_t
op_star
id|chunk
op_assign
l_int|NULL
suffix:semicolon
r_union
id|sctp_addr
id|to
suffix:semicolon
r_struct
id|sockaddr
op_star
id|msg_name
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|sctp_sndrcvinfo
id|default_sinfo
op_assign
(brace
l_int|0
)brace
suffix:semicolon
r_struct
id|sctp_sndrcvinfo
op_star
id|sinfo
suffix:semicolon
r_struct
id|sctp_initmsg
op_star
id|sinit
suffix:semicolon
id|sctp_assoc_t
id|associd
op_assign
l_int|NULL
suffix:semicolon
id|sctp_cmsgs_t
id|cmsgs
op_assign
(brace
l_int|0
)brace
suffix:semicolon
r_int
id|err
suffix:semicolon
id|sctp_scope_t
id|scope
suffix:semicolon
r_int
id|timeo
suffix:semicolon
id|__u16
id|sinfo_flags
op_assign
l_int|0
suffix:semicolon
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;sctp_sendmsg(sk: %p, msg: %p, msg_len: %d)&bslash;n&quot;
comma
id|sk
comma
id|msg
comma
id|msg_len
)paren
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
id|sp
op_assign
id|sctp_sk
c_func
(paren
id|sk
)paren
suffix:semicolon
id|ep
op_assign
id|sp-&gt;ep
suffix:semicolon
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;Using endpoint: %s.&bslash;n&quot;
comma
id|ep-&gt;debug_name
)paren
suffix:semicolon
multiline_comment|/* Parse out the SCTP CMSGs.  */
id|err
op_assign
id|sctp_msghdr_parse
c_func
(paren
id|msg
comma
op_amp
id|cmsgs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;msghdr parse err = %x&bslash;n&quot;
comma
id|err
)paren
suffix:semicolon
r_goto
id|out_nounlock
suffix:semicolon
)brace
multiline_comment|/* Fetch the destination address for this packet.  This&n;&t; * address only selects the association--it is not necessarily&n;&t; * the address we will send to.&n;&t; * For a peeled-off socket, msg_name is ignored.&n;&t; */
r_if
c_cond
(paren
(paren
id|SCTP_SOCKET_UDP_HIGH_BANDWIDTH
op_ne
id|sp-&gt;type
)paren
op_logical_and
id|msg-&gt;msg_name
)paren
(brace
r_int
id|msg_namelen
op_assign
id|msg-&gt;msg_namelen
suffix:semicolon
id|err
op_assign
id|sctp_verify_addr
c_func
(paren
id|sk
comma
(paren
r_union
id|sctp_addr
op_star
)paren
id|msg-&gt;msg_name
comma
id|msg_namelen
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
r_if
c_cond
(paren
id|msg_namelen
OG
r_sizeof
(paren
id|to
)paren
)paren
id|msg_namelen
op_assign
r_sizeof
(paren
id|to
)paren
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|to
comma
id|msg-&gt;msg_name
comma
id|msg_namelen
)paren
suffix:semicolon
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;Just memcpy&squot;d. msg_name is &quot;
l_string|&quot;0x%x:%u.&bslash;n&quot;
comma
id|to.v4.sin_addr.s_addr
comma
id|to.v4.sin_port
)paren
suffix:semicolon
id|to.v4.sin_port
op_assign
id|ntohs
c_func
(paren
id|to.v4.sin_port
)paren
suffix:semicolon
id|msg_name
op_assign
id|msg-&gt;msg_name
suffix:semicolon
)brace
id|sinfo
op_assign
id|cmsgs.info
suffix:semicolon
id|sinit
op_assign
id|cmsgs.init
suffix:semicolon
multiline_comment|/* Did the user specify SNDRCVINFO?  */
r_if
c_cond
(paren
id|sinfo
)paren
(brace
id|sinfo_flags
op_assign
id|sinfo-&gt;sinfo_flags
suffix:semicolon
id|associd
op_assign
id|sinfo-&gt;sinfo_assoc_id
suffix:semicolon
)brace
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;msg_len: %Zd, sinfo_flags: 0x%x&bslash;n&quot;
comma
id|msg_len
comma
id|sinfo_flags
)paren
suffix:semicolon
multiline_comment|/* If MSG_EOF is set, no data can be sent. Disallow sending zero&n;&t; * length messages when MSG_EOF|MSG_ABORT is not set.&n;&t; * If MSG_ABORT is set, the message length could be non zero with&n;&t; * the msg_iov set to the user abort reason.&n; &t; */
r_if
c_cond
(paren
(paren
(paren
id|sinfo_flags
op_amp
id|MSG_EOF
)paren
op_logical_and
(paren
id|msg_len
OG
l_int|0
)paren
)paren
op_logical_or
(paren
op_logical_neg
(paren
id|sinfo_flags
op_amp
(paren
id|MSG_EOF
op_or
id|MSG_ABORT
)paren
)paren
op_logical_and
(paren
id|msg_len
op_eq
l_int|0
)paren
)paren
)paren
(brace
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|out_nounlock
suffix:semicolon
)brace
id|sctp_lock_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
id|transport
op_assign
l_int|NULL
suffix:semicolon
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;About to look up association.&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* If a msg_name has been specified, assume this is to be used.  */
r_if
c_cond
(paren
id|msg_name
)paren
(brace
multiline_comment|/* Look for a matching association on the endpoint. */
id|asoc
op_assign
id|sctp_endpoint_lookup_assoc
c_func
(paren
id|ep
comma
op_amp
id|to
comma
op_amp
id|transport
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|asoc
)paren
(brace
multiline_comment|/* If we could not find a matching association on the&n;&t;&t;&t; * endpoint, make sure that there is no peeled-off&n;&t;&t;&t; * association on another socket.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|sctp_endpoint_is_peeled_off
c_func
(paren
id|ep
comma
op_amp
id|to
)paren
)paren
(brace
id|err
op_assign
op_minus
id|EADDRNOTAVAIL
suffix:semicolon
r_goto
id|out_unlock
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
multiline_comment|/* For a peeled-off socket, ignore any associd specified by&n;&t;&t; * the user with SNDRCVINFO.&n;&t;&t; */
r_if
c_cond
(paren
id|SCTP_SOCKET_UDP_HIGH_BANDWIDTH
op_eq
id|sp-&gt;type
)paren
(brace
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|ep-&gt;asocs
)paren
)paren
(brace
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|out_unlock
suffix:semicolon
)brace
id|asoc
op_assign
id|list_entry
c_func
(paren
id|ep-&gt;asocs.next
comma
id|sctp_association_t
comma
id|asocs
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|associd
)paren
(brace
id|asoc
op_assign
id|sctp_id2assoc
c_func
(paren
id|sk
comma
id|associd
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|asoc
)paren
(brace
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|out_unlock
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|asoc
)paren
(brace
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;Just looked up association: &quot;
l_string|&quot;%s. &bslash;n&quot;
comma
id|asoc-&gt;debug_name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sinfo_flags
op_amp
id|MSG_EOF
)paren
(brace
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;Shutting down association: %p&bslash;n&quot;
comma
id|asoc
)paren
suffix:semicolon
id|sctp_primitive_SHUTDOWN
c_func
(paren
id|asoc
comma
l_int|NULL
)paren
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
r_goto
id|out_unlock
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sinfo_flags
op_amp
id|MSG_ABORT
)paren
(brace
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;Aborting association: %p&bslash;n&quot;
comma
id|asoc
)paren
suffix:semicolon
id|sctp_primitive_ABORT
c_func
(paren
id|asoc
comma
id|msg
)paren
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
r_goto
id|out_unlock
suffix:semicolon
)brace
)brace
multiline_comment|/* Do we need to create the association?  */
r_if
c_cond
(paren
op_logical_neg
id|asoc
)paren
(brace
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;There is no association yet.&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Check for invalid stream against the stream counts,&n;&t;&t; * either the default or the user specified stream counts.&n;&t;&t; */
r_if
c_cond
(paren
id|sinfo
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|sinit
op_logical_or
(paren
id|sinit
op_logical_and
op_logical_neg
id|sinit-&gt;sinit_num_ostreams
)paren
)paren
(brace
multiline_comment|/* Check against the defaults. */
r_if
c_cond
(paren
id|sinfo-&gt;sinfo_stream
op_ge
id|sp-&gt;initmsg.sinit_num_ostreams
)paren
(brace
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|out_unlock
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* Check against the requested.  */
r_if
c_cond
(paren
id|sinfo-&gt;sinfo_stream
op_ge
id|sinit-&gt;sinit_num_ostreams
)paren
(brace
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|out_unlock
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;&t;&t; * API 3.1.2 bind() - UDP Style Syntax&n;&t;&t; * If a bind() or sctp_bindx() is not called prior to a&n;&t;&t; * sendmsg() call that initiates a new association, the&n;&t;&t; * system picks an ephemeral port and will choose an address&n;&t;&t; * set equivalent to binding with a wildcard address.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|ep-&gt;base.bind_addr.port
)paren
(brace
r_if
c_cond
(paren
id|sctp_autobind
c_func
(paren
id|sk
)paren
)paren
(brace
id|err
op_assign
op_minus
id|EAGAIN
suffix:semicolon
r_goto
id|out_unlock
suffix:semicolon
)brace
)brace
id|scope
op_assign
id|sctp_scope
c_func
(paren
op_amp
id|to
)paren
suffix:semicolon
id|new_asoc
op_assign
id|sctp_association_new
c_func
(paren
id|ep
comma
id|sk
comma
id|scope
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|new_asoc
)paren
(brace
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|out_unlock
suffix:semicolon
)brace
id|asoc
op_assign
id|new_asoc
suffix:semicolon
multiline_comment|/* If the SCTP_INIT ancillary data is specified, set all&n;&t;&t; * the association init values accordingly.&n;&t;&t; */
r_if
c_cond
(paren
id|sinit
)paren
(brace
r_if
c_cond
(paren
id|sinit-&gt;sinit_num_ostreams
)paren
(brace
id|asoc-&gt;c.sinit_num_ostreams
op_assign
id|sinit-&gt;sinit_num_ostreams
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sinit-&gt;sinit_max_instreams
)paren
(brace
id|asoc-&gt;c.sinit_max_instreams
op_assign
id|sinit-&gt;sinit_max_instreams
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sinit-&gt;sinit_max_attempts
)paren
(brace
id|asoc-&gt;max_init_attempts
op_assign
id|sinit-&gt;sinit_max_attempts
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sinit-&gt;sinit_max_init_timeo
)paren
(brace
id|asoc-&gt;max_init_timeo
op_assign
id|sinit-&gt;sinit_max_init_timeo
op_star
id|HZ
suffix:semicolon
)brace
)brace
multiline_comment|/* Prime the peer&squot;s transport structures.  */
id|transport
op_assign
id|sctp_assoc_add_peer
c_func
(paren
id|asoc
comma
op_amp
id|to
comma
id|GFP_KERNEL
)paren
suffix:semicolon
)brace
multiline_comment|/* ASSERT: we have a valid association at this point.  */
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;We have a valid association.&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* API 7.1.7, the sndbuf size per association bounds the&n;&t; * maximum size of data that can be sent in a single send call.&n;&t; */
r_if
c_cond
(paren
id|msg_len
OG
id|sk-&gt;sndbuf
)paren
(brace
id|err
op_assign
op_minus
id|EMSGSIZE
suffix:semicolon
r_goto
id|out_free
suffix:semicolon
)brace
multiline_comment|/* FIXME: In the current implementation, a single chunk is created&n;&t; * for the entire message initially, even if it has to be fragmented&n;&t; * later.  As the length field in the chunkhdr is used to set&n;&t; * the chunk length, the maximum size of the chunk and hence the&n;&t; * message is limited by its type(__u16).&n;&t; * The real fix is to fragment the message before creating the chunks.&n;&t; */
r_if
c_cond
(paren
id|msg_len
OG
(paren
(paren
id|__u16
)paren
(paren
op_complement
(paren
id|__u16
)paren
l_int|0
)paren
op_minus
id|WORD_ROUND
c_func
(paren
r_sizeof
(paren
id|sctp_data_chunk_t
)paren
op_plus
l_int|1
)paren
)paren
)paren
(brace
id|err
op_assign
op_minus
id|EMSGSIZE
suffix:semicolon
r_goto
id|out_free
suffix:semicolon
)brace
multiline_comment|/* If fragmentation is disabled and the message length exceeds the&n;&t; * association fragmentation point, return EMSGSIZE.  The I-D&n;&t; * does not specify what this error is, but this looks like&n;&t; * a great fit.&n;&t; */
r_if
c_cond
(paren
id|sctp_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|disable_fragments
op_logical_and
(paren
id|msg_len
OG
id|asoc-&gt;frag_point
)paren
)paren
(brace
id|err
op_assign
op_minus
id|EMSGSIZE
suffix:semicolon
r_goto
id|out_free
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sinfo
)paren
(brace
multiline_comment|/* Check for invalid stream. */
r_if
c_cond
(paren
id|sinfo-&gt;sinfo_stream
op_ge
id|asoc-&gt;c.sinit_num_ostreams
)paren
(brace
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|out_free
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* If the user didn&squot;t specify SNDRCVINFO, make up one with&n;&t;&t; * some defaults.&n;&t;&t; */
id|default_sinfo.sinfo_stream
op_assign
id|asoc-&gt;defaults.stream
suffix:semicolon
id|default_sinfo.sinfo_ppid
op_assign
id|asoc-&gt;defaults.ppid
suffix:semicolon
id|sinfo
op_assign
op_amp
id|default_sinfo
suffix:semicolon
)brace
id|timeo
op_assign
id|sock_sndtimeo
c_func
(paren
id|sk
comma
id|msg-&gt;msg_flags
op_amp
id|MSG_DONTWAIT
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sctp_wspace
c_func
(paren
id|asoc
)paren
)paren
(brace
id|err
op_assign
id|sctp_wait_for_sndbuf
c_func
(paren
id|asoc
comma
op_amp
id|timeo
comma
id|msg_len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out_free
suffix:semicolon
)brace
multiline_comment|/* Get enough memory for the whole message.  */
id|chunk
op_assign
id|sctp_make_data_empty
c_func
(paren
id|asoc
comma
id|sinfo
comma
id|msg_len
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|chunk
)paren
(brace
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|out_free
suffix:semicolon
)brace
macro_line|#if 0
multiline_comment|/* FIXME: This looks wrong so I&squot;ll comment out.&n;&t; * We should be able to use this same technique for&n;&t; * primary address override!  --jgrimm&n;&t; */
multiline_comment|/* If the user gave us an address, copy it in.  */
r_if
c_cond
(paren
id|msg-&gt;msg_name
)paren
(brace
id|chunk-&gt;transport
op_assign
id|sctp_assoc_lookup_paddr
c_func
(paren
id|asoc
comma
op_amp
id|to
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|chunk-&gt;transport
)paren
(brace
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|out_free
suffix:semicolon
)brace
)brace
macro_line|#endif /* 0 */
multiline_comment|/* Copy the message from the user.  */
id|err
op_assign
id|sctp_user_addto_chunk
c_func
(paren
id|chunk
comma
id|msg_len
comma
id|msg-&gt;msg_iov
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_goto
id|out_free
suffix:semicolon
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;Copied message to chunk: %p.&bslash;n&quot;
comma
id|chunk
)paren
suffix:semicolon
multiline_comment|/* Put the chunk-&gt;skb back into the form expected by send.  */
id|__skb_pull
c_func
(paren
id|chunk-&gt;skb
comma
(paren
id|__u8
op_star
)paren
id|chunk-&gt;chunk_hdr
op_minus
(paren
id|__u8
op_star
)paren
id|chunk-&gt;skb-&gt;data
)paren
suffix:semicolon
multiline_comment|/* Do accounting for the write space.  */
id|sctp_set_owner_w
c_func
(paren
id|chunk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SCTP_STATE_CLOSED
op_eq
id|asoc-&gt;state
)paren
(brace
id|err
op_assign
id|sctp_primitive_ASSOCIATE
c_func
(paren
id|asoc
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_goto
id|out_free
suffix:semicolon
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;We associated primitively.&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* Send it to the lower layers.  */
id|err
op_assign
id|sctp_primitive_SEND
c_func
(paren
id|asoc
comma
id|chunk
)paren
suffix:semicolon
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;We sent primitively.&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* BUG: SCTP_CHECK_TIMER(sk); */
r_if
c_cond
(paren
op_logical_neg
id|err
)paren
(brace
id|err
op_assign
id|msg_len
suffix:semicolon
r_goto
id|out_unlock
suffix:semicolon
)brace
multiline_comment|/* If we are already past ASSOCIATE, the lower&n;&t; * layers are responsible for its cleanup.&n;&t; */
r_goto
id|out_free_chunk
suffix:semicolon
id|out_free
suffix:colon
r_if
c_cond
(paren
id|new_asoc
)paren
id|sctp_association_free
c_func
(paren
id|asoc
)paren
suffix:semicolon
id|out_free_chunk
suffix:colon
r_if
c_cond
(paren
id|chunk
)paren
id|sctp_free_chunk
c_func
(paren
id|chunk
)paren
suffix:semicolon
id|out_unlock
suffix:colon
id|sctp_release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
id|out_nounlock
suffix:colon
r_return
id|err
suffix:semicolon
macro_line|#if 0
id|do_sock_err
suffix:colon
r_if
c_cond
(paren
id|msg_len
)paren
id|err
op_assign
id|msg_len
suffix:semicolon
r_else
id|err
op_assign
id|sock_error
c_func
(paren
id|sk
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
id|do_interrupted
suffix:colon
r_if
c_cond
(paren
id|msg_len
)paren
id|err
op_assign
id|msg_len
suffix:semicolon
r_goto
id|out
suffix:semicolon
macro_line|#endif /* 0 */
)brace
multiline_comment|/* This is an extended version of skb_pull() that removes the data from the&n; * start of a skb even when data is spread across the list of skb&squot;s in the&n; * frag_list. len specifies the total amount of data that needs to be removed.&n; * when &squot;len&squot; bytes could be removed from the skb, it returns 0.&n; * If &squot;len&squot; exceeds the total skb length,  it returns the no. of bytes that&n; * could not be removed.&n; */
DECL|function|sctp_skb_pull
r_static
r_int
id|sctp_skb_pull
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|len
)paren
(brace
r_struct
id|sk_buff
op_star
id|list
suffix:semicolon
r_int
id|skb_len
op_assign
id|skb_headlen
c_func
(paren
id|skb
)paren
suffix:semicolon
r_int
id|rlen
suffix:semicolon
r_if
c_cond
(paren
id|len
op_le
id|skb_len
)paren
(brace
id|__skb_pull
c_func
(paren
id|skb
comma
id|len
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|len
op_sub_assign
id|skb_len
suffix:semicolon
id|__skb_pull
c_func
(paren
id|skb
comma
id|skb_len
)paren
suffix:semicolon
r_for
c_loop
(paren
id|list
op_assign
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|frag_list
suffix:semicolon
id|list
suffix:semicolon
id|list
op_assign
id|list-&gt;next
)paren
(brace
id|rlen
op_assign
id|sctp_skb_pull
c_func
(paren
id|list
comma
id|len
)paren
suffix:semicolon
id|skb-&gt;len
op_sub_assign
(paren
id|len
op_minus
id|rlen
)paren
suffix:semicolon
id|skb-&gt;data_len
op_sub_assign
(paren
id|len
op_minus
id|rlen
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rlen
)paren
r_return
l_int|0
suffix:semicolon
id|len
op_assign
id|rlen
suffix:semicolon
)brace
r_return
id|len
suffix:semicolon
)brace
multiline_comment|/* API 3.1.3  recvmsg() - UDP Style Syntax&n; *&n; *  ssize_t recvmsg(int socket, struct msghdr *message,&n; *                    int flags);&n; *&n; *  socket  - the socket descriptor of the endpoint.&n; *  message - pointer to the msghdr structure which contains a single&n; *            user message and possibly some ancillary data.&n; *&n; *            See Section 5 for complete description of the data&n; *            structures.&n; *&n; *  flags   - flags sent or received with the user message, see Section&n; *            5 for complete description of the flags.&n; */
r_static
r_struct
id|sk_buff
op_star
id|sctp_skb_recv_datagram
c_func
(paren
r_struct
id|sock
op_star
comma
r_int
comma
r_int
comma
r_int
op_star
)paren
suffix:semicolon
DECL|function|sctp_recvmsg
id|SCTP_STATIC
r_int
id|sctp_recvmsg
c_func
(paren
r_struct
id|kiocb
op_star
id|iocb
comma
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|msghdr
op_star
id|msg
comma
r_int
id|len
comma
r_int
id|noblock
comma
r_int
id|flags
comma
r_int
op_star
id|addr_len
)paren
(brace
id|sctp_ulpevent_t
op_star
id|event
op_assign
l_int|NULL
suffix:semicolon
id|sctp_opt_t
op_star
id|sp
op_assign
id|sctp_sk
c_func
(paren
id|sk
)paren
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_int
id|copied
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
r_int
id|skb_len
suffix:semicolon
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;sctp_recvmsg(&quot;
l_string|&quot;%s: %p, %s: %p, %s: %d, %s: %d, %s: &quot;
l_string|&quot;0x%x, %s: %p)&bslash;n&quot;
comma
l_string|&quot;sk&quot;
comma
id|sk
comma
l_string|&quot;msghdr&quot;
comma
id|msg
comma
l_string|&quot;len&quot;
comma
id|len
comma
l_string|&quot;knoblauch&quot;
comma
id|noblock
comma
l_string|&quot;flags&quot;
comma
id|flags
comma
l_string|&quot;addr_len&quot;
comma
id|addr_len
)paren
suffix:semicolon
id|sctp_lock_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
id|skb
op_assign
id|sctp_skb_recv_datagram
c_func
(paren
id|sk
comma
id|flags
comma
id|noblock
comma
op_amp
id|err
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skb
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* Get the total length of the skb including any skb&squot;s in the&n;&t; * frag_list.&n;&t; */
id|skb_len
op_assign
id|skb-&gt;len
suffix:semicolon
id|copied
op_assign
id|skb_len
suffix:semicolon
r_if
c_cond
(paren
id|copied
OG
id|len
)paren
id|copied
op_assign
id|len
suffix:semicolon
id|err
op_assign
id|skb_copy_datagram_iovec
c_func
(paren
id|skb
comma
l_int|0
comma
id|msg-&gt;msg_iov
comma
id|copied
)paren
suffix:semicolon
id|event
op_assign
(paren
id|sctp_ulpevent_t
op_star
)paren
id|skb-&gt;cb
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out_free
suffix:semicolon
id|sock_recv_timestamp
c_func
(paren
id|msg
comma
id|sk
comma
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sctp_ulpevent_is_notification
c_func
(paren
id|event
)paren
)paren
(brace
id|msg-&gt;msg_flags
op_or_assign
id|MSG_NOTIFICATION
suffix:semicolon
id|sp-&gt;pf
op_member_access_from_pointer
id|event_msgname
c_func
(paren
id|event
comma
id|msg-&gt;msg_name
comma
id|addr_len
)paren
suffix:semicolon
)brace
r_else
(brace
id|sp-&gt;pf
op_member_access_from_pointer
id|skb_msgname
c_func
(paren
id|skb
comma
id|msg-&gt;msg_name
comma
id|addr_len
)paren
suffix:semicolon
)brace
multiline_comment|/* Check if we allow SCTP_SNDRCVINFO. */
r_if
c_cond
(paren
id|sp-&gt;subscribe.sctp_data_io_event
)paren
id|sctp_ulpevent_read_sndrcvinfo
c_func
(paren
id|event
comma
id|msg
)paren
suffix:semicolon
macro_line|#if 0
multiline_comment|/* FIXME: we should be calling IP/IPv6 layers.  */
r_if
c_cond
(paren
id|sk-&gt;protinfo.af_inet.cmsg_flags
)paren
id|ip_cmsg_recv
c_func
(paren
id|msg
comma
id|skb
)paren
suffix:semicolon
macro_line|#endif
id|err
op_assign
id|copied
suffix:semicolon
multiline_comment|/* If skb&squot;s length exceeds the user&squot;s buffer, update the skb and&n;&t; * push it back to the receive_queue so that the next call to&n;&t; * recvmsg() will return the remaining data. Don&squot;t set MSG_EOR.&n;&t; * Otherwise, set MSG_EOR indicating the end of a message.&n;&t; */
r_if
c_cond
(paren
id|skb_len
OG
id|copied
)paren
(brace
id|msg-&gt;msg_flags
op_and_assign
op_complement
id|MSG_EOR
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|MSG_PEEK
)paren
r_goto
id|out_free
suffix:semicolon
id|sctp_skb_pull
c_func
(paren
id|skb
comma
id|copied
)paren
suffix:semicolon
id|skb_queue_head
c_func
(paren
op_amp
id|sk-&gt;receive_queue
comma
id|skb
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_else
(brace
id|msg-&gt;msg_flags
op_or_assign
id|MSG_EOR
suffix:semicolon
)brace
id|out_free
suffix:colon
id|sctp_ulpevent_free
c_func
(paren
id|event
)paren
suffix:semicolon
multiline_comment|/* Free the skb. */
id|out
suffix:colon
id|sctp_release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|function|sctp_setsockopt_disable_fragments
r_static
r_inline
r_int
id|sctp_setsockopt_disable_fragments
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_char
op_star
id|optval
comma
r_int
id|optlen
)paren
(brace
r_int
id|val
suffix:semicolon
r_if
c_cond
(paren
id|optlen
OL
r_sizeof
(paren
r_int
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|optval
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|sctp_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|disable_fragments
op_assign
(paren
id|val
op_eq
l_int|0
)paren
ques
c_cond
l_int|0
suffix:colon
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|sctp_setsockopt_set_events
r_static
r_inline
r_int
id|sctp_setsockopt_set_events
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_char
op_star
id|optval
comma
r_int
id|optlen
)paren
(brace
r_if
c_cond
(paren
id|optlen
op_ne
r_sizeof
(paren
r_struct
id|sctp_event_subscribe
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|sctp_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|subscribe
comma
id|optval
comma
id|optlen
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|sctp_setsockopt_autoclose
r_static
r_inline
r_int
id|sctp_setsockopt_autoclose
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_char
op_star
id|optval
comma
r_int
id|optlen
)paren
(brace
id|sctp_opt_t
op_star
id|sp
op_assign
id|sctp_sk
c_func
(paren
id|sk
)paren
suffix:semicolon
multiline_comment|/* Applicable to UDP-style socket only */
r_if
c_cond
(paren
id|SCTP_SOCKET_TCP
op_eq
id|sp-&gt;type
)paren
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
r_if
c_cond
(paren
id|optlen
op_ne
r_sizeof
(paren
r_int
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|sp-&gt;autoclose
comma
id|optval
comma
id|optlen
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|sp-&gt;ep-&gt;timeouts
(braket
id|SCTP_EVENT_TIMEOUT_AUTOCLOSE
)braket
op_assign
id|sp-&gt;autoclose
op_star
id|HZ
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|sctp_setsockopt_set_peer_addr_params
r_static
r_inline
r_int
id|sctp_setsockopt_set_peer_addr_params
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_char
op_star
id|optval
comma
r_int
id|optlen
)paren
(brace
r_struct
id|sctp_paddrparams
id|params
suffix:semicolon
id|sctp_association_t
op_star
id|asoc
suffix:semicolon
r_union
id|sctp_addr
op_star
id|addr
suffix:semicolon
r_struct
id|sctp_transport
op_star
id|trans
suffix:semicolon
r_int
id|error
suffix:semicolon
r_if
c_cond
(paren
id|optlen
op_ne
r_sizeof
(paren
r_struct
id|sctp_paddrparams
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|params
comma
id|optval
comma
id|optlen
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|asoc
op_assign
id|sctp_id2assoc
c_func
(paren
id|sk
comma
id|params.spp_assoc_id
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|asoc
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|addr
op_assign
(paren
r_union
id|sctp_addr
op_star
)paren
op_amp
(paren
id|params.spp_address
)paren
suffix:semicolon
id|trans
op_assign
id|sctp_assoc_lookup_paddr
c_func
(paren
id|asoc
comma
id|addr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|trans
)paren
r_return
op_minus
id|ENOENT
suffix:semicolon
multiline_comment|/* Applications can enable or disable heartbeats for any peer address&n;&t; * of an association, modify an address&squot;s heartbeat interval, force a&n;&t; * heartbeat to be sent immediately, and adjust the address&squot;s maximum&n;&t; * number of retransmissions sent before an address is considered&n;&t; * unreachable.&n;&t; *&n;&t; * The value of the heartbeat interval, in milliseconds. A value of&n;&t; * UINT32_MAX (4294967295), when modifying the parameter, specifies&n;&t; * that a heartbeat should be sent immediately to the peer address,&n;&t; * and the current interval should remain unchanged.&n;&t; */
r_if
c_cond
(paren
l_int|0xffffffff
op_eq
id|params.spp_hbinterval
)paren
(brace
id|error
op_assign
id|sctp_primitive_REQUESTHEARTBEAT
(paren
id|asoc
comma
id|trans
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* The value of the heartbeat interval, in milliseconds. A value of 0,&n;&t; * when modifying the parameter, specifies that the heartbeat on this&n;&t; * address should be disabled.&n;&t; */
r_if
c_cond
(paren
id|params.spp_hbinterval
)paren
(brace
id|trans-&gt;hb_allowed
op_assign
l_int|1
suffix:semicolon
id|trans-&gt;hb_interval
op_assign
id|params.spp_hbinterval
op_star
id|HZ
op_div
l_int|1000
suffix:semicolon
)brace
r_else
id|trans-&gt;hb_allowed
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* spp_pathmaxrxt contains the maximum number of retransmissions&n;&t; * before this address shall be considered unreachable.&n;&t; */
id|trans-&gt;error_threshold
op_assign
id|params.spp_pathmaxrxt
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|sctp_setsockopt_initmsg
r_static
r_inline
r_int
id|sctp_setsockopt_initmsg
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_char
op_star
id|optval
comma
r_int
id|optlen
)paren
(brace
r_if
c_cond
(paren
id|optlen
op_ne
r_sizeof
(paren
r_struct
id|sctp_initmsg
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|sctp_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|initmsg
comma
id|optval
comma
id|optlen
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* API 6.2 setsockopt(), getsockopt()&n; *&n; * Applications use setsockopt() and getsockopt() to set or retrieve&n; * socket options.  Socket options are used to change the default&n; * behavior of sockets calls.  They are described in Section 7.&n; *&n; * The syntax is:&n; *&n; *   ret = getsockopt(int sd, int level, int optname, void *optval,&n; *                    int *optlen);&n; *   ret = setsockopt(int sd, int level, int optname, const void *optval,&n; *                    int optlen);&n; *&n; *   sd      - the socket descript.&n; *   level   - set to IPPROTO_SCTP for all SCTP options.&n; *   optname - the option name.&n; *   optval  - the buffer to store the value of the option.&n; *   optlen  - the size of the buffer.&n; */
DECL|function|sctp_setsockopt
id|SCTP_STATIC
r_int
id|sctp_setsockopt
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|level
comma
r_int
id|optname
comma
r_char
op_star
id|optval
comma
r_int
id|optlen
)paren
(brace
r_int
id|retval
op_assign
l_int|0
suffix:semicolon
r_char
op_star
id|tmp
suffix:semicolon
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;sctp_setsockopt(sk: %p... optname: %d)&bslash;n&quot;
comma
id|sk
comma
id|optname
)paren
suffix:semicolon
multiline_comment|/* I can hardly begin to describe how wrong this is.  This is&n;&t; * so broken as to be worse than useless.  The API draft&n;&t; * REALLY is NOT helpful here...  I am not convinced that the&n;&t; * semantics of setsockopt() with a level OTHER THAN SOL_SCTP&n;&t; * are at all well-founded.&n;&t; */
r_if
c_cond
(paren
id|level
op_ne
id|SOL_SCTP
)paren
(brace
r_struct
id|sctp_af
op_star
id|af
op_assign
id|sctp_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|pf-&gt;af
suffix:semicolon
id|retval
op_assign
id|af
op_member_access_from_pointer
id|setsockopt
c_func
(paren
id|sk
comma
id|level
comma
id|optname
comma
id|optval
comma
id|optlen
)paren
suffix:semicolon
r_goto
id|out_nounlock
suffix:semicolon
)brace
id|sctp_lock_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|optname
)paren
(brace
r_case
id|SCTP_SOCKOPT_DEBUG_NAME
suffix:colon
multiline_comment|/* BUG! we don&squot;t ever seem to free this memory. --jgrimm */
r_if
c_cond
(paren
l_int|NULL
op_eq
(paren
id|tmp
op_assign
id|kmalloc
c_func
(paren
id|optlen
op_plus
l_int|1
comma
id|GFP_KERNEL
)paren
)paren
)paren
(brace
id|retval
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|out_unlock
suffix:semicolon
)brace
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|tmp
comma
id|optval
comma
id|optlen
)paren
)paren
(brace
id|retval
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
id|out_unlock
suffix:semicolon
)brace
id|tmp
(braket
id|optlen
)braket
op_assign
l_char|&squot;&bslash;000&squot;
suffix:semicolon
id|sctp_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|ep-&gt;debug_name
op_assign
id|tmp
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_SOCKOPT_BINDX_ADD
suffix:colon
multiline_comment|/* &squot;optlen&squot; is the size of the addresses buffer. */
id|retval
op_assign
id|sctp_setsockopt_bindx
c_func
(paren
id|sk
comma
(paren
r_struct
id|sockaddr_storage
op_star
)paren
id|optval
comma
id|optlen
comma
id|BINDX_ADD_ADDR
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_SOCKOPT_BINDX_REM
suffix:colon
multiline_comment|/* &squot;optlen&squot; is the size of the addresses buffer. */
id|retval
op_assign
id|sctp_setsockopt_bindx
c_func
(paren
id|sk
comma
(paren
r_struct
id|sockaddr_storage
op_star
)paren
id|optval
comma
id|optlen
comma
id|BINDX_REM_ADDR
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_DISABLE_FRAGMENTS
suffix:colon
id|retval
op_assign
id|sctp_setsockopt_disable_fragments
c_func
(paren
id|sk
comma
id|optval
comma
id|optlen
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_SET_EVENTS
suffix:colon
id|retval
op_assign
id|sctp_setsockopt_set_events
c_func
(paren
id|sk
comma
id|optval
comma
id|optlen
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_AUTOCLOSE
suffix:colon
id|retval
op_assign
id|sctp_setsockopt_autoclose
c_func
(paren
id|sk
comma
id|optval
comma
id|optlen
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_SET_PEER_ADDR_PARAMS
suffix:colon
id|retval
op_assign
id|sctp_setsockopt_set_peer_addr_params
c_func
(paren
id|sk
comma
id|optval
comma
id|optlen
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_INITMSG
suffix:colon
id|retval
op_assign
id|sctp_setsockopt_initmsg
c_func
(paren
id|sk
comma
id|optval
comma
id|optlen
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|retval
op_assign
op_minus
id|ENOPROTOOPT
suffix:semicolon
r_break
suffix:semicolon
)brace
suffix:semicolon
id|out_unlock
suffix:colon
id|sctp_release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
id|out_nounlock
suffix:colon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/* API 3.1.6 connect() - UDP Style Syntax&n; *&n; * An application may use the connect() call in the UDP model to initiate an&n; * association without sending data.&n; *&n; * The syntax is:&n; *&n; * ret = connect(int sd, const struct sockaddr *nam, socklen_t len);&n; *&n; * sd: the socket descriptor to have a new association added to.&n; *&n; * nam: the address structure (either struct sockaddr_in or struct&n; *    sockaddr_in6 defined in RFC2553 [7]).&n; *&n; * len: the size of the address.&n; */
DECL|function|sctp_connect
id|SCTP_STATIC
r_int
id|sctp_connect
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sockaddr
op_star
id|uaddr
comma
r_int
id|addr_len
)paren
(brace
id|sctp_opt_t
op_star
id|sp
suffix:semicolon
id|sctp_endpoint_t
op_star
id|ep
suffix:semicolon
id|sctp_association_t
op_star
id|asoc
suffix:semicolon
r_struct
id|sctp_transport
op_star
id|transport
suffix:semicolon
r_union
id|sctp_addr
id|to
suffix:semicolon
id|sctp_scope_t
id|scope
suffix:semicolon
r_int
id|timeo
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
id|sctp_lock_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;%s - sk: %p, sockaddr: %p, addr_len: %d)&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|sk
comma
id|uaddr
comma
id|addr_len
)paren
suffix:semicolon
id|sp
op_assign
id|sctp_sk
c_func
(paren
id|sk
)paren
suffix:semicolon
id|ep
op_assign
id|sp-&gt;ep
suffix:semicolon
multiline_comment|/* connect() cannot be done on a peeled-off socket. */
r_if
c_cond
(paren
id|SCTP_SOCKET_UDP_HIGH_BANDWIDTH
op_eq
id|sp-&gt;type
)paren
(brace
id|err
op_assign
op_minus
id|EISCONN
suffix:semicolon
r_goto
id|out_unlock
suffix:semicolon
)brace
id|err
op_assign
id|sctp_verify_addr
c_func
(paren
id|sk
comma
(paren
r_union
id|sctp_addr
op_star
)paren
id|uaddr
comma
id|addr_len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out_unlock
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|to
comma
id|uaddr
comma
id|addr_len
)paren
suffix:semicolon
id|to.v4.sin_port
op_assign
id|ntohs
c_func
(paren
id|to.v4.sin_port
)paren
suffix:semicolon
id|asoc
op_assign
id|sctp_endpoint_lookup_assoc
c_func
(paren
id|ep
comma
op_amp
id|to
comma
op_amp
id|transport
)paren
suffix:semicolon
r_if
c_cond
(paren
id|asoc
)paren
(brace
r_if
c_cond
(paren
id|asoc-&gt;state
op_ge
id|SCTP_STATE_ESTABLISHED
)paren
id|err
op_assign
op_minus
id|EISCONN
suffix:semicolon
r_else
id|err
op_assign
op_minus
id|EALREADY
suffix:semicolon
r_goto
id|out_unlock
suffix:semicolon
)brace
multiline_comment|/* If we could not find a matching association on the endpoint,&n;&t; * make sure that there is no peeled-off association matching the&n;&t; * peer address even on another socket.&n;&t; */
r_if
c_cond
(paren
id|sctp_endpoint_is_peeled_off
c_func
(paren
id|ep
comma
op_amp
id|to
)paren
)paren
(brace
id|err
op_assign
op_minus
id|EADDRNOTAVAIL
suffix:semicolon
r_goto
id|out_unlock
suffix:semicolon
)brace
multiline_comment|/* If a bind() or sctp_bindx() is not called prior to a connect()&n;&t; * call, the system picks an ephemeral port and will choose an address&n;&t; * set equivalent to binding with a wildcard address.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|ep-&gt;base.bind_addr.port
)paren
(brace
r_if
c_cond
(paren
id|sctp_autobind
c_func
(paren
id|sk
)paren
)paren
(brace
id|err
op_assign
op_minus
id|EAGAIN
suffix:semicolon
r_goto
id|out_unlock
suffix:semicolon
)brace
)brace
id|scope
op_assign
id|sctp_scope
c_func
(paren
op_amp
id|to
)paren
suffix:semicolon
id|asoc
op_assign
id|sctp_association_new
c_func
(paren
id|ep
comma
id|sk
comma
id|scope
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|asoc
)paren
(brace
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|out_unlock
suffix:semicolon
)brace
multiline_comment|/* Prime the peer&squot;s transport structures.  */
id|transport
op_assign
id|sctp_assoc_add_peer
c_func
(paren
id|asoc
comma
op_amp
id|to
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|err
op_assign
id|sctp_primitive_ASSOCIATE
c_func
(paren
id|asoc
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
(brace
id|sctp_association_free
c_func
(paren
id|asoc
)paren
suffix:semicolon
r_goto
id|out_unlock
suffix:semicolon
)brace
id|timeo
op_assign
id|sock_sndtimeo
c_func
(paren
id|sk
comma
id|sk-&gt;socket-&gt;file-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
suffix:semicolon
id|err
op_assign
id|sctp_wait_for_connect
c_func
(paren
id|asoc
comma
op_amp
id|timeo
)paren
suffix:semicolon
id|out_unlock
suffix:colon
id|sctp_release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/* FIXME: Write comments. */
DECL|function|sctp_disconnect
id|SCTP_STATIC
r_int
id|sctp_disconnect
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|flags
)paren
(brace
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
multiline_comment|/* STUB */
)brace
multiline_comment|/* FIXME: Write comments. */
DECL|function|sctp_accept
id|SCTP_STATIC
r_struct
id|sock
op_star
id|sctp_accept
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|flags
comma
r_int
op_star
id|err
)paren
(brace
r_int
id|error
op_assign
op_minus
id|EOPNOTSUPP
suffix:semicolon
op_star
id|err
op_assign
id|error
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* FIXME: Write Comments. */
DECL|function|sctp_ioctl
id|SCTP_STATIC
r_int
id|sctp_ioctl
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
multiline_comment|/* STUB */
)brace
multiline_comment|/* This is the function which gets called during socket creation to&n; * initialized the SCTP-specific portion of the sock.&n; * The sock structure should already be zero-filled memory.&n; */
DECL|function|sctp_init_sock
id|SCTP_STATIC
r_int
id|sctp_init_sock
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
id|sctp_endpoint_t
op_star
id|ep
suffix:semicolon
id|sctp_protocol_t
op_star
id|proto
suffix:semicolon
id|sctp_opt_t
op_star
id|sp
suffix:semicolon
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;sctp_init_sock(sk: %p)&bslash;n&quot;
comma
id|sk
)paren
suffix:semicolon
id|proto
op_assign
id|sctp_get_protocol
c_func
(paren
)paren
suffix:semicolon
id|sp
op_assign
id|sctp_sk
c_func
(paren
id|sk
)paren
suffix:semicolon
multiline_comment|/* Initialize the SCTP per socket area.  */
id|sp-&gt;type
op_assign
id|SCTP_SOCKET_UDP
suffix:semicolon
multiline_comment|/* FIXME:  The next draft (04) of the SCTP Sockets Extensions&n;&t; * should include a socket option for manipulating these&n;&t; * message parameters (and a few others).&n;&t; */
id|sp-&gt;default_stream
op_assign
l_int|0
suffix:semicolon
id|sp-&gt;default_ppid
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Initialize default setup parameters. These parameters&n;&t; * can be modified with the SCTP_INITMSG socket option or&n;&t; * overridden by the SCTP_INIT CMSG.&n;&t; */
id|sp-&gt;initmsg.sinit_num_ostreams
op_assign
id|proto-&gt;max_outstreams
suffix:semicolon
id|sp-&gt;initmsg.sinit_max_instreams
op_assign
id|proto-&gt;max_instreams
suffix:semicolon
id|sp-&gt;initmsg.sinit_max_attempts
op_assign
id|proto-&gt;max_retrans_init
suffix:semicolon
id|sp-&gt;initmsg.sinit_max_init_timeo
op_assign
id|proto-&gt;rto_max
op_div
id|HZ
suffix:semicolon
multiline_comment|/* Initialize default RTO related parameters.  These parameters can&n;&t; * be modified for with the SCTP_RTOINFO socket option.&n;&t; * FIXME: This are not used yet.&n;&t; */
id|sp-&gt;rtoinfo.srto_initial
op_assign
id|proto-&gt;rto_initial
suffix:semicolon
id|sp-&gt;rtoinfo.srto_max
op_assign
id|proto-&gt;rto_max
suffix:semicolon
id|sp-&gt;rtoinfo.srto_min
op_assign
id|proto-&gt;rto_min
suffix:semicolon
multiline_comment|/* Initialize default event subscriptions.&n;&t; * the struct sock is initialized to zero, so only&n;&t; * enable the events needed.  By default, UDP-style&n;&t; * sockets enable io and association change notifications.&n;&t; */
r_if
c_cond
(paren
id|SCTP_SOCKET_UDP
op_eq
id|sp-&gt;type
)paren
(brace
id|sp-&gt;subscribe.sctp_data_io_event
op_assign
l_int|1
suffix:semicolon
id|sp-&gt;subscribe.sctp_association_event
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Default Peer Address Parameters.  These defaults can&n;&t; * be modified via SCTP_SET_PEER_ADDR_PARAMS&n;&t; */
id|sp-&gt;paddrparam.spp_hbinterval
op_assign
id|proto-&gt;hb_interval
op_div
id|HZ
suffix:semicolon
id|sp-&gt;paddrparam.spp_pathmaxrxt
op_assign
id|proto-&gt;max_retrans_path
suffix:semicolon
multiline_comment|/* If enabled no SCTP message fragmentation will be performed.&n;&t; * Configure through SCTP_DISABLE_FRAGMENTS socket option.&n;&t; */
id|sp-&gt;disable_fragments
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Turn on/off any Nagle-like algorithm.  */
id|sp-&gt;nodelay
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Auto-close idle associations after the configured&n;&t; * number of seconds.  A value of 0 disables this&n;&t; * feature.  Configure through the SCTP_AUTOCLOSE socket option,&n;&t; * for UDP-style sockets only.&n;&t; */
id|sp-&gt;autoclose
op_assign
l_int|0
suffix:semicolon
id|sp-&gt;pf
op_assign
id|sctp_get_pf_specific
c_func
(paren
id|sk-&gt;family
)paren
suffix:semicolon
multiline_comment|/* Create a per socket endpoint structure.  Even if we&n;&t; * change the data structure relationships, this may still&n;&t; * be useful for storing pre-connect address information.&n;&t; */
id|ep
op_assign
id|sctp_endpoint_new
c_func
(paren
id|proto
comma
id|sk
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|NULL
op_eq
id|ep
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|sp-&gt;ep
op_assign
id|ep
suffix:semicolon
id|SCTP_DBG_OBJCNT_INC
c_func
(paren
id|sock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Cleanup any SCTP per socket resources.  */
DECL|function|sctp_destroy_sock
id|SCTP_STATIC
r_int
id|sctp_destroy_sock
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
id|sctp_endpoint_t
op_star
id|ep
suffix:semicolon
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;sctp_destroy_sock(sk: %p)&bslash;n&quot;
comma
id|sk
)paren
suffix:semicolon
multiline_comment|/* Release our hold on the endpoint. */
id|ep
op_assign
id|sctp_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|ep
suffix:semicolon
id|sctp_endpoint_free
c_func
(paren
id|ep
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* FIXME: Comments needed.  */
DECL|function|sctp_shutdown
id|SCTP_STATIC
r_void
id|sctp_shutdown
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|how
)paren
(brace
multiline_comment|/* UDP-style sockets do not support shutdown. */
multiline_comment|/* STUB */
)brace
DECL|function|sctp_getsockopt_sctp_status
r_static
r_int
id|sctp_getsockopt_sctp_status
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|len
comma
r_char
op_star
id|optval
comma
r_int
op_star
id|optlen
)paren
(brace
r_struct
id|sctp_status
id|status
suffix:semicolon
id|sctp_endpoint_t
op_star
id|ep
suffix:semicolon
id|sctp_association_t
op_star
id|assoc
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|sctp_transport
op_star
id|transport
suffix:semicolon
id|sctp_assoc_t
id|associd
suffix:semicolon
r_int
id|retval
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|len
op_ne
r_sizeof
(paren
id|status
)paren
)paren
(brace
id|retval
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|status
comma
id|optval
comma
r_sizeof
(paren
id|status
)paren
)paren
)paren
(brace
id|retval
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|associd
op_assign
id|status.sstat_assoc_id
suffix:semicolon
r_if
c_cond
(paren
(paren
id|SCTP_SOCKET_UDP_HIGH_BANDWIDTH
op_ne
id|sctp_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|type
)paren
op_logical_and
id|associd
)paren
(brace
id|assoc
op_assign
id|sctp_id2assoc
c_func
(paren
id|sk
comma
id|associd
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|assoc
)paren
(brace
id|retval
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
)brace
r_else
(brace
id|ep
op_assign
id|sctp_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|ep
suffix:semicolon
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|ep-&gt;asocs
)paren
)paren
(brace
id|retval
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|assoc
op_assign
id|list_entry
c_func
(paren
id|ep-&gt;asocs.next
comma
id|sctp_association_t
comma
id|asocs
)paren
suffix:semicolon
)brace
id|transport
op_assign
id|assoc-&gt;peer.primary_path
suffix:semicolon
id|status.sstat_assoc_id
op_assign
id|sctp_assoc2id
c_func
(paren
id|assoc
)paren
suffix:semicolon
id|status.sstat_state
op_assign
id|assoc-&gt;state
suffix:semicolon
id|status.sstat_rwnd
op_assign
id|assoc-&gt;peer.rwnd
suffix:semicolon
id|status.sstat_unackdata
op_assign
id|assoc-&gt;unack_data
suffix:semicolon
id|status.sstat_penddata
op_assign
id|assoc-&gt;peer.tsn_map.pending_data
suffix:semicolon
id|status.sstat_instrms
op_assign
id|assoc-&gt;c.sinit_max_instreams
suffix:semicolon
id|status.sstat_outstrms
op_assign
id|assoc-&gt;c.sinit_num_ostreams
suffix:semicolon
id|status.sstat_fragmentation_point
op_assign
id|assoc-&gt;frag_point
suffix:semicolon
id|status.sstat_primary.spinfo_assoc_id
op_assign
id|sctp_assoc2id
c_func
(paren
id|transport-&gt;asoc
)paren
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|status.sstat_primary.spinfo_address
comma
op_amp
(paren
id|transport-&gt;ipaddr
)paren
comma
r_sizeof
(paren
r_union
id|sctp_addr
)paren
)paren
suffix:semicolon
id|status.sstat_primary.spinfo_state
op_assign
id|transport-&gt;active
suffix:semicolon
id|status.sstat_primary.spinfo_cwnd
op_assign
id|transport-&gt;cwnd
suffix:semicolon
id|status.sstat_primary.spinfo_srtt
op_assign
id|transport-&gt;srtt
suffix:semicolon
id|status.sstat_primary.spinfo_rto
op_assign
id|transport-&gt;rto
suffix:semicolon
id|status.sstat_primary.spinfo_mtu
op_assign
id|transport-&gt;pmtu
suffix:semicolon
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|len
comma
id|optlen
)paren
)paren
(brace
id|retval
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;sctp_getsockopt_sctp_status(%d): %d %d %p&bslash;n&quot;
comma
id|len
comma
id|status.sstat_state
comma
id|status.sstat_rwnd
comma
id|status.sstat_assoc_id
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|optval
comma
op_amp
id|status
comma
id|len
)paren
)paren
(brace
id|retval
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|out
suffix:colon
r_return
(paren
id|retval
)paren
suffix:semicolon
)brace
DECL|function|sctp_getsockopt_disable_fragments
r_static
r_inline
r_int
id|sctp_getsockopt_disable_fragments
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|len
comma
r_char
op_star
id|optval
comma
r_int
op_star
id|optlen
)paren
(brace
r_int
id|val
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
r_sizeof
(paren
r_int
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|len
op_assign
r_sizeof
(paren
r_int
)paren
suffix:semicolon
id|val
op_assign
(paren
id|sctp_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|disable_fragments
op_eq
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|len
comma
id|optlen
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|optval
comma
op_amp
id|val
comma
id|len
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|sctp_getsockopt_set_events
r_static
r_inline
r_int
id|sctp_getsockopt_set_events
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|len
comma
r_char
op_star
id|optval
comma
r_int
op_star
id|optlen
)paren
(brace
r_if
c_cond
(paren
id|len
op_ne
r_sizeof
(paren
r_struct
id|sctp_event_subscribe
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|optval
comma
op_amp
id|sctp_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|subscribe
comma
id|len
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|sctp_getsockopt_autoclose
r_static
r_inline
r_int
id|sctp_getsockopt_autoclose
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|len
comma
r_char
op_star
id|optval
comma
r_int
op_star
id|optlen
)paren
(brace
multiline_comment|/* Applicable to UDP-style socket only */
r_if
c_cond
(paren
id|SCTP_SOCKET_TCP
op_eq
id|sctp_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|type
)paren
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
r_if
c_cond
(paren
id|len
op_ne
r_sizeof
(paren
r_int
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|optval
comma
op_amp
id|sctp_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|autoclose
comma
id|len
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Helper routine to branch off an association to a new socket.  */
DECL|function|sctp_do_peeloff
id|SCTP_STATIC
r_int
id|sctp_do_peeloff
c_func
(paren
id|sctp_association_t
op_star
id|assoc
comma
r_struct
id|socket
op_star
op_star
id|newsock
)paren
(brace
r_struct
id|sock
op_star
id|oldsk
op_assign
id|assoc-&gt;base.sk
suffix:semicolon
r_struct
id|sock
op_star
id|newsk
suffix:semicolon
r_struct
id|socket
op_star
id|tmpsock
suffix:semicolon
id|sctp_endpoint_t
op_star
id|newep
suffix:semicolon
id|sctp_opt_t
op_star
id|oldsp
op_assign
id|sctp_sk
c_func
(paren
id|oldsk
)paren
suffix:semicolon
id|sctp_opt_t
op_star
id|newsp
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
comma
op_star
id|tmp
suffix:semicolon
id|sctp_ulpevent_t
op_star
id|event
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* An association cannot be branched off from an already peeled-off&n;&t; * socket, nor is this supported for tcp style sockets.&n;&t; */
r_if
c_cond
(paren
id|SCTP_SOCKET_UDP
op_ne
id|sctp_sk
c_func
(paren
id|oldsk
)paren
op_member_access_from_pointer
id|type
)paren
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
multiline_comment|/* Create a new socket.  */
id|err
op_assign
id|sock_create
c_func
(paren
id|PF_INET
comma
id|SOCK_SEQPACKET
comma
id|IPPROTO_SCTP
comma
op_amp
id|tmpsock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_return
id|err
suffix:semicolon
id|newsk
op_assign
id|tmpsock-&gt;sk
suffix:semicolon
id|newsp
op_assign
id|sctp_sk
c_func
(paren
id|newsk
)paren
suffix:semicolon
id|newep
op_assign
id|newsp-&gt;ep
suffix:semicolon
multiline_comment|/* Migrate socket buffer sizes and all the socket level options to the&n;&t; * new socket.&n;&t; */
id|newsk-&gt;sndbuf
op_assign
id|oldsk-&gt;sndbuf
suffix:semicolon
id|newsk-&gt;rcvbuf
op_assign
id|oldsk-&gt;rcvbuf
suffix:semicolon
op_star
id|newsp
op_assign
op_star
id|oldsp
suffix:semicolon
multiline_comment|/* Restore the ep value that was overwritten with the above structure&n;&t; * copy.&n;&t; */
id|newsp-&gt;ep
op_assign
id|newep
suffix:semicolon
multiline_comment|/* Move any messages in the old socket&squot;s receive queue that are for the&n;&t; * peeled off association to the new socket&squot;s receive queue.&n;&t; */
id|sctp_skb_for_each
c_func
(paren
id|skb
comma
op_amp
id|oldsk-&gt;receive_queue
comma
id|tmp
)paren
(brace
id|event
op_assign
(paren
id|sctp_ulpevent_t
op_star
)paren
id|skb-&gt;cb
suffix:semicolon
r_if
c_cond
(paren
id|event-&gt;asoc
op_eq
id|assoc
)paren
(brace
id|__skb_unlink
c_func
(paren
id|skb
comma
id|skb-&gt;list
)paren
suffix:semicolon
id|__skb_queue_tail
c_func
(paren
op_amp
id|newsk-&gt;receive_queue
comma
id|skb
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Set the type of socket to indicate that it is peeled off from the&n;&t; * original socket.&n;&t; */
id|newsp-&gt;type
op_assign
id|SCTP_SOCKET_UDP_HIGH_BANDWIDTH
suffix:semicolon
multiline_comment|/* Migrate the association to the new socket.  */
id|sctp_assoc_migrate
c_func
(paren
id|assoc
comma
id|newsk
)paren
suffix:semicolon
op_star
id|newsock
op_assign
id|tmpsock
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|function|sctp_getsockopt_peeloff
r_static
r_inline
r_int
id|sctp_getsockopt_peeloff
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|len
comma
r_char
op_star
id|optval
comma
r_int
op_star
id|optlen
)paren
(brace
id|sctp_peeloff_arg_t
id|peeloff
suffix:semicolon
r_struct
id|socket
op_star
id|newsock
suffix:semicolon
r_int
id|retval
op_assign
l_int|0
suffix:semicolon
id|sctp_association_t
op_star
id|assoc
suffix:semicolon
r_if
c_cond
(paren
id|len
op_ne
r_sizeof
(paren
id|sctp_peeloff_arg_t
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|peeloff
comma
id|optval
comma
id|len
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|assoc
op_assign
id|sctp_id2assoc
c_func
(paren
id|sk
comma
id|peeloff.associd
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|NULL
op_eq
id|assoc
)paren
(brace
id|retval
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;%s: sk: %p assoc: %p&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|sk
comma
id|assoc
)paren
suffix:semicolon
id|retval
op_assign
id|sctp_do_peeloff
c_func
(paren
id|assoc
comma
op_amp
id|newsock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
OL
l_int|0
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* Map the socket to an unused fd that can be returned to the user.  */
id|retval
op_assign
id|sock_map_fd
c_func
(paren
id|newsock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
OL
l_int|0
)paren
(brace
id|sock_release
c_func
(paren
id|newsock
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;%s: sk: %p assoc: %p newsk: %p sd: %d&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|sk
comma
id|assoc
comma
id|newsock-&gt;sk
comma
id|retval
)paren
suffix:semicolon
multiline_comment|/* Return the fd mapped to the new socket.  */
id|peeloff.sd
op_assign
id|retval
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|optval
comma
op_amp
id|peeloff
comma
id|len
)paren
)paren
id|retval
op_assign
op_minus
id|EFAULT
suffix:semicolon
id|out
suffix:colon
r_return
id|retval
suffix:semicolon
)brace
DECL|function|sctp_getsockopt_get_peer_addr_params
r_static
r_inline
r_int
id|sctp_getsockopt_get_peer_addr_params
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|len
comma
r_char
op_star
id|optval
comma
r_int
op_star
id|optlen
)paren
(brace
r_struct
id|sctp_paddrparams
id|params
suffix:semicolon
id|sctp_association_t
op_star
id|asoc
suffix:semicolon
r_union
id|sctp_addr
op_star
id|addr
suffix:semicolon
r_struct
id|sctp_transport
op_star
id|trans
suffix:semicolon
r_if
c_cond
(paren
id|len
op_ne
r_sizeof
(paren
r_struct
id|sctp_paddrparams
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|params
comma
id|optval
comma
op_star
id|optlen
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|asoc
op_assign
id|sctp_id2assoc
c_func
(paren
id|sk
comma
id|params.spp_assoc_id
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|asoc
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|addr
op_assign
(paren
r_union
id|sctp_addr
op_star
)paren
op_amp
(paren
id|params.spp_address
)paren
suffix:semicolon
id|trans
op_assign
id|sctp_assoc_lookup_paddr
c_func
(paren
id|asoc
comma
id|addr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|trans
)paren
r_return
op_minus
id|ENOENT
suffix:semicolon
multiline_comment|/* The value of the heartbeat interval, in milliseconds. A value of 0,&n;&t; * when modifying the parameter, specifies that the heartbeat on this&n;&t; * address should be disabled.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|trans-&gt;hb_allowed
)paren
id|params.spp_hbinterval
op_assign
l_int|0
suffix:semicolon
r_else
id|params.spp_hbinterval
op_assign
id|trans-&gt;hb_interval
op_star
l_int|1000
op_div
id|HZ
suffix:semicolon
multiline_comment|/* spp_pathmaxrxt contains the maximum number of retransmissions&n;&t; * before this address shall be considered unreachable.&n;&t; */
id|params.spp_pathmaxrxt
op_assign
id|trans-&gt;error_threshold
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|optval
comma
op_amp
id|params
comma
id|len
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
op_star
id|optlen
op_assign
id|len
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|sctp_getsockopt_initmsg
r_static
r_inline
r_int
id|sctp_getsockopt_initmsg
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|len
comma
r_char
op_star
id|optval
comma
r_int
op_star
id|optlen
)paren
(brace
r_if
c_cond
(paren
id|len
op_ne
r_sizeof
(paren
r_struct
id|sctp_initmsg
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|optval
comma
op_amp
id|sctp_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|initmsg
comma
id|len
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|sctp_getsockopt_get_peer_addrs_num
r_static
r_inline
r_int
id|sctp_getsockopt_get_peer_addrs_num
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|len
comma
r_char
op_star
id|optval
comma
r_int
op_star
id|optlen
)paren
(brace
id|sctp_assoc_t
id|id
suffix:semicolon
id|sctp_association_t
op_star
id|asoc
suffix:semicolon
r_struct
id|list_head
op_star
id|pos
suffix:semicolon
r_int
id|cnt
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|len
op_ne
r_sizeof
(paren
id|sctp_assoc_t
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|id
comma
id|optval
comma
r_sizeof
(paren
id|sctp_assoc_t
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
multiline_comment|/*&n;&t; *  For UDP-style sockets, id specifies the association to query.&n;&t; */
id|asoc
op_assign
id|sctp_id2assoc
c_func
(paren
id|sk
comma
id|id
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|asoc
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|list_for_each
c_func
(paren
id|pos
comma
op_amp
id|asoc-&gt;peer.transport_addr_list
)paren
(brace
id|cnt
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|optval
comma
op_amp
id|cnt
comma
r_sizeof
(paren
r_int
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|sctp_getsockopt_get_peer_addrs
r_static
r_inline
r_int
id|sctp_getsockopt_get_peer_addrs
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|len
comma
r_char
op_star
id|optval
comma
r_int
op_star
id|optlen
)paren
(brace
id|sctp_association_t
op_star
id|asoc
suffix:semicolon
r_struct
id|list_head
op_star
id|pos
suffix:semicolon
r_int
id|cnt
op_assign
l_int|0
suffix:semicolon
r_struct
id|sctp_getaddrs
id|getaddrs
suffix:semicolon
r_struct
id|sctp_transport
op_star
id|from
suffix:semicolon
r_struct
id|sockaddr_storage
op_star
id|to
suffix:semicolon
r_if
c_cond
(paren
id|len
op_ne
r_sizeof
(paren
r_struct
id|sctp_getaddrs
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|getaddrs
comma
id|optval
comma
r_sizeof
(paren
r_struct
id|sctp_getaddrs
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|getaddrs.addr_num
op_le
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/*&n;&t; *  For UDP-style sockets, id specifies the association to query.&n;&t; */
id|asoc
op_assign
id|sctp_id2assoc
c_func
(paren
id|sk
comma
id|getaddrs.assoc_id
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|asoc
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|to
op_assign
id|getaddrs.addrs
suffix:semicolon
id|list_for_each
c_func
(paren
id|pos
comma
op_amp
id|asoc-&gt;peer.transport_addr_list
)paren
(brace
id|from
op_assign
id|list_entry
c_func
(paren
id|pos
comma
r_struct
id|sctp_transport
comma
id|transports
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|to
comma
op_amp
id|from-&gt;ipaddr
comma
r_sizeof
(paren
id|from-&gt;ipaddr
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|to
op_increment
suffix:semicolon
id|cnt
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|cnt
op_ge
id|getaddrs.addr_num
)paren
r_break
suffix:semicolon
)brace
id|getaddrs.addr_num
op_assign
id|cnt
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|optval
comma
op_amp
id|getaddrs
comma
r_sizeof
(paren
r_struct
id|sctp_getaddrs
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|sctp_getsockopt_get_local_addrs_num
r_static
r_inline
r_int
id|sctp_getsockopt_get_local_addrs_num
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|len
comma
r_char
op_star
id|optval
comma
r_int
op_star
id|optlen
)paren
(brace
id|sctp_assoc_t
id|id
suffix:semicolon
id|sctp_bind_addr_t
op_star
id|bp
suffix:semicolon
id|sctp_association_t
op_star
id|asoc
suffix:semicolon
r_struct
id|list_head
op_star
id|pos
suffix:semicolon
r_int
id|cnt
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|len
op_ne
r_sizeof
(paren
id|sctp_assoc_t
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|id
comma
id|optval
comma
r_sizeof
(paren
id|sctp_assoc_t
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
multiline_comment|/*&n;&t; *  For UDP-style sockets, id specifies the association to query.&n;&t; *  If the id field is set to the value &squot;0&squot; then the locally bound&n;&t; *  addresses are returned without regard to any particular&n;&t; *  association.&n;&t; */
r_if
c_cond
(paren
l_int|0
op_eq
id|id
)paren
(brace
id|bp
op_assign
op_amp
id|sctp_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|ep-&gt;base.bind_addr
suffix:semicolon
)brace
r_else
(brace
id|asoc
op_assign
id|sctp_id2assoc
c_func
(paren
id|sk
comma
id|id
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|asoc
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|bp
op_assign
op_amp
id|asoc-&gt;base.bind_addr
suffix:semicolon
)brace
id|list_for_each
c_func
(paren
id|pos
comma
op_amp
id|bp-&gt;address_list
)paren
(brace
id|cnt
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|optval
comma
op_amp
id|cnt
comma
r_sizeof
(paren
r_int
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|sctp_getsockopt_get_local_addrs
r_static
r_inline
r_int
id|sctp_getsockopt_get_local_addrs
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|len
comma
r_char
op_star
id|optval
comma
r_int
op_star
id|optlen
)paren
(brace
id|sctp_bind_addr_t
op_star
id|bp
suffix:semicolon
id|sctp_association_t
op_star
id|asoc
suffix:semicolon
r_struct
id|list_head
op_star
id|pos
suffix:semicolon
r_int
id|cnt
op_assign
l_int|0
suffix:semicolon
r_struct
id|sctp_getaddrs
id|getaddrs
suffix:semicolon
r_struct
id|sockaddr_storage_list
op_star
id|from
suffix:semicolon
r_struct
id|sockaddr_storage
op_star
id|to
suffix:semicolon
r_if
c_cond
(paren
id|len
op_ne
r_sizeof
(paren
r_struct
id|sctp_getaddrs
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|getaddrs
comma
id|optval
comma
r_sizeof
(paren
r_struct
id|sctp_getaddrs
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|getaddrs.addr_num
op_le
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/*&n;&t; *  For UDP-style sockets, id specifies the association to query.&n;&t; *  If the id field is set to the value &squot;0&squot; then the locally bound&n;&t; *  addresses are returned without regard to any particular&n;&t; *  association.&n;&t; */
r_if
c_cond
(paren
l_int|0
op_eq
id|getaddrs.assoc_id
)paren
(brace
id|bp
op_assign
op_amp
id|sctp_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|ep-&gt;base.bind_addr
suffix:semicolon
)brace
r_else
(brace
id|asoc
op_assign
id|sctp_id2assoc
c_func
(paren
id|sk
comma
id|getaddrs.assoc_id
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|asoc
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|bp
op_assign
op_amp
id|asoc-&gt;base.bind_addr
suffix:semicolon
)brace
id|to
op_assign
id|getaddrs.addrs
suffix:semicolon
id|list_for_each
c_func
(paren
id|pos
comma
op_amp
id|bp-&gt;address_list
)paren
(brace
id|from
op_assign
id|list_entry
c_func
(paren
id|pos
comma
r_struct
id|sockaddr_storage_list
comma
id|list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|to
comma
op_amp
id|from-&gt;a
comma
r_sizeof
(paren
id|from-&gt;a
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|to
op_increment
suffix:semicolon
id|cnt
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|cnt
op_ge
id|getaddrs.addr_num
)paren
r_break
suffix:semicolon
)brace
id|getaddrs.addr_num
op_assign
id|cnt
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|optval
comma
op_amp
id|getaddrs
comma
r_sizeof
(paren
r_struct
id|sctp_getaddrs
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|sctp_getsockopt
id|SCTP_STATIC
r_int
id|sctp_getsockopt
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|level
comma
r_int
id|optname
comma
r_char
op_star
id|optval
comma
r_int
op_star
id|optlen
)paren
(brace
r_int
id|retval
op_assign
l_int|0
suffix:semicolon
r_int
id|len
suffix:semicolon
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;sctp_getsockopt(sk: %p, ...)&bslash;n&quot;
comma
id|sk
)paren
suffix:semicolon
multiline_comment|/* I can hardly begin to describe how wrong this is.  This is&n;&t; * so broken as to be worse than useless.  The API draft&n;&t; * REALLY is NOT helpful here...  I am not convinced that the&n;&t; * semantics of getsockopt() with a level OTHER THAN SOL_SCTP&n;&t; * are at all well-founded.&n;&t; */
r_if
c_cond
(paren
id|level
op_ne
id|SOL_SCTP
)paren
(brace
r_struct
id|sctp_af
op_star
id|af
op_assign
id|sctp_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|pf-&gt;af
suffix:semicolon
id|retval
op_assign
id|af
op_member_access_from_pointer
id|getsockopt
c_func
(paren
id|sk
comma
id|level
comma
id|optname
comma
id|optval
comma
id|optlen
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|len
comma
id|optlen
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|sctp_lock_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|optname
)paren
(brace
r_case
id|SCTP_STATUS
suffix:colon
id|retval
op_assign
id|sctp_getsockopt_sctp_status
c_func
(paren
id|sk
comma
id|len
comma
id|optval
comma
id|optlen
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_DISABLE_FRAGMENTS
suffix:colon
id|retval
op_assign
id|sctp_getsockopt_disable_fragments
c_func
(paren
id|sk
comma
id|len
comma
id|optval
comma
id|optlen
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_SET_EVENTS
suffix:colon
id|retval
op_assign
id|sctp_getsockopt_set_events
c_func
(paren
id|sk
comma
id|len
comma
id|optval
comma
id|optlen
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_AUTOCLOSE
suffix:colon
id|retval
op_assign
id|sctp_getsockopt_autoclose
c_func
(paren
id|sk
comma
id|len
comma
id|optval
comma
id|optlen
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_SOCKOPT_PEELOFF
suffix:colon
id|retval
op_assign
id|sctp_getsockopt_peeloff
c_func
(paren
id|sk
comma
id|len
comma
id|optval
comma
id|optlen
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_GET_PEER_ADDR_PARAMS
suffix:colon
id|retval
op_assign
id|sctp_getsockopt_get_peer_addr_params
c_func
(paren
id|sk
comma
id|len
comma
id|optval
comma
id|optlen
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_INITMSG
suffix:colon
id|retval
op_assign
id|sctp_getsockopt_initmsg
c_func
(paren
id|sk
comma
id|len
comma
id|optval
comma
id|optlen
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_GET_PEER_ADDRS_NUM
suffix:colon
id|retval
op_assign
id|sctp_getsockopt_get_peer_addrs_num
c_func
(paren
id|sk
comma
id|len
comma
id|optval
comma
id|optlen
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_GET_LOCAL_ADDRS_NUM
suffix:colon
id|retval
op_assign
id|sctp_getsockopt_get_local_addrs_num
c_func
(paren
id|sk
comma
id|len
comma
id|optval
comma
id|optlen
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_GET_PEER_ADDRS
suffix:colon
id|retval
op_assign
id|sctp_getsockopt_get_peer_addrs
c_func
(paren
id|sk
comma
id|len
comma
id|optval
comma
id|optlen
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_GET_LOCAL_ADDRS
suffix:colon
id|retval
op_assign
id|sctp_getsockopt_get_local_addrs
c_func
(paren
id|sk
comma
id|len
comma
id|optval
comma
id|optlen
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|retval
op_assign
op_minus
id|ENOPROTOOPT
suffix:semicolon
r_break
suffix:semicolon
)brace
suffix:semicolon
id|sctp_release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
DECL|function|sctp_hash
r_static
r_void
id|sctp_hash
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
multiline_comment|/* STUB */
)brace
DECL|function|sctp_unhash
r_static
r_void
id|sctp_unhash
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
multiline_comment|/* STUB */
)brace
multiline_comment|/* Check if port is acceptable.  Possibly find first available port.&n; *&n; * The port hash table (contained in the &squot;global&squot; SCTP protocol storage&n; * returned by sctp_protocol_t * sctp_get_protocol()). The hash&n; * table is an array of 4096 lists (sctp_bind_hashbucket_t). Each&n; * list (the list number is the port number hashed out, so as you&n; * would expect from a hash function, all the ports in a given list have&n; * such a number that hashes out to the same list number; you were&n; * expecting that, right?); so each list has a set of ports, with a&n; * link to the socket (struct sock) that uses it, the port number and&n; * a fastreuse flag (FIXME: NPI ipg).&n; */
r_static
id|sctp_bind_bucket_t
op_star
id|sctp_bucket_create
c_func
(paren
id|sctp_bind_hashbucket_t
op_star
id|head
comma
r_int
r_int
id|snum
)paren
suffix:semicolon
DECL|function|sctp_get_port_local
r_static
r_int
id|sctp_get_port_local
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_union
id|sctp_addr
op_star
id|addr
)paren
(brace
id|sctp_bind_hashbucket_t
op_star
id|head
suffix:semicolon
multiline_comment|/* hash list */
id|sctp_bind_bucket_t
op_star
id|pp
suffix:semicolon
multiline_comment|/* hash list port iterator */
id|sctp_protocol_t
op_star
id|sctp
op_assign
id|sctp_get_protocol
c_func
(paren
)paren
suffix:semicolon
r_int
r_int
id|snum
suffix:semicolon
r_int
id|ret
suffix:semicolon
multiline_comment|/* NOTE:  Remember to put this back to net order. */
id|addr-&gt;v4.sin_port
op_assign
id|ntohs
c_func
(paren
id|addr-&gt;v4.sin_port
)paren
suffix:semicolon
id|snum
op_assign
id|addr-&gt;v4.sin_port
suffix:semicolon
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;sctp_get_port() begins, snum=%d&bslash;n&quot;
comma
id|snum
)paren
suffix:semicolon
id|sctp_local_bh_disable
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|snum
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Search for an available port.&n;&t;&t; *&n;&t;&t; * &squot;sctp-&gt;port_rover&squot; was the last port assigned, so&n;&t;&t; * we start to search from &squot;sctp-&gt;port_rover +&n;&t;&t; * 1&squot;. What we do is first check if port &squot;rover&squot; is&n;&t;&t; * already in the hash table; if not, we use that; if&n;&t;&t; * it is, we try next.&n;&t;&t; */
r_int
id|low
op_assign
id|sysctl_local_port_range
(braket
l_int|0
)braket
suffix:semicolon
r_int
id|high
op_assign
id|sysctl_local_port_range
(braket
l_int|1
)braket
suffix:semicolon
r_int
id|remaining
op_assign
(paren
id|high
op_minus
id|low
)paren
op_plus
l_int|1
suffix:semicolon
r_int
id|rover
suffix:semicolon
r_int
id|index
suffix:semicolon
id|sctp_spin_lock
c_func
(paren
op_amp
id|sctp-&gt;port_alloc_lock
)paren
suffix:semicolon
id|rover
op_assign
id|sctp-&gt;port_rover
suffix:semicolon
r_do
(brace
id|rover
op_increment
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rover
OL
id|low
)paren
op_logical_or
(paren
id|rover
OG
id|high
)paren
)paren
id|rover
op_assign
id|low
suffix:semicolon
id|index
op_assign
id|sctp_phashfn
c_func
(paren
id|rover
)paren
suffix:semicolon
id|head
op_assign
op_amp
id|sctp-&gt;port_hashtable
(braket
id|index
)braket
suffix:semicolon
id|sctp_spin_lock
c_func
(paren
op_amp
id|head-&gt;lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|pp
op_assign
id|head-&gt;chain
suffix:semicolon
id|pp
suffix:semicolon
id|pp
op_assign
id|pp-&gt;next
)paren
r_if
c_cond
(paren
id|pp-&gt;port
op_eq
id|rover
)paren
r_goto
id|next
suffix:semicolon
r_break
suffix:semicolon
id|next
suffix:colon
id|sctp_spin_unlock
c_func
(paren
op_amp
id|head-&gt;lock
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
op_decrement
id|remaining
OG
l_int|0
)paren
suffix:semicolon
id|sctp-&gt;port_rover
op_assign
id|rover
suffix:semicolon
id|sctp_spin_unlock
c_func
(paren
op_amp
id|sctp-&gt;port_alloc_lock
)paren
suffix:semicolon
multiline_comment|/* Exhausted local port range during search? */
id|ret
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|remaining
op_le
l_int|0
)paren
r_goto
id|fail
suffix:semicolon
multiline_comment|/* OK, here is the one we will use.  HEAD (the port&n;&t;&t; * hash table list entry) is non-NULL and we hold it&squot;s&n;&t;&t; * mutex.&n;&t;&t; */
id|snum
op_assign
id|rover
suffix:semicolon
id|pp
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* We are given an specific port number; we verify&n;&t;&t; * that it is not being used. If it is used, we will&n;&t;&t; * exahust the search in the hash list corresponding&n;&t;&t; * to the port number (snum) - we detect that with the&n;&t;&t; * port iterator, pp being NULL.&n;&t;&t; */
id|head
op_assign
op_amp
id|sctp-&gt;port_hashtable
(braket
id|sctp_phashfn
c_func
(paren
id|snum
)paren
)braket
suffix:semicolon
id|sctp_spin_lock
c_func
(paren
op_amp
id|head-&gt;lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|pp
op_assign
id|head-&gt;chain
suffix:semicolon
id|pp
suffix:semicolon
id|pp
op_assign
id|pp-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|pp-&gt;port
op_eq
id|snum
)paren
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|pp
op_ne
l_int|NULL
op_logical_and
id|pp-&gt;sk
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* We had a port hash table hit - there is an&n;&t;&t; * available port (pp != NULL) and it is being&n;&t;&t; * used by other socket (pp-&gt;sk != NULL); that other&n;&t;&t; * socket is going to be sk2.&n;&t;&t; */
r_int
id|sk_reuse
op_assign
id|sk-&gt;reuse
suffix:semicolon
r_struct
id|sock
op_star
id|sk2
op_assign
id|pp-&gt;sk
suffix:semicolon
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;sctp_get_port() found a &quot;
l_string|&quot;possible match&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pp-&gt;fastreuse
op_ne
l_int|0
op_logical_and
id|sk-&gt;reuse
op_ne
l_int|0
)paren
r_goto
id|success
suffix:semicolon
multiline_comment|/* Run through the list of sockets bound to the port&n;&t;&t; * (pp-&gt;port) [via the pointers bind_next and&n;&t;&t; * bind_pprev in the struct sock *sk2 (pp-&gt;sk)]. On each one,&n;&t;&t; * we get the endpoint they describe and run through&n;&t;&t; * the endpoint&squot;s list of IP (v4 or v6) addresses,&n;&t;&t; * comparing each of the addresses with the address of&n;&t;&t; * the socket sk. If we find a match, then that means&n;&t;&t; * that this port/socket (sk) combination are already&n;&t;&t; * in an endpoint.&n;&t;&t; */
r_for
c_loop
(paren
suffix:semicolon
id|sk2
op_ne
l_int|NULL
suffix:semicolon
id|sk2
op_assign
id|sk2-&gt;bind_next
)paren
(brace
id|sctp_endpoint_t
op_star
id|ep2
suffix:semicolon
id|ep2
op_assign
id|sctp_sk
c_func
(paren
id|sk2
)paren
op_member_access_from_pointer
id|ep
suffix:semicolon
r_if
c_cond
(paren
id|sk_reuse
op_logical_and
id|sk2-&gt;reuse
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|sctp_bind_addr_match
c_func
(paren
op_amp
id|ep2-&gt;base.bind_addr
comma
id|addr
comma
id|sctp_sk
c_func
(paren
id|sk
)paren
)paren
)paren
r_goto
id|found
suffix:semicolon
)brace
id|found
suffix:colon
multiline_comment|/* If we found a conflict, fail.  */
r_if
c_cond
(paren
id|sk2
op_ne
l_int|NULL
)paren
(brace
id|ret
op_assign
(paren
r_int
)paren
id|sk2
suffix:semicolon
r_goto
id|fail_unlock
suffix:semicolon
)brace
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;sctp_get_port(): Found a match&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* If there was a hash table miss, create a new port.  */
id|ret
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|pp
op_eq
l_int|NULL
op_logical_and
(paren
id|pp
op_assign
id|sctp_bucket_create
c_func
(paren
id|head
comma
id|snum
)paren
)paren
op_eq
l_int|NULL
)paren
r_goto
id|fail_unlock
suffix:semicolon
multiline_comment|/* In either case (hit or miss), make sure fastreuse is 1 only&n;&t; * if sk-&gt;reuse is too (that is, if the caller requested&n;&t; * SO_REUSEADDR on this socket -sk-).&n;&t; */
r_if
c_cond
(paren
id|pp-&gt;sk
op_eq
l_int|NULL
)paren
(brace
id|pp-&gt;fastreuse
op_assign
id|sk-&gt;reuse
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|pp-&gt;fastreuse
op_logical_and
id|sk-&gt;reuse
op_eq
l_int|0
)paren
(brace
id|pp-&gt;fastreuse
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* We are set, so fill up all the data in the hash table&n;&t; * entry, tie the socket list information with the rest of the&n;&t; * sockets FIXME: Blurry, NPI (ipg).&n;&t; */
id|success
suffix:colon
id|inet_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|num
op_assign
id|snum
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;prev
op_eq
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
(paren
id|sk-&gt;bind_next
op_assign
id|pp-&gt;sk
)paren
op_ne
l_int|NULL
)paren
id|pp-&gt;sk-&gt;bind_pprev
op_assign
op_amp
id|sk-&gt;bind_next
suffix:semicolon
id|pp-&gt;sk
op_assign
id|sk
suffix:semicolon
id|sk-&gt;bind_pprev
op_assign
op_amp
id|pp-&gt;sk
suffix:semicolon
id|sk-&gt;prev
op_assign
(paren
r_struct
id|sock
op_star
)paren
id|pp
suffix:semicolon
)brace
id|ret
op_assign
l_int|0
suffix:semicolon
id|fail_unlock
suffix:colon
id|sctp_spin_unlock
c_func
(paren
op_amp
id|head-&gt;lock
)paren
suffix:semicolon
id|fail
suffix:colon
id|sctp_local_bh_enable
c_func
(paren
)paren
suffix:semicolon
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;sctp_get_port() ends, ret=%d&bslash;n&quot;
comma
id|ret
)paren
suffix:semicolon
id|addr-&gt;v4.sin_port
op_assign
id|htons
c_func
(paren
id|addr-&gt;v4.sin_port
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* Assign a &squot;snum&squot; port to the socket.  If snum == 0, an ephemeral&n; * port is requested.&n; */
DECL|function|sctp_get_port
r_static
r_int
id|sctp_get_port
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
r_int
id|snum
)paren
(brace
r_int
id|ret
suffix:semicolon
r_union
id|sctp_addr
id|addr
suffix:semicolon
r_struct
id|sctp_af
op_star
id|af
op_assign
id|sctp_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|pf-&gt;af
suffix:semicolon
multiline_comment|/* Set up a dummy address struct from the sk. */
id|af
op_member_access_from_pointer
id|from_sk
c_func
(paren
op_amp
id|addr
comma
id|sk
)paren
suffix:semicolon
id|addr.v4.sin_port
op_assign
id|htons
c_func
(paren
id|snum
)paren
suffix:semicolon
multiline_comment|/* Note: sk-&gt;num gets filled in if ephemeral port request. */
id|ret
op_assign
id|sctp_get_port_local
c_func
(paren
id|sk
comma
op_amp
id|addr
)paren
suffix:semicolon
r_return
(paren
id|ret
ques
c_cond
l_int|1
suffix:colon
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * 3.1.3 listen() - UDP Style Syntax&n; *&n; *   By default, new associations are not accepted for UDP style sockets.&n; *   An application uses listen() to mark a socket as being able to&n; *   accept new associations.&n; */
DECL|function|sctp_seqpacket_listen
id|SCTP_STATIC
r_int
id|sctp_seqpacket_listen
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|backlog
)paren
(brace
id|sctp_opt_t
op_star
id|sp
op_assign
id|sctp_sk
c_func
(paren
id|sk
)paren
suffix:semicolon
id|sctp_endpoint_t
op_star
id|ep
op_assign
id|sp-&gt;ep
suffix:semicolon
multiline_comment|/* Only UDP style sockets that are not peeled off are allowed to&n;&t; * listen().&n;&t; */
r_if
c_cond
(paren
id|SCTP_SOCKET_UDP
op_ne
id|sp-&gt;type
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/*&n;&t; * If a bind() or sctp_bindx() is not called prior to a listen()&n;&t; * call that allows new associations to be accepted, the system&n;&t; * picks an ephemeral port and will choose an address set equivalent&n;&t; * to binding with a wildcard address.&n;&t; *&n;&t; * This is not currently spelled out in the SCTP sockets&n;&t; * extensions draft, but follows the practice as seen in TCP&n;&t; * sockets.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|ep-&gt;base.bind_addr.port
)paren
(brace
r_if
c_cond
(paren
id|sctp_autobind
c_func
(paren
id|sk
)paren
)paren
r_return
op_minus
id|EAGAIN
suffix:semicolon
)brace
id|sk-&gt;state
op_assign
id|SCTP_SS_LISTENING
suffix:semicolon
id|sctp_hash_endpoint
c_func
(paren
id|ep
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *  Move a socket to LISTENING state.&n; */
DECL|function|sctp_inet_listen
r_int
id|sctp_inet_listen
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_int
id|backlog
)paren
(brace
r_struct
id|sock
op_star
id|sk
op_assign
id|sock-&gt;sk
suffix:semicolon
r_int
id|err
suffix:semicolon
id|sctp_lock_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|sock-&gt;state
op_ne
id|SS_UNCONNECTED
)paren
r_goto
id|out
suffix:semicolon
r_switch
c_cond
(paren
id|sock-&gt;type
)paren
(brace
r_case
id|SOCK_SEQPACKET
suffix:colon
id|err
op_assign
id|sctp_seqpacket_listen
c_func
(paren
id|sk
comma
id|backlog
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOCK_STREAM
suffix:colon
multiline_comment|/* FIXME for TCP-style sockets. */
id|err
op_assign
op_minus
id|EOPNOTSUPP
suffix:semicolon
r_default
suffix:colon
r_goto
id|out
suffix:semicolon
)brace
suffix:semicolon
id|out
suffix:colon
id|sctp_release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; * This function is done by modeling the current datagram_poll() and the&n; * tcp_poll().  Note that, based on these implementations, we don&squot;t&n; * lock the socket in this function, even though it seems that,&n; * ideally, locking or some other mechanisms can be used to ensure&n; * the integrity of the counters (sndbuf and wmem_queued) used&n; * in this place.  We assume that we don&squot;t need locks either until proven&n; * otherwise.&n; *&n; * Another thing to note is that we include the Async I/O support&n; * here, again, by modeling the current TCP/UDP code.  We don&squot;t have&n; * a good way to test with it yet.&n; */
DECL|function|sctp_poll
r_int
r_int
id|sctp_poll
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_struct
id|socket
op_star
id|sock
comma
id|poll_table
op_star
id|wait
)paren
(brace
r_struct
id|sock
op_star
id|sk
op_assign
id|sock-&gt;sk
suffix:semicolon
r_int
r_int
id|mask
suffix:semicolon
id|poll_wait
c_func
(paren
id|file
comma
id|sk-&gt;sleep
comma
id|wait
)paren
suffix:semicolon
id|mask
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Is there any exceptional events?  */
r_if
c_cond
(paren
id|sk-&gt;err
op_logical_or
op_logical_neg
id|skb_queue_empty
c_func
(paren
op_amp
id|sk-&gt;error_queue
)paren
)paren
id|mask
op_or_assign
id|POLLERR
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;shutdown
op_eq
id|SHUTDOWN_MASK
)paren
id|mask
op_or_assign
id|POLLHUP
suffix:semicolon
multiline_comment|/* Is it readable?  Reconsider this code with TCP-style support.  */
r_if
c_cond
(paren
op_logical_neg
id|skb_queue_empty
c_func
(paren
op_amp
id|sk-&gt;receive_queue
)paren
op_logical_or
(paren
id|sk-&gt;shutdown
op_amp
id|RCV_SHUTDOWN
)paren
)paren
id|mask
op_or_assign
id|POLLIN
op_or
id|POLLRDNORM
suffix:semicolon
multiline_comment|/*&n;&t; * FIXME: We need to set SCTP_SS_DISCONNECTING for TCP-style and&n;&t; * peeled off sockets.  Additionally, TCP-style needs to consider&n;&t; * other establishment conditions.&n;&t; */
r_if
c_cond
(paren
id|SCTP_SOCKET_UDP
op_ne
id|sctp_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|type
)paren
(brace
multiline_comment|/* The association is going away.  */
r_if
c_cond
(paren
id|SCTP_SS_DISCONNECTING
op_eq
id|sk-&gt;state
)paren
id|mask
op_or_assign
id|POLLHUP
suffix:semicolon
multiline_comment|/* The association is either gone or not ready.  */
r_if
c_cond
(paren
id|SCTP_SS_CLOSED
op_eq
id|sk-&gt;state
)paren
r_return
id|mask
suffix:semicolon
)brace
multiline_comment|/* Is it writable?  */
r_if
c_cond
(paren
id|sctp_writeable
c_func
(paren
id|sk
)paren
)paren
(brace
id|mask
op_or_assign
id|POLLOUT
op_or
id|POLLWRNORM
suffix:semicolon
)brace
r_else
(brace
id|set_bit
c_func
(paren
id|SOCK_ASYNC_NOSPACE
comma
op_amp
id|sk-&gt;socket-&gt;flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Since the socket is not locked, the buffer&n;&t;&t; * might be made available after the writeable check and&n;&t;&t; * before the bit is set.  This could cause a lost I/O&n;&t;&t; * signal.  tcp_poll() has a race breaker for this race&n;&t;&t; * condition.  Based on their implementation, we put&n;&t;&t; * in the following code to cover it as well.&n;&t;&t; */
r_if
c_cond
(paren
id|sctp_writeable
c_func
(paren
id|sk
)paren
)paren
id|mask
op_or_assign
id|POLLOUT
op_or
id|POLLWRNORM
suffix:semicolon
)brace
r_return
id|mask
suffix:semicolon
)brace
multiline_comment|/********************************************************************&n; * 2nd Level Abstractions&n; ********************************************************************/
DECL|function|sctp_bucket_create
r_static
id|sctp_bind_bucket_t
op_star
id|sctp_bucket_create
c_func
(paren
id|sctp_bind_hashbucket_t
op_star
id|head
comma
r_int
r_int
id|snum
)paren
(brace
id|sctp_bind_bucket_t
op_star
id|pp
suffix:semicolon
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;sctp_bucket_create() begins, snum=%d&bslash;n&quot;
comma
id|snum
)paren
suffix:semicolon
id|pp
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|sctp_bind_bucket_t
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pp
)paren
(brace
id|pp-&gt;port
op_assign
id|snum
suffix:semicolon
id|pp-&gt;fastreuse
op_assign
l_int|0
suffix:semicolon
id|pp-&gt;sk
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
(paren
id|pp-&gt;next
op_assign
id|head-&gt;chain
)paren
op_ne
l_int|NULL
)paren
id|pp-&gt;next-&gt;pprev
op_assign
op_amp
id|pp-&gt;next
suffix:semicolon
id|head-&gt;chain
op_assign
id|pp
suffix:semicolon
id|pp-&gt;pprev
op_assign
op_amp
id|head-&gt;chain
suffix:semicolon
)brace
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;sctp_bucket_create() ends, pp=%p&bslash;n&quot;
comma
id|pp
)paren
suffix:semicolon
r_return
id|pp
suffix:semicolon
)brace
multiline_comment|/* FIXME: Commments! */
DECL|function|__sctp_put_port
r_static
id|__inline__
r_void
id|__sctp_put_port
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
id|sctp_protocol_t
op_star
id|sctp_proto
op_assign
id|sctp_get_protocol
c_func
(paren
)paren
suffix:semicolon
id|sctp_bind_hashbucket_t
op_star
id|head
op_assign
op_amp
id|sctp_proto-&gt;port_hashtable
(braket
id|sctp_phashfn
c_func
(paren
id|inet_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|num
)paren
)braket
suffix:semicolon
id|sctp_bind_bucket_t
op_star
id|pp
suffix:semicolon
id|sctp_spin_lock
c_func
(paren
op_amp
id|head-&gt;lock
)paren
suffix:semicolon
id|pp
op_assign
(paren
id|sctp_bind_bucket_t
op_star
)paren
id|sk-&gt;prev
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;bind_next
)paren
id|sk-&gt;bind_next-&gt;bind_pprev
op_assign
id|sk-&gt;bind_pprev
suffix:semicolon
op_star
(paren
id|sk-&gt;bind_pprev
)paren
op_assign
id|sk-&gt;bind_next
suffix:semicolon
id|sk-&gt;prev
op_assign
l_int|NULL
suffix:semicolon
id|inet_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|num
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|pp-&gt;sk
)paren
(brace
r_if
c_cond
(paren
id|pp-&gt;next
)paren
id|pp-&gt;next-&gt;pprev
op_assign
id|pp-&gt;pprev
suffix:semicolon
op_star
(paren
id|pp-&gt;pprev
)paren
op_assign
id|pp-&gt;next
suffix:semicolon
id|kfree
c_func
(paren
id|pp
)paren
suffix:semicolon
)brace
id|sctp_spin_unlock
c_func
(paren
op_amp
id|head-&gt;lock
)paren
suffix:semicolon
)brace
DECL|function|sctp_put_port
r_void
id|sctp_put_port
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
id|sctp_local_bh_disable
c_func
(paren
)paren
suffix:semicolon
id|__sctp_put_port
c_func
(paren
id|sk
)paren
suffix:semicolon
id|sctp_local_bh_enable
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * The system picks an ephemeral port and choose an address set equivalent&n; * to binding with a wildcard address.&n; * One of those addresses will be the primary address for the association.&n; * This automatically enables the multihoming capability of SCTP.&n; */
DECL|function|sctp_autobind
r_static
r_int
id|sctp_autobind
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_union
id|sctp_addr
id|autoaddr
suffix:semicolon
r_struct
id|sctp_af
op_star
id|af
suffix:semicolon
r_int
r_int
id|port
suffix:semicolon
multiline_comment|/* Initialize a local sockaddr structure to INADDR_ANY. */
id|af
op_assign
id|sctp_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|pf-&gt;af
suffix:semicolon
id|port
op_assign
id|htons
c_func
(paren
id|inet_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|num
)paren
suffix:semicolon
id|af
op_member_access_from_pointer
id|inaddr_any
c_func
(paren
op_amp
id|autoaddr
comma
id|port
)paren
suffix:semicolon
r_return
id|sctp_do_bind
c_func
(paren
id|sk
comma
op_amp
id|autoaddr
comma
id|af-&gt;sockaddr_len
)paren
suffix:semicolon
)brace
multiline_comment|/* Parse out IPPROTO_SCTP CMSG headers.  Perform only minimal validation.&n; *&n; * From RFC 2292&n; * 4.2 The cmsghdr Structure *&n; *&n; * When ancillary data is sent or received, any number of ancillary data&n; * objects can be specified by the msg_control and msg_controllen members of&n; * the msghdr structure, because each object is preceded by&n; * a cmsghdr structure defining the object&squot;s length (the cmsg_len member).&n; * Historically Berkeley-derived implementations have passed only one object&n; * at a time, but this API allows multiple objects to be&n; * passed in a single call to sendmsg() or recvmsg(). The following example&n; * shows two ancillary data objects in a control buffer.&n; *&n; *   |&lt;--------------------------- msg_controllen --------------------------&gt;|&n; *   |                                                                       |&n; *&n; *   |&lt;----- ancillary data object -----&gt;|&lt;----- ancillary data object -----&gt;|&n; *&n; *   |&lt;---------- CMSG_SPACE() ---------&gt;|&lt;---------- CMSG_SPACE() ---------&gt;|&n; *   |                                   |                                   |&n; *&n; *   |&lt;---------- cmsg_len ----------&gt;|  |&lt;--------- cmsg_len -----------&gt;|  |&n; *&n; *   |&lt;--------- CMSG_LEN() ---------&gt;|  |&lt;-------- CMSG_LEN() ----------&gt;|  |&n; *   |                                |  |                                |  |&n; *&n; *   +-----+-----+-----+--+-----------+--+-----+-----+-----+--+-----------+--+&n; *   |cmsg_|cmsg_|cmsg_|XX|           |XX|cmsg_|cmsg_|cmsg_|XX|           |XX|&n; *&n; *   |len  |level|type |XX|cmsg_data[]|XX|len  |level|type |XX|cmsg_data[]|XX|&n; *&n; *   +-----+-----+-----+--+-----------+--+-----+-----+-----+--+-----------+--+&n; *    ^&n; *    |&n; *&n; * msg_control&n; * points here&n; */
DECL|function|sctp_msghdr_parse
id|SCTP_STATIC
r_int
id|sctp_msghdr_parse
c_func
(paren
r_const
r_struct
id|msghdr
op_star
id|msg
comma
id|sctp_cmsgs_t
op_star
id|cmsgs
)paren
(brace
r_struct
id|cmsghdr
op_star
id|cmsg
suffix:semicolon
r_for
c_loop
(paren
id|cmsg
op_assign
id|CMSG_FIRSTHDR
c_func
(paren
id|msg
)paren
suffix:semicolon
id|cmsg
op_ne
l_int|NULL
suffix:semicolon
id|cmsg
op_assign
id|CMSG_NXTHDR
c_func
(paren
(paren
r_struct
id|msghdr
op_star
)paren
id|msg
comma
id|cmsg
)paren
)paren
(brace
multiline_comment|/* Check for minimum length.  The SCM code has this check.  */
r_if
c_cond
(paren
id|cmsg-&gt;cmsg_len
template_param
id|msg-&gt;msg_controllen
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* Should we parse this header or ignore?  */
r_if
c_cond
(paren
id|cmsg-&gt;cmsg_level
op_ne
id|IPPROTO_SCTP
)paren
r_continue
suffix:semicolon
multiline_comment|/* Strictly check lengths following example in SCM code.  */
r_switch
c_cond
(paren
id|cmsg-&gt;cmsg_type
)paren
(brace
r_case
id|SCTP_INIT
suffix:colon
multiline_comment|/* SCTP Socket API Extension (draft 1)&n;&t;&t;&t; * 5.2.1 SCTP Initiation Structure (SCTP_INIT)&n;&t;&t;&t; *&n;&t;&t;&t; * This cmsghdr structure provides information for&n;&t;&t;&t; * initializing new SCTP associations with sendmsg().&n;&t;&t;&t; * The SCTP_INITMSG socket option uses this same data&n;&t;&t;&t; * structure.  This structure is not used for&n;&t;&t;&t; * recvmsg().&n;&t;&t;&t; *&n;&t;&t;&t; * cmsg_level    cmsg_type      cmsg_data[]&n;&t;&t;&t; * ------------  ------------   ----------------------&n;&t;&t;&t; * IPPROTO_SCTP  SCTP_INIT      struct sctp_initmsg&n;&t;&t;&t; */
r_if
c_cond
(paren
id|cmsg-&gt;cmsg_len
op_ne
id|CMSG_LEN
c_func
(paren
r_sizeof
(paren
r_struct
id|sctp_initmsg
)paren
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|cmsgs-&gt;init
op_assign
(paren
r_struct
id|sctp_initmsg
op_star
)paren
id|CMSG_DATA
c_func
(paren
id|cmsg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_SNDRCV
suffix:colon
multiline_comment|/* SCTP Socket API Extension (draft 1)&n;&t;&t;&t; * 5.2.2 SCTP Header Information Structure(SCTP_SNDRCV)&n;&t;&t;&t; *&n;&t;&t;&t; * This cmsghdr structure specifies SCTP options for&n;&t;&t;&t; * sendmsg() and describes SCTP header information&n;&t;&t;&t; * about a received message through recvmsg().&n;&t;&t;&t; *&n;&t;&t;&t; * cmsg_level    cmsg_type      cmsg_data[]&n;&t;&t;&t; * ------------  ------------   ----------------------&n;&t;&t;&t; * IPPROTO_SCTP  SCTP_SNDRCV    struct sctp_sndrcvinfo&n;&t;&t;&t; */
r_if
c_cond
(paren
id|cmsg-&gt;cmsg_len
op_ne
id|CMSG_LEN
c_func
(paren
r_sizeof
(paren
r_struct
id|sctp_sndrcvinfo
)paren
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|cmsgs-&gt;info
op_assign
(paren
r_struct
id|sctp_sndrcvinfo
op_star
)paren
id|CMSG_DATA
c_func
(paren
id|cmsg
)paren
suffix:semicolon
multiline_comment|/* Minimally, validate the sinfo_flags. */
r_if
c_cond
(paren
id|cmsgs-&gt;info-&gt;sinfo_flags
op_amp
op_complement
(paren
id|MSG_UNORDERED
op_or
id|MSG_ADDR_OVER
op_or
id|MSG_ABORT
op_or
id|MSG_EOF
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Wait for a packet..&n; * Note: This function is the same function as in core/datagram.c&n; * with a few modifications to make lksctp work.&n; */
DECL|function|sctp_wait_for_packet
r_static
r_int
id|sctp_wait_for_packet
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
op_star
id|err
comma
r_int
op_star
id|timeo_p
)paren
(brace
r_int
id|error
suffix:semicolon
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
id|__set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
id|add_wait_queue_exclusive
c_func
(paren
id|sk-&gt;sleep
comma
op_amp
id|wait
)paren
suffix:semicolon
multiline_comment|/* Socket errors? */
id|error
op_assign
id|sock_error
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skb_queue_empty
c_func
(paren
op_amp
id|sk-&gt;receive_queue
)paren
)paren
r_goto
id|ready
suffix:semicolon
multiline_comment|/* Socket shut down?  */
r_if
c_cond
(paren
id|sk-&gt;shutdown
op_amp
id|RCV_SHUTDOWN
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* Sequenced packets can come disconnected.  If so we report the&n;&t; * problem.&n;&t; */
id|error
op_assign
op_minus
id|ENOTCONN
suffix:semicolon
multiline_comment|/* Is there a good reason to think that we may receive some data?  */
r_if
c_cond
(paren
(paren
id|list_empty
c_func
(paren
op_amp
id|sctp_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|ep-&gt;asocs
)paren
)paren
op_logical_and
(paren
id|sk-&gt;state
op_ne
id|SCTP_SS_LISTENING
)paren
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* Handle signals.  */
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
r_goto
id|interrupted
suffix:semicolon
multiline_comment|/* Let another process have a go.  Since we are going to sleep&n;&t; * anyway.  Note: This may cause odd behaviors if the message&n;&t; * does not fit in the user&squot;s buffer, but this seems to be the&n;&t; * only way to honor MSG_DONTWAIT realistically.&n;&t; */
id|sctp_release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
op_star
id|timeo_p
op_assign
id|schedule_timeout
c_func
(paren
op_star
id|timeo_p
)paren
suffix:semicolon
id|sctp_lock_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
id|ready
suffix:colon
id|remove_wait_queue
c_func
(paren
id|sk-&gt;sleep
comma
op_amp
id|wait
)paren
suffix:semicolon
id|__set_current_state
c_func
(paren
id|TASK_RUNNING
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|interrupted
suffix:colon
id|error
op_assign
id|sock_intr_errno
c_func
(paren
op_star
id|timeo_p
)paren
suffix:semicolon
id|out
suffix:colon
id|remove_wait_queue
c_func
(paren
id|sk-&gt;sleep
comma
op_amp
id|wait
)paren
suffix:semicolon
id|__set_current_state
c_func
(paren
id|TASK_RUNNING
)paren
suffix:semicolon
op_star
id|err
op_assign
id|error
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/* Receive a datagram.&n; * Note: This is pretty much the same routine as in core/datagram.c&n; * with a few changes to make lksctp work.&n; */
DECL|function|sctp_skb_recv_datagram
r_static
r_struct
id|sk_buff
op_star
id|sctp_skb_recv_datagram
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|flags
comma
r_int
id|noblock
comma
r_int
op_star
id|err
)paren
(brace
r_int
id|error
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_int
id|timeo
suffix:semicolon
multiline_comment|/* Caller is allowed not to check sk-&gt;err before skb_recv_datagram()  */
id|error
op_assign
id|sock_error
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|no_packet
suffix:semicolon
id|timeo
op_assign
id|sock_rcvtimeo
c_func
(paren
id|sk
comma
id|noblock
)paren
suffix:semicolon
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;Timeout: timeo: %ld, MAX: %ld.&bslash;n&quot;
comma
id|timeo
comma
id|MAX_SCHEDULE_TIMEOUT
)paren
suffix:semicolon
r_do
(brace
multiline_comment|/* Again only user level code calls this function,&n;&t;&t; * so nothing interrupt level&n;&t;&t; * will suddenly eat the receive_queue.&n;&t;&t; *&n;&t;&t; *  Look at current nfs client by the way...&n;&t;&t; *  However, this function was corrent in any case. 8)&n;&t;&t; */
r_if
c_cond
(paren
id|flags
op_amp
id|MSG_PEEK
)paren
(brace
r_int
r_int
id|cpu_flags
suffix:semicolon
id|sctp_spin_lock_irqsave
c_func
(paren
op_amp
id|sk-&gt;receive_queue.lock
comma
id|cpu_flags
)paren
suffix:semicolon
id|skb
op_assign
id|skb_peek
c_func
(paren
op_amp
id|sk-&gt;receive_queue
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
)paren
id|atomic_inc
c_func
(paren
op_amp
id|skb-&gt;users
)paren
suffix:semicolon
id|sctp_spin_unlock_irqrestore
c_func
(paren
op_amp
id|sk-&gt;receive_queue.lock
comma
id|cpu_flags
)paren
suffix:semicolon
)brace
r_else
(brace
id|skb
op_assign
id|skb_dequeue
c_func
(paren
op_amp
id|sk-&gt;receive_queue
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|skb
)paren
r_return
id|skb
suffix:semicolon
multiline_comment|/* User doesn&squot;t want to wait.  */
id|error
op_assign
op_minus
id|EAGAIN
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|timeo
)paren
r_goto
id|no_packet
suffix:semicolon
)brace
r_while
c_loop
(paren
id|sctp_wait_for_packet
c_func
(paren
id|sk
comma
id|err
comma
op_amp
id|timeo
)paren
op_eq
l_int|0
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
id|no_packet
suffix:colon
op_star
id|err
op_assign
id|error
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Verify that this is a valid address. */
DECL|function|sctp_verify_addr
r_static
r_int
id|sctp_verify_addr
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_union
id|sctp_addr
op_star
id|addr
comma
r_int
id|len
)paren
(brace
r_struct
id|sctp_af
op_star
id|af
suffix:semicolon
multiline_comment|/* Verify basic sockaddr. */
id|af
op_assign
id|sctp_sockaddr_af
c_func
(paren
id|sctp_sk
c_func
(paren
id|sk
)paren
comma
id|addr
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|af
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* Is this a valid SCTP address?  */
r_if
c_cond
(paren
op_logical_neg
id|af
op_member_access_from_pointer
id|addr_valid
c_func
(paren
(paren
r_union
id|sctp_addr
op_star
)paren
id|addr
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Get the sndbuf space available at the time on the association.  */
DECL|function|sctp_wspace
r_static
r_inline
r_int
id|sctp_wspace
c_func
(paren
id|sctp_association_t
op_star
id|asoc
)paren
(brace
r_struct
id|sock
op_star
id|sk
op_assign
id|asoc-&gt;base.sk
suffix:semicolon
r_int
id|amt
op_assign
l_int|0
suffix:semicolon
id|amt
op_assign
id|sk-&gt;sndbuf
op_minus
id|asoc-&gt;sndbuf_used
suffix:semicolon
r_if
c_cond
(paren
id|amt
OL
l_int|0
)paren
id|amt
op_assign
l_int|0
suffix:semicolon
r_return
id|amt
suffix:semicolon
)brace
multiline_comment|/* Increment the used sndbuf space count of the corresponding association by&n; * the size of the outgoing data chunk.&n; * Also, set the skb destructor for sndbuf accounting later.&n; *&n; * Since it is always 1-1 between chunk and skb, and also a new skb is always&n; * allocated for chunk bundling in sctp_packet_transmit(), we can use the&n; * destructor in the data chunk skb for the purpose of the sndbuf space&n; * tracking.&n; */
DECL|function|sctp_set_owner_w
r_static
r_inline
r_void
id|sctp_set_owner_w
c_func
(paren
id|sctp_chunk_t
op_star
id|chunk
)paren
(brace
id|sctp_association_t
op_star
id|asoc
op_assign
id|chunk-&gt;asoc
suffix:semicolon
r_struct
id|sock
op_star
id|sk
op_assign
id|asoc-&gt;base.sk
suffix:semicolon
multiline_comment|/* The sndbuf space is tracked per association.  */
id|sctp_association_hold
c_func
(paren
id|asoc
)paren
suffix:semicolon
id|chunk-&gt;skb-&gt;destructor
op_assign
id|sctp_wfree
suffix:semicolon
multiline_comment|/* Save the chunk pointer in skb for sctp_wfree to use later.  */
op_star
(paren
(paren
id|sctp_chunk_t
op_star
op_star
)paren
(paren
id|chunk-&gt;skb-&gt;cb
)paren
)paren
op_assign
id|chunk
suffix:semicolon
id|asoc-&gt;sndbuf_used
op_add_assign
id|SCTP_DATA_SNDSIZE
c_func
(paren
id|chunk
)paren
suffix:semicolon
id|sk-&gt;wmem_queued
op_add_assign
id|SCTP_DATA_SNDSIZE
c_func
(paren
id|chunk
)paren
suffix:semicolon
)brace
multiline_comment|/* If sndbuf has changed, wake up per association sndbuf waiters.  */
DECL|function|__sctp_write_space
r_static
r_void
id|__sctp_write_space
c_func
(paren
id|sctp_association_t
op_star
id|asoc
)paren
(brace
r_struct
id|sock
op_star
id|sk
op_assign
id|asoc-&gt;base.sk
suffix:semicolon
r_struct
id|socket
op_star
id|sock
op_assign
id|sk-&gt;socket
suffix:semicolon
r_if
c_cond
(paren
(paren
id|sctp_wspace
c_func
(paren
id|asoc
)paren
OG
l_int|0
)paren
op_logical_and
id|sock
)paren
(brace
r_if
c_cond
(paren
id|waitqueue_active
c_func
(paren
op_amp
id|asoc-&gt;wait
)paren
)paren
id|wake_up_interruptible
c_func
(paren
op_amp
id|asoc-&gt;wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sctp_writeable
c_func
(paren
id|sk
)paren
)paren
(brace
r_if
c_cond
(paren
id|sk-&gt;sleep
op_logical_and
id|waitqueue_active
c_func
(paren
id|sk-&gt;sleep
)paren
)paren
id|wake_up_interruptible
c_func
(paren
id|sk-&gt;sleep
)paren
suffix:semicolon
multiline_comment|/* Note that we try to include the Async I/O support&n;&t;&t;&t; * here by modeling from the current TCP/UDP code.&n;&t;&t;&t; * We have not tested with it yet.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|sock-&gt;fasync_list
op_logical_and
op_logical_neg
(paren
id|sk-&gt;shutdown
op_amp
id|SEND_SHUTDOWN
)paren
)paren
id|sock_wake_async
c_func
(paren
id|sock
comma
l_int|2
comma
id|POLL_OUT
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Do accounting for the sndbuf space.&n; * Decrement the used sndbuf space of the corresponding association by the&n; * data size which was just transmitted(freed).&n; */
DECL|function|sctp_wfree
r_static
r_void
id|sctp_wfree
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
id|sctp_association_t
op_star
id|asoc
suffix:semicolon
id|sctp_chunk_t
op_star
id|chunk
suffix:semicolon
r_struct
id|sock
op_star
id|sk
suffix:semicolon
multiline_comment|/* Get the saved chunk pointer.  */
id|chunk
op_assign
op_star
(paren
(paren
id|sctp_chunk_t
op_star
op_star
)paren
(paren
id|skb-&gt;cb
)paren
)paren
suffix:semicolon
id|asoc
op_assign
id|chunk-&gt;asoc
suffix:semicolon
id|sk
op_assign
id|asoc-&gt;base.sk
suffix:semicolon
id|asoc-&gt;sndbuf_used
op_sub_assign
id|SCTP_DATA_SNDSIZE
c_func
(paren
id|chunk
)paren
suffix:semicolon
id|sk-&gt;wmem_queued
op_sub_assign
id|SCTP_DATA_SNDSIZE
c_func
(paren
id|chunk
)paren
suffix:semicolon
id|__sctp_write_space
c_func
(paren
id|asoc
)paren
suffix:semicolon
id|sctp_association_put
c_func
(paren
id|asoc
)paren
suffix:semicolon
)brace
multiline_comment|/* Helper function to wait for space in the sndbuf.  */
DECL|function|sctp_wait_for_sndbuf
r_static
r_int
id|sctp_wait_for_sndbuf
c_func
(paren
id|sctp_association_t
op_star
id|asoc
comma
r_int
op_star
id|timeo_p
comma
r_int
id|msg_len
)paren
(brace
r_struct
id|sock
op_star
id|sk
op_assign
id|asoc-&gt;base.sk
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
r_int
id|current_timeo
op_assign
op_star
id|timeo_p
suffix:semicolon
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;wait_for_sndbuf: asoc=%p, timeo=%ld, msg_len=%d&bslash;n&quot;
comma
id|asoc
comma
(paren
r_int
)paren
(paren
op_star
id|timeo_p
)paren
comma
id|msg_len
)paren
suffix:semicolon
multiline_comment|/* Wait on the association specific sndbuf space. */
id|add_wait_queue_exclusive
c_func
(paren
op_amp
id|asoc-&gt;wait
comma
op_amp
id|wait
)paren
suffix:semicolon
multiline_comment|/* Increment the association&squot;s refcnt.  */
id|sctp_association_hold
c_func
(paren
id|asoc
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_star
id|timeo_p
)paren
r_goto
id|do_nonblock
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;err
op_logical_or
id|asoc-&gt;state
op_ge
id|SCTP_STATE_SHUTDOWN_PENDING
op_logical_or
id|asoc-&gt;base.dead
)paren
r_goto
id|do_error
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
r_goto
id|do_interrupted
suffix:semicolon
r_if
c_cond
(paren
id|msg_len
op_le
id|sctp_wspace
c_func
(paren
id|asoc
)paren
)paren
r_break
suffix:semicolon
multiline_comment|/* Let another process have a go.  Since we are going&n;&t;&t; * to sleep anyway.&n;&t;&t; */
id|sctp_release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
id|current_timeo
op_assign
id|schedule_timeout
c_func
(paren
id|current_timeo
)paren
suffix:semicolon
id|sctp_lock_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
op_star
id|timeo_p
op_assign
id|current_timeo
suffix:semicolon
)brace
id|out
suffix:colon
id|remove_wait_queue
c_func
(paren
op_amp
id|asoc-&gt;wait
comma
op_amp
id|wait
)paren
suffix:semicolon
multiline_comment|/* Release the association&squot;s refcnt.  */
id|sctp_association_put
c_func
(paren
id|asoc
)paren
suffix:semicolon
id|__set_current_state
c_func
(paren
id|TASK_RUNNING
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
id|do_error
suffix:colon
id|err
op_assign
op_minus
id|EPIPE
suffix:semicolon
r_goto
id|out
suffix:semicolon
id|do_interrupted
suffix:colon
id|err
op_assign
id|sock_intr_errno
c_func
(paren
op_star
id|timeo_p
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
id|do_nonblock
suffix:colon
id|err
op_assign
op_minus
id|EAGAIN
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* If socket sndbuf has changed, wake up all per association waiters.  */
DECL|function|sctp_write_space
r_void
id|sctp_write_space
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
id|sctp_association_t
op_star
id|asoc
suffix:semicolon
r_struct
id|list_head
op_star
id|pos
suffix:semicolon
multiline_comment|/* Wake up the tasks in each wait queue.  */
id|list_for_each
c_func
(paren
id|pos
comma
op_amp
(paren
(paren
id|sctp_sk
c_func
(paren
id|sk
)paren
)paren
op_member_access_from_pointer
id|ep-&gt;asocs
)paren
)paren
(brace
id|asoc
op_assign
id|list_entry
c_func
(paren
id|pos
comma
id|sctp_association_t
comma
id|asocs
)paren
suffix:semicolon
id|__sctp_write_space
c_func
(paren
id|asoc
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Is there any sndbuf space available on the socket?&n; *&n; * Note that wmem_queued is the sum of the send buffers on all of the&n; * associations on the same socket.  For a UDP-style socket with&n; * multiple associations, it is possible for it to be &quot;unwriteable&quot;&n; * prematurely.  I assume that this is acceptable because&n; * a premature &quot;unwriteable&quot; is better than an accidental &quot;writeable&quot; which&n; * would cause an unwanted block under certain circumstances.  For the 1-1&n; * UDP-style sockets or TCP-style sockets, this code should work.&n; *  - Daisy&n; */
DECL|function|sctp_writeable
r_static
r_int
id|sctp_writeable
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_int
id|amt
op_assign
l_int|0
suffix:semicolon
id|amt
op_assign
id|sk-&gt;sndbuf
op_minus
id|sk-&gt;wmem_queued
suffix:semicolon
r_if
c_cond
(paren
id|amt
OL
l_int|0
)paren
id|amt
op_assign
l_int|0
suffix:semicolon
r_return
id|amt
suffix:semicolon
)brace
multiline_comment|/* Wait for an association to go into ESTABLISHED state. If timeout is 0,&n; * returns immediately with EINPROGRESS.&n; */
DECL|function|sctp_wait_for_connect
r_static
r_int
id|sctp_wait_for_connect
c_func
(paren
id|sctp_association_t
op_star
id|asoc
comma
r_int
op_star
id|timeo_p
)paren
(brace
r_struct
id|sock
op_star
id|sk
op_assign
id|asoc-&gt;base.sk
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
r_int
id|current_timeo
op_assign
op_star
id|timeo_p
suffix:semicolon
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;%s: asoc=%p, timeo=%ld&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|asoc
comma
(paren
r_int
)paren
(paren
op_star
id|timeo_p
)paren
)paren
suffix:semicolon
id|add_wait_queue_exclusive
c_func
(paren
op_amp
id|asoc-&gt;wait
comma
op_amp
id|wait
)paren
suffix:semicolon
multiline_comment|/* Increment the association&squot;s refcnt.  */
id|sctp_association_hold
c_func
(paren
id|asoc
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|__set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_star
id|timeo_p
)paren
r_goto
id|do_nonblock
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;err
op_logical_or
id|asoc-&gt;state
op_ge
id|SCTP_STATE_SHUTDOWN_PENDING
op_logical_or
id|asoc-&gt;base.dead
)paren
r_goto
id|do_error
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
r_goto
id|do_interrupted
suffix:semicolon
r_if
c_cond
(paren
id|asoc-&gt;state
op_eq
id|SCTP_STATE_ESTABLISHED
)paren
r_break
suffix:semicolon
multiline_comment|/* Let another process have a go.  Since we are going&n;&t;&t; * to sleep anyway.&n;&t;&t; */
id|sctp_release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
id|current_timeo
op_assign
id|schedule_timeout
c_func
(paren
id|current_timeo
)paren
suffix:semicolon
id|sctp_lock_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
op_star
id|timeo_p
op_assign
id|current_timeo
suffix:semicolon
)brace
id|out
suffix:colon
id|remove_wait_queue
c_func
(paren
op_amp
id|asoc-&gt;wait
comma
op_amp
id|wait
)paren
suffix:semicolon
multiline_comment|/* Release the association&squot;s refcnt.  */
id|sctp_association_put
c_func
(paren
id|asoc
)paren
suffix:semicolon
id|__set_current_state
c_func
(paren
id|TASK_RUNNING
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
id|do_error
suffix:colon
id|err
op_assign
op_minus
id|ECONNABORTED
suffix:semicolon
r_goto
id|out
suffix:semicolon
id|do_interrupted
suffix:colon
id|err
op_assign
id|sock_intr_errno
c_func
(paren
op_star
id|timeo_p
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
id|do_nonblock
suffix:colon
id|err
op_assign
op_minus
id|EINPROGRESS
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* This proto struct describes the ULP interface for SCTP.  */
DECL|variable|sctp_prot
r_struct
id|proto
id|sctp_prot
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;SCTP&quot;
comma
dot
id|close
op_assign
id|sctp_close
comma
dot
id|connect
op_assign
id|sctp_connect
comma
dot
id|disconnect
op_assign
id|sctp_disconnect
comma
dot
id|accept
op_assign
id|sctp_accept
comma
dot
id|ioctl
op_assign
id|sctp_ioctl
comma
dot
id|init
op_assign
id|sctp_init_sock
comma
dot
id|destroy
op_assign
id|sctp_destroy_sock
comma
dot
id|shutdown
op_assign
id|sctp_shutdown
comma
dot
id|setsockopt
op_assign
id|sctp_setsockopt
comma
dot
id|getsockopt
op_assign
id|sctp_getsockopt
comma
dot
id|sendmsg
op_assign
id|sctp_sendmsg
comma
dot
id|recvmsg
op_assign
id|sctp_recvmsg
comma
dot
id|bind
op_assign
id|sctp_bind
comma
dot
id|backlog_rcv
op_assign
id|sctp_backlog_rcv
comma
dot
id|hash
op_assign
id|sctp_hash
comma
dot
id|unhash
op_assign
id|sctp_unhash
comma
dot
id|get_port
op_assign
id|sctp_get_port
comma
)brace
suffix:semicolon
eof
