multiline_comment|/* SCTP kernel reference Implementation&n; * (C) Copyright IBM Corp. 2001, 2004&n; * Copyright (c) 1999-2000 Cisco, Inc.&n; * Copyright (c) 1999-2001 Motorola, Inc.&n; * Copyright (c) 2001-2003 Intel Corp.&n; * Copyright (c) 2001-2002 Nokia, Inc.&n; * Copyright (c) 2001 La Monte H.P. Yarroll&n; *&n; * This file is part of the SCTP kernel reference Implementation&n; *&n; * These functions interface with the sockets layer to implement the&n; * SCTP Extensions for the Sockets API.&n; *&n; * Note that the descriptions from the specification are USER level&n; * functions--this file is the functions which populate the struct proto&n; * for SCTP which is the BOTTOM of the sockets interface.&n; *&n; * The SCTP reference implementation is free software;&n; * you can redistribute it and/or modify it under the terms of&n; * the GNU General Public License as published by&n; * the Free Software Foundation; either version 2, or (at your option)&n; * any later version.&n; *&n; * The SCTP reference implementation is distributed in the hope that it&n; * will be useful, but WITHOUT ANY WARRANTY; without even the implied&n; *                 ************************&n; * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&n; * See the GNU General Public License for more details.&n; *&n; * You should have received a copy of the GNU General Public License&n; * along with GNU CC; see the file COPYING.  If not, write to&n; * the Free Software Foundation, 59 Temple Place - Suite 330,&n; * Boston, MA 02111-1307, USA.&n; *&n; * Please send any bug reports or fixes you make to the&n; * email address(es):&n; *    lksctp developers &lt;lksctp-developers@lists.sourceforge.net&gt;&n; *&n; * Or submit a bug report through the following website:&n; *    http://www.sf.net/projects/lksctp&n; *&n; * Written or modified by:&n; *    La Monte H.P. Yarroll &lt;piggy@acm.org&gt;&n; *    Narasimha Budihal     &lt;narsi@refcode.org&gt;&n; *    Karl Knutson          &lt;karl@athena.chicago.il.us&gt;&n; *    Jon Grimm             &lt;jgrimm@us.ibm.com&gt;&n; *    Xingang Guo           &lt;xingang.guo@intel.com&gt;&n; *    Daisy Chang           &lt;daisyc@us.ibm.com&gt;&n; *    Sridhar Samudrala     &lt;samudrala@us.ibm.com&gt;&n; *    Inaky Perez-Gonzalez  &lt;inaky.gonzalez@intel.com&gt;&n; *    Ardelle Fan&t;    &lt;ardelle.fan@intel.com&gt;&n; *    Ryan Layer&t;    &lt;rmlayer@us.ibm.com&gt;&n; *    Anup Pemmaiah         &lt;pemmaiah@cc.usu.edu&gt;&n; *    Kevin Gao             &lt;kevin.gao@intel.com&gt;&n; *&n; * Any bugs reported given to us we will try to fix... any fixes shared will&n; * be incorporated into the next SCTP release.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/wait.h&gt;
macro_line|#include &lt;linux/time.h&gt;
macro_line|#include &lt;linux/ip.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/poll.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/crypto.h&gt;
macro_line|#include &lt;net/ip.h&gt;
macro_line|#include &lt;net/icmp.h&gt;
macro_line|#include &lt;net/route.h&gt;
macro_line|#include &lt;net/ipv6.h&gt;
macro_line|#include &lt;net/inet_common.h&gt;
macro_line|#include &lt;linux/socket.h&gt; /* for sa_family_t */
macro_line|#include &lt;net/sock.h&gt;
macro_line|#include &lt;net/sctp/sctp.h&gt;
macro_line|#include &lt;net/sctp/sm.h&gt;
multiline_comment|/* WARNING:  Please do not remove the SCTP_STATIC attribute to&n; * any of the functions below as they are used to export functions&n; * used by a project regression testsuite.&n; */
multiline_comment|/* Forward declarations for internal helper functions. */
r_static
r_int
id|sctp_writeable
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
suffix:semicolon
r_static
r_void
id|sctp_wfree
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
suffix:semicolon
r_static
r_int
id|sctp_wait_for_sndbuf
c_func
(paren
r_struct
id|sctp_association
op_star
comma
r_int
op_star
id|timeo_p
comma
r_int
id|msg_len
)paren
suffix:semicolon
r_static
r_int
id|sctp_wait_for_packet
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
op_star
id|err
comma
r_int
op_star
id|timeo_p
)paren
suffix:semicolon
r_static
r_int
id|sctp_wait_for_connect
c_func
(paren
r_struct
id|sctp_association
op_star
comma
r_int
op_star
id|timeo_p
)paren
suffix:semicolon
r_static
r_int
id|sctp_wait_for_accept
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|timeo
)paren
suffix:semicolon
r_static
r_void
id|sctp_wait_for_close
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|timeo
)paren
suffix:semicolon
r_static
r_struct
id|sctp_af
op_star
id|sctp_sockaddr_af
c_func
(paren
r_struct
id|sctp_opt
op_star
id|opt
comma
r_union
id|sctp_addr
op_star
id|addr
comma
r_int
id|len
)paren
suffix:semicolon
r_static
r_int
id|sctp_bindx_add
c_func
(paren
r_struct
id|sock
op_star
comma
r_struct
id|sockaddr
op_star
comma
r_int
)paren
suffix:semicolon
r_static
r_int
id|sctp_bindx_rem
c_func
(paren
r_struct
id|sock
op_star
comma
r_struct
id|sockaddr
op_star
comma
r_int
)paren
suffix:semicolon
r_static
r_int
id|sctp_send_asconf_add_ip
c_func
(paren
r_struct
id|sock
op_star
comma
r_struct
id|sockaddr
op_star
comma
r_int
)paren
suffix:semicolon
r_static
r_int
id|sctp_send_asconf_del_ip
c_func
(paren
r_struct
id|sock
op_star
comma
r_struct
id|sockaddr
op_star
comma
r_int
)paren
suffix:semicolon
r_static
r_int
id|sctp_send_asconf
c_func
(paren
r_struct
id|sctp_association
op_star
id|asoc
comma
r_struct
id|sctp_chunk
op_star
id|chunk
)paren
suffix:semicolon
r_static
r_int
id|sctp_do_bind
c_func
(paren
r_struct
id|sock
op_star
comma
r_union
id|sctp_addr
op_star
comma
r_int
)paren
suffix:semicolon
r_static
r_int
id|sctp_autobind
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
suffix:semicolon
r_static
r_void
id|sctp_sock_migrate
c_func
(paren
r_struct
id|sock
op_star
comma
r_struct
id|sock
op_star
comma
r_struct
id|sctp_association
op_star
comma
id|sctp_socket_type_t
)paren
suffix:semicolon
DECL|variable|sctp_hmac_alg
r_static
r_char
op_star
id|sctp_hmac_alg
op_assign
id|SCTP_COOKIE_HMAC_ALG
suffix:semicolon
r_extern
id|kmem_cache_t
op_star
id|sctp_bucket_cachep
suffix:semicolon
multiline_comment|/* Get the sndbuf space available at the time on the association.  */
DECL|function|sctp_wspace
r_static
r_inline
r_int
id|sctp_wspace
c_func
(paren
r_struct
id|sctp_association
op_star
id|asoc
)paren
(brace
r_struct
id|sock
op_star
id|sk
op_assign
id|asoc-&gt;base.sk
suffix:semicolon
r_int
id|amt
op_assign
l_int|0
suffix:semicolon
id|amt
op_assign
id|sk-&gt;sk_sndbuf
op_minus
id|asoc-&gt;sndbuf_used
suffix:semicolon
r_if
c_cond
(paren
id|amt
OL
l_int|0
)paren
id|amt
op_assign
l_int|0
suffix:semicolon
r_return
id|amt
suffix:semicolon
)brace
multiline_comment|/* Increment the used sndbuf space count of the corresponding association by&n; * the size of the outgoing data chunk.&n; * Also, set the skb destructor for sndbuf accounting later.&n; *&n; * Since it is always 1-1 between chunk and skb, and also a new skb is always&n; * allocated for chunk bundling in sctp_packet_transmit(), we can use the&n; * destructor in the data chunk skb for the purpose of the sndbuf space&n; * tracking.&n; */
DECL|function|sctp_set_owner_w
r_static
r_inline
r_void
id|sctp_set_owner_w
c_func
(paren
r_struct
id|sctp_chunk
op_star
id|chunk
)paren
(brace
r_struct
id|sctp_association
op_star
id|asoc
op_assign
id|chunk-&gt;asoc
suffix:semicolon
r_struct
id|sock
op_star
id|sk
op_assign
id|asoc-&gt;base.sk
suffix:semicolon
multiline_comment|/* The sndbuf space is tracked per association.  */
id|sctp_association_hold
c_func
(paren
id|asoc
)paren
suffix:semicolon
id|chunk-&gt;skb-&gt;destructor
op_assign
id|sctp_wfree
suffix:semicolon
multiline_comment|/* Save the chunk pointer in skb for sctp_wfree to use later.  */
op_star
(paren
(paren
r_struct
id|sctp_chunk
op_star
op_star
)paren
(paren
id|chunk-&gt;skb-&gt;cb
)paren
)paren
op_assign
id|chunk
suffix:semicolon
id|asoc-&gt;sndbuf_used
op_add_assign
id|SCTP_DATA_SNDSIZE
c_func
(paren
id|chunk
)paren
suffix:semicolon
id|sk-&gt;sk_wmem_queued
op_add_assign
id|SCTP_DATA_SNDSIZE
c_func
(paren
id|chunk
)paren
suffix:semicolon
)brace
multiline_comment|/* Verify that this is a valid address. */
DECL|function|sctp_verify_addr
r_static
r_inline
r_int
id|sctp_verify_addr
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_union
id|sctp_addr
op_star
id|addr
comma
r_int
id|len
)paren
(brace
r_struct
id|sctp_af
op_star
id|af
suffix:semicolon
multiline_comment|/* Verify basic sockaddr. */
id|af
op_assign
id|sctp_sockaddr_af
c_func
(paren
id|sctp_sk
c_func
(paren
id|sk
)paren
comma
id|addr
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|af
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* Is this a valid SCTP address?  */
r_if
c_cond
(paren
op_logical_neg
id|af
op_member_access_from_pointer
id|addr_valid
c_func
(paren
id|addr
comma
id|sctp_sk
c_func
(paren
id|sk
)paren
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sctp_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|pf
op_member_access_from_pointer
id|send_verify
c_func
(paren
id|sctp_sk
c_func
(paren
id|sk
)paren
comma
(paren
id|addr
)paren
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Look up the association by its id.  If this is not a UDP-style&n; * socket, the ID field is always ignored.&n; */
DECL|function|sctp_id2assoc
r_struct
id|sctp_association
op_star
id|sctp_id2assoc
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
id|sctp_assoc_t
id|id
)paren
(brace
r_struct
id|sctp_association
op_star
id|asoc
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* If this is not a UDP-style socket, assoc id should be ignored. */
r_if
c_cond
(paren
op_logical_neg
id|sctp_style
c_func
(paren
id|sk
comma
id|UDP
)paren
)paren
(brace
multiline_comment|/* Return NULL if the socket state is not ESTABLISHED. It&n;&t;&t; * could be a TCP-style listening socket or a socket which&n;&t;&t; * hasn&squot;t yet called connect() to establish an association.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|sctp_sstate
c_func
(paren
id|sk
comma
id|ESTABLISHED
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/* Get the first and the only association from the list. */
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|sctp_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|ep-&gt;asocs
)paren
)paren
id|asoc
op_assign
id|list_entry
c_func
(paren
id|sctp_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|ep-&gt;asocs.next
comma
r_struct
id|sctp_association
comma
id|asocs
)paren
suffix:semicolon
r_return
id|asoc
suffix:semicolon
)brace
multiline_comment|/* Otherwise this is a UDP-style socket. */
r_if
c_cond
(paren
op_logical_neg
id|id
op_logical_or
(paren
id|id
op_eq
(paren
id|sctp_assoc_t
)paren
op_minus
l_int|1
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
id|spin_lock_bh
c_func
(paren
op_amp
id|sctp_assocs_id_lock
)paren
suffix:semicolon
id|asoc
op_assign
(paren
r_struct
id|sctp_association
op_star
)paren
id|idr_find
c_func
(paren
op_amp
id|sctp_assocs_id
comma
(paren
r_int
)paren
id|id
)paren
suffix:semicolon
id|spin_unlock_bh
c_func
(paren
op_amp
id|sctp_assocs_id_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|asoc
op_logical_or
(paren
id|asoc-&gt;base.sk
op_ne
id|sk
)paren
op_logical_or
id|asoc-&gt;base.dead
)paren
r_return
l_int|NULL
suffix:semicolon
r_return
id|asoc
suffix:semicolon
)brace
multiline_comment|/* Look up the transport from an address and an assoc id. If both address and&n; * id are specified, the associations matching the address and the id should be&n; * the same.&n; */
DECL|function|sctp_addr_id2transport
r_struct
id|sctp_transport
op_star
id|sctp_addr_id2transport
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sockaddr_storage
op_star
id|addr
comma
id|sctp_assoc_t
id|id
)paren
(brace
r_struct
id|sctp_association
op_star
id|addr_asoc
op_assign
l_int|NULL
comma
op_star
id|id_asoc
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|sctp_transport
op_star
id|transport
suffix:semicolon
r_union
id|sctp_addr
op_star
id|laddr
op_assign
(paren
r_union
id|sctp_addr
op_star
)paren
id|addr
suffix:semicolon
id|laddr-&gt;v4.sin_port
op_assign
id|ntohs
c_func
(paren
id|laddr-&gt;v4.sin_port
)paren
suffix:semicolon
id|addr_asoc
op_assign
id|sctp_endpoint_lookup_assoc
c_func
(paren
id|sctp_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|ep
comma
(paren
r_union
id|sctp_addr
op_star
)paren
id|addr
comma
op_amp
id|transport
)paren
suffix:semicolon
id|laddr-&gt;v4.sin_port
op_assign
id|htons
c_func
(paren
id|laddr-&gt;v4.sin_port
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|addr_asoc
)paren
r_return
l_int|NULL
suffix:semicolon
id|id_asoc
op_assign
id|sctp_id2assoc
c_func
(paren
id|sk
comma
id|id
)paren
suffix:semicolon
r_if
c_cond
(paren
id|id_asoc
op_logical_and
(paren
id|id_asoc
op_ne
id|addr_asoc
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
id|sctp_get_pf_specific
c_func
(paren
id|sk-&gt;sk_family
)paren
op_member_access_from_pointer
id|addr_v4map
c_func
(paren
id|sctp_sk
c_func
(paren
id|sk
)paren
comma
(paren
r_union
id|sctp_addr
op_star
)paren
id|addr
)paren
suffix:semicolon
r_return
id|transport
suffix:semicolon
)brace
multiline_comment|/* API 3.1.2 bind() - UDP Style Syntax&n; * The syntax of bind() is,&n; *&n; *   ret = bind(int sd, struct sockaddr *addr, int addrlen);&n; *&n; *   sd      - the socket descriptor returned by socket().&n; *   addr    - the address structure (struct sockaddr_in or struct&n; *             sockaddr_in6 [RFC 2553]),&n; *   addr_len - the size of the address structure.&n; */
DECL|function|sctp_bind
r_int
id|sctp_bind
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sockaddr
op_star
id|uaddr
comma
r_int
id|addr_len
)paren
(brace
r_int
id|retval
op_assign
l_int|0
suffix:semicolon
id|sctp_lock_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;sctp_bind(sk: %p, uaddr: %p, addr_len: %d)&bslash;n&quot;
comma
id|sk
comma
id|uaddr
comma
id|addr_len
)paren
suffix:semicolon
multiline_comment|/* Disallow binding twice. */
r_if
c_cond
(paren
op_logical_neg
id|sctp_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|ep-&gt;base.bind_addr.port
)paren
id|retval
op_assign
id|sctp_do_bind
c_func
(paren
id|sk
comma
(paren
r_union
id|sctp_addr
op_star
)paren
id|uaddr
comma
id|addr_len
)paren
suffix:semicolon
r_else
id|retval
op_assign
op_minus
id|EINVAL
suffix:semicolon
id|sctp_release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
r_static
r_int
id|sctp_get_port_local
c_func
(paren
r_struct
id|sock
op_star
comma
r_union
id|sctp_addr
op_star
)paren
suffix:semicolon
multiline_comment|/* Verify this is a valid sockaddr. */
DECL|function|sctp_sockaddr_af
r_static
r_struct
id|sctp_af
op_star
id|sctp_sockaddr_af
c_func
(paren
r_struct
id|sctp_opt
op_star
id|opt
comma
r_union
id|sctp_addr
op_star
id|addr
comma
r_int
id|len
)paren
(brace
r_struct
id|sctp_af
op_star
id|af
suffix:semicolon
multiline_comment|/* Check minimum size.  */
r_if
c_cond
(paren
id|len
OL
r_sizeof
(paren
r_struct
id|sockaddr
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/* Does this PF support this AF? */
r_if
c_cond
(paren
op_logical_neg
id|opt-&gt;pf
op_member_access_from_pointer
id|af_supported
c_func
(paren
id|addr-&gt;sa.sa_family
comma
id|opt
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/* If we get this far, af is valid. */
id|af
op_assign
id|sctp_get_af_specific
c_func
(paren
id|addr-&gt;sa.sa_family
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
id|af-&gt;sockaddr_len
)paren
r_return
l_int|NULL
suffix:semicolon
r_return
id|af
suffix:semicolon
)brace
multiline_comment|/* Bind a local address either to an endpoint or to an association.  */
DECL|function|sctp_do_bind
id|SCTP_STATIC
r_int
id|sctp_do_bind
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_union
id|sctp_addr
op_star
id|addr
comma
r_int
id|len
)paren
(brace
r_struct
id|sctp_opt
op_star
id|sp
op_assign
id|sctp_sk
c_func
(paren
id|sk
)paren
suffix:semicolon
r_struct
id|sctp_endpoint
op_star
id|ep
op_assign
id|sp-&gt;ep
suffix:semicolon
r_struct
id|sctp_bind_addr
op_star
id|bp
op_assign
op_amp
id|ep-&gt;base.bind_addr
suffix:semicolon
r_struct
id|sctp_af
op_star
id|af
suffix:semicolon
r_int
r_int
id|snum
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;sctp_do_bind(sk: %p, newaddr: %p, len: %d)&bslash;n&quot;
comma
id|sk
comma
id|addr
comma
id|len
)paren
suffix:semicolon
multiline_comment|/* Common sockaddr verification. */
id|af
op_assign
id|sctp_sockaddr_af
c_func
(paren
id|sp
comma
id|addr
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|af
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* PF specific bind() address verification. */
r_if
c_cond
(paren
op_logical_neg
id|sp-&gt;pf
op_member_access_from_pointer
id|bind_verify
c_func
(paren
id|sp
comma
id|addr
)paren
)paren
r_return
op_minus
id|EADDRNOTAVAIL
suffix:semicolon
id|snum
op_assign
id|ntohs
c_func
(paren
id|addr-&gt;v4.sin_port
)paren
suffix:semicolon
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;sctp_do_bind: port: %d, new port: %d&bslash;n&quot;
comma
id|bp-&gt;port
comma
id|snum
)paren
suffix:semicolon
multiline_comment|/* We must either be unbound, or bind to the same port.  */
r_if
c_cond
(paren
id|bp-&gt;port
op_logical_and
(paren
id|snum
op_ne
id|bp-&gt;port
)paren
)paren
(brace
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;sctp_do_bind:&quot;
l_string|&quot; New port %d does not match existing port &quot;
l_string|&quot;%d.&bslash;n&quot;
comma
id|snum
comma
id|bp-&gt;port
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|snum
op_logical_and
id|snum
OL
id|PROT_SOCK
op_logical_and
op_logical_neg
id|capable
c_func
(paren
id|CAP_NET_BIND_SERVICE
)paren
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
multiline_comment|/* Make sure we are allowed to bind here.&n;&t; * The function sctp_get_port_local() does duplicate address&n;&t; * detection.&n;&t; */
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|sctp_get_port_local
c_func
(paren
id|sk
comma
id|addr
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|ret
op_eq
(paren
r_int
)paren
id|sk
)paren
(brace
multiline_comment|/* This endpoint has a conflicting address. */
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_else
(brace
r_return
op_minus
id|EADDRINUSE
suffix:semicolon
)brace
)brace
multiline_comment|/* Refresh ephemeral port.  */
r_if
c_cond
(paren
op_logical_neg
id|snum
)paren
id|snum
op_assign
id|inet_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|num
suffix:semicolon
multiline_comment|/* Add the address to the bind address list.  */
id|sctp_local_bh_disable
c_func
(paren
)paren
suffix:semicolon
id|sctp_write_lock
c_func
(paren
op_amp
id|ep-&gt;base.addr_lock
)paren
suffix:semicolon
multiline_comment|/* Use GFP_ATOMIC since BHs are disabled.  */
id|addr-&gt;v4.sin_port
op_assign
id|ntohs
c_func
(paren
id|addr-&gt;v4.sin_port
)paren
suffix:semicolon
id|ret
op_assign
id|sctp_add_bind_addr
c_func
(paren
id|bp
comma
id|addr
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
id|addr-&gt;v4.sin_port
op_assign
id|htons
c_func
(paren
id|addr-&gt;v4.sin_port
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ret
op_logical_and
op_logical_neg
id|bp-&gt;port
)paren
id|bp-&gt;port
op_assign
id|snum
suffix:semicolon
id|sctp_write_unlock
c_func
(paren
op_amp
id|ep-&gt;base.addr_lock
)paren
suffix:semicolon
id|sctp_local_bh_enable
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Copy back into socket for getsockname() use. */
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
(brace
id|inet_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|sport
op_assign
id|htons
c_func
(paren
id|inet_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|num
)paren
suffix:semicolon
id|af
op_member_access_from_pointer
id|to_sk_saddr
c_func
(paren
id|addr
comma
id|sk
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* ADDIP Section 4.1.1 Congestion Control of ASCONF Chunks&n; *&n; * R1) One and only one ASCONF Chunk MAY be in transit and unacknowledged &n; * at any one time.  If a sender, after sending an ASCONF chunk, decides&n; * it needs to transfer another ASCONF Chunk, it MUST wait until the &n; * ASCONF-ACK Chunk returns from the previous ASCONF Chunk before sending a&n; * subsequent ASCONF. Note this restriction binds each side, so at any &n; * time two ASCONF may be in-transit on any given association (one sent &n; * from each endpoint).&n; */
DECL|function|sctp_send_asconf
r_static
r_int
id|sctp_send_asconf
c_func
(paren
r_struct
id|sctp_association
op_star
id|asoc
comma
r_struct
id|sctp_chunk
op_star
id|chunk
)paren
(brace
r_int
id|retval
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* If there is an outstanding ASCONF chunk, queue it for later&n;&t; * transmission.&n;&t; */
r_if
c_cond
(paren
id|asoc-&gt;addip_last_asconf
)paren
(brace
id|__skb_queue_tail
c_func
(paren
op_amp
id|asoc-&gt;addip_chunks
comma
(paren
r_struct
id|sk_buff
op_star
)paren
id|chunk
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* Hold the chunk until an ASCONF_ACK is received. */
id|sctp_chunk_hold
c_func
(paren
id|chunk
)paren
suffix:semicolon
id|retval
op_assign
id|sctp_primitive_ASCONF
c_func
(paren
id|asoc
comma
id|chunk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
id|sctp_chunk_free
c_func
(paren
id|chunk
)paren
suffix:semicolon
r_else
id|asoc-&gt;addip_last_asconf
op_assign
id|chunk
suffix:semicolon
id|out
suffix:colon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/* Add a list of addresses as bind addresses to local endpoint or&n; * association.&n; *&n; * Basically run through each address specified in the addrs/addrcnt&n; * array/length pair, determine if it is IPv6 or IPv4 and call&n; * sctp_do_bind() on it.&n; *&n; * If any of them fails, then the operation will be reversed and the&n; * ones that were added will be removed.&n; *&n; * Only sctp_setsockopt_bindx() is supposed to call this function.&n; */
DECL|function|sctp_bindx_add
r_int
id|sctp_bindx_add
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sockaddr
op_star
id|addrs
comma
r_int
id|addrcnt
)paren
(brace
r_int
id|cnt
suffix:semicolon
r_int
id|retval
op_assign
l_int|0
suffix:semicolon
r_void
op_star
id|addr_buf
suffix:semicolon
r_struct
id|sockaddr
op_star
id|sa_addr
suffix:semicolon
r_struct
id|sctp_af
op_star
id|af
suffix:semicolon
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;sctp_bindx_add (sk: %p, addrs: %p, addrcnt: %d)&bslash;n&quot;
comma
id|sk
comma
id|addrs
comma
id|addrcnt
)paren
suffix:semicolon
id|addr_buf
op_assign
id|addrs
suffix:semicolon
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
suffix:semicolon
id|cnt
OL
id|addrcnt
suffix:semicolon
id|cnt
op_increment
)paren
(brace
multiline_comment|/* The list may contain either IPv4 or IPv6 address;&n;&t;&t; * determine the address length for walking thru the list.&n;&t;&t; */
id|sa_addr
op_assign
(paren
r_struct
id|sockaddr
op_star
)paren
id|addr_buf
suffix:semicolon
id|af
op_assign
id|sctp_get_af_specific
c_func
(paren
id|sa_addr-&gt;sa_family
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|af
)paren
(brace
id|retval
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|err_bindx_add
suffix:semicolon
)brace
id|retval
op_assign
id|sctp_do_bind
c_func
(paren
id|sk
comma
(paren
r_union
id|sctp_addr
op_star
)paren
id|sa_addr
comma
id|af-&gt;sockaddr_len
)paren
suffix:semicolon
id|addr_buf
op_add_assign
id|af-&gt;sockaddr_len
suffix:semicolon
id|err_bindx_add
suffix:colon
r_if
c_cond
(paren
id|retval
OL
l_int|0
)paren
(brace
multiline_comment|/* Failed. Cleanup the ones that have been added */
r_if
c_cond
(paren
id|cnt
OG
l_int|0
)paren
id|sctp_bindx_rem
c_func
(paren
id|sk
comma
id|addrs
comma
id|cnt
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
)brace
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/* Send an ASCONF chunk with Add IP address parameters to all the peers of the&n; * associations that are part of the endpoint indicating that a list of local&n; * addresses are added to the endpoint.&n; *&n; * If any of the addresses is already in the bind address list of the &n; * association, we do not send the chunk for that association.  But it will not&n; * affect other associations.&n; *&n; * Only sctp_setsockopt_bindx() is supposed to call this function.&n; */
DECL|function|sctp_send_asconf_add_ip
r_static
r_int
id|sctp_send_asconf_add_ip
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sockaddr
op_star
id|addrs
comma
r_int
id|addrcnt
)paren
(brace
r_struct
id|sctp_opt
op_star
id|sp
suffix:semicolon
r_struct
id|sctp_endpoint
op_star
id|ep
suffix:semicolon
r_struct
id|sctp_association
op_star
id|asoc
suffix:semicolon
r_struct
id|sctp_bind_addr
op_star
id|bp
suffix:semicolon
r_struct
id|sctp_chunk
op_star
id|chunk
suffix:semicolon
r_struct
id|sctp_sockaddr_entry
op_star
id|laddr
suffix:semicolon
r_union
id|sctp_addr
op_star
id|addr
suffix:semicolon
r_void
op_star
id|addr_buf
suffix:semicolon
r_struct
id|sctp_af
op_star
id|af
suffix:semicolon
r_struct
id|list_head
op_star
id|pos
suffix:semicolon
r_struct
id|list_head
op_star
id|p
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|retval
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sctp_addip_enable
)paren
r_return
id|retval
suffix:semicolon
id|sp
op_assign
id|sctp_sk
c_func
(paren
id|sk
)paren
suffix:semicolon
id|ep
op_assign
id|sp-&gt;ep
suffix:semicolon
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;%s: (sk: %p, addrs: %p, addrcnt: %d)&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|sk
comma
id|addrs
comma
id|addrcnt
)paren
suffix:semicolon
id|list_for_each
c_func
(paren
id|pos
comma
op_amp
id|ep-&gt;asocs
)paren
(brace
id|asoc
op_assign
id|list_entry
c_func
(paren
id|pos
comma
r_struct
id|sctp_association
comma
id|asocs
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|asoc-&gt;peer.asconf_capable
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|asoc-&gt;peer.addip_disabled_mask
op_amp
id|SCTP_PARAM_ADD_IP
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sctp_state
c_func
(paren
id|asoc
comma
id|ESTABLISHED
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/* Check if any address in the packed array of addresses is&n;&t;         * in the bind address list of the association. If so, &n;&t;&t; * do not send the asconf chunk to its peer, but continue with &n;&t;&t; * other associations.&n;&t;&t; */
id|addr_buf
op_assign
id|addrs
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|addrcnt
suffix:semicolon
id|i
op_increment
)paren
(brace
id|addr
op_assign
(paren
r_union
id|sctp_addr
op_star
)paren
id|addr_buf
suffix:semicolon
id|af
op_assign
id|sctp_get_af_specific
c_func
(paren
id|addr-&gt;v4.sin_family
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|af
)paren
(brace
id|retval
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sctp_assoc_lookup_laddr
c_func
(paren
id|asoc
comma
id|addr
)paren
)paren
r_break
suffix:semicolon
id|addr_buf
op_add_assign
id|af-&gt;sockaddr_len
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
OL
id|addrcnt
)paren
r_continue
suffix:semicolon
multiline_comment|/* Use the first address in bind addr list of association as&n;&t;&t; * Address Parameter of ASCONF CHUNK.&n;&t;&t; */
id|sctp_read_lock
c_func
(paren
op_amp
id|asoc-&gt;base.addr_lock
)paren
suffix:semicolon
id|bp
op_assign
op_amp
id|asoc-&gt;base.bind_addr
suffix:semicolon
id|p
op_assign
id|bp-&gt;address_list.next
suffix:semicolon
id|laddr
op_assign
id|list_entry
c_func
(paren
id|p
comma
r_struct
id|sctp_sockaddr_entry
comma
id|list
)paren
suffix:semicolon
id|sctp_read_unlock
c_func
(paren
op_amp
id|asoc-&gt;base.addr_lock
)paren
suffix:semicolon
id|chunk
op_assign
id|sctp_make_asconf_update_ip
c_func
(paren
id|asoc
comma
op_amp
id|laddr-&gt;a
comma
id|addrs
comma
id|addrcnt
comma
id|SCTP_PARAM_ADD_IP
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|chunk
)paren
(brace
id|retval
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|retval
op_assign
id|sctp_send_asconf
c_func
(paren
id|asoc
comma
id|chunk
)paren
suffix:semicolon
multiline_comment|/* FIXME: After sending the add address ASCONF chunk, we&n;&t;&t; * cannot append the address to the association&squot;s binding&n;&t;&t; * address list, because the new address may be used as the&n;&t;&t; * source of a message sent to the peer before the ASCONF&n;&t;&t; * chunk is received by the peer.  So we should wait until&n;&t;&t; * ASCONF_ACK is received.&n;&t;&t; */
)brace
id|out
suffix:colon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/* Remove a list of addresses from bind addresses list.  Do not remove the&n; * last address.&n; *&n; * Basically run through each address specified in the addrs/addrcnt&n; * array/length pair, determine if it is IPv6 or IPv4 and call&n; * sctp_del_bind() on it.&n; *&n; * If any of them fails, then the operation will be reversed and the&n; * ones that were removed will be added back.&n; *&n; * At least one address has to be left; if only one address is&n; * available, the operation will return -EBUSY.&n; *&n; * Only sctp_setsockopt_bindx() is supposed to call this function.&n; */
DECL|function|sctp_bindx_rem
r_int
id|sctp_bindx_rem
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sockaddr
op_star
id|addrs
comma
r_int
id|addrcnt
)paren
(brace
r_struct
id|sctp_opt
op_star
id|sp
op_assign
id|sctp_sk
c_func
(paren
id|sk
)paren
suffix:semicolon
r_struct
id|sctp_endpoint
op_star
id|ep
op_assign
id|sp-&gt;ep
suffix:semicolon
r_int
id|cnt
suffix:semicolon
r_struct
id|sctp_bind_addr
op_star
id|bp
op_assign
op_amp
id|ep-&gt;base.bind_addr
suffix:semicolon
r_int
id|retval
op_assign
l_int|0
suffix:semicolon
r_union
id|sctp_addr
id|saveaddr
suffix:semicolon
r_void
op_star
id|addr_buf
suffix:semicolon
r_struct
id|sockaddr
op_star
id|sa_addr
suffix:semicolon
r_struct
id|sctp_af
op_star
id|af
suffix:semicolon
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;sctp_bindx_rem (sk: %p, addrs: %p, addrcnt: %d)&bslash;n&quot;
comma
id|sk
comma
id|addrs
comma
id|addrcnt
)paren
suffix:semicolon
id|addr_buf
op_assign
id|addrs
suffix:semicolon
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
suffix:semicolon
id|cnt
OL
id|addrcnt
suffix:semicolon
id|cnt
op_increment
)paren
(brace
multiline_comment|/* If the bind address list is empty or if there is only one&n;&t;&t; * bind address, there is nothing more to be removed (we need&n;&t;&t; * at least one address here).&n;&t;&t; */
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|bp-&gt;address_list
)paren
op_logical_or
(paren
id|sctp_list_single_entry
c_func
(paren
op_amp
id|bp-&gt;address_list
)paren
)paren
)paren
(brace
id|retval
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_goto
id|err_bindx_rem
suffix:semicolon
)brace
multiline_comment|/* The list may contain either IPv4 or IPv6 address;&n;&t;&t; * determine the address length to copy the address to&n;&t;&t; * saveaddr. &n;&t;&t; */
id|sa_addr
op_assign
(paren
r_struct
id|sockaddr
op_star
)paren
id|addr_buf
suffix:semicolon
id|af
op_assign
id|sctp_get_af_specific
c_func
(paren
id|sa_addr-&gt;sa_family
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|af
)paren
(brace
id|retval
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|err_bindx_rem
suffix:semicolon
)brace
id|memcpy
c_func
(paren
op_amp
id|saveaddr
comma
id|sa_addr
comma
id|af-&gt;sockaddr_len
)paren
suffix:semicolon
id|saveaddr.v4.sin_port
op_assign
id|ntohs
c_func
(paren
id|saveaddr.v4.sin_port
)paren
suffix:semicolon
r_if
c_cond
(paren
id|saveaddr.v4.sin_port
op_ne
id|bp-&gt;port
)paren
(brace
id|retval
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|err_bindx_rem
suffix:semicolon
)brace
multiline_comment|/* FIXME - There is probably a need to check if sk-&gt;sk_saddr and&n;&t;&t; * sk-&gt;sk_rcv_addr are currently set to one of the addresses to&n;&t;&t; * be removed. This is something which needs to be looked into&n;&t;&t; * when we are fixing the outstanding issues with multi-homing&n;&t;&t; * socket routing and failover schemes. Refer to comments in&n;&t;&t; * sctp_do_bind(). -daisy&n;&t;&t; */
id|sctp_local_bh_disable
c_func
(paren
)paren
suffix:semicolon
id|sctp_write_lock
c_func
(paren
op_amp
id|ep-&gt;base.addr_lock
)paren
suffix:semicolon
id|retval
op_assign
id|sctp_del_bind_addr
c_func
(paren
id|bp
comma
op_amp
id|saveaddr
)paren
suffix:semicolon
id|sctp_write_unlock
c_func
(paren
op_amp
id|ep-&gt;base.addr_lock
)paren
suffix:semicolon
id|sctp_local_bh_enable
c_func
(paren
)paren
suffix:semicolon
id|addr_buf
op_add_assign
id|af-&gt;sockaddr_len
suffix:semicolon
id|err_bindx_rem
suffix:colon
r_if
c_cond
(paren
id|retval
OL
l_int|0
)paren
(brace
multiline_comment|/* Failed. Add the ones that has been removed back */
r_if
c_cond
(paren
id|cnt
OG
l_int|0
)paren
id|sctp_bindx_add
c_func
(paren
id|sk
comma
id|addrs
comma
id|cnt
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
)brace
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/* Send an ASCONF chunk with Delete IP address parameters to all the peers of&n; * the associations that are part of the endpoint indicating that a list of&n; * local addresses are removed from the endpoint.&n; *&n; * If any of the addresses is already in the bind address list of the &n; * association, we do not send the chunk for that association.  But it will not&n; * affect other associations.&n; *&n; * Only sctp_setsockopt_bindx() is supposed to call this function.&n; */
DECL|function|sctp_send_asconf_del_ip
r_static
r_int
id|sctp_send_asconf_del_ip
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sockaddr
op_star
id|addrs
comma
r_int
id|addrcnt
)paren
(brace
r_struct
id|sctp_opt
op_star
id|sp
suffix:semicolon
r_struct
id|sctp_endpoint
op_star
id|ep
suffix:semicolon
r_struct
id|sctp_association
op_star
id|asoc
suffix:semicolon
r_struct
id|sctp_bind_addr
op_star
id|bp
suffix:semicolon
r_struct
id|sctp_chunk
op_star
id|chunk
suffix:semicolon
r_union
id|sctp_addr
op_star
id|laddr
suffix:semicolon
r_void
op_star
id|addr_buf
suffix:semicolon
r_struct
id|sctp_af
op_star
id|af
suffix:semicolon
r_struct
id|list_head
op_star
id|pos
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|retval
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sctp_addip_enable
)paren
r_return
id|retval
suffix:semicolon
id|sp
op_assign
id|sctp_sk
c_func
(paren
id|sk
)paren
suffix:semicolon
id|ep
op_assign
id|sp-&gt;ep
suffix:semicolon
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;%s: (sk: %p, addrs: %p, addrcnt: %d)&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|sk
comma
id|addrs
comma
id|addrcnt
)paren
suffix:semicolon
id|list_for_each
c_func
(paren
id|pos
comma
op_amp
id|ep-&gt;asocs
)paren
(brace
id|asoc
op_assign
id|list_entry
c_func
(paren
id|pos
comma
r_struct
id|sctp_association
comma
id|asocs
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|asoc-&gt;peer.asconf_capable
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|asoc-&gt;peer.addip_disabled_mask
op_amp
id|SCTP_PARAM_DEL_IP
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sctp_state
c_func
(paren
id|asoc
comma
id|ESTABLISHED
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/* Check if any address in the packed array of addresses is&n;&t;         * not present in the bind address list of the association.&n;&t;&t; * If so, do not send the asconf chunk to its peer, but&n;&t;&t; * continue with other associations.&n;&t;&t; */
id|addr_buf
op_assign
id|addrs
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|addrcnt
suffix:semicolon
id|i
op_increment
)paren
(brace
id|laddr
op_assign
(paren
r_union
id|sctp_addr
op_star
)paren
id|addr_buf
suffix:semicolon
id|af
op_assign
id|sctp_get_af_specific
c_func
(paren
id|laddr-&gt;v4.sin_family
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|af
)paren
(brace
id|retval
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|sctp_assoc_lookup_laddr
c_func
(paren
id|asoc
comma
id|laddr
)paren
)paren
r_break
suffix:semicolon
id|addr_buf
op_add_assign
id|af-&gt;sockaddr_len
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
OL
id|addrcnt
)paren
r_continue
suffix:semicolon
multiline_comment|/* Find one address in the association&squot;s bind address list&n;&t;&t; * that is not in the packed array of addresses. This is to&n;&t;&t; * make sure that we do not delete all the addresses in the&n;&t;&t; * association.&n;&t;&t; */
id|sctp_read_lock
c_func
(paren
op_amp
id|asoc-&gt;base.addr_lock
)paren
suffix:semicolon
id|bp
op_assign
op_amp
id|asoc-&gt;base.bind_addr
suffix:semicolon
id|laddr
op_assign
id|sctp_find_unmatch_addr
c_func
(paren
id|bp
comma
(paren
r_union
id|sctp_addr
op_star
)paren
id|addrs
comma
id|addrcnt
comma
id|sp
)paren
suffix:semicolon
id|sctp_read_unlock
c_func
(paren
op_amp
id|asoc-&gt;base.addr_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|laddr
)paren
r_continue
suffix:semicolon
id|chunk
op_assign
id|sctp_make_asconf_update_ip
c_func
(paren
id|asoc
comma
id|laddr
comma
id|addrs
comma
id|addrcnt
comma
id|SCTP_PARAM_DEL_IP
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|chunk
)paren
(brace
id|retval
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|retval
op_assign
id|sctp_send_asconf
c_func
(paren
id|asoc
comma
id|chunk
)paren
suffix:semicolon
multiline_comment|/* FIXME: After sending the delete address ASCONF chunk, we&n;&t;&t; * cannot remove the addresses from the association&squot;s bind&n;&t;&t; * address list, because there maybe some packet send to&n;&t;&t; * the delete addresses, so we should wait until ASCONF_ACK&n;&t;&t; * packet is received.&n;&t;&t; */
)brace
id|out
suffix:colon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/* Helper for tunneling sctp_bindx() requests through sctp_setsockopt()&n; *&n; * API 8.1&n; * int sctp_bindx(int sd, struct sockaddr *addrs, int addrcnt,&n; *                int flags);&n; *&n; * If sd is an IPv4 socket, the addresses passed must be IPv4 addresses.&n; * If the sd is an IPv6 socket, the addresses passed can either be IPv4&n; * or IPv6 addresses.&n; *&n; * A single address may be specified as INADDR_ANY or IN6ADDR_ANY, see&n; * Section 3.1.2 for this usage.&n; *&n; * addrs is a pointer to an array of one or more socket addresses. Each&n; * address is contained in its appropriate structure (i.e. struct&n; * sockaddr_in or struct sockaddr_in6) the family of the address type&n; * must be used to distengish the address length (note that this&n; * representation is termed a &quot;packed array&quot; of addresses). The caller&n; * specifies the number of addresses in the array with addrcnt.&n; *&n; * On success, sctp_bindx() returns 0. On failure, sctp_bindx() returns&n; * -1, and sets errno to the appropriate error code.&n; *&n; * For SCTP, the port given in each socket address must be the same, or&n; * sctp_bindx() will fail, setting errno to EINVAL.&n; *&n; * The flags parameter is formed from the bitwise OR of zero or more of&n; * the following currently defined flags:&n; *&n; * SCTP_BINDX_ADD_ADDR&n; *&n; * SCTP_BINDX_REM_ADDR&n; *&n; * SCTP_BINDX_ADD_ADDR directs SCTP to add the given addresses to the&n; * association, and SCTP_BINDX_REM_ADDR directs SCTP to remove the given&n; * addresses from the association. The two flags are mutually exclusive;&n; * if both are given, sctp_bindx() will fail with EINVAL. A caller may&n; * not remove all addresses from an association; sctp_bindx() will&n; * reject such an attempt with EINVAL.&n; *&n; * An application can use sctp_bindx(SCTP_BINDX_ADD_ADDR) to associate&n; * additional addresses with an endpoint after calling bind().  Or use&n; * sctp_bindx(SCTP_BINDX_REM_ADDR) to remove some addresses a listening&n; * socket is associated with so that no new association accepted will be&n; * associated with those addresses. If the endpoint supports dynamic&n; * address a SCTP_BINDX_REM_ADDR or SCTP_BINDX_ADD_ADDR may cause a&n; * endpoint to send the appropriate message to the peer to change the&n; * peers address lists.&n; *&n; * Adding and removing addresses from a connected association is&n; * optional functionality. Implementations that do not support this&n; * functionality should return EOPNOTSUPP.&n; *&n; * Basically do nothing but copying the addresses from user to kernel&n; * land and invoking either sctp_bindx_add() or sctp_bindx_rem() on the sk.&n; * This is used for tunneling the sctp_bindx() request through sctp_setsockopt() * from userspace.&n; *&n; * We don&squot;t use copy_from_user() for optimization: we first do the&n; * sanity checks (buffer size -fast- and access check-healthy&n; * pointer); if all of those succeed, then we can alloc the memory&n; * (expensive operation) needed to copy the data to kernel. Then we do&n; * the copying without checking the user space area&n; * (__copy_from_user()).&n; *&n; * On exit there is no need to do sockfd_put(), sys_setsockopt() does&n; * it.&n; *&n; * sk        The sk of the socket&n; * addrs     The pointer to the addresses in user land&n; * addrssize Size of the addrs buffer&n; * op        Operation to perform (add or remove, see the flags of&n; *           sctp_bindx)&n; *&n; * Returns 0 if ok, &lt;0 errno code on error.&n; */
DECL|function|sctp_setsockopt_bindx
id|SCTP_STATIC
r_int
id|sctp_setsockopt_bindx
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sockaddr
id|__user
op_star
id|addrs
comma
r_int
id|addrs_size
comma
r_int
id|op
)paren
(brace
r_struct
id|sockaddr
op_star
id|kaddrs
suffix:semicolon
r_int
id|err
suffix:semicolon
r_int
id|addrcnt
op_assign
l_int|0
suffix:semicolon
r_int
id|walk_size
op_assign
l_int|0
suffix:semicolon
r_struct
id|sockaddr
op_star
id|sa_addr
suffix:semicolon
r_void
op_star
id|addr_buf
suffix:semicolon
r_struct
id|sctp_af
op_star
id|af
suffix:semicolon
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;sctp_setsocktopt_bindx: sk %p addrs %p&quot;
l_string|&quot; addrs_size %d opt %d&bslash;n&quot;
comma
id|sk
comma
id|addrs
comma
id|addrs_size
comma
id|op
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|addrs_size
op_le
l_int|0
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* Check the user passed a healthy pointer.  */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|access_ok
c_func
(paren
id|VERIFY_READ
comma
id|addrs
comma
id|addrs_size
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
multiline_comment|/* Alloc space for the address array in kernel memory.  */
id|kaddrs
op_assign
(paren
r_struct
id|sockaddr
op_star
)paren
id|kmalloc
c_func
(paren
id|addrs_size
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|kaddrs
)paren
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
id|__copy_from_user
c_func
(paren
id|kaddrs
comma
id|addrs
comma
id|addrs_size
)paren
)paren
(brace
id|kfree
c_func
(paren
id|kaddrs
)paren
suffix:semicolon
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
multiline_comment|/* Walk through the addrs buffer and count the number of addresses. */
id|addr_buf
op_assign
id|kaddrs
suffix:semicolon
r_while
c_loop
(paren
id|walk_size
OL
id|addrs_size
)paren
(brace
id|sa_addr
op_assign
(paren
r_struct
id|sockaddr
op_star
)paren
id|addr_buf
suffix:semicolon
id|af
op_assign
id|sctp_get_af_specific
c_func
(paren
id|sa_addr-&gt;sa_family
)paren
suffix:semicolon
multiline_comment|/* If the address family is not supported or if this address&n;&t;&t; * causes the address buffer to overflow return EINVAL.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|af
op_logical_or
(paren
id|walk_size
op_plus
id|af-&gt;sockaddr_len
)paren
OG
id|addrs_size
)paren
(brace
id|kfree
c_func
(paren
id|kaddrs
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|addrcnt
op_increment
suffix:semicolon
id|addr_buf
op_add_assign
id|af-&gt;sockaddr_len
suffix:semicolon
id|walk_size
op_add_assign
id|af-&gt;sockaddr_len
suffix:semicolon
)brace
multiline_comment|/* Do the work. */
r_switch
c_cond
(paren
id|op
)paren
(brace
r_case
id|SCTP_BINDX_ADD_ADDR
suffix:colon
id|err
op_assign
id|sctp_bindx_add
c_func
(paren
id|sk
comma
id|kaddrs
comma
id|addrcnt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out
suffix:semicolon
id|err
op_assign
id|sctp_send_asconf_add_ip
c_func
(paren
id|sk
comma
id|kaddrs
comma
id|addrcnt
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_BINDX_REM_ADDR
suffix:colon
id|err
op_assign
id|sctp_bindx_rem
c_func
(paren
id|sk
comma
id|kaddrs
comma
id|addrcnt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out
suffix:semicolon
id|err
op_assign
id|sctp_send_asconf_del_ip
c_func
(paren
id|sk
comma
id|kaddrs
comma
id|addrcnt
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
)brace
suffix:semicolon
id|out
suffix:colon
id|kfree
c_func
(paren
id|kaddrs
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/* API 3.1.4 close() - UDP Style Syntax&n; * Applications use close() to perform graceful shutdown (as described in&n; * Section 10.1 of [SCTP]) on ALL the associations currently represented&n; * by a UDP-style socket.&n; *&n; * The syntax is&n; *&n; *   ret = close(int sd);&n; *&n; *   sd      - the socket descriptor of the associations to be closed.&n; *&n; * To gracefully shutdown a specific association represented by the&n; * UDP-style socket, an application should use the sendmsg() call,&n; * passing no user data, but including the appropriate flag in the&n; * ancillary data (see Section xxxx).&n; *&n; * If sd in the close() call is a branched-off socket representing only&n; * one association, the shutdown is performed on that association only.&n; *&n; * 4.1.6 close() - TCP Style Syntax&n; *&n; * Applications use close() to gracefully close down an association.&n; *&n; * The syntax is:&n; *&n; *    int close(int sd);&n; *&n; *      sd      - the socket descriptor of the association to be closed.&n; *&n; * After an application calls close() on a socket descriptor, no further&n; * socket operations will succeed on that descriptor.&n; *&n; * API 7.1.4 SO_LINGER&n; *&n; * An application using the TCP-style socket can use this option to&n; * perform the SCTP ABORT primitive.  The linger option structure is:&n; *&n; *  struct  linger {&n; *     int     l_onoff;                // option on/off&n; *     int     l_linger;               // linger time&n; * };&n; *&n; * To enable the option, set l_onoff to 1.  If the l_linger value is set&n; * to 0, calling close() is the same as the ABORT primitive.  If the&n; * value is set to a negative value, the setsockopt() call will return&n; * an error.  If the value is set to a positive value linger_time, the&n; * close() can be blocked for at most linger_time ms.  If the graceful&n; * shutdown phase does not finish during this period, close() will&n; * return but the graceful shutdown phase continues in the system.&n; */
DECL|function|sctp_close
id|SCTP_STATIC
r_void
id|sctp_close
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|timeout
)paren
(brace
r_struct
id|sctp_endpoint
op_star
id|ep
suffix:semicolon
r_struct
id|sctp_association
op_star
id|asoc
suffix:semicolon
r_struct
id|list_head
op_star
id|pos
comma
op_star
id|temp
suffix:semicolon
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;sctp_close(sk: 0x%p, timeout:%ld)&bslash;n&quot;
comma
id|sk
comma
id|timeout
)paren
suffix:semicolon
id|sctp_lock_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
id|sk-&gt;sk_shutdown
op_assign
id|SHUTDOWN_MASK
suffix:semicolon
id|ep
op_assign
id|sctp_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|ep
suffix:semicolon
multiline_comment|/* Walk all associations on a socket, not on an endpoint.  */
id|list_for_each_safe
c_func
(paren
id|pos
comma
id|temp
comma
op_amp
id|ep-&gt;asocs
)paren
(brace
id|asoc
op_assign
id|list_entry
c_func
(paren
id|pos
comma
r_struct
id|sctp_association
comma
id|asocs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sctp_style
c_func
(paren
id|sk
comma
id|TCP
)paren
)paren
(brace
multiline_comment|/* A closed association can still be in the list if&n;&t;&t;&t; * it belongs to a TCP-style listening socket that is&n;&t;&t;&t; * not yet accepted. If so, free it. If not, send an&n;&t;&t;&t; * ABORT or SHUTDOWN based on the linger options.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|sctp_state
c_func
(paren
id|asoc
comma
id|CLOSED
)paren
)paren
(brace
id|sctp_unhash_established
c_func
(paren
id|asoc
)paren
suffix:semicolon
id|sctp_association_free
c_func
(paren
id|asoc
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|sock_flag
c_func
(paren
id|sk
comma
id|SOCK_LINGER
)paren
op_logical_and
op_logical_neg
id|sk-&gt;sk_lingertime
)paren
id|sctp_primitive_ABORT
c_func
(paren
id|asoc
comma
l_int|NULL
)paren
suffix:semicolon
r_else
id|sctp_primitive_SHUTDOWN
c_func
(paren
id|asoc
comma
l_int|NULL
)paren
suffix:semicolon
)brace
r_else
id|sctp_primitive_SHUTDOWN
c_func
(paren
id|asoc
comma
l_int|NULL
)paren
suffix:semicolon
)brace
multiline_comment|/* Clean up any skbs sitting on the receive queue.  */
id|sctp_queue_purge_ulpevents
c_func
(paren
op_amp
id|sk-&gt;sk_receive_queue
)paren
suffix:semicolon
id|sctp_queue_purge_ulpevents
c_func
(paren
op_amp
id|sctp_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|pd_lobby
)paren
suffix:semicolon
multiline_comment|/* On a TCP-style socket, block for at most linger_time if set. */
r_if
c_cond
(paren
id|sctp_style
c_func
(paren
id|sk
comma
id|TCP
)paren
op_logical_and
id|timeout
)paren
id|sctp_wait_for_close
c_func
(paren
id|sk
comma
id|timeout
)paren
suffix:semicolon
multiline_comment|/* This will run the backlog queue.  */
id|sctp_release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
multiline_comment|/* Supposedly, no process has access to the socket, but&n;&t; * the net layers still may.&n;&t; */
id|sctp_local_bh_disable
c_func
(paren
)paren
suffix:semicolon
id|sctp_bh_lock_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
multiline_comment|/* Hold the sock, since sk_common_release() will put sock_put()&n;&t; * and we have just a little more cleanup.&n;&t; */
id|sock_hold
c_func
(paren
id|sk
)paren
suffix:semicolon
id|sk_common_release
c_func
(paren
id|sk
)paren
suffix:semicolon
id|sctp_bh_unlock_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
id|sctp_local_bh_enable
c_func
(paren
)paren
suffix:semicolon
id|sock_put
c_func
(paren
id|sk
)paren
suffix:semicolon
id|SCTP_DBG_OBJCNT_DEC
c_func
(paren
id|sock
)paren
suffix:semicolon
)brace
multiline_comment|/* Handle EPIPE error. */
DECL|function|sctp_error
r_static
r_int
id|sctp_error
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|flags
comma
r_int
id|err
)paren
(brace
r_if
c_cond
(paren
id|err
op_eq
op_minus
id|EPIPE
)paren
id|err
op_assign
id|sock_error
c_func
(paren
id|sk
)paren
ques
c_cond
suffix:colon
op_minus
id|EPIPE
suffix:semicolon
r_if
c_cond
(paren
id|err
op_eq
op_minus
id|EPIPE
op_logical_and
op_logical_neg
(paren
id|flags
op_amp
id|MSG_NOSIGNAL
)paren
)paren
id|send_sig
c_func
(paren
id|SIGPIPE
comma
id|current
comma
l_int|0
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/* API 3.1.3 sendmsg() - UDP Style Syntax&n; *&n; * An application uses sendmsg() and recvmsg() calls to transmit data to&n; * and receive data from its peer.&n; *&n; *  ssize_t sendmsg(int socket, const struct msghdr *message,&n; *                  int flags);&n; *&n; *  socket  - the socket descriptor of the endpoint.&n; *  message - pointer to the msghdr structure which contains a single&n; *            user message and possibly some ancillary data.&n; *&n; *            See Section 5 for complete description of the data&n; *            structures.&n; *&n; *  flags   - flags sent or received with the user message, see Section&n; *            5 for complete description of the flags.&n; *&n; * Note:  This function could use a rewrite especially when explicit&n; * connect support comes in.&n; */
multiline_comment|/* BUG:  We do not implement the equivalent of sk_stream_wait_memory(). */
id|SCTP_STATIC
r_int
id|sctp_msghdr_parse
c_func
(paren
r_const
r_struct
id|msghdr
op_star
comma
id|sctp_cmsgs_t
op_star
)paren
suffix:semicolon
DECL|function|sctp_sendmsg
id|SCTP_STATIC
r_int
id|sctp_sendmsg
c_func
(paren
r_struct
id|kiocb
op_star
id|iocb
comma
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|msghdr
op_star
id|msg
comma
r_int
id|msg_len
)paren
(brace
r_struct
id|sctp_opt
op_star
id|sp
suffix:semicolon
r_struct
id|sctp_endpoint
op_star
id|ep
suffix:semicolon
r_struct
id|sctp_association
op_star
id|new_asoc
op_assign
l_int|NULL
comma
op_star
id|asoc
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|sctp_transport
op_star
id|transport
comma
op_star
id|chunk_tp
suffix:semicolon
r_struct
id|sctp_chunk
op_star
id|chunk
suffix:semicolon
r_union
id|sctp_addr
id|to
suffix:semicolon
r_struct
id|sockaddr
op_star
id|msg_name
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|sctp_sndrcvinfo
id|default_sinfo
op_assign
(brace
l_int|0
)brace
suffix:semicolon
r_struct
id|sctp_sndrcvinfo
op_star
id|sinfo
suffix:semicolon
r_struct
id|sctp_initmsg
op_star
id|sinit
suffix:semicolon
id|sctp_assoc_t
id|associd
op_assign
l_int|0
suffix:semicolon
id|sctp_cmsgs_t
id|cmsgs
op_assign
(brace
l_int|NULL
)brace
suffix:semicolon
r_int
id|err
suffix:semicolon
id|sctp_scope_t
id|scope
suffix:semicolon
r_int
id|timeo
suffix:semicolon
id|__u16
id|sinfo_flags
op_assign
l_int|0
suffix:semicolon
r_struct
id|sctp_datamsg
op_star
id|datamsg
suffix:semicolon
r_struct
id|list_head
op_star
id|pos
suffix:semicolon
r_int
id|msg_flags
op_assign
id|msg-&gt;msg_flags
suffix:semicolon
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;sctp_sendmsg(sk: %p, msg: %p, msg_len: %zu)&bslash;n&quot;
comma
id|sk
comma
id|msg
comma
id|msg_len
)paren
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
id|sp
op_assign
id|sctp_sk
c_func
(paren
id|sk
)paren
suffix:semicolon
id|ep
op_assign
id|sp-&gt;ep
suffix:semicolon
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;Using endpoint: %s.&bslash;n&quot;
comma
id|ep-&gt;debug_name
)paren
suffix:semicolon
multiline_comment|/* We cannot send a message over a TCP-style listening socket. */
r_if
c_cond
(paren
id|sctp_style
c_func
(paren
id|sk
comma
id|TCP
)paren
op_logical_and
id|sctp_sstate
c_func
(paren
id|sk
comma
id|LISTENING
)paren
)paren
(brace
id|err
op_assign
op_minus
id|EPIPE
suffix:semicolon
r_goto
id|out_nounlock
suffix:semicolon
)brace
multiline_comment|/* Parse out the SCTP CMSGs.  */
id|err
op_assign
id|sctp_msghdr_parse
c_func
(paren
id|msg
comma
op_amp
id|cmsgs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;msghdr parse err = %x&bslash;n&quot;
comma
id|err
)paren
suffix:semicolon
r_goto
id|out_nounlock
suffix:semicolon
)brace
multiline_comment|/* Fetch the destination address for this packet.  This&n;&t; * address only selects the association--it is not necessarily&n;&t; * the address we will send to.&n;&t; * For a peeled-off socket, msg_name is ignored.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|sctp_style
c_func
(paren
id|sk
comma
id|UDP_HIGH_BANDWIDTH
)paren
op_logical_and
id|msg-&gt;msg_name
)paren
(brace
r_int
id|msg_namelen
op_assign
id|msg-&gt;msg_namelen
suffix:semicolon
id|err
op_assign
id|sctp_verify_addr
c_func
(paren
id|sk
comma
(paren
r_union
id|sctp_addr
op_star
)paren
id|msg-&gt;msg_name
comma
id|msg_namelen
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
r_if
c_cond
(paren
id|msg_namelen
OG
r_sizeof
(paren
id|to
)paren
)paren
id|msg_namelen
op_assign
r_sizeof
(paren
id|to
)paren
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|to
comma
id|msg-&gt;msg_name
comma
id|msg_namelen
)paren
suffix:semicolon
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;Just memcpy&squot;d. msg_name is &quot;
l_string|&quot;0x%x:%u.&bslash;n&quot;
comma
id|to.v4.sin_addr.s_addr
comma
id|to.v4.sin_port
)paren
suffix:semicolon
id|to.v4.sin_port
op_assign
id|ntohs
c_func
(paren
id|to.v4.sin_port
)paren
suffix:semicolon
id|msg_name
op_assign
id|msg-&gt;msg_name
suffix:semicolon
)brace
id|sinfo
op_assign
id|cmsgs.info
suffix:semicolon
id|sinit
op_assign
id|cmsgs.init
suffix:semicolon
multiline_comment|/* Did the user specify SNDRCVINFO?  */
r_if
c_cond
(paren
id|sinfo
)paren
(brace
id|sinfo_flags
op_assign
id|sinfo-&gt;sinfo_flags
suffix:semicolon
id|associd
op_assign
id|sinfo-&gt;sinfo_assoc_id
suffix:semicolon
)brace
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;msg_len: %zu, sinfo_flags: 0x%x&bslash;n&quot;
comma
id|msg_len
comma
id|sinfo_flags
)paren
suffix:semicolon
multiline_comment|/* MSG_EOF or MSG_ABORT cannot be set on a TCP-style socket. */
r_if
c_cond
(paren
id|sctp_style
c_func
(paren
id|sk
comma
id|TCP
)paren
op_logical_and
(paren
id|sinfo_flags
op_amp
(paren
id|MSG_EOF
op_or
id|MSG_ABORT
)paren
)paren
)paren
(brace
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|out_nounlock
suffix:semicolon
)brace
multiline_comment|/* If MSG_EOF is set, no data can be sent. Disallow sending zero&n;&t; * length messages when MSG_EOF|MSG_ABORT is not set.&n;&t; * If MSG_ABORT is set, the message length could be non zero with&n;&t; * the msg_iov set to the user abort reason.&n; &t; */
r_if
c_cond
(paren
(paren
(paren
id|sinfo_flags
op_amp
id|MSG_EOF
)paren
op_logical_and
(paren
id|msg_len
OG
l_int|0
)paren
)paren
op_logical_or
(paren
op_logical_neg
(paren
id|sinfo_flags
op_amp
(paren
id|MSG_EOF
op_or
id|MSG_ABORT
)paren
)paren
op_logical_and
(paren
id|msg_len
op_eq
l_int|0
)paren
)paren
)paren
(brace
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|out_nounlock
suffix:semicolon
)brace
multiline_comment|/* If MSG_ADDR_OVER is set, there must be an address&n;&t; * specified in msg_name.&n;&t; */
r_if
c_cond
(paren
(paren
id|sinfo_flags
op_amp
id|MSG_ADDR_OVER
)paren
op_logical_and
(paren
op_logical_neg
id|msg-&gt;msg_name
)paren
)paren
(brace
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|out_nounlock
suffix:semicolon
)brace
id|transport
op_assign
l_int|NULL
suffix:semicolon
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;About to look up association.&bslash;n&quot;
)paren
suffix:semicolon
id|sctp_lock_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
multiline_comment|/* If a msg_name has been specified, assume this is to be used.  */
r_if
c_cond
(paren
id|msg_name
)paren
(brace
multiline_comment|/* Look for a matching association on the endpoint. */
id|asoc
op_assign
id|sctp_endpoint_lookup_assoc
c_func
(paren
id|ep
comma
op_amp
id|to
comma
op_amp
id|transport
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|asoc
)paren
(brace
multiline_comment|/* If we could not find a matching association on the&n;&t;&t;&t; * endpoint, make sure that it is not a TCP-style&n;&t;&t;&t; * socket that already has an association or there is&n;&t;&t;&t; * no peeled-off association on another socket.&n;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|sctp_style
c_func
(paren
id|sk
comma
id|TCP
)paren
op_logical_and
id|sctp_sstate
c_func
(paren
id|sk
comma
id|ESTABLISHED
)paren
)paren
op_logical_or
id|sctp_endpoint_is_peeled_off
c_func
(paren
id|ep
comma
op_amp
id|to
)paren
)paren
(brace
id|err
op_assign
op_minus
id|EADDRNOTAVAIL
suffix:semicolon
r_goto
id|out_unlock
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
id|asoc
op_assign
id|sctp_id2assoc
c_func
(paren
id|sk
comma
id|associd
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|asoc
)paren
(brace
id|err
op_assign
op_minus
id|EPIPE
suffix:semicolon
r_goto
id|out_unlock
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|asoc
)paren
(brace
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;Just looked up association: %p.&bslash;n&quot;
comma
id|asoc
)paren
suffix:semicolon
multiline_comment|/* We cannot send a message on a TCP-style SCTP_SS_ESTABLISHED&n;&t;&t; * socket that has an association in CLOSED state. This can&n;&t;&t; * happen when an accepted socket has an association that is&n;&t;&t; * already CLOSED.&n;&t;&t; */
r_if
c_cond
(paren
id|sctp_state
c_func
(paren
id|asoc
comma
id|CLOSED
)paren
op_logical_and
id|sctp_style
c_func
(paren
id|sk
comma
id|TCP
)paren
)paren
(brace
id|err
op_assign
op_minus
id|EPIPE
suffix:semicolon
r_goto
id|out_unlock
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sinfo_flags
op_amp
id|MSG_EOF
)paren
(brace
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;Shutting down association: %p&bslash;n&quot;
comma
id|asoc
)paren
suffix:semicolon
id|sctp_primitive_SHUTDOWN
c_func
(paren
id|asoc
comma
l_int|NULL
)paren
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
r_goto
id|out_unlock
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sinfo_flags
op_amp
id|MSG_ABORT
)paren
(brace
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;Aborting association: %p&bslash;n&quot;
comma
id|asoc
)paren
suffix:semicolon
id|sctp_primitive_ABORT
c_func
(paren
id|asoc
comma
id|msg
)paren
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
r_goto
id|out_unlock
suffix:semicolon
)brace
)brace
multiline_comment|/* Do we need to create the association?  */
r_if
c_cond
(paren
op_logical_neg
id|asoc
)paren
(brace
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;There is no association yet.&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sinfo_flags
op_amp
(paren
id|MSG_EOF
op_or
id|MSG_ABORT
)paren
)paren
(brace
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|out_unlock
suffix:semicolon
)brace
multiline_comment|/* Check for invalid stream against the stream counts,&n;&t;&t; * either the default or the user specified stream counts.&n;&t;&t; */
r_if
c_cond
(paren
id|sinfo
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|sinit
op_logical_or
(paren
id|sinit
op_logical_and
op_logical_neg
id|sinit-&gt;sinit_num_ostreams
)paren
)paren
(brace
multiline_comment|/* Check against the defaults. */
r_if
c_cond
(paren
id|sinfo-&gt;sinfo_stream
op_ge
id|sp-&gt;initmsg.sinit_num_ostreams
)paren
(brace
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|out_unlock
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* Check against the requested.  */
r_if
c_cond
(paren
id|sinfo-&gt;sinfo_stream
op_ge
id|sinit-&gt;sinit_num_ostreams
)paren
(brace
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|out_unlock
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;&t;&t; * API 3.1.2 bind() - UDP Style Syntax&n;&t;&t; * If a bind() or sctp_bindx() is not called prior to a&n;&t;&t; * sendmsg() call that initiates a new association, the&n;&t;&t; * system picks an ephemeral port and will choose an address&n;&t;&t; * set equivalent to binding with a wildcard address.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|ep-&gt;base.bind_addr.port
)paren
(brace
r_if
c_cond
(paren
id|sctp_autobind
c_func
(paren
id|sk
)paren
)paren
(brace
id|err
op_assign
op_minus
id|EAGAIN
suffix:semicolon
r_goto
id|out_unlock
suffix:semicolon
)brace
)brace
id|scope
op_assign
id|sctp_scope
c_func
(paren
op_amp
id|to
)paren
suffix:semicolon
id|new_asoc
op_assign
id|sctp_association_new
c_func
(paren
id|ep
comma
id|sk
comma
id|scope
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|new_asoc
)paren
(brace
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|out_unlock
suffix:semicolon
)brace
id|asoc
op_assign
id|new_asoc
suffix:semicolon
multiline_comment|/* If the SCTP_INIT ancillary data is specified, set all&n;&t;&t; * the association init values accordingly.&n;&t;&t; */
r_if
c_cond
(paren
id|sinit
)paren
(brace
r_if
c_cond
(paren
id|sinit-&gt;sinit_num_ostreams
)paren
(brace
id|asoc-&gt;c.sinit_num_ostreams
op_assign
id|sinit-&gt;sinit_num_ostreams
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sinit-&gt;sinit_max_instreams
)paren
(brace
id|asoc-&gt;c.sinit_max_instreams
op_assign
id|sinit-&gt;sinit_max_instreams
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sinit-&gt;sinit_max_attempts
)paren
(brace
id|asoc-&gt;max_init_attempts
op_assign
id|sinit-&gt;sinit_max_attempts
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sinit-&gt;sinit_max_init_timeo
)paren
(brace
id|asoc-&gt;max_init_timeo
op_assign
id|msecs_to_jiffies
c_func
(paren
id|sinit-&gt;sinit_max_init_timeo
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Prime the peer&squot;s transport structures.  */
id|transport
op_assign
id|sctp_assoc_add_peer
c_func
(paren
id|asoc
comma
op_amp
id|to
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|transport
)paren
(brace
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|out_free
suffix:semicolon
)brace
id|err
op_assign
id|sctp_assoc_set_bind_addr_from_ep
c_func
(paren
id|asoc
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
(brace
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|out_free
suffix:semicolon
)brace
)brace
multiline_comment|/* ASSERT: we have a valid association at this point.  */
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;We have a valid association.&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sinfo
)paren
(brace
multiline_comment|/* If the user didn&squot;t specify SNDRCVINFO, make up one with&n;&t;&t; * some defaults.&n;&t;&t; */
id|default_sinfo.sinfo_stream
op_assign
id|asoc-&gt;default_stream
suffix:semicolon
id|default_sinfo.sinfo_flags
op_assign
id|asoc-&gt;default_flags
suffix:semicolon
id|default_sinfo.sinfo_ppid
op_assign
id|asoc-&gt;default_ppid
suffix:semicolon
id|default_sinfo.sinfo_context
op_assign
id|asoc-&gt;default_context
suffix:semicolon
id|default_sinfo.sinfo_timetolive
op_assign
id|asoc-&gt;default_timetolive
suffix:semicolon
id|default_sinfo.sinfo_assoc_id
op_assign
id|sctp_assoc2id
c_func
(paren
id|asoc
)paren
suffix:semicolon
id|sinfo
op_assign
op_amp
id|default_sinfo
suffix:semicolon
)brace
multiline_comment|/* API 7.1.7, the sndbuf size per association bounds the&n;&t; * maximum size of data that can be sent in a single send call.&n;&t; */
r_if
c_cond
(paren
id|msg_len
OG
id|sk-&gt;sk_sndbuf
)paren
(brace
id|err
op_assign
op_minus
id|EMSGSIZE
suffix:semicolon
r_goto
id|out_free
suffix:semicolon
)brace
multiline_comment|/* If fragmentation is disabled and the message length exceeds the&n;&t; * association fragmentation point, return EMSGSIZE.  The I-D&n;&t; * does not specify what this error is, but this looks like&n;&t; * a great fit.&n;&t; */
r_if
c_cond
(paren
id|sctp_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|disable_fragments
op_logical_and
(paren
id|msg_len
OG
id|asoc-&gt;frag_point
)paren
)paren
(brace
id|err
op_assign
op_minus
id|EMSGSIZE
suffix:semicolon
r_goto
id|out_free
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sinfo
)paren
(brace
multiline_comment|/* Check for invalid stream. */
r_if
c_cond
(paren
id|sinfo-&gt;sinfo_stream
op_ge
id|asoc-&gt;c.sinit_num_ostreams
)paren
(brace
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|out_free
suffix:semicolon
)brace
)brace
id|timeo
op_assign
id|sock_sndtimeo
c_func
(paren
id|sk
comma
id|msg-&gt;msg_flags
op_amp
id|MSG_DONTWAIT
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sctp_wspace
c_func
(paren
id|asoc
)paren
)paren
(brace
id|err
op_assign
id|sctp_wait_for_sndbuf
c_func
(paren
id|asoc
comma
op_amp
id|timeo
comma
id|msg_len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out_free
suffix:semicolon
)brace
multiline_comment|/* If an address is passed with the sendto/sendmsg call, it is used&n;&t; * to override the primary destination address in the TCP model, or&n;&t; * when MSG_ADDR_OVER flag is set in the UDP model.&n;&t; */
r_if
c_cond
(paren
(paren
id|sctp_style
c_func
(paren
id|sk
comma
id|TCP
)paren
op_logical_and
id|msg_name
)paren
op_logical_or
(paren
id|sinfo_flags
op_amp
id|MSG_ADDR_OVER
)paren
)paren
(brace
id|chunk_tp
op_assign
id|sctp_assoc_lookup_paddr
c_func
(paren
id|asoc
comma
op_amp
id|to
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|chunk_tp
)paren
(brace
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|out_free
suffix:semicolon
)brace
)brace
r_else
id|chunk_tp
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Auto-connect, if we aren&squot;t connected already. */
r_if
c_cond
(paren
id|sctp_state
c_func
(paren
id|asoc
comma
id|CLOSED
)paren
)paren
(brace
id|err
op_assign
id|sctp_primitive_ASSOCIATE
c_func
(paren
id|asoc
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_goto
id|out_free
suffix:semicolon
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;We associated primitively.&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* Break the message into multiple chunks of maximum size. */
id|datamsg
op_assign
id|sctp_datamsg_from_user
c_func
(paren
id|asoc
comma
id|sinfo
comma
id|msg
comma
id|msg_len
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|datamsg
)paren
(brace
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|out_free
suffix:semicolon
)brace
multiline_comment|/* Now send the (possibly) fragmented message. */
id|list_for_each
c_func
(paren
id|pos
comma
op_amp
id|datamsg-&gt;chunks
)paren
(brace
id|chunk
op_assign
id|list_entry
c_func
(paren
id|pos
comma
r_struct
id|sctp_chunk
comma
id|frag_list
)paren
suffix:semicolon
id|sctp_datamsg_track
c_func
(paren
id|chunk
)paren
suffix:semicolon
multiline_comment|/* Do accounting for the write space.  */
id|sctp_set_owner_w
c_func
(paren
id|chunk
)paren
suffix:semicolon
id|chunk-&gt;transport
op_assign
id|chunk_tp
suffix:semicolon
multiline_comment|/* Send it to the lower layers.  Note:  all chunks&n;&t;&t; * must either fail or succeed.   The lower layer&n;&t;&t; * works that way today.  Keep it that way or this&n;&t;&t; * breaks.&n;&t;&t; */
id|err
op_assign
id|sctp_primitive_SEND
c_func
(paren
id|asoc
comma
id|chunk
)paren
suffix:semicolon
multiline_comment|/* Did the lower layer accept the chunk? */
r_if
c_cond
(paren
id|err
)paren
id|sctp_chunk_free
c_func
(paren
id|chunk
)paren
suffix:semicolon
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;We sent primitively.&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|sctp_datamsg_free
c_func
(paren
id|datamsg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out_free
suffix:semicolon
r_else
id|err
op_assign
id|msg_len
suffix:semicolon
multiline_comment|/* If we are already past ASSOCIATE, the lower&n;&t; * layers are responsible for association cleanup.&n;&t; */
r_goto
id|out_unlock
suffix:semicolon
id|out_free
suffix:colon
r_if
c_cond
(paren
id|new_asoc
)paren
id|sctp_association_free
c_func
(paren
id|asoc
)paren
suffix:semicolon
id|out_unlock
suffix:colon
id|sctp_release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
id|out_nounlock
suffix:colon
r_return
id|sctp_error
c_func
(paren
id|sk
comma
id|msg_flags
comma
id|err
)paren
suffix:semicolon
macro_line|#if 0
id|do_sock_err
suffix:colon
r_if
c_cond
(paren
id|msg_len
)paren
id|err
op_assign
id|msg_len
suffix:semicolon
r_else
id|err
op_assign
id|sock_error
c_func
(paren
id|sk
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
id|do_interrupted
suffix:colon
r_if
c_cond
(paren
id|msg_len
)paren
id|err
op_assign
id|msg_len
suffix:semicolon
r_goto
id|out
suffix:semicolon
macro_line|#endif /* 0 */
)brace
multiline_comment|/* This is an extended version of skb_pull() that removes the data from the&n; * start of a skb even when data is spread across the list of skb&squot;s in the&n; * frag_list. len specifies the total amount of data that needs to be removed.&n; * when &squot;len&squot; bytes could be removed from the skb, it returns 0.&n; * If &squot;len&squot; exceeds the total skb length,  it returns the no. of bytes that&n; * could not be removed.&n; */
DECL|function|sctp_skb_pull
r_static
r_int
id|sctp_skb_pull
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|len
)paren
(brace
r_struct
id|sk_buff
op_star
id|list
suffix:semicolon
r_int
id|skb_len
op_assign
id|skb_headlen
c_func
(paren
id|skb
)paren
suffix:semicolon
r_int
id|rlen
suffix:semicolon
r_if
c_cond
(paren
id|len
op_le
id|skb_len
)paren
(brace
id|__skb_pull
c_func
(paren
id|skb
comma
id|len
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|len
op_sub_assign
id|skb_len
suffix:semicolon
id|__skb_pull
c_func
(paren
id|skb
comma
id|skb_len
)paren
suffix:semicolon
r_for
c_loop
(paren
id|list
op_assign
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|frag_list
suffix:semicolon
id|list
suffix:semicolon
id|list
op_assign
id|list-&gt;next
)paren
(brace
id|rlen
op_assign
id|sctp_skb_pull
c_func
(paren
id|list
comma
id|len
)paren
suffix:semicolon
id|skb-&gt;len
op_sub_assign
(paren
id|len
op_minus
id|rlen
)paren
suffix:semicolon
id|skb-&gt;data_len
op_sub_assign
(paren
id|len
op_minus
id|rlen
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rlen
)paren
r_return
l_int|0
suffix:semicolon
id|len
op_assign
id|rlen
suffix:semicolon
)brace
r_return
id|len
suffix:semicolon
)brace
multiline_comment|/* API 3.1.3  recvmsg() - UDP Style Syntax&n; *&n; *  ssize_t recvmsg(int socket, struct msghdr *message,&n; *                    int flags);&n; *&n; *  socket  - the socket descriptor of the endpoint.&n; *  message - pointer to the msghdr structure which contains a single&n; *            user message and possibly some ancillary data.&n; *&n; *            See Section 5 for complete description of the data&n; *            structures.&n; *&n; *  flags   - flags sent or received with the user message, see Section&n; *            5 for complete description of the flags.&n; */
r_static
r_struct
id|sk_buff
op_star
id|sctp_skb_recv_datagram
c_func
(paren
r_struct
id|sock
op_star
comma
r_int
comma
r_int
comma
r_int
op_star
)paren
suffix:semicolon
DECL|function|sctp_recvmsg
id|SCTP_STATIC
r_int
id|sctp_recvmsg
c_func
(paren
r_struct
id|kiocb
op_star
id|iocb
comma
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|msghdr
op_star
id|msg
comma
r_int
id|len
comma
r_int
id|noblock
comma
r_int
id|flags
comma
r_int
op_star
id|addr_len
)paren
(brace
r_struct
id|sctp_ulpevent
op_star
id|event
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|sctp_opt
op_star
id|sp
op_assign
id|sctp_sk
c_func
(paren
id|sk
)paren
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_int
id|copied
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
r_int
id|skb_len
suffix:semicolon
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;sctp_recvmsg(%s: %p, %s: %p, %s: %zd, %s: %d, %s: &quot;
l_string|&quot;0x%x, %s: %p)&bslash;n&quot;
comma
l_string|&quot;sk&quot;
comma
id|sk
comma
l_string|&quot;msghdr&quot;
comma
id|msg
comma
l_string|&quot;len&quot;
comma
id|len
comma
l_string|&quot;knoblauch&quot;
comma
id|noblock
comma
l_string|&quot;flags&quot;
comma
id|flags
comma
l_string|&quot;addr_len&quot;
comma
id|addr_len
)paren
suffix:semicolon
id|sctp_lock_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sctp_style
c_func
(paren
id|sk
comma
id|TCP
)paren
op_logical_and
op_logical_neg
id|sctp_sstate
c_func
(paren
id|sk
comma
id|ESTABLISHED
)paren
)paren
(brace
id|err
op_assign
op_minus
id|ENOTCONN
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|skb
op_assign
id|sctp_skb_recv_datagram
c_func
(paren
id|sk
comma
id|flags
comma
id|noblock
comma
op_amp
id|err
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skb
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* Get the total length of the skb including any skb&squot;s in the&n;&t; * frag_list.&n;&t; */
id|skb_len
op_assign
id|skb-&gt;len
suffix:semicolon
id|copied
op_assign
id|skb_len
suffix:semicolon
r_if
c_cond
(paren
id|copied
OG
id|len
)paren
id|copied
op_assign
id|len
suffix:semicolon
id|err
op_assign
id|skb_copy_datagram_iovec
c_func
(paren
id|skb
comma
l_int|0
comma
id|msg-&gt;msg_iov
comma
id|copied
)paren
suffix:semicolon
id|event
op_assign
id|sctp_skb2event
c_func
(paren
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out_free
suffix:semicolon
id|sock_recv_timestamp
c_func
(paren
id|msg
comma
id|sk
comma
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sctp_ulpevent_is_notification
c_func
(paren
id|event
)paren
)paren
(brace
id|msg-&gt;msg_flags
op_or_assign
id|MSG_NOTIFICATION
suffix:semicolon
id|sp-&gt;pf
op_member_access_from_pointer
id|event_msgname
c_func
(paren
id|event
comma
id|msg-&gt;msg_name
comma
id|addr_len
)paren
suffix:semicolon
)brace
r_else
(brace
id|sp-&gt;pf
op_member_access_from_pointer
id|skb_msgname
c_func
(paren
id|skb
comma
id|msg-&gt;msg_name
comma
id|addr_len
)paren
suffix:semicolon
)brace
multiline_comment|/* Check if we allow SCTP_SNDRCVINFO. */
r_if
c_cond
(paren
id|sp-&gt;subscribe.sctp_data_io_event
)paren
id|sctp_ulpevent_read_sndrcvinfo
c_func
(paren
id|event
comma
id|msg
)paren
suffix:semicolon
macro_line|#if 0
multiline_comment|/* FIXME: we should be calling IP/IPv6 layers.  */
r_if
c_cond
(paren
id|sk-&gt;sk_protinfo.af_inet.cmsg_flags
)paren
id|ip_cmsg_recv
c_func
(paren
id|msg
comma
id|skb
)paren
suffix:semicolon
macro_line|#endif
id|err
op_assign
id|copied
suffix:semicolon
multiline_comment|/* If skb&squot;s length exceeds the user&squot;s buffer, update the skb and&n;&t; * push it back to the receive_queue so that the next call to&n;&t; * recvmsg() will return the remaining data. Don&squot;t set MSG_EOR.&n;&t; */
r_if
c_cond
(paren
id|skb_len
OG
id|copied
)paren
(brace
id|msg-&gt;msg_flags
op_and_assign
op_complement
id|MSG_EOR
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|MSG_PEEK
)paren
r_goto
id|out_free
suffix:semicolon
id|sctp_skb_pull
c_func
(paren
id|skb
comma
id|copied
)paren
suffix:semicolon
id|skb_queue_head
c_func
(paren
op_amp
id|sk-&gt;sk_receive_queue
comma
id|skb
)paren
suffix:semicolon
multiline_comment|/* When only partial message is copied to the user, increase&n;&t;&t; * rwnd by that amount. If all the data in the skb is read,&n;&t;&t; * rwnd is updated when the event is freed.&n;&t;&t; */
id|sctp_assoc_rwnd_increase
c_func
(paren
id|event-&gt;asoc
comma
id|copied
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|event-&gt;msg_flags
op_amp
id|MSG_NOTIFICATION
)paren
op_logical_or
(paren
id|event-&gt;msg_flags
op_amp
id|MSG_EOR
)paren
)paren
id|msg-&gt;msg_flags
op_or_assign
id|MSG_EOR
suffix:semicolon
r_else
id|msg-&gt;msg_flags
op_and_assign
op_complement
id|MSG_EOR
suffix:semicolon
id|out_free
suffix:colon
r_if
c_cond
(paren
id|flags
op_amp
id|MSG_PEEK
)paren
(brace
multiline_comment|/* Release the skb reference acquired after peeking the skb in&n;&t;&t; * sctp_skb_recv_datagram().&n;&t;&t; */
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Free the event which includes releasing the reference to&n;&t;&t; * the owner of the skb, freeing the skb and updating the&n;&t;&t; * rwnd.&n;&t;&t; */
id|sctp_ulpevent_free
c_func
(paren
id|event
)paren
suffix:semicolon
)brace
id|out
suffix:colon
id|sctp_release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/* 7.1.12 Enable/Disable message fragmentation (SCTP_DISABLE_FRAGMENTS)&n; *&n; * This option is a on/off flag.  If enabled no SCTP message&n; * fragmentation will be performed.  Instead if a message being sent&n; * exceeds the current PMTU size, the message will NOT be sent and&n; * instead a error will be indicated to the user.&n; */
DECL|function|sctp_setsockopt_disable_fragments
r_static
r_int
id|sctp_setsockopt_disable_fragments
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_char
id|__user
op_star
id|optval
comma
r_int
id|optlen
)paren
(brace
r_int
id|val
suffix:semicolon
r_if
c_cond
(paren
id|optlen
OL
r_sizeof
(paren
r_int
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
id|__user
op_star
)paren
id|optval
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|sctp_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|disable_fragments
op_assign
(paren
id|val
op_eq
l_int|0
)paren
ques
c_cond
l_int|0
suffix:colon
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|sctp_setsockopt_events
r_static
r_int
id|sctp_setsockopt_events
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_char
id|__user
op_star
id|optval
comma
r_int
id|optlen
)paren
(brace
r_if
c_cond
(paren
id|optlen
op_ne
r_sizeof
(paren
r_struct
id|sctp_event_subscribe
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|sctp_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|subscribe
comma
id|optval
comma
id|optlen
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* 7.1.8 Automatic Close of associations (SCTP_AUTOCLOSE)&n; *&n; * This socket option is applicable to the UDP-style socket only.  When&n; * set it will cause associations that are idle for more than the&n; * specified number of seconds to automatically close.  An association&n; * being idle is defined an association that has NOT sent or received&n; * user data.  The special value of &squot;0&squot; indicates that no automatic&n; * close of any associations should be performed.  The option expects an&n; * integer defining the number of seconds of idle time before an&n; * association is closed.&n; */
DECL|function|sctp_setsockopt_autoclose
r_static
r_int
id|sctp_setsockopt_autoclose
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_char
id|__user
op_star
id|optval
comma
r_int
id|optlen
)paren
(brace
r_struct
id|sctp_opt
op_star
id|sp
op_assign
id|sctp_sk
c_func
(paren
id|sk
)paren
suffix:semicolon
multiline_comment|/* Applicable to UDP-style socket only */
r_if
c_cond
(paren
id|sctp_style
c_func
(paren
id|sk
comma
id|TCP
)paren
)paren
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
r_if
c_cond
(paren
id|optlen
op_ne
r_sizeof
(paren
r_int
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|sp-&gt;autoclose
comma
id|optval
comma
id|optlen
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|sp-&gt;ep-&gt;timeouts
(braket
id|SCTP_EVENT_TIMEOUT_AUTOCLOSE
)braket
op_assign
id|sp-&gt;autoclose
op_star
id|HZ
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* 7.1.13 Peer Address Parameters (SCTP_PEER_ADDR_PARAMS)&n; *&n; * Applications can enable or disable heartbeats for any peer address of&n; * an association, modify an address&squot;s heartbeat interval, force a&n; * heartbeat to be sent immediately, and adjust the address&squot;s maximum&n; * number of retransmissions sent before an address is considered&n; * unreachable.  The following structure is used to access and modify an&n; * address&squot;s parameters:&n; *&n; *  struct sctp_paddrparams {&n; *      sctp_assoc_t            spp_assoc_id;&n; *      struct sockaddr_storage spp_address;&n; *      uint32_t                spp_hbinterval;&n; *      uint16_t                spp_pathmaxrxt;&n; *  };&n; *&n; *   spp_assoc_id    - (UDP style socket) This is filled in the application,&n; *                     and identifies the association for this query.&n; *   spp_address     - This specifies which address is of interest.&n; *   spp_hbinterval  - This contains the value of the heartbeat interval,&n; *                     in milliseconds.  A value of 0, when modifying the&n; *                     parameter, specifies that the heartbeat on this&n; *                     address should be disabled. A value of UINT32_MAX&n; *                     (4294967295), when modifying the parameter,&n; *                     specifies that a heartbeat should be sent&n; *                     immediately to the peer address, and the current&n; *                     interval should remain unchanged.&n; *   spp_pathmaxrxt  - This contains the maximum number of&n; *                     retransmissions before this address shall be&n; *                     considered unreachable.&n; */
DECL|function|sctp_setsockopt_peer_addr_params
r_static
r_int
id|sctp_setsockopt_peer_addr_params
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_char
id|__user
op_star
id|optval
comma
r_int
id|optlen
)paren
(brace
r_struct
id|sctp_paddrparams
id|params
suffix:semicolon
r_struct
id|sctp_transport
op_star
id|trans
suffix:semicolon
r_int
id|error
suffix:semicolon
r_if
c_cond
(paren
id|optlen
op_ne
r_sizeof
(paren
r_struct
id|sctp_paddrparams
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|params
comma
id|optval
comma
id|optlen
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
multiline_comment|/*&n;&t; * API 7. Socket Options (setting the default value for the endpoint)&n;&t; * All options that support specific settings on an association by&n;&t; * filling in either an association id variable or a sockaddr_storage&n;&t; * SHOULD also support setting of the same value for the entire endpoint&n;&t; * (i.e. future associations). To accomplish this the following logic is&n;&t; * used when setting one of these options:&n;&n;&t; * c) If neither the sockaddr_storage or association identification is&n;&t; *    set i.e. the sockaddr_storage is set to all 0&squot;s (INADDR_ANY) and&n;&t; *    the association identification is 0, the settings are a default&n;&t; *    and to be applied to the endpoint (all future associations).&n;&t; */
multiline_comment|/* update default value for endpoint (all future associations) */
r_if
c_cond
(paren
op_logical_neg
id|params.spp_assoc_id
op_logical_and
id|sctp_is_any
c_func
(paren
(paren
r_union
id|sctp_addr
op_star
)paren
op_amp
id|params.spp_address
)paren
)paren
(brace
r_if
c_cond
(paren
id|params.spp_hbinterval
)paren
id|sctp_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|paddrparam.spp_hbinterval
op_assign
id|params.spp_hbinterval
suffix:semicolon
r_if
c_cond
(paren
id|sctp_max_retrans_path
)paren
id|sctp_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|paddrparam.spp_pathmaxrxt
op_assign
id|params.spp_pathmaxrxt
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|trans
op_assign
id|sctp_addr_id2transport
c_func
(paren
id|sk
comma
op_amp
id|params.spp_address
comma
id|params.spp_assoc_id
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|trans
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* Applications can enable or disable heartbeats for any peer address&n;&t; * of an association, modify an address&squot;s heartbeat interval, force a&n;&t; * heartbeat to be sent immediately, and adjust the address&squot;s maximum&n;&t; * number of retransmissions sent before an address is considered&n;&t; * unreachable.&n;&t; *&n;&t; * The value of the heartbeat interval, in milliseconds. A value of&n;&t; * UINT32_MAX (4294967295), when modifying the parameter, specifies&n;&t; * that a heartbeat should be sent immediately to the peer address,&n;&t; * and the current interval should remain unchanged.&n;&t; */
r_if
c_cond
(paren
l_int|0xffffffff
op_eq
id|params.spp_hbinterval
)paren
(brace
id|error
op_assign
id|sctp_primitive_REQUESTHEARTBEAT
(paren
id|trans-&gt;asoc
comma
id|trans
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* The value of the heartbeat interval, in milliseconds. A value of 0,&n;&t; * when modifying the parameter, specifies that the heartbeat on this&n;&t; * address should be disabled.&n;&t; */
r_if
c_cond
(paren
id|params.spp_hbinterval
)paren
(brace
id|trans-&gt;hb_allowed
op_assign
l_int|1
suffix:semicolon
id|trans-&gt;hb_interval
op_assign
id|msecs_to_jiffies
c_func
(paren
id|params.spp_hbinterval
)paren
suffix:semicolon
)brace
r_else
id|trans-&gt;hb_allowed
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* spp_pathmaxrxt contains the maximum number of retransmissions&n;&t; * before this address shall be considered unreachable.&n;&t; */
id|trans-&gt;error_threshold
op_assign
id|params.spp_pathmaxrxt
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* 7.1.3 Initialization Parameters (SCTP_INITMSG)&n; *&n; * Applications can specify protocol parameters for the default association&n; * initialization.  The option name argument to setsockopt() and getsockopt()&n; * is SCTP_INITMSG.&n; *&n; * Setting initialization parameters is effective only on an unconnected&n; * socket (for UDP-style sockets only future associations are effected&n; * by the change).  With TCP-style sockets, this option is inherited by&n; * sockets derived from a listener socket.&n; */
DECL|function|sctp_setsockopt_initmsg
r_static
r_int
id|sctp_setsockopt_initmsg
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_char
id|__user
op_star
id|optval
comma
r_int
id|optlen
)paren
(brace
r_struct
id|sctp_initmsg
id|sinit
suffix:semicolon
r_struct
id|sctp_opt
op_star
id|sp
op_assign
id|sctp_sk
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|optlen
op_ne
r_sizeof
(paren
r_struct
id|sctp_initmsg
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|sinit
comma
id|optval
comma
id|optlen
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|sinit.sinit_num_ostreams
)paren
id|sp-&gt;initmsg.sinit_num_ostreams
op_assign
id|sinit.sinit_num_ostreams
suffix:semicolon
r_if
c_cond
(paren
id|sinit.sinit_max_instreams
)paren
id|sp-&gt;initmsg.sinit_max_instreams
op_assign
id|sinit.sinit_max_instreams
suffix:semicolon
r_if
c_cond
(paren
id|sinit.sinit_max_attempts
)paren
id|sp-&gt;initmsg.sinit_max_attempts
op_assign
id|sinit.sinit_max_attempts
suffix:semicolon
r_if
c_cond
(paren
id|sinit.sinit_max_init_timeo
)paren
id|sp-&gt;initmsg.sinit_max_init_timeo
op_assign
id|sinit.sinit_max_init_timeo
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * 7.1.14 Set default send parameters (SCTP_DEFAULT_SEND_PARAM)&n; *&n; *   Applications that wish to use the sendto() system call may wish to&n; *   specify a default set of parameters that would normally be supplied&n; *   through the inclusion of ancillary data.  This socket option allows&n; *   such an application to set the default sctp_sndrcvinfo structure.&n; *   The application that wishes to use this socket option simply passes&n; *   in to this call the sctp_sndrcvinfo structure defined in Section&n; *   5.2.2) The input parameters accepted by this call include&n; *   sinfo_stream, sinfo_flags, sinfo_ppid, sinfo_context,&n; *   sinfo_timetolive.  The user must provide the sinfo_assoc_id field in&n; *   to this call if the caller is using the UDP model.&n; */
DECL|function|sctp_setsockopt_default_send_param
r_static
r_int
id|sctp_setsockopt_default_send_param
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_char
id|__user
op_star
id|optval
comma
r_int
id|optlen
)paren
(brace
r_struct
id|sctp_sndrcvinfo
id|info
suffix:semicolon
r_struct
id|sctp_association
op_star
id|asoc
suffix:semicolon
r_struct
id|sctp_opt
op_star
id|sp
op_assign
id|sctp_sk
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|optlen
op_ne
r_sizeof
(paren
r_struct
id|sctp_sndrcvinfo
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|info
comma
id|optval
comma
id|optlen
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|asoc
op_assign
id|sctp_id2assoc
c_func
(paren
id|sk
comma
id|info.sinfo_assoc_id
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|asoc
op_logical_and
id|info.sinfo_assoc_id
op_logical_and
id|sctp_style
c_func
(paren
id|sk
comma
id|UDP
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|asoc
)paren
(brace
id|asoc-&gt;default_stream
op_assign
id|info.sinfo_stream
suffix:semicolon
id|asoc-&gt;default_flags
op_assign
id|info.sinfo_flags
suffix:semicolon
id|asoc-&gt;default_ppid
op_assign
id|info.sinfo_ppid
suffix:semicolon
id|asoc-&gt;default_context
op_assign
id|info.sinfo_context
suffix:semicolon
id|asoc-&gt;default_timetolive
op_assign
id|info.sinfo_timetolive
suffix:semicolon
)brace
r_else
(brace
id|sp-&gt;default_stream
op_assign
id|info.sinfo_stream
suffix:semicolon
id|sp-&gt;default_flags
op_assign
id|info.sinfo_flags
suffix:semicolon
id|sp-&gt;default_ppid
op_assign
id|info.sinfo_ppid
suffix:semicolon
id|sp-&gt;default_context
op_assign
id|info.sinfo_context
suffix:semicolon
id|sp-&gt;default_timetolive
op_assign
id|info.sinfo_timetolive
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* 7.1.10 Set Primary Address (SCTP_PRIMARY_ADDR)&n; *&n; * Requests that the local SCTP stack use the enclosed peer address as&n; * the association primary.  The enclosed address must be one of the&n; * association peer&squot;s addresses.&n; */
DECL|function|sctp_setsockopt_primary_addr
r_static
r_int
id|sctp_setsockopt_primary_addr
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_char
id|__user
op_star
id|optval
comma
r_int
id|optlen
)paren
(brace
r_struct
id|sctp_prim
id|prim
suffix:semicolon
r_struct
id|sctp_transport
op_star
id|trans
suffix:semicolon
r_if
c_cond
(paren
id|optlen
op_ne
r_sizeof
(paren
r_struct
id|sctp_prim
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|prim
comma
id|optval
comma
r_sizeof
(paren
r_struct
id|sctp_prim
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|trans
op_assign
id|sctp_addr_id2transport
c_func
(paren
id|sk
comma
op_amp
id|prim.ssp_addr
comma
id|prim.ssp_assoc_id
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|trans
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|sctp_assoc_set_primary
c_func
(paren
id|trans-&gt;asoc
comma
id|trans
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * 7.1.5 SCTP_NODELAY&n; *&n; * Turn on/off any Nagle-like algorithm.  This means that packets are&n; * generally sent as soon as possible and no unnecessary delays are&n; * introduced, at the cost of more packets in the network.  Expects an&n; *  integer boolean flag.&n; */
DECL|function|sctp_setsockopt_nodelay
r_static
r_int
id|sctp_setsockopt_nodelay
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_char
id|__user
op_star
id|optval
comma
r_int
id|optlen
)paren
(brace
r_int
id|val
suffix:semicolon
r_if
c_cond
(paren
id|optlen
OL
r_sizeof
(paren
r_int
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
id|__user
op_star
)paren
id|optval
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|sctp_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|nodelay
op_assign
(paren
id|val
op_eq
l_int|0
)paren
ques
c_cond
l_int|0
suffix:colon
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&n; * 7.1.1 SCTP_RTOINFO&n; *&n; * The protocol parameters used to initialize and bound retransmission&n; * timeout (RTO) are tunable. sctp_rtoinfo structure is used to access&n; * and modify these parameters.&n; * All parameters are time values, in milliseconds.  A value of 0, when&n; * modifying the parameters, indicates that the current value should not&n; * be changed.&n; *&n; */
DECL|function|sctp_setsockopt_rtoinfo
r_static
r_int
id|sctp_setsockopt_rtoinfo
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_char
id|__user
op_star
id|optval
comma
r_int
id|optlen
)paren
(brace
r_struct
id|sctp_rtoinfo
id|rtoinfo
suffix:semicolon
r_struct
id|sctp_association
op_star
id|asoc
suffix:semicolon
r_if
c_cond
(paren
id|optlen
op_ne
r_sizeof
(paren
r_struct
id|sctp_rtoinfo
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|rtoinfo
comma
id|optval
comma
id|optlen
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|asoc
op_assign
id|sctp_id2assoc
c_func
(paren
id|sk
comma
id|rtoinfo.srto_assoc_id
)paren
suffix:semicolon
multiline_comment|/* Set the values to the specific association */
r_if
c_cond
(paren
op_logical_neg
id|asoc
op_logical_and
id|rtoinfo.srto_assoc_id
op_logical_and
id|sctp_style
c_func
(paren
id|sk
comma
id|UDP
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|asoc
)paren
(brace
r_if
c_cond
(paren
id|rtoinfo.srto_initial
op_ne
l_int|0
)paren
id|asoc-&gt;rto_initial
op_assign
id|msecs_to_jiffies
c_func
(paren
id|rtoinfo.srto_initial
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rtoinfo.srto_max
op_ne
l_int|0
)paren
id|asoc-&gt;rto_max
op_assign
id|msecs_to_jiffies
c_func
(paren
id|rtoinfo.srto_max
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rtoinfo.srto_min
op_ne
l_int|0
)paren
id|asoc-&gt;rto_min
op_assign
id|msecs_to_jiffies
c_func
(paren
id|rtoinfo.srto_min
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* If there is no association or the association-id = 0&n;&t;&t; * set the values to the endpoint.&n;&t;&t; */
r_struct
id|sctp_opt
op_star
id|sp
op_assign
id|sctp_sk
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rtoinfo.srto_initial
op_ne
l_int|0
)paren
id|sp-&gt;rtoinfo.srto_initial
op_assign
id|rtoinfo.srto_initial
suffix:semicolon
r_if
c_cond
(paren
id|rtoinfo.srto_max
op_ne
l_int|0
)paren
id|sp-&gt;rtoinfo.srto_max
op_assign
id|rtoinfo.srto_max
suffix:semicolon
r_if
c_cond
(paren
id|rtoinfo.srto_min
op_ne
l_int|0
)paren
id|sp-&gt;rtoinfo.srto_min
op_assign
id|rtoinfo.srto_min
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&n; * 7.1.2 SCTP_ASSOCINFO&n; *&n; * This option is used to tune the the maximum retransmission attempts&n; * of the association.&n; * Returns an error if the new association retransmission value is&n; * greater than the sum of the retransmission value  of the peer.&n; * See [SCTP] for more information.&n; *&n; */
DECL|function|sctp_setsockopt_associnfo
r_static
r_int
id|sctp_setsockopt_associnfo
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_char
id|__user
op_star
id|optval
comma
r_int
id|optlen
)paren
(brace
r_struct
id|sctp_assocparams
id|assocparams
suffix:semicolon
r_struct
id|sctp_association
op_star
id|asoc
suffix:semicolon
r_if
c_cond
(paren
id|optlen
op_ne
r_sizeof
(paren
r_struct
id|sctp_assocparams
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|assocparams
comma
id|optval
comma
id|optlen
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|asoc
op_assign
id|sctp_id2assoc
c_func
(paren
id|sk
comma
id|assocparams.sasoc_assoc_id
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|asoc
op_logical_and
id|assocparams.sasoc_assoc_id
op_logical_and
id|sctp_style
c_func
(paren
id|sk
comma
id|UDP
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* Set the values to the specific association */
r_if
c_cond
(paren
id|asoc
)paren
(brace
r_if
c_cond
(paren
id|assocparams.sasoc_asocmaxrxt
op_ne
l_int|0
)paren
id|asoc-&gt;max_retrans
op_assign
id|assocparams.sasoc_asocmaxrxt
suffix:semicolon
r_if
c_cond
(paren
id|assocparams.sasoc_cookie_life
op_ne
l_int|0
)paren
(brace
id|asoc-&gt;cookie_life.tv_sec
op_assign
id|assocparams.sasoc_cookie_life
op_div
l_int|1000
suffix:semicolon
id|asoc-&gt;cookie_life.tv_usec
op_assign
(paren
id|assocparams.sasoc_cookie_life
op_mod
l_int|1000
)paren
op_star
l_int|1000
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* Set the values to the endpoint */
r_struct
id|sctp_opt
op_star
id|sp
op_assign
id|sctp_sk
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|assocparams.sasoc_asocmaxrxt
op_ne
l_int|0
)paren
id|sp-&gt;assocparams.sasoc_asocmaxrxt
op_assign
id|assocparams.sasoc_asocmaxrxt
suffix:semicolon
r_if
c_cond
(paren
id|assocparams.sasoc_cookie_life
op_ne
l_int|0
)paren
id|sp-&gt;assocparams.sasoc_cookie_life
op_assign
id|assocparams.sasoc_cookie_life
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * 7.1.16 Set/clear IPv4 mapped addresses (SCTP_I_WANT_MAPPED_V4_ADDR)&n; *&n; * This socket option is a boolean flag which turns on or off mapped V4&n; * addresses.  If this option is turned on and the socket is type&n; * PF_INET6, then IPv4 addresses will be mapped to V6 representation.&n; * If this option is turned off, then no mapping will be done of V4&n; * addresses and a user will receive both PF_INET6 and PF_INET type&n; * addresses on the socket.&n; */
DECL|function|sctp_setsockopt_mappedv4
r_static
r_int
id|sctp_setsockopt_mappedv4
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_char
id|__user
op_star
id|optval
comma
r_int
id|optlen
)paren
(brace
r_int
id|val
suffix:semicolon
r_struct
id|sctp_opt
op_star
id|sp
op_assign
id|sctp_sk
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|optlen
OL
r_sizeof
(paren
r_int
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
id|__user
op_star
)paren
id|optval
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|val
)paren
id|sp-&gt;v4mapped
op_assign
l_int|1
suffix:semicolon
r_else
id|sp-&gt;v4mapped
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * 7.1.17 Set the maximum fragrmentation size (SCTP_MAXSEG)&n; *&n; * This socket option specifies the maximum size to put in any outgoing&n; * SCTP chunk.  If a message is larger than this size it will be&n; * fragmented by SCTP into the specified size.  Note that the underlying&n; * SCTP implementation may fragment into smaller sized chunks when the&n; * PMTU of the underlying association is smaller than the value set by&n; * the user.&n; */
DECL|function|sctp_setsockopt_maxseg
r_static
r_int
id|sctp_setsockopt_maxseg
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_char
id|__user
op_star
id|optval
comma
r_int
id|optlen
)paren
(brace
r_struct
id|sctp_association
op_star
id|asoc
suffix:semicolon
r_struct
id|list_head
op_star
id|pos
suffix:semicolon
r_struct
id|sctp_opt
op_star
id|sp
op_assign
id|sctp_sk
c_func
(paren
id|sk
)paren
suffix:semicolon
r_int
id|val
suffix:semicolon
r_if
c_cond
(paren
id|optlen
OL
r_sizeof
(paren
r_int
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
id|__user
op_star
)paren
id|optval
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
(paren
id|val
OL
l_int|8
)paren
op_logical_or
(paren
id|val
OG
id|SCTP_MAX_CHUNK_LEN
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|sp-&gt;user_frag
op_assign
id|val
suffix:semicolon
r_if
c_cond
(paren
id|val
)paren
(brace
multiline_comment|/* Update the frag_point of the existing associations. */
id|list_for_each
c_func
(paren
id|pos
comma
op_amp
(paren
id|sp-&gt;ep-&gt;asocs
)paren
)paren
(brace
id|asoc
op_assign
id|list_entry
c_func
(paren
id|pos
comma
r_struct
id|sctp_association
comma
id|asocs
)paren
suffix:semicolon
id|asoc-&gt;frag_point
op_assign
id|sctp_frag_point
c_func
(paren
id|sp
comma
id|asoc-&gt;pmtu
)paren
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *  7.1.9 Set Peer Primary Address (SCTP_SET_PEER_PRIMARY_ADDR)&n; *&n; *   Requests that the peer mark the enclosed address as the association&n; *   primary. The enclosed address must be one of the association&squot;s&n; *   locally bound addresses. The following structure is used to make a&n; *   set primary request:&n; */
DECL|function|sctp_setsockopt_peer_primary_addr
r_static
r_int
id|sctp_setsockopt_peer_primary_addr
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_char
id|__user
op_star
id|optval
comma
r_int
id|optlen
)paren
(brace
r_struct
id|sctp_opt
op_star
id|sp
suffix:semicolon
r_struct
id|sctp_endpoint
op_star
id|ep
suffix:semicolon
r_struct
id|sctp_association
op_star
id|asoc
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|sctp_setpeerprim
id|prim
suffix:semicolon
r_struct
id|sctp_chunk
op_star
id|chunk
suffix:semicolon
r_int
id|err
suffix:semicolon
id|sp
op_assign
id|sctp_sk
c_func
(paren
id|sk
)paren
suffix:semicolon
id|ep
op_assign
id|sp-&gt;ep
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sctp_addip_enable
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|optlen
op_ne
r_sizeof
(paren
r_struct
id|sctp_setpeerprim
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|prim
comma
id|optval
comma
id|optlen
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|asoc
op_assign
id|sctp_id2assoc
c_func
(paren
id|sk
comma
id|prim.sspp_assoc_id
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|asoc
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|asoc-&gt;peer.asconf_capable
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|asoc-&gt;peer.addip_disabled_mask
op_amp
id|SCTP_PARAM_SET_PRIMARY
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sctp_state
c_func
(paren
id|asoc
comma
id|ESTABLISHED
)paren
)paren
r_return
op_minus
id|ENOTCONN
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sctp_assoc_lookup_laddr
c_func
(paren
id|asoc
comma
(paren
r_union
id|sctp_addr
op_star
)paren
op_amp
id|prim.sspp_addr
)paren
)paren
r_return
op_minus
id|EADDRNOTAVAIL
suffix:semicolon
multiline_comment|/* Create an ASCONF chunk with SET_PRIMARY parameter&t;*/
id|chunk
op_assign
id|sctp_make_asconf_set_prim
c_func
(paren
id|asoc
comma
(paren
r_union
id|sctp_addr
op_star
)paren
op_amp
id|prim.sspp_addr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|chunk
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|err
op_assign
id|sctp_send_asconf
c_func
(paren
id|asoc
comma
id|chunk
)paren
suffix:semicolon
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;We set peer primary addr primitively.&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|function|sctp_setsockopt_adaption_layer
r_static
r_int
id|sctp_setsockopt_adaption_layer
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_char
id|__user
op_star
id|optval
comma
r_int
id|optlen
)paren
(brace
id|__u32
id|val
suffix:semicolon
r_if
c_cond
(paren
id|optlen
OL
r_sizeof
(paren
id|__u32
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|val
comma
id|optval
comma
r_sizeof
(paren
id|__u32
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|sctp_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|adaption_ind
op_assign
id|val
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* API 6.2 setsockopt(), getsockopt()&n; *&n; * Applications use setsockopt() and getsockopt() to set or retrieve&n; * socket options.  Socket options are used to change the default&n; * behavior of sockets calls.  They are described in Section 7.&n; *&n; * The syntax is:&n; *&n; *   ret = getsockopt(int sd, int level, int optname, void __user *optval,&n; *                    int __user *optlen);&n; *   ret = setsockopt(int sd, int level, int optname, const void __user *optval,&n; *                    int optlen);&n; *&n; *   sd      - the socket descript.&n; *   level   - set to IPPROTO_SCTP for all SCTP options.&n; *   optname - the option name.&n; *   optval  - the buffer to store the value of the option.&n; *   optlen  - the size of the buffer.&n; */
DECL|function|sctp_setsockopt
id|SCTP_STATIC
r_int
id|sctp_setsockopt
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|level
comma
r_int
id|optname
comma
r_char
id|__user
op_star
id|optval
comma
r_int
id|optlen
)paren
(brace
r_int
id|retval
op_assign
l_int|0
suffix:semicolon
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;sctp_setsockopt(sk: %p... optname: %d)&bslash;n&quot;
comma
id|sk
comma
id|optname
)paren
suffix:semicolon
multiline_comment|/* I can hardly begin to describe how wrong this is.  This is&n;&t; * so broken as to be worse than useless.  The API draft&n;&t; * REALLY is NOT helpful here...  I am not convinced that the&n;&t; * semantics of setsockopt() with a level OTHER THAN SOL_SCTP&n;&t; * are at all well-founded.&n;&t; */
r_if
c_cond
(paren
id|level
op_ne
id|SOL_SCTP
)paren
(brace
r_struct
id|sctp_af
op_star
id|af
op_assign
id|sctp_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|pf-&gt;af
suffix:semicolon
id|retval
op_assign
id|af
op_member_access_from_pointer
id|setsockopt
c_func
(paren
id|sk
comma
id|level
comma
id|optname
comma
id|optval
comma
id|optlen
)paren
suffix:semicolon
r_goto
id|out_nounlock
suffix:semicolon
)brace
id|sctp_lock_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|optname
)paren
(brace
r_case
id|SCTP_SOCKOPT_BINDX_ADD
suffix:colon
multiline_comment|/* &squot;optlen&squot; is the size of the addresses buffer. */
id|retval
op_assign
id|sctp_setsockopt_bindx
c_func
(paren
id|sk
comma
(paren
r_struct
id|sockaddr
id|__user
op_star
)paren
id|optval
comma
id|optlen
comma
id|SCTP_BINDX_ADD_ADDR
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_SOCKOPT_BINDX_REM
suffix:colon
multiline_comment|/* &squot;optlen&squot; is the size of the addresses buffer. */
id|retval
op_assign
id|sctp_setsockopt_bindx
c_func
(paren
id|sk
comma
(paren
r_struct
id|sockaddr
id|__user
op_star
)paren
id|optval
comma
id|optlen
comma
id|SCTP_BINDX_REM_ADDR
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_DISABLE_FRAGMENTS
suffix:colon
id|retval
op_assign
id|sctp_setsockopt_disable_fragments
c_func
(paren
id|sk
comma
id|optval
comma
id|optlen
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_EVENTS
suffix:colon
id|retval
op_assign
id|sctp_setsockopt_events
c_func
(paren
id|sk
comma
id|optval
comma
id|optlen
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_AUTOCLOSE
suffix:colon
id|retval
op_assign
id|sctp_setsockopt_autoclose
c_func
(paren
id|sk
comma
id|optval
comma
id|optlen
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_PEER_ADDR_PARAMS
suffix:colon
id|retval
op_assign
id|sctp_setsockopt_peer_addr_params
c_func
(paren
id|sk
comma
id|optval
comma
id|optlen
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_INITMSG
suffix:colon
id|retval
op_assign
id|sctp_setsockopt_initmsg
c_func
(paren
id|sk
comma
id|optval
comma
id|optlen
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_DEFAULT_SEND_PARAM
suffix:colon
id|retval
op_assign
id|sctp_setsockopt_default_send_param
c_func
(paren
id|sk
comma
id|optval
comma
id|optlen
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_PRIMARY_ADDR
suffix:colon
id|retval
op_assign
id|sctp_setsockopt_primary_addr
c_func
(paren
id|sk
comma
id|optval
comma
id|optlen
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_SET_PEER_PRIMARY_ADDR
suffix:colon
id|retval
op_assign
id|sctp_setsockopt_peer_primary_addr
c_func
(paren
id|sk
comma
id|optval
comma
id|optlen
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_NODELAY
suffix:colon
id|retval
op_assign
id|sctp_setsockopt_nodelay
c_func
(paren
id|sk
comma
id|optval
comma
id|optlen
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_RTOINFO
suffix:colon
id|retval
op_assign
id|sctp_setsockopt_rtoinfo
c_func
(paren
id|sk
comma
id|optval
comma
id|optlen
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_ASSOCINFO
suffix:colon
id|retval
op_assign
id|sctp_setsockopt_associnfo
c_func
(paren
id|sk
comma
id|optval
comma
id|optlen
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_I_WANT_MAPPED_V4_ADDR
suffix:colon
id|retval
op_assign
id|sctp_setsockopt_mappedv4
c_func
(paren
id|sk
comma
id|optval
comma
id|optlen
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_MAXSEG
suffix:colon
id|retval
op_assign
id|sctp_setsockopt_maxseg
c_func
(paren
id|sk
comma
id|optval
comma
id|optlen
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_ADAPTION_LAYER
suffix:colon
id|retval
op_assign
id|sctp_setsockopt_adaption_layer
c_func
(paren
id|sk
comma
id|optval
comma
id|optlen
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|retval
op_assign
op_minus
id|ENOPROTOOPT
suffix:semicolon
r_break
suffix:semicolon
)brace
suffix:semicolon
id|sctp_release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
id|out_nounlock
suffix:colon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/* API 3.1.6 connect() - UDP Style Syntax&n; *&n; * An application may use the connect() call in the UDP model to initiate an&n; * association without sending data.&n; *&n; * The syntax is:&n; *&n; * ret = connect(int sd, const struct sockaddr *nam, socklen_t len);&n; *&n; * sd: the socket descriptor to have a new association added to.&n; *&n; * nam: the address structure (either struct sockaddr_in or struct&n; *    sockaddr_in6 defined in RFC2553 [7]).&n; *&n; * len: the size of the address.&n; */
DECL|function|sctp_connect
id|SCTP_STATIC
r_int
id|sctp_connect
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sockaddr
op_star
id|uaddr
comma
r_int
id|addr_len
)paren
(brace
r_struct
id|sctp_opt
op_star
id|sp
suffix:semicolon
r_struct
id|sctp_endpoint
op_star
id|ep
suffix:semicolon
r_struct
id|sctp_association
op_star
id|asoc
suffix:semicolon
r_struct
id|sctp_transport
op_star
id|transport
suffix:semicolon
r_union
id|sctp_addr
id|to
suffix:semicolon
r_struct
id|sctp_af
op_star
id|af
suffix:semicolon
id|sctp_scope_t
id|scope
suffix:semicolon
r_int
id|timeo
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
id|sctp_lock_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;%s - sk: %p, sockaddr: %p, addr_len: %d)&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|sk
comma
id|uaddr
comma
id|addr_len
)paren
suffix:semicolon
id|sp
op_assign
id|sctp_sk
c_func
(paren
id|sk
)paren
suffix:semicolon
id|ep
op_assign
id|sp-&gt;ep
suffix:semicolon
multiline_comment|/* connect() cannot be done on a socket that is already in ESTABLISHED&n;&t; * state - UDP-style peeled off socket or a TCP-style socket that&n;&t; * is already connected.&n;&t; * It cannot be done even on a TCP-style listening socket.&n;&t; */
r_if
c_cond
(paren
id|sctp_sstate
c_func
(paren
id|sk
comma
id|ESTABLISHED
)paren
op_logical_or
(paren
id|sctp_style
c_func
(paren
id|sk
comma
id|TCP
)paren
op_logical_and
id|sctp_sstate
c_func
(paren
id|sk
comma
id|LISTENING
)paren
)paren
)paren
(brace
id|err
op_assign
op_minus
id|EISCONN
suffix:semicolon
r_goto
id|out_unlock
suffix:semicolon
)brace
id|err
op_assign
id|sctp_verify_addr
c_func
(paren
id|sk
comma
(paren
r_union
id|sctp_addr
op_star
)paren
id|uaddr
comma
id|addr_len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out_unlock
suffix:semicolon
r_if
c_cond
(paren
id|addr_len
OG
r_sizeof
(paren
id|to
)paren
)paren
id|addr_len
op_assign
r_sizeof
(paren
id|to
)paren
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|to
comma
id|uaddr
comma
id|addr_len
)paren
suffix:semicolon
id|to.v4.sin_port
op_assign
id|ntohs
c_func
(paren
id|to.v4.sin_port
)paren
suffix:semicolon
id|asoc
op_assign
id|sctp_endpoint_lookup_assoc
c_func
(paren
id|ep
comma
op_amp
id|to
comma
op_amp
id|transport
)paren
suffix:semicolon
r_if
c_cond
(paren
id|asoc
)paren
(brace
r_if
c_cond
(paren
id|asoc-&gt;state
op_ge
id|SCTP_STATE_ESTABLISHED
)paren
id|err
op_assign
op_minus
id|EISCONN
suffix:semicolon
r_else
id|err
op_assign
op_minus
id|EALREADY
suffix:semicolon
r_goto
id|out_unlock
suffix:semicolon
)brace
multiline_comment|/* If we could not find a matching association on the endpoint,&n;&t; * make sure that there is no peeled-off association matching the&n;&t; * peer address even on another socket.&n;&t; */
r_if
c_cond
(paren
id|sctp_endpoint_is_peeled_off
c_func
(paren
id|ep
comma
op_amp
id|to
)paren
)paren
(brace
id|err
op_assign
op_minus
id|EADDRNOTAVAIL
suffix:semicolon
r_goto
id|out_unlock
suffix:semicolon
)brace
multiline_comment|/* If a bind() or sctp_bindx() is not called prior to a connect()&n;&t; * call, the system picks an ephemeral port and will choose an address&n;&t; * set equivalent to binding with a wildcard address.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|ep-&gt;base.bind_addr.port
)paren
(brace
r_if
c_cond
(paren
id|sctp_autobind
c_func
(paren
id|sk
)paren
)paren
(brace
id|err
op_assign
op_minus
id|EAGAIN
suffix:semicolon
r_goto
id|out_unlock
suffix:semicolon
)brace
)brace
id|scope
op_assign
id|sctp_scope
c_func
(paren
op_amp
id|to
)paren
suffix:semicolon
id|asoc
op_assign
id|sctp_association_new
c_func
(paren
id|ep
comma
id|sk
comma
id|scope
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|asoc
)paren
(brace
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|out_unlock
suffix:semicolon
)brace
multiline_comment|/* Prime the peer&squot;s transport structures.  */
id|transport
op_assign
id|sctp_assoc_add_peer
c_func
(paren
id|asoc
comma
op_amp
id|to
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|transport
)paren
(brace
id|sctp_association_free
c_func
(paren
id|asoc
)paren
suffix:semicolon
r_goto
id|out_unlock
suffix:semicolon
)brace
id|err
op_assign
id|sctp_assoc_set_bind_addr_from_ep
c_func
(paren
id|asoc
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
(brace
id|sctp_association_free
c_func
(paren
id|asoc
)paren
suffix:semicolon
r_goto
id|out_unlock
suffix:semicolon
)brace
id|err
op_assign
id|sctp_primitive_ASSOCIATE
c_func
(paren
id|asoc
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
(brace
id|sctp_association_free
c_func
(paren
id|asoc
)paren
suffix:semicolon
r_goto
id|out_unlock
suffix:semicolon
)brace
multiline_comment|/* Initialize sk&squot;s dport and daddr for getpeername() */
id|inet_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|dport
op_assign
id|htons
c_func
(paren
id|asoc-&gt;peer.port
)paren
suffix:semicolon
id|af
op_assign
id|sctp_get_af_specific
c_func
(paren
id|to.sa.sa_family
)paren
suffix:semicolon
id|af
op_member_access_from_pointer
id|to_sk_daddr
c_func
(paren
op_amp
id|to
comma
id|sk
)paren
suffix:semicolon
id|timeo
op_assign
id|sock_sndtimeo
c_func
(paren
id|sk
comma
id|sk-&gt;sk_socket-&gt;file-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
suffix:semicolon
id|err
op_assign
id|sctp_wait_for_connect
c_func
(paren
id|asoc
comma
op_amp
id|timeo
)paren
suffix:semicolon
id|out_unlock
suffix:colon
id|sctp_release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/* FIXME: Write comments. */
DECL|function|sctp_disconnect
id|SCTP_STATIC
r_int
id|sctp_disconnect
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|flags
)paren
(brace
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
multiline_comment|/* STUB */
)brace
multiline_comment|/* 4.1.4 accept() - TCP Style Syntax&n; *&n; * Applications use accept() call to remove an established SCTP&n; * association from the accept queue of the endpoint.  A new socket&n; * descriptor will be returned from accept() to represent the newly&n; * formed association.&n; */
DECL|function|sctp_accept
id|SCTP_STATIC
r_struct
id|sock
op_star
id|sctp_accept
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|flags
comma
r_int
op_star
id|err
)paren
(brace
r_struct
id|sctp_opt
op_star
id|sp
suffix:semicolon
r_struct
id|sctp_endpoint
op_star
id|ep
suffix:semicolon
r_struct
id|sock
op_star
id|newsk
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|sctp_association
op_star
id|asoc
suffix:semicolon
r_int
id|timeo
suffix:semicolon
r_int
id|error
op_assign
l_int|0
suffix:semicolon
id|sctp_lock_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
id|sp
op_assign
id|sctp_sk
c_func
(paren
id|sk
)paren
suffix:semicolon
id|ep
op_assign
id|sp-&gt;ep
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sctp_style
c_func
(paren
id|sk
comma
id|TCP
)paren
)paren
(brace
id|error
op_assign
op_minus
id|EOPNOTSUPP
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|sctp_sstate
c_func
(paren
id|sk
comma
id|LISTENING
)paren
)paren
(brace
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|timeo
op_assign
id|sock_rcvtimeo
c_func
(paren
id|sk
comma
id|sk-&gt;sk_socket-&gt;file-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
suffix:semicolon
id|error
op_assign
id|sctp_wait_for_accept
c_func
(paren
id|sk
comma
id|timeo
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* We treat the list of associations on the endpoint as the accept&n;&t; * queue and pick the first association on the list.&n;&t; */
id|asoc
op_assign
id|list_entry
c_func
(paren
id|ep-&gt;asocs.next
comma
r_struct
id|sctp_association
comma
id|asocs
)paren
suffix:semicolon
id|newsk
op_assign
id|sp-&gt;pf
op_member_access_from_pointer
id|create_accept_sk
c_func
(paren
id|sk
comma
id|asoc
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|newsk
)paren
(brace
id|error
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* Populate the fields of the newsk from the oldsk and migrate the&n;&t; * asoc to the newsk.&n;&t; */
id|sctp_sock_migrate
c_func
(paren
id|sk
comma
id|newsk
comma
id|asoc
comma
id|SCTP_SOCKET_TCP
)paren
suffix:semicolon
id|out
suffix:colon
id|sctp_release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
op_star
id|err
op_assign
id|error
suffix:semicolon
r_return
id|newsk
suffix:semicolon
)brace
multiline_comment|/* The SCTP ioctl handler. */
DECL|function|sctp_ioctl
id|SCTP_STATIC
r_int
id|sctp_ioctl
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_return
op_minus
id|ENOIOCTLCMD
suffix:semicolon
)brace
multiline_comment|/* This is the function which gets called during socket creation to&n; * initialized the SCTP-specific portion of the sock.&n; * The sock structure should already be zero-filled memory.&n; */
DECL|function|sctp_init_sock
id|SCTP_STATIC
r_int
id|sctp_init_sock
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|sctp_endpoint
op_star
id|ep
suffix:semicolon
r_struct
id|sctp_opt
op_star
id|sp
suffix:semicolon
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;sctp_init_sock(sk: %p)&bslash;n&quot;
comma
id|sk
)paren
suffix:semicolon
id|sp
op_assign
id|sctp_sk
c_func
(paren
id|sk
)paren
suffix:semicolon
multiline_comment|/* Initialize the SCTP per socket area.  */
r_switch
c_cond
(paren
id|sk-&gt;sk_type
)paren
(brace
r_case
id|SOCK_SEQPACKET
suffix:colon
id|sp-&gt;type
op_assign
id|SCTP_SOCKET_UDP
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOCK_STREAM
suffix:colon
id|sp-&gt;type
op_assign
id|SCTP_SOCKET_TCP
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|ESOCKTNOSUPPORT
suffix:semicolon
)brace
multiline_comment|/* Initialize default send parameters. These parameters can be&n;&t; * modified with the SCTP_DEFAULT_SEND_PARAM socket option.&n;&t; */
id|sp-&gt;default_stream
op_assign
l_int|0
suffix:semicolon
id|sp-&gt;default_ppid
op_assign
l_int|0
suffix:semicolon
id|sp-&gt;default_flags
op_assign
l_int|0
suffix:semicolon
id|sp-&gt;default_context
op_assign
l_int|0
suffix:semicolon
id|sp-&gt;default_timetolive
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Initialize default setup parameters. These parameters&n;&t; * can be modified with the SCTP_INITMSG socket option or&n;&t; * overridden by the SCTP_INIT CMSG.&n;&t; */
id|sp-&gt;initmsg.sinit_num_ostreams
op_assign
id|sctp_max_outstreams
suffix:semicolon
id|sp-&gt;initmsg.sinit_max_instreams
op_assign
id|sctp_max_instreams
suffix:semicolon
id|sp-&gt;initmsg.sinit_max_attempts
op_assign
id|sctp_max_retrans_init
suffix:semicolon
id|sp-&gt;initmsg.sinit_max_init_timeo
op_assign
id|jiffies_to_msecs
c_func
(paren
id|sctp_rto_max
)paren
suffix:semicolon
multiline_comment|/* Initialize default RTO related parameters.  These parameters can&n;&t; * be modified for with the SCTP_RTOINFO socket option.&n;&t; */
id|sp-&gt;rtoinfo.srto_initial
op_assign
id|jiffies_to_msecs
c_func
(paren
id|sctp_rto_initial
)paren
suffix:semicolon
id|sp-&gt;rtoinfo.srto_max
op_assign
id|jiffies_to_msecs
c_func
(paren
id|sctp_rto_max
)paren
suffix:semicolon
id|sp-&gt;rtoinfo.srto_min
op_assign
id|jiffies_to_msecs
c_func
(paren
id|sctp_rto_min
)paren
suffix:semicolon
multiline_comment|/* Initialize default association related parameters. These parameters&n;&t; * can be modified with the SCTP_ASSOCINFO socket option.&n;&t; */
id|sp-&gt;assocparams.sasoc_asocmaxrxt
op_assign
id|sctp_max_retrans_association
suffix:semicolon
id|sp-&gt;assocparams.sasoc_number_peer_destinations
op_assign
l_int|0
suffix:semicolon
id|sp-&gt;assocparams.sasoc_peer_rwnd
op_assign
l_int|0
suffix:semicolon
id|sp-&gt;assocparams.sasoc_local_rwnd
op_assign
l_int|0
suffix:semicolon
id|sp-&gt;assocparams.sasoc_cookie_life
op_assign
id|jiffies_to_msecs
c_func
(paren
id|sctp_valid_cookie_life
)paren
suffix:semicolon
multiline_comment|/* Initialize default event subscriptions. By default, all the&n;&t; * options are off. &n;&t; */
id|memset
c_func
(paren
op_amp
id|sp-&gt;subscribe
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|sctp_event_subscribe
)paren
)paren
suffix:semicolon
multiline_comment|/* Default Peer Address Parameters.  These defaults can&n;&t; * be modified via SCTP_PEER_ADDR_PARAMS&n;&t; */
id|sp-&gt;paddrparam.spp_hbinterval
op_assign
id|jiffies_to_msecs
c_func
(paren
id|sctp_hb_interval
)paren
suffix:semicolon
id|sp-&gt;paddrparam.spp_pathmaxrxt
op_assign
id|sctp_max_retrans_path
suffix:semicolon
multiline_comment|/* If enabled no SCTP message fragmentation will be performed.&n;&t; * Configure through SCTP_DISABLE_FRAGMENTS socket option.&n;&t; */
id|sp-&gt;disable_fragments
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Turn on/off any Nagle-like algorithm.  */
id|sp-&gt;nodelay
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Enable by default. */
id|sp-&gt;v4mapped
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Auto-close idle associations after the configured&n;&t; * number of seconds.  A value of 0 disables this&n;&t; * feature.  Configure through the SCTP_AUTOCLOSE socket option,&n;&t; * for UDP-style sockets only.&n;&t; */
id|sp-&gt;autoclose
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* User specified fragmentation limit. */
id|sp-&gt;user_frag
op_assign
l_int|0
suffix:semicolon
id|sp-&gt;adaption_ind
op_assign
l_int|0
suffix:semicolon
id|sp-&gt;pf
op_assign
id|sctp_get_pf_specific
c_func
(paren
id|sk-&gt;sk_family
)paren
suffix:semicolon
multiline_comment|/* Control variables for partial data delivery. */
id|sp-&gt;pd_mode
op_assign
l_int|0
suffix:semicolon
id|skb_queue_head_init
c_func
(paren
op_amp
id|sp-&gt;pd_lobby
)paren
suffix:semicolon
multiline_comment|/* Create a per socket endpoint structure.  Even if we&n;&t; * change the data structure relationships, this may still&n;&t; * be useful for storing pre-connect address information.&n;&t; */
id|ep
op_assign
id|sctp_endpoint_new
c_func
(paren
id|sk
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ep
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|sp-&gt;ep
op_assign
id|ep
suffix:semicolon
id|sp-&gt;hmac
op_assign
l_int|NULL
suffix:semicolon
id|SCTP_DBG_OBJCNT_INC
c_func
(paren
id|sock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Cleanup any SCTP per socket resources.  */
DECL|function|sctp_destroy_sock
id|SCTP_STATIC
r_int
id|sctp_destroy_sock
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|sctp_endpoint
op_star
id|ep
suffix:semicolon
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;sctp_destroy_sock(sk: %p)&bslash;n&quot;
comma
id|sk
)paren
suffix:semicolon
multiline_comment|/* Release our hold on the endpoint. */
id|ep
op_assign
id|sctp_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|ep
suffix:semicolon
id|sctp_endpoint_free
c_func
(paren
id|ep
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* API 4.1.7 shutdown() - TCP Style Syntax&n; *     int shutdown(int socket, int how);&n; *&n; *     sd      - the socket descriptor of the association to be closed.&n; *     how     - Specifies the type of shutdown.  The  values  are&n; *               as follows:&n; *               SHUT_RD&n; *                     Disables further receive operations. No SCTP&n; *                     protocol action is taken.&n; *               SHUT_WR&n; *                     Disables further send operations, and initiates&n; *                     the SCTP shutdown sequence.&n; *               SHUT_RDWR&n; *                     Disables further send  and  receive  operations&n; *                     and initiates the SCTP shutdown sequence.&n; */
DECL|function|sctp_shutdown
id|SCTP_STATIC
r_void
id|sctp_shutdown
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|how
)paren
(brace
r_struct
id|sctp_endpoint
op_star
id|ep
suffix:semicolon
r_struct
id|sctp_association
op_star
id|asoc
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sctp_style
c_func
(paren
id|sk
comma
id|TCP
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|how
op_amp
id|SEND_SHUTDOWN
)paren
(brace
id|ep
op_assign
id|sctp_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|ep
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|ep-&gt;asocs
)paren
)paren
(brace
id|asoc
op_assign
id|list_entry
c_func
(paren
id|ep-&gt;asocs.next
comma
r_struct
id|sctp_association
comma
id|asocs
)paren
suffix:semicolon
id|sctp_primitive_SHUTDOWN
c_func
(paren
id|asoc
comma
l_int|NULL
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* 7.2.1 Association Status (SCTP_STATUS)&n;&n; * Applications can retrieve current status information about an&n; * association, including association state, peer receiver window size,&n; * number of unacked data chunks, and number of data chunks pending&n; * receipt.  This information is read-only.&n; */
DECL|function|sctp_getsockopt_sctp_status
r_static
r_int
id|sctp_getsockopt_sctp_status
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|len
comma
r_char
id|__user
op_star
id|optval
comma
r_int
id|__user
op_star
id|optlen
)paren
(brace
r_struct
id|sctp_status
id|status
suffix:semicolon
r_struct
id|sctp_association
op_star
id|asoc
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|sctp_transport
op_star
id|transport
suffix:semicolon
id|sctp_assoc_t
id|associd
suffix:semicolon
r_int
id|retval
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|len
op_ne
r_sizeof
(paren
id|status
)paren
)paren
(brace
id|retval
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|status
comma
id|optval
comma
r_sizeof
(paren
id|status
)paren
)paren
)paren
(brace
id|retval
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|associd
op_assign
id|status.sstat_assoc_id
suffix:semicolon
id|asoc
op_assign
id|sctp_id2assoc
c_func
(paren
id|sk
comma
id|associd
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|asoc
)paren
(brace
id|retval
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|transport
op_assign
id|asoc-&gt;peer.primary_path
suffix:semicolon
id|status.sstat_assoc_id
op_assign
id|sctp_assoc2id
c_func
(paren
id|asoc
)paren
suffix:semicolon
id|status.sstat_state
op_assign
id|asoc-&gt;state
suffix:semicolon
id|status.sstat_rwnd
op_assign
id|asoc-&gt;peer.rwnd
suffix:semicolon
id|status.sstat_unackdata
op_assign
id|asoc-&gt;unack_data
suffix:semicolon
id|status.sstat_penddata
op_assign
id|sctp_tsnmap_pending
c_func
(paren
op_amp
id|asoc-&gt;peer.tsn_map
)paren
suffix:semicolon
id|status.sstat_instrms
op_assign
id|asoc-&gt;c.sinit_max_instreams
suffix:semicolon
id|status.sstat_outstrms
op_assign
id|asoc-&gt;c.sinit_num_ostreams
suffix:semicolon
id|status.sstat_fragmentation_point
op_assign
id|asoc-&gt;frag_point
suffix:semicolon
id|status.sstat_primary.spinfo_assoc_id
op_assign
id|sctp_assoc2id
c_func
(paren
id|transport-&gt;asoc
)paren
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|status.sstat_primary.spinfo_address
comma
op_amp
(paren
id|transport-&gt;ipaddr
)paren
comma
r_sizeof
(paren
r_union
id|sctp_addr
)paren
)paren
suffix:semicolon
multiline_comment|/* Map ipv4 address into v4-mapped-on-v6 address.  */
id|sctp_get_pf_specific
c_func
(paren
id|sk-&gt;sk_family
)paren
op_member_access_from_pointer
id|addr_v4map
c_func
(paren
id|sctp_sk
c_func
(paren
id|sk
)paren
comma
(paren
r_union
id|sctp_addr
op_star
)paren
op_amp
id|status.sstat_primary.spinfo_address
)paren
suffix:semicolon
id|status.sstat_primary.spinfo_state
op_assign
id|transport-&gt;active
suffix:semicolon
id|status.sstat_primary.spinfo_cwnd
op_assign
id|transport-&gt;cwnd
suffix:semicolon
id|status.sstat_primary.spinfo_srtt
op_assign
id|transport-&gt;srtt
suffix:semicolon
id|status.sstat_primary.spinfo_rto
op_assign
id|jiffies_to_msecs
c_func
(paren
id|transport-&gt;rto
)paren
suffix:semicolon
id|status.sstat_primary.spinfo_mtu
op_assign
id|transport-&gt;pmtu
suffix:semicolon
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|len
comma
id|optlen
)paren
)paren
(brace
id|retval
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;sctp_getsockopt_sctp_status(%d): %d %d %p&bslash;n&quot;
comma
id|len
comma
id|status.sstat_state
comma
id|status.sstat_rwnd
comma
id|status.sstat_assoc_id
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|optval
comma
op_amp
id|status
comma
id|len
)paren
)paren
(brace
id|retval
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|out
suffix:colon
r_return
(paren
id|retval
)paren
suffix:semicolon
)brace
multiline_comment|/* 7.2.2 Peer Address Information (SCTP_GET_PEER_ADDR_INFO)&n; *&n; * Applications can retrieve information about a specific peer address&n; * of an association, including its reachability state, congestion&n; * window, and retransmission timer values.  This information is&n; * read-only.&n; */
DECL|function|sctp_getsockopt_peer_addr_info
r_static
r_int
id|sctp_getsockopt_peer_addr_info
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|len
comma
r_char
id|__user
op_star
id|optval
comma
r_int
id|__user
op_star
id|optlen
)paren
(brace
r_struct
id|sctp_paddrinfo
id|pinfo
suffix:semicolon
r_struct
id|sctp_transport
op_star
id|transport
suffix:semicolon
r_int
id|retval
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|len
op_ne
r_sizeof
(paren
id|pinfo
)paren
)paren
(brace
id|retval
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|pinfo
comma
id|optval
comma
r_sizeof
(paren
id|pinfo
)paren
)paren
)paren
(brace
id|retval
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|transport
op_assign
id|sctp_addr_id2transport
c_func
(paren
id|sk
comma
op_amp
id|pinfo.spinfo_address
comma
id|pinfo.spinfo_assoc_id
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|transport
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|pinfo.spinfo_assoc_id
op_assign
id|sctp_assoc2id
c_func
(paren
id|transport-&gt;asoc
)paren
suffix:semicolon
id|pinfo.spinfo_state
op_assign
id|transport-&gt;active
suffix:semicolon
id|pinfo.spinfo_cwnd
op_assign
id|transport-&gt;cwnd
suffix:semicolon
id|pinfo.spinfo_srtt
op_assign
id|transport-&gt;srtt
suffix:semicolon
id|pinfo.spinfo_rto
op_assign
id|jiffies_to_msecs
c_func
(paren
id|transport-&gt;rto
)paren
suffix:semicolon
id|pinfo.spinfo_mtu
op_assign
id|transport-&gt;pmtu
suffix:semicolon
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|len
comma
id|optlen
)paren
)paren
(brace
id|retval
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|optval
comma
op_amp
id|pinfo
comma
id|len
)paren
)paren
(brace
id|retval
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|out
suffix:colon
r_return
(paren
id|retval
)paren
suffix:semicolon
)brace
multiline_comment|/* 7.1.12 Enable/Disable message fragmentation (SCTP_DISABLE_FRAGMENTS)&n; *&n; * This option is a on/off flag.  If enabled no SCTP message&n; * fragmentation will be performed.  Instead if a message being sent&n; * exceeds the current PMTU size, the message will NOT be sent and&n; * instead a error will be indicated to the user.&n; */
DECL|function|sctp_getsockopt_disable_fragments
r_static
r_int
id|sctp_getsockopt_disable_fragments
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|len
comma
r_char
id|__user
op_star
id|optval
comma
r_int
id|__user
op_star
id|optlen
)paren
(brace
r_int
id|val
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
r_sizeof
(paren
r_int
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|len
op_assign
r_sizeof
(paren
r_int
)paren
suffix:semicolon
id|val
op_assign
(paren
id|sctp_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|disable_fragments
op_eq
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|len
comma
id|optlen
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|optval
comma
op_amp
id|val
comma
id|len
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* 7.1.15 Set notification and ancillary events (SCTP_EVENTS)&n; *&n; * This socket option is used to specify various notifications and&n; * ancillary data the user wishes to receive.&n; */
DECL|function|sctp_getsockopt_events
r_static
r_int
id|sctp_getsockopt_events
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|len
comma
r_char
id|__user
op_star
id|optval
comma
r_int
id|__user
op_star
id|optlen
)paren
(brace
r_if
c_cond
(paren
id|len
op_ne
r_sizeof
(paren
r_struct
id|sctp_event_subscribe
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|optval
comma
op_amp
id|sctp_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|subscribe
comma
id|len
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* 7.1.8 Automatic Close of associations (SCTP_AUTOCLOSE)&n; *&n; * This socket option is applicable to the UDP-style socket only.  When&n; * set it will cause associations that are idle for more than the&n; * specified number of seconds to automatically close.  An association&n; * being idle is defined an association that has NOT sent or received&n; * user data.  The special value of &squot;0&squot; indicates that no automatic&n; * close of any associations should be performed.  The option expects an&n; * integer defining the number of seconds of idle time before an&n; * association is closed.&n; */
DECL|function|sctp_getsockopt_autoclose
r_static
r_int
id|sctp_getsockopt_autoclose
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|len
comma
r_char
id|__user
op_star
id|optval
comma
r_int
id|__user
op_star
id|optlen
)paren
(brace
multiline_comment|/* Applicable to UDP-style socket only */
r_if
c_cond
(paren
id|sctp_style
c_func
(paren
id|sk
comma
id|TCP
)paren
)paren
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
r_if
c_cond
(paren
id|len
op_ne
r_sizeof
(paren
r_int
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|optval
comma
op_amp
id|sctp_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|autoclose
comma
id|len
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Helper routine to branch off an association to a new socket.  */
DECL|function|sctp_do_peeloff
id|SCTP_STATIC
r_int
id|sctp_do_peeloff
c_func
(paren
r_struct
id|sctp_association
op_star
id|asoc
comma
r_struct
id|socket
op_star
op_star
id|sockp
)paren
(brace
r_struct
id|sock
op_star
id|sk
op_assign
id|asoc-&gt;base.sk
suffix:semicolon
r_struct
id|socket
op_star
id|sock
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* An association cannot be branched off from an already peeled-off&n;&t; * socket, nor is this supported for tcp style sockets.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|sctp_style
c_func
(paren
id|sk
comma
id|UDP
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* Create a new socket.  */
id|err
op_assign
id|sock_create
c_func
(paren
id|sk-&gt;sk_family
comma
id|SOCK_SEQPACKET
comma
id|IPPROTO_SCTP
comma
op_amp
id|sock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_return
id|err
suffix:semicolon
multiline_comment|/* Populate the fields of the newsk from the oldsk and migrate the&n;&t; * asoc to the newsk.&n;&t; */
id|sctp_sock_migrate
c_func
(paren
id|sk
comma
id|sock-&gt;sk
comma
id|asoc
comma
id|SCTP_SOCKET_UDP_HIGH_BANDWIDTH
)paren
suffix:semicolon
op_star
id|sockp
op_assign
id|sock
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|function|sctp_getsockopt_peeloff
r_static
r_int
id|sctp_getsockopt_peeloff
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|len
comma
r_char
id|__user
op_star
id|optval
comma
r_int
id|__user
op_star
id|optlen
)paren
(brace
id|sctp_peeloff_arg_t
id|peeloff
suffix:semicolon
r_struct
id|socket
op_star
id|newsock
suffix:semicolon
r_int
id|retval
op_assign
l_int|0
suffix:semicolon
r_struct
id|sctp_association
op_star
id|asoc
suffix:semicolon
r_if
c_cond
(paren
id|len
op_ne
r_sizeof
(paren
id|sctp_peeloff_arg_t
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|peeloff
comma
id|optval
comma
id|len
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|asoc
op_assign
id|sctp_id2assoc
c_func
(paren
id|sk
comma
id|peeloff.associd
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|asoc
)paren
(brace
id|retval
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;%s: sk: %p asoc: %p&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|sk
comma
id|asoc
)paren
suffix:semicolon
id|retval
op_assign
id|sctp_do_peeloff
c_func
(paren
id|asoc
comma
op_amp
id|newsock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
OL
l_int|0
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* Map the socket to an unused fd that can be returned to the user.  */
id|retval
op_assign
id|sock_map_fd
c_func
(paren
id|newsock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
OL
l_int|0
)paren
(brace
id|sock_release
c_func
(paren
id|newsock
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;%s: sk: %p asoc: %p newsk: %p sd: %d&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|sk
comma
id|asoc
comma
id|newsock-&gt;sk
comma
id|retval
)paren
suffix:semicolon
multiline_comment|/* Return the fd mapped to the new socket.  */
id|peeloff.sd
op_assign
id|retval
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|optval
comma
op_amp
id|peeloff
comma
id|len
)paren
)paren
id|retval
op_assign
op_minus
id|EFAULT
suffix:semicolon
id|out
suffix:colon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/* 7.1.13 Peer Address Parameters (SCTP_PEER_ADDR_PARAMS)&n; *&n; * Applications can enable or disable heartbeats for any peer address of&n; * an association, modify an address&squot;s heartbeat interval, force a&n; * heartbeat to be sent immediately, and adjust the address&squot;s maximum&n; * number of retransmissions sent before an address is considered&n; * unreachable.  The following structure is used to access and modify an&n; * address&squot;s parameters:&n; *&n; *  struct sctp_paddrparams {&n; *      sctp_assoc_t            spp_assoc_id;&n; *      struct sockaddr_storage spp_address;&n; *      uint32_t                spp_hbinterval;&n; *      uint16_t                spp_pathmaxrxt;&n; *  };&n; *&n; *   spp_assoc_id    - (UDP style socket) This is filled in the application,&n; *                     and identifies the association for this query.&n; *   spp_address     - This specifies which address is of interest.&n; *   spp_hbinterval  - This contains the value of the heartbeat interval,&n; *                     in milliseconds.  A value of 0, when modifying the&n; *                     parameter, specifies that the heartbeat on this&n; *                     address should be disabled. A value of UINT32_MAX&n; *                     (4294967295), when modifying the parameter,&n; *                     specifies that a heartbeat should be sent&n; *                     immediately to the peer address, and the current&n; *                     interval should remain unchanged.&n; *   spp_pathmaxrxt  - This contains the maximum number of&n; *                     retransmissions before this address shall be&n; *                     considered unreachable.&n; */
DECL|function|sctp_getsockopt_peer_addr_params
r_static
r_int
id|sctp_getsockopt_peer_addr_params
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|len
comma
r_char
id|__user
op_star
id|optval
comma
r_int
id|__user
op_star
id|optlen
)paren
(brace
r_struct
id|sctp_paddrparams
id|params
suffix:semicolon
r_struct
id|sctp_transport
op_star
id|trans
suffix:semicolon
r_if
c_cond
(paren
id|len
op_ne
r_sizeof
(paren
r_struct
id|sctp_paddrparams
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|params
comma
id|optval
comma
id|len
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
multiline_comment|/* If no association id is specified retrieve the default value&n;&t; * for the endpoint that will be used for all future associations&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|params.spp_assoc_id
op_logical_and
id|sctp_is_any
c_func
(paren
(paren
r_union
id|sctp_addr
op_star
)paren
op_amp
id|params.spp_address
)paren
)paren
(brace
id|params.spp_hbinterval
op_assign
id|sctp_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|paddrparam.spp_hbinterval
suffix:semicolon
id|params.spp_pathmaxrxt
op_assign
id|sctp_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|paddrparam.spp_pathmaxrxt
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
id|trans
op_assign
id|sctp_addr_id2transport
c_func
(paren
id|sk
comma
op_amp
id|params.spp_address
comma
id|params.spp_assoc_id
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|trans
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* The value of the heartbeat interval, in milliseconds. A value of 0,&n;&t; * when modifying the parameter, specifies that the heartbeat on this&n;&t; * address should be disabled.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|trans-&gt;hb_allowed
)paren
id|params.spp_hbinterval
op_assign
l_int|0
suffix:semicolon
r_else
id|params.spp_hbinterval
op_assign
id|jiffies_to_msecs
c_func
(paren
id|trans-&gt;hb_interval
)paren
suffix:semicolon
multiline_comment|/* spp_pathmaxrxt contains the maximum number of retransmissions&n;&t; * before this address shall be considered unreachable.&n;&t; */
id|params.spp_pathmaxrxt
op_assign
id|trans-&gt;error_threshold
suffix:semicolon
id|done
suffix:colon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|optval
comma
op_amp
id|params
comma
id|len
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|len
comma
id|optlen
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* 7.1.3 Initialization Parameters (SCTP_INITMSG)&n; *&n; * Applications can specify protocol parameters for the default association&n; * initialization.  The option name argument to setsockopt() and getsockopt()&n; * is SCTP_INITMSG.&n; *&n; * Setting initialization parameters is effective only on an unconnected&n; * socket (for UDP-style sockets only future associations are effected&n; * by the change).  With TCP-style sockets, this option is inherited by&n; * sockets derived from a listener socket.&n; */
DECL|function|sctp_getsockopt_initmsg
r_static
r_int
id|sctp_getsockopt_initmsg
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|len
comma
r_char
id|__user
op_star
id|optval
comma
r_int
id|__user
op_star
id|optlen
)paren
(brace
r_if
c_cond
(paren
id|len
op_ne
r_sizeof
(paren
r_struct
id|sctp_initmsg
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|optval
comma
op_amp
id|sctp_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|initmsg
comma
id|len
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|sctp_getsockopt_peer_addrs_num
r_static
r_int
id|sctp_getsockopt_peer_addrs_num
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|len
comma
r_char
id|__user
op_star
id|optval
comma
r_int
id|__user
op_star
id|optlen
)paren
(brace
id|sctp_assoc_t
id|id
suffix:semicolon
r_struct
id|sctp_association
op_star
id|asoc
suffix:semicolon
r_struct
id|list_head
op_star
id|pos
suffix:semicolon
r_int
id|cnt
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|len
op_ne
r_sizeof
(paren
id|sctp_assoc_t
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|id
comma
id|optval
comma
r_sizeof
(paren
id|sctp_assoc_t
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
multiline_comment|/* For UDP-style sockets, id specifies the association to query.  */
id|asoc
op_assign
id|sctp_id2assoc
c_func
(paren
id|sk
comma
id|id
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|asoc
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|list_for_each
c_func
(paren
id|pos
comma
op_amp
id|asoc-&gt;peer.transport_addr_list
)paren
(brace
id|cnt
op_increment
suffix:semicolon
)brace
r_return
id|cnt
suffix:semicolon
)brace
DECL|function|sctp_getsockopt_peer_addrs
r_static
r_int
id|sctp_getsockopt_peer_addrs
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|len
comma
r_char
id|__user
op_star
id|optval
comma
r_int
id|__user
op_star
id|optlen
)paren
(brace
r_struct
id|sctp_association
op_star
id|asoc
suffix:semicolon
r_struct
id|list_head
op_star
id|pos
suffix:semicolon
r_int
id|cnt
op_assign
l_int|0
suffix:semicolon
r_struct
id|sctp_getaddrs
id|getaddrs
suffix:semicolon
r_struct
id|sctp_transport
op_star
id|from
suffix:semicolon
r_void
id|__user
op_star
id|to
suffix:semicolon
r_union
id|sctp_addr
id|temp
suffix:semicolon
r_struct
id|sctp_opt
op_star
id|sp
op_assign
id|sctp_sk
c_func
(paren
id|sk
)paren
suffix:semicolon
r_int
id|addrlen
suffix:semicolon
r_if
c_cond
(paren
id|len
op_ne
r_sizeof
(paren
r_struct
id|sctp_getaddrs
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|getaddrs
comma
id|optval
comma
r_sizeof
(paren
r_struct
id|sctp_getaddrs
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|getaddrs.addr_num
op_le
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* For UDP-style sockets, id specifies the association to query.  */
id|asoc
op_assign
id|sctp_id2assoc
c_func
(paren
id|sk
comma
id|getaddrs.assoc_id
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|asoc
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|to
op_assign
(paren
r_void
id|__user
op_star
)paren
id|getaddrs.addrs
suffix:semicolon
id|list_for_each
c_func
(paren
id|pos
comma
op_amp
id|asoc-&gt;peer.transport_addr_list
)paren
(brace
id|from
op_assign
id|list_entry
c_func
(paren
id|pos
comma
r_struct
id|sctp_transport
comma
id|transports
)paren
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|temp
comma
op_amp
id|from-&gt;ipaddr
comma
r_sizeof
(paren
id|temp
)paren
)paren
suffix:semicolon
id|sctp_get_pf_specific
c_func
(paren
id|sk-&gt;sk_family
)paren
op_member_access_from_pointer
id|addr_v4map
c_func
(paren
id|sp
comma
op_amp
id|temp
)paren
suffix:semicolon
id|addrlen
op_assign
id|sctp_get_af_specific
c_func
(paren
id|sk-&gt;sk_family
)paren
op_member_access_from_pointer
id|sockaddr_len
suffix:semicolon
id|temp.v4.sin_port
op_assign
id|htons
c_func
(paren
id|temp.v4.sin_port
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|to
comma
op_amp
id|temp
comma
id|addrlen
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|to
op_add_assign
id|addrlen
suffix:semicolon
id|cnt
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|cnt
op_ge
id|getaddrs.addr_num
)paren
r_break
suffix:semicolon
)brace
id|getaddrs.addr_num
op_assign
id|cnt
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|optval
comma
op_amp
id|getaddrs
comma
r_sizeof
(paren
r_struct
id|sctp_getaddrs
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|sctp_getsockopt_local_addrs_num
r_static
r_int
id|sctp_getsockopt_local_addrs_num
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|len
comma
r_char
id|__user
op_star
id|optval
comma
r_int
id|__user
op_star
id|optlen
)paren
(brace
id|sctp_assoc_t
id|id
suffix:semicolon
r_struct
id|sctp_bind_addr
op_star
id|bp
suffix:semicolon
r_struct
id|sctp_association
op_star
id|asoc
suffix:semicolon
r_struct
id|list_head
op_star
id|pos
suffix:semicolon
r_int
id|cnt
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|len
op_ne
r_sizeof
(paren
id|sctp_assoc_t
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|id
comma
id|optval
comma
r_sizeof
(paren
id|sctp_assoc_t
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
multiline_comment|/*&n;&t; *  For UDP-style sockets, id specifies the association to query.&n;&t; *  If the id field is set to the value &squot;0&squot; then the locally bound&n;&t; *  addresses are returned without regard to any particular&n;&t; *  association.&n;&t; */
r_if
c_cond
(paren
l_int|0
op_eq
id|id
)paren
(brace
id|bp
op_assign
op_amp
id|sctp_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|ep-&gt;base.bind_addr
suffix:semicolon
)brace
r_else
(brace
id|asoc
op_assign
id|sctp_id2assoc
c_func
(paren
id|sk
comma
id|id
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|asoc
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|bp
op_assign
op_amp
id|asoc-&gt;base.bind_addr
suffix:semicolon
)brace
id|list_for_each
c_func
(paren
id|pos
comma
op_amp
id|bp-&gt;address_list
)paren
(brace
id|cnt
op_increment
suffix:semicolon
)brace
r_return
id|cnt
suffix:semicolon
)brace
DECL|function|sctp_getsockopt_local_addrs
r_static
r_int
id|sctp_getsockopt_local_addrs
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|len
comma
r_char
id|__user
op_star
id|optval
comma
r_int
id|__user
op_star
id|optlen
)paren
(brace
r_struct
id|sctp_bind_addr
op_star
id|bp
suffix:semicolon
r_struct
id|sctp_association
op_star
id|asoc
suffix:semicolon
r_struct
id|list_head
op_star
id|pos
suffix:semicolon
r_int
id|cnt
op_assign
l_int|0
suffix:semicolon
r_struct
id|sctp_getaddrs
id|getaddrs
suffix:semicolon
r_struct
id|sctp_sockaddr_entry
op_star
id|from
suffix:semicolon
r_void
id|__user
op_star
id|to
suffix:semicolon
r_union
id|sctp_addr
id|temp
suffix:semicolon
r_struct
id|sctp_opt
op_star
id|sp
op_assign
id|sctp_sk
c_func
(paren
id|sk
)paren
suffix:semicolon
r_int
id|addrlen
suffix:semicolon
r_if
c_cond
(paren
id|len
op_ne
r_sizeof
(paren
r_struct
id|sctp_getaddrs
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|getaddrs
comma
id|optval
comma
r_sizeof
(paren
r_struct
id|sctp_getaddrs
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|getaddrs.addr_num
op_le
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/*&n;&t; *  For UDP-style sockets, id specifies the association to query.&n;&t; *  If the id field is set to the value &squot;0&squot; then the locally bound&n;&t; *  addresses are returned without regard to any particular&n;&t; *  association.&n;&t; */
r_if
c_cond
(paren
l_int|0
op_eq
id|getaddrs.assoc_id
)paren
(brace
id|bp
op_assign
op_amp
id|sctp_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|ep-&gt;base.bind_addr
suffix:semicolon
)brace
r_else
(brace
id|asoc
op_assign
id|sctp_id2assoc
c_func
(paren
id|sk
comma
id|getaddrs.assoc_id
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|asoc
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|bp
op_assign
op_amp
id|asoc-&gt;base.bind_addr
suffix:semicolon
)brace
id|to
op_assign
id|getaddrs.addrs
suffix:semicolon
id|list_for_each
c_func
(paren
id|pos
comma
op_amp
id|bp-&gt;address_list
)paren
(brace
id|from
op_assign
id|list_entry
c_func
(paren
id|pos
comma
r_struct
id|sctp_sockaddr_entry
comma
id|list
)paren
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|temp
comma
op_amp
id|from-&gt;a
comma
r_sizeof
(paren
id|temp
)paren
)paren
suffix:semicolon
id|sctp_get_pf_specific
c_func
(paren
id|sk-&gt;sk_family
)paren
op_member_access_from_pointer
id|addr_v4map
c_func
(paren
id|sp
comma
op_amp
id|temp
)paren
suffix:semicolon
id|addrlen
op_assign
id|sctp_get_af_specific
c_func
(paren
id|temp.sa.sa_family
)paren
op_member_access_from_pointer
id|sockaddr_len
suffix:semicolon
id|temp.v4.sin_port
op_assign
id|htons
c_func
(paren
id|temp.v4.sin_port
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|to
comma
op_amp
id|temp
comma
id|addrlen
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|to
op_add_assign
id|addrlen
suffix:semicolon
id|cnt
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|cnt
op_ge
id|getaddrs.addr_num
)paren
r_break
suffix:semicolon
)brace
id|getaddrs.addr_num
op_assign
id|cnt
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|optval
comma
op_amp
id|getaddrs
comma
r_sizeof
(paren
r_struct
id|sctp_getaddrs
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* 7.1.10 Set Primary Address (SCTP_PRIMARY_ADDR)&n; *&n; * Requests that the local SCTP stack use the enclosed peer address as&n; * the association primary.  The enclosed address must be one of the&n; * association peer&squot;s addresses.&n; */
DECL|function|sctp_getsockopt_primary_addr
r_static
r_int
id|sctp_getsockopt_primary_addr
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|len
comma
r_char
id|__user
op_star
id|optval
comma
r_int
id|__user
op_star
id|optlen
)paren
(brace
r_struct
id|sctp_prim
id|prim
suffix:semicolon
r_struct
id|sctp_association
op_star
id|asoc
suffix:semicolon
r_struct
id|sctp_opt
op_star
id|sp
op_assign
id|sctp_sk
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
op_ne
r_sizeof
(paren
r_struct
id|sctp_prim
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|prim
comma
id|optval
comma
r_sizeof
(paren
r_struct
id|sctp_prim
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|asoc
op_assign
id|sctp_id2assoc
c_func
(paren
id|sk
comma
id|prim.ssp_assoc_id
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|asoc
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|asoc-&gt;peer.primary_path
)paren
r_return
op_minus
id|ENOTCONN
suffix:semicolon
id|asoc-&gt;peer.primary_path-&gt;ipaddr.v4.sin_port
op_assign
id|htons
c_func
(paren
id|asoc-&gt;peer.primary_path-&gt;ipaddr.v4.sin_port
)paren
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|prim.ssp_addr
comma
op_amp
id|asoc-&gt;peer.primary_path-&gt;ipaddr
comma
r_sizeof
(paren
r_union
id|sctp_addr
)paren
)paren
suffix:semicolon
id|asoc-&gt;peer.primary_path-&gt;ipaddr.v4.sin_port
op_assign
id|ntohs
c_func
(paren
id|asoc-&gt;peer.primary_path-&gt;ipaddr.v4.sin_port
)paren
suffix:semicolon
id|sctp_get_pf_specific
c_func
(paren
id|sk-&gt;sk_family
)paren
op_member_access_from_pointer
id|addr_v4map
c_func
(paren
id|sp
comma
(paren
r_union
id|sctp_addr
op_star
)paren
op_amp
id|prim.ssp_addr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|optval
comma
op_amp
id|prim
comma
r_sizeof
(paren
r_struct
id|sctp_prim
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * 7.1.11  Set Adaption Layer Indicator (SCTP_ADAPTION_LAYER)&n; *&n; * Requests that the local endpoint set the specified Adaption Layer&n; * Indication parameter for all future INIT and INIT-ACK exchanges.&n; */
DECL|function|sctp_getsockopt_adaption_layer
r_static
r_int
id|sctp_getsockopt_adaption_layer
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|len
comma
r_char
id|__user
op_star
id|optval
comma
r_int
id|__user
op_star
id|optlen
)paren
(brace
id|__u32
id|val
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
r_sizeof
(paren
id|__u32
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|len
op_assign
r_sizeof
(paren
id|__u32
)paren
suffix:semicolon
id|val
op_assign
id|sctp_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|adaption_ind
suffix:semicolon
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|len
comma
id|optlen
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|optval
comma
op_amp
id|val
comma
id|len
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&n; * 7.1.14 Set default send parameters (SCTP_DEFAULT_SEND_PARAM)&n; *&n; *   Applications that wish to use the sendto() system call may wish to&n; *   specify a default set of parameters that would normally be supplied&n; *   through the inclusion of ancillary data.  This socket option allows&n; *   such an application to set the default sctp_sndrcvinfo structure.&n;&n;&n; *   The application that wishes to use this socket option simply passes&n; *   in to this call the sctp_sndrcvinfo structure defined in Section&n; *   5.2.2) The input parameters accepted by this call include&n; *   sinfo_stream, sinfo_flags, sinfo_ppid, sinfo_context,&n; *   sinfo_timetolive.  The user must provide the sinfo_assoc_id field in&n; *   to this call if the caller is using the UDP model.&n; *&n; *   For getsockopt, it get the default sctp_sndrcvinfo structure.&n; */
DECL|function|sctp_getsockopt_default_send_param
r_static
r_int
id|sctp_getsockopt_default_send_param
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|len
comma
r_char
id|__user
op_star
id|optval
comma
r_int
id|__user
op_star
id|optlen
)paren
(brace
r_struct
id|sctp_sndrcvinfo
id|info
suffix:semicolon
r_struct
id|sctp_association
op_star
id|asoc
suffix:semicolon
r_struct
id|sctp_opt
op_star
id|sp
op_assign
id|sctp_sk
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
op_ne
r_sizeof
(paren
r_struct
id|sctp_sndrcvinfo
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|info
comma
id|optval
comma
r_sizeof
(paren
r_struct
id|sctp_sndrcvinfo
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|asoc
op_assign
id|sctp_id2assoc
c_func
(paren
id|sk
comma
id|info.sinfo_assoc_id
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|asoc
op_logical_and
id|info.sinfo_assoc_id
op_logical_and
id|sctp_style
c_func
(paren
id|sk
comma
id|UDP
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|asoc
)paren
(brace
id|info.sinfo_stream
op_assign
id|asoc-&gt;default_stream
suffix:semicolon
id|info.sinfo_flags
op_assign
id|asoc-&gt;default_flags
suffix:semicolon
id|info.sinfo_ppid
op_assign
id|asoc-&gt;default_ppid
suffix:semicolon
id|info.sinfo_context
op_assign
id|asoc-&gt;default_context
suffix:semicolon
id|info.sinfo_timetolive
op_assign
id|asoc-&gt;default_timetolive
suffix:semicolon
)brace
r_else
(brace
id|info.sinfo_stream
op_assign
id|sp-&gt;default_stream
suffix:semicolon
id|info.sinfo_flags
op_assign
id|sp-&gt;default_flags
suffix:semicolon
id|info.sinfo_ppid
op_assign
id|sp-&gt;default_ppid
suffix:semicolon
id|info.sinfo_context
op_assign
id|sp-&gt;default_context
suffix:semicolon
id|info.sinfo_timetolive
op_assign
id|sp-&gt;default_timetolive
suffix:semicolon
)brace
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|optval
comma
op_amp
id|info
comma
r_sizeof
(paren
r_struct
id|sctp_sndrcvinfo
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&n; * 7.1.5 SCTP_NODELAY&n; *&n; * Turn on/off any Nagle-like algorithm.  This means that packets are&n; * generally sent as soon as possible and no unnecessary delays are&n; * introduced, at the cost of more packets in the network.  Expects an&n; * integer boolean flag.&n; */
DECL|function|sctp_getsockopt_nodelay
r_static
r_int
id|sctp_getsockopt_nodelay
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|len
comma
r_char
id|__user
op_star
id|optval
comma
r_int
id|__user
op_star
id|optlen
)paren
(brace
r_int
id|val
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
r_sizeof
(paren
r_int
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|len
op_assign
r_sizeof
(paren
r_int
)paren
suffix:semicolon
id|val
op_assign
(paren
id|sctp_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|nodelay
op_eq
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|len
comma
id|optlen
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|optval
comma
op_amp
id|val
comma
id|len
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&n; * 7.1.1 SCTP_RTOINFO&n; *&n; * The protocol parameters used to initialize and bound retransmission&n; * timeout (RTO) are tunable. sctp_rtoinfo structure is used to access&n; * and modify these parameters.&n; * All parameters are time values, in milliseconds.  A value of 0, when&n; * modifying the parameters, indicates that the current value should not&n; * be changed.&n; *&n; */
DECL|function|sctp_getsockopt_rtoinfo
r_static
r_int
id|sctp_getsockopt_rtoinfo
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|len
comma
r_char
id|__user
op_star
id|optval
comma
r_int
id|__user
op_star
id|optlen
)paren
(brace
r_struct
id|sctp_rtoinfo
id|rtoinfo
suffix:semicolon
r_struct
id|sctp_association
op_star
id|asoc
suffix:semicolon
r_if
c_cond
(paren
id|len
op_ne
r_sizeof
(paren
r_struct
id|sctp_rtoinfo
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|rtoinfo
comma
id|optval
comma
r_sizeof
(paren
r_struct
id|sctp_rtoinfo
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|asoc
op_assign
id|sctp_id2assoc
c_func
(paren
id|sk
comma
id|rtoinfo.srto_assoc_id
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|asoc
op_logical_and
id|rtoinfo.srto_assoc_id
op_logical_and
id|sctp_style
c_func
(paren
id|sk
comma
id|UDP
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* Values corresponding to the specific association. */
r_if
c_cond
(paren
id|asoc
)paren
(brace
id|rtoinfo.srto_initial
op_assign
id|jiffies_to_msecs
c_func
(paren
id|asoc-&gt;rto_initial
)paren
suffix:semicolon
id|rtoinfo.srto_max
op_assign
id|jiffies_to_msecs
c_func
(paren
id|asoc-&gt;rto_max
)paren
suffix:semicolon
id|rtoinfo.srto_min
op_assign
id|jiffies_to_msecs
c_func
(paren
id|asoc-&gt;rto_min
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Values corresponding to the endpoint. */
r_struct
id|sctp_opt
op_star
id|sp
op_assign
id|sctp_sk
c_func
(paren
id|sk
)paren
suffix:semicolon
id|rtoinfo.srto_initial
op_assign
id|sp-&gt;rtoinfo.srto_initial
suffix:semicolon
id|rtoinfo.srto_max
op_assign
id|sp-&gt;rtoinfo.srto_max
suffix:semicolon
id|rtoinfo.srto_min
op_assign
id|sp-&gt;rtoinfo.srto_min
suffix:semicolon
)brace
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|len
comma
id|optlen
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|optval
comma
op_amp
id|rtoinfo
comma
id|len
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&n; * 7.1.2 SCTP_ASSOCINFO&n; *&n; * This option is used to tune the the maximum retransmission attempts&n; * of the association.&n; * Returns an error if the new association retransmission value is&n; * greater than the sum of the retransmission value  of the peer.&n; * See [SCTP] for more information.&n; *&n; */
DECL|function|sctp_getsockopt_associnfo
r_static
r_int
id|sctp_getsockopt_associnfo
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|len
comma
r_char
id|__user
op_star
id|optval
comma
r_int
id|__user
op_star
id|optlen
)paren
(brace
r_struct
id|sctp_assocparams
id|assocparams
suffix:semicolon
r_struct
id|sctp_association
op_star
id|asoc
suffix:semicolon
r_struct
id|list_head
op_star
id|pos
suffix:semicolon
r_int
id|cnt
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|len
op_ne
r_sizeof
(paren
r_struct
id|sctp_assocparams
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|assocparams
comma
id|optval
comma
r_sizeof
(paren
r_struct
id|sctp_assocparams
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|asoc
op_assign
id|sctp_id2assoc
c_func
(paren
id|sk
comma
id|assocparams.sasoc_assoc_id
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|asoc
op_logical_and
id|assocparams.sasoc_assoc_id
op_logical_and
id|sctp_style
c_func
(paren
id|sk
comma
id|UDP
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* Values correspoinding to the specific association */
r_if
c_cond
(paren
id|assocparams.sasoc_assoc_id
op_ne
l_int|0
)paren
(brace
id|assocparams.sasoc_asocmaxrxt
op_assign
id|asoc-&gt;max_retrans
suffix:semicolon
id|assocparams.sasoc_peer_rwnd
op_assign
id|asoc-&gt;peer.rwnd
suffix:semicolon
id|assocparams.sasoc_local_rwnd
op_assign
id|asoc-&gt;a_rwnd
suffix:semicolon
id|assocparams.sasoc_cookie_life
op_assign
(paren
id|asoc-&gt;cookie_life.tv_sec
op_star
l_int|1000
)paren
op_plus
(paren
id|asoc-&gt;cookie_life.tv_usec
op_div
l_int|1000
)paren
suffix:semicolon
id|list_for_each
c_func
(paren
id|pos
comma
op_amp
id|asoc-&gt;peer.transport_addr_list
)paren
(brace
id|cnt
op_increment
suffix:semicolon
)brace
id|assocparams.sasoc_number_peer_destinations
op_assign
id|cnt
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Values corresponding to the endpoint */
r_struct
id|sctp_opt
op_star
id|sp
op_assign
id|sctp_sk
c_func
(paren
id|sk
)paren
suffix:semicolon
id|assocparams.sasoc_asocmaxrxt
op_assign
id|sp-&gt;assocparams.sasoc_asocmaxrxt
suffix:semicolon
id|assocparams.sasoc_peer_rwnd
op_assign
id|sp-&gt;assocparams.sasoc_peer_rwnd
suffix:semicolon
id|assocparams.sasoc_local_rwnd
op_assign
id|sp-&gt;assocparams.sasoc_local_rwnd
suffix:semicolon
id|assocparams.sasoc_cookie_life
op_assign
id|sp-&gt;assocparams.sasoc_cookie_life
suffix:semicolon
id|assocparams.sasoc_number_peer_destinations
op_assign
id|sp-&gt;assocparams
dot
id|sasoc_number_peer_destinations
suffix:semicolon
)brace
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|len
comma
id|optlen
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|optval
comma
op_amp
id|assocparams
comma
id|len
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * 7.1.16 Set/clear IPv4 mapped addresses (SCTP_I_WANT_MAPPED_V4_ADDR)&n; *&n; * This socket option is a boolean flag which turns on or off mapped V4&n; * addresses.  If this option is turned on and the socket is type&n; * PF_INET6, then IPv4 addresses will be mapped to V6 representation.&n; * If this option is turned off, then no mapping will be done of V4&n; * addresses and a user will receive both PF_INET6 and PF_INET type&n; * addresses on the socket.&n; */
DECL|function|sctp_getsockopt_mappedv4
r_static
r_int
id|sctp_getsockopt_mappedv4
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|len
comma
r_char
id|__user
op_star
id|optval
comma
r_int
id|__user
op_star
id|optlen
)paren
(brace
r_int
id|val
suffix:semicolon
r_struct
id|sctp_opt
op_star
id|sp
op_assign
id|sctp_sk
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
r_sizeof
(paren
r_int
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|len
op_assign
r_sizeof
(paren
r_int
)paren
suffix:semicolon
id|val
op_assign
id|sp-&gt;v4mapped
suffix:semicolon
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|len
comma
id|optlen
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|optval
comma
op_amp
id|val
comma
id|len
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * 7.1.17 Set the maximum fragrmentation size (SCTP_MAXSEG)&n; *&n; * This socket option specifies the maximum size to put in any outgoing&n; * SCTP chunk.  If a message is larger than this size it will be&n; * fragmented by SCTP into the specified size.  Note that the underlying&n; * SCTP implementation may fragment into smaller sized chunks when the&n; * PMTU of the underlying association is smaller than the value set by&n; * the user.&n; */
DECL|function|sctp_getsockopt_maxseg
r_static
r_int
id|sctp_getsockopt_maxseg
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|len
comma
r_char
id|__user
op_star
id|optval
comma
r_int
id|__user
op_star
id|optlen
)paren
(brace
r_int
id|val
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
r_sizeof
(paren
r_int
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|len
op_assign
r_sizeof
(paren
r_int
)paren
suffix:semicolon
id|val
op_assign
id|sctp_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|user_frag
suffix:semicolon
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|len
comma
id|optlen
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|optval
comma
op_amp
id|val
comma
id|len
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|sctp_getsockopt
id|SCTP_STATIC
r_int
id|sctp_getsockopt
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|level
comma
r_int
id|optname
comma
r_char
id|__user
op_star
id|optval
comma
r_int
id|__user
op_star
id|optlen
)paren
(brace
r_int
id|retval
op_assign
l_int|0
suffix:semicolon
r_int
id|len
suffix:semicolon
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;sctp_getsockopt(sk: %p, ...)&bslash;n&quot;
comma
id|sk
)paren
suffix:semicolon
multiline_comment|/* I can hardly begin to describe how wrong this is.  This is&n;&t; * so broken as to be worse than useless.  The API draft&n;&t; * REALLY is NOT helpful here...  I am not convinced that the&n;&t; * semantics of getsockopt() with a level OTHER THAN SOL_SCTP&n;&t; * are at all well-founded.&n;&t; */
r_if
c_cond
(paren
id|level
op_ne
id|SOL_SCTP
)paren
(brace
r_struct
id|sctp_af
op_star
id|af
op_assign
id|sctp_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|pf-&gt;af
suffix:semicolon
id|retval
op_assign
id|af
op_member_access_from_pointer
id|getsockopt
c_func
(paren
id|sk
comma
id|level
comma
id|optname
comma
id|optval
comma
id|optlen
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|len
comma
id|optlen
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|sctp_lock_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|optname
)paren
(brace
r_case
id|SCTP_STATUS
suffix:colon
id|retval
op_assign
id|sctp_getsockopt_sctp_status
c_func
(paren
id|sk
comma
id|len
comma
id|optval
comma
id|optlen
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_DISABLE_FRAGMENTS
suffix:colon
id|retval
op_assign
id|sctp_getsockopt_disable_fragments
c_func
(paren
id|sk
comma
id|len
comma
id|optval
comma
id|optlen
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_EVENTS
suffix:colon
id|retval
op_assign
id|sctp_getsockopt_events
c_func
(paren
id|sk
comma
id|len
comma
id|optval
comma
id|optlen
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_AUTOCLOSE
suffix:colon
id|retval
op_assign
id|sctp_getsockopt_autoclose
c_func
(paren
id|sk
comma
id|len
comma
id|optval
comma
id|optlen
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_SOCKOPT_PEELOFF
suffix:colon
id|retval
op_assign
id|sctp_getsockopt_peeloff
c_func
(paren
id|sk
comma
id|len
comma
id|optval
comma
id|optlen
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_PEER_ADDR_PARAMS
suffix:colon
id|retval
op_assign
id|sctp_getsockopt_peer_addr_params
c_func
(paren
id|sk
comma
id|len
comma
id|optval
comma
id|optlen
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_INITMSG
suffix:colon
id|retval
op_assign
id|sctp_getsockopt_initmsg
c_func
(paren
id|sk
comma
id|len
comma
id|optval
comma
id|optlen
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_GET_PEER_ADDRS_NUM
suffix:colon
id|retval
op_assign
id|sctp_getsockopt_peer_addrs_num
c_func
(paren
id|sk
comma
id|len
comma
id|optval
comma
id|optlen
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_GET_LOCAL_ADDRS_NUM
suffix:colon
id|retval
op_assign
id|sctp_getsockopt_local_addrs_num
c_func
(paren
id|sk
comma
id|len
comma
id|optval
comma
id|optlen
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_GET_PEER_ADDRS
suffix:colon
id|retval
op_assign
id|sctp_getsockopt_peer_addrs
c_func
(paren
id|sk
comma
id|len
comma
id|optval
comma
id|optlen
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_GET_LOCAL_ADDRS
suffix:colon
id|retval
op_assign
id|sctp_getsockopt_local_addrs
c_func
(paren
id|sk
comma
id|len
comma
id|optval
comma
id|optlen
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_DEFAULT_SEND_PARAM
suffix:colon
id|retval
op_assign
id|sctp_getsockopt_default_send_param
c_func
(paren
id|sk
comma
id|len
comma
id|optval
comma
id|optlen
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_PRIMARY_ADDR
suffix:colon
id|retval
op_assign
id|sctp_getsockopt_primary_addr
c_func
(paren
id|sk
comma
id|len
comma
id|optval
comma
id|optlen
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_NODELAY
suffix:colon
id|retval
op_assign
id|sctp_getsockopt_nodelay
c_func
(paren
id|sk
comma
id|len
comma
id|optval
comma
id|optlen
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_RTOINFO
suffix:colon
id|retval
op_assign
id|sctp_getsockopt_rtoinfo
c_func
(paren
id|sk
comma
id|len
comma
id|optval
comma
id|optlen
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_ASSOCINFO
suffix:colon
id|retval
op_assign
id|sctp_getsockopt_associnfo
c_func
(paren
id|sk
comma
id|len
comma
id|optval
comma
id|optlen
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_I_WANT_MAPPED_V4_ADDR
suffix:colon
id|retval
op_assign
id|sctp_getsockopt_mappedv4
c_func
(paren
id|sk
comma
id|len
comma
id|optval
comma
id|optlen
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_MAXSEG
suffix:colon
id|retval
op_assign
id|sctp_getsockopt_maxseg
c_func
(paren
id|sk
comma
id|len
comma
id|optval
comma
id|optlen
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_GET_PEER_ADDR_INFO
suffix:colon
id|retval
op_assign
id|sctp_getsockopt_peer_addr_info
c_func
(paren
id|sk
comma
id|len
comma
id|optval
comma
id|optlen
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_ADAPTION_LAYER
suffix:colon
id|retval
op_assign
id|sctp_getsockopt_adaption_layer
c_func
(paren
id|sk
comma
id|len
comma
id|optval
comma
id|optlen
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|retval
op_assign
op_minus
id|ENOPROTOOPT
suffix:semicolon
r_break
suffix:semicolon
)brace
suffix:semicolon
id|sctp_release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
DECL|function|sctp_hash
r_static
r_void
id|sctp_hash
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
multiline_comment|/* STUB */
)brace
DECL|function|sctp_unhash
r_static
r_void
id|sctp_unhash
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
multiline_comment|/* STUB */
)brace
multiline_comment|/* Check if port is acceptable.  Possibly find first available port.&n; *&n; * The port hash table (contained in the &squot;global&squot; SCTP protocol storage&n; * returned by struct sctp_protocol *sctp_get_protocol()). The hash&n; * table is an array of 4096 lists (sctp_bind_hashbucket). Each&n; * list (the list number is the port number hashed out, so as you&n; * would expect from a hash function, all the ports in a given list have&n; * such a number that hashes out to the same list number; you were&n; * expecting that, right?); so each list has a set of ports, with a&n; * link to the socket (struct sock) that uses it, the port number and&n; * a fastreuse flag (FIXME: NPI ipg).&n; */
r_static
r_struct
id|sctp_bind_bucket
op_star
id|sctp_bucket_create
c_func
(paren
r_struct
id|sctp_bind_hashbucket
op_star
id|head
comma
r_int
r_int
id|snum
)paren
suffix:semicolon
DECL|function|sctp_get_port_local
r_static
r_int
id|sctp_get_port_local
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_union
id|sctp_addr
op_star
id|addr
)paren
(brace
r_struct
id|sctp_bind_hashbucket
op_star
id|head
suffix:semicolon
multiline_comment|/* hash list */
r_struct
id|sctp_bind_bucket
op_star
id|pp
suffix:semicolon
multiline_comment|/* hash list port iterator */
r_int
r_int
id|snum
suffix:semicolon
r_int
id|ret
suffix:semicolon
multiline_comment|/* NOTE:  Remember to put this back to net order. */
id|addr-&gt;v4.sin_port
op_assign
id|ntohs
c_func
(paren
id|addr-&gt;v4.sin_port
)paren
suffix:semicolon
id|snum
op_assign
id|addr-&gt;v4.sin_port
suffix:semicolon
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;sctp_get_port() begins, snum=%d&bslash;n&quot;
comma
id|snum
)paren
suffix:semicolon
id|sctp_local_bh_disable
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|snum
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Search for an available port.&n;&t;&t; *&n;&t;&t; * &squot;sctp_port_rover&squot; was the last port assigned, so&n;&t;&t; * we start to search from &squot;sctp_port_rover +&n;&t;&t; * 1&squot;. What we do is first check if port &squot;rover&squot; is&n;&t;&t; * already in the hash table; if not, we use that; if&n;&t;&t; * it is, we try next.&n;&t;&t; */
r_int
id|low
op_assign
id|sysctl_local_port_range
(braket
l_int|0
)braket
suffix:semicolon
r_int
id|high
op_assign
id|sysctl_local_port_range
(braket
l_int|1
)braket
suffix:semicolon
r_int
id|remaining
op_assign
(paren
id|high
op_minus
id|low
)paren
op_plus
l_int|1
suffix:semicolon
r_int
id|rover
suffix:semicolon
r_int
id|index
suffix:semicolon
id|sctp_spin_lock
c_func
(paren
op_amp
id|sctp_port_alloc_lock
)paren
suffix:semicolon
id|rover
op_assign
id|sctp_port_rover
suffix:semicolon
r_do
(brace
id|rover
op_increment
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rover
OL
id|low
)paren
op_logical_or
(paren
id|rover
OG
id|high
)paren
)paren
id|rover
op_assign
id|low
suffix:semicolon
id|index
op_assign
id|sctp_phashfn
c_func
(paren
id|rover
)paren
suffix:semicolon
id|head
op_assign
op_amp
id|sctp_port_hashtable
(braket
id|index
)braket
suffix:semicolon
id|sctp_spin_lock
c_func
(paren
op_amp
id|head-&gt;lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|pp
op_assign
id|head-&gt;chain
suffix:semicolon
id|pp
suffix:semicolon
id|pp
op_assign
id|pp-&gt;next
)paren
r_if
c_cond
(paren
id|pp-&gt;port
op_eq
id|rover
)paren
r_goto
id|next
suffix:semicolon
r_break
suffix:semicolon
id|next
suffix:colon
id|sctp_spin_unlock
c_func
(paren
op_amp
id|head-&gt;lock
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
op_decrement
id|remaining
OG
l_int|0
)paren
suffix:semicolon
id|sctp_port_rover
op_assign
id|rover
suffix:semicolon
id|sctp_spin_unlock
c_func
(paren
op_amp
id|sctp_port_alloc_lock
)paren
suffix:semicolon
multiline_comment|/* Exhausted local port range during search? */
id|ret
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|remaining
op_le
l_int|0
)paren
r_goto
id|fail
suffix:semicolon
multiline_comment|/* OK, here is the one we will use.  HEAD (the port&n;&t;&t; * hash table list entry) is non-NULL and we hold it&squot;s&n;&t;&t; * mutex.&n;&t;&t; */
id|snum
op_assign
id|rover
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* We are given an specific port number; we verify&n;&t;&t; * that it is not being used. If it is used, we will&n;&t;&t; * exahust the search in the hash list corresponding&n;&t;&t; * to the port number (snum) - we detect that with the&n;&t;&t; * port iterator, pp being NULL.&n;&t;&t; */
id|head
op_assign
op_amp
id|sctp_port_hashtable
(braket
id|sctp_phashfn
c_func
(paren
id|snum
)paren
)braket
suffix:semicolon
id|sctp_spin_lock
c_func
(paren
op_amp
id|head-&gt;lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|pp
op_assign
id|head-&gt;chain
suffix:semicolon
id|pp
suffix:semicolon
id|pp
op_assign
id|pp-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|pp-&gt;port
op_eq
id|snum
)paren
r_goto
id|pp_found
suffix:semicolon
)brace
)brace
id|pp
op_assign
l_int|NULL
suffix:semicolon
r_goto
id|pp_not_found
suffix:semicolon
id|pp_found
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|hlist_empty
c_func
(paren
op_amp
id|pp-&gt;owner
)paren
)paren
(brace
multiline_comment|/* We had a port hash table hit - there is an&n;&t;&t; * available port (pp != NULL) and it is being&n;&t;&t; * used by other socket (pp-&gt;owner not empty); that other&n;&t;&t; * socket is going to be sk2.&n;&t;&t; */
r_int
id|reuse
op_assign
id|sk-&gt;sk_reuse
suffix:semicolon
r_struct
id|sock
op_star
id|sk2
suffix:semicolon
r_struct
id|hlist_node
op_star
id|node
suffix:semicolon
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;sctp_get_port() found a possible match&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pp-&gt;fastreuse
op_logical_and
id|sk-&gt;sk_reuse
)paren
r_goto
id|success
suffix:semicolon
multiline_comment|/* Run through the list of sockets bound to the port&n;&t;&t; * (pp-&gt;port) [via the pointers bind_next and&n;&t;&t; * bind_pprev in the struct sock *sk2 (pp-&gt;sk)]. On each one,&n;&t;&t; * we get the endpoint they describe and run through&n;&t;&t; * the endpoint&squot;s list of IP (v4 or v6) addresses,&n;&t;&t; * comparing each of the addresses with the address of&n;&t;&t; * the socket sk. If we find a match, then that means&n;&t;&t; * that this port/socket (sk) combination are already&n;&t;&t; * in an endpoint.&n;&t;&t; */
id|sk_for_each_bound
c_func
(paren
id|sk2
comma
id|node
comma
op_amp
id|pp-&gt;owner
)paren
(brace
r_struct
id|sctp_endpoint
op_star
id|ep2
suffix:semicolon
id|ep2
op_assign
id|sctp_sk
c_func
(paren
id|sk2
)paren
op_member_access_from_pointer
id|ep
suffix:semicolon
r_if
c_cond
(paren
id|reuse
op_logical_and
id|sk2-&gt;sk_reuse
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|sctp_bind_addr_match
c_func
(paren
op_amp
id|ep2-&gt;base.bind_addr
comma
id|addr
comma
id|sctp_sk
c_func
(paren
id|sk
)paren
)paren
)paren
(brace
id|ret
op_assign
(paren
r_int
)paren
id|sk2
suffix:semicolon
r_goto
id|fail_unlock
suffix:semicolon
)brace
)brace
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;sctp_get_port(): Found a match&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|pp_not_found
suffix:colon
multiline_comment|/* If there was a hash table miss, create a new port.  */
id|ret
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pp
op_logical_and
op_logical_neg
(paren
id|pp
op_assign
id|sctp_bucket_create
c_func
(paren
id|head
comma
id|snum
)paren
)paren
)paren
r_goto
id|fail_unlock
suffix:semicolon
multiline_comment|/* In either case (hit or miss), make sure fastreuse is 1 only&n;&t; * if sk-&gt;sk_reuse is too (that is, if the caller requested&n;&t; * SO_REUSEADDR on this socket -sk-).&n;&t; */
r_if
c_cond
(paren
id|hlist_empty
c_func
(paren
op_amp
id|pp-&gt;owner
)paren
)paren
id|pp-&gt;fastreuse
op_assign
id|sk-&gt;sk_reuse
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
r_else
r_if
c_cond
(paren
id|pp-&gt;fastreuse
op_logical_and
op_logical_neg
id|sk-&gt;sk_reuse
)paren
id|pp-&gt;fastreuse
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* We are set, so fill up all the data in the hash table&n;&t; * entry, tie the socket list information with the rest of the&n;&t; * sockets FIXME: Blurry, NPI (ipg).&n;&t; */
id|success
suffix:colon
id|inet_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|num
op_assign
id|snum
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sctp_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|bind_hash
)paren
(brace
id|sk_add_bind_node
c_func
(paren
id|sk
comma
op_amp
id|pp-&gt;owner
)paren
suffix:semicolon
id|sctp_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|bind_hash
op_assign
id|pp
suffix:semicolon
)brace
id|ret
op_assign
l_int|0
suffix:semicolon
id|fail_unlock
suffix:colon
id|sctp_spin_unlock
c_func
(paren
op_amp
id|head-&gt;lock
)paren
suffix:semicolon
id|fail
suffix:colon
id|sctp_local_bh_enable
c_func
(paren
)paren
suffix:semicolon
id|addr-&gt;v4.sin_port
op_assign
id|htons
c_func
(paren
id|addr-&gt;v4.sin_port
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* Assign a &squot;snum&squot; port to the socket.  If snum == 0, an ephemeral&n; * port is requested.&n; */
DECL|function|sctp_get_port
r_static
r_int
id|sctp_get_port
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
r_int
id|snum
)paren
(brace
r_int
id|ret
suffix:semicolon
r_union
id|sctp_addr
id|addr
suffix:semicolon
r_struct
id|sctp_af
op_star
id|af
op_assign
id|sctp_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|pf-&gt;af
suffix:semicolon
multiline_comment|/* Set up a dummy address struct from the sk. */
id|af
op_member_access_from_pointer
id|from_sk
c_func
(paren
op_amp
id|addr
comma
id|sk
)paren
suffix:semicolon
id|addr.v4.sin_port
op_assign
id|htons
c_func
(paren
id|snum
)paren
suffix:semicolon
multiline_comment|/* Note: sk-&gt;sk_num gets filled in if ephemeral port request. */
id|ret
op_assign
id|sctp_get_port_local
c_func
(paren
id|sk
comma
op_amp
id|addr
)paren
suffix:semicolon
r_return
(paren
id|ret
ques
c_cond
l_int|1
suffix:colon
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * 3.1.3 listen() - UDP Style Syntax&n; *&n; *   By default, new associations are not accepted for UDP style sockets.&n; *   An application uses listen() to mark a socket as being able to&n; *   accept new associations.&n; */
DECL|function|sctp_seqpacket_listen
id|SCTP_STATIC
r_int
id|sctp_seqpacket_listen
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|backlog
)paren
(brace
r_struct
id|sctp_opt
op_star
id|sp
op_assign
id|sctp_sk
c_func
(paren
id|sk
)paren
suffix:semicolon
r_struct
id|sctp_endpoint
op_star
id|ep
op_assign
id|sp-&gt;ep
suffix:semicolon
multiline_comment|/* Only UDP style sockets that are not peeled off are allowed to&n;&t; * listen().&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|sctp_style
c_func
(paren
id|sk
comma
id|UDP
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* If backlog is zero, disable listening. */
r_if
c_cond
(paren
op_logical_neg
id|backlog
)paren
(brace
r_if
c_cond
(paren
id|sctp_sstate
c_func
(paren
id|sk
comma
id|CLOSED
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|sctp_unhash_endpoint
c_func
(paren
id|ep
)paren
suffix:semicolon
id|sk-&gt;sk_state
op_assign
id|SCTP_SS_CLOSED
suffix:semicolon
)brace
multiline_comment|/* Return if we are already listening. */
r_if
c_cond
(paren
id|sctp_sstate
c_func
(paren
id|sk
comma
id|LISTENING
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * If a bind() or sctp_bindx() is not called prior to a listen()&n;&t; * call that allows new associations to be accepted, the system&n;&t; * picks an ephemeral port and will choose an address set equivalent&n;&t; * to binding with a wildcard address.&n;&t; *&n;&t; * This is not currently spelled out in the SCTP sockets&n;&t; * extensions draft, but follows the practice as seen in TCP&n;&t; * sockets.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|ep-&gt;base.bind_addr.port
)paren
(brace
r_if
c_cond
(paren
id|sctp_autobind
c_func
(paren
id|sk
)paren
)paren
r_return
op_minus
id|EAGAIN
suffix:semicolon
)brace
id|sk-&gt;sk_state
op_assign
id|SCTP_SS_LISTENING
suffix:semicolon
id|sctp_hash_endpoint
c_func
(paren
id|ep
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * 4.1.3 listen() - TCP Style Syntax&n; *&n; *   Applications uses listen() to ready the SCTP endpoint for accepting&n; *   inbound associations.&n; */
DECL|function|sctp_stream_listen
id|SCTP_STATIC
r_int
id|sctp_stream_listen
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|backlog
)paren
(brace
r_struct
id|sctp_opt
op_star
id|sp
op_assign
id|sctp_sk
c_func
(paren
id|sk
)paren
suffix:semicolon
r_struct
id|sctp_endpoint
op_star
id|ep
op_assign
id|sp-&gt;ep
suffix:semicolon
multiline_comment|/* If backlog is zero, disable listening. */
r_if
c_cond
(paren
op_logical_neg
id|backlog
)paren
(brace
r_if
c_cond
(paren
id|sctp_sstate
c_func
(paren
id|sk
comma
id|CLOSED
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|sctp_unhash_endpoint
c_func
(paren
id|ep
)paren
suffix:semicolon
id|sk-&gt;sk_state
op_assign
id|SCTP_SS_CLOSED
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sctp_sstate
c_func
(paren
id|sk
comma
id|LISTENING
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * If a bind() or sctp_bindx() is not called prior to a listen()&n;&t; * call that allows new associations to be accepted, the system&n;&t; * picks an ephemeral port and will choose an address set equivalent&n;&t; * to binding with a wildcard address.&n;&t; *&n;&t; * This is not currently spelled out in the SCTP sockets&n;&t; * extensions draft, but follows the practice as seen in TCP&n;&t; * sockets.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|ep-&gt;base.bind_addr.port
)paren
(brace
r_if
c_cond
(paren
id|sctp_autobind
c_func
(paren
id|sk
)paren
)paren
r_return
op_minus
id|EAGAIN
suffix:semicolon
)brace
id|sk-&gt;sk_state
op_assign
id|SCTP_SS_LISTENING
suffix:semicolon
id|sk-&gt;sk_max_ack_backlog
op_assign
id|backlog
suffix:semicolon
id|sctp_hash_endpoint
c_func
(paren
id|ep
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *  Move a socket to LISTENING state.&n; */
DECL|function|sctp_inet_listen
r_int
id|sctp_inet_listen
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_int
id|backlog
)paren
(brace
r_struct
id|sock
op_star
id|sk
op_assign
id|sock-&gt;sk
suffix:semicolon
r_struct
id|crypto_tfm
op_star
id|tfm
op_assign
l_int|NULL
suffix:semicolon
r_int
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|backlog
OL
l_int|0
)paren
)paren
r_goto
id|out
suffix:semicolon
id|sctp_lock_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sock-&gt;state
op_ne
id|SS_UNCONNECTED
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* Allocate HMAC for generating cookie. */
r_if
c_cond
(paren
id|sctp_hmac_alg
)paren
(brace
id|tfm
op_assign
id|sctp_crypto_alloc_tfm
c_func
(paren
id|sctp_hmac_alg
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tfm
)paren
(brace
id|err
op_assign
op_minus
id|ENOSYS
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
)brace
r_switch
c_cond
(paren
id|sock-&gt;type
)paren
(brace
r_case
id|SOCK_SEQPACKET
suffix:colon
id|err
op_assign
id|sctp_seqpacket_listen
c_func
(paren
id|sk
comma
id|backlog
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOCK_STREAM
suffix:colon
id|err
op_assign
id|sctp_stream_listen
c_func
(paren
id|sk
comma
id|backlog
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|cleanup
suffix:semicolon
multiline_comment|/* Store away the transform reference. */
id|sctp_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|hmac
op_assign
id|tfm
suffix:semicolon
id|out
suffix:colon
id|sctp_release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
id|cleanup
suffix:colon
r_if
c_cond
(paren
id|tfm
)paren
id|sctp_crypto_free_tfm
c_func
(paren
id|tfm
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n; * This function is done by modeling the current datagram_poll() and the&n; * tcp_poll().  Note that, based on these implementations, we don&squot;t&n; * lock the socket in this function, even though it seems that,&n; * ideally, locking or some other mechanisms can be used to ensure&n; * the integrity of the counters (sndbuf and wmem_queued) used&n; * in this place.  We assume that we don&squot;t need locks either until proven&n; * otherwise.&n; *&n; * Another thing to note is that we include the Async I/O support&n; * here, again, by modeling the current TCP/UDP code.  We don&squot;t have&n; * a good way to test with it yet.&n; */
DECL|function|sctp_poll
r_int
r_int
id|sctp_poll
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_struct
id|socket
op_star
id|sock
comma
id|poll_table
op_star
id|wait
)paren
(brace
r_struct
id|sock
op_star
id|sk
op_assign
id|sock-&gt;sk
suffix:semicolon
r_struct
id|sctp_opt
op_star
id|sp
op_assign
id|sctp_sk
c_func
(paren
id|sk
)paren
suffix:semicolon
r_int
r_int
id|mask
suffix:semicolon
id|poll_wait
c_func
(paren
id|file
comma
id|sk-&gt;sk_sleep
comma
id|wait
)paren
suffix:semicolon
multiline_comment|/* A TCP-style listening socket becomes readable when the accept queue&n;&t; * is not empty.&n;&t; */
r_if
c_cond
(paren
id|sctp_style
c_func
(paren
id|sk
comma
id|TCP
)paren
op_logical_and
id|sctp_sstate
c_func
(paren
id|sk
comma
id|LISTENING
)paren
)paren
r_return
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|sp-&gt;ep-&gt;asocs
)paren
)paren
ques
c_cond
(paren
id|POLLIN
op_or
id|POLLRDNORM
)paren
suffix:colon
l_int|0
suffix:semicolon
id|mask
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Is there any exceptional events?  */
r_if
c_cond
(paren
id|sk-&gt;sk_err
op_logical_or
op_logical_neg
id|skb_queue_empty
c_func
(paren
op_amp
id|sk-&gt;sk_error_queue
)paren
)paren
id|mask
op_or_assign
id|POLLERR
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;sk_shutdown
op_eq
id|SHUTDOWN_MASK
)paren
id|mask
op_or_assign
id|POLLHUP
suffix:semicolon
multiline_comment|/* Is it readable?  Reconsider this code with TCP-style support.  */
r_if
c_cond
(paren
op_logical_neg
id|skb_queue_empty
c_func
(paren
op_amp
id|sk-&gt;sk_receive_queue
)paren
op_logical_or
(paren
id|sk-&gt;sk_shutdown
op_amp
id|RCV_SHUTDOWN
)paren
)paren
id|mask
op_or_assign
id|POLLIN
op_or
id|POLLRDNORM
suffix:semicolon
multiline_comment|/* The association is either gone or not ready.  */
r_if
c_cond
(paren
op_logical_neg
id|sctp_style
c_func
(paren
id|sk
comma
id|UDP
)paren
op_logical_and
id|sctp_sstate
c_func
(paren
id|sk
comma
id|CLOSED
)paren
)paren
r_return
id|mask
suffix:semicolon
multiline_comment|/* Is it writable?  */
r_if
c_cond
(paren
id|sctp_writeable
c_func
(paren
id|sk
)paren
)paren
(brace
id|mask
op_or_assign
id|POLLOUT
op_or
id|POLLWRNORM
suffix:semicolon
)brace
r_else
(brace
id|set_bit
c_func
(paren
id|SOCK_ASYNC_NOSPACE
comma
op_amp
id|sk-&gt;sk_socket-&gt;flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Since the socket is not locked, the buffer&n;&t;&t; * might be made available after the writeable check and&n;&t;&t; * before the bit is set.  This could cause a lost I/O&n;&t;&t; * signal.  tcp_poll() has a race breaker for this race&n;&t;&t; * condition.  Based on their implementation, we put&n;&t;&t; * in the following code to cover it as well.&n;&t;&t; */
r_if
c_cond
(paren
id|sctp_writeable
c_func
(paren
id|sk
)paren
)paren
id|mask
op_or_assign
id|POLLOUT
op_or
id|POLLWRNORM
suffix:semicolon
)brace
r_return
id|mask
suffix:semicolon
)brace
multiline_comment|/********************************************************************&n; * 2nd Level Abstractions&n; ********************************************************************/
DECL|function|sctp_bucket_create
r_static
r_struct
id|sctp_bind_bucket
op_star
id|sctp_bucket_create
c_func
(paren
r_struct
id|sctp_bind_hashbucket
op_star
id|head
comma
r_int
r_int
id|snum
)paren
(brace
r_struct
id|sctp_bind_bucket
op_star
id|pp
suffix:semicolon
id|pp
op_assign
id|kmem_cache_alloc
c_func
(paren
id|sctp_bucket_cachep
comma
id|SLAB_ATOMIC
)paren
suffix:semicolon
id|SCTP_DBG_OBJCNT_INC
c_func
(paren
id|bind_bucket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pp
)paren
(brace
id|pp-&gt;port
op_assign
id|snum
suffix:semicolon
id|pp-&gt;fastreuse
op_assign
l_int|0
suffix:semicolon
id|INIT_HLIST_HEAD
c_func
(paren
op_amp
id|pp-&gt;owner
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|pp-&gt;next
op_assign
id|head-&gt;chain
)paren
op_ne
l_int|NULL
)paren
id|pp-&gt;next-&gt;pprev
op_assign
op_amp
id|pp-&gt;next
suffix:semicolon
id|head-&gt;chain
op_assign
id|pp
suffix:semicolon
id|pp-&gt;pprev
op_assign
op_amp
id|head-&gt;chain
suffix:semicolon
)brace
r_return
id|pp
suffix:semicolon
)brace
multiline_comment|/* Caller must hold hashbucket lock for this tb with local BH disabled */
DECL|function|sctp_bucket_destroy
r_static
r_void
id|sctp_bucket_destroy
c_func
(paren
r_struct
id|sctp_bind_bucket
op_star
id|pp
)paren
(brace
r_if
c_cond
(paren
id|hlist_empty
c_func
(paren
op_amp
id|pp-&gt;owner
)paren
)paren
(brace
r_if
c_cond
(paren
id|pp-&gt;next
)paren
id|pp-&gt;next-&gt;pprev
op_assign
id|pp-&gt;pprev
suffix:semicolon
op_star
(paren
id|pp-&gt;pprev
)paren
op_assign
id|pp-&gt;next
suffix:semicolon
id|kmem_cache_free
c_func
(paren
id|sctp_bucket_cachep
comma
id|pp
)paren
suffix:semicolon
id|SCTP_DBG_OBJCNT_DEC
c_func
(paren
id|bind_bucket
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Release this socket&squot;s reference to a local port.  */
DECL|function|__sctp_put_port
r_static
r_inline
r_void
id|__sctp_put_port
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|sctp_bind_hashbucket
op_star
id|head
op_assign
op_amp
id|sctp_port_hashtable
(braket
id|sctp_phashfn
c_func
(paren
id|inet_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|num
)paren
)braket
suffix:semicolon
r_struct
id|sctp_bind_bucket
op_star
id|pp
suffix:semicolon
id|sctp_spin_lock
c_func
(paren
op_amp
id|head-&gt;lock
)paren
suffix:semicolon
id|pp
op_assign
id|sctp_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|bind_hash
suffix:semicolon
id|__sk_del_bind_node
c_func
(paren
id|sk
)paren
suffix:semicolon
id|sctp_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|bind_hash
op_assign
l_int|NULL
suffix:semicolon
id|inet_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|num
op_assign
l_int|0
suffix:semicolon
id|sctp_bucket_destroy
c_func
(paren
id|pp
)paren
suffix:semicolon
id|sctp_spin_unlock
c_func
(paren
op_amp
id|head-&gt;lock
)paren
suffix:semicolon
)brace
DECL|function|sctp_put_port
r_void
id|sctp_put_port
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
id|sctp_local_bh_disable
c_func
(paren
)paren
suffix:semicolon
id|__sctp_put_port
c_func
(paren
id|sk
)paren
suffix:semicolon
id|sctp_local_bh_enable
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * The system picks an ephemeral port and choose an address set equivalent&n; * to binding with a wildcard address.&n; * One of those addresses will be the primary address for the association.&n; * This automatically enables the multihoming capability of SCTP.&n; */
DECL|function|sctp_autobind
r_static
r_int
id|sctp_autobind
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_union
id|sctp_addr
id|autoaddr
suffix:semicolon
r_struct
id|sctp_af
op_star
id|af
suffix:semicolon
r_int
r_int
id|port
suffix:semicolon
multiline_comment|/* Initialize a local sockaddr structure to INADDR_ANY. */
id|af
op_assign
id|sctp_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|pf-&gt;af
suffix:semicolon
id|port
op_assign
id|htons
c_func
(paren
id|inet_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|num
)paren
suffix:semicolon
id|af
op_member_access_from_pointer
id|inaddr_any
c_func
(paren
op_amp
id|autoaddr
comma
id|port
)paren
suffix:semicolon
r_return
id|sctp_do_bind
c_func
(paren
id|sk
comma
op_amp
id|autoaddr
comma
id|af-&gt;sockaddr_len
)paren
suffix:semicolon
)brace
multiline_comment|/* Parse out IPPROTO_SCTP CMSG headers.  Perform only minimal validation.&n; *&n; * From RFC 2292&n; * 4.2 The cmsghdr Structure *&n; *&n; * When ancillary data is sent or received, any number of ancillary data&n; * objects can be specified by the msg_control and msg_controllen members of&n; * the msghdr structure, because each object is preceded by&n; * a cmsghdr structure defining the object&squot;s length (the cmsg_len member).&n; * Historically Berkeley-derived implementations have passed only one object&n; * at a time, but this API allows multiple objects to be&n; * passed in a single call to sendmsg() or recvmsg(). The following example&n; * shows two ancillary data objects in a control buffer.&n; *&n; *   |&lt;--------------------------- msg_controllen --------------------------&gt;|&n; *   |                                                                       |&n; *&n; *   |&lt;----- ancillary data object -----&gt;|&lt;----- ancillary data object -----&gt;|&n; *&n; *   |&lt;---------- CMSG_SPACE() ---------&gt;|&lt;---------- CMSG_SPACE() ---------&gt;|&n; *   |                                   |                                   |&n; *&n; *   |&lt;---------- cmsg_len ----------&gt;|  |&lt;--------- cmsg_len -----------&gt;|  |&n; *&n; *   |&lt;--------- CMSG_LEN() ---------&gt;|  |&lt;-------- CMSG_LEN() ----------&gt;|  |&n; *   |                                |  |                                |  |&n; *&n; *   +-----+-----+-----+--+-----------+--+-----+-----+-----+--+-----------+--+&n; *   |cmsg_|cmsg_|cmsg_|XX|           |XX|cmsg_|cmsg_|cmsg_|XX|           |XX|&n; *&n; *   |len  |level|type |XX|cmsg_data[]|XX|len  |level|type |XX|cmsg_data[]|XX|&n; *&n; *   +-----+-----+-----+--+-----------+--+-----+-----+-----+--+-----------+--+&n; *    ^&n; *    |&n; *&n; * msg_control&n; * points here&n; */
DECL|function|sctp_msghdr_parse
id|SCTP_STATIC
r_int
id|sctp_msghdr_parse
c_func
(paren
r_const
r_struct
id|msghdr
op_star
id|msg
comma
id|sctp_cmsgs_t
op_star
id|cmsgs
)paren
(brace
r_struct
id|cmsghdr
op_star
id|cmsg
suffix:semicolon
r_for
c_loop
(paren
id|cmsg
op_assign
id|CMSG_FIRSTHDR
c_func
(paren
id|msg
)paren
suffix:semicolon
id|cmsg
op_ne
l_int|NULL
suffix:semicolon
id|cmsg
op_assign
id|CMSG_NXTHDR
c_func
(paren
(paren
r_struct
id|msghdr
op_star
)paren
id|msg
comma
id|cmsg
)paren
)paren
(brace
multiline_comment|/* Check for minimum length.  The SCM code has this check.  */
r_if
c_cond
(paren
id|cmsg-&gt;cmsg_len
template_param
id|msg-&gt;msg_controllen
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* Should we parse this header or ignore?  */
r_if
c_cond
(paren
id|cmsg-&gt;cmsg_level
op_ne
id|IPPROTO_SCTP
)paren
r_continue
suffix:semicolon
multiline_comment|/* Strictly check lengths following example in SCM code.  */
r_switch
c_cond
(paren
id|cmsg-&gt;cmsg_type
)paren
(brace
r_case
id|SCTP_INIT
suffix:colon
multiline_comment|/* SCTP Socket API Extension&n;&t;&t;&t; * 5.2.1 SCTP Initiation Structure (SCTP_INIT)&n;&t;&t;&t; *&n;&t;&t;&t; * This cmsghdr structure provides information for&n;&t;&t;&t; * initializing new SCTP associations with sendmsg().&n;&t;&t;&t; * The SCTP_INITMSG socket option uses this same data&n;&t;&t;&t; * structure.  This structure is not used for&n;&t;&t;&t; * recvmsg().&n;&t;&t;&t; *&n;&t;&t;&t; * cmsg_level    cmsg_type      cmsg_data[]&n;&t;&t;&t; * ------------  ------------   ----------------------&n;&t;&t;&t; * IPPROTO_SCTP  SCTP_INIT      struct sctp_initmsg&n;&t;&t;&t; */
r_if
c_cond
(paren
id|cmsg-&gt;cmsg_len
op_ne
id|CMSG_LEN
c_func
(paren
r_sizeof
(paren
r_struct
id|sctp_initmsg
)paren
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|cmsgs-&gt;init
op_assign
(paren
r_struct
id|sctp_initmsg
op_star
)paren
id|CMSG_DATA
c_func
(paren
id|cmsg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_SNDRCV
suffix:colon
multiline_comment|/* SCTP Socket API Extension&n;&t;&t;&t; * 5.2.2 SCTP Header Information Structure(SCTP_SNDRCV)&n;&t;&t;&t; *&n;&t;&t;&t; * This cmsghdr structure specifies SCTP options for&n;&t;&t;&t; * sendmsg() and describes SCTP header information&n;&t;&t;&t; * about a received message through recvmsg().&n;&t;&t;&t; *&n;&t;&t;&t; * cmsg_level    cmsg_type      cmsg_data[]&n;&t;&t;&t; * ------------  ------------   ----------------------&n;&t;&t;&t; * IPPROTO_SCTP  SCTP_SNDRCV    struct sctp_sndrcvinfo&n;&t;&t;&t; */
r_if
c_cond
(paren
id|cmsg-&gt;cmsg_len
op_ne
id|CMSG_LEN
c_func
(paren
r_sizeof
(paren
r_struct
id|sctp_sndrcvinfo
)paren
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|cmsgs-&gt;info
op_assign
(paren
r_struct
id|sctp_sndrcvinfo
op_star
)paren
id|CMSG_DATA
c_func
(paren
id|cmsg
)paren
suffix:semicolon
multiline_comment|/* Minimally, validate the sinfo_flags. */
r_if
c_cond
(paren
id|cmsgs-&gt;info-&gt;sinfo_flags
op_amp
op_complement
(paren
id|MSG_UNORDERED
op_or
id|MSG_ADDR_OVER
op_or
id|MSG_ABORT
op_or
id|MSG_EOF
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Wait for a packet..&n; * Note: This function is the same function as in core/datagram.c&n; * with a few modifications to make lksctp work.&n; */
DECL|function|sctp_wait_for_packet
r_static
r_int
id|sctp_wait_for_packet
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
op_star
id|err
comma
r_int
op_star
id|timeo_p
)paren
(brace
r_int
id|error
suffix:semicolon
id|DEFINE_WAIT
c_func
(paren
id|wait
)paren
suffix:semicolon
id|prepare_to_wait_exclusive
c_func
(paren
id|sk-&gt;sk_sleep
comma
op_amp
id|wait
comma
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
multiline_comment|/* Socket errors? */
id|error
op_assign
id|sock_error
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skb_queue_empty
c_func
(paren
op_amp
id|sk-&gt;sk_receive_queue
)paren
)paren
r_goto
id|ready
suffix:semicolon
multiline_comment|/* Socket shut down?  */
r_if
c_cond
(paren
id|sk-&gt;sk_shutdown
op_amp
id|RCV_SHUTDOWN
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* Sequenced packets can come disconnected.  If so we report the&n;&t; * problem.&n;&t; */
id|error
op_assign
op_minus
id|ENOTCONN
suffix:semicolon
multiline_comment|/* Is there a good reason to think that we may receive some data?  */
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|sctp_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|ep-&gt;asocs
)paren
op_logical_and
op_logical_neg
id|sctp_sstate
c_func
(paren
id|sk
comma
id|LISTENING
)paren
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* Handle signals.  */
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
r_goto
id|interrupted
suffix:semicolon
multiline_comment|/* Let another process have a go.  Since we are going to sleep&n;&t; * anyway.  Note: This may cause odd behaviors if the message&n;&t; * does not fit in the user&squot;s buffer, but this seems to be the&n;&t; * only way to honor MSG_DONTWAIT realistically.&n;&t; */
id|sctp_release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
op_star
id|timeo_p
op_assign
id|schedule_timeout
c_func
(paren
op_star
id|timeo_p
)paren
suffix:semicolon
id|sctp_lock_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
id|ready
suffix:colon
id|finish_wait
c_func
(paren
id|sk-&gt;sk_sleep
comma
op_amp
id|wait
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|interrupted
suffix:colon
id|error
op_assign
id|sock_intr_errno
c_func
(paren
op_star
id|timeo_p
)paren
suffix:semicolon
id|out
suffix:colon
id|finish_wait
c_func
(paren
id|sk-&gt;sk_sleep
comma
op_amp
id|wait
)paren
suffix:semicolon
op_star
id|err
op_assign
id|error
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/* Receive a datagram.&n; * Note: This is pretty much the same routine as in core/datagram.c&n; * with a few changes to make lksctp work.&n; */
DECL|function|sctp_skb_recv_datagram
r_static
r_struct
id|sk_buff
op_star
id|sctp_skb_recv_datagram
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|flags
comma
r_int
id|noblock
comma
r_int
op_star
id|err
)paren
(brace
r_int
id|error
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_int
id|timeo
suffix:semicolon
multiline_comment|/* Caller is allowed not to check sk-&gt;sk_err before calling.  */
id|error
op_assign
id|sock_error
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|no_packet
suffix:semicolon
id|timeo
op_assign
id|sock_rcvtimeo
c_func
(paren
id|sk
comma
id|noblock
)paren
suffix:semicolon
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;Timeout: timeo: %ld, MAX: %ld.&bslash;n&quot;
comma
id|timeo
comma
id|MAX_SCHEDULE_TIMEOUT
)paren
suffix:semicolon
r_do
(brace
multiline_comment|/* Again only user level code calls this function,&n;&t;&t; * so nothing interrupt level&n;&t;&t; * will suddenly eat the receive_queue.&n;&t;&t; *&n;&t;&t; *  Look at current nfs client by the way...&n;&t;&t; *  However, this function was corrent in any case. 8)&n;&t;&t; */
r_if
c_cond
(paren
id|flags
op_amp
id|MSG_PEEK
)paren
(brace
r_int
r_int
id|cpu_flags
suffix:semicolon
id|sctp_spin_lock_irqsave
c_func
(paren
op_amp
id|sk-&gt;sk_receive_queue.lock
comma
id|cpu_flags
)paren
suffix:semicolon
id|skb
op_assign
id|skb_peek
c_func
(paren
op_amp
id|sk-&gt;sk_receive_queue
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
)paren
id|atomic_inc
c_func
(paren
op_amp
id|skb-&gt;users
)paren
suffix:semicolon
id|sctp_spin_unlock_irqrestore
c_func
(paren
op_amp
id|sk-&gt;sk_receive_queue.lock
comma
id|cpu_flags
)paren
suffix:semicolon
)brace
r_else
(brace
id|skb
op_assign
id|skb_dequeue
c_func
(paren
op_amp
id|sk-&gt;sk_receive_queue
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|skb
)paren
r_return
id|skb
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;sk_shutdown
op_amp
id|RCV_SHUTDOWN
)paren
r_break
suffix:semicolon
multiline_comment|/* User doesn&squot;t want to wait.  */
id|error
op_assign
op_minus
id|EAGAIN
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|timeo
)paren
r_goto
id|no_packet
suffix:semicolon
)brace
r_while
c_loop
(paren
id|sctp_wait_for_packet
c_func
(paren
id|sk
comma
id|err
comma
op_amp
id|timeo
)paren
op_eq
l_int|0
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
id|no_packet
suffix:colon
op_star
id|err
op_assign
id|error
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* If sndbuf has changed, wake up per association sndbuf waiters.  */
DECL|function|__sctp_write_space
r_static
r_void
id|__sctp_write_space
c_func
(paren
r_struct
id|sctp_association
op_star
id|asoc
)paren
(brace
r_struct
id|sock
op_star
id|sk
op_assign
id|asoc-&gt;base.sk
suffix:semicolon
r_struct
id|socket
op_star
id|sock
op_assign
id|sk-&gt;sk_socket
suffix:semicolon
r_if
c_cond
(paren
(paren
id|sctp_wspace
c_func
(paren
id|asoc
)paren
OG
l_int|0
)paren
op_logical_and
id|sock
)paren
(brace
r_if
c_cond
(paren
id|waitqueue_active
c_func
(paren
op_amp
id|asoc-&gt;wait
)paren
)paren
id|wake_up_interruptible
c_func
(paren
op_amp
id|asoc-&gt;wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sctp_writeable
c_func
(paren
id|sk
)paren
)paren
(brace
r_if
c_cond
(paren
id|sk-&gt;sk_sleep
op_logical_and
id|waitqueue_active
c_func
(paren
id|sk-&gt;sk_sleep
)paren
)paren
id|wake_up_interruptible
c_func
(paren
id|sk-&gt;sk_sleep
)paren
suffix:semicolon
multiline_comment|/* Note that we try to include the Async I/O support&n;&t;&t;&t; * here by modeling from the current TCP/UDP code.&n;&t;&t;&t; * We have not tested with it yet.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|sock-&gt;fasync_list
op_logical_and
op_logical_neg
(paren
id|sk-&gt;sk_shutdown
op_amp
id|SEND_SHUTDOWN
)paren
)paren
id|sock_wake_async
c_func
(paren
id|sock
comma
l_int|2
comma
id|POLL_OUT
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Do accounting for the sndbuf space.&n; * Decrement the used sndbuf space of the corresponding association by the&n; * data size which was just transmitted(freed).&n; */
DECL|function|sctp_wfree
r_static
r_void
id|sctp_wfree
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|sctp_association
op_star
id|asoc
suffix:semicolon
r_struct
id|sctp_chunk
op_star
id|chunk
suffix:semicolon
r_struct
id|sock
op_star
id|sk
suffix:semicolon
multiline_comment|/* Get the saved chunk pointer.  */
id|chunk
op_assign
op_star
(paren
(paren
r_struct
id|sctp_chunk
op_star
op_star
)paren
(paren
id|skb-&gt;cb
)paren
)paren
suffix:semicolon
id|asoc
op_assign
id|chunk-&gt;asoc
suffix:semicolon
id|sk
op_assign
id|asoc-&gt;base.sk
suffix:semicolon
id|asoc-&gt;sndbuf_used
op_sub_assign
id|SCTP_DATA_SNDSIZE
c_func
(paren
id|chunk
)paren
suffix:semicolon
id|sk-&gt;sk_wmem_queued
op_sub_assign
id|SCTP_DATA_SNDSIZE
c_func
(paren
id|chunk
)paren
suffix:semicolon
id|__sctp_write_space
c_func
(paren
id|asoc
)paren
suffix:semicolon
id|sctp_association_put
c_func
(paren
id|asoc
)paren
suffix:semicolon
)brace
multiline_comment|/* Helper function to wait for space in the sndbuf.  */
DECL|function|sctp_wait_for_sndbuf
r_static
r_int
id|sctp_wait_for_sndbuf
c_func
(paren
r_struct
id|sctp_association
op_star
id|asoc
comma
r_int
op_star
id|timeo_p
comma
r_int
id|msg_len
)paren
(brace
r_struct
id|sock
op_star
id|sk
op_assign
id|asoc-&gt;base.sk
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
r_int
id|current_timeo
op_assign
op_star
id|timeo_p
suffix:semicolon
id|DEFINE_WAIT
c_func
(paren
id|wait
)paren
suffix:semicolon
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;wait_for_sndbuf: asoc=%p, timeo=%ld, msg_len=%zu&bslash;n&quot;
comma
id|asoc
comma
(paren
r_int
)paren
(paren
op_star
id|timeo_p
)paren
comma
id|msg_len
)paren
suffix:semicolon
multiline_comment|/* Increment the association&squot;s refcnt.  */
id|sctp_association_hold
c_func
(paren
id|asoc
)paren
suffix:semicolon
multiline_comment|/* Wait on the association specific sndbuf space. */
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|prepare_to_wait_exclusive
c_func
(paren
op_amp
id|asoc-&gt;wait
comma
op_amp
id|wait
comma
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_star
id|timeo_p
)paren
r_goto
id|do_nonblock
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;sk_err
op_logical_or
id|asoc-&gt;state
op_ge
id|SCTP_STATE_SHUTDOWN_PENDING
op_logical_or
id|asoc-&gt;base.dead
)paren
r_goto
id|do_error
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
r_goto
id|do_interrupted
suffix:semicolon
r_if
c_cond
(paren
id|msg_len
op_le
id|sctp_wspace
c_func
(paren
id|asoc
)paren
)paren
r_break
suffix:semicolon
multiline_comment|/* Let another process have a go.  Since we are going&n;&t;&t; * to sleep anyway.&n;&t;&t; */
id|sctp_release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
id|current_timeo
op_assign
id|schedule_timeout
c_func
(paren
id|current_timeo
)paren
suffix:semicolon
id|sctp_lock_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
op_star
id|timeo_p
op_assign
id|current_timeo
suffix:semicolon
)brace
id|out
suffix:colon
id|finish_wait
c_func
(paren
op_amp
id|asoc-&gt;wait
comma
op_amp
id|wait
)paren
suffix:semicolon
multiline_comment|/* Release the association&squot;s refcnt.  */
id|sctp_association_put
c_func
(paren
id|asoc
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
id|do_error
suffix:colon
id|err
op_assign
op_minus
id|EPIPE
suffix:semicolon
r_goto
id|out
suffix:semicolon
id|do_interrupted
suffix:colon
id|err
op_assign
id|sock_intr_errno
c_func
(paren
op_star
id|timeo_p
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
id|do_nonblock
suffix:colon
id|err
op_assign
op_minus
id|EAGAIN
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* If socket sndbuf has changed, wake up all per association waiters.  */
DECL|function|sctp_write_space
r_void
id|sctp_write_space
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|sctp_association
op_star
id|asoc
suffix:semicolon
r_struct
id|list_head
op_star
id|pos
suffix:semicolon
multiline_comment|/* Wake up the tasks in each wait queue.  */
id|list_for_each
c_func
(paren
id|pos
comma
op_amp
(paren
(paren
id|sctp_sk
c_func
(paren
id|sk
)paren
)paren
op_member_access_from_pointer
id|ep-&gt;asocs
)paren
)paren
(brace
id|asoc
op_assign
id|list_entry
c_func
(paren
id|pos
comma
r_struct
id|sctp_association
comma
id|asocs
)paren
suffix:semicolon
id|__sctp_write_space
c_func
(paren
id|asoc
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Is there any sndbuf space available on the socket?&n; *&n; * Note that wmem_queued is the sum of the send buffers on all of the&n; * associations on the same socket.  For a UDP-style socket with&n; * multiple associations, it is possible for it to be &quot;unwriteable&quot;&n; * prematurely.  I assume that this is acceptable because&n; * a premature &quot;unwriteable&quot; is better than an accidental &quot;writeable&quot; which&n; * would cause an unwanted block under certain circumstances.  For the 1-1&n; * UDP-style sockets or TCP-style sockets, this code should work.&n; *  - Daisy&n; */
DECL|function|sctp_writeable
r_static
r_int
id|sctp_writeable
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_int
id|amt
op_assign
l_int|0
suffix:semicolon
id|amt
op_assign
id|sk-&gt;sk_sndbuf
op_minus
id|sk-&gt;sk_wmem_queued
suffix:semicolon
r_if
c_cond
(paren
id|amt
OL
l_int|0
)paren
id|amt
op_assign
l_int|0
suffix:semicolon
r_return
id|amt
suffix:semicolon
)brace
multiline_comment|/* Wait for an association to go into ESTABLISHED state. If timeout is 0,&n; * returns immediately with EINPROGRESS.&n; */
DECL|function|sctp_wait_for_connect
r_static
r_int
id|sctp_wait_for_connect
c_func
(paren
r_struct
id|sctp_association
op_star
id|asoc
comma
r_int
op_star
id|timeo_p
)paren
(brace
r_struct
id|sock
op_star
id|sk
op_assign
id|asoc-&gt;base.sk
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
r_int
id|current_timeo
op_assign
op_star
id|timeo_p
suffix:semicolon
id|DEFINE_WAIT
c_func
(paren
id|wait
)paren
suffix:semicolon
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;%s: asoc=%p, timeo=%ld&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|asoc
comma
(paren
r_int
)paren
(paren
op_star
id|timeo_p
)paren
)paren
suffix:semicolon
multiline_comment|/* Increment the association&squot;s refcnt.  */
id|sctp_association_hold
c_func
(paren
id|asoc
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|prepare_to_wait_exclusive
c_func
(paren
op_amp
id|asoc-&gt;wait
comma
op_amp
id|wait
comma
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_star
id|timeo_p
)paren
r_goto
id|do_nonblock
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;sk_shutdown
op_amp
id|RCV_SHUTDOWN
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;sk_err
op_logical_or
id|asoc-&gt;state
op_ge
id|SCTP_STATE_SHUTDOWN_PENDING
op_logical_or
id|asoc-&gt;base.dead
)paren
r_goto
id|do_error
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
r_goto
id|do_interrupted
suffix:semicolon
r_if
c_cond
(paren
id|sctp_state
c_func
(paren
id|asoc
comma
id|ESTABLISHED
)paren
)paren
r_break
suffix:semicolon
multiline_comment|/* Let another process have a go.  Since we are going&n;&t;&t; * to sleep anyway.&n;&t;&t; */
id|sctp_release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
id|current_timeo
op_assign
id|schedule_timeout
c_func
(paren
id|current_timeo
)paren
suffix:semicolon
id|sctp_lock_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
op_star
id|timeo_p
op_assign
id|current_timeo
suffix:semicolon
)brace
id|out
suffix:colon
id|finish_wait
c_func
(paren
op_amp
id|asoc-&gt;wait
comma
op_amp
id|wait
)paren
suffix:semicolon
multiline_comment|/* Release the association&squot;s refcnt.  */
id|sctp_association_put
c_func
(paren
id|asoc
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
id|do_error
suffix:colon
r_if
c_cond
(paren
id|asoc-&gt;counters
(braket
id|SCTP_COUNTER_INIT_ERROR
)braket
op_plus
l_int|1
op_ge
id|asoc-&gt;max_init_attempts
)paren
id|err
op_assign
op_minus
id|ETIMEDOUT
suffix:semicolon
r_else
id|err
op_assign
op_minus
id|ECONNREFUSED
suffix:semicolon
r_goto
id|out
suffix:semicolon
id|do_interrupted
suffix:colon
id|err
op_assign
id|sock_intr_errno
c_func
(paren
op_star
id|timeo_p
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
id|do_nonblock
suffix:colon
id|err
op_assign
op_minus
id|EINPROGRESS
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
DECL|function|sctp_wait_for_accept
r_static
r_int
id|sctp_wait_for_accept
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|timeo
)paren
(brace
r_struct
id|sctp_endpoint
op_star
id|ep
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
id|DEFINE_WAIT
c_func
(paren
id|wait
)paren
suffix:semicolon
id|ep
op_assign
id|sctp_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|ep
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|prepare_to_wait_exclusive
c_func
(paren
id|sk-&gt;sk_sleep
comma
op_amp
id|wait
comma
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|ep-&gt;asocs
)paren
)paren
(brace
id|sctp_release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
id|timeo
op_assign
id|schedule_timeout
c_func
(paren
id|timeo
)paren
suffix:semicolon
id|sctp_lock_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sctp_sstate
c_func
(paren
id|sk
comma
id|LISTENING
)paren
)paren
r_break
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|ep-&gt;asocs
)paren
)paren
r_break
suffix:semicolon
id|err
op_assign
id|sock_intr_errno
c_func
(paren
id|timeo
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
r_break
suffix:semicolon
id|err
op_assign
op_minus
id|EAGAIN
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|timeo
)paren
r_break
suffix:semicolon
)brace
id|finish_wait
c_func
(paren
id|sk-&gt;sk_sleep
comma
op_amp
id|wait
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|function|sctp_wait_for_close
r_void
id|sctp_wait_for_close
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|timeout
)paren
(brace
id|DEFINE_WAIT
c_func
(paren
id|wait
)paren
suffix:semicolon
r_do
(brace
id|prepare_to_wait
c_func
(paren
id|sk-&gt;sk_sleep
comma
op_amp
id|wait
comma
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|sctp_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|ep-&gt;asocs
)paren
)paren
r_break
suffix:semicolon
id|sctp_release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
id|timeout
op_assign
id|schedule_timeout
c_func
(paren
id|timeout
)paren
suffix:semicolon
id|sctp_lock_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
op_logical_neg
id|signal_pending
c_func
(paren
id|current
)paren
op_logical_and
id|timeout
)paren
suffix:semicolon
id|finish_wait
c_func
(paren
id|sk-&gt;sk_sleep
comma
op_amp
id|wait
)paren
suffix:semicolon
)brace
multiline_comment|/* Populate the fields of the newsk from the oldsk and migrate the assoc&n; * and its messages to the newsk.&n; */
DECL|function|sctp_sock_migrate
r_static
r_void
id|sctp_sock_migrate
c_func
(paren
r_struct
id|sock
op_star
id|oldsk
comma
r_struct
id|sock
op_star
id|newsk
comma
r_struct
id|sctp_association
op_star
id|assoc
comma
id|sctp_socket_type_t
id|type
)paren
(brace
r_struct
id|sctp_opt
op_star
id|oldsp
op_assign
id|sctp_sk
c_func
(paren
id|oldsk
)paren
suffix:semicolon
r_struct
id|sctp_opt
op_star
id|newsp
op_assign
id|sctp_sk
c_func
(paren
id|newsk
)paren
suffix:semicolon
r_struct
id|sctp_bind_bucket
op_star
id|pp
suffix:semicolon
multiline_comment|/* hash list port iterator */
r_struct
id|sctp_endpoint
op_star
id|newep
op_assign
id|newsp-&gt;ep
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
comma
op_star
id|tmp
suffix:semicolon
r_struct
id|sctp_ulpevent
op_star
id|event
suffix:semicolon
multiline_comment|/* Migrate socket buffer sizes and all the socket level options to the&n;&t; * new socket.&n;&t; */
id|newsk-&gt;sk_sndbuf
op_assign
id|oldsk-&gt;sk_sndbuf
suffix:semicolon
id|newsk-&gt;sk_rcvbuf
op_assign
id|oldsk-&gt;sk_rcvbuf
suffix:semicolon
multiline_comment|/* Brute force copy old sctp opt. */
id|memcpy
c_func
(paren
id|newsp
comma
id|oldsp
comma
r_sizeof
(paren
r_struct
id|sctp_opt
)paren
)paren
suffix:semicolon
multiline_comment|/* Restore the ep value that was overwritten with the above structure&n;&t; * copy.&n;&t; */
id|newsp-&gt;ep
op_assign
id|newep
suffix:semicolon
id|newsp-&gt;hmac
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Hook this new socket in to the bind_hash list. */
id|pp
op_assign
id|sctp_sk
c_func
(paren
id|oldsk
)paren
op_member_access_from_pointer
id|bind_hash
suffix:semicolon
id|sk_add_bind_node
c_func
(paren
id|newsk
comma
op_amp
id|pp-&gt;owner
)paren
suffix:semicolon
id|sctp_sk
c_func
(paren
id|newsk
)paren
op_member_access_from_pointer
id|bind_hash
op_assign
id|pp
suffix:semicolon
id|inet_sk
c_func
(paren
id|newsk
)paren
op_member_access_from_pointer
id|num
op_assign
id|inet_sk
c_func
(paren
id|oldsk
)paren
op_member_access_from_pointer
id|num
suffix:semicolon
multiline_comment|/* Move any messages in the old socket&squot;s receive queue that are for the&n;&t; * peeled off association to the new socket&squot;s receive queue.&n;&t; */
id|sctp_skb_for_each
c_func
(paren
id|skb
comma
op_amp
id|oldsk-&gt;sk_receive_queue
comma
id|tmp
)paren
(brace
id|event
op_assign
id|sctp_skb2event
c_func
(paren
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|event-&gt;asoc
op_eq
id|assoc
)paren
(brace
id|__skb_unlink
c_func
(paren
id|skb
comma
id|skb-&gt;list
)paren
suffix:semicolon
id|__skb_queue_tail
c_func
(paren
op_amp
id|newsk-&gt;sk_receive_queue
comma
id|skb
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Clean up any messages pending delivery due to partial&n;&t; * delivery.   Three cases:&n;&t; * 1) No partial deliver;  no work.&n;&t; * 2) Peeling off partial delivery; keep pd_lobby in new pd_lobby.&n;&t; * 3) Peeling off non-partial delivery; move pd_lobby to recieve_queue.&n;&t; */
id|skb_queue_head_init
c_func
(paren
op_amp
id|newsp-&gt;pd_lobby
)paren
suffix:semicolon
id|sctp_sk
c_func
(paren
id|newsk
)paren
op_member_access_from_pointer
id|pd_mode
op_assign
id|assoc-&gt;ulpq.pd_mode
suffix:semicolon
r_if
c_cond
(paren
id|sctp_sk
c_func
(paren
id|oldsk
)paren
op_member_access_from_pointer
id|pd_mode
)paren
(brace
r_struct
id|sk_buff_head
op_star
id|queue
suffix:semicolon
multiline_comment|/* Decide which queue to move pd_lobby skbs to. */
r_if
c_cond
(paren
id|assoc-&gt;ulpq.pd_mode
)paren
(brace
id|queue
op_assign
op_amp
id|newsp-&gt;pd_lobby
suffix:semicolon
)brace
r_else
id|queue
op_assign
op_amp
id|newsk-&gt;sk_receive_queue
suffix:semicolon
multiline_comment|/* Walk through the pd_lobby, looking for skbs that&n;&t;&t; * need moved to the new socket.&n;&t;&t; */
id|sctp_skb_for_each
c_func
(paren
id|skb
comma
op_amp
id|oldsp-&gt;pd_lobby
comma
id|tmp
)paren
(brace
id|event
op_assign
id|sctp_skb2event
c_func
(paren
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|event-&gt;asoc
op_eq
id|assoc
)paren
(brace
id|__skb_unlink
c_func
(paren
id|skb
comma
id|skb-&gt;list
)paren
suffix:semicolon
id|__skb_queue_tail
c_func
(paren
id|queue
comma
id|skb
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Clear up any skbs waiting for the partial&n;&t;&t; * delivery to finish.&n;&t;&t; */
r_if
c_cond
(paren
id|assoc-&gt;ulpq.pd_mode
)paren
id|sctp_clear_pd
c_func
(paren
id|oldsk
)paren
suffix:semicolon
)brace
multiline_comment|/* Set the type of socket to indicate that it is peeled off from the&n;&t; * original UDP-style socket or created with the accept() call on a&n;&t; * TCP-style socket..&n;&t; */
id|newsp-&gt;type
op_assign
id|type
suffix:semicolon
multiline_comment|/* Migrate the association to the new socket. */
id|sctp_assoc_migrate
c_func
(paren
id|assoc
comma
id|newsk
)paren
suffix:semicolon
multiline_comment|/* If the association on the newsk is already closed before accept()&n;&t; * is called, set RCV_SHUTDOWN flag.&n;&t; */
r_if
c_cond
(paren
id|sctp_state
c_func
(paren
id|assoc
comma
id|CLOSED
)paren
op_logical_and
id|sctp_style
c_func
(paren
id|newsk
comma
id|TCP
)paren
)paren
id|newsk-&gt;sk_shutdown
op_or_assign
id|RCV_SHUTDOWN
suffix:semicolon
id|newsk-&gt;sk_state
op_assign
id|SCTP_SS_ESTABLISHED
suffix:semicolon
)brace
multiline_comment|/* This proto struct describes the ULP interface for SCTP.  */
DECL|variable|sctp_prot
r_struct
id|proto
id|sctp_prot
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;SCTP&quot;
comma
dot
id|close
op_assign
id|sctp_close
comma
dot
id|connect
op_assign
id|sctp_connect
comma
dot
id|disconnect
op_assign
id|sctp_disconnect
comma
dot
id|accept
op_assign
id|sctp_accept
comma
dot
id|ioctl
op_assign
id|sctp_ioctl
comma
dot
id|init
op_assign
id|sctp_init_sock
comma
dot
id|destroy
op_assign
id|sctp_destroy_sock
comma
dot
id|shutdown
op_assign
id|sctp_shutdown
comma
dot
id|setsockopt
op_assign
id|sctp_setsockopt
comma
dot
id|getsockopt
op_assign
id|sctp_getsockopt
comma
dot
id|sendmsg
op_assign
id|sctp_sendmsg
comma
dot
id|recvmsg
op_assign
id|sctp_recvmsg
comma
dot
id|bind
op_assign
id|sctp_bind
comma
dot
id|backlog_rcv
op_assign
id|sctp_backlog_rcv
comma
dot
id|hash
op_assign
id|sctp_hash
comma
dot
id|unhash
op_assign
id|sctp_unhash
comma
dot
id|get_port
op_assign
id|sctp_get_port
comma
dot
id|slab_obj_size
op_assign
r_sizeof
(paren
r_struct
id|sctp_sock
)paren
comma
)brace
suffix:semicolon
macro_line|#if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)
DECL|variable|sctpv6_prot
r_struct
id|proto
id|sctpv6_prot
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;SCTPv6&quot;
comma
dot
id|close
op_assign
id|sctp_close
comma
dot
id|connect
op_assign
id|sctp_connect
comma
dot
id|disconnect
op_assign
id|sctp_disconnect
comma
dot
id|accept
op_assign
id|sctp_accept
comma
dot
id|ioctl
op_assign
id|sctp_ioctl
comma
dot
id|init
op_assign
id|sctp_init_sock
comma
dot
id|destroy
op_assign
id|sctp_destroy_sock
comma
dot
id|shutdown
op_assign
id|sctp_shutdown
comma
dot
id|setsockopt
op_assign
id|sctp_setsockopt
comma
dot
id|getsockopt
op_assign
id|sctp_getsockopt
comma
dot
id|sendmsg
op_assign
id|sctp_sendmsg
comma
dot
id|recvmsg
op_assign
id|sctp_recvmsg
comma
dot
id|bind
op_assign
id|sctp_bind
comma
dot
id|backlog_rcv
op_assign
id|sctp_backlog_rcv
comma
dot
id|hash
op_assign
id|sctp_hash
comma
dot
id|unhash
op_assign
id|sctp_unhash
comma
dot
id|get_port
op_assign
id|sctp_get_port
comma
dot
id|slab_obj_size
op_assign
r_sizeof
(paren
r_struct
id|sctp6_sock
)paren
comma
)brace
suffix:semicolon
macro_line|#endif /* defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE) */
eof
