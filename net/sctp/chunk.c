multiline_comment|/* SCTP kernel reference Implementation&n; * (C) Copyright IBM Corp. 2003, 2004&n; *&n; * This file is part of the SCTP kernel reference Implementation&n; *&n; * This file contains the code relating the the chunk abstraction.&n; *&n; * The SCTP reference implementation is free software;&n; * you can redistribute it and/or modify it under the terms of&n; * the GNU General Public License as published by&n; * the Free Software Foundation; either version 2, or (at your option)&n; * any later version.&n; *&n; * The SCTP reference implementation is distributed in the hope that it&n; * will be useful, but WITHOUT ANY WARRANTY; without even the implied&n; *                 ************************&n; * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&n; * See the GNU General Public License for more details.&n; *&n; * You should have received a copy of the GNU General Public License&n; * along with GNU CC; see the file COPYING.  If not, write to&n; * the Free Software Foundation, 59 Temple Place - Suite 330,&n; * Boston, MA 02111-1307, USA.&n; *&n; * Please send any bug reports or fixes you make to the&n; * email address(es):&n; *    lksctp developers &lt;lksctp-developers@lists.sourceforge.net&gt;&n; *&n; * Or submit a bug report through the following website:&n; *    http://www.sf.net/projects/lksctp&n; *&n; * Written or modified by:&n; *    Jon Grimm             &lt;jgrimm@us.ibm.com&gt;&n; *    Sridhar Samudrala     &lt;sri@us.ibm.com&gt;&n; *&n; * Any bugs reported given to us we will try to fix... any fixes shared will&n; * be incorporated into the next SCTP release.&n; */
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/net.h&gt;
macro_line|#include &lt;linux/inet.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;net/sock.h&gt;
macro_line|#include &lt;net/sctp/sctp.h&gt;
macro_line|#include &lt;net/sctp/sm.h&gt;
multiline_comment|/* This file is mostly in anticipation of future work, but initially&n; * populate with fragment tracking for an outbound message.&n; */
multiline_comment|/* Initialize datamsg from memory. */
DECL|function|sctp_datamsg_init
r_static
r_void
id|sctp_datamsg_init
c_func
(paren
r_struct
id|sctp_datamsg
op_star
id|msg
)paren
(brace
id|atomic_set
c_func
(paren
op_amp
id|msg-&gt;refcnt
comma
l_int|1
)paren
suffix:semicolon
id|msg-&gt;send_failed
op_assign
l_int|0
suffix:semicolon
id|msg-&gt;send_error
op_assign
l_int|0
suffix:semicolon
id|msg-&gt;can_abandon
op_assign
l_int|0
suffix:semicolon
id|msg-&gt;expires_at
op_assign
l_int|0
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|msg-&gt;chunks
)paren
suffix:semicolon
)brace
multiline_comment|/* Allocate and initialize datamsg. */
DECL|function|sctp_datamsg_new
id|SCTP_STATIC
r_struct
id|sctp_datamsg
op_star
id|sctp_datamsg_new
c_func
(paren
r_int
id|gfp
)paren
(brace
r_struct
id|sctp_datamsg
op_star
id|msg
suffix:semicolon
id|msg
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|sctp_datamsg
)paren
comma
id|gfp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|msg
)paren
id|sctp_datamsg_init
c_func
(paren
id|msg
)paren
suffix:semicolon
id|SCTP_DBG_OBJCNT_INC
c_func
(paren
id|datamsg
)paren
suffix:semicolon
r_return
id|msg
suffix:semicolon
)brace
multiline_comment|/* Final destructruction of datamsg memory. */
DECL|function|sctp_datamsg_destroy
r_static
r_void
id|sctp_datamsg_destroy
c_func
(paren
r_struct
id|sctp_datamsg
op_star
id|msg
)paren
(brace
r_struct
id|list_head
op_star
id|pos
comma
op_star
id|temp
suffix:semicolon
r_struct
id|sctp_chunk
op_star
id|chunk
suffix:semicolon
r_struct
id|sctp_sock
op_star
id|sp
suffix:semicolon
r_struct
id|sctp_ulpevent
op_star
id|ev
suffix:semicolon
r_struct
id|sctp_association
op_star
id|asoc
op_assign
l_int|NULL
suffix:semicolon
r_int
id|error
op_assign
l_int|0
comma
id|notify
suffix:semicolon
multiline_comment|/* If we failed, we may need to notify. */
id|notify
op_assign
id|msg-&gt;send_failed
ques
c_cond
op_minus
l_int|1
suffix:colon
l_int|0
suffix:semicolon
multiline_comment|/* Release all references. */
id|list_for_each_safe
c_func
(paren
id|pos
comma
id|temp
comma
op_amp
id|msg-&gt;chunks
)paren
(brace
id|list_del_init
c_func
(paren
id|pos
)paren
suffix:semicolon
id|chunk
op_assign
id|list_entry
c_func
(paren
id|pos
comma
r_struct
id|sctp_chunk
comma
id|frag_list
)paren
suffix:semicolon
multiline_comment|/* Check whether we _really_ need to notify. */
r_if
c_cond
(paren
id|notify
OL
l_int|0
)paren
(brace
id|asoc
op_assign
id|chunk-&gt;asoc
suffix:semicolon
r_if
c_cond
(paren
id|msg-&gt;send_error
)paren
id|error
op_assign
id|msg-&gt;send_error
suffix:semicolon
r_else
id|error
op_assign
id|asoc-&gt;outqueue.error
suffix:semicolon
id|sp
op_assign
id|sctp_sk
c_func
(paren
id|asoc-&gt;base.sk
)paren
suffix:semicolon
id|notify
op_assign
id|sctp_ulpevent_type_enabled
c_func
(paren
id|SCTP_SEND_FAILED
comma
op_amp
id|sp-&gt;subscribe
)paren
suffix:semicolon
)brace
multiline_comment|/* Generate a SEND FAILED event only if enabled. */
r_if
c_cond
(paren
id|notify
OG
l_int|0
)paren
(brace
r_int
id|sent
suffix:semicolon
r_if
c_cond
(paren
id|chunk-&gt;has_tsn
)paren
id|sent
op_assign
id|SCTP_DATA_SENT
suffix:semicolon
r_else
id|sent
op_assign
id|SCTP_DATA_UNSENT
suffix:semicolon
id|ev
op_assign
id|sctp_ulpevent_make_send_failed
c_func
(paren
id|asoc
comma
id|chunk
comma
id|sent
comma
id|error
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ev
)paren
id|sctp_ulpq_tail_event
c_func
(paren
op_amp
id|asoc-&gt;ulpq
comma
id|ev
)paren
suffix:semicolon
)brace
id|sctp_chunk_put
c_func
(paren
id|chunk
)paren
suffix:semicolon
)brace
id|SCTP_DBG_OBJCNT_DEC
c_func
(paren
id|datamsg
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|msg
)paren
suffix:semicolon
)brace
multiline_comment|/* Hold a reference. */
DECL|function|sctp_datamsg_hold
r_static
r_void
id|sctp_datamsg_hold
c_func
(paren
r_struct
id|sctp_datamsg
op_star
id|msg
)paren
(brace
id|atomic_inc
c_func
(paren
op_amp
id|msg-&gt;refcnt
)paren
suffix:semicolon
)brace
multiline_comment|/* Release a reference. */
DECL|function|sctp_datamsg_put
r_void
id|sctp_datamsg_put
c_func
(paren
r_struct
id|sctp_datamsg
op_star
id|msg
)paren
(brace
r_if
c_cond
(paren
id|atomic_dec_and_test
c_func
(paren
op_amp
id|msg-&gt;refcnt
)paren
)paren
id|sctp_datamsg_destroy
c_func
(paren
id|msg
)paren
suffix:semicolon
)brace
multiline_comment|/* Free a message.  Really just give up a reference, the&n; * really free happens in sctp_datamsg_destroy().&n; */
DECL|function|sctp_datamsg_free
r_void
id|sctp_datamsg_free
c_func
(paren
r_struct
id|sctp_datamsg
op_star
id|msg
)paren
(brace
id|sctp_datamsg_put
c_func
(paren
id|msg
)paren
suffix:semicolon
)brace
multiline_comment|/* Hold on to all the fragments until all chunks have been sent. */
DECL|function|sctp_datamsg_track
r_void
id|sctp_datamsg_track
c_func
(paren
r_struct
id|sctp_chunk
op_star
id|chunk
)paren
(brace
id|sctp_chunk_hold
c_func
(paren
id|chunk
)paren
suffix:semicolon
)brace
multiline_comment|/* Assign a chunk to this datamsg. */
DECL|function|sctp_datamsg_assign
r_static
r_void
id|sctp_datamsg_assign
c_func
(paren
r_struct
id|sctp_datamsg
op_star
id|msg
comma
r_struct
id|sctp_chunk
op_star
id|chunk
)paren
(brace
id|sctp_datamsg_hold
c_func
(paren
id|msg
)paren
suffix:semicolon
id|chunk-&gt;msg
op_assign
id|msg
suffix:semicolon
)brace
multiline_comment|/* A data chunk can have a maximum payload of (2^16 - 20).  Break&n; * down any such message into smaller chunks.  Opportunistically, fragment&n; * the chunks down to the current MTU constraints.  We may get refragmented&n; * later if the PMTU changes, but it is _much better_ to fragment immediately&n; * with a reasonable guess than always doing our fragmentation on the&n; * soft-interrupt.&n; */
DECL|function|sctp_datamsg_from_user
r_struct
id|sctp_datamsg
op_star
id|sctp_datamsg_from_user
c_func
(paren
r_struct
id|sctp_association
op_star
id|asoc
comma
r_struct
id|sctp_sndrcvinfo
op_star
id|sinfo
comma
r_struct
id|msghdr
op_star
id|msgh
comma
r_int
id|msg_len
)paren
(brace
r_int
id|max
comma
id|whole
comma
id|i
comma
id|offset
comma
id|over
comma
id|err
suffix:semicolon
r_int
id|len
comma
id|first_len
suffix:semicolon
r_struct
id|sctp_chunk
op_star
id|chunk
suffix:semicolon
r_struct
id|sctp_datamsg
op_star
id|msg
suffix:semicolon
r_struct
id|list_head
op_star
id|pos
comma
op_star
id|temp
suffix:semicolon
id|__u8
id|frag
suffix:semicolon
id|msg
op_assign
id|sctp_datamsg_new
c_func
(paren
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|msg
)paren
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/* Note: Calculate this outside of the loop, so that all fragments&n;&t; * have the same expiration.&n;&t; */
r_if
c_cond
(paren
id|sinfo-&gt;sinfo_timetolive
)paren
(brace
multiline_comment|/* sinfo_timetolive is in milliseconds */
id|msg-&gt;expires_at
op_assign
id|jiffies
op_plus
id|msecs_to_jiffies
c_func
(paren
id|sinfo-&gt;sinfo_timetolive
)paren
suffix:semicolon
id|msg-&gt;can_abandon
op_assign
l_int|1
suffix:semicolon
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;%s: msg:%p expires_at: %ld jiffies:%ld&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|msg
comma
id|msg-&gt;expires_at
comma
id|jiffies
)paren
suffix:semicolon
)brace
id|max
op_assign
id|asoc-&gt;frag_point
suffix:semicolon
id|whole
op_assign
l_int|0
suffix:semicolon
id|first_len
op_assign
id|max
suffix:semicolon
multiline_comment|/* Encourage Cookie-ECHO bundling. */
r_if
c_cond
(paren
id|asoc-&gt;state
OL
id|SCTP_STATE_COOKIE_ECHOED
)paren
(brace
id|whole
op_assign
id|msg_len
op_div
(paren
id|max
op_minus
id|SCTP_ARBITRARY_COOKIE_ECHO_LEN
)paren
suffix:semicolon
multiline_comment|/* Account for the DATA to be bundled with the COOKIE-ECHO. */
r_if
c_cond
(paren
id|whole
)paren
(brace
id|first_len
op_assign
id|max
op_minus
id|SCTP_ARBITRARY_COOKIE_ECHO_LEN
suffix:semicolon
id|msg_len
op_sub_assign
id|first_len
suffix:semicolon
id|whole
op_assign
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/* How many full sized?  How many bytes leftover? */
id|whole
op_add_assign
id|msg_len
op_div
id|max
suffix:semicolon
id|over
op_assign
id|msg_len
op_mod
id|max
suffix:semicolon
id|offset
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|whole
OG
l_int|1
)paren
op_logical_or
(paren
id|whole
op_logical_and
id|over
)paren
)paren
id|SCTP_INC_STATS_USER
c_func
(paren
id|SCTP_MIB_FRAGUSRMSGS
)paren
suffix:semicolon
multiline_comment|/* Create chunks for all the full sized DATA chunks. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|len
op_assign
id|first_len
suffix:semicolon
id|i
OL
id|whole
suffix:semicolon
id|i
op_increment
)paren
(brace
id|frag
op_assign
id|SCTP_DATA_MIDDLE_FRAG
suffix:semicolon
r_if
c_cond
(paren
l_int|0
op_eq
id|i
)paren
id|frag
op_or_assign
id|SCTP_DATA_FIRST_FRAG
suffix:semicolon
r_if
c_cond
(paren
(paren
id|i
op_eq
(paren
id|whole
op_minus
l_int|1
)paren
)paren
op_logical_and
op_logical_neg
id|over
)paren
id|frag
op_or_assign
id|SCTP_DATA_LAST_FRAG
suffix:semicolon
id|chunk
op_assign
id|sctp_make_datafrag_empty
c_func
(paren
id|asoc
comma
id|sinfo
comma
id|len
comma
id|frag
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|chunk
)paren
r_goto
id|errout
suffix:semicolon
id|err
op_assign
id|sctp_user_addto_chunk
c_func
(paren
id|chunk
comma
id|offset
comma
id|len
comma
id|msgh-&gt;msg_iov
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_goto
id|errout
suffix:semicolon
id|offset
op_add_assign
id|len
suffix:semicolon
multiline_comment|/* Put the chunk-&gt;skb back into the form expected by send.  */
id|__skb_pull
c_func
(paren
id|chunk-&gt;skb
comma
(paren
id|__u8
op_star
)paren
id|chunk-&gt;chunk_hdr
op_minus
(paren
id|__u8
op_star
)paren
id|chunk-&gt;skb-&gt;data
)paren
suffix:semicolon
id|sctp_datamsg_assign
c_func
(paren
id|msg
comma
id|chunk
)paren
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|chunk-&gt;frag_list
comma
op_amp
id|msg-&gt;chunks
)paren
suffix:semicolon
multiline_comment|/* The first chunk, the first chunk was likely short&n;&t;&t; * to allow bundling, so reset to full size.&n;&t;&t; */
r_if
c_cond
(paren
l_int|0
op_eq
id|i
)paren
id|len
op_assign
id|max
suffix:semicolon
)brace
multiline_comment|/* .. now the leftover bytes. */
r_if
c_cond
(paren
id|over
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|whole
)paren
id|frag
op_assign
id|SCTP_DATA_NOT_FRAG
suffix:semicolon
r_else
id|frag
op_assign
id|SCTP_DATA_LAST_FRAG
suffix:semicolon
id|chunk
op_assign
id|sctp_make_datafrag_empty
c_func
(paren
id|asoc
comma
id|sinfo
comma
id|over
comma
id|frag
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|chunk
)paren
r_goto
id|errout
suffix:semicolon
id|err
op_assign
id|sctp_user_addto_chunk
c_func
(paren
id|chunk
comma
id|offset
comma
id|over
comma
id|msgh-&gt;msg_iov
)paren
suffix:semicolon
multiline_comment|/* Put the chunk-&gt;skb back into the form expected by send.  */
id|__skb_pull
c_func
(paren
id|chunk-&gt;skb
comma
(paren
id|__u8
op_star
)paren
id|chunk-&gt;chunk_hdr
op_minus
(paren
id|__u8
op_star
)paren
id|chunk-&gt;skb-&gt;data
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_goto
id|errout
suffix:semicolon
id|sctp_datamsg_assign
c_func
(paren
id|msg
comma
id|chunk
)paren
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|chunk-&gt;frag_list
comma
op_amp
id|msg-&gt;chunks
)paren
suffix:semicolon
)brace
r_return
id|msg
suffix:semicolon
id|errout
suffix:colon
id|list_for_each_safe
c_func
(paren
id|pos
comma
id|temp
comma
op_amp
id|msg-&gt;chunks
)paren
(brace
id|list_del_init
c_func
(paren
id|pos
)paren
suffix:semicolon
id|chunk
op_assign
id|list_entry
c_func
(paren
id|pos
comma
r_struct
id|sctp_chunk
comma
id|frag_list
)paren
suffix:semicolon
id|sctp_chunk_free
c_func
(paren
id|chunk
)paren
suffix:semicolon
)brace
id|sctp_datamsg_free
c_func
(paren
id|msg
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Check whether this message has expired. */
DECL|function|sctp_chunk_abandoned
r_int
id|sctp_chunk_abandoned
c_func
(paren
r_struct
id|sctp_chunk
op_star
id|chunk
)paren
(brace
r_struct
id|sctp_datamsg
op_star
id|msg
op_assign
id|chunk-&gt;msg
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|msg-&gt;can_abandon
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|time_after
c_func
(paren
id|jiffies
comma
id|msg-&gt;expires_at
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* This chunk (and consequently entire message) has failed in its sending. */
DECL|function|sctp_chunk_fail
r_void
id|sctp_chunk_fail
c_func
(paren
r_struct
id|sctp_chunk
op_star
id|chunk
comma
r_int
id|error
)paren
(brace
id|chunk-&gt;msg-&gt;send_failed
op_assign
l_int|1
suffix:semicolon
id|chunk-&gt;msg-&gt;send_error
op_assign
id|error
suffix:semicolon
)brace
eof
