multiline_comment|/* SCTP kernel reference Implementation&n; * Copyright (c) 1999-2000 Cisco, Inc.&n; * Copyright (c) 1999-2001 Motorola, Inc.&n; * Copyright (c) 2001-2002 International Business Machines, Corp.&n; * Copyright (c) 2002      Nokia Corp.&n; *&n; * This file is part of the SCTP kernel reference Implementation&n; * &n; * $Header: /cvsroot/lksctp/lksctp/sctp_cvs/net/sctp/sctp_sm_statefuns.c,v 1.48 2002/08/16 19:30:50 jgrimm Exp $&n; * &n; * This is part of the SCTP Linux Kernel Reference Implementation.&n; *&n; * These are the state functions for the state machine.&n; * &n; * The SCTP reference implementation is free software; &n; * you can redistribute it and/or modify it under the terms of &n; * the GNU General Public License as published by&n; * the Free Software Foundation; either version 2, or (at your option)&n; * any later version.&n; * &n; * The SCTP reference implementation is distributed in the hope that it &n; * will be useful, but WITHOUT ANY WARRANTY; without even the implied&n; *                 ************************&n; * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&n; * See the GNU General Public License for more details.&n; * &n; * You should have received a copy of the GNU General Public License&n; * along with GNU CC; see the file COPYING.  If not, write to&n; * the Free Software Foundation, 59 Temple Place - Suite 330,&n; * Boston, MA 02111-1307, USA.  &n; * &n; * Please send any bug reports or fixes you make to the&n; * email address(es):&n; *    lksctp developers &lt;lksctp-developers@lists.sourceforge.net&gt;&n; * &n; * Or submit a bug report through the following website:&n; *    http://www.sf.net/projects/lksctp&n; *&n; * Written or modified by: &n; *    La Monte H.P. Yarroll &lt;piggy@acm.org&gt;&n; *    Karl Knutson          &lt;karl@athena.chicago.il.us&gt;&n; *    Mathew Kotowsky       &lt;kotowsky@sctp.org&gt;&n; *    Sridhar Samudrala     &lt;samudrala@us.ibm.com&gt;&n; *    Jon Grimm             &lt;jgrimm@us.ibm.com&gt;&n; *    Hui Huang &t;    &lt;hui.huang@nokia.com&gt;&n; *    Dajiang Zhang &t;    &lt;dajiang.zhang@nokia.com&gt;&n; *    Daisy Chang&t;    &lt;daisyc@us.ibm.com&gt;&n; *&n; * Any bugs reported given to us we will try to fix... any fixes shared will&n; * be incorporated into the next SCTP release.&n; */
DECL|variable|cvs_id
r_static
r_char
op_star
id|cvs_id
id|__attribute__
(paren
(paren
id|unused
)paren
)paren
op_assign
l_string|&quot;$Id: sctp_sm_statefuns.c,v 1.48 2002/08/16 19:30:50 jgrimm Exp $&quot;
suffix:semicolon
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/ip.h&gt;
macro_line|#include &lt;linux/ipv6.h&gt;
macro_line|#include &lt;linux/net.h&gt;
macro_line|#include &lt;linux/inet.h&gt;
macro_line|#include &lt;net/sock.h&gt;
macro_line|#ifndef CONFIG_INET_ECN
DECL|macro|CONFIG_INET_ECN
mdefine_line|#define CONFIG_INET_ECN
macro_line|#endif /* CONFIG_INET_ECN */
macro_line|#include &lt;net/inet_ecn.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;net/sctp/sctp.h&gt;
macro_line|#include &lt;net/sctp/sctp_sm.h&gt;
macro_line|#include &lt;net/sctp/sctp_structs.h&gt;
multiline_comment|/**********************************************************&n; * These are the state functions for handling chunk events.&n; **********************************************************/
multiline_comment|/*&n; * Process the final SHUTDOWN COMPLETE.&n; * &n; * Section: 4 (C) (diagram), 9.2&n; * Upon reception of the SHUTDOWN COMPLETE chunk the endpoint will verify&n; * that it is in SHUTDOWN-ACK-SENT state, if it is not the chunk should be&n; * discarded. If the endpoint is in the SHUTDOWN-ACK-SENT state the endpoint&n; * should stop the T2-shutdown timer and remove all knowledge of the&n; * association (and thus the association enters the CLOSED state).&n; *&n; * Verification Tag: 8.5.1(C)&n; * C) Rules for packet carrying SHUTDOWN COMPLETE:&n; * ...&n; * - The receiver of a SHUTDOWN COMPLETE shall accept the packet if the&n; *   Verification Tag field of the packet matches its own tag OR it is&n; *   set to its peer&squot;s tag and the T bit is set in the Chunk Flags. &n; *   Otherwise, the receiver MUST silently discard the packet and take &n; *   no further action. An endpoint MUST ignore the SHUTDOWN COMPLETE if &n; *   it is not in the SHUTDOWN-ACK-SENT state. &n; *&n; * Inputs&n; * (endpoint, asoc, chunk)&n; * &n; * Outputs&n; * (asoc, reply_msg, msg_up, timers, counters)&n; *&n; * The return value is the disposition of the chunk.&n; */
id|sctp_disposition_t
DECL|function|sctp_sf_do_4_C
id|sctp_sf_do_4_C
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
r_const
id|sctp_subtype_t
id|type
comma
r_void
op_star
id|arg
comma
id|sctp_cmd_seq_t
op_star
id|commands
)paren
(brace
id|sctp_chunk_t
op_star
id|chunk
op_assign
id|arg
suffix:semicolon
id|sctp_ulpevent_t
op_star
id|ev
suffix:semicolon
multiline_comment|/* RFC 2960 6.10 Bundling&n;&t; *&n;&t; * An endpoint MUST NOT bundle INIT, INIT ACK or&n;&t; * SHUTDOWN COMPLETE with any other chunks.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|chunk-&gt;singleton
)paren
(brace
r_return
id|SCTP_DISPOSITION_VIOLATION
suffix:semicolon
)brace
multiline_comment|/* RFC 2960 8.5.1 Exceptions in Verification Tag Rules&n;&t; * &n;&t; * (C) The receiver of a SHUTDOWN COMPLETE shall accept the&n;&t; * packet if the Verification Tag field of the packet&n;&t; * matches its own tag OR it is set to its peer&squot;s tag and&n;&t; * the T bit is set in the Chunk Flags.  Otherwise, the &n;&t; * receiver MUST silently discard the packet and take no &n;&t; * further action....&n;&t; */
r_if
c_cond
(paren
(paren
id|ntohl
c_func
(paren
id|chunk-&gt;sctp_hdr-&gt;vtag
)paren
op_ne
id|asoc-&gt;c.my_vtag
)paren
op_logical_and
op_logical_neg
(paren
id|sctp_test_T_bit
c_func
(paren
id|chunk
)paren
op_logical_or
(paren
id|ntohl
c_func
(paren
id|chunk-&gt;sctp_hdr-&gt;vtag
)paren
op_ne
id|asoc-&gt;peer.i.init_tag
)paren
)paren
)paren
(brace
r_return
id|sctp_sf_pdiscard
c_func
(paren
id|ep
comma
id|asoc
comma
id|type
comma
id|arg
comma
id|commands
)paren
suffix:semicolon
)brace
multiline_comment|/* RFC 2960 10.2 SCTP-to-ULP&n;&t; *&n;&t; * H) SHUTDOWN COMPLETE notification&n;         * &n;         * When SCTP completes the shutdown procedures (section 9.2) this&n;         * notification is passed to the upper layer.&n;         */
id|ev
op_assign
id|sctp_ulpevent_make_assoc_change
c_func
(paren
id|asoc
comma
l_int|0
comma
id|SCTP_SHUTDOWN_COMP
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ev
)paren
(brace
r_goto
id|nomem
suffix:semicolon
)brace
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_EVENT_ULP
comma
id|SCTP_ULPEVENT
c_func
(paren
id|ev
)paren
)paren
suffix:semicolon
multiline_comment|/* Upon reception of the SHUTDOWN COMPLETE chunk the endpoint&n;         * will verify that it is in SHUTDOWN-ACK-SENT state, if it is&n;         * not the chunk should be discarded. If the endpoint is in&n;         * the SHUTDOWN-ACK-SENT state the endpoint should stop the&n;         * T2-shutdown timer and remove all knowledge of the&n;         * association (and thus the association enters the CLOSED&n;         * state).&n;         */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_TIMER_STOP
comma
id|SCTP_TO
c_func
(paren
id|SCTP_EVENT_TIMEOUT_T2_SHUTDOWN
)paren
)paren
suffix:semicolon
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_NEW_STATE
comma
id|SCTP_STATE
c_func
(paren
id|SCTP_STATE_CLOSED
)paren
)paren
suffix:semicolon
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_DELETE_TCB
comma
id|SCTP_NULL
c_func
(paren
)paren
)paren
suffix:semicolon
r_return
id|SCTP_DISPOSITION_DELETE_TCB
suffix:semicolon
id|nomem
suffix:colon
r_return
id|SCTP_DISPOSITION_NOMEM
suffix:semicolon
)brace
multiline_comment|/* sctp_sf_do_4_C() */
multiline_comment|/*&n; * Discard the whole packet.&n; * &n; * Section: 8.4 2)&n; *&n; * 2) If the OOTB packet contains an ABORT chunk, the receiver MUST &n; *    silently discard the OOTB packet and take no further action. &n; *    Otherwise,&n; *&n; * Verification Tag: No verification necessary&n; *&n; * Inputs&n; * (endpoint, asoc, chunk)&n; * &n; * Outputs&n; * (asoc, reply_msg, msg_up, timers, counters)&n; *&n; * The return value is the disposition of the chunk.&n; */
id|sctp_disposition_t
DECL|function|sctp_sf_pdiscard
id|sctp_sf_pdiscard
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
r_const
id|sctp_subtype_t
id|type
comma
r_void
op_star
id|arg
comma
id|sctp_cmd_seq_t
op_star
id|commands
)paren
(brace
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_DISCARD_PACKET
comma
id|SCTP_NULL
c_func
(paren
)paren
)paren
suffix:semicolon
r_return
id|SCTP_DISPOSITION_CONSUME
suffix:semicolon
)brace
multiline_comment|/* sctp_sf_pdiscard() */
multiline_comment|/*&n; * Respond to a normal INIT chunk.&n; * We are the side that is being asked for an association.&n; * &n; * Section: 5.1 Normal Establishment of an Association, B&n; * B) &quot;Z&quot; shall respond immediately with an INIT ACK chunk.  The &n; *    destination IP address of the INIT ACK MUST be set to the source &n; *    IP address of the INIT to which this INIT ACK is responding.  In &n; *    the response, besides filling in other parameters, &quot;Z&quot; must set the&n; *    Verification Tag field to Tag_A, and also provide its own &n; *    Verification Tag (Tag_Z) in the Initiate Tag field. &n; *&n; * Verification Tag: No checking.&n; *&n; * Inputs&n; * (endpoint, asoc, chunk)&n; * &n; * Outputs&n; * (asoc, reply_msg, msg_up, timers, counters)&n; *&n; * The return value is the disposition of the chunk.&n; */
id|sctp_disposition_t
DECL|function|sctp_sf_do_5_1B_init
id|sctp_sf_do_5_1B_init
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
r_const
id|sctp_subtype_t
id|type
comma
r_void
op_star
id|arg
comma
id|sctp_cmd_seq_t
op_star
id|commands
)paren
(brace
id|sctp_chunk_t
op_star
id|chunk
op_assign
id|arg
suffix:semicolon
id|sctp_chunk_t
op_star
id|repl
suffix:semicolon
id|sctp_association_t
op_star
id|new_asoc
suffix:semicolon
multiline_comment|/* If the packet is an OOTB packet which is temporarily on the&n;&t; * control endpoint, responding with an ABORT.&n;&t; */
r_if
c_cond
(paren
id|ep
op_eq
id|sctp_sk
c_func
(paren
(paren
id|sctp_get_ctl_sock
c_func
(paren
)paren
)paren
)paren
op_member_access_from_pointer
id|ep
)paren
(brace
r_return
id|sctp_sf_ootb
c_func
(paren
id|ep
comma
id|asoc
comma
id|type
comma
id|arg
comma
id|commands
)paren
suffix:semicolon
)brace
multiline_comment|/* 6.10 Bundling&n;&t; * An endpoint MUST NOT bundle INIT, INIT ACK or&n;&t; * SHUTDOWN COMPLETE with any other chunks.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|chunk-&gt;singleton
)paren
(brace
r_return
id|SCTP_DISPOSITION_VIOLATION
suffix:semicolon
)brace
multiline_comment|/* Grab the INIT header.  */
id|chunk-&gt;subh.init_hdr
op_assign
(paren
id|sctp_inithdr_t
op_star
)paren
id|chunk-&gt;skb-&gt;data
suffix:semicolon
multiline_comment|/* Tag the variable length parameters.  */
id|chunk-&gt;param_hdr.v
op_assign
id|skb_pull
c_func
(paren
id|chunk-&gt;skb
comma
r_sizeof
(paren
id|sctp_inithdr_t
)paren
)paren
suffix:semicolon
id|new_asoc
op_assign
id|sctp_make_temp_asoc
c_func
(paren
id|ep
comma
id|chunk
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|NULL
op_eq
id|new_asoc
)paren
(brace
r_goto
id|nomem
suffix:semicolon
)brace
multiline_comment|/* FIXME: sctp_process_init can fail, but there is no &n;&t; * status nor handling. &n;&t; */
id|sctp_process_init
c_func
(paren
id|new_asoc
comma
id|chunk-&gt;chunk_hdr-&gt;type
comma
id|sctp_source
c_func
(paren
id|chunk
)paren
comma
(paren
id|sctp_init_chunk_t
op_star
)paren
id|chunk-&gt;chunk_hdr
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_NEW_ASOC
comma
id|SCTP_ASOC
c_func
(paren
id|new_asoc
)paren
)paren
suffix:semicolon
multiline_comment|/* B) &quot;Z&quot; shall respond immediately with an INIT ACK chunk. &n;&t; */
id|repl
op_assign
id|sctp_make_init_ack
c_func
(paren
id|new_asoc
comma
id|chunk
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|repl
)paren
(brace
r_goto
id|nomem_ack
suffix:semicolon
)brace
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_REPLY
comma
id|SCTP_CHUNK
c_func
(paren
id|repl
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;         * Note: After sending out INIT ACK with the State Cookie parameter,&n;&t; * &quot;Z&quot; MUST NOT allocate any resources, nor keep any states for the&n;&t; * new association.  Otherwise, &quot;Z&quot; will be vulnerable to resource&n;&t; * attacks.&n;&t; */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_DELETE_TCB
comma
id|SCTP_NULL
c_func
(paren
)paren
)paren
suffix:semicolon
r_return
id|SCTP_DISPOSITION_DELETE_TCB
suffix:semicolon
id|nomem_ack
suffix:colon
id|sctp_association_free
c_func
(paren
id|new_asoc
)paren
suffix:semicolon
id|nomem
suffix:colon
r_return
id|SCTP_DISPOSITION_NOMEM
suffix:semicolon
)brace
multiline_comment|/* sctp_sf_do_5_1B_init() */
multiline_comment|/*&n; * Respond to a normal INIT ACK chunk.&n; * We are the side that is initiating the association.&n; * &n; * Section: 5.1 Normal Establishment of an Association, C&n; * C) Upon reception of the INIT ACK from &quot;Z&quot;, &quot;A&quot; shall stop the T1-init&n; *    timer and leave COOKIE-WAIT state. &quot;A&quot; shall then send the State &n; *    Cookie received in the INIT ACK chunk in a COOKIE ECHO chunk, start &n; *    the T1-cookie timer, and enter the COOKIE-ECHOED state.&n; * &n; *    Note: The COOKIE ECHO chunk can be bundled with any pending outbound&n; *    DATA chunks, but it MUST be the first chunk in the packet and&n; *    until the COOKIE ACK is returned the sender MUST NOT send any&n; *    other packets to the peer.&n; * &n; * Verification Tag: 3.3.3&n; *   If the value of the Initiate Tag in a received INIT ACK chunk is &n; *   found to be 0, the receiver MUST treat it as an error and close the&n; *   association by transmitting an ABORT.&n; *&n; * Inputs&n; * (endpoint, asoc, chunk)&n; * &n; * Outputs&n; * (asoc, reply_msg, msg_up, timers, counters)&n; *&n; * The return value is the disposition of the chunk.&n; */
id|sctp_disposition_t
DECL|function|sctp_sf_do_5_1C_ack
id|sctp_sf_do_5_1C_ack
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
r_const
id|sctp_subtype_t
id|type
comma
r_void
op_star
id|arg
comma
id|sctp_cmd_seq_t
op_star
id|commands
)paren
(brace
id|sctp_chunk_t
op_star
id|chunk
op_assign
id|arg
suffix:semicolon
id|sctp_init_chunk_t
op_star
id|initchunk
suffix:semicolon
r_uint32
id|init_tag
suffix:semicolon
multiline_comment|/* 6.10 Bundling&n;&t; * An endpoint MUST NOT bundle INIT, INIT ACK or&n;&t; * SHUTDOWN COMPLETE with any other chunks.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|chunk-&gt;singleton
)paren
(brace
r_return
id|SCTP_DISPOSITION_VIOLATION
suffix:semicolon
)brace
multiline_comment|/* Grab the INIT header.  &n;&t; */
id|chunk-&gt;subh.init_hdr
op_assign
(paren
id|sctp_inithdr_t
op_star
)paren
id|chunk-&gt;skb-&gt;data
suffix:semicolon
id|init_tag
op_assign
id|ntohl
c_func
(paren
id|chunk-&gt;subh.init_hdr-&gt;init_tag
)paren
suffix:semicolon
multiline_comment|/* Verification Tag: 3.3.3&n;         *   If the value of the Initiate Tag in a received INIT ACK&n;         *   chunk is found to be 0, the receiver MUST treat it as an&n;         *   error and close the association by transmitting an ABORT.&n;         */
r_if
c_cond
(paren
l_int|0
op_eq
id|init_tag
)paren
(brace
id|sctp_chunk_t
op_star
id|reply
suffix:semicolon
id|reply
op_assign
id|sctp_make_abort
c_func
(paren
id|asoc
comma
id|chunk
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|reply
)paren
(brace
r_goto
id|nomem
suffix:semicolon
)brace
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_REPLY
comma
id|SCTP_CHUNK
c_func
(paren
id|reply
)paren
)paren
suffix:semicolon
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_NEW_STATE
comma
id|SCTP_STATE
c_func
(paren
id|SCTP_STATE_CLOSED
)paren
)paren
suffix:semicolon
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_DELETE_TCB
comma
id|SCTP_NULL
c_func
(paren
)paren
)paren
suffix:semicolon
r_return
id|SCTP_DISPOSITION_DELETE_TCB
suffix:semicolon
)brace
multiline_comment|/* Tag the variable length paramters.  Note that we never&n;&t; * convert the parameters in an INIT chunk.&n;&t; */
id|chunk-&gt;param_hdr.v
op_assign
id|skb_pull
c_func
(paren
id|chunk-&gt;skb
comma
r_sizeof
(paren
id|sctp_inithdr_t
)paren
)paren
suffix:semicolon
id|initchunk
op_assign
(paren
id|sctp_init_chunk_t
op_star
)paren
id|chunk-&gt;chunk_hdr
suffix:semicolon
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_PEER_INIT
comma
id|SCTP_PEER_INIT
c_func
(paren
id|initchunk
)paren
)paren
suffix:semicolon
multiline_comment|/* 5.1 C) &quot;A&quot; shall stop the T1-init timer and leave&n;         * COOKIE-WAIT state.  &quot;A&quot; shall then ... start the T1-cookie&n;         * timer, and enter the COOKIE-ECHOED state.&n;         */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_TIMER_STOP
comma
id|SCTP_TO
c_func
(paren
id|SCTP_EVENT_TIMEOUT_T1_INIT
)paren
)paren
suffix:semicolon
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_COUNTER_RESET
comma
id|SCTP_COUNTER
c_func
(paren
id|SCTP_COUNTER_INIT_ERROR
)paren
)paren
suffix:semicolon
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_TIMER_START
comma
id|SCTP_TO
c_func
(paren
id|SCTP_EVENT_TIMEOUT_T1_COOKIE
)paren
)paren
suffix:semicolon
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_NEW_STATE
comma
id|SCTP_STATE
c_func
(paren
id|SCTP_STATE_COOKIE_ECHOED
)paren
)paren
suffix:semicolon
multiline_comment|/* 5.1 C) &quot;A&quot; shall then send the State Cookie received in the&n;         * INIT ACK chunk in a COOKIE ECHO chunk, ...&n;         */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_GEN_COOKIE_ECHO
comma
id|SCTP_NULL
c_func
(paren
)paren
)paren
suffix:semicolon
r_return
id|SCTP_DISPOSITION_CONSUME
suffix:semicolon
id|nomem
suffix:colon
r_return
id|SCTP_DISPOSITION_NOMEM
suffix:semicolon
)brace
multiline_comment|/* sctp_sf_do_5_1C_ack() */
multiline_comment|/*&n; * Respond to a normal COOKIE ECHO chunk.&n; * We are the side that is being asked for an association.&n; * &n; * Section: 5.1 Normal Establishment of an Association, D&n; * D) Upon reception of the COOKIE ECHO chunk, Endpoint &quot;Z&quot; will reply &n; *    with a COOKIE ACK chunk after building a TCB and moving to&n; *    the ESTABLISHED state. A COOKIE ACK chunk may be bundled with&n; *    any pending DATA chunks (and/or SACK chunks), but the COOKIE ACK&n; *    chunk MUST be the first chunk in the packet.&n; * &n; *   IMPLEMENTATION NOTE: An implementation may choose to send the&n; *   Communication Up notification to the SCTP user upon reception&n; *   of a valid COOKIE ECHO chunk.&n; * &n; * Verification Tag: 8.5.1 Exceptions in Verification Tag Rules&n; * D) Rules for packet carrying a COOKIE ECHO&n; * &n; * - When sending a COOKIE ECHO, the endpoint MUST use the value of the&n; *   Initial Tag received in the INIT ACK.&n; * &n; * - The receiver of a COOKIE ECHO follows the procedures in Section 5.&n; * &n; * Inputs&n; * (endpoint, asoc, chunk)&n; * &n; * Outputs&n; * (asoc, reply_msg, msg_up, timers, counters)&n; *&n; * The return value is the disposition of the chunk.&n; */
id|sctp_disposition_t
DECL|function|sctp_sf_do_5_1D_ce
id|sctp_sf_do_5_1D_ce
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
r_const
id|sctp_subtype_t
id|type
comma
r_void
op_star
id|arg
comma
id|sctp_cmd_seq_t
op_star
id|commands
)paren
(brace
id|sctp_chunk_t
op_star
id|chunk
op_assign
id|arg
suffix:semicolon
id|sctp_association_t
op_star
id|new_asoc
suffix:semicolon
id|sctp_init_chunk_t
op_star
id|peer_init
suffix:semicolon
id|sctp_chunk_t
op_star
id|repl
suffix:semicolon
id|sctp_ulpevent_t
op_star
id|ev
suffix:semicolon
r_int
id|error
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* If the packet is an OOTB packet which is temporarily on the&n;&t; * control endpoint, responding with an ABORT.&n;&t; */
r_if
c_cond
(paren
id|ep
op_eq
id|sctp_sk
c_func
(paren
(paren
id|sctp_get_ctl_sock
c_func
(paren
)paren
)paren
)paren
op_member_access_from_pointer
id|ep
)paren
(brace
r_return
id|sctp_sf_ootb
c_func
(paren
id|ep
comma
id|asoc
comma
id|type
comma
id|arg
comma
id|commands
)paren
suffix:semicolon
)brace
multiline_comment|/* &quot;Decode&quot; the chunk.  We have no optional parameters so we&n;         * are in good shape.&n;         */
id|chunk-&gt;subh.cookie_hdr
op_assign
(paren
id|sctp_signed_cookie_t
op_star
)paren
id|chunk-&gt;skb-&gt;data
suffix:semicolon
id|skb_pull
c_func
(paren
id|chunk-&gt;skb
comma
id|ntohs
c_func
(paren
id|chunk-&gt;chunk_hdr-&gt;length
)paren
op_minus
r_sizeof
(paren
id|sctp_chunkhdr_t
)paren
)paren
suffix:semicolon
multiline_comment|/* 5.1 D) Upon reception of the COOKIE ECHO chunk, Endpoint&n;         * &quot;Z&quot; will reply with a COOKIE ACK chunk after building a TCB&n;         * and moving to the ESTABLISHED state.&n;         */
id|new_asoc
op_assign
id|sctp_unpack_cookie
c_func
(paren
id|ep
comma
id|asoc
comma
id|chunk
comma
id|GFP_ATOMIC
comma
op_amp
id|error
)paren
suffix:semicolon
multiline_comment|/* FIXME:  &n;&t; * If the re-build failed, what is the proper error path&n;&t; * from here?&n;&t; *&n;&t; * [We should abort the association. --piggy]&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|new_asoc
)paren
(brace
multiline_comment|/* FIXME: Several errors are possible.  A bad cookie should&n;&t;&t; * be silently discarded, but think about logging it too.&n;&t;&t; */
r_switch
c_cond
(paren
id|error
)paren
(brace
r_case
op_minus
id|SCTP_IERROR_NOMEM
suffix:colon
r_goto
id|nomem
suffix:semicolon
r_case
op_minus
id|SCTP_IERROR_BAD_SIG
suffix:colon
r_default
suffix:colon
r_return
id|sctp_sf_pdiscard
c_func
(paren
id|ep
comma
id|asoc
comma
id|type
comma
id|arg
comma
id|commands
)paren
suffix:semicolon
)brace
)brace
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_NEW_ASOC
comma
id|SCTP_ASOC
c_func
(paren
id|new_asoc
)paren
)paren
suffix:semicolon
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_NEW_STATE
comma
id|SCTP_STATE
c_func
(paren
id|SCTP_STATE_ESTABLISHED
)paren
)paren
suffix:semicolon
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_HB_TIMERS_START
comma
id|SCTP_NULL
c_func
(paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|new_asoc-&gt;autoclose
)paren
(brace
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_TIMER_START
comma
id|SCTP_TO
c_func
(paren
id|SCTP_EVENT_TIMEOUT_AUTOCLOSE
)paren
)paren
suffix:semicolon
)brace
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_TRANSMIT
comma
id|SCTP_NULL
c_func
(paren
)paren
)paren
suffix:semicolon
multiline_comment|/* Re-build the bind address for the association is done in &n;&t; * the sctp_unpack_cookie() already. &n;&t; */
multiline_comment|/* This is a brand-new association, so these are not yet side&n;&t; * effects--it is safe to run them here.&n;&t; */
id|peer_init
op_assign
op_amp
id|chunk-&gt;subh.cookie_hdr-&gt;c.peer_init
(braket
l_int|0
)braket
suffix:semicolon
id|sctp_process_init
c_func
(paren
id|new_asoc
comma
id|chunk-&gt;chunk_hdr-&gt;type
comma
op_amp
id|chunk-&gt;subh.cookie_hdr-&gt;c.peer_addr
comma
id|peer_init
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
id|repl
op_assign
id|sctp_make_cookie_ack
c_func
(paren
id|new_asoc
comma
id|chunk
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|repl
)paren
(brace
r_goto
id|nomem_repl
suffix:semicolon
)brace
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_REPLY
comma
id|SCTP_CHUNK
c_func
(paren
id|repl
)paren
)paren
suffix:semicolon
multiline_comment|/* RFC 2960 5.1 Normal Establishment of an Association&n;&t; *&n;&t; * D) IMPLEMENTATION NOTE: An implementation may choose to&n;         * send the Communication Up notification to the SCTP user&n;         * upon reception of a valid COOKIE ECHO chunk.&n;&t; */
id|ev
op_assign
id|sctp_ulpevent_make_assoc_change
c_func
(paren
id|new_asoc
comma
l_int|0
comma
id|SCTP_COMM_UP
comma
l_int|0
comma
id|new_asoc-&gt;c.sinit_num_ostreams
comma
id|new_asoc-&gt;c.sinit_max_instreams
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ev
)paren
(brace
r_goto
id|nomem_ev
suffix:semicolon
)brace
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_EVENT_ULP
comma
id|SCTP_ULPEVENT
c_func
(paren
id|ev
)paren
)paren
suffix:semicolon
r_return
id|SCTP_DISPOSITION_CONSUME
suffix:semicolon
id|nomem_ev
suffix:colon
id|sctp_free_chunk
c_func
(paren
id|repl
)paren
suffix:semicolon
id|nomem_repl
suffix:colon
id|sctp_association_free
c_func
(paren
id|new_asoc
)paren
suffix:semicolon
id|nomem
suffix:colon
r_return
id|SCTP_DISPOSITION_NOMEM
suffix:semicolon
)brace
multiline_comment|/* sctp_sf_do_5_1D_ce() */
multiline_comment|/*&n; * Respond to a normal COOKIE ACK chunk.&n; * We are the side that is being asked for an association.&n; * &n; * RFC 2960 5.1 Normal Establishment of an Association&n; * &n; * E) Upon reception of the COOKIE ACK, endpoint &quot;A&quot; will move from the &n; *    COOKIE-ECHOED state to the ESTABLISHED state, stopping the T1-cookie&n; *    timer. It may also notify its ULP about the successful&n; *    establishment of the association with a Communication Up &n; *    notification (see Section 10). &n; * &n; * Verification Tag:&n; * Inputs&n; * (endpoint, asoc, chunk)&n; * &n; * Outputs&n; * (asoc, reply_msg, msg_up, timers, counters)&n; *&n; * The return value is the disposition of the chunk.&n; */
id|sctp_disposition_t
DECL|function|sctp_sf_do_5_1E_ca
id|sctp_sf_do_5_1E_ca
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
r_const
id|sctp_subtype_t
id|type
comma
r_void
op_star
id|arg
comma
id|sctp_cmd_seq_t
op_star
id|commands
)paren
(brace
id|sctp_ulpevent_t
op_star
id|ev
suffix:semicolon
multiline_comment|/* RFC 2960 5.1 Normal Establishment of an Association&n;&t; * &n;&t; * E) Upon reception of the COOKIE ACK, endpoint &quot;A&quot; will move&n;         * from the COOKIE-ECHOED state to the ESTABLISHED state,&n;         * stopping the T1-cookie timer.&n;&t; */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_TIMER_STOP
comma
id|SCTP_TO
c_func
(paren
id|SCTP_EVENT_TIMEOUT_T1_COOKIE
)paren
)paren
suffix:semicolon
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_NEW_STATE
comma
id|SCTP_STATE
c_func
(paren
id|SCTP_STATE_ESTABLISHED
)paren
)paren
suffix:semicolon
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_HB_TIMERS_START
comma
id|SCTP_NULL
c_func
(paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|asoc-&gt;autoclose
)paren
(brace
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_TIMER_START
comma
id|SCTP_TO
c_func
(paren
id|SCTP_EVENT_TIMEOUT_AUTOCLOSE
)paren
)paren
suffix:semicolon
)brace
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_TRANSMIT
comma
id|SCTP_NULL
c_func
(paren
)paren
)paren
suffix:semicolon
multiline_comment|/* It may also notify its ULP about the successful&n;         * establishment of the association with a Communication Up&n;         * notification (see Section 10).&n;         */
id|ev
op_assign
id|sctp_ulpevent_make_assoc_change
c_func
(paren
id|asoc
comma
l_int|0
comma
id|SCTP_COMM_UP
comma
l_int|0
comma
id|asoc-&gt;c.sinit_num_ostreams
comma
id|asoc-&gt;c.sinit_max_instreams
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ev
)paren
(brace
r_goto
id|nomem
suffix:semicolon
)brace
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_EVENT_ULP
comma
id|SCTP_ULPEVENT
c_func
(paren
id|ev
)paren
)paren
suffix:semicolon
r_return
id|SCTP_DISPOSITION_CONSUME
suffix:semicolon
id|nomem
suffix:colon
r_return
id|SCTP_DISPOSITION_NOMEM
suffix:semicolon
)brace
multiline_comment|/* sctp_sf_do_5_1E_ca() */
multiline_comment|/* Generate a HEARTBEAT packet on the given transport.  */
id|sctp_disposition_t
DECL|function|sctp_sf_sendbeat_8_3
id|sctp_sf_sendbeat_8_3
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
r_const
id|sctp_subtype_t
id|type
comma
r_void
op_star
id|arg
comma
id|sctp_cmd_seq_t
op_star
id|commands
)paren
(brace
id|sctp_transport_t
op_star
id|transport
op_assign
(paren
id|sctp_transport_t
op_star
)paren
id|arg
suffix:semicolon
id|sctp_chunk_t
op_star
id|reply
suffix:semicolon
id|sctp_sender_hb_info_t
id|hbinfo
suffix:semicolon
r_int
id|paylen
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|asoc-&gt;overall_error_count
op_ge
id|asoc-&gt;overall_error_threshold
)paren
(brace
multiline_comment|/* CMD_ASSOC_FAILED calls CMD_DELETE_TCB. */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_ASSOC_FAILED
comma
id|SCTP_NULL
c_func
(paren
)paren
)paren
suffix:semicolon
r_return
id|SCTP_DISPOSITION_DELETE_TCB
suffix:semicolon
)brace
multiline_comment|/* Section 3.3.5. &n;&t; * The Sender-specific Heartbeat Info field should normally include&n;&t; * information about the sender&squot;s current time when this HEARTBEAT&n;&t; * chunk is sent and the destination transport address to which this&n;&t; * HEARTBEAT is sent (see Section 8.3).&n;&t; */
id|hbinfo.param_hdr.type
op_assign
id|SCTP_PARAM_HEATBEAT_INFO
suffix:semicolon
id|hbinfo.param_hdr.length
op_assign
id|htons
c_func
(paren
r_sizeof
(paren
id|sctp_sender_hb_info_t
)paren
)paren
suffix:semicolon
id|hbinfo.daddr
op_assign
id|transport-&gt;ipaddr
suffix:semicolon
id|hbinfo.sent_at
op_assign
id|jiffies
suffix:semicolon
multiline_comment|/* Set rto_pending indicating that an RTT measurement is started&n;&t; * with this heartbeat chunk.&n;&t; */
id|transport-&gt;rto_pending
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Send a heartbeat to our peer. */
id|paylen
op_assign
r_sizeof
(paren
id|sctp_sender_hb_info_t
)paren
suffix:semicolon
id|reply
op_assign
id|sctp_make_heartbeat
c_func
(paren
id|asoc
comma
id|transport
comma
op_amp
id|hbinfo
comma
id|paylen
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|NULL
op_eq
id|reply
)paren
(brace
r_goto
id|nomem
suffix:semicolon
)brace
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_REPLY
comma
id|SCTP_CHUNK
c_func
(paren
id|reply
)paren
)paren
suffix:semicolon
multiline_comment|/* Set transport error counter and association error counter&n;         * when sending heartbeat.&n;&t; */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_TRANSPORT_RESET
comma
id|SCTP_TRANSPORT
c_func
(paren
id|transport
)paren
)paren
suffix:semicolon
r_return
id|SCTP_DISPOSITION_CONSUME
suffix:semicolon
id|nomem
suffix:colon
r_return
id|SCTP_DISPOSITION_NOMEM
suffix:semicolon
)brace
multiline_comment|/* sctp_sf_sendbeat_8_3() */
multiline_comment|/*&n; * Process an heartbeat request.&n; * &n; * Section: 8.3 Path Heartbeat&n; * The receiver of the HEARTBEAT should immediately respond with a&n; * HEARTBEAT ACK that contains the Heartbeat Information field copied &n; * from the received HEARTBEAT chunk.&n; * &n; * Verification Tag:  8.5 Verification Tag [Normal verification]&n; * When receiving an SCTP packet, the endpoint MUST ensure that the&n; * value in the Verification Tag field of the received SCTP packet&n; * matches its own Tag. If the received Verification Tag value does not&n; * match the receiver&squot;s own tag value, the receiver shall silently&n; * discard the packet and shall not process it any further except for &n; * those cases listed in Section 8.5.1 below.&n; * &n; * Inputs&n; * (endpoint, asoc, chunk)&n; * &n; * Outputs&n; * (asoc, reply_msg, msg_up, timers, counters)&n; *&n; * The return value is the disposition of the chunk.&n; */
id|sctp_disposition_t
DECL|function|sctp_sf_beat_8_3
id|sctp_sf_beat_8_3
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
r_const
id|sctp_subtype_t
id|type
comma
r_void
op_star
id|arg
comma
id|sctp_cmd_seq_t
op_star
id|commands
)paren
(brace
id|sctp_chunk_t
op_star
id|chunk
op_assign
id|arg
suffix:semicolon
id|sctp_chunk_t
op_star
id|reply
suffix:semicolon
r_int
id|paylen
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* 8.5 When receiving an SCTP packet, the endpoint MUST ensure&n;         * that the value in the Verification Tag field of the&n;         * received SCTP packet matches its own Tag. If the received&n;         * Verification Tag value does not match the receiver&squot;s own&n;         * tag value, the receiver shall silently discard the packet...&n;         */
r_if
c_cond
(paren
id|ntohl
c_func
(paren
id|chunk-&gt;sctp_hdr-&gt;vtag
)paren
op_ne
id|asoc-&gt;c.my_vtag
)paren
(brace
r_return
id|sctp_sf_pdiscard
c_func
(paren
id|ep
comma
id|asoc
comma
id|type
comma
id|arg
comma
id|commands
)paren
suffix:semicolon
)brace
multiline_comment|/* 8.3 The receiver of the HEARTBEAT should immediately&n;         * respond with a HEARTBEAT ACK that contains the Heartbeat&n;         * Information field copied from the received HEARTBEAT chunk.&n;         */
id|chunk-&gt;subh.hb_hdr
op_assign
(paren
id|sctp_heartbeathdr_t
op_star
)paren
id|chunk-&gt;skb-&gt;data
suffix:semicolon
id|paylen
op_assign
id|ntohs
c_func
(paren
id|chunk-&gt;chunk_hdr-&gt;length
)paren
op_minus
r_sizeof
(paren
id|sctp_chunkhdr_t
)paren
suffix:semicolon
id|skb_pull
c_func
(paren
id|chunk-&gt;skb
comma
id|paylen
)paren
suffix:semicolon
id|reply
op_assign
id|sctp_make_heartbeat_ack
c_func
(paren
id|asoc
comma
id|chunk
comma
id|chunk-&gt;subh.hb_hdr
comma
id|paylen
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|NULL
op_eq
id|reply
)paren
(brace
r_goto
id|nomem
suffix:semicolon
)brace
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_REPLY
comma
id|SCTP_CHUNK
c_func
(paren
id|reply
)paren
)paren
suffix:semicolon
r_return
id|SCTP_DISPOSITION_CONSUME
suffix:semicolon
id|nomem
suffix:colon
r_return
id|SCTP_DISPOSITION_NOMEM
suffix:semicolon
)brace
multiline_comment|/* sctp_sf_beat_8_3() */
multiline_comment|/*&n; * Process the returning HEARTBEAT ACK.&n; * &n; * Section: 8.3 Path Heartbeat&n; * Upon the receipt of the HEARTBEAT ACK, the sender of the HEARTBEAT&n; * should clear the error counter of the destination transport&n; * address to which the HEARTBEAT was sent, and mark the destination&n; * transport address as active if it is not so marked. The endpoint may&n; * optionally report to the upper layer when an inactive destination&n; * address is marked as active due to the reception of the latest&n; * HEARTBEAT ACK. The receiver of the HEARTBEAT ACK must also&n; * clear the association overall error count as well (as defined&n; * in section 8.1).&n; * &n; * The receiver of the HEARTBEAT ACK should also perform an RTT&n; * measurement for that destination transport address using the time&n; * value carried in the HEARTBEAT ACK chunk.&n; * &n; * Verification Tag:  8.5 Verification Tag [Normal verification]&n; *&n; * Inputs&n; * (endpoint, asoc, chunk)&n; * &n; * Outputs&n; * (asoc, reply_msg, msg_up, timers, counters)&n; *&n; * The return value is the disposition of the chunk.&n; */
id|sctp_disposition_t
DECL|function|sctp_sf_backbeat_8_3
id|sctp_sf_backbeat_8_3
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
r_const
id|sctp_subtype_t
id|type
comma
r_void
op_star
id|arg
comma
id|sctp_cmd_seq_t
op_star
id|commands
)paren
(brace
id|sctp_chunk_t
op_star
id|chunk
op_assign
id|arg
suffix:semicolon
id|sockaddr_storage_t
id|from_addr
suffix:semicolon
id|sctp_transport_t
op_star
id|link
suffix:semicolon
id|sctp_sender_hb_info_t
op_star
id|hbinfo
suffix:semicolon
r_int
r_int
id|max_interval
suffix:semicolon
multiline_comment|/* 8.5 When receiving an SCTP packet, the endpoint MUST ensure&n;         * that the value in the Verification Tag field of the&n;         * received SCTP packet matches its own Tag. ...&n;         */
r_if
c_cond
(paren
id|ntohl
c_func
(paren
id|chunk-&gt;sctp_hdr-&gt;vtag
)paren
op_ne
id|asoc-&gt;c.my_vtag
)paren
(brace
r_return
id|sctp_sf_pdiscard
c_func
(paren
id|ep
comma
id|asoc
comma
id|type
comma
id|arg
comma
id|commands
)paren
suffix:semicolon
)brace
id|hbinfo
op_assign
(paren
id|sctp_sender_hb_info_t
op_star
)paren
id|chunk-&gt;skb-&gt;data
suffix:semicolon
id|from_addr
op_assign
id|hbinfo-&gt;daddr
suffix:semicolon
id|link
op_assign
id|sctp_assoc_lookup_paddr
c_func
(paren
id|asoc
comma
op_amp
id|from_addr
)paren
suffix:semicolon
multiline_comment|/* This should never happen, but lets log it if so. */
r_if
c_cond
(paren
op_logical_neg
id|link
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
id|__FUNCTION__
l_string|&quot;: Could not find address %d.%d.%d.%d&bslash;n&quot;
comma
id|NIPQUAD
c_func
(paren
id|from_addr.v4.sin_addr
)paren
)paren
suffix:semicolon
r_return
id|SCTP_DISPOSITION_DISCARD
suffix:semicolon
)brace
id|max_interval
op_assign
id|link-&gt;hb_interval
op_plus
id|link-&gt;rto
suffix:semicolon
multiline_comment|/* Check if the timestamp looks valid.  */
r_if
c_cond
(paren
id|time_after
c_func
(paren
id|hbinfo-&gt;sent_at
comma
id|jiffies
)paren
op_logical_or
id|time_after
c_func
(paren
id|jiffies
comma
id|hbinfo-&gt;sent_at
op_plus
id|max_interval
)paren
)paren
(brace
id|SCTP_DEBUG_PRINTK
c_func
(paren
"&quot;"
op_mod
id|s
suffix:colon
id|HEARTBEAT
id|ACK
id|with
id|invalid
id|timestamp
id|received
r_for
id|transport
suffix:colon
op_mod
id|p
"&bslash;"
id|n
"&quot;"
comma
id|__FUNCTION__
comma
id|link
)paren
suffix:semicolon
r_return
id|SCTP_DISPOSITION_DISCARD
suffix:semicolon
)brace
multiline_comment|/* 8.3 Upon the receipt of the HEARTBEAT ACK, the sender of&n;         * the HEARTBEAT should clear the error counter of the&n;         * destination transport address to which the HEARTBEAT was&n;         * sent and mark the destination transport address as active if&n;         * it is not so marked.&n;         */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_TRANSPORT_ON
comma
id|SCTP_TRANSPORT
c_func
(paren
id|link
)paren
)paren
suffix:semicolon
r_return
id|SCTP_DISPOSITION_CONSUME
suffix:semicolon
id|nomem
suffix:colon
id|__attribute__
c_func
(paren
(paren
id|unused
)paren
)paren
r_return
id|SCTP_DISPOSITION_NOMEM
suffix:semicolon
)brace
multiline_comment|/* sctp_sf_backbeat_8_3() */
multiline_comment|/* Populate the verification/tie tags based on overlapping INIT&n; * scenario.  &n; *  &n; * Note: Do not use in CLOSED or SHUTDOWN-ACK-SENT state.&n; */
r_static
r_void
DECL|function|sctp_tietags_populate
id|sctp_tietags_populate
c_func
(paren
id|sctp_association_t
op_star
id|new_asoc
comma
r_const
id|sctp_association_t
op_star
id|asoc
)paren
(brace
r_switch
c_cond
(paren
id|asoc-&gt;state
)paren
(brace
multiline_comment|/* 5.2.1 INIT received in COOKIE-WAIT or COOKIE-ECHOED State */
r_case
id|SCTP_STATE_COOKIE_WAIT
suffix:colon
id|new_asoc-&gt;c.my_vtag
op_assign
id|asoc-&gt;c.my_vtag
suffix:semicolon
id|new_asoc-&gt;c.my_ttag
op_assign
id|asoc-&gt;c.my_vtag
suffix:semicolon
id|new_asoc-&gt;c.peer_ttag
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_STATE_COOKIE_ECHOED
suffix:colon
id|new_asoc-&gt;c.my_vtag
op_assign
id|asoc-&gt;c.my_vtag
suffix:semicolon
id|new_asoc-&gt;c.my_ttag
op_assign
id|asoc-&gt;c.my_vtag
suffix:semicolon
id|new_asoc-&gt;c.peer_ttag
op_assign
id|asoc-&gt;c.peer_vtag
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* 5.2.2 Unexpected INIT in States Other than CLOSED, COOKIE-ECHOED,&n;&t; *   COOKIE-WAIT and SHUTDOWN-ACK-SENT&n;&t; */
r_default
suffix:colon
id|new_asoc-&gt;c.my_ttag
op_assign
id|asoc-&gt;c.my_vtag
suffix:semicolon
id|new_asoc-&gt;c.peer_ttag
op_assign
id|asoc-&gt;c.peer_vtag
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Other parameters for the endpoint SHOULD be copied from the&n;         * existing parameters of the association (e.g. number of&n;         * outbound streams) into the INIT ACK and cookie.&n;         */
id|new_asoc-&gt;rwnd
op_assign
id|asoc-&gt;rwnd
suffix:semicolon
id|new_asoc-&gt;c.sinit_num_ostreams
op_assign
id|asoc-&gt;c.sinit_num_ostreams
suffix:semicolon
id|new_asoc-&gt;c.sinit_max_instreams
op_assign
id|asoc-&gt;c.sinit_max_instreams
suffix:semicolon
id|new_asoc-&gt;c.initial_tsn
op_assign
id|asoc-&gt;c.initial_tsn
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* sctp_tietags_populate() */
multiline_comment|/* &n; * Compare vtag/tietag values to determine unexpected COOKIE-ECHO&n; * handling action.&n; *&n; * RFC 2960 5.2.4 Handle a COOKIE ECHO when a TCB exists.&n; * &n; * Returns value representing action to be taken.   These action values &n; * correspond to Action/Description values in RFC 2960, Table 2. &n; */
r_static
r_char
DECL|function|sctp_tietags_compare
id|sctp_tietags_compare
c_func
(paren
id|sctp_association_t
op_star
id|new_asoc
comma
r_const
id|sctp_association_t
op_star
id|asoc
)paren
(brace
multiline_comment|/* In this case, the peer may have restarted.  */
r_if
c_cond
(paren
(paren
id|asoc-&gt;c.my_vtag
op_ne
id|new_asoc-&gt;c.my_vtag
)paren
op_logical_and
(paren
id|asoc-&gt;c.peer_vtag
op_ne
id|new_asoc-&gt;c.peer_vtag
)paren
op_logical_and
(paren
id|asoc-&gt;c.my_vtag
op_eq
id|new_asoc-&gt;c.my_ttag
)paren
op_logical_and
(paren
id|asoc-&gt;c.peer_vtag
op_eq
id|new_asoc-&gt;c.peer_ttag
)paren
)paren
(brace
r_return
l_char|&squot;A&squot;
suffix:semicolon
)brace
multiline_comment|/* Collision case D.&n;&t; * Note: Test case D first, otherwise it may be incorrectly&n;&t; * identified as second case of B if the value of the Tie_tag is&n;&t; * not filled into the state cookie.&n;&t; */
r_if
c_cond
(paren
(paren
id|asoc-&gt;c.my_vtag
op_eq
id|new_asoc-&gt;c.my_vtag
)paren
op_logical_and
(paren
id|asoc-&gt;c.peer_vtag
op_eq
id|new_asoc-&gt;c.peer_vtag
)paren
)paren
(brace
r_return
l_char|&squot;D&squot;
suffix:semicolon
)brace
multiline_comment|/* Collision case B. */
r_if
c_cond
(paren
(paren
id|asoc-&gt;c.my_vtag
op_eq
id|new_asoc-&gt;c.my_vtag
)paren
op_logical_and
(paren
(paren
id|asoc-&gt;c.peer_vtag
op_ne
id|new_asoc-&gt;c.peer_vtag
)paren
op_logical_or
(paren
op_logical_neg
id|new_asoc-&gt;c.my_ttag
op_logical_and
op_logical_neg
id|new_asoc-&gt;c.peer_ttag
)paren
)paren
)paren
(brace
r_return
l_char|&squot;B&squot;
suffix:semicolon
)brace
multiline_comment|/* Collision case C. */
r_if
c_cond
(paren
(paren
id|asoc-&gt;c.my_vtag
op_ne
id|new_asoc-&gt;c.my_vtag
)paren
op_logical_and
(paren
id|asoc-&gt;c.peer_vtag
op_eq
id|new_asoc-&gt;c.peer_vtag
)paren
op_logical_and
(paren
l_int|0
op_eq
id|new_asoc-&gt;c.my_ttag
)paren
op_logical_and
(paren
l_int|0
op_eq
id|new_asoc-&gt;c.peer_ttag
)paren
)paren
(brace
r_return
l_char|&squot;C&squot;
suffix:semicolon
)brace
r_return
l_char|&squot;E&squot;
suffix:semicolon
multiline_comment|/* No such case available. */
)brace
multiline_comment|/* sctp_tietags_compare() */
multiline_comment|/* Common helper routine for both duplicate and simulataneous INIT&n; * chunk handling.&n; */
r_static
id|sctp_disposition_t
DECL|function|sctp_sf_do_unexpected_init
id|sctp_sf_do_unexpected_init
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
r_const
id|sctp_subtype_t
id|type
comma
r_void
op_star
id|arg
comma
id|sctp_cmd_seq_t
op_star
id|commands
)paren
(brace
id|sctp_chunk_t
op_star
id|chunk
op_assign
id|arg
suffix:semicolon
id|sctp_chunk_t
op_star
id|repl
suffix:semicolon
id|sctp_association_t
op_star
id|new_asoc
suffix:semicolon
multiline_comment|/* 6.10 Bundling&n;&t; * An endpoint MUST NOT bundle INIT, INIT ACK or&n;&t; * SHUTDOWN COMPLETE with any other chunks.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|chunk-&gt;singleton
)paren
(brace
r_return
id|SCTP_DISPOSITION_VIOLATION
suffix:semicolon
)brace
multiline_comment|/* Grab the INIT header.  */
id|chunk-&gt;subh.init_hdr
op_assign
(paren
id|sctp_inithdr_t
op_star
)paren
id|chunk-&gt;skb-&gt;data
suffix:semicolon
multiline_comment|/* Tag the variable length parameters.  &n;&t; */
id|chunk-&gt;param_hdr.v
op_assign
id|skb_pull
c_func
(paren
id|chunk-&gt;skb
comma
r_sizeof
(paren
id|sctp_inithdr_t
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Other parameters for the endpoint SHOULD be copied from the&n;&t; * existing parameters of the association (e.g. number of&n;&t; * outbound streams) into the INIT ACK and cookie.&n;&t; * FIXME:  We are copying parameters from the endpoint not the &n;&t; * association. &n;&t; */
id|new_asoc
op_assign
id|sctp_make_temp_asoc
c_func
(paren
id|ep
comma
id|chunk
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|new_asoc
)paren
(brace
r_goto
id|nomem
suffix:semicolon
)brace
multiline_comment|/* In the outbound INIT ACK the endpoint MUST copy its current&n;         * Verification Tag and Peers Verification tag into a reserved&n;         * place (local tie-tag and per tie-tag) within the state cookie.&n;&t; */
id|sctp_process_init
c_func
(paren
id|new_asoc
comma
id|chunk-&gt;chunk_hdr-&gt;type
comma
id|sctp_source
c_func
(paren
id|chunk
)paren
comma
(paren
id|sctp_init_chunk_t
op_star
)paren
id|chunk-&gt;chunk_hdr
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
id|sctp_tietags_populate
c_func
(paren
id|new_asoc
comma
id|asoc
)paren
suffix:semicolon
multiline_comment|/* B) &quot;Z&quot; shall respond immediately with an INIT ACK chunk. &n;&t; */
id|repl
op_assign
id|sctp_make_init_ack
c_func
(paren
id|new_asoc
comma
id|chunk
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|repl
)paren
(brace
r_goto
id|nomem
suffix:semicolon
)brace
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_NEW_ASOC
comma
id|SCTP_ASOC
c_func
(paren
id|new_asoc
)paren
)paren
suffix:semicolon
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_REPLY
comma
id|SCTP_CHUNK
c_func
(paren
id|repl
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;         * Note: After sending out INIT ACK with the State Cookie parameter,&n;&t; * &quot;Z&quot; MUST NOT allocate any resources for this new association.&n;&t; * Otherwise, &quot;Z&quot; will be vulnerable to resource attacks.&n;&t; */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_DELETE_TCB
comma
id|SCTP_NULL
c_func
(paren
)paren
)paren
suffix:semicolon
r_return
id|SCTP_DISPOSITION_CONSUME
suffix:semicolon
id|nomem
suffix:colon
r_return
id|SCTP_DISPOSITION_NOMEM
suffix:semicolon
)brace
multiline_comment|/* sctp_sf_do_unexpected_init() */
multiline_comment|/*&n; * Handle simultanous INIT.&n; * This means we started an INIT and then we got an INIT request from&n; * our peer.&n; * &n; * Section: 5.2.1 INIT received in COOKIE-WAIT or COOKIE-ECHOED State (Item B)&n; * This usually indicates an initialization collision, i.e., each&n; * endpoint is attempting, at about the same time, to establish an&n; * association with the other endpoint.&n; * &n; * Upon receipt of an INIT in the COOKIE-WAIT or COOKIE-ECHOED state, an&n; * endpoint MUST respond with an INIT ACK using the same parameters it&n; * sent in its original INIT chunk (including its Verification Tag,&n; * unchanged). These original parameters are combined with those from the&n; * newly received INIT chunk. The endpoint shall also generate a State&n; * Cookie with the INIT ACK. The endpoint uses the parameters sent in its&n; * INIT to calculate the State Cookie.&n; * &n; * After that, the endpoint MUST NOT change its state, the T1-init &n; * timer shall be left running and the corresponding TCB MUST NOT be &n; * destroyed. The normal procedures for handling State Cookies when&n; * a TCB exists will resolve the duplicate INITs to a single association.&n; * &n; * For an endpoint that is in the COOKIE-ECHOED state it MUST populate&n; * its Tie-Tags with the Tag information of itself and its peer (see&n; * section 5.2.2 for a description of the Tie-Tags).&n; * &n; * Verification Tag: Not explicit, but an INIT can not have a valid&n; * verification tag, so we skip the check.&n; *&n; * Inputs&n; * (endpoint, asoc, chunk)&n; * &n; * Outputs&n; * (asoc, reply_msg, msg_up, timers, counters)&n; *&n; * The return value is the disposition of the chunk.&n; */
id|sctp_disposition_t
DECL|function|sctp_sf_do_5_2_1_siminit
id|sctp_sf_do_5_2_1_siminit
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
r_const
id|sctp_subtype_t
id|type
comma
r_void
op_star
id|arg
comma
id|sctp_cmd_seq_t
op_star
id|commands
)paren
(brace
id|sctp_disposition_t
id|retval
suffix:semicolon
multiline_comment|/* Call helper to do the real work for both simulataneous and&n;&t; * duplicate INIT chunk handling. &n;&t; */
id|retval
op_assign
id|sctp_sf_do_unexpected_init
c_func
(paren
id|ep
comma
id|asoc
comma
id|type
comma
id|arg
comma
id|commands
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/* sctp_sf_do_5_2_1_siminit() */
multiline_comment|/*&n; * Handle duplicated INIT messages.  These are usually delayed &n; * restransmissions.&n; * &n; * Section: 5.2.2 Unexpected INIT in States Other than CLOSED,&n; * COOKIE-ECHOED and COOKIE-WAIT&n; *&n; * Unless otherwise stated, upon reception of an unexpected INIT for&n; * this association, the endpoint shall generate an INIT ACK with a&n; * State Cookie.  In the outbound INIT ACK the endpoint MUST copy its&n; * current Verification Tag and peer&squot;s Verification Tag into a reserved&n; * place within the state cookie.  We shall refer to these locations as&n; * the Peer&squot;s-Tie-Tag and the Local-Tie-Tag.  The outbound SCTP packet&n; * containing this INIT ACK MUST carry a Verification Tag value equal to&n; * the Initiation Tag found in the unexpected INIT.  And the INIT ACK&n; * MUST contain a new Initiation Tag (randomly generated see Section&n; * 5.3.1).  Other parameters for the endpoint SHOULD be copied from the&n; * existing parameters of the association (e.g. number of outbound&n; * streams) into the INIT ACK and cookie.&n; *&n; * After sending out the INIT ACK, the endpoint shall take no further&n; * actions, i.e., the existing association, including its current state,&n; * and the corresponding TCB MUST NOT be changed.&n; *&n; * Note: Only when a TCB exists and the association is not in a COOKIE-&n; * WAIT state are the Tie-Tags populated.  For a normal association INIT&n; * (i.e. the endpoint is in a COOKIE-WAIT state), the Tie-Tags MUST be&n; * set to 0 (indicating that no previous TCB existed).  The INIT ACK and&n; * State Cookie are populated as specified in section 5.2.1.&n; * &n; * Verification Tag: Not specifed, but an INIT has no way of knowing&n; * what the verification tag could be, so we ignore it.&n; *&n; * Inputs&n; * (endpoint, asoc, chunk)&n; * &n; * Outputs&n; * (asoc, reply_msg, msg_up, timers, counters)&n; *&n; * The return value is the disposition of the chunk.  */
id|sctp_disposition_t
DECL|function|sctp_sf_do_5_2_2_dupinit
id|sctp_sf_do_5_2_2_dupinit
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
r_const
id|sctp_subtype_t
id|type
comma
r_void
op_star
id|arg
comma
id|sctp_cmd_seq_t
op_star
id|commands
)paren
(brace
id|sctp_disposition_t
id|retval
suffix:semicolon
multiline_comment|/* Call helper to do the real work for both simulataneous and&n;&t; * duplicate INIT chunk handling. &n;&t; */
id|retval
op_assign
id|sctp_sf_do_unexpected_init
c_func
(paren
id|ep
comma
id|asoc
comma
id|type
comma
id|arg
comma
id|commands
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/* sctp_sf_do_5_2_2_dupinit() */
multiline_comment|/* Unexpected COOKIE-ECHO handlerfor peer restart (Table 2, action &squot;A&squot;)&n; * &n; * Section 5.2.4 &n; *  A)  In this case, the peer may have restarted.&n; */
r_static
id|sctp_disposition_t
DECL|function|sctp_sf_do_dupcook_a
id|sctp_sf_do_dupcook_a
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
id|sctp_chunk_t
op_star
id|chunk
comma
id|sctp_cmd_seq_t
op_star
id|commands
comma
id|sctp_association_t
op_star
id|new_asoc
)paren
(brace
id|sctp_init_chunk_t
op_star
id|peer_init
suffix:semicolon
id|sctp_ulpevent_t
op_star
id|ev
suffix:semicolon
id|sctp_chunk_t
op_star
id|repl
suffix:semicolon
id|sctp_transport_t
op_star
id|new_addr
comma
op_star
id|addr
suffix:semicolon
id|list_t
op_star
id|pos
comma
op_star
id|pos2
comma
op_star
id|temp
suffix:semicolon
r_int
id|found
comma
id|error
suffix:semicolon
multiline_comment|/* new_asoc is a brand-new association, so these are not yet&n;&t; * side effects--it is safe to run them here.&n;&t; */
id|peer_init
op_assign
op_amp
id|chunk-&gt;subh.cookie_hdr-&gt;c.peer_init
(braket
l_int|0
)braket
suffix:semicolon
id|sctp_process_init
c_func
(paren
id|new_asoc
comma
id|chunk-&gt;chunk_hdr-&gt;type
comma
id|sctp_source
c_func
(paren
id|chunk
)paren
comma
id|peer_init
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
multiline_comment|/* Make sure peer is not adding new addresses. */
id|found
op_assign
l_int|0
suffix:semicolon
id|new_addr
op_assign
l_int|NULL
suffix:semicolon
id|list_for_each
c_func
(paren
id|pos
comma
op_amp
id|new_asoc-&gt;peer.transport_addr_list
)paren
(brace
id|new_addr
op_assign
id|list_entry
c_func
(paren
id|pos
comma
id|sctp_transport_t
comma
id|transports
)paren
suffix:semicolon
id|found
op_assign
l_int|1
suffix:semicolon
id|list_for_each_safe
c_func
(paren
id|pos2
comma
id|temp
comma
op_amp
id|asoc-&gt;peer.transport_addr_list
)paren
(brace
id|addr
op_assign
id|list_entry
c_func
(paren
id|pos2
comma
id|sctp_transport_t
comma
id|transports
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sctp_cmp_addr_exact
c_func
(paren
op_amp
id|new_addr-&gt;ipaddr
comma
op_amp
id|addr-&gt;ipaddr
)paren
)paren
(brace
id|found
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|found
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* list_for_each(...) */
r_if
c_cond
(paren
op_logical_neg
id|found
)paren
(brace
id|sctp_bind_addr_t
op_star
id|bp
suffix:semicolon
id|sctpParam_t
id|rawaddr
suffix:semicolon
r_int
id|len
suffix:semicolon
id|bp
op_assign
id|sctp_bind_addr_new
c_func
(paren
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bp
)paren
(brace
r_goto
id|nomem
suffix:semicolon
)brace
id|error
op_assign
id|sctp_add_bind_addr
c_func
(paren
id|bp
comma
op_amp
id|new_addr-&gt;ipaddr
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_goto
id|nomem_add
suffix:semicolon
)brace
id|rawaddr
op_assign
id|sctp_bind_addrs_to_raw
c_func
(paren
id|bp
comma
op_amp
id|len
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rawaddr.v
)paren
(brace
r_goto
id|nomem_raw
suffix:semicolon
)brace
id|repl
op_assign
id|sctp_make_abort
c_func
(paren
id|asoc
comma
id|chunk
comma
id|len
op_plus
r_sizeof
(paren
id|sctp_errhdr_t
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|repl
)paren
(brace
r_goto
id|nomem_abort
suffix:semicolon
)brace
id|sctp_init_cause
c_func
(paren
id|repl
comma
id|SCTP_ERROR_RESTART
comma
id|rawaddr.v
comma
id|len
)paren
suffix:semicolon
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_REPLY
comma
id|SCTP_CHUNK
c_func
(paren
id|repl
)paren
)paren
suffix:semicolon
r_return
id|SCTP_DISPOSITION_CONSUME
suffix:semicolon
id|nomem_abort
suffix:colon
id|kfree
c_func
(paren
id|rawaddr.v
)paren
suffix:semicolon
id|nomem_raw
suffix:colon
id|nomem_add
suffix:colon
id|sctp_bind_addr_free
c_func
(paren
id|bp
)paren
suffix:semicolon
r_goto
id|nomem
suffix:semicolon
)brace
multiline_comment|/* For now, fail any unsent/unacked data.  Consider the optional&n;&t; * choice of resending of this data.&n;&t; */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_PURGE_OUTQUEUE
comma
id|SCTP_NULL
c_func
(paren
)paren
)paren
suffix:semicolon
multiline_comment|/* Update the content of current association. */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_UPDATE_ASSOC
comma
id|SCTP_ASOC
c_func
(paren
id|new_asoc
)paren
)paren
suffix:semicolon
id|repl
op_assign
id|sctp_make_cookie_ack
c_func
(paren
id|new_asoc
comma
id|chunk
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|repl
)paren
(brace
r_goto
id|nomem
suffix:semicolon
)brace
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_REPLY
comma
id|SCTP_CHUNK
c_func
(paren
id|repl
)paren
)paren
suffix:semicolon
multiline_comment|/* Report association restart to upper layer. */
id|ev
op_assign
id|sctp_ulpevent_make_assoc_change
c_func
(paren
id|asoc
comma
l_int|0
comma
id|SCTP_RESTART
comma
l_int|0
comma
id|new_asoc-&gt;c.sinit_num_ostreams
comma
id|new_asoc-&gt;c.sinit_max_instreams
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|NULL
op_eq
id|ev
)paren
(brace
r_goto
id|nomem_ev
suffix:semicolon
)brace
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_EVENT_ULP
comma
id|SCTP_ULPEVENT
c_func
(paren
id|ev
)paren
)paren
suffix:semicolon
r_return
id|SCTP_DISPOSITION_CONSUME
suffix:semicolon
id|nomem_ev
suffix:colon
id|sctp_free_chunk
c_func
(paren
id|repl
)paren
suffix:semicolon
id|nomem
suffix:colon
r_return
id|SCTP_DISPOSITION_NOMEM
suffix:semicolon
)brace
multiline_comment|/* sctp_sf_dupcook_a() */
multiline_comment|/* Unexpected COOKIE-ECHO handler for setup collision (Table 2, action &squot;B&squot;)&n; * &n; * Section 5.2.4 &n; *   B) In this case, both sides may be attempting to start an association&n; *      at about the same time but the peer endpoint started its INIT&n; *      after responding to the local endpoint&squot;s INIT&n; */
multiline_comment|/* This case represents an intialization collision.  */
r_static
id|sctp_disposition_t
DECL|function|sctp_sf_do_dupcook_b
id|sctp_sf_do_dupcook_b
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
id|sctp_chunk_t
op_star
id|chunk
comma
id|sctp_cmd_seq_t
op_star
id|commands
comma
id|sctp_association_t
op_star
id|new_asoc
)paren
(brace
id|sctp_init_chunk_t
op_star
id|peer_init
suffix:semicolon
id|sctp_ulpevent_t
op_star
id|ev
suffix:semicolon
id|sctp_chunk_t
op_star
id|repl
suffix:semicolon
multiline_comment|/* new_asoc is a brand-new association, so these are not yet&n;&t; * side effects--it is safe to run them here.&n;&t; */
id|peer_init
op_assign
op_amp
id|chunk-&gt;subh.cookie_hdr-&gt;c.peer_init
(braket
l_int|0
)braket
suffix:semicolon
id|sctp_process_init
c_func
(paren
id|new_asoc
comma
id|chunk-&gt;chunk_hdr-&gt;type
comma
id|sctp_source
c_func
(paren
id|chunk
)paren
comma
id|peer_init
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
multiline_comment|/* Update the content of current association. */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_UPDATE_ASSOC
comma
id|SCTP_ASOC
c_func
(paren
id|new_asoc
)paren
)paren
suffix:semicolon
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_NEW_STATE
comma
id|SCTP_STATE
c_func
(paren
id|SCTP_STATE_ESTABLISHED
)paren
)paren
suffix:semicolon
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_HB_TIMERS_START
comma
id|SCTP_NULL
c_func
(paren
)paren
)paren
suffix:semicolon
id|repl
op_assign
id|sctp_make_cookie_ack
c_func
(paren
id|new_asoc
comma
id|chunk
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|NULL
op_eq
id|repl
)paren
(brace
r_goto
id|nomem
suffix:semicolon
)brace
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_REPLY
comma
id|SCTP_CHUNK
c_func
(paren
id|repl
)paren
)paren
suffix:semicolon
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_TRANSMIT
comma
id|SCTP_NULL
c_func
(paren
)paren
)paren
suffix:semicolon
multiline_comment|/* RFC 2960 5.1 Normal Establishment of an Association&n;&t; *&n;&t; * D) IMPLEMENTATION NOTE: An implementation may choose to&n;&t; * send the Communication Up notification to the SCTP user&n;&t; * upon reception of a valid COOKIE ECHO chunk.&n;&t; */
id|ev
op_assign
id|sctp_ulpevent_make_assoc_change
c_func
(paren
id|asoc
comma
l_int|0
comma
id|SCTP_COMM_UP
comma
l_int|0
comma
id|new_asoc-&gt;c.sinit_num_ostreams
comma
id|new_asoc-&gt;c.sinit_max_instreams
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|NULL
op_eq
id|ev
)paren
(brace
r_goto
id|nomem_ev
suffix:semicolon
)brace
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_EVENT_ULP
comma
id|SCTP_ULPEVENT
c_func
(paren
id|ev
)paren
)paren
suffix:semicolon
r_return
id|SCTP_DISPOSITION_CONSUME
suffix:semicolon
id|nomem_ev
suffix:colon
id|sctp_free_chunk
c_func
(paren
id|repl
)paren
suffix:semicolon
id|nomem
suffix:colon
r_return
id|SCTP_DISPOSITION_NOMEM
suffix:semicolon
)brace
multiline_comment|/* sctp_sf_dupcook_b() */
multiline_comment|/* Unexpected COOKIE-ECHO handler for setup collision (Table 2, action &squot;C&squot;)&n; * &n; * Section 5.2.4 &n; *  C) In this case, the local endpoint&squot;s cookie has arrived late.&n; *     Before it arrived, the local endpoint sent an INIT and received an&n; *     INIT-ACK and finally sent a COOKIE ECHO with the peer&squot;s same tag&n; *     but a new tag of its own.&n; */
multiline_comment|/* This case represents an intialization collision.  */
r_static
id|sctp_disposition_t
DECL|function|sctp_sf_do_dupcook_c
id|sctp_sf_do_dupcook_c
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
id|sctp_chunk_t
op_star
id|chunk
comma
id|sctp_cmd_seq_t
op_star
id|commands
comma
id|sctp_association_t
op_star
id|new_asoc
)paren
(brace
multiline_comment|/* The cookie should be silently discarded. &n;&t; * The endpoint SHOULD NOT change states and should leave&n;&t; * any timers running.&n;&t; */
r_return
id|SCTP_DISPOSITION_DISCARD
suffix:semicolon
)brace
multiline_comment|/* sctp_sf_do_dupcook_c() */
multiline_comment|/* Unexpected COOKIE-ECHO handler lost chunk (Table 2, action &squot;D&squot;)&n; * &n; * Section 5.2.4 &n; * &n; * D) When both local and remote tags match the endpoint should always&n; *    enter the ESTABLISHED state, if it has not already done so.&n; */
multiline_comment|/* This case represents an intialization collision.  */
r_static
id|sctp_disposition_t
DECL|function|sctp_sf_do_dupcook_d
id|sctp_sf_do_dupcook_d
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
id|sctp_chunk_t
op_star
id|chunk
comma
id|sctp_cmd_seq_t
op_star
id|commands
comma
id|sctp_association_t
op_star
id|new_asoc
)paren
(brace
id|sctp_ulpevent_t
op_star
id|ev
op_assign
l_int|NULL
suffix:semicolon
id|sctp_chunk_t
op_star
id|repl
suffix:semicolon
multiline_comment|/* The local endpoint cannot use any value from the received&n;&t; * state cookie and need to immediately resend a COOKIE-ACK&n;&t; * and move into ESTABLISHED if it hasn&squot;t done so.&n;&t; */
r_if
c_cond
(paren
id|SCTP_STATE_ESTABLISHED
op_ne
id|asoc-&gt;state
)paren
(brace
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_NEW_STATE
comma
id|SCTP_STATE
c_func
(paren
id|SCTP_STATE_ESTABLISHED
)paren
)paren
suffix:semicolon
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_HB_TIMERS_START
comma
id|SCTP_NULL
c_func
(paren
)paren
)paren
suffix:semicolon
multiline_comment|/* RFC 2960 5.1 Normal Establishment of an Association&n;&t;&t; *&n;&t;&t; * D) IMPLEMENTATION NOTE: An implementation may choose&n;&t;&t; * to send the Communication Up notification to the&n;&t;&t; * SCTP user upon reception of a valid COOKIE&n;&t;&t; * ECHO chunk.&n;&t;&t; */
id|ev
op_assign
id|sctp_ulpevent_make_assoc_change
c_func
(paren
id|new_asoc
comma
l_int|0
comma
id|SCTP_COMM_UP
comma
l_int|0
comma
id|new_asoc-&gt;c.sinit_num_ostreams
comma
id|new_asoc-&gt;c.sinit_max_instreams
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|NULL
op_eq
id|ev
)paren
(brace
r_goto
id|nomem
suffix:semicolon
)brace
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_EVENT_ULP
comma
id|SCTP_ULPEVENT
c_func
(paren
id|ev
)paren
)paren
suffix:semicolon
)brace
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_TRANSMIT
comma
id|SCTP_NULL
c_func
(paren
)paren
)paren
suffix:semicolon
id|repl
op_assign
id|sctp_make_cookie_ack
c_func
(paren
id|new_asoc
comma
id|chunk
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|NULL
op_eq
id|repl
)paren
(brace
r_goto
id|nomem
suffix:semicolon
)brace
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_REPLY
comma
id|SCTP_CHUNK
c_func
(paren
id|repl
)paren
)paren
suffix:semicolon
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_TRANSMIT
comma
id|SCTP_NULL
c_func
(paren
)paren
)paren
suffix:semicolon
r_return
id|SCTP_DISPOSITION_CONSUME
suffix:semicolon
id|nomem
suffix:colon
r_if
c_cond
(paren
id|ev
)paren
(brace
id|sctp_ulpevent_free
c_func
(paren
id|ev
)paren
suffix:semicolon
)brace
r_return
id|SCTP_DISPOSITION_NOMEM
suffix:semicolon
)brace
multiline_comment|/* sctp_sf_do_dupcook_c() */
multiline_comment|/*&n; * Handle a duplicate COOKIE-ECHO.  This usually means a cookie-carrying&n; * chunk was retransmitted and then delayed in the network.&n; * &n; * Section: 5.2.4 Handle a COOKIE ECHO when a TCB exists&n; * &n; * Verification Tag: None.  Do cookie validation.&n; *&n; * Inputs&n; * (endpoint, asoc, chunk)&n; * &n; * Outputs&n; * (asoc, reply_msg, msg_up, timers, counters)&n; *&n; * The return value is the disposition of the chunk.&n; */
id|sctp_disposition_t
DECL|function|sctp_sf_do_5_2_4_dupcook
id|sctp_sf_do_5_2_4_dupcook
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
r_const
id|sctp_subtype_t
id|type
comma
r_void
op_star
id|arg
comma
id|sctp_cmd_seq_t
op_star
id|commands
)paren
(brace
id|sctp_disposition_t
id|retval
suffix:semicolon
id|sctp_chunk_t
op_star
id|chunk
op_assign
id|arg
suffix:semicolon
id|sctp_association_t
op_star
id|new_asoc
suffix:semicolon
r_int
id|error
op_assign
l_int|0
suffix:semicolon
r_char
id|action
suffix:semicolon
multiline_comment|/* &quot;Decode&quot; the chunk.  We have no optional parameters so we&n;          * are in good shape.&n;          */
id|chunk-&gt;subh.cookie_hdr
op_assign
(paren
id|sctp_signed_cookie_t
op_star
)paren
id|chunk-&gt;skb-&gt;data
suffix:semicolon
id|skb_pull
c_func
(paren
id|chunk-&gt;skb
comma
id|ntohs
c_func
(paren
id|chunk-&gt;chunk_hdr-&gt;length
)paren
op_minus
r_sizeof
(paren
id|sctp_chunkhdr_t
)paren
)paren
suffix:semicolon
multiline_comment|/* In RFC 2960 5.2.4 3, if both Verification Tags in the State Cookie&n;&t;  * of a duplicate COOKIE ECHO match the Verification Tags of the&n;&t;  * current association, consider the State Cookie valid even if&n;&t;  * the lifespan is exceeded.&n;&t;  */
id|new_asoc
op_assign
id|sctp_unpack_cookie
c_func
(paren
id|ep
comma
id|asoc
comma
id|chunk
comma
id|GFP_ATOMIC
comma
op_amp
id|error
)paren
suffix:semicolon
multiline_comment|/* FIXME:&n;&t;  * If the re-build failed, what is the proper error path&n;&t;  * from here?&n;&t;  *&n;&t;  * [We should abort the association. --piggy]&n;&t;  */
r_if
c_cond
(paren
l_int|NULL
op_eq
id|new_asoc
)paren
(brace
multiline_comment|/* FIXME: Several errors are possible.  A bad cookie should&n;&t;&t;  * be silently discarded, but think about logging it too.&n;&t;&t;  */
r_switch
c_cond
(paren
id|error
)paren
(brace
r_case
op_minus
id|SCTP_IERROR_NOMEM
suffix:colon
r_goto
id|nomem
suffix:semicolon
r_case
op_minus
id|SCTP_IERROR_BAD_SIG
suffix:colon
r_default
suffix:colon
r_return
id|sctp_sf_pdiscard
c_func
(paren
id|ep
comma
id|asoc
comma
id|type
comma
id|arg
comma
id|commands
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Compare the tie_tag in cookie with the verification tag of&n;         * current association.&n;         */
id|action
op_assign
id|sctp_tietags_compare
c_func
(paren
id|new_asoc
comma
id|asoc
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|action
)paren
(brace
r_case
l_char|&squot;A&squot;
suffix:colon
multiline_comment|/* Association restart. */
id|retval
op_assign
id|sctp_sf_do_dupcook_a
c_func
(paren
id|ep
comma
id|asoc
comma
id|chunk
comma
id|commands
comma
id|new_asoc
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;B&squot;
suffix:colon
multiline_comment|/* Collision case B. */
id|retval
op_assign
id|sctp_sf_do_dupcook_b
c_func
(paren
id|ep
comma
id|asoc
comma
id|chunk
comma
id|commands
comma
id|new_asoc
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;C&squot;
suffix:colon
multiline_comment|/* Collisioun case C. */
id|retval
op_assign
id|sctp_sf_do_dupcook_c
c_func
(paren
id|ep
comma
id|asoc
comma
id|chunk
comma
id|commands
comma
id|new_asoc
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;D&squot;
suffix:colon
multiline_comment|/* Collision case D. */
id|retval
op_assign
id|sctp_sf_do_dupcook_d
c_func
(paren
id|ep
comma
id|asoc
comma
id|chunk
comma
id|commands
comma
id|new_asoc
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* No such case, discard it. */
id|printk
c_func
(paren
id|KERN_WARNING
id|__FUNCTION__
l_string|&quot;:unknown case&bslash;n&quot;
)paren
suffix:semicolon
id|retval
op_assign
id|SCTP_DISPOSITION_DISCARD
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* switch */
multiline_comment|/* Delete the tempory new association. */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_NEW_ASOC
comma
id|SCTP_ASOC
c_func
(paren
id|new_asoc
)paren
)paren
suffix:semicolon
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_DELETE_TCB
comma
id|SCTP_NULL
c_func
(paren
)paren
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
id|nomem
suffix:colon
r_return
id|SCTP_DISPOSITION_NOMEM
suffix:semicolon
)brace
multiline_comment|/* sctp_sf_do_5_2_4_dupcook() */
macro_line|#if 0
multiline_comment|/*&n; * Handle a Stale COOKIE Error&n; * &n; * Section: 5.2.6 Handle Stale COOKIE Error&n; * If the association is in the COOKIE-ECHOED state, the endpoint may elect&n; * one of the following three alternatives. &n; * ...&n; * 3) Send a new INIT chunk to the endpoint, adding a Cookie&n; *    Preservative parameter requesting an extension to the lifetime of&n; *    the State Cookie. When calculating the time extension, an &n; *    implementation SHOULD use the RTT information measured based on the&n; *    previous COOKIE ECHO / ERROR exchange, and should add no more &n; *    than 1 second beyond the measured RTT, due to long State Cookie &n; *    lifetimes making the endpoint more subject to a replay attack.&n; * &n; * Verification Tag:  Not explicit, but safe to ignore.&n; *&n; * Inputs&n; * (endpoint, asoc, chunk)&n; * &n; * Outputs&n; * (asoc, reply_msg, msg_up, timers, counters)&n; *&n; * The return value is the disposition of the chunk.&n; */
id|sctp_disposition_t
id|do_5_2_6_stale
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
r_const
id|sctp_subtype_t
id|type
comma
r_void
op_star
id|arg
comma
id|sctp_cmd_seq_t
op_star
id|commands
)paren
(brace
id|sctp_chunk_t
op_star
id|chunk
op_assign
id|arg
suffix:semicolon
multiline_comment|/* This is not a real chunk type.  It is a subtype of the&n;         * ERROR chunk type.  The ERROR chunk processing will bring us&n;         * here.&n;         */
id|sctp_chunk_t
op_star
id|in_packet
suffix:semicolon
id|stp_chunk_t
op_star
id|reply
suffix:semicolon
id|sctp_inithdr_t
id|initack
suffix:semicolon
r_uint8
op_star
id|addrs
suffix:semicolon
r_int
id|addrs_len
suffix:semicolon
id|time_t
id|rtt
suffix:semicolon
r_extern
r_struct
id|timespec
id|now
suffix:semicolon
r_struct
id|sctpCookiePreserve
id|bht
suffix:semicolon
multiline_comment|/* If we have gotten too many failures, give up.  */
r_if
c_cond
(paren
l_int|1
op_plus
id|asoc-&gt;counters
(braket
id|SctpCounterInits
)braket
OG
id|asoc-&gt;max_init_attempts
)paren
(brace
multiline_comment|/* FIXME: Move to new ulpevent. */
id|retval-&gt;event_up
op_assign
id|sctp_make_ulp_init_timeout
c_func
(paren
id|asoc
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|NULL
op_eq
id|retval-&gt;event_up
)paren
(brace
r_goto
id|nomem
suffix:semicolon
)brace
id|sctp_add_cmd_sf
c_func
(paren
id|retval-&gt;commands
comma
id|SCTP_CMD_DELETE_TCB
comma
id|SCTP_NULL
c_func
(paren
)paren
)paren
suffix:semicolon
r_return
id|SCTP_DISPOSITION_DELETE_TCB
suffix:semicolon
)brace
id|retval-&gt;counters
(braket
l_int|0
)braket
op_assign
id|SCTP_COUNTER_INCR
suffix:semicolon
id|retval-&gt;counters
(braket
l_int|0
)braket
op_assign
id|SctpCounterInits
suffix:semicolon
id|retval-&gt;counters
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
id|retval-&gt;counters
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Calculate the RTT in ms.  */
multiline_comment|/* BUG--we should get the send time of the HEARTBEAT REQUEST.  */
id|in_packet
op_assign
id|chunk
suffix:semicolon
id|rtt
op_assign
l_int|1000
op_star
id|timeval_sub
c_func
(paren
id|in_packet-&gt;skb-&gt;stamp
comma
id|asoc-&gt;c.state_timestamp
)paren
suffix:semicolon
multiline_comment|/* When calculating the time extension, an implementation&n;         * SHOULD use the RTT information measured based on the&n;         * previous COOKIE ECHO / ERROR exchange, and should add no&n;         * more than 1 second beyond the measured RTT, due to long&n;         * State Cookie lifetimes making the endpoint more subject to&n;         * a replay attack.&n;         */
id|bht.p
op_assign
(brace
id|SCTP_COOKIE_PRESERVE
comma
l_int|8
)brace
suffix:semicolon
id|bht.extraTime
op_assign
id|htonl
c_func
(paren
id|rtt
op_plus
l_int|1000
)paren
suffix:semicolon
id|initack.init_tag
op_assign
id|htonl
c_func
(paren
id|asoc-&gt;c.my_vtag
)paren
suffix:semicolon
id|initack.a_rwnd
op_assign
id|htonl
c_func
(paren
id|atomic_read
c_func
(paren
op_amp
id|asoc-&gt;rnwd
)paren
)paren
suffix:semicolon
id|initack.num_outbound_streams
op_assign
id|htons
c_func
(paren
id|asoc-&gt;streamoutcnt
)paren
suffix:semicolon
id|initack.num_inbound_streams
op_assign
id|htons
c_func
(paren
id|asoc-&gt;streamincnt
)paren
suffix:semicolon
id|initack.initial_tsn
op_assign
id|htonl
c_func
(paren
id|asoc-&gt;c.initSeqNumber
)paren
suffix:semicolon
id|sctp_get_my_addrs
c_func
(paren
id|asoc
comma
op_amp
id|addrs
comma
op_amp
id|addrs_len
)paren
suffix:semicolon
multiline_comment|/* Build that new INIT chunk.  */
id|reply
op_assign
id|sctp_make_chunk
c_func
(paren
id|SCTP_INITIATION
comma
l_int|0
comma
r_sizeof
(paren
id|initack
)paren
op_plus
r_sizeof
(paren
id|bht
)paren
op_plus
id|addrs_len
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|NULL
op_eq
id|reply
)paren
(brace
r_goto
id|nomem
suffix:semicolon
)brace
id|sctp_addto_chunk
c_func
(paren
id|reply
comma
r_sizeof
(paren
id|initack
)paren
comma
op_amp
id|initack
)paren
suffix:semicolon
id|sctp_addto_chunk
c_func
(paren
id|reply
comma
r_sizeof
(paren
id|bht
)paren
comma
op_amp
id|bht
)paren
suffix:semicolon
id|sctp_addto_chunk
c_func
(paren
id|reply
comma
id|addrs_len
comma
id|addrs
)paren
suffix:semicolon
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_REPLY
comma
id|SCTP_CHUNK
c_func
(paren
id|reply
)paren
)paren
suffix:semicolon
r_return
id|SCTP_DISPOSITION_CONSUME
suffix:semicolon
id|nomem
suffix:colon
r_return
id|SCTP_DISPOSITION_NOMEM
suffix:semicolon
)brace
multiline_comment|/* sctp_disposition_t do_5_2_6_stale  (...) */
macro_line|#endif /* 0 */
multiline_comment|/*&n; * Process an ABORT.&n; * &n; * Section: 9.1&n; * After checking the Verification Tag, the receiving endpoint shall &n; * remove the association from its record, and shall report the &n; * termination to its upper layer.&n; *&n; * Verification Tag: 8.5.1 Exceptions in Verification Tag Rules&n; * B) Rules for packet carrying ABORT:&n; * &n; *  - The endpoint shall always fill in the Verification Tag field of the&n; *    outbound packet with the destination endpoint&squot;s tag value if it&n; *    is known. &n; * &n; *  - If the ABORT is sent in response to an OOTB packet, the endpoint&n; *    MUST follow the procedure described in Section 8.4.&n; * &n; *  - The receiver MUST accept the packet if the Verification Tag&n; *    matches either its own tag, OR the tag of its peer. Otherwise, the&n; *    receiver MUST silently discard the packet and take no further&n; *    action.  &n; * &n; * Inputs&n; * (endpoint, asoc, chunk)&n; * &n; * Outputs&n; * (asoc, reply_msg, msg_up, timers, counters)&n; *&n; * The return value is the disposition of the chunk.&n; */
id|sctp_disposition_t
DECL|function|sctp_sf_do_9_1_abort
id|sctp_sf_do_9_1_abort
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
r_const
id|sctp_subtype_t
id|type
comma
r_void
op_star
id|arg
comma
id|sctp_cmd_seq_t
op_star
id|commands
)paren
(brace
multiline_comment|/* Check the verification tag.  */
multiline_comment|/* BUG: WRITE ME. */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_NEW_STATE
comma
id|SCTP_STATE
c_func
(paren
id|SCTP_STATE_CLOSED
)paren
)paren
suffix:semicolon
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_DELETE_TCB
comma
id|SCTP_NULL
c_func
(paren
)paren
)paren
suffix:semicolon
multiline_comment|/* BUG?  This does not look complete... */
r_return
id|SCTP_DISPOSITION_ABORT
suffix:semicolon
)brace
multiline_comment|/* sctp_sf_do_9_1_abort() */
multiline_comment|/*&n; * Process an ABORT.  (COOKIE-WAIT state)&n; * &n; * See sctp_sf_do_9_1_abort() above.&n; */
id|sctp_disposition_t
DECL|function|sctp_sf_cookie_wait_abort
id|sctp_sf_cookie_wait_abort
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
r_const
id|sctp_subtype_t
id|type
comma
r_void
op_star
id|arg
comma
id|sctp_cmd_seq_t
op_star
id|commands
)paren
(brace
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_NEW_STATE
comma
id|SCTP_STATE
c_func
(paren
id|SCTP_STATE_CLOSED
)paren
)paren
suffix:semicolon
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_TIMER_STOP
comma
id|SCTP_TO
c_func
(paren
id|SCTP_EVENT_TIMEOUT_T1_INIT
)paren
)paren
suffix:semicolon
multiline_comment|/* CMD_INIT_FAILED will DELETE_TCB. */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_INIT_FAILED
comma
id|SCTP_NULL
c_func
(paren
)paren
)paren
suffix:semicolon
r_return
id|SCTP_DISPOSITION_DELETE_TCB
suffix:semicolon
)brace
multiline_comment|/* sctp_sf_cookie_wait_abort() */
multiline_comment|/*&n; * Process an ABORT.  (COOKIE-ECHOED state)&n; * &n; * See sctp_sf_do_9_1_abort() above.&n; */
id|sctp_disposition_t
DECL|function|sctp_sf_cookie_echoed_abort
id|sctp_sf_cookie_echoed_abort
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
r_const
id|sctp_subtype_t
id|type
comma
r_void
op_star
id|arg
comma
id|sctp_cmd_seq_t
op_star
id|commands
)paren
(brace
multiline_comment|/* There is a single T1 timer, so we should be able to use&n;&t; * common function with the COOKIE-WAIT state. &n;&t; */
r_return
id|sctp_sf_cookie_wait_abort
c_func
(paren
id|ep
comma
id|asoc
comma
id|type
comma
id|arg
comma
id|commands
)paren
suffix:semicolon
)brace
multiline_comment|/* sctp_sf_cookie_echoed_abort() */
macro_line|#if 0
multiline_comment|/*&n; * Handle a shutdown timeout or INIT during a shutdown phase.&n; * &n; * Section: 9.2&n; * If an endpoint is in SHUTDOWN-ACK-SENT state and receives an INIT chunk &n; * (e.g., if the SHUTDOWN COMPLETE was lost) with source and destination &n; * transport addresses (either in the IP addresses or in the INIT chunk) &n; * that belong to this association, it should discard the INIT chunk and &n; * retransmit the SHUTDOWN ACK chunk. &n; *... &n; * While in SHUTDOWN-SENT state ... If the timer expires, the endpoint&n; * must re-send the SHUTDOWN ACK.&n; *&n; * Verification Tag:  Neither the INIT nor the timeout will have a&n; * valid verification tag, so it is safe to ignore.&n; *&n; * Inputs&n; * (endpoint, asoc, chunk)&n; * &n; * Outputs&n; * (asoc, reply_msg, msg_up, timers, counters)&n; *&n; * The return value is the disposition of the chunk.&n; */
id|sctp_disposition_t
id|sctp_do_9_2_reshutack
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
r_const
id|sctp_subtype_t
id|type
comma
r_void
op_star
id|arg
comma
id|sctp_cmd_seq_t
op_star
id|commands
)paren
(brace
id|sctp_chunk_t
op_star
id|chunk
op_assign
id|arg
suffix:semicolon
multiline_comment|/* If this was a timeout (not an INIT), then do the counter&n;&t; * work.  We might need to just dump the association.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|chunk
)paren
(brace
r_if
c_cond
(paren
l_int|1
op_plus
id|asoc-&gt;counters
(braket
id|SctpCounterRetran
)braket
OG
id|asoc-&gt;maxRetrans
)paren
(brace
id|sctp_add_cmd
c_func
(paren
id|commands
comma
id|SCTP_CMD_DELETE_TCB
comma
id|SCTP_NULL
c_func
(paren
)paren
)paren
suffix:semicolon
r_return
id|SCTP_DISPOSITION_DELETE_TCB
suffix:semicolon
)brace
id|retval-&gt;counters
(braket
l_int|0
)braket
op_assign
id|SCTP_COUNTER_INCR
suffix:semicolon
id|retval-&gt;counters
(braket
l_int|0
)braket
op_assign
id|SctpCounterRetran
suffix:semicolon
id|retval-&gt;counters
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
id|retval-&gt;counters
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
)brace
id|reply
op_assign
id|sctp_make_shutdown_ack
c_func
(paren
id|asoc
comma
id|chunk
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|reply
)paren
(brace
r_goto
id|nomem
suffix:semicolon
)brace
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_REPLY
comma
id|SCTP_CHUNK
c_func
(paren
id|reply
)paren
)paren
suffix:semicolon
r_return
id|SCTP_DISPOSITION_CONSUME
suffix:semicolon
id|nomem
suffix:colon
r_return
id|SCTP_DISPOSITION_NOMEM
suffix:semicolon
)brace
multiline_comment|/* sctp_disposition_t sctp_do_9_2_reshutack(...) */
macro_line|#endif /* 0 */
multiline_comment|/*&n; * sctp_sf_do_9_2_shut&n; * &n; * Section: 9.2&n; * Upon the reception of the SHUTDOWN, the peer endpoint shall &n; *  - enter the SHUTDOWN-RECEIVED state, &n; *&n; *  - stop accepting new data from its SCTP user &n; *&n; *  - verify, by checking the Cumulative TSN Ack field of the chunk,&n; *    that all its outstanding DATA chunks have been received by the&n; *    SHUTDOWN sender.&n; *&n; * Once an endpoint as reached the SHUTDOWN-RECEIVED state it MUST NOT&n; * send a SHUTDOWN in response to a ULP request. And should discard&n; * subsequent SHUTDOWN chunks.&n; * &n; * If there are still outstanding DATA chunks left, the SHUTDOWN&n; * receiver shall continue to follow normal data transmission&n; * procedures defined in Section 6 until all outstanding DATA chunks&n; * are acknowledged; however, the SHUTDOWN receiver MUST NOT accept&n; * new data from its SCTP user.&n; * &n; * Verification Tag:  8.5 Verification Tag [Normal verification]&n; *&n; * Inputs&n; * (endpoint, asoc, chunk)&n; * &n; * Outputs&n; * (asoc, reply_msg, msg_up, timers, counters)&n; *&n; * The return value is the disposition of the chunk.  */
id|sctp_disposition_t
DECL|function|sctp_sf_do_9_2_shutdown
id|sctp_sf_do_9_2_shutdown
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
r_const
id|sctp_subtype_t
id|type
comma
r_void
op_star
id|arg
comma
id|sctp_cmd_seq_t
op_star
id|commands
)paren
(brace
id|sctp_chunk_t
op_star
id|chunk
op_assign
id|arg
suffix:semicolon
id|sctp_shutdownhdr_t
op_star
id|sdh
suffix:semicolon
id|sctp_disposition_t
id|disposition
suffix:semicolon
multiline_comment|/* Convert the elaborate header.  */
id|sdh
op_assign
(paren
id|sctp_shutdownhdr_t
op_star
)paren
id|chunk-&gt;skb-&gt;data
suffix:semicolon
id|skb_pull
c_func
(paren
id|chunk-&gt;skb
comma
r_sizeof
(paren
id|sctp_shutdownhdr_t
)paren
)paren
suffix:semicolon
id|chunk-&gt;subh.shutdown_hdr
op_assign
id|sdh
suffix:semicolon
multiline_comment|/* 8.5 When receiving an SCTP packet, the endpoint MUST ensure&n;         * that the value in the Verification Tag field of the&n;         * received SCTP packet matches its own Tag. If the received&n;         * Verification Tag value does not match the receiver&squot;s own&n;         * tag value, the receiver shall silently discard the packet...&n;         */
r_if
c_cond
(paren
id|ntohl
c_func
(paren
id|chunk-&gt;sctp_hdr-&gt;vtag
)paren
op_ne
id|asoc-&gt;c.my_vtag
)paren
(brace
r_return
id|sctp_sf_pdiscard
c_func
(paren
id|ep
comma
id|asoc
comma
id|type
comma
id|arg
comma
id|commands
)paren
suffix:semicolon
)brace
multiline_comment|/* Upon the reception of the SHUTDOWN, the peer endpoint shall &n;         *  - enter the SHUTDOWN-RECEIVED state,         &n;&t; *  - stop accepting new data from its SCTP user&n;         *&n;         * [This is implicit in the new state.]&n;         */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_NEW_STATE
comma
id|SCTP_STATE
c_func
(paren
id|SCTP_STATE_SHUTDOWN_RECEIVED
)paren
)paren
suffix:semicolon
id|disposition
op_assign
id|SCTP_DISPOSITION_CONSUME
suffix:semicolon
r_if
c_cond
(paren
id|sctp_outqueue_is_empty
c_func
(paren
op_amp
id|asoc-&gt;outqueue
)paren
)paren
(brace
id|disposition
op_assign
id|sctp_sf_do_9_2_shutdown_ack
c_func
(paren
id|ep
comma
id|asoc
comma
id|type
comma
id|arg
comma
id|commands
)paren
suffix:semicolon
)brace
multiline_comment|/*  - verify, by checking the Cumulative TSN Ack field of the&n;         *    chunk, that all its outstanding DATA chunks have been&n;         *    received by the SHUTDOWN sender.&n;         */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_PROCESS_CTSN
comma
id|SCTP_U32
c_func
(paren
id|chunk-&gt;subh.shutdown_hdr-&gt;cum_tsn_ack
)paren
)paren
suffix:semicolon
r_return
id|disposition
suffix:semicolon
)brace
multiline_comment|/* sctp_sf_do_9_2_shutdown() */
multiline_comment|/*&n; * sctp_sf_do_ecn_cwr&n; * &n; * Section:  Appendix A: Explicit Congestion Notification&n; *&n; * CWR:&n; *&n; * RFC 2481 details a specific bit for a sender to send in the header of&n; * its next outbound TCP segment to indicate to its peer that it has&n; * reduced its congestion window.  This is termed the CWR bit.  For&n; * SCTP the same indication is made by including the CWR chunk.&n; * This chunk contains one data element, i.e. the TSN number that&n; * was sent in the ECNE chunk.  This element represents the lowest&n; * TSN number in the datagram that was originally marked with the&n; * CE bit.&n; *&n; * Verification Tag: 8.5 Verification Tag [Normal verification]&n; * Inputs&n; * (endpoint, asoc, chunk)&n; * &n; * Outputs&n; * (asoc, reply_msg, msg_up, timers, counters)&n; *&n; * The return value is the disposition of the chunk.&n; */
id|sctp_disposition_t
DECL|function|sctp_sf_do_ecn_cwr
id|sctp_sf_do_ecn_cwr
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
r_const
id|sctp_subtype_t
id|type
comma
r_void
op_star
id|arg
comma
id|sctp_cmd_seq_t
op_star
id|commands
)paren
(brace
id|sctp_cwrhdr_t
op_star
id|cwr
suffix:semicolon
id|sctp_chunk_t
op_star
id|chunk
op_assign
id|arg
suffix:semicolon
multiline_comment|/* 8.5 When receiving an SCTP packet, the endpoint MUST ensure&n;         * that the value in the Verification Tag field of the&n;         * received SCTP packet matches its own Tag. If the received&n;         * Verification Tag value does not match the receiver&squot;s own&n;         * tag value, the receiver shall silently discard the packet...&n;         */
r_if
c_cond
(paren
id|ntohl
c_func
(paren
id|chunk-&gt;sctp_hdr-&gt;vtag
)paren
op_ne
id|asoc-&gt;c.my_vtag
)paren
(brace
r_return
id|sctp_sf_pdiscard
c_func
(paren
id|ep
comma
id|asoc
comma
id|type
comma
id|arg
comma
id|commands
)paren
suffix:semicolon
)brace
id|cwr
op_assign
(paren
id|sctp_cwrhdr_t
op_star
)paren
id|chunk-&gt;skb-&gt;data
suffix:semicolon
id|skb_pull
c_func
(paren
id|chunk-&gt;skb
comma
r_sizeof
(paren
id|sctp_cwrhdr_t
)paren
)paren
suffix:semicolon
id|cwr-&gt;lowest_tsn
op_assign
id|ntohl
c_func
(paren
id|cwr-&gt;lowest_tsn
)paren
suffix:semicolon
multiline_comment|/* Does this CWR ack the last sent congestion notification? */
r_if
c_cond
(paren
id|TSN_lte
c_func
(paren
id|asoc-&gt;last_ecne_tsn
comma
id|cwr-&gt;lowest_tsn
)paren
)paren
(brace
multiline_comment|/* Stop sending ECNE. */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_ECN_CWR
comma
id|SCTP_U32
c_func
(paren
id|cwr-&gt;lowest_tsn
)paren
)paren
suffix:semicolon
)brace
r_return
id|SCTP_DISPOSITION_CONSUME
suffix:semicolon
)brace
multiline_comment|/* sctp_sf_do_ecne_cwr() */
multiline_comment|/*&n; * sctp_sf_do_ecne&n; * &n; * Section:  Appendix A: Explicit Congestion Notification&n; *&n; * ECN-Echo&n; *&n; * RFC 2481 details a specific bit for a receiver to send back in its&n; * TCP acknowledgements to notify the sender of the Congestion&n; * Experienced (CE) bit having arrived from the network.  For SCTP this&n; * same indication is made by including the ECNE chunk.  This chunk&n; * contains one data element, i.e. the lowest TSN associated with the IP&n; * datagram marked with the CE bit.....&n; *&n; * Verification Tag: 8.5 Verification Tag [Normal verification]&n; * Inputs&n; * (endpoint, asoc, chunk)&n; * &n; * Outputs&n; * (asoc, reply_msg, msg_up, timers, counters)&n; *&n; * The return value is the disposition of the chunk.&n; */
id|sctp_disposition_t
DECL|function|sctp_sf_do_ecne
id|sctp_sf_do_ecne
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
r_const
id|sctp_subtype_t
id|type
comma
r_void
op_star
id|arg
comma
id|sctp_cmd_seq_t
op_star
id|commands
)paren
(brace
id|sctp_ecnehdr_t
op_star
id|ecne
suffix:semicolon
id|sctp_chunk_t
op_star
id|chunk
op_assign
id|arg
suffix:semicolon
multiline_comment|/* 8.5 When receiving an SCTP packet, the endpoint MUST ensure&n;         * that the value in the Verification Tag field of the&n;         * received SCTP packet matches its own Tag. If the received&n;         * Verification Tag value does not match the receiver&squot;s own&n;         * tag value, the receiver shall silently discard the packet...&n;         */
r_if
c_cond
(paren
id|ntohl
c_func
(paren
id|chunk-&gt;sctp_hdr-&gt;vtag
)paren
op_ne
id|asoc-&gt;c.my_vtag
)paren
(brace
r_return
id|sctp_sf_pdiscard
c_func
(paren
id|ep
comma
id|asoc
comma
id|type
comma
id|arg
comma
id|commands
)paren
suffix:semicolon
)brace
id|ecne
op_assign
(paren
id|sctp_ecnehdr_t
op_star
)paren
id|chunk-&gt;skb-&gt;data
suffix:semicolon
id|skb_pull
c_func
(paren
id|chunk-&gt;skb
comma
r_sizeof
(paren
id|sctp_ecnehdr_t
)paren
)paren
suffix:semicolon
id|ecne-&gt;lowest_tsn
op_assign
id|ntohl
c_func
(paren
id|ecne-&gt;lowest_tsn
)paren
suffix:semicolon
multiline_comment|/* Casting away the const, as we are just modifying the spinlock,&n;&t; * not the association itself.   This should go away in the near&n;&t; * future when we move to an endpoint based lock.&n;&t; */
multiline_comment|/* If this is a newer ECNE than the last CWR packet we sent out */
r_if
c_cond
(paren
id|TSN_lt
c_func
(paren
id|asoc-&gt;last_cwr_tsn
comma
id|ecne-&gt;lowest_tsn
)paren
)paren
(brace
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_ECN_ECNE
comma
id|SCTP_U32
c_func
(paren
id|ecne-&gt;lowest_tsn
)paren
)paren
suffix:semicolon
)brace
r_return
id|SCTP_DISPOSITION_CONSUME
suffix:semicolon
)brace
multiline_comment|/* sctp_sf_do_ecne() */
multiline_comment|/*&n; * Section: 6.2  Acknowledgement on Reception of DATA Chunks&n; * &n; * The SCTP endpoint MUST always acknowledge the reception of each valid &n; * DATA chunk. &n; * &n; * The guidelines on delayed acknowledgement algorithm specified in&n; * Section 4.2 of [RFC2581] SHOULD be followed. Specifically, an&n; * acknowledgement SHOULD be generated for at least every second packet&n; * (not every second DATA chunk) received, and SHOULD be generated within &n; * 200 ms of the arrival of any unacknowledged DATA chunk. In some &n; * situations it may be beneficial for an SCTP transmitter to be more &n; * conservative than the algorithms detailed in this document allow. &n; * However, an SCTP transmitter MUST NOT be more aggressive than the &n; * following algorithms allow.&n; * &n; * A SCTP receiver MUST NOT generate more than one SACK for every&n; * incoming packet, other than to update the offered window as the&n; * receiving application consumes new data.&n; * &n; * Verification Tag:  8.5 Verification Tag [Normal verification]&n; * &n; * Inputs&n; * (endpoint, asoc, chunk)&n; * &n; * Outputs&n; * (asoc, reply_msg, msg_up, timers, counters)&n; *&n; * The return value is the disposition of the chunk.&n; */
id|sctp_disposition_t
DECL|function|sctp_sf_eat_data_6_2
id|sctp_sf_eat_data_6_2
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
r_const
id|sctp_subtype_t
id|type
comma
r_void
op_star
id|arg
comma
id|sctp_cmd_seq_t
op_star
id|commands
)paren
(brace
id|sctp_chunk_t
op_star
id|chunk
op_assign
id|arg
suffix:semicolon
id|sctp_datahdr_t
op_star
id|data_hdr
suffix:semicolon
id|sctp_chunk_t
op_star
id|err
suffix:semicolon
r_int
id|datalen
suffix:semicolon
r_int
id|tmp
suffix:semicolon
r_uint32
id|tsn
suffix:semicolon
multiline_comment|/* RFC 2960 8.5 Verification Tag&n;&t; *&n;&t; * When receiving an SCTP packet, the endpoint MUST ensure&n;         * that the value in the Verification Tag field of the&n;         * received SCTP packet matches its own Tag.&n;&t; */
r_if
c_cond
(paren
id|ntohl
c_func
(paren
id|chunk-&gt;sctp_hdr-&gt;vtag
)paren
op_ne
id|asoc-&gt;c.my_vtag
)paren
(brace
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_REPORT_BAD_TAG
comma
id|SCTP_NULL
c_func
(paren
)paren
)paren
suffix:semicolon
r_return
id|sctp_sf_pdiscard
c_func
(paren
id|ep
comma
id|asoc
comma
id|type
comma
id|arg
comma
id|commands
)paren
suffix:semicolon
)brace
id|data_hdr
op_assign
id|chunk-&gt;subh.data_hdr
op_assign
(paren
id|sctp_datahdr_t
op_star
)paren
id|chunk-&gt;skb-&gt;data
suffix:semicolon
id|skb_pull
c_func
(paren
id|chunk-&gt;skb
comma
r_sizeof
(paren
id|sctp_datahdr_t
)paren
)paren
suffix:semicolon
id|tsn
op_assign
id|ntohl
c_func
(paren
id|data_hdr-&gt;tsn
)paren
suffix:semicolon
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;eat_data: TSN 0x%x.&bslash;n&quot;
comma
id|tsn
)paren
suffix:semicolon
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;eat_data: skb-&gt;head %p.&bslash;n&quot;
comma
id|chunk-&gt;skb-&gt;head
)paren
suffix:semicolon
multiline_comment|/* ASSERT:  Now skb-&gt;data is really the user data.  */
multiline_comment|/* Process ECN based congestion.&n;&t; * &n;&t; * Since the chunk structure is reused for all chunks within&n;&t; * a packet, we use ecn_ce_done to track if we&squot;ve already&n;&t; * done CE processing for this packet.&n;&t; *&n;&t; * We need to do ECN processing even if we plan to discard the&n;&t; * chunk later.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|chunk-&gt;ecn_ce_done
)paren
(brace
id|chunk-&gt;ecn_ce_done
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|INET_ECN_is_ce
c_func
(paren
id|chunk-&gt;skb-&gt;nh.iph-&gt;tos
)paren
op_logical_and
id|asoc-&gt;peer.ecn_capable
)paren
(brace
multiline_comment|/* Do real work as sideffect. */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_ECN_CE
comma
id|SCTP_U32
c_func
(paren
id|tsn
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* if (packet experienced congestion) */
)brace
multiline_comment|/* if (we have not done ecn_ce processing) */
id|tmp
op_assign
id|sctp_tsnmap_check
c_func
(paren
op_amp
id|asoc-&gt;peer.tsn_map
comma
id|tsn
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
OL
l_int|0
)paren
(brace
multiline_comment|/* The TSN is too high--silently discard the chunk and&n;&t;&t; * count on it getting retransmitted later.&n;&t;&t; */
r_goto
id|discard_noforce
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|tmp
OG
l_int|0
)paren
(brace
multiline_comment|/* This is a duplicate.  Record it.  */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_REPORT_DUP
comma
id|SCTP_U32
c_func
(paren
id|tsn
)paren
)paren
suffix:semicolon
r_goto
id|discard_force
suffix:semicolon
)brace
multiline_comment|/* This is a new TSN.  */
multiline_comment|/* If we don&squot;t have any room in our receive window, discard.&n;&t; * Actually, allow a little bit of overflow (up to a MTU of&n;&t; * of overflow).&n;&t; */
id|datalen
op_assign
id|ntohs
c_func
(paren
id|chunk-&gt;chunk_hdr-&gt;length
)paren
suffix:semicolon
id|datalen
op_sub_assign
r_sizeof
(paren
id|sctp_data_chunk_t
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|asoc-&gt;rwnd
op_logical_or
(paren
id|datalen
OG
id|asoc-&gt;frag_point
)paren
)paren
(brace
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;Discarding tsn: %u datalen: %d, &quot;
l_string|&quot;rwnd: %d&bslash;n&quot;
comma
id|tsn
comma
id|datalen
comma
id|asoc-&gt;rwnd
)paren
suffix:semicolon
r_goto
id|discard_noforce
suffix:semicolon
)brace
multiline_comment|/* &n;&t; * Section 3.3.10.9 No User Data (9)&n;&t; *&n;&t; * Cause of error&n;&t; * ---------------&n;&t; * No User Data:  This error cause is returned to the originator of a&n;&t; * DATA chunk if a received DATA chunk has no user data.&n;&t; */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
l_int|0
op_eq
id|datalen
)paren
)paren
(brace
id|err
op_assign
id|sctp_make_abort_no_data
c_func
(paren
id|asoc
comma
id|chunk
comma
id|tsn
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_REPLY
comma
id|SCTP_CHUNK
c_func
(paren
id|err
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* We are going to ABORT, so we might as well stop&n;&t;&t; * processing the rest of the chunks in the packet.&n;&t;&t; */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_DISCARD_PACKET
comma
id|SCTP_NULL
c_func
(paren
)paren
)paren
suffix:semicolon
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_NEW_STATE
comma
id|SCTP_STATE
c_func
(paren
id|SCTP_STATE_CLOSED
)paren
)paren
suffix:semicolon
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_DELETE_TCB
comma
id|SCTP_NULL
c_func
(paren
)paren
)paren
suffix:semicolon
r_return
id|SCTP_DISPOSITION_CONSUME
suffix:semicolon
)brace
multiline_comment|/* We are accepting this DATA chunk. */
multiline_comment|/* Record the fact that we have received this TSN.  */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_REPORT_TSN
comma
id|SCTP_U32
c_func
(paren
id|tsn
)paren
)paren
suffix:semicolon
multiline_comment|/* RFC 2960 6.5 Stream Identifier and Stream Sequence Number&n;&t; * &n;&t; * If an endpoint receive a DATA chunk with an invalid stream &n;&t; * identifier, it shall acknowledge the reception of the DATA chunk&n;&t; * following the normal procedure, immediately send an ERROR chunk&n;&t; * with cause set to &quot;Invalid Stream Identifier&quot; (See Section 3.3.10)&n;&t; * and discard the DATA chunk. &n;&t; */
r_if
c_cond
(paren
id|ntohs
c_func
(paren
id|data_hdr-&gt;stream
)paren
op_ge
id|asoc-&gt;c.sinit_max_instreams
)paren
(brace
id|err
op_assign
id|sctp_make_op_error
c_func
(paren
id|asoc
comma
id|chunk
comma
id|SCTP_ERROR_INV_STRM
comma
op_amp
id|data_hdr-&gt;stream
comma
r_sizeof
(paren
id|data_hdr-&gt;stream
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_REPLY
comma
id|SCTP_CHUNK
c_func
(paren
id|err
)paren
)paren
suffix:semicolon
)brace
r_goto
id|discard_noforce
suffix:semicolon
)brace
multiline_comment|/* Send the data up to the user.  Note:  Schedule  the&n;&t; * SCTP_CMD_CHUNK_ULP cmd before the SCTP_CMD_GEN_SACK, as the SACK &n;&t; * chunk needs the updated rwnd.&n;&t; */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_CHUNK_ULP
comma
id|SCTP_CHUNK
c_func
(paren
id|chunk
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|asoc-&gt;autoclose
)paren
(brace
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_TIMER_RESTART
comma
id|SCTP_TO
c_func
(paren
id|SCTP_EVENT_TIMEOUT_AUTOCLOSE
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* If this is the last chunk in a packet, we need to count it&n;         * toward sack generation.  Note that we need to SACK every&n;         * OTHER packet containing data chunks, EVEN IF WE DISCARD&n;         * THEM.  We elect to NOT generate SACK&squot;s if the chunk fails&n;         * the verification tag test.&n;&t; *&n;&t; * RFC 2960 6.2 Acknowledgement on Reception of DATA Chunks&n;&t; *&n;&t; * The SCTP endpoint MUST always acknowledge the reception of&n;&t; * each valid DATA chunk.&n;&t; * &n;&t; * The guidelines on delayed acknowledgement algorithm&n;&t; * specified in  Section 4.2 of [RFC2581] SHOULD be followed.&n;&t; * Specifically, an acknowledgement SHOULD be generated for at&n;&t; * least every second packet (not every second DATA chunk)&n;&t; * received, and SHOULD be generated within 200 ms of the&n;&t; * arrival of any unacknowledged DATA chunk.  In some&n;&t; * situations it may be beneficial for an SCTP transmitter to&n;&t; * be more conservative than the algorithms detailed in this&n;&t; * document allow. However, an SCTP transmitter MUST NOT be&n;&t; * more aggressive than the following algorithms allow.&n;         */
r_if
c_cond
(paren
id|chunk-&gt;end_of_packet
)paren
(brace
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_GEN_SACK
comma
id|SCTP_NOFORCE
c_func
(paren
)paren
)paren
suffix:semicolon
multiline_comment|/* Start the SACK timer.  */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_TIMER_RESTART
comma
id|SCTP_TO
c_func
(paren
id|SCTP_EVENT_TIMEOUT_SACK
)paren
)paren
suffix:semicolon
)brace
r_return
id|SCTP_DISPOSITION_CONSUME
suffix:semicolon
id|discard_force
suffix:colon
multiline_comment|/* RFC 2960 6.2 Acknowledgement on Reception of DATA Chunks&n;&t; *&n;&t; * When a packet arrives with duplicate DATA chunk(s) and with&n;&t; * no new DATA chunk(s), the endpoint MUST immediately send a&n;&t; * SACK with no delay.  If a packet arrives with duplicate&n;&t; * DATA chunk(s) bundled with new DATA chunks, the endpoint&n;&t; * MAY immediately send a SACK.  Normally receipt of duplicate&n;&t; * DATA chunks will occur when the original SACK chunk was lost&n;&t; * and the peer&squot;s RTO has expired.  The duplicate TSN number(s)&n;&t; * SHOULD be reported in the SACK as duplicate.&n;&t; */
multiline_comment|/* In our case, we split the MAY SACK advice up whether or not&n;&t; * the last chunk is a duplicate.&squot;&n;&t; */
r_if
c_cond
(paren
id|chunk-&gt;end_of_packet
)paren
(brace
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_GEN_SACK
comma
id|SCTP_FORCE
c_func
(paren
)paren
)paren
suffix:semicolon
)brace
r_return
id|SCTP_DISPOSITION_DISCARD
suffix:semicolon
id|discard_noforce
suffix:colon
r_if
c_cond
(paren
id|chunk-&gt;end_of_packet
)paren
(brace
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_GEN_SACK
comma
id|SCTP_NOFORCE
c_func
(paren
)paren
)paren
suffix:semicolon
multiline_comment|/* Start the SACK timer.  */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_TIMER_RESTART
comma
id|SCTP_TO
c_func
(paren
id|SCTP_EVENT_TIMEOUT_SACK
)paren
)paren
suffix:semicolon
)brace
r_return
id|SCTP_DISPOSITION_DISCARD
suffix:semicolon
)brace
multiline_comment|/* sctp_sf_eat_data_6_2() */
multiline_comment|/*&n; * sctp_sf_eat_data_fast_4_4&n; * &n; * Section: 4 (4)&n; * (4) In SHUTDOWN-SENT state the endpoint MUST acknowledge any received&n; *    DATA chunks without delay.&n; *&n; * Verification Tag:  8.5 Verification Tag [Normal verification]&n; * Inputs&n; * (endpoint, asoc, chunk)&n; * &n; * Outputs&n; * (asoc, reply_msg, msg_up, timers, counters)&n; *&n; * The return value is the disposition of the chunk.&n; */
id|sctp_disposition_t
DECL|function|sctp_sf_eat_data_fast_4_4
id|sctp_sf_eat_data_fast_4_4
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
r_const
id|sctp_subtype_t
id|type
comma
r_void
op_star
id|arg
comma
id|sctp_cmd_seq_t
op_star
id|commands
)paren
(brace
id|sctp_chunk_t
op_star
id|chunk
op_assign
id|arg
suffix:semicolon
id|sctp_datahdr_t
op_star
id|data_hdr
suffix:semicolon
id|sctp_chunk_t
op_star
id|err
suffix:semicolon
r_int
id|datalen
suffix:semicolon
r_int
id|tmp
suffix:semicolon
r_uint32
id|tsn
suffix:semicolon
multiline_comment|/* RFC 2960 8.5 Verification Tag&n;&t; *&n;&t; * When receiving an SCTP packet, the endpoint MUST ensure&n;         * that the value in the Verification Tag field of the&n;         * received SCTP packet matches its own Tag.&n;&t; */
r_if
c_cond
(paren
id|ntohl
c_func
(paren
id|chunk-&gt;sctp_hdr-&gt;vtag
)paren
op_ne
id|asoc-&gt;c.my_vtag
)paren
(brace
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_REPORT_BAD_TAG
comma
id|SCTP_NULL
c_func
(paren
)paren
)paren
suffix:semicolon
r_return
id|sctp_sf_pdiscard
c_func
(paren
id|ep
comma
id|asoc
comma
id|type
comma
id|arg
comma
id|commands
)paren
suffix:semicolon
)brace
id|data_hdr
op_assign
id|chunk-&gt;subh.data_hdr
op_assign
(paren
id|sctp_datahdr_t
op_star
)paren
id|chunk-&gt;skb-&gt;data
suffix:semicolon
id|skb_pull
c_func
(paren
id|chunk-&gt;skb
comma
r_sizeof
(paren
id|sctp_datahdr_t
)paren
)paren
suffix:semicolon
id|tsn
op_assign
id|ntohl
c_func
(paren
id|data_hdr-&gt;tsn
)paren
suffix:semicolon
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;eat_data: TSN 0x%x.&bslash;n&quot;
comma
id|tsn
)paren
suffix:semicolon
multiline_comment|/* ASSERT:  Now skb-&gt;data is really the user data.  */
multiline_comment|/* Process ECN based congestion.&n;&t; * &n;&t; * Since the chunk structure is reused for all chunks within&n;&t; * a packet, we use ecn_ce_done to track if we&squot;ve already&n;&t; * done CE processing for this packet.&n;&t; *&n;&t; * We need to do ECN processing even if we plan to discard the&n;&t; * chunk later.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|chunk-&gt;ecn_ce_done
)paren
(brace
id|chunk-&gt;ecn_ce_done
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|INET_ECN_is_ce
c_func
(paren
id|chunk-&gt;skb-&gt;nh.iph-&gt;tos
)paren
op_logical_and
id|asoc-&gt;peer.ecn_capable
)paren
(brace
multiline_comment|/* Do real work as sideffect. */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_ECN_CE
comma
id|SCTP_U32
c_func
(paren
id|tsn
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* if (packet experienced congestion) */
)brace
multiline_comment|/* if (we have not done ecn_ce processing) */
id|tmp
op_assign
id|sctp_tsnmap_check
c_func
(paren
op_amp
id|asoc-&gt;peer.tsn_map
comma
id|tsn
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
OL
l_int|0
)paren
(brace
multiline_comment|/* The TSN is too high--silently discard the chunk and&n;&t;&t; * count on it getting retransmitted later.&n;&t;&t; */
r_goto
id|gen_shutdown
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|tmp
OG
l_int|0
)paren
(brace
multiline_comment|/* This is a duplicate.  Record it.  */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_REPORT_DUP
comma
id|SCTP_U32
c_func
(paren
id|tsn
)paren
)paren
suffix:semicolon
r_goto
id|gen_shutdown
suffix:semicolon
)brace
multiline_comment|/* This is a new TSN.  */
id|datalen
op_assign
id|ntohs
c_func
(paren
id|chunk-&gt;chunk_hdr-&gt;length
)paren
suffix:semicolon
id|datalen
op_sub_assign
r_sizeof
(paren
id|sctp_data_chunk_t
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * Section 3.3.10.9 No User Data (9)&n;&t; *&n;&t; * Cause of error&n;&t; * ---------------&n;&t; * No User Data:  This error cause is returned to the originator of a&n;&t; * DATA chunk if a received DATA chunk has no user data.&n;&t; */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
l_int|0
op_eq
id|datalen
)paren
)paren
(brace
id|err
op_assign
id|sctp_make_abort_no_data
c_func
(paren
id|asoc
comma
id|chunk
comma
id|tsn
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_REPLY
comma
id|SCTP_CHUNK
c_func
(paren
id|err
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* We are going to ABORT, so we might as well stop&n;&t;&t; * processing the rest of the chunks in the packet.&n;&t;&t; */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_DISCARD_PACKET
comma
id|SCTP_NULL
c_func
(paren
)paren
)paren
suffix:semicolon
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_NEW_STATE
comma
id|SCTP_STATE
c_func
(paren
id|SCTP_STATE_CLOSED
)paren
)paren
suffix:semicolon
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_DELETE_TCB
comma
id|SCTP_NULL
c_func
(paren
)paren
)paren
suffix:semicolon
r_return
id|SCTP_DISPOSITION_CONSUME
suffix:semicolon
)brace
multiline_comment|/* We are accepting this DATA chunk. */
multiline_comment|/* Record the fact that we have received this TSN.  */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_REPORT_TSN
comma
id|SCTP_U32
c_func
(paren
id|tsn
)paren
)paren
suffix:semicolon
multiline_comment|/* RFC 2960 6.5 Stream Identifier and Stream Sequence Number&n;&t; * &n;&t; * If an endpoint receive a DATA chunk with an invalid stream &n;&t; * identifier, it shall acknowledge the reception of the DATA chunk&n;&t; * following the normal procedure, immediately send an ERROR chunk&n;&t; * with cause set to &quot;Invalid Stream Identifier&quot; (See Section 3.3.10)&n;&t; * and discard the DATA chunk. &n;&t; */
r_if
c_cond
(paren
id|ntohs
c_func
(paren
id|data_hdr-&gt;stream
)paren
op_ge
id|asoc-&gt;c.sinit_max_instreams
)paren
(brace
id|err
op_assign
id|sctp_make_op_error
c_func
(paren
id|asoc
comma
id|chunk
comma
id|SCTP_ERROR_INV_STRM
comma
op_amp
id|data_hdr-&gt;stream
comma
r_sizeof
(paren
id|data_hdr-&gt;stream
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_REPLY
comma
id|SCTP_CHUNK
c_func
(paren
id|err
)paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Go a head and force a SACK, since we are shutting down. */
id|gen_shutdown
suffix:colon
multiline_comment|/* Implementor&squot;s Guide.  &n;&t; *&n;&t; * While in SHUTDOWN-SENT state, the SHUTDOWN sender MUST immediately&n;&t; * respond to each received packet containing one or more DATA chunk(s)&n;&t; * with a SACK, a SHUTDOWN chunk, and restart the T2-shutdown timer&n;&t; */
r_if
c_cond
(paren
id|chunk-&gt;end_of_packet
)paren
(brace
multiline_comment|/* We must delay the chunk creation since the cumulative&n;&t;&t; * TSN has not been updated yet.  &n;&t;&t; */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_GEN_SHUTDOWN
comma
id|SCTP_NULL
c_func
(paren
)paren
)paren
suffix:semicolon
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_GEN_SACK
comma
id|SCTP_FORCE
c_func
(paren
)paren
)paren
suffix:semicolon
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_TIMER_RESTART
comma
id|SCTP_TO
c_func
(paren
id|SCTP_EVENT_TIMEOUT_T2_SHUTDOWN
)paren
)paren
suffix:semicolon
)brace
r_return
id|SCTP_DISPOSITION_CONSUME
suffix:semicolon
)brace
multiline_comment|/* sctp_sf_eat_data_fast4_4() */
multiline_comment|/*&n; * Section: 6.2  Processing a Received SACK&n; * D) Any time a SACK arrives, the endpoint performs the following:&n; * &n; *     i) If Cumulative TSN Ack is less than the Cumulative TSN Ack Point,&n; *     then drop the SACK.   Since Cumulative TSN Ack is monotonically&n; *     increasing, a SACK whose Cumulative TSN Ack is less than the&n; *     Cumulative TSN Ack Point indicates an out-of-order SACK.&n; * &n; *     ii) Set rwnd equal to the newly received a_rwnd minus the number&n; *     of bytes still outstanding after processing the Cumulative TSN Ack&n; *     and the Gap Ack Blocks.&n; * &n; *     iii) If the SACK is missing a TSN that was previously&n; *     acknowledged via a Gap Ack Block (e.g., the data receiver&n; *     reneged on the data), then mark the corresponding DATA chunk&n; *     as available for retransmit:  Mark it as missing for fast&n; *     retransmit as described in Section 7.2.4 and if no retransmit&n; *     timer is running for the destination address to which the DATA&n; *     chunk was originally transmitted, then T3-rtx is started for&n; *     that destination address.&n; * &n; * Verification Tag:  8.5 Verification Tag [Normal verification]&n; *&n; * Inputs&n; * (endpoint, asoc, chunk)&n; * &n; * Outputs&n; * (asoc, reply_msg, msg_up, timers, counters)&n; *&n; * The return value is the disposition of the chunk.&n; */
id|sctp_disposition_t
DECL|function|sctp_sf_eat_sack_6_2
id|sctp_sf_eat_sack_6_2
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
r_const
id|sctp_subtype_t
id|type
comma
r_void
op_star
id|arg
comma
id|sctp_cmd_seq_t
op_star
id|commands
)paren
(brace
id|sctp_chunk_t
op_star
id|chunk
op_assign
id|arg
suffix:semicolon
id|sctp_sackhdr_t
op_star
id|sackh
suffix:semicolon
r_uint32
id|ctsn
suffix:semicolon
multiline_comment|/* 8.5 When receiving an SCTP packet, the endpoint MUST ensure&n;         * that the value in the Verification Tag field of the&n;         * received SCTP packet matches its own Tag. ...&n;         */
r_if
c_cond
(paren
id|ntohl
c_func
(paren
id|chunk-&gt;sctp_hdr-&gt;vtag
)paren
op_ne
id|asoc-&gt;c.my_vtag
)paren
(brace
r_return
id|sctp_sf_pdiscard
c_func
(paren
id|ep
comma
id|asoc
comma
id|type
comma
id|arg
comma
id|commands
)paren
suffix:semicolon
)brace
multiline_comment|/* Pull the SACK chunk from the data buffer */
id|sackh
op_assign
id|sctp_sm_pull_sack
c_func
(paren
id|chunk
)paren
suffix:semicolon
id|chunk-&gt;subh.sack_hdr
op_assign
id|sackh
suffix:semicolon
id|ctsn
op_assign
id|ntohl
c_func
(paren
id|sackh-&gt;cum_tsn_ack
)paren
suffix:semicolon
multiline_comment|/* i) If Cumulative TSN Ack is less than the Cumulative TSN&n;         *     Ack Point, then drop the SACK.  Since Cumulative TSN&n;         *     Ack is monotonically increasing, a SACK whose&n;         *     Cumulative TSN Ack is less than the Cumulative TSN Ack&n;         *     Point indicates an out-of-order SACK.&n;         */
r_if
c_cond
(paren
id|TSN_lt
c_func
(paren
id|ctsn
comma
id|asoc-&gt;ctsn_ack_point
)paren
)paren
(brace
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;ctsn %x&bslash;n&quot;
comma
id|ctsn
)paren
suffix:semicolon
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;ctsn_ack_point %x&bslash;n&quot;
comma
id|asoc-&gt;ctsn_ack_point
)paren
suffix:semicolon
r_return
id|SCTP_DISPOSITION_DISCARD
suffix:semicolon
)brace
multiline_comment|/* Return this SACK for further processing.  */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_PROCESS_SACK
comma
id|SCTP_SACKH
c_func
(paren
id|sackh
)paren
)paren
suffix:semicolon
multiline_comment|/* Note: We do the rest of the work on the PROCESS_SACK &n;&t; * sideeffect.&n;&t; */
r_return
id|SCTP_DISPOSITION_CONSUME
suffix:semicolon
)brace
multiline_comment|/* sctp_sf_eat_sack_6_2() */
multiline_comment|/*&n; * Generate an ABORT in response to a packet.&n; * &n; * Section: 8.4 Handle &quot;Out of the blue&quot; Packets&n; *&n; * 8) The receiver should respond to the sender of the OOTB packet&n; *    with an ABORT.  When sending the ABORT, the receiver of the&n; *    OOTB packet MUST fill in the Verification Tag field of the&n; *    outbound packet with the value found in the Verification Tag&n; *    field of the OOTB packet and set the T-bit in the Chunk Flags&n; *    to indicate that no TCB was found.  After sending this ABORT,&n; *    the receiver of the OOTB packet shall discard the OOTB packet&n; *    and take no further action.&n; *&n; * Verification Tag:&n; *&n; * The return value is the disposition of the chunk.  */
id|sctp_disposition_t
DECL|function|sctp_sf_tabort_8_4_8
id|sctp_sf_tabort_8_4_8
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
r_const
id|sctp_subtype_t
id|type
comma
r_void
op_star
id|arg
comma
id|sctp_cmd_seq_t
op_star
id|commands
)paren
(brace
id|sctp_packet_t
op_star
id|packet
op_assign
l_int|NULL
suffix:semicolon
id|sctp_transport_t
op_star
id|transport
op_assign
l_int|NULL
suffix:semicolon
id|sctp_chunk_t
op_star
id|chunk
op_assign
id|arg
suffix:semicolon
id|sctp_chunk_t
op_star
m_abort
suffix:semicolon
r_uint16
id|sport
suffix:semicolon
r_uint16
id|dport
suffix:semicolon
r_uint32
id|vtag
suffix:semicolon
multiline_comment|/* Grub in chunk and endpoint for kewl bitz. */
id|sport
op_assign
id|ntohs
c_func
(paren
id|chunk-&gt;sctp_hdr-&gt;dest
)paren
suffix:semicolon
id|dport
op_assign
id|ntohs
c_func
(paren
id|chunk-&gt;sctp_hdr-&gt;source
)paren
suffix:semicolon
multiline_comment|/* -- Make sure the ABORT packet&squot;s V-tag is the same as the&n;         *    inbound packet if no association exists, otherwise use&n;         *    the peer&squot;s vtag.&n;         */
r_if
c_cond
(paren
id|asoc
)paren
(brace
id|vtag
op_assign
id|asoc-&gt;peer.i.init_tag
suffix:semicolon
)brace
r_else
(brace
id|vtag
op_assign
id|ntohl
c_func
(paren
id|chunk-&gt;sctp_hdr-&gt;vtag
)paren
suffix:semicolon
)brace
multiline_comment|/* Make a transport for the bucket, Eliza... */
id|transport
op_assign
id|sctp_transport_new
c_func
(paren
id|sctp_source
c_func
(paren
id|chunk
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|transport
)paren
(brace
r_goto
id|nomem
suffix:semicolon
)brace
multiline_comment|/* Make a packet for the ABORT to go into. */
id|packet
op_assign
id|t_new
c_func
(paren
id|sctp_packet_t
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|packet
)paren
(brace
r_goto
id|nomem_packet
suffix:semicolon
)brace
id|packet
op_assign
id|sctp_packet_init
c_func
(paren
id|packet
comma
id|transport
comma
id|sport
comma
id|dport
)paren
suffix:semicolon
id|packet
op_assign
id|sctp_packet_config
c_func
(paren
id|packet
comma
id|vtag
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* Make an ABORT.&n;         * This will set the T bit since we have no association.&n;         */
m_abort
op_assign
id|sctp_make_abort
c_func
(paren
l_int|NULL
comma
id|chunk
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|NULL
op_eq
m_abort
)paren
(brace
r_goto
id|nomem_chunk
suffix:semicolon
)brace
multiline_comment|/* Set the skb to the belonging sock for accounting.  */
m_abort
op_member_access_from_pointer
id|skb-&gt;sk
op_assign
id|ep-&gt;base.sk
suffix:semicolon
id|sctp_packet_append_chunk
c_func
(paren
id|packet
comma
m_abort
)paren
suffix:semicolon
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_SEND_PKT
comma
id|SCTP_PACKET
c_func
(paren
id|packet
)paren
)paren
suffix:semicolon
r_return
id|SCTP_DISPOSITION_DISCARD
suffix:semicolon
id|nomem_chunk
suffix:colon
id|sctp_packet_free
c_func
(paren
id|packet
)paren
suffix:semicolon
id|nomem_packet
suffix:colon
id|sctp_transport_free
c_func
(paren
id|transport
)paren
suffix:semicolon
id|nomem
suffix:colon
r_return
id|SCTP_DISPOSITION_NOMEM
suffix:semicolon
)brace
multiline_comment|/* sctp_sf_tabort_8_4_8() */
multiline_comment|/*&n; * Received an ERROR chunk from peer.  Generate SCTP_REMOTE_ERROR &n; * event as ULP notification for each cause included in the chunk.&n; * &n; * API 5.3.1.3 - SCTP_REMOTE_ERROR &n; *&n; * The return value is the disposition of the chunk.  */
id|sctp_disposition_t
DECL|function|sctp_sf_operr_notify
id|sctp_sf_operr_notify
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
r_const
id|sctp_subtype_t
id|type
comma
r_void
op_star
id|arg
comma
id|sctp_cmd_seq_t
op_star
id|commands
)paren
(brace
id|sctp_chunk_t
op_star
id|chunk
op_assign
id|arg
suffix:semicolon
id|sctp_ulpevent_t
op_star
id|ev
suffix:semicolon
r_while
c_loop
(paren
id|chunk-&gt;chunk_end
OG
id|chunk-&gt;skb-&gt;data
)paren
(brace
id|ev
op_assign
id|sctp_ulpevent_make_remote_error
c_func
(paren
id|asoc
comma
id|chunk
comma
l_int|0
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ev
)paren
(brace
r_goto
id|nomem
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|sctp_add_cmd
c_func
(paren
id|commands
comma
id|SCTP_CMD_EVENT_ULP
comma
id|SCTP_ULPEVENT
c_func
(paren
id|ev
)paren
)paren
)paren
(brace
id|sctp_ulpevent_free
c_func
(paren
id|ev
)paren
suffix:semicolon
r_goto
id|nomem
suffix:semicolon
)brace
)brace
r_return
id|SCTP_DISPOSITION_CONSUME
suffix:semicolon
id|nomem
suffix:colon
r_return
id|SCTP_DISPOSITION_NOMEM
suffix:semicolon
)brace
multiline_comment|/* sctp_sf_operr_notify() */
multiline_comment|/*&n; * Process an inbound SHUTDOWN ACK.&n; * &n; * From Section 9.2: &n; * Upon the receipt of the SHUTDOWN ACK, the SHUTDOWN sender shall&n; * stop the T2-shutdown timer, send a SHUTDOWN COMPLETE chunk to its&n; * peer, and remove all record of the association.&n; *&n; * The return value is the disposition.  */
id|sctp_disposition_t
DECL|function|sctp_sf_do_9_2_final
id|sctp_sf_do_9_2_final
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
r_const
id|sctp_subtype_t
id|type
comma
r_void
op_star
id|arg
comma
id|sctp_cmd_seq_t
op_star
id|commands
)paren
(brace
id|sctp_chunk_t
op_star
id|chunk
op_assign
id|arg
suffix:semicolon
id|sctp_chunk_t
op_star
id|reply
suffix:semicolon
id|sctp_ulpevent_t
op_star
id|ev
suffix:semicolon
multiline_comment|/* 10.2 H) SHUTDOWN COMPLETE notification&n;         * &n;         * When SCTP completes the shutdown procedures (section 9.2) this&n;         * notification is passed to the upper layer.&n;         */
id|ev
op_assign
id|sctp_ulpevent_make_assoc_change
c_func
(paren
id|asoc
comma
l_int|0
comma
id|SCTP_SHUTDOWN_COMP
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ev
)paren
(brace
r_goto
id|nomem
suffix:semicolon
)brace
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_EVENT_ULP
comma
id|SCTP_ULPEVENT
c_func
(paren
id|ev
)paren
)paren
suffix:semicolon
multiline_comment|/* Upon the receipt of the SHUTDOWN ACK, the SHUTDOWN sender shall&n;         * stop the T2-shutdown timer,&n;         */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_TIMER_STOP
comma
id|SCTP_TO
c_func
(paren
id|SCTP_EVENT_TIMEOUT_T2_SHUTDOWN
)paren
)paren
suffix:semicolon
multiline_comment|/* ...send a SHUTDOWN COMPLETE chunk to its peer, */
id|reply
op_assign
id|sctp_make_shutdown_complete
c_func
(paren
id|asoc
comma
id|chunk
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|reply
)paren
(brace
r_goto
id|nomem
suffix:semicolon
)brace
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_NEW_STATE
comma
id|SCTP_STATE
c_func
(paren
id|SCTP_STATE_CLOSED
)paren
)paren
suffix:semicolon
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_REPLY
comma
id|SCTP_CHUNK
c_func
(paren
id|reply
)paren
)paren
suffix:semicolon
multiline_comment|/* ...and remove all record of the association. */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_DELETE_TCB
comma
id|SCTP_NULL
c_func
(paren
)paren
)paren
suffix:semicolon
r_return
id|SCTP_DISPOSITION_DELETE_TCB
suffix:semicolon
id|nomem
suffix:colon
r_return
id|SCTP_DISPOSITION_NOMEM
suffix:semicolon
)brace
multiline_comment|/* sctp_sf_do_9_2_final() */
multiline_comment|/*&n; * RFC 2960, 8.4 - Handle &quot;Out of the blue&quot; Packets&n; * 5) If the packet contains a SHUTDOWN ACK chunk, the receiver should&n; *    respond to the sender of the OOTB packet with a SHUTDOWN COMPLETE.&n; *    When sending the SHUTDOWN COMPLETE, the receiver of the OOTB&n; *    packet must fill in the Verification Tag field of the outbound&n; *    packet with the Verification Tag received in the SHUTDOWN ACK and&n; *    set the T-bit in the Chunk Flags to indicate that no TCB was&n; *    found. Otherwise,&n; *&n; * 8) The receiver should respond to the sender of the OOTB packet with&n; *    an ABORT.  When sending the ABORT, the receiver of the OOTB packet&n; *    MUST fill in the Verification Tag field of the outbound packet&n; *    with the value found in the Verification Tag field of the OOTB&n; *    packet and set the T-bit in the Chunk Flags to indicate that no&n; *    TCB was found.  After sending this ABORT, the receiver of the OOTB&n; *    packet shall discard the OOTB packet and take no further action.&n; */
id|sctp_disposition_t
DECL|function|sctp_sf_ootb
id|sctp_sf_ootb
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
r_const
id|sctp_subtype_t
id|type
comma
r_void
op_star
id|arg
comma
id|sctp_cmd_seq_t
op_star
id|commands
)paren
(brace
id|sctp_chunk_t
op_star
id|chunk
op_assign
id|arg
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
op_assign
id|chunk-&gt;skb
suffix:semicolon
id|sctp_chunkhdr_t
op_star
id|ch
suffix:semicolon
r_uint8
op_star
id|ch_end
suffix:semicolon
r_int
id|ootb_shut_ack
op_assign
l_int|0
suffix:semicolon
id|ch
op_assign
(paren
id|sctp_chunkhdr_t
op_star
)paren
id|chunk-&gt;chunk_hdr
suffix:semicolon
r_do
(brace
id|ch_end
op_assign
(paren
(paren
r_uint8
op_star
)paren
id|ch
)paren
op_plus
id|WORD_ROUND
c_func
(paren
id|ntohs
c_func
(paren
id|ch-&gt;length
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SCTP_CID_SHUTDOWN_ACK
op_eq
id|ch-&gt;type
)paren
(brace
id|ootb_shut_ack
op_assign
l_int|1
suffix:semicolon
)brace
id|ch
op_assign
(paren
id|sctp_chunkhdr_t
op_star
)paren
id|ch_end
suffix:semicolon
)brace
r_while
c_loop
(paren
id|ch_end
OL
id|skb-&gt;tail
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ootb_shut_ack
)paren
(brace
id|sctp_sf_shut_8_4_5
c_func
(paren
id|ep
comma
id|asoc
comma
id|type
comma
id|arg
comma
id|commands
)paren
suffix:semicolon
)brace
r_else
(brace
id|sctp_sf_tabort_8_4_8
c_func
(paren
id|ep
comma
id|asoc
comma
id|type
comma
id|arg
comma
id|commands
)paren
suffix:semicolon
)brace
r_return
id|sctp_sf_pdiscard
c_func
(paren
id|ep
comma
id|asoc
comma
id|type
comma
id|arg
comma
id|commands
)paren
suffix:semicolon
)brace
multiline_comment|/* sctp_sf_ootb() */
multiline_comment|/*&n; * Handle an &quot;Out of the blue&quot; SHUTDOWN ACK.&n; *&n; * Section: 8.4 5)&n; * 5) If the packet contains a SHUTDOWN ACK chunk, the receiver should &n; *   respond to the sender of the OOTB packet with a SHUTDOWN COMPLETE.  &n; *   When sending the SHUTDOWN COMPLETE, the receiver of the OOTB packet &n; *   must fill in the Verification Tag field of the outbound packet with &n; *   the Verification Tag received in the SHUTDOWN ACK and set the &n; *   T-bit in the Chunk Flags to indicate that no TCB was found. &n; * &n; * Verification Tag:  8.5.1 E) Rules for packet carrying a SHUTDOWN ACK&n; *   If the receiver is in COOKIE-ECHOED or COOKIE-WAIT state the&n; *   procedures in section 8.4 SHOULD be followed, in other words it&n; *   should be treated as an Out Of The Blue packet.&n; *   [This means that we do NOT check the Verification Tag on these&n; *   chunks. --piggy ]&n; *&n; * Inputs&n; * (endpoint, asoc, type, arg, commands)&n; * &n; * Outputs&n; * (sctp_disposition_t)&n; *&n; * The return value is the disposition of the chunk.&n; */
id|sctp_disposition_t
DECL|function|sctp_sf_shut_8_4_5
id|sctp_sf_shut_8_4_5
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
r_const
id|sctp_subtype_t
id|type
comma
r_void
op_star
id|arg
comma
id|sctp_cmd_seq_t
op_star
id|commands
)paren
(brace
id|sctp_packet_t
op_star
id|packet
op_assign
l_int|NULL
suffix:semicolon
id|sctp_transport_t
op_star
id|transport
op_assign
l_int|NULL
suffix:semicolon
id|sctp_chunk_t
op_star
id|chunk
op_assign
id|arg
suffix:semicolon
id|sctp_chunk_t
op_star
id|shut
suffix:semicolon
r_uint16
id|sport
suffix:semicolon
r_uint16
id|dport
suffix:semicolon
r_uint32
id|vtag
suffix:semicolon
multiline_comment|/* Grub in chunk and endpoint for kewl bitz. */
id|sport
op_assign
id|ntohs
c_func
(paren
id|chunk-&gt;sctp_hdr-&gt;dest
)paren
suffix:semicolon
id|dport
op_assign
id|ntohs
c_func
(paren
id|chunk-&gt;sctp_hdr-&gt;source
)paren
suffix:semicolon
multiline_comment|/* Make sure the ABORT packet&squot;s V-tag is the same as the&n;         * inbound packet if no association exists, otherwise use&n;         * the peer&squot;s vtag.&n;         */
id|vtag
op_assign
id|ntohl
c_func
(paren
id|chunk-&gt;sctp_hdr-&gt;vtag
)paren
suffix:semicolon
multiline_comment|/* Make a transport for the bucket, Eliza... */
id|transport
op_assign
id|sctp_transport_new
c_func
(paren
id|sctp_source
c_func
(paren
id|chunk
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|transport
)paren
(brace
r_goto
id|nomem
suffix:semicolon
)brace
multiline_comment|/* Make a packet for the ABORT to go into. */
id|packet
op_assign
id|t_new
c_func
(paren
id|sctp_packet_t
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|packet
)paren
(brace
r_goto
id|nomem_packet
suffix:semicolon
)brace
id|packet
op_assign
id|sctp_packet_init
c_func
(paren
id|packet
comma
id|transport
comma
id|sport
comma
id|dport
)paren
suffix:semicolon
id|packet
op_assign
id|sctp_packet_config
c_func
(paren
id|packet
comma
id|vtag
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* Make an ABORT.&n;         * This will set the T bit since we have no association.&n;         */
id|shut
op_assign
id|sctp_make_shutdown_complete
c_func
(paren
l_int|NULL
comma
id|chunk
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|shut
)paren
(brace
r_goto
id|nomem_chunk
suffix:semicolon
)brace
multiline_comment|/* Set the skb to the belonging sock for accounting.  */
id|shut-&gt;skb-&gt;sk
op_assign
id|ep-&gt;base.sk
suffix:semicolon
id|sctp_packet_append_chunk
c_func
(paren
id|packet
comma
id|shut
)paren
suffix:semicolon
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_SEND_PKT
comma
id|SCTP_PACKET
c_func
(paren
id|packet
)paren
)paren
suffix:semicolon
r_return
id|SCTP_DISPOSITION_CONSUME
suffix:semicolon
id|nomem_chunk
suffix:colon
id|sctp_packet_free
c_func
(paren
id|packet
)paren
suffix:semicolon
id|nomem_packet
suffix:colon
id|sctp_transport_free
c_func
(paren
id|transport
)paren
suffix:semicolon
id|nomem
suffix:colon
r_return
id|SCTP_DISPOSITION_NOMEM
suffix:semicolon
)brace
multiline_comment|/* sctp_sf_shut_8_4_5() */
macro_line|#if 0
multiline_comment|/*&n; * We did something stupid but got lucky.  Namely, we sent a HEARTBEAT&n; * before the association was all the way up and we did NOT get an&n; * ABORT.&n; *&n; * Log the fact and then process normally.&n; * &n; * Section: Not specified&n; * Verification Tag:  8.5 Verification Tag [Normal verification]&n; * Inputs&n; * (endpoint, asoc, chunk)&n; * &n; * Outputs&n; * (asoc, reply_msg, msg_up, timers, counters)&n; *&n; * The return value is the disposition of the chunk.&n; */
id|sctp_disposition_t
id|lucky
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
r_const
id|sctp_subtype_t
id|type
comma
r_void
op_star
id|arg
comma
id|sctp_cmd_seq_t
op_star
id|commands
)paren
(brace
id|sctp_chunk_t
op_star
id|chunk
op_assign
id|arg
suffix:semicolon
multiline_comment|/* 8.5 When receiving an SCTP packet, the endpoint MUST ensure&n;         * that the value in the Verification Tag field of the&n;         * received SCTP packet matches its own Tag. ...&n;         */
r_if
c_cond
(paren
id|chunk-&gt;sctp_hdr-&gt;vtag
op_ne
id|asoc-&gt;c.my_vtag
)paren
(brace
r_return
id|sctp_sf_pdiscard
c_func
(paren
id|ep
comma
id|asoc
comma
id|type
comma
id|arg
comma
id|commands
)paren
suffix:semicolon
)brace
r_return
id|SCTP_DISPOSITION_CONSUME
suffix:semicolon
id|nomem
suffix:colon
r_return
id|SCTP_DISPOSITION_NOMEM
suffix:semicolon
)brace
multiline_comment|/* sctp_disposition_t lucky(...) */
macro_line|#endif /* 0 */
macro_line|#if 0
multiline_comment|/*&n; * The other end is doing something very stupid.  We&squot;ll ignore them&n; * after logging their idiocy. :-)&n; * &n; * Section: Not specified&n; * Verification Tag:  8.5 Verification Tag [Normal verification]&n; * Inputs&n; * (endpoint, asoc, chunk)&n; * &n; * Outputs&n; * (asoc, reply_msg, msg_up, timers, counters)&n; *&n; * The return value is the disposition of the chunk.&n; */
id|sctp_disposition_t
id|other_stupid
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
r_const
id|sctp_subtype_t
id|type
comma
r_void
op_star
id|arg
comma
id|sctp_cmd_seq_t
op_star
id|commands
)paren
(brace
id|sctp_chunk_t
op_star
id|chunk
op_assign
id|arg
suffix:semicolon
multiline_comment|/* 8.5 When receiving an SCTP packet, the endpoint MUST ensure&n;         * that the value in the Verification Tag field of the&n;         * received SCTP packet matches its own Tag. ...&n;         */
r_if
c_cond
(paren
id|chunk-&gt;sctp_hdr-&gt;vtag
op_ne
id|asoc-&gt;c.my_vtag
)paren
(brace
r_return
id|sctp_sf_pdiscard
c_func
(paren
id|ep
comma
id|asoc
comma
id|type
comma
id|arg
comma
id|commands
)paren
suffix:semicolon
)brace
r_return
id|SCTP_DISPOSITION_CONSUME
suffix:semicolon
id|nomem
suffix:colon
r_return
id|SCTP_DISPOSITION_NOMEM
suffix:semicolon
)brace
multiline_comment|/* sctp_disposition_t other_stupid(...) */
macro_line|#endif /* 0 */
multiline_comment|/*&n; * The other end is violating protocol.&n; * &n; * Section: Not specified&n; * Verification Tag: Not specified&n; * Inputs&n; * (endpoint, asoc, chunk)&n; * &n; * Outputs&n; * (asoc, reply_msg, msg_up, timers, counters)&n; *&n; * We simply tag the chunk as a violation.  The state machine will log&n; * the violation and continue.&n; */
id|sctp_disposition_t
DECL|function|sctp_sf_violation
id|sctp_sf_violation
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
r_const
id|sctp_subtype_t
id|type
comma
r_void
op_star
id|arg
comma
id|sctp_cmd_seq_t
op_star
id|commands
)paren
(brace
r_return
id|SCTP_DISPOSITION_VIOLATION
suffix:semicolon
)brace
multiline_comment|/* sctp_sf_violation() */
multiline_comment|/***************************************************************************&n; * These are the state functions for handling primitive (Section 10) events.&n; ***************************************************************************/
multiline_comment|/*&n; * sctp_sf_do_prm_asoc&n; * &n; * Section: 10.1 ULP-to-SCTP&n; * B) Associate&n; * &n; * Format: ASSOCIATE(local SCTP instance name, destination transport addr, &n; * outbound stream count) &n; * -&gt; association id [,destination transport addr list] [,outbound stream&n; * count] &n; * &n; * This primitive allows the upper layer to initiate an association to a&n; * specific peer endpoint. &n; * &n; * The peer endpoint shall be specified by one of the transport addresses&n; * which defines the endpoint (see Section 1.4).  If the local SCTP&n; * instance has not been initialized, the ASSOCIATE is considered an&n; * error. &n; * [This is not relevant for the kernel implementation since we do all&n; * initialization at boot time.  It we hadn&squot;t initialized we wouldn&squot;t&n; * get anywhere near this code.]&n; * &n; * An association id, which is a local handle to the SCTP association,&n; * will be returned on successful establishment of the association. If&n; * SCTP is not able to open an SCTP association with the peer endpoint,&n; * an error is returned.&n; * [In the kernel implementation, the sctp_association_t needs to&n; * be created BEFORE causing this primitive to run.]&n; * &n; * Other association parameters may be returned, including the&n; * complete destination transport addresses of the peer as well as the&n; * outbound stream count of the local endpoint. One of the transport&n; * address from the returned destination addresses will be selected by&n; * the local endpoint as default primary path for sending SCTP packets&n; * to this peer.  The returned &quot;destination transport addr list&quot; can&n; * be used by the ULP to change the default primary path or to force&n; * sending a packet to a specific transport address.  [All of this&n; * stuff happens when the INIT ACK arrives.  This is a NON-BLOCKING&n; * function.]&n; * &n; * Mandatory attributes:&n; * &n; * o local SCTP instance name - obtained from the INITIALIZE operation.&n; *   [This is the argument asoc.]&n; * o destination transport addr - specified as one of the transport&n; * addresses of the peer endpoint with which the association is to be&n; * established.&n; *  [This is asoc-&gt;peer.active_path.]&n; * o outbound stream count - the number of outbound streams the ULP&n; * would like to open towards this peer endpoint.&n; * [BUG: This is not currently implemented.]&n; * Optional attributes:&n; * &n; * None.&n; * &n; * The return value is a disposition.&n; */
id|sctp_disposition_t
DECL|function|sctp_sf_do_prm_asoc
id|sctp_sf_do_prm_asoc
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
r_const
id|sctp_subtype_t
id|type
comma
r_void
op_star
id|arg
comma
id|sctp_cmd_seq_t
op_star
id|commands
)paren
(brace
id|sctp_chunk_t
op_star
id|repl
suffix:semicolon
id|sctp_bind_addr_t
op_star
id|bp
suffix:semicolon
id|sctp_scope_t
id|scope
suffix:semicolon
r_int
id|error
suffix:semicolon
r_int
id|flags
suffix:semicolon
multiline_comment|/* The comment below says that we enter COOKIE-WAIT AFTER&n;&t; * sending the INIT, but that doesn&squot;t actually work in our&n;&t; * implementation...&n;&t; */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_NEW_STATE
comma
id|SCTP_STATE
c_func
(paren
id|SCTP_STATE_COOKIE_WAIT
)paren
)paren
suffix:semicolon
multiline_comment|/* Build up the bind address list for the association based on&n;&t; * info from the local endpoint and the remote peer.&n;&t; */
id|bp
op_assign
id|sctp_bind_addr_new
c_func
(paren
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|NULL
op_eq
id|bp
)paren
(brace
r_goto
id|nomem
suffix:semicolon
)brace
multiline_comment|/* Use scoping rules to determine the subset of addresses from&n;&t; * the endpoint. &n;&t; */
id|scope
op_assign
id|sctp_scope
c_func
(paren
op_amp
id|asoc-&gt;peer.active_path-&gt;ipaddr
)paren
suffix:semicolon
id|flags
op_assign
(paren
id|PF_INET6
op_eq
id|asoc-&gt;base.sk-&gt;family
)paren
ques
c_cond
id|SCTP_ADDR6_ALLOWED
suffix:colon
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|asoc-&gt;peer.ipv4_address
)paren
(brace
id|flags
op_or_assign
id|SCTP_ADDR4_PEERSUPP
suffix:semicolon
)brace
r_if
c_cond
(paren
id|asoc-&gt;peer.ipv6_address
)paren
(brace
id|flags
op_or_assign
id|SCTP_ADDR6_PEERSUPP
suffix:semicolon
)brace
id|error
op_assign
id|sctp_bind_addr_copy
c_func
(paren
id|bp
comma
op_amp
id|ep-&gt;base.bind_addr
comma
id|scope
comma
id|GFP_ATOMIC
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|0
op_ne
id|error
)paren
(brace
r_goto
id|nomem
suffix:semicolon
)brace
multiline_comment|/* FIXME: Either move address assignment out of this function&n;&t; * or else move the association allocation/init into this function.&n;&t; * The association structure is brand new before calling this&n;&t; * function, so would not be a sideeffect if the allocation&n;&t; * moved into this function.  --jgrimm &n;&t; */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_SET_BIND_ADDR
comma
(paren
id|sctp_arg_t
)paren
id|bp
)paren
suffix:semicolon
multiline_comment|/* RFC 2960 5.1 Normal Establishment of an Association&n;         *&n;         * A) &quot;A&quot; first sends an INIT chunk to &quot;Z&quot;.  In the INIT, &quot;A&quot;&n;         * must provide its Verification Tag (Tag_A) in the Initiate&n;         * Tag field.  Tag_A SHOULD be a random number in the range of&n;         * 1 to 4294967295 (see 5.3.1 for Tag value selection). ...&n;         */
id|repl
op_assign
id|sctp_make_init
c_func
(paren
id|asoc
comma
id|bp
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|NULL
op_eq
id|repl
)paren
(brace
r_goto
id|nomem
suffix:semicolon
)brace
multiline_comment|/* Cast away the const modifier, as we want to just&n;&t; * rerun it through as a sideffect. &n;&t; */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_NEW_ASOC
comma
id|SCTP_ASOC
c_func
(paren
(paren
id|sctp_association_t
op_star
)paren
id|asoc
)paren
)paren
suffix:semicolon
multiline_comment|/* After sending the INIT, &quot;A&quot; starts the T1-init timer and&n;         * enters the COOKIE-WAIT state.&n;         */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_TIMER_START
comma
id|SCTP_TO
c_func
(paren
id|SCTP_EVENT_TIMEOUT_T1_INIT
)paren
)paren
suffix:semicolon
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_REPLY
comma
id|SCTP_CHUNK
c_func
(paren
id|repl
)paren
)paren
suffix:semicolon
r_return
id|SCTP_DISPOSITION_CONSUME
suffix:semicolon
id|nomem
suffix:colon
r_if
c_cond
(paren
id|bp
)paren
(brace
id|sctp_bind_addr_free
c_func
(paren
id|bp
)paren
suffix:semicolon
)brace
r_return
id|SCTP_DISPOSITION_NOMEM
suffix:semicolon
)brace
multiline_comment|/* sctp_sf_do_prm_asoc() */
multiline_comment|/*&n; * Process the SEND primitive.&n; * &n; * Section: 10.1 ULP-to-SCTP&n; * E) Send&n; * &n; * Format: SEND(association id, buffer address, byte count [,context]&n; *         [,stream id] [,life time] [,destination transport address] &n; *         [,unorder flag] [,no-bundle flag] [,payload protocol-id] )&n; * -&gt; result&n; * &n; * This is the main method to send user data via SCTP. &n; * &n; * Mandatory attributes:&n; * &n; *  o association id - local handle to the SCTP association&n; * &n; *  o buffer address - the location where the user message to be&n; *    transmitted is stored;&n; * &n; *  o byte count - The size of the user data in number of bytes;&n; * &n; * Optional attributes:&n; * &n; *  o context - an optional 32 bit integer that will be carried in the&n; *    sending failure notification to the ULP if the transportation of&n; *    this User Message fails.&n; * &n; *  o stream id - to indicate which stream to send the data on. If not&n; *    specified, stream 0 will be used.&n; * &n; *  o life time - specifies the life time of the user data. The user data&n; *    will not be sent by SCTP after the life time expires. This&n; *    parameter can be used to avoid efforts to transmit stale&n; *    user messages. SCTP notifies the ULP if the data cannot be&n; *    initiated to transport (i.e. sent to the destination via SCTP&squot;s&n; *    send primitive) within the life time variable. However, the&n; *    user data will be transmitted if SCTP has attempted to transmit a &n; *    chunk before the life time expired.&n; * &n; *  o destination transport address - specified as one of the destination&n; *    transport addresses of the peer endpoint to which this packet&n; *    should be sent. Whenever possible, SCTP should use this destination&n; *    transport address for sending the packets, instead of the current&n; *    primary path. &n; * &n; *  o unorder flag - this flag, if present, indicates that the user&n; *    would like the data delivered in an unordered fashion to the peer &n; *    (i.e., the U flag is set to 1 on all DATA chunks carrying this &n; *    message).&n; * &n; *  o no-bundle flag - instructs SCTP not to bundle this user data with&n; *    other outbound DATA chunks. SCTP MAY still bundle even when &n; *    this flag is present, when faced with network congestion.&n; * &n; *  o payload protocol-id - A 32 bit unsigned integer that is to be &n; *    passed to the peer indicating the type of payload protocol data &n; *    being transmitted. This value is passed as opaque data by SCTP.&n; * &n; *    &n; * The return value is the disposition.&n; */
id|sctp_disposition_t
DECL|function|sctp_sf_do_prm_send
id|sctp_sf_do_prm_send
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
r_const
id|sctp_subtype_t
id|type
comma
r_void
op_star
id|arg
comma
id|sctp_cmd_seq_t
op_star
id|commands
)paren
(brace
id|sctp_chunk_t
op_star
id|chunk
op_assign
id|arg
suffix:semicolon
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_REPLY
comma
id|SCTP_CHUNK
c_func
(paren
id|chunk
)paren
)paren
suffix:semicolon
r_return
id|SCTP_DISPOSITION_CONSUME
suffix:semicolon
)brace
multiline_comment|/* sctp_sf_do_prm_send() */
multiline_comment|/*&n; * Process the SHUTDOWN primitive.&n; * &n; * Section: 10.1:&n; * C) Shutdown&n; * &n; * Format: SHUTDOWN(association id)&n; * -&gt; result &n; * &n; * Gracefully closes an association. Any locally queued user data&n; * will be delivered to the peer. The association will be terminated only&n; * after the peer acknowledges all the SCTP packets sent.  A success code&n; * will be returned on successful termination of the association. If&n; * attempting to terminate the association results in a failure, an error&n; * code shall be returned.&n; * &n; * Mandatory attributes:&n; * &n; *  o association id - local handle to the SCTP association&n; * &n; * Optional attributes:&n; * &n; * None.&n; *&n; * The return value is the disposition.&n; */
id|sctp_disposition_t
DECL|function|sctp_sf_do_9_2_prm_shutdown
id|sctp_sf_do_9_2_prm_shutdown
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
r_const
id|sctp_subtype_t
id|type
comma
r_void
op_star
id|arg
comma
id|sctp_cmd_seq_t
op_star
id|commands
)paren
(brace
r_int
id|disposition
suffix:semicolon
multiline_comment|/* From 9.2 Shutdown of an Association&n;         * Upon receipt of the SHUTDOWN primitive from its upper&n;         * layer, the endpoint enters SHUTDOWN-PENDING state and&n;         * remains there until all outstanding data has been&n;         * acknowledged by its peer. The endpoint accepts no new data&n;         * from its upper layer, but retransmits data to the far end&n;         * if necessary to fill gaps.&n;         */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_NEW_STATE
comma
id|SCTP_STATE
c_func
(paren
id|SCTP_STATE_SHUTDOWN_PENDING
)paren
)paren
suffix:semicolon
id|disposition
op_assign
id|SCTP_DISPOSITION_CONSUME
suffix:semicolon
r_if
c_cond
(paren
id|sctp_outqueue_is_empty
c_func
(paren
op_amp
id|asoc-&gt;outqueue
)paren
)paren
(brace
id|disposition
op_assign
id|sctp_sf_do_9_2_start_shutdown
c_func
(paren
id|ep
comma
id|asoc
comma
id|type
comma
id|arg
comma
id|commands
)paren
suffix:semicolon
)brace
r_return
id|disposition
suffix:semicolon
)brace
multiline_comment|/* sctp_sf_do_9_2_prm_shutdown() */
multiline_comment|/* We tried an illegal operation on an association which is closed.  */
id|sctp_disposition_t
DECL|function|sctp_sf_error_closed
id|sctp_sf_error_closed
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
r_const
id|sctp_subtype_t
id|type
comma
r_void
op_star
id|arg
comma
id|sctp_cmd_seq_t
op_star
id|commands
)paren
(brace
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_REPORT_ERROR
comma
id|SCTP_ERROR
c_func
(paren
op_minus
id|EINVAL
)paren
)paren
suffix:semicolon
r_return
id|SCTP_DISPOSITION_CONSUME
suffix:semicolon
)brace
multiline_comment|/* sctp_sf_error_closed() */
multiline_comment|/* We tried an illegal operation on an association which is shutting&n; * down.&n; */
id|sctp_disposition_t
DECL|function|sctp_sf_error_shutdown
id|sctp_sf_error_shutdown
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
r_const
id|sctp_subtype_t
id|type
comma
r_void
op_star
id|arg
comma
id|sctp_cmd_seq_t
op_star
id|commands
)paren
(brace
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_REPORT_ERROR
comma
id|SCTP_ERROR
c_func
(paren
op_minus
id|ESHUTDOWN
)paren
)paren
suffix:semicolon
r_return
id|SCTP_DISPOSITION_CONSUME
suffix:semicolon
)brace
multiline_comment|/* sctp_sf_error_shutdown() */
multiline_comment|/*&n; * sctp_cookie_wait_prm_shutdown&n; * &n; * Section: 4 Note: 2&n; * Verification Tag:&n; * Inputs&n; * (endpoint, asoc)&n; * &n; * The RFC does not explicitly address this issue, but is the route through the&n; * state table when someone issues a shutdown while in COOKIE_WAIT state.&n; *&n; * Outputs&n; * (timers)&n; */
id|sctp_disposition_t
DECL|function|sctp_sf_cookie_wait_prm_shutdown
(def_block
id|sctp_sf_cookie_wait_prm_shutdown
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
r_const
id|sctp_subtype_t
id|type
comma
r_void
op_star
id|arg
comma
id|sctp_cmd_seq_t
op_star
id|commands
)paren
(brace
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_TIMER_STOP
comma
id|SCTP_TO
c_func
(paren
id|SCTP_EVENT_TIMEOUT_T1_INIT
)paren
)paren
suffix:semicolon
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_NEW_STATE
comma
id|SCTP_STATE
c_func
(paren
id|SCTP_STATE_CLOSED
)paren
)paren
suffix:semicolon
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_DELETE_TCB
comma
id|SCTP_NULL
c_func
(paren
)paren
)paren
suffix:semicolon
r_return
id|SCTP_DISPOSITION_DELETE_TCB
suffix:semicolon
)brace
)def_block
multiline_comment|/* sctp_sf_cookie_wait_prm_shutdown()  */
multiline_comment|/*&n; * sctp_cookie_echoed_prm_shutdown&n; * &n; * Section: 4 Note: 2&n; * Verification Tag:&n; * Inputs&n; * (endpoint, asoc)&n; * &n; * The RFC does not explcitly address this issue, but is the route through the&n; * state table when someone issues a shutdown while in COOKIE_ECHOED state.&n; *&n; * Outputs&n; * (timers)&n; */
id|sctp_disposition_t
DECL|function|sctp_sf_cookie_echoed_prm_shutdown
id|sctp_sf_cookie_echoed_prm_shutdown
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
r_const
id|sctp_subtype_t
id|type
comma
r_void
op_star
id|arg
comma
id|sctp_cmd_seq_t
op_star
id|commands
)paren
(brace
multiline_comment|/* There is a single T1 timer, so we should be able to use&n;&t; * common function with the COOKIE-WAIT state. &n;&t; */
r_return
id|sctp_sf_cookie_wait_prm_shutdown
c_func
(paren
id|ep
comma
id|asoc
comma
id|type
comma
id|arg
comma
id|commands
)paren
suffix:semicolon
)brace
multiline_comment|/* sctp_sf_cookie_echoed_prm_shutdown()  */
multiline_comment|/*&n; * Ignore the primitive event&n; *&n; * The return value is the disposition of the primitive.&n; */
id|sctp_disposition_t
DECL|function|sctp_sf_ignore_primitive
id|sctp_sf_ignore_primitive
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
r_const
id|sctp_subtype_t
id|type
comma
r_void
op_star
id|arg
comma
id|sctp_cmd_seq_t
op_star
id|commands
)paren
(brace
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;Primitive type %d is ignored.&bslash;n&quot;
comma
id|type.primitive
)paren
suffix:semicolon
r_return
id|SCTP_DISPOSITION_DISCARD
suffix:semicolon
)brace
multiline_comment|/* sctp_sf_ignore_primitive() */
multiline_comment|/***************************************************************************&n; * These are the state functions for the OTHER events.&n; ***************************************************************************/
multiline_comment|/*&n; * Start the shutdown negotiation.&n; * &n; * From Section 9.2:&n; * Once all its outstanding data has been acknowledged, the endpoint &n; * shall send a SHUTDOWN chunk to its peer including in the Cumulative &n; * TSN Ack field the last sequential TSN it has received from the peer. &n; * It shall then start the T2-shutdown timer and enter the SHUTDOWN-SENT &n; * state. If the timer expires, the endpoint must re-send the SHUTDOWN &n; * with the updated last sequential TSN received from its peer.&n; * &n; * The return value is the disposition.&n; */
id|sctp_disposition_t
DECL|function|sctp_sf_do_9_2_start_shutdown
id|sctp_sf_do_9_2_start_shutdown
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
r_const
id|sctp_subtype_t
id|type
comma
r_void
op_star
id|arg
comma
id|sctp_cmd_seq_t
op_star
id|commands
)paren
(brace
id|sctp_chunk_t
op_star
id|reply
suffix:semicolon
multiline_comment|/* Once all its outstanding data has been acknowledged, the&n;         * endpoint shall send a SHUTDOWN chunk to its peer including&n;         * in the Cumulative TSN Ack field the last sequential TSN it&n;         * has received from the peer.&n;         */
id|reply
op_assign
id|sctp_make_shutdown
c_func
(paren
id|asoc
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|NULL
op_eq
id|reply
)paren
(brace
r_goto
id|nomem
suffix:semicolon
)brace
multiline_comment|/* Set the transport for the SHUTDOWN chunk and the timeout for the&n;&t; * T2-shutdown timer.  &n;&t; */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_SETUP_T2
comma
id|SCTP_CHUNK
c_func
(paren
id|reply
)paren
)paren
suffix:semicolon
multiline_comment|/* It shall then start the T2-shutdown timer */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_TIMER_START
comma
id|SCTP_TO
c_func
(paren
id|SCTP_EVENT_TIMEOUT_T2_SHUTDOWN
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|asoc-&gt;autoclose
)paren
(brace
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_TIMER_STOP
comma
id|SCTP_TO
c_func
(paren
id|SCTP_EVENT_TIMEOUT_AUTOCLOSE
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* and enter the SHUTDOWN-SENT state.  */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_NEW_STATE
comma
id|SCTP_STATE
c_func
(paren
id|SCTP_STATE_SHUTDOWN_SENT
)paren
)paren
suffix:semicolon
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_REPLY
comma
id|SCTP_CHUNK
c_func
(paren
id|reply
)paren
)paren
suffix:semicolon
r_return
id|SCTP_DISPOSITION_CONSUME
suffix:semicolon
id|nomem
suffix:colon
r_return
id|SCTP_DISPOSITION_NOMEM
suffix:semicolon
)brace
multiline_comment|/* sctp_sf_do_9_2_start_shutdown() */
multiline_comment|/*&n; * Generate a SHUTDOWN ACK now that everything is SACK&squot;d.&n; * &n; * From Section 9.2: &n; * &n; * If it has no more outstanding DATA chunks, the SHUTDOWN receiver&n; * shall send a SHUTDOWN ACK and start a T2-shutdown timer of its own,&n; * entering the SHUTDOWN-ACK-SENT state. If the timer expires, the&n; * endpoint must re-send the SHUTDOWN ACK.&n; *&n; * The return value is the disposition.  */
id|sctp_disposition_t
DECL|function|sctp_sf_do_9_2_shutdown_ack
id|sctp_sf_do_9_2_shutdown_ack
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
r_const
id|sctp_subtype_t
id|type
comma
r_void
op_star
id|arg
comma
id|sctp_cmd_seq_t
op_star
id|commands
)paren
(brace
id|sctp_chunk_t
op_star
id|chunk
op_assign
(paren
id|sctp_chunk_t
op_star
)paren
id|arg
suffix:semicolon
id|sctp_chunk_t
op_star
id|reply
suffix:semicolon
multiline_comment|/* If it has no more outstanding DATA chunks, the SHUTDOWN receiver&n;         * shall send a SHUTDOWN ACK ...&n;         */
id|reply
op_assign
id|sctp_make_shutdown_ack
c_func
(paren
id|asoc
comma
id|chunk
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|NULL
op_eq
id|reply
)paren
(brace
r_goto
id|nomem
suffix:semicolon
)brace
multiline_comment|/* Set the transport for the SHUTDOWN ACK chunk and the timeout for &n;&t; * the T2-shutdown timer.  &n;&t; */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_SETUP_T2
comma
id|SCTP_CHUNK
c_func
(paren
id|reply
)paren
)paren
suffix:semicolon
multiline_comment|/* and start/restart a T2-shutdown timer of its own, */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_TIMER_RESTART
comma
id|SCTP_TO
c_func
(paren
id|SCTP_EVENT_TIMEOUT_T2_SHUTDOWN
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|asoc-&gt;autoclose
)paren
(brace
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_TIMER_STOP
comma
id|SCTP_TO
c_func
(paren
id|SCTP_EVENT_TIMEOUT_AUTOCLOSE
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Enter the SHUTDOWN-ACK-SENT state.  */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_NEW_STATE
comma
id|SCTP_STATE
c_func
(paren
id|SCTP_STATE_SHUTDOWN_ACK_SENT
)paren
)paren
suffix:semicolon
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_REPLY
comma
id|SCTP_CHUNK
c_func
(paren
id|reply
)paren
)paren
suffix:semicolon
r_return
id|SCTP_DISPOSITION_CONSUME
suffix:semicolon
id|nomem
suffix:colon
r_return
id|SCTP_DISPOSITION_NOMEM
suffix:semicolon
)brace
multiline_comment|/* sctp_sf_do_9_2_shutdown_ack() */
multiline_comment|/*&n; * Ignore the event defined as other&n; *&n; * The return value is the disposition of the event.&n; */
id|sctp_disposition_t
DECL|function|sctp_sf_ignore_other
id|sctp_sf_ignore_other
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
r_const
id|sctp_subtype_t
id|type
comma
r_void
op_star
id|arg
comma
id|sctp_cmd_seq_t
op_star
id|commands
)paren
(brace
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;The event other type %d is ignored&bslash;n&quot;
comma
id|type.other
)paren
suffix:semicolon
r_return
id|SCTP_DISPOSITION_DISCARD
suffix:semicolon
)brace
multiline_comment|/* sctp_sf_ignore_primitive() */
multiline_comment|/************************************************************&n; * These are the state functions for handling timeout events.&n; ************************************************************/
multiline_comment|/*&n; * RTX Timeout&n; * &n; * Section: 6.3.3 Handle T3-rtx Expiration&n; * &n; * Whenever the retransmission timer T3-rtx expires for a destination&n; * address, do the following:&n; * [See below]&n; *&n; * The return value is the disposition of the chunk.&n; */
id|sctp_disposition_t
DECL|function|sctp_sf_do_6_3_3_rtx
id|sctp_sf_do_6_3_3_rtx
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
r_const
id|sctp_subtype_t
id|type
comma
r_void
op_star
id|arg
comma
id|sctp_cmd_seq_t
op_star
id|commands
)paren
(brace
id|sctp_transport_t
op_star
id|transport
op_assign
id|arg
suffix:semicolon
r_if
c_cond
(paren
id|asoc-&gt;overall_error_count
op_ge
id|asoc-&gt;overall_error_threshold
)paren
(brace
multiline_comment|/* CMD_ASSOC_FAILED calls CMD_DELETE_TCB. */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_ASSOC_FAILED
comma
id|SCTP_NULL
c_func
(paren
)paren
)paren
suffix:semicolon
r_return
id|SCTP_DISPOSITION_DELETE_TCB
suffix:semicolon
)brace
multiline_comment|/* E1) For the destination address for which the timer&n;         * expires, adjust its ssthresh with rules defined in Section&n;         * 7.2.3 and set the cwnd &lt;- MTU.&n;         */
multiline_comment|/* E2) For the destination address for which the timer&n;         * expires, set RTO &lt;- RTO * 2 (&quot;back off the timer&quot;).  The&n;         * maximum value discussed in rule C7 above (RTO.max) may be&n;         * used to provide an upper bound to this doubling operation.&n;         */
multiline_comment|/* E3) Determine how many of the earliest (i.e., lowest TSN)&n;         * outstanding DATA chunks for the address for which the&n;         * T3-rtx has expired will fit into a single packet, subject&n;         * to the MTU constraint for the path corresponding to the&n;         * destination transport address to which the retransmission&n;         * is being sent (this may be different from the address for&n;         * which the timer expires [see Section 6.4]).  Call this&n;         * value K. Bundle and retransmit those K DATA chunks in a&n;         * single packet to the destination endpoint.&n;         * &n;         * Note: Any DATA chunks that were sent to the address for&n;         * which the T3-rtx timer expired but did not fit in one MTU&n;         * (rule E3 above), should be marked for retransmission and&n;         * sent as soon as cwnd allows (normally when a SACK arrives).&n;         */
multiline_comment|/* NB: Rules E4 and F1 are implicit in R1.  */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_RETRAN
comma
id|SCTP_TRANSPORT
c_func
(paren
id|transport
)paren
)paren
suffix:semicolon
multiline_comment|/* Do some failure management (Section 8.2). */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_STRIKE
comma
id|SCTP_TRANSPORT
c_func
(paren
id|transport
)paren
)paren
suffix:semicolon
r_return
id|SCTP_DISPOSITION_CONSUME
suffix:semicolon
)brace
multiline_comment|/* sctp_sf_do_6_3_3_rtx() */
multiline_comment|/*&n; * Generate delayed SACK on timeout&n; * &n; * Section: 6.2  Acknowledgement on Reception of DATA Chunks&n; *&n; * The guidelines on delayed acknowledgement algorithm specified in&n; * Section 4.2 of [RFC2581] SHOULD be followed.  Specifically, an&n; * acknowledgement SHOULD be generated for at least every second packet&n; * (not every second DATA chunk) received, and SHOULD be generated&n; * within 200 ms of the arrival of any unacknowledged DATA chunk.  In&n; * some situations it may be beneficial for an SCTP transmitter to be&n; * more conservative than the algorithms detailed in this document&n; * allow. However, an SCTP transmitter MUST NOT be more aggressive than&n; * the following algorithms allow.&n; */
id|sctp_disposition_t
DECL|function|sctp_sf_do_6_2_sack
id|sctp_sf_do_6_2_sack
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
r_const
id|sctp_subtype_t
id|type
comma
r_void
op_star
id|arg
comma
id|sctp_cmd_seq_t
op_star
id|commands
)paren
(brace
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_GEN_SACK
comma
id|SCTP_FORCE
c_func
(paren
)paren
)paren
suffix:semicolon
r_return
id|SCTP_DISPOSITION_CONSUME
suffix:semicolon
)brace
multiline_comment|/* sctp_sf_do_6_2_sack() */
multiline_comment|/*&n; * sctp_sf_t1_timer_expire&n; * &n; * Section: 4 Note: 2&n; * Verification Tag:&n; * Inputs&n; * (endpoint, asoc)&n; * &n; *  RFC 2960 Section 4 Notes &n; *  2) If the T1-init timer expires, the endpoint MUST retransmit INIT&n; *     and re-start the T1-init timer without changing state.  This MUST&n; *     be repeated up to &squot;Max.Init.Retransmits&squot; times.  After that, the&n; *     endpoint MUST abort the initialization process and report the&n; *     error to SCTP user.&n; * &n; *   3) If the T1-cookie timer expires, the endpoint MUST retransmit&n; *     COOKIE ECHO and re-start the T1-cookie timer without changing&n; *     state.  This MUST be repeated up to &squot;Max.Init.Retransmits&squot; times.&n; *     After that, the endpoint MUST abort the initialization process and&n; *     report the error to SCTP user.&n; *&n; *&n; * Outputs&n; * (timers, events)&n; *&n; */
id|sctp_disposition_t
DECL|function|sctp_sf_t1_timer_expire
id|sctp_sf_t1_timer_expire
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
r_const
id|sctp_subtype_t
id|type
comma
r_void
op_star
id|arg
comma
id|sctp_cmd_seq_t
op_star
id|commands
)paren
(brace
id|sctp_chunk_t
op_star
id|repl
suffix:semicolon
id|sctp_bind_addr_t
op_star
id|bp
suffix:semicolon
id|sctp_event_timeout_t
id|timer
op_assign
(paren
id|sctp_event_timeout_t
)paren
id|arg
suffix:semicolon
r_int
id|timeout
suffix:semicolon
r_int
id|attempts
suffix:semicolon
id|timeout
op_assign
id|asoc-&gt;timeouts
(braket
id|timer
)braket
suffix:semicolon
id|attempts
op_assign
id|asoc-&gt;counters
(braket
id|SCTP_COUNTER_INIT_ERROR
)braket
op_plus
l_int|1
suffix:semicolon
id|repl
op_assign
l_int|NULL
suffix:semicolon
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;Timer T1 expired.&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|timeout
OL
id|asoc-&gt;max_init_timeo
)paren
op_logical_and
(paren
id|attempts
OL
id|asoc-&gt;max_init_attempts
)paren
)paren
(brace
r_switch
c_cond
(paren
id|timer
)paren
(brace
r_case
id|SCTP_EVENT_TIMEOUT_T1_INIT
suffix:colon
id|bp
op_assign
(paren
id|sctp_bind_addr_t
op_star
)paren
op_amp
id|asoc-&gt;base.bind_addr
suffix:semicolon
id|repl
op_assign
id|sctp_make_init
c_func
(paren
id|asoc
comma
id|bp
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_EVENT_TIMEOUT_T1_COOKIE
suffix:colon
id|repl
op_assign
id|sctp_make_cookie_echo
c_func
(paren
id|asoc
comma
l_int|NULL
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|repl
)paren
(brace
r_goto
id|nomem
suffix:semicolon
)brace
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_REPLY
comma
id|SCTP_CHUNK
c_func
(paren
id|repl
)paren
)paren
suffix:semicolon
multiline_comment|/* Issue a sideeffect to do the needed accounting. */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_INIT_RESTART
comma
id|SCTP_TO
c_func
(paren
id|timer
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_INIT_FAILED
comma
id|SCTP_NULL
c_func
(paren
)paren
)paren
suffix:semicolon
r_return
id|SCTP_DISPOSITION_DELETE_TCB
suffix:semicolon
)brace
r_return
id|SCTP_DISPOSITION_CONSUME
suffix:semicolon
id|nomem
suffix:colon
r_return
id|SCTP_DISPOSITION_NOMEM
suffix:semicolon
)brace
multiline_comment|/* sctp_sf_t1_timer_expire() */
multiline_comment|/* RFC2960 9.2 If the timer expires, the endpoint must re-send the SHUTDOWN&n; * with the updated last sequential TSN received from its peer.&n; *&n; * An endpoint should limit the number of retransmissions of the&n; * SHUTDOWN chunk to the protocol parameter &squot;Association.Max.Retrans&squot;.&n; * If this threshold is exceeded the endpoint should destroy the TCB and&n; * MUST report the peer endpoint unreachable to the upper layer (and&n; * thus the association enters the CLOSED state).  The reception of any&n; * packet from its peer (i.e. as the peer sends all of its queued DATA&n; * chunks) should clear the endpoint&squot;s retransmission count and restart&n; * the T2-Shutdown timer,  giving its peer ample opportunity to transmit&n; * all of its queued DATA chunks that have not yet been sent.&n; */
id|sctp_disposition_t
DECL|function|sctp_sf_t2_timer_expire
id|sctp_sf_t2_timer_expire
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
r_const
id|sctp_subtype_t
id|type
comma
r_void
op_star
id|arg
comma
id|sctp_cmd_seq_t
op_star
id|commands
)paren
(brace
id|sctp_chunk_t
op_star
id|reply
op_assign
l_int|NULL
suffix:semicolon
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;Timer T2 expired.&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|asoc-&gt;overall_error_count
op_ge
id|asoc-&gt;overall_error_threshold
)paren
(brace
multiline_comment|/* Note:  CMD_ASSOC_FAILED calls CMD_DELETE_TCB. */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_ASSOC_FAILED
comma
id|SCTP_NULL
c_func
(paren
)paren
)paren
suffix:semicolon
r_return
id|SCTP_DISPOSITION_DELETE_TCB
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|asoc-&gt;state
)paren
(brace
r_case
id|SCTP_STATE_SHUTDOWN_SENT
suffix:colon
id|reply
op_assign
id|sctp_make_shutdown
c_func
(paren
id|asoc
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_STATE_SHUTDOWN_ACK_SENT
suffix:colon
id|reply
op_assign
id|sctp_make_shutdown_ack
c_func
(paren
id|asoc
comma
l_int|NULL
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|reply
)paren
(brace
r_goto
id|nomem
suffix:semicolon
)brace
multiline_comment|/* Do some failure management (Section 8.2). */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_STRIKE
comma
id|SCTP_TRANSPORT
c_func
(paren
id|asoc-&gt;shutdown_last_sent_to
)paren
)paren
suffix:semicolon
multiline_comment|/* Set the transport for the SHUTDOWN/ACK chunk and the timeout for &n;&t; * the T2-shutdown timer.  &n;&t; */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_SETUP_T2
comma
id|SCTP_CHUNK
c_func
(paren
id|reply
)paren
)paren
suffix:semicolon
multiline_comment|/* Restart the T2-shutdown timer.  */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_TIMER_RESTART
comma
id|SCTP_TO
c_func
(paren
id|SCTP_EVENT_TIMEOUT_T2_SHUTDOWN
)paren
)paren
suffix:semicolon
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_REPLY
comma
id|SCTP_CHUNK
c_func
(paren
id|reply
)paren
)paren
suffix:semicolon
r_return
id|SCTP_DISPOSITION_CONSUME
suffix:semicolon
id|nomem
suffix:colon
r_return
id|SCTP_DISPOSITION_NOMEM
suffix:semicolon
)brace
multiline_comment|/* sctp_sf_t2_timer_expire() */
multiline_comment|/* Handle expiration of AUTOCLOSE timer.  When the autoclose timer expires, &n; * the association is automatically closed by starting the shutdown process. &n; * The work that needs to be done is same as when SHUTDOWN is initiated by&n; * the user.  So this routine looks same as sctp_sf_do_9_2_prm_shutdown().&n; */
id|sctp_disposition_t
DECL|function|sctp_sf_autoclose_timer_expire
id|sctp_sf_autoclose_timer_expire
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
r_const
id|sctp_subtype_t
id|type
comma
r_void
op_star
id|arg
comma
id|sctp_cmd_seq_t
op_star
id|commands
)paren
(brace
r_int
id|disposition
suffix:semicolon
multiline_comment|/* From 9.2 Shutdown of an Association&n;         * Upon receipt of the SHUTDOWN primitive from its upper&n;         * layer, the endpoint enters SHUTDOWN-PENDING state and&n;         * remains there until all outstanding data has been&n;         * acknowledged by its peer. The endpoint accepts no new data&n;         * from its upper layer, but retransmits data to the far end&n;         * if necessary to fill gaps.&n;         */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_NEW_STATE
comma
id|SCTP_STATE
c_func
(paren
id|SCTP_STATE_SHUTDOWN_PENDING
)paren
)paren
suffix:semicolon
id|disposition
op_assign
id|SCTP_DISPOSITION_CONSUME
suffix:semicolon
r_if
c_cond
(paren
id|sctp_outqueue_is_empty
c_func
(paren
op_amp
id|asoc-&gt;outqueue
)paren
)paren
(brace
id|disposition
op_assign
id|sctp_sf_do_9_2_start_shutdown
c_func
(paren
id|ep
comma
id|asoc
comma
id|type
comma
id|arg
comma
id|commands
)paren
suffix:semicolon
)brace
r_return
id|disposition
suffix:semicolon
)brace
multiline_comment|/* sctp_sf_autoclose_timer_expire() */
multiline_comment|/*****************************************************************************&n; * These are sa state functions which could apply to all types of events.&n; ****************************************************************************/
multiline_comment|/*&n; * This table entry is not implemented.&n; *&n; * Inputs&n; * (endpoint, asoc, chunk)&n; * &n; * The return value is the disposition of the chunk.&n; */
id|sctp_disposition_t
DECL|function|sctp_sf_not_impl
id|sctp_sf_not_impl
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
r_const
id|sctp_subtype_t
id|type
comma
r_void
op_star
id|arg
comma
id|sctp_cmd_seq_t
op_star
id|commands
)paren
(brace
r_return
id|SCTP_DISPOSITION_NOT_IMPL
suffix:semicolon
)brace
multiline_comment|/* sctp_sf_not_impl() */
multiline_comment|/*&n; * This table entry represents a bug.&n; *&n; * Inputs&n; * (endpoint, asoc, chunk)&n; * &n; * The return value is the disposition of the chunk.&n; */
id|sctp_disposition_t
DECL|function|sctp_sf_bug
id|sctp_sf_bug
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
r_const
id|sctp_subtype_t
id|type
comma
r_void
op_star
id|arg
comma
id|sctp_cmd_seq_t
op_star
id|commands
)paren
(brace
r_return
id|SCTP_DISPOSITION_BUG
suffix:semicolon
)brace
multiline_comment|/* sctp_sf_bug() */
multiline_comment|/*&n; * This table entry represents the firing of a timer in the wrong state.&n; * Since timer deletion cannot be guaranteed a timer &squot;may&squot; end up firing&n; * when the association is in the wrong state.   This event should &n; * be ignored, so as to prevent any rearming of the timer. &n; *&n; * Inputs&n; * (endpoint, asoc, chunk)&n; * &n; * The return value is the disposition of the chunk.&n; */
id|sctp_disposition_t
DECL|function|sctp_sf_timer_ignore
id|sctp_sf_timer_ignore
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
r_const
id|sctp_subtype_t
id|type
comma
r_void
op_star
id|arg
comma
id|sctp_cmd_seq_t
op_star
id|commands
)paren
(brace
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;Timer %d ignored.&bslash;n&quot;
comma
id|type.chunk
)paren
suffix:semicolon
r_return
id|SCTP_DISPOSITION_CONSUME
suffix:semicolon
)brace
multiline_comment|/* sctp_sf_timer_ignore() */
multiline_comment|/*&n; * Discard the chunk.&n; *&n; * Section: 0.2, 5.2.3, 5.2.5, 5.2.6, 6.0, 8.4.6, 8.5.1c, 9.2&n; * [Too numerous to mention...]&n; * Verification Tag: No verification needed.&n; * Inputs&n; * (endpoint, asoc, chunk)&n; * &n; * Outputs&n; * (asoc, reply_msg, msg_up, timers, counters)&n; *&n; * The return value is the disposition of the chunk.&n; */
id|sctp_disposition_t
DECL|function|sctp_sf_discard_chunk
id|sctp_sf_discard_chunk
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
r_const
id|sctp_subtype_t
id|type
comma
r_void
op_star
id|arg
comma
id|sctp_cmd_seq_t
op_star
id|commands
)paren
(brace
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;Chunk %d is discarded&bslash;n&quot;
comma
id|type.chunk
)paren
suffix:semicolon
r_return
id|SCTP_DISPOSITION_DISCARD
suffix:semicolon
)brace
multiline_comment|/* sctp_sf_discard_chunk() */
multiline_comment|/********************************************************************&n; * 2nd Level Abstractions&n; ********************************************************************/
multiline_comment|/* Pull the SACK chunk based on the SACK header. */
id|sctp_sackhdr_t
op_star
DECL|function|sctp_sm_pull_sack
id|sctp_sm_pull_sack
c_func
(paren
id|sctp_chunk_t
op_star
id|chunk
)paren
(brace
id|sctp_sackhdr_t
op_star
id|sack
suffix:semicolon
r_uint16
id|num_blocks
suffix:semicolon
r_uint16
id|num_dup_tsns
suffix:semicolon
id|sack
op_assign
(paren
id|sctp_sackhdr_t
op_star
)paren
id|chunk-&gt;skb-&gt;data
suffix:semicolon
id|skb_pull
c_func
(paren
id|chunk-&gt;skb
comma
r_sizeof
(paren
id|sctp_sackhdr_t
)paren
)paren
suffix:semicolon
id|num_blocks
op_assign
id|ntohs
c_func
(paren
id|sack-&gt;num_gap_ack_blocks
)paren
suffix:semicolon
id|num_dup_tsns
op_assign
id|ntohs
c_func
(paren
id|sack-&gt;num_dup_tsns
)paren
suffix:semicolon
id|skb_pull
c_func
(paren
id|chunk-&gt;skb
comma
(paren
id|num_blocks
op_plus
id|num_dup_tsns
)paren
op_star
r_sizeof
(paren
r_uint32
)paren
)paren
suffix:semicolon
r_return
id|sack
suffix:semicolon
)brace
multiline_comment|/* sctp_sm_pull_sack() */
eof
