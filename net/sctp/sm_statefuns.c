multiline_comment|/* SCTP kernel reference Implementation&n; * Copyright (c) 1999-2000 Cisco, Inc.&n; * Copyright (c) 1999-2001 Motorola, Inc.&n; * Copyright (c) 2001-2002 International Business Machines, Corp.&n; * Copyright (c) 2001-2002 Intel Corp.&n; * Copyright (c) 2002      Nokia Corp.&n; *&n; * This file is part of the SCTP kernel reference Implementation&n; *&n; * This is part of the SCTP Linux Kernel Reference Implementation.&n; *&n; * These are the state functions for the state machine.&n; *&n; * The SCTP reference implementation is free software;&n; * you can redistribute it and/or modify it under the terms of&n; * the GNU General Public License as published by&n; * the Free Software Foundation; either version 2, or (at your option)&n; * any later version.&n; *&n; * The SCTP reference implementation is distributed in the hope that it&n; * will be useful, but WITHOUT ANY WARRANTY; without even the implied&n; *                 ************************&n; * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&n; * See the GNU General Public License for more details.&n; *&n; * You should have received a copy of the GNU General Public License&n; * along with GNU CC; see the file COPYING.  If not, write to&n; * the Free Software Foundation, 59 Temple Place - Suite 330,&n; * Boston, MA 02111-1307, USA.&n; *&n; * Please send any bug reports or fixes you make to the&n; * email address(es):&n; *    lksctp developers &lt;lksctp-developers@lists.sourceforge.net&gt;&n; *&n; * Or submit a bug report through the following website:&n; *    http://www.sf.net/projects/lksctp&n; *&n; * Written or modified by:&n; *    La Monte H.P. Yarroll &lt;piggy@acm.org&gt;&n; *    Karl Knutson          &lt;karl@athena.chicago.il.us&gt;&n; *    Mathew Kotowsky       &lt;kotowsky@sctp.org&gt;&n; *    Sridhar Samudrala     &lt;samudrala@us.ibm.com&gt;&n; *    Jon Grimm             &lt;jgrimm@us.ibm.com&gt;&n; *    Hui Huang &t;    &lt;hui.huang@nokia.com&gt;&n; *    Dajiang Zhang &t;    &lt;dajiang.zhang@nokia.com&gt;&n; *    Daisy Chang&t;    &lt;daisyc@us.ibm.com&gt;&n; *    Ardelle Fan&t;    &lt;ardelle.fan@intel.com&gt;&n; *&n; * Any bugs reported given to us we will try to fix... any fixes shared will&n; * be incorporated into the next SCTP release.&n; */
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/ip.h&gt;
macro_line|#include &lt;linux/ipv6.h&gt;
macro_line|#include &lt;linux/net.h&gt;
macro_line|#include &lt;linux/inet.h&gt;
macro_line|#include &lt;net/sock.h&gt;
macro_line|#include &lt;net/inet_ecn.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;net/sctp/sctp.h&gt;
macro_line|#include &lt;net/sctp/sm.h&gt;
macro_line|#include &lt;net/sctp/structs.h&gt;
multiline_comment|/**********************************************************&n; * These are the state functions for handling chunk events.&n; **********************************************************/
multiline_comment|/*&n; * Process the final SHUTDOWN COMPLETE.&n; *&n; * Section: 4 (C) (diagram), 9.2&n; * Upon reception of the SHUTDOWN COMPLETE chunk the endpoint will verify&n; * that it is in SHUTDOWN-ACK-SENT state, if it is not the chunk should be&n; * discarded. If the endpoint is in the SHUTDOWN-ACK-SENT state the endpoint&n; * should stop the T2-shutdown timer and remove all knowledge of the&n; * association (and thus the association enters the CLOSED state).&n; *&n; * Verification Tag: 8.5.1(C)&n; * C) Rules for packet carrying SHUTDOWN COMPLETE:&n; * ...&n; * - The receiver of a SHUTDOWN COMPLETE shall accept the packet if the&n; *   Verification Tag field of the packet matches its own tag OR it is&n; *   set to its peer&squot;s tag and the T bit is set in the Chunk Flags.&n; *   Otherwise, the receiver MUST silently discard the packet and take&n; *   no further action. An endpoint MUST ignore the SHUTDOWN COMPLETE if&n; *   it is not in the SHUTDOWN-ACK-SENT state.&n; *&n; * Inputs&n; * (endpoint, asoc, chunk)&n; *&n; * Outputs&n; * (asoc, reply_msg, msg_up, timers, counters)&n; *&n; * The return value is the disposition of the chunk.&n; */
DECL|function|sctp_sf_do_4_C
id|sctp_disposition_t
id|sctp_sf_do_4_C
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
r_const
id|sctp_subtype_t
id|type
comma
r_void
op_star
id|arg
comma
id|sctp_cmd_seq_t
op_star
id|commands
)paren
(brace
id|sctp_chunk_t
op_star
id|chunk
op_assign
id|arg
suffix:semicolon
r_struct
id|sctp_ulpevent
op_star
id|ev
suffix:semicolon
multiline_comment|/* RFC 2960 6.10 Bundling&n;&t; *&n;&t; * An endpoint MUST NOT bundle INIT, INIT ACK or&n;&t; * SHUTDOWN COMPLETE with any other chunks.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|chunk-&gt;singleton
)paren
r_return
id|SCTP_DISPOSITION_VIOLATION
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sctp_vtag_verify_either
c_func
(paren
id|chunk
comma
id|asoc
)paren
)paren
r_return
id|sctp_sf_pdiscard
c_func
(paren
id|ep
comma
id|asoc
comma
id|type
comma
id|arg
comma
id|commands
)paren
suffix:semicolon
multiline_comment|/* RFC 2960 10.2 SCTP-to-ULP&n;&t; *&n;&t; * H) SHUTDOWN COMPLETE notification&n;&t; *&n;&t; * When SCTP completes the shutdown procedures (section 9.2) this&n;&t; * notification is passed to the upper layer.&n;&t; */
id|ev
op_assign
id|sctp_ulpevent_make_assoc_change
c_func
(paren
id|asoc
comma
l_int|0
comma
id|SCTP_SHUTDOWN_COMP
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ev
)paren
r_goto
id|nomem
suffix:semicolon
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_EVENT_ULP
comma
id|SCTP_ULPEVENT
c_func
(paren
id|ev
)paren
)paren
suffix:semicolon
multiline_comment|/* Upon reception of the SHUTDOWN COMPLETE chunk the endpoint&n;&t; * will verify that it is in SHUTDOWN-ACK-SENT state, if it is&n;&t; * not the chunk should be discarded. If the endpoint is in&n;&t; * the SHUTDOWN-ACK-SENT state the endpoint should stop the&n;&t; * T2-shutdown timer and remove all knowledge of the&n;&t; * association (and thus the association enters the CLOSED&n;&t; * state).&n;&t; */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_TIMER_STOP
comma
id|SCTP_TO
c_func
(paren
id|SCTP_EVENT_TIMEOUT_T2_SHUTDOWN
)paren
)paren
suffix:semicolon
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_TIMER_STOP
comma
id|SCTP_TO
c_func
(paren
id|SCTP_EVENT_TIMEOUT_T5_SHUTDOWN_GUARD
)paren
)paren
suffix:semicolon
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_NEW_STATE
comma
id|SCTP_STATE
c_func
(paren
id|SCTP_STATE_CLOSED
)paren
)paren
suffix:semicolon
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_DELETE_TCB
comma
id|SCTP_NULL
c_func
(paren
)paren
)paren
suffix:semicolon
r_return
id|SCTP_DISPOSITION_DELETE_TCB
suffix:semicolon
id|nomem
suffix:colon
r_return
id|SCTP_DISPOSITION_NOMEM
suffix:semicolon
)brace
multiline_comment|/*&n; * Respond to a normal INIT chunk.&n; * We are the side that is being asked for an association.&n; *&n; * Section: 5.1 Normal Establishment of an Association, B&n; * B) &quot;Z&quot; shall respond immediately with an INIT ACK chunk.  The&n; *    destination IP address of the INIT ACK MUST be set to the source&n; *    IP address of the INIT to which this INIT ACK is responding.  In&n; *    the response, besides filling in other parameters, &quot;Z&quot; must set the&n; *    Verification Tag field to Tag_A, and also provide its own&n; *    Verification Tag (Tag_Z) in the Initiate Tag field.&n; *&n; * Verification Tag: No checking.&n; *&n; * Inputs&n; * (endpoint, asoc, chunk)&n; *&n; * Outputs&n; * (asoc, reply_msg, msg_up, timers, counters)&n; *&n; * The return value is the disposition of the chunk.&n; */
DECL|function|sctp_sf_do_5_1B_init
id|sctp_disposition_t
id|sctp_sf_do_5_1B_init
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
r_const
id|sctp_subtype_t
id|type
comma
r_void
op_star
id|arg
comma
id|sctp_cmd_seq_t
op_star
id|commands
)paren
(brace
id|sctp_chunk_t
op_star
id|chunk
op_assign
id|arg
suffix:semicolon
id|sctp_chunk_t
op_star
id|repl
suffix:semicolon
id|sctp_association_t
op_star
id|new_asoc
suffix:semicolon
id|sctp_chunk_t
op_star
id|err_chunk
suffix:semicolon
id|sctp_packet_t
op_star
id|packet
suffix:semicolon
id|sctp_unrecognized_param_t
op_star
id|unk_param
suffix:semicolon
r_int
id|len
suffix:semicolon
multiline_comment|/* If the packet is an OOTB packet which is temporarily on the&n;&t; * control endpoint, respond with an ABORT.&n;&t; */
r_if
c_cond
(paren
id|ep
op_eq
id|sctp_sk
c_func
(paren
(paren
id|sctp_get_ctl_sock
c_func
(paren
)paren
)paren
)paren
op_member_access_from_pointer
id|ep
)paren
r_return
id|sctp_sf_ootb
c_func
(paren
id|ep
comma
id|asoc
comma
id|type
comma
id|arg
comma
id|commands
)paren
suffix:semicolon
multiline_comment|/* 6.10 Bundling&n;&t; * An endpoint MUST NOT bundle INIT, INIT ACK or&n;&t; * SHUTDOWN COMPLETE with any other chunks.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|chunk-&gt;singleton
)paren
r_return
id|SCTP_DISPOSITION_VIOLATION
suffix:semicolon
multiline_comment|/* Verify the INIT chunk before processing it. */
id|err_chunk
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sctp_verify_init
c_func
(paren
id|asoc
comma
id|chunk-&gt;chunk_hdr-&gt;type
comma
(paren
id|sctp_init_chunk_t
op_star
)paren
id|chunk-&gt;chunk_hdr
comma
id|chunk
comma
op_amp
id|err_chunk
)paren
)paren
(brace
multiline_comment|/* This chunk contains fatal error. It is to be discarded.&n;&t;&t; * Send an ABORT, with causes if there is any.&n;&t;&t; */
r_if
c_cond
(paren
id|err_chunk
)paren
(brace
id|packet
op_assign
id|sctp_abort_pkt_new
c_func
(paren
id|ep
comma
id|asoc
comma
id|arg
comma
(paren
id|__u8
op_star
)paren
(paren
id|err_chunk-&gt;chunk_hdr
)paren
op_plus
r_sizeof
(paren
id|sctp_chunkhdr_t
)paren
comma
id|ntohs
c_func
(paren
id|err_chunk-&gt;chunk_hdr-&gt;length
)paren
op_minus
r_sizeof
(paren
id|sctp_chunkhdr_t
)paren
)paren
suffix:semicolon
id|sctp_free_chunk
c_func
(paren
id|err_chunk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|packet
)paren
(brace
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_SEND_PKT
comma
id|SCTP_PACKET
c_func
(paren
id|packet
)paren
)paren
suffix:semicolon
r_return
id|SCTP_DISPOSITION_CONSUME
suffix:semicolon
)brace
r_else
(brace
r_return
id|SCTP_DISPOSITION_NOMEM
suffix:semicolon
)brace
)brace
r_else
(brace
r_return
id|sctp_sf_tabort_8_4_8
c_func
(paren
id|ep
comma
id|asoc
comma
id|type
comma
id|arg
comma
id|commands
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Grab the INIT header.  */
id|chunk-&gt;subh.init_hdr
op_assign
(paren
id|sctp_inithdr_t
op_star
)paren
id|chunk-&gt;skb-&gt;data
suffix:semicolon
multiline_comment|/* Tag the variable length parameters.  */
id|chunk-&gt;param_hdr.v
op_assign
id|skb_pull
c_func
(paren
id|chunk-&gt;skb
comma
r_sizeof
(paren
id|sctp_inithdr_t
)paren
)paren
suffix:semicolon
id|new_asoc
op_assign
id|sctp_make_temp_asoc
c_func
(paren
id|ep
comma
id|chunk
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|new_asoc
)paren
r_goto
id|nomem
suffix:semicolon
multiline_comment|/* The call, sctp_process_init(), can fail on memory allocation.  */
r_if
c_cond
(paren
op_logical_neg
id|sctp_process_init
c_func
(paren
id|new_asoc
comma
id|chunk-&gt;chunk_hdr-&gt;type
comma
id|sctp_source
c_func
(paren
id|chunk
)paren
comma
(paren
id|sctp_init_chunk_t
op_star
)paren
id|chunk-&gt;chunk_hdr
comma
id|GFP_ATOMIC
)paren
)paren
r_goto
id|nomem_init
suffix:semicolon
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_NEW_ASOC
comma
id|SCTP_ASOC
c_func
(paren
id|new_asoc
)paren
)paren
suffix:semicolon
multiline_comment|/* B) &quot;Z&quot; shall respond immediately with an INIT ACK chunk.  */
multiline_comment|/* If there are errors need to be reported for unknown parameters,&n;&t; * make sure to reserve enough room in the INIT ACK for them.&n;&t; */
id|len
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|err_chunk
)paren
id|len
op_assign
id|ntohs
c_func
(paren
id|err_chunk-&gt;chunk_hdr-&gt;length
)paren
op_minus
r_sizeof
(paren
id|sctp_chunkhdr_t
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sctp_assoc_set_bind_addr_from_ep
c_func
(paren
id|new_asoc
comma
id|GFP_ATOMIC
)paren
OL
l_int|0
)paren
r_goto
id|nomem_ack
suffix:semicolon
id|repl
op_assign
id|sctp_make_init_ack
c_func
(paren
id|new_asoc
comma
id|chunk
comma
id|GFP_ATOMIC
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|repl
)paren
r_goto
id|nomem_ack
suffix:semicolon
multiline_comment|/* If there are errors need to be reported for unknown parameters,&n;&t; * include them in the outgoing INIT ACK as &quot;Unrecognized parameter&quot;&n;&t; * parameter.&n;&t; */
r_if
c_cond
(paren
id|err_chunk
)paren
(brace
multiline_comment|/* Get the &quot;Unrecognized parameter&quot; parameter(s) out of the&n;&t;&t; * ERROR chunk generated by sctp_verify_init(). Since the&n;&t;&t; * error cause code for &quot;unknown parameter&quot; and the&n;&t;&t; * &quot;Unrecognized parameter&quot; type is the same, we can&n;&t;&t; * construct the parameters in INIT ACK by copying the&n;&t;&t; * ERROR causes over.&n;&t;&t; */
id|unk_param
op_assign
(paren
id|sctp_unrecognized_param_t
op_star
)paren
(paren
(paren
id|__u8
op_star
)paren
(paren
id|err_chunk-&gt;chunk_hdr
)paren
op_plus
r_sizeof
(paren
id|sctp_chunkhdr_t
)paren
)paren
suffix:semicolon
multiline_comment|/* Replace the cause code with the &quot;Unrecognized parameter&quot;&n;&t;&t; * parameter type.&n;&t;&t; */
id|sctp_addto_chunk
c_func
(paren
id|repl
comma
id|len
comma
id|unk_param
)paren
suffix:semicolon
id|sctp_free_chunk
c_func
(paren
id|err_chunk
)paren
suffix:semicolon
)brace
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_REPLY
comma
id|SCTP_CHUNK
c_func
(paren
id|repl
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Note:  After sending out INIT ACK with the State Cookie parameter,&n;&t; * &quot;Z&quot; MUST NOT allocate any resources, nor keep any states for the&n;&t; * new association.  Otherwise, &quot;Z&quot; will be vulnerable to resource&n;&t; * attacks.&n;&t; */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_DELETE_TCB
comma
id|SCTP_NULL
c_func
(paren
)paren
)paren
suffix:semicolon
r_return
id|SCTP_DISPOSITION_DELETE_TCB
suffix:semicolon
id|nomem_ack
suffix:colon
r_if
c_cond
(paren
id|err_chunk
)paren
id|sctp_free_chunk
c_func
(paren
id|err_chunk
)paren
suffix:semicolon
id|nomem_init
suffix:colon
id|sctp_association_free
c_func
(paren
id|new_asoc
)paren
suffix:semicolon
id|nomem
suffix:colon
r_return
id|SCTP_DISPOSITION_NOMEM
suffix:semicolon
)brace
multiline_comment|/*&n; * Respond to a normal INIT ACK chunk.&n; * We are the side that is initiating the association.&n; *&n; * Section: 5.1 Normal Establishment of an Association, C&n; * C) Upon reception of the INIT ACK from &quot;Z&quot;, &quot;A&quot; shall stop the T1-init&n; *    timer and leave COOKIE-WAIT state. &quot;A&quot; shall then send the State&n; *    Cookie received in the INIT ACK chunk in a COOKIE ECHO chunk, start&n; *    the T1-cookie timer, and enter the COOKIE-ECHOED state.&n; *&n; *    Note: The COOKIE ECHO chunk can be bundled with any pending outbound&n; *    DATA chunks, but it MUST be the first chunk in the packet and&n; *    until the COOKIE ACK is returned the sender MUST NOT send any&n; *    other packets to the peer.&n; *&n; * Verification Tag: 3.3.3&n; *   If the value of the Initiate Tag in a received INIT ACK chunk is&n; *   found to be 0, the receiver MUST treat it as an error and close the&n; *   association by transmitting an ABORT.&n; *&n; * Inputs&n; * (endpoint, asoc, chunk)&n; *&n; * Outputs&n; * (asoc, reply_msg, msg_up, timers, counters)&n; *&n; * The return value is the disposition of the chunk.&n; */
DECL|function|sctp_sf_do_5_1C_ack
id|sctp_disposition_t
id|sctp_sf_do_5_1C_ack
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
r_const
id|sctp_subtype_t
id|type
comma
r_void
op_star
id|arg
comma
id|sctp_cmd_seq_t
op_star
id|commands
)paren
(brace
id|sctp_chunk_t
op_star
id|chunk
op_assign
id|arg
suffix:semicolon
id|sctp_init_chunk_t
op_star
id|initchunk
suffix:semicolon
id|__u32
id|init_tag
suffix:semicolon
id|sctp_chunk_t
op_star
id|err_chunk
suffix:semicolon
id|sctp_packet_t
op_star
id|packet
suffix:semicolon
id|sctp_disposition_t
id|ret
suffix:semicolon
multiline_comment|/* 6.10 Bundling&n;&t; * An endpoint MUST NOT bundle INIT, INIT ACK or&n;&t; * SHUTDOWN COMPLETE with any other chunks.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|chunk-&gt;singleton
)paren
r_return
id|SCTP_DISPOSITION_VIOLATION
suffix:semicolon
multiline_comment|/* Grab the INIT header.  */
id|chunk-&gt;subh.init_hdr
op_assign
(paren
id|sctp_inithdr_t
op_star
)paren
id|chunk-&gt;skb-&gt;data
suffix:semicolon
id|init_tag
op_assign
id|ntohl
c_func
(paren
id|chunk-&gt;subh.init_hdr-&gt;init_tag
)paren
suffix:semicolon
multiline_comment|/* Verification Tag: 3.3.3&n;&t; *   If the value of the Initiate Tag in a received INIT ACK&n;&t; *   chunk is found to be 0, the receiver MUST treat it as an&n;&t; *   error and close the association by transmitting an ABORT.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|init_tag
)paren
(brace
id|sctp_chunk_t
op_star
id|reply
op_assign
id|sctp_make_abort
c_func
(paren
id|asoc
comma
id|chunk
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|reply
)paren
r_goto
id|nomem
suffix:semicolon
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_REPLY
comma
id|SCTP_CHUNK
c_func
(paren
id|reply
)paren
)paren
suffix:semicolon
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_NEW_STATE
comma
id|SCTP_STATE
c_func
(paren
id|SCTP_STATE_CLOSED
)paren
)paren
suffix:semicolon
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_DELETE_TCB
comma
id|SCTP_NULL
c_func
(paren
)paren
)paren
suffix:semicolon
r_return
id|SCTP_DISPOSITION_DELETE_TCB
suffix:semicolon
)brace
multiline_comment|/* Verify the INIT chunk before processing it. */
id|err_chunk
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sctp_verify_init
c_func
(paren
id|asoc
comma
id|chunk-&gt;chunk_hdr-&gt;type
comma
(paren
id|sctp_init_chunk_t
op_star
)paren
id|chunk-&gt;chunk_hdr
comma
id|chunk
comma
op_amp
id|err_chunk
)paren
)paren
(brace
multiline_comment|/* This chunk contains fatal error. It is to be discarded.&n;&t;&t; * Send an ABORT, with causes if there is any.&n;&t;&t; */
r_if
c_cond
(paren
id|err_chunk
)paren
(brace
id|packet
op_assign
id|sctp_abort_pkt_new
c_func
(paren
id|ep
comma
id|asoc
comma
id|arg
comma
(paren
id|__u8
op_star
)paren
(paren
id|err_chunk-&gt;chunk_hdr
)paren
op_plus
r_sizeof
(paren
id|sctp_chunkhdr_t
)paren
comma
id|ntohs
c_func
(paren
id|err_chunk-&gt;chunk_hdr-&gt;length
)paren
op_minus
r_sizeof
(paren
id|sctp_chunkhdr_t
)paren
)paren
suffix:semicolon
id|sctp_free_chunk
c_func
(paren
id|err_chunk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|packet
)paren
(brace
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_SEND_PKT
comma
id|SCTP_PACKET
c_func
(paren
id|packet
)paren
)paren
suffix:semicolon
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_NEW_STATE
comma
id|SCTP_STATE
c_func
(paren
id|SCTP_STATE_CLOSED
)paren
)paren
suffix:semicolon
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_DELETE_TCB
comma
id|SCTP_NULL
c_func
(paren
)paren
)paren
suffix:semicolon
r_return
id|SCTP_DISPOSITION_CONSUME
suffix:semicolon
)brace
r_else
(brace
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_NEW_STATE
comma
id|SCTP_STATE
c_func
(paren
id|SCTP_STATE_CLOSED
)paren
)paren
suffix:semicolon
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_DELETE_TCB
comma
id|SCTP_NULL
c_func
(paren
)paren
)paren
suffix:semicolon
r_return
id|SCTP_DISPOSITION_NOMEM
suffix:semicolon
)brace
)brace
r_else
(brace
id|ret
op_assign
id|sctp_sf_tabort_8_4_8
c_func
(paren
id|ep
comma
id|asoc
comma
id|type
comma
id|arg
comma
id|commands
)paren
suffix:semicolon
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_NEW_STATE
comma
id|SCTP_STATE
c_func
(paren
id|SCTP_STATE_CLOSED
)paren
)paren
suffix:semicolon
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_DELETE_TCB
comma
id|SCTP_NULL
c_func
(paren
)paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
)brace
multiline_comment|/* Tag the variable length paramters.  Note that we never&n;&t; * convert the parameters in an INIT chunk.&n;&t; */
id|chunk-&gt;param_hdr.v
op_assign
id|skb_pull
c_func
(paren
id|chunk-&gt;skb
comma
r_sizeof
(paren
id|sctp_inithdr_t
)paren
)paren
suffix:semicolon
id|initchunk
op_assign
(paren
id|sctp_init_chunk_t
op_star
)paren
id|chunk-&gt;chunk_hdr
suffix:semicolon
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_PEER_INIT
comma
id|SCTP_PEER_INIT
c_func
(paren
id|initchunk
)paren
)paren
suffix:semicolon
multiline_comment|/* 5.1 C) &quot;A&quot; shall stop the T1-init timer and leave&n;&t; * COOKIE-WAIT state.  &quot;A&quot; shall then ... start the T1-cookie&n;&t; * timer, and enter the COOKIE-ECHOED state.&n;&t; */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_TIMER_STOP
comma
id|SCTP_TO
c_func
(paren
id|SCTP_EVENT_TIMEOUT_T1_INIT
)paren
)paren
suffix:semicolon
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_COUNTER_RESET
comma
id|SCTP_COUNTER
c_func
(paren
id|SCTP_COUNTER_INIT_ERROR
)paren
)paren
suffix:semicolon
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_TIMER_START
comma
id|SCTP_TO
c_func
(paren
id|SCTP_EVENT_TIMEOUT_T1_COOKIE
)paren
)paren
suffix:semicolon
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_NEW_STATE
comma
id|SCTP_STATE
c_func
(paren
id|SCTP_STATE_COOKIE_ECHOED
)paren
)paren
suffix:semicolon
multiline_comment|/* 5.1 C) &quot;A&quot; shall then send the State Cookie received in the&n;&t; * INIT ACK chunk in a COOKIE ECHO chunk, ...&n;&t; */
multiline_comment|/* If there is any errors to report, send the ERROR chunk generated&n;&t; * for unknown parameters as well.&n;&t; */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_GEN_COOKIE_ECHO
comma
id|SCTP_CHUNK
c_func
(paren
id|err_chunk
)paren
)paren
suffix:semicolon
r_return
id|SCTP_DISPOSITION_CONSUME
suffix:semicolon
id|nomem
suffix:colon
r_return
id|SCTP_DISPOSITION_NOMEM
suffix:semicolon
)brace
multiline_comment|/*&n; * Respond to a normal COOKIE ECHO chunk.&n; * We are the side that is being asked for an association.&n; *&n; * Section: 5.1 Normal Establishment of an Association, D&n; * D) Upon reception of the COOKIE ECHO chunk, Endpoint &quot;Z&quot; will reply&n; *    with a COOKIE ACK chunk after building a TCB and moving to&n; *    the ESTABLISHED state. A COOKIE ACK chunk may be bundled with&n; *    any pending DATA chunks (and/or SACK chunks), but the COOKIE ACK&n; *    chunk MUST be the first chunk in the packet.&n; *&n; *   IMPLEMENTATION NOTE: An implementation may choose to send the&n; *   Communication Up notification to the SCTP user upon reception&n; *   of a valid COOKIE ECHO chunk.&n; *&n; * Verification Tag: 8.5.1 Exceptions in Verification Tag Rules&n; * D) Rules for packet carrying a COOKIE ECHO&n; *&n; * - When sending a COOKIE ECHO, the endpoint MUST use the value of the&n; *   Initial Tag received in the INIT ACK.&n; *&n; * - The receiver of a COOKIE ECHO follows the procedures in Section 5.&n; *&n; * Inputs&n; * (endpoint, asoc, chunk)&n; *&n; * Outputs&n; * (asoc, reply_msg, msg_up, timers, counters)&n; *&n; * The return value is the disposition of the chunk.&n; */
DECL|function|sctp_sf_do_5_1D_ce
id|sctp_disposition_t
id|sctp_sf_do_5_1D_ce
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
r_const
id|sctp_subtype_t
id|type
comma
r_void
op_star
id|arg
comma
id|sctp_cmd_seq_t
op_star
id|commands
)paren
(brace
id|sctp_chunk_t
op_star
id|chunk
op_assign
id|arg
suffix:semicolon
id|sctp_association_t
op_star
id|new_asoc
suffix:semicolon
id|sctp_init_chunk_t
op_star
id|peer_init
suffix:semicolon
id|sctp_chunk_t
op_star
id|repl
suffix:semicolon
r_struct
id|sctp_ulpevent
op_star
id|ev
suffix:semicolon
r_int
id|error
op_assign
l_int|0
suffix:semicolon
id|sctp_chunk_t
op_star
id|err_chk_p
suffix:semicolon
multiline_comment|/* If the packet is an OOTB packet which is temporarily on the&n;&t; * control endpoint, respond with an ABORT.&n;&t; */
r_if
c_cond
(paren
id|ep
op_eq
id|sctp_sk
c_func
(paren
(paren
id|sctp_get_ctl_sock
c_func
(paren
)paren
)paren
)paren
op_member_access_from_pointer
id|ep
)paren
r_return
id|sctp_sf_ootb
c_func
(paren
id|ep
comma
id|asoc
comma
id|type
comma
id|arg
comma
id|commands
)paren
suffix:semicolon
multiline_comment|/* &quot;Decode&quot; the chunk.  We have no optional parameters so we&n;&t; * are in good shape.&n;&t; */
id|chunk-&gt;subh.cookie_hdr
op_assign
(paren
id|sctp_signed_cookie_t
op_star
)paren
id|chunk-&gt;skb-&gt;data
suffix:semicolon
id|skb_pull
c_func
(paren
id|chunk-&gt;skb
comma
id|ntohs
c_func
(paren
id|chunk-&gt;chunk_hdr-&gt;length
)paren
op_minus
r_sizeof
(paren
id|sctp_chunkhdr_t
)paren
)paren
suffix:semicolon
multiline_comment|/* 5.1 D) Upon reception of the COOKIE ECHO chunk, Endpoint&n;&t; * &quot;Z&quot; will reply with a COOKIE ACK chunk after building a TCB&n;&t; * and moving to the ESTABLISHED state.&n;&t; */
id|new_asoc
op_assign
id|sctp_unpack_cookie
c_func
(paren
id|ep
comma
id|asoc
comma
id|chunk
comma
id|GFP_ATOMIC
comma
op_amp
id|error
comma
op_amp
id|err_chk_p
)paren
suffix:semicolon
multiline_comment|/* FIXME:&n;&t; * If the re-build failed, what is the proper error path&n;&t; * from here?&n;&t; *&n;&t; * [We should abort the association. --piggy]&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|new_asoc
)paren
(brace
multiline_comment|/* FIXME: Several errors are possible.  A bad cookie should&n;&t;&t; * be silently discarded, but think about logging it too.&n;&t;&t; */
r_switch
c_cond
(paren
id|error
)paren
(brace
r_case
op_minus
id|SCTP_IERROR_NOMEM
suffix:colon
r_goto
id|nomem
suffix:semicolon
r_case
op_minus
id|SCTP_IERROR_STALE_COOKIE
suffix:colon
id|sctp_send_stale_cookie_err
c_func
(paren
id|ep
comma
id|asoc
comma
id|chunk
comma
id|commands
comma
id|err_chk_p
)paren
suffix:semicolon
r_return
id|sctp_sf_pdiscard
c_func
(paren
id|ep
comma
id|asoc
comma
id|type
comma
id|arg
comma
id|commands
)paren
suffix:semicolon
r_case
op_minus
id|SCTP_IERROR_BAD_SIG
suffix:colon
r_default
suffix:colon
r_return
id|sctp_sf_pdiscard
c_func
(paren
id|ep
comma
id|asoc
comma
id|type
comma
id|arg
comma
id|commands
)paren
suffix:semicolon
)brace
suffix:semicolon
)brace
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_NEW_ASOC
comma
id|SCTP_ASOC
c_func
(paren
id|new_asoc
)paren
)paren
suffix:semicolon
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_NEW_STATE
comma
id|SCTP_STATE
c_func
(paren
id|SCTP_STATE_ESTABLISHED
)paren
)paren
suffix:semicolon
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_HB_TIMERS_START
comma
id|SCTP_NULL
c_func
(paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|new_asoc-&gt;autoclose
)paren
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_TIMER_START
comma
id|SCTP_TO
c_func
(paren
id|SCTP_EVENT_TIMEOUT_AUTOCLOSE
)paren
)paren
suffix:semicolon
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_TRANSMIT
comma
id|SCTP_NULL
c_func
(paren
)paren
)paren
suffix:semicolon
multiline_comment|/* Re-build the bind address for the association is done in&n;&t; * the sctp_unpack_cookie() already.&n;&t; */
multiline_comment|/* This is a brand-new association, so these are not yet side&n;&t; * effects--it is safe to run them here.&n;&t; */
id|peer_init
op_assign
op_amp
id|chunk-&gt;subh.cookie_hdr-&gt;c.peer_init
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sctp_process_init
c_func
(paren
id|new_asoc
comma
id|chunk-&gt;chunk_hdr-&gt;type
comma
op_amp
id|chunk-&gt;subh.cookie_hdr-&gt;c.peer_addr
comma
id|peer_init
comma
id|GFP_ATOMIC
)paren
)paren
r_goto
id|nomem_init
suffix:semicolon
id|repl
op_assign
id|sctp_make_cookie_ack
c_func
(paren
id|new_asoc
comma
id|chunk
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|repl
)paren
r_goto
id|nomem_repl
suffix:semicolon
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_REPLY
comma
id|SCTP_CHUNK
c_func
(paren
id|repl
)paren
)paren
suffix:semicolon
multiline_comment|/* RFC 2960 5.1 Normal Establishment of an Association&n;&t; *&n;&t; * D) IMPLEMENTATION NOTE: An implementation may choose to&n;&t; * send the Communication Up notification to the SCTP user&n;&t; * upon reception of a valid COOKIE ECHO chunk.&n;&t; */
id|ev
op_assign
id|sctp_ulpevent_make_assoc_change
c_func
(paren
id|new_asoc
comma
l_int|0
comma
id|SCTP_COMM_UP
comma
l_int|0
comma
id|new_asoc-&gt;c.sinit_num_ostreams
comma
id|new_asoc-&gt;c.sinit_max_instreams
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ev
)paren
r_goto
id|nomem_ev
suffix:semicolon
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_EVENT_ULP
comma
id|SCTP_ULPEVENT
c_func
(paren
id|ev
)paren
)paren
suffix:semicolon
r_return
id|SCTP_DISPOSITION_CONSUME
suffix:semicolon
id|nomem_ev
suffix:colon
id|sctp_free_chunk
c_func
(paren
id|repl
)paren
suffix:semicolon
id|nomem_repl
suffix:colon
id|nomem_init
suffix:colon
id|sctp_association_free
c_func
(paren
id|new_asoc
)paren
suffix:semicolon
id|nomem
suffix:colon
r_return
id|SCTP_DISPOSITION_NOMEM
suffix:semicolon
)brace
multiline_comment|/*&n; * Respond to a normal COOKIE ACK chunk.&n; * We are the side that is being asked for an association.&n; *&n; * RFC 2960 5.1 Normal Establishment of an Association&n; *&n; * E) Upon reception of the COOKIE ACK, endpoint &quot;A&quot; will move from the&n; *    COOKIE-ECHOED state to the ESTABLISHED state, stopping the T1-cookie&n; *    timer. It may also notify its ULP about the successful&n; *    establishment of the association with a Communication Up&n; *    notification (see Section 10).&n; *&n; * Verification Tag:&n; * Inputs&n; * (endpoint, asoc, chunk)&n; *&n; * Outputs&n; * (asoc, reply_msg, msg_up, timers, counters)&n; *&n; * The return value is the disposition of the chunk.&n; */
DECL|function|sctp_sf_do_5_1E_ca
id|sctp_disposition_t
id|sctp_sf_do_5_1E_ca
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
r_const
id|sctp_subtype_t
id|type
comma
r_void
op_star
id|arg
comma
id|sctp_cmd_seq_t
op_star
id|commands
)paren
(brace
r_struct
id|sctp_ulpevent
op_star
id|ev
suffix:semicolon
multiline_comment|/* RFC 2960 5.1 Normal Establishment of an Association&n;&t; *&n;&t; * E) Upon reception of the COOKIE ACK, endpoint &quot;A&quot; will move&n;&t; * from the COOKIE-ECHOED state to the ESTABLISHED state,&n;&t; * stopping the T1-cookie timer.&n;&t; */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_TIMER_STOP
comma
id|SCTP_TO
c_func
(paren
id|SCTP_EVENT_TIMEOUT_T1_COOKIE
)paren
)paren
suffix:semicolon
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_NEW_STATE
comma
id|SCTP_STATE
c_func
(paren
id|SCTP_STATE_ESTABLISHED
)paren
)paren
suffix:semicolon
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_HB_TIMERS_START
comma
id|SCTP_NULL
c_func
(paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|asoc-&gt;autoclose
)paren
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_TIMER_START
comma
id|SCTP_TO
c_func
(paren
id|SCTP_EVENT_TIMEOUT_AUTOCLOSE
)paren
)paren
suffix:semicolon
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_TRANSMIT
comma
id|SCTP_NULL
c_func
(paren
)paren
)paren
suffix:semicolon
multiline_comment|/* It may also notify its ULP about the successful&n;&t; * establishment of the association with a Communication Up&n;&t; * notification (see Section 10).&n;&t; */
id|ev
op_assign
id|sctp_ulpevent_make_assoc_change
c_func
(paren
id|asoc
comma
l_int|0
comma
id|SCTP_COMM_UP
comma
l_int|0
comma
id|asoc-&gt;c.sinit_num_ostreams
comma
id|asoc-&gt;c.sinit_max_instreams
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ev
)paren
r_goto
id|nomem
suffix:semicolon
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_EVENT_ULP
comma
id|SCTP_ULPEVENT
c_func
(paren
id|ev
)paren
)paren
suffix:semicolon
r_return
id|SCTP_DISPOSITION_CONSUME
suffix:semicolon
id|nomem
suffix:colon
r_return
id|SCTP_DISPOSITION_NOMEM
suffix:semicolon
)brace
multiline_comment|/* Generate and sendout a heartbeat packet.  */
DECL|function|sctp_sf_heartbeat
id|sctp_disposition_t
id|sctp_sf_heartbeat
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
r_const
id|sctp_subtype_t
id|type
comma
r_void
op_star
id|arg
comma
id|sctp_cmd_seq_t
op_star
id|commands
)paren
(brace
r_struct
id|sctp_transport
op_star
id|transport
op_assign
(paren
r_struct
id|sctp_transport
op_star
)paren
id|arg
suffix:semicolon
id|sctp_chunk_t
op_star
id|reply
suffix:semicolon
id|sctp_sender_hb_info_t
id|hbinfo
suffix:semicolon
r_int
id|paylen
op_assign
l_int|0
suffix:semicolon
id|hbinfo.param_hdr.type
op_assign
id|SCTP_PARAM_HEARTBEAT_INFO
suffix:semicolon
id|hbinfo.param_hdr.length
op_assign
id|htons
c_func
(paren
r_sizeof
(paren
id|sctp_sender_hb_info_t
)paren
)paren
suffix:semicolon
id|hbinfo.daddr
op_assign
id|transport-&gt;ipaddr
suffix:semicolon
id|hbinfo.sent_at
op_assign
id|jiffies
suffix:semicolon
multiline_comment|/* Send a heartbeat to our peer.  */
id|paylen
op_assign
r_sizeof
(paren
id|sctp_sender_hb_info_t
)paren
suffix:semicolon
id|reply
op_assign
id|sctp_make_heartbeat
c_func
(paren
id|asoc
comma
id|transport
comma
op_amp
id|hbinfo
comma
id|paylen
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|reply
)paren
r_return
id|SCTP_DISPOSITION_NOMEM
suffix:semicolon
multiline_comment|/* Set rto_pending indicating that an RTT measurement&n;&t; * is started with this heartbeat chunk.&n;&t; */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_RTO_PENDING
comma
id|SCTP_TRANSPORT
c_func
(paren
id|transport
)paren
)paren
suffix:semicolon
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_REPLY
comma
id|SCTP_CHUNK
c_func
(paren
id|reply
)paren
)paren
suffix:semicolon
r_return
id|SCTP_DISPOSITION_CONSUME
suffix:semicolon
)brace
multiline_comment|/* Generate a HEARTBEAT packet on the given transport.  */
DECL|function|sctp_sf_sendbeat_8_3
id|sctp_disposition_t
id|sctp_sf_sendbeat_8_3
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
r_const
id|sctp_subtype_t
id|type
comma
r_void
op_star
id|arg
comma
id|sctp_cmd_seq_t
op_star
id|commands
)paren
(brace
r_struct
id|sctp_transport
op_star
id|transport
op_assign
(paren
r_struct
id|sctp_transport
op_star
)paren
id|arg
suffix:semicolon
r_if
c_cond
(paren
id|asoc-&gt;overall_error_count
op_ge
id|asoc-&gt;overall_error_threshold
)paren
(brace
multiline_comment|/* CMD_ASSOC_FAILED calls CMD_DELETE_TCB. */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_ASSOC_FAILED
comma
id|SCTP_NULL
c_func
(paren
)paren
)paren
suffix:semicolon
r_return
id|SCTP_DISPOSITION_DELETE_TCB
suffix:semicolon
)brace
multiline_comment|/* Section 3.3.5.&n;&t; * The Sender-specific Heartbeat Info field should normally include&n;&t; * information about the sender&squot;s current time when this HEARTBEAT&n;&t; * chunk is sent and the destination transport address to which this&n;&t; * HEARTBEAT is sent (see Section 8.3).&n;&t; */
r_if
c_cond
(paren
id|transport-&gt;hb_allowed
)paren
(brace
r_if
c_cond
(paren
id|SCTP_DISPOSITION_NOMEM
op_eq
id|sctp_sf_heartbeat
c_func
(paren
id|ep
comma
id|asoc
comma
id|type
comma
id|arg
comma
id|commands
)paren
)paren
r_return
id|SCTP_DISPOSITION_NOMEM
suffix:semicolon
multiline_comment|/* Set transport error counter and association error counter&n;&t;&t; * when sending heartbeat.&n;&t;&t; */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_TRANSPORT_RESET
comma
id|SCTP_TRANSPORT
c_func
(paren
id|transport
)paren
)paren
suffix:semicolon
)brace
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_HB_TIMER_UPDATE
comma
id|SCTP_TRANSPORT
c_func
(paren
id|transport
)paren
)paren
suffix:semicolon
r_return
id|SCTP_DISPOSITION_CONSUME
suffix:semicolon
)brace
multiline_comment|/*&n; * Process an heartbeat request.&n; *&n; * Section: 8.3 Path Heartbeat&n; * The receiver of the HEARTBEAT should immediately respond with a&n; * HEARTBEAT ACK that contains the Heartbeat Information field copied&n; * from the received HEARTBEAT chunk.&n; *&n; * Verification Tag:  8.5 Verification Tag [Normal verification]&n; * When receiving an SCTP packet, the endpoint MUST ensure that the&n; * value in the Verification Tag field of the received SCTP packet&n; * matches its own Tag. If the received Verification Tag value does not&n; * match the receiver&squot;s own tag value, the receiver shall silently&n; * discard the packet and shall not process it any further except for&n; * those cases listed in Section 8.5.1 below.&n; *&n; * Inputs&n; * (endpoint, asoc, chunk)&n; *&n; * Outputs&n; * (asoc, reply_msg, msg_up, timers, counters)&n; *&n; * The return value is the disposition of the chunk.&n; */
DECL|function|sctp_sf_beat_8_3
id|sctp_disposition_t
id|sctp_sf_beat_8_3
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
r_const
id|sctp_subtype_t
id|type
comma
r_void
op_star
id|arg
comma
id|sctp_cmd_seq_t
op_star
id|commands
)paren
(brace
id|sctp_chunk_t
op_star
id|chunk
op_assign
id|arg
suffix:semicolon
id|sctp_chunk_t
op_star
id|reply
suffix:semicolon
r_int
id|paylen
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* 8.5 When receiving an SCTP packet, the endpoint MUST ensure&n;&t; * that the value in the Verification Tag field of the&n;&t; * received SCTP packet matches its own Tag. If the received&n;&t; * Verification Tag value does not match the receiver&squot;s own&n;&t; * tag value, the receiver shall silently discard the packet...&n;&t; */
r_if
c_cond
(paren
id|ntohl
c_func
(paren
id|chunk-&gt;sctp_hdr-&gt;vtag
)paren
op_ne
id|asoc-&gt;c.my_vtag
)paren
r_return
id|sctp_sf_pdiscard
c_func
(paren
id|ep
comma
id|asoc
comma
id|type
comma
id|arg
comma
id|commands
)paren
suffix:semicolon
multiline_comment|/* 8.3 The receiver of the HEARTBEAT should immediately&n;&t; * respond with a HEARTBEAT ACK that contains the Heartbeat&n;&t; * Information field copied from the received HEARTBEAT chunk.&n;&t; */
id|chunk-&gt;subh.hb_hdr
op_assign
(paren
id|sctp_heartbeathdr_t
op_star
)paren
id|chunk-&gt;skb-&gt;data
suffix:semicolon
id|paylen
op_assign
id|ntohs
c_func
(paren
id|chunk-&gt;chunk_hdr-&gt;length
)paren
op_minus
r_sizeof
(paren
id|sctp_chunkhdr_t
)paren
suffix:semicolon
id|skb_pull
c_func
(paren
id|chunk-&gt;skb
comma
id|paylen
)paren
suffix:semicolon
id|reply
op_assign
id|sctp_make_heartbeat_ack
c_func
(paren
id|asoc
comma
id|chunk
comma
id|chunk-&gt;subh.hb_hdr
comma
id|paylen
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|reply
)paren
r_goto
id|nomem
suffix:semicolon
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_REPLY
comma
id|SCTP_CHUNK
c_func
(paren
id|reply
)paren
)paren
suffix:semicolon
r_return
id|SCTP_DISPOSITION_CONSUME
suffix:semicolon
id|nomem
suffix:colon
r_return
id|SCTP_DISPOSITION_NOMEM
suffix:semicolon
)brace
multiline_comment|/*&n; * Process the returning HEARTBEAT ACK.&n; *&n; * Section: 8.3 Path Heartbeat&n; * Upon the receipt of the HEARTBEAT ACK, the sender of the HEARTBEAT&n; * should clear the error counter of the destination transport&n; * address to which the HEARTBEAT was sent, and mark the destination&n; * transport address as active if it is not so marked. The endpoint may&n; * optionally report to the upper layer when an inactive destination&n; * address is marked as active due to the reception of the latest&n; * HEARTBEAT ACK. The receiver of the HEARTBEAT ACK must also&n; * clear the association overall error count as well (as defined&n; * in section 8.1).&n; *&n; * The receiver of the HEARTBEAT ACK should also perform an RTT&n; * measurement for that destination transport address using the time&n; * value carried in the HEARTBEAT ACK chunk.&n; *&n; * Verification Tag:  8.5 Verification Tag [Normal verification]&n; *&n; * Inputs&n; * (endpoint, asoc, chunk)&n; *&n; * Outputs&n; * (asoc, reply_msg, msg_up, timers, counters)&n; *&n; * The return value is the disposition of the chunk.&n; */
DECL|function|sctp_sf_backbeat_8_3
id|sctp_disposition_t
id|sctp_sf_backbeat_8_3
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
r_const
id|sctp_subtype_t
id|type
comma
r_void
op_star
id|arg
comma
id|sctp_cmd_seq_t
op_star
id|commands
)paren
(brace
id|sctp_chunk_t
op_star
id|chunk
op_assign
id|arg
suffix:semicolon
r_union
id|sctp_addr
id|from_addr
suffix:semicolon
r_struct
id|sctp_transport
op_star
id|link
suffix:semicolon
id|sctp_sender_hb_info_t
op_star
id|hbinfo
suffix:semicolon
r_int
r_int
id|max_interval
suffix:semicolon
multiline_comment|/* 8.5 When receiving an SCTP packet, the endpoint MUST ensure&n;&t; * that the value in the Verification Tag field of the&n;&t; * received SCTP packet matches its own Tag. ...&n;&t; */
r_if
c_cond
(paren
id|ntohl
c_func
(paren
id|chunk-&gt;sctp_hdr-&gt;vtag
)paren
op_ne
id|asoc-&gt;c.my_vtag
)paren
r_return
id|sctp_sf_pdiscard
c_func
(paren
id|ep
comma
id|asoc
comma
id|type
comma
id|arg
comma
id|commands
)paren
suffix:semicolon
id|hbinfo
op_assign
(paren
id|sctp_sender_hb_info_t
op_star
)paren
id|chunk-&gt;skb-&gt;data
suffix:semicolon
id|from_addr
op_assign
id|hbinfo-&gt;daddr
suffix:semicolon
id|link
op_assign
id|sctp_assoc_lookup_paddr
c_func
(paren
id|asoc
comma
op_amp
id|from_addr
)paren
suffix:semicolon
multiline_comment|/* This should never happen, but lets log it if so.  */
r_if
c_cond
(paren
op_logical_neg
id|link
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: Could not find address %d.%d.%d.%d&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|NIPQUAD
c_func
(paren
id|from_addr.v4.sin_addr
)paren
)paren
suffix:semicolon
r_return
id|SCTP_DISPOSITION_DISCARD
suffix:semicolon
)brace
id|max_interval
op_assign
id|link-&gt;hb_interval
op_plus
id|link-&gt;rto
suffix:semicolon
multiline_comment|/* Check if the timestamp looks valid.  */
r_if
c_cond
(paren
id|time_after
c_func
(paren
id|hbinfo-&gt;sent_at
comma
id|jiffies
)paren
op_logical_or
id|time_after
c_func
(paren
id|jiffies
comma
id|hbinfo-&gt;sent_at
op_plus
id|max_interval
)paren
)paren
(brace
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;%s: HEARTBEAT ACK with invalid timestamp&quot;
l_string|&quot;received for transport: %p&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|link
)paren
suffix:semicolon
r_return
id|SCTP_DISPOSITION_DISCARD
suffix:semicolon
)brace
multiline_comment|/* 8.3 Upon the receipt of the HEARTBEAT ACK, the sender of&n;&t; * the HEARTBEAT should clear the error counter of the&n;&t; * destination transport address to which the HEARTBEAT was&n;&t; * sent and mark the destination transport address as active if&n;&t; * it is not so marked.&n;&t; */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_TRANSPORT_ON
comma
id|SCTP_TRANSPORT
c_func
(paren
id|link
)paren
)paren
suffix:semicolon
r_return
id|SCTP_DISPOSITION_CONSUME
suffix:semicolon
)brace
multiline_comment|/* Helper function to send out an abort for the restart&n; * condition.&n; */
DECL|function|sctp_sf_send_restart_abort
r_static
r_int
id|sctp_sf_send_restart_abort
c_func
(paren
r_union
id|sctp_addr
op_star
id|ssa
comma
id|sctp_chunk_t
op_star
id|init
comma
id|sctp_cmd_seq_t
op_star
id|commands
)paren
(brace
r_int
id|len
suffix:semicolon
id|sctp_packet_t
op_star
id|pkt
suffix:semicolon
id|sctp_addr_param_t
op_star
id|addrparm
suffix:semicolon
id|sctp_errhdr_t
op_star
id|errhdr
suffix:semicolon
id|sctp_endpoint_t
op_star
id|ep
suffix:semicolon
r_char
id|buffer
(braket
r_sizeof
(paren
id|sctp_errhdr_t
)paren
op_plus
r_sizeof
(paren
id|sctp_addr_param_t
)paren
)braket
suffix:semicolon
multiline_comment|/* Build the error on the stack.   We are way to malloc&n;&t; * malloc crazy throughout the code today.&n;&t; */
id|errhdr
op_assign
(paren
id|sctp_errhdr_t
op_star
)paren
id|buffer
suffix:semicolon
id|addrparm
op_assign
(paren
id|sctp_addr_param_t
op_star
)paren
id|errhdr-&gt;variable
suffix:semicolon
multiline_comment|/* Copy into a parm format. */
id|len
op_assign
id|sockaddr2sctp_addr
c_func
(paren
id|ssa
comma
id|addrparm
)paren
suffix:semicolon
id|len
op_add_assign
r_sizeof
(paren
id|sctp_errhdr_t
)paren
suffix:semicolon
id|errhdr-&gt;cause
op_assign
id|SCTP_ERROR_RESTART
suffix:semicolon
id|errhdr-&gt;length
op_assign
id|htons
c_func
(paren
id|len
)paren
suffix:semicolon
multiline_comment|/* Assign to the control socket. */
id|ep
op_assign
id|sctp_sk
c_func
(paren
(paren
id|sctp_get_ctl_sock
c_func
(paren
)paren
)paren
)paren
op_member_access_from_pointer
id|ep
suffix:semicolon
multiline_comment|/* Association is NULL since this may be a restart attack and we&n;&t; * want to send back the attacker&squot;s vtag.&n;&t; */
id|pkt
op_assign
id|sctp_abort_pkt_new
c_func
(paren
id|ep
comma
l_int|NULL
comma
id|init
comma
id|errhdr
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pkt
)paren
r_goto
id|out
suffix:semicolon
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_SEND_PKT
comma
id|SCTP_PACKET
c_func
(paren
id|pkt
)paren
)paren
suffix:semicolon
multiline_comment|/* Discard the rest of the inbound packet. */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_DISCARD_PACKET
comma
id|SCTP_NULL
c_func
(paren
)paren
)paren
suffix:semicolon
id|out
suffix:colon
multiline_comment|/* Even if there is no memory, treat as a failure so&n;&t; * the packet will get dropped.&n;&t; */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* A restart is occuring, check to make sure no new addresses&n; * are being added as we may be under a takeover attack.&n; */
DECL|function|sctp_sf_check_restart_addrs
r_static
r_int
id|sctp_sf_check_restart_addrs
c_func
(paren
r_const
id|sctp_association_t
op_star
id|new_asoc
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
id|sctp_chunk_t
op_star
id|init
comma
id|sctp_cmd_seq_t
op_star
id|commands
)paren
(brace
r_struct
id|sctp_transport
op_star
id|new_addr
comma
op_star
id|addr
suffix:semicolon
r_struct
id|list_head
op_star
id|pos
comma
op_star
id|pos2
suffix:semicolon
r_int
id|found
suffix:semicolon
multiline_comment|/* Implementor&squot;s Guide - Sectin 5.2.2&n;&t; * ...&n;&t; * Before responding the endpoint MUST check to see if the&n;&t; * unexpected INIT adds new addresses to the association. If new&n;&t; * addresses are added to the association, the endpoint MUST respond&n;&t; * with an ABORT..&n;&t; */
multiline_comment|/* Search through all current addresses and make sure&n;&t; * we aren&squot;t adding any new ones.&n;&t; */
id|new_addr
op_assign
l_int|0
suffix:semicolon
id|found
op_assign
l_int|0
suffix:semicolon
id|list_for_each
c_func
(paren
id|pos
comma
op_amp
id|new_asoc-&gt;peer.transport_addr_list
)paren
(brace
id|new_addr
op_assign
id|list_entry
c_func
(paren
id|pos
comma
r_struct
id|sctp_transport
comma
id|transports
)paren
suffix:semicolon
id|found
op_assign
l_int|0
suffix:semicolon
id|list_for_each
c_func
(paren
id|pos2
comma
op_amp
id|asoc-&gt;peer.transport_addr_list
)paren
(brace
id|addr
op_assign
id|list_entry
c_func
(paren
id|pos2
comma
r_struct
id|sctp_transport
comma
id|transports
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sctp_cmp_addr_exact
c_func
(paren
op_amp
id|new_addr-&gt;ipaddr
comma
op_amp
id|addr-&gt;ipaddr
)paren
)paren
(brace
id|found
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|found
)paren
r_break
suffix:semicolon
)brace
multiline_comment|/* If a new address was added, ABORT the sender. */
r_if
c_cond
(paren
op_logical_neg
id|found
op_logical_and
id|new_addr
)paren
(brace
id|sctp_sf_send_restart_abort
c_func
(paren
op_amp
id|new_addr-&gt;ipaddr
comma
id|init
comma
id|commands
)paren
suffix:semicolon
)brace
multiline_comment|/* Return success if all addresses were found. */
r_return
id|found
suffix:semicolon
)brace
multiline_comment|/* Populate the verification/tie tags based on overlapping INIT&n; * scenario.&n; *&n; * Note: Do not use in CLOSED or SHUTDOWN-ACK-SENT state.&n; */
DECL|function|sctp_tietags_populate
r_static
r_void
id|sctp_tietags_populate
c_func
(paren
id|sctp_association_t
op_star
id|new_asoc
comma
r_const
id|sctp_association_t
op_star
id|asoc
)paren
(brace
r_switch
c_cond
(paren
id|asoc-&gt;state
)paren
(brace
multiline_comment|/* 5.2.1 INIT received in COOKIE-WAIT or COOKIE-ECHOED State */
r_case
id|SCTP_STATE_COOKIE_WAIT
suffix:colon
id|new_asoc-&gt;c.my_vtag
op_assign
id|asoc-&gt;c.my_vtag
suffix:semicolon
id|new_asoc-&gt;c.my_ttag
op_assign
id|asoc-&gt;c.my_vtag
suffix:semicolon
id|new_asoc-&gt;c.peer_ttag
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_STATE_COOKIE_ECHOED
suffix:colon
id|new_asoc-&gt;c.my_vtag
op_assign
id|asoc-&gt;c.my_vtag
suffix:semicolon
id|new_asoc-&gt;c.my_ttag
op_assign
id|asoc-&gt;c.my_vtag
suffix:semicolon
id|new_asoc-&gt;c.peer_ttag
op_assign
id|asoc-&gt;c.peer_vtag
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* 5.2.2 Unexpected INIT in States Other than CLOSED, COOKIE-ECHOED,&n;&t; * COOKIE-WAIT and SHUTDOWN-ACK-SENT&n;&t; */
r_default
suffix:colon
id|new_asoc-&gt;c.my_ttag
op_assign
id|asoc-&gt;c.my_vtag
suffix:semicolon
id|new_asoc-&gt;c.peer_ttag
op_assign
id|asoc-&gt;c.peer_vtag
suffix:semicolon
r_break
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* Other parameters for the endpoint SHOULD be copied from the&n;&t; * existing parameters of the association (e.g. number of&n;&t; * outbound streams) into the INIT ACK and cookie.&n;&t; */
id|new_asoc-&gt;rwnd
op_assign
id|asoc-&gt;rwnd
suffix:semicolon
id|new_asoc-&gt;c.sinit_num_ostreams
op_assign
id|asoc-&gt;c.sinit_num_ostreams
suffix:semicolon
id|new_asoc-&gt;c.sinit_max_instreams
op_assign
id|asoc-&gt;c.sinit_max_instreams
suffix:semicolon
id|new_asoc-&gt;c.initial_tsn
op_assign
id|asoc-&gt;c.initial_tsn
suffix:semicolon
)brace
multiline_comment|/*&n; * Compare vtag/tietag values to determine unexpected COOKIE-ECHO&n; * handling action.&n; *&n; * RFC 2960 5.2.4 Handle a COOKIE ECHO when a TCB exists.&n; *&n; * Returns value representing action to be taken.   These action values&n; * correspond to Action/Description values in RFC 2960, Table 2.&n; */
DECL|function|sctp_tietags_compare
r_static
r_char
id|sctp_tietags_compare
c_func
(paren
id|sctp_association_t
op_star
id|new_asoc
comma
r_const
id|sctp_association_t
op_star
id|asoc
)paren
(brace
multiline_comment|/* In this case, the peer may have restarted.  */
r_if
c_cond
(paren
(paren
id|asoc-&gt;c.my_vtag
op_ne
id|new_asoc-&gt;c.my_vtag
)paren
op_logical_and
(paren
id|asoc-&gt;c.peer_vtag
op_ne
id|new_asoc-&gt;c.peer_vtag
)paren
op_logical_and
(paren
id|asoc-&gt;c.my_vtag
op_eq
id|new_asoc-&gt;c.my_ttag
)paren
op_logical_and
(paren
id|asoc-&gt;c.peer_vtag
op_eq
id|new_asoc-&gt;c.peer_ttag
)paren
)paren
r_return
l_char|&squot;A&squot;
suffix:semicolon
multiline_comment|/* Collision case B. */
r_if
c_cond
(paren
(paren
id|asoc-&gt;c.my_vtag
op_eq
id|new_asoc-&gt;c.my_vtag
)paren
op_logical_and
(paren
(paren
id|asoc-&gt;c.peer_vtag
op_ne
id|new_asoc-&gt;c.peer_vtag
)paren
op_logical_or
(paren
l_int|0
op_eq
id|asoc-&gt;c.peer_vtag
)paren
)paren
)paren
(brace
r_return
l_char|&squot;B&squot;
suffix:semicolon
)brace
multiline_comment|/* Collision case D. */
r_if
c_cond
(paren
(paren
id|asoc-&gt;c.my_vtag
op_eq
id|new_asoc-&gt;c.my_vtag
)paren
op_logical_and
(paren
id|asoc-&gt;c.peer_vtag
op_eq
id|new_asoc-&gt;c.peer_vtag
)paren
)paren
r_return
l_char|&squot;D&squot;
suffix:semicolon
multiline_comment|/* Collision case C. */
r_if
c_cond
(paren
(paren
id|asoc-&gt;c.my_vtag
op_ne
id|new_asoc-&gt;c.my_vtag
)paren
op_logical_and
(paren
id|asoc-&gt;c.peer_vtag
op_eq
id|new_asoc-&gt;c.peer_vtag
)paren
op_logical_and
(paren
l_int|0
op_eq
id|new_asoc-&gt;c.my_ttag
)paren
op_logical_and
(paren
l_int|0
op_eq
id|new_asoc-&gt;c.peer_ttag
)paren
)paren
r_return
l_char|&squot;C&squot;
suffix:semicolon
multiline_comment|/* No match to any of the special cases; discard this packet. */
r_return
l_char|&squot;E&squot;
suffix:semicolon
)brace
multiline_comment|/* Common helper routine for both duplicate and simulataneous INIT&n; * chunk handling.&n; */
DECL|function|sctp_sf_do_unexpected_init
r_static
id|sctp_disposition_t
id|sctp_sf_do_unexpected_init
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
r_const
id|sctp_subtype_t
id|type
comma
r_void
op_star
id|arg
comma
id|sctp_cmd_seq_t
op_star
id|commands
)paren
(brace
id|sctp_disposition_t
id|retval
suffix:semicolon
id|sctp_chunk_t
op_star
id|chunk
op_assign
id|arg
suffix:semicolon
id|sctp_chunk_t
op_star
id|repl
suffix:semicolon
id|sctp_association_t
op_star
id|new_asoc
suffix:semicolon
id|sctp_chunk_t
op_star
id|err_chunk
suffix:semicolon
id|sctp_packet_t
op_star
id|packet
suffix:semicolon
id|sctp_unrecognized_param_t
op_star
id|unk_param
suffix:semicolon
r_int
id|len
suffix:semicolon
multiline_comment|/* 6.10 Bundling&n;&t; * An endpoint MUST NOT bundle INIT, INIT ACK or&n;&t; * SHUTDOWN COMPLETE with any other chunks.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|chunk-&gt;singleton
)paren
r_return
id|SCTP_DISPOSITION_VIOLATION
suffix:semicolon
multiline_comment|/* Grab the INIT header.  */
id|chunk-&gt;subh.init_hdr
op_assign
(paren
id|sctp_inithdr_t
op_star
)paren
id|chunk-&gt;skb-&gt;data
suffix:semicolon
multiline_comment|/* Tag the variable length parameters.  */
id|chunk-&gt;param_hdr.v
op_assign
id|skb_pull
c_func
(paren
id|chunk-&gt;skb
comma
r_sizeof
(paren
id|sctp_inithdr_t
)paren
)paren
suffix:semicolon
multiline_comment|/* Verify the INIT chunk before processing it. */
id|err_chunk
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sctp_verify_init
c_func
(paren
id|asoc
comma
id|chunk-&gt;chunk_hdr-&gt;type
comma
(paren
id|sctp_init_chunk_t
op_star
)paren
id|chunk-&gt;chunk_hdr
comma
id|chunk
comma
op_amp
id|err_chunk
)paren
)paren
(brace
multiline_comment|/* This chunk contains fatal error. It is to be discarded.&n;&t;&t; * Send an ABORT, with causes if there is any.&n;&t;&t; */
r_if
c_cond
(paren
id|err_chunk
)paren
(brace
id|packet
op_assign
id|sctp_abort_pkt_new
c_func
(paren
id|ep
comma
id|asoc
comma
id|arg
comma
(paren
id|__u8
op_star
)paren
(paren
id|err_chunk-&gt;chunk_hdr
)paren
op_plus
r_sizeof
(paren
id|sctp_chunkhdr_t
)paren
comma
id|ntohs
c_func
(paren
id|err_chunk-&gt;chunk_hdr-&gt;length
)paren
op_minus
r_sizeof
(paren
id|sctp_chunkhdr_t
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|packet
)paren
(brace
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_SEND_PKT
comma
id|SCTP_PACKET
c_func
(paren
id|packet
)paren
)paren
suffix:semicolon
id|retval
op_assign
id|SCTP_DISPOSITION_CONSUME
suffix:semicolon
)brace
r_else
(brace
id|retval
op_assign
id|SCTP_DISPOSITION_NOMEM
suffix:semicolon
)brace
r_goto
id|cleanup
suffix:semicolon
)brace
r_else
(brace
r_return
id|sctp_sf_tabort_8_4_8
c_func
(paren
id|ep
comma
id|asoc
comma
id|type
comma
id|arg
comma
id|commands
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Other parameters for the endpoint SHOULD be copied from the&n;&t; * existing parameters of the association (e.g. number of&n;&t; * outbound streams) into the INIT ACK and cookie.&n;&t; * FIXME:  We are copying parameters from the endpoint not the&n;&t; * association.&n;&t; */
id|new_asoc
op_assign
id|sctp_make_temp_asoc
c_func
(paren
id|ep
comma
id|chunk
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|new_asoc
)paren
r_goto
id|nomem
suffix:semicolon
multiline_comment|/* In the outbound INIT ACK the endpoint MUST copy its current&n;&t; * Verification Tag and Peers Verification tag into a reserved&n;&t; * place (local tie-tag and per tie-tag) within the state cookie.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|sctp_process_init
c_func
(paren
id|new_asoc
comma
id|chunk-&gt;chunk_hdr-&gt;type
comma
id|sctp_source
c_func
(paren
id|chunk
)paren
comma
(paren
id|sctp_init_chunk_t
op_star
)paren
id|chunk-&gt;chunk_hdr
comma
id|GFP_ATOMIC
)paren
)paren
(brace
id|retval
op_assign
id|SCTP_DISPOSITION_NOMEM
suffix:semicolon
r_goto
id|nomem_init
suffix:semicolon
)brace
multiline_comment|/* Make sure no new addresses are being added during the&n;&t; * restart.   Do not do this check for COOKIE-WAIT state,&n;&t; * since there are no peer addresses to check against.&n;&t; * Upon return an ABORT will have been sent if needed.&n;&t; */
r_if
c_cond
(paren
id|asoc-&gt;state
op_ne
id|SCTP_STATE_COOKIE_WAIT
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|sctp_sf_check_restart_addrs
c_func
(paren
id|new_asoc
comma
id|asoc
comma
id|chunk
comma
id|commands
)paren
)paren
(brace
id|retval
op_assign
id|SCTP_DISPOSITION_CONSUME
suffix:semicolon
r_goto
id|cleanup_asoc
suffix:semicolon
)brace
)brace
id|sctp_tietags_populate
c_func
(paren
id|new_asoc
comma
id|asoc
)paren
suffix:semicolon
multiline_comment|/* B) &quot;Z&quot; shall respond immediately with an INIT ACK chunk.  */
multiline_comment|/* If there are errors need to be reported for unknown parameters,&n;&t; * make sure to reserve enough room in the INIT ACK for them.&n;&t; */
id|len
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|err_chunk
)paren
(brace
id|len
op_assign
id|ntohs
c_func
(paren
id|err_chunk-&gt;chunk_hdr-&gt;length
)paren
op_minus
r_sizeof
(paren
id|sctp_chunkhdr_t
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sctp_assoc_set_bind_addr_from_ep
c_func
(paren
id|new_asoc
comma
id|GFP_ATOMIC
)paren
OL
l_int|0
)paren
r_goto
id|nomem
suffix:semicolon
id|repl
op_assign
id|sctp_make_init_ack
c_func
(paren
id|new_asoc
comma
id|chunk
comma
id|GFP_ATOMIC
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|repl
)paren
r_goto
id|nomem
suffix:semicolon
multiline_comment|/* If there are errors need to be reported for unknown parameters,&n;&t; * include them in the outgoing INIT ACK as &quot;Unrecognized parameter&quot;&n;&t; * parameter.&n;&t; */
r_if
c_cond
(paren
id|err_chunk
)paren
(brace
multiline_comment|/* Get the &quot;Unrecognized parameter&quot; parameter(s) out of the&n;&t;&t; * ERROR chunk generated by sctp_verify_init(). Since the&n;&t;&t; * error cause code for &quot;unknown parameter&quot; and the&n;&t;&t; * &quot;Unrecognized parameter&quot; type is the same, we can&n;&t;&t; * construct the parameters in INIT ACK by copying the&n;&t;&t; * ERROR causes over.&n;&t;&t; */
id|unk_param
op_assign
(paren
id|sctp_unrecognized_param_t
op_star
)paren
(paren
(paren
id|__u8
op_star
)paren
(paren
id|err_chunk-&gt;chunk_hdr
)paren
op_plus
r_sizeof
(paren
id|sctp_chunkhdr_t
)paren
)paren
suffix:semicolon
multiline_comment|/* Replace the cause code with the &quot;Unrecognized parameter&quot;&n;&t;&t; * parameter type.&n;&t;&t; */
id|sctp_addto_chunk
c_func
(paren
id|repl
comma
id|len
comma
id|unk_param
)paren
suffix:semicolon
id|sctp_free_chunk
c_func
(paren
id|err_chunk
)paren
suffix:semicolon
)brace
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_NEW_ASOC
comma
id|SCTP_ASOC
c_func
(paren
id|new_asoc
)paren
)paren
suffix:semicolon
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_REPLY
comma
id|SCTP_CHUNK
c_func
(paren
id|repl
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Note: After sending out INIT ACK with the State Cookie parameter,&n;&t; * &quot;Z&quot; MUST NOT allocate any resources for this new association.&n;&t; * Otherwise, &quot;Z&quot; will be vulnerable to resource attacks.&n;&t; */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_DELETE_TCB
comma
id|SCTP_NULL
c_func
(paren
)paren
)paren
suffix:semicolon
id|retval
op_assign
id|SCTP_DISPOSITION_CONSUME
suffix:semicolon
id|cleanup
suffix:colon
r_if
c_cond
(paren
id|err_chunk
)paren
id|sctp_free_chunk
c_func
(paren
id|err_chunk
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
id|nomem
suffix:colon
id|retval
op_assign
id|SCTP_DISPOSITION_NOMEM
suffix:semicolon
r_goto
id|cleanup
suffix:semicolon
id|nomem_init
suffix:colon
id|cleanup_asoc
suffix:colon
id|sctp_association_free
c_func
(paren
id|new_asoc
)paren
suffix:semicolon
r_goto
id|cleanup
suffix:semicolon
)brace
multiline_comment|/*&n; * Handle simultanous INIT.&n; * This means we started an INIT and then we got an INIT request from&n; * our peer.&n; *&n; * Section: 5.2.1 INIT received in COOKIE-WAIT or COOKIE-ECHOED State (Item B)&n; * This usually indicates an initialization collision, i.e., each&n; * endpoint is attempting, at about the same time, to establish an&n; * association with the other endpoint.&n; *&n; * Upon receipt of an INIT in the COOKIE-WAIT or COOKIE-ECHOED state, an&n; * endpoint MUST respond with an INIT ACK using the same parameters it&n; * sent in its original INIT chunk (including its Verification Tag,&n; * unchanged). These original parameters are combined with those from the&n; * newly received INIT chunk. The endpoint shall also generate a State&n; * Cookie with the INIT ACK. The endpoint uses the parameters sent in its&n; * INIT to calculate the State Cookie.&n; *&n; * After that, the endpoint MUST NOT change its state, the T1-init&n; * timer shall be left running and the corresponding TCB MUST NOT be&n; * destroyed. The normal procedures for handling State Cookies when&n; * a TCB exists will resolve the duplicate INITs to a single association.&n; *&n; * For an endpoint that is in the COOKIE-ECHOED state it MUST populate&n; * its Tie-Tags with the Tag information of itself and its peer (see&n; * section 5.2.2 for a description of the Tie-Tags).&n; *&n; * Verification Tag: Not explicit, but an INIT can not have a valid&n; * verification tag, so we skip the check.&n; *&n; * Inputs&n; * (endpoint, asoc, chunk)&n; *&n; * Outputs&n; * (asoc, reply_msg, msg_up, timers, counters)&n; *&n; * The return value is the disposition of the chunk.&n; */
DECL|function|sctp_sf_do_5_2_1_siminit
id|sctp_disposition_t
id|sctp_sf_do_5_2_1_siminit
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
r_const
id|sctp_subtype_t
id|type
comma
r_void
op_star
id|arg
comma
id|sctp_cmd_seq_t
op_star
id|commands
)paren
(brace
multiline_comment|/* Call helper to do the real work for both simulataneous and&n;&t; * duplicate INIT chunk handling.&n;&t; */
r_return
id|sctp_sf_do_unexpected_init
c_func
(paren
id|ep
comma
id|asoc
comma
id|type
comma
id|arg
comma
id|commands
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Handle duplicated INIT messages.  These are usually delayed&n; * restransmissions.&n; *&n; * Section: 5.2.2 Unexpected INIT in States Other than CLOSED,&n; * COOKIE-ECHOED and COOKIE-WAIT&n; *&n; * Unless otherwise stated, upon reception of an unexpected INIT for&n; * this association, the endpoint shall generate an INIT ACK with a&n; * State Cookie.  In the outbound INIT ACK the endpoint MUST copy its&n; * current Verification Tag and peer&squot;s Verification Tag into a reserved&n; * place within the state cookie.  We shall refer to these locations as&n; * the Peer&squot;s-Tie-Tag and the Local-Tie-Tag.  The outbound SCTP packet&n; * containing this INIT ACK MUST carry a Verification Tag value equal to&n; * the Initiation Tag found in the unexpected INIT.  And the INIT ACK&n; * MUST contain a new Initiation Tag (randomly generated see Section&n; * 5.3.1).  Other parameters for the endpoint SHOULD be copied from the&n; * existing parameters of the association (e.g. number of outbound&n; * streams) into the INIT ACK and cookie.&n; *&n; * After sending out the INIT ACK, the endpoint shall take no further&n; * actions, i.e., the existing association, including its current state,&n; * and the corresponding TCB MUST NOT be changed.&n; *&n; * Note: Only when a TCB exists and the association is not in a COOKIE-&n; * WAIT state are the Tie-Tags populated.  For a normal association INIT&n; * (i.e. the endpoint is in a COOKIE-WAIT state), the Tie-Tags MUST be&n; * set to 0 (indicating that no previous TCB existed).  The INIT ACK and&n; * State Cookie are populated as specified in section 5.2.1.&n; *&n; * Verification Tag: Not specifed, but an INIT has no way of knowing&n; * what the verification tag could be, so we ignore it.&n; *&n; * Inputs&n; * (endpoint, asoc, chunk)&n; *&n; * Outputs&n; * (asoc, reply_msg, msg_up, timers, counters)&n; *&n; * The return value is the disposition of the chunk.&n; */
DECL|function|sctp_sf_do_5_2_2_dupinit
id|sctp_disposition_t
id|sctp_sf_do_5_2_2_dupinit
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
r_const
id|sctp_subtype_t
id|type
comma
r_void
op_star
id|arg
comma
id|sctp_cmd_seq_t
op_star
id|commands
)paren
(brace
multiline_comment|/* Call helper to do the real work for both simulataneous and&n;&t; * duplicate INIT chunk handling.&n;&t; */
r_return
id|sctp_sf_do_unexpected_init
c_func
(paren
id|ep
comma
id|asoc
comma
id|type
comma
id|arg
comma
id|commands
)paren
suffix:semicolon
)brace
multiline_comment|/* Unexpected COOKIE-ECHO handler for peer restart (Table 2, action &squot;A&squot;)&n; *&n; * Section 5.2.4&n; *  A)  In this case, the peer may have restarted.&n; */
DECL|function|sctp_sf_do_dupcook_a
r_static
id|sctp_disposition_t
id|sctp_sf_do_dupcook_a
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
id|sctp_chunk_t
op_star
id|chunk
comma
id|sctp_cmd_seq_t
op_star
id|commands
comma
id|sctp_association_t
op_star
id|new_asoc
)paren
(brace
id|sctp_init_chunk_t
op_star
id|peer_init
suffix:semicolon
r_struct
id|sctp_ulpevent
op_star
id|ev
suffix:semicolon
id|sctp_chunk_t
op_star
id|repl
suffix:semicolon
multiline_comment|/* new_asoc is a brand-new association, so these are not yet&n;&t; * side effects--it is safe to run them here.&n;&t; */
id|peer_init
op_assign
op_amp
id|chunk-&gt;subh.cookie_hdr-&gt;c.peer_init
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sctp_process_init
c_func
(paren
id|new_asoc
comma
id|chunk-&gt;chunk_hdr-&gt;type
comma
id|sctp_source
c_func
(paren
id|chunk
)paren
comma
id|peer_init
comma
id|GFP_ATOMIC
)paren
)paren
r_goto
id|nomem
suffix:semicolon
multiline_comment|/* Make sure no new addresses are being added during the&n;&t; * restart.  Though this is a pretty complicated attack&n;&t; * since you&squot;d have to get inside the cookie.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|sctp_sf_check_restart_addrs
c_func
(paren
id|new_asoc
comma
id|asoc
comma
id|chunk
comma
id|commands
)paren
)paren
(brace
r_return
id|SCTP_DISPOSITION_CONSUME
suffix:semicolon
)brace
multiline_comment|/* For now, fail any unsent/unacked data.  Consider the optional&n;&t; * choice of resending of this data.&n;&t; */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_PURGE_OUTQUEUE
comma
id|SCTP_NULL
c_func
(paren
)paren
)paren
suffix:semicolon
multiline_comment|/* Update the content of current association. */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_UPDATE_ASSOC
comma
id|SCTP_ASOC
c_func
(paren
id|new_asoc
)paren
)paren
suffix:semicolon
id|repl
op_assign
id|sctp_make_cookie_ack
c_func
(paren
id|new_asoc
comma
id|chunk
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|repl
)paren
r_goto
id|nomem
suffix:semicolon
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_REPLY
comma
id|SCTP_CHUNK
c_func
(paren
id|repl
)paren
)paren
suffix:semicolon
multiline_comment|/* Report association restart to upper layer. */
id|ev
op_assign
id|sctp_ulpevent_make_assoc_change
c_func
(paren
id|asoc
comma
l_int|0
comma
id|SCTP_RESTART
comma
l_int|0
comma
id|new_asoc-&gt;c.sinit_num_ostreams
comma
id|new_asoc-&gt;c.sinit_max_instreams
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ev
)paren
r_goto
id|nomem_ev
suffix:semicolon
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_EVENT_ULP
comma
id|SCTP_ULPEVENT
c_func
(paren
id|ev
)paren
)paren
suffix:semicolon
r_return
id|SCTP_DISPOSITION_CONSUME
suffix:semicolon
id|nomem_ev
suffix:colon
id|sctp_free_chunk
c_func
(paren
id|repl
)paren
suffix:semicolon
id|nomem
suffix:colon
r_return
id|SCTP_DISPOSITION_NOMEM
suffix:semicolon
)brace
multiline_comment|/* Unexpected COOKIE-ECHO handler for setup collision (Table 2, action &squot;B&squot;)&n; *&n; * Section 5.2.4&n; *   B) In this case, both sides may be attempting to start an association&n; *      at about the same time but the peer endpoint started its INIT&n; *      after responding to the local endpoint&squot;s INIT&n; */
multiline_comment|/* This case represents an intialization collision.  */
DECL|function|sctp_sf_do_dupcook_b
r_static
id|sctp_disposition_t
id|sctp_sf_do_dupcook_b
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
id|sctp_chunk_t
op_star
id|chunk
comma
id|sctp_cmd_seq_t
op_star
id|commands
comma
id|sctp_association_t
op_star
id|new_asoc
)paren
(brace
id|sctp_init_chunk_t
op_star
id|peer_init
suffix:semicolon
r_struct
id|sctp_ulpevent
op_star
id|ev
suffix:semicolon
id|sctp_chunk_t
op_star
id|repl
suffix:semicolon
multiline_comment|/* new_asoc is a brand-new association, so these are not yet&n;&t; * side effects--it is safe to run them here.&n;&t; */
id|peer_init
op_assign
op_amp
id|chunk-&gt;subh.cookie_hdr-&gt;c.peer_init
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sctp_process_init
c_func
(paren
id|new_asoc
comma
id|chunk-&gt;chunk_hdr-&gt;type
comma
id|sctp_source
c_func
(paren
id|chunk
)paren
comma
id|peer_init
comma
id|GFP_ATOMIC
)paren
)paren
r_goto
id|nomem
suffix:semicolon
multiline_comment|/* Update the content of current association.  */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_UPDATE_ASSOC
comma
id|SCTP_ASOC
c_func
(paren
id|new_asoc
)paren
)paren
suffix:semicolon
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_NEW_STATE
comma
id|SCTP_STATE
c_func
(paren
id|SCTP_STATE_ESTABLISHED
)paren
)paren
suffix:semicolon
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_HB_TIMERS_START
comma
id|SCTP_NULL
c_func
(paren
)paren
)paren
suffix:semicolon
id|repl
op_assign
id|sctp_make_cookie_ack
c_func
(paren
id|new_asoc
comma
id|chunk
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|repl
)paren
r_goto
id|nomem
suffix:semicolon
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_REPLY
comma
id|SCTP_CHUNK
c_func
(paren
id|repl
)paren
)paren
suffix:semicolon
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_TRANSMIT
comma
id|SCTP_NULL
c_func
(paren
)paren
)paren
suffix:semicolon
multiline_comment|/* RFC 2960 5.1 Normal Establishment of an Association&n;&t; *&n;&t; * D) IMPLEMENTATION NOTE: An implementation may choose to&n;&t; * send the Communication Up notification to the SCTP user&n;&t; * upon reception of a valid COOKIE ECHO chunk.&n;&t; */
id|ev
op_assign
id|sctp_ulpevent_make_assoc_change
c_func
(paren
id|asoc
comma
l_int|0
comma
id|SCTP_COMM_UP
comma
l_int|0
comma
id|new_asoc-&gt;c.sinit_num_ostreams
comma
id|new_asoc-&gt;c.sinit_max_instreams
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ev
)paren
r_goto
id|nomem_ev
suffix:semicolon
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_EVENT_ULP
comma
id|SCTP_ULPEVENT
c_func
(paren
id|ev
)paren
)paren
suffix:semicolon
r_return
id|SCTP_DISPOSITION_CONSUME
suffix:semicolon
id|nomem_ev
suffix:colon
id|sctp_free_chunk
c_func
(paren
id|repl
)paren
suffix:semicolon
id|nomem
suffix:colon
r_return
id|SCTP_DISPOSITION_NOMEM
suffix:semicolon
)brace
multiline_comment|/* Unexpected COOKIE-ECHO handler for setup collision (Table 2, action &squot;C&squot;)&n; *&n; * Section 5.2.4&n; *  C) In this case, the local endpoint&squot;s cookie has arrived late.&n; *     Before it arrived, the local endpoint sent an INIT and received an&n; *     INIT-ACK and finally sent a COOKIE ECHO with the peer&squot;s same tag&n; *     but a new tag of its own.&n; */
multiline_comment|/* This case represents an intialization collision.  */
DECL|function|sctp_sf_do_dupcook_c
r_static
id|sctp_disposition_t
id|sctp_sf_do_dupcook_c
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
id|sctp_chunk_t
op_star
id|chunk
comma
id|sctp_cmd_seq_t
op_star
id|commands
comma
id|sctp_association_t
op_star
id|new_asoc
)paren
(brace
multiline_comment|/* The cookie should be silently discarded.&n;&t; * The endpoint SHOULD NOT change states and should leave&n;&t; * any timers running.&n;&t; */
r_return
id|SCTP_DISPOSITION_DISCARD
suffix:semicolon
)brace
multiline_comment|/* Unexpected COOKIE-ECHO handler lost chunk (Table 2, action &squot;D&squot;)&n; *&n; * Section 5.2.4&n; *&n; * D) When both local and remote tags match the endpoint should always&n; *    enter the ESTABLISHED state, if it has not already done so.&n; */
multiline_comment|/* This case represents an intialization collision.  */
DECL|function|sctp_sf_do_dupcook_d
r_static
id|sctp_disposition_t
id|sctp_sf_do_dupcook_d
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
id|sctp_chunk_t
op_star
id|chunk
comma
id|sctp_cmd_seq_t
op_star
id|commands
comma
id|sctp_association_t
op_star
id|new_asoc
)paren
(brace
r_struct
id|sctp_ulpevent
op_star
id|ev
op_assign
l_int|NULL
suffix:semicolon
id|sctp_chunk_t
op_star
id|repl
suffix:semicolon
multiline_comment|/* Clarification from Implementor&squot;s Guide:&n;&t; * D) When both local and remote tags match the endpoint should&n;         * enter the ESTABLISHED state, if it is in the COOKIE-ECHOED state.&n;         * It should stop any cookie timer that may be running and send&n;         * a COOKIE ACK.&n;&t; */
multiline_comment|/* Don&squot;t accidentally move back into established state. */
r_if
c_cond
(paren
id|asoc-&gt;state
OL
id|SCTP_STATE_ESTABLISHED
)paren
(brace
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_TIMER_STOP
comma
id|SCTP_TO
c_func
(paren
id|SCTP_EVENT_TIMEOUT_T1_COOKIE
)paren
)paren
suffix:semicolon
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_NEW_STATE
comma
id|SCTP_STATE
c_func
(paren
id|SCTP_STATE_ESTABLISHED
)paren
)paren
suffix:semicolon
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_HB_TIMERS_START
comma
id|SCTP_NULL
c_func
(paren
)paren
)paren
suffix:semicolon
multiline_comment|/* RFC 2960 5.1 Normal Establishment of an Association&n;&t;&t; *&n;&t;&t; * D) IMPLEMENTATION NOTE: An implementation may choose&n;&t;&t; * to send the Communication Up notification to the&n;&t;&t; * SCTP user upon reception of a valid COOKIE&n;&t;&t; * ECHO chunk.&n;&t;&t; */
id|ev
op_assign
id|sctp_ulpevent_make_assoc_change
c_func
(paren
id|new_asoc
comma
l_int|0
comma
id|SCTP_COMM_UP
comma
l_int|0
comma
id|new_asoc-&gt;c.sinit_num_ostreams
comma
id|new_asoc-&gt;c.sinit_max_instreams
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ev
)paren
r_goto
id|nomem
suffix:semicolon
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_EVENT_ULP
comma
id|SCTP_ULPEVENT
c_func
(paren
id|ev
)paren
)paren
suffix:semicolon
)brace
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_TRANSMIT
comma
id|SCTP_NULL
c_func
(paren
)paren
)paren
suffix:semicolon
id|repl
op_assign
id|sctp_make_cookie_ack
c_func
(paren
id|new_asoc
comma
id|chunk
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|repl
)paren
r_goto
id|nomem
suffix:semicolon
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_REPLY
comma
id|SCTP_CHUNK
c_func
(paren
id|repl
)paren
)paren
suffix:semicolon
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_TRANSMIT
comma
id|SCTP_NULL
c_func
(paren
)paren
)paren
suffix:semicolon
r_return
id|SCTP_DISPOSITION_CONSUME
suffix:semicolon
id|nomem
suffix:colon
r_if
c_cond
(paren
id|ev
)paren
id|sctp_ulpevent_free
c_func
(paren
id|ev
)paren
suffix:semicolon
r_return
id|SCTP_DISPOSITION_NOMEM
suffix:semicolon
)brace
multiline_comment|/*&n; * Handle a duplicate COOKIE-ECHO.  This usually means a cookie-carrying&n; * chunk was retransmitted and then delayed in the network.&n; *&n; * Section: 5.2.4 Handle a COOKIE ECHO when a TCB exists&n; *&n; * Verification Tag: None.  Do cookie validation.&n; *&n; * Inputs&n; * (endpoint, asoc, chunk)&n; *&n; * Outputs&n; * (asoc, reply_msg, msg_up, timers, counters)&n; *&n; * The return value is the disposition of the chunk.&n; */
DECL|function|sctp_sf_do_5_2_4_dupcook
id|sctp_disposition_t
id|sctp_sf_do_5_2_4_dupcook
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
r_const
id|sctp_subtype_t
id|type
comma
r_void
op_star
id|arg
comma
id|sctp_cmd_seq_t
op_star
id|commands
)paren
(brace
id|sctp_disposition_t
id|retval
suffix:semicolon
id|sctp_chunk_t
op_star
id|chunk
op_assign
id|arg
suffix:semicolon
id|sctp_association_t
op_star
id|new_asoc
suffix:semicolon
r_int
id|error
op_assign
l_int|0
suffix:semicolon
r_char
id|action
suffix:semicolon
id|sctp_chunk_t
op_star
id|err_chk_p
suffix:semicolon
multiline_comment|/* &quot;Decode&quot; the chunk.  We have no optional parameters so we&n;&t; * are in good shape.&n;&t; */
id|chunk-&gt;subh.cookie_hdr
op_assign
(paren
id|sctp_signed_cookie_t
op_star
)paren
id|chunk-&gt;skb-&gt;data
suffix:semicolon
id|skb_pull
c_func
(paren
id|chunk-&gt;skb
comma
id|ntohs
c_func
(paren
id|chunk-&gt;chunk_hdr-&gt;length
)paren
op_minus
r_sizeof
(paren
id|sctp_chunkhdr_t
)paren
)paren
suffix:semicolon
multiline_comment|/* In RFC 2960 5.2.4 3, if both Verification Tags in the State Cookie&n;&t; * of a duplicate COOKIE ECHO match the Verification Tags of the&n;&t; * current association, consider the State Cookie valid even if&n;&t; * the lifespan is exceeded.&n;&t; */
id|new_asoc
op_assign
id|sctp_unpack_cookie
c_func
(paren
id|ep
comma
id|asoc
comma
id|chunk
comma
id|GFP_ATOMIC
comma
op_amp
id|error
comma
op_amp
id|err_chk_p
)paren
suffix:semicolon
multiline_comment|/* FIXME:&n;&t; * If the re-build failed, what is the proper error path&n;&t; * from here?&n;&t; *&n;&t; * [We should abort the association. --piggy]&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|new_asoc
)paren
(brace
multiline_comment|/* FIXME: Several errors are possible.  A bad cookie should&n;&t;&t; * be silently discarded, but think about logging it too.&n;&t;&t; */
r_switch
c_cond
(paren
id|error
)paren
(brace
r_case
op_minus
id|SCTP_IERROR_NOMEM
suffix:colon
r_goto
id|nomem
suffix:semicolon
r_case
op_minus
id|SCTP_IERROR_STALE_COOKIE
suffix:colon
id|sctp_send_stale_cookie_err
c_func
(paren
id|ep
comma
id|asoc
comma
id|chunk
comma
id|commands
comma
id|err_chk_p
)paren
suffix:semicolon
r_return
id|sctp_sf_pdiscard
c_func
(paren
id|ep
comma
id|asoc
comma
id|type
comma
id|arg
comma
id|commands
)paren
suffix:semicolon
r_case
op_minus
id|SCTP_IERROR_BAD_SIG
suffix:colon
r_default
suffix:colon
r_return
id|sctp_sf_pdiscard
c_func
(paren
id|ep
comma
id|asoc
comma
id|type
comma
id|arg
comma
id|commands
)paren
suffix:semicolon
)brace
suffix:semicolon
)brace
multiline_comment|/* Compare the tie_tag in cookie with the verification tag of&n;&t; * current association.&n;&t; */
id|action
op_assign
id|sctp_tietags_compare
c_func
(paren
id|new_asoc
comma
id|asoc
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|action
)paren
(brace
r_case
l_char|&squot;A&squot;
suffix:colon
multiline_comment|/* Association restart. */
id|retval
op_assign
id|sctp_sf_do_dupcook_a
c_func
(paren
id|ep
comma
id|asoc
comma
id|chunk
comma
id|commands
comma
id|new_asoc
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;B&squot;
suffix:colon
multiline_comment|/* Collision case B. */
id|retval
op_assign
id|sctp_sf_do_dupcook_b
c_func
(paren
id|ep
comma
id|asoc
comma
id|chunk
comma
id|commands
comma
id|new_asoc
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;C&squot;
suffix:colon
multiline_comment|/* Collision case C. */
id|retval
op_assign
id|sctp_sf_do_dupcook_c
c_func
(paren
id|ep
comma
id|asoc
comma
id|chunk
comma
id|commands
comma
id|new_asoc
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;D&squot;
suffix:colon
multiline_comment|/* Collision case D. */
id|retval
op_assign
id|sctp_sf_do_dupcook_d
c_func
(paren
id|ep
comma
id|asoc
comma
id|chunk
comma
id|commands
comma
id|new_asoc
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* Discard packet for all others. */
id|retval
op_assign
id|sctp_sf_pdiscard
c_func
(paren
id|ep
comma
id|asoc
comma
id|type
comma
id|arg
comma
id|commands
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* Delete the tempory new association. */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_NEW_ASOC
comma
id|SCTP_ASOC
c_func
(paren
id|new_asoc
)paren
)paren
suffix:semicolon
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_DELETE_TCB
comma
id|SCTP_NULL
c_func
(paren
)paren
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
id|nomem
suffix:colon
r_return
id|SCTP_DISPOSITION_NOMEM
suffix:semicolon
)brace
multiline_comment|/*&n; * Process an ABORT.  (SHUTDOWN-PENDING state)&n; *&n; * See sctp_sf_do_9_1_abort().&n; */
DECL|function|sctp_sf_shutdown_pending_abort
id|sctp_disposition_t
id|sctp_sf_shutdown_pending_abort
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
r_const
id|sctp_subtype_t
id|type
comma
r_void
op_star
id|arg
comma
id|sctp_cmd_seq_t
op_star
id|commands
)paren
(brace
id|sctp_chunk_t
op_star
id|chunk
op_assign
id|arg
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sctp_vtag_verify_either
c_func
(paren
id|chunk
comma
id|asoc
)paren
)paren
r_return
id|sctp_sf_pdiscard
c_func
(paren
id|ep
comma
id|asoc
comma
id|type
comma
id|arg
comma
id|commands
)paren
suffix:semicolon
multiline_comment|/* Stop the T5-shutdown guard timer.  */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_TIMER_STOP
comma
id|SCTP_TO
c_func
(paren
id|SCTP_EVENT_TIMEOUT_T5_SHUTDOWN_GUARD
)paren
)paren
suffix:semicolon
r_return
id|sctp_sf_do_9_1_abort
c_func
(paren
id|ep
comma
id|asoc
comma
id|type
comma
id|arg
comma
id|commands
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Process an ABORT.  (SHUTDOWN-SENT state)&n; *&n; * See sctp_sf_do_9_1_abort().&n; */
DECL|function|sctp_sf_shutdown_sent_abort
id|sctp_disposition_t
id|sctp_sf_shutdown_sent_abort
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
r_const
id|sctp_subtype_t
id|type
comma
r_void
op_star
id|arg
comma
id|sctp_cmd_seq_t
op_star
id|commands
)paren
(brace
id|sctp_chunk_t
op_star
id|chunk
op_assign
id|arg
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sctp_vtag_verify_either
c_func
(paren
id|chunk
comma
id|asoc
)paren
)paren
r_return
id|sctp_sf_pdiscard
c_func
(paren
id|ep
comma
id|asoc
comma
id|type
comma
id|arg
comma
id|commands
)paren
suffix:semicolon
multiline_comment|/* Stop the T2-shutdown timer. */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_TIMER_STOP
comma
id|SCTP_TO
c_func
(paren
id|SCTP_EVENT_TIMEOUT_T2_SHUTDOWN
)paren
)paren
suffix:semicolon
multiline_comment|/* Stop the T5-shutdown guard timer.  */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_TIMER_STOP
comma
id|SCTP_TO
c_func
(paren
id|SCTP_EVENT_TIMEOUT_T5_SHUTDOWN_GUARD
)paren
)paren
suffix:semicolon
r_return
id|sctp_sf_do_9_1_abort
c_func
(paren
id|ep
comma
id|asoc
comma
id|type
comma
id|arg
comma
id|commands
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Process an ABORT.  (SHUTDOWN-ACK-SENT state)&n; *&n; * See sctp_sf_do_9_1_abort().&n; */
DECL|function|sctp_sf_shutdown_ack_sent_abort
id|sctp_disposition_t
id|sctp_sf_shutdown_ack_sent_abort
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
r_const
id|sctp_subtype_t
id|type
comma
r_void
op_star
id|arg
comma
id|sctp_cmd_seq_t
op_star
id|commands
)paren
(brace
multiline_comment|/* The same T2 timer, so we should be able to use&n;&t; * common function with the SHUTDOWN-SENT state.&n;&t; */
r_return
id|sctp_sf_shutdown_sent_abort
c_func
(paren
id|ep
comma
id|asoc
comma
id|type
comma
id|arg
comma
id|commands
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Handle an Error received in COOKIE_ECHOED state.&n; *&n; * Only handle the error type of stale COOKIE Error, the other errors will&n; * be ignored.&n; *&n; * Inputs&n; * (endpoint, asoc, chunk)&n; *&n; * Outputs&n; * (asoc, reply_msg, msg_up, timers, counters)&n; *&n; * The return value is the disposition of the chunk.&n; */
DECL|function|sctp_sf_cookie_echoed_err
id|sctp_disposition_t
id|sctp_sf_cookie_echoed_err
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
r_const
id|sctp_subtype_t
id|type
comma
r_void
op_star
id|arg
comma
id|sctp_cmd_seq_t
op_star
id|commands
)paren
(brace
id|sctp_chunk_t
op_star
id|chunk
op_assign
id|arg
suffix:semicolon
id|sctp_errhdr_t
op_star
id|err
suffix:semicolon
multiline_comment|/* If we have gotten too many failures, give up.  */
r_if
c_cond
(paren
l_int|1
op_plus
id|asoc-&gt;counters
(braket
id|SCTP_COUNTER_INIT_ERROR
)braket
OG
id|asoc-&gt;max_init_attempts
)paren
(brace
multiline_comment|/* INIT_FAILED will issue an ulpevent.  */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_INIT_FAILED
comma
id|SCTP_NULL
c_func
(paren
)paren
)paren
suffix:semicolon
r_return
id|SCTP_DISPOSITION_DELETE_TCB
suffix:semicolon
)brace
id|err
op_assign
(paren
id|sctp_errhdr_t
op_star
)paren
(paren
id|chunk-&gt;skb-&gt;data
)paren
suffix:semicolon
multiline_comment|/* Process the error here */
r_switch
c_cond
(paren
id|err-&gt;cause
)paren
(brace
r_case
id|SCTP_ERROR_STALE_COOKIE
suffix:colon
r_return
id|sctp_sf_do_5_2_6_stale
c_func
(paren
id|ep
comma
id|asoc
comma
id|type
comma
id|arg
comma
id|commands
)paren
suffix:semicolon
r_default
suffix:colon
r_return
id|sctp_sf_pdiscard
c_func
(paren
id|ep
comma
id|asoc
comma
id|type
comma
id|arg
comma
id|commands
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Handle a Stale COOKIE Error&n; *&n; * Section: 5.2.6 Handle Stale COOKIE Error&n; * If the association is in the COOKIE-ECHOED state, the endpoint may elect&n; * one of the following three alternatives.&n; * ...&n; * 3) Send a new INIT chunk to the endpoint, adding a Cookie&n; *    Preservative parameter requesting an extension to the lifetime of&n; *    the State Cookie. When calculating the time extension, an&n; *    implementation SHOULD use the RTT information measured based on the&n; *    previous COOKIE ECHO / ERROR exchange, and should add no more&n; *    than 1 second beyond the measured RTT, due to long State Cookie&n; *    lifetimes making the endpoint more subject to a replay attack.&n; *&n; * Verification Tag:  Not explicit, but safe to ignore.&n; *&n; * Inputs&n; * (endpoint, asoc, chunk)&n; *&n; * Outputs&n; * (asoc, reply_msg, msg_up, timers, counters)&n; *&n; * The return value is the disposition of the chunk.&n; */
DECL|function|sctp_sf_do_5_2_6_stale
id|sctp_disposition_t
id|sctp_sf_do_5_2_6_stale
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
r_const
id|sctp_subtype_t
id|type
comma
r_void
op_star
id|arg
comma
id|sctp_cmd_seq_t
op_star
id|commands
)paren
(brace
id|sctp_chunk_t
op_star
id|chunk
op_assign
id|arg
suffix:semicolon
id|time_t
id|stale
suffix:semicolon
id|sctp_cookie_preserve_param_t
id|bht
suffix:semicolon
id|sctp_errhdr_t
op_star
id|err
suffix:semicolon
r_struct
id|list_head
op_star
id|pos
suffix:semicolon
r_struct
id|sctp_transport
op_star
id|t
suffix:semicolon
id|sctp_chunk_t
op_star
id|reply
suffix:semicolon
id|sctp_bind_addr_t
op_star
id|bp
suffix:semicolon
r_int
id|attempts
suffix:semicolon
id|attempts
op_assign
id|asoc-&gt;counters
(braket
id|SCTP_COUNTER_INIT_ERROR
)braket
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|attempts
op_ge
id|asoc-&gt;max_init_attempts
)paren
(brace
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_INIT_FAILED
comma
id|SCTP_NULL
c_func
(paren
)paren
)paren
suffix:semicolon
r_return
id|SCTP_DISPOSITION_DELETE_TCB
suffix:semicolon
)brace
id|err
op_assign
(paren
id|sctp_errhdr_t
op_star
)paren
(paren
id|chunk-&gt;skb-&gt;data
)paren
suffix:semicolon
multiline_comment|/* When calculating the time extension, an implementation&n;&t; * SHOULD use the RTT information measured based on the&n;&t; * previous COOKIE ECHO / ERROR exchange, and should add no&n;&t; * more than 1 second beyond the measured RTT, due to long&n;&t; * State Cookie lifetimes making the endpoint more subject to&n;&t; * a replay attack.&n;&t; * Measure of Staleness&squot;s unit is usec. (1/1000000 sec)&n;&t; * Suggested Cookie Life-span Increment&squot;s unit is msec.&n;&t; * (1/1000 sec)&n;&t; * In general, if you use the suggested cookie life, the value&n;&t; * found in the field of measure of staleness should be doubled&n;&t; * to give ample time to retransmit the new cookie and thus&n;&t; * yield a higher probability of success on the reattempt.&n;&t; */
id|stale
op_assign
id|ntohl
c_func
(paren
op_star
(paren
id|suseconds_t
op_star
)paren
(paren
(paren
id|u8
op_star
)paren
id|err
op_plus
r_sizeof
(paren
id|sctp_errhdr_t
)paren
)paren
)paren
suffix:semicolon
id|stale
op_assign
id|stale
op_lshift
l_int|1
op_div
l_int|1000
suffix:semicolon
id|bht.param_hdr.type
op_assign
id|SCTP_PARAM_COOKIE_PRESERVATIVE
suffix:semicolon
id|bht.param_hdr.length
op_assign
id|htons
c_func
(paren
r_sizeof
(paren
id|bht
)paren
)paren
suffix:semicolon
id|bht.lifespan_increment
op_assign
id|htonl
c_func
(paren
id|stale
)paren
suffix:semicolon
multiline_comment|/* Build that new INIT chunk.  */
id|bp
op_assign
(paren
id|sctp_bind_addr_t
op_star
)paren
op_amp
id|asoc-&gt;base.bind_addr
suffix:semicolon
id|reply
op_assign
id|sctp_make_init
c_func
(paren
id|asoc
comma
id|bp
comma
id|GFP_ATOMIC
comma
r_sizeof
(paren
id|bht
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|reply
)paren
r_goto
id|nomem
suffix:semicolon
id|sctp_addto_chunk
c_func
(paren
id|reply
comma
r_sizeof
(paren
id|bht
)paren
comma
op_amp
id|bht
)paren
suffix:semicolon
multiline_comment|/* Cast away the const modifier, as we want to just&n;&t; * rerun it through as a sideffect.&n;&t; */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_COUNTER_INC
comma
id|SCTP_COUNTER
c_func
(paren
id|SCTP_COUNTER_INIT_ERROR
)paren
)paren
suffix:semicolon
multiline_comment|/* If we&squot;ve sent any data bundled with COOKIE-ECHO we need to&n;&t; * resend.&n;&t; */
id|list_for_each
c_func
(paren
id|pos
comma
op_amp
id|asoc-&gt;peer.transport_addr_list
)paren
(brace
id|t
op_assign
id|list_entry
c_func
(paren
id|pos
comma
r_struct
id|sctp_transport
comma
id|transports
)paren
suffix:semicolon
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_RETRAN
comma
id|SCTP_TRANSPORT
c_func
(paren
id|t
)paren
)paren
suffix:semicolon
)brace
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_TIMER_STOP
comma
id|SCTP_TO
c_func
(paren
id|SCTP_EVENT_TIMEOUT_T1_COOKIE
)paren
)paren
suffix:semicolon
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_NEW_STATE
comma
id|SCTP_STATE
c_func
(paren
id|SCTP_STATE_COOKIE_WAIT
)paren
)paren
suffix:semicolon
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_TIMER_START
comma
id|SCTP_TO
c_func
(paren
id|SCTP_EVENT_TIMEOUT_T1_INIT
)paren
)paren
suffix:semicolon
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_REPLY
comma
id|SCTP_CHUNK
c_func
(paren
id|reply
)paren
)paren
suffix:semicolon
r_return
id|SCTP_DISPOSITION_CONSUME
suffix:semicolon
id|nomem
suffix:colon
r_return
id|SCTP_DISPOSITION_NOMEM
suffix:semicolon
)brace
multiline_comment|/*&n; * Process an ABORT.&n; *&n; * Section: 9.1&n; * After checking the Verification Tag, the receiving endpoint shall&n; * remove the association from its record, and shall report the&n; * termination to its upper layer.&n; *&n; * Verification Tag: 8.5.1 Exceptions in Verification Tag Rules&n; * B) Rules for packet carrying ABORT:&n; *&n; *  - The endpoint shall always fill in the Verification Tag field of the&n; *    outbound packet with the destination endpoint&squot;s tag value if it&n; *    is known.&n; *&n; *  - If the ABORT is sent in response to an OOTB packet, the endpoint&n; *    MUST follow the procedure described in Section 8.4.&n; *&n; *  - The receiver MUST accept the packet if the Verification Tag&n; *    matches either its own tag, OR the tag of its peer. Otherwise, the&n; *    receiver MUST silently discard the packet and take no further&n; *    action.&n; *&n; * Inputs&n; * (endpoint, asoc, chunk)&n; *&n; * Outputs&n; * (asoc, reply_msg, msg_up, timers, counters)&n; *&n; * The return value is the disposition of the chunk.&n; */
DECL|function|sctp_sf_do_9_1_abort
id|sctp_disposition_t
id|sctp_sf_do_9_1_abort
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
r_const
id|sctp_subtype_t
id|type
comma
r_void
op_star
id|arg
comma
id|sctp_cmd_seq_t
op_star
id|commands
)paren
(brace
id|sctp_chunk_t
op_star
id|chunk
op_assign
id|arg
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sctp_vtag_verify_either
c_func
(paren
id|chunk
comma
id|asoc
)paren
)paren
r_return
id|sctp_sf_pdiscard
c_func
(paren
id|ep
comma
id|asoc
comma
id|type
comma
id|arg
comma
id|commands
)paren
suffix:semicolon
multiline_comment|/* ASSOC_FAILED will DELETE_TCB. */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_ASSOC_FAILED
comma
id|SCTP_NULL
c_func
(paren
)paren
)paren
suffix:semicolon
multiline_comment|/* BUG?  This does not look complete... */
r_return
id|SCTP_DISPOSITION_ABORT
suffix:semicolon
)brace
multiline_comment|/*&n; * Process an ABORT.  (COOKIE-WAIT state)&n; *&n; * See sctp_sf_do_9_1_abort() above.&n; */
DECL|function|sctp_sf_cookie_wait_abort
id|sctp_disposition_t
id|sctp_sf_cookie_wait_abort
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
r_const
id|sctp_subtype_t
id|type
comma
r_void
op_star
id|arg
comma
id|sctp_cmd_seq_t
op_star
id|commands
)paren
(brace
id|sctp_chunk_t
op_star
id|chunk
op_assign
id|arg
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sctp_vtag_verify_either
c_func
(paren
id|chunk
comma
id|asoc
)paren
)paren
r_return
id|sctp_sf_pdiscard
c_func
(paren
id|ep
comma
id|asoc
comma
id|type
comma
id|arg
comma
id|commands
)paren
suffix:semicolon
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_NEW_STATE
comma
id|SCTP_STATE
c_func
(paren
id|SCTP_STATE_CLOSED
)paren
)paren
suffix:semicolon
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_TIMER_STOP
comma
id|SCTP_TO
c_func
(paren
id|SCTP_EVENT_TIMEOUT_T1_INIT
)paren
)paren
suffix:semicolon
multiline_comment|/* CMD_INIT_FAILED will DELETE_TCB. */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_INIT_FAILED
comma
id|SCTP_NULL
c_func
(paren
)paren
)paren
suffix:semicolon
multiline_comment|/* BUG?  This does not look complete... */
r_return
id|SCTP_DISPOSITION_ABORT
suffix:semicolon
)brace
multiline_comment|/*&n; * Process an ABORT.  (COOKIE-ECHOED state)&n; *&n; * See sctp_sf_do_9_1_abort() above.&n; */
DECL|function|sctp_sf_cookie_echoed_abort
id|sctp_disposition_t
id|sctp_sf_cookie_echoed_abort
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
r_const
id|sctp_subtype_t
id|type
comma
r_void
op_star
id|arg
comma
id|sctp_cmd_seq_t
op_star
id|commands
)paren
(brace
multiline_comment|/* There is a single T1 timer, so we should be able to use&n;&t; * common function with the COOKIE-WAIT state.&n;&t; */
r_return
id|sctp_sf_cookie_wait_abort
c_func
(paren
id|ep
comma
id|asoc
comma
id|type
comma
id|arg
comma
id|commands
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * sctp_sf_do_9_2_shut&n; *&n; * Section: 9.2&n; * Upon the reception of the SHUTDOWN, the peer endpoint shall&n; *  - enter the SHUTDOWN-RECEIVED state,&n; *&n; *  - stop accepting new data from its SCTP user&n; *&n; *  - verify, by checking the Cumulative TSN Ack field of the chunk,&n; *    that all its outstanding DATA chunks have been received by the&n; *    SHUTDOWN sender.&n; *&n; * Once an endpoint as reached the SHUTDOWN-RECEIVED state it MUST NOT&n; * send a SHUTDOWN in response to a ULP request. And should discard&n; * subsequent SHUTDOWN chunks.&n; *&n; * If there are still outstanding DATA chunks left, the SHUTDOWN&n; * receiver shall continue to follow normal data transmission&n; * procedures defined in Section 6 until all outstanding DATA chunks&n; * are acknowledged; however, the SHUTDOWN receiver MUST NOT accept&n; * new data from its SCTP user.&n; *&n; * Verification Tag:  8.5 Verification Tag [Normal verification]&n; *&n; * Inputs&n; * (endpoint, asoc, chunk)&n; *&n; * Outputs&n; * (asoc, reply_msg, msg_up, timers, counters)&n; *&n; * The return value is the disposition of the chunk.&n; */
DECL|function|sctp_sf_do_9_2_shutdown
id|sctp_disposition_t
id|sctp_sf_do_9_2_shutdown
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
r_const
id|sctp_subtype_t
id|type
comma
r_void
op_star
id|arg
comma
id|sctp_cmd_seq_t
op_star
id|commands
)paren
(brace
id|sctp_chunk_t
op_star
id|chunk
op_assign
id|arg
suffix:semicolon
id|sctp_shutdownhdr_t
op_star
id|sdh
suffix:semicolon
id|sctp_disposition_t
id|disposition
suffix:semicolon
multiline_comment|/* Convert the elaborate header.  */
id|sdh
op_assign
(paren
id|sctp_shutdownhdr_t
op_star
)paren
id|chunk-&gt;skb-&gt;data
suffix:semicolon
id|skb_pull
c_func
(paren
id|chunk-&gt;skb
comma
r_sizeof
(paren
id|sctp_shutdownhdr_t
)paren
)paren
suffix:semicolon
id|chunk-&gt;subh.shutdown_hdr
op_assign
id|sdh
suffix:semicolon
multiline_comment|/* 8.5 When receiving an SCTP packet, the endpoint MUST ensure&n;&t; * that the value in the Verification Tag field of the&n;&t; * received SCTP packet matches its own Tag. If the received&n;&t; * Verification Tag value does not match the receiver&squot;s own&n;&t; * tag value, the receiver shall silently discard the packet...&n;&t; */
r_if
c_cond
(paren
id|ntohl
c_func
(paren
id|chunk-&gt;sctp_hdr-&gt;vtag
)paren
op_ne
id|asoc-&gt;c.my_vtag
)paren
r_return
id|sctp_sf_pdiscard
c_func
(paren
id|ep
comma
id|asoc
comma
id|type
comma
id|arg
comma
id|commands
)paren
suffix:semicolon
multiline_comment|/* Upon the reception of the SHUTDOWN, the peer endpoint shall&n;&t; *  - enter the SHUTDOWN-RECEIVED state,&n;&t; *  - stop accepting new data from its SCTP user&n;&t; *&n;&t; * [This is implicit in the new state.]&n;&t; */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_NEW_STATE
comma
id|SCTP_STATE
c_func
(paren
id|SCTP_STATE_SHUTDOWN_RECEIVED
)paren
)paren
suffix:semicolon
id|disposition
op_assign
id|SCTP_DISPOSITION_CONSUME
suffix:semicolon
r_if
c_cond
(paren
id|sctp_outq_is_empty
c_func
(paren
op_amp
id|asoc-&gt;outqueue
)paren
)paren
(brace
id|disposition
op_assign
id|sctp_sf_do_9_2_shutdown_ack
c_func
(paren
id|ep
comma
id|asoc
comma
id|type
comma
id|arg
comma
id|commands
)paren
suffix:semicolon
)brace
multiline_comment|/*  - verify, by checking the Cumulative TSN Ack field of the&n;&t; *    chunk, that all its outstanding DATA chunks have been&n;&t; *    received by the SHUTDOWN sender.&n;&t; */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_PROCESS_CTSN
comma
id|SCTP_U32
c_func
(paren
id|chunk-&gt;subh.shutdown_hdr-&gt;cum_tsn_ack
)paren
)paren
suffix:semicolon
r_return
id|disposition
suffix:semicolon
)brace
multiline_comment|/* RFC 2960 9.2&n; * If an endpoint is in SHUTDOWN-ACK-SENT state and receives an INIT chunk&n; * (e.g., if the SHUTDOWN COMPLETE was lost) with source and destination&n; * transport addresses (either in the IP addresses or in the INIT chunk)&n; * that belong to this association, it should discard the INIT chunk and&n; * retransmit the SHUTDOWN ACK chunk.&n; */
DECL|function|sctp_sf_do_9_2_reshutack
id|sctp_disposition_t
id|sctp_sf_do_9_2_reshutack
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
r_const
id|sctp_subtype_t
id|type
comma
r_void
op_star
id|arg
comma
id|sctp_cmd_seq_t
op_star
id|commands
)paren
(brace
id|sctp_chunk_t
op_star
id|chunk
op_assign
(paren
id|sctp_chunk_t
op_star
)paren
id|arg
suffix:semicolon
id|sctp_chunk_t
op_star
id|reply
suffix:semicolon
id|reply
op_assign
id|sctp_make_shutdown_ack
c_func
(paren
id|asoc
comma
id|chunk
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|NULL
op_eq
id|reply
)paren
r_goto
id|nomem
suffix:semicolon
multiline_comment|/* Set the transport for the SHUTDOWN ACK chunk and the timeout for&n;&t; * the T2-SHUTDOWN timer.&n;&t; */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_SETUP_T2
comma
id|SCTP_CHUNK
c_func
(paren
id|reply
)paren
)paren
suffix:semicolon
multiline_comment|/* and restart the T2-shutdown timer. */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_TIMER_RESTART
comma
id|SCTP_TO
c_func
(paren
id|SCTP_EVENT_TIMEOUT_T2_SHUTDOWN
)paren
)paren
suffix:semicolon
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_REPLY
comma
id|SCTP_CHUNK
c_func
(paren
id|reply
)paren
)paren
suffix:semicolon
r_return
id|SCTP_DISPOSITION_CONSUME
suffix:semicolon
id|nomem
suffix:colon
r_return
id|SCTP_DISPOSITION_NOMEM
suffix:semicolon
)brace
multiline_comment|/*&n; * sctp_sf_do_ecn_cwr&n; *&n; * Section:  Appendix A: Explicit Congestion Notification&n; *&n; * CWR:&n; *&n; * RFC 2481 details a specific bit for a sender to send in the header of&n; * its next outbound TCP segment to indicate to its peer that it has&n; * reduced its congestion window.  This is termed the CWR bit.  For&n; * SCTP the same indication is made by including the CWR chunk.&n; * This chunk contains one data element, i.e. the TSN number that&n; * was sent in the ECNE chunk.  This element represents the lowest&n; * TSN number in the datagram that was originally marked with the&n; * CE bit.&n; *&n; * Verification Tag: 8.5 Verification Tag [Normal verification]&n; * Inputs&n; * (endpoint, asoc, chunk)&n; *&n; * Outputs&n; * (asoc, reply_msg, msg_up, timers, counters)&n; *&n; * The return value is the disposition of the chunk.&n; */
DECL|function|sctp_sf_do_ecn_cwr
id|sctp_disposition_t
id|sctp_sf_do_ecn_cwr
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
r_const
id|sctp_subtype_t
id|type
comma
r_void
op_star
id|arg
comma
id|sctp_cmd_seq_t
op_star
id|commands
)paren
(brace
id|sctp_cwrhdr_t
op_star
id|cwr
suffix:semicolon
id|sctp_chunk_t
op_star
id|chunk
op_assign
id|arg
suffix:semicolon
multiline_comment|/* 8.5 When receiving an SCTP packet, the endpoint MUST ensure&n;&t; * that the value in the Verification Tag field of the&n;&t; * received SCTP packet matches its own Tag. If the received&n;&t; * Verification Tag value does not match the receiver&squot;s own&n;&t; * tag value, the receiver shall silently discard the packet...&n;&t; */
r_if
c_cond
(paren
id|ntohl
c_func
(paren
id|chunk-&gt;sctp_hdr-&gt;vtag
)paren
op_ne
id|asoc-&gt;c.my_vtag
)paren
r_return
id|sctp_sf_pdiscard
c_func
(paren
id|ep
comma
id|asoc
comma
id|type
comma
id|arg
comma
id|commands
)paren
suffix:semicolon
id|cwr
op_assign
(paren
id|sctp_cwrhdr_t
op_star
)paren
id|chunk-&gt;skb-&gt;data
suffix:semicolon
id|skb_pull
c_func
(paren
id|chunk-&gt;skb
comma
r_sizeof
(paren
id|sctp_cwrhdr_t
)paren
)paren
suffix:semicolon
id|cwr-&gt;lowest_tsn
op_assign
id|ntohl
c_func
(paren
id|cwr-&gt;lowest_tsn
)paren
suffix:semicolon
multiline_comment|/* Does this CWR ack the last sent congestion notification? */
r_if
c_cond
(paren
id|TSN_lte
c_func
(paren
id|asoc-&gt;last_ecne_tsn
comma
id|cwr-&gt;lowest_tsn
)paren
)paren
(brace
multiline_comment|/* Stop sending ECNE. */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_ECN_CWR
comma
id|SCTP_U32
c_func
(paren
id|cwr-&gt;lowest_tsn
)paren
)paren
suffix:semicolon
)brace
r_return
id|SCTP_DISPOSITION_CONSUME
suffix:semicolon
)brace
multiline_comment|/*&n; * sctp_sf_do_ecne&n; *&n; * Section:  Appendix A: Explicit Congestion Notification&n; *&n; * ECN-Echo&n; *&n; * RFC 2481 details a specific bit for a receiver to send back in its&n; * TCP acknowledgements to notify the sender of the Congestion&n; * Experienced (CE) bit having arrived from the network.  For SCTP this&n; * same indication is made by including the ECNE chunk.  This chunk&n; * contains one data element, i.e. the lowest TSN associated with the IP&n; * datagram marked with the CE bit.....&n; *&n; * Verification Tag: 8.5 Verification Tag [Normal verification]&n; * Inputs&n; * (endpoint, asoc, chunk)&n; *&n; * Outputs&n; * (asoc, reply_msg, msg_up, timers, counters)&n; *&n; * The return value is the disposition of the chunk.&n; */
DECL|function|sctp_sf_do_ecne
id|sctp_disposition_t
id|sctp_sf_do_ecne
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
r_const
id|sctp_subtype_t
id|type
comma
r_void
op_star
id|arg
comma
id|sctp_cmd_seq_t
op_star
id|commands
)paren
(brace
id|sctp_ecnehdr_t
op_star
id|ecne
suffix:semicolon
id|sctp_chunk_t
op_star
id|chunk
op_assign
id|arg
suffix:semicolon
multiline_comment|/* 8.5 When receiving an SCTP packet, the endpoint MUST ensure&n;&t; * that the value in the Verification Tag field of the&n;&t; * received SCTP packet matches its own Tag. If the received&n;&t; * Verification Tag value does not match the receiver&squot;s own&n;&t; * tag value, the receiver shall silently discard the packet...&n;&t; */
r_if
c_cond
(paren
id|ntohl
c_func
(paren
id|chunk-&gt;sctp_hdr-&gt;vtag
)paren
op_ne
id|asoc-&gt;c.my_vtag
)paren
r_return
id|sctp_sf_pdiscard
c_func
(paren
id|ep
comma
id|asoc
comma
id|type
comma
id|arg
comma
id|commands
)paren
suffix:semicolon
id|ecne
op_assign
(paren
id|sctp_ecnehdr_t
op_star
)paren
id|chunk-&gt;skb-&gt;data
suffix:semicolon
id|skb_pull
c_func
(paren
id|chunk-&gt;skb
comma
r_sizeof
(paren
id|sctp_ecnehdr_t
)paren
)paren
suffix:semicolon
multiline_comment|/* If this is a newer ECNE than the last CWR packet we sent out */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_ECN_ECNE
comma
id|SCTP_U32
c_func
(paren
id|ntohl
c_func
(paren
id|ecne-&gt;lowest_tsn
)paren
)paren
)paren
suffix:semicolon
r_return
id|SCTP_DISPOSITION_CONSUME
suffix:semicolon
)brace
multiline_comment|/*&n; * Section: 6.2  Acknowledgement on Reception of DATA Chunks&n; *&n; * The SCTP endpoint MUST always acknowledge the reception of each valid&n; * DATA chunk.&n; *&n; * The guidelines on delayed acknowledgement algorithm specified in&n; * Section 4.2 of [RFC2581] SHOULD be followed. Specifically, an&n; * acknowledgement SHOULD be generated for at least every second packet&n; * (not every second DATA chunk) received, and SHOULD be generated within&n; * 200 ms of the arrival of any unacknowledged DATA chunk. In some&n; * situations it may be beneficial for an SCTP transmitter to be more&n; * conservative than the algorithms detailed in this document allow.&n; * However, an SCTP transmitter MUST NOT be more aggressive than the&n; * following algorithms allow.&n; *&n; * A SCTP receiver MUST NOT generate more than one SACK for every&n; * incoming packet, other than to update the offered window as the&n; * receiving application consumes new data.&n; *&n; * Verification Tag:  8.5 Verification Tag [Normal verification]&n; *&n; * Inputs&n; * (endpoint, asoc, chunk)&n; *&n; * Outputs&n; * (asoc, reply_msg, msg_up, timers, counters)&n; *&n; * The return value is the disposition of the chunk.&n; */
DECL|function|sctp_sf_eat_data_6_2
id|sctp_disposition_t
id|sctp_sf_eat_data_6_2
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
r_const
id|sctp_subtype_t
id|type
comma
r_void
op_star
id|arg
comma
id|sctp_cmd_seq_t
op_star
id|commands
)paren
(brace
id|sctp_chunk_t
op_star
id|chunk
op_assign
id|arg
suffix:semicolon
id|sctp_datahdr_t
op_star
id|data_hdr
suffix:semicolon
id|sctp_chunk_t
op_star
id|err
suffix:semicolon
r_int
id|datalen
suffix:semicolon
id|sctp_verb_t
id|deliver
suffix:semicolon
r_int
id|tmp
suffix:semicolon
id|__u32
id|tsn
suffix:semicolon
multiline_comment|/* RFC 2960 8.5 Verification Tag&n;&t; *&n;&t; * When receiving an SCTP packet, the endpoint MUST ensure&n;&t; * that the value in the Verification Tag field of the&n;&t; * received SCTP packet matches its own Tag.&n;&t; */
r_if
c_cond
(paren
id|ntohl
c_func
(paren
id|chunk-&gt;sctp_hdr-&gt;vtag
)paren
op_ne
id|asoc-&gt;c.my_vtag
)paren
(brace
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_REPORT_BAD_TAG
comma
id|SCTP_NULL
c_func
(paren
)paren
)paren
suffix:semicolon
r_return
id|sctp_sf_pdiscard
c_func
(paren
id|ep
comma
id|asoc
comma
id|type
comma
id|arg
comma
id|commands
)paren
suffix:semicolon
)brace
id|data_hdr
op_assign
id|chunk-&gt;subh.data_hdr
op_assign
(paren
id|sctp_datahdr_t
op_star
)paren
id|chunk-&gt;skb-&gt;data
suffix:semicolon
id|skb_pull
c_func
(paren
id|chunk-&gt;skb
comma
r_sizeof
(paren
id|sctp_datahdr_t
)paren
)paren
suffix:semicolon
id|tsn
op_assign
id|ntohl
c_func
(paren
id|data_hdr-&gt;tsn
)paren
suffix:semicolon
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;eat_data: TSN 0x%x.&bslash;n&quot;
comma
id|tsn
)paren
suffix:semicolon
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;eat_data: skb-&gt;head %p.&bslash;n&quot;
comma
id|chunk-&gt;skb-&gt;head
)paren
suffix:semicolon
multiline_comment|/* ASSERT:  Now skb-&gt;data is really the user data.  */
multiline_comment|/* Process ECN based congestion.&n;&t; *&n;&t; * Since the chunk structure is reused for all chunks within&n;&t; * a packet, we use ecn_ce_done to track if we&squot;ve already&n;&t; * done CE processing for this packet.&n;&t; *&n;&t; * We need to do ECN processing even if we plan to discard the&n;&t; * chunk later.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|chunk-&gt;ecn_ce_done
)paren
(brace
id|chunk-&gt;ecn_ce_done
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|INET_ECN_is_ce
c_func
(paren
id|chunk-&gt;skb-&gt;nh.iph-&gt;tos
)paren
op_logical_and
id|asoc-&gt;peer.ecn_capable
)paren
(brace
multiline_comment|/* Do real work as sideffect. */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_ECN_CE
comma
id|SCTP_U32
c_func
(paren
id|tsn
)paren
)paren
suffix:semicolon
)brace
)brace
id|tmp
op_assign
id|sctp_tsnmap_check
c_func
(paren
op_amp
id|asoc-&gt;peer.tsn_map
comma
id|tsn
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
OL
l_int|0
)paren
(brace
multiline_comment|/* The TSN is too high--silently discard the chunk and&n;&t;&t; * count on it getting retransmitted later.&n;&t;&t; */
r_goto
id|discard_noforce
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|tmp
OG
l_int|0
)paren
(brace
multiline_comment|/* This is a duplicate.  Record it.  */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_REPORT_DUP
comma
id|SCTP_U32
c_func
(paren
id|tsn
)paren
)paren
suffix:semicolon
r_goto
id|discard_force
suffix:semicolon
)brace
multiline_comment|/* This is a new TSN.  */
multiline_comment|/* Discard if there is no room in the receive window.&n;&t; * Actually, allow a little bit of overflow (up to a MTU).&n;&t; */
id|datalen
op_assign
id|ntohs
c_func
(paren
id|chunk-&gt;chunk_hdr-&gt;length
)paren
suffix:semicolon
id|datalen
op_sub_assign
r_sizeof
(paren
id|sctp_data_chunk_t
)paren
suffix:semicolon
id|deliver
op_assign
id|SCTP_CMD_CHUNK_ULP
suffix:semicolon
multiline_comment|/* Think about partial delivery. */
r_if
c_cond
(paren
(paren
id|datalen
op_ge
id|asoc-&gt;rwnd
)paren
op_logical_and
(paren
op_logical_neg
id|asoc-&gt;ulpq.pd_mode
)paren
)paren
(brace
multiline_comment|/* Even if we don&squot;t accept this chunk there is&n;&t;&t; * memory pressure.&n;&t;&t; */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_CHUNK_PD
comma
id|SCTP_NULL
c_func
(paren
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|asoc-&gt;rwnd_over
op_logical_or
(paren
id|datalen
OG
id|asoc-&gt;rwnd
op_plus
id|asoc-&gt;frag_point
)paren
)paren
(brace
multiline_comment|/* There is absolutely no room, but this is the most&n;&t;&t; * important tsn that we are waiting on, try to &n;&t;&t; * to partial deliver or renege to make room. &n;&t;&t; */
r_if
c_cond
(paren
(paren
id|sctp_tsnmap_get_ctsn
c_func
(paren
op_amp
id|asoc-&gt;peer.tsn_map
)paren
op_plus
l_int|1
)paren
op_eq
id|tsn
)paren
(brace
id|deliver
op_assign
id|SCTP_CMD_CHUNK_PD
suffix:semicolon
)brace
r_else
(brace
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;Discard tsn: %u len: %Zd, &quot;
l_string|&quot;rwnd: %d&bslash;n&quot;
comma
id|tsn
comma
id|datalen
comma
id|asoc-&gt;rwnd
)paren
suffix:semicolon
r_goto
id|discard_force
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Section 3.3.10.9 No User Data (9)&n;&t; *&n;&t; * Cause of error&n;&t; * ---------------&n;&t; * No User Data:  This error cause is returned to the originator of a&n;&t; * DATA chunk if a received DATA chunk has no user data.&n;&t; */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
l_int|0
op_eq
id|datalen
)paren
)paren
(brace
id|err
op_assign
id|sctp_make_abort_no_data
c_func
(paren
id|asoc
comma
id|chunk
comma
id|tsn
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_REPLY
comma
id|SCTP_CHUNK
c_func
(paren
id|err
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* We are going to ABORT, so we might as well stop&n;&t;&t; * processing the rest of the chunks in the packet.&n;&t;&t; */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_DISCARD_PACKET
comma
id|SCTP_NULL
c_func
(paren
)paren
)paren
suffix:semicolon
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_ASSOC_FAILED
comma
id|SCTP_NULL
c_func
(paren
)paren
)paren
suffix:semicolon
r_return
id|SCTP_DISPOSITION_CONSUME
suffix:semicolon
)brace
multiline_comment|/* If definately accepting the DATA chunk, record its TSN, otherwise&n;&t; * wait for renege processing. &n;&t; */
r_if
c_cond
(paren
id|deliver
op_ne
id|SCTP_CMD_CHUNK_PD
)paren
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_REPORT_TSN
comma
id|SCTP_U32
c_func
(paren
id|tsn
)paren
)paren
suffix:semicolon
multiline_comment|/* RFC 2960 6.5 Stream Identifier and Stream Sequence Number&n;&t; *&n;&t; * If an endpoint receive a DATA chunk with an invalid stream&n;&t; * identifier, it shall acknowledge the reception of the DATA chunk&n;&t; * following the normal procedure, immediately send an ERROR chunk&n;&t; * with cause set to &quot;Invalid Stream Identifier&quot; (See Section 3.3.10)&n;&t; * and discard the DATA chunk.&n;&t; */
r_if
c_cond
(paren
id|ntohs
c_func
(paren
id|data_hdr-&gt;stream
)paren
op_ge
id|asoc-&gt;c.sinit_max_instreams
)paren
(brace
id|err
op_assign
id|sctp_make_op_error
c_func
(paren
id|asoc
comma
id|chunk
comma
id|SCTP_ERROR_INV_STRM
comma
op_amp
id|data_hdr-&gt;stream
comma
r_sizeof
(paren
id|data_hdr-&gt;stream
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_REPLY
comma
id|SCTP_CHUNK
c_func
(paren
id|err
)paren
)paren
suffix:semicolon
r_goto
id|discard_noforce
suffix:semicolon
)brace
multiline_comment|/* Send the data up to the user.  Note:  Schedule  the&n;&t; * SCTP_CMD_CHUNK_ULP cmd before the SCTP_CMD_GEN_SACK, as the SACK&n;&t; * chunk needs the updated rwnd.&n;&t; */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|deliver
comma
id|SCTP_CHUNK
c_func
(paren
id|chunk
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|asoc-&gt;autoclose
)paren
(brace
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_TIMER_RESTART
comma
id|SCTP_TO
c_func
(paren
id|SCTP_EVENT_TIMEOUT_AUTOCLOSE
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* If this is the last chunk in a packet, we need to count it&n;&t; * toward sack generation.  Note that we need to SACK every&n;&t; * OTHER packet containing data chunks, EVEN IF WE DISCARD&n;&t; * THEM.  We elect to NOT generate SACK&squot;s if the chunk fails&n;&t; * the verification tag test.&n;&t; *&n;&t; * RFC 2960 6.2 Acknowledgement on Reception of DATA Chunks&n;&t; *&n;&t; * The SCTP endpoint MUST always acknowledge the reception of&n;&t; * each valid DATA chunk.&n;&t; *&n;&t; * The guidelines on delayed acknowledgement algorithm&n;&t; * specified in  Section 4.2 of [RFC2581] SHOULD be followed.&n;&t; * Specifically, an acknowledgement SHOULD be generated for at&n;&t; * least every second packet (not every second DATA chunk)&n;&t; * received, and SHOULD be generated within 200 ms of the&n;&t; * arrival of any unacknowledged DATA chunk.  In some&n;&t; * situations it may be beneficial for an SCTP transmitter to&n;&t; * be more conservative than the algorithms detailed in this&n;&t; * document allow. However, an SCTP transmitter MUST NOT be&n;&t; * more aggressive than the following algorithms allow.&n;&t; */
r_if
c_cond
(paren
id|chunk-&gt;end_of_packet
)paren
(brace
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_GEN_SACK
comma
id|SCTP_NOFORCE
c_func
(paren
)paren
)paren
suffix:semicolon
multiline_comment|/* Start the SACK timer.  */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_TIMER_RESTART
comma
id|SCTP_TO
c_func
(paren
id|SCTP_EVENT_TIMEOUT_SACK
)paren
)paren
suffix:semicolon
)brace
r_return
id|SCTP_DISPOSITION_CONSUME
suffix:semicolon
id|discard_force
suffix:colon
multiline_comment|/* RFC 2960 6.2 Acknowledgement on Reception of DATA Chunks&n;&t; *&n;&t; * When a packet arrives with duplicate DATA chunk(s) and with&n;&t; * no new DATA chunk(s), the endpoint MUST immediately send a&n;&t; * SACK with no delay.  If a packet arrives with duplicate&n;&t; * DATA chunk(s) bundled with new DATA chunks, the endpoint&n;&t; * MAY immediately send a SACK.  Normally receipt of duplicate&n;&t; * DATA chunks will occur when the original SACK chunk was lost&n;&t; * and the peer&squot;s RTO has expired.  The duplicate TSN number(s)&n;&t; * SHOULD be reported in the SACK as duplicate.&n;&t; */
multiline_comment|/* In our case, we split the MAY SACK advice up whether or not&n;&t; * the last chunk is a duplicate.&squot;&n;&t; */
r_if
c_cond
(paren
id|chunk-&gt;end_of_packet
)paren
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_GEN_SACK
comma
id|SCTP_FORCE
c_func
(paren
)paren
)paren
suffix:semicolon
r_return
id|SCTP_DISPOSITION_DISCARD
suffix:semicolon
id|discard_noforce
suffix:colon
r_if
c_cond
(paren
id|chunk-&gt;end_of_packet
)paren
(brace
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_GEN_SACK
comma
id|SCTP_NOFORCE
c_func
(paren
)paren
)paren
suffix:semicolon
multiline_comment|/* Start the SACK timer.  */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_TIMER_RESTART
comma
id|SCTP_TO
c_func
(paren
id|SCTP_EVENT_TIMEOUT_SACK
)paren
)paren
suffix:semicolon
)brace
r_return
id|SCTP_DISPOSITION_DISCARD
suffix:semicolon
)brace
multiline_comment|/*&n; * sctp_sf_eat_data_fast_4_4&n; *&n; * Section: 4 (4)&n; * (4) In SHUTDOWN-SENT state the endpoint MUST acknowledge any received&n; *    DATA chunks without delay.&n; *&n; * Verification Tag:  8.5 Verification Tag [Normal verification]&n; * Inputs&n; * (endpoint, asoc, chunk)&n; *&n; * Outputs&n; * (asoc, reply_msg, msg_up, timers, counters)&n; *&n; * The return value is the disposition of the chunk.&n; */
DECL|function|sctp_sf_eat_data_fast_4_4
id|sctp_disposition_t
id|sctp_sf_eat_data_fast_4_4
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
r_const
id|sctp_subtype_t
id|type
comma
r_void
op_star
id|arg
comma
id|sctp_cmd_seq_t
op_star
id|commands
)paren
(brace
id|sctp_chunk_t
op_star
id|chunk
op_assign
id|arg
suffix:semicolon
id|sctp_datahdr_t
op_star
id|data_hdr
suffix:semicolon
id|sctp_chunk_t
op_star
id|err
suffix:semicolon
r_int
id|datalen
suffix:semicolon
r_int
id|tmp
suffix:semicolon
id|__u32
id|tsn
suffix:semicolon
multiline_comment|/* RFC 2960 8.5 Verification Tag&n;&t; *&n;&t; * When receiving an SCTP packet, the endpoint MUST ensure&n;&t; * that the value in the Verification Tag field of the&n;&t; * received SCTP packet matches its own Tag.&n;&t; */
r_if
c_cond
(paren
id|ntohl
c_func
(paren
id|chunk-&gt;sctp_hdr-&gt;vtag
)paren
op_ne
id|asoc-&gt;c.my_vtag
)paren
(brace
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_REPORT_BAD_TAG
comma
id|SCTP_NULL
c_func
(paren
)paren
)paren
suffix:semicolon
r_return
id|sctp_sf_pdiscard
c_func
(paren
id|ep
comma
id|asoc
comma
id|type
comma
id|arg
comma
id|commands
)paren
suffix:semicolon
)brace
id|data_hdr
op_assign
id|chunk-&gt;subh.data_hdr
op_assign
(paren
id|sctp_datahdr_t
op_star
)paren
id|chunk-&gt;skb-&gt;data
suffix:semicolon
id|skb_pull
c_func
(paren
id|chunk-&gt;skb
comma
r_sizeof
(paren
id|sctp_datahdr_t
)paren
)paren
suffix:semicolon
id|tsn
op_assign
id|ntohl
c_func
(paren
id|data_hdr-&gt;tsn
)paren
suffix:semicolon
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;eat_data: TSN 0x%x.&bslash;n&quot;
comma
id|tsn
)paren
suffix:semicolon
multiline_comment|/* ASSERT:  Now skb-&gt;data is really the user data.  */
multiline_comment|/* Process ECN based congestion.&n;&t; *&n;&t; * Since the chunk structure is reused for all chunks within&n;&t; * a packet, we use ecn_ce_done to track if we&squot;ve already&n;&t; * done CE processing for this packet.&n;&t; *&n;&t; * We need to do ECN processing even if we plan to discard the&n;&t; * chunk later.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|chunk-&gt;ecn_ce_done
)paren
(brace
id|chunk-&gt;ecn_ce_done
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|INET_ECN_is_ce
c_func
(paren
id|chunk-&gt;skb-&gt;nh.iph-&gt;tos
)paren
op_logical_and
id|asoc-&gt;peer.ecn_capable
)paren
(brace
multiline_comment|/* Do real work as sideffect. */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_ECN_CE
comma
id|SCTP_U32
c_func
(paren
id|tsn
)paren
)paren
suffix:semicolon
)brace
)brace
id|tmp
op_assign
id|sctp_tsnmap_check
c_func
(paren
op_amp
id|asoc-&gt;peer.tsn_map
comma
id|tsn
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
OL
l_int|0
)paren
(brace
multiline_comment|/* The TSN is too high--silently discard the chunk and&n;&t;&t; * count on it getting retransmitted later.&n;&t;&t; */
r_goto
id|gen_shutdown
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|tmp
OG
l_int|0
)paren
(brace
multiline_comment|/* This is a duplicate.  Record it.  */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_REPORT_DUP
comma
id|SCTP_U32
c_func
(paren
id|tsn
)paren
)paren
suffix:semicolon
r_goto
id|gen_shutdown
suffix:semicolon
)brace
multiline_comment|/* This is a new TSN.  */
id|datalen
op_assign
id|ntohs
c_func
(paren
id|chunk-&gt;chunk_hdr-&gt;length
)paren
suffix:semicolon
id|datalen
op_sub_assign
r_sizeof
(paren
id|sctp_data_chunk_t
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Section 3.3.10.9 No User Data (9)&n;&t; *&n;&t; * Cause of error&n;&t; * ---------------&n;&t; * No User Data:  This error cause is returned to the originator of a&n;&t; * DATA chunk if a received DATA chunk has no user data.&n;&t; */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
l_int|0
op_eq
id|datalen
)paren
)paren
(brace
id|err
op_assign
id|sctp_make_abort_no_data
c_func
(paren
id|asoc
comma
id|chunk
comma
id|tsn
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_REPLY
comma
id|SCTP_CHUNK
c_func
(paren
id|err
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* We are going to ABORT, so we might as well stop&n;&t;&t; * processing the rest of the chunks in the packet.&n;&t;&t; */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_DISCARD_PACKET
comma
id|SCTP_NULL
c_func
(paren
)paren
)paren
suffix:semicolon
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_ASSOC_FAILED
comma
id|SCTP_NULL
c_func
(paren
)paren
)paren
suffix:semicolon
r_return
id|SCTP_DISPOSITION_CONSUME
suffix:semicolon
)brace
multiline_comment|/* We are accepting this DATA chunk. */
multiline_comment|/* Record the fact that we have received this TSN.  */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_REPORT_TSN
comma
id|SCTP_U32
c_func
(paren
id|tsn
)paren
)paren
suffix:semicolon
multiline_comment|/* RFC 2960 6.5 Stream Identifier and Stream Sequence Number&n;&t; *&n;&t; * If an endpoint receive a DATA chunk with an invalid stream&n;&t; * identifier, it shall acknowledge the reception of the DATA chunk&n;&t; * following the normal procedure, immediately send an ERROR chunk&n;&t; * with cause set to &quot;Invalid Stream Identifier&quot; (See Section 3.3.10)&n;&t; * and discard the DATA chunk.&n;&t; */
r_if
c_cond
(paren
id|ntohs
c_func
(paren
id|data_hdr-&gt;stream
)paren
op_ge
id|asoc-&gt;c.sinit_max_instreams
)paren
(brace
id|err
op_assign
id|sctp_make_op_error
c_func
(paren
id|asoc
comma
id|chunk
comma
id|SCTP_ERROR_INV_STRM
comma
op_amp
id|data_hdr-&gt;stream
comma
r_sizeof
(paren
id|data_hdr-&gt;stream
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_REPLY
comma
id|SCTP_CHUNK
c_func
(paren
id|err
)paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Go a head and force a SACK, since we are shutting down. */
id|gen_shutdown
suffix:colon
multiline_comment|/* Implementor&squot;s Guide.&n;&t; *&n;&t; * While in SHUTDOWN-SENT state, the SHUTDOWN sender MUST immediately&n;&t; * respond to each received packet containing one or more DATA chunk(s)&n;&t; * with a SACK, a SHUTDOWN chunk, and restart the T2-shutdown timer&n;&t; */
r_if
c_cond
(paren
id|chunk-&gt;end_of_packet
)paren
(brace
multiline_comment|/* We must delay the chunk creation since the cumulative&n;&t;&t; * TSN has not been updated yet.&n;&t;&t; */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_GEN_SHUTDOWN
comma
id|SCTP_NULL
c_func
(paren
)paren
)paren
suffix:semicolon
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_GEN_SACK
comma
id|SCTP_FORCE
c_func
(paren
)paren
)paren
suffix:semicolon
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_TIMER_RESTART
comma
id|SCTP_TO
c_func
(paren
id|SCTP_EVENT_TIMEOUT_T2_SHUTDOWN
)paren
)paren
suffix:semicolon
)brace
r_return
id|SCTP_DISPOSITION_CONSUME
suffix:semicolon
)brace
multiline_comment|/*&n; * Section: 6.2  Processing a Received SACK&n; * D) Any time a SACK arrives, the endpoint performs the following:&n; *&n; *     i) If Cumulative TSN Ack is less than the Cumulative TSN Ack Point,&n; *     then drop the SACK.   Since Cumulative TSN Ack is monotonically&n; *     increasing, a SACK whose Cumulative TSN Ack is less than the&n; *     Cumulative TSN Ack Point indicates an out-of-order SACK.&n; *&n; *     ii) Set rwnd equal to the newly received a_rwnd minus the number&n; *     of bytes still outstanding after processing the Cumulative TSN Ack&n; *     and the Gap Ack Blocks.&n; *&n; *     iii) If the SACK is missing a TSN that was previously&n; *     acknowledged via a Gap Ack Block (e.g., the data receiver&n; *     reneged on the data), then mark the corresponding DATA chunk&n; *     as available for retransmit:  Mark it as missing for fast&n; *     retransmit as described in Section 7.2.4 and if no retransmit&n; *     timer is running for the destination address to which the DATA&n; *     chunk was originally transmitted, then T3-rtx is started for&n; *     that destination address.&n; *&n; * Verification Tag:  8.5 Verification Tag [Normal verification]&n; *&n; * Inputs&n; * (endpoint, asoc, chunk)&n; *&n; * Outputs&n; * (asoc, reply_msg, msg_up, timers, counters)&n; *&n; * The return value is the disposition of the chunk.&n; */
DECL|function|sctp_sf_eat_sack_6_2
id|sctp_disposition_t
id|sctp_sf_eat_sack_6_2
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
r_const
id|sctp_subtype_t
id|type
comma
r_void
op_star
id|arg
comma
id|sctp_cmd_seq_t
op_star
id|commands
)paren
(brace
id|sctp_chunk_t
op_star
id|chunk
op_assign
id|arg
suffix:semicolon
id|sctp_sackhdr_t
op_star
id|sackh
suffix:semicolon
id|__u32
id|ctsn
suffix:semicolon
multiline_comment|/* 8.5 When receiving an SCTP packet, the endpoint MUST ensure&n;&t; * that the value in the Verification Tag field of the&n;&t; * received SCTP packet matches its own Tag. ...&n;&t; */
r_if
c_cond
(paren
id|ntohl
c_func
(paren
id|chunk-&gt;sctp_hdr-&gt;vtag
)paren
op_ne
id|asoc-&gt;c.my_vtag
)paren
r_return
id|sctp_sf_pdiscard
c_func
(paren
id|ep
comma
id|asoc
comma
id|type
comma
id|arg
comma
id|commands
)paren
suffix:semicolon
multiline_comment|/* Pull the SACK chunk from the data buffer */
id|sackh
op_assign
id|sctp_sm_pull_sack
c_func
(paren
id|chunk
)paren
suffix:semicolon
id|chunk-&gt;subh.sack_hdr
op_assign
id|sackh
suffix:semicolon
id|ctsn
op_assign
id|ntohl
c_func
(paren
id|sackh-&gt;cum_tsn_ack
)paren
suffix:semicolon
multiline_comment|/* i) If Cumulative TSN Ack is less than the Cumulative TSN&n;&t; *     Ack Point, then drop the SACK.  Since Cumulative TSN&n;&t; *     Ack is monotonically increasing, a SACK whose&n;&t; *     Cumulative TSN Ack is less than the Cumulative TSN Ack&n;&t; *     Point indicates an out-of-order SACK.&n;&t; */
r_if
c_cond
(paren
id|TSN_lt
c_func
(paren
id|ctsn
comma
id|asoc-&gt;ctsn_ack_point
)paren
)paren
(brace
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;ctsn %x&bslash;n&quot;
comma
id|ctsn
)paren
suffix:semicolon
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;ctsn_ack_point %x&bslash;n&quot;
comma
id|asoc-&gt;ctsn_ack_point
)paren
suffix:semicolon
r_return
id|SCTP_DISPOSITION_DISCARD
suffix:semicolon
)brace
multiline_comment|/* Return this SACK for further processing.  */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_PROCESS_SACK
comma
id|SCTP_SACKH
c_func
(paren
id|sackh
)paren
)paren
suffix:semicolon
multiline_comment|/* Note: We do the rest of the work on the PROCESS_SACK&n;&t; * sideeffect.&n;&t; */
r_return
id|SCTP_DISPOSITION_CONSUME
suffix:semicolon
)brace
multiline_comment|/*&n; * Generate an ABORT in response to a packet.&n; *&n; * Section: 8.4 Handle &quot;Out of the blue&quot; Packets&n; *&n; * 8) The receiver should respond to the sender of the OOTB packet&n; *    with an ABORT.  When sending the ABORT, the receiver of the&n; *    OOTB packet MUST fill in the Verification Tag field of the&n; *    outbound packet with the value found in the Verification Tag&n; *    field of the OOTB packet and set the T-bit in the Chunk Flags&n; *    to indicate that no TCB was found.  After sending this ABORT,&n; *    the receiver of the OOTB packet shall discard the OOTB packet&n; *    and take no further action.&n; *&n; * Verification Tag:&n; *&n; * The return value is the disposition of the chunk.&n;*/
DECL|function|sctp_sf_tabort_8_4_8
id|sctp_disposition_t
id|sctp_sf_tabort_8_4_8
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
r_const
id|sctp_subtype_t
id|type
comma
r_void
op_star
id|arg
comma
id|sctp_cmd_seq_t
op_star
id|commands
)paren
(brace
id|sctp_packet_t
op_star
id|packet
op_assign
l_int|NULL
suffix:semicolon
id|sctp_chunk_t
op_star
id|chunk
op_assign
id|arg
suffix:semicolon
id|sctp_chunk_t
op_star
m_abort
suffix:semicolon
id|packet
op_assign
id|sctp_ootb_pkt_new
c_func
(paren
id|asoc
comma
id|chunk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|packet
)paren
(brace
multiline_comment|/* Make an ABORT. The T bit will be set if the asoc&n;&t;&t; * is NULL.&n;&t;&t; */
m_abort
op_assign
id|sctp_make_abort
c_func
(paren
id|asoc
comma
id|chunk
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
m_abort
)paren
(brace
id|sctp_ootb_pkt_free
c_func
(paren
id|packet
)paren
suffix:semicolon
r_return
id|SCTP_DISPOSITION_NOMEM
suffix:semicolon
)brace
multiline_comment|/* Set the skb to the belonging sock for accounting.  */
m_abort
op_member_access_from_pointer
id|skb-&gt;sk
op_assign
id|ep-&gt;base.sk
suffix:semicolon
id|sctp_packet_append_chunk
c_func
(paren
id|packet
comma
m_abort
)paren
suffix:semicolon
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_SEND_PKT
comma
id|SCTP_PACKET
c_func
(paren
id|packet
)paren
)paren
suffix:semicolon
r_return
id|SCTP_DISPOSITION_CONSUME
suffix:semicolon
)brace
r_return
id|SCTP_DISPOSITION_NOMEM
suffix:semicolon
)brace
multiline_comment|/*&n; * Received an ERROR chunk from peer.  Generate SCTP_REMOTE_ERROR&n; * event as ULP notification for each cause included in the chunk.&n; *&n; * API 5.3.1.3 - SCTP_REMOTE_ERROR&n; *&n; * The return value is the disposition of the chunk.&n;*/
DECL|function|sctp_sf_operr_notify
id|sctp_disposition_t
id|sctp_sf_operr_notify
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
r_const
id|sctp_subtype_t
id|type
comma
r_void
op_star
id|arg
comma
id|sctp_cmd_seq_t
op_star
id|commands
)paren
(brace
id|sctp_chunk_t
op_star
id|chunk
op_assign
id|arg
suffix:semicolon
r_struct
id|sctp_ulpevent
op_star
id|ev
suffix:semicolon
r_while
c_loop
(paren
id|chunk-&gt;chunk_end
OG
id|chunk-&gt;skb-&gt;data
)paren
(brace
id|ev
op_assign
id|sctp_ulpevent_make_remote_error
c_func
(paren
id|asoc
comma
id|chunk
comma
l_int|0
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ev
)paren
r_goto
id|nomem
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sctp_add_cmd
c_func
(paren
id|commands
comma
id|SCTP_CMD_EVENT_ULP
comma
id|SCTP_ULPEVENT
c_func
(paren
id|ev
)paren
)paren
)paren
(brace
id|sctp_ulpevent_free
c_func
(paren
id|ev
)paren
suffix:semicolon
r_goto
id|nomem
suffix:semicolon
)brace
)brace
r_return
id|SCTP_DISPOSITION_CONSUME
suffix:semicolon
id|nomem
suffix:colon
r_return
id|SCTP_DISPOSITION_NOMEM
suffix:semicolon
)brace
multiline_comment|/*&n; * Process an inbound SHUTDOWN ACK.&n; *&n; * From Section 9.2:&n; * Upon the receipt of the SHUTDOWN ACK, the SHUTDOWN sender shall&n; * stop the T2-shutdown timer, send a SHUTDOWN COMPLETE chunk to its&n; * peer, and remove all record of the association.&n; *&n; * The return value is the disposition.&n; */
DECL|function|sctp_sf_do_9_2_final
id|sctp_disposition_t
id|sctp_sf_do_9_2_final
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
r_const
id|sctp_subtype_t
id|type
comma
r_void
op_star
id|arg
comma
id|sctp_cmd_seq_t
op_star
id|commands
)paren
(brace
id|sctp_chunk_t
op_star
id|chunk
op_assign
id|arg
suffix:semicolon
id|sctp_chunk_t
op_star
id|reply
suffix:semicolon
r_struct
id|sctp_ulpevent
op_star
id|ev
suffix:semicolon
multiline_comment|/* 10.2 H) SHUTDOWN COMPLETE notification&n;&t; *&n;&t; * When SCTP completes the shutdown procedures (section 9.2) this&n;&t; * notification is passed to the upper layer.&n;&t; */
id|ev
op_assign
id|sctp_ulpevent_make_assoc_change
c_func
(paren
id|asoc
comma
l_int|0
comma
id|SCTP_SHUTDOWN_COMP
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ev
)paren
r_goto
id|nomem
suffix:semicolon
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_EVENT_ULP
comma
id|SCTP_ULPEVENT
c_func
(paren
id|ev
)paren
)paren
suffix:semicolon
multiline_comment|/* Upon the receipt of the SHUTDOWN ACK, the SHUTDOWN sender shall&n;&t; * stop the T2-shutdown timer,&n;&t; */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_TIMER_STOP
comma
id|SCTP_TO
c_func
(paren
id|SCTP_EVENT_TIMEOUT_T2_SHUTDOWN
)paren
)paren
suffix:semicolon
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_TIMER_STOP
comma
id|SCTP_TO
c_func
(paren
id|SCTP_EVENT_TIMEOUT_T5_SHUTDOWN_GUARD
)paren
)paren
suffix:semicolon
multiline_comment|/* ...send a SHUTDOWN COMPLETE chunk to its peer, */
id|reply
op_assign
id|sctp_make_shutdown_complete
c_func
(paren
id|asoc
comma
id|chunk
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|reply
)paren
r_goto
id|nomem
suffix:semicolon
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_NEW_STATE
comma
id|SCTP_STATE
c_func
(paren
id|SCTP_STATE_CLOSED
)paren
)paren
suffix:semicolon
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_REPLY
comma
id|SCTP_CHUNK
c_func
(paren
id|reply
)paren
)paren
suffix:semicolon
multiline_comment|/* ...and remove all record of the association. */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_DELETE_TCB
comma
id|SCTP_NULL
c_func
(paren
)paren
)paren
suffix:semicolon
r_return
id|SCTP_DISPOSITION_DELETE_TCB
suffix:semicolon
id|nomem
suffix:colon
r_return
id|SCTP_DISPOSITION_NOMEM
suffix:semicolon
)brace
multiline_comment|/*&n; * RFC 2960, 8.4 - Handle &quot;Out of the blue&quot; Packets&n; * 5) If the packet contains a SHUTDOWN ACK chunk, the receiver should&n; *    respond to the sender of the OOTB packet with a SHUTDOWN COMPLETE.&n; *    When sending the SHUTDOWN COMPLETE, the receiver of the OOTB&n; *    packet must fill in the Verification Tag field of the outbound&n; *    packet with the Verification Tag received in the SHUTDOWN ACK and&n; *    set the T-bit in the Chunk Flags to indicate that no TCB was&n; *    found. Otherwise,&n; *&n; * 8) The receiver should respond to the sender of the OOTB packet with&n; *    an ABORT.  When sending the ABORT, the receiver of the OOTB packet&n; *    MUST fill in the Verification Tag field of the outbound packet&n; *    with the value found in the Verification Tag field of the OOTB&n; *    packet and set the T-bit in the Chunk Flags to indicate that no&n; *    TCB was found.  After sending this ABORT, the receiver of the OOTB&n; *    packet shall discard the OOTB packet and take no further action.&n; */
DECL|function|sctp_sf_ootb
id|sctp_disposition_t
id|sctp_sf_ootb
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
r_const
id|sctp_subtype_t
id|type
comma
r_void
op_star
id|arg
comma
id|sctp_cmd_seq_t
op_star
id|commands
)paren
(brace
id|sctp_chunk_t
op_star
id|chunk
op_assign
id|arg
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
op_assign
id|chunk-&gt;skb
suffix:semicolon
id|sctp_chunkhdr_t
op_star
id|ch
suffix:semicolon
id|__u8
op_star
id|ch_end
suffix:semicolon
r_int
id|ootb_shut_ack
op_assign
l_int|0
suffix:semicolon
id|ch
op_assign
(paren
id|sctp_chunkhdr_t
op_star
)paren
id|chunk-&gt;chunk_hdr
suffix:semicolon
r_do
(brace
id|ch_end
op_assign
(paren
(paren
id|__u8
op_star
)paren
id|ch
)paren
op_plus
id|WORD_ROUND
c_func
(paren
id|ntohs
c_func
(paren
id|ch-&gt;length
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SCTP_CID_SHUTDOWN_ACK
op_eq
id|ch-&gt;type
)paren
id|ootb_shut_ack
op_assign
l_int|1
suffix:semicolon
id|ch
op_assign
(paren
id|sctp_chunkhdr_t
op_star
)paren
id|ch_end
suffix:semicolon
)brace
r_while
c_loop
(paren
id|ch_end
OL
id|skb-&gt;tail
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ootb_shut_ack
)paren
id|sctp_sf_shut_8_4_5
c_func
(paren
id|ep
comma
id|asoc
comma
id|type
comma
id|arg
comma
id|commands
)paren
suffix:semicolon
r_else
id|sctp_sf_tabort_8_4_8
c_func
(paren
id|ep
comma
id|asoc
comma
id|type
comma
id|arg
comma
id|commands
)paren
suffix:semicolon
r_return
id|sctp_sf_pdiscard
c_func
(paren
id|ep
comma
id|asoc
comma
id|type
comma
id|arg
comma
id|commands
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Handle an &quot;Out of the blue&quot; SHUTDOWN ACK.&n; *&n; * Section: 8.4 5)&n; * 5) If the packet contains a SHUTDOWN ACK chunk, the receiver should&n; *   respond to the sender of the OOTB packet with a SHUTDOWN COMPLETE.&n; *   When sending the SHUTDOWN COMPLETE, the receiver of the OOTB packet&n; *   must fill in the Verification Tag field of the outbound packet with&n; *   the Verification Tag received in the SHUTDOWN ACK and set the&n; *   T-bit in the Chunk Flags to indicate that no TCB was found.&n; *&n; * Inputs&n; * (endpoint, asoc, type, arg, commands)&n; *&n; * Outputs&n; * (sctp_disposition_t)&n; *&n; * The return value is the disposition of the chunk.&n; */
DECL|function|sctp_sf_shut_8_4_5
id|sctp_disposition_t
id|sctp_sf_shut_8_4_5
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
r_const
id|sctp_subtype_t
id|type
comma
r_void
op_star
id|arg
comma
id|sctp_cmd_seq_t
op_star
id|commands
)paren
(brace
id|sctp_packet_t
op_star
id|packet
op_assign
l_int|NULL
suffix:semicolon
id|sctp_chunk_t
op_star
id|chunk
op_assign
id|arg
suffix:semicolon
id|sctp_chunk_t
op_star
id|shut
suffix:semicolon
id|packet
op_assign
id|sctp_ootb_pkt_new
c_func
(paren
id|asoc
comma
id|chunk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|packet
)paren
(brace
multiline_comment|/* Make an SHUTDOWN_COMPLETE.&n;         &t; * The T bit will be set if the asoc is NULL.&n;         &t; */
id|shut
op_assign
id|sctp_make_shutdown_complete
c_func
(paren
id|asoc
comma
id|chunk
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|shut
)paren
(brace
id|sctp_ootb_pkt_free
c_func
(paren
id|packet
)paren
suffix:semicolon
r_return
id|SCTP_DISPOSITION_NOMEM
suffix:semicolon
)brace
multiline_comment|/* Set the skb to the belonging sock for accounting.  */
id|shut-&gt;skb-&gt;sk
op_assign
id|ep-&gt;base.sk
suffix:semicolon
id|sctp_packet_append_chunk
c_func
(paren
id|packet
comma
id|shut
)paren
suffix:semicolon
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_SEND_PKT
comma
id|SCTP_PACKET
c_func
(paren
id|packet
)paren
)paren
suffix:semicolon
r_return
id|SCTP_DISPOSITION_CONSUME
suffix:semicolon
)brace
r_return
id|SCTP_DISPOSITION_NOMEM
suffix:semicolon
)brace
multiline_comment|/*&n; * Handle SHUTDOWN ACK in COOKIE_ECHOED or COOKIE_WAIT state.&n; *&n; * Verification Tag:  8.5.1 E) Rules for packet carrying a SHUTDOWN ACK&n; *   If the receiver is in COOKIE-ECHOED or COOKIE-WAIT state the&n; *   procedures in section 8.4 SHOULD be followed, in other words it&n; *   should be treated as an Out Of The Blue packet.&n; *   [This means that we do NOT check the Verification Tag on these&n; *   chunks. --piggy ]&n; *&n; */
DECL|function|sctp_sf_do_8_5_1_E_sa
id|sctp_disposition_t
id|sctp_sf_do_8_5_1_E_sa
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
r_const
id|sctp_subtype_t
id|type
comma
r_void
op_star
id|arg
comma
id|sctp_cmd_seq_t
op_star
id|commands
)paren
(brace
multiline_comment|/* Although we do have an association in this case, it corresponds&n;&t; * to a restarted association. So the packet is treated as an OOTB&n;&t; * packet and the state function that handles OOTB SHUTDOWN_ACK is&n;&t; * called with a NULL association.&n;&t; */
r_return
id|sctp_sf_shut_8_4_5
c_func
(paren
id|ep
comma
l_int|NULL
comma
id|type
comma
id|arg
comma
id|commands
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Process an unknown chunk.&n; *&n; * Section: 3.2. Also, 2.1 in the implementor&squot;s guide.&n; *&n; * Chunk Types are encoded such that the highest-order two bits specify&n; * the action that must be taken if the processing endpoint does not&n; * recognize the Chunk Type.&n; *&n; * 00 - Stop processing this SCTP packet and discard it, do not process&n; *      any further chunks within it.&n; *&n; * 01 - Stop processing this SCTP packet and discard it, do not process&n; *      any further chunks within it, and report the unrecognized&n; *      chunk in an &squot;Unrecognized Chunk Type&squot;.&n; *&n; * 10 - Skip this chunk and continue processing.&n; *&n; * 11 - Skip this chunk and continue processing, but report in an ERROR&n; *      Chunk using the &squot;Unrecognized Chunk Type&squot; cause of error.&n; *&n; * The return value is the disposition of the chunk.&n; */
DECL|function|sctp_sf_unk_chunk
id|sctp_disposition_t
id|sctp_sf_unk_chunk
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
r_const
id|sctp_subtype_t
id|type
comma
r_void
op_star
id|arg
comma
id|sctp_cmd_seq_t
op_star
id|commands
)paren
(brace
id|sctp_chunk_t
op_star
id|unk_chunk
op_assign
id|arg
suffix:semicolon
id|sctp_chunk_t
op_star
id|err_chunk
suffix:semicolon
id|sctp_chunkhdr_t
op_star
id|hdr
suffix:semicolon
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;Processing the unknown chunk id %d.&bslash;n&quot;
comma
id|type.chunk
)paren
suffix:semicolon
multiline_comment|/* 8.5 When receiving an SCTP packet, the endpoint MUST ensure&n;&t; * that the value in the Verification Tag field of the&n;&t; * received SCTP packet matches its own Tag.  If the received&n;&t; * Verification Tag value does not match the receiver&squot;s own&n;&t; * tag value, the receiver shall silently discard the packet.&n;&t; */
r_if
c_cond
(paren
id|ntohl
c_func
(paren
id|unk_chunk-&gt;sctp_hdr-&gt;vtag
)paren
op_ne
id|asoc-&gt;c.my_vtag
)paren
r_return
id|sctp_sf_pdiscard
c_func
(paren
id|ep
comma
id|asoc
comma
id|type
comma
id|arg
comma
id|commands
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|type.chunk
op_amp
id|SCTP_CID_ACTION_MASK
)paren
(brace
r_case
id|SCTP_CID_ACTION_DISCARD
suffix:colon
multiline_comment|/* Discard the packet.  */
r_return
id|sctp_sf_pdiscard
c_func
(paren
id|ep
comma
id|asoc
comma
id|type
comma
id|arg
comma
id|commands
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_CID_ACTION_DISCARD_ERR
suffix:colon
multiline_comment|/* Discard the packet.  */
id|sctp_sf_pdiscard
c_func
(paren
id|ep
comma
id|asoc
comma
id|type
comma
id|arg
comma
id|commands
)paren
suffix:semicolon
multiline_comment|/* Generate an ERROR chunk as response. */
id|hdr
op_assign
id|unk_chunk-&gt;chunk_hdr
suffix:semicolon
id|err_chunk
op_assign
id|sctp_make_op_error
c_func
(paren
id|asoc
comma
id|unk_chunk
comma
id|SCTP_ERROR_UNKNOWN_CHUNK
comma
id|hdr
comma
id|WORD_ROUND
c_func
(paren
id|ntohs
c_func
(paren
id|hdr-&gt;length
)paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err_chunk
)paren
(brace
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_REPLY
comma
id|SCTP_CHUNK
c_func
(paren
id|err_chunk
)paren
)paren
suffix:semicolon
)brace
r_return
id|SCTP_DISPOSITION_CONSUME
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_CID_ACTION_SKIP
suffix:colon
multiline_comment|/* Skip the chunk.  */
r_return
id|SCTP_DISPOSITION_DISCARD
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_CID_ACTION_SKIP_ERR
suffix:colon
multiline_comment|/* Generate an ERROR chunk as response. */
id|hdr
op_assign
id|unk_chunk-&gt;chunk_hdr
suffix:semicolon
id|err_chunk
op_assign
id|sctp_make_op_error
c_func
(paren
id|asoc
comma
id|unk_chunk
comma
id|SCTP_ERROR_UNKNOWN_CHUNK
comma
id|hdr
comma
id|WORD_ROUND
c_func
(paren
id|ntohs
c_func
(paren
id|hdr-&gt;length
)paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err_chunk
)paren
(brace
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_REPLY
comma
id|SCTP_CHUNK
c_func
(paren
id|err_chunk
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Skip the chunk.  */
r_return
id|SCTP_DISPOSITION_CONSUME
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
r_return
id|SCTP_DISPOSITION_DISCARD
suffix:semicolon
)brace
multiline_comment|/*&n; * Discard the chunk.&n; *&n; * Section: 0.2, 5.2.3, 5.2.5, 5.2.6, 6.0, 8.4.6, 8.5.1c, 9.2&n; * [Too numerous to mention...]&n; * Verification Tag: No verification needed.&n; * Inputs&n; * (endpoint, asoc, chunk)&n; *&n; * Outputs&n; * (asoc, reply_msg, msg_up, timers, counters)&n; *&n; * The return value is the disposition of the chunk.&n; */
DECL|function|sctp_sf_discard_chunk
id|sctp_disposition_t
id|sctp_sf_discard_chunk
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
r_const
id|sctp_subtype_t
id|type
comma
r_void
op_star
id|arg
comma
id|sctp_cmd_seq_t
op_star
id|commands
)paren
(brace
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;Chunk %d is discarded&bslash;n&quot;
comma
id|type.chunk
)paren
suffix:semicolon
r_return
id|SCTP_DISPOSITION_DISCARD
suffix:semicolon
)brace
multiline_comment|/*&n; * Discard the whole packet.&n; *&n; * Section: 8.4 2)&n; *&n; * 2) If the OOTB packet contains an ABORT chunk, the receiver MUST&n; *    silently discard the OOTB packet and take no further action.&n; *    Otherwise,&n; *&n; * Verification Tag: No verification necessary&n; *&n; * Inputs&n; * (endpoint, asoc, chunk)&n; *&n; * Outputs&n; * (asoc, reply_msg, msg_up, timers, counters)&n; *&n; * The return value is the disposition of the chunk.&n; */
DECL|function|sctp_sf_pdiscard
id|sctp_disposition_t
id|sctp_sf_pdiscard
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
r_const
id|sctp_subtype_t
id|type
comma
r_void
op_star
id|arg
comma
id|sctp_cmd_seq_t
op_star
id|commands
)paren
(brace
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_DISCARD_PACKET
comma
id|SCTP_NULL
c_func
(paren
)paren
)paren
suffix:semicolon
r_return
id|SCTP_DISPOSITION_CONSUME
suffix:semicolon
)brace
macro_line|#if 0
multiline_comment|/*&n; * We did something stupid but got lucky.  Namely, we sent a HEARTBEAT&n; * before the association was all the way up and we did NOT get an&n; * ABORT.&n; *&n; * Log the fact and then process normally.&n; *&n; * Section: Not specified&n; * Verification Tag:  8.5 Verification Tag [Normal verification]&n; * Inputs&n; * (endpoint, asoc, chunk)&n; *&n; * Outputs&n; * (asoc, reply_msg, msg_up, timers, counters)&n; *&n; * The return value is the disposition of the chunk.&n; */
id|sctp_disposition_t
id|lucky
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
r_const
id|sctp_subtype_t
id|type
comma
r_void
op_star
id|arg
comma
id|sctp_cmd_seq_t
op_star
id|commands
)paren
(brace
id|sctp_chunk_t
op_star
id|chunk
op_assign
id|arg
suffix:semicolon
multiline_comment|/* 8.5 When receiving an SCTP packet, the endpoint MUST ensure&n;&t; * that the value in the Verification Tag field of the&n;&t; * received SCTP packet matches its own Tag. ...&n;&t; */
r_if
c_cond
(paren
id|chunk-&gt;sctp_hdr-&gt;vtag
op_ne
id|asoc-&gt;c.my_vtag
)paren
r_return
id|sctp_sf_pdiscard
c_func
(paren
id|ep
comma
id|asoc
comma
id|type
comma
id|arg
comma
id|commands
)paren
suffix:semicolon
r_return
id|SCTP_DISPOSITION_CONSUME
suffix:semicolon
id|nomem
suffix:colon
r_return
id|SCTP_DISPOSITION_NOMEM
suffix:semicolon
)brace
macro_line|#endif /* 0 */
macro_line|#if 0
multiline_comment|/*&n; * The other end is doing something very stupid.  We&squot;ll ignore them&n; * after logging their idiocy. :-)&n; *&n; * Section: Not specified&n; * Verification Tag:  8.5 Verification Tag [Normal verification]&n; * Inputs&n; * (endpoint, asoc, chunk)&n; *&n; * Outputs&n; * (asoc, reply_msg, msg_up, timers, counters)&n; *&n; * The return value is the disposition of the chunk.&n; */
id|sctp_disposition_t
id|other_stupid
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
r_const
id|sctp_subtype_t
id|type
comma
r_void
op_star
id|arg
comma
id|sctp_cmd_seq_t
op_star
id|commands
)paren
(brace
id|sctp_chunk_t
op_star
id|chunk
op_assign
id|arg
suffix:semicolon
multiline_comment|/* 8.5 When receiving an SCTP packet, the endpoint MUST ensure&n;&t; * that the value in the Verification Tag field of the&n;&t; * received SCTP packet matches its own Tag. ...&n;&t; */
r_if
c_cond
(paren
id|chunk-&gt;sctp_hdr-&gt;vtag
op_ne
id|asoc-&gt;c.my_vtag
)paren
r_return
id|sctp_sf_pdiscard
c_func
(paren
id|ep
comma
id|asoc
comma
id|type
comma
id|arg
comma
id|commands
)paren
suffix:semicolon
r_return
id|SCTP_DISPOSITION_CONSUME
suffix:semicolon
id|nomem
suffix:colon
r_return
id|SCTP_DISPOSITION_NOMEM
suffix:semicolon
)brace
macro_line|#endif /* 0 */
multiline_comment|/*&n; * The other end is violating protocol.&n; *&n; * Section: Not specified&n; * Verification Tag: Not specified&n; * Inputs&n; * (endpoint, asoc, chunk)&n; *&n; * Outputs&n; * (asoc, reply_msg, msg_up, timers, counters)&n; *&n; * We simply tag the chunk as a violation.  The state machine will log&n; * the violation and continue.&n; */
DECL|function|sctp_sf_violation
id|sctp_disposition_t
id|sctp_sf_violation
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
r_const
id|sctp_subtype_t
id|type
comma
r_void
op_star
id|arg
comma
id|sctp_cmd_seq_t
op_star
id|commands
)paren
(brace
r_return
id|SCTP_DISPOSITION_VIOLATION
suffix:semicolon
)brace
multiline_comment|/***************************************************************************&n; * These are the state functions for handling primitive (Section 10) events.&n; ***************************************************************************/
multiline_comment|/*&n; * sctp_sf_do_prm_asoc&n; *&n; * Section: 10.1 ULP-to-SCTP&n; * B) Associate&n; *&n; * Format: ASSOCIATE(local SCTP instance name, destination transport addr,&n; * outbound stream count)&n; * -&gt; association id [,destination transport addr list] [,outbound stream&n; * count]&n; *&n; * This primitive allows the upper layer to initiate an association to a&n; * specific peer endpoint.&n; *&n; * The peer endpoint shall be specified by one of the transport addresses&n; * which defines the endpoint (see Section 1.4).  If the local SCTP&n; * instance has not been initialized, the ASSOCIATE is considered an&n; * error.&n; * [This is not relevant for the kernel implementation since we do all&n; * initialization at boot time.  It we hadn&squot;t initialized we wouldn&squot;t&n; * get anywhere near this code.]&n; *&n; * An association id, which is a local handle to the SCTP association,&n; * will be returned on successful establishment of the association. If&n; * SCTP is not able to open an SCTP association with the peer endpoint,&n; * an error is returned.&n; * [In the kernel implementation, the sctp_association_t needs to&n; * be created BEFORE causing this primitive to run.]&n; *&n; * Other association parameters may be returned, including the&n; * complete destination transport addresses of the peer as well as the&n; * outbound stream count of the local endpoint. One of the transport&n; * address from the returned destination addresses will be selected by&n; * the local endpoint as default primary path for sending SCTP packets&n; * to this peer.  The returned &quot;destination transport addr list&quot; can&n; * be used by the ULP to change the default primary path or to force&n; * sending a packet to a specific transport address.  [All of this&n; * stuff happens when the INIT ACK arrives.  This is a NON-BLOCKING&n; * function.]&n; *&n; * Mandatory attributes:&n; *&n; * o local SCTP instance name - obtained from the INITIALIZE operation.&n; *   [This is the argument asoc.]&n; * o destination transport addr - specified as one of the transport&n; * addresses of the peer endpoint with which the association is to be&n; * established.&n; *  [This is asoc-&gt;peer.active_path.]&n; * o outbound stream count - the number of outbound streams the ULP&n; * would like to open towards this peer endpoint.&n; * [BUG: This is not currently implemented.]&n; * Optional attributes:&n; *&n; * None.&n; *&n; * The return value is a disposition.&n; */
DECL|function|sctp_sf_do_prm_asoc
id|sctp_disposition_t
id|sctp_sf_do_prm_asoc
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
r_const
id|sctp_subtype_t
id|type
comma
r_void
op_star
id|arg
comma
id|sctp_cmd_seq_t
op_star
id|commands
)paren
(brace
id|sctp_chunk_t
op_star
id|repl
suffix:semicolon
multiline_comment|/* The comment below says that we enter COOKIE-WAIT AFTER&n;&t; * sending the INIT, but that doesn&squot;t actually work in our&n;&t; * implementation...&n;&t; */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_NEW_STATE
comma
id|SCTP_STATE
c_func
(paren
id|SCTP_STATE_COOKIE_WAIT
)paren
)paren
suffix:semicolon
multiline_comment|/* RFC 2960 5.1 Normal Establishment of an Association&n;&t; *&n;&t; * A) &quot;A&quot; first sends an INIT chunk to &quot;Z&quot;.  In the INIT, &quot;A&quot;&n;&t; * must provide its Verification Tag (Tag_A) in the Initiate&n;&t; * Tag field.  Tag_A SHOULD be a random number in the range of&n;&t; * 1 to 4294967295 (see 5.3.1 for Tag value selection). ...&n;&t; */
id|repl
op_assign
id|sctp_make_init
c_func
(paren
id|asoc
comma
op_amp
id|asoc-&gt;base.bind_addr
comma
id|GFP_ATOMIC
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|repl
)paren
r_goto
id|nomem
suffix:semicolon
multiline_comment|/* Cast away the const modifier, as we want to just&n;&t; * rerun it through as a sideffect.&n;&t; */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_NEW_ASOC
comma
id|SCTP_ASOC
c_func
(paren
(paren
id|sctp_association_t
op_star
)paren
id|asoc
)paren
)paren
suffix:semicolon
multiline_comment|/* After sending the INIT, &quot;A&quot; starts the T1-init timer and&n;&t; * enters the COOKIE-WAIT state.&n;&t; */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_TIMER_START
comma
id|SCTP_TO
c_func
(paren
id|SCTP_EVENT_TIMEOUT_T1_INIT
)paren
)paren
suffix:semicolon
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_REPLY
comma
id|SCTP_CHUNK
c_func
(paren
id|repl
)paren
)paren
suffix:semicolon
r_return
id|SCTP_DISPOSITION_CONSUME
suffix:semicolon
id|nomem
suffix:colon
r_return
id|SCTP_DISPOSITION_NOMEM
suffix:semicolon
)brace
multiline_comment|/*&n; * Process the SEND primitive.&n; *&n; * Section: 10.1 ULP-to-SCTP&n; * E) Send&n; *&n; * Format: SEND(association id, buffer address, byte count [,context]&n; *         [,stream id] [,life time] [,destination transport address]&n; *         [,unorder flag] [,no-bundle flag] [,payload protocol-id] )&n; * -&gt; result&n; *&n; * This is the main method to send user data via SCTP.&n; *&n; * Mandatory attributes:&n; *&n; *  o association id - local handle to the SCTP association&n; *&n; *  o buffer address - the location where the user message to be&n; *    transmitted is stored;&n; *&n; *  o byte count - The size of the user data in number of bytes;&n; *&n; * Optional attributes:&n; *&n; *  o context - an optional 32 bit integer that will be carried in the&n; *    sending failure notification to the ULP if the transportation of&n; *    this User Message fails.&n; *&n; *  o stream id - to indicate which stream to send the data on. If not&n; *    specified, stream 0 will be used.&n; *&n; *  o life time - specifies the life time of the user data. The user data&n; *    will not be sent by SCTP after the life time expires. This&n; *    parameter can be used to avoid efforts to transmit stale&n; *    user messages. SCTP notifies the ULP if the data cannot be&n; *    initiated to transport (i.e. sent to the destination via SCTP&squot;s&n; *    send primitive) within the life time variable. However, the&n; *    user data will be transmitted if SCTP has attempted to transmit a&n; *    chunk before the life time expired.&n; *&n; *  o destination transport address - specified as one of the destination&n; *    transport addresses of the peer endpoint to which this packet&n; *    should be sent. Whenever possible, SCTP should use this destination&n; *    transport address for sending the packets, instead of the current&n; *    primary path.&n; *&n; *  o unorder flag - this flag, if present, indicates that the user&n; *    would like the data delivered in an unordered fashion to the peer&n; *    (i.e., the U flag is set to 1 on all DATA chunks carrying this&n; *    message).&n; *&n; *  o no-bundle flag - instructs SCTP not to bundle this user data with&n; *    other outbound DATA chunks. SCTP MAY still bundle even when&n; *    this flag is present, when faced with network congestion.&n; *&n; *  o payload protocol-id - A 32 bit unsigned integer that is to be&n; *    passed to the peer indicating the type of payload protocol data&n; *    being transmitted. This value is passed as opaque data by SCTP.&n; *&n; * The return value is the disposition.&n; */
DECL|function|sctp_sf_do_prm_send
id|sctp_disposition_t
id|sctp_sf_do_prm_send
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
r_const
id|sctp_subtype_t
id|type
comma
r_void
op_star
id|arg
comma
id|sctp_cmd_seq_t
op_star
id|commands
)paren
(brace
id|sctp_chunk_t
op_star
id|chunk
op_assign
id|arg
suffix:semicolon
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_REPLY
comma
id|SCTP_CHUNK
c_func
(paren
id|chunk
)paren
)paren
suffix:semicolon
r_return
id|SCTP_DISPOSITION_CONSUME
suffix:semicolon
)brace
multiline_comment|/*&n; * Process the SHUTDOWN primitive.&n; *&n; * Section: 10.1:&n; * C) Shutdown&n; *&n; * Format: SHUTDOWN(association id)&n; * -&gt; result&n; *&n; * Gracefully closes an association. Any locally queued user data&n; * will be delivered to the peer. The association will be terminated only&n; * after the peer acknowledges all the SCTP packets sent.  A success code&n; * will be returned on successful termination of the association. If&n; * attempting to terminate the association results in a failure, an error&n; * code shall be returned.&n; *&n; * Mandatory attributes:&n; *&n; *  o association id - local handle to the SCTP association&n; *&n; * Optional attributes:&n; *&n; * None.&n; *&n; * The return value is the disposition.&n; */
DECL|function|sctp_sf_do_9_2_prm_shutdown
id|sctp_disposition_t
id|sctp_sf_do_9_2_prm_shutdown
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
r_const
id|sctp_subtype_t
id|type
comma
r_void
op_star
id|arg
comma
id|sctp_cmd_seq_t
op_star
id|commands
)paren
(brace
r_int
id|disposition
suffix:semicolon
multiline_comment|/* From 9.2 Shutdown of an Association&n;&t; * Upon receipt of the SHUTDOWN primitive from its upper&n;&t; * layer, the endpoint enters SHUTDOWN-PENDING state and&n;&t; * remains there until all outstanding data has been&n;&t; * acknowledged by its peer. The endpoint accepts no new data&n;&t; * from its upper layer, but retransmits data to the far end&n;&t; * if necessary to fill gaps.&n;&t; */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_NEW_STATE
comma
id|SCTP_STATE
c_func
(paren
id|SCTP_STATE_SHUTDOWN_PENDING
)paren
)paren
suffix:semicolon
multiline_comment|/* sctpimpguide-05 Section 2.12.2&n;&t; * The sender of the SHUTDOWN MAY also start an overall guard timer&n;&t; * &squot;T5-shutdown-guard&squot; to bound the overall time for shutdown sequence.&n;&t; */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_TIMER_START
comma
id|SCTP_TO
c_func
(paren
id|SCTP_EVENT_TIMEOUT_T5_SHUTDOWN_GUARD
)paren
)paren
suffix:semicolon
id|disposition
op_assign
id|SCTP_DISPOSITION_CONSUME
suffix:semicolon
r_if
c_cond
(paren
id|sctp_outq_is_empty
c_func
(paren
op_amp
id|asoc-&gt;outqueue
)paren
)paren
(brace
id|disposition
op_assign
id|sctp_sf_do_9_2_start_shutdown
c_func
(paren
id|ep
comma
id|asoc
comma
id|type
comma
id|arg
comma
id|commands
)paren
suffix:semicolon
)brace
r_return
id|disposition
suffix:semicolon
)brace
multiline_comment|/*&n; * Process the ABORT primitive.&n; *&n; * Section: 10.1:&n; * C) Abort&n; *&n; * Format: Abort(association id [, cause code])&n; * -&gt; result&n; *&n; * Ungracefully closes an association. Any locally queued user data&n; * will be discarded and an ABORT chunk is sent to the peer.  A success code&n; * will be returned on successful abortion of the association. If&n; * attempting to abort the association results in a failure, an error&n; * code shall be returned.&n; *&n; * Mandatory attributes:&n; *&n; *  o association id - local handle to the SCTP association&n; *&n; * Optional attributes:&n; *&n; *  o cause code - reason of the abort to be passed to the peer&n; *&n; * None.&n; *&n; * The return value is the disposition.&n; */
DECL|function|sctp_sf_do_9_1_prm_abort
id|sctp_disposition_t
id|sctp_sf_do_9_1_prm_abort
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
r_const
id|sctp_subtype_t
id|type
comma
r_void
op_star
id|arg
comma
id|sctp_cmd_seq_t
op_star
id|commands
)paren
(brace
multiline_comment|/* From 9.1 Abort of an Association&n;&t; * Upon receipt of the ABORT primitive from its upper&n;&t; * layer, the endpoint enters CLOSED state and&n;&t; * discard all outstanding data has been&n;&t; * acknowledged by its peer. The endpoint accepts no new data&n;&t; * from its upper layer, but retransmits data to the far end&n;&t; * if necessary to fill gaps.&n;&t; */
r_struct
id|msghdr
op_star
id|msg
op_assign
id|arg
suffix:semicolon
id|sctp_chunk_t
op_star
m_abort
suffix:semicolon
id|sctp_disposition_t
id|retval
suffix:semicolon
id|retval
op_assign
id|SCTP_DISPOSITION_CONSUME
suffix:semicolon
multiline_comment|/* Generate ABORT chunk to send the peer.  */
m_abort
op_assign
id|sctp_make_abort_user
c_func
(paren
id|asoc
comma
l_int|NULL
comma
id|msg
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
m_abort
)paren
id|retval
op_assign
id|SCTP_DISPOSITION_NOMEM
suffix:semicolon
r_else
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_REPLY
comma
id|SCTP_CHUNK
c_func
(paren
m_abort
)paren
)paren
suffix:semicolon
multiline_comment|/* Even if we can&squot;t send the ABORT due to low memory delete the&n;&t; * TCB.  This is a departure from our typical NOMEM handling.&n;&t; */
multiline_comment|/* Delete the established association. */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_ASSOC_FAILED
comma
id|SCTP_NULL
c_func
(paren
)paren
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/* We tried an illegal operation on an association which is closed.  */
DECL|function|sctp_sf_error_closed
id|sctp_disposition_t
id|sctp_sf_error_closed
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
r_const
id|sctp_subtype_t
id|type
comma
r_void
op_star
id|arg
comma
id|sctp_cmd_seq_t
op_star
id|commands
)paren
(brace
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_REPORT_ERROR
comma
id|SCTP_ERROR
c_func
(paren
op_minus
id|EINVAL
)paren
)paren
suffix:semicolon
r_return
id|SCTP_DISPOSITION_CONSUME
suffix:semicolon
)brace
multiline_comment|/* We tried an illegal operation on an association which is shutting&n; * down.&n; */
DECL|function|sctp_sf_error_shutdown
id|sctp_disposition_t
id|sctp_sf_error_shutdown
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
r_const
id|sctp_subtype_t
id|type
comma
r_void
op_star
id|arg
comma
id|sctp_cmd_seq_t
op_star
id|commands
)paren
(brace
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_REPORT_ERROR
comma
id|SCTP_ERROR
c_func
(paren
op_minus
id|ESHUTDOWN
)paren
)paren
suffix:semicolon
r_return
id|SCTP_DISPOSITION_CONSUME
suffix:semicolon
)brace
multiline_comment|/*&n; * sctp_cookie_wait_prm_shutdown&n; *&n; * Section: 4 Note: 2&n; * Verification Tag:&n; * Inputs&n; * (endpoint, asoc)&n; *&n; * The RFC does not explicitly address this issue, but is the route through the&n; * state table when someone issues a shutdown while in COOKIE_WAIT state.&n; *&n; * Outputs&n; * (timers)&n; */
DECL|function|sctp_sf_cookie_wait_prm_shutdown
id|sctp_disposition_t
id|sctp_sf_cookie_wait_prm_shutdown
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
r_const
id|sctp_subtype_t
id|type
comma
r_void
op_star
id|arg
comma
id|sctp_cmd_seq_t
op_star
id|commands
)paren
(brace
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_TIMER_STOP
comma
id|SCTP_TO
c_func
(paren
id|SCTP_EVENT_TIMEOUT_T1_INIT
)paren
)paren
suffix:semicolon
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_NEW_STATE
comma
id|SCTP_STATE
c_func
(paren
id|SCTP_STATE_CLOSED
)paren
)paren
suffix:semicolon
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_DELETE_TCB
comma
id|SCTP_NULL
c_func
(paren
)paren
)paren
suffix:semicolon
r_return
id|SCTP_DISPOSITION_DELETE_TCB
suffix:semicolon
)brace
multiline_comment|/*&n; * sctp_cookie_echoed_prm_shutdown&n; *&n; * Section: 4 Note: 2&n; * Verification Tag:&n; * Inputs&n; * (endpoint, asoc)&n; *&n; * The RFC does not explcitly address this issue, but is the route through the&n; * state table when someone issues a shutdown while in COOKIE_ECHOED state.&n; *&n; * Outputs&n; * (timers)&n; */
DECL|function|sctp_sf_cookie_echoed_prm_shutdown
id|sctp_disposition_t
id|sctp_sf_cookie_echoed_prm_shutdown
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
r_const
id|sctp_subtype_t
id|type
comma
r_void
op_star
id|arg
comma
id|sctp_cmd_seq_t
op_star
id|commands
)paren
(brace
multiline_comment|/* There is a single T1 timer, so we should be able to use&n;&t; * common function with the COOKIE-WAIT state.&n;&t; */
r_return
id|sctp_sf_cookie_wait_prm_shutdown
c_func
(paren
id|ep
comma
id|asoc
comma
id|type
comma
id|arg
comma
id|commands
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * sctp_sf_cookie_wait_prm_abort&n; *&n; * Section: 4 Note: 2&n; * Verification Tag:&n; * Inputs&n; * (endpoint, asoc)&n; *&n; * The RFC does not explicitly address this issue, but is the route through the&n; * state table when someone issues an abort while in COOKIE_WAIT state.&n; *&n; * Outputs&n; * (timers)&n; */
DECL|function|sctp_sf_cookie_wait_prm_abort
id|sctp_disposition_t
id|sctp_sf_cookie_wait_prm_abort
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
r_const
id|sctp_subtype_t
id|type
comma
r_void
op_star
id|arg
comma
id|sctp_cmd_seq_t
op_star
id|commands
)paren
(brace
r_struct
id|msghdr
op_star
id|msg
op_assign
id|arg
suffix:semicolon
id|sctp_chunk_t
op_star
m_abort
suffix:semicolon
id|sctp_disposition_t
id|retval
suffix:semicolon
multiline_comment|/* Stop T1-init timer */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_TIMER_STOP
comma
id|SCTP_TO
c_func
(paren
id|SCTP_EVENT_TIMEOUT_T1_INIT
)paren
)paren
suffix:semicolon
id|retval
op_assign
id|SCTP_DISPOSITION_CONSUME
suffix:semicolon
multiline_comment|/* Generate ABORT chunk to send the peer */
m_abort
op_assign
id|sctp_make_abort_user
c_func
(paren
id|asoc
comma
l_int|NULL
comma
id|msg
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
m_abort
)paren
id|retval
op_assign
id|SCTP_DISPOSITION_NOMEM
suffix:semicolon
r_else
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_REPLY
comma
id|SCTP_CHUNK
c_func
(paren
m_abort
)paren
)paren
suffix:semicolon
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_NEW_STATE
comma
id|SCTP_STATE
c_func
(paren
id|SCTP_STATE_CLOSED
)paren
)paren
suffix:semicolon
multiline_comment|/* Even if we can&squot;t send the ABORT due to low memory delete the&n;&t; * TCB.  This is a departure from our typical NOMEM handling.&n;&t; */
multiline_comment|/* Delete the established association. */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_INIT_FAILED
comma
id|SCTP_NULL
c_func
(paren
)paren
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*&n; * sctp_sf_cookie_echoed_prm_abort&n; *&n; * Section: 4 Note: 3&n; * Verification Tag:&n; * Inputs&n; * (endpoint, asoc)&n; *&n; * The RFC does not explcitly address this issue, but is the route through the&n; * state table when someone issues an abort while in COOKIE_ECHOED state.&n; *&n; * Outputs&n; * (timers)&n; */
DECL|function|sctp_sf_cookie_echoed_prm_abort
id|sctp_disposition_t
id|sctp_sf_cookie_echoed_prm_abort
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
r_const
id|sctp_subtype_t
id|type
comma
r_void
op_star
id|arg
comma
id|sctp_cmd_seq_t
op_star
id|commands
)paren
(brace
multiline_comment|/* There is a single T1 timer, so we should be able to use&n;&t; * common function with the COOKIE-WAIT state.&n;&t; */
r_return
id|sctp_sf_cookie_wait_prm_abort
c_func
(paren
id|ep
comma
id|asoc
comma
id|type
comma
id|arg
comma
id|commands
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * sctp_sf_shutdown_pending_prm_abort&n; *&n; * Inputs&n; * (endpoint, asoc)&n; *&n; * The RFC does not explicitly address this issue, but is the route through the&n; * state table when someone issues an abort while in SHUTDOWN-PENDING state.&n; *&n; * Outputs&n; * (timers)&n; */
DECL|function|sctp_sf_shutdown_pending_prm_abort
id|sctp_disposition_t
id|sctp_sf_shutdown_pending_prm_abort
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
r_const
id|sctp_subtype_t
id|type
comma
r_void
op_star
id|arg
comma
id|sctp_cmd_seq_t
op_star
id|commands
)paren
(brace
multiline_comment|/* Stop the T5-shutdown guard timer.  */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_TIMER_STOP
comma
id|SCTP_TO
c_func
(paren
id|SCTP_EVENT_TIMEOUT_T5_SHUTDOWN_GUARD
)paren
)paren
suffix:semicolon
r_return
id|sctp_sf_do_9_1_prm_abort
c_func
(paren
id|ep
comma
id|asoc
comma
id|type
comma
id|arg
comma
id|commands
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * sctp_sf_shutdown_sent_prm_abort&n; *&n; * Inputs&n; * (endpoint, asoc)&n; *&n; * The RFC does not explicitly address this issue, but is the route through the&n; * state table when someone issues an abort while in SHUTDOWN-SENT state.&n; *&n; * Outputs&n; * (timers)&n; */
DECL|function|sctp_sf_shutdown_sent_prm_abort
id|sctp_disposition_t
id|sctp_sf_shutdown_sent_prm_abort
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
r_const
id|sctp_subtype_t
id|type
comma
r_void
op_star
id|arg
comma
id|sctp_cmd_seq_t
op_star
id|commands
)paren
(brace
multiline_comment|/* Stop the T2-shutdown timer.  */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_TIMER_STOP
comma
id|SCTP_TO
c_func
(paren
id|SCTP_EVENT_TIMEOUT_T2_SHUTDOWN
)paren
)paren
suffix:semicolon
multiline_comment|/* Stop the T5-shutdown guard timer.  */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_TIMER_STOP
comma
id|SCTP_TO
c_func
(paren
id|SCTP_EVENT_TIMEOUT_T5_SHUTDOWN_GUARD
)paren
)paren
suffix:semicolon
r_return
id|sctp_sf_do_9_1_prm_abort
c_func
(paren
id|ep
comma
id|asoc
comma
id|type
comma
id|arg
comma
id|commands
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * sctp_sf_cookie_echoed_prm_abort&n; *&n; * Inputs&n; * (endpoint, asoc)&n; *&n; * The RFC does not explcitly address this issue, but is the route through the&n; * state table when someone issues an abort while in COOKIE_ECHOED state.&n; *&n; * Outputs&n; * (timers)&n; */
DECL|function|sctp_sf_shutdown_ack_sent_prm_abort
id|sctp_disposition_t
id|sctp_sf_shutdown_ack_sent_prm_abort
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
r_const
id|sctp_subtype_t
id|type
comma
r_void
op_star
id|arg
comma
id|sctp_cmd_seq_t
op_star
id|commands
)paren
(brace
multiline_comment|/* The same T2 timer, so we should be able to use&n;&t; * common function with the SHUTDOWN-SENT state.&n;&t; */
r_return
id|sctp_sf_shutdown_sent_prm_abort
c_func
(paren
id|ep
comma
id|asoc
comma
id|type
comma
id|arg
comma
id|commands
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Process the REQUESTHEARTBEAT primitive&n; *&n; * 10.1 ULP-to-SCTP&n; * J) Request Heartbeat&n; *&n; * Format: REQUESTHEARTBEAT(association id, destination transport address)&n; *&n; * -&gt; result&n; *&n; * Instructs the local endpoint to perform a HeartBeat on the specified&n; * destination transport address of the given association. The returned&n; * result should indicate whether the transmission of the HEARTBEAT&n; * chunk to the destination address is successful.&n; *&n; * Mandatory attributes:&n; *&n; * o association id - local handle to the SCTP association&n; *&n; * o destination transport address - the transport address of the&n; *   asociation on which a heartbeat should be issued.&n; */
DECL|function|sctp_sf_do_prm_requestheartbeat
id|sctp_disposition_t
id|sctp_sf_do_prm_requestheartbeat
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
r_const
id|sctp_subtype_t
id|type
comma
r_void
op_star
id|arg
comma
id|sctp_cmd_seq_t
op_star
id|commands
)paren
(brace
r_return
id|sctp_sf_heartbeat
c_func
(paren
id|ep
comma
id|asoc
comma
id|type
comma
(paren
r_struct
id|sctp_transport
op_star
)paren
id|arg
comma
id|commands
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Ignore the primitive event&n; *&n; * The return value is the disposition of the primitive.&n; */
DECL|function|sctp_sf_ignore_primitive
id|sctp_disposition_t
id|sctp_sf_ignore_primitive
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
r_const
id|sctp_subtype_t
id|type
comma
r_void
op_star
id|arg
comma
id|sctp_cmd_seq_t
op_star
id|commands
)paren
(brace
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;Primitive type %d is ignored.&bslash;n&quot;
comma
id|type.primitive
)paren
suffix:semicolon
r_return
id|SCTP_DISPOSITION_DISCARD
suffix:semicolon
)brace
multiline_comment|/***************************************************************************&n; * These are the state functions for the OTHER events.&n; ***************************************************************************/
multiline_comment|/*&n; * Start the shutdown negotiation.&n; *&n; * From Section 9.2:&n; * Once all its outstanding data has been acknowledged, the endpoint&n; * shall send a SHUTDOWN chunk to its peer including in the Cumulative&n; * TSN Ack field the last sequential TSN it has received from the peer.&n; * It shall then start the T2-shutdown timer and enter the SHUTDOWN-SENT&n; * state. If the timer expires, the endpoint must re-send the SHUTDOWN&n; * with the updated last sequential TSN received from its peer.&n; *&n; * The return value is the disposition.&n; */
DECL|function|sctp_sf_do_9_2_start_shutdown
id|sctp_disposition_t
id|sctp_sf_do_9_2_start_shutdown
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
r_const
id|sctp_subtype_t
id|type
comma
r_void
op_star
id|arg
comma
id|sctp_cmd_seq_t
op_star
id|commands
)paren
(brace
id|sctp_chunk_t
op_star
id|reply
suffix:semicolon
multiline_comment|/* Once all its outstanding data has been acknowledged, the&n;&t; * endpoint shall send a SHUTDOWN chunk to its peer including&n;&t; * in the Cumulative TSN Ack field the last sequential TSN it&n;&t; * has received from the peer.&n;&t; */
id|reply
op_assign
id|sctp_make_shutdown
c_func
(paren
id|asoc
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|reply
)paren
r_goto
id|nomem
suffix:semicolon
multiline_comment|/* Set the transport for the SHUTDOWN chunk and the timeout for the&n;&t; * T2-shutdown timer.&n;&t; */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_SETUP_T2
comma
id|SCTP_CHUNK
c_func
(paren
id|reply
)paren
)paren
suffix:semicolon
multiline_comment|/* It shall then start the T2-shutdown timer */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_TIMER_START
comma
id|SCTP_TO
c_func
(paren
id|SCTP_EVENT_TIMEOUT_T2_SHUTDOWN
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|asoc-&gt;autoclose
)paren
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_TIMER_STOP
comma
id|SCTP_TO
c_func
(paren
id|SCTP_EVENT_TIMEOUT_AUTOCLOSE
)paren
)paren
suffix:semicolon
multiline_comment|/* and enter the SHUTDOWN-SENT state.  */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_NEW_STATE
comma
id|SCTP_STATE
c_func
(paren
id|SCTP_STATE_SHUTDOWN_SENT
)paren
)paren
suffix:semicolon
multiline_comment|/* sctp-implguide 2.10 Issues with Heartbeating and failover&n;&t; *&n;&t; * HEARTBEAT ... is discontinued after sending either SHUTDOWN&n;         * or SHUTDOWN-ACK.&n;&t; */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_HB_TIMERS_STOP
comma
id|SCTP_NULL
c_func
(paren
)paren
)paren
suffix:semicolon
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_REPLY
comma
id|SCTP_CHUNK
c_func
(paren
id|reply
)paren
)paren
suffix:semicolon
r_return
id|SCTP_DISPOSITION_CONSUME
suffix:semicolon
id|nomem
suffix:colon
r_return
id|SCTP_DISPOSITION_NOMEM
suffix:semicolon
)brace
multiline_comment|/*&n; * Generate a SHUTDOWN ACK now that everything is SACK&squot;d.&n; *&n; * From Section 9.2:&n; *&n; * If it has no more outstanding DATA chunks, the SHUTDOWN receiver&n; * shall send a SHUTDOWN ACK and start a T2-shutdown timer of its own,&n; * entering the SHUTDOWN-ACK-SENT state. If the timer expires, the&n; * endpoint must re-send the SHUTDOWN ACK.&n; *&n; * The return value is the disposition.&n; */
DECL|function|sctp_sf_do_9_2_shutdown_ack
id|sctp_disposition_t
id|sctp_sf_do_9_2_shutdown_ack
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
r_const
id|sctp_subtype_t
id|type
comma
r_void
op_star
id|arg
comma
id|sctp_cmd_seq_t
op_star
id|commands
)paren
(brace
id|sctp_chunk_t
op_star
id|chunk
op_assign
(paren
id|sctp_chunk_t
op_star
)paren
id|arg
suffix:semicolon
id|sctp_chunk_t
op_star
id|reply
suffix:semicolon
multiline_comment|/* If it has no more outstanding DATA chunks, the SHUTDOWN receiver&n;&t; * shall send a SHUTDOWN ACK ...&n;&t; */
id|reply
op_assign
id|sctp_make_shutdown_ack
c_func
(paren
id|asoc
comma
id|chunk
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|reply
)paren
r_goto
id|nomem
suffix:semicolon
multiline_comment|/* Set the transport for the SHUTDOWN ACK chunk and the timeout for&n;&t; * the T2-shutdown timer.&n;&t; */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_SETUP_T2
comma
id|SCTP_CHUNK
c_func
(paren
id|reply
)paren
)paren
suffix:semicolon
multiline_comment|/* and start/restart a T2-shutdown timer of its own, */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_TIMER_RESTART
comma
id|SCTP_TO
c_func
(paren
id|SCTP_EVENT_TIMEOUT_T2_SHUTDOWN
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|asoc-&gt;autoclose
)paren
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_TIMER_STOP
comma
id|SCTP_TO
c_func
(paren
id|SCTP_EVENT_TIMEOUT_AUTOCLOSE
)paren
)paren
suffix:semicolon
multiline_comment|/* Enter the SHUTDOWN-ACK-SENT state.  */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_NEW_STATE
comma
id|SCTP_STATE
c_func
(paren
id|SCTP_STATE_SHUTDOWN_ACK_SENT
)paren
)paren
suffix:semicolon
multiline_comment|/* sctp-implguide 2.10 Issues with Heartbeating and failover&n;&t; *&n;&t; * HEARTBEAT ... is discontinued after sending either SHUTDOWN&n;         * or SHUTDOWN-ACK.&n;&t; */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_HB_TIMERS_STOP
comma
id|SCTP_NULL
c_func
(paren
)paren
)paren
suffix:semicolon
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_REPLY
comma
id|SCTP_CHUNK
c_func
(paren
id|reply
)paren
)paren
suffix:semicolon
r_return
id|SCTP_DISPOSITION_CONSUME
suffix:semicolon
id|nomem
suffix:colon
r_return
id|SCTP_DISPOSITION_NOMEM
suffix:semicolon
)brace
multiline_comment|/*&n; * Ignore the event defined as other&n; *&n; * The return value is the disposition of the event.&n; */
DECL|function|sctp_sf_ignore_other
id|sctp_disposition_t
id|sctp_sf_ignore_other
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
r_const
id|sctp_subtype_t
id|type
comma
r_void
op_star
id|arg
comma
id|sctp_cmd_seq_t
op_star
id|commands
)paren
(brace
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;The event other type %d is ignored&bslash;n&quot;
comma
id|type.other
)paren
suffix:semicolon
r_return
id|SCTP_DISPOSITION_DISCARD
suffix:semicolon
)brace
multiline_comment|/************************************************************&n; * These are the state functions for handling timeout events.&n; ************************************************************/
multiline_comment|/*&n; * RTX Timeout&n; *&n; * Section: 6.3.3 Handle T3-rtx Expiration&n; *&n; * Whenever the retransmission timer T3-rtx expires for a destination&n; * address, do the following:&n; * [See below]&n; *&n; * The return value is the disposition of the chunk.&n; */
DECL|function|sctp_sf_do_6_3_3_rtx
id|sctp_disposition_t
id|sctp_sf_do_6_3_3_rtx
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
r_const
id|sctp_subtype_t
id|type
comma
r_void
op_star
id|arg
comma
id|sctp_cmd_seq_t
op_star
id|commands
)paren
(brace
r_struct
id|sctp_transport
op_star
id|transport
op_assign
id|arg
suffix:semicolon
r_if
c_cond
(paren
id|asoc-&gt;overall_error_count
op_ge
id|asoc-&gt;overall_error_threshold
)paren
(brace
multiline_comment|/* CMD_ASSOC_FAILED calls CMD_DELETE_TCB. */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_ASSOC_FAILED
comma
id|SCTP_NULL
c_func
(paren
)paren
)paren
suffix:semicolon
r_return
id|SCTP_DISPOSITION_DELETE_TCB
suffix:semicolon
)brace
multiline_comment|/* E1) For the destination address for which the timer&n;&t; * expires, adjust its ssthresh with rules defined in Section&n;&t; * 7.2.3 and set the cwnd &lt;- MTU.&n;&t; */
multiline_comment|/* E2) For the destination address for which the timer&n;&t; * expires, set RTO &lt;- RTO * 2 (&quot;back off the timer&quot;).  The&n;&t; * maximum value discussed in rule C7 above (RTO.max) may be&n;&t; * used to provide an upper bound to this doubling operation.&n;&t; */
multiline_comment|/* E3) Determine how many of the earliest (i.e., lowest TSN)&n;&t; * outstanding DATA chunks for the address for which the&n;&t; * T3-rtx has expired will fit into a single packet, subject&n;&t; * to the MTU constraint for the path corresponding to the&n;&t; * destination transport address to which the retransmission&n;&t; * is being sent (this may be different from the address for&n;&t; * which the timer expires [see Section 6.4]).  Call this&n;&t; * value K. Bundle and retransmit those K DATA chunks in a&n;&t; * single packet to the destination endpoint.&n;&t; *&n;&t; * Note: Any DATA chunks that were sent to the address for&n;&t; * which the T3-rtx timer expired but did not fit in one MTU&n;&t; * (rule E3 above), should be marked for retransmission and&n;&t; * sent as soon as cwnd allows (normally when a SACK arrives).&n;&t; */
multiline_comment|/* NB: Rules E4 and F1 are implicit in R1.  */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_RETRAN
comma
id|SCTP_TRANSPORT
c_func
(paren
id|transport
)paren
)paren
suffix:semicolon
multiline_comment|/* Do some failure management (Section 8.2). */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_STRIKE
comma
id|SCTP_TRANSPORT
c_func
(paren
id|transport
)paren
)paren
suffix:semicolon
r_return
id|SCTP_DISPOSITION_CONSUME
suffix:semicolon
)brace
multiline_comment|/*&n; * Generate delayed SACK on timeout&n; *&n; * Section: 6.2  Acknowledgement on Reception of DATA Chunks&n; *&n; * The guidelines on delayed acknowledgement algorithm specified in&n; * Section 4.2 of [RFC2581] SHOULD be followed.  Specifically, an&n; * acknowledgement SHOULD be generated for at least every second packet&n; * (not every second DATA chunk) received, and SHOULD be generated&n; * within 200 ms of the arrival of any unacknowledged DATA chunk.  In&n; * some situations it may be beneficial for an SCTP transmitter to be&n; * more conservative than the algorithms detailed in this document&n; * allow. However, an SCTP transmitter MUST NOT be more aggressive than&n; * the following algorithms allow.&n; */
DECL|function|sctp_sf_do_6_2_sack
id|sctp_disposition_t
id|sctp_sf_do_6_2_sack
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
r_const
id|sctp_subtype_t
id|type
comma
r_void
op_star
id|arg
comma
id|sctp_cmd_seq_t
op_star
id|commands
)paren
(brace
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_GEN_SACK
comma
id|SCTP_FORCE
c_func
(paren
)paren
)paren
suffix:semicolon
r_return
id|SCTP_DISPOSITION_CONSUME
suffix:semicolon
)brace
multiline_comment|/*&n; * sctp_sf_t1_timer_expire&n; *&n; * Section: 4 Note: 2&n; * Verification Tag:&n; * Inputs&n; * (endpoint, asoc)&n; *&n; *  RFC 2960 Section 4 Notes&n; *  2) If the T1-init timer expires, the endpoint MUST retransmit INIT&n; *     and re-start the T1-init timer without changing state.  This MUST&n; *     be repeated up to &squot;Max.Init.Retransmits&squot; times.  After that, the&n; *     endpoint MUST abort the initialization process and report the&n; *     error to SCTP user.&n; *&n; *   3) If the T1-cookie timer expires, the endpoint MUST retransmit&n; *     COOKIE ECHO and re-start the T1-cookie timer without changing&n; *     state.  This MUST be repeated up to &squot;Max.Init.Retransmits&squot; times.&n; *     After that, the endpoint MUST abort the initialization process and&n; *     report the error to SCTP user.&n; *&n; * Outputs&n; * (timers, events)&n; *&n; */
DECL|function|sctp_sf_t1_timer_expire
id|sctp_disposition_t
id|sctp_sf_t1_timer_expire
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
r_const
id|sctp_subtype_t
id|type
comma
r_void
op_star
id|arg
comma
id|sctp_cmd_seq_t
op_star
id|commands
)paren
(brace
id|sctp_chunk_t
op_star
id|repl
suffix:semicolon
id|sctp_bind_addr_t
op_star
id|bp
suffix:semicolon
id|sctp_event_timeout_t
id|timer
op_assign
(paren
id|sctp_event_timeout_t
)paren
id|arg
suffix:semicolon
r_int
id|timeout
suffix:semicolon
r_int
id|attempts
suffix:semicolon
id|timeout
op_assign
id|asoc-&gt;timeouts
(braket
id|timer
)braket
suffix:semicolon
id|attempts
op_assign
id|asoc-&gt;counters
(braket
id|SCTP_COUNTER_INIT_ERROR
)braket
op_plus
l_int|1
suffix:semicolon
id|repl
op_assign
l_int|NULL
suffix:semicolon
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;Timer T1 expired.&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|timeout
OL
id|asoc-&gt;max_init_timeo
)paren
op_logical_and
(paren
id|attempts
OL
id|asoc-&gt;max_init_attempts
)paren
)paren
(brace
r_switch
c_cond
(paren
id|timer
)paren
(brace
r_case
id|SCTP_EVENT_TIMEOUT_T1_INIT
suffix:colon
id|bp
op_assign
(paren
id|sctp_bind_addr_t
op_star
)paren
op_amp
id|asoc-&gt;base.bind_addr
suffix:semicolon
id|repl
op_assign
id|sctp_make_init
c_func
(paren
id|asoc
comma
id|bp
comma
id|GFP_ATOMIC
comma
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_EVENT_TIMEOUT_T1_COOKIE
suffix:colon
id|repl
op_assign
id|sctp_make_cookie_echo
c_func
(paren
id|asoc
comma
l_int|NULL
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|repl
)paren
r_goto
id|nomem
suffix:semicolon
multiline_comment|/* Issue a sideeffect to do the needed accounting. */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_INIT_RESTART
comma
id|SCTP_TO
c_func
(paren
id|timer
)paren
)paren
suffix:semicolon
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_REPLY
comma
id|SCTP_CHUNK
c_func
(paren
id|repl
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_INIT_FAILED
comma
id|SCTP_NULL
c_func
(paren
)paren
)paren
suffix:semicolon
r_return
id|SCTP_DISPOSITION_DELETE_TCB
suffix:semicolon
)brace
r_return
id|SCTP_DISPOSITION_CONSUME
suffix:semicolon
id|nomem
suffix:colon
r_return
id|SCTP_DISPOSITION_NOMEM
suffix:semicolon
)brace
multiline_comment|/* RFC2960 9.2 If the timer expires, the endpoint must re-send the SHUTDOWN&n; * with the updated last sequential TSN received from its peer.&n; *&n; * An endpoint should limit the number of retransmissions of the&n; * SHUTDOWN chunk to the protocol parameter &squot;Association.Max.Retrans&squot;.&n; * If this threshold is exceeded the endpoint should destroy the TCB and&n; * MUST report the peer endpoint unreachable to the upper layer (and&n; * thus the association enters the CLOSED state).  The reception of any&n; * packet from its peer (i.e. as the peer sends all of its queued DATA&n; * chunks) should clear the endpoint&squot;s retransmission count and restart&n; * the T2-Shutdown timer,  giving its peer ample opportunity to transmit&n; * all of its queued DATA chunks that have not yet been sent.&n; */
DECL|function|sctp_sf_t2_timer_expire
id|sctp_disposition_t
id|sctp_sf_t2_timer_expire
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
r_const
id|sctp_subtype_t
id|type
comma
r_void
op_star
id|arg
comma
id|sctp_cmd_seq_t
op_star
id|commands
)paren
(brace
id|sctp_chunk_t
op_star
id|reply
op_assign
l_int|NULL
suffix:semicolon
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;Timer T2 expired.&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|asoc-&gt;overall_error_count
op_ge
id|asoc-&gt;overall_error_threshold
)paren
(brace
multiline_comment|/* Note:  CMD_ASSOC_FAILED calls CMD_DELETE_TCB. */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_ASSOC_FAILED
comma
id|SCTP_NULL
c_func
(paren
)paren
)paren
suffix:semicolon
r_return
id|SCTP_DISPOSITION_DELETE_TCB
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|asoc-&gt;state
)paren
(brace
r_case
id|SCTP_STATE_SHUTDOWN_SENT
suffix:colon
id|reply
op_assign
id|sctp_make_shutdown
c_func
(paren
id|asoc
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_STATE_SHUTDOWN_ACK_SENT
suffix:colon
id|reply
op_assign
id|sctp_make_shutdown_ack
c_func
(paren
id|asoc
comma
l_int|NULL
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|reply
)paren
r_goto
id|nomem
suffix:semicolon
multiline_comment|/* Do some failure management (Section 8.2). */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_STRIKE
comma
id|SCTP_TRANSPORT
c_func
(paren
id|asoc-&gt;shutdown_last_sent_to
)paren
)paren
suffix:semicolon
multiline_comment|/* Set the transport for the SHUTDOWN/ACK chunk and the timeout for&n;&t; * the T2-shutdown timer.&n;&t; */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_SETUP_T2
comma
id|SCTP_CHUNK
c_func
(paren
id|reply
)paren
)paren
suffix:semicolon
multiline_comment|/* Restart the T2-shutdown timer.  */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_TIMER_RESTART
comma
id|SCTP_TO
c_func
(paren
id|SCTP_EVENT_TIMEOUT_T2_SHUTDOWN
)paren
)paren
suffix:semicolon
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_REPLY
comma
id|SCTP_CHUNK
c_func
(paren
id|reply
)paren
)paren
suffix:semicolon
r_return
id|SCTP_DISPOSITION_CONSUME
suffix:semicolon
id|nomem
suffix:colon
r_return
id|SCTP_DISPOSITION_NOMEM
suffix:semicolon
)brace
multiline_comment|/* sctpimpguide-05 Section 2.12.2&n; * The sender of the SHUTDOWN MAY also start an overall guard timer&n; * &squot;T5-shutdown-guard&squot; to bound the overall time for shutdown sequence.&n; * At the expiration of this timer the sender SHOULD abort the association&n; * by sending an ABORT chunk.&n; */
DECL|function|sctp_sf_t5_timer_expire
id|sctp_disposition_t
id|sctp_sf_t5_timer_expire
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
r_const
id|sctp_subtype_t
id|type
comma
r_void
op_star
id|arg
comma
id|sctp_cmd_seq_t
op_star
id|commands
)paren
(brace
id|sctp_chunk_t
op_star
id|reply
op_assign
l_int|NULL
suffix:semicolon
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;Timer T5 expired.&bslash;n&quot;
)paren
suffix:semicolon
id|reply
op_assign
id|sctp_make_abort
c_func
(paren
id|asoc
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|reply
)paren
r_goto
id|nomem
suffix:semicolon
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_REPLY
comma
id|SCTP_CHUNK
c_func
(paren
id|reply
)paren
)paren
suffix:semicolon
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_ASSOC_FAILED
comma
id|SCTP_NULL
c_func
(paren
)paren
)paren
suffix:semicolon
r_return
id|SCTP_DISPOSITION_DELETE_TCB
suffix:semicolon
id|nomem
suffix:colon
r_return
id|SCTP_DISPOSITION_NOMEM
suffix:semicolon
)brace
multiline_comment|/* Handle expiration of AUTOCLOSE timer.  When the autoclose timer expires,&n; * the association is automatically closed by starting the shutdown process.&n; * The work that needs to be done is same as when SHUTDOWN is initiated by&n; * the user.  So this routine looks same as sctp_sf_do_9_2_prm_shutdown().&n; */
DECL|function|sctp_sf_autoclose_timer_expire
id|sctp_disposition_t
id|sctp_sf_autoclose_timer_expire
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
r_const
id|sctp_subtype_t
id|type
comma
r_void
op_star
id|arg
comma
id|sctp_cmd_seq_t
op_star
id|commands
)paren
(brace
r_int
id|disposition
suffix:semicolon
multiline_comment|/* From 9.2 Shutdown of an Association&n;&t; * Upon receipt of the SHUTDOWN primitive from its upper&n;&t; * layer, the endpoint enters SHUTDOWN-PENDING state and&n;&t; * remains there until all outstanding data has been&n;&t; * acknowledged by its peer. The endpoint accepts no new data&n;&t; * from its upper layer, but retransmits data to the far end&n;&t; * if necessary to fill gaps.&n;&t; */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_NEW_STATE
comma
id|SCTP_STATE
c_func
(paren
id|SCTP_STATE_SHUTDOWN_PENDING
)paren
)paren
suffix:semicolon
multiline_comment|/* sctpimpguide-05 Section 2.12.2&n;&t; * The sender of the SHUTDOWN MAY also start an overall guard timer&n;&t; * &squot;T5-shutdown-guard&squot; to bound the overall time for shutdown sequence.&n; &t; */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_TIMER_START
comma
id|SCTP_TO
c_func
(paren
id|SCTP_EVENT_TIMEOUT_T5_SHUTDOWN_GUARD
)paren
)paren
suffix:semicolon
id|disposition
op_assign
id|SCTP_DISPOSITION_CONSUME
suffix:semicolon
r_if
c_cond
(paren
id|sctp_outq_is_empty
c_func
(paren
op_amp
id|asoc-&gt;outqueue
)paren
)paren
(brace
id|disposition
op_assign
id|sctp_sf_do_9_2_start_shutdown
c_func
(paren
id|ep
comma
id|asoc
comma
id|type
comma
id|arg
comma
id|commands
)paren
suffix:semicolon
)brace
r_return
id|disposition
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************&n; * These are sa state functions which could apply to all types of events.&n; ****************************************************************************/
multiline_comment|/*&n; * This table entry is not implemented.&n; *&n; * Inputs&n; * (endpoint, asoc, chunk)&n; *&n; * The return value is the disposition of the chunk.&n; */
DECL|function|sctp_sf_not_impl
id|sctp_disposition_t
id|sctp_sf_not_impl
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
r_const
id|sctp_subtype_t
id|type
comma
r_void
op_star
id|arg
comma
id|sctp_cmd_seq_t
op_star
id|commands
)paren
(brace
r_return
id|SCTP_DISPOSITION_NOT_IMPL
suffix:semicolon
)brace
multiline_comment|/*&n; * This table entry represents a bug.&n; *&n; * Inputs&n; * (endpoint, asoc, chunk)&n; *&n; * The return value is the disposition of the chunk.&n; */
DECL|function|sctp_sf_bug
id|sctp_disposition_t
id|sctp_sf_bug
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
r_const
id|sctp_subtype_t
id|type
comma
r_void
op_star
id|arg
comma
id|sctp_cmd_seq_t
op_star
id|commands
)paren
(brace
r_return
id|SCTP_DISPOSITION_BUG
suffix:semicolon
)brace
multiline_comment|/*&n; * This table entry represents the firing of a timer in the wrong state.&n; * Since timer deletion cannot be guaranteed a timer &squot;may&squot; end up firing&n; * when the association is in the wrong state.   This event should&n; * be ignored, so as to prevent any rearming of the timer.&n; *&n; * Inputs&n; * (endpoint, asoc, chunk)&n; *&n; * The return value is the disposition of the chunk.&n; */
DECL|function|sctp_sf_timer_ignore
id|sctp_disposition_t
id|sctp_sf_timer_ignore
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
r_const
id|sctp_subtype_t
id|type
comma
r_void
op_star
id|arg
comma
id|sctp_cmd_seq_t
op_star
id|commands
)paren
(brace
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;Timer %d ignored.&bslash;n&quot;
comma
id|type.chunk
)paren
suffix:semicolon
r_return
id|SCTP_DISPOSITION_CONSUME
suffix:semicolon
)brace
multiline_comment|/********************************************************************&n; * 2nd Level Abstractions&n; ********************************************************************/
multiline_comment|/* Pull the SACK chunk based on the SACK header. */
DECL|function|sctp_sm_pull_sack
id|sctp_sackhdr_t
op_star
id|sctp_sm_pull_sack
c_func
(paren
id|sctp_chunk_t
op_star
id|chunk
)paren
(brace
id|sctp_sackhdr_t
op_star
id|sack
suffix:semicolon
id|__u16
id|num_blocks
suffix:semicolon
id|__u16
id|num_dup_tsns
suffix:semicolon
id|sack
op_assign
(paren
id|sctp_sackhdr_t
op_star
)paren
id|chunk-&gt;skb-&gt;data
suffix:semicolon
id|skb_pull
c_func
(paren
id|chunk-&gt;skb
comma
r_sizeof
(paren
id|sctp_sackhdr_t
)paren
)paren
suffix:semicolon
id|num_blocks
op_assign
id|ntohs
c_func
(paren
id|sack-&gt;num_gap_ack_blocks
)paren
suffix:semicolon
id|num_dup_tsns
op_assign
id|ntohs
c_func
(paren
id|sack-&gt;num_dup_tsns
)paren
suffix:semicolon
id|skb_pull
c_func
(paren
id|chunk-&gt;skb
comma
(paren
id|num_blocks
op_plus
id|num_dup_tsns
)paren
op_star
r_sizeof
(paren
id|__u32
)paren
)paren
suffix:semicolon
r_return
id|sack
suffix:semicolon
)brace
multiline_comment|/* Create an ABORT packet to be sent as a response, with the specified&n; * error causes.&n; */
DECL|function|sctp_abort_pkt_new
id|sctp_packet_t
op_star
id|sctp_abort_pkt_new
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
id|sctp_chunk_t
op_star
id|chunk
comma
r_const
r_void
op_star
id|payload
comma
r_int
id|paylen
)paren
(brace
id|sctp_packet_t
op_star
id|packet
suffix:semicolon
id|sctp_chunk_t
op_star
m_abort
suffix:semicolon
id|packet
op_assign
id|sctp_ootb_pkt_new
c_func
(paren
id|asoc
comma
id|chunk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|packet
)paren
(brace
multiline_comment|/* Make an ABORT.&n;&t;&t; * The T bit will be set if the asoc is NULL.&n;&t;&t; */
m_abort
op_assign
id|sctp_make_abort
c_func
(paren
id|asoc
comma
id|chunk
comma
id|paylen
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
m_abort
)paren
(brace
id|sctp_ootb_pkt_free
c_func
(paren
id|packet
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Add specified error causes, i.e., payload, to the&n;&t;&t; * end of the chunk.&n;&t;&t; */
id|sctp_addto_chunk
c_func
(paren
m_abort
comma
id|paylen
comma
id|payload
)paren
suffix:semicolon
multiline_comment|/* Set the skb to the belonging sock for accounting.  */
m_abort
op_member_access_from_pointer
id|skb-&gt;sk
op_assign
id|ep-&gt;base.sk
suffix:semicolon
id|sctp_packet_append_chunk
c_func
(paren
id|packet
comma
m_abort
)paren
suffix:semicolon
)brace
r_return
id|packet
suffix:semicolon
)brace
multiline_comment|/* Allocate a packet for responding in the OOTB conditions.  */
DECL|function|sctp_ootb_pkt_new
id|sctp_packet_t
op_star
id|sctp_ootb_pkt_new
c_func
(paren
r_const
id|sctp_association_t
op_star
id|asoc
comma
r_const
id|sctp_chunk_t
op_star
id|chunk
)paren
(brace
id|sctp_packet_t
op_star
id|packet
suffix:semicolon
r_struct
id|sctp_transport
op_star
id|transport
suffix:semicolon
id|__u16
id|sport
suffix:semicolon
id|__u16
id|dport
suffix:semicolon
id|__u32
id|vtag
suffix:semicolon
multiline_comment|/* Get the source and destination port from the inbound packet.  */
id|sport
op_assign
id|ntohs
c_func
(paren
id|chunk-&gt;sctp_hdr-&gt;dest
)paren
suffix:semicolon
id|dport
op_assign
id|ntohs
c_func
(paren
id|chunk-&gt;sctp_hdr-&gt;source
)paren
suffix:semicolon
multiline_comment|/* The V-tag is going to be the same as the inbound packet if no&n;&t; * association exists, otherwise, use the peer&squot;s vtag.&n;&t; */
r_if
c_cond
(paren
id|asoc
)paren
(brace
id|vtag
op_assign
id|asoc-&gt;peer.i.init_tag
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Special case the INIT as there is no vtag yet. */
r_if
c_cond
(paren
id|SCTP_CID_INIT
op_eq
id|chunk-&gt;chunk_hdr-&gt;type
)paren
(brace
id|sctp_init_chunk_t
op_star
id|init
suffix:semicolon
id|init
op_assign
(paren
id|sctp_init_chunk_t
op_star
)paren
id|chunk-&gt;chunk_hdr
suffix:semicolon
id|vtag
op_assign
id|ntohl
c_func
(paren
id|init-&gt;init_hdr.init_tag
)paren
suffix:semicolon
)brace
r_else
(brace
id|vtag
op_assign
id|ntohl
c_func
(paren
id|chunk-&gt;sctp_hdr-&gt;vtag
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Make a transport for the bucket, Eliza... */
id|transport
op_assign
id|sctp_transport_new
c_func
(paren
id|sctp_source
c_func
(paren
id|chunk
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|transport
)paren
r_goto
id|nomem
suffix:semicolon
multiline_comment|/* Allocate a new packet for sending the response. */
id|packet
op_assign
id|t_new
c_func
(paren
id|sctp_packet_t
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|packet
)paren
r_goto
id|nomem_packet
suffix:semicolon
multiline_comment|/* Cache a route for the transport with the chunk&squot;s destination as&n;&t; * the source address.&n;&t; */
id|sctp_transport_route
c_func
(paren
id|transport
comma
(paren
r_union
id|sctp_addr
op_star
)paren
op_amp
id|chunk-&gt;dest
comma
id|sctp_sk
c_func
(paren
id|sctp_get_ctl_sock
c_func
(paren
)paren
)paren
)paren
suffix:semicolon
id|packet
op_assign
id|sctp_packet_init
c_func
(paren
id|packet
comma
id|transport
comma
id|sport
comma
id|dport
)paren
suffix:semicolon
id|packet
op_assign
id|sctp_packet_config
c_func
(paren
id|packet
comma
id|vtag
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
r_return
id|packet
suffix:semicolon
id|nomem_packet
suffix:colon
id|sctp_transport_free
c_func
(paren
id|transport
)paren
suffix:semicolon
id|nomem
suffix:colon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Free the packet allocated earlier for responding in the OOTB condition.  */
DECL|function|sctp_ootb_pkt_free
r_void
id|sctp_ootb_pkt_free
c_func
(paren
id|sctp_packet_t
op_star
id|packet
)paren
(brace
id|sctp_transport_free
c_func
(paren
id|packet-&gt;transport
)paren
suffix:semicolon
id|sctp_packet_free
c_func
(paren
id|packet
)paren
suffix:semicolon
)brace
multiline_comment|/* Send a stale cookie error when a invalid COOKIE ECHO chunk is found  */
DECL|function|sctp_send_stale_cookie_err
r_void
id|sctp_send_stale_cookie_err
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
id|sctp_association_t
op_star
id|asoc
comma
r_const
id|sctp_chunk_t
op_star
id|chunk
comma
id|sctp_cmd_seq_t
op_star
id|commands
comma
id|sctp_chunk_t
op_star
id|err_chunk
)paren
(brace
id|sctp_packet_t
op_star
id|packet
suffix:semicolon
r_if
c_cond
(paren
id|err_chunk
)paren
(brace
id|packet
op_assign
id|sctp_ootb_pkt_new
c_func
(paren
id|asoc
comma
id|chunk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|packet
)paren
(brace
multiline_comment|/* Set the skb to the belonging sock for accounting. */
id|err_chunk-&gt;skb-&gt;sk
op_assign
id|ep-&gt;base.sk
suffix:semicolon
id|sctp_packet_append_chunk
c_func
(paren
id|packet
comma
id|err_chunk
)paren
suffix:semicolon
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_SEND_PKT
comma
id|SCTP_PACKET
c_func
(paren
id|packet
)paren
)paren
suffix:semicolon
)brace
r_else
id|sctp_free_chunk
(paren
id|err_chunk
)paren
suffix:semicolon
)brace
)brace
eof
