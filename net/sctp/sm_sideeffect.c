multiline_comment|/* SCTP kernel reference Implementation&n; * (C) Copyright IBM Corp. 2001, 2004&n; * Copyright (c) 1999 Cisco, Inc.&n; * Copyright (c) 1999-2001 Motorola, Inc.&n; *&n; * This file is part of the SCTP kernel reference Implementation&n; *&n; * These functions work with the state functions in sctp_sm_statefuns.c&n; * to implement that state operations.  These functions implement the&n; * steps which require modifying existing data structures.&n; *&n; * The SCTP reference implementation is free software;&n; * you can redistribute it and/or modify it under the terms of&n; * the GNU General Public License as published by&n; * the Free Software Foundation; either version 2, or (at your option)&n; * any later version.&n; *&n; * The SCTP reference implementation is distributed in the hope that it&n; * will be useful, but WITHOUT ANY WARRANTY; without even the implied&n; *                 ************************&n; * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&n; * See the GNU General Public License for more details.&n; *&n; * You should have received a copy of the GNU General Public License&n; * along with GNU CC; see the file COPYING.  If not, write to&n; * the Free Software Foundation, 59 Temple Place - Suite 330,&n; * Boston, MA 02111-1307, USA.&n; *&n; * Please send any bug reports or fixes you make to the&n; * email address(es):&n; *    lksctp developers &lt;lksctp-developers@lists.sourceforge.net&gt;&n; *&n; * Or submit a bug report through the following website:&n; *    http://www.sf.net/projects/lksctp&n; *&n; * Written or modified by:&n; *    La Monte H.P. Yarroll &lt;piggy@acm.org&gt;&n; *    Karl Knutson          &lt;karl@athena.chicago.il.us&gt;&n; *    Jon Grimm             &lt;jgrimm@austin.ibm.com&gt;&n; *    Hui Huang&t;&t;    &lt;hui.huang@nokia.com&gt;&n; *    Dajiang Zhang&t;    &lt;dajiang.zhang@nokia.com&gt;&n; *    Daisy Chang&t;    &lt;daisyc@us.ibm.com&gt;&n; *    Sridhar Samudrala&t;    &lt;sri@us.ibm.com&gt;&n; *    Ardelle Fan&t;    &lt;ardelle.fan@intel.com&gt;&n; *&n; * Any bugs reported given to us we will try to fix... any fixes shared will&n; * be incorporated into the next SCTP release.&n; */
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/socket.h&gt;
macro_line|#include &lt;linux/ip.h&gt;
macro_line|#include &lt;net/sock.h&gt;
macro_line|#include &lt;net/sctp/sctp.h&gt;
macro_line|#include &lt;net/sctp/sm.h&gt;
r_static
r_int
id|sctp_cmd_interpreter
c_func
(paren
id|sctp_event_t
id|event_type
comma
id|sctp_subtype_t
id|subtype
comma
id|sctp_state_t
id|state
comma
r_struct
id|sctp_endpoint
op_star
id|ep
comma
r_struct
id|sctp_association
op_star
id|asoc
comma
r_void
op_star
id|event_arg
comma
id|sctp_disposition_t
id|status
comma
id|sctp_cmd_seq_t
op_star
id|commands
comma
r_int
id|gfp
)paren
suffix:semicolon
r_static
r_int
id|sctp_side_effects
c_func
(paren
id|sctp_event_t
id|event_type
comma
id|sctp_subtype_t
id|subtype
comma
id|sctp_state_t
id|state
comma
r_struct
id|sctp_endpoint
op_star
id|ep
comma
r_struct
id|sctp_association
op_star
id|asoc
comma
r_void
op_star
id|event_arg
comma
id|sctp_disposition_t
id|status
comma
id|sctp_cmd_seq_t
op_star
id|commands
comma
r_int
id|gfp
)paren
suffix:semicolon
multiline_comment|/********************************************************************&n; * Helper functions&n; ********************************************************************/
multiline_comment|/* A helper function for delayed processing of INET ECN CE bit. */
DECL|function|sctp_do_ecn_ce_work
r_static
r_void
id|sctp_do_ecn_ce_work
c_func
(paren
r_struct
id|sctp_association
op_star
id|asoc
comma
id|__u32
id|lowest_tsn
)paren
(brace
multiline_comment|/* Save the TSN away for comparison when we receive CWR */
id|asoc-&gt;last_ecne_tsn
op_assign
id|lowest_tsn
suffix:semicolon
id|asoc-&gt;need_ecne
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Helper function for delayed processing of SCTP ECNE chunk.  */
multiline_comment|/* RFC 2960 Appendix A&n; *&n; * RFC 2481 details a specific bit for a sender to send in&n; * the header of its next outbound TCP segment to indicate to&n; * its peer that it has reduced its congestion window.  This&n; * is termed the CWR bit.  For SCTP the same indication is made&n; * by including the CWR chunk.  This chunk contains one data&n; * element, i.e. the TSN number that was sent in the ECNE chunk.&n; * This element represents the lowest TSN number in the datagram&n; * that was originally marked with the CE bit.&n; */
DECL|function|sctp_do_ecn_ecne_work
r_static
r_struct
id|sctp_chunk
op_star
id|sctp_do_ecn_ecne_work
c_func
(paren
r_struct
id|sctp_association
op_star
id|asoc
comma
id|__u32
id|lowest_tsn
comma
r_struct
id|sctp_chunk
op_star
id|chunk
)paren
(brace
r_struct
id|sctp_chunk
op_star
id|repl
suffix:semicolon
multiline_comment|/* Our previously transmitted packet ran into some congestion&n;&t; * so we should take action by reducing cwnd and ssthresh&n;&t; * and then ACK our peer that we we&squot;ve done so by&n;&t; * sending a CWR.&n;&t; */
multiline_comment|/* First, try to determine if we want to actually lower&n;&t; * our cwnd variables.  Only lower them if the ECNE looks more&n;&t; * recent than the last response.&n;&t; */
r_if
c_cond
(paren
id|TSN_lt
c_func
(paren
id|asoc-&gt;last_cwr_tsn
comma
id|lowest_tsn
)paren
)paren
(brace
r_struct
id|sctp_transport
op_star
id|transport
suffix:semicolon
multiline_comment|/* Find which transport&squot;s congestion variables&n;&t;&t; * need to be adjusted.&n;&t;&t; */
id|transport
op_assign
id|sctp_assoc_lookup_tsn
c_func
(paren
id|asoc
comma
id|lowest_tsn
)paren
suffix:semicolon
multiline_comment|/* Update the congestion variables. */
r_if
c_cond
(paren
id|transport
)paren
id|sctp_transport_lower_cwnd
c_func
(paren
id|transport
comma
id|SCTP_LOWER_CWND_ECNE
)paren
suffix:semicolon
id|asoc-&gt;last_cwr_tsn
op_assign
id|lowest_tsn
suffix:semicolon
)brace
multiline_comment|/* Always try to quiet the other end.  In case of lost CWR,&n;&t; * resend last_cwr_tsn.&n;&t; */
id|repl
op_assign
id|sctp_make_cwr
c_func
(paren
id|asoc
comma
id|asoc-&gt;last_cwr_tsn
comma
id|chunk
)paren
suffix:semicolon
multiline_comment|/* If we run out of memory, it will look like a lost CWR.  We&squot;ll&n;&t; * get back in sync eventually.&n;&t; */
r_return
id|repl
suffix:semicolon
)brace
multiline_comment|/* Helper function to do delayed processing of ECN CWR chunk.  */
DECL|function|sctp_do_ecn_cwr_work
r_static
r_void
id|sctp_do_ecn_cwr_work
c_func
(paren
r_struct
id|sctp_association
op_star
id|asoc
comma
id|__u32
id|lowest_tsn
)paren
(brace
multiline_comment|/* Turn off ECNE getting auto-prepended to every outgoing&n;&t; * packet&n;&t; */
id|asoc-&gt;need_ecne
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Generate SACK if necessary.  We call this at the end of a packet.  */
DECL|function|sctp_gen_sack
r_static
r_int
id|sctp_gen_sack
c_func
(paren
r_struct
id|sctp_association
op_star
id|asoc
comma
r_int
id|force
comma
id|sctp_cmd_seq_t
op_star
id|commands
)paren
(brace
id|__u32
id|ctsn
comma
id|max_tsn_seen
suffix:semicolon
r_struct
id|sctp_chunk
op_star
id|sack
suffix:semicolon
r_int
id|error
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|force
)paren
id|asoc-&gt;peer.sack_needed
op_assign
l_int|1
suffix:semicolon
id|ctsn
op_assign
id|sctp_tsnmap_get_ctsn
c_func
(paren
op_amp
id|asoc-&gt;peer.tsn_map
)paren
suffix:semicolon
id|max_tsn_seen
op_assign
id|sctp_tsnmap_get_max_tsn_seen
c_func
(paren
op_amp
id|asoc-&gt;peer.tsn_map
)paren
suffix:semicolon
multiline_comment|/* From 12.2 Parameters necessary per association (i.e. the TCB):&n;&t; *&n;&t; * Ack State : This flag indicates if the next received packet&n;&t; * &t;     : is to be responded to with a SACK. ...&n;&t; *&t;     : When DATA chunks are out of order, SACK&squot;s&n;&t; *           : are not delayed (see Section 6).&n;&t; *&n;&t; * [This is actually not mentioned in Section 6, but we&n;&t; * implement it here anyway. --piggy]&n;&t; */
r_if
c_cond
(paren
id|max_tsn_seen
op_ne
id|ctsn
)paren
id|asoc-&gt;peer.sack_needed
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* From 6.2  Acknowledgement on Reception of DATA Chunks:&n;&t; *&n;&t; * Section 4.2 of [RFC2581] SHOULD be followed. Specifically,&n;&t; * an acknowledgement SHOULD be generated for at least every&n;&t; * second packet (not every second DATA chunk) received, and&n;&t; * SHOULD be generated within 200 ms of the arrival of any&n;&t; * unacknowledged DATA chunk. ...&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|asoc-&gt;peer.sack_needed
)paren
(brace
multiline_comment|/* We will need a SACK for the next packet.  */
id|asoc-&gt;peer.sack_needed
op_assign
l_int|1
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|asoc-&gt;a_rwnd
OG
id|asoc-&gt;rwnd
)paren
id|asoc-&gt;a_rwnd
op_assign
id|asoc-&gt;rwnd
suffix:semicolon
id|sack
op_assign
id|sctp_make_sack
c_func
(paren
id|asoc
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sack
)paren
r_goto
id|nomem
suffix:semicolon
id|asoc-&gt;peer.sack_needed
op_assign
l_int|0
suffix:semicolon
id|error
op_assign
id|sctp_outq_tail
c_func
(paren
op_amp
id|asoc-&gt;outqueue
comma
id|sack
)paren
suffix:semicolon
multiline_comment|/* Stop the SACK timer.  */
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_TIMER_STOP
comma
id|SCTP_TO
c_func
(paren
id|SCTP_EVENT_TIMEOUT_SACK
)paren
)paren
suffix:semicolon
)brace
id|out
suffix:colon
r_return
id|error
suffix:semicolon
id|nomem
suffix:colon
id|error
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/* When the T3-RTX timer expires, it calls this function to create the&n; * relevant state machine event.&n; */
DECL|function|sctp_generate_t3_rtx_event
r_void
id|sctp_generate_t3_rtx_event
c_func
(paren
r_int
r_int
id|peer
)paren
(brace
r_int
id|error
suffix:semicolon
r_struct
id|sctp_transport
op_star
id|transport
op_assign
(paren
r_struct
id|sctp_transport
op_star
)paren
id|peer
suffix:semicolon
r_struct
id|sctp_association
op_star
id|asoc
op_assign
id|transport-&gt;asoc
suffix:semicolon
multiline_comment|/* Check whether a task is in the sock.  */
id|sctp_bh_lock_sock
c_func
(paren
id|asoc-&gt;base.sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sock_owned_by_user
c_func
(paren
id|asoc-&gt;base.sk
)paren
)paren
(brace
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;%s:Sock is busy.&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
multiline_comment|/* Try again later.  */
r_if
c_cond
(paren
op_logical_neg
id|mod_timer
c_func
(paren
op_amp
id|transport-&gt;T3_rtx_timer
comma
id|jiffies
op_plus
(paren
id|HZ
op_div
l_int|20
)paren
)paren
)paren
id|sctp_transport_hold
c_func
(paren
id|transport
)paren
suffix:semicolon
r_goto
id|out_unlock
suffix:semicolon
)brace
multiline_comment|/* Is this transport really dead and just waiting around for&n;&t; * the timer to let go of the reference?&n;&t; */
r_if
c_cond
(paren
id|transport-&gt;dead
)paren
r_goto
id|out_unlock
suffix:semicolon
multiline_comment|/* Run through the state machine.  */
id|error
op_assign
id|sctp_do_sm
c_func
(paren
id|SCTP_EVENT_T_TIMEOUT
comma
id|SCTP_ST_TIMEOUT
c_func
(paren
id|SCTP_EVENT_TIMEOUT_T3_RTX
)paren
comma
id|asoc-&gt;state
comma
id|asoc-&gt;ep
comma
id|asoc
comma
id|transport
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
id|asoc-&gt;base.sk-&gt;sk_err
op_assign
op_minus
id|error
suffix:semicolon
id|out_unlock
suffix:colon
id|sctp_bh_unlock_sock
c_func
(paren
id|asoc-&gt;base.sk
)paren
suffix:semicolon
id|sctp_transport_put
c_func
(paren
id|transport
)paren
suffix:semicolon
)brace
multiline_comment|/* This is a sa interface for producing timeout events.  It works&n; * for timeouts which use the association as their parameter.&n; */
DECL|function|sctp_generate_timeout_event
r_static
r_void
id|sctp_generate_timeout_event
c_func
(paren
r_struct
id|sctp_association
op_star
id|asoc
comma
id|sctp_event_timeout_t
id|timeout_type
)paren
(brace
r_int
id|error
op_assign
l_int|0
suffix:semicolon
id|sctp_bh_lock_sock
c_func
(paren
id|asoc-&gt;base.sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sock_owned_by_user
c_func
(paren
id|asoc-&gt;base.sk
)paren
)paren
(brace
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;%s:Sock is busy: timer %d&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|timeout_type
)paren
suffix:semicolon
multiline_comment|/* Try again later.  */
r_if
c_cond
(paren
op_logical_neg
id|mod_timer
c_func
(paren
op_amp
id|asoc-&gt;timers
(braket
id|timeout_type
)braket
comma
id|jiffies
op_plus
(paren
id|HZ
op_div
l_int|20
)paren
)paren
)paren
id|sctp_association_hold
c_func
(paren
id|asoc
)paren
suffix:semicolon
r_goto
id|out_unlock
suffix:semicolon
)brace
multiline_comment|/* Is this association really dead and just waiting around for&n;&t; * the timer to let go of the reference?&n;&t; */
r_if
c_cond
(paren
id|asoc-&gt;base.dead
)paren
r_goto
id|out_unlock
suffix:semicolon
multiline_comment|/* Run through the state machine.  */
id|error
op_assign
id|sctp_do_sm
c_func
(paren
id|SCTP_EVENT_T_TIMEOUT
comma
id|SCTP_ST_TIMEOUT
c_func
(paren
id|timeout_type
)paren
comma
id|asoc-&gt;state
comma
id|asoc-&gt;ep
comma
id|asoc
comma
(paren
r_void
op_star
)paren
id|timeout_type
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
id|asoc-&gt;base.sk-&gt;sk_err
op_assign
op_minus
id|error
suffix:semicolon
id|out_unlock
suffix:colon
id|sctp_bh_unlock_sock
c_func
(paren
id|asoc-&gt;base.sk
)paren
suffix:semicolon
id|sctp_association_put
c_func
(paren
id|asoc
)paren
suffix:semicolon
)brace
DECL|function|sctp_generate_t1_cookie_event
r_static
r_void
id|sctp_generate_t1_cookie_event
c_func
(paren
r_int
r_int
id|data
)paren
(brace
r_struct
id|sctp_association
op_star
id|asoc
op_assign
(paren
r_struct
id|sctp_association
op_star
)paren
id|data
suffix:semicolon
id|sctp_generate_timeout_event
c_func
(paren
id|asoc
comma
id|SCTP_EVENT_TIMEOUT_T1_COOKIE
)paren
suffix:semicolon
)brace
DECL|function|sctp_generate_t1_init_event
r_static
r_void
id|sctp_generate_t1_init_event
c_func
(paren
r_int
r_int
id|data
)paren
(brace
r_struct
id|sctp_association
op_star
id|asoc
op_assign
(paren
r_struct
id|sctp_association
op_star
)paren
id|data
suffix:semicolon
id|sctp_generate_timeout_event
c_func
(paren
id|asoc
comma
id|SCTP_EVENT_TIMEOUT_T1_INIT
)paren
suffix:semicolon
)brace
DECL|function|sctp_generate_t2_shutdown_event
r_static
r_void
id|sctp_generate_t2_shutdown_event
c_func
(paren
r_int
r_int
id|data
)paren
(brace
r_struct
id|sctp_association
op_star
id|asoc
op_assign
(paren
r_struct
id|sctp_association
op_star
)paren
id|data
suffix:semicolon
id|sctp_generate_timeout_event
c_func
(paren
id|asoc
comma
id|SCTP_EVENT_TIMEOUT_T2_SHUTDOWN
)paren
suffix:semicolon
)brace
DECL|function|sctp_generate_t4_rto_event
r_static
r_void
id|sctp_generate_t4_rto_event
c_func
(paren
r_int
r_int
id|data
)paren
(brace
r_struct
id|sctp_association
op_star
id|asoc
op_assign
(paren
r_struct
id|sctp_association
op_star
)paren
id|data
suffix:semicolon
id|sctp_generate_timeout_event
c_func
(paren
id|asoc
comma
id|SCTP_EVENT_TIMEOUT_T4_RTO
)paren
suffix:semicolon
)brace
DECL|function|sctp_generate_t5_shutdown_guard_event
r_static
r_void
id|sctp_generate_t5_shutdown_guard_event
c_func
(paren
r_int
r_int
id|data
)paren
(brace
r_struct
id|sctp_association
op_star
id|asoc
op_assign
(paren
r_struct
id|sctp_association
op_star
)paren
id|data
suffix:semicolon
id|sctp_generate_timeout_event
c_func
(paren
id|asoc
comma
id|SCTP_EVENT_TIMEOUT_T5_SHUTDOWN_GUARD
)paren
suffix:semicolon
)brace
multiline_comment|/* sctp_generate_t5_shutdown_guard_event() */
DECL|function|sctp_generate_autoclose_event
r_static
r_void
id|sctp_generate_autoclose_event
c_func
(paren
r_int
r_int
id|data
)paren
(brace
r_struct
id|sctp_association
op_star
id|asoc
op_assign
(paren
r_struct
id|sctp_association
op_star
)paren
id|data
suffix:semicolon
id|sctp_generate_timeout_event
c_func
(paren
id|asoc
comma
id|SCTP_EVENT_TIMEOUT_AUTOCLOSE
)paren
suffix:semicolon
)brace
multiline_comment|/* Generate a heart beat event.  If the sock is busy, reschedule.   Make&n; * sure that the transport is still valid.&n; */
DECL|function|sctp_generate_heartbeat_event
r_void
id|sctp_generate_heartbeat_event
c_func
(paren
r_int
r_int
id|data
)paren
(brace
r_int
id|error
op_assign
l_int|0
suffix:semicolon
r_struct
id|sctp_transport
op_star
id|transport
op_assign
(paren
r_struct
id|sctp_transport
op_star
)paren
id|data
suffix:semicolon
r_struct
id|sctp_association
op_star
id|asoc
op_assign
id|transport-&gt;asoc
suffix:semicolon
id|sctp_bh_lock_sock
c_func
(paren
id|asoc-&gt;base.sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sock_owned_by_user
c_func
(paren
id|asoc-&gt;base.sk
)paren
)paren
(brace
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;%s:Sock is busy.&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
multiline_comment|/* Try again later.  */
r_if
c_cond
(paren
op_logical_neg
id|mod_timer
c_func
(paren
op_amp
id|transport-&gt;hb_timer
comma
id|jiffies
op_plus
(paren
id|HZ
op_div
l_int|20
)paren
)paren
)paren
id|sctp_transport_hold
c_func
(paren
id|transport
)paren
suffix:semicolon
r_goto
id|out_unlock
suffix:semicolon
)brace
multiline_comment|/* Is this structure just waiting around for us to actually&n;&t; * get destroyed?&n;&t; */
r_if
c_cond
(paren
id|transport-&gt;dead
)paren
r_goto
id|out_unlock
suffix:semicolon
id|error
op_assign
id|sctp_do_sm
c_func
(paren
id|SCTP_EVENT_T_TIMEOUT
comma
id|SCTP_ST_TIMEOUT
c_func
(paren
id|SCTP_EVENT_TIMEOUT_HEARTBEAT
)paren
comma
id|asoc-&gt;state
comma
id|asoc-&gt;ep
comma
id|asoc
comma
id|transport
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
id|asoc-&gt;base.sk-&gt;sk_err
op_assign
op_minus
id|error
suffix:semicolon
id|out_unlock
suffix:colon
id|sctp_bh_unlock_sock
c_func
(paren
id|asoc-&gt;base.sk
)paren
suffix:semicolon
id|sctp_transport_put
c_func
(paren
id|transport
)paren
suffix:semicolon
)brace
multiline_comment|/* Inject a SACK Timeout event into the state machine.  */
DECL|function|sctp_generate_sack_event
r_static
r_void
id|sctp_generate_sack_event
c_func
(paren
r_int
r_int
id|data
)paren
(brace
r_struct
id|sctp_association
op_star
id|asoc
op_assign
(paren
r_struct
id|sctp_association
op_star
)paren
id|data
suffix:semicolon
id|sctp_generate_timeout_event
c_func
(paren
id|asoc
comma
id|SCTP_EVENT_TIMEOUT_SACK
)paren
suffix:semicolon
)brace
DECL|variable|sctp_timer_events
id|sctp_timer_event_t
op_star
id|sctp_timer_events
(braket
id|SCTP_NUM_TIMEOUT_TYPES
)braket
op_assign
(brace
l_int|NULL
comma
id|sctp_generate_t1_cookie_event
comma
id|sctp_generate_t1_init_event
comma
id|sctp_generate_t2_shutdown_event
comma
l_int|NULL
comma
id|sctp_generate_t4_rto_event
comma
id|sctp_generate_t5_shutdown_guard_event
comma
id|sctp_generate_heartbeat_event
comma
id|sctp_generate_sack_event
comma
id|sctp_generate_autoclose_event
comma
)brace
suffix:semicolon
multiline_comment|/* RFC 2960 8.2 Path Failure Detection&n; *&n; * When its peer endpoint is multi-homed, an endpoint should keep a&n; * error counter for each of the destination transport addresses of the&n; * peer endpoint.&n; *&n; * Each time the T3-rtx timer expires on any address, or when a&n; * HEARTBEAT sent to an idle address is not acknowledged within a RTO,&n; * the error counter of that destination address will be incremented.&n; * When the value in the error counter exceeds the protocol parameter&n; * &squot;Path.Max.Retrans&squot; of that destination address, the endpoint should&n; * mark the destination transport address as inactive, and a&n; * notification SHOULD be sent to the upper layer.&n; *&n; */
DECL|function|sctp_do_8_2_transport_strike
r_static
r_void
id|sctp_do_8_2_transport_strike
c_func
(paren
r_struct
id|sctp_association
op_star
id|asoc
comma
r_struct
id|sctp_transport
op_star
id|transport
)paren
(brace
multiline_comment|/* The check for association&squot;s overall error counter exceeding the&n;&t; * threshold is done in the state function.&n;&t; */
id|asoc-&gt;overall_error_count
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|transport-&gt;active
op_logical_and
(paren
id|transport-&gt;error_count
op_increment
op_ge
id|transport-&gt;max_retrans
)paren
)paren
(brace
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;transport_strike: transport &quot;
l_string|&quot;IP:%d.%d.%d.%d failed.&bslash;n&quot;
comma
id|NIPQUAD
c_func
(paren
id|transport-&gt;ipaddr.v4.sin_addr
)paren
)paren
suffix:semicolon
id|sctp_assoc_control_transport
c_func
(paren
id|asoc
comma
id|transport
comma
id|SCTP_TRANSPORT_DOWN
comma
id|SCTP_FAILED_THRESHOLD
)paren
suffix:semicolon
)brace
multiline_comment|/* E2) For the destination address for which the timer&n;&t; * expires, set RTO &lt;- RTO * 2 (&quot;back off the timer&quot;).  The&n;&t; * maximum value discussed in rule C7 above (RTO.max) may be&n;&t; * used to provide an upper bound to this doubling operation.&n;&t; */
id|transport-&gt;rto
op_assign
id|min
c_func
(paren
(paren
id|transport-&gt;rto
op_star
l_int|2
)paren
comma
id|transport-&gt;asoc-&gt;rto_max
)paren
suffix:semicolon
)brace
multiline_comment|/* Worker routine to handle INIT command failure.  */
DECL|function|sctp_cmd_init_failed
r_static
r_void
id|sctp_cmd_init_failed
c_func
(paren
id|sctp_cmd_seq_t
op_star
id|commands
comma
r_struct
id|sctp_association
op_star
id|asoc
comma
r_int
id|error
)paren
(brace
r_struct
id|sctp_ulpevent
op_star
id|event
suffix:semicolon
id|event
op_assign
id|sctp_ulpevent_make_assoc_change
c_func
(paren
id|asoc
comma
l_int|0
comma
id|SCTP_CANT_STR_ASSOC
comma
(paren
id|__u16
)paren
id|error
comma
l_int|0
comma
l_int|0
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|event
)paren
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_EVENT_ULP
comma
id|SCTP_ULPEVENT
c_func
(paren
id|event
)paren
)paren
suffix:semicolon
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_NEW_STATE
comma
id|SCTP_STATE
c_func
(paren
id|SCTP_STATE_CLOSED
)paren
)paren
suffix:semicolon
multiline_comment|/* SEND_FAILED sent later when cleaning up the association. */
id|asoc-&gt;outqueue.error
op_assign
id|error
suffix:semicolon
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_DELETE_TCB
comma
id|SCTP_NULL
c_func
(paren
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Worker routine to handle SCTP_CMD_ASSOC_FAILED.  */
DECL|function|sctp_cmd_assoc_failed
r_static
r_void
id|sctp_cmd_assoc_failed
c_func
(paren
id|sctp_cmd_seq_t
op_star
id|commands
comma
r_struct
id|sctp_association
op_star
id|asoc
comma
id|sctp_event_t
id|event_type
comma
id|sctp_subtype_t
id|subtype
comma
r_struct
id|sctp_chunk
op_star
id|chunk
comma
r_int
id|error
)paren
(brace
r_struct
id|sctp_ulpevent
op_star
id|event
suffix:semicolon
multiline_comment|/* Cancel any partial delivery in progress. */
id|sctp_ulpq_abort_pd
c_func
(paren
op_amp
id|asoc-&gt;ulpq
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
id|event
op_assign
id|sctp_ulpevent_make_assoc_change
c_func
(paren
id|asoc
comma
l_int|0
comma
id|SCTP_COMM_LOST
comma
(paren
id|__u16
)paren
id|error
comma
l_int|0
comma
l_int|0
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|event
)paren
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_EVENT_ULP
comma
id|SCTP_ULPEVENT
c_func
(paren
id|event
)paren
)paren
suffix:semicolon
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_NEW_STATE
comma
id|SCTP_STATE
c_func
(paren
id|SCTP_STATE_CLOSED
)paren
)paren
suffix:semicolon
multiline_comment|/* Set sk_err to ECONNRESET on a 1-1 style socket. */
r_if
c_cond
(paren
op_logical_neg
id|sctp_style
c_func
(paren
id|asoc-&gt;base.sk
comma
id|UDP
)paren
)paren
id|asoc-&gt;base.sk-&gt;sk_err
op_assign
id|ECONNRESET
suffix:semicolon
multiline_comment|/* SEND_FAILED sent later when cleaning up the association. */
id|asoc-&gt;outqueue.error
op_assign
id|error
suffix:semicolon
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_DELETE_TCB
comma
id|SCTP_NULL
c_func
(paren
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Process an init chunk (may be real INIT/INIT-ACK or an embedded INIT&n; * inside the cookie.  In reality, this is only used for INIT-ACK processing&n; * since all other cases use &quot;temporary&quot; associations and can do all&n; * their work in statefuns directly.&n; */
DECL|function|sctp_cmd_process_init
r_static
r_int
id|sctp_cmd_process_init
c_func
(paren
id|sctp_cmd_seq_t
op_star
id|commands
comma
r_struct
id|sctp_association
op_star
id|asoc
comma
r_struct
id|sctp_chunk
op_star
id|chunk
comma
id|sctp_init_chunk_t
op_star
id|peer_init
comma
r_int
id|gfp
)paren
(brace
r_int
id|error
suffix:semicolon
multiline_comment|/* We only process the init as a sideeffect in a single&n;&t; * case.   This is when we process the INIT-ACK.   If we&n;&t; * fail during INIT processing (due to malloc problems),&n;&t; * just return the error and stop processing the stack.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|sctp_process_init
c_func
(paren
id|asoc
comma
id|chunk-&gt;chunk_hdr-&gt;type
comma
id|sctp_source
c_func
(paren
id|chunk
)paren
comma
id|peer_init
comma
id|gfp
)paren
)paren
id|error
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_else
id|error
op_assign
l_int|0
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/* Helper function to break out starting up of heartbeat timers.  */
DECL|function|sctp_cmd_hb_timers_start
r_static
r_void
id|sctp_cmd_hb_timers_start
c_func
(paren
id|sctp_cmd_seq_t
op_star
id|cmds
comma
r_struct
id|sctp_association
op_star
id|asoc
)paren
(brace
r_struct
id|sctp_transport
op_star
id|t
suffix:semicolon
r_struct
id|list_head
op_star
id|pos
suffix:semicolon
multiline_comment|/* Start a heartbeat timer for each transport on the association.&n;&t; * hold a reference on the transport to make sure none of&n;&t; * the needed data structures go away.&n;&t; */
id|list_for_each
c_func
(paren
id|pos
comma
op_amp
id|asoc-&gt;peer.transport_addr_list
)paren
(brace
id|t
op_assign
id|list_entry
c_func
(paren
id|pos
comma
r_struct
id|sctp_transport
comma
id|transports
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mod_timer
c_func
(paren
op_amp
id|t-&gt;hb_timer
comma
id|sctp_transport_timeout
c_func
(paren
id|t
)paren
)paren
)paren
id|sctp_transport_hold
c_func
(paren
id|t
)paren
suffix:semicolon
)brace
)brace
DECL|function|sctp_cmd_hb_timers_stop
r_static
r_void
id|sctp_cmd_hb_timers_stop
c_func
(paren
id|sctp_cmd_seq_t
op_star
id|cmds
comma
r_struct
id|sctp_association
op_star
id|asoc
)paren
(brace
r_struct
id|sctp_transport
op_star
id|t
suffix:semicolon
r_struct
id|list_head
op_star
id|pos
suffix:semicolon
multiline_comment|/* Stop all heartbeat timers. */
id|list_for_each
c_func
(paren
id|pos
comma
op_amp
id|asoc-&gt;peer.transport_addr_list
)paren
(brace
id|t
op_assign
id|list_entry
c_func
(paren
id|pos
comma
r_struct
id|sctp_transport
comma
id|transports
)paren
suffix:semicolon
r_if
c_cond
(paren
id|del_timer
c_func
(paren
op_amp
id|t-&gt;hb_timer
)paren
)paren
id|sctp_transport_put
c_func
(paren
id|t
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Helper function to stop any pending T3-RTX timers */
DECL|function|sctp_cmd_t3_rtx_timers_stop
r_static
r_void
id|sctp_cmd_t3_rtx_timers_stop
c_func
(paren
id|sctp_cmd_seq_t
op_star
id|cmds
comma
r_struct
id|sctp_association
op_star
id|asoc
)paren
(brace
r_struct
id|sctp_transport
op_star
id|t
suffix:semicolon
r_struct
id|list_head
op_star
id|pos
suffix:semicolon
id|list_for_each
c_func
(paren
id|pos
comma
op_amp
id|asoc-&gt;peer.transport_addr_list
)paren
(brace
id|t
op_assign
id|list_entry
c_func
(paren
id|pos
comma
r_struct
id|sctp_transport
comma
id|transports
)paren
suffix:semicolon
r_if
c_cond
(paren
id|timer_pending
c_func
(paren
op_amp
id|t-&gt;T3_rtx_timer
)paren
op_logical_and
id|del_timer
c_func
(paren
op_amp
id|t-&gt;T3_rtx_timer
)paren
)paren
(brace
id|sctp_transport_put
c_func
(paren
id|t
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Helper function to update the heartbeat timer. */
DECL|function|sctp_cmd_hb_timer_update
r_static
r_void
id|sctp_cmd_hb_timer_update
c_func
(paren
id|sctp_cmd_seq_t
op_star
id|cmds
comma
r_struct
id|sctp_association
op_star
id|asoc
comma
r_struct
id|sctp_transport
op_star
id|t
)paren
(brace
multiline_comment|/* Update the heartbeat timer.  */
r_if
c_cond
(paren
op_logical_neg
id|mod_timer
c_func
(paren
op_amp
id|t-&gt;hb_timer
comma
id|sctp_transport_timeout
c_func
(paren
id|t
)paren
)paren
)paren
id|sctp_transport_hold
c_func
(paren
id|t
)paren
suffix:semicolon
)brace
multiline_comment|/* Helper function to handle the reception of an HEARTBEAT ACK.  */
DECL|function|sctp_cmd_transport_on
r_static
r_void
id|sctp_cmd_transport_on
c_func
(paren
id|sctp_cmd_seq_t
op_star
id|cmds
comma
r_struct
id|sctp_association
op_star
id|asoc
comma
r_struct
id|sctp_transport
op_star
id|t
comma
r_struct
id|sctp_chunk
op_star
id|chunk
)paren
(brace
id|sctp_sender_hb_info_t
op_star
id|hbinfo
suffix:semicolon
multiline_comment|/* 8.3 Upon the receipt of the HEARTBEAT ACK, the sender of the&n;&t; * HEARTBEAT should clear the error counter of the destination&n;&t; * transport address to which the HEARTBEAT was sent.&n;&t; * The association&squot;s overall error count is also cleared.&n;&t; */
id|t-&gt;error_count
op_assign
l_int|0
suffix:semicolon
id|t-&gt;asoc-&gt;overall_error_count
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Mark the destination transport address as active if it is not so&n;&t; * marked.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|t-&gt;active
)paren
id|sctp_assoc_control_transport
c_func
(paren
id|asoc
comma
id|t
comma
id|SCTP_TRANSPORT_UP
comma
id|SCTP_HEARTBEAT_SUCCESS
)paren
suffix:semicolon
multiline_comment|/* The receiver of the HEARTBEAT ACK should also perform an&n;&t; * RTT measurement for that destination transport address&n;&t; * using the time value carried in the HEARTBEAT ACK chunk.&n;&t; */
id|hbinfo
op_assign
(paren
id|sctp_sender_hb_info_t
op_star
)paren
id|chunk-&gt;skb-&gt;data
suffix:semicolon
id|sctp_transport_update_rto
c_func
(paren
id|t
comma
(paren
id|jiffies
op_minus
id|hbinfo-&gt;sent_at
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Helper function to do a transport reset at the expiry of the hearbeat&n; * timer.&n; */
DECL|function|sctp_cmd_transport_reset
r_static
r_void
id|sctp_cmd_transport_reset
c_func
(paren
id|sctp_cmd_seq_t
op_star
id|cmds
comma
r_struct
id|sctp_association
op_star
id|asoc
comma
r_struct
id|sctp_transport
op_star
id|t
)paren
(brace
id|sctp_transport_lower_cwnd
c_func
(paren
id|t
comma
id|SCTP_LOWER_CWND_INACTIVE
)paren
suffix:semicolon
multiline_comment|/* Mark one strike against a transport.  */
id|sctp_do_8_2_transport_strike
c_func
(paren
id|asoc
comma
id|t
)paren
suffix:semicolon
)brace
multiline_comment|/* Helper function to process the process SACK command.  */
DECL|function|sctp_cmd_process_sack
r_static
r_int
id|sctp_cmd_process_sack
c_func
(paren
id|sctp_cmd_seq_t
op_star
id|cmds
comma
r_struct
id|sctp_association
op_star
id|asoc
comma
r_struct
id|sctp_sackhdr
op_star
id|sackh
)paren
(brace
r_int
id|err
suffix:semicolon
r_if
c_cond
(paren
id|sctp_outq_sack
c_func
(paren
op_amp
id|asoc-&gt;outqueue
comma
id|sackh
)paren
)paren
(brace
multiline_comment|/* There are no more TSNs awaiting SACK.  */
id|err
op_assign
id|sctp_do_sm
c_func
(paren
id|SCTP_EVENT_T_OTHER
comma
id|SCTP_ST_OTHER
c_func
(paren
id|SCTP_EVENT_NO_PENDING_TSN
)paren
comma
id|asoc-&gt;state
comma
id|asoc-&gt;ep
comma
id|asoc
comma
l_int|NULL
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Windows may have opened, so we need&n;&t;&t; * to check if we have DATA to transmit&n;&t;&t; */
id|err
op_assign
id|sctp_outq_flush
c_func
(paren
op_amp
id|asoc-&gt;outqueue
comma
l_int|0
)paren
suffix:semicolon
)brace
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/* Helper function to set the timeout value for T2-SHUTDOWN timer and to set&n; * the transport for a shutdown chunk.&n; */
DECL|function|sctp_cmd_setup_t2
r_static
r_void
id|sctp_cmd_setup_t2
c_func
(paren
id|sctp_cmd_seq_t
op_star
id|cmds
comma
r_struct
id|sctp_association
op_star
id|asoc
comma
r_struct
id|sctp_chunk
op_star
id|chunk
)paren
(brace
r_struct
id|sctp_transport
op_star
id|t
suffix:semicolon
id|t
op_assign
id|sctp_assoc_choose_shutdown_transport
c_func
(paren
id|asoc
)paren
suffix:semicolon
id|asoc-&gt;shutdown_last_sent_to
op_assign
id|t
suffix:semicolon
id|asoc-&gt;timeouts
(braket
id|SCTP_EVENT_TIMEOUT_T2_SHUTDOWN
)braket
op_assign
id|t-&gt;rto
suffix:semicolon
id|chunk-&gt;transport
op_assign
id|t
suffix:semicolon
)brace
multiline_comment|/* Helper function to change the state of an association. */
DECL|function|sctp_cmd_new_state
r_static
r_void
id|sctp_cmd_new_state
c_func
(paren
id|sctp_cmd_seq_t
op_star
id|cmds
comma
r_struct
id|sctp_association
op_star
id|asoc
comma
id|sctp_state_t
id|state
)paren
(brace
r_struct
id|sock
op_star
id|sk
op_assign
id|asoc-&gt;base.sk
suffix:semicolon
id|asoc-&gt;state
op_assign
id|state
suffix:semicolon
r_if
c_cond
(paren
id|sctp_style
c_func
(paren
id|sk
comma
id|TCP
)paren
)paren
(brace
multiline_comment|/* Change the sk-&gt;sk_state of a TCP-style socket that has &n;&t;&t; * sucessfully completed a connect() call.&n;&t;&t; */
r_if
c_cond
(paren
id|sctp_state
c_func
(paren
id|asoc
comma
id|ESTABLISHED
)paren
op_logical_and
id|sctp_sstate
c_func
(paren
id|sk
comma
id|CLOSED
)paren
)paren
id|sk-&gt;sk_state
op_assign
id|SCTP_SS_ESTABLISHED
suffix:semicolon
multiline_comment|/* Set the RCV_SHUTDOWN flag when a SHUTDOWN is received. */
r_if
c_cond
(paren
id|sctp_state
c_func
(paren
id|asoc
comma
id|SHUTDOWN_RECEIVED
)paren
op_logical_and
id|sctp_sstate
c_func
(paren
id|sk
comma
id|ESTABLISHED
)paren
)paren
id|sk-&gt;sk_shutdown
op_or_assign
id|RCV_SHUTDOWN
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sctp_state
c_func
(paren
id|asoc
comma
id|ESTABLISHED
)paren
op_logical_or
id|sctp_state
c_func
(paren
id|asoc
comma
id|CLOSED
)paren
op_logical_or
id|sctp_state
c_func
(paren
id|asoc
comma
id|SHUTDOWN_RECEIVED
)paren
)paren
(brace
multiline_comment|/* Wake up any processes waiting in the asoc&squot;s wait queue in&n;&t;&t; * sctp_wait_for_connect() or sctp_wait_for_sndbuf().&n;&t; &t; */
r_if
c_cond
(paren
id|waitqueue_active
c_func
(paren
op_amp
id|asoc-&gt;wait
)paren
)paren
id|wake_up_interruptible
c_func
(paren
op_amp
id|asoc-&gt;wait
)paren
suffix:semicolon
multiline_comment|/* Wake up any processes waiting in the sk&squot;s sleep queue of&n;&t;&t; * a TCP-style or UDP-style peeled-off socket in&n;&t;&t; * sctp_wait_for_accept() or sctp_wait_for_packet().&n;&t;&t; * For a UDP-style socket, the waiters are woken up by the&n;&t;&t; * notifications.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|sctp_style
c_func
(paren
id|sk
comma
id|UDP
)paren
)paren
id|sk
op_member_access_from_pointer
id|sk_state_change
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Helper function to delete an association. */
DECL|function|sctp_cmd_delete_tcb
r_static
r_void
id|sctp_cmd_delete_tcb
c_func
(paren
id|sctp_cmd_seq_t
op_star
id|cmds
comma
r_struct
id|sctp_association
op_star
id|asoc
)paren
(brace
r_struct
id|sock
op_star
id|sk
op_assign
id|asoc-&gt;base.sk
suffix:semicolon
multiline_comment|/* If it is a non-temporary association belonging to a TCP-style&n;&t; * listening socket that is not closed, do not free it so that accept() &n;&t; * can pick it up later.&n;&t; */
r_if
c_cond
(paren
id|sctp_style
c_func
(paren
id|sk
comma
id|TCP
)paren
op_logical_and
id|sctp_sstate
c_func
(paren
id|sk
comma
id|LISTENING
)paren
op_logical_and
(paren
op_logical_neg
id|asoc-&gt;temp
)paren
op_logical_and
(paren
id|sk-&gt;sk_shutdown
op_ne
id|SHUTDOWN_MASK
)paren
)paren
r_return
suffix:semicolon
id|sctp_unhash_established
c_func
(paren
id|asoc
)paren
suffix:semicolon
id|sctp_association_free
c_func
(paren
id|asoc
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * ADDIP Section 4.1 ASCONF Chunk Procedures&n; * A4) Start a T-4 RTO timer, using the RTO value of the selected&n; * destination address (we use active path instead of primary path just&n; * because primary path may be inactive. &n; */
DECL|function|sctp_cmd_setup_t4
r_static
r_void
id|sctp_cmd_setup_t4
c_func
(paren
id|sctp_cmd_seq_t
op_star
id|cmds
comma
r_struct
id|sctp_association
op_star
id|asoc
comma
r_struct
id|sctp_chunk
op_star
id|chunk
)paren
(brace
r_struct
id|sctp_transport
op_star
id|t
suffix:semicolon
id|t
op_assign
id|asoc-&gt;peer.active_path
suffix:semicolon
id|asoc-&gt;timeouts
(braket
id|SCTP_EVENT_TIMEOUT_T4_RTO
)braket
op_assign
id|t-&gt;rto
suffix:semicolon
id|chunk-&gt;transport
op_assign
id|t
suffix:semicolon
)brace
multiline_comment|/* Process an incoming Operation Error Chunk. */
DECL|function|sctp_cmd_process_operr
r_static
r_void
id|sctp_cmd_process_operr
c_func
(paren
id|sctp_cmd_seq_t
op_star
id|cmds
comma
r_struct
id|sctp_association
op_star
id|asoc
comma
r_struct
id|sctp_chunk
op_star
id|chunk
)paren
(brace
r_struct
id|sctp_operr_chunk
op_star
id|operr_chunk
suffix:semicolon
r_struct
id|sctp_errhdr
op_star
id|err_hdr
suffix:semicolon
id|operr_chunk
op_assign
(paren
r_struct
id|sctp_operr_chunk
op_star
)paren
id|chunk-&gt;chunk_hdr
suffix:semicolon
id|err_hdr
op_assign
op_amp
id|operr_chunk-&gt;err_hdr
suffix:semicolon
r_switch
c_cond
(paren
id|err_hdr-&gt;cause
)paren
(brace
r_case
id|SCTP_ERROR_UNKNOWN_CHUNK
suffix:colon
(brace
r_struct
id|sctp_chunkhdr
op_star
id|unk_chunk_hdr
suffix:semicolon
id|unk_chunk_hdr
op_assign
(paren
r_struct
id|sctp_chunkhdr
op_star
)paren
id|err_hdr-&gt;variable
suffix:semicolon
r_switch
c_cond
(paren
id|unk_chunk_hdr-&gt;type
)paren
(brace
multiline_comment|/* ADDIP 4.1 A9) If the peer responds to an ASCONF with an&n;&t;&t; * ERROR chunk reporting that it did not recognized the ASCONF&n;&t;&t; * chunk type, the sender of the ASCONF MUST NOT send any&n;&t;&t; * further ASCONF chunks and MUST stop its T-4 timer.&n;&t;&t; */
r_case
id|SCTP_CID_ASCONF
suffix:colon
id|asoc-&gt;peer.asconf_capable
op_assign
l_int|0
suffix:semicolon
id|sctp_add_cmd_sf
c_func
(paren
id|cmds
comma
id|SCTP_CMD_TIMER_STOP
comma
id|SCTP_TO
c_func
(paren
id|SCTP_EVENT_TIMEOUT_T4_RTO
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
r_default
suffix:colon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* Process variable FWDTSN chunk information. */
DECL|function|sctp_cmd_process_fwdtsn
r_static
r_void
id|sctp_cmd_process_fwdtsn
c_func
(paren
r_struct
id|sctp_ulpq
op_star
id|ulpq
comma
r_struct
id|sctp_chunk
op_star
id|chunk
)paren
(brace
r_struct
id|sctp_fwdtsn_skip
op_star
id|skip
suffix:semicolon
multiline_comment|/* Walk through all the skipped SSNs */
id|sctp_walk_fwdtsn
c_func
(paren
id|skip
comma
id|chunk
)paren
(brace
id|sctp_ulpq_skip
c_func
(paren
id|ulpq
comma
id|ntohs
c_func
(paren
id|skip-&gt;stream
)paren
comma
id|ntohs
c_func
(paren
id|skip-&gt;ssn
)paren
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/* Helper function to remove the association non-primary peer &n; * transports.&n; */
DECL|function|sctp_cmd_del_non_primary
r_static
r_void
id|sctp_cmd_del_non_primary
c_func
(paren
r_struct
id|sctp_association
op_star
id|asoc
)paren
(brace
r_struct
id|sctp_transport
op_star
id|t
suffix:semicolon
r_struct
id|list_head
op_star
id|pos
suffix:semicolon
r_struct
id|list_head
op_star
id|temp
suffix:semicolon
id|list_for_each_safe
c_func
(paren
id|pos
comma
id|temp
comma
op_amp
id|asoc-&gt;peer.transport_addr_list
)paren
(brace
id|t
op_assign
id|list_entry
c_func
(paren
id|pos
comma
r_struct
id|sctp_transport
comma
id|transports
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sctp_cmp_addr_exact
c_func
(paren
op_amp
id|t-&gt;ipaddr
comma
op_amp
id|asoc-&gt;peer.primary_addr
)paren
)paren
(brace
id|sctp_assoc_del_peer
c_func
(paren
id|asoc
comma
op_amp
id|t-&gt;ipaddr
)paren
suffix:semicolon
)brace
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/* These three macros allow us to pull the debugging code out of the&n; * main flow of sctp_do_sm() to keep attention focused on the real&n; * functionality there.&n; */
DECL|macro|DEBUG_PRE
mdefine_line|#define DEBUG_PRE &bslash;&n;&t;SCTP_DEBUG_PRINTK(&quot;sctp_do_sm prefn: &quot; &bslash;&n;&t;&t;&t;  &quot;ep %p, %s, %s, asoc %p[%s], %s&bslash;n&quot;, &bslash;&n;&t;&t;&t;  ep, sctp_evttype_tbl[event_type], &bslash;&n;&t;&t;&t;  (*debug_fn)(subtype), asoc, &bslash;&n;&t;&t;&t;  sctp_state_tbl[state], state_fn-&gt;name)
DECL|macro|DEBUG_POST
mdefine_line|#define DEBUG_POST &bslash;&n;&t;SCTP_DEBUG_PRINTK(&quot;sctp_do_sm postfn: &quot; &bslash;&n;&t;&t;&t;  &quot;asoc %p, status: %s&bslash;n&quot;, &bslash;&n;&t;&t;&t;  asoc, sctp_status_tbl[status])
DECL|macro|DEBUG_POST_SFX
mdefine_line|#define DEBUG_POST_SFX &bslash;&n;&t;SCTP_DEBUG_PRINTK(&quot;sctp_do_sm post sfx: error %d, asoc %p[%s]&bslash;n&quot;, &bslash;&n;&t;&t;&t;  error, asoc, &bslash;&n;&t;&t;&t;  sctp_state_tbl[(asoc &amp;&amp; sctp_id2assoc(ep-&gt;base.sk, &bslash;&n;&t;&t;&t;  sctp_assoc2id(asoc)))?asoc-&gt;state:SCTP_STATE_CLOSED])
multiline_comment|/*&n; * This is the master state machine processing function.&n; *&n; * If you want to understand all of lksctp, this is a&n; * good place to start.&n; */
DECL|function|sctp_do_sm
r_int
id|sctp_do_sm
c_func
(paren
id|sctp_event_t
id|event_type
comma
id|sctp_subtype_t
id|subtype
comma
id|sctp_state_t
id|state
comma
r_struct
id|sctp_endpoint
op_star
id|ep
comma
r_struct
id|sctp_association
op_star
id|asoc
comma
r_void
op_star
id|event_arg
comma
r_int
id|gfp
)paren
(brace
id|sctp_cmd_seq_t
id|commands
suffix:semicolon
r_const
id|sctp_sm_table_entry_t
op_star
id|state_fn
suffix:semicolon
id|sctp_disposition_t
id|status
suffix:semicolon
r_int
id|error
op_assign
l_int|0
suffix:semicolon
r_typedef
r_const
r_char
op_star
(paren
id|printfn_t
)paren
(paren
id|sctp_subtype_t
)paren
suffix:semicolon
r_static
id|printfn_t
op_star
id|table
(braket
)braket
op_assign
(brace
l_int|NULL
comma
id|sctp_cname
comma
id|sctp_tname
comma
id|sctp_oname
comma
id|sctp_pname
comma
)brace
suffix:semicolon
id|printfn_t
op_star
id|debug_fn
id|__attribute__
(paren
(paren
id|unused
)paren
)paren
op_assign
id|table
(braket
id|event_type
)braket
suffix:semicolon
multiline_comment|/* Look up the state function, run it, and then process the&n;&t; * side effects.  These three steps are the heart of lksctp.&n;&t; */
id|state_fn
op_assign
id|sctp_sm_lookup_event
c_func
(paren
id|event_type
comma
id|state
comma
id|subtype
)paren
suffix:semicolon
id|sctp_init_cmd_seq
c_func
(paren
op_amp
id|commands
)paren
suffix:semicolon
id|DEBUG_PRE
suffix:semicolon
id|status
op_assign
(paren
op_star
id|state_fn-&gt;fn
)paren
(paren
id|ep
comma
id|asoc
comma
id|subtype
comma
id|event_arg
comma
op_amp
id|commands
)paren
suffix:semicolon
id|DEBUG_POST
suffix:semicolon
id|error
op_assign
id|sctp_side_effects
c_func
(paren
id|event_type
comma
id|subtype
comma
id|state
comma
id|ep
comma
id|asoc
comma
id|event_arg
comma
id|status
comma
op_amp
id|commands
comma
id|gfp
)paren
suffix:semicolon
id|DEBUG_POST_SFX
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
DECL|macro|DEBUG_PRE
macro_line|#undef DEBUG_PRE
DECL|macro|DEBUG_POST
macro_line|#undef DEBUG_POST
multiline_comment|/*****************************************************************&n; * This the master state function side effect processing function.&n; *****************************************************************/
DECL|function|sctp_side_effects
r_static
r_int
id|sctp_side_effects
c_func
(paren
id|sctp_event_t
id|event_type
comma
id|sctp_subtype_t
id|subtype
comma
id|sctp_state_t
id|state
comma
r_struct
id|sctp_endpoint
op_star
id|ep
comma
r_struct
id|sctp_association
op_star
id|asoc
comma
r_void
op_star
id|event_arg
comma
id|sctp_disposition_t
id|status
comma
id|sctp_cmd_seq_t
op_star
id|commands
comma
r_int
id|gfp
)paren
(brace
r_int
id|error
suffix:semicolon
multiline_comment|/* FIXME - Most of the dispositions left today would be categorized&n;&t; * as &quot;exceptional&quot; dispositions.  For those dispositions, it&n;&t; * may not be proper to run through any of the commands at all.&n;&t; * For example, the command interpreter might be run only with&n;&t; * disposition SCTP_DISPOSITION_CONSUME.&n;&t; */
r_if
c_cond
(paren
l_int|0
op_ne
(paren
id|error
op_assign
id|sctp_cmd_interpreter
c_func
(paren
id|event_type
comma
id|subtype
comma
id|state
comma
id|ep
comma
id|asoc
comma
id|event_arg
comma
id|status
comma
id|commands
comma
id|gfp
)paren
)paren
)paren
r_goto
id|bail
suffix:semicolon
r_switch
c_cond
(paren
id|status
)paren
(brace
r_case
id|SCTP_DISPOSITION_DISCARD
suffix:colon
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;Ignored sctp protocol event - state %d, &quot;
l_string|&quot;event_type %d, event_id %d&bslash;n&quot;
comma
id|state
comma
id|event_type
comma
id|subtype.chunk
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_DISPOSITION_NOMEM
suffix:colon
multiline_comment|/* We ran out of memory, so we need to discard this&n;&t;&t; * packet.&n;&t;&t; */
multiline_comment|/* BUG--we should now recover some memory, probably by&n;&t;&t; * reneging...&n;&t;&t; */
id|error
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_DISPOSITION_DELETE_TCB
suffix:colon
multiline_comment|/* This should now be a command. */
r_break
suffix:semicolon
r_case
id|SCTP_DISPOSITION_CONSUME
suffix:colon
r_case
id|SCTP_DISPOSITION_ABORT
suffix:colon
multiline_comment|/*&n;&t;&t; * We should no longer have much work to do here as the&n;&t;&t; * real work has been done as explicit commands above.&n;&t;&t; */
r_break
suffix:semicolon
r_case
id|SCTP_DISPOSITION_VIOLATION
suffix:colon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;sctp protocol violation state %d &quot;
l_string|&quot;chunkid %d&bslash;n&quot;
comma
id|state
comma
id|subtype.chunk
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_DISPOSITION_NOT_IMPL
suffix:colon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;sctp unimplemented feature in state %d, &quot;
l_string|&quot;event_type %d, event_id %d&bslash;n&quot;
comma
id|state
comma
id|event_type
comma
id|subtype.chunk
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_DISPOSITION_BUG
suffix:colon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;sctp bug in state %d, &quot;
l_string|&quot;event_type %d, event_id %d&bslash;n&quot;
comma
id|state
comma
id|event_type
comma
id|subtype.chunk
)paren
suffix:semicolon
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;sctp impossible disposition %d &quot;
l_string|&quot;in state %d, event_type %d, event_id %d&bslash;n&quot;
comma
id|status
comma
id|state
comma
id|event_type
comma
id|subtype.chunk
)paren
suffix:semicolon
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
suffix:semicolon
id|bail
suffix:colon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/********************************************************************&n; * 2nd Level Abstractions&n; ********************************************************************/
multiline_comment|/* This is the side-effect interpreter.  */
DECL|function|sctp_cmd_interpreter
r_static
r_int
id|sctp_cmd_interpreter
c_func
(paren
id|sctp_event_t
id|event_type
comma
id|sctp_subtype_t
id|subtype
comma
id|sctp_state_t
id|state
comma
r_struct
id|sctp_endpoint
op_star
id|ep
comma
r_struct
id|sctp_association
op_star
id|asoc
comma
r_void
op_star
id|event_arg
comma
id|sctp_disposition_t
id|status
comma
id|sctp_cmd_seq_t
op_star
id|commands
comma
r_int
id|gfp
)paren
(brace
r_int
id|error
op_assign
l_int|0
suffix:semicolon
r_int
id|force
suffix:semicolon
id|sctp_cmd_t
op_star
id|cmd
suffix:semicolon
r_struct
id|sctp_chunk
op_star
id|new_obj
suffix:semicolon
r_struct
id|sctp_chunk
op_star
id|chunk
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|sctp_packet
op_star
id|packet
suffix:semicolon
r_struct
id|list_head
op_star
id|pos
suffix:semicolon
r_struct
id|timer_list
op_star
id|timer
suffix:semicolon
r_int
r_int
id|timeout
suffix:semicolon
r_struct
id|sctp_transport
op_star
id|t
suffix:semicolon
r_struct
id|sctp_sackhdr
id|sackh
suffix:semicolon
r_int
id|local_cork
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|SCTP_EVENT_T_TIMEOUT
op_ne
id|event_type
)paren
id|chunk
op_assign
(paren
r_struct
id|sctp_chunk
op_star
)paren
id|event_arg
suffix:semicolon
multiline_comment|/* Note:  This whole file is a huge candidate for rework.&n;&t; * For example, each command could either have its own handler, so&n;&t; * the loop would look like:&n;&t; *     while (cmds)&n;&t; *         cmd-&gt;handle(x, y, z)&n;&t; * --jgrimm&n;&t; */
r_while
c_loop
(paren
l_int|NULL
op_ne
(paren
id|cmd
op_assign
id|sctp_next_cmd
c_func
(paren
id|commands
)paren
)paren
)paren
(brace
r_switch
c_cond
(paren
id|cmd-&gt;verb
)paren
(brace
r_case
id|SCTP_CMD_NOP
suffix:colon
multiline_comment|/* Do nothing. */
r_break
suffix:semicolon
r_case
id|SCTP_CMD_NEW_ASOC
suffix:colon
multiline_comment|/* Register a new association.  */
r_if
c_cond
(paren
id|local_cork
)paren
(brace
id|sctp_outq_uncork
c_func
(paren
op_amp
id|asoc-&gt;outqueue
)paren
suffix:semicolon
id|local_cork
op_assign
l_int|0
suffix:semicolon
)brace
id|asoc
op_assign
id|cmd-&gt;obj.ptr
suffix:semicolon
multiline_comment|/* Register with the endpoint.  */
id|sctp_endpoint_add_asoc
c_func
(paren
id|ep
comma
id|asoc
)paren
suffix:semicolon
id|sctp_hash_established
c_func
(paren
id|asoc
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_CMD_UPDATE_ASSOC
suffix:colon
id|sctp_assoc_update
c_func
(paren
id|asoc
comma
id|cmd-&gt;obj.ptr
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_CMD_PURGE_OUTQUEUE
suffix:colon
id|sctp_outq_teardown
c_func
(paren
op_amp
id|asoc-&gt;outqueue
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_CMD_DELETE_TCB
suffix:colon
r_if
c_cond
(paren
id|local_cork
)paren
(brace
id|sctp_outq_uncork
c_func
(paren
op_amp
id|asoc-&gt;outqueue
)paren
suffix:semicolon
id|local_cork
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Delete the current association.  */
id|sctp_cmd_delete_tcb
c_func
(paren
id|commands
comma
id|asoc
)paren
suffix:semicolon
id|asoc
op_assign
l_int|NULL
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_CMD_NEW_STATE
suffix:colon
multiline_comment|/* Enter a new state.  */
id|sctp_cmd_new_state
c_func
(paren
id|commands
comma
id|asoc
comma
id|cmd-&gt;obj.state
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_CMD_REPORT_TSN
suffix:colon
multiline_comment|/* Record the arrival of a TSN.  */
id|sctp_tsnmap_mark
c_func
(paren
op_amp
id|asoc-&gt;peer.tsn_map
comma
id|cmd-&gt;obj.u32
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_CMD_REPORT_FWDTSN
suffix:colon
multiline_comment|/* Move the Cumulattive TSN Ack ahead. */
id|sctp_tsnmap_skip
c_func
(paren
op_amp
id|asoc-&gt;peer.tsn_map
comma
id|cmd-&gt;obj.u32
)paren
suffix:semicolon
multiline_comment|/* Abort any in progress partial delivery. */
id|sctp_ulpq_abort_pd
c_func
(paren
op_amp
id|asoc-&gt;ulpq
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_CMD_PROCESS_FWDTSN
suffix:colon
id|sctp_cmd_process_fwdtsn
c_func
(paren
op_amp
id|asoc-&gt;ulpq
comma
id|cmd-&gt;obj.ptr
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_CMD_GEN_SACK
suffix:colon
multiline_comment|/* Generate a Selective ACK.&n;&t;&t;&t; * The argument tells us whether to just count&n;&t;&t;&t; * the packet and MAYBE generate a SACK, or&n;&t;&t;&t; * force a SACK out.&n;&t;&t;&t; */
id|force
op_assign
id|cmd-&gt;obj.i32
suffix:semicolon
id|error
op_assign
id|sctp_gen_sack
c_func
(paren
id|asoc
comma
id|force
comma
id|commands
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_CMD_PROCESS_SACK
suffix:colon
multiline_comment|/* Process an inbound SACK.  */
id|error
op_assign
id|sctp_cmd_process_sack
c_func
(paren
id|commands
comma
id|asoc
comma
id|cmd-&gt;obj.ptr
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_CMD_GEN_INIT_ACK
suffix:colon
multiline_comment|/* Generate an INIT ACK chunk.  */
id|new_obj
op_assign
id|sctp_make_init_ack
c_func
(paren
id|asoc
comma
id|chunk
comma
id|GFP_ATOMIC
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|new_obj
)paren
r_goto
id|nomem
suffix:semicolon
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_REPLY
comma
id|SCTP_CHUNK
c_func
(paren
id|new_obj
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_CMD_PEER_INIT
suffix:colon
multiline_comment|/* Process a unified INIT from the peer.&n;&t;&t;&t; * Note: Only used during INIT-ACK processing.  If&n;&t;&t;&t; * there is an error just return to the outter&n;&t;&t;&t; * layer which will bail.&n;&t;&t;&t; */
id|error
op_assign
id|sctp_cmd_process_init
c_func
(paren
id|commands
comma
id|asoc
comma
id|chunk
comma
id|cmd-&gt;obj.ptr
comma
id|gfp
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_CMD_GEN_COOKIE_ECHO
suffix:colon
multiline_comment|/* Generate a COOKIE ECHO chunk.  */
id|new_obj
op_assign
id|sctp_make_cookie_echo
c_func
(paren
id|asoc
comma
id|chunk
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|new_obj
)paren
(brace
r_if
c_cond
(paren
id|cmd-&gt;obj.ptr
)paren
id|sctp_chunk_free
c_func
(paren
id|cmd-&gt;obj.ptr
)paren
suffix:semicolon
r_goto
id|nomem
suffix:semicolon
)brace
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_REPLY
comma
id|SCTP_CHUNK
c_func
(paren
id|new_obj
)paren
)paren
suffix:semicolon
multiline_comment|/* If there is an ERROR chunk to be sent along with&n;&t;&t;&t; * the COOKIE_ECHO, send it, too.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|cmd-&gt;obj.ptr
)paren
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_REPLY
comma
id|SCTP_CHUNK
c_func
(paren
id|cmd-&gt;obj.ptr
)paren
)paren
suffix:semicolon
multiline_comment|/* FIXME - Eventually come up with a cleaner way to&n;&t;&t;&t; * enabling COOKIE-ECHO + DATA bundling during &n;&t;&t;&t; * multihoming stale cookie scenarios, the following &n;&t;&t;&t; * command plays with asoc-&gt;peer.retran_path to &n;&t;&t;&t; * avoid the problem of sending the COOKIE-ECHO and &n;&t;&t;&t; * DATA in different paths, which could result &n;&t;&t;&t; * in the association being ABORTed if the DATA chunk &n;&t;&t;&t; * is processed first by the server.  Checking the&n;&t;&t;&t; * init error counter simply causes this command&n;&t;&t;&t; * to be executed only during failed attempts of&n;&t;&t;&t; * association establishment.&n;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|asoc-&gt;peer.retran_path
op_ne
id|asoc-&gt;peer.primary_path
)paren
op_logical_and
(paren
id|asoc-&gt;counters
(braket
id|SCTP_COUNTER_INIT_ERROR
)braket
OG
l_int|0
)paren
)paren
(brace
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_FORCE_PRIM_RETRAN
comma
id|SCTP_NULL
c_func
(paren
)paren
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|SCTP_CMD_GEN_SHUTDOWN
suffix:colon
multiline_comment|/* Generate SHUTDOWN when in SHUTDOWN_SENT state.&n;&t;&t;&t; * Reset error counts.&n;&t;&t;&t; */
id|asoc-&gt;overall_error_count
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Generate a SHUTDOWN chunk.  */
id|new_obj
op_assign
id|sctp_make_shutdown
c_func
(paren
id|asoc
comma
id|chunk
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|new_obj
)paren
r_goto
id|nomem
suffix:semicolon
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_REPLY
comma
id|SCTP_CHUNK
c_func
(paren
id|new_obj
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_CMD_CHUNK_ULP
suffix:colon
multiline_comment|/* Send a chunk to the sockets layer.  */
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;sm_sideff: %s %p, %s %p.&bslash;n&quot;
comma
l_string|&quot;chunk_up:&quot;
comma
id|cmd-&gt;obj.ptr
comma
l_string|&quot;ulpq:&quot;
comma
op_amp
id|asoc-&gt;ulpq
)paren
suffix:semicolon
id|sctp_ulpq_tail_data
c_func
(paren
op_amp
id|asoc-&gt;ulpq
comma
id|cmd-&gt;obj.ptr
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_CMD_EVENT_ULP
suffix:colon
multiline_comment|/* Send a notification to the sockets layer.  */
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;sm_sideff: %s %p, %s %p.&bslash;n&quot;
comma
l_string|&quot;event_up:&quot;
comma
id|cmd-&gt;obj.ptr
comma
l_string|&quot;ulpq:&quot;
comma
op_amp
id|asoc-&gt;ulpq
)paren
suffix:semicolon
id|sctp_ulpq_tail_event
c_func
(paren
op_amp
id|asoc-&gt;ulpq
comma
id|cmd-&gt;obj.ptr
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_CMD_REPLY
suffix:colon
multiline_comment|/* If an caller has not already corked, do cork. */
r_if
c_cond
(paren
op_logical_neg
id|asoc-&gt;outqueue.cork
)paren
(brace
id|sctp_outq_cork
c_func
(paren
op_amp
id|asoc-&gt;outqueue
)paren
suffix:semicolon
id|local_cork
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Send a chunk to our peer.  */
id|error
op_assign
id|sctp_outq_tail
c_func
(paren
op_amp
id|asoc-&gt;outqueue
comma
id|cmd-&gt;obj.ptr
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_CMD_SEND_PKT
suffix:colon
multiline_comment|/* Send a full packet to our peer.  */
id|packet
op_assign
id|cmd-&gt;obj.ptr
suffix:semicolon
id|sctp_packet_transmit
c_func
(paren
id|packet
)paren
suffix:semicolon
id|sctp_ootb_pkt_free
c_func
(paren
id|packet
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_CMD_RETRAN
suffix:colon
multiline_comment|/* Mark a transport for retransmission.  */
id|sctp_retransmit
c_func
(paren
op_amp
id|asoc-&gt;outqueue
comma
id|cmd-&gt;obj.transport
comma
id|SCTP_RTXR_T3_RTX
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_CMD_TRANSMIT
suffix:colon
multiline_comment|/* Kick start transmission. */
id|error
op_assign
id|sctp_outq_uncork
c_func
(paren
op_amp
id|asoc-&gt;outqueue
)paren
suffix:semicolon
id|local_cork
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_CMD_ECN_CE
suffix:colon
multiline_comment|/* Do delayed CE processing.   */
id|sctp_do_ecn_ce_work
c_func
(paren
id|asoc
comma
id|cmd-&gt;obj.u32
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_CMD_ECN_ECNE
suffix:colon
multiline_comment|/* Do delayed ECNE processing. */
id|new_obj
op_assign
id|sctp_do_ecn_ecne_work
c_func
(paren
id|asoc
comma
id|cmd-&gt;obj.u32
comma
id|chunk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|new_obj
)paren
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_REPLY
comma
id|SCTP_CHUNK
c_func
(paren
id|new_obj
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_CMD_ECN_CWR
suffix:colon
multiline_comment|/* Do delayed CWR processing.  */
id|sctp_do_ecn_cwr_work
c_func
(paren
id|asoc
comma
id|cmd-&gt;obj.u32
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_CMD_SETUP_T2
suffix:colon
id|sctp_cmd_setup_t2
c_func
(paren
id|commands
comma
id|asoc
comma
id|cmd-&gt;obj.ptr
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_CMD_TIMER_START
suffix:colon
id|timer
op_assign
op_amp
id|asoc-&gt;timers
(braket
id|cmd-&gt;obj.to
)braket
suffix:semicolon
id|timeout
op_assign
id|asoc-&gt;timeouts
(braket
id|cmd-&gt;obj.to
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|timeout
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|timer-&gt;expires
op_assign
id|jiffies
op_plus
id|timeout
suffix:semicolon
id|sctp_association_hold
c_func
(paren
id|asoc
)paren
suffix:semicolon
id|add_timer
c_func
(paren
id|timer
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_CMD_TIMER_RESTART
suffix:colon
id|timer
op_assign
op_amp
id|asoc-&gt;timers
(braket
id|cmd-&gt;obj.to
)braket
suffix:semicolon
id|timeout
op_assign
id|asoc-&gt;timeouts
(braket
id|cmd-&gt;obj.to
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mod_timer
c_func
(paren
id|timer
comma
id|jiffies
op_plus
id|timeout
)paren
)paren
id|sctp_association_hold
c_func
(paren
id|asoc
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_CMD_TIMER_STOP
suffix:colon
id|timer
op_assign
op_amp
id|asoc-&gt;timers
(braket
id|cmd-&gt;obj.to
)braket
suffix:semicolon
r_if
c_cond
(paren
id|timer_pending
c_func
(paren
id|timer
)paren
op_logical_and
id|del_timer
c_func
(paren
id|timer
)paren
)paren
id|sctp_association_put
c_func
(paren
id|asoc
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_CMD_INIT_RESTART
suffix:colon
multiline_comment|/* Do the needed accounting and updates&n;&t;&t;&t; * associated with restarting an initialization&n;&t;&t;&t; * timer.&n;&t;&t;&t; */
id|asoc-&gt;counters
(braket
id|SCTP_COUNTER_INIT_ERROR
)braket
op_increment
suffix:semicolon
id|asoc-&gt;timeouts
(braket
id|cmd-&gt;obj.to
)braket
op_mul_assign
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|asoc-&gt;timeouts
(braket
id|cmd-&gt;obj.to
)braket
OG
id|asoc-&gt;max_init_timeo
)paren
(brace
id|asoc-&gt;timeouts
(braket
id|cmd-&gt;obj.to
)braket
op_assign
id|asoc-&gt;max_init_timeo
suffix:semicolon
)brace
multiline_comment|/* If we&squot;ve sent any data bundled with&n;&t;&t;&t; * COOKIE-ECHO we need to resend.&n;&t;&t;&t; */
id|list_for_each
c_func
(paren
id|pos
comma
op_amp
id|asoc-&gt;peer.transport_addr_list
)paren
(brace
id|t
op_assign
id|list_entry
c_func
(paren
id|pos
comma
r_struct
id|sctp_transport
comma
id|transports
)paren
suffix:semicolon
id|sctp_retransmit_mark
c_func
(paren
op_amp
id|asoc-&gt;outqueue
comma
id|t
comma
l_int|0
)paren
suffix:semicolon
)brace
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_TIMER_RESTART
comma
id|SCTP_TO
c_func
(paren
id|cmd-&gt;obj.to
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_CMD_INIT_FAILED
suffix:colon
id|sctp_cmd_init_failed
c_func
(paren
id|commands
comma
id|asoc
comma
id|cmd-&gt;obj.u32
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_CMD_ASSOC_FAILED
suffix:colon
id|sctp_cmd_assoc_failed
c_func
(paren
id|commands
comma
id|asoc
comma
id|event_type
comma
id|subtype
comma
id|chunk
comma
id|cmd-&gt;obj.u32
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_CMD_COUNTER_INC
suffix:colon
id|asoc-&gt;counters
(braket
id|cmd-&gt;obj.counter
)braket
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_CMD_COUNTER_RESET
suffix:colon
id|asoc-&gt;counters
(braket
id|cmd-&gt;obj.counter
)braket
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_CMD_REPORT_DUP
suffix:colon
id|sctp_tsnmap_mark_dup
c_func
(paren
op_amp
id|asoc-&gt;peer.tsn_map
comma
id|cmd-&gt;obj.u32
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_CMD_REPORT_BAD_TAG
suffix:colon
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;vtag mismatch!&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_CMD_STRIKE
suffix:colon
multiline_comment|/* Mark one strike against a transport.  */
id|sctp_do_8_2_transport_strike
c_func
(paren
id|asoc
comma
id|cmd-&gt;obj.transport
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_CMD_TRANSPORT_RESET
suffix:colon
id|t
op_assign
id|cmd-&gt;obj.transport
suffix:semicolon
id|sctp_cmd_transport_reset
c_func
(paren
id|commands
comma
id|asoc
comma
id|t
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_CMD_TRANSPORT_ON
suffix:colon
id|t
op_assign
id|cmd-&gt;obj.transport
suffix:semicolon
id|sctp_cmd_transport_on
c_func
(paren
id|commands
comma
id|asoc
comma
id|t
comma
id|chunk
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_CMD_HB_TIMERS_START
suffix:colon
id|sctp_cmd_hb_timers_start
c_func
(paren
id|commands
comma
id|asoc
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_CMD_HB_TIMER_UPDATE
suffix:colon
id|t
op_assign
id|cmd-&gt;obj.transport
suffix:semicolon
id|sctp_cmd_hb_timer_update
c_func
(paren
id|commands
comma
id|asoc
comma
id|t
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_CMD_HB_TIMERS_STOP
suffix:colon
id|sctp_cmd_hb_timers_stop
c_func
(paren
id|commands
comma
id|asoc
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_CMD_REPORT_ERROR
suffix:colon
id|error
op_assign
id|cmd-&gt;obj.error
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_CMD_PROCESS_CTSN
suffix:colon
multiline_comment|/* Dummy up a SACK for processing. */
id|sackh.cum_tsn_ack
op_assign
id|cmd-&gt;obj.u32
suffix:semicolon
id|sackh.a_rwnd
op_assign
l_int|0
suffix:semicolon
id|sackh.num_gap_ack_blocks
op_assign
l_int|0
suffix:semicolon
id|sackh.num_dup_tsns
op_assign
l_int|0
suffix:semicolon
id|sctp_add_cmd_sf
c_func
(paren
id|commands
comma
id|SCTP_CMD_PROCESS_SACK
comma
id|SCTP_SACKH
c_func
(paren
op_amp
id|sackh
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_CMD_DISCARD_PACKET
suffix:colon
multiline_comment|/* We need to discard the whole packet.  */
id|chunk-&gt;pdiscard
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_CMD_RTO_PENDING
suffix:colon
id|t
op_assign
id|cmd-&gt;obj.transport
suffix:semicolon
id|t-&gt;rto_pending
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_CMD_PART_DELIVER
suffix:colon
id|sctp_ulpq_partial_delivery
c_func
(paren
op_amp
id|asoc-&gt;ulpq
comma
id|cmd-&gt;obj.ptr
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_CMD_RENEGE
suffix:colon
id|sctp_ulpq_renege
c_func
(paren
op_amp
id|asoc-&gt;ulpq
comma
id|cmd-&gt;obj.ptr
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_CMD_SETUP_T4
suffix:colon
id|sctp_cmd_setup_t4
c_func
(paren
id|commands
comma
id|asoc
comma
id|cmd-&gt;obj.ptr
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_CMD_PROCESS_OPERR
suffix:colon
id|sctp_cmd_process_operr
c_func
(paren
id|commands
comma
id|asoc
comma
id|chunk
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_CMD_CLEAR_INIT_TAG
suffix:colon
id|asoc-&gt;peer.i.init_tag
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_CMD_DEL_NON_PRIMARY
suffix:colon
id|sctp_cmd_del_non_primary
c_func
(paren
id|asoc
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_CMD_T3_RTX_TIMERS_STOP
suffix:colon
id|sctp_cmd_t3_rtx_timers_stop
c_func
(paren
id|commands
comma
id|asoc
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_CMD_FORCE_PRIM_RETRAN
suffix:colon
id|t
op_assign
id|asoc-&gt;peer.retran_path
suffix:semicolon
id|asoc-&gt;peer.retran_path
op_assign
id|asoc-&gt;peer.primary_path
suffix:semicolon
id|error
op_assign
id|sctp_outq_uncork
c_func
(paren
op_amp
id|asoc-&gt;outqueue
)paren
suffix:semicolon
id|local_cork
op_assign
l_int|0
suffix:semicolon
id|asoc-&gt;peer.retran_path
op_assign
id|t
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Impossible command: %u, %p&bslash;n&quot;
comma
id|cmd-&gt;verb
comma
id|cmd-&gt;obj.ptr
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_break
suffix:semicolon
)brace
id|out
suffix:colon
r_if
c_cond
(paren
id|local_cork
)paren
id|sctp_outq_uncork
c_func
(paren
op_amp
id|asoc-&gt;outqueue
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
id|nomem
suffix:colon
id|error
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
eof
