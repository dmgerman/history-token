multiline_comment|/* SCTP kernel reference Implementation&n; * Copyright (c) 1999-2000 Cisco, Inc.&n; * Copyright (c) 1999-2001 Motorola, Inc.&n; * Copyright (c) 2001-2003 International Business Machines Corp.&n; * Copyright (c) 2001 Intel Corp.&n; * Copyright (c) 2001 La Monte H.P. Yarroll&n; *&n; * This file is part of the SCTP kernel reference Implementation&n; *&n; * This module provides the abstraction for an SCTP association.&n; *&n; * The SCTP reference implementation is free software;&n; * you can redistribute it and/or modify it under the terms of&n; * the GNU General Public License as published by&n; * the Free Software Foundation; either version 2, or (at your option)&n; * any later version.&n; *&n; * The SCTP reference implementation is distributed in the hope that it&n; * will be useful, but WITHOUT ANY WARRANTY; without even the implied&n; *                 ************************&n; * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&n; * See the GNU General Public License for more details.&n; *&n; * You should have received a copy of the GNU General Public License&n; * along with GNU CC; see the file COPYING.  If not, write to&n; * the Free Software Foundation, 59 Temple Place - Suite 330,&n; * Boston, MA 02111-1307, USA.&n; *&n; * Please send any bug reports or fixes you make to the&n; * email address(es):&n; *    lksctp developers &lt;lksctp-developers@lists.sourceforge.net&gt;&n; *&n; * Or submit a bug report through the following website:&n; *    http://www.sf.net/projects/lksctp&n; *&n; * Written or modified by:&n; *    La Monte H.P. Yarroll &lt;piggy@acm.org&gt;&n; *    Karl Knutson          &lt;karl@athena.chicago.il.us&gt;&n; *    Jon Grimm             &lt;jgrimm@us.ibm.com&gt;&n; *    Xingang Guo           &lt;xingang.guo@intel.com&gt;&n; *    Hui Huang             &lt;hui.huang@nokia.com&gt;&n; *    Sridhar Samudrala&t;    &lt;sri@us.ibm.com&gt;&n; *    Daisy Chang&t;    &lt;daisyc@us.ibm.com&gt;&n; *&n; * Any bugs reported given to us we will try to fix... any fixes shared will&n; * be incorporated into the next SCTP release.&n; */
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/poll.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/in.h&gt;
macro_line|#include &lt;net/ipv6.h&gt;
macro_line|#include &lt;net/sctp/sctp.h&gt;
multiline_comment|/* Forward declarations for internal functions. */
r_static
r_void
id|sctp_assoc_bh_rcv
c_func
(paren
id|sctp_association_t
op_star
id|asoc
)paren
suffix:semicolon
multiline_comment|/* 1st Level Abstractions. */
multiline_comment|/* Allocate and initialize a new association */
DECL|function|sctp_association_new
id|sctp_association_t
op_star
id|sctp_association_new
c_func
(paren
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
r_struct
id|sock
op_star
id|sk
comma
id|sctp_scope_t
id|scope
comma
r_int
id|priority
)paren
(brace
id|sctp_association_t
op_star
id|asoc
suffix:semicolon
id|asoc
op_assign
id|t_new
c_func
(paren
id|sctp_association_t
comma
id|priority
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|asoc
)paren
r_goto
id|fail
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sctp_association_init
c_func
(paren
id|asoc
comma
id|ep
comma
id|sk
comma
id|scope
comma
id|priority
)paren
)paren
r_goto
id|fail_init
suffix:semicolon
id|asoc-&gt;base.malloced
op_assign
l_int|1
suffix:semicolon
id|SCTP_DBG_OBJCNT_INC
c_func
(paren
id|assoc
)paren
suffix:semicolon
r_return
id|asoc
suffix:semicolon
id|fail_init
suffix:colon
id|kfree
c_func
(paren
id|asoc
)paren
suffix:semicolon
id|fail
suffix:colon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Intialize a new association from provided memory. */
DECL|function|sctp_association_init
id|sctp_association_t
op_star
id|sctp_association_init
c_func
(paren
id|sctp_association_t
op_star
id|asoc
comma
r_const
id|sctp_endpoint_t
op_star
id|ep
comma
r_const
r_struct
id|sock
op_star
id|sk
comma
id|sctp_scope_t
id|scope
comma
r_int
id|priority
)paren
(brace
id|sctp_opt_t
op_star
id|sp
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/* Retrieve the SCTP per socket area.  */
id|sp
op_assign
id|sctp_sk
c_func
(paren
(paren
r_struct
id|sock
op_star
)paren
id|sk
)paren
suffix:semicolon
multiline_comment|/* Init all variables to a known value.  */
id|memset
c_func
(paren
id|asoc
comma
l_int|0
comma
r_sizeof
(paren
id|sctp_association_t
)paren
)paren
suffix:semicolon
multiline_comment|/* Discarding const is appropriate here.  */
id|asoc-&gt;ep
op_assign
(paren
id|sctp_endpoint_t
op_star
)paren
id|ep
suffix:semicolon
id|sctp_endpoint_hold
c_func
(paren
id|asoc-&gt;ep
)paren
suffix:semicolon
multiline_comment|/* Hold the sock.  */
id|asoc-&gt;base.sk
op_assign
(paren
r_struct
id|sock
op_star
)paren
id|sk
suffix:semicolon
id|sock_hold
c_func
(paren
id|asoc-&gt;base.sk
)paren
suffix:semicolon
multiline_comment|/* Initialize the common base substructure.  */
id|asoc-&gt;base.type
op_assign
id|SCTP_EP_TYPE_ASSOCIATION
suffix:semicolon
multiline_comment|/* Initialize the object handling fields.  */
id|atomic_set
c_func
(paren
op_amp
id|asoc-&gt;base.refcnt
comma
l_int|1
)paren
suffix:semicolon
id|asoc-&gt;base.dead
op_assign
l_int|0
suffix:semicolon
id|asoc-&gt;base.malloced
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Initialize the bind addr area.  */
id|sctp_bind_addr_init
c_func
(paren
op_amp
id|asoc-&gt;base.bind_addr
comma
id|ep-&gt;base.bind_addr.port
)paren
suffix:semicolon
id|asoc-&gt;base.addr_lock
op_assign
id|RW_LOCK_UNLOCKED
suffix:semicolon
id|asoc-&gt;state
op_assign
id|SCTP_STATE_CLOSED
suffix:semicolon
id|asoc-&gt;state_timestamp
op_assign
id|jiffies
suffix:semicolon
multiline_comment|/* Set things that have constant value.  */
id|asoc-&gt;cookie_life.tv_sec
op_assign
id|sctp_proto.valid_cookie_life
op_div
id|HZ
suffix:semicolon
id|asoc-&gt;cookie_life.tv_usec
op_assign
(paren
id|sctp_proto.valid_cookie_life
op_mod
id|HZ
)paren
op_star
l_int|1000000L
op_div
id|HZ
suffix:semicolon
id|asoc-&gt;pmtu
op_assign
l_int|0
suffix:semicolon
id|asoc-&gt;frag_point
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Initialize the default association max_retrans and RTO values.  */
id|asoc-&gt;max_retrans
op_assign
id|ep-&gt;proto-&gt;max_retrans_association
suffix:semicolon
id|asoc-&gt;rto_initial
op_assign
id|ep-&gt;proto-&gt;rto_initial
suffix:semicolon
id|asoc-&gt;rto_max
op_assign
id|ep-&gt;proto-&gt;rto_max
suffix:semicolon
id|asoc-&gt;rto_min
op_assign
id|ep-&gt;proto-&gt;rto_min
suffix:semicolon
id|asoc-&gt;overall_error_threshold
op_assign
l_int|0
suffix:semicolon
id|asoc-&gt;overall_error_count
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Initialize the maximum mumber of new data packets that can be sent&n;&t; * in a burst.&n;&t; */
id|asoc-&gt;max_burst
op_assign
id|ep-&gt;proto-&gt;max_burst
suffix:semicolon
multiline_comment|/* Copy things from the endpoint.  */
r_for
c_loop
(paren
id|i
op_assign
id|SCTP_EVENT_TIMEOUT_NONE
suffix:semicolon
id|i
OL
id|SCTP_NUM_TIMEOUT_TYPES
suffix:semicolon
op_increment
id|i
)paren
(brace
id|asoc-&gt;timeouts
(braket
id|i
)braket
op_assign
id|ep-&gt;timeouts
(braket
id|i
)braket
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|asoc-&gt;timers
(braket
id|i
)braket
)paren
suffix:semicolon
id|asoc-&gt;timers
(braket
id|i
)braket
dot
id|function
op_assign
id|sctp_timer_events
(braket
id|i
)braket
suffix:semicolon
id|asoc-&gt;timers
(braket
id|i
)braket
dot
id|data
op_assign
(paren
r_int
r_int
)paren
id|asoc
suffix:semicolon
)brace
multiline_comment|/* Pull default initialization values from the sock options.&n;&t; * Note: This assumes that the values have already been&n;&t; * validated in the sock.&n;&t; */
id|asoc-&gt;c.sinit_max_instreams
op_assign
id|sp-&gt;initmsg.sinit_max_instreams
suffix:semicolon
id|asoc-&gt;c.sinit_num_ostreams
op_assign
id|sp-&gt;initmsg.sinit_num_ostreams
suffix:semicolon
id|asoc-&gt;max_init_attempts
op_assign
id|sp-&gt;initmsg.sinit_max_attempts
suffix:semicolon
id|asoc-&gt;max_init_timeo
op_assign
id|sp-&gt;initmsg.sinit_max_init_timeo
op_star
id|HZ
suffix:semicolon
multiline_comment|/* Allocate storage for the ssnmap after the inbound and outbound&n;&t; * streams have been negotiated during Init.&n;&t; */
id|asoc-&gt;ssnmap
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Set the local window size for receive.&n;&t; * This is also the rcvbuf space per association.&n;&t; * RFC 6 - A SCTP receiver MUST be able to receive a minimum of&n;&t; * 1500 bytes in one SCTP packet.&n;&t; */
r_if
c_cond
(paren
id|sk-&gt;rcvbuf
OL
id|SCTP_DEFAULT_MINWINDOW
)paren
id|asoc-&gt;rwnd
op_assign
id|SCTP_DEFAULT_MINWINDOW
suffix:semicolon
r_else
id|asoc-&gt;rwnd
op_assign
id|sk-&gt;rcvbuf
suffix:semicolon
id|asoc-&gt;a_rwnd
op_assign
l_int|0
suffix:semicolon
id|asoc-&gt;rwnd_over
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Use my own max window until I learn something better.  */
id|asoc-&gt;peer.rwnd
op_assign
id|SCTP_DEFAULT_MAXWINDOW
suffix:semicolon
multiline_comment|/* Set the sndbuf size for transmit.  */
id|asoc-&gt;sndbuf_used
op_assign
l_int|0
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|asoc-&gt;wait
)paren
suffix:semicolon
id|asoc-&gt;c.my_vtag
op_assign
id|sctp_generate_tag
c_func
(paren
id|ep
)paren
suffix:semicolon
id|asoc-&gt;peer.i.init_tag
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* INIT needs a vtag of 0. */
id|asoc-&gt;c.peer_vtag
op_assign
l_int|0
suffix:semicolon
id|asoc-&gt;c.my_ttag
op_assign
l_int|0
suffix:semicolon
id|asoc-&gt;c.peer_ttag
op_assign
l_int|0
suffix:semicolon
id|asoc-&gt;c.initial_tsn
op_assign
id|sctp_generate_tsn
c_func
(paren
id|ep
)paren
suffix:semicolon
id|asoc-&gt;next_tsn
op_assign
id|asoc-&gt;c.initial_tsn
suffix:semicolon
id|asoc-&gt;ctsn_ack_point
op_assign
id|asoc-&gt;next_tsn
op_minus
l_int|1
suffix:semicolon
id|asoc-&gt;highest_sacked
op_assign
id|asoc-&gt;ctsn_ack_point
suffix:semicolon
id|asoc-&gt;last_cwr_tsn
op_assign
id|asoc-&gt;ctsn_ack_point
suffix:semicolon
id|asoc-&gt;unack_data
op_assign
l_int|0
suffix:semicolon
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;myctsnap for %s INIT as 0x%x.&bslash;n&quot;
comma
id|asoc-&gt;ep-&gt;debug_name
comma
id|asoc-&gt;ctsn_ack_point
)paren
suffix:semicolon
multiline_comment|/* ADDIP Section 4.1 Asconf Chunk Procedures&n;&t; *&n;&t; * When an endpoint has an ASCONF signaled change to be sent to the&n;&t; * remote endpoint it should do the following:&n;&t; * ...&n;&t; * A2) a serial number should be assigned to the chunk. The serial&n;&t; * number should be a monotonically increasing number. All serial&n;&t; * numbers are defined to be initialized at the start of the&n;&t; * association to the same value as the initial TSN.&n;&t; */
id|asoc-&gt;addip_serial
op_assign
id|asoc-&gt;c.initial_tsn
suffix:semicolon
multiline_comment|/* Make an empty list of remote transport addresses.  */
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|asoc-&gt;peer.transport_addr_list
)paren
suffix:semicolon
multiline_comment|/* RFC 2960 5.1 Normal Establishment of an Association&n;&t; *&n;&t; * After the reception of the first data chunk in an&n;&t; * association the endpoint must immediately respond with a&n;&t; * sack to acknowledge the data chunk.  Subsequent&n;&t; * acknowledgements should be done as described in Section&n;&t; * 6.2.&n;&t; *&n;&t; * [We implement this by telling a new association that it&n;&t; * already received one packet.]&n;&t; */
id|asoc-&gt;peer.sack_needed
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Create an input queue.  */
id|sctp_inqueue_init
c_func
(paren
op_amp
id|asoc-&gt;base.inqueue
)paren
suffix:semicolon
id|sctp_inqueue_set_th_handler
c_func
(paren
op_amp
id|asoc-&gt;base.inqueue
comma
(paren
r_void
(paren
op_star
)paren
(paren
r_void
op_star
)paren
)paren
id|sctp_assoc_bh_rcv
comma
id|asoc
)paren
suffix:semicolon
multiline_comment|/* Create an output queue.  */
id|sctp_outq_init
c_func
(paren
id|asoc
comma
op_amp
id|asoc-&gt;outqueue
)paren
suffix:semicolon
id|sctp_outq_set_output_handlers
c_func
(paren
op_amp
id|asoc-&gt;outqueue
comma
id|sctp_packet_init
comma
id|sctp_packet_config
comma
id|sctp_packet_append_chunk
comma
id|sctp_packet_transmit_chunk
comma
id|sctp_packet_transmit
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|NULL
op_eq
id|sctp_ulpq_init
c_func
(paren
op_amp
id|asoc-&gt;ulpq
comma
id|asoc
)paren
)paren
r_goto
id|fail_init
suffix:semicolon
multiline_comment|/* Set up the tsn tracking. */
id|sctp_tsnmap_init
c_func
(paren
op_amp
id|asoc-&gt;peer.tsn_map
comma
id|SCTP_TSN_MAP_SIZE
comma
l_int|0
)paren
suffix:semicolon
id|asoc-&gt;peer.next_dup_tsn
op_assign
l_int|0
suffix:semicolon
id|skb_queue_head_init
c_func
(paren
op_amp
id|asoc-&gt;addip_chunks
)paren
suffix:semicolon
id|asoc-&gt;need_ecne
op_assign
l_int|0
suffix:semicolon
id|asoc-&gt;debug_name
op_assign
l_string|&quot;unnamedasoc&quot;
suffix:semicolon
id|asoc-&gt;eyecatcher
op_assign
id|SCTP_ASSOC_EYECATCHER
suffix:semicolon
multiline_comment|/* Assume that peer would support both address types unless we are&n;&t; * told otherwise.&n;&t; */
id|asoc-&gt;peer.ipv4_address
op_assign
l_int|1
suffix:semicolon
id|asoc-&gt;peer.ipv6_address
op_assign
l_int|1
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|asoc-&gt;asocs
)paren
suffix:semicolon
id|asoc-&gt;autoclose
op_assign
id|sp-&gt;autoclose
suffix:semicolon
r_return
id|asoc
suffix:semicolon
id|fail_init
suffix:colon
id|sctp_endpoint_put
c_func
(paren
id|asoc-&gt;ep
)paren
suffix:semicolon
id|sock_put
c_func
(paren
id|asoc-&gt;base.sk
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Free this association if possible.  There may still be users, so&n; * the actual deallocation may be delayed.&n; */
DECL|function|sctp_association_free
r_void
id|sctp_association_free
c_func
(paren
id|sctp_association_t
op_star
id|asoc
)paren
(brace
r_struct
id|sctp_transport
op_star
id|transport
suffix:semicolon
id|sctp_endpoint_t
op_star
id|ep
suffix:semicolon
r_struct
id|list_head
op_star
id|pos
comma
op_star
id|temp
suffix:semicolon
r_int
id|i
suffix:semicolon
id|ep
op_assign
id|asoc-&gt;ep
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|asoc-&gt;asocs
)paren
suffix:semicolon
multiline_comment|/* Mark as dead, so other users can know this structure is&n;&t; * going away.&n;&t; */
id|asoc-&gt;base.dead
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Dispose of any data lying around in the outqueue. */
id|sctp_outq_free
c_func
(paren
op_amp
id|asoc-&gt;outqueue
)paren
suffix:semicolon
multiline_comment|/* Dispose of any pending messages for the upper layer. */
id|sctp_ulpq_free
c_func
(paren
op_amp
id|asoc-&gt;ulpq
)paren
suffix:semicolon
multiline_comment|/* Dispose of any pending chunks on the inqueue. */
id|sctp_inqueue_free
c_func
(paren
op_amp
id|asoc-&gt;base.inqueue
)paren
suffix:semicolon
multiline_comment|/* Free ssnmap storage. */
id|sctp_ssnmap_free
c_func
(paren
id|asoc-&gt;ssnmap
)paren
suffix:semicolon
multiline_comment|/* Clean up the bound address list. */
id|sctp_bind_addr_free
c_func
(paren
op_amp
id|asoc-&gt;base.bind_addr
)paren
suffix:semicolon
multiline_comment|/* Do we need to go through all of our timers and&n;&t; * delete them?   To be safe we will try to delete all, but we&n;&t; * should be able to go through and make a guess based&n;&t; * on our state.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
id|SCTP_EVENT_TIMEOUT_NONE
suffix:semicolon
id|i
OL
id|SCTP_NUM_TIMEOUT_TYPES
suffix:semicolon
op_increment
id|i
)paren
(brace
r_if
c_cond
(paren
id|timer_pending
c_func
(paren
op_amp
id|asoc-&gt;timers
(braket
id|i
)braket
)paren
op_logical_and
id|del_timer
c_func
(paren
op_amp
id|asoc-&gt;timers
(braket
id|i
)braket
)paren
)paren
id|sctp_association_put
c_func
(paren
id|asoc
)paren
suffix:semicolon
)brace
multiline_comment|/* Free peer&squot;s cached cookie. */
r_if
c_cond
(paren
id|asoc-&gt;peer.cookie
)paren
(brace
id|kfree
c_func
(paren
id|asoc-&gt;peer.cookie
)paren
suffix:semicolon
)brace
multiline_comment|/* Release the transport structures. */
id|list_for_each_safe
c_func
(paren
id|pos
comma
id|temp
comma
op_amp
id|asoc-&gt;peer.transport_addr_list
)paren
(brace
id|transport
op_assign
id|list_entry
c_func
(paren
id|pos
comma
r_struct
id|sctp_transport
comma
id|transports
)paren
suffix:semicolon
id|list_del
c_func
(paren
id|pos
)paren
suffix:semicolon
id|sctp_transport_free
c_func
(paren
id|transport
)paren
suffix:semicolon
)brace
id|asoc-&gt;eyecatcher
op_assign
l_int|0
suffix:semicolon
id|sctp_association_put
c_func
(paren
id|asoc
)paren
suffix:semicolon
)brace
multiline_comment|/* Cleanup and free up an association. */
DECL|function|sctp_association_destroy
r_static
r_void
id|sctp_association_destroy
c_func
(paren
id|sctp_association_t
op_star
id|asoc
)paren
(brace
id|SCTP_ASSERT
c_func
(paren
id|asoc-&gt;base.dead
comma
l_string|&quot;Assoc is not dead&quot;
comma
r_return
)paren
suffix:semicolon
id|sctp_endpoint_put
c_func
(paren
id|asoc-&gt;ep
)paren
suffix:semicolon
id|sock_put
c_func
(paren
id|asoc-&gt;base.sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|asoc-&gt;base.malloced
)paren
(brace
id|kfree
c_func
(paren
id|asoc
)paren
suffix:semicolon
id|SCTP_DBG_OBJCNT_DEC
c_func
(paren
id|assoc
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Add a transport address to an association.  */
DECL|function|sctp_assoc_add_peer
r_struct
id|sctp_transport
op_star
id|sctp_assoc_add_peer
c_func
(paren
id|sctp_association_t
op_star
id|asoc
comma
r_const
r_union
id|sctp_addr
op_star
id|addr
comma
r_int
id|priority
)paren
(brace
r_struct
id|sctp_transport
op_star
id|peer
suffix:semicolon
id|sctp_opt_t
op_star
id|sp
suffix:semicolon
r_int
r_int
id|port
suffix:semicolon
multiline_comment|/* AF_INET and AF_INET6 share common port field. */
id|port
op_assign
id|addr-&gt;v4.sin_port
suffix:semicolon
multiline_comment|/* Set the port if it has not been set yet.  */
r_if
c_cond
(paren
l_int|0
op_eq
id|asoc-&gt;peer.port
)paren
(brace
id|asoc-&gt;peer.port
op_assign
id|port
suffix:semicolon
)brace
multiline_comment|/* Check to see if this is a duplicate. */
id|peer
op_assign
id|sctp_assoc_lookup_paddr
c_func
(paren
id|asoc
comma
id|addr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|peer
)paren
r_return
id|peer
suffix:semicolon
id|peer
op_assign
id|sctp_transport_new
c_func
(paren
id|addr
comma
id|priority
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|peer
)paren
r_return
l_int|NULL
suffix:semicolon
id|sctp_transport_set_owner
c_func
(paren
id|peer
comma
id|asoc
)paren
suffix:semicolon
multiline_comment|/* Initialize the pmtu of the transport. */
id|sctp_transport_pmtu
c_func
(paren
id|peer
)paren
suffix:semicolon
multiline_comment|/* If this is the first transport addr on this association,&n;&t; * initialize the association PMTU to the peer&squot;s PMTU.&n;&t; * If not and the current association PMTU is higher than the new&n;&t; * peer&squot;s PMTU, reset the association PMTU to the new peer&squot;s PMTU.&n;&t; */
r_if
c_cond
(paren
id|asoc-&gt;pmtu
)paren
(brace
id|asoc-&gt;pmtu
op_assign
id|min_t
c_func
(paren
r_int
comma
id|peer-&gt;pmtu
comma
id|asoc-&gt;pmtu
)paren
suffix:semicolon
)brace
r_else
(brace
id|asoc-&gt;pmtu
op_assign
id|peer-&gt;pmtu
suffix:semicolon
)brace
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;sctp_assoc_add_peer:association %p PMTU set to &quot;
l_string|&quot;%d&bslash;n&quot;
comma
id|asoc
comma
id|asoc-&gt;pmtu
)paren
suffix:semicolon
id|asoc-&gt;frag_point
op_assign
id|asoc-&gt;pmtu
op_minus
(paren
id|SCTP_IP_OVERHEAD
op_plus
r_sizeof
(paren
id|sctp_data_chunk_t
)paren
)paren
suffix:semicolon
multiline_comment|/* The asoc-&gt;peer.port might not be meaningful yet, but&n;&t; * initialize the packet structure anyway.&n;&t; */
(paren
id|asoc-&gt;outqueue.init_output
)paren
(paren
op_amp
id|peer-&gt;packet
comma
id|peer
comma
id|asoc-&gt;base.bind_addr.port
comma
id|asoc-&gt;peer.port
)paren
suffix:semicolon
multiline_comment|/* 7.2.1 Slow-Start&n;&t; *&n;&t; * o The initial cwnd before data transmission or after a&n;&t; *   sufficiently long idle period MUST be &lt;= 2*MTU.&n;&t; *&n;&t; * o The initial value of ssthresh MAY be arbitrarily high&n;&t; *   (for example, implementations MAY use the size of the&n;&t; *   receiver advertised window).&n;&t; */
id|peer-&gt;cwnd
op_assign
id|asoc-&gt;pmtu
op_star
l_int|2
suffix:semicolon
multiline_comment|/* At this point, we may not have the receiver&squot;s advertised window,&n;&t; * so initialize ssthresh to the default value and it will be set&n;&t; * later when we process the INIT.&n;&t; */
id|peer-&gt;ssthresh
op_assign
id|SCTP_DEFAULT_MAXWINDOW
suffix:semicolon
id|peer-&gt;partial_bytes_acked
op_assign
l_int|0
suffix:semicolon
id|peer-&gt;flight_size
op_assign
l_int|0
suffix:semicolon
id|peer-&gt;error_threshold
op_assign
id|peer-&gt;max_retrans
suffix:semicolon
multiline_comment|/* Update the overall error threshold value of the association&n;&t; * taking the new peer&squot;s error threshold into account.&n;&t; */
id|asoc-&gt;overall_error_threshold
op_assign
id|min
c_func
(paren
id|asoc-&gt;overall_error_threshold
op_plus
id|peer-&gt;error_threshold
comma
id|asoc-&gt;max_retrans
)paren
suffix:semicolon
multiline_comment|/* By default, enable heartbeat for peer address. */
id|peer-&gt;hb_allowed
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Initialize the peer&squot;s heartbeat interval based on the&n;&t; * sock configured value.&n;&t; */
id|sp
op_assign
id|sctp_sk
c_func
(paren
id|asoc-&gt;base.sk
)paren
suffix:semicolon
id|peer-&gt;hb_interval
op_assign
id|sp-&gt;paddrparam.spp_hbinterval
op_star
id|HZ
suffix:semicolon
multiline_comment|/* Attach the remote transport to our asoc.  */
id|list_add_tail
c_func
(paren
op_amp
id|peer-&gt;transports
comma
op_amp
id|asoc-&gt;peer.transport_addr_list
)paren
suffix:semicolon
multiline_comment|/* If we do not yet have a primary path, set one.  */
r_if
c_cond
(paren
l_int|NULL
op_eq
id|asoc-&gt;peer.primary_path
)paren
(brace
id|asoc-&gt;peer.primary_path
op_assign
id|peer
suffix:semicolon
multiline_comment|/* Set a default msg_name for events. */
id|memcpy
c_func
(paren
op_amp
id|asoc-&gt;peer.primary_addr
comma
op_amp
id|peer-&gt;ipaddr
comma
r_sizeof
(paren
r_union
id|sctp_addr
)paren
)paren
suffix:semicolon
id|asoc-&gt;peer.active_path
op_assign
id|peer
suffix:semicolon
id|asoc-&gt;peer.retran_path
op_assign
id|peer
suffix:semicolon
)brace
r_if
c_cond
(paren
id|asoc-&gt;peer.active_path
op_eq
id|asoc-&gt;peer.retran_path
)paren
id|asoc-&gt;peer.retran_path
op_assign
id|peer
suffix:semicolon
r_return
id|peer
suffix:semicolon
)brace
multiline_comment|/* Lookup a transport by address. */
DECL|function|sctp_assoc_lookup_paddr
r_struct
id|sctp_transport
op_star
id|sctp_assoc_lookup_paddr
c_func
(paren
r_const
id|sctp_association_t
op_star
id|asoc
comma
r_const
r_union
id|sctp_addr
op_star
id|address
)paren
(brace
r_struct
id|sctp_transport
op_star
id|t
suffix:semicolon
r_struct
id|list_head
op_star
id|pos
suffix:semicolon
multiline_comment|/* Cycle through all transports searching for a peer address. */
id|list_for_each
c_func
(paren
id|pos
comma
op_amp
id|asoc-&gt;peer.transport_addr_list
)paren
(brace
id|t
op_assign
id|list_entry
c_func
(paren
id|pos
comma
r_struct
id|sctp_transport
comma
id|transports
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sctp_cmp_addr_exact
c_func
(paren
id|address
comma
op_amp
id|t-&gt;ipaddr
)paren
)paren
r_return
id|t
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Engage in transport control operations.&n; * Mark the transport up or down and send a notification to the user.&n; * Select and update the new active and retran paths.&n; */
DECL|function|sctp_assoc_control_transport
r_void
id|sctp_assoc_control_transport
c_func
(paren
id|sctp_association_t
op_star
id|asoc
comma
r_struct
id|sctp_transport
op_star
id|transport
comma
id|sctp_transport_cmd_t
id|command
comma
id|sctp_sn_error_t
id|error
)paren
(brace
r_struct
id|sctp_transport
op_star
id|t
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|sctp_transport
op_star
id|first
suffix:semicolon
r_struct
id|sctp_transport
op_star
id|second
suffix:semicolon
id|sctp_ulpevent_t
op_star
id|event
suffix:semicolon
r_struct
id|list_head
op_star
id|pos
suffix:semicolon
r_int
id|spc_state
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Record the transition on the transport.  */
r_switch
c_cond
(paren
id|command
)paren
(brace
r_case
id|SCTP_TRANSPORT_UP
suffix:colon
id|transport-&gt;active
op_assign
l_int|1
suffix:semicolon
id|spc_state
op_assign
id|ADDRESS_AVAILABLE
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_TRANSPORT_DOWN
suffix:colon
id|transport-&gt;active
op_assign
l_int|0
suffix:semicolon
id|spc_state
op_assign
id|ADDRESS_UNREACHABLE
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* Generate and send a SCTP_PEER_ADDR_CHANGE notification to the&n;&t; * user.&n;&t; */
id|event
op_assign
id|sctp_ulpevent_make_peer_addr_change
c_func
(paren
id|asoc
comma
(paren
r_struct
id|sockaddr_storage
op_star
)paren
op_amp
id|transport-&gt;ipaddr
comma
l_int|0
comma
id|spc_state
comma
id|error
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|event
)paren
id|sctp_ulpq_tail_event
c_func
(paren
op_amp
id|asoc-&gt;ulpq
comma
id|event
)paren
suffix:semicolon
multiline_comment|/* Select new active and retran paths. */
multiline_comment|/* Look for the two most recently used active transports.&n;&t; *&n;&t; * This code produces the wrong ordering whenever jiffies&n;&t; * rolls over, but we still get usable transports, so we don&squot;t&n;&t; * worry about it.&n;&t; */
id|first
op_assign
l_int|NULL
suffix:semicolon
id|second
op_assign
l_int|NULL
suffix:semicolon
id|list_for_each
c_func
(paren
id|pos
comma
op_amp
id|asoc-&gt;peer.transport_addr_list
)paren
(brace
id|t
op_assign
id|list_entry
c_func
(paren
id|pos
comma
r_struct
id|sctp_transport
comma
id|transports
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|t-&gt;active
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|first
op_logical_or
id|t-&gt;last_time_heard
OG
id|first-&gt;last_time_heard
)paren
(brace
id|second
op_assign
id|first
suffix:semicolon
id|first
op_assign
id|t
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|second
op_logical_or
id|t-&gt;last_time_heard
OG
id|second-&gt;last_time_heard
)paren
id|second
op_assign
id|t
suffix:semicolon
)brace
multiline_comment|/* RFC 2960 6.4 Multi-Homed SCTP Endpoints&n;&t; *&n;&t; * By default, an endpoint should always transmit to the&n;&t; * primary path, unless the SCTP user explicitly specifies the&n;&t; * destination transport address (and possibly source&n;&t; * transport address) to use.&n;&t; *&n;&t; * [If the primary is active but not most recent, bump the most&n;&t; * recently used transport.]&n;&t; */
r_if
c_cond
(paren
id|asoc-&gt;peer.primary_path-&gt;active
op_logical_and
id|first
op_ne
id|asoc-&gt;peer.primary_path
)paren
(brace
id|second
op_assign
id|first
suffix:semicolon
id|first
op_assign
id|asoc-&gt;peer.primary_path
suffix:semicolon
)brace
multiline_comment|/* If we failed to find a usable transport, just camp on the&n;&t; * primary, even if it is inactive.&n;&t; */
r_if
c_cond
(paren
l_int|NULL
op_eq
id|first
)paren
(brace
id|first
op_assign
id|asoc-&gt;peer.primary_path
suffix:semicolon
id|second
op_assign
id|asoc-&gt;peer.primary_path
suffix:semicolon
)brace
multiline_comment|/* Set the active and retran transports.  */
id|asoc-&gt;peer.active_path
op_assign
id|first
suffix:semicolon
id|asoc-&gt;peer.retran_path
op_assign
id|second
suffix:semicolon
)brace
multiline_comment|/* Hold a reference to an association. */
DECL|function|sctp_association_hold
r_void
id|sctp_association_hold
c_func
(paren
id|sctp_association_t
op_star
id|asoc
)paren
(brace
id|atomic_inc
c_func
(paren
op_amp
id|asoc-&gt;base.refcnt
)paren
suffix:semicolon
)brace
multiline_comment|/* Release a reference to an association and cleanup&n; * if there are no more references.&n; */
DECL|function|sctp_association_put
r_void
id|sctp_association_put
c_func
(paren
id|sctp_association_t
op_star
id|asoc
)paren
(brace
r_if
c_cond
(paren
id|atomic_dec_and_test
c_func
(paren
op_amp
id|asoc-&gt;base.refcnt
)paren
)paren
id|sctp_association_destroy
c_func
(paren
id|asoc
)paren
suffix:semicolon
)brace
multiline_comment|/* Allocate the next TSN, Transmission Sequence Number, for the given&n; * association.&n; */
DECL|function|__sctp_association_get_next_tsn
id|__u32
id|__sctp_association_get_next_tsn
c_func
(paren
id|sctp_association_t
op_star
id|asoc
)paren
(brace
multiline_comment|/* From Section 1.6 Serial Number Arithmetic:&n;&t; * Transmission Sequence Numbers wrap around when they reach&n;&t; * 2**32 - 1.  That is, the next TSN a DATA chunk MUST use&n;&t; * after transmitting TSN = 2*32 - 1 is TSN = 0.&n;&t; */
id|__u32
id|retval
op_assign
id|asoc-&gt;next_tsn
suffix:semicolon
id|asoc-&gt;next_tsn
op_increment
suffix:semicolon
id|asoc-&gt;unack_data
op_increment
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/* Allocate &squot;num&squot; TSNs by incrementing the association&squot;s TSN by num. */
DECL|function|__sctp_association_get_tsn_block
id|__u32
id|__sctp_association_get_tsn_block
c_func
(paren
id|sctp_association_t
op_star
id|asoc
comma
r_int
id|num
)paren
(brace
id|__u32
id|retval
op_assign
id|asoc-&gt;next_tsn
suffix:semicolon
id|asoc-&gt;next_tsn
op_add_assign
id|num
suffix:semicolon
id|asoc-&gt;unack_data
op_add_assign
id|num
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/* Compare two addresses to see if they match.  Wildcard addresses&n; * only match themselves.&n; *&n; * FIXME: We do not match address scopes correctly.&n; */
DECL|function|sctp_cmp_addr_exact
r_int
id|sctp_cmp_addr_exact
c_func
(paren
r_const
r_union
id|sctp_addr
op_star
id|ss1
comma
r_const
r_union
id|sctp_addr
op_star
id|ss2
)paren
(brace
r_struct
id|sctp_af
op_star
id|af
suffix:semicolon
id|af
op_assign
id|sctp_get_af_specific
c_func
(paren
id|ss1-&gt;sa.sa_family
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|af
)paren
r_return
l_int|0
suffix:semicolon
r_return
id|af
op_member_access_from_pointer
id|cmp_addr
c_func
(paren
id|ss1
comma
id|ss2
)paren
suffix:semicolon
)brace
multiline_comment|/* Return an ecne chunk to get prepended to a packet.&n; * Note:  We are sly and return a shared, prealloced chunk.&n; */
DECL|function|sctp_get_ecne_prepend
id|sctp_chunk_t
op_star
id|sctp_get_ecne_prepend
c_func
(paren
id|sctp_association_t
op_star
id|asoc
)paren
(brace
id|sctp_chunk_t
op_star
id|chunk
suffix:semicolon
r_int
id|need_ecne
suffix:semicolon
id|__u32
id|lowest_tsn
suffix:semicolon
multiline_comment|/* Can be called from task or bh.   Both need_ecne and&n;&t; * last_ecne_tsn are written during bh.&n;&t; */
id|need_ecne
op_assign
id|asoc-&gt;need_ecne
suffix:semicolon
id|lowest_tsn
op_assign
id|asoc-&gt;last_ecne_tsn
suffix:semicolon
r_if
c_cond
(paren
id|need_ecne
)paren
(brace
id|chunk
op_assign
id|sctp_make_ecne
c_func
(paren
id|asoc
comma
id|lowest_tsn
)paren
suffix:semicolon
multiline_comment|/* ECNE is not mandatory to the flow.  Being unable to&n;&t;&t; * alloc mem is not deadly.  We are just unable to help&n;&t;&t; * out the network.  If we run out of memory, just return&n;&t;&t; * NULL.&n;&t;&t; */
)brace
r_else
(brace
id|chunk
op_assign
l_int|NULL
suffix:semicolon
)brace
r_return
id|chunk
suffix:semicolon
)brace
multiline_comment|/* Use this function for the packet prepend callback when no ECNE&n; * packet is desired (e.g. some packets don&squot;t like to be bundled).&n; */
DECL|function|sctp_get_no_prepend
id|sctp_chunk_t
op_star
id|sctp_get_no_prepend
c_func
(paren
id|sctp_association_t
op_star
id|asoc
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * Find which transport this TSN was sent on.&n; */
DECL|function|sctp_assoc_lookup_tsn
r_struct
id|sctp_transport
op_star
id|sctp_assoc_lookup_tsn
c_func
(paren
id|sctp_association_t
op_star
id|asoc
comma
id|__u32
id|tsn
)paren
(brace
r_struct
id|sctp_transport
op_star
id|active
suffix:semicolon
r_struct
id|sctp_transport
op_star
id|match
suffix:semicolon
r_struct
id|list_head
op_star
id|entry
comma
op_star
id|pos
suffix:semicolon
r_struct
id|sctp_transport
op_star
id|transport
suffix:semicolon
id|sctp_chunk_t
op_star
id|chunk
suffix:semicolon
id|__u32
id|key
op_assign
id|htonl
c_func
(paren
id|tsn
)paren
suffix:semicolon
id|match
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * FIXME: In general, find a more efficient data structure for&n;&t; * searching.&n;&t; */
multiline_comment|/*&n;&t; * The general strategy is to search each transport&squot;s transmitted&n;&t; * list.   Return which transport this TSN lives on.&n;&t; *&n;&t; * Let&squot;s be hopeful and check the active_path first.&n;&t; * Another optimization would be to know if there is only one&n;&t; * outbound path and not have to look for the TSN at all.&n;&t; *&n;&t; */
id|active
op_assign
id|asoc-&gt;peer.active_path
suffix:semicolon
id|list_for_each
c_func
(paren
id|entry
comma
op_amp
id|active-&gt;transmitted
)paren
(brace
id|chunk
op_assign
id|list_entry
c_func
(paren
id|entry
comma
id|sctp_chunk_t
comma
id|transmitted_list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|key
op_eq
id|chunk-&gt;subh.data_hdr-&gt;tsn
)paren
(brace
id|match
op_assign
id|active
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
)brace
multiline_comment|/* If not found, go search all the other transports. */
id|list_for_each
c_func
(paren
id|pos
comma
op_amp
id|asoc-&gt;peer.transport_addr_list
)paren
(brace
id|transport
op_assign
id|list_entry
c_func
(paren
id|pos
comma
r_struct
id|sctp_transport
comma
id|transports
)paren
suffix:semicolon
r_if
c_cond
(paren
id|transport
op_eq
id|active
)paren
r_break
suffix:semicolon
id|list_for_each
c_func
(paren
id|entry
comma
op_amp
id|transport-&gt;transmitted
)paren
(brace
id|chunk
op_assign
id|list_entry
c_func
(paren
id|entry
comma
id|sctp_chunk_t
comma
id|transmitted_list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|key
op_eq
id|chunk-&gt;subh.data_hdr-&gt;tsn
)paren
(brace
id|match
op_assign
id|transport
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
)brace
)brace
id|out
suffix:colon
r_return
id|match
suffix:semicolon
)brace
multiline_comment|/* Is this the association we are looking for? */
DECL|function|sctp_assoc_is_match
r_struct
id|sctp_transport
op_star
id|sctp_assoc_is_match
c_func
(paren
id|sctp_association_t
op_star
id|asoc
comma
r_const
r_union
id|sctp_addr
op_star
id|laddr
comma
r_const
r_union
id|sctp_addr
op_star
id|paddr
)paren
(brace
r_struct
id|sctp_transport
op_star
id|transport
suffix:semicolon
id|sctp_read_lock
c_func
(paren
op_amp
id|asoc-&gt;base.addr_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|asoc-&gt;base.bind_addr.port
op_eq
id|laddr-&gt;v4.sin_port
)paren
op_logical_and
(paren
id|asoc-&gt;peer.port
op_eq
id|paddr-&gt;v4.sin_port
)paren
)paren
(brace
id|transport
op_assign
id|sctp_assoc_lookup_paddr
c_func
(paren
id|asoc
comma
id|paddr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|transport
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|sctp_bind_addr_match
c_func
(paren
op_amp
id|asoc-&gt;base.bind_addr
comma
id|laddr
comma
id|sctp_sk
c_func
(paren
id|asoc-&gt;base.sk
)paren
)paren
)paren
r_goto
id|out
suffix:semicolon
)brace
id|transport
op_assign
l_int|NULL
suffix:semicolon
id|out
suffix:colon
id|sctp_read_unlock
c_func
(paren
op_amp
id|asoc-&gt;base.addr_lock
)paren
suffix:semicolon
r_return
id|transport
suffix:semicolon
)brace
multiline_comment|/* Do delayed input processing.  This is scheduled by sctp_rcv(). */
DECL|function|sctp_assoc_bh_rcv
r_static
r_void
id|sctp_assoc_bh_rcv
c_func
(paren
id|sctp_association_t
op_star
id|asoc
)paren
(brace
id|sctp_endpoint_t
op_star
id|ep
suffix:semicolon
id|sctp_chunk_t
op_star
id|chunk
suffix:semicolon
r_struct
id|sock
op_star
id|sk
suffix:semicolon
id|sctp_inqueue_t
op_star
id|inqueue
suffix:semicolon
r_int
id|state
comma
id|subtype
suffix:semicolon
id|sctp_assoc_t
id|associd
op_assign
id|sctp_assoc2id
c_func
(paren
id|asoc
)paren
suffix:semicolon
r_int
id|error
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* The association should be held so we should be safe. */
id|ep
op_assign
id|asoc-&gt;ep
suffix:semicolon
id|sk
op_assign
id|asoc-&gt;base.sk
suffix:semicolon
id|inqueue
op_assign
op_amp
id|asoc-&gt;base.inqueue
suffix:semicolon
r_while
c_loop
(paren
l_int|NULL
op_ne
(paren
id|chunk
op_assign
id|sctp_pop_inqueue
c_func
(paren
id|inqueue
)paren
)paren
)paren
(brace
id|state
op_assign
id|asoc-&gt;state
suffix:semicolon
id|subtype
op_assign
id|chunk-&gt;chunk_hdr-&gt;type
suffix:semicolon
multiline_comment|/* Remember where the last DATA chunk came from so we&n;&t;&t; * know where to send the SACK.&n;&t;&t; */
r_if
c_cond
(paren
id|sctp_chunk_is_data
c_func
(paren
id|chunk
)paren
)paren
id|asoc-&gt;peer.last_data_from
op_assign
id|chunk-&gt;transport
suffix:semicolon
r_if
c_cond
(paren
id|chunk-&gt;transport
)paren
id|chunk-&gt;transport-&gt;last_time_heard
op_assign
id|jiffies
suffix:semicolon
multiline_comment|/* Run through the state machine. */
id|error
op_assign
id|sctp_do_sm
c_func
(paren
id|SCTP_EVENT_T_CHUNK
comma
id|SCTP_ST_CHUNK
c_func
(paren
id|subtype
)paren
comma
id|state
comma
id|ep
comma
id|asoc
comma
id|chunk
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
multiline_comment|/* Check to see if the association is freed in response to&n;&t;&t; * the incoming chunk.  If so, get out of the while loop.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|sctp_id2assoc
c_func
(paren
id|sk
comma
id|associd
)paren
)paren
r_break
suffix:semicolon
multiline_comment|/* If there is an error on chunk, discard this packet. */
r_if
c_cond
(paren
id|error
op_logical_and
id|chunk
)paren
id|chunk-&gt;pdiscard
op_assign
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/* This routine moves an association from its old sk to a new sk.  */
DECL|function|sctp_assoc_migrate
r_void
id|sctp_assoc_migrate
c_func
(paren
id|sctp_association_t
op_star
id|assoc
comma
r_struct
id|sock
op_star
id|newsk
)paren
(brace
id|sctp_opt_t
op_star
id|newsp
op_assign
id|sctp_sk
c_func
(paren
id|newsk
)paren
suffix:semicolon
multiline_comment|/* Delete the association from the old endpoint&squot;s list of&n;&t; * associations.&n;&t; */
id|list_del
c_func
(paren
op_amp
id|assoc-&gt;asocs
)paren
suffix:semicolon
multiline_comment|/* Release references to the old endpoint and the sock.  */
id|sctp_endpoint_put
c_func
(paren
id|assoc-&gt;ep
)paren
suffix:semicolon
id|sock_put
c_func
(paren
id|assoc-&gt;base.sk
)paren
suffix:semicolon
multiline_comment|/* Get a reference to the new endpoint.  */
id|assoc-&gt;ep
op_assign
id|newsp-&gt;ep
suffix:semicolon
id|sctp_endpoint_hold
c_func
(paren
id|assoc-&gt;ep
)paren
suffix:semicolon
multiline_comment|/* Get a reference to the new sock.  */
id|assoc-&gt;base.sk
op_assign
id|newsk
suffix:semicolon
id|sock_hold
c_func
(paren
id|assoc-&gt;base.sk
)paren
suffix:semicolon
multiline_comment|/* Add the association to the new endpoint&squot;s list of associations.  */
id|sctp_endpoint_add_asoc
c_func
(paren
id|newsp-&gt;ep
comma
id|assoc
)paren
suffix:semicolon
)brace
multiline_comment|/* Update an association (possibly from unexpected COOKIE-ECHO processing).  */
DECL|function|sctp_assoc_update
r_void
id|sctp_assoc_update
c_func
(paren
id|sctp_association_t
op_star
id|asoc
comma
id|sctp_association_t
op_star
r_new
)paren
(brace
multiline_comment|/* Copy in new parameters of peer. */
id|asoc-&gt;c
op_assign
r_new
op_member_access_from_pointer
id|c
suffix:semicolon
id|asoc-&gt;peer.rwnd
op_assign
r_new
op_member_access_from_pointer
id|peer.rwnd
suffix:semicolon
id|asoc-&gt;peer.next_dup_tsn
op_assign
r_new
op_member_access_from_pointer
id|peer.next_dup_tsn
suffix:semicolon
id|asoc-&gt;peer.sack_needed
op_assign
r_new
op_member_access_from_pointer
id|peer.sack_needed
suffix:semicolon
id|asoc-&gt;peer.i
op_assign
r_new
op_member_access_from_pointer
id|peer.i
suffix:semicolon
id|sctp_tsnmap_init
c_func
(paren
op_amp
id|asoc-&gt;peer.tsn_map
comma
id|SCTP_TSN_MAP_SIZE
comma
id|asoc-&gt;peer.i.initial_tsn
)paren
suffix:semicolon
multiline_comment|/* FIXME:&n;&t; *    Do we need to copy primary_path etc?&n;&t; *&n;&t; *    More explicitly, addresses may have been removed and&n;&t; *    this needs accounting for.&n;&t; */
multiline_comment|/* If the case is A (association restart), use&n;&t; * initial_tsn as next_tsn. If the case is B, use&n;&t; * current next_tsn in case data sent to peer&n;&t; * has been discarded and needs retransmission.&n;&t; */
r_if
c_cond
(paren
id|SCTP_STATE_ESTABLISHED
op_eq
id|asoc-&gt;state
)paren
(brace
id|asoc-&gt;next_tsn
op_assign
r_new
op_member_access_from_pointer
id|next_tsn
suffix:semicolon
id|asoc-&gt;ctsn_ack_point
op_assign
r_new
op_member_access_from_pointer
id|ctsn_ack_point
suffix:semicolon
multiline_comment|/* Reinitialize SSN for both local streams&n;&t;&t; * and peer&squot;s streams.&n;&t;&t; */
id|sctp_ssnmap_clear
c_func
(paren
id|asoc-&gt;ssnmap
)paren
suffix:semicolon
)brace
r_else
(brace
id|asoc-&gt;ctsn_ack_point
op_assign
id|asoc-&gt;next_tsn
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|asoc-&gt;ssnmap
)paren
(brace
multiline_comment|/* Move the ssnmap. */
id|asoc-&gt;ssnmap
op_assign
r_new
op_member_access_from_pointer
id|ssnmap
suffix:semicolon
r_new
op_member_access_from_pointer
id|ssnmap
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Choose the transport for sending a shutdown packet.&n; * Round-robin through the active transports, else round-robin&n; * through the inactive transports as this is the next best thing&n; * we can try.&n; */
DECL|function|sctp_assoc_choose_shutdown_transport
r_struct
id|sctp_transport
op_star
id|sctp_assoc_choose_shutdown_transport
c_func
(paren
id|sctp_association_t
op_star
id|asoc
)paren
(brace
r_struct
id|sctp_transport
op_star
id|t
comma
op_star
id|next
suffix:semicolon
r_struct
id|list_head
op_star
id|head
op_assign
op_amp
id|asoc-&gt;peer.transport_addr_list
suffix:semicolon
r_struct
id|list_head
op_star
id|pos
suffix:semicolon
multiline_comment|/* If this is the first time SHUTDOWN is sent, use the active&n;&t; * path.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|asoc-&gt;shutdown_last_sent_to
)paren
r_return
id|asoc-&gt;peer.active_path
suffix:semicolon
multiline_comment|/* Otherwise, find the next transport in a round-robin fashion. */
id|t
op_assign
id|asoc-&gt;shutdown_last_sent_to
suffix:semicolon
id|pos
op_assign
op_amp
id|t-&gt;transports
suffix:semicolon
id|next
op_assign
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
multiline_comment|/* Skip the head. */
r_if
c_cond
(paren
id|pos-&gt;next
op_eq
id|head
)paren
id|pos
op_assign
id|head-&gt;next
suffix:semicolon
r_else
id|pos
op_assign
id|pos-&gt;next
suffix:semicolon
id|t
op_assign
id|list_entry
c_func
(paren
id|pos
comma
r_struct
id|sctp_transport
comma
id|transports
)paren
suffix:semicolon
multiline_comment|/* Try to find an active transport. */
r_if
c_cond
(paren
id|t-&gt;active
)paren
(brace
r_break
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Keep track of the next transport in case&n;&t;&t;&t; * we don&squot;t find any active transport.&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|next
)paren
id|next
op_assign
id|t
suffix:semicolon
)brace
multiline_comment|/* We have exhausted the list, but didn&squot;t find any&n;&t;&t; * other active transports.  If so, use the next&n;&t;&t; * transport.&n;&t;&t; */
r_if
c_cond
(paren
id|t
op_eq
id|asoc-&gt;shutdown_last_sent_to
)paren
(brace
id|t
op_assign
id|next
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_return
id|t
suffix:semicolon
)brace
multiline_comment|/* Update the association&squot;s pmtu and frag_point by going through all the&n; * transports. This routine is called when a transport&squot;s PMTU has changed.&n; */
DECL|function|sctp_assoc_sync_pmtu
r_void
id|sctp_assoc_sync_pmtu
c_func
(paren
id|sctp_association_t
op_star
id|asoc
)paren
(brace
r_struct
id|sctp_transport
op_star
id|t
suffix:semicolon
r_struct
id|list_head
op_star
id|pos
suffix:semicolon
id|__u32
id|pmtu
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|asoc
)paren
r_return
suffix:semicolon
multiline_comment|/* Get the lowest pmtu of all the transports. */
id|list_for_each
c_func
(paren
id|pos
comma
op_amp
id|asoc-&gt;peer.transport_addr_list
)paren
(brace
id|t
op_assign
id|list_entry
c_func
(paren
id|pos
comma
r_struct
id|sctp_transport
comma
id|transports
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pmtu
op_logical_or
(paren
id|t-&gt;pmtu
OL
id|pmtu
)paren
)paren
id|pmtu
op_assign
id|t-&gt;pmtu
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pmtu
)paren
(brace
id|asoc-&gt;pmtu
op_assign
id|pmtu
suffix:semicolon
id|asoc-&gt;frag_point
op_assign
id|pmtu
op_minus
(paren
id|SCTP_IP_OVERHEAD
op_plus
r_sizeof
(paren
id|sctp_data_chunk_t
)paren
)paren
suffix:semicolon
)brace
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;%s: asoc:%p, pmtu:%d, frag_point:%d&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|asoc
comma
id|asoc-&gt;pmtu
comma
id|asoc-&gt;frag_point
)paren
suffix:semicolon
)brace
multiline_comment|/* Increase asoc&squot;s rwnd by len and send any window update SACK if needed. */
DECL|function|sctp_assoc_rwnd_increase
r_void
id|sctp_assoc_rwnd_increase
c_func
(paren
id|sctp_association_t
op_star
id|asoc
comma
r_int
id|len
)paren
(brace
id|sctp_chunk_t
op_star
id|sack
suffix:semicolon
r_struct
id|timer_list
op_star
id|timer
suffix:semicolon
r_if
c_cond
(paren
id|asoc-&gt;rwnd_over
)paren
(brace
r_if
c_cond
(paren
id|asoc-&gt;rwnd_over
op_ge
id|len
)paren
(brace
id|asoc-&gt;rwnd_over
op_sub_assign
id|len
suffix:semicolon
)brace
r_else
(brace
id|asoc-&gt;rwnd
op_add_assign
(paren
id|len
op_minus
id|asoc-&gt;rwnd_over
)paren
suffix:semicolon
id|asoc-&gt;rwnd_over
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_else
(brace
id|asoc-&gt;rwnd
op_add_assign
id|len
suffix:semicolon
)brace
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;%s: asoc %p rwnd increased by %d to (%u, %u) - %u&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|asoc
comma
id|len
comma
id|asoc-&gt;rwnd
comma
id|asoc-&gt;rwnd_over
comma
id|asoc-&gt;a_rwnd
)paren
suffix:semicolon
multiline_comment|/* Send a window update SACK if the rwnd has increased by at least the&n;&t; * minimum of the association&squot;s PMTU and half of the receive buffer.&n;&t; * The algorithm used is similar to the one described in &n;&t; * Section 4.2.3.3 of RFC 1122.&n;&t; */
r_if
c_cond
(paren
(paren
id|asoc-&gt;state
op_eq
id|SCTP_STATE_ESTABLISHED
)paren
op_logical_and
(paren
id|asoc-&gt;rwnd
OG
id|asoc-&gt;a_rwnd
)paren
op_logical_and
(paren
(paren
id|asoc-&gt;rwnd
op_minus
id|asoc-&gt;a_rwnd
)paren
op_ge
id|min_t
c_func
(paren
id|__u32
comma
(paren
id|asoc-&gt;base.sk-&gt;rcvbuf
op_rshift
l_int|1
)paren
comma
id|asoc-&gt;pmtu
)paren
)paren
)paren
(brace
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;%s: Sending window update SACK- asoc: %p &quot;
l_string|&quot;rwnd: %u a_rwnd: %u&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|asoc
comma
id|asoc-&gt;rwnd
comma
id|asoc-&gt;a_rwnd
)paren
suffix:semicolon
id|sack
op_assign
id|sctp_make_sack
c_func
(paren
id|asoc
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sack
)paren
r_return
suffix:semicolon
multiline_comment|/* Update the last advertised rwnd value. */
id|asoc-&gt;a_rwnd
op_assign
id|asoc-&gt;rwnd
suffix:semicolon
id|asoc-&gt;peer.sack_needed
op_assign
l_int|0
suffix:semicolon
id|asoc-&gt;peer.next_dup_tsn
op_assign
l_int|0
suffix:semicolon
id|sctp_outq_tail
c_func
(paren
op_amp
id|asoc-&gt;outqueue
comma
id|sack
)paren
suffix:semicolon
multiline_comment|/* Stop the SACK timer.  */
id|timer
op_assign
op_amp
id|asoc-&gt;timers
(braket
id|SCTP_EVENT_TIMEOUT_SACK
)braket
suffix:semicolon
r_if
c_cond
(paren
id|timer_pending
c_func
(paren
id|timer
)paren
op_logical_and
id|del_timer
c_func
(paren
id|timer
)paren
)paren
id|sctp_association_put
c_func
(paren
id|asoc
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Decrease asoc&squot;s rwnd by len. */
DECL|function|sctp_assoc_rwnd_decrease
r_void
id|sctp_assoc_rwnd_decrease
c_func
(paren
id|sctp_association_t
op_star
id|asoc
comma
r_int
id|len
)paren
(brace
id|SCTP_ASSERT
c_func
(paren
id|asoc-&gt;rwnd
comma
l_string|&quot;rwnd zero&quot;
comma
r_return
)paren
suffix:semicolon
id|SCTP_ASSERT
c_func
(paren
op_logical_neg
id|asoc-&gt;rwnd_over
comma
l_string|&quot;rwnd_over not zero&quot;
comma
r_return
)paren
suffix:semicolon
r_if
c_cond
(paren
id|asoc-&gt;rwnd
op_ge
id|len
)paren
(brace
id|asoc-&gt;rwnd
op_sub_assign
id|len
suffix:semicolon
)brace
r_else
(brace
id|asoc-&gt;rwnd_over
op_assign
id|len
op_minus
id|asoc-&gt;rwnd
suffix:semicolon
id|asoc-&gt;rwnd
op_assign
l_int|0
suffix:semicolon
)brace
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;%s: asoc %p rwnd decreased by %d to (%u, %u)&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|asoc
comma
id|len
comma
id|asoc-&gt;rwnd
comma
id|asoc-&gt;rwnd_over
)paren
suffix:semicolon
)brace
multiline_comment|/* Build the bind address list for the association based on info from the&n; * local endpoint and the remote peer.&n; */
DECL|function|sctp_assoc_set_bind_addr_from_ep
r_int
id|sctp_assoc_set_bind_addr_from_ep
c_func
(paren
id|sctp_association_t
op_star
id|asoc
comma
r_int
id|priority
)paren
(brace
id|sctp_scope_t
id|scope
suffix:semicolon
r_int
id|flags
suffix:semicolon
multiline_comment|/* Use scoping rules to determine the subset of addresses from&n;&t; * the endpoint.&n;&t; */
id|scope
op_assign
id|sctp_scope
c_func
(paren
op_amp
id|asoc-&gt;peer.active_path-&gt;ipaddr
)paren
suffix:semicolon
id|flags
op_assign
(paren
id|PF_INET6
op_eq
id|asoc-&gt;base.sk-&gt;family
)paren
ques
c_cond
id|SCTP_ADDR6_ALLOWED
suffix:colon
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|asoc-&gt;peer.ipv4_address
)paren
id|flags
op_or_assign
id|SCTP_ADDR4_PEERSUPP
suffix:semicolon
r_if
c_cond
(paren
id|asoc-&gt;peer.ipv6_address
)paren
id|flags
op_or_assign
id|SCTP_ADDR6_PEERSUPP
suffix:semicolon
r_return
id|sctp_bind_addr_copy
c_func
(paren
op_amp
id|asoc-&gt;base.bind_addr
comma
op_amp
id|asoc-&gt;ep-&gt;base.bind_addr
comma
id|scope
comma
id|priority
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* Build the association&squot;s bind address list from the cookie.  */
DECL|function|sctp_assoc_set_bind_addr_from_cookie
r_int
id|sctp_assoc_set_bind_addr_from_cookie
c_func
(paren
id|sctp_association_t
op_star
id|asoc
comma
id|sctp_cookie_t
op_star
id|cookie
comma
r_int
id|priority
)paren
(brace
r_int
id|var_size2
op_assign
id|ntohs
c_func
(paren
id|cookie-&gt;peer_init-&gt;chunk_hdr.length
)paren
suffix:semicolon
r_int
id|var_size3
op_assign
id|cookie-&gt;raw_addr_list_len
suffix:semicolon
id|__u8
op_star
id|raw_addr_list
op_assign
(paren
id|__u8
op_star
)paren
id|cookie
op_plus
r_sizeof
(paren
id|sctp_cookie_t
)paren
op_plus
id|var_size2
suffix:semicolon
r_return
id|sctp_raw_to_bind_addrs
c_func
(paren
op_amp
id|asoc-&gt;base.bind_addr
comma
id|raw_addr_list
comma
id|var_size3
comma
id|asoc-&gt;ep-&gt;base.bind_addr.port
comma
id|priority
)paren
suffix:semicolon
)brace
eof
