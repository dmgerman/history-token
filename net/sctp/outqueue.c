multiline_comment|/* SCTP kernel reference Implementation&n; * Copyright (c) 1999-2000 Cisco, Inc.&n; * Copyright (c) 1999-2001 Motorola, Inc.&n; * Copyright (c) 2001-2003 Intel Corp.&n; * Copyright (c) 2001-2003 International Business Machines Corp.&n; *&n; * This file is part of the SCTP kernel reference Implementation&n; *&n; * These functions implement the sctp_outq class.   The outqueue handles&n; * bundling and queueing of outgoing SCTP chunks.&n; *&n; * The SCTP reference implementation is free software;&n; * you can redistribute it and/or modify it under the terms of&n; * the GNU General Public License as published by&n; * the Free Software Foundation; either version 2, or (at your option)&n; * any later version.&n; *&n; * The SCTP reference implementation is distributed in the hope that it&n; * will be useful, but WITHOUT ANY WARRANTY; without even the implied&n; *                 ************************&n; * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&n; * See the GNU General Public License for more details.&n; *&n; * You should have received a copy of the GNU General Public License&n; * along with GNU CC; see the file COPYING.  If not, write to&n; * the Free Software Foundation, 59 Temple Place - Suite 330,&n; * Boston, MA 02111-1307, USA.&n; *&n; * Please send any bug reports or fixes you make to the&n; * email address(es):&n; *    lksctp developers &lt;lksctp-developers@lists.sourceforge.net&gt;&n; *&n; * Or submit a bug report through the following website:&n; *    http://www.sf.net/projects/lksctp&n; *&n; * Written or modified by:&n; *    La Monte H.P. Yarroll &lt;piggy@acm.org&gt;&n; *    Karl Knutson          &lt;karl@athena.chicago.il.us&gt;&n; *    Perry Melange         &lt;pmelange@null.cc.uic.edu&gt;&n; *    Xingang Guo           &lt;xingang.guo@intel.com&gt;&n; *    Hui Huang &t;    &lt;hui.huang@nokia.com&gt;&n; *    Sridhar Samudrala     &lt;sri@us.ibm.com&gt;&n; *    Jon Grimm             &lt;jgrimm@us.ibm.com&gt;&n; *&n; * Any bugs reported given to us we will try to fix... any fixes shared will&n; * be incorporated into the next SCTP release.&n; */
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/list.h&gt;   /* For struct list_head */
macro_line|#include &lt;linux/socket.h&gt;
macro_line|#include &lt;linux/ip.h&gt;
macro_line|#include &lt;net/sock.h&gt;&t;  /* For skb_set_owner_w */
macro_line|#include &lt;net/sctp/sctp.h&gt;
multiline_comment|/* Declare internal functions here.  */
r_static
r_int
id|sctp_acked
c_func
(paren
id|sctp_sackhdr_t
op_star
id|sack
comma
id|__u32
id|tsn
)paren
suffix:semicolon
r_static
r_void
id|sctp_check_transmitted
c_func
(paren
r_struct
id|sctp_outq
op_star
id|q
comma
r_struct
id|list_head
op_star
id|transmitted_queue
comma
r_struct
id|sctp_transport
op_star
id|transport
comma
id|sctp_sackhdr_t
op_star
id|sack
comma
id|__u32
id|highest_new_tsn
)paren
suffix:semicolon
multiline_comment|/* Add data to the front of the queue. */
DECL|function|sctp_outq_head_data
r_static
r_inline
r_void
id|sctp_outq_head_data
c_func
(paren
r_struct
id|sctp_outq
op_star
id|q
comma
r_struct
id|sctp_chunk
op_star
id|ch
)paren
(brace
id|__skb_queue_head
c_func
(paren
op_amp
id|q-&gt;out
comma
(paren
r_struct
id|sk_buff
op_star
)paren
id|ch
)paren
suffix:semicolon
id|q-&gt;out_qlen
op_add_assign
id|ch-&gt;skb-&gt;len
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Take data from the front of the queue. */
DECL|function|sctp_outq_dequeue_data
r_static
r_inline
r_struct
id|sctp_chunk
op_star
id|sctp_outq_dequeue_data
c_func
(paren
r_struct
id|sctp_outq
op_star
id|q
)paren
(brace
r_struct
id|sctp_chunk
op_star
id|ch
suffix:semicolon
id|ch
op_assign
(paren
r_struct
id|sctp_chunk
op_star
)paren
id|__skb_dequeue
c_func
(paren
op_amp
id|q-&gt;out
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ch
)paren
id|q-&gt;out_qlen
op_sub_assign
id|ch-&gt;skb-&gt;len
suffix:semicolon
r_return
id|ch
suffix:semicolon
)brace
multiline_comment|/* Add data chunk to the end of the queue. */
DECL|function|sctp_outq_tail_data
r_static
r_inline
r_void
id|sctp_outq_tail_data
c_func
(paren
r_struct
id|sctp_outq
op_star
id|q
comma
r_struct
id|sctp_chunk
op_star
id|ch
)paren
(brace
id|__skb_queue_tail
c_func
(paren
op_amp
id|q-&gt;out
comma
(paren
r_struct
id|sk_buff
op_star
)paren
id|ch
)paren
suffix:semicolon
id|q-&gt;out_qlen
op_add_assign
id|ch-&gt;skb-&gt;len
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Generate a new outqueue.  */
DECL|function|sctp_outq_new
r_struct
id|sctp_outq
op_star
id|sctp_outq_new
c_func
(paren
id|sctp_association_t
op_star
id|asoc
)paren
(brace
r_struct
id|sctp_outq
op_star
id|q
suffix:semicolon
id|q
op_assign
id|t_new
c_func
(paren
r_struct
id|sctp_outq
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|q
)paren
(brace
id|sctp_outq_init
c_func
(paren
id|asoc
comma
id|q
)paren
suffix:semicolon
id|q-&gt;malloced
op_assign
l_int|1
suffix:semicolon
)brace
r_return
id|q
suffix:semicolon
)brace
multiline_comment|/* Initialize an existing sctp_outq.  This does the boring stuff.&n; * You still need to define handlers if you really want to DO&n; * something with this structure...&n; */
DECL|function|sctp_outq_init
r_void
id|sctp_outq_init
c_func
(paren
id|sctp_association_t
op_star
id|asoc
comma
r_struct
id|sctp_outq
op_star
id|q
)paren
(brace
id|q-&gt;asoc
op_assign
id|asoc
suffix:semicolon
id|skb_queue_head_init
c_func
(paren
op_amp
id|q-&gt;out
)paren
suffix:semicolon
id|skb_queue_head_init
c_func
(paren
op_amp
id|q-&gt;control
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|q-&gt;retransmit
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|q-&gt;sacked
)paren
suffix:semicolon
id|q-&gt;init_output
op_assign
l_int|NULL
suffix:semicolon
id|q-&gt;config_output
op_assign
l_int|NULL
suffix:semicolon
id|q-&gt;append_output
op_assign
l_int|NULL
suffix:semicolon
id|q-&gt;build_output
op_assign
l_int|NULL
suffix:semicolon
id|q-&gt;force_output
op_assign
l_int|NULL
suffix:semicolon
id|q-&gt;outstanding_bytes
op_assign
l_int|0
suffix:semicolon
id|q-&gt;empty
op_assign
l_int|1
suffix:semicolon
id|q-&gt;malloced
op_assign
l_int|0
suffix:semicolon
id|q-&gt;out_qlen
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Free the outqueue structure and any related pending chunks.&n; * FIXME: Add SEND_FAILED support.&n; */
DECL|function|sctp_outq_teardown
r_void
id|sctp_outq_teardown
c_func
(paren
r_struct
id|sctp_outq
op_star
id|q
)paren
(brace
r_struct
id|sctp_transport
op_star
id|transport
suffix:semicolon
r_struct
id|list_head
op_star
id|lchunk
comma
op_star
id|pos
comma
op_star
id|temp
suffix:semicolon
id|sctp_chunk_t
op_star
id|chunk
suffix:semicolon
multiline_comment|/* Throw away unacknowledged chunks. */
id|list_for_each
c_func
(paren
id|pos
comma
op_amp
id|q-&gt;asoc-&gt;peer.transport_addr_list
)paren
(brace
id|transport
op_assign
id|list_entry
c_func
(paren
id|pos
comma
r_struct
id|sctp_transport
comma
id|transports
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|lchunk
op_assign
id|sctp_list_dequeue
c_func
(paren
op_amp
id|transport-&gt;transmitted
)paren
)paren
)paren
(brace
id|chunk
op_assign
id|list_entry
c_func
(paren
id|lchunk
comma
id|sctp_chunk_t
comma
id|transmitted_list
)paren
suffix:semicolon
id|sctp_free_chunk
c_func
(paren
id|chunk
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Throw away chunks that have been gap ACKed.  */
id|list_for_each_safe
c_func
(paren
id|lchunk
comma
id|temp
comma
op_amp
id|q-&gt;sacked
)paren
(brace
id|list_del
c_func
(paren
id|lchunk
)paren
suffix:semicolon
id|chunk
op_assign
id|list_entry
c_func
(paren
id|lchunk
comma
id|sctp_chunk_t
comma
id|transmitted_list
)paren
suffix:semicolon
id|sctp_free_chunk
c_func
(paren
id|chunk
)paren
suffix:semicolon
)brace
multiline_comment|/* Throw away any chunks in the retransmit queue. */
id|list_for_each_safe
c_func
(paren
id|lchunk
comma
id|temp
comma
op_amp
id|q-&gt;retransmit
)paren
(brace
id|list_del
c_func
(paren
id|lchunk
)paren
suffix:semicolon
id|chunk
op_assign
id|list_entry
c_func
(paren
id|lchunk
comma
id|sctp_chunk_t
comma
id|transmitted_list
)paren
suffix:semicolon
id|sctp_free_chunk
c_func
(paren
id|chunk
)paren
suffix:semicolon
)brace
multiline_comment|/* Throw away any leftover data chunks. */
r_while
c_loop
(paren
(paren
id|chunk
op_assign
id|sctp_outq_dequeue_data
c_func
(paren
id|q
)paren
)paren
)paren
id|sctp_free_chunk
c_func
(paren
id|chunk
)paren
suffix:semicolon
multiline_comment|/* Throw away any leftover control chunks. */
r_while
c_loop
(paren
(paren
id|chunk
op_assign
(paren
id|sctp_chunk_t
op_star
)paren
id|skb_dequeue
c_func
(paren
op_amp
id|q-&gt;control
)paren
)paren
)paren
id|sctp_free_chunk
c_func
(paren
id|chunk
)paren
suffix:semicolon
)brace
multiline_comment|/* Free the outqueue structure and any related pending chunks.  */
DECL|function|sctp_outq_free
r_void
id|sctp_outq_free
c_func
(paren
r_struct
id|sctp_outq
op_star
id|q
)paren
(brace
multiline_comment|/* Throw away leftover chunks. */
id|sctp_outq_teardown
c_func
(paren
id|q
)paren
suffix:semicolon
multiline_comment|/* If we were kmalloc()&squot;d, free the memory.  */
r_if
c_cond
(paren
id|q-&gt;malloced
)paren
id|kfree
c_func
(paren
id|q
)paren
suffix:semicolon
)brace
multiline_comment|/* Put a new chunk in an sctp_outq.  */
DECL|function|sctp_outq_tail
r_int
id|sctp_outq_tail
c_func
(paren
r_struct
id|sctp_outq
op_star
id|q
comma
id|sctp_chunk_t
op_star
id|chunk
)paren
(brace
r_int
id|error
op_assign
l_int|0
suffix:semicolon
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;sctp_outq_tail(%p, %p[%s])&bslash;n&quot;
comma
id|q
comma
id|chunk
comma
id|chunk
op_logical_and
id|chunk-&gt;chunk_hdr
ques
c_cond
id|sctp_cname
c_func
(paren
id|SCTP_ST_CHUNK
c_func
(paren
id|chunk-&gt;chunk_hdr-&gt;type
)paren
)paren
suffix:colon
l_string|&quot;Illegal Chunk&quot;
)paren
suffix:semicolon
multiline_comment|/* If it is data, queue it up, otherwise, send it&n;&t; * immediately.&n;&t; */
r_if
c_cond
(paren
id|SCTP_CID_DATA
op_eq
id|chunk-&gt;chunk_hdr-&gt;type
)paren
(brace
multiline_comment|/* Is it OK to queue data chunks?  */
multiline_comment|/* From 9. Termination of Association&n;&t;&t; *&n;&t;&t; * When either endpoint performs a shutdown, the&n;&t;&t; * association on each peer will stop accepting new&n;&t;&t; * data from its user and only deliver data in queue&n;&t;&t; * at the time of sending or receiving the SHUTDOWN&n;&t;&t; * chunk.&n;&t;&t; */
r_switch
c_cond
(paren
id|q-&gt;asoc-&gt;state
)paren
(brace
r_case
id|SCTP_STATE_EMPTY
suffix:colon
r_case
id|SCTP_STATE_CLOSED
suffix:colon
r_case
id|SCTP_STATE_SHUTDOWN_PENDING
suffix:colon
r_case
id|SCTP_STATE_SHUTDOWN_SENT
suffix:colon
r_case
id|SCTP_STATE_SHUTDOWN_RECEIVED
suffix:colon
r_case
id|SCTP_STATE_SHUTDOWN_ACK_SENT
suffix:colon
multiline_comment|/* Cannot send after transport endpoint shutdown */
id|error
op_assign
op_minus
id|ESHUTDOWN
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;outqueueing (%p, %p[%s])&bslash;n&quot;
comma
id|q
comma
id|chunk
comma
id|chunk
op_logical_and
id|chunk-&gt;chunk_hdr
ques
c_cond
id|sctp_cname
c_func
(paren
id|SCTP_ST_CHUNK
c_func
(paren
id|chunk-&gt;chunk_hdr-&gt;type
)paren
)paren
suffix:colon
l_string|&quot;Illegal Chunk&quot;
)paren
suffix:semicolon
id|sctp_outq_tail_data
c_func
(paren
id|q
comma
id|chunk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|chunk-&gt;chunk_hdr-&gt;flags
op_amp
id|SCTP_DATA_UNORDERED
)paren
id|SCTP_INC_STATS
c_func
(paren
id|SctpOutUnorderChunks
)paren
suffix:semicolon
r_else
id|SCTP_INC_STATS
c_func
(paren
id|SctpOutOrderChunks
)paren
suffix:semicolon
id|q-&gt;empty
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
suffix:semicolon
)brace
r_else
(brace
id|__skb_queue_tail
c_func
(paren
op_amp
id|q-&gt;control
comma
(paren
r_struct
id|sk_buff
op_star
)paren
id|chunk
)paren
suffix:semicolon
id|SCTP_INC_STATS
c_func
(paren
id|SctpOutCtrlChunks
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|error
OL
l_int|0
)paren
r_return
id|error
suffix:semicolon
id|error
op_assign
id|sctp_outq_flush
c_func
(paren
id|q
comma
l_int|0
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/* Insert a chunk into the retransmit queue.  Chunks on the retransmit&n; * queue are kept in order, based on the TSNs.&n; */
DECL|function|sctp_retransmit_insert
r_void
id|sctp_retransmit_insert
c_func
(paren
r_struct
id|list_head
op_star
id|tlchunk
comma
r_struct
id|sctp_outq
op_star
id|q
)paren
(brace
r_struct
id|list_head
op_star
id|rlchunk
suffix:semicolon
id|sctp_chunk_t
op_star
id|tchunk
comma
op_star
id|rchunk
suffix:semicolon
id|__u32
id|ttsn
comma
id|rtsn
suffix:semicolon
r_int
id|done
op_assign
l_int|0
suffix:semicolon
id|tchunk
op_assign
id|list_entry
c_func
(paren
id|tlchunk
comma
id|sctp_chunk_t
comma
id|transmitted_list
)paren
suffix:semicolon
id|ttsn
op_assign
id|ntohl
c_func
(paren
id|tchunk-&gt;subh.data_hdr-&gt;tsn
)paren
suffix:semicolon
id|list_for_each
c_func
(paren
id|rlchunk
comma
op_amp
id|q-&gt;retransmit
)paren
(brace
id|rchunk
op_assign
id|list_entry
c_func
(paren
id|rlchunk
comma
id|sctp_chunk_t
comma
id|transmitted_list
)paren
suffix:semicolon
id|rtsn
op_assign
id|ntohl
c_func
(paren
id|rchunk-&gt;subh.data_hdr-&gt;tsn
)paren
suffix:semicolon
r_if
c_cond
(paren
id|TSN_lt
c_func
(paren
id|ttsn
comma
id|rtsn
)paren
)paren
(brace
id|list_add
c_func
(paren
id|tlchunk
comma
id|rlchunk-&gt;prev
)paren
suffix:semicolon
id|done
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|done
)paren
(brace
id|list_add_tail
c_func
(paren
id|tlchunk
comma
op_amp
id|q-&gt;retransmit
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Mark all the eligible packets on a transport for retransmission.  */
DECL|function|sctp_retransmit_mark
r_void
id|sctp_retransmit_mark
c_func
(paren
r_struct
id|sctp_outq
op_star
id|q
comma
r_struct
id|sctp_transport
op_star
id|transport
comma
id|__u8
id|fast_retransmit
)paren
(brace
r_struct
id|list_head
op_star
id|lchunk
comma
op_star
id|ltemp
suffix:semicolon
id|sctp_chunk_t
op_star
id|chunk
suffix:semicolon
multiline_comment|/* Walk through the specified transmitted queue.  */
id|list_for_each_safe
c_func
(paren
id|lchunk
comma
id|ltemp
comma
op_amp
id|transport-&gt;transmitted
)paren
(brace
id|chunk
op_assign
id|list_entry
c_func
(paren
id|lchunk
comma
id|sctp_chunk_t
comma
id|transmitted_list
)paren
suffix:semicolon
multiline_comment|/* If we are doing retransmission due to a fast retransmit,&n;&t;&t; * only the chunk&squot;s that are marked for fast retransmit&n;&t;&t; * should be added to the retransmit queue.  If we are doing&n;&t;&t; * retransmission due to a timeout or pmtu discovery, only the&n;&t;&t; * chunks that are not yet acked should be added to the&n;&t;&t; * retransmit queue.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|fast_retransmit
op_logical_and
id|chunk-&gt;fast_retransmit
)paren
op_logical_or
(paren
op_logical_neg
id|fast_retransmit
op_logical_and
op_logical_neg
id|chunk-&gt;tsn_gap_acked
)paren
)paren
(brace
multiline_comment|/* RFC 2960 6.2.1 Processing a Received SACK&n;&t;&t;&t; *&n;&t;&t;&t; * C) Any time a DATA chunk is marked for&n;&t;&t;&t; * retransmission (via either T3-rtx timer expiration&n;&t;&t;&t; * (Section 6.3.3) or via fast retransmit&n;&t;&t;&t; * (Section 7.2.4)), add the data size of those&n;&t;&t;&t; * chunks to the rwnd.&n;&t;&t;&t; */
id|q-&gt;asoc-&gt;peer.rwnd
op_add_assign
id|sctp_data_size
c_func
(paren
id|chunk
)paren
suffix:semicolon
id|q-&gt;outstanding_bytes
op_sub_assign
id|sctp_data_size
c_func
(paren
id|chunk
)paren
suffix:semicolon
id|transport-&gt;flight_size
op_sub_assign
id|sctp_data_size
c_func
(paren
id|chunk
)paren
suffix:semicolon
multiline_comment|/* sctpimpguide-05 Section 2.8.2&n;&t;&t;&t; * M5) If a T3-rtx timer expires, the&n;&t;&t;&t; * &squot;TSN.Missing.Report&squot; of all affected TSNs is set&n;&t;&t;&t; * to 0.&n;&t;&t;&t; */
id|chunk-&gt;tsn_missing_report
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* If a chunk that is being used for RTT measurement&n;&t;&t;&t; * has to be retransmitted, we cannot use this chunk&n;&t;&t;&t; * anymore for RTT measurements. Reset rto_pending so&n;&t;&t;&t; * that a new RTT measurement is started when a new&n;&t;&t;&t; * data chunk is sent.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|chunk-&gt;rtt_in_progress
)paren
(brace
id|chunk-&gt;rtt_in_progress
op_assign
l_int|0
suffix:semicolon
id|transport-&gt;rto_pending
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Move the chunk to the retransmit queue. The chunks&n;&t;&t;&t; * on the retransmit queue is always kept in order.&n;&t;&t;&t; */
id|list_del
c_func
(paren
id|lchunk
)paren
suffix:semicolon
id|sctp_retransmit_insert
c_func
(paren
id|lchunk
comma
id|q
)paren
suffix:semicolon
)brace
)brace
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;%s: transport: %p, fast_retransmit: %d, &quot;
l_string|&quot;cwnd: %d, ssthresh: %d, flight_size: %d, &quot;
l_string|&quot;pba: %d&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|transport
comma
id|fast_retransmit
comma
id|transport-&gt;cwnd
comma
id|transport-&gt;ssthresh
comma
id|transport-&gt;flight_size
comma
id|transport-&gt;partial_bytes_acked
)paren
suffix:semicolon
)brace
multiline_comment|/* Mark all the eligible packets on a transport for retransmission and force&n; * one packet out.&n; */
DECL|function|sctp_retransmit
r_void
id|sctp_retransmit
c_func
(paren
r_struct
id|sctp_outq
op_star
id|q
comma
r_struct
id|sctp_transport
op_star
id|transport
comma
id|sctp_retransmit_reason_t
id|reason
)paren
(brace
r_int
id|error
op_assign
l_int|0
suffix:semicolon
id|__u8
id|fast_retransmit
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|reason
)paren
(brace
r_case
id|SCTP_RETRANSMIT_T3_RTX
suffix:colon
id|sctp_transport_lower_cwnd
c_func
(paren
id|transport
comma
id|SCTP_LOWER_CWND_T3_RTX
)paren
suffix:semicolon
multiline_comment|/* Update the retran path if the T3-rtx timer has expired for&n;&t;&t; * the current retran path.&n;&t;&t; */
r_if
c_cond
(paren
id|transport
op_eq
id|transport-&gt;asoc-&gt;peer.retran_path
)paren
id|sctp_assoc_update_retran_path
c_func
(paren
id|transport-&gt;asoc
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_RETRANSMIT_FAST_RTX
suffix:colon
id|sctp_transport_lower_cwnd
c_func
(paren
id|transport
comma
id|SCTP_LOWER_CWND_FAST_RTX
)paren
suffix:semicolon
id|fast_retransmit
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
id|sctp_retransmit_mark
c_func
(paren
id|q
comma
id|transport
comma
id|fast_retransmit
)paren
suffix:semicolon
id|error
op_assign
id|sctp_outq_flush
c_func
(paren
id|q
comma
multiline_comment|/* rtx_timeout */
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
id|q-&gt;asoc-&gt;base.sk-&gt;err
op_assign
op_minus
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * Transmit DATA chunks on the retransmit queue.  Upon return from&n; * sctp_outq_flush_rtx() the packet &squot;pkt&squot; may contain chunks which&n; * need to be transmitted by the caller.&n; * We assume that pkt-&gt;transport has already been set.&n; *&n; * The return value is a normal kernel error return value.&n; */
DECL|function|sctp_outq_flush_rtx
r_static
r_int
id|sctp_outq_flush_rtx
c_func
(paren
r_struct
id|sctp_outq
op_star
id|q
comma
r_struct
id|sctp_packet
op_star
id|pkt
comma
r_int
id|rtx_timeout
comma
r_int
op_star
id|start_timer
)paren
(brace
r_struct
id|list_head
op_star
id|lqueue
suffix:semicolon
r_struct
id|list_head
op_star
id|lchunk
suffix:semicolon
r_struct
id|sctp_transport
op_star
id|transport
op_assign
id|pkt-&gt;transport
suffix:semicolon
id|sctp_xmit_t
id|status
suffix:semicolon
id|sctp_chunk_t
op_star
id|chunk
suffix:semicolon
id|sctp_association_t
op_star
id|asoc
suffix:semicolon
r_int
id|error
op_assign
l_int|0
suffix:semicolon
id|asoc
op_assign
id|q-&gt;asoc
suffix:semicolon
id|lqueue
op_assign
op_amp
id|q-&gt;retransmit
suffix:semicolon
multiline_comment|/* RFC 2960 6.3.3 Handle T3-rtx Expiration&n;&t; *&n;&t; * E3) Determine how many of the earliest (i.e., lowest TSN)&n;&t; * outstanding DATA chunks for the address for which the&n;&t; * T3-rtx has expired will fit into a single packet, subject&n;&t; * to the MTU constraint for the path corresponding to the&n;&t; * destination transport address to which the retransmission&n;&t; * is being sent (this may be different from the address for&n;&t; * which the timer expires [see Section 6.4]). Call this value&n;&t; * K. Bundle and retransmit those K DATA chunks in a single&n;&t; * packet to the destination endpoint.&n;&t; *&n;&t; * [Just to be painfully clear, if we are retransmitting&n;&t; * because a timeout just happened, we should send only ONE&n;&t; * packet of retransmitted data.]&n;&t; */
id|lchunk
op_assign
id|sctp_list_dequeue
c_func
(paren
id|lqueue
)paren
suffix:semicolon
r_while
c_loop
(paren
id|lchunk
)paren
(brace
id|chunk
op_assign
id|list_entry
c_func
(paren
id|lchunk
comma
id|sctp_chunk_t
comma
id|transmitted_list
)paren
suffix:semicolon
multiline_comment|/* Make sure that Gap Acked TSNs are not retransmitted.  A&n;&t;&t; * simple approach is just to move such TSNs out of the&n;&t;&t; * way and into a &squot;transmitted&squot; queue and skip to the&n;&t;&t; * next chunk.&n;&t;&t; */
r_if
c_cond
(paren
id|chunk-&gt;tsn_gap_acked
)paren
(brace
id|list_add_tail
c_func
(paren
id|lchunk
comma
op_amp
id|transport-&gt;transmitted
)paren
suffix:semicolon
id|lchunk
op_assign
id|sctp_list_dequeue
c_func
(paren
id|lqueue
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* Attempt to append this chunk to the packet. */
id|status
op_assign
(paren
op_star
id|q-&gt;append_output
)paren
(paren
id|pkt
comma
id|chunk
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|status
)paren
(brace
r_case
id|SCTP_XMIT_PMTU_FULL
suffix:colon
multiline_comment|/* Send this packet.  */
r_if
c_cond
(paren
(paren
id|error
op_assign
(paren
op_star
id|q-&gt;force_output
)paren
(paren
id|pkt
)paren
)paren
op_eq
l_int|0
)paren
op_star
id|start_timer
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* If we are retransmitting, we should only&n;&t;&t;&t; * send a single packet.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|rtx_timeout
)paren
(brace
id|list_add
c_func
(paren
id|lchunk
comma
id|lqueue
)paren
suffix:semicolon
id|lchunk
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Bundle lchunk in the next round.  */
r_break
suffix:semicolon
r_case
id|SCTP_XMIT_RWND_FULL
suffix:colon
multiline_comment|/* Send this packet. */
r_if
c_cond
(paren
(paren
id|error
op_assign
(paren
op_star
id|q-&gt;force_output
)paren
(paren
id|pkt
)paren
)paren
op_eq
l_int|0
)paren
op_star
id|start_timer
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Stop sending DATA as there is no more room&n;&t;&t;&t; * at the reciever.&n;&t;&t;&t; */
id|list_add
c_func
(paren
id|lchunk
comma
id|lqueue
)paren
suffix:semicolon
id|lchunk
op_assign
l_int|NULL
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* The append was successful, so add this chunk to&n;&t;&t;&t; * the transmitted list.&n;&t;&t;&t; */
id|list_add_tail
c_func
(paren
id|lchunk
comma
op_amp
id|transport-&gt;transmitted
)paren
suffix:semicolon
op_star
id|start_timer
op_assign
l_int|1
suffix:semicolon
id|q-&gt;empty
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Retrieve a new chunk to bundle. */
id|lchunk
op_assign
id|sctp_list_dequeue
c_func
(paren
id|lqueue
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
suffix:semicolon
)brace
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/* This routine either transmits the fragment or puts it on the output&n; * queue.  &squot;pos&squot; points to the next chunk in the output queue after the&n; * chunk that is currently in the process of fragmentation.&n; */
DECL|function|sctp_xmit_frag
r_void
id|sctp_xmit_frag
c_func
(paren
r_struct
id|sctp_outq
op_star
id|q
comma
r_struct
id|sk_buff
op_star
id|pos
comma
r_struct
id|sctp_packet
op_star
id|packet
comma
id|sctp_chunk_t
op_star
id|frag
comma
id|__u32
id|tsn
)paren
(brace
r_struct
id|sctp_transport
op_star
id|transport
op_assign
id|packet-&gt;transport
suffix:semicolon
r_struct
id|sk_buff_head
op_star
id|queue
op_assign
op_amp
id|q-&gt;out
suffix:semicolon
id|sctp_xmit_t
id|status
suffix:semicolon
r_int
id|error
suffix:semicolon
id|frag-&gt;subh.data_hdr-&gt;tsn
op_assign
id|htonl
c_func
(paren
id|tsn
)paren
suffix:semicolon
id|frag-&gt;has_tsn
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* An inner fragment may be smaller than the earlier one and may get&n;&t; * in if we call q-&gt;build_output.  This ensures that all the fragments&n;&t; * are sent in order.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|skb_queue_empty
c_func
(paren
id|queue
)paren
)paren
(brace
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;sctp_xmit_frag: q not empty. &quot;
l_string|&quot;adding 0x%x to outqueue&bslash;n&quot;
comma
id|ntohl
c_func
(paren
id|frag-&gt;subh.data_hdr-&gt;tsn
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pos
)paren
id|__skb_insert
c_func
(paren
(paren
r_struct
id|sk_buff
op_star
)paren
id|frag
comma
id|pos-&gt;prev
comma
id|pos
comma
id|pos-&gt;list
)paren
suffix:semicolon
r_else
id|__skb_queue_tail
c_func
(paren
id|queue
comma
(paren
r_struct
id|sk_buff
op_star
)paren
id|frag
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Add the chunk fragment to the packet.  */
id|status
op_assign
(paren
op_star
id|q-&gt;build_output
)paren
(paren
id|packet
comma
id|frag
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|status
)paren
(brace
r_case
id|SCTP_XMIT_RWND_FULL
suffix:colon
multiline_comment|/* RWND is full, so put the chunk in the output queue. */
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;sctp_xmit_frag: rwnd full. &quot;
l_string|&quot;adding 0x%x to outqueue&bslash;n&quot;
comma
id|ntohl
c_func
(paren
id|frag-&gt;subh.data_hdr-&gt;tsn
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pos
)paren
id|__skb_insert
c_func
(paren
(paren
r_struct
id|sk_buff
op_star
)paren
id|frag
comma
id|pos-&gt;prev
comma
id|pos
comma
id|pos-&gt;list
)paren
suffix:semicolon
r_else
id|__skb_queue_tail
c_func
(paren
id|queue
comma
(paren
r_struct
id|sk_buff
op_star
)paren
id|frag
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_XMIT_OK
suffix:colon
id|error
op_assign
(paren
op_star
id|q-&gt;force_output
)paren
(paren
id|packet
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
OL
l_int|0
)paren
(brace
multiline_comment|/* Packet could not be transmitted, put the chunk in&n;&t;&t;&t; * the output queue&n;&t;&t;&t; */
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;sctp_xmit_frag: force output &quot;
l_string|&quot;failed. adding 0x%x to outqueue&bslash;n&quot;
comma
id|ntohl
c_func
(paren
id|frag-&gt;subh.data_hdr-&gt;tsn
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pos
)paren
id|__skb_insert
c_func
(paren
(paren
r_struct
id|sk_buff
op_star
)paren
id|frag
comma
id|pos-&gt;prev
comma
id|pos
comma
id|pos-&gt;list
)paren
suffix:semicolon
r_else
id|__skb_queue_tail
c_func
(paren
id|queue
comma
(paren
r_struct
id|sk_buff
op_star
)paren
id|frag
)paren
suffix:semicolon
)brace
r_else
(brace
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;sctp_xmit_frag: force output &quot;
l_string|&quot;success. 0x%x sent&bslash;n&quot;
comma
id|ntohl
c_func
(paren
id|frag-&gt;subh.data_hdr-&gt;tsn
)paren
)paren
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|frag-&gt;transmitted_list
comma
op_amp
id|transport-&gt;transmitted
)paren
suffix:semicolon
id|sctp_transport_reset_timers
c_func
(paren
id|transport
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
suffix:semicolon
)brace
multiline_comment|/* This routine calls sctp_xmit_frag() for all the fragments of a message.&n; * The argument &squot;frag&squot; point to the first fragment and it holds the list&n; * of all the other fragments in the &squot;frag_list&squot; field.&n; */
DECL|function|sctp_xmit_fragmented_chunks
r_void
id|sctp_xmit_fragmented_chunks
c_func
(paren
r_struct
id|sctp_outq
op_star
id|q
comma
r_struct
id|sctp_packet
op_star
id|pkt
comma
id|sctp_chunk_t
op_star
id|frag
)paren
(brace
id|sctp_association_t
op_star
id|asoc
op_assign
id|frag-&gt;asoc
suffix:semicolon
r_struct
id|list_head
op_star
id|lfrag
comma
op_star
id|frag_list
suffix:semicolon
id|__u32
id|tsn
suffix:semicolon
r_int
id|nfrags
op_assign
l_int|1
suffix:semicolon
r_struct
id|sk_buff
op_star
id|pos
suffix:semicolon
multiline_comment|/* Count the number of fragments. */
id|frag_list
op_assign
op_amp
id|frag-&gt;frag_list
suffix:semicolon
id|list_for_each
c_func
(paren
id|lfrag
comma
id|frag_list
)paren
(brace
id|nfrags
op_increment
suffix:semicolon
)brace
multiline_comment|/* Get a TSN block of nfrags TSNs. */
id|tsn
op_assign
id|sctp_association_get_tsn_block
c_func
(paren
id|asoc
comma
id|nfrags
)paren
suffix:semicolon
id|pos
op_assign
id|skb_peek
c_func
(paren
op_amp
id|q-&gt;out
)paren
suffix:semicolon
multiline_comment|/* Transmit the first fragment. */
id|sctp_xmit_frag
c_func
(paren
id|q
comma
id|pos
comma
id|pkt
comma
id|frag
comma
id|tsn
op_increment
)paren
suffix:semicolon
multiline_comment|/* Transmit the rest of fragments. */
id|frag_list
op_assign
op_amp
id|frag-&gt;frag_list
suffix:semicolon
id|list_for_each
c_func
(paren
id|lfrag
comma
id|frag_list
)paren
(brace
id|frag
op_assign
id|list_entry
c_func
(paren
id|lfrag
comma
id|sctp_chunk_t
comma
id|frag_list
)paren
suffix:semicolon
id|sctp_xmit_frag
c_func
(paren
id|q
comma
id|pos
comma
id|pkt
comma
id|frag
comma
id|tsn
op_increment
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* This routine breaks the given chunk into &squot;max_frag_data_len&squot; size&n; * fragments.  It returns the first fragment with the frag_list field holding&n; * the remaining fragments.&n; */
DECL|function|sctp_fragment_chunk
id|sctp_chunk_t
op_star
id|sctp_fragment_chunk
c_func
(paren
id|sctp_chunk_t
op_star
id|chunk
comma
r_int
id|max_frag_data_len
)paren
(brace
id|sctp_association_t
op_star
id|asoc
op_assign
id|chunk-&gt;asoc
suffix:semicolon
r_void
op_star
id|data_ptr
op_assign
id|chunk-&gt;subh.data_hdr
suffix:semicolon
r_struct
id|sctp_sndrcvinfo
op_star
id|sinfo
op_assign
op_amp
id|chunk-&gt;sinfo
suffix:semicolon
id|__u16
id|chunk_data_len
op_assign
id|sctp_data_size
c_func
(paren
id|chunk
)paren
suffix:semicolon
id|__u16
id|ssn
op_assign
id|ntohs
c_func
(paren
id|chunk-&gt;subh.data_hdr-&gt;ssn
)paren
suffix:semicolon
id|sctp_chunk_t
op_star
id|first_frag
comma
op_star
id|frag
suffix:semicolon
r_struct
id|list_head
op_star
id|frag_list
suffix:semicolon
r_int
id|nfrags
suffix:semicolon
id|__u8
id|old_flags
comma
id|flags
suffix:semicolon
multiline_comment|/* nfrags = no. of max size fragments + any smaller last fragment. */
id|nfrags
op_assign
(paren
(paren
id|chunk_data_len
op_div
id|max_frag_data_len
)paren
op_plus
(paren
(paren
id|chunk_data_len
op_mod
id|max_frag_data_len
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
)paren
)paren
suffix:semicolon
multiline_comment|/* Start of the data in the chunk. */
id|data_ptr
op_add_assign
r_sizeof
(paren
id|sctp_datahdr_t
)paren
suffix:semicolon
multiline_comment|/* Are we fragmenting an already fragmented large message? */
id|old_flags
op_assign
id|chunk-&gt;chunk_hdr-&gt;flags
suffix:semicolon
r_if
c_cond
(paren
id|old_flags
op_amp
id|SCTP_DATA_FIRST_FRAG
)paren
id|flags
op_assign
id|SCTP_DATA_FIRST_FRAG
suffix:semicolon
r_else
id|flags
op_assign
id|SCTP_DATA_MIDDLE_FRAG
suffix:semicolon
multiline_comment|/* Make the first fragment. */
id|first_frag
op_assign
id|sctp_make_datafrag
c_func
(paren
id|asoc
comma
id|sinfo
comma
id|max_frag_data_len
comma
id|data_ptr
comma
id|flags
comma
id|ssn
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|first_frag
)paren
r_goto
id|err
suffix:semicolon
id|first_frag-&gt;has_ssn
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* All the fragments are added to the frag_list of the first chunk. */
id|frag_list
op_assign
op_amp
id|first_frag-&gt;frag_list
suffix:semicolon
id|chunk_data_len
op_sub_assign
id|max_frag_data_len
suffix:semicolon
id|data_ptr
op_add_assign
id|max_frag_data_len
suffix:semicolon
multiline_comment|/* Make the middle fragments. */
r_while
c_loop
(paren
id|chunk_data_len
OG
id|max_frag_data_len
)paren
(brace
id|frag
op_assign
id|sctp_make_datafrag
c_func
(paren
id|asoc
comma
id|sinfo
comma
id|max_frag_data_len
comma
id|data_ptr
comma
id|SCTP_DATA_MIDDLE_FRAG
comma
id|ssn
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|frag
)paren
r_goto
id|err
suffix:semicolon
id|frag-&gt;has_ssn
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Add the middle fragment to the first fragment&squot;s&n;&t;&t; * frag_list.&n;&t;&t; */
id|list_add_tail
c_func
(paren
op_amp
id|frag-&gt;frag_list
comma
id|frag_list
)paren
suffix:semicolon
id|chunk_data_len
op_sub_assign
id|max_frag_data_len
suffix:semicolon
id|data_ptr
op_add_assign
id|max_frag_data_len
suffix:semicolon
)brace
r_if
c_cond
(paren
id|old_flags
op_amp
id|SCTP_DATA_LAST_FRAG
)paren
id|flags
op_assign
id|SCTP_DATA_LAST_FRAG
suffix:semicolon
r_else
id|flags
op_assign
id|SCTP_DATA_MIDDLE_FRAG
suffix:semicolon
multiline_comment|/* Make the last fragment. */
id|frag
op_assign
id|sctp_make_datafrag
c_func
(paren
id|asoc
comma
id|sinfo
comma
id|chunk_data_len
comma
id|data_ptr
comma
id|flags
comma
id|ssn
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|frag
)paren
r_goto
id|err
suffix:semicolon
id|frag-&gt;has_ssn
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Add the last fragment to the first fragment&squot;s frag_list. */
id|list_add_tail
c_func
(paren
op_amp
id|frag-&gt;frag_list
comma
id|frag_list
)paren
suffix:semicolon
multiline_comment|/* Free the original chunk. */
id|sctp_free_chunk
c_func
(paren
id|chunk
)paren
suffix:semicolon
r_return
id|first_frag
suffix:semicolon
id|err
suffix:colon
multiline_comment|/* Free any fragments that are created before the failure.  */
r_if
c_cond
(paren
id|first_frag
)paren
(brace
r_struct
id|list_head
op_star
id|flist
comma
op_star
id|lfrag
suffix:semicolon
multiline_comment|/* Free all the fragments off the first one. */
id|flist
op_assign
op_amp
id|first_frag-&gt;frag_list
suffix:semicolon
r_while
c_loop
(paren
l_int|NULL
op_ne
(paren
id|lfrag
op_assign
id|sctp_list_dequeue
c_func
(paren
id|flist
)paren
)paren
)paren
(brace
id|frag
op_assign
id|list_entry
c_func
(paren
id|lfrag
comma
id|sctp_chunk_t
comma
id|frag_list
)paren
suffix:semicolon
id|sctp_free_chunk
c_func
(paren
id|frag
)paren
suffix:semicolon
)brace
multiline_comment|/* Free the first fragment. */
id|sctp_free_chunk
c_func
(paren
id|first_frag
)paren
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * sctp_outq_flush - Try to flush an outqueue.&n; *&n; * Description: Send everything in q which we legally can, subject to&n; * congestion limitations.&n; * * Note: This function can be called from multiple contexts so appropriate&n; * locking concerns must be made.  Today we use the sock lock to protect&n; * this function.&n; */
DECL|function|sctp_outq_flush
r_int
id|sctp_outq_flush
c_func
(paren
r_struct
id|sctp_outq
op_star
id|q
comma
r_int
id|rtx_timeout
)paren
(brace
r_struct
id|sctp_packet
op_star
id|packet
suffix:semicolon
r_struct
id|sctp_packet
id|singleton
suffix:semicolon
id|sctp_association_t
op_star
id|asoc
op_assign
id|q-&gt;asoc
suffix:semicolon
r_int
id|ecn_capable
op_assign
id|asoc-&gt;peer.ecn_capable
suffix:semicolon
id|__u16
id|sport
op_assign
id|asoc-&gt;base.bind_addr.port
suffix:semicolon
id|__u16
id|dport
op_assign
id|asoc-&gt;peer.port
suffix:semicolon
id|__u32
id|vtag
op_assign
id|asoc-&gt;peer.i.init_tag
suffix:semicolon
multiline_comment|/* This is the ECNE handler for singleton packets.  */
id|sctp_packet_phandler_t
op_star
id|s_ecne_handler
op_assign
l_int|NULL
suffix:semicolon
id|sctp_packet_phandler_t
op_star
id|ecne_handler
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|sk_buff_head
op_star
id|queue
suffix:semicolon
r_struct
id|sctp_transport
op_star
id|transport
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|sctp_transport
op_star
id|new_transport
suffix:semicolon
id|sctp_chunk_t
op_star
id|chunk
suffix:semicolon
id|sctp_xmit_t
id|status
suffix:semicolon
r_int
id|error
op_assign
l_int|0
suffix:semicolon
r_int
id|start_timer
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* These transports have chunks to send. */
r_struct
id|list_head
id|transport_list
suffix:semicolon
r_struct
id|list_head
op_star
id|ltransport
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|transport_list
)paren
suffix:semicolon
id|packet
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * 6.10 Bundling&n;&t; *   ...&n;&t; *   When bundling control chunks with DATA chunks, an&n;&t; *   endpoint MUST place control chunks first in the outbound&n;&t; *   SCTP packet.  The transmitter MUST transmit DATA chunks&n;&t; *   within a SCTP packet in increasing order of TSN.&n;&t; *   ...&n;&t; */
r_if
c_cond
(paren
id|ecn_capable
)paren
(brace
id|s_ecne_handler
op_assign
op_amp
id|sctp_get_no_prepend
suffix:semicolon
id|ecne_handler
op_assign
op_amp
id|sctp_get_ecne_prepend
suffix:semicolon
)brace
id|queue
op_assign
op_amp
id|q-&gt;control
suffix:semicolon
r_while
c_loop
(paren
l_int|NULL
op_ne
(paren
id|chunk
op_assign
(paren
id|sctp_chunk_t
op_star
)paren
id|skb_dequeue
c_func
(paren
id|queue
)paren
)paren
)paren
(brace
multiline_comment|/* Pick the right transport to use. */
id|new_transport
op_assign
id|chunk-&gt;transport
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|new_transport
)paren
(brace
id|new_transport
op_assign
id|asoc-&gt;peer.active_path
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|new_transport-&gt;active
)paren
(brace
multiline_comment|/* If the chunk is Heartbeat, send it to&n;&t;&t;&t; * chunk-&gt;transport, even it&squot;s inactive.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|chunk-&gt;chunk_hdr-&gt;type
op_ne
id|SCTP_CID_HEARTBEAT
)paren
id|new_transport
op_assign
id|asoc-&gt;peer.active_path
suffix:semicolon
)brace
multiline_comment|/* Are we switching transports?&n;&t;&t; * Take care of transport locks.&n;&t;&t; */
r_if
c_cond
(paren
id|new_transport
op_ne
id|transport
)paren
(brace
id|transport
op_assign
id|new_transport
suffix:semicolon
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|transport-&gt;send_ready
)paren
)paren
(brace
id|list_add_tail
c_func
(paren
op_amp
id|transport-&gt;send_ready
comma
op_amp
id|transport_list
)paren
suffix:semicolon
)brace
id|packet
op_assign
op_amp
id|transport-&gt;packet
suffix:semicolon
(paren
op_star
id|q-&gt;config_output
)paren
(paren
id|packet
comma
id|vtag
comma
id|ecn_capable
comma
id|ecne_handler
)paren
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|chunk-&gt;chunk_hdr-&gt;type
)paren
(brace
multiline_comment|/*&n;&t;&t; * 6.10 Bundling&n;&t;&t; *   ...&n;&t;&t; *   An endpoint MUST NOT bundle INIT, INIT ACK or SHUTDOWN&n;&t;&t; *   COMPLETE with any other chunks.  [Send them immediately.]&n;&t;&t; */
r_case
id|SCTP_CID_INIT
suffix:colon
r_case
id|SCTP_CID_INIT_ACK
suffix:colon
r_case
id|SCTP_CID_SHUTDOWN_COMPLETE
suffix:colon
(paren
op_star
id|q-&gt;init_output
)paren
(paren
op_amp
id|singleton
comma
id|transport
comma
id|sport
comma
id|dport
)paren
suffix:semicolon
(paren
op_star
id|q-&gt;config_output
)paren
(paren
op_amp
id|singleton
comma
id|vtag
comma
id|ecn_capable
comma
id|s_ecne_handler
)paren
suffix:semicolon
(paren
r_void
)paren
(paren
op_star
id|q-&gt;build_output
)paren
(paren
op_amp
id|singleton
comma
id|chunk
)paren
suffix:semicolon
id|error
op_assign
(paren
op_star
id|q-&gt;force_output
)paren
(paren
op_amp
id|singleton
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
OL
l_int|0
)paren
r_return
id|error
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_CID_ABORT
suffix:colon
r_case
id|SCTP_CID_SACK
suffix:colon
r_case
id|SCTP_CID_HEARTBEAT
suffix:colon
r_case
id|SCTP_CID_HEARTBEAT_ACK
suffix:colon
r_case
id|SCTP_CID_SHUTDOWN
suffix:colon
r_case
id|SCTP_CID_SHUTDOWN_ACK
suffix:colon
r_case
id|SCTP_CID_ERROR
suffix:colon
r_case
id|SCTP_CID_COOKIE_ECHO
suffix:colon
r_case
id|SCTP_CID_COOKIE_ACK
suffix:colon
r_case
id|SCTP_CID_ECN_ECNE
suffix:colon
r_case
id|SCTP_CID_ECN_CWR
suffix:colon
(paren
r_void
)paren
(paren
op_star
id|q-&gt;build_output
)paren
(paren
id|packet
comma
id|chunk
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_CID_ASCONF
suffix:colon
r_case
id|SCTP_CID_ASCONF_ACK
suffix:colon
(paren
r_void
)paren
(paren
op_star
id|q-&gt;build_output
)paren
(paren
id|packet
comma
id|chunk
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* We built a chunk with an illegal type! */
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
suffix:semicolon
)brace
multiline_comment|/* Is it OK to send data chunks?  */
r_switch
c_cond
(paren
id|asoc-&gt;state
)paren
(brace
r_case
id|SCTP_STATE_COOKIE_ECHOED
suffix:colon
multiline_comment|/* Only allow bundling when this packet has a COOKIE-ECHO&n;&t;&t; * chunk.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|packet
op_logical_or
op_logical_neg
id|packet-&gt;has_cookie_echo
)paren
r_break
suffix:semicolon
multiline_comment|/* fallthru */
r_case
id|SCTP_STATE_ESTABLISHED
suffix:colon
r_case
id|SCTP_STATE_SHUTDOWN_PENDING
suffix:colon
r_case
id|SCTP_STATE_SHUTDOWN_RECEIVED
suffix:colon
multiline_comment|/*&n;&t;&t; * RFC 2960 6.1  Transmission of DATA Chunks&n;&t;&t; *&n;&t;&t; * C) When the time comes for the sender to transmit,&n;&t;&t; * before sending new DATA chunks, the sender MUST&n;&t;&t; * first transmit any outstanding DATA chunks which&n;&t;&t; * are marked for retransmission (limited by the&n;&t;&t; * current cwnd).&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|q-&gt;retransmit
)paren
)paren
(brace
r_if
c_cond
(paren
id|transport
op_eq
id|asoc-&gt;peer.retran_path
)paren
r_goto
id|retran
suffix:semicolon
multiline_comment|/* Switch transports &amp; prepare the packet.  */
id|transport
op_assign
id|asoc-&gt;peer.retran_path
suffix:semicolon
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|transport-&gt;send_ready
)paren
)paren
(brace
id|list_add_tail
c_func
(paren
op_amp
id|transport-&gt;send_ready
comma
op_amp
id|transport_list
)paren
suffix:semicolon
)brace
id|packet
op_assign
op_amp
id|transport-&gt;packet
suffix:semicolon
(paren
op_star
id|q-&gt;config_output
)paren
(paren
id|packet
comma
id|vtag
comma
id|ecn_capable
comma
id|ecne_handler
)paren
suffix:semicolon
id|retran
suffix:colon
id|error
op_assign
id|sctp_outq_flush_rtx
c_func
(paren
id|q
comma
id|packet
comma
id|rtx_timeout
comma
op_amp
id|start_timer
)paren
suffix:semicolon
r_if
c_cond
(paren
id|start_timer
)paren
id|sctp_transport_reset_timers
c_func
(paren
id|transport
)paren
suffix:semicolon
multiline_comment|/* This can happen on COOKIE-ECHO resend.  Only&n;&t;&t;&t; * one chunk can get bundled with a COOKIE-ECHO.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|packet-&gt;has_cookie_echo
)paren
r_goto
id|sctp_flush_out
suffix:semicolon
multiline_comment|/* Don&squot;t send new data if there is still data&n;&t;&t;&t; * waiting to retransmit.&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|q-&gt;retransmit
)paren
)paren
r_goto
id|sctp_flush_out
suffix:semicolon
)brace
multiline_comment|/* Finally, transmit new packets.  */
id|start_timer
op_assign
l_int|0
suffix:semicolon
id|queue
op_assign
op_amp
id|q-&gt;out
suffix:semicolon
r_while
c_loop
(paren
l_int|NULL
op_ne
(paren
id|chunk
op_assign
id|sctp_outq_dequeue_data
c_func
(paren
id|q
)paren
)paren
)paren
(brace
multiline_comment|/* RFC 2960 6.5 Every DATA chunk MUST carry a valid&n;&t;&t;&t; * stream identifier.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|chunk-&gt;sinfo.sinfo_stream
op_ge
id|asoc-&gt;c.sinit_num_ostreams
)paren
(brace
r_struct
id|sctp_ulpevent
op_star
id|ev
suffix:semicolon
multiline_comment|/* Generate a SEND FAILED event. */
id|ev
op_assign
id|sctp_ulpevent_make_send_failed
c_func
(paren
id|asoc
comma
id|chunk
comma
id|SCTP_DATA_UNSENT
comma
id|SCTP_ERROR_INV_STRM
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ev
)paren
id|sctp_ulpq_tail_event
c_func
(paren
op_amp
id|asoc-&gt;ulpq
comma
id|ev
)paren
suffix:semicolon
multiline_comment|/* Free the chunk. This chunk is not on any&n;&t;&t;&t;&t; * list yet, just free it.&n;&t;&t;&t;&t; */
id|sctp_free_chunk
c_func
(paren
id|chunk
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* Now do delayed assignment of SSN.  This will&n;&t;&t;&t; * probably change again when we start supporting&n;&t;&t;&t; * large (&gt; approximately 2^16) size messages.&n;&t;&t;&t; */
id|sctp_chunk_assign_ssn
c_func
(paren
id|chunk
)paren
suffix:semicolon
multiline_comment|/* If there is a specified transport, use it.&n;&t;&t;&t; * Otherwise, we want to use the active path.&n;&t;&t;&t; */
id|new_transport
op_assign
id|chunk-&gt;transport
suffix:semicolon
r_if
c_cond
(paren
id|new_transport
op_eq
l_int|NULL
op_logical_or
op_logical_neg
id|new_transport-&gt;active
)paren
id|new_transport
op_assign
id|asoc-&gt;peer.active_path
suffix:semicolon
multiline_comment|/* Change packets if necessary.  */
r_if
c_cond
(paren
id|new_transport
op_ne
id|transport
)paren
(brace
id|transport
op_assign
id|new_transport
suffix:semicolon
multiline_comment|/* Schedule to have this transport&squot;s&n;&t;&t;&t;&t; * packet flushed.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|transport-&gt;send_ready
)paren
)paren
(brace
id|list_add_tail
c_func
(paren
op_amp
id|transport-&gt;send_ready
comma
op_amp
id|transport_list
)paren
suffix:semicolon
)brace
id|packet
op_assign
op_amp
id|transport-&gt;packet
suffix:semicolon
(paren
op_star
id|q-&gt;config_output
)paren
(paren
id|packet
comma
id|vtag
comma
id|ecn_capable
comma
id|ecne_handler
)paren
suffix:semicolon
)brace
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;sctp_transmit_packet(%p, %p[%s]), &quot;
comma
id|q
comma
id|chunk
comma
id|chunk
op_logical_and
id|chunk-&gt;chunk_hdr
ques
c_cond
id|sctp_cname
c_func
(paren
id|SCTP_ST_CHUNK
c_func
(paren
id|chunk-&gt;chunk_hdr-&gt;type
)paren
)paren
suffix:colon
l_string|&quot;Illegal Chunk&quot;
)paren
suffix:semicolon
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;TX TSN 0x%x skb-&gt;head &quot;
l_string|&quot;%p skb-&gt;users %d.&bslash;n&quot;
comma
id|ntohl
c_func
(paren
id|chunk-&gt;subh.data_hdr-&gt;tsn
)paren
comma
id|chunk-&gt;skb
ques
c_cond
id|chunk-&gt;skb-&gt;head
suffix:colon
l_int|0
comma
id|chunk-&gt;skb
ques
c_cond
id|atomic_read
c_func
(paren
op_amp
id|chunk-&gt;skb-&gt;users
)paren
suffix:colon
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Add the chunk to the packet.  */
id|status
op_assign
(paren
op_star
id|q-&gt;build_output
)paren
(paren
id|packet
comma
id|chunk
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|status
)paren
(brace
r_case
id|SCTP_XMIT_PMTU_FULL
suffix:colon
r_case
id|SCTP_XMIT_RWND_FULL
suffix:colon
r_case
id|SCTP_XMIT_NAGLE_DELAY
suffix:colon
multiline_comment|/* We could not append this chunk, so put&n;&t;&t;&t;&t; * the chunk back on the output queue.&n;&t;&t;&t;&t; */
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;sctp_outq_flush: could &quot;
l_string|&quot;not transmit TSN: 0x%x, status: %d&bslash;n&quot;
comma
id|ntohl
c_func
(paren
id|chunk-&gt;subh.data_hdr-&gt;tsn
)paren
comma
id|status
)paren
suffix:semicolon
id|sctp_outq_head_data
c_func
(paren
id|q
comma
id|chunk
)paren
suffix:semicolon
r_goto
id|sctp_flush_out
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_XMIT_MUST_FRAG
suffix:colon
(brace
id|sctp_chunk_t
op_star
id|frag
suffix:semicolon
id|frag
op_assign
id|sctp_fragment_chunk
c_func
(paren
id|chunk
comma
id|packet-&gt;transport-&gt;asoc-&gt;frag_point
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|frag
)paren
(brace
multiline_comment|/* We could not fragment due to out of&n;&t;&t;&t;&t;&t; * memory condition. Free the original&n;&t;&t;&t;&t;&t; * chunk and return ENOMEM.&n;&t;&t;&t;&t;&t; */
id|sctp_free_chunk
c_func
(paren
id|chunk
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
id|sctp_xmit_fragmented_chunks
c_func
(paren
id|q
comma
id|packet
comma
id|frag
)paren
suffix:semicolon
r_goto
id|sctp_flush_out
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|SCTP_XMIT_OK
suffix:colon
r_break
suffix:semicolon
r_default
suffix:colon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* BUG: We assume that the (*q-&gt;force_output())&n;&t;&t;&t; * call below will succeed all the time and add the&n;&t;&t;&t; * chunk to the transmitted list and restart the&n;&t;&t;&t; * timers.&n;&t;&t;&t; * It is possible that the call can fail under OOM&n;&t;&t;&t; * conditions.&n;&t;&t;&t; *&n;&t;&t;&t; * Is this really a problem?  Won&squot;t this behave&n;&t;&t;&t; * like a lost TSN?&n;&t;&t;&t; */
id|list_add_tail
c_func
(paren
op_amp
id|chunk-&gt;transmitted_list
comma
op_amp
id|transport-&gt;transmitted
)paren
suffix:semicolon
id|sctp_transport_reset_timers
c_func
(paren
id|transport
)paren
suffix:semicolon
id|q-&gt;empty
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Only let one DATA chunk get bundled with a&n;&t;&t;&t; * COOKIE-ECHO chunk.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|packet-&gt;has_cookie_echo
)paren
r_goto
id|sctp_flush_out
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* Do nothing.  */
r_break
suffix:semicolon
)brace
id|sctp_flush_out
suffix:colon
multiline_comment|/* Before returning, examine all the transports touched in&n;&t; * this call.  Right now, we bluntly force clear all the&n;&t; * transports.  Things might change after we implement Nagle.&n;&t; * But such an examination is still required.&n;&t; *&n;&t; * --xguo&n;&t; */
r_while
c_loop
(paren
(paren
id|ltransport
op_assign
id|sctp_list_dequeue
c_func
(paren
op_amp
id|transport_list
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
r_struct
id|sctp_transport
op_star
id|t
op_assign
id|list_entry
c_func
(paren
id|ltransport
comma
r_struct
id|sctp_transport
comma
id|send_ready
)paren
suffix:semicolon
r_if
c_cond
(paren
id|t
op_ne
id|transport
)paren
id|transport
op_assign
id|t
suffix:semicolon
id|packet
op_assign
op_amp
id|transport-&gt;packet
suffix:semicolon
r_if
c_cond
(paren
id|packet-&gt;size
op_ne
id|SCTP_IP_OVERHEAD
)paren
id|error
op_assign
(paren
op_star
id|q-&gt;force_output
)paren
(paren
id|packet
)paren
suffix:semicolon
)brace
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/* Set the various output handling callbacks.  */
DECL|function|sctp_outq_set_output_handlers
r_int
id|sctp_outq_set_output_handlers
c_func
(paren
r_struct
id|sctp_outq
op_star
id|q
comma
id|sctp_outq_ohandler_init_t
id|init
comma
id|sctp_outq_ohandler_config_t
id|config
comma
id|sctp_outq_ohandler_t
id|append
comma
id|sctp_outq_ohandler_t
id|build
comma
id|sctp_outq_ohandler_force_t
id|force
)paren
(brace
id|q-&gt;init_output
op_assign
id|init
suffix:semicolon
id|q-&gt;config_output
op_assign
id|config
suffix:semicolon
id|q-&gt;append_output
op_assign
id|append
suffix:semicolon
id|q-&gt;build_output
op_assign
id|build
suffix:semicolon
id|q-&gt;force_output
op_assign
id|force
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Update unack_data based on the incoming SACK chunk */
DECL|function|sctp_sack_update_unack_data
r_static
r_void
id|sctp_sack_update_unack_data
c_func
(paren
id|sctp_association_t
op_star
id|assoc
comma
id|sctp_sackhdr_t
op_star
id|sack
)paren
(brace
id|sctp_sack_variable_t
op_star
id|frags
suffix:semicolon
id|__u16
id|unack_data
suffix:semicolon
r_int
id|i
suffix:semicolon
id|unack_data
op_assign
id|assoc-&gt;next_tsn
op_minus
id|assoc-&gt;ctsn_ack_point
op_minus
l_int|1
suffix:semicolon
id|frags
op_assign
id|sack-&gt;variable
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ntohs
c_func
(paren
id|sack-&gt;num_gap_ack_blocks
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|unack_data
op_sub_assign
(paren
(paren
id|ntohs
c_func
(paren
id|frags
(braket
id|i
)braket
dot
id|gab.end
)paren
op_minus
id|ntohs
c_func
(paren
id|frags
(braket
id|i
)braket
dot
id|gab.start
)paren
op_plus
l_int|1
)paren
)paren
suffix:semicolon
)brace
id|assoc-&gt;unack_data
op_assign
id|unack_data
suffix:semicolon
)brace
multiline_comment|/* Return the highest new tsn that is acknowledged by the given SACK chunk. */
DECL|function|sctp_highest_new_tsn
r_static
id|__u32
id|sctp_highest_new_tsn
c_func
(paren
id|sctp_sackhdr_t
op_star
id|sack
comma
id|sctp_association_t
op_star
id|asoc
)paren
(brace
r_struct
id|list_head
op_star
id|ltransport
comma
op_star
id|lchunk
suffix:semicolon
r_struct
id|sctp_transport
op_star
id|transport
suffix:semicolon
id|sctp_chunk_t
op_star
id|chunk
suffix:semicolon
id|__u32
id|highest_new_tsn
comma
id|tsn
suffix:semicolon
r_struct
id|list_head
op_star
id|transport_list
op_assign
op_amp
id|asoc-&gt;peer.transport_addr_list
suffix:semicolon
id|highest_new_tsn
op_assign
id|ntohl
c_func
(paren
id|sack-&gt;cum_tsn_ack
)paren
suffix:semicolon
id|list_for_each
c_func
(paren
id|ltransport
comma
id|transport_list
)paren
(brace
id|transport
op_assign
id|list_entry
c_func
(paren
id|ltransport
comma
r_struct
id|sctp_transport
comma
id|transports
)paren
suffix:semicolon
id|list_for_each
c_func
(paren
id|lchunk
comma
op_amp
id|transport-&gt;transmitted
)paren
(brace
id|chunk
op_assign
id|list_entry
c_func
(paren
id|lchunk
comma
id|sctp_chunk_t
comma
id|transmitted_list
)paren
suffix:semicolon
id|tsn
op_assign
id|ntohl
c_func
(paren
id|chunk-&gt;subh.data_hdr-&gt;tsn
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|chunk-&gt;tsn_gap_acked
op_logical_and
id|TSN_lt
c_func
(paren
id|highest_new_tsn
comma
id|tsn
)paren
op_logical_and
id|sctp_acked
c_func
(paren
id|sack
comma
id|tsn
)paren
)paren
id|highest_new_tsn
op_assign
id|tsn
suffix:semicolon
)brace
)brace
r_return
id|highest_new_tsn
suffix:semicolon
)brace
multiline_comment|/* This is where we REALLY process a SACK.&n; *&n; * Process the SACK against the outqueue.  Mostly, this just frees&n; * things off the transmitted queue.&n; */
DECL|function|sctp_outq_sack
r_int
id|sctp_outq_sack
c_func
(paren
r_struct
id|sctp_outq
op_star
id|q
comma
id|sctp_sackhdr_t
op_star
id|sack
)paren
(brace
id|sctp_association_t
op_star
id|asoc
op_assign
id|q-&gt;asoc
suffix:semicolon
r_struct
id|sctp_transport
op_star
id|transport
suffix:semicolon
id|sctp_chunk_t
op_star
id|tchunk
suffix:semicolon
r_struct
id|list_head
op_star
id|lchunk
comma
op_star
id|transport_list
comma
op_star
id|pos
suffix:semicolon
id|sctp_sack_variable_t
op_star
id|frags
op_assign
id|sack-&gt;variable
suffix:semicolon
id|__u32
id|sack_ctsn
comma
id|ctsn
comma
id|tsn
suffix:semicolon
id|__u32
id|highest_tsn
comma
id|highest_new_tsn
suffix:semicolon
id|__u32
id|sack_a_rwnd
suffix:semicolon
r_int
id|outstanding
suffix:semicolon
multiline_comment|/* Grab the association&squot;s destination address list. */
id|transport_list
op_assign
op_amp
id|asoc-&gt;peer.transport_addr_list
suffix:semicolon
id|sack_ctsn
op_assign
id|ntohl
c_func
(paren
id|sack-&gt;cum_tsn_ack
)paren
suffix:semicolon
multiline_comment|/* Get the highest TSN in the sack. */
id|highest_tsn
op_assign
id|sack_ctsn
op_plus
id|ntohs
c_func
(paren
id|frags
(braket
id|ntohs
c_func
(paren
id|sack-&gt;num_gap_ack_blocks
)paren
op_minus
l_int|1
)braket
dot
id|gab.end
)paren
suffix:semicolon
r_if
c_cond
(paren
id|TSN_lt
c_func
(paren
id|asoc-&gt;highest_sacked
comma
id|highest_tsn
)paren
)paren
(brace
id|highest_new_tsn
op_assign
id|highest_tsn
suffix:semicolon
id|asoc-&gt;highest_sacked
op_assign
id|highest_tsn
suffix:semicolon
)brace
r_else
(brace
id|highest_new_tsn
op_assign
id|sctp_highest_new_tsn
c_func
(paren
id|sack
comma
id|asoc
)paren
suffix:semicolon
)brace
multiline_comment|/* Run through the retransmit queue.  Credit bytes received&n;&t; * and free those chunks that we can.&n;&t; */
id|sctp_check_transmitted
c_func
(paren
id|q
comma
op_amp
id|q-&gt;retransmit
comma
l_int|NULL
comma
id|sack
comma
id|highest_new_tsn
)paren
suffix:semicolon
multiline_comment|/* Run through the transmitted queue.&n;&t; * Credit bytes received and free those chunks which we can.&n;&t; *&n;&t; * This is a MASSIVE candidate for optimization.&n;&t; */
id|list_for_each
c_func
(paren
id|pos
comma
id|transport_list
)paren
(brace
id|transport
op_assign
id|list_entry
c_func
(paren
id|pos
comma
r_struct
id|sctp_transport
comma
id|transports
)paren
suffix:semicolon
id|sctp_check_transmitted
c_func
(paren
id|q
comma
op_amp
id|transport-&gt;transmitted
comma
id|transport
comma
id|sack
comma
id|highest_new_tsn
)paren
suffix:semicolon
)brace
multiline_comment|/* Move the Cumulative TSN Ack Point if appropriate.  */
r_if
c_cond
(paren
id|TSN_lt
c_func
(paren
id|asoc-&gt;ctsn_ack_point
comma
id|sack_ctsn
)paren
)paren
id|asoc-&gt;ctsn_ack_point
op_assign
id|sack_ctsn
suffix:semicolon
multiline_comment|/* Update unack_data field in the assoc. */
id|sctp_sack_update_unack_data
c_func
(paren
id|asoc
comma
id|sack
)paren
suffix:semicolon
id|ctsn
op_assign
id|asoc-&gt;ctsn_ack_point
suffix:semicolon
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;%s: sack Cumulative TSN Ack is 0x%x.&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|sack_ctsn
)paren
suffix:semicolon
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;%s: Cumulative TSN Ack of association &quot;
l_string|&quot;%p is 0x%x.&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|asoc
comma
id|ctsn
)paren
suffix:semicolon
multiline_comment|/* Throw away stuff rotting on the sack queue.  */
id|list_for_each
c_func
(paren
id|lchunk
comma
op_amp
id|q-&gt;sacked
)paren
(brace
id|tchunk
op_assign
id|list_entry
c_func
(paren
id|lchunk
comma
id|sctp_chunk_t
comma
id|transmitted_list
)paren
suffix:semicolon
id|tsn
op_assign
id|ntohl
c_func
(paren
id|tchunk-&gt;subh.data_hdr-&gt;tsn
)paren
suffix:semicolon
r_if
c_cond
(paren
id|TSN_lte
c_func
(paren
id|tsn
comma
id|ctsn
)paren
)paren
(brace
id|lchunk
op_assign
id|lchunk-&gt;prev
suffix:semicolon
id|sctp_free_chunk
c_func
(paren
id|tchunk
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* ii) Set rwnd equal to the newly received a_rwnd minus the&n;&t; *     number of bytes still outstanding after processing the&n;&t; *     Cumulative TSN Ack and the Gap Ack Blocks.&n;&t; */
id|sack_a_rwnd
op_assign
id|ntohl
c_func
(paren
id|sack-&gt;a_rwnd
)paren
suffix:semicolon
id|outstanding
op_assign
id|q-&gt;outstanding_bytes
suffix:semicolon
r_if
c_cond
(paren
id|outstanding
OL
id|sack_a_rwnd
)paren
id|sack_a_rwnd
op_sub_assign
id|outstanding
suffix:semicolon
r_else
id|sack_a_rwnd
op_assign
l_int|0
suffix:semicolon
id|asoc-&gt;peer.rwnd
op_assign
id|sack_a_rwnd
suffix:semicolon
multiline_comment|/* See if all chunks are acked.&n;&t; * Make sure the empty queue handler will get run later.&n;&t; */
id|q-&gt;empty
op_assign
id|skb_queue_empty
c_func
(paren
op_amp
id|q-&gt;out
)paren
op_logical_and
id|list_empty
c_func
(paren
op_amp
id|q-&gt;retransmit
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|q-&gt;empty
)paren
r_goto
id|finish
suffix:semicolon
id|list_for_each
c_func
(paren
id|pos
comma
id|transport_list
)paren
(brace
id|transport
op_assign
id|list_entry
c_func
(paren
id|pos
comma
r_struct
id|sctp_transport
comma
id|transports
)paren
suffix:semicolon
id|q-&gt;empty
op_assign
id|q-&gt;empty
op_logical_and
id|list_empty
c_func
(paren
op_amp
id|transport-&gt;transmitted
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|q-&gt;empty
)paren
r_goto
id|finish
suffix:semicolon
)brace
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;sack queue is empty.&bslash;n&quot;
)paren
suffix:semicolon
id|finish
suffix:colon
r_return
id|q-&gt;empty
suffix:semicolon
)brace
multiline_comment|/* Is the outqueue empty?  */
DECL|function|sctp_outq_is_empty
r_int
id|sctp_outq_is_empty
c_func
(paren
r_const
r_struct
id|sctp_outq
op_star
id|q
)paren
(brace
r_return
id|q-&gt;empty
suffix:semicolon
)brace
multiline_comment|/********************************************************************&n; * 2nd Level Abstractions&n; ********************************************************************/
multiline_comment|/* Go through a transport&squot;s transmitted list or the assocication&squot;s retransmit&n; * list and move chunks that are acked by the Cumulative TSN Ack to q-&gt;sacked.&n; * The retransmit list will not have an associated transport. In case of a&n; * transmitted list with a transport, the transport&squot;s congestion, rto and fast&n; * retransmit parameters are also updated and if needed a fast retransmit&n; * process is started.&n; *&n; * I added coherent debug information output.&t;--xguo&n; *&n; * Instead of printing &squot;sacked&squot; or &squot;kept&squot; for each TSN on the&n; * transmitted_queue, we print a range: SACKED: TSN1-TSN2, TSN3, TSN4-TSN5.&n; * KEPT TSN6-TSN7, etc.&n; */
DECL|function|sctp_check_transmitted
r_static
r_void
id|sctp_check_transmitted
c_func
(paren
r_struct
id|sctp_outq
op_star
id|q
comma
r_struct
id|list_head
op_star
id|transmitted_queue
comma
r_struct
id|sctp_transport
op_star
id|transport
comma
id|sctp_sackhdr_t
op_star
id|sack
comma
id|__u32
id|highest_new_tsn_in_sack
)paren
(brace
r_struct
id|list_head
op_star
id|lchunk
suffix:semicolon
id|sctp_chunk_t
op_star
id|tchunk
suffix:semicolon
r_struct
id|list_head
id|tlist
suffix:semicolon
id|__u32
id|tsn
suffix:semicolon
id|__u32
id|sack_ctsn
suffix:semicolon
id|__u32
id|rtt
suffix:semicolon
id|__u8
id|restart_timer
op_assign
l_int|0
suffix:semicolon
id|__u8
id|do_fast_retransmit
op_assign
l_int|0
suffix:semicolon
r_int
id|bytes_acked
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* These state variables are for coherent debug output. --xguo */
macro_line|#if SCTP_DEBUG
id|__u32
id|dbg_ack_tsn
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* An ACKed TSN range starts here... */
id|__u32
id|dbg_last_ack_tsn
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* ...and finishes here.&t;     */
id|__u32
id|dbg_kept_tsn
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* An un-ACKed range starts here...  */
id|__u32
id|dbg_last_kept_tsn
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* ...and finishes here.&t;     */
multiline_comment|/* 0 : The last TSN was ACKed.&n;&t; * 1 : The last TSN was NOT ACKed (i.e. KEPT).&n;&t; * -1: We need to initialize.&n;&t; */
r_int
id|dbg_prt_state
op_assign
op_minus
l_int|1
suffix:semicolon
macro_line|#endif /* SCTP_DEBUG */
id|sack_ctsn
op_assign
id|ntohl
c_func
(paren
id|sack-&gt;cum_tsn_ack
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|tlist
)paren
suffix:semicolon
multiline_comment|/* The while loop will skip empty transmitted queues. */
r_while
c_loop
(paren
l_int|NULL
op_ne
(paren
id|lchunk
op_assign
id|sctp_list_dequeue
c_func
(paren
id|transmitted_queue
)paren
)paren
)paren
(brace
id|tchunk
op_assign
id|list_entry
c_func
(paren
id|lchunk
comma
id|sctp_chunk_t
comma
id|transmitted_list
)paren
suffix:semicolon
id|tsn
op_assign
id|ntohl
c_func
(paren
id|tchunk-&gt;subh.data_hdr-&gt;tsn
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sctp_acked
c_func
(paren
id|sack
comma
id|tsn
)paren
)paren
(brace
multiline_comment|/* If this queue is the retransmit queue, the&n;&t;&t;&t; * retransmit timer has already reclaimed&n;&t;&t;&t; * the outstanding bytes for this chunk, so only&n;&t;&t;&t; * count bytes associated with a transport.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|transport
)paren
(brace
multiline_comment|/* If this chunk is being used for RTT&n;&t;&t;&t;&t; * measurement, calculate the RTT and update&n;&t;&t;&t;&t; * the RTO using this value.&n;&t;&t;&t;&t; *&n;&t;&t;&t;&t; * 6.3.1 C5) Karn&squot;s algorithm: RTT measurements&n;&t;&t;&t;&t; * MUST NOT be made using packets that were&n;&t;&t;&t;&t; * retransmitted (and thus for which it is&n;&t;&t;&t;&t; * ambiguous whether the reply was for the&n;&t;&t;&t;&t; * first instance of the packet or a later&n;&t;&t;&t;&t; * instance).&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
(paren
op_logical_neg
id|tchunk-&gt;tsn_gap_acked
)paren
op_logical_and
(paren
l_int|1
op_eq
id|tchunk-&gt;num_times_sent
)paren
op_logical_and
(paren
id|tchunk-&gt;rtt_in_progress
)paren
)paren
(brace
id|rtt
op_assign
id|jiffies
op_minus
id|tchunk-&gt;sent_at
suffix:semicolon
id|sctp_transport_update_rto
c_func
(paren
id|transport
comma
id|rtt
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|TSN_lte
c_func
(paren
id|tsn
comma
id|sack_ctsn
)paren
)paren
(brace
multiline_comment|/* RFC 2960  6.3.2 Retransmission Timer Rules&n;&t;&t;&t;&t; *&n;&t;&t;&t;&t; * R3) Whenever a SACK is received&n;&t;&t;&t;&t; * that acknowledges the DATA chunk&n;&t;&t;&t;&t; * with the earliest outstanding TSN&n;&t;&t;&t;&t; * for that address, restart T3-rtx&n;&t;&t;&t;&t; * timer for that address with its&n;&t;&t;&t;&t; * current RTO.&n;&t;&t;&t;&t; */
id|restart_timer
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tchunk-&gt;tsn_gap_acked
)paren
(brace
id|tchunk-&gt;tsn_gap_acked
op_assign
l_int|1
suffix:semicolon
id|bytes_acked
op_add_assign
id|sctp_data_size
c_func
(paren
id|tchunk
)paren
suffix:semicolon
)brace
id|list_add_tail
c_func
(paren
op_amp
id|tchunk-&gt;transmitted_list
comma
op_amp
id|q-&gt;sacked
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* RFC2960 7.2.4, sctpimpguide-05 2.8.2&n;&t;&t;&t;&t; * M2) Each time a SACK arrives reporting&n;&t;&t;&t;&t; * &squot;Stray DATA chunk(s)&squot; record the highest TSN&n;&t;&t;&t;&t; * reported as newly acknowledged, call this&n;&t;&t;&t;&t; * value &squot;HighestTSNinSack&squot;. A newly&n;&t;&t;&t;&t; * acknowledged DATA chunk is one not&n;&t;&t;&t;&t; * previously acknowledged in a SACK.&n;&t;&t;&t;&t; *&n;&t;&t;&t;&t; * When the SCTP sender of data receives a SACK&n;&t;&t;&t;&t; * chunk that acknowledges, for the first time,&n;&t;&t;&t;&t; * the receipt of a DATA chunk, all the still&n;&t;&t;&t;&t; * unacknowledged DATA chunks whose TSN is&n;&t;&t;&t;&t; * older than that newly acknowledged DATA&n;&t;&t;&t;&t; * chunk, are qualified as &squot;Stray DATA chunks&squot;.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|tchunk-&gt;tsn_gap_acked
)paren
(brace
id|tchunk-&gt;tsn_gap_acked
op_assign
l_int|1
suffix:semicolon
id|bytes_acked
op_add_assign
id|sctp_data_size
c_func
(paren
id|tchunk
)paren
suffix:semicolon
)brace
id|list_add_tail
c_func
(paren
id|lchunk
comma
op_amp
id|tlist
)paren
suffix:semicolon
)brace
macro_line|#if SCTP_DEBUG
r_switch
c_cond
(paren
id|dbg_prt_state
)paren
(brace
r_case
l_int|0
suffix:colon
multiline_comment|/* last TSN was ACKed */
r_if
c_cond
(paren
id|dbg_last_ack_tsn
op_plus
l_int|1
op_eq
id|tsn
)paren
(brace
multiline_comment|/* This TSN belongs to the&n;&t;&t;&t;&t;&t; * current ACK range.&n;&t;&t;&t;&t;&t; */
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dbg_last_ack_tsn
op_ne
id|dbg_ack_tsn
)paren
(brace
multiline_comment|/* Display the end of the&n;&t;&t;&t;&t;&t; * current range.&n;&t;&t;&t;&t;&t; */
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;-%08x&quot;
comma
id|dbg_last_ack_tsn
)paren
suffix:semicolon
)brace
multiline_comment|/* Start a new range.  */
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;,%08x&quot;
comma
id|tsn
)paren
suffix:semicolon
id|dbg_ack_tsn
op_assign
id|tsn
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
multiline_comment|/* The last TSN was NOT ACKed. */
r_if
c_cond
(paren
id|dbg_last_kept_tsn
op_ne
id|dbg_kept_tsn
)paren
(brace
multiline_comment|/* Display the end of current range. */
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;-%08x&quot;
comma
id|dbg_last_kept_tsn
)paren
suffix:semicolon
)brace
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* FALL THROUGH... */
r_default
suffix:colon
multiline_comment|/* This is the first-ever TSN we examined.  */
multiline_comment|/* Start a new range of ACK-ed TSNs.  */
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;ACKed: %08x&quot;
comma
id|tsn
)paren
suffix:semicolon
id|dbg_prt_state
op_assign
l_int|0
suffix:semicolon
id|dbg_ack_tsn
op_assign
id|tsn
suffix:semicolon
)brace
suffix:semicolon
id|dbg_last_ack_tsn
op_assign
id|tsn
suffix:semicolon
macro_line|#endif /* SCTP_DEBUG */
)brace
r_else
(brace
r_if
c_cond
(paren
id|tchunk-&gt;tsn_gap_acked
)paren
(brace
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;%s: Receiver reneged on &quot;
l_string|&quot;data TSN: 0x%x&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|tsn
)paren
suffix:semicolon
id|tchunk-&gt;tsn_gap_acked
op_assign
l_int|0
suffix:semicolon
id|bytes_acked
op_sub_assign
id|sctp_data_size
c_func
(paren
id|tchunk
)paren
suffix:semicolon
multiline_comment|/* RFC 2960 6.3.2 Retransmission Timer Rules&n;&t;&t;&t;&t; *&n;&t;&t;&t;&t; * R4) Whenever a SACK is received missing a&n;&t;&t;&t;&t; * TSN that was previously acknowledged via a&n;&t;&t;&t;&t; * Gap Ack Block, start T3-rtx for the&n;&t;&t;&t;&t; * destination address to which the DATA&n;&t;&t;&t;&t; * chunk was originally&n;&t;&t;&t;&t; * transmitted if it is not already running.&n;&t;&t;&t;&t; */
id|restart_timer
op_assign
l_int|1
suffix:semicolon
)brace
id|list_add_tail
c_func
(paren
id|lchunk
comma
op_amp
id|tlist
)paren
suffix:semicolon
macro_line|#if SCTP_DEBUG
multiline_comment|/* See the above comments on ACK-ed TSNs. */
r_switch
c_cond
(paren
id|dbg_prt_state
)paren
(brace
r_case
l_int|1
suffix:colon
r_if
c_cond
(paren
id|dbg_last_kept_tsn
op_plus
l_int|1
op_eq
id|tsn
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|dbg_last_kept_tsn
op_ne
id|dbg_kept_tsn
)paren
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;-%08x&quot;
comma
id|dbg_last_kept_tsn
)paren
suffix:semicolon
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;,%08x&quot;
comma
id|tsn
)paren
suffix:semicolon
id|dbg_kept_tsn
op_assign
id|tsn
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0
suffix:colon
r_if
c_cond
(paren
id|dbg_last_ack_tsn
op_ne
id|dbg_ack_tsn
)paren
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;-%08x&quot;
comma
id|dbg_last_ack_tsn
)paren
suffix:semicolon
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* FALL THROUGH... */
r_default
suffix:colon
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;KEPT: %08x&quot;
comma
id|tsn
)paren
suffix:semicolon
id|dbg_prt_state
op_assign
l_int|1
suffix:semicolon
id|dbg_kept_tsn
op_assign
id|tsn
suffix:semicolon
)brace
suffix:semicolon
id|dbg_last_kept_tsn
op_assign
id|tsn
suffix:semicolon
macro_line|#endif /* SCTP_DEBUG */
)brace
)brace
macro_line|#if SCTP_DEBUG
multiline_comment|/* Finish off the last range, displaying its ending TSN.  */
r_switch
c_cond
(paren
id|dbg_prt_state
)paren
(brace
r_case
l_int|0
suffix:colon
r_if
c_cond
(paren
id|dbg_last_ack_tsn
op_ne
id|dbg_ack_tsn
)paren
(brace
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;-%08x&bslash;n&quot;
comma
id|dbg_last_ack_tsn
)paren
suffix:semicolon
)brace
r_else
(brace
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
r_if
c_cond
(paren
id|dbg_last_kept_tsn
op_ne
id|dbg_kept_tsn
)paren
(brace
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;-%08x&bslash;n&quot;
comma
id|dbg_last_kept_tsn
)paren
suffix:semicolon
)brace
r_else
(brace
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
suffix:semicolon
macro_line|#endif /* SCTP_DEBUG */
r_if
c_cond
(paren
id|transport
)paren
(brace
r_if
c_cond
(paren
id|bytes_acked
)paren
(brace
multiline_comment|/* 8.2. When an outstanding TSN is acknowledged,&n;&t;&t;&t; * the endpoint shall clear the error counter of&n;&t;&t;&t; * the destination transport address to which the&n;&t;&t;&t; * DATA chunk was last sent.&n;&t;&t;&t; * The association&squot;s overall error counter is&n;&t;&t;&t; * also cleared.&n;&t;&t;&t; */
id|transport-&gt;error_count
op_assign
l_int|0
suffix:semicolon
id|transport-&gt;asoc-&gt;overall_error_count
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Mark the destination transport address as&n;&t;&t;&t; * active if it is not so marked.&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|transport-&gt;active
)paren
(brace
id|sctp_assoc_control_transport
c_func
(paren
id|transport-&gt;asoc
comma
id|transport
comma
id|SCTP_TRANSPORT_UP
comma
id|SCTP_RECEIVED_SACK
)paren
suffix:semicolon
)brace
id|sctp_transport_raise_cwnd
c_func
(paren
id|transport
comma
id|sack_ctsn
comma
id|bytes_acked
)paren
suffix:semicolon
id|transport-&gt;flight_size
op_sub_assign
id|bytes_acked
suffix:semicolon
id|q-&gt;outstanding_bytes
op_sub_assign
id|bytes_acked
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* RFC 2960 6.1, sctpimpguide-06 2.15.2&n;&t;&t;&t; * When a sender is doing zero window probing, it&n;&t;&t;&t; * should not timeout the association if it continues&n;&t;&t;&t; * to receive new packets from the receiver. The&n;&t;&t;&t; * reason is that the receiver MAY keep its window&n;&t;&t;&t; * closed for an indefinite time.&n;&t;&t;&t; * A sender is doing zero window probing when the&n;&t;&t;&t; * receiver&squot;s advertised window is zero, and there is&n;&t;&t;&t; * only one data chunk in flight to the receiver.&n;&t;&t;&t; */
r_if
c_cond
(paren
(paren
l_int|0
op_eq
id|q-&gt;asoc-&gt;peer.rwnd
)paren
op_logical_and
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|tlist
)paren
)paren
op_logical_and
(paren
id|sack_ctsn
op_plus
l_int|2
op_eq
id|q-&gt;asoc-&gt;next_tsn
)paren
)paren
(brace
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;%s: SACK received for zero &quot;
l_string|&quot;window probe: %u&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|sack_ctsn
)paren
suffix:semicolon
id|q-&gt;asoc-&gt;overall_error_count
op_assign
l_int|0
suffix:semicolon
id|transport-&gt;error_count
op_assign
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/* RFC 2960 6.3.2 Retransmission Timer Rules&n;&t;&t; *&n;&t;&t; * R2) Whenever all outstanding data sent to an address have&n;&t;&t; * been acknowledged, turn off the T3-rtx timer of that&n;&t;&t; * address.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|transport-&gt;flight_size
)paren
(brace
r_if
c_cond
(paren
id|timer_pending
c_func
(paren
op_amp
id|transport-&gt;T3_rtx_timer
)paren
op_logical_and
id|del_timer
c_func
(paren
op_amp
id|transport-&gt;T3_rtx_timer
)paren
)paren
(brace
id|sctp_transport_put
c_func
(paren
id|transport
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|restart_timer
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|mod_timer
c_func
(paren
op_amp
id|transport-&gt;T3_rtx_timer
comma
id|jiffies
op_plus
id|transport-&gt;rto
)paren
)paren
id|sctp_transport_hold
c_func
(paren
id|transport
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Reconstruct the transmitted list with chunks that are not yet&n;&t; * acked by the Cumulative TSN Ack.&n;&t; */
r_while
c_loop
(paren
l_int|NULL
op_ne
(paren
id|lchunk
op_assign
id|sctp_list_dequeue
c_func
(paren
op_amp
id|tlist
)paren
)paren
)paren
(brace
id|tchunk
op_assign
id|list_entry
c_func
(paren
id|lchunk
comma
id|sctp_chunk_t
comma
id|transmitted_list
)paren
suffix:semicolon
id|tsn
op_assign
id|ntohl
c_func
(paren
id|tchunk-&gt;subh.data_hdr-&gt;tsn
)paren
suffix:semicolon
multiline_comment|/* RFC 2960 7.2.4, sctpimpguide-05 2.8.2 M3) Examine all&n;&t;&t; * &squot;Unacknowledged TSN&squot;s&squot;, if the TSN number of an&n;&t;&t; * &squot;Unacknowledged TSN&squot; is smaller than the &squot;HighestTSNinSack&squot;&n;&t;&t; * value, increment the &squot;TSN.Missing.Report&squot; count on that&n;&t;&t; * chunk if it has NOT been fast retransmitted or marked for&n;&t;&t; * fast retransmit already.&n;&t;&t; *&n;&t;&t; * M4) If any DATA chunk is found to have a&n;&t;&t; * &squot;TSN.Missing.Report&squot;&n;&t;&t; * value larger than or equal to 4, mark that chunk for&n;&t;&t; * retransmission and start the fast retransmit procedure.&n;&t;&t; */
r_if
c_cond
(paren
(paren
op_logical_neg
id|tchunk-&gt;fast_retransmit
)paren
op_logical_and
(paren
op_logical_neg
id|tchunk-&gt;tsn_gap_acked
)paren
op_logical_and
(paren
id|TSN_lt
c_func
(paren
id|tsn
comma
id|highest_new_tsn_in_sack
)paren
)paren
)paren
(brace
id|tchunk-&gt;tsn_missing_report
op_increment
suffix:semicolon
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;%s: TSN 0x%x missing counter: %d&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|tsn
comma
id|tchunk-&gt;tsn_missing_report
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tchunk-&gt;tsn_missing_report
op_ge
l_int|4
)paren
(brace
id|tchunk-&gt;fast_retransmit
op_assign
l_int|1
suffix:semicolon
id|do_fast_retransmit
op_assign
l_int|1
suffix:semicolon
)brace
id|list_add_tail
c_func
(paren
id|lchunk
comma
id|transmitted_queue
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|transport
)paren
(brace
r_if
c_cond
(paren
id|do_fast_retransmit
)paren
id|sctp_retransmit
c_func
(paren
id|q
comma
id|transport
comma
id|SCTP_RETRANSMIT_FAST_RTX
)paren
suffix:semicolon
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;%s: transport: %p, cwnd: %d, &quot;
l_string|&quot;ssthresh: %d, flight_size: %d, pba: %d&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|transport
comma
id|transport-&gt;cwnd
comma
id|transport-&gt;ssthresh
comma
id|transport-&gt;flight_size
comma
id|transport-&gt;partial_bytes_acked
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Is the given TSN acked by this packet?  */
DECL|function|sctp_acked
r_static
r_int
id|sctp_acked
c_func
(paren
id|sctp_sackhdr_t
op_star
id|sack
comma
id|__u32
id|tsn
)paren
(brace
r_int
id|i
suffix:semicolon
id|sctp_sack_variable_t
op_star
id|frags
suffix:semicolon
id|__u16
id|gap
suffix:semicolon
id|__u32
id|ctsn
op_assign
id|ntohl
c_func
(paren
id|sack-&gt;cum_tsn_ack
)paren
suffix:semicolon
r_if
c_cond
(paren
id|TSN_lte
c_func
(paren
id|tsn
comma
id|ctsn
)paren
)paren
r_goto
id|pass
suffix:semicolon
multiline_comment|/* 3.3.4 Selective Acknowledgement (SACK) (3):&n;&t; *&n;&t; * Gap Ack Blocks:&n;&t; *  These fields contain the Gap Ack Blocks. They are repeated&n;&t; *  for each Gap Ack Block up to the number of Gap Ack Blocks&n;&t; *  defined in the Number of Gap Ack Blocks field. All DATA&n;&t; *  chunks with TSNs greater than or equal to (Cumulative TSN&n;&t; *  Ack + Gap Ack Block Start) and less than or equal to&n;&t; *  (Cumulative TSN Ack + Gap Ack Block End) of each Gap Ack&n;&t; *  Block are assumed to have been received correctly.&n;&t; */
id|frags
op_assign
id|sack-&gt;variable
suffix:semicolon
id|gap
op_assign
id|tsn
op_minus
id|ctsn
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ntohs
c_func
(paren
id|sack-&gt;num_gap_ack_blocks
)paren
suffix:semicolon
op_increment
id|i
)paren
(brace
r_if
c_cond
(paren
id|TSN_lte
c_func
(paren
id|ntohs
c_func
(paren
id|frags
(braket
id|i
)braket
dot
id|gab.start
)paren
comma
id|gap
)paren
op_logical_and
id|TSN_lte
c_func
(paren
id|gap
comma
id|ntohs
c_func
(paren
id|frags
(braket
id|i
)braket
dot
id|gab.end
)paren
)paren
)paren
r_goto
id|pass
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
id|pass
suffix:colon
r_return
l_int|1
suffix:semicolon
)brace
eof
