multiline_comment|/* SCTP kernel reference Implementation&n; * (C) Copyright IBM Corp. 2001, 2004&n; * Copyright (c) 1999-2000 Cisco, Inc.&n; * Copyright (c) 1999-2001 Motorola, Inc.&n; * Copyright (c) 2001-2003 Intel Corp.&n; *&n; * This file is part of the SCTP kernel reference Implementation&n; *&n; * These functions implement the sctp_outq class.   The outqueue handles&n; * bundling and queueing of outgoing SCTP chunks.&n; *&n; * The SCTP reference implementation is free software;&n; * you can redistribute it and/or modify it under the terms of&n; * the GNU General Public License as published by&n; * the Free Software Foundation; either version 2, or (at your option)&n; * any later version.&n; *&n; * The SCTP reference implementation is distributed in the hope that it&n; * will be useful, but WITHOUT ANY WARRANTY; without even the implied&n; *                 ************************&n; * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&n; * See the GNU General Public License for more details.&n; *&n; * You should have received a copy of the GNU General Public License&n; * along with GNU CC; see the file COPYING.  If not, write to&n; * the Free Software Foundation, 59 Temple Place - Suite 330,&n; * Boston, MA 02111-1307, USA.&n; *&n; * Please send any bug reports or fixes you make to the&n; * email address(es):&n; *    lksctp developers &lt;lksctp-developers@lists.sourceforge.net&gt;&n; *&n; * Or submit a bug report through the following website:&n; *    http://www.sf.net/projects/lksctp&n; *&n; * Written or modified by:&n; *    La Monte H.P. Yarroll &lt;piggy@acm.org&gt;&n; *    Karl Knutson          &lt;karl@athena.chicago.il.us&gt;&n; *    Perry Melange         &lt;pmelange@null.cc.uic.edu&gt;&n; *    Xingang Guo           &lt;xingang.guo@intel.com&gt;&n; *    Hui Huang &t;    &lt;hui.huang@nokia.com&gt;&n; *    Sridhar Samudrala     &lt;sri@us.ibm.com&gt;&n; *    Jon Grimm             &lt;jgrimm@us.ibm.com&gt;&n; *&n; * Any bugs reported given to us we will try to fix... any fixes shared will&n; * be incorporated into the next SCTP release.&n; */
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/list.h&gt;   /* For struct list_head */
macro_line|#include &lt;linux/socket.h&gt;
macro_line|#include &lt;linux/ip.h&gt;
macro_line|#include &lt;net/sock.h&gt;&t;  /* For skb_set_owner_w */
macro_line|#include &lt;net/sctp/sctp.h&gt;
macro_line|#include &lt;net/sctp/sm.h&gt;
multiline_comment|/* Declare internal functions here.  */
r_static
r_int
id|sctp_acked
c_func
(paren
r_struct
id|sctp_sackhdr
op_star
id|sack
comma
id|__u32
id|tsn
)paren
suffix:semicolon
r_static
r_void
id|sctp_check_transmitted
c_func
(paren
r_struct
id|sctp_outq
op_star
id|q
comma
r_struct
id|list_head
op_star
id|transmitted_queue
comma
r_struct
id|sctp_transport
op_star
id|transport
comma
r_struct
id|sctp_sackhdr
op_star
id|sack
comma
id|__u32
id|highest_new_tsn
)paren
suffix:semicolon
r_static
r_void
id|sctp_mark_missing
c_func
(paren
r_struct
id|sctp_outq
op_star
id|q
comma
r_struct
id|list_head
op_star
id|transmitted_queue
comma
r_struct
id|sctp_transport
op_star
id|transport
comma
id|__u32
id|highest_new_tsn
comma
r_int
id|count_of_newacks
)paren
suffix:semicolon
r_static
r_void
id|sctp_generate_fwdtsn
c_func
(paren
r_struct
id|sctp_outq
op_star
id|q
comma
id|__u32
id|sack_ctsn
)paren
suffix:semicolon
multiline_comment|/* Add data to the front of the queue. */
DECL|function|sctp_outq_head_data
r_static
r_inline
r_void
id|sctp_outq_head_data
c_func
(paren
r_struct
id|sctp_outq
op_star
id|q
comma
r_struct
id|sctp_chunk
op_star
id|ch
)paren
(brace
id|__skb_queue_head
c_func
(paren
op_amp
id|q-&gt;out
comma
(paren
r_struct
id|sk_buff
op_star
)paren
id|ch
)paren
suffix:semicolon
id|q-&gt;out_qlen
op_add_assign
id|ch-&gt;skb-&gt;len
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Take data from the front of the queue. */
DECL|function|sctp_outq_dequeue_data
r_static
r_inline
r_struct
id|sctp_chunk
op_star
id|sctp_outq_dequeue_data
c_func
(paren
r_struct
id|sctp_outq
op_star
id|q
)paren
(brace
r_struct
id|sctp_chunk
op_star
id|ch
suffix:semicolon
id|ch
op_assign
(paren
r_struct
id|sctp_chunk
op_star
)paren
id|__skb_dequeue
c_func
(paren
op_amp
id|q-&gt;out
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ch
)paren
id|q-&gt;out_qlen
op_sub_assign
id|ch-&gt;skb-&gt;len
suffix:semicolon
r_return
id|ch
suffix:semicolon
)brace
multiline_comment|/* Add data chunk to the end of the queue. */
DECL|function|sctp_outq_tail_data
r_static
r_inline
r_void
id|sctp_outq_tail_data
c_func
(paren
r_struct
id|sctp_outq
op_star
id|q
comma
r_struct
id|sctp_chunk
op_star
id|ch
)paren
(brace
id|__skb_queue_tail
c_func
(paren
op_amp
id|q-&gt;out
comma
(paren
r_struct
id|sk_buff
op_star
)paren
id|ch
)paren
suffix:semicolon
id|q-&gt;out_qlen
op_add_assign
id|ch-&gt;skb-&gt;len
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * SFR-CACC algorithm:&n; * D) If count_of_newacks is greater than or equal to 2&n; * and t was not sent to the current primary then the&n; * sender MUST NOT increment missing report count for t.&n; */
DECL|function|sctp_cacc_skip_3_1_d
r_static
r_inline
r_int
id|sctp_cacc_skip_3_1_d
c_func
(paren
r_struct
id|sctp_transport
op_star
id|primary
comma
r_struct
id|sctp_transport
op_star
id|transport
comma
r_int
id|count_of_newacks
)paren
(brace
r_if
c_cond
(paren
id|count_of_newacks
op_ge
l_int|2
op_logical_and
id|transport
op_ne
id|primary
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * SFR-CACC algorithm:&n; * F) If count_of_newacks is less than 2, let d be the&n; * destination to which t was sent. If cacc_saw_newack&n; * is 0 for destination d, then the sender MUST NOT&n; * increment missing report count for t.&n; */
DECL|function|sctp_cacc_skip_3_1_f
r_static
r_inline
r_int
id|sctp_cacc_skip_3_1_f
c_func
(paren
r_struct
id|sctp_transport
op_star
id|transport
comma
r_int
id|count_of_newacks
)paren
(brace
r_if
c_cond
(paren
id|count_of_newacks
OL
l_int|2
op_logical_and
op_logical_neg
id|transport-&gt;cacc.cacc_saw_newack
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * SFR-CACC algorithm:&n; * 3.1) If CYCLING_CHANGEOVER is 0, the sender SHOULD&n; * execute steps C, D, F.&n; *&n; * C has been implemented in sctp_outq_sack&n; */
DECL|function|sctp_cacc_skip_3_1
r_static
r_inline
r_int
id|sctp_cacc_skip_3_1
c_func
(paren
r_struct
id|sctp_transport
op_star
id|primary
comma
r_struct
id|sctp_transport
op_star
id|transport
comma
r_int
id|count_of_newacks
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|primary-&gt;cacc.cycling_changeover
)paren
(brace
r_if
c_cond
(paren
id|sctp_cacc_skip_3_1_d
c_func
(paren
id|primary
comma
id|transport
comma
id|count_of_newacks
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|sctp_cacc_skip_3_1_f
c_func
(paren
id|transport
comma
id|count_of_newacks
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * SFR-CACC algorithm:&n; * 3.2) Else if CYCLING_CHANGEOVER is 1, and t is less&n; * than next_tsn_at_change of the current primary, then&n; * the sender MUST NOT increment missing report count&n; * for t.&n; */
DECL|function|sctp_cacc_skip_3_2
r_static
r_inline
r_int
id|sctp_cacc_skip_3_2
c_func
(paren
r_struct
id|sctp_transport
op_star
id|primary
comma
id|__u32
id|tsn
)paren
(brace
r_if
c_cond
(paren
id|primary-&gt;cacc.cycling_changeover
op_logical_and
id|TSN_lt
c_func
(paren
id|tsn
comma
id|primary-&gt;cacc.next_tsn_at_change
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * SFR-CACC algorithm:&n; * 3) If the missing report count for TSN t is to be&n; * incremented according to [RFC2960] and&n; * [SCTP_STEWART-2002], and CHANGEOVER_ACTIVE is set,&n; * then the sender MUST futher execute steps 3.1 and&n; * 3.2 to determine if the missing report count for&n; * TSN t SHOULD NOT be incremented.&n; *&n; * 3.3) If 3.1 and 3.2 do not dictate that the missing&n; * report count for t should not be incremented, then&n; * the sender SOULD increment missing report count for&n; * t (according to [RFC2960] and [SCTP_STEWART_2002]).&n; */
DECL|function|sctp_cacc_skip
r_static
r_inline
r_int
id|sctp_cacc_skip
c_func
(paren
r_struct
id|sctp_transport
op_star
id|primary
comma
r_struct
id|sctp_transport
op_star
id|transport
comma
r_int
id|count_of_newacks
comma
id|__u32
id|tsn
)paren
(brace
r_if
c_cond
(paren
id|primary-&gt;cacc.changeover_active
op_logical_and
(paren
id|sctp_cacc_skip_3_1
c_func
(paren
id|primary
comma
id|transport
comma
id|count_of_newacks
)paren
op_logical_or
id|sctp_cacc_skip_3_2
c_func
(paren
id|primary
comma
id|tsn
)paren
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Generate a new outqueue.  */
DECL|function|sctp_outq_new
r_struct
id|sctp_outq
op_star
id|sctp_outq_new
c_func
(paren
r_struct
id|sctp_association
op_star
id|asoc
)paren
(brace
r_struct
id|sctp_outq
op_star
id|q
suffix:semicolon
id|q
op_assign
id|t_new
c_func
(paren
r_struct
id|sctp_outq
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|q
)paren
(brace
id|sctp_outq_init
c_func
(paren
id|asoc
comma
id|q
)paren
suffix:semicolon
id|q-&gt;malloced
op_assign
l_int|1
suffix:semicolon
)brace
r_return
id|q
suffix:semicolon
)brace
multiline_comment|/* Initialize an existing sctp_outq.  This does the boring stuff.&n; * You still need to define handlers if you really want to DO&n; * something with this structure...&n; */
DECL|function|sctp_outq_init
r_void
id|sctp_outq_init
c_func
(paren
r_struct
id|sctp_association
op_star
id|asoc
comma
r_struct
id|sctp_outq
op_star
id|q
)paren
(brace
id|q-&gt;asoc
op_assign
id|asoc
suffix:semicolon
id|skb_queue_head_init
c_func
(paren
op_amp
id|q-&gt;out
)paren
suffix:semicolon
id|skb_queue_head_init
c_func
(paren
op_amp
id|q-&gt;control
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|q-&gt;retransmit
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|q-&gt;sacked
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|q-&gt;abandoned
)paren
suffix:semicolon
id|q-&gt;outstanding_bytes
op_assign
l_int|0
suffix:semicolon
id|q-&gt;empty
op_assign
l_int|1
suffix:semicolon
id|q-&gt;cork
op_assign
l_int|0
suffix:semicolon
id|q-&gt;malloced
op_assign
l_int|0
suffix:semicolon
id|q-&gt;out_qlen
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Free the outqueue structure and any related pending chunks.&n; */
DECL|function|sctp_outq_teardown
r_void
id|sctp_outq_teardown
c_func
(paren
r_struct
id|sctp_outq
op_star
id|q
)paren
(brace
r_struct
id|sctp_transport
op_star
id|transport
suffix:semicolon
r_struct
id|list_head
op_star
id|lchunk
comma
op_star
id|pos
comma
op_star
id|temp
suffix:semicolon
r_struct
id|sctp_chunk
op_star
id|chunk
suffix:semicolon
multiline_comment|/* Throw away unacknowledged chunks. */
id|list_for_each
c_func
(paren
id|pos
comma
op_amp
id|q-&gt;asoc-&gt;peer.transport_addr_list
)paren
(brace
id|transport
op_assign
id|list_entry
c_func
(paren
id|pos
comma
r_struct
id|sctp_transport
comma
id|transports
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|lchunk
op_assign
id|sctp_list_dequeue
c_func
(paren
op_amp
id|transport-&gt;transmitted
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|chunk
op_assign
id|list_entry
c_func
(paren
id|lchunk
comma
r_struct
id|sctp_chunk
comma
id|transmitted_list
)paren
suffix:semicolon
multiline_comment|/* Mark as part of a failed message. */
id|sctp_chunk_fail
c_func
(paren
id|chunk
comma
id|q-&gt;error
)paren
suffix:semicolon
id|sctp_chunk_free
c_func
(paren
id|chunk
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Throw away chunks that have been gap ACKed.  */
id|list_for_each_safe
c_func
(paren
id|lchunk
comma
id|temp
comma
op_amp
id|q-&gt;sacked
)paren
(brace
id|list_del_init
c_func
(paren
id|lchunk
)paren
suffix:semicolon
id|chunk
op_assign
id|list_entry
c_func
(paren
id|lchunk
comma
r_struct
id|sctp_chunk
comma
id|transmitted_list
)paren
suffix:semicolon
id|sctp_chunk_fail
c_func
(paren
id|chunk
comma
id|q-&gt;error
)paren
suffix:semicolon
id|sctp_chunk_free
c_func
(paren
id|chunk
)paren
suffix:semicolon
)brace
multiline_comment|/* Throw away any chunks in the retransmit queue. */
id|list_for_each_safe
c_func
(paren
id|lchunk
comma
id|temp
comma
op_amp
id|q-&gt;retransmit
)paren
(brace
id|list_del_init
c_func
(paren
id|lchunk
)paren
suffix:semicolon
id|chunk
op_assign
id|list_entry
c_func
(paren
id|lchunk
comma
r_struct
id|sctp_chunk
comma
id|transmitted_list
)paren
suffix:semicolon
id|sctp_chunk_fail
c_func
(paren
id|chunk
comma
id|q-&gt;error
)paren
suffix:semicolon
id|sctp_chunk_free
c_func
(paren
id|chunk
)paren
suffix:semicolon
)brace
multiline_comment|/* Throw away any chunks that are in the abandoned queue. */
id|list_for_each_safe
c_func
(paren
id|lchunk
comma
id|temp
comma
op_amp
id|q-&gt;abandoned
)paren
(brace
id|list_del_init
c_func
(paren
id|lchunk
)paren
suffix:semicolon
id|chunk
op_assign
id|list_entry
c_func
(paren
id|lchunk
comma
r_struct
id|sctp_chunk
comma
id|transmitted_list
)paren
suffix:semicolon
id|sctp_chunk_fail
c_func
(paren
id|chunk
comma
id|q-&gt;error
)paren
suffix:semicolon
id|sctp_chunk_free
c_func
(paren
id|chunk
)paren
suffix:semicolon
)brace
multiline_comment|/* Throw away any leftover data chunks. */
r_while
c_loop
(paren
(paren
id|chunk
op_assign
id|sctp_outq_dequeue_data
c_func
(paren
id|q
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* Mark as send failure. */
id|sctp_chunk_fail
c_func
(paren
id|chunk
comma
id|q-&gt;error
)paren
suffix:semicolon
id|sctp_chunk_free
c_func
(paren
id|chunk
)paren
suffix:semicolon
)brace
id|q-&gt;error
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Throw away any leftover control chunks. */
r_while
c_loop
(paren
(paren
id|chunk
op_assign
(paren
r_struct
id|sctp_chunk
op_star
)paren
id|skb_dequeue
c_func
(paren
op_amp
id|q-&gt;control
)paren
)paren
op_ne
l_int|NULL
)paren
id|sctp_chunk_free
c_func
(paren
id|chunk
)paren
suffix:semicolon
)brace
multiline_comment|/* Free the outqueue structure and any related pending chunks.  */
DECL|function|sctp_outq_free
r_void
id|sctp_outq_free
c_func
(paren
r_struct
id|sctp_outq
op_star
id|q
)paren
(brace
multiline_comment|/* Throw away leftover chunks. */
id|sctp_outq_teardown
c_func
(paren
id|q
)paren
suffix:semicolon
multiline_comment|/* If we were kmalloc()&squot;d, free the memory.  */
r_if
c_cond
(paren
id|q-&gt;malloced
)paren
id|kfree
c_func
(paren
id|q
)paren
suffix:semicolon
)brace
multiline_comment|/* Put a new chunk in an sctp_outq.  */
DECL|function|sctp_outq_tail
r_int
id|sctp_outq_tail
c_func
(paren
r_struct
id|sctp_outq
op_star
id|q
comma
r_struct
id|sctp_chunk
op_star
id|chunk
)paren
(brace
r_int
id|error
op_assign
l_int|0
suffix:semicolon
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;sctp_outq_tail(%p, %p[%s])&bslash;n&quot;
comma
id|q
comma
id|chunk
comma
id|chunk
op_logical_and
id|chunk-&gt;chunk_hdr
ques
c_cond
id|sctp_cname
c_func
(paren
id|SCTP_ST_CHUNK
c_func
(paren
id|chunk-&gt;chunk_hdr-&gt;type
)paren
)paren
suffix:colon
l_string|&quot;Illegal Chunk&quot;
)paren
suffix:semicolon
multiline_comment|/* If it is data, queue it up, otherwise, send it&n;&t; * immediately.&n;&t; */
r_if
c_cond
(paren
id|SCTP_CID_DATA
op_eq
id|chunk-&gt;chunk_hdr-&gt;type
)paren
(brace
multiline_comment|/* Is it OK to queue data chunks?  */
multiline_comment|/* From 9. Termination of Association&n;&t;&t; *&n;&t;&t; * When either endpoint performs a shutdown, the&n;&t;&t; * association on each peer will stop accepting new&n;&t;&t; * data from its user and only deliver data in queue&n;&t;&t; * at the time of sending or receiving the SHUTDOWN&n;&t;&t; * chunk.&n;&t;&t; */
r_switch
c_cond
(paren
id|q-&gt;asoc-&gt;state
)paren
(brace
r_case
id|SCTP_STATE_EMPTY
suffix:colon
r_case
id|SCTP_STATE_CLOSED
suffix:colon
r_case
id|SCTP_STATE_SHUTDOWN_PENDING
suffix:colon
r_case
id|SCTP_STATE_SHUTDOWN_SENT
suffix:colon
r_case
id|SCTP_STATE_SHUTDOWN_RECEIVED
suffix:colon
r_case
id|SCTP_STATE_SHUTDOWN_ACK_SENT
suffix:colon
multiline_comment|/* Cannot send after transport endpoint shutdown */
id|error
op_assign
op_minus
id|ESHUTDOWN
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;outqueueing (%p, %p[%s])&bslash;n&quot;
comma
id|q
comma
id|chunk
comma
id|chunk
op_logical_and
id|chunk-&gt;chunk_hdr
ques
c_cond
id|sctp_cname
c_func
(paren
id|SCTP_ST_CHUNK
c_func
(paren
id|chunk-&gt;chunk_hdr-&gt;type
)paren
)paren
suffix:colon
l_string|&quot;Illegal Chunk&quot;
)paren
suffix:semicolon
id|sctp_outq_tail_data
c_func
(paren
id|q
comma
id|chunk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|chunk-&gt;chunk_hdr-&gt;flags
op_amp
id|SCTP_DATA_UNORDERED
)paren
id|SCTP_INC_STATS
c_func
(paren
id|SCTP_MIB_OUTUNORDERCHUNKS
)paren
suffix:semicolon
r_else
id|SCTP_INC_STATS
c_func
(paren
id|SCTP_MIB_OUTORDERCHUNKS
)paren
suffix:semicolon
id|q-&gt;empty
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
suffix:semicolon
)brace
r_else
(brace
id|__skb_queue_tail
c_func
(paren
op_amp
id|q-&gt;control
comma
(paren
r_struct
id|sk_buff
op_star
)paren
id|chunk
)paren
suffix:semicolon
id|SCTP_INC_STATS
c_func
(paren
id|SCTP_MIB_OUTCTRLCHUNKS
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|error
OL
l_int|0
)paren
r_return
id|error
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|q-&gt;cork
)paren
id|error
op_assign
id|sctp_outq_flush
c_func
(paren
id|q
comma
l_int|0
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/* Insert a chunk into the sorted list based on the TSNs.  The retransmit list&n; * and the abandoned list are in ascending order.&n; */
DECL|function|sctp_insert_list
r_void
id|sctp_insert_list
c_func
(paren
r_struct
id|list_head
op_star
id|head
comma
r_struct
id|list_head
op_star
r_new
)paren
(brace
r_struct
id|list_head
op_star
id|pos
suffix:semicolon
r_struct
id|sctp_chunk
op_star
id|nchunk
comma
op_star
id|lchunk
suffix:semicolon
id|__u32
id|ntsn
comma
id|ltsn
suffix:semicolon
r_int
id|done
op_assign
l_int|0
suffix:semicolon
id|nchunk
op_assign
id|list_entry
c_func
(paren
r_new
comma
r_struct
id|sctp_chunk
comma
id|transmitted_list
)paren
suffix:semicolon
id|ntsn
op_assign
id|ntohl
c_func
(paren
id|nchunk-&gt;subh.data_hdr-&gt;tsn
)paren
suffix:semicolon
id|list_for_each
c_func
(paren
id|pos
comma
id|head
)paren
(brace
id|lchunk
op_assign
id|list_entry
c_func
(paren
id|pos
comma
r_struct
id|sctp_chunk
comma
id|transmitted_list
)paren
suffix:semicolon
id|ltsn
op_assign
id|ntohl
c_func
(paren
id|lchunk-&gt;subh.data_hdr-&gt;tsn
)paren
suffix:semicolon
r_if
c_cond
(paren
id|TSN_lt
c_func
(paren
id|ntsn
comma
id|ltsn
)paren
)paren
(brace
id|list_add
c_func
(paren
r_new
comma
id|pos-&gt;prev
)paren
suffix:semicolon
id|done
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|done
)paren
id|list_add_tail
c_func
(paren
r_new
comma
id|head
)paren
suffix:semicolon
)brace
multiline_comment|/* Mark all the eligible packets on a transport for retransmission.  */
DECL|function|sctp_retransmit_mark
r_void
id|sctp_retransmit_mark
c_func
(paren
r_struct
id|sctp_outq
op_star
id|q
comma
r_struct
id|sctp_transport
op_star
id|transport
comma
id|__u8
id|fast_retransmit
)paren
(brace
r_struct
id|list_head
op_star
id|lchunk
comma
op_star
id|ltemp
suffix:semicolon
r_struct
id|sctp_chunk
op_star
id|chunk
suffix:semicolon
multiline_comment|/* Walk through the specified transmitted queue.  */
id|list_for_each_safe
c_func
(paren
id|lchunk
comma
id|ltemp
comma
op_amp
id|transport-&gt;transmitted
)paren
(brace
id|chunk
op_assign
id|list_entry
c_func
(paren
id|lchunk
comma
r_struct
id|sctp_chunk
comma
id|transmitted_list
)paren
suffix:semicolon
multiline_comment|/* If the chunk is abandoned, move it to abandoned list. */
r_if
c_cond
(paren
id|sctp_chunk_abandoned
c_func
(paren
id|chunk
)paren
)paren
(brace
id|list_del_init
c_func
(paren
id|lchunk
)paren
suffix:semicolon
id|sctp_insert_list
c_func
(paren
op_amp
id|q-&gt;abandoned
comma
id|lchunk
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* If we are doing retransmission due to a fast retransmit,&n;&t;&t; * only the chunk&squot;s that are marked for fast retransmit&n;&t;&t; * should be added to the retransmit queue.  If we are doing&n;&t;&t; * retransmission due to a timeout or pmtu discovery, only the&n;&t;&t; * chunks that are not yet acked should be added to the&n;&t;&t; * retransmit queue.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|fast_retransmit
op_logical_and
id|chunk-&gt;fast_retransmit
)paren
op_logical_or
(paren
op_logical_neg
id|fast_retransmit
op_logical_and
op_logical_neg
id|chunk-&gt;tsn_gap_acked
)paren
)paren
(brace
multiline_comment|/* RFC 2960 6.2.1 Processing a Received SACK&n;&t;&t;&t; *&n;&t;&t;&t; * C) Any time a DATA chunk is marked for&n;&t;&t;&t; * retransmission (via either T3-rtx timer expiration&n;&t;&t;&t; * (Section 6.3.3) or via fast retransmit&n;&t;&t;&t; * (Section 7.2.4)), add the data size of those&n;&t;&t;&t; * chunks to the rwnd.&n;&t;&t;&t; */
id|q-&gt;asoc-&gt;peer.rwnd
op_add_assign
id|sctp_data_size
c_func
(paren
id|chunk
)paren
suffix:semicolon
id|q-&gt;outstanding_bytes
op_sub_assign
id|sctp_data_size
c_func
(paren
id|chunk
)paren
suffix:semicolon
id|transport-&gt;flight_size
op_sub_assign
id|sctp_data_size
c_func
(paren
id|chunk
)paren
suffix:semicolon
multiline_comment|/* sctpimpguide-05 Section 2.8.2&n;&t;&t;&t; * M5) If a T3-rtx timer expires, the&n;&t;&t;&t; * &squot;TSN.Missing.Report&squot; of all affected TSNs is set&n;&t;&t;&t; * to 0.&n;&t;&t;&t; */
id|chunk-&gt;tsn_missing_report
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* If a chunk that is being used for RTT measurement&n;&t;&t;&t; * has to be retransmitted, we cannot use this chunk&n;&t;&t;&t; * anymore for RTT measurements. Reset rto_pending so&n;&t;&t;&t; * that a new RTT measurement is started when a new&n;&t;&t;&t; * data chunk is sent.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|chunk-&gt;rtt_in_progress
)paren
(brace
id|chunk-&gt;rtt_in_progress
op_assign
l_int|0
suffix:semicolon
id|transport-&gt;rto_pending
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Move the chunk to the retransmit queue. The chunks&n;&t;&t;&t; * on the retransmit queue are always kept in order.&n;&t;&t;&t; */
id|list_del_init
c_func
(paren
id|lchunk
)paren
suffix:semicolon
id|sctp_insert_list
c_func
(paren
op_amp
id|q-&gt;retransmit
comma
id|lchunk
)paren
suffix:semicolon
)brace
)brace
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;%s: transport: %p, fast_retransmit: %d, &quot;
l_string|&quot;cwnd: %d, ssthresh: %d, flight_size: %d, &quot;
l_string|&quot;pba: %d&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|transport
comma
id|fast_retransmit
comma
id|transport-&gt;cwnd
comma
id|transport-&gt;ssthresh
comma
id|transport-&gt;flight_size
comma
id|transport-&gt;partial_bytes_acked
)paren
suffix:semicolon
)brace
multiline_comment|/* Mark all the eligible packets on a transport for retransmission and force&n; * one packet out.&n; */
DECL|function|sctp_retransmit
r_void
id|sctp_retransmit
c_func
(paren
r_struct
id|sctp_outq
op_star
id|q
comma
r_struct
id|sctp_transport
op_star
id|transport
comma
id|sctp_retransmit_reason_t
id|reason
)paren
(brace
r_int
id|error
op_assign
l_int|0
suffix:semicolon
id|__u8
id|fast_retransmit
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|reason
)paren
(brace
r_case
id|SCTP_RTXR_T3_RTX
suffix:colon
id|sctp_transport_lower_cwnd
c_func
(paren
id|transport
comma
id|SCTP_LOWER_CWND_T3_RTX
)paren
suffix:semicolon
multiline_comment|/* Update the retran path if the T3-rtx timer has expired for&n;&t;&t; * the current retran path.&n;&t;&t; */
r_if
c_cond
(paren
id|transport
op_eq
id|transport-&gt;asoc-&gt;peer.retran_path
)paren
id|sctp_assoc_update_retran_path
c_func
(paren
id|transport-&gt;asoc
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_RTXR_FAST_RTX
suffix:colon
id|sctp_transport_lower_cwnd
c_func
(paren
id|transport
comma
id|SCTP_LOWER_CWND_FAST_RTX
)paren
suffix:semicolon
id|fast_retransmit
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_RTXR_PMTUD
suffix:colon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
id|sctp_retransmit_mark
c_func
(paren
id|q
comma
id|transport
comma
id|fast_retransmit
)paren
suffix:semicolon
multiline_comment|/* PR-SCTP A5) Any time the T3-rtx timer expires, on any destination,&n;&t; * the sender SHOULD try to advance the &quot;Advanced.Peer.Ack.Point&quot; by&n;&t; * following the procedures outlined in C1 - C5.&n;&t; */
id|sctp_generate_fwdtsn
c_func
(paren
id|q
comma
id|q-&gt;asoc-&gt;ctsn_ack_point
)paren
suffix:semicolon
id|error
op_assign
id|sctp_outq_flush
c_func
(paren
id|q
comma
multiline_comment|/* rtx_timeout */
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
id|q-&gt;asoc-&gt;base.sk-&gt;sk_err
op_assign
op_minus
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * Transmit DATA chunks on the retransmit queue.  Upon return from&n; * sctp_outq_flush_rtx() the packet &squot;pkt&squot; may contain chunks which&n; * need to be transmitted by the caller.&n; * We assume that pkt-&gt;transport has already been set.&n; *&n; * The return value is a normal kernel error return value.&n; */
DECL|function|sctp_outq_flush_rtx
r_static
r_int
id|sctp_outq_flush_rtx
c_func
(paren
r_struct
id|sctp_outq
op_star
id|q
comma
r_struct
id|sctp_packet
op_star
id|pkt
comma
r_int
id|rtx_timeout
comma
r_int
op_star
id|start_timer
)paren
(brace
r_struct
id|list_head
op_star
id|lqueue
suffix:semicolon
r_struct
id|list_head
op_star
id|lchunk
comma
op_star
id|lchunk1
suffix:semicolon
r_struct
id|sctp_transport
op_star
id|transport
op_assign
id|pkt-&gt;transport
suffix:semicolon
id|sctp_xmit_t
id|status
suffix:semicolon
r_struct
id|sctp_chunk
op_star
id|chunk
comma
op_star
id|chunk1
suffix:semicolon
r_struct
id|sctp_association
op_star
id|asoc
suffix:semicolon
r_int
id|error
op_assign
l_int|0
suffix:semicolon
id|asoc
op_assign
id|q-&gt;asoc
suffix:semicolon
id|lqueue
op_assign
op_amp
id|q-&gt;retransmit
suffix:semicolon
multiline_comment|/* RFC 2960 6.3.3 Handle T3-rtx Expiration&n;&t; *&n;&t; * E3) Determine how many of the earliest (i.e., lowest TSN)&n;&t; * outstanding DATA chunks for the address for which the&n;&t; * T3-rtx has expired will fit into a single packet, subject&n;&t; * to the MTU constraint for the path corresponding to the&n;&t; * destination transport address to which the retransmission&n;&t; * is being sent (this may be different from the address for&n;&t; * which the timer expires [see Section 6.4]). Call this value&n;&t; * K. Bundle and retransmit those K DATA chunks in a single&n;&t; * packet to the destination endpoint.&n;&t; *&n;&t; * [Just to be painfully clear, if we are retransmitting&n;&t; * because a timeout just happened, we should send only ONE&n;&t; * packet of retransmitted data.]&n;&t; */
id|lchunk
op_assign
id|sctp_list_dequeue
c_func
(paren
id|lqueue
)paren
suffix:semicolon
r_while
c_loop
(paren
id|lchunk
)paren
(brace
id|chunk
op_assign
id|list_entry
c_func
(paren
id|lchunk
comma
r_struct
id|sctp_chunk
comma
id|transmitted_list
)paren
suffix:semicolon
multiline_comment|/* Make sure that Gap Acked TSNs are not retransmitted.  A&n;&t;&t; * simple approach is just to move such TSNs out of the&n;&t;&t; * way and into a &squot;transmitted&squot; queue and skip to the&n;&t;&t; * next chunk.&n;&t;&t; */
r_if
c_cond
(paren
id|chunk-&gt;tsn_gap_acked
)paren
(brace
id|list_add_tail
c_func
(paren
id|lchunk
comma
op_amp
id|transport-&gt;transmitted
)paren
suffix:semicolon
id|lchunk
op_assign
id|sctp_list_dequeue
c_func
(paren
id|lqueue
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* Attempt to append this chunk to the packet. */
id|status
op_assign
id|sctp_packet_append_chunk
c_func
(paren
id|pkt
comma
id|chunk
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|status
)paren
(brace
r_case
id|SCTP_XMIT_PMTU_FULL
suffix:colon
multiline_comment|/* Send this packet.  */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|sctp_packet_transmit
c_func
(paren
id|pkt
)paren
)paren
op_eq
l_int|0
)paren
op_star
id|start_timer
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* If we are retransmitting, we should only&n;&t;&t;&t; * send a single packet.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|rtx_timeout
)paren
(brace
id|list_add
c_func
(paren
id|lchunk
comma
id|lqueue
)paren
suffix:semicolon
id|lchunk
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Bundle lchunk in the next round.  */
r_break
suffix:semicolon
r_case
id|SCTP_XMIT_RWND_FULL
suffix:colon
multiline_comment|/* Send this packet. */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|sctp_packet_transmit
c_func
(paren
id|pkt
)paren
)paren
op_eq
l_int|0
)paren
op_star
id|start_timer
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Stop sending DATA as there is no more room&n;&t;&t;&t; * at the receiver.&n;&t;&t;&t; */
id|list_add
c_func
(paren
id|lchunk
comma
id|lqueue
)paren
suffix:semicolon
id|lchunk
op_assign
l_int|NULL
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_XMIT_NAGLE_DELAY
suffix:colon
multiline_comment|/* Send this packet. */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|sctp_packet_transmit
c_func
(paren
id|pkt
)paren
)paren
op_eq
l_int|0
)paren
op_star
id|start_timer
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Stop sending DATA because of nagle delay. */
id|list_add
c_func
(paren
id|lchunk
comma
id|lqueue
)paren
suffix:semicolon
id|lchunk
op_assign
l_int|NULL
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* The append was successful, so add this chunk to&n;&t;&t;&t; * the transmitted list.&n;&t;&t;&t; */
id|list_add_tail
c_func
(paren
id|lchunk
comma
op_amp
id|transport-&gt;transmitted
)paren
suffix:semicolon
multiline_comment|/* Mark the chunk as ineligible for fast retransmit &n;&t;&t;&t; * after it is retransmitted.&n;&t;&t;&t; */
id|chunk-&gt;fast_retransmit
op_assign
l_int|0
suffix:semicolon
op_star
id|start_timer
op_assign
l_int|1
suffix:semicolon
id|q-&gt;empty
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Retrieve a new chunk to bundle. */
id|lchunk
op_assign
id|sctp_list_dequeue
c_func
(paren
id|lqueue
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* If we are here due to a retransmit timeout or a fast&n;&t;&t; * retransmit and if there are any chunks left in the retransmit&n;&t;&t; * queue that could not fit in the PMTU sized packet, they need&t;&t;&t; * to be marked as ineligible for a subsequent fast retransmit.&n;&t;&t; */
r_if
c_cond
(paren
id|rtx_timeout
op_logical_and
op_logical_neg
id|lchunk
)paren
(brace
id|list_for_each
c_func
(paren
id|lchunk1
comma
id|lqueue
)paren
(brace
id|chunk1
op_assign
id|list_entry
c_func
(paren
id|lchunk1
comma
r_struct
id|sctp_chunk
comma
id|transmitted_list
)paren
suffix:semicolon
id|chunk1-&gt;fast_retransmit
op_assign
l_int|0
suffix:semicolon
)brace
)brace
)brace
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/* Cork the outqueue so queued chunks are really queued. */
DECL|function|sctp_outq_uncork
r_int
id|sctp_outq_uncork
c_func
(paren
r_struct
id|sctp_outq
op_star
id|q
)paren
(brace
r_int
id|error
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|q-&gt;cork
)paren
(brace
id|q-&gt;cork
op_assign
l_int|0
suffix:semicolon
id|error
op_assign
id|sctp_outq_flush
c_func
(paren
id|q
comma
l_int|0
)paren
suffix:semicolon
)brace
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * Try to flush an outqueue.&n; *&n; * Description: Send everything in q which we legally can, subject to&n; * congestion limitations.&n; * * Note: This function can be called from multiple contexts so appropriate&n; * locking concerns must be made.  Today we use the sock lock to protect&n; * this function.&n; */
DECL|function|sctp_outq_flush
r_int
id|sctp_outq_flush
c_func
(paren
r_struct
id|sctp_outq
op_star
id|q
comma
r_int
id|rtx_timeout
)paren
(brace
r_struct
id|sctp_packet
op_star
id|packet
suffix:semicolon
r_struct
id|sctp_packet
id|singleton
suffix:semicolon
r_struct
id|sctp_association
op_star
id|asoc
op_assign
id|q-&gt;asoc
suffix:semicolon
id|__u16
id|sport
op_assign
id|asoc-&gt;base.bind_addr.port
suffix:semicolon
id|__u16
id|dport
op_assign
id|asoc-&gt;peer.port
suffix:semicolon
id|__u32
id|vtag
op_assign
id|asoc-&gt;peer.i.init_tag
suffix:semicolon
r_struct
id|sk_buff_head
op_star
id|queue
suffix:semicolon
r_struct
id|sctp_transport
op_star
id|transport
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|sctp_transport
op_star
id|new_transport
suffix:semicolon
r_struct
id|sctp_chunk
op_star
id|chunk
suffix:semicolon
id|sctp_xmit_t
id|status
suffix:semicolon
r_int
id|error
op_assign
l_int|0
suffix:semicolon
r_int
id|start_timer
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* These transports have chunks to send. */
r_struct
id|list_head
id|transport_list
suffix:semicolon
r_struct
id|list_head
op_star
id|ltransport
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|transport_list
)paren
suffix:semicolon
id|packet
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * 6.10 Bundling&n;&t; *   ...&n;&t; *   When bundling control chunks with DATA chunks, an&n;&t; *   endpoint MUST place control chunks first in the outbound&n;&t; *   SCTP packet.  The transmitter MUST transmit DATA chunks&n;&t; *   within a SCTP packet in increasing order of TSN.&n;&t; *   ...&n;&t; */
id|queue
op_assign
op_amp
id|q-&gt;control
suffix:semicolon
r_while
c_loop
(paren
(paren
id|chunk
op_assign
(paren
r_struct
id|sctp_chunk
op_star
)paren
id|skb_dequeue
c_func
(paren
id|queue
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* Pick the right transport to use. */
id|new_transport
op_assign
id|chunk-&gt;transport
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|new_transport
)paren
(brace
id|new_transport
op_assign
id|asoc-&gt;peer.active_path
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|new_transport-&gt;active
)paren
(brace
multiline_comment|/* If the chunk is Heartbeat or Heartbeat Ack, &n;&t;&t;&t; * send it to chunk-&gt;transport, even if it&squot;s &n;&t;&t;&t; * inactive.&n;&t;&t;&t; *&n;&t;&t;&t; * 3.3.6 Heartbeat Acknowledgement:&n;&t;&t;&t; * ...  &n;&t;&t;&t; * A HEARTBEAT ACK is always sent to the source IP&n;&t;&t;&t; * address of the IP datagram containing the&n;&t;&t;&t; * HEARTBEAT chunk to which this ack is responding.&n;&t;&t;&t; * ...  &n;&t;&t;&t; */
r_if
c_cond
(paren
id|chunk-&gt;chunk_hdr-&gt;type
op_ne
id|SCTP_CID_HEARTBEAT
op_logical_and
id|chunk-&gt;chunk_hdr-&gt;type
op_ne
id|SCTP_CID_HEARTBEAT_ACK
)paren
id|new_transport
op_assign
id|asoc-&gt;peer.active_path
suffix:semicolon
)brace
multiline_comment|/* Are we switching transports?&n;&t;&t; * Take care of transport locks.&n;&t;&t; */
r_if
c_cond
(paren
id|new_transport
op_ne
id|transport
)paren
(brace
id|transport
op_assign
id|new_transport
suffix:semicolon
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|transport-&gt;send_ready
)paren
)paren
(brace
id|list_add_tail
c_func
(paren
op_amp
id|transport-&gt;send_ready
comma
op_amp
id|transport_list
)paren
suffix:semicolon
)brace
id|packet
op_assign
op_amp
id|transport-&gt;packet
suffix:semicolon
id|sctp_packet_config
c_func
(paren
id|packet
comma
id|vtag
comma
id|asoc-&gt;peer.ecn_capable
)paren
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|chunk-&gt;chunk_hdr-&gt;type
)paren
(brace
multiline_comment|/*&n;&t;&t; * 6.10 Bundling&n;&t;&t; *   ...&n;&t;&t; *   An endpoint MUST NOT bundle INIT, INIT ACK or SHUTDOWN&n;&t;&t; *   COMPLETE with any other chunks.  [Send them immediately.]&n;&t;&t; */
r_case
id|SCTP_CID_INIT
suffix:colon
r_case
id|SCTP_CID_INIT_ACK
suffix:colon
r_case
id|SCTP_CID_SHUTDOWN_COMPLETE
suffix:colon
id|sctp_packet_init
c_func
(paren
op_amp
id|singleton
comma
id|transport
comma
id|sport
comma
id|dport
)paren
suffix:semicolon
id|sctp_packet_config
c_func
(paren
op_amp
id|singleton
comma
id|vtag
comma
l_int|0
)paren
suffix:semicolon
id|sctp_packet_append_chunk
c_func
(paren
op_amp
id|singleton
comma
id|chunk
)paren
suffix:semicolon
id|error
op_assign
id|sctp_packet_transmit
c_func
(paren
op_amp
id|singleton
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
OL
l_int|0
)paren
r_return
id|error
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_CID_ABORT
suffix:colon
r_case
id|SCTP_CID_SACK
suffix:colon
r_case
id|SCTP_CID_HEARTBEAT
suffix:colon
r_case
id|SCTP_CID_HEARTBEAT_ACK
suffix:colon
r_case
id|SCTP_CID_SHUTDOWN
suffix:colon
r_case
id|SCTP_CID_SHUTDOWN_ACK
suffix:colon
r_case
id|SCTP_CID_ERROR
suffix:colon
r_case
id|SCTP_CID_COOKIE_ECHO
suffix:colon
r_case
id|SCTP_CID_COOKIE_ACK
suffix:colon
r_case
id|SCTP_CID_ECN_ECNE
suffix:colon
r_case
id|SCTP_CID_ECN_CWR
suffix:colon
r_case
id|SCTP_CID_ASCONF
suffix:colon
r_case
id|SCTP_CID_ASCONF_ACK
suffix:colon
r_case
id|SCTP_CID_FWD_TSN
suffix:colon
id|sctp_packet_transmit_chunk
c_func
(paren
id|packet
comma
id|chunk
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* We built a chunk with an illegal type! */
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
suffix:semicolon
)brace
multiline_comment|/* Is it OK to send data chunks?  */
r_switch
c_cond
(paren
id|asoc-&gt;state
)paren
(brace
r_case
id|SCTP_STATE_COOKIE_ECHOED
suffix:colon
multiline_comment|/* Only allow bundling when this packet has a COOKIE-ECHO&n;&t;&t; * chunk.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|packet
op_logical_or
op_logical_neg
id|packet-&gt;has_cookie_echo
)paren
r_break
suffix:semicolon
multiline_comment|/* fallthru */
r_case
id|SCTP_STATE_ESTABLISHED
suffix:colon
r_case
id|SCTP_STATE_SHUTDOWN_PENDING
suffix:colon
r_case
id|SCTP_STATE_SHUTDOWN_RECEIVED
suffix:colon
multiline_comment|/*&n;&t;&t; * RFC 2960 6.1  Transmission of DATA Chunks&n;&t;&t; *&n;&t;&t; * C) When the time comes for the sender to transmit,&n;&t;&t; * before sending new DATA chunks, the sender MUST&n;&t;&t; * first transmit any outstanding DATA chunks which&n;&t;&t; * are marked for retransmission (limited by the&n;&t;&t; * current cwnd).&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|q-&gt;retransmit
)paren
)paren
(brace
r_if
c_cond
(paren
id|transport
op_eq
id|asoc-&gt;peer.retran_path
)paren
r_goto
id|retran
suffix:semicolon
multiline_comment|/* Switch transports &amp; prepare the packet.  */
id|transport
op_assign
id|asoc-&gt;peer.retran_path
suffix:semicolon
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|transport-&gt;send_ready
)paren
)paren
(brace
id|list_add_tail
c_func
(paren
op_amp
id|transport-&gt;send_ready
comma
op_amp
id|transport_list
)paren
suffix:semicolon
)brace
id|packet
op_assign
op_amp
id|transport-&gt;packet
suffix:semicolon
id|sctp_packet_config
c_func
(paren
id|packet
comma
id|vtag
comma
id|asoc-&gt;peer.ecn_capable
)paren
suffix:semicolon
id|retran
suffix:colon
id|error
op_assign
id|sctp_outq_flush_rtx
c_func
(paren
id|q
comma
id|packet
comma
id|rtx_timeout
comma
op_amp
id|start_timer
)paren
suffix:semicolon
r_if
c_cond
(paren
id|start_timer
)paren
id|sctp_transport_reset_timers
c_func
(paren
id|transport
)paren
suffix:semicolon
multiline_comment|/* This can happen on COOKIE-ECHO resend.  Only&n;&t;&t;&t; * one chunk can get bundled with a COOKIE-ECHO.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|packet-&gt;has_cookie_echo
)paren
r_goto
id|sctp_flush_out
suffix:semicolon
multiline_comment|/* Don&squot;t send new data if there is still data&n;&t;&t;&t; * waiting to retransmit.&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|q-&gt;retransmit
)paren
)paren
r_goto
id|sctp_flush_out
suffix:semicolon
)brace
multiline_comment|/* Finally, transmit new packets.  */
id|start_timer
op_assign
l_int|0
suffix:semicolon
id|queue
op_assign
op_amp
id|q-&gt;out
suffix:semicolon
r_while
c_loop
(paren
(paren
id|chunk
op_assign
id|sctp_outq_dequeue_data
c_func
(paren
id|q
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* RFC 2960 6.5 Every DATA chunk MUST carry a valid&n;&t;&t;&t; * stream identifier.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|chunk-&gt;sinfo.sinfo_stream
op_ge
id|asoc-&gt;c.sinit_num_ostreams
)paren
(brace
multiline_comment|/* Mark as failed send. */
id|sctp_chunk_fail
c_func
(paren
id|chunk
comma
id|SCTP_ERROR_INV_STRM
)paren
suffix:semicolon
id|sctp_chunk_free
c_func
(paren
id|chunk
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* Has this chunk expired? */
r_if
c_cond
(paren
id|sctp_chunk_abandoned
c_func
(paren
id|chunk
)paren
)paren
(brace
id|sctp_chunk_fail
c_func
(paren
id|chunk
comma
l_int|0
)paren
suffix:semicolon
id|sctp_chunk_free
c_func
(paren
id|chunk
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* If there is a specified transport, use it.&n;&t;&t;&t; * Otherwise, we want to use the active path.&n;&t;&t;&t; */
id|new_transport
op_assign
id|chunk-&gt;transport
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|new_transport
op_logical_or
op_logical_neg
id|new_transport-&gt;active
)paren
id|new_transport
op_assign
id|asoc-&gt;peer.active_path
suffix:semicolon
multiline_comment|/* Change packets if necessary.  */
r_if
c_cond
(paren
id|new_transport
op_ne
id|transport
)paren
(brace
id|transport
op_assign
id|new_transport
suffix:semicolon
multiline_comment|/* Schedule to have this transport&squot;s&n;&t;&t;&t;&t; * packet flushed.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|transport-&gt;send_ready
)paren
)paren
(brace
id|list_add_tail
c_func
(paren
op_amp
id|transport-&gt;send_ready
comma
op_amp
id|transport_list
)paren
suffix:semicolon
)brace
id|packet
op_assign
op_amp
id|transport-&gt;packet
suffix:semicolon
id|sctp_packet_config
c_func
(paren
id|packet
comma
id|vtag
comma
id|asoc-&gt;peer.ecn_capable
)paren
suffix:semicolon
)brace
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;sctp_outq_flush(%p, %p[%s]), &quot;
comma
id|q
comma
id|chunk
comma
id|chunk
op_logical_and
id|chunk-&gt;chunk_hdr
ques
c_cond
id|sctp_cname
c_func
(paren
id|SCTP_ST_CHUNK
c_func
(paren
id|chunk-&gt;chunk_hdr-&gt;type
)paren
)paren
suffix:colon
l_string|&quot;Illegal Chunk&quot;
)paren
suffix:semicolon
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;TX TSN 0x%x skb-&gt;head &quot;
l_string|&quot;%p skb-&gt;users %d.&bslash;n&quot;
comma
id|ntohl
c_func
(paren
id|chunk-&gt;subh.data_hdr-&gt;tsn
)paren
comma
id|chunk-&gt;skb
ques
c_cond
id|chunk-&gt;skb-&gt;head
suffix:colon
l_int|NULL
comma
id|chunk-&gt;skb
ques
c_cond
id|atomic_read
c_func
(paren
op_amp
id|chunk-&gt;skb-&gt;users
)paren
suffix:colon
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Add the chunk to the packet.  */
id|status
op_assign
id|sctp_packet_transmit_chunk
c_func
(paren
id|packet
comma
id|chunk
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|status
)paren
(brace
r_case
id|SCTP_XMIT_PMTU_FULL
suffix:colon
r_case
id|SCTP_XMIT_RWND_FULL
suffix:colon
r_case
id|SCTP_XMIT_NAGLE_DELAY
suffix:colon
multiline_comment|/* We could not append this chunk, so put&n;&t;&t;&t;&t; * the chunk back on the output queue.&n;&t;&t;&t;&t; */
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;sctp_outq_flush: could &quot;
l_string|&quot;not transmit TSN: 0x%x, status: %d&bslash;n&quot;
comma
id|ntohl
c_func
(paren
id|chunk-&gt;subh.data_hdr-&gt;tsn
)paren
comma
id|status
)paren
suffix:semicolon
id|sctp_outq_head_data
c_func
(paren
id|q
comma
id|chunk
)paren
suffix:semicolon
r_goto
id|sctp_flush_out
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_XMIT_OK
suffix:colon
r_break
suffix:semicolon
r_default
suffix:colon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* BUG: We assume that the sctp_packet_transmit() &n;&t;&t;&t; * call below will succeed all the time and add the&n;&t;&t;&t; * chunk to the transmitted list and restart the&n;&t;&t;&t; * timers.&n;&t;&t;&t; * It is possible that the call can fail under OOM&n;&t;&t;&t; * conditions.&n;&t;&t;&t; *&n;&t;&t;&t; * Is this really a problem?  Won&squot;t this behave&n;&t;&t;&t; * like a lost TSN?&n;&t;&t;&t; */
id|list_add_tail
c_func
(paren
op_amp
id|chunk-&gt;transmitted_list
comma
op_amp
id|transport-&gt;transmitted
)paren
suffix:semicolon
id|sctp_transport_reset_timers
c_func
(paren
id|transport
)paren
suffix:semicolon
id|q-&gt;empty
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Only let one DATA chunk get bundled with a&n;&t;&t;&t; * COOKIE-ECHO chunk.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|packet-&gt;has_cookie_echo
)paren
r_goto
id|sctp_flush_out
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* Do nothing.  */
r_break
suffix:semicolon
)brace
id|sctp_flush_out
suffix:colon
multiline_comment|/* Before returning, examine all the transports touched in&n;&t; * this call.  Right now, we bluntly force clear all the&n;&t; * transports.  Things might change after we implement Nagle.&n;&t; * But such an examination is still required.&n;&t; *&n;&t; * --xguo&n;&t; */
r_while
c_loop
(paren
(paren
id|ltransport
op_assign
id|sctp_list_dequeue
c_func
(paren
op_amp
id|transport_list
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
r_struct
id|sctp_transport
op_star
id|t
op_assign
id|list_entry
c_func
(paren
id|ltransport
comma
r_struct
id|sctp_transport
comma
id|send_ready
)paren
suffix:semicolon
id|packet
op_assign
op_amp
id|t-&gt;packet
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sctp_packet_empty
c_func
(paren
id|packet
)paren
)paren
id|error
op_assign
id|sctp_packet_transmit
c_func
(paren
id|packet
)paren
suffix:semicolon
)brace
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/* Update unack_data based on the incoming SACK chunk */
DECL|function|sctp_sack_update_unack_data
r_static
r_void
id|sctp_sack_update_unack_data
c_func
(paren
r_struct
id|sctp_association
op_star
id|assoc
comma
r_struct
id|sctp_sackhdr
op_star
id|sack
)paren
(brace
id|sctp_sack_variable_t
op_star
id|frags
suffix:semicolon
id|__u16
id|unack_data
suffix:semicolon
r_int
id|i
suffix:semicolon
id|unack_data
op_assign
id|assoc-&gt;next_tsn
op_minus
id|assoc-&gt;ctsn_ack_point
op_minus
l_int|1
suffix:semicolon
id|frags
op_assign
id|sack-&gt;variable
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ntohs
c_func
(paren
id|sack-&gt;num_gap_ack_blocks
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|unack_data
op_sub_assign
(paren
(paren
id|ntohs
c_func
(paren
id|frags
(braket
id|i
)braket
dot
id|gab.end
)paren
op_minus
id|ntohs
c_func
(paren
id|frags
(braket
id|i
)braket
dot
id|gab.start
)paren
op_plus
l_int|1
)paren
)paren
suffix:semicolon
)brace
id|assoc-&gt;unack_data
op_assign
id|unack_data
suffix:semicolon
)brace
multiline_comment|/* Return the highest new tsn that is acknowledged by the given SACK chunk. */
DECL|function|sctp_highest_new_tsn
r_static
id|__u32
id|sctp_highest_new_tsn
c_func
(paren
r_struct
id|sctp_sackhdr
op_star
id|sack
comma
r_struct
id|sctp_association
op_star
id|asoc
)paren
(brace
r_struct
id|list_head
op_star
id|ltransport
comma
op_star
id|lchunk
suffix:semicolon
r_struct
id|sctp_transport
op_star
id|transport
suffix:semicolon
r_struct
id|sctp_chunk
op_star
id|chunk
suffix:semicolon
id|__u32
id|highest_new_tsn
comma
id|tsn
suffix:semicolon
r_struct
id|list_head
op_star
id|transport_list
op_assign
op_amp
id|asoc-&gt;peer.transport_addr_list
suffix:semicolon
id|highest_new_tsn
op_assign
id|ntohl
c_func
(paren
id|sack-&gt;cum_tsn_ack
)paren
suffix:semicolon
id|list_for_each
c_func
(paren
id|ltransport
comma
id|transport_list
)paren
(brace
id|transport
op_assign
id|list_entry
c_func
(paren
id|ltransport
comma
r_struct
id|sctp_transport
comma
id|transports
)paren
suffix:semicolon
id|list_for_each
c_func
(paren
id|lchunk
comma
op_amp
id|transport-&gt;transmitted
)paren
(brace
id|chunk
op_assign
id|list_entry
c_func
(paren
id|lchunk
comma
r_struct
id|sctp_chunk
comma
id|transmitted_list
)paren
suffix:semicolon
id|tsn
op_assign
id|ntohl
c_func
(paren
id|chunk-&gt;subh.data_hdr-&gt;tsn
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|chunk-&gt;tsn_gap_acked
op_logical_and
id|TSN_lt
c_func
(paren
id|highest_new_tsn
comma
id|tsn
)paren
op_logical_and
id|sctp_acked
c_func
(paren
id|sack
comma
id|tsn
)paren
)paren
id|highest_new_tsn
op_assign
id|tsn
suffix:semicolon
)brace
)brace
r_return
id|highest_new_tsn
suffix:semicolon
)brace
multiline_comment|/* This is where we REALLY process a SACK.&n; *&n; * Process the SACK against the outqueue.  Mostly, this just frees&n; * things off the transmitted queue.&n; */
DECL|function|sctp_outq_sack
r_int
id|sctp_outq_sack
c_func
(paren
r_struct
id|sctp_outq
op_star
id|q
comma
r_struct
id|sctp_sackhdr
op_star
id|sack
)paren
(brace
r_struct
id|sctp_association
op_star
id|asoc
op_assign
id|q-&gt;asoc
suffix:semicolon
r_struct
id|sctp_transport
op_star
id|transport
suffix:semicolon
r_struct
id|sctp_chunk
op_star
id|tchunk
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|list_head
op_star
id|lchunk
comma
op_star
id|transport_list
comma
op_star
id|pos
comma
op_star
id|temp
suffix:semicolon
id|sctp_sack_variable_t
op_star
id|frags
op_assign
id|sack-&gt;variable
suffix:semicolon
id|__u32
id|sack_ctsn
comma
id|ctsn
comma
id|tsn
suffix:semicolon
id|__u32
id|highest_tsn
comma
id|highest_new_tsn
suffix:semicolon
id|__u32
id|sack_a_rwnd
suffix:semicolon
r_int
id|outstanding
suffix:semicolon
r_struct
id|sctp_transport
op_star
id|primary
op_assign
id|asoc-&gt;peer.primary_path
suffix:semicolon
r_int
id|count_of_newacks
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Grab the association&squot;s destination address list. */
id|transport_list
op_assign
op_amp
id|asoc-&gt;peer.transport_addr_list
suffix:semicolon
id|sack_ctsn
op_assign
id|ntohl
c_func
(paren
id|sack-&gt;cum_tsn_ack
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * SFR-CACC algorithm:&n;&t; * On receipt of a SACK the sender SHOULD execute the&n;&t; * following statements.&n;&t; *&n;&t; * 1) If the cumulative ack in the SACK passes next tsn_at_change&n;&t; * on the current primary, the CHANGEOVER_ACTIVE flag SHOULD be&n;&t; * cleared. The CYCLING_CHANGEOVER flag SHOULD also be cleared for&n;&t; * all destinations.&n;&t; */
r_if
c_cond
(paren
id|TSN_lte
c_func
(paren
id|primary-&gt;cacc.next_tsn_at_change
comma
id|sack_ctsn
)paren
)paren
(brace
id|primary-&gt;cacc.changeover_active
op_assign
l_int|0
suffix:semicolon
id|list_for_each
c_func
(paren
id|pos
comma
id|transport_list
)paren
(brace
id|transport
op_assign
id|list_entry
c_func
(paren
id|pos
comma
r_struct
id|sctp_transport
comma
id|transports
)paren
suffix:semicolon
id|transport-&gt;cacc.cycling_changeover
op_assign
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * SFR-CACC algorithm:&n;&t; * 2) If the SACK contains gap acks and the flag CHANGEOVER_ACTIVE&n;&t; * is set the receiver of the SACK MUST take the following actions:&n;&t; *&n;&t; * A) Initialize the cacc_saw_newack to 0 for all destination&n;&t; * addresses.&n;&t; */
r_if
c_cond
(paren
id|sack-&gt;num_gap_ack_blocks
OG
l_int|0
op_logical_and
id|primary-&gt;cacc.changeover_active
)paren
(brace
id|list_for_each
c_func
(paren
id|pos
comma
id|transport_list
)paren
(brace
id|transport
op_assign
id|list_entry
c_func
(paren
id|pos
comma
r_struct
id|sctp_transport
comma
id|transports
)paren
suffix:semicolon
id|transport-&gt;cacc.cacc_saw_newack
op_assign
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/* Get the highest TSN in the sack. */
id|highest_tsn
op_assign
id|sack_ctsn
suffix:semicolon
r_if
c_cond
(paren
id|sack-&gt;num_gap_ack_blocks
)paren
id|highest_tsn
op_add_assign
id|ntohs
c_func
(paren
id|frags
(braket
id|ntohs
c_func
(paren
id|sack-&gt;num_gap_ack_blocks
)paren
op_minus
l_int|1
)braket
dot
id|gab.end
)paren
suffix:semicolon
r_if
c_cond
(paren
id|TSN_lt
c_func
(paren
id|asoc-&gt;highest_sacked
comma
id|highest_tsn
)paren
)paren
(brace
id|highest_new_tsn
op_assign
id|highest_tsn
suffix:semicolon
id|asoc-&gt;highest_sacked
op_assign
id|highest_tsn
suffix:semicolon
)brace
r_else
(brace
id|highest_new_tsn
op_assign
id|sctp_highest_new_tsn
c_func
(paren
id|sack
comma
id|asoc
)paren
suffix:semicolon
)brace
multiline_comment|/* Run through the retransmit queue.  Credit bytes received&n;&t; * and free those chunks that we can.&n;&t; */
id|sctp_check_transmitted
c_func
(paren
id|q
comma
op_amp
id|q-&gt;retransmit
comma
l_int|NULL
comma
id|sack
comma
id|highest_new_tsn
)paren
suffix:semicolon
id|sctp_mark_missing
c_func
(paren
id|q
comma
op_amp
id|q-&gt;retransmit
comma
l_int|NULL
comma
id|highest_new_tsn
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Run through the transmitted queue.&n;&t; * Credit bytes received and free those chunks which we can.&n;&t; *&n;&t; * This is a MASSIVE candidate for optimization.&n;&t; */
id|list_for_each
c_func
(paren
id|pos
comma
id|transport_list
)paren
(brace
id|transport
op_assign
id|list_entry
c_func
(paren
id|pos
comma
r_struct
id|sctp_transport
comma
id|transports
)paren
suffix:semicolon
id|sctp_check_transmitted
c_func
(paren
id|q
comma
op_amp
id|transport-&gt;transmitted
comma
id|transport
comma
id|sack
comma
id|highest_new_tsn
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * SFR-CACC algorithm:&n;&t;&t; * C) Let count_of_newacks be the number of&n;&t;&t; * destinations for which cacc_saw_newack is set.&n;&t;&t; */
r_if
c_cond
(paren
id|transport-&gt;cacc.cacc_saw_newack
)paren
id|count_of_newacks
op_increment
suffix:semicolon
)brace
id|list_for_each
c_func
(paren
id|pos
comma
id|transport_list
)paren
(brace
id|transport
op_assign
id|list_entry
c_func
(paren
id|pos
comma
r_struct
id|sctp_transport
comma
id|transports
)paren
suffix:semicolon
id|sctp_mark_missing
c_func
(paren
id|q
comma
op_amp
id|transport-&gt;transmitted
comma
id|transport
comma
id|highest_new_tsn
comma
id|count_of_newacks
)paren
suffix:semicolon
)brace
multiline_comment|/* Move the Cumulative TSN Ack Point if appropriate.  */
r_if
c_cond
(paren
id|TSN_lt
c_func
(paren
id|asoc-&gt;ctsn_ack_point
comma
id|sack_ctsn
)paren
)paren
id|asoc-&gt;ctsn_ack_point
op_assign
id|sack_ctsn
suffix:semicolon
multiline_comment|/* Update unack_data field in the assoc. */
id|sctp_sack_update_unack_data
c_func
(paren
id|asoc
comma
id|sack
)paren
suffix:semicolon
id|ctsn
op_assign
id|asoc-&gt;ctsn_ack_point
suffix:semicolon
multiline_comment|/* Throw away stuff rotting on the sack queue.  */
id|list_for_each_safe
c_func
(paren
id|lchunk
comma
id|temp
comma
op_amp
id|q-&gt;sacked
)paren
(brace
id|tchunk
op_assign
id|list_entry
c_func
(paren
id|lchunk
comma
r_struct
id|sctp_chunk
comma
id|transmitted_list
)paren
suffix:semicolon
id|tsn
op_assign
id|ntohl
c_func
(paren
id|tchunk-&gt;subh.data_hdr-&gt;tsn
)paren
suffix:semicolon
r_if
c_cond
(paren
id|TSN_lte
c_func
(paren
id|tsn
comma
id|ctsn
)paren
)paren
id|sctp_chunk_free
c_func
(paren
id|tchunk
)paren
suffix:semicolon
)brace
multiline_comment|/* ii) Set rwnd equal to the newly received a_rwnd minus the&n;&t; *     number of bytes still outstanding after processing the&n;&t; *     Cumulative TSN Ack and the Gap Ack Blocks.&n;&t; */
id|sack_a_rwnd
op_assign
id|ntohl
c_func
(paren
id|sack-&gt;a_rwnd
)paren
suffix:semicolon
id|outstanding
op_assign
id|q-&gt;outstanding_bytes
suffix:semicolon
r_if
c_cond
(paren
id|outstanding
OL
id|sack_a_rwnd
)paren
id|sack_a_rwnd
op_sub_assign
id|outstanding
suffix:semicolon
r_else
id|sack_a_rwnd
op_assign
l_int|0
suffix:semicolon
id|asoc-&gt;peer.rwnd
op_assign
id|sack_a_rwnd
suffix:semicolon
id|sctp_generate_fwdtsn
c_func
(paren
id|q
comma
id|sack_ctsn
)paren
suffix:semicolon
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;%s: sack Cumulative TSN Ack is 0x%x.&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|sack_ctsn
)paren
suffix:semicolon
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;%s: Cumulative TSN Ack of association, &quot;
l_string|&quot;%p is 0x%x. Adv peer ack point: 0x%x&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|asoc
comma
id|ctsn
comma
id|asoc-&gt;adv_peer_ack_point
)paren
suffix:semicolon
multiline_comment|/* See if all chunks are acked.&n;&t; * Make sure the empty queue handler will get run later.&n;&t; */
id|q-&gt;empty
op_assign
id|skb_queue_empty
c_func
(paren
op_amp
id|q-&gt;out
)paren
op_logical_and
id|skb_queue_empty
c_func
(paren
op_amp
id|q-&gt;control
)paren
op_logical_and
id|list_empty
c_func
(paren
op_amp
id|q-&gt;retransmit
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|q-&gt;empty
)paren
r_goto
id|finish
suffix:semicolon
id|list_for_each
c_func
(paren
id|pos
comma
id|transport_list
)paren
(brace
id|transport
op_assign
id|list_entry
c_func
(paren
id|pos
comma
r_struct
id|sctp_transport
comma
id|transports
)paren
suffix:semicolon
id|q-&gt;empty
op_assign
id|q-&gt;empty
op_logical_and
id|list_empty
c_func
(paren
op_amp
id|transport-&gt;transmitted
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|q-&gt;empty
)paren
r_goto
id|finish
suffix:semicolon
)brace
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;sack queue is empty.&bslash;n&quot;
)paren
suffix:semicolon
id|finish
suffix:colon
r_return
id|q-&gt;empty
suffix:semicolon
)brace
multiline_comment|/* Is the outqueue empty?  */
DECL|function|sctp_outq_is_empty
r_int
id|sctp_outq_is_empty
c_func
(paren
r_const
r_struct
id|sctp_outq
op_star
id|q
)paren
(brace
r_return
id|q-&gt;empty
suffix:semicolon
)brace
multiline_comment|/********************************************************************&n; * 2nd Level Abstractions&n; ********************************************************************/
multiline_comment|/* Go through a transport&squot;s transmitted list or the association&squot;s retransmit&n; * list and move chunks that are acked by the Cumulative TSN Ack to q-&gt;sacked.&n; * The retransmit list will not have an associated transport.&n; *&n; * I added coherent debug information output.&t;--xguo&n; *&n; * Instead of printing &squot;sacked&squot; or &squot;kept&squot; for each TSN on the&n; * transmitted_queue, we print a range: SACKED: TSN1-TSN2, TSN3, TSN4-TSN5.&n; * KEPT TSN6-TSN7, etc.&n; */
DECL|function|sctp_check_transmitted
r_static
r_void
id|sctp_check_transmitted
c_func
(paren
r_struct
id|sctp_outq
op_star
id|q
comma
r_struct
id|list_head
op_star
id|transmitted_queue
comma
r_struct
id|sctp_transport
op_star
id|transport
comma
r_struct
id|sctp_sackhdr
op_star
id|sack
comma
id|__u32
id|highest_new_tsn_in_sack
)paren
(brace
r_struct
id|list_head
op_star
id|lchunk
suffix:semicolon
r_struct
id|sctp_chunk
op_star
id|tchunk
suffix:semicolon
r_struct
id|list_head
id|tlist
suffix:semicolon
id|__u32
id|tsn
suffix:semicolon
id|__u32
id|sack_ctsn
suffix:semicolon
id|__u32
id|rtt
suffix:semicolon
id|__u8
id|restart_timer
op_assign
l_int|0
suffix:semicolon
r_int
id|bytes_acked
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* These state variables are for coherent debug output. --xguo */
macro_line|#if SCTP_DEBUG
id|__u32
id|dbg_ack_tsn
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* An ACKed TSN range starts here... */
id|__u32
id|dbg_last_ack_tsn
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* ...and finishes here.&t;     */
id|__u32
id|dbg_kept_tsn
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* An un-ACKed range starts here...  */
id|__u32
id|dbg_last_kept_tsn
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* ...and finishes here.&t;     */
multiline_comment|/* 0 : The last TSN was ACKed.&n;&t; * 1 : The last TSN was NOT ACKed (i.e. KEPT).&n;&t; * -1: We need to initialize.&n;&t; */
r_int
id|dbg_prt_state
op_assign
op_minus
l_int|1
suffix:semicolon
macro_line|#endif /* SCTP_DEBUG */
id|sack_ctsn
op_assign
id|ntohl
c_func
(paren
id|sack-&gt;cum_tsn_ack
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|tlist
)paren
suffix:semicolon
multiline_comment|/* The while loop will skip empty transmitted queues. */
r_while
c_loop
(paren
l_int|NULL
op_ne
(paren
id|lchunk
op_assign
id|sctp_list_dequeue
c_func
(paren
id|transmitted_queue
)paren
)paren
)paren
(brace
id|tchunk
op_assign
id|list_entry
c_func
(paren
id|lchunk
comma
r_struct
id|sctp_chunk
comma
id|transmitted_list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sctp_chunk_abandoned
c_func
(paren
id|tchunk
)paren
)paren
(brace
multiline_comment|/* Move the chunk to abandoned list. */
id|sctp_insert_list
c_func
(paren
op_amp
id|q-&gt;abandoned
comma
id|lchunk
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|tsn
op_assign
id|ntohl
c_func
(paren
id|tchunk-&gt;subh.data_hdr-&gt;tsn
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sctp_acked
c_func
(paren
id|sack
comma
id|tsn
)paren
)paren
(brace
multiline_comment|/* If this queue is the retransmit queue, the&n;&t;&t;&t; * retransmit timer has already reclaimed&n;&t;&t;&t; * the outstanding bytes for this chunk, so only&n;&t;&t;&t; * count bytes associated with a transport.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|transport
)paren
(brace
multiline_comment|/* If this chunk is being used for RTT&n;&t;&t;&t;&t; * measurement, calculate the RTT and update&n;&t;&t;&t;&t; * the RTO using this value.&n;&t;&t;&t;&t; *&n;&t;&t;&t;&t; * 6.3.1 C5) Karn&squot;s algorithm: RTT measurements&n;&t;&t;&t;&t; * MUST NOT be made using packets that were&n;&t;&t;&t;&t; * retransmitted (and thus for which it is&n;&t;&t;&t;&t; * ambiguous whether the reply was for the&n;&t;&t;&t;&t; * first instance of the packet or a later&n;&t;&t;&t;&t; * instance).&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|tchunk-&gt;tsn_gap_acked
op_logical_and
op_logical_neg
id|tchunk-&gt;resent
op_logical_and
id|tchunk-&gt;rtt_in_progress
)paren
(brace
id|rtt
op_assign
id|jiffies
op_minus
id|tchunk-&gt;sent_at
suffix:semicolon
id|sctp_transport_update_rto
c_func
(paren
id|transport
comma
id|rtt
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|TSN_lte
c_func
(paren
id|tsn
comma
id|sack_ctsn
)paren
)paren
(brace
multiline_comment|/* RFC 2960  6.3.2 Retransmission Timer Rules&n;&t;&t;&t;&t; *&n;&t;&t;&t;&t; * R3) Whenever a SACK is received&n;&t;&t;&t;&t; * that acknowledges the DATA chunk&n;&t;&t;&t;&t; * with the earliest outstanding TSN&n;&t;&t;&t;&t; * for that address, restart T3-rtx&n;&t;&t;&t;&t; * timer for that address with its&n;&t;&t;&t;&t; * current RTO.&n;&t;&t;&t;&t; */
id|restart_timer
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tchunk-&gt;tsn_gap_acked
)paren
(brace
id|tchunk-&gt;tsn_gap_acked
op_assign
l_int|1
suffix:semicolon
id|bytes_acked
op_add_assign
id|sctp_data_size
c_func
(paren
id|tchunk
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t;&t; * SFR-CACC algorithm:&n;&t;&t;&t;&t;&t; * 2) If the SACK contains gap acks&n;&t;&t;&t;&t;&t; * and the flag CHANGEOVER_ACTIVE is&n;&t;&t;&t;&t;&t; * set the receiver of the SACK MUST&n;&t;&t;&t;&t;&t; * take the following action:&n;&t;&t;&t;&t;&t; *&n;&t;&t;&t;&t;&t; * B) For each TSN t being acked that&n;&t;&t;&t;&t;&t; * has not been acked in any SACK so&n;&t;&t;&t;&t;&t; * far, set cacc_saw_newack to 1 for&n;&t;&t;&t;&t;&t; * the destination that the TSN was&n;&t;&t;&t;&t;&t; * sent to.&n;&t;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|transport
op_logical_and
id|sack-&gt;num_gap_ack_blocks
op_logical_and
id|q-&gt;asoc-&gt;peer.primary_path-&gt;cacc
dot
id|changeover_active
)paren
id|transport-&gt;cacc.cacc_saw_newack
op_assign
l_int|1
suffix:semicolon
)brace
id|list_add_tail
c_func
(paren
op_amp
id|tchunk-&gt;transmitted_list
comma
op_amp
id|q-&gt;sacked
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* RFC2960 7.2.4, sctpimpguide-05 2.8.2&n;&t;&t;&t;&t; * M2) Each time a SACK arrives reporting&n;&t;&t;&t;&t; * &squot;Stray DATA chunk(s)&squot; record the highest TSN&n;&t;&t;&t;&t; * reported as newly acknowledged, call this&n;&t;&t;&t;&t; * value &squot;HighestTSNinSack&squot;. A newly&n;&t;&t;&t;&t; * acknowledged DATA chunk is one not&n;&t;&t;&t;&t; * previously acknowledged in a SACK.&n;&t;&t;&t;&t; *&n;&t;&t;&t;&t; * When the SCTP sender of data receives a SACK&n;&t;&t;&t;&t; * chunk that acknowledges, for the first time,&n;&t;&t;&t;&t; * the receipt of a DATA chunk, all the still&n;&t;&t;&t;&t; * unacknowledged DATA chunks whose TSN is&n;&t;&t;&t;&t; * older than that newly acknowledged DATA&n;&t;&t;&t;&t; * chunk, are qualified as &squot;Stray DATA chunks&squot;.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|tchunk-&gt;tsn_gap_acked
)paren
(brace
id|tchunk-&gt;tsn_gap_acked
op_assign
l_int|1
suffix:semicolon
id|bytes_acked
op_add_assign
id|sctp_data_size
c_func
(paren
id|tchunk
)paren
suffix:semicolon
)brace
id|list_add_tail
c_func
(paren
id|lchunk
comma
op_amp
id|tlist
)paren
suffix:semicolon
)brace
macro_line|#if SCTP_DEBUG
r_switch
c_cond
(paren
id|dbg_prt_state
)paren
(brace
r_case
l_int|0
suffix:colon
multiline_comment|/* last TSN was ACKed */
r_if
c_cond
(paren
id|dbg_last_ack_tsn
op_plus
l_int|1
op_eq
id|tsn
)paren
(brace
multiline_comment|/* This TSN belongs to the&n;&t;&t;&t;&t;&t; * current ACK range.&n;&t;&t;&t;&t;&t; */
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dbg_last_ack_tsn
op_ne
id|dbg_ack_tsn
)paren
(brace
multiline_comment|/* Display the end of the&n;&t;&t;&t;&t;&t; * current range.&n;&t;&t;&t;&t;&t; */
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;-%08x&quot;
comma
id|dbg_last_ack_tsn
)paren
suffix:semicolon
)brace
multiline_comment|/* Start a new range.  */
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;,%08x&quot;
comma
id|tsn
)paren
suffix:semicolon
id|dbg_ack_tsn
op_assign
id|tsn
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
multiline_comment|/* The last TSN was NOT ACKed. */
r_if
c_cond
(paren
id|dbg_last_kept_tsn
op_ne
id|dbg_kept_tsn
)paren
(brace
multiline_comment|/* Display the end of current range. */
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;-%08x&quot;
comma
id|dbg_last_kept_tsn
)paren
suffix:semicolon
)brace
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* FALL THROUGH... */
r_default
suffix:colon
multiline_comment|/* This is the first-ever TSN we examined.  */
multiline_comment|/* Start a new range of ACK-ed TSNs.  */
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;ACKed: %08x&quot;
comma
id|tsn
)paren
suffix:semicolon
id|dbg_prt_state
op_assign
l_int|0
suffix:semicolon
id|dbg_ack_tsn
op_assign
id|tsn
suffix:semicolon
)brace
suffix:semicolon
id|dbg_last_ack_tsn
op_assign
id|tsn
suffix:semicolon
macro_line|#endif /* SCTP_DEBUG */
)brace
r_else
(brace
r_if
c_cond
(paren
id|tchunk-&gt;tsn_gap_acked
)paren
(brace
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;%s: Receiver reneged on &quot;
l_string|&quot;data TSN: 0x%x&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|tsn
)paren
suffix:semicolon
id|tchunk-&gt;tsn_gap_acked
op_assign
l_int|0
suffix:semicolon
id|bytes_acked
op_sub_assign
id|sctp_data_size
c_func
(paren
id|tchunk
)paren
suffix:semicolon
multiline_comment|/* RFC 2960 6.3.2 Retransmission Timer Rules&n;&t;&t;&t;&t; *&n;&t;&t;&t;&t; * R4) Whenever a SACK is received missing a&n;&t;&t;&t;&t; * TSN that was previously acknowledged via a&n;&t;&t;&t;&t; * Gap Ack Block, start T3-rtx for the&n;&t;&t;&t;&t; * destination address to which the DATA&n;&t;&t;&t;&t; * chunk was originally&n;&t;&t;&t;&t; * transmitted if it is not already running.&n;&t;&t;&t;&t; */
id|restart_timer
op_assign
l_int|1
suffix:semicolon
)brace
id|list_add_tail
c_func
(paren
id|lchunk
comma
op_amp
id|tlist
)paren
suffix:semicolon
macro_line|#if SCTP_DEBUG
multiline_comment|/* See the above comments on ACK-ed TSNs. */
r_switch
c_cond
(paren
id|dbg_prt_state
)paren
(brace
r_case
l_int|1
suffix:colon
r_if
c_cond
(paren
id|dbg_last_kept_tsn
op_plus
l_int|1
op_eq
id|tsn
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|dbg_last_kept_tsn
op_ne
id|dbg_kept_tsn
)paren
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;-%08x&quot;
comma
id|dbg_last_kept_tsn
)paren
suffix:semicolon
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;,%08x&quot;
comma
id|tsn
)paren
suffix:semicolon
id|dbg_kept_tsn
op_assign
id|tsn
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0
suffix:colon
r_if
c_cond
(paren
id|dbg_last_ack_tsn
op_ne
id|dbg_ack_tsn
)paren
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;-%08x&quot;
comma
id|dbg_last_ack_tsn
)paren
suffix:semicolon
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* FALL THROUGH... */
r_default
suffix:colon
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;KEPT: %08x&quot;
comma
id|tsn
)paren
suffix:semicolon
id|dbg_prt_state
op_assign
l_int|1
suffix:semicolon
id|dbg_kept_tsn
op_assign
id|tsn
suffix:semicolon
)brace
suffix:semicolon
id|dbg_last_kept_tsn
op_assign
id|tsn
suffix:semicolon
macro_line|#endif /* SCTP_DEBUG */
)brace
)brace
macro_line|#if SCTP_DEBUG
multiline_comment|/* Finish off the last range, displaying its ending TSN.  */
r_switch
c_cond
(paren
id|dbg_prt_state
)paren
(brace
r_case
l_int|0
suffix:colon
r_if
c_cond
(paren
id|dbg_last_ack_tsn
op_ne
id|dbg_ack_tsn
)paren
(brace
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;-%08x&bslash;n&quot;
comma
id|dbg_last_ack_tsn
)paren
suffix:semicolon
)brace
r_else
(brace
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
r_if
c_cond
(paren
id|dbg_last_kept_tsn
op_ne
id|dbg_kept_tsn
)paren
(brace
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;-%08x&bslash;n&quot;
comma
id|dbg_last_kept_tsn
)paren
suffix:semicolon
)brace
r_else
(brace
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
suffix:semicolon
macro_line|#endif /* SCTP_DEBUG */
r_if
c_cond
(paren
id|transport
)paren
(brace
r_if
c_cond
(paren
id|bytes_acked
)paren
(brace
multiline_comment|/* 8.2. When an outstanding TSN is acknowledged,&n;&t;&t;&t; * the endpoint shall clear the error counter of&n;&t;&t;&t; * the destination transport address to which the&n;&t;&t;&t; * DATA chunk was last sent.&n;&t;&t;&t; * The association&squot;s overall error counter is&n;&t;&t;&t; * also cleared.&n;&t;&t;&t; */
id|transport-&gt;error_count
op_assign
l_int|0
suffix:semicolon
id|transport-&gt;asoc-&gt;overall_error_count
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Mark the destination transport address as&n;&t;&t;&t; * active if it is not so marked.&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|transport-&gt;active
)paren
(brace
id|sctp_assoc_control_transport
c_func
(paren
id|transport-&gt;asoc
comma
id|transport
comma
id|SCTP_TRANSPORT_UP
comma
id|SCTP_RECEIVED_SACK
)paren
suffix:semicolon
)brace
id|sctp_transport_raise_cwnd
c_func
(paren
id|transport
comma
id|sack_ctsn
comma
id|bytes_acked
)paren
suffix:semicolon
id|transport-&gt;flight_size
op_sub_assign
id|bytes_acked
suffix:semicolon
id|q-&gt;outstanding_bytes
op_sub_assign
id|bytes_acked
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* RFC 2960 6.1, sctpimpguide-06 2.15.2&n;&t;&t;&t; * When a sender is doing zero window probing, it&n;&t;&t;&t; * should not timeout the association if it continues&n;&t;&t;&t; * to receive new packets from the receiver. The&n;&t;&t;&t; * reason is that the receiver MAY keep its window&n;&t;&t;&t; * closed for an indefinite time.&n;&t;&t;&t; * A sender is doing zero window probing when the&n;&t;&t;&t; * receiver&squot;s advertised window is zero, and there is&n;&t;&t;&t; * only one data chunk in flight to the receiver.&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|q-&gt;asoc-&gt;peer.rwnd
op_logical_and
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|tlist
)paren
op_logical_and
(paren
id|sack_ctsn
op_plus
l_int|2
op_eq
id|q-&gt;asoc-&gt;next_tsn
)paren
)paren
(brace
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;%s: SACK received for zero &quot;
l_string|&quot;window probe: %u&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|sack_ctsn
)paren
suffix:semicolon
id|q-&gt;asoc-&gt;overall_error_count
op_assign
l_int|0
suffix:semicolon
id|transport-&gt;error_count
op_assign
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/* RFC 2960 6.3.2 Retransmission Timer Rules&n;&t;&t; *&n;&t;&t; * R2) Whenever all outstanding data sent to an address have&n;&t;&t; * been acknowledged, turn off the T3-rtx timer of that&n;&t;&t; * address.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|transport-&gt;flight_size
)paren
(brace
r_if
c_cond
(paren
id|timer_pending
c_func
(paren
op_amp
id|transport-&gt;T3_rtx_timer
)paren
op_logical_and
id|del_timer
c_func
(paren
op_amp
id|transport-&gt;T3_rtx_timer
)paren
)paren
(brace
id|sctp_transport_put
c_func
(paren
id|transport
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|restart_timer
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|mod_timer
c_func
(paren
op_amp
id|transport-&gt;T3_rtx_timer
comma
id|jiffies
op_plus
id|transport-&gt;rto
)paren
)paren
id|sctp_transport_hold
c_func
(paren
id|transport
)paren
suffix:semicolon
)brace
)brace
id|list_splice
c_func
(paren
op_amp
id|tlist
comma
id|transmitted_queue
)paren
suffix:semicolon
)brace
multiline_comment|/* Mark chunks as missing and consequently may get retransmitted. */
DECL|function|sctp_mark_missing
r_static
r_void
id|sctp_mark_missing
c_func
(paren
r_struct
id|sctp_outq
op_star
id|q
comma
r_struct
id|list_head
op_star
id|transmitted_queue
comma
r_struct
id|sctp_transport
op_star
id|transport
comma
id|__u32
id|highest_new_tsn_in_sack
comma
r_int
id|count_of_newacks
)paren
(brace
r_struct
id|sctp_chunk
op_star
id|chunk
suffix:semicolon
r_struct
id|list_head
op_star
id|pos
suffix:semicolon
id|__u32
id|tsn
suffix:semicolon
r_char
id|do_fast_retransmit
op_assign
l_int|0
suffix:semicolon
r_struct
id|sctp_transport
op_star
id|primary
op_assign
id|q-&gt;asoc-&gt;peer.primary_path
suffix:semicolon
id|list_for_each
c_func
(paren
id|pos
comma
id|transmitted_queue
)paren
(brace
id|chunk
op_assign
id|list_entry
c_func
(paren
id|pos
comma
r_struct
id|sctp_chunk
comma
id|transmitted_list
)paren
suffix:semicolon
id|tsn
op_assign
id|ntohl
c_func
(paren
id|chunk-&gt;subh.data_hdr-&gt;tsn
)paren
suffix:semicolon
multiline_comment|/* RFC 2960 7.2.4, sctpimpguide-05 2.8.2 M3) Examine all&n;&t;&t; * &squot;Unacknowledged TSN&squot;s&squot;, if the TSN number of an&n;&t;&t; * &squot;Unacknowledged TSN&squot; is smaller than the &squot;HighestTSNinSack&squot;&n;&t;&t; * value, increment the &squot;TSN.Missing.Report&squot; count on that&n;&t;&t; * chunk if it has NOT been fast retransmitted or marked for&n;&t;&t; * fast retransmit already.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|chunk-&gt;fast_retransmit
op_logical_and
op_logical_neg
id|chunk-&gt;tsn_gap_acked
op_logical_and
id|TSN_lt
c_func
(paren
id|tsn
comma
id|highest_new_tsn_in_sack
)paren
)paren
(brace
multiline_comment|/* SFR-CACC may require us to skip marking&n;&t;&t;&t; * this chunk as missing.&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|transport
op_logical_or
op_logical_neg
id|sctp_cacc_skip
c_func
(paren
id|primary
comma
id|transport
comma
id|count_of_newacks
comma
id|tsn
)paren
)paren
(brace
id|chunk-&gt;tsn_missing_report
op_increment
suffix:semicolon
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;%s: TSN 0x%x missing counter: %d&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|tsn
comma
id|chunk-&gt;tsn_missing_report
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t; * M4) If any DATA chunk is found to have a&n;&t;&t; * &squot;TSN.Missing.Report&squot;&n;&t;&t; * value larger than or equal to 4, mark that chunk for&n;&t;&t; * retransmission and start the fast retransmit procedure.&n;&t;&t; */
r_if
c_cond
(paren
id|chunk-&gt;tsn_missing_report
op_ge
l_int|4
)paren
(brace
id|chunk-&gt;fast_retransmit
op_assign
l_int|1
suffix:semicolon
id|do_fast_retransmit
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|transport
)paren
(brace
r_if
c_cond
(paren
id|do_fast_retransmit
)paren
id|sctp_retransmit
c_func
(paren
id|q
comma
id|transport
comma
id|SCTP_RTXR_FAST_RTX
)paren
suffix:semicolon
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;%s: transport: %p, cwnd: %d, &quot;
l_string|&quot;ssthresh: %d, flight_size: %d, pba: %d&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|transport
comma
id|transport-&gt;cwnd
comma
id|transport-&gt;ssthresh
comma
id|transport-&gt;flight_size
comma
id|transport-&gt;partial_bytes_acked
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Is the given TSN acked by this packet?  */
DECL|function|sctp_acked
r_static
r_int
id|sctp_acked
c_func
(paren
r_struct
id|sctp_sackhdr
op_star
id|sack
comma
id|__u32
id|tsn
)paren
(brace
r_int
id|i
suffix:semicolon
id|sctp_sack_variable_t
op_star
id|frags
suffix:semicolon
id|__u16
id|gap
suffix:semicolon
id|__u32
id|ctsn
op_assign
id|ntohl
c_func
(paren
id|sack-&gt;cum_tsn_ack
)paren
suffix:semicolon
r_if
c_cond
(paren
id|TSN_lte
c_func
(paren
id|tsn
comma
id|ctsn
)paren
)paren
r_goto
id|pass
suffix:semicolon
multiline_comment|/* 3.3.4 Selective Acknowledgement (SACK) (3):&n;&t; *&n;&t; * Gap Ack Blocks:&n;&t; *  These fields contain the Gap Ack Blocks. They are repeated&n;&t; *  for each Gap Ack Block up to the number of Gap Ack Blocks&n;&t; *  defined in the Number of Gap Ack Blocks field. All DATA&n;&t; *  chunks with TSNs greater than or equal to (Cumulative TSN&n;&t; *  Ack + Gap Ack Block Start) and less than or equal to&n;&t; *  (Cumulative TSN Ack + Gap Ack Block End) of each Gap Ack&n;&t; *  Block are assumed to have been received correctly.&n;&t; */
id|frags
op_assign
id|sack-&gt;variable
suffix:semicolon
id|gap
op_assign
id|tsn
op_minus
id|ctsn
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ntohs
c_func
(paren
id|sack-&gt;num_gap_ack_blocks
)paren
suffix:semicolon
op_increment
id|i
)paren
(brace
r_if
c_cond
(paren
id|TSN_lte
c_func
(paren
id|ntohs
c_func
(paren
id|frags
(braket
id|i
)braket
dot
id|gab.start
)paren
comma
id|gap
)paren
op_logical_and
id|TSN_lte
c_func
(paren
id|gap
comma
id|ntohs
c_func
(paren
id|frags
(braket
id|i
)braket
dot
id|gab.end
)paren
)paren
)paren
r_goto
id|pass
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
id|pass
suffix:colon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|sctp_get_skip_pos
r_static
r_inline
r_int
id|sctp_get_skip_pos
c_func
(paren
r_struct
id|sctp_fwdtsn_skip
op_star
id|skiplist
comma
r_int
id|nskips
comma
id|__u16
id|stream
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nskips
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|skiplist
(braket
id|i
)braket
dot
id|stream
op_eq
id|stream
)paren
r_return
id|i
suffix:semicolon
)brace
r_return
id|i
suffix:semicolon
)brace
multiline_comment|/* Create and add a fwdtsn chunk to the outq&squot;s control queue if needed. */
DECL|function|sctp_generate_fwdtsn
r_static
r_void
id|sctp_generate_fwdtsn
c_func
(paren
r_struct
id|sctp_outq
op_star
id|q
comma
id|__u32
id|ctsn
)paren
(brace
r_struct
id|sctp_association
op_star
id|asoc
op_assign
id|q-&gt;asoc
suffix:semicolon
r_struct
id|sctp_chunk
op_star
id|ftsn_chunk
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|sctp_fwdtsn_skip
id|ftsn_skip_arr
(braket
l_int|10
)braket
suffix:semicolon
r_int
id|nskips
op_assign
l_int|0
suffix:semicolon
r_int
id|skip_pos
op_assign
l_int|0
suffix:semicolon
id|__u32
id|tsn
suffix:semicolon
r_struct
id|sctp_chunk
op_star
id|chunk
suffix:semicolon
r_struct
id|list_head
op_star
id|lchunk
comma
op_star
id|temp
suffix:semicolon
multiline_comment|/* PR-SCTP C1) Let SackCumAck be the Cumulative TSN ACK carried in the&n;&t; * received SACK.&n;&t; * &n;&t; * If (Advanced.Peer.Ack.Point &lt; SackCumAck), then update&n;&t; * Advanced.Peer.Ack.Point to be equal to SackCumAck.&n;&t; */
r_if
c_cond
(paren
id|TSN_lt
c_func
(paren
id|asoc-&gt;adv_peer_ack_point
comma
id|ctsn
)paren
)paren
id|asoc-&gt;adv_peer_ack_point
op_assign
id|ctsn
suffix:semicolon
multiline_comment|/* PR-SCTP C2) Try to further advance the &quot;Advanced.Peer.Ack.Point&quot;&n;&t; * locally, that is, to move &quot;Advanced.Peer.Ack.Point&quot; up as long as&n;&t; * the chunk next in the out-queue space is marked as &quot;abandoned&quot; as&n;&t; * shown in the following example:&n;&t; *&n;&t; * Assuming that a SACK arrived with the Cumulative TSN ACK 102&n;&t; * and the Advanced.Peer.Ack.Point is updated to this value:&n;&t; * &n;&t; *   out-queue at the end of  ==&gt;   out-queue after Adv.Ack.Point&n;&t; *   normal SACK processing           local advancement&n;&t; *                ...                           ...&n;&t; *   Adv.Ack.Pt-&gt; 102 acked                     102 acked&n;&t; *                103 abandoned                 103 abandoned&n;&t; *                104 abandoned     Adv.Ack.P-&gt; 104 abandoned&n;&t; *                105                           105&n;&t; *                106 acked                     106 acked&n;&t; *                ...                           ...&n;&t; *&n;&t; * In this example, the data sender successfully advanced the&n;&t; * &quot;Advanced.Peer.Ack.Point&quot; from 102 to 104 locally.&n;&t; */
id|list_for_each_safe
c_func
(paren
id|lchunk
comma
id|temp
comma
op_amp
id|q-&gt;abandoned
)paren
(brace
id|chunk
op_assign
id|list_entry
c_func
(paren
id|lchunk
comma
r_struct
id|sctp_chunk
comma
id|transmitted_list
)paren
suffix:semicolon
id|tsn
op_assign
id|ntohl
c_func
(paren
id|chunk-&gt;subh.data_hdr-&gt;tsn
)paren
suffix:semicolon
multiline_comment|/* Remove any chunks in the abandoned queue that are acked by&n;&t;&t; * the ctsn.&n;&t;&t; */
r_if
c_cond
(paren
id|TSN_lte
c_func
(paren
id|tsn
comma
id|ctsn
)paren
)paren
(brace
id|list_del_init
c_func
(paren
id|lchunk
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|chunk-&gt;tsn_gap_acked
)paren
(brace
id|chunk-&gt;transport-&gt;flight_size
op_sub_assign
id|sctp_data_size
c_func
(paren
id|chunk
)paren
suffix:semicolon
id|q-&gt;outstanding_bytes
op_sub_assign
id|sctp_data_size
c_func
(paren
id|chunk
)paren
suffix:semicolon
)brace
id|sctp_chunk_free
c_func
(paren
id|chunk
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|TSN_lte
c_func
(paren
id|tsn
comma
id|asoc-&gt;adv_peer_ack_point
op_plus
l_int|1
)paren
)paren
(brace
id|asoc-&gt;adv_peer_ack_point
op_assign
id|tsn
suffix:semicolon
r_if
c_cond
(paren
id|chunk-&gt;chunk_hdr-&gt;flags
op_amp
id|SCTP_DATA_UNORDERED
)paren
r_continue
suffix:semicolon
id|skip_pos
op_assign
id|sctp_get_skip_pos
c_func
(paren
op_amp
id|ftsn_skip_arr
(braket
l_int|0
)braket
comma
id|nskips
comma
id|chunk-&gt;subh.data_hdr-&gt;stream
)paren
suffix:semicolon
id|ftsn_skip_arr
(braket
id|skip_pos
)braket
dot
id|stream
op_assign
id|chunk-&gt;subh.data_hdr-&gt;stream
suffix:semicolon
id|ftsn_skip_arr
(braket
id|skip_pos
)braket
dot
id|ssn
op_assign
id|chunk-&gt;subh.data_hdr-&gt;ssn
suffix:semicolon
r_if
c_cond
(paren
id|skip_pos
op_eq
id|nskips
)paren
id|nskips
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|nskips
op_eq
l_int|10
)paren
r_break
suffix:semicolon
)brace
r_else
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* PR-SCTP C3) If, after step C1 and C2, the &quot;Advanced.Peer.Ack.Point&quot;&n;&t; * is greater than the Cumulative TSN ACK carried in the received&n;&t; * SACK, the data sender MUST send the data receiver a FORWARD TSN&n;&t; * chunk containing the latest value of the&n;&t; * &quot;Advanced.Peer.Ack.Point&quot;.&n;&t; *&n;&t; * C4) For each &quot;abandoned&quot; TSN the sender of the FORWARD TSN SHOULD&n;&t; * list each stream and sequence number in the forwarded TSN. This&n;&t; * information will enable the receiver to easily find any&n;&t; * stranded TSN&squot;s waiting on stream reorder queues. Each stream&n;&t; * SHOULD only be reported once; this means that if multiple&n;&t; * abandoned messages occur in the same stream then only the&n;&t; * highest abandoned stream sequence number is reported. If the&n;&t; * total size of the FORWARD TSN does NOT fit in a single MTU then&n;&t; * the sender of the FORWARD TSN SHOULD lower the&n;&t; * Advanced.Peer.Ack.Point to the last TSN that will fit in a&n;&t; * single MTU.&n;&t; */
r_if
c_cond
(paren
id|asoc-&gt;adv_peer_ack_point
OG
id|ctsn
)paren
id|ftsn_chunk
op_assign
id|sctp_make_fwdtsn
c_func
(paren
id|asoc
comma
id|asoc-&gt;adv_peer_ack_point
comma
id|nskips
comma
op_amp
id|ftsn_skip_arr
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ftsn_chunk
)paren
(brace
id|__skb_queue_tail
c_func
(paren
op_amp
id|q-&gt;control
comma
(paren
r_struct
id|sk_buff
op_star
)paren
id|ftsn_chunk
)paren
suffix:semicolon
id|SCTP_INC_STATS
c_func
(paren
id|SCTP_MIB_OUTCTRLCHUNKS
)paren
suffix:semicolon
)brace
)brace
eof
