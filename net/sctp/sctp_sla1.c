multiline_comment|/* SCTP kernel reference Implementation&n; * Copyright (c) 1999-2000 Cisco, Inc.&n; * Copyright (c) 1999-2001 Motorola, Inc.&n; * &n; * This file is part of the SCTP kernel reference Implementation&n; * &n; * $Header: /cvsroot/lksctp/lksctp/sctp_cvs/net/sctp/sctp_sla1.c,v 1.4 2002/07/19 22:00:33 jgrimm Exp $&n; * &n; * (It&squot;s really SHA-1 but Hey I was tired when I created this &n; * file, and on a plane to France :-)&n; * &n; * The SCTP reference implementation is free software; &n; * you can redistribute it and/or modify it under the terms of &n; * the GNU General Public License as published by&n; * the Free Software Foundation; either version 2, or (at your option)&n; * any later version.&n; * &n; * The SCTP reference implementation is distributed in the hope that it &n; * will be useful, but WITHOUT ANY WARRANTY; without even the implied&n; *                 ************************&n; * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&n; * See the GNU General Public License for more details.&n; * &n; * You should have received a copy of the GNU General Public License&n; * along with GNU CC; see the file COPYING.  If not, write to&n; * the Free Software Foundation, 59 Temple Place - Suite 330,&n; * Boston, MA 02111-1307, USA.  &n; * &n; * Please send any bug reports or fixes you make to the&n; * email address(es):&n; *    lksctp developers &lt;lksctp-developers@lists.sourceforge.net&gt;&n; * &n; * Or submit a bug report through the following website:&n; *    http://www.sf.net/projects/lksctp&n; *&n; * Written or modified by: &n; *    Randall Stewart &lt;rstewar1@email.mot.com&gt;&n; *    kmorneau@cisco.com&n; *    qxie1@email.mot.com&n; *&n; * Based on:&n; *    Randy Stewart, et al. SCTP Reference Implementation which is licenced&n; *    under the GPL. &n; * &n; * Any bugs reported given to us we will try to fix... any fixes shared will&n; * be incorporated into the next SCTP release.&n; */
DECL|variable|cvs_id
r_static
r_char
op_star
id|cvs_id
id|__attribute__
(paren
(paren
id|unused
)paren
)paren
op_assign
l_string|&quot;$Id: sctp_sla1.c,v 1.4 2002/07/19 22:00:33 jgrimm Exp $&quot;
suffix:semicolon
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;asm/string.h&gt;&t;&t;/* for memcpy */
macro_line|#include &lt;linux/sched.h&gt;&t;/* dead chicken for in.h */
macro_line|#include &lt;linux/in.h&gt;&t;&t;/* for htonl and ntohl */
macro_line|#include &lt;net/sctp/sctp_sla1.h&gt;
r_void
DECL|function|SLA1_Init
id|SLA1_Init
c_func
(paren
r_struct
id|SLA_1_Context
op_star
id|ctx
)paren
(brace
multiline_comment|/* Init the SLA-1 context structure */
id|ctx-&gt;A
op_assign
l_int|0
suffix:semicolon
id|ctx-&gt;B
op_assign
l_int|0
suffix:semicolon
id|ctx-&gt;C
op_assign
l_int|0
suffix:semicolon
id|ctx-&gt;D
op_assign
l_int|0
suffix:semicolon
id|ctx-&gt;E
op_assign
l_int|0
suffix:semicolon
id|ctx-&gt;H0
op_assign
id|H0INIT
suffix:semicolon
id|ctx-&gt;H1
op_assign
id|H1INIT
suffix:semicolon
id|ctx-&gt;H2
op_assign
id|H2INIT
suffix:semicolon
id|ctx-&gt;H3
op_assign
id|H3INIT
suffix:semicolon
id|ctx-&gt;H4
op_assign
id|H4INIT
suffix:semicolon
id|ctx-&gt;TEMP
op_assign
l_int|0
suffix:semicolon
id|memset
c_func
(paren
id|ctx-&gt;words
comma
l_int|0
comma
r_sizeof
(paren
id|ctx-&gt;words
)paren
)paren
suffix:semicolon
id|ctx-&gt;howManyInBlock
op_assign
l_int|0
suffix:semicolon
id|ctx-&gt;runningTotal
op_assign
l_int|0
suffix:semicolon
)brace
r_void
DECL|function|SLA1processABlock
id|SLA1processABlock
c_func
(paren
r_struct
id|SLA_1_Context
op_star
id|ctx
comma
r_int
r_int
op_star
id|block
)paren
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/* init the W0-W15 to the block of words being &n;   * hashed.&n;   */
multiline_comment|/* step a) */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
id|i
op_increment
)paren
(brace
id|ctx-&gt;words
(braket
id|i
)braket
op_assign
id|ntohl
c_func
(paren
id|block
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/* now init the rest based on the SLA-1 formula, step b) */
r_for
c_loop
(paren
id|i
op_assign
l_int|16
suffix:semicolon
id|i
OL
l_int|80
suffix:semicolon
id|i
op_increment
)paren
(brace
id|ctx-&gt;words
(braket
id|i
)braket
op_assign
id|CSHIFT
c_func
(paren
l_int|1
comma
(paren
(paren
id|ctx-&gt;words
(braket
(paren
id|i
op_minus
l_int|3
)paren
)braket
)paren
op_xor
(paren
id|ctx-&gt;words
(braket
(paren
id|i
op_minus
l_int|8
)paren
)braket
)paren
op_xor
(paren
id|ctx-&gt;words
(braket
(paren
id|i
op_minus
l_int|14
)paren
)braket
)paren
op_xor
(paren
id|ctx-&gt;words
(braket
(paren
id|i
op_minus
l_int|16
)paren
)braket
)paren
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* step c) */
id|ctx-&gt;A
op_assign
id|ctx-&gt;H0
suffix:semicolon
id|ctx-&gt;B
op_assign
id|ctx-&gt;H1
suffix:semicolon
id|ctx-&gt;C
op_assign
id|ctx-&gt;H2
suffix:semicolon
id|ctx-&gt;D
op_assign
id|ctx-&gt;H3
suffix:semicolon
id|ctx-&gt;E
op_assign
id|ctx-&gt;H4
suffix:semicolon
multiline_comment|/* step d) */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|80
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|i
OL
l_int|20
)paren
(brace
id|ctx-&gt;TEMP
op_assign
(paren
(paren
id|CSHIFT
c_func
(paren
l_int|5
comma
id|ctx-&gt;A
)paren
)paren
op_plus
(paren
id|F1
c_func
(paren
id|ctx-&gt;B
comma
id|ctx-&gt;C
comma
id|ctx-&gt;D
)paren
)paren
op_plus
(paren
id|ctx-&gt;E
)paren
op_plus
id|ctx-&gt;words
(braket
id|i
)braket
op_plus
id|K1
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|i
OL
l_int|40
)paren
(brace
id|ctx-&gt;TEMP
op_assign
(paren
(paren
id|CSHIFT
c_func
(paren
l_int|5
comma
id|ctx-&gt;A
)paren
)paren
op_plus
(paren
id|F2
c_func
(paren
id|ctx-&gt;B
comma
id|ctx-&gt;C
comma
id|ctx-&gt;D
)paren
)paren
op_plus
(paren
id|ctx-&gt;E
)paren
op_plus
(paren
id|ctx-&gt;words
(braket
id|i
)braket
)paren
op_plus
id|K2
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|i
OL
l_int|60
)paren
(brace
id|ctx-&gt;TEMP
op_assign
(paren
(paren
id|CSHIFT
c_func
(paren
l_int|5
comma
id|ctx-&gt;A
)paren
)paren
op_plus
(paren
id|F3
c_func
(paren
id|ctx-&gt;B
comma
id|ctx-&gt;C
comma
id|ctx-&gt;D
)paren
)paren
op_plus
(paren
id|ctx-&gt;E
)paren
op_plus
(paren
id|ctx-&gt;words
(braket
id|i
)braket
)paren
op_plus
id|K3
)paren
suffix:semicolon
)brace
r_else
(brace
id|ctx-&gt;TEMP
op_assign
(paren
(paren
id|CSHIFT
c_func
(paren
l_int|5
comma
id|ctx-&gt;A
)paren
)paren
op_plus
(paren
id|F4
c_func
(paren
id|ctx-&gt;B
comma
id|ctx-&gt;C
comma
id|ctx-&gt;D
)paren
)paren
op_plus
(paren
id|ctx-&gt;E
)paren
op_plus
(paren
id|ctx-&gt;words
(braket
id|i
)braket
)paren
op_plus
id|K4
)paren
suffix:semicolon
)brace
id|ctx-&gt;E
op_assign
id|ctx-&gt;D
suffix:semicolon
id|ctx-&gt;D
op_assign
id|ctx-&gt;C
suffix:semicolon
id|ctx-&gt;C
op_assign
id|CSHIFT
c_func
(paren
l_int|30
comma
id|ctx-&gt;B
)paren
suffix:semicolon
id|ctx-&gt;B
op_assign
id|ctx-&gt;A
suffix:semicolon
id|ctx-&gt;A
op_assign
id|ctx-&gt;TEMP
suffix:semicolon
)brace
multiline_comment|/* step e) */
id|ctx-&gt;H0
op_assign
(paren
id|ctx-&gt;H0
)paren
op_plus
(paren
id|ctx-&gt;A
)paren
suffix:semicolon
id|ctx-&gt;H1
op_assign
(paren
id|ctx-&gt;H1
)paren
op_plus
(paren
id|ctx-&gt;B
)paren
suffix:semicolon
id|ctx-&gt;H2
op_assign
(paren
id|ctx-&gt;H2
)paren
op_plus
(paren
id|ctx-&gt;C
)paren
suffix:semicolon
id|ctx-&gt;H3
op_assign
(paren
id|ctx-&gt;H3
)paren
op_plus
(paren
id|ctx-&gt;D
)paren
suffix:semicolon
id|ctx-&gt;H4
op_assign
(paren
id|ctx-&gt;H4
)paren
op_plus
(paren
id|ctx-&gt;E
)paren
suffix:semicolon
)brace
r_void
DECL|function|SLA1_Process
id|SLA1_Process
c_func
(paren
r_struct
id|SLA_1_Context
op_star
id|ctx
comma
r_const
r_int
r_char
op_star
id|ptr
comma
r_int
id|siz
)paren
(brace
r_int
id|numberLeft
comma
id|leftToFill
suffix:semicolon
id|numberLeft
op_assign
id|siz
suffix:semicolon
r_while
c_loop
(paren
id|numberLeft
OG
l_int|0
)paren
(brace
id|leftToFill
op_assign
r_sizeof
(paren
id|ctx-&gt;SLAblock
)paren
op_minus
id|ctx-&gt;howManyInBlock
suffix:semicolon
r_if
c_cond
(paren
id|leftToFill
OG
id|numberLeft
)paren
(brace
multiline_comment|/* can only partially fill up this one */
id|memcpy
c_func
(paren
op_amp
id|ctx-&gt;SLAblock
(braket
id|ctx-&gt;howManyInBlock
)braket
comma
id|ptr
comma
id|numberLeft
)paren
suffix:semicolon
id|ctx-&gt;howManyInBlock
op_add_assign
id|siz
suffix:semicolon
id|ctx-&gt;runningTotal
op_add_assign
id|siz
suffix:semicolon
r_break
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* block is now full, process it */
id|memcpy
c_func
(paren
op_amp
id|ctx-&gt;SLAblock
(braket
id|ctx-&gt;howManyInBlock
)braket
comma
id|ptr
comma
id|leftToFill
)paren
suffix:semicolon
id|SLA1processABlock
c_func
(paren
id|ctx
comma
(paren
r_int
r_int
op_star
)paren
id|ctx-&gt;SLAblock
)paren
suffix:semicolon
id|numberLeft
op_sub_assign
id|leftToFill
suffix:semicolon
id|ctx-&gt;runningTotal
op_add_assign
id|leftToFill
suffix:semicolon
id|ctx-&gt;howManyInBlock
op_assign
l_int|0
suffix:semicolon
)brace
)brace
)brace
r_void
DECL|function|SLA1_Final
id|SLA1_Final
c_func
(paren
r_struct
id|SLA_1_Context
op_star
id|ctx
comma
r_int
r_char
op_star
id|digestBuf
)paren
(brace
multiline_comment|/* if any left in block fill with padding &n;   * and process. Then transfer the digest to &n;   * the pointer. At the last block some special&n;   * rules need to apply. We must add a 1 bit&n;   * following the message, then we pad with&n;   * 0&squot;s. The total size is encoded as a 64 bit&n;   * number at the end. Now if the last buffer has&n;   * more than 55 octets in it we cannot fit&n;   * the 64 bit number + 10000000 pad on the end&n;   * and must add the 10000000 pad, pad the rest&n;   * of the message with 0&squot;s and then create a&n;   * all 0 message with just the 64 bit size&n;   * at the end and run this block through by itself.&n;   * Also the 64 bit int must be in network byte&n;   * order.&n;   */
r_int
id|i
comma
id|leftToFill
suffix:semicolon
r_int
r_int
op_star
id|ptr
suffix:semicolon
r_if
c_cond
(paren
id|ctx-&gt;howManyInBlock
OG
l_int|55
)paren
(brace
multiline_comment|/* special case, we need to process two&n;     * blocks here. One for the current stuff&n;     * plus possibly the pad. The other for&n;     * the size.&n;     */
id|leftToFill
op_assign
r_sizeof
(paren
id|ctx-&gt;SLAblock
)paren
op_minus
id|ctx-&gt;howManyInBlock
suffix:semicolon
r_if
c_cond
(paren
id|leftToFill
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Should not really happen but I am paranoid */
multiline_comment|/* Not paranoid enough!  It is possible for leftToFill to become&n;       * negative!  AAA!!!!  This is another reason to pick MD5 :-)...&n;       */
id|SLA1processABlock
c_func
(paren
id|ctx
comma
(paren
r_int
r_int
op_star
)paren
id|ctx-&gt;SLAblock
)paren
suffix:semicolon
multiline_comment|/* init last block, a bit different then the rest :-) */
id|ctx-&gt;SLAblock
(braket
l_int|0
)braket
op_assign
l_int|0x80
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|ctx-&gt;SLAblock
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|ctx-&gt;SLAblock
(braket
id|i
)braket
op_assign
l_int|0x0
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|leftToFill
op_eq
l_int|1
)paren
(brace
id|ctx-&gt;SLAblock
(braket
id|ctx-&gt;howManyInBlock
)braket
op_assign
l_int|0x80
suffix:semicolon
id|SLA1processABlock
c_func
(paren
id|ctx
comma
(paren
r_int
r_int
op_star
)paren
id|ctx-&gt;SLAblock
)paren
suffix:semicolon
multiline_comment|/* init last block */
id|memset
c_func
(paren
id|ctx-&gt;SLAblock
comma
l_int|0
comma
r_sizeof
(paren
id|ctx-&gt;SLAblock
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|ctx-&gt;SLAblock
(braket
id|ctx-&gt;howManyInBlock
)braket
op_assign
l_int|0x80
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
(paren
id|ctx-&gt;howManyInBlock
op_plus
l_int|1
)paren
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|ctx-&gt;SLAblock
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|ctx-&gt;SLAblock
(braket
id|i
)braket
op_assign
l_int|0x0
suffix:semicolon
)brace
id|SLA1processABlock
c_func
(paren
id|ctx
comma
(paren
r_int
r_int
op_star
)paren
id|ctx-&gt;SLAblock
)paren
suffix:semicolon
multiline_comment|/* init last block */
id|memset
c_func
(paren
id|ctx-&gt;SLAblock
comma
l_int|0
comma
r_sizeof
(paren
id|ctx-&gt;SLAblock
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* This is in bits so multiply by 8 */
id|ctx-&gt;runningTotal
op_mul_assign
l_int|8
suffix:semicolon
id|ptr
op_assign
(paren
r_int
r_int
op_star
)paren
op_amp
id|ctx-&gt;SLAblock
(braket
l_int|60
)braket
suffix:semicolon
op_star
id|ptr
op_assign
id|htonl
c_func
(paren
id|ctx-&gt;runningTotal
)paren
suffix:semicolon
id|SLA1processABlock
c_func
(paren
id|ctx
comma
(paren
r_int
r_int
op_star
)paren
id|ctx-&gt;SLAblock
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* easy case, we just pad this&n;     * message to size - end with 0&n;     * add the magic 0x80 to the next&n;     * word and then put the network byte&n;     * order size in the last spot and&n;     * process the block.&n;     */
id|ctx-&gt;SLAblock
(braket
id|ctx-&gt;howManyInBlock
)braket
op_assign
l_int|0x80
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
(paren
id|ctx-&gt;howManyInBlock
op_plus
l_int|1
)paren
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|ctx-&gt;SLAblock
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|ctx-&gt;SLAblock
(braket
id|i
)braket
op_assign
l_int|0x0
suffix:semicolon
)brace
multiline_comment|/* get last int spot */
id|ctx-&gt;runningTotal
op_mul_assign
l_int|8
suffix:semicolon
id|ptr
op_assign
(paren
r_int
r_int
op_star
)paren
op_amp
id|ctx-&gt;SLAblock
(braket
l_int|60
)braket
suffix:semicolon
op_star
id|ptr
op_assign
id|htonl
c_func
(paren
id|ctx-&gt;runningTotal
)paren
suffix:semicolon
id|SLA1processABlock
c_func
(paren
id|ctx
comma
(paren
r_int
r_int
op_star
)paren
id|ctx-&gt;SLAblock
)paren
suffix:semicolon
)brace
multiline_comment|/* Now at this point all we need do is transfer the &n;   * digest back to the user&n;   */
id|digestBuf
(braket
l_int|3
)braket
op_assign
(paren
id|ctx-&gt;H0
op_amp
l_int|0xff
)paren
suffix:semicolon
id|digestBuf
(braket
l_int|2
)braket
op_assign
(paren
(paren
id|ctx-&gt;H0
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
)paren
suffix:semicolon
id|digestBuf
(braket
l_int|1
)braket
op_assign
(paren
(paren
id|ctx-&gt;H0
op_rshift
l_int|16
)paren
op_amp
l_int|0xff
)paren
suffix:semicolon
id|digestBuf
(braket
l_int|0
)braket
op_assign
(paren
(paren
id|ctx-&gt;H0
op_rshift
l_int|24
)paren
op_amp
l_int|0xff
)paren
suffix:semicolon
id|digestBuf
(braket
l_int|7
)braket
op_assign
(paren
id|ctx-&gt;H1
op_amp
l_int|0xff
)paren
suffix:semicolon
id|digestBuf
(braket
l_int|6
)braket
op_assign
(paren
(paren
id|ctx-&gt;H1
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
)paren
suffix:semicolon
id|digestBuf
(braket
l_int|5
)braket
op_assign
(paren
(paren
id|ctx-&gt;H1
op_rshift
l_int|16
)paren
op_amp
l_int|0xff
)paren
suffix:semicolon
id|digestBuf
(braket
l_int|4
)braket
op_assign
(paren
(paren
id|ctx-&gt;H1
op_rshift
l_int|24
)paren
op_amp
l_int|0xff
)paren
suffix:semicolon
id|digestBuf
(braket
l_int|11
)braket
op_assign
(paren
id|ctx-&gt;H2
op_amp
l_int|0xff
)paren
suffix:semicolon
id|digestBuf
(braket
l_int|10
)braket
op_assign
(paren
(paren
id|ctx-&gt;H2
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
)paren
suffix:semicolon
id|digestBuf
(braket
l_int|9
)braket
op_assign
(paren
(paren
id|ctx-&gt;H2
op_rshift
l_int|16
)paren
op_amp
l_int|0xff
)paren
suffix:semicolon
id|digestBuf
(braket
l_int|8
)braket
op_assign
(paren
(paren
id|ctx-&gt;H2
op_rshift
l_int|24
)paren
op_amp
l_int|0xff
)paren
suffix:semicolon
id|digestBuf
(braket
l_int|15
)braket
op_assign
(paren
id|ctx-&gt;H3
op_amp
l_int|0xff
)paren
suffix:semicolon
id|digestBuf
(braket
l_int|14
)braket
op_assign
(paren
(paren
id|ctx-&gt;H3
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
)paren
suffix:semicolon
id|digestBuf
(braket
l_int|13
)braket
op_assign
(paren
(paren
id|ctx-&gt;H3
op_rshift
l_int|16
)paren
op_amp
l_int|0xff
)paren
suffix:semicolon
id|digestBuf
(braket
l_int|12
)braket
op_assign
(paren
(paren
id|ctx-&gt;H3
op_rshift
l_int|24
)paren
op_amp
l_int|0xff
)paren
suffix:semicolon
id|digestBuf
(braket
l_int|19
)braket
op_assign
(paren
id|ctx-&gt;H4
op_amp
l_int|0xff
)paren
suffix:semicolon
id|digestBuf
(braket
l_int|18
)braket
op_assign
(paren
(paren
id|ctx-&gt;H4
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
)paren
suffix:semicolon
id|digestBuf
(braket
l_int|17
)braket
op_assign
(paren
(paren
id|ctx-&gt;H4
op_rshift
l_int|16
)paren
op_amp
l_int|0xff
)paren
suffix:semicolon
id|digestBuf
(braket
l_int|16
)braket
op_assign
(paren
(paren
id|ctx-&gt;H4
op_rshift
l_int|24
)paren
op_amp
l_int|0xff
)paren
suffix:semicolon
)brace
eof
