multiline_comment|/* SCTP kernel reference Implementation&n; * Copyright (c) 2001 International Business Machines Corp.&n; * &n; * This file is part of the SCTP kernel reference Implementation&n; * &n; * Support for memory object debugging.  This allows one to monitor the&n; * object allocations/deallocations for types instrumented for this &n; * via the proc fs. &n; * &n; * The SCTP reference implementation is free software; &n; * you can redistribute it and/or modify it under the terms of &n; * the GNU General Public License as published by&n; * the Free Software Foundation; either version 2, or (at your option)&n; * any later version.&n; * &n; * The SCTP reference implementation is distributed in the hope that it &n; * will be useful, but WITHOUT ANY WARRANTY; without even the implied&n; *                 ************************&n; * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&n; * See the GNU General Public License for more details.&n; * &n; * You should have received a copy of the GNU General Public License&n; * along with GNU CC; see the file COPYING.  If not, write to&n; * the Free Software Foundation, 59 Temple Place - Suite 330,&n; * Boston, MA 02111-1307, USA.  &n; * &n; * Please send any bug reports or fixes you make to the&n; * email address(es):&n; *    lksctp developers &lt;lksctp-developers@lists.sourceforge.net&gt;&n; * &n; * Or submit a bug report through the following website:&n; *    http://www.sf.net/projects/lksctp&n; *&n; * Written or modified by: &n; *    Jon Grimm             &lt;jgrimm@us.ibm.com&gt;&n; * &n; * Any bugs reported given to us we will try to fix... any fixes shared will&n; * be incorporated into the next SCTP release.&n; */
macro_line|#include &lt;net/sctp/sctp.h&gt;
multiline_comment|/*&n; * Global counters to count raw object allocation counts.&n; * To add new counters, choose a unique suffix for the variable&n; * name as the helper macros key off this suffix to make&n; * life easier for the programmer.&n; */
DECL|variable|sock
id|SCTP_DBG_OBJCNT
c_func
(paren
id|sock
)paren
suffix:semicolon
DECL|variable|ep
id|SCTP_DBG_OBJCNT
c_func
(paren
id|ep
)paren
suffix:semicolon
DECL|variable|transport
id|SCTP_DBG_OBJCNT
c_func
(paren
id|transport
)paren
suffix:semicolon
DECL|variable|assoc
id|SCTP_DBG_OBJCNT
c_func
(paren
id|assoc
)paren
suffix:semicolon
DECL|variable|bind_addr
id|SCTP_DBG_OBJCNT
c_func
(paren
id|bind_addr
)paren
suffix:semicolon
DECL|variable|chunk
id|SCTP_DBG_OBJCNT
c_func
(paren
id|chunk
)paren
suffix:semicolon
DECL|variable|addr
id|SCTP_DBG_OBJCNT
c_func
(paren
id|addr
)paren
suffix:semicolon
DECL|variable|ssnmap
id|SCTP_DBG_OBJCNT
c_func
(paren
id|ssnmap
)paren
suffix:semicolon
multiline_comment|/* An array to make it easy to pretty print the debug information&n; * to the proc fs.&n; */
DECL|variable|sctp_dbg_objcnt
id|sctp_dbg_objcnt_entry_t
id|sctp_dbg_objcnt
(braket
)braket
op_assign
(brace
id|SCTP_DBG_OBJCNT_ENTRY
c_func
(paren
id|sock
)paren
comma
id|SCTP_DBG_OBJCNT_ENTRY
c_func
(paren
id|ep
)paren
comma
id|SCTP_DBG_OBJCNT_ENTRY
c_func
(paren
id|assoc
)paren
comma
id|SCTP_DBG_OBJCNT_ENTRY
c_func
(paren
id|transport
)paren
comma
id|SCTP_DBG_OBJCNT_ENTRY
c_func
(paren
id|chunk
)paren
comma
id|SCTP_DBG_OBJCNT_ENTRY
c_func
(paren
id|bind_addr
)paren
comma
id|SCTP_DBG_OBJCNT_ENTRY
c_func
(paren
id|addr
)paren
comma
id|SCTP_DBG_OBJCNT_ENTRY
c_func
(paren
id|ssnmap
)paren
comma
)brace
suffix:semicolon
multiline_comment|/* Callback from procfs to read out objcount information.&n; * Walk through the entries in the sctp_dbg_objcnt array, dumping&n; * the raw object counts for each monitored type.&n; *&n; * This code was modified from similar code in route.c&n; */
DECL|function|sctp_dbg_objcnt_read
r_static
r_int
id|sctp_dbg_objcnt_read
c_func
(paren
r_char
op_star
id|buffer
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|length
comma
r_int
op_star
id|eof
comma
r_void
op_star
id|data
)paren
(brace
r_int
id|len
op_assign
l_int|0
suffix:semicolon
id|off_t
id|pos
op_assign
l_int|0
suffix:semicolon
r_int
id|entries
suffix:semicolon
r_int
id|i
suffix:semicolon
r_char
id|temp
(braket
l_int|128
)braket
suffix:semicolon
multiline_comment|/* How many entries? */
id|entries
op_assign
r_sizeof
(paren
id|sctp_dbg_objcnt
)paren
op_div
r_sizeof
(paren
id|sctp_dbg_objcnt
(braket
l_int|0
)braket
)paren
suffix:semicolon
multiline_comment|/* Walk the entries and print out the debug information&n;&t; * for proc fs.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|entries
suffix:semicolon
id|i
op_increment
)paren
(brace
id|pos
op_add_assign
l_int|128
suffix:semicolon
multiline_comment|/* Skip ahead. */
r_if
c_cond
(paren
id|pos
op_le
id|offset
)paren
(brace
id|len
op_assign
l_int|0
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* Print out each entry. */
id|sprintf
c_func
(paren
id|temp
comma
l_string|&quot;%s: %d&quot;
comma
id|sctp_dbg_objcnt
(braket
id|i
)braket
dot
id|label
comma
id|atomic_read
c_func
(paren
id|sctp_dbg_objcnt
(braket
id|i
)braket
dot
id|counter
)paren
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;%-127s&bslash;n&quot;
comma
id|temp
)paren
suffix:semicolon
id|len
op_add_assign
l_int|128
suffix:semicolon
r_if
c_cond
(paren
id|pos
op_ge
id|offset
op_plus
id|length
)paren
r_goto
id|done
suffix:semicolon
)brace
id|done
suffix:colon
op_star
id|start
op_assign
id|buffer
op_plus
id|len
op_minus
(paren
id|pos
op_minus
id|offset
)paren
suffix:semicolon
id|len
op_assign
id|pos
op_minus
id|offset
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|length
)paren
id|len
op_assign
id|length
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
multiline_comment|/* Initialize the objcount in the proc filesystem.  */
DECL|function|sctp_dbg_objcnt_init
r_void
id|sctp_dbg_objcnt_init
c_func
(paren
r_void
)paren
(brace
id|create_proc_read_entry
c_func
(paren
l_string|&quot;sctp_dbg_objcnt&quot;
comma
l_int|0
comma
id|proc_net_sctp
comma
id|sctp_dbg_objcnt_read
comma
l_int|NULL
)paren
suffix:semicolon
)brace
multiline_comment|/* Cleanup the objcount entry in the proc filesystem.  */
DECL|function|sctp_dbg_objcnt_exit
r_void
id|sctp_dbg_objcnt_exit
c_func
(paren
r_void
)paren
(brace
id|remove_proc_entry
c_func
(paren
l_string|&quot;sctp_dbg_objcount&quot;
comma
id|proc_net_sctp
)paren
suffix:semicolon
)brace
eof
