multiline_comment|/* SCTP kernel reference Implementation&n; * (C) Copyright IBM Corp. 2001, 2004&n; * Copyright (c) 1999-2000 Cisco, Inc.&n; * Copyright (c) 1999-2001 Motorola, Inc.&n; * Copyright (c) 2001 Intel Corp.&n; * Copyright (c) 2001 Nokia, Inc.&n; * Copyright (c) 2001 La Monte H.P. Yarroll&n; *&n; * These functions manipulate an sctp event.   The struct ulpevent is used&n; * to carry notifications and data to the ULP (sockets).&n; * The SCTP reference implementation is free software;&n; * you can redistribute it and/or modify it under the terms of&n; * the GNU General Public License as published by&n; * the Free Software Foundation; either version 2, or (at your option)&n; * any later version.&n; *&n; * The SCTP reference implementation is distributed in the hope that it&n; * will be useful, but WITHOUT ANY WARRANTY; without even the implied&n; *                 ************************&n; * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&n; * See the GNU General Public License for more details.&n; *&n; * You should have received a copy of the GNU General Public License&n; * along with GNU CC; see the file COPYING.  If not, write to&n; * the Free Software Foundation, 59 Temple Place - Suite 330,&n; * Boston, MA 02111-1307, USA.&n; *&n; * Please send any bug reports or fixes you make to the&n; * email address(es):&n; *    lksctp developers &lt;lksctp-developers@lists.sourceforge.net&gt;&n; *&n; * Or submit a bug report through the following website:&n; *    http://www.sf.net/projects/lksctp&n; *&n; * Written or modified by:&n; *    Jon Grimm             &lt;jgrimm@us.ibm.com&gt;&n; *    La Monte H.P. Yarroll &lt;piggy@acm.org&gt;&n; *    Ardelle Fan&t;    &lt;ardelle.fan@intel.com&gt;&n; *    Sridhar Samudrala     &lt;sri@us.ibm.com&gt;&n; *&n; * Any bugs reported given to us we will try to fix... any fixes shared will&n; * be incorporated into the next SCTP release.&n; */
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;net/sctp/structs.h&gt;
macro_line|#include &lt;net/sctp/sctp.h&gt;
macro_line|#include &lt;net/sctp/sm.h&gt;
r_static
r_void
id|sctp_ulpevent_receive_data
c_func
(paren
r_struct
id|sctp_ulpevent
op_star
id|event
comma
r_struct
id|sctp_association
op_star
id|asoc
)paren
suffix:semicolon
r_static
r_void
id|sctp_ulpevent_release_data
c_func
(paren
r_struct
id|sctp_ulpevent
op_star
id|event
)paren
suffix:semicolon
multiline_comment|/* Stub skb destructor.  */
DECL|function|sctp_stub_rfree
r_static
r_void
id|sctp_stub_rfree
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
multiline_comment|/* WARNING:  This function is just a warning not to use the&n; * skb destructor.  If the skb is shared, we may get the destructor&n; * callback on some processor that does not own the sock_lock.  This&n; * was occuring with PACKET socket applications that were monitoring&n; * our skbs.   We can&squot;t take the sock_lock, because we can&squot;t risk&n; * recursing if we do really own the sock lock.  Instead, do all&n; * of our rwnd manipulation while we own the sock_lock outright.&n; */
)brace
multiline_comment|/* Create a new sctp_ulpevent.  */
DECL|function|sctp_ulpevent_new
r_struct
id|sctp_ulpevent
op_star
id|sctp_ulpevent_new
c_func
(paren
r_int
id|size
comma
r_int
id|msg_flags
comma
r_int
id|gfp
)paren
(brace
r_struct
id|sctp_ulpevent
op_star
id|event
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
id|skb
op_assign
id|alloc_skb
c_func
(paren
id|size
comma
id|gfp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skb
)paren
r_goto
id|fail
suffix:semicolon
id|event
op_assign
id|sctp_skb2event
c_func
(paren
id|skb
)paren
suffix:semicolon
id|sctp_ulpevent_init
c_func
(paren
id|event
comma
id|msg_flags
)paren
suffix:semicolon
r_return
id|event
suffix:semicolon
id|fail
suffix:colon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Initialize an ULP event from an given skb.  */
DECL|function|sctp_ulpevent_init
r_void
id|sctp_ulpevent_init
c_func
(paren
r_struct
id|sctp_ulpevent
op_star
id|event
comma
r_int
id|msg_flags
)paren
(brace
id|memset
c_func
(paren
id|event
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|sctp_ulpevent
)paren
)paren
suffix:semicolon
id|event-&gt;msg_flags
op_assign
id|msg_flags
suffix:semicolon
)brace
multiline_comment|/* Is this a MSG_NOTIFICATION?  */
DECL|function|sctp_ulpevent_is_notification
r_int
id|sctp_ulpevent_is_notification
c_func
(paren
r_const
r_struct
id|sctp_ulpevent
op_star
id|event
)paren
(brace
r_return
id|MSG_NOTIFICATION
op_eq
(paren
id|event-&gt;msg_flags
op_amp
id|MSG_NOTIFICATION
)paren
suffix:semicolon
)brace
multiline_comment|/* Hold the association in case the msg_name needs read out of&n; * the association.&n; */
DECL|function|sctp_ulpevent_set_owner
r_static
r_inline
r_void
id|sctp_ulpevent_set_owner
c_func
(paren
r_struct
id|sctp_ulpevent
op_star
id|event
comma
r_const
r_struct
id|sctp_association
op_star
id|asoc
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
multiline_comment|/* Cast away the const, as we are just wanting to&n;&t; * bump the reference count.&n;&t; */
id|sctp_association_hold
c_func
(paren
(paren
r_struct
id|sctp_association
op_star
)paren
id|asoc
)paren
suffix:semicolon
id|skb
op_assign
id|sctp_event2skb
c_func
(paren
id|event
)paren
suffix:semicolon
id|skb-&gt;sk
op_assign
id|asoc-&gt;base.sk
suffix:semicolon
id|event-&gt;asoc
op_assign
(paren
r_struct
id|sctp_association
op_star
)paren
id|asoc
suffix:semicolon
id|skb-&gt;destructor
op_assign
id|sctp_stub_rfree
suffix:semicolon
)brace
multiline_comment|/* A simple destructor to give up the reference to the association. */
DECL|function|sctp_ulpevent_release_owner
r_static
r_inline
r_void
id|sctp_ulpevent_release_owner
c_func
(paren
r_struct
id|sctp_ulpevent
op_star
id|event
)paren
(brace
id|sctp_association_put
c_func
(paren
id|event-&gt;asoc
)paren
suffix:semicolon
)brace
multiline_comment|/* Create and initialize an SCTP_ASSOC_CHANGE event.&n; *&n; * 5.3.1.1 SCTP_ASSOC_CHANGE&n; *&n; * Communication notifications inform the ULP that an SCTP association&n; * has either begun or ended. The identifier for a new association is&n; * provided by this notification.&n; *&n; * Note: There is no field checking here.  If a field is unused it will be&n; * zero&squot;d out.&n; */
DECL|function|sctp_ulpevent_make_assoc_change
r_struct
id|sctp_ulpevent
op_star
id|sctp_ulpevent_make_assoc_change
c_func
(paren
r_const
r_struct
id|sctp_association
op_star
id|asoc
comma
id|__u16
id|flags
comma
id|__u16
id|state
comma
id|__u16
id|error
comma
id|__u16
id|outbound
comma
id|__u16
id|inbound
comma
r_int
id|gfp
)paren
(brace
r_struct
id|sctp_ulpevent
op_star
id|event
suffix:semicolon
r_struct
id|sctp_assoc_change
op_star
id|sac
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
id|event
op_assign
id|sctp_ulpevent_new
c_func
(paren
r_sizeof
(paren
r_struct
id|sctp_assoc_change
)paren
comma
id|MSG_NOTIFICATION
comma
id|gfp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|event
)paren
r_goto
id|fail
suffix:semicolon
id|skb
op_assign
id|sctp_event2skb
c_func
(paren
id|event
)paren
suffix:semicolon
id|sac
op_assign
(paren
r_struct
id|sctp_assoc_change
op_star
)paren
id|skb_put
c_func
(paren
id|skb
comma
r_sizeof
(paren
r_struct
id|sctp_assoc_change
)paren
)paren
suffix:semicolon
multiline_comment|/* Socket Extensions for SCTP&n;&t; * 5.3.1.1 SCTP_ASSOC_CHANGE&n;&t; *&n;&t; * sac_type:&n;&t; * It should be SCTP_ASSOC_CHANGE.&n;&t; */
id|sac-&gt;sac_type
op_assign
id|SCTP_ASSOC_CHANGE
suffix:semicolon
multiline_comment|/* Socket Extensions for SCTP&n;&t; * 5.3.1.1 SCTP_ASSOC_CHANGE&n;&t; *&n;&t; * sac_state: 32 bits (signed integer)&n;&t; * This field holds one of a number of values that communicate the&n;&t; * event that happened to the association.&n;&t; */
id|sac-&gt;sac_state
op_assign
id|state
suffix:semicolon
multiline_comment|/* Socket Extensions for SCTP&n;&t; * 5.3.1.1 SCTP_ASSOC_CHANGE&n;&t; *&n;&t; * sac_flags: 16 bits (unsigned integer)&n;&t; * Currently unused.&n;&t; */
id|sac-&gt;sac_flags
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Socket Extensions for SCTP&n;&t; * 5.3.1.1 SCTP_ASSOC_CHANGE&n;&t; *&n;&t; * sac_length: sizeof (__u32)&n;&t; * This field is the total length of the notification data, including&n;&t; * the notification header.&n;&t; */
id|sac-&gt;sac_length
op_assign
r_sizeof
(paren
r_struct
id|sctp_assoc_change
)paren
suffix:semicolon
multiline_comment|/* Socket Extensions for SCTP&n;&t; * 5.3.1.1 SCTP_ASSOC_CHANGE&n;&t; *&n;&t; * sac_error:  32 bits (signed integer)&n;&t; *&n;&t; * If the state was reached due to a error condition (e.g.&n;&t; * COMMUNICATION_LOST) any relevant error information is available in&n;&t; * this field. This corresponds to the protocol error codes defined in&n;&t; * [SCTP].&n;&t; */
id|sac-&gt;sac_error
op_assign
id|error
suffix:semicolon
multiline_comment|/* Socket Extensions for SCTP&n;&t; * 5.3.1.1 SCTP_ASSOC_CHANGE&n;&t; *&n;&t; * sac_outbound_streams:  16 bits (unsigned integer)&n;&t; * sac_inbound_streams:  16 bits (unsigned integer)&n;&t; *&n;&t; * The maximum number of streams allowed in each direction are&n;&t; * available in sac_outbound_streams and sac_inbound streams.&n;&t; */
id|sac-&gt;sac_outbound_streams
op_assign
id|outbound
suffix:semicolon
id|sac-&gt;sac_inbound_streams
op_assign
id|inbound
suffix:semicolon
multiline_comment|/* Socket Extensions for SCTP&n;&t; * 5.3.1.1 SCTP_ASSOC_CHANGE&n;&t; *&n;&t; * sac_assoc_id: sizeof (sctp_assoc_t)&n;&t; *&n;&t; * The association id field, holds the identifier for the association.&n;&t; * All notifications for a given association have the same association&n;&t; * identifier.  For TCP style socket, this field is ignored.&n;&t; */
id|sctp_ulpevent_set_owner
c_func
(paren
id|event
comma
id|asoc
)paren
suffix:semicolon
id|sac-&gt;sac_assoc_id
op_assign
id|sctp_assoc2id
c_func
(paren
id|asoc
)paren
suffix:semicolon
r_return
id|event
suffix:semicolon
id|fail
suffix:colon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Create and initialize an SCTP_PEER_ADDR_CHANGE event.&n; *&n; * Socket Extensions for SCTP - draft-01&n; * 5.3.1.2 SCTP_PEER_ADDR_CHANGE&n; *&n; * When a destination address on a multi-homed peer encounters a change&n; * an interface details event is sent.&n; */
DECL|function|sctp_ulpevent_make_peer_addr_change
r_struct
id|sctp_ulpevent
op_star
id|sctp_ulpevent_make_peer_addr_change
c_func
(paren
r_const
r_struct
id|sctp_association
op_star
id|asoc
comma
r_const
r_struct
id|sockaddr_storage
op_star
id|aaddr
comma
r_int
id|flags
comma
r_int
id|state
comma
r_int
id|error
comma
r_int
id|gfp
)paren
(brace
r_struct
id|sctp_ulpevent
op_star
id|event
suffix:semicolon
r_struct
id|sctp_paddr_change
op_star
id|spc
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
id|event
op_assign
id|sctp_ulpevent_new
c_func
(paren
r_sizeof
(paren
r_struct
id|sctp_paddr_change
)paren
comma
id|MSG_NOTIFICATION
comma
id|gfp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|event
)paren
r_goto
id|fail
suffix:semicolon
id|skb
op_assign
id|sctp_event2skb
c_func
(paren
id|event
)paren
suffix:semicolon
id|spc
op_assign
(paren
r_struct
id|sctp_paddr_change
op_star
)paren
id|skb_put
c_func
(paren
id|skb
comma
r_sizeof
(paren
r_struct
id|sctp_paddr_change
)paren
)paren
suffix:semicolon
multiline_comment|/* Sockets API Extensions for SCTP&n;&t; * Section 5.3.1.2 SCTP_PEER_ADDR_CHANGE&n;&t; *&n;&t; * spc_type:&n;&t; *&n;&t; *    It should be SCTP_PEER_ADDR_CHANGE.&n;&t; */
id|spc-&gt;spc_type
op_assign
id|SCTP_PEER_ADDR_CHANGE
suffix:semicolon
multiline_comment|/* Sockets API Extensions for SCTP&n;&t; * Section 5.3.1.2 SCTP_PEER_ADDR_CHANGE&n;&t; *&n;&t; * spc_length: sizeof (__u32)&n;&t; *&n;&t; * This field is the total length of the notification data, including&n;&t; * the notification header.&n;&t; */
id|spc-&gt;spc_length
op_assign
r_sizeof
(paren
r_struct
id|sctp_paddr_change
)paren
suffix:semicolon
multiline_comment|/* Sockets API Extensions for SCTP&n;&t; * Section 5.3.1.2 SCTP_PEER_ADDR_CHANGE&n;&t; *&n;&t; * spc_flags: 16 bits (unsigned integer)&n;&t; * Currently unused.&n;&t; */
id|spc-&gt;spc_flags
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Sockets API Extensions for SCTP&n;&t; * Section 5.3.1.2 SCTP_PEER_ADDR_CHANGE&n;&t; *&n;&t; * spc_state:  32 bits (signed integer)&n;&t; *&n;&t; * This field holds one of a number of values that communicate the&n;&t; * event that happened to the address.&n;&t; */
id|spc-&gt;spc_state
op_assign
id|state
suffix:semicolon
multiline_comment|/* Sockets API Extensions for SCTP&n;&t; * Section 5.3.1.2 SCTP_PEER_ADDR_CHANGE&n;&t; *&n;&t; * spc_error:  32 bits (signed integer)&n;&t; *&n;&t; * If the state was reached due to any error condition (e.g.&n;&t; * ADDRESS_UNREACHABLE) any relevant error information is available in&n;&t; * this field.&n;&t; */
id|spc-&gt;spc_error
op_assign
id|error
suffix:semicolon
multiline_comment|/* Socket Extensions for SCTP&n;&t; * 5.3.1.1 SCTP_ASSOC_CHANGE&n;&t; *&n;&t; * spc_assoc_id: sizeof (sctp_assoc_t)&n;&t; *&n;&t; * The association id field, holds the identifier for the association.&n;&t; * All notifications for a given association have the same association&n;&t; * identifier.  For TCP style socket, this field is ignored.&n;&t; */
id|sctp_ulpevent_set_owner
c_func
(paren
id|event
comma
id|asoc
)paren
suffix:semicolon
id|spc-&gt;spc_assoc_id
op_assign
id|sctp_assoc2id
c_func
(paren
id|asoc
)paren
suffix:semicolon
multiline_comment|/* Sockets API Extensions for SCTP&n;&t; * Section 5.3.1.2 SCTP_PEER_ADDR_CHANGE&n;&t; *&n;&t; * spc_aaddr: sizeof (struct sockaddr_storage)&n;&t; *&n;&t; * The affected address field, holds the remote peer&squot;s address that is&n;&t; * encountering the change of state.&n;&t; */
id|memcpy
c_func
(paren
op_amp
id|spc-&gt;spc_aaddr
comma
id|aaddr
comma
r_sizeof
(paren
r_struct
id|sockaddr_storage
)paren
)paren
suffix:semicolon
multiline_comment|/* Map ipv4 address into v4-mapped-on-v6 address.  */
id|sctp_get_pf_specific
c_func
(paren
id|asoc-&gt;base.sk-&gt;sk_family
)paren
op_member_access_from_pointer
id|addr_v4map
c_func
(paren
id|sctp_sk
c_func
(paren
id|asoc-&gt;base.sk
)paren
comma
(paren
r_union
id|sctp_addr
op_star
)paren
op_amp
id|spc-&gt;spc_aaddr
)paren
suffix:semicolon
r_return
id|event
suffix:semicolon
id|fail
suffix:colon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Create and initialize an SCTP_REMOTE_ERROR notification.&n; *&n; * Note: This assumes that the chunk-&gt;skb-&gt;data already points to the&n; * operation error payload.&n; *&n; * Socket Extensions for SCTP - draft-01&n; * 5.3.1.3 SCTP_REMOTE_ERROR&n; *&n; * A remote peer may send an Operational Error message to its peer.&n; * This message indicates a variety of error conditions on an&n; * association. The entire error TLV as it appears on the wire is&n; * included in a SCTP_REMOTE_ERROR event.  Please refer to the SCTP&n; * specification [SCTP] and any extensions for a list of possible&n; * error formats.&n; */
DECL|function|sctp_ulpevent_make_remote_error
r_struct
id|sctp_ulpevent
op_star
id|sctp_ulpevent_make_remote_error
c_func
(paren
r_const
r_struct
id|sctp_association
op_star
id|asoc
comma
r_struct
id|sctp_chunk
op_star
id|chunk
comma
id|__u16
id|flags
comma
r_int
id|gfp
)paren
(brace
r_struct
id|sctp_ulpevent
op_star
id|event
suffix:semicolon
r_struct
id|sctp_remote_error
op_star
id|sre
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
id|sctp_errhdr_t
op_star
id|ch
suffix:semicolon
id|__u16
id|cause
suffix:semicolon
r_int
id|elen
suffix:semicolon
id|ch
op_assign
(paren
id|sctp_errhdr_t
op_star
)paren
(paren
id|chunk-&gt;skb-&gt;data
)paren
suffix:semicolon
id|cause
op_assign
id|ch-&gt;cause
suffix:semicolon
id|elen
op_assign
id|WORD_ROUND
c_func
(paren
id|ntohs
c_func
(paren
id|ch-&gt;length
)paren
)paren
op_minus
r_sizeof
(paren
id|sctp_errhdr_t
)paren
suffix:semicolon
multiline_comment|/* Pull off the ERROR header.  */
id|skb_pull
c_func
(paren
id|chunk-&gt;skb
comma
r_sizeof
(paren
id|sctp_errhdr_t
)paren
)paren
suffix:semicolon
multiline_comment|/* Copy the skb to a new skb with room for us to prepend&n;&t; * notification with.&n;&t; */
id|skb
op_assign
id|skb_copy_expand
c_func
(paren
id|chunk-&gt;skb
comma
r_sizeof
(paren
r_struct
id|sctp_remote_error
)paren
comma
l_int|0
comma
id|gfp
)paren
suffix:semicolon
multiline_comment|/* Pull off the rest of the cause TLV from the chunk.  */
id|skb_pull
c_func
(paren
id|chunk-&gt;skb
comma
id|elen
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skb
)paren
r_goto
id|fail
suffix:semicolon
multiline_comment|/* Embed the event fields inside the cloned skb.  */
id|event
op_assign
id|sctp_skb2event
c_func
(paren
id|skb
)paren
suffix:semicolon
id|sctp_ulpevent_init
c_func
(paren
id|event
comma
id|MSG_NOTIFICATION
)paren
suffix:semicolon
id|sre
op_assign
(paren
r_struct
id|sctp_remote_error
op_star
)paren
id|skb_push
c_func
(paren
id|skb
comma
r_sizeof
(paren
r_struct
id|sctp_remote_error
)paren
)paren
suffix:semicolon
multiline_comment|/* Trim the buffer to the right length.  */
id|skb_trim
c_func
(paren
id|skb
comma
r_sizeof
(paren
r_struct
id|sctp_remote_error
)paren
op_plus
id|elen
)paren
suffix:semicolon
multiline_comment|/* Socket Extensions for SCTP&n;&t; * 5.3.1.3 SCTP_REMOTE_ERROR&n;&t; *&n;&t; * sre_type:&n;&t; *   It should be SCTP_REMOTE_ERROR.&n;&t; */
id|sre-&gt;sre_type
op_assign
id|SCTP_REMOTE_ERROR
suffix:semicolon
multiline_comment|/*&n;&t; * Socket Extensions for SCTP&n;&t; * 5.3.1.3 SCTP_REMOTE_ERROR&n;&t; *&n;&t; * sre_flags: 16 bits (unsigned integer)&n;&t; *   Currently unused.&n;&t; */
id|sre-&gt;sre_flags
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Socket Extensions for SCTP&n;&t; * 5.3.1.3 SCTP_REMOTE_ERROR&n;&t; *&n;&t; * sre_length: sizeof (__u32)&n;&t; *&n;&t; * This field is the total length of the notification data,&n;&t; * including the notification header.&n;&t; */
id|sre-&gt;sre_length
op_assign
id|skb-&gt;len
suffix:semicolon
multiline_comment|/* Socket Extensions for SCTP&n;&t; * 5.3.1.3 SCTP_REMOTE_ERROR&n;&t; *&n;&t; * sre_error: 16 bits (unsigned integer)&n;&t; * This value represents one of the Operational Error causes defined in&n;&t; * the SCTP specification, in network byte order.&n;&t; */
id|sre-&gt;sre_error
op_assign
id|cause
suffix:semicolon
multiline_comment|/* Socket Extensions for SCTP&n;&t; * 5.3.1.3 SCTP_REMOTE_ERROR&n;&t; *&n;&t; * sre_assoc_id: sizeof (sctp_assoc_t)&n;&t; *&n;&t; * The association id field, holds the identifier for the association.&n;&t; * All notifications for a given association have the same association&n;&t; * identifier.  For TCP style socket, this field is ignored.&n;&t; */
id|sctp_ulpevent_set_owner
c_func
(paren
id|event
comma
id|asoc
)paren
suffix:semicolon
id|sre-&gt;sre_assoc_id
op_assign
id|sctp_assoc2id
c_func
(paren
id|asoc
)paren
suffix:semicolon
r_return
id|event
suffix:semicolon
id|fail
suffix:colon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Create and initialize a SCTP_SEND_FAILED notification.&n; *&n; * Socket Extensions for SCTP - draft-01&n; * 5.3.1.4 SCTP_SEND_FAILED&n; */
DECL|function|sctp_ulpevent_make_send_failed
r_struct
id|sctp_ulpevent
op_star
id|sctp_ulpevent_make_send_failed
c_func
(paren
r_const
r_struct
id|sctp_association
op_star
id|asoc
comma
r_struct
id|sctp_chunk
op_star
id|chunk
comma
id|__u16
id|flags
comma
id|__u32
id|error
comma
r_int
id|gfp
)paren
(brace
r_struct
id|sctp_ulpevent
op_star
id|event
suffix:semicolon
r_struct
id|sctp_send_failed
op_star
id|ssf
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
multiline_comment|/* Pull off any padding. */
r_int
id|len
op_assign
id|ntohs
c_func
(paren
id|chunk-&gt;chunk_hdr-&gt;length
)paren
suffix:semicolon
multiline_comment|/* Make skb with more room so we can prepend notification.  */
id|skb
op_assign
id|skb_copy_expand
c_func
(paren
id|chunk-&gt;skb
comma
r_sizeof
(paren
r_struct
id|sctp_send_failed
)paren
comma
multiline_comment|/* headroom */
l_int|0
comma
multiline_comment|/* tailroom */
id|gfp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skb
)paren
r_goto
id|fail
suffix:semicolon
multiline_comment|/* Pull off the common chunk header and DATA header.  */
id|skb_pull
c_func
(paren
id|skb
comma
r_sizeof
(paren
r_struct
id|sctp_data_chunk
)paren
)paren
suffix:semicolon
id|len
op_sub_assign
r_sizeof
(paren
r_struct
id|sctp_data_chunk
)paren
suffix:semicolon
multiline_comment|/* Embed the event fields inside the cloned skb.  */
id|event
op_assign
id|sctp_skb2event
c_func
(paren
id|skb
)paren
suffix:semicolon
id|sctp_ulpevent_init
c_func
(paren
id|event
comma
id|MSG_NOTIFICATION
)paren
suffix:semicolon
id|ssf
op_assign
(paren
r_struct
id|sctp_send_failed
op_star
)paren
id|skb_push
c_func
(paren
id|skb
comma
r_sizeof
(paren
r_struct
id|sctp_send_failed
)paren
)paren
suffix:semicolon
multiline_comment|/* Socket Extensions for SCTP&n;&t; * 5.3.1.4 SCTP_SEND_FAILED&n;&t; *&n;&t; * ssf_type:&n;&t; * It should be SCTP_SEND_FAILED.&n;&t; */
id|ssf-&gt;ssf_type
op_assign
id|SCTP_SEND_FAILED
suffix:semicolon
multiline_comment|/* Socket Extensions for SCTP&n;&t; * 5.3.1.4 SCTP_SEND_FAILED&n;&t; *&n;&t; * ssf_flags: 16 bits (unsigned integer)&n;&t; * The flag value will take one of the following values&n;&t; *&n;&t; * SCTP_DATA_UNSENT - Indicates that the data was never put on&n;&t; *                    the wire.&n;&t; *&n;&t; * SCTP_DATA_SENT   - Indicates that the data was put on the wire.&n;&t; *                    Note that this does not necessarily mean that the&n;&t; *                    data was (or was not) successfully delivered.&n;&t; */
id|ssf-&gt;ssf_flags
op_assign
id|flags
suffix:semicolon
multiline_comment|/* Socket Extensions for SCTP&n;&t; * 5.3.1.4 SCTP_SEND_FAILED&n;&t; *&n;&t; * ssf_length: sizeof (__u32)&n;&t; * This field is the total length of the notification data, including&n;&t; * the notification header.&n;&t; */
id|ssf-&gt;ssf_length
op_assign
r_sizeof
(paren
r_struct
id|sctp_send_failed
)paren
op_plus
id|len
suffix:semicolon
id|skb_trim
c_func
(paren
id|skb
comma
id|ssf-&gt;ssf_length
)paren
suffix:semicolon
multiline_comment|/* Socket Extensions for SCTP&n;&t; * 5.3.1.4 SCTP_SEND_FAILED&n;&t; *&n;&t; * ssf_error: 16 bits (unsigned integer)&n;&t; * This value represents the reason why the send failed, and if set,&n;&t; * will be a SCTP protocol error code as defined in [SCTP] section&n;&t; * 3.3.10.&n;&t; */
id|ssf-&gt;ssf_error
op_assign
id|error
suffix:semicolon
multiline_comment|/* Socket Extensions for SCTP&n;&t; * 5.3.1.4 SCTP_SEND_FAILED&n;&t; *&n;&t; * ssf_info: sizeof (struct sctp_sndrcvinfo)&n;&t; * The original send information associated with the undelivered&n;&t; * message.&n;&t; */
id|memcpy
c_func
(paren
op_amp
id|ssf-&gt;ssf_info
comma
op_amp
id|chunk-&gt;sinfo
comma
r_sizeof
(paren
r_struct
id|sctp_sndrcvinfo
)paren
)paren
suffix:semicolon
multiline_comment|/* Per TSVWG discussion with Randy. Allow the application to&n;&t; * ressemble a fragmented message.&n;&t; */
id|ssf-&gt;ssf_info.sinfo_flags
op_assign
id|chunk-&gt;chunk_hdr-&gt;flags
suffix:semicolon
multiline_comment|/* Socket Extensions for SCTP&n;&t; * 5.3.1.4 SCTP_SEND_FAILED&n;&t; *&n;&t; * ssf_assoc_id: sizeof (sctp_assoc_t)&n;&t; * The association id field, sf_assoc_id, holds the identifier for the&n;&t; * association.  All notifications for a given association have the&n;&t; * same association identifier.  For TCP style socket, this field is&n;&t; * ignored.&n;&t; */
id|sctp_ulpevent_set_owner
c_func
(paren
id|event
comma
id|asoc
)paren
suffix:semicolon
id|ssf-&gt;ssf_assoc_id
op_assign
id|sctp_assoc2id
c_func
(paren
id|asoc
)paren
suffix:semicolon
r_return
id|event
suffix:semicolon
id|fail
suffix:colon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Create and initialize a SCTP_SHUTDOWN_EVENT notification.&n; *&n; * Socket Extensions for SCTP - draft-01&n; * 5.3.1.5 SCTP_SHUTDOWN_EVENT&n; */
DECL|function|sctp_ulpevent_make_shutdown_event
r_struct
id|sctp_ulpevent
op_star
id|sctp_ulpevent_make_shutdown_event
c_func
(paren
r_const
r_struct
id|sctp_association
op_star
id|asoc
comma
id|__u16
id|flags
comma
r_int
id|gfp
)paren
(brace
r_struct
id|sctp_ulpevent
op_star
id|event
suffix:semicolon
r_struct
id|sctp_shutdown_event
op_star
id|sse
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
id|event
op_assign
id|sctp_ulpevent_new
c_func
(paren
r_sizeof
(paren
r_struct
id|sctp_shutdown_event
)paren
comma
id|MSG_NOTIFICATION
comma
id|gfp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|event
)paren
r_goto
id|fail
suffix:semicolon
id|skb
op_assign
id|sctp_event2skb
c_func
(paren
id|event
)paren
suffix:semicolon
id|sse
op_assign
(paren
r_struct
id|sctp_shutdown_event
op_star
)paren
id|skb_put
c_func
(paren
id|skb
comma
r_sizeof
(paren
r_struct
id|sctp_shutdown_event
)paren
)paren
suffix:semicolon
multiline_comment|/* Socket Extensions for SCTP&n;&t; * 5.3.1.5 SCTP_SHUTDOWN_EVENT&n;&t; *&n;&t; * sse_type&n;&t; * It should be SCTP_SHUTDOWN_EVENT&n;&t; */
id|sse-&gt;sse_type
op_assign
id|SCTP_SHUTDOWN_EVENT
suffix:semicolon
multiline_comment|/* Socket Extensions for SCTP&n;&t; * 5.3.1.5 SCTP_SHUTDOWN_EVENT&n;&t; *&n;&t; * sse_flags: 16 bits (unsigned integer)&n;&t; * Currently unused.&n;&t; */
id|sse-&gt;sse_flags
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Socket Extensions for SCTP&n;&t; * 5.3.1.5 SCTP_SHUTDOWN_EVENT&n;&t; *&n;&t; * sse_length: sizeof (__u32)&n;&t; * This field is the total length of the notification data, including&n;&t; * the notification header.&n;&t; */
id|sse-&gt;sse_length
op_assign
r_sizeof
(paren
r_struct
id|sctp_shutdown_event
)paren
suffix:semicolon
multiline_comment|/* Socket Extensions for SCTP&n;&t; * 5.3.1.5 SCTP_SHUTDOWN_EVENT&n;&t; *&n;&t; * sse_assoc_id: sizeof (sctp_assoc_t)&n;&t; * The association id field, holds the identifier for the association.&n;&t; * All notifications for a given association have the same association&n;&t; * identifier.  For TCP style socket, this field is ignored.&n;&t; */
id|sctp_ulpevent_set_owner
c_func
(paren
id|event
comma
id|asoc
)paren
suffix:semicolon
id|sse-&gt;sse_assoc_id
op_assign
id|sctp_assoc2id
c_func
(paren
id|asoc
)paren
suffix:semicolon
r_return
id|event
suffix:semicolon
id|fail
suffix:colon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Create and initialize a SCTP_ADAPTION_INDICATION notification.&n; *&n; * Socket Extensions for SCTP&n; * 5.3.1.6 SCTP_ADAPTION_INDICATION&n; */
DECL|function|sctp_ulpevent_make_adaption_indication
r_struct
id|sctp_ulpevent
op_star
id|sctp_ulpevent_make_adaption_indication
c_func
(paren
r_const
r_struct
id|sctp_association
op_star
id|asoc
comma
r_int
id|gfp
)paren
(brace
r_struct
id|sctp_ulpevent
op_star
id|event
suffix:semicolon
r_struct
id|sctp_adaption_event
op_star
id|sai
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
id|event
op_assign
id|sctp_ulpevent_new
c_func
(paren
r_sizeof
(paren
r_struct
id|sctp_adaption_event
)paren
comma
id|MSG_NOTIFICATION
comma
id|gfp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|event
)paren
r_goto
id|fail
suffix:semicolon
id|skb
op_assign
id|sctp_event2skb
c_func
(paren
id|event
)paren
suffix:semicolon
id|sai
op_assign
(paren
r_struct
id|sctp_adaption_event
op_star
)paren
id|skb_put
c_func
(paren
id|skb
comma
r_sizeof
(paren
r_struct
id|sctp_adaption_event
)paren
)paren
suffix:semicolon
id|sai-&gt;sai_type
op_assign
id|SCTP_ADAPTION_INDICATION
suffix:semicolon
id|sai-&gt;sai_flags
op_assign
l_int|0
suffix:semicolon
id|sai-&gt;sai_length
op_assign
r_sizeof
(paren
r_struct
id|sctp_adaption_event
)paren
suffix:semicolon
id|sai-&gt;sai_adaption_ind
op_assign
id|asoc-&gt;peer.adaption_ind
suffix:semicolon
id|sctp_ulpevent_set_owner
c_func
(paren
id|event
comma
id|asoc
)paren
suffix:semicolon
id|sai-&gt;sai_assoc_id
op_assign
id|sctp_assoc2id
c_func
(paren
id|asoc
)paren
suffix:semicolon
r_return
id|event
suffix:semicolon
id|fail
suffix:colon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* A message has been received.  Package this message as a notification&n; * to pass it to the upper layers.  Go ahead and calculate the sndrcvinfo&n; * even if filtered out later.&n; *&n; * Socket Extensions for SCTP&n; * 5.2.2 SCTP Header Information Structure (SCTP_SNDRCV)&n; */
DECL|function|sctp_ulpevent_make_rcvmsg
r_struct
id|sctp_ulpevent
op_star
id|sctp_ulpevent_make_rcvmsg
c_func
(paren
r_struct
id|sctp_association
op_star
id|asoc
comma
r_struct
id|sctp_chunk
op_star
id|chunk
comma
r_int
id|gfp
)paren
(brace
r_struct
id|sctp_ulpevent
op_star
id|event
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_int
id|padding
comma
id|len
suffix:semicolon
multiline_comment|/* Clone the original skb, sharing the data.  */
id|skb
op_assign
id|skb_clone
c_func
(paren
id|chunk-&gt;skb
comma
id|gfp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skb
)paren
r_goto
id|fail
suffix:semicolon
multiline_comment|/* First calculate the padding, so we don&squot;t inadvertently&n;&t; * pass up the wrong length to the user.&n;&t; *&n;&t; * RFC 2960 - Section 3.2  Chunk Field Descriptions&n;&t; *&n;&t; * The total length of a chunk(including Type, Length and Value fields)&n;&t; * MUST be a multiple of 4 bytes.  If the length of the chunk is not a&n;&t; * multiple of 4 bytes, the sender MUST pad the chunk with all zero&n;&t; * bytes and this padding is not included in the chunk length field.&n;&t; * The sender should never pad with more than 3 bytes.  The receiver&n;&t; * MUST ignore the padding bytes.&n;&t; */
id|len
op_assign
id|ntohs
c_func
(paren
id|chunk-&gt;chunk_hdr-&gt;length
)paren
suffix:semicolon
id|padding
op_assign
id|WORD_ROUND
c_func
(paren
id|len
)paren
op_minus
id|len
suffix:semicolon
multiline_comment|/* Fixup cloned skb with just this chunks data.  */
id|skb_trim
c_func
(paren
id|skb
comma
id|chunk-&gt;chunk_end
op_minus
id|padding
op_minus
id|skb-&gt;data
)paren
suffix:semicolon
multiline_comment|/* Embed the event fields inside the cloned skb.  */
id|event
op_assign
id|sctp_skb2event
c_func
(paren
id|skb
)paren
suffix:semicolon
multiline_comment|/* Initialize event with flags 0.  */
id|sctp_ulpevent_init
c_func
(paren
id|event
comma
l_int|0
)paren
suffix:semicolon
id|sctp_ulpevent_receive_data
c_func
(paren
id|event
comma
id|asoc
)paren
suffix:semicolon
id|event-&gt;stream
op_assign
id|ntohs
c_func
(paren
id|chunk-&gt;subh.data_hdr-&gt;stream
)paren
suffix:semicolon
id|event-&gt;ssn
op_assign
id|ntohs
c_func
(paren
id|chunk-&gt;subh.data_hdr-&gt;ssn
)paren
suffix:semicolon
id|event-&gt;ppid
op_assign
id|chunk-&gt;subh.data_hdr-&gt;ppid
suffix:semicolon
r_if
c_cond
(paren
id|chunk-&gt;chunk_hdr-&gt;flags
op_amp
id|SCTP_DATA_UNORDERED
)paren
(brace
id|event-&gt;flags
op_or_assign
id|MSG_UNORDERED
suffix:semicolon
id|event-&gt;cumtsn
op_assign
id|sctp_tsnmap_get_ctsn
c_func
(paren
op_amp
id|asoc-&gt;peer.tsn_map
)paren
suffix:semicolon
)brace
id|event-&gt;tsn
op_assign
id|ntohl
c_func
(paren
id|chunk-&gt;subh.data_hdr-&gt;tsn
)paren
suffix:semicolon
id|event-&gt;msg_flags
op_or_assign
id|chunk-&gt;chunk_hdr-&gt;flags
suffix:semicolon
id|event-&gt;iif
op_assign
id|sctp_chunk_iif
c_func
(paren
id|chunk
)paren
suffix:semicolon
id|fail
suffix:colon
r_return
id|event
suffix:semicolon
)brace
multiline_comment|/* Create a partial delivery related event.&n; *&n; * 5.3.1.7 SCTP_PARTIAL_DELIVERY_EVENT&n; *&n; *   When a reciever is engaged in a partial delivery of a&n; *   message this notification will be used to inidicate&n; *   various events.&n; */
DECL|function|sctp_ulpevent_make_pdapi
r_struct
id|sctp_ulpevent
op_star
id|sctp_ulpevent_make_pdapi
c_func
(paren
r_const
r_struct
id|sctp_association
op_star
id|asoc
comma
id|__u32
id|indication
comma
r_int
id|gfp
)paren
(brace
r_struct
id|sctp_ulpevent
op_star
id|event
suffix:semicolon
r_struct
id|sctp_pdapi_event
op_star
id|pd
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
id|event
op_assign
id|sctp_ulpevent_new
c_func
(paren
r_sizeof
(paren
r_struct
id|sctp_pdapi_event
)paren
comma
id|MSG_NOTIFICATION
comma
id|gfp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|event
)paren
r_goto
id|fail
suffix:semicolon
id|skb
op_assign
id|sctp_event2skb
c_func
(paren
id|event
)paren
suffix:semicolon
id|pd
op_assign
(paren
r_struct
id|sctp_pdapi_event
op_star
)paren
id|skb_put
c_func
(paren
id|skb
comma
r_sizeof
(paren
r_struct
id|sctp_pdapi_event
)paren
)paren
suffix:semicolon
multiline_comment|/* pdapi_type&n;&t; *   It should be SCTP_PARTIAL_DELIVERY_EVENT&n;&t; *&n;&t; * pdapi_flags: 16 bits (unsigned integer)&n;&t; *   Currently unused.&n;&t; */
id|pd-&gt;pdapi_type
op_assign
id|SCTP_PARTIAL_DELIVERY_EVENT
suffix:semicolon
id|pd-&gt;pdapi_flags
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* pdapi_length: 32 bits (unsigned integer)&n;&t; *&n;&t; * This field is the total length of the notification data, including&n;&t; * the notification header.  It will generally be sizeof (struct&n;&t; * sctp_pdapi_event).&n;&t; */
id|pd-&gt;pdapi_length
op_assign
r_sizeof
(paren
r_struct
id|sctp_pdapi_event
)paren
suffix:semicolon
multiline_comment|/*  pdapi_indication: 32 bits (unsigned integer)&n;&t; *&n;&t; * This field holds the indication being sent to the application.&n;&t; */
id|pd-&gt;pdapi_indication
op_assign
id|indication
suffix:semicolon
multiline_comment|/*  pdapi_assoc_id: sizeof (sctp_assoc_t)&n;&t; *&n;&t; * The association id field, holds the identifier for the association.&n;&t; */
id|sctp_ulpevent_set_owner
c_func
(paren
id|event
comma
id|asoc
)paren
suffix:semicolon
id|pd-&gt;pdapi_assoc_id
op_assign
id|sctp_assoc2id
c_func
(paren
id|asoc
)paren
suffix:semicolon
r_return
id|event
suffix:semicolon
id|fail
suffix:colon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Return the notification type, assuming this is a notification&n; * event.&n; */
DECL|function|sctp_ulpevent_get_notification_type
id|__u16
id|sctp_ulpevent_get_notification_type
c_func
(paren
r_const
r_struct
id|sctp_ulpevent
op_star
id|event
)paren
(brace
r_union
id|sctp_notification
op_star
id|notification
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
id|skb
op_assign
id|sctp_event2skb
c_func
(paren
(paren
r_struct
id|sctp_ulpevent
op_star
)paren
id|event
)paren
suffix:semicolon
id|notification
op_assign
(paren
r_union
id|sctp_notification
op_star
)paren
id|skb-&gt;data
suffix:semicolon
r_return
id|notification-&gt;sn_header.sn_type
suffix:semicolon
)brace
multiline_comment|/* Copy out the sndrcvinfo into a msghdr.  */
DECL|function|sctp_ulpevent_read_sndrcvinfo
r_void
id|sctp_ulpevent_read_sndrcvinfo
c_func
(paren
r_const
r_struct
id|sctp_ulpevent
op_star
id|event
comma
r_struct
id|msghdr
op_star
id|msghdr
)paren
(brace
r_struct
id|sctp_sndrcvinfo
id|sinfo
suffix:semicolon
r_if
c_cond
(paren
id|sctp_ulpevent_is_notification
c_func
(paren
id|event
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* Sockets API Extensions for SCTP&n; &t; * Section 5.2.2 SCTP Header Information Structure (SCTP_SNDRCV)&n; &t; *&n; &t; * sinfo_stream: 16 bits (unsigned integer)&n; &t; *&n; &t; * For recvmsg() the SCTP stack places the message&squot;s stream number in&n; &t; * this value.&n; &t;*/
id|sinfo.sinfo_stream
op_assign
id|event-&gt;stream
suffix:semicolon
multiline_comment|/* sinfo_ssn: 16 bits (unsigned integer)&n;&t; *&n;&t; * For recvmsg() this value contains the stream sequence number that&n;&t; * the remote endpoint placed in the DATA chunk.  For fragmented&n;&t; * messages this is the same number for all deliveries of the message&n;&t; * (if more than one recvmsg() is needed to read the message).&n;&t; */
id|sinfo.sinfo_ssn
op_assign
id|event-&gt;ssn
suffix:semicolon
multiline_comment|/* sinfo_ppid: 32 bits (unsigned integer)&n;&t; *&n;&t; * In recvmsg() this value is&n;&t; * the same information that was passed by the upper layer in the peer&n;&t; * application.  Please note that byte order issues are NOT accounted&n;&t; * for and this information is passed opaquely by the SCTP stack from&n;&t; * one end to the other.&n;&t; */
id|sinfo.sinfo_ppid
op_assign
id|event-&gt;ppid
suffix:semicolon
multiline_comment|/* sinfo_flags: 16 bits (unsigned integer)&n;&t; *&n;&t; * This field may contain any of the following flags and is composed of&n;&t; * a bitwise OR of these values.&n;&t; *&n;&t; * recvmsg() flags:&n;&t; *&n;&t; * MSG_UNORDERED - This flag is present when the message was sent&n;&t; *                 non-ordered.&n;&t; */
id|sinfo.sinfo_flags
op_assign
id|event-&gt;flags
suffix:semicolon
multiline_comment|/* sinfo_tsn: 32 bit (unsigned integer)&n;&t; *&n;&t; * For the receiving side, this field holds a TSN that was &n;&t; * assigned to one of the SCTP Data Chunks.&n;&t; */
id|sinfo.sinfo_tsn
op_assign
id|event-&gt;tsn
suffix:semicolon
multiline_comment|/* sinfo_cumtsn: 32 bit (unsigned integer)&n;&t; *&n;&t; * This field will hold the current cumulative TSN as&n;&t; * known by the underlying SCTP layer.  Note this field is&n;&t; * ignored when sending and only valid for a receive&n;&t; * operation when sinfo_flags are set to MSG_UNORDERED.&n;&t; */
id|sinfo.sinfo_cumtsn
op_assign
id|event-&gt;cumtsn
suffix:semicolon
multiline_comment|/* sinfo_assoc_id: sizeof (sctp_assoc_t)&n;&t; *&n;&t; * The association handle field, sinfo_assoc_id, holds the identifier&n;&t; * for the association announced in the COMMUNICATION_UP notification.&n;&t; * All notifications for a given association have the same identifier.&n;&t; * Ignored for one-to-one style sockets.&n;&t; */
id|sinfo.sinfo_assoc_id
op_assign
id|sctp_assoc2id
c_func
(paren
id|event-&gt;asoc
)paren
suffix:semicolon
multiline_comment|/* These fields are not used while receiving. */
id|sinfo.sinfo_context
op_assign
l_int|0
suffix:semicolon
id|sinfo.sinfo_timetolive
op_assign
l_int|0
suffix:semicolon
id|put_cmsg
c_func
(paren
id|msghdr
comma
id|IPPROTO_SCTP
comma
id|SCTP_SNDRCV
comma
r_sizeof
(paren
r_struct
id|sctp_sndrcvinfo
)paren
comma
(paren
r_void
op_star
)paren
op_amp
id|sinfo
)paren
suffix:semicolon
)brace
multiline_comment|/* Do accounting for bytes received and hold a reference to the association&n; * for each skb.&n; */
DECL|function|sctp_ulpevent_receive_data
r_static
r_void
id|sctp_ulpevent_receive_data
c_func
(paren
r_struct
id|sctp_ulpevent
op_star
id|event
comma
r_struct
id|sctp_association
op_star
id|asoc
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
comma
op_star
id|frag
suffix:semicolon
id|skb
op_assign
id|sctp_event2skb
c_func
(paren
id|event
)paren
suffix:semicolon
multiline_comment|/* Set the owner and charge rwnd for bytes received.  */
id|sctp_ulpevent_set_owner
c_func
(paren
id|event
comma
id|asoc
)paren
suffix:semicolon
id|sctp_assoc_rwnd_decrease
c_func
(paren
id|asoc
comma
id|skb_headlen
c_func
(paren
id|skb
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skb-&gt;data_len
)paren
r_return
suffix:semicolon
multiline_comment|/* Note:  Not clearing the entire event struct as this is just a&n;&t; * fragment of the real event.  However, we still need to do rwnd&n;&t; * accounting.&n;&t; * In general, the skb passed from IP can have only 1 level of&n;&t; * fragments. But we allow multiple levels of fragments. &n;&t; */
r_for
c_loop
(paren
id|frag
op_assign
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|frag_list
suffix:semicolon
id|frag
suffix:semicolon
id|frag
op_assign
id|frag-&gt;next
)paren
(brace
id|sctp_ulpevent_receive_data
c_func
(paren
id|sctp_skb2event
c_func
(paren
id|frag
)paren
comma
id|asoc
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Do accounting for bytes just read by user and release the references to&n; * the association.&n; */
DECL|function|sctp_ulpevent_release_data
r_static
r_void
id|sctp_ulpevent_release_data
c_func
(paren
r_struct
id|sctp_ulpevent
op_star
id|event
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
comma
op_star
id|frag
suffix:semicolon
multiline_comment|/* Current stack structures assume that the rcv buffer is&n;&t; * per socket.   For UDP style sockets this is not true as&n;&t; * multiple associations may be on a single UDP-style socket.&n;&t; * Use the local private area of the skb to track the owning&n;&t; * association.&n;&t; */
id|skb
op_assign
id|sctp_event2skb
c_func
(paren
id|event
)paren
suffix:semicolon
id|sctp_assoc_rwnd_increase
c_func
(paren
id|event-&gt;asoc
comma
id|skb_headlen
c_func
(paren
id|skb
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skb-&gt;data_len
)paren
r_goto
id|done
suffix:semicolon
multiline_comment|/* Don&squot;t forget the fragments. */
r_for
c_loop
(paren
id|frag
op_assign
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|frag_list
suffix:semicolon
id|frag
suffix:semicolon
id|frag
op_assign
id|frag-&gt;next
)paren
(brace
multiline_comment|/* NOTE:  skb_shinfos are recursive. Although IP returns&n;&t;&t; * skb&squot;s with only 1 level of fragments, SCTP reassembly can&n;&t;&t; * increase the levels.&n;&t;&t; */
id|sctp_ulpevent_release_data
c_func
(paren
id|sctp_skb2event
c_func
(paren
id|frag
)paren
)paren
suffix:semicolon
)brace
id|done
suffix:colon
id|sctp_ulpevent_release_owner
c_func
(paren
id|event
)paren
suffix:semicolon
)brace
multiline_comment|/* Free a ulpevent that has an owner.  It includes releasing the reference&n; * to the owner, updating the rwnd in case of a DATA event and freeing the&n; * skb.&n; * See comments in sctp_stub_rfree().&n; */
DECL|function|sctp_ulpevent_free
r_void
id|sctp_ulpevent_free
c_func
(paren
r_struct
id|sctp_ulpevent
op_star
id|event
)paren
(brace
r_if
c_cond
(paren
id|sctp_ulpevent_is_notification
c_func
(paren
id|event
)paren
)paren
id|sctp_ulpevent_release_owner
c_func
(paren
id|event
)paren
suffix:semicolon
r_else
id|sctp_ulpevent_release_data
c_func
(paren
id|event
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|sctp_event2skb
c_func
(paren
id|event
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Purge the skb lists holding ulpevents. */
DECL|function|sctp_queue_purge_ulpevents
r_void
id|sctp_queue_purge_ulpevents
c_func
(paren
r_struct
id|sk_buff_head
op_star
id|list
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_while
c_loop
(paren
(paren
id|skb
op_assign
id|skb_dequeue
c_func
(paren
id|list
)paren
)paren
op_ne
l_int|NULL
)paren
id|sctp_ulpevent_free
c_func
(paren
id|sctp_skb2event
c_func
(paren
id|skb
)paren
)paren
suffix:semicolon
)brace
eof
