multiline_comment|/* SCTP kernel reference Implementation&n; * Copyright (c) 1999-2000 Cisco, Inc.&n; * Copyright (c) 1999-2001 Motorola, Inc.&n; * Copyright (c) 2001 Intel Corp.&n; * Copyright (c) 2001-2002 International Business Machines Corp.&n; * &n; * This file is part of the SCTP kernel reference Implementation&n; * &n; * $Header: /cvsroot/lksctp/lksctp/sctp_cvs/net/sctp/sctp_outqueue.c,v 1.35 2002/08/05 02:58:05 jgrimm Exp $&n; * &n; * These functions implement the outqueue class.   The outqueue handles&n; * bundling and queueing of outgoing SCTP chunks.  &n; * &n; * The SCTP reference implementation is free software; &n; * you can redistribute it and/or modify it under the terms of &n; * the GNU General Public License as published by&n; * the Free Software Foundation; either version 2, or (at your option)&n; * any later version.&n; * &n; * The SCTP reference implementation is distributed in the hope that it &n; * will be useful, but WITHOUT ANY WARRANTY; without even the implied&n; *                 ************************&n; * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&n; * See the GNU General Public License for more details.&n; * &n; * You should have received a copy of the GNU General Public License&n; * along with GNU CC; see the file COPYING.  If not, write to&n; * the Free Software Foundation, 59 Temple Place - Suite 330,&n; * Boston, MA 02111-1307, USA.  &n; * &n; * Please send any bug reports or fixes you make to the&n; * email address(es):&n; *    lksctp developers &lt;lksctp-developers@lists.sourceforge.net&gt;&n; * &n; * Or submit a bug report through the following website:&n; *    http://www.sf.net/projects/lksctp&n; *&n; * Written or modified by: &n; *    La Monte H.P. Yarroll &lt;piggy@acm.org&gt;&n; *    Karl Knutson          &lt;karl@athena.chicago.il.us&gt; &n; *    Perry Melange         &lt;pmelange@null.cc.uic.edu&gt;&n; *    Xingang Guo           &lt;xingang.guo@intel.com&gt;&n; *    Hui Huang &t;    &lt;hui.huang@nokia.com&gt;&n; *    Sridhar Samudrala     &lt;sri@us.ibm.com&gt;&n; *    Jon Grimm             &lt;jgrimm@us.ibm.com&gt;&n; *&t;&n; * Any bugs reported given to us we will try to fix... any fixes shared will&n; * be incorporated into the next SCTP release.&n; */
DECL|variable|cvs_id
r_static
r_char
op_star
id|cvs_id
id|__attribute__
(paren
(paren
id|unused
)paren
)paren
op_assign
l_string|&quot;$Id: sctp_outqueue.c,v 1.35 2002/08/05 02:58:05 jgrimm Exp $&quot;
suffix:semicolon
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/list.h&gt; /* For struct list_head */
macro_line|#include &lt;linux/socket.h&gt;
macro_line|#include &lt;linux/ip.h&gt;
macro_line|#include &lt;net/sock.h&gt;&t;&t;/* For skb_set_owner_w */
macro_line|#include &lt;net/sctp/sctp.h&gt;
multiline_comment|/* Declare internal functions here.  */
r_static
r_int
id|sctp_acked
c_func
(paren
id|sctp_sackhdr_t
op_star
id|sack
comma
r_uint32
id|tsn
)paren
suffix:semicolon
r_static
r_void
id|sctp_check_transmitted
c_func
(paren
id|sctp_outqueue_t
op_star
id|q
comma
r_struct
id|list_head
op_star
id|transmitted_queue
comma
id|sctp_transport_t
op_star
id|transport
comma
id|sctp_sackhdr_t
op_star
id|sack
)paren
suffix:semicolon
multiline_comment|/* Generate a new outqueue.  */
id|sctp_outqueue_t
op_star
DECL|function|sctp_outqueue_new
id|sctp_outqueue_new
c_func
(paren
id|sctp_association_t
op_star
id|asoc
)paren
(brace
id|sctp_outqueue_t
op_star
id|q
suffix:semicolon
id|q
op_assign
id|t_new
c_func
(paren
id|sctp_outqueue_t
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|q
)paren
(brace
id|sctp_outqueue_init
c_func
(paren
id|asoc
comma
id|q
)paren
suffix:semicolon
id|q-&gt;malloced
op_assign
l_int|1
suffix:semicolon
)brace
r_return
id|q
suffix:semicolon
)brace
multiline_comment|/* sctp_outqueue_new() */
multiline_comment|/* Initialize an existing SCTP_outqueue.  This does the boring stuff.&n; * You still need to define handlers if you really want to DO&n; * something with this structure...&n; */
r_void
DECL|function|sctp_outqueue_init
id|sctp_outqueue_init
c_func
(paren
id|sctp_association_t
op_star
id|asoc
comma
id|sctp_outqueue_t
op_star
id|q
)paren
(brace
id|q-&gt;asoc
op_assign
id|asoc
suffix:semicolon
id|skb_queue_head_init
c_func
(paren
op_amp
id|q-&gt;out
)paren
suffix:semicolon
id|skb_queue_head_init
c_func
(paren
op_amp
id|q-&gt;control
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|q-&gt;retransmit
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|q-&gt;sacked
)paren
suffix:semicolon
id|q-&gt;init_output
op_assign
l_int|NULL
suffix:semicolon
id|q-&gt;config_output
op_assign
l_int|NULL
suffix:semicolon
id|q-&gt;append_output
op_assign
l_int|NULL
suffix:semicolon
id|q-&gt;build_output
op_assign
l_int|NULL
suffix:semicolon
id|q-&gt;force_output
op_assign
l_int|NULL
suffix:semicolon
id|q-&gt;outstanding_bytes
op_assign
l_int|0
suffix:semicolon
id|q-&gt;empty
op_assign
l_int|1
suffix:semicolon
id|q-&gt;malloced
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* sctp_outqueue_init() */
multiline_comment|/* Free the outqueue structure and any related pending chunks. &n; * FIXME: Add SEND_FAILED support.  &n; */
r_void
DECL|function|sctp_outqueue_teardown
id|sctp_outqueue_teardown
c_func
(paren
id|sctp_outqueue_t
op_star
id|q
)paren
(brace
id|sctp_transport_t
op_star
id|transport
suffix:semicolon
id|list_t
op_star
id|lchunk
comma
op_star
id|pos
suffix:semicolon
id|sctp_chunk_t
op_star
id|chunk
suffix:semicolon
multiline_comment|/* Throw away unacknowledged chunks. */
id|list_for_each
c_func
(paren
id|pos
comma
op_amp
id|q-&gt;asoc-&gt;peer.transport_addr_list
)paren
(brace
id|transport
op_assign
id|list_entry
c_func
(paren
id|pos
comma
id|sctp_transport_t
comma
id|transports
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|lchunk
op_assign
id|sctp_list_dequeue
c_func
(paren
op_amp
id|transport-&gt;transmitted
)paren
)paren
)paren
(brace
id|chunk
op_assign
id|list_entry
c_func
(paren
id|lchunk
comma
id|sctp_chunk_t
comma
id|transmitted_list
)paren
suffix:semicolon
id|sctp_free_chunk
c_func
(paren
id|chunk
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* For all transports. */
multiline_comment|/* Throw away any leftover chunks. */
r_while
c_loop
(paren
(paren
id|chunk
op_assign
(paren
id|sctp_chunk_t
op_star
)paren
id|skb_dequeue
c_func
(paren
op_amp
id|q-&gt;out
)paren
)paren
)paren
(brace
id|sctp_free_chunk
c_func
(paren
id|chunk
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* sctp_outqueue_teardown() */
multiline_comment|/* Free the outqueue structure and any related pending chunks. */
r_void
DECL|function|sctp_outqueue_free
id|sctp_outqueue_free
c_func
(paren
id|sctp_outqueue_t
op_star
id|q
)paren
(brace
multiline_comment|/* Throw away leftover chunks. */
id|sctp_outqueue_teardown
c_func
(paren
id|q
)paren
suffix:semicolon
multiline_comment|/* If we were kmalloc()&squot;d, free the memory.  */
r_if
c_cond
(paren
id|q-&gt;malloced
)paren
(brace
id|kfree
c_func
(paren
id|q
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* sctp_outqueue_free() */
multiline_comment|/* Transmit any pending partial chunks.  */
r_void
DECL|function|sctp_force_outqueue
id|sctp_force_outqueue
c_func
(paren
id|sctp_outqueue_t
op_star
id|q
)paren
(brace
multiline_comment|/* Do we really need this? */
multiline_comment|/* BUG */
)brace
multiline_comment|/* sctp_force_outqueue() */
multiline_comment|/* Put a new chunk in an SCTP_outqueue. */
r_int
DECL|function|sctp_push_outqueue
id|sctp_push_outqueue
c_func
(paren
id|sctp_outqueue_t
op_star
id|q
comma
id|sctp_chunk_t
op_star
id|chunk
)paren
(brace
r_int
id|error
op_assign
l_int|0
suffix:semicolon
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;sctp_push_outqueue(%p, %p[%s])&bslash;n&quot;
comma
id|q
comma
id|chunk
comma
id|chunk
op_logical_and
id|chunk-&gt;chunk_hdr
ques
c_cond
id|sctp_cname
c_func
(paren
id|SCTP_ST_CHUNK
c_func
(paren
id|chunk-&gt;chunk_hdr-&gt;type
)paren
)paren
suffix:colon
l_string|&quot;Illegal Chunk&quot;
)paren
suffix:semicolon
multiline_comment|/* If it is data, queue it up, otherwise, send it&n;         * immediately.&n;         */
r_if
c_cond
(paren
id|SCTP_CID_DATA
op_eq
id|chunk-&gt;chunk_hdr-&gt;type
)paren
(brace
multiline_comment|/* Is it OK to queue data chunks?  */
multiline_comment|/* From 9. Termination of Association&n;                 * &n;                 * When either endpoint performs a shutdown, the&n;                 * association on each peer will stop accepting new&n;                 * data from its user and only deliver data in queue&n;                 * at the time of sending or receiving the SHUTDOWN&n;                 * chunk.&n;                 */
r_switch
c_cond
(paren
id|q-&gt;asoc-&gt;state
)paren
(brace
r_case
id|SCTP_STATE_EMPTY
suffix:colon
r_case
id|SCTP_STATE_CLOSED
suffix:colon
r_case
id|SCTP_STATE_SHUTDOWN_PENDING
suffix:colon
r_case
id|SCTP_STATE_SHUTDOWN_SENT
suffix:colon
r_case
id|SCTP_STATE_SHUTDOWN_RECEIVED
suffix:colon
r_case
id|SCTP_STATE_SHUTDOWN_ACK_SENT
suffix:colon
multiline_comment|/* Cannot send after transport endpoint shutdown */
id|error
op_assign
op_minus
id|ESHUTDOWN
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;outqueueing (%p, %p[%s])&bslash;n&quot;
comma
id|q
comma
id|chunk
comma
id|chunk
op_logical_and
id|chunk-&gt;chunk_hdr
ques
c_cond
id|sctp_cname
c_func
(paren
id|SCTP_ST_CHUNK
c_func
(paren
id|chunk-&gt;chunk_hdr-&gt;type
)paren
)paren
suffix:colon
l_string|&quot;Illegal Chunk&quot;
)paren
suffix:semicolon
id|skb_queue_tail
c_func
(paren
op_amp
id|q-&gt;out
comma
(paren
r_struct
id|sk_buff
op_star
)paren
id|chunk
)paren
suffix:semicolon
id|q-&gt;empty
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* switch() (case It is OK to queue data chunks) */
)brace
r_else
(brace
id|skb_queue_tail
c_func
(paren
op_amp
id|q-&gt;control
comma
(paren
r_struct
id|sk_buff
op_star
)paren
id|chunk
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|error
OL
l_int|0
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
id|error
op_assign
id|sctp_flush_outqueue
c_func
(paren
id|q
comma
l_int|0
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/* sctp_push_outqueue() */
multiline_comment|/* Mark all the eligible packets on a transport for retransmission and force &n; * one packet out.&n; */
r_void
DECL|function|sctp_retransmit
id|sctp_retransmit
c_func
(paren
id|sctp_outqueue_t
op_star
id|q
comma
id|sctp_transport_t
op_star
id|transport
comma
r_uint8
id|fast_retransmit
)paren
(brace
r_struct
id|list_head
op_star
id|lchunk
suffix:semicolon
id|sctp_chunk_t
op_star
id|chunk
suffix:semicolon
r_int
id|error
op_assign
l_int|0
suffix:semicolon
r_struct
id|list_head
id|tlist
suffix:semicolon
r_if
c_cond
(paren
id|fast_retransmit
)paren
(brace
id|sctp_transport_lower_cwnd
c_func
(paren
id|transport
comma
id|SCTP_LOWER_CWND_FAST_RTX
)paren
suffix:semicolon
)brace
r_else
(brace
id|sctp_transport_lower_cwnd
c_func
(paren
id|transport
comma
id|SCTP_LOWER_CWND_T3_RTX
)paren
suffix:semicolon
)brace
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|tlist
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|transport-&gt;transmitted
)paren
)paren
(brace
id|lchunk
op_assign
id|sctp_list_dequeue
c_func
(paren
op_amp
id|transport-&gt;transmitted
)paren
suffix:semicolon
id|chunk
op_assign
id|list_entry
c_func
(paren
id|lchunk
comma
id|sctp_chunk_t
comma
id|transmitted_list
)paren
suffix:semicolon
multiline_comment|/* If we are doing retransmission due to a fast retransmit, &n;&t;&t; * only the chunk&squot;s that are marked for fast retransmit &n;&t;&t; * should be added to the retransmit queue.  If we are doing &n;&t;&t; * retransmission due to a timeout, only the chunks that are &n;&t;&t; * not yet acked should be added to the retransmit queue.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|fast_retransmit
op_logical_and
op_logical_neg
id|chunk-&gt;fast_retransmit
)paren
op_logical_or
(paren
op_logical_neg
id|fast_retransmit
op_logical_and
id|chunk-&gt;tsn_gap_acked
)paren
)paren
(brace
id|list_add_tail
c_func
(paren
id|lchunk
comma
op_amp
id|tlist
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* RFC 2960 6.2.1 Processing a Received SACK&n;&t;&t; &t; *&n;&t;&t; &t; * C) Any time a DATA chunk is marked for &n;&t;&t; &t; * retransmission (via either T3-rtx timer expiration &n;&t;&t; &t; * (Section 6.3.3) or via fast retransmit&n;&t;&t; &t; * (Section 7.2.4)), add the data size of those &n;&t;&t; &t; * chunks to the rwnd.&n;&t;&t; &t; */
id|q-&gt;asoc-&gt;peer.rwnd
op_add_assign
id|sctp_data_size
c_func
(paren
id|chunk
)paren
suffix:semicolon
id|q-&gt;outstanding_bytes
op_sub_assign
id|sctp_data_size
c_func
(paren
id|chunk
)paren
suffix:semicolon
id|transport-&gt;flight_size
op_sub_assign
id|sctp_data_size
c_func
(paren
id|chunk
)paren
suffix:semicolon
multiline_comment|/* sctpimpguide-05 Section 2.8.2 &n;&t;&t;&t; * M5) If a T3-rtx timer expires, the &n;&t;&t;&t; * &squot;TSN.Missing.Report&squot; of all affected TSNs is set &n;&t;&t;&t; * to 0.&n;&t;&t;&t; */
id|chunk-&gt;tsn_missing_report
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* If a chunk that is being used for RTT measurement&n;&t;&t;&t; * has to be retransmitted, we cannot use this chunk&n;&t;&t;&t; * anymore for RTT measurements. Reset rto_pending so &n;&t;&t;&t; * that a new RTT measurement is started when a new &n;&t;&t;&t; * data chunk is sent.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|chunk-&gt;rtt_in_progress
)paren
(brace
id|chunk-&gt;rtt_in_progress
op_assign
l_int|0
suffix:semicolon
id|transport-&gt;rto_pending
op_assign
l_int|0
suffix:semicolon
)brace
id|list_add_tail
c_func
(paren
id|lchunk
comma
op_amp
id|q-&gt;retransmit
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* while (we have stuff left on transport-&gt;transmitted) */
multiline_comment|/* Reconstruct the transmitted queue with chunks that are not &n;&t; * eligible for retransmission. &n;&t; */
r_while
c_loop
(paren
l_int|NULL
op_ne
(paren
id|lchunk
op_assign
id|sctp_list_dequeue
c_func
(paren
op_amp
id|tlist
)paren
)paren
)paren
(brace
id|list_add_tail
c_func
(paren
id|lchunk
comma
op_amp
id|transport-&gt;transmitted
)paren
suffix:semicolon
)brace
id|SCTP_DEBUG_PRINTK
c_func
(paren
id|__FUNCTION__
l_string|&quot;: transport: %p, fast_retransmit: %d, &quot;
l_string|&quot;cwnd: %d, ssthresh: %d, flight_size: %d, &quot;
l_string|&quot;pba: %d&bslash;n&quot;
comma
id|transport
comma
id|fast_retransmit
comma
id|transport-&gt;cwnd
comma
id|transport-&gt;ssthresh
comma
id|transport-&gt;flight_size
comma
id|transport-&gt;partial_bytes_acked
)paren
suffix:semicolon
id|error
op_assign
id|sctp_flush_outqueue
c_func
(paren
id|q
comma
multiline_comment|/* rtx_timeout */
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|q-&gt;asoc-&gt;base.sk-&gt;err
op_assign
op_minus
id|error
suffix:semicolon
)brace
)brace
multiline_comment|/* sctp_retransmit() */
multiline_comment|/* &n; * Transmit DATA chunks on the retransmit queue.  Upon return from&n; * sctp_flush_retran_queue() the packet &squot;pkt&squot; may contain chunks which&n; * need to be transmitted by the caller.&n; * We assume that pkt-&gt;transport has already been set.&n; *&n; * The return value is a normal kernel error return value.&n; */
r_static
r_int
DECL|function|sctp_flush_retran_queue
id|sctp_flush_retran_queue
c_func
(paren
id|sctp_outqueue_t
op_star
id|q
comma
id|sctp_packet_t
op_star
id|pkt
comma
r_int
id|rtx_timeout
comma
r_int
op_star
id|start_timer
)paren
(brace
r_struct
id|list_head
op_star
id|lqueue
suffix:semicolon
r_struct
id|list_head
op_star
id|lchunk
suffix:semicolon
id|sctp_transport_t
op_star
id|transport
op_assign
id|pkt-&gt;transport
suffix:semicolon
id|sctp_xmit_t
id|status
suffix:semicolon
id|sctp_chunk_t
op_star
id|chunk
suffix:semicolon
id|sctp_association_t
op_star
id|asoc
suffix:semicolon
r_int
id|error
op_assign
l_int|0
suffix:semicolon
id|asoc
op_assign
id|q-&gt;asoc
suffix:semicolon
id|lqueue
op_assign
op_amp
id|q-&gt;retransmit
suffix:semicolon
multiline_comment|/* RFC 2960 6.3.3 Handle T3-rtx Expiration&n;&t; *&n;&t; * E3) Determine how many of the earliest (i.e., lowest TSN)&n;&t; * outstanding DATA chunks for the address for which the&n;&t; * T3-rtx has expired will fit into a single packet, subject&n;&t; * to the MTU constraint for the path corresponding to the&n;&t; * destination transport address to which the retransmission&n;&t; * is being sent (this may be different from the address for&n;&t; * which the timer expires [see Section 6.4]). Call this value&n;&t; * K. Bundle and retransmit those K DATA chunks in a single&n;&t; * packet to the destination endpoint.&n;&t; *&n;&t; * [Just to be painfully clear, if we are retransmitting&n;&t; * because a timeout just happened, we should send only ONE&n;&t; * packet of retransmitted data.]&n;&t; */
id|lchunk
op_assign
id|sctp_list_dequeue
c_func
(paren
id|lqueue
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|NULL
op_ne
id|lchunk
)paren
(brace
id|chunk
op_assign
id|list_entry
c_func
(paren
id|lchunk
comma
id|sctp_chunk_t
comma
id|transmitted_list
)paren
suffix:semicolon
macro_line|#if 0
multiline_comment|/* If a chunk has been tried for more than SCTP_DEF_MAX_SEND&n;&t;&t; * times, discard it, and check the empty flag of the outqueue.&n;&t;&t; *&n;&t;&t; *&t;&t;--xguo&n;&t;&t; */
r_if
c_cond
(paren
id|chunk-&gt;snd_count
OG
id|SCTP_DEF_MAX_SEND
)paren
(brace
id|sctp_free_chunk
c_func
(paren
id|chunk
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* Attempt to append this chunk to the packet. */
id|status
op_assign
(paren
op_star
id|q-&gt;append_output
)paren
(paren
id|pkt
comma
id|chunk
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|status
)paren
(brace
r_case
id|SCTP_XMIT_PMTU_FULL
suffix:colon
multiline_comment|/* Send this packet. */
r_if
c_cond
(paren
(paren
id|error
op_assign
(paren
op_star
id|q-&gt;force_output
)paren
(paren
id|pkt
)paren
)paren
op_eq
l_int|0
)paren
(brace
op_star
id|start_timer
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* If we are retransmitting, we should only&n;&t;&t;&t; * send a single packet.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|rtx_timeout
)paren
(brace
id|list_add
c_func
(paren
id|lchunk
comma
id|lqueue
)paren
suffix:semicolon
id|lchunk
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Bundle lchunk in the next round.  */
r_break
suffix:semicolon
r_case
id|SCTP_XMIT_RWND_FULL
suffix:colon
multiline_comment|/* Send this packet. */
r_if
c_cond
(paren
(paren
id|error
op_assign
(paren
op_star
id|q-&gt;force_output
)paren
(paren
id|pkt
)paren
)paren
op_eq
l_int|0
)paren
(brace
op_star
id|start_timer
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Stop sending DATA as there is no more room&n;&t;&t;&t; * at the reciever.&n;&t;&t;&t; */
id|list_add
c_func
(paren
id|lchunk
comma
id|lqueue
)paren
suffix:semicolon
id|lchunk
op_assign
l_int|NULL
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* The append was successful, so add this chunk to&n;&t;&t;&t; * the transmitted list.&n;&t;&t;&t; */
id|list_add_tail
c_func
(paren
id|lchunk
comma
op_amp
id|transport-&gt;transmitted
)paren
suffix:semicolon
op_star
id|start_timer
op_assign
l_int|1
suffix:semicolon
id|q-&gt;empty
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Retrieve a new chunk to bundle. */
id|lchunk
op_assign
id|sctp_list_dequeue
c_func
(paren
id|lqueue
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* while (more retransmit chunks) */
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/* sctp_flush_retran_queue() */
multiline_comment|/* This routine either transmits the fragment or puts it on the output &n; * queue.  &squot;pos&squot; points to the next chunk in the output queue after the&n; * chunk that is currently in the process of fragmentation.&n; */
r_void
DECL|function|sctp_xmit_frag
id|sctp_xmit_frag
c_func
(paren
id|sctp_outqueue_t
op_star
id|q
comma
r_struct
id|sk_buff
op_star
id|pos
comma
id|sctp_packet_t
op_star
id|packet
comma
id|sctp_chunk_t
op_star
id|frag
comma
r_uint32
id|tsn
)paren
(brace
id|sctp_transport_t
op_star
id|transport
op_assign
id|packet-&gt;transport
suffix:semicolon
r_struct
id|sk_buff_head
op_star
id|queue
op_assign
op_amp
id|q-&gt;out
suffix:semicolon
id|sctp_xmit_t
id|status
suffix:semicolon
r_int
id|error
suffix:semicolon
id|frag-&gt;subh.data_hdr-&gt;tsn
op_assign
id|htonl
c_func
(paren
id|tsn
)paren
suffix:semicolon
id|frag-&gt;has_tsn
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* An inner fragment may be smaller than the earlier one and may get &n;&t; * in if we call q-&gt;build_output.  This ensures that all the fragments &n;&t; * are sent in order. &n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|skb_queue_empty
c_func
(paren
id|queue
)paren
)paren
(brace
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;sctp_xmit_frag: q not empty. &quot;
l_string|&quot;adding 0x%x to outqueue&bslash;n&quot;
comma
id|ntohl
c_func
(paren
id|frag-&gt;subh.data_hdr-&gt;tsn
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pos
)paren
(brace
id|skb_insert
c_func
(paren
id|pos
comma
(paren
r_struct
id|sk_buff
op_star
)paren
id|frag
)paren
suffix:semicolon
)brace
r_else
(brace
id|skb_queue_tail
c_func
(paren
id|queue
comma
(paren
r_struct
id|sk_buff
op_star
)paren
id|frag
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/* Add the chunk fragment to the packet.  */
id|status
op_assign
(paren
op_star
id|q-&gt;build_output
)paren
(paren
id|packet
comma
id|frag
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|status
)paren
(brace
r_case
id|SCTP_XMIT_RWND_FULL
suffix:colon
multiline_comment|/* RWND is full, so put the chunk in the output queue. */
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;sctp_xmit_frag: rwnd full. &quot;
l_string|&quot;adding 0x%x to outqueue&bslash;n&quot;
comma
id|ntohl
c_func
(paren
id|frag-&gt;subh.data_hdr-&gt;tsn
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pos
)paren
(brace
id|skb_insert
c_func
(paren
id|pos
comma
(paren
r_struct
id|sk_buff
op_star
)paren
id|frag
)paren
suffix:semicolon
)brace
r_else
(brace
id|skb_queue_tail
c_func
(paren
id|queue
comma
(paren
r_struct
id|sk_buff
op_star
)paren
id|frag
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|SCTP_XMIT_OK
suffix:colon
id|error
op_assign
(paren
op_star
id|q-&gt;force_output
)paren
(paren
id|packet
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
OL
l_int|0
)paren
(brace
multiline_comment|/* Packet could not be transmitted, put the chunk in &n;&t;&t;&t; * the output queue &n;&t;&t;&t; */
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;sctp_xmit_frag: force output &quot;
l_string|&quot;failed. adding 0x%x to outqueue&bslash;n&quot;
comma
id|ntohl
c_func
(paren
id|frag-&gt;subh.data_hdr-&gt;tsn
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pos
)paren
(brace
id|skb_insert
c_func
(paren
id|pos
comma
(paren
r_struct
id|sk_buff
op_star
)paren
id|frag
)paren
suffix:semicolon
)brace
r_else
(brace
id|skb_queue_tail
c_func
(paren
id|queue
comma
(paren
r_struct
id|sk_buff
op_star
)paren
id|frag
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;sctp_xmit_frag: force output &quot;
l_string|&quot;success. 0x%x sent&bslash;n&quot;
comma
id|ntohl
c_func
(paren
id|frag-&gt;subh.data_hdr-&gt;tsn
)paren
)paren
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|frag-&gt;transmitted_list
comma
op_amp
id|transport-&gt;transmitted
)paren
suffix:semicolon
id|sctp_transport_reset_timers
c_func
(paren
id|transport
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* sctp_xmit_frag() */
multiline_comment|/* This routine calls sctp_xmit_frag() for all the fragments of a message. &n; * The argument &squot;frag&squot; point to the first fragment and it holds the list &n; * of all the other fragments in the &squot;frag_list&squot; field.&n; */
r_void
DECL|function|sctp_xmit_fragmented_chunks
id|sctp_xmit_fragmented_chunks
c_func
(paren
id|sctp_outqueue_t
op_star
id|q
comma
id|sctp_packet_t
op_star
id|packet
comma
id|sctp_chunk_t
op_star
id|frag
)paren
(brace
id|sctp_association_t
op_star
id|asoc
op_assign
id|frag-&gt;asoc
suffix:semicolon
r_struct
id|list_head
op_star
id|lfrag
comma
op_star
id|frag_list
suffix:semicolon
r_uint32
id|tsn
suffix:semicolon
r_int
id|nfrags
op_assign
l_int|1
suffix:semicolon
r_struct
id|sk_buff
op_star
id|pos
suffix:semicolon
multiline_comment|/* Count the number of fragments. */
id|frag_list
op_assign
op_amp
id|frag-&gt;frag_list
suffix:semicolon
id|list_for_each
c_func
(paren
id|lfrag
comma
id|frag_list
)paren
(brace
id|nfrags
op_increment
suffix:semicolon
)brace
multiline_comment|/* Get a TSN block of nfrags TSNs. */
id|tsn
op_assign
id|__sctp_association_get_tsn_block
c_func
(paren
id|asoc
comma
id|nfrags
)paren
suffix:semicolon
id|pos
op_assign
id|skb_peek
c_func
(paren
op_amp
id|q-&gt;out
)paren
suffix:semicolon
multiline_comment|/* Transmit the first fragment. */
id|sctp_xmit_frag
c_func
(paren
id|q
comma
id|pos
comma
id|packet
comma
id|frag
comma
id|tsn
op_increment
)paren
suffix:semicolon
multiline_comment|/* Transmit the rest of fragments. */
id|frag_list
op_assign
op_amp
id|frag-&gt;frag_list
suffix:semicolon
id|list_for_each
c_func
(paren
id|lfrag
comma
id|frag_list
)paren
(brace
id|frag
op_assign
id|list_entry
c_func
(paren
id|lfrag
comma
id|sctp_chunk_t
comma
id|frag_list
)paren
suffix:semicolon
id|sctp_xmit_frag
c_func
(paren
id|q
comma
id|pos
comma
id|packet
comma
id|frag
comma
id|tsn
op_increment
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* sctp_xmit_fragmented_chunks() */
multiline_comment|/* This routine breaks the given chunk into &squot;max_frag_data_len&squot; size &n; * fragments.  It returns the first fragment with the frag_list field holding &n; * the remaining fragments. &n; */
id|sctp_chunk_t
op_star
DECL|function|sctp_fragment_chunk
id|sctp_fragment_chunk
c_func
(paren
id|sctp_chunk_t
op_star
id|chunk
comma
r_int
id|max_frag_data_len
)paren
(brace
id|sctp_association_t
op_star
id|asoc
op_assign
id|chunk-&gt;asoc
suffix:semicolon
r_void
op_star
id|data_ptr
op_assign
id|chunk-&gt;subh.data_hdr
suffix:semicolon
r_struct
id|sctp_sndrcvinfo
op_star
id|sinfo
op_assign
op_amp
id|chunk-&gt;sinfo
suffix:semicolon
r_uint16
id|chunk_data_len
op_assign
id|sctp_data_size
c_func
(paren
id|chunk
)paren
suffix:semicolon
r_uint16
id|ssn
op_assign
id|ntohs
c_func
(paren
id|chunk-&gt;subh.data_hdr-&gt;ssn
)paren
suffix:semicolon
id|sctp_chunk_t
op_star
id|first_frag
comma
op_star
id|frag
suffix:semicolon
r_struct
id|list_head
op_star
id|frag_list
suffix:semicolon
r_int
id|nfrags
suffix:semicolon
multiline_comment|/* nfrags = no. of max size fragments + any smaller last fragment. */
id|nfrags
op_assign
(paren
(paren
id|chunk_data_len
op_div
id|max_frag_data_len
)paren
op_plus
(paren
(paren
id|chunk_data_len
op_mod
id|max_frag_data_len
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
)paren
)paren
suffix:semicolon
multiline_comment|/* Start of the data in the chunk. */
id|data_ptr
op_add_assign
r_sizeof
(paren
id|sctp_datahdr_t
)paren
suffix:semicolon
multiline_comment|/* Make the first fragment. */
id|first_frag
op_assign
id|sctp_make_datafrag
c_func
(paren
id|asoc
comma
id|sinfo
comma
id|max_frag_data_len
comma
id|data_ptr
comma
id|SCTP_DATA_FIRST_FRAG
comma
id|ssn
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|first_frag
)paren
(brace
r_goto
id|err
suffix:semicolon
)brace
multiline_comment|/* All the fragments are added to the frag_list of the first chunk. */
id|frag_list
op_assign
op_amp
id|first_frag-&gt;frag_list
suffix:semicolon
id|chunk_data_len
op_sub_assign
id|max_frag_data_len
suffix:semicolon
id|data_ptr
op_add_assign
id|max_frag_data_len
suffix:semicolon
multiline_comment|/* Make the middle fragments. */
r_while
c_loop
(paren
id|chunk_data_len
OG
id|max_frag_data_len
)paren
(brace
id|frag
op_assign
id|sctp_make_datafrag
c_func
(paren
id|asoc
comma
id|sinfo
comma
id|max_frag_data_len
comma
id|data_ptr
comma
id|SCTP_DATA_MIDDLE_FRAG
comma
id|ssn
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|frag
)paren
(brace
r_goto
id|err
suffix:semicolon
)brace
multiline_comment|/* Add the middle fragment to the first fragment&squot;s frag_list.*/
id|list_add_tail
c_func
(paren
op_amp
id|frag-&gt;frag_list
comma
id|frag_list
)paren
suffix:semicolon
id|chunk_data_len
op_sub_assign
id|max_frag_data_len
suffix:semicolon
id|data_ptr
op_add_assign
id|max_frag_data_len
suffix:semicolon
)brace
multiline_comment|/* Make the last fragment. */
id|frag
op_assign
id|sctp_make_datafrag
c_func
(paren
id|asoc
comma
id|sinfo
comma
id|chunk_data_len
comma
id|data_ptr
comma
id|SCTP_DATA_LAST_FRAG
comma
id|ssn
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|frag
)paren
(brace
r_goto
id|err
suffix:semicolon
)brace
multiline_comment|/* Add the last fragment to the first fragment&squot;s frag_list. */
id|list_add_tail
c_func
(paren
op_amp
id|frag-&gt;frag_list
comma
id|frag_list
)paren
suffix:semicolon
multiline_comment|/* Free the original chunk. */
id|sctp_free_chunk
c_func
(paren
id|chunk
)paren
suffix:semicolon
r_return
(paren
id|first_frag
)paren
suffix:semicolon
id|err
suffix:colon
multiline_comment|/* Free any fragments that are created before the failure. */
r_if
c_cond
(paren
id|first_frag
)paren
(brace
r_struct
id|list_head
op_star
id|flist
comma
op_star
id|lfrag
suffix:semicolon
multiline_comment|/* Free all the fragments off the first one. */
id|flist
op_assign
op_amp
id|first_frag-&gt;frag_list
suffix:semicolon
r_while
c_loop
(paren
l_int|NULL
op_ne
(paren
id|lfrag
op_assign
id|sctp_list_dequeue
c_func
(paren
id|flist
)paren
)paren
)paren
(brace
id|frag
op_assign
id|list_entry
c_func
(paren
id|lfrag
comma
id|sctp_chunk_t
comma
id|frag_list
)paren
suffix:semicolon
id|sctp_free_chunk
c_func
(paren
id|frag
)paren
suffix:semicolon
)brace
multiline_comment|/* Free the first fragment. */
id|sctp_free_chunk
c_func
(paren
id|first_frag
)paren
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* sctp_fragment_chunk() */
multiline_comment|/*&n; * sctp_flush_outqueue - Try to flush an outqueue.&n; * &n; * Description: Send everything in q which we legally can, subject to&n; * congestion limitations.&n; * &n; * Note: This function can be called from multiple contexts so appropriate&n; * locking concerns must be made.  Today we use the sock lock to protect&n; * this function.  &n; */
r_int
DECL|function|sctp_flush_outqueue
id|sctp_flush_outqueue
c_func
(paren
id|sctp_outqueue_t
op_star
id|q
comma
r_int
id|rtx_timeout
)paren
(brace
id|sctp_packet_t
op_star
id|packet
suffix:semicolon
id|sctp_packet_t
id|singleton
suffix:semicolon
id|sctp_association_t
op_star
id|asoc
op_assign
id|q-&gt;asoc
suffix:semicolon
r_int
id|ecn_capable
op_assign
id|asoc-&gt;peer.ecn_capable
suffix:semicolon
r_uint16
id|sport
op_assign
id|asoc-&gt;base.bind_addr.port
suffix:semicolon
r_uint16
id|dport
op_assign
id|asoc-&gt;peer.port
suffix:semicolon
r_uint32
id|vtag
op_assign
id|asoc-&gt;peer.i.init_tag
suffix:semicolon
multiline_comment|/* This is the ECNE handler for singleton packets.  */
id|sctp_packet_phandler_t
op_star
id|s_ecne_handler
op_assign
l_int|NULL
suffix:semicolon
id|sctp_packet_phandler_t
op_star
id|ecne_handler
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|sk_buff_head
op_star
id|queue
suffix:semicolon
id|sctp_transport_t
op_star
id|transport
op_assign
l_int|NULL
suffix:semicolon
id|sctp_transport_t
op_star
id|new_transport
suffix:semicolon
id|sctp_chunk_t
op_star
id|chunk
suffix:semicolon
id|sctp_xmit_t
id|status
suffix:semicolon
r_int
id|error
op_assign
l_int|0
suffix:semicolon
r_int
id|start_timer
op_assign
l_int|0
suffix:semicolon
id|sctp_ulpevent_t
op_star
id|event
suffix:semicolon
multiline_comment|/* These transports have chunks to send. */
r_struct
id|list_head
id|transport_list
suffix:semicolon
r_struct
id|list_head
op_star
id|ltransport
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|transport_list
)paren
suffix:semicolon
id|packet
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * 6.10 Bundling&n;&t; *   ...&n;&t; *   When bundling control chunks with DATA chunks, an&n;&t; *   endpoint MUST place control chunks first in the outbound&n;&t; *   SCTP packet.  The transmitter MUST transmit DATA chunks&n;&t; *   within a SCTP packet in increasing order of TSN.&n;&t; *   ...&n;&t; */
r_if
c_cond
(paren
id|ecn_capable
)paren
(brace
id|s_ecne_handler
op_assign
op_amp
id|sctp_get_no_prepend
suffix:semicolon
id|ecne_handler
op_assign
op_amp
id|sctp_get_ecne_prepend
suffix:semicolon
)brace
id|queue
op_assign
op_amp
id|q-&gt;control
suffix:semicolon
r_while
c_loop
(paren
l_int|NULL
op_ne
(paren
id|chunk
op_assign
(paren
id|sctp_chunk_t
op_star
)paren
id|skb_dequeue
c_func
(paren
id|queue
)paren
)paren
)paren
(brace
multiline_comment|/* Pick the right transport to use. */
id|new_transport
op_assign
id|chunk-&gt;transport
suffix:semicolon
r_if
c_cond
(paren
id|new_transport
op_eq
l_int|NULL
)paren
(brace
id|new_transport
op_assign
id|asoc-&gt;peer.active_path
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|new_transport-&gt;state.active
)paren
(brace
multiline_comment|/* If the chunk is Heartbeat, send it to&n;&t;&t;&t; * chunk-&gt;transport, even it&squot;s inactive.&n;&t;&t; &t; */
r_if
c_cond
(paren
id|chunk-&gt;chunk_hdr-&gt;type
op_ne
id|SCTP_CID_HEARTBEAT
)paren
(brace
id|new_transport
op_assign
id|asoc-&gt;peer.active_path
suffix:semicolon
)brace
)brace
multiline_comment|/* Are we switching transports?&n;&t;&t; * Take care of transport locks.&n;&t;&t; */
r_if
c_cond
(paren
id|new_transport
op_ne
id|transport
)paren
(brace
id|transport
op_assign
id|new_transport
suffix:semicolon
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|transport-&gt;send_ready
)paren
)paren
(brace
id|list_add_tail
c_func
(paren
op_amp
id|transport-&gt;send_ready
comma
op_amp
id|transport_list
)paren
suffix:semicolon
)brace
id|packet
op_assign
op_amp
id|transport-&gt;packet
suffix:semicolon
(paren
op_star
id|q-&gt;config_output
)paren
(paren
id|packet
comma
id|vtag
comma
id|ecn_capable
comma
id|ecne_handler
)paren
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|chunk-&gt;chunk_hdr-&gt;type
)paren
(brace
multiline_comment|/*&n;&t;&t; * 6.10 Bundling&n;&t;&t; *   ...&n;&t;&t; *   An endpoint MUST NOT bundle INIT, INIT ACK or SHUTDOWN&n;&t;&t; *   COMPLETE with any other chunks.  [Send them immediately.]&n;&t;&t; */
r_case
id|SCTP_CID_INIT
suffix:colon
r_case
id|SCTP_CID_INIT_ACK
suffix:colon
r_case
id|SCTP_CID_SHUTDOWN_COMPLETE
suffix:colon
(paren
op_star
id|q-&gt;init_output
)paren
(paren
op_amp
id|singleton
comma
id|transport
comma
id|sport
comma
id|dport
)paren
suffix:semicolon
(paren
op_star
id|q-&gt;config_output
)paren
(paren
op_amp
id|singleton
comma
id|vtag
comma
id|ecn_capable
comma
id|s_ecne_handler
)paren
suffix:semicolon
(paren
r_void
)paren
(paren
op_star
id|q-&gt;build_output
)paren
(paren
op_amp
id|singleton
comma
id|chunk
)paren
suffix:semicolon
id|error
op_assign
(paren
op_star
id|q-&gt;force_output
)paren
(paren
op_amp
id|singleton
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
OL
l_int|0
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|SCTP_CID_ABORT
suffix:colon
r_case
id|SCTP_CID_SACK
suffix:colon
r_case
id|SCTP_CID_HEARTBEAT
suffix:colon
r_case
id|SCTP_CID_HEARTBEAT_ACK
suffix:colon
r_case
id|SCTP_CID_SHUTDOWN
suffix:colon
r_case
id|SCTP_CID_SHUTDOWN_ACK
suffix:colon
r_case
id|SCTP_CID_ERROR
suffix:colon
r_case
id|SCTP_CID_COOKIE_ECHO
suffix:colon
r_case
id|SCTP_CID_COOKIE_ACK
suffix:colon
r_case
id|SCTP_CID_ECN_ECNE
suffix:colon
r_case
id|SCTP_CID_ECN_CWR
suffix:colon
(paren
r_void
)paren
(paren
op_star
id|q-&gt;build_output
)paren
(paren
id|packet
comma
id|chunk
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_CID_ASCONF
suffix:colon
r_case
id|SCTP_CID_ASCONF_ACK
suffix:colon
(paren
r_void
)paren
(paren
op_star
id|q-&gt;build_output
)paren
(paren
id|packet
comma
id|chunk
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* We built a chunk with an illegal type! */
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* switch(type) */
)brace
multiline_comment|/* while (more chunks in control queue) */
multiline_comment|/* Is it OK to send data chunks?  */
r_switch
c_cond
(paren
id|asoc-&gt;state
)paren
(brace
r_case
id|SCTP_STATE_COOKIE_ECHOED
suffix:colon
multiline_comment|/* Only allow bundling, if this packet has a COOKIE-ECHO&n;&t;&t; * chunk.&n;&t;&t; */
r_if
c_cond
(paren
id|packet
op_logical_and
op_logical_neg
id|packet-&gt;has_cookie_echo
)paren
(brace
r_break
suffix:semicolon
)brace
r_case
id|SCTP_STATE_ESTABLISHED
suffix:colon
r_case
id|SCTP_STATE_SHUTDOWN_PENDING
suffix:colon
r_case
id|SCTP_STATE_SHUTDOWN_RECEIVED
suffix:colon
multiline_comment|/*&n;&t;&t; * RFC 2960 6.1  Transmission of DATA Chunks&n;&t;&t; *&n;&t;&t; * C) When the time comes for the sender to transmit,&n;&t;&t; * before sending new DATA chunks, the sender MUST&n;&t;&t; * first transmit any outstanding DATA chunks which&n;&t;&t; * are marked for retransmission (limited by the&n;&t;&t; * current cwnd).&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|q-&gt;retransmit
)paren
)paren
(brace
r_if
c_cond
(paren
id|transport
op_eq
id|asoc-&gt;peer.retran_path
)paren
(brace
r_goto
id|retran
suffix:semicolon
)brace
multiline_comment|/* Switch transports &amp; prepare the packet.  */
id|transport
op_assign
id|asoc-&gt;peer.retran_path
suffix:semicolon
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|transport-&gt;send_ready
)paren
)paren
(brace
id|list_add_tail
c_func
(paren
op_amp
id|transport-&gt;send_ready
comma
op_amp
id|transport_list
)paren
suffix:semicolon
)brace
id|packet
op_assign
op_amp
id|transport-&gt;packet
suffix:semicolon
(paren
op_star
id|q-&gt;config_output
)paren
(paren
id|packet
comma
id|vtag
comma
id|ecn_capable
comma
id|ecne_handler
)paren
suffix:semicolon
id|retran
suffix:colon
id|error
op_assign
id|sctp_flush_retran_queue
c_func
(paren
id|q
comma
id|packet
comma
id|rtx_timeout
comma
op_amp
id|start_timer
)paren
suffix:semicolon
r_if
c_cond
(paren
id|start_timer
)paren
(brace
id|sctp_transport_reset_timers
c_func
(paren
id|transport
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* if (we have chunks for retransmission) */
multiline_comment|/* Finally, transmit new packets.  */
id|start_timer
op_assign
l_int|0
suffix:semicolon
id|queue
op_assign
op_amp
id|q-&gt;out
suffix:semicolon
r_while
c_loop
(paren
l_int|NULL
op_ne
(paren
id|chunk
op_assign
(paren
id|sctp_chunk_t
op_star
)paren
id|skb_dequeue
c_func
(paren
id|queue
)paren
)paren
)paren
(brace
multiline_comment|/* RFC 2960 6.5 Every DATA chunk MUST carry a valid&n;&t;&t;&t; * stream identifier. &n;&t;&t;&t; */
r_if
c_cond
(paren
id|chunk-&gt;sinfo.sinfo_stream
op_ge
id|asoc-&gt;c.sinit_num_ostreams
)paren
(brace
multiline_comment|/* Generate a SEND FAILED event. */
id|event
op_assign
id|sctp_ulpevent_make_send_failed
c_func
(paren
id|asoc
comma
id|chunk
comma
id|SCTP_DATA_UNSENT
comma
id|SCTP_ERROR_INV_STRM
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|event
)paren
(brace
id|sctp_ulpqueue_tail_event
c_func
(paren
op_amp
id|asoc-&gt;ulpq
comma
id|event
)paren
suffix:semicolon
)brace
multiline_comment|/* Free the chunk. This chunk is not on any &n;&t;&t;&t;&t; * list yet, just free it. */
id|sctp_free_chunk
c_func
(paren
id|chunk
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* If there is a specified transport, use it.&n;&t;&t;&t; * Otherwise, we want to use the active path.&n;&t;&t;&t; */
id|new_transport
op_assign
id|chunk-&gt;transport
suffix:semicolon
r_if
c_cond
(paren
id|new_transport
op_eq
l_int|NULL
op_logical_or
op_logical_neg
id|new_transport-&gt;state.active
)paren
(brace
id|new_transport
op_assign
id|asoc-&gt;peer.active_path
suffix:semicolon
)brace
multiline_comment|/* Change packets if necessary.  */
r_if
c_cond
(paren
id|new_transport
op_ne
id|transport
)paren
(brace
id|transport
op_assign
id|new_transport
suffix:semicolon
multiline_comment|/* Schedule to have this transport&squot;s&n;&t;&t;&t;&t; * packet flushed.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|transport-&gt;send_ready
)paren
)paren
(brace
id|list_add_tail
c_func
(paren
op_amp
id|transport-&gt;send_ready
comma
op_amp
id|transport_list
)paren
suffix:semicolon
)brace
id|packet
op_assign
op_amp
id|transport-&gt;packet
suffix:semicolon
(paren
op_star
id|q-&gt;config_output
)paren
(paren
id|packet
comma
id|vtag
comma
id|ecn_capable
comma
id|ecne_handler
)paren
suffix:semicolon
)brace
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;sctp_transmit_packet(%p, %p[%s]), &quot;
comma
id|q
comma
id|chunk
comma
id|chunk
op_logical_and
id|chunk-&gt;chunk_hdr
ques
c_cond
id|sctp_cname
c_func
(paren
id|SCTP_ST_CHUNK
c_func
(paren
id|chunk-&gt;chunk_hdr-&gt;type
)paren
)paren
suffix:colon
l_string|&quot;Illegal Chunk&quot;
)paren
suffix:semicolon
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;TX TSN 0x%x skb-&gt;head &quot;
l_string|&quot;%p skb-&gt;users %d.&bslash;n&quot;
comma
id|ntohl
c_func
(paren
id|chunk-&gt;subh.data_hdr-&gt;tsn
)paren
comma
id|chunk-&gt;skb
ques
c_cond
id|chunk-&gt;skb-&gt;head
suffix:colon
l_int|0
comma
id|chunk-&gt;skb
ques
c_cond
(paren
r_int
)paren
id|atomic_read
c_func
(paren
op_amp
id|chunk-&gt;skb-&gt;users
)paren
suffix:colon
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Add the chunk to the packet.  */
id|status
op_assign
(paren
op_star
id|q-&gt;build_output
)paren
(paren
id|packet
comma
id|chunk
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|status
)paren
(brace
r_case
id|SCTP_XMIT_PMTU_FULL
suffix:colon
r_case
id|SCTP_XMIT_RWND_FULL
suffix:colon
multiline_comment|/* We could not append this chunk, so put&n;&t;&t;&t;&t; * the chunk back on the output queue.&n;&t;&t;&t;&t; */
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;sctp_flush_outqueue: could&quot;
l_string|&quot;not transmit TSN: 0x%x, status: %d&bslash;n&quot;
comma
id|ntohl
c_func
(paren
id|chunk-&gt;subh.data_hdr-&gt;tsn
)paren
comma
id|status
)paren
suffix:semicolon
id|skb_queue_head
c_func
(paren
id|queue
comma
(paren
r_struct
id|sk_buff
op_star
)paren
id|chunk
)paren
suffix:semicolon
r_goto
id|sctp_flush_out
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCTP_XMIT_MUST_FRAG
suffix:colon
(brace
id|sctp_chunk_t
op_star
id|frag
suffix:semicolon
id|frag
op_assign
id|sctp_fragment_chunk
c_func
(paren
id|chunk
comma
id|packet-&gt;transport-&gt;asoc-&gt;frag_point
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|frag
)paren
(brace
multiline_comment|/* We could not fragment due to out of&n;&t;&t;&t;&t;&t; * memory condition. Free the original &n;&t;&t;&t;&t;&t; * chunk and return ENOMEM. &n;&t;&t;&t;&t;&t; */
id|sctp_free_chunk
c_func
(paren
id|chunk
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_return
(paren
id|error
)paren
suffix:semicolon
)brace
id|sctp_xmit_fragmented_chunks
c_func
(paren
id|q
comma
id|packet
comma
id|frag
)paren
suffix:semicolon
r_goto
id|sctp_flush_out
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|SCTP_XMIT_OK
suffix:colon
r_break
suffix:semicolon
r_default
suffix:colon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* BUG: We assume that the (*q-&gt;force_output())&n;&t;&t;&t; * call below will succeed all the time and add the &n;&t;&t;&t; * chunk to the transmitted list and restart the &n;&t;&t;&t; * timers. &n;&t;&t;&t; * It is possible that the call can fail under OOM &n;&t;&t;&t; * conditions.&n;&t;&t;&t; *&n;&t;&t;&t; * Is this really a problem?  Won&squot;t this behave&n;&t;&t;&t; * like a lost TSN?&n;&t;&t;&t; */
id|list_add_tail
c_func
(paren
op_amp
id|chunk-&gt;transmitted_list
comma
op_amp
id|transport-&gt;transmitted
)paren
suffix:semicolon
id|sctp_transport_reset_timers
c_func
(paren
id|transport
)paren
suffix:semicolon
id|q-&gt;empty
op_assign
l_int|0
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* Do nothing.  */
r_break
suffix:semicolon
)brace
multiline_comment|/* switch ()(case It is OK to send data chunks:) */
id|sctp_flush_out
suffix:colon
multiline_comment|/* Before returning, examine all the transports touched in&n;&t; * this call.  Right now, we bluntly force clear all the&n;&t; * transports.  Things might change after we implement Nagle.&n;&t; * But such an examination is still required.&n;&t; * &n;&t; * --xguo&n;&t; */
r_while
c_loop
(paren
(paren
id|ltransport
op_assign
id|sctp_list_dequeue
c_func
(paren
op_amp
id|transport_list
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|sctp_transport_t
op_star
id|t
op_assign
id|list_entry
c_func
(paren
id|ltransport
comma
id|sctp_transport_t
comma
id|send_ready
)paren
suffix:semicolon
r_if
c_cond
(paren
id|t
op_ne
id|transport
)paren
(brace
id|transport
op_assign
id|t
suffix:semicolon
)brace
id|packet
op_assign
op_amp
id|transport-&gt;packet
suffix:semicolon
r_if
c_cond
(paren
id|packet-&gt;size
op_ne
id|SCTP_IP_OVERHEAD
)paren
(brace
id|error
op_assign
(paren
op_star
id|q-&gt;force_output
)paren
(paren
id|packet
)paren
suffix:semicolon
)brace
)brace
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/* sctp_flush_outqueue() */
multiline_comment|/* Set the various output handling callbacks. */
r_int
DECL|function|sctp_outqueue_set_output_handlers
id|sctp_outqueue_set_output_handlers
c_func
(paren
id|sctp_outqueue_t
op_star
id|q
comma
id|sctp_outqueue_ohandler_init_t
id|init
comma
id|sctp_outqueue_ohandler_config_t
id|config
comma
id|sctp_outqueue_ohandler_t
id|append
comma
id|sctp_outqueue_ohandler_t
id|build
comma
id|sctp_outqueue_ohandler_force_t
id|force
)paren
(brace
id|q-&gt;init_output
op_assign
id|init
suffix:semicolon
id|q-&gt;config_output
op_assign
id|config
suffix:semicolon
id|q-&gt;append_output
op_assign
id|append
suffix:semicolon
id|q-&gt;build_output
op_assign
id|build
suffix:semicolon
id|q-&gt;force_output
op_assign
id|force
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* sctp_outqueue_set_out_handler() */
multiline_comment|/* Update unack_data based on the incoming SACK chunk */
r_static
r_void
DECL|function|sctp_sack_update_unack_data
id|sctp_sack_update_unack_data
c_func
(paren
id|sctp_association_t
op_star
id|assoc
comma
id|sctp_sackhdr_t
op_star
id|sack
)paren
(brace
id|sctp_sack_variable_t
op_star
id|frags
suffix:semicolon
r_uint16
id|unack_data
suffix:semicolon
r_int
id|i
suffix:semicolon
id|unack_data
op_assign
id|assoc-&gt;next_tsn
op_minus
id|assoc-&gt;ctsn_ack_point
op_minus
l_int|1
suffix:semicolon
id|frags
op_assign
id|sack-&gt;variable
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ntohs
c_func
(paren
id|sack-&gt;num_gap_ack_blocks
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|unack_data
op_sub_assign
(paren
(paren
id|ntohs
c_func
(paren
id|frags
(braket
id|i
)braket
dot
id|gab.end
)paren
op_minus
id|ntohs
c_func
(paren
id|frags
(braket
id|i
)braket
dot
id|gab.start
)paren
op_plus
l_int|1
)paren
)paren
suffix:semicolon
)brace
id|assoc-&gt;unack_data
op_assign
id|unack_data
suffix:semicolon
)brace
multiline_comment|/* This is where we REALLY process a SACK.&n; *&n; * Process the sack against the outqueue.  Mostly, this just frees&n; * things off the transmitted queue.&n; */
r_int
DECL|function|sctp_sack_outqueue
id|sctp_sack_outqueue
c_func
(paren
id|sctp_outqueue_t
op_star
id|q
comma
id|sctp_sackhdr_t
op_star
id|sack
)paren
(brace
id|sctp_chunk_t
op_star
id|tchunk
suffix:semicolon
id|list_t
op_star
id|lchunk
comma
op_star
id|transport_list
comma
op_star
id|pos
suffix:semicolon
r_uint32
id|tsn
suffix:semicolon
r_uint32
id|sack_ctsn
suffix:semicolon
r_uint32
id|ctsn
suffix:semicolon
id|sctp_transport_t
op_star
id|transport
suffix:semicolon
r_int
id|outstanding
suffix:semicolon
r_uint32
id|sack_a_rwnd
suffix:semicolon
multiline_comment|/* Grab the association&squot;s destination address list. */
id|transport_list
op_assign
op_amp
id|q-&gt;asoc-&gt;peer.transport_addr_list
suffix:semicolon
multiline_comment|/* Run through the retransmit queue.  Credit bytes received&n;&t; * and free those chunks that we can. &n;&t; */
id|sctp_check_transmitted
c_func
(paren
id|q
comma
op_amp
id|q-&gt;retransmit
comma
l_int|NULL
comma
id|sack
)paren
suffix:semicolon
multiline_comment|/* Run through the transmitted queue.&n;         * Credit bytes received and free those chunks which we can.&n;         *&n;         * This is a MASSIVE candidate for optimization.&n;         */
id|list_for_each
c_func
(paren
id|pos
comma
id|transport_list
)paren
(brace
id|transport
op_assign
id|list_entry
c_func
(paren
id|pos
comma
id|sctp_transport_t
comma
id|transports
)paren
suffix:semicolon
id|sctp_check_transmitted
c_func
(paren
id|q
comma
op_amp
id|transport-&gt;transmitted
comma
id|transport
comma
id|sack
)paren
suffix:semicolon
)brace
multiline_comment|/* Move the Cumulative TSN Ack Point if appropriate.  */
id|sack_ctsn
op_assign
id|ntohl
c_func
(paren
id|sack-&gt;cum_tsn_ack
)paren
suffix:semicolon
r_if
c_cond
(paren
id|TSN_lt
c_func
(paren
id|q-&gt;asoc-&gt;ctsn_ack_point
comma
id|sack_ctsn
)paren
)paren
(brace
id|q-&gt;asoc-&gt;ctsn_ack_point
op_assign
id|sack_ctsn
suffix:semicolon
)brace
multiline_comment|/* Update unack_data field in the assoc. */
id|sctp_sack_update_unack_data
c_func
(paren
id|q-&gt;asoc
comma
id|sack
)paren
suffix:semicolon
id|ctsn
op_assign
id|q-&gt;asoc-&gt;ctsn_ack_point
suffix:semicolon
id|SCTP_DEBUG_PRINTK
c_func
(paren
id|__FUNCTION__
l_string|&quot;: sack Cumulative TSN Ack is 0x%x.&bslash;n&quot;
comma
id|sack_ctsn
)paren
suffix:semicolon
id|SCTP_DEBUG_PRINTK
c_func
(paren
id|__FUNCTION__
l_string|&quot;: Cumulative TSN Ack of association &quot;
l_string|&quot;%p is 0x%x.&bslash;n&quot;
comma
id|q-&gt;asoc
comma
id|ctsn
)paren
suffix:semicolon
multiline_comment|/* Throw away stuff rotting on the sack queue.  */
id|list_for_each
c_func
(paren
id|lchunk
comma
op_amp
id|q-&gt;sacked
)paren
(brace
id|tchunk
op_assign
id|list_entry
c_func
(paren
id|lchunk
comma
id|sctp_chunk_t
comma
id|transmitted_list
)paren
suffix:semicolon
id|tsn
op_assign
id|ntohl
c_func
(paren
id|tchunk-&gt;subh.data_hdr-&gt;tsn
)paren
suffix:semicolon
r_if
c_cond
(paren
id|TSN_lte
c_func
(paren
id|tsn
comma
id|ctsn
)paren
)paren
(brace
id|lchunk
op_assign
id|lchunk-&gt;prev
suffix:semicolon
id|sctp_free_chunk
c_func
(paren
id|tchunk
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* ii) Set rwnd equal to the newly received a_rwnd minus the&n;         *     number of bytes still outstanding after processing the&n;         *     Cumulative TSN Ack and the Gap Ack Blocks.&n;         */
id|sack_a_rwnd
op_assign
id|ntohl
c_func
(paren
id|sack-&gt;a_rwnd
)paren
suffix:semicolon
id|outstanding
op_assign
id|q-&gt;outstanding_bytes
suffix:semicolon
r_if
c_cond
(paren
id|outstanding
OL
id|sack_a_rwnd
)paren
(brace
id|sack_a_rwnd
op_sub_assign
id|outstanding
suffix:semicolon
)brace
r_else
(brace
id|sack_a_rwnd
op_assign
l_int|0
suffix:semicolon
)brace
id|q-&gt;asoc-&gt;peer.rwnd
op_assign
id|sack_a_rwnd
suffix:semicolon
multiline_comment|/* See if all chunks are acked.&n;         * Make sure the empty queue handler will get run later.&n;         */
id|q-&gt;empty
op_assign
id|skb_queue_empty
c_func
(paren
op_amp
id|q-&gt;out
)paren
op_logical_and
id|list_empty
c_func
(paren
op_amp
id|q-&gt;retransmit
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|q-&gt;empty
)paren
(brace
r_goto
id|finish
suffix:semicolon
)brace
id|list_for_each
c_func
(paren
id|pos
comma
id|transport_list
)paren
(brace
id|transport
op_assign
id|list_entry
c_func
(paren
id|pos
comma
id|sctp_transport_t
comma
id|transports
)paren
suffix:semicolon
id|q-&gt;empty
op_assign
id|q-&gt;empty
op_logical_and
id|list_empty
c_func
(paren
op_amp
id|transport-&gt;transmitted
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|q-&gt;empty
)paren
(brace
r_goto
id|finish
suffix:semicolon
)brace
)brace
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;sack queue is empty.&bslash;n&quot;
)paren
suffix:semicolon
id|finish
suffix:colon
r_return
id|q-&gt;empty
suffix:semicolon
)brace
multiline_comment|/* sctp_sack_outqueue() */
multiline_comment|/* Is the outqueue empty?  */
r_int
DECL|function|sctp_outqueue_is_empty
id|sctp_outqueue_is_empty
c_func
(paren
r_const
id|sctp_outqueue_t
op_star
id|q
)paren
(brace
r_return
id|q-&gt;empty
suffix:semicolon
)brace
multiline_comment|/* sctp_outqueue_is_empty() */
multiline_comment|/********************************************************************&n; * 2nd Level Abstractions&n; ********************************************************************/
multiline_comment|/* Go through a transport&squot;s transmitted list or the assocication&squot;s retransmit&n; * list and move chunks that are acked by the Cumulative TSN Ack to q-&gt;sacked.&n; * The retransmit list will not have an associated transport. In case of a&n; * transmitted list with a transport, the transport&squot;s congestion, rto and fast &n; * retransmit parameters are also updated and if needed a fast retransmit&n; * process is started. &n; *&n; * I added coherent debug information output.&t;--xguo&n; *&n; * Instead of printing &squot;sacked&squot; or &squot;kept&squot; for each TSN on the&n; * transmitted_queue, we print a range: SACKED: TSN1-TSN2, TSN3, TSN4-TSN5.&n; * KEPT TSN6-TSN7, etc.&n; */
r_static
r_void
DECL|function|sctp_check_transmitted
id|sctp_check_transmitted
c_func
(paren
id|sctp_outqueue_t
op_star
id|q
comma
r_struct
id|list_head
op_star
id|transmitted_queue
comma
id|sctp_transport_t
op_star
id|transport
comma
id|sctp_sackhdr_t
op_star
id|sack
)paren
(brace
r_struct
id|list_head
op_star
id|lchunk
suffix:semicolon
id|sctp_chunk_t
op_star
id|tchunk
suffix:semicolon
r_struct
id|list_head
id|tlist
suffix:semicolon
r_uint32
id|tsn
suffix:semicolon
r_uint32
id|sack_ctsn
suffix:semicolon
r_uint32
id|rtt
suffix:semicolon
r_uint32
id|highest_new_tsn_in_sack
suffix:semicolon
r_uint8
id|restart_timer
op_assign
l_int|0
suffix:semicolon
r_uint8
id|do_fast_retransmit
op_assign
l_int|0
suffix:semicolon
r_int
id|bytes_acked
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* These state variables are for coherent debug output. --xguo */
macro_line|#if SCTP_DEBUG
r_uint32
id|dbg_ack_tsn
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* An ACKed TSN range starts here... */
r_uint32
id|dbg_last_ack_tsn
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* ...and finishes here.&t;     */
r_uint32
id|dbg_kept_tsn
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* An un-ACKed range starts here...  */
r_uint32
id|dbg_last_kept_tsn
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* ...and finishes here.&t;     */
multiline_comment|/* 0 : The last TSN was ACKed.&n;&t; * 1 : The last TSN was NOT ACKed (i.e. KEPT).&n;&t; * -1: We need to initialize.&n;&t; */
r_int
id|dbg_prt_state
op_assign
op_minus
l_int|1
suffix:semicolon
macro_line|#endif /* SCTP_DEBUG */
id|sack_ctsn
op_assign
id|ntohl
c_func
(paren
id|sack-&gt;cum_tsn_ack
)paren
suffix:semicolon
id|highest_new_tsn_in_sack
op_assign
id|sack_ctsn
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|tlist
)paren
suffix:semicolon
multiline_comment|/* The while loop will skip empty transmitted queues. */
r_while
c_loop
(paren
l_int|NULL
op_ne
(paren
id|lchunk
op_assign
id|sctp_list_dequeue
c_func
(paren
id|transmitted_queue
)paren
)paren
)paren
(brace
id|tchunk
op_assign
id|list_entry
c_func
(paren
id|lchunk
comma
id|sctp_chunk_t
comma
id|transmitted_list
)paren
suffix:semicolon
id|tsn
op_assign
id|ntohl
c_func
(paren
id|tchunk-&gt;subh.data_hdr-&gt;tsn
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sctp_acked
c_func
(paren
id|sack
comma
id|tsn
)paren
)paren
(brace
multiline_comment|/* If this queue is the retransmit queue, the&n;&t;&t;&t; * retransmit timer has already reclaimed&n;&t;&t;&t; * the outstanding bytes for this chunk, so only&n;&t;&t;&t; * count bytes associated with a transport.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|transport
)paren
(brace
multiline_comment|/* If this chunk is being used for RTT &n;&t;&t;&t;    * measurement, calculate the RTT and update &n;&t;&t;&t;    * the RTO using this value.&n;&t;&t;&t;    *&n;&t;&t;&t;    * 6.3.1 C5) Karn&squot;s algorithm: RTT measurements &n;&t;&t;&t;    * MUST NOT be made using packets that were &n;&t;&t;&t;    * retransmitted (and thus for which it is &n;&t;&t;&t;    * ambiguous whether the reply was for the first &n;&t;&t;&t;    * instance of the packet or a later instance).&n;&t;&t;&t;    */
r_if
c_cond
(paren
(paren
op_logical_neg
id|tchunk-&gt;tsn_gap_acked
)paren
op_logical_and
(paren
l_int|1
op_eq
id|tchunk-&gt;num_times_sent
)paren
op_logical_and
(paren
id|tchunk-&gt;rtt_in_progress
)paren
)paren
(brace
id|rtt
op_assign
id|jiffies
op_minus
id|tchunk-&gt;sent_at
suffix:semicolon
id|sctp_transport_update_rto
c_func
(paren
id|transport
comma
id|rtt
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|TSN_lte
c_func
(paren
id|tsn
comma
id|sack_ctsn
)paren
)paren
(brace
multiline_comment|/* RFC 2960  6.3.2 Retransmission Timer Rules&n;                                 *&n;                                 * R3) Whenever a SACK is received&n;                                 * that acknowledges the DATA chunk&n;                                 * with the earliest outstanding TSN&n;                                 * for that address, restart T3-rtx&n;                                 * timer for that address with its&n;                                 * current RTO.&n;                                 */
id|restart_timer
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tchunk-&gt;tsn_gap_acked
)paren
(brace
id|tchunk-&gt;tsn_gap_acked
op_assign
l_int|1
suffix:semicolon
id|bytes_acked
op_add_assign
id|sctp_data_size
c_func
(paren
id|tchunk
)paren
suffix:semicolon
)brace
id|list_add_tail
c_func
(paren
op_amp
id|tchunk-&gt;transmitted_list
comma
op_amp
id|q-&gt;sacked
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* RFC2960 7.2.4, sctpimpguide-05 2.8.2&n;&t;&t;&t;       * M2) Each time a SACK arrives reporting &n;&t;&t;&t;       * &squot;Stray DATA chunk(s)&squot; record the highest TSN &n;&t;&t;&t;       * reported as newly acknowledged, call this &n;&t;&t;&t;       * value &squot;HighestTSNinSack&squot;. A newly &n;&t;&t;&t;       * acknowledged DATA chunk is one not previously &n;&t;&t;&t;       * acknowledged in a SACK.&n;&t;&t;&t;       *&n;&t;&t;&t;       * When the SCTP sender of data receives a SACK &n;&t;&t;&t;       * chunk that acknowledges, for the first time, &n;&t;&t;&t;       * the receipt of a DATA chunk, all the still &n;&t;&t;&t;       * unacknowledged DATA chunks whose TSN is older &n;&t;&t;&t;       * than that newly acknowledged DATA chunk, are &n;&t;&t;&t;       * qualified as &squot;Stray DATA chunks&squot;.&n;&t;&t;&t;       */
r_if
c_cond
(paren
op_logical_neg
id|tchunk-&gt;tsn_gap_acked
)paren
(brace
id|tchunk-&gt;tsn_gap_acked
op_assign
l_int|1
suffix:semicolon
id|bytes_acked
op_add_assign
id|sctp_data_size
c_func
(paren
id|tchunk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|TSN_lt
c_func
(paren
id|highest_new_tsn_in_sack
comma
id|tsn
)paren
)paren
(brace
id|highest_new_tsn_in_sack
op_assign
id|tsn
suffix:semicolon
)brace
)brace
id|list_add_tail
c_func
(paren
id|lchunk
comma
op_amp
id|tlist
)paren
suffix:semicolon
)brace
macro_line|#if SCTP_DEBUG
r_switch
c_cond
(paren
id|dbg_prt_state
)paren
(brace
r_case
l_int|0
suffix:colon
multiline_comment|/* last TSN was ACKed */
r_if
c_cond
(paren
id|dbg_last_ack_tsn
op_plus
l_int|1
op_eq
id|tsn
)paren
(brace
multiline_comment|/* This TSN belongs to the&n;&t;&t;&t;&t;&t; * current ACK range.&n;&t;&t;&t;&t;&t; */
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dbg_last_ack_tsn
op_ne
id|dbg_ack_tsn
)paren
(brace
multiline_comment|/* Display the end of the&n;&t;&t;&t;&t;&t; * current range.&n;&t;&t;&t;&t;&t; */
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;-%08x&quot;
comma
id|dbg_last_ack_tsn
)paren
suffix:semicolon
)brace
multiline_comment|/* Start a new range.  */
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;,%08x&quot;
comma
id|tsn
)paren
suffix:semicolon
id|dbg_ack_tsn
op_assign
id|tsn
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
multiline_comment|/* The last TSN was NOT ACKed. */
r_if
c_cond
(paren
id|dbg_last_kept_tsn
op_ne
id|dbg_kept_tsn
)paren
(brace
multiline_comment|/* Display the end of current range. */
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;-%08x&quot;
comma
id|dbg_last_kept_tsn
)paren
suffix:semicolon
)brace
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* FALL THROUGH... */
r_default
suffix:colon
multiline_comment|/* This is the first-ever TSN we examined.  */
multiline_comment|/* Start a new range of ACK-ed TSNs. */
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;ACKed: %08x&quot;
comma
id|tsn
)paren
suffix:semicolon
id|dbg_prt_state
op_assign
l_int|0
suffix:semicolon
id|dbg_ack_tsn
op_assign
id|tsn
suffix:semicolon
)brace
id|dbg_last_ack_tsn
op_assign
id|tsn
suffix:semicolon
macro_line|#endif /* SCTP_DEBUG */&t;&t;&t;&t;
)brace
r_else
(brace
r_if
c_cond
(paren
id|tchunk-&gt;tsn_gap_acked
)paren
(brace
id|SCTP_DEBUG_PRINTK
c_func
(paren
id|__FUNCTION__
l_string|&quot;: Receiver reneged on data &quot;
l_string|&quot;TSN: 0x%x&bslash;n&quot;
comma
id|tsn
)paren
suffix:semicolon
id|tchunk-&gt;tsn_gap_acked
op_assign
l_int|0
suffix:semicolon
id|bytes_acked
op_sub_assign
id|sctp_data_size
c_func
(paren
id|tchunk
)paren
suffix:semicolon
multiline_comment|/* RFC 2960 6.3.2 Retransmission Timer Rules&n;&t;&t;&t; *&n;&t;&t;&t; * R4) Whenever a SACK is received missing a TSN &n;&t;&t;&t; * that was previously acknowledged via a Gap Ack &n;&t;&t;&t; * Block, start T3-rtx for the destination &n;&t;&t;&t; * address to which the DATA chunk was originally &n;&t;&t;&t; * transmitted if it is not already running.&n;&t;&t;&t; */
id|restart_timer
op_assign
l_int|1
suffix:semicolon
)brace
id|list_add_tail
c_func
(paren
id|lchunk
comma
op_amp
id|tlist
)paren
suffix:semicolon
macro_line|#if SCTP_DEBUG
multiline_comment|/* See the above comments on ACK-ed TSNs. */
r_switch
c_cond
(paren
id|dbg_prt_state
)paren
(brace
r_case
l_int|1
suffix:colon
r_if
c_cond
(paren
id|dbg_last_kept_tsn
op_plus
l_int|1
op_eq
id|tsn
)paren
(brace
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dbg_last_kept_tsn
op_ne
id|dbg_kept_tsn
)paren
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;-%08x&quot;
comma
id|dbg_last_kept_tsn
)paren
suffix:semicolon
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;,%08x&quot;
comma
id|tsn
)paren
suffix:semicolon
id|dbg_kept_tsn
op_assign
id|tsn
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0
suffix:colon
r_if
c_cond
(paren
id|dbg_last_ack_tsn
op_ne
id|dbg_ack_tsn
)paren
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;-%08x&quot;
comma
id|dbg_last_ack_tsn
)paren
suffix:semicolon
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* FALL THROUGH... */
r_default
suffix:colon
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;KEPT: %08x&quot;
comma
id|tsn
)paren
suffix:semicolon
id|dbg_prt_state
op_assign
l_int|1
suffix:semicolon
id|dbg_kept_tsn
op_assign
id|tsn
suffix:semicolon
)brace
id|dbg_last_kept_tsn
op_assign
id|tsn
suffix:semicolon
macro_line|#endif /* SCTP_DEBUG */
)brace
multiline_comment|/* if (TSN has just been ACKd) */
)brace
suffix:semicolon
multiline_comment|/* while (transmitted queue is not empty) */
macro_line|#if SCTP_DEBUG
multiline_comment|/* Finish off the last range, displaying its ending TSN. */
r_switch
c_cond
(paren
id|dbg_prt_state
)paren
(brace
r_case
l_int|0
suffix:colon
r_if
c_cond
(paren
id|dbg_last_ack_tsn
op_ne
id|dbg_ack_tsn
)paren
(brace
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;-%08x&bslash;n&quot;
comma
id|dbg_last_ack_tsn
)paren
suffix:semicolon
)brace
r_else
(brace
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
r_if
c_cond
(paren
id|dbg_last_kept_tsn
op_ne
id|dbg_kept_tsn
)paren
(brace
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;-%08x&bslash;n&quot;
comma
id|dbg_last_kept_tsn
)paren
suffix:semicolon
)brace
r_else
(brace
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif /* SCTP_DEBUG */
r_if
c_cond
(paren
id|transport
)paren
(brace
r_if
c_cond
(paren
id|bytes_acked
)paren
(brace
multiline_comment|/* 8.2. When an outstanding TSN is acknowledged, &n;&t;&t;&t; * the endpoint shall clear the error counter of &n;&t;&t;&t; * the destination transport address to which the &n;&t;&t;&t; * DATA chunk was last sent.&n;&t;&t;&t; * The association&squot;s overall error counter is &n;&t;&t;&t; * also cleared.&n;&t;&t;&t; */
id|transport-&gt;error_count
op_assign
l_int|0
suffix:semicolon
id|transport-&gt;asoc-&gt;overall_error_count
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Mark the destination transport address as &n;&t;&t;&t; * active if it is not so marked.&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|transport-&gt;state.active
)paren
(brace
id|sctp_assoc_control_transport
c_func
(paren
id|transport-&gt;asoc
comma
id|transport
comma
id|SCTP_TRANSPORT_UP
comma
id|SCTP_RECEIVED_SACK
)paren
suffix:semicolon
)brace
id|sctp_transport_raise_cwnd
c_func
(paren
id|transport
comma
id|sack_ctsn
comma
id|bytes_acked
)paren
suffix:semicolon
id|transport-&gt;flight_size
op_sub_assign
id|bytes_acked
suffix:semicolon
id|q-&gt;outstanding_bytes
op_sub_assign
id|bytes_acked
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* RFC 2960 6.1, sctpimpguide-06 2.15.2 &n;&t;&t;&t; * When a sender is doing zero window probing, it &n;&t;&t;&t; * should not timeout the association if it continues &n;&t;&t;&t; * to receive new packets from the receiver. The &n;&t;&t;&t; * reason is that the receiver MAY keep its window &n;&t;&t;&t; * closed for an indefinite time.&n;&t;&t;&t; * A sender is doing zero window probing when the &n;&t;&t;&t; * receiver&squot;s advertised window is zero, and there is&n;&t;&t;&t; * only one data chunk in flight to the receiver.  &n;&t;&t;&t; */
r_if
c_cond
(paren
(paren
l_int|0
op_eq
id|q-&gt;asoc-&gt;peer.rwnd
)paren
op_logical_and
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|tlist
)paren
)paren
op_logical_and
(paren
id|sack_ctsn
op_plus
l_int|2
op_eq
id|q-&gt;asoc-&gt;next_tsn
)paren
)paren
(brace
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;%s: SACK received for zero &quot;
l_string|&quot;window probe: %u&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|sack_ctsn
)paren
suffix:semicolon
id|q-&gt;asoc-&gt;overall_error_count
op_assign
l_int|0
suffix:semicolon
id|transport-&gt;error_count
op_assign
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/* RFC 2960 6.3.2 Retransmission Timer Rules&n;         &t; * &n;         &t; * R2) Whenever all outstanding data sent to an address have &n;&t;&t; * been acknowledged, turn off the T3-rtx timer of that &n;&t;&t; * address. &n;         &t; */
r_if
c_cond
(paren
op_logical_neg
id|transport-&gt;flight_size
)paren
(brace
r_if
c_cond
(paren
id|timer_pending
c_func
(paren
op_amp
id|transport-&gt;T3_rtx_timer
)paren
op_logical_and
id|del_timer
c_func
(paren
op_amp
id|transport-&gt;T3_rtx_timer
)paren
)paren
(brace
id|sctp_transport_put
c_func
(paren
id|transport
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|restart_timer
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|mod_timer
c_func
(paren
op_amp
id|transport-&gt;T3_rtx_timer
comma
id|jiffies
op_plus
id|transport-&gt;rto
)paren
)paren
(brace
id|sctp_transport_hold
c_func
(paren
id|transport
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Reconstruct the transmitted list with chunks that are not yet&n;&t; * acked by the Cumulative TSN Ack.&n;&t; */
r_while
c_loop
(paren
l_int|NULL
op_ne
(paren
id|lchunk
op_assign
id|sctp_list_dequeue
c_func
(paren
op_amp
id|tlist
)paren
)paren
)paren
(brace
id|tchunk
op_assign
id|list_entry
c_func
(paren
id|lchunk
comma
id|sctp_chunk_t
comma
id|transmitted_list
)paren
suffix:semicolon
id|tsn
op_assign
id|ntohl
c_func
(paren
id|tchunk-&gt;subh.data_hdr-&gt;tsn
)paren
suffix:semicolon
multiline_comment|/* RFC 2960 7.2.4, sctpimpguide-05 2.8.2 M3) Examine all &n;&t;&t; * &squot;Unacknowledged TSN&squot;s&squot;, if the TSN number of an &n;&t;&t; * &squot;Unacknowledged TSN&squot; is smaller than the &squot;HighestTSNinSack&squot;&n;&t;&t; * value, increment the &squot;TSN.Missing.Report&squot; count on that &n;&t;&t; * chunk if it has NOT been fast retransmitted or marked for &n;&t;&t; * fast retransmit already.&n;&t;&t; *&n;&t;&t; * M4) If any DATA chunk is found to have a &n;&t;&t; * &squot;TSN.Missing.Report&squot; &n;&t;&t; * value larger than or equal to 4, mark that chunk for &n;&t;&t; * retransmission and start the fast retransmit procedure. &n;&t;&t; */
r_if
c_cond
(paren
(paren
op_logical_neg
id|tchunk-&gt;fast_retransmit
)paren
op_logical_and
(paren
op_logical_neg
id|tchunk-&gt;tsn_gap_acked
)paren
op_logical_and
(paren
id|TSN_lt
c_func
(paren
id|tsn
comma
id|highest_new_tsn_in_sack
)paren
)paren
)paren
(brace
id|tchunk-&gt;tsn_missing_report
op_increment
suffix:semicolon
id|SCTP_DEBUG_PRINTK
c_func
(paren
l_string|&quot;%s: TSN 0x%x missing counter: %d&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|tsn
comma
id|tchunk-&gt;tsn_missing_report
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tchunk-&gt;tsn_missing_report
op_ge
l_int|4
)paren
(brace
id|tchunk-&gt;fast_retransmit
op_assign
l_int|1
suffix:semicolon
id|do_fast_retransmit
op_assign
l_int|1
suffix:semicolon
)brace
id|list_add_tail
c_func
(paren
id|lchunk
comma
id|transmitted_queue
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|transport
)paren
(brace
r_if
c_cond
(paren
id|do_fast_retransmit
)paren
(brace
id|sctp_retransmit
c_func
(paren
id|q
comma
id|transport
comma
id|do_fast_retransmit
)paren
suffix:semicolon
)brace
id|SCTP_DEBUG_PRINTK
c_func
(paren
id|__FUNCTION__
l_string|&quot;: transport: %p, cwnd: %d, &quot;
l_string|&quot;ssthresh: %d, flight_size: %d, pba: %d&bslash;n&quot;
comma
id|transport
comma
id|transport-&gt;cwnd
comma
id|transport-&gt;ssthresh
comma
id|transport-&gt;flight_size
comma
id|transport-&gt;partial_bytes_acked
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* sctp_check_transmitted() */
multiline_comment|/* Is the given TSN acked by this packet?  */
r_static
r_int
DECL|function|sctp_acked
id|sctp_acked
c_func
(paren
id|sctp_sackhdr_t
op_star
id|sack
comma
r_uint32
id|tsn
)paren
(brace
r_int
id|i
suffix:semicolon
id|sctp_sack_variable_t
op_star
id|frags
suffix:semicolon
r_uint16
id|gap
suffix:semicolon
r_uint32
id|ctsn
op_assign
id|ntohl
c_func
(paren
id|sack-&gt;cum_tsn_ack
)paren
suffix:semicolon
r_if
c_cond
(paren
id|TSN_lte
c_func
(paren
id|tsn
comma
id|ctsn
)paren
)paren
(brace
r_goto
id|pass
suffix:semicolon
)brace
multiline_comment|/* 3.3.4 Selective Acknowledgement (SACK) (3):&n;         * &n;         * Gap Ack Blocks:&n;         *  These fields contain the Gap Ack Blocks. They are repeated&n;         *  for each Gap Ack Block up to the number of Gap Ack Blocks&n;         *  defined in the Number of Gap Ack Blocks field. All DATA&n;         *  chunks with TSNs greater than or equal to (Cumulative TSN&n;         *  Ack + Gap Ack Block Start) and less than or equal to&n;         *  (Cumulative TSN Ack + Gap Ack Block End) of each Gap Ack&n;         *  Block are assumed to have been received correctly.&n;         */
id|frags
op_assign
id|sack-&gt;variable
suffix:semicolon
id|gap
op_assign
id|tsn
op_minus
id|ctsn
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ntohs
c_func
(paren
id|sack-&gt;num_gap_ack_blocks
)paren
suffix:semicolon
op_increment
id|i
)paren
(brace
r_if
c_cond
(paren
id|TSN_lte
c_func
(paren
id|ntohs
c_func
(paren
id|frags
(braket
id|i
)braket
dot
id|gab.start
)paren
comma
id|gap
)paren
op_logical_and
id|TSN_lte
c_func
(paren
id|gap
comma
id|ntohs
c_func
(paren
id|frags
(braket
id|i
)braket
dot
id|gab.end
)paren
)paren
)paren
(brace
r_goto
id|pass
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
id|pass
suffix:colon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* sctp_acked() */
eof
