multiline_comment|/*&n; * llc_conn.c - Driver routines for connection component.&n; *&n; * Copyright (c) 1997 by Procom Technology, Inc.&n; *&t;&t; 2001 by Arnaldo Carvalho de Melo &lt;acme@conectiva.com.br&gt;&n; *&n; * This program can be redistributed or modified under the terms of the&n; * GNU General Public License as published by the Free Software Foundation.&n; * This program is distributed without any warranty or implied warranty&n; * of merchantability or fitness for a particular purpose.&n; *&n; * See the GNU General Public License for more details.&n; */
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;net/llc_if.h&gt;
macro_line|#include &lt;net/llc_sap.h&gt;
macro_line|#include &lt;net/llc_conn.h&gt;
macro_line|#include &lt;net/sock.h&gt;
macro_line|#include &lt;net/llc_main.h&gt;
macro_line|#include &lt;net/llc_c_ev.h&gt;
macro_line|#include &lt;net/llc_c_ac.h&gt;
macro_line|#include &lt;net/llc_c_st.h&gt;
macro_line|#include &lt;net/llc_mac.h&gt;
macro_line|#include &lt;net/llc_pdu.h&gt;
macro_line|#include &lt;net/llc_s_ev.h&gt;
r_static
r_int
id|llc_find_offset
c_func
(paren
r_int
id|state
comma
r_int
id|ev_type
)paren
suffix:semicolon
r_static
r_void
id|llc_conn_send_pdus
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
suffix:semicolon
r_static
r_int
id|llc_conn_service
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|llc_conn_state_ev
op_star
id|ev
)paren
suffix:semicolon
r_static
r_int
id|llc_exec_conn_trans_actions
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|llc_conn_state_trans
op_star
id|trans
comma
r_struct
id|llc_conn_state_ev
op_star
id|ev
)paren
suffix:semicolon
r_static
r_struct
id|llc_conn_state_trans
op_star
id|llc_qualify_conn_ev
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|llc_conn_state_ev
op_star
id|ev
)paren
suffix:semicolon
multiline_comment|/* Offset table on connection states transition diagram */
DECL|variable|llc_offset_table
r_static
r_int
id|llc_offset_table
(braket
id|NBR_CONN_STATES
)braket
(braket
id|NBR_CONN_EV
)braket
suffix:semicolon
multiline_comment|/**&n; *&t;llc_conn_alloc_event: allocates an event&n; *&t;@sk: socket that event is associated&n; *&n; *&t;Returns pointer to allocated connection on success, %NULL on failure.&n; */
DECL|function|llc_conn_alloc_ev
r_struct
id|llc_conn_state_ev
op_star
id|llc_conn_alloc_ev
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|llc_conn_state_ev
op_star
id|ev
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* verify connection is valid, active and open */
r_if
c_cond
(paren
id|llc_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|state
op_ne
id|LLC_CONN_OUT_OF_SVC
)paren
(brace
multiline_comment|/* get event structure to build a station event */
id|ev
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|ev
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ev
)paren
id|memset
c_func
(paren
id|ev
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|ev
)paren
)paren
suffix:semicolon
)brace
r_return
id|ev
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;llc_conn_send_event - sends event to connection state machine&n; *&t;@sk: connection&n; *&t;@ev: occurred event&n; *&n; *&t;Sends an event to connection state machine. after processing event&n; *&t;(executing it&squot;s actions and changing state), upper layer will be&n; *&t;indicated or confirmed, if needed. Returns 0 for success, 1 for&n; *&t;failure. The socket lock has to be held before calling this function.&n; */
DECL|function|llc_conn_send_ev
r_int
id|llc_conn_send_ev
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|llc_conn_state_ev
op_star
id|ev
)paren
(brace
multiline_comment|/* sending event to state machine */
r_int
id|rc
op_assign
id|llc_conn_service
c_func
(paren
id|sk
comma
id|ev
)paren
suffix:semicolon
r_struct
id|llc_opt
op_star
id|llc
op_assign
id|llc_sk
c_func
(paren
id|sk
)paren
suffix:semicolon
id|u8
id|flag
op_assign
id|ev-&gt;flag
suffix:semicolon
r_struct
id|llc_prim_if_block
op_star
id|ind_prim
op_assign
id|ev-&gt;ind_prim
suffix:semicolon
r_struct
id|llc_prim_if_block
op_star
id|cfm_prim
op_assign
id|ev-&gt;cfm_prim
suffix:semicolon
id|llc_conn_free_ev
c_func
(paren
id|ev
)paren
suffix:semicolon
macro_line|#ifdef THIS_BREAKS_DISCONNECT_NOTIFICATION_BADLY
multiline_comment|/* check if the connection was freed by the state machine by&n;&t; * means of llc_conn_disc */
r_if
c_cond
(paren
id|rc
op_eq
l_int|2
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
id|__FUNCTION__
l_string|&quot;: rc == 2&bslash;n&quot;
)paren
suffix:semicolon
id|rc
op_assign
op_minus
id|ECONNABORTED
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
macro_line|#endif&t;/* THIS_BREAKS_DISCONNECT_NOTIFICATION_BADLY */
r_if
c_cond
(paren
op_logical_neg
id|flag
)paren
multiline_comment|/* indicate or confirm not required */
r_goto
id|out
suffix:semicolon
id|rc
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ind_prim
)paren
multiline_comment|/* indication required */
id|llc-&gt;sap
op_member_access_from_pointer
id|ind
c_func
(paren
id|ind_prim
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cfm_prim
)paren
multiline_comment|/* confirmation not required */
r_goto
id|out
suffix:semicolon
multiline_comment|/* data confirm has preconditions */
r_if
c_cond
(paren
id|cfm_prim-&gt;prim
op_ne
id|LLC_DATA_PRIM
)paren
(brace
id|llc-&gt;sap
op_member_access_from_pointer
id|conf
c_func
(paren
id|cfm_prim
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|llc_data_accept_state
c_func
(paren
id|llc-&gt;state
)paren
)paren
(brace
multiline_comment|/* In this state, we can send I pdu */
multiline_comment|/* FIXME: check if we don&squot;t need to see if sk-&gt;lock.users != 0&n;&t;&t; * is needed here&n;&t;&t; */
id|rc
op_assign
id|llc-&gt;sap
op_member_access_from_pointer
id|conf
c_func
(paren
id|cfm_prim
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
multiline_comment|/* confirmation didn&squot;t accept by upper layer */
id|llc-&gt;failed_data_req
op_assign
l_int|1
suffix:semicolon
)brace
r_else
id|llc-&gt;failed_data_req
op_assign
l_int|1
suffix:semicolon
id|out
suffix:colon
r_return
id|rc
suffix:semicolon
)brace
DECL|function|llc_conn_send_pdu
r_void
id|llc_conn_send_pdu
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
id|llc_sock_assert
c_func
(paren
id|sk
)paren
suffix:semicolon
multiline_comment|/* queue PDU to send to MAC layer */
id|skb_queue_tail
c_func
(paren
op_amp
id|sk-&gt;write_queue
comma
id|skb
)paren
suffix:semicolon
id|llc_conn_send_pdus
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;llc_conn_rtn_pdu - sends received data pdu to upper layer&n; *&t;@sk: Active connection&n; *&t;@skb: Received data frame&n; *&t;@ev: Occurred event&n; *&n; *&t;Sends received data pdu to upper layer (by using indicate function).&n; *&t;Prepares service parameters (prim and prim_data). calling indication&n; *&t;function will be done in llc_conn_send_ev.&n; */
DECL|function|llc_conn_rtn_pdu
r_void
id|llc_conn_rtn_pdu
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|llc_conn_state_ev
op_star
id|ev
)paren
(brace
r_struct
id|llc_prim_if_block
op_star
id|prim
op_assign
op_amp
id|llc_ind_prim
suffix:semicolon
r_union
id|llc_u_prim_data
op_star
id|prim_data
op_assign
id|llc_ind_prim.data
suffix:semicolon
id|prim_data-&gt;data.sk
op_assign
id|sk
suffix:semicolon
id|prim_data-&gt;data.pri
op_assign
l_int|0
suffix:semicolon
id|prim_data-&gt;data.skb
op_assign
id|skb
suffix:semicolon
id|prim_data-&gt;data.link
op_assign
id|llc_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|link
suffix:semicolon
id|prim-&gt;data
op_assign
id|prim_data
suffix:semicolon
id|prim-&gt;prim
op_assign
id|LLC_DATA_PRIM
suffix:semicolon
id|prim-&gt;sap
op_assign
id|llc_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|sap
suffix:semicolon
id|ev-&gt;flag
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* saving prepd prim in event for future use in llc_conn_send_ev */
id|ev-&gt;ind_prim
op_assign
id|prim
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;llc_conn_resend_i_pdu_as_cmd - resend all all unacknowledged I PDUs&n; *&t;@sk: active connection&n; *&t;@nr: NR&n; *&t;@first_p_bit: p_bit value of first pdu&n; *&n; *&t;Resend all unacknowledged I PDUs, starting with the NR; send first as&n; *&t;command PDU with P bit equal first_p_bit; if more than one send&n; *&t;subsequent as command PDUs with P bit equal zero (0).&n; */
DECL|function|llc_conn_resend_i_pdu_as_cmd
r_void
id|llc_conn_resend_i_pdu_as_cmd
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
id|u8
id|nr
comma
id|u8
id|first_p_bit
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
id|llc_pdu_sn_t
op_star
id|pdu
suffix:semicolon
id|u16
id|nbr_unack_pdus
suffix:semicolon
id|u8
id|howmany_resend
op_assign
l_int|0
suffix:semicolon
id|llc_conn_remove_acked_pdus
c_func
(paren
id|sk
comma
id|nr
comma
op_amp
id|nbr_unack_pdus
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|nbr_unack_pdus
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* process unack PDUs only if unack queue is not empty; remove&n;&t; * appropriate PDUs, fix them up, and put them on mac_pdu_q.&n;&t; */
r_while
c_loop
(paren
(paren
id|skb
op_assign
id|skb_dequeue
c_func
(paren
op_amp
id|llc_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|pdu_unack_q
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|pdu
op_assign
(paren
id|llc_pdu_sn_t
op_star
)paren
id|skb-&gt;nh.raw
suffix:semicolon
id|llc_pdu_set_cmd_rsp
c_func
(paren
id|skb
comma
id|LLC_PDU_CMD
)paren
suffix:semicolon
id|llc_pdu_set_pf_bit
c_func
(paren
id|skb
comma
id|first_p_bit
)paren
suffix:semicolon
id|skb_queue_tail
c_func
(paren
op_amp
id|sk-&gt;write_queue
comma
id|skb
)paren
suffix:semicolon
id|first_p_bit
op_assign
l_int|0
suffix:semicolon
id|llc_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|vS
op_assign
id|LLC_I_GET_NS
c_func
(paren
id|pdu
)paren
suffix:semicolon
id|howmany_resend
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|howmany_resend
OG
l_int|0
)paren
id|llc_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|vS
op_assign
(paren
id|llc_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|vS
op_plus
l_int|1
)paren
op_mod
id|LLC_2_SEQ_NBR_MODULO
suffix:semicolon
multiline_comment|/* any PDUs to re-send are queued up; start sending to MAC */
id|llc_conn_send_pdus
c_func
(paren
id|sk
)paren
suffix:semicolon
id|out
suffix:colon
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;llc_conn_resend_i_pdu_as_rsp - Resend all unacknowledged I PDUs&n; *&t;@sk: active connection.&n; *&t;@nr: NR&n; *&t;@first_f_bit: f_bit value of first pdu.&n; *&n; *&t;Resend all unacknowledged I PDUs, starting with the NR; send first as&n; *&t;response PDU with F bit equal first_f_bit; if more than one send&n; *&t;subsequent as response PDUs with F bit equal zero (0).&n; */
DECL|function|llc_conn_resend_i_pdu_as_rsp
r_void
id|llc_conn_resend_i_pdu_as_rsp
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
id|u8
id|nr
comma
id|u8
id|first_f_bit
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
id|llc_pdu_sn_t
op_star
id|pdu
suffix:semicolon
id|u16
id|nbr_unack_pdus
suffix:semicolon
id|u8
id|howmany_resend
op_assign
l_int|0
suffix:semicolon
id|llc_conn_remove_acked_pdus
c_func
(paren
id|sk
comma
id|nr
comma
op_amp
id|nbr_unack_pdus
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|nbr_unack_pdus
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* process unack PDUs only if unack queue is not empty; remove&n;&t; * appropriate PDUs, fix them up, and put them on mac_pdu_q&n;&t; */
r_while
c_loop
(paren
(paren
id|skb
op_assign
id|skb_dequeue
c_func
(paren
op_amp
id|llc_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|pdu_unack_q
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|pdu
op_assign
(paren
id|llc_pdu_sn_t
op_star
)paren
id|skb-&gt;nh.raw
suffix:semicolon
id|llc_pdu_set_cmd_rsp
c_func
(paren
id|skb
comma
id|LLC_PDU_RSP
)paren
suffix:semicolon
id|llc_pdu_set_pf_bit
c_func
(paren
id|skb
comma
id|first_f_bit
)paren
suffix:semicolon
id|skb_queue_tail
c_func
(paren
op_amp
id|sk-&gt;write_queue
comma
id|skb
)paren
suffix:semicolon
id|first_f_bit
op_assign
l_int|0
suffix:semicolon
id|llc_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|vS
op_assign
id|LLC_I_GET_NS
c_func
(paren
id|pdu
)paren
suffix:semicolon
id|howmany_resend
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|howmany_resend
OG
l_int|0
)paren
id|llc_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|vS
op_assign
(paren
id|llc_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|vS
op_plus
l_int|1
)paren
op_mod
id|LLC_2_SEQ_NBR_MODULO
suffix:semicolon
multiline_comment|/* any PDUs to re-send are queued up; start sending to MAC */
id|llc_conn_send_pdus
c_func
(paren
id|sk
)paren
suffix:semicolon
id|out
suffix:colon
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;llc_conn_remove_acked_pdus - Removes acknowledged pdus from tx queue&n; *&t;@sk: active connection&n; *&t;nr: NR&n; *&t;how_many_unacked: size of pdu_unack_q after removing acked pdus&n; *&n; *&t;Removes acknowledged pdus from transmit queue (pdu_unack_q). Returns&n; *&t;the number of pdus that removed from queue.&n; */
DECL|function|llc_conn_remove_acked_pdus
r_int
id|llc_conn_remove_acked_pdus
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
id|u8
id|nr
comma
id|u16
op_star
id|how_many_unacked
)paren
(brace
r_int
id|pdu_pos
comma
id|i
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
id|llc_pdu_sn_t
op_star
id|pdu
suffix:semicolon
r_int
id|nbr_acked
op_assign
l_int|0
suffix:semicolon
r_int
id|q_len
op_assign
id|skb_queue_len
c_func
(paren
op_amp
id|llc_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|pdu_unack_q
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|q_len
)paren
r_goto
id|out
suffix:semicolon
id|skb
op_assign
id|skb_peek
c_func
(paren
op_amp
id|llc_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|pdu_unack_q
)paren
suffix:semicolon
id|pdu
op_assign
(paren
id|llc_pdu_sn_t
op_star
)paren
id|skb-&gt;nh.raw
suffix:semicolon
multiline_comment|/* finding position of last acked pdu in queue */
id|pdu_pos
op_assign
(paren
(paren
r_int
)paren
id|LLC_2_SEQ_NBR_MODULO
op_plus
(paren
r_int
)paren
id|nr
op_minus
(paren
r_int
)paren
id|LLC_I_GET_NS
c_func
(paren
id|pdu
)paren
)paren
op_mod
id|LLC_2_SEQ_NBR_MODULO
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|pdu_pos
op_logical_and
id|i
OL
id|q_len
suffix:semicolon
id|i
op_increment
)paren
(brace
id|skb
op_assign
id|skb_dequeue
c_func
(paren
op_amp
id|llc_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|pdu_unack_q
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
)paren
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
id|nbr_acked
op_increment
suffix:semicolon
)brace
id|out
suffix:colon
op_star
id|how_many_unacked
op_assign
id|skb_queue_len
c_func
(paren
op_amp
id|llc_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|pdu_unack_q
)paren
suffix:semicolon
r_return
id|nbr_acked
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;llc_conn_send_pdus - Sends queued PDUs&n; *&t;@sk: active connection&n; *&n; *&t;Sends queued pdus to MAC layer for transmition.&n; */
DECL|function|llc_conn_send_pdus
r_static
r_void
id|llc_conn_send_pdus
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_while
c_loop
(paren
(paren
id|skb
op_assign
id|skb_dequeue
c_func
(paren
op_amp
id|sk-&gt;write_queue
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|llc_pdu_sn_t
op_star
id|pdu
op_assign
(paren
id|llc_pdu_sn_t
op_star
)paren
id|skb-&gt;nh.raw
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|LLC_PDU_TYPE_IS_I
c_func
(paren
id|pdu
)paren
op_logical_and
op_logical_neg
(paren
id|skb-&gt;dev-&gt;flags
op_amp
id|IFF_LOOPBACK
)paren
)paren
id|skb_queue_tail
c_func
(paren
op_amp
id|llc_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|pdu_unack_q
comma
id|skb
)paren
suffix:semicolon
id|mac_send_pdu
c_func
(paren
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|LLC_PDU_TYPE_IS_I
c_func
(paren
id|pdu
)paren
op_logical_or
(paren
id|skb-&gt;dev
op_logical_and
id|skb-&gt;dev-&gt;flags
op_amp
id|IFF_LOOPBACK
)paren
)paren
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; *&t;llc_conn_free_ev - free event&n; *&t;@ev: event to free&n; *&n; *&t;Free allocated event.&n; */
DECL|function|llc_conn_free_ev
r_void
id|llc_conn_free_ev
c_func
(paren
r_struct
id|llc_conn_state_ev
op_star
id|ev
)paren
(brace
r_if
c_cond
(paren
id|ev-&gt;type
op_eq
id|LLC_CONN_EV_TYPE_PDU
)paren
(brace
multiline_comment|/* free the frame that binded to this event */
id|llc_pdu_sn_t
op_star
id|pdu
op_assign
(paren
id|llc_pdu_sn_t
op_star
)paren
id|ev-&gt;data.pdu.skb-&gt;nh.raw
suffix:semicolon
r_if
c_cond
(paren
id|LLC_PDU_TYPE_IS_I
c_func
(paren
id|pdu
)paren
op_logical_or
op_logical_neg
id|ev-&gt;flag
op_logical_or
op_logical_neg
id|ev-&gt;ind_prim
)paren
id|kfree_skb
c_func
(paren
id|ev-&gt;data.pdu.skb
)paren
suffix:semicolon
)brace
multiline_comment|/* free event structure to free list of the same */
id|kfree
c_func
(paren
id|ev
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;llc_conn_service - finds transition and changes state of connection&n; *&t;@sk: connection&n; *&t;@ev: happened event&n; *&n; *&t;This function finds transition that matches with happened event, then&n; *&t;executes related actions and finally changes state of connection.&n; *&t;Returns 0 for success, 1 for failure.&n; */
DECL|function|llc_conn_service
r_static
r_int
id|llc_conn_service
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|llc_conn_state_ev
op_star
id|ev
)paren
(brace
r_int
id|rc
op_assign
l_int|1
suffix:semicolon
r_struct
id|llc_conn_state_trans
op_star
id|trans
suffix:semicolon
r_if
c_cond
(paren
id|llc_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|state
OG
id|NBR_CONN_STATES
)paren
r_goto
id|out
suffix:semicolon
id|rc
op_assign
l_int|0
suffix:semicolon
id|trans
op_assign
id|llc_qualify_conn_ev
c_func
(paren
id|sk
comma
id|ev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|trans
)paren
(brace
id|rc
op_assign
id|llc_exec_conn_trans_actions
c_func
(paren
id|sk
comma
id|trans
comma
id|ev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rc
op_logical_and
id|trans-&gt;next_state
op_ne
id|NO_STATE_CHANGE
)paren
id|llc_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|state
op_assign
id|trans-&gt;next_state
suffix:semicolon
)brace
id|out
suffix:colon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;llc_qualify_conn_ev - finds transition for event&n; *&t;@sk: connection&n; *&t;@ev: happened event&n; *&n; *&t;This function finds transition that matches with happened event.&n; *&t;Returns pointer to found transition on success, %NULL otherwise.&n; */
r_static
r_struct
id|llc_conn_state_trans
op_star
DECL|function|llc_qualify_conn_ev
id|llc_qualify_conn_ev
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|llc_conn_state_ev
op_star
id|ev
)paren
(brace
r_struct
id|llc_conn_state_trans
op_star
op_star
id|next_trans
suffix:semicolon
id|llc_conn_ev_qfyr_t
op_star
id|next_qualifier
suffix:semicolon
r_struct
id|llc_conn_state
op_star
id|curr_state
op_assign
op_amp
id|llc_conn_state_table
(braket
id|llc_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|state
op_minus
l_int|1
)braket
suffix:semicolon
multiline_comment|/* search thru events for this state until&n;&t; * list exhausted or until no more&n;&t; */
r_for
c_loop
(paren
id|next_trans
op_assign
id|curr_state-&gt;transitions
op_plus
id|llc_find_offset
c_func
(paren
id|llc_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|state
op_minus
l_int|1
comma
id|ev-&gt;type
)paren
suffix:semicolon
(paren
op_star
id|next_trans
)paren
op_member_access_from_pointer
id|ev
suffix:semicolon
id|next_trans
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
op_star
id|next_trans
)paren
op_member_access_from_pointer
id|ev
)paren
(paren
id|sk
comma
id|ev
)paren
)paren
(brace
multiline_comment|/* got POSSIBLE event match; the event may require&n;&t;&t;&t; * qualification based on the values of a number of&n;&t;&t;&t; * state flags; if all qualifications are met (i.e.,&n;&t;&t;&t; * if all qualifying functions return success, or 0,&n;&t;&t;&t; * then this is THE event we&squot;re looking for&n;&t;&t;&t; */
r_for
c_loop
(paren
id|next_qualifier
op_assign
(paren
op_star
id|next_trans
)paren
op_member_access_from_pointer
id|ev_qualifiers
suffix:semicolon
id|next_qualifier
op_logical_and
op_star
id|next_qualifier
op_logical_and
op_logical_neg
(paren
op_star
id|next_qualifier
)paren
(paren
id|sk
comma
id|ev
)paren
suffix:semicolon
id|next_qualifier
op_increment
)paren
multiline_comment|/* nothing */
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|next_qualifier
op_logical_or
op_logical_neg
op_star
id|next_qualifier
)paren
multiline_comment|/* all qualifiers executed successfully; this is&n;&t;&t;&t;&t; * our transition; return it so we can perform&n;&t;&t;&t;&t; * the associated actions &amp; change the state&n;&t;&t;&t;&t; */
r_return
op_star
id|next_trans
suffix:semicolon
)brace
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;llc_exec_conn_trans_actions - executes related actions&n; *&t;@sk: connection&n; *&t;@trans: transition that it&squot;s actions must be performed&n; *&t;@ev: happened event&n; *&n; *&t;Executes actions that is related to happened event. Returns 0 for&n; *&t;success, 1 to indicate failure of at least one action or 2 if the&n; *&t;connection was freed (llc_conn_disc was called)&n; */
DECL|function|llc_exec_conn_trans_actions
r_static
r_int
id|llc_exec_conn_trans_actions
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|llc_conn_state_trans
op_star
id|trans
comma
r_struct
id|llc_conn_state_ev
op_star
id|ev
)paren
(brace
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
id|llc_conn_action_t
op_star
id|next_action
suffix:semicolon
r_for
c_loop
(paren
id|next_action
op_assign
id|trans-&gt;ev_actions
suffix:semicolon
id|next_action
op_logical_and
op_star
id|next_action
suffix:semicolon
id|next_action
op_increment
)paren
(brace
r_int
id|rc2
op_assign
(paren
op_star
id|next_action
)paren
(paren
id|sk
comma
id|ev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc2
op_eq
l_int|2
)paren
(brace
id|rc
op_assign
id|rc2
suffix:semicolon
r_break
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|rc2
)paren
id|rc
op_assign
l_int|1
suffix:semicolon
)brace
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;llc_find_sock - Finds connection in sap for the remote/local sap/mac&n; *&t;@sap: SAP&n; *&t;@daddr: address of remote LLC (MAC + SAP)&n; *&t;@laddr: address of local LLC (MAC + SAP)&n; *&n; *&t;Search connection list of the SAP and finds connection using the remote&n; *&t;mac, remote sap, local mac, and local sap. Returns pointer for&n; *&t;connection found, %NULL otherwise.&n; */
DECL|function|llc_find_sock
r_struct
id|sock
op_star
id|llc_find_sock
c_func
(paren
r_struct
id|llc_sap
op_star
id|sap
comma
r_struct
id|llc_addr
op_star
id|daddr
comma
r_struct
id|llc_addr
op_star
id|laddr
)paren
(brace
r_struct
id|sock
op_star
id|rc
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|list_head
op_star
id|entry
suffix:semicolon
id|spin_lock_bh
c_func
(paren
op_amp
id|sap-&gt;sk_list.lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|sap-&gt;sk_list.list
)paren
)paren
r_goto
id|out
suffix:semicolon
id|list_for_each
c_func
(paren
id|entry
comma
op_amp
id|sap-&gt;sk_list.list
)paren
(brace
r_struct
id|llc_opt
op_star
id|llc
op_assign
id|list_entry
c_func
(paren
id|entry
comma
r_struct
id|llc_opt
comma
id|node
)paren
suffix:semicolon
r_if
c_cond
(paren
id|llc-&gt;laddr.lsap
op_eq
id|laddr-&gt;lsap
op_logical_and
id|llc-&gt;daddr.lsap
op_eq
id|daddr-&gt;lsap
op_logical_and
op_logical_neg
id|memcmp
c_func
(paren
id|llc-&gt;laddr.mac
comma
id|laddr-&gt;mac
comma
id|ETH_ALEN
)paren
op_logical_and
op_logical_neg
id|memcmp
c_func
(paren
id|llc-&gt;daddr.mac
comma
id|daddr-&gt;mac
comma
id|ETH_ALEN
)paren
)paren
(brace
id|rc
op_assign
id|llc-&gt;sk
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|rc
)paren
id|sock_hold
c_func
(paren
id|rc
)paren
suffix:semicolon
id|out
suffix:colon
id|spin_unlock_bh
c_func
(paren
op_amp
id|sap-&gt;sk_list.lock
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;llc_data_accept_state - designates if in this state data can be sent.&n; *&t;@state: state of connection.&n; *&n; *&t;Returns 0 if data can be sent, 1 otherwise.&n; */
DECL|function|llc_data_accept_state
id|u8
id|llc_data_accept_state
c_func
(paren
id|u8
id|state
)paren
(brace
r_if
c_cond
(paren
id|state
op_ne
id|LLC_CONN_STATE_NORMAL
op_logical_and
id|state
op_ne
id|LLC_CONN_STATE_BUSY
op_logical_and
id|state
op_ne
id|LLC_CONN_STATE_REJ
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* data_conn_refuse */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;find_next_offset - finds offset for next category of transitions&n; *&t;@state: state table.&n; *&t;@offset: start offset.&n; *&n; *&t;Finds offset of next category of transitions in transition table.&n; *&t;Returns the start index of next category.&n; */
DECL|function|find_next_offset
id|u16
id|find_next_offset
c_func
(paren
r_struct
id|llc_conn_state
op_star
id|state
comma
id|u16
id|offset
)paren
(brace
id|u16
id|cnt
op_assign
l_int|0
suffix:semicolon
r_struct
id|llc_conn_state_trans
op_star
op_star
id|next_trans
suffix:semicolon
r_for
c_loop
(paren
id|next_trans
op_assign
id|state-&gt;transitions
op_plus
id|offset
suffix:semicolon
(paren
op_star
id|next_trans
)paren
op_member_access_from_pointer
id|ev
suffix:semicolon
id|next_trans
op_increment
)paren
op_increment
id|cnt
suffix:semicolon
r_return
id|cnt
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;llc_build_offset_table - builds offset table of connection&n; *&n; *&t;Fills offset table of connection state transition table&n; *&t;(llc_offset_table).&n; */
DECL|function|llc_build_offset_table
r_void
id|__init
id|llc_build_offset_table
c_func
(paren
r_void
)paren
(brace
r_struct
id|llc_conn_state
op_star
id|curr_state
suffix:semicolon
r_int
id|state
comma
id|ev_type
comma
id|next_offset
suffix:semicolon
id|memset
c_func
(paren
id|llc_offset_table
comma
l_int|0
comma
r_sizeof
(paren
id|llc_offset_table
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|state
op_assign
l_int|0
suffix:semicolon
id|state
OL
id|NBR_CONN_STATES
suffix:semicolon
id|state
op_increment
)paren
(brace
id|curr_state
op_assign
op_amp
id|llc_conn_state_table
(braket
id|state
)braket
suffix:semicolon
id|next_offset
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|ev_type
op_assign
l_int|0
suffix:semicolon
id|ev_type
OL
id|NBR_CONN_EV
suffix:semicolon
id|ev_type
op_increment
)paren
(brace
id|llc_offset_table
(braket
id|state
)braket
(braket
id|ev_type
)braket
op_assign
id|next_offset
suffix:semicolon
id|next_offset
op_add_assign
id|find_next_offset
c_func
(paren
id|curr_state
comma
id|next_offset
)paren
op_plus
l_int|1
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/**&n; *&t;llc_find_offset - finds start offset of category of transitions&n; *&t;@state: state of connection&n; *&t;@ev_type: type of happened event&n; *&n; *&t;Finds start offset of desired category of transitions. Returns the&n; *&t;desired start offset.&n; */
DECL|function|llc_find_offset
r_static
r_int
id|llc_find_offset
c_func
(paren
r_int
id|state
comma
r_int
id|ev_type
)paren
(brace
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* at this stage, llc_offset_table[..][2] is not important. it is for&n;&t; * init_pf_cycle and I don&squot;t know what is it.&n;&t; */
r_switch
c_cond
(paren
id|ev_type
)paren
(brace
r_case
id|LLC_CONN_EV_TYPE_PRIM
suffix:colon
id|rc
op_assign
id|llc_offset_table
(braket
id|state
)braket
(braket
l_int|0
)braket
suffix:semicolon
r_break
suffix:semicolon
r_case
id|LLC_CONN_EV_TYPE_PDU
suffix:colon
id|rc
op_assign
id|llc_offset_table
(braket
id|state
)braket
(braket
l_int|4
)braket
suffix:semicolon
r_break
suffix:semicolon
r_case
id|LLC_CONN_EV_TYPE_SIMPLE
suffix:colon
id|rc
op_assign
id|llc_offset_table
(braket
id|state
)braket
(braket
l_int|1
)braket
suffix:semicolon
r_break
suffix:semicolon
r_case
id|LLC_CONN_EV_TYPE_P_TMR
suffix:colon
r_case
id|LLC_CONN_EV_TYPE_ACK_TMR
suffix:colon
r_case
id|LLC_CONN_EV_TYPE_REJ_TMR
suffix:colon
r_case
id|LLC_CONN_EV_TYPE_BUSY_TMR
suffix:colon
id|rc
op_assign
id|llc_offset_table
(braket
id|state
)braket
(braket
l_int|3
)braket
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|rc
suffix:semicolon
)brace
eof
