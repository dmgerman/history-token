multiline_comment|/*&n; * llc_conn.c - Driver routines for connection component.&n; *&n; * Copyright (c) 1997 by Procom Technology, Inc.&n; *&t;&t; 2001 by Arnaldo Carvalho de Melo &lt;acme@conectiva.com.br&gt;&n; *&n; * This program can be redistributed or modified under the terms of the&n; * GNU General Public License as published by the Free Software Foundation.&n; * This program is distributed without any warranty or implied warranty&n; * of merchantability or fitness for a particular purpose.&n; *&n; * See the GNU General Public License for more details.&n; */
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;net/llc_if.h&gt;
macro_line|#include &lt;net/llc_sap.h&gt;
macro_line|#include &lt;net/llc_conn.h&gt;
macro_line|#include &lt;net/sock.h&gt;
macro_line|#include &lt;linux/tcp.h&gt;
macro_line|#include &lt;net/llc_main.h&gt;
macro_line|#include &lt;net/llc_c_ev.h&gt;
macro_line|#include &lt;net/llc_c_ac.h&gt;
macro_line|#include &lt;net/llc_c_st.h&gt;
macro_line|#include &lt;net/llc_mac.h&gt;
macro_line|#include &lt;net/llc_pdu.h&gt;
macro_line|#include &lt;net/llc_s_ev.h&gt;
r_static
r_int
id|llc_find_offset
c_func
(paren
r_int
id|state
comma
r_int
id|ev_type
)paren
suffix:semicolon
r_static
r_void
id|llc_conn_send_pdus
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
suffix:semicolon
r_static
r_int
id|llc_conn_service
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
suffix:semicolon
r_static
r_int
id|llc_exec_conn_trans_actions
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|llc_conn_state_trans
op_star
id|trans
comma
r_struct
id|sk_buff
op_star
id|ev
)paren
suffix:semicolon
r_static
r_struct
id|llc_conn_state_trans
op_star
id|llc_qualify_conn_ev
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
suffix:semicolon
multiline_comment|/* Offset table on connection states transition diagram */
DECL|variable|llc_offset_table
r_static
r_int
id|llc_offset_table
(braket
id|NBR_CONN_STATES
)braket
(braket
id|NBR_CONN_EV
)braket
suffix:semicolon
multiline_comment|/**&n; *&t;llc_conn_state_process - sends event to connection state machine&n; *&t;@sk: connection&n; *&t;@skb: occurred event&n; *&n; *&t;Sends an event to connection state machine. After processing event&n; *&t;(executing it&squot;s actions and changing state), upper layer will be&n; *&t;indicated or confirmed, if needed. Returns 0 for success, 1 for&n; *&t;failure. The socket lock has to be held before calling this function.&n; */
DECL|function|llc_conn_state_process
r_int
id|llc_conn_state_process
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
multiline_comment|/* sending event to state machine */
r_int
id|rc
op_assign
id|llc_conn_service
c_func
(paren
id|sk
comma
id|skb
)paren
suffix:semicolon
r_struct
id|llc_opt
op_star
id|llc
op_assign
id|llc_sk
c_func
(paren
id|sk
)paren
suffix:semicolon
r_struct
id|llc_conn_state_ev
op_star
id|ev
op_assign
id|llc_conn_ev
c_func
(paren
id|skb
)paren
suffix:semicolon
id|u8
id|flag
op_assign
id|ev-&gt;flag
suffix:semicolon
r_struct
id|llc_prim_if_block
op_star
id|ind_prim
op_assign
id|ev-&gt;ind_prim
suffix:semicolon
r_struct
id|llc_prim_if_block
op_star
id|cfm_prim
op_assign
id|ev-&gt;cfm_prim
suffix:semicolon
multiline_comment|/*&n;&t; * FIXME: this will vanish as soon I get rid of the last prim crap&n;&t; */
r_if
c_cond
(paren
id|flag
op_ne
id|LLC_DATA_PRIM
op_plus
l_int|1
op_logical_and
id|flag
op_ne
id|LLC_CONN_PRIM
op_plus
l_int|1
op_logical_and
id|flag
op_ne
id|LLC_DISC_PRIM
op_plus
l_int|1
)paren
id|llc_conn_free_ev
c_func
(paren
id|skb
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|ind_prim
op_logical_and
id|cfm_prim
)paren
id|skb_get
c_func
(paren
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|flag
)paren
multiline_comment|/* indicate or confirm not required */
r_goto
id|out
suffix:semicolon
id|rc
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ind_prim
)paren
(brace
multiline_comment|/* indication required */
multiline_comment|/*&n;&t;&t; * FIXME: this will be saner as soon I get rid of the double&n;&t;&t; *&t;  sock crap&n;&t;&t; */
r_switch
c_cond
(paren
id|flag
)paren
(brace
r_case
id|LLC_DATA_PRIM
op_plus
l_int|1
suffix:colon
r_if
c_cond
(paren
id|sock_queue_rcv_skb
c_func
(paren
id|sk
comma
id|skb
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * FIXME: have to sync the LLC state&n;&t;&t;&t;&t; *        machine wrt mem usage with&n;&t;&t;&t;&t; *        sk-&gt;{r,w}mem_alloc, will do&n;&t;&t;&t;&t; *        this soon 8)&n;&t;&t;&t;&t; */
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: sock_queue_rcv_skb failed!&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|LLC_CONN_PRIM
op_plus
l_int|1
suffix:colon
(brace
r_struct
id|sock
op_star
id|parent
op_assign
id|skb-&gt;sk
suffix:semicolon
id|skb-&gt;sk
op_assign
id|sk
suffix:semicolon
id|skb_queue_tail
c_func
(paren
op_amp
id|parent-&gt;receive_queue
comma
id|skb
)paren
suffix:semicolon
id|sk
op_member_access_from_pointer
id|state_change
c_func
(paren
id|parent
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|LLC_DISC_PRIM
op_plus
l_int|1
suffix:colon
id|sock_hold
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;type
op_eq
id|SOCK_STREAM
op_logical_and
id|sk-&gt;state
op_eq
id|TCP_ESTABLISHED
)paren
(brace
id|sk-&gt;shutdown
op_assign
id|SHUTDOWN_MASK
suffix:semicolon
id|sk-&gt;socket-&gt;state
op_assign
id|SS_UNCONNECTED
suffix:semicolon
id|sk-&gt;state
op_assign
id|TCP_CLOSE
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;dead
)paren
(brace
id|sk
op_member_access_from_pointer
id|state_change
c_func
(paren
id|sk
)paren
suffix:semicolon
id|sk-&gt;dead
op_assign
l_int|1
suffix:semicolon
)brace
)brace
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
id|sock_put
c_func
(paren
id|sk
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|llc-&gt;sap
op_member_access_from_pointer
id|ind
c_func
(paren
id|ind_prim
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|cfm_prim
)paren
multiline_comment|/* confirmation not required */
r_goto
id|out
suffix:semicolon
multiline_comment|/* FIXME: see FIXMEs above */
r_switch
c_cond
(paren
id|flag
)paren
(brace
r_case
id|LLC_DATA_PRIM
op_plus
l_int|1
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|llc_data_accept_state
c_func
(paren
id|llc-&gt;state
)paren
)paren
multiline_comment|/* In this state, we can send I pdu */
id|sk
op_member_access_from_pointer
id|write_space
c_func
(paren
id|sk
)paren
suffix:semicolon
r_else
id|rc
op_assign
id|llc-&gt;failed_data_req
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|LLC_CONN_PRIM
op_plus
l_int|1
suffix:colon
r_if
c_cond
(paren
id|sk-&gt;type
op_ne
id|SOCK_STREAM
op_logical_or
id|sk-&gt;state
op_ne
id|TCP_SYN_SENT
)paren
r_goto
id|out_kfree_skb
suffix:semicolon
r_if
c_cond
(paren
id|ev-&gt;status
)paren
(brace
id|sk-&gt;socket-&gt;state
op_assign
id|SS_UNCONNECTED
suffix:semicolon
id|sk-&gt;state
op_assign
id|TCP_CLOSE
suffix:semicolon
)brace
r_else
(brace
id|sk-&gt;socket-&gt;state
op_assign
id|SS_CONNECTED
suffix:semicolon
id|sk-&gt;state
op_assign
id|TCP_ESTABLISHED
suffix:semicolon
)brace
id|sk
op_member_access_from_pointer
id|state_change
c_func
(paren
id|sk
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|LLC_DISC_PRIM
op_plus
l_int|1
suffix:colon
id|sock_hold
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;type
op_ne
id|SOCK_STREAM
op_logical_or
id|sk-&gt;state
op_ne
id|TCP_CLOSING
)paren
(brace
id|sock_put
c_func
(paren
id|sk
)paren
suffix:semicolon
r_goto
id|out_kfree_skb
suffix:semicolon
)brace
id|sk-&gt;socket-&gt;state
op_assign
id|SS_UNCONNECTED
suffix:semicolon
id|sk-&gt;state
op_assign
id|TCP_CLOSE
suffix:semicolon
id|sk
op_member_access_from_pointer
id|state_change
c_func
(paren
id|sk
)paren
suffix:semicolon
id|sock_put
c_func
(paren
id|sk
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|llc-&gt;sap
op_member_access_from_pointer
id|conf
c_func
(paren
id|cfm_prim
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|out_kfree_skb
suffix:colon
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|rc
suffix:semicolon
)brace
DECL|function|llc_conn_send_pdu
r_void
id|llc_conn_send_pdu
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
multiline_comment|/* queue PDU to send to MAC layer */
id|skb_queue_tail
c_func
(paren
op_amp
id|sk-&gt;write_queue
comma
id|skb
)paren
suffix:semicolon
id|llc_conn_send_pdus
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;llc_conn_rtn_pdu - sends received data pdu to upper layer&n; *&t;@sk: Active connection&n; *&t;@skb: Received data frame&n; *&n; *&t;Sends received data pdu to upper layer (by using indicate function).&n; *&t;Prepares service parameters (prim and prim_data). calling indication&n; *&t;function will be done in llc_conn_state_process.&n; */
DECL|function|llc_conn_rtn_pdu
r_void
id|llc_conn_rtn_pdu
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|llc_conn_state_ev
op_star
id|ev
op_assign
id|llc_conn_ev
c_func
(paren
id|skb
)paren
suffix:semicolon
multiline_comment|/* FIXME: indicate that we should send this to the upper layer */
id|ev-&gt;flag
op_assign
id|LLC_DATA_PRIM
op_plus
l_int|1
suffix:semicolon
id|ev-&gt;ind_prim
op_assign
(paren
r_void
op_star
)paren
l_int|1
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;llc_conn_resend_i_pdu_as_cmd - resend all all unacknowledged I PDUs&n; *&t;@sk: active connection&n; *&t;@nr: NR&n; *&t;@first_p_bit: p_bit value of first pdu&n; *&n; *&t;Resend all unacknowledged I PDUs, starting with the NR; send first as&n; *&t;command PDU with P bit equal first_p_bit; if more than one send&n; *&t;subsequent as command PDUs with P bit equal zero (0).&n; */
DECL|function|llc_conn_resend_i_pdu_as_cmd
r_void
id|llc_conn_resend_i_pdu_as_cmd
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
id|u8
id|nr
comma
id|u8
id|first_p_bit
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_struct
id|llc_pdu_sn
op_star
id|pdu
suffix:semicolon
id|u16
id|nbr_unack_pdus
suffix:semicolon
id|u8
id|howmany_resend
op_assign
l_int|0
suffix:semicolon
id|llc_conn_remove_acked_pdus
c_func
(paren
id|sk
comma
id|nr
comma
op_amp
id|nbr_unack_pdus
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|nbr_unack_pdus
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* process unack PDUs only if unack queue is not empty; remove&n;&t; * appropriate PDUs, fix them up, and put them on mac_pdu_q.&n;&t; */
r_while
c_loop
(paren
(paren
id|skb
op_assign
id|skb_dequeue
c_func
(paren
op_amp
id|llc_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|pdu_unack_q
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|pdu
op_assign
(paren
r_struct
id|llc_pdu_sn
op_star
)paren
id|skb-&gt;nh.raw
suffix:semicolon
id|llc_pdu_set_cmd_rsp
c_func
(paren
id|skb
comma
id|LLC_PDU_CMD
)paren
suffix:semicolon
id|llc_pdu_set_pf_bit
c_func
(paren
id|skb
comma
id|first_p_bit
)paren
suffix:semicolon
id|skb_queue_tail
c_func
(paren
op_amp
id|sk-&gt;write_queue
comma
id|skb
)paren
suffix:semicolon
id|first_p_bit
op_assign
l_int|0
suffix:semicolon
id|llc_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|vS
op_assign
id|LLC_I_GET_NS
c_func
(paren
id|pdu
)paren
suffix:semicolon
id|howmany_resend
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|howmany_resend
OG
l_int|0
)paren
id|llc_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|vS
op_assign
(paren
id|llc_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|vS
op_plus
l_int|1
)paren
op_mod
id|LLC_2_SEQ_NBR_MODULO
suffix:semicolon
multiline_comment|/* any PDUs to re-send are queued up; start sending to MAC */
id|llc_conn_send_pdus
c_func
(paren
id|sk
)paren
suffix:semicolon
id|out
suffix:colon
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;llc_conn_resend_i_pdu_as_rsp - Resend all unacknowledged I PDUs&n; *&t;@sk: active connection.&n; *&t;@nr: NR&n; *&t;@first_f_bit: f_bit value of first pdu.&n; *&n; *&t;Resend all unacknowledged I PDUs, starting with the NR; send first as&n; *&t;response PDU with F bit equal first_f_bit; if more than one send&n; *&t;subsequent as response PDUs with F bit equal zero (0).&n; */
DECL|function|llc_conn_resend_i_pdu_as_rsp
r_void
id|llc_conn_resend_i_pdu_as_rsp
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
id|u8
id|nr
comma
id|u8
id|first_f_bit
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_struct
id|llc_pdu_sn
op_star
id|pdu
suffix:semicolon
id|u16
id|nbr_unack_pdus
suffix:semicolon
id|u8
id|howmany_resend
op_assign
l_int|0
suffix:semicolon
id|llc_conn_remove_acked_pdus
c_func
(paren
id|sk
comma
id|nr
comma
op_amp
id|nbr_unack_pdus
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|nbr_unack_pdus
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* process unack PDUs only if unack queue is not empty; remove&n;&t; * appropriate PDUs, fix them up, and put them on mac_pdu_q&n;&t; */
r_while
c_loop
(paren
(paren
id|skb
op_assign
id|skb_dequeue
c_func
(paren
op_amp
id|llc_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|pdu_unack_q
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|pdu
op_assign
(paren
r_struct
id|llc_pdu_sn
op_star
)paren
id|skb-&gt;nh.raw
suffix:semicolon
id|llc_pdu_set_cmd_rsp
c_func
(paren
id|skb
comma
id|LLC_PDU_RSP
)paren
suffix:semicolon
id|llc_pdu_set_pf_bit
c_func
(paren
id|skb
comma
id|first_f_bit
)paren
suffix:semicolon
id|skb_queue_tail
c_func
(paren
op_amp
id|sk-&gt;write_queue
comma
id|skb
)paren
suffix:semicolon
id|first_f_bit
op_assign
l_int|0
suffix:semicolon
id|llc_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|vS
op_assign
id|LLC_I_GET_NS
c_func
(paren
id|pdu
)paren
suffix:semicolon
id|howmany_resend
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|howmany_resend
OG
l_int|0
)paren
id|llc_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|vS
op_assign
(paren
id|llc_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|vS
op_plus
l_int|1
)paren
op_mod
id|LLC_2_SEQ_NBR_MODULO
suffix:semicolon
multiline_comment|/* any PDUs to re-send are queued up; start sending to MAC */
id|llc_conn_send_pdus
c_func
(paren
id|sk
)paren
suffix:semicolon
id|out
suffix:colon
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;llc_conn_remove_acked_pdus - Removes acknowledged pdus from tx queue&n; *&t;@sk: active connection&n; *&t;nr: NR&n; *&t;how_many_unacked: size of pdu_unack_q after removing acked pdus&n; *&n; *&t;Removes acknowledged pdus from transmit queue (pdu_unack_q). Returns&n; *&t;the number of pdus that removed from queue.&n; */
DECL|function|llc_conn_remove_acked_pdus
r_int
id|llc_conn_remove_acked_pdus
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
id|u8
id|nr
comma
id|u16
op_star
id|how_many_unacked
)paren
(brace
r_int
id|pdu_pos
comma
id|i
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_struct
id|llc_pdu_sn
op_star
id|pdu
suffix:semicolon
r_int
id|nbr_acked
op_assign
l_int|0
suffix:semicolon
r_int
id|q_len
op_assign
id|skb_queue_len
c_func
(paren
op_amp
id|llc_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|pdu_unack_q
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|q_len
)paren
r_goto
id|out
suffix:semicolon
id|skb
op_assign
id|skb_peek
c_func
(paren
op_amp
id|llc_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|pdu_unack_q
)paren
suffix:semicolon
id|pdu
op_assign
(paren
r_struct
id|llc_pdu_sn
op_star
)paren
id|skb-&gt;nh.raw
suffix:semicolon
multiline_comment|/* finding position of last acked pdu in queue */
id|pdu_pos
op_assign
(paren
(paren
r_int
)paren
id|LLC_2_SEQ_NBR_MODULO
op_plus
(paren
r_int
)paren
id|nr
op_minus
(paren
r_int
)paren
id|LLC_I_GET_NS
c_func
(paren
id|pdu
)paren
)paren
op_mod
id|LLC_2_SEQ_NBR_MODULO
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|pdu_pos
op_logical_and
id|i
OL
id|q_len
suffix:semicolon
id|i
op_increment
)paren
(brace
id|skb
op_assign
id|skb_dequeue
c_func
(paren
op_amp
id|llc_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|pdu_unack_q
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
)paren
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
id|nbr_acked
op_increment
suffix:semicolon
)brace
id|out
suffix:colon
op_star
id|how_many_unacked
op_assign
id|skb_queue_len
c_func
(paren
op_amp
id|llc_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|pdu_unack_q
)paren
suffix:semicolon
r_return
id|nbr_acked
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;llc_conn_send_pdus - Sends queued PDUs&n; *&t;@sk: active connection&n; *&n; *&t;Sends queued pdus to MAC layer for transmition.&n; */
DECL|function|llc_conn_send_pdus
r_static
r_void
id|llc_conn_send_pdus
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_while
c_loop
(paren
(paren
id|skb
op_assign
id|skb_dequeue
c_func
(paren
op_amp
id|sk-&gt;write_queue
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
r_struct
id|llc_pdu_sn
op_star
id|pdu
op_assign
(paren
r_struct
id|llc_pdu_sn
op_star
)paren
id|skb-&gt;nh.raw
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|LLC_PDU_TYPE_IS_I
c_func
(paren
id|pdu
)paren
op_logical_and
op_logical_neg
(paren
id|skb-&gt;dev-&gt;flags
op_amp
id|IFF_LOOPBACK
)paren
)paren
id|skb_queue_tail
c_func
(paren
op_amp
id|llc_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|pdu_unack_q
comma
id|skb
)paren
suffix:semicolon
id|mac_send_pdu
c_func
(paren
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|LLC_PDU_TYPE_IS_I
c_func
(paren
id|pdu
)paren
op_logical_or
(paren
id|skb-&gt;dev
op_logical_and
id|skb-&gt;dev-&gt;flags
op_amp
id|IFF_LOOPBACK
)paren
)paren
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; *&t;llc_conn_free_ev - free event&n; *&t;@skb: event to free&n; *&n; *&t;Free allocated event.&n; */
DECL|function|llc_conn_free_ev
r_void
id|llc_conn_free_ev
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|llc_conn_state_ev
op_star
id|ev
op_assign
id|llc_conn_ev
c_func
(paren
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ev-&gt;type
op_eq
id|LLC_CONN_EV_TYPE_PDU
)paren
(brace
multiline_comment|/* free the frame that is bound to this event */
r_struct
id|llc_pdu_sn
op_star
id|pdu
op_assign
id|llc_pdu_sn_hdr
c_func
(paren
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|LLC_PDU_TYPE_IS_I
c_func
(paren
id|pdu
)paren
op_logical_or
op_logical_neg
id|ev-&gt;flag
op_logical_or
op_logical_neg
id|ev-&gt;ind_prim
)paren
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ev-&gt;type
op_eq
id|LLC_CONN_EV_TYPE_PRIM
op_logical_and
id|ev-&gt;data.prim.prim
op_ne
id|LLC_DATA_PRIM
)paren
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|ev-&gt;type
op_eq
id|LLC_CONN_EV_TYPE_P_TMR
)paren
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;llc_conn_service - finds transition and changes state of connection&n; *&t;@sk: connection&n; *&t;@skb: happened event&n; *&n; *&t;This function finds transition that matches with happened event, then&n; *&t;executes related actions and finally changes state of connection.&n; *&t;Returns 0 for success, 1 for failure.&n; */
DECL|function|llc_conn_service
r_static
r_int
id|llc_conn_service
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_int
id|rc
op_assign
l_int|1
suffix:semicolon
r_struct
id|llc_conn_state_trans
op_star
id|trans
suffix:semicolon
r_if
c_cond
(paren
id|llc_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|state
OG
id|NBR_CONN_STATES
)paren
r_goto
id|out
suffix:semicolon
id|rc
op_assign
l_int|0
suffix:semicolon
id|trans
op_assign
id|llc_qualify_conn_ev
c_func
(paren
id|sk
comma
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|trans
)paren
(brace
id|rc
op_assign
id|llc_exec_conn_trans_actions
c_func
(paren
id|sk
comma
id|trans
comma
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rc
op_logical_and
id|trans-&gt;next_state
op_ne
id|NO_STATE_CHANGE
)paren
id|llc_sk
c_func
(paren
id|sk
)paren
op_member_access_from_pointer
id|state
op_assign
id|trans-&gt;next_state
suffix:semicolon
)brace
id|out
suffix:colon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;llc_qualify_conn_ev - finds transition for event&n; *&t;@sk: connection&n; *&t;@skb: happened event&n; *&n; *&t;This function finds transition that matches with happened event.&n; *&t;Returns pointer to found transition on success, %NULL otherwise.&n; */
DECL|function|llc_qualify_conn_ev
r_static
r_struct
id|llc_conn_state_trans
op_star
id|llc_qualify_conn_ev
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|llc_conn_state_trans
op_star
op_star
id|next_trans
suffix:semicolon
id|llc_conn_ev_qfyr_t
op_star
id|next_qualifier
suffix:semicolon
r_struct
id|llc_conn_state_ev
op_star
id|ev
op_assign
id|llc_conn_ev
c_func
(paren
id|skb
)paren
suffix:semicolon
r_struct
id|llc_opt
op_star
id|llc
op_assign
id|llc_sk
c_func
(paren
id|sk
)paren
suffix:semicolon
r_struct
id|llc_conn_state
op_star
id|curr_state
op_assign
op_amp
id|llc_conn_state_table
(braket
id|llc-&gt;state
op_minus
l_int|1
)braket
suffix:semicolon
multiline_comment|/* search thru events for this state until&n;&t; * list exhausted or until no more&n;&t; */
r_for
c_loop
(paren
id|next_trans
op_assign
id|curr_state-&gt;transitions
op_plus
id|llc_find_offset
c_func
(paren
id|llc-&gt;state
op_minus
l_int|1
comma
id|ev-&gt;type
)paren
suffix:semicolon
(paren
op_star
id|next_trans
)paren
op_member_access_from_pointer
id|ev
suffix:semicolon
id|next_trans
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
op_star
id|next_trans
)paren
op_member_access_from_pointer
id|ev
)paren
(paren
id|sk
comma
id|skb
)paren
)paren
(brace
multiline_comment|/* got POSSIBLE event match; the event may require&n;&t;&t;&t; * qualification based on the values of a number of&n;&t;&t;&t; * state flags; if all qualifications are met (i.e.,&n;&t;&t;&t; * if all qualifying functions return success, or 0,&n;&t;&t;&t; * then this is THE event we&squot;re looking for&n;&t;&t;&t; */
r_for
c_loop
(paren
id|next_qualifier
op_assign
(paren
op_star
id|next_trans
)paren
op_member_access_from_pointer
id|ev_qualifiers
suffix:semicolon
id|next_qualifier
op_logical_and
op_star
id|next_qualifier
op_logical_and
op_logical_neg
(paren
op_star
id|next_qualifier
)paren
(paren
id|sk
comma
id|skb
)paren
suffix:semicolon
id|next_qualifier
op_increment
)paren
multiline_comment|/* nothing */
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|next_qualifier
op_logical_or
op_logical_neg
op_star
id|next_qualifier
)paren
multiline_comment|/* all qualifiers executed successfully; this is&n;&t;&t;&t;&t; * our transition; return it so we can perform&n;&t;&t;&t;&t; * the associated actions &amp; change the state&n;&t;&t;&t;&t; */
r_return
op_star
id|next_trans
suffix:semicolon
)brace
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;llc_exec_conn_trans_actions - executes related actions&n; *&t;@sk: connection&n; *&t;@trans: transition that it&squot;s actions must be performed&n; *&t;@skb: event&n; *&n; *&t;Executes actions that is related to happened event. Returns 0 for&n; *&t;success, 1 to indicate failure of at least one action.&n; */
DECL|function|llc_exec_conn_trans_actions
r_static
r_int
id|llc_exec_conn_trans_actions
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|llc_conn_state_trans
op_star
id|trans
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
id|llc_conn_action_t
op_star
id|next_action
suffix:semicolon
r_for
c_loop
(paren
id|next_action
op_assign
id|trans-&gt;ev_actions
suffix:semicolon
id|next_action
op_logical_and
op_star
id|next_action
suffix:semicolon
id|next_action
op_increment
)paren
(brace
r_int
id|rc2
op_assign
(paren
op_star
id|next_action
)paren
(paren
id|sk
comma
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc2
op_eq
l_int|2
)paren
(brace
id|rc
op_assign
id|rc2
suffix:semicolon
r_break
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|rc2
)paren
id|rc
op_assign
l_int|1
suffix:semicolon
)brace
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;llc_lookup_established - Finds connection for the remote/local sap/mac&n; *&t;@sap: SAP&n; *&t;@daddr: address of remote LLC (MAC + SAP)&n; *&t;@laddr: address of local LLC (MAC + SAP)&n; *&n; *&t;Search connection list of the SAP and finds connection using the remote&n; *&t;mac, remote sap, local mac, and local sap. Returns pointer for&n; *&t;connection found, %NULL otherwise.&n; */
DECL|function|llc_lookup_established
r_struct
id|sock
op_star
id|llc_lookup_established
c_func
(paren
r_struct
id|llc_sap
op_star
id|sap
comma
r_struct
id|llc_addr
op_star
id|daddr
comma
r_struct
id|llc_addr
op_star
id|laddr
)paren
(brace
r_struct
id|sock
op_star
id|rc
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|list_head
op_star
id|entry
suffix:semicolon
id|spin_lock_bh
c_func
(paren
op_amp
id|sap-&gt;sk_list.lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|sap-&gt;sk_list.list
)paren
)paren
r_goto
id|out
suffix:semicolon
id|list_for_each
c_func
(paren
id|entry
comma
op_amp
id|sap-&gt;sk_list.list
)paren
(brace
r_struct
id|llc_opt
op_star
id|llc
op_assign
id|list_entry
c_func
(paren
id|entry
comma
r_struct
id|llc_opt
comma
id|node
)paren
suffix:semicolon
r_if
c_cond
(paren
id|llc-&gt;laddr.lsap
op_eq
id|laddr-&gt;lsap
op_logical_and
id|llc-&gt;daddr.lsap
op_eq
id|daddr-&gt;lsap
op_logical_and
id|llc_mac_match
c_func
(paren
id|llc-&gt;laddr.mac
comma
id|laddr-&gt;mac
)paren
op_logical_and
id|llc_mac_match
c_func
(paren
id|llc-&gt;daddr.mac
comma
id|daddr-&gt;mac
)paren
)paren
(brace
id|rc
op_assign
id|llc-&gt;sk
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|rc
)paren
id|sock_hold
c_func
(paren
id|rc
)paren
suffix:semicolon
id|out
suffix:colon
id|spin_unlock_bh
c_func
(paren
op_amp
id|sap-&gt;sk_list.lock
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;llc_lookup_listener - Finds listener for local MAC + SAP&n; *&t;@sap: SAP&n; *&t;@laddr: address of local LLC (MAC + SAP)&n; *&n; *&t;Search connection list of the SAP and finds connection listening on&n; *&t;local mac, and local sap. Returns pointer for parent socket found,&n; *&t;%NULL otherwise.&n; */
DECL|function|llc_lookup_listener
r_struct
id|sock
op_star
id|llc_lookup_listener
c_func
(paren
r_struct
id|llc_sap
op_star
id|sap
comma
r_struct
id|llc_addr
op_star
id|laddr
)paren
(brace
r_struct
id|sock
op_star
id|rc
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|list_head
op_star
id|entry
suffix:semicolon
id|spin_lock_bh
c_func
(paren
op_amp
id|sap-&gt;sk_list.lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|sap-&gt;sk_list.list
)paren
)paren
r_goto
id|out
suffix:semicolon
id|list_for_each
c_func
(paren
id|entry
comma
op_amp
id|sap-&gt;sk_list.list
)paren
(brace
r_struct
id|llc_opt
op_star
id|llc
op_assign
id|list_entry
c_func
(paren
id|entry
comma
r_struct
id|llc_opt
comma
id|node
)paren
suffix:semicolon
r_if
c_cond
(paren
id|llc-&gt;sk-&gt;type
op_ne
id|SOCK_STREAM
op_logical_or
id|llc-&gt;sk-&gt;state
op_ne
id|TCP_LISTEN
op_logical_or
id|llc-&gt;laddr.lsap
op_ne
id|laddr-&gt;lsap
op_logical_or
op_logical_neg
id|llc_mac_match
c_func
(paren
id|llc-&gt;laddr.mac
comma
id|laddr-&gt;mac
)paren
)paren
r_continue
suffix:semicolon
id|rc
op_assign
id|llc-&gt;sk
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rc
)paren
id|sock_hold
c_func
(paren
id|rc
)paren
suffix:semicolon
id|out
suffix:colon
id|spin_unlock_bh
c_func
(paren
op_amp
id|sap-&gt;sk_list.lock
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;llc_data_accept_state - designates if in this state data can be sent.&n; *&t;@state: state of connection.&n; *&n; *&t;Returns 0 if data can be sent, 1 otherwise.&n; */
DECL|function|llc_data_accept_state
id|u8
id|llc_data_accept_state
c_func
(paren
id|u8
id|state
)paren
(brace
r_return
id|state
op_ne
id|LLC_CONN_STATE_NORMAL
op_logical_and
id|state
op_ne
id|LLC_CONN_STATE_BUSY
op_logical_and
id|state
op_ne
id|LLC_CONN_STATE_REJ
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;find_next_offset - finds offset for next category of transitions&n; *&t;@state: state table.&n; *&t;@offset: start offset.&n; *&n; *&t;Finds offset of next category of transitions in transition table.&n; *&t;Returns the start index of next category.&n; */
DECL|function|find_next_offset
id|u16
id|find_next_offset
c_func
(paren
r_struct
id|llc_conn_state
op_star
id|state
comma
id|u16
id|offset
)paren
(brace
id|u16
id|cnt
op_assign
l_int|0
suffix:semicolon
r_struct
id|llc_conn_state_trans
op_star
op_star
id|next_trans
suffix:semicolon
r_for
c_loop
(paren
id|next_trans
op_assign
id|state-&gt;transitions
op_plus
id|offset
suffix:semicolon
(paren
op_star
id|next_trans
)paren
op_member_access_from_pointer
id|ev
suffix:semicolon
id|next_trans
op_increment
)paren
op_increment
id|cnt
suffix:semicolon
r_return
id|cnt
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;llc_build_offset_table - builds offset table of connection&n; *&n; *&t;Fills offset table of connection state transition table&n; *&t;(llc_offset_table).&n; */
DECL|function|llc_build_offset_table
r_void
id|__init
id|llc_build_offset_table
c_func
(paren
r_void
)paren
(brace
r_struct
id|llc_conn_state
op_star
id|curr_state
suffix:semicolon
r_int
id|state
comma
id|ev_type
comma
id|next_offset
suffix:semicolon
r_for
c_loop
(paren
id|state
op_assign
l_int|0
suffix:semicolon
id|state
OL
id|NBR_CONN_STATES
suffix:semicolon
id|state
op_increment
)paren
(brace
id|curr_state
op_assign
op_amp
id|llc_conn_state_table
(braket
id|state
)braket
suffix:semicolon
id|next_offset
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|ev_type
op_assign
l_int|0
suffix:semicolon
id|ev_type
OL
id|NBR_CONN_EV
suffix:semicolon
id|ev_type
op_increment
)paren
(brace
id|llc_offset_table
(braket
id|state
)braket
(braket
id|ev_type
)braket
op_assign
id|next_offset
suffix:semicolon
id|next_offset
op_add_assign
id|find_next_offset
c_func
(paren
id|curr_state
comma
id|next_offset
)paren
op_plus
l_int|1
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/**&n; *&t;llc_find_offset - finds start offset of category of transitions&n; *&t;@state: state of connection&n; *&t;@ev_type: type of happened event&n; *&n; *&t;Finds start offset of desired category of transitions. Returns the&n; *&t;desired start offset.&n; */
DECL|function|llc_find_offset
r_static
r_int
id|llc_find_offset
c_func
(paren
r_int
id|state
comma
r_int
id|ev_type
)paren
(brace
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* at this stage, llc_offset_table[..][2] is not important. it is for&n;&t; * init_pf_cycle and I don&squot;t know what is it.&n;&t; */
r_switch
c_cond
(paren
id|ev_type
)paren
(brace
r_case
id|LLC_CONN_EV_TYPE_PRIM
suffix:colon
id|rc
op_assign
id|llc_offset_table
(braket
id|state
)braket
(braket
l_int|0
)braket
suffix:semicolon
r_break
suffix:semicolon
r_case
id|LLC_CONN_EV_TYPE_PDU
suffix:colon
id|rc
op_assign
id|llc_offset_table
(braket
id|state
)braket
(braket
l_int|4
)braket
suffix:semicolon
r_break
suffix:semicolon
r_case
id|LLC_CONN_EV_TYPE_SIMPLE
suffix:colon
id|rc
op_assign
id|llc_offset_table
(braket
id|state
)braket
(braket
l_int|1
)braket
suffix:semicolon
r_break
suffix:semicolon
r_case
id|LLC_CONN_EV_TYPE_P_TMR
suffix:colon
r_case
id|LLC_CONN_EV_TYPE_ACK_TMR
suffix:colon
r_case
id|LLC_CONN_EV_TYPE_REJ_TMR
suffix:colon
r_case
id|LLC_CONN_EV_TYPE_BUSY_TMR
suffix:colon
id|rc
op_assign
id|llc_offset_table
(braket
id|state
)braket
(braket
l_int|3
)braket
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|rc
suffix:semicolon
)brace
eof
