multiline_comment|/* &n; * xfrm_policy.c&n; *&n; * Changes:&n; *&t;Mitsuru KANDA @USAGI&n; * &t;Kazunori MIYAZAWA @USAGI&n; * &t;Kunihiro Ishiguro &lt;kunihiro@ipinfusion.com&gt;&n; * &t;&t;IPv6 support&n; * &t;Kazunori MIYAZAWA @USAGI&n; * &t;YOSHIFUJI Hideaki&n; * &t;&t;Split up af-specific portion&n; *&t;Derek Atkins &lt;derek@ihtfp.com&gt;&t;&t;Add the post_input processor&n; * &t;&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/kmod.h&gt;
macro_line|#include &lt;linux/list.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/workqueue.h&gt;
macro_line|#include &lt;linux/notifier.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;net/xfrm.h&gt;
macro_line|#include &lt;net/ip.h&gt;
DECL|variable|xfrm_cfg_sem
id|DECLARE_MUTEX
c_func
(paren
id|xfrm_cfg_sem
)paren
suffix:semicolon
DECL|variable|xfrm_policy_lock
r_static
id|rwlock_t
id|xfrm_policy_lock
op_assign
id|RW_LOCK_UNLOCKED
suffix:semicolon
DECL|variable|xfrm_policy_list
r_struct
id|xfrm_policy
op_star
id|xfrm_policy_list
(braket
id|XFRM_POLICY_MAX
op_star
l_int|2
)braket
suffix:semicolon
DECL|variable|xfrm_policy_afinfo_lock
r_static
id|rwlock_t
id|xfrm_policy_afinfo_lock
op_assign
id|RW_LOCK_UNLOCKED
suffix:semicolon
DECL|variable|xfrm_policy_afinfo
r_static
r_struct
id|xfrm_policy_afinfo
op_star
id|xfrm_policy_afinfo
(braket
id|NPROTO
)braket
suffix:semicolon
DECL|variable|xfrm_dst_cache
id|kmem_cache_t
op_star
id|xfrm_dst_cache
suffix:semicolon
DECL|variable|xfrm_policy_gc_work
r_static
r_struct
id|work_struct
id|xfrm_policy_gc_work
suffix:semicolon
DECL|variable|xfrm_policy_gc_list
r_static
r_struct
id|list_head
id|xfrm_policy_gc_list
op_assign
id|LIST_HEAD_INIT
c_func
(paren
id|xfrm_policy_gc_list
)paren
suffix:semicolon
DECL|variable|xfrm_policy_gc_lock
r_static
id|spinlock_t
id|xfrm_policy_gc_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
r_static
r_struct
id|xfrm_policy_afinfo
op_star
id|xfrm_policy_get_afinfo
c_func
(paren
r_int
r_int
id|family
)paren
suffix:semicolon
r_static
r_void
id|xfrm_policy_put_afinfo
c_func
(paren
r_struct
id|xfrm_policy_afinfo
op_star
id|afinfo
)paren
suffix:semicolon
DECL|function|xfrm_register_type
r_int
id|xfrm_register_type
c_func
(paren
r_struct
id|xfrm_type
op_star
id|type
comma
r_int
r_int
id|family
)paren
(brace
r_struct
id|xfrm_policy_afinfo
op_star
id|afinfo
op_assign
id|xfrm_policy_get_afinfo
c_func
(paren
id|family
)paren
suffix:semicolon
r_struct
id|xfrm_type_map
op_star
id|typemap
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|afinfo
op_eq
l_int|NULL
)paren
)paren
r_return
op_minus
id|EAFNOSUPPORT
suffix:semicolon
id|typemap
op_assign
id|afinfo-&gt;type_map
suffix:semicolon
id|write_lock
c_func
(paren
op_amp
id|typemap-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
id|typemap-&gt;map
(braket
id|type-&gt;proto
)braket
op_eq
l_int|NULL
)paren
)paren
id|typemap-&gt;map
(braket
id|type-&gt;proto
)braket
op_assign
id|type
suffix:semicolon
r_else
id|err
op_assign
op_minus
id|EEXIST
suffix:semicolon
id|write_unlock
c_func
(paren
op_amp
id|typemap-&gt;lock
)paren
suffix:semicolon
id|xfrm_policy_put_afinfo
c_func
(paren
id|afinfo
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|function|xfrm_unregister_type
r_int
id|xfrm_unregister_type
c_func
(paren
r_struct
id|xfrm_type
op_star
id|type
comma
r_int
r_int
id|family
)paren
(brace
r_struct
id|xfrm_policy_afinfo
op_star
id|afinfo
op_assign
id|xfrm_policy_get_afinfo
c_func
(paren
id|family
)paren
suffix:semicolon
r_struct
id|xfrm_type_map
op_star
id|typemap
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|afinfo
op_eq
l_int|NULL
)paren
)paren
r_return
op_minus
id|EAFNOSUPPORT
suffix:semicolon
id|typemap
op_assign
id|afinfo-&gt;type_map
suffix:semicolon
id|write_lock
c_func
(paren
op_amp
id|typemap-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|typemap-&gt;map
(braket
id|type-&gt;proto
)braket
op_ne
id|type
)paren
)paren
id|err
op_assign
op_minus
id|ENOENT
suffix:semicolon
r_else
id|typemap-&gt;map
(braket
id|type-&gt;proto
)braket
op_assign
l_int|NULL
suffix:semicolon
id|write_unlock
c_func
(paren
op_amp
id|typemap-&gt;lock
)paren
suffix:semicolon
id|xfrm_policy_put_afinfo
c_func
(paren
id|afinfo
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|function|xfrm_get_type
r_struct
id|xfrm_type
op_star
id|xfrm_get_type
c_func
(paren
id|u8
id|proto
comma
r_int
r_int
id|family
)paren
(brace
r_struct
id|xfrm_policy_afinfo
op_star
id|afinfo
suffix:semicolon
r_struct
id|xfrm_type_map
op_star
id|typemap
suffix:semicolon
r_struct
id|xfrm_type
op_star
id|type
suffix:semicolon
r_int
id|modload_attempted
op_assign
l_int|0
suffix:semicolon
id|retry
suffix:colon
id|afinfo
op_assign
id|xfrm_policy_get_afinfo
c_func
(paren
id|family
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|afinfo
op_eq
l_int|NULL
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
id|typemap
op_assign
id|afinfo-&gt;type_map
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|typemap-&gt;lock
)paren
suffix:semicolon
id|type
op_assign
id|typemap-&gt;map
(braket
id|proto
)braket
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|type
op_logical_and
op_logical_neg
id|try_module_get
c_func
(paren
id|type-&gt;owner
)paren
)paren
)paren
id|type
op_assign
l_int|NULL
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|typemap-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|type
op_logical_and
op_logical_neg
id|modload_attempted
)paren
(brace
id|xfrm_policy_put_afinfo
c_func
(paren
id|afinfo
)paren
suffix:semicolon
id|request_module
c_func
(paren
l_string|&quot;xfrm-type-%d-%d&quot;
comma
(paren
r_int
)paren
id|family
comma
(paren
r_int
)paren
id|proto
)paren
suffix:semicolon
id|modload_attempted
op_assign
l_int|1
suffix:semicolon
r_goto
id|retry
suffix:semicolon
)brace
id|xfrm_policy_put_afinfo
c_func
(paren
id|afinfo
)paren
suffix:semicolon
r_return
id|type
suffix:semicolon
)brace
DECL|function|xfrm_dst_lookup
r_int
id|xfrm_dst_lookup
c_func
(paren
r_struct
id|xfrm_dst
op_star
op_star
id|dst
comma
r_struct
id|flowi
op_star
id|fl
comma
r_int
r_int
id|family
)paren
(brace
r_struct
id|xfrm_policy_afinfo
op_star
id|afinfo
op_assign
id|xfrm_policy_get_afinfo
c_func
(paren
id|family
)paren
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|afinfo
op_eq
l_int|NULL
)paren
)paren
r_return
op_minus
id|EAFNOSUPPORT
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
id|afinfo-&gt;dst_lookup
op_ne
l_int|NULL
)paren
)paren
id|err
op_assign
id|afinfo
op_member_access_from_pointer
id|dst_lookup
c_func
(paren
id|dst
comma
id|fl
)paren
suffix:semicolon
r_else
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
id|xfrm_policy_put_afinfo
c_func
(paren
id|afinfo
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|function|xfrm_put_type
r_void
id|xfrm_put_type
c_func
(paren
r_struct
id|xfrm_type
op_star
id|type
)paren
(brace
id|module_put
c_func
(paren
id|type-&gt;owner
)paren
suffix:semicolon
)brace
DECL|function|make_jiffies
r_static
r_inline
r_int
r_int
id|make_jiffies
c_func
(paren
r_int
id|secs
)paren
(brace
r_if
c_cond
(paren
id|secs
op_ge
(paren
id|MAX_SCHEDULE_TIMEOUT
op_minus
l_int|1
)paren
op_div
id|HZ
)paren
r_return
id|MAX_SCHEDULE_TIMEOUT
op_minus
l_int|1
suffix:semicolon
r_else
r_return
id|secs
op_star
id|HZ
suffix:semicolon
)brace
DECL|function|xfrm_policy_timer
r_static
r_void
id|xfrm_policy_timer
c_func
(paren
r_int
r_int
id|data
)paren
(brace
r_struct
id|xfrm_policy
op_star
id|xp
op_assign
(paren
r_struct
id|xfrm_policy
op_star
)paren
id|data
suffix:semicolon
r_int
r_int
id|now
op_assign
(paren
r_int
r_int
)paren
id|xtime.tv_sec
suffix:semicolon
r_int
id|next
op_assign
id|LONG_MAX
suffix:semicolon
r_int
id|warn
op_assign
l_int|0
suffix:semicolon
r_int
id|dir
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|xp-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|xp-&gt;dead
)paren
r_goto
id|out
suffix:semicolon
id|dir
op_assign
id|xp-&gt;index
op_amp
l_int|7
suffix:semicolon
r_if
c_cond
(paren
id|xp-&gt;lft.hard_add_expires_seconds
)paren
(brace
r_int
id|tmo
op_assign
id|xp-&gt;lft.hard_add_expires_seconds
op_plus
id|xp-&gt;curlft.add_time
op_minus
id|now
suffix:semicolon
r_if
c_cond
(paren
id|tmo
op_le
l_int|0
)paren
r_goto
id|expired
suffix:semicolon
r_if
c_cond
(paren
id|tmo
OL
id|next
)paren
id|next
op_assign
id|tmo
suffix:semicolon
)brace
r_if
c_cond
(paren
id|xp-&gt;lft.hard_use_expires_seconds
)paren
(brace
r_int
id|tmo
op_assign
id|xp-&gt;lft.hard_use_expires_seconds
op_plus
(paren
id|xp-&gt;curlft.use_time
ques
c_cond
suffix:colon
id|xp-&gt;curlft.add_time
)paren
op_minus
id|now
suffix:semicolon
r_if
c_cond
(paren
id|tmo
op_le
l_int|0
)paren
r_goto
id|expired
suffix:semicolon
r_if
c_cond
(paren
id|tmo
OL
id|next
)paren
id|next
op_assign
id|tmo
suffix:semicolon
)brace
r_if
c_cond
(paren
id|xp-&gt;lft.soft_add_expires_seconds
)paren
(brace
r_int
id|tmo
op_assign
id|xp-&gt;lft.soft_add_expires_seconds
op_plus
id|xp-&gt;curlft.add_time
op_minus
id|now
suffix:semicolon
r_if
c_cond
(paren
id|tmo
op_le
l_int|0
)paren
(brace
id|warn
op_assign
l_int|1
suffix:semicolon
id|tmo
op_assign
id|XFRM_KM_TIMEOUT
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tmo
OL
id|next
)paren
id|next
op_assign
id|tmo
suffix:semicolon
)brace
r_if
c_cond
(paren
id|xp-&gt;lft.soft_use_expires_seconds
)paren
(brace
r_int
id|tmo
op_assign
id|xp-&gt;lft.soft_use_expires_seconds
op_plus
(paren
id|xp-&gt;curlft.use_time
ques
c_cond
suffix:colon
id|xp-&gt;curlft.add_time
)paren
op_minus
id|now
suffix:semicolon
r_if
c_cond
(paren
id|tmo
op_le
l_int|0
)paren
(brace
id|warn
op_assign
l_int|1
suffix:semicolon
id|tmo
op_assign
id|XFRM_KM_TIMEOUT
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tmo
OL
id|next
)paren
id|next
op_assign
id|tmo
suffix:semicolon
)brace
r_if
c_cond
(paren
id|warn
)paren
id|km_policy_expired
c_func
(paren
id|xp
comma
id|dir
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|next
op_ne
id|LONG_MAX
op_logical_and
op_logical_neg
id|mod_timer
c_func
(paren
op_amp
id|xp-&gt;timer
comma
id|jiffies
op_plus
id|make_jiffies
c_func
(paren
id|next
)paren
)paren
)paren
id|xfrm_pol_hold
c_func
(paren
id|xp
)paren
suffix:semicolon
id|out
suffix:colon
id|read_unlock
c_func
(paren
op_amp
id|xp-&gt;lock
)paren
suffix:semicolon
id|xfrm_pol_put
c_func
(paren
id|xp
)paren
suffix:semicolon
r_return
suffix:semicolon
id|expired
suffix:colon
id|read_unlock
c_func
(paren
op_amp
id|xp-&gt;lock
)paren
suffix:semicolon
id|km_policy_expired
c_func
(paren
id|xp
comma
id|dir
comma
l_int|1
)paren
suffix:semicolon
id|xfrm_policy_delete
c_func
(paren
id|xp
comma
id|dir
)paren
suffix:semicolon
id|xfrm_pol_put
c_func
(paren
id|xp
)paren
suffix:semicolon
)brace
multiline_comment|/* Allocate xfrm_policy. Not used here, it is supposed to be used by pfkeyv2&n; * SPD calls.&n; */
DECL|function|xfrm_policy_alloc
r_struct
id|xfrm_policy
op_star
id|xfrm_policy_alloc
c_func
(paren
r_int
id|gfp
)paren
(brace
r_struct
id|xfrm_policy
op_star
id|policy
suffix:semicolon
id|policy
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|xfrm_policy
)paren
comma
id|gfp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|policy
)paren
(brace
id|memset
c_func
(paren
id|policy
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|xfrm_policy
)paren
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|policy-&gt;refcnt
comma
l_int|1
)paren
suffix:semicolon
id|rwlock_init
c_func
(paren
op_amp
id|policy-&gt;lock
)paren
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|policy-&gt;timer
)paren
suffix:semicolon
id|policy-&gt;timer.data
op_assign
(paren
r_int
r_int
)paren
id|policy
suffix:semicolon
id|policy-&gt;timer.function
op_assign
id|xfrm_policy_timer
suffix:semicolon
)brace
r_return
id|policy
suffix:semicolon
)brace
multiline_comment|/* Destroy xfrm_policy: descendant resources must be released to this moment. */
DECL|function|__xfrm_policy_destroy
r_void
id|__xfrm_policy_destroy
c_func
(paren
r_struct
id|xfrm_policy
op_star
id|policy
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|policy-&gt;dead
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|policy-&gt;bundles
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|del_timer
c_func
(paren
op_amp
id|policy-&gt;timer
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|policy
)paren
suffix:semicolon
)brace
DECL|function|xfrm_policy_gc_kill
r_static
r_void
id|xfrm_policy_gc_kill
c_func
(paren
r_struct
id|xfrm_policy
op_star
id|policy
)paren
(brace
r_struct
id|dst_entry
op_star
id|dst
suffix:semicolon
r_while
c_loop
(paren
(paren
id|dst
op_assign
id|policy-&gt;bundles
)paren
op_ne
l_int|NULL
)paren
(brace
id|policy-&gt;bundles
op_assign
id|dst-&gt;next
suffix:semicolon
id|dst_free
c_func
(paren
id|dst
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|del_timer
c_func
(paren
op_amp
id|policy-&gt;timer
)paren
)paren
id|atomic_dec
c_func
(paren
op_amp
id|policy-&gt;refcnt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|policy-&gt;refcnt
)paren
OG
l_int|1
)paren
id|flow_cache_flush
c_func
(paren
)paren
suffix:semicolon
id|xfrm_pol_put
c_func
(paren
id|policy
)paren
suffix:semicolon
)brace
DECL|function|xfrm_policy_gc_task
r_static
r_void
id|xfrm_policy_gc_task
c_func
(paren
r_void
op_star
id|data
)paren
(brace
r_struct
id|xfrm_policy
op_star
id|policy
suffix:semicolon
r_struct
id|list_head
op_star
id|entry
comma
op_star
id|tmp
suffix:semicolon
r_struct
id|list_head
id|gc_list
op_assign
id|LIST_HEAD_INIT
c_func
(paren
id|gc_list
)paren
suffix:semicolon
id|spin_lock_bh
c_func
(paren
op_amp
id|xfrm_policy_gc_lock
)paren
suffix:semicolon
id|list_splice_init
c_func
(paren
op_amp
id|xfrm_policy_gc_list
comma
op_amp
id|gc_list
)paren
suffix:semicolon
id|spin_unlock_bh
c_func
(paren
op_amp
id|xfrm_policy_gc_lock
)paren
suffix:semicolon
id|list_for_each_safe
c_func
(paren
id|entry
comma
id|tmp
comma
op_amp
id|gc_list
)paren
(brace
id|policy
op_assign
id|list_entry
c_func
(paren
id|entry
comma
r_struct
id|xfrm_policy
comma
id|list
)paren
suffix:semicolon
id|xfrm_policy_gc_kill
c_func
(paren
id|policy
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Rule must be locked. Release descentant resources, announce&n; * entry dead. The rule must be unlinked from lists to the moment.&n; */
DECL|function|xfrm_policy_kill
r_static
r_void
id|xfrm_policy_kill
c_func
(paren
r_struct
id|xfrm_policy
op_star
id|policy
)paren
(brace
id|write_lock_bh
c_func
(paren
op_amp
id|policy-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|policy-&gt;dead
)paren
r_goto
id|out
suffix:semicolon
id|policy-&gt;dead
op_assign
l_int|1
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|xfrm_policy_gc_lock
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|policy-&gt;list
comma
op_amp
id|xfrm_policy_gc_list
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|xfrm_policy_gc_lock
)paren
suffix:semicolon
id|schedule_work
c_func
(paren
op_amp
id|xfrm_policy_gc_work
)paren
suffix:semicolon
id|out
suffix:colon
id|write_unlock_bh
c_func
(paren
op_amp
id|policy-&gt;lock
)paren
suffix:semicolon
)brace
multiline_comment|/* Generate new index... KAME seems to generate them ordered by cost&n; * of an absolute inpredictability of ordering of rules. This will not pass. */
DECL|function|xfrm_gen_index
r_static
id|u32
id|xfrm_gen_index
c_func
(paren
r_int
id|dir
)paren
(brace
id|u32
id|idx
suffix:semicolon
r_struct
id|xfrm_policy
op_star
id|p
suffix:semicolon
r_static
id|u32
id|idx_generator
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|idx
op_assign
(paren
id|idx_generator
op_or
id|dir
)paren
suffix:semicolon
id|idx_generator
op_add_assign
l_int|8
suffix:semicolon
r_if
c_cond
(paren
id|idx
op_eq
l_int|0
)paren
id|idx
op_assign
l_int|8
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|xfrm_policy_list
(braket
id|dir
)braket
suffix:semicolon
id|p
suffix:semicolon
id|p
op_assign
id|p-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;index
op_eq
id|idx
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|p
)paren
r_return
id|idx
suffix:semicolon
)brace
)brace
DECL|function|xfrm_policy_insert
r_int
id|xfrm_policy_insert
c_func
(paren
r_int
id|dir
comma
r_struct
id|xfrm_policy
op_star
id|policy
comma
r_int
id|excl
)paren
(brace
r_struct
id|xfrm_policy
op_star
id|pol
comma
op_star
op_star
id|p
suffix:semicolon
r_struct
id|xfrm_policy
op_star
id|delpol
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|xfrm_policy
op_star
op_star
id|newpos
op_assign
l_int|NULL
suffix:semicolon
id|write_lock_bh
c_func
(paren
op_amp
id|xfrm_policy_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
op_amp
id|xfrm_policy_list
(braket
id|dir
)braket
suffix:semicolon
(paren
id|pol
op_assign
op_star
id|p
)paren
op_ne
l_int|NULL
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|delpol
op_logical_and
id|memcmp
c_func
(paren
op_amp
id|policy-&gt;selector
comma
op_amp
id|pol-&gt;selector
comma
r_sizeof
(paren
id|pol-&gt;selector
)paren
)paren
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|excl
)paren
(brace
id|write_unlock_bh
c_func
(paren
op_amp
id|xfrm_policy_lock
)paren
suffix:semicolon
r_return
op_minus
id|EEXIST
suffix:semicolon
)brace
op_star
id|p
op_assign
id|pol-&gt;next
suffix:semicolon
id|delpol
op_assign
id|pol
suffix:semicolon
r_if
c_cond
(paren
id|policy-&gt;priority
OG
id|pol-&gt;priority
)paren
r_continue
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|policy-&gt;priority
op_ge
id|pol-&gt;priority
)paren
(brace
id|p
op_assign
op_amp
id|pol-&gt;next
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|newpos
)paren
id|newpos
op_assign
id|p
suffix:semicolon
r_if
c_cond
(paren
id|delpol
)paren
r_break
suffix:semicolon
id|p
op_assign
op_amp
id|pol-&gt;next
suffix:semicolon
)brace
r_if
c_cond
(paren
id|newpos
)paren
id|p
op_assign
id|newpos
suffix:semicolon
id|xfrm_pol_hold
c_func
(paren
id|policy
)paren
suffix:semicolon
id|policy-&gt;next
op_assign
op_star
id|p
suffix:semicolon
op_star
id|p
op_assign
id|policy
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|flow_cache_genid
)paren
suffix:semicolon
id|policy-&gt;index
op_assign
id|delpol
ques
c_cond
id|delpol-&gt;index
suffix:colon
id|xfrm_gen_index
c_func
(paren
id|dir
)paren
suffix:semicolon
id|policy-&gt;curlft.add_time
op_assign
(paren
r_int
r_int
)paren
id|xtime.tv_sec
suffix:semicolon
id|policy-&gt;curlft.use_time
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mod_timer
c_func
(paren
op_amp
id|policy-&gt;timer
comma
id|jiffies
op_plus
id|HZ
)paren
)paren
id|xfrm_pol_hold
c_func
(paren
id|policy
)paren
suffix:semicolon
id|write_unlock_bh
c_func
(paren
op_amp
id|xfrm_policy_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|delpol
)paren
(brace
id|xfrm_policy_kill
c_func
(paren
id|delpol
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|xfrm_policy_bysel
r_struct
id|xfrm_policy
op_star
id|xfrm_policy_bysel
c_func
(paren
r_int
id|dir
comma
r_struct
id|xfrm_selector
op_star
id|sel
comma
r_int
r_delete
)paren
(brace
r_struct
id|xfrm_policy
op_star
id|pol
comma
op_star
op_star
id|p
suffix:semicolon
id|write_lock_bh
c_func
(paren
op_amp
id|xfrm_policy_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
op_amp
id|xfrm_policy_list
(braket
id|dir
)braket
suffix:semicolon
(paren
id|pol
op_assign
op_star
id|p
)paren
op_ne
l_int|NULL
suffix:semicolon
id|p
op_assign
op_amp
id|pol-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|sel
comma
op_amp
id|pol-&gt;selector
comma
r_sizeof
(paren
op_star
id|sel
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|xfrm_pol_hold
c_func
(paren
id|pol
)paren
suffix:semicolon
r_if
c_cond
(paren
r_delete
)paren
op_star
id|p
op_assign
id|pol-&gt;next
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|write_unlock_bh
c_func
(paren
op_amp
id|xfrm_policy_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pol
op_logical_and
r_delete
)paren
(brace
id|atomic_inc
c_func
(paren
op_amp
id|flow_cache_genid
)paren
suffix:semicolon
id|xfrm_policy_kill
c_func
(paren
id|pol
)paren
suffix:semicolon
)brace
r_return
id|pol
suffix:semicolon
)brace
DECL|function|xfrm_policy_byid
r_struct
id|xfrm_policy
op_star
id|xfrm_policy_byid
c_func
(paren
r_int
id|dir
comma
id|u32
id|id
comma
r_int
r_delete
)paren
(brace
r_struct
id|xfrm_policy
op_star
id|pol
comma
op_star
op_star
id|p
suffix:semicolon
id|write_lock_bh
c_func
(paren
op_amp
id|xfrm_policy_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
op_amp
id|xfrm_policy_list
(braket
id|id
op_amp
l_int|7
)braket
suffix:semicolon
(paren
id|pol
op_assign
op_star
id|p
)paren
op_ne
l_int|NULL
suffix:semicolon
id|p
op_assign
op_amp
id|pol-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|pol-&gt;index
op_eq
id|id
)paren
(brace
id|xfrm_pol_hold
c_func
(paren
id|pol
)paren
suffix:semicolon
r_if
c_cond
(paren
r_delete
)paren
op_star
id|p
op_assign
id|pol-&gt;next
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|write_unlock_bh
c_func
(paren
op_amp
id|xfrm_policy_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pol
op_logical_and
r_delete
)paren
(brace
id|atomic_inc
c_func
(paren
op_amp
id|flow_cache_genid
)paren
suffix:semicolon
id|xfrm_policy_kill
c_func
(paren
id|pol
)paren
suffix:semicolon
)brace
r_return
id|pol
suffix:semicolon
)brace
DECL|function|xfrm_policy_flush
r_void
id|xfrm_policy_flush
c_func
(paren
r_void
)paren
(brace
r_struct
id|xfrm_policy
op_star
id|xp
suffix:semicolon
r_int
id|dir
suffix:semicolon
id|write_lock_bh
c_func
(paren
op_amp
id|xfrm_policy_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|dir
op_assign
l_int|0
suffix:semicolon
id|dir
OL
id|XFRM_POLICY_MAX
suffix:semicolon
id|dir
op_increment
)paren
(brace
r_while
c_loop
(paren
(paren
id|xp
op_assign
id|xfrm_policy_list
(braket
id|dir
)braket
)paren
op_ne
l_int|NULL
)paren
(brace
id|xfrm_policy_list
(braket
id|dir
)braket
op_assign
id|xp-&gt;next
suffix:semicolon
id|write_unlock_bh
c_func
(paren
op_amp
id|xfrm_policy_lock
)paren
suffix:semicolon
id|xfrm_policy_kill
c_func
(paren
id|xp
)paren
suffix:semicolon
id|write_lock_bh
c_func
(paren
op_amp
id|xfrm_policy_lock
)paren
suffix:semicolon
)brace
)brace
id|atomic_inc
c_func
(paren
op_amp
id|flow_cache_genid
)paren
suffix:semicolon
id|write_unlock_bh
c_func
(paren
op_amp
id|xfrm_policy_lock
)paren
suffix:semicolon
)brace
DECL|function|xfrm_policy_walk
r_int
id|xfrm_policy_walk
c_func
(paren
r_int
(paren
op_star
id|func
)paren
(paren
r_struct
id|xfrm_policy
op_star
comma
r_int
comma
r_int
comma
r_void
op_star
)paren
comma
r_void
op_star
id|data
)paren
(brace
r_struct
id|xfrm_policy
op_star
id|xp
suffix:semicolon
r_int
id|dir
suffix:semicolon
r_int
id|count
op_assign
l_int|0
suffix:semicolon
r_int
id|error
op_assign
l_int|0
suffix:semicolon
id|read_lock_bh
c_func
(paren
op_amp
id|xfrm_policy_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|dir
op_assign
l_int|0
suffix:semicolon
id|dir
OL
l_int|2
op_star
id|XFRM_POLICY_MAX
suffix:semicolon
id|dir
op_increment
)paren
(brace
r_for
c_loop
(paren
id|xp
op_assign
id|xfrm_policy_list
(braket
id|dir
)braket
suffix:semicolon
id|xp
suffix:semicolon
id|xp
op_assign
id|xp-&gt;next
)paren
id|count
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|count
op_eq
l_int|0
)paren
(brace
id|error
op_assign
op_minus
id|ENOENT
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_for
c_loop
(paren
id|dir
op_assign
l_int|0
suffix:semicolon
id|dir
OL
l_int|2
op_star
id|XFRM_POLICY_MAX
suffix:semicolon
id|dir
op_increment
)paren
(brace
r_for
c_loop
(paren
id|xp
op_assign
id|xfrm_policy_list
(braket
id|dir
)braket
suffix:semicolon
id|xp
suffix:semicolon
id|xp
op_assign
id|xp-&gt;next
)paren
(brace
id|error
op_assign
id|func
c_func
(paren
id|xp
comma
id|dir
op_mod
id|XFRM_POLICY_MAX
comma
op_decrement
id|count
comma
id|data
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|out
suffix:semicolon
)brace
)brace
id|out
suffix:colon
id|read_unlock_bh
c_func
(paren
op_amp
id|xfrm_policy_lock
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/* Find policy to apply to this flow. */
DECL|function|xfrm_policy_lookup
r_static
r_void
id|xfrm_policy_lookup
c_func
(paren
r_struct
id|flowi
op_star
id|fl
comma
id|u16
id|family
comma
id|u8
id|dir
comma
r_void
op_star
op_star
id|objp
comma
id|atomic_t
op_star
op_star
id|obj_refp
)paren
(brace
r_struct
id|xfrm_policy
op_star
id|pol
suffix:semicolon
id|read_lock_bh
c_func
(paren
op_amp
id|xfrm_policy_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|pol
op_assign
id|xfrm_policy_list
(braket
id|dir
)braket
suffix:semicolon
id|pol
suffix:semicolon
id|pol
op_assign
id|pol-&gt;next
)paren
(brace
r_struct
id|xfrm_selector
op_star
id|sel
op_assign
op_amp
id|pol-&gt;selector
suffix:semicolon
r_int
id|match
suffix:semicolon
r_if
c_cond
(paren
id|pol-&gt;family
op_ne
id|family
)paren
r_continue
suffix:semicolon
id|match
op_assign
id|xfrm_selector_match
c_func
(paren
id|sel
comma
id|fl
comma
id|family
)paren
suffix:semicolon
r_if
c_cond
(paren
id|match
)paren
(brace
id|xfrm_pol_hold
c_func
(paren
id|pol
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|read_unlock_bh
c_func
(paren
op_amp
id|xfrm_policy_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
op_star
id|objp
op_assign
(paren
r_void
op_star
)paren
id|pol
)paren
op_ne
l_int|NULL
)paren
op_star
id|obj_refp
op_assign
op_amp
id|pol-&gt;refcnt
suffix:semicolon
)brace
DECL|function|xfrm_sk_policy_lookup
r_struct
id|xfrm_policy
op_star
id|xfrm_sk_policy_lookup
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|dir
comma
r_struct
id|flowi
op_star
id|fl
)paren
(brace
r_struct
id|xfrm_policy
op_star
id|pol
suffix:semicolon
id|read_lock_bh
c_func
(paren
op_amp
id|xfrm_policy_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|pol
op_assign
id|sk-&gt;sk_policy
(braket
id|dir
)braket
)paren
op_ne
l_int|NULL
)paren
(brace
r_int
id|match
op_assign
id|xfrm_selector_match
c_func
(paren
op_amp
id|pol-&gt;selector
comma
id|fl
comma
id|sk-&gt;sk_family
)paren
suffix:semicolon
r_if
c_cond
(paren
id|match
)paren
id|xfrm_pol_hold
c_func
(paren
id|pol
)paren
suffix:semicolon
r_else
id|pol
op_assign
l_int|NULL
suffix:semicolon
)brace
id|read_unlock_bh
c_func
(paren
op_amp
id|xfrm_policy_lock
)paren
suffix:semicolon
r_return
id|pol
suffix:semicolon
)brace
DECL|function|__xfrm_policy_link
r_static
r_void
id|__xfrm_policy_link
c_func
(paren
r_struct
id|xfrm_policy
op_star
id|pol
comma
r_int
id|dir
)paren
(brace
id|pol-&gt;next
op_assign
id|xfrm_policy_list
(braket
id|dir
)braket
suffix:semicolon
id|xfrm_policy_list
(braket
id|dir
)braket
op_assign
id|pol
suffix:semicolon
id|xfrm_pol_hold
c_func
(paren
id|pol
)paren
suffix:semicolon
)brace
DECL|function|__xfrm_policy_unlink
r_static
r_struct
id|xfrm_policy
op_star
id|__xfrm_policy_unlink
c_func
(paren
r_struct
id|xfrm_policy
op_star
id|pol
comma
r_int
id|dir
)paren
(brace
r_struct
id|xfrm_policy
op_star
op_star
id|polp
suffix:semicolon
r_for
c_loop
(paren
id|polp
op_assign
op_amp
id|xfrm_policy_list
(braket
id|dir
)braket
suffix:semicolon
op_star
id|polp
op_ne
l_int|NULL
suffix:semicolon
id|polp
op_assign
op_amp
(paren
op_star
id|polp
)paren
op_member_access_from_pointer
id|next
)paren
(brace
r_if
c_cond
(paren
op_star
id|polp
op_eq
id|pol
)paren
(brace
op_star
id|polp
op_assign
id|pol-&gt;next
suffix:semicolon
r_return
id|pol
suffix:semicolon
)brace
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|xfrm_policy_delete
r_void
id|xfrm_policy_delete
c_func
(paren
r_struct
id|xfrm_policy
op_star
id|pol
comma
r_int
id|dir
)paren
(brace
id|write_lock_bh
c_func
(paren
op_amp
id|xfrm_policy_lock
)paren
suffix:semicolon
id|pol
op_assign
id|__xfrm_policy_unlink
c_func
(paren
id|pol
comma
id|dir
)paren
suffix:semicolon
id|write_unlock_bh
c_func
(paren
op_amp
id|xfrm_policy_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pol
)paren
(brace
r_if
c_cond
(paren
id|dir
OL
id|XFRM_POLICY_MAX
)paren
id|atomic_inc
c_func
(paren
op_amp
id|flow_cache_genid
)paren
suffix:semicolon
id|xfrm_policy_kill
c_func
(paren
id|pol
)paren
suffix:semicolon
)brace
)brace
DECL|variable|xfrm_policy_delete
id|EXPORT_SYMBOL
c_func
(paren
id|xfrm_policy_delete
)paren
suffix:semicolon
DECL|function|xfrm_sk_policy_insert
r_int
id|xfrm_sk_policy_insert
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|dir
comma
r_struct
id|xfrm_policy
op_star
id|pol
)paren
(brace
r_struct
id|xfrm_policy
op_star
id|old_pol
suffix:semicolon
id|write_lock_bh
c_func
(paren
op_amp
id|xfrm_policy_lock
)paren
suffix:semicolon
id|old_pol
op_assign
id|sk-&gt;sk_policy
(braket
id|dir
)braket
suffix:semicolon
id|sk-&gt;sk_policy
(braket
id|dir
)braket
op_assign
id|pol
suffix:semicolon
r_if
c_cond
(paren
id|pol
)paren
(brace
id|pol-&gt;curlft.add_time
op_assign
(paren
r_int
r_int
)paren
id|xtime.tv_sec
suffix:semicolon
id|pol-&gt;index
op_assign
id|xfrm_gen_index
c_func
(paren
id|XFRM_POLICY_MAX
op_plus
id|dir
)paren
suffix:semicolon
id|__xfrm_policy_link
c_func
(paren
id|pol
comma
id|XFRM_POLICY_MAX
op_plus
id|dir
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|old_pol
)paren
id|__xfrm_policy_unlink
c_func
(paren
id|old_pol
comma
id|XFRM_POLICY_MAX
op_plus
id|dir
)paren
suffix:semicolon
id|write_unlock_bh
c_func
(paren
op_amp
id|xfrm_policy_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|old_pol
)paren
(brace
id|xfrm_policy_kill
c_func
(paren
id|old_pol
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|clone_policy
r_static
r_struct
id|xfrm_policy
op_star
id|clone_policy
c_func
(paren
r_struct
id|xfrm_policy
op_star
id|old
comma
r_int
id|dir
)paren
(brace
r_struct
id|xfrm_policy
op_star
id|newp
op_assign
id|xfrm_policy_alloc
c_func
(paren
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|newp
)paren
(brace
id|newp-&gt;selector
op_assign
id|old-&gt;selector
suffix:semicolon
id|newp-&gt;lft
op_assign
id|old-&gt;lft
suffix:semicolon
id|newp-&gt;curlft
op_assign
id|old-&gt;curlft
suffix:semicolon
id|newp-&gt;action
op_assign
id|old-&gt;action
suffix:semicolon
id|newp-&gt;flags
op_assign
id|old-&gt;flags
suffix:semicolon
id|newp-&gt;xfrm_nr
op_assign
id|old-&gt;xfrm_nr
suffix:semicolon
id|newp-&gt;index
op_assign
id|old-&gt;index
suffix:semicolon
id|memcpy
c_func
(paren
id|newp-&gt;xfrm_vec
comma
id|old-&gt;xfrm_vec
comma
id|newp-&gt;xfrm_nr
op_star
r_sizeof
(paren
r_struct
id|xfrm_tmpl
)paren
)paren
suffix:semicolon
id|write_lock_bh
c_func
(paren
op_amp
id|xfrm_policy_lock
)paren
suffix:semicolon
id|__xfrm_policy_link
c_func
(paren
id|newp
comma
id|XFRM_POLICY_MAX
op_plus
id|dir
)paren
suffix:semicolon
id|write_unlock_bh
c_func
(paren
op_amp
id|xfrm_policy_lock
)paren
suffix:semicolon
id|xfrm_pol_put
c_func
(paren
id|newp
)paren
suffix:semicolon
)brace
r_return
id|newp
suffix:semicolon
)brace
DECL|function|__xfrm_sk_clone_policy
r_int
id|__xfrm_sk_clone_policy
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|xfrm_policy
op_star
id|p0
op_assign
id|sk-&gt;sk_policy
(braket
l_int|0
)braket
comma
op_star
id|p1
op_assign
id|sk-&gt;sk_policy
(braket
l_int|1
)braket
suffix:semicolon
id|sk-&gt;sk_policy
(braket
l_int|0
)braket
op_assign
id|sk-&gt;sk_policy
(braket
l_int|1
)braket
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|p0
op_logical_and
(paren
id|sk-&gt;sk_policy
(braket
l_int|0
)braket
op_assign
id|clone_policy
c_func
(paren
id|p0
comma
l_int|0
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
id|p1
op_logical_and
(paren
id|sk-&gt;sk_policy
(braket
l_int|1
)braket
op_assign
id|clone_policy
c_func
(paren
id|p1
comma
l_int|1
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Resolve list of templates for the flow, given policy. */
r_static
r_int
DECL|function|xfrm_tmpl_resolve
id|xfrm_tmpl_resolve
c_func
(paren
r_struct
id|xfrm_policy
op_star
id|policy
comma
r_struct
id|flowi
op_star
id|fl
comma
r_struct
id|xfrm_state
op_star
op_star
id|xfrm
comma
r_int
r_int
id|family
)paren
(brace
r_int
id|nx
suffix:semicolon
r_int
id|i
comma
id|error
suffix:semicolon
id|xfrm_address_t
op_star
id|daddr
op_assign
id|xfrm_flowi_daddr
c_func
(paren
id|fl
comma
id|family
)paren
suffix:semicolon
id|xfrm_address_t
op_star
id|saddr
op_assign
id|xfrm_flowi_saddr
c_func
(paren
id|fl
comma
id|family
)paren
suffix:semicolon
r_for
c_loop
(paren
id|nx
op_assign
l_int|0
comma
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|policy-&gt;xfrm_nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|xfrm_state
op_star
id|x
suffix:semicolon
id|xfrm_address_t
op_star
id|remote
op_assign
id|daddr
suffix:semicolon
id|xfrm_address_t
op_star
id|local
op_assign
id|saddr
suffix:semicolon
r_struct
id|xfrm_tmpl
op_star
id|tmpl
op_assign
op_amp
id|policy-&gt;xfrm_vec
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|tmpl-&gt;mode
)paren
(brace
id|remote
op_assign
op_amp
id|tmpl-&gt;id.daddr
suffix:semicolon
id|local
op_assign
op_amp
id|tmpl-&gt;saddr
suffix:semicolon
)brace
id|x
op_assign
id|xfrm_state_find
c_func
(paren
id|remote
comma
id|local
comma
id|fl
comma
id|tmpl
comma
id|policy
comma
op_amp
id|error
comma
id|family
)paren
suffix:semicolon
r_if
c_cond
(paren
id|x
op_logical_and
id|x-&gt;km.state
op_eq
id|XFRM_STATE_VALID
)paren
(brace
id|xfrm
(braket
id|nx
op_increment
)braket
op_assign
id|x
suffix:semicolon
id|daddr
op_assign
id|remote
suffix:semicolon
id|saddr
op_assign
id|local
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|x
)paren
(brace
id|error
op_assign
(paren
id|x-&gt;km.state
op_eq
id|XFRM_STATE_ERROR
ques
c_cond
op_minus
id|EINVAL
suffix:colon
op_minus
id|EAGAIN
)paren
suffix:semicolon
id|xfrm_state_put
c_func
(paren
id|x
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|tmpl-&gt;optional
)paren
r_goto
id|fail
suffix:semicolon
)brace
r_return
id|nx
suffix:semicolon
id|fail
suffix:colon
r_for
c_loop
(paren
id|nx
op_decrement
suffix:semicolon
id|nx
op_ge
l_int|0
suffix:semicolon
id|nx
op_decrement
)paren
id|xfrm_state_put
c_func
(paren
id|xfrm
(braket
id|nx
)braket
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/* Check that the bundle accepts the flow and its components are&n; * still valid.&n; */
r_static
r_struct
id|dst_entry
op_star
DECL|function|xfrm_find_bundle
id|xfrm_find_bundle
c_func
(paren
r_struct
id|flowi
op_star
id|fl
comma
r_struct
id|xfrm_policy
op_star
id|policy
comma
r_int
r_int
id|family
)paren
(brace
r_struct
id|dst_entry
op_star
id|x
suffix:semicolon
r_struct
id|xfrm_policy_afinfo
op_star
id|afinfo
op_assign
id|xfrm_policy_get_afinfo
c_func
(paren
id|family
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|afinfo
op_eq
l_int|NULL
)paren
)paren
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
id|x
op_assign
id|afinfo
op_member_access_from_pointer
id|find_bundle
c_func
(paren
id|fl
comma
id|policy
)paren
suffix:semicolon
id|xfrm_policy_put_afinfo
c_func
(paren
id|afinfo
)paren
suffix:semicolon
r_return
id|x
suffix:semicolon
)brace
multiline_comment|/* Allocate chain of dst_entry&squot;s, attach known xfrm&squot;s, calculate&n; * all the metrics... Shortly, bundle a bundle.&n; */
r_static
r_int
DECL|function|xfrm_bundle_create
id|xfrm_bundle_create
c_func
(paren
r_struct
id|xfrm_policy
op_star
id|policy
comma
r_struct
id|xfrm_state
op_star
op_star
id|xfrm
comma
r_int
id|nx
comma
r_struct
id|flowi
op_star
id|fl
comma
r_struct
id|dst_entry
op_star
op_star
id|dst_p
comma
r_int
r_int
id|family
)paren
(brace
r_int
id|err
suffix:semicolon
r_struct
id|xfrm_policy_afinfo
op_star
id|afinfo
op_assign
id|xfrm_policy_get_afinfo
c_func
(paren
id|family
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|afinfo
op_eq
l_int|NULL
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|err
op_assign
id|afinfo
op_member_access_from_pointer
id|bundle_create
c_func
(paren
id|policy
comma
id|xfrm
comma
id|nx
comma
id|fl
comma
id|dst_p
)paren
suffix:semicolon
id|xfrm_policy_put_afinfo
c_func
(paren
id|afinfo
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|function|policy_to_flow_dir
r_static
r_inline
r_int
id|policy_to_flow_dir
c_func
(paren
r_int
id|dir
)paren
(brace
r_if
c_cond
(paren
id|XFRM_POLICY_IN
op_eq
id|FLOW_DIR_IN
op_logical_and
id|XFRM_POLICY_OUT
op_eq
id|FLOW_DIR_OUT
op_logical_and
id|XFRM_POLICY_FWD
op_eq
id|FLOW_DIR_FWD
)paren
r_return
id|dir
suffix:semicolon
r_switch
c_cond
(paren
id|dir
)paren
(brace
r_default
suffix:colon
r_case
id|XFRM_POLICY_IN
suffix:colon
r_return
id|FLOW_DIR_IN
suffix:semicolon
r_case
id|XFRM_POLICY_OUT
suffix:colon
r_return
id|FLOW_DIR_OUT
suffix:semicolon
r_case
id|XFRM_POLICY_FWD
suffix:colon
r_return
id|FLOW_DIR_FWD
suffix:semicolon
)brace
suffix:semicolon
)brace
r_static
r_int
id|stale_bundle
c_func
(paren
r_struct
id|dst_entry
op_star
id|dst
)paren
suffix:semicolon
multiline_comment|/* Main function: finds/creates a bundle for given flow.&n; *&n; * At the moment we eat a raw IP route. Mostly to speed up lookups&n; * on interfaces with disabled IPsec.&n; */
DECL|function|xfrm_lookup
r_int
id|xfrm_lookup
c_func
(paren
r_struct
id|dst_entry
op_star
op_star
id|dst_p
comma
r_struct
id|flowi
op_star
id|fl
comma
r_struct
id|sock
op_star
id|sk
comma
r_int
id|flags
)paren
(brace
r_struct
id|xfrm_policy
op_star
id|policy
suffix:semicolon
r_struct
id|xfrm_state
op_star
id|xfrm
(braket
id|XFRM_MAX_DEPTH
)braket
suffix:semicolon
r_struct
id|dst_entry
op_star
id|dst
comma
op_star
id|dst_orig
op_assign
op_star
id|dst_p
suffix:semicolon
r_int
id|nx
op_assign
l_int|0
suffix:semicolon
r_int
id|err
suffix:semicolon
id|u32
id|genid
suffix:semicolon
id|u16
id|family
op_assign
id|dst_orig-&gt;ops-&gt;family
suffix:semicolon
id|restart
suffix:colon
id|genid
op_assign
id|atomic_read
c_func
(paren
op_amp
id|flow_cache_genid
)paren
suffix:semicolon
id|policy
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|sk
op_logical_and
id|sk-&gt;sk_policy
(braket
l_int|1
)braket
)paren
id|policy
op_assign
id|xfrm_sk_policy_lookup
c_func
(paren
id|sk
comma
id|XFRM_POLICY_OUT
comma
id|fl
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|policy
)paren
(brace
multiline_comment|/* To accelerate a bit...  */
r_if
c_cond
(paren
(paren
id|dst_orig-&gt;flags
op_amp
id|DST_NOXFRM
)paren
op_logical_or
op_logical_neg
id|xfrm_policy_list
(braket
id|XFRM_POLICY_OUT
)braket
)paren
r_return
l_int|0
suffix:semicolon
id|policy
op_assign
id|flow_cache_lookup
c_func
(paren
id|fl
comma
id|family
comma
id|policy_to_flow_dir
c_func
(paren
id|XFRM_POLICY_OUT
)paren
comma
id|xfrm_policy_lookup
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|policy
)paren
r_return
l_int|0
suffix:semicolon
id|policy-&gt;curlft.use_time
op_assign
(paren
r_int
r_int
)paren
id|xtime.tv_sec
suffix:semicolon
r_switch
c_cond
(paren
id|policy-&gt;action
)paren
(brace
r_case
id|XFRM_POLICY_BLOCK
suffix:colon
multiline_comment|/* Prohibit the flow */
id|xfrm_pol_put
c_func
(paren
id|policy
)paren
suffix:semicolon
r_return
op_minus
id|EPERM
suffix:semicolon
r_case
id|XFRM_POLICY_ALLOW
suffix:colon
r_if
c_cond
(paren
id|policy-&gt;xfrm_nr
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Flow passes not transformed. */
id|xfrm_pol_put
c_func
(paren
id|policy
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Try to find matching bundle.&n;&t;&t; *&n;&t;&t; * LATER: help from flow cache. It is optional, this&n;&t;&t; * is required only for output policy.&n;&t;&t; */
id|dst
op_assign
id|xfrm_find_bundle
c_func
(paren
id|fl
comma
id|policy
comma
id|family
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|dst
)paren
)paren
(brace
id|xfrm_pol_put
c_func
(paren
id|policy
)paren
suffix:semicolon
r_return
id|PTR_ERR
c_func
(paren
id|dst
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dst
)paren
r_break
suffix:semicolon
id|nx
op_assign
id|xfrm_tmpl_resolve
c_func
(paren
id|policy
comma
id|fl
comma
id|xfrm
comma
id|family
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|nx
OL
l_int|0
)paren
)paren
(brace
id|err
op_assign
id|nx
suffix:semicolon
r_if
c_cond
(paren
id|err
op_eq
op_minus
id|EAGAIN
op_logical_and
id|flags
)paren
(brace
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
id|add_wait_queue
c_func
(paren
op_amp
id|km_waitq
comma
op_amp
id|wait
)paren
suffix:semicolon
id|set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|set_current_state
c_func
(paren
id|TASK_RUNNING
)paren
suffix:semicolon
id|remove_wait_queue
c_func
(paren
op_amp
id|km_waitq
comma
op_amp
id|wait
)paren
suffix:semicolon
id|nx
op_assign
id|xfrm_tmpl_resolve
c_func
(paren
id|policy
comma
id|fl
comma
id|xfrm
comma
id|family
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nx
op_eq
op_minus
id|EAGAIN
op_logical_and
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
id|err
op_assign
op_minus
id|ERESTART
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
r_if
c_cond
(paren
id|nx
op_eq
op_minus
id|EAGAIN
op_logical_or
id|genid
op_ne
id|atomic_read
c_func
(paren
op_amp
id|flow_cache_genid
)paren
)paren
(brace
id|xfrm_pol_put
c_func
(paren
id|policy
)paren
suffix:semicolon
r_goto
id|restart
suffix:semicolon
)brace
id|err
op_assign
id|nx
suffix:semicolon
)brace
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_goto
id|error
suffix:semicolon
)brace
r_if
c_cond
(paren
id|nx
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Flow passes not transformed. */
id|xfrm_pol_put
c_func
(paren
id|policy
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|dst
op_assign
id|dst_orig
suffix:semicolon
id|err
op_assign
id|xfrm_bundle_create
c_func
(paren
id|policy
comma
id|xfrm
comma
id|nx
comma
id|fl
comma
op_amp
id|dst
comma
id|family
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|err
)paren
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nx
suffix:semicolon
id|i
op_increment
)paren
id|xfrm_state_put
c_func
(paren
id|xfrm
(braket
id|i
)braket
)paren
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
id|write_lock_bh
c_func
(paren
op_amp
id|policy-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|policy-&gt;dead
op_logical_or
id|stale_bundle
c_func
(paren
id|dst
)paren
)paren
)paren
(brace
multiline_comment|/* Wow! While we worked on resolving, this&n;&t;&t;&t; * policy has gone. Retry. It is not paranoia,&n;&t;&t;&t; * we just cannot enlist new bundle to dead object.&n;&t;&t;&t; * We can&squot;t enlist stable bundles either.&n;&t;&t;&t; */
id|write_unlock_bh
c_func
(paren
op_amp
id|policy-&gt;lock
)paren
suffix:semicolon
id|xfrm_pol_put
c_func
(paren
id|policy
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dst
)paren
id|dst_free
c_func
(paren
id|dst
)paren
suffix:semicolon
r_goto
id|restart
suffix:semicolon
)brace
id|dst-&gt;next
op_assign
id|policy-&gt;bundles
suffix:semicolon
id|policy-&gt;bundles
op_assign
id|dst
suffix:semicolon
id|dst_hold
c_func
(paren
id|dst
)paren
suffix:semicolon
id|write_unlock_bh
c_func
(paren
op_amp
id|policy-&gt;lock
)paren
suffix:semicolon
)brace
op_star
id|dst_p
op_assign
id|dst
suffix:semicolon
id|dst_release
c_func
(paren
id|dst_orig
)paren
suffix:semicolon
id|xfrm_pol_put
c_func
(paren
id|policy
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|error
suffix:colon
id|dst_release
c_func
(paren
id|dst_orig
)paren
suffix:semicolon
id|xfrm_pol_put
c_func
(paren
id|policy
)paren
suffix:semicolon
op_star
id|dst_p
op_assign
l_int|NULL
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/* When skb is transformed back to its &quot;native&quot; form, we have to&n; * check policy restrictions. At the moment we make this in maximally&n; * stupid way. Shame on me. :-) Of course, connected sockets must&n; * have policy cached at them.&n; */
r_static
r_inline
r_int
DECL|function|xfrm_state_ok
id|xfrm_state_ok
c_func
(paren
r_struct
id|xfrm_tmpl
op_star
id|tmpl
comma
r_struct
id|xfrm_state
op_star
id|x
comma
r_int
r_int
id|family
)paren
(brace
r_if
c_cond
(paren
id|xfrm_state_kern
c_func
(paren
id|x
)paren
)paren
r_return
id|tmpl-&gt;optional
op_logical_and
op_logical_neg
id|xfrm_state_addr_cmp
c_func
(paren
id|tmpl
comma
id|x
comma
id|family
)paren
suffix:semicolon
r_return
id|x-&gt;id.proto
op_eq
id|tmpl-&gt;id.proto
op_logical_and
(paren
id|x-&gt;id.spi
op_eq
id|tmpl-&gt;id.spi
op_logical_or
op_logical_neg
id|tmpl-&gt;id.spi
)paren
op_logical_and
(paren
id|x-&gt;props.reqid
op_eq
id|tmpl-&gt;reqid
op_logical_or
op_logical_neg
id|tmpl-&gt;reqid
)paren
op_logical_and
id|x-&gt;props.mode
op_eq
id|tmpl-&gt;mode
op_logical_and
(paren
id|tmpl-&gt;aalgos
op_amp
(paren
l_int|1
op_lshift
id|x-&gt;props.aalgo
)paren
)paren
op_logical_and
op_logical_neg
(paren
id|x-&gt;props.mode
op_logical_and
id|xfrm_state_addr_cmp
c_func
(paren
id|tmpl
comma
id|x
comma
id|family
)paren
)paren
suffix:semicolon
)brace
r_static
r_inline
r_int
DECL|function|xfrm_policy_ok
id|xfrm_policy_ok
c_func
(paren
r_struct
id|xfrm_tmpl
op_star
id|tmpl
comma
r_struct
id|sec_path
op_star
id|sp
comma
r_int
id|start
comma
r_int
r_int
id|family
)paren
(brace
r_int
id|idx
op_assign
id|start
suffix:semicolon
r_if
c_cond
(paren
id|tmpl-&gt;optional
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|tmpl-&gt;mode
)paren
r_return
id|start
suffix:semicolon
)brace
r_else
id|start
op_assign
op_minus
l_int|1
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|idx
OL
id|sp-&gt;len
suffix:semicolon
id|idx
op_increment
)paren
(brace
r_if
c_cond
(paren
id|xfrm_state_ok
c_func
(paren
id|tmpl
comma
id|sp-&gt;x
(braket
id|idx
)braket
dot
id|xvec
comma
id|family
)paren
)paren
r_return
op_increment
id|idx
suffix:semicolon
r_if
c_cond
(paren
id|sp-&gt;x
(braket
id|idx
)braket
dot
id|xvec-&gt;props.mode
)paren
r_break
suffix:semicolon
)brace
r_return
id|start
suffix:semicolon
)brace
r_static
r_int
DECL|function|_decode_session
id|_decode_session
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|flowi
op_star
id|fl
comma
r_int
r_int
id|family
)paren
(brace
r_struct
id|xfrm_policy_afinfo
op_star
id|afinfo
op_assign
id|xfrm_policy_get_afinfo
c_func
(paren
id|family
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|afinfo
op_eq
l_int|NULL
)paren
)paren
r_return
op_minus
id|EAFNOSUPPORT
suffix:semicolon
id|afinfo
op_member_access_from_pointer
id|decode_session
c_func
(paren
id|skb
comma
id|fl
)paren
suffix:semicolon
id|xfrm_policy_put_afinfo
c_func
(paren
id|afinfo
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|secpath_has_tunnel
r_static
r_inline
r_int
id|secpath_has_tunnel
c_func
(paren
r_struct
id|sec_path
op_star
id|sp
comma
r_int
id|k
)paren
(brace
r_for
c_loop
(paren
suffix:semicolon
id|k
OL
id|sp-&gt;len
suffix:semicolon
id|k
op_increment
)paren
(brace
r_if
c_cond
(paren
id|sp-&gt;x
(braket
id|k
)braket
dot
id|xvec-&gt;props.mode
)paren
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|__xfrm_policy_check
r_int
id|__xfrm_policy_check
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|dir
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
r_int
id|family
)paren
(brace
r_struct
id|xfrm_policy
op_star
id|pol
suffix:semicolon
r_struct
id|flowi
id|fl
suffix:semicolon
r_if
c_cond
(paren
id|_decode_session
c_func
(paren
id|skb
comma
op_amp
id|fl
comma
id|family
)paren
OL
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* First, check used SA against their selectors. */
r_if
c_cond
(paren
id|skb-&gt;sp
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|skb-&gt;sp-&gt;len
op_minus
l_int|1
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
r_struct
id|sec_decap_state
op_star
id|xvec
op_assign
op_amp
(paren
id|skb-&gt;sp-&gt;x
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|xfrm_selector_match
c_func
(paren
op_amp
id|xvec-&gt;xvec-&gt;sel
comma
op_amp
id|fl
comma
id|family
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* If there is a post_input processor, try running it */
r_if
c_cond
(paren
id|xvec-&gt;xvec-&gt;type-&gt;post_input
op_logical_and
(paren
id|xvec-&gt;xvec-&gt;type-&gt;post_input
)paren
(paren
id|xvec-&gt;xvec
comma
op_amp
(paren
id|xvec-&gt;decap
)paren
comma
id|skb
)paren
op_ne
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
)brace
)brace
id|pol
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|sk
op_logical_and
id|sk-&gt;sk_policy
(braket
id|dir
)braket
)paren
id|pol
op_assign
id|xfrm_sk_policy_lookup
c_func
(paren
id|sk
comma
id|dir
comma
op_amp
id|fl
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pol
)paren
id|pol
op_assign
id|flow_cache_lookup
c_func
(paren
op_amp
id|fl
comma
id|family
comma
id|policy_to_flow_dir
c_func
(paren
id|dir
)paren
comma
id|xfrm_policy_lookup
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pol
)paren
r_return
op_logical_neg
id|skb-&gt;sp
op_logical_or
op_logical_neg
id|secpath_has_tunnel
c_func
(paren
id|skb-&gt;sp
comma
l_int|0
)paren
suffix:semicolon
id|pol-&gt;curlft.use_time
op_assign
(paren
r_int
r_int
)paren
id|xtime.tv_sec
suffix:semicolon
r_if
c_cond
(paren
id|pol-&gt;action
op_eq
id|XFRM_POLICY_ALLOW
)paren
(brace
r_struct
id|sec_path
op_star
id|sp
suffix:semicolon
r_static
r_struct
id|sec_path
id|dummy
suffix:semicolon
r_int
id|i
comma
id|k
suffix:semicolon
r_if
c_cond
(paren
(paren
id|sp
op_assign
id|skb-&gt;sp
)paren
op_eq
l_int|NULL
)paren
id|sp
op_assign
op_amp
id|dummy
suffix:semicolon
multiline_comment|/* For each tunnel xfrm, find the first matching tmpl.&n;&t;&t; * For each tmpl before that, find corresponding xfrm.&n;&t;&t; * Order is _important_. Later we will implement&n;&t;&t; * some barriers, but at the moment barriers&n;&t;&t; * are implied between each two transformations.&n;&t;&t; */
r_for
c_loop
(paren
id|i
op_assign
id|pol-&gt;xfrm_nr
op_minus
l_int|1
comma
id|k
op_assign
l_int|0
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
id|k
op_assign
id|xfrm_policy_ok
c_func
(paren
id|pol-&gt;xfrm_vec
op_plus
id|i
comma
id|sp
comma
id|k
comma
id|family
)paren
suffix:semicolon
r_if
c_cond
(paren
id|k
OL
l_int|0
)paren
r_goto
id|reject
suffix:semicolon
)brace
r_if
c_cond
(paren
id|secpath_has_tunnel
c_func
(paren
id|sp
comma
id|k
)paren
)paren
r_goto
id|reject
suffix:semicolon
id|xfrm_pol_put
c_func
(paren
id|pol
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|reject
suffix:colon
id|xfrm_pol_put
c_func
(paren
id|pol
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|__xfrm_route_forward
r_int
id|__xfrm_route_forward
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
r_int
id|family
)paren
(brace
r_struct
id|flowi
id|fl
suffix:semicolon
r_if
c_cond
(paren
id|_decode_session
c_func
(paren
id|skb
comma
op_amp
id|fl
comma
id|family
)paren
OL
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
r_return
id|xfrm_lookup
c_func
(paren
op_amp
id|skb-&gt;dst
comma
op_amp
id|fl
comma
l_int|NULL
comma
l_int|0
)paren
op_eq
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Optimize later using cookies and generation ids. */
DECL|function|xfrm_dst_check
r_static
r_struct
id|dst_entry
op_star
id|xfrm_dst_check
c_func
(paren
r_struct
id|dst_entry
op_star
id|dst
comma
id|u32
id|cookie
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|stale_bundle
c_func
(paren
id|dst
)paren
)paren
r_return
id|dst
suffix:semicolon
id|dst_release
c_func
(paren
id|dst
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|stale_bundle
r_static
r_int
id|stale_bundle
c_func
(paren
r_struct
id|dst_entry
op_star
id|dst
)paren
(brace
r_struct
id|dst_entry
op_star
id|child
op_assign
id|dst
suffix:semicolon
r_while
c_loop
(paren
id|child
)paren
(brace
r_if
c_cond
(paren
id|child-&gt;obsolete
OG
l_int|0
op_logical_or
(paren
id|child-&gt;dev
op_logical_and
op_logical_neg
id|netif_running
c_func
(paren
id|child-&gt;dev
)paren
)paren
op_logical_or
(paren
id|child-&gt;xfrm
op_logical_and
id|child-&gt;xfrm-&gt;km.state
op_ne
id|XFRM_STATE_VALID
)paren
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
id|child
op_assign
id|child-&gt;child
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|xfrm_dst_destroy
r_static
r_void
id|xfrm_dst_destroy
c_func
(paren
r_struct
id|dst_entry
op_star
id|dst
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|dst-&gt;xfrm
)paren
r_return
suffix:semicolon
id|xfrm_state_put
c_func
(paren
id|dst-&gt;xfrm
)paren
suffix:semicolon
id|dst-&gt;xfrm
op_assign
l_int|NULL
suffix:semicolon
)brace
DECL|function|xfrm_link_failure
r_static
r_void
id|xfrm_link_failure
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
multiline_comment|/* Impossible. Such dst must be popped before reaches point of failure. */
r_return
suffix:semicolon
)brace
DECL|function|xfrm_negative_advice
r_static
r_struct
id|dst_entry
op_star
id|xfrm_negative_advice
c_func
(paren
r_struct
id|dst_entry
op_star
id|dst
)paren
(brace
r_if
c_cond
(paren
id|dst
)paren
(brace
r_if
c_cond
(paren
id|dst-&gt;obsolete
)paren
(brace
id|dst_release
c_func
(paren
id|dst
)paren
suffix:semicolon
id|dst
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
r_return
id|dst
suffix:semicolon
)brace
DECL|function|xfrm_prune_bundles
r_static
r_void
id|xfrm_prune_bundles
c_func
(paren
r_int
(paren
op_star
id|func
)paren
(paren
r_struct
id|dst_entry
op_star
)paren
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|xfrm_policy
op_star
id|pol
suffix:semicolon
r_struct
id|dst_entry
op_star
id|dst
comma
op_star
op_star
id|dstp
comma
op_star
id|gc_list
op_assign
l_int|NULL
suffix:semicolon
id|read_lock_bh
c_func
(paren
op_amp
id|xfrm_policy_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|2
op_star
id|XFRM_POLICY_MAX
suffix:semicolon
id|i
op_increment
)paren
(brace
r_for
c_loop
(paren
id|pol
op_assign
id|xfrm_policy_list
(braket
id|i
)braket
suffix:semicolon
id|pol
suffix:semicolon
id|pol
op_assign
id|pol-&gt;next
)paren
(brace
id|write_lock
c_func
(paren
op_amp
id|pol-&gt;lock
)paren
suffix:semicolon
id|dstp
op_assign
op_amp
id|pol-&gt;bundles
suffix:semicolon
r_while
c_loop
(paren
(paren
id|dst
op_assign
op_star
id|dstp
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|func
c_func
(paren
id|dst
)paren
)paren
(brace
op_star
id|dstp
op_assign
id|dst-&gt;next
suffix:semicolon
id|dst-&gt;next
op_assign
id|gc_list
suffix:semicolon
id|gc_list
op_assign
id|dst
suffix:semicolon
)brace
r_else
(brace
id|dstp
op_assign
op_amp
id|dst-&gt;next
suffix:semicolon
)brace
)brace
id|write_unlock
c_func
(paren
op_amp
id|pol-&gt;lock
)paren
suffix:semicolon
)brace
)brace
id|read_unlock_bh
c_func
(paren
op_amp
id|xfrm_policy_lock
)paren
suffix:semicolon
r_while
c_loop
(paren
id|gc_list
)paren
(brace
id|dst
op_assign
id|gc_list
suffix:semicolon
id|gc_list
op_assign
id|dst-&gt;next
suffix:semicolon
id|dst_free
c_func
(paren
id|dst
)paren
suffix:semicolon
)brace
)brace
DECL|function|unused_bundle
r_static
r_int
id|unused_bundle
c_func
(paren
r_struct
id|dst_entry
op_star
id|dst
)paren
(brace
r_return
op_logical_neg
id|atomic_read
c_func
(paren
op_amp
id|dst-&gt;__refcnt
)paren
suffix:semicolon
)brace
DECL|function|__xfrm_garbage_collect
r_static
r_void
id|__xfrm_garbage_collect
c_func
(paren
r_void
)paren
(brace
id|xfrm_prune_bundles
c_func
(paren
id|unused_bundle
)paren
suffix:semicolon
)brace
DECL|function|xfrm_flush_bundles
r_int
id|xfrm_flush_bundles
c_func
(paren
r_void
)paren
(brace
id|xfrm_prune_bundles
c_func
(paren
id|stale_bundle
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Well... that&squot;s _TASK_. We need to scan through transformation&n; * list and figure out what mss tcp should generate in order to&n; * final datagram fit to mtu. Mama mia... :-)&n; *&n; * Apparently, some easy way exists, but we used to choose the most&n; * bizarre ones. :-) So, raising Kalashnikov... tra-ta-ta.&n; *&n; * Consider this function as something like dark humour. :-)&n; */
DECL|function|xfrm_get_mss
r_static
r_int
id|xfrm_get_mss
c_func
(paren
r_struct
id|dst_entry
op_star
id|dst
comma
id|u32
id|mtu
)paren
(brace
r_int
id|res
op_assign
id|mtu
op_minus
id|dst-&gt;header_len
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_struct
id|dst_entry
op_star
id|d
op_assign
id|dst
suffix:semicolon
r_int
id|m
op_assign
id|res
suffix:semicolon
r_do
(brace
r_struct
id|xfrm_state
op_star
id|x
op_assign
id|d-&gt;xfrm
suffix:semicolon
r_if
c_cond
(paren
id|x
)paren
(brace
id|spin_lock_bh
c_func
(paren
op_amp
id|x-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|x-&gt;km.state
op_eq
id|XFRM_STATE_VALID
op_logical_and
id|x-&gt;type
op_logical_and
id|x-&gt;type-&gt;get_max_size
)paren
id|m
op_assign
id|x-&gt;type
op_member_access_from_pointer
id|get_max_size
c_func
(paren
id|d-&gt;xfrm
comma
id|m
)paren
suffix:semicolon
r_else
id|m
op_add_assign
id|x-&gt;props.header_len
suffix:semicolon
id|spin_unlock_bh
c_func
(paren
op_amp
id|x-&gt;lock
)paren
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
(paren
id|d
op_assign
id|d-&gt;child
)paren
op_ne
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|m
op_le
id|mtu
)paren
r_break
suffix:semicolon
id|res
op_sub_assign
(paren
id|m
op_minus
id|mtu
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res
OL
l_int|88
)paren
r_return
id|mtu
suffix:semicolon
)brace
r_return
id|res
op_plus
id|dst-&gt;header_len
suffix:semicolon
)brace
DECL|function|xfrm_policy_register_afinfo
r_int
id|xfrm_policy_register_afinfo
c_func
(paren
r_struct
id|xfrm_policy_afinfo
op_star
id|afinfo
)paren
(brace
r_int
id|err
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|afinfo
op_eq
l_int|NULL
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|afinfo-&gt;family
op_ge
id|NPROTO
)paren
)paren
r_return
op_minus
id|EAFNOSUPPORT
suffix:semicolon
id|write_lock
c_func
(paren
op_amp
id|xfrm_policy_afinfo_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|xfrm_policy_afinfo
(braket
id|afinfo-&gt;family
)braket
op_ne
l_int|NULL
)paren
)paren
id|err
op_assign
op_minus
id|ENOBUFS
suffix:semicolon
r_else
(brace
r_struct
id|dst_ops
op_star
id|dst_ops
op_assign
id|afinfo-&gt;dst_ops
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
id|dst_ops-&gt;kmem_cachep
op_eq
l_int|NULL
)paren
)paren
id|dst_ops-&gt;kmem_cachep
op_assign
id|xfrm_dst_cache
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
id|dst_ops-&gt;check
op_eq
l_int|NULL
)paren
)paren
id|dst_ops-&gt;check
op_assign
id|xfrm_dst_check
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
id|dst_ops-&gt;destroy
op_eq
l_int|NULL
)paren
)paren
id|dst_ops-&gt;destroy
op_assign
id|xfrm_dst_destroy
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
id|dst_ops-&gt;negative_advice
op_eq
l_int|NULL
)paren
)paren
id|dst_ops-&gt;negative_advice
op_assign
id|xfrm_negative_advice
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
id|dst_ops-&gt;link_failure
op_eq
l_int|NULL
)paren
)paren
id|dst_ops-&gt;link_failure
op_assign
id|xfrm_link_failure
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
id|dst_ops-&gt;get_mss
op_eq
l_int|NULL
)paren
)paren
id|dst_ops-&gt;get_mss
op_assign
id|xfrm_get_mss
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
id|afinfo-&gt;garbage_collect
op_eq
l_int|NULL
)paren
)paren
id|afinfo-&gt;garbage_collect
op_assign
id|__xfrm_garbage_collect
suffix:semicolon
id|xfrm_policy_afinfo
(braket
id|afinfo-&gt;family
)braket
op_assign
id|afinfo
suffix:semicolon
)brace
id|write_unlock
c_func
(paren
op_amp
id|xfrm_policy_afinfo_lock
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|function|xfrm_policy_unregister_afinfo
r_int
id|xfrm_policy_unregister_afinfo
c_func
(paren
r_struct
id|xfrm_policy_afinfo
op_star
id|afinfo
)paren
(brace
r_int
id|err
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|afinfo
op_eq
l_int|NULL
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|afinfo-&gt;family
op_ge
id|NPROTO
)paren
)paren
r_return
op_minus
id|EAFNOSUPPORT
suffix:semicolon
id|write_lock
c_func
(paren
op_amp
id|xfrm_policy_afinfo_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
id|xfrm_policy_afinfo
(braket
id|afinfo-&gt;family
)braket
op_ne
l_int|NULL
)paren
)paren
(brace
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|xfrm_policy_afinfo
(braket
id|afinfo-&gt;family
)braket
op_ne
id|afinfo
)paren
)paren
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_else
(brace
r_struct
id|dst_ops
op_star
id|dst_ops
op_assign
id|afinfo-&gt;dst_ops
suffix:semicolon
id|xfrm_policy_afinfo
(braket
id|afinfo-&gt;family
)braket
op_assign
l_int|NULL
suffix:semicolon
id|dst_ops-&gt;kmem_cachep
op_assign
l_int|NULL
suffix:semicolon
id|dst_ops-&gt;check
op_assign
l_int|NULL
suffix:semicolon
id|dst_ops-&gt;destroy
op_assign
l_int|NULL
suffix:semicolon
id|dst_ops-&gt;negative_advice
op_assign
l_int|NULL
suffix:semicolon
id|dst_ops-&gt;link_failure
op_assign
l_int|NULL
suffix:semicolon
id|dst_ops-&gt;get_mss
op_assign
l_int|NULL
suffix:semicolon
id|afinfo-&gt;garbage_collect
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
id|write_unlock
c_func
(paren
op_amp
id|xfrm_policy_afinfo_lock
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|function|xfrm_policy_get_afinfo
r_static
r_struct
id|xfrm_policy_afinfo
op_star
id|xfrm_policy_get_afinfo
c_func
(paren
r_int
r_int
id|family
)paren
(brace
r_struct
id|xfrm_policy_afinfo
op_star
id|afinfo
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|family
op_ge
id|NPROTO
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|xfrm_policy_afinfo_lock
)paren
suffix:semicolon
id|afinfo
op_assign
id|xfrm_policy_afinfo
(braket
id|family
)braket
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
id|afinfo
op_ne
l_int|NULL
)paren
)paren
id|read_lock
c_func
(paren
op_amp
id|afinfo-&gt;lock
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|xfrm_policy_afinfo_lock
)paren
suffix:semicolon
r_return
id|afinfo
suffix:semicolon
)brace
DECL|function|xfrm_policy_put_afinfo
r_static
r_void
id|xfrm_policy_put_afinfo
c_func
(paren
r_struct
id|xfrm_policy_afinfo
op_star
id|afinfo
)paren
(brace
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|afinfo
op_eq
l_int|NULL
)paren
)paren
r_return
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|afinfo-&gt;lock
)paren
suffix:semicolon
)brace
DECL|function|xfrm_dev_event
r_static
r_int
id|xfrm_dev_event
c_func
(paren
r_struct
id|notifier_block
op_star
id|this
comma
r_int
r_int
id|event
comma
r_void
op_star
id|ptr
)paren
(brace
r_switch
c_cond
(paren
id|event
)paren
(brace
r_case
id|NETDEV_DOWN
suffix:colon
id|xfrm_flush_bundles
c_func
(paren
)paren
suffix:semicolon
)brace
r_return
id|NOTIFY_DONE
suffix:semicolon
)brace
DECL|variable|xfrm_dev_notifier
r_struct
id|notifier_block
id|xfrm_dev_notifier
op_assign
(brace
id|xfrm_dev_event
comma
l_int|NULL
comma
l_int|0
)brace
suffix:semicolon
DECL|function|xfrm_policy_init
r_void
id|__init
id|xfrm_policy_init
c_func
(paren
r_void
)paren
(brace
id|xfrm_dst_cache
op_assign
id|kmem_cache_create
c_func
(paren
l_string|&quot;xfrm_dst_cache&quot;
comma
r_sizeof
(paren
r_struct
id|xfrm_dst
)paren
comma
l_int|0
comma
id|SLAB_HWCACHE_ALIGN
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|xfrm_dst_cache
)paren
id|panic
c_func
(paren
l_string|&quot;XFRM: failed to allocate xfrm_dst_cache&bslash;n&quot;
)paren
suffix:semicolon
id|INIT_WORK
c_func
(paren
op_amp
id|xfrm_policy_gc_work
comma
id|xfrm_policy_gc_task
comma
l_int|NULL
)paren
suffix:semicolon
id|register_netdevice_notifier
c_func
(paren
op_amp
id|xfrm_dev_notifier
)paren
suffix:semicolon
)brace
DECL|function|xfrm_init
r_void
id|__init
id|xfrm_init
c_func
(paren
r_void
)paren
(brace
id|xfrm_state_init
c_func
(paren
)paren
suffix:semicolon
id|xfrm_policy_init
c_func
(paren
)paren
suffix:semicolon
id|xfrm_input_init
c_func
(paren
)paren
suffix:semicolon
)brace
eof
