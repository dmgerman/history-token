multiline_comment|/*&n; * xfrm_state.c&n; *&n; * Changes:&n; *&t;Mitsuru KANDA @USAGI&n; * &t;Kazunori MIYAZAWA @USAGI&n; * &t;Kunihiro Ishiguro &lt;kunihiro@ipinfusion.com&gt;&n; * &t;&t;IPv6 support&n; * &t;YOSHIFUJI Hideaki @USAGI&n; * &t;&t;Split up af-specific functions&n; *&t;Derek Atkins &lt;derek@ihtfp.com&gt;&n; *&t;&t;Add UDP Encapsulation&n; * &t;&n; */
macro_line|#include &lt;linux/workqueue.h&gt;
macro_line|#include &lt;net/xfrm.h&gt;
macro_line|#include &lt;linux/pfkeyv2.h&gt;
macro_line|#include &lt;linux/ipsec.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
multiline_comment|/* Each xfrm_state may be linked to two tables:&n;&n;   1. Hash table by (spi,daddr,ah/esp) to find SA by SPI. (input,ctl)&n;   2. Hash table by daddr to find what SAs exist for given&n;      destination/tunnel endpoint. (output)&n; */
DECL|variable|xfrm_state_lock
r_static
id|spinlock_t
id|xfrm_state_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
multiline_comment|/* Hash table to find appropriate SA towards given target (endpoint&n; * of tunnel or destination of transport mode) allowed by selector.&n; *&n; * Main use is finding SA after policy selected tunnel or transport mode.&n; * Also, it can be used by ah/esp icmp error handler to find offending SA.&n; */
DECL|variable|xfrm_state_bydst
r_static
r_struct
id|list_head
id|xfrm_state_bydst
(braket
id|XFRM_DST_HSIZE
)braket
suffix:semicolon
DECL|variable|xfrm_state_byspi
r_static
r_struct
id|list_head
id|xfrm_state_byspi
(braket
id|XFRM_DST_HSIZE
)braket
suffix:semicolon
DECL|variable|km_waitq
id|DECLARE_WAIT_QUEUE_HEAD
c_func
(paren
id|km_waitq
)paren
suffix:semicolon
DECL|variable|xfrm_state_afinfo_lock
r_static
id|rwlock_t
id|xfrm_state_afinfo_lock
op_assign
id|RW_LOCK_UNLOCKED
suffix:semicolon
DECL|variable|xfrm_state_afinfo
r_static
r_struct
id|xfrm_state_afinfo
op_star
id|xfrm_state_afinfo
(braket
id|NPROTO
)braket
suffix:semicolon
DECL|variable|xfrm_state_gc_work
r_static
r_struct
id|work_struct
id|xfrm_state_gc_work
suffix:semicolon
DECL|variable|xfrm_state_gc_list
r_static
r_struct
id|list_head
id|xfrm_state_gc_list
op_assign
id|LIST_HEAD_INIT
c_func
(paren
id|xfrm_state_gc_list
)paren
suffix:semicolon
DECL|variable|xfrm_state_gc_lock
r_static
id|spinlock_t
id|xfrm_state_gc_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
r_static
r_void
id|__xfrm_state_delete
c_func
(paren
r_struct
id|xfrm_state
op_star
id|x
)paren
suffix:semicolon
r_static
r_struct
id|xfrm_state_afinfo
op_star
id|xfrm_state_get_afinfo
c_func
(paren
r_int
r_int
id|family
)paren
suffix:semicolon
r_static
r_void
id|xfrm_state_put_afinfo
c_func
(paren
r_struct
id|xfrm_state_afinfo
op_star
id|afinfo
)paren
suffix:semicolon
r_static
r_int
id|km_query
c_func
(paren
r_struct
id|xfrm_state
op_star
id|x
comma
r_struct
id|xfrm_tmpl
op_star
id|t
comma
r_struct
id|xfrm_policy
op_star
id|pol
)paren
suffix:semicolon
r_static
r_void
id|km_state_expired
c_func
(paren
r_struct
id|xfrm_state
op_star
id|x
comma
r_int
id|hard
)paren
suffix:semicolon
DECL|function|xfrm_state_gc_destroy
r_static
r_void
id|xfrm_state_gc_destroy
c_func
(paren
r_struct
id|xfrm_state
op_star
id|x
)paren
(brace
r_if
c_cond
(paren
id|del_timer
c_func
(paren
op_amp
id|x-&gt;timer
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|x-&gt;aalg
)paren
id|kfree
c_func
(paren
id|x-&gt;aalg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|x-&gt;ealg
)paren
id|kfree
c_func
(paren
id|x-&gt;ealg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|x-&gt;calg
)paren
id|kfree
c_func
(paren
id|x-&gt;calg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|x-&gt;encap
)paren
id|kfree
c_func
(paren
id|x-&gt;encap
)paren
suffix:semicolon
r_if
c_cond
(paren
id|x-&gt;type
)paren
(brace
id|x-&gt;type
op_member_access_from_pointer
id|destructor
c_func
(paren
id|x
)paren
suffix:semicolon
id|xfrm_put_type
c_func
(paren
id|x-&gt;type
)paren
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|x
)paren
suffix:semicolon
)brace
DECL|function|xfrm_state_gc_task
r_static
r_void
id|xfrm_state_gc_task
c_func
(paren
r_void
op_star
id|data
)paren
(brace
r_struct
id|xfrm_state
op_star
id|x
suffix:semicolon
r_struct
id|list_head
op_star
id|entry
comma
op_star
id|tmp
suffix:semicolon
r_struct
id|list_head
id|gc_list
op_assign
id|LIST_HEAD_INIT
c_func
(paren
id|gc_list
)paren
suffix:semicolon
id|spin_lock_bh
c_func
(paren
op_amp
id|xfrm_state_gc_lock
)paren
suffix:semicolon
id|list_splice_init
c_func
(paren
op_amp
id|xfrm_state_gc_list
comma
op_amp
id|gc_list
)paren
suffix:semicolon
id|spin_unlock_bh
c_func
(paren
op_amp
id|xfrm_state_gc_lock
)paren
suffix:semicolon
id|list_for_each_safe
c_func
(paren
id|entry
comma
id|tmp
comma
op_amp
id|gc_list
)paren
(brace
id|x
op_assign
id|list_entry
c_func
(paren
id|entry
comma
r_struct
id|xfrm_state
comma
id|bydst
)paren
suffix:semicolon
id|xfrm_state_gc_destroy
c_func
(paren
id|x
)paren
suffix:semicolon
)brace
id|wake_up
c_func
(paren
op_amp
id|km_waitq
)paren
suffix:semicolon
)brace
DECL|function|make_jiffies
r_static
r_inline
r_int
r_int
id|make_jiffies
c_func
(paren
r_int
id|secs
)paren
(brace
r_if
c_cond
(paren
id|secs
op_ge
(paren
id|MAX_SCHEDULE_TIMEOUT
op_minus
l_int|1
)paren
op_div
id|HZ
)paren
r_return
id|MAX_SCHEDULE_TIMEOUT
op_minus
l_int|1
suffix:semicolon
r_else
r_return
id|secs
op_star
id|HZ
suffix:semicolon
)brace
DECL|function|xfrm_timer_handler
r_static
r_void
id|xfrm_timer_handler
c_func
(paren
r_int
r_int
id|data
)paren
(brace
r_struct
id|xfrm_state
op_star
id|x
op_assign
(paren
r_struct
id|xfrm_state
op_star
)paren
id|data
suffix:semicolon
r_int
r_int
id|now
op_assign
(paren
r_int
r_int
)paren
id|xtime.tv_sec
suffix:semicolon
r_int
id|next
op_assign
id|LONG_MAX
suffix:semicolon
r_int
id|warn
op_assign
l_int|0
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|x-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|x-&gt;km.state
op_eq
id|XFRM_STATE_DEAD
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|x-&gt;km.state
op_eq
id|XFRM_STATE_EXPIRED
)paren
r_goto
id|expired
suffix:semicolon
r_if
c_cond
(paren
id|x-&gt;lft.hard_add_expires_seconds
)paren
(brace
r_int
id|tmo
op_assign
id|x-&gt;lft.hard_add_expires_seconds
op_plus
id|x-&gt;curlft.add_time
op_minus
id|now
suffix:semicolon
r_if
c_cond
(paren
id|tmo
op_le
l_int|0
)paren
r_goto
id|expired
suffix:semicolon
r_if
c_cond
(paren
id|tmo
OL
id|next
)paren
id|next
op_assign
id|tmo
suffix:semicolon
)brace
r_if
c_cond
(paren
id|x-&gt;lft.hard_use_expires_seconds
)paren
(brace
r_int
id|tmo
op_assign
id|x-&gt;lft.hard_use_expires_seconds
op_plus
(paren
id|x-&gt;curlft.use_time
ques
c_cond
suffix:colon
id|now
)paren
op_minus
id|now
suffix:semicolon
r_if
c_cond
(paren
id|tmo
op_le
l_int|0
)paren
r_goto
id|expired
suffix:semicolon
r_if
c_cond
(paren
id|tmo
OL
id|next
)paren
id|next
op_assign
id|tmo
suffix:semicolon
)brace
r_if
c_cond
(paren
id|x-&gt;km.dying
)paren
r_goto
id|resched
suffix:semicolon
r_if
c_cond
(paren
id|x-&gt;lft.soft_add_expires_seconds
)paren
(brace
r_int
id|tmo
op_assign
id|x-&gt;lft.soft_add_expires_seconds
op_plus
id|x-&gt;curlft.add_time
op_minus
id|now
suffix:semicolon
r_if
c_cond
(paren
id|tmo
op_le
l_int|0
)paren
id|warn
op_assign
l_int|1
suffix:semicolon
r_else
r_if
c_cond
(paren
id|tmo
OL
id|next
)paren
id|next
op_assign
id|tmo
suffix:semicolon
)brace
r_if
c_cond
(paren
id|x-&gt;lft.soft_use_expires_seconds
)paren
(brace
r_int
id|tmo
op_assign
id|x-&gt;lft.soft_use_expires_seconds
op_plus
(paren
id|x-&gt;curlft.use_time
ques
c_cond
suffix:colon
id|now
)paren
op_minus
id|now
suffix:semicolon
r_if
c_cond
(paren
id|tmo
op_le
l_int|0
)paren
id|warn
op_assign
l_int|1
suffix:semicolon
r_else
r_if
c_cond
(paren
id|tmo
OL
id|next
)paren
id|next
op_assign
id|tmo
suffix:semicolon
)brace
r_if
c_cond
(paren
id|warn
)paren
id|km_state_expired
c_func
(paren
id|x
comma
l_int|0
)paren
suffix:semicolon
id|resched
suffix:colon
r_if
c_cond
(paren
id|next
op_ne
id|LONG_MAX
op_logical_and
op_logical_neg
id|mod_timer
c_func
(paren
op_amp
id|x-&gt;timer
comma
id|jiffies
op_plus
id|make_jiffies
c_func
(paren
id|next
)paren
)paren
)paren
id|xfrm_state_hold
c_func
(paren
id|x
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
id|expired
suffix:colon
r_if
c_cond
(paren
id|x-&gt;km.state
op_eq
id|XFRM_STATE_ACQ
op_logical_and
id|x-&gt;id.spi
op_eq
l_int|0
)paren
(brace
id|x-&gt;km.state
op_assign
id|XFRM_STATE_EXPIRED
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|km_waitq
)paren
suffix:semicolon
id|next
op_assign
l_int|2
suffix:semicolon
r_goto
id|resched
suffix:semicolon
)brace
r_if
c_cond
(paren
id|x-&gt;id.spi
op_ne
l_int|0
)paren
id|km_state_expired
c_func
(paren
id|x
comma
l_int|1
)paren
suffix:semicolon
id|__xfrm_state_delete
c_func
(paren
id|x
)paren
suffix:semicolon
id|out
suffix:colon
id|spin_unlock
c_func
(paren
op_amp
id|x-&gt;lock
)paren
suffix:semicolon
id|xfrm_state_put
c_func
(paren
id|x
)paren
suffix:semicolon
)brace
DECL|function|xfrm_state_alloc
r_struct
id|xfrm_state
op_star
id|xfrm_state_alloc
c_func
(paren
r_void
)paren
(brace
r_struct
id|xfrm_state
op_star
id|x
suffix:semicolon
id|x
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|xfrm_state
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|x
)paren
(brace
id|memset
c_func
(paren
id|x
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|xfrm_state
)paren
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|x-&gt;refcnt
comma
l_int|1
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|x-&gt;tunnel_users
comma
l_int|0
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|x-&gt;bydst
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|x-&gt;byspi
)paren
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|x-&gt;timer
)paren
suffix:semicolon
id|x-&gt;timer.function
op_assign
id|xfrm_timer_handler
suffix:semicolon
id|x-&gt;timer.data
op_assign
(paren
r_int
r_int
)paren
id|x
suffix:semicolon
id|x-&gt;curlft.add_time
op_assign
(paren
r_int
r_int
)paren
id|xtime.tv_sec
suffix:semicolon
id|x-&gt;lft.soft_byte_limit
op_assign
id|XFRM_INF
suffix:semicolon
id|x-&gt;lft.soft_packet_limit
op_assign
id|XFRM_INF
suffix:semicolon
id|x-&gt;lft.hard_byte_limit
op_assign
id|XFRM_INF
suffix:semicolon
id|x-&gt;lft.hard_packet_limit
op_assign
id|XFRM_INF
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|x-&gt;lock
)paren
suffix:semicolon
)brace
r_return
id|x
suffix:semicolon
)brace
DECL|function|__xfrm_state_destroy
r_void
id|__xfrm_state_destroy
c_func
(paren
r_struct
id|xfrm_state
op_star
id|x
)paren
(brace
id|BUG_TRAP
c_func
(paren
id|x-&gt;km.state
op_eq
id|XFRM_STATE_DEAD
)paren
suffix:semicolon
id|spin_lock_bh
c_func
(paren
op_amp
id|xfrm_state_gc_lock
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|x-&gt;bydst
comma
op_amp
id|xfrm_state_gc_list
)paren
suffix:semicolon
id|spin_unlock_bh
c_func
(paren
op_amp
id|xfrm_state_gc_lock
)paren
suffix:semicolon
id|schedule_work
c_func
(paren
op_amp
id|xfrm_state_gc_work
)paren
suffix:semicolon
)brace
DECL|function|__xfrm_state_delete
r_static
r_void
id|__xfrm_state_delete
c_func
(paren
r_struct
id|xfrm_state
op_star
id|x
)paren
(brace
r_if
c_cond
(paren
id|x-&gt;km.state
op_ne
id|XFRM_STATE_DEAD
)paren
(brace
id|x-&gt;km.state
op_assign
id|XFRM_STATE_DEAD
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|xfrm_state_lock
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|x-&gt;bydst
)paren
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|x-&gt;refcnt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|x-&gt;id.spi
)paren
(brace
id|list_del
c_func
(paren
op_amp
id|x-&gt;byspi
)paren
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|x-&gt;refcnt
)paren
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|xfrm_state_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|del_timer
c_func
(paren
op_amp
id|x-&gt;timer
)paren
)paren
id|atomic_dec
c_func
(paren
op_amp
id|x-&gt;refcnt
)paren
suffix:semicolon
multiline_comment|/* The number two in this test is the reference&n;&t;&t; * mentioned in the comment below plus the reference&n;&t;&t; * our caller holds.  A larger value means that&n;&t;&t; * there are DSTs attached to this xfrm_state.&n;&t;&t; */
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|x-&gt;refcnt
)paren
OG
l_int|2
)paren
id|xfrm_flush_bundles
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* All xfrm_state objects are created by xfrm_state_alloc.&n;&t;&t; * The xfrm_state_alloc call gives a reference, and that&n;&t;&t; * is what we are dropping here.&n;&t;&t; */
id|atomic_dec
c_func
(paren
op_amp
id|x-&gt;refcnt
)paren
suffix:semicolon
)brace
)brace
DECL|function|xfrm_state_delete
r_void
id|xfrm_state_delete
c_func
(paren
r_struct
id|xfrm_state
op_star
id|x
)paren
(brace
id|spin_lock_bh
c_func
(paren
op_amp
id|x-&gt;lock
)paren
suffix:semicolon
id|__xfrm_state_delete
c_func
(paren
id|x
)paren
suffix:semicolon
id|spin_unlock_bh
c_func
(paren
op_amp
id|x-&gt;lock
)paren
suffix:semicolon
)brace
DECL|function|xfrm_state_flush
r_void
id|xfrm_state_flush
c_func
(paren
id|u8
id|proto
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|xfrm_state
op_star
id|x
suffix:semicolon
id|spin_lock_bh
c_func
(paren
op_amp
id|xfrm_state_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|XFRM_DST_HSIZE
suffix:semicolon
id|i
op_increment
)paren
(brace
id|restart
suffix:colon
id|list_for_each_entry
c_func
(paren
id|x
comma
id|xfrm_state_bydst
op_plus
id|i
comma
id|bydst
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|xfrm_state_kern
c_func
(paren
id|x
)paren
op_logical_and
(paren
id|proto
op_eq
id|IPSEC_PROTO_ANY
op_logical_or
id|x-&gt;id.proto
op_eq
id|proto
)paren
)paren
(brace
id|xfrm_state_hold
c_func
(paren
id|x
)paren
suffix:semicolon
id|spin_unlock_bh
c_func
(paren
op_amp
id|xfrm_state_lock
)paren
suffix:semicolon
id|xfrm_state_delete
c_func
(paren
id|x
)paren
suffix:semicolon
id|xfrm_state_put
c_func
(paren
id|x
)paren
suffix:semicolon
id|spin_lock_bh
c_func
(paren
op_amp
id|xfrm_state_lock
)paren
suffix:semicolon
r_goto
id|restart
suffix:semicolon
)brace
)brace
)brace
id|spin_unlock_bh
c_func
(paren
op_amp
id|xfrm_state_lock
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|km_waitq
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|xfrm_init_tempsel
id|xfrm_init_tempsel
c_func
(paren
r_struct
id|xfrm_state
op_star
id|x
comma
r_struct
id|flowi
op_star
id|fl
comma
r_struct
id|xfrm_tmpl
op_star
id|tmpl
comma
id|xfrm_address_t
op_star
id|daddr
comma
id|xfrm_address_t
op_star
id|saddr
comma
r_int
r_int
id|family
)paren
(brace
r_struct
id|xfrm_state_afinfo
op_star
id|afinfo
op_assign
id|xfrm_state_get_afinfo
c_func
(paren
id|family
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|afinfo
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|afinfo
op_member_access_from_pointer
id|init_tempsel
c_func
(paren
id|x
comma
id|fl
comma
id|tmpl
comma
id|daddr
comma
id|saddr
)paren
suffix:semicolon
id|xfrm_state_put_afinfo
c_func
(paren
id|afinfo
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_struct
id|xfrm_state
op_star
DECL|function|xfrm_state_find
id|xfrm_state_find
c_func
(paren
id|xfrm_address_t
op_star
id|daddr
comma
id|xfrm_address_t
op_star
id|saddr
comma
r_struct
id|flowi
op_star
id|fl
comma
r_struct
id|xfrm_tmpl
op_star
id|tmpl
comma
r_struct
id|xfrm_policy
op_star
id|pol
comma
r_int
op_star
id|err
comma
r_int
r_int
id|family
)paren
(brace
r_int
id|h
op_assign
id|xfrm_dst_hash
c_func
(paren
id|daddr
comma
id|family
)paren
suffix:semicolon
r_struct
id|xfrm_state
op_star
id|x
suffix:semicolon
r_int
id|acquire_in_progress
op_assign
l_int|0
suffix:semicolon
r_int
id|error
op_assign
l_int|0
suffix:semicolon
r_struct
id|xfrm_state
op_star
id|best
op_assign
l_int|NULL
suffix:semicolon
id|spin_lock_bh
c_func
(paren
op_amp
id|xfrm_state_lock
)paren
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|x
comma
id|xfrm_state_bydst
op_plus
id|h
comma
id|bydst
)paren
(brace
r_if
c_cond
(paren
id|x-&gt;props.family
op_eq
id|family
op_logical_and
id|x-&gt;props.reqid
op_eq
id|tmpl-&gt;reqid
op_logical_and
id|xfrm_state_addr_check
c_func
(paren
id|x
comma
id|daddr
comma
id|saddr
comma
id|family
)paren
op_logical_and
id|tmpl-&gt;mode
op_eq
id|x-&gt;props.mode
op_logical_and
id|tmpl-&gt;id.proto
op_eq
id|x-&gt;id.proto
)paren
(brace
multiline_comment|/* Resolution logic:&n;&t;&t;&t;   1. There is a valid state with matching selector.&n;&t;&t;&t;      Done.&n;&t;&t;&t;   2. Valid state with inappropriate selector. Skip.&n;&n;&t;&t;&t;   Entering area of &quot;sysdeps&quot;.&n;&n;&t;&t;&t;   3. If state is not valid, selector is temporary,&n;&t;&t;&t;      it selects only session which triggered&n;&t;&t;&t;      previous resolution. Key manager will do&n;&t;&t;&t;      something to install a state with proper&n;&t;&t;&t;      selector.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|x-&gt;km.state
op_eq
id|XFRM_STATE_VALID
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|xfrm_selector_match
c_func
(paren
op_amp
id|x-&gt;sel
comma
id|fl
comma
id|family
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|best
op_logical_or
id|best-&gt;km.dying
OG
id|x-&gt;km.dying
op_logical_or
(paren
id|best-&gt;km.dying
op_eq
id|x-&gt;km.dying
op_logical_and
id|best-&gt;curlft.add_time
OL
id|x-&gt;curlft.add_time
)paren
)paren
id|best
op_assign
id|x
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|x-&gt;km.state
op_eq
id|XFRM_STATE_ACQ
)paren
(brace
id|acquire_in_progress
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|x-&gt;km.state
op_eq
id|XFRM_STATE_ERROR
op_logical_or
id|x-&gt;km.state
op_eq
id|XFRM_STATE_EXPIRED
)paren
(brace
r_if
c_cond
(paren
id|xfrm_selector_match
c_func
(paren
op_amp
id|x-&gt;sel
comma
id|fl
comma
id|family
)paren
)paren
id|error
op_assign
l_int|1
suffix:semicolon
)brace
)brace
)brace
id|x
op_assign
id|best
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|x
op_logical_and
op_logical_neg
id|error
op_logical_and
op_logical_neg
id|acquire_in_progress
op_logical_and
(paren
(paren
id|x
op_assign
id|xfrm_state_alloc
c_func
(paren
)paren
)paren
op_ne
l_int|NULL
)paren
)paren
(brace
multiline_comment|/* Initialize temporary selector matching only&n;&t;&t; * to current session. */
id|xfrm_init_tempsel
c_func
(paren
id|x
comma
id|fl
comma
id|tmpl
comma
id|daddr
comma
id|saddr
comma
id|family
)paren
suffix:semicolon
r_if
c_cond
(paren
id|km_query
c_func
(paren
id|x
comma
id|tmpl
comma
id|pol
)paren
op_eq
l_int|0
)paren
(brace
id|x-&gt;km.state
op_assign
id|XFRM_STATE_ACQ
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|x-&gt;bydst
comma
id|xfrm_state_bydst
op_plus
id|h
)paren
suffix:semicolon
id|xfrm_state_hold
c_func
(paren
id|x
)paren
suffix:semicolon
r_if
c_cond
(paren
id|x-&gt;id.spi
)paren
(brace
id|h
op_assign
id|xfrm_spi_hash
c_func
(paren
op_amp
id|x-&gt;id.daddr
comma
id|x-&gt;id.spi
comma
id|x-&gt;id.proto
comma
id|family
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|x-&gt;byspi
comma
id|xfrm_state_byspi
op_plus
id|h
)paren
suffix:semicolon
id|xfrm_state_hold
c_func
(paren
id|x
)paren
suffix:semicolon
)brace
id|x-&gt;lft.hard_add_expires_seconds
op_assign
id|XFRM_ACQ_EXPIRES
suffix:semicolon
id|xfrm_state_hold
c_func
(paren
id|x
)paren
suffix:semicolon
id|x-&gt;timer.expires
op_assign
id|jiffies
op_plus
id|XFRM_ACQ_EXPIRES
op_star
id|HZ
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|x-&gt;timer
)paren
suffix:semicolon
)brace
r_else
(brace
id|x-&gt;km.state
op_assign
id|XFRM_STATE_DEAD
suffix:semicolon
id|xfrm_state_put
c_func
(paren
id|x
)paren
suffix:semicolon
id|x
op_assign
l_int|NULL
suffix:semicolon
id|error
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|x
)paren
id|xfrm_state_hold
c_func
(paren
id|x
)paren
suffix:semicolon
r_else
op_star
id|err
op_assign
id|acquire_in_progress
ques
c_cond
op_minus
id|EAGAIN
suffix:colon
(paren
id|error
ques
c_cond
op_minus
id|ESRCH
suffix:colon
op_minus
id|ENOMEM
)paren
suffix:semicolon
id|spin_unlock_bh
c_func
(paren
op_amp
id|xfrm_state_lock
)paren
suffix:semicolon
r_return
id|x
suffix:semicolon
)brace
DECL|function|__xfrm_state_insert
r_static
r_void
id|__xfrm_state_insert
c_func
(paren
r_struct
id|xfrm_state
op_star
id|x
)paren
(brace
r_int
id|h
op_assign
id|xfrm_dst_hash
c_func
(paren
op_amp
id|x-&gt;id.daddr
comma
id|x-&gt;props.family
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|x-&gt;bydst
comma
id|xfrm_state_bydst
op_plus
id|h
)paren
suffix:semicolon
id|xfrm_state_hold
c_func
(paren
id|x
)paren
suffix:semicolon
id|h
op_assign
id|xfrm_spi_hash
c_func
(paren
op_amp
id|x-&gt;id.daddr
comma
id|x-&gt;id.spi
comma
id|x-&gt;id.proto
comma
id|x-&gt;props.family
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|x-&gt;byspi
comma
id|xfrm_state_byspi
op_plus
id|h
)paren
suffix:semicolon
id|xfrm_state_hold
c_func
(paren
id|x
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mod_timer
c_func
(paren
op_amp
id|x-&gt;timer
comma
id|jiffies
op_plus
id|HZ
)paren
)paren
id|xfrm_state_hold
c_func
(paren
id|x
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|km_waitq
)paren
suffix:semicolon
)brace
DECL|function|xfrm_state_insert
r_void
id|xfrm_state_insert
c_func
(paren
r_struct
id|xfrm_state
op_star
id|x
)paren
(brace
id|spin_lock_bh
c_func
(paren
op_amp
id|xfrm_state_lock
)paren
suffix:semicolon
id|__xfrm_state_insert
c_func
(paren
id|x
)paren
suffix:semicolon
id|spin_unlock_bh
c_func
(paren
op_amp
id|xfrm_state_lock
)paren
suffix:semicolon
)brace
r_static
r_struct
id|xfrm_state
op_star
id|__xfrm_find_acq_byseq
c_func
(paren
id|u32
id|seq
)paren
suffix:semicolon
DECL|function|xfrm_state_add
r_int
id|xfrm_state_add
c_func
(paren
r_struct
id|xfrm_state
op_star
id|x
)paren
(brace
r_struct
id|xfrm_state_afinfo
op_star
id|afinfo
suffix:semicolon
r_struct
id|xfrm_state
op_star
id|x1
suffix:semicolon
r_int
id|family
suffix:semicolon
r_int
id|err
suffix:semicolon
id|family
op_assign
id|x-&gt;props.family
suffix:semicolon
id|afinfo
op_assign
id|xfrm_state_get_afinfo
c_func
(paren
id|family
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|afinfo
op_eq
l_int|NULL
)paren
)paren
r_return
op_minus
id|EAFNOSUPPORT
suffix:semicolon
id|spin_lock_bh
c_func
(paren
op_amp
id|xfrm_state_lock
)paren
suffix:semicolon
id|x1
op_assign
id|afinfo
op_member_access_from_pointer
id|state_lookup
c_func
(paren
op_amp
id|x-&gt;id.daddr
comma
id|x-&gt;id.spi
comma
id|x-&gt;id.proto
)paren
suffix:semicolon
r_if
c_cond
(paren
id|x1
)paren
(brace
id|xfrm_state_put
c_func
(paren
id|x1
)paren
suffix:semicolon
id|x1
op_assign
l_int|NULL
suffix:semicolon
id|err
op_assign
op_minus
id|EEXIST
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|x-&gt;km.seq
)paren
(brace
id|x1
op_assign
id|__xfrm_find_acq_byseq
c_func
(paren
id|x-&gt;km.seq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|x1
op_logical_and
id|xfrm_addr_cmp
c_func
(paren
op_amp
id|x1-&gt;id.daddr
comma
op_amp
id|x-&gt;id.daddr
comma
id|family
)paren
)paren
(brace
id|xfrm_state_put
c_func
(paren
id|x1
)paren
suffix:semicolon
id|x1
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|x1
)paren
id|x1
op_assign
id|afinfo
op_member_access_from_pointer
id|find_acq
c_func
(paren
id|x-&gt;props.mode
comma
id|x-&gt;props.reqid
comma
id|x-&gt;id.proto
comma
op_amp
id|x-&gt;id.daddr
comma
op_amp
id|x-&gt;props.saddr
comma
l_int|0
)paren
suffix:semicolon
id|__xfrm_state_insert
c_func
(paren
id|x
)paren
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
id|out
suffix:colon
id|spin_unlock_bh
c_func
(paren
op_amp
id|xfrm_state_lock
)paren
suffix:semicolon
id|xfrm_state_put_afinfo
c_func
(paren
id|afinfo
)paren
suffix:semicolon
r_if
c_cond
(paren
id|x1
)paren
(brace
id|xfrm_state_delete
c_func
(paren
id|x1
)paren
suffix:semicolon
id|xfrm_state_put
c_func
(paren
id|x1
)paren
suffix:semicolon
)brace
r_return
id|err
suffix:semicolon
)brace
DECL|function|xfrm_state_update
r_int
id|xfrm_state_update
c_func
(paren
r_struct
id|xfrm_state
op_star
id|x
)paren
(brace
r_struct
id|xfrm_state_afinfo
op_star
id|afinfo
suffix:semicolon
r_struct
id|xfrm_state
op_star
id|x1
suffix:semicolon
r_int
id|err
suffix:semicolon
id|afinfo
op_assign
id|xfrm_state_get_afinfo
c_func
(paren
id|x-&gt;props.family
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|afinfo
op_eq
l_int|NULL
)paren
)paren
r_return
op_minus
id|EAFNOSUPPORT
suffix:semicolon
id|spin_lock_bh
c_func
(paren
op_amp
id|xfrm_state_lock
)paren
suffix:semicolon
id|x1
op_assign
id|afinfo
op_member_access_from_pointer
id|state_lookup
c_func
(paren
op_amp
id|x-&gt;id.daddr
comma
id|x-&gt;id.spi
comma
id|x-&gt;id.proto
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|ESRCH
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|x1
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|xfrm_state_kern
c_func
(paren
id|x1
)paren
)paren
(brace
id|xfrm_state_put
c_func
(paren
id|x1
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EEXIST
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|x1-&gt;km.state
op_eq
id|XFRM_STATE_ACQ
)paren
(brace
id|__xfrm_state_insert
c_func
(paren
id|x
)paren
suffix:semicolon
id|x
op_assign
l_int|NULL
suffix:semicolon
)brace
id|err
op_assign
l_int|0
suffix:semicolon
id|out
suffix:colon
id|spin_unlock_bh
c_func
(paren
op_amp
id|xfrm_state_lock
)paren
suffix:semicolon
id|xfrm_state_put_afinfo
c_func
(paren
id|afinfo
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|x
)paren
(brace
id|xfrm_state_delete
c_func
(paren
id|x1
)paren
suffix:semicolon
id|xfrm_state_put
c_func
(paren
id|x1
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
id|spin_lock_bh
c_func
(paren
op_amp
id|x1-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
id|x1-&gt;km.state
op_eq
id|XFRM_STATE_VALID
)paren
)paren
(brace
r_if
c_cond
(paren
id|x-&gt;encap
op_logical_and
id|x1-&gt;encap
)paren
id|memcpy
c_func
(paren
id|x1-&gt;encap
comma
id|x-&gt;encap
comma
r_sizeof
(paren
op_star
id|x1-&gt;encap
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|x1-&gt;lft
comma
op_amp
id|x-&gt;lft
comma
r_sizeof
(paren
id|x1-&gt;lft
)paren
)paren
suffix:semicolon
id|x1-&gt;km.dying
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mod_timer
c_func
(paren
op_amp
id|x1-&gt;timer
comma
id|jiffies
op_plus
id|HZ
)paren
)paren
id|xfrm_state_hold
c_func
(paren
id|x1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|x1-&gt;curlft.use_time
)paren
id|xfrm_state_check_expire
c_func
(paren
id|x1
)paren
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
)brace
id|spin_unlock_bh
c_func
(paren
op_amp
id|x1-&gt;lock
)paren
suffix:semicolon
id|xfrm_state_put
c_func
(paren
id|x1
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|function|xfrm_state_check_expire
r_int
id|xfrm_state_check_expire
c_func
(paren
r_struct
id|xfrm_state
op_star
id|x
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|x-&gt;curlft.use_time
)paren
id|x-&gt;curlft.use_time
op_assign
(paren
r_int
r_int
)paren
id|xtime.tv_sec
suffix:semicolon
r_if
c_cond
(paren
id|x-&gt;km.state
op_ne
id|XFRM_STATE_VALID
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|x-&gt;curlft.bytes
op_ge
id|x-&gt;lft.hard_byte_limit
op_logical_or
id|x-&gt;curlft.packets
op_ge
id|x-&gt;lft.hard_packet_limit
)paren
(brace
id|km_state_expired
c_func
(paren
id|x
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mod_timer
c_func
(paren
op_amp
id|x-&gt;timer
comma
id|jiffies
op_plus
id|XFRM_ACQ_EXPIRES
op_star
id|HZ
)paren
)paren
id|xfrm_state_hold
c_func
(paren
id|x
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|x-&gt;km.dying
op_logical_and
(paren
id|x-&gt;curlft.bytes
op_ge
id|x-&gt;lft.soft_byte_limit
op_logical_or
id|x-&gt;curlft.packets
op_ge
id|x-&gt;lft.soft_packet_limit
)paren
)paren
id|km_state_expired
c_func
(paren
id|x
comma
l_int|0
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|xfrm_state_check_space
r_static
r_int
id|xfrm_state_check_space
c_func
(paren
r_struct
id|xfrm_state
op_star
id|x
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_int
id|nhead
op_assign
id|x-&gt;props.header_len
op_plus
id|LL_RESERVED_SPACE
c_func
(paren
id|skb-&gt;dst-&gt;dev
)paren
op_minus
id|skb_headroom
c_func
(paren
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nhead
OG
l_int|0
)paren
r_return
id|pskb_expand_head
c_func
(paren
id|skb
comma
id|nhead
comma
l_int|0
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
multiline_comment|/* Check tail too... */
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|xfrm_state_check
r_int
id|xfrm_state_check
c_func
(paren
r_struct
id|xfrm_state
op_star
id|x
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_int
id|err
op_assign
id|xfrm_state_check_expire
c_func
(paren
id|x
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_goto
id|err
suffix:semicolon
id|err
op_assign
id|xfrm_state_check_space
c_func
(paren
id|x
comma
id|skb
)paren
suffix:semicolon
id|err
suffix:colon
r_return
id|err
suffix:semicolon
)brace
r_struct
id|xfrm_state
op_star
DECL|function|xfrm_state_lookup
id|xfrm_state_lookup
c_func
(paren
id|xfrm_address_t
op_star
id|daddr
comma
id|u32
id|spi
comma
id|u8
id|proto
comma
r_int
r_int
id|family
)paren
(brace
r_struct
id|xfrm_state
op_star
id|x
suffix:semicolon
r_struct
id|xfrm_state_afinfo
op_star
id|afinfo
op_assign
id|xfrm_state_get_afinfo
c_func
(paren
id|family
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|afinfo
)paren
r_return
l_int|NULL
suffix:semicolon
id|spin_lock_bh
c_func
(paren
op_amp
id|xfrm_state_lock
)paren
suffix:semicolon
id|x
op_assign
id|afinfo
op_member_access_from_pointer
id|state_lookup
c_func
(paren
id|daddr
comma
id|spi
comma
id|proto
)paren
suffix:semicolon
id|spin_unlock_bh
c_func
(paren
op_amp
id|xfrm_state_lock
)paren
suffix:semicolon
id|xfrm_state_put_afinfo
c_func
(paren
id|afinfo
)paren
suffix:semicolon
r_return
id|x
suffix:semicolon
)brace
r_struct
id|xfrm_state
op_star
DECL|function|xfrm_find_acq
id|xfrm_find_acq
c_func
(paren
id|u8
id|mode
comma
id|u32
id|reqid
comma
id|u8
id|proto
comma
id|xfrm_address_t
op_star
id|daddr
comma
id|xfrm_address_t
op_star
id|saddr
comma
r_int
id|create
comma
r_int
r_int
id|family
)paren
(brace
r_struct
id|xfrm_state
op_star
id|x
suffix:semicolon
r_struct
id|xfrm_state_afinfo
op_star
id|afinfo
op_assign
id|xfrm_state_get_afinfo
c_func
(paren
id|family
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|afinfo
)paren
r_return
l_int|NULL
suffix:semicolon
id|spin_lock_bh
c_func
(paren
op_amp
id|xfrm_state_lock
)paren
suffix:semicolon
id|x
op_assign
id|afinfo
op_member_access_from_pointer
id|find_acq
c_func
(paren
id|mode
comma
id|reqid
comma
id|proto
comma
id|daddr
comma
id|saddr
comma
id|create
)paren
suffix:semicolon
id|spin_unlock_bh
c_func
(paren
op_amp
id|xfrm_state_lock
)paren
suffix:semicolon
id|xfrm_state_put_afinfo
c_func
(paren
id|afinfo
)paren
suffix:semicolon
r_return
id|x
suffix:semicolon
)brace
multiline_comment|/* Silly enough, but I&squot;m lazy to build resolution list */
DECL|function|__xfrm_find_acq_byseq
r_static
r_struct
id|xfrm_state
op_star
id|__xfrm_find_acq_byseq
c_func
(paren
id|u32
id|seq
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|xfrm_state
op_star
id|x
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|XFRM_DST_HSIZE
suffix:semicolon
id|i
op_increment
)paren
(brace
id|list_for_each_entry
c_func
(paren
id|x
comma
id|xfrm_state_bydst
op_plus
id|i
comma
id|bydst
)paren
(brace
r_if
c_cond
(paren
id|x-&gt;km.seq
op_eq
id|seq
)paren
(brace
id|xfrm_state_hold
c_func
(paren
id|x
)paren
suffix:semicolon
r_return
id|x
suffix:semicolon
)brace
)brace
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|xfrm_find_acq_byseq
r_struct
id|xfrm_state
op_star
id|xfrm_find_acq_byseq
c_func
(paren
id|u32
id|seq
)paren
(brace
r_struct
id|xfrm_state
op_star
id|x
suffix:semicolon
id|spin_lock_bh
c_func
(paren
op_amp
id|xfrm_state_lock
)paren
suffix:semicolon
id|x
op_assign
id|__xfrm_find_acq_byseq
c_func
(paren
id|seq
)paren
suffix:semicolon
id|spin_unlock_bh
c_func
(paren
op_amp
id|xfrm_state_lock
)paren
suffix:semicolon
r_return
id|x
suffix:semicolon
)brace
DECL|function|xfrm_get_acqseq
id|u32
id|xfrm_get_acqseq
c_func
(paren
r_void
)paren
(brace
id|u32
id|res
suffix:semicolon
r_static
id|u32
id|acqseq
suffix:semicolon
r_static
id|spinlock_t
id|acqseq_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
id|spin_lock_bh
c_func
(paren
op_amp
id|acqseq_lock
)paren
suffix:semicolon
id|res
op_assign
(paren
op_increment
id|acqseq
ques
c_cond
suffix:colon
op_increment
id|acqseq
)paren
suffix:semicolon
id|spin_unlock_bh
c_func
(paren
op_amp
id|acqseq_lock
)paren
suffix:semicolon
r_return
id|res
suffix:semicolon
)brace
r_void
DECL|function|xfrm_alloc_spi
id|xfrm_alloc_spi
c_func
(paren
r_struct
id|xfrm_state
op_star
id|x
comma
id|u32
id|minspi
comma
id|u32
id|maxspi
)paren
(brace
id|u32
id|h
suffix:semicolon
r_struct
id|xfrm_state
op_star
id|x0
suffix:semicolon
r_if
c_cond
(paren
id|x-&gt;id.spi
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|minspi
op_eq
id|maxspi
)paren
(brace
id|x0
op_assign
id|xfrm_state_lookup
c_func
(paren
op_amp
id|x-&gt;id.daddr
comma
id|minspi
comma
id|x-&gt;id.proto
comma
id|x-&gt;props.family
)paren
suffix:semicolon
r_if
c_cond
(paren
id|x0
)paren
(brace
id|xfrm_state_put
c_func
(paren
id|x0
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|x-&gt;id.spi
op_assign
id|minspi
suffix:semicolon
)brace
r_else
(brace
id|u32
id|spi
op_assign
l_int|0
suffix:semicolon
id|minspi
op_assign
id|ntohl
c_func
(paren
id|minspi
)paren
suffix:semicolon
id|maxspi
op_assign
id|ntohl
c_func
(paren
id|maxspi
)paren
suffix:semicolon
r_for
c_loop
(paren
id|h
op_assign
l_int|0
suffix:semicolon
id|h
OL
id|maxspi
op_minus
id|minspi
op_plus
l_int|1
suffix:semicolon
id|h
op_increment
)paren
(brace
id|spi
op_assign
id|minspi
op_plus
id|net_random
c_func
(paren
)paren
op_mod
(paren
id|maxspi
op_minus
id|minspi
op_plus
l_int|1
)paren
suffix:semicolon
id|x0
op_assign
id|xfrm_state_lookup
c_func
(paren
op_amp
id|x-&gt;id.daddr
comma
id|htonl
c_func
(paren
id|spi
)paren
comma
id|x-&gt;id.proto
comma
id|x-&gt;props.family
)paren
suffix:semicolon
r_if
c_cond
(paren
id|x0
op_eq
l_int|NULL
)paren
(brace
id|x-&gt;id.spi
op_assign
id|htonl
c_func
(paren
id|spi
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|xfrm_state_put
c_func
(paren
id|x0
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|x-&gt;id.spi
)paren
(brace
id|spin_lock_bh
c_func
(paren
op_amp
id|xfrm_state_lock
)paren
suffix:semicolon
id|h
op_assign
id|xfrm_spi_hash
c_func
(paren
op_amp
id|x-&gt;id.daddr
comma
id|x-&gt;id.spi
comma
id|x-&gt;id.proto
comma
id|x-&gt;props.family
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|x-&gt;byspi
comma
id|xfrm_state_byspi
op_plus
id|h
)paren
suffix:semicolon
id|xfrm_state_hold
c_func
(paren
id|x
)paren
suffix:semicolon
id|spin_unlock_bh
c_func
(paren
op_amp
id|xfrm_state_lock
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|km_waitq
)paren
suffix:semicolon
)brace
)brace
DECL|function|xfrm_state_walk
r_int
id|xfrm_state_walk
c_func
(paren
id|u8
id|proto
comma
r_int
(paren
op_star
id|func
)paren
(paren
r_struct
id|xfrm_state
op_star
comma
r_int
comma
r_void
op_star
)paren
comma
r_void
op_star
id|data
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|xfrm_state
op_star
id|x
suffix:semicolon
r_int
id|count
op_assign
l_int|0
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
id|spin_lock_bh
c_func
(paren
op_amp
id|xfrm_state_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|XFRM_DST_HSIZE
suffix:semicolon
id|i
op_increment
)paren
(brace
id|list_for_each_entry
c_func
(paren
id|x
comma
id|xfrm_state_bydst
op_plus
id|i
comma
id|bydst
)paren
(brace
r_if
c_cond
(paren
id|proto
op_eq
id|IPSEC_PROTO_ANY
op_logical_or
id|x-&gt;id.proto
op_eq
id|proto
)paren
id|count
op_increment
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|count
op_eq
l_int|0
)paren
(brace
id|err
op_assign
op_minus
id|ENOENT
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|XFRM_DST_HSIZE
suffix:semicolon
id|i
op_increment
)paren
(brace
id|list_for_each_entry
c_func
(paren
id|x
comma
id|xfrm_state_bydst
op_plus
id|i
comma
id|bydst
)paren
(brace
r_if
c_cond
(paren
id|proto
op_ne
id|IPSEC_PROTO_ANY
op_logical_and
id|x-&gt;id.proto
op_ne
id|proto
)paren
r_continue
suffix:semicolon
id|err
op_assign
id|func
c_func
(paren
id|x
comma
op_decrement
id|count
comma
id|data
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out
suffix:semicolon
)brace
)brace
id|out
suffix:colon
id|spin_unlock_bh
c_func
(paren
op_amp
id|xfrm_state_lock
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|function|xfrm_replay_check
r_int
id|xfrm_replay_check
c_func
(paren
r_struct
id|xfrm_state
op_star
id|x
comma
id|u32
id|seq
)paren
(brace
id|u32
id|diff
suffix:semicolon
id|seq
op_assign
id|ntohl
c_func
(paren
id|seq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|seq
op_eq
l_int|0
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
id|seq
OG
id|x-&gt;replay.seq
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|diff
op_assign
id|x-&gt;replay.seq
op_minus
id|seq
suffix:semicolon
r_if
c_cond
(paren
id|diff
op_ge
id|x-&gt;props.replay_window
)paren
(brace
id|x-&gt;stats.replay_window
op_increment
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|x-&gt;replay.bitmap
op_amp
(paren
l_int|1U
op_lshift
id|diff
)paren
)paren
(brace
id|x-&gt;stats.replay
op_increment
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|xfrm_replay_advance
r_void
id|xfrm_replay_advance
c_func
(paren
r_struct
id|xfrm_state
op_star
id|x
comma
id|u32
id|seq
)paren
(brace
id|u32
id|diff
suffix:semicolon
id|seq
op_assign
id|ntohl
c_func
(paren
id|seq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|seq
OG
id|x-&gt;replay.seq
)paren
(brace
id|diff
op_assign
id|seq
op_minus
id|x-&gt;replay.seq
suffix:semicolon
r_if
c_cond
(paren
id|diff
OL
id|x-&gt;props.replay_window
)paren
id|x-&gt;replay.bitmap
op_assign
(paren
(paren
id|x-&gt;replay.bitmap
)paren
op_lshift
id|diff
)paren
op_or
l_int|1
suffix:semicolon
r_else
id|x-&gt;replay.bitmap
op_assign
l_int|1
suffix:semicolon
id|x-&gt;replay.seq
op_assign
id|seq
suffix:semicolon
)brace
r_else
(brace
id|diff
op_assign
id|x-&gt;replay.seq
op_minus
id|seq
suffix:semicolon
id|x-&gt;replay.bitmap
op_or_assign
(paren
l_int|1U
op_lshift
id|diff
)paren
suffix:semicolon
)brace
)brace
DECL|variable|xfrm_km_list
r_static
r_struct
id|list_head
id|xfrm_km_list
op_assign
id|LIST_HEAD_INIT
c_func
(paren
id|xfrm_km_list
)paren
suffix:semicolon
DECL|variable|xfrm_km_lock
r_static
id|rwlock_t
id|xfrm_km_lock
op_assign
id|RW_LOCK_UNLOCKED
suffix:semicolon
DECL|function|km_state_expired
r_static
r_void
id|km_state_expired
c_func
(paren
r_struct
id|xfrm_state
op_star
id|x
comma
r_int
id|hard
)paren
(brace
r_struct
id|xfrm_mgr
op_star
id|km
suffix:semicolon
r_if
c_cond
(paren
id|hard
)paren
id|x-&gt;km.state
op_assign
id|XFRM_STATE_EXPIRED
suffix:semicolon
r_else
id|x-&gt;km.dying
op_assign
l_int|1
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|xfrm_km_lock
)paren
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|km
comma
op_amp
id|xfrm_km_list
comma
id|list
)paren
id|km
op_member_access_from_pointer
id|notify
c_func
(paren
id|x
comma
id|hard
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|xfrm_km_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hard
)paren
id|wake_up
c_func
(paren
op_amp
id|km_waitq
)paren
suffix:semicolon
)brace
DECL|function|km_query
r_static
r_int
id|km_query
c_func
(paren
r_struct
id|xfrm_state
op_star
id|x
comma
r_struct
id|xfrm_tmpl
op_star
id|t
comma
r_struct
id|xfrm_policy
op_star
id|pol
)paren
(brace
r_int
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_struct
id|xfrm_mgr
op_star
id|km
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|xfrm_km_lock
)paren
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|km
comma
op_amp
id|xfrm_km_list
comma
id|list
)paren
(brace
id|err
op_assign
id|km
op_member_access_from_pointer
id|acquire
c_func
(paren
id|x
comma
id|t
comma
id|pol
comma
id|XFRM_POLICY_OUT
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|err
)paren
r_break
suffix:semicolon
)brace
id|read_unlock
c_func
(paren
op_amp
id|xfrm_km_lock
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|function|km_new_mapping
r_int
id|km_new_mapping
c_func
(paren
r_struct
id|xfrm_state
op_star
id|x
comma
id|xfrm_address_t
op_star
id|ipaddr
comma
id|u16
id|sport
)paren
(brace
r_int
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_struct
id|xfrm_mgr
op_star
id|km
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|xfrm_km_lock
)paren
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|km
comma
op_amp
id|xfrm_km_list
comma
id|list
)paren
(brace
r_if
c_cond
(paren
id|km-&gt;new_mapping
)paren
id|err
op_assign
id|km
op_member_access_from_pointer
id|new_mapping
c_func
(paren
id|x
comma
id|ipaddr
comma
id|sport
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|err
)paren
r_break
suffix:semicolon
)brace
id|read_unlock
c_func
(paren
op_amp
id|xfrm_km_lock
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|function|km_policy_expired
r_void
id|km_policy_expired
c_func
(paren
r_struct
id|xfrm_policy
op_star
id|pol
comma
r_int
id|dir
comma
r_int
id|hard
)paren
(brace
r_struct
id|xfrm_mgr
op_star
id|km
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|xfrm_km_lock
)paren
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|km
comma
op_amp
id|xfrm_km_list
comma
id|list
)paren
r_if
c_cond
(paren
id|km-&gt;notify_policy
)paren
id|km
op_member_access_from_pointer
id|notify_policy
c_func
(paren
id|pol
comma
id|dir
comma
id|hard
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|xfrm_km_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hard
)paren
id|wake_up
c_func
(paren
op_amp
id|km_waitq
)paren
suffix:semicolon
)brace
DECL|function|xfrm_user_policy
r_int
id|xfrm_user_policy
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|optname
comma
id|u8
id|__user
op_star
id|optval
comma
r_int
id|optlen
)paren
(brace
r_int
id|err
suffix:semicolon
id|u8
op_star
id|data
suffix:semicolon
r_struct
id|xfrm_mgr
op_star
id|km
suffix:semicolon
r_struct
id|xfrm_policy
op_star
id|pol
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|optlen
op_le
l_int|0
op_logical_or
id|optlen
OG
id|PAGE_SIZE
)paren
r_return
op_minus
id|EMSGSIZE
suffix:semicolon
id|data
op_assign
id|kmalloc
c_func
(paren
id|optlen
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|data
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|err
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|data
comma
id|optval
comma
id|optlen
)paren
)paren
r_goto
id|out
suffix:semicolon
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|xfrm_km_lock
)paren
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|km
comma
op_amp
id|xfrm_km_list
comma
id|list
)paren
(brace
id|pol
op_assign
id|km
op_member_access_from_pointer
id|compile_policy
c_func
(paren
id|sk-&gt;sk_family
comma
id|optname
comma
id|data
comma
id|optlen
comma
op_amp
id|err
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_ge
l_int|0
)paren
r_break
suffix:semicolon
)brace
id|read_unlock
c_func
(paren
op_amp
id|xfrm_km_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_ge
l_int|0
)paren
(brace
id|xfrm_sk_policy_insert
c_func
(paren
id|sk
comma
id|err
comma
id|pol
)paren
suffix:semicolon
id|xfrm_pol_put
c_func
(paren
id|pol
)paren
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
)brace
id|out
suffix:colon
id|kfree
c_func
(paren
id|data
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|function|xfrm_register_km
r_int
id|xfrm_register_km
c_func
(paren
r_struct
id|xfrm_mgr
op_star
id|km
)paren
(brace
id|write_lock_bh
c_func
(paren
op_amp
id|xfrm_km_lock
)paren
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|km-&gt;list
comma
op_amp
id|xfrm_km_list
)paren
suffix:semicolon
id|write_unlock_bh
c_func
(paren
op_amp
id|xfrm_km_lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|xfrm_unregister_km
r_int
id|xfrm_unregister_km
c_func
(paren
r_struct
id|xfrm_mgr
op_star
id|km
)paren
(brace
id|write_lock_bh
c_func
(paren
op_amp
id|xfrm_km_lock
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|km-&gt;list
)paren
suffix:semicolon
id|write_unlock_bh
c_func
(paren
op_amp
id|xfrm_km_lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|xfrm_state_register_afinfo
r_int
id|xfrm_state_register_afinfo
c_func
(paren
r_struct
id|xfrm_state_afinfo
op_star
id|afinfo
)paren
(brace
r_int
id|err
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|afinfo
op_eq
l_int|NULL
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|afinfo-&gt;family
op_ge
id|NPROTO
)paren
)paren
r_return
op_minus
id|EAFNOSUPPORT
suffix:semicolon
id|write_lock
c_func
(paren
op_amp
id|xfrm_state_afinfo_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|xfrm_state_afinfo
(braket
id|afinfo-&gt;family
)braket
op_ne
l_int|NULL
)paren
)paren
id|err
op_assign
op_minus
id|ENOBUFS
suffix:semicolon
r_else
(brace
id|afinfo-&gt;state_bydst
op_assign
id|xfrm_state_bydst
suffix:semicolon
id|afinfo-&gt;state_byspi
op_assign
id|xfrm_state_byspi
suffix:semicolon
id|xfrm_state_afinfo
(braket
id|afinfo-&gt;family
)braket
op_assign
id|afinfo
suffix:semicolon
)brace
id|write_unlock
c_func
(paren
op_amp
id|xfrm_state_afinfo_lock
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|function|xfrm_state_unregister_afinfo
r_int
id|xfrm_state_unregister_afinfo
c_func
(paren
r_struct
id|xfrm_state_afinfo
op_star
id|afinfo
)paren
(brace
r_int
id|err
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|afinfo
op_eq
l_int|NULL
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|afinfo-&gt;family
op_ge
id|NPROTO
)paren
)paren
r_return
op_minus
id|EAFNOSUPPORT
suffix:semicolon
id|write_lock
c_func
(paren
op_amp
id|xfrm_state_afinfo_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
id|xfrm_state_afinfo
(braket
id|afinfo-&gt;family
)braket
op_ne
l_int|NULL
)paren
)paren
(brace
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|xfrm_state_afinfo
(braket
id|afinfo-&gt;family
)braket
op_ne
id|afinfo
)paren
)paren
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_else
(brace
id|xfrm_state_afinfo
(braket
id|afinfo-&gt;family
)braket
op_assign
l_int|NULL
suffix:semicolon
id|afinfo-&gt;state_byspi
op_assign
l_int|NULL
suffix:semicolon
id|afinfo-&gt;state_bydst
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
id|write_unlock
c_func
(paren
op_amp
id|xfrm_state_afinfo_lock
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|function|xfrm_state_get_afinfo
r_static
r_struct
id|xfrm_state_afinfo
op_star
id|xfrm_state_get_afinfo
c_func
(paren
r_int
r_int
id|family
)paren
(brace
r_struct
id|xfrm_state_afinfo
op_star
id|afinfo
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|family
op_ge
id|NPROTO
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|xfrm_state_afinfo_lock
)paren
suffix:semicolon
id|afinfo
op_assign
id|xfrm_state_afinfo
(braket
id|family
)braket
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
id|afinfo
op_ne
l_int|NULL
)paren
)paren
id|read_lock
c_func
(paren
op_amp
id|afinfo-&gt;lock
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|xfrm_state_afinfo_lock
)paren
suffix:semicolon
r_return
id|afinfo
suffix:semicolon
)brace
DECL|function|xfrm_state_put_afinfo
r_static
r_void
id|xfrm_state_put_afinfo
c_func
(paren
r_struct
id|xfrm_state_afinfo
op_star
id|afinfo
)paren
(brace
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|afinfo
op_eq
l_int|NULL
)paren
)paren
r_return
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|afinfo-&gt;lock
)paren
suffix:semicolon
)brace
multiline_comment|/* Temporarily located here until net/xfrm/xfrm_tunnel.c is created */
DECL|function|xfrm_state_delete_tunnel
r_void
id|xfrm_state_delete_tunnel
c_func
(paren
r_struct
id|xfrm_state
op_star
id|x
)paren
(brace
r_if
c_cond
(paren
id|x-&gt;tunnel
)paren
(brace
r_struct
id|xfrm_state
op_star
id|t
op_assign
id|x-&gt;tunnel
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|t-&gt;tunnel_users
)paren
op_eq
l_int|2
)paren
id|xfrm_state_delete
c_func
(paren
id|t
)paren
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|t-&gt;tunnel_users
)paren
suffix:semicolon
id|xfrm_state_put
c_func
(paren
id|t
)paren
suffix:semicolon
id|x-&gt;tunnel
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
DECL|function|xfrm_state_init
r_void
id|__init
id|xfrm_state_init
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|XFRM_DST_HSIZE
suffix:semicolon
id|i
op_increment
)paren
(brace
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|xfrm_state_bydst
(braket
id|i
)braket
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|xfrm_state_byspi
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|INIT_WORK
c_func
(paren
op_amp
id|xfrm_state_gc_work
comma
id|xfrm_state_gc_task
comma
l_int|NULL
)paren
suffix:semicolon
)brace
eof
