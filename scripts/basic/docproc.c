multiline_comment|/*&n; *&t;docproc is a simple preprocessor for the template files&n; *      used as placeholders for the kernel internal documentation.&n; *&t;docproc is used for documentation-frontend and&n; *      dependency-generator.&n; *&t;The two usages have in common that they require&n; *&t;some knowledge of the .tmpl syntax, therefore they&n; *&t;are kept together.&n; *&n; *&t;documentation-frontend&n; *&t;&t;Scans the template file and call kernel-doc for&n; *&t;&t;all occurrences of ![EIF]file&n; *&t;&t;Beforehand each referenced file are scanned for&n; *&t;&t;any exported sympols &quot;EXPORT_SYMBOL()&quot; statements.&n; *&t;&t;This is used to create proper -function and&n; *&t;&t;-nofunction arguments in calls to kernel-doc.&n; *&t;&t;Usage: docproc doc file.tmpl&n; *&n; *&t;dependency-generator:&n; *&t;&t;Scans the template file and list all files&n; *&t;&t;referenced in a format recognized by make.&n; *&t;&t;Usage:&t;docproc depend file.tmpl&n; *&t;&t;Writes dependency information to stdout&n; *&t;&t;in the following format:&n; *&t;&t;file.tmpl src.c&t;src2.c&n; *&t;&t;The filenames are obtained from the following constructs:&n; *&t;&t;!Efilename&n; *&t;&t;!Ifilename&n; *&t;&t;!Dfilename&n; *&t;&t;!Ffilename&n; *&n; */
macro_line|#include &lt;stdio.h&gt;
macro_line|#include &lt;stdlib.h&gt;
macro_line|#include &lt;string.h&gt;
macro_line|#include &lt;ctype.h&gt;
macro_line|#include &lt;unistd.h&gt;
macro_line|#include &lt;limits.h&gt;
macro_line|#include &lt;sys/types.h&gt;
macro_line|#include &lt;sys/wait.h&gt;
multiline_comment|/* exitstatus is used to keep track of any failing calls to kernel-doc,&n; * but execution continues. */
DECL|variable|exitstatus
r_int
id|exitstatus
op_assign
l_int|0
suffix:semicolon
DECL|typedef|DFL
r_typedef
r_void
id|DFL
c_func
(paren
r_char
op_star
)paren
suffix:semicolon
DECL|variable|defaultline
id|DFL
op_star
id|defaultline
suffix:semicolon
DECL|typedef|FILEONLY
r_typedef
r_void
id|FILEONLY
c_func
(paren
r_char
op_star
id|file
)paren
suffix:semicolon
DECL|variable|internalfunctions
id|FILEONLY
op_star
id|internalfunctions
suffix:semicolon
DECL|variable|externalfunctions
id|FILEONLY
op_star
id|externalfunctions
suffix:semicolon
DECL|variable|symbolsonly
id|FILEONLY
op_star
id|symbolsonly
suffix:semicolon
DECL|typedef|FILELINE
r_typedef
r_void
id|FILELINE
c_func
(paren
r_char
op_star
id|file
comma
r_int
r_char
op_star
id|line
)paren
suffix:semicolon
DECL|variable|singlefunctions
id|FILELINE
op_star
id|singlefunctions
suffix:semicolon
DECL|variable|entity_system
id|FILELINE
op_star
id|entity_system
suffix:semicolon
DECL|macro|MAXLINESZ
mdefine_line|#define MAXLINESZ     2048
DECL|macro|MAXFILES
mdefine_line|#define MAXFILES      250
DECL|macro|KERNELDOCPATH
mdefine_line|#define KERNELDOCPATH &quot;scripts/&quot;
DECL|macro|KERNELDOC
mdefine_line|#define KERNELDOC     &quot;kernel-doc&quot;
DECL|macro|DOCBOOK
mdefine_line|#define DOCBOOK       &quot;-docbook&quot;
DECL|macro|FUNCTION
mdefine_line|#define FUNCTION      &quot;-function&quot;
DECL|macro|NOFUNCTION
mdefine_line|#define NOFUNCTION    &quot;-nofunction&quot;
DECL|function|usage
r_void
id|usage
(paren
r_void
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Usage: docproc {doc|depend} file&bslash;n&quot;
)paren
suffix:semicolon
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Input is read from file.tmpl. Output is sent to stdout&bslash;n&quot;
)paren
suffix:semicolon
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;doc: frontend when generating kernel documentation&bslash;n&quot;
)paren
suffix:semicolon
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;depend: generate list of files referenced within file&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Execute kernel-doc with parameters givin in svec&n; */
DECL|function|exec_kernel_doc
r_void
id|exec_kernel_doc
c_func
(paren
r_char
op_star
op_star
id|svec
)paren
(brace
id|pid_t
id|pid
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_char
id|real_filename
(braket
id|PATH_MAX
op_plus
l_int|1
)braket
suffix:semicolon
multiline_comment|/* Make sure output generated so far are flushed */
id|fflush
c_func
(paren
id|stdout
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|pid
op_assign
id|fork
c_func
(paren
)paren
)paren
(brace
r_case
op_minus
l_int|1
suffix:colon
id|perror
c_func
(paren
l_string|&quot;fork&quot;
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
r_case
l_int|0
suffix:colon
id|memset
c_func
(paren
id|real_filename
comma
l_int|0
comma
r_sizeof
(paren
id|real_filename
)paren
)paren
suffix:semicolon
id|strncat
c_func
(paren
id|real_filename
comma
id|getenv
c_func
(paren
l_string|&quot;SRCTREE&quot;
)paren
comma
id|PATH_MAX
)paren
suffix:semicolon
id|strncat
c_func
(paren
id|real_filename
comma
id|KERNELDOCPATH
id|KERNELDOC
comma
id|PATH_MAX
op_minus
id|strlen
c_func
(paren
id|real_filename
)paren
)paren
suffix:semicolon
id|execvp
c_func
(paren
id|real_filename
comma
id|svec
)paren
suffix:semicolon
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;exec &quot;
)paren
suffix:semicolon
id|perror
c_func
(paren
id|real_filename
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
r_default
suffix:colon
id|waitpid
c_func
(paren
id|pid
comma
op_amp
id|ret
comma
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|WIFEXITED
c_func
(paren
id|ret
)paren
)paren
id|exitstatus
op_or_assign
id|WEXITSTATUS
c_func
(paren
id|ret
)paren
suffix:semicolon
r_else
id|exitstatus
op_assign
l_int|0xff
suffix:semicolon
)brace
multiline_comment|/* Types used to create list of all exported symbols in a number of files */
DECL|struct|symbols
r_struct
id|symbols
(brace
DECL|member|name
r_char
op_star
id|name
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|symfile
r_struct
id|symfile
(brace
DECL|member|filename
r_char
op_star
id|filename
suffix:semicolon
DECL|member|symbollist
r_struct
id|symbols
op_star
id|symbollist
suffix:semicolon
DECL|member|symbolcnt
r_int
id|symbolcnt
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|symfilelist
r_struct
id|symfile
id|symfilelist
(braket
id|MAXFILES
)braket
suffix:semicolon
DECL|variable|symfilecnt
r_int
id|symfilecnt
op_assign
l_int|0
suffix:semicolon
DECL|function|add_new_symbol
r_void
id|add_new_symbol
c_func
(paren
r_struct
id|symfile
op_star
id|sym
comma
r_char
op_star
id|symname
)paren
(brace
id|sym-&gt;symbollist
op_assign
id|realloc
c_func
(paren
id|sym-&gt;symbollist
comma
(paren
id|sym-&gt;symbolcnt
op_plus
l_int|1
)paren
op_star
r_sizeof
(paren
r_char
op_star
)paren
)paren
suffix:semicolon
id|sym-&gt;symbollist
(braket
id|sym-&gt;symbolcnt
op_increment
)braket
dot
id|name
op_assign
id|strdup
c_func
(paren
id|symname
)paren
suffix:semicolon
)brace
multiline_comment|/* Add a filename to the list */
DECL|function|add_new_file
r_struct
id|symfile
op_star
id|add_new_file
c_func
(paren
r_char
op_star
id|filename
)paren
(brace
id|symfilelist
(braket
id|symfilecnt
op_increment
)braket
dot
id|filename
op_assign
id|strdup
c_func
(paren
id|filename
)paren
suffix:semicolon
r_return
op_amp
id|symfilelist
(braket
id|symfilecnt
op_minus
l_int|1
)braket
suffix:semicolon
)brace
multiline_comment|/* Check if file already are present in the list */
DECL|function|filename_exist
r_struct
id|symfile
op_star
id|filename_exist
c_func
(paren
r_char
op_star
id|filename
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|symfilecnt
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|symfilelist
(braket
id|i
)braket
dot
id|filename
comma
id|filename
)paren
op_eq
l_int|0
)paren
r_return
op_amp
id|symfilelist
(braket
id|i
)braket
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * List all files referenced within the template file.&n; * Files are separated by tabs.&n; */
DECL|function|adddep
r_void
id|adddep
c_func
(paren
r_char
op_star
id|file
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;&bslash;t%s&quot;
comma
id|file
)paren
suffix:semicolon
)brace
DECL|function|adddep2
r_void
id|adddep2
c_func
(paren
r_char
op_star
id|file
comma
r_int
r_char
op_star
id|line
)paren
(brace
id|line
op_assign
id|line
suffix:semicolon
id|adddep
c_func
(paren
id|file
)paren
suffix:semicolon
)brace
DECL|function|noaction
r_void
id|noaction
c_func
(paren
r_char
op_star
id|line
)paren
(brace
id|line
op_assign
id|line
suffix:semicolon
)brace
DECL|function|noaction2
r_void
id|noaction2
c_func
(paren
r_char
op_star
id|file
comma
r_int
r_char
op_star
id|line
)paren
(brace
id|file
op_assign
id|file
suffix:semicolon
id|line
op_assign
id|line
suffix:semicolon
)brace
multiline_comment|/* Echo the line without further action */
DECL|function|printline
r_void
id|printline
c_func
(paren
r_char
op_star
id|line
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%s&quot;
comma
id|line
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Find all symbols exported with EXPORT_SYMBOL and EXPORT_SYMBOL_GPL&n; * in filename.&n; * All symbols located are stored in symfilelist.&n; */
DECL|function|find_export_symbols
r_void
id|find_export_symbols
c_func
(paren
r_char
op_star
id|filename
)paren
(brace
id|FILE
op_star
id|fp
suffix:semicolon
r_struct
id|symfile
op_star
id|sym
suffix:semicolon
r_char
id|line
(braket
id|MAXLINESZ
)braket
suffix:semicolon
r_if
c_cond
(paren
id|filename_exist
c_func
(paren
id|filename
)paren
op_eq
l_int|NULL
)paren
(brace
r_char
id|real_filename
(braket
id|PATH_MAX
op_plus
l_int|1
)braket
suffix:semicolon
id|memset
c_func
(paren
id|real_filename
comma
l_int|0
comma
r_sizeof
(paren
id|real_filename
)paren
)paren
suffix:semicolon
id|strncat
c_func
(paren
id|real_filename
comma
id|getenv
c_func
(paren
l_string|&quot;SRCTREE&quot;
)paren
comma
id|PATH_MAX
)paren
suffix:semicolon
id|strncat
c_func
(paren
id|real_filename
comma
id|filename
comma
id|PATH_MAX
op_minus
id|strlen
c_func
(paren
id|real_filename
)paren
)paren
suffix:semicolon
id|sym
op_assign
id|add_new_file
c_func
(paren
id|filename
)paren
suffix:semicolon
id|fp
op_assign
id|fopen
c_func
(paren
id|real_filename
comma
l_string|&quot;r&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fp
op_eq
l_int|NULL
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;docproc: &quot;
)paren
suffix:semicolon
id|perror
c_func
(paren
id|real_filename
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|fgets
c_func
(paren
id|line
comma
id|MAXLINESZ
comma
id|fp
)paren
)paren
(brace
r_int
r_char
op_star
id|p
suffix:semicolon
r_int
r_char
op_star
id|e
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|p
op_assign
id|strstr
c_func
(paren
id|line
comma
l_string|&quot;EXPORT_SYMBOL_GPL&quot;
)paren
)paren
op_ne
l_int|0
)paren
op_logical_or
(paren
(paren
id|p
op_assign
id|strstr
c_func
(paren
id|line
comma
l_string|&quot;EXPORT_SYMBOL&quot;
)paren
)paren
op_ne
l_int|0
)paren
)paren
(brace
multiline_comment|/* Skip EXPORT_SYMBOL{_GPL} */
r_while
c_loop
(paren
id|isalnum
c_func
(paren
op_star
id|p
)paren
op_logical_or
op_star
id|p
op_eq
l_char|&squot;_&squot;
)paren
id|p
op_increment
suffix:semicolon
multiline_comment|/* Remove paranteses and additional ws */
r_while
c_loop
(paren
id|isspace
c_func
(paren
op_star
id|p
)paren
)paren
id|p
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_star
id|p
op_ne
l_char|&squot;(&squot;
)paren
r_continue
suffix:semicolon
multiline_comment|/* Syntax error? */
r_else
id|p
op_increment
suffix:semicolon
r_while
c_loop
(paren
id|isspace
c_func
(paren
op_star
id|p
)paren
)paren
id|p
op_increment
suffix:semicolon
id|e
op_assign
id|p
suffix:semicolon
r_while
c_loop
(paren
id|isalnum
c_func
(paren
op_star
id|e
)paren
op_logical_or
op_star
id|e
op_eq
l_char|&squot;_&squot;
)paren
id|e
op_increment
suffix:semicolon
op_star
id|e
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|add_new_symbol
c_func
(paren
id|sym
comma
id|p
)paren
suffix:semicolon
)brace
)brace
id|fclose
c_func
(paren
id|fp
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Document all external or internal functions in a file.&n; * Call kernel-doc with following parameters:&n; * kernel-doc -docbook -nofunction function_name1 filename&n; * function names are obtained from all the the src files&n; * by find_export_symbols.&n; * intfunc uses -nofunction&n; * extfunc uses -function&n; */
DECL|function|docfunctions
r_void
id|docfunctions
c_func
(paren
r_char
op_star
id|filename
comma
r_char
op_star
id|type
)paren
(brace
r_int
id|i
comma
id|j
suffix:semicolon
r_int
id|symcnt
op_assign
l_int|0
suffix:semicolon
r_int
id|idx
op_assign
l_int|0
suffix:semicolon
r_char
op_star
op_star
id|vec
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_le
id|symfilecnt
suffix:semicolon
id|i
op_increment
)paren
id|symcnt
op_add_assign
id|symfilelist
(braket
id|i
)braket
dot
id|symbolcnt
suffix:semicolon
id|vec
op_assign
id|malloc
c_func
(paren
(paren
l_int|2
op_plus
l_int|2
op_star
id|symcnt
op_plus
l_int|2
)paren
op_star
r_sizeof
(paren
r_char
op_star
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vec
op_eq
l_int|NULL
)paren
(brace
id|perror
c_func
(paren
l_string|&quot;docproc: &quot;
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
)brace
id|vec
(braket
id|idx
op_increment
)braket
op_assign
id|KERNELDOC
suffix:semicolon
id|vec
(braket
id|idx
op_increment
)braket
op_assign
id|DOCBOOK
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|symfilecnt
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|symfile
op_star
id|sym
op_assign
op_amp
id|symfilelist
(braket
id|i
)braket
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|sym-&gt;symbolcnt
suffix:semicolon
id|j
op_increment
)paren
(brace
id|vec
(braket
id|idx
op_increment
)braket
op_assign
id|type
suffix:semicolon
id|vec
(braket
id|idx
op_increment
)braket
op_assign
id|sym-&gt;symbollist
(braket
id|j
)braket
dot
id|name
suffix:semicolon
)brace
)brace
id|vec
(braket
id|idx
op_increment
)braket
op_assign
id|filename
suffix:semicolon
id|vec
(braket
id|idx
)braket
op_assign
l_int|NULL
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&lt;!-- %s --&gt;&bslash;n&quot;
comma
id|filename
)paren
suffix:semicolon
id|exec_kernel_doc
c_func
(paren
id|vec
)paren
suffix:semicolon
id|fflush
c_func
(paren
id|stdout
)paren
suffix:semicolon
id|free
c_func
(paren
id|vec
)paren
suffix:semicolon
)brace
DECL|function|intfunc
r_void
id|intfunc
c_func
(paren
r_char
op_star
id|filename
)paren
(brace
id|docfunctions
c_func
(paren
id|filename
comma
id|NOFUNCTION
)paren
suffix:semicolon
)brace
DECL|function|extfunc
r_void
id|extfunc
c_func
(paren
r_char
op_star
id|filename
)paren
(brace
id|docfunctions
c_func
(paren
id|filename
comma
id|FUNCTION
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Document sp&#xfffd;ecific function(s) in a file.&n; * Call kernel-doc with the following parameters:&n; * kernel-doc -docbook -function function1 [-function function2]&n; */
DECL|function|singfunc
r_void
id|singfunc
c_func
(paren
r_char
op_star
id|filename
comma
r_int
r_char
op_star
id|line
)paren
(brace
r_char
op_star
id|vec
(braket
l_int|200
)braket
suffix:semicolon
multiline_comment|/* Enough for specific functions */
r_int
id|i
comma
id|idx
op_assign
l_int|0
suffix:semicolon
r_int
id|startofsym
op_assign
l_int|1
suffix:semicolon
id|vec
(braket
id|idx
op_increment
)braket
op_assign
id|KERNELDOC
suffix:semicolon
id|vec
(braket
id|idx
op_increment
)braket
op_assign
id|DOCBOOK
suffix:semicolon
multiline_comment|/* Split line up in individual parameters preceeded by FUNCTION */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|line
(braket
id|i
)braket
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|isspace
c_func
(paren
id|line
(braket
id|i
)braket
)paren
)paren
(brace
id|line
(braket
id|i
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|startofsym
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|startofsym
)paren
(brace
id|startofsym
op_assign
l_int|0
suffix:semicolon
id|vec
(braket
id|idx
op_increment
)braket
op_assign
id|FUNCTION
suffix:semicolon
id|vec
(braket
id|idx
op_increment
)braket
op_assign
op_amp
id|line
(braket
id|i
)braket
suffix:semicolon
)brace
)brace
id|vec
(braket
id|idx
op_increment
)braket
op_assign
id|filename
suffix:semicolon
id|vec
(braket
id|idx
)braket
op_assign
l_int|NULL
suffix:semicolon
id|exec_kernel_doc
c_func
(paren
id|vec
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Parse file, calling action specific functions for:&n; * 1) Lines containing !E&n; * 2) Lines containing !I&n; * 3) Lines containing !D&n; * 4) Lines containing !F&n; * 5) Default lines - lines not matching the above&n; */
DECL|function|parse_file
r_void
id|parse_file
c_func
(paren
id|FILE
op_star
id|infile
)paren
(brace
r_char
id|line
(braket
id|MAXLINESZ
)braket
suffix:semicolon
r_int
r_char
op_star
id|s
suffix:semicolon
r_while
c_loop
(paren
id|fgets
c_func
(paren
id|line
comma
id|MAXLINESZ
comma
id|infile
)paren
)paren
(brace
r_if
c_cond
(paren
id|line
(braket
l_int|0
)braket
op_eq
l_char|&squot;!&squot;
)paren
(brace
id|s
op_assign
id|line
op_plus
l_int|2
suffix:semicolon
r_switch
c_cond
(paren
id|line
(braket
l_int|1
)braket
)paren
(brace
r_case
l_char|&squot;E&squot;
suffix:colon
r_while
c_loop
(paren
op_star
id|s
op_logical_and
op_logical_neg
id|isspace
c_func
(paren
op_star
id|s
)paren
)paren
id|s
op_increment
suffix:semicolon
op_star
id|s
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|externalfunctions
c_func
(paren
id|line
op_plus
l_int|2
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;I&squot;
suffix:colon
r_while
c_loop
(paren
op_star
id|s
op_logical_and
op_logical_neg
id|isspace
c_func
(paren
op_star
id|s
)paren
)paren
id|s
op_increment
suffix:semicolon
op_star
id|s
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|internalfunctions
c_func
(paren
id|line
op_plus
l_int|2
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;D&squot;
suffix:colon
r_while
c_loop
(paren
op_star
id|s
op_logical_and
op_logical_neg
id|isspace
c_func
(paren
op_star
id|s
)paren
)paren
id|s
op_increment
suffix:semicolon
op_star
id|s
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|symbolsonly
c_func
(paren
id|line
op_plus
l_int|2
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;F&squot;
suffix:colon
multiline_comment|/* filename */
r_while
c_loop
(paren
op_star
id|s
op_logical_and
op_logical_neg
id|isspace
c_func
(paren
op_star
id|s
)paren
)paren
id|s
op_increment
suffix:semicolon
op_star
id|s
op_increment
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
multiline_comment|/* function names */
r_while
c_loop
(paren
id|isspace
c_func
(paren
op_star
id|s
)paren
)paren
id|s
op_increment
suffix:semicolon
id|singlefunctions
c_func
(paren
id|line
op_plus
l_int|2
comma
id|s
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|defaultline
c_func
(paren
id|line
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|defaultline
c_func
(paren
id|line
)paren
suffix:semicolon
)brace
)brace
id|fflush
c_func
(paren
id|stdout
)paren
suffix:semicolon
)brace
DECL|function|main
r_int
id|main
c_func
(paren
r_int
id|argc
comma
r_char
op_star
id|argv
(braket
)braket
)paren
(brace
id|FILE
op_star
id|infile
suffix:semicolon
r_if
c_cond
(paren
id|argc
op_ne
l_int|3
)paren
(brace
id|usage
c_func
(paren
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* Open file, exit on error */
id|infile
op_assign
id|fopen
c_func
(paren
id|argv
(braket
l_int|2
)braket
comma
l_string|&quot;r&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|infile
op_eq
l_int|NULL
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;docproc: &quot;
)paren
suffix:semicolon
id|perror
c_func
(paren
id|argv
(braket
l_int|2
)braket
)paren
suffix:semicolon
m_exit
(paren
l_int|2
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|strcmp
c_func
(paren
l_string|&quot;doc&quot;
comma
id|argv
(braket
l_int|1
)braket
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Need to do this in two passes.&n;&t;&t; * First pass is used to collect all symbols exported&n;&t;&t; * in the various files.&n;&t;&t; * Second pass generate the documentation.&n;&t;&t; * This is required because function are declared&n;&t;&t; * and exported in different files :-((&n;&t;&t; */
multiline_comment|/* Collect symbols */
id|defaultline
op_assign
id|noaction
suffix:semicolon
id|internalfunctions
op_assign
id|find_export_symbols
suffix:semicolon
id|externalfunctions
op_assign
id|find_export_symbols
suffix:semicolon
id|symbolsonly
op_assign
id|find_export_symbols
suffix:semicolon
id|singlefunctions
op_assign
id|noaction2
suffix:semicolon
id|parse_file
c_func
(paren
id|infile
)paren
suffix:semicolon
multiline_comment|/* Rewind to start from beginning of file again */
id|fseek
c_func
(paren
id|infile
comma
l_int|0
comma
id|SEEK_SET
)paren
suffix:semicolon
id|defaultline
op_assign
id|printline
suffix:semicolon
id|internalfunctions
op_assign
id|intfunc
suffix:semicolon
id|externalfunctions
op_assign
id|extfunc
suffix:semicolon
id|symbolsonly
op_assign
id|printline
suffix:semicolon
id|singlefunctions
op_assign
id|singfunc
suffix:semicolon
id|parse_file
c_func
(paren
id|infile
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|strcmp
c_func
(paren
l_string|&quot;depend&quot;
comma
id|argv
(braket
l_int|1
)braket
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Create first part of dependency chain&n;&t;&t; * file.tmpl */
id|printf
c_func
(paren
l_string|&quot;%s&bslash;t&quot;
comma
id|argv
(braket
l_int|2
)braket
)paren
suffix:semicolon
id|defaultline
op_assign
id|noaction
suffix:semicolon
id|internalfunctions
op_assign
id|adddep
suffix:semicolon
id|externalfunctions
op_assign
id|adddep
suffix:semicolon
id|symbolsonly
op_assign
id|adddep
suffix:semicolon
id|singlefunctions
op_assign
id|adddep2
suffix:semicolon
id|parse_file
c_func
(paren
id|infile
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Unknown option: %s&bslash;n&quot;
comma
id|argv
(braket
l_int|1
)braket
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
)brace
id|fclose
c_func
(paren
id|infile
)paren
suffix:semicolon
id|fflush
c_func
(paren
id|stdout
)paren
suffix:semicolon
r_return
id|exitstatus
suffix:semicolon
)brace
eof
