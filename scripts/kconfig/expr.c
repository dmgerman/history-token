multiline_comment|/*&n; * Copyright (C) 2002 Roman Zippel &lt;zippel@linux-m68k.org&gt;&n; * Released under the terms of the GNU GPL v2.0.&n; */
macro_line|#include &lt;stdio.h&gt;
macro_line|#include &lt;stdlib.h&gt;
macro_line|#include &lt;string.h&gt;
DECL|macro|LKC_DIRECT_LINK
mdefine_line|#define LKC_DIRECT_LINK
macro_line|#include &quot;lkc.h&quot;
DECL|macro|DEBUG_EXPR
mdefine_line|#define DEBUG_EXPR&t;0
DECL|function|expr_alloc_symbol
r_struct
id|expr
op_star
id|expr_alloc_symbol
c_func
(paren
r_struct
id|symbol
op_star
id|sym
)paren
(brace
r_struct
id|expr
op_star
id|e
op_assign
id|malloc
c_func
(paren
r_sizeof
(paren
op_star
id|e
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|e
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|e
)paren
)paren
suffix:semicolon
id|e-&gt;type
op_assign
id|E_SYMBOL
suffix:semicolon
id|e-&gt;left.sym
op_assign
id|sym
suffix:semicolon
r_return
id|e
suffix:semicolon
)brace
DECL|function|expr_alloc_one
r_struct
id|expr
op_star
id|expr_alloc_one
c_func
(paren
r_enum
id|expr_type
id|type
comma
r_struct
id|expr
op_star
id|ce
)paren
(brace
r_struct
id|expr
op_star
id|e
op_assign
id|malloc
c_func
(paren
r_sizeof
(paren
op_star
id|e
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|e
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|e
)paren
)paren
suffix:semicolon
id|e-&gt;type
op_assign
id|type
suffix:semicolon
id|e-&gt;left.expr
op_assign
id|ce
suffix:semicolon
r_return
id|e
suffix:semicolon
)brace
DECL|function|expr_alloc_two
r_struct
id|expr
op_star
id|expr_alloc_two
c_func
(paren
r_enum
id|expr_type
id|type
comma
r_struct
id|expr
op_star
id|e1
comma
r_struct
id|expr
op_star
id|e2
)paren
(brace
r_struct
id|expr
op_star
id|e
op_assign
id|malloc
c_func
(paren
r_sizeof
(paren
op_star
id|e
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|e
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|e
)paren
)paren
suffix:semicolon
id|e-&gt;type
op_assign
id|type
suffix:semicolon
id|e-&gt;left.expr
op_assign
id|e1
suffix:semicolon
id|e-&gt;right.expr
op_assign
id|e2
suffix:semicolon
r_return
id|e
suffix:semicolon
)brace
DECL|function|expr_alloc_comp
r_struct
id|expr
op_star
id|expr_alloc_comp
c_func
(paren
r_enum
id|expr_type
id|type
comma
r_struct
id|symbol
op_star
id|s1
comma
r_struct
id|symbol
op_star
id|s2
)paren
(brace
r_struct
id|expr
op_star
id|e
op_assign
id|malloc
c_func
(paren
r_sizeof
(paren
op_star
id|e
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|e
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|e
)paren
)paren
suffix:semicolon
id|e-&gt;type
op_assign
id|type
suffix:semicolon
id|e-&gt;left.sym
op_assign
id|s1
suffix:semicolon
id|e-&gt;right.sym
op_assign
id|s2
suffix:semicolon
r_return
id|e
suffix:semicolon
)brace
DECL|function|expr_alloc_and
r_struct
id|expr
op_star
id|expr_alloc_and
c_func
(paren
r_struct
id|expr
op_star
id|e1
comma
r_struct
id|expr
op_star
id|e2
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|e1
)paren
r_return
id|e2
suffix:semicolon
r_return
id|e2
ques
c_cond
id|expr_alloc_two
c_func
(paren
id|E_AND
comma
id|e1
comma
id|e2
)paren
suffix:colon
id|e1
suffix:semicolon
)brace
DECL|function|expr_alloc_or
r_struct
id|expr
op_star
id|expr_alloc_or
c_func
(paren
r_struct
id|expr
op_star
id|e1
comma
r_struct
id|expr
op_star
id|e2
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|e1
)paren
r_return
id|e2
suffix:semicolon
r_return
id|e2
ques
c_cond
id|expr_alloc_two
c_func
(paren
id|E_OR
comma
id|e1
comma
id|e2
)paren
suffix:colon
id|e1
suffix:semicolon
)brace
DECL|function|expr_copy
r_struct
id|expr
op_star
id|expr_copy
c_func
(paren
r_struct
id|expr
op_star
id|org
)paren
(brace
r_struct
id|expr
op_star
id|e
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|org
)paren
r_return
l_int|NULL
suffix:semicolon
id|e
op_assign
id|malloc
c_func
(paren
r_sizeof
(paren
op_star
id|org
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|e
comma
id|org
comma
r_sizeof
(paren
op_star
id|org
)paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|org-&gt;type
)paren
(brace
r_case
id|E_SYMBOL
suffix:colon
id|e-&gt;left
op_assign
id|org-&gt;left
suffix:semicolon
r_break
suffix:semicolon
r_case
id|E_NOT
suffix:colon
id|e-&gt;left.expr
op_assign
id|expr_copy
c_func
(paren
id|org-&gt;left.expr
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|E_EQUAL
suffix:colon
r_case
id|E_UNEQUAL
suffix:colon
id|e-&gt;left.sym
op_assign
id|org-&gt;left.sym
suffix:semicolon
id|e-&gt;right.sym
op_assign
id|org-&gt;right.sym
suffix:semicolon
r_break
suffix:semicolon
r_case
id|E_AND
suffix:colon
r_case
id|E_OR
suffix:colon
r_case
id|E_CHOICE
suffix:colon
id|e-&gt;left.expr
op_assign
id|expr_copy
c_func
(paren
id|org-&gt;left.expr
)paren
suffix:semicolon
id|e-&gt;right.expr
op_assign
id|expr_copy
c_func
(paren
id|org-&gt;right.expr
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printf
c_func
(paren
l_string|&quot;can&squot;t copy type %d&bslash;n&quot;
comma
id|e-&gt;type
)paren
suffix:semicolon
id|free
c_func
(paren
id|e
)paren
suffix:semicolon
id|e
op_assign
l_int|NULL
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|e
suffix:semicolon
)brace
DECL|function|expr_free
r_void
id|expr_free
c_func
(paren
r_struct
id|expr
op_star
id|e
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|e
)paren
r_return
suffix:semicolon
r_switch
c_cond
(paren
id|e-&gt;type
)paren
(brace
r_case
id|E_SYMBOL
suffix:colon
r_break
suffix:semicolon
r_case
id|E_NOT
suffix:colon
id|expr_free
c_func
(paren
id|e-&gt;left.expr
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
id|E_EQUAL
suffix:colon
r_case
id|E_UNEQUAL
suffix:colon
r_break
suffix:semicolon
r_case
id|E_OR
suffix:colon
r_case
id|E_AND
suffix:colon
id|expr_free
c_func
(paren
id|e-&gt;left.expr
)paren
suffix:semicolon
id|expr_free
c_func
(paren
id|e-&gt;right.expr
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printf
c_func
(paren
l_string|&quot;how to free type %d?&bslash;n&quot;
comma
id|e-&gt;type
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|free
c_func
(paren
id|e
)paren
suffix:semicolon
)brace
DECL|variable|trans_count
r_static
r_int
id|trans_count
suffix:semicolon
DECL|macro|e1
mdefine_line|#define e1 (*ep1)
DECL|macro|e2
mdefine_line|#define e2 (*ep2)
DECL|function|__expr_eliminate_eq
r_static
r_void
id|__expr_eliminate_eq
c_func
(paren
r_enum
id|expr_type
id|type
comma
r_struct
id|expr
op_star
op_star
id|ep1
comma
r_struct
id|expr
op_star
op_star
id|ep2
)paren
(brace
r_if
c_cond
(paren
id|e1-&gt;type
op_eq
id|type
)paren
(brace
id|__expr_eliminate_eq
c_func
(paren
id|type
comma
op_amp
id|e1-&gt;left.expr
comma
op_amp
id|e2
)paren
suffix:semicolon
id|__expr_eliminate_eq
c_func
(paren
id|type
comma
op_amp
id|e1-&gt;right.expr
comma
op_amp
id|e2
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|e2-&gt;type
op_eq
id|type
)paren
(brace
id|__expr_eliminate_eq
c_func
(paren
id|type
comma
op_amp
id|e1
comma
op_amp
id|e2-&gt;left.expr
)paren
suffix:semicolon
id|__expr_eliminate_eq
c_func
(paren
id|type
comma
op_amp
id|e1
comma
op_amp
id|e2-&gt;right.expr
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|e1-&gt;type
op_eq
id|E_SYMBOL
op_logical_and
id|e2-&gt;type
op_eq
id|E_SYMBOL
op_logical_and
id|e1-&gt;left.sym
op_eq
id|e2-&gt;left.sym
op_logical_and
(paren
id|e1-&gt;left.sym-&gt;flags
op_amp
(paren
id|SYMBOL_YES
op_or
id|SYMBOL_NO
)paren
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|expr_eq
c_func
(paren
id|e1
comma
id|e2
)paren
)paren
r_return
suffix:semicolon
id|trans_count
op_increment
suffix:semicolon
id|expr_free
c_func
(paren
id|e1
)paren
suffix:semicolon
id|expr_free
c_func
(paren
id|e2
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|type
)paren
(brace
r_case
id|E_OR
suffix:colon
id|e1
op_assign
id|expr_alloc_symbol
c_func
(paren
op_amp
id|symbol_no
)paren
suffix:semicolon
id|e2
op_assign
id|expr_alloc_symbol
c_func
(paren
op_amp
id|symbol_no
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|E_AND
suffix:colon
id|e1
op_assign
id|expr_alloc_symbol
c_func
(paren
op_amp
id|symbol_yes
)paren
suffix:semicolon
id|e2
op_assign
id|expr_alloc_symbol
c_func
(paren
op_amp
id|symbol_yes
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
suffix:semicolon
)brace
)brace
DECL|function|expr_eliminate_eq
r_void
id|expr_eliminate_eq
c_func
(paren
r_struct
id|expr
op_star
op_star
id|ep1
comma
r_struct
id|expr
op_star
op_star
id|ep2
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|e1
op_logical_or
op_logical_neg
id|e2
)paren
r_return
suffix:semicolon
r_switch
c_cond
(paren
id|e1-&gt;type
)paren
(brace
r_case
id|E_OR
suffix:colon
r_case
id|E_AND
suffix:colon
id|__expr_eliminate_eq
c_func
(paren
id|e1-&gt;type
comma
id|ep1
comma
id|ep2
)paren
suffix:semicolon
r_default
suffix:colon
suffix:semicolon
)brace
r_if
c_cond
(paren
id|e1-&gt;type
op_ne
id|e2-&gt;type
)paren
r_switch
c_cond
(paren
id|e2-&gt;type
)paren
(brace
r_case
id|E_OR
suffix:colon
r_case
id|E_AND
suffix:colon
id|__expr_eliminate_eq
c_func
(paren
id|e2-&gt;type
comma
id|ep1
comma
id|ep2
)paren
suffix:semicolon
r_default
suffix:colon
suffix:semicolon
)brace
id|e1
op_assign
id|expr_eliminate_yn
c_func
(paren
id|e1
)paren
suffix:semicolon
id|e2
op_assign
id|expr_eliminate_yn
c_func
(paren
id|e2
)paren
suffix:semicolon
)brace
DECL|macro|e1
macro_line|#undef e1
DECL|macro|e2
macro_line|#undef e2
DECL|function|expr_eq
r_int
id|expr_eq
c_func
(paren
r_struct
id|expr
op_star
id|e1
comma
r_struct
id|expr
op_star
id|e2
)paren
(brace
r_int
id|res
comma
id|old_count
suffix:semicolon
r_if
c_cond
(paren
id|e1-&gt;type
op_ne
id|e2-&gt;type
)paren
r_return
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|e1-&gt;type
)paren
(brace
r_case
id|E_EQUAL
suffix:colon
r_case
id|E_UNEQUAL
suffix:colon
r_return
id|e1-&gt;left.sym
op_eq
id|e2-&gt;left.sym
op_logical_and
id|e1-&gt;right.sym
op_eq
id|e2-&gt;right.sym
suffix:semicolon
r_case
id|E_SYMBOL
suffix:colon
r_return
id|e1-&gt;left.sym
op_eq
id|e2-&gt;left.sym
suffix:semicolon
r_case
id|E_NOT
suffix:colon
r_return
id|expr_eq
c_func
(paren
id|e1-&gt;left.expr
comma
id|e2-&gt;left.expr
)paren
suffix:semicolon
r_case
id|E_AND
suffix:colon
r_case
id|E_OR
suffix:colon
id|e1
op_assign
id|expr_copy
c_func
(paren
id|e1
)paren
suffix:semicolon
id|e2
op_assign
id|expr_copy
c_func
(paren
id|e2
)paren
suffix:semicolon
id|old_count
op_assign
id|trans_count
suffix:semicolon
id|expr_eliminate_eq
c_func
(paren
op_amp
id|e1
comma
op_amp
id|e2
)paren
suffix:semicolon
id|res
op_assign
(paren
id|e1-&gt;type
op_eq
id|E_SYMBOL
op_logical_and
id|e2-&gt;type
op_eq
id|E_SYMBOL
op_logical_and
id|e1-&gt;left.sym
op_eq
id|e2-&gt;left.sym
)paren
suffix:semicolon
id|expr_free
c_func
(paren
id|e1
)paren
suffix:semicolon
id|expr_free
c_func
(paren
id|e2
)paren
suffix:semicolon
id|trans_count
op_assign
id|old_count
suffix:semicolon
r_return
id|res
suffix:semicolon
r_case
id|E_CHOICE
suffix:colon
r_case
id|E_RANGE
suffix:colon
r_case
id|E_NONE
suffix:colon
multiline_comment|/* panic */
suffix:semicolon
)brace
r_if
c_cond
(paren
id|DEBUG_EXPR
)paren
(brace
id|expr_fprint
c_func
(paren
id|e1
comma
id|stdout
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot; = &quot;
)paren
suffix:semicolon
id|expr_fprint
c_func
(paren
id|e2
comma
id|stdout
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot; ?&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|expr_eliminate_yn
r_struct
id|expr
op_star
id|expr_eliminate_yn
c_func
(paren
r_struct
id|expr
op_star
id|e
)paren
(brace
r_struct
id|expr
op_star
id|tmp
suffix:semicolon
r_if
c_cond
(paren
id|e
)paren
r_switch
c_cond
(paren
id|e-&gt;type
)paren
(brace
r_case
id|E_AND
suffix:colon
id|e-&gt;left.expr
op_assign
id|expr_eliminate_yn
c_func
(paren
id|e-&gt;left.expr
)paren
suffix:semicolon
id|e-&gt;right.expr
op_assign
id|expr_eliminate_yn
c_func
(paren
id|e-&gt;right.expr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|e-&gt;left.expr-&gt;type
op_eq
id|E_SYMBOL
)paren
(brace
r_if
c_cond
(paren
id|e-&gt;left.expr-&gt;left.sym
op_eq
op_amp
id|symbol_no
)paren
(brace
id|expr_free
c_func
(paren
id|e-&gt;left.expr
)paren
suffix:semicolon
id|expr_free
c_func
(paren
id|e-&gt;right.expr
)paren
suffix:semicolon
id|e-&gt;type
op_assign
id|E_SYMBOL
suffix:semicolon
id|e-&gt;left.sym
op_assign
op_amp
id|symbol_no
suffix:semicolon
id|e-&gt;right.expr
op_assign
l_int|NULL
suffix:semicolon
r_return
id|e
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|e-&gt;left.expr-&gt;left.sym
op_eq
op_amp
id|symbol_yes
)paren
(brace
id|free
c_func
(paren
id|e-&gt;left.expr
)paren
suffix:semicolon
id|tmp
op_assign
id|e-&gt;right.expr
suffix:semicolon
op_star
id|e
op_assign
op_star
(paren
id|e-&gt;right.expr
)paren
suffix:semicolon
id|free
c_func
(paren
id|tmp
)paren
suffix:semicolon
r_return
id|e
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|e-&gt;right.expr-&gt;type
op_eq
id|E_SYMBOL
)paren
(brace
r_if
c_cond
(paren
id|e-&gt;right.expr-&gt;left.sym
op_eq
op_amp
id|symbol_no
)paren
(brace
id|expr_free
c_func
(paren
id|e-&gt;left.expr
)paren
suffix:semicolon
id|expr_free
c_func
(paren
id|e-&gt;right.expr
)paren
suffix:semicolon
id|e-&gt;type
op_assign
id|E_SYMBOL
suffix:semicolon
id|e-&gt;left.sym
op_assign
op_amp
id|symbol_no
suffix:semicolon
id|e-&gt;right.expr
op_assign
l_int|NULL
suffix:semicolon
r_return
id|e
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|e-&gt;right.expr-&gt;left.sym
op_eq
op_amp
id|symbol_yes
)paren
(brace
id|free
c_func
(paren
id|e-&gt;right.expr
)paren
suffix:semicolon
id|tmp
op_assign
id|e-&gt;left.expr
suffix:semicolon
op_star
id|e
op_assign
op_star
(paren
id|e-&gt;left.expr
)paren
suffix:semicolon
id|free
c_func
(paren
id|tmp
)paren
suffix:semicolon
r_return
id|e
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
r_case
id|E_OR
suffix:colon
id|e-&gt;left.expr
op_assign
id|expr_eliminate_yn
c_func
(paren
id|e-&gt;left.expr
)paren
suffix:semicolon
id|e-&gt;right.expr
op_assign
id|expr_eliminate_yn
c_func
(paren
id|e-&gt;right.expr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|e-&gt;left.expr-&gt;type
op_eq
id|E_SYMBOL
)paren
(brace
r_if
c_cond
(paren
id|e-&gt;left.expr-&gt;left.sym
op_eq
op_amp
id|symbol_no
)paren
(brace
id|free
c_func
(paren
id|e-&gt;left.expr
)paren
suffix:semicolon
id|tmp
op_assign
id|e-&gt;right.expr
suffix:semicolon
op_star
id|e
op_assign
op_star
(paren
id|e-&gt;right.expr
)paren
suffix:semicolon
id|free
c_func
(paren
id|tmp
)paren
suffix:semicolon
r_return
id|e
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|e-&gt;left.expr-&gt;left.sym
op_eq
op_amp
id|symbol_yes
)paren
(brace
id|expr_free
c_func
(paren
id|e-&gt;left.expr
)paren
suffix:semicolon
id|expr_free
c_func
(paren
id|e-&gt;right.expr
)paren
suffix:semicolon
id|e-&gt;type
op_assign
id|E_SYMBOL
suffix:semicolon
id|e-&gt;left.sym
op_assign
op_amp
id|symbol_yes
suffix:semicolon
id|e-&gt;right.expr
op_assign
l_int|NULL
suffix:semicolon
r_return
id|e
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|e-&gt;right.expr-&gt;type
op_eq
id|E_SYMBOL
)paren
(brace
r_if
c_cond
(paren
id|e-&gt;right.expr-&gt;left.sym
op_eq
op_amp
id|symbol_no
)paren
(brace
id|free
c_func
(paren
id|e-&gt;right.expr
)paren
suffix:semicolon
id|tmp
op_assign
id|e-&gt;left.expr
suffix:semicolon
op_star
id|e
op_assign
op_star
(paren
id|e-&gt;left.expr
)paren
suffix:semicolon
id|free
c_func
(paren
id|tmp
)paren
suffix:semicolon
r_return
id|e
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|e-&gt;right.expr-&gt;left.sym
op_eq
op_amp
id|symbol_yes
)paren
(brace
id|expr_free
c_func
(paren
id|e-&gt;left.expr
)paren
suffix:semicolon
id|expr_free
c_func
(paren
id|e-&gt;right.expr
)paren
suffix:semicolon
id|e-&gt;type
op_assign
id|E_SYMBOL
suffix:semicolon
id|e-&gt;left.sym
op_assign
op_amp
id|symbol_yes
suffix:semicolon
id|e-&gt;right.expr
op_assign
l_int|NULL
suffix:semicolon
r_return
id|e
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
r_default
suffix:colon
suffix:semicolon
)brace
r_return
id|e
suffix:semicolon
)brace
multiline_comment|/*&n; * bool FOO!=n =&gt; FOO&n; */
DECL|function|expr_trans_bool
r_struct
id|expr
op_star
id|expr_trans_bool
c_func
(paren
r_struct
id|expr
op_star
id|e
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|e
)paren
r_return
l_int|NULL
suffix:semicolon
r_switch
c_cond
(paren
id|e-&gt;type
)paren
(brace
r_case
id|E_AND
suffix:colon
r_case
id|E_OR
suffix:colon
r_case
id|E_NOT
suffix:colon
id|e-&gt;left.expr
op_assign
id|expr_trans_bool
c_func
(paren
id|e-&gt;left.expr
)paren
suffix:semicolon
id|e-&gt;right.expr
op_assign
id|expr_trans_bool
c_func
(paren
id|e-&gt;right.expr
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|E_UNEQUAL
suffix:colon
singleline_comment|// FOO!=n -&gt; FOO
r_if
c_cond
(paren
id|e-&gt;left.sym-&gt;type
op_eq
id|S_TRISTATE
)paren
(brace
r_if
c_cond
(paren
id|e-&gt;right.sym
op_eq
op_amp
id|symbol_no
)paren
(brace
id|e-&gt;type
op_assign
id|E_SYMBOL
suffix:semicolon
id|e-&gt;right.sym
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
r_default
suffix:colon
suffix:semicolon
)brace
r_return
id|e
suffix:semicolon
)brace
multiline_comment|/*&n; * e1 || e2 -&gt; ?&n; */
DECL|function|expr_join_or
r_struct
id|expr
op_star
id|expr_join_or
c_func
(paren
r_struct
id|expr
op_star
id|e1
comma
r_struct
id|expr
op_star
id|e2
)paren
(brace
r_struct
id|expr
op_star
id|tmp
suffix:semicolon
r_struct
id|symbol
op_star
id|sym1
comma
op_star
id|sym2
suffix:semicolon
r_if
c_cond
(paren
id|expr_eq
c_func
(paren
id|e1
comma
id|e2
)paren
)paren
r_return
id|expr_copy
c_func
(paren
id|e1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|e1-&gt;type
op_ne
id|E_EQUAL
op_logical_and
id|e1-&gt;type
op_ne
id|E_UNEQUAL
op_logical_and
id|e1-&gt;type
op_ne
id|E_SYMBOL
op_logical_and
id|e1-&gt;type
op_ne
id|E_NOT
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|e2-&gt;type
op_ne
id|E_EQUAL
op_logical_and
id|e2-&gt;type
op_ne
id|E_UNEQUAL
op_logical_and
id|e2-&gt;type
op_ne
id|E_SYMBOL
op_logical_and
id|e2-&gt;type
op_ne
id|E_NOT
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|e1-&gt;type
op_eq
id|E_NOT
)paren
(brace
id|tmp
op_assign
id|e1-&gt;left.expr
suffix:semicolon
r_if
c_cond
(paren
id|tmp-&gt;type
op_ne
id|E_EQUAL
op_logical_and
id|tmp-&gt;type
op_ne
id|E_UNEQUAL
op_logical_and
id|tmp-&gt;type
op_ne
id|E_SYMBOL
)paren
r_return
l_int|NULL
suffix:semicolon
id|sym1
op_assign
id|tmp-&gt;left.sym
suffix:semicolon
)brace
r_else
id|sym1
op_assign
id|e1-&gt;left.sym
suffix:semicolon
r_if
c_cond
(paren
id|e2-&gt;type
op_eq
id|E_NOT
)paren
(brace
r_if
c_cond
(paren
id|e2-&gt;left.expr-&gt;type
op_ne
id|E_SYMBOL
)paren
r_return
l_int|NULL
suffix:semicolon
id|sym2
op_assign
id|e2-&gt;left.expr-&gt;left.sym
suffix:semicolon
)brace
r_else
id|sym2
op_assign
id|e2-&gt;left.sym
suffix:semicolon
r_if
c_cond
(paren
id|sym1
op_ne
id|sym2
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|sym1-&gt;type
op_ne
id|S_BOOLEAN
op_logical_and
id|sym1-&gt;type
op_ne
id|S_TRISTATE
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|sym1-&gt;type
op_eq
id|S_TRISTATE
)paren
(brace
r_if
c_cond
(paren
id|e1-&gt;type
op_eq
id|E_EQUAL
op_logical_and
id|e2-&gt;type
op_eq
id|E_EQUAL
op_logical_and
(paren
(paren
id|e1-&gt;right.sym
op_eq
op_amp
id|symbol_yes
op_logical_and
id|e2-&gt;right.sym
op_eq
op_amp
id|symbol_mod
)paren
op_logical_or
(paren
id|e1-&gt;right.sym
op_eq
op_amp
id|symbol_mod
op_logical_and
id|e2-&gt;right.sym
op_eq
op_amp
id|symbol_yes
)paren
)paren
)paren
(brace
singleline_comment|// (a=&squot;y&squot;) || (a=&squot;m&squot;) -&gt; (a!=&squot;n&squot;)
r_return
id|expr_alloc_comp
c_func
(paren
id|E_UNEQUAL
comma
id|sym1
comma
op_amp
id|symbol_no
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|e1-&gt;type
op_eq
id|E_EQUAL
op_logical_and
id|e2-&gt;type
op_eq
id|E_EQUAL
op_logical_and
(paren
(paren
id|e1-&gt;right.sym
op_eq
op_amp
id|symbol_yes
op_logical_and
id|e2-&gt;right.sym
op_eq
op_amp
id|symbol_no
)paren
op_logical_or
(paren
id|e1-&gt;right.sym
op_eq
op_amp
id|symbol_no
op_logical_and
id|e2-&gt;right.sym
op_eq
op_amp
id|symbol_yes
)paren
)paren
)paren
(brace
singleline_comment|// (a=&squot;y&squot;) || (a=&squot;n&squot;) -&gt; (a!=&squot;m&squot;)
r_return
id|expr_alloc_comp
c_func
(paren
id|E_UNEQUAL
comma
id|sym1
comma
op_amp
id|symbol_mod
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|e1-&gt;type
op_eq
id|E_EQUAL
op_logical_and
id|e2-&gt;type
op_eq
id|E_EQUAL
op_logical_and
(paren
(paren
id|e1-&gt;right.sym
op_eq
op_amp
id|symbol_mod
op_logical_and
id|e2-&gt;right.sym
op_eq
op_amp
id|symbol_no
)paren
op_logical_or
(paren
id|e1-&gt;right.sym
op_eq
op_amp
id|symbol_no
op_logical_and
id|e2-&gt;right.sym
op_eq
op_amp
id|symbol_mod
)paren
)paren
)paren
(brace
singleline_comment|// (a=&squot;m&squot;) || (a=&squot;n&squot;) -&gt; (a!=&squot;y&squot;)
r_return
id|expr_alloc_comp
c_func
(paren
id|E_UNEQUAL
comma
id|sym1
comma
op_amp
id|symbol_yes
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|sym1-&gt;type
op_eq
id|S_BOOLEAN
op_logical_and
id|sym1
op_eq
id|sym2
)paren
(brace
r_if
c_cond
(paren
(paren
id|e1-&gt;type
op_eq
id|E_NOT
op_logical_and
id|e1-&gt;left.expr-&gt;type
op_eq
id|E_SYMBOL
op_logical_and
id|e2-&gt;type
op_eq
id|E_SYMBOL
)paren
op_logical_or
(paren
id|e2-&gt;type
op_eq
id|E_NOT
op_logical_and
id|e2-&gt;left.expr-&gt;type
op_eq
id|E_SYMBOL
op_logical_and
id|e1-&gt;type
op_eq
id|E_SYMBOL
)paren
)paren
r_return
id|expr_alloc_symbol
c_func
(paren
op_amp
id|symbol_yes
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|DEBUG_EXPR
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;optimize (&quot;
)paren
suffix:semicolon
id|expr_fprint
c_func
(paren
id|e1
comma
id|stdout
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;) || (&quot;
)paren
suffix:semicolon
id|expr_fprint
c_func
(paren
id|e2
comma
id|stdout
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;)?&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|expr_join_and
r_struct
id|expr
op_star
id|expr_join_and
c_func
(paren
r_struct
id|expr
op_star
id|e1
comma
r_struct
id|expr
op_star
id|e2
)paren
(brace
r_struct
id|expr
op_star
id|tmp
suffix:semicolon
r_struct
id|symbol
op_star
id|sym1
comma
op_star
id|sym2
suffix:semicolon
r_if
c_cond
(paren
id|expr_eq
c_func
(paren
id|e1
comma
id|e2
)paren
)paren
r_return
id|expr_copy
c_func
(paren
id|e1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|e1-&gt;type
op_ne
id|E_EQUAL
op_logical_and
id|e1-&gt;type
op_ne
id|E_UNEQUAL
op_logical_and
id|e1-&gt;type
op_ne
id|E_SYMBOL
op_logical_and
id|e1-&gt;type
op_ne
id|E_NOT
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|e2-&gt;type
op_ne
id|E_EQUAL
op_logical_and
id|e2-&gt;type
op_ne
id|E_UNEQUAL
op_logical_and
id|e2-&gt;type
op_ne
id|E_SYMBOL
op_logical_and
id|e2-&gt;type
op_ne
id|E_NOT
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|e1-&gt;type
op_eq
id|E_NOT
)paren
(brace
id|tmp
op_assign
id|e1-&gt;left.expr
suffix:semicolon
r_if
c_cond
(paren
id|tmp-&gt;type
op_ne
id|E_EQUAL
op_logical_and
id|tmp-&gt;type
op_ne
id|E_UNEQUAL
op_logical_and
id|tmp-&gt;type
op_ne
id|E_SYMBOL
)paren
r_return
l_int|NULL
suffix:semicolon
id|sym1
op_assign
id|tmp-&gt;left.sym
suffix:semicolon
)brace
r_else
id|sym1
op_assign
id|e1-&gt;left.sym
suffix:semicolon
r_if
c_cond
(paren
id|e2-&gt;type
op_eq
id|E_NOT
)paren
(brace
r_if
c_cond
(paren
id|e2-&gt;left.expr-&gt;type
op_ne
id|E_SYMBOL
)paren
r_return
l_int|NULL
suffix:semicolon
id|sym2
op_assign
id|e2-&gt;left.expr-&gt;left.sym
suffix:semicolon
)brace
r_else
id|sym2
op_assign
id|e2-&gt;left.sym
suffix:semicolon
r_if
c_cond
(paren
id|sym1
op_ne
id|sym2
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|sym1-&gt;type
op_ne
id|S_BOOLEAN
op_logical_and
id|sym1-&gt;type
op_ne
id|S_TRISTATE
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
(paren
id|e1-&gt;type
op_eq
id|E_SYMBOL
op_logical_and
id|e2-&gt;type
op_eq
id|E_EQUAL
op_logical_and
id|e2-&gt;right.sym
op_eq
op_amp
id|symbol_yes
)paren
op_logical_or
(paren
id|e2-&gt;type
op_eq
id|E_SYMBOL
op_logical_and
id|e1-&gt;type
op_eq
id|E_EQUAL
op_logical_and
id|e1-&gt;right.sym
op_eq
op_amp
id|symbol_yes
)paren
)paren
singleline_comment|// (a) &amp;&amp; (a=&squot;y&squot;) -&gt; (a=&squot;y&squot;)
r_return
id|expr_alloc_comp
c_func
(paren
id|E_EQUAL
comma
id|sym1
comma
op_amp
id|symbol_yes
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|e1-&gt;type
op_eq
id|E_SYMBOL
op_logical_and
id|e2-&gt;type
op_eq
id|E_UNEQUAL
op_logical_and
id|e2-&gt;right.sym
op_eq
op_amp
id|symbol_no
)paren
op_logical_or
(paren
id|e2-&gt;type
op_eq
id|E_SYMBOL
op_logical_and
id|e1-&gt;type
op_eq
id|E_UNEQUAL
op_logical_and
id|e1-&gt;right.sym
op_eq
op_amp
id|symbol_no
)paren
)paren
singleline_comment|// (a) &amp;&amp; (a!=&squot;n&squot;) -&gt; (a)
r_return
id|expr_alloc_symbol
c_func
(paren
id|sym1
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|e1-&gt;type
op_eq
id|E_SYMBOL
op_logical_and
id|e2-&gt;type
op_eq
id|E_UNEQUAL
op_logical_and
id|e2-&gt;right.sym
op_eq
op_amp
id|symbol_mod
)paren
op_logical_or
(paren
id|e2-&gt;type
op_eq
id|E_SYMBOL
op_logical_and
id|e1-&gt;type
op_eq
id|E_UNEQUAL
op_logical_and
id|e1-&gt;right.sym
op_eq
op_amp
id|symbol_mod
)paren
)paren
singleline_comment|// (a) &amp;&amp; (a!=&squot;m&squot;) -&gt; (a=&squot;y&squot;)
r_return
id|expr_alloc_comp
c_func
(paren
id|E_EQUAL
comma
id|sym1
comma
op_amp
id|symbol_yes
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sym1-&gt;type
op_eq
id|S_TRISTATE
)paren
(brace
r_if
c_cond
(paren
id|e1-&gt;type
op_eq
id|E_EQUAL
op_logical_and
id|e2-&gt;type
op_eq
id|E_UNEQUAL
)paren
(brace
singleline_comment|// (a=&squot;b&squot;) &amp;&amp; (a!=&squot;c&squot;) -&gt; &squot;b&squot;=&squot;c&squot; ? &squot;n&squot; : a=&squot;b&squot;
id|sym2
op_assign
id|e1-&gt;right.sym
suffix:semicolon
r_if
c_cond
(paren
(paren
id|e2-&gt;right.sym-&gt;flags
op_amp
id|SYMBOL_CONST
)paren
op_logical_and
(paren
id|sym2-&gt;flags
op_amp
id|SYMBOL_CONST
)paren
)paren
r_return
id|sym2
op_ne
id|e2-&gt;right.sym
ques
c_cond
id|expr_alloc_comp
c_func
(paren
id|E_EQUAL
comma
id|sym1
comma
id|sym2
)paren
suffix:colon
id|expr_alloc_symbol
c_func
(paren
op_amp
id|symbol_no
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|e1-&gt;type
op_eq
id|E_UNEQUAL
op_logical_and
id|e2-&gt;type
op_eq
id|E_EQUAL
)paren
(brace
singleline_comment|// (a=&squot;b&squot;) &amp;&amp; (a!=&squot;c&squot;) -&gt; &squot;b&squot;=&squot;c&squot; ? &squot;n&squot; : a=&squot;b&squot;
id|sym2
op_assign
id|e2-&gt;right.sym
suffix:semicolon
r_if
c_cond
(paren
(paren
id|e1-&gt;right.sym-&gt;flags
op_amp
id|SYMBOL_CONST
)paren
op_logical_and
(paren
id|sym2-&gt;flags
op_amp
id|SYMBOL_CONST
)paren
)paren
r_return
id|sym2
op_ne
id|e1-&gt;right.sym
ques
c_cond
id|expr_alloc_comp
c_func
(paren
id|E_EQUAL
comma
id|sym1
comma
id|sym2
)paren
suffix:colon
id|expr_alloc_symbol
c_func
(paren
op_amp
id|symbol_no
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|e1-&gt;type
op_eq
id|E_UNEQUAL
op_logical_and
id|e2-&gt;type
op_eq
id|E_UNEQUAL
op_logical_and
(paren
(paren
id|e1-&gt;right.sym
op_eq
op_amp
id|symbol_yes
op_logical_and
id|e2-&gt;right.sym
op_eq
op_amp
id|symbol_no
)paren
op_logical_or
(paren
id|e1-&gt;right.sym
op_eq
op_amp
id|symbol_no
op_logical_and
id|e2-&gt;right.sym
op_eq
op_amp
id|symbol_yes
)paren
)paren
)paren
singleline_comment|// (a!=&squot;y&squot;) &amp;&amp; (a!=&squot;n&squot;) -&gt; (a=&squot;m&squot;)
r_return
id|expr_alloc_comp
c_func
(paren
id|E_EQUAL
comma
id|sym1
comma
op_amp
id|symbol_mod
)paren
suffix:semicolon
r_if
c_cond
(paren
id|e1-&gt;type
op_eq
id|E_UNEQUAL
op_logical_and
id|e2-&gt;type
op_eq
id|E_UNEQUAL
op_logical_and
(paren
(paren
id|e1-&gt;right.sym
op_eq
op_amp
id|symbol_yes
op_logical_and
id|e2-&gt;right.sym
op_eq
op_amp
id|symbol_mod
)paren
op_logical_or
(paren
id|e1-&gt;right.sym
op_eq
op_amp
id|symbol_mod
op_logical_and
id|e2-&gt;right.sym
op_eq
op_amp
id|symbol_yes
)paren
)paren
)paren
singleline_comment|// (a!=&squot;y&squot;) &amp;&amp; (a!=&squot;m&squot;) -&gt; (a=&squot;n&squot;)
r_return
id|expr_alloc_comp
c_func
(paren
id|E_EQUAL
comma
id|sym1
comma
op_amp
id|symbol_no
)paren
suffix:semicolon
r_if
c_cond
(paren
id|e1-&gt;type
op_eq
id|E_UNEQUAL
op_logical_and
id|e2-&gt;type
op_eq
id|E_UNEQUAL
op_logical_and
(paren
(paren
id|e1-&gt;right.sym
op_eq
op_amp
id|symbol_mod
op_logical_and
id|e2-&gt;right.sym
op_eq
op_amp
id|symbol_no
)paren
op_logical_or
(paren
id|e1-&gt;right.sym
op_eq
op_amp
id|symbol_no
op_logical_and
id|e2-&gt;right.sym
op_eq
op_amp
id|symbol_mod
)paren
)paren
)paren
singleline_comment|// (a!=&squot;m&squot;) &amp;&amp; (a!=&squot;n&squot;) -&gt; (a=&squot;m&squot;)
r_return
id|expr_alloc_comp
c_func
(paren
id|E_EQUAL
comma
id|sym1
comma
op_amp
id|symbol_yes
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|e1-&gt;type
op_eq
id|E_SYMBOL
op_logical_and
id|e2-&gt;type
op_eq
id|E_EQUAL
op_logical_and
id|e2-&gt;right.sym
op_eq
op_amp
id|symbol_mod
)paren
op_logical_or
(paren
id|e2-&gt;type
op_eq
id|E_SYMBOL
op_logical_and
id|e1-&gt;type
op_eq
id|E_EQUAL
op_logical_and
id|e1-&gt;right.sym
op_eq
op_amp
id|symbol_mod
)paren
op_logical_or
(paren
id|e1-&gt;type
op_eq
id|E_SYMBOL
op_logical_and
id|e2-&gt;type
op_eq
id|E_UNEQUAL
op_logical_and
id|e2-&gt;right.sym
op_eq
op_amp
id|symbol_yes
)paren
op_logical_or
(paren
id|e2-&gt;type
op_eq
id|E_SYMBOL
op_logical_and
id|e1-&gt;type
op_eq
id|E_UNEQUAL
op_logical_and
id|e1-&gt;right.sym
op_eq
op_amp
id|symbol_yes
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|DEBUG_EXPR
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;optimize (&quot;
)paren
suffix:semicolon
id|expr_fprint
c_func
(paren
id|e1
comma
id|stdout
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;) &amp;&amp; (&quot;
)paren
suffix:semicolon
id|expr_fprint
c_func
(paren
id|e2
comma
id|stdout
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;)?&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|expr_eliminate_dups1
r_static
r_void
id|expr_eliminate_dups1
c_func
(paren
r_enum
id|expr_type
id|type
comma
r_struct
id|expr
op_star
op_star
id|ep1
comma
r_struct
id|expr
op_star
op_star
id|ep2
)paren
(brace
DECL|macro|e1
mdefine_line|#define e1 (*ep1)
DECL|macro|e2
mdefine_line|#define e2 (*ep2)
r_struct
id|expr
op_star
id|tmp
suffix:semicolon
r_if
c_cond
(paren
id|e1-&gt;type
op_eq
id|type
)paren
(brace
id|expr_eliminate_dups1
c_func
(paren
id|type
comma
op_amp
id|e1-&gt;left.expr
comma
op_amp
id|e2
)paren
suffix:semicolon
id|expr_eliminate_dups1
c_func
(paren
id|type
comma
op_amp
id|e1-&gt;right.expr
comma
op_amp
id|e2
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|e2-&gt;type
op_eq
id|type
)paren
(brace
id|expr_eliminate_dups1
c_func
(paren
id|type
comma
op_amp
id|e1
comma
op_amp
id|e2-&gt;left.expr
)paren
suffix:semicolon
id|expr_eliminate_dups1
c_func
(paren
id|type
comma
op_amp
id|e1
comma
op_amp
id|e2-&gt;right.expr
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|e1
op_eq
id|e2
)paren
r_return
suffix:semicolon
r_switch
c_cond
(paren
id|e1-&gt;type
)paren
(brace
r_case
id|E_OR
suffix:colon
r_case
id|E_AND
suffix:colon
id|expr_eliminate_dups1
c_func
(paren
id|e1-&gt;type
comma
op_amp
id|e1
comma
op_amp
id|e1
)paren
suffix:semicolon
r_default
suffix:colon
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|type
)paren
(brace
r_case
id|E_OR
suffix:colon
id|tmp
op_assign
id|expr_join_or
c_func
(paren
id|e1
comma
id|e2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
)paren
(brace
id|expr_free
c_func
(paren
id|e1
)paren
suffix:semicolon
id|expr_free
c_func
(paren
id|e2
)paren
suffix:semicolon
id|e1
op_assign
id|expr_alloc_symbol
c_func
(paren
op_amp
id|symbol_no
)paren
suffix:semicolon
id|e2
op_assign
id|tmp
suffix:semicolon
id|trans_count
op_increment
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|E_AND
suffix:colon
id|tmp
op_assign
id|expr_join_and
c_func
(paren
id|e1
comma
id|e2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
)paren
(brace
id|expr_free
c_func
(paren
id|e1
)paren
suffix:semicolon
id|expr_free
c_func
(paren
id|e2
)paren
suffix:semicolon
id|e1
op_assign
id|expr_alloc_symbol
c_func
(paren
op_amp
id|symbol_yes
)paren
suffix:semicolon
id|e2
op_assign
id|tmp
suffix:semicolon
id|trans_count
op_increment
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
suffix:semicolon
)brace
DECL|macro|e1
macro_line|#undef e1
DECL|macro|e2
macro_line|#undef e2
)brace
DECL|function|expr_eliminate_dups2
r_static
r_void
id|expr_eliminate_dups2
c_func
(paren
r_enum
id|expr_type
id|type
comma
r_struct
id|expr
op_star
op_star
id|ep1
comma
r_struct
id|expr
op_star
op_star
id|ep2
)paren
(brace
DECL|macro|e1
mdefine_line|#define e1 (*ep1)
DECL|macro|e2
mdefine_line|#define e2 (*ep2)
r_struct
id|expr
op_star
id|tmp
comma
op_star
id|tmp1
comma
op_star
id|tmp2
suffix:semicolon
r_if
c_cond
(paren
id|e1-&gt;type
op_eq
id|type
)paren
(brace
id|expr_eliminate_dups2
c_func
(paren
id|type
comma
op_amp
id|e1-&gt;left.expr
comma
op_amp
id|e2
)paren
suffix:semicolon
id|expr_eliminate_dups2
c_func
(paren
id|type
comma
op_amp
id|e1-&gt;right.expr
comma
op_amp
id|e2
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|e2-&gt;type
op_eq
id|type
)paren
(brace
id|expr_eliminate_dups2
c_func
(paren
id|type
comma
op_amp
id|e1
comma
op_amp
id|e2-&gt;left.expr
)paren
suffix:semicolon
id|expr_eliminate_dups2
c_func
(paren
id|type
comma
op_amp
id|e1
comma
op_amp
id|e2-&gt;right.expr
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|e1
op_eq
id|e2
)paren
r_return
suffix:semicolon
r_switch
c_cond
(paren
id|e1-&gt;type
)paren
(brace
r_case
id|E_OR
suffix:colon
id|expr_eliminate_dups2
c_func
(paren
id|e1-&gt;type
comma
op_amp
id|e1
comma
op_amp
id|e1
)paren
suffix:semicolon
singleline_comment|// (FOO || BAR) &amp;&amp; (!FOO &amp;&amp; !BAR) -&gt; n
id|tmp1
op_assign
id|expr_transform
c_func
(paren
id|expr_alloc_one
c_func
(paren
id|E_NOT
comma
id|expr_copy
c_func
(paren
id|e1
)paren
)paren
)paren
suffix:semicolon
id|tmp2
op_assign
id|expr_copy
c_func
(paren
id|e2
)paren
suffix:semicolon
id|tmp
op_assign
id|expr_extract_eq_and
c_func
(paren
op_amp
id|tmp1
comma
op_amp
id|tmp2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|expr_is_yes
c_func
(paren
id|tmp1
)paren
)paren
(brace
id|expr_free
c_func
(paren
id|e1
)paren
suffix:semicolon
id|e1
op_assign
id|expr_alloc_symbol
c_func
(paren
op_amp
id|symbol_no
)paren
suffix:semicolon
id|trans_count
op_increment
suffix:semicolon
)brace
id|expr_free
c_func
(paren
id|tmp2
)paren
suffix:semicolon
id|expr_free
c_func
(paren
id|tmp1
)paren
suffix:semicolon
id|expr_free
c_func
(paren
id|tmp
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|E_AND
suffix:colon
id|expr_eliminate_dups2
c_func
(paren
id|e1-&gt;type
comma
op_amp
id|e1
comma
op_amp
id|e1
)paren
suffix:semicolon
singleline_comment|// (FOO &amp;&amp; BAR) || (!FOO || !BAR) -&gt; y
id|tmp1
op_assign
id|expr_transform
c_func
(paren
id|expr_alloc_one
c_func
(paren
id|E_NOT
comma
id|expr_copy
c_func
(paren
id|e1
)paren
)paren
)paren
suffix:semicolon
id|tmp2
op_assign
id|expr_copy
c_func
(paren
id|e2
)paren
suffix:semicolon
id|tmp
op_assign
id|expr_extract_eq_or
c_func
(paren
op_amp
id|tmp1
comma
op_amp
id|tmp2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|expr_is_no
c_func
(paren
id|tmp1
)paren
)paren
(brace
id|expr_free
c_func
(paren
id|e1
)paren
suffix:semicolon
id|e1
op_assign
id|expr_alloc_symbol
c_func
(paren
op_amp
id|symbol_yes
)paren
suffix:semicolon
id|trans_count
op_increment
suffix:semicolon
)brace
id|expr_free
c_func
(paren
id|tmp2
)paren
suffix:semicolon
id|expr_free
c_func
(paren
id|tmp1
)paren
suffix:semicolon
id|expr_free
c_func
(paren
id|tmp
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
suffix:semicolon
)brace
DECL|macro|e1
macro_line|#undef e1
DECL|macro|e2
macro_line|#undef e2
)brace
DECL|function|expr_eliminate_dups
r_struct
id|expr
op_star
id|expr_eliminate_dups
c_func
(paren
r_struct
id|expr
op_star
id|e
)paren
(brace
r_int
id|oldcount
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|e
)paren
r_return
id|e
suffix:semicolon
id|oldcount
op_assign
id|trans_count
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|trans_count
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|e-&gt;type
)paren
(brace
r_case
id|E_OR
suffix:colon
r_case
id|E_AND
suffix:colon
id|expr_eliminate_dups1
c_func
(paren
id|e-&gt;type
comma
op_amp
id|e
comma
op_amp
id|e
)paren
suffix:semicolon
id|expr_eliminate_dups2
c_func
(paren
id|e-&gt;type
comma
op_amp
id|e
comma
op_amp
id|e
)paren
suffix:semicolon
r_default
suffix:colon
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|trans_count
)paren
r_break
suffix:semicolon
id|e
op_assign
id|expr_eliminate_yn
c_func
(paren
id|e
)paren
suffix:semicolon
)brace
id|trans_count
op_assign
id|oldcount
suffix:semicolon
r_return
id|e
suffix:semicolon
)brace
DECL|function|expr_transform
r_struct
id|expr
op_star
id|expr_transform
c_func
(paren
r_struct
id|expr
op_star
id|e
)paren
(brace
r_struct
id|expr
op_star
id|tmp
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|e
)paren
r_return
l_int|NULL
suffix:semicolon
r_switch
c_cond
(paren
id|e-&gt;type
)paren
(brace
r_case
id|E_EQUAL
suffix:colon
r_case
id|E_UNEQUAL
suffix:colon
r_case
id|E_SYMBOL
suffix:colon
r_case
id|E_CHOICE
suffix:colon
r_break
suffix:semicolon
r_default
suffix:colon
id|e-&gt;left.expr
op_assign
id|expr_transform
c_func
(paren
id|e-&gt;left.expr
)paren
suffix:semicolon
id|e-&gt;right.expr
op_assign
id|expr_transform
c_func
(paren
id|e-&gt;right.expr
)paren
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|e-&gt;type
)paren
(brace
r_case
id|E_EQUAL
suffix:colon
r_if
c_cond
(paren
id|e-&gt;left.sym-&gt;type
op_ne
id|S_BOOLEAN
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|e-&gt;right.sym
op_eq
op_amp
id|symbol_no
)paren
(brace
id|e-&gt;type
op_assign
id|E_NOT
suffix:semicolon
id|e-&gt;left.expr
op_assign
id|expr_alloc_symbol
c_func
(paren
id|e-&gt;left.sym
)paren
suffix:semicolon
id|e-&gt;right.sym
op_assign
l_int|NULL
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|e-&gt;right.sym
op_eq
op_amp
id|symbol_mod
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;boolean symbol %s tested for &squot;m&squot;? test forced to &squot;n&squot;&bslash;n&quot;
comma
id|e-&gt;left.sym-&gt;name
)paren
suffix:semicolon
id|e-&gt;type
op_assign
id|E_SYMBOL
suffix:semicolon
id|e-&gt;left.sym
op_assign
op_amp
id|symbol_no
suffix:semicolon
id|e-&gt;right.sym
op_assign
l_int|NULL
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|e-&gt;right.sym
op_eq
op_amp
id|symbol_yes
)paren
(brace
id|e-&gt;type
op_assign
id|E_SYMBOL
suffix:semicolon
id|e-&gt;right.sym
op_assign
l_int|NULL
suffix:semicolon
r_break
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|E_UNEQUAL
suffix:colon
r_if
c_cond
(paren
id|e-&gt;left.sym-&gt;type
op_ne
id|S_BOOLEAN
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|e-&gt;right.sym
op_eq
op_amp
id|symbol_no
)paren
(brace
id|e-&gt;type
op_assign
id|E_SYMBOL
suffix:semicolon
id|e-&gt;right.sym
op_assign
l_int|NULL
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|e-&gt;right.sym
op_eq
op_amp
id|symbol_mod
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;boolean symbol %s tested for &squot;m&squot;? test forced to &squot;y&squot;&bslash;n&quot;
comma
id|e-&gt;left.sym-&gt;name
)paren
suffix:semicolon
id|e-&gt;type
op_assign
id|E_SYMBOL
suffix:semicolon
id|e-&gt;left.sym
op_assign
op_amp
id|symbol_yes
suffix:semicolon
id|e-&gt;right.sym
op_assign
l_int|NULL
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|e-&gt;right.sym
op_eq
op_amp
id|symbol_yes
)paren
(brace
id|e-&gt;type
op_assign
id|E_NOT
suffix:semicolon
id|e-&gt;left.expr
op_assign
id|expr_alloc_symbol
c_func
(paren
id|e-&gt;left.sym
)paren
suffix:semicolon
id|e-&gt;right.sym
op_assign
l_int|NULL
suffix:semicolon
r_break
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|E_NOT
suffix:colon
r_switch
c_cond
(paren
id|e-&gt;left.expr-&gt;type
)paren
(brace
r_case
id|E_NOT
suffix:colon
singleline_comment|// !!a -&gt; a
id|tmp
op_assign
id|e-&gt;left.expr-&gt;left.expr
suffix:semicolon
id|free
c_func
(paren
id|e-&gt;left.expr
)paren
suffix:semicolon
id|free
c_func
(paren
id|e
)paren
suffix:semicolon
id|e
op_assign
id|tmp
suffix:semicolon
id|e
op_assign
id|expr_transform
c_func
(paren
id|e
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|E_EQUAL
suffix:colon
r_case
id|E_UNEQUAL
suffix:colon
singleline_comment|// !a=&squot;x&squot; -&gt; a!=&squot;x&squot;
id|tmp
op_assign
id|e-&gt;left.expr
suffix:semicolon
id|free
c_func
(paren
id|e
)paren
suffix:semicolon
id|e
op_assign
id|tmp
suffix:semicolon
id|e-&gt;type
op_assign
id|e-&gt;type
op_eq
id|E_EQUAL
ques
c_cond
id|E_UNEQUAL
suffix:colon
id|E_EQUAL
suffix:semicolon
r_break
suffix:semicolon
r_case
id|E_OR
suffix:colon
singleline_comment|// !(a || b) -&gt; !a &amp;&amp; !b
id|tmp
op_assign
id|e-&gt;left.expr
suffix:semicolon
id|e-&gt;type
op_assign
id|E_AND
suffix:semicolon
id|e-&gt;right.expr
op_assign
id|expr_alloc_one
c_func
(paren
id|E_NOT
comma
id|tmp-&gt;right.expr
)paren
suffix:semicolon
id|tmp-&gt;type
op_assign
id|E_NOT
suffix:semicolon
id|tmp-&gt;right.expr
op_assign
l_int|NULL
suffix:semicolon
id|e
op_assign
id|expr_transform
c_func
(paren
id|e
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|E_AND
suffix:colon
singleline_comment|// !(a &amp;&amp; b) -&gt; !a || !b
id|tmp
op_assign
id|e-&gt;left.expr
suffix:semicolon
id|e-&gt;type
op_assign
id|E_OR
suffix:semicolon
id|e-&gt;right.expr
op_assign
id|expr_alloc_one
c_func
(paren
id|E_NOT
comma
id|tmp-&gt;right.expr
)paren
suffix:semicolon
id|tmp-&gt;type
op_assign
id|E_NOT
suffix:semicolon
id|tmp-&gt;right.expr
op_assign
l_int|NULL
suffix:semicolon
id|e
op_assign
id|expr_transform
c_func
(paren
id|e
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|E_SYMBOL
suffix:colon
r_if
c_cond
(paren
id|e-&gt;left.expr-&gt;left.sym
op_eq
op_amp
id|symbol_yes
)paren
(brace
singleline_comment|// !&squot;y&squot; -&gt; &squot;n&squot;
id|tmp
op_assign
id|e-&gt;left.expr
suffix:semicolon
id|free
c_func
(paren
id|e
)paren
suffix:semicolon
id|e
op_assign
id|tmp
suffix:semicolon
id|e-&gt;type
op_assign
id|E_SYMBOL
suffix:semicolon
id|e-&gt;left.sym
op_assign
op_amp
id|symbol_no
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|e-&gt;left.expr-&gt;left.sym
op_eq
op_amp
id|symbol_mod
)paren
(brace
singleline_comment|// !&squot;m&squot; -&gt; &squot;m&squot;
id|tmp
op_assign
id|e-&gt;left.expr
suffix:semicolon
id|free
c_func
(paren
id|e
)paren
suffix:semicolon
id|e
op_assign
id|tmp
suffix:semicolon
id|e-&gt;type
op_assign
id|E_SYMBOL
suffix:semicolon
id|e-&gt;left.sym
op_assign
op_amp
id|symbol_mod
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|e-&gt;left.expr-&gt;left.sym
op_eq
op_amp
id|symbol_no
)paren
(brace
singleline_comment|// !&squot;n&squot; -&gt; &squot;y&squot;
id|tmp
op_assign
id|e-&gt;left.expr
suffix:semicolon
id|free
c_func
(paren
id|e
)paren
suffix:semicolon
id|e
op_assign
id|tmp
suffix:semicolon
id|e-&gt;type
op_assign
id|E_SYMBOL
suffix:semicolon
id|e-&gt;left.sym
op_assign
op_amp
id|symbol_yes
suffix:semicolon
r_break
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
suffix:semicolon
)brace
r_return
id|e
suffix:semicolon
)brace
DECL|function|expr_contains_symbol
r_int
id|expr_contains_symbol
c_func
(paren
r_struct
id|expr
op_star
id|dep
comma
r_struct
id|symbol
op_star
id|sym
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|dep
)paren
r_return
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|dep-&gt;type
)paren
(brace
r_case
id|E_AND
suffix:colon
r_case
id|E_OR
suffix:colon
r_return
id|expr_contains_symbol
c_func
(paren
id|dep-&gt;left.expr
comma
id|sym
)paren
op_logical_or
id|expr_contains_symbol
c_func
(paren
id|dep-&gt;right.expr
comma
id|sym
)paren
suffix:semicolon
r_case
id|E_SYMBOL
suffix:colon
r_return
id|dep-&gt;left.sym
op_eq
id|sym
suffix:semicolon
r_case
id|E_EQUAL
suffix:colon
r_case
id|E_UNEQUAL
suffix:colon
r_return
id|dep-&gt;left.sym
op_eq
id|sym
op_logical_or
id|dep-&gt;right.sym
op_eq
id|sym
suffix:semicolon
r_case
id|E_NOT
suffix:colon
r_return
id|expr_contains_symbol
c_func
(paren
id|dep-&gt;left.expr
comma
id|sym
)paren
suffix:semicolon
r_default
suffix:colon
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|expr_depends_symbol
r_bool
id|expr_depends_symbol
c_func
(paren
r_struct
id|expr
op_star
id|dep
comma
r_struct
id|symbol
op_star
id|sym
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|dep
)paren
r_return
l_bool|false
suffix:semicolon
r_switch
c_cond
(paren
id|dep-&gt;type
)paren
(brace
r_case
id|E_AND
suffix:colon
r_return
id|expr_depends_symbol
c_func
(paren
id|dep-&gt;left.expr
comma
id|sym
)paren
op_logical_or
id|expr_depends_symbol
c_func
(paren
id|dep-&gt;right.expr
comma
id|sym
)paren
suffix:semicolon
r_case
id|E_SYMBOL
suffix:colon
r_return
id|dep-&gt;left.sym
op_eq
id|sym
suffix:semicolon
r_case
id|E_EQUAL
suffix:colon
r_if
c_cond
(paren
id|dep-&gt;left.sym
op_eq
id|sym
)paren
(brace
r_if
c_cond
(paren
id|dep-&gt;right.sym
op_eq
op_amp
id|symbol_yes
op_logical_or
id|dep-&gt;right.sym
op_eq
op_amp
id|symbol_mod
)paren
r_return
l_bool|true
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|E_UNEQUAL
suffix:colon
r_if
c_cond
(paren
id|dep-&gt;left.sym
op_eq
id|sym
)paren
(brace
r_if
c_cond
(paren
id|dep-&gt;right.sym
op_eq
op_amp
id|symbol_no
)paren
r_return
l_bool|true
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
suffix:semicolon
)brace
r_return
l_bool|false
suffix:semicolon
)brace
DECL|function|expr_extract_eq_and
r_struct
id|expr
op_star
id|expr_extract_eq_and
c_func
(paren
r_struct
id|expr
op_star
op_star
id|ep1
comma
r_struct
id|expr
op_star
op_star
id|ep2
)paren
(brace
r_struct
id|expr
op_star
id|tmp
op_assign
l_int|NULL
suffix:semicolon
id|expr_extract_eq
c_func
(paren
id|E_AND
comma
op_amp
id|tmp
comma
id|ep1
comma
id|ep2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
)paren
(brace
op_star
id|ep1
op_assign
id|expr_eliminate_yn
c_func
(paren
op_star
id|ep1
)paren
suffix:semicolon
op_star
id|ep2
op_assign
id|expr_eliminate_yn
c_func
(paren
op_star
id|ep2
)paren
suffix:semicolon
)brace
r_return
id|tmp
suffix:semicolon
)brace
DECL|function|expr_extract_eq_or
r_struct
id|expr
op_star
id|expr_extract_eq_or
c_func
(paren
r_struct
id|expr
op_star
op_star
id|ep1
comma
r_struct
id|expr
op_star
op_star
id|ep2
)paren
(brace
r_struct
id|expr
op_star
id|tmp
op_assign
l_int|NULL
suffix:semicolon
id|expr_extract_eq
c_func
(paren
id|E_OR
comma
op_amp
id|tmp
comma
id|ep1
comma
id|ep2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
)paren
(brace
op_star
id|ep1
op_assign
id|expr_eliminate_yn
c_func
(paren
op_star
id|ep1
)paren
suffix:semicolon
op_star
id|ep2
op_assign
id|expr_eliminate_yn
c_func
(paren
op_star
id|ep2
)paren
suffix:semicolon
)brace
r_return
id|tmp
suffix:semicolon
)brace
DECL|function|expr_extract_eq
r_void
id|expr_extract_eq
c_func
(paren
r_enum
id|expr_type
id|type
comma
r_struct
id|expr
op_star
op_star
id|ep
comma
r_struct
id|expr
op_star
op_star
id|ep1
comma
r_struct
id|expr
op_star
op_star
id|ep2
)paren
(brace
DECL|macro|e1
mdefine_line|#define e1 (*ep1)
DECL|macro|e2
mdefine_line|#define e2 (*ep2)
r_if
c_cond
(paren
id|e1-&gt;type
op_eq
id|type
)paren
(brace
id|expr_extract_eq
c_func
(paren
id|type
comma
id|ep
comma
op_amp
id|e1-&gt;left.expr
comma
op_amp
id|e2
)paren
suffix:semicolon
id|expr_extract_eq
c_func
(paren
id|type
comma
id|ep
comma
op_amp
id|e1-&gt;right.expr
comma
op_amp
id|e2
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|e2-&gt;type
op_eq
id|type
)paren
(brace
id|expr_extract_eq
c_func
(paren
id|type
comma
id|ep
comma
id|ep1
comma
op_amp
id|e2-&gt;left.expr
)paren
suffix:semicolon
id|expr_extract_eq
c_func
(paren
id|type
comma
id|ep
comma
id|ep1
comma
op_amp
id|e2-&gt;right.expr
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|expr_eq
c_func
(paren
id|e1
comma
id|e2
)paren
)paren
(brace
op_star
id|ep
op_assign
op_star
id|ep
ques
c_cond
id|expr_alloc_two
c_func
(paren
id|type
comma
op_star
id|ep
comma
id|e1
)paren
suffix:colon
id|e1
suffix:semicolon
id|expr_free
c_func
(paren
id|e2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|type
op_eq
id|E_AND
)paren
(brace
id|e1
op_assign
id|expr_alloc_symbol
c_func
(paren
op_amp
id|symbol_yes
)paren
suffix:semicolon
id|e2
op_assign
id|expr_alloc_symbol
c_func
(paren
op_amp
id|symbol_yes
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|type
op_eq
id|E_OR
)paren
(brace
id|e1
op_assign
id|expr_alloc_symbol
c_func
(paren
op_amp
id|symbol_no
)paren
suffix:semicolon
id|e2
op_assign
id|expr_alloc_symbol
c_func
(paren
op_amp
id|symbol_no
)paren
suffix:semicolon
)brace
)brace
DECL|macro|e1
macro_line|#undef e1
DECL|macro|e2
macro_line|#undef e2
)brace
DECL|function|expr_trans_compare
r_struct
id|expr
op_star
id|expr_trans_compare
c_func
(paren
r_struct
id|expr
op_star
id|e
comma
r_enum
id|expr_type
id|type
comma
r_struct
id|symbol
op_star
id|sym
)paren
(brace
r_struct
id|expr
op_star
id|e1
comma
op_star
id|e2
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|e
)paren
(brace
id|e
op_assign
id|expr_alloc_symbol
c_func
(paren
id|sym
)paren
suffix:semicolon
r_if
c_cond
(paren
id|type
op_eq
id|E_UNEQUAL
)paren
id|e
op_assign
id|expr_alloc_one
c_func
(paren
id|E_NOT
comma
id|e
)paren
suffix:semicolon
r_return
id|e
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|e-&gt;type
)paren
(brace
r_case
id|E_AND
suffix:colon
id|e1
op_assign
id|expr_trans_compare
c_func
(paren
id|e-&gt;left.expr
comma
id|E_EQUAL
comma
id|sym
)paren
suffix:semicolon
id|e2
op_assign
id|expr_trans_compare
c_func
(paren
id|e-&gt;right.expr
comma
id|E_EQUAL
comma
id|sym
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sym
op_eq
op_amp
id|symbol_yes
)paren
id|e
op_assign
id|expr_alloc_two
c_func
(paren
id|E_AND
comma
id|e1
comma
id|e2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sym
op_eq
op_amp
id|symbol_no
)paren
id|e
op_assign
id|expr_alloc_two
c_func
(paren
id|E_OR
comma
id|e1
comma
id|e2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|type
op_eq
id|E_UNEQUAL
)paren
id|e
op_assign
id|expr_alloc_one
c_func
(paren
id|E_NOT
comma
id|e
)paren
suffix:semicolon
r_return
id|e
suffix:semicolon
r_case
id|E_OR
suffix:colon
id|e1
op_assign
id|expr_trans_compare
c_func
(paren
id|e-&gt;left.expr
comma
id|E_EQUAL
comma
id|sym
)paren
suffix:semicolon
id|e2
op_assign
id|expr_trans_compare
c_func
(paren
id|e-&gt;right.expr
comma
id|E_EQUAL
comma
id|sym
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sym
op_eq
op_amp
id|symbol_yes
)paren
id|e
op_assign
id|expr_alloc_two
c_func
(paren
id|E_OR
comma
id|e1
comma
id|e2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sym
op_eq
op_amp
id|symbol_no
)paren
id|e
op_assign
id|expr_alloc_two
c_func
(paren
id|E_AND
comma
id|e1
comma
id|e2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|type
op_eq
id|E_UNEQUAL
)paren
id|e
op_assign
id|expr_alloc_one
c_func
(paren
id|E_NOT
comma
id|e
)paren
suffix:semicolon
r_return
id|e
suffix:semicolon
r_case
id|E_NOT
suffix:colon
r_return
id|expr_trans_compare
c_func
(paren
id|e-&gt;left.expr
comma
id|type
op_eq
id|E_EQUAL
ques
c_cond
id|E_UNEQUAL
suffix:colon
id|E_EQUAL
comma
id|sym
)paren
suffix:semicolon
r_case
id|E_UNEQUAL
suffix:colon
r_case
id|E_EQUAL
suffix:colon
r_if
c_cond
(paren
id|type
op_eq
id|E_EQUAL
)paren
(brace
r_if
c_cond
(paren
id|sym
op_eq
op_amp
id|symbol_yes
)paren
r_return
id|expr_copy
c_func
(paren
id|e
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sym
op_eq
op_amp
id|symbol_mod
)paren
r_return
id|expr_alloc_symbol
c_func
(paren
op_amp
id|symbol_no
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sym
op_eq
op_amp
id|symbol_no
)paren
r_return
id|expr_alloc_one
c_func
(paren
id|E_NOT
comma
id|expr_copy
c_func
(paren
id|e
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|sym
op_eq
op_amp
id|symbol_yes
)paren
r_return
id|expr_alloc_one
c_func
(paren
id|E_NOT
comma
id|expr_copy
c_func
(paren
id|e
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sym
op_eq
op_amp
id|symbol_mod
)paren
r_return
id|expr_alloc_symbol
c_func
(paren
op_amp
id|symbol_yes
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sym
op_eq
op_amp
id|symbol_no
)paren
r_return
id|expr_copy
c_func
(paren
id|e
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|E_SYMBOL
suffix:colon
r_return
id|expr_alloc_comp
c_func
(paren
id|type
comma
id|e-&gt;left.sym
comma
id|sym
)paren
suffix:semicolon
r_case
id|E_CHOICE
suffix:colon
r_case
id|E_RANGE
suffix:colon
r_case
id|E_NONE
suffix:colon
multiline_comment|/* panic */
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|expr_calc_value
id|tristate
id|expr_calc_value
c_func
(paren
r_struct
id|expr
op_star
id|e
)paren
(brace
id|tristate
id|val1
comma
id|val2
suffix:semicolon
r_const
r_char
op_star
id|str1
comma
op_star
id|str2
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|e
)paren
r_return
id|yes
suffix:semicolon
r_switch
c_cond
(paren
id|e-&gt;type
)paren
(brace
r_case
id|E_SYMBOL
suffix:colon
id|sym_calc_value
c_func
(paren
id|e-&gt;left.sym
)paren
suffix:semicolon
r_return
id|e-&gt;left.sym-&gt;curr.tri
suffix:semicolon
r_case
id|E_AND
suffix:colon
id|val1
op_assign
id|expr_calc_value
c_func
(paren
id|e-&gt;left.expr
)paren
suffix:semicolon
id|val2
op_assign
id|expr_calc_value
c_func
(paren
id|e-&gt;right.expr
)paren
suffix:semicolon
r_return
id|E_AND
c_func
(paren
id|val1
comma
id|val2
)paren
suffix:semicolon
r_case
id|E_OR
suffix:colon
id|val1
op_assign
id|expr_calc_value
c_func
(paren
id|e-&gt;left.expr
)paren
suffix:semicolon
id|val2
op_assign
id|expr_calc_value
c_func
(paren
id|e-&gt;right.expr
)paren
suffix:semicolon
r_return
id|E_OR
c_func
(paren
id|val1
comma
id|val2
)paren
suffix:semicolon
r_case
id|E_NOT
suffix:colon
id|val1
op_assign
id|expr_calc_value
c_func
(paren
id|e-&gt;left.expr
)paren
suffix:semicolon
r_return
id|E_NOT
c_func
(paren
id|val1
)paren
suffix:semicolon
r_case
id|E_EQUAL
suffix:colon
id|sym_calc_value
c_func
(paren
id|e-&gt;left.sym
)paren
suffix:semicolon
id|sym_calc_value
c_func
(paren
id|e-&gt;right.sym
)paren
suffix:semicolon
id|str1
op_assign
id|sym_get_string_value
c_func
(paren
id|e-&gt;left.sym
)paren
suffix:semicolon
id|str2
op_assign
id|sym_get_string_value
c_func
(paren
id|e-&gt;right.sym
)paren
suffix:semicolon
r_return
op_logical_neg
id|strcmp
c_func
(paren
id|str1
comma
id|str2
)paren
ques
c_cond
id|yes
suffix:colon
id|no
suffix:semicolon
r_case
id|E_UNEQUAL
suffix:colon
id|sym_calc_value
c_func
(paren
id|e-&gt;left.sym
)paren
suffix:semicolon
id|sym_calc_value
c_func
(paren
id|e-&gt;right.sym
)paren
suffix:semicolon
id|str1
op_assign
id|sym_get_string_value
c_func
(paren
id|e-&gt;left.sym
)paren
suffix:semicolon
id|str2
op_assign
id|sym_get_string_value
c_func
(paren
id|e-&gt;right.sym
)paren
suffix:semicolon
r_return
op_logical_neg
id|strcmp
c_func
(paren
id|str1
comma
id|str2
)paren
ques
c_cond
id|no
suffix:colon
id|yes
suffix:semicolon
r_default
suffix:colon
id|printf
c_func
(paren
l_string|&quot;expr_calc_value: %d?&bslash;n&quot;
comma
id|e-&gt;type
)paren
suffix:semicolon
r_return
id|no
suffix:semicolon
)brace
)brace
DECL|function|expr_compare_type
r_int
id|expr_compare_type
c_func
(paren
r_enum
id|expr_type
id|t1
comma
r_enum
id|expr_type
id|t2
)paren
(brace
macro_line|#if 0
r_return
l_int|1
suffix:semicolon
macro_line|#else
r_if
c_cond
(paren
id|t1
op_eq
id|t2
)paren
r_return
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|t1
)paren
(brace
r_case
id|E_EQUAL
suffix:colon
r_case
id|E_UNEQUAL
suffix:colon
r_if
c_cond
(paren
id|t2
op_eq
id|E_NOT
)paren
r_return
l_int|1
suffix:semicolon
r_case
id|E_NOT
suffix:colon
r_if
c_cond
(paren
id|t2
op_eq
id|E_AND
)paren
r_return
l_int|1
suffix:semicolon
r_case
id|E_AND
suffix:colon
r_if
c_cond
(paren
id|t2
op_eq
id|E_OR
)paren
r_return
l_int|1
suffix:semicolon
r_case
id|E_OR
suffix:colon
r_if
c_cond
(paren
id|t2
op_eq
id|E_CHOICE
)paren
r_return
l_int|1
suffix:semicolon
r_case
id|E_CHOICE
suffix:colon
r_if
c_cond
(paren
id|t2
op_eq
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|printf
c_func
(paren
l_string|&quot;[%dgt%d?]&quot;
comma
id|t1
comma
id|t2
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
macro_line|#endif
)brace
DECL|function|expr_print
r_void
id|expr_print
c_func
(paren
r_struct
id|expr
op_star
id|e
comma
r_void
(paren
op_star
id|fn
)paren
(paren
r_void
op_star
comma
r_const
r_char
op_star
)paren
comma
r_void
op_star
id|data
comma
r_int
id|prevtoken
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|e
)paren
(brace
id|fn
c_func
(paren
id|data
comma
l_string|&quot;y&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|expr_compare_type
c_func
(paren
id|prevtoken
comma
id|e-&gt;type
)paren
OG
l_int|0
)paren
id|fn
c_func
(paren
id|data
comma
l_string|&quot;(&quot;
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|e-&gt;type
)paren
(brace
r_case
id|E_SYMBOL
suffix:colon
r_if
c_cond
(paren
id|e-&gt;left.sym-&gt;name
)paren
id|fn
c_func
(paren
id|data
comma
id|e-&gt;left.sym-&gt;name
)paren
suffix:semicolon
r_else
id|fn
c_func
(paren
id|data
comma
l_string|&quot;&lt;choice&gt;&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|E_NOT
suffix:colon
id|fn
c_func
(paren
id|data
comma
l_string|&quot;!&quot;
)paren
suffix:semicolon
id|expr_print
c_func
(paren
id|e-&gt;left.expr
comma
id|fn
comma
id|data
comma
id|E_NOT
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|E_EQUAL
suffix:colon
id|fn
c_func
(paren
id|data
comma
id|e-&gt;left.sym-&gt;name
)paren
suffix:semicolon
id|fn
c_func
(paren
id|data
comma
l_string|&quot;=&quot;
)paren
suffix:semicolon
id|fn
c_func
(paren
id|data
comma
id|e-&gt;right.sym-&gt;name
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|E_UNEQUAL
suffix:colon
id|fn
c_func
(paren
id|data
comma
id|e-&gt;left.sym-&gt;name
)paren
suffix:semicolon
id|fn
c_func
(paren
id|data
comma
l_string|&quot;!=&quot;
)paren
suffix:semicolon
id|fn
c_func
(paren
id|data
comma
id|e-&gt;right.sym-&gt;name
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|E_OR
suffix:colon
id|expr_print
c_func
(paren
id|e-&gt;left.expr
comma
id|fn
comma
id|data
comma
id|E_OR
)paren
suffix:semicolon
id|fn
c_func
(paren
id|data
comma
l_string|&quot; || &quot;
)paren
suffix:semicolon
id|expr_print
c_func
(paren
id|e-&gt;right.expr
comma
id|fn
comma
id|data
comma
id|E_OR
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|E_AND
suffix:colon
id|expr_print
c_func
(paren
id|e-&gt;left.expr
comma
id|fn
comma
id|data
comma
id|E_AND
)paren
suffix:semicolon
id|fn
c_func
(paren
id|data
comma
l_string|&quot; &amp;&amp; &quot;
)paren
suffix:semicolon
id|expr_print
c_func
(paren
id|e-&gt;right.expr
comma
id|fn
comma
id|data
comma
id|E_AND
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|E_CHOICE
suffix:colon
id|fn
c_func
(paren
id|data
comma
id|e-&gt;right.sym-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|e-&gt;left.expr
)paren
(brace
id|fn
c_func
(paren
id|data
comma
l_string|&quot; ^ &quot;
)paren
suffix:semicolon
id|expr_print
c_func
(paren
id|e-&gt;left.expr
comma
id|fn
comma
id|data
comma
id|E_CHOICE
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|E_RANGE
suffix:colon
id|fn
c_func
(paren
id|data
comma
l_string|&quot;[&quot;
)paren
suffix:semicolon
id|fn
c_func
(paren
id|data
comma
id|e-&gt;left.sym-&gt;name
)paren
suffix:semicolon
id|fn
c_func
(paren
id|data
comma
l_string|&quot; &quot;
)paren
suffix:semicolon
id|fn
c_func
(paren
id|data
comma
id|e-&gt;right.sym-&gt;name
)paren
suffix:semicolon
id|fn
c_func
(paren
id|data
comma
l_string|&quot;]&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
(brace
r_char
id|buf
(braket
l_int|32
)braket
suffix:semicolon
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;&lt;unknown type %d&gt;&quot;
comma
id|e-&gt;type
)paren
suffix:semicolon
id|fn
c_func
(paren
id|data
comma
id|buf
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|expr_compare_type
c_func
(paren
id|prevtoken
comma
id|e-&gt;type
)paren
OG
l_int|0
)paren
id|fn
c_func
(paren
id|data
comma
l_string|&quot;)&quot;
)paren
suffix:semicolon
)brace
DECL|function|expr_print_file_helper
r_static
r_void
id|expr_print_file_helper
c_func
(paren
r_void
op_star
id|data
comma
r_const
r_char
op_star
id|str
)paren
(brace
id|fwrite
c_func
(paren
id|str
comma
id|strlen
c_func
(paren
id|str
)paren
comma
l_int|1
comma
id|data
)paren
suffix:semicolon
)brace
DECL|function|expr_fprint
r_void
id|expr_fprint
c_func
(paren
r_struct
id|expr
op_star
id|e
comma
id|FILE
op_star
id|out
)paren
(brace
id|expr_print
c_func
(paren
id|e
comma
id|expr_print_file_helper
comma
id|out
comma
id|E_NONE
)paren
suffix:semicolon
)brace
DECL|function|expr_print_gstr_helper
r_static
r_void
id|expr_print_gstr_helper
c_func
(paren
r_void
op_star
id|data
comma
r_const
r_char
op_star
id|str
)paren
(brace
id|str_append
c_func
(paren
(paren
r_struct
id|gstr
op_star
)paren
id|data
comma
id|str
)paren
suffix:semicolon
)brace
DECL|function|expr_gstr_print
r_void
id|expr_gstr_print
c_func
(paren
r_struct
id|expr
op_star
id|e
comma
r_struct
id|gstr
op_star
id|gs
)paren
(brace
id|expr_print
c_func
(paren
id|e
comma
id|expr_print_gstr_helper
comma
id|gs
comma
id|E_NONE
)paren
suffix:semicolon
)brace
eof
