multiline_comment|/*&n; * Copyright (C) 2002 Roman Zippel &lt;zippel@linux-m68k.org&gt;&n; * Released under the terms of the GNU GPL v2.0.&n; */
macro_line|#include &lt;ctype.h&gt;
macro_line|#include &lt;stdlib.h&gt;
macro_line|#include &lt;string.h&gt;
macro_line|#include &lt;sys/utsname.h&gt;
DECL|macro|LKC_DIRECT_LINK
mdefine_line|#define LKC_DIRECT_LINK
macro_line|#include &quot;lkc.h&quot;
DECL|variable|symbol_yes
r_struct
id|symbol
id|symbol_yes
op_assign
(brace
id|name
suffix:colon
l_string|&quot;y&quot;
comma
id|curr
suffix:colon
(brace
l_string|&quot;y&quot;
comma
id|yes
)brace
comma
id|flags
suffix:colon
id|SYMBOL_YES
op_or
id|SYMBOL_VALID
comma
DECL|variable|symbol_mod
)brace
comma
id|symbol_mod
op_assign
(brace
id|name
suffix:colon
l_string|&quot;m&quot;
comma
id|curr
suffix:colon
(brace
l_string|&quot;m&quot;
comma
id|mod
)brace
comma
id|flags
suffix:colon
id|SYMBOL_MOD
op_or
id|SYMBOL_VALID
comma
DECL|variable|symbol_no
)brace
comma
id|symbol_no
op_assign
(brace
id|name
suffix:colon
l_string|&quot;n&quot;
comma
id|curr
suffix:colon
(brace
l_string|&quot;n&quot;
comma
id|no
)brace
comma
id|flags
suffix:colon
id|SYMBOL_NO
op_or
id|SYMBOL_VALID
comma
DECL|variable|symbol_empty
)brace
comma
id|symbol_empty
op_assign
(brace
id|name
suffix:colon
l_string|&quot;&quot;
comma
id|curr
suffix:colon
(brace
l_string|&quot;&quot;
comma
id|no
)brace
comma
id|flags
suffix:colon
id|SYMBOL_VALID
comma
)brace
suffix:semicolon
DECL|variable|sym_change_count
r_int
id|sym_change_count
suffix:semicolon
DECL|variable|modules_sym
r_struct
id|symbol
op_star
id|modules_sym
suffix:semicolon
DECL|function|sym_add_default
r_void
id|sym_add_default
c_func
(paren
r_struct
id|symbol
op_star
id|sym
comma
r_const
r_char
op_star
id|def
)paren
(brace
r_struct
id|property
op_star
id|prop
op_assign
id|create_prop
c_func
(paren
id|P_DEFAULT
)paren
suffix:semicolon
r_struct
id|property
op_star
op_star
id|propp
suffix:semicolon
id|prop-&gt;sym
op_assign
id|sym
suffix:semicolon
id|prop-&gt;def
op_assign
id|sym_lookup
c_func
(paren
id|def
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* append property to the prop list of symbol */
r_if
c_cond
(paren
id|prop-&gt;sym
)paren
(brace
r_for
c_loop
(paren
id|propp
op_assign
op_amp
id|prop-&gt;sym-&gt;prop
suffix:semicolon
op_star
id|propp
suffix:semicolon
id|propp
op_assign
op_amp
(paren
op_star
id|propp
)paren
op_member_access_from_pointer
id|next
)paren
suffix:semicolon
op_star
id|propp
op_assign
id|prop
suffix:semicolon
)brace
)brace
DECL|function|sym_init
r_void
id|sym_init
c_func
(paren
r_void
)paren
(brace
r_struct
id|symbol
op_star
id|sym
suffix:semicolon
r_struct
id|utsname
id|uts
suffix:semicolon
r_char
op_star
id|p
suffix:semicolon
r_static
r_bool
id|inited
op_assign
l_bool|false
suffix:semicolon
r_if
c_cond
(paren
id|inited
)paren
r_return
suffix:semicolon
id|inited
op_assign
l_bool|true
suffix:semicolon
id|uname
c_func
(paren
op_amp
id|uts
)paren
suffix:semicolon
id|sym
op_assign
id|sym_lookup
c_func
(paren
l_string|&quot;ARCH&quot;
comma
l_int|0
)paren
suffix:semicolon
id|sym-&gt;type
op_assign
id|S_STRING
suffix:semicolon
id|sym-&gt;flags
op_or_assign
id|SYMBOL_AUTO
suffix:semicolon
id|p
op_assign
id|getenv
c_func
(paren
l_string|&quot;ARCH&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
)paren
id|sym_add_default
c_func
(paren
id|sym
comma
id|p
)paren
suffix:semicolon
id|sym
op_assign
id|sym_lookup
c_func
(paren
l_string|&quot;KERNELRELEASE&quot;
comma
l_int|0
)paren
suffix:semicolon
id|sym-&gt;type
op_assign
id|S_STRING
suffix:semicolon
id|sym-&gt;flags
op_or_assign
id|SYMBOL_AUTO
suffix:semicolon
id|p
op_assign
id|getenv
c_func
(paren
l_string|&quot;KERNELRELEASE&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
)paren
id|sym_add_default
c_func
(paren
id|sym
comma
id|p
)paren
suffix:semicolon
id|sym
op_assign
id|sym_lookup
c_func
(paren
l_string|&quot;UNAME_RELEASE&quot;
comma
l_int|0
)paren
suffix:semicolon
id|sym-&gt;type
op_assign
id|S_STRING
suffix:semicolon
id|sym-&gt;flags
op_or_assign
id|SYMBOL_AUTO
suffix:semicolon
id|sym_add_default
c_func
(paren
id|sym
comma
id|uts.release
)paren
suffix:semicolon
)brace
DECL|function|sym_get_type
r_int
id|sym_get_type
c_func
(paren
r_struct
id|symbol
op_star
id|sym
)paren
(brace
r_int
id|type
op_assign
id|sym-&gt;type
suffix:semicolon
r_if
c_cond
(paren
id|type
op_eq
id|S_TRISTATE
)paren
(brace
r_if
c_cond
(paren
id|sym_is_choice_value
c_func
(paren
id|sym
)paren
op_logical_and
id|sym-&gt;visible
op_eq
id|yes
)paren
id|type
op_assign
id|S_BOOLEAN
suffix:semicolon
r_else
(brace
id|sym_calc_value
c_func
(paren
id|modules_sym
)paren
suffix:semicolon
r_if
c_cond
(paren
id|S_TRI
c_func
(paren
id|modules_sym-&gt;curr
)paren
op_eq
id|no
)paren
id|type
op_assign
id|S_BOOLEAN
suffix:semicolon
)brace
)brace
r_return
id|type
suffix:semicolon
)brace
DECL|function|sym_type_name
r_const
r_char
op_star
id|sym_type_name
c_func
(paren
r_int
id|type
)paren
(brace
r_switch
c_cond
(paren
id|type
)paren
(brace
r_case
id|S_BOOLEAN
suffix:colon
r_return
l_string|&quot;boolean&quot;
suffix:semicolon
r_case
id|S_TRISTATE
suffix:colon
r_return
l_string|&quot;tristate&quot;
suffix:semicolon
r_case
id|S_INT
suffix:colon
r_return
l_string|&quot;integer&quot;
suffix:semicolon
r_case
id|S_HEX
suffix:colon
r_return
l_string|&quot;hex&quot;
suffix:semicolon
r_case
id|S_STRING
suffix:colon
r_return
l_string|&quot;string&quot;
suffix:semicolon
r_case
id|S_UNKNOWN
suffix:colon
r_return
l_string|&quot;unknown&quot;
suffix:semicolon
)brace
r_return
l_string|&quot;???&quot;
suffix:semicolon
)brace
DECL|function|sym_get_choice_prop
r_struct
id|property
op_star
id|sym_get_choice_prop
c_func
(paren
r_struct
id|symbol
op_star
id|sym
)paren
(brace
r_struct
id|property
op_star
id|prop
suffix:semicolon
id|for_all_choices
c_func
(paren
id|sym
comma
id|prop
)paren
r_return
id|prop
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|sym_get_default_prop
r_struct
id|property
op_star
id|sym_get_default_prop
c_func
(paren
r_struct
id|symbol
op_star
id|sym
)paren
(brace
r_struct
id|property
op_star
id|prop
suffix:semicolon
id|tristate
id|visible
suffix:semicolon
id|for_all_defaults
c_func
(paren
id|sym
comma
id|prop
)paren
(brace
id|visible
op_assign
id|E_CALC
c_func
(paren
id|prop-&gt;visible
)paren
suffix:semicolon
r_if
c_cond
(paren
id|visible
op_ne
id|no
)paren
r_return
id|prop
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|sym_calc_visibility
r_void
id|sym_calc_visibility
c_func
(paren
r_struct
id|symbol
op_star
id|sym
)paren
(brace
r_struct
id|property
op_star
id|prop
suffix:semicolon
id|tristate
id|visible
comma
id|oldvisible
suffix:semicolon
multiline_comment|/* any prompt visible? */
id|oldvisible
op_assign
id|sym-&gt;visible
suffix:semicolon
id|visible
op_assign
id|no
suffix:semicolon
id|for_all_prompts
c_func
(paren
id|sym
comma
id|prop
)paren
id|visible
op_assign
id|E_OR
c_func
(paren
id|visible
comma
id|E_CALC
c_func
(paren
id|prop-&gt;visible
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|oldvisible
op_ne
id|visible
)paren
(brace
id|sym-&gt;visible
op_assign
id|visible
suffix:semicolon
id|sym_set_changed
c_func
(paren
id|sym
)paren
suffix:semicolon
)brace
)brace
DECL|function|sym_calc_value
r_void
id|sym_calc_value
c_func
(paren
r_struct
id|symbol
op_star
id|sym
)paren
(brace
r_struct
id|symbol_value
id|newval
comma
id|oldval
suffix:semicolon
r_struct
id|property
op_star
id|prop
comma
op_star
id|def_prop
suffix:semicolon
r_struct
id|symbol
op_star
id|def_sym
suffix:semicolon
r_struct
id|expr
op_star
id|e
suffix:semicolon
r_if
c_cond
(paren
id|sym-&gt;flags
op_amp
id|SYMBOL_VALID
)paren
r_return
suffix:semicolon
id|oldval
op_assign
id|sym-&gt;curr
suffix:semicolon
r_switch
c_cond
(paren
id|sym-&gt;type
)paren
(brace
r_case
id|S_INT
suffix:colon
r_case
id|S_HEX
suffix:colon
r_case
id|S_STRING
suffix:colon
id|newval
op_assign
id|symbol_empty.curr
suffix:semicolon
r_break
suffix:semicolon
r_case
id|S_BOOLEAN
suffix:colon
r_case
id|S_TRISTATE
suffix:colon
id|newval
op_assign
id|symbol_no.curr
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|S_VAL
c_func
(paren
id|newval
)paren
op_assign
id|sym-&gt;name
suffix:semicolon
id|S_TRI
c_func
(paren
id|newval
)paren
op_assign
id|no
suffix:semicolon
r_if
c_cond
(paren
id|sym-&gt;flags
op_amp
id|SYMBOL_CONST
)paren
(brace
r_goto
id|out
suffix:semicolon
)brace
singleline_comment|//newval = symbol_empty.curr;
singleline_comment|// generate warning somewhere here later
singleline_comment|//S_TRI(newval) = yes;
r_goto
id|out
suffix:semicolon
)brace
id|sym-&gt;flags
op_or_assign
id|SYMBOL_VALID
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sym_is_choice_value
c_func
(paren
id|sym
)paren
)paren
id|sym-&gt;flags
op_and_assign
op_complement
id|SYMBOL_WRITE
suffix:semicolon
id|sym_calc_visibility
c_func
(paren
id|sym
)paren
suffix:semicolon
multiline_comment|/* set default if recursively called */
id|sym-&gt;curr
op_assign
id|newval
suffix:semicolon
r_if
c_cond
(paren
id|sym-&gt;visible
op_ne
id|no
)paren
(brace
id|sym-&gt;flags
op_or_assign
id|SYMBOL_WRITE
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sym_has_value
c_func
(paren
id|sym
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|sym_is_choice
c_func
(paren
id|sym
)paren
)paren
(brace
id|prop
op_assign
id|sym_get_default_prop
c_func
(paren
id|sym
)paren
suffix:semicolon
r_if
c_cond
(paren
id|prop
)paren
(brace
id|sym_calc_value
c_func
(paren
id|prop-&gt;def
)paren
suffix:semicolon
id|newval
op_assign
id|prop-&gt;def-&gt;curr
suffix:semicolon
)brace
)brace
r_else
id|S_TRI
c_func
(paren
id|newval
)paren
op_assign
id|S_TRI
c_func
(paren
id|sym-&gt;def
)paren
suffix:semicolon
)brace
r_else
id|newval
op_assign
id|sym-&gt;def
suffix:semicolon
id|S_TRI
c_func
(paren
id|newval
)paren
op_assign
id|E_AND
c_func
(paren
id|S_TRI
c_func
(paren
id|newval
)paren
comma
id|sym-&gt;visible
)paren
suffix:semicolon
multiline_comment|/* if the symbol is visible and not optionial,&n;&t;&t; * possibly ignore old user choice. */
r_if
c_cond
(paren
op_logical_neg
id|sym_is_optional
c_func
(paren
id|sym
)paren
op_logical_and
id|S_TRI
c_func
(paren
id|newval
)paren
op_eq
id|no
)paren
id|S_TRI
c_func
(paren
id|newval
)paren
op_assign
id|sym-&gt;visible
suffix:semicolon
r_if
c_cond
(paren
id|sym_is_choice_value
c_func
(paren
id|sym
)paren
op_logical_and
id|sym-&gt;visible
op_eq
id|yes
)paren
(brace
id|prop
op_assign
id|sym_get_choice_prop
c_func
(paren
id|sym
)paren
suffix:semicolon
id|S_TRI
c_func
(paren
id|newval
)paren
op_assign
(paren
id|S_VAL
c_func
(paren
id|prop-&gt;def-&gt;curr
)paren
op_eq
id|sym
)paren
ques
c_cond
id|yes
suffix:colon
id|no
suffix:semicolon
)brace
)brace
r_else
(brace
id|prop
op_assign
id|sym_get_default_prop
c_func
(paren
id|sym
)paren
suffix:semicolon
r_if
c_cond
(paren
id|prop
)paren
(brace
id|sym-&gt;flags
op_or_assign
id|SYMBOL_WRITE
suffix:semicolon
id|sym_calc_value
c_func
(paren
id|prop-&gt;def
)paren
suffix:semicolon
id|newval
op_assign
id|prop-&gt;def-&gt;curr
suffix:semicolon
)brace
)brace
r_switch
c_cond
(paren
id|sym_get_type
c_func
(paren
id|sym
)paren
)paren
(brace
r_case
id|S_TRISTATE
suffix:colon
r_if
c_cond
(paren
id|S_TRI
c_func
(paren
id|newval
)paren
op_ne
id|mod
)paren
r_break
suffix:semicolon
id|sym_calc_value
c_func
(paren
id|modules_sym
)paren
suffix:semicolon
r_if
c_cond
(paren
id|S_TRI
c_func
(paren
id|modules_sym-&gt;curr
)paren
op_eq
id|no
)paren
id|S_TRI
c_func
(paren
id|newval
)paren
op_assign
id|yes
suffix:semicolon
r_break
suffix:semicolon
r_case
id|S_BOOLEAN
suffix:colon
r_if
c_cond
(paren
id|S_TRI
c_func
(paren
id|newval
)paren
op_eq
id|mod
)paren
id|S_TRI
c_func
(paren
id|newval
)paren
op_assign
id|yes
suffix:semicolon
)brace
id|out
suffix:colon
id|sym-&gt;curr
op_assign
id|newval
suffix:semicolon
r_if
c_cond
(paren
id|sym_is_choice
c_func
(paren
id|sym
)paren
op_logical_and
id|S_TRI
c_func
(paren
id|newval
)paren
op_eq
id|yes
)paren
(brace
id|def_sym
op_assign
id|S_VAL
c_func
(paren
id|sym-&gt;def
)paren
suffix:semicolon
r_if
c_cond
(paren
id|def_sym
)paren
(brace
id|sym_calc_visibility
c_func
(paren
id|def_sym
)paren
suffix:semicolon
r_if
c_cond
(paren
id|def_sym-&gt;visible
op_eq
id|no
)paren
id|def_sym
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|def_sym
)paren
(brace
id|for_all_defaults
c_func
(paren
id|sym
comma
id|def_prop
)paren
(brace
r_if
c_cond
(paren
id|E_CALC
c_func
(paren
id|def_prop-&gt;visible
)paren
op_eq
id|no
)paren
r_continue
suffix:semicolon
id|sym_calc_visibility
c_func
(paren
id|def_prop-&gt;def
)paren
suffix:semicolon
r_if
c_cond
(paren
id|def_prop-&gt;def-&gt;visible
op_ne
id|no
)paren
(brace
id|def_sym
op_assign
id|def_prop-&gt;def
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|def_sym
)paren
(brace
id|prop
op_assign
id|sym_get_choice_prop
c_func
(paren
id|sym
)paren
suffix:semicolon
r_for
c_loop
(paren
id|e
op_assign
id|prop-&gt;dep
suffix:semicolon
id|e
suffix:semicolon
id|e
op_assign
id|e-&gt;left.expr
)paren
(brace
id|sym_calc_visibility
c_func
(paren
id|e-&gt;right.sym
)paren
suffix:semicolon
r_if
c_cond
(paren
id|e-&gt;right.sym-&gt;visible
op_ne
id|no
)paren
(brace
id|def_sym
op_assign
id|e-&gt;right.sym
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
id|S_VAL
c_func
(paren
id|newval
)paren
op_assign
id|def_sym
suffix:semicolon
)brace
r_if
c_cond
(paren
id|memcmp
c_func
(paren
op_amp
id|oldval
comma
op_amp
id|newval
comma
r_sizeof
(paren
id|newval
)paren
)paren
)paren
id|sym_set_changed
c_func
(paren
id|sym
)paren
suffix:semicolon
id|sym-&gt;curr
op_assign
id|newval
suffix:semicolon
r_if
c_cond
(paren
id|sym_is_choice
c_func
(paren
id|sym
)paren
)paren
(brace
r_int
id|flags
op_assign
id|sym-&gt;flags
op_amp
(paren
id|SYMBOL_CHANGED
op_or
id|SYMBOL_WRITE
)paren
suffix:semicolon
id|prop
op_assign
id|sym_get_choice_prop
c_func
(paren
id|sym
)paren
suffix:semicolon
r_for
c_loop
(paren
id|e
op_assign
id|prop-&gt;dep
suffix:semicolon
id|e
suffix:semicolon
id|e
op_assign
id|e-&gt;left.expr
)paren
(brace
id|e-&gt;right.sym-&gt;flags
op_or_assign
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|SYMBOL_CHANGED
)paren
id|sym_set_changed
c_func
(paren
id|e-&gt;right.sym
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|function|sym_clear_all_valid
r_void
id|sym_clear_all_valid
c_func
(paren
r_void
)paren
(brace
r_struct
id|symbol
op_star
id|sym
suffix:semicolon
r_int
id|i
suffix:semicolon
id|for_all_symbols
c_func
(paren
id|i
comma
id|sym
)paren
id|sym-&gt;flags
op_and_assign
op_complement
id|SYMBOL_VALID
suffix:semicolon
id|sym_change_count
op_increment
suffix:semicolon
)brace
DECL|function|sym_set_changed
r_void
id|sym_set_changed
c_func
(paren
r_struct
id|symbol
op_star
id|sym
)paren
(brace
r_struct
id|property
op_star
id|prop
suffix:semicolon
id|sym-&gt;flags
op_or_assign
id|SYMBOL_CHANGED
suffix:semicolon
r_for
c_loop
(paren
id|prop
op_assign
id|sym-&gt;prop
suffix:semicolon
id|prop
suffix:semicolon
id|prop
op_assign
id|prop-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|prop-&gt;menu
)paren
id|prop-&gt;menu-&gt;flags
op_or_assign
id|MENU_CHANGED
suffix:semicolon
)brace
)brace
DECL|function|sym_set_all_changed
r_void
id|sym_set_all_changed
c_func
(paren
r_void
)paren
(brace
r_struct
id|symbol
op_star
id|sym
suffix:semicolon
r_int
id|i
suffix:semicolon
id|for_all_symbols
c_func
(paren
id|i
comma
id|sym
)paren
id|sym_set_changed
c_func
(paren
id|sym
)paren
suffix:semicolon
)brace
DECL|function|sym_tristate_within_range
r_bool
id|sym_tristate_within_range
c_func
(paren
r_struct
id|symbol
op_star
id|sym
comma
id|tristate
id|val
)paren
(brace
r_int
id|type
op_assign
id|sym_get_type
c_func
(paren
id|sym
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sym-&gt;visible
op_eq
id|no
)paren
r_return
l_bool|false
suffix:semicolon
r_if
c_cond
(paren
id|type
op_ne
id|S_BOOLEAN
op_logical_and
id|type
op_ne
id|S_TRISTATE
)paren
r_return
l_bool|false
suffix:semicolon
r_switch
c_cond
(paren
id|val
)paren
(brace
r_case
id|no
suffix:colon
r_if
c_cond
(paren
id|sym_is_choice_value
c_func
(paren
id|sym
)paren
op_logical_and
id|sym-&gt;visible
op_eq
id|yes
)paren
r_return
l_bool|false
suffix:semicolon
r_return
id|sym_is_optional
c_func
(paren
id|sym
)paren
suffix:semicolon
r_case
id|mod
suffix:colon
r_if
c_cond
(paren
id|sym_is_choice_value
c_func
(paren
id|sym
)paren
op_logical_and
id|sym-&gt;visible
op_eq
id|yes
)paren
r_return
l_bool|false
suffix:semicolon
r_return
id|type
op_eq
id|S_TRISTATE
suffix:semicolon
r_case
id|yes
suffix:colon
r_return
id|type
op_eq
id|S_BOOLEAN
op_logical_or
id|sym-&gt;visible
op_eq
id|yes
suffix:semicolon
)brace
r_return
l_bool|false
suffix:semicolon
)brace
DECL|function|sym_set_tristate_value
r_bool
id|sym_set_tristate_value
c_func
(paren
r_struct
id|symbol
op_star
id|sym
comma
id|tristate
id|val
)paren
(brace
id|tristate
id|oldval
op_assign
id|sym_get_tristate_value
c_func
(paren
id|sym
)paren
suffix:semicolon
r_if
c_cond
(paren
id|oldval
op_ne
id|val
op_logical_and
op_logical_neg
id|sym_tristate_within_range
c_func
(paren
id|sym
comma
id|val
)paren
)paren
r_return
l_bool|false
suffix:semicolon
r_if
c_cond
(paren
id|sym-&gt;flags
op_amp
id|SYMBOL_NEW
)paren
(brace
id|sym-&gt;flags
op_and_assign
op_complement
id|SYMBOL_NEW
suffix:semicolon
id|sym_set_changed
c_func
(paren
id|sym
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sym_is_choice_value
c_func
(paren
id|sym
)paren
op_logical_and
id|val
op_eq
id|yes
)paren
(brace
r_struct
id|property
op_star
id|prop
op_assign
id|sym_get_choice_prop
c_func
(paren
id|sym
)paren
suffix:semicolon
id|S_VAL
c_func
(paren
id|prop-&gt;def-&gt;def
)paren
op_assign
id|sym
suffix:semicolon
id|prop-&gt;def-&gt;flags
op_and_assign
op_complement
id|SYMBOL_NEW
suffix:semicolon
)brace
id|S_TRI
c_func
(paren
id|sym-&gt;def
)paren
op_assign
id|val
suffix:semicolon
r_if
c_cond
(paren
id|oldval
op_ne
id|val
)paren
(brace
id|sym_clear_all_valid
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sym
op_eq
id|modules_sym
)paren
id|sym_set_all_changed
c_func
(paren
)paren
suffix:semicolon
)brace
r_return
l_bool|true
suffix:semicolon
)brace
DECL|function|sym_toggle_tristate_value
id|tristate
id|sym_toggle_tristate_value
c_func
(paren
r_struct
id|symbol
op_star
id|sym
)paren
(brace
id|tristate
id|oldval
comma
id|newval
suffix:semicolon
id|oldval
op_assign
id|newval
op_assign
id|sym_get_tristate_value
c_func
(paren
id|sym
)paren
suffix:semicolon
r_do
(brace
r_switch
c_cond
(paren
id|newval
)paren
(brace
r_case
id|no
suffix:colon
id|newval
op_assign
id|mod
suffix:semicolon
r_break
suffix:semicolon
r_case
id|mod
suffix:colon
id|newval
op_assign
id|yes
suffix:semicolon
r_break
suffix:semicolon
r_case
id|yes
suffix:colon
id|newval
op_assign
id|no
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sym_set_tristate_value
c_func
(paren
id|sym
comma
id|newval
)paren
)paren
r_break
suffix:semicolon
)brace
r_while
c_loop
(paren
id|oldval
op_ne
id|newval
)paren
suffix:semicolon
r_return
id|newval
suffix:semicolon
)brace
DECL|function|sym_string_valid
r_bool
id|sym_string_valid
c_func
(paren
r_struct
id|symbol
op_star
id|sym
comma
r_const
r_char
op_star
id|str
)paren
(brace
r_char
id|ch
suffix:semicolon
r_switch
c_cond
(paren
id|sym-&gt;type
)paren
(brace
r_case
id|S_STRING
suffix:colon
r_return
l_bool|true
suffix:semicolon
r_case
id|S_INT
suffix:colon
id|ch
op_assign
op_star
id|str
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|ch
op_eq
l_char|&squot;-&squot;
)paren
id|ch
op_assign
op_star
id|str
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|isdigit
c_func
(paren
id|ch
)paren
)paren
r_return
l_bool|false
suffix:semicolon
r_if
c_cond
(paren
id|ch
op_eq
l_char|&squot;0&squot;
op_logical_and
op_star
id|str
op_ne
l_int|0
)paren
r_return
l_bool|false
suffix:semicolon
r_while
c_loop
(paren
(paren
id|ch
op_assign
op_star
id|str
op_increment
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|isdigit
c_func
(paren
id|ch
)paren
)paren
r_return
l_bool|false
suffix:semicolon
)brace
r_return
l_bool|true
suffix:semicolon
r_case
id|S_HEX
suffix:colon
r_if
c_cond
(paren
id|str
(braket
l_int|0
)braket
op_eq
l_char|&squot;0&squot;
op_logical_and
(paren
id|str
(braket
l_int|1
)braket
op_eq
l_char|&squot;x&squot;
op_logical_or
id|str
(braket
l_int|1
)braket
op_eq
l_char|&squot;X&squot;
)paren
)paren
id|str
op_add_assign
l_int|2
suffix:semicolon
id|ch
op_assign
op_star
id|str
op_increment
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
op_logical_neg
id|isxdigit
c_func
(paren
id|ch
)paren
)paren
r_return
l_bool|false
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|ch
op_assign
op_star
id|str
op_increment
)paren
)paren
suffix:semicolon
r_return
l_bool|true
suffix:semicolon
r_case
id|S_BOOLEAN
suffix:colon
r_case
id|S_TRISTATE
suffix:colon
r_switch
c_cond
(paren
id|str
(braket
l_int|0
)braket
)paren
(brace
r_case
l_char|&squot;y&squot;
suffix:colon
r_case
l_char|&squot;Y&squot;
suffix:colon
r_return
id|sym_tristate_within_range
c_func
(paren
id|sym
comma
id|yes
)paren
suffix:semicolon
r_case
l_char|&squot;m&squot;
suffix:colon
r_case
l_char|&squot;M&squot;
suffix:colon
r_return
id|sym_tristate_within_range
c_func
(paren
id|sym
comma
id|mod
)paren
suffix:semicolon
r_case
l_char|&squot;n&squot;
suffix:colon
r_case
l_char|&squot;N&squot;
suffix:colon
r_return
id|sym_tristate_within_range
c_func
(paren
id|sym
comma
id|no
)paren
suffix:semicolon
)brace
r_return
l_bool|false
suffix:semicolon
r_default
suffix:colon
r_return
l_bool|false
suffix:semicolon
)brace
)brace
DECL|function|sym_set_string_value
r_bool
id|sym_set_string_value
c_func
(paren
r_struct
id|symbol
op_star
id|sym
comma
r_const
r_char
op_star
id|newval
)paren
(brace
r_const
r_char
op_star
id|oldval
suffix:semicolon
r_char
op_star
id|val
suffix:semicolon
r_int
id|size
suffix:semicolon
r_switch
c_cond
(paren
id|sym-&gt;type
)paren
(brace
r_case
id|S_BOOLEAN
suffix:colon
r_case
id|S_TRISTATE
suffix:colon
r_switch
c_cond
(paren
id|newval
(braket
l_int|0
)braket
)paren
(brace
r_case
l_char|&squot;y&squot;
suffix:colon
r_case
l_char|&squot;Y&squot;
suffix:colon
r_return
id|sym_set_tristate_value
c_func
(paren
id|sym
comma
id|yes
)paren
suffix:semicolon
r_case
l_char|&squot;m&squot;
suffix:colon
r_case
l_char|&squot;M&squot;
suffix:colon
r_return
id|sym_set_tristate_value
c_func
(paren
id|sym
comma
id|mod
)paren
suffix:semicolon
r_case
l_char|&squot;n&squot;
suffix:colon
r_case
l_char|&squot;N&squot;
suffix:colon
r_return
id|sym_set_tristate_value
c_func
(paren
id|sym
comma
id|no
)paren
suffix:semicolon
)brace
r_return
l_bool|false
suffix:semicolon
r_default
suffix:colon
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|sym_string_valid
c_func
(paren
id|sym
comma
id|newval
)paren
)paren
r_return
l_bool|false
suffix:semicolon
r_if
c_cond
(paren
id|sym-&gt;flags
op_amp
id|SYMBOL_NEW
)paren
(brace
id|sym-&gt;flags
op_and_assign
op_complement
id|SYMBOL_NEW
suffix:semicolon
id|sym_set_changed
c_func
(paren
id|sym
)paren
suffix:semicolon
)brace
id|oldval
op_assign
id|S_VAL
c_func
(paren
id|sym-&gt;def
)paren
suffix:semicolon
id|size
op_assign
id|strlen
c_func
(paren
id|newval
)paren
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|sym-&gt;type
op_eq
id|S_HEX
op_logical_and
(paren
id|newval
(braket
l_int|0
)braket
op_ne
l_char|&squot;0&squot;
op_logical_or
(paren
id|newval
(braket
l_int|1
)braket
op_ne
l_char|&squot;x&squot;
op_logical_and
id|newval
(braket
l_int|1
)braket
op_ne
l_char|&squot;X&squot;
)paren
)paren
)paren
(brace
id|size
op_add_assign
l_int|2
suffix:semicolon
id|S_VAL
c_func
(paren
id|sym-&gt;def
)paren
op_assign
id|val
op_assign
id|malloc
c_func
(paren
id|size
)paren
suffix:semicolon
op_star
id|val
op_increment
op_assign
l_char|&squot;0&squot;
suffix:semicolon
op_star
id|val
op_increment
op_assign
l_char|&squot;x&squot;
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|oldval
op_logical_or
id|strcmp
c_func
(paren
id|oldval
comma
id|newval
)paren
)paren
id|S_VAL
c_func
(paren
id|sym-&gt;def
)paren
op_assign
id|val
op_assign
id|malloc
c_func
(paren
id|size
)paren
suffix:semicolon
r_else
r_return
l_bool|true
suffix:semicolon
id|strcpy
c_func
(paren
id|val
comma
id|newval
)paren
suffix:semicolon
id|free
c_func
(paren
(paren
r_void
op_star
)paren
id|oldval
)paren
suffix:semicolon
id|sym_clear_all_valid
c_func
(paren
)paren
suffix:semicolon
r_return
l_bool|true
suffix:semicolon
)brace
DECL|function|sym_get_string_value
r_const
r_char
op_star
id|sym_get_string_value
c_func
(paren
r_struct
id|symbol
op_star
id|sym
)paren
(brace
id|tristate
id|val
suffix:semicolon
r_switch
c_cond
(paren
id|sym-&gt;type
)paren
(brace
r_case
id|S_BOOLEAN
suffix:colon
r_case
id|S_TRISTATE
suffix:colon
id|val
op_assign
id|sym_get_tristate_value
c_func
(paren
id|sym
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|val
)paren
(brace
r_case
id|no
suffix:colon
r_return
l_string|&quot;n&quot;
suffix:semicolon
r_case
id|mod
suffix:colon
r_return
l_string|&quot;m&quot;
suffix:semicolon
r_case
id|yes
suffix:colon
r_return
l_string|&quot;y&quot;
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
suffix:semicolon
)brace
r_return
(paren
r_const
r_char
op_star
)paren
id|S_VAL
c_func
(paren
id|sym-&gt;curr
)paren
suffix:semicolon
)brace
DECL|function|sym_is_changable
r_bool
id|sym_is_changable
c_func
(paren
r_struct
id|symbol
op_star
id|sym
)paren
(brace
r_if
c_cond
(paren
id|sym-&gt;visible
op_eq
id|no
)paren
r_return
l_bool|false
suffix:semicolon
multiline_comment|/* at least &squot;n&squot; and &squot;y&squot;/&squot;m&squot; is selectable */
r_if
c_cond
(paren
id|sym_is_optional
c_func
(paren
id|sym
)paren
)paren
r_return
l_bool|true
suffix:semicolon
multiline_comment|/* no &squot;n&squot;, so &squot;y&squot; and &squot;m&squot; must be selectable */
r_if
c_cond
(paren
id|sym_get_type
c_func
(paren
id|sym
)paren
op_eq
id|S_TRISTATE
op_logical_and
id|sym-&gt;visible
op_eq
id|yes
)paren
r_return
l_bool|true
suffix:semicolon
r_return
l_bool|false
suffix:semicolon
)brace
DECL|function|sym_lookup
r_struct
id|symbol
op_star
id|sym_lookup
c_func
(paren
r_const
r_char
op_star
id|name
comma
r_int
id|isconst
)paren
(brace
r_struct
id|symbol
op_star
id|symbol
suffix:semicolon
r_const
r_char
op_star
id|ptr
suffix:semicolon
r_char
op_star
id|new_name
suffix:semicolon
r_int
id|hash
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|name
)paren
(brace
r_if
c_cond
(paren
id|name
(braket
l_int|0
)braket
op_logical_and
op_logical_neg
id|name
(braket
l_int|1
)braket
)paren
(brace
r_switch
c_cond
(paren
id|name
(braket
l_int|0
)braket
)paren
(brace
r_case
l_char|&squot;y&squot;
suffix:colon
r_return
op_amp
id|symbol_yes
suffix:semicolon
r_case
l_char|&squot;m&squot;
suffix:colon
r_return
op_amp
id|symbol_mod
suffix:semicolon
r_case
l_char|&squot;n&squot;
suffix:colon
r_return
op_amp
id|symbol_no
suffix:semicolon
)brace
)brace
r_for
c_loop
(paren
id|ptr
op_assign
id|name
suffix:semicolon
op_star
id|ptr
suffix:semicolon
id|ptr
op_increment
)paren
id|hash
op_add_assign
op_star
id|ptr
suffix:semicolon
id|hash
op_and_assign
l_int|0xff
suffix:semicolon
r_for
c_loop
(paren
id|symbol
op_assign
id|symbol_hash
(braket
id|hash
)braket
suffix:semicolon
id|symbol
suffix:semicolon
id|symbol
op_assign
id|symbol-&gt;next
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|symbol-&gt;name
comma
id|name
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|isconst
op_logical_and
id|symbol-&gt;flags
op_amp
id|SYMBOL_CONST
)paren
op_logical_or
(paren
op_logical_neg
id|isconst
op_logical_and
op_logical_neg
(paren
id|symbol-&gt;flags
op_amp
id|SYMBOL_CONST
)paren
)paren
)paren
r_return
id|symbol
suffix:semicolon
)brace
)brace
id|new_name
op_assign
id|strdup
c_func
(paren
id|name
)paren
suffix:semicolon
)brace
r_else
(brace
id|new_name
op_assign
l_int|NULL
suffix:semicolon
id|hash
op_assign
l_int|256
suffix:semicolon
)brace
id|symbol
op_assign
id|malloc
c_func
(paren
r_sizeof
(paren
op_star
id|symbol
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|symbol
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|symbol
)paren
)paren
suffix:semicolon
id|symbol-&gt;name
op_assign
id|new_name
suffix:semicolon
id|symbol-&gt;type
op_assign
id|S_UNKNOWN
suffix:semicolon
id|symbol-&gt;flags
op_assign
id|SYMBOL_NEW
suffix:semicolon
r_if
c_cond
(paren
id|isconst
)paren
id|symbol-&gt;flags
op_or_assign
id|SYMBOL_CONST
suffix:semicolon
id|symbol-&gt;next
op_assign
id|symbol_hash
(braket
id|hash
)braket
suffix:semicolon
id|symbol_hash
(braket
id|hash
)braket
op_assign
id|symbol
suffix:semicolon
r_return
id|symbol
suffix:semicolon
)brace
DECL|function|sym_find
r_struct
id|symbol
op_star
id|sym_find
c_func
(paren
r_const
r_char
op_star
id|name
)paren
(brace
r_struct
id|symbol
op_star
id|symbol
op_assign
l_int|NULL
suffix:semicolon
r_const
r_char
op_star
id|ptr
suffix:semicolon
r_int
id|hash
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|name
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|name
(braket
l_int|0
)braket
op_logical_and
op_logical_neg
id|name
(braket
l_int|1
)braket
)paren
(brace
r_switch
c_cond
(paren
id|name
(braket
l_int|0
)braket
)paren
(brace
r_case
l_char|&squot;y&squot;
suffix:colon
r_return
op_amp
id|symbol_yes
suffix:semicolon
r_case
l_char|&squot;m&squot;
suffix:colon
r_return
op_amp
id|symbol_mod
suffix:semicolon
r_case
l_char|&squot;n&squot;
suffix:colon
r_return
op_amp
id|symbol_no
suffix:semicolon
)brace
)brace
r_for
c_loop
(paren
id|ptr
op_assign
id|name
suffix:semicolon
op_star
id|ptr
suffix:semicolon
id|ptr
op_increment
)paren
id|hash
op_add_assign
op_star
id|ptr
suffix:semicolon
id|hash
op_and_assign
l_int|0xff
suffix:semicolon
r_for
c_loop
(paren
id|symbol
op_assign
id|symbol_hash
(braket
id|hash
)braket
suffix:semicolon
id|symbol
suffix:semicolon
id|symbol
op_assign
id|symbol-&gt;next
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|symbol-&gt;name
comma
id|name
)paren
op_logical_and
op_logical_neg
(paren
id|symbol-&gt;flags
op_amp
id|SYMBOL_CONST
)paren
)paren
r_break
suffix:semicolon
)brace
r_return
id|symbol
suffix:semicolon
)brace
DECL|function|prop_get_type_name
r_const
r_char
op_star
id|prop_get_type_name
c_func
(paren
r_enum
id|prop_type
id|type
)paren
(brace
r_switch
c_cond
(paren
id|type
)paren
(brace
r_case
id|P_PROMPT
suffix:colon
r_return
l_string|&quot;prompt&quot;
suffix:semicolon
r_case
id|P_COMMENT
suffix:colon
r_return
l_string|&quot;comment&quot;
suffix:semicolon
r_case
id|P_MENU
suffix:colon
r_return
l_string|&quot;menu&quot;
suffix:semicolon
r_case
id|P_ROOTMENU
suffix:colon
r_return
l_string|&quot;rootmenu&quot;
suffix:semicolon
r_case
id|P_DEFAULT
suffix:colon
r_return
l_string|&quot;default&quot;
suffix:semicolon
r_case
id|P_CHOICE
suffix:colon
r_return
l_string|&quot;choice&quot;
suffix:semicolon
r_default
suffix:colon
r_return
l_string|&quot;unknown&quot;
suffix:semicolon
)brace
)brace
eof
