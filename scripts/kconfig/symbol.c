multiline_comment|/*&n; * Copyright (C) 2002 Roman Zippel &lt;zippel@linux-m68k.org&gt;&n; * Released under the terms of the GNU GPL v2.0.&n; */
macro_line|#include &lt;ctype.h&gt;
macro_line|#include &lt;stdlib.h&gt;
macro_line|#include &lt;string.h&gt;
macro_line|#include &lt;regex.h&gt;
macro_line|#include &lt;sys/utsname.h&gt;
DECL|macro|LKC_DIRECT_LINK
mdefine_line|#define LKC_DIRECT_LINK
macro_line|#include &quot;lkc.h&quot;
DECL|variable|symbol_yes
r_struct
id|symbol
id|symbol_yes
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;y&quot;
comma
dot
id|curr
op_assign
(brace
l_string|&quot;y&quot;
comma
id|yes
)brace
comma
dot
id|flags
op_assign
id|SYMBOL_YES
op_or
id|SYMBOL_VALID
comma
DECL|variable|symbol_mod
)brace
comma
id|symbol_mod
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;m&quot;
comma
dot
id|curr
op_assign
(brace
l_string|&quot;m&quot;
comma
id|mod
)brace
comma
dot
id|flags
op_assign
id|SYMBOL_MOD
op_or
id|SYMBOL_VALID
comma
DECL|variable|symbol_no
)brace
comma
id|symbol_no
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;n&quot;
comma
dot
id|curr
op_assign
(brace
l_string|&quot;n&quot;
comma
id|no
)brace
comma
dot
id|flags
op_assign
id|SYMBOL_NO
op_or
id|SYMBOL_VALID
comma
DECL|variable|symbol_empty
)brace
comma
id|symbol_empty
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;&quot;
comma
dot
id|curr
op_assign
(brace
l_string|&quot;&quot;
comma
id|no
)brace
comma
dot
id|flags
op_assign
id|SYMBOL_VALID
comma
)brace
suffix:semicolon
DECL|variable|sym_change_count
r_int
id|sym_change_count
suffix:semicolon
DECL|variable|modules_sym
r_struct
id|symbol
op_star
id|modules_sym
suffix:semicolon
DECL|variable|modules_val
id|tristate
id|modules_val
suffix:semicolon
DECL|function|sym_add_default
r_void
id|sym_add_default
c_func
(paren
r_struct
id|symbol
op_star
id|sym
comma
r_const
r_char
op_star
id|def
)paren
(brace
r_struct
id|property
op_star
id|prop
op_assign
id|prop_alloc
c_func
(paren
id|P_DEFAULT
comma
id|sym
)paren
suffix:semicolon
id|prop-&gt;expr
op_assign
id|expr_alloc_symbol
c_func
(paren
id|sym_lookup
c_func
(paren
id|def
comma
l_int|1
)paren
)paren
suffix:semicolon
)brace
DECL|function|sym_init
r_void
id|sym_init
c_func
(paren
r_void
)paren
(brace
r_struct
id|symbol
op_star
id|sym
suffix:semicolon
r_struct
id|utsname
id|uts
suffix:semicolon
r_char
op_star
id|p
suffix:semicolon
r_static
r_bool
id|inited
op_assign
l_bool|false
suffix:semicolon
r_if
c_cond
(paren
id|inited
)paren
r_return
suffix:semicolon
id|inited
op_assign
l_bool|true
suffix:semicolon
id|uname
c_func
(paren
op_amp
id|uts
)paren
suffix:semicolon
id|sym
op_assign
id|sym_lookup
c_func
(paren
l_string|&quot;ARCH&quot;
comma
l_int|0
)paren
suffix:semicolon
id|sym-&gt;type
op_assign
id|S_STRING
suffix:semicolon
id|sym-&gt;flags
op_or_assign
id|SYMBOL_AUTO
suffix:semicolon
id|p
op_assign
id|getenv
c_func
(paren
l_string|&quot;ARCH&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
)paren
id|sym_add_default
c_func
(paren
id|sym
comma
id|p
)paren
suffix:semicolon
id|sym
op_assign
id|sym_lookup
c_func
(paren
l_string|&quot;KERNELRELEASE&quot;
comma
l_int|0
)paren
suffix:semicolon
id|sym-&gt;type
op_assign
id|S_STRING
suffix:semicolon
id|sym-&gt;flags
op_or_assign
id|SYMBOL_AUTO
suffix:semicolon
id|p
op_assign
id|getenv
c_func
(paren
l_string|&quot;KERNELRELEASE&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
)paren
id|sym_add_default
c_func
(paren
id|sym
comma
id|p
)paren
suffix:semicolon
id|sym
op_assign
id|sym_lookup
c_func
(paren
l_string|&quot;UNAME_RELEASE&quot;
comma
l_int|0
)paren
suffix:semicolon
id|sym-&gt;type
op_assign
id|S_STRING
suffix:semicolon
id|sym-&gt;flags
op_or_assign
id|SYMBOL_AUTO
suffix:semicolon
id|sym_add_default
c_func
(paren
id|sym
comma
id|uts.release
)paren
suffix:semicolon
)brace
DECL|function|sym_get_type
r_enum
id|symbol_type
id|sym_get_type
c_func
(paren
r_struct
id|symbol
op_star
id|sym
)paren
(brace
r_enum
id|symbol_type
id|type
op_assign
id|sym-&gt;type
suffix:semicolon
r_if
c_cond
(paren
id|type
op_eq
id|S_TRISTATE
)paren
(brace
r_if
c_cond
(paren
id|sym_is_choice_value
c_func
(paren
id|sym
)paren
op_logical_and
id|sym-&gt;visible
op_eq
id|yes
)paren
id|type
op_assign
id|S_BOOLEAN
suffix:semicolon
r_else
r_if
c_cond
(paren
id|modules_val
op_eq
id|no
)paren
id|type
op_assign
id|S_BOOLEAN
suffix:semicolon
)brace
r_return
id|type
suffix:semicolon
)brace
DECL|function|sym_type_name
r_const
r_char
op_star
id|sym_type_name
c_func
(paren
r_enum
id|symbol_type
id|type
)paren
(brace
r_switch
c_cond
(paren
id|type
)paren
(brace
r_case
id|S_BOOLEAN
suffix:colon
r_return
l_string|&quot;boolean&quot;
suffix:semicolon
r_case
id|S_TRISTATE
suffix:colon
r_return
l_string|&quot;tristate&quot;
suffix:semicolon
r_case
id|S_INT
suffix:colon
r_return
l_string|&quot;integer&quot;
suffix:semicolon
r_case
id|S_HEX
suffix:colon
r_return
l_string|&quot;hex&quot;
suffix:semicolon
r_case
id|S_STRING
suffix:colon
r_return
l_string|&quot;string&quot;
suffix:semicolon
r_case
id|S_UNKNOWN
suffix:colon
r_return
l_string|&quot;unknown&quot;
suffix:semicolon
r_case
id|S_OTHER
suffix:colon
r_break
suffix:semicolon
)brace
r_return
l_string|&quot;???&quot;
suffix:semicolon
)brace
DECL|function|sym_get_choice_prop
r_struct
id|property
op_star
id|sym_get_choice_prop
c_func
(paren
r_struct
id|symbol
op_star
id|sym
)paren
(brace
r_struct
id|property
op_star
id|prop
suffix:semicolon
id|for_all_choices
c_func
(paren
id|sym
comma
id|prop
)paren
r_return
id|prop
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|sym_get_default_prop
r_struct
id|property
op_star
id|sym_get_default_prop
c_func
(paren
r_struct
id|symbol
op_star
id|sym
)paren
(brace
r_struct
id|property
op_star
id|prop
suffix:semicolon
id|for_all_defaults
c_func
(paren
id|sym
comma
id|prop
)paren
(brace
id|prop-&gt;visible.tri
op_assign
id|expr_calc_value
c_func
(paren
id|prop-&gt;visible.expr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|prop-&gt;visible.tri
op_ne
id|no
)paren
r_return
id|prop
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|sym_get_range_prop
r_struct
id|property
op_star
id|sym_get_range_prop
c_func
(paren
r_struct
id|symbol
op_star
id|sym
)paren
(brace
r_struct
id|property
op_star
id|prop
suffix:semicolon
id|for_all_properties
c_func
(paren
id|sym
comma
id|prop
comma
id|P_RANGE
)paren
(brace
id|prop-&gt;visible.tri
op_assign
id|expr_calc_value
c_func
(paren
id|prop-&gt;visible.expr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|prop-&gt;visible.tri
op_ne
id|no
)paren
r_return
id|prop
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|sym_calc_visibility
r_static
r_void
id|sym_calc_visibility
c_func
(paren
r_struct
id|symbol
op_star
id|sym
)paren
(brace
r_struct
id|property
op_star
id|prop
suffix:semicolon
id|tristate
id|tri
suffix:semicolon
multiline_comment|/* any prompt visible? */
id|tri
op_assign
id|no
suffix:semicolon
id|for_all_prompts
c_func
(paren
id|sym
comma
id|prop
)paren
(brace
id|prop-&gt;visible.tri
op_assign
id|expr_calc_value
c_func
(paren
id|prop-&gt;visible.expr
)paren
suffix:semicolon
id|tri
op_assign
id|E_OR
c_func
(paren
id|tri
comma
id|prop-&gt;visible.tri
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tri
op_eq
id|mod
op_logical_and
(paren
id|sym-&gt;type
op_ne
id|S_TRISTATE
op_logical_or
id|modules_val
op_eq
id|no
)paren
)paren
id|tri
op_assign
id|yes
suffix:semicolon
r_if
c_cond
(paren
id|sym-&gt;visible
op_ne
id|tri
)paren
(brace
id|sym-&gt;visible
op_assign
id|tri
suffix:semicolon
id|sym_set_changed
c_func
(paren
id|sym
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sym_is_choice_value
c_func
(paren
id|sym
)paren
)paren
r_return
suffix:semicolon
id|tri
op_assign
id|no
suffix:semicolon
r_if
c_cond
(paren
id|sym-&gt;rev_dep.expr
)paren
id|tri
op_assign
id|expr_calc_value
c_func
(paren
id|sym-&gt;rev_dep.expr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tri
op_eq
id|mod
op_logical_and
id|sym_get_type
c_func
(paren
id|sym
)paren
op_eq
id|S_BOOLEAN
)paren
id|tri
op_assign
id|yes
suffix:semicolon
r_if
c_cond
(paren
id|sym-&gt;rev_dep.tri
op_ne
id|tri
)paren
(brace
id|sym-&gt;rev_dep.tri
op_assign
id|tri
suffix:semicolon
id|sym_set_changed
c_func
(paren
id|sym
)paren
suffix:semicolon
)brace
)brace
DECL|function|sym_calc_choice
r_static
r_struct
id|symbol
op_star
id|sym_calc_choice
c_func
(paren
r_struct
id|symbol
op_star
id|sym
)paren
(brace
r_struct
id|symbol
op_star
id|def_sym
suffix:semicolon
r_struct
id|property
op_star
id|prop
suffix:semicolon
r_struct
id|expr
op_star
id|e
suffix:semicolon
multiline_comment|/* is the user choice visible? */
id|def_sym
op_assign
id|sym-&gt;user.val
suffix:semicolon
r_if
c_cond
(paren
id|def_sym
)paren
(brace
id|sym_calc_visibility
c_func
(paren
id|def_sym
)paren
suffix:semicolon
r_if
c_cond
(paren
id|def_sym-&gt;visible
op_ne
id|no
)paren
r_return
id|def_sym
suffix:semicolon
)brace
multiline_comment|/* any of the defaults visible? */
id|for_all_defaults
c_func
(paren
id|sym
comma
id|prop
)paren
(brace
id|prop-&gt;visible.tri
op_assign
id|expr_calc_value
c_func
(paren
id|prop-&gt;visible.expr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|prop-&gt;visible.tri
op_eq
id|no
)paren
r_continue
suffix:semicolon
id|def_sym
op_assign
id|prop_get_symbol
c_func
(paren
id|prop
)paren
suffix:semicolon
id|sym_calc_visibility
c_func
(paren
id|def_sym
)paren
suffix:semicolon
r_if
c_cond
(paren
id|def_sym-&gt;visible
op_ne
id|no
)paren
r_return
id|def_sym
suffix:semicolon
)brace
multiline_comment|/* just get the first visible value */
id|prop
op_assign
id|sym_get_choice_prop
c_func
(paren
id|sym
)paren
suffix:semicolon
r_for
c_loop
(paren
id|e
op_assign
id|prop-&gt;expr
suffix:semicolon
id|e
suffix:semicolon
id|e
op_assign
id|e-&gt;left.expr
)paren
(brace
id|def_sym
op_assign
id|e-&gt;right.sym
suffix:semicolon
id|sym_calc_visibility
c_func
(paren
id|def_sym
)paren
suffix:semicolon
r_if
c_cond
(paren
id|def_sym-&gt;visible
op_ne
id|no
)paren
r_return
id|def_sym
suffix:semicolon
)brace
multiline_comment|/* no choice? reset tristate value */
id|sym-&gt;curr.tri
op_assign
id|no
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|sym_calc_value
r_void
id|sym_calc_value
c_func
(paren
r_struct
id|symbol
op_star
id|sym
)paren
(brace
r_struct
id|symbol_value
id|newval
comma
id|oldval
suffix:semicolon
r_struct
id|property
op_star
id|prop
suffix:semicolon
r_struct
id|expr
op_star
id|e
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sym
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|sym-&gt;flags
op_amp
id|SYMBOL_VALID
)paren
r_return
suffix:semicolon
id|sym-&gt;flags
op_or_assign
id|SYMBOL_VALID
suffix:semicolon
id|oldval
op_assign
id|sym-&gt;curr
suffix:semicolon
r_switch
c_cond
(paren
id|sym-&gt;type
)paren
(brace
r_case
id|S_INT
suffix:colon
r_case
id|S_HEX
suffix:colon
r_case
id|S_STRING
suffix:colon
id|newval
op_assign
id|symbol_empty.curr
suffix:semicolon
r_break
suffix:semicolon
r_case
id|S_BOOLEAN
suffix:colon
r_case
id|S_TRISTATE
suffix:colon
id|newval
op_assign
id|symbol_no.curr
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|sym-&gt;curr.val
op_assign
id|sym-&gt;name
suffix:semicolon
id|sym-&gt;curr.tri
op_assign
id|no
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|sym_is_choice_value
c_func
(paren
id|sym
)paren
)paren
id|sym-&gt;flags
op_and_assign
op_complement
id|SYMBOL_WRITE
suffix:semicolon
id|sym_calc_visibility
c_func
(paren
id|sym
)paren
suffix:semicolon
multiline_comment|/* set default if recursively called */
id|sym-&gt;curr
op_assign
id|newval
suffix:semicolon
r_switch
c_cond
(paren
id|sym_get_type
c_func
(paren
id|sym
)paren
)paren
(brace
r_case
id|S_BOOLEAN
suffix:colon
r_case
id|S_TRISTATE
suffix:colon
r_if
c_cond
(paren
id|sym_is_choice_value
c_func
(paren
id|sym
)paren
op_logical_and
id|sym-&gt;visible
op_eq
id|yes
)paren
(brace
id|prop
op_assign
id|sym_get_choice_prop
c_func
(paren
id|sym
)paren
suffix:semicolon
id|newval.tri
op_assign
(paren
id|prop_get_symbol
c_func
(paren
id|prop
)paren
op_member_access_from_pointer
id|curr.val
op_eq
id|sym
)paren
ques
c_cond
id|yes
suffix:colon
id|no
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|E_OR
c_func
(paren
id|sym-&gt;visible
comma
id|sym-&gt;rev_dep.tri
)paren
op_ne
id|no
)paren
(brace
id|sym-&gt;flags
op_or_assign
id|SYMBOL_WRITE
suffix:semicolon
r_if
c_cond
(paren
id|sym_has_value
c_func
(paren
id|sym
)paren
)paren
id|newval.tri
op_assign
id|sym-&gt;user.tri
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|sym_is_choice
c_func
(paren
id|sym
)paren
)paren
(brace
id|prop
op_assign
id|sym_get_default_prop
c_func
(paren
id|sym
)paren
suffix:semicolon
r_if
c_cond
(paren
id|prop
)paren
id|newval.tri
op_assign
id|expr_calc_value
c_func
(paren
id|prop-&gt;expr
)paren
suffix:semicolon
)brace
id|newval.tri
op_assign
id|E_OR
c_func
(paren
id|E_AND
c_func
(paren
id|newval.tri
comma
id|sym-&gt;visible
)paren
comma
id|sym-&gt;rev_dep.tri
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|sym_is_choice
c_func
(paren
id|sym
)paren
)paren
(brace
id|prop
op_assign
id|sym_get_default_prop
c_func
(paren
id|sym
)paren
suffix:semicolon
r_if
c_cond
(paren
id|prop
)paren
(brace
id|sym-&gt;flags
op_or_assign
id|SYMBOL_WRITE
suffix:semicolon
id|newval.tri
op_assign
id|expr_calc_value
c_func
(paren
id|prop-&gt;expr
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|newval.tri
op_eq
id|mod
op_logical_and
id|sym_get_type
c_func
(paren
id|sym
)paren
op_eq
id|S_BOOLEAN
)paren
id|newval.tri
op_assign
id|yes
suffix:semicolon
r_break
suffix:semicolon
r_case
id|S_STRING
suffix:colon
r_case
id|S_HEX
suffix:colon
r_case
id|S_INT
suffix:colon
r_if
c_cond
(paren
id|sym-&gt;visible
op_ne
id|no
)paren
(brace
id|sym-&gt;flags
op_or_assign
id|SYMBOL_WRITE
suffix:semicolon
r_if
c_cond
(paren
id|sym_has_value
c_func
(paren
id|sym
)paren
)paren
(brace
id|newval.val
op_assign
id|sym-&gt;user.val
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|prop
op_assign
id|sym_get_default_prop
c_func
(paren
id|sym
)paren
suffix:semicolon
r_if
c_cond
(paren
id|prop
)paren
(brace
r_struct
id|symbol
op_star
id|ds
op_assign
id|prop_get_symbol
c_func
(paren
id|prop
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ds
)paren
(brace
id|sym-&gt;flags
op_or_assign
id|SYMBOL_WRITE
suffix:semicolon
id|sym_calc_value
c_func
(paren
id|ds
)paren
suffix:semicolon
id|newval.val
op_assign
id|ds-&gt;curr.val
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
r_default
suffix:colon
suffix:semicolon
)brace
id|sym-&gt;curr
op_assign
id|newval
suffix:semicolon
r_if
c_cond
(paren
id|sym_is_choice
c_func
(paren
id|sym
)paren
op_logical_and
id|newval.tri
op_eq
id|yes
)paren
id|sym-&gt;curr.val
op_assign
id|sym_calc_choice
c_func
(paren
id|sym
)paren
suffix:semicolon
r_if
c_cond
(paren
id|memcmp
c_func
(paren
op_amp
id|oldval
comma
op_amp
id|sym-&gt;curr
comma
r_sizeof
(paren
id|oldval
)paren
)paren
)paren
id|sym_set_changed
c_func
(paren
id|sym
)paren
suffix:semicolon
r_if
c_cond
(paren
id|modules_sym
op_eq
id|sym
)paren
id|modules_val
op_assign
id|modules_sym-&gt;curr.tri
suffix:semicolon
r_if
c_cond
(paren
id|sym_is_choice
c_func
(paren
id|sym
)paren
)paren
(brace
r_int
id|flags
op_assign
id|sym-&gt;flags
op_amp
(paren
id|SYMBOL_CHANGED
op_or
id|SYMBOL_WRITE
)paren
suffix:semicolon
id|prop
op_assign
id|sym_get_choice_prop
c_func
(paren
id|sym
)paren
suffix:semicolon
r_for
c_loop
(paren
id|e
op_assign
id|prop-&gt;expr
suffix:semicolon
id|e
suffix:semicolon
id|e
op_assign
id|e-&gt;left.expr
)paren
(brace
id|e-&gt;right.sym-&gt;flags
op_or_assign
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|SYMBOL_CHANGED
)paren
id|sym_set_changed
c_func
(paren
id|e-&gt;right.sym
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|function|sym_clear_all_valid
r_void
id|sym_clear_all_valid
c_func
(paren
r_void
)paren
(brace
r_struct
id|symbol
op_star
id|sym
suffix:semicolon
r_int
id|i
suffix:semicolon
id|for_all_symbols
c_func
(paren
id|i
comma
id|sym
)paren
id|sym-&gt;flags
op_and_assign
op_complement
id|SYMBOL_VALID
suffix:semicolon
id|sym_change_count
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|modules_sym
)paren
id|sym_calc_value
c_func
(paren
id|modules_sym
)paren
suffix:semicolon
)brace
DECL|function|sym_set_changed
r_void
id|sym_set_changed
c_func
(paren
r_struct
id|symbol
op_star
id|sym
)paren
(brace
r_struct
id|property
op_star
id|prop
suffix:semicolon
id|sym-&gt;flags
op_or_assign
id|SYMBOL_CHANGED
suffix:semicolon
r_for
c_loop
(paren
id|prop
op_assign
id|sym-&gt;prop
suffix:semicolon
id|prop
suffix:semicolon
id|prop
op_assign
id|prop-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|prop-&gt;menu
)paren
id|prop-&gt;menu-&gt;flags
op_or_assign
id|MENU_CHANGED
suffix:semicolon
)brace
)brace
DECL|function|sym_set_all_changed
r_void
id|sym_set_all_changed
c_func
(paren
r_void
)paren
(brace
r_struct
id|symbol
op_star
id|sym
suffix:semicolon
r_int
id|i
suffix:semicolon
id|for_all_symbols
c_func
(paren
id|i
comma
id|sym
)paren
id|sym_set_changed
c_func
(paren
id|sym
)paren
suffix:semicolon
)brace
DECL|function|sym_tristate_within_range
r_bool
id|sym_tristate_within_range
c_func
(paren
r_struct
id|symbol
op_star
id|sym
comma
id|tristate
id|val
)paren
(brace
r_int
id|type
op_assign
id|sym_get_type
c_func
(paren
id|sym
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sym-&gt;visible
op_eq
id|no
)paren
r_return
l_bool|false
suffix:semicolon
r_if
c_cond
(paren
id|type
op_ne
id|S_BOOLEAN
op_logical_and
id|type
op_ne
id|S_TRISTATE
)paren
r_return
l_bool|false
suffix:semicolon
r_if
c_cond
(paren
id|type
op_eq
id|S_BOOLEAN
op_logical_and
id|val
op_eq
id|mod
)paren
r_return
l_bool|false
suffix:semicolon
r_if
c_cond
(paren
id|sym-&gt;visible
op_le
id|sym-&gt;rev_dep.tri
)paren
r_return
l_bool|false
suffix:semicolon
r_if
c_cond
(paren
id|sym_is_choice_value
c_func
(paren
id|sym
)paren
op_logical_and
id|sym-&gt;visible
op_eq
id|yes
)paren
r_return
id|val
op_eq
id|yes
suffix:semicolon
r_return
id|val
op_ge
id|sym-&gt;rev_dep.tri
op_logical_and
id|val
op_le
id|sym-&gt;visible
suffix:semicolon
)brace
DECL|function|sym_set_tristate_value
r_bool
id|sym_set_tristate_value
c_func
(paren
r_struct
id|symbol
op_star
id|sym
comma
id|tristate
id|val
)paren
(brace
id|tristate
id|oldval
op_assign
id|sym_get_tristate_value
c_func
(paren
id|sym
)paren
suffix:semicolon
r_if
c_cond
(paren
id|oldval
op_ne
id|val
op_logical_and
op_logical_neg
id|sym_tristate_within_range
c_func
(paren
id|sym
comma
id|val
)paren
)paren
r_return
l_bool|false
suffix:semicolon
r_if
c_cond
(paren
id|sym-&gt;flags
op_amp
id|SYMBOL_NEW
)paren
(brace
id|sym-&gt;flags
op_and_assign
op_complement
id|SYMBOL_NEW
suffix:semicolon
id|sym_set_changed
c_func
(paren
id|sym
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sym_is_choice_value
c_func
(paren
id|sym
)paren
op_logical_and
id|val
op_eq
id|yes
)paren
(brace
r_struct
id|symbol
op_star
id|cs
op_assign
id|prop_get_symbol
c_func
(paren
id|sym_get_choice_prop
c_func
(paren
id|sym
)paren
)paren
suffix:semicolon
id|cs-&gt;user.val
op_assign
id|sym
suffix:semicolon
id|cs-&gt;flags
op_and_assign
op_complement
id|SYMBOL_NEW
suffix:semicolon
)brace
id|sym-&gt;user.tri
op_assign
id|val
suffix:semicolon
r_if
c_cond
(paren
id|oldval
op_ne
id|val
)paren
(brace
id|sym_clear_all_valid
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sym
op_eq
id|modules_sym
)paren
id|sym_set_all_changed
c_func
(paren
)paren
suffix:semicolon
)brace
r_return
l_bool|true
suffix:semicolon
)brace
DECL|function|sym_toggle_tristate_value
id|tristate
id|sym_toggle_tristate_value
c_func
(paren
r_struct
id|symbol
op_star
id|sym
)paren
(brace
id|tristate
id|oldval
comma
id|newval
suffix:semicolon
id|oldval
op_assign
id|newval
op_assign
id|sym_get_tristate_value
c_func
(paren
id|sym
)paren
suffix:semicolon
r_do
(brace
r_switch
c_cond
(paren
id|newval
)paren
(brace
r_case
id|no
suffix:colon
id|newval
op_assign
id|mod
suffix:semicolon
r_break
suffix:semicolon
r_case
id|mod
suffix:colon
id|newval
op_assign
id|yes
suffix:semicolon
r_break
suffix:semicolon
r_case
id|yes
suffix:colon
id|newval
op_assign
id|no
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sym_set_tristate_value
c_func
(paren
id|sym
comma
id|newval
)paren
)paren
r_break
suffix:semicolon
)brace
r_while
c_loop
(paren
id|oldval
op_ne
id|newval
)paren
suffix:semicolon
r_return
id|newval
suffix:semicolon
)brace
DECL|function|sym_string_valid
r_bool
id|sym_string_valid
c_func
(paren
r_struct
id|symbol
op_star
id|sym
comma
r_const
r_char
op_star
id|str
)paren
(brace
r_int
r_char
id|ch
suffix:semicolon
r_switch
c_cond
(paren
id|sym-&gt;type
)paren
(brace
r_case
id|S_STRING
suffix:colon
r_return
l_bool|true
suffix:semicolon
r_case
id|S_INT
suffix:colon
id|ch
op_assign
op_star
id|str
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|ch
op_eq
l_char|&squot;-&squot;
)paren
id|ch
op_assign
op_star
id|str
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|isdigit
c_func
(paren
id|ch
)paren
)paren
r_return
l_bool|false
suffix:semicolon
r_if
c_cond
(paren
id|ch
op_eq
l_char|&squot;0&squot;
op_logical_and
op_star
id|str
op_ne
l_int|0
)paren
r_return
l_bool|false
suffix:semicolon
r_while
c_loop
(paren
(paren
id|ch
op_assign
op_star
id|str
op_increment
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|isdigit
c_func
(paren
id|ch
)paren
)paren
r_return
l_bool|false
suffix:semicolon
)brace
r_return
l_bool|true
suffix:semicolon
r_case
id|S_HEX
suffix:colon
r_if
c_cond
(paren
id|str
(braket
l_int|0
)braket
op_eq
l_char|&squot;0&squot;
op_logical_and
(paren
id|str
(braket
l_int|1
)braket
op_eq
l_char|&squot;x&squot;
op_logical_or
id|str
(braket
l_int|1
)braket
op_eq
l_char|&squot;X&squot;
)paren
)paren
id|str
op_add_assign
l_int|2
suffix:semicolon
id|ch
op_assign
op_star
id|str
op_increment
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
op_logical_neg
id|isxdigit
c_func
(paren
id|ch
)paren
)paren
r_return
l_bool|false
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|ch
op_assign
op_star
id|str
op_increment
)paren
)paren
suffix:semicolon
r_return
l_bool|true
suffix:semicolon
r_case
id|S_BOOLEAN
suffix:colon
r_case
id|S_TRISTATE
suffix:colon
r_switch
c_cond
(paren
id|str
(braket
l_int|0
)braket
)paren
(brace
r_case
l_char|&squot;y&squot;
suffix:colon
r_case
l_char|&squot;Y&squot;
suffix:colon
r_case
l_char|&squot;m&squot;
suffix:colon
r_case
l_char|&squot;M&squot;
suffix:colon
r_case
l_char|&squot;n&squot;
suffix:colon
r_case
l_char|&squot;N&squot;
suffix:colon
r_return
l_bool|true
suffix:semicolon
)brace
r_return
l_bool|false
suffix:semicolon
r_default
suffix:colon
r_return
l_bool|false
suffix:semicolon
)brace
)brace
DECL|function|sym_string_within_range
r_bool
id|sym_string_within_range
c_func
(paren
r_struct
id|symbol
op_star
id|sym
comma
r_const
r_char
op_star
id|str
)paren
(brace
r_struct
id|property
op_star
id|prop
suffix:semicolon
r_int
id|val
suffix:semicolon
r_switch
c_cond
(paren
id|sym-&gt;type
)paren
(brace
r_case
id|S_STRING
suffix:colon
r_return
id|sym_string_valid
c_func
(paren
id|sym
comma
id|str
)paren
suffix:semicolon
r_case
id|S_INT
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|sym_string_valid
c_func
(paren
id|sym
comma
id|str
)paren
)paren
r_return
l_bool|false
suffix:semicolon
id|prop
op_assign
id|sym_get_range_prop
c_func
(paren
id|sym
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|prop
)paren
r_return
l_bool|true
suffix:semicolon
id|val
op_assign
id|strtol
c_func
(paren
id|str
comma
l_int|NULL
comma
l_int|10
)paren
suffix:semicolon
r_return
id|val
op_ge
id|strtol
c_func
(paren
id|prop-&gt;expr-&gt;left.sym-&gt;name
comma
l_int|NULL
comma
l_int|10
)paren
op_logical_and
id|val
op_le
id|strtol
c_func
(paren
id|prop-&gt;expr-&gt;right.sym-&gt;name
comma
l_int|NULL
comma
l_int|10
)paren
suffix:semicolon
r_case
id|S_HEX
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|sym_string_valid
c_func
(paren
id|sym
comma
id|str
)paren
)paren
r_return
l_bool|false
suffix:semicolon
id|prop
op_assign
id|sym_get_range_prop
c_func
(paren
id|sym
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|prop
)paren
r_return
l_bool|true
suffix:semicolon
id|val
op_assign
id|strtol
c_func
(paren
id|str
comma
l_int|NULL
comma
l_int|16
)paren
suffix:semicolon
r_return
id|val
op_ge
id|strtol
c_func
(paren
id|prop-&gt;expr-&gt;left.sym-&gt;name
comma
l_int|NULL
comma
l_int|16
)paren
op_logical_and
id|val
op_le
id|strtol
c_func
(paren
id|prop-&gt;expr-&gt;right.sym-&gt;name
comma
l_int|NULL
comma
l_int|16
)paren
suffix:semicolon
r_case
id|S_BOOLEAN
suffix:colon
r_case
id|S_TRISTATE
suffix:colon
r_switch
c_cond
(paren
id|str
(braket
l_int|0
)braket
)paren
(brace
r_case
l_char|&squot;y&squot;
suffix:colon
r_case
l_char|&squot;Y&squot;
suffix:colon
r_return
id|sym_tristate_within_range
c_func
(paren
id|sym
comma
id|yes
)paren
suffix:semicolon
r_case
l_char|&squot;m&squot;
suffix:colon
r_case
l_char|&squot;M&squot;
suffix:colon
r_return
id|sym_tristate_within_range
c_func
(paren
id|sym
comma
id|mod
)paren
suffix:semicolon
r_case
l_char|&squot;n&squot;
suffix:colon
r_case
l_char|&squot;N&squot;
suffix:colon
r_return
id|sym_tristate_within_range
c_func
(paren
id|sym
comma
id|no
)paren
suffix:semicolon
)brace
r_return
l_bool|false
suffix:semicolon
r_default
suffix:colon
r_return
l_bool|false
suffix:semicolon
)brace
)brace
DECL|function|sym_set_string_value
r_bool
id|sym_set_string_value
c_func
(paren
r_struct
id|symbol
op_star
id|sym
comma
r_const
r_char
op_star
id|newval
)paren
(brace
r_const
r_char
op_star
id|oldval
suffix:semicolon
r_char
op_star
id|val
suffix:semicolon
r_int
id|size
suffix:semicolon
r_switch
c_cond
(paren
id|sym-&gt;type
)paren
(brace
r_case
id|S_BOOLEAN
suffix:colon
r_case
id|S_TRISTATE
suffix:colon
r_switch
c_cond
(paren
id|newval
(braket
l_int|0
)braket
)paren
(brace
r_case
l_char|&squot;y&squot;
suffix:colon
r_case
l_char|&squot;Y&squot;
suffix:colon
r_return
id|sym_set_tristate_value
c_func
(paren
id|sym
comma
id|yes
)paren
suffix:semicolon
r_case
l_char|&squot;m&squot;
suffix:colon
r_case
l_char|&squot;M&squot;
suffix:colon
r_return
id|sym_set_tristate_value
c_func
(paren
id|sym
comma
id|mod
)paren
suffix:semicolon
r_case
l_char|&squot;n&squot;
suffix:colon
r_case
l_char|&squot;N&squot;
suffix:colon
r_return
id|sym_set_tristate_value
c_func
(paren
id|sym
comma
id|no
)paren
suffix:semicolon
)brace
r_return
l_bool|false
suffix:semicolon
r_default
suffix:colon
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|sym_string_within_range
c_func
(paren
id|sym
comma
id|newval
)paren
)paren
r_return
l_bool|false
suffix:semicolon
r_if
c_cond
(paren
id|sym-&gt;flags
op_amp
id|SYMBOL_NEW
)paren
(brace
id|sym-&gt;flags
op_and_assign
op_complement
id|SYMBOL_NEW
suffix:semicolon
id|sym_set_changed
c_func
(paren
id|sym
)paren
suffix:semicolon
)brace
id|oldval
op_assign
id|sym-&gt;user.val
suffix:semicolon
id|size
op_assign
id|strlen
c_func
(paren
id|newval
)paren
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|sym-&gt;type
op_eq
id|S_HEX
op_logical_and
(paren
id|newval
(braket
l_int|0
)braket
op_ne
l_char|&squot;0&squot;
op_logical_or
(paren
id|newval
(braket
l_int|1
)braket
op_ne
l_char|&squot;x&squot;
op_logical_and
id|newval
(braket
l_int|1
)braket
op_ne
l_char|&squot;X&squot;
)paren
)paren
)paren
(brace
id|size
op_add_assign
l_int|2
suffix:semicolon
id|sym-&gt;user.val
op_assign
id|val
op_assign
id|malloc
c_func
(paren
id|size
)paren
suffix:semicolon
op_star
id|val
op_increment
op_assign
l_char|&squot;0&squot;
suffix:semicolon
op_star
id|val
op_increment
op_assign
l_char|&squot;x&squot;
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|oldval
op_logical_or
id|strcmp
c_func
(paren
id|oldval
comma
id|newval
)paren
)paren
id|sym-&gt;user.val
op_assign
id|val
op_assign
id|malloc
c_func
(paren
id|size
)paren
suffix:semicolon
r_else
r_return
l_bool|true
suffix:semicolon
id|strcpy
c_func
(paren
id|val
comma
id|newval
)paren
suffix:semicolon
id|free
c_func
(paren
(paren
r_void
op_star
)paren
id|oldval
)paren
suffix:semicolon
id|sym_clear_all_valid
c_func
(paren
)paren
suffix:semicolon
r_return
l_bool|true
suffix:semicolon
)brace
DECL|function|sym_get_string_value
r_const
r_char
op_star
id|sym_get_string_value
c_func
(paren
r_struct
id|symbol
op_star
id|sym
)paren
(brace
id|tristate
id|val
suffix:semicolon
r_switch
c_cond
(paren
id|sym-&gt;type
)paren
(brace
r_case
id|S_BOOLEAN
suffix:colon
r_case
id|S_TRISTATE
suffix:colon
id|val
op_assign
id|sym_get_tristate_value
c_func
(paren
id|sym
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|val
)paren
(brace
r_case
id|no
suffix:colon
r_return
l_string|&quot;n&quot;
suffix:semicolon
r_case
id|mod
suffix:colon
r_return
l_string|&quot;m&quot;
suffix:semicolon
r_case
id|yes
suffix:colon
r_return
l_string|&quot;y&quot;
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
suffix:semicolon
)brace
r_return
(paren
r_const
r_char
op_star
)paren
id|sym-&gt;curr.val
suffix:semicolon
)brace
DECL|function|sym_is_changable
r_bool
id|sym_is_changable
c_func
(paren
r_struct
id|symbol
op_star
id|sym
)paren
(brace
r_return
id|sym-&gt;visible
OG
id|sym-&gt;rev_dep.tri
suffix:semicolon
)brace
DECL|function|sym_lookup
r_struct
id|symbol
op_star
id|sym_lookup
c_func
(paren
r_const
r_char
op_star
id|name
comma
r_int
id|isconst
)paren
(brace
r_struct
id|symbol
op_star
id|symbol
suffix:semicolon
r_const
r_char
op_star
id|ptr
suffix:semicolon
r_char
op_star
id|new_name
suffix:semicolon
r_int
id|hash
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|name
)paren
(brace
r_if
c_cond
(paren
id|name
(braket
l_int|0
)braket
op_logical_and
op_logical_neg
id|name
(braket
l_int|1
)braket
)paren
(brace
r_switch
c_cond
(paren
id|name
(braket
l_int|0
)braket
)paren
(brace
r_case
l_char|&squot;y&squot;
suffix:colon
r_return
op_amp
id|symbol_yes
suffix:semicolon
r_case
l_char|&squot;m&squot;
suffix:colon
r_return
op_amp
id|symbol_mod
suffix:semicolon
r_case
l_char|&squot;n&squot;
suffix:colon
r_return
op_amp
id|symbol_no
suffix:semicolon
)brace
)brace
r_for
c_loop
(paren
id|ptr
op_assign
id|name
suffix:semicolon
op_star
id|ptr
suffix:semicolon
id|ptr
op_increment
)paren
id|hash
op_add_assign
op_star
id|ptr
suffix:semicolon
id|hash
op_and_assign
l_int|0xff
suffix:semicolon
r_for
c_loop
(paren
id|symbol
op_assign
id|symbol_hash
(braket
id|hash
)braket
suffix:semicolon
id|symbol
suffix:semicolon
id|symbol
op_assign
id|symbol-&gt;next
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|symbol-&gt;name
comma
id|name
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|isconst
op_logical_and
id|symbol-&gt;flags
op_amp
id|SYMBOL_CONST
)paren
op_logical_or
(paren
op_logical_neg
id|isconst
op_logical_and
op_logical_neg
(paren
id|symbol-&gt;flags
op_amp
id|SYMBOL_CONST
)paren
)paren
)paren
r_return
id|symbol
suffix:semicolon
)brace
)brace
id|new_name
op_assign
id|strdup
c_func
(paren
id|name
)paren
suffix:semicolon
)brace
r_else
(brace
id|new_name
op_assign
l_int|NULL
suffix:semicolon
id|hash
op_assign
l_int|256
suffix:semicolon
)brace
id|symbol
op_assign
id|malloc
c_func
(paren
r_sizeof
(paren
op_star
id|symbol
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|symbol
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|symbol
)paren
)paren
suffix:semicolon
id|symbol-&gt;name
op_assign
id|new_name
suffix:semicolon
id|symbol-&gt;type
op_assign
id|S_UNKNOWN
suffix:semicolon
id|symbol-&gt;flags
op_assign
id|SYMBOL_NEW
suffix:semicolon
r_if
c_cond
(paren
id|isconst
)paren
id|symbol-&gt;flags
op_or_assign
id|SYMBOL_CONST
suffix:semicolon
id|symbol-&gt;next
op_assign
id|symbol_hash
(braket
id|hash
)braket
suffix:semicolon
id|symbol_hash
(braket
id|hash
)braket
op_assign
id|symbol
suffix:semicolon
r_return
id|symbol
suffix:semicolon
)brace
DECL|function|sym_find
r_struct
id|symbol
op_star
id|sym_find
c_func
(paren
r_const
r_char
op_star
id|name
)paren
(brace
r_struct
id|symbol
op_star
id|symbol
op_assign
l_int|NULL
suffix:semicolon
r_const
r_char
op_star
id|ptr
suffix:semicolon
r_int
id|hash
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|name
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|name
(braket
l_int|0
)braket
op_logical_and
op_logical_neg
id|name
(braket
l_int|1
)braket
)paren
(brace
r_switch
c_cond
(paren
id|name
(braket
l_int|0
)braket
)paren
(brace
r_case
l_char|&squot;y&squot;
suffix:colon
r_return
op_amp
id|symbol_yes
suffix:semicolon
r_case
l_char|&squot;m&squot;
suffix:colon
r_return
op_amp
id|symbol_mod
suffix:semicolon
r_case
l_char|&squot;n&squot;
suffix:colon
r_return
op_amp
id|symbol_no
suffix:semicolon
)brace
)brace
r_for
c_loop
(paren
id|ptr
op_assign
id|name
suffix:semicolon
op_star
id|ptr
suffix:semicolon
id|ptr
op_increment
)paren
id|hash
op_add_assign
op_star
id|ptr
suffix:semicolon
id|hash
op_and_assign
l_int|0xff
suffix:semicolon
r_for
c_loop
(paren
id|symbol
op_assign
id|symbol_hash
(braket
id|hash
)braket
suffix:semicolon
id|symbol
suffix:semicolon
id|symbol
op_assign
id|symbol-&gt;next
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|symbol-&gt;name
comma
id|name
)paren
op_logical_and
op_logical_neg
(paren
id|symbol-&gt;flags
op_amp
id|SYMBOL_CONST
)paren
)paren
r_break
suffix:semicolon
)brace
r_return
id|symbol
suffix:semicolon
)brace
DECL|function|sym_re_search
r_struct
id|symbol
op_star
op_star
id|sym_re_search
c_func
(paren
r_const
r_char
op_star
id|pattern
)paren
(brace
r_struct
id|symbol
op_star
id|sym
comma
op_star
op_star
id|sym_arr
op_assign
l_int|NULL
suffix:semicolon
r_int
id|i
comma
id|cnt
comma
id|size
suffix:semicolon
id|regex_t
id|re
suffix:semicolon
id|cnt
op_assign
id|size
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Skip if empty */
r_if
c_cond
(paren
id|strlen
c_func
(paren
id|pattern
)paren
op_eq
l_int|0
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|regcomp
c_func
(paren
op_amp
id|re
comma
id|pattern
comma
id|REG_EXTENDED
op_or
id|REG_NOSUB
op_or
id|REG_ICASE
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
id|for_all_symbols
c_func
(paren
id|i
comma
id|sym
)paren
(brace
r_if
c_cond
(paren
id|sym-&gt;flags
op_amp
id|SYMBOL_CONST
op_logical_or
op_logical_neg
id|sym-&gt;name
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|regexec
c_func
(paren
op_amp
id|re
comma
id|sym-&gt;name
comma
l_int|0
comma
l_int|NULL
comma
l_int|0
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|cnt
op_plus
l_int|1
op_ge
id|size
)paren
(brace
r_void
op_star
id|tmp
op_assign
id|sym_arr
suffix:semicolon
id|size
op_add_assign
l_int|16
suffix:semicolon
id|sym_arr
op_assign
id|realloc
c_func
(paren
id|sym_arr
comma
id|size
op_star
r_sizeof
(paren
r_struct
id|symbol
op_star
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sym_arr
)paren
(brace
id|free
c_func
(paren
id|tmp
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
)brace
id|sym_arr
(braket
id|cnt
op_increment
)braket
op_assign
id|sym
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sym_arr
)paren
id|sym_arr
(braket
id|cnt
)braket
op_assign
l_int|NULL
suffix:semicolon
id|regfree
c_func
(paren
op_amp
id|re
)paren
suffix:semicolon
r_return
id|sym_arr
suffix:semicolon
)brace
r_struct
id|symbol
op_star
id|sym_check_deps
c_func
(paren
r_struct
id|symbol
op_star
id|sym
)paren
suffix:semicolon
DECL|function|sym_check_expr_deps
r_static
r_struct
id|symbol
op_star
id|sym_check_expr_deps
c_func
(paren
r_struct
id|expr
op_star
id|e
)paren
(brace
r_struct
id|symbol
op_star
id|sym
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|e
)paren
r_return
l_int|NULL
suffix:semicolon
r_switch
c_cond
(paren
id|e-&gt;type
)paren
(brace
r_case
id|E_OR
suffix:colon
r_case
id|E_AND
suffix:colon
id|sym
op_assign
id|sym_check_expr_deps
c_func
(paren
id|e-&gt;left.expr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sym
)paren
r_return
id|sym
suffix:semicolon
r_return
id|sym_check_expr_deps
c_func
(paren
id|e-&gt;right.expr
)paren
suffix:semicolon
r_case
id|E_NOT
suffix:colon
r_return
id|sym_check_expr_deps
c_func
(paren
id|e-&gt;left.expr
)paren
suffix:semicolon
r_case
id|E_EQUAL
suffix:colon
r_case
id|E_UNEQUAL
suffix:colon
id|sym
op_assign
id|sym_check_deps
c_func
(paren
id|e-&gt;left.sym
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sym
)paren
r_return
id|sym
suffix:semicolon
r_return
id|sym_check_deps
c_func
(paren
id|e-&gt;right.sym
)paren
suffix:semicolon
r_case
id|E_SYMBOL
suffix:colon
r_return
id|sym_check_deps
c_func
(paren
id|e-&gt;left.sym
)paren
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
id|printf
c_func
(paren
l_string|&quot;Oops! How to check %d?&bslash;n&quot;
comma
id|e-&gt;type
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|sym_check_deps
r_struct
id|symbol
op_star
id|sym_check_deps
c_func
(paren
r_struct
id|symbol
op_star
id|sym
)paren
(brace
r_struct
id|symbol
op_star
id|sym2
suffix:semicolon
r_struct
id|property
op_star
id|prop
suffix:semicolon
r_if
c_cond
(paren
id|sym-&gt;flags
op_amp
id|SYMBOL_CHECK_DONE
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|sym-&gt;flags
op_amp
id|SYMBOL_CHECK
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;Warning! Found recursive dependency: %s&quot;
comma
id|sym-&gt;name
)paren
suffix:semicolon
r_return
id|sym
suffix:semicolon
)brace
id|sym-&gt;flags
op_or_assign
(paren
id|SYMBOL_CHECK
op_or
id|SYMBOL_CHECKED
)paren
suffix:semicolon
id|sym2
op_assign
id|sym_check_expr_deps
c_func
(paren
id|sym-&gt;rev_dep.expr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sym2
)paren
r_goto
id|out
suffix:semicolon
r_for
c_loop
(paren
id|prop
op_assign
id|sym-&gt;prop
suffix:semicolon
id|prop
suffix:semicolon
id|prop
op_assign
id|prop-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|prop-&gt;type
op_eq
id|P_CHOICE
op_logical_or
id|prop-&gt;type
op_eq
id|P_SELECT
)paren
r_continue
suffix:semicolon
id|sym2
op_assign
id|sym_check_expr_deps
c_func
(paren
id|prop-&gt;visible.expr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sym2
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|prop-&gt;type
op_ne
id|P_DEFAULT
op_logical_or
id|sym_is_choice
c_func
(paren
id|sym
)paren
)paren
r_continue
suffix:semicolon
id|sym2
op_assign
id|sym_check_expr_deps
c_func
(paren
id|prop-&gt;expr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sym2
)paren
r_goto
id|out
suffix:semicolon
)brace
id|out
suffix:colon
r_if
c_cond
(paren
id|sym2
)paren
id|printf
c_func
(paren
l_string|&quot; %s&quot;
comma
id|sym-&gt;name
)paren
suffix:semicolon
id|sym-&gt;flags
op_and_assign
op_complement
id|SYMBOL_CHECK
suffix:semicolon
r_return
id|sym2
suffix:semicolon
)brace
DECL|function|prop_alloc
r_struct
id|property
op_star
id|prop_alloc
c_func
(paren
r_enum
id|prop_type
id|type
comma
r_struct
id|symbol
op_star
id|sym
)paren
(brace
r_struct
id|property
op_star
id|prop
suffix:semicolon
r_struct
id|property
op_star
op_star
id|propp
suffix:semicolon
id|prop
op_assign
id|malloc
c_func
(paren
r_sizeof
(paren
op_star
id|prop
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|prop
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|prop
)paren
)paren
suffix:semicolon
id|prop-&gt;type
op_assign
id|type
suffix:semicolon
id|prop-&gt;sym
op_assign
id|sym
suffix:semicolon
id|prop-&gt;file
op_assign
id|current_file
suffix:semicolon
id|prop-&gt;lineno
op_assign
id|zconf_lineno
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* append property to the prop list of symbol */
r_if
c_cond
(paren
id|sym
)paren
(brace
r_for
c_loop
(paren
id|propp
op_assign
op_amp
id|sym-&gt;prop
suffix:semicolon
op_star
id|propp
suffix:semicolon
id|propp
op_assign
op_amp
(paren
op_star
id|propp
)paren
op_member_access_from_pointer
id|next
)paren
suffix:semicolon
op_star
id|propp
op_assign
id|prop
suffix:semicolon
)brace
r_return
id|prop
suffix:semicolon
)brace
DECL|function|prop_get_symbol
r_struct
id|symbol
op_star
id|prop_get_symbol
c_func
(paren
r_struct
id|property
op_star
id|prop
)paren
(brace
r_if
c_cond
(paren
id|prop-&gt;expr
op_logical_and
(paren
id|prop-&gt;expr-&gt;type
op_eq
id|E_SYMBOL
op_logical_or
id|prop-&gt;expr-&gt;type
op_eq
id|E_CHOICE
)paren
)paren
r_return
id|prop-&gt;expr-&gt;left.sym
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|prop_get_type_name
r_const
r_char
op_star
id|prop_get_type_name
c_func
(paren
r_enum
id|prop_type
id|type
)paren
(brace
r_switch
c_cond
(paren
id|type
)paren
(brace
r_case
id|P_PROMPT
suffix:colon
r_return
l_string|&quot;prompt&quot;
suffix:semicolon
r_case
id|P_COMMENT
suffix:colon
r_return
l_string|&quot;comment&quot;
suffix:semicolon
r_case
id|P_MENU
suffix:colon
r_return
l_string|&quot;menu&quot;
suffix:semicolon
r_case
id|P_DEFAULT
suffix:colon
r_return
l_string|&quot;default&quot;
suffix:semicolon
r_case
id|P_CHOICE
suffix:colon
r_return
l_string|&quot;choice&quot;
suffix:semicolon
r_case
id|P_SELECT
suffix:colon
r_return
l_string|&quot;select&quot;
suffix:semicolon
r_case
id|P_RANGE
suffix:colon
r_return
l_string|&quot;range&quot;
suffix:semicolon
r_case
id|P_UNKNOWN
suffix:colon
r_break
suffix:semicolon
)brace
r_return
l_string|&quot;unknown&quot;
suffix:semicolon
)brace
eof
