multiline_comment|/*&n; * cramfsck - check a cramfs file system&n; *&n; * Copyright (C) 2000-2001 Transmeta Corporation&n; *&n; * This program is free software; you can redistribute it and/or modify&n; * it under the terms of the GNU General Public License as published by&n; * the Free Software Foundation; either version 2 of the License, or&n; * (at your option) any later version.&n; *&n; * This program is distributed in the hope that it will be useful,&n; * but WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; * GNU General Public License for more details.&n; *&n; * You should have received a copy of the GNU General Public License&n; * along with this program; if not, write to the Free Software&n; * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA&n; *&n; * 1999/12/03: Linus Torvalds (cramfs tester and unarchive program)&n; * 2000/06/03: Daniel Quinlan (CRC and length checking program)&n; * 2000/06/04: Daniel Quinlan (merged programs, added options, support&n; *                            for special files, preserve permissions and&n; *                            ownership, cramfs superblock v2, bogus mode&n; *                            test, pathname length test, etc.)&n; * 2000/06/06: Daniel Quinlan (support for holes, pretty-printing,&n; *                            symlink size test)&n; * 2000/07/11: Daniel Quinlan (file length tests, start at offset 0 or 512,&n; *                            fsck-compatible exit codes)&n; * 2000/07/15: Daniel Quinlan (initial support for block devices)&n; */
multiline_comment|/* compile-time options */
DECL|macro|INCLUDE_FS_TESTS
mdefine_line|#define INCLUDE_FS_TESTS&t;/* include cramfs checking and extraction */
macro_line|#include &lt;sys/types.h&gt;
macro_line|#include &lt;stdio.h&gt;
macro_line|#include &lt;sys/stat.h&gt;
macro_line|#include &lt;unistd.h&gt;
macro_line|#include &lt;sys/mman.h&gt;
macro_line|#include &lt;sys/fcntl.h&gt;
macro_line|#include &lt;dirent.h&gt;
macro_line|#include &lt;stdlib.h&gt;
macro_line|#include &lt;errno.h&gt;
macro_line|#include &lt;string.h&gt;
macro_line|#include &lt;assert.h&gt;
macro_line|#include &lt;getopt.h&gt;
macro_line|#include &lt;sys/sysmacros.h&gt;
macro_line|#include &lt;utime.h&gt;
macro_line|#include &lt;sys/ioctl.h&gt;
DECL|macro|_LINUX_STRING_H_
mdefine_line|#define _LINUX_STRING_H_
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/cramfs_fs.h&gt;
macro_line|#include &lt;zlib.h&gt;
DECL|variable|progname
r_static
r_const
r_char
op_star
id|progname
op_assign
l_string|&quot;cramfsck&quot;
suffix:semicolon
DECL|variable|fd
r_static
r_int
id|fd
suffix:semicolon
multiline_comment|/* ROM image file descriptor */
DECL|variable|filename
r_static
r_char
op_star
id|filename
suffix:semicolon
multiline_comment|/* ROM image filename */
DECL|variable|super
r_struct
id|cramfs_super
op_star
id|super
suffix:semicolon
multiline_comment|/* just find the cramfs superblock once */
DECL|variable|opt_verbose
r_static
r_int
id|opt_verbose
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* 1 = verbose (-v), 2+ = very verbose (-vv) */
macro_line|#ifdef INCLUDE_FS_TESTS
DECL|variable|opt_extract
r_static
r_int
id|opt_extract
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* extract cramfs (-x) */
DECL|variable|extract_dir
r_char
op_star
id|extract_dir
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* extraction directory (-x) */
DECL|variable|start_inode
r_int
r_int
id|start_inode
op_assign
l_int|1
op_lshift
l_int|28
suffix:semicolon
multiline_comment|/* start of first non-root inode */
DECL|variable|end_inode
r_int
r_int
id|end_inode
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* end of the directory structure */
DECL|variable|start_data
r_int
r_int
id|start_data
op_assign
l_int|1
op_lshift
l_int|28
suffix:semicolon
multiline_comment|/* start of the data (256 MB = max) */
DECL|variable|end_data
r_int
r_int
id|end_data
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* end of the data */
multiline_comment|/* true?  cramfs_super &lt; start_inode &lt; end_inode &lt;= start_data &lt;= end_data */
DECL|variable|euid
r_static
id|uid_t
id|euid
suffix:semicolon
multiline_comment|/* effective UID */
DECL|macro|PAD_SIZE
mdefine_line|#define PAD_SIZE 512
DECL|macro|PAGE_CACHE_SIZE
mdefine_line|#define PAGE_CACHE_SIZE (4096)
multiline_comment|/* Guarantee access to at least 8kB at a time */
DECL|macro|ROMBUFFER_BITS
mdefine_line|#define ROMBUFFER_BITS&t;13
DECL|macro|ROMBUFFERSIZE
mdefine_line|#define ROMBUFFERSIZE&t;(1 &lt;&lt; ROMBUFFER_BITS)
DECL|macro|ROMBUFFERMASK
mdefine_line|#define ROMBUFFERMASK&t;(ROMBUFFERSIZE-1)
DECL|variable|read_buffer
r_static
r_char
id|read_buffer
(braket
id|ROMBUFFERSIZE
op_star
l_int|2
)braket
suffix:semicolon
DECL|variable|read_buffer_block
r_static
r_int
r_int
id|read_buffer_block
op_assign
op_complement
l_int|0UL
suffix:semicolon
multiline_comment|/* Uncompressing data structures... */
DECL|variable|outbuffer
r_static
r_char
id|outbuffer
(braket
id|PAGE_CACHE_SIZE
op_star
l_int|2
)braket
suffix:semicolon
DECL|variable|stream
id|z_stream
id|stream
suffix:semicolon
macro_line|#endif /* INCLUDE_FS_TESTS */
multiline_comment|/* Input status of 0 to print help and exit without an error. */
DECL|function|usage
r_static
r_void
id|usage
c_func
(paren
r_int
id|status
)paren
(brace
id|FILE
op_star
id|stream
op_assign
id|status
ques
c_cond
id|stderr
suffix:colon
id|stdout
suffix:semicolon
id|fprintf
c_func
(paren
id|stream
comma
l_string|&quot;usage: %s [-hv] [-x dir] file&bslash;n&quot;
l_string|&quot; -h         print this help&bslash;n&quot;
l_string|&quot; -x dir     extract into dir&bslash;n&quot;
l_string|&quot; -v         be more verbose&bslash;n&quot;
l_string|&quot; file       file to test&bslash;n&quot;
comma
id|progname
)paren
suffix:semicolon
m_exit
(paren
id|status
)paren
suffix:semicolon
)brace
macro_line|#ifdef INCLUDE_FS_TESTS
DECL|function|print_node
r_void
id|print_node
c_func
(paren
r_char
id|type
comma
r_struct
id|cramfs_inode
op_star
id|i
comma
r_char
op_star
id|name
)paren
(brace
r_char
id|info
(braket
l_int|10
)braket
suffix:semicolon
r_if
c_cond
(paren
id|S_ISCHR
c_func
(paren
id|i-&gt;mode
)paren
op_logical_or
(paren
id|S_ISBLK
c_func
(paren
id|i-&gt;mode
)paren
)paren
)paren
(brace
multiline_comment|/* major/minor numbers can be as high as 2^12 or 4096 */
id|snprintf
c_func
(paren
id|info
comma
l_int|10
comma
l_string|&quot;%4d,%4d&quot;
comma
id|major
c_func
(paren
id|i-&gt;size
)paren
comma
id|minor
c_func
(paren
id|i-&gt;size
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* size be as high as 2^24 or 16777216 */
id|snprintf
c_func
(paren
id|info
comma
l_int|10
comma
l_string|&quot;%9d&quot;
comma
id|i-&gt;size
)paren
suffix:semicolon
)brace
id|printf
c_func
(paren
l_string|&quot;%c %04o %s %5d:%-3d %s&bslash;n&quot;
comma
id|type
comma
id|i-&gt;mode
op_amp
op_complement
id|S_IFMT
comma
id|info
comma
id|i-&gt;uid
comma
id|i-&gt;gid
comma
id|name
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Create a fake &quot;blocked&quot; access&n; */
DECL|function|romfs_read
r_static
r_void
op_star
id|romfs_read
c_func
(paren
r_int
r_int
id|offset
)paren
(brace
r_int
r_int
id|block
op_assign
id|offset
op_rshift
id|ROMBUFFER_BITS
suffix:semicolon
r_if
c_cond
(paren
id|block
op_ne
id|read_buffer_block
)paren
(brace
id|read_buffer_block
op_assign
id|block
suffix:semicolon
id|lseek
c_func
(paren
id|fd
comma
id|block
op_lshift
id|ROMBUFFER_BITS
comma
id|SEEK_SET
)paren
suffix:semicolon
id|read
c_func
(paren
id|fd
comma
id|read_buffer
comma
id|ROMBUFFERSIZE
op_star
l_int|2
)paren
suffix:semicolon
)brace
r_return
id|read_buffer
op_plus
(paren
id|offset
op_amp
id|ROMBUFFERMASK
)paren
suffix:semicolon
)brace
DECL|function|cramfs_iget
r_static
r_struct
id|cramfs_inode
op_star
id|cramfs_iget
c_func
(paren
r_struct
id|cramfs_inode
op_star
id|i
)paren
(brace
r_struct
id|cramfs_inode
op_star
id|inode
op_assign
id|malloc
c_func
(paren
r_sizeof
(paren
r_struct
id|cramfs_inode
)paren
)paren
suffix:semicolon
op_star
id|inode
op_assign
op_star
id|i
suffix:semicolon
r_return
id|inode
suffix:semicolon
)brace
DECL|function|iget
r_static
r_struct
id|cramfs_inode
op_star
id|iget
c_func
(paren
r_int
r_int
id|ino
)paren
(brace
r_return
id|cramfs_iget
c_func
(paren
id|romfs_read
c_func
(paren
id|ino
)paren
)paren
suffix:semicolon
)brace
DECL|function|iput
r_void
id|iput
c_func
(paren
r_struct
id|cramfs_inode
op_star
id|inode
)paren
(brace
id|free
c_func
(paren
id|inode
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Return the offset of the root directory,&n; * or 0 if none.&n; */
DECL|function|read_super
r_static
r_struct
id|cramfs_inode
op_star
id|read_super
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|offset
suffix:semicolon
id|offset
op_assign
id|super-&gt;root.offset
op_lshift
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|super-&gt;magic
op_ne
id|CRAMFS_MAGIC
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|super-&gt;signature
comma
id|CRAMFS_SIGNATURE
comma
r_sizeof
(paren
id|super-&gt;signature
)paren
)paren
op_ne
l_int|0
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|offset
OL
r_sizeof
(paren
id|super
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
r_return
id|cramfs_iget
c_func
(paren
op_amp
id|super-&gt;root
)paren
suffix:semicolon
)brace
DECL|function|uncompress_block
r_static
r_int
id|uncompress_block
c_func
(paren
r_void
op_star
id|src
comma
r_int
id|len
)paren
(brace
r_int
id|err
suffix:semicolon
id|stream.next_in
op_assign
id|src
suffix:semicolon
id|stream.avail_in
op_assign
id|len
suffix:semicolon
id|stream.next_out
op_assign
(paren
r_int
r_char
op_star
)paren
id|outbuffer
suffix:semicolon
id|stream.avail_out
op_assign
id|PAGE_CACHE_SIZE
op_star
l_int|2
suffix:semicolon
id|inflateReset
c_func
(paren
op_amp
id|stream
)paren
suffix:semicolon
id|err
op_assign
id|inflate
c_func
(paren
op_amp
id|stream
comma
id|Z_FINISH
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_ne
id|Z_STREAM_END
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;%s: error %d while decompressing! %p(%d)&bslash;n&quot;
comma
id|filename
comma
id|err
comma
id|src
comma
id|len
)paren
suffix:semicolon
m_exit
(paren
l_int|4
)paren
suffix:semicolon
)brace
r_return
id|stream.total_out
suffix:semicolon
)brace
DECL|function|change_file_status
r_static
r_void
id|change_file_status
c_func
(paren
r_char
op_star
id|path
comma
r_struct
id|cramfs_inode
op_star
id|i
)paren
(brace
r_struct
id|utimbuf
id|epoch
op_assign
(brace
l_int|0
comma
l_int|0
)brace
suffix:semicolon
r_if
c_cond
(paren
id|euid
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|lchown
c_func
(paren
id|path
comma
id|i-&gt;uid
comma
id|i-&gt;gid
)paren
OL
l_int|0
)paren
(brace
id|perror
c_func
(paren
id|path
)paren
suffix:semicolon
m_exit
(paren
l_int|8
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|S_ISLNK
c_func
(paren
id|i-&gt;mode
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
(paren
id|S_ISUID
op_or
id|S_ISGID
)paren
op_amp
id|i-&gt;mode
)paren
(brace
r_if
c_cond
(paren
id|chmod
c_func
(paren
id|path
comma
id|i-&gt;mode
)paren
OL
l_int|0
)paren
(brace
id|perror
c_func
(paren
id|path
)paren
suffix:semicolon
m_exit
(paren
l_int|8
)paren
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|S_ISLNK
c_func
(paren
id|i-&gt;mode
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|utime
c_func
(paren
id|path
comma
op_amp
id|epoch
)paren
OL
l_int|0
)paren
(brace
id|perror
c_func
(paren
id|path
)paren
suffix:semicolon
m_exit
(paren
l_int|8
)paren
suffix:semicolon
)brace
)brace
DECL|function|do_symlink
r_static
r_void
id|do_symlink
c_func
(paren
r_char
op_star
id|path
comma
r_struct
id|cramfs_inode
op_star
id|i
)paren
(brace
r_int
r_int
id|offset
op_assign
id|i-&gt;offset
op_lshift
l_int|2
suffix:semicolon
r_int
r_int
id|curr
op_assign
id|offset
op_plus
l_int|4
suffix:semicolon
r_int
r_int
id|next
op_assign
op_star
(paren
id|u32
op_star
)paren
id|romfs_read
c_func
(paren
id|offset
)paren
suffix:semicolon
r_int
r_int
id|size
suffix:semicolon
r_if
c_cond
(paren
id|next
OG
id|end_data
)paren
(brace
id|end_data
op_assign
id|next
suffix:semicolon
)brace
id|size
op_assign
id|uncompress_block
c_func
(paren
id|romfs_read
c_func
(paren
id|curr
)paren
comma
id|next
op_minus
id|curr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|size
op_ne
id|i-&gt;size
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;%s: size error in symlink `%s&squot;&bslash;n&quot;
comma
id|filename
comma
id|path
)paren
suffix:semicolon
m_exit
(paren
l_int|4
)paren
suffix:semicolon
)brace
id|outbuffer
(braket
id|size
)braket
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|opt_verbose
)paren
(brace
r_char
op_star
id|str
suffix:semicolon
id|str
op_assign
id|malloc
c_func
(paren
id|strlen
c_func
(paren
id|outbuffer
)paren
op_plus
id|strlen
c_func
(paren
id|path
)paren
op_plus
l_int|5
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|str
comma
id|path
)paren
suffix:semicolon
id|strncat
c_func
(paren
id|str
comma
l_string|&quot; -&gt; &quot;
comma
l_int|4
)paren
suffix:semicolon
id|strncat
c_func
(paren
id|str
comma
id|outbuffer
comma
id|size
)paren
suffix:semicolon
id|print_node
c_func
(paren
l_char|&squot;l&squot;
comma
id|i
comma
id|str
)paren
suffix:semicolon
r_if
c_cond
(paren
id|opt_verbose
OG
l_int|1
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;  uncompressing block at %ld to %ld (%ld)&bslash;n&quot;
comma
id|curr
comma
id|next
comma
id|next
op_minus
id|curr
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|opt_extract
)paren
(brace
id|symlink
c_func
(paren
id|outbuffer
comma
id|path
)paren
suffix:semicolon
id|change_file_status
c_func
(paren
id|path
comma
id|i
)paren
suffix:semicolon
)brace
)brace
DECL|function|do_special_inode
r_static
r_void
id|do_special_inode
c_func
(paren
r_char
op_star
id|path
comma
r_struct
id|cramfs_inode
op_star
id|i
)paren
(brace
id|dev_t
id|devtype
op_assign
l_int|0
suffix:semicolon
r_char
id|type
suffix:semicolon
r_if
c_cond
(paren
id|S_ISCHR
c_func
(paren
id|i-&gt;mode
)paren
)paren
(brace
id|devtype
op_assign
id|i-&gt;size
suffix:semicolon
id|type
op_assign
l_char|&squot;c&squot;
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|S_ISBLK
c_func
(paren
id|i-&gt;mode
)paren
)paren
(brace
id|devtype
op_assign
id|i-&gt;size
suffix:semicolon
id|type
op_assign
l_char|&squot;b&squot;
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|S_ISFIFO
c_func
(paren
id|i-&gt;mode
)paren
)paren
id|type
op_assign
l_char|&squot;p&squot;
suffix:semicolon
r_else
r_if
c_cond
(paren
id|S_ISSOCK
c_func
(paren
id|i-&gt;mode
)paren
)paren
id|type
op_assign
l_char|&squot;s&squot;
suffix:semicolon
r_else
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;%s: bogus mode on `%s&squot; (%o)&bslash;n&quot;
comma
id|filename
comma
id|path
comma
id|i-&gt;mode
)paren
suffix:semicolon
m_exit
(paren
l_int|4
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|opt_verbose
)paren
(brace
id|print_node
c_func
(paren
id|type
comma
id|i
comma
id|path
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|opt_extract
)paren
(brace
r_if
c_cond
(paren
id|mknod
c_func
(paren
id|path
comma
id|i-&gt;mode
comma
id|devtype
)paren
OL
l_int|0
)paren
(brace
id|perror
c_func
(paren
id|path
)paren
suffix:semicolon
m_exit
(paren
l_int|8
)paren
suffix:semicolon
)brace
id|change_file_status
c_func
(paren
id|path
comma
id|i
)paren
suffix:semicolon
)brace
)brace
DECL|function|do_uncompress
r_static
r_void
id|do_uncompress
c_func
(paren
r_int
id|fd
comma
r_int
r_int
id|offset
comma
r_int
r_int
id|size
)paren
(brace
r_int
r_int
id|curr
op_assign
id|offset
op_plus
l_int|4
op_star
(paren
(paren
id|size
op_plus
id|PAGE_CACHE_SIZE
op_minus
l_int|1
)paren
op_div
id|PAGE_CACHE_SIZE
)paren
suffix:semicolon
r_do
(brace
r_int
r_int
id|out
op_assign
id|PAGE_CACHE_SIZE
suffix:semicolon
r_int
r_int
id|next
op_assign
op_star
(paren
id|u32
op_star
)paren
id|romfs_read
c_func
(paren
id|offset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|next
OG
id|end_data
)paren
(brace
id|end_data
op_assign
id|next
suffix:semicolon
)brace
id|offset
op_add_assign
l_int|4
suffix:semicolon
r_if
c_cond
(paren
id|curr
op_eq
id|next
)paren
(brace
r_if
c_cond
(paren
id|opt_verbose
OG
l_int|1
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;  hole at %ld (%d)&bslash;n&quot;
comma
id|curr
comma
id|PAGE_CACHE_SIZE
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|size
OL
id|PAGE_CACHE_SIZE
)paren
id|out
op_assign
id|size
suffix:semicolon
id|memset
c_func
(paren
id|outbuffer
comma
l_int|0x00
comma
id|out
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|opt_verbose
OG
l_int|1
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;  uncompressing block at %ld to %ld (%ld)&bslash;n&quot;
comma
id|curr
comma
id|next
comma
id|next
op_minus
id|curr
)paren
suffix:semicolon
)brace
id|out
op_assign
id|uncompress_block
c_func
(paren
id|romfs_read
c_func
(paren
id|curr
)paren
comma
id|next
op_minus
id|curr
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|size
op_ge
id|PAGE_CACHE_SIZE
)paren
(brace
r_if
c_cond
(paren
id|out
op_ne
id|PAGE_CACHE_SIZE
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;%s: Non-block (%ld) bytes&bslash;n&quot;
comma
id|filename
comma
id|out
)paren
suffix:semicolon
m_exit
(paren
l_int|4
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|out
op_ne
id|size
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;%s: Non-size (%ld vs %ld) bytes&bslash;n&quot;
comma
id|filename
comma
id|out
comma
id|size
)paren
suffix:semicolon
m_exit
(paren
l_int|4
)paren
suffix:semicolon
)brace
)brace
id|size
op_sub_assign
id|out
suffix:semicolon
r_if
c_cond
(paren
id|opt_extract
)paren
(brace
id|write
c_func
(paren
id|fd
comma
id|outbuffer
comma
id|out
)paren
suffix:semicolon
)brace
id|curr
op_assign
id|next
suffix:semicolon
)brace
r_while
c_loop
(paren
id|size
)paren
suffix:semicolon
)brace
DECL|function|expand_fs
r_static
r_void
id|expand_fs
c_func
(paren
r_int
id|pathlen
comma
r_char
op_star
id|path
comma
r_struct
id|cramfs_inode
op_star
id|inode
)paren
(brace
r_if
c_cond
(paren
id|S_ISDIR
c_func
(paren
id|inode-&gt;mode
)paren
)paren
(brace
r_int
id|count
op_assign
id|inode-&gt;size
suffix:semicolon
r_int
r_int
id|offset
op_assign
id|inode-&gt;offset
op_lshift
l_int|2
suffix:semicolon
r_char
op_star
id|newpath
op_assign
id|malloc
c_func
(paren
id|pathlen
op_plus
l_int|256
)paren
suffix:semicolon
r_if
c_cond
(paren
id|count
OG
l_int|0
op_logical_and
id|offset
OL
id|start_inode
)paren
(brace
id|start_inode
op_assign
id|offset
suffix:semicolon
)brace
multiline_comment|/* XXX - need to check end_inode for empty case? */
id|memcpy
c_func
(paren
id|newpath
comma
id|path
comma
id|pathlen
)paren
suffix:semicolon
id|newpath
(braket
id|pathlen
)braket
op_assign
l_char|&squot;/&squot;
suffix:semicolon
id|pathlen
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|opt_verbose
)paren
(brace
id|print_node
c_func
(paren
l_char|&squot;d&squot;
comma
id|inode
comma
id|path
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|opt_extract
)paren
(brace
id|mkdir
c_func
(paren
id|path
comma
id|inode-&gt;mode
)paren
suffix:semicolon
id|change_file_status
c_func
(paren
id|path
comma
id|inode
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|count
OG
l_int|0
)paren
(brace
r_struct
id|cramfs_inode
op_star
id|child
op_assign
id|iget
c_func
(paren
id|offset
)paren
suffix:semicolon
r_int
id|size
suffix:semicolon
r_int
id|newlen
op_assign
id|child-&gt;namelen
op_lshift
l_int|2
suffix:semicolon
id|size
op_assign
r_sizeof
(paren
r_struct
id|cramfs_inode
)paren
op_plus
id|newlen
suffix:semicolon
id|count
op_sub_assign
id|size
suffix:semicolon
id|offset
op_add_assign
r_sizeof
(paren
r_struct
id|cramfs_inode
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|newpath
op_plus
id|pathlen
comma
id|romfs_read
c_func
(paren
id|offset
)paren
comma
id|newlen
)paren
suffix:semicolon
id|newpath
(braket
id|pathlen
op_plus
id|newlen
)braket
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|pathlen
op_plus
id|newlen
)paren
op_minus
id|strlen
c_func
(paren
id|newpath
)paren
OG
l_int|3
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;%s: invalid cramfs--bad path length&bslash;n&quot;
comma
id|filename
)paren
suffix:semicolon
m_exit
(paren
l_int|4
)paren
suffix:semicolon
)brace
id|expand_fs
c_func
(paren
id|strlen
c_func
(paren
id|newpath
)paren
comma
id|newpath
comma
id|child
)paren
suffix:semicolon
id|offset
op_add_assign
id|newlen
suffix:semicolon
r_if
c_cond
(paren
id|offset
OG
id|end_inode
)paren
(brace
id|end_inode
op_assign
id|offset
suffix:semicolon
)brace
)brace
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|S_ISREG
c_func
(paren
id|inode-&gt;mode
)paren
)paren
(brace
r_int
id|fd
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|offset
op_assign
id|inode-&gt;offset
op_lshift
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|offset
OG
l_int|0
op_logical_and
id|offset
OL
id|start_data
)paren
(brace
id|start_data
op_assign
id|offset
suffix:semicolon
)brace
r_if
c_cond
(paren
id|opt_verbose
)paren
(brace
id|print_node
c_func
(paren
l_char|&squot;f&squot;
comma
id|inode
comma
id|path
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|opt_extract
)paren
(brace
id|fd
op_assign
id|open
c_func
(paren
id|path
comma
id|O_WRONLY
op_or
id|O_CREAT
op_or
id|O_TRUNC
comma
id|inode-&gt;mode
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|inode-&gt;size
)paren
(brace
id|do_uncompress
c_func
(paren
id|fd
comma
id|offset
comma
id|inode-&gt;size
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|opt_extract
)paren
(brace
id|close
c_func
(paren
id|fd
)paren
suffix:semicolon
id|change_file_status
c_func
(paren
id|path
comma
id|inode
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|S_ISLNK
c_func
(paren
id|inode-&gt;mode
)paren
)paren
(brace
r_int
r_int
id|offset
op_assign
id|inode-&gt;offset
op_lshift
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|offset
OL
id|start_data
)paren
(brace
id|start_data
op_assign
id|offset
suffix:semicolon
)brace
id|do_symlink
c_func
(paren
id|path
comma
id|inode
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
(brace
id|do_special_inode
c_func
(paren
id|path
comma
id|inode
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
macro_line|#endif /* INCLUDE_FS_TESTS */
DECL|function|main
r_int
id|main
c_func
(paren
r_int
id|argc
comma
r_char
op_star
op_star
id|argv
)paren
(brace
r_void
op_star
id|buf
suffix:semicolon
r_int
id|length
suffix:semicolon
r_struct
id|stat
id|st
suffix:semicolon
id|u32
id|crc_old
comma
id|crc_new
suffix:semicolon
macro_line|#ifdef INCLUDE_FS_TESTS
r_struct
id|cramfs_inode
op_star
id|root
suffix:semicolon
macro_line|#endif /* INCLUDE_FS_TESTS */
r_int
id|c
suffix:semicolon
multiline_comment|/* for getopt */
r_int
id|start
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|argc
)paren
id|progname
op_assign
id|argv
(braket
l_int|0
)braket
suffix:semicolon
multiline_comment|/* command line options */
r_while
c_loop
(paren
(paren
id|c
op_assign
id|getopt
c_func
(paren
id|argc
comma
id|argv
comma
l_string|&quot;hx:v&quot;
)paren
)paren
op_ne
id|EOF
)paren
(brace
r_switch
c_cond
(paren
id|c
)paren
(brace
r_case
l_char|&squot;h&squot;
suffix:colon
id|usage
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_case
l_char|&squot;x&squot;
suffix:colon
macro_line|#ifdef INCLUDE_FS_TESTS
id|opt_extract
op_assign
l_int|1
suffix:semicolon
id|extract_dir
op_assign
id|malloc
c_func
(paren
id|strlen
c_func
(paren
id|optarg
)paren
op_plus
l_int|1
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|extract_dir
comma
id|optarg
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#else /*  not INCLUDE_FS_TESTS */
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;%s: compiled without -x support&bslash;n&quot;
comma
id|progname
)paren
suffix:semicolon
m_exit
(paren
l_int|16
)paren
suffix:semicolon
macro_line|#endif /* not INCLUDE_FS_TESTS */
r_case
l_char|&squot;v&squot;
suffix:colon
id|opt_verbose
op_increment
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
(paren
id|argc
op_minus
id|optind
)paren
op_ne
l_int|1
)paren
id|usage
c_func
(paren
l_int|16
)paren
suffix:semicolon
id|filename
op_assign
id|argv
(braket
id|optind
)braket
suffix:semicolon
multiline_comment|/* find the physical size of the file or block device */
r_if
c_cond
(paren
id|lstat
c_func
(paren
id|filename
comma
op_amp
id|st
)paren
OL
l_int|0
)paren
(brace
id|perror
c_func
(paren
id|filename
)paren
suffix:semicolon
m_exit
(paren
l_int|8
)paren
suffix:semicolon
)brace
id|fd
op_assign
id|open
c_func
(paren
id|filename
comma
id|O_RDONLY
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fd
OL
l_int|0
)paren
(brace
id|perror
c_func
(paren
id|filename
)paren
suffix:semicolon
m_exit
(paren
l_int|8
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|S_ISBLK
c_func
(paren
id|st.st_mode
)paren
)paren
(brace
r_if
c_cond
(paren
id|ioctl
c_func
(paren
id|fd
comma
id|BLKGETSIZE
comma
op_amp
id|length
)paren
OL
l_int|0
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;%s: warning--unable to determine filesystem size &bslash;n&quot;
comma
id|filename
)paren
suffix:semicolon
m_exit
(paren
l_int|4
)paren
suffix:semicolon
)brace
id|length
op_assign
id|length
op_star
l_int|512
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|S_ISREG
c_func
(paren
id|st.st_mode
)paren
)paren
(brace
id|length
op_assign
id|st.st_size
suffix:semicolon
)brace
r_else
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;%s is not a block device or file&bslash;n&quot;
comma
id|filename
)paren
suffix:semicolon
m_exit
(paren
l_int|8
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|length
OL
r_sizeof
(paren
r_struct
id|cramfs_super
)paren
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;%s: invalid cramfs--file length too short&bslash;n&quot;
comma
id|filename
)paren
suffix:semicolon
m_exit
(paren
l_int|4
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|S_ISBLK
c_func
(paren
id|st.st_mode
)paren
)paren
(brace
multiline_comment|/* nasty because mmap of block devices fails */
id|buf
op_assign
id|mmap
c_func
(paren
l_int|NULL
comma
id|length
comma
id|PROT_READ
op_or
id|PROT_WRITE
comma
id|MAP_PRIVATE
op_or
id|MAP_ANONYMOUS
comma
op_minus
l_int|1
comma
l_int|0
)paren
suffix:semicolon
id|read
c_func
(paren
id|fd
comma
id|buf
comma
id|length
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* nice and easy */
id|buf
op_assign
id|mmap
c_func
(paren
l_int|NULL
comma
id|length
comma
id|PROT_READ
op_or
id|PROT_WRITE
comma
id|MAP_PRIVATE
comma
id|fd
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* XXX - this could be cleaner... */
r_if
c_cond
(paren
(paren
(paren
r_struct
id|cramfs_super
op_star
)paren
id|buf
)paren
op_member_access_from_pointer
id|magic
op_eq
id|CRAMFS_MAGIC
)paren
(brace
id|start
op_assign
l_int|0
suffix:semicolon
id|super
op_assign
(paren
r_struct
id|cramfs_super
op_star
)paren
id|buf
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|length
op_ge
(paren
id|PAD_SIZE
op_plus
r_sizeof
(paren
r_struct
id|cramfs_super
)paren
)paren
op_logical_and
(paren
(paren
(paren
(paren
r_struct
id|cramfs_super
op_star
)paren
(paren
id|buf
op_plus
id|PAD_SIZE
)paren
)paren
op_member_access_from_pointer
id|magic
op_eq
id|CRAMFS_MAGIC
)paren
)paren
)paren
(brace
id|start
op_assign
id|PAD_SIZE
suffix:semicolon
id|super
op_assign
(paren
r_struct
id|cramfs_super
op_star
)paren
(paren
id|buf
op_plus
id|PAD_SIZE
)paren
suffix:semicolon
)brace
r_else
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;%s: invalid cramfs--wrong magic&bslash;n&quot;
comma
id|filename
)paren
suffix:semicolon
m_exit
(paren
l_int|4
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|super-&gt;flags
op_amp
id|CRAMFS_FLAG_FSID_VERSION_2
)paren
(brace
multiline_comment|/* length test */
r_if
c_cond
(paren
id|length
OL
id|super-&gt;size
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;%s: invalid cramfs--file length too short&bslash;n&quot;
comma
id|filename
)paren
suffix:semicolon
m_exit
(paren
l_int|4
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|length
OG
id|super-&gt;size
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;%s: warning--file length too long, padded image?&bslash;n&quot;
comma
id|filename
)paren
suffix:semicolon
)brace
multiline_comment|/* CRC test */
id|crc_old
op_assign
id|super-&gt;fsid.crc
suffix:semicolon
id|super-&gt;fsid.crc
op_assign
id|crc32
c_func
(paren
l_int|0L
comma
id|Z_NULL
comma
l_int|0
)paren
suffix:semicolon
id|crc_new
op_assign
id|crc32
c_func
(paren
l_int|0L
comma
id|Z_NULL
comma
l_int|0
)paren
suffix:semicolon
id|crc_new
op_assign
id|crc32
c_func
(paren
id|crc_new
comma
(paren
r_int
r_char
op_star
)paren
id|buf
op_plus
id|start
comma
id|super-&gt;size
op_minus
id|start
)paren
suffix:semicolon
r_if
c_cond
(paren
id|crc_new
op_ne
id|crc_old
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;%s: invalid cramfs--crc error&bslash;n&quot;
comma
id|filename
)paren
suffix:semicolon
m_exit
(paren
l_int|4
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;%s: warning--old cramfs image, no CRC&bslash;n&quot;
comma
id|filename
)paren
suffix:semicolon
)brace
macro_line|#ifdef INCLUDE_FS_TESTS
id|super
op_assign
(paren
r_struct
id|cramfs_super
op_star
)paren
id|malloc
c_func
(paren
r_sizeof
(paren
r_struct
id|cramfs_super
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
r_struct
id|cramfs_super
op_star
)paren
id|buf
)paren
op_member_access_from_pointer
id|magic
op_eq
id|CRAMFS_MAGIC
)paren
(brace
id|memcpy
c_func
(paren
id|super
comma
id|buf
comma
r_sizeof
(paren
r_struct
id|cramfs_super
)paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|length
op_ge
(paren
id|PAD_SIZE
op_plus
r_sizeof
(paren
r_struct
id|cramfs_super
)paren
)paren
op_logical_and
(paren
(paren
(paren
(paren
r_struct
id|cramfs_super
op_star
)paren
(paren
id|buf
op_plus
id|PAD_SIZE
)paren
)paren
op_member_access_from_pointer
id|magic
op_eq
id|CRAMFS_MAGIC
)paren
)paren
)paren
(brace
id|memcpy
c_func
(paren
id|super
comma
(paren
id|buf
op_plus
id|PAD_SIZE
)paren
comma
r_sizeof
(paren
r_struct
id|cramfs_super
)paren
)paren
suffix:semicolon
)brace
id|munmap
c_func
(paren
id|buf
comma
id|length
)paren
suffix:semicolon
multiline_comment|/* file format test, uses fake &quot;blocked&quot; accesses */
id|root
op_assign
id|read_super
c_func
(paren
)paren
suffix:semicolon
id|umask
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|euid
op_assign
id|geteuid
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|root
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;%s: invalid cramfs--bad superblock&bslash;n&quot;
comma
id|filename
)paren
suffix:semicolon
m_exit
(paren
l_int|4
)paren
suffix:semicolon
)brace
id|stream.next_in
op_assign
l_int|NULL
suffix:semicolon
id|stream.avail_in
op_assign
l_int|0
suffix:semicolon
id|inflateInit
c_func
(paren
op_amp
id|stream
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|extract_dir
)paren
(brace
id|extract_dir
op_assign
l_string|&quot;root&quot;
suffix:semicolon
)brace
id|expand_fs
c_func
(paren
id|strlen
c_func
(paren
id|extract_dir
)paren
comma
id|extract_dir
comma
id|root
)paren
suffix:semicolon
id|inflateEnd
c_func
(paren
op_amp
id|stream
)paren
suffix:semicolon
r_if
c_cond
(paren
id|start_data
op_ne
l_int|1
op_lshift
l_int|28
op_logical_and
id|end_inode
op_ne
id|start_data
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;%s: invalid cramfs--directory data end (%ld) != file data start (%ld)&bslash;n&quot;
comma
id|filename
comma
id|end_inode
comma
id|start_data
)paren
suffix:semicolon
m_exit
(paren
l_int|4
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|super-&gt;flags
op_amp
id|CRAMFS_FLAG_FSID_VERSION_2
)paren
(brace
r_if
c_cond
(paren
id|end_data
OG
id|super-&gt;size
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;%s: invalid cramfs--invalid file data offset&bslash;n&quot;
comma
id|filename
)paren
suffix:semicolon
m_exit
(paren
l_int|4
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif /* INCLUDE_FS_TESTS */
m_exit
(paren
l_int|0
)paren
suffix:semicolon
)brace
eof
