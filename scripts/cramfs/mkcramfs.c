multiline_comment|/*&n; * mkcramfs - make a cramfs file system&n; *&n; * Copyright (C) 1999-2001 Transmeta Corporation&n; *&n; * This program is free software; you can redistribute it and/or modify&n; * it under the terms of the GNU General Public License as published by&n; * the Free Software Foundation; either version 2 of the License, or&n; * (at your option) any later version.&n; *&n; * This program is distributed in the hope that it will be useful,&n; * but WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; * GNU General Public License for more details.&n; *&n; * You should have received a copy of the GNU General Public License&n; * along with this program; if not, write to the Free Software&n; * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA&n; */
macro_line|#include &lt;sys/types.h&gt;
macro_line|#include &lt;stdio.h&gt;
macro_line|#include &lt;sys/stat.h&gt;
macro_line|#include &lt;unistd.h&gt;
macro_line|#include &lt;sys/mman.h&gt;
macro_line|#include &lt;sys/fcntl.h&gt;
macro_line|#include &lt;dirent.h&gt;
macro_line|#include &lt;stdlib.h&gt;
macro_line|#include &lt;errno.h&gt;
macro_line|#include &lt;string.h&gt;
macro_line|#include &lt;assert.h&gt;
macro_line|#include &lt;getopt.h&gt;
macro_line|#include &lt;linux/cramfs_fs.h&gt;
macro_line|#include &lt;zlib.h&gt;
DECL|macro|PAD_SIZE
mdefine_line|#define PAD_SIZE 512&t;&t;/* only 0 and 512 supported by kernel */
DECL|variable|progname
r_static
r_const
r_char
op_star
id|progname
op_assign
l_string|&quot;mkcramfs&quot;
suffix:semicolon
multiline_comment|/* N.B. If you change the disk format of cramfs, please update fs/cramfs/README. */
multiline_comment|/* Input status of 0 to print help and exit without an error. */
DECL|function|usage
r_static
r_void
id|usage
c_func
(paren
r_int
id|status
)paren
(brace
id|FILE
op_star
id|stream
op_assign
id|status
ques
c_cond
id|stderr
suffix:colon
id|stdout
suffix:semicolon
id|fprintf
c_func
(paren
id|stream
comma
l_string|&quot;usage: %s [-h] [-e edition] [-i file] [-n name] dirname outfile&bslash;n&quot;
l_string|&quot; -h         print this help&bslash;n&quot;
l_string|&quot; -E         make all warnings errors (non-zero exit status)&bslash;n&quot;
l_string|&quot; -e edition set edition number (part of fsid)&bslash;n&quot;
l_string|&quot; -i file    insert a file image into the filesystem (requires &gt;= 2.4.0)&bslash;n&quot;
l_string|&quot; -n name    set name of cramfs filesystem&bslash;n&quot;
l_string|&quot; -p         pad by %d bytes for boot code&bslash;n&quot;
l_string|&quot; -s         sort directory entries (old option, ignored)&bslash;n&quot;
l_string|&quot; -z         make explicit holes (requires &gt;= 2.3.39)&bslash;n&quot;
l_string|&quot; dirname    root of the filesystem to be compressed&bslash;n&quot;
l_string|&quot; outfile    output file&bslash;n&quot;
comma
id|progname
comma
id|PAD_SIZE
)paren
suffix:semicolon
m_exit
(paren
id|status
)paren
suffix:semicolon
)brace
DECL|macro|PAGE_CACHE_SIZE
mdefine_line|#define PAGE_CACHE_SIZE (4096)
multiline_comment|/* The kernel assumes PAGE_CACHE_SIZE as block size. */
DECL|variable|blksize
r_static
r_int
r_int
id|blksize
op_assign
id|PAGE_CACHE_SIZE
suffix:semicolon
DECL|variable|total_blocks
DECL|variable|total_nodes
r_static
r_int
id|total_blocks
op_assign
l_int|0
comma
id|total_nodes
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* pre-count the root node */
DECL|variable|image_length
r_static
r_int
id|image_length
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n; * If opt_holes is set, then mkcramfs can create explicit holes in the&n; * data, which saves 26 bytes per hole (which is a lot smaller a&n; * saving than most most filesystems).&n; *&n; * Note that kernels up to at least 2.3.39 don&squot;t support cramfs holes,&n; * which is why this is turned off by default.&n; */
DECL|variable|opt_edition
r_static
r_int
id|opt_edition
op_assign
l_int|0
suffix:semicolon
DECL|variable|opt_errors
r_static
r_int
id|opt_errors
op_assign
l_int|0
suffix:semicolon
DECL|variable|opt_holes
r_static
r_int
id|opt_holes
op_assign
l_int|0
suffix:semicolon
DECL|variable|opt_pad
r_static
r_int
id|opt_pad
op_assign
l_int|0
suffix:semicolon
DECL|variable|opt_image
r_static
r_char
op_star
id|opt_image
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|opt_name
r_static
r_char
op_star
id|opt_name
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|warn_dev
DECL|variable|warn_gid
DECL|variable|warn_namelen
DECL|variable|warn_skip
DECL|variable|warn_size
DECL|variable|warn_uid
r_static
r_int
id|warn_dev
comma
id|warn_gid
comma
id|warn_namelen
comma
id|warn_skip
comma
id|warn_size
comma
id|warn_uid
suffix:semicolon
macro_line|#ifndef MIN
DECL|macro|MIN
macro_line|# define MIN(_a,_b) ((_a) &lt; (_b) ? (_a) : (_b))
macro_line|#endif
multiline_comment|/* In-core version of inode / directory entry. */
DECL|struct|entry
r_struct
id|entry
(brace
multiline_comment|/* stats */
DECL|member|name
r_char
op_star
id|name
suffix:semicolon
DECL|member|mode
DECL|member|size
DECL|member|uid
DECL|member|gid
r_int
r_int
id|mode
comma
id|size
comma
id|uid
comma
id|gid
suffix:semicolon
multiline_comment|/* FS data */
DECL|member|uncompressed
r_void
op_star
id|uncompressed
suffix:semicolon
multiline_comment|/* points to other identical file */
DECL|member|same
r_struct
id|entry
op_star
id|same
suffix:semicolon
DECL|member|offset
r_int
r_int
id|offset
suffix:semicolon
multiline_comment|/* pointer to compressed data in archive */
DECL|member|dir_offset
r_int
r_int
id|dir_offset
suffix:semicolon
multiline_comment|/* Where in the archive is the directory entry? */
multiline_comment|/* organization */
DECL|member|child
r_struct
id|entry
op_star
id|child
suffix:semicolon
multiline_comment|/* null for non-directories and empty directories */
DECL|member|next
r_struct
id|entry
op_star
id|next
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * The longest file name component to allow for in the input directory tree.&n; * Ext2fs (and many others) allow up to 255 bytes.  A couple of filesystems&n; * allow longer (e.g. smbfs 1024), but there isn&squot;t much use in supporting&n; * &gt;255-byte names in the input directory tree given that such names get&n; * truncated to 255 bytes when written to cramfs.&n; */
DECL|macro|MAX_INPUT_NAMELEN
mdefine_line|#define MAX_INPUT_NAMELEN 255
DECL|function|find_identical_file
r_static
r_int
id|find_identical_file
c_func
(paren
r_struct
id|entry
op_star
id|orig
comma
r_struct
id|entry
op_star
id|newfile
)paren
(brace
r_if
c_cond
(paren
id|orig
op_eq
id|newfile
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|orig
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|orig-&gt;size
op_eq
id|newfile-&gt;size
op_logical_and
id|orig-&gt;uncompressed
op_logical_and
op_logical_neg
id|memcmp
c_func
(paren
id|orig-&gt;uncompressed
comma
id|newfile-&gt;uncompressed
comma
id|orig-&gt;size
)paren
)paren
(brace
id|newfile-&gt;same
op_assign
id|orig
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
id|find_identical_file
c_func
(paren
id|orig-&gt;child
comma
id|newfile
)paren
op_logical_or
id|find_identical_file
c_func
(paren
id|orig-&gt;next
comma
id|newfile
)paren
suffix:semicolon
)brace
DECL|function|eliminate_doubles
r_static
r_void
id|eliminate_doubles
c_func
(paren
r_struct
id|entry
op_star
id|root
comma
r_struct
id|entry
op_star
id|orig
)paren
(brace
r_if
c_cond
(paren
id|orig
)paren
(brace
r_if
c_cond
(paren
id|orig-&gt;size
op_logical_and
id|orig-&gt;uncompressed
)paren
(brace
id|find_identical_file
c_func
(paren
id|root
comma
id|orig
)paren
suffix:semicolon
)brace
id|eliminate_doubles
c_func
(paren
id|root
comma
id|orig-&gt;child
)paren
suffix:semicolon
id|eliminate_doubles
c_func
(paren
id|root
comma
id|orig-&gt;next
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * We define our own sorting function instead of using alphasort which&n; * uses strcoll and changes ordering based on locale information.&n; */
DECL|function|cramsort
r_static
r_int
id|cramsort
(paren
r_const
r_void
op_star
id|a
comma
r_const
r_void
op_star
id|b
)paren
(brace
r_return
id|strcmp
(paren
(paren
op_star
(paren
r_const
r_struct
id|dirent
op_star
op_star
)paren
id|a
)paren
op_member_access_from_pointer
id|d_name
comma
(paren
op_star
(paren
r_const
r_struct
id|dirent
op_star
op_star
)paren
id|b
)paren
op_member_access_from_pointer
id|d_name
)paren
suffix:semicolon
)brace
DECL|function|parse_directory
r_static
r_int
r_int
id|parse_directory
c_func
(paren
r_struct
id|entry
op_star
id|root_entry
comma
r_const
r_char
op_star
id|name
comma
r_struct
id|entry
op_star
op_star
id|prev
comma
id|loff_t
op_star
id|fslen_ub
)paren
(brace
r_struct
id|dirent
op_star
op_star
id|dirlist
suffix:semicolon
r_int
id|totalsize
op_assign
l_int|0
comma
id|dircount
comma
id|dirindex
suffix:semicolon
r_char
op_star
id|path
comma
op_star
id|endpath
suffix:semicolon
r_int
id|len
op_assign
id|strlen
c_func
(paren
id|name
)paren
suffix:semicolon
multiline_comment|/* Set up the path. */
multiline_comment|/* TODO: Reuse the parent&squot;s buffer to save memcpy&squot;ing and duplication. */
id|path
op_assign
id|malloc
c_func
(paren
id|len
op_plus
l_int|1
op_plus
id|MAX_INPUT_NAMELEN
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|path
)paren
(brace
id|perror
c_func
(paren
l_int|NULL
)paren
suffix:semicolon
m_exit
(paren
l_int|8
)paren
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|path
comma
id|name
comma
id|len
)paren
suffix:semicolon
id|endpath
op_assign
id|path
op_plus
id|len
suffix:semicolon
op_star
id|endpath
op_assign
l_char|&squot;/&squot;
suffix:semicolon
id|endpath
op_increment
suffix:semicolon
multiline_comment|/* read in the directory and sort */
id|dircount
op_assign
id|scandir
c_func
(paren
id|name
comma
op_amp
id|dirlist
comma
l_int|0
comma
id|cramsort
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dircount
OL
l_int|0
)paren
(brace
id|perror
c_func
(paren
id|name
)paren
suffix:semicolon
m_exit
(paren
l_int|8
)paren
suffix:semicolon
)brace
multiline_comment|/* process directory */
r_for
c_loop
(paren
id|dirindex
op_assign
l_int|0
suffix:semicolon
id|dirindex
OL
id|dircount
suffix:semicolon
id|dirindex
op_increment
)paren
(brace
r_struct
id|dirent
op_star
id|dirent
suffix:semicolon
r_struct
id|entry
op_star
id|entry
suffix:semicolon
r_struct
id|stat
id|st
suffix:semicolon
r_int
id|size
suffix:semicolon
r_int
id|namelen
suffix:semicolon
id|dirent
op_assign
id|dirlist
(braket
id|dirindex
)braket
suffix:semicolon
multiline_comment|/* Ignore &quot;.&quot; and &quot;..&quot; - we won&squot;t be adding them to the archive */
r_if
c_cond
(paren
id|dirent-&gt;d_name
(braket
l_int|0
)braket
op_eq
l_char|&squot;.&squot;
)paren
(brace
r_if
c_cond
(paren
id|dirent-&gt;d_name
(braket
l_int|1
)braket
op_eq
l_char|&squot;&bslash;0&squot;
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|dirent-&gt;d_name
(braket
l_int|1
)braket
op_eq
l_char|&squot;.&squot;
)paren
(brace
r_if
c_cond
(paren
id|dirent-&gt;d_name
(braket
l_int|2
)braket
op_eq
l_char|&squot;&bslash;0&squot;
)paren
r_continue
suffix:semicolon
)brace
)brace
id|namelen
op_assign
id|strlen
c_func
(paren
id|dirent-&gt;d_name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|namelen
OG
id|MAX_INPUT_NAMELEN
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Very long (%u bytes) filename `%s&squot; found.&bslash;n&quot;
l_string|&quot; Please increase MAX_INPUT_NAMELEN in mkcramfs.c and recompile.  Exiting.&bslash;n&quot;
comma
id|namelen
comma
id|dirent-&gt;d_name
)paren
suffix:semicolon
m_exit
(paren
l_int|8
)paren
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|endpath
comma
id|dirent-&gt;d_name
comma
id|namelen
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lstat
c_func
(paren
id|path
comma
op_amp
id|st
)paren
OL
l_int|0
)paren
(brace
id|perror
c_func
(paren
id|endpath
)paren
suffix:semicolon
id|warn_skip
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|entry
op_assign
id|calloc
c_func
(paren
l_int|1
comma
r_sizeof
(paren
r_struct
id|entry
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|entry
)paren
(brace
id|perror
c_func
(paren
l_int|NULL
)paren
suffix:semicolon
m_exit
(paren
l_int|8
)paren
suffix:semicolon
)brace
id|entry-&gt;name
op_assign
id|strdup
c_func
(paren
id|dirent-&gt;d_name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|entry-&gt;name
)paren
(brace
id|perror
c_func
(paren
l_int|NULL
)paren
suffix:semicolon
m_exit
(paren
l_int|8
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|namelen
OG
l_int|255
)paren
(brace
multiline_comment|/* Can&squot;t happen when reading from ext2fs. */
multiline_comment|/* TODO: we ought to avoid chopping in half&n;&t;&t;&t;   multi-byte UTF8 characters. */
id|entry-&gt;name
(braket
id|namelen
op_assign
l_int|255
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|warn_namelen
op_assign
l_int|1
suffix:semicolon
)brace
id|entry-&gt;mode
op_assign
id|st.st_mode
suffix:semicolon
id|entry-&gt;size
op_assign
id|st.st_size
suffix:semicolon
id|entry-&gt;uid
op_assign
id|st.st_uid
suffix:semicolon
r_if
c_cond
(paren
id|entry-&gt;uid
op_ge
l_int|1
op_lshift
id|CRAMFS_UID_WIDTH
)paren
id|warn_uid
op_assign
l_int|1
suffix:semicolon
id|entry-&gt;gid
op_assign
id|st.st_gid
suffix:semicolon
r_if
c_cond
(paren
id|entry-&gt;gid
op_ge
l_int|1
op_lshift
id|CRAMFS_GID_WIDTH
)paren
multiline_comment|/* TODO: We ought to replace with a default&n;                           gid instead of truncating; otherwise there&n;                           are security problems.  Maybe mode should&n;                           be &amp;= ~070.  Same goes for uid once Linux&n;                           supports &gt;16-bit uids. */
id|warn_gid
op_assign
l_int|1
suffix:semicolon
id|size
op_assign
r_sizeof
(paren
r_struct
id|cramfs_inode
)paren
op_plus
(paren
(paren
id|namelen
op_plus
l_int|3
)paren
op_amp
op_complement
l_int|3
)paren
suffix:semicolon
op_star
id|fslen_ub
op_add_assign
id|size
suffix:semicolon
r_if
c_cond
(paren
id|S_ISDIR
c_func
(paren
id|st.st_mode
)paren
)paren
(brace
id|entry-&gt;size
op_assign
id|parse_directory
c_func
(paren
id|root_entry
comma
id|path
comma
op_amp
id|entry-&gt;child
comma
id|fslen_ub
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|S_ISREG
c_func
(paren
id|st.st_mode
)paren
)paren
(brace
multiline_comment|/* TODO: We ought to open files in do_compress, one&n;&t;&t;&t;   at a time, instead of amassing all these memory&n;&t;&t;&t;   maps during parse_directory (which don&squot;t get used&n;&t;&t;&t;   until do_compress anyway).  As it is, we tend to&n;&t;&t;&t;   get EMFILE errors (especially if mkcramfs is run&n;&t;&t;&t;   by non-root).&n;&n;&t;&t;&t;   While we&squot;re at it, do analagously for symlinks&n;&t;&t;&t;   (which would just save a little memory). */
r_int
id|fd
op_assign
id|open
c_func
(paren
id|path
comma
id|O_RDONLY
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fd
OL
l_int|0
)paren
(brace
id|perror
c_func
(paren
id|path
)paren
suffix:semicolon
id|warn_skip
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|entry-&gt;size
)paren
(brace
r_if
c_cond
(paren
(paren
id|entry-&gt;size
op_ge
l_int|1
op_lshift
id|CRAMFS_SIZE_WIDTH
)paren
)paren
(brace
id|warn_size
op_assign
l_int|1
suffix:semicolon
id|entry-&gt;size
op_assign
(paren
l_int|1
op_lshift
id|CRAMFS_SIZE_WIDTH
)paren
op_minus
l_int|1
suffix:semicolon
)brace
id|entry-&gt;uncompressed
op_assign
id|mmap
c_func
(paren
l_int|NULL
comma
id|entry-&gt;size
comma
id|PROT_READ
comma
id|MAP_PRIVATE
comma
id|fd
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_minus
l_int|1
op_eq
(paren
r_int
)paren
(paren
r_int
)paren
id|entry-&gt;uncompressed
)paren
(brace
id|perror
c_func
(paren
l_string|&quot;mmap&quot;
)paren
suffix:semicolon
m_exit
(paren
l_int|8
)paren
suffix:semicolon
)brace
)brace
id|close
c_func
(paren
id|fd
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|S_ISLNK
c_func
(paren
id|st.st_mode
)paren
)paren
(brace
id|entry-&gt;uncompressed
op_assign
id|malloc
c_func
(paren
id|entry-&gt;size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|entry-&gt;uncompressed
)paren
(brace
id|perror
c_func
(paren
l_int|NULL
)paren
suffix:semicolon
m_exit
(paren
l_int|8
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|readlink
c_func
(paren
id|path
comma
id|entry-&gt;uncompressed
comma
id|entry-&gt;size
)paren
OL
l_int|0
)paren
(brace
id|perror
c_func
(paren
id|path
)paren
suffix:semicolon
id|warn_skip
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|S_ISFIFO
c_func
(paren
id|st.st_mode
)paren
op_logical_or
id|S_ISSOCK
c_func
(paren
id|st.st_mode
)paren
)paren
(brace
multiline_comment|/* maybe we should skip sockets */
id|entry-&gt;size
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|entry-&gt;size
op_assign
id|st.st_rdev
suffix:semicolon
r_if
c_cond
(paren
id|entry-&gt;size
op_amp
op_minus
(paren
l_int|1
op_lshift
id|CRAMFS_SIZE_WIDTH
)paren
)paren
id|warn_dev
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|S_ISREG
c_func
(paren
id|st.st_mode
)paren
op_logical_or
id|S_ISLNK
c_func
(paren
id|st.st_mode
)paren
)paren
(brace
r_int
id|blocks
op_assign
(paren
(paren
id|entry-&gt;size
op_minus
l_int|1
)paren
op_div
id|blksize
op_plus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* block pointers &amp; data expansion allowance + data */
r_if
c_cond
(paren
id|entry-&gt;size
)paren
(brace
op_star
id|fslen_ub
op_add_assign
(paren
l_int|4
op_plus
l_int|26
)paren
op_star
id|blocks
op_plus
id|entry-&gt;size
op_plus
l_int|3
suffix:semicolon
)brace
)brace
multiline_comment|/* Link it into the list */
op_star
id|prev
op_assign
id|entry
suffix:semicolon
id|prev
op_assign
op_amp
id|entry-&gt;next
suffix:semicolon
id|totalsize
op_add_assign
id|size
suffix:semicolon
)brace
id|free
c_func
(paren
id|path
)paren
suffix:semicolon
id|free
c_func
(paren
id|dirlist
)paren
suffix:semicolon
multiline_comment|/* allocated by scandir() with malloc() */
r_return
id|totalsize
suffix:semicolon
)brace
multiline_comment|/* Returns sizeof(struct cramfs_super), which includes the root inode. */
DECL|function|write_superblock
r_static
r_int
r_int
id|write_superblock
c_func
(paren
r_struct
id|entry
op_star
id|root
comma
r_char
op_star
id|base
comma
r_int
id|size
)paren
(brace
r_struct
id|cramfs_super
op_star
id|super
op_assign
(paren
r_struct
id|cramfs_super
op_star
)paren
id|base
suffix:semicolon
r_int
r_int
id|offset
op_assign
r_sizeof
(paren
r_struct
id|cramfs_super
)paren
op_plus
id|image_length
suffix:semicolon
r_if
c_cond
(paren
id|opt_pad
)paren
(brace
id|offset
op_add_assign
id|opt_pad
suffix:semicolon
)brace
id|super-&gt;magic
op_assign
id|CRAMFS_MAGIC
suffix:semicolon
id|super-&gt;flags
op_assign
id|CRAMFS_FLAG_FSID_VERSION_2
op_or
id|CRAMFS_FLAG_SORTED_DIRS
suffix:semicolon
r_if
c_cond
(paren
id|opt_holes
)paren
id|super-&gt;flags
op_or_assign
id|CRAMFS_FLAG_HOLES
suffix:semicolon
r_if
c_cond
(paren
id|image_length
OG
l_int|0
)paren
id|super-&gt;flags
op_or_assign
id|CRAMFS_FLAG_SHIFTED_ROOT_OFFSET
suffix:semicolon
id|super-&gt;size
op_assign
id|size
suffix:semicolon
id|memcpy
c_func
(paren
id|super-&gt;signature
comma
id|CRAMFS_SIGNATURE
comma
r_sizeof
(paren
id|super-&gt;signature
)paren
)paren
suffix:semicolon
id|super-&gt;fsid.crc
op_assign
id|crc32
c_func
(paren
l_int|0L
comma
id|Z_NULL
comma
l_int|0
)paren
suffix:semicolon
id|super-&gt;fsid.edition
op_assign
id|opt_edition
suffix:semicolon
id|super-&gt;fsid.blocks
op_assign
id|total_blocks
suffix:semicolon
id|super-&gt;fsid.files
op_assign
id|total_nodes
suffix:semicolon
id|memset
c_func
(paren
id|super-&gt;name
comma
l_int|0x00
comma
r_sizeof
(paren
id|super-&gt;name
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|opt_name
)paren
id|strncpy
c_func
(paren
id|super-&gt;name
comma
id|opt_name
comma
r_sizeof
(paren
id|super-&gt;name
)paren
)paren
suffix:semicolon
r_else
id|strncpy
c_func
(paren
id|super-&gt;name
comma
l_string|&quot;Compressed&quot;
comma
r_sizeof
(paren
id|super-&gt;name
)paren
)paren
suffix:semicolon
id|super-&gt;root.mode
op_assign
id|root-&gt;mode
suffix:semicolon
id|super-&gt;root.uid
op_assign
id|root-&gt;uid
suffix:semicolon
id|super-&gt;root.gid
op_assign
id|root-&gt;gid
suffix:semicolon
id|super-&gt;root.size
op_assign
id|root-&gt;size
suffix:semicolon
id|super-&gt;root.offset
op_assign
id|offset
op_rshift
l_int|2
suffix:semicolon
r_return
id|offset
suffix:semicolon
)brace
DECL|function|set_data_offset
r_static
r_void
id|set_data_offset
c_func
(paren
r_struct
id|entry
op_star
id|entry
comma
r_char
op_star
id|base
comma
r_int
r_int
id|offset
)paren
(brace
r_struct
id|cramfs_inode
op_star
id|inode
op_assign
(paren
r_struct
id|cramfs_inode
op_star
)paren
(paren
id|base
op_plus
id|entry-&gt;dir_offset
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
m_assert
(paren
(paren
id|offset
op_amp
l_int|3
)paren
op_eq
l_int|0
)paren
suffix:semicolon
macro_line|#endif /* DEBUG */
r_if
c_cond
(paren
id|offset
op_ge
(paren
l_int|1
op_lshift
(paren
l_int|2
op_plus
id|CRAMFS_OFFSET_WIDTH
)paren
)paren
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;filesystem too big.  Exiting.&bslash;n&quot;
)paren
suffix:semicolon
m_exit
(paren
l_int|8
)paren
suffix:semicolon
)brace
id|inode-&gt;offset
op_assign
(paren
id|offset
op_rshift
l_int|2
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * We do a width-first printout of the directory&n; * entries, using a stack to remember the directories&n; * we&squot;ve seen.&n; */
DECL|macro|MAXENTRIES
mdefine_line|#define MAXENTRIES (100)
DECL|function|write_directory_structure
r_static
r_int
r_int
id|write_directory_structure
c_func
(paren
r_struct
id|entry
op_star
id|entry
comma
r_char
op_star
id|base
comma
r_int
r_int
id|offset
)paren
(brace
r_int
id|stack_entries
op_assign
l_int|0
suffix:semicolon
r_struct
id|entry
op_star
id|entry_stack
(braket
id|MAXENTRIES
)braket
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_int
id|dir_start
op_assign
id|stack_entries
suffix:semicolon
r_while
c_loop
(paren
id|entry
)paren
(brace
r_struct
id|cramfs_inode
op_star
id|inode
op_assign
(paren
r_struct
id|cramfs_inode
op_star
)paren
(paren
id|base
op_plus
id|offset
)paren
suffix:semicolon
r_int
id|len
op_assign
id|strlen
c_func
(paren
id|entry-&gt;name
)paren
suffix:semicolon
id|entry-&gt;dir_offset
op_assign
id|offset
suffix:semicolon
id|inode-&gt;mode
op_assign
id|entry-&gt;mode
suffix:semicolon
id|inode-&gt;uid
op_assign
id|entry-&gt;uid
suffix:semicolon
id|inode-&gt;gid
op_assign
id|entry-&gt;gid
suffix:semicolon
id|inode-&gt;size
op_assign
id|entry-&gt;size
suffix:semicolon
id|inode-&gt;offset
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Non-empty directories, regfiles and symlinks will&n;&t;&t;&t;   write over inode-&gt;offset later. */
id|offset
op_add_assign
r_sizeof
(paren
r_struct
id|cramfs_inode
)paren
suffix:semicolon
id|total_nodes
op_increment
suffix:semicolon
multiline_comment|/* another node */
id|memcpy
c_func
(paren
id|base
op_plus
id|offset
comma
id|entry-&gt;name
comma
id|len
)paren
suffix:semicolon
multiline_comment|/* Pad up the name to a 4-byte boundary */
r_while
c_loop
(paren
id|len
op_amp
l_int|3
)paren
(brace
op_star
(paren
id|base
op_plus
id|offset
op_plus
id|len
)paren
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|len
op_increment
suffix:semicolon
)brace
id|inode-&gt;namelen
op_assign
id|len
op_rshift
l_int|2
suffix:semicolon
id|offset
op_add_assign
id|len
suffix:semicolon
multiline_comment|/* TODO: this may get it wrong for chars &gt;= 0x80.&n;&t;&t;&t;   Most filesystems use UTF8 encoding for filenames,&n;&t;&t;&t;   whereas the console is a single-byte character&n;&t;&t;&t;   set like iso-latin-1. */
id|printf
c_func
(paren
l_string|&quot;  %s&bslash;n&quot;
comma
id|entry-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|entry-&gt;child
)paren
(brace
r_if
c_cond
(paren
id|stack_entries
op_ge
id|MAXENTRIES
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Exceeded MAXENTRIES.  Raise this value in mkcramfs.c and recompile.  Exiting.&bslash;n&quot;
)paren
suffix:semicolon
m_exit
(paren
l_int|8
)paren
suffix:semicolon
)brace
id|entry_stack
(braket
id|stack_entries
)braket
op_assign
id|entry
suffix:semicolon
id|stack_entries
op_increment
suffix:semicolon
)brace
id|entry
op_assign
id|entry-&gt;next
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Reverse the order the stack entries pushed during&n;                 * this directory, for a small optimization of disk&n;                 * access in the created fs.  This change makes things&n;                 * `ls -UR&squot; order.&n;&t;&t; */
(brace
r_struct
id|entry
op_star
op_star
id|lo
op_assign
id|entry_stack
op_plus
id|dir_start
suffix:semicolon
r_struct
id|entry
op_star
op_star
id|hi
op_assign
id|entry_stack
op_plus
id|stack_entries
suffix:semicolon
r_struct
id|entry
op_star
id|tmp
suffix:semicolon
r_while
c_loop
(paren
id|lo
OL
op_decrement
id|hi
)paren
(brace
id|tmp
op_assign
op_star
id|lo
suffix:semicolon
op_star
id|lo
op_increment
op_assign
op_star
id|hi
suffix:semicolon
op_star
id|hi
op_assign
id|tmp
suffix:semicolon
)brace
)brace
multiline_comment|/* Pop a subdirectory entry from the stack, and recurse. */
r_if
c_cond
(paren
op_logical_neg
id|stack_entries
)paren
r_break
suffix:semicolon
id|stack_entries
op_decrement
suffix:semicolon
id|entry
op_assign
id|entry_stack
(braket
id|stack_entries
)braket
suffix:semicolon
id|set_data_offset
c_func
(paren
id|entry
comma
id|base
comma
id|offset
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&squot;%s&squot;:&bslash;n&quot;
comma
id|entry-&gt;name
)paren
suffix:semicolon
id|entry
op_assign
id|entry-&gt;child
suffix:semicolon
)brace
r_return
id|offset
suffix:semicolon
)brace
DECL|function|is_zero
r_static
r_int
id|is_zero
c_func
(paren
r_char
r_const
op_star
id|begin
comma
r_int
id|len
)paren
(brace
r_if
c_cond
(paren
id|opt_holes
)paren
multiline_comment|/* Returns non-zero iff the first LEN bytes from BEGIN are&n;&t;&t;   all NULs. */
r_return
(paren
id|len
op_decrement
op_eq
l_int|0
op_logical_or
(paren
id|begin
(braket
l_int|0
)braket
op_eq
l_char|&squot;&bslash;0&squot;
op_logical_and
(paren
id|len
op_decrement
op_eq
l_int|0
op_logical_or
(paren
id|begin
(braket
l_int|1
)braket
op_eq
l_char|&squot;&bslash;0&squot;
op_logical_and
(paren
id|len
op_decrement
op_eq
l_int|0
op_logical_or
(paren
id|begin
(braket
l_int|2
)braket
op_eq
l_char|&squot;&bslash;0&squot;
op_logical_and
(paren
id|len
op_decrement
op_eq
l_int|0
op_logical_or
(paren
id|begin
(braket
l_int|3
)braket
op_eq
l_char|&squot;&bslash;0&squot;
op_logical_and
id|memcmp
c_func
(paren
id|begin
comma
id|begin
op_plus
l_int|4
comma
id|len
)paren
op_eq
l_int|0
)paren
)paren
)paren
)paren
)paren
)paren
)paren
)paren
suffix:semicolon
r_else
multiline_comment|/* Never create holes. */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * One 4-byte pointer per block and then the actual blocked&n; * output. The first block does not need an offset pointer,&n; * as it will start immediately after the pointer block;&n; * so the i&squot;th pointer points to the end of the i&squot;th block&n; * (i.e. the start of the (i+1)&squot;th block or past EOF).&n; *&n; * Note that size &gt; 0, as a zero-sized file wouldn&squot;t ever&n; * have gotten here in the first place.&n; */
DECL|function|do_compress
r_static
r_int
r_int
id|do_compress
c_func
(paren
r_char
op_star
id|base
comma
r_int
r_int
id|offset
comma
r_char
r_const
op_star
id|name
comma
r_char
op_star
id|uncompressed
comma
r_int
r_int
id|size
)paren
(brace
r_int
r_int
id|original_size
op_assign
id|size
suffix:semicolon
r_int
r_int
id|original_offset
op_assign
id|offset
suffix:semicolon
r_int
r_int
id|new_size
suffix:semicolon
r_int
r_int
id|blocks
op_assign
(paren
id|size
op_minus
l_int|1
)paren
op_div
id|blksize
op_plus
l_int|1
suffix:semicolon
r_int
r_int
id|curr
op_assign
id|offset
op_plus
l_int|4
op_star
id|blocks
suffix:semicolon
r_int
id|change
suffix:semicolon
id|total_blocks
op_add_assign
id|blocks
suffix:semicolon
r_do
(brace
r_int
r_int
id|len
op_assign
l_int|2
op_star
id|blksize
suffix:semicolon
r_int
r_int
id|input
op_assign
id|size
suffix:semicolon
r_if
c_cond
(paren
id|input
OG
id|blksize
)paren
id|input
op_assign
id|blksize
suffix:semicolon
id|size
op_sub_assign
id|input
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|is_zero
(paren
id|uncompressed
comma
id|input
)paren
)paren
(brace
id|compress
c_func
(paren
id|base
op_plus
id|curr
comma
op_amp
id|len
comma
id|uncompressed
comma
id|input
)paren
suffix:semicolon
id|curr
op_add_assign
id|len
suffix:semicolon
)brace
id|uncompressed
op_add_assign
id|input
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|blksize
op_star
l_int|2
)paren
(brace
multiline_comment|/* (I don&squot;t think this can happen with zlib.) */
id|printf
c_func
(paren
l_string|&quot;AIEEE: block &bslash;&quot;compressed&bslash;&quot; to &gt; 2*blocklength (%ld)&bslash;n&quot;
comma
id|len
)paren
suffix:semicolon
m_exit
(paren
l_int|8
)paren
suffix:semicolon
)brace
op_star
(paren
id|u32
op_star
)paren
(paren
id|base
op_plus
id|offset
)paren
op_assign
id|curr
suffix:semicolon
id|offset
op_add_assign
l_int|4
suffix:semicolon
)brace
r_while
c_loop
(paren
id|size
)paren
suffix:semicolon
id|curr
op_assign
(paren
id|curr
op_plus
l_int|3
)paren
op_amp
op_complement
l_int|3
suffix:semicolon
id|new_size
op_assign
id|curr
op_minus
id|original_offset
suffix:semicolon
multiline_comment|/* TODO: Arguably, original_size in these 2 lines should be&n;&t;   st_blocks * 512.  But if you say that then perhaps&n;&t;   administrative data should also be included in both. */
id|change
op_assign
id|new_size
op_minus
id|original_size
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;%6.2f%% (%+d bytes)&bslash;t%s&bslash;n&quot;
comma
(paren
id|change
op_star
l_int|100
)paren
op_div
(paren
r_float
)paren
id|original_size
comma
id|change
comma
id|name
)paren
suffix:semicolon
r_return
id|curr
suffix:semicolon
)brace
multiline_comment|/*&n; * Traverse the entry tree, writing data for every item that has&n; * non-null entry-&gt;compressed (i.e. every symlink and non-empty&n; * regfile).&n; */
DECL|function|write_data
r_static
r_int
r_int
id|write_data
c_func
(paren
r_struct
id|entry
op_star
id|entry
comma
r_char
op_star
id|base
comma
r_int
r_int
id|offset
)paren
(brace
r_do
(brace
r_if
c_cond
(paren
id|entry-&gt;uncompressed
)paren
(brace
r_if
c_cond
(paren
id|entry-&gt;same
)paren
(brace
id|set_data_offset
c_func
(paren
id|entry
comma
id|base
comma
id|entry-&gt;same-&gt;offset
)paren
suffix:semicolon
id|entry-&gt;offset
op_assign
id|entry-&gt;same-&gt;offset
suffix:semicolon
)brace
r_else
(brace
id|set_data_offset
c_func
(paren
id|entry
comma
id|base
comma
id|offset
)paren
suffix:semicolon
id|entry-&gt;offset
op_assign
id|offset
suffix:semicolon
id|offset
op_assign
id|do_compress
c_func
(paren
id|base
comma
id|offset
comma
id|entry-&gt;name
comma
id|entry-&gt;uncompressed
comma
id|entry-&gt;size
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|entry-&gt;child
)paren
id|offset
op_assign
id|write_data
c_func
(paren
id|entry-&gt;child
comma
id|base
comma
id|offset
)paren
suffix:semicolon
id|entry
op_assign
id|entry-&gt;next
suffix:semicolon
)brace
r_while
c_loop
(paren
id|entry
)paren
suffix:semicolon
r_return
id|offset
suffix:semicolon
)brace
DECL|function|write_file
r_static
r_int
r_int
id|write_file
c_func
(paren
r_char
op_star
id|file
comma
r_char
op_star
id|base
comma
r_int
r_int
id|offset
)paren
(brace
r_int
id|fd
suffix:semicolon
r_char
op_star
id|buf
suffix:semicolon
id|fd
op_assign
id|open
c_func
(paren
id|file
comma
id|O_RDONLY
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fd
OL
l_int|0
)paren
(brace
id|perror
c_func
(paren
id|file
)paren
suffix:semicolon
m_exit
(paren
l_int|8
)paren
suffix:semicolon
)brace
id|buf
op_assign
id|mmap
c_func
(paren
l_int|NULL
comma
id|image_length
comma
id|PROT_READ
comma
id|MAP_PRIVATE
comma
id|fd
comma
l_int|0
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|base
op_plus
id|offset
comma
id|buf
comma
id|image_length
)paren
suffix:semicolon
id|munmap
c_func
(paren
id|buf
comma
id|image_length
)paren
suffix:semicolon
id|close
(paren
id|fd
)paren
suffix:semicolon
multiline_comment|/* Pad up the image_length to a 4-byte boundary */
r_while
c_loop
(paren
id|image_length
op_amp
l_int|3
)paren
(brace
op_star
(paren
id|base
op_plus
id|offset
op_plus
id|image_length
)paren
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|image_length
op_increment
suffix:semicolon
)brace
r_return
(paren
id|offset
op_plus
id|image_length
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Maximum size fs you can create is roughly 256MB.  (The last file&squot;s&n; * data must begin within 256MB boundary but can extend beyond that.)&n; *&n; * Note that if you want it to fit in a ROM then you&squot;re limited to what the&n; * hardware and kernel can support (64MB?).&n; */
DECL|macro|MAXFSLEN
mdefine_line|#define MAXFSLEN ((((1 &lt;&lt; CRAMFS_OFFSET_WIDTH) - 1) &lt;&lt; 2) /* offset */ &bslash;&n;&t;&t;  + (1 &lt;&lt; CRAMFS_SIZE_WIDTH) - 1 /* filesize */ &bslash;&n;&t;&t;  + (1 &lt;&lt; CRAMFS_SIZE_WIDTH) * 4 / PAGE_CACHE_SIZE /* block pointers */ )
multiline_comment|/*&n; * Usage:&n; *&n; *      mkcramfs directory-name outfile&n; *&n; * where &quot;directory-name&quot; is simply the root of the directory&n; * tree that we want to generate a compressed filesystem out&n; * of.&n; */
DECL|function|main
r_int
id|main
c_func
(paren
r_int
id|argc
comma
r_char
op_star
op_star
id|argv
)paren
(brace
r_struct
id|stat
id|st
suffix:semicolon
multiline_comment|/* used twice... */
r_struct
id|entry
op_star
id|root_entry
suffix:semicolon
r_char
op_star
id|rom_image
suffix:semicolon
id|ssize_t
id|offset
comma
id|written
suffix:semicolon
r_int
id|fd
suffix:semicolon
multiline_comment|/* initial guess (upper-bound) of required filesystem size */
id|loff_t
id|fslen_ub
op_assign
r_sizeof
(paren
r_struct
id|cramfs_super
)paren
suffix:semicolon
r_char
r_const
op_star
id|dirname
comma
op_star
id|outfile
suffix:semicolon
id|u32
id|crc
op_assign
id|crc32
c_func
(paren
l_int|0L
comma
id|Z_NULL
comma
l_int|0
)paren
suffix:semicolon
r_int
id|c
suffix:semicolon
multiline_comment|/* for getopt */
id|total_blocks
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|argc
)paren
id|progname
op_assign
id|argv
(braket
l_int|0
)braket
suffix:semicolon
multiline_comment|/* command line options */
r_while
c_loop
(paren
(paren
id|c
op_assign
id|getopt
c_func
(paren
id|argc
comma
id|argv
comma
l_string|&quot;hEe:i:n:psz&quot;
)paren
)paren
op_ne
id|EOF
)paren
(brace
r_switch
c_cond
(paren
id|c
)paren
(brace
r_case
l_char|&squot;h&squot;
suffix:colon
id|usage
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_case
l_char|&squot;E&squot;
suffix:colon
id|opt_errors
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;e&squot;
suffix:colon
id|opt_edition
op_assign
id|atoi
c_func
(paren
id|optarg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;i&squot;
suffix:colon
id|opt_image
op_assign
id|optarg
suffix:semicolon
r_if
c_cond
(paren
id|lstat
c_func
(paren
id|opt_image
comma
op_amp
id|st
)paren
OL
l_int|0
)paren
(brace
id|perror
c_func
(paren
id|opt_image
)paren
suffix:semicolon
m_exit
(paren
l_int|16
)paren
suffix:semicolon
)brace
id|image_length
op_assign
id|st.st_size
suffix:semicolon
multiline_comment|/* may be padded later */
id|fslen_ub
op_add_assign
(paren
id|image_length
op_plus
l_int|3
)paren
suffix:semicolon
multiline_comment|/* 3 is for padding */
r_break
suffix:semicolon
r_case
l_char|&squot;n&squot;
suffix:colon
id|opt_name
op_assign
id|optarg
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;p&squot;
suffix:colon
id|opt_pad
op_assign
id|PAD_SIZE
suffix:semicolon
id|fslen_ub
op_add_assign
id|PAD_SIZE
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;s&squot;
suffix:colon
multiline_comment|/* old option, ignored */
r_break
suffix:semicolon
r_case
l_char|&squot;z&squot;
suffix:colon
id|opt_holes
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
(paren
id|argc
op_minus
id|optind
)paren
op_ne
l_int|2
)paren
id|usage
c_func
(paren
l_int|16
)paren
suffix:semicolon
id|dirname
op_assign
id|argv
(braket
id|optind
)braket
suffix:semicolon
id|outfile
op_assign
id|argv
(braket
id|optind
op_plus
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
id|stat
c_func
(paren
id|dirname
comma
op_amp
id|st
)paren
OL
l_int|0
)paren
(brace
id|perror
c_func
(paren
id|dirname
)paren
suffix:semicolon
m_exit
(paren
l_int|16
)paren
suffix:semicolon
)brace
id|fd
op_assign
id|open
c_func
(paren
id|outfile
comma
id|O_WRONLY
op_or
id|O_CREAT
op_or
id|O_TRUNC
comma
l_int|0666
)paren
suffix:semicolon
id|root_entry
op_assign
id|calloc
c_func
(paren
l_int|1
comma
r_sizeof
(paren
r_struct
id|entry
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|root_entry
)paren
(brace
id|perror
c_func
(paren
l_int|NULL
)paren
suffix:semicolon
m_exit
(paren
l_int|8
)paren
suffix:semicolon
)brace
id|root_entry-&gt;mode
op_assign
id|st.st_mode
suffix:semicolon
id|root_entry-&gt;uid
op_assign
id|st.st_uid
suffix:semicolon
id|root_entry-&gt;gid
op_assign
id|st.st_gid
suffix:semicolon
id|root_entry-&gt;size
op_assign
id|parse_directory
c_func
(paren
id|root_entry
comma
id|dirname
comma
op_amp
id|root_entry-&gt;child
comma
op_amp
id|fslen_ub
)paren
suffix:semicolon
multiline_comment|/* always allocate a multiple of blksize bytes because that&squot;s&n;           what we&squot;re going to write later on */
id|fslen_ub
op_assign
(paren
(paren
id|fslen_ub
op_minus
l_int|1
)paren
op_or
(paren
id|blksize
op_minus
l_int|1
)paren
)paren
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|fslen_ub
OG
id|MAXFSLEN
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;warning: guestimate of required size (upper bound) is %LdMB, but maximum image size is %uMB.  We might die prematurely.&bslash;n&quot;
comma
id|fslen_ub
op_rshift
l_int|20
comma
id|MAXFSLEN
op_rshift
l_int|20
)paren
suffix:semicolon
id|fslen_ub
op_assign
id|MAXFSLEN
suffix:semicolon
)brace
multiline_comment|/* find duplicate files. TODO: uses the most inefficient algorithm&n;           possible. */
id|eliminate_doubles
c_func
(paren
id|root_entry
comma
id|root_entry
)paren
suffix:semicolon
multiline_comment|/* TODO: Why do we use a private/anonymous mapping here&n;           followed by a write below, instead of just a shared mapping&n;           and a couple of ftruncate calls?  Is it just to save us&n;           having to deal with removing the file afterwards?  If we&n;           really need this huge anonymous mapping, we ought to mmap&n;           in smaller chunks, so that the user doesn&squot;t need nn MB of&n;           RAM free.  If the reason is to be able to write to&n;           un-mmappable block devices, then we could try shared mmap&n;           and revert to anonymous mmap if the shared mmap fails. */
id|rom_image
op_assign
id|mmap
c_func
(paren
l_int|NULL
comma
id|fslen_ub
ques
c_cond
id|fslen_ub
suffix:colon
l_int|1
comma
id|PROT_READ
op_or
id|PROT_WRITE
comma
id|MAP_PRIVATE
op_or
id|MAP_ANONYMOUS
comma
op_minus
l_int|1
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_minus
l_int|1
op_eq
(paren
r_int
)paren
(paren
r_int
)paren
id|rom_image
)paren
(brace
id|perror
c_func
(paren
l_string|&quot;ROM image map&quot;
)paren
suffix:semicolon
m_exit
(paren
l_int|8
)paren
suffix:semicolon
)brace
multiline_comment|/* Skip the first opt_pad bytes for boot loader code */
id|offset
op_assign
id|opt_pad
suffix:semicolon
id|memset
c_func
(paren
id|rom_image
comma
l_int|0x00
comma
id|opt_pad
)paren
suffix:semicolon
multiline_comment|/* Skip the superblock and come back to write it later. */
id|offset
op_add_assign
r_sizeof
(paren
r_struct
id|cramfs_super
)paren
suffix:semicolon
multiline_comment|/* Insert a file image. */
r_if
c_cond
(paren
id|opt_image
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;Including: %s&bslash;n&quot;
comma
id|opt_image
)paren
suffix:semicolon
id|offset
op_assign
id|write_file
c_func
(paren
id|opt_image
comma
id|rom_image
comma
id|offset
)paren
suffix:semicolon
)brace
id|offset
op_assign
id|write_directory_structure
c_func
(paren
id|root_entry-&gt;child
comma
id|rom_image
comma
id|offset
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Directory data: %d bytes&bslash;n&quot;
comma
id|offset
)paren
suffix:semicolon
id|offset
op_assign
id|write_data
c_func
(paren
id|root_entry
comma
id|rom_image
comma
id|offset
)paren
suffix:semicolon
multiline_comment|/* We always write a multiple of blksize bytes, so that&n;           losetup works. */
id|offset
op_assign
(paren
(paren
id|offset
op_minus
l_int|1
)paren
op_or
(paren
id|blksize
op_minus
l_int|1
)paren
)paren
op_plus
l_int|1
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Everything: %d kilobytes&bslash;n&quot;
comma
id|offset
op_rshift
l_int|10
)paren
suffix:semicolon
multiline_comment|/* Write the superblock now that we can fill in all of the fields. */
id|write_superblock
c_func
(paren
id|root_entry
comma
id|rom_image
op_plus
id|opt_pad
comma
id|offset
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Super block: %d bytes&bslash;n&quot;
comma
r_sizeof
(paren
r_struct
id|cramfs_super
)paren
)paren
suffix:semicolon
multiline_comment|/* Put the checksum in. */
id|crc
op_assign
id|crc32
c_func
(paren
id|crc
comma
(paren
id|rom_image
op_plus
id|opt_pad
)paren
comma
(paren
id|offset
op_minus
id|opt_pad
)paren
)paren
suffix:semicolon
(paren
(paren
r_struct
id|cramfs_super
op_star
)paren
(paren
id|rom_image
op_plus
id|opt_pad
)paren
)paren
op_member_access_from_pointer
id|fsid.crc
op_assign
id|crc
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;CRC: %x&bslash;n&quot;
comma
id|crc
)paren
suffix:semicolon
multiline_comment|/* Check to make sure we allocated enough space. */
r_if
c_cond
(paren
id|fslen_ub
OL
id|offset
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;not enough space allocated for ROM image (%Ld allocated, %d used)&bslash;n&quot;
comma
id|fslen_ub
comma
id|offset
)paren
suffix:semicolon
m_exit
(paren
l_int|8
)paren
suffix:semicolon
)brace
id|written
op_assign
id|write
c_func
(paren
id|fd
comma
id|rom_image
comma
id|offset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|written
OL
l_int|0
)paren
(brace
id|perror
c_func
(paren
l_string|&quot;ROM image&quot;
)paren
suffix:semicolon
m_exit
(paren
l_int|8
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|offset
op_ne
id|written
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;ROM image write failed (%d %d)&bslash;n&quot;
comma
id|written
comma
id|offset
)paren
suffix:semicolon
m_exit
(paren
l_int|8
)paren
suffix:semicolon
)brace
multiline_comment|/* (These warnings used to come at the start, but they scroll off the&n;           screen too quickly.) */
r_if
c_cond
(paren
id|warn_namelen
)paren
multiline_comment|/* (can&squot;t happen when reading from ext2fs) */
id|fprintf
c_func
(paren
id|stderr
comma
multiline_comment|/* bytes, not chars: think UTF8. */
l_string|&quot;warning: filenames truncated to 255 bytes.&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|warn_skip
)paren
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;warning: files were skipped due to errors.&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|warn_size
)paren
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;warning: file sizes truncated to %luMB (minus 1 byte).&bslash;n&quot;
comma
l_int|1L
op_lshift
(paren
id|CRAMFS_SIZE_WIDTH
op_minus
l_int|20
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|warn_uid
)paren
multiline_comment|/* (not possible with current Linux versions) */
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;warning: uids truncated to %u bits.  (This may be a security concern.)&bslash;n&quot;
comma
id|CRAMFS_UID_WIDTH
)paren
suffix:semicolon
r_if
c_cond
(paren
id|warn_gid
)paren
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;warning: gids truncated to %u bits.  (This may be a security concern.)&bslash;n&quot;
comma
id|CRAMFS_GID_WIDTH
)paren
suffix:semicolon
r_if
c_cond
(paren
id|warn_dev
)paren
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;WARNING: device numbers truncated to %u bits.  This almost certainly means&bslash;n&quot;
l_string|&quot;that some device files will be wrong.&bslash;n&quot;
comma
id|CRAMFS_OFFSET_WIDTH
)paren
suffix:semicolon
r_if
c_cond
(paren
id|opt_errors
op_logical_and
(paren
id|warn_namelen
op_logical_or
id|warn_skip
op_logical_or
id|warn_size
op_logical_or
id|warn_uid
op_logical_or
id|warn_gid
op_logical_or
id|warn_dev
)paren
)paren
m_exit
(paren
l_int|8
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
eof
