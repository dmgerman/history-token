multiline_comment|/* Generate assembler source containing symbol information&n; *&n; * Copyright 2002       by Kai Germaschewski&n; *&n; * This software may be used and distributed according to the terms&n; * of the GNU General Public License, incorporated herein by reference.&n; *&n; * Usage: nm -n vmlinux | scripts/kallsyms [--all-symbols] &gt; symbols.S&n; *&n; * ChangeLog:&n; *&n; * (25/Aug/2004) Paulo Marques &lt;pmarques@grupopie.com&gt;&n; *      Changed the compression method from stem compression to &quot;table lookup&quot;&n; *      compression&n; *&n; *      Table compression uses all the unused char codes on the symbols and&n; *  maps these to the most used substrings (tokens). For instance, it might&n; *  map char code 0xF7 to represent &quot;write_&quot; and then in every symbol where&n; *  &quot;write_&quot; appears it can be replaced by 0xF7, saving 5 bytes.&n; *      The used codes themselves are also placed in the table so that the&n; *  decompresion can work without &quot;special cases&quot;.&n; *      Applied to kernel symbols, this usually produces a compression ratio&n; *  of about 50%.&n; *&n; */
macro_line|#include &lt;stdio.h&gt;
macro_line|#include &lt;stdlib.h&gt;
macro_line|#include &lt;string.h&gt;
macro_line|#include &lt;ctype.h&gt;
multiline_comment|/* maximum token length used. It doesn&squot;t pay to increase it a lot, because&n; * very long substrings probably don&squot;t repeat themselves too often. */
DECL|macro|MAX_TOK_SIZE
mdefine_line|#define MAX_TOK_SIZE&t;&t;11
DECL|macro|KSYM_NAME_LEN
mdefine_line|#define KSYM_NAME_LEN&t;&t;127
multiline_comment|/* we use only a subset of the complete symbol table to gather the token count,&n; * to speed up compression, at the expense of a little compression ratio */
DECL|macro|WORKING_SET
mdefine_line|#define WORKING_SET&t;&t;1024
multiline_comment|/* first find the best token only on the list of tokens that would profit more&n; * than GOOD_BAD_THRESHOLD. Only if this list is empty go to the &quot;bad&quot; list.&n; * Increasing this value will put less tokens on the &quot;good&quot; list, so the search&n; * is faster. However, if the good list runs out of tokens, we must painfully&n; * search the bad list. */
DECL|macro|GOOD_BAD_THRESHOLD
mdefine_line|#define GOOD_BAD_THRESHOLD&t;10
multiline_comment|/* token hash parameters */
DECL|macro|HASH_BITS
mdefine_line|#define HASH_BITS&t;&t;18
DECL|macro|HASH_TABLE_SIZE
mdefine_line|#define HASH_TABLE_SIZE&t;&t;(1 &lt;&lt; HASH_BITS)
DECL|macro|HASH_MASK
mdefine_line|#define HASH_MASK&t;&t;(HASH_TABLE_SIZE - 1)
DECL|macro|HASH_BASE_OFFSET
mdefine_line|#define HASH_BASE_OFFSET&t;2166136261U
DECL|macro|HASH_FOLD
mdefine_line|#define HASH_FOLD(a)&t;&t;((a)&amp;(HASH_MASK))
multiline_comment|/* flags to mark symbols */
DECL|macro|SYM_FLAG_VALID
mdefine_line|#define SYM_FLAG_VALID&t;&t;1
DECL|macro|SYM_FLAG_SAMPLED
mdefine_line|#define SYM_FLAG_SAMPLED&t;2
DECL|struct|sym_entry
r_struct
id|sym_entry
(brace
DECL|member|addr
r_int
r_int
r_int
id|addr
suffix:semicolon
DECL|member|type
r_char
id|type
suffix:semicolon
DECL|member|flags
r_int
r_char
id|flags
suffix:semicolon
DECL|member|len
r_int
r_char
id|len
suffix:semicolon
DECL|member|sym
r_int
r_char
op_star
id|sym
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|table
r_static
r_struct
id|sym_entry
op_star
id|table
suffix:semicolon
DECL|variable|size
DECL|variable|cnt
r_static
r_int
id|size
comma
id|cnt
suffix:semicolon
DECL|variable|_stext
DECL|variable|_etext
DECL|variable|_sinittext
DECL|variable|_einittext
r_static
r_int
r_int
r_int
id|_stext
comma
id|_etext
comma
id|_sinittext
comma
id|_einittext
suffix:semicolon
DECL|variable|all_symbols
r_static
r_int
id|all_symbols
op_assign
l_int|0
suffix:semicolon
DECL|struct|token
r_struct
id|token
(brace
DECL|member|data
r_int
r_char
id|data
(braket
id|MAX_TOK_SIZE
)braket
suffix:semicolon
DECL|member|len
r_int
r_char
id|len
suffix:semicolon
multiline_comment|/* profit: the number of bytes that could be saved by inserting this&n;&t; * token into the table */
DECL|member|profit
r_int
id|profit
suffix:semicolon
DECL|member|next
r_struct
id|token
op_star
id|next
suffix:semicolon
multiline_comment|/* next token on the hash list */
DECL|member|right
r_struct
id|token
op_star
id|right
suffix:semicolon
multiline_comment|/* next token on the good/bad list */
DECL|member|left
r_struct
id|token
op_star
id|left
suffix:semicolon
multiline_comment|/* previous token on the good/bad list */
DECL|member|smaller
r_struct
id|token
op_star
id|smaller
suffix:semicolon
multiline_comment|/* token that is less one letter than this one */
)brace
suffix:semicolon
DECL|variable|bad_head
DECL|variable|good_head
r_struct
id|token
id|bad_head
comma
id|good_head
suffix:semicolon
DECL|variable|hash_table
r_struct
id|token
op_star
id|hash_table
(braket
id|HASH_TABLE_SIZE
)braket
suffix:semicolon
multiline_comment|/* the table that holds the result of the compression */
DECL|variable|best_table
r_int
r_char
id|best_table
(braket
l_int|256
)braket
(braket
id|MAX_TOK_SIZE
op_plus
l_int|1
)braket
suffix:semicolon
DECL|variable|best_table_len
r_int
r_char
id|best_table_len
(braket
l_int|256
)braket
suffix:semicolon
r_static
r_void
DECL|function|usage
id|usage
c_func
(paren
r_void
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Usage: kallsyms [--all-symbols] &lt; in.map &gt; out.S&bslash;n&quot;
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|read_symbol
id|read_symbol
c_func
(paren
id|FILE
op_star
id|in
comma
r_struct
id|sym_entry
op_star
id|s
)paren
(brace
r_char
id|str
(braket
l_int|500
)braket
suffix:semicolon
r_int
id|rc
suffix:semicolon
id|rc
op_assign
id|fscanf
c_func
(paren
id|in
comma
l_string|&quot;%llx %c %499s&bslash;n&quot;
comma
op_amp
id|s-&gt;addr
comma
op_amp
id|s-&gt;type
comma
id|str
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_ne
l_int|3
)paren
(brace
r_if
c_cond
(paren
id|rc
op_ne
id|EOF
)paren
(brace
multiline_comment|/* skip line */
id|fgets
c_func
(paren
id|str
comma
l_int|500
comma
id|in
)paren
suffix:semicolon
)brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Ignore most absolute/undefined (?) symbols. */
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|str
comma
l_string|&quot;_stext&quot;
)paren
op_eq
l_int|0
)paren
id|_stext
op_assign
id|s-&gt;addr
suffix:semicolon
r_else
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|str
comma
l_string|&quot;_etext&quot;
)paren
op_eq
l_int|0
)paren
id|_etext
op_assign
id|s-&gt;addr
suffix:semicolon
r_else
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|str
comma
l_string|&quot;_sinittext&quot;
)paren
op_eq
l_int|0
)paren
id|_sinittext
op_assign
id|s-&gt;addr
suffix:semicolon
r_else
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|str
comma
l_string|&quot;_einittext&quot;
)paren
op_eq
l_int|0
)paren
id|_einittext
op_assign
id|s-&gt;addr
suffix:semicolon
r_else
r_if
c_cond
(paren
id|toupper
c_func
(paren
id|s-&gt;type
)paren
op_eq
l_char|&squot;A&squot;
op_logical_or
id|toupper
c_func
(paren
id|s-&gt;type
)paren
op_eq
l_char|&squot;U&squot;
)paren
r_return
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* include the type field in the symbol name, so that it gets&n;&t; * compressed together */
id|s-&gt;len
op_assign
id|strlen
c_func
(paren
id|str
)paren
op_plus
l_int|1
suffix:semicolon
id|s-&gt;sym
op_assign
(paren
r_char
op_star
)paren
id|malloc
c_func
(paren
id|s-&gt;len
op_plus
l_int|1
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|s-&gt;sym
op_plus
l_int|1
comma
id|str
)paren
suffix:semicolon
id|s-&gt;sym
(braket
l_int|0
)braket
op_assign
id|s-&gt;type
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|symbol_valid
id|symbol_valid
c_func
(paren
r_struct
id|sym_entry
op_star
id|s
)paren
(brace
multiline_comment|/* Symbols which vary between passes.  Passes 1 and 2 must have&n;&t; * identical symbol lists.  The kallsyms_* symbols below are only added&n;&t; * after pass 1, they would be included in pass 2 when --all-symbols is&n;&t; * specified so exclude them to get a stable symbol list.&n;&t; */
r_static
r_char
op_star
id|special_symbols
(braket
)braket
op_assign
(brace
l_string|&quot;kallsyms_addresses&quot;
comma
l_string|&quot;kallsyms_num_syms&quot;
comma
l_string|&quot;kallsyms_names&quot;
comma
l_string|&quot;kallsyms_markers&quot;
comma
l_string|&quot;kallsyms_token_table&quot;
comma
l_string|&quot;kallsyms_token_index&quot;
comma
multiline_comment|/* Exclude linker generated symbols which vary between passes */
l_string|&quot;_SDA_BASE_&quot;
comma
multiline_comment|/* ppc */
l_string|&quot;_SDA2_BASE_&quot;
comma
multiline_comment|/* ppc */
l_int|NULL
)brace
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/* if --all-symbols is not specified, then symbols outside the text&n;&t; * and inittext sections are discarded */
r_if
c_cond
(paren
op_logical_neg
id|all_symbols
)paren
(brace
r_if
c_cond
(paren
(paren
id|s-&gt;addr
template_param
id|_etext
)paren
op_logical_and
(paren
id|s-&gt;addr
template_param
id|_einittext
)paren
)paren
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Exclude symbols which vary between passes. */
r_if
c_cond
(paren
id|strstr
c_func
(paren
id|s-&gt;sym
op_plus
l_int|1
comma
l_string|&quot;_compiled.&quot;
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|special_symbols
(braket
id|i
)braket
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|s-&gt;sym
op_plus
l_int|1
comma
id|special_symbols
(braket
id|i
)braket
)paren
op_eq
l_int|0
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
r_static
r_void
DECL|function|read_map
id|read_map
c_func
(paren
id|FILE
op_star
id|in
)paren
(brace
r_while
c_loop
(paren
op_logical_neg
id|feof
c_func
(paren
id|in
)paren
)paren
(brace
r_if
c_cond
(paren
id|cnt
op_ge
id|size
)paren
(brace
id|size
op_add_assign
l_int|10000
suffix:semicolon
id|table
op_assign
id|realloc
c_func
(paren
id|table
comma
r_sizeof
(paren
op_star
id|table
)paren
op_star
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|table
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;out of memory&bslash;n&quot;
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|read_symbol
c_func
(paren
id|in
comma
op_amp
id|table
(braket
id|cnt
)braket
)paren
op_eq
l_int|0
)paren
id|cnt
op_increment
suffix:semicolon
)brace
)brace
DECL|function|output_label
r_static
r_void
id|output_label
c_func
(paren
r_char
op_star
id|label
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;.globl %s&bslash;n&quot;
comma
id|label
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;tALGN&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;%s:&bslash;n&quot;
comma
id|label
)paren
suffix:semicolon
)brace
multiline_comment|/* uncompress a compressed symbol. When this function is called, the best table&n; * might still be compressed itself, so the function needs to be recursive */
DECL|function|expand_symbol
r_static
r_int
id|expand_symbol
c_func
(paren
r_int
r_char
op_star
id|data
comma
r_int
id|len
comma
r_char
op_star
id|result
)paren
(brace
r_int
id|c
comma
id|rlen
comma
id|total
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|len
)paren
(brace
id|c
op_assign
op_star
id|data
suffix:semicolon
multiline_comment|/* if the table holds a single char that is the same as the one&n;&t;&t; * we are looking for, then end the search */
r_if
c_cond
(paren
id|best_table
(braket
id|c
)braket
(braket
l_int|0
)braket
op_eq
id|c
op_logical_and
id|best_table_len
(braket
id|c
)braket
op_eq
l_int|1
)paren
(brace
op_star
id|result
op_increment
op_assign
id|c
suffix:semicolon
id|total
op_increment
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* if not, recurse and expand */
id|rlen
op_assign
id|expand_symbol
c_func
(paren
id|best_table
(braket
id|c
)braket
comma
id|best_table_len
(braket
id|c
)braket
comma
id|result
)paren
suffix:semicolon
id|total
op_add_assign
id|rlen
suffix:semicolon
id|result
op_add_assign
id|rlen
suffix:semicolon
)brace
id|data
op_increment
suffix:semicolon
id|len
op_decrement
suffix:semicolon
)brace
op_star
id|result
op_assign
l_int|0
suffix:semicolon
r_return
id|total
suffix:semicolon
)brace
r_static
r_void
DECL|function|write_src
id|write_src
c_func
(paren
r_void
)paren
(brace
r_int
id|i
comma
id|k
comma
id|off
comma
id|valid
suffix:semicolon
r_int
r_int
id|best_idx
(braket
l_int|256
)braket
suffix:semicolon
r_int
r_int
op_star
id|markers
suffix:semicolon
r_char
id|buf
(braket
id|KSYM_NAME_LEN
op_plus
l_int|1
)braket
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;#include &lt;asm/types.h&gt;&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;#if BITS_PER_LONG == 64&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;#define PTR .quad&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;#define ALGN .align 8&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;#else&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;#define PTR .long&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;#define ALGN .align 4&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;#endif&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;.data&bslash;n&quot;
)paren
suffix:semicolon
id|output_label
c_func
(paren
l_string|&quot;kallsyms_addresses&quot;
)paren
suffix:semicolon
id|valid
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|cnt
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|table
(braket
id|i
)braket
dot
id|flags
op_amp
id|SYM_FLAG_VALID
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;&bslash;tPTR&bslash;t%#llx&bslash;n&quot;
comma
id|table
(braket
id|i
)braket
dot
id|addr
)paren
suffix:semicolon
id|valid
op_increment
suffix:semicolon
)brace
)brace
id|printf
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|output_label
c_func
(paren
l_string|&quot;kallsyms_num_syms&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;tPTR&bslash;t%d&bslash;n&quot;
comma
id|valid
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* table of offset markers, that give the offset in the compressed stream&n;&t; * every 256 symbols */
id|markers
op_assign
(paren
r_int
r_int
op_star
)paren
id|malloc
c_func
(paren
r_sizeof
(paren
r_int
r_int
)paren
op_star
(paren
(paren
id|valid
op_plus
l_int|255
)paren
op_div
l_int|256
)paren
)paren
suffix:semicolon
id|output_label
c_func
(paren
l_string|&quot;kallsyms_names&quot;
)paren
suffix:semicolon
id|valid
op_assign
l_int|0
suffix:semicolon
id|off
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|cnt
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|table
(braket
id|i
)braket
dot
id|flags
op_amp
id|SYM_FLAG_VALID
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
(paren
id|valid
op_amp
l_int|0xFF
)paren
op_eq
l_int|0
)paren
id|markers
(braket
id|valid
op_rshift
l_int|8
)braket
op_assign
id|off
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;t.byte 0x%02x&quot;
comma
id|table
(braket
id|i
)braket
dot
id|len
)paren
suffix:semicolon
r_for
c_loop
(paren
id|k
op_assign
l_int|0
suffix:semicolon
id|k
OL
id|table
(braket
id|i
)braket
dot
id|len
suffix:semicolon
id|k
op_increment
)paren
id|printf
c_func
(paren
l_string|&quot;, 0x%02x&quot;
comma
id|table
(braket
id|i
)braket
dot
id|sym
(braket
id|k
)braket
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|off
op_add_assign
id|table
(braket
id|i
)braket
dot
id|len
op_plus
l_int|1
suffix:semicolon
id|valid
op_increment
suffix:semicolon
)brace
id|printf
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|output_label
c_func
(paren
l_string|&quot;kallsyms_markers&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
(paren
id|valid
op_plus
l_int|255
)paren
op_rshift
l_int|8
)paren
suffix:semicolon
id|i
op_increment
)paren
id|printf
c_func
(paren
l_string|&quot;&bslash;tPTR&bslash;t%d&bslash;n&quot;
comma
id|markers
(braket
id|i
)braket
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|free
c_func
(paren
id|markers
)paren
suffix:semicolon
id|output_label
c_func
(paren
l_string|&quot;kallsyms_token_table&quot;
)paren
suffix:semicolon
id|off
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|256
suffix:semicolon
id|i
op_increment
)paren
(brace
id|best_idx
(braket
id|i
)braket
op_assign
id|off
suffix:semicolon
id|expand_symbol
c_func
(paren
id|best_table
(braket
id|i
)braket
comma
id|best_table_len
(braket
id|i
)braket
comma
id|buf
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;t.asciz&bslash;t&bslash;&quot;%s&bslash;&quot;&bslash;n&quot;
comma
id|buf
)paren
suffix:semicolon
id|off
op_add_assign
id|strlen
c_func
(paren
id|buf
)paren
op_plus
l_int|1
suffix:semicolon
)brace
id|printf
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|output_label
c_func
(paren
l_string|&quot;kallsyms_token_index&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|256
suffix:semicolon
id|i
op_increment
)paren
id|printf
c_func
(paren
l_string|&quot;&bslash;t.short&bslash;t%d&bslash;n&quot;
comma
id|best_idx
(braket
id|i
)braket
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* table lookup compression functions */
DECL|function|rehash_token
r_static
r_inline
r_int
r_int
id|rehash_token
c_func
(paren
r_int
r_int
id|hash
comma
r_int
r_char
id|data
)paren
(brace
r_return
(paren
(paren
id|hash
op_star
l_int|16777619
)paren
op_xor
id|data
)paren
suffix:semicolon
)brace
DECL|function|hash_token
r_static
r_int
r_int
id|hash_token
c_func
(paren
r_int
r_char
op_star
id|data
comma
r_int
id|len
)paren
(brace
r_int
r_int
id|hash
op_assign
id|HASH_BASE_OFFSET
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
suffix:semicolon
id|i
op_increment
)paren
id|hash
op_assign
id|rehash_token
c_func
(paren
id|hash
comma
id|data
(braket
id|i
)braket
)paren
suffix:semicolon
r_return
id|HASH_FOLD
c_func
(paren
id|hash
)paren
suffix:semicolon
)brace
multiline_comment|/* find a token given its data and hash value */
DECL|function|find_token_hash
r_static
r_struct
id|token
op_star
id|find_token_hash
c_func
(paren
r_int
r_char
op_star
id|data
comma
r_int
id|len
comma
r_int
r_int
id|hash
)paren
(brace
r_struct
id|token
op_star
id|ptr
suffix:semicolon
id|ptr
op_assign
id|hash_table
(braket
id|hash
)braket
suffix:semicolon
r_while
c_loop
(paren
id|ptr
)paren
(brace
r_if
c_cond
(paren
(paren
id|ptr-&gt;len
op_eq
id|len
)paren
op_logical_and
(paren
id|memcmp
c_func
(paren
id|ptr-&gt;data
comma
id|data
comma
id|len
)paren
op_eq
l_int|0
)paren
)paren
r_return
id|ptr
suffix:semicolon
id|ptr
op_assign
id|ptr-&gt;next
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|insert_token_in_group
r_static
r_inline
r_void
id|insert_token_in_group
c_func
(paren
r_struct
id|token
op_star
id|head
comma
r_struct
id|token
op_star
id|ptr
)paren
(brace
id|ptr-&gt;right
op_assign
id|head-&gt;right
suffix:semicolon
id|ptr-&gt;right-&gt;left
op_assign
id|ptr
suffix:semicolon
id|head-&gt;right
op_assign
id|ptr
suffix:semicolon
id|ptr-&gt;left
op_assign
id|head
suffix:semicolon
)brace
DECL|function|remove_token_from_group
r_static
r_inline
r_void
id|remove_token_from_group
c_func
(paren
r_struct
id|token
op_star
id|ptr
)paren
(brace
id|ptr-&gt;left-&gt;right
op_assign
id|ptr-&gt;right
suffix:semicolon
id|ptr-&gt;right-&gt;left
op_assign
id|ptr-&gt;left
suffix:semicolon
)brace
multiline_comment|/* build the counts for all the tokens that start with &quot;data&quot;, and have lenghts&n; * from 2 to &quot;len&quot; */
DECL|function|learn_token
r_static
r_void
id|learn_token
c_func
(paren
r_int
r_char
op_star
id|data
comma
r_int
id|len
)paren
(brace
r_struct
id|token
op_star
id|ptr
comma
op_star
id|last_ptr
suffix:semicolon
r_int
id|i
comma
id|newprofit
suffix:semicolon
r_int
r_int
id|hash
op_assign
id|HASH_BASE_OFFSET
suffix:semicolon
r_int
r_int
id|hashes
(braket
id|MAX_TOK_SIZE
op_plus
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|MAX_TOK_SIZE
)paren
id|len
op_assign
id|MAX_TOK_SIZE
suffix:semicolon
multiline_comment|/* calculate and store the hash values for all the sub-tokens */
id|hash
op_assign
id|rehash_token
c_func
(paren
id|hash
comma
id|data
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|2
suffix:semicolon
id|i
op_le
id|len
suffix:semicolon
id|i
op_increment
)paren
(brace
id|hash
op_assign
id|rehash_token
c_func
(paren
id|hash
comma
id|data
(braket
id|i
op_minus
l_int|1
)braket
)paren
suffix:semicolon
id|hashes
(braket
id|i
)braket
op_assign
id|HASH_FOLD
c_func
(paren
id|hash
)paren
suffix:semicolon
)brace
id|last_ptr
op_assign
l_int|NULL
suffix:semicolon
id|ptr
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|len
suffix:semicolon
id|i
op_ge
l_int|2
suffix:semicolon
id|i
op_decrement
)paren
(brace
id|hash
op_assign
id|hashes
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ptr
)paren
id|ptr
op_assign
id|find_token_hash
c_func
(paren
id|data
comma
id|i
comma
id|hash
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ptr
)paren
(brace
multiline_comment|/* create a new token entry */
id|ptr
op_assign
(paren
r_struct
id|token
op_star
)paren
id|malloc
c_func
(paren
r_sizeof
(paren
op_star
id|ptr
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|ptr-&gt;data
comma
id|data
comma
id|i
)paren
suffix:semicolon
id|ptr-&gt;len
op_assign
id|i
suffix:semicolon
multiline_comment|/* when we create an entry, it&squot;s profit is 0 because&n;&t;&t;&t; * we also take into account the size of the token on&n;&t;&t;&t; * the compressed table. We then subtract GOOD_BAD_THRESHOLD&n;&t;&t;&t; * so that the test to see if this token belongs to&n;&t;&t;&t; * the good or bad list, is a comparison to zero */
id|ptr-&gt;profit
op_assign
op_minus
id|GOOD_BAD_THRESHOLD
suffix:semicolon
id|ptr-&gt;next
op_assign
id|hash_table
(braket
id|hash
)braket
suffix:semicolon
id|hash_table
(braket
id|hash
)braket
op_assign
id|ptr
suffix:semicolon
id|insert_token_in_group
c_func
(paren
op_amp
id|bad_head
comma
id|ptr
)paren
suffix:semicolon
id|ptr-&gt;smaller
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
(brace
id|newprofit
op_assign
id|ptr-&gt;profit
op_plus
(paren
id|ptr-&gt;len
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* check to see if this token needs to be moved to a&n;&t;&t;&t; * different list */
r_if
c_cond
(paren
(paren
id|ptr-&gt;profit
OL
l_int|0
)paren
op_logical_and
(paren
id|newprofit
op_ge
l_int|0
)paren
)paren
(brace
id|remove_token_from_group
c_func
(paren
id|ptr
)paren
suffix:semicolon
id|insert_token_in_group
c_func
(paren
op_amp
id|good_head
comma
id|ptr
)paren
suffix:semicolon
)brace
id|ptr-&gt;profit
op_assign
id|newprofit
suffix:semicolon
)brace
r_if
c_cond
(paren
id|last_ptr
)paren
id|last_ptr-&gt;smaller
op_assign
id|ptr
suffix:semicolon
id|last_ptr
op_assign
id|ptr
suffix:semicolon
id|ptr
op_assign
id|ptr-&gt;smaller
suffix:semicolon
)brace
)brace
multiline_comment|/* decrease the counts for all the tokens that start with &quot;data&quot;, and have lenghts&n; * from 2 to &quot;len&quot;. This function is much simpler than learn_token because we have&n; * more guarantees (tho tokens exist, the -&gt;smaller pointer is set, etc.)&n; * The two separate functions exist only because of compression performance */
DECL|function|forget_token
r_static
r_void
id|forget_token
c_func
(paren
r_int
r_char
op_star
id|data
comma
r_int
id|len
)paren
(brace
r_struct
id|token
op_star
id|ptr
suffix:semicolon
r_int
id|i
comma
id|newprofit
suffix:semicolon
r_int
r_int
id|hash
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|MAX_TOK_SIZE
)paren
id|len
op_assign
id|MAX_TOK_SIZE
suffix:semicolon
id|hash
op_assign
id|hash_token
c_func
(paren
id|data
comma
id|len
)paren
suffix:semicolon
id|ptr
op_assign
id|find_token_hash
c_func
(paren
id|data
comma
id|len
comma
id|hash
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|len
suffix:semicolon
id|i
op_ge
l_int|2
suffix:semicolon
id|i
op_decrement
)paren
(brace
id|newprofit
op_assign
id|ptr-&gt;profit
op_minus
(paren
id|ptr-&gt;len
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ptr-&gt;profit
op_ge
l_int|0
)paren
op_logical_and
(paren
id|newprofit
OL
l_int|0
)paren
)paren
(brace
id|remove_token_from_group
c_func
(paren
id|ptr
)paren
suffix:semicolon
id|insert_token_in_group
c_func
(paren
op_amp
id|bad_head
comma
id|ptr
)paren
suffix:semicolon
)brace
id|ptr-&gt;profit
op_assign
id|newprofit
suffix:semicolon
id|ptr
op_assign
id|ptr-&gt;smaller
suffix:semicolon
)brace
)brace
multiline_comment|/* count all the possible tokens in a symbol */
DECL|function|learn_symbol
r_static
r_void
id|learn_symbol
c_func
(paren
r_int
r_char
op_star
id|symbol
comma
r_int
id|len
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
op_minus
l_int|1
suffix:semicolon
id|i
op_increment
)paren
id|learn_token
c_func
(paren
id|symbol
op_plus
id|i
comma
id|len
op_minus
id|i
)paren
suffix:semicolon
)brace
multiline_comment|/* decrease the count for all the possible tokens in a symbol */
DECL|function|forget_symbol
r_static
r_void
id|forget_symbol
c_func
(paren
r_int
r_char
op_star
id|symbol
comma
r_int
id|len
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
op_minus
l_int|1
suffix:semicolon
id|i
op_increment
)paren
id|forget_token
c_func
(paren
id|symbol
op_plus
id|i
comma
id|len
op_minus
id|i
)paren
suffix:semicolon
)brace
multiline_comment|/* set all the symbol flags and do the initial token count */
DECL|function|build_initial_tok_table
r_static
r_void
id|build_initial_tok_table
c_func
(paren
r_void
)paren
(brace
r_int
id|i
comma
id|use_it
comma
id|valid
suffix:semicolon
id|valid
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|cnt
suffix:semicolon
id|i
op_increment
)paren
(brace
id|table
(braket
id|i
)braket
dot
id|flags
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|symbol_valid
c_func
(paren
op_amp
id|table
(braket
id|i
)braket
)paren
)paren
(brace
id|table
(braket
id|i
)braket
dot
id|flags
op_or_assign
id|SYM_FLAG_VALID
suffix:semicolon
id|valid
op_increment
suffix:semicolon
)brace
)brace
id|use_it
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|cnt
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* subsample the available symbols. This method is almost like&n;&t;&t; * a Bresenham&squot;s algorithm to get uniformly distributed samples&n;&t;&t; * across the symbol table */
r_if
c_cond
(paren
id|table
(braket
id|i
)braket
dot
id|flags
op_amp
id|SYM_FLAG_VALID
)paren
(brace
id|use_it
op_add_assign
id|WORKING_SET
suffix:semicolon
r_if
c_cond
(paren
id|use_it
op_ge
id|valid
)paren
(brace
id|table
(braket
id|i
)braket
dot
id|flags
op_or_assign
id|SYM_FLAG_SAMPLED
suffix:semicolon
id|use_it
op_sub_assign
id|valid
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|table
(braket
id|i
)braket
dot
id|flags
op_amp
id|SYM_FLAG_SAMPLED
)paren
id|learn_symbol
c_func
(paren
id|table
(braket
id|i
)braket
dot
id|sym
comma
id|table
(braket
id|i
)braket
dot
id|len
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* replace a given token in all the valid symbols. Use the sampled symbols&n; * to update the counts */
DECL|function|compress_symbols
r_static
r_void
id|compress_symbols
c_func
(paren
r_int
r_char
op_star
id|str
comma
r_int
id|tlen
comma
r_int
id|idx
)paren
(brace
r_int
id|i
comma
id|len
comma
id|learn
comma
id|size
suffix:semicolon
r_int
r_char
op_star
id|p
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|cnt
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|table
(braket
id|i
)braket
dot
id|flags
op_amp
id|SYM_FLAG_VALID
)paren
)paren
r_continue
suffix:semicolon
id|len
op_assign
id|table
(braket
id|i
)braket
dot
id|len
suffix:semicolon
id|learn
op_assign
l_int|0
suffix:semicolon
id|p
op_assign
id|table
(braket
id|i
)braket
dot
id|sym
suffix:semicolon
r_do
(brace
multiline_comment|/* find the token on the symbol */
id|p
op_assign
(paren
r_int
r_char
op_star
)paren
id|strstr
c_func
(paren
(paren
r_char
op_star
)paren
id|p
comma
(paren
r_char
op_star
)paren
id|str
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|learn
)paren
(brace
multiline_comment|/* if this symbol was used to count, decrease it */
r_if
c_cond
(paren
id|table
(braket
id|i
)braket
dot
id|flags
op_amp
id|SYM_FLAG_SAMPLED
)paren
id|forget_symbol
c_func
(paren
id|table
(braket
id|i
)braket
dot
id|sym
comma
id|len
)paren
suffix:semicolon
id|learn
op_assign
l_int|1
suffix:semicolon
)brace
op_star
id|p
op_assign
id|idx
suffix:semicolon
id|size
op_assign
(paren
id|len
op_minus
(paren
id|p
op_minus
id|table
(braket
id|i
)braket
dot
id|sym
)paren
)paren
op_minus
id|tlen
op_plus
l_int|1
suffix:semicolon
id|memmove
c_func
(paren
id|p
op_plus
l_int|1
comma
id|p
op_plus
id|tlen
comma
id|size
)paren
suffix:semicolon
id|p
op_increment
suffix:semicolon
id|len
op_sub_assign
id|tlen
op_minus
l_int|1
suffix:semicolon
)brace
r_while
c_loop
(paren
id|size
op_ge
id|tlen
)paren
suffix:semicolon
r_if
c_cond
(paren
id|learn
)paren
(brace
id|table
(braket
id|i
)braket
dot
id|len
op_assign
id|len
suffix:semicolon
multiline_comment|/* if this symbol was used to count, learn it again */
r_if
c_cond
(paren
id|table
(braket
id|i
)braket
dot
id|flags
op_amp
id|SYM_FLAG_SAMPLED
)paren
(brace
id|learn_symbol
c_func
(paren
id|table
(braket
id|i
)braket
dot
id|sym
comma
id|len
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
multiline_comment|/* search the token with the maximum profit */
DECL|function|find_best_token
r_static
r_struct
id|token
op_star
id|find_best_token
c_func
(paren
r_void
)paren
(brace
r_struct
id|token
op_star
id|ptr
comma
op_star
id|best
comma
op_star
id|head
suffix:semicolon
r_int
id|bestprofit
suffix:semicolon
id|bestprofit
op_assign
op_minus
l_int|10000
suffix:semicolon
multiline_comment|/* failsafe: if the &quot;good&quot; list is empty search from the &quot;bad&quot; list */
r_if
c_cond
(paren
id|good_head.right
op_eq
op_amp
id|good_head
)paren
(brace
id|head
op_assign
op_amp
id|bad_head
suffix:semicolon
)brace
r_else
id|head
op_assign
op_amp
id|good_head
suffix:semicolon
id|ptr
op_assign
id|head-&gt;right
suffix:semicolon
id|best
op_assign
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
id|ptr
op_ne
id|head
)paren
(brace
r_if
c_cond
(paren
id|ptr-&gt;profit
OG
id|bestprofit
)paren
(brace
id|bestprofit
op_assign
id|ptr-&gt;profit
suffix:semicolon
id|best
op_assign
id|ptr
suffix:semicolon
)brace
id|ptr
op_assign
id|ptr-&gt;right
suffix:semicolon
)brace
r_return
id|best
suffix:semicolon
)brace
multiline_comment|/* this is the core of the algorithm: calculate the &quot;best&quot; table */
DECL|function|optimize_result
r_static
r_void
id|optimize_result
c_func
(paren
r_void
)paren
(brace
r_struct
id|token
op_star
id|best
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/* using the &squot;&bslash;0&squot; symbol last allows compress_symbols to use standard&n;&t; * fast string functions */
r_for
c_loop
(paren
id|i
op_assign
l_int|255
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
multiline_comment|/* if this table slot is empty (it is not used by an actual&n;&t;&t; * original char code */
r_if
c_cond
(paren
op_logical_neg
id|best_table_len
(braket
id|i
)braket
)paren
(brace
multiline_comment|/* find the token with the breates profit value */
id|best
op_assign
id|find_best_token
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* place it in the &quot;best&quot; table */
id|best_table_len
(braket
id|i
)braket
op_assign
id|best-&gt;len
suffix:semicolon
id|memcpy
c_func
(paren
id|best_table
(braket
id|i
)braket
comma
id|best-&gt;data
comma
id|best_table_len
(braket
id|i
)braket
)paren
suffix:semicolon
multiline_comment|/* zero terminate the token so that we can use strstr&n;&t;&t;&t;   in compress_symbols */
id|best_table
(braket
id|i
)braket
(braket
id|best_table_len
(braket
id|i
)braket
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
multiline_comment|/* replace this token in all the valid symbols */
id|compress_symbols
c_func
(paren
id|best_table
(braket
id|i
)braket
comma
id|best_table_len
(braket
id|i
)braket
comma
id|i
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* start by placing the symbols that are actually used on the table */
DECL|function|insert_real_symbols_in_table
r_static
r_void
id|insert_real_symbols_in_table
c_func
(paren
r_void
)paren
(brace
r_int
id|i
comma
id|j
comma
id|c
suffix:semicolon
id|memset
c_func
(paren
id|best_table
comma
l_int|0
comma
r_sizeof
(paren
id|best_table
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|best_table_len
comma
l_int|0
comma
r_sizeof
(paren
id|best_table_len
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|cnt
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|table
(braket
id|i
)braket
dot
id|flags
op_amp
id|SYM_FLAG_VALID
)paren
(brace
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|table
(braket
id|i
)braket
dot
id|len
suffix:semicolon
id|j
op_increment
)paren
(brace
id|c
op_assign
id|table
(braket
id|i
)braket
dot
id|sym
(braket
id|j
)braket
suffix:semicolon
id|best_table
(braket
id|c
)braket
(braket
l_int|0
)braket
op_assign
id|c
suffix:semicolon
id|best_table_len
(braket
id|c
)braket
op_assign
l_int|1
suffix:semicolon
)brace
)brace
)brace
)brace
DECL|function|optimize_token_table
r_static
r_void
id|optimize_token_table
c_func
(paren
r_void
)paren
(brace
id|memset
c_func
(paren
id|hash_table
comma
l_int|0
comma
r_sizeof
(paren
id|hash_table
)paren
)paren
suffix:semicolon
id|good_head.left
op_assign
op_amp
id|good_head
suffix:semicolon
id|good_head.right
op_assign
op_amp
id|good_head
suffix:semicolon
id|bad_head.left
op_assign
op_amp
id|bad_head
suffix:semicolon
id|bad_head.right
op_assign
op_amp
id|bad_head
suffix:semicolon
id|build_initial_tok_table
c_func
(paren
)paren
suffix:semicolon
id|insert_real_symbols_in_table
c_func
(paren
)paren
suffix:semicolon
id|optimize_result
c_func
(paren
)paren
suffix:semicolon
)brace
r_int
DECL|function|main
id|main
c_func
(paren
r_int
id|argc
comma
r_char
op_star
op_star
id|argv
)paren
(brace
r_if
c_cond
(paren
id|argc
op_eq
l_int|2
op_logical_and
id|strcmp
c_func
(paren
id|argv
(braket
l_int|1
)braket
comma
l_string|&quot;--all-symbols&quot;
)paren
op_eq
l_int|0
)paren
id|all_symbols
op_assign
l_int|1
suffix:semicolon
r_else
r_if
c_cond
(paren
id|argc
op_ne
l_int|1
)paren
id|usage
c_func
(paren
)paren
suffix:semicolon
id|read_map
c_func
(paren
id|stdin
)paren
suffix:semicolon
id|optimize_token_table
c_func
(paren
)paren
suffix:semicolon
id|write_src
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
eof
