multiline_comment|/* Generate assembler source containing symbol information&n; *&n; * Copyright 2002       by Kai Germaschewski&n; *&n; * This software may be used and distributed according to the terms&n; * of the GNU General Public License, incorporated herein by reference.&n; *&n; * Usage: nm -n vmlinux | scripts/kallsyms [--all-symbols] &gt; symbols.S&n; */
macro_line|#include &lt;stdio.h&gt;
macro_line|#include &lt;stdlib.h&gt;
macro_line|#include &lt;string.h&gt;
macro_line|#include &lt;ctype.h&gt;
DECL|struct|sym_entry
r_struct
id|sym_entry
(brace
DECL|member|addr
r_int
r_int
r_int
id|addr
suffix:semicolon
DECL|member|type
r_char
id|type
suffix:semicolon
DECL|member|sym
r_char
op_star
id|sym
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|table
r_static
r_struct
id|sym_entry
op_star
id|table
suffix:semicolon
DECL|variable|size
DECL|variable|cnt
r_static
r_int
id|size
comma
id|cnt
suffix:semicolon
DECL|variable|_stext
DECL|variable|_etext
DECL|variable|_sinittext
DECL|variable|_einittext
r_static
r_int
r_int
r_int
id|_stext
comma
id|_etext
comma
id|_sinittext
comma
id|_einittext
suffix:semicolon
DECL|variable|all_symbols
r_static
r_int
id|all_symbols
op_assign
l_int|0
suffix:semicolon
r_static
r_void
DECL|function|usage
id|usage
c_func
(paren
r_void
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Usage: kallsyms [--all-symbols] &lt; in.map &gt; out.S&bslash;n&quot;
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|read_symbol
id|read_symbol
c_func
(paren
id|FILE
op_star
id|in
comma
r_struct
id|sym_entry
op_star
id|s
)paren
(brace
r_char
id|str
(braket
l_int|500
)braket
suffix:semicolon
r_int
id|rc
suffix:semicolon
id|rc
op_assign
id|fscanf
c_func
(paren
id|in
comma
l_string|&quot;%llx %c %499s&bslash;n&quot;
comma
op_amp
id|s-&gt;addr
comma
op_amp
id|s-&gt;type
comma
id|str
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_ne
l_int|3
)paren
(brace
r_if
c_cond
(paren
id|rc
op_ne
id|EOF
)paren
(brace
multiline_comment|/* skip line */
id|fgets
c_func
(paren
id|str
comma
l_int|500
comma
id|in
)paren
suffix:semicolon
)brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Ignore most absolute/undefined (?) symbols. */
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|str
comma
l_string|&quot;_stext&quot;
)paren
op_eq
l_int|0
)paren
id|_stext
op_assign
id|s-&gt;addr
suffix:semicolon
r_else
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|str
comma
l_string|&quot;_etext&quot;
)paren
op_eq
l_int|0
)paren
id|_etext
op_assign
id|s-&gt;addr
suffix:semicolon
r_else
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|str
comma
l_string|&quot;_sinittext&quot;
)paren
op_eq
l_int|0
)paren
id|_sinittext
op_assign
id|s-&gt;addr
suffix:semicolon
r_else
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|str
comma
l_string|&quot;_einittext&quot;
)paren
op_eq
l_int|0
)paren
id|_einittext
op_assign
id|s-&gt;addr
suffix:semicolon
r_else
r_if
c_cond
(paren
id|toupper
c_func
(paren
id|s-&gt;type
)paren
op_eq
l_char|&squot;A&squot;
op_logical_or
id|toupper
c_func
(paren
id|s-&gt;type
)paren
op_eq
l_char|&squot;U&squot;
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|s-&gt;sym
op_assign
id|strdup
c_func
(paren
id|str
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|symbol_valid
id|symbol_valid
c_func
(paren
r_struct
id|sym_entry
op_star
id|s
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|all_symbols
)paren
(brace
r_if
c_cond
(paren
(paren
id|s-&gt;addr
template_param
id|_etext
)paren
op_logical_and
(paren
id|s-&gt;addr
template_param
id|_einittext
)paren
)paren
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Exclude symbols which vary between passes.  Passes 1 and 2 must have&n;&t; * identical symbol lists.  The kallsyms_* symbols below are only added&n;&t; * after pass 1, they would be included in pass 2 when --all-symbols is&n;&t; * specified so exclude them to get a stable symbol list.&n;&t; */
r_if
c_cond
(paren
id|strstr
c_func
(paren
id|s-&gt;sym
comma
l_string|&quot;_compiled.&quot;
)paren
op_logical_or
id|strcmp
c_func
(paren
id|s-&gt;sym
comma
l_string|&quot;kallsyms_addresses&quot;
)paren
op_eq
l_int|0
op_logical_or
id|strcmp
c_func
(paren
id|s-&gt;sym
comma
l_string|&quot;kallsyms_num_syms&quot;
)paren
op_eq
l_int|0
op_logical_or
id|strcmp
c_func
(paren
id|s-&gt;sym
comma
l_string|&quot;kallsyms_names&quot;
)paren
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_static
r_void
DECL|function|read_map
id|read_map
c_func
(paren
id|FILE
op_star
id|in
)paren
(brace
r_while
c_loop
(paren
op_logical_neg
id|feof
c_func
(paren
id|in
)paren
)paren
(brace
r_if
c_cond
(paren
id|cnt
op_ge
id|size
)paren
(brace
id|size
op_add_assign
l_int|10000
suffix:semicolon
id|table
op_assign
id|realloc
c_func
(paren
id|table
comma
r_sizeof
(paren
op_star
id|table
)paren
op_star
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|table
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;out of memory&bslash;n&quot;
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|read_symbol
c_func
(paren
id|in
comma
op_amp
id|table
(braket
id|cnt
)braket
)paren
op_eq
l_int|0
)paren
id|cnt
op_increment
suffix:semicolon
)brace
)brace
r_static
r_void
DECL|function|write_src
id|write_src
c_func
(paren
r_void
)paren
(brace
r_int
id|i
comma
id|valid
op_assign
l_int|0
suffix:semicolon
r_char
op_star
id|prev
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;#include &lt;asm/types.h&gt;&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;#if BITS_PER_LONG == 64&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;#define PTR .quad&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;#define ALGN .align 8&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;#else&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;#define PTR .long&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;#define ALGN .align 4&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;#endif&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;.data&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;.globl kallsyms_addresses&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;tALGN&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;kallsyms_addresses:&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|cnt
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|symbol_valid
c_func
(paren
op_amp
id|table
(braket
id|i
)braket
)paren
)paren
r_continue
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;tPTR&bslash;t%#llx&bslash;n&quot;
comma
id|table
(braket
id|i
)braket
dot
id|addr
)paren
suffix:semicolon
id|valid
op_increment
suffix:semicolon
)brace
id|printf
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;.globl kallsyms_num_syms&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;tALGN&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;kallsyms_num_syms:&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;tPTR&bslash;t%d&bslash;n&quot;
comma
id|valid
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;.globl kallsyms_names&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;tALGN&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;kallsyms_names:&bslash;n&quot;
)paren
suffix:semicolon
id|prev
op_assign
l_string|&quot;&quot;
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|cnt
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|k
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|symbol_valid
c_func
(paren
op_amp
id|table
(braket
id|i
)braket
)paren
)paren
r_continue
suffix:semicolon
r_for
c_loop
(paren
id|k
op_assign
l_int|0
suffix:semicolon
id|table
(braket
id|i
)braket
dot
id|sym
(braket
id|k
)braket
op_logical_and
id|table
(braket
id|i
)braket
dot
id|sym
(braket
id|k
)braket
op_eq
id|prev
(braket
id|k
)braket
suffix:semicolon
op_increment
id|k
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;t.byte 0x%02x&bslash;n&bslash;t.asciz&bslash;t&bslash;&quot;%s&bslash;&quot;&bslash;n&quot;
comma
id|k
comma
id|table
(braket
id|i
)braket
dot
id|sym
op_plus
id|k
)paren
suffix:semicolon
id|prev
op_assign
id|table
(braket
id|i
)braket
dot
id|sym
suffix:semicolon
)brace
id|printf
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_int
DECL|function|main
id|main
c_func
(paren
r_int
id|argc
comma
r_char
op_star
op_star
id|argv
)paren
(brace
r_if
c_cond
(paren
id|argc
op_eq
l_int|2
op_logical_and
id|strcmp
c_func
(paren
id|argv
(braket
l_int|1
)braket
comma
l_string|&quot;--all-symbols&quot;
)paren
op_eq
l_int|0
)paren
id|all_symbols
op_assign
l_int|1
suffix:semicolon
r_else
r_if
c_cond
(paren
id|argc
op_ne
l_int|1
)paren
id|usage
c_func
(paren
)paren
suffix:semicolon
id|read_map
c_func
(paren
id|stdin
)paren
suffix:semicolon
id|write_src
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
eof
