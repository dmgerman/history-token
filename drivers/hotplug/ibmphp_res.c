multiline_comment|/*&n; * IBM Hot Plug Controller Driver&n; *&n; * Written By: Irene Zubarev, IBM Corporation&n; *&n; * Copyright (c) 2001 Greg Kroah-Hartman (greg@kroah.com)&n; * Copyright (c) 2001,2002 IBM Corp.&n; *&n; * All rights reserved.&n; *&n; * This program is free software; you can redistribute it and/or modify&n; * it under the terms of the GNU General Public License as published by&n; * the Free Software Foundation; either version 2 of the License, or (at&n; * your option) any later version.&n; *&n; * This program is distributed in the hope that it will be useful, but&n; * WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or&n; * NON INFRINGEMENT.  See the GNU General Public License for more&n; * details.&n; *&n; * You should have received a copy of the GNU General Public License&n; * along with this program; if not, write to the Free Software&n; * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.&n; *&n; * Send feedback to &lt;gregkh@us.ibm.com&gt;&n; *&n; */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/list.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &quot;ibmphp.h&quot;
DECL|variable|flags
r_static
r_int
id|flags
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* for testing */
r_static
r_void
id|update_resources
(paren
r_struct
id|bus_node
op_star
id|bus_cur
comma
r_int
id|type
comma
r_int
id|rangeno
)paren
suffix:semicolon
r_static
r_int
id|once_over
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|remove_ranges
(paren
r_struct
id|bus_node
op_star
comma
r_struct
id|bus_node
op_star
)paren
suffix:semicolon
r_static
r_int
id|update_bridge_ranges
(paren
r_struct
id|bus_node
op_star
op_star
)paren
suffix:semicolon
r_static
r_int
id|add_range
(paren
r_int
id|type
comma
r_struct
id|range_node
op_star
comma
r_struct
id|bus_node
op_star
)paren
suffix:semicolon
r_static
r_void
id|fix_resources
(paren
r_struct
id|bus_node
op_star
)paren
suffix:semicolon
r_static
r_inline
r_struct
id|bus_node
op_star
id|find_bus_wprev
(paren
id|u8
comma
r_struct
id|bus_node
op_star
op_star
comma
id|u8
)paren
suffix:semicolon
r_static
id|LIST_HEAD
c_func
(paren
id|gbuses
)paren
suffix:semicolon
DECL|variable|ibmphp_res_head
id|LIST_HEAD
c_func
(paren
id|ibmphp_res_head
)paren
suffix:semicolon
DECL|function|alloc_error_bus
r_static
r_struct
id|bus_node
op_star
id|__init
id|alloc_error_bus
(paren
r_struct
id|ebda_pci_rsrc
op_star
id|curr
comma
id|u8
id|busno
comma
r_int
id|flag
)paren
(brace
r_struct
id|bus_node
op_star
id|newbus
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|curr
)paren
op_logical_and
op_logical_neg
(paren
id|flag
)paren
)paren
(brace
id|err
(paren
l_string|&quot;NULL pointer passed &bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|newbus
op_assign
id|kmalloc
(paren
r_sizeof
(paren
r_struct
id|bus_node
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|newbus
)paren
(brace
id|err
(paren
l_string|&quot;out of system memory &bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|memset
(paren
id|newbus
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|bus_node
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flag
)paren
id|newbus-&gt;busno
op_assign
id|busno
suffix:semicolon
r_else
id|newbus-&gt;busno
op_assign
id|curr-&gt;bus_num
suffix:semicolon
id|list_add_tail
(paren
op_amp
id|newbus-&gt;bus_list
comma
op_amp
id|gbuses
)paren
suffix:semicolon
r_return
id|newbus
suffix:semicolon
)brace
DECL|function|alloc_resources
r_static
r_struct
id|resource_node
op_star
id|__init
id|alloc_resources
(paren
r_struct
id|ebda_pci_rsrc
op_star
id|curr
)paren
(brace
r_struct
id|resource_node
op_star
id|rs
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|curr
)paren
(brace
id|err
(paren
l_string|&quot;NULL passed to allocate &bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|rs
op_assign
id|kmalloc
(paren
r_sizeof
(paren
r_struct
id|resource_node
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rs
)paren
(brace
id|err
(paren
l_string|&quot;out of system memory &bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|memset
(paren
id|rs
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|resource_node
)paren
)paren
suffix:semicolon
id|rs-&gt;busno
op_assign
id|curr-&gt;bus_num
suffix:semicolon
id|rs-&gt;devfunc
op_assign
id|curr-&gt;dev_fun
suffix:semicolon
id|rs-&gt;start
op_assign
id|curr-&gt;start_addr
suffix:semicolon
id|rs-&gt;end
op_assign
id|curr-&gt;end_addr
suffix:semicolon
id|rs-&gt;len
op_assign
id|curr-&gt;end_addr
op_minus
id|curr-&gt;start_addr
op_plus
l_int|1
suffix:semicolon
r_return
id|rs
suffix:semicolon
)brace
DECL|function|alloc_bus_range
r_static
r_int
id|__init
id|alloc_bus_range
(paren
r_struct
id|bus_node
op_star
op_star
id|new_bus
comma
r_struct
id|range_node
op_star
op_star
id|new_range
comma
r_struct
id|ebda_pci_rsrc
op_star
id|curr
comma
r_int
id|flag
comma
id|u8
id|first_bus
)paren
(brace
r_struct
id|bus_node
op_star
id|newbus
suffix:semicolon
r_struct
id|range_node
op_star
id|newrange
suffix:semicolon
id|u8
id|num_ranges
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|first_bus
)paren
(brace
id|newbus
op_assign
id|kmalloc
(paren
r_sizeof
(paren
r_struct
id|bus_node
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|newbus
)paren
(brace
id|err
(paren
l_string|&quot;out of system memory. &bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|memset
(paren
id|newbus
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|bus_node
)paren
)paren
suffix:semicolon
id|newbus-&gt;busno
op_assign
id|curr-&gt;bus_num
suffix:semicolon
)brace
r_else
(brace
id|newbus
op_assign
op_star
id|new_bus
suffix:semicolon
r_switch
c_cond
(paren
id|flag
)paren
(brace
r_case
id|MEM
suffix:colon
id|num_ranges
op_assign
id|newbus-&gt;noMemRanges
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PFMEM
suffix:colon
id|num_ranges
op_assign
id|newbus-&gt;noPFMemRanges
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IO
suffix:colon
id|num_ranges
op_assign
id|newbus-&gt;noIORanges
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|newrange
op_assign
id|kmalloc
(paren
r_sizeof
(paren
r_struct
id|range_node
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|newrange
)paren
(brace
r_if
c_cond
(paren
id|first_bus
)paren
id|kfree
(paren
id|newbus
)paren
suffix:semicolon
id|err
(paren
l_string|&quot;out of system memory &bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|memset
(paren
id|newrange
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|range_node
)paren
)paren
suffix:semicolon
id|newrange-&gt;start
op_assign
id|curr-&gt;start_addr
suffix:semicolon
id|newrange-&gt;end
op_assign
id|curr-&gt;end_addr
suffix:semicolon
r_if
c_cond
(paren
id|first_bus
op_logical_or
(paren
op_logical_neg
id|num_ranges
)paren
)paren
id|newrange-&gt;rangeno
op_assign
l_int|1
suffix:semicolon
r_else
(brace
multiline_comment|/* need to insert our range */
id|add_range
(paren
id|flag
comma
id|newrange
comma
id|newbus
)paren
suffix:semicolon
id|debug
(paren
l_string|&quot;%d resource Primary Bus inserted on bus %x [%x - %x]&bslash;n&quot;
comma
id|flag
comma
id|newbus-&gt;busno
comma
id|newrange-&gt;start
comma
id|newrange-&gt;end
)paren
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|flag
)paren
(brace
r_case
id|MEM
suffix:colon
id|newbus-&gt;rangeMem
op_assign
id|newrange
suffix:semicolon
r_if
c_cond
(paren
id|first_bus
)paren
id|newbus-&gt;noMemRanges
op_assign
l_int|1
suffix:semicolon
r_else
(brace
id|debug
(paren
l_string|&quot;First Memory Primary on bus %x, [%x - %x]&bslash;n&quot;
comma
id|newbus-&gt;busno
comma
id|newrange-&gt;start
comma
id|newrange-&gt;end
)paren
suffix:semicolon
op_increment
id|newbus-&gt;noMemRanges
suffix:semicolon
id|fix_resources
(paren
id|newbus
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|IO
suffix:colon
id|newbus-&gt;rangeIO
op_assign
id|newrange
suffix:semicolon
r_if
c_cond
(paren
id|first_bus
)paren
id|newbus-&gt;noIORanges
op_assign
l_int|1
suffix:semicolon
r_else
(brace
id|debug
(paren
l_string|&quot;First IO Primary on bus %x, [%x - %x]&bslash;n&quot;
comma
id|newbus-&gt;busno
comma
id|newrange-&gt;start
comma
id|newrange-&gt;end
)paren
suffix:semicolon
op_increment
id|newbus-&gt;noIORanges
suffix:semicolon
id|fix_resources
(paren
id|newbus
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|PFMEM
suffix:colon
id|newbus-&gt;rangePFMem
op_assign
id|newrange
suffix:semicolon
r_if
c_cond
(paren
id|first_bus
)paren
id|newbus-&gt;noPFMemRanges
op_assign
l_int|1
suffix:semicolon
r_else
(brace
id|debug
(paren
l_string|&quot;1st PFMemory Primary on Bus %x [%x - %x]&bslash;n&quot;
comma
id|newbus-&gt;busno
comma
id|newrange-&gt;start
comma
id|newrange-&gt;end
)paren
suffix:semicolon
op_increment
id|newbus-&gt;noPFMemRanges
suffix:semicolon
id|fix_resources
(paren
id|newbus
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
op_star
id|new_bus
op_assign
id|newbus
suffix:semicolon
op_star
id|new_range
op_assign
id|newrange
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Notes:&n; * 1. The ranges are ordered.  The buses are not ordered.  (First come)&n; *&n; * 2. If cannot allocate out of PFMem range, allocate from Mem ranges.  PFmemFromMem&n; * are not sorted. (no need since use mem node). To not change the entire code, we&n; * also add mem node whenever this case happens so as not to change&n; * ibmphp_check_mem_resource etc (and since it really is taking Mem resource)&n; */
multiline_comment|/*****************************************************************************&n; * This is the Resource Management initialization function.  It will go through&n; * the Resource list taken from EBDA and fill in this module&squot;s data structures&n; *&n; * THIS IS NOT TAKING INTO CONSIDERATION IO RESTRICTIONS OF PRIMARY BUSES, &n; * SINCE WE&squot;RE GOING TO ASSUME FOR NOW WE DON&squot;T HAVE THOSE ON OUR BUSES FOR NOW&n; *&n; * Input: ptr to the head of the resource list from EBDA&n; * Output: 0, -1 or error codes&n; ***************************************************************************/
DECL|function|ibmphp_rsrc_init
r_int
id|__init
id|ibmphp_rsrc_init
(paren
r_void
)paren
(brace
r_struct
id|ebda_pci_rsrc
op_star
id|curr
suffix:semicolon
r_struct
id|range_node
op_star
id|newrange
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|bus_node
op_star
id|newbus
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|bus_node
op_star
id|bus_cur
suffix:semicolon
r_struct
id|bus_node
op_star
id|bus_prev
suffix:semicolon
r_struct
id|list_head
op_star
id|tmp
suffix:semicolon
r_struct
id|resource_node
op_star
id|new_io
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|resource_node
op_star
id|new_mem
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|resource_node
op_star
id|new_pfmem
op_assign
l_int|NULL
suffix:semicolon
r_int
id|rc
suffix:semicolon
r_struct
id|list_head
op_star
id|tmp_ebda
suffix:semicolon
id|list_for_each
(paren
id|tmp_ebda
comma
op_amp
id|ibmphp_ebda_pci_rsrc_head
)paren
(brace
id|curr
op_assign
id|list_entry
(paren
id|tmp_ebda
comma
r_struct
id|ebda_pci_rsrc
comma
id|ebda_pci_rsrc_list
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|curr-&gt;rsrc_type
op_amp
id|PCIDEVMASK
)paren
)paren
(brace
multiline_comment|/* EBDA still lists non PCI devices, so ignore... */
id|debug
(paren
l_string|&quot;this is not a PCI DEVICE in rsrc_init, please take care&bslash;n&quot;
)paren
suffix:semicolon
singleline_comment|// continue;
)brace
multiline_comment|/* this is a primary bus resource */
r_if
c_cond
(paren
id|curr-&gt;rsrc_type
op_amp
id|PRIMARYBUSMASK
)paren
(brace
multiline_comment|/* memory */
r_if
c_cond
(paren
(paren
id|curr-&gt;rsrc_type
op_amp
id|RESTYPE
)paren
op_eq
id|MMASK
)paren
(brace
multiline_comment|/* no bus structure exists in place yet */
r_if
c_cond
(paren
id|list_empty
(paren
op_amp
id|gbuses
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|alloc_bus_range
(paren
op_amp
id|newbus
comma
op_amp
id|newrange
comma
id|curr
comma
id|MEM
comma
l_int|1
)paren
)paren
)paren
r_return
id|rc
suffix:semicolon
id|list_add_tail
(paren
op_amp
id|newbus-&gt;bus_list
comma
op_amp
id|gbuses
)paren
suffix:semicolon
id|debug
(paren
l_string|&quot;gbuses = NULL, Memory Primary Bus %x [%x - %x]&bslash;n&quot;
comma
id|newbus-&gt;busno
comma
id|newrange-&gt;start
comma
id|newrange-&gt;end
)paren
suffix:semicolon
)brace
r_else
(brace
id|bus_cur
op_assign
id|find_bus_wprev
(paren
id|curr-&gt;bus_num
comma
op_amp
id|bus_prev
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* found our bus */
r_if
c_cond
(paren
id|bus_cur
)paren
(brace
id|rc
op_assign
id|alloc_bus_range
(paren
op_amp
id|bus_cur
comma
op_amp
id|newrange
comma
id|curr
comma
id|MEM
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_return
id|rc
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* went through all the buses and didn&squot;t find ours, need to create a new bus node */
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|alloc_bus_range
(paren
op_amp
id|newbus
comma
op_amp
id|newrange
comma
id|curr
comma
id|MEM
comma
l_int|1
)paren
)paren
)paren
r_return
id|rc
suffix:semicolon
id|list_add_tail
(paren
op_amp
id|newbus-&gt;bus_list
comma
op_amp
id|gbuses
)paren
suffix:semicolon
id|debug
(paren
l_string|&quot;New Bus, Memory Primary Bus %x [%x - %x]&bslash;n&quot;
comma
id|newbus-&gt;busno
comma
id|newrange-&gt;start
comma
id|newrange-&gt;end
)paren
suffix:semicolon
)brace
)brace
)brace
r_else
r_if
c_cond
(paren
(paren
id|curr-&gt;rsrc_type
op_amp
id|RESTYPE
)paren
op_eq
id|PFMASK
)paren
(brace
multiline_comment|/* prefetchable memory */
r_if
c_cond
(paren
id|list_empty
(paren
op_amp
id|gbuses
)paren
)paren
(brace
multiline_comment|/* no bus structure exists in place yet */
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|alloc_bus_range
(paren
op_amp
id|newbus
comma
op_amp
id|newrange
comma
id|curr
comma
id|PFMEM
comma
l_int|1
)paren
)paren
)paren
r_return
id|rc
suffix:semicolon
id|list_add_tail
(paren
op_amp
id|newbus-&gt;bus_list
comma
op_amp
id|gbuses
)paren
suffix:semicolon
id|debug
(paren
l_string|&quot;gbuses = NULL, PFMemory Primary Bus %x [%x - %x]&bslash;n&quot;
comma
id|newbus-&gt;busno
comma
id|newrange-&gt;start
comma
id|newrange-&gt;end
)paren
suffix:semicolon
)brace
r_else
(brace
id|bus_cur
op_assign
id|find_bus_wprev
(paren
id|curr-&gt;bus_num
comma
op_amp
id|bus_prev
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bus_cur
)paren
(brace
multiline_comment|/* found our bus */
id|rc
op_assign
id|alloc_bus_range
(paren
op_amp
id|bus_cur
comma
op_amp
id|newrange
comma
id|curr
comma
id|PFMEM
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_return
id|rc
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* went through all the buses and didn&squot;t find ours, need to create a new bus node */
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|alloc_bus_range
(paren
op_amp
id|newbus
comma
op_amp
id|newrange
comma
id|curr
comma
id|PFMEM
comma
l_int|1
)paren
)paren
)paren
r_return
id|rc
suffix:semicolon
id|list_add_tail
(paren
op_amp
id|newbus-&gt;bus_list
comma
op_amp
id|gbuses
)paren
suffix:semicolon
id|debug
(paren
l_string|&quot;1st Bus, PFMemory Primary Bus %x [%x - %x]&bslash;n&quot;
comma
id|newbus-&gt;busno
comma
id|newrange-&gt;start
comma
id|newrange-&gt;end
)paren
suffix:semicolon
)brace
)brace
)brace
r_else
r_if
c_cond
(paren
(paren
id|curr-&gt;rsrc_type
op_amp
id|RESTYPE
)paren
op_eq
id|IOMASK
)paren
(brace
multiline_comment|/* IO */
r_if
c_cond
(paren
id|list_empty
(paren
op_amp
id|gbuses
)paren
)paren
(brace
multiline_comment|/* no bus structure exists in place yet */
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|alloc_bus_range
(paren
op_amp
id|newbus
comma
op_amp
id|newrange
comma
id|curr
comma
id|IO
comma
l_int|1
)paren
)paren
)paren
r_return
id|rc
suffix:semicolon
id|list_add_tail
(paren
op_amp
id|newbus-&gt;bus_list
comma
op_amp
id|gbuses
)paren
suffix:semicolon
id|debug
(paren
l_string|&quot;gbuses = NULL, IO Primary Bus %x [%x - %x]&bslash;n&quot;
comma
id|newbus-&gt;busno
comma
id|newrange-&gt;start
comma
id|newrange-&gt;end
)paren
suffix:semicolon
)brace
r_else
(brace
id|bus_cur
op_assign
id|find_bus_wprev
(paren
id|curr-&gt;bus_num
comma
op_amp
id|bus_prev
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bus_cur
)paren
(brace
id|rc
op_assign
id|alloc_bus_range
(paren
op_amp
id|bus_cur
comma
op_amp
id|newrange
comma
id|curr
comma
id|IO
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_return
id|rc
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* went through all the buses and didn&squot;t find ours, need to create a new bus node */
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|alloc_bus_range
(paren
op_amp
id|newbus
comma
op_amp
id|newrange
comma
id|curr
comma
id|IO
comma
l_int|1
)paren
)paren
)paren
r_return
id|rc
suffix:semicolon
id|list_add_tail
(paren
op_amp
id|newbus-&gt;bus_list
comma
op_amp
id|gbuses
)paren
suffix:semicolon
id|debug
(paren
l_string|&quot;1st Bus, IO Primary Bus %x [%x - %x]&bslash;n&quot;
comma
id|newbus-&gt;busno
comma
id|newrange-&gt;start
comma
id|newrange-&gt;end
)paren
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
suffix:semicolon
multiline_comment|/* type is reserved  WHAT TO DO IN THIS CASE???&n;&t;&t;&t;&t;&t;   NOTHING TO DO??? */
)brace
)brace
r_else
(brace
multiline_comment|/* regular pci device resource */
r_if
c_cond
(paren
(paren
id|curr-&gt;rsrc_type
op_amp
id|RESTYPE
)paren
op_eq
id|MMASK
)paren
(brace
multiline_comment|/* Memory resource */
id|new_mem
op_assign
id|alloc_resources
(paren
id|curr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|new_mem
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|new_mem-&gt;type
op_assign
id|MEM
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * if it didn&squot;t find the bus, means PCI dev&n;&t;&t;&t;&t; * came b4 the Primary Bus info, so need to&n;&t;&t;&t;&t; * create a bus rangeno becomes a problem...&n;&t;&t;&t;&t; * assign a -1 and then update once the range&n;&t;&t;&t;&t; * actually appears...&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|ibmphp_add_resource
(paren
id|new_mem
)paren
OL
l_int|0
)paren
(brace
id|newbus
op_assign
id|alloc_error_bus
(paren
id|curr
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|newbus
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|newbus-&gt;firstMem
op_assign
id|new_mem
suffix:semicolon
op_increment
id|newbus-&gt;needMemUpdate
suffix:semicolon
id|new_mem-&gt;rangeno
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
id|debug
(paren
l_string|&quot;Memory resource for device %x, bus %x, [%x - %x]&bslash;n&quot;
comma
id|new_mem-&gt;devfunc
comma
id|new_mem-&gt;busno
comma
id|new_mem-&gt;start
comma
id|new_mem-&gt;end
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|curr-&gt;rsrc_type
op_amp
id|RESTYPE
)paren
op_eq
id|PFMASK
)paren
(brace
multiline_comment|/* PFMemory resource */
id|new_pfmem
op_assign
id|alloc_resources
(paren
id|curr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|new_pfmem
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|new_pfmem-&gt;type
op_assign
id|PFMEM
suffix:semicolon
id|new_pfmem-&gt;fromMem
op_assign
id|FALSE
suffix:semicolon
r_if
c_cond
(paren
id|ibmphp_add_resource
(paren
id|new_pfmem
)paren
OL
l_int|0
)paren
(brace
id|newbus
op_assign
id|alloc_error_bus
(paren
id|curr
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|newbus
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|newbus-&gt;firstPFMem
op_assign
id|new_pfmem
suffix:semicolon
op_increment
id|newbus-&gt;needPFMemUpdate
suffix:semicolon
id|new_pfmem-&gt;rangeno
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
id|debug
(paren
l_string|&quot;PFMemory resource for device %x, bus %x, [%x - %x]&bslash;n&quot;
comma
id|new_pfmem-&gt;devfunc
comma
id|new_pfmem-&gt;busno
comma
id|new_pfmem-&gt;start
comma
id|new_pfmem-&gt;end
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|curr-&gt;rsrc_type
op_amp
id|RESTYPE
)paren
op_eq
id|IOMASK
)paren
(brace
multiline_comment|/* IO resource */
id|new_io
op_assign
id|alloc_resources
(paren
id|curr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|new_io
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|new_io-&gt;type
op_assign
id|IO
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * if it didn&squot;t find the bus, means PCI dev&n;&t;&t;&t;&t; * came b4 the Primary Bus info, so need to&n;&t;&t;&t;&t; * create a bus rangeno becomes a problem...&n;&t;&t;&t;&t; * Can assign a -1 and then update once the&n;&t;&t;&t;&t; * range actually appears...&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|ibmphp_add_resource
(paren
id|new_io
)paren
OL
l_int|0
)paren
(brace
id|newbus
op_assign
id|alloc_error_bus
(paren
id|curr
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|newbus
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|newbus-&gt;firstIO
op_assign
id|new_io
suffix:semicolon
op_increment
id|newbus-&gt;needIOUpdate
suffix:semicolon
id|new_io-&gt;rangeno
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
id|debug
(paren
l_string|&quot;IO resource for device %x, bus %x, [%x - %x]&bslash;n&quot;
comma
id|new_io-&gt;devfunc
comma
id|new_io-&gt;busno
comma
id|new_io-&gt;start
comma
id|new_io-&gt;end
)paren
suffix:semicolon
)brace
)brace
)brace
id|list_for_each
(paren
id|tmp
comma
op_amp
id|gbuses
)paren
(brace
id|bus_cur
op_assign
id|list_entry
(paren
id|tmp
comma
r_struct
id|bus_node
comma
id|bus_list
)paren
suffix:semicolon
multiline_comment|/* This is to get info about PPB resources, since EBDA doesn&squot;t put this info into the primary bus info */
id|rc
op_assign
id|update_bridge_ranges
(paren
op_amp
id|bus_cur
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_return
id|rc
suffix:semicolon
)brace
id|rc
op_assign
id|once_over
(paren
)paren
suffix:semicolon
multiline_comment|/* This is to align ranges (so no -1) */
r_if
c_cond
(paren
id|rc
)paren
r_return
id|rc
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/********************************************************************************&n; * This function adds a range into a sorted list of ranges per bus for a particular&n; * range type, it then calls another routine to update the range numbers on the&n; * pci devices&squot; resources for the appropriate resource&n; *&n; * Input: type of the resource, range to add, current bus&n; * Output: 0 or -1, bus and range ptrs &n; ********************************************************************************/
DECL|function|add_range
r_static
r_int
id|add_range
(paren
r_int
id|type
comma
r_struct
id|range_node
op_star
id|range
comma
r_struct
id|bus_node
op_star
id|bus_cur
)paren
(brace
r_struct
id|range_node
op_star
id|range_cur
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|range_node
op_star
id|range_prev
suffix:semicolon
r_int
id|count
op_assign
l_int|0
comma
id|i_init
suffix:semicolon
r_int
id|noRanges
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|type
)paren
(brace
r_case
id|MEM
suffix:colon
id|range_cur
op_assign
id|bus_cur-&gt;rangeMem
suffix:semicolon
id|noRanges
op_assign
id|bus_cur-&gt;noMemRanges
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PFMEM
suffix:colon
id|range_cur
op_assign
id|bus_cur-&gt;rangePFMem
suffix:semicolon
id|noRanges
op_assign
id|bus_cur-&gt;noPFMemRanges
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IO
suffix:colon
id|range_cur
op_assign
id|bus_cur-&gt;rangeIO
suffix:semicolon
id|noRanges
op_assign
id|bus_cur-&gt;noIORanges
suffix:semicolon
r_break
suffix:semicolon
)brace
id|range_prev
op_assign
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
id|range_cur
)paren
(brace
r_if
c_cond
(paren
id|range-&gt;start
OL
id|range_cur-&gt;start
)paren
r_break
suffix:semicolon
id|range_prev
op_assign
id|range_cur
suffix:semicolon
id|range_cur
op_assign
id|range_cur-&gt;next
suffix:semicolon
id|count
op_assign
id|count
op_plus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|count
)paren
(brace
multiline_comment|/* our range will go at the beginning of the list */
r_switch
c_cond
(paren
id|type
)paren
(brace
r_case
id|MEM
suffix:colon
id|bus_cur-&gt;rangeMem
op_assign
id|range
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PFMEM
suffix:colon
id|bus_cur-&gt;rangePFMem
op_assign
id|range
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IO
suffix:colon
id|bus_cur-&gt;rangeIO
op_assign
id|range
suffix:semicolon
r_break
suffix:semicolon
)brace
id|range-&gt;next
op_assign
id|range_cur
suffix:semicolon
id|range-&gt;rangeno
op_assign
l_int|1
suffix:semicolon
id|i_init
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|range_cur
)paren
(brace
multiline_comment|/* our range will go at the end of the list */
id|range-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|range_prev-&gt;next
op_assign
id|range
suffix:semicolon
id|range-&gt;rangeno
op_assign
id|range_prev-&gt;rangeno
op_plus
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* the range is in the middle */
id|range_prev-&gt;next
op_assign
id|range
suffix:semicolon
id|range-&gt;next
op_assign
id|range_cur
suffix:semicolon
id|range-&gt;rangeno
op_assign
id|range_cur-&gt;rangeno
suffix:semicolon
id|i_init
op_assign
id|range_prev-&gt;rangeno
suffix:semicolon
)brace
r_for
c_loop
(paren
id|count
op_assign
id|i_init
suffix:semicolon
id|count
OL
id|noRanges
suffix:semicolon
op_increment
id|count
)paren
(brace
op_increment
id|range_cur-&gt;rangeno
suffix:semicolon
id|range_cur
op_assign
id|range_cur-&gt;next
suffix:semicolon
)brace
id|update_resources
(paren
id|bus_cur
comma
id|type
comma
id|i_init
op_plus
l_int|1
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*******************************************************************************&n; * This routine goes through the list of resources of type &squot;type&squot; and updates&n; * the range numbers that they correspond to.  It was called from add_range fnc&n; *&n; * Input: bus, type of the resource, the rangeno starting from which to update&n; ******************************************************************************/
DECL|function|update_resources
r_static
r_void
id|update_resources
(paren
r_struct
id|bus_node
op_star
id|bus_cur
comma
r_int
id|type
comma
r_int
id|rangeno
)paren
(brace
r_struct
id|resource_node
op_star
id|res
op_assign
l_int|NULL
suffix:semicolon
id|u8
id|eol
op_assign
id|FALSE
suffix:semicolon
multiline_comment|/* end of list indicator */
r_switch
c_cond
(paren
id|type
)paren
(brace
r_case
id|MEM
suffix:colon
r_if
c_cond
(paren
id|bus_cur-&gt;firstMem
)paren
id|res
op_assign
id|bus_cur-&gt;firstMem
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PFMEM
suffix:colon
r_if
c_cond
(paren
id|bus_cur-&gt;firstPFMem
)paren
id|res
op_assign
id|bus_cur-&gt;firstPFMem
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IO
suffix:colon
r_if
c_cond
(paren
id|bus_cur-&gt;firstIO
)paren
id|res
op_assign
id|bus_cur-&gt;firstIO
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|res
)paren
(brace
r_while
c_loop
(paren
id|res
)paren
(brace
r_if
c_cond
(paren
id|res-&gt;rangeno
op_eq
id|rangeno
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|res-&gt;next
)paren
id|res
op_assign
id|res-&gt;next
suffix:semicolon
r_else
r_if
c_cond
(paren
id|res-&gt;nextRange
)paren
id|res
op_assign
id|res-&gt;nextRange
suffix:semicolon
r_else
(brace
id|eol
op_assign
id|TRUE
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|eol
)paren
(brace
multiline_comment|/* found the range */
r_while
c_loop
(paren
id|res
)paren
(brace
op_increment
id|res-&gt;rangeno
suffix:semicolon
id|res
op_assign
id|res-&gt;next
suffix:semicolon
)brace
)brace
)brace
)brace
DECL|function|fix_me
r_static
r_void
id|fix_me
(paren
r_struct
id|resource_node
op_star
id|res
comma
r_struct
id|bus_node
op_star
id|bus_cur
comma
r_struct
id|range_node
op_star
id|range
)paren
(brace
r_char
op_star
id|str
op_assign
l_string|&quot;&quot;
suffix:semicolon
r_switch
c_cond
(paren
id|res-&gt;type
)paren
(brace
r_case
id|IO
suffix:colon
id|str
op_assign
l_string|&quot;io&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MEM
suffix:colon
id|str
op_assign
l_string|&quot;mem&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PFMEM
suffix:colon
id|str
op_assign
l_string|&quot;pfmem&quot;
suffix:semicolon
r_break
suffix:semicolon
)brace
r_while
c_loop
(paren
id|res
)paren
(brace
r_if
c_cond
(paren
id|res-&gt;rangeno
op_eq
op_minus
l_int|1
)paren
(brace
r_while
c_loop
(paren
id|range
)paren
(brace
r_if
c_cond
(paren
(paren
id|res-&gt;start
op_ge
id|range-&gt;start
)paren
op_logical_and
(paren
id|res-&gt;end
op_le
id|range-&gt;end
)paren
)paren
(brace
id|res-&gt;rangeno
op_assign
id|range-&gt;rangeno
suffix:semicolon
id|debug
(paren
l_string|&quot;%s-&gt;rangeno in fix_resources is %d&bslash;n&quot;
comma
id|str
comma
id|res-&gt;rangeno
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|res-&gt;type
)paren
(brace
r_case
id|IO
suffix:colon
op_decrement
id|bus_cur-&gt;needIOUpdate
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MEM
suffix:colon
op_decrement
id|bus_cur-&gt;needMemUpdate
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PFMEM
suffix:colon
op_decrement
id|bus_cur-&gt;needPFMemUpdate
suffix:semicolon
r_break
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
id|range
op_assign
id|range-&gt;next
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|res-&gt;next
)paren
id|res
op_assign
id|res-&gt;next
suffix:semicolon
r_else
id|res
op_assign
id|res-&gt;nextRange
suffix:semicolon
)brace
)brace
multiline_comment|/*****************************************************************************&n; * This routine reassigns the range numbers to the resources that had a -1&n; * This case can happen only if upon initialization, resources taken by pci dev&n; * appear in EBDA before the resources allocated for that bus, since we don&squot;t&n; * know the range, we assign -1, and this routine is called after a new range&n; * is assigned to see the resources with unknown range belong to the added range&n; *&n; * Input: current bus&n; * Output: none, list of resources for that bus are fixed if can be&n; *******************************************************************************/
DECL|function|fix_resources
r_static
r_void
id|fix_resources
(paren
r_struct
id|bus_node
op_star
id|bus_cur
)paren
(brace
r_struct
id|range_node
op_star
id|range
suffix:semicolon
r_struct
id|resource_node
op_star
id|res
suffix:semicolon
id|debug
(paren
l_string|&quot;%s - bus_cur-&gt;busno = %d&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|bus_cur-&gt;busno
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bus_cur-&gt;needIOUpdate
)paren
(brace
id|res
op_assign
id|bus_cur-&gt;firstIO
suffix:semicolon
id|range
op_assign
id|bus_cur-&gt;rangeIO
suffix:semicolon
id|fix_me
(paren
id|res
comma
id|bus_cur
comma
id|range
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bus_cur-&gt;needMemUpdate
)paren
(brace
id|res
op_assign
id|bus_cur-&gt;firstMem
suffix:semicolon
id|range
op_assign
id|bus_cur-&gt;rangeMem
suffix:semicolon
id|fix_me
(paren
id|res
comma
id|bus_cur
comma
id|range
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bus_cur-&gt;needPFMemUpdate
)paren
(brace
id|res
op_assign
id|bus_cur-&gt;firstPFMem
suffix:semicolon
id|range
op_assign
id|bus_cur-&gt;rangePFMem
suffix:semicolon
id|fix_me
(paren
id|res
comma
id|bus_cur
comma
id|range
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*******************************************************************************&n; * This routine adds a resource to the list of resources to the appropriate bus &n; * based on their resource type and sorted by their starting addresses.  It assigns&n; * the ptrs to next and nextRange if needed.&n; *&n; * Input: resource ptr&n; * Output: ptrs assigned (to the node)&n; * 0 or -1&n; *******************************************************************************/
DECL|function|ibmphp_add_resource
r_int
id|ibmphp_add_resource
(paren
r_struct
id|resource_node
op_star
id|res
)paren
(brace
r_struct
id|resource_node
op_star
id|res_cur
suffix:semicolon
r_struct
id|resource_node
op_star
id|res_prev
suffix:semicolon
r_struct
id|bus_node
op_star
id|bus_cur
suffix:semicolon
r_struct
id|range_node
op_star
id|range_cur
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|resource_node
op_star
id|res_start
op_assign
l_int|NULL
suffix:semicolon
id|debug
(paren
l_string|&quot;%s - enter&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|res
)paren
(brace
id|err
(paren
l_string|&quot;NULL passed to add &bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|bus_cur
op_assign
id|find_bus_wprev
(paren
id|res-&gt;busno
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bus_cur
)paren
(brace
multiline_comment|/* didn&squot;t find a bus, smth&squot;s wrong!!! */
id|debug
(paren
l_string|&quot;no bus in the system, either pci_dev&squot;s wrong or allocation failed&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/* Normal case */
r_switch
c_cond
(paren
id|res-&gt;type
)paren
(brace
r_case
id|IO
suffix:colon
id|range_cur
op_assign
id|bus_cur-&gt;rangeIO
suffix:semicolon
id|res_start
op_assign
id|bus_cur-&gt;firstIO
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MEM
suffix:colon
id|range_cur
op_assign
id|bus_cur-&gt;rangeMem
suffix:semicolon
id|res_start
op_assign
id|bus_cur-&gt;firstMem
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PFMEM
suffix:colon
id|range_cur
op_assign
id|bus_cur-&gt;rangePFMem
suffix:semicolon
id|res_start
op_assign
id|bus_cur-&gt;firstPFMem
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|err
(paren
l_string|&quot;cannot read the type of the resource to add... problem &bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_while
c_loop
(paren
id|range_cur
)paren
(brace
r_if
c_cond
(paren
(paren
id|res-&gt;start
op_ge
id|range_cur-&gt;start
)paren
op_logical_and
(paren
id|res-&gt;end
op_le
id|range_cur-&gt;end
)paren
)paren
(brace
id|res-&gt;rangeno
op_assign
id|range_cur-&gt;rangeno
suffix:semicolon
r_break
suffix:semicolon
)brace
id|range_cur
op_assign
id|range_cur-&gt;next
suffix:semicolon
)brace
multiline_comment|/* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!&n;&t; * this is again the case of rangeno = -1&n;&t; * !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|range_cur
)paren
(brace
r_switch
c_cond
(paren
id|res-&gt;type
)paren
(brace
r_case
id|IO
suffix:colon
op_increment
id|bus_cur-&gt;needIOUpdate
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MEM
suffix:colon
op_increment
id|bus_cur-&gt;needMemUpdate
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PFMEM
suffix:colon
op_increment
id|bus_cur-&gt;needPFMemUpdate
suffix:semicolon
r_break
suffix:semicolon
)brace
id|res-&gt;rangeno
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
id|debug
(paren
l_string|&quot;The range is %d&bslash;n&quot;
comma
id|res-&gt;rangeno
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|res_start
)paren
(brace
multiline_comment|/* no first{IO,Mem,Pfmem} on the bus, 1st IO/Mem/Pfmem resource ever */
r_switch
c_cond
(paren
id|res-&gt;type
)paren
(brace
r_case
id|IO
suffix:colon
id|bus_cur-&gt;firstIO
op_assign
id|res
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MEM
suffix:colon
id|bus_cur-&gt;firstMem
op_assign
id|res
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PFMEM
suffix:colon
id|bus_cur-&gt;firstPFMem
op_assign
id|res
suffix:semicolon
r_break
suffix:semicolon
)brace
id|res-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|res-&gt;nextRange
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
(brace
id|res_cur
op_assign
id|res_start
suffix:semicolon
id|res_prev
op_assign
l_int|NULL
suffix:semicolon
id|debug
(paren
l_string|&quot;res_cur-&gt;rangeno is %d&bslash;n&quot;
comma
id|res_cur-&gt;rangeno
)paren
suffix:semicolon
r_while
c_loop
(paren
id|res_cur
)paren
(brace
r_if
c_cond
(paren
id|res_cur-&gt;rangeno
op_ge
id|res-&gt;rangeno
)paren
r_break
suffix:semicolon
id|res_prev
op_assign
id|res_cur
suffix:semicolon
r_if
c_cond
(paren
id|res_cur-&gt;next
)paren
id|res_cur
op_assign
id|res_cur-&gt;next
suffix:semicolon
r_else
id|res_cur
op_assign
id|res_cur-&gt;nextRange
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|res_cur
)paren
(brace
multiline_comment|/* at the end of the resource list */
id|debug
(paren
l_string|&quot;i should be here, [%x - %x]&bslash;n&quot;
comma
id|res-&gt;start
comma
id|res-&gt;end
)paren
suffix:semicolon
id|res_prev-&gt;nextRange
op_assign
id|res
suffix:semicolon
id|res-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|res-&gt;nextRange
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|res_cur-&gt;rangeno
op_eq
id|res-&gt;rangeno
)paren
(brace
multiline_comment|/* in the same range */
r_while
c_loop
(paren
id|res_cur
)paren
(brace
r_if
c_cond
(paren
id|res-&gt;start
OL
id|res_cur-&gt;start
)paren
r_break
suffix:semicolon
id|res_prev
op_assign
id|res_cur
suffix:semicolon
id|res_cur
op_assign
id|res_cur-&gt;next
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|res_cur
)paren
(brace
multiline_comment|/* the last resource in this range */
id|res_prev-&gt;next
op_assign
id|res
suffix:semicolon
id|res-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|res-&gt;nextRange
op_assign
id|res_prev-&gt;nextRange
suffix:semicolon
id|res_prev-&gt;nextRange
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|res-&gt;start
OL
id|res_cur-&gt;start
)paren
(brace
multiline_comment|/* at the beginning or middle of the range */
r_if
c_cond
(paren
op_logical_neg
id|res_prev
)paren
(brace
r_switch
c_cond
(paren
id|res-&gt;type
)paren
(brace
r_case
id|IO
suffix:colon
id|bus_cur-&gt;firstIO
op_assign
id|res
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MEM
suffix:colon
id|bus_cur-&gt;firstMem
op_assign
id|res
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PFMEM
suffix:colon
id|bus_cur-&gt;firstPFMem
op_assign
id|res
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|res_prev-&gt;rangeno
op_eq
id|res_cur-&gt;rangeno
)paren
id|res_prev-&gt;next
op_assign
id|res
suffix:semicolon
r_else
id|res_prev-&gt;nextRange
op_assign
id|res
suffix:semicolon
id|res-&gt;next
op_assign
id|res_cur
suffix:semicolon
id|res-&gt;nextRange
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* this is the case where it is 1st occurrence of the range */
r_if
c_cond
(paren
op_logical_neg
id|res_prev
)paren
(brace
multiline_comment|/* at the beginning of the resource list */
id|res-&gt;next
op_assign
l_int|NULL
suffix:semicolon
r_switch
c_cond
(paren
id|res-&gt;type
)paren
(brace
r_case
id|IO
suffix:colon
id|res-&gt;nextRange
op_assign
id|bus_cur-&gt;firstIO
suffix:semicolon
id|bus_cur-&gt;firstIO
op_assign
id|res
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MEM
suffix:colon
id|res-&gt;nextRange
op_assign
id|bus_cur-&gt;firstMem
suffix:semicolon
id|bus_cur-&gt;firstMem
op_assign
id|res
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PFMEM
suffix:colon
id|res-&gt;nextRange
op_assign
id|bus_cur-&gt;firstPFMem
suffix:semicolon
id|bus_cur-&gt;firstPFMem
op_assign
id|res
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|res_cur-&gt;rangeno
OG
id|res-&gt;rangeno
)paren
(brace
multiline_comment|/* in the middle of the resource list */
id|res_prev-&gt;nextRange
op_assign
id|res
suffix:semicolon
id|res-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|res-&gt;nextRange
op_assign
id|res_cur
suffix:semicolon
)brace
)brace
)brace
id|debug
(paren
l_string|&quot;%s - exit&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/****************************************************************************&n; * This routine will remove the resource from the list of resources&n; *&n; * Input: io, mem, and/or pfmem resource to be deleted&n; * Ouput: modified resource list&n; *        0 or error code&n; ****************************************************************************/
DECL|function|ibmphp_remove_resource
r_int
id|ibmphp_remove_resource
(paren
r_struct
id|resource_node
op_star
id|res
)paren
(brace
r_struct
id|bus_node
op_star
id|bus_cur
suffix:semicolon
r_struct
id|resource_node
op_star
id|res_cur
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|resource_node
op_star
id|res_prev
suffix:semicolon
r_struct
id|resource_node
op_star
id|mem_cur
suffix:semicolon
r_char
op_star
id|type
op_assign
l_string|&quot;&quot;
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|res
)paren
(brace
id|err
(paren
l_string|&quot;resource to remove is NULL &bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|bus_cur
op_assign
id|find_bus_wprev
(paren
id|res-&gt;busno
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bus_cur
)paren
(brace
id|err
(paren
l_string|&quot;cannot find corresponding bus of the io resource to remove  &quot;
l_string|&quot;bailing out...&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|res-&gt;type
)paren
(brace
r_case
id|IO
suffix:colon
id|res_cur
op_assign
id|bus_cur-&gt;firstIO
suffix:semicolon
id|type
op_assign
l_string|&quot;io&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MEM
suffix:colon
id|res_cur
op_assign
id|bus_cur-&gt;firstMem
suffix:semicolon
id|type
op_assign
l_string|&quot;mem&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PFMEM
suffix:colon
id|res_cur
op_assign
id|bus_cur-&gt;firstPFMem
suffix:semicolon
id|type
op_assign
l_string|&quot;pfmem&quot;
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|err
(paren
l_string|&quot;unknown type for resource to remove &bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|res_prev
op_assign
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
id|res_cur
)paren
(brace
r_if
c_cond
(paren
(paren
id|res_cur-&gt;start
op_eq
id|res-&gt;start
)paren
op_logical_and
(paren
id|res_cur-&gt;end
op_eq
id|res-&gt;end
)paren
)paren
r_break
suffix:semicolon
id|res_prev
op_assign
id|res_cur
suffix:semicolon
r_if
c_cond
(paren
id|res_cur-&gt;next
)paren
id|res_cur
op_assign
id|res_cur-&gt;next
suffix:semicolon
r_else
id|res_cur
op_assign
id|res_cur-&gt;nextRange
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|res_cur
)paren
(brace
r_if
c_cond
(paren
id|res-&gt;type
op_eq
id|PFMEM
)paren
(brace
multiline_comment|/* &n;&t;&t;&t; * case where pfmem might be in the PFMemFromMem list&n;&t;&t;&t; * so will also need to remove the corresponding mem&n;&t;&t;&t; * entry&n;&t;&t;&t; */
id|res_cur
op_assign
id|bus_cur-&gt;firstPFMemFromMem
suffix:semicolon
id|res_prev
op_assign
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
id|res_cur
)paren
(brace
r_if
c_cond
(paren
(paren
id|res_cur-&gt;start
op_eq
id|res-&gt;start
)paren
op_logical_and
(paren
id|res_cur-&gt;end
op_eq
id|res-&gt;end
)paren
)paren
(brace
id|mem_cur
op_assign
id|bus_cur-&gt;firstMem
suffix:semicolon
r_while
c_loop
(paren
id|mem_cur
)paren
(brace
r_if
c_cond
(paren
(paren
id|mem_cur-&gt;start
op_eq
id|res_cur-&gt;start
)paren
op_logical_and
(paren
id|mem_cur-&gt;end
op_eq
id|res_cur-&gt;end
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|mem_cur-&gt;next
)paren
id|mem_cur
op_assign
id|mem_cur-&gt;next
suffix:semicolon
r_else
id|mem_cur
op_assign
id|mem_cur-&gt;nextRange
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|mem_cur
)paren
(brace
id|err
(paren
l_string|&quot;cannot find corresponding mem node for pfmem...&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|ibmphp_remove_resource
(paren
id|mem_cur
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|res_prev
)paren
id|bus_cur-&gt;firstPFMemFromMem
op_assign
id|res_cur-&gt;next
suffix:semicolon
r_else
id|res_prev-&gt;next
op_assign
id|res_cur-&gt;next
suffix:semicolon
id|kfree
(paren
id|res_cur
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|res_prev
op_assign
id|res_cur
suffix:semicolon
r_if
c_cond
(paren
id|res_cur-&gt;next
)paren
id|res_cur
op_assign
id|res_cur-&gt;next
suffix:semicolon
r_else
id|res_cur
op_assign
id|res_cur-&gt;nextRange
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|res_cur
)paren
(brace
id|err
(paren
l_string|&quot;cannot find pfmem to delete...&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
r_else
(brace
id|err
(paren
l_string|&quot;the %s resource is not in the list to be deleted...&bslash;n&quot;
comma
id|type
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|res_prev
)paren
(brace
multiline_comment|/* first device to be deleted */
r_if
c_cond
(paren
id|res_cur-&gt;next
)paren
(brace
r_switch
c_cond
(paren
id|res-&gt;type
)paren
(brace
r_case
id|IO
suffix:colon
id|bus_cur-&gt;firstIO
op_assign
id|res_cur-&gt;next
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MEM
suffix:colon
id|bus_cur-&gt;firstMem
op_assign
id|res_cur-&gt;next
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PFMEM
suffix:colon
id|bus_cur-&gt;firstPFMem
op_assign
id|res_cur-&gt;next
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|res_cur-&gt;nextRange
)paren
(brace
r_switch
c_cond
(paren
id|res-&gt;type
)paren
(brace
r_case
id|IO
suffix:colon
id|bus_cur-&gt;firstIO
op_assign
id|res_cur-&gt;nextRange
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MEM
suffix:colon
id|bus_cur-&gt;firstMem
op_assign
id|res_cur-&gt;nextRange
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PFMEM
suffix:colon
id|bus_cur-&gt;firstPFMem
op_assign
id|res_cur-&gt;nextRange
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_else
(brace
r_switch
c_cond
(paren
id|res-&gt;type
)paren
(brace
r_case
id|IO
suffix:colon
id|bus_cur-&gt;firstIO
op_assign
l_int|NULL
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MEM
suffix:colon
id|bus_cur-&gt;firstMem
op_assign
l_int|NULL
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PFMEM
suffix:colon
id|bus_cur-&gt;firstPFMem
op_assign
l_int|NULL
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|kfree
(paren
id|res_cur
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|res_cur-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|res_prev-&gt;rangeno
op_eq
id|res_cur-&gt;rangeno
)paren
id|res_prev-&gt;next
op_assign
id|res_cur-&gt;next
suffix:semicolon
r_else
id|res_prev-&gt;nextRange
op_assign
id|res_cur-&gt;next
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|res_cur-&gt;nextRange
)paren
(brace
id|res_prev-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|res_prev-&gt;nextRange
op_assign
id|res_cur-&gt;nextRange
suffix:semicolon
)brace
r_else
(brace
id|res_prev-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|res_prev-&gt;nextRange
op_assign
l_int|NULL
suffix:semicolon
)brace
id|kfree
(paren
id|res_cur
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|find_range
r_static
r_struct
id|range_node
op_star
id|find_range
(paren
r_struct
id|bus_node
op_star
id|bus_cur
comma
r_struct
id|resource_node
op_star
id|res
)paren
(brace
r_struct
id|range_node
op_star
id|range
op_assign
l_int|NULL
suffix:semicolon
r_switch
c_cond
(paren
id|res-&gt;type
)paren
(brace
r_case
id|IO
suffix:colon
id|range
op_assign
id|bus_cur-&gt;rangeIO
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MEM
suffix:colon
id|range
op_assign
id|bus_cur-&gt;rangeMem
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PFMEM
suffix:colon
id|range
op_assign
id|bus_cur-&gt;rangePFMem
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|err
(paren
l_string|&quot;cannot read resource type in find_range &bslash;n&quot;
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|range
)paren
(brace
r_if
c_cond
(paren
id|res-&gt;rangeno
op_eq
id|range-&gt;rangeno
)paren
r_break
suffix:semicolon
id|range
op_assign
id|range-&gt;next
suffix:semicolon
)brace
r_return
id|range
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************&n; * This routine will check to make sure the io/mem/pfmem-&gt;len that the device asked for &n; * can fit w/i our list of available IO/MEM/PFMEM resources.  If cannot, returns -EINVAL,&n; * otherwise, returns 0&n; *&n; * Input: resource&n; * Ouput: the correct start and end address are inputted into the resource node,&n; *        0 or -EINVAL&n; *****************************************************************************/
DECL|function|ibmphp_check_resource
r_int
id|ibmphp_check_resource
(paren
r_struct
id|resource_node
op_star
id|res
comma
id|u8
id|bridge
)paren
(brace
r_struct
id|bus_node
op_star
id|bus_cur
suffix:semicolon
r_struct
id|range_node
op_star
id|range
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|resource_node
op_star
id|res_prev
suffix:semicolon
r_struct
id|resource_node
op_star
id|res_cur
op_assign
l_int|NULL
suffix:semicolon
id|u32
id|len_cur
op_assign
l_int|0
comma
id|start_cur
op_assign
l_int|0
comma
id|len_tmp
op_assign
l_int|0
suffix:semicolon
r_int
id|noranges
op_assign
l_int|0
suffix:semicolon
id|u32
id|tmp_start
suffix:semicolon
multiline_comment|/* this is to make sure start address is divisible by the length needed */
id|u32
id|tmp_divide
suffix:semicolon
id|u8
id|flag
op_assign
id|FALSE
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|res
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|bridge
)paren
(brace
multiline_comment|/* The rules for bridges are different, 4K divisible for IO, 1M for (pf)mem*/
r_if
c_cond
(paren
id|res-&gt;type
op_eq
id|IO
)paren
id|tmp_divide
op_assign
id|IOBRIDGE
suffix:semicolon
r_else
id|tmp_divide
op_assign
id|MEMBRIDGE
suffix:semicolon
)brace
r_else
id|tmp_divide
op_assign
id|res-&gt;len
suffix:semicolon
id|bus_cur
op_assign
id|find_bus_wprev
(paren
id|res-&gt;busno
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bus_cur
)paren
(brace
multiline_comment|/* didn&squot;t find a bus, smth&squot;s wrong!!! */
id|debug
(paren
l_string|&quot;no bus in the system, either pci_dev&squot;s wrong or allocation failed &bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|debug
(paren
l_string|&quot;%s - enter&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
id|debug
(paren
l_string|&quot;bus_cur-&gt;busno is %d&bslash;n&quot;
comma
id|bus_cur-&gt;busno
)paren
suffix:semicolon
multiline_comment|/* This is a quick fix to not mess up with the code very much.  i.e.,&n;&t; * 2000-2fff, len = 1000, but when we compare, we need it to be fff */
id|res-&gt;len
op_sub_assign
l_int|1
suffix:semicolon
r_switch
c_cond
(paren
id|res-&gt;type
)paren
(brace
r_case
id|IO
suffix:colon
id|res_cur
op_assign
id|bus_cur-&gt;firstIO
suffix:semicolon
id|noranges
op_assign
id|bus_cur-&gt;noIORanges
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MEM
suffix:colon
id|res_cur
op_assign
id|bus_cur-&gt;firstMem
suffix:semicolon
id|noranges
op_assign
id|bus_cur-&gt;noMemRanges
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PFMEM
suffix:colon
id|res_cur
op_assign
id|bus_cur-&gt;firstPFMem
suffix:semicolon
id|noranges
op_assign
id|bus_cur-&gt;noPFMemRanges
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|err
(paren
l_string|&quot;wrong type of resource to check &bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|res_prev
op_assign
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
id|res_cur
)paren
(brace
id|range
op_assign
id|find_range
(paren
id|bus_cur
comma
id|res_cur
)paren
suffix:semicolon
id|debug
(paren
l_string|&quot;%s - rangeno = %d&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|res_cur-&gt;rangeno
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|range
)paren
(brace
id|err
(paren
l_string|&quot;no range for the device exists... bailing out...&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* found our range */
r_if
c_cond
(paren
op_logical_neg
id|res_prev
)paren
(brace
multiline_comment|/* first time in the loop */
r_if
c_cond
(paren
(paren
id|res_cur-&gt;start
op_ne
id|range-&gt;start
)paren
op_logical_and
(paren
(paren
id|len_tmp
op_assign
id|res_cur-&gt;start
op_minus
l_int|1
op_minus
id|range-&gt;start
)paren
op_ge
id|res-&gt;len
)paren
)paren
(brace
id|debug
(paren
l_string|&quot;len_tmp = %x&bslash;n&quot;
comma
id|len_tmp
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|len_tmp
OL
id|len_cur
)paren
op_logical_or
(paren
id|len_cur
op_eq
l_int|0
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|range-&gt;start
op_mod
id|tmp_divide
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* just perfect, starting address is divisible by length */
id|flag
op_assign
id|TRUE
suffix:semicolon
id|len_cur
op_assign
id|len_tmp
suffix:semicolon
id|start_cur
op_assign
id|range-&gt;start
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Needs adjusting */
id|tmp_start
op_assign
id|range-&gt;start
suffix:semicolon
id|flag
op_assign
id|FALSE
suffix:semicolon
r_while
c_loop
(paren
(paren
id|len_tmp
op_assign
id|res_cur-&gt;start
op_minus
l_int|1
op_minus
id|tmp_start
)paren
op_ge
id|res-&gt;len
)paren
(brace
r_if
c_cond
(paren
(paren
id|tmp_start
op_mod
id|tmp_divide
)paren
op_eq
l_int|0
)paren
(brace
id|flag
op_assign
id|TRUE
suffix:semicolon
id|len_cur
op_assign
id|len_tmp
suffix:semicolon
id|start_cur
op_assign
id|tmp_start
suffix:semicolon
r_break
suffix:semicolon
)brace
id|tmp_start
op_add_assign
id|tmp_divide
op_minus
id|tmp_start
op_mod
id|tmp_divide
suffix:semicolon
r_if
c_cond
(paren
id|tmp_start
op_ge
id|res_cur-&gt;start
op_minus
l_int|1
)paren
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|flag
op_logical_and
id|len_cur
op_eq
id|res-&gt;len
)paren
(brace
id|debug
(paren
l_string|&quot;but we are not here, right?&bslash;n&quot;
)paren
suffix:semicolon
id|res-&gt;start
op_assign
id|start_cur
suffix:semicolon
id|res-&gt;len
op_add_assign
l_int|1
suffix:semicolon
multiline_comment|/* To restore the balance */
id|res-&gt;end
op_assign
id|res-&gt;start
op_plus
id|res-&gt;len
op_minus
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|res_cur-&gt;next
)paren
(brace
multiline_comment|/* last device on the range */
r_if
c_cond
(paren
(paren
id|range-&gt;end
op_ne
id|res_cur-&gt;end
)paren
op_logical_and
(paren
(paren
id|len_tmp
op_assign
id|range-&gt;end
op_minus
(paren
id|res_cur-&gt;end
op_plus
l_int|1
)paren
)paren
op_ge
id|res-&gt;len
)paren
)paren
(brace
id|debug
(paren
l_string|&quot;len_tmp = %x&bslash;n&quot;
comma
id|len_tmp
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|len_tmp
OL
id|len_cur
)paren
op_logical_or
(paren
id|len_cur
op_eq
l_int|0
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
id|res_cur-&gt;end
op_plus
l_int|1
)paren
op_mod
id|tmp_divide
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* just perfect, starting address is divisible by length */
id|flag
op_assign
id|TRUE
suffix:semicolon
id|len_cur
op_assign
id|len_tmp
suffix:semicolon
id|start_cur
op_assign
id|res_cur-&gt;end
op_plus
l_int|1
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Needs adjusting */
id|tmp_start
op_assign
id|res_cur-&gt;end
op_plus
l_int|1
suffix:semicolon
id|flag
op_assign
id|FALSE
suffix:semicolon
r_while
c_loop
(paren
(paren
id|len_tmp
op_assign
id|range-&gt;end
op_minus
id|tmp_start
)paren
op_ge
id|res-&gt;len
)paren
(brace
r_if
c_cond
(paren
(paren
id|tmp_start
op_mod
id|tmp_divide
)paren
op_eq
l_int|0
)paren
(brace
id|flag
op_assign
id|TRUE
suffix:semicolon
id|len_cur
op_assign
id|len_tmp
suffix:semicolon
id|start_cur
op_assign
id|tmp_start
suffix:semicolon
r_break
suffix:semicolon
)brace
id|tmp_start
op_add_assign
id|tmp_divide
op_minus
id|tmp_start
op_mod
id|tmp_divide
suffix:semicolon
r_if
c_cond
(paren
id|tmp_start
op_ge
id|range-&gt;end
)paren
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|flag
op_logical_and
id|len_cur
op_eq
id|res-&gt;len
)paren
(brace
id|res-&gt;start
op_assign
id|start_cur
suffix:semicolon
id|res-&gt;len
op_add_assign
l_int|1
suffix:semicolon
multiline_comment|/* To restore the balance */
id|res-&gt;end
op_assign
id|res-&gt;start
op_plus
id|res-&gt;len
op_minus
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
)brace
)brace
r_if
c_cond
(paren
id|res_prev
)paren
(brace
r_if
c_cond
(paren
id|res_prev-&gt;rangeno
op_ne
id|res_cur-&gt;rangeno
)paren
(brace
multiline_comment|/* 1st device on this range */
r_if
c_cond
(paren
(paren
id|res_cur-&gt;start
op_ne
id|range-&gt;start
)paren
op_logical_and
(paren
(paren
id|len_tmp
op_assign
id|res_cur-&gt;start
op_minus
l_int|1
op_minus
id|range-&gt;start
)paren
op_ge
id|res-&gt;len
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|len_tmp
OL
id|len_cur
)paren
op_logical_or
(paren
id|len_cur
op_eq
l_int|0
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|range-&gt;start
op_mod
id|tmp_divide
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* just perfect, starting address is divisible by length */
id|flag
op_assign
id|TRUE
suffix:semicolon
id|len_cur
op_assign
id|len_tmp
suffix:semicolon
id|start_cur
op_assign
id|range-&gt;start
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Needs adjusting */
id|tmp_start
op_assign
id|range-&gt;start
suffix:semicolon
id|flag
op_assign
id|FALSE
suffix:semicolon
r_while
c_loop
(paren
(paren
id|len_tmp
op_assign
id|res_cur-&gt;start
op_minus
l_int|1
op_minus
id|tmp_start
)paren
op_ge
id|res-&gt;len
)paren
(brace
r_if
c_cond
(paren
(paren
id|tmp_start
op_mod
id|tmp_divide
)paren
op_eq
l_int|0
)paren
(brace
id|flag
op_assign
id|TRUE
suffix:semicolon
id|len_cur
op_assign
id|len_tmp
suffix:semicolon
id|start_cur
op_assign
id|tmp_start
suffix:semicolon
r_break
suffix:semicolon
)brace
id|tmp_start
op_add_assign
id|tmp_divide
op_minus
id|tmp_start
op_mod
id|tmp_divide
suffix:semicolon
r_if
c_cond
(paren
id|tmp_start
op_ge
id|res_cur-&gt;start
op_minus
l_int|1
)paren
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|flag
op_logical_and
id|len_cur
op_eq
id|res-&gt;len
)paren
(brace
id|res-&gt;start
op_assign
id|start_cur
suffix:semicolon
id|res-&gt;len
op_add_assign
l_int|1
suffix:semicolon
multiline_comment|/* To restore the balance */
id|res-&gt;end
op_assign
id|res-&gt;start
op_plus
id|res-&gt;len
op_minus
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
)brace
)brace
r_else
(brace
multiline_comment|/* in the same range */
r_if
c_cond
(paren
(paren
id|len_tmp
op_assign
id|res_cur-&gt;start
op_minus
l_int|1
op_minus
id|res_prev-&gt;end
op_minus
l_int|1
)paren
op_ge
id|res-&gt;len
)paren
(brace
r_if
c_cond
(paren
(paren
id|len_tmp
OL
id|len_cur
)paren
op_logical_or
(paren
id|len_cur
op_eq
l_int|0
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
id|res_prev-&gt;end
op_plus
l_int|1
)paren
op_mod
id|tmp_divide
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* just perfect, starting address&squot;s divisible by length */
id|flag
op_assign
id|TRUE
suffix:semicolon
id|len_cur
op_assign
id|len_tmp
suffix:semicolon
id|start_cur
op_assign
id|res_prev-&gt;end
op_plus
l_int|1
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Needs adjusting */
id|tmp_start
op_assign
id|res_prev-&gt;end
op_plus
l_int|1
suffix:semicolon
id|flag
op_assign
id|FALSE
suffix:semicolon
r_while
c_loop
(paren
(paren
id|len_tmp
op_assign
id|res_cur-&gt;start
op_minus
l_int|1
op_minus
id|tmp_start
)paren
op_ge
id|res-&gt;len
)paren
(brace
r_if
c_cond
(paren
(paren
id|tmp_start
op_mod
id|tmp_divide
)paren
op_eq
l_int|0
)paren
(brace
id|flag
op_assign
id|TRUE
suffix:semicolon
id|len_cur
op_assign
id|len_tmp
suffix:semicolon
id|start_cur
op_assign
id|tmp_start
suffix:semicolon
r_break
suffix:semicolon
)brace
id|tmp_start
op_add_assign
id|tmp_divide
op_minus
id|tmp_start
op_mod
id|tmp_divide
suffix:semicolon
r_if
c_cond
(paren
id|tmp_start
op_ge
id|res_cur-&gt;start
op_minus
l_int|1
)paren
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|flag
op_logical_and
id|len_cur
op_eq
id|res-&gt;len
)paren
(brace
id|res-&gt;start
op_assign
id|start_cur
suffix:semicolon
id|res-&gt;len
op_add_assign
l_int|1
suffix:semicolon
multiline_comment|/* To restore the balance */
id|res-&gt;end
op_assign
id|res-&gt;start
op_plus
id|res-&gt;len
op_minus
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
)brace
)brace
)brace
multiline_comment|/* end if (res_prev) */
id|res_prev
op_assign
id|res_cur
suffix:semicolon
r_if
c_cond
(paren
id|res_cur-&gt;next
)paren
id|res_cur
op_assign
id|res_cur-&gt;next
suffix:semicolon
r_else
id|res_cur
op_assign
id|res_cur-&gt;nextRange
suffix:semicolon
)brace
multiline_comment|/* end of while */
r_if
c_cond
(paren
op_logical_neg
id|res_prev
)paren
(brace
multiline_comment|/* 1st device ever */
multiline_comment|/* need to find appropriate range */
r_switch
c_cond
(paren
id|res-&gt;type
)paren
(brace
r_case
id|IO
suffix:colon
id|range
op_assign
id|bus_cur-&gt;rangeIO
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MEM
suffix:colon
id|range
op_assign
id|bus_cur-&gt;rangeMem
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PFMEM
suffix:colon
id|range
op_assign
id|bus_cur-&gt;rangePFMem
suffix:semicolon
r_break
suffix:semicolon
)brace
r_while
c_loop
(paren
id|range
)paren
(brace
r_if
c_cond
(paren
(paren
id|len_tmp
op_assign
id|range-&gt;end
op_minus
id|range-&gt;start
)paren
op_ge
id|res-&gt;len
)paren
(brace
r_if
c_cond
(paren
(paren
id|len_tmp
OL
id|len_cur
)paren
op_logical_or
(paren
id|len_cur
op_eq
l_int|0
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|range-&gt;start
op_mod
id|tmp_divide
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* just perfect, starting address&squot;s divisible by length */
id|flag
op_assign
id|TRUE
suffix:semicolon
id|len_cur
op_assign
id|len_tmp
suffix:semicolon
id|start_cur
op_assign
id|range-&gt;start
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Needs adjusting */
id|tmp_start
op_assign
id|range-&gt;start
suffix:semicolon
id|flag
op_assign
id|FALSE
suffix:semicolon
r_while
c_loop
(paren
(paren
id|len_tmp
op_assign
id|range-&gt;end
op_minus
id|tmp_start
)paren
op_ge
id|res-&gt;len
)paren
(brace
r_if
c_cond
(paren
(paren
id|tmp_start
op_mod
id|tmp_divide
)paren
op_eq
l_int|0
)paren
(brace
id|flag
op_assign
id|TRUE
suffix:semicolon
id|len_cur
op_assign
id|len_tmp
suffix:semicolon
id|start_cur
op_assign
id|tmp_start
suffix:semicolon
r_break
suffix:semicolon
)brace
id|tmp_start
op_add_assign
id|tmp_divide
op_minus
id|tmp_start
op_mod
id|tmp_divide
suffix:semicolon
r_if
c_cond
(paren
id|tmp_start
op_ge
id|range-&gt;end
)paren
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|flag
op_logical_and
id|len_cur
op_eq
id|res-&gt;len
)paren
(brace
id|res-&gt;start
op_assign
id|start_cur
suffix:semicolon
id|res-&gt;len
op_add_assign
l_int|1
suffix:semicolon
multiline_comment|/* To restore the balance */
id|res-&gt;end
op_assign
id|res-&gt;start
op_plus
id|res-&gt;len
op_minus
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
)brace
id|range
op_assign
id|range-&gt;next
suffix:semicolon
)brace
multiline_comment|/* end of while */
r_if
c_cond
(paren
(paren
op_logical_neg
id|range
)paren
op_logical_and
(paren
id|len_cur
op_eq
l_int|0
)paren
)paren
(brace
multiline_comment|/* have gone through the list of devices and ranges and haven&squot;t found n.e.thing */
id|err
(paren
l_string|&quot;no appropriate range.. bailing out...&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|len_cur
)paren
(brace
id|res-&gt;start
op_assign
id|start_cur
suffix:semicolon
id|res-&gt;len
op_add_assign
l_int|1
suffix:semicolon
multiline_comment|/* To restore the balance */
id|res-&gt;end
op_assign
id|res-&gt;start
op_plus
id|res-&gt;len
op_minus
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|res_cur
)paren
(brace
id|debug
(paren
l_string|&quot;prev-&gt;rangeno = %d, noranges = %d&bslash;n&quot;
comma
id|res_prev-&gt;rangeno
comma
id|noranges
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res_prev-&gt;rangeno
OL
id|noranges
)paren
(brace
multiline_comment|/* if there&squot;re more ranges out there to check */
r_switch
c_cond
(paren
id|res-&gt;type
)paren
(brace
r_case
id|IO
suffix:colon
id|range
op_assign
id|bus_cur-&gt;rangeIO
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MEM
suffix:colon
id|range
op_assign
id|bus_cur-&gt;rangeMem
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PFMEM
suffix:colon
id|range
op_assign
id|bus_cur-&gt;rangePFMem
suffix:semicolon
r_break
suffix:semicolon
)brace
r_while
c_loop
(paren
id|range
)paren
(brace
r_if
c_cond
(paren
(paren
id|len_tmp
op_assign
id|range-&gt;end
op_minus
id|range-&gt;start
)paren
op_ge
id|res-&gt;len
)paren
(brace
r_if
c_cond
(paren
(paren
id|len_tmp
OL
id|len_cur
)paren
op_logical_or
(paren
id|len_cur
op_eq
l_int|0
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|range-&gt;start
op_mod
id|tmp_divide
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* just perfect, starting address&squot;s divisible by length */
id|flag
op_assign
id|TRUE
suffix:semicolon
id|len_cur
op_assign
id|len_tmp
suffix:semicolon
id|start_cur
op_assign
id|range-&gt;start
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Needs adjusting */
id|tmp_start
op_assign
id|range-&gt;start
suffix:semicolon
id|flag
op_assign
id|FALSE
suffix:semicolon
r_while
c_loop
(paren
(paren
id|len_tmp
op_assign
id|range-&gt;end
op_minus
id|tmp_start
)paren
op_ge
id|res-&gt;len
)paren
(brace
r_if
c_cond
(paren
(paren
id|tmp_start
op_mod
id|tmp_divide
)paren
op_eq
l_int|0
)paren
(brace
id|flag
op_assign
id|TRUE
suffix:semicolon
id|len_cur
op_assign
id|len_tmp
suffix:semicolon
id|start_cur
op_assign
id|tmp_start
suffix:semicolon
r_break
suffix:semicolon
)brace
id|tmp_start
op_add_assign
id|tmp_divide
op_minus
id|tmp_start
op_mod
id|tmp_divide
suffix:semicolon
r_if
c_cond
(paren
id|tmp_start
op_ge
id|range-&gt;end
)paren
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|flag
op_logical_and
id|len_cur
op_eq
id|res-&gt;len
)paren
(brace
id|res-&gt;start
op_assign
id|start_cur
suffix:semicolon
id|res-&gt;len
op_add_assign
l_int|1
suffix:semicolon
multiline_comment|/* To restore the balance */
id|res-&gt;end
op_assign
id|res-&gt;start
op_plus
id|res-&gt;len
op_minus
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
)brace
id|range
op_assign
id|range-&gt;next
suffix:semicolon
)brace
multiline_comment|/* end of while */
r_if
c_cond
(paren
(paren
op_logical_neg
id|range
)paren
op_logical_and
(paren
id|len_cur
op_eq
l_int|0
)paren
)paren
(brace
multiline_comment|/* have gone through the list of devices and ranges and haven&squot;t found n.e.thing */
id|err
(paren
l_string|&quot;no appropriate range.. bailing out...&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|len_cur
)paren
(brace
id|res-&gt;start
op_assign
id|start_cur
suffix:semicolon
id|res-&gt;len
op_add_assign
l_int|1
suffix:semicolon
multiline_comment|/* To restore the balance */
id|res-&gt;end
op_assign
id|res-&gt;start
op_plus
id|res-&gt;len
op_minus
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* no more ranges to check on */
r_if
c_cond
(paren
id|len_cur
)paren
(brace
id|res-&gt;start
op_assign
id|start_cur
suffix:semicolon
id|res-&gt;len
op_add_assign
l_int|1
suffix:semicolon
multiline_comment|/* To restore the balance */
id|res-&gt;end
op_assign
id|res-&gt;start
op_plus
id|res-&gt;len
op_minus
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* have gone through the list of devices and haven&squot;t found n.e.thing */
id|err
(paren
l_string|&quot;no appropriate range.. bailing out...&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* end if(!res_cur) */
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/********************************************************************************&n; * This routine is called from remove_card if the card contained PPB.&n; * It will remove all the resources on the bus as well as the bus itself&n; * Input: Bus&n; * Ouput: 0, -ENODEV&n; ********************************************************************************/
DECL|function|ibmphp_remove_bus
r_int
id|ibmphp_remove_bus
(paren
r_struct
id|bus_node
op_star
id|bus
comma
id|u8
id|parent_busno
)paren
(brace
r_struct
id|resource_node
op_star
id|res_cur
suffix:semicolon
r_struct
id|resource_node
op_star
id|res_tmp
suffix:semicolon
r_struct
id|bus_node
op_star
id|prev_bus
suffix:semicolon
r_int
id|rc
suffix:semicolon
id|prev_bus
op_assign
id|find_bus_wprev
(paren
id|parent_busno
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|prev_bus
)paren
(brace
id|debug
(paren
l_string|&quot;something terribly wrong. Cannot find parent bus to the one to remove&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|debug
(paren
l_string|&quot;In ibmphp_remove_bus... prev_bus-&gt;busno is %x&bslash;n&quot;
comma
id|prev_bus-&gt;busno
)paren
suffix:semicolon
id|rc
op_assign
id|remove_ranges
(paren
id|bus
comma
id|prev_bus
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_return
id|rc
suffix:semicolon
r_if
c_cond
(paren
id|bus-&gt;firstIO
)paren
(brace
id|res_cur
op_assign
id|bus-&gt;firstIO
suffix:semicolon
r_while
c_loop
(paren
id|res_cur
)paren
(brace
id|res_tmp
op_assign
id|res_cur
suffix:semicolon
r_if
c_cond
(paren
id|res_cur-&gt;next
)paren
id|res_cur
op_assign
id|res_cur-&gt;next
suffix:semicolon
r_else
id|res_cur
op_assign
id|res_cur-&gt;nextRange
suffix:semicolon
id|kfree
(paren
id|res_tmp
)paren
suffix:semicolon
id|res_tmp
op_assign
l_int|NULL
suffix:semicolon
)brace
id|bus-&gt;firstIO
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bus-&gt;firstMem
)paren
(brace
id|res_cur
op_assign
id|bus-&gt;firstMem
suffix:semicolon
r_while
c_loop
(paren
id|res_cur
)paren
(brace
id|res_tmp
op_assign
id|res_cur
suffix:semicolon
r_if
c_cond
(paren
id|res_cur-&gt;next
)paren
id|res_cur
op_assign
id|res_cur-&gt;next
suffix:semicolon
r_else
id|res_cur
op_assign
id|res_cur-&gt;nextRange
suffix:semicolon
id|kfree
(paren
id|res_tmp
)paren
suffix:semicolon
id|res_tmp
op_assign
l_int|NULL
suffix:semicolon
)brace
id|bus-&gt;firstMem
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bus-&gt;firstPFMem
)paren
(brace
id|res_cur
op_assign
id|bus-&gt;firstPFMem
suffix:semicolon
r_while
c_loop
(paren
id|res_cur
)paren
(brace
id|res_tmp
op_assign
id|res_cur
suffix:semicolon
r_if
c_cond
(paren
id|res_cur-&gt;next
)paren
id|res_cur
op_assign
id|res_cur-&gt;next
suffix:semicolon
r_else
id|res_cur
op_assign
id|res_cur-&gt;nextRange
suffix:semicolon
id|kfree
(paren
id|res_tmp
)paren
suffix:semicolon
id|res_tmp
op_assign
l_int|NULL
suffix:semicolon
)brace
id|bus-&gt;firstPFMem
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bus-&gt;firstPFMemFromMem
)paren
(brace
id|res_cur
op_assign
id|bus-&gt;firstPFMemFromMem
suffix:semicolon
r_while
c_loop
(paren
id|res_cur
)paren
(brace
id|res_tmp
op_assign
id|res_cur
suffix:semicolon
id|res_cur
op_assign
id|res_cur-&gt;next
suffix:semicolon
id|kfree
(paren
id|res_tmp
)paren
suffix:semicolon
id|res_tmp
op_assign
l_int|NULL
suffix:semicolon
)brace
id|bus-&gt;firstPFMemFromMem
op_assign
l_int|NULL
suffix:semicolon
)brace
id|list_del
(paren
op_amp
id|bus-&gt;bus_list
)paren
suffix:semicolon
id|kfree
(paren
id|bus
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; * This routine deletes the ranges from a given bus, and the entries from the &n; * parent&squot;s bus in the resources&n; * Input: current bus, previous bus&n; * Output: 0, -EINVAL&n; ******************************************************************************/
DECL|function|remove_ranges
r_static
r_int
id|remove_ranges
(paren
r_struct
id|bus_node
op_star
id|bus_cur
comma
r_struct
id|bus_node
op_star
id|bus_prev
)paren
(brace
r_struct
id|range_node
op_star
id|range_cur
suffix:semicolon
r_struct
id|range_node
op_star
id|range_tmp
suffix:semicolon
r_int
id|i
suffix:semicolon
r_struct
id|resource_node
op_star
id|res
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|bus_cur-&gt;noIORanges
)paren
(brace
id|range_cur
op_assign
id|bus_cur-&gt;rangeIO
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|bus_cur-&gt;noIORanges
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|ibmphp_find_resource
(paren
id|bus_prev
comma
id|range_cur-&gt;start
comma
op_amp
id|res
comma
id|IO
)paren
OL
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|ibmphp_remove_resource
(paren
id|res
)paren
suffix:semicolon
id|range_tmp
op_assign
id|range_cur
suffix:semicolon
id|range_cur
op_assign
id|range_cur-&gt;next
suffix:semicolon
id|kfree
(paren
id|range_tmp
)paren
suffix:semicolon
id|range_tmp
op_assign
l_int|NULL
suffix:semicolon
)brace
id|bus_cur-&gt;rangeIO
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bus_cur-&gt;noMemRanges
)paren
(brace
id|range_cur
op_assign
id|bus_cur-&gt;rangeMem
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|bus_cur-&gt;noMemRanges
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|ibmphp_find_resource
(paren
id|bus_prev
comma
id|range_cur-&gt;start
comma
op_amp
id|res
comma
id|MEM
)paren
OL
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|ibmphp_remove_resource
(paren
id|res
)paren
suffix:semicolon
id|range_tmp
op_assign
id|range_cur
suffix:semicolon
id|range_cur
op_assign
id|range_cur-&gt;next
suffix:semicolon
id|kfree
(paren
id|range_tmp
)paren
suffix:semicolon
id|range_tmp
op_assign
l_int|NULL
suffix:semicolon
)brace
id|bus_cur-&gt;rangeMem
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bus_cur-&gt;noPFMemRanges
)paren
(brace
id|range_cur
op_assign
id|bus_cur-&gt;rangePFMem
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|bus_cur-&gt;noPFMemRanges
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|ibmphp_find_resource
(paren
id|bus_prev
comma
id|range_cur-&gt;start
comma
op_amp
id|res
comma
id|PFMEM
)paren
OL
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|ibmphp_remove_resource
(paren
id|res
)paren
suffix:semicolon
id|range_tmp
op_assign
id|range_cur
suffix:semicolon
id|range_cur
op_assign
id|range_cur-&gt;next
suffix:semicolon
id|kfree
(paren
id|range_tmp
)paren
suffix:semicolon
id|range_tmp
op_assign
l_int|NULL
suffix:semicolon
)brace
id|bus_cur-&gt;rangePFMem
op_assign
l_int|NULL
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * find the resource node in the bus &n; * Input: Resource needed, start address of the resource, type of resource&n; */
DECL|function|ibmphp_find_resource
r_int
id|ibmphp_find_resource
(paren
r_struct
id|bus_node
op_star
id|bus
comma
id|u32
id|start_address
comma
r_struct
id|resource_node
op_star
op_star
id|res
comma
r_int
id|flag
)paren
(brace
r_struct
id|resource_node
op_star
id|res_cur
op_assign
l_int|NULL
suffix:semicolon
r_char
op_star
id|type
op_assign
l_string|&quot;&quot;
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bus
)paren
(brace
id|err
(paren
l_string|&quot;The bus passed in NULL to find resource &bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|flag
)paren
(brace
r_case
id|IO
suffix:colon
id|res_cur
op_assign
id|bus-&gt;firstIO
suffix:semicolon
id|type
op_assign
l_string|&quot;io&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MEM
suffix:colon
id|res_cur
op_assign
id|bus-&gt;firstMem
suffix:semicolon
id|type
op_assign
l_string|&quot;mem&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PFMEM
suffix:colon
id|res_cur
op_assign
id|bus-&gt;firstPFMem
suffix:semicolon
id|type
op_assign
l_string|&quot;pfmem&quot;
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|err
(paren
l_string|&quot;wrong type of flag &bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_while
c_loop
(paren
id|res_cur
)paren
(brace
r_if
c_cond
(paren
id|res_cur-&gt;start
op_eq
id|start_address
)paren
(brace
op_star
id|res
op_assign
id|res_cur
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|res_cur-&gt;next
)paren
id|res_cur
op_assign
id|res_cur-&gt;next
suffix:semicolon
r_else
id|res_cur
op_assign
id|res_cur-&gt;nextRange
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|res_cur
)paren
(brace
r_if
c_cond
(paren
id|flag
op_eq
id|PFMEM
)paren
(brace
id|res_cur
op_assign
id|bus-&gt;firstPFMemFromMem
suffix:semicolon
r_while
c_loop
(paren
id|res_cur
)paren
(brace
r_if
c_cond
(paren
id|res_cur-&gt;start
op_eq
id|start_address
)paren
(brace
op_star
id|res
op_assign
id|res_cur
suffix:semicolon
r_break
suffix:semicolon
)brace
id|res_cur
op_assign
id|res_cur-&gt;next
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|res_cur
)paren
(brace
id|debug
(paren
l_string|&quot;SOS...cannot find %s resource in the bus. &bslash;n&quot;
comma
id|type
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
r_else
(brace
id|debug
(paren
l_string|&quot;SOS... cannot find %s resource in the bus. &bslash;n&quot;
comma
id|type
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_star
id|res
)paren
id|debug
(paren
l_string|&quot;*res-&gt;start = %x &bslash;n&quot;
comma
(paren
op_star
id|res
)paren
op_member_access_from_pointer
id|start
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/***********************************************************************&n; * This routine will free the resource structures used by the&n; * system.  It is called from cleanup routine for the module&n; * Parameters: none&n; * Returns: none&n; ***********************************************************************/
DECL|function|ibmphp_free_resources
r_void
id|ibmphp_free_resources
(paren
r_void
)paren
(brace
r_struct
id|bus_node
op_star
id|bus_cur
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|bus_node
op_star
id|bus_tmp
suffix:semicolon
r_struct
id|range_node
op_star
id|range_cur
suffix:semicolon
r_struct
id|range_node
op_star
id|range_tmp
suffix:semicolon
r_struct
id|resource_node
op_star
id|res_cur
suffix:semicolon
r_struct
id|resource_node
op_star
id|res_tmp
suffix:semicolon
r_struct
id|list_head
op_star
id|tmp
suffix:semicolon
r_struct
id|list_head
op_star
id|next
suffix:semicolon
r_int
id|i
op_assign
l_int|0
suffix:semicolon
id|flags
op_assign
l_int|1
suffix:semicolon
id|list_for_each_safe
(paren
id|tmp
comma
id|next
comma
op_amp
id|gbuses
)paren
(brace
id|bus_cur
op_assign
id|list_entry
(paren
id|tmp
comma
r_struct
id|bus_node
comma
id|bus_list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bus_cur-&gt;noIORanges
)paren
(brace
id|range_cur
op_assign
id|bus_cur-&gt;rangeIO
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|bus_cur-&gt;noIORanges
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|range_cur
)paren
r_break
suffix:semicolon
id|range_tmp
op_assign
id|range_cur
suffix:semicolon
id|range_cur
op_assign
id|range_cur-&gt;next
suffix:semicolon
id|kfree
(paren
id|range_tmp
)paren
suffix:semicolon
id|range_tmp
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|bus_cur-&gt;noMemRanges
)paren
(brace
id|range_cur
op_assign
id|bus_cur-&gt;rangeMem
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|bus_cur-&gt;noMemRanges
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|range_cur
)paren
r_break
suffix:semicolon
id|range_tmp
op_assign
id|range_cur
suffix:semicolon
id|range_cur
op_assign
id|range_cur-&gt;next
suffix:semicolon
id|kfree
(paren
id|range_tmp
)paren
suffix:semicolon
id|range_tmp
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|bus_cur-&gt;noPFMemRanges
)paren
(brace
id|range_cur
op_assign
id|bus_cur-&gt;rangePFMem
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|bus_cur-&gt;noPFMemRanges
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|range_cur
)paren
r_break
suffix:semicolon
id|range_tmp
op_assign
id|range_cur
suffix:semicolon
id|range_cur
op_assign
id|range_cur-&gt;next
suffix:semicolon
id|kfree
(paren
id|range_tmp
)paren
suffix:semicolon
id|range_tmp
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|bus_cur-&gt;firstIO
)paren
(brace
id|res_cur
op_assign
id|bus_cur-&gt;firstIO
suffix:semicolon
r_while
c_loop
(paren
id|res_cur
)paren
(brace
id|res_tmp
op_assign
id|res_cur
suffix:semicolon
r_if
c_cond
(paren
id|res_cur-&gt;next
)paren
id|res_cur
op_assign
id|res_cur-&gt;next
suffix:semicolon
r_else
id|res_cur
op_assign
id|res_cur-&gt;nextRange
suffix:semicolon
id|kfree
(paren
id|res_tmp
)paren
suffix:semicolon
id|res_tmp
op_assign
l_int|NULL
suffix:semicolon
)brace
id|bus_cur-&gt;firstIO
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bus_cur-&gt;firstMem
)paren
(brace
id|res_cur
op_assign
id|bus_cur-&gt;firstMem
suffix:semicolon
r_while
c_loop
(paren
id|res_cur
)paren
(brace
id|res_tmp
op_assign
id|res_cur
suffix:semicolon
r_if
c_cond
(paren
id|res_cur-&gt;next
)paren
id|res_cur
op_assign
id|res_cur-&gt;next
suffix:semicolon
r_else
id|res_cur
op_assign
id|res_cur-&gt;nextRange
suffix:semicolon
id|kfree
(paren
id|res_tmp
)paren
suffix:semicolon
id|res_tmp
op_assign
l_int|NULL
suffix:semicolon
)brace
id|bus_cur-&gt;firstMem
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bus_cur-&gt;firstPFMem
)paren
(brace
id|res_cur
op_assign
id|bus_cur-&gt;firstPFMem
suffix:semicolon
r_while
c_loop
(paren
id|res_cur
)paren
(brace
id|res_tmp
op_assign
id|res_cur
suffix:semicolon
r_if
c_cond
(paren
id|res_cur-&gt;next
)paren
id|res_cur
op_assign
id|res_cur-&gt;next
suffix:semicolon
r_else
id|res_cur
op_assign
id|res_cur-&gt;nextRange
suffix:semicolon
id|kfree
(paren
id|res_tmp
)paren
suffix:semicolon
id|res_tmp
op_assign
l_int|NULL
suffix:semicolon
)brace
id|bus_cur-&gt;firstPFMem
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bus_cur-&gt;firstPFMemFromMem
)paren
(brace
id|res_cur
op_assign
id|bus_cur-&gt;firstPFMemFromMem
suffix:semicolon
r_while
c_loop
(paren
id|res_cur
)paren
(brace
id|res_tmp
op_assign
id|res_cur
suffix:semicolon
id|res_cur
op_assign
id|res_cur-&gt;next
suffix:semicolon
id|kfree
(paren
id|res_tmp
)paren
suffix:semicolon
id|res_tmp
op_assign
l_int|NULL
suffix:semicolon
)brace
id|bus_cur-&gt;firstPFMemFromMem
op_assign
l_int|NULL
suffix:semicolon
)brace
id|bus_tmp
op_assign
id|bus_cur
suffix:semicolon
id|list_del
(paren
op_amp
id|bus_cur-&gt;bus_list
)paren
suffix:semicolon
id|kfree
(paren
id|bus_tmp
)paren
suffix:semicolon
id|bus_tmp
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
multiline_comment|/*********************************************************************************&n; * This function will go over the PFmem resources to check if the EBDA allocated&n; * pfmem out of memory buckets of the bus.  If so, it will change the range numbers&n; * and a flag to indicate that this resource is out of memory. It will also move the&n; * Pfmem out of the pfmem resource list to the PFMemFromMem list, and will create&n; * a new Mem node&n; * This routine is called right after initialization&n; *******************************************************************************/
DECL|function|once_over
r_static
r_int
id|__init
id|once_over
(paren
r_void
)paren
(brace
r_struct
id|resource_node
op_star
id|pfmem_cur
suffix:semicolon
r_struct
id|resource_node
op_star
id|pfmem_prev
suffix:semicolon
r_struct
id|resource_node
op_star
id|mem
suffix:semicolon
r_struct
id|bus_node
op_star
id|bus_cur
suffix:semicolon
r_struct
id|list_head
op_star
id|tmp
suffix:semicolon
id|list_for_each
(paren
id|tmp
comma
op_amp
id|gbuses
)paren
(brace
id|bus_cur
op_assign
id|list_entry
(paren
id|tmp
comma
r_struct
id|bus_node
comma
id|bus_list
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
op_logical_neg
id|bus_cur-&gt;rangePFMem
)paren
op_logical_and
(paren
id|bus_cur-&gt;firstPFMem
)paren
)paren
(brace
r_for
c_loop
(paren
id|pfmem_cur
op_assign
id|bus_cur-&gt;firstPFMem
comma
id|pfmem_prev
op_assign
l_int|NULL
suffix:semicolon
id|pfmem_cur
suffix:semicolon
id|pfmem_prev
op_assign
id|pfmem_cur
comma
id|pfmem_cur
op_assign
id|pfmem_cur-&gt;next
)paren
(brace
id|pfmem_cur-&gt;fromMem
op_assign
id|TRUE
suffix:semicolon
r_if
c_cond
(paren
id|pfmem_prev
)paren
id|pfmem_prev-&gt;next
op_assign
id|pfmem_cur-&gt;next
suffix:semicolon
r_else
id|bus_cur-&gt;firstPFMem
op_assign
id|pfmem_cur-&gt;next
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bus_cur-&gt;firstPFMemFromMem
)paren
id|pfmem_cur-&gt;next
op_assign
l_int|NULL
suffix:semicolon
r_else
multiline_comment|/* we don&squot;t need to sort PFMemFromMem since we&squot;re using mem node for&n;&t;&t;&t;&t;&t;   all the real work anyways, so just insert at the beginning of the&n;&t;&t;&t;&t;&t;   list&n;&t;&t;&t;&t;&t; */
id|pfmem_cur-&gt;next
op_assign
id|bus_cur-&gt;firstPFMemFromMem
suffix:semicolon
id|bus_cur-&gt;firstPFMemFromMem
op_assign
id|pfmem_cur
suffix:semicolon
id|mem
op_assign
id|kmalloc
(paren
r_sizeof
(paren
r_struct
id|resource_node
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mem
)paren
(brace
id|err
(paren
l_string|&quot;out of system memory &bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|memset
(paren
id|mem
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|resource_node
)paren
)paren
suffix:semicolon
id|mem-&gt;type
op_assign
id|MEM
suffix:semicolon
id|mem-&gt;busno
op_assign
id|pfmem_cur-&gt;busno
suffix:semicolon
id|mem-&gt;devfunc
op_assign
id|pfmem_cur-&gt;devfunc
suffix:semicolon
id|mem-&gt;start
op_assign
id|pfmem_cur-&gt;start
suffix:semicolon
id|mem-&gt;end
op_assign
id|pfmem_cur-&gt;end
suffix:semicolon
id|mem-&gt;len
op_assign
id|pfmem_cur-&gt;len
suffix:semicolon
r_if
c_cond
(paren
id|ibmphp_add_resource
(paren
id|mem
)paren
OL
l_int|0
)paren
id|err
(paren
l_string|&quot;Trouble...trouble... EBDA allocated pfmem from mem, but system doesn&squot;t display it has this space... unless not PCI device...&bslash;n&quot;
)paren
suffix:semicolon
id|pfmem_cur-&gt;rangeno
op_assign
id|mem-&gt;rangeno
suffix:semicolon
)brace
multiline_comment|/* end for pfmem */
)brace
multiline_comment|/* end if */
)brace
multiline_comment|/* end list_for_each bus */
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ibmphp_add_pfmem_from_mem
r_int
id|ibmphp_add_pfmem_from_mem
(paren
r_struct
id|resource_node
op_star
id|pfmem
)paren
(brace
r_struct
id|bus_node
op_star
id|bus_cur
op_assign
id|find_bus_wprev
(paren
id|pfmem-&gt;busno
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bus_cur
)paren
(brace
id|err
(paren
l_string|&quot;cannot find bus of pfmem to add...&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bus_cur-&gt;firstPFMemFromMem
)paren
id|pfmem-&gt;next
op_assign
id|bus_cur-&gt;firstPFMemFromMem
suffix:semicolon
r_else
id|pfmem-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|bus_cur-&gt;firstPFMemFromMem
op_assign
id|pfmem
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* This routine just goes through the buses to see if the bus already exists.&n; * It is called from ibmphp_find_sec_number, to find out a secondary bus number for&n; * bridged cards&n; * Parameters: bus_number&n; * Returns: Bus pointer or NULL&n; */
DECL|function|ibmphp_find_res_bus
r_struct
id|bus_node
op_star
id|ibmphp_find_res_bus
(paren
id|u8
id|bus_number
)paren
(brace
r_return
id|find_bus_wprev
(paren
id|bus_number
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|find_bus_wprev
r_static
r_inline
r_struct
id|bus_node
op_star
id|find_bus_wprev
(paren
id|u8
id|bus_number
comma
r_struct
id|bus_node
op_star
op_star
id|prev
comma
id|u8
id|flag
)paren
(brace
r_struct
id|bus_node
op_star
id|bus_cur
suffix:semicolon
r_struct
id|list_head
op_star
id|tmp
suffix:semicolon
r_struct
id|list_head
op_star
id|tmp_prev
suffix:semicolon
id|list_for_each
(paren
id|tmp
comma
op_amp
id|gbuses
)paren
(brace
id|tmp_prev
op_assign
id|tmp-&gt;prev
suffix:semicolon
id|bus_cur
op_assign
id|list_entry
(paren
id|tmp
comma
r_struct
id|bus_node
comma
id|bus_list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flag
)paren
op_star
id|prev
op_assign
id|list_entry
(paren
id|tmp_prev
comma
r_struct
id|bus_node
comma
id|bus_list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bus_cur-&gt;busno
op_eq
id|bus_number
)paren
r_return
id|bus_cur
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|ibmphp_print_test
r_void
id|ibmphp_print_test
(paren
r_void
)paren
(brace
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_struct
id|bus_node
op_star
id|bus_cur
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|range_node
op_star
id|range
suffix:semicolon
r_struct
id|resource_node
op_star
id|res
suffix:semicolon
r_struct
id|list_head
op_star
id|tmp
suffix:semicolon
id|debug_pci
(paren
l_string|&quot;*****************START**********************&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|gbuses
)paren
)paren
op_logical_and
id|flags
)paren
(brace
id|err
(paren
l_string|&quot;The GBUSES is not NULL?!?!?!?!?&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|list_for_each
(paren
id|tmp
comma
op_amp
id|gbuses
)paren
(brace
id|bus_cur
op_assign
id|list_entry
(paren
id|tmp
comma
r_struct
id|bus_node
comma
id|bus_list
)paren
suffix:semicolon
id|debug_pci
(paren
l_string|&quot;This is bus # %d.  There are &bslash;n&quot;
comma
id|bus_cur-&gt;busno
)paren
suffix:semicolon
id|debug_pci
(paren
l_string|&quot;IORanges = %d&bslash;t&quot;
comma
id|bus_cur-&gt;noIORanges
)paren
suffix:semicolon
id|debug_pci
(paren
l_string|&quot;MemRanges = %d&bslash;t&quot;
comma
id|bus_cur-&gt;noMemRanges
)paren
suffix:semicolon
id|debug_pci
(paren
l_string|&quot;PFMemRanges = %d&bslash;n&quot;
comma
id|bus_cur-&gt;noPFMemRanges
)paren
suffix:semicolon
id|debug_pci
(paren
l_string|&quot;The IO Ranges are as follows:&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bus_cur-&gt;rangeIO
)paren
(brace
id|range
op_assign
id|bus_cur-&gt;rangeIO
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|bus_cur-&gt;noIORanges
suffix:semicolon
id|i
op_increment
)paren
(brace
id|debug_pci
(paren
l_string|&quot;rangeno is %d&bslash;n&quot;
comma
id|range-&gt;rangeno
)paren
suffix:semicolon
id|debug_pci
(paren
l_string|&quot;[%x - %x]&bslash;n&quot;
comma
id|range-&gt;start
comma
id|range-&gt;end
)paren
suffix:semicolon
id|range
op_assign
id|range-&gt;next
suffix:semicolon
)brace
)brace
id|debug_pci
(paren
l_string|&quot;The Mem Ranges are as follows:&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bus_cur-&gt;rangeMem
)paren
(brace
id|range
op_assign
id|bus_cur-&gt;rangeMem
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|bus_cur-&gt;noMemRanges
suffix:semicolon
id|i
op_increment
)paren
(brace
id|debug_pci
(paren
l_string|&quot;rangeno is %d&bslash;n&quot;
comma
id|range-&gt;rangeno
)paren
suffix:semicolon
id|debug_pci
(paren
l_string|&quot;[%x - %x]&bslash;n&quot;
comma
id|range-&gt;start
comma
id|range-&gt;end
)paren
suffix:semicolon
id|range
op_assign
id|range-&gt;next
suffix:semicolon
)brace
)brace
id|debug_pci
(paren
l_string|&quot;The PFMem Ranges are as follows:&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bus_cur-&gt;rangePFMem
)paren
(brace
id|range
op_assign
id|bus_cur-&gt;rangePFMem
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|bus_cur-&gt;noPFMemRanges
suffix:semicolon
id|i
op_increment
)paren
(brace
id|debug_pci
(paren
l_string|&quot;rangeno is %d&bslash;n&quot;
comma
id|range-&gt;rangeno
)paren
suffix:semicolon
id|debug_pci
(paren
l_string|&quot;[%x - %x]&bslash;n&quot;
comma
id|range-&gt;start
comma
id|range-&gt;end
)paren
suffix:semicolon
id|range
op_assign
id|range-&gt;next
suffix:semicolon
)brace
)brace
id|debug_pci
(paren
l_string|&quot;The resources on this bus are as follows&bslash;n&quot;
)paren
suffix:semicolon
id|debug_pci
(paren
l_string|&quot;IO...&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bus_cur-&gt;firstIO
)paren
(brace
id|res
op_assign
id|bus_cur-&gt;firstIO
suffix:semicolon
r_while
c_loop
(paren
id|res
)paren
(brace
id|debug_pci
(paren
l_string|&quot;The range # is %d&bslash;n&quot;
comma
id|res-&gt;rangeno
)paren
suffix:semicolon
id|debug_pci
(paren
l_string|&quot;The bus, devfnc is %d, %x&bslash;n&quot;
comma
id|res-&gt;busno
comma
id|res-&gt;devfunc
)paren
suffix:semicolon
id|debug_pci
(paren
l_string|&quot;[%x - %x], len=%x&bslash;n&quot;
comma
id|res-&gt;start
comma
id|res-&gt;end
comma
id|res-&gt;len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res-&gt;next
)paren
id|res
op_assign
id|res-&gt;next
suffix:semicolon
r_else
r_if
c_cond
(paren
id|res-&gt;nextRange
)paren
id|res
op_assign
id|res-&gt;nextRange
suffix:semicolon
r_else
r_break
suffix:semicolon
)brace
)brace
id|debug_pci
(paren
l_string|&quot;Mem...&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bus_cur-&gt;firstMem
)paren
(brace
id|res
op_assign
id|bus_cur-&gt;firstMem
suffix:semicolon
r_while
c_loop
(paren
id|res
)paren
(brace
id|debug_pci
(paren
l_string|&quot;The range # is %d&bslash;n&quot;
comma
id|res-&gt;rangeno
)paren
suffix:semicolon
id|debug_pci
(paren
l_string|&quot;The bus, devfnc is %d, %x&bslash;n&quot;
comma
id|res-&gt;busno
comma
id|res-&gt;devfunc
)paren
suffix:semicolon
id|debug_pci
(paren
l_string|&quot;[%x - %x], len=%x&bslash;n&quot;
comma
id|res-&gt;start
comma
id|res-&gt;end
comma
id|res-&gt;len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res-&gt;next
)paren
id|res
op_assign
id|res-&gt;next
suffix:semicolon
r_else
r_if
c_cond
(paren
id|res-&gt;nextRange
)paren
id|res
op_assign
id|res-&gt;nextRange
suffix:semicolon
r_else
r_break
suffix:semicolon
)brace
)brace
id|debug_pci
(paren
l_string|&quot;PFMem...&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bus_cur-&gt;firstPFMem
)paren
(brace
id|res
op_assign
id|bus_cur-&gt;firstPFMem
suffix:semicolon
r_while
c_loop
(paren
id|res
)paren
(brace
id|debug_pci
(paren
l_string|&quot;The range # is %d&bslash;n&quot;
comma
id|res-&gt;rangeno
)paren
suffix:semicolon
id|debug_pci
(paren
l_string|&quot;The bus, devfnc is %d, %x&bslash;n&quot;
comma
id|res-&gt;busno
comma
id|res-&gt;devfunc
)paren
suffix:semicolon
id|debug_pci
(paren
l_string|&quot;[%x - %x], len=%x&bslash;n&quot;
comma
id|res-&gt;start
comma
id|res-&gt;end
comma
id|res-&gt;len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res-&gt;next
)paren
id|res
op_assign
id|res-&gt;next
suffix:semicolon
r_else
r_if
c_cond
(paren
id|res-&gt;nextRange
)paren
id|res
op_assign
id|res-&gt;nextRange
suffix:semicolon
r_else
r_break
suffix:semicolon
)brace
)brace
id|debug_pci
(paren
l_string|&quot;PFMemFromMem...&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bus_cur-&gt;firstPFMemFromMem
)paren
(brace
id|res
op_assign
id|bus_cur-&gt;firstPFMemFromMem
suffix:semicolon
r_while
c_loop
(paren
id|res
)paren
(brace
id|debug_pci
(paren
l_string|&quot;The range # is %d&bslash;n&quot;
comma
id|res-&gt;rangeno
)paren
suffix:semicolon
id|debug_pci
(paren
l_string|&quot;The bus, devfnc is %d, %x&bslash;n&quot;
comma
id|res-&gt;busno
comma
id|res-&gt;devfunc
)paren
suffix:semicolon
id|debug_pci
(paren
l_string|&quot;[%x - %x], len=%x&bslash;n&quot;
comma
id|res-&gt;start
comma
id|res-&gt;end
comma
id|res-&gt;len
)paren
suffix:semicolon
id|res
op_assign
id|res-&gt;next
suffix:semicolon
)brace
)brace
)brace
id|debug_pci
(paren
l_string|&quot;***********************END***********************&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|function|range_exists_already
r_static
r_int
id|range_exists_already
(paren
r_struct
id|range_node
op_star
id|range
comma
r_struct
id|bus_node
op_star
id|bus_cur
comma
id|u8
id|type
)paren
(brace
r_struct
id|range_node
op_star
id|range_cur
op_assign
l_int|NULL
suffix:semicolon
r_switch
c_cond
(paren
id|type
)paren
(brace
r_case
id|IO
suffix:colon
id|range_cur
op_assign
id|bus_cur-&gt;rangeIO
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MEM
suffix:colon
id|range_cur
op_assign
id|bus_cur-&gt;rangeMem
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PFMEM
suffix:colon
id|range_cur
op_assign
id|bus_cur-&gt;rangePFMem
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|err
(paren
l_string|&quot;wrong type passed to find out if range already exists &bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_while
c_loop
(paren
id|range_cur
)paren
(brace
r_if
c_cond
(paren
(paren
id|range_cur-&gt;start
op_eq
id|range-&gt;start
)paren
op_logical_and
(paren
id|range_cur-&gt;end
op_eq
id|range-&gt;end
)paren
)paren
r_return
l_int|1
suffix:semicolon
id|range_cur
op_assign
id|range_cur-&gt;next
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* This routine will read the windows for any PPB we have and update the&n; * range info for the secondary bus, and will also input this info into&n; * primary bus, since BIOS doesn&squot;t. This is for PPB that are in the system&n; * on bootup.  For bridged cards that were added during previous load of the&n; * driver, only the ranges and the bus structure are added, the devices are&n; * added from NVRAM&n; * Input: primary busno&n; * Returns: none&n; * Note: this function doesn&squot;t take into account IO restrictions etc,&n; *&t; so will only work for bridges with no video/ISA devices behind them It&n; *&t; also will not work for onboard PPB&squot;s that can have more than 1 *bus&n; *&t; behind them All these are TO DO.&n; *&t; Also need to add more error checkings... (from fnc returns etc)&n; */
DECL|function|update_bridge_ranges
r_static
r_int
id|__init
id|update_bridge_ranges
(paren
r_struct
id|bus_node
op_star
op_star
id|bus
)paren
(brace
id|u8
id|sec_busno
comma
id|device
comma
id|function
comma
id|hdr_type
comma
id|start_io_address
comma
id|end_io_address
suffix:semicolon
id|u16
id|vendor_id
comma
id|upper_io_start
comma
id|upper_io_end
comma
id|start_mem_address
comma
id|end_mem_address
suffix:semicolon
id|u32
id|start_address
comma
id|end_address
comma
id|upper_start
comma
id|upper_end
suffix:semicolon
r_struct
id|bus_node
op_star
id|bus_sec
suffix:semicolon
r_struct
id|bus_node
op_star
id|bus_cur
suffix:semicolon
r_struct
id|resource_node
op_star
id|io
suffix:semicolon
r_struct
id|resource_node
op_star
id|mem
suffix:semicolon
r_struct
id|resource_node
op_star
id|pfmem
suffix:semicolon
r_struct
id|range_node
op_star
id|range
suffix:semicolon
r_int
r_int
id|devfn
suffix:semicolon
id|bus_cur
op_assign
op_star
id|bus
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bus_cur
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|ibmphp_pci_bus-&gt;number
op_assign
id|bus_cur-&gt;busno
suffix:semicolon
id|debug
(paren
l_string|&quot;inside %s &bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
id|debug
(paren
l_string|&quot;bus_cur-&gt;busno = %x&bslash;n&quot;
comma
id|bus_cur-&gt;busno
)paren
suffix:semicolon
r_for
c_loop
(paren
id|device
op_assign
l_int|0
suffix:semicolon
id|device
OL
l_int|32
suffix:semicolon
id|device
op_increment
)paren
(brace
r_for
c_loop
(paren
id|function
op_assign
l_int|0x00
suffix:semicolon
id|function
OL
l_int|0x08
suffix:semicolon
id|function
op_increment
)paren
(brace
id|devfn
op_assign
id|PCI_DEVFN
c_func
(paren
id|device
comma
id|function
)paren
suffix:semicolon
id|pci_bus_read_config_word
(paren
id|ibmphp_pci_bus
comma
id|devfn
comma
id|PCI_VENDOR_ID
comma
op_amp
id|vendor_id
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vendor_id
op_ne
id|PCI_VENDOR_ID_NOTVALID
)paren
(brace
multiline_comment|/* found correct device!!! */
id|pci_bus_read_config_byte
(paren
id|ibmphp_pci_bus
comma
id|devfn
comma
id|PCI_HEADER_TYPE
comma
op_amp
id|hdr_type
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|hdr_type
)paren
(brace
r_case
id|PCI_HEADER_TYPE_NORMAL
suffix:colon
id|function
op_assign
l_int|0x8
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PCI_HEADER_TYPE_MULTIDEVICE
suffix:colon
r_break
suffix:semicolon
r_case
id|PCI_HEADER_TYPE_BRIDGE
suffix:colon
id|function
op_assign
l_int|0x8
suffix:semicolon
r_case
id|PCI_HEADER_TYPE_MULTIBRIDGE
suffix:colon
multiline_comment|/* We assume here that only 1 bus behind the bridge &n;&t;&t;&t;&t;&t;&t;   TO DO: add functionality for several:&n;&t;&t;&t;&t;&t;&t;   temp = secondary;&n;&t;&t;&t;&t;&t;&t;   while (temp &lt; subordinate) {&n;&t;&t;&t;&t;&t;&t;   ...&n;&t;&t;&t;&t;&t;&t;   temp++;&n;&t;&t;&t;&t;&t;&t;   }&n;&t;&t;&t;&t;&t;&t; */
id|pci_bus_read_config_byte
(paren
id|ibmphp_pci_bus
comma
id|devfn
comma
id|PCI_SECONDARY_BUS
comma
op_amp
id|sec_busno
)paren
suffix:semicolon
id|bus_sec
op_assign
id|find_bus_wprev
(paren
id|sec_busno
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* this bus structure doesn&squot;t exist yet, PPB was configured during previous loading of ibmphp */
r_if
c_cond
(paren
op_logical_neg
id|bus_sec
)paren
(brace
id|bus_sec
op_assign
id|alloc_error_bus
(paren
l_int|NULL
comma
id|sec_busno
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* the rest will be populated during NVRAM call */
r_return
l_int|0
suffix:semicolon
)brace
id|pci_bus_read_config_byte
(paren
id|ibmphp_pci_bus
comma
id|devfn
comma
id|PCI_IO_BASE
comma
op_amp
id|start_io_address
)paren
suffix:semicolon
id|pci_bus_read_config_byte
(paren
id|ibmphp_pci_bus
comma
id|devfn
comma
id|PCI_IO_LIMIT
comma
op_amp
id|end_io_address
)paren
suffix:semicolon
id|pci_bus_read_config_word
(paren
id|ibmphp_pci_bus
comma
id|devfn
comma
id|PCI_IO_BASE_UPPER16
comma
op_amp
id|upper_io_start
)paren
suffix:semicolon
id|pci_bus_read_config_word
(paren
id|ibmphp_pci_bus
comma
id|devfn
comma
id|PCI_IO_LIMIT_UPPER16
comma
op_amp
id|upper_io_end
)paren
suffix:semicolon
id|start_address
op_assign
(paren
id|start_io_address
op_amp
id|PCI_IO_RANGE_MASK
)paren
op_lshift
l_int|8
suffix:semicolon
id|start_address
op_or_assign
(paren
id|upper_io_start
op_lshift
l_int|16
)paren
suffix:semicolon
id|end_address
op_assign
(paren
id|end_io_address
op_amp
id|PCI_IO_RANGE_MASK
)paren
op_lshift
l_int|8
suffix:semicolon
id|end_address
op_or_assign
(paren
id|upper_io_end
op_lshift
l_int|16
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|start_address
)paren
op_logical_and
(paren
id|start_address
op_le
id|end_address
)paren
)paren
(brace
id|range
op_assign
id|kmalloc
(paren
r_sizeof
(paren
r_struct
id|range_node
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|range
)paren
(brace
id|err
(paren
l_string|&quot;out of system memory &bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|memset
(paren
id|range
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|range_node
)paren
)paren
suffix:semicolon
id|range-&gt;start
op_assign
id|start_address
suffix:semicolon
id|range-&gt;end
op_assign
id|end_address
op_plus
l_int|0xfff
suffix:semicolon
r_if
c_cond
(paren
id|bus_sec-&gt;noIORanges
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|range_exists_already
(paren
id|range
comma
id|bus_sec
comma
id|IO
)paren
)paren
(brace
id|add_range
(paren
id|IO
comma
id|range
comma
id|bus_sec
)paren
suffix:semicolon
op_increment
id|bus_sec-&gt;noIORanges
suffix:semicolon
)brace
r_else
(brace
id|kfree
(paren
id|range
)paren
suffix:semicolon
id|range
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* 1st IO Range on the bus */
id|range-&gt;rangeno
op_assign
l_int|1
suffix:semicolon
id|bus_sec-&gt;rangeIO
op_assign
id|range
suffix:semicolon
op_increment
id|bus_sec-&gt;noIORanges
suffix:semicolon
)brace
id|fix_resources
(paren
id|bus_sec
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ibmphp_find_resource
(paren
id|bus_cur
comma
id|start_address
comma
op_amp
id|io
comma
id|IO
)paren
)paren
(brace
id|io
op_assign
id|kmalloc
(paren
r_sizeof
(paren
r_struct
id|resource_node
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|io
)paren
(brace
id|kfree
(paren
id|range
)paren
suffix:semicolon
id|err
(paren
l_string|&quot;out of system memory &bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|memset
(paren
id|io
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|resource_node
)paren
)paren
suffix:semicolon
id|io-&gt;type
op_assign
id|IO
suffix:semicolon
id|io-&gt;busno
op_assign
id|bus_cur-&gt;busno
suffix:semicolon
id|io-&gt;devfunc
op_assign
(paren
(paren
id|device
op_lshift
l_int|3
)paren
op_or
(paren
id|function
op_amp
l_int|0x7
)paren
)paren
suffix:semicolon
id|io-&gt;start
op_assign
id|start_address
suffix:semicolon
id|io-&gt;end
op_assign
id|end_address
op_plus
l_int|0xfff
suffix:semicolon
id|io-&gt;len
op_assign
id|io-&gt;end
op_minus
id|io-&gt;start
op_plus
l_int|1
suffix:semicolon
id|ibmphp_add_resource
(paren
id|io
)paren
suffix:semicolon
)brace
)brace
id|pci_bus_read_config_word
(paren
id|ibmphp_pci_bus
comma
id|devfn
comma
id|PCI_MEMORY_BASE
comma
op_amp
id|start_mem_address
)paren
suffix:semicolon
id|pci_bus_read_config_word
(paren
id|ibmphp_pci_bus
comma
id|devfn
comma
id|PCI_MEMORY_LIMIT
comma
op_amp
id|end_mem_address
)paren
suffix:semicolon
id|start_address
op_assign
l_int|0x00000000
op_or
(paren
id|start_mem_address
op_amp
id|PCI_MEMORY_RANGE_MASK
)paren
op_lshift
l_int|16
suffix:semicolon
id|end_address
op_assign
l_int|0x00000000
op_or
(paren
id|end_mem_address
op_amp
id|PCI_MEMORY_RANGE_MASK
)paren
op_lshift
l_int|16
suffix:semicolon
r_if
c_cond
(paren
(paren
id|start_address
)paren
op_logical_and
(paren
id|start_address
op_le
id|end_address
)paren
)paren
(brace
id|range
op_assign
id|kmalloc
(paren
r_sizeof
(paren
r_struct
id|range_node
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|range
)paren
(brace
id|err
(paren
l_string|&quot;out of system memory &bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|memset
(paren
id|range
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|range_node
)paren
)paren
suffix:semicolon
id|range-&gt;start
op_assign
id|start_address
suffix:semicolon
id|range-&gt;end
op_assign
id|end_address
op_plus
l_int|0xfffff
suffix:semicolon
r_if
c_cond
(paren
id|bus_sec-&gt;noMemRanges
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|range_exists_already
(paren
id|range
comma
id|bus_sec
comma
id|MEM
)paren
)paren
(brace
id|add_range
(paren
id|MEM
comma
id|range
comma
id|bus_sec
)paren
suffix:semicolon
op_increment
id|bus_sec-&gt;noMemRanges
suffix:semicolon
)brace
r_else
(brace
id|kfree
(paren
id|range
)paren
suffix:semicolon
id|range
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* 1st Mem Range on the bus */
id|range-&gt;rangeno
op_assign
l_int|1
suffix:semicolon
id|bus_sec-&gt;rangeMem
op_assign
id|range
suffix:semicolon
op_increment
id|bus_sec-&gt;noMemRanges
suffix:semicolon
)brace
id|fix_resources
(paren
id|bus_sec
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ibmphp_find_resource
(paren
id|bus_cur
comma
id|start_address
comma
op_amp
id|mem
comma
id|MEM
)paren
)paren
(brace
id|mem
op_assign
id|kmalloc
(paren
r_sizeof
(paren
r_struct
id|resource_node
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mem
)paren
(brace
id|kfree
(paren
id|range
)paren
suffix:semicolon
id|err
(paren
l_string|&quot;out of system memory &bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|memset
(paren
id|mem
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|resource_node
)paren
)paren
suffix:semicolon
id|mem-&gt;type
op_assign
id|MEM
suffix:semicolon
id|mem-&gt;busno
op_assign
id|bus_cur-&gt;busno
suffix:semicolon
id|mem-&gt;devfunc
op_assign
(paren
(paren
id|device
op_lshift
l_int|3
)paren
op_or
(paren
id|function
op_amp
l_int|0x7
)paren
)paren
suffix:semicolon
id|mem-&gt;start
op_assign
id|start_address
suffix:semicolon
id|mem-&gt;end
op_assign
id|end_address
op_plus
l_int|0xfffff
suffix:semicolon
id|mem-&gt;len
op_assign
id|mem-&gt;end
op_minus
id|mem-&gt;start
op_plus
l_int|1
suffix:semicolon
id|ibmphp_add_resource
(paren
id|mem
)paren
suffix:semicolon
)brace
)brace
id|pci_bus_read_config_word
(paren
id|ibmphp_pci_bus
comma
id|devfn
comma
id|PCI_PREF_MEMORY_BASE
comma
op_amp
id|start_mem_address
)paren
suffix:semicolon
id|pci_bus_read_config_word
(paren
id|ibmphp_pci_bus
comma
id|devfn
comma
id|PCI_PREF_MEMORY_LIMIT
comma
op_amp
id|end_mem_address
)paren
suffix:semicolon
id|pci_bus_read_config_dword
(paren
id|ibmphp_pci_bus
comma
id|devfn
comma
id|PCI_PREF_BASE_UPPER32
comma
op_amp
id|upper_start
)paren
suffix:semicolon
id|pci_bus_read_config_dword
(paren
id|ibmphp_pci_bus
comma
id|devfn
comma
id|PCI_PREF_LIMIT_UPPER32
comma
op_amp
id|upper_end
)paren
suffix:semicolon
id|start_address
op_assign
l_int|0x00000000
op_or
(paren
id|start_mem_address
op_amp
id|PCI_MEMORY_RANGE_MASK
)paren
op_lshift
l_int|16
suffix:semicolon
id|end_address
op_assign
l_int|0x00000000
op_or
(paren
id|end_mem_address
op_amp
id|PCI_MEMORY_RANGE_MASK
)paren
op_lshift
l_int|16
suffix:semicolon
macro_line|#if BITS_PER_LONG == 64
id|start_address
op_or_assign
(paren
(paren
r_int
)paren
id|upper_start
)paren
op_lshift
l_int|32
suffix:semicolon
id|end_address
op_or_assign
(paren
(paren
r_int
)paren
id|upper_end
)paren
op_lshift
l_int|32
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
(paren
id|start_address
)paren
op_logical_and
(paren
id|start_address
op_le
id|end_address
)paren
)paren
(brace
id|range
op_assign
id|kmalloc
(paren
r_sizeof
(paren
r_struct
id|range_node
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|range
)paren
(brace
id|err
(paren
l_string|&quot;out of system memory &bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|memset
(paren
id|range
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|range_node
)paren
)paren
suffix:semicolon
id|range-&gt;start
op_assign
id|start_address
suffix:semicolon
id|range-&gt;end
op_assign
id|end_address
op_plus
l_int|0xfffff
suffix:semicolon
r_if
c_cond
(paren
id|bus_sec-&gt;noPFMemRanges
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|range_exists_already
(paren
id|range
comma
id|bus_sec
comma
id|PFMEM
)paren
)paren
(brace
id|add_range
(paren
id|PFMEM
comma
id|range
comma
id|bus_sec
)paren
suffix:semicolon
op_increment
id|bus_sec-&gt;noPFMemRanges
suffix:semicolon
)brace
r_else
(brace
id|kfree
(paren
id|range
)paren
suffix:semicolon
id|range
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* 1st PFMem Range on the bus */
id|range-&gt;rangeno
op_assign
l_int|1
suffix:semicolon
id|bus_sec-&gt;rangePFMem
op_assign
id|range
suffix:semicolon
op_increment
id|bus_sec-&gt;noPFMemRanges
suffix:semicolon
)brace
id|fix_resources
(paren
id|bus_sec
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ibmphp_find_resource
(paren
id|bus_cur
comma
id|start_address
comma
op_amp
id|pfmem
comma
id|PFMEM
)paren
)paren
(brace
id|pfmem
op_assign
id|kmalloc
(paren
r_sizeof
(paren
r_struct
id|resource_node
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pfmem
)paren
(brace
id|kfree
(paren
id|range
)paren
suffix:semicolon
id|err
(paren
l_string|&quot;out of system memory &bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|memset
(paren
id|pfmem
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|resource_node
)paren
)paren
suffix:semicolon
id|pfmem-&gt;type
op_assign
id|PFMEM
suffix:semicolon
id|pfmem-&gt;busno
op_assign
id|bus_cur-&gt;busno
suffix:semicolon
id|pfmem-&gt;devfunc
op_assign
(paren
(paren
id|device
op_lshift
l_int|3
)paren
op_or
(paren
id|function
op_amp
l_int|0x7
)paren
)paren
suffix:semicolon
id|pfmem-&gt;start
op_assign
id|start_address
suffix:semicolon
id|pfmem-&gt;end
op_assign
id|end_address
op_plus
l_int|0xfffff
suffix:semicolon
id|pfmem-&gt;len
op_assign
id|pfmem-&gt;end
op_minus
id|pfmem-&gt;start
op_plus
l_int|1
suffix:semicolon
id|pfmem-&gt;fromMem
op_assign
id|FALSE
suffix:semicolon
id|ibmphp_add_resource
(paren
id|pfmem
)paren
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
)brace
multiline_comment|/* end of switch */
)brace
multiline_comment|/* end if vendor */
)brace
multiline_comment|/* end for function */
)brace
multiline_comment|/* end for device */
id|bus
op_assign
op_amp
id|bus_cur
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
eof
