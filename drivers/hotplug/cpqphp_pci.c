multiline_comment|/*&n; * Compaq Hot Plug Controller Driver&n; *&n; * Copyright (c) 1995,2001 Compaq Computer Corporation&n; * Copyright (c) 2001 Greg Kroah-Hartman (greg@kroah.com)&n; * Copyright (c) 2001 IBM Corp.&n; *&n; * All rights reserved.&n; *&n; * This program is free software; you can redistribute it and/or modify&n; * it under the terms of the GNU General Public License as published by&n; * the Free Software Foundation; either version 2 of the License, or (at&n; * your option) any later version.&n; *&n; * This program is distributed in the hope that it will be useful, but&n; * WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or&n; * NON INFRINGEMENT.  See the GNU General Public License for more&n; * details.&n; *&n; * You should have received a copy of the GNU General Public License&n; * along with this program; if not, write to the Free Software&n; * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.&n; *&n; * Send feedback to &lt;greg@kroah.com&gt;&n; *&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/workqueue.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &quot;cpqphp.h&quot;
macro_line|#include &quot;cpqphp_nvram.h&quot;
macro_line|#include &quot;../../arch/i386/pci/pci.h&quot;&t;/* horrible hack showing how processor dependent we are... */
DECL|variable|cpqhp_nic_irq
id|u8
id|cpqhp_nic_irq
suffix:semicolon
DECL|variable|cpqhp_disk_irq
id|u8
id|cpqhp_disk_irq
suffix:semicolon
DECL|variable|unused_IRQ
r_static
id|u16
id|unused_IRQ
suffix:semicolon
multiline_comment|/*&n; * detect_HRT_floating_pointer&n; *&n; * find the Hot Plug Resource Table in the specified region of memory.&n; *&n; */
DECL|function|detect_HRT_floating_pointer
r_static
r_void
op_star
id|detect_HRT_floating_pointer
c_func
(paren
r_void
op_star
id|begin
comma
r_void
op_star
id|end
)paren
(brace
r_void
op_star
id|fp
suffix:semicolon
r_void
op_star
id|endp
suffix:semicolon
id|u8
id|temp1
comma
id|temp2
comma
id|temp3
comma
id|temp4
suffix:semicolon
r_int
id|status
op_assign
l_int|0
suffix:semicolon
id|endp
op_assign
(paren
id|end
op_minus
r_sizeof
(paren
r_struct
id|hrt
)paren
op_plus
l_int|1
)paren
suffix:semicolon
r_for
c_loop
(paren
id|fp
op_assign
id|begin
suffix:semicolon
id|fp
op_le
id|endp
suffix:semicolon
id|fp
op_add_assign
l_int|16
)paren
(brace
id|temp1
op_assign
id|readb
c_func
(paren
id|fp
op_plus
id|SIG0
)paren
suffix:semicolon
id|temp2
op_assign
id|readb
c_func
(paren
id|fp
op_plus
id|SIG1
)paren
suffix:semicolon
id|temp3
op_assign
id|readb
c_func
(paren
id|fp
op_plus
id|SIG2
)paren
suffix:semicolon
id|temp4
op_assign
id|readb
c_func
(paren
id|fp
op_plus
id|SIG3
)paren
suffix:semicolon
r_if
c_cond
(paren
id|temp1
op_eq
l_char|&squot;$&squot;
op_logical_and
id|temp2
op_eq
l_char|&squot;H&squot;
op_logical_and
id|temp3
op_eq
l_char|&squot;R&squot;
op_logical_and
id|temp4
op_eq
l_char|&squot;T&squot;
)paren
(brace
id|status
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|status
)paren
id|fp
op_assign
l_int|NULL
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;Discovered Hotplug Resource Table at %p&bslash;n&quot;
comma
id|fp
)paren
suffix:semicolon
r_return
id|fp
suffix:semicolon
)brace
DECL|function|cpqhp_configure_device
r_int
id|cpqhp_configure_device
(paren
r_struct
id|controller
op_star
id|ctrl
comma
r_struct
id|pci_func
op_star
id|func
)paren
(brace
r_int
r_char
id|bus
suffix:semicolon
r_struct
id|pci_dev
id|dev0
suffix:semicolon
r_struct
id|pci_bus
op_star
id|child
suffix:semicolon
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|dev0
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|pci_dev
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|func-&gt;pci_dev
op_eq
l_int|NULL
)paren
id|func-&gt;pci_dev
op_assign
id|pci_find_slot
c_func
(paren
id|func-&gt;bus
comma
(paren
id|func-&gt;device
op_lshift
l_int|3
)paren
op_or
(paren
id|func-&gt;function
op_amp
l_int|0x7
)paren
)paren
suffix:semicolon
singleline_comment|//Still NULL ? Well then scan for it !
r_if
c_cond
(paren
id|func-&gt;pci_dev
op_eq
l_int|NULL
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;INFO: pci_dev still null&bslash;n&quot;
)paren
suffix:semicolon
id|dev0.bus
op_assign
id|ctrl-&gt;pci_dev-&gt;bus
suffix:semicolon
id|dev0.devfn
op_assign
(paren
id|func-&gt;device
op_lshift
l_int|3
)paren
op_plus
(paren
id|func-&gt;function
op_amp
l_int|0x7
)paren
suffix:semicolon
id|dev0.sysdata
op_assign
id|ctrl-&gt;pci_dev-&gt;sysdata
suffix:semicolon
singleline_comment|//this will generate pci_dev structures for all functions, but we will only call this case when lookup fails
id|func-&gt;pci_dev
op_assign
id|pci_scan_slot
c_func
(paren
op_amp
id|dev0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|func-&gt;pci_dev
op_eq
l_int|NULL
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;ERROR: pci_dev still null&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|func-&gt;pci_dev-&gt;hdr_type
op_eq
id|PCI_HEADER_TYPE_BRIDGE
)paren
(brace
id|pci_read_config_byte
c_func
(paren
id|func-&gt;pci_dev
comma
id|PCI_SECONDARY_BUS
comma
op_amp
id|bus
)paren
suffix:semicolon
id|child
op_assign
(paren
r_struct
id|pci_bus
op_star
)paren
id|pci_add_new_bus
c_func
(paren
id|func-&gt;pci_dev-&gt;bus
comma
(paren
id|func-&gt;pci_dev
)paren
comma
id|bus
)paren
suffix:semicolon
id|pci_do_scan_bus
c_func
(paren
id|child
)paren
suffix:semicolon
)brace
r_return
id|rc
suffix:semicolon
)brace
DECL|function|cpqhp_unconfigure_device
r_int
id|cpqhp_unconfigure_device
c_func
(paren
r_struct
id|pci_func
op_star
id|func
)paren
(brace
r_int
id|j
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;%s: bus/dev/func = %x/%x/%x&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|func-&gt;bus
comma
id|func-&gt;device
comma
id|func-&gt;function
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
l_int|8
suffix:semicolon
id|j
op_increment
)paren
(brace
r_struct
id|pci_dev
op_star
id|temp
op_assign
id|pci_find_slot
c_func
(paren
id|func-&gt;bus
comma
(paren
id|func-&gt;device
op_lshift
l_int|3
)paren
op_or
id|j
)paren
suffix:semicolon
r_if
c_cond
(paren
id|temp
)paren
id|pci_remove_bus_device
c_func
(paren
id|temp
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|PCI_RefinedAccessConfig
r_static
r_int
id|PCI_RefinedAccessConfig
c_func
(paren
r_struct
id|pci_bus
op_star
id|bus
comma
r_int
r_int
id|devfn
comma
id|u8
id|offset
comma
id|u32
op_star
id|value
)paren
(brace
id|u32
id|vendID
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|pci_bus_read_config_dword
(paren
id|bus
comma
id|devfn
comma
id|PCI_VENDOR_ID
comma
op_amp
id|vendID
)paren
op_eq
op_minus
l_int|1
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|vendID
op_eq
l_int|0xffffffff
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_return
id|pci_bus_read_config_dword
(paren
id|bus
comma
id|devfn
comma
id|offset
comma
id|value
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * cpqhp_set_irq&n; *&n; * @bus_num: bus number of PCI device&n; * @dev_num: device number of PCI device&n; * @slot: pointer to u8 where slot number will be returned&n; */
DECL|function|cpqhp_set_irq
r_int
id|cpqhp_set_irq
(paren
id|u8
id|bus_num
comma
id|u8
id|dev_num
comma
id|u8
id|int_pin
comma
id|u8
id|irq_num
)paren
(brace
r_int
id|rc
suffix:semicolon
id|u16
id|temp_word
suffix:semicolon
r_struct
id|pci_dev
id|fakedev
suffix:semicolon
r_struct
id|pci_bus
id|fakebus
suffix:semicolon
id|fakedev.devfn
op_assign
id|dev_num
op_lshift
l_int|3
suffix:semicolon
id|fakedev.bus
op_assign
op_amp
id|fakebus
suffix:semicolon
id|fakebus.number
op_assign
id|bus_num
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;%s: dev %d, bus %d, pin %d, num %d&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|dev_num
comma
id|bus_num
comma
id|int_pin
comma
id|irq_num
)paren
suffix:semicolon
id|rc
op_assign
id|pcibios_set_irq_routing
c_func
(paren
op_amp
id|fakedev
comma
id|int_pin
op_minus
l_int|0x0a
comma
id|irq_num
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;%s: rc %d&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|rc
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rc
)paren
r_return
op_logical_neg
id|rc
suffix:semicolon
singleline_comment|// set the Edge Level Control Register (ELCR)
id|temp_word
op_assign
id|inb
c_func
(paren
l_int|0x4d0
)paren
suffix:semicolon
id|temp_word
op_or_assign
id|inb
c_func
(paren
l_int|0x4d1
)paren
op_lshift
l_int|8
suffix:semicolon
id|temp_word
op_or_assign
l_int|0x01
op_lshift
id|irq_num
suffix:semicolon
singleline_comment|// This should only be for x86 as it sets the Edge Level Control Register
id|outb
c_func
(paren
(paren
id|u8
)paren
(paren
id|temp_word
op_amp
l_int|0xFF
)paren
comma
l_int|0x4d0
)paren
suffix:semicolon
id|outb
c_func
(paren
(paren
id|u8
)paren
(paren
(paren
id|temp_word
op_amp
l_int|0xFF00
)paren
op_rshift
l_int|8
)paren
comma
l_int|0x4d1
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * WTF??? This function isn&squot;t in the code, yet a function calls it, but the &n; * compiler optimizes it away?  strange.  Here as a placeholder to keep the &n; * compiler happy.&n; */
DECL|function|PCI_ScanBusNonBridge
r_static
r_int
id|PCI_ScanBusNonBridge
(paren
id|u8
id|bus
comma
id|u8
id|device
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|PCI_ScanBusForNonBridge
r_static
r_int
id|PCI_ScanBusForNonBridge
c_func
(paren
r_struct
id|controller
op_star
id|ctrl
comma
id|u8
id|bus_num
comma
id|u8
op_star
id|dev_num
)paren
(brace
id|u8
id|tdevice
suffix:semicolon
id|u32
id|work
suffix:semicolon
id|u8
id|tbus
suffix:semicolon
id|ctrl-&gt;pci_bus-&gt;number
op_assign
id|bus_num
suffix:semicolon
r_for
c_loop
(paren
id|tdevice
op_assign
l_int|0
suffix:semicolon
id|tdevice
OL
l_int|0x100
suffix:semicolon
id|tdevice
op_increment
)paren
(brace
singleline_comment|//Scan for access first
r_if
c_cond
(paren
id|PCI_RefinedAccessConfig
c_func
(paren
id|ctrl-&gt;pci_bus
comma
id|tdevice
comma
l_int|0x08
comma
op_amp
id|work
)paren
op_eq
op_minus
l_int|1
)paren
r_continue
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;Looking for nonbridge bus_num %d dev_num %d&bslash;n&quot;
comma
id|bus_num
comma
id|tdevice
)paren
suffix:semicolon
singleline_comment|//Yep we got one. Not a bridge ?
r_if
c_cond
(paren
(paren
id|work
op_rshift
l_int|8
)paren
op_ne
id|PCI_TO_PCI_BRIDGE_CLASS
)paren
(brace
op_star
id|dev_num
op_assign
id|tdevice
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;found it !&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_for
c_loop
(paren
id|tdevice
op_assign
l_int|0
suffix:semicolon
id|tdevice
OL
l_int|0x100
suffix:semicolon
id|tdevice
op_increment
)paren
(brace
singleline_comment|//Scan for access first
r_if
c_cond
(paren
id|PCI_RefinedAccessConfig
c_func
(paren
id|ctrl-&gt;pci_bus
comma
id|tdevice
comma
l_int|0x08
comma
op_amp
id|work
)paren
op_eq
op_minus
l_int|1
)paren
r_continue
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;Looking for bridge bus_num %d dev_num %d&bslash;n&quot;
comma
id|bus_num
comma
id|tdevice
)paren
suffix:semicolon
singleline_comment|//Yep we got one. bridge ?
r_if
c_cond
(paren
(paren
id|work
op_rshift
l_int|8
)paren
op_eq
id|PCI_TO_PCI_BRIDGE_CLASS
)paren
(brace
id|pci_bus_read_config_byte
(paren
id|ctrl-&gt;pci_bus
comma
id|PCI_DEVFN
c_func
(paren
id|tdevice
comma
l_int|0
)paren
comma
id|PCI_SECONDARY_BUS
comma
op_amp
id|tbus
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;Recurse on bus_num %d tdevice %d&bslash;n&quot;
comma
id|tbus
comma
id|tdevice
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PCI_ScanBusNonBridge
c_func
(paren
id|tbus
comma
id|tdevice
)paren
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
DECL|function|PCI_GetBusDevHelper
r_static
r_int
id|PCI_GetBusDevHelper
c_func
(paren
r_struct
id|controller
op_star
id|ctrl
comma
id|u8
op_star
id|bus_num
comma
id|u8
op_star
id|dev_num
comma
id|u8
id|slot
comma
id|u8
id|nobridge
)paren
(brace
r_struct
id|irq_routing_table
op_star
id|PCIIRQRoutingInfoLength
suffix:semicolon
r_int
id|len
suffix:semicolon
r_int
id|loop
suffix:semicolon
id|u32
id|work
suffix:semicolon
id|u8
id|tbus
comma
id|tdevice
comma
id|tslot
suffix:semicolon
id|PCIIRQRoutingInfoLength
op_assign
id|pcibios_get_irq_routing_table
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|PCIIRQRoutingInfoLength
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|len
op_assign
(paren
id|PCIIRQRoutingInfoLength-&gt;size
op_minus
r_sizeof
(paren
r_struct
id|irq_routing_table
)paren
)paren
op_div
r_sizeof
(paren
r_struct
id|irq_info
)paren
suffix:semicolon
singleline_comment|// Make sure I got at least one entry
r_if
c_cond
(paren
id|len
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|PCIIRQRoutingInfoLength
op_ne
l_int|NULL
)paren
id|kfree
c_func
(paren
id|PCIIRQRoutingInfoLength
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_for
c_loop
(paren
id|loop
op_assign
l_int|0
suffix:semicolon
id|loop
OL
id|len
suffix:semicolon
op_increment
id|loop
)paren
(brace
id|tbus
op_assign
id|PCIIRQRoutingInfoLength-&gt;slots
(braket
id|loop
)braket
dot
id|bus
suffix:semicolon
id|tdevice
op_assign
id|PCIIRQRoutingInfoLength-&gt;slots
(braket
id|loop
)braket
dot
id|devfn
suffix:semicolon
id|tslot
op_assign
id|PCIIRQRoutingInfoLength-&gt;slots
(braket
id|loop
)braket
dot
id|slot
suffix:semicolon
r_if
c_cond
(paren
id|tslot
op_eq
id|slot
)paren
(brace
op_star
id|bus_num
op_assign
id|tbus
suffix:semicolon
op_star
id|dev_num
op_assign
id|tdevice
suffix:semicolon
id|ctrl-&gt;pci_bus-&gt;number
op_assign
id|tbus
suffix:semicolon
id|pci_bus_read_config_dword
(paren
id|ctrl-&gt;pci_bus
comma
op_star
id|dev_num
comma
id|PCI_VENDOR_ID
comma
op_amp
id|work
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|nobridge
op_logical_or
(paren
id|work
op_eq
l_int|0xffffffff
)paren
)paren
(brace
r_if
c_cond
(paren
id|PCIIRQRoutingInfoLength
op_ne
l_int|NULL
)paren
id|kfree
c_func
(paren
id|PCIIRQRoutingInfoLength
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|dbg
c_func
(paren
l_string|&quot;bus_num %d devfn %d&bslash;n&quot;
comma
op_star
id|bus_num
comma
op_star
id|dev_num
)paren
suffix:semicolon
id|pci_bus_read_config_dword
(paren
id|ctrl-&gt;pci_bus
comma
op_star
id|dev_num
comma
id|PCI_CLASS_REVISION
comma
op_amp
id|work
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;work &gt;&gt; 8 (%x) = BRIDGE (%x)&bslash;n&quot;
comma
id|work
op_rshift
l_int|8
comma
id|PCI_TO_PCI_BRIDGE_CLASS
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|work
op_rshift
l_int|8
)paren
op_eq
id|PCI_TO_PCI_BRIDGE_CLASS
)paren
(brace
id|pci_bus_read_config_byte
(paren
id|ctrl-&gt;pci_bus
comma
op_star
id|dev_num
comma
id|PCI_SECONDARY_BUS
comma
op_amp
id|tbus
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;Scan bus for Non Bridge: bus %d&bslash;n&quot;
comma
id|tbus
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PCI_ScanBusForNonBridge
c_func
(paren
id|ctrl
comma
id|tbus
comma
id|dev_num
)paren
op_eq
l_int|0
)paren
(brace
op_star
id|bus_num
op_assign
id|tbus
suffix:semicolon
r_if
c_cond
(paren
id|PCIIRQRoutingInfoLength
op_ne
l_int|NULL
)paren
id|kfree
c_func
(paren
id|PCIIRQRoutingInfoLength
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|PCIIRQRoutingInfoLength
op_ne
l_int|NULL
)paren
id|kfree
c_func
(paren
id|PCIIRQRoutingInfoLength
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|PCIIRQRoutingInfoLength
op_ne
l_int|NULL
)paren
id|kfree
c_func
(paren
id|PCIIRQRoutingInfoLength
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
DECL|function|cpqhp_get_bus_dev
r_int
id|cpqhp_get_bus_dev
(paren
r_struct
id|controller
op_star
id|ctrl
comma
id|u8
op_star
id|bus_num
comma
id|u8
op_star
id|dev_num
comma
id|u8
id|slot
)paren
(brace
r_return
id|PCI_GetBusDevHelper
c_func
(paren
id|ctrl
comma
id|bus_num
comma
id|dev_num
comma
id|slot
comma
l_int|0
)paren
suffix:semicolon
singleline_comment|//plain (bridges allowed)
)brace
multiline_comment|/* More PCI configuration routines; this time centered around hotplug controller */
multiline_comment|/*&n; * cpqhp_save_config&n; *&n; * Reads configuration for all slots in a PCI bus and saves info.&n; *&n; * Note:  For non-hot plug busses, the slot # saved is the device #&n; *&n; * returns 0 if success&n; */
DECL|function|cpqhp_save_config
r_int
id|cpqhp_save_config
c_func
(paren
r_struct
id|controller
op_star
id|ctrl
comma
r_int
id|busnumber
comma
r_int
id|is_hot_plug
)paren
(brace
r_int
id|rc
suffix:semicolon
id|u8
id|class_code
suffix:semicolon
id|u8
id|header_type
suffix:semicolon
id|u32
id|ID
suffix:semicolon
id|u8
id|secondary_bus
suffix:semicolon
r_struct
id|pci_func
op_star
id|new_slot
suffix:semicolon
r_int
id|sub_bus
suffix:semicolon
r_int
id|FirstSupported
suffix:semicolon
r_int
id|LastSupported
suffix:semicolon
r_int
id|max_functions
suffix:semicolon
r_int
id|function
suffix:semicolon
id|u8
id|DevError
suffix:semicolon
r_int
id|device
op_assign
l_int|0
suffix:semicolon
r_int
id|cloop
op_assign
l_int|0
suffix:semicolon
r_int
id|stop_it
suffix:semicolon
r_int
id|index
suffix:semicolon
singleline_comment|//              Decide which slots are supported
r_if
c_cond
(paren
id|is_hot_plug
)paren
(brace
singleline_comment|//*********************************
singleline_comment|// is_hot_plug is the slot mask
singleline_comment|//*********************************
id|FirstSupported
op_assign
id|is_hot_plug
op_rshift
l_int|4
suffix:semicolon
id|LastSupported
op_assign
id|FirstSupported
op_plus
(paren
id|is_hot_plug
op_amp
l_int|0x0F
)paren
op_minus
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|FirstSupported
op_assign
l_int|0
suffix:semicolon
id|LastSupported
op_assign
l_int|0x1F
suffix:semicolon
)brace
singleline_comment|//     Save PCI configuration space for all devices in supported slots
id|ctrl-&gt;pci_bus-&gt;number
op_assign
id|busnumber
suffix:semicolon
r_for
c_loop
(paren
id|device
op_assign
id|FirstSupported
suffix:semicolon
id|device
op_le
id|LastSupported
suffix:semicolon
id|device
op_increment
)paren
(brace
id|ID
op_assign
l_int|0xFFFFFFFF
suffix:semicolon
id|rc
op_assign
id|pci_bus_read_config_dword
(paren
id|ctrl-&gt;pci_bus
comma
id|PCI_DEVFN
c_func
(paren
id|device
comma
l_int|0
)paren
comma
id|PCI_VENDOR_ID
comma
op_amp
id|ID
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ID
op_ne
l_int|0xFFFFFFFF
)paren
(brace
singleline_comment|//  device in slot
id|rc
op_assign
id|pci_bus_read_config_byte
(paren
id|ctrl-&gt;pci_bus
comma
id|PCI_DEVFN
c_func
(paren
id|device
comma
l_int|0
)paren
comma
l_int|0x0B
comma
op_amp
id|class_code
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_return
id|rc
suffix:semicolon
id|rc
op_assign
id|pci_bus_read_config_byte
(paren
id|ctrl-&gt;pci_bus
comma
id|PCI_DEVFN
c_func
(paren
id|device
comma
l_int|0
)paren
comma
id|PCI_HEADER_TYPE
comma
op_amp
id|header_type
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_return
id|rc
suffix:semicolon
singleline_comment|// If multi-function device, set max_functions to 8
r_if
c_cond
(paren
id|header_type
op_amp
l_int|0x80
)paren
id|max_functions
op_assign
l_int|8
suffix:semicolon
r_else
id|max_functions
op_assign
l_int|1
suffix:semicolon
id|function
op_assign
l_int|0
suffix:semicolon
r_do
(brace
id|DevError
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|header_type
op_amp
l_int|0x7F
)paren
op_eq
id|PCI_HEADER_TYPE_BRIDGE
)paren
(brace
singleline_comment|// P-P Bridge
singleline_comment|//  Recurse the subordinate bus
singleline_comment|//  get the subordinate bus number
id|rc
op_assign
id|pci_bus_read_config_byte
(paren
id|ctrl-&gt;pci_bus
comma
id|PCI_DEVFN
c_func
(paren
id|device
comma
id|function
)paren
comma
id|PCI_SECONDARY_BUS
comma
op_amp
id|secondary_bus
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
(brace
r_return
id|rc
suffix:semicolon
)brace
r_else
(brace
id|sub_bus
op_assign
(paren
r_int
)paren
id|secondary_bus
suffix:semicolon
singleline_comment|// Save secondary bus cfg spc
singleline_comment|// with this recursive call.
id|rc
op_assign
id|cpqhp_save_config
c_func
(paren
id|ctrl
comma
id|sub_bus
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_return
id|rc
suffix:semicolon
id|ctrl-&gt;pci_bus-&gt;number
op_assign
id|busnumber
suffix:semicolon
)brace
)brace
id|index
op_assign
l_int|0
suffix:semicolon
id|new_slot
op_assign
id|cpqhp_slot_find
c_func
(paren
id|busnumber
comma
id|device
comma
id|index
op_increment
)paren
suffix:semicolon
r_while
c_loop
(paren
id|new_slot
op_logical_and
(paren
id|new_slot-&gt;function
op_ne
(paren
id|u8
)paren
id|function
)paren
)paren
id|new_slot
op_assign
id|cpqhp_slot_find
c_func
(paren
id|busnumber
comma
id|device
comma
id|index
op_increment
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|new_slot
)paren
(brace
singleline_comment|// Setup slot structure.
id|new_slot
op_assign
id|cpqhp_slot_create
c_func
(paren
id|busnumber
)paren
suffix:semicolon
r_if
c_cond
(paren
id|new_slot
op_eq
l_int|NULL
)paren
r_return
l_int|1
suffix:semicolon
)brace
id|new_slot-&gt;bus
op_assign
(paren
id|u8
)paren
id|busnumber
suffix:semicolon
id|new_slot-&gt;device
op_assign
(paren
id|u8
)paren
id|device
suffix:semicolon
id|new_slot-&gt;function
op_assign
(paren
id|u8
)paren
id|function
suffix:semicolon
id|new_slot-&gt;is_a_board
op_assign
l_int|1
suffix:semicolon
id|new_slot-&gt;switch_save
op_assign
l_int|0x10
suffix:semicolon
singleline_comment|// In case of unsupported board
id|new_slot-&gt;status
op_assign
id|DevError
suffix:semicolon
id|new_slot-&gt;pci_dev
op_assign
id|pci_find_slot
c_func
(paren
id|new_slot-&gt;bus
comma
(paren
id|new_slot-&gt;device
op_lshift
l_int|3
)paren
op_or
id|new_slot-&gt;function
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cloop
op_assign
l_int|0
suffix:semicolon
id|cloop
OL
l_int|0x20
suffix:semicolon
id|cloop
op_increment
)paren
(brace
id|rc
op_assign
id|pci_bus_read_config_dword
(paren
id|ctrl-&gt;pci_bus
comma
id|PCI_DEVFN
c_func
(paren
id|device
comma
id|function
)paren
comma
id|cloop
op_lshift
l_int|2
comma
(paren
id|u32
op_star
)paren
op_amp
(paren
id|new_slot
op_member_access_from_pointer
id|config_space
(braket
id|cloop
)braket
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_return
id|rc
suffix:semicolon
)brace
id|function
op_increment
suffix:semicolon
id|stop_it
op_assign
l_int|0
suffix:semicolon
singleline_comment|//  this loop skips to the next present function
singleline_comment|//  reading in Class Code and Header type.
r_while
c_loop
(paren
(paren
id|function
OL
id|max_functions
)paren
op_logical_and
(paren
op_logical_neg
id|stop_it
)paren
)paren
(brace
id|rc
op_assign
id|pci_bus_read_config_dword
(paren
id|ctrl-&gt;pci_bus
comma
id|PCI_DEVFN
c_func
(paren
id|device
comma
id|function
)paren
comma
id|PCI_VENDOR_ID
comma
op_amp
id|ID
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ID
op_eq
l_int|0xFFFFFFFF
)paren
(brace
singleline_comment|// nothing there.
id|function
op_increment
suffix:semicolon
)brace
r_else
(brace
singleline_comment|// Something there
id|rc
op_assign
id|pci_bus_read_config_byte
(paren
id|ctrl-&gt;pci_bus
comma
id|PCI_DEVFN
c_func
(paren
id|device
comma
id|function
)paren
comma
l_int|0x0B
comma
op_amp
id|class_code
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_return
id|rc
suffix:semicolon
id|rc
op_assign
id|pci_bus_read_config_byte
(paren
id|ctrl-&gt;pci_bus
comma
id|PCI_DEVFN
c_func
(paren
id|device
comma
id|function
)paren
comma
id|PCI_HEADER_TYPE
comma
op_amp
id|header_type
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_return
id|rc
suffix:semicolon
id|stop_it
op_increment
suffix:semicolon
)brace
)brace
)brace
r_while
c_loop
(paren
id|function
OL
id|max_functions
)paren
suffix:semicolon
)brace
singleline_comment|// End of IF (device in slot?)
r_else
r_if
c_cond
(paren
id|is_hot_plug
)paren
(brace
singleline_comment|// Setup slot structure with entry for empty slot
id|new_slot
op_assign
id|cpqhp_slot_create
c_func
(paren
id|busnumber
)paren
suffix:semicolon
r_if
c_cond
(paren
id|new_slot
op_eq
l_int|NULL
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
id|new_slot-&gt;bus
op_assign
(paren
id|u8
)paren
id|busnumber
suffix:semicolon
id|new_slot-&gt;device
op_assign
(paren
id|u8
)paren
id|device
suffix:semicolon
id|new_slot-&gt;function
op_assign
l_int|0
suffix:semicolon
id|new_slot-&gt;is_a_board
op_assign
l_int|0
suffix:semicolon
id|new_slot-&gt;presence_save
op_assign
l_int|0
suffix:semicolon
id|new_slot-&gt;switch_save
op_assign
l_int|0
suffix:semicolon
)brace
)brace
singleline_comment|// End of FOR loop
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * cpqhp_save_slot_config&n; *&n; * Saves configuration info for all PCI devices in a given slot&n; * including subordinate busses.&n; *&n; * returns 0 if success&n; */
DECL|function|cpqhp_save_slot_config
r_int
id|cpqhp_save_slot_config
(paren
r_struct
id|controller
op_star
id|ctrl
comma
r_struct
id|pci_func
op_star
id|new_slot
)paren
(brace
r_int
id|rc
suffix:semicolon
id|u8
id|class_code
suffix:semicolon
id|u8
id|header_type
suffix:semicolon
id|u32
id|ID
suffix:semicolon
id|u8
id|secondary_bus
suffix:semicolon
r_int
id|sub_bus
suffix:semicolon
r_int
id|max_functions
suffix:semicolon
r_int
id|function
suffix:semicolon
r_int
id|cloop
op_assign
l_int|0
suffix:semicolon
r_int
id|stop_it
suffix:semicolon
id|ID
op_assign
l_int|0xFFFFFFFF
suffix:semicolon
id|ctrl-&gt;pci_bus-&gt;number
op_assign
id|new_slot-&gt;bus
suffix:semicolon
id|pci_bus_read_config_dword
(paren
id|ctrl-&gt;pci_bus
comma
id|PCI_DEVFN
c_func
(paren
id|new_slot-&gt;device
comma
l_int|0
)paren
comma
id|PCI_VENDOR_ID
comma
op_amp
id|ID
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ID
op_ne
l_int|0xFFFFFFFF
)paren
(brace
singleline_comment|//  device in slot
id|pci_bus_read_config_byte
(paren
id|ctrl-&gt;pci_bus
comma
id|PCI_DEVFN
c_func
(paren
id|new_slot-&gt;device
comma
l_int|0
)paren
comma
l_int|0x0B
comma
op_amp
id|class_code
)paren
suffix:semicolon
id|pci_bus_read_config_byte
(paren
id|ctrl-&gt;pci_bus
comma
id|PCI_DEVFN
c_func
(paren
id|new_slot-&gt;device
comma
l_int|0
)paren
comma
id|PCI_HEADER_TYPE
comma
op_amp
id|header_type
)paren
suffix:semicolon
r_if
c_cond
(paren
id|header_type
op_amp
l_int|0x80
)paren
singleline_comment|// Multi-function device
id|max_functions
op_assign
l_int|8
suffix:semicolon
r_else
id|max_functions
op_assign
l_int|1
suffix:semicolon
id|function
op_assign
l_int|0
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
(paren
id|header_type
op_amp
l_int|0x7F
)paren
op_eq
id|PCI_HEADER_TYPE_BRIDGE
)paren
(brace
singleline_comment|// PCI-PCI Bridge
singleline_comment|//  Recurse the subordinate bus
id|pci_bus_read_config_byte
(paren
id|ctrl-&gt;pci_bus
comma
id|PCI_DEVFN
c_func
(paren
id|new_slot-&gt;device
comma
id|function
)paren
comma
id|PCI_SECONDARY_BUS
comma
op_amp
id|secondary_bus
)paren
suffix:semicolon
id|sub_bus
op_assign
(paren
r_int
)paren
id|secondary_bus
suffix:semicolon
singleline_comment|// Save the config headers for the secondary bus.
id|rc
op_assign
id|cpqhp_save_config
c_func
(paren
id|ctrl
comma
id|sub_bus
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_return
id|rc
suffix:semicolon
id|ctrl-&gt;pci_bus-&gt;number
op_assign
id|new_slot-&gt;bus
suffix:semicolon
)brace
singleline_comment|// End of IF
id|new_slot-&gt;status
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|cloop
op_assign
l_int|0
suffix:semicolon
id|cloop
OL
l_int|0x20
suffix:semicolon
id|cloop
op_increment
)paren
(brace
id|pci_bus_read_config_dword
(paren
id|ctrl-&gt;pci_bus
comma
id|PCI_DEVFN
c_func
(paren
id|new_slot-&gt;device
comma
id|function
)paren
comma
id|cloop
op_lshift
l_int|2
comma
(paren
id|u32
op_star
)paren
op_amp
(paren
id|new_slot
op_member_access_from_pointer
id|config_space
(braket
id|cloop
)braket
)paren
)paren
suffix:semicolon
)brace
id|function
op_increment
suffix:semicolon
id|stop_it
op_assign
l_int|0
suffix:semicolon
singleline_comment|//  this loop skips to the next present function
singleline_comment|//  reading in the Class Code and the Header type.
r_while
c_loop
(paren
(paren
id|function
OL
id|max_functions
)paren
op_logical_and
(paren
op_logical_neg
id|stop_it
)paren
)paren
(brace
id|pci_bus_read_config_dword
(paren
id|ctrl-&gt;pci_bus
comma
id|PCI_DEVFN
c_func
(paren
id|new_slot-&gt;device
comma
id|function
)paren
comma
id|PCI_VENDOR_ID
comma
op_amp
id|ID
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ID
op_eq
l_int|0xFFFFFFFF
)paren
(brace
singleline_comment|// nothing there.
id|function
op_increment
suffix:semicolon
)brace
r_else
(brace
singleline_comment|// Something there
id|pci_bus_read_config_byte
(paren
id|ctrl-&gt;pci_bus
comma
id|PCI_DEVFN
c_func
(paren
id|new_slot-&gt;device
comma
id|function
)paren
comma
l_int|0x0B
comma
op_amp
id|class_code
)paren
suffix:semicolon
id|pci_bus_read_config_byte
(paren
id|ctrl-&gt;pci_bus
comma
id|PCI_DEVFN
c_func
(paren
id|new_slot-&gt;device
comma
id|function
)paren
comma
id|PCI_HEADER_TYPE
comma
op_amp
id|header_type
)paren
suffix:semicolon
id|stop_it
op_increment
suffix:semicolon
)brace
)brace
)brace
r_while
c_loop
(paren
id|function
OL
id|max_functions
)paren
suffix:semicolon
)brace
singleline_comment|// End of IF (device in slot?)
r_else
(brace
r_return
l_int|2
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * cpqhp_save_base_addr_length&n; *&n; * Saves the length of all base address registers for the&n; * specified slot.  this is for hot plug REPLACE&n; *&n; * returns 0 if success&n; */
DECL|function|cpqhp_save_base_addr_length
r_int
id|cpqhp_save_base_addr_length
c_func
(paren
r_struct
id|controller
op_star
id|ctrl
comma
r_struct
id|pci_func
op_star
id|func
)paren
(brace
id|u8
id|cloop
suffix:semicolon
id|u8
id|header_type
suffix:semicolon
id|u8
id|secondary_bus
suffix:semicolon
id|u8
id|type
suffix:semicolon
r_int
id|sub_bus
suffix:semicolon
id|u32
id|temp_register
suffix:semicolon
id|u32
id|base
suffix:semicolon
id|u32
id|rc
suffix:semicolon
r_struct
id|pci_func
op_star
id|next
suffix:semicolon
r_int
id|index
op_assign
l_int|0
suffix:semicolon
r_struct
id|pci_bus
op_star
id|pci_bus
op_assign
id|ctrl-&gt;pci_bus
suffix:semicolon
r_int
r_int
id|devfn
suffix:semicolon
id|func
op_assign
id|cpqhp_slot_find
c_func
(paren
id|func-&gt;bus
comma
id|func-&gt;device
comma
id|index
op_increment
)paren
suffix:semicolon
r_while
c_loop
(paren
id|func
op_ne
l_int|NULL
)paren
(brace
id|pci_bus-&gt;number
op_assign
id|func-&gt;bus
suffix:semicolon
id|devfn
op_assign
id|PCI_DEVFN
c_func
(paren
id|func-&gt;device
comma
id|func-&gt;function
)paren
suffix:semicolon
singleline_comment|// Check for Bridge
id|pci_bus_read_config_byte
(paren
id|pci_bus
comma
id|devfn
comma
id|PCI_HEADER_TYPE
comma
op_amp
id|header_type
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|header_type
op_amp
l_int|0x7F
)paren
op_eq
id|PCI_HEADER_TYPE_BRIDGE
)paren
(brace
singleline_comment|// PCI-PCI Bridge
id|pci_bus_read_config_byte
(paren
id|pci_bus
comma
id|devfn
comma
id|PCI_SECONDARY_BUS
comma
op_amp
id|secondary_bus
)paren
suffix:semicolon
id|sub_bus
op_assign
(paren
r_int
)paren
id|secondary_bus
suffix:semicolon
id|next
op_assign
id|cpqhp_slot_list
(braket
id|sub_bus
)braket
suffix:semicolon
r_while
c_loop
(paren
id|next
op_ne
l_int|NULL
)paren
(brace
id|rc
op_assign
id|cpqhp_save_base_addr_length
c_func
(paren
id|ctrl
comma
id|next
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_return
id|rc
suffix:semicolon
id|next
op_assign
id|next-&gt;next
suffix:semicolon
)brace
id|pci_bus-&gt;number
op_assign
id|func-&gt;bus
suffix:semicolon
singleline_comment|//FIXME: this loop is duplicated in the non-bridge case.  The two could be rolled together
singleline_comment|// Figure out IO and memory base lengths
r_for
c_loop
(paren
id|cloop
op_assign
l_int|0x10
suffix:semicolon
id|cloop
op_le
l_int|0x14
suffix:semicolon
id|cloop
op_add_assign
l_int|4
)paren
(brace
id|temp_register
op_assign
l_int|0xFFFFFFFF
suffix:semicolon
id|pci_bus_write_config_dword
(paren
id|pci_bus
comma
id|devfn
comma
id|cloop
comma
id|temp_register
)paren
suffix:semicolon
id|pci_bus_read_config_dword
(paren
id|pci_bus
comma
id|devfn
comma
id|cloop
comma
op_amp
id|base
)paren
suffix:semicolon
r_if
c_cond
(paren
id|base
)paren
(brace
singleline_comment|// If this register is implemented
r_if
c_cond
(paren
id|base
op_amp
l_int|0x01L
)paren
(brace
singleline_comment|// IO base
singleline_comment|// set base = amount of IO space requested
id|base
op_assign
id|base
op_amp
l_int|0xFFFFFFFE
suffix:semicolon
id|base
op_assign
(paren
op_complement
id|base
)paren
op_plus
l_int|1
suffix:semicolon
id|type
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
singleline_comment|// memory base
id|base
op_assign
id|base
op_amp
l_int|0xFFFFFFF0
suffix:semicolon
id|base
op_assign
(paren
op_complement
id|base
)paren
op_plus
l_int|1
suffix:semicolon
id|type
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_else
(brace
id|base
op_assign
l_int|0x0L
suffix:semicolon
id|type
op_assign
l_int|0
suffix:semicolon
)brace
singleline_comment|// Save information in slot structure
id|func-&gt;base_length
(braket
(paren
id|cloop
op_minus
l_int|0x10
)paren
op_rshift
l_int|2
)braket
op_assign
id|base
suffix:semicolon
id|func-&gt;base_type
(braket
(paren
id|cloop
op_minus
l_int|0x10
)paren
op_rshift
l_int|2
)braket
op_assign
id|type
suffix:semicolon
)brace
singleline_comment|// End of base register loop
)brace
r_else
r_if
c_cond
(paren
(paren
id|header_type
op_amp
l_int|0x7F
)paren
op_eq
l_int|0x00
)paren
(brace
singleline_comment|// PCI-PCI Bridge
singleline_comment|// Figure out IO and memory base lengths
r_for
c_loop
(paren
id|cloop
op_assign
l_int|0x10
suffix:semicolon
id|cloop
op_le
l_int|0x24
suffix:semicolon
id|cloop
op_add_assign
l_int|4
)paren
(brace
id|temp_register
op_assign
l_int|0xFFFFFFFF
suffix:semicolon
id|pci_bus_write_config_dword
(paren
id|pci_bus
comma
id|devfn
comma
id|cloop
comma
id|temp_register
)paren
suffix:semicolon
id|pci_bus_read_config_dword
(paren
id|pci_bus
comma
id|devfn
comma
id|cloop
comma
op_amp
id|base
)paren
suffix:semicolon
r_if
c_cond
(paren
id|base
)paren
(brace
singleline_comment|// If this register is implemented
r_if
c_cond
(paren
id|base
op_amp
l_int|0x01L
)paren
(brace
singleline_comment|// IO base
singleline_comment|// base = amount of IO space requested
id|base
op_assign
id|base
op_amp
l_int|0xFFFFFFFE
suffix:semicolon
id|base
op_assign
(paren
op_complement
id|base
)paren
op_plus
l_int|1
suffix:semicolon
id|type
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
singleline_comment|// memory base
singleline_comment|// base = amount of memory space requested
id|base
op_assign
id|base
op_amp
l_int|0xFFFFFFF0
suffix:semicolon
id|base
op_assign
(paren
op_complement
id|base
)paren
op_plus
l_int|1
suffix:semicolon
id|type
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_else
(brace
id|base
op_assign
l_int|0x0L
suffix:semicolon
id|type
op_assign
l_int|0
suffix:semicolon
)brace
singleline_comment|// Save information in slot structure
id|func-&gt;base_length
(braket
(paren
id|cloop
op_minus
l_int|0x10
)paren
op_rshift
l_int|2
)braket
op_assign
id|base
suffix:semicolon
id|func-&gt;base_type
(braket
(paren
id|cloop
op_minus
l_int|0x10
)paren
op_rshift
l_int|2
)braket
op_assign
id|type
suffix:semicolon
)brace
singleline_comment|// End of base register loop
)brace
r_else
(brace
singleline_comment|// Some other unknown header type
)brace
singleline_comment|// find the next device in this slot
id|func
op_assign
id|cpqhp_slot_find
c_func
(paren
id|func-&gt;bus
comma
id|func-&gt;device
comma
id|index
op_increment
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * cpqhp_save_used_resources&n; *&n; * Stores used resource information for existing boards.  this is&n; * for boards that were in the system when this driver was loaded.&n; * this function is for hot plug ADD&n; *&n; * returns 0 if success&n; */
DECL|function|cpqhp_save_used_resources
r_int
id|cpqhp_save_used_resources
(paren
r_struct
id|controller
op_star
id|ctrl
comma
r_struct
id|pci_func
op_star
id|func
)paren
(brace
id|u8
id|cloop
suffix:semicolon
id|u8
id|header_type
suffix:semicolon
id|u8
id|secondary_bus
suffix:semicolon
id|u8
id|temp_byte
suffix:semicolon
id|u8
id|b_base
suffix:semicolon
id|u8
id|b_length
suffix:semicolon
id|u16
id|command
suffix:semicolon
id|u16
id|save_command
suffix:semicolon
id|u16
id|w_base
suffix:semicolon
id|u16
id|w_length
suffix:semicolon
id|u32
id|temp_register
suffix:semicolon
id|u32
id|save_base
suffix:semicolon
id|u32
id|base
suffix:semicolon
r_int
id|index
op_assign
l_int|0
suffix:semicolon
r_struct
id|pci_resource
op_star
id|mem_node
suffix:semicolon
r_struct
id|pci_resource
op_star
id|p_mem_node
suffix:semicolon
r_struct
id|pci_resource
op_star
id|io_node
suffix:semicolon
r_struct
id|pci_resource
op_star
id|bus_node
suffix:semicolon
r_struct
id|pci_bus
op_star
id|pci_bus
op_assign
id|ctrl-&gt;pci_bus
suffix:semicolon
r_int
r_int
id|devfn
suffix:semicolon
id|func
op_assign
id|cpqhp_slot_find
c_func
(paren
id|func-&gt;bus
comma
id|func-&gt;device
comma
id|index
op_increment
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|func
op_ne
l_int|NULL
)paren
op_logical_and
id|func-&gt;is_a_board
)paren
(brace
id|pci_bus-&gt;number
op_assign
id|func-&gt;bus
suffix:semicolon
id|devfn
op_assign
id|PCI_DEVFN
c_func
(paren
id|func-&gt;device
comma
id|func-&gt;function
)paren
suffix:semicolon
singleline_comment|// Save the command register
id|pci_bus_read_config_word
(paren
id|pci_bus
comma
id|devfn
comma
id|PCI_COMMAND
comma
op_amp
id|save_command
)paren
suffix:semicolon
singleline_comment|// disable card
id|command
op_assign
l_int|0x00
suffix:semicolon
id|pci_bus_write_config_word
(paren
id|pci_bus
comma
id|devfn
comma
id|PCI_COMMAND
comma
id|command
)paren
suffix:semicolon
singleline_comment|// Check for Bridge
id|pci_bus_read_config_byte
(paren
id|pci_bus
comma
id|devfn
comma
id|PCI_HEADER_TYPE
comma
op_amp
id|header_type
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|header_type
op_amp
l_int|0x7F
)paren
op_eq
id|PCI_HEADER_TYPE_BRIDGE
)paren
(brace
singleline_comment|// PCI-PCI Bridge
singleline_comment|// Clear Bridge Control Register
id|command
op_assign
l_int|0x00
suffix:semicolon
id|pci_bus_write_config_word
(paren
id|pci_bus
comma
id|devfn
comma
id|PCI_BRIDGE_CONTROL
comma
id|command
)paren
suffix:semicolon
id|pci_bus_read_config_byte
(paren
id|pci_bus
comma
id|devfn
comma
id|PCI_SECONDARY_BUS
comma
op_amp
id|secondary_bus
)paren
suffix:semicolon
id|pci_bus_read_config_byte
(paren
id|pci_bus
comma
id|devfn
comma
id|PCI_SUBORDINATE_BUS
comma
op_amp
id|temp_byte
)paren
suffix:semicolon
id|bus_node
op_assign
(paren
r_struct
id|pci_resource
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|pci_resource
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bus_node
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|bus_node-&gt;base
op_assign
id|secondary_bus
suffix:semicolon
id|bus_node-&gt;length
op_assign
id|temp_byte
op_minus
id|secondary_bus
op_plus
l_int|1
suffix:semicolon
id|bus_node-&gt;next
op_assign
id|func-&gt;bus_head
suffix:semicolon
id|func-&gt;bus_head
op_assign
id|bus_node
suffix:semicolon
singleline_comment|// Save IO base and Limit registers
id|pci_bus_read_config_byte
(paren
id|pci_bus
comma
id|devfn
comma
id|PCI_IO_BASE
comma
op_amp
id|b_base
)paren
suffix:semicolon
id|pci_bus_read_config_byte
(paren
id|pci_bus
comma
id|devfn
comma
id|PCI_IO_LIMIT
comma
op_amp
id|b_length
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|b_base
op_le
id|b_length
)paren
op_logical_and
(paren
id|save_command
op_amp
l_int|0x01
)paren
)paren
(brace
id|io_node
op_assign
(paren
r_struct
id|pci_resource
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|pci_resource
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|io_node
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|io_node-&gt;base
op_assign
(paren
id|b_base
op_amp
l_int|0xF0
)paren
op_lshift
l_int|8
suffix:semicolon
id|io_node-&gt;length
op_assign
(paren
id|b_length
op_minus
id|b_base
op_plus
l_int|0x10
)paren
op_lshift
l_int|8
suffix:semicolon
id|io_node-&gt;next
op_assign
id|func-&gt;io_head
suffix:semicolon
id|func-&gt;io_head
op_assign
id|io_node
suffix:semicolon
)brace
singleline_comment|// Save memory base and Limit registers
id|pci_bus_read_config_word
(paren
id|pci_bus
comma
id|devfn
comma
id|PCI_MEMORY_BASE
comma
op_amp
id|w_base
)paren
suffix:semicolon
id|pci_bus_read_config_word
(paren
id|pci_bus
comma
id|devfn
comma
id|PCI_MEMORY_LIMIT
comma
op_amp
id|w_length
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|w_base
op_le
id|w_length
)paren
op_logical_and
(paren
id|save_command
op_amp
l_int|0x02
)paren
)paren
(brace
id|mem_node
op_assign
(paren
r_struct
id|pci_resource
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|pci_resource
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mem_node
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|mem_node-&gt;base
op_assign
id|w_base
op_lshift
l_int|16
suffix:semicolon
id|mem_node-&gt;length
op_assign
(paren
id|w_length
op_minus
id|w_base
op_plus
l_int|0x10
)paren
op_lshift
l_int|16
suffix:semicolon
id|mem_node-&gt;next
op_assign
id|func-&gt;mem_head
suffix:semicolon
id|func-&gt;mem_head
op_assign
id|mem_node
suffix:semicolon
)brace
singleline_comment|// Save prefetchable memory base and Limit registers
id|pci_bus_read_config_word
(paren
id|pci_bus
comma
id|devfn
comma
id|PCI_PREF_MEMORY_BASE
comma
op_amp
id|w_base
)paren
suffix:semicolon
id|pci_bus_read_config_word
(paren
id|pci_bus
comma
id|devfn
comma
id|PCI_PREF_MEMORY_LIMIT
comma
op_amp
id|w_length
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|w_base
op_le
id|w_length
)paren
op_logical_and
(paren
id|save_command
op_amp
l_int|0x02
)paren
)paren
(brace
id|p_mem_node
op_assign
(paren
r_struct
id|pci_resource
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|pci_resource
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p_mem_node
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|p_mem_node-&gt;base
op_assign
id|w_base
op_lshift
l_int|16
suffix:semicolon
id|p_mem_node-&gt;length
op_assign
(paren
id|w_length
op_minus
id|w_base
op_plus
l_int|0x10
)paren
op_lshift
l_int|16
suffix:semicolon
id|p_mem_node-&gt;next
op_assign
id|func-&gt;p_mem_head
suffix:semicolon
id|func-&gt;p_mem_head
op_assign
id|p_mem_node
suffix:semicolon
)brace
singleline_comment|// Figure out IO and memory base lengths
r_for
c_loop
(paren
id|cloop
op_assign
l_int|0x10
suffix:semicolon
id|cloop
op_le
l_int|0x14
suffix:semicolon
id|cloop
op_add_assign
l_int|4
)paren
(brace
id|pci_bus_read_config_dword
(paren
id|pci_bus
comma
id|devfn
comma
id|cloop
comma
op_amp
id|save_base
)paren
suffix:semicolon
id|temp_register
op_assign
l_int|0xFFFFFFFF
suffix:semicolon
id|pci_bus_write_config_dword
(paren
id|pci_bus
comma
id|devfn
comma
id|cloop
comma
id|temp_register
)paren
suffix:semicolon
id|pci_bus_read_config_dword
(paren
id|pci_bus
comma
id|devfn
comma
id|cloop
comma
op_amp
id|base
)paren
suffix:semicolon
id|temp_register
op_assign
id|base
suffix:semicolon
r_if
c_cond
(paren
id|base
)paren
(brace
singleline_comment|// If this register is implemented
r_if
c_cond
(paren
(paren
(paren
id|base
op_amp
l_int|0x03L
)paren
op_eq
l_int|0x01
)paren
op_logical_and
(paren
id|save_command
op_amp
l_int|0x01
)paren
)paren
(brace
singleline_comment|// IO base
singleline_comment|// set temp_register = amount of IO space requested
id|temp_register
op_assign
id|base
op_amp
l_int|0xFFFFFFFE
suffix:semicolon
id|temp_register
op_assign
(paren
op_complement
id|temp_register
)paren
op_plus
l_int|1
suffix:semicolon
id|io_node
op_assign
(paren
r_struct
id|pci_resource
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|pci_resource
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|io_node
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|io_node-&gt;base
op_assign
id|save_base
op_amp
(paren
op_complement
l_int|0x03L
)paren
suffix:semicolon
id|io_node-&gt;length
op_assign
id|temp_register
suffix:semicolon
id|io_node-&gt;next
op_assign
id|func-&gt;io_head
suffix:semicolon
id|func-&gt;io_head
op_assign
id|io_node
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
(paren
id|base
op_amp
l_int|0x0BL
)paren
op_eq
l_int|0x08
)paren
op_logical_and
(paren
id|save_command
op_amp
l_int|0x02
)paren
)paren
(brace
singleline_comment|// prefetchable memory base
id|temp_register
op_assign
id|base
op_amp
l_int|0xFFFFFFF0
suffix:semicolon
id|temp_register
op_assign
(paren
op_complement
id|temp_register
)paren
op_plus
l_int|1
suffix:semicolon
id|p_mem_node
op_assign
(paren
r_struct
id|pci_resource
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|pci_resource
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p_mem_node
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|p_mem_node-&gt;base
op_assign
id|save_base
op_amp
(paren
op_complement
l_int|0x0FL
)paren
suffix:semicolon
id|p_mem_node-&gt;length
op_assign
id|temp_register
suffix:semicolon
id|p_mem_node-&gt;next
op_assign
id|func-&gt;p_mem_head
suffix:semicolon
id|func-&gt;p_mem_head
op_assign
id|p_mem_node
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
(paren
id|base
op_amp
l_int|0x0BL
)paren
op_eq
l_int|0x00
)paren
op_logical_and
(paren
id|save_command
op_amp
l_int|0x02
)paren
)paren
(brace
singleline_comment|// prefetchable memory base
id|temp_register
op_assign
id|base
op_amp
l_int|0xFFFFFFF0
suffix:semicolon
id|temp_register
op_assign
(paren
op_complement
id|temp_register
)paren
op_plus
l_int|1
suffix:semicolon
id|mem_node
op_assign
(paren
r_struct
id|pci_resource
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|pci_resource
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mem_node
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|mem_node-&gt;base
op_assign
id|save_base
op_amp
(paren
op_complement
l_int|0x0FL
)paren
suffix:semicolon
id|mem_node-&gt;length
op_assign
id|temp_register
suffix:semicolon
id|mem_node-&gt;next
op_assign
id|func-&gt;mem_head
suffix:semicolon
id|func-&gt;mem_head
op_assign
id|mem_node
suffix:semicolon
)brace
r_else
r_return
l_int|1
suffix:semicolon
)brace
)brace
singleline_comment|// End of base register loop
)brace
r_else
r_if
c_cond
(paren
(paren
id|header_type
op_amp
l_int|0x7F
)paren
op_eq
l_int|0x00
)paren
(brace
singleline_comment|// Standard header
singleline_comment|// Figure out IO and memory base lengths
r_for
c_loop
(paren
id|cloop
op_assign
l_int|0x10
suffix:semicolon
id|cloop
op_le
l_int|0x24
suffix:semicolon
id|cloop
op_add_assign
l_int|4
)paren
(brace
id|pci_bus_read_config_dword
(paren
id|pci_bus
comma
id|devfn
comma
id|cloop
comma
op_amp
id|save_base
)paren
suffix:semicolon
id|temp_register
op_assign
l_int|0xFFFFFFFF
suffix:semicolon
id|pci_bus_write_config_dword
(paren
id|pci_bus
comma
id|devfn
comma
id|cloop
comma
id|temp_register
)paren
suffix:semicolon
id|pci_bus_read_config_dword
(paren
id|pci_bus
comma
id|devfn
comma
id|cloop
comma
op_amp
id|base
)paren
suffix:semicolon
id|temp_register
op_assign
id|base
suffix:semicolon
r_if
c_cond
(paren
id|base
)paren
(brace
singleline_comment|// If this register is implemented
r_if
c_cond
(paren
(paren
(paren
id|base
op_amp
l_int|0x03L
)paren
op_eq
l_int|0x01
)paren
op_logical_and
(paren
id|save_command
op_amp
l_int|0x01
)paren
)paren
(brace
singleline_comment|// IO base
singleline_comment|// set temp_register = amount of IO space requested
id|temp_register
op_assign
id|base
op_amp
l_int|0xFFFFFFFE
suffix:semicolon
id|temp_register
op_assign
(paren
op_complement
id|temp_register
)paren
op_plus
l_int|1
suffix:semicolon
id|io_node
op_assign
(paren
r_struct
id|pci_resource
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|pci_resource
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|io_node
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|io_node-&gt;base
op_assign
id|save_base
op_amp
(paren
op_complement
l_int|0x01L
)paren
suffix:semicolon
id|io_node-&gt;length
op_assign
id|temp_register
suffix:semicolon
id|io_node-&gt;next
op_assign
id|func-&gt;io_head
suffix:semicolon
id|func-&gt;io_head
op_assign
id|io_node
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
(paren
id|base
op_amp
l_int|0x0BL
)paren
op_eq
l_int|0x08
)paren
op_logical_and
(paren
id|save_command
op_amp
l_int|0x02
)paren
)paren
(brace
singleline_comment|// prefetchable memory base
id|temp_register
op_assign
id|base
op_amp
l_int|0xFFFFFFF0
suffix:semicolon
id|temp_register
op_assign
(paren
op_complement
id|temp_register
)paren
op_plus
l_int|1
suffix:semicolon
id|p_mem_node
op_assign
(paren
r_struct
id|pci_resource
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|pci_resource
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p_mem_node
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|p_mem_node-&gt;base
op_assign
id|save_base
op_amp
(paren
op_complement
l_int|0x0FL
)paren
suffix:semicolon
id|p_mem_node-&gt;length
op_assign
id|temp_register
suffix:semicolon
id|p_mem_node-&gt;next
op_assign
id|func-&gt;p_mem_head
suffix:semicolon
id|func-&gt;p_mem_head
op_assign
id|p_mem_node
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
(paren
id|base
op_amp
l_int|0x0BL
)paren
op_eq
l_int|0x00
)paren
op_logical_and
(paren
id|save_command
op_amp
l_int|0x02
)paren
)paren
(brace
singleline_comment|// prefetchable memory base
id|temp_register
op_assign
id|base
op_amp
l_int|0xFFFFFFF0
suffix:semicolon
id|temp_register
op_assign
(paren
op_complement
id|temp_register
)paren
op_plus
l_int|1
suffix:semicolon
id|mem_node
op_assign
(paren
r_struct
id|pci_resource
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|pci_resource
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mem_node
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|mem_node-&gt;base
op_assign
id|save_base
op_amp
(paren
op_complement
l_int|0x0FL
)paren
suffix:semicolon
id|mem_node-&gt;length
op_assign
id|temp_register
suffix:semicolon
id|mem_node-&gt;next
op_assign
id|func-&gt;mem_head
suffix:semicolon
id|func-&gt;mem_head
op_assign
id|mem_node
suffix:semicolon
)brace
r_else
r_return
l_int|1
suffix:semicolon
)brace
)brace
singleline_comment|// End of base register loop
)brace
r_else
(brace
singleline_comment|// Some other unknown header type
)brace
singleline_comment|// find the next device in this slot
id|func
op_assign
id|cpqhp_slot_find
c_func
(paren
id|func-&gt;bus
comma
id|func-&gt;device
comma
id|index
op_increment
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * cpqhp_configure_board&n; *&n; * Copies saved configuration information to one slot.&n; * this is called recursively for bridge devices.&n; * this is for hot plug REPLACE!&n; *&n; * returns 0 if success&n; */
DECL|function|cpqhp_configure_board
r_int
id|cpqhp_configure_board
c_func
(paren
r_struct
id|controller
op_star
id|ctrl
comma
r_struct
id|pci_func
op_star
id|func
)paren
(brace
r_int
id|cloop
suffix:semicolon
id|u8
id|header_type
suffix:semicolon
id|u8
id|secondary_bus
suffix:semicolon
r_int
id|sub_bus
suffix:semicolon
r_struct
id|pci_func
op_star
id|next
suffix:semicolon
id|u32
id|temp
suffix:semicolon
id|u32
id|rc
suffix:semicolon
r_int
id|index
op_assign
l_int|0
suffix:semicolon
r_struct
id|pci_bus
op_star
id|pci_bus
op_assign
id|ctrl-&gt;pci_bus
suffix:semicolon
r_int
r_int
id|devfn
suffix:semicolon
id|func
op_assign
id|cpqhp_slot_find
c_func
(paren
id|func-&gt;bus
comma
id|func-&gt;device
comma
id|index
op_increment
)paren
suffix:semicolon
r_while
c_loop
(paren
id|func
op_ne
l_int|NULL
)paren
(brace
id|pci_bus-&gt;number
op_assign
id|func-&gt;bus
suffix:semicolon
id|devfn
op_assign
id|PCI_DEVFN
c_func
(paren
id|func-&gt;device
comma
id|func-&gt;function
)paren
suffix:semicolon
singleline_comment|// Start at the top of config space so that the control
singleline_comment|// registers are programmed last
r_for
c_loop
(paren
id|cloop
op_assign
l_int|0x3C
suffix:semicolon
id|cloop
OG
l_int|0
suffix:semicolon
id|cloop
op_sub_assign
l_int|4
)paren
(brace
id|pci_bus_write_config_dword
(paren
id|pci_bus
comma
id|devfn
comma
id|cloop
comma
id|func-&gt;config_space
(braket
id|cloop
op_rshift
l_int|2
)braket
)paren
suffix:semicolon
)brace
id|pci_bus_read_config_byte
(paren
id|pci_bus
comma
id|devfn
comma
id|PCI_HEADER_TYPE
comma
op_amp
id|header_type
)paren
suffix:semicolon
singleline_comment|// If this is a bridge device, restore subordinate devices
r_if
c_cond
(paren
(paren
id|header_type
op_amp
l_int|0x7F
)paren
op_eq
id|PCI_HEADER_TYPE_BRIDGE
)paren
(brace
singleline_comment|// PCI-PCI Bridge
id|pci_bus_read_config_byte
(paren
id|pci_bus
comma
id|devfn
comma
id|PCI_SECONDARY_BUS
comma
op_amp
id|secondary_bus
)paren
suffix:semicolon
id|sub_bus
op_assign
(paren
r_int
)paren
id|secondary_bus
suffix:semicolon
id|next
op_assign
id|cpqhp_slot_list
(braket
id|sub_bus
)braket
suffix:semicolon
r_while
c_loop
(paren
id|next
op_ne
l_int|NULL
)paren
(brace
id|rc
op_assign
id|cpqhp_configure_board
c_func
(paren
id|ctrl
comma
id|next
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_return
id|rc
suffix:semicolon
id|next
op_assign
id|next-&gt;next
suffix:semicolon
)brace
)brace
r_else
(brace
singleline_comment|// Check all the base Address Registers to make sure
singleline_comment|// they are the same.  If not, the board is different.
r_for
c_loop
(paren
id|cloop
op_assign
l_int|16
suffix:semicolon
id|cloop
OL
l_int|40
suffix:semicolon
id|cloop
op_add_assign
l_int|4
)paren
(brace
id|pci_bus_read_config_dword
(paren
id|pci_bus
comma
id|devfn
comma
id|cloop
comma
op_amp
id|temp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|temp
op_ne
id|func-&gt;config_space
(braket
id|cloop
op_rshift
l_int|2
)braket
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;Config space compare failure!!! offset = %x&bslash;n&quot;
comma
id|cloop
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;bus = %x, device = %x, function = %x&bslash;n&quot;
comma
id|func-&gt;bus
comma
id|func-&gt;device
comma
id|func-&gt;function
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;temp = %x, config space = %x&bslash;n&bslash;n&quot;
comma
id|temp
comma
id|func-&gt;config_space
(braket
id|cloop
op_rshift
l_int|2
)braket
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
)brace
id|func-&gt;configured
op_assign
l_int|1
suffix:semicolon
id|func
op_assign
id|cpqhp_slot_find
c_func
(paren
id|func-&gt;bus
comma
id|func-&gt;device
comma
id|index
op_increment
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * cpqhp_valid_replace&n; *&n; * this function checks to see if a board is the same as the&n; * one it is replacing.  this check will detect if the device&squot;s&n; * vendor or device id&squot;s are the same&n; *&n; * returns 0 if the board is the same nonzero otherwise&n; */
DECL|function|cpqhp_valid_replace
r_int
id|cpqhp_valid_replace
c_func
(paren
r_struct
id|controller
op_star
id|ctrl
comma
r_struct
id|pci_func
op_star
id|func
)paren
(brace
id|u8
id|cloop
suffix:semicolon
id|u8
id|header_type
suffix:semicolon
id|u8
id|secondary_bus
suffix:semicolon
id|u8
id|type
suffix:semicolon
id|u32
id|temp_register
op_assign
l_int|0
suffix:semicolon
id|u32
id|base
suffix:semicolon
id|u32
id|rc
suffix:semicolon
r_struct
id|pci_func
op_star
id|next
suffix:semicolon
r_int
id|index
op_assign
l_int|0
suffix:semicolon
r_struct
id|pci_bus
op_star
id|pci_bus
op_assign
id|ctrl-&gt;pci_bus
suffix:semicolon
r_int
r_int
id|devfn
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|func-&gt;is_a_board
)paren
r_return
id|ADD_NOT_SUPPORTED
suffix:semicolon
id|func
op_assign
id|cpqhp_slot_find
c_func
(paren
id|func-&gt;bus
comma
id|func-&gt;device
comma
id|index
op_increment
)paren
suffix:semicolon
r_while
c_loop
(paren
id|func
op_ne
l_int|NULL
)paren
(brace
id|pci_bus-&gt;number
op_assign
id|func-&gt;bus
suffix:semicolon
id|devfn
op_assign
id|PCI_DEVFN
c_func
(paren
id|func-&gt;device
comma
id|func-&gt;function
)paren
suffix:semicolon
id|pci_bus_read_config_dword
(paren
id|pci_bus
comma
id|devfn
comma
id|PCI_VENDOR_ID
comma
op_amp
id|temp_register
)paren
suffix:semicolon
singleline_comment|// No adapter present
r_if
c_cond
(paren
id|temp_register
op_eq
l_int|0xFFFFFFFF
)paren
r_return
id|NO_ADAPTER_PRESENT
suffix:semicolon
r_if
c_cond
(paren
id|temp_register
op_ne
id|func-&gt;config_space
(braket
l_int|0
)braket
)paren
r_return
id|ADAPTER_NOT_SAME
suffix:semicolon
singleline_comment|// Check for same revision number and class code
id|pci_bus_read_config_dword
(paren
id|pci_bus
comma
id|devfn
comma
id|PCI_CLASS_REVISION
comma
op_amp
id|temp_register
)paren
suffix:semicolon
singleline_comment|// Adapter not the same
r_if
c_cond
(paren
id|temp_register
op_ne
id|func-&gt;config_space
(braket
l_int|0x08
op_rshift
l_int|2
)braket
)paren
r_return
id|ADAPTER_NOT_SAME
suffix:semicolon
singleline_comment|// Check for Bridge
id|pci_bus_read_config_byte
(paren
id|pci_bus
comma
id|devfn
comma
id|PCI_HEADER_TYPE
comma
op_amp
id|header_type
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|header_type
op_amp
l_int|0x7F
)paren
op_eq
id|PCI_HEADER_TYPE_BRIDGE
)paren
(brace
singleline_comment|// PCI-PCI Bridge
singleline_comment|// In order to continue checking, we must program the
singleline_comment|// bus registers in the bridge to respond to accesses
singleline_comment|// for it&squot;s subordinate bus(es)
id|temp_register
op_assign
id|func-&gt;config_space
(braket
l_int|0x18
op_rshift
l_int|2
)braket
suffix:semicolon
id|pci_bus_write_config_dword
(paren
id|pci_bus
comma
id|devfn
comma
id|PCI_PRIMARY_BUS
comma
id|temp_register
)paren
suffix:semicolon
id|secondary_bus
op_assign
(paren
id|temp_register
op_rshift
l_int|8
)paren
op_amp
l_int|0xFF
suffix:semicolon
id|next
op_assign
id|cpqhp_slot_list
(braket
id|secondary_bus
)braket
suffix:semicolon
r_while
c_loop
(paren
id|next
op_ne
l_int|NULL
)paren
(brace
id|rc
op_assign
id|cpqhp_valid_replace
c_func
(paren
id|ctrl
comma
id|next
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_return
id|rc
suffix:semicolon
id|next
op_assign
id|next-&gt;next
suffix:semicolon
)brace
)brace
singleline_comment|// Check to see if it is a standard config header
r_else
r_if
c_cond
(paren
(paren
id|header_type
op_amp
l_int|0x7F
)paren
op_eq
id|PCI_HEADER_TYPE_NORMAL
)paren
(brace
singleline_comment|// Check subsystem vendor and ID
id|pci_bus_read_config_dword
(paren
id|pci_bus
comma
id|devfn
comma
id|PCI_SUBSYSTEM_VENDOR_ID
comma
op_amp
id|temp_register
)paren
suffix:semicolon
r_if
c_cond
(paren
id|temp_register
op_ne
id|func-&gt;config_space
(braket
l_int|0x2C
op_rshift
l_int|2
)braket
)paren
(brace
singleline_comment|// If it&squot;s a SMART-2 and the register isn&squot;t filled
singleline_comment|// in, ignore the difference because
singleline_comment|// they just have an old rev of the firmware
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|func-&gt;config_space
(braket
l_int|0
)braket
op_eq
l_int|0xAE100E11
)paren
op_logical_and
(paren
id|temp_register
op_eq
l_int|0x00L
)paren
)paren
)paren
r_return
id|ADAPTER_NOT_SAME
suffix:semicolon
)brace
singleline_comment|// Figure out IO and memory base lengths
r_for
c_loop
(paren
id|cloop
op_assign
l_int|0x10
suffix:semicolon
id|cloop
op_le
l_int|0x24
suffix:semicolon
id|cloop
op_add_assign
l_int|4
)paren
(brace
id|temp_register
op_assign
l_int|0xFFFFFFFF
suffix:semicolon
id|pci_bus_write_config_dword
(paren
id|pci_bus
comma
id|devfn
comma
id|cloop
comma
id|temp_register
)paren
suffix:semicolon
id|pci_bus_read_config_dword
(paren
id|pci_bus
comma
id|devfn
comma
id|cloop
comma
op_amp
id|base
)paren
suffix:semicolon
r_if
c_cond
(paren
id|base
)paren
(brace
singleline_comment|// If this register is implemented
r_if
c_cond
(paren
id|base
op_amp
l_int|0x01L
)paren
(brace
singleline_comment|// IO base
singleline_comment|// set base = amount of IO space requested
id|base
op_assign
id|base
op_amp
l_int|0xFFFFFFFE
suffix:semicolon
id|base
op_assign
(paren
op_complement
id|base
)paren
op_plus
l_int|1
suffix:semicolon
id|type
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
singleline_comment|// memory base
id|base
op_assign
id|base
op_amp
l_int|0xFFFFFFF0
suffix:semicolon
id|base
op_assign
(paren
op_complement
id|base
)paren
op_plus
l_int|1
suffix:semicolon
id|type
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_else
(brace
id|base
op_assign
l_int|0x0L
suffix:semicolon
id|type
op_assign
l_int|0
suffix:semicolon
)brace
singleline_comment|// Check information in slot structure
r_if
c_cond
(paren
id|func-&gt;base_length
(braket
(paren
id|cloop
op_minus
l_int|0x10
)paren
op_rshift
l_int|2
)braket
op_ne
id|base
)paren
r_return
id|ADAPTER_NOT_SAME
suffix:semicolon
r_if
c_cond
(paren
id|func-&gt;base_type
(braket
(paren
id|cloop
op_minus
l_int|0x10
)paren
op_rshift
l_int|2
)braket
op_ne
id|type
)paren
r_return
id|ADAPTER_NOT_SAME
suffix:semicolon
)brace
singleline_comment|// End of base register loop
)brace
singleline_comment|// End of (type 0 config space) else
r_else
(brace
singleline_comment|// this is not a type 0 or 1 config space header so
singleline_comment|// we don&squot;t know how to do it
r_return
id|DEVICE_TYPE_NOT_SUPPORTED
suffix:semicolon
)brace
singleline_comment|// Get the next function
id|func
op_assign
id|cpqhp_slot_find
c_func
(paren
id|func-&gt;bus
comma
id|func-&gt;device
comma
id|index
op_increment
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * cpqhp_find_available_resources&n; *&n; * Finds available memory, IO, and IRQ resources for programming&n; * devices which may be added to the system&n; * this function is for hot plug ADD!&n; *&n; * returns 0 if success&n; */
DECL|function|cpqhp_find_available_resources
r_int
id|cpqhp_find_available_resources
(paren
r_struct
id|controller
op_star
id|ctrl
comma
r_void
op_star
id|rom_start
)paren
(brace
id|u8
id|temp
suffix:semicolon
id|u8
id|populated_slot
suffix:semicolon
id|u8
id|bridged_slot
suffix:semicolon
r_void
op_star
id|one_slot
suffix:semicolon
r_struct
id|pci_func
op_star
id|func
op_assign
l_int|NULL
suffix:semicolon
r_int
id|i
op_assign
l_int|10
comma
id|index
suffix:semicolon
id|u32
id|temp_dword
comma
id|rc
suffix:semicolon
r_struct
id|pci_resource
op_star
id|mem_node
suffix:semicolon
r_struct
id|pci_resource
op_star
id|p_mem_node
suffix:semicolon
r_struct
id|pci_resource
op_star
id|io_node
suffix:semicolon
r_struct
id|pci_resource
op_star
id|bus_node
suffix:semicolon
r_void
op_star
id|rom_resource_table
suffix:semicolon
id|rom_resource_table
op_assign
id|detect_HRT_floating_pointer
c_func
(paren
id|rom_start
comma
id|rom_start
op_plus
l_int|0xffff
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;rom_resource_table = %p&bslash;n&quot;
comma
id|rom_resource_table
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rom_resource_table
op_eq
l_int|NULL
)paren
(brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
singleline_comment|// Sum all resources and setup resource maps
id|unused_IRQ
op_assign
id|readl
c_func
(paren
id|rom_resource_table
op_plus
id|UNUSED_IRQ
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;unused_IRQ = %x&bslash;n&quot;
comma
id|unused_IRQ
)paren
suffix:semicolon
id|temp
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|unused_IRQ
)paren
(brace
r_if
c_cond
(paren
id|unused_IRQ
op_amp
l_int|1
)paren
(brace
id|cpqhp_disk_irq
op_assign
id|temp
suffix:semicolon
r_break
suffix:semicolon
)brace
id|unused_IRQ
op_assign
id|unused_IRQ
op_rshift
l_int|1
suffix:semicolon
id|temp
op_increment
suffix:semicolon
)brace
id|dbg
c_func
(paren
l_string|&quot;cpqhp_disk_irq= %d&bslash;n&quot;
comma
id|cpqhp_disk_irq
)paren
suffix:semicolon
id|unused_IRQ
op_assign
id|unused_IRQ
op_rshift
l_int|1
suffix:semicolon
id|temp
op_increment
suffix:semicolon
r_while
c_loop
(paren
id|unused_IRQ
)paren
(brace
r_if
c_cond
(paren
id|unused_IRQ
op_amp
l_int|1
)paren
(brace
id|cpqhp_nic_irq
op_assign
id|temp
suffix:semicolon
r_break
suffix:semicolon
)brace
id|unused_IRQ
op_assign
id|unused_IRQ
op_rshift
l_int|1
suffix:semicolon
id|temp
op_increment
suffix:semicolon
)brace
id|dbg
c_func
(paren
l_string|&quot;cpqhp_nic_irq= %d&bslash;n&quot;
comma
id|cpqhp_nic_irq
)paren
suffix:semicolon
id|unused_IRQ
op_assign
id|readl
c_func
(paren
id|rom_resource_table
op_plus
id|PCIIRQ
)paren
suffix:semicolon
id|temp
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cpqhp_nic_irq
)paren
(brace
id|cpqhp_nic_irq
op_assign
id|ctrl-&gt;interrupt
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|cpqhp_disk_irq
)paren
(brace
id|cpqhp_disk_irq
op_assign
id|ctrl-&gt;interrupt
suffix:semicolon
)brace
id|dbg
c_func
(paren
l_string|&quot;cpqhp_disk_irq, cpqhp_nic_irq= %d, %d&bslash;n&quot;
comma
id|cpqhp_disk_irq
comma
id|cpqhp_nic_irq
)paren
suffix:semicolon
id|rc
op_assign
id|compaq_nvram_load
c_func
(paren
id|rom_start
comma
id|ctrl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_return
id|rc
suffix:semicolon
id|one_slot
op_assign
id|rom_resource_table
op_plus
r_sizeof
(paren
r_struct
id|hrt
)paren
suffix:semicolon
id|i
op_assign
id|readb
c_func
(paren
id|rom_resource_table
op_plus
id|NUMBER_OF_ENTRIES
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;number_of_entries = %d&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|readb
c_func
(paren
id|one_slot
op_plus
id|SECONDARY_BUS
)paren
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
id|dbg
c_func
(paren
l_string|&quot;dev|IO base|length|Mem base|length|Pre base|length|PB SB MB&bslash;n&quot;
)paren
suffix:semicolon
r_while
c_loop
(paren
id|i
op_logical_and
id|readb
c_func
(paren
id|one_slot
op_plus
id|SECONDARY_BUS
)paren
)paren
(brace
id|u8
id|dev_func
op_assign
id|readb
c_func
(paren
id|one_slot
op_plus
id|DEV_FUNC
)paren
suffix:semicolon
id|u8
id|primary_bus
op_assign
id|readb
c_func
(paren
id|one_slot
op_plus
id|PRIMARY_BUS
)paren
suffix:semicolon
id|u8
id|secondary_bus
op_assign
id|readb
c_func
(paren
id|one_slot
op_plus
id|SECONDARY_BUS
)paren
suffix:semicolon
id|u8
id|max_bus
op_assign
id|readb
c_func
(paren
id|one_slot
op_plus
id|MAX_BUS
)paren
suffix:semicolon
id|u16
id|io_base
op_assign
id|readw
c_func
(paren
id|one_slot
op_plus
id|IO_BASE
)paren
suffix:semicolon
id|u16
id|io_length
op_assign
id|readw
c_func
(paren
id|one_slot
op_plus
id|IO_LENGTH
)paren
suffix:semicolon
id|u16
id|mem_base
op_assign
id|readw
c_func
(paren
id|one_slot
op_plus
id|MEM_BASE
)paren
suffix:semicolon
id|u16
id|mem_length
op_assign
id|readw
c_func
(paren
id|one_slot
op_plus
id|MEM_LENGTH
)paren
suffix:semicolon
id|u16
id|pre_mem_base
op_assign
id|readw
c_func
(paren
id|one_slot
op_plus
id|PRE_MEM_BASE
)paren
suffix:semicolon
id|u16
id|pre_mem_length
op_assign
id|readw
c_func
(paren
id|one_slot
op_plus
id|PRE_MEM_LENGTH
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;%2.2x | %4.4x  | %4.4x | %4.4x   | %4.4x | %4.4x   | %4.4x |%2.2x %2.2x %2.2x&bslash;n&quot;
comma
id|dev_func
comma
id|io_base
comma
id|io_length
comma
id|mem_base
comma
id|mem_length
comma
id|pre_mem_base
comma
id|pre_mem_length
comma
id|primary_bus
comma
id|secondary_bus
comma
id|max_bus
)paren
suffix:semicolon
singleline_comment|// If this entry isn&squot;t for our controller&squot;s bus, ignore it
r_if
c_cond
(paren
id|primary_bus
op_ne
id|ctrl-&gt;bus
)paren
(brace
id|i
op_decrement
suffix:semicolon
id|one_slot
op_add_assign
r_sizeof
(paren
r_struct
id|slot_rt
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
singleline_comment|// find out if this entry is for an occupied slot
id|ctrl-&gt;pci_bus-&gt;number
op_assign
id|primary_bus
suffix:semicolon
id|pci_bus_read_config_dword
(paren
id|ctrl-&gt;pci_bus
comma
id|dev_func
comma
id|PCI_VENDOR_ID
comma
op_amp
id|temp_dword
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;temp_D_word = %x&bslash;n&quot;
comma
id|temp_dword
)paren
suffix:semicolon
r_if
c_cond
(paren
id|temp_dword
op_ne
l_int|0xFFFFFFFF
)paren
(brace
id|index
op_assign
l_int|0
suffix:semicolon
id|func
op_assign
id|cpqhp_slot_find
c_func
(paren
id|primary_bus
comma
id|dev_func
op_rshift
l_int|3
comma
l_int|0
)paren
suffix:semicolon
r_while
c_loop
(paren
id|func
op_logical_and
(paren
id|func-&gt;function
op_ne
(paren
id|dev_func
op_amp
l_int|0x07
)paren
)paren
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;func = %p (bus, dev, fun) = (%d, %d, %d)&bslash;n&quot;
comma
id|func
comma
id|primary_bus
comma
id|dev_func
op_rshift
l_int|3
comma
id|index
)paren
suffix:semicolon
id|func
op_assign
id|cpqhp_slot_find
c_func
(paren
id|primary_bus
comma
id|dev_func
op_rshift
l_int|3
comma
id|index
op_increment
)paren
suffix:semicolon
)brace
singleline_comment|// If we can&squot;t find a match, skip this table entry
r_if
c_cond
(paren
op_logical_neg
id|func
)paren
(brace
id|i
op_decrement
suffix:semicolon
id|one_slot
op_add_assign
r_sizeof
(paren
r_struct
id|slot_rt
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
singleline_comment|// this may not work and shouldn&squot;t be used
r_if
c_cond
(paren
id|secondary_bus
op_ne
id|primary_bus
)paren
id|bridged_slot
op_assign
l_int|1
suffix:semicolon
r_else
id|bridged_slot
op_assign
l_int|0
suffix:semicolon
id|populated_slot
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|populated_slot
op_assign
l_int|0
suffix:semicolon
id|bridged_slot
op_assign
l_int|0
suffix:semicolon
)brace
singleline_comment|// If we&squot;ve got a valid IO base, use it
id|temp_dword
op_assign
id|io_base
op_plus
id|io_length
suffix:semicolon
r_if
c_cond
(paren
(paren
id|io_base
)paren
op_logical_and
(paren
id|temp_dword
OL
l_int|0x10000
)paren
)paren
(brace
id|io_node
op_assign
(paren
r_struct
id|pci_resource
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|pci_resource
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|io_node
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|io_node-&gt;base
op_assign
id|io_base
suffix:semicolon
id|io_node-&gt;length
op_assign
id|io_length
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;found io_node(base, length) = %x, %x&bslash;n&quot;
comma
id|io_node-&gt;base
comma
id|io_node-&gt;length
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;populated slot =%d &bslash;n&quot;
comma
id|populated_slot
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|populated_slot
)paren
(brace
id|io_node-&gt;next
op_assign
id|ctrl-&gt;io_head
suffix:semicolon
id|ctrl-&gt;io_head
op_assign
id|io_node
suffix:semicolon
)brace
r_else
(brace
id|io_node-&gt;next
op_assign
id|func-&gt;io_head
suffix:semicolon
id|func-&gt;io_head
op_assign
id|io_node
suffix:semicolon
)brace
)brace
singleline_comment|// If we&squot;ve got a valid memory base, use it
id|temp_dword
op_assign
id|mem_base
op_plus
id|mem_length
suffix:semicolon
r_if
c_cond
(paren
(paren
id|mem_base
)paren
op_logical_and
(paren
id|temp_dword
OL
l_int|0x10000
)paren
)paren
(brace
id|mem_node
op_assign
(paren
r_struct
id|pci_resource
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|pci_resource
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mem_node
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|mem_node-&gt;base
op_assign
id|mem_base
op_lshift
l_int|16
suffix:semicolon
id|mem_node-&gt;length
op_assign
id|mem_length
op_lshift
l_int|16
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;found mem_node(base, length) = %x, %x&bslash;n&quot;
comma
id|mem_node-&gt;base
comma
id|mem_node-&gt;length
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;populated slot =%d &bslash;n&quot;
comma
id|populated_slot
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|populated_slot
)paren
(brace
id|mem_node-&gt;next
op_assign
id|ctrl-&gt;mem_head
suffix:semicolon
id|ctrl-&gt;mem_head
op_assign
id|mem_node
suffix:semicolon
)brace
r_else
(brace
id|mem_node-&gt;next
op_assign
id|func-&gt;mem_head
suffix:semicolon
id|func-&gt;mem_head
op_assign
id|mem_node
suffix:semicolon
)brace
)brace
singleline_comment|// If we&squot;ve got a valid prefetchable memory base, and
singleline_comment|// the base + length isn&squot;t greater than 0xFFFF
id|temp_dword
op_assign
id|pre_mem_base
op_plus
id|pre_mem_length
suffix:semicolon
r_if
c_cond
(paren
(paren
id|pre_mem_base
)paren
op_logical_and
(paren
id|temp_dword
OL
l_int|0x10000
)paren
)paren
(brace
id|p_mem_node
op_assign
(paren
r_struct
id|pci_resource
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|pci_resource
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p_mem_node
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|p_mem_node-&gt;base
op_assign
id|pre_mem_base
op_lshift
l_int|16
suffix:semicolon
id|p_mem_node-&gt;length
op_assign
id|pre_mem_length
op_lshift
l_int|16
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;found p_mem_node(base, length) = %x, %x&bslash;n&quot;
comma
id|p_mem_node-&gt;base
comma
id|p_mem_node-&gt;length
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;populated slot =%d &bslash;n&quot;
comma
id|populated_slot
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|populated_slot
)paren
(brace
id|p_mem_node-&gt;next
op_assign
id|ctrl-&gt;p_mem_head
suffix:semicolon
id|ctrl-&gt;p_mem_head
op_assign
id|p_mem_node
suffix:semicolon
)brace
r_else
(brace
id|p_mem_node-&gt;next
op_assign
id|func-&gt;p_mem_head
suffix:semicolon
id|func-&gt;p_mem_head
op_assign
id|p_mem_node
suffix:semicolon
)brace
)brace
singleline_comment|// If we&squot;ve got a valid bus number, use it
singleline_comment|// The second condition is to ignore bus numbers on
singleline_comment|// populated slots that don&squot;t have PCI-PCI bridges
r_if
c_cond
(paren
id|secondary_bus
op_logical_and
(paren
id|secondary_bus
op_ne
id|primary_bus
)paren
)paren
(brace
id|bus_node
op_assign
(paren
r_struct
id|pci_resource
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|pci_resource
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bus_node
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|bus_node-&gt;base
op_assign
id|secondary_bus
suffix:semicolon
id|bus_node-&gt;length
op_assign
id|max_bus
op_minus
id|secondary_bus
op_plus
l_int|1
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;found bus_node(base, length) = %x, %x&bslash;n&quot;
comma
id|bus_node-&gt;base
comma
id|bus_node-&gt;length
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;populated slot =%d &bslash;n&quot;
comma
id|populated_slot
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|populated_slot
)paren
(brace
id|bus_node-&gt;next
op_assign
id|ctrl-&gt;bus_head
suffix:semicolon
id|ctrl-&gt;bus_head
op_assign
id|bus_node
suffix:semicolon
)brace
r_else
(brace
id|bus_node-&gt;next
op_assign
id|func-&gt;bus_head
suffix:semicolon
id|func-&gt;bus_head
op_assign
id|bus_node
suffix:semicolon
)brace
)brace
id|i
op_decrement
suffix:semicolon
id|one_slot
op_add_assign
r_sizeof
(paren
r_struct
id|slot_rt
)paren
suffix:semicolon
)brace
singleline_comment|// If all of the following fail, we don&squot;t have any resources for
singleline_comment|// hot plug add
id|rc
op_assign
l_int|1
suffix:semicolon
id|rc
op_and_assign
id|cpqhp_resource_sort_and_combine
c_func
(paren
op_amp
(paren
id|ctrl-&gt;mem_head
)paren
)paren
suffix:semicolon
id|rc
op_and_assign
id|cpqhp_resource_sort_and_combine
c_func
(paren
op_amp
(paren
id|ctrl-&gt;p_mem_head
)paren
)paren
suffix:semicolon
id|rc
op_and_assign
id|cpqhp_resource_sort_and_combine
c_func
(paren
op_amp
(paren
id|ctrl-&gt;io_head
)paren
)paren
suffix:semicolon
id|rc
op_and_assign
id|cpqhp_resource_sort_and_combine
c_func
(paren
op_amp
(paren
id|ctrl-&gt;bus_head
)paren
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/*&n; * cpqhp_return_board_resources&n; *&n; * this routine returns all resources allocated to a board to&n; * the available pool.&n; *&n; * returns 0 if success&n; */
DECL|function|cpqhp_return_board_resources
r_int
id|cpqhp_return_board_resources
c_func
(paren
r_struct
id|pci_func
op_star
id|func
comma
r_struct
id|resource_lists
op_star
id|resources
)paren
(brace
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
r_struct
id|pci_resource
op_star
id|node
suffix:semicolon
r_struct
id|pci_resource
op_star
id|t_node
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;%s&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|func
)paren
r_return
l_int|1
suffix:semicolon
id|node
op_assign
id|func-&gt;io_head
suffix:semicolon
id|func-&gt;io_head
op_assign
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
id|node
)paren
(brace
id|t_node
op_assign
id|node-&gt;next
suffix:semicolon
id|return_resource
c_func
(paren
op_amp
(paren
id|resources-&gt;io_head
)paren
comma
id|node
)paren
suffix:semicolon
id|node
op_assign
id|t_node
suffix:semicolon
)brace
id|node
op_assign
id|func-&gt;mem_head
suffix:semicolon
id|func-&gt;mem_head
op_assign
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
id|node
)paren
(brace
id|t_node
op_assign
id|node-&gt;next
suffix:semicolon
id|return_resource
c_func
(paren
op_amp
(paren
id|resources-&gt;mem_head
)paren
comma
id|node
)paren
suffix:semicolon
id|node
op_assign
id|t_node
suffix:semicolon
)brace
id|node
op_assign
id|func-&gt;p_mem_head
suffix:semicolon
id|func-&gt;p_mem_head
op_assign
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
id|node
)paren
(brace
id|t_node
op_assign
id|node-&gt;next
suffix:semicolon
id|return_resource
c_func
(paren
op_amp
(paren
id|resources-&gt;p_mem_head
)paren
comma
id|node
)paren
suffix:semicolon
id|node
op_assign
id|t_node
suffix:semicolon
)brace
id|node
op_assign
id|func-&gt;bus_head
suffix:semicolon
id|func-&gt;bus_head
op_assign
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
id|node
)paren
(brace
id|t_node
op_assign
id|node-&gt;next
suffix:semicolon
id|return_resource
c_func
(paren
op_amp
(paren
id|resources-&gt;bus_head
)paren
comma
id|node
)paren
suffix:semicolon
id|node
op_assign
id|t_node
suffix:semicolon
)brace
id|rc
op_or_assign
id|cpqhp_resource_sort_and_combine
c_func
(paren
op_amp
(paren
id|resources-&gt;mem_head
)paren
)paren
suffix:semicolon
id|rc
op_or_assign
id|cpqhp_resource_sort_and_combine
c_func
(paren
op_amp
(paren
id|resources-&gt;p_mem_head
)paren
)paren
suffix:semicolon
id|rc
op_or_assign
id|cpqhp_resource_sort_and_combine
c_func
(paren
op_amp
(paren
id|resources-&gt;io_head
)paren
)paren
suffix:semicolon
id|rc
op_or_assign
id|cpqhp_resource_sort_and_combine
c_func
(paren
op_amp
(paren
id|resources-&gt;bus_head
)paren
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/*&n; * cpqhp_destroy_resource_list&n; *&n; * Puts node back in the resource list pointed to by head&n; */
DECL|function|cpqhp_destroy_resource_list
r_void
id|cpqhp_destroy_resource_list
(paren
r_struct
id|resource_lists
op_star
id|resources
)paren
(brace
r_struct
id|pci_resource
op_star
id|res
comma
op_star
id|tres
suffix:semicolon
id|res
op_assign
id|resources-&gt;io_head
suffix:semicolon
id|resources-&gt;io_head
op_assign
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
id|res
)paren
(brace
id|tres
op_assign
id|res
suffix:semicolon
id|res
op_assign
id|res-&gt;next
suffix:semicolon
id|kfree
c_func
(paren
id|tres
)paren
suffix:semicolon
)brace
id|res
op_assign
id|resources-&gt;mem_head
suffix:semicolon
id|resources-&gt;mem_head
op_assign
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
id|res
)paren
(brace
id|tres
op_assign
id|res
suffix:semicolon
id|res
op_assign
id|res-&gt;next
suffix:semicolon
id|kfree
c_func
(paren
id|tres
)paren
suffix:semicolon
)brace
id|res
op_assign
id|resources-&gt;p_mem_head
suffix:semicolon
id|resources-&gt;p_mem_head
op_assign
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
id|res
)paren
(brace
id|tres
op_assign
id|res
suffix:semicolon
id|res
op_assign
id|res-&gt;next
suffix:semicolon
id|kfree
c_func
(paren
id|tres
)paren
suffix:semicolon
)brace
id|res
op_assign
id|resources-&gt;bus_head
suffix:semicolon
id|resources-&gt;bus_head
op_assign
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
id|res
)paren
(brace
id|tres
op_assign
id|res
suffix:semicolon
id|res
op_assign
id|res-&gt;next
suffix:semicolon
id|kfree
c_func
(paren
id|tres
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * cpqhp_destroy_board_resources&n; *&n; * Puts node back in the resource list pointed to by head&n; */
DECL|function|cpqhp_destroy_board_resources
r_void
id|cpqhp_destroy_board_resources
(paren
r_struct
id|pci_func
op_star
id|func
)paren
(brace
r_struct
id|pci_resource
op_star
id|res
comma
op_star
id|tres
suffix:semicolon
id|res
op_assign
id|func-&gt;io_head
suffix:semicolon
id|func-&gt;io_head
op_assign
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
id|res
)paren
(brace
id|tres
op_assign
id|res
suffix:semicolon
id|res
op_assign
id|res-&gt;next
suffix:semicolon
id|kfree
c_func
(paren
id|tres
)paren
suffix:semicolon
)brace
id|res
op_assign
id|func-&gt;mem_head
suffix:semicolon
id|func-&gt;mem_head
op_assign
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
id|res
)paren
(brace
id|tres
op_assign
id|res
suffix:semicolon
id|res
op_assign
id|res-&gt;next
suffix:semicolon
id|kfree
c_func
(paren
id|tres
)paren
suffix:semicolon
)brace
id|res
op_assign
id|func-&gt;p_mem_head
suffix:semicolon
id|func-&gt;p_mem_head
op_assign
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
id|res
)paren
(brace
id|tres
op_assign
id|res
suffix:semicolon
id|res
op_assign
id|res-&gt;next
suffix:semicolon
id|kfree
c_func
(paren
id|tres
)paren
suffix:semicolon
)brace
id|res
op_assign
id|func-&gt;bus_head
suffix:semicolon
id|func-&gt;bus_head
op_assign
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
id|res
)paren
(brace
id|tres
op_assign
id|res
suffix:semicolon
id|res
op_assign
id|res-&gt;next
suffix:semicolon
id|kfree
c_func
(paren
id|tres
)paren
suffix:semicolon
)brace
)brace
eof
