multiline_comment|/*&n; *&n;  Copyright (c) Eicon Networks, 2002.&n; *&n;  This source file is supplied for the use with&n;  Eicon Networks range of DIVA Server Adapters.&n; *&n;  Eicon File Revision :    2.1&n; *&n;  This program is free software; you can redistribute it and/or modify&n;  it under the terms of the GNU General Public License as published by&n;  the Free Software Foundation; either version 2, or (at your option)&n;  any later version.&n; *&n;  This program is distributed in the hope that it will be useful,&n;  but WITHOUT ANY WARRANTY OF ANY KIND WHATSOEVER INCLUDING ANY&n;  implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&n;  See the GNU General Public License for more details.&n; *&n;  You should have received a copy of the GNU General Public License&n;  along with this program; if not, write to the Free Software&n;  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.&n; *&n; */
macro_line|#include &quot;platform.h&quot;
macro_line|#include &quot;pc.h&quot;
macro_line|#include &quot;pr_pc.h&quot;
macro_line|#include &quot;di_defs.h&quot;
macro_line|#include &quot;di.h&quot;
macro_line|#if !defined USE_EXTENDED_DEBUGS
macro_line|#include &quot;dimaint.h&quot;
macro_line|#else
DECL|macro|dprintf
mdefine_line|#define dprintf
macro_line|#endif
macro_line|#include &quot;io.h&quot;
macro_line|#include &quot;dfifo.h&quot;
DECL|macro|PR_RAM
mdefine_line|#define PR_RAM  ((struct pr_ram *)0)
DECL|macro|RAM
mdefine_line|#define RAM ((struct dual *)0)
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/* local function prototypes                                        */
multiline_comment|/*------------------------------------------------------------------*/
r_void
id|pr_out
c_func
(paren
id|ADAPTER
op_star
id|a
)paren
suffix:semicolon
id|byte
id|pr_dpc
c_func
(paren
id|ADAPTER
op_star
id|a
)paren
suffix:semicolon
r_void
id|scom_out
c_func
(paren
id|ADAPTER
op_star
id|a
)paren
suffix:semicolon
id|byte
id|scom_dpc
c_func
(paren
id|ADAPTER
op_star
id|a
)paren
suffix:semicolon
r_static
id|byte
id|pr_ready
c_func
(paren
id|ADAPTER
op_star
id|a
)paren
suffix:semicolon
r_static
id|byte
id|scom_ready
c_func
(paren
id|ADAPTER
op_star
id|a
)paren
suffix:semicolon
r_static
id|byte
id|isdn_rc
c_func
(paren
id|ADAPTER
op_star
comma
id|byte
comma
id|byte
comma
id|byte
comma
id|word
comma
id|dword
comma
id|dword
)paren
suffix:semicolon
r_static
id|byte
id|isdn_ind
c_func
(paren
id|ADAPTER
op_star
comma
id|byte
comma
id|byte
comma
id|byte
comma
id|PBUFFER
op_star
comma
id|byte
comma
id|word
)paren
suffix:semicolon
multiline_comment|/* -----------------------------------------------------------------&n;    Functions used for the extended XDI Debug&n;    macros&n;    global convergence counter (used by all adapters)&n;    Look by the implementation part of the functions&n;    about the parameters.&n;    If you change the dubugging parameters, then you should update&n;    the aididbg.doc in the IDI doc&squot;s.&n;   ----------------------------------------------------------------- */
macro_line|#if defined(XDI_USE_XLOG)
DECL|macro|XDI_A_NR
mdefine_line|#define XDI_A_NR(_x_) ((byte)(((ISDN_ADAPTER *)(_x_-&gt;io))-&gt;ANum))
macro_line|#else
DECL|macro|XDI_A_NR
mdefine_line|#define XDI_A_NR(_x_) ((byte)0)
macro_line|#endif
DECL|variable|xdi_xlog_sec
id|byte
id|xdi_xlog_sec
op_assign
l_int|0
suffix:semicolon
r_void
id|xdi_xlog
(paren
id|byte
op_star
id|msg
comma
id|word
id|code
comma
r_int
id|length
)paren
suffix:semicolon
r_static
r_void
id|xdi_xlog_rc_event
(paren
id|byte
id|Adapter
comma
id|byte
id|Id
comma
id|byte
id|Ch
comma
id|byte
id|Rc
comma
id|byte
id|cb
comma
id|byte
id|type
)paren
suffix:semicolon
r_static
r_void
id|xdi_xlog_request
(paren
id|byte
id|Adapter
comma
id|byte
id|Id
comma
id|byte
id|Ch
comma
id|byte
id|Req
comma
id|byte
id|type
)paren
suffix:semicolon
r_static
r_void
id|xdi_xlog_ind
(paren
id|byte
id|Adapter
comma
id|byte
id|Id
comma
id|byte
id|Ch
comma
id|byte
id|Ind
comma
id|byte
id|rnr_valid
comma
id|byte
id|rnr
comma
id|byte
id|type
)paren
suffix:semicolon
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/* output function                                                  */
multiline_comment|/*------------------------------------------------------------------*/
DECL|function|pr_out
r_void
id|pr_out
c_func
(paren
id|ADAPTER
op_star
id|a
)paren
(brace
id|byte
id|e_no
suffix:semicolon
id|ENTITY
op_star
id|this
op_assign
l_int|NULL
suffix:semicolon
id|BUFFERS
op_star
id|X
suffix:semicolon
id|word
id|length
suffix:semicolon
id|word
id|i
suffix:semicolon
id|word
id|clength
suffix:semicolon
id|REQ
op_star
id|ReqOut
suffix:semicolon
id|byte
id|more
suffix:semicolon
id|byte
id|ReadyCount
suffix:semicolon
id|byte
id|ReqCount
suffix:semicolon
id|byte
id|Id
suffix:semicolon
id|dtrc
c_func
(paren
id|dprintf
c_func
(paren
l_string|&quot;pr_out&quot;
)paren
)paren
suffix:semicolon
multiline_comment|/* while a request is pending ...                           */
id|e_no
op_assign
id|look_req
c_func
(paren
id|a
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|e_no
)paren
(brace
id|dtrc
c_func
(paren
id|dprintf
c_func
(paren
l_string|&quot;no_req&quot;
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|ReadyCount
op_assign
id|pr_ready
c_func
(paren
id|a
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ReadyCount
)paren
(brace
id|dtrc
c_func
(paren
id|dprintf
c_func
(paren
l_string|&quot;not_ready&quot;
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|ReqCount
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|e_no
op_logical_and
id|ReadyCount
)paren
(brace
id|next_req
c_func
(paren
id|a
)paren
suffix:semicolon
id|this
op_assign
id|entity_ptr
c_func
(paren
id|a
comma
id|e_no
)paren
suffix:semicolon
macro_line|#ifdef USE_EXTENDED_DEBUGS
r_if
c_cond
(paren
op_logical_neg
id|this
)paren
(brace
id|DBG_FTL
c_func
(paren
(paren
l_string|&quot;XDI: [%02x] !A%d ==&gt; NULL entity ptr - try to ignore&quot;
comma
id|xdi_xlog_sec
op_increment
comma
(paren
r_int
)paren
(paren
(paren
id|ISDN_ADAPTER
op_star
)paren
id|a-&gt;io
)paren
op_member_access_from_pointer
id|ANum
)paren
)paren
id|e_no
op_assign
id|look_req
c_func
(paren
id|a
)paren
suffix:semicolon
id|ReadyCount
op_decrement
suffix:semicolon
r_continue
suffix:semicolon
)brace
(brace
id|DBG_TRC
c_func
(paren
(paren
l_string|&quot;&gt;A%d Id=0x%x Req=0x%x&quot;
comma
(paren
(paren
id|ISDN_ADAPTER
op_star
)paren
id|a-&gt;io
)paren
op_member_access_from_pointer
id|ANum
comma
id|this-&gt;Id
comma
id|this-&gt;Req
)paren
)paren
)brace
macro_line|#else
id|dbug
c_func
(paren
id|dprintf
c_func
(paren
l_string|&quot;out:Req=%x,Id=%x,Ch=%x&quot;
comma
id|this-&gt;Req
comma
id|this-&gt;Id
comma
id|this-&gt;ReqCh
)paren
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* get address of next available request buffer             */
id|ReqOut
op_assign
(paren
id|REQ
op_star
)paren
op_amp
id|PR_RAM-&gt;B
(braket
id|a
op_member_access_from_pointer
id|ram_inw
c_func
(paren
id|a
comma
op_amp
id|PR_RAM-&gt;NextReq
)paren
)braket
suffix:semicolon
macro_line|#if defined(DIVA_ISTREAM)
r_if
c_cond
(paren
op_logical_neg
(paren
id|a-&gt;tx_stream
(braket
id|this-&gt;Id
)braket
op_logical_and
id|this-&gt;Req
op_eq
id|N_DATA
)paren
)paren
(brace
macro_line|#endif
multiline_comment|/* now copy the data from the current data buffer into the  */
multiline_comment|/* adapters request buffer                                  */
id|length
op_assign
l_int|0
suffix:semicolon
id|i
op_assign
id|this-&gt;XCurrent
suffix:semicolon
id|X
op_assign
id|PTR_X
c_func
(paren
id|a
comma
id|this
)paren
suffix:semicolon
r_while
c_loop
(paren
id|i
OL
id|this-&gt;XNum
op_logical_and
id|length
OL
l_int|270
)paren
(brace
id|clength
op_assign
id|MIN
c_func
(paren
(paren
id|word
)paren
(paren
l_int|270
op_minus
id|length
)paren
comma
id|X
(braket
id|i
)braket
dot
id|PLength
op_minus
id|this-&gt;XOffset
)paren
suffix:semicolon
id|a
op_member_access_from_pointer
id|ram_out_buffer
c_func
(paren
id|a
comma
op_amp
id|ReqOut-&gt;XBuffer.P
(braket
id|length
)braket
comma
id|PTR_P
c_func
(paren
id|a
comma
id|this
comma
op_amp
id|X
(braket
id|i
)braket
dot
id|P
(braket
id|this-&gt;XOffset
)braket
)paren
comma
id|clength
)paren
suffix:semicolon
id|length
op_add_assign
id|clength
suffix:semicolon
id|this-&gt;XOffset
op_add_assign
id|clength
suffix:semicolon
r_if
c_cond
(paren
id|this-&gt;XOffset
op_eq
id|X
(braket
id|i
)braket
dot
id|PLength
)paren
(brace
id|this-&gt;XCurrent
op_assign
(paren
id|byte
)paren
op_increment
id|i
suffix:semicolon
id|this-&gt;XOffset
op_assign
l_int|0
suffix:semicolon
)brace
)brace
macro_line|#if defined(DIVA_ISTREAM)
)brace
r_else
(brace
multiline_comment|/* Use CMA extension in order to transfer data to the card */
id|i
op_assign
id|this-&gt;XCurrent
suffix:semicolon
id|X
op_assign
id|PTR_X
c_func
(paren
id|a
comma
id|this
)paren
suffix:semicolon
r_while
c_loop
(paren
id|i
OL
id|this-&gt;XNum
)paren
(brace
id|diva_istream_write
(paren
id|a
comma
id|this-&gt;Id
comma
id|PTR_P
c_func
(paren
id|a
comma
id|this
comma
op_amp
id|X
(braket
id|i
)braket
dot
id|P
(braket
l_int|0
)braket
)paren
comma
id|X
(braket
id|i
)braket
dot
id|PLength
comma
(paren
(paren
id|i
op_plus
l_int|1
)paren
op_eq
id|this-&gt;XNum
)paren
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|this-&gt;XCurrent
op_assign
(paren
id|byte
)paren
op_increment
id|i
suffix:semicolon
)brace
id|length
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#endif
id|a
op_member_access_from_pointer
id|ram_outw
c_func
(paren
id|a
comma
op_amp
id|ReqOut-&gt;XBuffer.length
comma
id|length
)paren
suffix:semicolon
id|a
op_member_access_from_pointer
id|ram_out
c_func
(paren
id|a
comma
op_amp
id|ReqOut-&gt;ReqId
comma
id|this-&gt;Id
)paren
suffix:semicolon
id|a
op_member_access_from_pointer
id|ram_out
c_func
(paren
id|a
comma
op_amp
id|ReqOut-&gt;ReqCh
comma
id|this-&gt;ReqCh
)paren
suffix:semicolon
multiline_comment|/* if it&squot;s a specific request (no ASSIGN) ...                */
r_if
c_cond
(paren
id|this-&gt;Id
op_amp
l_int|0x1f
)paren
(brace
multiline_comment|/* if buffers are left in the list of data buffers do       */
multiline_comment|/* do chaining (LL_MDATA, N_MDATA)                          */
id|this-&gt;More
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|i
OL
id|this-&gt;XNum
op_logical_and
id|this-&gt;MInd
)paren
(brace
id|xdi_xlog_request
(paren
id|XDI_A_NR
c_func
(paren
id|a
)paren
comma
id|this-&gt;Id
comma
id|this-&gt;ReqCh
comma
id|this-&gt;MInd
comma
id|a-&gt;IdTypeTable
(braket
id|this-&gt;No
)braket
)paren
suffix:semicolon
id|a
op_member_access_from_pointer
id|ram_out
c_func
(paren
id|a
comma
op_amp
id|ReqOut-&gt;Req
comma
id|this-&gt;MInd
)paren
suffix:semicolon
id|more
op_assign
id|TRUE
suffix:semicolon
)brace
r_else
(brace
id|xdi_xlog_request
(paren
id|XDI_A_NR
c_func
(paren
id|a
)paren
comma
id|this-&gt;Id
comma
id|this-&gt;ReqCh
comma
id|this-&gt;Req
comma
id|a-&gt;IdTypeTable
(braket
id|this-&gt;No
)braket
)paren
suffix:semicolon
id|this-&gt;More
op_or_assign
id|XMOREF
suffix:semicolon
id|a
op_member_access_from_pointer
id|ram_out
c_func
(paren
id|a
comma
op_amp
id|ReqOut-&gt;Req
comma
id|this-&gt;Req
)paren
suffix:semicolon
id|more
op_assign
id|FALSE
suffix:semicolon
r_if
c_cond
(paren
id|a-&gt;FlowControlIdTable
(braket
id|this-&gt;ReqCh
)braket
op_eq
id|this-&gt;Id
)paren
id|a-&gt;FlowControlSkipTable
(braket
id|this-&gt;ReqCh
)braket
op_assign
id|TRUE
suffix:semicolon
multiline_comment|/*&n;           Note that remove request was sent to the card&n;           */
r_if
c_cond
(paren
id|this-&gt;Req
op_eq
id|REMOVE
)paren
(brace
id|a-&gt;misc_flags_table
(braket
id|e_no
)braket
op_or_assign
id|DIVA_MISC_FLAGS_REMOVE_PENDING
suffix:semicolon
)brace
)brace
multiline_comment|/* if we did chaining, this entity is put back into the     */
multiline_comment|/* request queue                                            */
r_if
c_cond
(paren
id|more
)paren
(brace
id|req_queue
c_func
(paren
id|a
comma
id|this-&gt;No
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* else it&squot;s a ASSIGN                                       */
r_else
(brace
multiline_comment|/* save the request code used for buffer chaining           */
id|this-&gt;MInd
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|this-&gt;Id
op_eq
id|BLLC_ID
)paren
id|this-&gt;MInd
op_assign
id|LL_MDATA
suffix:semicolon
r_if
c_cond
(paren
id|this-&gt;Id
op_eq
id|NL_ID
op_logical_or
id|this-&gt;Id
op_eq
id|TASK_ID
op_logical_or
id|this-&gt;Id
op_eq
id|MAN_ID
)paren
id|this-&gt;MInd
op_assign
id|N_MDATA
suffix:semicolon
multiline_comment|/* send the ASSIGN                                          */
id|a-&gt;IdTypeTable
(braket
id|this-&gt;No
)braket
op_assign
id|this-&gt;Id
suffix:semicolon
id|xdi_xlog_request
(paren
id|XDI_A_NR
c_func
(paren
id|a
)paren
comma
id|this-&gt;Id
comma
id|this-&gt;ReqCh
comma
id|this-&gt;Req
comma
id|this-&gt;Id
)paren
suffix:semicolon
id|this-&gt;More
op_or_assign
id|XMOREF
suffix:semicolon
id|a
op_member_access_from_pointer
id|ram_out
c_func
(paren
id|a
comma
op_amp
id|ReqOut-&gt;Req
comma
id|this-&gt;Req
)paren
suffix:semicolon
multiline_comment|/* save the reference of the ASSIGN                         */
id|assign_queue
c_func
(paren
id|a
comma
id|this-&gt;No
comma
id|a
op_member_access_from_pointer
id|ram_inw
c_func
(paren
id|a
comma
op_amp
id|ReqOut-&gt;Reference
)paren
)paren
suffix:semicolon
)brace
id|a
op_member_access_from_pointer
id|ram_outw
c_func
(paren
id|a
comma
op_amp
id|PR_RAM-&gt;NextReq
comma
id|a
op_member_access_from_pointer
id|ram_inw
c_func
(paren
id|a
comma
op_amp
id|ReqOut-&gt;next
)paren
)paren
suffix:semicolon
id|ReadyCount
op_decrement
suffix:semicolon
id|ReqCount
op_increment
suffix:semicolon
id|e_no
op_assign
id|look_req
c_func
(paren
id|a
)paren
suffix:semicolon
)brace
multiline_comment|/* send the filled request buffers to the ISDN adapter      */
id|a
op_member_access_from_pointer
id|ram_out
c_func
(paren
id|a
comma
op_amp
id|PR_RAM-&gt;ReqInput
comma
(paren
id|byte
)paren
(paren
id|a
op_member_access_from_pointer
id|ram_in
c_func
(paren
id|a
comma
op_amp
id|PR_RAM-&gt;ReqInput
)paren
op_plus
id|ReqCount
)paren
)paren
suffix:semicolon
multiline_comment|/* if it is a &squot;unreturncoded&squot; UREMOVE request, remove the  */
multiline_comment|/* Id from our table after sending the request             */
r_if
c_cond
(paren
id|this
op_logical_and
(paren
id|this-&gt;Req
op_eq
id|UREMOVE
)paren
op_logical_and
id|this-&gt;Id
)paren
(brace
id|Id
op_assign
id|this-&gt;Id
suffix:semicolon
id|e_no
op_assign
id|a-&gt;IdTable
(braket
id|Id
)braket
suffix:semicolon
id|free_entity
c_func
(paren
id|a
comma
id|e_no
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|256
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|a-&gt;FlowControlIdTable
(braket
id|i
)braket
op_eq
id|Id
)paren
id|a-&gt;FlowControlIdTable
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
)brace
id|a-&gt;IdTable
(braket
id|Id
)braket
op_assign
l_int|0
suffix:semicolon
id|this-&gt;Id
op_assign
l_int|0
suffix:semicolon
)brace
)brace
DECL|function|pr_ready
r_static
id|byte
id|pr_ready
c_func
(paren
id|ADAPTER
op_star
id|a
)paren
(brace
id|byte
id|ReadyCount
suffix:semicolon
id|ReadyCount
op_assign
(paren
id|byte
)paren
(paren
id|a
op_member_access_from_pointer
id|ram_in
c_func
(paren
id|a
comma
op_amp
id|PR_RAM-&gt;ReqOutput
)paren
op_minus
id|a
op_member_access_from_pointer
id|ram_in
c_func
(paren
id|a
comma
op_amp
id|PR_RAM-&gt;ReqInput
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ReadyCount
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|a-&gt;ReadyInt
)paren
(brace
id|a
op_member_access_from_pointer
id|ram_inc
c_func
(paren
id|a
comma
op_amp
id|PR_RAM-&gt;ReadyInt
)paren
suffix:semicolon
id|a-&gt;ReadyInt
op_increment
suffix:semicolon
)brace
)brace
r_return
id|ReadyCount
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/* isdn interrupt handler                                           */
multiline_comment|/*------------------------------------------------------------------*/
DECL|function|pr_dpc
id|byte
id|pr_dpc
c_func
(paren
id|ADAPTER
op_star
id|a
)paren
(brace
id|byte
id|Count
suffix:semicolon
id|RC
op_star
id|RcIn
suffix:semicolon
id|IND
op_star
id|IndIn
suffix:semicolon
id|byte
id|c
suffix:semicolon
id|byte
id|RNRId
suffix:semicolon
id|byte
id|Rc
suffix:semicolon
id|byte
id|Ind
suffix:semicolon
multiline_comment|/* if return codes are available ...                        */
r_if
c_cond
(paren
(paren
id|Count
op_assign
id|a
op_member_access_from_pointer
id|ram_in
c_func
(paren
id|a
comma
op_amp
id|PR_RAM-&gt;RcOutput
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|dtrc
c_func
(paren
id|dprintf
c_func
(paren
l_string|&quot;#Rc=%x&quot;
comma
id|Count
)paren
)paren
suffix:semicolon
multiline_comment|/* get the buffer address of the first return code          */
id|RcIn
op_assign
(paren
id|RC
op_star
)paren
op_amp
id|PR_RAM-&gt;B
(braket
id|a
op_member_access_from_pointer
id|ram_inw
c_func
(paren
id|a
comma
op_amp
id|PR_RAM-&gt;NextRc
)paren
)braket
suffix:semicolon
multiline_comment|/* for all return codes do ...                              */
r_while
c_loop
(paren
id|Count
op_decrement
)paren
(brace
r_if
c_cond
(paren
(paren
id|Rc
op_assign
id|a
op_member_access_from_pointer
id|ram_in
c_func
(paren
id|a
comma
op_amp
id|RcIn-&gt;Rc
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|dword
id|tmp
(braket
l_int|2
)braket
suffix:semicolon
multiline_comment|/*&n;          Get extended information, associated with return code&n;          */
id|a
op_member_access_from_pointer
id|ram_in_buffer
c_func
(paren
id|a
comma
op_amp
id|RcIn-&gt;Reserved2
(braket
l_int|0
)braket
comma
(paren
id|byte
op_star
)paren
op_amp
id|tmp
(braket
l_int|0
)braket
comma
l_int|8
)paren
suffix:semicolon
multiline_comment|/* call return code handler, if it is not our return code   */
multiline_comment|/* the handler returns 2                                    */
multiline_comment|/* for all return codes we process, we clear the Rc field   */
id|isdn_rc
c_func
(paren
id|a
comma
id|Rc
comma
id|a
op_member_access_from_pointer
id|ram_in
c_func
(paren
id|a
comma
op_amp
id|RcIn-&gt;RcId
)paren
comma
id|a
op_member_access_from_pointer
id|ram_in
c_func
(paren
id|a
comma
op_amp
id|RcIn-&gt;RcCh
)paren
comma
id|a
op_member_access_from_pointer
id|ram_inw
c_func
(paren
id|a
comma
op_amp
id|RcIn-&gt;Reference
)paren
comma
id|tmp
(braket
l_int|0
)braket
comma
multiline_comment|/* type of extended informtion */
id|tmp
(braket
l_int|1
)braket
)paren
suffix:semicolon
multiline_comment|/* extended information        */
id|a
op_member_access_from_pointer
id|ram_out
c_func
(paren
id|a
comma
op_amp
id|RcIn-&gt;Rc
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* get buffer address of next return code                   */
id|RcIn
op_assign
(paren
id|RC
op_star
)paren
op_amp
id|PR_RAM-&gt;B
(braket
id|a
op_member_access_from_pointer
id|ram_inw
c_func
(paren
id|a
comma
op_amp
id|RcIn-&gt;next
)paren
)braket
suffix:semicolon
)brace
multiline_comment|/* clear all return codes (no chaining!)                    */
id|a
op_member_access_from_pointer
id|ram_out
c_func
(paren
id|a
comma
op_amp
id|PR_RAM-&gt;RcOutput
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* call output function                                     */
id|pr_out
c_func
(paren
id|a
)paren
suffix:semicolon
)brace
multiline_comment|/* clear RNR flag                                           */
id|RNRId
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* if indications are available ...                         */
r_if
c_cond
(paren
(paren
id|Count
op_assign
id|a
op_member_access_from_pointer
id|ram_in
c_func
(paren
id|a
comma
op_amp
id|PR_RAM-&gt;IndOutput
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|dtrc
c_func
(paren
id|dprintf
c_func
(paren
l_string|&quot;#Ind=%x&quot;
comma
id|Count
)paren
)paren
suffix:semicolon
multiline_comment|/* get the buffer address of the first indication           */
id|IndIn
op_assign
(paren
id|IND
op_star
)paren
op_amp
id|PR_RAM-&gt;B
(braket
id|a
op_member_access_from_pointer
id|ram_inw
c_func
(paren
id|a
comma
op_amp
id|PR_RAM-&gt;NextInd
)paren
)braket
suffix:semicolon
multiline_comment|/* for all indications do ...                               */
r_while
c_loop
(paren
id|Count
op_decrement
)paren
(brace
multiline_comment|/* if the application marks an indication as RNR, all       */
multiline_comment|/* indications from the same Id delivered in this interrupt */
multiline_comment|/* are marked RNR                                           */
r_if
c_cond
(paren
id|RNRId
op_logical_and
id|RNRId
op_eq
id|a
op_member_access_from_pointer
id|ram_in
c_func
(paren
id|a
comma
op_amp
id|IndIn-&gt;IndId
)paren
)paren
(brace
id|a
op_member_access_from_pointer
id|ram_out
c_func
(paren
id|a
comma
op_amp
id|IndIn-&gt;Ind
comma
l_int|0
)paren
suffix:semicolon
id|a
op_member_access_from_pointer
id|ram_out
c_func
(paren
id|a
comma
op_amp
id|IndIn-&gt;RNR
comma
id|TRUE
)paren
suffix:semicolon
)brace
r_else
(brace
id|Ind
op_assign
id|a
op_member_access_from_pointer
id|ram_in
c_func
(paren
id|a
comma
op_amp
id|IndIn-&gt;Ind
)paren
suffix:semicolon
r_if
c_cond
(paren
id|Ind
)paren
(brace
id|RNRId
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* call indication handler, a return value of 2 means chain */
multiline_comment|/* a return value of 1 means RNR                            */
multiline_comment|/* for all indications we process, we clear the Ind field   */
id|c
op_assign
id|isdn_ind
c_func
(paren
id|a
comma
id|Ind
comma
id|a
op_member_access_from_pointer
id|ram_in
c_func
(paren
id|a
comma
op_amp
id|IndIn-&gt;IndId
)paren
comma
id|a
op_member_access_from_pointer
id|ram_in
c_func
(paren
id|a
comma
op_amp
id|IndIn-&gt;IndCh
)paren
comma
op_amp
id|IndIn-&gt;RBuffer
comma
id|a
op_member_access_from_pointer
id|ram_in
c_func
(paren
id|a
comma
op_amp
id|IndIn-&gt;MInd
)paren
comma
id|a
op_member_access_from_pointer
id|ram_inw
c_func
(paren
id|a
comma
op_amp
id|IndIn-&gt;MLength
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
l_int|1
)paren
(brace
id|dtrc
c_func
(paren
id|dprintf
c_func
(paren
l_string|&quot;RNR&quot;
)paren
)paren
suffix:semicolon
id|a
op_member_access_from_pointer
id|ram_out
c_func
(paren
id|a
comma
op_amp
id|IndIn-&gt;Ind
comma
l_int|0
)paren
suffix:semicolon
id|RNRId
op_assign
id|a
op_member_access_from_pointer
id|ram_in
c_func
(paren
id|a
comma
op_amp
id|IndIn-&gt;IndId
)paren
suffix:semicolon
id|a
op_member_access_from_pointer
id|ram_out
c_func
(paren
id|a
comma
op_amp
id|IndIn-&gt;RNR
comma
id|TRUE
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* get buffer address of next indication                    */
id|IndIn
op_assign
(paren
id|IND
op_star
)paren
op_amp
id|PR_RAM-&gt;B
(braket
id|a
op_member_access_from_pointer
id|ram_inw
c_func
(paren
id|a
comma
op_amp
id|IndIn-&gt;next
)paren
)braket
suffix:semicolon
)brace
id|a
op_member_access_from_pointer
id|ram_out
c_func
(paren
id|a
comma
op_amp
id|PR_RAM-&gt;IndOutput
comma
l_int|0
)paren
suffix:semicolon
)brace
r_return
id|FALSE
suffix:semicolon
)brace
DECL|function|pr_test_int
id|byte
id|pr_test_int
c_func
(paren
id|ADAPTER
op_star
id|a
)paren
(brace
r_return
id|a
op_member_access_from_pointer
id|ram_in
c_func
(paren
id|a
comma
(paren
r_void
op_star
)paren
l_int|0x3ffc
)paren
suffix:semicolon
)brace
DECL|function|pr_clear_int
r_void
id|pr_clear_int
c_func
(paren
id|ADAPTER
op_star
id|a
)paren
(brace
id|a
op_member_access_from_pointer
id|ram_out
c_func
(paren
id|a
comma
(paren
r_void
op_star
)paren
l_int|0x3ffc
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/* output function                                                  */
multiline_comment|/*------------------------------------------------------------------*/
DECL|function|scom_out
r_void
id|scom_out
c_func
(paren
id|ADAPTER
op_star
id|a
)paren
(brace
id|byte
id|e_no
suffix:semicolon
id|ENTITY
op_star
id|this
suffix:semicolon
id|BUFFERS
op_star
id|X
suffix:semicolon
id|word
id|length
suffix:semicolon
id|word
id|i
suffix:semicolon
id|word
id|clength
suffix:semicolon
id|byte
id|more
suffix:semicolon
id|byte
id|Id
suffix:semicolon
id|dtrc
c_func
(paren
id|dprintf
c_func
(paren
l_string|&quot;scom_out&quot;
)paren
)paren
suffix:semicolon
multiline_comment|/* check if the adapter is ready to accept an request:      */
id|e_no
op_assign
id|look_req
c_func
(paren
id|a
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|e_no
)paren
(brace
id|dtrc
c_func
(paren
id|dprintf
c_func
(paren
l_string|&quot;no_req&quot;
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|scom_ready
c_func
(paren
id|a
)paren
)paren
(brace
id|dtrc
c_func
(paren
id|dprintf
c_func
(paren
l_string|&quot;not_ready&quot;
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|this
op_assign
id|entity_ptr
c_func
(paren
id|a
comma
id|e_no
)paren
suffix:semicolon
id|dtrc
c_func
(paren
id|dprintf
c_func
(paren
l_string|&quot;out:Req=%x,Id=%x,Ch=%x&quot;
comma
id|this-&gt;Req
comma
id|this-&gt;Id
comma
id|this-&gt;ReqCh
)paren
)paren
suffix:semicolon
id|next_req
c_func
(paren
id|a
)paren
suffix:semicolon
multiline_comment|/* now copy the data from the current data buffer into the  */
multiline_comment|/* adapters request buffer                                  */
id|length
op_assign
l_int|0
suffix:semicolon
id|i
op_assign
id|this-&gt;XCurrent
suffix:semicolon
id|X
op_assign
id|PTR_X
c_func
(paren
id|a
comma
id|this
)paren
suffix:semicolon
r_while
c_loop
(paren
id|i
OL
id|this-&gt;XNum
op_logical_and
id|length
OL
l_int|270
)paren
(brace
id|clength
op_assign
id|MIN
c_func
(paren
(paren
id|word
)paren
(paren
l_int|270
op_minus
id|length
)paren
comma
id|X
(braket
id|i
)braket
dot
id|PLength
op_minus
id|this-&gt;XOffset
)paren
suffix:semicolon
id|a
op_member_access_from_pointer
id|ram_out_buffer
c_func
(paren
id|a
comma
op_amp
id|RAM-&gt;XBuffer.P
(braket
id|length
)braket
comma
id|PTR_P
c_func
(paren
id|a
comma
id|this
comma
op_amp
id|X
(braket
id|i
)braket
dot
id|P
(braket
id|this-&gt;XOffset
)braket
)paren
comma
id|clength
)paren
suffix:semicolon
id|length
op_add_assign
id|clength
suffix:semicolon
id|this-&gt;XOffset
op_add_assign
id|clength
suffix:semicolon
r_if
c_cond
(paren
id|this-&gt;XOffset
op_eq
id|X
(braket
id|i
)braket
dot
id|PLength
)paren
(brace
id|this-&gt;XCurrent
op_assign
(paren
id|byte
)paren
op_increment
id|i
suffix:semicolon
id|this-&gt;XOffset
op_assign
l_int|0
suffix:semicolon
)brace
)brace
id|a
op_member_access_from_pointer
id|ram_outw
c_func
(paren
id|a
comma
op_amp
id|RAM-&gt;XBuffer.length
comma
id|length
)paren
suffix:semicolon
id|a
op_member_access_from_pointer
id|ram_out
c_func
(paren
id|a
comma
op_amp
id|RAM-&gt;ReqId
comma
id|this-&gt;Id
)paren
suffix:semicolon
id|a
op_member_access_from_pointer
id|ram_out
c_func
(paren
id|a
comma
op_amp
id|RAM-&gt;ReqCh
comma
id|this-&gt;ReqCh
)paren
suffix:semicolon
multiline_comment|/* if it&squot;s a specific request (no ASSIGN) ...                */
r_if
c_cond
(paren
id|this-&gt;Id
op_amp
l_int|0x1f
)paren
(brace
multiline_comment|/* if buffers are left in the list of data buffers do       */
multiline_comment|/* chaining (LL_MDATA, N_MDATA)                             */
id|this-&gt;More
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|i
OL
id|this-&gt;XNum
op_logical_and
id|this-&gt;MInd
)paren
(brace
id|a
op_member_access_from_pointer
id|ram_out
c_func
(paren
id|a
comma
op_amp
id|RAM-&gt;Req
comma
id|this-&gt;MInd
)paren
suffix:semicolon
id|more
op_assign
id|TRUE
suffix:semicolon
)brace
r_else
(brace
id|this-&gt;More
op_or_assign
id|XMOREF
suffix:semicolon
id|a
op_member_access_from_pointer
id|ram_out
c_func
(paren
id|a
comma
op_amp
id|RAM-&gt;Req
comma
id|this-&gt;Req
)paren
suffix:semicolon
id|more
op_assign
id|FALSE
suffix:semicolon
r_if
c_cond
(paren
id|a-&gt;FlowControlIdTable
(braket
id|this-&gt;ReqCh
)braket
op_eq
id|this-&gt;Id
)paren
id|a-&gt;FlowControlSkipTable
(braket
id|this-&gt;ReqCh
)braket
op_assign
id|TRUE
suffix:semicolon
multiline_comment|/*&n;         Note that remove request was sent to the card&n;         */
r_if
c_cond
(paren
id|this-&gt;Req
op_eq
id|REMOVE
)paren
(brace
id|a-&gt;misc_flags_table
(braket
id|e_no
)braket
op_or_assign
id|DIVA_MISC_FLAGS_REMOVE_PENDING
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|more
)paren
(brace
id|req_queue
c_func
(paren
id|a
comma
id|this-&gt;No
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* else it&squot;s a ASSIGN                                       */
r_else
(brace
multiline_comment|/* save the request code used for buffer chaining           */
id|this-&gt;MInd
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|this-&gt;Id
op_eq
id|BLLC_ID
)paren
id|this-&gt;MInd
op_assign
id|LL_MDATA
suffix:semicolon
r_if
c_cond
(paren
id|this-&gt;Id
op_eq
id|NL_ID
op_logical_or
id|this-&gt;Id
op_eq
id|TASK_ID
op_logical_or
id|this-&gt;Id
op_eq
id|MAN_ID
)paren
id|this-&gt;MInd
op_assign
id|N_MDATA
suffix:semicolon
multiline_comment|/* send the ASSIGN                                          */
id|this-&gt;More
op_or_assign
id|XMOREF
suffix:semicolon
id|a
op_member_access_from_pointer
id|ram_out
c_func
(paren
id|a
comma
op_amp
id|RAM-&gt;Req
comma
id|this-&gt;Req
)paren
suffix:semicolon
multiline_comment|/* save the reference of the ASSIGN                         */
id|assign_queue
c_func
(paren
id|a
comma
id|this-&gt;No
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* if it is a &squot;unreturncoded&squot; UREMOVE request, remove the  */
multiline_comment|/* Id from our table after sending the request             */
r_if
c_cond
(paren
id|this-&gt;Req
op_eq
id|UREMOVE
op_logical_and
id|this-&gt;Id
)paren
(brace
id|Id
op_assign
id|this-&gt;Id
suffix:semicolon
id|e_no
op_assign
id|a-&gt;IdTable
(braket
id|Id
)braket
suffix:semicolon
id|free_entity
c_func
(paren
id|a
comma
id|e_no
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|256
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|a-&gt;FlowControlIdTable
(braket
id|i
)braket
op_eq
id|Id
)paren
id|a-&gt;FlowControlIdTable
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
)brace
id|a-&gt;IdTable
(braket
id|Id
)braket
op_assign
l_int|0
suffix:semicolon
id|this-&gt;Id
op_assign
l_int|0
suffix:semicolon
)brace
)brace
DECL|function|scom_ready
r_static
id|byte
id|scom_ready
c_func
(paren
id|ADAPTER
op_star
id|a
)paren
(brace
r_if
c_cond
(paren
id|a
op_member_access_from_pointer
id|ram_in
c_func
(paren
id|a
comma
op_amp
id|RAM-&gt;Req
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|a-&gt;ReadyInt
)paren
(brace
id|a
op_member_access_from_pointer
id|ram_inc
c_func
(paren
id|a
comma
op_amp
id|RAM-&gt;ReadyInt
)paren
suffix:semicolon
id|a-&gt;ReadyInt
op_increment
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/* isdn interrupt handler                                           */
multiline_comment|/*------------------------------------------------------------------*/
DECL|function|scom_dpc
id|byte
id|scom_dpc
c_func
(paren
id|ADAPTER
op_star
id|a
)paren
(brace
id|byte
id|c
suffix:semicolon
multiline_comment|/* if a return code is available ...                        */
r_if
c_cond
(paren
id|a
op_member_access_from_pointer
id|ram_in
c_func
(paren
id|a
comma
op_amp
id|RAM-&gt;Rc
)paren
)paren
(brace
multiline_comment|/* call return code handler, if it is not our return code   */
multiline_comment|/* the handler returns 2, if it&squot;s the return code to an     */
multiline_comment|/* ASSIGN the handler returns 1                             */
id|c
op_assign
id|isdn_rc
c_func
(paren
id|a
comma
id|a
op_member_access_from_pointer
id|ram_in
c_func
(paren
id|a
comma
op_amp
id|RAM-&gt;Rc
)paren
comma
id|a
op_member_access_from_pointer
id|ram_in
c_func
(paren
id|a
comma
op_amp
id|RAM-&gt;RcId
)paren
comma
id|a
op_member_access_from_pointer
id|ram_in
c_func
(paren
id|a
comma
op_amp
id|RAM-&gt;RcCh
)paren
comma
l_int|0
comma
multiline_comment|/*&n;                  Scom Card does not provide extended information&n;                  */
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|c
)paren
(brace
r_case
l_int|0
suffix:colon
id|a
op_member_access_from_pointer
id|ram_out
c_func
(paren
id|a
comma
op_amp
id|RAM-&gt;Rc
comma
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|a
op_member_access_from_pointer
id|ram_out
c_func
(paren
id|a
comma
op_amp
id|RAM-&gt;Req
comma
l_int|0
)paren
suffix:semicolon
id|a
op_member_access_from_pointer
id|ram_out
c_func
(paren
id|a
comma
op_amp
id|RAM-&gt;Rc
comma
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
r_return
id|TRUE
suffix:semicolon
)brace
multiline_comment|/* call output function                                     */
id|scom_out
c_func
(paren
id|a
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* if an indications is available ...                       */
r_if
c_cond
(paren
id|a
op_member_access_from_pointer
id|ram_in
c_func
(paren
id|a
comma
op_amp
id|RAM-&gt;Ind
)paren
)paren
(brace
multiline_comment|/* call indication handler, a return value of 2 means chain */
multiline_comment|/* a return value of 1 means RNR                            */
id|c
op_assign
id|isdn_ind
c_func
(paren
id|a
comma
id|a
op_member_access_from_pointer
id|ram_in
c_func
(paren
id|a
comma
op_amp
id|RAM-&gt;Ind
)paren
comma
id|a
op_member_access_from_pointer
id|ram_in
c_func
(paren
id|a
comma
op_amp
id|RAM-&gt;IndId
)paren
comma
id|a
op_member_access_from_pointer
id|ram_in
c_func
(paren
id|a
comma
op_amp
id|RAM-&gt;IndCh
)paren
comma
op_amp
id|RAM-&gt;RBuffer
comma
id|a
op_member_access_from_pointer
id|ram_in
c_func
(paren
id|a
comma
op_amp
id|RAM-&gt;MInd
)paren
comma
id|a
op_member_access_from_pointer
id|ram_inw
c_func
(paren
id|a
comma
op_amp
id|RAM-&gt;MLength
)paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|c
)paren
(brace
r_case
l_int|0
suffix:colon
id|a
op_member_access_from_pointer
id|ram_out
c_func
(paren
id|a
comma
op_amp
id|RAM-&gt;Ind
comma
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|dtrc
c_func
(paren
id|dprintf
c_func
(paren
l_string|&quot;RNR&quot;
)paren
)paren
suffix:semicolon
id|a
op_member_access_from_pointer
id|ram_out
c_func
(paren
id|a
comma
op_amp
id|RAM-&gt;RNR
comma
id|TRUE
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
r_return
id|TRUE
suffix:semicolon
)brace
)brace
)brace
r_return
id|FALSE
suffix:semicolon
)brace
DECL|function|scom_test_int
id|byte
id|scom_test_int
c_func
(paren
id|ADAPTER
op_star
id|a
)paren
(brace
r_return
id|a
op_member_access_from_pointer
id|ram_in
c_func
(paren
id|a
comma
(paren
r_void
op_star
)paren
l_int|0x3fe
)paren
suffix:semicolon
)brace
DECL|function|scom_clear_int
r_void
id|scom_clear_int
c_func
(paren
id|ADAPTER
op_star
id|a
)paren
(brace
id|a
op_member_access_from_pointer
id|ram_out
c_func
(paren
id|a
comma
(paren
r_void
op_star
)paren
l_int|0x3fe
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|quadro_clear_int
r_void
id|quadro_clear_int
c_func
(paren
id|ADAPTER
op_star
id|a
)paren
(brace
id|a
op_member_access_from_pointer
id|ram_out
c_func
(paren
id|a
comma
(paren
r_void
op_star
)paren
l_int|0x3fe
comma
l_int|0
)paren
suffix:semicolon
id|a
op_member_access_from_pointer
id|ram_out
c_func
(paren
id|a
comma
(paren
r_void
op_star
)paren
l_int|0x401
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/* return code handler                                              */
multiline_comment|/*------------------------------------------------------------------*/
DECL|function|isdn_rc
id|byte
id|isdn_rc
c_func
(paren
id|ADAPTER
op_star
id|a
comma
id|byte
id|Rc
comma
id|byte
id|Id
comma
id|byte
id|Ch
comma
id|word
id|Ref
comma
id|dword
id|extended_info_type
comma
id|dword
id|extended_info
)paren
(brace
id|ENTITY
op_star
id|this
suffix:semicolon
id|byte
id|e_no
suffix:semicolon
id|word
id|i
suffix:semicolon
r_int
id|cancel_rc
suffix:semicolon
macro_line|#ifdef USE_EXTENDED_DEBUGS
(brace
id|DBG_TRC
c_func
(paren
(paren
l_string|&quot;&lt;A%d Id=0x%x Rc=0x%x&quot;
comma
(paren
(paren
id|ISDN_ADAPTER
op_star
)paren
id|a-&gt;io
)paren
op_member_access_from_pointer
id|ANum
comma
id|Id
comma
id|Rc
)paren
)paren
)brace
macro_line|#else
id|dbug
c_func
(paren
id|dprintf
c_func
(paren
l_string|&quot;isdn_rc(Rc=%x,Id=%x,Ch=%x)&quot;
comma
id|Rc
comma
id|Id
comma
id|Ch
)paren
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* check for ready interrupt                                */
r_if
c_cond
(paren
id|Rc
op_eq
id|READY_INT
)paren
(brace
id|xdi_xlog_rc_event
(paren
id|XDI_A_NR
c_func
(paren
id|a
)paren
comma
id|Id
comma
id|Ch
comma
id|Rc
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|a-&gt;ReadyInt
)paren
(brace
id|a-&gt;ReadyInt
op_decrement
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
l_int|2
suffix:semicolon
)brace
multiline_comment|/* if we know this Id ...                                   */
id|e_no
op_assign
id|a-&gt;IdTable
(braket
id|Id
)braket
suffix:semicolon
r_if
c_cond
(paren
id|e_no
)paren
(brace
id|this
op_assign
id|entity_ptr
c_func
(paren
id|a
comma
id|e_no
)paren
suffix:semicolon
id|xdi_xlog_rc_event
(paren
id|XDI_A_NR
c_func
(paren
id|a
)paren
comma
id|Id
comma
id|Ch
comma
id|Rc
comma
l_int|0
comma
id|a-&gt;IdTypeTable
(braket
id|this-&gt;No
)braket
)paren
suffix:semicolon
id|this-&gt;RcCh
op_assign
id|Ch
suffix:semicolon
multiline_comment|/* if it is a return code to a REMOVE request, remove the   */
multiline_comment|/* Id from our table                                        */
r_if
c_cond
(paren
(paren
id|a-&gt;misc_flags_table
(braket
id|e_no
)braket
op_amp
id|DIVA_MISC_FLAGS_REMOVE_PENDING
)paren
op_logical_and
(paren
id|Rc
op_eq
id|OK
)paren
)paren
(brace
r_if
c_cond
(paren
id|a-&gt;IdTypeTable
(braket
id|e_no
)braket
op_eq
id|NL_ID
)paren
(brace
r_if
c_cond
(paren
id|a-&gt;RcExtensionSupported
op_logical_and
(paren
id|extended_info_type
op_ne
id|DIVA_RC_TYPE_REMOVE_COMPLETE
)paren
)paren
(brace
id|dtrc
c_func
(paren
id|dprintf
c_func
(paren
l_string|&quot;XDI: N-REMOVE, A(%02x) Id:%02x, ignore RC=OK&quot;
comma
id|XDI_A_NR
c_func
(paren
id|a
)paren
comma
id|Id
)paren
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|extended_info_type
op_eq
id|DIVA_RC_TYPE_REMOVE_COMPLETE
)paren
id|a-&gt;RcExtensionSupported
op_assign
id|TRUE
suffix:semicolon
)brace
id|a-&gt;misc_flags_table
(braket
id|e_no
)braket
op_and_assign
op_complement
id|DIVA_MISC_FLAGS_REMOVE_PENDING
suffix:semicolon
id|a-&gt;misc_flags_table
(braket
id|e_no
)braket
op_and_assign
op_complement
id|DIVA_MISC_FLAGS_NO_RC_CANCELLING
suffix:semicolon
id|free_entity
c_func
(paren
id|a
comma
id|e_no
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|256
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|a-&gt;FlowControlIdTable
(braket
id|i
)braket
op_eq
id|Id
)paren
id|a-&gt;FlowControlIdTable
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
)brace
id|a-&gt;IdTable
(braket
id|Id
)braket
op_assign
l_int|0
suffix:semicolon
id|this-&gt;Id
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* ---------------------------------------------------------------&n;        If we send N_DISC or N_DISK_ACK after we have received OK_FC&n;        then the card will respond with OK_FC and later with RC==OK.&n;        If we send N_REMOVE in this state we will receive only RC==OK&n;        This will create the state in that the XDI is waiting for the&n;        additional RC and does not delivery the RC to the client. This&n;        code corrects the counter of outstanding RC&squot;s in this case.&n;      --------------------------------------------------------------- */
r_if
c_cond
(paren
(paren
id|this-&gt;More
op_amp
id|XMOREC
)paren
OG
l_int|1
)paren
(brace
id|this-&gt;More
op_and_assign
op_complement
id|XMOREC
suffix:semicolon
id|this-&gt;More
op_or_assign
l_int|1
suffix:semicolon
id|dtrc
c_func
(paren
id|dprintf
c_func
(paren
l_string|&quot;XDI: correct MORE on REMOVE A(%02x) Id:%02x&quot;
comma
id|XDI_A_NR
c_func
(paren
id|a
)paren
comma
id|Id
)paren
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|Rc
op_eq
id|OK_FC
)paren
(brace
id|a-&gt;FlowControlIdTable
(braket
id|Ch
)braket
op_assign
id|Id
suffix:semicolon
id|a-&gt;FlowControlSkipTable
(braket
id|Ch
)braket
op_assign
id|FALSE
suffix:semicolon
id|this-&gt;Rc
op_assign
id|Rc
suffix:semicolon
id|this-&gt;More
op_and_assign
op_complement
(paren
id|XBUSY
op_or
id|XMOREC
)paren
suffix:semicolon
id|this-&gt;complete
op_assign
l_int|0xff
suffix:semicolon
id|xdi_xlog_rc_event
(paren
id|XDI_A_NR
c_func
(paren
id|a
)paren
comma
id|Id
comma
id|Ch
comma
id|Rc
comma
l_int|1
comma
id|a-&gt;IdTypeTable
(braket
id|this-&gt;No
)braket
)paren
suffix:semicolon
id|CALLBACK
c_func
(paren
id|a
comma
id|this
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;      New protocol code sends return codes that comes from release&n;      of flow control condition marked with DIVA_RC_TYPE_OK_FC extended&n;      information element type.&n;      If like return code arrives then application is able to process&n;      all return codes self and XDI should not cances return codes.&n;      This return code does not decrement XMOREC partial return code&n;      counter due to fact that it was no request for this return code,&n;      also XMOREC was not incremented.&n;      */
r_if
c_cond
(paren
id|extended_info_type
op_eq
id|DIVA_RC_TYPE_OK_FC
)paren
(brace
id|a-&gt;misc_flags_table
(braket
id|e_no
)braket
op_or_assign
id|DIVA_MISC_FLAGS_NO_RC_CANCELLING
suffix:semicolon
id|this-&gt;Rc
op_assign
id|Rc
suffix:semicolon
id|this-&gt;complete
op_assign
l_int|0xff
suffix:semicolon
id|xdi_xlog_rc_event
(paren
id|XDI_A_NR
c_func
(paren
id|a
)paren
comma
id|Id
comma
id|Ch
comma
id|Rc
comma
l_int|1
comma
id|a-&gt;IdTypeTable
(braket
id|this-&gt;No
)braket
)paren
suffix:semicolon
id|DBG_TRC
c_func
(paren
(paren
l_string|&quot;XDI OK_FC A(%02x) Id:%02x Ch:%02x Rc:%02x&quot;
comma
id|XDI_A_NR
c_func
(paren
id|a
)paren
comma
id|Id
comma
id|Ch
comma
id|Rc
)paren
)paren
id|CALLBACK
c_func
(paren
id|a
comma
id|this
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|cancel_rc
op_assign
op_logical_neg
(paren
id|a-&gt;misc_flags_table
(braket
id|e_no
)braket
op_amp
id|DIVA_MISC_FLAGS_NO_RC_CANCELLING
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cancel_rc
op_logical_and
(paren
id|a-&gt;FlowControlIdTable
(braket
id|Ch
)braket
op_eq
id|Id
)paren
)paren
(brace
id|a-&gt;FlowControlIdTable
(braket
id|Ch
)braket
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|Rc
op_ne
id|OK
)paren
op_logical_or
op_logical_neg
id|a-&gt;FlowControlSkipTable
(braket
id|Ch
)braket
)paren
(brace
id|this-&gt;Rc
op_assign
id|Rc
suffix:semicolon
r_if
c_cond
(paren
id|Ch
op_eq
id|this-&gt;ReqCh
)paren
(brace
id|this-&gt;More
op_and_assign
op_complement
(paren
id|XBUSY
op_or
id|XMOREC
)paren
suffix:semicolon
id|this-&gt;complete
op_assign
l_int|0xff
suffix:semicolon
)brace
id|xdi_xlog_rc_event
(paren
id|XDI_A_NR
c_func
(paren
id|a
)paren
comma
id|Id
comma
id|Ch
comma
id|Rc
comma
l_int|1
comma
id|a-&gt;IdTypeTable
(braket
id|this-&gt;No
)braket
)paren
suffix:semicolon
id|CALLBACK
c_func
(paren
id|a
comma
id|this
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|this-&gt;More
op_amp
id|XMOREC
)paren
id|this-&gt;More
op_decrement
suffix:semicolon
multiline_comment|/* call the application callback function                   */
r_if
c_cond
(paren
(paren
(paren
op_logical_neg
id|cancel_rc
)paren
op_logical_or
(paren
id|this-&gt;More
op_amp
id|XMOREF
)paren
)paren
op_logical_and
op_logical_neg
(paren
id|this-&gt;More
op_amp
id|XMOREC
)paren
)paren
(brace
id|this-&gt;Rc
op_assign
id|Rc
suffix:semicolon
id|this-&gt;More
op_and_assign
op_complement
id|XBUSY
suffix:semicolon
id|this-&gt;complete
op_assign
l_int|0xff
suffix:semicolon
id|xdi_xlog_rc_event
(paren
id|XDI_A_NR
c_func
(paren
id|a
)paren
comma
id|Id
comma
id|Ch
comma
id|Rc
comma
l_int|1
comma
id|a-&gt;IdTypeTable
(braket
id|this-&gt;No
)braket
)paren
suffix:semicolon
id|CALLBACK
c_func
(paren
id|a
comma
id|this
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* if it&squot;s an ASSIGN return code check if it&squot;s a return     */
multiline_comment|/* code to an ASSIGN request from us                        */
r_if
c_cond
(paren
(paren
id|Rc
op_amp
l_int|0xf0
)paren
op_eq
id|ASSIGN_RC
)paren
(brace
id|e_no
op_assign
id|get_assign
c_func
(paren
id|a
comma
id|Ref
)paren
suffix:semicolon
r_if
c_cond
(paren
id|e_no
)paren
(brace
id|this
op_assign
id|entity_ptr
c_func
(paren
id|a
comma
id|e_no
)paren
suffix:semicolon
id|this-&gt;Id
op_assign
id|Id
suffix:semicolon
id|xdi_xlog_rc_event
(paren
id|XDI_A_NR
c_func
(paren
id|a
)paren
comma
id|Id
comma
id|Ch
comma
id|Rc
comma
l_int|2
comma
id|a-&gt;IdTypeTable
(braket
id|this-&gt;No
)braket
)paren
suffix:semicolon
multiline_comment|/* call the application callback function                   */
id|this-&gt;Rc
op_assign
id|Rc
suffix:semicolon
id|this-&gt;More
op_and_assign
op_complement
id|XBUSY
suffix:semicolon
id|this-&gt;complete
op_assign
l_int|0xff
suffix:semicolon
macro_line|#if defined(DIVA_ISTREAM) /* { */
r_if
c_cond
(paren
(paren
id|Rc
op_eq
id|ASSIGN_OK
)paren
op_logical_and
id|a-&gt;ram_offset
op_logical_and
(paren
id|a-&gt;IdTypeTable
(braket
id|this-&gt;No
)braket
op_eq
id|NL_ID
)paren
op_logical_and
(paren
(paren
id|extended_info_type
op_eq
id|DIVA_RC_TYPE_RX_DMA
)paren
op_logical_or
(paren
id|extended_info_type
op_eq
id|DIVA_RC_TYPE_CMA_PTR
)paren
)paren
op_logical_and
id|extended_info
)paren
(brace
id|dword
id|offset
op_assign
(paren
op_star
(paren
id|a-&gt;ram_offset
)paren
)paren
(paren
id|a
)paren
suffix:semicolon
id|dword
id|tmp
(braket
l_int|2
)braket
suffix:semicolon
id|extended_info
op_sub_assign
id|offset
suffix:semicolon
macro_line|#ifdef PLATFORM_GT_32BIT
id|a
op_member_access_from_pointer
id|ram_in_dw
c_func
(paren
id|a
comma
(paren
r_void
op_star
)paren
id|ULongToPtr
c_func
(paren
id|extended_info
)paren
comma
(paren
id|dword
op_star
)paren
op_amp
id|tmp
(braket
l_int|0
)braket
comma
l_int|2
)paren
suffix:semicolon
macro_line|#else
id|a
op_member_access_from_pointer
id|ram_in_dw
c_func
(paren
id|a
comma
(paren
r_void
op_star
)paren
id|extended_info
comma
(paren
id|dword
op_star
)paren
op_amp
id|tmp
(braket
l_int|0
)braket
comma
l_int|2
)paren
suffix:semicolon
macro_line|#endif
id|a-&gt;tx_stream
(braket
id|Id
)braket
op_assign
id|tmp
(braket
l_int|0
)braket
suffix:semicolon
id|a-&gt;rx_stream
(braket
id|Id
)braket
op_assign
id|tmp
(braket
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
id|extended_info_type
op_eq
id|DIVA_RC_TYPE_RX_DMA
)paren
(brace
id|DBG_TRC
c_func
(paren
(paren
l_string|&quot;Id=0x%x RxDMA=%08x:%08x&quot;
comma
id|Id
comma
id|a-&gt;tx_stream
(braket
id|Id
)braket
comma
id|a-&gt;rx_stream
(braket
id|Id
)braket
)paren
)paren
id|a-&gt;misc_flags_table
(braket
id|this-&gt;No
)braket
op_or_assign
id|DIVA_MISC_FLAGS_RX_DMA
suffix:semicolon
)brace
r_else
(brace
id|DBG_TRC
c_func
(paren
(paren
l_string|&quot;Id=0x%x CMA=%08x:%08x&quot;
comma
id|Id
comma
id|a-&gt;tx_stream
(braket
id|Id
)braket
comma
id|a-&gt;rx_stream
(braket
id|Id
)braket
)paren
)paren
id|a-&gt;misc_flags_table
(braket
id|this-&gt;No
)braket
op_and_assign
op_complement
id|DIVA_MISC_FLAGS_RX_DMA
suffix:semicolon
id|a-&gt;rx_pos
(braket
id|Id
)braket
op_assign
l_int|0
suffix:semicolon
id|a-&gt;rx_stream
(braket
id|Id
)braket
op_sub_assign
id|offset
suffix:semicolon
)brace
id|a-&gt;tx_pos
(braket
id|Id
)braket
op_assign
l_int|0
suffix:semicolon
id|a-&gt;tx_stream
(braket
id|Id
)braket
op_sub_assign
id|offset
suffix:semicolon
)brace
r_else
(brace
id|a-&gt;tx_stream
(braket
id|Id
)braket
op_assign
l_int|0
suffix:semicolon
id|a-&gt;rx_stream
(braket
id|Id
)braket
op_assign
l_int|0
suffix:semicolon
id|a-&gt;misc_flags_table
(braket
id|this-&gt;No
)braket
op_and_assign
op_complement
id|DIVA_MISC_FLAGS_RX_DMA
suffix:semicolon
)brace
macro_line|#endif /* } */
id|CALLBACK
c_func
(paren
id|a
comma
id|this
)paren
suffix:semicolon
r_if
c_cond
(paren
id|Rc
op_eq
id|ASSIGN_OK
)paren
(brace
id|a-&gt;IdTable
(braket
id|Id
)braket
op_assign
id|e_no
suffix:semicolon
)brace
r_else
(brace
id|free_entity
c_func
(paren
id|a
comma
id|e_no
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|256
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|a-&gt;FlowControlIdTable
(braket
id|i
)braket
op_eq
id|Id
)paren
id|a-&gt;FlowControlIdTable
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
)brace
id|a-&gt;IdTable
(braket
id|Id
)braket
op_assign
l_int|0
suffix:semicolon
id|this-&gt;Id
op_assign
l_int|0
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
)brace
r_return
l_int|2
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/* indication handler                                               */
multiline_comment|/*------------------------------------------------------------------*/
DECL|function|isdn_ind
id|byte
id|isdn_ind
c_func
(paren
id|ADAPTER
op_star
id|a
comma
id|byte
id|Ind
comma
id|byte
id|Id
comma
id|byte
id|Ch
comma
id|PBUFFER
op_star
id|RBuffer
comma
id|byte
id|MInd
comma
id|word
id|MLength
)paren
(brace
id|ENTITY
op_star
id|this
suffix:semicolon
id|word
id|clength
suffix:semicolon
id|word
id|offset
suffix:semicolon
id|BUFFERS
op_star
id|R
suffix:semicolon
id|byte
op_star
id|cma
op_assign
l_int|NULL
suffix:semicolon
macro_line|#ifdef USE_EXTENDED_DEBUGS
(brace
id|DBG_TRC
c_func
(paren
(paren
l_string|&quot;&lt;A%d Id=0x%x Ind=0x%x&quot;
comma
(paren
(paren
id|ISDN_ADAPTER
op_star
)paren
id|a-&gt;io
)paren
op_member_access_from_pointer
id|ANum
comma
id|Id
comma
id|Ind
)paren
)paren
)brace
macro_line|#else
id|dbug
c_func
(paren
id|dprintf
c_func
(paren
l_string|&quot;isdn_ind(Ind=%x,Id=%x,Ch=%x)&quot;
comma
id|Ind
comma
id|Id
comma
id|Ch
)paren
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|a-&gt;IdTable
(braket
id|Id
)braket
)paren
(brace
id|this
op_assign
id|entity_ptr
c_func
(paren
id|a
comma
id|a-&gt;IdTable
(braket
id|Id
)braket
)paren
suffix:semicolon
id|this-&gt;IndCh
op_assign
id|Ch
suffix:semicolon
id|xdi_xlog_ind
(paren
id|XDI_A_NR
c_func
(paren
id|a
)paren
comma
id|Id
comma
id|Ch
comma
id|Ind
comma
l_int|0
multiline_comment|/* rnr_valid */
comma
l_int|0
multiline_comment|/* rnr */
comma
id|a-&gt;IdTypeTable
(braket
id|this-&gt;No
)braket
)paren
suffix:semicolon
multiline_comment|/* if the Receive More flag is not yet set, this is the     */
multiline_comment|/* first buffer of the packet                               */
r_if
c_cond
(paren
id|this-&gt;RCurrent
op_eq
l_int|0xff
)paren
(brace
multiline_comment|/* check for receive buffer chaining                        */
r_if
c_cond
(paren
id|Ind
op_eq
id|this-&gt;MInd
)paren
(brace
id|this-&gt;complete
op_assign
l_int|0
suffix:semicolon
id|this-&gt;Ind
op_assign
id|MInd
suffix:semicolon
)brace
r_else
(brace
id|this-&gt;complete
op_assign
l_int|1
suffix:semicolon
id|this-&gt;Ind
op_assign
id|Ind
suffix:semicolon
)brace
multiline_comment|/* call the application callback function for the receive   */
multiline_comment|/* look ahead                                               */
id|this-&gt;RLength
op_assign
id|MLength
suffix:semicolon
macro_line|#if defined(DIVA_ISTREAM)
r_if
c_cond
(paren
(paren
id|a-&gt;rx_stream
(braket
id|this-&gt;Id
)braket
op_logical_or
(paren
id|a-&gt;misc_flags_table
(braket
id|this-&gt;No
)braket
op_amp
id|DIVA_MISC_FLAGS_RX_DMA
)paren
)paren
op_logical_and
(paren
(paren
id|Ind
op_eq
id|N_DATA
)paren
op_logical_or
(paren
id|a-&gt;protocol_capabilities
op_amp
id|PROTCAP_CMA_ALLPR
)paren
)paren
)paren
(brace
id|PISDN_ADAPTER
id|IoAdapter
op_assign
(paren
id|PISDN_ADAPTER
)paren
id|a-&gt;io
suffix:semicolon
r_if
c_cond
(paren
id|a-&gt;misc_flags_table
(braket
id|this-&gt;No
)braket
op_amp
id|DIVA_MISC_FLAGS_RX_DMA
)paren
(brace
macro_line|#if defined(DIVA_IDI_RX_DMA)
id|dword
id|d
suffix:semicolon
id|diva_get_dma_map_entry
(paren
"&bslash;"
(paren
r_struct
id|_diva_dma_map_entry
op_star
)paren
id|IoAdapter-&gt;dma_map
comma
(paren
r_int
)paren
id|a-&gt;rx_stream
(braket
id|this-&gt;Id
)braket
comma
(paren
r_void
op_star
op_star
)paren
op_amp
id|cma
comma
op_amp
id|d
)paren
suffix:semicolon
macro_line|#else
id|cma
op_assign
op_amp
id|a-&gt;stream_buffer
(braket
l_int|0
)braket
suffix:semicolon
id|cma
(braket
l_int|0
)braket
op_assign
id|cma
(braket
l_int|1
)braket
op_assign
id|cma
(braket
l_int|2
)braket
op_assign
id|cma
(braket
l_int|3
)braket
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
id|this-&gt;RLength
op_assign
id|MLength
op_assign
(paren
id|word
)paren
op_star
(paren
id|dword
op_star
)paren
id|cma
suffix:semicolon
id|cma
op_add_assign
l_int|4
suffix:semicolon
)brace
r_else
(brace
r_int
id|final
op_assign
l_int|0
suffix:semicolon
id|cma
op_assign
op_amp
id|a-&gt;stream_buffer
(braket
l_int|0
)braket
suffix:semicolon
id|this-&gt;RLength
op_assign
id|MLength
op_assign
(paren
id|word
)paren
id|diva_istream_read
(paren
id|a
comma
id|Id
comma
id|cma
comma
r_sizeof
(paren
id|a-&gt;stream_buffer
)paren
comma
op_amp
id|final
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
)brace
id|IoAdapter-&gt;RBuffer.length
op_assign
id|MIN
c_func
(paren
id|MLength
comma
l_int|270
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IoAdapter-&gt;RBuffer.length
op_ne
id|MLength
)paren
(brace
id|this-&gt;complete
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|this-&gt;complete
op_assign
l_int|1
suffix:semicolon
)brace
id|memcpy
(paren
id|IoAdapter-&gt;RBuffer.P
comma
id|cma
comma
id|IoAdapter-&gt;RBuffer.length
)paren
suffix:semicolon
id|this-&gt;RBuffer
op_assign
(paren
id|DBUFFER
op_star
)paren
op_amp
id|IoAdapter-&gt;RBuffer
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|cma
)paren
(brace
id|a
op_member_access_from_pointer
id|ram_look_ahead
c_func
(paren
id|a
comma
id|RBuffer
comma
id|this
)paren
suffix:semicolon
)brace
id|this-&gt;RNum
op_assign
l_int|0
suffix:semicolon
id|CALLBACK
c_func
(paren
id|a
comma
id|this
)paren
suffix:semicolon
multiline_comment|/* map entity ptr, selector could be re-mapped by call to   */
multiline_comment|/* IDI from within callback                                 */
id|this
op_assign
id|entity_ptr
c_func
(paren
id|a
comma
id|a-&gt;IdTable
(braket
id|Id
)braket
)paren
suffix:semicolon
id|xdi_xlog_ind
(paren
id|XDI_A_NR
c_func
(paren
id|a
)paren
comma
id|Id
comma
id|Ch
comma
id|Ind
comma
l_int|1
multiline_comment|/* rnr_valid */
comma
id|this-&gt;RNR
multiline_comment|/* rnr */
comma
id|a-&gt;IdTypeTable
(braket
id|this-&gt;No
)braket
)paren
suffix:semicolon
multiline_comment|/* check for RNR                                            */
r_if
c_cond
(paren
id|this-&gt;RNR
op_eq
l_int|1
)paren
(brace
id|this-&gt;RNR
op_assign
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* if no buffers are provided by the application, the       */
multiline_comment|/* application want to copy the data itself including       */
multiline_comment|/* N_MDATA/LL_MDATA chaining                                */
r_if
c_cond
(paren
op_logical_neg
id|this-&gt;RNR
op_logical_and
op_logical_neg
id|this-&gt;RNum
)paren
(brace
id|xdi_xlog_ind
(paren
id|XDI_A_NR
c_func
(paren
id|a
)paren
comma
id|Id
comma
id|Ch
comma
id|Ind
comma
l_int|2
multiline_comment|/* rnr_valid */
comma
l_int|0
multiline_comment|/* rnr */
comma
id|a-&gt;IdTypeTable
(braket
id|this-&gt;No
)braket
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* if there is no RNR, set the More flag                    */
id|this-&gt;RCurrent
op_assign
l_int|0
suffix:semicolon
id|this-&gt;ROffset
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|this-&gt;RNR
op_eq
l_int|2
)paren
(brace
r_if
c_cond
(paren
id|Ind
op_ne
id|this-&gt;MInd
)paren
(brace
id|this-&gt;RCurrent
op_assign
l_int|0xff
suffix:semicolon
id|this-&gt;RNR
op_assign
l_int|0
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* if we have received buffers from the application, copy   */
multiline_comment|/* the data into these buffers                              */
id|offset
op_assign
l_int|0
suffix:semicolon
id|R
op_assign
id|PTR_R
c_func
(paren
id|a
comma
id|this
)paren
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|this-&gt;ROffset
op_eq
id|R
(braket
id|this-&gt;RCurrent
)braket
dot
id|PLength
)paren
(brace
id|this-&gt;ROffset
op_assign
l_int|0
suffix:semicolon
id|this-&gt;RCurrent
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cma
)paren
(brace
id|clength
op_assign
id|MIN
c_func
(paren
id|MLength
comma
id|R
(braket
id|this-&gt;RCurrent
)braket
dot
id|PLength
op_minus
id|this-&gt;ROffset
)paren
suffix:semicolon
)brace
r_else
(brace
id|clength
op_assign
id|MIN
c_func
(paren
id|a
op_member_access_from_pointer
id|ram_inw
c_func
(paren
id|a
comma
op_amp
id|RBuffer-&gt;length
)paren
op_minus
id|offset
comma
id|R
(braket
id|this-&gt;RCurrent
)braket
dot
id|PLength
op_minus
id|this-&gt;ROffset
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|R
(braket
id|this-&gt;RCurrent
)braket
dot
id|P
)paren
(brace
r_if
c_cond
(paren
id|cma
)paren
(brace
id|memcpy
(paren
id|PTR_P
c_func
(paren
id|a
comma
id|this
comma
op_amp
id|R
(braket
id|this-&gt;RCurrent
)braket
dot
id|P
(braket
id|this-&gt;ROffset
)braket
)paren
comma
op_amp
id|cma
(braket
id|offset
)braket
comma
id|clength
)paren
suffix:semicolon
)brace
r_else
(brace
id|a
op_member_access_from_pointer
id|ram_in_buffer
c_func
(paren
id|a
comma
op_amp
id|RBuffer-&gt;P
(braket
id|offset
)braket
comma
id|PTR_P
c_func
(paren
id|a
comma
id|this
comma
op_amp
id|R
(braket
id|this-&gt;RCurrent
)braket
dot
id|P
(braket
id|this-&gt;ROffset
)braket
)paren
comma
id|clength
)paren
suffix:semicolon
)brace
)brace
id|offset
op_add_assign
id|clength
suffix:semicolon
id|this-&gt;ROffset
op_add_assign
id|clength
suffix:semicolon
r_if
c_cond
(paren
id|cma
)paren
(brace
r_if
c_cond
(paren
id|offset
op_ge
id|MLength
)paren
(brace
r_break
suffix:semicolon
)brace
r_continue
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|offset
OL
(paren
id|a
op_member_access_from_pointer
id|ram_inw
c_func
(paren
id|a
comma
op_amp
id|RBuffer-&gt;length
)paren
)paren
)paren
(brace
suffix:semicolon
)brace
multiline_comment|/* if it&squot;s the last buffer of the packet, call the          */
multiline_comment|/* application callback function for the receive complete   */
multiline_comment|/* call                                                     */
r_if
c_cond
(paren
id|Ind
op_ne
id|this-&gt;MInd
)paren
(brace
id|R
(braket
id|this-&gt;RCurrent
)braket
dot
id|PLength
op_assign
id|this-&gt;ROffset
suffix:semicolon
r_if
c_cond
(paren
id|this-&gt;ROffset
)paren
(brace
id|this-&gt;RCurrent
op_increment
suffix:semicolon
)brace
id|this-&gt;RNum
op_assign
id|this-&gt;RCurrent
suffix:semicolon
id|this-&gt;RCurrent
op_assign
l_int|0xff
suffix:semicolon
id|this-&gt;Ind
op_assign
id|Ind
suffix:semicolon
id|this-&gt;complete
op_assign
l_int|2
suffix:semicolon
id|xdi_xlog_ind
(paren
id|XDI_A_NR
c_func
(paren
id|a
)paren
comma
id|Id
comma
id|Ch
comma
id|Ind
comma
l_int|3
multiline_comment|/* rnr_valid */
comma
l_int|0
multiline_comment|/* rnr */
comma
id|a-&gt;IdTypeTable
(braket
id|this-&gt;No
)braket
)paren
suffix:semicolon
id|CALLBACK
c_func
(paren
id|a
comma
id|this
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_return
l_int|2
suffix:semicolon
)brace
multiline_comment|/* -----------------------------------------------------------&n;   This function works in the same way as xlog on the&n;   active board&n;   ----------------------------------------------------------- */
DECL|function|xdi_xlog
r_void
id|xdi_xlog
(paren
id|byte
op_star
id|msg
comma
id|word
id|code
comma
r_int
id|length
)paren
(brace
macro_line|#if defined(XDI_USE_XLOG)
id|xdi_dbg_xlog
(paren
l_string|&quot;&bslash;x00&bslash;x02&quot;
comma
id|msg
comma
id|code
comma
id|length
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/* -----------------------------------------------------------&n;    This function writes the information about the Return Code&n;    processing in the trace buffer. Trace ID is 221.&n;    INPUT:&n;        Adapter - system unicue adapter number (0 ... 255)&n;        Id      - Id of the entity that had sent this return code&n;        Ch      - Channel of the entity that had sent this return code&n;        Rc      - return code value&n;        cb:       (0...2)&n;                  switch (cb) {&n;                   case 0: printf (&quot;DELIVERY&quot;); break;&n;                   case 1: printf (&quot;CALLBACK&quot;); break;&n;                   case 2: printf (&quot;ASSIGN&quot;); break;&n;                  }&n;                  DELIVERY - have entered isdn_rc with this RC&n;                  CALLBACK - about to make callback to the application&n;                             for this RC&n;                  ASSIGN   - about to make callback for RC that is result&n;                             of ASSIGN request. It is no DELIVERY message&n;                             before of this message&n;        type   - the Id that was sent by the ASSIGN of this entity.&n;                 This should be global Id like NL_ID, DSIG_ID, MAN_ID.&n;                 An unknown Id will cause &quot;?-&quot; in the front of the request.&n;                 In this case the log.c is to be extended.&n;   ----------------------------------------------------------- */
DECL|function|xdi_xlog_rc_event
r_static
r_void
id|xdi_xlog_rc_event
(paren
id|byte
id|Adapter
comma
id|byte
id|Id
comma
id|byte
id|Ch
comma
id|byte
id|Rc
comma
id|byte
id|cb
comma
id|byte
id|type
)paren
(brace
macro_line|#if defined(XDI_USE_XLOG)
id|word
id|LogInfo
(braket
l_int|4
)braket
suffix:semicolon
id|PUT_WORD
c_func
(paren
op_amp
id|LogInfo
(braket
l_int|0
)braket
comma
(paren
(paren
id|word
)paren
id|Adapter
op_or
(paren
id|word
)paren
(paren
id|xdi_xlog_sec
op_increment
op_lshift
l_int|8
)paren
)paren
)paren
suffix:semicolon
id|PUT_WORD
c_func
(paren
op_amp
id|LogInfo
(braket
l_int|1
)braket
comma
(paren
(paren
id|word
)paren
id|Id
op_or
(paren
id|word
)paren
(paren
id|Ch
op_lshift
l_int|8
)paren
)paren
)paren
suffix:semicolon
id|PUT_WORD
c_func
(paren
op_amp
id|LogInfo
(braket
l_int|2
)braket
comma
(paren
(paren
id|word
)paren
id|Rc
op_or
(paren
id|word
)paren
(paren
id|type
op_lshift
l_int|8
)paren
)paren
)paren
suffix:semicolon
id|PUT_WORD
c_func
(paren
op_amp
id|LogInfo
(braket
l_int|3
)braket
comma
id|cb
)paren
suffix:semicolon
id|xdi_xlog
(paren
(paren
id|byte
op_star
)paren
op_amp
id|LogInfo
(braket
l_int|0
)braket
comma
l_int|221
comma
r_sizeof
(paren
id|LogInfo
)paren
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/* ------------------------------------------------------------------------&n;    This function writes the information about the request processing&n;    in the trace buffer. Trace ID is 220.&n;    INPUT:&n;        Adapter - system unicue adapter number (0 ... 255)&n;        Id      - Id of the entity that had sent this request&n;        Ch      - Channel of the entity that had sent this request&n;        Req     - Code of the request&n;        type    - the Id that was sent by the ASSIGN of this entity.&n;                  This should be global Id like NL_ID, DSIG_ID, MAN_ID.&n;                  An unknown Id will cause &quot;?-&quot; in the front of the request.&n;                  In this case the log.c is to be extended.&n;   ------------------------------------------------------------------------ */
DECL|function|xdi_xlog_request
r_static
r_void
id|xdi_xlog_request
(paren
id|byte
id|Adapter
comma
id|byte
id|Id
comma
id|byte
id|Ch
comma
id|byte
id|Req
comma
id|byte
id|type
)paren
(brace
macro_line|#if defined(XDI_USE_XLOG)
id|word
id|LogInfo
(braket
l_int|3
)braket
suffix:semicolon
id|PUT_WORD
c_func
(paren
op_amp
id|LogInfo
(braket
l_int|0
)braket
comma
(paren
(paren
id|word
)paren
id|Adapter
op_or
(paren
id|word
)paren
(paren
id|xdi_xlog_sec
op_increment
op_lshift
l_int|8
)paren
)paren
)paren
suffix:semicolon
id|PUT_WORD
c_func
(paren
op_amp
id|LogInfo
(braket
l_int|1
)braket
comma
(paren
(paren
id|word
)paren
id|Id
op_or
(paren
id|word
)paren
(paren
id|Ch
op_lshift
l_int|8
)paren
)paren
)paren
suffix:semicolon
id|PUT_WORD
c_func
(paren
op_amp
id|LogInfo
(braket
l_int|2
)braket
comma
(paren
(paren
id|word
)paren
id|Req
op_or
(paren
id|word
)paren
(paren
id|type
op_lshift
l_int|8
)paren
)paren
)paren
suffix:semicolon
id|xdi_xlog
(paren
(paren
id|byte
op_star
)paren
op_amp
id|LogInfo
(braket
l_int|0
)braket
comma
l_int|220
comma
r_sizeof
(paren
id|LogInfo
)paren
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/* ------------------------------------------------------------------------&n;    This function writes the information about the indication processing&n;    in the trace buffer. Trace ID is 222.&n;    INPUT:&n;        Adapter - system unicue adapter number (0 ... 255)&n;        Id      - Id of the entity that had sent this indication&n;        Ch      - Channel of the entity that had sent this indication&n;        Ind     - Code of the indication&n;        rnr_valid: (0 .. 3) supported&n;          switch (rnr_valid) {&n;            case 0: printf (&quot;DELIVERY&quot;); break;&n;            case 1: printf (&quot;RNR=%d&quot;, rnr);&n;            case 2: printf (&quot;RNum=0&quot;);&n;            case 3: printf (&quot;COMPLETE&quot;);&n;          }&n;          DELIVERY - indication entered isdn_rc function&n;          RNR=...  - application had returned RNR=... after the&n;                     look ahead callback&n;          RNum=0   - aplication had not returned any buffer to copy&n;                     this indication and will copy it self&n;          COMPLETE - XDI had copied the data to the buffers provided&n;                     bu the application and is about to issue the&n;                     final callback&n;        rnr:  Look case 1 of the rnr_valid&n;        type: the Id that was sent by the ASSIGN of this entity. This should&n;              be global Id like NL_ID, DSIG_ID, MAN_ID. An unknown Id will&n;              cause &quot;?-&quot; in the front of the request. In this case the&n;              log.c is to be extended.&n;   ------------------------------------------------------------------------ */
DECL|function|xdi_xlog_ind
r_static
r_void
id|xdi_xlog_ind
(paren
id|byte
id|Adapter
comma
id|byte
id|Id
comma
id|byte
id|Ch
comma
id|byte
id|Ind
comma
id|byte
id|rnr_valid
comma
id|byte
id|rnr
comma
id|byte
id|type
)paren
(brace
macro_line|#if defined(XDI_USE_XLOG)
id|word
id|LogInfo
(braket
l_int|4
)braket
suffix:semicolon
id|PUT_WORD
c_func
(paren
op_amp
id|LogInfo
(braket
l_int|0
)braket
comma
(paren
(paren
id|word
)paren
id|Adapter
op_or
(paren
id|word
)paren
(paren
id|xdi_xlog_sec
op_increment
op_lshift
l_int|8
)paren
)paren
)paren
suffix:semicolon
id|PUT_WORD
c_func
(paren
op_amp
id|LogInfo
(braket
l_int|1
)braket
comma
(paren
(paren
id|word
)paren
id|Id
op_or
(paren
id|word
)paren
(paren
id|Ch
op_lshift
l_int|8
)paren
)paren
)paren
suffix:semicolon
id|PUT_WORD
c_func
(paren
op_amp
id|LogInfo
(braket
l_int|2
)braket
comma
(paren
(paren
id|word
)paren
id|Ind
op_or
(paren
id|word
)paren
(paren
id|type
op_lshift
l_int|8
)paren
)paren
)paren
suffix:semicolon
id|PUT_WORD
c_func
(paren
op_amp
id|LogInfo
(braket
l_int|3
)braket
comma
(paren
(paren
id|word
)paren
id|rnr
op_or
(paren
id|word
)paren
(paren
id|rnr_valid
op_lshift
l_int|8
)paren
)paren
)paren
suffix:semicolon
id|xdi_xlog
(paren
(paren
id|byte
op_star
)paren
op_amp
id|LogInfo
(braket
l_int|0
)braket
comma
l_int|222
comma
r_sizeof
(paren
id|LogInfo
)paren
)paren
suffix:semicolon
macro_line|#endif
)brace
eof
