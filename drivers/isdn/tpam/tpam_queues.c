multiline_comment|/* $Id: tpam_queues.c,v 1.1.2.2 2001/09/23 22:25:03 kai Exp $&n; *&n; * Turbo PAM ISDN driver for Linux. (Kernel Driver)&n; *&n; * Copyright 2001 Stelian Pop &lt;stelian.pop@fr.alcove.com&gt;, Alc&#xfffd;ve&n; *&n; * This software may be used and distributed according to the terms&n; * of the GNU General Public License, incorporated herein by reference.&n; *&n; * For all support questions please contact: &lt;support@auvertech.fr&gt;&n; *&n; */
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/workqueue.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &quot;tpam.h&quot;
multiline_comment|/* Local function prototype */
r_static
r_int
id|tpam_sendpacket
c_func
(paren
id|tpam_card
op_star
id|card
comma
id|tpam_channel
op_star
id|channel
)paren
suffix:semicolon
multiline_comment|/*&n; * Queue a message to be send to the card when possible.&n; *&n; * &t;card: the board&n; * &t;skb: the sk_buff containing the message.&n; */
DECL|function|tpam_enqueue
r_void
id|tpam_enqueue
c_func
(paren
id|tpam_card
op_star
id|card
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
id|pr_debug
c_func
(paren
l_string|&quot;TurboPAM(tpam_enqueue): card=%d&bslash;n&quot;
comma
id|card-&gt;id
)paren
suffix:semicolon
multiline_comment|/* queue the sk_buff on the board&squot;s send queue */
id|skb_queue_tail
c_func
(paren
op_amp
id|card-&gt;sendq
comma
id|skb
)paren
suffix:semicolon
multiline_comment|/* queue the board&squot;s send task struct for immediate treatment */
id|schedule_work
c_func
(paren
op_amp
id|card-&gt;send_tq
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Queue a data message to be send to the card when possible.&n; *&n; * &t;card: the board&n; * &t;skb: the sk_buff containing the message and the data. This parameter&n; * &t;&t;can be NULL if we want just to trigger the send of queued &n; * &t;&t;messages.&n; */
DECL|function|tpam_enqueue_data
r_void
id|tpam_enqueue_data
c_func
(paren
id|tpam_channel
op_star
id|channel
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
id|pr_debug
c_func
(paren
l_string|&quot;TurboPAM(tpam_enqueue_data): card=%d, channel=%d&bslash;n&quot;
comma
id|channel-&gt;card-&gt;id
comma
id|channel-&gt;num
)paren
suffix:semicolon
multiline_comment|/* if existant, queue the sk_buff on the channel&squot;s send queue */
r_if
c_cond
(paren
id|skb
)paren
id|skb_queue_tail
c_func
(paren
op_amp
id|channel-&gt;sendq
comma
id|skb
)paren
suffix:semicolon
multiline_comment|/* queue the channel&squot;s send task struct for immediate treatment */
id|schedule_work
c_func
(paren
op_amp
id|channel-&gt;card-&gt;send_tq
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * IRQ handler.&n; *&n; * If a message comes from the board we read it, construct a sk_buff containing&n; * the message and we queue the sk_buff on the board&squot;s receive queue, and we&n; * trigger the execution of the board&squot;s receive task queue.&n; *&n; * If a message ack comes from the board we can go on and send a new message,&n; * so we trigger the execution of the board&squot;s send task queue.&n; *&n; * &t;irq: the irq number&n; * &t;dev_id: the registered board to the irq&n; * &t;regs: not used.&n; */
DECL|function|tpam_irq
id|irqreturn_t
id|tpam_irq
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|tpam_card
op_star
id|card
op_assign
(paren
id|tpam_card
op_star
)paren
id|dev_id
suffix:semicolon
id|u32
id|ackupload
comma
id|uploadptr
suffix:semicolon
id|u32
id|waiting_too_long
suffix:semicolon
id|u32
id|hpic
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
id|pci_mpb
id|mpb
suffix:semicolon
id|skb_header
op_star
id|skbh
suffix:semicolon
id|pr_debug
c_func
(paren
l_string|&quot;TurboPAM(tpam_irq): IRQ received, card=%d&bslash;n&quot;
comma
id|card-&gt;id
)paren
suffix:semicolon
multiline_comment|/* grab the board lock */
id|spin_lock
c_func
(paren
op_amp
id|card-&gt;lock
)paren
suffix:semicolon
multiline_comment|/* get the message type */
id|ackupload
op_assign
id|copy_from_pam_dword
c_func
(paren
id|card
comma
id|TPAM_ACKUPLOAD_REGISTER
)paren
suffix:semicolon
multiline_comment|/* acknowledge the interrupt */
id|copy_to_pam_dword
c_func
(paren
id|card
comma
id|TPAM_INTERRUPTACK_REGISTER
comma
l_int|0
)paren
suffix:semicolon
id|readl
c_func
(paren
id|card-&gt;bar0
op_plus
id|TPAM_HINTACK_REGISTER
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ackupload
)paren
(brace
multiline_comment|/* it is a new message from the board */
id|pr_debug
c_func
(paren
l_string|&quot;TurboPAM(tpam_irq): message received, card=%d&bslash;n&quot;
comma
id|card-&gt;id
)paren
suffix:semicolon
multiline_comment|/* get the upload pointer */
id|uploadptr
op_assign
id|copy_from_pam_dword
c_func
(paren
id|card
comma
id|TPAM_UPLOADPTR_REGISTER
)paren
suffix:semicolon
multiline_comment|/* get the beginning of the message (pci_mpb part) */
id|copy_from_pam
c_func
(paren
id|card
comma
op_amp
id|mpb
comma
id|uploadptr
comma
r_sizeof
(paren
id|pci_mpb
)paren
)paren
suffix:semicolon
multiline_comment|/* allocate the sk_buff */
r_if
c_cond
(paren
op_logical_neg
(paren
id|skb
op_assign
id|alloc_skb
c_func
(paren
r_sizeof
(paren
id|skb_header
)paren
op_plus
r_sizeof
(paren
id|pci_mpb
)paren
op_plus
id|mpb.actualBlockTLVSize
op_plus
id|mpb.actualDataSize
comma
id|GFP_ATOMIC
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;TurboPAM(tpam_irq): &quot;
l_string|&quot;alloc_skb failed&bslash;n&quot;
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|card-&gt;lock
)paren
suffix:semicolon
r_return
id|IRQ_HANDLED
suffix:semicolon
)brace
multiline_comment|/* build the skb_header */
id|skbh
op_assign
(paren
id|skb_header
op_star
)paren
id|skb_put
c_func
(paren
id|skb
comma
r_sizeof
(paren
id|skb_header
)paren
)paren
suffix:semicolon
id|skbh-&gt;size
op_assign
r_sizeof
(paren
id|pci_mpb
)paren
op_plus
id|mpb.actualBlockTLVSize
suffix:semicolon
id|skbh-&gt;data_size
op_assign
id|mpb.actualDataSize
suffix:semicolon
id|skbh-&gt;ack
op_assign
l_int|0
suffix:semicolon
id|skbh-&gt;ack_size
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* copy the pci_mpb into the sk_buff */
id|memcpy
c_func
(paren
id|skb_put
c_func
(paren
id|skb
comma
r_sizeof
(paren
id|pci_mpb
)paren
)paren
comma
op_amp
id|mpb
comma
r_sizeof
(paren
id|pci_mpb
)paren
)paren
suffix:semicolon
multiline_comment|/* copy the TLV block into the sk_buff */
id|copy_from_pam
c_func
(paren
id|card
comma
id|skb_put
c_func
(paren
id|skb
comma
id|mpb.actualBlockTLVSize
)paren
comma
id|uploadptr
op_plus
r_sizeof
(paren
id|pci_mpb
)paren
comma
id|mpb.actualBlockTLVSize
)paren
suffix:semicolon
multiline_comment|/* if existent, copy the data block into the sk_buff */
r_if
c_cond
(paren
id|mpb.actualDataSize
)paren
id|copy_from_pam
c_func
(paren
id|card
comma
id|skb_put
c_func
(paren
id|skb
comma
id|mpb.actualDataSize
)paren
comma
id|uploadptr
op_plus
r_sizeof
(paren
id|pci_mpb
)paren
op_plus
l_int|4096
comma
id|mpb.actualDataSize
)paren
suffix:semicolon
multiline_comment|/* wait for the board to become ready */
id|waiting_too_long
op_assign
l_int|0
suffix:semicolon
r_do
(brace
id|hpic
op_assign
id|readl
c_func
(paren
id|card-&gt;bar0
op_plus
id|TPAM_HPIC_REGISTER
)paren
suffix:semicolon
r_if
c_cond
(paren
id|waiting_too_long
op_increment
OG
l_int|0xfffffff
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|card-&gt;lock
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;TurboPAM(tpam_irq): &quot;
l_string|&quot;waiting too long...&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|IRQ_HANDLED
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|hpic
op_amp
l_int|0x00000002
)paren
suffix:semicolon
multiline_comment|/* acknowledge the message */
id|copy_to_pam_dword
c_func
(paren
id|card
comma
id|TPAM_ACKDOWNLOAD_REGISTER
comma
l_int|0xffffffff
)paren
suffix:semicolon
id|readl
c_func
(paren
id|card-&gt;bar0
op_plus
id|TPAM_DSPINT_REGISTER
)paren
suffix:semicolon
multiline_comment|/* release the board lock */
id|spin_unlock
c_func
(paren
op_amp
id|card-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mpb.messageID
op_eq
id|ID_U3ReadyToReceiveInd
)paren
(brace
multiline_comment|/* this message needs immediate treatment */
id|tpam_recv_U3ReadyToReceiveInd
c_func
(paren
id|card
comma
id|skb
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* put the message in the receive queue */
id|skb_queue_tail
c_func
(paren
op_amp
id|card-&gt;recvq
comma
id|skb
)paren
suffix:semicolon
id|schedule_work
c_func
(paren
op_amp
id|card-&gt;recv_tq
)paren
suffix:semicolon
)brace
r_return
id|IRQ_HANDLED
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* it is a ack from the board */
id|pr_debug
c_func
(paren
l_string|&quot;TurboPAM(tpam_irq): message acknowledged, card=%d&bslash;n&quot;
comma
id|card-&gt;id
)paren
suffix:semicolon
multiline_comment|/* board is not busy anymore */
id|card-&gt;busy
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* release the lock */
id|spin_unlock
c_func
(paren
op_amp
id|card-&gt;lock
)paren
suffix:semicolon
multiline_comment|/* schedule the send queue for execution */
id|schedule_work
c_func
(paren
op_amp
id|card-&gt;send_tq
)paren
suffix:semicolon
)brace
r_return
id|IRQ_HANDLED
suffix:semicolon
)brace
multiline_comment|/*&n; * Run the board&squot;s receive task queue, dispatching each message on the queue,&n; * to its treatment function.&n; *&n; * &t;card: the board.&n; */
DECL|function|tpam_recv_tq
r_void
id|tpam_recv_tq
c_func
(paren
id|tpam_card
op_star
id|card
)paren
(brace
id|pci_mpb
op_star
id|p
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
multiline_comment|/* for each message on the receive queue... */
r_while
c_loop
(paren
(paren
id|skb
op_assign
id|skb_dequeue
c_func
(paren
op_amp
id|card-&gt;recvq
)paren
)paren
)paren
(brace
multiline_comment|/* point to the pci_mpb block */
id|p
op_assign
(paren
id|pci_mpb
op_star
)paren
(paren
id|skb-&gt;data
op_plus
r_sizeof
(paren
id|skb_header
)paren
)paren
suffix:semicolon
multiline_comment|/* dispatch the message */
r_switch
c_cond
(paren
id|p-&gt;messageID
)paren
(brace
r_case
id|ID_ACreateNCOCnf
suffix:colon
id|tpam_recv_ACreateNCOCnf
c_func
(paren
id|card
comma
id|skb
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ID_ADestroyNCOCnf
suffix:colon
id|tpam_recv_ADestroyNCOCnf
c_func
(paren
id|card
comma
id|skb
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ID_CConnectCnf
suffix:colon
id|tpam_recv_CConnectCnf
c_func
(paren
id|card
comma
id|skb
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ID_CConnectInd
suffix:colon
id|tpam_recv_CConnectInd
c_func
(paren
id|card
comma
id|skb
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ID_CDisconnectInd
suffix:colon
id|tpam_recv_CDisconnectInd
c_func
(paren
id|card
comma
id|skb
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ID_CDisconnectCnf
suffix:colon
id|tpam_recv_CDisconnectCnf
c_func
(paren
id|card
comma
id|skb
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ID_U3DataInd
suffix:colon
id|tpam_recv_U3DataInd
c_func
(paren
id|card
comma
id|skb
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|pr_debug
c_func
(paren
l_string|&quot;TurboPAM(tpam_recv_tq): &quot;
l_string|&quot;unknown messageID %d, card=%d&bslash;n&quot;
comma
id|p-&gt;messageID
comma
id|card-&gt;id
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* free the sk_buff */
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Run the board&squot;s send task queue. If there is a message in the board&squot;s send&n; * queue, it gets sended. If not, it examines each channel (one at the time,&n; * using a round robin algorithm). For each channel, if there is a message&n; * in the channel&squot;s send queue, it gets sended. This function sends only one&n; * message, it does not consume all the queue.&n; */
DECL|function|tpam_send_tq
r_void
id|tpam_send_tq
c_func
(paren
id|tpam_card
op_star
id|card
)paren
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/* first, try to send a packet from the board&squot;s send queue */
r_if
c_cond
(paren
id|tpam_sendpacket
c_func
(paren
id|card
comma
l_int|NULL
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* then, try each channel, in a round-robin manner */
r_for
c_loop
(paren
id|i
op_assign
id|card-&gt;roundrobin
suffix:semicolon
id|i
OL
id|card-&gt;roundrobin
op_plus
id|card-&gt;channels_used
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|tpam_sendpacket
c_func
(paren
id|card
comma
op_amp
id|card-&gt;channels
(braket
id|i
op_mod
id|card-&gt;channels_used
)braket
)paren
)paren
(brace
id|card-&gt;roundrobin
op_assign
(paren
id|i
op_plus
l_int|1
)paren
op_mod
id|card-&gt;channels_used
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * Try to send a packet from the board&squot;s send queue or from the channel&squot;s&n; * send queue.&n; *&n; * &t;card: the board.&n; * &t;channel: the channel (if NULL, the packet will be taken from the &n; * &t;&t;board&squot;s send queue. If not, it will be taken from the &n; * &t;&t;channel&squot;s send queue.&n; *&n; * Return: 0 if tpam_send_tq must try another card/channel combination&n; * &t;(meaning that no packet has been send), 1 if no more packets&n; * &t;can be send at that time (a packet has been send or the card is&n; * &t;still busy from a previous send).&n; */
DECL|function|tpam_sendpacket
r_static
r_int
id|tpam_sendpacket
c_func
(paren
id|tpam_card
op_star
id|card
comma
id|tpam_channel
op_star
id|channel
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
id|u32
id|hpic
suffix:semicolon
id|u32
id|downloadptr
suffix:semicolon
id|skb_header
op_star
id|skbh
suffix:semicolon
id|u32
id|waiting_too_long
suffix:semicolon
id|pr_debug
c_func
(paren
l_string|&quot;TurboPAM(tpam_sendpacket), card=%d, channel=%d&bslash;n&quot;
comma
id|card-&gt;id
comma
id|channel
ques
c_cond
id|channel-&gt;num
suffix:colon
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|channel
)paren
(brace
multiline_comment|/* dequeue a packet from the channel&squot;s send queue */
r_if
c_cond
(paren
op_logical_neg
(paren
id|skb
op_assign
id|skb_dequeue
c_func
(paren
op_amp
id|channel-&gt;sendq
)paren
)paren
)paren
(brace
id|pr_debug
c_func
(paren
l_string|&quot;TurboPAM(tpam_sendpacket): &quot;
l_string|&quot;card=%d, channel=%d, no packet&bslash;n&quot;
comma
id|card-&gt;id
comma
id|channel-&gt;num
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* if the channel is not ready to receive, requeue the packet&n;&t;&t; * and return 0 to give a chance to another channel */
r_if
c_cond
(paren
op_logical_neg
id|channel-&gt;readytoreceive
)paren
(brace
id|pr_debug
c_func
(paren
l_string|&quot;TurboPAM(tpam_sendpacket): &quot;
l_string|&quot;card=%d, channel=%d, channel not ready&bslash;n&quot;
comma
id|card-&gt;id
comma
id|channel-&gt;num
)paren
suffix:semicolon
id|skb_queue_head
c_func
(paren
op_amp
id|channel-&gt;sendq
comma
id|skb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* grab the board lock */
id|spin_lock_irq
c_func
(paren
op_amp
id|card-&gt;lock
)paren
suffix:semicolon
multiline_comment|/* if the board is busy, requeue the packet and return 1 since&n;&t;&t; * there is no need to try another channel */
r_if
c_cond
(paren
id|card-&gt;busy
)paren
(brace
id|pr_debug
c_func
(paren
l_string|&quot;TurboPAM(tpam_sendpacket): &quot;
l_string|&quot;card=%d, channel=%d, card busy&bslash;n&quot;
comma
id|card-&gt;id
comma
id|channel-&gt;num
)paren
suffix:semicolon
id|skb_queue_head
c_func
(paren
op_amp
id|channel-&gt;sendq
comma
id|skb
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|card-&gt;lock
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* dequeue a packet from the board&squot;s send queue */
r_if
c_cond
(paren
op_logical_neg
(paren
id|skb
op_assign
id|skb_dequeue
c_func
(paren
op_amp
id|card-&gt;sendq
)paren
)paren
)paren
(brace
id|pr_debug
c_func
(paren
l_string|&quot;TurboPAM(tpam_sendpacket): &quot;
l_string|&quot;card=%d, no packet&bslash;n&quot;
comma
id|card-&gt;id
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* grab the board lock */
id|spin_lock_irq
c_func
(paren
op_amp
id|card-&gt;lock
)paren
suffix:semicolon
multiline_comment|/* if the board is busy, requeue the packet and return 1 since&n;&t;&t; * there is no need to try another channel */
r_if
c_cond
(paren
id|card-&gt;busy
)paren
(brace
id|pr_debug
c_func
(paren
l_string|&quot;TurboPAM(tpam_sendpacket): &quot;
l_string|&quot;card=%d, card busy&bslash;n&quot;
comma
id|card-&gt;id
)paren
suffix:semicolon
id|skb_queue_head
c_func
(paren
op_amp
id|card-&gt;sendq
comma
id|skb
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|card-&gt;lock
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/* wait for the board to become ready */
id|waiting_too_long
op_assign
l_int|0
suffix:semicolon
r_do
(brace
id|hpic
op_assign
id|readl
c_func
(paren
id|card-&gt;bar0
op_plus
id|TPAM_HPIC_REGISTER
)paren
suffix:semicolon
r_if
c_cond
(paren
id|waiting_too_long
op_increment
OG
l_int|0xfffffff
)paren
(brace
id|spin_unlock_irq
c_func
(paren
op_amp
id|card-&gt;lock
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;TurboPAM(tpam_sendpacket): &quot;
l_string|&quot;waiting too long...&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|hpic
op_amp
l_int|0x00000002
)paren
suffix:semicolon
id|skbh
op_assign
(paren
id|skb_header
op_star
)paren
id|skb-&gt;data
suffix:semicolon
id|pr_debug
c_func
(paren
l_string|&quot;TurboPAM(tpam_sendpacket): &quot;
l_string|&quot;card=%d, card ready, sending %d/%d bytes&bslash;n&quot;
comma
id|card-&gt;id
comma
id|skbh-&gt;size
comma
id|skbh-&gt;data_size
)paren
suffix:semicolon
multiline_comment|/* get the board&squot;s download pointer */
id|downloadptr
op_assign
id|copy_from_pam_dword
c_func
(paren
id|card
comma
id|TPAM_DOWNLOADPTR_REGISTER
)paren
suffix:semicolon
multiline_comment|/* copy the packet to the board at the downloadptr location */
id|copy_to_pam
c_func
(paren
id|card
comma
id|downloadptr
comma
id|skb-&gt;data
op_plus
r_sizeof
(paren
id|skb_header
)paren
comma
id|skbh-&gt;size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skbh-&gt;data_size
)paren
multiline_comment|/* if there is some data in the packet, copy it too */
id|copy_to_pam
c_func
(paren
id|card
comma
id|downloadptr
op_plus
r_sizeof
(paren
id|pci_mpb
)paren
op_plus
l_int|4096
comma
id|skb-&gt;data
op_plus
r_sizeof
(paren
id|skb_header
)paren
op_plus
id|skbh-&gt;size
comma
id|skbh-&gt;data_size
)paren
suffix:semicolon
multiline_comment|/* card will become busy right now */
id|card-&gt;busy
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* interrupt the board */
id|copy_to_pam_dword
c_func
(paren
id|card
comma
id|TPAM_ACKDOWNLOAD_REGISTER
comma
l_int|0
)paren
suffix:semicolon
id|readl
c_func
(paren
id|card-&gt;bar0
op_plus
id|TPAM_DSPINT_REGISTER
)paren
suffix:semicolon
multiline_comment|/* release the lock */
id|spin_unlock_irq
c_func
(paren
op_amp
id|card-&gt;lock
)paren
suffix:semicolon
multiline_comment|/* if a data ack was requested by the ISDN link layer, send it now */
r_if
c_cond
(paren
id|skbh-&gt;ack
)paren
(brace
id|isdn_ctrl
id|ctrl
suffix:semicolon
id|ctrl.driver
op_assign
id|card-&gt;id
suffix:semicolon
id|ctrl.command
op_assign
id|ISDN_STAT_BSENT
suffix:semicolon
id|ctrl.arg
op_assign
id|channel-&gt;num
suffix:semicolon
id|ctrl.parm.length
op_assign
id|skbh-&gt;ack_size
suffix:semicolon
(paren
op_star
id|card-&gt;interface.statcallb
)paren
(paren
op_amp
id|ctrl
)paren
suffix:semicolon
)brace
multiline_comment|/* free the sk_buff */
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
eof
