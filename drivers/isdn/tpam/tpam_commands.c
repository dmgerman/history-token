multiline_comment|/* $Id: tpam_commands.c,v 1.1.2.3 2001/09/23 22:25:03 kai Exp $&n; *&n; * Turbo PAM ISDN driver for Linux. (Kernel Driver - ISDN commands)&n; *&n; * Copyright 2001 Stelian Pop &lt;stelian.pop@fr.alcove.com&gt;, Alc&#xfffd;ve&n; *&n; * This software may be used and distributed according to the terms&n; * of the GNU General Public License, incorporated herein by reference.&n; *&n; * For all support questions please contact: &lt;support@auvertech.fr&gt;&n; *&n; */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/tqueue.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;linux/isdn/tpam.h&gt;
macro_line|#include &quot;tpam.h&quot;
multiline_comment|/* Local functions prototypes */
r_static
r_int
id|tpam_command_ioctl_dspload
c_func
(paren
id|tpam_card
op_star
comma
id|u32
)paren
suffix:semicolon
r_static
r_int
id|tpam_command_ioctl_dspsave
c_func
(paren
id|tpam_card
op_star
comma
id|u32
)paren
suffix:semicolon
r_static
r_int
id|tpam_command_ioctl_dsprun
c_func
(paren
id|tpam_card
op_star
)paren
suffix:semicolon
r_static
r_int
id|tpam_command_ioctl_loopmode
c_func
(paren
id|tpam_card
op_star
comma
id|u8
)paren
suffix:semicolon
r_static
r_int
id|tpam_command_dial
c_func
(paren
id|tpam_card
op_star
comma
id|u32
comma
id|u8
op_star
)paren
suffix:semicolon
r_static
r_int
id|tpam_command_setl2
c_func
(paren
id|tpam_card
op_star
comma
id|u32
comma
id|u8
)paren
suffix:semicolon
r_static
r_int
id|tpam_command_getl2
c_func
(paren
id|tpam_card
op_star
comma
id|u32
)paren
suffix:semicolon
r_static
r_int
id|tpam_command_acceptd
c_func
(paren
id|tpam_card
op_star
comma
id|u32
)paren
suffix:semicolon
r_static
r_int
id|tpam_command_acceptb
c_func
(paren
id|tpam_card
op_star
comma
id|u32
)paren
suffix:semicolon
r_static
r_int
id|tpam_command_hangup
c_func
(paren
id|tpam_card
op_star
comma
id|u32
)paren
suffix:semicolon
r_static
r_int
id|tpam_command_proceed
c_func
(paren
id|tpam_card
op_star
comma
id|u32
)paren
suffix:semicolon
r_static
r_void
id|tpam_statcallb_run
c_func
(paren
r_int
r_int
)paren
suffix:semicolon
r_static
r_void
id|tpam_statcallb
c_func
(paren
id|tpam_card
op_star
comma
id|isdn_ctrl
)paren
suffix:semicolon
multiline_comment|/*&n; * Function called when the ISDN link level send a command to the driver.&n; *&n; * &t;c: ISDN command.&n; *&n; * Return: 0 if OK, &lt;0 on errors.&n; */
DECL|function|tpam_command
r_int
id|tpam_command
c_func
(paren
id|isdn_ctrl
op_star
id|c
)paren
(brace
id|tpam_card
op_star
id|card
suffix:semicolon
r_int
r_int
id|argp
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;TurboPAM(tpam_command) card=%d, command=%d&bslash;n&quot;
comma
id|c-&gt;driver
comma
id|c-&gt;command
)paren
suffix:semicolon
multiline_comment|/* search for the board */
r_if
c_cond
(paren
op_logical_neg
(paren
id|card
op_assign
id|tpam_findcard
c_func
(paren
id|c-&gt;driver
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;TurboPAM(tpam_command): invalid driverId %d&bslash;n&quot;
comma
id|c-&gt;driver
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/* dispatch the command */
r_switch
c_cond
(paren
id|c-&gt;command
)paren
(brace
r_case
id|ISDN_CMD_IOCTL
suffix:colon
id|argp
op_assign
id|c-&gt;parm.userdata
suffix:semicolon
r_switch
c_cond
(paren
id|c-&gt;arg
)paren
(brace
r_case
id|TPAM_CMD_DSPLOAD
suffix:colon
r_return
id|tpam_command_ioctl_dspload
c_func
(paren
id|card
comma
id|argp
)paren
suffix:semicolon
r_case
id|TPAM_CMD_DSPSAVE
suffix:colon
r_return
id|tpam_command_ioctl_dspsave
c_func
(paren
id|card
comma
id|argp
)paren
suffix:semicolon
r_case
id|TPAM_CMD_DSPRUN
suffix:colon
r_return
id|tpam_command_ioctl_dsprun
c_func
(paren
id|card
)paren
suffix:semicolon
r_case
id|TPAM_CMD_LOOPMODEON
suffix:colon
r_return
id|tpam_command_ioctl_loopmode
c_func
(paren
id|card
comma
l_int|1
)paren
suffix:semicolon
r_case
id|TPAM_CMD_LOOPMODEOFF
suffix:colon
r_return
id|tpam_command_ioctl_loopmode
c_func
(paren
id|card
comma
l_int|0
)paren
suffix:semicolon
r_default
suffix:colon
id|dprintk
c_func
(paren
l_string|&quot;TurboPAM(tpam_command): &quot;
l_string|&quot;invalid tpam ioctl %ld&bslash;n&quot;
comma
id|c-&gt;arg
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_case
id|ISDN_CMD_DIAL
suffix:colon
r_return
id|tpam_command_dial
c_func
(paren
id|card
comma
id|c-&gt;arg
comma
id|c-&gt;parm.setup.phone
)paren
suffix:semicolon
r_case
id|ISDN_CMD_ACCEPTD
suffix:colon
r_return
id|tpam_command_acceptd
c_func
(paren
id|card
comma
id|c-&gt;arg
)paren
suffix:semicolon
r_case
id|ISDN_CMD_ACCEPTB
suffix:colon
r_return
id|tpam_command_acceptb
c_func
(paren
id|card
comma
id|c-&gt;arg
)paren
suffix:semicolon
r_case
id|ISDN_CMD_HANGUP
suffix:colon
r_return
id|tpam_command_hangup
c_func
(paren
id|card
comma
id|c-&gt;arg
)paren
suffix:semicolon
r_case
id|ISDN_CMD_SETL2
suffix:colon
r_return
id|tpam_command_setl2
c_func
(paren
id|card
comma
id|c-&gt;arg
op_amp
l_int|0xff
comma
id|c-&gt;arg
op_rshift
l_int|8
)paren
suffix:semicolon
r_case
id|ISDN_CMD_GETL2
suffix:colon
r_return
id|tpam_command_getl2
c_func
(paren
id|card
comma
id|c-&gt;arg
)paren
suffix:semicolon
r_case
id|ISDN_CMD_LOCK
suffix:colon
id|MOD_INC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|ISDN_CMD_UNLOCK
suffix:colon
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|ISDN_CMD_PROCEED
suffix:colon
r_return
id|tpam_command_proceed
c_func
(paren
id|card
comma
id|c-&gt;arg
)paren
suffix:semicolon
r_default
suffix:colon
id|dprintk
c_func
(paren
l_string|&quot;TurboPAM(tpam_command): &quot;
l_string|&quot;unknown or unused isdn ioctl %d&bslash;n&quot;
comma
id|c-&gt;command
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* not reached */
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/*&n; * Load some data into the board&squot;s memory.&n; *&n; * &t;card: the board&n; * &t;arg: IOCTL argument containing the user space address of &n; * &t;&t;the tpam_dsp_ioctl structure describing the IOCTL.&n; *&n; * Return: 0 if OK, &lt;0 on errors.&n; */
DECL|function|tpam_command_ioctl_dspload
r_static
r_int
id|tpam_command_ioctl_dspload
c_func
(paren
id|tpam_card
op_star
id|card
comma
id|u32
id|arg
)paren
(brace
id|tpam_dsp_ioctl
id|tdl
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;TurboPAM(tpam_command_ioctl_dspload): card=%d&bslash;n&quot;
comma
id|card-&gt;id
)paren
suffix:semicolon
multiline_comment|/* get the IOCTL parameter from userspace */
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|tdl
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|tpam_dsp_ioctl
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
multiline_comment|/* if the board&squot;s firmware was started, protect against writes&n;&t; * to unallowed memory areas. If the board&squot;s firmware wasn&squot;t started,&n;&t; * all is allowed. */
r_if
c_cond
(paren
id|card-&gt;running
op_logical_and
id|tpam_verify_area
c_func
(paren
id|tdl.address
comma
id|tdl.data_len
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
multiline_comment|/* write the data in the board&squot;s memory */
id|ret
op_assign
id|copy_from_user_to_pam
c_func
(paren
id|card
comma
(paren
r_void
op_star
)paren
id|tdl.address
comma
(paren
r_void
op_star
)paren
id|arg
op_plus
r_sizeof
(paren
id|tpam_dsp_ioctl
)paren
comma
id|tdl.data_len
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Extract some data from the board&squot;s memory.&n; *&n; * &t;card: the board&n; * &t;arg: IOCTL argument containing the user space address of &n; * &t;&t;the tpam_dsp_ioctl structure describing the IOCTL.&n; *&n; * Return: 0 if OK, &lt;0 on errors.&n; */
DECL|function|tpam_command_ioctl_dspsave
r_static
r_int
id|tpam_command_ioctl_dspsave
c_func
(paren
id|tpam_card
op_star
id|card
comma
id|u32
id|arg
)paren
(brace
id|tpam_dsp_ioctl
id|tdl
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;TurboPAM(tpam_command_ioctl_dspsave): card=%d&bslash;n&quot;
comma
id|card-&gt;id
)paren
suffix:semicolon
multiline_comment|/* get the IOCTL parameter from userspace */
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|tdl
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|tpam_dsp_ioctl
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
multiline_comment|/* protect against read from unallowed memory areas */
r_if
c_cond
(paren
id|tpam_verify_area
c_func
(paren
id|tdl.address
comma
id|tdl.data_len
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
multiline_comment|/* read the data from the board&squot;s memory */
id|ret
op_assign
id|copy_from_pam_to_user
c_func
(paren
id|card
comma
(paren
r_void
op_star
)paren
id|arg
op_plus
r_sizeof
(paren
id|tpam_dsp_ioctl
)paren
comma
(paren
r_void
op_star
)paren
id|tdl.address
comma
id|tdl.data_len
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Launch the board&squot;s firmware. This function must be called after the &n; * firmware was loaded into the board&squot;s memory using TPAM_CMD_DSPLOAD &n; * IOCTL commands. After launching the firmware, this function creates&n; * the NCOs and waits for their creation.&n; *&n; * &t;card: the board&n; *&n; * Return: 0 if OK, &lt;0 on errors.&n; */
DECL|function|tpam_command_ioctl_dsprun
r_static
r_int
id|tpam_command_ioctl_dsprun
c_func
(paren
id|tpam_card
op_star
id|card
)paren
(brace
id|u32
id|signature
op_assign
l_int|0
comma
id|timeout
comma
id|i
suffix:semicolon
id|isdn_ctrl
id|ctrl
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;TurboPAM(tpam_command_ioctl_dsprun): card=%d&bslash;n&quot;
comma
id|card-&gt;id
)paren
suffix:semicolon
multiline_comment|/* board must _not_ be running */
r_if
c_cond
(paren
id|card-&gt;running
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
multiline_comment|/* reset the board */
id|spin_lock_irq
c_func
(paren
op_amp
id|card-&gt;lock
)paren
suffix:semicolon
id|copy_to_pam_dword
c_func
(paren
id|card
comma
(paren
r_void
op_star
)paren
id|TPAM_MAGICNUMBER_REGISTER
comma
l_int|0xdeadface
)paren
suffix:semicolon
id|readl
c_func
(paren
id|card-&gt;bar0
op_plus
id|TPAM_DSPINT_REGISTER
)paren
suffix:semicolon
id|readl
c_func
(paren
id|card-&gt;bar0
op_plus
id|TPAM_HINTACK_REGISTER
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|card-&gt;lock
)paren
suffix:semicolon
multiline_comment|/* wait for the board signature */
id|timeout
op_assign
id|jiffies
op_plus
id|SIGNATURE_TIMEOUT
suffix:semicolon
r_while
c_loop
(paren
id|timeout
OG
id|jiffies
)paren
(brace
id|spin_lock_irq
c_func
(paren
op_amp
id|card-&gt;lock
)paren
suffix:semicolon
id|signature
op_assign
id|copy_from_pam_dword
c_func
(paren
id|card
comma
(paren
r_void
op_star
)paren
id|TPAM_MAGICNUMBER_REGISTER
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|card-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signature
op_eq
id|TPAM_MAGICNUMBER
)paren
r_break
suffix:semicolon
id|set_current_state
c_func
(paren
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
id|schedule_timeout
c_func
(paren
l_int|2
)paren
suffix:semicolon
)brace
multiline_comment|/* signature not present -&gt; board not started */
r_if
c_cond
(paren
id|signature
op_ne
id|TPAM_MAGICNUMBER
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;TurboPAM(tpam_command_ioctl_dsprun): &quot;
l_string|&quot;card=%d, signature 0x%lx, expected 0x%lx&bslash;n&quot;
comma
id|card-&gt;id
comma
(paren
r_int
r_int
)paren
id|signature
comma
(paren
r_int
r_int
)paren
id|TPAM_MAGICNUMBER
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;TurboPAM(tpam_command_ioctl_dsprun): &quot;
l_string|&quot;card=%d, firmware not started&bslash;n&quot;
comma
id|card-&gt;id
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/* the firmware is started */
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;TurboPAM: card=%d, firmware started&bslash;n&quot;
comma
id|card-&gt;id
)paren
suffix:semicolon
multiline_comment|/* init the CRC routines */
id|init_CRC
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* create all the NCOs */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|TPAM_NBCHANNEL
suffix:semicolon
op_increment
id|i
)paren
r_if
c_cond
(paren
(paren
id|skb
op_assign
id|build_ACreateNCOReq
c_func
(paren
l_string|&quot;&quot;
)paren
)paren
)paren
id|tpam_enqueue
c_func
(paren
id|card
comma
id|skb
)paren
suffix:semicolon
multiline_comment|/* wait for NCO creation confirmation */
id|timeout
op_assign
id|jiffies
op_plus
id|NCOCREATE_TIMEOUT
suffix:semicolon
r_while
c_loop
(paren
id|timeout
OG
id|jiffies
)paren
(brace
r_if
c_cond
(paren
id|card-&gt;channels_tested
op_eq
id|TPAM_NBCHANNEL
)paren
r_break
suffix:semicolon
id|set_current_state
c_func
(paren
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
id|schedule_timeout
c_func
(paren
l_int|2
)paren
suffix:semicolon
)brace
id|card-&gt;running
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|card-&gt;channels_tested
op_ne
id|TPAM_NBCHANNEL
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;TurboPAM(tpam_command_ioctl_dsprun): &quot;
l_string|&quot;card=%d, tried to init %d channels, &quot;
l_string|&quot;got reply from only %d channels&bslash;n&quot;
comma
id|card-&gt;id
comma
id|TPAM_NBCHANNEL
comma
id|card-&gt;channels_tested
)paren
suffix:semicolon
multiline_comment|/* if all the channels were not initialized, signal to the ISDN&n;&t; * link layer that fact that some channels are not usable */
r_if
c_cond
(paren
id|card-&gt;channels_used
op_ne
id|TPAM_NBCHANNEL
)paren
r_for
c_loop
(paren
id|i
op_assign
id|card-&gt;channels_used
suffix:semicolon
id|i
OL
id|TPAM_NBCHANNEL
suffix:semicolon
op_increment
id|i
)paren
(brace
id|ctrl.driver
op_assign
id|card-&gt;id
suffix:semicolon
id|ctrl.command
op_assign
id|ISDN_STAT_DISCH
suffix:semicolon
id|ctrl.arg
op_assign
id|i
suffix:semicolon
id|ctrl.parm.num
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
(paren
op_star
id|card-&gt;interface.statcallb
)paren
(paren
op_amp
id|ctrl
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;TurboPAM: card=%d, ready, %d channels available&bslash;n&quot;
comma
id|card-&gt;id
comma
id|card-&gt;channels_used
)paren
suffix:semicolon
multiline_comment|/* let&squot;s rock ! */
id|ctrl.driver
op_assign
id|card-&gt;id
suffix:semicolon
id|ctrl.command
op_assign
id|ISDN_STAT_RUN
suffix:semicolon
id|ctrl.arg
op_assign
l_int|0
suffix:semicolon
id|tpam_statcallb
c_func
(paren
id|card
comma
id|ctrl
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* &n; * Set/reset the board&squot;s looptest mode.&n; *&n; * &t;card: the board&n; * &t;mode: if 1, sets the board&squot;s looptest mode, if 0 resets it.&n; *&n; * Return: 0 if OK, &lt;0 if error.&n; */
DECL|function|tpam_command_ioctl_loopmode
r_static
r_int
id|tpam_command_ioctl_loopmode
c_func
(paren
id|tpam_card
op_star
id|card
comma
id|u8
id|mode
)paren
(brace
multiline_comment|/* board must be running */
r_if
c_cond
(paren
op_logical_neg
id|card-&gt;running
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|card-&gt;loopmode
op_assign
id|mode
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Issue a dial command. This function builds and sends a CConnectReq.&n; * &n; * &t;card: the board&n; * &t;channel: the channel number&n; * &t;phone: the remote phone number (EAZ)&n; *&n; * Return: 0 if OK, &lt;0 if error.&n; */
DECL|function|tpam_command_dial
r_static
r_int
id|tpam_command_dial
c_func
(paren
id|tpam_card
op_star
id|card
comma
id|u32
id|channel
comma
id|u8
op_star
id|phone
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
id|isdn_ctrl
id|ctrl
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;TurboPAM(tpam_command_dial): card=%d, channel=%lu, phone=%s&bslash;n&quot;
comma
id|card-&gt;id
comma
(paren
r_int
r_int
)paren
id|channel
comma
id|phone
)paren
suffix:semicolon
multiline_comment|/* board must be running */
r_if
c_cond
(paren
op_logical_neg
id|card-&gt;running
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
multiline_comment|/* initialize channel parameters */
id|card-&gt;channels
(braket
id|channel
)braket
dot
id|realhdlc
op_assign
id|card-&gt;channels
(braket
id|channel
)braket
dot
id|hdlc
suffix:semicolon
id|card-&gt;channels
(braket
id|channel
)braket
dot
id|hdlcshift
op_assign
l_int|0
suffix:semicolon
id|card-&gt;channels
(braket
id|channel
)braket
dot
id|readytoreceive
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* build and send a CConnectReq */
id|skb
op_assign
id|build_CConnectReq
c_func
(paren
id|card-&gt;channels
(braket
id|channel
)braket
dot
id|ncoid
comma
id|phone
comma
id|card-&gt;channels
(braket
id|channel
)braket
dot
id|realhdlc
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skb
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|tpam_enqueue
c_func
(paren
id|card
comma
id|skb
)paren
suffix:semicolon
multiline_comment|/* making a connection in modem mode is slow and causes the ISDN&n;&t; * link layer to hangup the connection before even it gets a chance&n;&t; * to establish... All we can do is simulate a successful connection&n;&t; * for now, and send a DHUP later if the connection fails */
r_if
c_cond
(paren
op_logical_neg
id|card-&gt;channels
(braket
id|channel
)braket
dot
id|realhdlc
)paren
(brace
id|ctrl.driver
op_assign
id|card-&gt;id
suffix:semicolon
id|ctrl.command
op_assign
id|ISDN_STAT_DCONN
suffix:semicolon
id|ctrl.arg
op_assign
id|channel
suffix:semicolon
id|tpam_statcallb
c_func
(paren
id|card
comma
id|ctrl
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Set the level2 protocol (modem or HDLC).&n; *&n; * &t;card: the board&n; * &t;channel: the channel number&n; * &t;proto: the level2 protocol (one of ISDN_PROTO_L2*)&n; *&n; * Return: 0 if OK, &lt;0 if error.&n; */
DECL|function|tpam_command_setl2
r_static
r_int
id|tpam_command_setl2
c_func
(paren
id|tpam_card
op_star
id|card
comma
id|u32
id|channel
comma
id|u8
id|proto
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;TurboPAM(tpam_command_setl2): card=%d, channel=%lu, proto=%d&bslash;n&quot;
comma
id|card-&gt;id
comma
(paren
r_int
r_int
)paren
id|channel
comma
id|proto
)paren
suffix:semicolon
multiline_comment|/* board must be running */
r_if
c_cond
(paren
op_logical_neg
id|card-&gt;running
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
multiline_comment|/* set the hdlc/modem mode */
r_switch
c_cond
(paren
id|proto
)paren
(brace
r_case
id|ISDN_PROTO_L2_HDLC
suffix:colon
id|card-&gt;channels
(braket
id|channel
)braket
dot
id|hdlc
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ISDN_PROTO_L2_MODEM
suffix:colon
id|card-&gt;channels
(braket
id|channel
)braket
dot
id|hdlc
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Return the level2 protocol (modem or HDLC).&n; *&n; * &t;card: the board&n; * &t;channel: the channel number&n; *&n; * Return: ISDN_PROTO_L2_HDLC/MODEM if OK, &lt;0 if error.&n; */
DECL|function|tpam_command_getl2
r_static
r_int
id|tpam_command_getl2
c_func
(paren
id|tpam_card
op_star
id|card
comma
id|u32
id|channel
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;TurboPAM(tpam_command_getl2): card=%d, channel=%lu&bslash;n&quot;
comma
id|card-&gt;id
comma
(paren
r_int
r_int
)paren
id|channel
)paren
suffix:semicolon
multiline_comment|/* board must be running */
r_if
c_cond
(paren
op_logical_neg
id|card-&gt;running
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
multiline_comment|/* return the current mode */
r_if
c_cond
(paren
id|card-&gt;channels
(braket
id|channel
)braket
dot
id|realhdlc
)paren
r_return
id|ISDN_PROTO_L2_HDLC
suffix:semicolon
r_else
r_return
id|ISDN_PROTO_L2_MODEM
suffix:semicolon
)brace
multiline_comment|/*&n; * Accept a D-channel connection (incoming connection). This function&n; * builds and sends a CConnectRsp message and signals DCONN to the ISDN&n; * link level.&n; *&n; * &t;card: the board&n; * &t;channel: the channel number&n; *&n; * Return: 0 if OK, &lt;0 if error.&n; */
DECL|function|tpam_command_acceptd
r_static
r_int
id|tpam_command_acceptd
c_func
(paren
id|tpam_card
op_star
id|card
comma
id|u32
id|channel
)paren
(brace
id|isdn_ctrl
id|ctrl
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;TurboPAM(tpam_command_acceptd): card=%d, channel=%lu&bslash;n&quot;
comma
id|card-&gt;id
comma
(paren
r_int
r_int
)paren
id|channel
)paren
suffix:semicolon
multiline_comment|/* board must be running */
r_if
c_cond
(paren
op_logical_neg
id|card-&gt;running
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
multiline_comment|/* build and send a CConnectRsp */
id|skb
op_assign
id|build_CConnectRsp
c_func
(paren
id|card-&gt;channels
(braket
id|channel
)braket
dot
id|ncoid
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skb
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|tpam_enqueue
c_func
(paren
id|card
comma
id|skb
)paren
suffix:semicolon
multiline_comment|/* issue DCONN to the ISDN link level */
id|ctrl.driver
op_assign
id|card-&gt;id
suffix:semicolon
id|ctrl.command
op_assign
id|ISDN_STAT_DCONN
suffix:semicolon
id|ctrl.arg
op_assign
id|channel
suffix:semicolon
id|tpam_statcallb
c_func
(paren
id|card
comma
id|ctrl
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Accepts a B-channel connection. This is not used by the driver, &n; * since the TurboPAM is an active card hiding its B-channels from&n; * us. We just signal BCONN to the ISDN link layer.&n; *&n; * &t;card: the board&n; * &t;channel: the channel number&n; *&n; * Return: 0 if OK, &lt;0 if error.&n; */
DECL|function|tpam_command_acceptb
r_static
r_int
id|tpam_command_acceptb
c_func
(paren
id|tpam_card
op_star
id|card
comma
id|u32
id|channel
)paren
(brace
id|isdn_ctrl
id|ctrl
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;TurboPAM(tpam_command_acceptb): card=%d, channel=%lu&bslash;n&quot;
comma
id|card-&gt;id
comma
(paren
r_int
r_int
)paren
id|channel
)paren
suffix:semicolon
multiline_comment|/* board must be running */
r_if
c_cond
(paren
op_logical_neg
id|card-&gt;running
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
multiline_comment|/* issue BCONN to the ISDN link level */
id|ctrl.driver
op_assign
id|card-&gt;id
suffix:semicolon
id|ctrl.command
op_assign
id|ISDN_STAT_BCONN
suffix:semicolon
id|ctrl.arg
op_assign
id|channel
suffix:semicolon
id|ctrl.parm.num
(braket
l_int|0
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|tpam_statcallb
c_func
(paren
id|card
comma
id|ctrl
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Hang up a connection. This function builds and sends a CDisconnectReq.&n; *&n; * &t;card: the board&n; * &t;channel: the channel number.&n; *&n; * Return: 0 if OK, &lt;0 if error.&n; */
DECL|function|tpam_command_hangup
r_static
r_int
id|tpam_command_hangup
c_func
(paren
id|tpam_card
op_star
id|card
comma
id|u32
id|channel
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;TurboPAM(tpam_command_hangup): card=%d, channel=%lu&bslash;n&quot;
comma
id|card-&gt;id
comma
(paren
r_int
r_int
)paren
id|channel
)paren
suffix:semicolon
multiline_comment|/* board must be running */
r_if
c_cond
(paren
op_logical_neg
id|card-&gt;running
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
multiline_comment|/* build and send a CDisconnectReq */
id|skb
op_assign
id|build_CDisconnectReq
c_func
(paren
id|card-&gt;channels
(braket
id|channel
)braket
dot
id|ncoid
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skb
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|tpam_enqueue
c_func
(paren
id|card
comma
id|skb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Proceed with an incoming connection. This function builds and sends a &n; * CConnectRsp.&n; *&n; * &t;card: the board&n; * &t;channel: the channel number.&n; *&n; * Return: 0 if OK, &lt;0 if error.&n; */
DECL|function|tpam_command_proceed
r_static
r_int
id|tpam_command_proceed
c_func
(paren
id|tpam_card
op_star
id|card
comma
id|u32
id|channel
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;TurboPAM(tpam_command_proceed): card=%d, channel=%lu&bslash;n&quot;
comma
id|card-&gt;id
comma
(paren
r_int
r_int
)paren
id|channel
)paren
suffix:semicolon
multiline_comment|/* board must be running */
r_if
c_cond
(paren
op_logical_neg
id|card-&gt;running
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
multiline_comment|/* build and send a CConnectRsp */
id|skb
op_assign
id|build_CConnectRsp
c_func
(paren
id|card-&gt;channels
(braket
id|channel
)braket
dot
id|ncoid
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skb
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|tpam_enqueue
c_func
(paren
id|card
comma
id|skb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Send data through the board. This function encodes the data depending&n; * on the connection type (modem or HDLC), then builds and sends a U3DataReq.&n; *&n; * &t;driverId: the driver id (really meaning here the board)&n; * &t;channel: the channel number&n; * &t;ack: data needs to be acknowledged upon send&n; * &t;skb: sk_buff containing the data&n; *&n; * Return: size of data send if OK, &lt;0 if error.&n; */
DECL|function|tpam_writebuf_skb
r_int
id|tpam_writebuf_skb
c_func
(paren
r_int
id|driverId
comma
r_int
id|channel
comma
r_int
id|ack
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
id|tpam_card
op_star
id|card
suffix:semicolon
r_int
id|orig_size
op_assign
id|skb-&gt;len
suffix:semicolon
r_void
op_star
id|finaldata
suffix:semicolon
id|u32
id|finallen
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;TurboPAM(tpam_writebuf_skb): &quot;
l_string|&quot;card=%d, channel=%ld, ack=%d, data size=%d&bslash;n&quot;
comma
id|driverId
comma
(paren
r_int
r_int
)paren
id|channel
comma
id|ack
comma
id|skb-&gt;len
)paren
suffix:semicolon
multiline_comment|/* find the board based on its driver ID */
r_if
c_cond
(paren
op_logical_neg
(paren
id|card
op_assign
id|tpam_findcard
c_func
(paren
id|driverId
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;TurboPAM(tpam_writebuf_skb): &quot;
l_string|&quot;invalid driverId %d&bslash;n&quot;
comma
id|driverId
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/* board must be running */
r_if
c_cond
(paren
op_logical_neg
id|card-&gt;running
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
multiline_comment|/* allocate some temporary memory */
r_if
c_cond
(paren
op_logical_neg
(paren
id|finaldata
op_assign
(paren
r_void
op_star
)paren
id|__get_free_page
c_func
(paren
id|GFP_ATOMIC
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;TurboPAM(tpam_writebuf_skb): &quot;
l_string|&quot;get_free_page failed&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
multiline_comment|/* encode the data */
r_if
c_cond
(paren
op_logical_neg
id|card-&gt;channels
(braket
id|channel
)braket
dot
id|realhdlc
)paren
(brace
multiline_comment|/* modem mode */
id|hdlc_encode_modem
c_func
(paren
id|skb-&gt;data
comma
id|skb-&gt;len
comma
id|finaldata
comma
op_amp
id|finallen
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* HDLC mode */
r_void
op_star
id|tempdata
suffix:semicolon
id|u32
id|templen
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|tempdata
op_assign
(paren
r_void
op_star
)paren
id|__get_free_page
c_func
(paren
id|GFP_ATOMIC
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;TurboPAM(tpam_writebuf_skb): &quot;
l_string|&quot;get_free_page failed&bslash;n&quot;
)paren
suffix:semicolon
id|free_page
c_func
(paren
(paren
id|u32
)paren
id|finaldata
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|hdlc_no_accm_encode
c_func
(paren
id|skb-&gt;data
comma
id|skb-&gt;len
comma
id|tempdata
comma
op_amp
id|templen
)paren
suffix:semicolon
id|finallen
op_assign
id|hdlc_encode
c_func
(paren
id|tempdata
comma
id|finaldata
comma
op_amp
id|card-&gt;channels
(braket
id|channel
)braket
dot
id|hdlcshift
comma
id|templen
)paren
suffix:semicolon
id|free_page
c_func
(paren
(paren
id|u32
)paren
id|tempdata
)paren
suffix:semicolon
)brace
multiline_comment|/* free the old sk_buff */
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
multiline_comment|/* build and send a U3DataReq */
id|skb
op_assign
id|build_U3DataReq
c_func
(paren
id|card-&gt;channels
(braket
id|channel
)braket
dot
id|ncoid
comma
id|finaldata
comma
id|finallen
comma
id|ack
comma
id|orig_size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skb
)paren
(brace
id|free_page
c_func
(paren
(paren
id|u32
)paren
id|finaldata
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|tpam_enqueue_data
c_func
(paren
op_amp
id|card-&gt;channels
(braket
id|channel
)braket
comma
id|skb
)paren
suffix:semicolon
multiline_comment|/* free the temporary memory */
id|free_page
c_func
(paren
(paren
id|u32
)paren
id|finaldata
)paren
suffix:semicolon
r_return
id|orig_size
suffix:semicolon
)brace
multiline_comment|/*&n; * Treat a received ACreateNCOCnf message.&n; *&n; * &t;card: the board&n; * &t;skb: the received message&n; */
DECL|function|tpam_recv_ACreateNCOCnf
r_void
id|tpam_recv_ACreateNCOCnf
c_func
(paren
id|tpam_card
op_star
id|card
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
id|u32
id|ncoid
suffix:semicolon
id|u8
id|status
suffix:semicolon
id|u32
id|channel
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;TurboPAM(tpam_recv_ACreateNCOCnf): card=%d&bslash;n&quot;
comma
id|card-&gt;id
)paren
suffix:semicolon
multiline_comment|/* parse the message contents */
r_if
c_cond
(paren
id|parse_ACreateNCOCnf
c_func
(paren
id|skb
comma
op_amp
id|status
comma
op_amp
id|ncoid
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* if the card is alreay running, it means that this message&n;&t; * arrives too late... */
r_if
c_cond
(paren
id|card-&gt;running
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;TurboPAM(tpam_recv_ACreateNCOCnf): &quot;
l_string|&quot;ACreateNCOCnf received too late, status=%d&bslash;n&quot;
comma
id|status
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* the NCO creation failed, the corresponding channel will&n;&t; * be unused */
r_if
c_cond
(paren
id|status
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;TurboPAM(tpam_recv_ACreateNCOCnf): &quot;
l_string|&quot;ACreateNCO failed, status=%d&bslash;n&quot;
comma
id|status
)paren
suffix:semicolon
id|card-&gt;channels_tested
op_increment
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* find the first free channel and assign the nco ID to it */
r_if
c_cond
(paren
(paren
id|channel
op_assign
id|tpam_findchannel
c_func
(paren
id|card
comma
id|TPAM_NCOID_INVALID
)paren
)paren
op_eq
id|TPAM_CHANNEL_INVALID
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;TurboPAM(tpam_recv_ACreateNCOCnf): &quot;
l_string|&quot;All channels are assigned&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|card-&gt;channels
(braket
id|channel
)braket
dot
id|ncoid
op_assign
id|ncoid
suffix:semicolon
id|card-&gt;channels_tested
op_increment
suffix:semicolon
id|card-&gt;channels_used
op_increment
suffix:semicolon
)brace
multiline_comment|/*&n; * Treat a received ADestroyNCOCnf message. Not used by the driver.&n; *&n; * &t;card: the board&n; * &t;skb: the received message&n; */
DECL|function|tpam_recv_ADestroyNCOCnf
r_void
id|tpam_recv_ADestroyNCOCnf
c_func
(paren
id|tpam_card
op_star
id|card
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
id|u32
id|ncoid
suffix:semicolon
id|u8
id|status
suffix:semicolon
id|u32
id|channel
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;TurboPAM(tpam_recv_ADestroyNCOCnf): card=%d&bslash;n&quot;
comma
id|card-&gt;id
)paren
suffix:semicolon
multiline_comment|/* parse the message contents */
r_if
c_cond
(paren
id|parse_ADestroyNCOCnf
c_func
(paren
id|skb
comma
op_amp
id|status
comma
op_amp
id|ncoid
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|status
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;TurboPAM(tpam_recv_ADestroyNCOCnf): &quot;
l_string|&quot;ADestroyNCO failed, status=%d&bslash;n&quot;
comma
id|status
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* clears the channel&squot;s nco ID */
r_if
c_cond
(paren
(paren
id|channel
op_assign
id|tpam_findchannel
c_func
(paren
id|card
comma
id|ncoid
)paren
)paren
op_eq
id|TPAM_CHANNEL_INVALID
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;TurboPAM(tpam_recv_ADestroyNCOCnf): &quot;
l_string|&quot;ncoid invalid %lu&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|ncoid
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|card-&gt;channels
(braket
id|channel
)braket
dot
id|ncoid
op_assign
id|TPAM_NCOID_INVALID
suffix:semicolon
)brace
multiline_comment|/*&n; * Treat a received CConnectCnf message.&n; *&n; * &t;card: the board&n; * &t;skb: the received message&n; */
DECL|function|tpam_recv_CConnectCnf
r_void
id|tpam_recv_CConnectCnf
c_func
(paren
id|tpam_card
op_star
id|card
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
id|u32
id|ncoid
suffix:semicolon
id|u32
id|channel
suffix:semicolon
id|isdn_ctrl
id|ctrl
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;TurboPAM(tpam_recv_CConnectCnf): card=%d&bslash;n&quot;
comma
id|card-&gt;id
)paren
suffix:semicolon
multiline_comment|/* parse the message contents */
r_if
c_cond
(paren
id|parse_CConnectCnf
c_func
(paren
id|skb
comma
op_amp
id|ncoid
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* find the channel by its nco ID */
r_if
c_cond
(paren
(paren
id|channel
op_assign
id|tpam_findchannel
c_func
(paren
id|card
comma
id|ncoid
)paren
)paren
op_eq
id|TPAM_CHANNEL_INVALID
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;TurboPAM(tpam_recv_CConnectCnf): &quot;
l_string|&quot;ncoid invalid %lu&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|ncoid
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* issue a DCONN command to the ISDN link layer if we are in HDLC mode.&n;&t; * In modem mode, we alreay did it - the ISDN timer kludge */
r_if
c_cond
(paren
id|card-&gt;channels
(braket
id|channel
)braket
dot
id|realhdlc
)paren
(brace
id|ctrl.driver
op_assign
id|card-&gt;id
suffix:semicolon
id|ctrl.command
op_assign
id|ISDN_STAT_DCONN
suffix:semicolon
id|ctrl.arg
op_assign
id|channel
suffix:semicolon
(paren
op_star
id|card-&gt;interface.statcallb
)paren
(paren
op_amp
id|ctrl
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Treat a received CConnectInd message. This function signals a ICALL&n; * to the ISDN link layer.&n; *&n; * &t;card: the board&n; * &t;skb: the received message&n; */
DECL|function|tpam_recv_CConnectInd
r_void
id|tpam_recv_CConnectInd
c_func
(paren
id|tpam_card
op_star
id|card
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
id|u32
id|ncoid
suffix:semicolon
id|u32
id|channel
suffix:semicolon
id|u8
id|hdlc
comma
id|plan
comma
id|screen
suffix:semicolon
id|u8
id|calling
(braket
id|PHONE_MAXIMUMSIZE
)braket
comma
id|called
(braket
id|PHONE_MAXIMUMSIZE
)braket
suffix:semicolon
id|isdn_ctrl
id|ctrl
suffix:semicolon
r_int
id|status
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;TurboPAM(tpam_recv_CConnectInd): card=%d&bslash;n&quot;
comma
id|card-&gt;id
)paren
suffix:semicolon
multiline_comment|/* parse the message contents */
r_if
c_cond
(paren
id|parse_CConnectInd
c_func
(paren
id|skb
comma
op_amp
id|ncoid
comma
op_amp
id|hdlc
comma
id|calling
comma
id|called
comma
op_amp
id|plan
comma
op_amp
id|screen
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* find the channel by its nco ID */
r_if
c_cond
(paren
(paren
id|channel
op_assign
id|tpam_findchannel
c_func
(paren
id|card
comma
id|ncoid
)paren
)paren
op_eq
id|TPAM_CHANNEL_INVALID
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;TurboPAM(tpam_recv_CConnectInd): &quot;
l_string|&quot;ncoid invalid %lu&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|ncoid
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* initialize the channel parameters */
id|card-&gt;channels
(braket
id|channel
)braket
dot
id|realhdlc
op_assign
id|hdlc
suffix:semicolon
id|card-&gt;channels
(braket
id|channel
)braket
dot
id|hdlcshift
op_assign
l_int|0
suffix:semicolon
id|card-&gt;channels
(braket
id|channel
)braket
dot
id|readytoreceive
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* issue a ICALL command to the ISDN link layer */
id|ctrl.driver
op_assign
id|card-&gt;id
suffix:semicolon
id|ctrl.command
op_assign
id|ISDN_STAT_ICALL
suffix:semicolon
id|ctrl.arg
op_assign
id|channel
suffix:semicolon
id|memcpy
c_func
(paren
id|ctrl.parm.setup.phone
comma
id|calling
comma
l_int|32
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|ctrl.parm.setup.eazmsn
comma
id|called
comma
l_int|32
)paren
suffix:semicolon
id|ctrl.parm.setup.si1
op_assign
l_int|7
suffix:semicolon
multiline_comment|/* data capability */
id|ctrl.parm.setup.si2
op_assign
l_int|0
suffix:semicolon
id|ctrl.parm.setup.plan
op_assign
id|plan
suffix:semicolon
id|ctrl.parm.setup.screen
op_assign
id|screen
suffix:semicolon
id|status
op_assign
(paren
op_star
id|card-&gt;interface.statcallb
)paren
(paren
op_amp
id|ctrl
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|status
)paren
(brace
r_case
l_int|1
suffix:colon
r_case
l_int|4
suffix:colon
multiline_comment|/* call accepted, link layer will send us a ACCEPTD &n;&t;&t;&t; * command later */
id|dprintk
c_func
(paren
l_string|&quot;TurboPAM(tpam_recv_CConnectInd): &quot;
l_string|&quot;card=%d, channel=%d, icall waiting, status=%d&bslash;n&quot;
comma
id|card-&gt;id
comma
id|channel
comma
id|status
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* call denied, we build and send a CDisconnectReq */
id|dprintk
c_func
(paren
l_string|&quot;TurboPAM(tpam_recv_CConnectInd): &quot;
l_string|&quot;card=%d, channel=%d, icall denied, status=%d&bslash;n&quot;
comma
id|card-&gt;id
comma
id|channel
comma
id|status
)paren
suffix:semicolon
id|skb
op_assign
id|build_CDisconnectReq
c_func
(paren
id|ncoid
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skb
)paren
r_return
suffix:semicolon
id|tpam_enqueue
c_func
(paren
id|card
comma
id|skb
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Treat a received CDisconnectInd message. This function signals a DHUP and&n; * a BHUP to the ISDN link layer.&n; *&n; * &t;card: the board&n; * &t;skb: the received message&n; */
DECL|function|tpam_recv_CDisconnectInd
r_void
id|tpam_recv_CDisconnectInd
c_func
(paren
id|tpam_card
op_star
id|card
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
id|u32
id|ncoid
suffix:semicolon
id|u32
id|channel
suffix:semicolon
id|u32
id|cause
suffix:semicolon
id|isdn_ctrl
id|ctrl
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;TurboPAM(tpam_recv_CDisconnectInd): card=%d&bslash;n&quot;
comma
id|card-&gt;id
)paren
suffix:semicolon
multiline_comment|/* parse the message contents */
r_if
c_cond
(paren
id|parse_CDisconnectInd
c_func
(paren
id|skb
comma
op_amp
id|ncoid
comma
op_amp
id|cause
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* find the channel by its nco ID */
r_if
c_cond
(paren
(paren
id|channel
op_assign
id|tpam_findchannel
c_func
(paren
id|card
comma
id|ncoid
)paren
)paren
op_eq
id|TPAM_CHANNEL_INVALID
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;TurboPAM(tpam_recv_CDisconnectInd): &quot;
l_string|&quot;ncoid invalid %lu&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|ncoid
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* build and send a CDisconnectRsp */
id|skb
op_assign
id|build_CDisconnectRsp
c_func
(paren
id|ncoid
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skb
)paren
r_return
suffix:semicolon
id|tpam_enqueue
c_func
(paren
id|card
comma
id|skb
)paren
suffix:semicolon
multiline_comment|/* issue a DHUP to the ISDN link layer */
id|ctrl.driver
op_assign
id|card-&gt;id
suffix:semicolon
id|ctrl.command
op_assign
id|ISDN_STAT_DHUP
suffix:semicolon
id|ctrl.arg
op_assign
id|channel
suffix:semicolon
(paren
op_star
id|card-&gt;interface.statcallb
)paren
(paren
op_amp
id|ctrl
)paren
suffix:semicolon
multiline_comment|/* issue a BHUP to the ISDN link layer */
id|ctrl.driver
op_assign
id|card-&gt;id
suffix:semicolon
id|ctrl.command
op_assign
id|ISDN_STAT_BHUP
suffix:semicolon
id|ctrl.arg
op_assign
id|channel
suffix:semicolon
(paren
op_star
id|card-&gt;interface.statcallb
)paren
(paren
op_amp
id|ctrl
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Treat a received CDisconnectCnf message. This function signals a DHUP and&n; * a BHUP to the ISDN link layer.&n; *&n; * &t;card: the board&n; * &t;skb: the received message&n; */
DECL|function|tpam_recv_CDisconnectCnf
r_void
id|tpam_recv_CDisconnectCnf
c_func
(paren
id|tpam_card
op_star
id|card
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
id|u32
id|ncoid
suffix:semicolon
id|u32
id|channel
suffix:semicolon
id|u32
id|cause
suffix:semicolon
id|isdn_ctrl
id|ctrl
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;TurboPAM(tpam_recv_CDisconnectCnf): card=%d&bslash;n&quot;
comma
id|card-&gt;id
)paren
suffix:semicolon
multiline_comment|/* parse the message contents */
r_if
c_cond
(paren
id|parse_CDisconnectCnf
c_func
(paren
id|skb
comma
op_amp
id|ncoid
comma
op_amp
id|cause
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* find the channel by its nco ID */
r_if
c_cond
(paren
(paren
id|channel
op_assign
id|tpam_findchannel
c_func
(paren
id|card
comma
id|ncoid
)paren
)paren
op_eq
id|TPAM_CHANNEL_INVALID
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;TurboPAM(tpam_recv_CDisconnectCnf): &quot;
l_string|&quot;ncoid invalid %lu&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|ncoid
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* issue a DHUP to the ISDN link layer */
id|ctrl.driver
op_assign
id|card-&gt;id
suffix:semicolon
id|ctrl.command
op_assign
id|ISDN_STAT_DHUP
suffix:semicolon
id|ctrl.arg
op_assign
id|channel
suffix:semicolon
(paren
op_star
id|card-&gt;interface.statcallb
)paren
(paren
op_amp
id|ctrl
)paren
suffix:semicolon
multiline_comment|/* issue a BHUP to the ISDN link layer */
id|ctrl.driver
op_assign
id|card-&gt;id
suffix:semicolon
id|ctrl.command
op_assign
id|ISDN_STAT_BHUP
suffix:semicolon
id|ctrl.arg
op_assign
id|channel
suffix:semicolon
(paren
op_star
id|card-&gt;interface.statcallb
)paren
(paren
op_amp
id|ctrl
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Treat a received U3DataInd message. This function decodes the data&n; * depending on the connection type (modem or HDLC) and passes it to the&n; * ISDN link layer by using rcvcallb_skb.&n; *&n; * &t;card: the board&n; * &t;skb: the received message + data&n; */
DECL|function|tpam_recv_U3DataInd
r_void
id|tpam_recv_U3DataInd
c_func
(paren
id|tpam_card
op_star
id|card
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
id|u32
id|ncoid
suffix:semicolon
id|u32
id|channel
suffix:semicolon
id|u8
op_star
id|data
suffix:semicolon
id|u16
id|len
suffix:semicolon
r_struct
id|sk_buff
op_star
id|result
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;TurboPAM(tpam_recv_U3DataInd): card=%d, datalen=%d&bslash;n&quot;
comma
id|card-&gt;id
comma
id|skb-&gt;len
)paren
suffix:semicolon
multiline_comment|/* parse the message contents */
r_if
c_cond
(paren
id|parse_U3DataInd
c_func
(paren
id|skb
comma
op_amp
id|ncoid
comma
op_amp
id|data
comma
op_amp
id|len
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* find the channel by its nco ID */
r_if
c_cond
(paren
(paren
id|channel
op_assign
id|tpam_findchannel
c_func
(paren
id|card
comma
id|ncoid
)paren
)paren
op_eq
id|TPAM_CHANNEL_INVALID
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;TurboPAM(tpam_recv_U3DataInd): &quot;
l_string|&quot;ncoid invalid %lu&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|ncoid
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* decode the data */
r_if
c_cond
(paren
id|card-&gt;channels
(braket
id|ncoid
)braket
dot
id|realhdlc
)paren
(brace
multiline_comment|/* HDLC mode */
id|u8
op_star
id|tempdata
suffix:semicolon
id|u32
id|templen
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|tempdata
op_assign
(paren
r_void
op_star
)paren
id|__get_free_page
c_func
(paren
id|GFP_ATOMIC
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;TurboPAM(tpam_recv_U3DataInd): &quot;
l_string|&quot;get_free_page failed&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|templen
op_assign
id|hdlc_decode
c_func
(paren
id|data
comma
id|tempdata
comma
id|len
)paren
suffix:semicolon
id|templen
op_assign
id|hdlc_no_accm_decode
c_func
(paren
id|tempdata
comma
id|templen
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|result
op_assign
id|alloc_skb
c_func
(paren
id|templen
comma
id|GFP_ATOMIC
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;TurboPAM(tpam_recv_U3DataInd): &quot;
l_string|&quot;alloc_skb failed&bslash;n&quot;
)paren
suffix:semicolon
id|free_page
c_func
(paren
(paren
id|u32
)paren
id|tempdata
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|skb_put
c_func
(paren
id|result
comma
id|templen
)paren
comma
id|tempdata
comma
id|templen
)paren
suffix:semicolon
id|free_page
c_func
(paren
(paren
id|u32
)paren
id|tempdata
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* modem mode */
r_if
c_cond
(paren
op_logical_neg
(paren
id|result
op_assign
id|alloc_skb
c_func
(paren
id|len
comma
id|GFP_ATOMIC
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;TurboPAM(tpam_recv_U3DataInd): &quot;
l_string|&quot;alloc_skb failed&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|skb_put
c_func
(paren
id|result
comma
id|len
)paren
comma
id|data
comma
id|len
)paren
suffix:semicolon
)brace
multiline_comment|/* In loop mode, resend the data immediatly */
r_if
c_cond
(paren
id|card-&gt;loopmode
)paren
(brace
r_struct
id|sk_buff
op_star
id|loopskb
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|loopskb
op_assign
id|alloc_skb
c_func
(paren
id|skb-&gt;len
comma
id|GFP_ATOMIC
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;TurboPAM(tpam_recv_U3DataInd): &quot;
l_string|&quot;alloc_skb failed&bslash;n&quot;
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|result
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|skb_put
c_func
(paren
id|loopskb
comma
id|result-&gt;len
)paren
comma
id|result-&gt;data
comma
id|result-&gt;len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tpam_writebuf_skb
c_func
(paren
id|card-&gt;id
comma
id|channel
comma
l_int|0
comma
id|loopskb
)paren
OL
l_int|0
)paren
id|kfree_skb
c_func
(paren
id|loopskb
)paren
suffix:semicolon
)brace
multiline_comment|/* pass the data to the ISDN link layer */
(paren
op_star
id|card-&gt;interface.rcvcallb_skb
)paren
(paren
id|card-&gt;id
comma
id|channel
comma
id|result
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Treat a received U3ReadyToReceiveInd message. This function sets the&n; * channel ready flag and triggers the send of data if the channel becomed&n; * ready.&n; *&n; * &t;card: the board&n; * &t;skb: the received message + data&n; */
DECL|function|tpam_recv_U3ReadyToReceiveInd
r_void
id|tpam_recv_U3ReadyToReceiveInd
c_func
(paren
id|tpam_card
op_star
id|card
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
id|u32
id|ncoid
suffix:semicolon
id|u32
id|channel
suffix:semicolon
id|u8
id|ready
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;TurboPAM(tpam_recv_U3ReadyToReceiveInd): card=%d&bslash;n&quot;
comma
id|card-&gt;id
)paren
suffix:semicolon
multiline_comment|/* parse the message contents */
r_if
c_cond
(paren
id|parse_U3ReadyToReceiveInd
c_func
(paren
id|skb
comma
op_amp
id|ncoid
comma
op_amp
id|ready
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* find the channel by its nco ID */
r_if
c_cond
(paren
(paren
id|channel
op_assign
id|tpam_findchannel
c_func
(paren
id|card
comma
id|ncoid
)paren
)paren
op_eq
id|TPAM_CHANNEL_INVALID
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;TurboPAM(tpam_recv_U3ReadyToReceiveInd): &quot;
l_string|&quot;ncoid invalid %lu&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|ncoid
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* set the readytoreceive flag */
id|card-&gt;channels
(braket
id|channel
)braket
dot
id|readytoreceive
op_assign
id|ready
suffix:semicolon
multiline_comment|/* if the channel just becomed ready, trigger the send of queued data */
r_if
c_cond
(paren
id|ready
)paren
id|tpam_enqueue_data
c_func
(paren
op_amp
id|card-&gt;channels
(braket
id|channel
)braket
comma
l_int|NULL
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Runs the delayed statcallb when its timer expires.&n; *&n; * &t;parm: pointer to the tpam_statcallb_data statcallb argument.&n; */
DECL|function|tpam_statcallb_run
r_static
r_void
id|tpam_statcallb_run
c_func
(paren
r_int
r_int
id|parm
)paren
(brace
id|tpam_statcallb_data
op_star
id|ds
op_assign
(paren
id|tpam_statcallb_data
op_star
)paren
id|parm
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;TurboPAM(tpam_statcallb_run)&bslash;n&quot;
)paren
suffix:semicolon
(paren
op_star
id|ds-&gt;card-&gt;interface.statcallb
)paren
(paren
op_amp
id|ds-&gt;ctrl
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|ds-&gt;timer
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|ds
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Queues a statcallb call for delayed invocation.&n; *&n; * &t;card: the board&n; * &t;ctrl: the statcallb argument&n; */
DECL|function|tpam_statcallb
r_static
r_void
id|tpam_statcallb
c_func
(paren
id|tpam_card
op_star
id|card
comma
id|isdn_ctrl
id|ctrl
)paren
(brace
r_struct
id|timer_list
op_star
id|timer
suffix:semicolon
id|tpam_statcallb_data
op_star
id|ds
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;TurboPAM(tpam_statcallb): card=%d&bslash;n&quot;
comma
id|card-&gt;id
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|timer
op_assign
(paren
r_struct
id|timer_list
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|timer_list
)paren
comma
id|GFP_ATOMIC
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;TurboPAM: tpam_statcallb: kmalloc failed!&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|ds
op_assign
(paren
id|tpam_statcallb_data
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|tpam_statcallb_data
)paren
comma
id|GFP_ATOMIC
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;TurboPAM: tpam_statcallb: kmalloc failed!&bslash;n&quot;
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|timer
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|ds-&gt;card
op_assign
id|card
suffix:semicolon
id|ds-&gt;timer
op_assign
id|timer
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|ds-&gt;ctrl
comma
op_amp
id|ctrl
comma
r_sizeof
(paren
id|isdn_ctrl
)paren
)paren
suffix:semicolon
id|init_timer
c_func
(paren
id|timer
)paren
suffix:semicolon
id|timer-&gt;function
op_assign
id|tpam_statcallb_run
suffix:semicolon
id|timer-&gt;data
op_assign
(paren
r_int
r_int
)paren
id|ds
suffix:semicolon
id|timer-&gt;expires
op_assign
id|jiffies
op_plus
l_float|0.1
op_star
id|HZ
suffix:semicolon
multiline_comment|/* 0.1 second */
id|add_timer
c_func
(paren
id|timer
)paren
suffix:semicolon
)brace
eof
