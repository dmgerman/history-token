multiline_comment|/*&n; *  Copyright (C) 2002&t;&t;Marcin Dalecki &lt;martin@dalecki.de&gt;&n; *  Copyright (C) 2000&t;&t;Michael Cornwell &lt;cornwell@acm.org&gt;&n; *  Copyright (C) 2000&t;&t;Andre Hedrick &lt;andre@linux-ide.org&gt;&n; *&n; *  May be copied or modified under the terms of the GNU General Public License&n; */
macro_line|#include &lt;linux/config.h&gt;
DECL|macro|__NO_VERSION__
mdefine_line|#define __NO_VERSION__
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/major.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/genhd.h&gt;
macro_line|#include &lt;linux/blkpg.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/hdreg.h&gt;
macro_line|#include &lt;linux/ide.h&gt;
macro_line|#include &lt;asm/byteorder.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
DECL|macro|DEBUG_TASKFILE
mdefine_line|#define DEBUG_TASKFILE&t;0&t;/* unset when fixed */
macro_line|#if DEBUG_TASKFILE
DECL|macro|DTF
mdefine_line|#define DTF(x...) printk(##x)
macro_line|#else
DECL|macro|DTF
mdefine_line|#define DTF(x...)
macro_line|#endif
DECL|macro|SUPPORT_VLB_SYNC
mdefine_line|#define SUPPORT_VLB_SYNC 1
multiline_comment|/*&n; * for now, taskfile requests are special :/&n; */
DECL|function|ide_map_rq
r_static
r_inline
r_char
op_star
id|ide_map_rq
c_func
(paren
r_struct
id|request
op_star
id|rq
comma
r_int
r_int
op_star
id|flags
)paren
(brace
r_if
c_cond
(paren
id|rq-&gt;bio
)paren
r_return
id|bio_kmap_irq
c_func
(paren
id|rq-&gt;bio
comma
id|flags
)paren
op_plus
id|ide_rq_offset
c_func
(paren
id|rq
)paren
suffix:semicolon
r_else
r_return
id|rq-&gt;buffer
op_plus
(paren
(paren
id|rq
)paren
op_member_access_from_pointer
id|nr_sectors
op_minus
(paren
id|rq
)paren
op_member_access_from_pointer
id|current_nr_sectors
)paren
op_star
id|SECTOR_SIZE
suffix:semicolon
)brace
DECL|function|ide_unmap_rq
r_static
r_inline
r_void
id|ide_unmap_rq
c_func
(paren
r_struct
id|request
op_star
id|rq
comma
r_char
op_star
id|to
comma
r_int
r_int
op_star
id|flags
)paren
(brace
r_if
c_cond
(paren
id|rq-&gt;bio
)paren
id|bio_kunmap_irq
c_func
(paren
id|to
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Data transfer functions for polled IO.&n; */
macro_line|#if SUPPORT_VLB_SYNC
multiline_comment|/*&n; * Some localbus EIDE interfaces require a special access sequence&n; * when using 32-bit I/O instructions to transfer data.  We call this&n; * the &quot;vlb_sync&quot; sequence, which consists of three successive reads&n; * of the sector count register location, with interrupts disabled&n; * to ensure that the reads all happen together.&n; */
DECL|function|ata_read_vlb
r_static
r_void
id|ata_read_vlb
c_func
(paren
r_struct
id|ata_device
op_star
id|drive
comma
r_void
op_star
id|buffer
comma
r_int
r_int
id|wcount
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|__save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* local CPU only */
id|__cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* local CPU only */
id|IN_BYTE
c_func
(paren
id|IDE_NSECTOR_REG
)paren
suffix:semicolon
id|IN_BYTE
c_func
(paren
id|IDE_NSECTOR_REG
)paren
suffix:semicolon
id|IN_BYTE
c_func
(paren
id|IDE_NSECTOR_REG
)paren
suffix:semicolon
id|insl
c_func
(paren
id|IDE_DATA_REG
comma
id|buffer
comma
id|wcount
)paren
suffix:semicolon
id|__restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* local CPU only */
)brace
DECL|function|ata_write_vlb
r_static
r_void
id|ata_write_vlb
c_func
(paren
r_struct
id|ata_device
op_star
id|drive
comma
r_void
op_star
id|buffer
comma
r_int
r_int
id|wcount
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|__save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* local CPU only */
id|__cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* local CPU only */
id|IN_BYTE
c_func
(paren
id|IDE_NSECTOR_REG
)paren
suffix:semicolon
id|IN_BYTE
c_func
(paren
id|IDE_NSECTOR_REG
)paren
suffix:semicolon
id|IN_BYTE
c_func
(paren
id|IDE_NSECTOR_REG
)paren
suffix:semicolon
id|outsl
c_func
(paren
id|IDE_DATA_REG
comma
id|buffer
comma
id|wcount
)paren
suffix:semicolon
id|__restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* local CPU only */
)brace
macro_line|#endif
DECL|function|ata_read_32
r_static
r_void
id|ata_read_32
c_func
(paren
r_struct
id|ata_device
op_star
id|drive
comma
r_void
op_star
id|buffer
comma
r_int
r_int
id|wcount
)paren
(brace
id|insl
c_func
(paren
id|IDE_DATA_REG
comma
id|buffer
comma
id|wcount
)paren
suffix:semicolon
)brace
DECL|function|ata_write_32
r_static
r_void
id|ata_write_32
c_func
(paren
r_struct
id|ata_device
op_star
id|drive
comma
r_void
op_star
id|buffer
comma
r_int
r_int
id|wcount
)paren
(brace
id|outsl
c_func
(paren
id|IDE_DATA_REG
comma
id|buffer
comma
id|wcount
)paren
suffix:semicolon
)brace
macro_line|#if SUPPORT_SLOW_DATA_PORTS
DECL|function|ata_read_slow
r_static
r_void
id|ata_read_slow
c_func
(paren
r_struct
id|ata_device
op_star
id|drive
comma
r_void
op_star
id|buffer
comma
r_int
r_int
id|wcount
)paren
(brace
r_int
r_int
op_star
id|ptr
op_assign
(paren
r_int
r_int
op_star
)paren
id|buffer
suffix:semicolon
r_while
c_loop
(paren
id|wcount
op_decrement
)paren
(brace
op_star
id|ptr
op_increment
op_assign
id|inw_p
c_func
(paren
id|IDE_DATA_REG
)paren
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
id|inw_p
c_func
(paren
id|IDE_DATA_REG
)paren
suffix:semicolon
)brace
)brace
DECL|function|ata_write_slow
r_static
r_void
id|ata_write_slow
c_func
(paren
r_struct
id|ata_device
op_star
id|drive
comma
r_void
op_star
id|buffer
comma
r_int
r_int
id|wcount
)paren
(brace
r_int
r_int
op_star
id|ptr
op_assign
(paren
r_int
r_int
op_star
)paren
id|buffer
suffix:semicolon
r_while
c_loop
(paren
id|wcount
op_decrement
)paren
(brace
id|outw_p
c_func
(paren
op_star
id|ptr
op_increment
comma
id|IDE_DATA_REG
)paren
suffix:semicolon
id|outw_p
c_func
(paren
op_star
id|ptr
op_increment
comma
id|IDE_DATA_REG
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
DECL|function|ata_read_16
r_static
r_void
id|ata_read_16
c_func
(paren
id|ide_drive_t
op_star
id|drive
comma
r_void
op_star
id|buffer
comma
r_int
r_int
id|wcount
)paren
(brace
id|insw
c_func
(paren
id|IDE_DATA_REG
comma
id|buffer
comma
id|wcount
op_lshift
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|ata_write_16
r_static
r_void
id|ata_write_16
c_func
(paren
id|ide_drive_t
op_star
id|drive
comma
r_void
op_star
id|buffer
comma
r_int
r_int
id|wcount
)paren
(brace
id|outsw
c_func
(paren
id|IDE_DATA_REG
comma
id|buffer
comma
id|wcount
op_lshift
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This is used for most PIO data transfers *from* the device.&n; */
DECL|function|ata_read
r_void
id|ata_read
c_func
(paren
id|ide_drive_t
op_star
id|drive
comma
r_void
op_star
id|buffer
comma
r_int
r_int
id|wcount
)paren
(brace
r_int
id|io_32bit
suffix:semicolon
multiline_comment|/*&n;&t; * First check if this controller has defined a special function&n;&t; * for handling polled ide transfers.&n;&t; */
r_if
c_cond
(paren
id|drive-&gt;channel-&gt;ata_read
)paren
(brace
id|drive-&gt;channel
op_member_access_from_pointer
id|ata_read
c_func
(paren
id|drive
comma
id|buffer
comma
id|wcount
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|io_32bit
op_assign
id|drive-&gt;channel-&gt;io_32bit
suffix:semicolon
r_if
c_cond
(paren
id|io_32bit
)paren
(brace
macro_line|#if SUPPORT_VLB_SYNC
r_if
c_cond
(paren
id|io_32bit
op_amp
l_int|2
)paren
id|ata_read_vlb
c_func
(paren
id|drive
comma
id|buffer
comma
id|wcount
)paren
suffix:semicolon
r_else
macro_line|#endif
id|ata_read_32
c_func
(paren
id|drive
comma
id|buffer
comma
id|wcount
)paren
suffix:semicolon
)brace
r_else
(brace
macro_line|#if SUPPORT_SLOW_DATA_PORTS
r_if
c_cond
(paren
id|drive-&gt;channel-&gt;slow
)paren
id|ata_read_slow
c_func
(paren
id|drive
comma
id|buffer
comma
id|wcount
)paren
suffix:semicolon
r_else
macro_line|#endif
id|ata_read_16
c_func
(paren
id|drive
comma
id|buffer
comma
id|wcount
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * This is used for most PIO data transfers *to* the device interface.&n; */
DECL|function|ata_write
r_void
id|ata_write
c_func
(paren
id|ide_drive_t
op_star
id|drive
comma
r_void
op_star
id|buffer
comma
r_int
r_int
id|wcount
)paren
(brace
r_int
id|io_32bit
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;channel-&gt;ata_write
)paren
(brace
id|drive-&gt;channel
op_member_access_from_pointer
id|ata_write
c_func
(paren
id|drive
comma
id|buffer
comma
id|wcount
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|io_32bit
op_assign
id|drive-&gt;channel-&gt;io_32bit
suffix:semicolon
r_if
c_cond
(paren
id|io_32bit
)paren
(brace
macro_line|#if SUPPORT_VLB_SYNC
r_if
c_cond
(paren
id|io_32bit
op_amp
l_int|2
)paren
id|ata_write_vlb
c_func
(paren
id|drive
comma
id|buffer
comma
id|wcount
)paren
suffix:semicolon
r_else
macro_line|#endif
id|ata_write_32
c_func
(paren
id|drive
comma
id|buffer
comma
id|wcount
)paren
suffix:semicolon
)brace
r_else
(brace
macro_line|#if SUPPORT_SLOW_DATA_PORTS
r_if
c_cond
(paren
id|drive-&gt;channel-&gt;slow
)paren
id|ata_write_slow
c_func
(paren
id|drive
comma
id|buffer
comma
id|wcount
)paren
suffix:semicolon
r_else
macro_line|#endif
id|ata_write_16
c_func
(paren
id|drive
comma
id|buffer
comma
id|wcount
op_lshift
l_int|1
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * The following routines are mainly used by the ATAPI drivers.&n; *&n; * These routines will round up any request for an odd number of bytes,&n; * so if an odd bytecount is specified, be sure that there&squot;s at least one&n; * extra byte allocated for the buffer.&n; */
DECL|function|atapi_read
r_void
id|atapi_read
c_func
(paren
id|ide_drive_t
op_star
id|drive
comma
r_void
op_star
id|buffer
comma
r_int
r_int
id|bytecount
)paren
(brace
r_if
c_cond
(paren
id|drive-&gt;channel-&gt;atapi_read
)paren
(brace
id|drive-&gt;channel
op_member_access_from_pointer
id|atapi_read
c_func
(paren
id|drive
comma
id|buffer
comma
id|bytecount
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
op_increment
id|bytecount
suffix:semicolon
macro_line|#if defined(CONFIG_ATARI) || defined(CONFIG_Q40)
r_if
c_cond
(paren
id|MACH_IS_ATARI
op_logical_or
id|MACH_IS_Q40
)paren
(brace
multiline_comment|/* Atari has a byte-swapped IDE interface */
id|insw_swapw
c_func
(paren
id|IDE_DATA_REG
comma
id|buffer
comma
id|bytecount
op_div
l_int|2
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#endif
id|ata_read
c_func
(paren
id|drive
comma
id|buffer
comma
id|bytecount
op_div
l_int|4
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bytecount
op_amp
l_int|0x03
)paren
op_ge
l_int|2
)paren
id|insw
c_func
(paren
id|IDE_DATA_REG
comma
(paren
(paren
id|byte
op_star
)paren
id|buffer
)paren
op_plus
(paren
id|bytecount
op_amp
op_complement
l_int|0x03
)paren
comma
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|atapi_write
r_void
id|atapi_write
c_func
(paren
id|ide_drive_t
op_star
id|drive
comma
r_void
op_star
id|buffer
comma
r_int
r_int
id|bytecount
)paren
(brace
r_if
c_cond
(paren
id|drive-&gt;channel-&gt;atapi_write
)paren
(brace
id|drive-&gt;channel
op_member_access_from_pointer
id|atapi_write
c_func
(paren
id|drive
comma
id|buffer
comma
id|bytecount
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
op_increment
id|bytecount
suffix:semicolon
macro_line|#if defined(CONFIG_ATARI) || defined(CONFIG_Q40)
r_if
c_cond
(paren
id|MACH_IS_ATARI
op_logical_or
id|MACH_IS_Q40
)paren
(brace
multiline_comment|/* Atari has a byte-swapped IDE interface */
id|outsw_swapw
c_func
(paren
id|IDE_DATA_REG
comma
id|buffer
comma
id|bytecount
op_div
l_int|2
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#endif
id|ata_write
c_func
(paren
id|drive
comma
id|buffer
comma
id|bytecount
op_div
l_int|4
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bytecount
op_amp
l_int|0x03
)paren
op_ge
l_int|2
)paren
id|outsw
c_func
(paren
id|IDE_DATA_REG
comma
(paren
(paren
id|byte
op_star
)paren
id|buffer
)paren
op_plus
(paren
id|bytecount
op_amp
op_complement
l_int|0x03
)paren
comma
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Needed for PCI irq sharing&n; */
DECL|function|drive_is_ready
r_int
id|drive_is_ready
c_func
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|byte
id|stat
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;waiting_for_dma
)paren
r_return
id|drive-&gt;channel
op_member_access_from_pointer
id|udma
c_func
(paren
id|ide_dma_test_irq
comma
id|drive
comma
l_int|NULL
)paren
suffix:semicolon
macro_line|#if 0
multiline_comment|/* need to guarantee 400ns since last command was issued */
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_IDEPCI_SHARE_IRQ
multiline_comment|/*&n;&t; * We do a passive status test under shared PCI interrupts on&n;&t; * cards that truly share the ATA side interrupt, but may also share&n;&t; * an interrupt with another pci card/device.  We make no assumptions&n;&t; * about possible isa-pnp and pci-pnp issues yet.&n;&t; */
r_if
c_cond
(paren
id|IDE_CONTROL_REG
)paren
id|stat
op_assign
id|GET_ALTSTAT
c_func
(paren
)paren
suffix:semicolon
r_else
macro_line|#endif
id|stat
op_assign
id|GET_STAT
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Note: this may clear a pending IRQ!! */
r_if
c_cond
(paren
id|stat
op_amp
id|BUSY_STAT
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* drive busy:  definitely not interrupting */
r_return
l_int|1
suffix:semicolon
multiline_comment|/* drive ready: *might* be interrupting */
)brace
multiline_comment|/*&n; * Polling wait until the drive is ready.&n; *&n; * Stuff the first sector(s) by implicitly calling the handler driectly&n; * therafter.&n; */
DECL|function|ata_poll_drive_ready
r_void
id|ata_poll_drive_ready
c_func
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|drive_is_ready
c_func
(paren
id|drive
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* FIXME: Replace hard-coded 100, what about error handling?&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|100
suffix:semicolon
op_increment
id|i
)paren
(brace
r_if
c_cond
(paren
id|drive_is_ready
c_func
(paren
id|drive
)paren
)paren
r_break
suffix:semicolon
)brace
)brace
DECL|function|pre_task_mulout_intr
r_static
id|ide_startstop_t
id|pre_task_mulout_intr
c_func
(paren
r_struct
id|ata_device
op_star
id|drive
comma
r_struct
id|request
op_star
id|rq
)paren
(brace
r_struct
id|ata_taskfile
op_star
id|args
op_assign
id|rq-&gt;special
suffix:semicolon
id|ide_startstop_t
id|startstop
suffix:semicolon
r_if
c_cond
(paren
id|ide_wait_stat
c_func
(paren
op_amp
id|startstop
comma
id|drive
comma
id|DATA_READY
comma
id|drive-&gt;bad_wstat
comma
id|WAIT_DRQ
)paren
)paren
r_return
id|startstop
suffix:semicolon
id|ata_poll_drive_ready
c_func
(paren
id|drive
)paren
suffix:semicolon
r_return
id|args
op_member_access_from_pointer
id|handler
c_func
(paren
id|drive
comma
id|rq
)paren
suffix:semicolon
)brace
DECL|function|task_mulout_intr
r_static
id|ide_startstop_t
id|task_mulout_intr
c_func
(paren
r_struct
id|ata_device
op_star
id|drive
comma
r_struct
id|request
op_star
id|rq
)paren
(brace
id|u8
id|stat
op_assign
id|GET_STAT
c_func
(paren
)paren
suffix:semicolon
id|ide_hwgroup_t
op_star
id|hwgroup
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
suffix:semicolon
r_int
id|mcount
op_assign
id|drive-&gt;mult_count
suffix:semicolon
id|ide_startstop_t
id|startstop
suffix:semicolon
multiline_comment|/*&n;&t; * (ks/hs): Handle last IRQ on multi-sector transfer,&n;&t; * occurs after all data was sent in this chunk&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|rq-&gt;nr_sectors
)paren
(brace
r_if
c_cond
(paren
id|stat
op_amp
(paren
id|ERR_STAT
op_or
id|DRQ_STAT
)paren
)paren
(brace
id|startstop
op_assign
id|ide_error
c_func
(paren
id|drive
comma
l_string|&quot;task_mulout_intr&quot;
comma
id|stat
)paren
suffix:semicolon
r_return
id|startstop
suffix:semicolon
)brace
id|__ide_end_request
c_func
(paren
id|drive
comma
id|rq
comma
l_int|1
comma
id|rq-&gt;hard_nr_sectors
)paren
suffix:semicolon
id|rq-&gt;bio
op_assign
l_int|NULL
suffix:semicolon
r_return
id|ide_stopped
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|OK_STAT
c_func
(paren
id|stat
comma
id|DATA_READY
comma
id|BAD_R_STAT
)paren
)paren
(brace
r_if
c_cond
(paren
id|stat
op_amp
(paren
id|ERR_STAT
op_or
id|DRQ_STAT
)paren
)paren
(brace
id|startstop
op_assign
id|ide_error
c_func
(paren
id|drive
comma
l_string|&quot;task_mulout_intr&quot;
comma
id|stat
)paren
suffix:semicolon
r_return
id|startstop
suffix:semicolon
)brace
multiline_comment|/* no data yet, so wait for another interrupt */
r_if
c_cond
(paren
id|hwgroup-&gt;handler
op_eq
l_int|NULL
)paren
id|ide_set_handler
c_func
(paren
id|drive
comma
id|task_mulout_intr
comma
id|WAIT_CMD
comma
l_int|NULL
)paren
suffix:semicolon
r_return
id|ide_started
suffix:semicolon
)brace
r_do
(brace
r_char
op_star
id|buffer
suffix:semicolon
r_int
id|nsect
op_assign
id|rq-&gt;current_nr_sectors
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|nsect
OG
id|mcount
)paren
id|nsect
op_assign
id|mcount
suffix:semicolon
id|mcount
op_sub_assign
id|nsect
suffix:semicolon
id|buffer
op_assign
id|bio_kmap_irq
c_func
(paren
id|rq-&gt;bio
comma
op_amp
id|flags
)paren
op_plus
id|ide_rq_offset
c_func
(paren
id|rq
)paren
suffix:semicolon
id|rq-&gt;sector
op_add_assign
id|nsect
suffix:semicolon
id|rq-&gt;nr_sectors
op_sub_assign
id|nsect
suffix:semicolon
id|rq-&gt;current_nr_sectors
op_sub_assign
id|nsect
suffix:semicolon
multiline_comment|/* Do we move to the next bio after this? */
r_if
c_cond
(paren
op_logical_neg
id|rq-&gt;current_nr_sectors
)paren
(brace
multiline_comment|/* remember to fix this up /jens */
r_struct
id|bio
op_star
id|bio
op_assign
id|rq-&gt;bio-&gt;bi_next
suffix:semicolon
multiline_comment|/* end early if we ran out of requests */
r_if
c_cond
(paren
op_logical_neg
id|bio
)paren
(brace
id|mcount
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|rq-&gt;bio
op_assign
id|bio
suffix:semicolon
id|rq-&gt;current_nr_sectors
op_assign
id|bio_iovec
c_func
(paren
id|bio
)paren
op_member_access_from_pointer
id|bv_len
op_rshift
l_int|9
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t; * Ok, we&squot;re all setup for the interrupt re-entering us on the&n;&t;&t; * last transfer.&n;&t;&t; */
id|ata_write
c_func
(paren
id|drive
comma
id|buffer
comma
id|nsect
op_star
id|SECTOR_WORDS
)paren
suffix:semicolon
id|bio_kunmap_irq
c_func
(paren
id|buffer
comma
op_amp
id|flags
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|mcount
)paren
suffix:semicolon
id|rq-&gt;errors
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|hwgroup-&gt;handler
op_eq
l_int|NULL
)paren
id|ide_set_handler
c_func
(paren
id|drive
comma
id|task_mulout_intr
comma
id|WAIT_CMD
comma
l_int|NULL
)paren
suffix:semicolon
r_return
id|ide_started
suffix:semicolon
)brace
DECL|function|ata_taskfile
id|ide_startstop_t
id|ata_taskfile
c_func
(paren
id|ide_drive_t
op_star
id|drive
comma
r_struct
id|ata_taskfile
op_star
id|args
comma
r_struct
id|request
op_star
id|rq
)paren
(brace
r_struct
id|hd_driveid
op_star
id|id
op_assign
id|drive-&gt;id
suffix:semicolon
id|u8
id|HIHI
op_assign
(paren
id|drive-&gt;addressing
)paren
ques
c_cond
l_int|0xE0
suffix:colon
l_int|0xEF
suffix:semicolon
macro_line|#if 0
id|printk
c_func
(paren
l_string|&quot;ata_taskfile ... %p&bslash;n&quot;
comma
id|args-&gt;handler
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;   sector feature          %02x&bslash;n&quot;
comma
id|args-&gt;taskfile.feature
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;   sector count            %02x&bslash;n&quot;
comma
id|args-&gt;taskfile.sector_count
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;   drive/head              %02x&bslash;n&quot;
comma
id|args-&gt;taskfile.device_head
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;   command                 %02x&bslash;n&quot;
comma
id|args-&gt;taskfile.command
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rq
)paren
id|printk
c_func
(paren
l_string|&quot;   rq-&gt;nr_sectors          %2li&bslash;n&quot;
comma
id|rq-&gt;nr_sectors
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;   rq-&gt;                   = null&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* (ks/hs): Moved to start, do not use for multiple out commands */
r_if
c_cond
(paren
id|args-&gt;handler
op_ne
id|task_mulout_intr
)paren
(brace
r_if
c_cond
(paren
id|IDE_CONTROL_REG
)paren
id|OUT_BYTE
c_func
(paren
id|drive-&gt;ctl
comma
id|IDE_CONTROL_REG
)paren
suffix:semicolon
multiline_comment|/* clear nIEN */
id|SELECT_MASK
c_func
(paren
id|drive-&gt;channel
comma
id|drive
comma
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|id-&gt;command_set_2
op_amp
l_int|0x0400
)paren
op_logical_and
(paren
id|id-&gt;cfs_enable_2
op_amp
l_int|0x0400
)paren
op_logical_and
(paren
id|drive-&gt;addressing
op_eq
l_int|1
)paren
)paren
(brace
id|OUT_BYTE
c_func
(paren
id|args-&gt;hobfile.feature
comma
id|IDE_FEATURE_REG
)paren
suffix:semicolon
id|OUT_BYTE
c_func
(paren
id|args-&gt;hobfile.sector_count
comma
id|IDE_NSECTOR_REG
)paren
suffix:semicolon
id|OUT_BYTE
c_func
(paren
id|args-&gt;hobfile.sector_number
comma
id|IDE_SECTOR_REG
)paren
suffix:semicolon
id|OUT_BYTE
c_func
(paren
id|args-&gt;hobfile.low_cylinder
comma
id|IDE_LCYL_REG
)paren
suffix:semicolon
id|OUT_BYTE
c_func
(paren
id|args-&gt;hobfile.high_cylinder
comma
id|IDE_HCYL_REG
)paren
suffix:semicolon
)brace
id|OUT_BYTE
c_func
(paren
id|args-&gt;taskfile.feature
comma
id|IDE_FEATURE_REG
)paren
suffix:semicolon
id|OUT_BYTE
c_func
(paren
id|args-&gt;taskfile.sector_count
comma
id|IDE_NSECTOR_REG
)paren
suffix:semicolon
multiline_comment|/* refers to number of sectors to transfer */
id|OUT_BYTE
c_func
(paren
id|args-&gt;taskfile.sector_number
comma
id|IDE_SECTOR_REG
)paren
suffix:semicolon
multiline_comment|/* refers to sector offset or start sector */
id|OUT_BYTE
c_func
(paren
id|args-&gt;taskfile.low_cylinder
comma
id|IDE_LCYL_REG
)paren
suffix:semicolon
id|OUT_BYTE
c_func
(paren
id|args-&gt;taskfile.high_cylinder
comma
id|IDE_HCYL_REG
)paren
suffix:semicolon
id|OUT_BYTE
c_func
(paren
(paren
id|args-&gt;taskfile.device_head
op_amp
id|HIHI
)paren
op_or
id|drive-&gt;select.all
comma
id|IDE_SELECT_REG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|args-&gt;handler
op_ne
l_int|NULL
)paren
(brace
id|ide_set_handler
c_func
(paren
id|drive
comma
id|args-&gt;handler
comma
id|WAIT_CMD
comma
l_int|NULL
)paren
suffix:semicolon
id|OUT_BYTE
c_func
(paren
id|args-&gt;taskfile.command
comma
id|IDE_COMMAND_REG
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Warning check for race between handler and prehandler for&n;&t;&t; * writing first block of data.  however since we are well&n;&t;&t; * inside the boundaries of the seek, we should be okay.&n;&t;&t; */
r_if
c_cond
(paren
id|args-&gt;prehandler
op_ne
l_int|NULL
)paren
r_return
id|args
op_member_access_from_pointer
id|prehandler
c_func
(paren
id|drive
comma
id|rq
)paren
suffix:semicolon
)brace
r_else
(brace
id|ide_dma_action_t
id|dma_act
suffix:semicolon
r_int
id|tcq
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|drive-&gt;using_dma
)paren
r_return
id|ide_started
suffix:semicolon
multiline_comment|/* for dma commands we don&squot;t set the handler */
r_if
c_cond
(paren
id|args-&gt;taskfile.command
op_eq
id|WIN_WRITEDMA
op_logical_or
id|args-&gt;taskfile.command
op_eq
id|WIN_WRITEDMA_EXT
)paren
id|dma_act
op_assign
id|ide_dma_write
suffix:semicolon
r_else
r_if
c_cond
(paren
id|args-&gt;taskfile.command
op_eq
id|WIN_READDMA
op_logical_or
id|args-&gt;taskfile.command
op_eq
id|WIN_READDMA_EXT
)paren
id|dma_act
op_assign
id|ide_dma_read
suffix:semicolon
r_else
r_if
c_cond
(paren
id|args-&gt;taskfile.command
op_eq
id|WIN_WRITEDMA_QUEUED
op_logical_or
id|args-&gt;taskfile.command
op_eq
id|WIN_WRITEDMA_QUEUED_EXT
)paren
(brace
id|tcq
op_assign
l_int|1
suffix:semicolon
id|dma_act
op_assign
id|ide_dma_write_queued
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|args-&gt;taskfile.command
op_eq
id|WIN_READDMA_QUEUED
op_logical_or
id|args-&gt;taskfile.command
op_eq
id|WIN_READDMA_QUEUED_EXT
)paren
(brace
id|tcq
op_assign
l_int|1
suffix:semicolon
id|dma_act
op_assign
id|ide_dma_read_queued
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;ata_taskfile: unknown command %x&bslash;n&quot;
comma
id|args-&gt;taskfile.command
)paren
suffix:semicolon
r_return
id|ide_stopped
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * FIXME: this is a gross hack, need to unify tcq dma proc and&n;&t;&t; * regular dma proc -- basically split stuff that needs to act&n;&t;&t; * on a request from things like ide_dma_check etc.&n;&t;&t; */
r_if
c_cond
(paren
id|tcq
)paren
r_return
id|drive-&gt;channel
op_member_access_from_pointer
id|udma
c_func
(paren
id|dma_act
comma
id|drive
comma
id|rq
)paren
suffix:semicolon
r_else
(brace
r_if
c_cond
(paren
id|drive-&gt;channel
op_member_access_from_pointer
id|udma
c_func
(paren
id|dma_act
comma
id|drive
comma
id|rq
)paren
)paren
r_return
id|ide_stopped
suffix:semicolon
)brace
)brace
r_return
id|ide_started
suffix:semicolon
)brace
multiline_comment|/*&n; * This is invoked on completion of a WIN_SETMULT cmd.&n; */
DECL|function|set_multmode_intr
id|ide_startstop_t
id|set_multmode_intr
c_func
(paren
r_struct
id|ata_device
op_star
id|drive
comma
r_struct
id|request
op_star
id|__rq
)paren
(brace
id|u8
id|stat
suffix:semicolon
r_if
c_cond
(paren
id|OK_STAT
c_func
(paren
id|stat
op_assign
id|GET_STAT
c_func
(paren
)paren
comma
id|READY_STAT
comma
id|BAD_STAT
)paren
)paren
(brace
id|drive-&gt;mult_count
op_assign
id|drive-&gt;mult_req
suffix:semicolon
)brace
r_else
(brace
id|drive-&gt;mult_req
op_assign
id|drive-&gt;mult_count
op_assign
l_int|0
suffix:semicolon
id|drive-&gt;special_cmd
op_or_assign
id|ATA_SPECIAL_RECALIBRATE
suffix:semicolon
id|ide_dump_status
c_func
(paren
id|drive
comma
l_string|&quot;set_multmode&quot;
comma
id|stat
)paren
suffix:semicolon
)brace
r_return
id|ide_stopped
suffix:semicolon
)brace
multiline_comment|/*&n; * This is invoked on completion of a WIN_SPECIFY cmd.&n; */
DECL|function|set_geometry_intr
id|ide_startstop_t
id|set_geometry_intr
c_func
(paren
r_struct
id|ata_device
op_star
id|drive
comma
r_struct
id|request
op_star
id|__rq
)paren
(brace
id|u8
id|stat
suffix:semicolon
r_if
c_cond
(paren
id|OK_STAT
c_func
(paren
id|stat
op_assign
id|GET_STAT
c_func
(paren
)paren
comma
id|READY_STAT
comma
id|BAD_STAT
)paren
)paren
r_return
id|ide_stopped
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_amp
(paren
id|ERR_STAT
op_or
id|DRQ_STAT
)paren
)paren
r_return
id|ide_error
c_func
(paren
id|drive
comma
l_string|&quot;set_geometry_intr&quot;
comma
id|stat
)paren
suffix:semicolon
id|ide_set_handler
c_func
(paren
id|drive
comma
id|set_geometry_intr
comma
id|WAIT_CMD
comma
l_int|NULL
)paren
suffix:semicolon
r_return
id|ide_started
suffix:semicolon
)brace
multiline_comment|/*&n; * This is invoked on completion of a WIN_RESTORE (recalibrate) cmd.&n; */
DECL|function|recal_intr
id|ide_startstop_t
id|recal_intr
c_func
(paren
r_struct
id|ata_device
op_star
id|drive
comma
r_struct
id|request
op_star
id|__rq
)paren
(brace
id|u8
id|stat
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|OK_STAT
c_func
(paren
id|stat
op_assign
id|GET_STAT
c_func
(paren
)paren
comma
id|READY_STAT
comma
id|BAD_STAT
)paren
)paren
r_return
id|ide_error
c_func
(paren
id|drive
comma
l_string|&quot;recal_intr&quot;
comma
id|stat
)paren
suffix:semicolon
r_return
id|ide_stopped
suffix:semicolon
)brace
multiline_comment|/*&n; * Handler for commands without a data phase&n; */
DECL|function|task_no_data_intr
id|ide_startstop_t
id|task_no_data_intr
c_func
(paren
r_struct
id|ata_device
op_star
id|drive
comma
r_struct
id|request
op_star
id|rq
)paren
(brace
id|u8
id|stat
suffix:semicolon
r_struct
id|ata_taskfile
op_star
id|args
op_assign
id|rq-&gt;special
suffix:semicolon
id|ide__sti
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* local CPU only */
r_if
c_cond
(paren
op_logical_neg
id|OK_STAT
c_func
(paren
id|stat
op_assign
id|GET_STAT
c_func
(paren
)paren
comma
id|READY_STAT
comma
id|BAD_STAT
)paren
)paren
(brace
multiline_comment|/* Keep quiet for NOP because it is expected to fail. */
r_if
c_cond
(paren
id|args
op_logical_and
id|args-&gt;taskfile.command
op_ne
id|WIN_NOP
)paren
r_return
id|ide_error
c_func
(paren
id|drive
comma
l_string|&quot;task_no_data_intr&quot;
comma
id|stat
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|args
)paren
id|ide_end_drive_cmd
(paren
id|drive
comma
id|stat
comma
id|GET_ERR
c_func
(paren
)paren
)paren
suffix:semicolon
r_return
id|ide_stopped
suffix:semicolon
)brace
multiline_comment|/*&n; * Handler for command with PIO data-in phase&n; */
DECL|function|task_in_intr
r_static
id|ide_startstop_t
id|task_in_intr
(paren
r_struct
id|ata_device
op_star
id|drive
comma
r_struct
id|request
op_star
id|rq
)paren
(brace
id|u8
id|stat
op_assign
id|GET_STAT
c_func
(paren
)paren
suffix:semicolon
r_char
op_star
id|pBuf
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|OK_STAT
c_func
(paren
id|stat
comma
id|DATA_READY
comma
id|BAD_R_STAT
)paren
)paren
(brace
r_if
c_cond
(paren
id|stat
op_amp
(paren
id|ERR_STAT
op_or
id|DRQ_STAT
)paren
)paren
(brace
r_return
id|ide_error
c_func
(paren
id|drive
comma
l_string|&quot;task_in_intr&quot;
comma
id|stat
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|stat
op_amp
id|BUSY_STAT
)paren
)paren
(brace
id|DTF
c_func
(paren
l_string|&quot;task_in_intr to Soon wait for next interrupt&bslash;n&quot;
)paren
suffix:semicolon
id|ide_set_handler
c_func
(paren
id|drive
comma
id|task_in_intr
comma
id|WAIT_CMD
comma
l_int|NULL
)paren
suffix:semicolon
r_return
id|ide_started
suffix:semicolon
)brace
)brace
id|DTF
c_func
(paren
l_string|&quot;stat: %02x&bslash;n&quot;
comma
id|stat
)paren
suffix:semicolon
id|pBuf
op_assign
id|ide_map_rq
c_func
(paren
id|rq
comma
op_amp
id|flags
)paren
suffix:semicolon
id|DTF
c_func
(paren
l_string|&quot;Read: %p, rq-&gt;current_nr_sectors: %d&bslash;n&quot;
comma
id|pBuf
comma
(paren
r_int
)paren
id|rq-&gt;current_nr_sectors
)paren
suffix:semicolon
id|ata_read
c_func
(paren
id|drive
comma
id|pBuf
comma
id|SECTOR_WORDS
)paren
suffix:semicolon
id|ide_unmap_rq
c_func
(paren
id|rq
comma
id|pBuf
comma
op_amp
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * first segment of the request is complete. note that this does not&n;&t; * necessarily mean that the entire request is done!! this is only&n;&t; * true if ide_end_request() returns 0.&n;&t; */
r_if
c_cond
(paren
op_decrement
id|rq-&gt;current_nr_sectors
op_le
l_int|0
)paren
(brace
id|DTF
c_func
(paren
l_string|&quot;Request Ended stat: %02x&bslash;n&quot;
comma
id|GET_STAT
c_func
(paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ide_end_request
c_func
(paren
id|drive
comma
id|rq
comma
l_int|1
)paren
)paren
r_return
id|ide_stopped
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * still data left to transfer&n;&t; */
id|ide_set_handler
c_func
(paren
id|drive
comma
id|task_in_intr
comma
id|WAIT_CMD
comma
l_int|NULL
)paren
suffix:semicolon
r_return
id|ide_started
suffix:semicolon
)brace
DECL|function|pre_task_out_intr
r_static
id|ide_startstop_t
id|pre_task_out_intr
c_func
(paren
r_struct
id|ata_device
op_star
id|drive
comma
r_struct
id|request
op_star
id|rq
)paren
(brace
r_struct
id|ata_taskfile
op_star
id|args
op_assign
id|rq-&gt;special
suffix:semicolon
id|ide_startstop_t
id|startstop
suffix:semicolon
r_if
c_cond
(paren
id|ide_wait_stat
c_func
(paren
op_amp
id|startstop
comma
id|drive
comma
id|DATA_READY
comma
id|drive-&gt;bad_wstat
comma
id|WAIT_DRQ
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: no DRQ after issuing %s&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|drive-&gt;mult_count
ques
c_cond
l_string|&quot;MULTWRITE&quot;
suffix:colon
l_string|&quot;WRITE&quot;
)paren
suffix:semicolon
r_return
id|startstop
suffix:semicolon
)brace
multiline_comment|/* (ks/hs): Fixed Multi Write */
r_if
c_cond
(paren
(paren
id|args-&gt;taskfile.command
op_ne
id|WIN_MULTWRITE
)paren
op_logical_and
(paren
id|args-&gt;taskfile.command
op_ne
id|WIN_MULTWRITE_EXT
)paren
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_char
op_star
id|buf
op_assign
id|ide_map_rq
c_func
(paren
id|rq
comma
op_amp
id|flags
)paren
suffix:semicolon
multiline_comment|/* For Write_sectors we need to stuff the first sector */
id|ata_write
c_func
(paren
id|drive
comma
id|buf
comma
id|SECTOR_WORDS
)paren
suffix:semicolon
id|rq-&gt;current_nr_sectors
op_decrement
suffix:semicolon
id|ide_unmap_rq
c_func
(paren
id|rq
comma
id|buf
comma
op_amp
id|flags
)paren
suffix:semicolon
)brace
r_else
(brace
id|ata_poll_drive_ready
c_func
(paren
id|drive
)paren
suffix:semicolon
r_return
id|args
op_member_access_from_pointer
id|handler
c_func
(paren
id|drive
comma
id|rq
)paren
suffix:semicolon
)brace
r_return
id|ide_started
suffix:semicolon
)brace
multiline_comment|/*&n; * Handler for command with PIO data-out phase&n; */
DECL|function|task_out_intr
r_static
id|ide_startstop_t
id|task_out_intr
c_func
(paren
r_struct
id|ata_device
op_star
id|drive
comma
r_struct
id|request
op_star
id|rq
)paren
(brace
id|u8
id|stat
op_assign
id|GET_STAT
c_func
(paren
)paren
suffix:semicolon
r_char
op_star
id|pBuf
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|OK_STAT
c_func
(paren
id|stat
comma
id|DRIVE_READY
comma
id|drive-&gt;bad_wstat
)paren
)paren
r_return
id|ide_error
c_func
(paren
id|drive
comma
l_string|&quot;task_out_intr&quot;
comma
id|stat
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rq-&gt;current_nr_sectors
)paren
r_if
c_cond
(paren
op_logical_neg
id|ide_end_request
c_func
(paren
id|drive
comma
id|rq
comma
l_int|1
)paren
)paren
r_return
id|ide_stopped
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rq-&gt;current_nr_sectors
op_eq
l_int|1
)paren
op_xor
(paren
id|stat
op_amp
id|DRQ_STAT
)paren
)paren
(brace
id|pBuf
op_assign
id|ide_map_rq
c_func
(paren
id|rq
comma
op_amp
id|flags
)paren
suffix:semicolon
id|DTF
c_func
(paren
l_string|&quot;write: %p, rq-&gt;current_nr_sectors: %d&bslash;n&quot;
comma
id|pBuf
comma
(paren
r_int
)paren
id|rq-&gt;current_nr_sectors
)paren
suffix:semicolon
id|ata_write
c_func
(paren
id|drive
comma
id|pBuf
comma
id|SECTOR_WORDS
)paren
suffix:semicolon
id|ide_unmap_rq
c_func
(paren
id|rq
comma
id|pBuf
comma
op_amp
id|flags
)paren
suffix:semicolon
id|rq-&gt;errors
op_assign
l_int|0
suffix:semicolon
id|rq-&gt;current_nr_sectors
op_decrement
suffix:semicolon
)brace
id|ide_set_handler
c_func
(paren
id|drive
comma
id|task_out_intr
comma
id|WAIT_CMD
comma
l_int|NULL
)paren
suffix:semicolon
r_return
id|ide_started
suffix:semicolon
)brace
multiline_comment|/*&n; * Handler for command with Read Multiple&n; */
DECL|function|task_mulin_intr
r_static
id|ide_startstop_t
id|task_mulin_intr
c_func
(paren
r_struct
id|ata_device
op_star
id|drive
comma
r_struct
id|request
op_star
id|rq
)paren
(brace
id|u8
id|stat
suffix:semicolon
r_char
op_star
id|pBuf
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|msect
comma
id|nsect
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|OK_STAT
c_func
(paren
id|stat
op_assign
id|GET_STAT
c_func
(paren
)paren
comma
id|DATA_READY
comma
id|BAD_R_STAT
)paren
)paren
(brace
r_if
c_cond
(paren
id|stat
op_amp
(paren
id|ERR_STAT
op_or
id|DRQ_STAT
)paren
)paren
(brace
r_return
id|ide_error
c_func
(paren
id|drive
comma
l_string|&quot;task_mulin_intr&quot;
comma
id|stat
)paren
suffix:semicolon
)brace
multiline_comment|/* no data yet, so wait for another interrupt */
id|ide_set_handler
c_func
(paren
id|drive
comma
id|task_mulin_intr
comma
id|WAIT_CMD
comma
l_int|NULL
)paren
suffix:semicolon
r_return
id|ide_started
suffix:semicolon
)brace
multiline_comment|/* (ks/hs): Fixed Multi-Sector transfer */
id|msect
op_assign
id|drive-&gt;mult_count
suffix:semicolon
r_do
(brace
id|nsect
op_assign
id|rq-&gt;current_nr_sectors
suffix:semicolon
r_if
c_cond
(paren
id|nsect
OG
id|msect
)paren
id|nsect
op_assign
id|msect
suffix:semicolon
id|pBuf
op_assign
id|ide_map_rq
c_func
(paren
id|rq
comma
op_amp
id|flags
)paren
suffix:semicolon
id|DTF
c_func
(paren
l_string|&quot;Multiread: %p, nsect: %d , rq-&gt;current_nr_sectors: %d&bslash;n&quot;
comma
id|pBuf
comma
id|nsect
comma
id|rq-&gt;current_nr_sectors
)paren
suffix:semicolon
id|ata_read
c_func
(paren
id|drive
comma
id|pBuf
comma
id|nsect
op_star
id|SECTOR_WORDS
)paren
suffix:semicolon
id|ide_unmap_rq
c_func
(paren
id|rq
comma
id|pBuf
comma
op_amp
id|flags
)paren
suffix:semicolon
id|rq-&gt;errors
op_assign
l_int|0
suffix:semicolon
id|rq-&gt;current_nr_sectors
op_sub_assign
id|nsect
suffix:semicolon
id|msect
op_sub_assign
id|nsect
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rq-&gt;current_nr_sectors
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ide_end_request
c_func
(paren
id|drive
comma
id|rq
comma
l_int|1
)paren
)paren
r_return
id|ide_stopped
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|msect
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * more data left&n;&t; */
id|ide_set_handler
c_func
(paren
id|drive
comma
id|task_mulin_intr
comma
id|WAIT_CMD
comma
l_int|NULL
)paren
suffix:semicolon
r_return
id|ide_started
suffix:semicolon
)brace
multiline_comment|/* Called by ioctl to feature out type of command being called */
DECL|function|ide_cmd_type_parser
r_void
id|ide_cmd_type_parser
c_func
(paren
r_struct
id|ata_taskfile
op_star
id|args
)paren
(brace
r_struct
id|hd_drive_task_hdr
op_star
id|taskfile
op_assign
op_amp
id|args-&gt;taskfile
suffix:semicolon
id|args-&gt;prehandler
op_assign
l_int|NULL
suffix:semicolon
id|args-&gt;handler
op_assign
l_int|NULL
suffix:semicolon
r_switch
c_cond
(paren
id|args-&gt;taskfile.command
)paren
(brace
r_case
id|WIN_IDENTIFY
suffix:colon
r_case
id|WIN_PIDENTIFY
suffix:colon
id|args-&gt;handler
op_assign
id|task_in_intr
suffix:semicolon
id|args-&gt;command_type
op_assign
id|IDE_DRIVE_TASK_IN
suffix:semicolon
r_return
suffix:semicolon
r_case
id|CFA_TRANSLATE_SECTOR
suffix:colon
r_case
id|WIN_READ
suffix:colon
r_case
id|WIN_READ_EXT
suffix:colon
r_case
id|WIN_READ_BUFFER
suffix:colon
id|args-&gt;handler
op_assign
id|task_in_intr
suffix:semicolon
id|args-&gt;command_type
op_assign
id|IDE_DRIVE_TASK_IN
suffix:semicolon
r_return
suffix:semicolon
r_case
id|WIN_WRITE
suffix:colon
r_case
id|WIN_WRITE_EXT
suffix:colon
r_case
id|WIN_WRITE_VERIFY
suffix:colon
r_case
id|WIN_WRITE_BUFFER
suffix:colon
r_case
id|CFA_WRITE_SECT_WO_ERASE
suffix:colon
r_case
id|WIN_DOWNLOAD_MICROCODE
suffix:colon
id|args-&gt;prehandler
op_assign
id|pre_task_out_intr
suffix:semicolon
id|args-&gt;handler
op_assign
id|task_out_intr
suffix:semicolon
id|args-&gt;command_type
op_assign
id|IDE_DRIVE_TASK_RAW_WRITE
suffix:semicolon
r_return
suffix:semicolon
r_case
id|WIN_MULTREAD
suffix:colon
r_case
id|WIN_MULTREAD_EXT
suffix:colon
id|args-&gt;handler
op_assign
id|task_mulin_intr
suffix:semicolon
id|args-&gt;command_type
op_assign
id|IDE_DRIVE_TASK_IN
suffix:semicolon
r_return
suffix:semicolon
r_case
id|CFA_WRITE_MULTI_WO_ERASE
suffix:colon
r_case
id|WIN_MULTWRITE
suffix:colon
r_case
id|WIN_MULTWRITE_EXT
suffix:colon
id|args-&gt;prehandler
op_assign
id|pre_task_mulout_intr
suffix:semicolon
id|args-&gt;handler
op_assign
id|task_mulout_intr
suffix:semicolon
id|args-&gt;command_type
op_assign
id|IDE_DRIVE_TASK_RAW_WRITE
suffix:semicolon
r_return
suffix:semicolon
r_case
id|WIN_SECURITY_DISABLE
suffix:colon
r_case
id|WIN_SECURITY_ERASE_UNIT
suffix:colon
r_case
id|WIN_SECURITY_SET_PASS
suffix:colon
r_case
id|WIN_SECURITY_UNLOCK
suffix:colon
id|args-&gt;handler
op_assign
id|task_out_intr
suffix:semicolon
id|args-&gt;command_type
op_assign
id|IDE_DRIVE_TASK_OUT
suffix:semicolon
r_return
suffix:semicolon
r_case
id|WIN_SMART
suffix:colon
r_if
c_cond
(paren
id|taskfile-&gt;feature
op_eq
id|SMART_WRITE_LOG_SECTOR
)paren
id|args-&gt;prehandler
op_assign
id|pre_task_out_intr
suffix:semicolon
id|args-&gt;taskfile.low_cylinder
op_assign
id|SMART_LCYL_PASS
suffix:semicolon
id|args-&gt;taskfile.high_cylinder
op_assign
id|SMART_HCYL_PASS
suffix:semicolon
r_switch
c_cond
(paren
id|args-&gt;taskfile.feature
)paren
(brace
r_case
id|SMART_READ_VALUES
suffix:colon
r_case
id|SMART_READ_THRESHOLDS
suffix:colon
r_case
id|SMART_READ_LOG_SECTOR
suffix:colon
id|args-&gt;handler
op_assign
id|task_in_intr
suffix:semicolon
id|args-&gt;command_type
op_assign
id|IDE_DRIVE_TASK_IN
suffix:semicolon
r_return
suffix:semicolon
r_case
id|SMART_WRITE_LOG_SECTOR
suffix:colon
id|args-&gt;handler
op_assign
id|task_out_intr
suffix:semicolon
id|args-&gt;command_type
op_assign
id|IDE_DRIVE_TASK_OUT
suffix:semicolon
r_return
suffix:semicolon
r_default
suffix:colon
id|args-&gt;handler
op_assign
id|task_no_data_intr
suffix:semicolon
id|args-&gt;command_type
op_assign
id|IDE_DRIVE_TASK_NO_DATA
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_BLK_DEV_IDEDMA
r_case
id|WIN_READDMA
suffix:colon
r_case
id|WIN_IDENTIFY_DMA
suffix:colon
r_case
id|WIN_READDMA_QUEUED
suffix:colon
r_case
id|WIN_READDMA_EXT
suffix:colon
r_case
id|WIN_READDMA_QUEUED_EXT
suffix:colon
id|args-&gt;command_type
op_assign
id|IDE_DRIVE_TASK_IN
suffix:semicolon
r_return
suffix:semicolon
r_case
id|WIN_WRITEDMA
suffix:colon
r_case
id|WIN_WRITEDMA_QUEUED
suffix:colon
r_case
id|WIN_WRITEDMA_EXT
suffix:colon
r_case
id|WIN_WRITEDMA_QUEUED_EXT
suffix:colon
id|args-&gt;command_type
op_assign
id|IDE_DRIVE_TASK_RAW_WRITE
suffix:semicolon
r_return
suffix:semicolon
macro_line|#endif
r_case
id|WIN_SETFEATURES
suffix:colon
id|args-&gt;handler
op_assign
id|task_no_data_intr
suffix:semicolon
r_switch
c_cond
(paren
id|args-&gt;taskfile.feature
)paren
(brace
r_case
id|SETFEATURES_XFER
suffix:colon
id|args-&gt;command_type
op_assign
id|IDE_DRIVE_TASK_SET_XFER
suffix:semicolon
r_return
suffix:semicolon
r_case
id|SETFEATURES_DIS_DEFECT
suffix:colon
r_case
id|SETFEATURES_EN_APM
suffix:colon
r_case
id|SETFEATURES_DIS_MSN
suffix:colon
r_case
id|SETFEATURES_EN_RI
suffix:colon
r_case
id|SETFEATURES_EN_SI
suffix:colon
r_case
id|SETFEATURES_DIS_RPOD
suffix:colon
r_case
id|SETFEATURES_DIS_WCACHE
suffix:colon
r_case
id|SETFEATURES_EN_DEFECT
suffix:colon
r_case
id|SETFEATURES_DIS_APM
suffix:colon
r_case
id|SETFEATURES_EN_MSN
suffix:colon
r_case
id|SETFEATURES_EN_RLA
suffix:colon
r_case
id|SETFEATURES_PREFETCH
suffix:colon
r_case
id|SETFEATURES_EN_RPOD
suffix:colon
r_case
id|SETFEATURES_DIS_RI
suffix:colon
r_case
id|SETFEATURES_DIS_SI
suffix:colon
r_default
suffix:colon
id|args-&gt;command_type
op_assign
id|IDE_DRIVE_TASK_NO_DATA
suffix:semicolon
r_return
suffix:semicolon
)brace
r_case
id|WIN_SPECIFY
suffix:colon
id|args-&gt;handler
op_assign
id|set_geometry_intr
suffix:semicolon
id|args-&gt;command_type
op_assign
id|IDE_DRIVE_TASK_NO_DATA
suffix:semicolon
r_return
suffix:semicolon
r_case
id|WIN_RESTORE
suffix:colon
id|args-&gt;handler
op_assign
id|recal_intr
suffix:semicolon
id|args-&gt;command_type
op_assign
id|IDE_DRIVE_TASK_NO_DATA
suffix:semicolon
r_return
suffix:semicolon
r_case
id|WIN_DIAGNOSE
suffix:colon
r_case
id|WIN_FLUSH_CACHE
suffix:colon
r_case
id|WIN_FLUSH_CACHE_EXT
suffix:colon
r_case
id|WIN_STANDBYNOW1
suffix:colon
r_case
id|WIN_STANDBYNOW2
suffix:colon
r_case
id|WIN_SLEEPNOW1
suffix:colon
r_case
id|WIN_SLEEPNOW2
suffix:colon
r_case
id|WIN_SETIDLE1
suffix:colon
r_case
id|WIN_CHECKPOWERMODE1
suffix:colon
r_case
id|WIN_CHECKPOWERMODE2
suffix:colon
r_case
id|WIN_GETMEDIASTATUS
suffix:colon
r_case
id|WIN_MEDIAEJECT
suffix:colon
r_case
id|CFA_REQ_EXT_ERROR_CODE
suffix:colon
r_case
id|CFA_ERASE_SECTORS
suffix:colon
r_case
id|WIN_VERIFY
suffix:colon
r_case
id|WIN_VERIFY_EXT
suffix:colon
r_case
id|WIN_SEEK
suffix:colon
r_case
id|WIN_READ_NATIVE_MAX
suffix:colon
r_case
id|WIN_SET_MAX
suffix:colon
r_case
id|WIN_READ_NATIVE_MAX_EXT
suffix:colon
r_case
id|WIN_SET_MAX_EXT
suffix:colon
r_case
id|WIN_SECURITY_ERASE_PREPARE
suffix:colon
r_case
id|WIN_SECURITY_FREEZE_LOCK
suffix:colon
r_case
id|WIN_DOORLOCK
suffix:colon
r_case
id|WIN_DOORUNLOCK
suffix:colon
r_case
id|DISABLE_SEAGATE
suffix:colon
r_case
id|EXABYTE_ENABLE_NEST
suffix:colon
id|args-&gt;handler
op_assign
id|task_no_data_intr
suffix:semicolon
id|args-&gt;command_type
op_assign
id|IDE_DRIVE_TASK_NO_DATA
suffix:semicolon
r_return
suffix:semicolon
r_case
id|WIN_SETMULT
suffix:colon
id|args-&gt;handler
op_assign
id|set_multmode_intr
suffix:semicolon
id|args-&gt;command_type
op_assign
id|IDE_DRIVE_TASK_NO_DATA
suffix:semicolon
r_return
suffix:semicolon
r_case
id|WIN_NOP
suffix:colon
id|args-&gt;handler
op_assign
id|task_no_data_intr
suffix:semicolon
id|args-&gt;command_type
op_assign
id|IDE_DRIVE_TASK_NO_DATA
suffix:semicolon
r_return
suffix:semicolon
r_case
id|WIN_FORMAT
suffix:colon
r_case
id|WIN_INIT
suffix:colon
r_case
id|WIN_DEVICE_RESET
suffix:colon
r_case
id|WIN_QUEUED_SERVICE
suffix:colon
r_case
id|WIN_PACKETCMD
suffix:colon
r_default
suffix:colon
id|args-&gt;command_type
op_assign
id|IDE_DRIVE_TASK_INVALID
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
DECL|function|ide_raw_taskfile
r_int
id|ide_raw_taskfile
c_func
(paren
id|ide_drive_t
op_star
id|drive
comma
r_struct
id|ata_taskfile
op_star
id|args
comma
id|byte
op_star
id|buf
)paren
(brace
r_struct
id|request
id|rq
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|rq
comma
l_int|0
comma
r_sizeof
(paren
id|rq
)paren
)paren
suffix:semicolon
id|rq.flags
op_assign
id|REQ_DRIVE_ACB
suffix:semicolon
id|rq.buffer
op_assign
id|buf
suffix:semicolon
r_if
c_cond
(paren
id|args-&gt;command_type
op_ne
id|IDE_DRIVE_TASK_NO_DATA
)paren
id|rq.current_nr_sectors
op_assign
id|rq.nr_sectors
op_assign
(paren
id|args-&gt;hobfile.sector_count
op_lshift
l_int|8
)paren
op_or
id|args-&gt;taskfile.sector_count
suffix:semicolon
id|rq.special
op_assign
id|args
suffix:semicolon
r_return
id|ide_do_drive_cmd
c_func
(paren
id|drive
comma
op_amp
id|rq
comma
id|ide_wait
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Implement generic ioctls invoked from userspace to imlpement specific&n; * functionality.&n; *&n; * Unfortunately every single low level programm out there is using this&n; * interface.&n; */
DECL|function|ide_cmd_ioctl
r_int
id|ide_cmd_ioctl
c_func
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
r_int
id|arg
)paren
(brace
r_int
id|err
op_assign
l_int|0
suffix:semicolon
id|u8
id|vals
(braket
l_int|4
)braket
suffix:semicolon
id|u8
op_star
id|argbuf
op_assign
id|vals
suffix:semicolon
id|u8
id|xfer_rate
op_assign
l_int|0
suffix:semicolon
r_int
id|argsize
op_assign
l_int|4
suffix:semicolon
r_struct
id|ata_taskfile
id|args
suffix:semicolon
r_struct
id|request
id|rq
suffix:semicolon
id|ide_init_drive_cmd
c_func
(paren
op_amp
id|rq
)paren
suffix:semicolon
multiline_comment|/* Wait for drive ready.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|arg
)paren
r_return
id|ide_do_drive_cmd
c_func
(paren
id|drive
comma
op_amp
id|rq
comma
id|ide_wait
)paren
suffix:semicolon
multiline_comment|/* Second phase.&n;&t; */
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|vals
comma
(paren
r_void
op_star
)paren
id|arg
comma
l_int|4
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|args.taskfile.feature
op_assign
id|vals
(braket
l_int|2
)braket
suffix:semicolon
id|args.taskfile.sector_count
op_assign
id|vals
(braket
l_int|3
)braket
suffix:semicolon
id|args.taskfile.sector_number
op_assign
id|vals
(braket
l_int|1
)braket
suffix:semicolon
id|args.taskfile.low_cylinder
op_assign
l_int|0x00
suffix:semicolon
id|args.taskfile.high_cylinder
op_assign
l_int|0x00
suffix:semicolon
id|args.taskfile.device_head
op_assign
l_int|0x00
suffix:semicolon
id|args.taskfile.command
op_assign
id|vals
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
id|vals
(braket
l_int|3
)braket
)paren
(brace
id|argsize
op_assign
l_int|4
op_plus
(paren
id|SECTOR_WORDS
op_star
l_int|4
op_star
id|vals
(braket
l_int|3
)braket
)paren
suffix:semicolon
id|argbuf
op_assign
id|kmalloc
c_func
(paren
id|argsize
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|argbuf
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|memcpy
c_func
(paren
id|argbuf
comma
id|vals
comma
l_int|4
)paren
suffix:semicolon
id|memset
c_func
(paren
id|argbuf
op_plus
l_int|4
comma
l_int|0
comma
id|argsize
op_minus
l_int|4
)paren
suffix:semicolon
)brace
multiline_comment|/* Always make sure the transfer reate has been setup.&n;&t; */
r_if
c_cond
(paren
id|set_transfer
c_func
(paren
id|drive
comma
op_amp
id|args
)paren
)paren
(brace
id|xfer_rate
op_assign
id|vals
(braket
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
id|ide_ata66_check
c_func
(paren
id|drive
comma
op_amp
id|args
)paren
)paren
r_goto
m_abort
suffix:semicolon
)brace
multiline_comment|/* Issue ATA command and wait for completion.&n;&t; */
id|rq.buffer
op_assign
id|argbuf
suffix:semicolon
id|err
op_assign
id|ide_do_drive_cmd
c_func
(paren
id|drive
comma
op_amp
id|rq
comma
id|ide_wait
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|err
op_logical_and
id|xfer_rate
)paren
(brace
multiline_comment|/* active-retuning-calls future */
r_if
c_cond
(paren
(paren
id|drive-&gt;channel-&gt;speedproc
)paren
op_ne
l_int|NULL
)paren
id|drive-&gt;channel
op_member_access_from_pointer
id|speedproc
c_func
(paren
id|drive
comma
id|xfer_rate
)paren
suffix:semicolon
id|ide_driveid_update
c_func
(paren
id|drive
)paren
suffix:semicolon
)brace
m_abort
suffix:colon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
id|argbuf
comma
id|argsize
)paren
)paren
id|err
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|argsize
OG
l_int|4
)paren
id|kfree
c_func
(paren
id|argbuf
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|variable|drive_is_ready
id|EXPORT_SYMBOL
c_func
(paren
id|drive_is_ready
)paren
suffix:semicolon
DECL|variable|ata_read
id|EXPORT_SYMBOL
c_func
(paren
id|ata_read
)paren
suffix:semicolon
DECL|variable|ata_write
id|EXPORT_SYMBOL
c_func
(paren
id|ata_write
)paren
suffix:semicolon
DECL|variable|atapi_read
id|EXPORT_SYMBOL
c_func
(paren
id|atapi_read
)paren
suffix:semicolon
DECL|variable|atapi_write
id|EXPORT_SYMBOL
c_func
(paren
id|atapi_write
)paren
suffix:semicolon
DECL|variable|ata_taskfile
id|EXPORT_SYMBOL
c_func
(paren
id|ata_taskfile
)paren
suffix:semicolon
DECL|variable|recal_intr
id|EXPORT_SYMBOL
c_func
(paren
id|recal_intr
)paren
suffix:semicolon
DECL|variable|set_geometry_intr
id|EXPORT_SYMBOL
c_func
(paren
id|set_geometry_intr
)paren
suffix:semicolon
DECL|variable|set_multmode_intr
id|EXPORT_SYMBOL
c_func
(paren
id|set_multmode_intr
)paren
suffix:semicolon
DECL|variable|task_no_data_intr
id|EXPORT_SYMBOL
c_func
(paren
id|task_no_data_intr
)paren
suffix:semicolon
DECL|variable|ide_raw_taskfile
id|EXPORT_SYMBOL
c_func
(paren
id|ide_raw_taskfile
)paren
suffix:semicolon
DECL|variable|ide_cmd_type_parser
id|EXPORT_SYMBOL
c_func
(paren
id|ide_cmd_type_parser
)paren
suffix:semicolon
DECL|variable|ide_cmd_ioctl
id|EXPORT_SYMBOL
c_func
(paren
id|ide_cmd_ioctl
)paren
suffix:semicolon
eof
