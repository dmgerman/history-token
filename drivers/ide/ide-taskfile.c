multiline_comment|/*&n; * linux/drivers/ide/ide-taskfile.c&t;Version 0.33&t;April 11, 2002&n; *&n; *  Copyright (C) 2000-2002&t;Michael Cornwell &lt;cornwell@acm.org&gt;&n; *  Copyright (C) 2000-2002&t;Andre Hedrick &lt;andre@linux-ide.org&gt;&n; *  Copyright (C) 2001-2002&t;Klaus Smolin&n; *&t;&t;&t;&t;&t;IBM Storage Technology Division&n; *&n; *  The big the bad and the ugly.&n; *&n; *  Problems to be fixed because of BH interface or the lack therefore.&n; *&n; *  Fill me in stupid !!!&n; *&n; *  HOST:&n; *&t;General refers to the Controller and Driver &quot;pair&quot;.&n; *  DATA HANDLER:&n; *&t;Under the context of Linux it generally refers to an interrupt handler.&n; *&t;However, it correctly describes the &squot;HOST&squot;&n; *  DATA BLOCK:&n; *&t;The amount of data needed to be transfered as predefined in the&n; *&t;setup of the device.&n; *  STORAGE ATOMIC:&n; *&t;The &squot;DATA BLOCK&squot; associated to the &squot;DATA HANDLER&squot;, and can be as&n; *&t;small as a single sector or as large as the entire command block&n; *&t;request.&n; */
macro_line|#include &lt;linux/config.h&gt;
DECL|macro|__NO_VERSION__
mdefine_line|#define __NO_VERSION__
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/major.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/genhd.h&gt;
macro_line|#include &lt;linux/blkpg.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/hdreg.h&gt;
macro_line|#include &lt;linux/ide.h&gt;
macro_line|#include &lt;asm/byteorder.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
DECL|macro|DEBUG_TASKFILE
mdefine_line|#define DEBUG_TASKFILE&t;0&t;/* unset when fixed */
macro_line|#if DEBUG_TASKFILE
DECL|macro|DTF
mdefine_line|#define DTF(x...) printk(x)
macro_line|#else
DECL|macro|DTF
mdefine_line|#define DTF(x...)
macro_line|#endif
DECL|macro|task_map_rq
mdefine_line|#define task_map_rq(rq, flags)&t;&t;ide_map_buffer((rq), (flags))
DECL|macro|task_unmap_rq
mdefine_line|#define task_unmap_rq(rq, buf, flags)&t;ide_unmap_buffer((rq), (buf), (flags))
DECL|function|task_read_24
r_inline
id|u32
id|task_read_24
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_return
(paren
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_HCYL_REG
)paren
op_lshift
l_int|16
)paren
op_or
(paren
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_LCYL_REG
)paren
op_lshift
l_int|8
)paren
op_or
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_SECTOR_REG
)paren
suffix:semicolon
)brace
DECL|variable|task_read_24
id|EXPORT_SYMBOL
c_func
(paren
id|task_read_24
)paren
suffix:semicolon
DECL|function|ata_bswap_data
r_static
r_void
id|ata_bswap_data
(paren
r_void
op_star
id|buffer
comma
r_int
id|wcount
)paren
(brace
id|u16
op_star
id|p
op_assign
id|buffer
suffix:semicolon
r_while
c_loop
(paren
id|wcount
op_decrement
)paren
(brace
op_star
id|p
op_assign
op_star
id|p
op_lshift
l_int|8
op_or
op_star
id|p
op_rshift
l_int|8
suffix:semicolon
id|p
op_increment
suffix:semicolon
op_star
id|p
op_assign
op_star
id|p
op_lshift
l_int|8
op_or
op_star
id|p
op_rshift
l_int|8
suffix:semicolon
id|p
op_increment
suffix:semicolon
)brace
)brace
DECL|function|taskfile_input_data
r_void
id|taskfile_input_data
(paren
id|ide_drive_t
op_star
id|drive
comma
r_void
op_star
id|buffer
comma
id|u32
id|wcount
)paren
(brace
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|ata_input_data
c_func
(paren
id|drive
comma
id|buffer
comma
id|wcount
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;bswap
)paren
id|ata_bswap_data
c_func
(paren
id|buffer
comma
id|wcount
)paren
suffix:semicolon
)brace
DECL|variable|taskfile_input_data
id|EXPORT_SYMBOL
c_func
(paren
id|taskfile_input_data
)paren
suffix:semicolon
DECL|function|taskfile_output_data
r_void
id|taskfile_output_data
(paren
id|ide_drive_t
op_star
id|drive
comma
r_void
op_star
id|buffer
comma
id|u32
id|wcount
)paren
(brace
r_if
c_cond
(paren
id|drive-&gt;bswap
)paren
(brace
id|ata_bswap_data
c_func
(paren
id|buffer
comma
id|wcount
)paren
suffix:semicolon
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|ata_output_data
c_func
(paren
id|drive
comma
id|buffer
comma
id|wcount
)paren
suffix:semicolon
id|ata_bswap_data
c_func
(paren
id|buffer
comma
id|wcount
)paren
suffix:semicolon
)brace
r_else
(brace
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|ata_output_data
c_func
(paren
id|drive
comma
id|buffer
comma
id|wcount
)paren
suffix:semicolon
)brace
)brace
DECL|variable|taskfile_output_data
id|EXPORT_SYMBOL
c_func
(paren
id|taskfile_output_data
)paren
suffix:semicolon
DECL|function|taskfile_lib_get_identify
r_int
id|taskfile_lib_get_identify
(paren
id|ide_drive_t
op_star
id|drive
comma
id|u8
op_star
id|buf
)paren
(brace
id|ide_task_t
id|args
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|args
comma
l_int|0
comma
r_sizeof
(paren
id|ide_task_t
)paren
)paren
suffix:semicolon
id|args.tfRegister
(braket
id|IDE_NSECTOR_OFFSET
)braket
op_assign
l_int|0x01
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;media
op_eq
id|ide_disk
)paren
id|args.tfRegister
(braket
id|IDE_COMMAND_OFFSET
)braket
op_assign
id|WIN_IDENTIFY
suffix:semicolon
r_else
id|args.tfRegister
(braket
id|IDE_COMMAND_OFFSET
)braket
op_assign
id|WIN_PIDENTIFY
suffix:semicolon
id|args.command_type
op_assign
id|ide_cmd_type_parser
c_func
(paren
op_amp
id|args
)paren
suffix:semicolon
r_return
id|ide_raw_taskfile
c_func
(paren
id|drive
comma
op_amp
id|args
comma
id|buf
)paren
suffix:semicolon
)brace
DECL|variable|taskfile_lib_get_identify
id|EXPORT_SYMBOL
c_func
(paren
id|taskfile_lib_get_identify
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_IDE_TASK_IOCTL_DEBUG
DECL|function|debug_taskfile
r_void
id|debug_taskfile
(paren
id|ide_drive_t
op_star
id|drive
comma
id|ide_task_t
op_star
id|args
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: &quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
singleline_comment|//&t;printk(&quot;TF.0=x%02x &quot;, args-&gt;tfRegister[IDE_DATA_OFFSET]);
id|printk
c_func
(paren
l_string|&quot;TF.1=x%02x &quot;
comma
id|args-&gt;tfRegister
(braket
id|IDE_FEATURE_OFFSET
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;TF.2=x%02x &quot;
comma
id|args-&gt;tfRegister
(braket
id|IDE_NSECTOR_OFFSET
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;TF.3=x%02x &quot;
comma
id|args-&gt;tfRegister
(braket
id|IDE_SECTOR_OFFSET
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;TF.4=x%02x &quot;
comma
id|args-&gt;tfRegister
(braket
id|IDE_LCYL_OFFSET
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;TF.5=x%02x &quot;
comma
id|args-&gt;tfRegister
(braket
id|IDE_HCYL_OFFSET
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;TF.6=x%02x &quot;
comma
id|args-&gt;tfRegister
(braket
id|IDE_SELECT_OFFSET
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;TF.7=x%02x&bslash;n&quot;
comma
id|args-&gt;tfRegister
(braket
id|IDE_COMMAND_OFFSET
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: &quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
singleline_comment|//&t;printk(&quot;HTF.0=x%02x &quot;, args-&gt;hobRegister[IDE_DATA_OFFSET_HOB]);
id|printk
c_func
(paren
l_string|&quot;HTF.1=x%02x &quot;
comma
id|args-&gt;hobRegister
(braket
id|IDE_FEATURE_OFFSET_HOB
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;HTF.2=x%02x &quot;
comma
id|args-&gt;hobRegister
(braket
id|IDE_NSECTOR_OFFSET_HOB
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;HTF.3=x%02x &quot;
comma
id|args-&gt;hobRegister
(braket
id|IDE_SECTOR_OFFSET_HOB
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;HTF.4=x%02x &quot;
comma
id|args-&gt;hobRegister
(braket
id|IDE_LCYL_OFFSET_HOB
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;HTF.5=x%02x &quot;
comma
id|args-&gt;hobRegister
(braket
id|IDE_HCYL_OFFSET_HOB
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;HTF.6=x%02x &quot;
comma
id|args-&gt;hobRegister
(braket
id|IDE_SELECT_OFFSET_HOB
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;HTF.7=x%02x&bslash;n&quot;
comma
id|args-&gt;hobRegister
(braket
id|IDE_CONTROL_OFFSET_HOB
)braket
)paren
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_IDE_TASK_IOCTL_DEBUG */
DECL|function|do_rw_taskfile
id|ide_startstop_t
id|do_rw_taskfile
(paren
id|ide_drive_t
op_star
id|drive
comma
id|ide_task_t
op_star
id|task
)paren
(brace
id|ide_hwif_t
op_star
id|hwif
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
suffix:semicolon
id|task_struct_t
op_star
id|taskfile
op_assign
(paren
id|task_struct_t
op_star
)paren
id|task-&gt;tfRegister
suffix:semicolon
id|hob_struct_t
op_star
id|hobfile
op_assign
(paren
id|hob_struct_t
op_star
)paren
id|task-&gt;hobRegister
suffix:semicolon
id|u8
id|HIHI
op_assign
(paren
id|drive-&gt;addressing
op_eq
l_int|1
)paren
ques
c_cond
l_int|0xE0
suffix:colon
l_int|0xEF
suffix:semicolon
macro_line|#ifdef CONFIG_IDE_TASK_IOCTL_DEBUG
r_void
id|debug_taskfile
c_func
(paren
id|drive
comma
id|task
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_IDE_TASK_IOCTL_DEBUG */
multiline_comment|/* ALL Command Block Executions SHALL clear nIEN, unless otherwise */
r_if
c_cond
(paren
id|IDE_CONTROL_REG
)paren
(brace
multiline_comment|/* clear nIEN */
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|drive-&gt;ctl
comma
id|IDE_CONTROL_REG
)paren
suffix:semicolon
)brace
id|SELECT_MASK
c_func
(paren
id|drive
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;addressing
op_eq
l_int|1
)paren
(brace
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|hobfile-&gt;feature
comma
id|IDE_FEATURE_REG
)paren
suffix:semicolon
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|hobfile-&gt;sector_count
comma
id|IDE_NSECTOR_REG
)paren
suffix:semicolon
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|hobfile-&gt;sector_number
comma
id|IDE_SECTOR_REG
)paren
suffix:semicolon
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|hobfile-&gt;low_cylinder
comma
id|IDE_LCYL_REG
)paren
suffix:semicolon
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|hobfile-&gt;high_cylinder
comma
id|IDE_HCYL_REG
)paren
suffix:semicolon
)brace
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|taskfile-&gt;feature
comma
id|IDE_FEATURE_REG
)paren
suffix:semicolon
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|taskfile-&gt;sector_count
comma
id|IDE_NSECTOR_REG
)paren
suffix:semicolon
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|taskfile-&gt;sector_number
comma
id|IDE_SECTOR_REG
)paren
suffix:semicolon
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|taskfile-&gt;low_cylinder
comma
id|IDE_LCYL_REG
)paren
suffix:semicolon
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|taskfile-&gt;high_cylinder
comma
id|IDE_HCYL_REG
)paren
suffix:semicolon
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
(paren
id|taskfile-&gt;device_head
op_amp
id|HIHI
)paren
op_or
id|drive-&gt;select.all
comma
id|IDE_SELECT_REG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|task-&gt;handler
op_ne
l_int|NULL
)paren
(brace
id|ide_set_handler
c_func
(paren
id|drive
comma
id|task-&gt;handler
comma
id|WAIT_WORSTCASE
comma
l_int|NULL
)paren
suffix:semicolon
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|taskfile-&gt;command
comma
id|IDE_COMMAND_REG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|task-&gt;prehandler
op_ne
l_int|NULL
)paren
r_return
id|task
op_member_access_from_pointer
id|prehandler
c_func
(paren
id|drive
comma
id|task-&gt;rq
)paren
suffix:semicolon
r_return
id|ide_started
suffix:semicolon
)brace
multiline_comment|/* for dma commands we down set the handler */
r_if
c_cond
(paren
id|blk_fs_request
c_func
(paren
id|task-&gt;rq
)paren
op_logical_and
id|drive-&gt;using_dma
)paren
(brace
r_if
c_cond
(paren
id|rq_data_dir
c_func
(paren
id|task-&gt;rq
)paren
op_eq
id|READ
)paren
(brace
r_if
c_cond
(paren
id|hwif
op_member_access_from_pointer
id|ide_dma_read
c_func
(paren
id|drive
)paren
)paren
r_return
id|ide_stopped
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|hwif
op_member_access_from_pointer
id|ide_dma_write
c_func
(paren
id|drive
)paren
)paren
r_return
id|ide_stopped
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
id|drive-&gt;using_dma
op_logical_and
(paren
id|task-&gt;handler
op_eq
l_int|NULL
)paren
)paren
r_return
id|ide_stopped
suffix:semicolon
r_switch
c_cond
(paren
id|taskfile-&gt;command
)paren
(brace
r_case
id|WIN_WRITEDMA_ONCE
suffix:colon
r_case
id|WIN_WRITEDMA
suffix:colon
r_case
id|WIN_WRITEDMA_EXT
suffix:colon
r_if
c_cond
(paren
id|hwif
op_member_access_from_pointer
id|ide_dma_write
c_func
(paren
id|drive
)paren
)paren
r_return
id|ide_stopped
suffix:semicolon
r_break
suffix:semicolon
r_case
id|WIN_READDMA_ONCE
suffix:colon
r_case
id|WIN_READDMA
suffix:colon
r_case
id|WIN_READDMA_EXT
suffix:colon
r_case
id|WIN_IDENTIFY_DMA
suffix:colon
r_if
c_cond
(paren
id|hwif
op_member_access_from_pointer
id|ide_dma_read
c_func
(paren
id|drive
)paren
)paren
r_return
id|ide_stopped
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
r_if
c_cond
(paren
id|task-&gt;handler
op_eq
l_int|NULL
)paren
r_return
id|ide_stopped
suffix:semicolon
)brace
)brace
r_return
id|ide_started
suffix:semicolon
)brace
DECL|variable|do_rw_taskfile
id|EXPORT_SYMBOL
c_func
(paren
id|do_rw_taskfile
)paren
suffix:semicolon
multiline_comment|/*&n; * Error reporting, in human readable form (luxurious, but a memory hog).&n; */
DECL|function|taskfile_dump_status
id|u8
id|taskfile_dump_status
(paren
id|ide_drive_t
op_star
id|drive
comma
r_const
r_char
op_star
id|msg
comma
id|u8
id|stat
)paren
(brace
id|ide_hwif_t
op_star
id|hwif
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|u8
id|err
op_assign
l_int|0
suffix:semicolon
id|local_irq_set
c_func
(paren
id|flags
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: %s: status=0x%02x&quot;
comma
id|drive-&gt;name
comma
id|msg
comma
id|stat
)paren
suffix:semicolon
macro_line|#if FANCY_STATUS_DUMPS
id|printk
c_func
(paren
l_string|&quot; { &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_amp
id|BUSY_STAT
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Busy &quot;
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|stat
op_amp
id|READY_STAT
)paren
id|printk
c_func
(paren
l_string|&quot;DriveReady &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_amp
id|WRERR_STAT
)paren
id|printk
c_func
(paren
l_string|&quot;DeviceFault &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_amp
id|SEEK_STAT
)paren
id|printk
c_func
(paren
l_string|&quot;SeekComplete &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_amp
id|DRQ_STAT
)paren
id|printk
c_func
(paren
l_string|&quot;DataRequest &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_amp
id|ECC_STAT
)paren
id|printk
c_func
(paren
l_string|&quot;CorrectedError &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_amp
id|INDEX_STAT
)paren
id|printk
c_func
(paren
l_string|&quot;Index &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_amp
id|ERR_STAT
)paren
id|printk
c_func
(paren
l_string|&quot;Error &quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;}&quot;
)paren
suffix:semicolon
macro_line|#endif  /* FANCY_STATUS_DUMPS */
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|stat
op_amp
(paren
id|BUSY_STAT
op_or
id|ERR_STAT
)paren
)paren
op_eq
id|ERR_STAT
)paren
(brace
id|err
op_assign
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_ERROR_REG
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: %s: error=0x%02x&quot;
comma
id|drive-&gt;name
comma
id|msg
comma
id|err
)paren
suffix:semicolon
macro_line|#if FANCY_STATUS_DUMPS
r_if
c_cond
(paren
id|drive-&gt;media
op_eq
id|ide_disk
)paren
r_goto
id|media_out
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; { &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_amp
id|ABRT_ERR
)paren
id|printk
c_func
(paren
l_string|&quot;DriveStatusError &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_amp
id|ICRC_ERR
)paren
id|printk
c_func
(paren
l_string|&quot;Bad%s&quot;
comma
(paren
id|err
op_amp
id|ABRT_ERR
)paren
ques
c_cond
l_string|&quot;CRC &quot;
suffix:colon
l_string|&quot;Sector &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_amp
id|ECC_ERR
)paren
id|printk
c_func
(paren
l_string|&quot;UncorrectableError &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_amp
id|ID_ERR
)paren
id|printk
c_func
(paren
l_string|&quot;SectorIdNotFound &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_amp
id|TRK0_ERR
)paren
id|printk
c_func
(paren
l_string|&quot;TrackZeroNotFound &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_amp
id|MARK_ERR
)paren
id|printk
c_func
(paren
l_string|&quot;AddrMarkNotFound &quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;}&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_amp
(paren
id|BBD_ERR
op_or
id|ABRT_ERR
)paren
)paren
op_eq
id|BBD_ERR
op_logical_or
(paren
id|err
op_amp
(paren
id|ECC_ERR
op_or
id|ID_ERR
op_or
id|MARK_ERR
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|drive-&gt;addressing
op_eq
l_int|1
)paren
(brace
id|u64
id|sectors
op_assign
l_int|0
suffix:semicolon
id|u32
id|high
op_assign
l_int|0
suffix:semicolon
id|u32
id|low
op_assign
id|task_read_24
c_func
(paren
id|drive
)paren
suffix:semicolon
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
l_int|0x80
comma
id|IDE_CONTROL_REG
)paren
suffix:semicolon
id|high
op_assign
id|task_read_24
c_func
(paren
id|drive
)paren
suffix:semicolon
id|sectors
op_assign
(paren
(paren
id|u64
)paren
id|high
op_lshift
l_int|24
)paren
op_or
id|low
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;, LBAsect=%lld&quot;
comma
id|sectors
)paren
suffix:semicolon
)brace
r_else
(brace
id|u8
id|cur
op_assign
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_SELECT_REG
)paren
suffix:semicolon
id|u8
id|low
op_assign
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_LCYL_REG
)paren
suffix:semicolon
id|u8
id|high
op_assign
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_HCYL_REG
)paren
suffix:semicolon
id|u8
id|sect
op_assign
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_SECTOR_REG
)paren
suffix:semicolon
multiline_comment|/* using LBA? */
r_if
c_cond
(paren
id|cur
op_amp
l_int|0x40
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;, LBAsect=%d&quot;
comma
(paren
id|u32
)paren
(paren
(paren
id|cur
op_amp
l_int|0xf
)paren
op_lshift
l_int|24
)paren
op_or
(paren
id|high
op_lshift
l_int|16
)paren
op_or
(paren
id|low
op_lshift
l_int|8
)paren
op_or
id|sect
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;, CHS=%d/%d/%d&quot;
comma
(paren
(paren
id|high
op_lshift
l_int|8
)paren
op_plus
id|low
)paren
comma
(paren
id|cur
op_amp
l_int|0xf
)paren
comma
id|sect
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
)paren
id|printk
c_func
(paren
l_string|&quot;, sector=%lu&quot;
comma
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq-&gt;sector
)paren
suffix:semicolon
)brace
id|media_out
suffix:colon
macro_line|#endif  /* FANCY_STATUS_DUMPS */
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|local_irq_restore
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|variable|taskfile_dump_status
id|EXPORT_SYMBOL
c_func
(paren
id|taskfile_dump_status
)paren
suffix:semicolon
multiline_comment|/*&n; * Clean up after success/failure of an explicit taskfile operation.&n; */
DECL|function|ide_end_taskfile
r_void
id|ide_end_taskfile
(paren
id|ide_drive_t
op_star
id|drive
comma
id|u8
id|stat
comma
id|u8
id|err
)paren
(brace
id|ide_hwif_t
op_star
id|hwif
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|request
op_star
id|rq
suffix:semicolon
id|ide_task_t
op_star
id|args
suffix:semicolon
id|task_ioreg_t
id|command
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ide_lock
comma
id|flags
)paren
suffix:semicolon
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ide_lock
comma
id|flags
)paren
suffix:semicolon
id|args
op_assign
(paren
id|ide_task_t
op_star
)paren
id|rq-&gt;special
suffix:semicolon
id|command
op_assign
id|args-&gt;tfRegister
(braket
id|IDE_COMMAND_OFFSET
)braket
suffix:semicolon
r_if
c_cond
(paren
id|rq-&gt;errors
op_eq
l_int|0
)paren
id|rq-&gt;errors
op_assign
op_logical_neg
id|OK_STAT
c_func
(paren
id|stat
comma
id|READY_STAT
comma
id|BAD_STAT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|args-&gt;tf_in_flags.b.data
)paren
(brace
id|u16
id|data
op_assign
id|hwif
op_member_access_from_pointer
id|INW
c_func
(paren
id|IDE_DATA_REG
)paren
suffix:semicolon
id|args-&gt;tfRegister
(braket
id|IDE_DATA_OFFSET
)braket
op_assign
(paren
id|data
)paren
op_amp
l_int|0xFF
suffix:semicolon
id|args-&gt;hobRegister
(braket
id|IDE_DATA_OFFSET_HOB
)braket
op_assign
(paren
id|data
op_rshift
l_int|8
)paren
op_amp
l_int|0xFF
suffix:semicolon
)brace
id|args-&gt;tfRegister
(braket
id|IDE_ERROR_OFFSET
)braket
op_assign
id|err
suffix:semicolon
id|args-&gt;tfRegister
(braket
id|IDE_NSECTOR_OFFSET
)braket
op_assign
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_NSECTOR_REG
)paren
suffix:semicolon
id|args-&gt;tfRegister
(braket
id|IDE_SECTOR_OFFSET
)braket
op_assign
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_SECTOR_REG
)paren
suffix:semicolon
id|args-&gt;tfRegister
(braket
id|IDE_LCYL_OFFSET
)braket
op_assign
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_LCYL_REG
)paren
suffix:semicolon
id|args-&gt;tfRegister
(braket
id|IDE_HCYL_OFFSET
)braket
op_assign
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_HCYL_REG
)paren
suffix:semicolon
id|args-&gt;tfRegister
(braket
id|IDE_SELECT_OFFSET
)braket
op_assign
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_SELECT_REG
)paren
suffix:semicolon
id|args-&gt;tfRegister
(braket
id|IDE_STATUS_OFFSET
)braket
op_assign
id|stat
suffix:semicolon
r_if
c_cond
(paren
(paren
id|drive-&gt;id-&gt;command_set_2
op_amp
l_int|0x0400
)paren
op_logical_and
(paren
id|drive-&gt;id-&gt;cfs_enable_2
op_amp
l_int|0x0400
)paren
op_logical_and
(paren
id|drive-&gt;addressing
op_eq
l_int|1
)paren
)paren
(brace
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|drive-&gt;ctl
op_or
l_int|0x80
comma
id|IDE_CONTROL_REG_HOB
)paren
suffix:semicolon
id|args-&gt;hobRegister
(braket
id|IDE_FEATURE_OFFSET_HOB
)braket
op_assign
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_FEATURE_REG
)paren
suffix:semicolon
id|args-&gt;hobRegister
(braket
id|IDE_NSECTOR_OFFSET_HOB
)braket
op_assign
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_NSECTOR_REG
)paren
suffix:semicolon
id|args-&gt;hobRegister
(braket
id|IDE_SECTOR_OFFSET_HOB
)braket
op_assign
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_SECTOR_REG
)paren
suffix:semicolon
id|args-&gt;hobRegister
(braket
id|IDE_LCYL_OFFSET_HOB
)braket
op_assign
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_LCYL_REG
)paren
suffix:semicolon
id|args-&gt;hobRegister
(braket
id|IDE_HCYL_OFFSET_HOB
)braket
op_assign
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_HCYL_REG
)paren
suffix:semicolon
)brace
macro_line|#if 0
multiline_comment|/*&t;taskfile_settings_update(drive, args, command); */
r_if
c_cond
(paren
id|args-&gt;posthandler
op_ne
l_int|NULL
)paren
id|args
op_member_access_from_pointer
id|posthandler
c_func
(paren
id|drive
comma
id|args
)paren
suffix:semicolon
macro_line|#endif
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ide_lock
comma
id|flags
)paren
suffix:semicolon
id|blkdev_dequeue_request
c_func
(paren
id|rq
)paren
suffix:semicolon
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
op_assign
l_int|NULL
suffix:semicolon
id|end_that_request_last
c_func
(paren
id|rq
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ide_lock
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|variable|ide_end_taskfile
id|EXPORT_SYMBOL
c_func
(paren
id|ide_end_taskfile
)paren
suffix:semicolon
multiline_comment|/*&n; * try_to_flush_leftover_data() is invoked in response to a drive&n; * unexpectedly having its DRQ_STAT bit set.  As an alternative to&n; * resetting the drive, this routine tries to clear the condition&n; * by read a sector&squot;s worth of data from the drive.  Of course,&n; * this may not help if the drive is *waiting* for data from *us*.&n; */
DECL|function|task_try_to_flush_leftover_data
r_void
id|task_try_to_flush_leftover_data
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_int
id|i
op_assign
(paren
id|drive-&gt;mult_count
ques
c_cond
id|drive-&gt;mult_count
suffix:colon
l_int|1
)paren
op_star
id|SECTOR_WORDS
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;media
op_ne
id|ide_disk
)paren
r_return
suffix:semicolon
r_while
c_loop
(paren
id|i
OG
l_int|0
)paren
(brace
id|u32
id|buffer
(braket
l_int|16
)braket
suffix:semicolon
r_int
r_int
id|wcount
op_assign
(paren
id|i
OG
l_int|16
)paren
ques
c_cond
l_int|16
suffix:colon
id|i
suffix:semicolon
id|i
op_sub_assign
id|wcount
suffix:semicolon
id|taskfile_input_data
c_func
(paren
id|drive
comma
id|buffer
comma
id|wcount
)paren
suffix:semicolon
)brace
)brace
DECL|variable|task_try_to_flush_leftover_data
id|EXPORT_SYMBOL
c_func
(paren
id|task_try_to_flush_leftover_data
)paren
suffix:semicolon
multiline_comment|/*&n; * taskfile_error() takes action based on the error returned by the drive.&n; */
DECL|function|taskfile_error
id|ide_startstop_t
id|taskfile_error
(paren
id|ide_drive_t
op_star
id|drive
comma
r_const
r_char
op_star
id|msg
comma
id|u8
id|stat
)paren
(brace
id|ide_hwif_t
op_star
id|hwif
suffix:semicolon
r_struct
id|request
op_star
id|rq
suffix:semicolon
id|u8
id|err
suffix:semicolon
id|err
op_assign
id|taskfile_dump_status
c_func
(paren
id|drive
comma
id|msg
comma
id|stat
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drive
op_eq
l_int|NULL
op_logical_or
(paren
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
)paren
op_eq
l_int|NULL
)paren
r_return
id|ide_stopped
suffix:semicolon
id|hwif
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
suffix:semicolon
multiline_comment|/* retry only &quot;normal&quot; I/O: */
r_if
c_cond
(paren
id|rq-&gt;flags
op_amp
id|REQ_DRIVE_TASKFILE
)paren
(brace
id|rq-&gt;errors
op_assign
l_int|1
suffix:semicolon
id|ide_end_taskfile
c_func
(paren
id|drive
comma
id|stat
comma
id|err
)paren
suffix:semicolon
r_return
id|ide_stopped
suffix:semicolon
)brace
r_if
c_cond
(paren
id|stat
op_amp
id|BUSY_STAT
op_logical_or
(paren
(paren
id|stat
op_amp
id|WRERR_STAT
)paren
op_logical_and
op_logical_neg
id|drive-&gt;nowerr
)paren
)paren
(brace
multiline_comment|/* other bits are useless when BUSY */
id|rq-&gt;errors
op_or_assign
id|ERROR_RESET
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|drive-&gt;media
op_ne
id|ide_disk
)paren
r_goto
id|media_out
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_amp
id|ERR_STAT
)paren
(brace
multiline_comment|/* err has different meaning on cdrom and tape */
r_if
c_cond
(paren
id|err
op_eq
id|ABRT_ERR
)paren
(brace
r_if
c_cond
(paren
id|drive-&gt;select.b.lba
op_logical_and
(paren
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_COMMAND_REG
)paren
op_eq
id|WIN_SPECIFY
)paren
)paren
multiline_comment|/* some newer drives don&squot;t&n;&t;&t;&t;&t;&t; * support WIN_SPECIFY&n;&t;&t;&t;&t;&t; */
r_return
id|ide_stopped
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|err
op_amp
id|BAD_CRC
)paren
op_eq
id|BAD_CRC
)paren
(brace
multiline_comment|/* UDMA crc error -- just retry the operation */
id|drive-&gt;crc_count
op_increment
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|err
op_amp
(paren
id|BBD_ERR
op_or
id|ECC_ERR
)paren
)paren
(brace
multiline_comment|/* retries won&squot;t help these */
id|rq-&gt;errors
op_assign
id|ERROR_MAX
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|err
op_amp
id|TRK0_ERR
)paren
(brace
multiline_comment|/* help it find track zero */
id|rq-&gt;errors
op_or_assign
id|ERROR_RECAL
suffix:semicolon
)brace
)brace
id|media_out
suffix:colon
r_if
c_cond
(paren
(paren
id|stat
op_amp
id|DRQ_STAT
)paren
op_logical_and
id|rq_data_dir
c_func
(paren
id|rq
)paren
op_ne
id|WRITE
)paren
id|task_try_to_flush_leftover_data
c_func
(paren
id|drive
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_STATUS_REG
)paren
op_amp
(paren
id|BUSY_STAT
op_or
id|DRQ_STAT
)paren
)paren
(brace
multiline_comment|/* force an abort */
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|WIN_IDLEIMMEDIATE
comma
id|IDE_COMMAND_REG
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rq-&gt;errors
op_ge
id|ERROR_MAX
)paren
(brace
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|end_request
c_func
(paren
id|drive
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
(paren
id|rq-&gt;errors
op_amp
id|ERROR_RESET
)paren
op_eq
id|ERROR_RESET
)paren
(brace
op_increment
id|rq-&gt;errors
suffix:semicolon
r_return
id|ide_do_reset
c_func
(paren
id|drive
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|rq-&gt;errors
op_amp
id|ERROR_RECAL
)paren
op_eq
id|ERROR_RECAL
)paren
id|drive-&gt;special.b.recalibrate
op_assign
l_int|1
suffix:semicolon
op_increment
id|rq-&gt;errors
suffix:semicolon
)brace
r_return
id|ide_stopped
suffix:semicolon
)brace
DECL|variable|taskfile_error
id|EXPORT_SYMBOL
c_func
(paren
id|taskfile_error
)paren
suffix:semicolon
multiline_comment|/*&n; * set_multmode_intr() is invoked on completion of a WIN_SETMULT cmd.&n; */
DECL|function|set_multmode_intr
id|ide_startstop_t
id|set_multmode_intr
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|ide_hwif_t
op_star
id|hwif
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
suffix:semicolon
id|u8
id|stat
suffix:semicolon
r_if
c_cond
(paren
id|OK_STAT
c_func
(paren
id|stat
op_assign
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_STATUS_REG
)paren
comma
id|READY_STAT
comma
id|BAD_STAT
)paren
)paren
(brace
id|drive-&gt;mult_count
op_assign
id|drive-&gt;mult_req
suffix:semicolon
)brace
r_else
(brace
id|drive-&gt;mult_req
op_assign
id|drive-&gt;mult_count
op_assign
l_int|0
suffix:semicolon
id|drive-&gt;special.b.recalibrate
op_assign
l_int|1
suffix:semicolon
(paren
r_void
)paren
id|ide_dump_status
c_func
(paren
id|drive
comma
l_string|&quot;set_multmode&quot;
comma
id|stat
)paren
suffix:semicolon
)brace
r_return
id|ide_stopped
suffix:semicolon
)brace
DECL|variable|set_multmode_intr
id|EXPORT_SYMBOL
c_func
(paren
id|set_multmode_intr
)paren
suffix:semicolon
multiline_comment|/*&n; * set_geometry_intr() is invoked on completion of a WIN_SPECIFY cmd.&n; */
DECL|function|set_geometry_intr
id|ide_startstop_t
id|set_geometry_intr
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|ide_hwif_t
op_star
id|hwif
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
suffix:semicolon
r_int
id|retries
op_assign
l_int|5
suffix:semicolon
id|u8
id|stat
suffix:semicolon
r_while
c_loop
(paren
(paren
(paren
id|stat
op_assign
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_STATUS_REG
)paren
)paren
op_amp
id|BUSY_STAT
)paren
op_logical_and
id|retries
op_decrement
)paren
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
r_if
c_cond
(paren
id|OK_STAT
c_func
(paren
id|stat
comma
id|READY_STAT
comma
id|BAD_STAT
)paren
)paren
r_return
id|ide_stopped
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_amp
(paren
id|ERR_STAT
op_or
id|DRQ_STAT
)paren
)paren
r_return
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|error
c_func
(paren
id|drive
comma
l_string|&quot;set_geometry_intr&quot;
comma
id|stat
)paren
suffix:semicolon
r_if
c_cond
(paren
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|handler
op_ne
l_int|NULL
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|ide_set_handler
c_func
(paren
id|drive
comma
op_amp
id|set_geometry_intr
comma
id|WAIT_WORSTCASE
comma
l_int|NULL
)paren
suffix:semicolon
r_return
id|ide_started
suffix:semicolon
)brace
DECL|variable|set_geometry_intr
id|EXPORT_SYMBOL
c_func
(paren
id|set_geometry_intr
)paren
suffix:semicolon
multiline_comment|/*&n; * recal_intr() is invoked on completion of a WIN_RESTORE (recalibrate) cmd.&n; */
DECL|function|recal_intr
id|ide_startstop_t
id|recal_intr
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|ide_hwif_t
op_star
id|hwif
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
suffix:semicolon
id|u8
id|stat
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|OK_STAT
c_func
(paren
id|stat
op_assign
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_STATUS_REG
)paren
comma
id|READY_STAT
comma
id|BAD_STAT
)paren
)paren
r_return
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|error
c_func
(paren
id|drive
comma
l_string|&quot;recal_intr&quot;
comma
id|stat
)paren
suffix:semicolon
r_return
id|ide_stopped
suffix:semicolon
)brace
DECL|variable|recal_intr
id|EXPORT_SYMBOL
c_func
(paren
id|recal_intr
)paren
suffix:semicolon
multiline_comment|/*&n; * Handler for commands without a data phase&n; */
DECL|function|task_no_data_intr
id|ide_startstop_t
id|task_no_data_intr
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|ide_task_t
op_star
id|args
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq-&gt;special
suffix:semicolon
id|ide_hwif_t
op_star
id|hwif
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
suffix:semicolon
id|u8
id|stat
suffix:semicolon
id|local_irq_enable
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|OK_STAT
c_func
(paren
id|stat
op_assign
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_STATUS_REG
)paren
comma
id|READY_STAT
comma
id|BAD_STAT
)paren
)paren
(brace
id|DTF
c_func
(paren
l_string|&quot;%s: command opcode 0x%02x&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|args-&gt;tfRegister
(braket
id|IDE_COMMAND_OFFSET
)braket
)paren
suffix:semicolon
r_return
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|error
c_func
(paren
id|drive
comma
l_string|&quot;task_no_data_intr&quot;
comma
id|stat
)paren
suffix:semicolon
multiline_comment|/* calls ide_end_drive_cmd */
)brace
r_if
c_cond
(paren
id|args
)paren
id|ide_end_drive_cmd
c_func
(paren
id|drive
comma
id|stat
comma
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_ERROR_REG
)paren
)paren
suffix:semicolon
r_return
id|ide_stopped
suffix:semicolon
)brace
DECL|variable|task_no_data_intr
id|EXPORT_SYMBOL
c_func
(paren
id|task_no_data_intr
)paren
suffix:semicolon
multiline_comment|/*&n; * Handler for command with PIO data-in phase, READ&n; */
multiline_comment|/*&n; * FIXME before 2.4 enable ...&n; *&t;DATA integrity issue upon error. &lt;andre@linux-ide.org&gt;&n; */
DECL|function|task_in_intr
id|ide_startstop_t
id|task_in_intr
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_struct
id|request
op_star
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
id|ide_hwif_t
op_star
id|hwif
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
suffix:semicolon
r_char
op_star
id|pBuf
op_assign
l_int|NULL
suffix:semicolon
id|u8
id|stat
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|OK_STAT
c_func
(paren
id|stat
op_assign
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_STATUS_REG
)paren
comma
id|DATA_READY
comma
id|BAD_R_STAT
)paren
)paren
(brace
r_if
c_cond
(paren
id|stat
op_amp
(paren
id|ERR_STAT
op_or
id|DRQ_STAT
)paren
)paren
(brace
macro_line|#if 0
id|DTF
c_func
(paren
l_string|&quot;%s: attempting to recover last &quot;
"&bslash;"
l_string|&quot;sector counter status=0x%02x&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|stat
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Expect a BUG BOMB if we attempt to rewind the&n;&t;&t;&t; * offset in the BH aka PAGE in the current BLOCK&n;&t;&t;&t; * segment.  This is different than the HOST segment.&n;&t;&t;&t; */
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|rq-&gt;bio
)paren
id|rq-&gt;current_nr_sectors
op_increment
suffix:semicolon
r_return
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|error
c_func
(paren
id|drive
comma
l_string|&quot;task_in_intr&quot;
comma
id|stat
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|stat
op_amp
id|BUSY_STAT
)paren
)paren
(brace
id|DTF
c_func
(paren
l_string|&quot;task_in_intr to Soon wait for next interrupt&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|handler
op_eq
l_int|NULL
)paren
id|ide_set_handler
c_func
(paren
id|drive
comma
op_amp
id|task_in_intr
comma
id|WAIT_WORSTCASE
comma
l_int|NULL
)paren
suffix:semicolon
r_return
id|ide_started
suffix:semicolon
)brace
)brace
macro_line|#if 0
multiline_comment|/*&n;&t; * Holding point for a brain dump of a thought :-/&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|OK_STAT
c_func
(paren
id|stat
comma
id|DRIVE_READY
comma
id|drive-&gt;bad_wstat
)paren
)paren
(brace
id|DTF
c_func
(paren
l_string|&quot;%s: READ attempting to recover last &quot;
"&bslash;"
l_string|&quot;sector counter status=0x%02x&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|stat
)paren
suffix:semicolon
id|rq-&gt;current_nr_sectors
op_increment
suffix:semicolon
r_return
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|error
c_func
(paren
id|drive
comma
l_string|&quot;task_in_intr&quot;
comma
id|stat
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|rq-&gt;current_nr_sectors
)paren
r_if
c_cond
(paren
op_logical_neg
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|end_request
c_func
(paren
id|drive
comma
l_int|1
comma
l_int|0
)paren
)paren
r_return
id|ide_stopped
suffix:semicolon
r_if
c_cond
(paren
op_decrement
id|rq-&gt;current_nr_sectors
op_le
l_int|0
)paren
r_if
c_cond
(paren
op_logical_neg
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|end_request
c_func
(paren
id|drive
comma
l_int|1
comma
l_int|0
)paren
)paren
r_return
id|ide_stopped
suffix:semicolon
macro_line|#endif
id|pBuf
op_assign
id|task_map_rq
c_func
(paren
id|rq
comma
op_amp
id|flags
)paren
suffix:semicolon
id|DTF
c_func
(paren
l_string|&quot;Read: %p, rq-&gt;current_nr_sectors: %d, stat: %02x&bslash;n&quot;
comma
id|pBuf
comma
(paren
r_int
)paren
id|rq-&gt;current_nr_sectors
comma
id|stat
)paren
suffix:semicolon
id|taskfile_input_data
c_func
(paren
id|drive
comma
id|pBuf
comma
id|SECTOR_WORDS
)paren
suffix:semicolon
id|task_unmap_rq
c_func
(paren
id|rq
comma
id|pBuf
comma
op_amp
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * FIXME :: We really can not legally get a new page/bh&n;&t; * regardless, if this is the end of our segment.&n;&t; * BH walking or segment can only be updated after we have a good&n;&t; * hwif-&gt;INB(IDE_STATUS_REG); return.&n;&t; */
r_if
c_cond
(paren
op_decrement
id|rq-&gt;current_nr_sectors
op_le
l_int|0
)paren
r_if
c_cond
(paren
op_logical_neg
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|end_request
c_func
(paren
id|drive
comma
l_int|1
comma
l_int|0
)paren
)paren
r_return
id|ide_stopped
suffix:semicolon
multiline_comment|/*&n;&t; * ERM, it is techincally legal to leave/exit here but it makes&n;&t; * a mess of the code ...&n;&t; */
r_if
c_cond
(paren
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|handler
op_eq
l_int|NULL
)paren
id|ide_set_handler
c_func
(paren
id|drive
comma
op_amp
id|task_in_intr
comma
id|WAIT_WORSTCASE
comma
l_int|NULL
)paren
suffix:semicolon
r_return
id|ide_started
suffix:semicolon
)brace
DECL|variable|task_in_intr
id|EXPORT_SYMBOL
c_func
(paren
id|task_in_intr
)paren
suffix:semicolon
multiline_comment|/*&n; * Handler for command with Read Multiple&n; */
DECL|function|task_mulin_intr
id|ide_startstop_t
id|task_mulin_intr
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|ide_hwif_t
op_star
id|hwif
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
suffix:semicolon
r_struct
id|request
op_star
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
r_char
op_star
id|pBuf
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|msect
op_assign
id|drive-&gt;mult_count
suffix:semicolon
r_int
r_int
id|nsect
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|u8
id|stat
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|OK_STAT
c_func
(paren
id|stat
op_assign
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_STATUS_REG
)paren
comma
id|DATA_READY
comma
id|BAD_R_STAT
)paren
)paren
(brace
r_if
c_cond
(paren
id|stat
op_amp
(paren
id|ERR_STAT
op_or
id|DRQ_STAT
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|rq-&gt;bio
)paren
(brace
id|rq-&gt;current_nr_sectors
op_add_assign
id|drive-&gt;mult_count
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * NOTE: could rewind beyond beginning :-/&n;&t;&t;&t;&t; */
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;%s: MULTI-READ assume all data &quot;
"&bslash;"
l_string|&quot;transfered is bad status=0x%02x&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|stat
)paren
suffix:semicolon
)brace
r_return
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|error
c_func
(paren
id|drive
comma
l_string|&quot;task_mulin_intr&quot;
comma
id|stat
)paren
suffix:semicolon
)brace
multiline_comment|/* no data yet, so wait for another interrupt */
r_if
c_cond
(paren
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|handler
op_eq
l_int|NULL
)paren
id|ide_set_handler
c_func
(paren
id|drive
comma
op_amp
id|task_mulin_intr
comma
id|WAIT_WORSTCASE
comma
l_int|NULL
)paren
suffix:semicolon
r_return
id|ide_started
suffix:semicolon
)brace
r_do
(brace
id|nsect
op_assign
id|rq-&gt;current_nr_sectors
suffix:semicolon
r_if
c_cond
(paren
id|nsect
OG
id|msect
)paren
id|nsect
op_assign
id|msect
suffix:semicolon
id|pBuf
op_assign
id|task_map_rq
c_func
(paren
id|rq
comma
op_amp
id|flags
)paren
suffix:semicolon
id|DTF
c_func
(paren
l_string|&quot;Multiread: %p, nsect: %d, msect: %d, &quot;
"&bslash;"
l_string|&quot; rq-&gt;current_nr_sectors: %d&bslash;n&quot;
comma
id|pBuf
comma
id|nsect
comma
id|msect
comma
id|rq-&gt;current_nr_sectors
)paren
suffix:semicolon
id|taskfile_input_data
c_func
(paren
id|drive
comma
id|pBuf
comma
id|nsect
op_star
id|SECTOR_WORDS
)paren
suffix:semicolon
id|task_unmap_rq
c_func
(paren
id|rq
comma
id|pBuf
comma
op_amp
id|flags
)paren
suffix:semicolon
id|rq-&gt;errors
op_assign
l_int|0
suffix:semicolon
id|rq-&gt;current_nr_sectors
op_sub_assign
id|nsect
suffix:semicolon
id|msect
op_sub_assign
id|nsect
suffix:semicolon
multiline_comment|/*&n;&t;&t; * FIXME :: We really can not legally get a new page/bh&n;&t;&t; * regardless, if this is the end of our segment.&n;&t;&t; * BH walking or segment can only be updated after we have a&n;&t;&t; * good hwif-&gt;INB(IDE_STATUS_REG); return.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|rq-&gt;current_nr_sectors
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|end_request
c_func
(paren
id|drive
comma
l_int|1
comma
l_int|0
)paren
)paren
r_return
id|ide_stopped
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|msect
)paren
suffix:semicolon
r_if
c_cond
(paren
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|handler
op_eq
l_int|NULL
)paren
id|ide_set_handler
c_func
(paren
id|drive
comma
op_amp
id|task_mulin_intr
comma
id|WAIT_WORSTCASE
comma
l_int|NULL
)paren
suffix:semicolon
r_return
id|ide_started
suffix:semicolon
)brace
DECL|variable|task_mulin_intr
id|EXPORT_SYMBOL
c_func
(paren
id|task_mulin_intr
)paren
suffix:semicolon
multiline_comment|/*&n; * VERIFY ME before 2.4 ... unexpected race is possible based on details&n; * RMK with 74LS245/373/374 TTL buffer logic because of passthrough.&n; */
DECL|function|pre_task_out_intr
id|ide_startstop_t
id|pre_task_out_intr
(paren
id|ide_drive_t
op_star
id|drive
comma
r_struct
id|request
op_star
id|rq
)paren
(brace
r_char
op_star
id|pBuf
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|ide_startstop_t
id|startstop
suffix:semicolon
r_if
c_cond
(paren
id|ide_wait_stat
c_func
(paren
op_amp
id|startstop
comma
id|drive
comma
id|DATA_READY
comma
id|drive-&gt;bad_wstat
comma
id|WAIT_DRQ
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: no DRQ after issuing WRITE%s&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|drive-&gt;addressing
ques
c_cond
l_string|&quot;_EXT&quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
r_return
id|startstop
suffix:semicolon
)brace
multiline_comment|/* For Write_sectors we need to stuff the first sector */
id|pBuf
op_assign
id|task_map_rq
c_func
(paren
id|rq
comma
op_amp
id|flags
)paren
suffix:semicolon
id|taskfile_output_data
c_func
(paren
id|drive
comma
id|pBuf
comma
id|SECTOR_WORDS
)paren
suffix:semicolon
id|rq-&gt;current_nr_sectors
op_decrement
suffix:semicolon
id|task_unmap_rq
c_func
(paren
id|rq
comma
id|pBuf
comma
op_amp
id|flags
)paren
suffix:semicolon
r_return
id|ide_started
suffix:semicolon
)brace
DECL|variable|pre_task_out_intr
id|EXPORT_SYMBOL
c_func
(paren
id|pre_task_out_intr
)paren
suffix:semicolon
multiline_comment|/*&n; * Handler for command with PIO data-out phase WRITE&n; *&n; * WOOHOO this is a CORRECT STATE DIAGRAM NOW, &lt;andre@linux-ide.org&gt;&n; */
DECL|function|task_out_intr
id|ide_startstop_t
id|task_out_intr
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|ide_hwif_t
op_star
id|hwif
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
suffix:semicolon
r_struct
id|request
op_star
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
r_char
op_star
id|pBuf
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|u8
id|stat
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|OK_STAT
c_func
(paren
id|stat
op_assign
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_STATUS_REG
)paren
comma
id|DRIVE_READY
comma
id|drive-&gt;bad_wstat
)paren
)paren
(brace
id|DTF
c_func
(paren
l_string|&quot;%s: WRITE attempting to recover last &quot;
"&bslash;"
l_string|&quot;sector counter status=0x%02x&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|stat
)paren
suffix:semicolon
id|rq-&gt;current_nr_sectors
op_increment
suffix:semicolon
r_return
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|error
c_func
(paren
id|drive
comma
l_string|&quot;task_out_intr&quot;
comma
id|stat
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Safe to update request for partial completions.&n;&t; * We have a good STATUS CHECK!!!&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|rq-&gt;current_nr_sectors
)paren
r_if
c_cond
(paren
op_logical_neg
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|end_request
c_func
(paren
id|drive
comma
l_int|1
comma
l_int|0
)paren
)paren
r_return
id|ide_stopped
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rq-&gt;current_nr_sectors
op_eq
l_int|1
)paren
op_xor
(paren
id|stat
op_amp
id|DRQ_STAT
)paren
)paren
(brace
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
id|pBuf
op_assign
id|task_map_rq
c_func
(paren
id|rq
comma
op_amp
id|flags
)paren
suffix:semicolon
id|DTF
c_func
(paren
l_string|&quot;write: %p, rq-&gt;current_nr_sectors: %d&bslash;n&quot;
comma
id|pBuf
comma
(paren
r_int
)paren
id|rq-&gt;current_nr_sectors
)paren
suffix:semicolon
id|taskfile_output_data
c_func
(paren
id|drive
comma
id|pBuf
comma
id|SECTOR_WORDS
)paren
suffix:semicolon
id|task_unmap_rq
c_func
(paren
id|rq
comma
id|pBuf
comma
op_amp
id|flags
)paren
suffix:semicolon
id|rq-&gt;errors
op_assign
l_int|0
suffix:semicolon
id|rq-&gt;current_nr_sectors
op_decrement
suffix:semicolon
)brace
r_if
c_cond
(paren
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|handler
op_eq
l_int|NULL
)paren
id|ide_set_handler
c_func
(paren
id|drive
comma
op_amp
id|task_out_intr
comma
id|WAIT_WORSTCASE
comma
l_int|NULL
)paren
suffix:semicolon
r_return
id|ide_started
suffix:semicolon
)brace
DECL|variable|task_out_intr
id|EXPORT_SYMBOL
c_func
(paren
id|task_out_intr
)paren
suffix:semicolon
DECL|macro|ALTERNATE_STATE_DIAGRAM_MULTI_OUT
macro_line|#undef ALTERNATE_STATE_DIAGRAM_MULTI_OUT
DECL|function|pre_task_mulout_intr
id|ide_startstop_t
id|pre_task_mulout_intr
(paren
id|ide_drive_t
op_star
id|drive
comma
r_struct
id|request
op_star
id|rq
)paren
(brace
macro_line|#ifdef ALTERNATE_STATE_DIAGRAM_MULTI_OUT
id|ide_hwif_t
op_star
id|hwif
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
suffix:semicolon
r_char
op_star
id|pBuf
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|nsect
op_assign
l_int|0
comma
id|msect
op_assign
id|drive-&gt;mult_count
suffix:semicolon
id|u8
id|stat
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
macro_line|#endif /* ALTERNATE_STATE_DIAGRAM_MULTI_OUT */
id|ide_task_t
op_star
id|args
op_assign
id|rq-&gt;special
suffix:semicolon
id|ide_startstop_t
id|startstop
suffix:semicolon
macro_line|#if 0
multiline_comment|/*&n;&t; * assign private copy for multi-write&n;&t; */
id|memcpy
c_func
(paren
op_amp
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|wrq
comma
id|rq
comma
r_sizeof
(paren
r_struct
id|request
)paren
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|ide_wait_stat
c_func
(paren
op_amp
id|startstop
comma
id|drive
comma
id|DATA_READY
comma
id|drive-&gt;bad_wstat
comma
id|WAIT_DRQ
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: no DRQ after issuing %s&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|drive-&gt;addressing
ques
c_cond
l_string|&quot;MULTWRITE_EXT&quot;
suffix:colon
l_string|&quot;MULTWRITE&quot;
)paren
suffix:semicolon
r_return
id|startstop
suffix:semicolon
)brace
macro_line|#ifdef ALTERNATE_STATE_DIAGRAM_MULTI_OUT
r_do
(brace
id|nsect
op_assign
id|rq-&gt;current_nr_sectors
suffix:semicolon
r_if
c_cond
(paren
id|nsect
OG
id|msect
)paren
id|nsect
op_assign
id|msect
suffix:semicolon
id|pBuf
op_assign
id|task_map_rq
c_func
(paren
id|rq
comma
op_amp
id|flags
)paren
suffix:semicolon
id|DTF
c_func
(paren
l_string|&quot;Pre-Multiwrite: %p, nsect: %d, msect: %d, &quot;
"&bslash;"
l_string|&quot;rq-&gt;current_nr_sectors: %ld&bslash;n&quot;
comma
id|pBuf
comma
id|nsect
comma
id|msect
comma
id|rq-&gt;current_nr_sectors
)paren
suffix:semicolon
id|msect
op_sub_assign
id|nsect
suffix:semicolon
id|taskfile_output_data
c_func
(paren
id|drive
comma
id|pBuf
comma
id|nsect
op_star
id|SECTOR_WORDS
)paren
suffix:semicolon
id|task_unmap_rq
c_func
(paren
id|rq
comma
id|pBuf
comma
op_amp
id|flags
)paren
suffix:semicolon
id|rq-&gt;current_nr_sectors
op_sub_assign
id|nsect
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rq-&gt;current_nr_sectors
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|end_request
c_func
(paren
id|drive
comma
l_int|1
comma
l_int|0
)paren
)paren
r_if
c_cond
(paren
op_logical_neg
id|rq-&gt;bio
)paren
(brace
id|stat
op_assign
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_STATUS_REG
)paren
suffix:semicolon
r_return
id|ide_stopped
suffix:semicolon
)brace
)brace
)brace
r_while
c_loop
(paren
id|msect
)paren
suffix:semicolon
id|rq-&gt;errors
op_assign
l_int|0
suffix:semicolon
r_return
id|ide_started
suffix:semicolon
macro_line|#else /* ! ALTERNATE_STATE_DIAGRAM_MULTI_OUT */
macro_line|#if 0
r_if
c_cond
(paren
id|wait_for_ready
c_func
(paren
id|drive
comma
l_int|100
)paren
)paren
id|IDE_DEBUG
c_func
(paren
id|__LINE__
)paren
suffix:semicolon
singleline_comment|//BUG();
macro_line|#else
r_if
c_cond
(paren
op_logical_neg
(paren
id|drive_is_ready
c_func
(paren
id|drive
)paren
)paren
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|100
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|drive_is_ready
c_func
(paren
id|drive
)paren
)paren
r_break
suffix:semicolon
)brace
)brace
macro_line|#endif
multiline_comment|/*&n;&t; * WARNING :: if the drive as not acked good status we may not&n;&t; * move the DATA-TRANSFER T-Bar as BSY != 0. &lt;andre@linux-ide.org&gt;&n;&t; */
r_return
id|args
op_member_access_from_pointer
id|handler
c_func
(paren
id|drive
)paren
suffix:semicolon
macro_line|#endif /* ALTERNATE_STATE_DIAGRAM_MULTI_OUT */
)brace
DECL|variable|pre_task_mulout_intr
id|EXPORT_SYMBOL
c_func
(paren
id|pre_task_mulout_intr
)paren
suffix:semicolon
multiline_comment|/*&n; * FIXME before enabling in 2.4 ... DATA integrity issue upon error.&n; */
multiline_comment|/*&n; * Handler for command write multiple&n; * Called directly from execute_drive_cmd for the first bunch of sectors,&n; * afterwards only by the ISR&n; */
DECL|function|task_mulout_intr
id|ide_startstop_t
id|task_mulout_intr
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|ide_hwif_t
op_star
id|hwif
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
suffix:semicolon
id|u8
id|stat
op_assign
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_STATUS_REG
)paren
suffix:semicolon
r_struct
id|request
op_star
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
r_char
op_star
id|pBuf
op_assign
l_int|NULL
suffix:semicolon
id|ide_startstop_t
id|startstop
op_assign
id|ide_stopped
suffix:semicolon
r_int
r_int
id|msect
op_assign
id|drive-&gt;mult_count
suffix:semicolon
r_int
r_int
id|nsect
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/*&n;&t; * (ks/hs): Handle last IRQ on multi-sector transfer,&n;&t; * occurs after all data was sent in this chunk&n;&t; */
r_if
c_cond
(paren
id|rq-&gt;current_nr_sectors
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|stat
op_amp
(paren
id|ERR_STAT
op_or
id|DRQ_STAT
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|rq-&gt;bio
)paren
(brace
id|rq-&gt;current_nr_sectors
op_add_assign
id|drive-&gt;mult_count
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * NOTE: could rewind beyond beginning :-/&n;&t;&t;&t;&t; */
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;%s: MULTI-WRITE assume all data &quot;
"&bslash;"
l_string|&quot;transfered is bad status=0x%02x&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|stat
)paren
suffix:semicolon
)brace
r_return
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|error
c_func
(paren
id|drive
comma
l_string|&quot;task_mulout_intr&quot;
comma
id|stat
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|rq-&gt;bio
)paren
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|end_request
c_func
(paren
id|drive
comma
l_int|1
comma
l_int|0
)paren
suffix:semicolon
r_return
id|startstop
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * DON&squot;T be lazy code the above and below togather !!!&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|OK_STAT
c_func
(paren
id|stat
comma
id|DATA_READY
comma
id|BAD_R_STAT
)paren
)paren
(brace
r_if
c_cond
(paren
id|stat
op_amp
(paren
id|ERR_STAT
op_or
id|DRQ_STAT
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|rq-&gt;bio
)paren
(brace
id|rq-&gt;current_nr_sectors
op_add_assign
id|drive-&gt;mult_count
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * NOTE: could rewind beyond beginning :-/&n;&t;&t;&t;&t; */
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;%s: MULTI-WRITE assume all data &quot;
"&bslash;"
l_string|&quot;transfered is bad status=0x%02x&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|stat
)paren
suffix:semicolon
)brace
r_return
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|error
c_func
(paren
id|drive
comma
l_string|&quot;task_mulout_intr&quot;
comma
id|stat
)paren
suffix:semicolon
)brace
multiline_comment|/* no data yet, so wait for another interrupt */
r_if
c_cond
(paren
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|handler
op_eq
l_int|NULL
)paren
id|ide_set_handler
c_func
(paren
id|drive
comma
op_amp
id|task_mulout_intr
comma
id|WAIT_WORSTCASE
comma
l_int|NULL
)paren
suffix:semicolon
r_return
id|ide_started
suffix:semicolon
)brace
macro_line|#ifndef ALTERNATE_STATE_DIAGRAM_MULTI_OUT
r_if
c_cond
(paren
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|handler
op_ne
l_int|NULL
)paren
(brace
r_int
r_int
id|lflags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ide_lock
comma
id|lflags
)paren
suffix:semicolon
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|handler
op_assign
l_int|NULL
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|timer
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ide_lock
comma
id|lflags
)paren
suffix:semicolon
)brace
macro_line|#endif /* ALTERNATE_STATE_DIAGRAM_MULTI_OUT */
r_do
(brace
id|nsect
op_assign
id|rq-&gt;current_nr_sectors
suffix:semicolon
r_if
c_cond
(paren
id|nsect
OG
id|msect
)paren
id|nsect
op_assign
id|msect
suffix:semicolon
id|pBuf
op_assign
id|task_map_rq
c_func
(paren
id|rq
comma
op_amp
id|flags
)paren
suffix:semicolon
id|DTF
c_func
(paren
l_string|&quot;Multiwrite: %p, nsect: %d, msect: %d, &quot;
"&bslash;"
l_string|&quot;rq-&gt;current_nr_sectors: %ld&bslash;n&quot;
comma
id|pBuf
comma
id|nsect
comma
id|msect
comma
id|rq-&gt;current_nr_sectors
)paren
suffix:semicolon
id|msect
op_sub_assign
id|nsect
suffix:semicolon
id|taskfile_output_data
c_func
(paren
id|drive
comma
id|pBuf
comma
id|nsect
op_star
id|SECTOR_WORDS
)paren
suffix:semicolon
id|task_unmap_rq
c_func
(paren
id|rq
comma
id|pBuf
comma
op_amp
id|flags
)paren
suffix:semicolon
id|rq-&gt;current_nr_sectors
op_sub_assign
id|nsect
suffix:semicolon
multiline_comment|/*&n;&t;&t; * FIXME :: We really can not legally get a new page/bh&n;&t;&t; * regardless, if this is the end of our segment.&n;&t;&t; * BH walking or segment can only be updated after we&n;&t;&t; * have a good  hwif-&gt;INB(IDE_STATUS_REG); return.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|rq-&gt;current_nr_sectors
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|end_request
c_func
(paren
id|drive
comma
l_int|1
comma
l_int|0
)paren
)paren
r_if
c_cond
(paren
op_logical_neg
id|rq-&gt;bio
)paren
r_return
id|ide_stopped
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|msect
)paren
suffix:semicolon
id|rq-&gt;errors
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|handler
op_eq
l_int|NULL
)paren
id|ide_set_handler
c_func
(paren
id|drive
comma
op_amp
id|task_mulout_intr
comma
id|WAIT_WORSTCASE
comma
l_int|NULL
)paren
suffix:semicolon
r_return
id|ide_started
suffix:semicolon
)brace
DECL|variable|task_mulout_intr
id|EXPORT_SYMBOL
c_func
(paren
id|task_mulout_intr
)paren
suffix:semicolon
multiline_comment|/* Called by internal to feature out type of command being called */
singleline_comment|//ide_pre_handler_t * ide_pre_handler_parser (task_struct_t *taskfile, hob_struct_t *hobfile)
DECL|function|ide_pre_handler_parser
id|ide_pre_handler_t
op_star
id|ide_pre_handler_parser
(paren
r_struct
id|hd_drive_task_hdr
op_star
id|taskfile
comma
r_struct
id|hd_drive_hob_hdr
op_star
id|hobfile
)paren
(brace
r_switch
c_cond
(paren
id|taskfile-&gt;command
)paren
(brace
multiline_comment|/* IDE_DRIVE_TASK_RAW_WRITE */
r_case
id|CFA_WRITE_MULTI_WO_ERASE
suffix:colon
singleline_comment|//&t;case WIN_WRITE_LONG:
singleline_comment|//&t;case WIN_WRITE_LONG_ONCE:
r_case
id|WIN_MULTWRITE
suffix:colon
r_case
id|WIN_MULTWRITE_EXT
suffix:colon
r_return
op_amp
id|pre_task_mulout_intr
suffix:semicolon
multiline_comment|/* IDE_DRIVE_TASK_OUT */
r_case
id|WIN_WRITE
suffix:colon
singleline_comment|//&t;case WIN_WRITE_ONCE:
r_case
id|WIN_WRITE_EXT
suffix:colon
r_case
id|WIN_WRITE_VERIFY
suffix:colon
r_case
id|WIN_WRITE_BUFFER
suffix:colon
r_case
id|CFA_WRITE_SECT_WO_ERASE
suffix:colon
r_case
id|WIN_DOWNLOAD_MICROCODE
suffix:colon
r_return
op_amp
id|pre_task_out_intr
suffix:semicolon
multiline_comment|/* IDE_DRIVE_TASK_OUT */
r_case
id|WIN_SMART
suffix:colon
r_if
c_cond
(paren
id|taskfile-&gt;feature
op_eq
id|SMART_WRITE_LOG_SECTOR
)paren
r_return
op_amp
id|pre_task_out_intr
suffix:semicolon
r_case
id|WIN_WRITEDMA
suffix:colon
singleline_comment|//&t;case WIN_WRITEDMA_ONCE:
r_case
id|WIN_WRITEDMA_QUEUED
suffix:colon
r_case
id|WIN_WRITEDMA_EXT
suffix:colon
r_case
id|WIN_WRITEDMA_QUEUED_EXT
suffix:colon
multiline_comment|/* IDE_DRIVE_TASK_OUT */
r_default
suffix:colon
r_break
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|variable|ide_pre_handler_parser
id|EXPORT_SYMBOL
c_func
(paren
id|ide_pre_handler_parser
)paren
suffix:semicolon
multiline_comment|/* Called by internal to feature out type of command being called */
singleline_comment|//ide_handler_t * ide_handler_parser (task_struct_t *taskfile, hob_struct_t *hobfile)
DECL|function|ide_handler_parser
id|ide_handler_t
op_star
id|ide_handler_parser
(paren
r_struct
id|hd_drive_task_hdr
op_star
id|taskfile
comma
r_struct
id|hd_drive_hob_hdr
op_star
id|hobfile
)paren
(brace
r_switch
c_cond
(paren
id|taskfile-&gt;command
)paren
(brace
r_case
id|WIN_IDENTIFY
suffix:colon
r_case
id|WIN_PIDENTIFY
suffix:colon
r_case
id|CFA_TRANSLATE_SECTOR
suffix:colon
r_case
id|WIN_READ_BUFFER
suffix:colon
r_case
id|WIN_READ
suffix:colon
singleline_comment|//&t;case WIN_READ_ONCE:
r_case
id|WIN_READ_EXT
suffix:colon
r_return
op_amp
id|task_in_intr
suffix:semicolon
r_case
id|WIN_SECURITY_DISABLE
suffix:colon
r_case
id|WIN_SECURITY_ERASE_UNIT
suffix:colon
r_case
id|WIN_SECURITY_SET_PASS
suffix:colon
r_case
id|WIN_SECURITY_UNLOCK
suffix:colon
r_case
id|WIN_DOWNLOAD_MICROCODE
suffix:colon
r_case
id|CFA_WRITE_SECT_WO_ERASE
suffix:colon
r_case
id|WIN_WRITE_BUFFER
suffix:colon
r_case
id|WIN_WRITE_VERIFY
suffix:colon
r_case
id|WIN_WRITE
suffix:colon
singleline_comment|//&t;case WIN_WRITE_ONCE:&t;
r_case
id|WIN_WRITE_EXT
suffix:colon
r_return
op_amp
id|task_out_intr
suffix:semicolon
singleline_comment|//&t;case WIN_READ_LONG:
singleline_comment|//&t;case WIN_READ_LONG_ONCE:
r_case
id|WIN_MULTREAD
suffix:colon
r_case
id|WIN_MULTREAD_EXT
suffix:colon
r_return
op_amp
id|task_mulin_intr
suffix:semicolon
singleline_comment|//&t;case WIN_WRITE_LONG:
singleline_comment|//&t;case WIN_WRITE_LONG_ONCE:
r_case
id|CFA_WRITE_MULTI_WO_ERASE
suffix:colon
r_case
id|WIN_MULTWRITE
suffix:colon
r_case
id|WIN_MULTWRITE_EXT
suffix:colon
r_return
op_amp
id|task_mulout_intr
suffix:semicolon
r_case
id|WIN_SMART
suffix:colon
r_switch
c_cond
(paren
id|taskfile-&gt;feature
)paren
(brace
r_case
id|SMART_READ_VALUES
suffix:colon
r_case
id|SMART_READ_THRESHOLDS
suffix:colon
r_case
id|SMART_READ_LOG_SECTOR
suffix:colon
r_return
op_amp
id|task_in_intr
suffix:semicolon
r_case
id|SMART_WRITE_LOG_SECTOR
suffix:colon
r_return
op_amp
id|task_out_intr
suffix:semicolon
r_default
suffix:colon
r_return
op_amp
id|task_no_data_intr
suffix:semicolon
)brace
r_case
id|CFA_REQ_EXT_ERROR_CODE
suffix:colon
r_case
id|CFA_ERASE_SECTORS
suffix:colon
r_case
id|WIN_VERIFY
suffix:colon
singleline_comment|//&t;case WIN_VERIFY_ONCE:
r_case
id|WIN_VERIFY_EXT
suffix:colon
r_case
id|WIN_SEEK
suffix:colon
r_return
op_amp
id|task_no_data_intr
suffix:semicolon
r_case
id|WIN_SPECIFY
suffix:colon
r_return
op_amp
id|set_geometry_intr
suffix:semicolon
r_case
id|WIN_RECAL
suffix:colon
singleline_comment|//&t;case WIN_RESTORE:
r_return
op_amp
id|recal_intr
suffix:semicolon
r_case
id|WIN_NOP
suffix:colon
r_case
id|WIN_DIAGNOSE
suffix:colon
r_case
id|WIN_FLUSH_CACHE
suffix:colon
r_case
id|WIN_FLUSH_CACHE_EXT
suffix:colon
r_case
id|WIN_STANDBYNOW1
suffix:colon
r_case
id|WIN_STANDBYNOW2
suffix:colon
r_case
id|WIN_SLEEPNOW1
suffix:colon
r_case
id|WIN_SLEEPNOW2
suffix:colon
r_case
id|WIN_SETIDLE1
suffix:colon
r_case
id|WIN_CHECKPOWERMODE1
suffix:colon
r_case
id|WIN_CHECKPOWERMODE2
suffix:colon
r_case
id|WIN_GETMEDIASTATUS
suffix:colon
r_case
id|WIN_MEDIAEJECT
suffix:colon
r_return
op_amp
id|task_no_data_intr
suffix:semicolon
r_case
id|WIN_SETMULT
suffix:colon
r_return
op_amp
id|set_multmode_intr
suffix:semicolon
r_case
id|WIN_READ_NATIVE_MAX
suffix:colon
r_case
id|WIN_SET_MAX
suffix:colon
r_case
id|WIN_READ_NATIVE_MAX_EXT
suffix:colon
r_case
id|WIN_SET_MAX_EXT
suffix:colon
r_case
id|WIN_SECURITY_ERASE_PREPARE
suffix:colon
r_case
id|WIN_SECURITY_FREEZE_LOCK
suffix:colon
r_case
id|WIN_DOORLOCK
suffix:colon
r_case
id|WIN_DOORUNLOCK
suffix:colon
r_case
id|WIN_SETFEATURES
suffix:colon
r_return
op_amp
id|task_no_data_intr
suffix:semicolon
r_case
id|DISABLE_SEAGATE
suffix:colon
r_case
id|EXABYTE_ENABLE_NEST
suffix:colon
r_return
op_amp
id|task_no_data_intr
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_IDEDMA
r_case
id|WIN_READDMA
suffix:colon
singleline_comment|//&t;case WIN_READDMA_ONCE:
r_case
id|WIN_IDENTIFY_DMA
suffix:colon
r_case
id|WIN_READDMA_QUEUED
suffix:colon
r_case
id|WIN_READDMA_EXT
suffix:colon
r_case
id|WIN_READDMA_QUEUED_EXT
suffix:colon
r_case
id|WIN_WRITEDMA
suffix:colon
singleline_comment|//&t;case WIN_WRITEDMA_ONCE:
r_case
id|WIN_WRITEDMA_QUEUED
suffix:colon
r_case
id|WIN_WRITEDMA_EXT
suffix:colon
r_case
id|WIN_WRITEDMA_QUEUED_EXT
suffix:colon
macro_line|#endif
r_case
id|WIN_FORMAT
suffix:colon
r_case
id|WIN_INIT
suffix:colon
r_case
id|WIN_DEVICE_RESET
suffix:colon
r_case
id|WIN_QUEUED_SERVICE
suffix:colon
r_case
id|WIN_PACKETCMD
suffix:colon
r_default
suffix:colon
r_return
l_int|NULL
suffix:semicolon
)brace
)brace
DECL|variable|ide_handler_parser
id|EXPORT_SYMBOL
c_func
(paren
id|ide_handler_parser
)paren
suffix:semicolon
DECL|function|ide_post_handler_parser
id|ide_post_handler_t
op_star
id|ide_post_handler_parser
(paren
r_struct
id|hd_drive_task_hdr
op_star
id|taskfile
comma
r_struct
id|hd_drive_hob_hdr
op_star
id|hobfile
)paren
(brace
r_switch
c_cond
(paren
id|taskfile-&gt;command
)paren
(brace
r_case
id|WIN_SPECIFY
suffix:colon
multiline_comment|/* set_geometry_intr */
r_case
id|WIN_RESTORE
suffix:colon
multiline_comment|/* recal_intr */
r_case
id|WIN_SETMULT
suffix:colon
multiline_comment|/* set_multmode_intr */
r_default
suffix:colon
r_return
l_int|NULL
suffix:semicolon
)brace
)brace
DECL|variable|ide_post_handler_parser
id|EXPORT_SYMBOL
c_func
(paren
id|ide_post_handler_parser
)paren
suffix:semicolon
multiline_comment|/* Called by ioctl to feature out type of command being called */
DECL|function|ide_cmd_type_parser
r_int
id|ide_cmd_type_parser
(paren
id|ide_task_t
op_star
id|args
)paren
(brace
id|task_struct_t
op_star
id|taskfile
op_assign
(paren
id|task_struct_t
op_star
)paren
id|args-&gt;tfRegister
suffix:semicolon
id|hob_struct_t
op_star
id|hobfile
op_assign
(paren
id|hob_struct_t
op_star
)paren
id|args-&gt;hobRegister
suffix:semicolon
id|args-&gt;prehandler
op_assign
id|ide_pre_handler_parser
c_func
(paren
id|taskfile
comma
id|hobfile
)paren
suffix:semicolon
id|args-&gt;handler
op_assign
id|ide_handler_parser
c_func
(paren
id|taskfile
comma
id|hobfile
)paren
suffix:semicolon
id|args-&gt;posthandler
op_assign
id|ide_post_handler_parser
c_func
(paren
id|taskfile
comma
id|hobfile
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|args-&gt;tfRegister
(braket
id|IDE_COMMAND_OFFSET
)braket
)paren
(brace
r_case
id|WIN_IDENTIFY
suffix:colon
r_case
id|WIN_PIDENTIFY
suffix:colon
r_return
id|IDE_DRIVE_TASK_IN
suffix:semicolon
r_case
id|CFA_TRANSLATE_SECTOR
suffix:colon
r_case
id|WIN_READ
suffix:colon
singleline_comment|//&t;case WIN_READ_ONCE:
r_case
id|WIN_READ_EXT
suffix:colon
r_case
id|WIN_READ_BUFFER
suffix:colon
r_return
id|IDE_DRIVE_TASK_IN
suffix:semicolon
r_case
id|WIN_WRITE
suffix:colon
singleline_comment|//&t;case WIN_WRITE_ONCE:
r_case
id|WIN_WRITE_EXT
suffix:colon
r_case
id|WIN_WRITE_VERIFY
suffix:colon
r_case
id|WIN_WRITE_BUFFER
suffix:colon
r_case
id|CFA_WRITE_SECT_WO_ERASE
suffix:colon
r_case
id|WIN_DOWNLOAD_MICROCODE
suffix:colon
r_return
id|IDE_DRIVE_TASK_RAW_WRITE
suffix:semicolon
singleline_comment|//&t;case WIN_READ_LONG:
singleline_comment|//&t;case WIN_READ_LONG_ONCE:
r_case
id|WIN_MULTREAD
suffix:colon
r_case
id|WIN_MULTREAD_EXT
suffix:colon
r_return
id|IDE_DRIVE_TASK_IN
suffix:semicolon
singleline_comment|//&t;case WIN_WRITE_LONG:
singleline_comment|//&t;case WIN_WRITE_LONG_ONCE:
r_case
id|CFA_WRITE_MULTI_WO_ERASE
suffix:colon
r_case
id|WIN_MULTWRITE
suffix:colon
r_case
id|WIN_MULTWRITE_EXT
suffix:colon
r_return
id|IDE_DRIVE_TASK_RAW_WRITE
suffix:semicolon
r_case
id|WIN_SECURITY_DISABLE
suffix:colon
r_case
id|WIN_SECURITY_ERASE_UNIT
suffix:colon
r_case
id|WIN_SECURITY_SET_PASS
suffix:colon
r_case
id|WIN_SECURITY_UNLOCK
suffix:colon
r_return
id|IDE_DRIVE_TASK_OUT
suffix:semicolon
r_case
id|WIN_SMART
suffix:colon
id|args-&gt;tfRegister
(braket
id|IDE_LCYL_OFFSET
)braket
op_assign
id|SMART_LCYL_PASS
suffix:semicolon
id|args-&gt;tfRegister
(braket
id|IDE_HCYL_OFFSET
)braket
op_assign
id|SMART_HCYL_PASS
suffix:semicolon
r_switch
c_cond
(paren
id|args-&gt;tfRegister
(braket
id|IDE_FEATURE_OFFSET
)braket
)paren
(brace
r_case
id|SMART_READ_VALUES
suffix:colon
r_case
id|SMART_READ_THRESHOLDS
suffix:colon
r_case
id|SMART_READ_LOG_SECTOR
suffix:colon
r_return
id|IDE_DRIVE_TASK_IN
suffix:semicolon
r_case
id|SMART_WRITE_LOG_SECTOR
suffix:colon
r_return
id|IDE_DRIVE_TASK_OUT
suffix:semicolon
r_default
suffix:colon
r_return
id|IDE_DRIVE_TASK_NO_DATA
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_BLK_DEV_IDEDMA
r_case
id|WIN_READDMA
suffix:colon
singleline_comment|//&t;case WIN_READDMA_ONCE:
r_case
id|WIN_IDENTIFY_DMA
suffix:colon
r_case
id|WIN_READDMA_QUEUED
suffix:colon
r_case
id|WIN_READDMA_EXT
suffix:colon
r_case
id|WIN_READDMA_QUEUED_EXT
suffix:colon
r_return
id|IDE_DRIVE_TASK_IN
suffix:semicolon
r_case
id|WIN_WRITEDMA
suffix:colon
singleline_comment|//&t;case WIN_WRITEDMA_ONCE:
r_case
id|WIN_WRITEDMA_QUEUED
suffix:colon
r_case
id|WIN_WRITEDMA_EXT
suffix:colon
r_case
id|WIN_WRITEDMA_QUEUED_EXT
suffix:colon
r_return
id|IDE_DRIVE_TASK_RAW_WRITE
suffix:semicolon
macro_line|#endif
r_case
id|WIN_SETFEATURES
suffix:colon
r_switch
c_cond
(paren
id|args-&gt;tfRegister
(braket
id|IDE_FEATURE_OFFSET
)braket
)paren
(brace
r_case
id|SETFEATURES_EN_8BIT
suffix:colon
r_case
id|SETFEATURES_EN_WCACHE
suffix:colon
r_return
id|IDE_DRIVE_TASK_NO_DATA
suffix:semicolon
r_case
id|SETFEATURES_XFER
suffix:colon
r_return
id|IDE_DRIVE_TASK_SET_XFER
suffix:semicolon
r_case
id|SETFEATURES_DIS_DEFECT
suffix:colon
r_case
id|SETFEATURES_EN_APM
suffix:colon
r_case
id|SETFEATURES_DIS_MSN
suffix:colon
r_case
id|SETFEATURES_DIS_RETRY
suffix:colon
r_case
id|SETFEATURES_EN_AAM
suffix:colon
r_case
id|SETFEATURES_RW_LONG
suffix:colon
r_case
id|SETFEATURES_SET_CACHE
suffix:colon
r_case
id|SETFEATURES_DIS_RLA
suffix:colon
r_case
id|SETFEATURES_EN_RI
suffix:colon
r_case
id|SETFEATURES_EN_SI
suffix:colon
r_case
id|SETFEATURES_DIS_RPOD
suffix:colon
r_case
id|SETFEATURES_DIS_WCACHE
suffix:colon
r_case
id|SETFEATURES_EN_DEFECT
suffix:colon
r_case
id|SETFEATURES_DIS_APM
suffix:colon
r_case
id|SETFEATURES_EN_ECC
suffix:colon
r_case
id|SETFEATURES_EN_MSN
suffix:colon
r_case
id|SETFEATURES_EN_RETRY
suffix:colon
r_case
id|SETFEATURES_EN_RLA
suffix:colon
r_case
id|SETFEATURES_PREFETCH
suffix:colon
r_case
id|SETFEATURES_4B_RW_LONG
suffix:colon
r_case
id|SETFEATURES_DIS_AAM
suffix:colon
r_case
id|SETFEATURES_EN_RPOD
suffix:colon
r_case
id|SETFEATURES_DIS_RI
suffix:colon
r_case
id|SETFEATURES_DIS_SI
suffix:colon
r_default
suffix:colon
r_return
id|IDE_DRIVE_TASK_NO_DATA
suffix:semicolon
)brace
r_case
id|WIN_NOP
suffix:colon
r_case
id|CFA_REQ_EXT_ERROR_CODE
suffix:colon
r_case
id|CFA_ERASE_SECTORS
suffix:colon
r_case
id|WIN_VERIFY
suffix:colon
singleline_comment|//&t;case WIN_VERIFY_ONCE:
r_case
id|WIN_VERIFY_EXT
suffix:colon
r_case
id|WIN_SEEK
suffix:colon
r_case
id|WIN_SPECIFY
suffix:colon
r_case
id|WIN_RESTORE
suffix:colon
r_case
id|WIN_DIAGNOSE
suffix:colon
r_case
id|WIN_FLUSH_CACHE
suffix:colon
r_case
id|WIN_FLUSH_CACHE_EXT
suffix:colon
r_case
id|WIN_STANDBYNOW1
suffix:colon
r_case
id|WIN_STANDBYNOW2
suffix:colon
r_case
id|WIN_SLEEPNOW1
suffix:colon
r_case
id|WIN_SLEEPNOW2
suffix:colon
r_case
id|WIN_SETIDLE1
suffix:colon
r_case
id|DISABLE_SEAGATE
suffix:colon
r_case
id|WIN_CHECKPOWERMODE1
suffix:colon
r_case
id|WIN_CHECKPOWERMODE2
suffix:colon
r_case
id|WIN_GETMEDIASTATUS
suffix:colon
r_case
id|WIN_MEDIAEJECT
suffix:colon
r_case
id|WIN_SETMULT
suffix:colon
r_case
id|WIN_READ_NATIVE_MAX
suffix:colon
r_case
id|WIN_SET_MAX
suffix:colon
r_case
id|WIN_READ_NATIVE_MAX_EXT
suffix:colon
r_case
id|WIN_SET_MAX_EXT
suffix:colon
r_case
id|WIN_SECURITY_ERASE_PREPARE
suffix:colon
r_case
id|WIN_SECURITY_FREEZE_LOCK
suffix:colon
r_case
id|EXABYTE_ENABLE_NEST
suffix:colon
r_case
id|WIN_DOORLOCK
suffix:colon
r_case
id|WIN_DOORUNLOCK
suffix:colon
r_return
id|IDE_DRIVE_TASK_NO_DATA
suffix:semicolon
r_case
id|WIN_FORMAT
suffix:colon
r_case
id|WIN_INIT
suffix:colon
r_case
id|WIN_DEVICE_RESET
suffix:colon
r_case
id|WIN_QUEUED_SERVICE
suffix:colon
r_case
id|WIN_PACKETCMD
suffix:colon
r_default
suffix:colon
r_return
id|IDE_DRIVE_TASK_INVALID
suffix:semicolon
)brace
)brace
DECL|variable|ide_cmd_type_parser
id|EXPORT_SYMBOL
c_func
(paren
id|ide_cmd_type_parser
)paren
suffix:semicolon
multiline_comment|/*&n; * This function is intended to be used prior to invoking ide_do_drive_cmd().&n; */
DECL|function|ide_init_drive_taskfile
r_void
id|ide_init_drive_taskfile
(paren
r_struct
id|request
op_star
id|rq
)paren
(brace
id|memset
c_func
(paren
id|rq
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|rq
)paren
)paren
suffix:semicolon
id|rq-&gt;flags
op_assign
id|REQ_DRIVE_TASKFILE
suffix:semicolon
)brace
DECL|variable|ide_init_drive_taskfile
id|EXPORT_SYMBOL
c_func
(paren
id|ide_init_drive_taskfile
)paren
suffix:semicolon
macro_line|#if 1
DECL|function|ide_diag_taskfile
r_int
id|ide_diag_taskfile
(paren
id|ide_drive_t
op_star
id|drive
comma
id|ide_task_t
op_star
id|args
comma
r_int
r_int
id|data_size
comma
id|u8
op_star
id|buf
)paren
(brace
r_struct
id|request
id|rq
suffix:semicolon
id|ide_init_drive_taskfile
c_func
(paren
op_amp
id|rq
)paren
suffix:semicolon
id|rq.flags
op_assign
id|REQ_DRIVE_TASKFILE
suffix:semicolon
id|rq.buffer
op_assign
id|buf
suffix:semicolon
multiline_comment|/*&n;&t; * (ks) We transfer currently only whole sectors.&n;&t; * This is suffient for now.  But, it would be great,&n;&t; * if we would find a solution to transfer any size.&n;&t; * To support special commands like READ LONG.&n;&t; */
r_if
c_cond
(paren
id|args-&gt;command_type
op_ne
id|IDE_DRIVE_TASK_NO_DATA
)paren
(brace
r_if
c_cond
(paren
id|data_size
op_eq
l_int|0
)paren
id|rq.current_nr_sectors
op_assign
id|rq.nr_sectors
op_assign
(paren
id|args-&gt;hobRegister
(braket
id|IDE_NSECTOR_OFFSET_HOB
)braket
op_lshift
l_int|8
)paren
op_or
id|args-&gt;tfRegister
(braket
id|IDE_NSECTOR_OFFSET
)braket
suffix:semicolon
multiline_comment|/*&t;rq.hard_cur_sectors&t;*/
r_else
id|rq.current_nr_sectors
op_assign
id|rq.nr_sectors
op_assign
id|data_size
op_div
id|SECTOR_SIZE
suffix:semicolon
multiline_comment|/*&t;rq.hard_cur_sectors&t;*/
)brace
r_if
c_cond
(paren
id|args-&gt;tf_out_flags.all
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * clean up kernel settings for driver sanity, regardless.&n;&t;&t; * except for discrete diag services.&n;&t;&t; */
id|args-&gt;posthandler
op_assign
id|ide_post_handler_parser
c_func
(paren
(paren
r_struct
id|hd_drive_task_hdr
op_star
)paren
id|args-&gt;tfRegister
comma
(paren
r_struct
id|hd_drive_hob_hdr
op_star
)paren
id|args-&gt;hobRegister
)paren
suffix:semicolon
)brace
id|rq.special
op_assign
id|args
suffix:semicolon
r_return
id|ide_do_drive_cmd
c_func
(paren
id|drive
comma
op_amp
id|rq
comma
id|ide_wait
)paren
suffix:semicolon
)brace
macro_line|#else
DECL|function|ide_diag_taskfile
r_int
id|ide_diag_taskfile
(paren
id|ide_drive_t
op_star
id|drive
comma
id|ide_task_t
op_star
id|args
comma
r_int
r_int
id|data_size
comma
id|u8
op_star
id|buf
)paren
(brace
r_struct
id|request
op_star
id|rq
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|ide_hwgroup_t
op_star
id|hwgroup
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
suffix:semicolon
r_int
r_int
id|major
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|major
suffix:semicolon
r_struct
id|list_head
op_star
id|queue_head
op_assign
op_amp
id|drive-&gt;queue.queue_head
suffix:semicolon
id|DECLARE_COMPLETION
c_func
(paren
id|wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|chipset
op_eq
id|ide_pdc4030
op_logical_and
id|buf
op_ne
l_int|NULL
)paren
r_return
op_minus
id|ENOSYS
suffix:semicolon
multiline_comment|/* special drive cmds not supported */
id|memset
c_func
(paren
id|rq
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|rq
)paren
)paren
suffix:semicolon
id|rq-&gt;flags
op_assign
id|REQ_DRIVE_TASKFILE
suffix:semicolon
id|rq-&gt;buffer
op_assign
id|buf
suffix:semicolon
multiline_comment|/*&n;&t; * (ks) We transfer currently only whole sectors.&n;&t; * This is suffient for now.  But, it would be great,&n;&t; * if we would find a solution to transfer any size.&n;&t; * To support special commands like READ LONG.&n;&t; */
r_if
c_cond
(paren
id|args-&gt;command_type
op_ne
id|IDE_DRIVE_TASK_NO_DATA
)paren
(brace
r_if
c_cond
(paren
id|data_size
op_eq
l_int|0
)paren
(brace
id|ata_nsector_t
id|nsector
suffix:semicolon
id|nsector.b.low
op_assign
id|args-&gt;hobRegister
(braket
id|IDE_NSECTOR_OFFSET_HOB
)braket
suffix:semicolon
id|nsector.b.high
op_assign
id|args-&gt;tfRegister
(braket
id|IDE_NSECTOR_OFFSET
)braket
suffix:semicolon
id|rq.nr_sectors
op_assign
id|nsector.all
suffix:semicolon
)brace
r_else
(brace
id|rq.nr_sectors
op_assign
id|data_size
op_div
id|SECTOR_SIZE
suffix:semicolon
)brace
id|rq.current_nr_sectors
op_assign
id|rq.nr_sectors
suffix:semicolon
singleline_comment|//&t;rq.hard_cur_sectors = rq.nr_sectors;
)brace
r_if
c_cond
(paren
id|args-&gt;tf_out_flags.all
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * clean up kernel settings for driver sanity, regardless.&n;&t;&t; * except for discrete diag services.&n;&t;&t; */
id|args-&gt;posthandler
op_assign
id|ide_post_handler_parser
c_func
(paren
(paren
r_struct
id|hd_drive_task_hdr
op_star
)paren
id|args-&gt;tfRegister
comma
(paren
r_struct
id|hd_drive_hob_hdr
op_star
)paren
id|args-&gt;hobRegister
)paren
suffix:semicolon
)brace
id|rq-&gt;special
op_assign
id|args
suffix:semicolon
id|rq-&gt;errors
op_assign
l_int|0
suffix:semicolon
id|rq-&gt;rq_status
op_assign
id|RQ_ACTIVE
suffix:semicolon
id|rq-&gt;rq_dev
op_assign
id|MKDEV
c_func
(paren
id|major
comma
(paren
id|drive-&gt;select.b.unit
)paren
op_lshift
id|PARTN_BITS
)paren
suffix:semicolon
id|rq-&gt;waiting
op_assign
op_amp
id|wait
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ide_lock
comma
id|flags
)paren
suffix:semicolon
id|queue_head
op_assign
id|queue_head-&gt;prev
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|rq-&gt;queue
comma
id|queue_head
)paren
suffix:semicolon
id|ide_do_request
c_func
(paren
id|hwgroup
comma
l_int|0
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ide_lock
comma
id|flags
)paren
suffix:semicolon
id|wait_for_completion
c_func
(paren
op_amp
id|wait
)paren
suffix:semicolon
multiline_comment|/* wait for it to be serviced */
r_return
id|rq-&gt;errors
ques
c_cond
op_minus
id|EIO
suffix:colon
l_int|0
suffix:semicolon
multiline_comment|/* return -EIO if errors */
)brace
macro_line|#endif
DECL|variable|ide_diag_taskfile
id|EXPORT_SYMBOL
c_func
(paren
id|ide_diag_taskfile
)paren
suffix:semicolon
DECL|function|ide_raw_taskfile
r_int
id|ide_raw_taskfile
(paren
id|ide_drive_t
op_star
id|drive
comma
id|ide_task_t
op_star
id|args
comma
id|u8
op_star
id|buf
)paren
(brace
r_return
id|ide_diag_taskfile
c_func
(paren
id|drive
comma
id|args
comma
l_int|0
comma
id|buf
)paren
suffix:semicolon
)brace
DECL|variable|ide_raw_taskfile
id|EXPORT_SYMBOL
c_func
(paren
id|ide_raw_taskfile
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_IDE_TASK_IOCTL_DEBUG
DECL|function|ide_ioctl_verbose
r_char
op_star
id|ide_ioctl_verbose
(paren
r_int
r_int
id|cmd
)paren
(brace
r_return
l_string|&quot;unknown&quot;
suffix:semicolon
)brace
DECL|function|ide_task_cmd_verbose
r_char
op_star
id|ide_task_cmd_verbose
(paren
id|u8
id|task
)paren
(brace
r_return
l_string|&quot;unknown&quot;
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_IDE_TASK_IOCTL_DEBUG */
DECL|macro|MAX_DMA
mdefine_line|#define MAX_DMA&t;&t;(256*SECTOR_WORDS)
id|ide_startstop_t
id|flagged_taskfile
c_func
(paren
id|ide_drive_t
op_star
comma
id|ide_task_t
op_star
)paren
suffix:semicolon
id|ide_startstop_t
id|flagged_task_no_data_intr
c_func
(paren
id|ide_drive_t
op_star
)paren
suffix:semicolon
id|ide_startstop_t
id|flagged_task_in_intr
c_func
(paren
id|ide_drive_t
op_star
)paren
suffix:semicolon
id|ide_startstop_t
id|flagged_task_mulin_intr
c_func
(paren
id|ide_drive_t
op_star
)paren
suffix:semicolon
id|ide_startstop_t
id|flagged_pre_task_out_intr
c_func
(paren
id|ide_drive_t
op_star
comma
r_struct
id|request
op_star
)paren
suffix:semicolon
id|ide_startstop_t
id|flagged_task_out_intr
c_func
(paren
id|ide_drive_t
op_star
)paren
suffix:semicolon
id|ide_startstop_t
id|flagged_pre_task_mulout_intr
c_func
(paren
id|ide_drive_t
op_star
comma
r_struct
id|request
op_star
)paren
suffix:semicolon
id|ide_startstop_t
id|flagged_task_mulout_intr
c_func
(paren
id|ide_drive_t
op_star
)paren
suffix:semicolon
DECL|function|ide_taskfile_ioctl
r_int
id|ide_taskfile_ioctl
(paren
id|ide_drive_t
op_star
id|drive
comma
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
id|ide_task_request_t
op_star
id|req_task
suffix:semicolon
id|ide_task_t
id|args
suffix:semicolon
id|u8
op_star
id|outbuf
op_assign
l_int|NULL
suffix:semicolon
id|u8
op_star
id|inbuf
op_assign
l_int|NULL
suffix:semicolon
id|task_ioreg_t
op_star
id|argsptr
op_assign
id|args.tfRegister
suffix:semicolon
id|task_ioreg_t
op_star
id|hobsptr
op_assign
id|args.hobRegister
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
r_int
id|tasksize
op_assign
r_sizeof
(paren
r_struct
id|ide_task_request_s
)paren
suffix:semicolon
r_int
id|taskin
op_assign
l_int|0
suffix:semicolon
r_int
id|taskout
op_assign
l_int|0
suffix:semicolon
id|u8
id|io_32bit
op_assign
id|drive-&gt;io_32bit
suffix:semicolon
singleline_comment|//&t;printk(&quot;IDE Taskfile ...&bslash;n&quot;);
id|req_task
op_assign
id|kmalloc
c_func
(paren
id|tasksize
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|req_task
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|memset
c_func
(paren
id|req_task
comma
l_int|0
comma
id|tasksize
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|req_task
comma
(paren
r_void
op_star
)paren
id|arg
comma
id|tasksize
)paren
)paren
(brace
id|kfree
c_func
(paren
id|req_task
)paren
suffix:semicolon
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
id|taskout
op_assign
(paren
r_int
)paren
id|req_task-&gt;out_size
suffix:semicolon
id|taskin
op_assign
(paren
r_int
)paren
id|req_task-&gt;in_size
suffix:semicolon
r_if
c_cond
(paren
id|taskout
)paren
(brace
r_int
id|outtotal
op_assign
id|tasksize
suffix:semicolon
id|outbuf
op_assign
id|kmalloc
c_func
(paren
id|taskout
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|outbuf
op_eq
l_int|NULL
)paren
(brace
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
id|memset
c_func
(paren
id|outbuf
comma
l_int|0
comma
id|taskout
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|outbuf
comma
(paren
r_void
op_star
)paren
id|arg
op_plus
id|outtotal
comma
id|taskout
)paren
)paren
(brace
id|err
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|taskin
)paren
(brace
r_int
id|intotal
op_assign
id|tasksize
op_plus
id|taskout
suffix:semicolon
id|inbuf
op_assign
id|kmalloc
c_func
(paren
id|taskin
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inbuf
op_eq
l_int|NULL
)paren
(brace
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
id|memset
c_func
(paren
id|inbuf
comma
l_int|0
comma
id|taskin
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|inbuf
comma
(paren
r_void
op_star
)paren
id|arg
op_plus
id|intotal
comma
id|taskin
)paren
)paren
(brace
id|err
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
)brace
id|memset
c_func
(paren
op_amp
id|args
comma
l_int|0
comma
r_sizeof
(paren
id|ide_task_t
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|argsptr
comma
id|req_task-&gt;io_ports
comma
id|HDIO_DRIVE_TASK_HDR_SIZE
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|hobsptr
comma
id|req_task-&gt;hob_ports
comma
id|HDIO_DRIVE_HOB_HDR_SIZE
)paren
suffix:semicolon
id|args.tf_in_flags
op_assign
id|req_task-&gt;in_flags
suffix:semicolon
id|args.tf_out_flags
op_assign
id|req_task-&gt;out_flags
suffix:semicolon
id|args.data_phase
op_assign
id|req_task-&gt;data_phase
suffix:semicolon
id|args.command_type
op_assign
id|req_task-&gt;req_cmd
suffix:semicolon
macro_line|#ifdef CONFIG_IDE_TASK_IOCTL_DEBUG
id|DTF
c_func
(paren
l_string|&quot;%s: ide_ioctl_cmd %s:  ide_task_cmd %s&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|ide_ioctl_verbose
c_func
(paren
id|cmd
)paren
comma
id|ide_task_cmd_verbose
c_func
(paren
id|args.tfRegister
(braket
id|IDE_COMMAND_OFFSET
)braket
)paren
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_IDE_TASK_IOCTL_DEBUG */
id|drive-&gt;io_32bit
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|req_task-&gt;data_phase
)paren
(brace
r_case
id|TASKFILE_OUT_DMAQ
suffix:colon
r_case
id|TASKFILE_OUT_DMA
suffix:colon
id|err
op_assign
id|ide_diag_taskfile
c_func
(paren
id|drive
comma
op_amp
id|args
comma
id|taskout
comma
id|outbuf
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TASKFILE_IN_DMAQ
suffix:colon
r_case
id|TASKFILE_IN_DMA
suffix:colon
id|err
op_assign
id|ide_diag_taskfile
c_func
(paren
id|drive
comma
op_amp
id|args
comma
id|taskin
comma
id|inbuf
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TASKFILE_IN_OUT
suffix:colon
macro_line|#if 0
id|args.prehandler
op_assign
op_amp
id|pre_task_out_intr
suffix:semicolon
id|args.handler
op_assign
op_amp
id|task_out_intr
suffix:semicolon
id|args.posthandler
op_assign
l_int|NULL
suffix:semicolon
id|err
op_assign
id|ide_diag_taskfile
c_func
(paren
id|drive
comma
op_amp
id|args
comma
id|taskout
comma
id|outbuf
)paren
suffix:semicolon
id|args.prehandler
op_assign
l_int|NULL
suffix:semicolon
id|args.handler
op_assign
op_amp
id|task_in_intr
suffix:semicolon
id|args.posthandler
op_assign
l_int|NULL
suffix:semicolon
id|err
op_assign
id|ide_diag_taskfile
c_func
(paren
id|drive
comma
op_amp
id|args
comma
id|taskin
comma
id|inbuf
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#else
id|err
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
m_abort
suffix:semicolon
macro_line|#endif
r_case
id|TASKFILE_MULTI_OUT
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|drive-&gt;mult_count
)paren
(brace
multiline_comment|/* (hs): give up if multcount is not set */
id|printk
c_func
(paren
l_string|&quot;%s: %s Multimode Write &quot;
"&bslash;"
l_string|&quot;multcount is not set&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|__FUNCTION__
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EPERM
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
r_if
c_cond
(paren
id|args.tf_out_flags.all
op_ne
l_int|0
)paren
(brace
id|args.prehandler
op_assign
op_amp
id|flagged_pre_task_mulout_intr
suffix:semicolon
id|args.handler
op_assign
op_amp
id|flagged_task_mulout_intr
suffix:semicolon
)brace
r_else
(brace
id|args.prehandler
op_assign
op_amp
id|pre_task_mulout_intr
suffix:semicolon
id|args.handler
op_assign
op_amp
id|task_mulout_intr
suffix:semicolon
)brace
id|err
op_assign
id|ide_diag_taskfile
c_func
(paren
id|drive
comma
op_amp
id|args
comma
id|taskout
comma
id|outbuf
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TASKFILE_OUT
suffix:colon
r_if
c_cond
(paren
id|args.tf_out_flags.all
op_ne
l_int|0
)paren
(brace
id|args.prehandler
op_assign
op_amp
id|flagged_pre_task_out_intr
suffix:semicolon
id|args.handler
op_assign
op_amp
id|flagged_task_out_intr
suffix:semicolon
)brace
r_else
(brace
id|args.prehandler
op_assign
op_amp
id|pre_task_out_intr
suffix:semicolon
id|args.handler
op_assign
op_amp
id|task_out_intr
suffix:semicolon
)brace
id|err
op_assign
id|ide_diag_taskfile
c_func
(paren
id|drive
comma
op_amp
id|args
comma
id|taskout
comma
id|outbuf
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TASKFILE_MULTI_IN
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|drive-&gt;mult_count
)paren
(brace
multiline_comment|/* (hs): give up if multcount is not set */
id|printk
c_func
(paren
l_string|&quot;%s: %s Multimode Read failure &quot;
"&bslash;"
l_string|&quot;multcount is not set&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|__FUNCTION__
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EPERM
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
r_if
c_cond
(paren
id|args.tf_out_flags.all
op_ne
l_int|0
)paren
(brace
id|args.handler
op_assign
op_amp
id|flagged_task_mulin_intr
suffix:semicolon
)brace
r_else
(brace
id|args.handler
op_assign
op_amp
id|task_mulin_intr
suffix:semicolon
)brace
id|err
op_assign
id|ide_diag_taskfile
c_func
(paren
id|drive
comma
op_amp
id|args
comma
id|taskin
comma
id|inbuf
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TASKFILE_IN
suffix:colon
r_if
c_cond
(paren
id|args.tf_out_flags.all
op_ne
l_int|0
)paren
(brace
id|args.handler
op_assign
op_amp
id|flagged_task_in_intr
suffix:semicolon
)brace
r_else
(brace
id|args.handler
op_assign
op_amp
id|task_in_intr
suffix:semicolon
)brace
id|err
op_assign
id|ide_diag_taskfile
c_func
(paren
id|drive
comma
op_amp
id|args
comma
id|taskin
comma
id|inbuf
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TASKFILE_NO_DATA
suffix:colon
r_if
c_cond
(paren
id|args.tf_out_flags.all
op_ne
l_int|0
)paren
(brace
id|args.handler
op_assign
op_amp
id|flagged_task_no_data_intr
suffix:semicolon
)brace
r_else
(brace
id|args.handler
op_assign
op_amp
id|task_no_data_intr
suffix:semicolon
)brace
id|err
op_assign
id|ide_diag_taskfile
c_func
(paren
id|drive
comma
op_amp
id|args
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|err
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|req_task-&gt;io_ports
comma
op_amp
(paren
id|args.tfRegister
)paren
comma
id|HDIO_DRIVE_TASK_HDR_SIZE
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|req_task-&gt;hob_ports
comma
op_amp
(paren
id|args.hobRegister
)paren
comma
id|HDIO_DRIVE_HOB_HDR_SIZE
)paren
suffix:semicolon
id|req_task-&gt;in_flags
op_assign
id|args.tf_in_flags
suffix:semicolon
id|req_task-&gt;out_flags
op_assign
id|args.tf_out_flags
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
id|req_task
comma
id|tasksize
)paren
)paren
(brace
id|err
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
r_if
c_cond
(paren
id|taskout
)paren
(brace
r_int
id|outtotal
op_assign
id|tasksize
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
op_plus
id|outtotal
comma
id|outbuf
comma
id|taskout
)paren
)paren
(brace
id|err
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|taskin
)paren
(brace
r_int
id|intotal
op_assign
id|tasksize
op_plus
id|taskout
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
op_plus
id|intotal
comma
id|inbuf
comma
id|taskin
)paren
)paren
(brace
id|err
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
)brace
m_abort
suffix:colon
id|kfree
c_func
(paren
id|req_task
)paren
suffix:semicolon
r_if
c_cond
(paren
id|outbuf
op_ne
l_int|NULL
)paren
id|kfree
c_func
(paren
id|outbuf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inbuf
op_ne
l_int|NULL
)paren
id|kfree
c_func
(paren
id|inbuf
)paren
suffix:semicolon
singleline_comment|//&t;printk(&quot;IDE Taskfile ioctl ended. rc = %i&bslash;n&quot;, err);
id|drive-&gt;io_32bit
op_assign
id|io_32bit
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|variable|ide_taskfile_ioctl
id|EXPORT_SYMBOL
c_func
(paren
id|ide_taskfile_ioctl
)paren
suffix:semicolon
DECL|function|ide_wait_cmd
r_int
id|ide_wait_cmd
(paren
id|ide_drive_t
op_star
id|drive
comma
id|u8
id|cmd
comma
id|u8
id|nsect
comma
id|u8
id|feature
comma
id|u8
id|sectors
comma
id|u8
op_star
id|buf
)paren
(brace
r_struct
id|request
id|rq
suffix:semicolon
id|u8
id|buffer
(braket
l_int|4
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buf
)paren
id|buf
op_assign
id|buffer
suffix:semicolon
id|memset
c_func
(paren
id|buf
comma
l_int|0
comma
l_int|4
op_plus
id|SECTOR_WORDS
op_star
l_int|4
op_star
id|sectors
)paren
suffix:semicolon
id|ide_init_drive_cmd
c_func
(paren
op_amp
id|rq
)paren
suffix:semicolon
id|rq.buffer
op_assign
id|buf
suffix:semicolon
op_star
id|buf
op_increment
op_assign
id|cmd
suffix:semicolon
op_star
id|buf
op_increment
op_assign
id|nsect
suffix:semicolon
op_star
id|buf
op_increment
op_assign
id|feature
suffix:semicolon
op_star
id|buf
op_increment
op_assign
id|sectors
suffix:semicolon
r_return
id|ide_do_drive_cmd
c_func
(paren
id|drive
comma
op_amp
id|rq
comma
id|ide_wait
)paren
suffix:semicolon
)brace
DECL|variable|ide_wait_cmd
id|EXPORT_SYMBOL
c_func
(paren
id|ide_wait_cmd
)paren
suffix:semicolon
multiline_comment|/*&n; * FIXME : this needs to map into at taskfile. &lt;andre@linux-ide.org&gt;&n; */
DECL|function|ide_cmd_ioctl
r_int
id|ide_cmd_ioctl
(paren
id|ide_drive_t
op_star
id|drive
comma
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
macro_line|#if 1
r_int
id|err
op_assign
l_int|0
suffix:semicolon
id|u8
id|args
(braket
l_int|4
)braket
comma
op_star
id|argbuf
op_assign
id|args
suffix:semicolon
id|u8
id|xfer_rate
op_assign
l_int|0
suffix:semicolon
r_int
id|argsize
op_assign
l_int|4
suffix:semicolon
id|ide_task_t
id|tfargs
suffix:semicolon
r_if
c_cond
(paren
l_int|NULL
op_eq
(paren
r_void
op_star
)paren
id|arg
)paren
(brace
r_struct
id|request
id|rq
suffix:semicolon
id|ide_init_drive_cmd
c_func
(paren
op_amp
id|rq
)paren
suffix:semicolon
r_return
id|ide_do_drive_cmd
c_func
(paren
id|drive
comma
op_amp
id|rq
comma
id|ide_wait
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|args
comma
(paren
r_void
op_star
)paren
id|arg
comma
l_int|4
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|tfargs
comma
l_int|0
comma
r_sizeof
(paren
id|ide_task_t
)paren
)paren
suffix:semicolon
id|tfargs.tfRegister
(braket
id|IDE_FEATURE_OFFSET
)braket
op_assign
id|args
(braket
l_int|2
)braket
suffix:semicolon
id|tfargs.tfRegister
(braket
id|IDE_NSECTOR_OFFSET
)braket
op_assign
id|args
(braket
l_int|3
)braket
suffix:semicolon
id|tfargs.tfRegister
(braket
id|IDE_SECTOR_OFFSET
)braket
op_assign
id|args
(braket
l_int|1
)braket
suffix:semicolon
id|tfargs.tfRegister
(braket
id|IDE_LCYL_OFFSET
)braket
op_assign
l_int|0x00
suffix:semicolon
id|tfargs.tfRegister
(braket
id|IDE_HCYL_OFFSET
)braket
op_assign
l_int|0x00
suffix:semicolon
id|tfargs.tfRegister
(braket
id|IDE_SELECT_OFFSET
)braket
op_assign
l_int|0x00
suffix:semicolon
id|tfargs.tfRegister
(braket
id|IDE_COMMAND_OFFSET
)braket
op_assign
id|args
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
id|args
(braket
l_int|3
)braket
)paren
(brace
id|argsize
op_assign
l_int|4
op_plus
(paren
id|SECTOR_WORDS
op_star
l_int|4
op_star
id|args
(braket
l_int|3
)braket
)paren
suffix:semicolon
id|argbuf
op_assign
id|kmalloc
c_func
(paren
id|argsize
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|argbuf
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|memcpy
c_func
(paren
id|argbuf
comma
id|args
comma
l_int|4
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|set_transfer
c_func
(paren
id|drive
comma
op_amp
id|tfargs
)paren
)paren
(brace
id|xfer_rate
op_assign
id|args
(braket
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
id|ide_ata66_check
c_func
(paren
id|drive
comma
op_amp
id|tfargs
)paren
)paren
r_goto
m_abort
suffix:semicolon
)brace
id|err
op_assign
id|ide_wait_cmd
c_func
(paren
id|drive
comma
id|args
(braket
l_int|0
)braket
comma
id|args
(braket
l_int|1
)braket
comma
id|args
(braket
l_int|2
)braket
comma
id|args
(braket
l_int|3
)braket
comma
id|argbuf
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|err
op_logical_and
id|xfer_rate
)paren
(brace
multiline_comment|/* active-retuning-calls future */
r_if
c_cond
(paren
(paren
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|speedproc
)paren
op_ne
l_int|NULL
)paren
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|speedproc
c_func
(paren
id|drive
comma
id|xfer_rate
)paren
suffix:semicolon
id|ide_driveid_update
c_func
(paren
id|drive
)paren
suffix:semicolon
)brace
m_abort
suffix:colon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
id|argbuf
comma
id|argsize
)paren
)paren
id|err
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|argsize
OG
l_int|4
)paren
id|kfree
c_func
(paren
id|argbuf
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
macro_line|#else
r_int
id|err
op_assign
l_int|0
suffix:semicolon
id|u8
id|args
(braket
l_int|4
)braket
comma
op_star
id|argbuf
op_assign
id|args
suffix:semicolon
id|u8
id|xfer_rate
op_assign
l_int|0
suffix:semicolon
r_int
id|argsize
op_assign
l_int|0
suffix:semicolon
id|ide_task_t
id|tfargs
suffix:semicolon
r_if
c_cond
(paren
l_int|NULL
op_eq
(paren
r_void
op_star
)paren
id|arg
)paren
(brace
r_struct
id|request
id|rq
suffix:semicolon
id|ide_init_drive_cmd
c_func
(paren
op_amp
id|rq
)paren
suffix:semicolon
r_return
id|ide_do_drive_cmd
c_func
(paren
id|drive
comma
op_amp
id|rq
comma
id|ide_wait
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|args
comma
(paren
r_void
op_star
)paren
id|arg
comma
l_int|4
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|tfargs
comma
l_int|0
comma
r_sizeof
(paren
id|ide_task_t
)paren
)paren
suffix:semicolon
id|tfargs.tfRegister
(braket
id|IDE_FEATURE_OFFSET
)braket
op_assign
id|args
(braket
l_int|2
)braket
suffix:semicolon
id|tfargs.tfRegister
(braket
id|IDE_NSECTOR_OFFSET
)braket
op_assign
id|args
(braket
l_int|3
)braket
suffix:semicolon
id|tfargs.tfRegister
(braket
id|IDE_SECTOR_OFFSET
)braket
op_assign
id|args
(braket
l_int|1
)braket
suffix:semicolon
id|tfargs.tfRegister
(braket
id|IDE_LCYL_OFFSET
)braket
op_assign
l_int|0x00
suffix:semicolon
id|tfargs.tfRegister
(braket
id|IDE_HCYL_OFFSET
)braket
op_assign
l_int|0x00
suffix:semicolon
id|tfargs.tfRegister
(braket
id|IDE_SELECT_OFFSET
)braket
op_assign
l_int|0x00
suffix:semicolon
id|tfargs.tfRegister
(braket
id|IDE_COMMAND_OFFSET
)braket
op_assign
id|args
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
id|args
(braket
l_int|3
)braket
)paren
(brace
id|argsize
op_assign
(paren
id|SECTOR_WORDS
op_star
l_int|4
op_star
id|args
(braket
l_int|3
)braket
)paren
suffix:semicolon
id|argbuf
op_assign
id|kmalloc
c_func
(paren
id|argsize
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|argbuf
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_if
c_cond
(paren
id|set_transfer
c_func
(paren
id|drive
comma
op_amp
id|tfargs
)paren
)paren
(brace
id|xfer_rate
op_assign
id|args
(braket
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
id|ide_ata66_check
c_func
(paren
id|drive
comma
op_amp
id|tfargs
)paren
)paren
r_goto
m_abort
suffix:semicolon
)brace
id|tfargs.command_type
op_assign
id|ide_cmd_type_parser
c_func
(paren
op_amp
id|tfargs
)paren
suffix:semicolon
id|err
op_assign
id|ide_raw_taskfile
c_func
(paren
id|drive
comma
op_amp
id|tfargs
comma
id|argbuf
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|err
op_logical_and
id|xfer_rate
)paren
(brace
multiline_comment|/* active-retuning-calls future */
r_if
c_cond
(paren
(paren
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|speedproc
)paren
op_ne
l_int|NULL
)paren
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|speedproc
c_func
(paren
id|drive
comma
id|xfer_rate
)paren
suffix:semicolon
id|ide_driveid_update
c_func
(paren
id|drive
)paren
suffix:semicolon
)brace
m_abort
suffix:colon
id|args
(braket
l_int|0
)braket
op_assign
id|tfargs.tfRegister
(braket
id|IDE_COMMAND_OFFSET
)braket
suffix:semicolon
id|args
(braket
l_int|1
)braket
op_assign
id|tfargs.tfRegister
(braket
id|IDE_FEATURE_OFFSET
)braket
suffix:semicolon
id|args
(braket
l_int|2
)braket
op_assign
id|tfargs.tfRegister
(braket
id|IDE_NSECTOR_OFFSET
)braket
suffix:semicolon
id|args
(braket
l_int|3
)braket
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
id|argbuf
comma
l_int|4
)paren
)paren
id|err
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|argbuf
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
id|argbuf
op_plus
l_int|4
comma
id|argsize
)paren
)paren
id|err
op_assign
op_minus
id|EFAULT
suffix:semicolon
id|kfree
c_func
(paren
id|argbuf
)paren
suffix:semicolon
)brace
r_return
id|err
suffix:semicolon
macro_line|#endif
)brace
DECL|variable|ide_cmd_ioctl
id|EXPORT_SYMBOL
c_func
(paren
id|ide_cmd_ioctl
)paren
suffix:semicolon
DECL|function|ide_wait_cmd_task
r_int
id|ide_wait_cmd_task
(paren
id|ide_drive_t
op_star
id|drive
comma
id|u8
op_star
id|buf
)paren
(brace
r_struct
id|request
id|rq
suffix:semicolon
id|ide_init_drive_cmd
c_func
(paren
op_amp
id|rq
)paren
suffix:semicolon
id|rq.flags
op_assign
id|REQ_DRIVE_TASK
suffix:semicolon
id|rq.buffer
op_assign
id|buf
suffix:semicolon
r_return
id|ide_do_drive_cmd
c_func
(paren
id|drive
comma
op_amp
id|rq
comma
id|ide_wait
)paren
suffix:semicolon
)brace
DECL|variable|ide_wait_cmd_task
id|EXPORT_SYMBOL
c_func
(paren
id|ide_wait_cmd_task
)paren
suffix:semicolon
multiline_comment|/*&n; * FIXME : this needs to map into at taskfile. &lt;andre@linux-ide.org&gt;&n; */
DECL|function|ide_task_ioctl
r_int
id|ide_task_ioctl
(paren
id|ide_drive_t
op_star
id|drive
comma
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_int
id|err
op_assign
l_int|0
suffix:semicolon
id|u8
id|args
(braket
l_int|7
)braket
comma
op_star
id|argbuf
op_assign
id|args
suffix:semicolon
r_int
id|argsize
op_assign
l_int|7
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|args
comma
(paren
r_void
op_star
)paren
id|arg
comma
l_int|7
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|err
op_assign
id|ide_wait_cmd_task
c_func
(paren
id|drive
comma
id|argbuf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
id|argbuf
comma
id|argsize
)paren
)paren
id|err
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|variable|ide_task_ioctl
id|EXPORT_SYMBOL
c_func
(paren
id|ide_task_ioctl
)paren
suffix:semicolon
multiline_comment|/*&n; * NOTICE: This is additions from IBM to provide a discrete interface,&n; * for selective taskregister access operations.  Nice JOB Klaus!!!&n; * Glad to be able to work and co-develop this with you and IBM.&n; */
DECL|function|flagged_taskfile
id|ide_startstop_t
id|flagged_taskfile
(paren
id|ide_drive_t
op_star
id|drive
comma
id|ide_task_t
op_star
id|task
)paren
(brace
id|ide_hwif_t
op_star
id|hwif
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
suffix:semicolon
id|task_struct_t
op_star
id|taskfile
op_assign
(paren
id|task_struct_t
op_star
)paren
id|task-&gt;tfRegister
suffix:semicolon
id|hob_struct_t
op_star
id|hobfile
op_assign
(paren
id|hob_struct_t
op_star
)paren
id|task-&gt;hobRegister
suffix:semicolon
macro_line|#if DEBUG_TASKFILE
id|u8
id|status
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_IDE_TASK_IOCTL_DEBUG
r_void
id|debug_taskfile
c_func
(paren
id|drive
comma
id|task
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_IDE_TASK_IOCTL_DEBUG */
multiline_comment|/*&n;&t; * (ks) Check taskfile in/out flags.&n;&t; * If set, then execute as it is defined.&n;&t; * If not set, then define default settings.&n;&t; * The default values are:&n;&t; *&t;write and read all taskfile registers (except data) &n;&t; *&t;write and read the hob registers (sector,nsector,lcyl,hcyl)&n;&t; */
r_if
c_cond
(paren
id|task-&gt;tf_out_flags.all
op_eq
l_int|0
)paren
(brace
id|task-&gt;tf_out_flags.all
op_assign
id|IDE_TASKFILE_STD_OUT_FLAGS
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;addressing
op_eq
l_int|1
)paren
id|task-&gt;tf_out_flags.all
op_or_assign
(paren
id|IDE_HOB_STD_OUT_FLAGS
op_lshift
l_int|8
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|task-&gt;tf_in_flags.all
op_eq
l_int|0
)paren
(brace
id|task-&gt;tf_in_flags.all
op_assign
id|IDE_TASKFILE_STD_IN_FLAGS
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;addressing
op_eq
l_int|1
)paren
id|task-&gt;tf_in_flags.all
op_or_assign
(paren
id|IDE_HOB_STD_IN_FLAGS
op_lshift
l_int|8
)paren
suffix:semicolon
)brace
multiline_comment|/* ALL Command Block Executions SHALL clear nIEN, unless otherwise */
r_if
c_cond
(paren
id|IDE_CONTROL_REG
)paren
multiline_comment|/* clear nIEN */
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|drive-&gt;ctl
comma
id|IDE_CONTROL_REG
)paren
suffix:semicolon
id|SELECT_MASK
c_func
(paren
id|drive
comma
l_int|0
)paren
suffix:semicolon
macro_line|#if DEBUG_TASKFILE
id|status
op_assign
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_STATUS_REG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
l_int|0x80
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;flagged_taskfile -&gt; Bad status. Status = %02x. wait 100 usec ...&bslash;n&quot;
comma
id|status
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|100
)paren
suffix:semicolon
id|status
op_assign
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_STATUS_REG
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;flagged_taskfile -&gt; Status = %02x&bslash;n&quot;
comma
id|status
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|task-&gt;tf_out_flags.b.data
)paren
(brace
id|u16
id|data
op_assign
id|taskfile-&gt;data
op_plus
(paren
id|hobfile-&gt;data
op_lshift
l_int|8
)paren
suffix:semicolon
id|hwif
op_member_access_from_pointer
id|OUTW
c_func
(paren
id|data
comma
id|IDE_DATA_REG
)paren
suffix:semicolon
)brace
multiline_comment|/* (ks) send hob registers first */
r_if
c_cond
(paren
id|task-&gt;tf_out_flags.b.nsector_hob
)paren
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|hobfile-&gt;sector_count
comma
id|IDE_NSECTOR_REG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|task-&gt;tf_out_flags.b.sector_hob
)paren
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|hobfile-&gt;sector_number
comma
id|IDE_SECTOR_REG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|task-&gt;tf_out_flags.b.lcyl_hob
)paren
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|hobfile-&gt;low_cylinder
comma
id|IDE_LCYL_REG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|task-&gt;tf_out_flags.b.hcyl_hob
)paren
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|hobfile-&gt;high_cylinder
comma
id|IDE_HCYL_REG
)paren
suffix:semicolon
multiline_comment|/* (ks) Send now the standard registers */
r_if
c_cond
(paren
id|task-&gt;tf_out_flags.b.error_feature
)paren
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|taskfile-&gt;feature
comma
id|IDE_FEATURE_REG
)paren
suffix:semicolon
multiline_comment|/* refers to number of sectors to transfer */
r_if
c_cond
(paren
id|task-&gt;tf_out_flags.b.nsector
)paren
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|taskfile-&gt;sector_count
comma
id|IDE_NSECTOR_REG
)paren
suffix:semicolon
multiline_comment|/* refers to sector offset or start sector */
r_if
c_cond
(paren
id|task-&gt;tf_out_flags.b.sector
)paren
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|taskfile-&gt;sector_number
comma
id|IDE_SECTOR_REG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|task-&gt;tf_out_flags.b.lcyl
)paren
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|taskfile-&gt;low_cylinder
comma
id|IDE_LCYL_REG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|task-&gt;tf_out_flags.b.hcyl
)paren
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|taskfile-&gt;high_cylinder
comma
id|IDE_HCYL_REG
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * (ks) In the flagged taskfile approch, we will used all specified&n;&t; * registers and the register value will not be changed. Except the&n;&t; * select bit (master/slave) in the drive_head register. We must make&n;&t; * sure that the desired drive is selected.&n;&t; */
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|taskfile-&gt;device_head
op_or
id|drive-&gt;select.all
comma
id|IDE_SELECT_REG
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|task-&gt;data_phase
)paren
(brace
r_case
id|TASKFILE_OUT_DMAQ
suffix:colon
r_case
id|TASKFILE_OUT_DMA
suffix:colon
id|hwif
op_member_access_from_pointer
id|ide_dma_write
c_func
(paren
id|drive
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TASKFILE_IN_DMAQ
suffix:colon
r_case
id|TASKFILE_IN_DMA
suffix:colon
id|hwif
op_member_access_from_pointer
id|ide_dma_read
c_func
(paren
id|drive
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
r_if
c_cond
(paren
id|task-&gt;handler
op_eq
l_int|NULL
)paren
r_return
id|ide_stopped
suffix:semicolon
id|ide_set_handler
c_func
(paren
id|drive
comma
id|task-&gt;handler
comma
id|WAIT_WORSTCASE
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* Issue the command */
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|taskfile-&gt;command
comma
id|IDE_COMMAND_REG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|task-&gt;prehandler
op_ne
l_int|NULL
)paren
r_return
id|task
op_member_access_from_pointer
id|prehandler
c_func
(paren
id|drive
comma
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
)paren
suffix:semicolon
)brace
r_return
id|ide_started
suffix:semicolon
)brace
DECL|variable|flagged_taskfile
id|EXPORT_SYMBOL
c_func
(paren
id|flagged_taskfile
)paren
suffix:semicolon
DECL|function|flagged_task_no_data_intr
id|ide_startstop_t
id|flagged_task_no_data_intr
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|ide_hwif_t
op_star
id|hwif
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
suffix:semicolon
id|u8
id|stat
suffix:semicolon
id|local_irq_enable
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|OK_STAT
c_func
(paren
id|stat
op_assign
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_STATUS_REG
)paren
comma
id|READY_STAT
comma
id|BAD_STAT
)paren
)paren
(brace
r_if
c_cond
(paren
id|stat
op_amp
id|ERR_STAT
)paren
(brace
r_return
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|error
c_func
(paren
id|drive
comma
l_string|&quot;flagged_task_no_data_intr&quot;
comma
id|stat
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * (ks) Unexpected ATA data phase detected.&n;&t;&t; * This should not happen. But, it can !&n;&t;&t; * I am not sure, which function is best to clean up&n;&t;&t; * this situation.  I choose: ide_error(...)&n;&t;&t; */
r_return
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|error
c_func
(paren
id|drive
comma
l_string|&quot;flagged_task_no_data_intr (unexpected phase)&quot;
comma
id|stat
)paren
suffix:semicolon
)brace
id|ide_end_drive_cmd
c_func
(paren
id|drive
comma
id|stat
comma
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_ERROR_REG
)paren
)paren
suffix:semicolon
r_return
id|ide_stopped
suffix:semicolon
)brace
multiline_comment|/*&n; * Handler for command with PIO data-in phase&n; */
DECL|function|flagged_task_in_intr
id|ide_startstop_t
id|flagged_task_in_intr
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|ide_hwif_t
op_star
id|hwif
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
suffix:semicolon
id|u8
id|stat
op_assign
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_STATUS_REG
)paren
suffix:semicolon
r_struct
id|request
op_star
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
r_char
op_star
id|pBuf
op_assign
l_int|NULL
suffix:semicolon
r_int
id|retries
op_assign
l_int|5
suffix:semicolon
r_if
c_cond
(paren
id|rq-&gt;current_nr_sectors
op_eq
l_int|0
)paren
r_return
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|error
c_func
(paren
id|drive
comma
l_string|&quot;flagged_task_in_intr (no data requested)&quot;
comma
id|stat
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|OK_STAT
c_func
(paren
id|stat
comma
id|DATA_READY
comma
id|BAD_R_STAT
)paren
)paren
(brace
r_if
c_cond
(paren
id|stat
op_amp
id|ERR_STAT
)paren
(brace
r_return
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|error
c_func
(paren
id|drive
comma
l_string|&quot;flagged_task_in_intr&quot;
comma
id|stat
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * (ks) Unexpected ATA data phase detected.&n;&t;&t; * This should not happen. But, it can !&n;&t;&t; * I am not sure, which function is best to clean up&n;&t;&t; * this situation.  I choose: ide_error(...)&n;&t;&t; */
r_return
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|error
c_func
(paren
id|drive
comma
l_string|&quot;flagged_task_in_intr (unexpected data phase)&quot;
comma
id|stat
)paren
suffix:semicolon
)brace
id|pBuf
op_assign
id|rq-&gt;buffer
op_plus
(paren
(paren
id|rq-&gt;nr_sectors
op_minus
id|rq-&gt;current_nr_sectors
)paren
op_star
id|SECTOR_SIZE
)paren
suffix:semicolon
id|DTF
c_func
(paren
l_string|&quot;Read - rq-&gt;current_nr_sectors: %d, status: %02x&bslash;n&quot;
comma
(paren
r_int
)paren
id|rq-&gt;current_nr_sectors
comma
id|stat
)paren
suffix:semicolon
id|taskfile_input_data
c_func
(paren
id|drive
comma
id|pBuf
comma
id|SECTOR_WORDS
)paren
suffix:semicolon
r_if
c_cond
(paren
op_decrement
id|rq-&gt;current_nr_sectors
op_ne
l_int|0
)paren
(brace
multiline_comment|/*&n;                 * (ks) We don&squot;t know which command was executed. &n;&t;&t; * So, we wait the &squot;WORSTCASE&squot; value.&n;                 */
id|ide_set_handler
c_func
(paren
id|drive
comma
op_amp
id|flagged_task_in_intr
comma
id|WAIT_WORSTCASE
comma
l_int|NULL
)paren
suffix:semicolon
r_return
id|ide_started
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * (ks) Last sector was transfered, wait until drive is ready. &n;&t; * This can take up to 10 usec. We willl wait max 50 us.&n;&t; */
r_while
c_loop
(paren
(paren
(paren
id|stat
op_assign
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_STATUS_REG
)paren
)paren
op_amp
id|BUSY_STAT
)paren
op_logical_and
id|retries
op_decrement
)paren
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
id|ide_end_drive_cmd
(paren
id|drive
comma
id|stat
comma
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_ERROR_REG
)paren
)paren
suffix:semicolon
r_return
id|ide_stopped
suffix:semicolon
)brace
DECL|function|flagged_task_mulin_intr
id|ide_startstop_t
id|flagged_task_mulin_intr
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|ide_hwif_t
op_star
id|hwif
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
suffix:semicolon
id|u8
id|stat
op_assign
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_STATUS_REG
)paren
suffix:semicolon
r_struct
id|request
op_star
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
r_char
op_star
id|pBuf
op_assign
l_int|NULL
suffix:semicolon
r_int
id|retries
op_assign
l_int|5
suffix:semicolon
r_int
r_int
id|msect
comma
id|nsect
suffix:semicolon
r_if
c_cond
(paren
id|rq-&gt;current_nr_sectors
op_eq
l_int|0
)paren
r_return
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|error
c_func
(paren
id|drive
comma
l_string|&quot;flagged_task_mulin_intr (no data requested)&quot;
comma
id|stat
)paren
suffix:semicolon
id|msect
op_assign
id|drive-&gt;mult_count
suffix:semicolon
r_if
c_cond
(paren
id|msect
op_eq
l_int|0
)paren
r_return
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|error
c_func
(paren
id|drive
comma
l_string|&quot;flagged_task_mulin_intr (multimode not set)&quot;
comma
id|stat
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|OK_STAT
c_func
(paren
id|stat
comma
id|DATA_READY
comma
id|BAD_R_STAT
)paren
)paren
(brace
r_if
c_cond
(paren
id|stat
op_amp
id|ERR_STAT
)paren
(brace
r_return
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|error
c_func
(paren
id|drive
comma
l_string|&quot;flagged_task_mulin_intr&quot;
comma
id|stat
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * (ks) Unexpected ATA data phase detected.&n;&t;&t; * This should not happen. But, it can !&n;&t;&t; * I am not sure, which function is best to clean up&n;&t;&t; * this situation.  I choose: ide_error(...)&n;&t;&t; */
r_return
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|error
c_func
(paren
id|drive
comma
l_string|&quot;flagged_task_mulin_intr (unexpected data phase)&quot;
comma
id|stat
)paren
suffix:semicolon
)brace
id|nsect
op_assign
(paren
id|rq-&gt;current_nr_sectors
OG
id|msect
)paren
ques
c_cond
id|msect
suffix:colon
id|rq-&gt;current_nr_sectors
suffix:semicolon
id|pBuf
op_assign
id|rq-&gt;buffer
op_plus
(paren
(paren
id|rq-&gt;nr_sectors
op_minus
id|rq-&gt;current_nr_sectors
)paren
op_star
id|SECTOR_SIZE
)paren
suffix:semicolon
id|DTF
c_func
(paren
l_string|&quot;Multiread: %p, nsect: %d , rq-&gt;current_nr_sectors: %ld&bslash;n&quot;
comma
id|pBuf
comma
id|nsect
comma
id|rq-&gt;current_nr_sectors
)paren
suffix:semicolon
id|taskfile_input_data
c_func
(paren
id|drive
comma
id|pBuf
comma
id|nsect
op_star
id|SECTOR_WORDS
)paren
suffix:semicolon
id|rq-&gt;current_nr_sectors
op_sub_assign
id|nsect
suffix:semicolon
r_if
c_cond
(paren
id|rq-&gt;current_nr_sectors
op_ne
l_int|0
)paren
(brace
multiline_comment|/*&n;                 * (ks) We don&squot;t know which command was executed. &n;&t;&t; * So, we wait the &squot;WORSTCASE&squot; value.&n;                 */
id|ide_set_handler
c_func
(paren
id|drive
comma
op_amp
id|flagged_task_mulin_intr
comma
id|WAIT_WORSTCASE
comma
l_int|NULL
)paren
suffix:semicolon
r_return
id|ide_started
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * (ks) Last sector was transfered, wait until drive is ready. &n;&t; * This can take up to 10 usec. We willl wait max 50 us.&n;&t; */
r_while
c_loop
(paren
(paren
(paren
id|stat
op_assign
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_STATUS_REG
)paren
)paren
op_amp
id|BUSY_STAT
)paren
op_logical_and
id|retries
op_decrement
)paren
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
id|ide_end_drive_cmd
(paren
id|drive
comma
id|stat
comma
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_ERROR_REG
)paren
)paren
suffix:semicolon
r_return
id|ide_stopped
suffix:semicolon
)brace
multiline_comment|/*&n; * Pre handler for command with PIO data-out phase&n; */
DECL|function|flagged_pre_task_out_intr
id|ide_startstop_t
id|flagged_pre_task_out_intr
(paren
id|ide_drive_t
op_star
id|drive
comma
r_struct
id|request
op_star
id|rq
)paren
(brace
id|ide_hwif_t
op_star
id|hwif
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
suffix:semicolon
id|u8
id|stat
op_assign
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_STATUS_REG
)paren
suffix:semicolon
id|ide_startstop_t
id|startstop
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rq-&gt;current_nr_sectors
)paren
(brace
r_return
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|error
c_func
(paren
id|drive
comma
l_string|&quot;flagged_pre_task_out_intr (write data not specified)&quot;
comma
id|stat
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ide_wait_stat
c_func
(paren
op_amp
id|startstop
comma
id|drive
comma
id|DATA_READY
comma
id|BAD_W_STAT
comma
id|WAIT_DRQ
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: No DRQ bit after issuing write command.&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
r_return
id|startstop
suffix:semicolon
)brace
id|taskfile_output_data
c_func
(paren
id|drive
comma
id|rq-&gt;buffer
comma
id|SECTOR_WORDS
)paren
suffix:semicolon
op_decrement
id|rq-&gt;current_nr_sectors
suffix:semicolon
r_return
id|ide_started
suffix:semicolon
)brace
DECL|function|flagged_task_out_intr
id|ide_startstop_t
id|flagged_task_out_intr
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|ide_hwif_t
op_star
id|hwif
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
suffix:semicolon
id|u8
id|stat
op_assign
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_STATUS_REG
)paren
suffix:semicolon
r_struct
id|request
op_star
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
r_char
op_star
id|pBuf
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|OK_STAT
c_func
(paren
id|stat
comma
id|DRIVE_READY
comma
id|BAD_W_STAT
)paren
)paren
r_return
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|error
c_func
(paren
id|drive
comma
l_string|&quot;flagged_task_out_intr&quot;
comma
id|stat
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rq-&gt;current_nr_sectors
)paren
(brace
id|ide_end_drive_cmd
(paren
id|drive
comma
id|stat
comma
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_ERROR_REG
)paren
)paren
suffix:semicolon
r_return
id|ide_stopped
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|OK_STAT
c_func
(paren
id|stat
comma
id|DATA_READY
comma
id|BAD_W_STAT
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * (ks) Unexpected ATA data phase detected.&n;&t;&t; * This should not happen. But, it can !&n;&t;&t; * I am not sure, which function is best to clean up&n;&t;&t; * this situation.  I choose: ide_error(...)&n;&t;&t; */
r_return
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|error
c_func
(paren
id|drive
comma
l_string|&quot;flagged_task_out_intr (unexpected data phase)&quot;
comma
id|stat
)paren
suffix:semicolon
)brace
id|pBuf
op_assign
id|rq-&gt;buffer
op_plus
(paren
(paren
id|rq-&gt;nr_sectors
op_minus
id|rq-&gt;current_nr_sectors
)paren
op_star
id|SECTOR_SIZE
)paren
suffix:semicolon
id|DTF
c_func
(paren
l_string|&quot;Write - rq-&gt;current_nr_sectors: %d, status: %02x&bslash;n&quot;
comma
(paren
r_int
)paren
id|rq-&gt;current_nr_sectors
comma
id|stat
)paren
suffix:semicolon
id|taskfile_output_data
c_func
(paren
id|drive
comma
id|pBuf
comma
id|SECTOR_WORDS
)paren
suffix:semicolon
op_decrement
id|rq-&gt;current_nr_sectors
suffix:semicolon
multiline_comment|/*&n;&t; * (ks) We don&squot;t know which command was executed. &n;&t; * So, we wait the &squot;WORSTCASE&squot; value.&n;&t; */
id|ide_set_handler
c_func
(paren
id|drive
comma
op_amp
id|flagged_task_out_intr
comma
id|WAIT_WORSTCASE
comma
l_int|NULL
)paren
suffix:semicolon
r_return
id|ide_started
suffix:semicolon
)brace
DECL|function|flagged_pre_task_mulout_intr
id|ide_startstop_t
id|flagged_pre_task_mulout_intr
(paren
id|ide_drive_t
op_star
id|drive
comma
r_struct
id|request
op_star
id|rq
)paren
(brace
id|ide_hwif_t
op_star
id|hwif
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
suffix:semicolon
id|u8
id|stat
op_assign
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_STATUS_REG
)paren
suffix:semicolon
r_char
op_star
id|pBuf
op_assign
l_int|NULL
suffix:semicolon
id|ide_startstop_t
id|startstop
suffix:semicolon
r_int
r_int
id|msect
comma
id|nsect
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rq-&gt;current_nr_sectors
)paren
r_return
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|error
c_func
(paren
id|drive
comma
l_string|&quot;flagged_pre_task_mulout_intr (write data not specified)&quot;
comma
id|stat
)paren
suffix:semicolon
id|msect
op_assign
id|drive-&gt;mult_count
suffix:semicolon
r_if
c_cond
(paren
id|msect
op_eq
l_int|0
)paren
r_return
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|error
c_func
(paren
id|drive
comma
l_string|&quot;flagged_pre_task_mulout_intr (multimode not set)&quot;
comma
id|stat
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ide_wait_stat
c_func
(paren
op_amp
id|startstop
comma
id|drive
comma
id|DATA_READY
comma
id|BAD_W_STAT
comma
id|WAIT_DRQ
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: No DRQ bit after issuing write command.&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
r_return
id|startstop
suffix:semicolon
)brace
id|nsect
op_assign
(paren
id|rq-&gt;current_nr_sectors
OG
id|msect
)paren
ques
c_cond
id|msect
suffix:colon
id|rq-&gt;current_nr_sectors
suffix:semicolon
id|pBuf
op_assign
id|rq-&gt;buffer
op_plus
(paren
(paren
id|rq-&gt;nr_sectors
op_minus
id|rq-&gt;current_nr_sectors
)paren
op_star
id|SECTOR_SIZE
)paren
suffix:semicolon
id|DTF
c_func
(paren
l_string|&quot;Multiwrite: %p, nsect: %d , rq-&gt;current_nr_sectors: %ld&bslash;n&quot;
comma
id|pBuf
comma
id|nsect
comma
id|rq-&gt;current_nr_sectors
)paren
suffix:semicolon
id|taskfile_output_data
c_func
(paren
id|drive
comma
id|pBuf
comma
id|nsect
op_star
id|SECTOR_WORDS
)paren
suffix:semicolon
id|rq-&gt;current_nr_sectors
op_sub_assign
id|nsect
suffix:semicolon
r_return
id|ide_started
suffix:semicolon
)brace
DECL|function|flagged_task_mulout_intr
id|ide_startstop_t
id|flagged_task_mulout_intr
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|ide_hwif_t
op_star
id|hwif
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
suffix:semicolon
id|u8
id|stat
op_assign
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_STATUS_REG
)paren
suffix:semicolon
r_struct
id|request
op_star
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
r_char
op_star
id|pBuf
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|msect
comma
id|nsect
suffix:semicolon
id|msect
op_assign
id|drive-&gt;mult_count
suffix:semicolon
r_if
c_cond
(paren
id|msect
op_eq
l_int|0
)paren
r_return
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|error
c_func
(paren
id|drive
comma
l_string|&quot;flagged_task_mulout_intr (multimode not set)&quot;
comma
id|stat
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|OK_STAT
c_func
(paren
id|stat
comma
id|DRIVE_READY
comma
id|BAD_W_STAT
)paren
)paren
r_return
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|error
c_func
(paren
id|drive
comma
l_string|&quot;flagged_task_mulout_intr&quot;
comma
id|stat
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rq-&gt;current_nr_sectors
)paren
(brace
id|ide_end_drive_cmd
(paren
id|drive
comma
id|stat
comma
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_ERROR_REG
)paren
)paren
suffix:semicolon
r_return
id|ide_stopped
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|OK_STAT
c_func
(paren
id|stat
comma
id|DATA_READY
comma
id|BAD_W_STAT
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * (ks) Unexpected ATA data phase detected.&n;&t;&t; * This should not happen. But, it can !&n;&t;&t; * I am not sure, which function is best to clean up&n;&t;&t; * this situation.  I choose: ide_error(...)&n;&t;&t; */
r_return
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|error
c_func
(paren
id|drive
comma
l_string|&quot;flagged_task_mulout_intr (unexpected data phase)&quot;
comma
id|stat
)paren
suffix:semicolon
)brace
id|nsect
op_assign
(paren
id|rq-&gt;current_nr_sectors
OG
id|msect
)paren
ques
c_cond
id|msect
suffix:colon
id|rq-&gt;current_nr_sectors
suffix:semicolon
id|pBuf
op_assign
id|rq-&gt;buffer
op_plus
(paren
(paren
id|rq-&gt;nr_sectors
op_minus
id|rq-&gt;current_nr_sectors
)paren
op_star
id|SECTOR_SIZE
)paren
suffix:semicolon
id|DTF
c_func
(paren
l_string|&quot;Multiwrite: %p, nsect: %d , rq-&gt;current_nr_sectors: %ld&bslash;n&quot;
comma
id|pBuf
comma
id|nsect
comma
id|rq-&gt;current_nr_sectors
)paren
suffix:semicolon
id|taskfile_output_data
c_func
(paren
id|drive
comma
id|pBuf
comma
id|nsect
op_star
id|SECTOR_WORDS
)paren
suffix:semicolon
id|rq-&gt;current_nr_sectors
op_sub_assign
id|nsect
suffix:semicolon
multiline_comment|/*&n;&t; * (ks) We don&squot;t know which command was executed. &n;&t; * So, we wait the &squot;WORSTCASE&squot; value.&n;&t; */
id|ide_set_handler
c_func
(paren
id|drive
comma
op_amp
id|flagged_task_mulout_intr
comma
id|WAIT_WORSTCASE
comma
l_int|NULL
)paren
suffix:semicolon
r_return
id|ide_started
suffix:semicolon
)brace
multiline_comment|/*&n; * Beginning of Taskfile OPCODE Library and feature sets.&n; */
macro_line|#ifdef CONFIG_PKT_TASK_IOCTL
DECL|function|pkt_taskfile_ioctl
r_int
id|pkt_taskfile_ioctl
(paren
id|ide_drive_t
op_star
id|drive
comma
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
macro_line|#if 0
r_switch
c_cond
(paren
id|req_task-&gt;data_phase
)paren
(brace
r_case
id|TASKFILE_P_OUT_DMAQ
suffix:colon
r_case
id|TASKFILE_P_IN_DMAQ
suffix:colon
r_case
id|TASKFILE_P_OUT_DMA
suffix:colon
r_case
id|TASKFILE_P_IN_DMA
suffix:colon
r_case
id|TASKFILE_P_OUT
suffix:colon
r_case
id|TASKFILE_P_IN
suffix:colon
)brace
macro_line|#endif
r_return
op_minus
id|ENOMSG
suffix:semicolon
)brace
DECL|variable|pkt_taskfile_ioctl
id|EXPORT_SYMBOL
c_func
(paren
id|pkt_taskfile_ioctl
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_PKT_TASK_IOCTL */
eof
