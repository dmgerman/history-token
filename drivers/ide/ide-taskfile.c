multiline_comment|/*&n; * linux/drivers/ide/ide-taskfile.c&t;Version 0.33&t;April 11, 2002&n; *&n; *  Copyright (C) 2000-2002&t;Michael Cornwell &lt;cornwell@acm.org&gt;&n; *  Copyright (C) 2000-2002&t;Andre Hedrick &lt;andre@linux-ide.org&gt;&n; *  Copyright (C) 2001-2002&t;Klaus Smolin&n; *&t;&t;&t;&t;&t;IBM Storage Technology Division&n; *&n; *  The big the bad and the ugly.&n; *&n; *  Problems to be fixed because of BH interface or the lack therefore.&n; *&n; *  Fill me in stupid !!!&n; *&n; *  HOST:&n; *&t;General refers to the Controller and Driver &quot;pair&quot;.&n; *  DATA HANDLER:&n; *&t;Under the context of Linux it generally refers to an interrupt handler.&n; *&t;However, it correctly describes the &squot;HOST&squot;&n; *  DATA BLOCK:&n; *&t;The amount of data needed to be transfered as predefined in the&n; *&t;setup of the device.&n; *  STORAGE ATOMIC:&n; *&t;The &squot;DATA BLOCK&squot; associated to the &squot;DATA HANDLER&squot;, and can be as&n; *&t;small as a single sector or as large as the entire command block&n; *&t;request.&n; */
macro_line|#include &lt;linux/config.h&gt;
DECL|macro|__NO_VERSION__
mdefine_line|#define __NO_VERSION__
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/major.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/genhd.h&gt;
macro_line|#include &lt;linux/blkpg.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/hdreg.h&gt;
macro_line|#include &lt;linux/ide.h&gt;
macro_line|#include &lt;asm/byteorder.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
DECL|macro|DEBUG_TASKFILE
mdefine_line|#define DEBUG_TASKFILE&t;0&t;/* unset when fixed */
macro_line|#if DEBUG_TASKFILE
DECL|macro|DTF
mdefine_line|#define DTF(x...) printk(x)
macro_line|#else
DECL|macro|DTF
mdefine_line|#define DTF(x...)
macro_line|#endif
DECL|macro|task_map_rq
mdefine_line|#define task_map_rq(rq, flags)&t;&t;ide_map_buffer((rq), (flags))
DECL|macro|task_unmap_rq
mdefine_line|#define task_unmap_rq(rq, buf, flags)&t;ide_unmap_buffer((buf), (flags))
DECL|function|task_read_24
r_inline
id|u32
id|task_read_24
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_return
(paren
id|IN_BYTE
c_func
(paren
id|IDE_HCYL_REG
)paren
op_lshift
l_int|16
)paren
op_or
(paren
id|IN_BYTE
c_func
(paren
id|IDE_LCYL_REG
)paren
op_lshift
l_int|8
)paren
op_or
id|IN_BYTE
c_func
(paren
id|IDE_SECTOR_REG
)paren
suffix:semicolon
)brace
DECL|function|ata_bswap_data
r_static
r_void
id|ata_bswap_data
(paren
r_void
op_star
id|buffer
comma
r_int
id|wcount
)paren
(brace
id|u16
op_star
id|p
op_assign
id|buffer
suffix:semicolon
r_while
c_loop
(paren
id|wcount
op_decrement
)paren
(brace
op_star
id|p
op_assign
op_star
id|p
op_lshift
l_int|8
op_or
op_star
id|p
op_rshift
l_int|8
suffix:semicolon
id|p
op_increment
suffix:semicolon
op_star
id|p
op_assign
op_star
id|p
op_lshift
l_int|8
op_or
op_star
id|p
op_rshift
l_int|8
suffix:semicolon
id|p
op_increment
suffix:semicolon
)brace
)brace
macro_line|#if SUPPORT_VLB_SYNC
multiline_comment|/*&n; * Some localbus EIDE interfaces require a special access sequence&n; * when using 32-bit I/O instructions to transfer data.  We call this&n; * the &quot;vlb_sync&quot; sequence, which consists of three successive reads&n; * of the sector count register location, with interrupts disabled&n; * to ensure that the reads all happen together.&n; */
DECL|function|task_vlb_sync
r_static
r_inline
r_void
id|task_vlb_sync
(paren
id|ide_ioreg_t
id|port
)paren
(brace
(paren
r_void
)paren
id|IN_BYTE
(paren
id|port
)paren
suffix:semicolon
(paren
r_void
)paren
id|IN_BYTE
(paren
id|port
)paren
suffix:semicolon
(paren
r_void
)paren
id|IN_BYTE
(paren
id|port
)paren
suffix:semicolon
)brace
macro_line|#endif /* SUPPORT_VLB_SYNC */
multiline_comment|/*&n; * This is used for most PIO data transfers *from* the IDE interface&n; */
DECL|function|ata_input_data
r_void
id|ata_input_data
(paren
id|ide_drive_t
op_star
id|drive
comma
r_void
op_star
id|buffer
comma
r_int
r_int
id|wcount
)paren
(brace
id|byte
id|io_32bit
suffix:semicolon
multiline_comment|/*&n;&t; * first check if this controller has defined a special function&n;&t; * for handling polled ide transfers&n;&t; */
r_if
c_cond
(paren
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|ideproc
)paren
(brace
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|ideproc
c_func
(paren
id|ideproc_ide_input_data
comma
id|drive
comma
id|buffer
comma
id|wcount
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|io_32bit
op_assign
id|drive-&gt;io_32bit
suffix:semicolon
r_if
c_cond
(paren
id|io_32bit
)paren
(brace
macro_line|#if SUPPORT_VLB_SYNC
r_if
c_cond
(paren
id|io_32bit
op_amp
l_int|2
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|local_irq_save
c_func
(paren
id|flags
)paren
suffix:semicolon
id|task_vlb_sync
c_func
(paren
id|IDE_NSECTOR_REG
)paren
suffix:semicolon
id|insl
c_func
(paren
id|IDE_DATA_REG
comma
id|buffer
comma
id|wcount
)paren
suffix:semicolon
id|local_irq_restore
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
r_else
macro_line|#endif /* SUPPORT_VLB_SYNC */
id|insl
c_func
(paren
id|IDE_DATA_REG
comma
id|buffer
comma
id|wcount
)paren
suffix:semicolon
)brace
r_else
(brace
macro_line|#if SUPPORT_SLOW_DATA_PORTS
r_if
c_cond
(paren
id|drive-&gt;slow
)paren
(brace
r_int
r_int
op_star
id|ptr
op_assign
(paren
r_int
r_int
op_star
)paren
id|buffer
suffix:semicolon
r_while
c_loop
(paren
id|wcount
op_decrement
)paren
(brace
op_star
id|ptr
op_increment
op_assign
id|inw_p
c_func
(paren
id|IDE_DATA_REG
)paren
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
id|inw_p
c_func
(paren
id|IDE_DATA_REG
)paren
suffix:semicolon
)brace
)brace
r_else
macro_line|#endif /* SUPPORT_SLOW_DATA_PORTS */
id|insw
c_func
(paren
id|IDE_DATA_REG
comma
id|buffer
comma
id|wcount
op_lshift
l_int|1
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * This is used for most PIO data transfers *to* the IDE interface&n; */
DECL|function|ata_output_data
r_void
id|ata_output_data
(paren
id|ide_drive_t
op_star
id|drive
comma
r_void
op_star
id|buffer
comma
r_int
r_int
id|wcount
)paren
(brace
id|byte
id|io_32bit
suffix:semicolon
r_if
c_cond
(paren
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|ideproc
)paren
(brace
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|ideproc
c_func
(paren
id|ideproc_ide_output_data
comma
id|drive
comma
id|buffer
comma
id|wcount
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|io_32bit
op_assign
id|drive-&gt;io_32bit
suffix:semicolon
r_if
c_cond
(paren
id|io_32bit
)paren
(brace
macro_line|#if SUPPORT_VLB_SYNC
r_if
c_cond
(paren
id|io_32bit
op_amp
l_int|2
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|local_irq_save
c_func
(paren
id|flags
)paren
suffix:semicolon
id|task_vlb_sync
c_func
(paren
id|IDE_NSECTOR_REG
)paren
suffix:semicolon
id|outsl
c_func
(paren
id|IDE_DATA_REG
comma
id|buffer
comma
id|wcount
)paren
suffix:semicolon
id|local_irq_restore
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
r_else
macro_line|#endif /* SUPPORT_VLB_SYNC */
id|outsl
c_func
(paren
id|IDE_DATA_REG
comma
id|buffer
comma
id|wcount
)paren
suffix:semicolon
)brace
r_else
(brace
macro_line|#if SUPPORT_SLOW_DATA_PORTS
r_if
c_cond
(paren
id|drive-&gt;slow
)paren
(brace
r_int
r_int
op_star
id|ptr
op_assign
(paren
r_int
r_int
op_star
)paren
id|buffer
suffix:semicolon
r_while
c_loop
(paren
id|wcount
op_decrement
)paren
(brace
id|outw_p
c_func
(paren
op_star
id|ptr
op_increment
comma
id|IDE_DATA_REG
)paren
suffix:semicolon
id|outw_p
c_func
(paren
op_star
id|ptr
op_increment
comma
id|IDE_DATA_REG
)paren
suffix:semicolon
)brace
)brace
r_else
macro_line|#endif /* SUPPORT_SLOW_DATA_PORTS */
id|outsw
c_func
(paren
id|IDE_DATA_REG
comma
id|buffer
comma
id|wcount
op_lshift
l_int|1
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * The following routines are mainly used by the ATAPI drivers.&n; *&n; * These routines will round up any request for an odd number of bytes,&n; * so if an odd bytecount is specified, be sure that there&squot;s at least one&n; * extra byte allocated for the buffer.&n; */
DECL|function|atapi_input_bytes
r_void
id|atapi_input_bytes
(paren
id|ide_drive_t
op_star
id|drive
comma
r_void
op_star
id|buffer
comma
r_int
r_int
id|bytecount
)paren
(brace
r_if
c_cond
(paren
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|ideproc
)paren
(brace
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|ideproc
c_func
(paren
id|ideproc_atapi_input_bytes
comma
id|drive
comma
id|buffer
comma
id|bytecount
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
op_increment
id|bytecount
suffix:semicolon
macro_line|#if defined(CONFIG_ATARI) || defined(CONFIG_Q40)
r_if
c_cond
(paren
id|MACH_IS_ATARI
op_logical_or
id|MACH_IS_Q40
)paren
(brace
multiline_comment|/* Atari has a byte-swapped IDE interface */
id|insw_swapw
c_func
(paren
id|IDE_DATA_REG
comma
id|buffer
comma
id|bytecount
op_div
l_int|2
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_ATARI */
id|ata_input_data
(paren
id|drive
comma
id|buffer
comma
id|bytecount
op_div
l_int|4
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bytecount
op_amp
l_int|0x03
)paren
op_ge
l_int|2
)paren
id|insw
(paren
id|IDE_DATA_REG
comma
(paren
(paren
id|byte
op_star
)paren
id|buffer
)paren
op_plus
(paren
id|bytecount
op_amp
op_complement
l_int|0x03
)paren
comma
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|atapi_output_bytes
r_void
id|atapi_output_bytes
(paren
id|ide_drive_t
op_star
id|drive
comma
r_void
op_star
id|buffer
comma
r_int
r_int
id|bytecount
)paren
(brace
r_if
c_cond
(paren
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|ideproc
)paren
(brace
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|ideproc
c_func
(paren
id|ideproc_atapi_output_bytes
comma
id|drive
comma
id|buffer
comma
id|bytecount
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
op_increment
id|bytecount
suffix:semicolon
macro_line|#if defined(CONFIG_ATARI) || defined(CONFIG_Q40)
r_if
c_cond
(paren
id|MACH_IS_ATARI
op_logical_or
id|MACH_IS_Q40
)paren
(brace
multiline_comment|/* Atari has a byte-swapped IDE interface */
id|outsw_swapw
c_func
(paren
id|IDE_DATA_REG
comma
id|buffer
comma
id|bytecount
op_div
l_int|2
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_ATARI */
id|ata_output_data
(paren
id|drive
comma
id|buffer
comma
id|bytecount
op_div
l_int|4
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bytecount
op_amp
l_int|0x03
)paren
op_ge
l_int|2
)paren
id|outsw
(paren
id|IDE_DATA_REG
comma
(paren
(paren
id|byte
op_star
)paren
id|buffer
)paren
op_plus
(paren
id|bytecount
op_amp
op_complement
l_int|0x03
)paren
comma
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|taskfile_input_data
r_void
id|taskfile_input_data
(paren
id|ide_drive_t
op_star
id|drive
comma
r_void
op_star
id|buffer
comma
r_int
r_int
id|wcount
)paren
(brace
id|ata_input_data
c_func
(paren
id|drive
comma
id|buffer
comma
id|wcount
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;bswap
)paren
id|ata_bswap_data
c_func
(paren
id|buffer
comma
id|wcount
)paren
suffix:semicolon
)brace
DECL|function|taskfile_output_data
r_void
id|taskfile_output_data
(paren
id|ide_drive_t
op_star
id|drive
comma
r_void
op_star
id|buffer
comma
r_int
r_int
id|wcount
)paren
(brace
r_if
c_cond
(paren
id|drive-&gt;bswap
)paren
(brace
id|ata_bswap_data
c_func
(paren
id|buffer
comma
id|wcount
)paren
suffix:semicolon
id|ata_output_data
c_func
(paren
id|drive
comma
id|buffer
comma
id|wcount
)paren
suffix:semicolon
id|ata_bswap_data
c_func
(paren
id|buffer
comma
id|wcount
)paren
suffix:semicolon
)brace
r_else
(brace
id|ata_output_data
c_func
(paren
id|drive
comma
id|buffer
comma
id|wcount
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Needed for PCI irq sharing&n; */
DECL|function|drive_is_ready
r_int
id|drive_is_ready
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|byte
id|stat
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;waiting_for_dma
)paren
r_return
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|dmaproc
c_func
(paren
id|ide_dma_test_irq
comma
id|drive
)paren
suffix:semicolon
macro_line|#if 0
multiline_comment|/* need to guarantee 400ns since last command was issued */
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_IDEPCI_SHARE_IRQ
multiline_comment|/*&n;&t; * We do a passive status test under shared PCI interrupts on&n;&t; * cards that truly share the ATA side interrupt, but may also share&n;&t; * an interrupt with another pci card/device.  We make no assumptions&n;&t; * about possible isa-pnp and pci-pnp issues yet.&n;&t; */
r_if
c_cond
(paren
id|IDE_CONTROL_REG
)paren
id|stat
op_assign
id|GET_ALTSTAT
c_func
(paren
)paren
suffix:semicolon
r_else
macro_line|#endif /* CONFIG_IDEPCI_SHARE_IRQ */
id|stat
op_assign
id|GET_STAT
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Note: this may clear a pending IRQ!! */
r_if
c_cond
(paren
id|stat
op_amp
id|BUSY_STAT
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* drive busy:  definitely not interrupting */
r_return
l_int|1
suffix:semicolon
multiline_comment|/* drive ready: *might* be interrupting */
)brace
multiline_comment|/*&n; * Global for All, and taken from ide-pmac.c&n; */
DECL|function|wait_for_ready
r_int
id|wait_for_ready
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|timeout
)paren
(brace
id|byte
id|stat
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
op_decrement
id|timeout
)paren
(brace
id|stat
op_assign
id|GET_STAT
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|stat
op_amp
id|BUSY_STAT
)paren
)paren
(brace
r_if
c_cond
(paren
id|drive-&gt;ready_stat
op_eq
l_int|0
)paren
r_break
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|stat
op_amp
id|drive-&gt;ready_stat
)paren
op_logical_or
(paren
id|stat
op_amp
id|ERR_STAT
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
id|mdelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|stat
op_amp
id|ERR_STAT
)paren
op_logical_or
id|timeout
op_le
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|stat
op_amp
id|ERR_STAT
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: wait_for_ready, error status: %x&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|stat
)paren
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * This routine busy-waits for the drive status to be not &quot;busy&quot;.&n; * It then checks the status for all of the &quot;good&quot; bits and none&n; * of the &quot;bad&quot; bits, and if all is okay it returns 0.  All other&n; * cases return 1 after invoking ide_error() -- caller should just return.&n; *&n; * This routine should get fixed to not hog the cpu during extra long waits..&n; * That could be done by busy-waiting for the first jiffy or two, and then&n; * setting a timer to wake up at half second intervals thereafter,&n; * until timeout is achieved, before timing out.&n; */
DECL|function|ide_wait_stat
r_int
id|ide_wait_stat
(paren
id|ide_startstop_t
op_star
id|startstop
comma
id|ide_drive_t
op_star
id|drive
comma
id|byte
id|good
comma
id|byte
id|bad
comma
r_int
r_int
id|timeout
)paren
(brace
id|byte
id|stat
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/* bail early if we&squot;ve exceeded max_failures */
r_if
c_cond
(paren
id|drive-&gt;max_failures
op_logical_and
(paren
id|drive-&gt;failures
OG
id|drive-&gt;max_failures
)paren
)paren
(brace
op_star
id|startstop
op_assign
id|ide_stopped
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
multiline_comment|/* spec allows drive 400ns to assert &quot;BUSY&quot; */
r_if
c_cond
(paren
(paren
id|stat
op_assign
id|GET_STAT
c_func
(paren
)paren
)paren
op_amp
id|BUSY_STAT
)paren
(brace
id|local_irq_set
c_func
(paren
id|flags
)paren
suffix:semicolon
id|timeout
op_add_assign
id|jiffies
suffix:semicolon
r_while
c_loop
(paren
(paren
id|stat
op_assign
id|GET_STAT
c_func
(paren
)paren
)paren
op_amp
id|BUSY_STAT
)paren
(brace
r_if
c_cond
(paren
id|time_after
c_func
(paren
id|jiffies
comma
id|timeout
)paren
)paren
(brace
id|local_irq_restore
c_func
(paren
id|flags
)paren
suffix:semicolon
op_star
id|startstop
op_assign
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|error
c_func
(paren
id|drive
comma
l_string|&quot;status timeout&quot;
comma
id|stat
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
id|local_irq_restore
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Allow status to settle, then read it again.&n;&t; * A few rare drives vastly violate the 400ns spec here,&n;&t; * so we&squot;ll wait up to 10usec for a &quot;good&quot; status&n;&t; * rather than expensively fail things immediately.&n;&t; * This fix courtesy of Matthew Faupel &amp; Niccolo Rigacci.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|10
suffix:semicolon
id|i
op_increment
)paren
(brace
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|OK_STAT
c_func
(paren
(paren
id|stat
op_assign
id|GET_STAT
c_func
(paren
)paren
)paren
comma
id|good
comma
id|bad
)paren
)paren
r_return
l_int|0
suffix:semicolon
)brace
op_star
id|startstop
op_assign
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|error
c_func
(paren
id|drive
comma
l_string|&quot;status error&quot;
comma
id|stat
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|debug_taskfile
r_void
id|debug_taskfile
(paren
id|ide_drive_t
op_star
id|drive
comma
id|ide_task_t
op_star
id|args
)paren
(brace
macro_line|#ifdef CONFIG_IDE_TASK_IOCTL_DEBUG
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: &quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
singleline_comment|//&t;printk(&quot;TF.0=x%02x &quot;, args-&gt;tfRegister[IDE_DATA_OFFSET]);
id|printk
c_func
(paren
l_string|&quot;TF.1=x%02x &quot;
comma
id|args-&gt;tfRegister
(braket
id|IDE_FEATURE_OFFSET
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;TF.2=x%02x &quot;
comma
id|args-&gt;tfRegister
(braket
id|IDE_NSECTOR_OFFSET
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;TF.3=x%02x &quot;
comma
id|args-&gt;tfRegister
(braket
id|IDE_SECTOR_OFFSET
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;TF.4=x%02x &quot;
comma
id|args-&gt;tfRegister
(braket
id|IDE_LCYL_OFFSET
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;TF.5=x%02x &quot;
comma
id|args-&gt;tfRegister
(braket
id|IDE_HCYL_OFFSET
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;TF.6=x%02x &quot;
comma
id|args-&gt;tfRegister
(braket
id|IDE_SELECT_OFFSET
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;TF.7=x%02x&bslash;n&quot;
comma
id|args-&gt;tfRegister
(braket
id|IDE_COMMAND_OFFSET
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: &quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
singleline_comment|//&t;printk(&quot;HTF.0=x%02x &quot;, args-&gt;hobRegister[IDE_DATA_OFFSET_HOB]);
id|printk
c_func
(paren
l_string|&quot;HTF.1=x%02x &quot;
comma
id|args-&gt;hobRegister
(braket
id|IDE_FEATURE_OFFSET_HOB
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;HTF.2=x%02x &quot;
comma
id|args-&gt;hobRegister
(braket
id|IDE_NSECTOR_OFFSET_HOB
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;HTF.3=x%02x &quot;
comma
id|args-&gt;hobRegister
(braket
id|IDE_SECTOR_OFFSET_HOB
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;HTF.4=x%02x &quot;
comma
id|args-&gt;hobRegister
(braket
id|IDE_LCYL_OFFSET_HOB
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;HTF.5=x%02x &quot;
comma
id|args-&gt;hobRegister
(braket
id|IDE_HCYL_OFFSET_HOB
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;HTF.6=x%02x &quot;
comma
id|args-&gt;hobRegister
(braket
id|IDE_SELECT_OFFSET_HOB
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;HTF.7=x%02x&bslash;n&quot;
comma
id|args-&gt;hobRegister
(braket
id|IDE_CONTROL_OFFSET_HOB
)braket
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_IDE_TASK_IOCTL_DEBUG */
)brace
DECL|function|do_rw_taskfile
id|ide_startstop_t
id|do_rw_taskfile
(paren
id|ide_drive_t
op_star
id|drive
comma
id|ide_task_t
op_star
id|task
)paren
(brace
id|task_struct_t
op_star
id|taskfile
op_assign
(paren
id|task_struct_t
op_star
)paren
id|task-&gt;tfRegister
suffix:semicolon
id|hob_struct_t
op_star
id|hobfile
op_assign
(paren
id|hob_struct_t
op_star
)paren
id|task-&gt;hobRegister
suffix:semicolon
r_struct
id|hd_driveid
op_star
id|id
op_assign
id|drive-&gt;id
suffix:semicolon
id|byte
id|HIHI
op_assign
(paren
id|drive-&gt;addressing
op_eq
l_int|1
)paren
ques
c_cond
l_int|0xE0
suffix:colon
l_int|0xEF
suffix:semicolon
macro_line|#ifdef CONFIG_IDE_TASK_IOCTL_DEBUG
r_void
id|debug_taskfile
c_func
(paren
id|drive
comma
id|task
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_IDE_TASK_IOCTL_DEBUG */
multiline_comment|/* ALL Command Block Executions SHALL clear nIEN, unless otherwise */
r_if
c_cond
(paren
id|IDE_CONTROL_REG
)paren
id|OUT_BYTE
c_func
(paren
id|drive-&gt;ctl
comma
id|IDE_CONTROL_REG
)paren
suffix:semicolon
multiline_comment|/* clear nIEN */
id|SELECT_MASK
c_func
(paren
id|HWIF
c_func
(paren
id|drive
)paren
comma
id|drive
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|id-&gt;command_set_2
op_amp
l_int|0x0400
)paren
op_logical_and
(paren
id|id-&gt;cfs_enable_2
op_amp
l_int|0x0400
)paren
op_logical_and
(paren
id|drive-&gt;addressing
op_eq
l_int|1
)paren
)paren
(brace
id|OUT_BYTE
c_func
(paren
id|hobfile-&gt;feature
comma
id|IDE_FEATURE_REG
)paren
suffix:semicolon
id|OUT_BYTE
c_func
(paren
id|hobfile-&gt;sector_count
comma
id|IDE_NSECTOR_REG
)paren
suffix:semicolon
id|OUT_BYTE
c_func
(paren
id|hobfile-&gt;sector_number
comma
id|IDE_SECTOR_REG
)paren
suffix:semicolon
id|OUT_BYTE
c_func
(paren
id|hobfile-&gt;low_cylinder
comma
id|IDE_LCYL_REG
)paren
suffix:semicolon
id|OUT_BYTE
c_func
(paren
id|hobfile-&gt;high_cylinder
comma
id|IDE_HCYL_REG
)paren
suffix:semicolon
)brace
id|OUT_BYTE
c_func
(paren
id|taskfile-&gt;feature
comma
id|IDE_FEATURE_REG
)paren
suffix:semicolon
id|OUT_BYTE
c_func
(paren
id|taskfile-&gt;sector_count
comma
id|IDE_NSECTOR_REG
)paren
suffix:semicolon
multiline_comment|/* refers to number of sectors to transfer */
id|OUT_BYTE
c_func
(paren
id|taskfile-&gt;sector_number
comma
id|IDE_SECTOR_REG
)paren
suffix:semicolon
multiline_comment|/* refers to sector offset or start sector */
id|OUT_BYTE
c_func
(paren
id|taskfile-&gt;low_cylinder
comma
id|IDE_LCYL_REG
)paren
suffix:semicolon
id|OUT_BYTE
c_func
(paren
id|taskfile-&gt;high_cylinder
comma
id|IDE_HCYL_REG
)paren
suffix:semicolon
id|OUT_BYTE
c_func
(paren
(paren
id|taskfile-&gt;device_head
op_amp
id|HIHI
)paren
op_or
id|drive-&gt;select.all
comma
id|IDE_SELECT_REG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|task-&gt;handler
op_ne
l_int|NULL
)paren
(brace
id|ide_set_handler
(paren
id|drive
comma
id|task-&gt;handler
comma
id|WAIT_CMD
comma
l_int|NULL
)paren
suffix:semicolon
id|OUT_BYTE
c_func
(paren
id|taskfile-&gt;command
comma
id|IDE_COMMAND_REG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|task-&gt;prehandler
op_ne
l_int|NULL
)paren
r_return
id|task
op_member_access_from_pointer
id|prehandler
c_func
(paren
id|drive
comma
id|task-&gt;rq
)paren
suffix:semicolon
r_return
id|ide_started
suffix:semicolon
)brace
macro_line|#if 0
r_switch
c_cond
(paren
id|task-&gt;data_phase
)paren
(brace
macro_line|#ifdef CONFIG_BLK_DEV_IDEDMA
r_case
id|TASKFILE_OUT_DMAQ
suffix:colon
r_case
id|TASKFILE_OUT_DMA
suffix:colon
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|dmaproc
c_func
(paren
id|ide_dma_write
comma
id|drive
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TASKFILE_IN_DMAQ
suffix:colon
r_case
id|TASKFILE_IN_DMA
suffix:colon
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|dmaproc
c_func
(paren
id|ide_dma_read
comma
id|drive
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif /* CONFIG_BLK_DEV_IDEDMA */
r_default
suffix:colon
(brace
)brace
r_if
c_cond
(paren
id|task-&gt;handler
op_eq
l_int|NULL
)paren
r_return
id|ide_stopped
suffix:semicolon
id|ide_set_handler
(paren
id|drive
comma
id|task-&gt;handler
comma
id|WAIT_WORSTCASE
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* Issue the command */
id|OUT_BYTE
c_func
(paren
id|taskfile-&gt;command
comma
id|IDE_COMMAND_REG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|task-&gt;prehandler
op_ne
l_int|NULL
)paren
r_return
id|task
op_member_access_from_pointer
id|prehandler
c_func
(paren
id|drive
comma
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
)paren
suffix:semicolon
)brace
macro_line|#else
singleline_comment|//&t;if ((rq-&gt;cmd == WRITE) &amp;&amp; (drive-&gt;using_dma))
multiline_comment|/* for dma commands we down set the handler */
r_if
c_cond
(paren
id|drive-&gt;using_dma
op_logical_and
op_logical_neg
(paren
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|dmaproc
c_func
(paren
(paren
(paren
id|taskfile-&gt;command
op_eq
id|WIN_WRITEDMA
)paren
op_logical_or
(paren
id|taskfile-&gt;command
op_eq
id|WIN_WRITEDMA_EXT
)paren
)paren
ques
c_cond
id|ide_dma_write
suffix:colon
id|ide_dma_read
comma
id|drive
)paren
)paren
)paren
suffix:semicolon
macro_line|#endif
r_return
id|ide_started
suffix:semicolon
)brace
macro_line|#if 0
multiline_comment|/*&n; * Error reporting, in human readable form (luxurious, but a memory hog).&n; */
id|byte
id|taskfile_dump_status
(paren
id|ide_drive_t
op_star
id|drive
comma
r_const
r_char
op_star
id|msg
comma
id|byte
id|stat
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|byte
id|err
op_assign
l_int|0
suffix:semicolon
id|local_irq_set
c_func
(paren
id|flags
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: %s: status=0x%02x&quot;
comma
id|drive-&gt;name
comma
id|msg
comma
id|stat
)paren
suffix:semicolon
macro_line|#if FANCY_STATUS_DUMPS
id|printk
c_func
(paren
l_string|&quot; { &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_amp
id|BUSY_STAT
)paren
id|printk
c_func
(paren
l_string|&quot;Busy &quot;
)paren
suffix:semicolon
r_else
(brace
r_if
c_cond
(paren
id|stat
op_amp
id|READY_STAT
)paren
id|printk
c_func
(paren
l_string|&quot;DriveReady &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_amp
id|WRERR_STAT
)paren
id|printk
c_func
(paren
l_string|&quot;DeviceFault &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_amp
id|SEEK_STAT
)paren
id|printk
c_func
(paren
l_string|&quot;SeekComplete &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_amp
id|DRQ_STAT
)paren
id|printk
c_func
(paren
l_string|&quot;DataRequest &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_amp
id|ECC_STAT
)paren
id|printk
c_func
(paren
l_string|&quot;CorrectedError &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_amp
id|INDEX_STAT
)paren
id|printk
c_func
(paren
l_string|&quot;Index &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_amp
id|ERR_STAT
)paren
id|printk
c_func
(paren
l_string|&quot;Error &quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;}&quot;
)paren
suffix:semicolon
macro_line|#endif  /* FANCY_STATUS_DUMPS */
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|stat
op_amp
(paren
id|BUSY_STAT
op_or
id|ERR_STAT
)paren
)paren
op_eq
id|ERR_STAT
)paren
(brace
id|err
op_assign
id|GET_ERR
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: %s: error=0x%02x&quot;
comma
id|drive-&gt;name
comma
id|msg
comma
id|err
)paren
suffix:semicolon
macro_line|#if FANCY_STATUS_DUMPS
r_if
c_cond
(paren
id|drive-&gt;media
op_eq
id|ide_disk
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; { &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_amp
id|ABRT_ERR
)paren
id|printk
c_func
(paren
l_string|&quot;DriveStatusError &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_amp
id|ICRC_ERR
)paren
id|printk
c_func
(paren
l_string|&quot;%s&quot;
comma
(paren
id|err
op_amp
id|ABRT_ERR
)paren
ques
c_cond
l_string|&quot;BadCRC &quot;
suffix:colon
l_string|&quot;BadSector &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_amp
id|ECC_ERR
)paren
id|printk
c_func
(paren
l_string|&quot;UncorrectableError &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_amp
id|ID_ERR
)paren
id|printk
c_func
(paren
l_string|&quot;SectorIdNotFound &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_amp
id|TRK0_ERR
)paren
id|printk
c_func
(paren
l_string|&quot;TrackZeroNotFound &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_amp
id|MARK_ERR
)paren
id|printk
c_func
(paren
l_string|&quot;AddrMarkNotFound &quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;}&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_amp
(paren
id|BBD_ERR
op_or
id|ABRT_ERR
)paren
)paren
op_eq
id|BBD_ERR
op_logical_or
(paren
id|err
op_amp
(paren
id|ECC_ERR
op_or
id|ID_ERR
op_or
id|MARK_ERR
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|drive-&gt;id-&gt;command_set_2
op_amp
l_int|0x0400
)paren
op_logical_and
(paren
id|drive-&gt;id-&gt;cfs_enable_2
op_amp
l_int|0x0400
)paren
op_logical_and
(paren
id|drive-&gt;addressing
op_eq
l_int|1
)paren
)paren
(brace
id|__u64
id|sectors
op_assign
l_int|0
suffix:semicolon
id|u32
id|low
op_assign
l_int|0
comma
id|high
op_assign
l_int|0
suffix:semicolon
id|low
op_assign
id|task_read_24
c_func
(paren
id|drive
)paren
suffix:semicolon
id|OUT_BYTE
c_func
(paren
l_int|0x80
comma
id|IDE_CONTROL_REG
)paren
suffix:semicolon
id|high
op_assign
id|task_read_24
c_func
(paren
id|drive
)paren
suffix:semicolon
id|sectors
op_assign
(paren
(paren
id|__u64
)paren
id|high
op_lshift
l_int|24
)paren
op_or
id|low
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;, LBAsect=%lld&quot;
comma
id|sectors
)paren
suffix:semicolon
)brace
r_else
(brace
id|byte
id|cur
op_assign
id|IN_BYTE
c_func
(paren
id|IDE_SELECT_REG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cur
op_amp
l_int|0x40
)paren
(brace
multiline_comment|/* using LBA? */
id|printk
c_func
(paren
l_string|&quot;, LBAsect=%ld&quot;
comma
(paren
r_int
r_int
)paren
(paren
(paren
id|cur
op_amp
l_int|0xf
)paren
op_lshift
l_int|24
)paren
op_or
(paren
id|IN_BYTE
c_func
(paren
id|IDE_HCYL_REG
)paren
op_lshift
l_int|16
)paren
op_or
(paren
id|IN_BYTE
c_func
(paren
id|IDE_LCYL_REG
)paren
op_lshift
l_int|8
)paren
op_or
id|IN_BYTE
c_func
(paren
id|IDE_SECTOR_REG
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;, CHS=%d/%d/%d&quot;
comma
(paren
id|IN_BYTE
c_func
(paren
id|IDE_HCYL_REG
)paren
op_lshift
l_int|8
)paren
op_plus
id|IN_BYTE
c_func
(paren
id|IDE_LCYL_REG
)paren
comma
id|cur
op_amp
l_int|0xf
comma
id|IN_BYTE
c_func
(paren
id|IDE_SECTOR_REG
)paren
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
)paren
id|printk
c_func
(paren
l_string|&quot;, sector=%lu&quot;
comma
(paren
id|__u64
)paren
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq-&gt;sector
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif  /* FANCY_STATUS_DUMPS */
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|local_irq_restore
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n; * Clean up after success/failure of an explicit taskfile operation.&n; */
DECL|function|ide_end_taskfile
r_void
id|ide_end_taskfile
(paren
id|ide_drive_t
op_star
id|drive
comma
id|byte
id|stat
comma
id|byte
id|err
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|request
op_star
id|rq
suffix:semicolon
id|ide_task_t
op_star
id|args
suffix:semicolon
id|task_ioreg_t
id|command
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ide_lock
comma
id|flags
)paren
suffix:semicolon
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ide_lock
comma
id|flags
)paren
suffix:semicolon
id|args
op_assign
(paren
id|ide_task_t
op_star
)paren
id|rq-&gt;special
suffix:semicolon
id|command
op_assign
id|args-&gt;tfRegister
(braket
id|IDE_COMMAND_OFFSET
)braket
suffix:semicolon
r_if
c_cond
(paren
id|rq-&gt;errors
op_eq
l_int|0
)paren
id|rq-&gt;errors
op_assign
op_logical_neg
id|OK_STAT
c_func
(paren
id|stat
comma
id|READY_STAT
comma
id|BAD_STAT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|args-&gt;tf_in_flags.b.data
)paren
(brace
r_int
r_int
id|data
op_assign
id|IN_WORD
c_func
(paren
id|IDE_DATA_REG
)paren
suffix:semicolon
id|args-&gt;tfRegister
(braket
id|IDE_DATA_OFFSET
)braket
op_assign
(paren
id|data
)paren
op_amp
l_int|0xFF
suffix:semicolon
id|args-&gt;hobRegister
(braket
id|IDE_DATA_OFFSET_HOB
)braket
op_assign
(paren
id|data
op_rshift
l_int|8
)paren
op_amp
l_int|0xFF
suffix:semicolon
)brace
id|args-&gt;tfRegister
(braket
id|IDE_ERROR_OFFSET
)braket
op_assign
id|err
suffix:semicolon
id|args-&gt;tfRegister
(braket
id|IDE_NSECTOR_OFFSET
)braket
op_assign
id|IN_BYTE
c_func
(paren
id|IDE_NSECTOR_REG
)paren
suffix:semicolon
id|args-&gt;tfRegister
(braket
id|IDE_SECTOR_OFFSET
)braket
op_assign
id|IN_BYTE
c_func
(paren
id|IDE_SECTOR_REG
)paren
suffix:semicolon
id|args-&gt;tfRegister
(braket
id|IDE_LCYL_OFFSET
)braket
op_assign
id|IN_BYTE
c_func
(paren
id|IDE_LCYL_REG
)paren
suffix:semicolon
id|args-&gt;tfRegister
(braket
id|IDE_HCYL_OFFSET
)braket
op_assign
id|IN_BYTE
c_func
(paren
id|IDE_HCYL_REG
)paren
suffix:semicolon
id|args-&gt;tfRegister
(braket
id|IDE_SELECT_OFFSET
)braket
op_assign
id|IN_BYTE
c_func
(paren
id|IDE_SELECT_REG
)paren
suffix:semicolon
id|args-&gt;tfRegister
(braket
id|IDE_STATUS_OFFSET
)braket
op_assign
id|stat
suffix:semicolon
r_if
c_cond
(paren
(paren
id|drive-&gt;id-&gt;command_set_2
op_amp
l_int|0x0400
)paren
op_logical_and
(paren
id|drive-&gt;id-&gt;cfs_enable_2
op_amp
l_int|0x0400
)paren
op_logical_and
(paren
id|drive-&gt;addressing
op_eq
l_int|1
)paren
)paren
(brace
id|OUT_BYTE
c_func
(paren
id|drive-&gt;ctl
op_or
l_int|0x80
comma
id|IDE_CONTROL_REG_HOB
)paren
suffix:semicolon
id|args-&gt;hobRegister
(braket
id|IDE_FEATURE_OFFSET_HOB
)braket
op_assign
id|IN_BYTE
c_func
(paren
id|IDE_FEATURE_REG
)paren
suffix:semicolon
id|args-&gt;hobRegister
(braket
id|IDE_NSECTOR_OFFSET_HOB
)braket
op_assign
id|IN_BYTE
c_func
(paren
id|IDE_NSECTOR_REG
)paren
suffix:semicolon
id|args-&gt;hobRegister
(braket
id|IDE_SECTOR_OFFSET_HOB
)braket
op_assign
id|IN_BYTE
c_func
(paren
id|IDE_SECTOR_REG
)paren
suffix:semicolon
id|args-&gt;hobRegister
(braket
id|IDE_LCYL_OFFSET_HOB
)braket
op_assign
id|IN_BYTE
c_func
(paren
id|IDE_LCYL_REG
)paren
suffix:semicolon
id|args-&gt;hobRegister
(braket
id|IDE_HCYL_OFFSET_HOB
)braket
op_assign
id|IN_BYTE
c_func
(paren
id|IDE_HCYL_REG
)paren
suffix:semicolon
)brace
macro_line|#if 0
multiline_comment|/*&t;taskfile_settings_update(drive, args, command); */
r_if
c_cond
(paren
id|args-&gt;posthandler
op_ne
l_int|NULL
)paren
id|args
op_member_access_from_pointer
id|posthandler
c_func
(paren
id|drive
comma
id|args
)paren
suffix:semicolon
macro_line|#endif
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ide_lock
comma
id|flags
)paren
suffix:semicolon
id|blkdev_dequeue_request
c_func
(paren
id|rq
)paren
suffix:semicolon
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
op_assign
l_int|NULL
suffix:semicolon
id|end_that_request_last
c_func
(paren
id|rq
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ide_lock
comma
id|flags
)paren
suffix:semicolon
)brace
macro_line|#if 0
multiline_comment|/*&n; * try_to_flush_leftover_data() is invoked in response to a drive&n; * unexpectedly having its DRQ_STAT bit set.  As an alternative to&n; * resetting the drive, this routine tries to clear the condition&n; * by read a sector&squot;s worth of data from the drive.  Of course,&n; * this may not help if the drive is *waiting* for data from *us*.&n; */
r_void
id|task_try_to_flush_leftover_data
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_int
id|i
op_assign
(paren
id|drive-&gt;mult_count
ques
c_cond
id|drive-&gt;mult_count
suffix:colon
l_int|1
)paren
op_star
id|SECTOR_WORDS
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;media
op_ne
id|ide_disk
)paren
r_return
suffix:semicolon
r_while
c_loop
(paren
id|i
OG
l_int|0
)paren
(brace
id|u32
id|buffer
(braket
l_int|16
)braket
suffix:semicolon
r_int
r_int
id|wcount
op_assign
(paren
id|i
OG
l_int|16
)paren
ques
c_cond
l_int|16
suffix:colon
id|i
suffix:semicolon
id|i
op_sub_assign
id|wcount
suffix:semicolon
id|taskfile_input_data
(paren
id|drive
comma
id|buffer
comma
id|wcount
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * taskfile_error() takes action based on the error returned by the drive.&n; */
id|ide_startstop_t
id|taskfile_error
(paren
id|ide_drive_t
op_star
id|drive
comma
r_const
r_char
op_star
id|msg
comma
id|byte
id|stat
)paren
(brace
r_struct
id|request
op_star
id|rq
suffix:semicolon
id|byte
id|err
suffix:semicolon
id|err
op_assign
id|taskfile_dump_status
c_func
(paren
id|drive
comma
id|msg
comma
id|stat
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drive
op_eq
l_int|NULL
op_logical_or
(paren
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
)paren
op_eq
l_int|NULL
)paren
r_return
id|ide_stopped
suffix:semicolon
multiline_comment|/* retry only &quot;normal&quot; I/O: */
r_if
c_cond
(paren
id|rq-&gt;cmd
op_eq
id|IDE_DRIVE_TASKFILE
)paren
(brace
id|rq-&gt;errors
op_assign
l_int|1
suffix:semicolon
id|ide_end_taskfile
c_func
(paren
id|drive
comma
id|stat
comma
id|err
)paren
suffix:semicolon
r_return
id|ide_stopped
suffix:semicolon
)brace
r_if
c_cond
(paren
id|stat
op_amp
id|BUSY_STAT
op_logical_or
(paren
(paren
id|stat
op_amp
id|WRERR_STAT
)paren
op_logical_and
op_logical_neg
id|drive-&gt;nowerr
)paren
)paren
(brace
multiline_comment|/* other bits are useless when BUSY */
id|rq-&gt;errors
op_or_assign
id|ERROR_RESET
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|drive-&gt;media
op_eq
id|ide_disk
op_logical_and
(paren
id|stat
op_amp
id|ERR_STAT
)paren
)paren
(brace
multiline_comment|/* err has different meaning on cdrom and tape */
r_if
c_cond
(paren
id|err
op_eq
id|ABRT_ERR
)paren
(brace
r_if
c_cond
(paren
id|drive-&gt;select.b.lba
op_logical_and
id|IN_BYTE
c_func
(paren
id|IDE_COMMAND_REG
)paren
op_eq
id|WIN_SPECIFY
)paren
r_return
id|ide_stopped
suffix:semicolon
multiline_comment|/* some newer drives don&squot;t support WIN_SPECIFY */
)brace
r_else
r_if
c_cond
(paren
(paren
id|err
op_amp
(paren
id|ABRT_ERR
op_or
id|ICRC_ERR
)paren
)paren
op_eq
(paren
id|ABRT_ERR
op_or
id|ICRC_ERR
)paren
)paren
(brace
id|drive-&gt;crc_count
op_increment
suffix:semicolon
multiline_comment|/* UDMA crc error -- just retry the operation */
)brace
r_else
r_if
c_cond
(paren
id|err
op_amp
(paren
id|BBD_ERR
op_or
id|ECC_ERR
)paren
)paren
multiline_comment|/* retries won&squot;t help these */
id|rq-&gt;errors
op_assign
id|ERROR_MAX
suffix:semicolon
r_else
r_if
c_cond
(paren
id|err
op_amp
id|TRK0_ERR
)paren
multiline_comment|/* help it find track zero */
id|rq-&gt;errors
op_or_assign
id|ERROR_RECAL
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|stat
op_amp
id|DRQ_STAT
)paren
op_logical_and
id|rq-&gt;cmd
op_ne
id|WRITE
)paren
id|task_try_to_flush_leftover_data
c_func
(paren
id|drive
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|GET_STAT
c_func
(paren
)paren
op_amp
(paren
id|BUSY_STAT
op_or
id|DRQ_STAT
)paren
)paren
id|OUT_BYTE
c_func
(paren
id|WIN_IDLEIMMEDIATE
comma
id|IDE_COMMAND_REG
)paren
suffix:semicolon
multiline_comment|/* force an abort */
r_if
c_cond
(paren
id|rq-&gt;errors
op_ge
id|ERROR_MAX
)paren
(brace
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|end_request
c_func
(paren
id|drive
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
(paren
id|rq-&gt;errors
op_amp
id|ERROR_RESET
)paren
op_eq
id|ERROR_RESET
)paren
(brace
op_increment
id|rq-&gt;errors
suffix:semicolon
r_return
id|ide_do_reset
c_func
(paren
id|drive
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|rq-&gt;errors
op_amp
id|ERROR_RECAL
)paren
op_eq
id|ERROR_RECAL
)paren
id|drive-&gt;special.b.recalibrate
op_assign
l_int|1
suffix:semicolon
op_increment
id|rq-&gt;errors
suffix:semicolon
)brace
r_return
id|ide_stopped
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n; * Handler for special commands without a data phase from ide-disk&n; */
multiline_comment|/*&n; * set_multmode_intr() is invoked on completion of a WIN_SETMULT cmd.&n; */
DECL|function|set_multmode_intr
id|ide_startstop_t
id|set_multmode_intr
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|byte
id|stat
suffix:semicolon
r_if
c_cond
(paren
id|OK_STAT
c_func
(paren
id|stat
op_assign
id|GET_STAT
c_func
(paren
)paren
comma
id|READY_STAT
comma
id|BAD_STAT
)paren
)paren
(brace
id|drive-&gt;mult_count
op_assign
id|drive-&gt;mult_req
suffix:semicolon
)brace
r_else
(brace
id|drive-&gt;mult_req
op_assign
id|drive-&gt;mult_count
op_assign
l_int|0
suffix:semicolon
id|drive-&gt;special.b.recalibrate
op_assign
l_int|1
suffix:semicolon
(paren
r_void
)paren
id|ide_dump_status
c_func
(paren
id|drive
comma
l_string|&quot;set_multmode&quot;
comma
id|stat
)paren
suffix:semicolon
)brace
r_return
id|ide_stopped
suffix:semicolon
)brace
multiline_comment|/*&n; * set_geometry_intr() is invoked on completion of a WIN_SPECIFY cmd.&n; */
DECL|function|set_geometry_intr
id|ide_startstop_t
id|set_geometry_intr
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_int
id|retries
op_assign
l_int|5
suffix:semicolon
id|byte
id|stat
suffix:semicolon
r_while
c_loop
(paren
(paren
(paren
id|stat
op_assign
id|GET_STAT
c_func
(paren
)paren
)paren
op_amp
id|BUSY_STAT
)paren
op_logical_and
id|retries
op_decrement
)paren
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
r_if
c_cond
(paren
id|OK_STAT
c_func
(paren
id|stat
comma
id|READY_STAT
comma
id|BAD_STAT
)paren
)paren
r_return
id|ide_stopped
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_amp
(paren
id|ERR_STAT
op_or
id|DRQ_STAT
)paren
)paren
r_return
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|error
c_func
(paren
id|drive
comma
l_string|&quot;set_geometry_intr&quot;
comma
id|stat
)paren
suffix:semicolon
r_if
c_cond
(paren
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|handler
op_ne
l_int|NULL
)paren
multiline_comment|/* paranoia check */
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|ide_set_handler
c_func
(paren
id|drive
comma
op_amp
id|set_geometry_intr
comma
id|WAIT_CMD
comma
l_int|NULL
)paren
suffix:semicolon
r_return
id|ide_started
suffix:semicolon
)brace
multiline_comment|/*&n; * recal_intr() is invoked on completion of a WIN_RESTORE (recalibrate) cmd.&n; */
DECL|function|recal_intr
id|ide_startstop_t
id|recal_intr
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|byte
id|stat
op_assign
id|GET_STAT
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|OK_STAT
c_func
(paren
id|stat
comma
id|READY_STAT
comma
id|BAD_STAT
)paren
)paren
r_return
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|error
c_func
(paren
id|drive
comma
l_string|&quot;recal_intr&quot;
comma
id|stat
)paren
suffix:semicolon
r_return
id|ide_stopped
suffix:semicolon
)brace
multiline_comment|/*&n; * Handler for commands without a data phase&n; */
DECL|function|task_no_data_intr
id|ide_startstop_t
id|task_no_data_intr
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|ide_task_t
op_star
id|args
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq-&gt;special
suffix:semicolon
id|byte
id|stat
op_assign
id|GET_STAT
c_func
(paren
)paren
suffix:semicolon
id|local_irq_enable
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|OK_STAT
c_func
(paren
id|stat
comma
id|READY_STAT
comma
id|BAD_STAT
)paren
)paren
(brace
id|DTF
c_func
(paren
l_string|&quot;%s: command opcode 0x%02x&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|args-&gt;tfRegister
(braket
id|IDE_COMMAND_OFFSET
)braket
)paren
suffix:semicolon
r_return
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|error
c_func
(paren
id|drive
comma
l_string|&quot;task_no_data_intr&quot;
comma
id|stat
)paren
suffix:semicolon
multiline_comment|/* calls ide_end_drive_cmd */
)brace
r_if
c_cond
(paren
id|args
)paren
id|ide_end_drive_cmd
(paren
id|drive
comma
id|stat
comma
id|GET_ERR
c_func
(paren
)paren
)paren
suffix:semicolon
r_return
id|ide_stopped
suffix:semicolon
)brace
multiline_comment|/*&n; * Handler for command with PIO data-in phase, READ&n; */
multiline_comment|/*&n; * FIXME before 2.4 enable ...&n; *&t;DATA integrity issue upon error. &lt;andre@linux-ide.org&gt;&n; */
DECL|function|task_in_intr
id|ide_startstop_t
id|task_in_intr
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|byte
id|stat
op_assign
id|GET_STAT
c_func
(paren
)paren
suffix:semicolon
r_struct
id|request
op_star
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
r_char
op_star
id|pBuf
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|OK_STAT
c_func
(paren
id|stat
comma
id|DATA_READY
comma
id|BAD_R_STAT
)paren
)paren
(brace
r_if
c_cond
(paren
id|stat
op_amp
(paren
id|ERR_STAT
op_or
id|DRQ_STAT
)paren
)paren
(brace
macro_line|#if 0
id|DTF
c_func
(paren
l_string|&quot;%s: attempting to recover last &quot;
"&bslash;"
l_string|&quot;sector counter status=0x%02x&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|stat
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Expect a BUG BOMB if we attempt to rewind the&n;&t;&t;&t; * offset in the BH aka PAGE in the current BLOCK&n;&t;&t;&t; * segment.  This is different than the HOST segment.&n;&t;&t;&t; */
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|rq-&gt;bio
)paren
id|rq-&gt;current_nr_sectors
op_increment
suffix:semicolon
r_return
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|error
c_func
(paren
id|drive
comma
l_string|&quot;task_in_intr&quot;
comma
id|stat
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|stat
op_amp
id|BUSY_STAT
)paren
)paren
(brace
id|DTF
c_func
(paren
l_string|&quot;task_in_intr to Soon wait for next interrupt&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|handler
op_eq
l_int|NULL
)paren
id|ide_set_handler
c_func
(paren
id|drive
comma
op_amp
id|task_in_intr
comma
id|WAIT_CMD
comma
l_int|NULL
)paren
suffix:semicolon
r_return
id|ide_started
suffix:semicolon
)brace
)brace
macro_line|#if 0
multiline_comment|/*&n;&t; * Holding point for a brain dump of a thought :-/&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|OK_STAT
c_func
(paren
id|stat
comma
id|DRIVE_READY
comma
id|drive-&gt;bad_wstat
)paren
)paren
(brace
id|DTF
c_func
(paren
l_string|&quot;%s: READ attempting to recover last &quot;
"&bslash;"
l_string|&quot;sector counter status=0x%02x&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|stat
)paren
suffix:semicolon
id|rq-&gt;current_nr_sectors
op_increment
suffix:semicolon
r_return
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|error
c_func
(paren
id|drive
comma
l_string|&quot;task_in_intr&quot;
comma
id|stat
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|rq-&gt;current_nr_sectors
)paren
r_if
c_cond
(paren
op_logical_neg
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|end_request
c_func
(paren
id|drive
comma
l_int|1
)paren
)paren
r_return
id|ide_stopped
suffix:semicolon
r_if
c_cond
(paren
op_decrement
id|rq-&gt;current_nr_sectors
op_le
l_int|0
)paren
r_if
c_cond
(paren
op_logical_neg
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|end_request
c_func
(paren
id|drive
comma
l_int|1
)paren
)paren
r_return
id|ide_stopped
suffix:semicolon
macro_line|#endif
id|pBuf
op_assign
id|task_map_rq
c_func
(paren
id|rq
comma
op_amp
id|flags
)paren
suffix:semicolon
id|DTF
c_func
(paren
l_string|&quot;Read: %p, rq-&gt;current_nr_sectors: %d, stat: %02x&bslash;n&quot;
comma
id|pBuf
comma
(paren
r_int
)paren
id|rq-&gt;current_nr_sectors
comma
id|stat
)paren
suffix:semicolon
id|taskfile_input_data
c_func
(paren
id|drive
comma
id|pBuf
comma
id|SECTOR_WORDS
)paren
suffix:semicolon
id|task_unmap_rq
c_func
(paren
id|rq
comma
id|pBuf
comma
op_amp
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * FIXME :: We really can not legally get a new page/bh&n;&t; * regardless, if this is the end of our segment.&n;&t; * BH walking or segment can only be updated after we have a good&n;&t; * GET_STAT(); return.&n;&t; */
r_if
c_cond
(paren
op_decrement
id|rq-&gt;current_nr_sectors
op_le
l_int|0
)paren
r_if
c_cond
(paren
op_logical_neg
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|end_request
c_func
(paren
id|drive
comma
l_int|1
)paren
)paren
r_return
id|ide_stopped
suffix:semicolon
multiline_comment|/*&n;&t; * ERM, it is techincally legal to leave/exit here but it makes&n;&t; * a mess of the code ...&n;&t; */
r_if
c_cond
(paren
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|handler
op_eq
l_int|NULL
)paren
id|ide_set_handler
c_func
(paren
id|drive
comma
op_amp
id|task_in_intr
comma
id|WAIT_CMD
comma
l_int|NULL
)paren
suffix:semicolon
r_return
id|ide_started
suffix:semicolon
)brace
DECL|macro|ALTSTAT_SCREW_UP
macro_line|#undef ALTSTAT_SCREW_UP
macro_line|#ifdef ALTSTAT_SCREW_UP
multiline_comment|/*&n; * (ks/hs): Poll Alternate Status Register to ensure&n; * that drive is not busy.&n; */
DECL|function|altstat_multi_busy
id|byte
id|altstat_multi_busy
(paren
id|ide_drive_t
op_star
id|drive
comma
id|byte
id|stat
comma
r_const
r_char
op_star
id|msg
)paren
(brace
r_int
id|i
suffix:semicolon
id|DTF
c_func
(paren
l_string|&quot;multi%s: ASR = %x&bslash;n&quot;
comma
id|msg
comma
id|stat
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_amp
id|BUSY_STAT
)paren
(brace
multiline_comment|/* (ks/hs): FIXME: Replace hard-coded 100, error handling? */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|100
suffix:semicolon
id|i
op_increment
)paren
(brace
id|stat
op_assign
id|GET_ALTSTAT
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|stat
op_amp
id|BUSY_STAT
)paren
op_eq
l_int|0
)paren
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * (ks/hs): Read Status AFTER Alternate Status Register&n;&t; */
r_return
id|GET_STAT
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * (ks/hs): Poll Alternate status register to wait for drive&n; * to become ready for next transfer&n; */
DECL|function|altstat_multi_poll
id|byte
id|altstat_multi_poll
(paren
id|ide_drive_t
op_star
id|drive
comma
id|byte
id|stat
comma
r_const
r_char
op_star
id|msg
)paren
(brace
multiline_comment|/* (ks/hs): FIXME: Error handling, time-out? */
r_while
c_loop
(paren
id|stat
op_amp
id|BUSY_STAT
)paren
id|stat
op_assign
id|GET_ALTSTAT
c_func
(paren
)paren
suffix:semicolon
id|DTF
c_func
(paren
l_string|&quot;multi%s: nsect=1, ASR = %x&bslash;n&quot;
comma
id|msg
comma
id|stat
)paren
suffix:semicolon
r_return
id|GET_STAT
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* (ks/hs): Clear pending IRQ */
)brace
macro_line|#endif /* ALTSTAT_SCREW_UP */
multiline_comment|/*&n; * Handler for command with Read Multiple&n; */
DECL|function|task_mulin_intr
id|ide_startstop_t
id|task_mulin_intr
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
macro_line|#ifdef ALTSTAT_SCREW_UP
id|byte
id|stat
op_assign
id|altstat_multi_busy
c_func
(paren
id|drive
comma
id|GET_ALTSTAT
c_func
(paren
)paren
comma
l_string|&quot;read&quot;
)paren
suffix:semicolon
macro_line|#else
id|byte
id|stat
op_assign
id|GET_STAT
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif /* ALTSTAT_SCREW_UP */
r_struct
id|request
op_star
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
r_char
op_star
id|pBuf
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|msect
op_assign
id|drive-&gt;mult_count
suffix:semicolon
r_int
r_int
id|nsect
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|OK_STAT
c_func
(paren
id|stat
comma
id|DATA_READY
comma
id|BAD_R_STAT
)paren
)paren
(brace
r_if
c_cond
(paren
id|stat
op_amp
(paren
id|ERR_STAT
op_or
id|DRQ_STAT
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|rq-&gt;bio
)paren
(brace
id|rq-&gt;current_nr_sectors
op_add_assign
id|drive-&gt;mult_count
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * NOTE: could rewind beyond beginning :-/&n;&t;&t;&t;&t; */
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;%s: MULTI-READ assume all data &quot;
"&bslash;"
l_string|&quot;transfered is bad status=0x%02x&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|stat
)paren
suffix:semicolon
)brace
r_return
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|error
c_func
(paren
id|drive
comma
l_string|&quot;task_mulin_intr&quot;
comma
id|stat
)paren
suffix:semicolon
)brace
multiline_comment|/* no data yet, so wait for another interrupt */
r_if
c_cond
(paren
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|handler
op_eq
l_int|NULL
)paren
id|ide_set_handler
c_func
(paren
id|drive
comma
op_amp
id|task_mulin_intr
comma
id|WAIT_CMD
comma
l_int|NULL
)paren
suffix:semicolon
r_return
id|ide_started
suffix:semicolon
)brace
macro_line|#ifdef ALTSTAT_SCREW_UP
multiline_comment|/*&n;&t; * Screw the request we do not support bad data-phase setups!&n;&t; * Either read and learn the ATA standard or crash yourself!&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|msect
)paren
(brace
multiline_comment|/*&n;&t;&t; * (ks/hs): Drive supports multi-sector transfer,&n;&t;&t; * drive-&gt;mult_count was not set&n;&t;&t; */
id|nsect
op_assign
l_int|1
suffix:semicolon
r_while
c_loop
(paren
id|rq-&gt;current_nr_sectors
)paren
(brace
id|pBuf
op_assign
id|task_map_rq
c_func
(paren
id|rq
comma
op_amp
id|flags
)paren
suffix:semicolon
id|DTF
c_func
(paren
l_string|&quot;Multiread: %p, nsect: %d, &quot;
"&bslash;"
l_string|&quot;rq-&gt;current_nr_sectors: %ld&bslash;n&quot;
comma
id|pBuf
comma
id|nsect
comma
id|rq-&gt;current_nr_sectors
)paren
suffix:semicolon
singleline_comment|//&t;&t;&t;rq-&gt;current_nr_sectors -= nsect;
id|taskfile_input_data
c_func
(paren
id|drive
comma
id|pBuf
comma
id|nsect
op_star
id|SECTOR_WORDS
)paren
suffix:semicolon
id|task_unmap_rq
c_func
(paren
id|rq
comma
id|pBuf
comma
op_amp
id|flags
)paren
suffix:semicolon
id|rq-&gt;errors
op_assign
l_int|0
suffix:semicolon
id|rq-&gt;current_nr_sectors
op_sub_assign
id|nsect
suffix:semicolon
id|stat
op_assign
id|altstat_multi_poll
c_func
(paren
id|drive
comma
id|GET_ALTSTAT
c_func
(paren
)paren
comma
l_string|&quot;read&quot;
)paren
suffix:semicolon
)brace
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|end_request
c_func
(paren
id|drive
comma
l_int|1
)paren
suffix:semicolon
r_return
id|ide_stopped
suffix:semicolon
)brace
macro_line|#endif /* ALTSTAT_SCREW_UP */
r_do
(brace
id|nsect
op_assign
id|rq-&gt;current_nr_sectors
suffix:semicolon
r_if
c_cond
(paren
id|nsect
OG
id|msect
)paren
id|nsect
op_assign
id|msect
suffix:semicolon
id|pBuf
op_assign
id|task_map_rq
c_func
(paren
id|rq
comma
op_amp
id|flags
)paren
suffix:semicolon
id|DTF
c_func
(paren
l_string|&quot;Multiread: %p, nsect: %d, msect: %d, &quot;
"&bslash;"
l_string|&quot; rq-&gt;current_nr_sectors: %d&bslash;n&quot;
comma
id|pBuf
comma
id|nsect
comma
id|msect
comma
id|rq-&gt;current_nr_sectors
)paren
suffix:semicolon
singleline_comment|//&t;&t;rq-&gt;current_nr_sectors -= nsect;
singleline_comment|//&t;&t;msect -= nsect;
id|taskfile_input_data
c_func
(paren
id|drive
comma
id|pBuf
comma
id|nsect
op_star
id|SECTOR_WORDS
)paren
suffix:semicolon
id|task_unmap_rq
c_func
(paren
id|rq
comma
id|pBuf
comma
op_amp
id|flags
)paren
suffix:semicolon
id|rq-&gt;errors
op_assign
l_int|0
suffix:semicolon
id|rq-&gt;current_nr_sectors
op_sub_assign
id|nsect
suffix:semicolon
id|msect
op_sub_assign
id|nsect
suffix:semicolon
multiline_comment|/*&n;&t;&t; * FIXME :: We really can not legally get a new page/bh&n;&t;&t; * regardless, if this is the end of our segment.&n;&t;&t; * BH walking or segment can only be updated after we have a&n;&t;&t; * good GET_STAT(); return.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|rq-&gt;current_nr_sectors
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|end_request
c_func
(paren
id|drive
comma
l_int|1
)paren
)paren
r_return
id|ide_stopped
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|msect
)paren
suffix:semicolon
r_if
c_cond
(paren
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|handler
op_eq
l_int|NULL
)paren
id|ide_set_handler
c_func
(paren
id|drive
comma
op_amp
id|task_mulin_intr
comma
id|WAIT_CMD
comma
l_int|NULL
)paren
suffix:semicolon
r_return
id|ide_started
suffix:semicolon
)brace
multiline_comment|/*&n; * VERIFY ME before 2.4 ... unexpected race is possible based on details&n; * RMK with 74LS245/373/374 TTL buffer logic because of passthrough.&n; */
DECL|function|pre_task_out_intr
id|ide_startstop_t
id|pre_task_out_intr
(paren
id|ide_drive_t
op_star
id|drive
comma
r_struct
id|request
op_star
id|rq
)paren
(brace
r_char
op_star
id|pBuf
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|ide_startstop_t
id|startstop
suffix:semicolon
r_if
c_cond
(paren
id|ide_wait_stat
c_func
(paren
op_amp
id|startstop
comma
id|drive
comma
id|DATA_READY
comma
id|drive-&gt;bad_wstat
comma
id|WAIT_DRQ
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: no DRQ after issuing %s&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|drive-&gt;addressing
ques
c_cond
l_string|&quot;WRITE_EXT&quot;
suffix:colon
l_string|&quot;WRITE&quot;
)paren
suffix:semicolon
r_return
id|startstop
suffix:semicolon
)brace
multiline_comment|/* For Write_sectors we need to stuff the first sector */
id|pBuf
op_assign
id|task_map_rq
c_func
(paren
id|rq
comma
op_amp
id|flags
)paren
suffix:semicolon
singleline_comment|//&t;rq-&gt;current_nr_sectors--;
id|taskfile_output_data
c_func
(paren
id|drive
comma
id|pBuf
comma
id|SECTOR_WORDS
)paren
suffix:semicolon
id|rq-&gt;current_nr_sectors
op_decrement
suffix:semicolon
multiline_comment|/*&n;&t; * WARNING :: Interrupt could happen instantly :-/&n;&t; */
id|task_unmap_rq
c_func
(paren
id|rq
comma
id|pBuf
comma
op_amp
id|flags
)paren
suffix:semicolon
r_return
id|ide_started
suffix:semicolon
)brace
multiline_comment|/*&n; * Handler for command with PIO data-out phase WRITE&n; *&n; * WOOHOO this is a CORRECT STATE DIAGRAM NOW, &lt;andre@linux-ide.org&gt;&n; */
DECL|function|task_out_intr
id|ide_startstop_t
id|task_out_intr
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|byte
id|stat
op_assign
id|GET_STAT
c_func
(paren
)paren
suffix:semicolon
r_struct
id|request
op_star
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
r_char
op_star
id|pBuf
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|OK_STAT
c_func
(paren
id|stat
comma
id|DRIVE_READY
comma
id|drive-&gt;bad_wstat
)paren
)paren
(brace
id|DTF
c_func
(paren
l_string|&quot;%s: WRITE attempting to recover last &quot;
"&bslash;"
l_string|&quot;sector counter status=0x%02x&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|stat
)paren
suffix:semicolon
id|rq-&gt;current_nr_sectors
op_increment
suffix:semicolon
r_return
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|error
c_func
(paren
id|drive
comma
l_string|&quot;task_out_intr&quot;
comma
id|stat
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Safe to update request for partial completions.&n;&t; * We have a good STATUS CHECK!!!&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|rq-&gt;current_nr_sectors
)paren
r_if
c_cond
(paren
op_logical_neg
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|end_request
c_func
(paren
id|drive
comma
l_int|1
)paren
)paren
r_return
id|ide_stopped
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rq-&gt;current_nr_sectors
op_eq
l_int|1
)paren
op_xor
(paren
id|stat
op_amp
id|DRQ_STAT
)paren
)paren
(brace
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
id|pBuf
op_assign
id|task_map_rq
c_func
(paren
id|rq
comma
op_amp
id|flags
)paren
suffix:semicolon
id|DTF
c_func
(paren
l_string|&quot;write: %p, rq-&gt;current_nr_sectors: %d&bslash;n&quot;
comma
id|pBuf
comma
(paren
r_int
)paren
id|rq-&gt;current_nr_sectors
)paren
suffix:semicolon
singleline_comment|//&t;&t;rq-&gt;current_nr_sectors--;
id|taskfile_output_data
c_func
(paren
id|drive
comma
id|pBuf
comma
id|SECTOR_WORDS
)paren
suffix:semicolon
id|task_unmap_rq
c_func
(paren
id|rq
comma
id|pBuf
comma
op_amp
id|flags
)paren
suffix:semicolon
id|rq-&gt;errors
op_assign
l_int|0
suffix:semicolon
id|rq-&gt;current_nr_sectors
op_decrement
suffix:semicolon
)brace
r_if
c_cond
(paren
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|handler
op_eq
l_int|NULL
)paren
id|ide_set_handler
c_func
(paren
id|drive
comma
op_amp
id|task_out_intr
comma
id|WAIT_CMD
comma
l_int|NULL
)paren
suffix:semicolon
r_return
id|ide_started
suffix:semicolon
)brace
DECL|function|pre_task_mulout_intr
id|ide_startstop_t
id|pre_task_mulout_intr
(paren
id|ide_drive_t
op_star
id|drive
comma
r_struct
id|request
op_star
id|rq
)paren
(brace
id|ide_task_t
op_star
id|args
op_assign
id|rq-&gt;special
suffix:semicolon
id|ide_startstop_t
id|startstop
suffix:semicolon
macro_line|#if 0
multiline_comment|/*&n;&t; * assign private copy for multi-write&n;&t; */
id|memcpy
c_func
(paren
op_amp
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|wrq
comma
id|rq
comma
r_sizeof
(paren
r_struct
id|request
)paren
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|ide_wait_stat
c_func
(paren
op_amp
id|startstop
comma
id|drive
comma
id|DATA_READY
comma
id|drive-&gt;bad_wstat
comma
id|WAIT_DRQ
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: no DRQ after issuing %s&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|drive-&gt;addressing
ques
c_cond
l_string|&quot;MULTWRITE_EXT&quot;
suffix:colon
l_string|&quot;MULTWRITE&quot;
)paren
suffix:semicolon
r_return
id|startstop
suffix:semicolon
)brace
macro_line|#if 0
r_if
c_cond
(paren
id|wait_for_ready
c_func
(paren
id|drive
comma
l_int|100
)paren
)paren
id|IDE_DEBUG
c_func
(paren
id|__LINE__
)paren
suffix:semicolon
singleline_comment|//BUG();
macro_line|#else
r_if
c_cond
(paren
op_logical_neg
(paren
id|drive_is_ready
c_func
(paren
id|drive
)paren
)paren
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|100
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|drive_is_ready
c_func
(paren
id|drive
)paren
)paren
r_break
suffix:semicolon
)brace
)brace
macro_line|#endif
multiline_comment|/*&n;&t; * WARNING :: if the drive as not acked good status we may not&n;&t; * move the DATA-TRANSFER T-Bar as BSY != 0. &lt;andre@linux-ide.org&gt;&n;&t; */
r_return
id|args
op_member_access_from_pointer
id|handler
c_func
(paren
id|drive
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * FIXME before enabling in 2.4 ... DATA integrity issue upon error.&n; */
multiline_comment|/*&n; * Handler for command write multiple&n; * Called directly from execute_drive_cmd for the first bunch of sectors,&n; * afterwards only by the ISR&n; */
DECL|function|task_mulout_intr
id|ide_startstop_t
id|task_mulout_intr
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
macro_line|#ifdef ALTSTAT_SCREW_UP
id|byte
id|stat
op_assign
id|altstat_multi_busy
c_func
(paren
id|drive
comma
id|GET_ALTSTAT
c_func
(paren
)paren
comma
l_string|&quot;write&quot;
)paren
suffix:semicolon
macro_line|#else
id|byte
id|stat
op_assign
id|GET_STAT
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif /* ALTSTAT_SCREW_UP */
r_struct
id|request
op_star
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
r_char
op_star
id|pBuf
op_assign
l_int|NULL
suffix:semicolon
id|ide_startstop_t
id|startstop
op_assign
id|ide_stopped
suffix:semicolon
r_int
r_int
id|msect
op_assign
id|drive-&gt;mult_count
suffix:semicolon
r_int
r_int
id|nsect
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/*&n;&t; * (ks/hs): Handle last IRQ on multi-sector transfer,&n;&t; * occurs after all data was sent in this chunk&n;&t; */
r_if
c_cond
(paren
id|rq-&gt;current_nr_sectors
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|stat
op_amp
(paren
id|ERR_STAT
op_or
id|DRQ_STAT
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|rq-&gt;bio
)paren
(brace
id|rq-&gt;current_nr_sectors
op_add_assign
id|drive-&gt;mult_count
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * NOTE: could rewind beyond beginning :-/&n;&t;&t;&t;&t; */
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;%s: MULTI-WRITE assume all data &quot;
"&bslash;"
l_string|&quot;transfered is bad status=0x%02x&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|stat
)paren
suffix:semicolon
)brace
r_return
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|error
c_func
(paren
id|drive
comma
l_string|&quot;task_mulout_intr&quot;
comma
id|stat
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|rq-&gt;bio
)paren
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|end_request
c_func
(paren
id|drive
comma
l_int|1
)paren
suffix:semicolon
r_return
id|startstop
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * DON&squot;T be lazy code the above and below togather !!!&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|OK_STAT
c_func
(paren
id|stat
comma
id|DATA_READY
comma
id|BAD_R_STAT
)paren
)paren
(brace
r_if
c_cond
(paren
id|stat
op_amp
(paren
id|ERR_STAT
op_or
id|DRQ_STAT
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|rq-&gt;bio
)paren
(brace
id|rq-&gt;current_nr_sectors
op_add_assign
id|drive-&gt;mult_count
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * NOTE: could rewind beyond beginning :-/&n;&t;&t;&t;&t; */
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;%s: MULTI-WRITE assume all data &quot;
"&bslash;"
l_string|&quot;transfered is bad status=0x%02x&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|stat
)paren
suffix:semicolon
)brace
r_return
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|error
c_func
(paren
id|drive
comma
l_string|&quot;task_mulout_intr&quot;
comma
id|stat
)paren
suffix:semicolon
)brace
multiline_comment|/* no data yet, so wait for another interrupt */
r_if
c_cond
(paren
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|handler
op_eq
l_int|NULL
)paren
id|ide_set_handler
c_func
(paren
id|drive
comma
op_amp
id|task_mulout_intr
comma
id|WAIT_CMD
comma
l_int|NULL
)paren
suffix:semicolon
r_return
id|ide_started
suffix:semicolon
)brace
r_if
c_cond
(paren
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|handler
op_ne
l_int|NULL
)paren
(brace
r_int
r_int
id|lflags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ide_lock
comma
id|lflags
)paren
suffix:semicolon
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|handler
op_assign
l_int|NULL
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|timer
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ide_lock
comma
id|lflags
)paren
suffix:semicolon
)brace
macro_line|#ifdef ALTSTAT_SCREW_UP
multiline_comment|/*&n;&t; * Screw the request we do not support bad data-phase setups!&n;&t; * Either read and learn the ATA standard or crash yourself!&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|msect
)paren
(brace
id|nsect
op_assign
l_int|1
suffix:semicolon
r_while
c_loop
(paren
id|rq-&gt;current_nr_sectors
)paren
(brace
id|pBuf
op_assign
id|task_map_rq
c_func
(paren
id|rq
comma
op_amp
id|flags
)paren
suffix:semicolon
id|DTF
c_func
(paren
l_string|&quot;Multiwrite: %p, nsect: %d, &quot;
"&bslash;"
l_string|&quot;rq-&gt;current_nr_sectors: %d&bslash;n&quot;
comma
id|pBuf
comma
id|nsect
comma
id|rq-&gt;current_nr_sectors
)paren
suffix:semicolon
singleline_comment|//&t;&t;&t;rq-&gt;current_nr_sectors -= nsect;
id|taskfile_output_data
c_func
(paren
id|drive
comma
id|pBuf
comma
id|nsect
op_star
id|SECTOR_WORDS
)paren
suffix:semicolon
id|task_unmap_rq
c_func
(paren
id|pBuf
comma
op_amp
id|flags
)paren
suffix:semicolon
id|rq-&gt;errors
op_assign
l_int|0
suffix:semicolon
id|rq-&gt;current_nr_sectors
op_sub_assign
id|nsect
suffix:semicolon
id|stat
op_assign
id|altstat_multi_poll
c_func
(paren
id|drive
comma
id|GET_ALTSTAT
c_func
(paren
)paren
comma
l_string|&quot;write&quot;
)paren
suffix:semicolon
)brace
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|end_request
c_func
(paren
id|drive
comma
l_int|1
)paren
suffix:semicolon
r_return
id|ide_stopped
suffix:semicolon
)brace
macro_line|#endif /* ALTSTAT_SCREW_UP */
r_do
(brace
id|nsect
op_assign
id|rq-&gt;current_nr_sectors
suffix:semicolon
r_if
c_cond
(paren
id|nsect
OG
id|msect
)paren
id|nsect
op_assign
id|msect
suffix:semicolon
id|pBuf
op_assign
id|task_map_rq
c_func
(paren
id|rq
comma
op_amp
id|flags
)paren
suffix:semicolon
id|DTF
c_func
(paren
l_string|&quot;Multiwrite: %p, nsect: %d, msect: %d, &quot;
"&bslash;"
l_string|&quot;rq-&gt;current_nr_sectors: %ld&bslash;n&quot;
comma
id|pBuf
comma
id|nsect
comma
id|msect
comma
id|rq-&gt;current_nr_sectors
)paren
suffix:semicolon
id|msect
op_sub_assign
id|nsect
suffix:semicolon
singleline_comment|//&t;&t;rq-&gt;current_nr_sectors -= nsect;
id|taskfile_output_data
c_func
(paren
id|drive
comma
id|pBuf
comma
id|nsect
op_star
id|SECTOR_WORDS
)paren
suffix:semicolon
id|task_unmap_rq
c_func
(paren
id|rq
comma
id|pBuf
comma
op_amp
id|flags
)paren
suffix:semicolon
id|rq-&gt;current_nr_sectors
op_sub_assign
id|nsect
suffix:semicolon
multiline_comment|/*&n;&t;&t; * FIXME :: We really can not legally get a new page/bh&n;&t;&t; * regardless, if this is the end of our segment.&n;&t;&t; * BH walking or segment can only be updated after we&n;&t;&t; * have a good  GET_STAT(); return.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|rq-&gt;current_nr_sectors
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|end_request
c_func
(paren
id|drive
comma
l_int|1
)paren
)paren
r_if
c_cond
(paren
op_logical_neg
id|rq-&gt;bio
)paren
r_return
id|ide_stopped
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|msect
)paren
suffix:semicolon
id|rq-&gt;errors
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|handler
op_eq
l_int|NULL
)paren
id|ide_set_handler
c_func
(paren
id|drive
comma
op_amp
id|task_mulout_intr
comma
id|WAIT_CMD
comma
l_int|NULL
)paren
suffix:semicolon
r_return
id|ide_started
suffix:semicolon
)brace
multiline_comment|/* Called by internal to feature out type of command being called */
DECL|function|ide_pre_handler_parser
id|ide_pre_handler_t
op_star
id|ide_pre_handler_parser
(paren
r_struct
id|hd_drive_task_hdr
op_star
id|taskfile
comma
r_struct
id|hd_drive_hob_hdr
op_star
id|hobfile
)paren
(brace
r_switch
c_cond
(paren
id|taskfile-&gt;command
)paren
(brace
multiline_comment|/* IDE_DRIVE_TASK_RAW_WRITE */
r_case
id|CFA_WRITE_MULTI_WO_ERASE
suffix:colon
r_case
id|WIN_MULTWRITE
suffix:colon
r_case
id|WIN_MULTWRITE_EXT
suffix:colon
r_return
op_amp
id|pre_task_mulout_intr
suffix:semicolon
multiline_comment|/* IDE_DRIVE_TASK_OUT */
r_case
id|WIN_WRITE
suffix:colon
r_case
id|WIN_WRITE_EXT
suffix:colon
r_case
id|WIN_WRITE_VERIFY
suffix:colon
r_case
id|WIN_WRITE_BUFFER
suffix:colon
r_case
id|CFA_WRITE_SECT_WO_ERASE
suffix:colon
r_case
id|WIN_DOWNLOAD_MICROCODE
suffix:colon
r_return
op_amp
id|pre_task_out_intr
suffix:semicolon
multiline_comment|/* IDE_DRIVE_TASK_OUT */
r_case
id|WIN_SMART
suffix:colon
r_if
c_cond
(paren
id|taskfile-&gt;feature
op_eq
id|SMART_WRITE_LOG_SECTOR
)paren
r_return
op_amp
id|pre_task_out_intr
suffix:semicolon
r_case
id|WIN_WRITEDMA
suffix:colon
r_case
id|WIN_WRITEDMA_QUEUED
suffix:colon
r_case
id|WIN_WRITEDMA_EXT
suffix:colon
r_case
id|WIN_WRITEDMA_QUEUED_EXT
suffix:colon
multiline_comment|/* IDE_DRIVE_TASK_OUT */
r_default
suffix:colon
r_break
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Called by internal to feature out type of command being called */
DECL|function|ide_handler_parser
id|ide_handler_t
op_star
id|ide_handler_parser
(paren
r_struct
id|hd_drive_task_hdr
op_star
id|taskfile
comma
r_struct
id|hd_drive_hob_hdr
op_star
id|hobfile
)paren
(brace
r_switch
c_cond
(paren
id|taskfile-&gt;command
)paren
(brace
r_case
id|WIN_IDENTIFY
suffix:colon
r_case
id|WIN_PIDENTIFY
suffix:colon
r_case
id|CFA_TRANSLATE_SECTOR
suffix:colon
r_case
id|WIN_READ_BUFFER
suffix:colon
r_case
id|WIN_READ
suffix:colon
r_case
id|WIN_READ_EXT
suffix:colon
r_return
op_amp
id|task_in_intr
suffix:semicolon
r_case
id|WIN_SECURITY_DISABLE
suffix:colon
r_case
id|WIN_SECURITY_ERASE_UNIT
suffix:colon
r_case
id|WIN_SECURITY_SET_PASS
suffix:colon
r_case
id|WIN_SECURITY_UNLOCK
suffix:colon
r_case
id|WIN_DOWNLOAD_MICROCODE
suffix:colon
r_case
id|CFA_WRITE_SECT_WO_ERASE
suffix:colon
r_case
id|WIN_WRITE_BUFFER
suffix:colon
r_case
id|WIN_WRITE_VERIFY
suffix:colon
r_case
id|WIN_WRITE
suffix:colon
r_case
id|WIN_WRITE_EXT
suffix:colon
r_return
op_amp
id|task_out_intr
suffix:semicolon
r_case
id|WIN_MULTREAD
suffix:colon
r_case
id|WIN_MULTREAD_EXT
suffix:colon
r_return
op_amp
id|task_mulin_intr
suffix:semicolon
r_case
id|CFA_WRITE_MULTI_WO_ERASE
suffix:colon
r_case
id|WIN_MULTWRITE
suffix:colon
r_case
id|WIN_MULTWRITE_EXT
suffix:colon
r_return
op_amp
id|task_mulout_intr
suffix:semicolon
r_case
id|WIN_SMART
suffix:colon
r_switch
c_cond
(paren
id|taskfile-&gt;feature
)paren
(brace
r_case
id|SMART_READ_VALUES
suffix:colon
r_case
id|SMART_READ_THRESHOLDS
suffix:colon
r_case
id|SMART_READ_LOG_SECTOR
suffix:colon
r_return
op_amp
id|task_in_intr
suffix:semicolon
r_case
id|SMART_WRITE_LOG_SECTOR
suffix:colon
r_return
op_amp
id|task_out_intr
suffix:semicolon
r_default
suffix:colon
r_return
op_amp
id|task_no_data_intr
suffix:semicolon
)brace
r_case
id|CFA_REQ_EXT_ERROR_CODE
suffix:colon
r_case
id|CFA_ERASE_SECTORS
suffix:colon
r_case
id|WIN_VERIFY
suffix:colon
r_case
id|WIN_VERIFY_EXT
suffix:colon
r_case
id|WIN_SEEK
suffix:colon
r_return
op_amp
id|task_no_data_intr
suffix:semicolon
r_case
id|WIN_SPECIFY
suffix:colon
r_return
op_amp
id|set_geometry_intr
suffix:semicolon
r_case
id|WIN_RECAL
suffix:colon
singleline_comment|//&t;case WIN_RESTORE:
r_return
op_amp
id|recal_intr
suffix:semicolon
r_case
id|WIN_NOP
suffix:colon
r_case
id|WIN_DIAGNOSE
suffix:colon
r_case
id|WIN_FLUSH_CACHE
suffix:colon
r_case
id|WIN_FLUSH_CACHE_EXT
suffix:colon
r_case
id|WIN_STANDBYNOW1
suffix:colon
r_case
id|WIN_STANDBYNOW2
suffix:colon
r_case
id|WIN_SLEEPNOW1
suffix:colon
r_case
id|WIN_SLEEPNOW2
suffix:colon
r_case
id|WIN_SETIDLE1
suffix:colon
r_case
id|WIN_CHECKPOWERMODE1
suffix:colon
r_case
id|WIN_CHECKPOWERMODE2
suffix:colon
r_case
id|WIN_GETMEDIASTATUS
suffix:colon
r_case
id|WIN_MEDIAEJECT
suffix:colon
r_return
op_amp
id|task_no_data_intr
suffix:semicolon
r_case
id|WIN_SETMULT
suffix:colon
r_return
op_amp
id|set_multmode_intr
suffix:semicolon
r_case
id|WIN_READ_NATIVE_MAX
suffix:colon
r_case
id|WIN_SET_MAX
suffix:colon
r_case
id|WIN_READ_NATIVE_MAX_EXT
suffix:colon
r_case
id|WIN_SET_MAX_EXT
suffix:colon
r_case
id|WIN_SECURITY_ERASE_PREPARE
suffix:colon
r_case
id|WIN_SECURITY_FREEZE_LOCK
suffix:colon
r_case
id|WIN_DOORLOCK
suffix:colon
r_case
id|WIN_DOORUNLOCK
suffix:colon
r_case
id|WIN_SETFEATURES
suffix:colon
r_return
op_amp
id|task_no_data_intr
suffix:semicolon
r_case
id|DISABLE_SEAGATE
suffix:colon
r_case
id|EXABYTE_ENABLE_NEST
suffix:colon
r_return
op_amp
id|task_no_data_intr
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_IDEDMA
r_case
id|WIN_READDMA
suffix:colon
r_case
id|WIN_IDENTIFY_DMA
suffix:colon
r_case
id|WIN_READDMA_QUEUED
suffix:colon
r_case
id|WIN_READDMA_EXT
suffix:colon
r_case
id|WIN_READDMA_QUEUED_EXT
suffix:colon
r_case
id|WIN_WRITEDMA
suffix:colon
r_case
id|WIN_WRITEDMA_QUEUED
suffix:colon
r_case
id|WIN_WRITEDMA_EXT
suffix:colon
r_case
id|WIN_WRITEDMA_QUEUED_EXT
suffix:colon
macro_line|#endif
r_case
id|WIN_FORMAT
suffix:colon
r_case
id|WIN_INIT
suffix:colon
r_case
id|WIN_DEVICE_RESET
suffix:colon
r_case
id|WIN_QUEUED_SERVICE
suffix:colon
r_case
id|WIN_PACKETCMD
suffix:colon
r_default
suffix:colon
r_return
l_int|NULL
suffix:semicolon
)brace
)brace
DECL|function|ide_post_handler_parser
id|ide_post_handler_t
op_star
id|ide_post_handler_parser
(paren
r_struct
id|hd_drive_task_hdr
op_star
id|taskfile
comma
r_struct
id|hd_drive_hob_hdr
op_star
id|hobfile
)paren
(brace
r_switch
c_cond
(paren
id|taskfile-&gt;command
)paren
(brace
r_case
id|WIN_SPECIFY
suffix:colon
multiline_comment|/* set_geometry_intr */
r_case
id|WIN_RESTORE
suffix:colon
multiline_comment|/* recal_intr */
r_case
id|WIN_SETMULT
suffix:colon
multiline_comment|/* set_multmode_intr */
r_default
suffix:colon
r_return
l_int|NULL
suffix:semicolon
)brace
)brace
multiline_comment|/* Called by ioctl to feature out type of command being called */
DECL|function|ide_cmd_type_parser
r_int
id|ide_cmd_type_parser
(paren
id|ide_task_t
op_star
id|args
)paren
(brace
r_struct
id|hd_drive_task_hdr
op_star
id|taskfile
op_assign
(paren
r_struct
id|hd_drive_task_hdr
op_star
)paren
id|args-&gt;tfRegister
suffix:semicolon
r_struct
id|hd_drive_hob_hdr
op_star
id|hobfile
op_assign
(paren
r_struct
id|hd_drive_hob_hdr
op_star
)paren
id|args-&gt;hobRegister
suffix:semicolon
id|args-&gt;prehandler
op_assign
id|ide_pre_handler_parser
c_func
(paren
id|taskfile
comma
id|hobfile
)paren
suffix:semicolon
id|args-&gt;handler
op_assign
id|ide_handler_parser
c_func
(paren
id|taskfile
comma
id|hobfile
)paren
suffix:semicolon
id|args-&gt;posthandler
op_assign
id|ide_post_handler_parser
c_func
(paren
id|taskfile
comma
id|hobfile
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|args-&gt;tfRegister
(braket
id|IDE_COMMAND_OFFSET
)braket
)paren
(brace
r_case
id|WIN_IDENTIFY
suffix:colon
r_case
id|WIN_PIDENTIFY
suffix:colon
r_return
id|IDE_DRIVE_TASK_IN
suffix:semicolon
r_case
id|CFA_TRANSLATE_SECTOR
suffix:colon
r_case
id|WIN_READ
suffix:colon
r_case
id|WIN_READ_EXT
suffix:colon
r_case
id|WIN_READ_BUFFER
suffix:colon
r_return
id|IDE_DRIVE_TASK_IN
suffix:semicolon
r_case
id|WIN_WRITE
suffix:colon
r_case
id|WIN_WRITE_EXT
suffix:colon
r_case
id|WIN_WRITE_VERIFY
suffix:colon
r_case
id|WIN_WRITE_BUFFER
suffix:colon
r_case
id|CFA_WRITE_SECT_WO_ERASE
suffix:colon
r_case
id|WIN_DOWNLOAD_MICROCODE
suffix:colon
r_return
id|IDE_DRIVE_TASK_RAW_WRITE
suffix:semicolon
r_case
id|WIN_MULTREAD
suffix:colon
r_case
id|WIN_MULTREAD_EXT
suffix:colon
r_return
id|IDE_DRIVE_TASK_IN
suffix:semicolon
r_case
id|CFA_WRITE_MULTI_WO_ERASE
suffix:colon
r_case
id|WIN_MULTWRITE
suffix:colon
r_case
id|WIN_MULTWRITE_EXT
suffix:colon
r_return
id|IDE_DRIVE_TASK_RAW_WRITE
suffix:semicolon
r_case
id|WIN_SECURITY_DISABLE
suffix:colon
r_case
id|WIN_SECURITY_ERASE_UNIT
suffix:colon
r_case
id|WIN_SECURITY_SET_PASS
suffix:colon
r_case
id|WIN_SECURITY_UNLOCK
suffix:colon
r_return
id|IDE_DRIVE_TASK_OUT
suffix:semicolon
r_case
id|WIN_SMART
suffix:colon
id|args-&gt;tfRegister
(braket
id|IDE_LCYL_OFFSET
)braket
op_assign
id|SMART_LCYL_PASS
suffix:semicolon
id|args-&gt;tfRegister
(braket
id|IDE_HCYL_OFFSET
)braket
op_assign
id|SMART_HCYL_PASS
suffix:semicolon
r_switch
c_cond
(paren
id|args-&gt;tfRegister
(braket
id|IDE_FEATURE_OFFSET
)braket
)paren
(brace
r_case
id|SMART_READ_VALUES
suffix:colon
r_case
id|SMART_READ_THRESHOLDS
suffix:colon
r_case
id|SMART_READ_LOG_SECTOR
suffix:colon
r_return
id|IDE_DRIVE_TASK_IN
suffix:semicolon
r_case
id|SMART_WRITE_LOG_SECTOR
suffix:colon
r_return
id|IDE_DRIVE_TASK_OUT
suffix:semicolon
r_default
suffix:colon
r_return
id|IDE_DRIVE_TASK_NO_DATA
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_BLK_DEV_IDEDMA
r_case
id|WIN_READDMA
suffix:colon
r_case
id|WIN_IDENTIFY_DMA
suffix:colon
r_case
id|WIN_READDMA_QUEUED
suffix:colon
r_case
id|WIN_READDMA_EXT
suffix:colon
r_case
id|WIN_READDMA_QUEUED_EXT
suffix:colon
r_return
id|IDE_DRIVE_TASK_IN
suffix:semicolon
r_case
id|WIN_WRITEDMA
suffix:colon
r_case
id|WIN_WRITEDMA_QUEUED
suffix:colon
r_case
id|WIN_WRITEDMA_EXT
suffix:colon
r_case
id|WIN_WRITEDMA_QUEUED_EXT
suffix:colon
r_return
id|IDE_DRIVE_TASK_RAW_WRITE
suffix:semicolon
macro_line|#endif
r_case
id|WIN_SETFEATURES
suffix:colon
r_switch
c_cond
(paren
id|args-&gt;tfRegister
(braket
id|IDE_FEATURE_OFFSET
)braket
)paren
(brace
r_case
id|SETFEATURES_EN_8BIT
suffix:colon
r_case
id|SETFEATURES_EN_WCACHE
suffix:colon
r_return
id|IDE_DRIVE_TASK_NO_DATA
suffix:semicolon
r_case
id|SETFEATURES_XFER
suffix:colon
r_return
id|IDE_DRIVE_TASK_SET_XFER
suffix:semicolon
r_case
id|SETFEATURES_DIS_DEFECT
suffix:colon
r_case
id|SETFEATURES_EN_APM
suffix:colon
r_case
id|SETFEATURES_DIS_MSN
suffix:colon
r_case
id|SETFEATURES_DIS_RETRY
suffix:colon
r_case
id|SETFEATURES_EN_AAM
suffix:colon
r_case
id|SETFEATURES_RW_LONG
suffix:colon
r_case
id|SETFEATURES_SET_CACHE
suffix:colon
r_case
id|SETFEATURES_DIS_RLA
suffix:colon
r_case
id|SETFEATURES_EN_RI
suffix:colon
r_case
id|SETFEATURES_EN_SI
suffix:colon
r_case
id|SETFEATURES_DIS_RPOD
suffix:colon
r_case
id|SETFEATURES_DIS_WCACHE
suffix:colon
r_case
id|SETFEATURES_EN_DEFECT
suffix:colon
r_case
id|SETFEATURES_DIS_APM
suffix:colon
r_case
id|SETFEATURES_EN_ECC
suffix:colon
r_case
id|SETFEATURES_EN_MSN
suffix:colon
r_case
id|SETFEATURES_EN_RETRY
suffix:colon
r_case
id|SETFEATURES_EN_RLA
suffix:colon
r_case
id|SETFEATURES_PREFETCH
suffix:colon
r_case
id|SETFEATURES_4B_RW_LONG
suffix:colon
r_case
id|SETFEATURES_DIS_AAM
suffix:colon
r_case
id|SETFEATURES_EN_RPOD
suffix:colon
r_case
id|SETFEATURES_DIS_RI
suffix:colon
r_case
id|SETFEATURES_DIS_SI
suffix:colon
r_default
suffix:colon
r_return
id|IDE_DRIVE_TASK_NO_DATA
suffix:semicolon
)brace
r_case
id|WIN_NOP
suffix:colon
r_case
id|CFA_REQ_EXT_ERROR_CODE
suffix:colon
r_case
id|CFA_ERASE_SECTORS
suffix:colon
r_case
id|WIN_VERIFY
suffix:colon
r_case
id|WIN_VERIFY_EXT
suffix:colon
r_case
id|WIN_SEEK
suffix:colon
r_case
id|WIN_SPECIFY
suffix:colon
r_case
id|WIN_RESTORE
suffix:colon
r_case
id|WIN_DIAGNOSE
suffix:colon
r_case
id|WIN_FLUSH_CACHE
suffix:colon
r_case
id|WIN_FLUSH_CACHE_EXT
suffix:colon
r_case
id|WIN_STANDBYNOW1
suffix:colon
r_case
id|WIN_STANDBYNOW2
suffix:colon
r_case
id|WIN_SLEEPNOW1
suffix:colon
r_case
id|WIN_SLEEPNOW2
suffix:colon
r_case
id|WIN_SETIDLE1
suffix:colon
r_case
id|DISABLE_SEAGATE
suffix:colon
r_case
id|WIN_CHECKPOWERMODE1
suffix:colon
r_case
id|WIN_CHECKPOWERMODE2
suffix:colon
r_case
id|WIN_GETMEDIASTATUS
suffix:colon
r_case
id|WIN_MEDIAEJECT
suffix:colon
r_case
id|WIN_SETMULT
suffix:colon
r_case
id|WIN_READ_NATIVE_MAX
suffix:colon
r_case
id|WIN_SET_MAX
suffix:colon
r_case
id|WIN_READ_NATIVE_MAX_EXT
suffix:colon
r_case
id|WIN_SET_MAX_EXT
suffix:colon
r_case
id|WIN_SECURITY_ERASE_PREPARE
suffix:colon
r_case
id|WIN_SECURITY_FREEZE_LOCK
suffix:colon
r_case
id|EXABYTE_ENABLE_NEST
suffix:colon
r_case
id|WIN_DOORLOCK
suffix:colon
r_case
id|WIN_DOORUNLOCK
suffix:colon
r_return
id|IDE_DRIVE_TASK_NO_DATA
suffix:semicolon
r_case
id|WIN_FORMAT
suffix:colon
r_case
id|WIN_INIT
suffix:colon
r_case
id|WIN_DEVICE_RESET
suffix:colon
r_case
id|WIN_QUEUED_SERVICE
suffix:colon
r_case
id|WIN_PACKETCMD
suffix:colon
r_default
suffix:colon
r_return
id|IDE_DRIVE_TASK_INVALID
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * NOTICE: This is additions from IBM to provide a discrete interface,&n; * for selective taskregister access operations.  Nice JOB Klaus!!!&n; * Glad to be able to work and co-develop this with you and IBM.&n; */
DECL|function|flagged_taskfile
id|ide_startstop_t
id|flagged_taskfile
(paren
id|ide_drive_t
op_star
id|drive
comma
id|ide_task_t
op_star
id|task
)paren
(brace
id|task_struct_t
op_star
id|taskfile
op_assign
(paren
id|task_struct_t
op_star
)paren
id|task-&gt;tfRegister
suffix:semicolon
id|hob_struct_t
op_star
id|hobfile
op_assign
(paren
id|hob_struct_t
op_star
)paren
id|task-&gt;hobRegister
suffix:semicolon
r_struct
id|hd_driveid
op_star
id|id
op_assign
id|drive-&gt;id
suffix:semicolon
macro_line|#if DEBUG_TASKFILE
id|byte
id|status
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_IDE_TASK_IOCTL_DEBUG
r_void
id|debug_taskfile
c_func
(paren
id|drive
comma
id|task
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_IDE_TASK_IOCTL_DEBUG */
multiline_comment|/*&n;&t; * (ks) Check taskfile in/out flags.&n;&t; * If set, then execute as it is defined.&n;&t; * If not set, then define default settings.&n;&t; * The default values are:&n;&t; *&t;write and read all taskfile registers (except data) &n;&t; *&t;write and read the hob registers (sector,nsector,lcyl,hcyl)&n;&t; */
r_if
c_cond
(paren
id|task-&gt;tf_out_flags.all
op_eq
l_int|0
)paren
(brace
id|task-&gt;tf_out_flags.all
op_assign
id|IDE_TASKFILE_STD_OUT_FLAGS
suffix:semicolon
r_if
c_cond
(paren
(paren
id|id-&gt;command_set_2
op_amp
l_int|0x0400
)paren
op_logical_and
(paren
id|id-&gt;cfs_enable_2
op_amp
l_int|0x0400
)paren
op_logical_and
(paren
id|drive-&gt;addressing
op_eq
l_int|1
)paren
)paren
(brace
id|task-&gt;tf_out_flags.all
op_or_assign
(paren
id|IDE_HOB_STD_OUT_FLAGS
op_lshift
l_int|8
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|task-&gt;tf_in_flags.all
op_eq
l_int|0
)paren
(brace
id|task-&gt;tf_in_flags.all
op_assign
id|IDE_TASKFILE_STD_IN_FLAGS
suffix:semicolon
r_if
c_cond
(paren
(paren
id|id-&gt;command_set_2
op_amp
l_int|0x0400
)paren
op_logical_and
(paren
id|id-&gt;cfs_enable_2
op_amp
l_int|0x0400
)paren
op_logical_and
(paren
id|drive-&gt;addressing
op_eq
l_int|1
)paren
)paren
(brace
id|task-&gt;tf_in_flags.all
op_or_assign
(paren
id|IDE_HOB_STD_IN_FLAGS
op_lshift
l_int|8
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* ALL Command Block Executions SHALL clear nIEN, unless otherwise */
r_if
c_cond
(paren
id|IDE_CONTROL_REG
)paren
id|OUT_BYTE
c_func
(paren
id|drive-&gt;ctl
comma
id|IDE_CONTROL_REG
)paren
suffix:semicolon
multiline_comment|/* clear nIEN */
id|SELECT_MASK
c_func
(paren
id|HWIF
c_func
(paren
id|drive
)paren
comma
id|drive
comma
l_int|0
)paren
suffix:semicolon
macro_line|#if DEBUG_TASKFILE
id|status
op_assign
id|GET_STAT
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
l_int|0x80
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;flagged_taskfile -&gt; Bad status. Status = %02x. wait 100 usec ...&bslash;n&quot;
comma
id|status
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|100
)paren
suffix:semicolon
id|status
op_assign
id|GET_STAT
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;flagged_taskfile -&gt; Status = %02x&bslash;n&quot;
comma
id|status
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|task-&gt;tf_out_flags.b.data
)paren
(brace
r_int
r_int
id|data
op_assign
id|taskfile-&gt;data
op_plus
(paren
id|hobfile-&gt;data
op_lshift
l_int|8
)paren
suffix:semicolon
id|OUT_WORD
c_func
(paren
id|data
comma
id|IDE_DATA_REG
)paren
suffix:semicolon
)brace
multiline_comment|/* (ks) send hob registers first */
r_if
c_cond
(paren
id|task-&gt;tf_out_flags.b.nsector_hob
)paren
id|OUT_BYTE
c_func
(paren
id|hobfile-&gt;sector_count
comma
id|IDE_NSECTOR_REG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|task-&gt;tf_out_flags.b.sector_hob
)paren
id|OUT_BYTE
c_func
(paren
id|hobfile-&gt;sector_number
comma
id|IDE_SECTOR_REG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|task-&gt;tf_out_flags.b.lcyl_hob
)paren
id|OUT_BYTE
c_func
(paren
id|hobfile-&gt;low_cylinder
comma
id|IDE_LCYL_REG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|task-&gt;tf_out_flags.b.hcyl_hob
)paren
id|OUT_BYTE
c_func
(paren
id|hobfile-&gt;high_cylinder
comma
id|IDE_HCYL_REG
)paren
suffix:semicolon
multiline_comment|/* (ks) Send now the standard registers */
r_if
c_cond
(paren
id|task-&gt;tf_out_flags.b.error_feature
)paren
id|OUT_BYTE
c_func
(paren
id|taskfile-&gt;feature
comma
id|IDE_FEATURE_REG
)paren
suffix:semicolon
multiline_comment|/* refers to number of sectors to transfer */
r_if
c_cond
(paren
id|task-&gt;tf_out_flags.b.nsector
)paren
id|OUT_BYTE
c_func
(paren
id|taskfile-&gt;sector_count
comma
id|IDE_NSECTOR_REG
)paren
suffix:semicolon
multiline_comment|/* refers to sector offset or start sector */
r_if
c_cond
(paren
id|task-&gt;tf_out_flags.b.sector
)paren
id|OUT_BYTE
c_func
(paren
id|taskfile-&gt;sector_number
comma
id|IDE_SECTOR_REG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|task-&gt;tf_out_flags.b.lcyl
)paren
id|OUT_BYTE
c_func
(paren
id|taskfile-&gt;low_cylinder
comma
id|IDE_LCYL_REG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|task-&gt;tf_out_flags.b.hcyl
)paren
id|OUT_BYTE
c_func
(paren
id|taskfile-&gt;high_cylinder
comma
id|IDE_HCYL_REG
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * (ks) In the flagged taskfile approch, we will used all specified&n;&t; * registers and the register value will not be changed. Except the&n;&t; * select bit (master/slave) in the drive_head register. We must make&n;&t; * sure that the desired drive is selected.&n;&t; */
id|OUT_BYTE
c_func
(paren
id|taskfile-&gt;device_head
op_or
id|drive-&gt;select.all
comma
id|IDE_SELECT_REG
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|task-&gt;data_phase
)paren
(brace
r_case
id|TASKFILE_OUT_DMAQ
suffix:colon
r_case
id|TASKFILE_OUT_DMA
suffix:colon
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|dmaproc
c_func
(paren
id|ide_dma_write
comma
id|drive
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TASKFILE_IN_DMAQ
suffix:colon
r_case
id|TASKFILE_IN_DMA
suffix:colon
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|dmaproc
c_func
(paren
id|ide_dma_read
comma
id|drive
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
r_if
c_cond
(paren
id|task-&gt;handler
op_eq
l_int|NULL
)paren
r_return
id|ide_stopped
suffix:semicolon
id|ide_set_handler
(paren
id|drive
comma
id|task-&gt;handler
comma
id|WAIT_WORSTCASE
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* Issue the command */
id|OUT_BYTE
c_func
(paren
id|taskfile-&gt;command
comma
id|IDE_COMMAND_REG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|task-&gt;prehandler
op_ne
l_int|NULL
)paren
r_return
id|task
op_member_access_from_pointer
id|prehandler
c_func
(paren
id|drive
comma
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
)paren
suffix:semicolon
)brace
r_return
id|ide_started
suffix:semicolon
)brace
DECL|function|flagged_task_no_data_intr
id|ide_startstop_t
id|flagged_task_no_data_intr
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|byte
id|stat
op_assign
id|GET_STAT
c_func
(paren
)paren
suffix:semicolon
id|local_irq_enable
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|OK_STAT
c_func
(paren
id|stat
comma
id|READY_STAT
comma
id|BAD_STAT
)paren
)paren
(brace
r_if
c_cond
(paren
id|stat
op_amp
id|ERR_STAT
)paren
(brace
r_return
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|error
c_func
(paren
id|drive
comma
l_string|&quot;flagged_task_no_data_intr&quot;
comma
id|stat
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * (ks) Unexpected ATA data phase detected.&n;&t;&t; * This should not happen. But, it can !&n;&t;&t; * I am not sure, which function is best to clean up&n;&t;&t; * this situation.  I choose: ide_error(...)&n;&t;&t; */
r_return
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|error
c_func
(paren
id|drive
comma
l_string|&quot;flagged_task_no_data_intr (unexpected phase)&quot;
comma
id|stat
)paren
suffix:semicolon
)brace
id|ide_end_drive_cmd
(paren
id|drive
comma
id|stat
comma
id|GET_ERR
c_func
(paren
)paren
)paren
suffix:semicolon
r_return
id|ide_stopped
suffix:semicolon
)brace
multiline_comment|/*&n; * Handler for command with PIO data-in phase&n; */
DECL|function|flagged_task_in_intr
id|ide_startstop_t
id|flagged_task_in_intr
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|byte
id|stat
op_assign
id|GET_STAT
c_func
(paren
)paren
suffix:semicolon
r_struct
id|request
op_star
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
r_char
op_star
id|pBuf
op_assign
l_int|NULL
suffix:semicolon
r_int
id|retries
op_assign
l_int|5
suffix:semicolon
r_if
c_cond
(paren
id|rq-&gt;current_nr_sectors
op_eq
l_int|0
)paren
r_return
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|error
c_func
(paren
id|drive
comma
l_string|&quot;flagged_task_in_intr (no data requested)&quot;
comma
id|stat
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|OK_STAT
c_func
(paren
id|stat
comma
id|DATA_READY
comma
id|BAD_R_STAT
)paren
)paren
(brace
r_if
c_cond
(paren
id|stat
op_amp
id|ERR_STAT
)paren
(brace
r_return
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|error
c_func
(paren
id|drive
comma
l_string|&quot;flagged_task_in_intr&quot;
comma
id|stat
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * (ks) Unexpected ATA data phase detected.&n;&t;&t; * This should not happen. But, it can !&n;&t;&t; * I am not sure, which function is best to clean up&n;&t;&t; * this situation.  I choose: ide_error(...)&n;&t;&t; */
r_return
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|error
c_func
(paren
id|drive
comma
l_string|&quot;flagged_task_in_intr (unexpected data phase)&quot;
comma
id|stat
)paren
suffix:semicolon
)brace
id|pBuf
op_assign
id|rq-&gt;buffer
op_plus
(paren
(paren
id|rq-&gt;nr_sectors
op_minus
id|rq-&gt;current_nr_sectors
)paren
op_star
id|SECTOR_SIZE
)paren
suffix:semicolon
id|DTF
c_func
(paren
l_string|&quot;Read - rq-&gt;current_nr_sectors: %d, status: %02x&bslash;n&quot;
comma
(paren
r_int
)paren
id|rq-&gt;current_nr_sectors
comma
id|stat
)paren
suffix:semicolon
id|taskfile_input_data
c_func
(paren
id|drive
comma
id|pBuf
comma
id|SECTOR_WORDS
)paren
suffix:semicolon
r_if
c_cond
(paren
op_decrement
id|rq-&gt;current_nr_sectors
op_ne
l_int|0
)paren
(brace
multiline_comment|/*&n;                 * (ks) We don&squot;t know which command was executed. &n;&t;&t; * So, we wait the &squot;WORSTCASE&squot; value.&n;                 */
id|ide_set_handler
c_func
(paren
id|drive
comma
op_amp
id|flagged_task_in_intr
comma
id|WAIT_WORSTCASE
comma
l_int|NULL
)paren
suffix:semicolon
r_return
id|ide_started
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * (ks) Last sector was transfered, wait until drive is ready. &n;&t; * This can take up to 10 usec. We willl wait max 50 us.&n;&t; */
r_while
c_loop
(paren
(paren
(paren
id|stat
op_assign
id|GET_STAT
c_func
(paren
)paren
)paren
op_amp
id|BUSY_STAT
)paren
op_logical_and
id|retries
op_decrement
)paren
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
id|ide_end_drive_cmd
(paren
id|drive
comma
id|stat
comma
id|GET_ERR
c_func
(paren
)paren
)paren
suffix:semicolon
r_return
id|ide_stopped
suffix:semicolon
)brace
DECL|function|flagged_task_mulin_intr
id|ide_startstop_t
id|flagged_task_mulin_intr
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|byte
id|stat
op_assign
id|GET_STAT
c_func
(paren
)paren
suffix:semicolon
r_struct
id|request
op_star
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
r_char
op_star
id|pBuf
op_assign
l_int|NULL
suffix:semicolon
r_int
id|retries
op_assign
l_int|5
suffix:semicolon
r_int
r_int
id|msect
comma
id|nsect
suffix:semicolon
r_if
c_cond
(paren
id|rq-&gt;current_nr_sectors
op_eq
l_int|0
)paren
r_return
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|error
c_func
(paren
id|drive
comma
l_string|&quot;flagged_task_mulin_intr (no data requested)&quot;
comma
id|stat
)paren
suffix:semicolon
id|msect
op_assign
id|drive-&gt;mult_count
suffix:semicolon
r_if
c_cond
(paren
id|msect
op_eq
l_int|0
)paren
r_return
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|error
c_func
(paren
id|drive
comma
l_string|&quot;flagged_task_mulin_intr (multimode not set)&quot;
comma
id|stat
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|OK_STAT
c_func
(paren
id|stat
comma
id|DATA_READY
comma
id|BAD_R_STAT
)paren
)paren
(brace
r_if
c_cond
(paren
id|stat
op_amp
id|ERR_STAT
)paren
(brace
r_return
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|error
c_func
(paren
id|drive
comma
l_string|&quot;flagged_task_mulin_intr&quot;
comma
id|stat
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * (ks) Unexpected ATA data phase detected.&n;&t;&t; * This should not happen. But, it can !&n;&t;&t; * I am not sure, which function is best to clean up&n;&t;&t; * this situation.  I choose: ide_error(...)&n;&t;&t; */
r_return
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|error
c_func
(paren
id|drive
comma
l_string|&quot;flagged_task_mulin_intr (unexpected data phase)&quot;
comma
id|stat
)paren
suffix:semicolon
)brace
id|nsect
op_assign
(paren
id|rq-&gt;current_nr_sectors
OG
id|msect
)paren
ques
c_cond
id|msect
suffix:colon
id|rq-&gt;current_nr_sectors
suffix:semicolon
id|pBuf
op_assign
id|rq-&gt;buffer
op_plus
(paren
(paren
id|rq-&gt;nr_sectors
op_minus
id|rq-&gt;current_nr_sectors
)paren
op_star
id|SECTOR_SIZE
)paren
suffix:semicolon
id|DTF
c_func
(paren
l_string|&quot;Multiread: %p, nsect: %d , rq-&gt;current_nr_sectors: %ld&bslash;n&quot;
comma
id|pBuf
comma
id|nsect
comma
id|rq-&gt;current_nr_sectors
)paren
suffix:semicolon
id|taskfile_input_data
c_func
(paren
id|drive
comma
id|pBuf
comma
id|nsect
op_star
id|SECTOR_WORDS
)paren
suffix:semicolon
id|rq-&gt;current_nr_sectors
op_sub_assign
id|nsect
suffix:semicolon
r_if
c_cond
(paren
id|rq-&gt;current_nr_sectors
op_ne
l_int|0
)paren
(brace
multiline_comment|/*&n;                 * (ks) We don&squot;t know which command was executed. &n;&t;&t; * So, we wait the &squot;WORSTCASE&squot; value.&n;                 */
id|ide_set_handler
c_func
(paren
id|drive
comma
op_amp
id|flagged_task_mulin_intr
comma
id|WAIT_WORSTCASE
comma
l_int|NULL
)paren
suffix:semicolon
r_return
id|ide_started
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * (ks) Last sector was transfered, wait until drive is ready. &n;&t; * This can take up to 10 usec. We willl wait max 50 us.&n;&t; */
r_while
c_loop
(paren
(paren
(paren
id|stat
op_assign
id|GET_STAT
c_func
(paren
)paren
)paren
op_amp
id|BUSY_STAT
)paren
op_logical_and
id|retries
op_decrement
)paren
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
id|ide_end_drive_cmd
(paren
id|drive
comma
id|stat
comma
id|GET_ERR
c_func
(paren
)paren
)paren
suffix:semicolon
r_return
id|ide_stopped
suffix:semicolon
)brace
multiline_comment|/*&n; * Pre handler for command with PIO data-out phase&n; */
DECL|function|flagged_pre_task_out_intr
id|ide_startstop_t
id|flagged_pre_task_out_intr
(paren
id|ide_drive_t
op_star
id|drive
comma
r_struct
id|request
op_star
id|rq
)paren
(brace
id|byte
id|stat
op_assign
id|GET_STAT
c_func
(paren
)paren
suffix:semicolon
id|ide_startstop_t
id|startstop
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rq-&gt;current_nr_sectors
)paren
(brace
r_return
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|error
c_func
(paren
id|drive
comma
l_string|&quot;flagged_pre_task_out_intr (write data not specified)&quot;
comma
id|stat
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ide_wait_stat
c_func
(paren
op_amp
id|startstop
comma
id|drive
comma
id|DATA_READY
comma
id|BAD_W_STAT
comma
id|WAIT_DRQ
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: No DRQ bit after issuing write command.&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
r_return
id|startstop
suffix:semicolon
)brace
id|taskfile_output_data
c_func
(paren
id|drive
comma
id|rq-&gt;buffer
comma
id|SECTOR_WORDS
)paren
suffix:semicolon
op_decrement
id|rq-&gt;current_nr_sectors
suffix:semicolon
r_return
id|ide_started
suffix:semicolon
)brace
DECL|function|flagged_task_out_intr
id|ide_startstop_t
id|flagged_task_out_intr
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|byte
id|stat
op_assign
id|GET_STAT
c_func
(paren
)paren
suffix:semicolon
r_struct
id|request
op_star
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
r_char
op_star
id|pBuf
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|OK_STAT
c_func
(paren
id|stat
comma
id|DRIVE_READY
comma
id|BAD_W_STAT
)paren
)paren
r_return
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|error
c_func
(paren
id|drive
comma
l_string|&quot;flagged_task_out_intr&quot;
comma
id|stat
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rq-&gt;current_nr_sectors
)paren
(brace
id|ide_end_drive_cmd
(paren
id|drive
comma
id|stat
comma
id|GET_ERR
c_func
(paren
)paren
)paren
suffix:semicolon
r_return
id|ide_stopped
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|OK_STAT
c_func
(paren
id|stat
comma
id|DATA_READY
comma
id|BAD_W_STAT
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * (ks) Unexpected ATA data phase detected.&n;&t;&t; * This should not happen. But, it can !&n;&t;&t; * I am not sure, which function is best to clean up&n;&t;&t; * this situation.  I choose: ide_error(...)&n;&t;&t; */
r_return
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|error
c_func
(paren
id|drive
comma
l_string|&quot;flagged_task_out_intr (unexpected data phase)&quot;
comma
id|stat
)paren
suffix:semicolon
)brace
id|pBuf
op_assign
id|rq-&gt;buffer
op_plus
(paren
(paren
id|rq-&gt;nr_sectors
op_minus
id|rq-&gt;current_nr_sectors
)paren
op_star
id|SECTOR_SIZE
)paren
suffix:semicolon
id|DTF
c_func
(paren
l_string|&quot;Write - rq-&gt;current_nr_sectors: %d, status: %02x&bslash;n&quot;
comma
(paren
r_int
)paren
id|rq-&gt;current_nr_sectors
comma
id|stat
)paren
suffix:semicolon
id|taskfile_output_data
c_func
(paren
id|drive
comma
id|pBuf
comma
id|SECTOR_WORDS
)paren
suffix:semicolon
op_decrement
id|rq-&gt;current_nr_sectors
suffix:semicolon
multiline_comment|/*&n;&t; * (ks) We don&squot;t know which command was executed. &n;&t; * So, we wait the &squot;WORSTCASE&squot; value.&n;&t; */
id|ide_set_handler
c_func
(paren
id|drive
comma
op_amp
id|flagged_task_out_intr
comma
id|WAIT_WORSTCASE
comma
l_int|NULL
)paren
suffix:semicolon
r_return
id|ide_started
suffix:semicolon
)brace
DECL|function|flagged_pre_task_mulout_intr
id|ide_startstop_t
id|flagged_pre_task_mulout_intr
(paren
id|ide_drive_t
op_star
id|drive
comma
r_struct
id|request
op_star
id|rq
)paren
(brace
id|byte
id|stat
op_assign
id|GET_STAT
c_func
(paren
)paren
suffix:semicolon
r_char
op_star
id|pBuf
op_assign
l_int|NULL
suffix:semicolon
id|ide_startstop_t
id|startstop
suffix:semicolon
r_int
r_int
id|msect
comma
id|nsect
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rq-&gt;current_nr_sectors
)paren
r_return
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|error
c_func
(paren
id|drive
comma
l_string|&quot;flagged_pre_task_mulout_intr (write data not specified)&quot;
comma
id|stat
)paren
suffix:semicolon
id|msect
op_assign
id|drive-&gt;mult_count
suffix:semicolon
r_if
c_cond
(paren
id|msect
op_eq
l_int|0
)paren
r_return
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|error
c_func
(paren
id|drive
comma
l_string|&quot;flagged_pre_task_mulout_intr (multimode not set)&quot;
comma
id|stat
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ide_wait_stat
c_func
(paren
op_amp
id|startstop
comma
id|drive
comma
id|DATA_READY
comma
id|BAD_W_STAT
comma
id|WAIT_DRQ
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: No DRQ bit after issuing write command.&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
r_return
id|startstop
suffix:semicolon
)brace
id|nsect
op_assign
(paren
id|rq-&gt;current_nr_sectors
OG
id|msect
)paren
ques
c_cond
id|msect
suffix:colon
id|rq-&gt;current_nr_sectors
suffix:semicolon
id|pBuf
op_assign
id|rq-&gt;buffer
op_plus
(paren
(paren
id|rq-&gt;nr_sectors
op_minus
id|rq-&gt;current_nr_sectors
)paren
op_star
id|SECTOR_SIZE
)paren
suffix:semicolon
id|DTF
c_func
(paren
l_string|&quot;Multiwrite: %p, nsect: %d , rq-&gt;current_nr_sectors: %ld&bslash;n&quot;
comma
id|pBuf
comma
id|nsect
comma
id|rq-&gt;current_nr_sectors
)paren
suffix:semicolon
id|taskfile_output_data
c_func
(paren
id|drive
comma
id|pBuf
comma
id|nsect
op_star
id|SECTOR_WORDS
)paren
suffix:semicolon
id|rq-&gt;current_nr_sectors
op_sub_assign
id|nsect
suffix:semicolon
r_return
id|ide_started
suffix:semicolon
)brace
DECL|function|flagged_task_mulout_intr
id|ide_startstop_t
id|flagged_task_mulout_intr
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|byte
id|stat
op_assign
id|GET_STAT
c_func
(paren
)paren
suffix:semicolon
r_struct
id|request
op_star
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
r_char
op_star
id|pBuf
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|msect
comma
id|nsect
suffix:semicolon
id|msect
op_assign
id|drive-&gt;mult_count
suffix:semicolon
r_if
c_cond
(paren
id|msect
op_eq
l_int|0
)paren
r_return
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|error
c_func
(paren
id|drive
comma
l_string|&quot;flagged_task_mulout_intr (multimode not set)&quot;
comma
id|stat
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|OK_STAT
c_func
(paren
id|stat
comma
id|DRIVE_READY
comma
id|BAD_W_STAT
)paren
)paren
r_return
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|error
c_func
(paren
id|drive
comma
l_string|&quot;flagged_task_mulout_intr&quot;
comma
id|stat
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rq-&gt;current_nr_sectors
)paren
(brace
id|ide_end_drive_cmd
(paren
id|drive
comma
id|stat
comma
id|GET_ERR
c_func
(paren
)paren
)paren
suffix:semicolon
r_return
id|ide_stopped
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|OK_STAT
c_func
(paren
id|stat
comma
id|DATA_READY
comma
id|BAD_W_STAT
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * (ks) Unexpected ATA data phase detected.&n;&t;&t; * This should not happen. But, it can !&n;&t;&t; * I am not sure, which function is best to clean up&n;&t;&t; * this situation.  I choose: ide_error(...)&n;&t;&t; */
r_return
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|error
c_func
(paren
id|drive
comma
l_string|&quot;flagged_task_mulout_intr (unexpected data phase)&quot;
comma
id|stat
)paren
suffix:semicolon
)brace
id|nsect
op_assign
(paren
id|rq-&gt;current_nr_sectors
OG
id|msect
)paren
ques
c_cond
id|msect
suffix:colon
id|rq-&gt;current_nr_sectors
suffix:semicolon
id|pBuf
op_assign
id|rq-&gt;buffer
op_plus
(paren
(paren
id|rq-&gt;nr_sectors
op_minus
id|rq-&gt;current_nr_sectors
)paren
op_star
id|SECTOR_SIZE
)paren
suffix:semicolon
id|DTF
c_func
(paren
l_string|&quot;Multiwrite: %p, nsect: %d , rq-&gt;current_nr_sectors: %ld&bslash;n&quot;
comma
id|pBuf
comma
id|nsect
comma
id|rq-&gt;current_nr_sectors
)paren
suffix:semicolon
id|taskfile_output_data
c_func
(paren
id|drive
comma
id|pBuf
comma
id|nsect
op_star
id|SECTOR_WORDS
)paren
suffix:semicolon
id|rq-&gt;current_nr_sectors
op_sub_assign
id|nsect
suffix:semicolon
multiline_comment|/*&n;&t; * (ks) We don&squot;t know which command was executed. &n;&t; * So, we wait the &squot;WORSTCASE&squot; value.&n;&t; */
id|ide_set_handler
c_func
(paren
id|drive
comma
op_amp
id|flagged_task_mulout_intr
comma
id|WAIT_WORSTCASE
comma
l_int|NULL
)paren
suffix:semicolon
r_return
id|ide_started
suffix:semicolon
)brace
multiline_comment|/*&n; * This function is intended to be used prior to invoking ide_do_drive_cmd().&n; */
DECL|function|ide_init_drive_taskfile
r_void
id|ide_init_drive_taskfile
(paren
r_struct
id|request
op_star
id|rq
)paren
(brace
id|memset
c_func
(paren
id|rq
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|rq
)paren
)paren
suffix:semicolon
id|rq-&gt;flags
op_assign
id|REQ_DRIVE_TASKFILE
suffix:semicolon
)brace
DECL|function|ide_diag_taskfile
r_int
id|ide_diag_taskfile
(paren
id|ide_drive_t
op_star
id|drive
comma
id|ide_task_t
op_star
id|args
comma
r_int
r_int
id|data_size
comma
id|byte
op_star
id|buf
)paren
(brace
r_struct
id|request
id|rq
suffix:semicolon
id|ide_init_drive_taskfile
c_func
(paren
op_amp
id|rq
)paren
suffix:semicolon
id|rq.flags
op_assign
id|REQ_DRIVE_TASKFILE
suffix:semicolon
id|rq.buffer
op_assign
id|buf
suffix:semicolon
multiline_comment|/*&n;&t; * (ks) We transfer currently only whole sectors.&n;&t; * This is suffient for now.  But, it would be great,&n;&t; * if we would find a solution to transfer any size.&n;&t; * To support special commands like READ LONG.&n;&t; */
r_if
c_cond
(paren
id|args-&gt;command_type
op_ne
id|IDE_DRIVE_TASK_NO_DATA
)paren
(brace
r_if
c_cond
(paren
id|data_size
op_eq
l_int|0
)paren
id|rq.current_nr_sectors
op_assign
id|rq.nr_sectors
op_assign
(paren
id|args-&gt;hobRegister
(braket
id|IDE_NSECTOR_OFFSET_HOB
)braket
op_lshift
l_int|8
)paren
op_or
id|args-&gt;tfRegister
(braket
id|IDE_NSECTOR_OFFSET
)braket
suffix:semicolon
multiline_comment|/*&t;rq.hard_cur_sectors&t;*/
r_else
id|rq.current_nr_sectors
op_assign
id|rq.nr_sectors
op_assign
id|data_size
op_div
id|SECTOR_SIZE
suffix:semicolon
multiline_comment|/*&t;rq.hard_cur_sectors&t;*/
)brace
r_if
c_cond
(paren
id|args-&gt;tf_out_flags.all
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * clean up kernel settings for driver sanity, regardless.&n;&t;&t; * except for discrete diag services.&n;&t;&t; */
id|args-&gt;posthandler
op_assign
id|ide_post_handler_parser
c_func
(paren
(paren
r_struct
id|hd_drive_task_hdr
op_star
)paren
id|args-&gt;tfRegister
comma
(paren
r_struct
id|hd_drive_hob_hdr
op_star
)paren
id|args-&gt;hobRegister
)paren
suffix:semicolon
)brace
id|rq.special
op_assign
id|args
suffix:semicolon
r_return
id|ide_do_drive_cmd
c_func
(paren
id|drive
comma
op_amp
id|rq
comma
id|ide_wait
)paren
suffix:semicolon
)brace
DECL|function|ide_raw_taskfile
r_int
id|ide_raw_taskfile
(paren
id|ide_drive_t
op_star
id|drive
comma
id|ide_task_t
op_star
id|args
comma
id|byte
op_star
id|buf
)paren
(brace
r_return
id|ide_diag_taskfile
c_func
(paren
id|drive
comma
id|args
comma
l_int|0
comma
id|buf
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_IDE_TASK_IOCTL_DEBUG
DECL|function|ide_ioctl_verbose
r_char
op_star
id|ide_ioctl_verbose
(paren
r_int
r_int
id|cmd
)paren
(brace
r_return
l_string|&quot;unknown&quot;
suffix:semicolon
)brace
DECL|function|ide_task_cmd_verbose
r_char
op_star
id|ide_task_cmd_verbose
(paren
id|byte
id|task
)paren
(brace
r_return
l_string|&quot;unknown&quot;
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_IDE_TASK_IOCTL_DEBUG */
DECL|macro|MAX_DMA
mdefine_line|#define MAX_DMA&t;&t;(256*SECTOR_WORDS)
DECL|function|ide_taskfile_ioctl
r_int
id|ide_taskfile_ioctl
(paren
id|ide_drive_t
op_star
id|drive
comma
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
id|ide_task_request_t
op_star
id|req_task
suffix:semicolon
id|ide_task_t
id|args
suffix:semicolon
id|byte
op_star
id|outbuf
op_assign
l_int|NULL
suffix:semicolon
id|byte
op_star
id|inbuf
op_assign
l_int|NULL
suffix:semicolon
id|task_ioreg_t
op_star
id|argsptr
op_assign
id|args.tfRegister
suffix:semicolon
id|task_ioreg_t
op_star
id|hobsptr
op_assign
id|args.hobRegister
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
r_int
id|tasksize
op_assign
r_sizeof
(paren
r_struct
id|ide_task_request_s
)paren
suffix:semicolon
r_int
id|taskin
op_assign
l_int|0
suffix:semicolon
r_int
id|taskout
op_assign
l_int|0
suffix:semicolon
id|byte
id|io_32bit
op_assign
id|drive-&gt;io_32bit
suffix:semicolon
singleline_comment|//&t;printk(&quot;IDE Taskfile ...&bslash;n&quot;);
id|req_task
op_assign
id|kmalloc
c_func
(paren
id|tasksize
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|req_task
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|memset
c_func
(paren
id|req_task
comma
l_int|0
comma
id|tasksize
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|req_task
comma
(paren
r_void
op_star
)paren
id|arg
comma
id|tasksize
)paren
)paren
(brace
id|kfree
c_func
(paren
id|req_task
)paren
suffix:semicolon
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
id|taskout
op_assign
(paren
r_int
)paren
id|req_task-&gt;out_size
suffix:semicolon
id|taskin
op_assign
(paren
r_int
)paren
id|req_task-&gt;in_size
suffix:semicolon
r_if
c_cond
(paren
id|taskout
)paren
(brace
r_int
id|outtotal
op_assign
id|tasksize
suffix:semicolon
id|outbuf
op_assign
id|kmalloc
c_func
(paren
id|taskout
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|outbuf
op_eq
l_int|NULL
)paren
(brace
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
id|memset
c_func
(paren
id|outbuf
comma
l_int|0
comma
id|taskout
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|outbuf
comma
(paren
r_void
op_star
)paren
id|arg
op_plus
id|outtotal
comma
id|taskout
)paren
)paren
(brace
id|err
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|taskin
)paren
(brace
r_int
id|intotal
op_assign
id|tasksize
op_plus
id|taskout
suffix:semicolon
id|inbuf
op_assign
id|kmalloc
c_func
(paren
id|taskin
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inbuf
op_eq
l_int|NULL
)paren
(brace
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
id|memset
c_func
(paren
id|inbuf
comma
l_int|0
comma
id|taskin
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|inbuf
comma
(paren
r_void
op_star
)paren
id|arg
op_plus
id|intotal
comma
id|taskin
)paren
)paren
(brace
id|err
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
)brace
id|memset
(paren
op_amp
id|args
comma
l_int|0
comma
r_sizeof
(paren
id|ide_task_t
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|argsptr
comma
id|req_task-&gt;io_ports
comma
id|HDIO_DRIVE_TASK_HDR_SIZE
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|hobsptr
comma
id|req_task-&gt;hob_ports
comma
id|HDIO_DRIVE_HOB_HDR_SIZE
)paren
suffix:semicolon
id|args.tf_in_flags
op_assign
id|req_task-&gt;in_flags
suffix:semicolon
id|args.tf_out_flags
op_assign
id|req_task-&gt;out_flags
suffix:semicolon
id|args.data_phase
op_assign
id|req_task-&gt;data_phase
suffix:semicolon
id|args.command_type
op_assign
id|req_task-&gt;req_cmd
suffix:semicolon
macro_line|#ifdef CONFIG_IDE_TASK_IOCTL_DEBUG
id|DTF
c_func
(paren
l_string|&quot;%s: ide_ioctl_cmd %s:  ide_task_cmd %s&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|ide_ioctl_verbose
c_func
(paren
id|cmd
)paren
comma
id|ide_task_cmd_verbose
c_func
(paren
id|args.tfRegister
(braket
id|IDE_COMMAND_OFFSET
)braket
)paren
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_IDE_TASK_IOCTL_DEBUG */
id|drive-&gt;io_32bit
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|req_task-&gt;data_phase
)paren
(brace
r_case
id|TASKFILE_OUT_DMAQ
suffix:colon
r_case
id|TASKFILE_OUT_DMA
suffix:colon
id|err
op_assign
id|ide_diag_taskfile
c_func
(paren
id|drive
comma
op_amp
id|args
comma
id|taskout
comma
id|outbuf
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TASKFILE_IN_DMAQ
suffix:colon
r_case
id|TASKFILE_IN_DMA
suffix:colon
id|err
op_assign
id|ide_diag_taskfile
c_func
(paren
id|drive
comma
op_amp
id|args
comma
id|taskin
comma
id|inbuf
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TASKFILE_IN_OUT
suffix:colon
macro_line|#if 0
id|args.prehandler
op_assign
op_amp
id|pre_task_out_intr
suffix:semicolon
id|args.handler
op_assign
op_amp
id|task_out_intr
suffix:semicolon
id|args.posthandler
op_assign
l_int|NULL
suffix:semicolon
id|err
op_assign
id|ide_diag_taskfile
c_func
(paren
id|drive
comma
op_amp
id|args
comma
id|taskout
comma
id|outbuf
)paren
suffix:semicolon
id|args.prehandler
op_assign
l_int|NULL
suffix:semicolon
id|args.handler
op_assign
op_amp
id|task_in_intr
suffix:semicolon
id|args.posthandler
op_assign
l_int|NULL
suffix:semicolon
id|err
op_assign
id|ide_diag_taskfile
c_func
(paren
id|drive
comma
op_amp
id|args
comma
id|taskin
comma
id|inbuf
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#else
id|err
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
m_abort
suffix:semicolon
macro_line|#endif
r_case
id|TASKFILE_MULTI_OUT
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|drive-&gt;mult_count
)paren
(brace
multiline_comment|/* (hs): give up if multcount is not set */
id|printk
c_func
(paren
l_string|&quot;%s: %s Multimode Write &quot;
"&bslash;"
l_string|&quot;multcount is not set&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|__FUNCTION__
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EPERM
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
r_if
c_cond
(paren
id|args.tf_out_flags.all
op_ne
l_int|0
)paren
(brace
id|args.prehandler
op_assign
op_amp
id|flagged_pre_task_mulout_intr
suffix:semicolon
id|args.handler
op_assign
op_amp
id|flagged_task_mulout_intr
suffix:semicolon
)brace
r_else
(brace
id|args.prehandler
op_assign
op_amp
id|pre_task_mulout_intr
suffix:semicolon
id|args.handler
op_assign
op_amp
id|task_mulout_intr
suffix:semicolon
)brace
id|err
op_assign
id|ide_diag_taskfile
c_func
(paren
id|drive
comma
op_amp
id|args
comma
id|taskout
comma
id|outbuf
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TASKFILE_OUT
suffix:colon
r_if
c_cond
(paren
id|args.tf_out_flags.all
op_ne
l_int|0
)paren
(brace
id|args.prehandler
op_assign
op_amp
id|flagged_pre_task_out_intr
suffix:semicolon
id|args.handler
op_assign
op_amp
id|flagged_task_out_intr
suffix:semicolon
)brace
r_else
(brace
id|args.prehandler
op_assign
op_amp
id|pre_task_out_intr
suffix:semicolon
id|args.handler
op_assign
op_amp
id|task_out_intr
suffix:semicolon
)brace
id|err
op_assign
id|ide_diag_taskfile
c_func
(paren
id|drive
comma
op_amp
id|args
comma
id|taskout
comma
id|outbuf
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TASKFILE_MULTI_IN
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|drive-&gt;mult_count
)paren
(brace
multiline_comment|/* (hs): give up if multcount is not set */
id|printk
c_func
(paren
l_string|&quot;%s: %s Multimode Read failure &quot;
"&bslash;"
l_string|&quot;multcount is not set&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|__FUNCTION__
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EPERM
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
r_if
c_cond
(paren
id|args.tf_out_flags.all
op_ne
l_int|0
)paren
(brace
id|args.handler
op_assign
op_amp
id|flagged_task_mulin_intr
suffix:semicolon
)brace
r_else
(brace
id|args.handler
op_assign
op_amp
id|task_mulin_intr
suffix:semicolon
)brace
id|err
op_assign
id|ide_diag_taskfile
c_func
(paren
id|drive
comma
op_amp
id|args
comma
id|taskin
comma
id|inbuf
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TASKFILE_IN
suffix:colon
r_if
c_cond
(paren
id|args.tf_out_flags.all
op_ne
l_int|0
)paren
(brace
id|args.handler
op_assign
op_amp
id|flagged_task_in_intr
suffix:semicolon
)brace
r_else
(brace
id|args.handler
op_assign
op_amp
id|task_in_intr
suffix:semicolon
)brace
id|err
op_assign
id|ide_diag_taskfile
c_func
(paren
id|drive
comma
op_amp
id|args
comma
id|taskin
comma
id|inbuf
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TASKFILE_NO_DATA
suffix:colon
r_if
c_cond
(paren
id|args.tf_out_flags.all
op_ne
l_int|0
)paren
(brace
id|args.handler
op_assign
op_amp
id|flagged_task_no_data_intr
suffix:semicolon
)brace
r_else
(brace
id|args.handler
op_assign
op_amp
id|task_no_data_intr
suffix:semicolon
)brace
id|err
op_assign
id|ide_diag_taskfile
c_func
(paren
id|drive
comma
op_amp
id|args
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|err
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|req_task-&gt;io_ports
comma
op_amp
(paren
id|args.tfRegister
)paren
comma
id|HDIO_DRIVE_TASK_HDR_SIZE
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|req_task-&gt;hob_ports
comma
op_amp
(paren
id|args.hobRegister
)paren
comma
id|HDIO_DRIVE_HOB_HDR_SIZE
)paren
suffix:semicolon
id|req_task-&gt;in_flags
op_assign
id|args.tf_in_flags
suffix:semicolon
id|req_task-&gt;out_flags
op_assign
id|args.tf_out_flags
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
id|req_task
comma
id|tasksize
)paren
)paren
(brace
id|err
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
r_if
c_cond
(paren
id|taskout
)paren
(brace
r_int
id|outtotal
op_assign
id|tasksize
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
op_plus
id|outtotal
comma
id|outbuf
comma
id|taskout
)paren
)paren
(brace
id|err
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|taskin
)paren
(brace
r_int
id|intotal
op_assign
id|tasksize
op_plus
id|taskout
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
op_plus
id|intotal
comma
id|inbuf
comma
id|taskin
)paren
)paren
(brace
id|err
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
)brace
m_abort
suffix:colon
id|kfree
c_func
(paren
id|req_task
)paren
suffix:semicolon
r_if
c_cond
(paren
id|outbuf
op_ne
l_int|NULL
)paren
id|kfree
c_func
(paren
id|outbuf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inbuf
op_ne
l_int|NULL
)paren
id|kfree
c_func
(paren
id|inbuf
)paren
suffix:semicolon
singleline_comment|//&t;printk(&quot;IDE Taskfile ioctl ended. rc = %i&bslash;n&quot;, err);
id|drive-&gt;io_32bit
op_assign
id|io_32bit
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
r_int
id|ide_ata66_check
(paren
id|ide_drive_t
op_star
id|drive
comma
id|ide_task_t
op_star
id|args
)paren
suffix:semicolon
r_int
id|set_transfer
c_func
(paren
id|ide_drive_t
op_star
id|drive
comma
id|ide_task_t
op_star
id|args
)paren
suffix:semicolon
multiline_comment|/*&n; * FIXME : this needs to map into at taskfile. &lt;andre@linux-ide.org&gt;&n; */
DECL|function|ide_cmd_ioctl
r_int
id|ide_cmd_ioctl
(paren
id|ide_drive_t
op_star
id|drive
comma
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
macro_line|#if 1
r_int
id|err
op_assign
l_int|0
suffix:semicolon
id|byte
id|args
(braket
l_int|4
)braket
comma
op_star
id|argbuf
op_assign
id|args
suffix:semicolon
id|byte
id|xfer_rate
op_assign
l_int|0
suffix:semicolon
r_int
id|argsize
op_assign
l_int|4
suffix:semicolon
id|ide_task_t
id|tfargs
suffix:semicolon
r_if
c_cond
(paren
l_int|NULL
op_eq
(paren
r_void
op_star
)paren
id|arg
)paren
(brace
r_struct
id|request
id|rq
suffix:semicolon
id|ide_init_drive_cmd
c_func
(paren
op_amp
id|rq
)paren
suffix:semicolon
r_return
id|ide_do_drive_cmd
c_func
(paren
id|drive
comma
op_amp
id|rq
comma
id|ide_wait
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|args
comma
(paren
r_void
op_star
)paren
id|arg
comma
l_int|4
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|tfargs
comma
l_int|0
comma
r_sizeof
(paren
id|ide_task_t
)paren
)paren
suffix:semicolon
id|tfargs.tfRegister
(braket
id|IDE_FEATURE_OFFSET
)braket
op_assign
id|args
(braket
l_int|2
)braket
suffix:semicolon
id|tfargs.tfRegister
(braket
id|IDE_NSECTOR_OFFSET
)braket
op_assign
id|args
(braket
l_int|3
)braket
suffix:semicolon
id|tfargs.tfRegister
(braket
id|IDE_SECTOR_OFFSET
)braket
op_assign
id|args
(braket
l_int|1
)braket
suffix:semicolon
id|tfargs.tfRegister
(braket
id|IDE_LCYL_OFFSET
)braket
op_assign
l_int|0x00
suffix:semicolon
id|tfargs.tfRegister
(braket
id|IDE_HCYL_OFFSET
)braket
op_assign
l_int|0x00
suffix:semicolon
id|tfargs.tfRegister
(braket
id|IDE_SELECT_OFFSET
)braket
op_assign
l_int|0x00
suffix:semicolon
id|tfargs.tfRegister
(braket
id|IDE_COMMAND_OFFSET
)braket
op_assign
id|args
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
id|args
(braket
l_int|3
)braket
)paren
(brace
id|argsize
op_assign
l_int|4
op_plus
(paren
id|SECTOR_WORDS
op_star
l_int|4
op_star
id|args
(braket
l_int|3
)braket
)paren
suffix:semicolon
id|argbuf
op_assign
id|kmalloc
c_func
(paren
id|argsize
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|argbuf
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|memcpy
c_func
(paren
id|argbuf
comma
id|args
comma
l_int|4
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|set_transfer
c_func
(paren
id|drive
comma
op_amp
id|tfargs
)paren
)paren
(brace
id|xfer_rate
op_assign
id|args
(braket
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
id|ide_ata66_check
c_func
(paren
id|drive
comma
op_amp
id|tfargs
)paren
)paren
r_goto
m_abort
suffix:semicolon
)brace
id|err
op_assign
id|ide_wait_cmd
c_func
(paren
id|drive
comma
id|args
(braket
l_int|0
)braket
comma
id|args
(braket
l_int|1
)braket
comma
id|args
(braket
l_int|2
)braket
comma
id|args
(braket
l_int|3
)braket
comma
id|argbuf
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|err
op_logical_and
id|xfer_rate
)paren
(brace
multiline_comment|/* active-retuning-calls future */
r_if
c_cond
(paren
(paren
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|speedproc
)paren
op_ne
l_int|NULL
)paren
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|speedproc
c_func
(paren
id|drive
comma
id|xfer_rate
)paren
suffix:semicolon
id|ide_driveid_update
c_func
(paren
id|drive
)paren
suffix:semicolon
)brace
m_abort
suffix:colon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
id|argbuf
comma
id|argsize
)paren
)paren
id|err
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|argsize
OG
l_int|4
)paren
id|kfree
c_func
(paren
id|argbuf
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
macro_line|#else
r_int
id|err
op_assign
l_int|0
suffix:semicolon
id|byte
id|args
(braket
l_int|4
)braket
comma
op_star
id|argbuf
op_assign
id|args
suffix:semicolon
id|byte
id|xfer_rate
op_assign
l_int|0
suffix:semicolon
r_int
id|argsize
op_assign
l_int|0
suffix:semicolon
id|ide_task_t
id|tfargs
suffix:semicolon
r_if
c_cond
(paren
l_int|NULL
op_eq
(paren
r_void
op_star
)paren
id|arg
)paren
(brace
r_struct
id|request
id|rq
suffix:semicolon
id|ide_init_drive_cmd
c_func
(paren
op_amp
id|rq
)paren
suffix:semicolon
r_return
id|ide_do_drive_cmd
c_func
(paren
id|drive
comma
op_amp
id|rq
comma
id|ide_wait
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|args
comma
(paren
r_void
op_star
)paren
id|arg
comma
l_int|4
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|tfargs
comma
l_int|0
comma
r_sizeof
(paren
id|ide_task_t
)paren
)paren
suffix:semicolon
id|tfargs.tfRegister
(braket
id|IDE_FEATURE_OFFSET
)braket
op_assign
id|args
(braket
l_int|2
)braket
suffix:semicolon
id|tfargs.tfRegister
(braket
id|IDE_NSECTOR_OFFSET
)braket
op_assign
id|args
(braket
l_int|3
)braket
suffix:semicolon
id|tfargs.tfRegister
(braket
id|IDE_SECTOR_OFFSET
)braket
op_assign
id|args
(braket
l_int|1
)braket
suffix:semicolon
id|tfargs.tfRegister
(braket
id|IDE_LCYL_OFFSET
)braket
op_assign
l_int|0x00
suffix:semicolon
id|tfargs.tfRegister
(braket
id|IDE_HCYL_OFFSET
)braket
op_assign
l_int|0x00
suffix:semicolon
id|tfargs.tfRegister
(braket
id|IDE_SELECT_OFFSET
)braket
op_assign
l_int|0x00
suffix:semicolon
id|tfargs.tfRegister
(braket
id|IDE_COMMAND_OFFSET
)braket
op_assign
id|args
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
id|args
(braket
l_int|3
)braket
)paren
(brace
id|argsize
op_assign
(paren
id|SECTOR_WORDS
op_star
l_int|4
op_star
id|args
(braket
l_int|3
)braket
)paren
suffix:semicolon
id|argbuf
op_assign
id|kmalloc
c_func
(paren
id|argsize
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|argbuf
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_if
c_cond
(paren
id|set_transfer
c_func
(paren
id|drive
comma
op_amp
id|tfargs
)paren
)paren
(brace
id|xfer_rate
op_assign
id|args
(braket
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
id|ide_ata66_check
c_func
(paren
id|drive
comma
op_amp
id|tfargs
)paren
)paren
r_goto
m_abort
suffix:semicolon
)brace
id|tfargs.command_type
op_assign
id|ide_cmd_type_parser
c_func
(paren
op_amp
id|tfargs
)paren
suffix:semicolon
id|err
op_assign
id|ide_raw_taskfile
c_func
(paren
id|drive
comma
op_amp
id|tfargs
comma
id|argbuf
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|err
op_logical_and
id|xfer_rate
)paren
(brace
multiline_comment|/* active-retuning-calls future */
r_if
c_cond
(paren
(paren
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|speedproc
)paren
op_ne
l_int|NULL
)paren
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|speedproc
c_func
(paren
id|drive
comma
id|xfer_rate
)paren
suffix:semicolon
id|ide_driveid_update
c_func
(paren
id|drive
)paren
suffix:semicolon
)brace
m_abort
suffix:colon
id|args
(braket
l_int|0
)braket
op_assign
id|tfargs.tfRegister
(braket
id|IDE_COMMAND_OFFSET
)braket
suffix:semicolon
id|args
(braket
l_int|1
)braket
op_assign
id|tfargs.tfRegister
(braket
id|IDE_FEATURE_OFFSET
)braket
suffix:semicolon
id|args
(braket
l_int|2
)braket
op_assign
id|tfargs.tfRegister
(braket
id|IDE_NSECTOR_OFFSET
)braket
suffix:semicolon
id|args
(braket
l_int|3
)braket
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
id|argbuf
comma
l_int|4
)paren
)paren
id|err
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|argbuf
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
id|argbuf
op_plus
l_int|4
comma
id|argsize
)paren
)paren
id|err
op_assign
op_minus
id|EFAULT
suffix:semicolon
id|kfree
c_func
(paren
id|argbuf
)paren
suffix:semicolon
)brace
r_return
id|err
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n; * FIXME : this needs to map into at taskfile. &lt;andre@linux-ide.org&gt;&n; */
DECL|function|ide_task_ioctl
r_int
id|ide_task_ioctl
(paren
id|ide_drive_t
op_star
id|drive
comma
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_int
id|err
op_assign
l_int|0
suffix:semicolon
id|byte
id|args
(braket
l_int|7
)braket
comma
op_star
id|argbuf
op_assign
id|args
suffix:semicolon
r_int
id|argsize
op_assign
l_int|7
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|args
comma
(paren
r_void
op_star
)paren
id|arg
comma
l_int|7
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|err
op_assign
id|ide_wait_cmd_task
c_func
(paren
id|drive
comma
id|argbuf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
id|argbuf
comma
id|argsize
)paren
)paren
id|err
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|variable|drive_is_ready
id|EXPORT_SYMBOL
c_func
(paren
id|drive_is_ready
)paren
suffix:semicolon
DECL|variable|wait_for_ready
id|EXPORT_SYMBOL
c_func
(paren
id|wait_for_ready
)paren
suffix:semicolon
DECL|variable|task_read_24
id|EXPORT_SYMBOL
c_func
(paren
id|task_read_24
)paren
suffix:semicolon
DECL|variable|ata_input_data
id|EXPORT_SYMBOL
c_func
(paren
id|ata_input_data
)paren
suffix:semicolon
DECL|variable|ata_output_data
id|EXPORT_SYMBOL
c_func
(paren
id|ata_output_data
)paren
suffix:semicolon
DECL|variable|atapi_input_bytes
id|EXPORT_SYMBOL
c_func
(paren
id|atapi_input_bytes
)paren
suffix:semicolon
DECL|variable|atapi_output_bytes
id|EXPORT_SYMBOL
c_func
(paren
id|atapi_output_bytes
)paren
suffix:semicolon
DECL|variable|taskfile_input_data
id|EXPORT_SYMBOL
c_func
(paren
id|taskfile_input_data
)paren
suffix:semicolon
DECL|variable|taskfile_output_data
id|EXPORT_SYMBOL
c_func
(paren
id|taskfile_output_data
)paren
suffix:semicolon
DECL|variable|ide_wait_stat
id|EXPORT_SYMBOL
c_func
(paren
id|ide_wait_stat
)paren
suffix:semicolon
DECL|variable|do_rw_taskfile
id|EXPORT_SYMBOL
c_func
(paren
id|do_rw_taskfile
)paren
suffix:semicolon
DECL|variable|flagged_taskfile
id|EXPORT_SYMBOL
c_func
(paren
id|flagged_taskfile
)paren
suffix:semicolon
DECL|variable|ide_end_taskfile
id|EXPORT_SYMBOL
c_func
(paren
id|ide_end_taskfile
)paren
suffix:semicolon
DECL|variable|set_multmode_intr
id|EXPORT_SYMBOL
c_func
(paren
id|set_multmode_intr
)paren
suffix:semicolon
DECL|variable|set_geometry_intr
id|EXPORT_SYMBOL
c_func
(paren
id|set_geometry_intr
)paren
suffix:semicolon
DECL|variable|recal_intr
id|EXPORT_SYMBOL
c_func
(paren
id|recal_intr
)paren
suffix:semicolon
DECL|variable|task_no_data_intr
id|EXPORT_SYMBOL
c_func
(paren
id|task_no_data_intr
)paren
suffix:semicolon
DECL|variable|task_in_intr
id|EXPORT_SYMBOL
c_func
(paren
id|task_in_intr
)paren
suffix:semicolon
DECL|variable|task_mulin_intr
id|EXPORT_SYMBOL
c_func
(paren
id|task_mulin_intr
)paren
suffix:semicolon
DECL|variable|pre_task_out_intr
id|EXPORT_SYMBOL
c_func
(paren
id|pre_task_out_intr
)paren
suffix:semicolon
DECL|variable|task_out_intr
id|EXPORT_SYMBOL
c_func
(paren
id|task_out_intr
)paren
suffix:semicolon
DECL|variable|pre_task_mulout_intr
id|EXPORT_SYMBOL
c_func
(paren
id|pre_task_mulout_intr
)paren
suffix:semicolon
DECL|variable|task_mulout_intr
id|EXPORT_SYMBOL
c_func
(paren
id|task_mulout_intr
)paren
suffix:semicolon
DECL|variable|ide_init_drive_taskfile
id|EXPORT_SYMBOL
c_func
(paren
id|ide_init_drive_taskfile
)paren
suffix:semicolon
DECL|variable|ide_raw_taskfile
id|EXPORT_SYMBOL
c_func
(paren
id|ide_raw_taskfile
)paren
suffix:semicolon
DECL|variable|ide_pre_handler_parser
id|EXPORT_SYMBOL
c_func
(paren
id|ide_pre_handler_parser
)paren
suffix:semicolon
DECL|variable|ide_handler_parser
id|EXPORT_SYMBOL
c_func
(paren
id|ide_handler_parser
)paren
suffix:semicolon
DECL|variable|ide_post_handler_parser
id|EXPORT_SYMBOL
c_func
(paren
id|ide_post_handler_parser
)paren
suffix:semicolon
DECL|variable|ide_cmd_type_parser
id|EXPORT_SYMBOL
c_func
(paren
id|ide_cmd_type_parser
)paren
suffix:semicolon
DECL|variable|ide_taskfile_ioctl
id|EXPORT_SYMBOL
c_func
(paren
id|ide_taskfile_ioctl
)paren
suffix:semicolon
DECL|variable|ide_cmd_ioctl
id|EXPORT_SYMBOL
c_func
(paren
id|ide_cmd_ioctl
)paren
suffix:semicolon
DECL|variable|ide_task_ioctl
id|EXPORT_SYMBOL
c_func
(paren
id|ide_task_ioctl
)paren
suffix:semicolon
multiline_comment|/*&n; * Beginning of Taskfile OPCODE Library and feature sets.&n; */
multiline_comment|/*&n; *  All hosts that use the 80c ribbon must use!&n; *  The name is derived from upper byte of word 93 and the 80c ribbon.&n; */
DECL|function|eighty_ninty_three
id|byte
id|eighty_ninty_three
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
macro_line|#if 0
r_if
c_cond
(paren
op_logical_neg
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|udma_four
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;id-&gt;major_rev_num
)paren
(brace
r_int
id|hssbd
op_assign
l_int|0
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Determime highest Supported SPEC&n;&t;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
op_le
l_int|15
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|drive-&gt;id-&gt;major_rev_num
op_amp
(paren
l_int|1
op_lshift
id|i
)paren
)paren
id|hssbd
op_increment
suffix:semicolon
r_switch
c_cond
(paren
id|hssbd
)paren
(brace
r_case
l_int|7
suffix:colon
r_case
l_int|6
suffix:colon
r_case
l_int|5
suffix:colon
multiline_comment|/* ATA-4 and older do not support above Ultra 33 */
r_default
suffix:colon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_return
(paren
(paren
id|byte
)paren
(paren
macro_line|#ifndef CONFIG_IDEDMA_IVB
(paren
id|drive-&gt;id-&gt;hw_config
op_amp
l_int|0x4000
)paren
op_logical_and
macro_line|#endif /* CONFIG_IDEDMA_IVB */
(paren
id|drive-&gt;id-&gt;hw_config
op_amp
l_int|0x6000
)paren
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
)paren
suffix:semicolon
macro_line|#else
r_return
(paren
(paren
id|byte
)paren
(paren
(paren
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|udma_four
)paren
op_logical_and
macro_line|#ifndef CONFIG_IDEDMA_IVB
(paren
id|drive-&gt;id-&gt;hw_config
op_amp
l_int|0x4000
)paren
op_logical_and
macro_line|#endif /* CONFIG_IDEDMA_IVB */
(paren
id|drive-&gt;id-&gt;hw_config
op_amp
l_int|0x6000
)paren
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
)paren
suffix:semicolon
macro_line|#endif
)brace
DECL|function|ide_ata66_check
r_int
id|ide_ata66_check
(paren
id|ide_drive_t
op_star
id|drive
comma
id|ide_task_t
op_star
id|args
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|udma_four
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: Speed warnings UDMA 3/4/5 is not functional.&bslash;n&quot;
comma
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|name
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|args-&gt;tfRegister
(braket
id|IDE_COMMAND_OFFSET
)braket
op_eq
id|WIN_SETFEATURES
)paren
op_logical_and
(paren
id|args-&gt;tfRegister
(braket
id|IDE_SECTOR_OFFSET
)braket
OG
id|XFER_UDMA_2
)paren
op_logical_and
(paren
id|args-&gt;tfRegister
(braket
id|IDE_FEATURE_OFFSET
)braket
op_eq
id|SETFEATURES_XFER
)paren
)paren
(brace
macro_line|#ifndef CONFIG_IDEDMA_IVB
r_if
c_cond
(paren
(paren
id|drive-&gt;id-&gt;hw_config
op_amp
l_int|0x6000
)paren
op_eq
l_int|0
)paren
(brace
macro_line|#else /* !CONFIG_IDEDMA_IVB */
r_if
c_cond
(paren
(paren
(paren
id|drive-&gt;id-&gt;hw_config
op_amp
l_int|0x2000
)paren
op_eq
l_int|0
)paren
op_logical_or
(paren
(paren
id|drive-&gt;id-&gt;hw_config
op_amp
l_int|0x4000
)paren
op_eq
l_int|0
)paren
)paren
(brace
macro_line|#endif /* CONFIG_IDEDMA_IVB */
id|printk
c_func
(paren
l_string|&quot;%s: Speed warnings UDMA 3/4/5 is not functional.&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Backside of HDIO_DRIVE_CMD call of SETFEATURES_XFER.&n; * 1 : Safe to update drive-&gt;id DMA registers.&n; * 0 : OOPs not allowed.&n; */
DECL|function|set_transfer
r_int
id|set_transfer
(paren
id|ide_drive_t
op_star
id|drive
comma
id|ide_task_t
op_star
id|args
)paren
(brace
r_if
c_cond
(paren
(paren
id|args-&gt;tfRegister
(braket
id|IDE_COMMAND_OFFSET
)braket
op_eq
id|WIN_SETFEATURES
)paren
op_logical_and
(paren
id|args-&gt;tfRegister
(braket
id|IDE_SECTOR_OFFSET
)braket
op_ge
id|XFER_SW_DMA_0
)paren
op_logical_and
(paren
id|args-&gt;tfRegister
(braket
id|IDE_FEATURE_OFFSET
)braket
op_eq
id|SETFEATURES_XFER
)paren
op_logical_and
(paren
id|drive-&gt;id-&gt;dma_ultra
op_logical_or
id|drive-&gt;id-&gt;dma_mword
op_logical_or
id|drive-&gt;id-&gt;dma_1word
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ide_auto_reduce_xfer
id|byte
id|ide_auto_reduce_xfer
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|drive-&gt;crc_count
)paren
r_return
id|drive-&gt;current_speed
suffix:semicolon
id|drive-&gt;crc_count
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|drive-&gt;current_speed
)paren
(brace
r_case
id|XFER_UDMA_7
suffix:colon
r_return
id|XFER_UDMA_6
suffix:semicolon
r_case
id|XFER_UDMA_6
suffix:colon
r_return
id|XFER_UDMA_5
suffix:semicolon
r_case
id|XFER_UDMA_5
suffix:colon
r_return
id|XFER_UDMA_4
suffix:semicolon
r_case
id|XFER_UDMA_4
suffix:colon
r_return
id|XFER_UDMA_3
suffix:semicolon
r_case
id|XFER_UDMA_3
suffix:colon
r_return
id|XFER_UDMA_2
suffix:semicolon
r_case
id|XFER_UDMA_2
suffix:colon
r_return
id|XFER_UDMA_1
suffix:semicolon
r_case
id|XFER_UDMA_1
suffix:colon
r_return
id|XFER_UDMA_0
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * OOPS we do not goto non Ultra DMA modes&n;&t;&t;&t; * without iCRC&squot;s available we force&n;&t;&t;&t; * the system to PIO and make the user&n;&t;&t;&t; * invoke the ATA-1 ATA-2 DMA modes.&n;&t;&t;&t; */
r_case
id|XFER_UDMA_0
suffix:colon
r_default
suffix:colon
r_return
id|XFER_PIO_4
suffix:semicolon
)brace
)brace
DECL|function|taskfile_lib_get_identify
r_int
id|taskfile_lib_get_identify
(paren
id|ide_drive_t
op_star
id|drive
comma
id|byte
op_star
id|buf
)paren
(brace
id|ide_task_t
id|args
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|args
comma
l_int|0
comma
r_sizeof
(paren
id|ide_task_t
)paren
)paren
suffix:semicolon
id|args.tfRegister
(braket
id|IDE_NSECTOR_OFFSET
)braket
op_assign
l_int|0x01
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;media
op_eq
id|ide_disk
)paren
id|args.tfRegister
(braket
id|IDE_COMMAND_OFFSET
)braket
op_assign
id|WIN_IDENTIFY
suffix:semicolon
r_else
id|args.tfRegister
(braket
id|IDE_COMMAND_OFFSET
)braket
op_assign
id|WIN_PIDENTIFY
suffix:semicolon
id|args.command_type
op_assign
id|ide_cmd_type_parser
c_func
(paren
op_amp
id|args
)paren
suffix:semicolon
r_return
id|ide_raw_taskfile
c_func
(paren
id|drive
comma
op_amp
id|args
comma
id|buf
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Update the &n; */
DECL|function|ide_driveid_update
r_int
id|ide_driveid_update
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
macro_line|#if 0
r_struct
id|hd_driveid
op_star
id|id
suffix:semicolon
id|id
op_assign
id|kmalloc
c_func
(paren
id|SECTOR_WORDS
op_star
l_int|4
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|id
)paren
r_return
l_int|0
suffix:semicolon
id|taskfile_lib_get_identify
c_func
(paren
id|drive
comma
(paren
r_char
op_star
)paren
op_amp
id|id
)paren
suffix:semicolon
id|ide_fix_driveid
c_func
(paren
id|id
)paren
suffix:semicolon
r_if
c_cond
(paren
id|id
)paren
(brace
id|drive-&gt;id-&gt;dma_ultra
op_assign
id|id-&gt;dma_ultra
suffix:semicolon
id|drive-&gt;id-&gt;dma_mword
op_assign
id|id-&gt;dma_mword
suffix:semicolon
id|drive-&gt;id-&gt;dma_1word
op_assign
id|id-&gt;dma_1word
suffix:semicolon
multiline_comment|/* anything more ? */
id|kfree
c_func
(paren
id|id
)paren
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
macro_line|#else
multiline_comment|/*&n;&t; * Re-read drive-&gt;id for possible DMA mode&n;&t; * change (copied from ide-probe.c)&n;&t; */
r_struct
id|hd_driveid
op_star
id|id
suffix:semicolon
r_int
r_int
id|timeout
comma
id|flags
suffix:semicolon
id|SELECT_MASK
c_func
(paren
id|HWIF
c_func
(paren
id|drive
)paren
comma
id|drive
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IDE_CONTROL_REG
)paren
id|OUT_BYTE
c_func
(paren
id|drive-&gt;ctl
comma
id|IDE_CONTROL_REG
)paren
suffix:semicolon
id|ide_delay_50ms
c_func
(paren
)paren
suffix:semicolon
id|OUT_BYTE
c_func
(paren
id|WIN_IDENTIFY
comma
id|IDE_COMMAND_REG
)paren
suffix:semicolon
id|timeout
op_assign
id|jiffies
op_plus
id|WAIT_WORSTCASE
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|time_after
c_func
(paren
id|jiffies
comma
id|timeout
)paren
)paren
(brace
id|SELECT_MASK
c_func
(paren
id|HWIF
c_func
(paren
id|drive
)paren
comma
id|drive
comma
l_int|0
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/* drive timed-out */
)brace
id|ide_delay_50ms
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* give drive a breather */
)brace
r_while
c_loop
(paren
id|IN_BYTE
c_func
(paren
id|IDE_ALTSTATUS_REG
)paren
op_amp
id|BUSY_STAT
)paren
suffix:semicolon
id|ide_delay_50ms
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* wait for IRQ and DRQ_STAT */
r_if
c_cond
(paren
op_logical_neg
id|OK_STAT
c_func
(paren
id|GET_STAT
c_func
(paren
)paren
comma
id|DRQ_STAT
comma
id|BAD_R_STAT
)paren
)paren
(brace
id|SELECT_MASK
c_func
(paren
id|HWIF
c_func
(paren
id|drive
)paren
comma
id|drive
comma
l_int|0
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: CHECK for good STATUS&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|local_irq_save
c_func
(paren
id|flags
)paren
suffix:semicolon
id|SELECT_MASK
c_func
(paren
id|HWIF
c_func
(paren
id|drive
)paren
comma
id|drive
comma
l_int|0
)paren
suffix:semicolon
id|id
op_assign
id|kmalloc
c_func
(paren
id|SECTOR_WORDS
op_star
l_int|4
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|id
)paren
(brace
id|local_irq_restore
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|ata_input_data
c_func
(paren
id|drive
comma
id|id
comma
id|SECTOR_WORDS
)paren
suffix:semicolon
(paren
r_void
)paren
id|GET_STAT
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* clear drive IRQ */
id|local_irq_enable
c_func
(paren
)paren
suffix:semicolon
id|local_irq_restore
c_func
(paren
id|flags
)paren
suffix:semicolon
id|ide_fix_driveid
c_func
(paren
id|id
)paren
suffix:semicolon
r_if
c_cond
(paren
id|id
)paren
(brace
id|drive-&gt;id-&gt;dma_ultra
op_assign
id|id-&gt;dma_ultra
suffix:semicolon
id|drive-&gt;id-&gt;dma_mword
op_assign
id|id-&gt;dma_mword
suffix:semicolon
id|drive-&gt;id-&gt;dma_1word
op_assign
id|id-&gt;dma_1word
suffix:semicolon
multiline_comment|/* anything more ? */
id|kfree
c_func
(paren
id|id
)paren
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n; * Similar to ide_wait_stat(), except it never calls ide_error internally.&n; * This is a kludge to handle the new ide_config_drive_speed() function,&n; * and should not otherwise be used anywhere.  Eventually, the tuneproc&squot;s&n; * should be updated to return ide_startstop_t, in which case we can get&n; * rid of this abomination again.  :)   -ml&n; *&n; * It is gone..........&n; *&n; * const char *msg == consider adding for verbose errors.&n; */
DECL|function|ide_config_drive_speed
r_int
id|ide_config_drive_speed
(paren
id|ide_drive_t
op_star
id|drive
comma
id|byte
id|speed
)paren
(brace
id|ide_hwif_t
op_star
id|hwif
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
suffix:semicolon
r_int
id|i
comma
id|error
op_assign
l_int|1
suffix:semicolon
id|byte
id|stat
suffix:semicolon
macro_line|#if defined(CONFIG_BLK_DEV_IDEDMA) &amp;&amp; !defined(CONFIG_DMA_NONPCI)
id|hwif
op_member_access_from_pointer
id|dmaproc
c_func
(paren
id|ide_dma_host_off
comma
id|drive
)paren
suffix:semicolon
macro_line|#endif /* (CONFIG_BLK_DEV_IDEDMA) &amp;&amp; !(CONFIG_DMA_NONPCI) */
multiline_comment|/*&n;&t; * Don&squot;t use ide_wait_cmd here - it will&n;&t; * attempt to set_geometry and recalibrate,&n;&t; * but for some reason these don&squot;t work at&n;&t; * this point (lost interrupt).&n;&t; */
multiline_comment|/*&n;         * Select the drive, and issue the SETFEATURES command&n;         */
id|disable_irq
c_func
(paren
id|hwif-&gt;irq
)paren
suffix:semicolon
multiline_comment|/* disable_irq_nosync ?? */
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|SELECT_DRIVE
c_func
(paren
id|HWIF
c_func
(paren
id|drive
)paren
comma
id|drive
)paren
suffix:semicolon
id|SELECT_MASK
c_func
(paren
id|HWIF
c_func
(paren
id|drive
)paren
comma
id|drive
comma
l_int|0
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IDE_CONTROL_REG
)paren
id|OUT_BYTE
c_func
(paren
id|drive-&gt;ctl
op_or
l_int|2
comma
id|IDE_CONTROL_REG
)paren
suffix:semicolon
id|OUT_BYTE
c_func
(paren
id|speed
comma
id|IDE_NSECTOR_REG
)paren
suffix:semicolon
id|OUT_BYTE
c_func
(paren
id|SETFEATURES_XFER
comma
id|IDE_FEATURE_REG
)paren
suffix:semicolon
id|OUT_BYTE
c_func
(paren
id|WIN_SETFEATURES
comma
id|IDE_COMMAND_REG
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|IDE_CONTROL_REG
)paren
op_logical_and
(paren
id|drive-&gt;quirk_list
op_eq
l_int|2
)paren
)paren
id|OUT_BYTE
c_func
(paren
id|drive-&gt;ctl
comma
id|IDE_CONTROL_REG
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Wait for drive to become non-BUSY&n;&t; */
r_if
c_cond
(paren
(paren
id|stat
op_assign
id|GET_STAT
c_func
(paren
)paren
)paren
op_amp
id|BUSY_STAT
)paren
(brace
r_int
r_int
id|flags
comma
id|timeout
suffix:semicolon
id|local_irq_set
c_func
(paren
id|flags
)paren
suffix:semicolon
id|timeout
op_assign
id|jiffies
op_plus
id|WAIT_CMD
suffix:semicolon
r_while
c_loop
(paren
(paren
id|stat
op_assign
id|GET_STAT
c_func
(paren
)paren
)paren
op_amp
id|BUSY_STAT
)paren
(brace
r_if
c_cond
(paren
id|time_after
c_func
(paren
id|jiffies
comma
id|timeout
)paren
)paren
r_break
suffix:semicolon
)brace
id|local_irq_restore
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Allow status to settle, then read it again.&n;&t; * A few rare drives vastly violate the 400ns spec here,&n;&t; * so we&squot;ll wait up to 10usec for a &quot;good&quot; status&n;&t; * rather than expensively fail things immediately.&n;&t; * This fix courtesy of Matthew Faupel &amp; Niccolo Rigacci.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|10
suffix:semicolon
id|i
op_increment
)paren
(brace
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|OK_STAT
c_func
(paren
(paren
id|stat
op_assign
id|GET_STAT
c_func
(paren
)paren
)paren
comma
id|DRIVE_READY
comma
id|BUSY_STAT
op_or
id|DRQ_STAT
op_or
id|ERR_STAT
)paren
)paren
(brace
id|error
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|SELECT_MASK
c_func
(paren
id|HWIF
c_func
(paren
id|drive
)paren
comma
id|drive
comma
l_int|0
)paren
suffix:semicolon
id|enable_irq
c_func
(paren
id|hwif-&gt;irq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
(paren
r_void
)paren
id|ide_dump_status
c_func
(paren
id|drive
comma
l_string|&quot;set_drive_speed_status&quot;
comma
id|stat
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
id|drive-&gt;id-&gt;dma_ultra
op_and_assign
op_complement
l_int|0xFF00
suffix:semicolon
id|drive-&gt;id-&gt;dma_mword
op_and_assign
op_complement
l_int|0x0F00
suffix:semicolon
id|drive-&gt;id-&gt;dma_1word
op_and_assign
op_complement
l_int|0x0F00
suffix:semicolon
macro_line|#if defined(CONFIG_BLK_DEV_IDEDMA) &amp;&amp; !defined(CONFIG_DMA_NONPCI)
r_if
c_cond
(paren
id|speed
op_ge
id|XFER_SW_DMA_0
)paren
id|hwif
op_member_access_from_pointer
id|dmaproc
c_func
(paren
id|ide_dma_host_on
comma
id|drive
)paren
suffix:semicolon
macro_line|#endif /* (CONFIG_BLK_DEV_IDEDMA) &amp;&amp; !(CONFIG_DMA_NONPCI) */
r_switch
c_cond
(paren
id|speed
)paren
(brace
r_case
id|XFER_UDMA_7
suffix:colon
id|drive-&gt;id-&gt;dma_ultra
op_or_assign
l_int|0x8080
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XFER_UDMA_6
suffix:colon
id|drive-&gt;id-&gt;dma_ultra
op_or_assign
l_int|0x4040
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XFER_UDMA_5
suffix:colon
id|drive-&gt;id-&gt;dma_ultra
op_or_assign
l_int|0x2020
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XFER_UDMA_4
suffix:colon
id|drive-&gt;id-&gt;dma_ultra
op_or_assign
l_int|0x1010
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XFER_UDMA_3
suffix:colon
id|drive-&gt;id-&gt;dma_ultra
op_or_assign
l_int|0x0808
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XFER_UDMA_2
suffix:colon
id|drive-&gt;id-&gt;dma_ultra
op_or_assign
l_int|0x0404
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XFER_UDMA_1
suffix:colon
id|drive-&gt;id-&gt;dma_ultra
op_or_assign
l_int|0x0202
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XFER_UDMA_0
suffix:colon
id|drive-&gt;id-&gt;dma_ultra
op_or_assign
l_int|0x0101
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XFER_MW_DMA_2
suffix:colon
id|drive-&gt;id-&gt;dma_mword
op_or_assign
l_int|0x0404
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XFER_MW_DMA_1
suffix:colon
id|drive-&gt;id-&gt;dma_mword
op_or_assign
l_int|0x0202
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XFER_MW_DMA_0
suffix:colon
id|drive-&gt;id-&gt;dma_mword
op_or_assign
l_int|0x0101
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XFER_SW_DMA_2
suffix:colon
id|drive-&gt;id-&gt;dma_1word
op_or_assign
l_int|0x0404
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XFER_SW_DMA_1
suffix:colon
id|drive-&gt;id-&gt;dma_1word
op_or_assign
l_int|0x0202
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XFER_SW_DMA_0
suffix:colon
id|drive-&gt;id-&gt;dma_1word
op_or_assign
l_int|0x0101
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|drive-&gt;init_speed
)paren
id|drive-&gt;init_speed
op_assign
id|speed
suffix:semicolon
id|drive-&gt;current_speed
op_assign
id|speed
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
DECL|variable|eighty_ninty_three
id|EXPORT_SYMBOL
c_func
(paren
id|eighty_ninty_three
)paren
suffix:semicolon
DECL|variable|ide_auto_reduce_xfer
id|EXPORT_SYMBOL
c_func
(paren
id|ide_auto_reduce_xfer
)paren
suffix:semicolon
DECL|variable|set_transfer
id|EXPORT_SYMBOL
c_func
(paren
id|set_transfer
)paren
suffix:semicolon
DECL|variable|taskfile_lib_get_identify
id|EXPORT_SYMBOL
c_func
(paren
id|taskfile_lib_get_identify
)paren
suffix:semicolon
DECL|variable|ide_driveid_update
id|EXPORT_SYMBOL
c_func
(paren
id|ide_driveid_update
)paren
suffix:semicolon
DECL|variable|ide_config_drive_speed
id|EXPORT_SYMBOL
c_func
(paren
id|ide_config_drive_speed
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_PKT_TASK_IOCTL
macro_line|#if 0
(brace
(brace
multiline_comment|/* start cdrom */
r_struct
id|cdrom_info
op_star
id|info
op_assign
id|drive-&gt;driver_data
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;dma
)paren
(brace
r_if
c_cond
(paren
id|info-&gt;cmd
op_eq
id|READ
)paren
(brace
id|info-&gt;dma
op_assign
op_logical_neg
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|dmaproc
c_func
(paren
id|ide_dma_read
comma
id|drive
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|info-&gt;cmd
op_eq
id|WRITE
)paren
(brace
id|info-&gt;dma
op_assign
op_logical_neg
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|dmaproc
c_func
(paren
id|ide_dma_write
comma
id|drive
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;ide-cd: DMA set, but not allowed&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Set up the controller registers. */
id|OUT_BYTE
(paren
id|info-&gt;dma
comma
id|IDE_FEATURE_REG
)paren
suffix:semicolon
id|OUT_BYTE
(paren
l_int|0
comma
id|IDE_NSECTOR_REG
)paren
suffix:semicolon
id|OUT_BYTE
(paren
l_int|0
comma
id|IDE_SECTOR_REG
)paren
suffix:semicolon
id|OUT_BYTE
(paren
id|xferlen
op_amp
l_int|0xff
comma
id|IDE_LCYL_REG
)paren
suffix:semicolon
id|OUT_BYTE
(paren
id|xferlen
op_rshift
l_int|8
comma
id|IDE_HCYL_REG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IDE_CONTROL_REG
)paren
id|OUT_BYTE
(paren
id|drive-&gt;ctl
comma
id|IDE_CONTROL_REG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;dma
)paren
(paren
r_void
)paren
(paren
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|dmaproc
c_func
(paren
id|ide_dma_begin
comma
id|drive
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|drq_interrupt
)paren
(brace
id|ide_set_handler
(paren
id|drive
comma
id|handler
comma
id|WAIT_CMD
comma
id|cdrom_timer_expiry
)paren
suffix:semicolon
id|OUT_BYTE
(paren
id|WIN_PACKETCMD
comma
id|IDE_COMMAND_REG
)paren
suffix:semicolon
multiline_comment|/* packet command */
r_return
id|ide_started
suffix:semicolon
)brace
r_else
(brace
id|OUT_BYTE
(paren
id|WIN_PACKETCMD
comma
id|IDE_COMMAND_REG
)paren
suffix:semicolon
multiline_comment|/* packet command */
r_return
(paren
op_star
id|handler
)paren
(paren
id|drive
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* end cdrom */
(brace
multiline_comment|/* start floppy */
id|idefloppy_floppy_t
op_star
id|floppy
op_assign
id|drive-&gt;driver_data
suffix:semicolon
id|idefloppy_bcount_reg_t
id|bcount
suffix:semicolon
r_int
id|dma_ok
op_assign
l_int|0
suffix:semicolon
id|floppy-&gt;pc
op_assign
id|pc
suffix:semicolon
multiline_comment|/* Set the current packet command */
id|pc-&gt;retries
op_increment
suffix:semicolon
id|pc-&gt;actually_transferred
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* We haven&squot;t transferred any data yet */
id|pc-&gt;current_position
op_assign
id|pc-&gt;buffer
suffix:semicolon
id|bcount.all
op_assign
id|IDE_MIN
c_func
(paren
id|pc-&gt;request_transfer
comma
l_int|63
op_star
l_int|1024
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_IDEDMA
r_if
c_cond
(paren
id|test_and_clear_bit
(paren
id|PC_DMA_ERROR
comma
op_amp
id|pc-&gt;flags
)paren
)paren
(brace
(paren
r_void
)paren
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|dmaproc
c_func
(paren
id|ide_dma_off
comma
id|drive
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|test_bit
(paren
id|PC_DMA_RECOMMENDED
comma
op_amp
id|pc-&gt;flags
)paren
op_logical_and
id|drive-&gt;using_dma
)paren
id|dma_ok
op_assign
op_logical_neg
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|dmaproc
c_func
(paren
id|test_bit
(paren
id|PC_WRITING
comma
op_amp
id|pc-&gt;flags
)paren
ques
c_cond
id|ide_dma_write
suffix:colon
id|ide_dma_read
comma
id|drive
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_BLK_DEV_IDEDMA */
r_if
c_cond
(paren
id|IDE_CONTROL_REG
)paren
id|OUT_BYTE
(paren
id|drive-&gt;ctl
comma
id|IDE_CONTROL_REG
)paren
suffix:semicolon
id|OUT_BYTE
(paren
id|dma_ok
ques
c_cond
l_int|1
suffix:colon
l_int|0
comma
id|IDE_FEATURE_REG
)paren
suffix:semicolon
multiline_comment|/* Use PIO/DMA */
id|OUT_BYTE
(paren
id|bcount.b.high
comma
id|IDE_BCOUNTH_REG
)paren
suffix:semicolon
id|OUT_BYTE
(paren
id|bcount.b.low
comma
id|IDE_BCOUNTL_REG
)paren
suffix:semicolon
id|OUT_BYTE
(paren
id|drive-&gt;select.all
comma
id|IDE_SELECT_REG
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_IDEDMA
r_if
c_cond
(paren
id|dma_ok
)paren
(brace
multiline_comment|/* Begin DMA, if necessary */
id|set_bit
(paren
id|PC_DMA_IN_PROGRESS
comma
op_amp
id|pc-&gt;flags
)paren
suffix:semicolon
(paren
r_void
)paren
(paren
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|dmaproc
c_func
(paren
id|ide_dma_begin
comma
id|drive
)paren
)paren
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_BLK_DEV_IDEDMA */
)brace
multiline_comment|/* end floppy */
(brace
multiline_comment|/* start tape */
id|idetape_tape_t
op_star
id|tape
op_assign
id|drive-&gt;driver_data
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_IDEDMA
r_if
c_cond
(paren
id|test_and_clear_bit
(paren
id|PC_DMA_ERROR
comma
op_amp
id|pc-&gt;flags
)paren
)paren
(brace
id|printk
(paren
id|KERN_WARNING
l_string|&quot;ide-tape: DMA disabled, reverting to PIO&bslash;n&quot;
)paren
suffix:semicolon
(paren
r_void
)paren
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|dmaproc
c_func
(paren
id|ide_dma_off
comma
id|drive
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|test_bit
(paren
id|PC_DMA_RECOMMENDED
comma
op_amp
id|pc-&gt;flags
)paren
op_logical_and
id|drive-&gt;using_dma
)paren
id|dma_ok
op_assign
op_logical_neg
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|dmaproc
c_func
(paren
id|test_bit
(paren
id|PC_WRITING
comma
op_amp
id|pc-&gt;flags
)paren
ques
c_cond
id|ide_dma_write
suffix:colon
id|ide_dma_read
comma
id|drive
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_BLK_DEV_IDEDMA */
r_if
c_cond
(paren
id|IDE_CONTROL_REG
)paren
id|OUT_BYTE
(paren
id|drive-&gt;ctl
comma
id|IDE_CONTROL_REG
)paren
suffix:semicolon
id|OUT_BYTE
(paren
id|dma_ok
ques
c_cond
l_int|1
suffix:colon
l_int|0
comma
id|IDE_FEATURE_REG
)paren
suffix:semicolon
multiline_comment|/* Use PIO/DMA */
id|OUT_BYTE
(paren
id|bcount.b.high
comma
id|IDE_BCOUNTH_REG
)paren
suffix:semicolon
id|OUT_BYTE
(paren
id|bcount.b.low
comma
id|IDE_BCOUNTL_REG
)paren
suffix:semicolon
id|OUT_BYTE
(paren
id|drive-&gt;select.all
comma
id|IDE_SELECT_REG
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_IDEDMA
r_if
c_cond
(paren
id|dma_ok
)paren
(brace
multiline_comment|/* Begin DMA, if necessary */
id|set_bit
(paren
id|PC_DMA_IN_PROGRESS
comma
op_amp
id|pc-&gt;flags
)paren
suffix:semicolon
(paren
r_void
)paren
(paren
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|dmaproc
c_func
(paren
id|ide_dma_begin
comma
id|drive
)paren
)paren
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_BLK_DEV_IDEDMA */
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|IDETAPE_DRQ_INTERRUPT
comma
op_amp
id|tape-&gt;flags
)paren
)paren
(brace
id|ide_set_handler
c_func
(paren
id|drive
comma
op_amp
id|idetape_transfer_pc
comma
id|IDETAPE_WAIT_CMD
comma
l_int|NULL
)paren
suffix:semicolon
id|OUT_BYTE
c_func
(paren
id|WIN_PACKETCMD
comma
id|IDE_COMMAND_REG
)paren
suffix:semicolon
r_return
id|ide_started
suffix:semicolon
)brace
r_else
(brace
id|OUT_BYTE
c_func
(paren
id|WIN_PACKETCMD
comma
id|IDE_COMMAND_REG
)paren
suffix:semicolon
r_return
id|idetape_transfer_pc
c_func
(paren
id|drive
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* end tape */
)brace
macro_line|#endif
DECL|function|pkt_taskfile_ioctl
r_int
id|pkt_taskfile_ioctl
(paren
id|ide_drive_t
op_star
id|drive
comma
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
macro_line|#if 0
r_switch
c_cond
(paren
id|req_task-&gt;data_phase
)paren
(brace
r_case
id|TASKFILE_P_OUT_DMAQ
suffix:colon
r_case
id|TASKFILE_P_IN_DMAQ
suffix:colon
r_case
id|TASKFILE_P_OUT_DMA
suffix:colon
r_case
id|TASKFILE_P_IN_DMA
suffix:colon
r_case
id|TASKFILE_P_OUT
suffix:colon
r_case
id|TASKFILE_P_IN
suffix:colon
)brace
macro_line|#endif
r_return
op_minus
id|ENOMSG
suffix:semicolon
)brace
DECL|variable|pkt_taskfile_ioctl
id|EXPORT_SYMBOL
c_func
(paren
id|pkt_taskfile_ioctl
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_PKT_TASK_IOCTL */
eof
