multiline_comment|/*&n; * linux/drivers/ide/ide-taskfile.c&t;Version 0.38&t;March 05, 2003&n; *&n; *  Copyright (C) 2000-2002&t;Michael Cornwell &lt;cornwell@acm.org&gt;&n; *  Copyright (C) 2000-2002&t;Andre Hedrick &lt;andre@linux-ide.org&gt;&n; *  Copyright (C) 2001-2002&t;Klaus Smolin&n; *&t;&t;&t;&t;&t;IBM Storage Technology Division&n; *  Copyright (C) 2003&t;&t;Bartlomiej Zolnierkiewicz&n; *&n; *  The big the bad and the ugly.&n; *&n; *  Problems to be fixed because of BH interface or the lack therefore.&n; *&n; *  Fill me in stupid !!!&n; *&n; *  HOST:&n; *&t;General refers to the Controller and Driver &quot;pair&quot;.&n; *  DATA HANDLER:&n; *&t;Under the context of Linux it generally refers to an interrupt handler.&n; *&t;However, it correctly describes the &squot;HOST&squot;&n; *  DATA BLOCK:&n; *&t;The amount of data needed to be transfered as predefined in the&n; *&t;setup of the device.&n; *  STORAGE ATOMIC:&n; *&t;The &squot;DATA BLOCK&squot; associated to the &squot;DATA HANDLER&squot;, and can be as&n; *&t;small as a single sector or as large as the entire command block&n; *&t;request.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/major.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/genhd.h&gt;
macro_line|#include &lt;linux/blkpg.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/hdreg.h&gt;
macro_line|#include &lt;linux/ide.h&gt;
macro_line|#include &lt;asm/byteorder.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
DECL|macro|DEBUG_TASKFILE
mdefine_line|#define DEBUG_TASKFILE&t;0&t;/* unset when fixed */
macro_line|#if DEBUG_TASKFILE
DECL|macro|DTF
mdefine_line|#define DTF(x...) printk(x)
macro_line|#else
DECL|macro|DTF
mdefine_line|#define DTF(x...)
macro_line|#endif
DECL|function|ata_bswap_data
r_static
r_void
id|ata_bswap_data
(paren
r_void
op_star
id|buffer
comma
r_int
id|wcount
)paren
(brace
id|u16
op_star
id|p
op_assign
id|buffer
suffix:semicolon
r_while
c_loop
(paren
id|wcount
op_decrement
)paren
(brace
op_star
id|p
op_assign
op_star
id|p
op_lshift
l_int|8
op_or
op_star
id|p
op_rshift
l_int|8
suffix:semicolon
id|p
op_increment
suffix:semicolon
op_star
id|p
op_assign
op_star
id|p
op_lshift
l_int|8
op_or
op_star
id|p
op_rshift
l_int|8
suffix:semicolon
id|p
op_increment
suffix:semicolon
)brace
)brace
DECL|function|taskfile_input_data
r_void
id|taskfile_input_data
(paren
id|ide_drive_t
op_star
id|drive
comma
r_void
op_star
id|buffer
comma
id|u32
id|wcount
)paren
(brace
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|ata_input_data
c_func
(paren
id|drive
comma
id|buffer
comma
id|wcount
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;bswap
)paren
id|ata_bswap_data
c_func
(paren
id|buffer
comma
id|wcount
)paren
suffix:semicolon
)brace
DECL|variable|taskfile_input_data
id|EXPORT_SYMBOL
c_func
(paren
id|taskfile_input_data
)paren
suffix:semicolon
DECL|function|taskfile_output_data
r_void
id|taskfile_output_data
(paren
id|ide_drive_t
op_star
id|drive
comma
r_void
op_star
id|buffer
comma
id|u32
id|wcount
)paren
(brace
r_if
c_cond
(paren
id|drive-&gt;bswap
)paren
(brace
id|ata_bswap_data
c_func
(paren
id|buffer
comma
id|wcount
)paren
suffix:semicolon
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|ata_output_data
c_func
(paren
id|drive
comma
id|buffer
comma
id|wcount
)paren
suffix:semicolon
id|ata_bswap_data
c_func
(paren
id|buffer
comma
id|wcount
)paren
suffix:semicolon
)brace
r_else
(brace
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|ata_output_data
c_func
(paren
id|drive
comma
id|buffer
comma
id|wcount
)paren
suffix:semicolon
)brace
)brace
DECL|variable|taskfile_output_data
id|EXPORT_SYMBOL
c_func
(paren
id|taskfile_output_data
)paren
suffix:semicolon
DECL|function|taskfile_lib_get_identify
r_int
id|taskfile_lib_get_identify
(paren
id|ide_drive_t
op_star
id|drive
comma
id|u8
op_star
id|buf
)paren
(brace
id|ide_task_t
id|args
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|args
comma
l_int|0
comma
r_sizeof
(paren
id|ide_task_t
)paren
)paren
suffix:semicolon
id|args.tfRegister
(braket
id|IDE_NSECTOR_OFFSET
)braket
op_assign
l_int|0x01
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;media
op_eq
id|ide_disk
)paren
id|args.tfRegister
(braket
id|IDE_COMMAND_OFFSET
)braket
op_assign
id|WIN_IDENTIFY
suffix:semicolon
r_else
id|args.tfRegister
(braket
id|IDE_COMMAND_OFFSET
)braket
op_assign
id|WIN_PIDENTIFY
suffix:semicolon
id|args.command_type
op_assign
id|IDE_DRIVE_TASK_IN
suffix:semicolon
id|args.handler
op_assign
op_amp
id|task_in_intr
suffix:semicolon
r_return
id|ide_raw_taskfile
c_func
(paren
id|drive
comma
op_amp
id|args
comma
id|buf
)paren
suffix:semicolon
)brace
DECL|variable|taskfile_lib_get_identify
id|EXPORT_SYMBOL
c_func
(paren
id|taskfile_lib_get_identify
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_IDE_TASK_IOCTL_DEBUG
DECL|function|debug_taskfile
r_void
id|debug_taskfile
(paren
id|ide_drive_t
op_star
id|drive
comma
id|ide_task_t
op_star
id|args
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: &quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
singleline_comment|//&t;printk(&quot;TF.0=x%02x &quot;, args-&gt;tfRegister[IDE_DATA_OFFSET]);
id|printk
c_func
(paren
l_string|&quot;TF.1=x%02x &quot;
comma
id|args-&gt;tfRegister
(braket
id|IDE_FEATURE_OFFSET
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;TF.2=x%02x &quot;
comma
id|args-&gt;tfRegister
(braket
id|IDE_NSECTOR_OFFSET
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;TF.3=x%02x &quot;
comma
id|args-&gt;tfRegister
(braket
id|IDE_SECTOR_OFFSET
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;TF.4=x%02x &quot;
comma
id|args-&gt;tfRegister
(braket
id|IDE_LCYL_OFFSET
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;TF.5=x%02x &quot;
comma
id|args-&gt;tfRegister
(braket
id|IDE_HCYL_OFFSET
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;TF.6=x%02x &quot;
comma
id|args-&gt;tfRegister
(braket
id|IDE_SELECT_OFFSET
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;TF.7=x%02x&bslash;n&quot;
comma
id|args-&gt;tfRegister
(braket
id|IDE_COMMAND_OFFSET
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: &quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
singleline_comment|//&t;printk(&quot;HTF.0=x%02x &quot;, args-&gt;hobRegister[IDE_DATA_OFFSET]);
id|printk
c_func
(paren
l_string|&quot;HTF.1=x%02x &quot;
comma
id|args-&gt;hobRegister
(braket
id|IDE_FEATURE_OFFSET
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;HTF.2=x%02x &quot;
comma
id|args-&gt;hobRegister
(braket
id|IDE_NSECTOR_OFFSET
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;HTF.3=x%02x &quot;
comma
id|args-&gt;hobRegister
(braket
id|IDE_SECTOR_OFFSET
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;HTF.4=x%02x &quot;
comma
id|args-&gt;hobRegister
(braket
id|IDE_LCYL_OFFSET
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;HTF.5=x%02x &quot;
comma
id|args-&gt;hobRegister
(braket
id|IDE_HCYL_OFFSET
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;HTF.6=x%02x &quot;
comma
id|args-&gt;hobRegister
(braket
id|IDE_SELECT_OFFSET
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;HTF.7=x%02x&bslash;n&quot;
comma
id|args-&gt;hobRegister
(braket
id|IDE_CONTROL_OFFSET_HOB
)braket
)paren
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_IDE_TASK_IOCTL_DEBUG */
DECL|function|do_rw_taskfile
id|ide_startstop_t
id|do_rw_taskfile
(paren
id|ide_drive_t
op_star
id|drive
comma
id|ide_task_t
op_star
id|task
)paren
(brace
id|ide_hwif_t
op_star
id|hwif
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
suffix:semicolon
id|task_struct_t
op_star
id|taskfile
op_assign
(paren
id|task_struct_t
op_star
)paren
id|task-&gt;tfRegister
suffix:semicolon
id|hob_struct_t
op_star
id|hobfile
op_assign
(paren
id|hob_struct_t
op_star
)paren
id|task-&gt;hobRegister
suffix:semicolon
id|u8
id|HIHI
op_assign
(paren
id|drive-&gt;addressing
op_eq
l_int|1
)paren
ques
c_cond
l_int|0xE0
suffix:colon
l_int|0xEF
suffix:semicolon
macro_line|#ifdef CONFIG_IDE_TASK_IOCTL_DEBUG
r_void
id|debug_taskfile
c_func
(paren
id|drive
comma
id|task
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_IDE_TASK_IOCTL_DEBUG */
multiline_comment|/* ALL Command Block Executions SHALL clear nIEN, unless otherwise */
r_if
c_cond
(paren
id|IDE_CONTROL_REG
)paren
(brace
multiline_comment|/* clear nIEN */
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|drive-&gt;ctl
comma
id|IDE_CONTROL_REG
)paren
suffix:semicolon
)brace
id|SELECT_MASK
c_func
(paren
id|drive
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;addressing
op_eq
l_int|1
)paren
(brace
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|hobfile-&gt;feature
comma
id|IDE_FEATURE_REG
)paren
suffix:semicolon
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|hobfile-&gt;sector_count
comma
id|IDE_NSECTOR_REG
)paren
suffix:semicolon
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|hobfile-&gt;sector_number
comma
id|IDE_SECTOR_REG
)paren
suffix:semicolon
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|hobfile-&gt;low_cylinder
comma
id|IDE_LCYL_REG
)paren
suffix:semicolon
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|hobfile-&gt;high_cylinder
comma
id|IDE_HCYL_REG
)paren
suffix:semicolon
)brace
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|taskfile-&gt;feature
comma
id|IDE_FEATURE_REG
)paren
suffix:semicolon
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|taskfile-&gt;sector_count
comma
id|IDE_NSECTOR_REG
)paren
suffix:semicolon
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|taskfile-&gt;sector_number
comma
id|IDE_SECTOR_REG
)paren
suffix:semicolon
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|taskfile-&gt;low_cylinder
comma
id|IDE_LCYL_REG
)paren
suffix:semicolon
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|taskfile-&gt;high_cylinder
comma
id|IDE_HCYL_REG
)paren
suffix:semicolon
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
(paren
id|taskfile-&gt;device_head
op_amp
id|HIHI
)paren
op_or
id|drive-&gt;select.all
comma
id|IDE_SELECT_REG
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_IDE_TASKFILE_IO
r_if
c_cond
(paren
id|task-&gt;handler
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|task-&gt;prehandler
op_ne
l_int|NULL
)paren
(brace
id|hwif
op_member_access_from_pointer
id|OUTBSYNC
c_func
(paren
id|drive
comma
id|taskfile-&gt;command
comma
id|IDE_COMMAND_REG
)paren
suffix:semicolon
id|ndelay
c_func
(paren
l_int|400
)paren
suffix:semicolon
multiline_comment|/* FIXME */
r_return
id|task
op_member_access_from_pointer
id|prehandler
c_func
(paren
id|drive
comma
id|task-&gt;rq
)paren
suffix:semicolon
)brace
id|ide_execute_command
c_func
(paren
id|drive
comma
id|taskfile-&gt;command
comma
id|task-&gt;handler
comma
id|WAIT_WORSTCASE
comma
l_int|NULL
)paren
suffix:semicolon
r_return
id|ide_started
suffix:semicolon
)brace
macro_line|#else
r_if
c_cond
(paren
id|task-&gt;handler
op_ne
l_int|NULL
)paren
(brace
id|ide_execute_command
c_func
(paren
id|drive
comma
id|taskfile-&gt;command
comma
id|task-&gt;handler
comma
id|WAIT_WORSTCASE
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|task-&gt;prehandler
op_ne
l_int|NULL
)paren
r_return
id|task
op_member_access_from_pointer
id|prehandler
c_func
(paren
id|drive
comma
id|task-&gt;rq
)paren
suffix:semicolon
r_return
id|ide_started
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|drive-&gt;using_dma
)paren
r_return
id|ide_stopped
suffix:semicolon
r_switch
c_cond
(paren
id|taskfile-&gt;command
)paren
(brace
r_case
id|WIN_WRITEDMA_ONCE
suffix:colon
r_case
id|WIN_WRITEDMA
suffix:colon
r_case
id|WIN_WRITEDMA_EXT
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|hwif
op_member_access_from_pointer
id|ide_dma_write
c_func
(paren
id|drive
)paren
)paren
r_return
id|ide_started
suffix:semicolon
r_break
suffix:semicolon
r_case
id|WIN_READDMA_ONCE
suffix:colon
r_case
id|WIN_READDMA
suffix:colon
r_case
id|WIN_READDMA_EXT
suffix:colon
r_case
id|WIN_IDENTIFY_DMA
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|hwif
op_member_access_from_pointer
id|ide_dma_read
c_func
(paren
id|drive
)paren
)paren
r_return
id|ide_started
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
r_if
c_cond
(paren
id|task-&gt;handler
op_eq
l_int|NULL
)paren
r_return
id|ide_stopped
suffix:semicolon
)brace
r_return
id|ide_stopped
suffix:semicolon
)brace
DECL|variable|do_rw_taskfile
id|EXPORT_SYMBOL
c_func
(paren
id|do_rw_taskfile
)paren
suffix:semicolon
multiline_comment|/*&n; * set_multmode_intr() is invoked on completion of a WIN_SETMULT cmd.&n; */
DECL|function|set_multmode_intr
id|ide_startstop_t
id|set_multmode_intr
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|ide_hwif_t
op_star
id|hwif
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
suffix:semicolon
id|u8
id|stat
suffix:semicolon
r_if
c_cond
(paren
id|OK_STAT
c_func
(paren
id|stat
op_assign
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_STATUS_REG
)paren
comma
id|READY_STAT
comma
id|BAD_STAT
)paren
)paren
(brace
id|drive-&gt;mult_count
op_assign
id|drive-&gt;mult_req
suffix:semicolon
)brace
r_else
(brace
id|drive-&gt;mult_req
op_assign
id|drive-&gt;mult_count
op_assign
l_int|0
suffix:semicolon
id|drive-&gt;special.b.recalibrate
op_assign
l_int|1
suffix:semicolon
(paren
r_void
)paren
id|ide_dump_status
c_func
(paren
id|drive
comma
l_string|&quot;set_multmode&quot;
comma
id|stat
)paren
suffix:semicolon
)brace
r_return
id|ide_stopped
suffix:semicolon
)brace
DECL|variable|set_multmode_intr
id|EXPORT_SYMBOL
c_func
(paren
id|set_multmode_intr
)paren
suffix:semicolon
multiline_comment|/*&n; * set_geometry_intr() is invoked on completion of a WIN_SPECIFY cmd.&n; */
DECL|function|set_geometry_intr
id|ide_startstop_t
id|set_geometry_intr
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|ide_hwif_t
op_star
id|hwif
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
suffix:semicolon
r_int
id|retries
op_assign
l_int|5
suffix:semicolon
id|u8
id|stat
suffix:semicolon
r_while
c_loop
(paren
(paren
(paren
id|stat
op_assign
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_STATUS_REG
)paren
)paren
op_amp
id|BUSY_STAT
)paren
op_logical_and
id|retries
op_decrement
)paren
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
r_if
c_cond
(paren
id|OK_STAT
c_func
(paren
id|stat
comma
id|READY_STAT
comma
id|BAD_STAT
)paren
)paren
r_return
id|ide_stopped
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_amp
(paren
id|ERR_STAT
op_or
id|DRQ_STAT
)paren
)paren
r_return
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|error
c_func
(paren
id|drive
comma
l_string|&quot;set_geometry_intr&quot;
comma
id|stat
)paren
suffix:semicolon
r_if
c_cond
(paren
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|handler
op_ne
l_int|NULL
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|ide_set_handler
c_func
(paren
id|drive
comma
op_amp
id|set_geometry_intr
comma
id|WAIT_WORSTCASE
comma
l_int|NULL
)paren
suffix:semicolon
r_return
id|ide_started
suffix:semicolon
)brace
DECL|variable|set_geometry_intr
id|EXPORT_SYMBOL
c_func
(paren
id|set_geometry_intr
)paren
suffix:semicolon
multiline_comment|/*&n; * recal_intr() is invoked on completion of a WIN_RESTORE (recalibrate) cmd.&n; */
DECL|function|recal_intr
id|ide_startstop_t
id|recal_intr
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|ide_hwif_t
op_star
id|hwif
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
suffix:semicolon
id|u8
id|stat
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|OK_STAT
c_func
(paren
id|stat
op_assign
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_STATUS_REG
)paren
comma
id|READY_STAT
comma
id|BAD_STAT
)paren
)paren
r_return
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|error
c_func
(paren
id|drive
comma
l_string|&quot;recal_intr&quot;
comma
id|stat
)paren
suffix:semicolon
r_return
id|ide_stopped
suffix:semicolon
)brace
DECL|variable|recal_intr
id|EXPORT_SYMBOL
c_func
(paren
id|recal_intr
)paren
suffix:semicolon
multiline_comment|/*&n; * Handler for commands without a data phase&n; */
DECL|function|task_no_data_intr
id|ide_startstop_t
id|task_no_data_intr
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|ide_task_t
op_star
id|args
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq-&gt;special
suffix:semicolon
id|ide_hwif_t
op_star
id|hwif
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
suffix:semicolon
id|u8
id|stat
suffix:semicolon
id|local_irq_enable
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|OK_STAT
c_func
(paren
id|stat
op_assign
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_STATUS_REG
)paren
comma
id|READY_STAT
comma
id|BAD_STAT
)paren
)paren
(brace
id|DTF
c_func
(paren
l_string|&quot;%s: command opcode 0x%02x&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|args-&gt;tfRegister
(braket
id|IDE_COMMAND_OFFSET
)braket
)paren
suffix:semicolon
r_return
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|error
c_func
(paren
id|drive
comma
l_string|&quot;task_no_data_intr&quot;
comma
id|stat
)paren
suffix:semicolon
multiline_comment|/* calls ide_end_drive_cmd */
)brace
r_if
c_cond
(paren
id|args
)paren
id|ide_end_drive_cmd
c_func
(paren
id|drive
comma
id|stat
comma
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_ERROR_REG
)paren
)paren
suffix:semicolon
r_return
id|ide_stopped
suffix:semicolon
)brace
DECL|variable|task_no_data_intr
id|EXPORT_SYMBOL
c_func
(paren
id|task_no_data_intr
)paren
suffix:semicolon
multiline_comment|/*&n; * old taskfile PIO handlers, to be killed as soon as possible.&n; */
macro_line|#ifndef CONFIG_IDE_TASKFILE_IO
DECL|macro|task_map_rq
mdefine_line|#define task_map_rq(rq, flags)&t;&t;ide_map_buffer((rq), (flags))
DECL|macro|task_unmap_rq
mdefine_line|#define task_unmap_rq(rq, buf, flags)&t;ide_unmap_buffer((rq), (buf), (flags))
multiline_comment|/*&n; * Handler for command with PIO data-in phase, READ&n; */
DECL|function|task_in_intr
id|ide_startstop_t
id|task_in_intr
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_struct
id|request
op_star
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
id|ide_hwif_t
op_star
id|hwif
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
suffix:semicolon
r_char
op_star
id|pBuf
op_assign
l_int|NULL
suffix:semicolon
id|u8
id|stat
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|OK_STAT
c_func
(paren
id|stat
op_assign
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_STATUS_REG
)paren
comma
id|DATA_READY
comma
id|BAD_R_STAT
)paren
)paren
(brace
r_if
c_cond
(paren
id|stat
op_amp
(paren
id|ERR_STAT
op_or
id|DRQ_STAT
)paren
)paren
(brace
r_return
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|error
c_func
(paren
id|drive
comma
l_string|&quot;task_in_intr&quot;
comma
id|stat
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|stat
op_amp
id|BUSY_STAT
)paren
)paren
(brace
id|DTF
c_func
(paren
l_string|&quot;task_in_intr to Soon wait for next interrupt&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|handler
op_eq
l_int|NULL
)paren
id|ide_set_handler
c_func
(paren
id|drive
comma
op_amp
id|task_in_intr
comma
id|WAIT_WORSTCASE
comma
l_int|NULL
)paren
suffix:semicolon
r_return
id|ide_started
suffix:semicolon
)brace
)brace
id|pBuf
op_assign
id|task_map_rq
c_func
(paren
id|rq
comma
op_amp
id|flags
)paren
suffix:semicolon
id|DTF
c_func
(paren
l_string|&quot;Read: %p, rq-&gt;current_nr_sectors: %d, stat: %02x&bslash;n&quot;
comma
id|pBuf
comma
(paren
r_int
)paren
id|rq-&gt;current_nr_sectors
comma
id|stat
)paren
suffix:semicolon
id|taskfile_input_data
c_func
(paren
id|drive
comma
id|pBuf
comma
id|SECTOR_WORDS
)paren
suffix:semicolon
id|task_unmap_rq
c_func
(paren
id|rq
comma
id|pBuf
comma
op_amp
id|flags
)paren
suffix:semicolon
multiline_comment|/* FIXME: check drive status */
r_if
c_cond
(paren
op_decrement
id|rq-&gt;current_nr_sectors
op_le
l_int|0
)paren
r_if
c_cond
(paren
op_logical_neg
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|end_request
c_func
(paren
id|drive
comma
l_int|1
comma
l_int|0
)paren
)paren
r_return
id|ide_stopped
suffix:semicolon
multiline_comment|/*&n;&t; * ERM, it is techincally legal to leave/exit here but it makes&n;&t; * a mess of the code ...&n;&t; */
r_if
c_cond
(paren
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|handler
op_eq
l_int|NULL
)paren
id|ide_set_handler
c_func
(paren
id|drive
comma
op_amp
id|task_in_intr
comma
id|WAIT_WORSTCASE
comma
l_int|NULL
)paren
suffix:semicolon
r_return
id|ide_started
suffix:semicolon
)brace
DECL|variable|task_in_intr
id|EXPORT_SYMBOL
c_func
(paren
id|task_in_intr
)paren
suffix:semicolon
multiline_comment|/*&n; * Handler for command with Read Multiple&n; */
DECL|function|task_mulin_intr
id|ide_startstop_t
id|task_mulin_intr
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|ide_hwif_t
op_star
id|hwif
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
suffix:semicolon
r_struct
id|request
op_star
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
r_char
op_star
id|pBuf
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|msect
op_assign
id|drive-&gt;mult_count
suffix:semicolon
r_int
r_int
id|nsect
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|u8
id|stat
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|OK_STAT
c_func
(paren
id|stat
op_assign
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_STATUS_REG
)paren
comma
id|DATA_READY
comma
id|BAD_R_STAT
)paren
)paren
(brace
r_if
c_cond
(paren
id|stat
op_amp
(paren
id|ERR_STAT
op_or
id|DRQ_STAT
)paren
)paren
(brace
r_return
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|error
c_func
(paren
id|drive
comma
l_string|&quot;task_mulin_intr&quot;
comma
id|stat
)paren
suffix:semicolon
)brace
multiline_comment|/* no data yet, so wait for another interrupt */
r_if
c_cond
(paren
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|handler
op_eq
l_int|NULL
)paren
id|ide_set_handler
c_func
(paren
id|drive
comma
op_amp
id|task_mulin_intr
comma
id|WAIT_WORSTCASE
comma
l_int|NULL
)paren
suffix:semicolon
r_return
id|ide_started
suffix:semicolon
)brace
r_do
(brace
id|nsect
op_assign
id|rq-&gt;current_nr_sectors
suffix:semicolon
r_if
c_cond
(paren
id|nsect
OG
id|msect
)paren
id|nsect
op_assign
id|msect
suffix:semicolon
id|pBuf
op_assign
id|task_map_rq
c_func
(paren
id|rq
comma
op_amp
id|flags
)paren
suffix:semicolon
id|DTF
c_func
(paren
l_string|&quot;Multiread: %p, nsect: %d, msect: %d, &quot;
"&bslash;"
l_string|&quot; rq-&gt;current_nr_sectors: %d&bslash;n&quot;
comma
id|pBuf
comma
id|nsect
comma
id|msect
comma
id|rq-&gt;current_nr_sectors
)paren
suffix:semicolon
id|taskfile_input_data
c_func
(paren
id|drive
comma
id|pBuf
comma
id|nsect
op_star
id|SECTOR_WORDS
)paren
suffix:semicolon
id|task_unmap_rq
c_func
(paren
id|rq
comma
id|pBuf
comma
op_amp
id|flags
)paren
suffix:semicolon
id|rq-&gt;errors
op_assign
l_int|0
suffix:semicolon
id|rq-&gt;current_nr_sectors
op_sub_assign
id|nsect
suffix:semicolon
id|msect
op_sub_assign
id|nsect
suffix:semicolon
multiline_comment|/* FIXME: check drive status */
r_if
c_cond
(paren
op_logical_neg
id|rq-&gt;current_nr_sectors
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|end_request
c_func
(paren
id|drive
comma
l_int|1
comma
l_int|0
)paren
)paren
r_return
id|ide_stopped
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|msect
)paren
suffix:semicolon
r_if
c_cond
(paren
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|handler
op_eq
l_int|NULL
)paren
id|ide_set_handler
c_func
(paren
id|drive
comma
op_amp
id|task_mulin_intr
comma
id|WAIT_WORSTCASE
comma
l_int|NULL
)paren
suffix:semicolon
r_return
id|ide_started
suffix:semicolon
)brace
DECL|variable|task_mulin_intr
id|EXPORT_SYMBOL
c_func
(paren
id|task_mulin_intr
)paren
suffix:semicolon
multiline_comment|/*&n; * VERIFY ME before 2.4 ... unexpected race is possible based on details&n; * RMK with 74LS245/373/374 TTL buffer logic because of passthrough.&n; */
DECL|function|pre_task_out_intr
id|ide_startstop_t
id|pre_task_out_intr
(paren
id|ide_drive_t
op_star
id|drive
comma
r_struct
id|request
op_star
id|rq
)paren
(brace
r_char
op_star
id|pBuf
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|ide_startstop_t
id|startstop
suffix:semicolon
r_if
c_cond
(paren
id|ide_wait_stat
c_func
(paren
op_amp
id|startstop
comma
id|drive
comma
id|DATA_READY
comma
id|drive-&gt;bad_wstat
comma
id|WAIT_DRQ
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: no DRQ after issuing WRITE%s&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|drive-&gt;addressing
ques
c_cond
l_string|&quot;_EXT&quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
r_return
id|startstop
suffix:semicolon
)brace
multiline_comment|/* For Write_sectors we need to stuff the first sector */
id|pBuf
op_assign
id|task_map_rq
c_func
(paren
id|rq
comma
op_amp
id|flags
)paren
suffix:semicolon
id|taskfile_output_data
c_func
(paren
id|drive
comma
id|pBuf
comma
id|SECTOR_WORDS
)paren
suffix:semicolon
id|rq-&gt;current_nr_sectors
op_decrement
suffix:semicolon
id|task_unmap_rq
c_func
(paren
id|rq
comma
id|pBuf
comma
op_amp
id|flags
)paren
suffix:semicolon
r_return
id|ide_started
suffix:semicolon
)brace
DECL|variable|pre_task_out_intr
id|EXPORT_SYMBOL
c_func
(paren
id|pre_task_out_intr
)paren
suffix:semicolon
multiline_comment|/*&n; * Handler for command with PIO data-out phase WRITE&n; *&n; * WOOHOO this is a CORRECT STATE DIAGRAM NOW, &lt;andre@linux-ide.org&gt;&n; */
DECL|function|task_out_intr
id|ide_startstop_t
id|task_out_intr
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|ide_hwif_t
op_star
id|hwif
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
suffix:semicolon
r_struct
id|request
op_star
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
r_char
op_star
id|pBuf
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|u8
id|stat
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|OK_STAT
c_func
(paren
id|stat
op_assign
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_STATUS_REG
)paren
comma
id|DRIVE_READY
comma
id|drive-&gt;bad_wstat
)paren
)paren
(brace
r_return
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|error
c_func
(paren
id|drive
comma
l_string|&quot;task_out_intr&quot;
comma
id|stat
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Safe to update request for partial completions.&n;&t; * We have a good STATUS CHECK!!!&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|rq-&gt;current_nr_sectors
)paren
r_if
c_cond
(paren
op_logical_neg
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|end_request
c_func
(paren
id|drive
comma
l_int|1
comma
l_int|0
)paren
)paren
r_return
id|ide_stopped
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rq-&gt;current_nr_sectors
op_eq
l_int|1
)paren
op_xor
(paren
id|stat
op_amp
id|DRQ_STAT
)paren
)paren
(brace
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
id|pBuf
op_assign
id|task_map_rq
c_func
(paren
id|rq
comma
op_amp
id|flags
)paren
suffix:semicolon
id|DTF
c_func
(paren
l_string|&quot;write: %p, rq-&gt;current_nr_sectors: %d&bslash;n&quot;
comma
id|pBuf
comma
(paren
r_int
)paren
id|rq-&gt;current_nr_sectors
)paren
suffix:semicolon
id|taskfile_output_data
c_func
(paren
id|drive
comma
id|pBuf
comma
id|SECTOR_WORDS
)paren
suffix:semicolon
id|task_unmap_rq
c_func
(paren
id|rq
comma
id|pBuf
comma
op_amp
id|flags
)paren
suffix:semicolon
id|rq-&gt;errors
op_assign
l_int|0
suffix:semicolon
id|rq-&gt;current_nr_sectors
op_decrement
suffix:semicolon
)brace
r_if
c_cond
(paren
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|handler
op_eq
l_int|NULL
)paren
id|ide_set_handler
c_func
(paren
id|drive
comma
op_amp
id|task_out_intr
comma
id|WAIT_WORSTCASE
comma
l_int|NULL
)paren
suffix:semicolon
r_return
id|ide_started
suffix:semicolon
)brace
DECL|variable|task_out_intr
id|EXPORT_SYMBOL
c_func
(paren
id|task_out_intr
)paren
suffix:semicolon
DECL|function|pre_task_mulout_intr
id|ide_startstop_t
id|pre_task_mulout_intr
(paren
id|ide_drive_t
op_star
id|drive
comma
r_struct
id|request
op_star
id|rq
)paren
(brace
id|ide_task_t
op_star
id|args
op_assign
id|rq-&gt;special
suffix:semicolon
id|ide_startstop_t
id|startstop
suffix:semicolon
r_if
c_cond
(paren
id|ide_wait_stat
c_func
(paren
op_amp
id|startstop
comma
id|drive
comma
id|DATA_READY
comma
id|drive-&gt;bad_wstat
comma
id|WAIT_DRQ
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: no DRQ after issuing %s&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|drive-&gt;addressing
ques
c_cond
l_string|&quot;MULTWRITE_EXT&quot;
suffix:colon
l_string|&quot;MULTWRITE&quot;
)paren
suffix:semicolon
r_return
id|startstop
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|drive_is_ready
c_func
(paren
id|drive
)paren
)paren
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|100
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|drive_is_ready
c_func
(paren
id|drive
)paren
)paren
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * WARNING :: if the drive as not acked good status we may not&n;&t; * move the DATA-TRANSFER T-Bar as BSY != 0. &lt;andre@linux-ide.org&gt;&n;&t; */
r_return
id|args
op_member_access_from_pointer
id|handler
c_func
(paren
id|drive
)paren
suffix:semicolon
)brace
DECL|variable|pre_task_mulout_intr
id|EXPORT_SYMBOL
c_func
(paren
id|pre_task_mulout_intr
)paren
suffix:semicolon
multiline_comment|/*&n; * Handler for command write multiple&n; * Called directly from execute_drive_cmd for the first bunch of sectors,&n; * afterwards only by the ISR&n; */
DECL|function|task_mulout_intr
id|ide_startstop_t
id|task_mulout_intr
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|ide_hwif_t
op_star
id|hwif
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
suffix:semicolon
id|u8
id|stat
op_assign
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_STATUS_REG
)paren
suffix:semicolon
r_struct
id|request
op_star
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
r_char
op_star
id|pBuf
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|msect
op_assign
id|drive-&gt;mult_count
suffix:semicolon
r_int
r_int
id|nsect
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|OK_STAT
c_func
(paren
id|stat
comma
id|DATA_READY
comma
id|BAD_R_STAT
)paren
op_logical_or
op_logical_neg
id|rq-&gt;current_nr_sectors
)paren
(brace
r_if
c_cond
(paren
id|stat
op_amp
(paren
id|ERR_STAT
op_or
id|DRQ_STAT
)paren
)paren
(brace
r_return
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|error
c_func
(paren
id|drive
comma
l_string|&quot;task_mulout_intr&quot;
comma
id|stat
)paren
suffix:semicolon
)brace
multiline_comment|/* Handle last IRQ, occurs after all data was sent. */
r_if
c_cond
(paren
op_logical_neg
id|rq-&gt;current_nr_sectors
)paren
(brace
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|end_request
c_func
(paren
id|drive
comma
l_int|1
comma
l_int|0
)paren
suffix:semicolon
r_return
id|ide_stopped
suffix:semicolon
)brace
multiline_comment|/* no data yet, so wait for another interrupt */
r_if
c_cond
(paren
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|handler
op_eq
l_int|NULL
)paren
id|ide_set_handler
c_func
(paren
id|drive
comma
op_amp
id|task_mulout_intr
comma
id|WAIT_WORSTCASE
comma
l_int|NULL
)paren
suffix:semicolon
r_return
id|ide_started
suffix:semicolon
)brace
r_if
c_cond
(paren
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|handler
op_ne
l_int|NULL
)paren
(brace
r_int
r_int
id|lflags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ide_lock
comma
id|lflags
)paren
suffix:semicolon
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|handler
op_assign
l_int|NULL
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|timer
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ide_lock
comma
id|lflags
)paren
suffix:semicolon
)brace
r_do
(brace
id|nsect
op_assign
id|rq-&gt;current_nr_sectors
suffix:semicolon
r_if
c_cond
(paren
id|nsect
OG
id|msect
)paren
id|nsect
op_assign
id|msect
suffix:semicolon
id|pBuf
op_assign
id|task_map_rq
c_func
(paren
id|rq
comma
op_amp
id|flags
)paren
suffix:semicolon
id|DTF
c_func
(paren
l_string|&quot;Multiwrite: %p, nsect: %d, msect: %d, &quot;
"&bslash;"
l_string|&quot;rq-&gt;current_nr_sectors: %ld&bslash;n&quot;
comma
id|pBuf
comma
id|nsect
comma
id|msect
comma
id|rq-&gt;current_nr_sectors
)paren
suffix:semicolon
id|msect
op_sub_assign
id|nsect
suffix:semicolon
id|taskfile_output_data
c_func
(paren
id|drive
comma
id|pBuf
comma
id|nsect
op_star
id|SECTOR_WORDS
)paren
suffix:semicolon
id|task_unmap_rq
c_func
(paren
id|rq
comma
id|pBuf
comma
op_amp
id|flags
)paren
suffix:semicolon
id|rq-&gt;current_nr_sectors
op_sub_assign
id|nsect
suffix:semicolon
multiline_comment|/* FIXME: check drive status */
r_if
c_cond
(paren
op_logical_neg
id|rq-&gt;current_nr_sectors
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|end_request
c_func
(paren
id|drive
comma
l_int|1
comma
l_int|0
)paren
)paren
r_if
c_cond
(paren
op_logical_neg
id|rq-&gt;bio
)paren
r_return
id|ide_stopped
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|msect
)paren
suffix:semicolon
id|rq-&gt;errors
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|handler
op_eq
l_int|NULL
)paren
id|ide_set_handler
c_func
(paren
id|drive
comma
op_amp
id|task_mulout_intr
comma
id|WAIT_WORSTCASE
comma
l_int|NULL
)paren
suffix:semicolon
r_return
id|ide_started
suffix:semicolon
)brace
DECL|variable|task_mulout_intr
id|EXPORT_SYMBOL
c_func
(paren
id|task_mulout_intr
)paren
suffix:semicolon
macro_line|#else /* !CONFIG_IDE_TASKFILE_IO */
DECL|function|wait_drive_not_busy
r_static
id|u8
id|wait_drive_not_busy
c_func
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|ide_hwif_t
op_star
id|hwif
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
suffix:semicolon
r_int
id|retries
op_assign
l_int|100
suffix:semicolon
id|u8
id|stat
suffix:semicolon
multiline_comment|/*&n;&t; * Last sector was transfered, wait until drive is ready.&n;&t; * This can take up to 10 usec, but we will wait max 1 ms&n;&t; * (drive_cmd_intr() waits that long).&n;&t; */
r_while
c_loop
(paren
(paren
(paren
id|stat
op_assign
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_STATUS_REG
)paren
)paren
op_amp
id|BUSY_STAT
)paren
op_logical_and
id|retries
op_decrement
)paren
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|retries
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: drive still BUSY!&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
r_return
id|stat
suffix:semicolon
)brace
multiline_comment|/*&n; * Handler for command with PIO data-in phase (Read).&n; */
DECL|function|task_in_intr
id|ide_startstop_t
id|task_in_intr
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_struct
id|request
op_star
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
id|u8
id|stat
comma
id|good_stat
suffix:semicolon
id|good_stat
op_assign
id|DATA_READY
suffix:semicolon
id|stat
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_STATUS_REG
)paren
suffix:semicolon
id|check_status
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|OK_STAT
c_func
(paren
id|stat
comma
id|good_stat
comma
id|BAD_R_STAT
)paren
)paren
(brace
r_if
c_cond
(paren
id|stat
op_amp
(paren
id|ERR_STAT
op_or
id|DRQ_STAT
)paren
)paren
r_return
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|error
c_func
(paren
id|drive
comma
id|__FUNCTION__
comma
id|stat
)paren
suffix:semicolon
multiline_comment|/* BUSY_STAT: No data yet, so wait for another IRQ. */
id|ide_set_handler
c_func
(paren
id|drive
comma
op_amp
id|task_in_intr
comma
id|WAIT_WORSTCASE
comma
l_int|NULL
)paren
suffix:semicolon
r_return
id|ide_started
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Complete previously submitted bios (if any).&n;&t; * Status was already verifyied.&n;&t; */
r_while
c_loop
(paren
id|rq-&gt;bio
op_ne
id|rq-&gt;cbio
)paren
r_if
c_cond
(paren
op_logical_neg
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|end_request
c_func
(paren
id|drive
comma
l_int|1
comma
id|bio_sectors
c_func
(paren
id|rq-&gt;bio
)paren
)paren
)paren
r_return
id|ide_stopped
suffix:semicolon
multiline_comment|/* Complete rq-&gt;buffer based request (ioctls). */
r_if
c_cond
(paren
op_logical_neg
id|rq-&gt;bio
op_logical_and
op_logical_neg
id|rq-&gt;nr_sectors
)paren
(brace
id|ide_end_drive_cmd
c_func
(paren
id|drive
comma
id|stat
comma
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_ERROR_REG
)paren
)paren
suffix:semicolon
r_return
id|ide_stopped
suffix:semicolon
)brace
id|rq-&gt;errors
op_assign
l_int|0
suffix:semicolon
id|task_sectors
c_func
(paren
id|drive
comma
id|rq
comma
l_int|1
comma
id|IDE_PIO_IN
)paren
suffix:semicolon
multiline_comment|/* If it was the last datablock check status and finish transfer. */
r_if
c_cond
(paren
op_logical_neg
id|rq-&gt;nr_sectors
)paren
(brace
id|good_stat
op_assign
l_int|0
suffix:semicolon
id|stat
op_assign
id|wait_drive_not_busy
c_func
(paren
id|drive
)paren
suffix:semicolon
r_goto
id|check_status
suffix:semicolon
)brace
multiline_comment|/* Still data left to transfer. */
id|ide_set_handler
c_func
(paren
id|drive
comma
op_amp
id|task_in_intr
comma
id|WAIT_WORSTCASE
comma
l_int|NULL
)paren
suffix:semicolon
r_return
id|ide_started
suffix:semicolon
)brace
DECL|variable|task_in_intr
id|EXPORT_SYMBOL
c_func
(paren
id|task_in_intr
)paren
suffix:semicolon
multiline_comment|/*&n; * Handler for command with PIO data-in phase (Read Multiple).&n; */
DECL|function|task_mulin_intr
id|ide_startstop_t
id|task_mulin_intr
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_struct
id|request
op_star
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
r_int
r_int
id|msect
op_assign
id|drive-&gt;mult_count
suffix:semicolon
r_int
r_int
id|nsect
suffix:semicolon
id|u8
id|stat
comma
id|good_stat
suffix:semicolon
id|good_stat
op_assign
id|DATA_READY
suffix:semicolon
id|stat
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_STATUS_REG
)paren
suffix:semicolon
id|check_status
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|OK_STAT
c_func
(paren
id|stat
comma
id|good_stat
comma
id|BAD_R_STAT
)paren
)paren
(brace
r_if
c_cond
(paren
id|stat
op_amp
(paren
id|ERR_STAT
op_or
id|DRQ_STAT
)paren
)paren
r_return
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|error
c_func
(paren
id|drive
comma
id|__FUNCTION__
comma
id|stat
)paren
suffix:semicolon
multiline_comment|/* BUSY_STAT: No data yet, so wait for another IRQ. */
id|ide_set_handler
c_func
(paren
id|drive
comma
op_amp
id|task_mulin_intr
comma
id|WAIT_WORSTCASE
comma
l_int|NULL
)paren
suffix:semicolon
r_return
id|ide_started
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Complete previously submitted bios (if any).&n;&t; * Status was already verifyied.&n;&t; */
r_while
c_loop
(paren
id|rq-&gt;bio
op_ne
id|rq-&gt;cbio
)paren
r_if
c_cond
(paren
op_logical_neg
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|end_request
c_func
(paren
id|drive
comma
l_int|1
comma
id|bio_sectors
c_func
(paren
id|rq-&gt;bio
)paren
)paren
)paren
r_return
id|ide_stopped
suffix:semicolon
multiline_comment|/* Complete rq-&gt;buffer based request (ioctls). */
r_if
c_cond
(paren
op_logical_neg
id|rq-&gt;bio
op_logical_and
op_logical_neg
id|rq-&gt;nr_sectors
)paren
(brace
id|ide_end_drive_cmd
c_func
(paren
id|drive
comma
id|stat
comma
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_ERROR_REG
)paren
)paren
suffix:semicolon
r_return
id|ide_stopped
suffix:semicolon
)brace
id|rq-&gt;errors
op_assign
l_int|0
suffix:semicolon
r_do
(brace
id|nsect
op_assign
id|rq-&gt;current_nr_sectors
suffix:semicolon
r_if
c_cond
(paren
id|nsect
OG
id|msect
)paren
id|nsect
op_assign
id|msect
suffix:semicolon
id|task_sectors
c_func
(paren
id|drive
comma
id|rq
comma
id|nsect
comma
id|IDE_PIO_IN
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rq-&gt;nr_sectors
)paren
id|msect
op_assign
l_int|0
suffix:semicolon
r_else
id|msect
op_sub_assign
id|nsect
suffix:semicolon
)brace
r_while
c_loop
(paren
id|msect
)paren
suffix:semicolon
multiline_comment|/* If it was the last datablock check status and finish transfer. */
r_if
c_cond
(paren
op_logical_neg
id|rq-&gt;nr_sectors
)paren
(brace
id|good_stat
op_assign
l_int|0
suffix:semicolon
id|stat
op_assign
id|wait_drive_not_busy
c_func
(paren
id|drive
)paren
suffix:semicolon
r_goto
id|check_status
suffix:semicolon
)brace
multiline_comment|/* Still data left to transfer. */
id|ide_set_handler
c_func
(paren
id|drive
comma
op_amp
id|task_mulin_intr
comma
id|WAIT_WORSTCASE
comma
l_int|NULL
)paren
suffix:semicolon
r_return
id|ide_started
suffix:semicolon
)brace
DECL|variable|task_mulin_intr
id|EXPORT_SYMBOL
c_func
(paren
id|task_mulin_intr
)paren
suffix:semicolon
multiline_comment|/*&n; * Handler for command with PIO data-out phase (Write).&n; */
DECL|function|task_out_intr
id|ide_startstop_t
id|task_out_intr
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_struct
id|request
op_star
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
id|u8
id|stat
suffix:semicolon
id|stat
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_STATUS_REG
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|OK_STAT
c_func
(paren
id|stat
comma
id|DRIVE_READY
comma
id|drive-&gt;bad_wstat
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|stat
op_amp
(paren
id|ERR_STAT
op_or
id|DRQ_STAT
)paren
)paren
op_logical_or
(paren
(paren
id|stat
op_amp
id|WRERR_STAT
)paren
op_logical_and
op_logical_neg
id|drive-&gt;nowerr
)paren
)paren
r_return
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|error
c_func
(paren
id|drive
comma
id|__FUNCTION__
comma
id|stat
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_amp
id|BUSY_STAT
)paren
(brace
multiline_comment|/* Not ready yet, so wait for another IRQ. */
id|ide_set_handler
c_func
(paren
id|drive
comma
op_amp
id|task_out_intr
comma
id|WAIT_WORSTCASE
comma
l_int|NULL
)paren
suffix:semicolon
r_return
id|ide_started
suffix:semicolon
)brace
)brace
multiline_comment|/* Deal with unexpected ATA data phase. */
r_if
c_cond
(paren
(paren
op_logical_neg
(paren
id|stat
op_amp
id|DATA_READY
)paren
op_logical_and
id|rq-&gt;nr_sectors
)paren
op_logical_or
(paren
(paren
id|stat
op_amp
id|DATA_READY
)paren
op_logical_and
op_logical_neg
id|rq-&gt;nr_sectors
)paren
)paren
r_return
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|error
c_func
(paren
id|drive
comma
id|__FUNCTION__
comma
id|stat
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * Complete previously submitted bios (if any).&n;&t; * Status was already verifyied.&n;&t; */
r_while
c_loop
(paren
id|rq-&gt;bio
op_ne
id|rq-&gt;cbio
)paren
r_if
c_cond
(paren
op_logical_neg
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|end_request
c_func
(paren
id|drive
comma
l_int|1
comma
id|bio_sectors
c_func
(paren
id|rq-&gt;bio
)paren
)paren
)paren
r_return
id|ide_stopped
suffix:semicolon
multiline_comment|/* Complete rq-&gt;buffer based request (ioctls). */
r_if
c_cond
(paren
op_logical_neg
id|rq-&gt;bio
op_logical_and
op_logical_neg
id|rq-&gt;nr_sectors
)paren
(brace
id|ide_end_drive_cmd
c_func
(paren
id|drive
comma
id|stat
comma
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_ERROR_REG
)paren
)paren
suffix:semicolon
r_return
id|ide_stopped
suffix:semicolon
)brace
multiline_comment|/* Still data left to transfer. */
id|ide_set_handler
c_func
(paren
id|drive
comma
op_amp
id|task_out_intr
comma
id|WAIT_WORSTCASE
comma
l_int|NULL
)paren
suffix:semicolon
id|rq-&gt;errors
op_assign
l_int|0
suffix:semicolon
id|task_sectors
c_func
(paren
id|drive
comma
id|rq
comma
l_int|1
comma
id|IDE_PIO_OUT
)paren
suffix:semicolon
r_return
id|ide_started
suffix:semicolon
)brace
DECL|variable|task_out_intr
id|EXPORT_SYMBOL
c_func
(paren
id|task_out_intr
)paren
suffix:semicolon
DECL|function|pre_task_out_intr
id|ide_startstop_t
id|pre_task_out_intr
(paren
id|ide_drive_t
op_star
id|drive
comma
r_struct
id|request
op_star
id|rq
)paren
(brace
id|ide_startstop_t
id|startstop
suffix:semicolon
r_if
c_cond
(paren
id|ide_wait_stat
c_func
(paren
op_amp
id|startstop
comma
id|drive
comma
id|DATA_READY
comma
id|drive-&gt;bad_wstat
comma
id|WAIT_DRQ
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: no DRQ after issuing WRITE%s&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|drive-&gt;addressing
ques
c_cond
l_string|&quot;_EXT&quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
r_return
id|startstop
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|drive-&gt;unmask
)paren
id|local_irq_disable
c_func
(paren
)paren
suffix:semicolon
r_return
id|task_out_intr
c_func
(paren
id|drive
)paren
suffix:semicolon
)brace
DECL|variable|pre_task_out_intr
id|EXPORT_SYMBOL
c_func
(paren
id|pre_task_out_intr
)paren
suffix:semicolon
multiline_comment|/*&n; * Handler for command with PIO data-out phase (Write Multiple).&n; */
DECL|function|task_mulout_intr
id|ide_startstop_t
id|task_mulout_intr
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_struct
id|request
op_star
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
r_int
r_int
id|msect
op_assign
id|drive-&gt;mult_count
suffix:semicolon
r_int
r_int
id|nsect
suffix:semicolon
id|u8
id|stat
suffix:semicolon
id|stat
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_STATUS_REG
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|OK_STAT
c_func
(paren
id|stat
comma
id|DRIVE_READY
comma
id|drive-&gt;bad_wstat
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|stat
op_amp
(paren
id|ERR_STAT
op_or
id|DRQ_STAT
)paren
)paren
op_logical_or
(paren
(paren
id|stat
op_amp
id|WRERR_STAT
)paren
op_logical_and
op_logical_neg
id|drive-&gt;nowerr
)paren
)paren
r_return
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|error
c_func
(paren
id|drive
comma
id|__FUNCTION__
comma
id|stat
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_amp
id|BUSY_STAT
)paren
(brace
multiline_comment|/* Not ready yet, so wait for another IRQ. */
id|ide_set_handler
c_func
(paren
id|drive
comma
op_amp
id|task_mulout_intr
comma
id|WAIT_WORSTCASE
comma
l_int|NULL
)paren
suffix:semicolon
r_return
id|ide_started
suffix:semicolon
)brace
)brace
multiline_comment|/* Deal with unexpected ATA data phase. */
r_if
c_cond
(paren
(paren
op_logical_neg
(paren
id|stat
op_amp
id|DATA_READY
)paren
op_logical_and
id|rq-&gt;nr_sectors
)paren
op_logical_or
(paren
(paren
id|stat
op_amp
id|DATA_READY
)paren
op_logical_and
op_logical_neg
id|rq-&gt;nr_sectors
)paren
)paren
r_return
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|error
c_func
(paren
id|drive
comma
id|__FUNCTION__
comma
id|stat
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * Complete previously submitted bios (if any).&n;&t; * Status was already verifyied.&n;&t; */
r_while
c_loop
(paren
id|rq-&gt;bio
op_ne
id|rq-&gt;cbio
)paren
r_if
c_cond
(paren
op_logical_neg
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|end_request
c_func
(paren
id|drive
comma
l_int|1
comma
id|bio_sectors
c_func
(paren
id|rq-&gt;bio
)paren
)paren
)paren
r_return
id|ide_stopped
suffix:semicolon
multiline_comment|/* Complete rq-&gt;buffer based request (ioctls). */
r_if
c_cond
(paren
op_logical_neg
id|rq-&gt;bio
op_logical_and
op_logical_neg
id|rq-&gt;nr_sectors
)paren
(brace
id|ide_end_drive_cmd
c_func
(paren
id|drive
comma
id|stat
comma
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_ERROR_REG
)paren
)paren
suffix:semicolon
r_return
id|ide_stopped
suffix:semicolon
)brace
multiline_comment|/* Still data left to transfer. */
id|ide_set_handler
c_func
(paren
id|drive
comma
op_amp
id|task_mulout_intr
comma
id|WAIT_WORSTCASE
comma
l_int|NULL
)paren
suffix:semicolon
id|rq-&gt;errors
op_assign
l_int|0
suffix:semicolon
r_do
(brace
id|nsect
op_assign
id|rq-&gt;current_nr_sectors
suffix:semicolon
r_if
c_cond
(paren
id|nsect
OG
id|msect
)paren
id|nsect
op_assign
id|msect
suffix:semicolon
id|task_sectors
c_func
(paren
id|drive
comma
id|rq
comma
id|nsect
comma
id|IDE_PIO_OUT
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rq-&gt;nr_sectors
)paren
id|msect
op_assign
l_int|0
suffix:semicolon
r_else
id|msect
op_sub_assign
id|nsect
suffix:semicolon
)brace
r_while
c_loop
(paren
id|msect
)paren
suffix:semicolon
r_return
id|ide_started
suffix:semicolon
)brace
DECL|variable|task_mulout_intr
id|EXPORT_SYMBOL
c_func
(paren
id|task_mulout_intr
)paren
suffix:semicolon
DECL|function|pre_task_mulout_intr
id|ide_startstop_t
id|pre_task_mulout_intr
(paren
id|ide_drive_t
op_star
id|drive
comma
r_struct
id|request
op_star
id|rq
)paren
(brace
id|ide_startstop_t
id|startstop
suffix:semicolon
r_if
c_cond
(paren
id|ide_wait_stat
c_func
(paren
op_amp
id|startstop
comma
id|drive
comma
id|DATA_READY
comma
id|drive-&gt;bad_wstat
comma
id|WAIT_DRQ
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: no DRQ after issuing MULTWRITE%s&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|drive-&gt;addressing
ques
c_cond
l_string|&quot;_EXT&quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
r_return
id|startstop
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|drive-&gt;unmask
)paren
id|local_irq_disable
c_func
(paren
)paren
suffix:semicolon
r_return
id|task_mulout_intr
c_func
(paren
id|drive
)paren
suffix:semicolon
)brace
DECL|variable|pre_task_mulout_intr
id|EXPORT_SYMBOL
c_func
(paren
id|pre_task_mulout_intr
)paren
suffix:semicolon
macro_line|#endif /* !CONFIG_IDE_TASKFILE_IO */
DECL|function|ide_diag_taskfile
r_int
id|ide_diag_taskfile
(paren
id|ide_drive_t
op_star
id|drive
comma
id|ide_task_t
op_star
id|args
comma
r_int
r_int
id|data_size
comma
id|u8
op_star
id|buf
)paren
(brace
r_struct
id|request
id|rq
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|rq
comma
l_int|0
comma
r_sizeof
(paren
id|rq
)paren
)paren
suffix:semicolon
id|rq.flags
op_assign
id|REQ_DRIVE_TASKFILE
suffix:semicolon
id|rq.buffer
op_assign
id|buf
suffix:semicolon
multiline_comment|/*&n;&t; * (ks) We transfer currently only whole sectors.&n;&t; * This is suffient for now.  But, it would be great,&n;&t; * if we would find a solution to transfer any size.&n;&t; * To support special commands like READ LONG.&n;&t; */
r_if
c_cond
(paren
id|args-&gt;command_type
op_ne
id|IDE_DRIVE_TASK_NO_DATA
)paren
(brace
r_if
c_cond
(paren
id|data_size
op_eq
l_int|0
)paren
id|rq.nr_sectors
op_assign
(paren
id|args-&gt;hobRegister
(braket
id|IDE_NSECTOR_OFFSET
)braket
op_lshift
l_int|8
)paren
op_or
id|args-&gt;tfRegister
(braket
id|IDE_NSECTOR_OFFSET
)braket
suffix:semicolon
r_else
id|rq.nr_sectors
op_assign
id|data_size
op_div
id|SECTOR_SIZE
suffix:semicolon
id|rq.hard_nr_sectors
op_assign
id|rq.nr_sectors
suffix:semicolon
id|rq.hard_cur_sectors
op_assign
id|rq.current_nr_sectors
op_assign
id|rq.nr_sectors
suffix:semicolon
)brace
id|rq.special
op_assign
id|args
suffix:semicolon
r_return
id|ide_do_drive_cmd
c_func
(paren
id|drive
comma
op_amp
id|rq
comma
id|ide_wait
)paren
suffix:semicolon
)brace
DECL|variable|ide_diag_taskfile
id|EXPORT_SYMBOL
c_func
(paren
id|ide_diag_taskfile
)paren
suffix:semicolon
DECL|function|ide_raw_taskfile
r_int
id|ide_raw_taskfile
(paren
id|ide_drive_t
op_star
id|drive
comma
id|ide_task_t
op_star
id|args
comma
id|u8
op_star
id|buf
)paren
(brace
r_return
id|ide_diag_taskfile
c_func
(paren
id|drive
comma
id|args
comma
l_int|0
comma
id|buf
)paren
suffix:semicolon
)brace
DECL|variable|ide_raw_taskfile
id|EXPORT_SYMBOL
c_func
(paren
id|ide_raw_taskfile
)paren
suffix:semicolon
DECL|macro|MAX_DMA
mdefine_line|#define MAX_DMA&t;&t;(256*SECTOR_WORDS)
id|ide_startstop_t
id|flagged_taskfile
c_func
(paren
id|ide_drive_t
op_star
comma
id|ide_task_t
op_star
)paren
suffix:semicolon
id|ide_startstop_t
id|flagged_task_no_data_intr
c_func
(paren
id|ide_drive_t
op_star
)paren
suffix:semicolon
id|ide_startstop_t
id|flagged_task_in_intr
c_func
(paren
id|ide_drive_t
op_star
)paren
suffix:semicolon
id|ide_startstop_t
id|flagged_task_mulin_intr
c_func
(paren
id|ide_drive_t
op_star
)paren
suffix:semicolon
id|ide_startstop_t
id|flagged_pre_task_out_intr
c_func
(paren
id|ide_drive_t
op_star
comma
r_struct
id|request
op_star
)paren
suffix:semicolon
id|ide_startstop_t
id|flagged_task_out_intr
c_func
(paren
id|ide_drive_t
op_star
)paren
suffix:semicolon
id|ide_startstop_t
id|flagged_pre_task_mulout_intr
c_func
(paren
id|ide_drive_t
op_star
comma
r_struct
id|request
op_star
)paren
suffix:semicolon
id|ide_startstop_t
id|flagged_task_mulout_intr
c_func
(paren
id|ide_drive_t
op_star
)paren
suffix:semicolon
DECL|function|ide_taskfile_ioctl
r_int
id|ide_taskfile_ioctl
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
id|ide_task_request_t
op_star
id|req_task
suffix:semicolon
id|ide_task_t
id|args
suffix:semicolon
id|u8
op_star
id|outbuf
op_assign
l_int|NULL
suffix:semicolon
id|u8
op_star
id|inbuf
op_assign
l_int|NULL
suffix:semicolon
id|task_ioreg_t
op_star
id|argsptr
op_assign
id|args.tfRegister
suffix:semicolon
id|task_ioreg_t
op_star
id|hobsptr
op_assign
id|args.hobRegister
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
r_int
id|tasksize
op_assign
r_sizeof
(paren
r_struct
id|ide_task_request_s
)paren
suffix:semicolon
r_int
id|taskin
op_assign
l_int|0
suffix:semicolon
r_int
id|taskout
op_assign
l_int|0
suffix:semicolon
id|u8
id|io_32bit
op_assign
id|drive-&gt;io_32bit
suffix:semicolon
r_char
id|__user
op_star
id|buf
op_assign
(paren
r_char
id|__user
op_star
)paren
id|arg
suffix:semicolon
singleline_comment|//&t;printk(&quot;IDE Taskfile ...&bslash;n&quot;);
id|req_task
op_assign
id|kmalloc
c_func
(paren
id|tasksize
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|req_task
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|memset
c_func
(paren
id|req_task
comma
l_int|0
comma
id|tasksize
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|req_task
comma
id|buf
comma
id|tasksize
)paren
)paren
(brace
id|kfree
c_func
(paren
id|req_task
)paren
suffix:semicolon
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
id|taskout
op_assign
(paren
r_int
)paren
id|req_task-&gt;out_size
suffix:semicolon
id|taskin
op_assign
(paren
r_int
)paren
id|req_task-&gt;in_size
suffix:semicolon
r_if
c_cond
(paren
id|taskout
)paren
(brace
r_int
id|outtotal
op_assign
id|tasksize
suffix:semicolon
id|outbuf
op_assign
id|kmalloc
c_func
(paren
id|taskout
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|outbuf
op_eq
l_int|NULL
)paren
(brace
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
id|memset
c_func
(paren
id|outbuf
comma
l_int|0
comma
id|taskout
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|outbuf
comma
id|buf
op_plus
id|outtotal
comma
id|taskout
)paren
)paren
(brace
id|err
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|taskin
)paren
(brace
r_int
id|intotal
op_assign
id|tasksize
op_plus
id|taskout
suffix:semicolon
id|inbuf
op_assign
id|kmalloc
c_func
(paren
id|taskin
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inbuf
op_eq
l_int|NULL
)paren
(brace
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
id|memset
c_func
(paren
id|inbuf
comma
l_int|0
comma
id|taskin
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|inbuf
comma
id|buf
op_plus
id|intotal
comma
id|taskin
)paren
)paren
(brace
id|err
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
)brace
id|memset
c_func
(paren
op_amp
id|args
comma
l_int|0
comma
r_sizeof
(paren
id|ide_task_t
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|argsptr
comma
id|req_task-&gt;io_ports
comma
id|HDIO_DRIVE_TASK_HDR_SIZE
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|hobsptr
comma
id|req_task-&gt;hob_ports
comma
id|HDIO_DRIVE_HOB_HDR_SIZE
)paren
suffix:semicolon
id|args.tf_in_flags
op_assign
id|req_task-&gt;in_flags
suffix:semicolon
id|args.tf_out_flags
op_assign
id|req_task-&gt;out_flags
suffix:semicolon
id|args.data_phase
op_assign
id|req_task-&gt;data_phase
suffix:semicolon
id|args.command_type
op_assign
id|req_task-&gt;req_cmd
suffix:semicolon
id|drive-&gt;io_32bit
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|req_task-&gt;data_phase
)paren
(brace
r_case
id|TASKFILE_OUT_DMAQ
suffix:colon
r_case
id|TASKFILE_OUT_DMA
suffix:colon
id|err
op_assign
id|ide_diag_taskfile
c_func
(paren
id|drive
comma
op_amp
id|args
comma
id|taskout
comma
id|outbuf
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TASKFILE_IN_DMAQ
suffix:colon
r_case
id|TASKFILE_IN_DMA
suffix:colon
id|err
op_assign
id|ide_diag_taskfile
c_func
(paren
id|drive
comma
op_amp
id|args
comma
id|taskin
comma
id|inbuf
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TASKFILE_IN_OUT
suffix:colon
macro_line|#if 0
id|args.prehandler
op_assign
op_amp
id|pre_task_out_intr
suffix:semicolon
id|args.handler
op_assign
op_amp
id|task_out_intr
suffix:semicolon
id|err
op_assign
id|ide_diag_taskfile
c_func
(paren
id|drive
comma
op_amp
id|args
comma
id|taskout
comma
id|outbuf
)paren
suffix:semicolon
id|args.prehandler
op_assign
l_int|NULL
suffix:semicolon
id|args.handler
op_assign
op_amp
id|task_in_intr
suffix:semicolon
id|err
op_assign
id|ide_diag_taskfile
c_func
(paren
id|drive
comma
op_amp
id|args
comma
id|taskin
comma
id|inbuf
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#else
id|err
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
m_abort
suffix:semicolon
macro_line|#endif
r_case
id|TASKFILE_MULTI_OUT
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|drive-&gt;mult_count
)paren
(brace
multiline_comment|/* (hs): give up if multcount is not set */
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: %s Multimode Write &quot;
"&bslash;"
l_string|&quot;multcount is not set&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|__FUNCTION__
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EPERM
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
r_if
c_cond
(paren
id|args.tf_out_flags.all
op_ne
l_int|0
)paren
(brace
id|args.prehandler
op_assign
op_amp
id|flagged_pre_task_mulout_intr
suffix:semicolon
id|args.handler
op_assign
op_amp
id|flagged_task_mulout_intr
suffix:semicolon
)brace
r_else
(brace
id|args.prehandler
op_assign
op_amp
id|pre_task_mulout_intr
suffix:semicolon
id|args.handler
op_assign
op_amp
id|task_mulout_intr
suffix:semicolon
)brace
id|err
op_assign
id|ide_diag_taskfile
c_func
(paren
id|drive
comma
op_amp
id|args
comma
id|taskout
comma
id|outbuf
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TASKFILE_OUT
suffix:colon
r_if
c_cond
(paren
id|args.tf_out_flags.all
op_ne
l_int|0
)paren
(brace
id|args.prehandler
op_assign
op_amp
id|flagged_pre_task_out_intr
suffix:semicolon
id|args.handler
op_assign
op_amp
id|flagged_task_out_intr
suffix:semicolon
)brace
r_else
(brace
id|args.prehandler
op_assign
op_amp
id|pre_task_out_intr
suffix:semicolon
id|args.handler
op_assign
op_amp
id|task_out_intr
suffix:semicolon
)brace
id|err
op_assign
id|ide_diag_taskfile
c_func
(paren
id|drive
comma
op_amp
id|args
comma
id|taskout
comma
id|outbuf
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TASKFILE_MULTI_IN
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|drive-&gt;mult_count
)paren
(brace
multiline_comment|/* (hs): give up if multcount is not set */
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: %s Multimode Read failure &quot;
"&bslash;"
l_string|&quot;multcount is not set&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|__FUNCTION__
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EPERM
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
r_if
c_cond
(paren
id|args.tf_out_flags.all
op_ne
l_int|0
)paren
(brace
id|args.handler
op_assign
op_amp
id|flagged_task_mulin_intr
suffix:semicolon
)brace
r_else
(brace
id|args.handler
op_assign
op_amp
id|task_mulin_intr
suffix:semicolon
)brace
id|err
op_assign
id|ide_diag_taskfile
c_func
(paren
id|drive
comma
op_amp
id|args
comma
id|taskin
comma
id|inbuf
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TASKFILE_IN
suffix:colon
r_if
c_cond
(paren
id|args.tf_out_flags.all
op_ne
l_int|0
)paren
(brace
id|args.handler
op_assign
op_amp
id|flagged_task_in_intr
suffix:semicolon
)brace
r_else
(brace
id|args.handler
op_assign
op_amp
id|task_in_intr
suffix:semicolon
)brace
id|err
op_assign
id|ide_diag_taskfile
c_func
(paren
id|drive
comma
op_amp
id|args
comma
id|taskin
comma
id|inbuf
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TASKFILE_NO_DATA
suffix:colon
r_if
c_cond
(paren
id|args.tf_out_flags.all
op_ne
l_int|0
)paren
(brace
id|args.handler
op_assign
op_amp
id|flagged_task_no_data_intr
suffix:semicolon
)brace
r_else
(brace
id|args.handler
op_assign
op_amp
id|task_no_data_intr
suffix:semicolon
)brace
id|err
op_assign
id|ide_diag_taskfile
c_func
(paren
id|drive
comma
op_amp
id|args
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|err
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|req_task-&gt;io_ports
comma
op_amp
(paren
id|args.tfRegister
)paren
comma
id|HDIO_DRIVE_TASK_HDR_SIZE
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|req_task-&gt;hob_ports
comma
op_amp
(paren
id|args.hobRegister
)paren
comma
id|HDIO_DRIVE_HOB_HDR_SIZE
)paren
suffix:semicolon
id|req_task-&gt;in_flags
op_assign
id|args.tf_in_flags
suffix:semicolon
id|req_task-&gt;out_flags
op_assign
id|args.tf_out_flags
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|buf
comma
id|req_task
comma
id|tasksize
)paren
)paren
(brace
id|err
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
r_if
c_cond
(paren
id|taskout
)paren
(brace
r_int
id|outtotal
op_assign
id|tasksize
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|buf
op_plus
id|outtotal
comma
id|outbuf
comma
id|taskout
)paren
)paren
(brace
id|err
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|taskin
)paren
(brace
r_int
id|intotal
op_assign
id|tasksize
op_plus
id|taskout
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|buf
op_plus
id|intotal
comma
id|inbuf
comma
id|taskin
)paren
)paren
(brace
id|err
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
)brace
m_abort
suffix:colon
id|kfree
c_func
(paren
id|req_task
)paren
suffix:semicolon
r_if
c_cond
(paren
id|outbuf
op_ne
l_int|NULL
)paren
id|kfree
c_func
(paren
id|outbuf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inbuf
op_ne
l_int|NULL
)paren
id|kfree
c_func
(paren
id|inbuf
)paren
suffix:semicolon
singleline_comment|//&t;printk(&quot;IDE Taskfile ioctl ended. rc = %i&bslash;n&quot;, err);
id|drive-&gt;io_32bit
op_assign
id|io_32bit
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|variable|ide_taskfile_ioctl
id|EXPORT_SYMBOL
c_func
(paren
id|ide_taskfile_ioctl
)paren
suffix:semicolon
DECL|function|ide_wait_cmd
r_int
id|ide_wait_cmd
(paren
id|ide_drive_t
op_star
id|drive
comma
id|u8
id|cmd
comma
id|u8
id|nsect
comma
id|u8
id|feature
comma
id|u8
id|sectors
comma
id|u8
op_star
id|buf
)paren
(brace
r_struct
id|request
id|rq
suffix:semicolon
id|u8
id|buffer
(braket
l_int|4
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buf
)paren
id|buf
op_assign
id|buffer
suffix:semicolon
id|memset
c_func
(paren
id|buf
comma
l_int|0
comma
l_int|4
op_plus
id|SECTOR_WORDS
op_star
l_int|4
op_star
id|sectors
)paren
suffix:semicolon
id|ide_init_drive_cmd
c_func
(paren
op_amp
id|rq
)paren
suffix:semicolon
id|rq.buffer
op_assign
id|buf
suffix:semicolon
op_star
id|buf
op_increment
op_assign
id|cmd
suffix:semicolon
op_star
id|buf
op_increment
op_assign
id|nsect
suffix:semicolon
op_star
id|buf
op_increment
op_assign
id|feature
suffix:semicolon
op_star
id|buf
op_increment
op_assign
id|sectors
suffix:semicolon
r_return
id|ide_do_drive_cmd
c_func
(paren
id|drive
comma
op_amp
id|rq
comma
id|ide_wait
)paren
suffix:semicolon
)brace
DECL|variable|ide_wait_cmd
id|EXPORT_SYMBOL
c_func
(paren
id|ide_wait_cmd
)paren
suffix:semicolon
multiline_comment|/*&n; * FIXME : this needs to map into at taskfile. &lt;andre@linux-ide.org&gt;&n; */
DECL|function|ide_cmd_ioctl
r_int
id|ide_cmd_ioctl
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_int
id|err
op_assign
l_int|0
suffix:semicolon
id|u8
id|args
(braket
l_int|4
)braket
comma
op_star
id|argbuf
op_assign
id|args
suffix:semicolon
id|u8
id|xfer_rate
op_assign
l_int|0
suffix:semicolon
r_int
id|argsize
op_assign
l_int|4
suffix:semicolon
id|ide_task_t
id|tfargs
suffix:semicolon
r_if
c_cond
(paren
l_int|NULL
op_eq
(paren
r_void
op_star
)paren
id|arg
)paren
(brace
r_struct
id|request
id|rq
suffix:semicolon
id|ide_init_drive_cmd
c_func
(paren
op_amp
id|rq
)paren
suffix:semicolon
r_return
id|ide_do_drive_cmd
c_func
(paren
id|drive
comma
op_amp
id|rq
comma
id|ide_wait
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|args
comma
(paren
r_void
id|__user
op_star
)paren
id|arg
comma
l_int|4
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|tfargs
comma
l_int|0
comma
r_sizeof
(paren
id|ide_task_t
)paren
)paren
suffix:semicolon
id|tfargs.tfRegister
(braket
id|IDE_FEATURE_OFFSET
)braket
op_assign
id|args
(braket
l_int|2
)braket
suffix:semicolon
id|tfargs.tfRegister
(braket
id|IDE_NSECTOR_OFFSET
)braket
op_assign
id|args
(braket
l_int|3
)braket
suffix:semicolon
id|tfargs.tfRegister
(braket
id|IDE_SECTOR_OFFSET
)braket
op_assign
id|args
(braket
l_int|1
)braket
suffix:semicolon
id|tfargs.tfRegister
(braket
id|IDE_LCYL_OFFSET
)braket
op_assign
l_int|0x00
suffix:semicolon
id|tfargs.tfRegister
(braket
id|IDE_HCYL_OFFSET
)braket
op_assign
l_int|0x00
suffix:semicolon
id|tfargs.tfRegister
(braket
id|IDE_SELECT_OFFSET
)braket
op_assign
l_int|0x00
suffix:semicolon
id|tfargs.tfRegister
(braket
id|IDE_COMMAND_OFFSET
)braket
op_assign
id|args
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
id|args
(braket
l_int|3
)braket
)paren
(brace
id|argsize
op_assign
l_int|4
op_plus
(paren
id|SECTOR_WORDS
op_star
l_int|4
op_star
id|args
(braket
l_int|3
)braket
)paren
suffix:semicolon
id|argbuf
op_assign
id|kmalloc
c_func
(paren
id|argsize
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|argbuf
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|memcpy
c_func
(paren
id|argbuf
comma
id|args
comma
l_int|4
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|set_transfer
c_func
(paren
id|drive
comma
op_amp
id|tfargs
)paren
)paren
(brace
id|xfer_rate
op_assign
id|args
(braket
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
id|ide_ata66_check
c_func
(paren
id|drive
comma
op_amp
id|tfargs
)paren
)paren
r_goto
m_abort
suffix:semicolon
)brace
id|err
op_assign
id|ide_wait_cmd
c_func
(paren
id|drive
comma
id|args
(braket
l_int|0
)braket
comma
id|args
(braket
l_int|1
)braket
comma
id|args
(braket
l_int|2
)braket
comma
id|args
(braket
l_int|3
)braket
comma
id|argbuf
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|err
op_logical_and
id|xfer_rate
)paren
(brace
multiline_comment|/* active-retuning-calls future */
id|ide_set_xfer_rate
c_func
(paren
id|drive
comma
id|xfer_rate
)paren
suffix:semicolon
id|ide_driveid_update
c_func
(paren
id|drive
)paren
suffix:semicolon
)brace
m_abort
suffix:colon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
(paren
r_void
id|__user
op_star
)paren
id|arg
comma
id|argbuf
comma
id|argsize
)paren
)paren
id|err
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|argsize
OG
l_int|4
)paren
id|kfree
c_func
(paren
id|argbuf
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|variable|ide_cmd_ioctl
id|EXPORT_SYMBOL
c_func
(paren
id|ide_cmd_ioctl
)paren
suffix:semicolon
DECL|function|ide_wait_cmd_task
r_int
id|ide_wait_cmd_task
(paren
id|ide_drive_t
op_star
id|drive
comma
id|u8
op_star
id|buf
)paren
(brace
r_struct
id|request
id|rq
suffix:semicolon
id|ide_init_drive_cmd
c_func
(paren
op_amp
id|rq
)paren
suffix:semicolon
id|rq.flags
op_assign
id|REQ_DRIVE_TASK
suffix:semicolon
id|rq.buffer
op_assign
id|buf
suffix:semicolon
r_return
id|ide_do_drive_cmd
c_func
(paren
id|drive
comma
op_amp
id|rq
comma
id|ide_wait
)paren
suffix:semicolon
)brace
DECL|variable|ide_wait_cmd_task
id|EXPORT_SYMBOL
c_func
(paren
id|ide_wait_cmd_task
)paren
suffix:semicolon
multiline_comment|/*&n; * FIXME : this needs to map into at taskfile. &lt;andre@linux-ide.org&gt;&n; */
DECL|function|ide_task_ioctl
r_int
id|ide_task_ioctl
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_void
id|__user
op_star
id|p
op_assign
(paren
r_void
id|__user
op_star
)paren
id|arg
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
id|u8
id|args
(braket
l_int|7
)braket
comma
op_star
id|argbuf
op_assign
id|args
suffix:semicolon
r_int
id|argsize
op_assign
l_int|7
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|args
comma
id|p
comma
l_int|7
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|err
op_assign
id|ide_wait_cmd_task
c_func
(paren
id|drive
comma
id|argbuf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|p
comma
id|argbuf
comma
id|argsize
)paren
)paren
id|err
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|variable|ide_task_ioctl
id|EXPORT_SYMBOL
c_func
(paren
id|ide_task_ioctl
)paren
suffix:semicolon
multiline_comment|/*&n; * NOTICE: This is additions from IBM to provide a discrete interface,&n; * for selective taskregister access operations.  Nice JOB Klaus!!!&n; * Glad to be able to work and co-develop this with you and IBM.&n; */
DECL|function|flagged_taskfile
id|ide_startstop_t
id|flagged_taskfile
(paren
id|ide_drive_t
op_star
id|drive
comma
id|ide_task_t
op_star
id|task
)paren
(brace
id|ide_hwif_t
op_star
id|hwif
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
suffix:semicolon
id|task_struct_t
op_star
id|taskfile
op_assign
(paren
id|task_struct_t
op_star
)paren
id|task-&gt;tfRegister
suffix:semicolon
id|hob_struct_t
op_star
id|hobfile
op_assign
(paren
id|hob_struct_t
op_star
)paren
id|task-&gt;hobRegister
suffix:semicolon
macro_line|#if DEBUG_TASKFILE
id|u8
id|status
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_IDE_TASK_IOCTL_DEBUG
r_void
id|debug_taskfile
c_func
(paren
id|drive
comma
id|task
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_IDE_TASK_IOCTL_DEBUG */
multiline_comment|/*&n;&t; * (ks) Check taskfile in/out flags.&n;&t; * If set, then execute as it is defined.&n;&t; * If not set, then define default settings.&n;&t; * The default values are:&n;&t; *&t;write and read all taskfile registers (except data) &n;&t; *&t;write and read the hob registers (sector,nsector,lcyl,hcyl)&n;&t; */
r_if
c_cond
(paren
id|task-&gt;tf_out_flags.all
op_eq
l_int|0
)paren
(brace
id|task-&gt;tf_out_flags.all
op_assign
id|IDE_TASKFILE_STD_OUT_FLAGS
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;addressing
op_eq
l_int|1
)paren
id|task-&gt;tf_out_flags.all
op_or_assign
(paren
id|IDE_HOB_STD_OUT_FLAGS
op_lshift
l_int|8
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|task-&gt;tf_in_flags.all
op_eq
l_int|0
)paren
(brace
id|task-&gt;tf_in_flags.all
op_assign
id|IDE_TASKFILE_STD_IN_FLAGS
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;addressing
op_eq
l_int|1
)paren
id|task-&gt;tf_in_flags.all
op_or_assign
(paren
id|IDE_HOB_STD_IN_FLAGS
op_lshift
l_int|8
)paren
suffix:semicolon
)brace
multiline_comment|/* ALL Command Block Executions SHALL clear nIEN, unless otherwise */
r_if
c_cond
(paren
id|IDE_CONTROL_REG
)paren
multiline_comment|/* clear nIEN */
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|drive-&gt;ctl
comma
id|IDE_CONTROL_REG
)paren
suffix:semicolon
id|SELECT_MASK
c_func
(paren
id|drive
comma
l_int|0
)paren
suffix:semicolon
macro_line|#if DEBUG_TASKFILE
id|status
op_assign
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_STATUS_REG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
l_int|0x80
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;flagged_taskfile -&gt; Bad status. Status = %02x. wait 100 usec ...&bslash;n&quot;
comma
id|status
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|100
)paren
suffix:semicolon
id|status
op_assign
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_STATUS_REG
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;flagged_taskfile -&gt; Status = %02x&bslash;n&quot;
comma
id|status
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|task-&gt;tf_out_flags.b.data
)paren
(brace
id|u16
id|data
op_assign
id|taskfile-&gt;data
op_plus
(paren
id|hobfile-&gt;data
op_lshift
l_int|8
)paren
suffix:semicolon
id|hwif
op_member_access_from_pointer
id|OUTW
c_func
(paren
id|data
comma
id|IDE_DATA_REG
)paren
suffix:semicolon
)brace
multiline_comment|/* (ks) send hob registers first */
r_if
c_cond
(paren
id|task-&gt;tf_out_flags.b.nsector_hob
)paren
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|hobfile-&gt;sector_count
comma
id|IDE_NSECTOR_REG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|task-&gt;tf_out_flags.b.sector_hob
)paren
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|hobfile-&gt;sector_number
comma
id|IDE_SECTOR_REG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|task-&gt;tf_out_flags.b.lcyl_hob
)paren
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|hobfile-&gt;low_cylinder
comma
id|IDE_LCYL_REG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|task-&gt;tf_out_flags.b.hcyl_hob
)paren
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|hobfile-&gt;high_cylinder
comma
id|IDE_HCYL_REG
)paren
suffix:semicolon
multiline_comment|/* (ks) Send now the standard registers */
r_if
c_cond
(paren
id|task-&gt;tf_out_flags.b.error_feature
)paren
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|taskfile-&gt;feature
comma
id|IDE_FEATURE_REG
)paren
suffix:semicolon
multiline_comment|/* refers to number of sectors to transfer */
r_if
c_cond
(paren
id|task-&gt;tf_out_flags.b.nsector
)paren
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|taskfile-&gt;sector_count
comma
id|IDE_NSECTOR_REG
)paren
suffix:semicolon
multiline_comment|/* refers to sector offset or start sector */
r_if
c_cond
(paren
id|task-&gt;tf_out_flags.b.sector
)paren
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|taskfile-&gt;sector_number
comma
id|IDE_SECTOR_REG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|task-&gt;tf_out_flags.b.lcyl
)paren
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|taskfile-&gt;low_cylinder
comma
id|IDE_LCYL_REG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|task-&gt;tf_out_flags.b.hcyl
)paren
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|taskfile-&gt;high_cylinder
comma
id|IDE_HCYL_REG
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * (ks) In the flagged taskfile approch, we will used all specified&n;&t; * registers and the register value will not be changed. Except the&n;&t; * select bit (master/slave) in the drive_head register. We must make&n;&t; * sure that the desired drive is selected.&n;&t; */
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|taskfile-&gt;device_head
op_or
id|drive-&gt;select.all
comma
id|IDE_SELECT_REG
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|task-&gt;data_phase
)paren
(brace
r_case
id|TASKFILE_OUT_DMAQ
suffix:colon
r_case
id|TASKFILE_OUT_DMA
suffix:colon
id|hwif
op_member_access_from_pointer
id|ide_dma_write
c_func
(paren
id|drive
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TASKFILE_IN_DMAQ
suffix:colon
r_case
id|TASKFILE_IN_DMA
suffix:colon
id|hwif
op_member_access_from_pointer
id|ide_dma_read
c_func
(paren
id|drive
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
r_if
c_cond
(paren
id|task-&gt;handler
op_eq
l_int|NULL
)paren
r_return
id|ide_stopped
suffix:semicolon
multiline_comment|/* Issue the command */
id|ide_execute_command
c_func
(paren
id|drive
comma
id|taskfile-&gt;command
comma
id|task-&gt;handler
comma
id|WAIT_WORSTCASE
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|task-&gt;prehandler
op_ne
l_int|NULL
)paren
r_return
id|task
op_member_access_from_pointer
id|prehandler
c_func
(paren
id|drive
comma
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
)paren
suffix:semicolon
)brace
r_return
id|ide_started
suffix:semicolon
)brace
DECL|variable|flagged_taskfile
id|EXPORT_SYMBOL
c_func
(paren
id|flagged_taskfile
)paren
suffix:semicolon
DECL|function|flagged_task_no_data_intr
id|ide_startstop_t
id|flagged_task_no_data_intr
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|ide_hwif_t
op_star
id|hwif
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
suffix:semicolon
id|u8
id|stat
suffix:semicolon
id|local_irq_enable
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|OK_STAT
c_func
(paren
id|stat
op_assign
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_STATUS_REG
)paren
comma
id|READY_STAT
comma
id|BAD_STAT
)paren
)paren
(brace
r_if
c_cond
(paren
id|stat
op_amp
id|ERR_STAT
)paren
(brace
r_return
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|error
c_func
(paren
id|drive
comma
l_string|&quot;flagged_task_no_data_intr&quot;
comma
id|stat
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * (ks) Unexpected ATA data phase detected.&n;&t;&t; * This should not happen. But, it can !&n;&t;&t; * I am not sure, which function is best to clean up&n;&t;&t; * this situation.  I choose: ide_error(...)&n;&t;&t; */
r_return
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|error
c_func
(paren
id|drive
comma
l_string|&quot;flagged_task_no_data_intr (unexpected phase)&quot;
comma
id|stat
)paren
suffix:semicolon
)brace
id|ide_end_drive_cmd
c_func
(paren
id|drive
comma
id|stat
comma
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_ERROR_REG
)paren
)paren
suffix:semicolon
r_return
id|ide_stopped
suffix:semicolon
)brace
multiline_comment|/*&n; * Handler for command with PIO data-in phase&n; */
DECL|function|flagged_task_in_intr
id|ide_startstop_t
id|flagged_task_in_intr
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|ide_hwif_t
op_star
id|hwif
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
suffix:semicolon
id|u8
id|stat
op_assign
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_STATUS_REG
)paren
suffix:semicolon
r_struct
id|request
op_star
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
r_char
op_star
id|pBuf
op_assign
l_int|NULL
suffix:semicolon
r_int
id|retries
op_assign
l_int|5
suffix:semicolon
r_if
c_cond
(paren
id|rq-&gt;current_nr_sectors
op_eq
l_int|0
)paren
r_return
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|error
c_func
(paren
id|drive
comma
l_string|&quot;flagged_task_in_intr (no data requested)&quot;
comma
id|stat
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|OK_STAT
c_func
(paren
id|stat
comma
id|DATA_READY
comma
id|BAD_R_STAT
)paren
)paren
(brace
r_if
c_cond
(paren
id|stat
op_amp
id|ERR_STAT
)paren
(brace
r_return
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|error
c_func
(paren
id|drive
comma
l_string|&quot;flagged_task_in_intr&quot;
comma
id|stat
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * (ks) Unexpected ATA data phase detected.&n;&t;&t; * This should not happen. But, it can !&n;&t;&t; * I am not sure, which function is best to clean up&n;&t;&t; * this situation.  I choose: ide_error(...)&n;&t;&t; */
r_return
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|error
c_func
(paren
id|drive
comma
l_string|&quot;flagged_task_in_intr (unexpected data phase)&quot;
comma
id|stat
)paren
suffix:semicolon
)brace
id|pBuf
op_assign
id|rq-&gt;buffer
op_plus
(paren
(paren
id|rq-&gt;nr_sectors
op_minus
id|rq-&gt;current_nr_sectors
)paren
op_star
id|SECTOR_SIZE
)paren
suffix:semicolon
id|DTF
c_func
(paren
l_string|&quot;Read - rq-&gt;current_nr_sectors: %d, status: %02x&bslash;n&quot;
comma
(paren
r_int
)paren
id|rq-&gt;current_nr_sectors
comma
id|stat
)paren
suffix:semicolon
id|taskfile_input_data
c_func
(paren
id|drive
comma
id|pBuf
comma
id|SECTOR_WORDS
)paren
suffix:semicolon
r_if
c_cond
(paren
op_decrement
id|rq-&gt;current_nr_sectors
op_ne
l_int|0
)paren
(brace
multiline_comment|/*&n;                 * (ks) We don&squot;t know which command was executed. &n;&t;&t; * So, we wait the &squot;WORSTCASE&squot; value.&n;                 */
id|ide_set_handler
c_func
(paren
id|drive
comma
op_amp
id|flagged_task_in_intr
comma
id|WAIT_WORSTCASE
comma
l_int|NULL
)paren
suffix:semicolon
r_return
id|ide_started
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * (ks) Last sector was transfered, wait until drive is ready. &n;&t; * This can take up to 10 usec. We willl wait max 50 us.&n;&t; */
r_while
c_loop
(paren
(paren
(paren
id|stat
op_assign
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_STATUS_REG
)paren
)paren
op_amp
id|BUSY_STAT
)paren
op_logical_and
id|retries
op_decrement
)paren
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
id|ide_end_drive_cmd
(paren
id|drive
comma
id|stat
comma
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_ERROR_REG
)paren
)paren
suffix:semicolon
r_return
id|ide_stopped
suffix:semicolon
)brace
DECL|function|flagged_task_mulin_intr
id|ide_startstop_t
id|flagged_task_mulin_intr
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|ide_hwif_t
op_star
id|hwif
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
suffix:semicolon
id|u8
id|stat
op_assign
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_STATUS_REG
)paren
suffix:semicolon
r_struct
id|request
op_star
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
r_char
op_star
id|pBuf
op_assign
l_int|NULL
suffix:semicolon
r_int
id|retries
op_assign
l_int|5
suffix:semicolon
r_int
r_int
id|msect
comma
id|nsect
suffix:semicolon
r_if
c_cond
(paren
id|rq-&gt;current_nr_sectors
op_eq
l_int|0
)paren
r_return
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|error
c_func
(paren
id|drive
comma
l_string|&quot;flagged_task_mulin_intr (no data requested)&quot;
comma
id|stat
)paren
suffix:semicolon
id|msect
op_assign
id|drive-&gt;mult_count
suffix:semicolon
r_if
c_cond
(paren
id|msect
op_eq
l_int|0
)paren
r_return
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|error
c_func
(paren
id|drive
comma
l_string|&quot;flagged_task_mulin_intr (multimode not set)&quot;
comma
id|stat
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|OK_STAT
c_func
(paren
id|stat
comma
id|DATA_READY
comma
id|BAD_R_STAT
)paren
)paren
(brace
r_if
c_cond
(paren
id|stat
op_amp
id|ERR_STAT
)paren
(brace
r_return
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|error
c_func
(paren
id|drive
comma
l_string|&quot;flagged_task_mulin_intr&quot;
comma
id|stat
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * (ks) Unexpected ATA data phase detected.&n;&t;&t; * This should not happen. But, it can !&n;&t;&t; * I am not sure, which function is best to clean up&n;&t;&t; * this situation.  I choose: ide_error(...)&n;&t;&t; */
r_return
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|error
c_func
(paren
id|drive
comma
l_string|&quot;flagged_task_mulin_intr (unexpected data phase)&quot;
comma
id|stat
)paren
suffix:semicolon
)brace
id|nsect
op_assign
(paren
id|rq-&gt;current_nr_sectors
OG
id|msect
)paren
ques
c_cond
id|msect
suffix:colon
id|rq-&gt;current_nr_sectors
suffix:semicolon
id|pBuf
op_assign
id|rq-&gt;buffer
op_plus
(paren
(paren
id|rq-&gt;nr_sectors
op_minus
id|rq-&gt;current_nr_sectors
)paren
op_star
id|SECTOR_SIZE
)paren
suffix:semicolon
id|DTF
c_func
(paren
l_string|&quot;Multiread: %p, nsect: %d , rq-&gt;current_nr_sectors: %ld&bslash;n&quot;
comma
id|pBuf
comma
id|nsect
comma
id|rq-&gt;current_nr_sectors
)paren
suffix:semicolon
id|taskfile_input_data
c_func
(paren
id|drive
comma
id|pBuf
comma
id|nsect
op_star
id|SECTOR_WORDS
)paren
suffix:semicolon
id|rq-&gt;current_nr_sectors
op_sub_assign
id|nsect
suffix:semicolon
r_if
c_cond
(paren
id|rq-&gt;current_nr_sectors
op_ne
l_int|0
)paren
(brace
multiline_comment|/*&n;                 * (ks) We don&squot;t know which command was executed. &n;&t;&t; * So, we wait the &squot;WORSTCASE&squot; value.&n;                 */
id|ide_set_handler
c_func
(paren
id|drive
comma
op_amp
id|flagged_task_mulin_intr
comma
id|WAIT_WORSTCASE
comma
l_int|NULL
)paren
suffix:semicolon
r_return
id|ide_started
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * (ks) Last sector was transfered, wait until drive is ready. &n;&t; * This can take up to 10 usec. We willl wait max 50 us.&n;&t; */
r_while
c_loop
(paren
(paren
(paren
id|stat
op_assign
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_STATUS_REG
)paren
)paren
op_amp
id|BUSY_STAT
)paren
op_logical_and
id|retries
op_decrement
)paren
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
id|ide_end_drive_cmd
(paren
id|drive
comma
id|stat
comma
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_ERROR_REG
)paren
)paren
suffix:semicolon
r_return
id|ide_stopped
suffix:semicolon
)brace
multiline_comment|/*&n; * Pre handler for command with PIO data-out phase&n; */
DECL|function|flagged_pre_task_out_intr
id|ide_startstop_t
id|flagged_pre_task_out_intr
(paren
id|ide_drive_t
op_star
id|drive
comma
r_struct
id|request
op_star
id|rq
)paren
(brace
id|ide_hwif_t
op_star
id|hwif
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
suffix:semicolon
id|u8
id|stat
op_assign
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_STATUS_REG
)paren
suffix:semicolon
id|ide_startstop_t
id|startstop
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rq-&gt;current_nr_sectors
)paren
(brace
r_return
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|error
c_func
(paren
id|drive
comma
l_string|&quot;flagged_pre_task_out_intr (write data not specified)&quot;
comma
id|stat
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ide_wait_stat
c_func
(paren
op_amp
id|startstop
comma
id|drive
comma
id|DATA_READY
comma
id|BAD_W_STAT
comma
id|WAIT_DRQ
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: No DRQ bit after issuing write command.&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
r_return
id|startstop
suffix:semicolon
)brace
id|taskfile_output_data
c_func
(paren
id|drive
comma
id|rq-&gt;buffer
comma
id|SECTOR_WORDS
)paren
suffix:semicolon
op_decrement
id|rq-&gt;current_nr_sectors
suffix:semicolon
r_return
id|ide_started
suffix:semicolon
)brace
DECL|function|flagged_task_out_intr
id|ide_startstop_t
id|flagged_task_out_intr
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|ide_hwif_t
op_star
id|hwif
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
suffix:semicolon
id|u8
id|stat
op_assign
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_STATUS_REG
)paren
suffix:semicolon
r_struct
id|request
op_star
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
r_char
op_star
id|pBuf
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|OK_STAT
c_func
(paren
id|stat
comma
id|DRIVE_READY
comma
id|BAD_W_STAT
)paren
)paren
r_return
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|error
c_func
(paren
id|drive
comma
l_string|&quot;flagged_task_out_intr&quot;
comma
id|stat
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rq-&gt;current_nr_sectors
)paren
(brace
id|ide_end_drive_cmd
(paren
id|drive
comma
id|stat
comma
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_ERROR_REG
)paren
)paren
suffix:semicolon
r_return
id|ide_stopped
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|OK_STAT
c_func
(paren
id|stat
comma
id|DATA_READY
comma
id|BAD_W_STAT
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * (ks) Unexpected ATA data phase detected.&n;&t;&t; * This should not happen. But, it can !&n;&t;&t; * I am not sure, which function is best to clean up&n;&t;&t; * this situation.  I choose: ide_error(...)&n;&t;&t; */
r_return
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|error
c_func
(paren
id|drive
comma
l_string|&quot;flagged_task_out_intr (unexpected data phase)&quot;
comma
id|stat
)paren
suffix:semicolon
)brace
id|pBuf
op_assign
id|rq-&gt;buffer
op_plus
(paren
(paren
id|rq-&gt;nr_sectors
op_minus
id|rq-&gt;current_nr_sectors
)paren
op_star
id|SECTOR_SIZE
)paren
suffix:semicolon
id|DTF
c_func
(paren
l_string|&quot;Write - rq-&gt;current_nr_sectors: %d, status: %02x&bslash;n&quot;
comma
(paren
r_int
)paren
id|rq-&gt;current_nr_sectors
comma
id|stat
)paren
suffix:semicolon
id|taskfile_output_data
c_func
(paren
id|drive
comma
id|pBuf
comma
id|SECTOR_WORDS
)paren
suffix:semicolon
op_decrement
id|rq-&gt;current_nr_sectors
suffix:semicolon
multiline_comment|/*&n;&t; * (ks) We don&squot;t know which command was executed. &n;&t; * So, we wait the &squot;WORSTCASE&squot; value.&n;&t; */
id|ide_set_handler
c_func
(paren
id|drive
comma
op_amp
id|flagged_task_out_intr
comma
id|WAIT_WORSTCASE
comma
l_int|NULL
)paren
suffix:semicolon
r_return
id|ide_started
suffix:semicolon
)brace
DECL|function|flagged_pre_task_mulout_intr
id|ide_startstop_t
id|flagged_pre_task_mulout_intr
(paren
id|ide_drive_t
op_star
id|drive
comma
r_struct
id|request
op_star
id|rq
)paren
(brace
id|ide_hwif_t
op_star
id|hwif
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
suffix:semicolon
id|u8
id|stat
op_assign
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_STATUS_REG
)paren
suffix:semicolon
r_char
op_star
id|pBuf
op_assign
l_int|NULL
suffix:semicolon
id|ide_startstop_t
id|startstop
suffix:semicolon
r_int
r_int
id|msect
comma
id|nsect
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rq-&gt;current_nr_sectors
)paren
r_return
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|error
c_func
(paren
id|drive
comma
l_string|&quot;flagged_pre_task_mulout_intr (write data not specified)&quot;
comma
id|stat
)paren
suffix:semicolon
id|msect
op_assign
id|drive-&gt;mult_count
suffix:semicolon
r_if
c_cond
(paren
id|msect
op_eq
l_int|0
)paren
r_return
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|error
c_func
(paren
id|drive
comma
l_string|&quot;flagged_pre_task_mulout_intr (multimode not set)&quot;
comma
id|stat
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ide_wait_stat
c_func
(paren
op_amp
id|startstop
comma
id|drive
comma
id|DATA_READY
comma
id|BAD_W_STAT
comma
id|WAIT_DRQ
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: No DRQ bit after issuing write command.&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
r_return
id|startstop
suffix:semicolon
)brace
id|nsect
op_assign
(paren
id|rq-&gt;current_nr_sectors
OG
id|msect
)paren
ques
c_cond
id|msect
suffix:colon
id|rq-&gt;current_nr_sectors
suffix:semicolon
id|pBuf
op_assign
id|rq-&gt;buffer
op_plus
(paren
(paren
id|rq-&gt;nr_sectors
op_minus
id|rq-&gt;current_nr_sectors
)paren
op_star
id|SECTOR_SIZE
)paren
suffix:semicolon
id|DTF
c_func
(paren
l_string|&quot;Multiwrite: %p, nsect: %d , rq-&gt;current_nr_sectors: %ld&bslash;n&quot;
comma
id|pBuf
comma
id|nsect
comma
id|rq-&gt;current_nr_sectors
)paren
suffix:semicolon
id|taskfile_output_data
c_func
(paren
id|drive
comma
id|pBuf
comma
id|nsect
op_star
id|SECTOR_WORDS
)paren
suffix:semicolon
id|rq-&gt;current_nr_sectors
op_sub_assign
id|nsect
suffix:semicolon
r_return
id|ide_started
suffix:semicolon
)brace
DECL|function|flagged_task_mulout_intr
id|ide_startstop_t
id|flagged_task_mulout_intr
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|ide_hwif_t
op_star
id|hwif
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
suffix:semicolon
id|u8
id|stat
op_assign
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_STATUS_REG
)paren
suffix:semicolon
r_struct
id|request
op_star
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
r_char
op_star
id|pBuf
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|msect
comma
id|nsect
suffix:semicolon
id|msect
op_assign
id|drive-&gt;mult_count
suffix:semicolon
r_if
c_cond
(paren
id|msect
op_eq
l_int|0
)paren
r_return
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|error
c_func
(paren
id|drive
comma
l_string|&quot;flagged_task_mulout_intr (multimode not set)&quot;
comma
id|stat
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|OK_STAT
c_func
(paren
id|stat
comma
id|DRIVE_READY
comma
id|BAD_W_STAT
)paren
)paren
r_return
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|error
c_func
(paren
id|drive
comma
l_string|&quot;flagged_task_mulout_intr&quot;
comma
id|stat
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rq-&gt;current_nr_sectors
)paren
(brace
id|ide_end_drive_cmd
(paren
id|drive
comma
id|stat
comma
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_ERROR_REG
)paren
)paren
suffix:semicolon
r_return
id|ide_stopped
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|OK_STAT
c_func
(paren
id|stat
comma
id|DATA_READY
comma
id|BAD_W_STAT
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * (ks) Unexpected ATA data phase detected.&n;&t;&t; * This should not happen. But, it can !&n;&t;&t; * I am not sure, which function is best to clean up&n;&t;&t; * this situation.  I choose: ide_error(...)&n;&t;&t; */
r_return
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|error
c_func
(paren
id|drive
comma
l_string|&quot;flagged_task_mulout_intr (unexpected data phase)&quot;
comma
id|stat
)paren
suffix:semicolon
)brace
id|nsect
op_assign
(paren
id|rq-&gt;current_nr_sectors
OG
id|msect
)paren
ques
c_cond
id|msect
suffix:colon
id|rq-&gt;current_nr_sectors
suffix:semicolon
id|pBuf
op_assign
id|rq-&gt;buffer
op_plus
(paren
(paren
id|rq-&gt;nr_sectors
op_minus
id|rq-&gt;current_nr_sectors
)paren
op_star
id|SECTOR_SIZE
)paren
suffix:semicolon
id|DTF
c_func
(paren
l_string|&quot;Multiwrite: %p, nsect: %d , rq-&gt;current_nr_sectors: %ld&bslash;n&quot;
comma
id|pBuf
comma
id|nsect
comma
id|rq-&gt;current_nr_sectors
)paren
suffix:semicolon
id|taskfile_output_data
c_func
(paren
id|drive
comma
id|pBuf
comma
id|nsect
op_star
id|SECTOR_WORDS
)paren
suffix:semicolon
id|rq-&gt;current_nr_sectors
op_sub_assign
id|nsect
suffix:semicolon
multiline_comment|/*&n;&t; * (ks) We don&squot;t know which command was executed. &n;&t; * So, we wait the &squot;WORSTCASE&squot; value.&n;&t; */
id|ide_set_handler
c_func
(paren
id|drive
comma
op_amp
id|flagged_task_mulout_intr
comma
id|WAIT_WORSTCASE
comma
l_int|NULL
)paren
suffix:semicolon
r_return
id|ide_started
suffix:semicolon
)brace
eof
