multiline_comment|/*&n; * linux/drivers/ide/ide-taskfile.c&t;Version 0.20&t;Oct 11, 2000&n; *&n; *  Copyright (C) 2000&t;&t;Michael Cornwell &lt;cornwell@acm.org&gt;&n; *  Copyright (C) 2000&t;&t;Andre Hedrick &lt;andre@linux-ide.org&gt;&n; *&n; *  May be copied or modified under the terms of the GNU General Public License&n; *&n; * IDE_DEBUG(__LINE__);&n; */
macro_line|#include &lt;linux/config.h&gt;
DECL|macro|__NO_VERSION__
mdefine_line|#define __NO_VERSION__
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/major.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/genhd.h&gt;
macro_line|#include &lt;linux/blkpg.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/hdreg.h&gt;
macro_line|#include &lt;linux/ide.h&gt;
macro_line|#include &lt;asm/byteorder.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
DECL|macro|DEBUG_TASKFILE
mdefine_line|#define DEBUG_TASKFILE&t;0&t;/* unset when fixed */
macro_line|#if DEBUG_TASKFILE
DECL|macro|DTF
mdefine_line|#define DTF(x...) printk(##x)
macro_line|#else
DECL|macro|DTF
mdefine_line|#define DTF(x...)
macro_line|#endif
DECL|function|task_read_24
r_inline
id|u32
id|task_read_24
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_return
(paren
id|IN_BYTE
c_func
(paren
id|IDE_HCYL_REG
)paren
op_lshift
l_int|16
)paren
op_or
(paren
id|IN_BYTE
c_func
(paren
id|IDE_LCYL_REG
)paren
op_lshift
l_int|8
)paren
op_or
id|IN_BYTE
c_func
(paren
id|IDE_SECTOR_REG
)paren
suffix:semicolon
)brace
DECL|function|ata_bswap_data
r_static
r_void
id|ata_bswap_data
(paren
r_void
op_star
id|buffer
comma
r_int
id|wcount
)paren
(brace
id|u16
op_star
id|p
op_assign
id|buffer
suffix:semicolon
r_while
c_loop
(paren
id|wcount
op_decrement
)paren
(brace
op_star
id|p
op_assign
op_star
id|p
op_lshift
l_int|8
op_or
op_star
id|p
op_rshift
l_int|8
suffix:semicolon
id|p
op_increment
suffix:semicolon
op_star
id|p
op_assign
op_star
id|p
op_lshift
l_int|8
op_or
op_star
id|p
op_rshift
l_int|8
suffix:semicolon
id|p
op_increment
suffix:semicolon
)brace
)brace
macro_line|#if SUPPORT_VLB_SYNC
multiline_comment|/*&n; * Some localbus EIDE interfaces require a special access sequence&n; * when using 32-bit I/O instructions to transfer data.  We call this&n; * the &quot;vlb_sync&quot; sequence, which consists of three successive reads&n; * of the sector count register location, with interrupts disabled&n; * to ensure that the reads all happen together.&n; */
DECL|function|task_vlb_sync
r_static
r_inline
r_void
id|task_vlb_sync
(paren
id|ide_ioreg_t
id|port
)paren
(brace
(paren
r_void
)paren
id|IN_BYTE
(paren
id|port
)paren
suffix:semicolon
(paren
r_void
)paren
id|IN_BYTE
(paren
id|port
)paren
suffix:semicolon
(paren
r_void
)paren
id|IN_BYTE
(paren
id|port
)paren
suffix:semicolon
)brace
macro_line|#endif /* SUPPORT_VLB_SYNC */
multiline_comment|/*&n; * This is used for most PIO data transfers *from* the IDE interface&n; */
DECL|function|ata_input_data
r_void
id|ata_input_data
(paren
id|ide_drive_t
op_star
id|drive
comma
r_void
op_star
id|buffer
comma
r_int
r_int
id|wcount
)paren
(brace
id|byte
id|io_32bit
suffix:semicolon
multiline_comment|/*&n;&t; * first check if this controller has defined a special function&n;&t; * for handling polled ide transfers&n;&t; */
r_if
c_cond
(paren
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|ideproc
)paren
(brace
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|ideproc
c_func
(paren
id|ideproc_ide_input_data
comma
id|drive
comma
id|buffer
comma
id|wcount
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|io_32bit
op_assign
id|drive-&gt;io_32bit
suffix:semicolon
r_if
c_cond
(paren
id|io_32bit
)paren
(brace
macro_line|#if SUPPORT_VLB_SYNC
r_if
c_cond
(paren
id|io_32bit
op_amp
l_int|2
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|__save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* local CPU only */
id|__cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* local CPU only */
id|task_vlb_sync
c_func
(paren
id|IDE_NSECTOR_REG
)paren
suffix:semicolon
id|insl
c_func
(paren
id|IDE_DATA_REG
comma
id|buffer
comma
id|wcount
)paren
suffix:semicolon
id|__restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* local CPU only */
)brace
r_else
macro_line|#endif /* SUPPORT_VLB_SYNC */
id|insl
c_func
(paren
id|IDE_DATA_REG
comma
id|buffer
comma
id|wcount
)paren
suffix:semicolon
)brace
r_else
(brace
macro_line|#if SUPPORT_SLOW_DATA_PORTS
r_if
c_cond
(paren
id|drive-&gt;slow
)paren
(brace
r_int
r_int
op_star
id|ptr
op_assign
(paren
r_int
r_int
op_star
)paren
id|buffer
suffix:semicolon
r_while
c_loop
(paren
id|wcount
op_decrement
)paren
(brace
op_star
id|ptr
op_increment
op_assign
id|inw_p
c_func
(paren
id|IDE_DATA_REG
)paren
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
id|inw_p
c_func
(paren
id|IDE_DATA_REG
)paren
suffix:semicolon
)brace
)brace
r_else
macro_line|#endif /* SUPPORT_SLOW_DATA_PORTS */
id|insw
c_func
(paren
id|IDE_DATA_REG
comma
id|buffer
comma
id|wcount
op_lshift
l_int|1
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * This is used for most PIO data transfers *to* the IDE interface&n; */
DECL|function|ata_output_data
r_void
id|ata_output_data
(paren
id|ide_drive_t
op_star
id|drive
comma
r_void
op_star
id|buffer
comma
r_int
r_int
id|wcount
)paren
(brace
id|byte
id|io_32bit
suffix:semicolon
r_if
c_cond
(paren
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|ideproc
)paren
(brace
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|ideproc
c_func
(paren
id|ideproc_ide_output_data
comma
id|drive
comma
id|buffer
comma
id|wcount
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|io_32bit
op_assign
id|drive-&gt;io_32bit
suffix:semicolon
r_if
c_cond
(paren
id|io_32bit
)paren
(brace
macro_line|#if SUPPORT_VLB_SYNC
r_if
c_cond
(paren
id|io_32bit
op_amp
l_int|2
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|__save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* local CPU only */
id|__cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* local CPU only */
id|task_vlb_sync
c_func
(paren
id|IDE_NSECTOR_REG
)paren
suffix:semicolon
id|outsl
c_func
(paren
id|IDE_DATA_REG
comma
id|buffer
comma
id|wcount
)paren
suffix:semicolon
id|__restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* local CPU only */
)brace
r_else
macro_line|#endif /* SUPPORT_VLB_SYNC */
id|outsl
c_func
(paren
id|IDE_DATA_REG
comma
id|buffer
comma
id|wcount
)paren
suffix:semicolon
)brace
r_else
(brace
macro_line|#if SUPPORT_SLOW_DATA_PORTS
r_if
c_cond
(paren
id|drive-&gt;slow
)paren
(brace
r_int
r_int
op_star
id|ptr
op_assign
(paren
r_int
r_int
op_star
)paren
id|buffer
suffix:semicolon
r_while
c_loop
(paren
id|wcount
op_decrement
)paren
(brace
id|outw_p
c_func
(paren
op_star
id|ptr
op_increment
comma
id|IDE_DATA_REG
)paren
suffix:semicolon
id|outw_p
c_func
(paren
op_star
id|ptr
op_increment
comma
id|IDE_DATA_REG
)paren
suffix:semicolon
)brace
)brace
r_else
macro_line|#endif /* SUPPORT_SLOW_DATA_PORTS */
id|outsw
c_func
(paren
id|IDE_DATA_REG
comma
id|buffer
comma
id|wcount
op_lshift
l_int|1
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * The following routines are mainly used by the ATAPI drivers.&n; *&n; * These routines will round up any request for an odd number of bytes,&n; * so if an odd bytecount is specified, be sure that there&squot;s at least one&n; * extra byte allocated for the buffer.&n; */
DECL|function|atapi_input_bytes
r_void
id|atapi_input_bytes
(paren
id|ide_drive_t
op_star
id|drive
comma
r_void
op_star
id|buffer
comma
r_int
r_int
id|bytecount
)paren
(brace
r_if
c_cond
(paren
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|ideproc
)paren
(brace
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|ideproc
c_func
(paren
id|ideproc_atapi_input_bytes
comma
id|drive
comma
id|buffer
comma
id|bytecount
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
op_increment
id|bytecount
suffix:semicolon
macro_line|#if defined(CONFIG_ATARI) || defined(CONFIG_Q40)
r_if
c_cond
(paren
id|MACH_IS_ATARI
op_logical_or
id|MACH_IS_Q40
)paren
(brace
multiline_comment|/* Atari has a byte-swapped IDE interface */
id|insw_swapw
c_func
(paren
id|IDE_DATA_REG
comma
id|buffer
comma
id|bytecount
op_div
l_int|2
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_ATARI */
id|ata_input_data
(paren
id|drive
comma
id|buffer
comma
id|bytecount
op_div
l_int|4
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bytecount
op_amp
l_int|0x03
)paren
op_ge
l_int|2
)paren
id|insw
(paren
id|IDE_DATA_REG
comma
(paren
(paren
id|byte
op_star
)paren
id|buffer
)paren
op_plus
(paren
id|bytecount
op_amp
op_complement
l_int|0x03
)paren
comma
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|atapi_output_bytes
r_void
id|atapi_output_bytes
(paren
id|ide_drive_t
op_star
id|drive
comma
r_void
op_star
id|buffer
comma
r_int
r_int
id|bytecount
)paren
(brace
r_if
c_cond
(paren
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|ideproc
)paren
(brace
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|ideproc
c_func
(paren
id|ideproc_atapi_output_bytes
comma
id|drive
comma
id|buffer
comma
id|bytecount
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
op_increment
id|bytecount
suffix:semicolon
macro_line|#if defined(CONFIG_ATARI) || defined(CONFIG_Q40)
r_if
c_cond
(paren
id|MACH_IS_ATARI
op_logical_or
id|MACH_IS_Q40
)paren
(brace
multiline_comment|/* Atari has a byte-swapped IDE interface */
id|outsw_swapw
c_func
(paren
id|IDE_DATA_REG
comma
id|buffer
comma
id|bytecount
op_div
l_int|2
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_ATARI */
id|ata_output_data
(paren
id|drive
comma
id|buffer
comma
id|bytecount
op_div
l_int|4
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bytecount
op_amp
l_int|0x03
)paren
op_ge
l_int|2
)paren
id|outsw
(paren
id|IDE_DATA_REG
comma
(paren
(paren
id|byte
op_star
)paren
id|buffer
)paren
op_plus
(paren
id|bytecount
op_amp
op_complement
l_int|0x03
)paren
comma
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|taskfile_input_data
r_void
id|taskfile_input_data
(paren
id|ide_drive_t
op_star
id|drive
comma
r_void
op_star
id|buffer
comma
r_int
r_int
id|wcount
)paren
(brace
id|ata_input_data
c_func
(paren
id|drive
comma
id|buffer
comma
id|wcount
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;bswap
)paren
id|ata_bswap_data
c_func
(paren
id|buffer
comma
id|wcount
)paren
suffix:semicolon
)brace
DECL|function|taskfile_output_data
r_void
id|taskfile_output_data
(paren
id|ide_drive_t
op_star
id|drive
comma
r_void
op_star
id|buffer
comma
r_int
r_int
id|wcount
)paren
(brace
r_if
c_cond
(paren
id|drive-&gt;bswap
)paren
(brace
id|ata_bswap_data
c_func
(paren
id|buffer
comma
id|wcount
)paren
suffix:semicolon
id|ata_output_data
c_func
(paren
id|drive
comma
id|buffer
comma
id|wcount
)paren
suffix:semicolon
id|ata_bswap_data
c_func
(paren
id|buffer
comma
id|wcount
)paren
suffix:semicolon
)brace
r_else
(brace
id|ata_output_data
c_func
(paren
id|drive
comma
id|buffer
comma
id|wcount
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Needed for PCI irq sharing&n; */
DECL|function|drive_is_ready
r_int
id|drive_is_ready
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|byte
id|stat
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;waiting_for_dma
)paren
r_return
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|dmaproc
c_func
(paren
id|ide_dma_test_irq
comma
id|drive
)paren
suffix:semicolon
macro_line|#if 0
multiline_comment|/* need to guarantee 400ns since last command was issued */
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_IDEPCI_SHARE_IRQ
multiline_comment|/*&n;&t; * We do a passive status test under shared PCI interrupts on&n;&t; * cards that truly share the ATA side interrupt, but may also share&n;&t; * an interrupt with another pci card/device.  We make no assumptions&n;&t; * about possible isa-pnp and pci-pnp issues yet.&n;&t; */
r_if
c_cond
(paren
id|IDE_CONTROL_REG
)paren
id|stat
op_assign
id|GET_ALTSTAT
c_func
(paren
)paren
suffix:semicolon
r_else
macro_line|#endif /* CONFIG_IDEPCI_SHARE_IRQ */
id|stat
op_assign
id|GET_STAT
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Note: this may clear a pending IRQ!! */
r_if
c_cond
(paren
id|stat
op_amp
id|BUSY_STAT
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* drive busy:  definitely not interrupting */
r_return
l_int|1
suffix:semicolon
multiline_comment|/* drive ready: *might* be interrupting */
)brace
DECL|function|do_rw_taskfile
id|ide_startstop_t
id|do_rw_taskfile
(paren
id|ide_drive_t
op_star
id|drive
comma
id|ide_task_t
op_star
id|task
)paren
(brace
id|task_struct_t
op_star
id|taskfile
op_assign
(paren
id|task_struct_t
op_star
)paren
id|task-&gt;tfRegister
suffix:semicolon
id|hob_struct_t
op_star
id|hobfile
op_assign
(paren
id|hob_struct_t
op_star
)paren
id|task-&gt;hobRegister
suffix:semicolon
r_struct
id|hd_driveid
op_star
id|id
op_assign
id|drive-&gt;id
suffix:semicolon
id|byte
id|HIHI
op_assign
(paren
id|drive-&gt;addressing
)paren
ques
c_cond
l_int|0xE0
suffix:colon
l_int|0xEF
suffix:semicolon
multiline_comment|/* (ks/hs): Moved to start, do not use for multiple out commands */
r_if
c_cond
(paren
id|task-&gt;handler
op_ne
id|task_mulout_intr
)paren
(brace
r_if
c_cond
(paren
id|IDE_CONTROL_REG
)paren
id|OUT_BYTE
c_func
(paren
id|drive-&gt;ctl
comma
id|IDE_CONTROL_REG
)paren
suffix:semicolon
multiline_comment|/* clear nIEN */
id|SELECT_MASK
c_func
(paren
id|HWIF
c_func
(paren
id|drive
)paren
comma
id|drive
comma
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|id-&gt;command_set_2
op_amp
l_int|0x0400
)paren
op_logical_and
(paren
id|id-&gt;cfs_enable_2
op_amp
l_int|0x0400
)paren
op_logical_and
(paren
id|drive-&gt;addressing
op_eq
l_int|1
)paren
)paren
(brace
id|OUT_BYTE
c_func
(paren
id|hobfile-&gt;feature
comma
id|IDE_FEATURE_REG
)paren
suffix:semicolon
id|OUT_BYTE
c_func
(paren
id|hobfile-&gt;sector_count
comma
id|IDE_NSECTOR_REG
)paren
suffix:semicolon
id|OUT_BYTE
c_func
(paren
id|hobfile-&gt;sector_number
comma
id|IDE_SECTOR_REG
)paren
suffix:semicolon
id|OUT_BYTE
c_func
(paren
id|hobfile-&gt;low_cylinder
comma
id|IDE_LCYL_REG
)paren
suffix:semicolon
id|OUT_BYTE
c_func
(paren
id|hobfile-&gt;high_cylinder
comma
id|IDE_HCYL_REG
)paren
suffix:semicolon
)brace
id|OUT_BYTE
c_func
(paren
id|taskfile-&gt;feature
comma
id|IDE_FEATURE_REG
)paren
suffix:semicolon
id|OUT_BYTE
c_func
(paren
id|taskfile-&gt;sector_count
comma
id|IDE_NSECTOR_REG
)paren
suffix:semicolon
multiline_comment|/* refers to number of sectors to transfer */
id|OUT_BYTE
c_func
(paren
id|taskfile-&gt;sector_number
comma
id|IDE_SECTOR_REG
)paren
suffix:semicolon
multiline_comment|/* refers to sector offset or start sector */
id|OUT_BYTE
c_func
(paren
id|taskfile-&gt;low_cylinder
comma
id|IDE_LCYL_REG
)paren
suffix:semicolon
id|OUT_BYTE
c_func
(paren
id|taskfile-&gt;high_cylinder
comma
id|IDE_HCYL_REG
)paren
suffix:semicolon
id|OUT_BYTE
c_func
(paren
(paren
id|taskfile-&gt;device_head
op_amp
id|HIHI
)paren
op_or
id|drive-&gt;select.all
comma
id|IDE_SELECT_REG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|task-&gt;handler
op_ne
l_int|NULL
)paren
(brace
id|ide_set_handler
(paren
id|drive
comma
id|task-&gt;handler
comma
id|WAIT_CMD
comma
l_int|NULL
)paren
suffix:semicolon
id|OUT_BYTE
c_func
(paren
id|taskfile-&gt;command
comma
id|IDE_COMMAND_REG
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * warning check for race between handler and prehandler for&n;&t;&t; * writing first block of data.  however since we are well&n;&t;&t; * inside the boundaries of the seek, we should be okay.&n;&t;&t; */
r_if
c_cond
(paren
id|task-&gt;prehandler
op_ne
l_int|NULL
)paren
(brace
r_return
id|task
op_member_access_from_pointer
id|prehandler
c_func
(paren
id|drive
comma
id|task-&gt;rq
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* for dma commands we down set the handler */
r_if
c_cond
(paren
id|drive-&gt;using_dma
op_logical_and
op_logical_neg
(paren
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|dmaproc
c_func
(paren
(paren
(paren
id|taskfile-&gt;command
op_eq
id|WIN_WRITEDMA
)paren
op_logical_or
(paren
id|taskfile-&gt;command
op_eq
id|WIN_WRITEDMA_EXT
)paren
)paren
ques
c_cond
id|ide_dma_write
suffix:colon
id|ide_dma_read
comma
id|drive
)paren
)paren
)paren
suffix:semicolon
)brace
r_return
id|ide_started
suffix:semicolon
)brace
DECL|function|do_taskfile
r_void
id|do_taskfile
(paren
id|ide_drive_t
op_star
id|drive
comma
r_struct
id|hd_drive_task_hdr
op_star
id|taskfile
comma
r_struct
id|hd_drive_hob_hdr
op_star
id|hobfile
comma
id|ide_handler_t
op_star
id|handler
)paren
(brace
r_struct
id|hd_driveid
op_star
id|id
op_assign
id|drive-&gt;id
suffix:semicolon
id|byte
id|HIHI
op_assign
(paren
id|drive-&gt;addressing
)paren
ques
c_cond
l_int|0xE0
suffix:colon
l_int|0xEF
suffix:semicolon
multiline_comment|/* (ks/hs): Moved to start, do not use for multiple out commands */
r_if
c_cond
(paren
op_star
id|handler
op_ne
id|task_mulout_intr
)paren
(brace
r_if
c_cond
(paren
id|IDE_CONTROL_REG
)paren
id|OUT_BYTE
c_func
(paren
id|drive-&gt;ctl
comma
id|IDE_CONTROL_REG
)paren
suffix:semicolon
multiline_comment|/* clear nIEN */
id|SELECT_MASK
c_func
(paren
id|HWIF
c_func
(paren
id|drive
)paren
comma
id|drive
comma
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|id-&gt;command_set_2
op_amp
l_int|0x0400
)paren
op_logical_and
(paren
id|id-&gt;cfs_enable_2
op_amp
l_int|0x0400
)paren
op_logical_and
(paren
id|drive-&gt;addressing
op_eq
l_int|1
)paren
)paren
(brace
id|OUT_BYTE
c_func
(paren
id|hobfile-&gt;feature
comma
id|IDE_FEATURE_REG
)paren
suffix:semicolon
id|OUT_BYTE
c_func
(paren
id|hobfile-&gt;sector_count
comma
id|IDE_NSECTOR_REG
)paren
suffix:semicolon
id|OUT_BYTE
c_func
(paren
id|hobfile-&gt;sector_number
comma
id|IDE_SECTOR_REG
)paren
suffix:semicolon
id|OUT_BYTE
c_func
(paren
id|hobfile-&gt;low_cylinder
comma
id|IDE_LCYL_REG
)paren
suffix:semicolon
id|OUT_BYTE
c_func
(paren
id|hobfile-&gt;high_cylinder
comma
id|IDE_HCYL_REG
)paren
suffix:semicolon
)brace
id|OUT_BYTE
c_func
(paren
id|taskfile-&gt;feature
comma
id|IDE_FEATURE_REG
)paren
suffix:semicolon
id|OUT_BYTE
c_func
(paren
id|taskfile-&gt;sector_count
comma
id|IDE_NSECTOR_REG
)paren
suffix:semicolon
multiline_comment|/* refers to number of sectors to transfer */
id|OUT_BYTE
c_func
(paren
id|taskfile-&gt;sector_number
comma
id|IDE_SECTOR_REG
)paren
suffix:semicolon
multiline_comment|/* refers to sector offset or start sector */
id|OUT_BYTE
c_func
(paren
id|taskfile-&gt;low_cylinder
comma
id|IDE_LCYL_REG
)paren
suffix:semicolon
id|OUT_BYTE
c_func
(paren
id|taskfile-&gt;high_cylinder
comma
id|IDE_HCYL_REG
)paren
suffix:semicolon
id|OUT_BYTE
c_func
(paren
(paren
id|taskfile-&gt;device_head
op_amp
id|HIHI
)paren
op_or
id|drive-&gt;select.all
comma
id|IDE_SELECT_REG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|handler
op_ne
l_int|NULL
)paren
(brace
id|ide_set_handler
(paren
id|drive
comma
id|handler
comma
id|WAIT_CMD
comma
l_int|NULL
)paren
suffix:semicolon
id|OUT_BYTE
c_func
(paren
id|taskfile-&gt;command
comma
id|IDE_COMMAND_REG
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* for dma commands we down set the handler */
r_if
c_cond
(paren
id|drive-&gt;using_dma
op_logical_and
op_logical_neg
(paren
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|dmaproc
c_func
(paren
(paren
(paren
id|taskfile-&gt;command
op_eq
id|WIN_WRITEDMA
)paren
op_logical_or
(paren
id|taskfile-&gt;command
op_eq
id|WIN_WRITEDMA_EXT
)paren
)paren
ques
c_cond
id|ide_dma_write
suffix:colon
id|ide_dma_read
comma
id|drive
)paren
)paren
)paren
suffix:semicolon
)brace
)brace
macro_line|#if 0
id|ide_startstop_t
id|flagged_taskfile
(paren
id|ide_drive_t
op_star
id|drive
comma
id|ide_task_t
op_star
id|task
)paren
(brace
id|task_struct_t
op_star
id|taskfile
op_assign
(paren
id|task_struct_t
op_star
)paren
id|task-&gt;tfRegister
suffix:semicolon
id|hob_struct_t
op_star
id|hobfile
op_assign
(paren
id|hob_struct_t
op_star
)paren
id|task-&gt;hobRegister
suffix:semicolon
r_struct
id|hd_driveid
op_star
id|id
op_assign
id|drive-&gt;id
suffix:semicolon
multiline_comment|/*&n;&t; * (KS) Check taskfile in/out flags.&n;&t; * If set, then execute as it is defined.&n;&t; * If not set, then define default settings.&n;&t; * The default values are:&n;&t; *&t;write and read all taskfile registers (except data) &n;&t; *&t;write and read the hob registers (sector,nsector,lcyl,hcyl)&n;&t; */
r_if
c_cond
(paren
id|task-&gt;tf_out_flags.all
op_eq
l_int|0
)paren
(brace
id|task-&gt;tf_out_flags.all
op_assign
id|IDE_TASKFILE_STD_OUT_FLAGS
suffix:semicolon
r_if
c_cond
(paren
(paren
id|id-&gt;command_set_2
op_amp
l_int|0x0400
)paren
op_logical_and
(paren
id|id-&gt;cfs_enable_2
op_amp
l_int|0x0400
)paren
op_logical_and
(paren
id|drive-&gt;addressing
op_eq
l_int|1
)paren
)paren
(brace
id|task-&gt;tf_out_flags.all
op_ne
(paren
id|IDE_HOB_STD_OUT_FLAGS
op_lshift
l_int|8
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|task-&gt;tf_in_flags.all
op_eq
l_int|0
)paren
(brace
id|task-&gt;tf_in_flags.all
op_assign
id|IDE_TASKFILE_STD_IN_FLAGS
suffix:semicolon
r_if
c_cond
(paren
(paren
id|id-&gt;command_set_2
op_amp
l_int|0x0400
)paren
op_logical_and
(paren
id|id-&gt;cfs_enable_2
op_amp
l_int|0x0400
)paren
op_logical_and
(paren
id|drive-&gt;addressing
op_eq
l_int|1
)paren
)paren
(brace
id|task-&gt;tf_in_flags.all
op_ne
(paren
id|IDE_HOB_STD_IN_FLAGS
op_lshift
l_int|8
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|IDE_CONTROL_REG
)paren
id|OUT_BYTE
c_func
(paren
id|drive-&gt;ctl
comma
id|IDE_CONTROL_REG
)paren
suffix:semicolon
multiline_comment|/* clear nIEN */
id|SELECT_MASK
c_func
(paren
id|HWIF
c_func
(paren
id|drive
)paren
comma
id|drive
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|task-&gt;tf_out_flags.b.data
)paren
(brace
r_int
r_int
id|data
op_assign
id|taskfile-&gt;data
op_plus
(paren
id|hobfile-&gt;data
op_lshift
l_int|8
)paren
suffix:semicolon
id|OUT_WORD
(paren
id|data
comma
id|IDE_DATA_REG
)paren
suffix:semicolon
)brace
multiline_comment|/* (KS) send hob registers first */
r_if
c_cond
(paren
id|task-&gt;tf_out_flags.b.nsector_hob
)paren
id|OUT_BYTE
c_func
(paren
id|hobfile-&gt;sector_count
comma
id|IDE_NSECTOR_REG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|task-&gt;tf_out_flags.b.sector_hob
)paren
id|OUT_BYTE
c_func
(paren
id|hobfile-&gt;sector_number
comma
id|IDE_SECTOR_REG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|task-&gt;tf_out_flags.b.lcyl_hob
)paren
id|OUT_BYTE
c_func
(paren
id|hobfile-&gt;low_cylinder
comma
id|IDE_LCYL_REG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|task-&gt;tf_out_flags.b.hcyl_hob
)paren
id|OUT_BYTE
c_func
(paren
id|hobfile-&gt;high_cylinder
comma
id|IDE_HCYL_REG
)paren
suffix:semicolon
multiline_comment|/* (KS) Send now the standard registers */
r_if
c_cond
(paren
id|task-&gt;tf_out_flags.b.error_feature
)paren
id|OUT_BYTE
c_func
(paren
id|taskfile-&gt;feature
comma
id|IDE_FEATURE_REG
)paren
suffix:semicolon
multiline_comment|/* refers to number of sectors to transfer */
r_if
c_cond
(paren
id|task-&gt;tf_out_flags.b.nsector
)paren
id|OUT_BYTE
c_func
(paren
id|taskfile-&gt;sector_count
comma
id|IDE_NSECTOR_REG
)paren
suffix:semicolon
multiline_comment|/* refers to sector offset or start sector */
r_if
c_cond
(paren
id|task-&gt;tf_out_flags.b.sector
)paren
id|OUT_BYTE
c_func
(paren
id|taskfile-&gt;sector_number
comma
id|IDE_SECTOR_REG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|task-&gt;tf_out_flags.b.lcyl
)paren
id|OUT_BYTE
c_func
(paren
id|taskfile-&gt;low_cylinder
comma
id|IDE_LCYL_REG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|task-&gt;tf_out_flags.b.hcyl
)paren
id|OUT_BYTE
c_func
(paren
id|taskfile-&gt;high_cylinder
comma
id|IDE_HCYL_REG
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * (KS) Do not modify the specified taskfile. We want to have a&n;&t; * universal pass through, so we must execute ALL specified values.&n;&t; *&n;&t; * (KS) The drive head register is mandatory.&n;&t; * Don&squot;t care about the out flags !&n;&t; */
id|OUT_BYTE
c_func
(paren
id|taskfile-&gt;device_head
op_or
id|drive-&gt;select.all
comma
id|IDE_SELECT_REG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|task-&gt;handler
op_ne
l_int|NULL
)paren
(brace
id|ide_set_handler
(paren
id|drive
comma
id|task-&gt;handler
comma
id|WAIT_CMD
comma
l_int|NULL
)paren
suffix:semicolon
id|OUT_BYTE
c_func
(paren
id|taskfile-&gt;command
comma
id|IDE_COMMAND_REG
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * warning check for race between handler and prehandler for&n;&t;&t; * writing first block of data.  however since we are well&n;&t;&t; * inside the boundaries of the seek, we should be okay.&n;&t;&t; */
r_if
c_cond
(paren
id|task-&gt;prehandler
op_ne
l_int|NULL
)paren
(brace
r_return
id|task
op_member_access_from_pointer
id|prehandler
c_func
(paren
id|drive
comma
id|task-&gt;rq
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* for dma commands we down set the handler */
r_if
c_cond
(paren
id|drive-&gt;using_dma
op_logical_and
op_logical_neg
(paren
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|dmaproc
c_func
(paren
(paren
(paren
id|taskfile-&gt;command
op_eq
id|WIN_WRITEDMA
)paren
op_logical_or
(paren
id|taskfile-&gt;command
op_eq
id|WIN_WRITEDMA_EXT
)paren
)paren
ques
c_cond
id|ide_dma_write
suffix:colon
id|ide_dma_read
comma
id|drive
)paren
)paren
)paren
suffix:semicolon
)brace
r_return
id|ide_started
suffix:semicolon
)brace
macro_line|#endif
macro_line|#if 0
multiline_comment|/*&n; * Error reporting, in human readable form (luxurious, but a memory hog).&n; */
id|byte
id|taskfile_dump_status
(paren
id|ide_drive_t
op_star
id|drive
comma
r_const
r_char
op_star
id|msg
comma
id|byte
id|stat
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|byte
id|err
op_assign
l_int|0
suffix:semicolon
id|__save_flags
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* local CPU only */
id|ide__sti
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* local CPU only */
id|printk
c_func
(paren
l_string|&quot;%s: %s: status=0x%02x&quot;
comma
id|drive-&gt;name
comma
id|msg
comma
id|stat
)paren
suffix:semicolon
macro_line|#if FANCY_STATUS_DUMPS
id|printk
c_func
(paren
l_string|&quot; { &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_amp
id|BUSY_STAT
)paren
id|printk
c_func
(paren
l_string|&quot;Busy &quot;
)paren
suffix:semicolon
r_else
(brace
r_if
c_cond
(paren
id|stat
op_amp
id|READY_STAT
)paren
id|printk
c_func
(paren
l_string|&quot;DriveReady &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_amp
id|WRERR_STAT
)paren
id|printk
c_func
(paren
l_string|&quot;DeviceFault &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_amp
id|SEEK_STAT
)paren
id|printk
c_func
(paren
l_string|&quot;SeekComplete &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_amp
id|DRQ_STAT
)paren
id|printk
c_func
(paren
l_string|&quot;DataRequest &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_amp
id|ECC_STAT
)paren
id|printk
c_func
(paren
l_string|&quot;CorrectedError &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_amp
id|INDEX_STAT
)paren
id|printk
c_func
(paren
l_string|&quot;Index &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_amp
id|ERR_STAT
)paren
id|printk
c_func
(paren
l_string|&quot;Error &quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;}&quot;
)paren
suffix:semicolon
macro_line|#endif  /* FANCY_STATUS_DUMPS */
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|stat
op_amp
(paren
id|BUSY_STAT
op_or
id|ERR_STAT
)paren
)paren
op_eq
id|ERR_STAT
)paren
(brace
id|err
op_assign
id|GET_ERR
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: %s: error=0x%02x&quot;
comma
id|drive-&gt;name
comma
id|msg
comma
id|err
)paren
suffix:semicolon
macro_line|#if FANCY_STATUS_DUMPS
r_if
c_cond
(paren
id|drive-&gt;media
op_eq
id|ide_disk
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; { &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_amp
id|ABRT_ERR
)paren
id|printk
c_func
(paren
l_string|&quot;DriveStatusError &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_amp
id|ICRC_ERR
)paren
id|printk
c_func
(paren
l_string|&quot;%s&quot;
comma
(paren
id|err
op_amp
id|ABRT_ERR
)paren
ques
c_cond
l_string|&quot;BadCRC &quot;
suffix:colon
l_string|&quot;BadSector &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_amp
id|ECC_ERR
)paren
id|printk
c_func
(paren
l_string|&quot;UncorrectableError &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_amp
id|ID_ERR
)paren
id|printk
c_func
(paren
l_string|&quot;SectorIdNotFound &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_amp
id|TRK0_ERR
)paren
id|printk
c_func
(paren
l_string|&quot;TrackZeroNotFound &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_amp
id|MARK_ERR
)paren
id|printk
c_func
(paren
l_string|&quot;AddrMarkNotFound &quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;}&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_amp
(paren
id|BBD_ERR
op_or
id|ABRT_ERR
)paren
)paren
op_eq
id|BBD_ERR
op_logical_or
(paren
id|err
op_amp
(paren
id|ECC_ERR
op_or
id|ID_ERR
op_or
id|MARK_ERR
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|drive-&gt;id-&gt;command_set_2
op_amp
l_int|0x0400
)paren
op_logical_and
(paren
id|drive-&gt;id-&gt;cfs_enable_2
op_amp
l_int|0x0400
)paren
op_logical_and
(paren
id|drive-&gt;addressing
op_eq
l_int|1
)paren
)paren
(brace
id|__u64
id|sectors
op_assign
l_int|0
suffix:semicolon
id|u32
id|low
op_assign
l_int|0
comma
id|high
op_assign
l_int|0
suffix:semicolon
id|low
op_assign
id|task_read_24
c_func
(paren
id|drive
)paren
suffix:semicolon
id|OUT_BYTE
c_func
(paren
l_int|0x80
comma
id|IDE_CONTROL_REG
)paren
suffix:semicolon
id|high
op_assign
id|task_read_24
c_func
(paren
id|drive
)paren
suffix:semicolon
id|sectors
op_assign
(paren
(paren
id|__u64
)paren
id|high
op_lshift
l_int|24
)paren
op_or
id|low
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;, LBAsect=%lld&quot;
comma
id|sectors
)paren
suffix:semicolon
)brace
r_else
(brace
id|byte
id|cur
op_assign
id|IN_BYTE
c_func
(paren
id|IDE_SELECT_REG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cur
op_amp
l_int|0x40
)paren
(brace
multiline_comment|/* using LBA? */
id|printk
c_func
(paren
l_string|&quot;, LBAsect=%ld&quot;
comma
(paren
r_int
r_int
)paren
(paren
(paren
id|cur
op_amp
l_int|0xf
)paren
op_lshift
l_int|24
)paren
op_or
(paren
id|IN_BYTE
c_func
(paren
id|IDE_HCYL_REG
)paren
op_lshift
l_int|16
)paren
op_or
(paren
id|IN_BYTE
c_func
(paren
id|IDE_LCYL_REG
)paren
op_lshift
l_int|8
)paren
op_or
id|IN_BYTE
c_func
(paren
id|IDE_SECTOR_REG
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;, CHS=%d/%d/%d&quot;
comma
(paren
id|IN_BYTE
c_func
(paren
id|IDE_HCYL_REG
)paren
op_lshift
l_int|8
)paren
op_plus
id|IN_BYTE
c_func
(paren
id|IDE_LCYL_REG
)paren
comma
id|cur
op_amp
l_int|0xf
comma
id|IN_BYTE
c_func
(paren
id|IDE_SECTOR_REG
)paren
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
)paren
id|printk
c_func
(paren
l_string|&quot;, sector=%llu&quot;
comma
(paren
id|__u64
)paren
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq-&gt;sector
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif  /* FANCY_STATUS_DUMPS */
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|__restore_flags
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* local CPU only */
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; * Clean up after success/failure of an explicit taskfile operation.&n; */
r_void
id|ide_end_taskfile
(paren
id|ide_drive_t
op_star
id|drive
comma
id|byte
id|stat
comma
id|byte
id|err
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|request
op_star
id|rq
suffix:semicolon
id|ide_task_t
op_star
id|args
suffix:semicolon
id|task_ioreg_t
id|command
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ide_lock
comma
id|flags
)paren
suffix:semicolon
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ide_lock
comma
id|flags
)paren
suffix:semicolon
id|args
op_assign
(paren
id|ide_task_t
op_star
)paren
id|rq-&gt;special
suffix:semicolon
id|command
op_assign
id|args-&gt;tfRegister
(braket
id|IDE_COMMAND_OFFSET
)braket
suffix:semicolon
id|rq-&gt;errors
op_assign
op_logical_neg
id|OK_STAT
c_func
(paren
id|stat
comma
id|READY_STAT
comma
id|BAD_STAT
)paren
suffix:semicolon
id|args-&gt;tfRegister
(braket
id|IDE_ERROR_OFFSET
)braket
op_assign
id|err
suffix:semicolon
id|args-&gt;tfRegister
(braket
id|IDE_NSECTOR_OFFSET
)braket
op_assign
id|IN_BYTE
c_func
(paren
id|IDE_NSECTOR_REG
)paren
suffix:semicolon
id|args-&gt;tfRegister
(braket
id|IDE_SECTOR_OFFSET
)braket
op_assign
id|IN_BYTE
c_func
(paren
id|IDE_SECTOR_REG
)paren
suffix:semicolon
id|args-&gt;tfRegister
(braket
id|IDE_LCYL_OFFSET
)braket
op_assign
id|IN_BYTE
c_func
(paren
id|IDE_LCYL_REG
)paren
suffix:semicolon
id|args-&gt;tfRegister
(braket
id|IDE_HCYL_OFFSET
)braket
op_assign
id|IN_BYTE
c_func
(paren
id|IDE_HCYL_REG
)paren
suffix:semicolon
id|args-&gt;tfRegister
(braket
id|IDE_SELECT_OFFSET
)braket
op_assign
id|IN_BYTE
c_func
(paren
id|IDE_SELECT_REG
)paren
suffix:semicolon
id|args-&gt;tfRegister
(braket
id|IDE_STATUS_OFFSET
)braket
op_assign
id|stat
suffix:semicolon
r_if
c_cond
(paren
(paren
id|drive-&gt;id-&gt;command_set_2
op_amp
l_int|0x0400
)paren
op_logical_and
(paren
id|drive-&gt;id-&gt;cfs_enable_2
op_amp
l_int|0x0400
)paren
op_logical_and
(paren
id|drive-&gt;addressing
op_eq
l_int|1
)paren
)paren
(brace
id|OUT_BYTE
c_func
(paren
id|drive-&gt;ctl
op_or
l_int|0x80
comma
id|IDE_CONTROL_REG_HOB
)paren
suffix:semicolon
id|args-&gt;hobRegister
(braket
id|IDE_FEATURE_OFFSET_HOB
)braket
op_assign
id|IN_BYTE
c_func
(paren
id|IDE_FEATURE_REG
)paren
suffix:semicolon
id|args-&gt;hobRegister
(braket
id|IDE_NSECTOR_OFFSET_HOB
)braket
op_assign
id|IN_BYTE
c_func
(paren
id|IDE_NSECTOR_REG
)paren
suffix:semicolon
id|args-&gt;hobRegister
(braket
id|IDE_SECTOR_OFFSET_HOB
)braket
op_assign
id|IN_BYTE
c_func
(paren
id|IDE_SECTOR_REG
)paren
suffix:semicolon
id|args-&gt;hobRegister
(braket
id|IDE_LCYL_OFFSET_HOB
)braket
op_assign
id|IN_BYTE
c_func
(paren
id|IDE_LCYL_REG
)paren
suffix:semicolon
id|args-&gt;hobRegister
(braket
id|IDE_HCYL_OFFSET_HOB
)braket
op_assign
id|IN_BYTE
c_func
(paren
id|IDE_HCYL_REG
)paren
suffix:semicolon
)brace
multiline_comment|/*&t;taskfile_settings_update(drive, args, command); */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ide_lock
comma
id|flags
)paren
suffix:semicolon
id|blkdev_dequeue_request
c_func
(paren
id|rq
)paren
suffix:semicolon
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
op_assign
l_int|NULL
suffix:semicolon
id|end_that_request_last
c_func
(paren
id|rq
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ide_lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * try_to_flush_leftover_data() is invoked in response to a drive&n; * unexpectedly having its DRQ_STAT bit set.  As an alternative to&n; * resetting the drive, this routine tries to clear the condition&n; * by read a sector&squot;s worth of data from the drive.  Of course,&n; * this may not help if the drive is *waiting* for data from *us*.&n; */
r_void
id|task_try_to_flush_leftover_data
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_int
id|i
op_assign
(paren
id|drive-&gt;mult_count
ques
c_cond
id|drive-&gt;mult_count
suffix:colon
l_int|1
)paren
op_star
id|SECTOR_WORDS
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;media
op_ne
id|ide_disk
)paren
r_return
suffix:semicolon
r_while
c_loop
(paren
id|i
OG
l_int|0
)paren
(brace
id|u32
id|buffer
(braket
l_int|16
)braket
suffix:semicolon
r_int
r_int
id|wcount
op_assign
(paren
id|i
OG
l_int|16
)paren
ques
c_cond
l_int|16
suffix:colon
id|i
suffix:semicolon
id|i
op_sub_assign
id|wcount
suffix:semicolon
id|taskfile_input_data
(paren
id|drive
comma
id|buffer
comma
id|wcount
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * taskfile_error() takes action based on the error returned by the drive.&n; */
id|ide_startstop_t
id|taskfile_error
(paren
id|ide_drive_t
op_star
id|drive
comma
r_const
r_char
op_star
id|msg
comma
id|byte
id|stat
)paren
(brace
r_struct
id|request
op_star
id|rq
suffix:semicolon
id|byte
id|err
suffix:semicolon
id|err
op_assign
id|taskfile_dump_status
c_func
(paren
id|drive
comma
id|msg
comma
id|stat
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drive
op_eq
l_int|NULL
op_logical_or
(paren
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
)paren
op_eq
l_int|NULL
)paren
r_return
id|ide_stopped
suffix:semicolon
multiline_comment|/* retry only &quot;normal&quot; I/O: */
r_if
c_cond
(paren
id|rq-&gt;flags
op_amp
id|REQ_DRIVE_TASKFILE
)paren
(brace
id|rq-&gt;errors
op_assign
l_int|1
suffix:semicolon
id|ide_end_taskfile
c_func
(paren
id|drive
comma
id|stat
comma
id|err
)paren
suffix:semicolon
r_return
id|ide_stopped
suffix:semicolon
)brace
r_if
c_cond
(paren
id|stat
op_amp
id|BUSY_STAT
op_logical_or
(paren
(paren
id|stat
op_amp
id|WRERR_STAT
)paren
op_logical_and
op_logical_neg
id|drive-&gt;nowerr
)paren
)paren
(brace
multiline_comment|/* other bits are useless when BUSY */
id|rq-&gt;errors
op_or_assign
id|ERROR_RESET
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|drive-&gt;media
op_eq
id|ide_disk
op_logical_and
(paren
id|stat
op_amp
id|ERR_STAT
)paren
)paren
(brace
multiline_comment|/* err has different meaning on cdrom and tape */
r_if
c_cond
(paren
id|err
op_eq
id|ABRT_ERR
)paren
(brace
r_if
c_cond
(paren
id|drive-&gt;select.b.lba
op_logical_and
id|IN_BYTE
c_func
(paren
id|IDE_COMMAND_REG
)paren
op_eq
id|WIN_SPECIFY
)paren
r_return
id|ide_stopped
suffix:semicolon
multiline_comment|/* some newer drives don&squot;t support WIN_SPECIFY */
)brace
r_else
r_if
c_cond
(paren
(paren
id|err
op_amp
(paren
id|ABRT_ERR
op_or
id|ICRC_ERR
)paren
)paren
op_eq
(paren
id|ABRT_ERR
op_or
id|ICRC_ERR
)paren
)paren
(brace
id|drive-&gt;crc_count
op_increment
suffix:semicolon
multiline_comment|/* UDMA crc error -- just retry the operation */
)brace
r_else
r_if
c_cond
(paren
id|err
op_amp
(paren
id|BBD_ERR
op_or
id|ECC_ERR
)paren
)paren
multiline_comment|/* retries won&squot;t help these */
id|rq-&gt;errors
op_assign
id|ERROR_MAX
suffix:semicolon
r_else
r_if
c_cond
(paren
id|err
op_amp
id|TRK0_ERR
)paren
multiline_comment|/* help it find track zero */
id|rq-&gt;errors
op_or_assign
id|ERROR_RECAL
suffix:semicolon
)brace
multiline_comment|/* pre bio (rq-&gt;cmd != WRITE) */
r_if
c_cond
(paren
(paren
id|stat
op_amp
id|DRQ_STAT
)paren
op_logical_and
id|rq_data_dir
c_func
(paren
id|rq
)paren
op_eq
id|READ
)paren
id|task_try_to_flush_leftover_data
c_func
(paren
id|drive
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|GET_STAT
c_func
(paren
)paren
op_amp
(paren
id|BUSY_STAT
op_or
id|DRQ_STAT
)paren
)paren
id|OUT_BYTE
c_func
(paren
id|WIN_IDLEIMMEDIATE
comma
id|IDE_COMMAND_REG
)paren
suffix:semicolon
multiline_comment|/* force an abort */
r_if
c_cond
(paren
id|rq-&gt;errors
op_ge
id|ERROR_MAX
)paren
(brace
r_if
c_cond
(paren
id|drive-&gt;driver
op_ne
l_int|NULL
)paren
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|end_request
c_func
(paren
l_int|0
comma
id|HWGROUP
c_func
(paren
id|drive
)paren
)paren
suffix:semicolon
r_else
id|ide_end_request
c_func
(paren
l_int|0
comma
id|HWGROUP
c_func
(paren
id|drive
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
(paren
id|rq-&gt;errors
op_amp
id|ERROR_RESET
)paren
op_eq
id|ERROR_RESET
)paren
(brace
op_increment
id|rq-&gt;errors
suffix:semicolon
r_return
id|ide_do_reset
c_func
(paren
id|drive
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|rq-&gt;errors
op_amp
id|ERROR_RECAL
)paren
op_eq
id|ERROR_RECAL
)paren
id|drive-&gt;special.b.recalibrate
op_assign
l_int|1
suffix:semicolon
op_increment
id|rq-&gt;errors
suffix:semicolon
)brace
r_return
id|ide_stopped
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n; * Handler for special commands without a data phase from ide-disk&n; */
multiline_comment|/*&n; * set_multmode_intr() is invoked on completion of a WIN_SETMULT cmd.&n; */
DECL|function|set_multmode_intr
id|ide_startstop_t
id|set_multmode_intr
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|byte
id|stat
suffix:semicolon
r_if
c_cond
(paren
id|OK_STAT
c_func
(paren
id|stat
op_assign
id|GET_STAT
c_func
(paren
)paren
comma
id|READY_STAT
comma
id|BAD_STAT
)paren
)paren
(brace
id|drive-&gt;mult_count
op_assign
id|drive-&gt;mult_req
suffix:semicolon
)brace
r_else
(brace
id|drive-&gt;mult_req
op_assign
id|drive-&gt;mult_count
op_assign
l_int|0
suffix:semicolon
id|drive-&gt;special.b.recalibrate
op_assign
l_int|1
suffix:semicolon
(paren
r_void
)paren
id|ide_dump_status
c_func
(paren
id|drive
comma
l_string|&quot;set_multmode&quot;
comma
id|stat
)paren
suffix:semicolon
)brace
r_return
id|ide_stopped
suffix:semicolon
)brace
multiline_comment|/*&n; * set_geometry_intr() is invoked on completion of a WIN_SPECIFY cmd.&n; */
DECL|function|set_geometry_intr
id|ide_startstop_t
id|set_geometry_intr
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|byte
id|stat
suffix:semicolon
r_if
c_cond
(paren
id|OK_STAT
c_func
(paren
id|stat
op_assign
id|GET_STAT
c_func
(paren
)paren
comma
id|READY_STAT
comma
id|BAD_STAT
)paren
)paren
r_return
id|ide_stopped
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_amp
(paren
id|ERR_STAT
op_or
id|DRQ_STAT
)paren
)paren
r_return
id|ide_error
c_func
(paren
id|drive
comma
l_string|&quot;set_geometry_intr&quot;
comma
id|stat
)paren
suffix:semicolon
id|ide_set_handler
c_func
(paren
id|drive
comma
op_amp
id|set_geometry_intr
comma
id|WAIT_CMD
comma
l_int|NULL
)paren
suffix:semicolon
r_return
id|ide_started
suffix:semicolon
)brace
multiline_comment|/*&n; * recal_intr() is invoked on completion of a WIN_RESTORE (recalibrate) cmd.&n; */
DECL|function|recal_intr
id|ide_startstop_t
id|recal_intr
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|byte
id|stat
op_assign
id|GET_STAT
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|OK_STAT
c_func
(paren
id|stat
comma
id|READY_STAT
comma
id|BAD_STAT
)paren
)paren
r_return
id|ide_error
c_func
(paren
id|drive
comma
l_string|&quot;recal_intr&quot;
comma
id|stat
)paren
suffix:semicolon
r_return
id|ide_stopped
suffix:semicolon
)brace
multiline_comment|/*&n; * Handler for commands without a data phase&n; */
DECL|function|task_no_data_intr
id|ide_startstop_t
id|task_no_data_intr
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|ide_task_t
op_star
id|args
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq-&gt;special
suffix:semicolon
id|byte
id|stat
op_assign
id|GET_STAT
c_func
(paren
)paren
suffix:semicolon
id|ide__sti
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* local CPU only */
r_if
c_cond
(paren
op_logical_neg
id|OK_STAT
c_func
(paren
id|stat
comma
id|READY_STAT
comma
id|BAD_STAT
)paren
)paren
r_return
id|ide_error
c_func
(paren
id|drive
comma
l_string|&quot;task_no_data_intr&quot;
comma
id|stat
)paren
suffix:semicolon
multiline_comment|/* calls ide_end_drive_cmd */
r_if
c_cond
(paren
id|args
)paren
id|ide_end_drive_cmd
(paren
id|drive
comma
id|stat
comma
id|GET_ERR
c_func
(paren
)paren
)paren
suffix:semicolon
r_return
id|ide_stopped
suffix:semicolon
)brace
multiline_comment|/*&n; * Handler for command with PIO data-in phase&n; */
DECL|function|task_in_intr
id|ide_startstop_t
id|task_in_intr
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|byte
id|stat
op_assign
id|GET_STAT
c_func
(paren
)paren
suffix:semicolon
id|byte
id|io_32bit
op_assign
id|drive-&gt;io_32bit
suffix:semicolon
r_struct
id|request
op_star
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
r_char
op_star
id|pBuf
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|OK_STAT
c_func
(paren
id|stat
comma
id|DATA_READY
comma
id|BAD_R_STAT
)paren
)paren
(brace
r_if
c_cond
(paren
id|stat
op_amp
(paren
id|ERR_STAT
op_or
id|DRQ_STAT
)paren
)paren
(brace
r_return
id|ide_error
c_func
(paren
id|drive
comma
l_string|&quot;task_in_intr&quot;
comma
id|stat
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|stat
op_amp
id|BUSY_STAT
)paren
)paren
(brace
id|DTF
c_func
(paren
l_string|&quot;task_in_intr to Soon wait for next interrupt&bslash;n&quot;
)paren
suffix:semicolon
id|ide_set_handler
c_func
(paren
id|drive
comma
op_amp
id|task_in_intr
comma
id|WAIT_CMD
comma
l_int|NULL
)paren
suffix:semicolon
r_return
id|ide_started
suffix:semicolon
)brace
)brace
id|DTF
c_func
(paren
l_string|&quot;stat: %02x&bslash;n&quot;
comma
id|stat
)paren
suffix:semicolon
id|pBuf
op_assign
id|rq-&gt;buffer
op_plus
(paren
(paren
id|rq-&gt;nr_sectors
op_minus
id|rq-&gt;current_nr_sectors
)paren
op_star
id|SECTOR_SIZE
)paren
suffix:semicolon
id|DTF
c_func
(paren
l_string|&quot;Read: %p, rq-&gt;current_nr_sectors: %d&bslash;n&quot;
comma
id|pBuf
comma
(paren
r_int
)paren
id|rq-&gt;current_nr_sectors
)paren
suffix:semicolon
id|drive-&gt;io_32bit
op_assign
l_int|0
suffix:semicolon
id|taskfile_input_data
c_func
(paren
id|drive
comma
id|pBuf
comma
id|SECTOR_WORDS
)paren
suffix:semicolon
id|drive-&gt;io_32bit
op_assign
id|io_32bit
suffix:semicolon
r_if
c_cond
(paren
op_decrement
id|rq-&gt;current_nr_sectors
op_le
l_int|0
)paren
(brace
multiline_comment|/* (hs): swapped next 2 lines */
id|DTF
c_func
(paren
l_string|&quot;Request Ended stat: %02x&bslash;n&quot;
comma
id|GET_STAT
c_func
(paren
)paren
)paren
suffix:semicolon
id|ide_end_request
c_func
(paren
l_int|1
comma
id|HWGROUP
c_func
(paren
id|drive
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|ide_set_handler
c_func
(paren
id|drive
comma
op_amp
id|task_in_intr
comma
id|WAIT_CMD
comma
l_int|NULL
)paren
suffix:semicolon
r_return
id|ide_started
suffix:semicolon
)brace
r_return
id|ide_stopped
suffix:semicolon
)brace
DECL|macro|ALTSTAT_SCREW_UP
macro_line|#undef ALTSTAT_SCREW_UP
macro_line|#ifdef ALTSTAT_SCREW_UP
multiline_comment|/*&n; * (ks/hs): Poll Alternate Status Register to ensure&n; * that drive is not busy.&n; */
DECL|function|altstat_multi_busy
id|byte
id|altstat_multi_busy
(paren
id|ide_drive_t
op_star
id|drive
comma
id|byte
id|stat
comma
r_const
r_char
op_star
id|msg
)paren
(brace
r_int
id|i
suffix:semicolon
id|DTF
c_func
(paren
l_string|&quot;multi%s: ASR = %x&bslash;n&quot;
comma
id|msg
comma
id|stat
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_amp
id|BUSY_STAT
)paren
(brace
multiline_comment|/* (ks/hs): FIXME: Replace hard-coded 100, error handling? */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|100
suffix:semicolon
id|i
op_increment
)paren
(brace
id|stat
op_assign
id|GET_ALTSTAT
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|stat
op_amp
id|BUSY_STAT
)paren
op_eq
l_int|0
)paren
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * (ks/hs): Read Status AFTER Alternate Status Register&n;&t; */
r_return
id|GET_STAT
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * (ks/hs): Poll Alternate status register to wait for drive&n; * to become ready for next transfer&n; */
DECL|function|altstat_multi_poll
id|byte
id|altstat_multi_poll
(paren
id|ide_drive_t
op_star
id|drive
comma
id|byte
id|stat
comma
r_const
r_char
op_star
id|msg
)paren
(brace
multiline_comment|/* (ks/hs): FIXME: Error handling, time-out? */
r_while
c_loop
(paren
id|stat
op_amp
id|BUSY_STAT
)paren
id|stat
op_assign
id|GET_ALTSTAT
c_func
(paren
)paren
suffix:semicolon
id|DTF
c_func
(paren
l_string|&quot;multi%s: nsect=1, ASR = %x&bslash;n&quot;
comma
id|msg
comma
id|stat
)paren
suffix:semicolon
r_return
id|GET_STAT
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* (ks/hs): Clear pending IRQ */
)brace
macro_line|#endif /* ALTSTAT_SCREW_UP */
multiline_comment|/*&n; * Handler for command with Read Multiple&n; */
DECL|function|task_mulin_intr
id|ide_startstop_t
id|task_mulin_intr
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_int
r_int
id|msect
comma
id|nsect
suffix:semicolon
macro_line|#ifdef ALTSTAT_SCREW_UP
id|byte
id|stat
op_assign
id|altstat_multi_busy
c_func
(paren
id|drive
comma
id|GET_ALTSTAT
c_func
(paren
)paren
comma
l_string|&quot;read&quot;
)paren
suffix:semicolon
macro_line|#else
id|byte
id|stat
op_assign
id|GET_STAT
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif /* ALTSTAT_SCREW_UP */
id|byte
id|io_32bit
op_assign
id|drive-&gt;io_32bit
suffix:semicolon
r_struct
id|request
op_star
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
r_char
op_star
id|pBuf
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|OK_STAT
c_func
(paren
id|stat
comma
id|DATA_READY
comma
id|BAD_R_STAT
)paren
)paren
(brace
r_if
c_cond
(paren
id|stat
op_amp
(paren
id|ERR_STAT
op_or
id|DRQ_STAT
)paren
)paren
(brace
r_return
id|ide_error
c_func
(paren
id|drive
comma
l_string|&quot;task_mulin_intr&quot;
comma
id|stat
)paren
suffix:semicolon
)brace
multiline_comment|/* no data yet, so wait for another interrupt */
id|ide_set_handler
c_func
(paren
id|drive
comma
op_amp
id|task_mulin_intr
comma
id|WAIT_CMD
comma
l_int|NULL
)paren
suffix:semicolon
r_return
id|ide_started
suffix:semicolon
)brace
multiline_comment|/* (ks/hs): Fixed Multi-Sector transfer */
id|msect
op_assign
id|drive-&gt;mult_count
suffix:semicolon
macro_line|#ifdef ALTSTAT_SCREW_UP
multiline_comment|/*&n;&t; * Screw the request we do not support bad data-phase setups!&n;&t; * Either read and learn the ATA standard or crash yourself!&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|msect
)paren
(brace
multiline_comment|/*&n;&t;&t; * (ks/hs): Drive supports multi-sector transfer,&n;&t;&t; * drive-&gt;mult_count was not set&n;&t;&t; */
id|nsect
op_assign
l_int|1
suffix:semicolon
r_while
c_loop
(paren
id|rq-&gt;current_nr_sectors
)paren
(brace
id|pBuf
op_assign
id|rq-&gt;buffer
op_plus
(paren
(paren
id|rq-&gt;nr_sectors
op_minus
id|rq-&gt;current_nr_sectors
)paren
op_star
id|SECTOR_SIZE
)paren
suffix:semicolon
id|DTF
c_func
(paren
l_string|&quot;Multiread: %p, nsect: %d, rq-&gt;current_nr_sectors: %ld&bslash;n&quot;
comma
id|pBuf
comma
id|nsect
comma
id|rq-&gt;current_nr_sectors
)paren
suffix:semicolon
id|drive-&gt;io_32bit
op_assign
l_int|0
suffix:semicolon
id|taskfile_input_data
c_func
(paren
id|drive
comma
id|pBuf
comma
id|nsect
op_star
id|SECTOR_WORDS
)paren
suffix:semicolon
id|drive-&gt;io_32bit
op_assign
id|io_32bit
suffix:semicolon
id|rq-&gt;errors
op_assign
l_int|0
suffix:semicolon
id|rq-&gt;current_nr_sectors
op_sub_assign
id|nsect
suffix:semicolon
id|stat
op_assign
id|altstat_multi_poll
c_func
(paren
id|drive
comma
id|GET_ALTSTAT
c_func
(paren
)paren
comma
l_string|&quot;read&quot;
)paren
suffix:semicolon
)brace
id|ide_end_request
c_func
(paren
l_int|1
comma
id|HWGROUP
c_func
(paren
id|drive
)paren
)paren
suffix:semicolon
r_return
id|ide_stopped
suffix:semicolon
)brace
macro_line|#endif /* ALTSTAT_SCREW_UP */
id|nsect
op_assign
(paren
id|rq-&gt;current_nr_sectors
OG
id|msect
)paren
ques
c_cond
id|msect
suffix:colon
id|rq-&gt;current_nr_sectors
suffix:semicolon
id|pBuf
op_assign
id|rq-&gt;buffer
op_plus
(paren
(paren
id|rq-&gt;nr_sectors
op_minus
id|rq-&gt;current_nr_sectors
)paren
op_star
id|SECTOR_SIZE
)paren
suffix:semicolon
id|DTF
c_func
(paren
l_string|&quot;Multiread: %p, nsect: %d , rq-&gt;current_nr_sectors: %ld&bslash;n&quot;
comma
id|pBuf
comma
id|nsect
comma
id|rq-&gt;current_nr_sectors
)paren
suffix:semicolon
id|drive-&gt;io_32bit
op_assign
l_int|0
suffix:semicolon
id|taskfile_input_data
c_func
(paren
id|drive
comma
id|pBuf
comma
id|nsect
op_star
id|SECTOR_WORDS
)paren
suffix:semicolon
id|drive-&gt;io_32bit
op_assign
id|io_32bit
suffix:semicolon
id|rq-&gt;errors
op_assign
l_int|0
suffix:semicolon
id|rq-&gt;current_nr_sectors
op_sub_assign
id|nsect
suffix:semicolon
r_if
c_cond
(paren
id|rq-&gt;current_nr_sectors
op_ne
l_int|0
)paren
(brace
id|ide_set_handler
c_func
(paren
id|drive
comma
op_amp
id|task_mulin_intr
comma
id|WAIT_CMD
comma
l_int|NULL
)paren
suffix:semicolon
r_return
id|ide_started
suffix:semicolon
)brace
id|ide_end_request
c_func
(paren
l_int|1
comma
id|HWGROUP
c_func
(paren
id|drive
)paren
)paren
suffix:semicolon
r_return
id|ide_stopped
suffix:semicolon
)brace
DECL|function|pre_task_out_intr
id|ide_startstop_t
id|pre_task_out_intr
(paren
id|ide_drive_t
op_star
id|drive
comma
r_struct
id|request
op_star
id|rq
)paren
(brace
id|ide_task_t
op_star
id|args
op_assign
id|rq-&gt;special
suffix:semicolon
id|ide_startstop_t
id|startstop
suffix:semicolon
r_if
c_cond
(paren
id|ide_wait_stat
c_func
(paren
op_amp
id|startstop
comma
id|drive
comma
id|DATA_READY
comma
id|drive-&gt;bad_wstat
comma
id|WAIT_DRQ
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: no DRQ after issuing %s&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|drive-&gt;mult_count
ques
c_cond
l_string|&quot;MULTWRITE&quot;
suffix:colon
l_string|&quot;WRITE&quot;
)paren
suffix:semicolon
r_return
id|startstop
suffix:semicolon
)brace
multiline_comment|/* (ks/hs): Fixed Multi Write */
r_if
c_cond
(paren
(paren
id|args-&gt;tfRegister
(braket
id|IDE_COMMAND_OFFSET
)braket
op_ne
id|WIN_MULTWRITE
)paren
op_logical_and
(paren
id|args-&gt;tfRegister
(braket
id|IDE_COMMAND_OFFSET
)braket
op_ne
id|WIN_MULTWRITE_EXT
)paren
)paren
(brace
multiline_comment|/* For Write_sectors we need to stuff the first sector */
id|taskfile_output_data
c_func
(paren
id|drive
comma
id|rq-&gt;buffer
comma
id|SECTOR_WORDS
)paren
suffix:semicolon
id|rq-&gt;current_nr_sectors
op_decrement
suffix:semicolon
r_return
id|ide_started
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * (ks/hs): Stuff the first sector(s)&n;&t;&t; * by implicitly calling the handler&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|drive_is_ready
c_func
(paren
id|drive
)paren
)paren
)paren
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * (ks/hs): FIXME: Replace hard-coded&n;&t;&t;&t; *               100, error handling?&n;&t;&t;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|100
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|drive_is_ready
c_func
(paren
id|drive
)paren
)paren
r_break
suffix:semicolon
)brace
)brace
r_return
id|args
op_member_access_from_pointer
id|handler
c_func
(paren
id|drive
)paren
suffix:semicolon
)brace
r_return
id|ide_started
suffix:semicolon
)brace
multiline_comment|/*&n; * Handler for command with PIO data-out phase&n; */
DECL|function|task_out_intr
id|ide_startstop_t
id|task_out_intr
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|byte
id|stat
op_assign
id|GET_STAT
c_func
(paren
)paren
suffix:semicolon
id|byte
id|io_32bit
op_assign
id|drive-&gt;io_32bit
suffix:semicolon
r_struct
id|request
op_star
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
r_char
op_star
id|pBuf
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rq-&gt;current_nr_sectors
)paren
(brace
id|ide_end_request
c_func
(paren
l_int|1
comma
id|HWGROUP
c_func
(paren
id|drive
)paren
)paren
suffix:semicolon
r_return
id|ide_stopped
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|OK_STAT
c_func
(paren
id|stat
comma
id|DRIVE_READY
comma
id|drive-&gt;bad_wstat
)paren
)paren
(brace
r_return
id|ide_error
c_func
(paren
id|drive
comma
l_string|&quot;task_out_intr&quot;
comma
id|stat
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|rq-&gt;current_nr_sectors
op_eq
l_int|1
)paren
op_xor
(paren
id|stat
op_amp
id|DRQ_STAT
)paren
)paren
(brace
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
id|pBuf
op_assign
id|rq-&gt;buffer
op_plus
(paren
(paren
id|rq-&gt;nr_sectors
op_minus
id|rq-&gt;current_nr_sectors
)paren
op_star
id|SECTOR_SIZE
)paren
suffix:semicolon
id|DTF
c_func
(paren
l_string|&quot;write: %p, rq-&gt;current_nr_sectors: %d&bslash;n&quot;
comma
id|pBuf
comma
(paren
r_int
)paren
id|rq-&gt;current_nr_sectors
)paren
suffix:semicolon
id|drive-&gt;io_32bit
op_assign
l_int|0
suffix:semicolon
id|taskfile_output_data
c_func
(paren
id|drive
comma
id|pBuf
comma
id|SECTOR_WORDS
)paren
suffix:semicolon
id|drive-&gt;io_32bit
op_assign
id|io_32bit
suffix:semicolon
id|rq-&gt;errors
op_assign
l_int|0
suffix:semicolon
id|rq-&gt;current_nr_sectors
op_decrement
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rq-&gt;current_nr_sectors
op_le
l_int|0
)paren
(brace
id|ide_end_request
c_func
(paren
l_int|1
comma
id|HWGROUP
c_func
(paren
id|drive
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|ide_set_handler
c_func
(paren
id|drive
comma
op_amp
id|task_out_intr
comma
id|WAIT_CMD
comma
l_int|NULL
)paren
suffix:semicolon
r_return
id|ide_started
suffix:semicolon
)brace
r_return
id|ide_stopped
suffix:semicolon
)brace
multiline_comment|/*&n; * Handler for command write multiple&n; * Called directly from execute_drive_cmd for the first bunch of sectors,&n; * afterwards only by the ISR&n; */
DECL|function|task_mulout_intr
id|ide_startstop_t
id|task_mulout_intr
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_int
r_int
id|msect
comma
id|nsect
suffix:semicolon
macro_line|#ifdef ALTSTAT_SCREW_UP
id|byte
id|stat
op_assign
id|altstat_multi_busy
c_func
(paren
id|drive
comma
id|GET_ALTSTAT
c_func
(paren
)paren
comma
l_string|&quot;write&quot;
)paren
suffix:semicolon
macro_line|#else
id|byte
id|stat
op_assign
id|GET_STAT
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif /* ALTSTAT_SCREW_UP */
id|byte
id|io_32bit
op_assign
id|drive-&gt;io_32bit
suffix:semicolon
r_struct
id|request
op_star
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
id|ide_hwgroup_t
op_star
id|hwgroup
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
suffix:semicolon
r_char
op_star
id|pBuf
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * (ks/hs): Handle last IRQ on multi-sector transfer,&n;&t; * occurs after all data was sent&n;&t; */
r_if
c_cond
(paren
id|rq-&gt;current_nr_sectors
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|stat
op_amp
(paren
id|ERR_STAT
op_or
id|DRQ_STAT
)paren
)paren
r_return
id|ide_error
c_func
(paren
id|drive
comma
l_string|&quot;task_mulout_intr&quot;
comma
id|stat
)paren
suffix:semicolon
id|ide_end_request
c_func
(paren
l_int|1
comma
id|HWGROUP
c_func
(paren
id|drive
)paren
)paren
suffix:semicolon
r_return
id|ide_stopped
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|OK_STAT
c_func
(paren
id|stat
comma
id|DATA_READY
comma
id|BAD_R_STAT
)paren
)paren
(brace
r_if
c_cond
(paren
id|stat
op_amp
(paren
id|ERR_STAT
op_or
id|DRQ_STAT
)paren
)paren
(brace
r_return
id|ide_error
c_func
(paren
id|drive
comma
l_string|&quot;task_mulout_intr&quot;
comma
id|stat
)paren
suffix:semicolon
)brace
multiline_comment|/* no data yet, so wait for another interrupt */
r_if
c_cond
(paren
id|hwgroup-&gt;handler
op_eq
l_int|NULL
)paren
id|ide_set_handler
c_func
(paren
id|drive
comma
op_amp
id|task_mulout_intr
comma
id|WAIT_CMD
comma
l_int|NULL
)paren
suffix:semicolon
r_return
id|ide_started
suffix:semicolon
)brace
multiline_comment|/* (ks/hs): See task_mulin_intr */
id|msect
op_assign
id|drive-&gt;mult_count
suffix:semicolon
macro_line|#ifdef ALTSTAT_SCREW_UP
multiline_comment|/*&n;&t; * Screw the request we do not support bad data-phase setups!&n;&t; * Either read and learn the ATA standard or crash yourself!&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|msect
)paren
(brace
id|nsect
op_assign
l_int|1
suffix:semicolon
r_while
c_loop
(paren
id|rq-&gt;current_nr_sectors
)paren
(brace
id|pBuf
op_assign
id|rq-&gt;buffer
op_plus
(paren
(paren
id|rq-&gt;nr_sectors
op_minus
id|rq-&gt;current_nr_sectors
)paren
op_star
id|SECTOR_SIZE
)paren
suffix:semicolon
id|DTF
c_func
(paren
l_string|&quot;Multiwrite: %p, nsect: %d, rq-&gt;current_nr_sectors: %ld&bslash;n&quot;
comma
id|pBuf
comma
id|nsect
comma
id|rq-&gt;current_nr_sectors
)paren
suffix:semicolon
id|drive-&gt;io_32bit
op_assign
l_int|0
suffix:semicolon
id|taskfile_output_data
c_func
(paren
id|drive
comma
id|pBuf
comma
id|nsect
op_star
id|SECTOR_WORDS
)paren
suffix:semicolon
id|drive-&gt;io_32bit
op_assign
id|io_32bit
suffix:semicolon
id|rq-&gt;errors
op_assign
l_int|0
suffix:semicolon
id|rq-&gt;current_nr_sectors
op_sub_assign
id|nsect
suffix:semicolon
id|stat
op_assign
id|altstat_multi_poll
c_func
(paren
id|drive
comma
id|GET_ALTSTAT
c_func
(paren
)paren
comma
l_string|&quot;write&quot;
)paren
suffix:semicolon
)brace
id|ide_end_request
c_func
(paren
l_int|1
comma
id|HWGROUP
c_func
(paren
id|drive
)paren
)paren
suffix:semicolon
r_return
id|ide_stopped
suffix:semicolon
)brace
macro_line|#endif /* ALTSTAT_SCREW_UP */
id|nsect
op_assign
(paren
id|rq-&gt;current_nr_sectors
OG
id|msect
)paren
ques
c_cond
id|msect
suffix:colon
id|rq-&gt;current_nr_sectors
suffix:semicolon
id|pBuf
op_assign
id|rq-&gt;buffer
op_plus
(paren
(paren
id|rq-&gt;nr_sectors
op_minus
id|rq-&gt;current_nr_sectors
)paren
op_star
id|SECTOR_SIZE
)paren
suffix:semicolon
id|DTF
c_func
(paren
l_string|&quot;Multiwrite: %p, nsect: %d , rq-&gt;current_nr_sectors: %ld&bslash;n&quot;
comma
id|pBuf
comma
id|nsect
comma
id|rq-&gt;current_nr_sectors
)paren
suffix:semicolon
id|drive-&gt;io_32bit
op_assign
l_int|0
suffix:semicolon
id|taskfile_output_data
c_func
(paren
id|drive
comma
id|pBuf
comma
id|nsect
op_star
id|SECTOR_WORDS
)paren
suffix:semicolon
id|drive-&gt;io_32bit
op_assign
id|io_32bit
suffix:semicolon
id|rq-&gt;errors
op_assign
l_int|0
suffix:semicolon
id|rq-&gt;current_nr_sectors
op_sub_assign
id|nsect
suffix:semicolon
r_if
c_cond
(paren
id|hwgroup-&gt;handler
op_eq
l_int|NULL
)paren
id|ide_set_handler
c_func
(paren
id|drive
comma
op_amp
id|task_mulout_intr
comma
id|WAIT_CMD
comma
l_int|NULL
)paren
suffix:semicolon
r_return
id|ide_started
suffix:semicolon
)brace
multiline_comment|/* Called by internal to feature out type of command being called */
DECL|function|ide_pre_handler_parser
id|ide_pre_handler_t
op_star
id|ide_pre_handler_parser
(paren
r_struct
id|hd_drive_task_hdr
op_star
id|taskfile
comma
r_struct
id|hd_drive_hob_hdr
op_star
id|hobfile
)paren
(brace
r_switch
c_cond
(paren
id|taskfile-&gt;command
)paren
(brace
multiline_comment|/* IDE_DRIVE_TASK_RAW_WRITE */
r_case
id|CFA_WRITE_MULTI_WO_ERASE
suffix:colon
r_case
id|WIN_MULTWRITE
suffix:colon
r_case
id|WIN_MULTWRITE_EXT
suffix:colon
multiline_comment|/* IDE_DRIVE_TASK_OUT */
r_case
id|WIN_WRITE
suffix:colon
r_case
id|WIN_WRITE_EXT
suffix:colon
r_case
id|WIN_WRITE_VERIFY
suffix:colon
r_case
id|WIN_WRITE_BUFFER
suffix:colon
r_case
id|CFA_WRITE_SECT_WO_ERASE
suffix:colon
r_case
id|WIN_DOWNLOAD_MICROCODE
suffix:colon
r_return
op_amp
id|pre_task_out_intr
suffix:semicolon
multiline_comment|/* IDE_DRIVE_TASK_OUT */
r_case
id|WIN_SMART
suffix:colon
r_if
c_cond
(paren
id|taskfile-&gt;feature
op_eq
id|SMART_WRITE_LOG_SECTOR
)paren
r_return
op_amp
id|pre_task_out_intr
suffix:semicolon
r_case
id|WIN_WRITEDMA
suffix:colon
r_case
id|WIN_WRITEDMA_QUEUED
suffix:colon
r_case
id|WIN_WRITEDMA_EXT
suffix:colon
r_case
id|WIN_WRITEDMA_QUEUED_EXT
suffix:colon
multiline_comment|/* IDE_DRIVE_TASK_OUT */
r_default
suffix:colon
r_break
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Called by internal to feature out type of command being called */
DECL|function|ide_handler_parser
id|ide_handler_t
op_star
id|ide_handler_parser
(paren
r_struct
id|hd_drive_task_hdr
op_star
id|taskfile
comma
r_struct
id|hd_drive_hob_hdr
op_star
id|hobfile
)paren
(brace
r_switch
c_cond
(paren
id|taskfile-&gt;command
)paren
(brace
r_case
id|WIN_IDENTIFY
suffix:colon
r_case
id|WIN_PIDENTIFY
suffix:colon
r_case
id|CFA_TRANSLATE_SECTOR
suffix:colon
r_case
id|WIN_READ_BUFFER
suffix:colon
r_case
id|WIN_READ
suffix:colon
r_case
id|WIN_READ_EXT
suffix:colon
r_return
op_amp
id|task_in_intr
suffix:semicolon
r_case
id|WIN_SECURITY_DISABLE
suffix:colon
r_case
id|WIN_SECURITY_ERASE_UNIT
suffix:colon
r_case
id|WIN_SECURITY_SET_PASS
suffix:colon
r_case
id|WIN_SECURITY_UNLOCK
suffix:colon
r_case
id|WIN_DOWNLOAD_MICROCODE
suffix:colon
r_case
id|CFA_WRITE_SECT_WO_ERASE
suffix:colon
r_case
id|WIN_WRITE_BUFFER
suffix:colon
r_case
id|WIN_WRITE_VERIFY
suffix:colon
r_case
id|WIN_WRITE
suffix:colon
r_case
id|WIN_WRITE_EXT
suffix:colon
r_return
op_amp
id|task_out_intr
suffix:semicolon
r_case
id|WIN_MULTREAD
suffix:colon
r_case
id|WIN_MULTREAD_EXT
suffix:colon
r_return
op_amp
id|task_mulin_intr
suffix:semicolon
r_case
id|CFA_WRITE_MULTI_WO_ERASE
suffix:colon
r_case
id|WIN_MULTWRITE
suffix:colon
r_case
id|WIN_MULTWRITE_EXT
suffix:colon
r_return
op_amp
id|task_mulout_intr
suffix:semicolon
r_case
id|WIN_SMART
suffix:colon
r_switch
c_cond
(paren
id|taskfile-&gt;feature
)paren
(brace
r_case
id|SMART_READ_VALUES
suffix:colon
r_case
id|SMART_READ_THRESHOLDS
suffix:colon
r_case
id|SMART_READ_LOG_SECTOR
suffix:colon
r_return
op_amp
id|task_in_intr
suffix:semicolon
r_case
id|SMART_WRITE_LOG_SECTOR
suffix:colon
r_return
op_amp
id|task_out_intr
suffix:semicolon
r_default
suffix:colon
r_return
op_amp
id|task_no_data_intr
suffix:semicolon
)brace
r_case
id|CFA_REQ_EXT_ERROR_CODE
suffix:colon
r_case
id|CFA_ERASE_SECTORS
suffix:colon
r_case
id|WIN_VERIFY
suffix:colon
r_case
id|WIN_VERIFY_EXT
suffix:colon
r_case
id|WIN_SEEK
suffix:colon
r_return
op_amp
id|task_no_data_intr
suffix:semicolon
r_case
id|WIN_SPECIFY
suffix:colon
r_return
op_amp
id|set_geometry_intr
suffix:semicolon
r_case
id|WIN_RESTORE
suffix:colon
r_return
op_amp
id|recal_intr
suffix:semicolon
r_case
id|WIN_DIAGNOSE
suffix:colon
r_case
id|WIN_FLUSH_CACHE
suffix:colon
r_case
id|WIN_FLUSH_CACHE_EXT
suffix:colon
r_case
id|WIN_STANDBYNOW1
suffix:colon
r_case
id|WIN_STANDBYNOW2
suffix:colon
r_case
id|WIN_SLEEPNOW1
suffix:colon
r_case
id|WIN_SLEEPNOW2
suffix:colon
r_case
id|WIN_SETIDLE1
suffix:colon
r_case
id|WIN_CHECKPOWERMODE1
suffix:colon
r_case
id|WIN_CHECKPOWERMODE2
suffix:colon
r_case
id|WIN_GETMEDIASTATUS
suffix:colon
r_case
id|WIN_MEDIAEJECT
suffix:colon
r_return
op_amp
id|task_no_data_intr
suffix:semicolon
r_case
id|WIN_SETMULT
suffix:colon
r_return
op_amp
id|set_multmode_intr
suffix:semicolon
r_case
id|WIN_READ_NATIVE_MAX
suffix:colon
r_case
id|WIN_SET_MAX
suffix:colon
r_case
id|WIN_READ_NATIVE_MAX_EXT
suffix:colon
r_case
id|WIN_SET_MAX_EXT
suffix:colon
r_case
id|WIN_SECURITY_ERASE_PREPARE
suffix:colon
r_case
id|WIN_SECURITY_FREEZE_LOCK
suffix:colon
r_case
id|WIN_DOORLOCK
suffix:colon
r_case
id|WIN_DOORUNLOCK
suffix:colon
r_case
id|WIN_SETFEATURES
suffix:colon
r_return
op_amp
id|task_no_data_intr
suffix:semicolon
r_case
id|DISABLE_SEAGATE
suffix:colon
r_case
id|EXABYTE_ENABLE_NEST
suffix:colon
r_return
op_amp
id|task_no_data_intr
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_IDEDMA
r_case
id|WIN_READDMA
suffix:colon
r_case
id|WIN_IDENTIFY_DMA
suffix:colon
r_case
id|WIN_READDMA_QUEUED
suffix:colon
r_case
id|WIN_READDMA_EXT
suffix:colon
r_case
id|WIN_READDMA_QUEUED_EXT
suffix:colon
r_case
id|WIN_WRITEDMA
suffix:colon
r_case
id|WIN_WRITEDMA_QUEUED
suffix:colon
r_case
id|WIN_WRITEDMA_EXT
suffix:colon
r_case
id|WIN_WRITEDMA_QUEUED_EXT
suffix:colon
macro_line|#endif
r_case
id|WIN_FORMAT
suffix:colon
r_case
id|WIN_INIT
suffix:colon
r_case
id|WIN_DEVICE_RESET
suffix:colon
r_case
id|WIN_QUEUED_SERVICE
suffix:colon
r_case
id|WIN_PACKETCMD
suffix:colon
r_default
suffix:colon
r_return
l_int|NULL
suffix:semicolon
)brace
)brace
multiline_comment|/* Called by ioctl to feature out type of command being called */
DECL|function|ide_cmd_type_parser
r_int
id|ide_cmd_type_parser
(paren
id|ide_task_t
op_star
id|args
)paren
(brace
r_struct
id|hd_drive_task_hdr
op_star
id|taskfile
op_assign
(paren
r_struct
id|hd_drive_task_hdr
op_star
)paren
id|args-&gt;tfRegister
suffix:semicolon
r_struct
id|hd_drive_hob_hdr
op_star
id|hobfile
op_assign
(paren
r_struct
id|hd_drive_hob_hdr
op_star
)paren
id|args-&gt;hobRegister
suffix:semicolon
id|args-&gt;prehandler
op_assign
id|ide_pre_handler_parser
c_func
(paren
id|taskfile
comma
id|hobfile
)paren
suffix:semicolon
id|args-&gt;handler
op_assign
id|ide_handler_parser
c_func
(paren
id|taskfile
comma
id|hobfile
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|args-&gt;tfRegister
(braket
id|IDE_COMMAND_OFFSET
)braket
)paren
(brace
r_case
id|WIN_IDENTIFY
suffix:colon
r_case
id|WIN_PIDENTIFY
suffix:colon
r_return
id|IDE_DRIVE_TASK_IN
suffix:semicolon
r_case
id|CFA_TRANSLATE_SECTOR
suffix:colon
r_case
id|WIN_READ
suffix:colon
r_case
id|WIN_READ_EXT
suffix:colon
r_case
id|WIN_READ_BUFFER
suffix:colon
r_return
id|IDE_DRIVE_TASK_IN
suffix:semicolon
r_case
id|WIN_WRITE
suffix:colon
r_case
id|WIN_WRITE_EXT
suffix:colon
r_case
id|WIN_WRITE_VERIFY
suffix:colon
r_case
id|WIN_WRITE_BUFFER
suffix:colon
r_case
id|CFA_WRITE_SECT_WO_ERASE
suffix:colon
r_case
id|WIN_DOWNLOAD_MICROCODE
suffix:colon
r_return
id|IDE_DRIVE_TASK_RAW_WRITE
suffix:semicolon
r_case
id|WIN_MULTREAD
suffix:colon
r_case
id|WIN_MULTREAD_EXT
suffix:colon
r_return
id|IDE_DRIVE_TASK_IN
suffix:semicolon
r_case
id|CFA_WRITE_MULTI_WO_ERASE
suffix:colon
r_case
id|WIN_MULTWRITE
suffix:colon
r_case
id|WIN_MULTWRITE_EXT
suffix:colon
r_return
id|IDE_DRIVE_TASK_RAW_WRITE
suffix:semicolon
r_case
id|WIN_SECURITY_DISABLE
suffix:colon
r_case
id|WIN_SECURITY_ERASE_UNIT
suffix:colon
r_case
id|WIN_SECURITY_SET_PASS
suffix:colon
r_case
id|WIN_SECURITY_UNLOCK
suffix:colon
r_return
id|IDE_DRIVE_TASK_OUT
suffix:semicolon
r_case
id|WIN_SMART
suffix:colon
id|args-&gt;tfRegister
(braket
id|IDE_LCYL_OFFSET
)braket
op_assign
id|SMART_LCYL_PASS
suffix:semicolon
id|args-&gt;tfRegister
(braket
id|IDE_HCYL_OFFSET
)braket
op_assign
id|SMART_HCYL_PASS
suffix:semicolon
r_switch
c_cond
(paren
id|args-&gt;tfRegister
(braket
id|IDE_FEATURE_OFFSET
)braket
)paren
(brace
r_case
id|SMART_READ_VALUES
suffix:colon
r_case
id|SMART_READ_THRESHOLDS
suffix:colon
r_case
id|SMART_READ_LOG_SECTOR
suffix:colon
r_return
id|IDE_DRIVE_TASK_IN
suffix:semicolon
r_case
id|SMART_WRITE_LOG_SECTOR
suffix:colon
r_return
id|IDE_DRIVE_TASK_OUT
suffix:semicolon
r_default
suffix:colon
r_return
id|IDE_DRIVE_TASK_NO_DATA
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_BLK_DEV_IDEDMA
r_case
id|WIN_READDMA
suffix:colon
r_case
id|WIN_IDENTIFY_DMA
suffix:colon
r_case
id|WIN_READDMA_QUEUED
suffix:colon
r_case
id|WIN_READDMA_EXT
suffix:colon
r_case
id|WIN_READDMA_QUEUED_EXT
suffix:colon
r_return
id|IDE_DRIVE_TASK_IN
suffix:semicolon
r_case
id|WIN_WRITEDMA
suffix:colon
r_case
id|WIN_WRITEDMA_QUEUED
suffix:colon
r_case
id|WIN_WRITEDMA_EXT
suffix:colon
r_case
id|WIN_WRITEDMA_QUEUED_EXT
suffix:colon
r_return
id|IDE_DRIVE_TASK_RAW_WRITE
suffix:semicolon
macro_line|#endif
r_case
id|WIN_SETFEATURES
suffix:colon
r_switch
c_cond
(paren
id|args-&gt;tfRegister
(braket
id|IDE_FEATURE_OFFSET
)braket
)paren
(brace
r_case
id|SETFEATURES_XFER
suffix:colon
r_return
id|IDE_DRIVE_TASK_SET_XFER
suffix:semicolon
r_case
id|SETFEATURES_DIS_DEFECT
suffix:colon
r_case
id|SETFEATURES_EN_APM
suffix:colon
r_case
id|SETFEATURES_DIS_MSN
suffix:colon
r_case
id|SETFEATURES_EN_RI
suffix:colon
r_case
id|SETFEATURES_EN_SI
suffix:colon
r_case
id|SETFEATURES_DIS_RPOD
suffix:colon
r_case
id|SETFEATURES_DIS_WCACHE
suffix:colon
r_case
id|SETFEATURES_EN_DEFECT
suffix:colon
r_case
id|SETFEATURES_DIS_APM
suffix:colon
r_case
id|SETFEATURES_EN_MSN
suffix:colon
r_case
id|SETFEATURES_EN_RLA
suffix:colon
r_case
id|SETFEATURES_PREFETCH
suffix:colon
r_case
id|SETFEATURES_EN_RPOD
suffix:colon
r_case
id|SETFEATURES_DIS_RI
suffix:colon
r_case
id|SETFEATURES_DIS_SI
suffix:colon
r_default
suffix:colon
r_return
id|IDE_DRIVE_TASK_NO_DATA
suffix:semicolon
)brace
r_case
id|WIN_NOP
suffix:colon
r_case
id|CFA_REQ_EXT_ERROR_CODE
suffix:colon
r_case
id|CFA_ERASE_SECTORS
suffix:colon
r_case
id|WIN_VERIFY
suffix:colon
r_case
id|WIN_VERIFY_EXT
suffix:colon
r_case
id|WIN_SEEK
suffix:colon
r_case
id|WIN_SPECIFY
suffix:colon
r_case
id|WIN_RESTORE
suffix:colon
r_case
id|WIN_DIAGNOSE
suffix:colon
r_case
id|WIN_FLUSH_CACHE
suffix:colon
r_case
id|WIN_FLUSH_CACHE_EXT
suffix:colon
r_case
id|WIN_STANDBYNOW1
suffix:colon
r_case
id|WIN_STANDBYNOW2
suffix:colon
r_case
id|WIN_SLEEPNOW1
suffix:colon
r_case
id|WIN_SLEEPNOW2
suffix:colon
r_case
id|WIN_SETIDLE1
suffix:colon
r_case
id|DISABLE_SEAGATE
suffix:colon
r_case
id|WIN_CHECKPOWERMODE1
suffix:colon
r_case
id|WIN_CHECKPOWERMODE2
suffix:colon
r_case
id|WIN_GETMEDIASTATUS
suffix:colon
r_case
id|WIN_MEDIAEJECT
suffix:colon
r_case
id|WIN_SETMULT
suffix:colon
r_case
id|WIN_READ_NATIVE_MAX
suffix:colon
r_case
id|WIN_SET_MAX
suffix:colon
r_case
id|WIN_READ_NATIVE_MAX_EXT
suffix:colon
r_case
id|WIN_SET_MAX_EXT
suffix:colon
r_case
id|WIN_SECURITY_ERASE_PREPARE
suffix:colon
r_case
id|WIN_SECURITY_FREEZE_LOCK
suffix:colon
r_case
id|EXABYTE_ENABLE_NEST
suffix:colon
r_case
id|WIN_DOORLOCK
suffix:colon
r_case
id|WIN_DOORUNLOCK
suffix:colon
r_return
id|IDE_DRIVE_TASK_NO_DATA
suffix:semicolon
r_case
id|WIN_FORMAT
suffix:colon
r_case
id|WIN_INIT
suffix:colon
r_case
id|WIN_DEVICE_RESET
suffix:colon
r_case
id|WIN_QUEUED_SERVICE
suffix:colon
r_case
id|WIN_PACKETCMD
suffix:colon
r_default
suffix:colon
r_return
id|IDE_DRIVE_TASK_INVALID
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * This function is intended to be used prior to invoking ide_do_drive_cmd().&n; */
DECL|function|ide_init_drive_taskfile
r_void
id|ide_init_drive_taskfile
(paren
r_struct
id|request
op_star
id|rq
)paren
(brace
id|memset
c_func
(paren
id|rq
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|rq
)paren
)paren
suffix:semicolon
id|rq-&gt;flags
op_assign
id|REQ_DRIVE_TASKFILE
suffix:semicolon
)brace
multiline_comment|/*&n; * This is kept for internal use only !!!&n; * This is an internal call and nobody in user-space has a damn&n; * reason to call this taskfile.&n; *&n; * ide_raw_taskfile is the one that user-space executes.&n; */
DECL|function|ide_wait_taskfile
r_int
id|ide_wait_taskfile
(paren
id|ide_drive_t
op_star
id|drive
comma
r_struct
id|hd_drive_task_hdr
op_star
id|taskfile
comma
r_struct
id|hd_drive_hob_hdr
op_star
id|hobfile
comma
id|byte
op_star
id|buf
)paren
(brace
r_struct
id|request
id|rq
suffix:semicolon
id|ide_task_t
id|args
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|args
comma
l_int|0
comma
r_sizeof
(paren
id|ide_task_t
)paren
)paren
suffix:semicolon
id|args.tfRegister
(braket
id|IDE_DATA_OFFSET
)braket
op_assign
id|taskfile-&gt;data
suffix:semicolon
id|args.tfRegister
(braket
id|IDE_FEATURE_OFFSET
)braket
op_assign
id|taskfile-&gt;feature
suffix:semicolon
id|args.tfRegister
(braket
id|IDE_NSECTOR_OFFSET
)braket
op_assign
id|taskfile-&gt;sector_count
suffix:semicolon
id|args.tfRegister
(braket
id|IDE_SECTOR_OFFSET
)braket
op_assign
id|taskfile-&gt;sector_number
suffix:semicolon
id|args.tfRegister
(braket
id|IDE_LCYL_OFFSET
)braket
op_assign
id|taskfile-&gt;low_cylinder
suffix:semicolon
id|args.tfRegister
(braket
id|IDE_HCYL_OFFSET
)braket
op_assign
id|taskfile-&gt;high_cylinder
suffix:semicolon
id|args.tfRegister
(braket
id|IDE_SELECT_OFFSET
)braket
op_assign
id|taskfile-&gt;device_head
suffix:semicolon
id|args.tfRegister
(braket
id|IDE_COMMAND_OFFSET
)braket
op_assign
id|taskfile-&gt;command
suffix:semicolon
id|args.hobRegister
(braket
id|IDE_DATA_OFFSET_HOB
)braket
op_assign
id|hobfile-&gt;data
suffix:semicolon
id|args.hobRegister
(braket
id|IDE_FEATURE_OFFSET_HOB
)braket
op_assign
id|hobfile-&gt;feature
suffix:semicolon
id|args.hobRegister
(braket
id|IDE_NSECTOR_OFFSET_HOB
)braket
op_assign
id|hobfile-&gt;sector_count
suffix:semicolon
id|args.hobRegister
(braket
id|IDE_SECTOR_OFFSET_HOB
)braket
op_assign
id|hobfile-&gt;sector_number
suffix:semicolon
id|args.hobRegister
(braket
id|IDE_LCYL_OFFSET_HOB
)braket
op_assign
id|hobfile-&gt;low_cylinder
suffix:semicolon
id|args.hobRegister
(braket
id|IDE_HCYL_OFFSET_HOB
)braket
op_assign
id|hobfile-&gt;high_cylinder
suffix:semicolon
id|args.hobRegister
(braket
id|IDE_SELECT_OFFSET_HOB
)braket
op_assign
id|hobfile-&gt;device_head
suffix:semicolon
id|args.hobRegister
(braket
id|IDE_CONTROL_OFFSET_HOB
)braket
op_assign
id|hobfile-&gt;control
suffix:semicolon
id|ide_init_drive_taskfile
c_func
(paren
op_amp
id|rq
)paren
suffix:semicolon
multiline_comment|/* This is kept for internal use only !!! */
id|args.command_type
op_assign
id|ide_cmd_type_parser
(paren
op_amp
id|args
)paren
suffix:semicolon
r_if
c_cond
(paren
id|args.command_type
op_ne
id|IDE_DRIVE_TASK_NO_DATA
)paren
id|rq.current_nr_sectors
op_assign
id|rq.nr_sectors
op_assign
(paren
id|hobfile-&gt;sector_count
op_lshift
l_int|8
)paren
op_or
id|taskfile-&gt;sector_count
suffix:semicolon
id|rq.buffer
op_assign
id|buf
suffix:semicolon
id|rq.special
op_assign
op_amp
id|args
suffix:semicolon
r_return
id|ide_do_drive_cmd
c_func
(paren
id|drive
comma
op_amp
id|rq
comma
id|ide_wait
)paren
suffix:semicolon
)brace
DECL|function|ide_raw_taskfile
r_int
id|ide_raw_taskfile
(paren
id|ide_drive_t
op_star
id|drive
comma
id|ide_task_t
op_star
id|args
comma
id|byte
op_star
id|buf
)paren
(brace
r_struct
id|request
id|rq
suffix:semicolon
id|ide_init_drive_taskfile
c_func
(paren
op_amp
id|rq
)paren
suffix:semicolon
id|rq.buffer
op_assign
id|buf
suffix:semicolon
r_if
c_cond
(paren
id|args-&gt;command_type
op_ne
id|IDE_DRIVE_TASK_NO_DATA
)paren
id|rq.current_nr_sectors
op_assign
id|rq.nr_sectors
op_assign
(paren
id|args-&gt;hobRegister
(braket
id|IDE_NSECTOR_OFFSET_HOB
)braket
op_lshift
l_int|8
)paren
op_or
id|args-&gt;tfRegister
(braket
id|IDE_NSECTOR_OFFSET
)braket
suffix:semicolon
id|rq.special
op_assign
id|args
suffix:semicolon
r_return
id|ide_do_drive_cmd
c_func
(paren
id|drive
comma
op_amp
id|rq
comma
id|ide_wait
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_IDE_TASK_IOCTL_DEBUG
DECL|function|ide_ioctl_verbose
r_char
op_star
id|ide_ioctl_verbose
(paren
r_int
r_int
id|cmd
)paren
(brace
r_return
l_string|&quot;unknown&quot;
suffix:semicolon
)brace
DECL|function|ide_task_cmd_verbose
r_char
op_star
id|ide_task_cmd_verbose
(paren
id|byte
id|task
)paren
(brace
r_return
l_string|&quot;unknown&quot;
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_IDE_TASK_IOCTL_DEBUG */
multiline_comment|/*&n; *  The taskfile glue table&n; *&n; *  reqtask.data_phase&t;reqtask.req_cmd&n; *  &t;&t;&t;args.command_type&t;&t;args.handler&n; *&n; *  TASKFILE_P_OUT_DMAQ&t;??&t;&t;&t;&t;??&n; *  TASKFILE_P_IN_DMAQ&t;??&t;&t;&t;&t;??&n; *  TASKFILE_P_OUT_DMA&t;??&t;&t;&t;&t;??&n; *  TASKFILE_P_IN_DMA&t;??&t;&t;&t;&t;??&n; *  TASKFILE_P_OUT&t;??&t;&t;&t;&t;??&n; *  TASKFILE_P_IN&t;??&t;&t;&t;&t;??&n; *&n; *  TASKFILE_OUT_DMAQ&t;IDE_DRIVE_TASK_RAW_WRITE&t;NULL&n; *  TASKFILE_IN_DMAQ&t;IDE_DRIVE_TASK_IN&t;&t;NULL&n; *&n; *  TASKFILE_OUT_DMA&t;IDE_DRIVE_TASK_RAW_WRITE&t;NULL&n; *  TASKFILE_IN_DMA&t;IDE_DRIVE_TASK_IN&t;&t;NULL&n; *&n; *  TASKFILE_IN_OUT&t;??&t;&t;&t;&t;??&n; *&n; *  TASKFILE_MULTI_OUT&t;IDE_DRIVE_TASK_RAW_WRITE&t;task_mulout_intr&n; *  TASKFILE_MULTI_IN&t;IDE_DRIVE_TASK_IN&t;&t;task_mulin_intr&n; *&n; *  TASKFILE_OUT&t;IDE_DRIVE_TASK_RAW_WRITE&t;task_out_intr&n; *  TASKFILE_OUT&t;IDE_DRIVE_TASK_OUT&t;&t;task_out_intr&n; *&n; *  TASKFILE_IN&t;&t;IDE_DRIVE_TASK_IN&t;&t;task_in_intr&n; *  TASKFILE_NO_DATA&t;IDE_DRIVE_TASK_NO_DATA&t;&t;task_no_data_intr&n; *&n; *  &t;&t;&t;IDE_DRIVE_TASK_SET_XFER&t;&t;task_no_data_intr&n; *  &t;&t;&t;IDE_DRIVE_TASK_INVALID&n; *&n; */
DECL|macro|MAX_DMA
mdefine_line|#define MAX_DMA&t;&t;(256*SECTOR_WORDS)
DECL|function|ide_taskfile_ioctl
r_int
id|ide_taskfile_ioctl
(paren
id|ide_drive_t
op_star
id|drive
comma
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
id|ide_task_request_t
op_star
id|req_task
suffix:semicolon
id|ide_task_t
id|args
suffix:semicolon
id|byte
op_star
id|outbuf
op_assign
l_int|NULL
suffix:semicolon
id|byte
op_star
id|inbuf
op_assign
l_int|NULL
suffix:semicolon
id|task_ioreg_t
op_star
id|argsptr
op_assign
id|args.tfRegister
suffix:semicolon
id|task_ioreg_t
op_star
id|hobsptr
op_assign
id|args.hobRegister
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
r_int
id|tasksize
op_assign
r_sizeof
(paren
r_struct
id|ide_task_request_s
)paren
suffix:semicolon
r_int
id|taskin
op_assign
l_int|0
suffix:semicolon
r_int
id|taskout
op_assign
l_int|0
suffix:semicolon
id|req_task
op_assign
id|kmalloc
c_func
(paren
id|tasksize
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|req_task
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|memset
c_func
(paren
id|req_task
comma
l_int|0
comma
id|tasksize
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|req_task
comma
(paren
r_void
op_star
)paren
id|arg
comma
id|tasksize
)paren
)paren
(brace
id|kfree
c_func
(paren
id|req_task
)paren
suffix:semicolon
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
id|taskout
op_assign
(paren
r_int
)paren
id|req_task-&gt;out_size
suffix:semicolon
id|taskin
op_assign
(paren
r_int
)paren
id|req_task-&gt;in_size
suffix:semicolon
r_if
c_cond
(paren
id|taskout
)paren
(brace
r_int
id|outtotal
op_assign
id|tasksize
suffix:semicolon
id|outbuf
op_assign
id|kmalloc
c_func
(paren
id|taskout
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|outbuf
op_eq
l_int|NULL
)paren
(brace
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
id|memset
c_func
(paren
id|outbuf
comma
l_int|0
comma
id|taskout
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|outbuf
comma
(paren
r_void
op_star
)paren
id|arg
op_plus
id|outtotal
comma
id|taskout
)paren
)paren
(brace
id|err
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|taskin
)paren
(brace
r_int
id|intotal
op_assign
id|tasksize
op_plus
id|taskout
suffix:semicolon
id|inbuf
op_assign
id|kmalloc
c_func
(paren
id|taskin
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inbuf
op_eq
l_int|NULL
)paren
(brace
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
id|memset
c_func
(paren
id|inbuf
comma
l_int|0
comma
id|taskin
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|inbuf
comma
(paren
r_void
op_star
)paren
id|arg
op_plus
id|intotal
comma
id|taskin
)paren
)paren
(brace
id|err
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
)brace
id|memset
c_func
(paren
id|argsptr
comma
l_int|0
comma
id|HDIO_DRIVE_TASK_HDR_SIZE
)paren
suffix:semicolon
id|memset
c_func
(paren
id|hobsptr
comma
l_int|0
comma
id|HDIO_DRIVE_HOB_HDR_SIZE
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|argsptr
comma
id|req_task-&gt;io_ports
comma
id|HDIO_DRIVE_TASK_HDR_SIZE
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|hobsptr
comma
id|req_task-&gt;hob_ports
comma
id|HDIO_DRIVE_HOB_HDR_SIZE
)paren
suffix:semicolon
id|args.tf_in_flags
op_assign
id|req_task-&gt;in_flags
suffix:semicolon
id|args.tf_out_flags
op_assign
id|req_task-&gt;out_flags
suffix:semicolon
id|args.data_phase
op_assign
id|req_task-&gt;data_phase
suffix:semicolon
id|args.command_type
op_assign
id|req_task-&gt;req_cmd
suffix:semicolon
macro_line|#ifdef CONFIG_IDE_TASK_IOCTL_DEBUG
id|DTF
c_func
(paren
l_string|&quot;%s: ide_ioctl_cmd %s:  ide_task_cmd %s&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|ide_ioctl_verbose
c_func
(paren
id|cmd
)paren
comma
id|ide_task_cmd_verbose
c_func
(paren
id|args.tfRegister
(braket
id|IDE_COMMAND_OFFSET
)braket
)paren
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_IDE_TASK_IOCTL_DEBUG */
r_switch
c_cond
(paren
id|req_task-&gt;data_phase
)paren
(brace
r_case
id|TASKFILE_OUT_DMAQ
suffix:colon
r_case
id|TASKFILE_OUT_DMA
suffix:colon
id|args.prehandler
op_assign
l_int|NULL
suffix:semicolon
id|args.handler
op_assign
l_int|NULL
suffix:semicolon
id|args.posthandler
op_assign
l_int|NULL
suffix:semicolon
id|err
op_assign
id|ide_raw_taskfile
c_func
(paren
id|drive
comma
op_amp
id|args
comma
id|outbuf
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TASKFILE_IN_DMAQ
suffix:colon
r_case
id|TASKFILE_IN_DMA
suffix:colon
id|args.prehandler
op_assign
l_int|NULL
suffix:semicolon
id|args.handler
op_assign
l_int|NULL
suffix:semicolon
id|args.posthandler
op_assign
l_int|NULL
suffix:semicolon
id|err
op_assign
id|ide_raw_taskfile
c_func
(paren
id|drive
comma
op_amp
id|args
comma
id|inbuf
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TASKFILE_IN_OUT
suffix:colon
macro_line|#if 0
id|args.prehandler
op_assign
op_amp
id|pre_task_out_intr
suffix:semicolon
id|args.handler
op_assign
op_amp
id|task_out_intr
suffix:semicolon
id|args.posthandler
op_assign
l_int|NULL
suffix:semicolon
id|err
op_assign
id|ide_raw_taskfile
c_func
(paren
id|drive
comma
op_amp
id|args
comma
id|outbuf
)paren
suffix:semicolon
id|args.prehandler
op_assign
l_int|NULL
suffix:semicolon
id|args.handler
op_assign
op_amp
id|task_in_intr
suffix:semicolon
id|args.posthandler
op_assign
l_int|NULL
suffix:semicolon
id|err
op_assign
id|ide_raw_taskfile
c_func
(paren
id|drive
comma
op_amp
id|args
comma
id|inbuf
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#else
id|err
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
m_abort
suffix:semicolon
macro_line|#endif
r_case
id|TASKFILE_MULTI_OUT
suffix:colon
r_if
c_cond
(paren
id|drive-&gt;mult_count
)paren
(brace
id|args.prehandler
op_assign
op_amp
id|pre_task_out_intr
suffix:semicolon
id|args.handler
op_assign
op_amp
id|task_mulout_intr
suffix:semicolon
id|args.posthandler
op_assign
l_int|NULL
suffix:semicolon
id|err
op_assign
id|ide_raw_taskfile
c_func
(paren
id|drive
comma
op_amp
id|args
comma
id|outbuf
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* (hs): give up if multcount is not set */
id|printk
c_func
(paren
l_string|&quot;%s: %s Multimode Write &quot;
"&bslash;"
l_string|&quot;multcount is not set&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|__FUNCTION__
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EPERM
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|TASKFILE_OUT
suffix:colon
id|args.prehandler
op_assign
op_amp
id|pre_task_out_intr
suffix:semicolon
id|args.handler
op_assign
op_amp
id|task_out_intr
suffix:semicolon
id|args.posthandler
op_assign
l_int|NULL
suffix:semicolon
id|err
op_assign
id|ide_raw_taskfile
c_func
(paren
id|drive
comma
op_amp
id|args
comma
id|outbuf
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TASKFILE_MULTI_IN
suffix:colon
r_if
c_cond
(paren
id|drive-&gt;mult_count
)paren
(brace
id|args.prehandler
op_assign
l_int|NULL
suffix:semicolon
id|args.handler
op_assign
op_amp
id|task_mulin_intr
suffix:semicolon
id|args.posthandler
op_assign
l_int|NULL
suffix:semicolon
id|err
op_assign
id|ide_raw_taskfile
c_func
(paren
id|drive
comma
op_amp
id|args
comma
id|inbuf
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* (hs): give up if multcount is not set */
id|printk
c_func
(paren
l_string|&quot;%s: %s Multimode Read failure &quot;
"&bslash;"
l_string|&quot;multcount is not set&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|__FUNCTION__
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EPERM
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|TASKFILE_IN
suffix:colon
id|args.prehandler
op_assign
l_int|NULL
suffix:semicolon
id|args.handler
op_assign
op_amp
id|task_in_intr
suffix:semicolon
id|args.posthandler
op_assign
l_int|NULL
suffix:semicolon
id|err
op_assign
id|ide_raw_taskfile
c_func
(paren
id|drive
comma
op_amp
id|args
comma
id|inbuf
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TASKFILE_NO_DATA
suffix:colon
id|args.prehandler
op_assign
l_int|NULL
suffix:semicolon
id|args.handler
op_assign
op_amp
id|task_no_data_intr
suffix:semicolon
id|args.posthandler
op_assign
l_int|NULL
suffix:semicolon
id|err
op_assign
id|ide_raw_taskfile
c_func
(paren
id|drive
comma
op_amp
id|args
comma
l_int|NULL
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|args.prehandler
op_assign
l_int|NULL
suffix:semicolon
id|args.handler
op_assign
l_int|NULL
suffix:semicolon
id|args.posthandler
op_assign
l_int|NULL
suffix:semicolon
id|err
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|req_task-&gt;io_ports
comma
op_amp
(paren
id|args.tfRegister
)paren
comma
id|HDIO_DRIVE_TASK_HDR_SIZE
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|req_task-&gt;hob_ports
comma
op_amp
(paren
id|args.hobRegister
)paren
comma
id|HDIO_DRIVE_HOB_HDR_SIZE
)paren
suffix:semicolon
id|req_task-&gt;in_flags
op_assign
id|args.tf_in_flags
suffix:semicolon
id|req_task-&gt;out_flags
op_assign
id|args.tf_out_flags
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
id|req_task
comma
id|tasksize
)paren
)paren
(brace
id|err
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
r_if
c_cond
(paren
id|taskout
)paren
(brace
r_int
id|outtotal
op_assign
id|tasksize
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
op_plus
id|outtotal
comma
id|outbuf
comma
id|taskout
)paren
)paren
(brace
id|err
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|taskin
)paren
(brace
r_int
id|intotal
op_assign
id|tasksize
op_plus
id|taskout
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
op_plus
id|intotal
comma
id|inbuf
comma
id|taskin
)paren
)paren
(brace
id|err
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
)brace
m_abort
suffix:colon
id|kfree
c_func
(paren
id|req_task
)paren
suffix:semicolon
r_if
c_cond
(paren
id|outbuf
op_ne
l_int|NULL
)paren
id|kfree
c_func
(paren
id|outbuf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inbuf
op_ne
l_int|NULL
)paren
id|kfree
c_func
(paren
id|inbuf
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|function|ide_cmd_ioctl
r_int
id|ide_cmd_ioctl
(paren
id|ide_drive_t
op_star
id|drive
comma
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_int
id|err
op_assign
l_int|0
suffix:semicolon
id|byte
id|args
(braket
l_int|4
)braket
comma
op_star
id|argbuf
op_assign
id|args
suffix:semicolon
id|byte
id|xfer_rate
op_assign
l_int|0
suffix:semicolon
r_int
id|argsize
op_assign
l_int|4
suffix:semicolon
id|ide_task_t
id|tfargs
suffix:semicolon
r_if
c_cond
(paren
l_int|NULL
op_eq
(paren
r_void
op_star
)paren
id|arg
)paren
(brace
r_struct
id|request
id|rq
suffix:semicolon
id|ide_init_drive_cmd
c_func
(paren
op_amp
id|rq
)paren
suffix:semicolon
r_return
id|ide_do_drive_cmd
c_func
(paren
id|drive
comma
op_amp
id|rq
comma
id|ide_wait
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|args
comma
(paren
r_void
op_star
)paren
id|arg
comma
l_int|4
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|tfargs.tfRegister
(braket
id|IDE_FEATURE_OFFSET
)braket
op_assign
id|args
(braket
l_int|2
)braket
suffix:semicolon
id|tfargs.tfRegister
(braket
id|IDE_NSECTOR_OFFSET
)braket
op_assign
id|args
(braket
l_int|3
)braket
suffix:semicolon
id|tfargs.tfRegister
(braket
id|IDE_SECTOR_OFFSET
)braket
op_assign
id|args
(braket
l_int|1
)braket
suffix:semicolon
id|tfargs.tfRegister
(braket
id|IDE_LCYL_OFFSET
)braket
op_assign
l_int|0x00
suffix:semicolon
id|tfargs.tfRegister
(braket
id|IDE_HCYL_OFFSET
)braket
op_assign
l_int|0x00
suffix:semicolon
id|tfargs.tfRegister
(braket
id|IDE_SELECT_OFFSET
)braket
op_assign
l_int|0x00
suffix:semicolon
id|tfargs.tfRegister
(braket
id|IDE_COMMAND_OFFSET
)braket
op_assign
id|args
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
id|args
(braket
l_int|3
)braket
)paren
(brace
id|argsize
op_assign
l_int|4
op_plus
(paren
id|SECTOR_WORDS
op_star
l_int|4
op_star
id|args
(braket
l_int|3
)braket
)paren
suffix:semicolon
id|argbuf
op_assign
id|kmalloc
c_func
(paren
id|argsize
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|argbuf
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|memcpy
c_func
(paren
id|argbuf
comma
id|args
comma
l_int|4
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|set_transfer
c_func
(paren
id|drive
comma
op_amp
id|tfargs
)paren
)paren
(brace
id|xfer_rate
op_assign
id|args
(braket
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
id|ide_ata66_check
c_func
(paren
id|drive
comma
op_amp
id|tfargs
)paren
)paren
r_goto
m_abort
suffix:semicolon
)brace
id|err
op_assign
id|ide_wait_cmd
c_func
(paren
id|drive
comma
id|args
(braket
l_int|0
)braket
comma
id|args
(braket
l_int|1
)braket
comma
id|args
(braket
l_int|2
)braket
comma
id|args
(braket
l_int|3
)braket
comma
id|argbuf
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|err
op_logical_and
id|xfer_rate
)paren
(brace
multiline_comment|/* active-retuning-calls future */
r_if
c_cond
(paren
(paren
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|speedproc
)paren
op_ne
l_int|NULL
)paren
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|speedproc
c_func
(paren
id|drive
comma
id|xfer_rate
)paren
suffix:semicolon
id|ide_driveid_update
c_func
(paren
id|drive
)paren
suffix:semicolon
)brace
m_abort
suffix:colon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
id|argbuf
comma
id|argsize
)paren
)paren
id|err
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|argsize
OG
l_int|4
)paren
id|kfree
c_func
(paren
id|argbuf
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|function|ide_task_ioctl
r_int
id|ide_task_ioctl
(paren
id|ide_drive_t
op_star
id|drive
comma
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_int
id|err
op_assign
l_int|0
suffix:semicolon
id|byte
id|args
(braket
l_int|7
)braket
comma
op_star
id|argbuf
op_assign
id|args
suffix:semicolon
r_int
id|argsize
op_assign
l_int|7
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|args
comma
(paren
r_void
op_star
)paren
id|arg
comma
l_int|7
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|err
op_assign
id|ide_wait_cmd_task
c_func
(paren
id|drive
comma
id|argbuf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
id|argbuf
comma
id|argsize
)paren
)paren
id|err
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|variable|drive_is_ready
id|EXPORT_SYMBOL
c_func
(paren
id|drive_is_ready
)paren
suffix:semicolon
DECL|variable|task_read_24
id|EXPORT_SYMBOL
c_func
(paren
id|task_read_24
)paren
suffix:semicolon
DECL|variable|ata_input_data
id|EXPORT_SYMBOL
c_func
(paren
id|ata_input_data
)paren
suffix:semicolon
DECL|variable|ata_output_data
id|EXPORT_SYMBOL
c_func
(paren
id|ata_output_data
)paren
suffix:semicolon
DECL|variable|atapi_input_bytes
id|EXPORT_SYMBOL
c_func
(paren
id|atapi_input_bytes
)paren
suffix:semicolon
DECL|variable|atapi_output_bytes
id|EXPORT_SYMBOL
c_func
(paren
id|atapi_output_bytes
)paren
suffix:semicolon
DECL|variable|taskfile_input_data
id|EXPORT_SYMBOL
c_func
(paren
id|taskfile_input_data
)paren
suffix:semicolon
DECL|variable|taskfile_output_data
id|EXPORT_SYMBOL
c_func
(paren
id|taskfile_output_data
)paren
suffix:semicolon
DECL|variable|do_rw_taskfile
id|EXPORT_SYMBOL
c_func
(paren
id|do_rw_taskfile
)paren
suffix:semicolon
DECL|variable|do_taskfile
id|EXPORT_SYMBOL
c_func
(paren
id|do_taskfile
)paren
suffix:semicolon
singleline_comment|// EXPORT_SYMBOL(flagged_taskfile);
singleline_comment|//EXPORT_SYMBOL(ide_end_taskfile);
DECL|variable|set_multmode_intr
id|EXPORT_SYMBOL
c_func
(paren
id|set_multmode_intr
)paren
suffix:semicolon
DECL|variable|set_geometry_intr
id|EXPORT_SYMBOL
c_func
(paren
id|set_geometry_intr
)paren
suffix:semicolon
DECL|variable|recal_intr
id|EXPORT_SYMBOL
c_func
(paren
id|recal_intr
)paren
suffix:semicolon
DECL|variable|task_no_data_intr
id|EXPORT_SYMBOL
c_func
(paren
id|task_no_data_intr
)paren
suffix:semicolon
DECL|variable|task_in_intr
id|EXPORT_SYMBOL
c_func
(paren
id|task_in_intr
)paren
suffix:semicolon
DECL|variable|task_mulin_intr
id|EXPORT_SYMBOL
c_func
(paren
id|task_mulin_intr
)paren
suffix:semicolon
DECL|variable|pre_task_out_intr
id|EXPORT_SYMBOL
c_func
(paren
id|pre_task_out_intr
)paren
suffix:semicolon
DECL|variable|task_out_intr
id|EXPORT_SYMBOL
c_func
(paren
id|task_out_intr
)paren
suffix:semicolon
DECL|variable|task_mulout_intr
id|EXPORT_SYMBOL
c_func
(paren
id|task_mulout_intr
)paren
suffix:semicolon
DECL|variable|ide_init_drive_taskfile
id|EXPORT_SYMBOL
c_func
(paren
id|ide_init_drive_taskfile
)paren
suffix:semicolon
DECL|variable|ide_wait_taskfile
id|EXPORT_SYMBOL
c_func
(paren
id|ide_wait_taskfile
)paren
suffix:semicolon
DECL|variable|ide_raw_taskfile
id|EXPORT_SYMBOL
c_func
(paren
id|ide_raw_taskfile
)paren
suffix:semicolon
DECL|variable|ide_pre_handler_parser
id|EXPORT_SYMBOL
c_func
(paren
id|ide_pre_handler_parser
)paren
suffix:semicolon
DECL|variable|ide_handler_parser
id|EXPORT_SYMBOL
c_func
(paren
id|ide_handler_parser
)paren
suffix:semicolon
DECL|variable|ide_cmd_type_parser
id|EXPORT_SYMBOL
c_func
(paren
id|ide_cmd_type_parser
)paren
suffix:semicolon
DECL|variable|ide_taskfile_ioctl
id|EXPORT_SYMBOL
c_func
(paren
id|ide_taskfile_ioctl
)paren
suffix:semicolon
DECL|variable|ide_cmd_ioctl
id|EXPORT_SYMBOL
c_func
(paren
id|ide_cmd_ioctl
)paren
suffix:semicolon
DECL|variable|ide_task_ioctl
id|EXPORT_SYMBOL
c_func
(paren
id|ide_task_ioctl
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_PKT_TASK_IOCTL
macro_line|#if 0
(brace
(brace
multiline_comment|/* start cdrom */
r_struct
id|cdrom_info
op_star
id|info
op_assign
id|drive-&gt;driver_data
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;dma
)paren
(brace
r_if
c_cond
(paren
id|info-&gt;cmd
op_eq
id|READ
)paren
(brace
id|info-&gt;dma
op_assign
op_logical_neg
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|dmaproc
c_func
(paren
id|ide_dma_read
comma
id|drive
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|info-&gt;cmd
op_eq
id|WRITE
)paren
(brace
id|info-&gt;dma
op_assign
op_logical_neg
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|dmaproc
c_func
(paren
id|ide_dma_write
comma
id|drive
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;ide-cd: DMA set, but not allowed&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Set up the controller registers. */
id|OUT_BYTE
(paren
id|info-&gt;dma
comma
id|IDE_FEATURE_REG
)paren
suffix:semicolon
id|OUT_BYTE
(paren
l_int|0
comma
id|IDE_NSECTOR_REG
)paren
suffix:semicolon
id|OUT_BYTE
(paren
l_int|0
comma
id|IDE_SECTOR_REG
)paren
suffix:semicolon
id|OUT_BYTE
(paren
id|xferlen
op_amp
l_int|0xff
comma
id|IDE_LCYL_REG
)paren
suffix:semicolon
id|OUT_BYTE
(paren
id|xferlen
op_rshift
l_int|8
comma
id|IDE_HCYL_REG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IDE_CONTROL_REG
)paren
id|OUT_BYTE
(paren
id|drive-&gt;ctl
comma
id|IDE_CONTROL_REG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;dma
)paren
(paren
r_void
)paren
(paren
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|dmaproc
c_func
(paren
id|ide_dma_begin
comma
id|drive
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|drq_interrupt
)paren
(brace
id|ide_set_handler
(paren
id|drive
comma
id|handler
comma
id|WAIT_CMD
comma
id|cdrom_timer_expiry
)paren
suffix:semicolon
id|OUT_BYTE
(paren
id|WIN_PACKETCMD
comma
id|IDE_COMMAND_REG
)paren
suffix:semicolon
multiline_comment|/* packet command */
r_return
id|ide_started
suffix:semicolon
)brace
r_else
(brace
id|OUT_BYTE
(paren
id|WIN_PACKETCMD
comma
id|IDE_COMMAND_REG
)paren
suffix:semicolon
multiline_comment|/* packet command */
r_return
(paren
op_star
id|handler
)paren
(paren
id|drive
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* end cdrom */
(brace
multiline_comment|/* start floppy */
id|idefloppy_floppy_t
op_star
id|floppy
op_assign
id|drive-&gt;driver_data
suffix:semicolon
id|idefloppy_bcount_reg_t
id|bcount
suffix:semicolon
r_int
id|dma_ok
op_assign
l_int|0
suffix:semicolon
id|floppy-&gt;pc
op_assign
id|pc
suffix:semicolon
multiline_comment|/* Set the current packet command */
id|pc-&gt;retries
op_increment
suffix:semicolon
id|pc-&gt;actually_transferred
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* We haven&squot;t transferred any data yet */
id|pc-&gt;current_position
op_assign
id|pc-&gt;buffer
suffix:semicolon
id|bcount.all
op_assign
id|IDE_MIN
c_func
(paren
id|pc-&gt;request_transfer
comma
l_int|63
op_star
l_int|1024
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_IDEDMA
r_if
c_cond
(paren
id|test_and_clear_bit
(paren
id|PC_DMA_ERROR
comma
op_amp
id|pc-&gt;flags
)paren
)paren
(brace
(paren
r_void
)paren
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|dmaproc
c_func
(paren
id|ide_dma_off
comma
id|drive
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|test_bit
(paren
id|PC_DMA_RECOMMENDED
comma
op_amp
id|pc-&gt;flags
)paren
op_logical_and
id|drive-&gt;using_dma
)paren
id|dma_ok
op_assign
op_logical_neg
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|dmaproc
c_func
(paren
id|test_bit
(paren
id|PC_WRITING
comma
op_amp
id|pc-&gt;flags
)paren
ques
c_cond
id|ide_dma_write
suffix:colon
id|ide_dma_read
comma
id|drive
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_BLK_DEV_IDEDMA */
r_if
c_cond
(paren
id|IDE_CONTROL_REG
)paren
id|OUT_BYTE
(paren
id|drive-&gt;ctl
comma
id|IDE_CONTROL_REG
)paren
suffix:semicolon
id|OUT_BYTE
(paren
id|dma_ok
ques
c_cond
l_int|1
suffix:colon
l_int|0
comma
id|IDE_FEATURE_REG
)paren
suffix:semicolon
multiline_comment|/* Use PIO/DMA */
id|OUT_BYTE
(paren
id|bcount.b.high
comma
id|IDE_BCOUNTH_REG
)paren
suffix:semicolon
id|OUT_BYTE
(paren
id|bcount.b.low
comma
id|IDE_BCOUNTL_REG
)paren
suffix:semicolon
id|OUT_BYTE
(paren
id|drive-&gt;select.all
comma
id|IDE_SELECT_REG
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_IDEDMA
r_if
c_cond
(paren
id|dma_ok
)paren
(brace
multiline_comment|/* Begin DMA, if necessary */
id|set_bit
(paren
id|PC_DMA_IN_PROGRESS
comma
op_amp
id|pc-&gt;flags
)paren
suffix:semicolon
(paren
r_void
)paren
(paren
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|dmaproc
c_func
(paren
id|ide_dma_begin
comma
id|drive
)paren
)paren
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_BLK_DEV_IDEDMA */
)brace
multiline_comment|/* end floppy */
(brace
multiline_comment|/* start tape */
id|idetape_tape_t
op_star
id|tape
op_assign
id|drive-&gt;driver_data
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_IDEDMA
r_if
c_cond
(paren
id|test_and_clear_bit
(paren
id|PC_DMA_ERROR
comma
op_amp
id|pc-&gt;flags
)paren
)paren
(brace
id|printk
(paren
id|KERN_WARNING
l_string|&quot;ide-tape: DMA disabled, reverting to PIO&bslash;n&quot;
)paren
suffix:semicolon
(paren
r_void
)paren
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|dmaproc
c_func
(paren
id|ide_dma_off
comma
id|drive
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|test_bit
(paren
id|PC_DMA_RECOMMENDED
comma
op_amp
id|pc-&gt;flags
)paren
op_logical_and
id|drive-&gt;using_dma
)paren
id|dma_ok
op_assign
op_logical_neg
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|dmaproc
c_func
(paren
id|test_bit
(paren
id|PC_WRITING
comma
op_amp
id|pc-&gt;flags
)paren
ques
c_cond
id|ide_dma_write
suffix:colon
id|ide_dma_read
comma
id|drive
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_BLK_DEV_IDEDMA */
r_if
c_cond
(paren
id|IDE_CONTROL_REG
)paren
id|OUT_BYTE
(paren
id|drive-&gt;ctl
comma
id|IDE_CONTROL_REG
)paren
suffix:semicolon
id|OUT_BYTE
(paren
id|dma_ok
ques
c_cond
l_int|1
suffix:colon
l_int|0
comma
id|IDE_FEATURE_REG
)paren
suffix:semicolon
multiline_comment|/* Use PIO/DMA */
id|OUT_BYTE
(paren
id|bcount.b.high
comma
id|IDE_BCOUNTH_REG
)paren
suffix:semicolon
id|OUT_BYTE
(paren
id|bcount.b.low
comma
id|IDE_BCOUNTL_REG
)paren
suffix:semicolon
id|OUT_BYTE
(paren
id|drive-&gt;select.all
comma
id|IDE_SELECT_REG
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_IDEDMA
r_if
c_cond
(paren
id|dma_ok
)paren
(brace
multiline_comment|/* Begin DMA, if necessary */
id|set_bit
(paren
id|PC_DMA_IN_PROGRESS
comma
op_amp
id|pc-&gt;flags
)paren
suffix:semicolon
(paren
r_void
)paren
(paren
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|dmaproc
c_func
(paren
id|ide_dma_begin
comma
id|drive
)paren
)paren
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_BLK_DEV_IDEDMA */
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|IDETAPE_DRQ_INTERRUPT
comma
op_amp
id|tape-&gt;flags
)paren
)paren
(brace
id|ide_set_handler
c_func
(paren
id|drive
comma
op_amp
id|idetape_transfer_pc
comma
id|IDETAPE_WAIT_CMD
comma
l_int|NULL
)paren
suffix:semicolon
id|OUT_BYTE
c_func
(paren
id|WIN_PACKETCMD
comma
id|IDE_COMMAND_REG
)paren
suffix:semicolon
r_return
id|ide_started
suffix:semicolon
)brace
r_else
(brace
id|OUT_BYTE
c_func
(paren
id|WIN_PACKETCMD
comma
id|IDE_COMMAND_REG
)paren
suffix:semicolon
r_return
id|idetape_transfer_pc
c_func
(paren
id|drive
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* end tape */
)brace
macro_line|#endif
DECL|function|pkt_taskfile_ioctl
r_int
id|pkt_taskfile_ioctl
(paren
id|ide_drive_t
op_star
id|drive
comma
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
macro_line|#if 0
r_switch
c_cond
(paren
id|req_task-&gt;data_phase
)paren
(brace
r_case
id|TASKFILE_P_OUT_DMAQ
suffix:colon
r_case
id|TASKFILE_P_IN_DMAQ
suffix:colon
r_case
id|TASKFILE_P_OUT_DMA
suffix:colon
r_case
id|TASKFILE_P_IN_DMA
suffix:colon
r_case
id|TASKFILE_P_OUT
suffix:colon
r_case
id|TASKFILE_P_IN
suffix:colon
)brace
macro_line|#endif
r_return
op_minus
id|ENOMSG
suffix:semicolon
)brace
DECL|variable|pkt_taskfile_ioctl
id|EXPORT_SYMBOL
c_func
(paren
id|pkt_taskfile_ioctl
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_PKT_TASK_IOCTL */
eof
