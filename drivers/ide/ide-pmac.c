multiline_comment|/*&n; * Support for IDE interfaces on PowerMacs.&n; * These IDE interfaces are memory-mapped and have a DBDMA channel&n; * for doing DMA.&n; *&n; *  Copyright (C) 1998-2001 Paul Mackerras &amp; Ben. Herrenschmidt&n; *&n; *  This program is free software; you can redistribute it and/or&n; *  modify it under the terms of the GNU General Public License&n; *  as published by the Free Software Foundation; either version&n; *  2 of the License, or (at your option) any later version.&n; *&n; * Some code taken from drivers/ide/ide-dma.c:&n; *&n; *  Copyright (c) 1995-1998  Mark Lord&n; *&n; * TODO:&n; *&n; *  - Find a way to duplicate less code with ide-dma and use the&n; *    dma fileds in the hwif structure instead of our own&n; *&n; *  - Fix check_disk_change() call&n; *&n; *  - Make module-able (includes setting ppc_md. hooks from within&n; *    this file and not from arch code, and handling module deps with&n; *    mediabay (by having both modules do dynamic lookup of each other&n; *    symbols or by storing hooks at arch level).&n; *&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/jiffies.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/ide.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;asm/prom.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/dbdma.h&gt;
macro_line|#include &lt;asm/ide.h&gt;
macro_line|#include &lt;asm/mediabay.h&gt;
macro_line|#include &lt;asm/pci-bridge.h&gt;
macro_line|#include &lt;asm/machdep.h&gt;
macro_line|#include &lt;asm/pmac_feature.h&gt;
macro_line|#include &lt;asm/sections.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#ifdef CONFIG_PMAC_PBOOK
macro_line|#include &lt;linux/adb.h&gt;
macro_line|#include &lt;linux/pmu.h&gt;
macro_line|#endif
macro_line|#include &quot;ata-timing.h&quot;
DECL|macro|IDE_PMAC_DEBUG
macro_line|#undef IDE_PMAC_DEBUG
DECL|macro|DMA_WAIT_TIMEOUT
mdefine_line|#define DMA_WAIT_TIMEOUT&t;500
DECL|struct|pmac_ide_hwif
r_struct
id|pmac_ide_hwif
(brace
DECL|member|regbase
id|ide_ioreg_t
id|regbase
suffix:semicolon
DECL|member|irq
r_int
id|irq
suffix:semicolon
DECL|member|kind
r_int
id|kind
suffix:semicolon
DECL|member|aapl_bus_id
r_int
id|aapl_bus_id
suffix:semicolon
DECL|member|node
r_struct
id|device_node
op_star
id|node
suffix:semicolon
DECL|member|timings
id|u32
id|timings
(braket
l_int|2
)braket
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_IDEDMA_PMAC
multiline_comment|/* Those fields are duplicating what is in hwif. We currently&n;&t; * can&squot;t use the hwif ones because of some assumptions that are&n;&t; * beeing done by the generic code about the kind of dma controller&n;&t; * and format of the dma table. This will have to be fixed though.&n;&t; */
DECL|member|dma_regs
r_volatile
r_struct
id|dbdma_regs
op_star
id|dma_regs
suffix:semicolon
DECL|member|dma_table_cpu
r_struct
id|dbdma_cmd
op_star
id|dma_table_cpu
suffix:semicolon
DECL|member|dma_table_dma
id|dma_addr_t
id|dma_table_dma
suffix:semicolon
DECL|member|sg_table
r_struct
id|scatterlist
op_star
id|sg_table
suffix:semicolon
DECL|member|sg_nents
r_int
id|sg_nents
suffix:semicolon
DECL|member|sg_dma_direction
r_int
id|sg_dma_direction
suffix:semicolon
macro_line|#endif
DECL|variable|__pmacdata
)brace
id|pmac_ide
(braket
id|MAX_HWIFS
)braket
id|__pmacdata
suffix:semicolon
DECL|variable|pmac_ide_count
r_static
r_int
id|pmac_ide_count
suffix:semicolon
r_enum
(brace
DECL|enumerator|controller_ohare
id|controller_ohare
comma
multiline_comment|/* OHare based */
DECL|enumerator|controller_heathrow
id|controller_heathrow
comma
multiline_comment|/* Heathrow/Paddington */
DECL|enumerator|controller_kl_ata3
id|controller_kl_ata3
comma
multiline_comment|/* KeyLargo ATA-3 */
DECL|enumerator|controller_kl_ata4
id|controller_kl_ata4
comma
multiline_comment|/* KeyLargo ATA-4 */
DECL|enumerator|controller_kl_ata4_80
id|controller_kl_ata4_80
multiline_comment|/* KeyLargo ATA-4 with 80 conductor cable */
)brace
suffix:semicolon
multiline_comment|/*&n; * Extra registers, both 32-bit little-endian&n; */
DECL|macro|IDE_TIMING_CONFIG
mdefine_line|#define IDE_TIMING_CONFIG&t;0x200
DECL|macro|IDE_INTERRUPT
mdefine_line|#define IDE_INTERRUPT&t;&t;0x300
multiline_comment|/*&n; * Timing configuration register definitions&n; */
multiline_comment|/* Number of IDE_SYSCLK_NS ticks, argument is in nanoseconds */
DECL|macro|SYSCLK_TICKS
mdefine_line|#define SYSCLK_TICKS(t)&t;&t;(((t) + IDE_SYSCLK_NS - 1) / IDE_SYSCLK_NS)
DECL|macro|SYSCLK_TICKS_66
mdefine_line|#define SYSCLK_TICKS_66(t)&t;(((t) + IDE_SYSCLK_66_NS - 1) / IDE_SYSCLK_66_NS)
DECL|macro|IDE_SYSCLK_NS
mdefine_line|#define IDE_SYSCLK_NS&t;&t;30&t;/* 33Mhz cell */
DECL|macro|IDE_SYSCLK_66_NS
mdefine_line|#define IDE_SYSCLK_66_NS&t;15&t;/* 66Mhz cell */
multiline_comment|/* 66Mhz cell, found in KeyLargo. Can do ultra mode 0 to 2 on&n; * 40 connector cable and to 4 on 80 connector one.&n; * Clock unit is 15ns (66Mhz)&n; *&n; * 3 Values can be programmed:&n; *  - Write data setup, which appears to match the cycle time. They&n; *    also call it DIOW setup.&n; *  - Ready to pause time (from spec)&n; *  - Address setup. That one is weird. I don&squot;t see where exactly&n; *    it fits in UDMA cycles, I got it&squot;s name from an obscure piece&n; *    of commented out code in Darwin. They leave it to 0, we do as&n; *    well, despite a comment that would lead to think it has a&n; *    min value of 45ns.&n; * Apple also add 60ns to the write data setup (or cycle time ?) on&n; * reads. I can&squot;t explain that, I tried it and it broke everything&n; * here.&n; */
DECL|macro|TR_66_UDMA_MASK
mdefine_line|#define TR_66_UDMA_MASK&t;&t;&t;0xfff00000
DECL|macro|TR_66_UDMA_EN
mdefine_line|#define TR_66_UDMA_EN&t;&t;&t;0x00100000 /* Enable Ultra mode for DMA */
DECL|macro|TR_66_UDMA_ADDRSETUP_MASK
mdefine_line|#define TR_66_UDMA_ADDRSETUP_MASK&t;0xe0000000 /* Address setup */
DECL|macro|TR_66_UDMA_ADDRSETUP_SHIFT
mdefine_line|#define TR_66_UDMA_ADDRSETUP_SHIFT&t;29
DECL|macro|TR_66_UDMA_RDY2PAUS_MASK
mdefine_line|#define TR_66_UDMA_RDY2PAUS_MASK&t;0x1e000000 /* Ready 2 pause time */
DECL|macro|TR_66_UDMA_RDY2PAUS_SHIFT
mdefine_line|#define TR_66_UDMA_RDY2PAUS_SHIFT&t;25
DECL|macro|TR_66_UDMA_WRDATASETUP_MASK
mdefine_line|#define TR_66_UDMA_WRDATASETUP_MASK&t;0x01e00000 /* Write data setup time */
DECL|macro|TR_66_UDMA_WRDATASETUP_SHIFT
mdefine_line|#define TR_66_UDMA_WRDATASETUP_SHIFT&t;21
DECL|macro|TR_66_MDMA_MASK
mdefine_line|#define TR_66_MDMA_MASK&t;&t;&t;0x000ffc00
DECL|macro|TR_66_MDMA_RECOVERY_MASK
mdefine_line|#define TR_66_MDMA_RECOVERY_MASK&t;0x000f8000
DECL|macro|TR_66_MDMA_RECOVERY_SHIFT
mdefine_line|#define TR_66_MDMA_RECOVERY_SHIFT&t;15
DECL|macro|TR_66_MDMA_ACCESS_MASK
mdefine_line|#define TR_66_MDMA_ACCESS_MASK&t;&t;0x00007c00
DECL|macro|TR_66_MDMA_ACCESS_SHIFT
mdefine_line|#define TR_66_MDMA_ACCESS_SHIFT&t;&t;10
DECL|macro|TR_66_PIO_MASK
mdefine_line|#define TR_66_PIO_MASK&t;&t;&t;0x000003ff
DECL|macro|TR_66_PIO_RECOVERY_MASK
mdefine_line|#define TR_66_PIO_RECOVERY_MASK&t;&t;0x000003e0
DECL|macro|TR_66_PIO_RECOVERY_SHIFT
mdefine_line|#define TR_66_PIO_RECOVERY_SHIFT&t;5
DECL|macro|TR_66_PIO_ACCESS_MASK
mdefine_line|#define TR_66_PIO_ACCESS_MASK&t;&t;0x0000001f
DECL|macro|TR_66_PIO_ACCESS_SHIFT
mdefine_line|#define TR_66_PIO_ACCESS_SHIFT&t;&t;0
multiline_comment|/* 33Mhz cell, found in OHare, Heathrow (&amp; Paddington) and KeyLargo&n; * Can do pio &amp; mdma modes, clock unit is 30ns (33Mhz)&n; *&n; * The access time and recovery time can be programmed. Some older&n; * Darwin code base limit OHare to 150ns cycle time. I decided to do&n; * the same here fore safety against broken old hardware ;)&n; * The HalfTick bit, when set, adds half a clock (15ns) to the access&n; * time and removes one from recovery. It&squot;s not supported on KeyLargo&n; * implementation afaik. The E bit appears to be set for PIO mode 0 and&n; * is used to reach long timings used in this mode.&n; */
DECL|macro|TR_33_MDMA_MASK
mdefine_line|#define TR_33_MDMA_MASK&t;&t;&t;0x003ff800
DECL|macro|TR_33_MDMA_RECOVERY_MASK
mdefine_line|#define TR_33_MDMA_RECOVERY_MASK&t;0x001f0000
DECL|macro|TR_33_MDMA_RECOVERY_SHIFT
mdefine_line|#define TR_33_MDMA_RECOVERY_SHIFT&t;16
DECL|macro|TR_33_MDMA_ACCESS_MASK
mdefine_line|#define TR_33_MDMA_ACCESS_MASK&t;&t;0x0000f800
DECL|macro|TR_33_MDMA_ACCESS_SHIFT
mdefine_line|#define TR_33_MDMA_ACCESS_SHIFT&t;&t;11
DECL|macro|TR_33_MDMA_HALFTICK
mdefine_line|#define TR_33_MDMA_HALFTICK&t;&t;0x00200000
DECL|macro|TR_33_PIO_MASK
mdefine_line|#define TR_33_PIO_MASK&t;&t;&t;0x000007ff
DECL|macro|TR_33_PIO_E
mdefine_line|#define TR_33_PIO_E&t;&t;&t;0x00000400
DECL|macro|TR_33_PIO_RECOVERY_MASK
mdefine_line|#define TR_33_PIO_RECOVERY_MASK&t;&t;0x000003e0
DECL|macro|TR_33_PIO_RECOVERY_SHIFT
mdefine_line|#define TR_33_PIO_RECOVERY_SHIFT&t;5
DECL|macro|TR_33_PIO_ACCESS_MASK
mdefine_line|#define TR_33_PIO_ACCESS_MASK&t;&t;0x0000001f
DECL|macro|TR_33_PIO_ACCESS_SHIFT
mdefine_line|#define TR_33_PIO_ACCESS_SHIFT&t;&t;0
multiline_comment|/*&n; * Interrupt register definitions&n; */
DECL|macro|IDE_INTR_DMA
mdefine_line|#define IDE_INTR_DMA&t;&t;&t;0x80000000
DECL|macro|IDE_INTR_DEVICE
mdefine_line|#define IDE_INTR_DEVICE&t;&t;&t;0x40000000
macro_line|#ifdef CONFIG_BLK_DEV_IDEDMA_PMAC
DECL|macro|BAD_DMA_DRIVE
macro_line|# define BAD_DMA_DRIVE&t;&t;0
DECL|macro|GOOD_DMA_DRIVE
macro_line|# define GOOD_DMA_DRIVE&t;&t;1
multiline_comment|/* Rounded Multiword DMA timings&n; *&n; * I gave up finding a generic formula for all controller&n; * types and instead, built tables based on timing values&n; * used by Apple in Darwin&squot;s implementation.&n; */
DECL|struct|mdma_timings_t
r_struct
id|mdma_timings_t
(brace
DECL|member|accessTime
r_int
id|accessTime
suffix:semicolon
DECL|member|recoveryTime
r_int
id|recoveryTime
suffix:semicolon
DECL|member|cycleTime
r_int
id|cycleTime
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|__pmacdata
r_struct
id|mdma_timings_t
id|mdma_timings_33
(braket
)braket
id|__pmacdata
op_assign
(brace
(brace
l_int|240
comma
l_int|240
comma
l_int|480
)brace
comma
(brace
l_int|180
comma
l_int|180
comma
l_int|360
)brace
comma
(brace
l_int|135
comma
l_int|135
comma
l_int|270
)brace
comma
(brace
l_int|120
comma
l_int|120
comma
l_int|240
)brace
comma
(brace
l_int|105
comma
l_int|105
comma
l_int|210
)brace
comma
(brace
l_int|90
comma
l_int|90
comma
l_int|180
)brace
comma
(brace
l_int|75
comma
l_int|75
comma
l_int|150
)brace
comma
(brace
l_int|75
comma
l_int|45
comma
l_int|120
)brace
comma
(brace
l_int|0
comma
l_int|0
comma
l_int|0
)brace
)brace
suffix:semicolon
DECL|variable|__pmacdata
r_struct
id|mdma_timings_t
id|mdma_timings_33k
(braket
)braket
id|__pmacdata
op_assign
(brace
(brace
l_int|240
comma
l_int|240
comma
l_int|480
)brace
comma
(brace
l_int|180
comma
l_int|180
comma
l_int|360
)brace
comma
(brace
l_int|150
comma
l_int|150
comma
l_int|300
)brace
comma
(brace
l_int|120
comma
l_int|120
comma
l_int|240
)brace
comma
(brace
l_int|90
comma
l_int|120
comma
l_int|210
)brace
comma
(brace
l_int|90
comma
l_int|90
comma
l_int|180
)brace
comma
(brace
l_int|90
comma
l_int|60
comma
l_int|150
)brace
comma
(brace
l_int|90
comma
l_int|30
comma
l_int|120
)brace
comma
(brace
l_int|0
comma
l_int|0
comma
l_int|0
)brace
)brace
suffix:semicolon
DECL|variable|__pmacdata
r_struct
id|mdma_timings_t
id|mdma_timings_66
(braket
)braket
id|__pmacdata
op_assign
(brace
(brace
l_int|240
comma
l_int|240
comma
l_int|480
)brace
comma
(brace
l_int|180
comma
l_int|180
comma
l_int|360
)brace
comma
(brace
l_int|135
comma
l_int|135
comma
l_int|270
)brace
comma
(brace
l_int|120
comma
l_int|120
comma
l_int|240
)brace
comma
(brace
l_int|105
comma
l_int|105
comma
l_int|210
)brace
comma
(brace
l_int|90
comma
l_int|90
comma
l_int|180
)brace
comma
(brace
l_int|90
comma
l_int|75
comma
l_int|165
)brace
comma
(brace
l_int|75
comma
l_int|45
comma
l_int|120
)brace
comma
(brace
l_int|0
comma
l_int|0
comma
l_int|0
)brace
)brace
suffix:semicolon
multiline_comment|/* Ultra DMA timings (rounded) */
r_struct
(brace
DECL|member|addrSetup
r_int
id|addrSetup
suffix:semicolon
multiline_comment|/* ??? */
DECL|member|rdy2pause
r_int
id|rdy2pause
suffix:semicolon
DECL|member|wrDataSetup
r_int
id|wrDataSetup
suffix:semicolon
DECL|variable|__pmacdata
)brace
id|udma_timings
(braket
)braket
id|__pmacdata
op_assign
(brace
(brace
l_int|0
comma
l_int|180
comma
l_int|120
)brace
comma
multiline_comment|/* Mode 0 */
(brace
l_int|0
comma
l_int|150
comma
l_int|90
)brace
comma
multiline_comment|/*      1 */
(brace
l_int|0
comma
l_int|120
comma
l_int|60
)brace
comma
multiline_comment|/*      2 */
(brace
l_int|0
comma
l_int|90
comma
l_int|45
)brace
comma
multiline_comment|/*      3 */
(brace
l_int|0
comma
l_int|90
comma
l_int|30
)brace
multiline_comment|/*      4 */
)brace
suffix:semicolon
multiline_comment|/* allow up to 256 DBDMA commands per xfer */
DECL|macro|MAX_DCMDS
mdefine_line|#define MAX_DCMDS&t;&t;256
multiline_comment|/* Wait 2s for disk to answer on IDE bus after&n; * enable operation.&n; * NOTE: There is at least one case I know of a disk that needs about 10sec&n; *       before anwering on the bus. I beleive we could add a kernel command&n; *       line arg to override this delay for such cases.&n; */
DECL|macro|IDE_WAKEUP_DELAY_MS
mdefine_line|#define IDE_WAKEUP_DELAY_MS&t;2000
r_static
r_void
id|pmac_ide_setup_dma
c_func
(paren
r_struct
id|device_node
op_star
id|np
comma
r_int
id|ix
)paren
suffix:semicolon
r_static
r_void
id|pmac_udma_enable
c_func
(paren
r_struct
id|ata_device
op_star
id|drive
comma
r_int
id|on
comma
r_int
id|verbose
)paren
suffix:semicolon
r_static
r_int
id|pmac_udma_start
c_func
(paren
r_struct
id|ata_device
op_star
id|drive
comma
r_struct
id|request
op_star
id|rq
)paren
suffix:semicolon
r_static
r_int
id|pmac_udma_stop
c_func
(paren
r_struct
id|ata_device
op_star
id|drive
)paren
suffix:semicolon
r_static
r_int
id|pmac_udma_init
c_func
(paren
r_struct
id|ata_device
op_star
id|drive
comma
r_struct
id|request
op_star
id|rq
)paren
suffix:semicolon
r_static
r_int
id|pmac_udma_irq_status
c_func
(paren
r_struct
id|ata_device
op_star
id|drive
)paren
suffix:semicolon
r_static
r_int
id|pmac_udma_setup
c_func
(paren
r_struct
id|ata_device
op_star
id|drive
)paren
suffix:semicolon
r_static
r_int
id|pmac_ide_build_dmatable
c_func
(paren
r_struct
id|ata_device
op_star
id|drive
comma
r_struct
id|request
op_star
id|rq
comma
r_int
id|ix
comma
r_int
id|wr
)paren
suffix:semicolon
r_static
r_int
id|pmac_ide_tune_chipset
c_func
(paren
r_struct
id|ata_device
op_star
id|drive
comma
id|byte
id|speed
)paren
suffix:semicolon
r_static
r_void
id|pmac_ide_tuneproc
c_func
(paren
r_struct
id|ata_device
op_star
id|drive
comma
id|byte
id|pio
)paren
suffix:semicolon
r_static
r_void
id|pmac_ide_selectproc
c_func
(paren
r_struct
id|ata_device
op_star
id|drive
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_BLK_DEV_IDEDMA_PMAC */
macro_line|#ifdef CONFIG_PMAC_PBOOK
r_static
r_int
id|idepmac_notify_sleep
c_func
(paren
r_struct
id|pmu_sleep_notifier
op_star
id|self
comma
r_int
id|when
)paren
suffix:semicolon
DECL|variable|idepmac_sleep_notifier
r_struct
id|pmu_sleep_notifier
id|idepmac_sleep_notifier
op_assign
(brace
id|idepmac_notify_sleep
comma
id|SLEEP_LEVEL_BLOCK
comma
)brace
suffix:semicolon
macro_line|#endif /* CONFIG_PMAC_PBOOK */
r_static
r_int
id|__pmac
DECL|function|pmac_ide_find
id|pmac_ide_find
c_func
(paren
r_struct
id|ata_device
op_star
id|drive
)paren
(brace
r_struct
id|ata_channel
op_star
id|hwif
op_assign
id|drive-&gt;channel
suffix:semicolon
id|ide_ioreg_t
id|base
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|pmac_ide_count
suffix:semicolon
id|i
op_increment
)paren
(brace
id|base
op_assign
id|pmac_ide
(braket
id|i
)braket
dot
id|regbase
suffix:semicolon
r_if
c_cond
(paren
id|base
op_logical_and
id|base
op_eq
id|hwif-&gt;io_ports
(braket
l_int|0
)braket
)paren
r_return
id|i
suffix:semicolon
)brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * N.B. this can&squot;t be an initfunc, because the media-bay task can&n; * call ide_[un]register at any time.&n; */
r_void
id|__pmac
DECL|function|pmac_ide_init_hwif_ports
id|pmac_ide_init_hwif_ports
c_func
(paren
id|hw_regs_t
op_star
id|hw
comma
id|ide_ioreg_t
id|data_port
comma
id|ide_ioreg_t
id|ctrl_port
comma
r_int
op_star
id|irq
)paren
(brace
r_int
id|i
comma
id|ix
suffix:semicolon
r_if
c_cond
(paren
id|data_port
op_eq
l_int|0
)paren
r_return
suffix:semicolon
r_for
c_loop
(paren
id|ix
op_assign
l_int|0
suffix:semicolon
id|ix
OL
id|MAX_HWIFS
suffix:semicolon
op_increment
id|ix
)paren
r_if
c_cond
(paren
id|data_port
op_eq
id|pmac_ide
(braket
id|ix
)braket
dot
id|regbase
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|ix
op_ge
id|MAX_HWIFS
)paren
(brace
multiline_comment|/* Probably a PCI interface... */
r_for
c_loop
(paren
id|i
op_assign
id|IDE_DATA_OFFSET
suffix:semicolon
id|i
op_le
id|IDE_STATUS_OFFSET
suffix:semicolon
op_increment
id|i
)paren
id|hw-&gt;io_ports
(braket
id|i
)braket
op_assign
id|data_port
op_plus
id|i
op_minus
id|IDE_DATA_OFFSET
suffix:semicolon
id|hw-&gt;io_ports
(braket
id|IDE_CONTROL_OFFSET
)braket
op_assign
id|ctrl_port
suffix:semicolon
r_return
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
op_increment
id|i
)paren
id|hw-&gt;io_ports
(braket
id|i
)braket
op_assign
id|data_port
op_plus
id|i
op_star
l_int|0x10
suffix:semicolon
id|hw-&gt;io_ports
(braket
l_int|8
)braket
op_assign
id|data_port
op_plus
l_int|0x160
suffix:semicolon
r_if
c_cond
(paren
id|irq
op_ne
l_int|NULL
)paren
op_star
id|irq
op_assign
id|pmac_ide
(braket
id|ix
)braket
dot
id|irq
suffix:semicolon
id|ide_hwifs
(braket
id|ix
)braket
dot
id|tuneproc
op_assign
id|pmac_ide_tuneproc
suffix:semicolon
id|ide_hwifs
(braket
id|ix
)braket
dot
id|selectproc
op_assign
id|pmac_ide_selectproc
suffix:semicolon
id|ide_hwifs
(braket
id|ix
)braket
dot
id|speedproc
op_assign
op_amp
id|pmac_ide_tune_chipset
suffix:semicolon
r_if
c_cond
(paren
id|pmac_ide
(braket
id|ix
)braket
dot
id|dma_regs
op_logical_and
id|pmac_ide
(braket
id|ix
)braket
dot
id|dma_table_cpu
)paren
(brace
id|ide_hwifs
(braket
id|ix
)braket
dot
id|udma_enable
op_assign
id|pmac_udma_enable
suffix:semicolon
id|ide_hwifs
(braket
id|ix
)braket
dot
id|udma_start
op_assign
id|pmac_udma_start
suffix:semicolon
id|ide_hwifs
(braket
id|ix
)braket
dot
id|udma_stop
op_assign
id|pmac_udma_stop
suffix:semicolon
id|ide_hwifs
(braket
id|ix
)braket
dot
id|udma_init
op_assign
id|pmac_udma_init
suffix:semicolon
id|ide_hwifs
(braket
id|ix
)braket
dot
id|udma_irq_status
op_assign
id|pmac_udma_irq_status
suffix:semicolon
id|ide_hwifs
(braket
id|ix
)braket
dot
id|udma_setup
op_assign
id|pmac_udma_setup
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_IDEDMA_PMAC_AUTO
r_if
c_cond
(paren
op_logical_neg
id|noautodma
)paren
id|ide_hwifs
(braket
id|ix
)braket
dot
id|autodma
op_assign
l_int|1
suffix:semicolon
macro_line|#endif
id|ide_hwifs
(braket
id|ix
)braket
dot
id|unmask
op_assign
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/* Setup timings for the selected drive (master/slave). I still need to verify if this&n; * is enough, I beleive selectproc will be called whenever an IDE command is started,&n; * but... */
r_static
r_void
id|__pmac
DECL|function|pmac_ide_selectproc
id|pmac_ide_selectproc
c_func
(paren
r_struct
id|ata_device
op_star
id|drive
)paren
(brace
r_int
id|i
op_assign
id|pmac_ide_find
c_func
(paren
id|drive
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
OL
l_int|0
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;select.b.unit
op_amp
l_int|0x01
)paren
id|out_le32
c_func
(paren
(paren
r_int
op_star
)paren
(paren
id|IDE_DATA_REG
op_plus
id|IDE_TIMING_CONFIG
op_plus
id|_IO_BASE
)paren
comma
id|pmac_ide
(braket
id|i
)braket
dot
id|timings
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_else
id|out_le32
c_func
(paren
(paren
r_int
op_star
)paren
(paren
id|IDE_DATA_REG
op_plus
id|IDE_TIMING_CONFIG
op_plus
id|_IO_BASE
)paren
comma
id|pmac_ide
(braket
id|i
)braket
dot
id|timings
(braket
l_int|0
)braket
)paren
suffix:semicolon
(paren
r_void
)paren
id|in_le32
c_func
(paren
(paren
r_int
op_star
)paren
(paren
id|IDE_DATA_REG
op_plus
id|IDE_TIMING_CONFIG
op_plus
id|_IO_BASE
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Note: We don&squot;t use the generic routine here because for some&n; * yet unexplained reasons, it cause some media-bay CD-ROMs to&n; * lockup the bus. Strangely, this new version of the code is&n; * almost identical to the generic one and works, I&squot;ve not yet&n; * managed to figure out what bit is causing the lockup in the&n; * generic code, possibly a timing issue...&n; *&n; * --BenH&n; */
r_static
r_int
id|__pmac
DECL|function|wait_for_ready
id|wait_for_ready
c_func
(paren
r_struct
id|ata_device
op_star
id|drive
)paren
(brace
multiline_comment|/* Timeout bumped for some powerbooks */
r_int
id|timeout
op_assign
l_int|2000
suffix:semicolon
r_while
c_loop
(paren
op_decrement
id|timeout
)paren
(brace
r_if
c_cond
(paren
id|ata_status
c_func
(paren
id|drive
comma
l_int|0
comma
id|BUSY_STAT
)paren
)paren
(brace
r_if
c_cond
(paren
id|drive-&gt;ready_stat
op_eq
l_int|0
)paren
r_break
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|drive-&gt;status
op_amp
id|drive-&gt;ready_stat
)paren
op_logical_or
(paren
id|drive-&gt;status
op_amp
id|ERR_STAT
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
id|mdelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|drive-&gt;status
op_amp
id|ERR_STAT
)paren
op_logical_or
id|timeout
op_le
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|drive-&gt;status
op_amp
id|ERR_STAT
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ide_pmac: wait_for_ready, error status: %x&bslash;n&quot;
comma
id|drive-&gt;status
)paren
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
id|__pmac
DECL|function|pmac_ide_do_setfeature
id|pmac_ide_do_setfeature
c_func
(paren
r_struct
id|ata_device
op_star
id|drive
comma
id|u8
id|command
)paren
(brace
r_int
id|result
op_assign
l_int|1
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|ata_channel
op_star
id|hwif
op_assign
id|drive-&gt;channel
suffix:semicolon
id|disable_irq
c_func
(paren
id|hwif-&gt;irq
)paren
suffix:semicolon
multiline_comment|/* disable_irq_nosync ?? */
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|ata_select
c_func
(paren
id|drive
comma
l_int|0
)paren
suffix:semicolon
id|ata_mask
c_func
(paren
id|drive
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|ata_status
c_func
(paren
id|drive
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Get rid of pending error state */
r_if
c_cond
(paren
id|wait_for_ready
c_func
(paren
id|drive
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;pmac_ide_do_setfeature disk not ready before SET_FEATURE!&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
id|ata_irq_enable
c_func
(paren
id|drive
comma
l_int|0
)paren
suffix:semicolon
id|OUT_BYTE
c_func
(paren
id|command
comma
id|IDE_NSECTOR_REG
)paren
suffix:semicolon
id|OUT_BYTE
c_func
(paren
id|SETFEATURES_XFER
comma
id|IDE_FEATURE_REG
)paren
suffix:semicolon
id|OUT_BYTE
c_func
(paren
id|WIN_SETFEATURES
comma
id|IDE_COMMAND_REG
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|__save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* local CPU only */
id|ide__sti
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* local CPU only -- for jiffies */
id|result
op_assign
id|wait_for_ready
c_func
(paren
id|drive
)paren
suffix:semicolon
id|__restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* local CPU only */
id|ata_irq_enable
c_func
(paren
id|drive
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;pmac_ide_do_setfeature disk not ready after SET_FEATURE !&bslash;n&quot;
)paren
suffix:semicolon
id|out
suffix:colon
id|ata_mask
c_func
(paren
id|drive
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_eq
l_int|0
)paren
(brace
id|drive-&gt;id-&gt;dma_ultra
op_and_assign
op_complement
l_int|0xFF00
suffix:semicolon
id|drive-&gt;id-&gt;dma_mword
op_and_assign
op_complement
l_int|0x0F00
suffix:semicolon
id|drive-&gt;id-&gt;dma_1word
op_and_assign
op_complement
l_int|0x0F00
suffix:semicolon
r_switch
c_cond
(paren
id|command
)paren
(brace
r_case
id|XFER_UDMA_7
suffix:colon
id|drive-&gt;id-&gt;dma_ultra
op_or_assign
l_int|0x8080
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XFER_UDMA_6
suffix:colon
id|drive-&gt;id-&gt;dma_ultra
op_or_assign
l_int|0x4040
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XFER_UDMA_5
suffix:colon
id|drive-&gt;id-&gt;dma_ultra
op_or_assign
l_int|0x2020
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XFER_UDMA_4
suffix:colon
id|drive-&gt;id-&gt;dma_ultra
op_or_assign
l_int|0x1010
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XFER_UDMA_3
suffix:colon
id|drive-&gt;id-&gt;dma_ultra
op_or_assign
l_int|0x0808
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XFER_UDMA_2
suffix:colon
id|drive-&gt;id-&gt;dma_ultra
op_or_assign
l_int|0x0404
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XFER_UDMA_1
suffix:colon
id|drive-&gt;id-&gt;dma_ultra
op_or_assign
l_int|0x0202
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XFER_UDMA_0
suffix:colon
id|drive-&gt;id-&gt;dma_ultra
op_or_assign
l_int|0x0101
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XFER_MW_DMA_2
suffix:colon
id|drive-&gt;id-&gt;dma_mword
op_or_assign
l_int|0x0404
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XFER_MW_DMA_1
suffix:colon
id|drive-&gt;id-&gt;dma_mword
op_or_assign
l_int|0x0202
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XFER_MW_DMA_0
suffix:colon
id|drive-&gt;id-&gt;dma_mword
op_or_assign
l_int|0x0101
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XFER_SW_DMA_2
suffix:colon
id|drive-&gt;id-&gt;dma_1word
op_or_assign
l_int|0x0404
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XFER_SW_DMA_1
suffix:colon
id|drive-&gt;id-&gt;dma_1word
op_or_assign
l_int|0x0202
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XFER_SW_DMA_0
suffix:colon
id|drive-&gt;id-&gt;dma_1word
op_or_assign
l_int|0x0101
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
)brace
id|enable_irq
c_func
(paren
id|hwif-&gt;irq
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/* Calculate PIO timings */
r_static
r_void
id|__pmac
DECL|function|pmac_ide_tuneproc
id|pmac_ide_tuneproc
c_func
(paren
r_struct
id|ata_device
op_star
id|drive
comma
id|byte
id|pio
)paren
(brace
r_struct
id|ata_timing
op_star
id|t
suffix:semicolon
r_int
id|i
suffix:semicolon
id|u32
op_star
id|timings
suffix:semicolon
r_int
id|accessTicks
comma
id|recTicks
suffix:semicolon
r_int
id|accessTime
comma
id|recTime
suffix:semicolon
id|i
op_assign
id|pmac_ide_find
c_func
(paren
id|drive
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
OL
l_int|0
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|pio
op_eq
l_int|255
)paren
id|pio
op_assign
id|ata_timing_mode
c_func
(paren
id|drive
comma
id|XFER_PIO
op_or
id|XFER_EPIO
)paren
suffix:semicolon
r_else
id|pio
op_assign
id|XFER_PIO_0
op_plus
id|min_t
c_func
(paren
id|byte
comma
id|pio
comma
l_int|4
)paren
suffix:semicolon
id|t
op_assign
id|ata_timing_data
c_func
(paren
id|pio
)paren
suffix:semicolon
id|accessTicks
op_assign
id|SYSCLK_TICKS
c_func
(paren
id|t-&gt;active
)paren
suffix:semicolon
id|timings
op_assign
op_amp
id|pmac_ide
(braket
id|i
)braket
dot
id|timings
(braket
id|drive-&gt;select.b.unit
op_amp
l_int|0x01
)braket
suffix:semicolon
id|recTime
op_assign
id|t-&gt;cycle
op_minus
id|t-&gt;active
op_minus
id|t-&gt;setup
suffix:semicolon
id|recTime
op_assign
id|max
c_func
(paren
id|recTime
comma
l_int|150U
)paren
suffix:semicolon
id|accessTime
op_assign
id|t-&gt;active
suffix:semicolon
id|accessTime
op_assign
id|max
c_func
(paren
id|accessTime
comma
l_int|150U
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pmac_ide
(braket
id|i
)braket
dot
id|kind
op_eq
id|controller_kl_ata4
op_logical_or
id|pmac_ide
(braket
id|i
)braket
dot
id|kind
op_eq
id|controller_kl_ata4_80
)paren
(brace
multiline_comment|/* 66Mhz cell */
id|accessTicks
op_assign
id|SYSCLK_TICKS_66
c_func
(paren
id|accessTime
)paren
suffix:semicolon
id|accessTicks
op_assign
id|min
c_func
(paren
id|accessTicks
comma
l_int|0x1fU
)paren
suffix:semicolon
id|recTicks
op_assign
id|SYSCLK_TICKS_66
c_func
(paren
id|recTime
)paren
suffix:semicolon
id|recTicks
op_assign
id|min
c_func
(paren
id|recTicks
comma
l_int|0x1fU
)paren
suffix:semicolon
op_star
id|timings
op_assign
(paren
(paren
op_star
id|timings
)paren
op_amp
op_complement
id|TR_66_PIO_MASK
)paren
op_or
(paren
id|accessTicks
op_lshift
id|TR_66_PIO_ACCESS_SHIFT
)paren
op_or
(paren
id|recTicks
op_lshift
id|TR_66_PIO_RECOVERY_SHIFT
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* 33Mhz cell */
r_int
id|ebit
op_assign
l_int|0
suffix:semicolon
id|accessTicks
op_assign
id|SYSCLK_TICKS
c_func
(paren
id|accessTime
)paren
suffix:semicolon
id|accessTicks
op_assign
id|min
c_func
(paren
id|accessTicks
comma
l_int|0x1fU
)paren
suffix:semicolon
id|accessTicks
op_assign
id|max
c_func
(paren
id|accessTicks
comma
l_int|4U
)paren
suffix:semicolon
id|recTicks
op_assign
id|SYSCLK_TICKS
c_func
(paren
id|recTime
)paren
suffix:semicolon
id|recTicks
op_assign
id|min
c_func
(paren
id|recTicks
comma
l_int|0x1fU
)paren
suffix:semicolon
id|recTicks
op_assign
id|max
c_func
(paren
id|recTicks
comma
l_int|5U
)paren
op_minus
l_int|4
suffix:semicolon
r_if
c_cond
(paren
id|recTicks
OG
l_int|9
)paren
(brace
id|recTicks
op_decrement
suffix:semicolon
multiline_comment|/* guess, but it&squot;s only for PIO0, so... */
id|ebit
op_assign
l_int|1
suffix:semicolon
)brace
op_star
id|timings
op_assign
(paren
(paren
op_star
id|timings
)paren
op_amp
op_complement
id|TR_33_PIO_MASK
)paren
op_or
(paren
id|accessTicks
op_lshift
id|TR_33_PIO_ACCESS_SHIFT
)paren
op_or
(paren
id|recTicks
op_lshift
id|TR_33_PIO_RECOVERY_SHIFT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ebit
)paren
op_star
id|timings
op_or_assign
id|TR_33_PIO_E
suffix:semicolon
)brace
macro_line|#ifdef IDE_PMAC_DEBUG
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ide_pmac: Set PIO timing for mode %d, reg: 0x%08x&bslash;n&quot;
comma
id|pio
comma
op_star
id|timings
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|drive-&gt;select.all
op_eq
id|IN_BYTE
c_func
(paren
id|IDE_SELECT_REG
)paren
)paren
id|pmac_ide_selectproc
c_func
(paren
id|drive
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_BLK_DEV_IDEDMA_PMAC
r_static
r_int
id|__pmac
DECL|function|set_timings_udma
id|set_timings_udma
c_func
(paren
id|u32
op_star
id|timings
comma
id|byte
id|speed
)paren
(brace
r_int
id|rdyToPauseTicks
comma
id|wrDataSetupTicks
comma
id|addrTicks
suffix:semicolon
id|rdyToPauseTicks
op_assign
id|SYSCLK_TICKS_66
c_func
(paren
id|udma_timings
(braket
id|speed
op_amp
l_int|0xf
)braket
dot
id|rdy2pause
)paren
suffix:semicolon
id|wrDataSetupTicks
op_assign
id|SYSCLK_TICKS_66
c_func
(paren
id|udma_timings
(braket
id|speed
op_amp
l_int|0xf
)braket
dot
id|wrDataSetup
)paren
suffix:semicolon
id|addrTicks
op_assign
id|SYSCLK_TICKS_66
c_func
(paren
id|udma_timings
(braket
id|speed
op_amp
l_int|0xf
)braket
dot
id|addrSetup
)paren
suffix:semicolon
op_star
id|timings
op_assign
(paren
(paren
op_star
id|timings
)paren
op_amp
op_complement
(paren
id|TR_66_UDMA_MASK
op_or
id|TR_66_MDMA_MASK
)paren
)paren
op_or
(paren
id|wrDataSetupTicks
op_lshift
id|TR_66_UDMA_WRDATASETUP_SHIFT
)paren
op_or
(paren
id|rdyToPauseTicks
op_lshift
id|TR_66_UDMA_RDY2PAUS_SHIFT
)paren
op_or
(paren
id|addrTicks
op_lshift
id|TR_66_UDMA_ADDRSETUP_SHIFT
)paren
op_or
id|TR_66_UDMA_EN
suffix:semicolon
macro_line|#ifdef IDE_PMAC_DEBUG
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ide_pmac: Set UDMA timing for mode %d, reg: 0x%08x&bslash;n&quot;
comma
id|speed
op_amp
l_int|0xf
comma
op_star
id|timings
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
id|__pmac
DECL|function|set_timings_mdma
id|set_timings_mdma
c_func
(paren
r_int
id|intf_type
comma
id|u32
op_star
id|timings
comma
id|byte
id|speed
comma
r_int
id|drive_cycle_time
)paren
(brace
r_int
id|cycleTime
comma
id|accessTime
comma
id|recTime
suffix:semicolon
r_int
id|accessTicks
comma
id|recTicks
suffix:semicolon
r_struct
id|mdma_timings_t
op_star
id|tm
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/* Get default cycle time for mode */
r_switch
c_cond
(paren
id|speed
op_amp
l_int|0xf
)paren
(brace
r_case
l_int|0
suffix:colon
id|cycleTime
op_assign
l_int|480
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|cycleTime
op_assign
l_int|150
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|cycleTime
op_assign
l_int|120
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Adjust for drive */
r_if
c_cond
(paren
id|drive_cycle_time
op_logical_and
id|drive_cycle_time
OG
id|cycleTime
)paren
id|cycleTime
op_assign
id|drive_cycle_time
suffix:semicolon
multiline_comment|/* OHare limits according to some old Apple sources */
r_if
c_cond
(paren
(paren
id|intf_type
op_eq
id|controller_ohare
)paren
op_logical_and
(paren
id|cycleTime
OL
l_int|150
)paren
)paren
id|cycleTime
op_assign
l_int|150
suffix:semicolon
multiline_comment|/* Get the proper timing array for this controller */
r_switch
c_cond
(paren
id|intf_type
)paren
(brace
r_case
id|controller_kl_ata4
suffix:colon
r_case
id|controller_kl_ata4_80
suffix:colon
id|tm
op_assign
id|mdma_timings_66
suffix:semicolon
r_break
suffix:semicolon
r_case
id|controller_kl_ata3
suffix:colon
id|tm
op_assign
id|mdma_timings_33k
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|tm
op_assign
id|mdma_timings_33
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Lookup matching access &amp; recovery times */
id|i
op_assign
op_minus
l_int|1
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
id|tm
(braket
id|i
op_plus
l_int|1
)braket
dot
id|cycleTime
OL
id|cycleTime
)paren
r_break
suffix:semicolon
id|i
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
OL
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|cycleTime
op_assign
id|tm
(braket
id|i
)braket
dot
id|cycleTime
suffix:semicolon
id|accessTime
op_assign
id|tm
(braket
id|i
)braket
dot
id|accessTime
suffix:semicolon
id|recTime
op_assign
id|tm
(braket
id|i
)braket
dot
id|recoveryTime
suffix:semicolon
macro_line|#ifdef IDE_PMAC_DEBUG
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ide_pmac: MDMA, cycleTime: %d, accessTime: %d, recTime: %d&bslash;n&quot;
comma
id|cycleTime
comma
id|accessTime
comma
id|recTime
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|intf_type
op_eq
id|controller_kl_ata4
op_logical_or
id|intf_type
op_eq
id|controller_kl_ata4_80
)paren
(brace
multiline_comment|/* 66Mhz cell */
id|accessTicks
op_assign
id|SYSCLK_TICKS_66
c_func
(paren
id|accessTime
)paren
suffix:semicolon
id|accessTicks
op_assign
id|min
c_func
(paren
id|accessTicks
comma
l_int|0x1fU
)paren
suffix:semicolon
id|accessTicks
op_assign
id|max
c_func
(paren
id|accessTicks
comma
l_int|0x1U
)paren
suffix:semicolon
id|recTicks
op_assign
id|SYSCLK_TICKS_66
c_func
(paren
id|recTime
)paren
suffix:semicolon
id|recTicks
op_assign
id|min
c_func
(paren
id|recTicks
comma
l_int|0x1fU
)paren
suffix:semicolon
id|recTicks
op_assign
id|max
c_func
(paren
id|recTicks
comma
l_int|0x3U
)paren
suffix:semicolon
multiline_comment|/* Clear out mdma bits and disable udma */
op_star
id|timings
op_assign
(paren
(paren
op_star
id|timings
)paren
op_amp
op_complement
(paren
id|TR_66_MDMA_MASK
op_or
id|TR_66_UDMA_MASK
)paren
)paren
op_or
(paren
id|accessTicks
op_lshift
id|TR_66_MDMA_ACCESS_SHIFT
)paren
op_or
(paren
id|recTicks
op_lshift
id|TR_66_MDMA_RECOVERY_SHIFT
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|intf_type
op_eq
id|controller_kl_ata3
)paren
(brace
multiline_comment|/* 33Mhz cell on KeyLargo */
id|accessTicks
op_assign
id|SYSCLK_TICKS
c_func
(paren
id|accessTime
)paren
suffix:semicolon
id|accessTicks
op_assign
id|max
c_func
(paren
id|accessTicks
comma
l_int|1U
)paren
suffix:semicolon
id|accessTicks
op_assign
id|min
c_func
(paren
id|accessTicks
comma
l_int|0x1fU
)paren
suffix:semicolon
id|accessTime
op_assign
id|accessTicks
op_star
id|IDE_SYSCLK_NS
suffix:semicolon
id|recTicks
op_assign
id|SYSCLK_TICKS
c_func
(paren
id|recTime
)paren
suffix:semicolon
id|recTicks
op_assign
id|max
c_func
(paren
id|recTicks
comma
l_int|1U
)paren
suffix:semicolon
id|recTicks
op_assign
id|min
c_func
(paren
id|recTicks
comma
l_int|0x1fU
)paren
suffix:semicolon
op_star
id|timings
op_assign
(paren
(paren
op_star
id|timings
)paren
op_amp
op_complement
id|TR_33_MDMA_MASK
)paren
op_or
(paren
id|accessTicks
op_lshift
id|TR_33_MDMA_ACCESS_SHIFT
)paren
op_or
(paren
id|recTicks
op_lshift
id|TR_33_MDMA_RECOVERY_SHIFT
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* 33Mhz cell on others */
r_int
id|halfTick
op_assign
l_int|0
suffix:semicolon
r_int
id|origAccessTime
op_assign
id|accessTime
suffix:semicolon
r_int
id|origRecTime
op_assign
id|recTime
suffix:semicolon
id|accessTicks
op_assign
id|SYSCLK_TICKS
c_func
(paren
id|accessTime
)paren
suffix:semicolon
id|accessTicks
op_assign
id|max
c_func
(paren
id|accessTicks
comma
l_int|1U
)paren
suffix:semicolon
id|accessTicks
op_assign
id|min
c_func
(paren
id|accessTicks
comma
l_int|0x1fU
)paren
suffix:semicolon
id|accessTime
op_assign
id|accessTicks
op_star
id|IDE_SYSCLK_NS
suffix:semicolon
id|recTicks
op_assign
id|SYSCLK_TICKS
c_func
(paren
id|recTime
)paren
suffix:semicolon
id|recTicks
op_assign
id|max
c_func
(paren
id|recTicks
comma
l_int|2U
)paren
op_minus
l_int|1
suffix:semicolon
id|recTicks
op_assign
id|min
c_func
(paren
id|recTicks
comma
l_int|0x1fU
)paren
suffix:semicolon
id|recTime
op_assign
(paren
id|recTicks
op_plus
l_int|1
)paren
op_star
id|IDE_SYSCLK_NS
suffix:semicolon
r_if
c_cond
(paren
(paren
id|accessTicks
OG
l_int|1
)paren
op_logical_and
(paren
(paren
id|accessTime
op_minus
id|IDE_SYSCLK_NS
op_div
l_int|2
)paren
op_ge
id|origAccessTime
)paren
op_logical_and
(paren
(paren
id|recTime
op_minus
id|IDE_SYSCLK_NS
op_div
l_int|2
)paren
op_ge
id|origRecTime
)paren
)paren
(brace
id|halfTick
op_assign
l_int|1
suffix:semicolon
id|accessTicks
op_decrement
suffix:semicolon
)brace
op_star
id|timings
op_assign
(paren
(paren
op_star
id|timings
)paren
op_amp
op_complement
id|TR_33_MDMA_MASK
)paren
op_or
(paren
id|accessTicks
op_lshift
id|TR_33_MDMA_ACCESS_SHIFT
)paren
op_or
(paren
id|recTicks
op_lshift
id|TR_33_MDMA_RECOVERY_SHIFT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|halfTick
)paren
op_star
id|timings
op_or_assign
id|TR_33_MDMA_HALFTICK
suffix:semicolon
)brace
macro_line|# ifdef IDE_PMAC_DEBUG
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ide_pmac: Set MDMA timing for mode %d, reg: 0x%08x&bslash;n&quot;
comma
id|speed
op_amp
l_int|0xf
comma
op_star
id|timings
)paren
suffix:semicolon
macro_line|# endif
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* You may notice we don&squot;t use this function on normal operation,&n; * our, normal mdma function is supposed to be more precise&n; */
r_static
r_int
id|__pmac
DECL|function|pmac_ide_tune_chipset
id|pmac_ide_tune_chipset
(paren
r_struct
id|ata_device
op_star
id|drive
comma
id|byte
id|speed
)paren
(brace
r_int
id|intf
op_assign
id|pmac_ide_find
c_func
(paren
id|drive
)paren
suffix:semicolon
r_int
id|unit
op_assign
(paren
id|drive-&gt;select.b.unit
op_amp
l_int|0x01
)paren
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|u32
op_star
id|timings
suffix:semicolon
r_if
c_cond
(paren
id|intf
OL
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
id|timings
op_assign
op_amp
id|pmac_ide
(braket
id|intf
)braket
dot
id|timings
(braket
id|unit
)braket
suffix:semicolon
r_switch
c_cond
(paren
id|speed
)paren
(brace
macro_line|#ifdef CONFIG_BLK_DEV_IDEDMA_PMAC
r_case
id|XFER_UDMA_4
suffix:colon
r_case
id|XFER_UDMA_3
suffix:colon
r_if
c_cond
(paren
id|pmac_ide
(braket
id|intf
)braket
dot
id|kind
op_ne
id|controller_kl_ata4_80
)paren
r_return
l_int|1
suffix:semicolon
r_case
id|XFER_UDMA_2
suffix:colon
r_case
id|XFER_UDMA_1
suffix:colon
r_case
id|XFER_UDMA_0
suffix:colon
r_if
c_cond
(paren
id|pmac_ide
(braket
id|intf
)braket
dot
id|kind
op_ne
id|controller_kl_ata4
op_logical_and
id|pmac_ide
(braket
id|intf
)braket
dot
id|kind
op_ne
id|controller_kl_ata4_80
)paren
r_return
l_int|1
suffix:semicolon
id|ret
op_assign
id|set_timings_udma
c_func
(paren
id|timings
comma
id|speed
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XFER_MW_DMA_2
suffix:colon
r_case
id|XFER_MW_DMA_1
suffix:colon
r_case
id|XFER_MW_DMA_0
suffix:colon
id|ret
op_assign
id|set_timings_mdma
c_func
(paren
id|pmac_ide
(braket
id|intf
)braket
dot
id|kind
comma
id|timings
comma
id|speed
comma
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XFER_SW_DMA_2
suffix:colon
r_case
id|XFER_SW_DMA_1
suffix:colon
r_case
id|XFER_SW_DMA_0
suffix:colon
r_return
l_int|1
suffix:semicolon
macro_line|#endif
r_case
id|XFER_PIO_4
suffix:colon
r_case
id|XFER_PIO_3
suffix:colon
r_case
id|XFER_PIO_2
suffix:colon
r_case
id|XFER_PIO_1
suffix:colon
r_case
id|XFER_PIO_0
suffix:colon
id|pmac_ide_tuneproc
c_func
(paren
id|drive
comma
id|speed
op_amp
l_int|0x07
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|ret
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ret
)paren
r_return
id|ret
suffix:semicolon
id|ret
op_assign
id|pmac_ide_do_setfeature
c_func
(paren
id|drive
comma
id|speed
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_return
id|ret
suffix:semicolon
id|pmac_ide_selectproc
c_func
(paren
id|drive
)paren
suffix:semicolon
id|drive-&gt;current_speed
op_assign
id|speed
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_void
id|__pmac
DECL|function|sanitize_timings
id|sanitize_timings
c_func
(paren
r_int
id|i
)paren
(brace
r_int
id|value
suffix:semicolon
r_switch
c_cond
(paren
id|pmac_ide
(braket
id|i
)braket
dot
id|kind
)paren
(brace
r_case
id|controller_kl_ata4
suffix:colon
r_case
id|controller_kl_ata4_80
suffix:colon
id|value
op_assign
l_int|0x0008438c
suffix:semicolon
r_break
suffix:semicolon
r_case
id|controller_kl_ata3
suffix:colon
id|value
op_assign
l_int|0x00084526
suffix:semicolon
r_break
suffix:semicolon
r_case
id|controller_heathrow
suffix:colon
r_case
id|controller_ohare
suffix:colon
r_default
suffix:colon
id|value
op_assign
l_int|0x00074526
suffix:semicolon
r_break
suffix:semicolon
)brace
id|pmac_ide
(braket
id|i
)braket
dot
id|timings
(braket
l_int|0
)braket
op_assign
id|pmac_ide
(braket
id|i
)braket
dot
id|timings
(braket
l_int|1
)braket
op_assign
id|value
suffix:semicolon
)brace
id|ide_ioreg_t
id|__pmac
DECL|function|pmac_ide_get_base
id|pmac_ide_get_base
c_func
(paren
r_int
id|index
)paren
(brace
r_return
id|pmac_ide
(braket
id|index
)braket
dot
id|regbase
suffix:semicolon
)brace
r_int
id|__pmac
DECL|function|pmac_ide_check_base
id|pmac_ide_check_base
c_func
(paren
id|ide_ioreg_t
id|base
)paren
(brace
r_int
id|ix
suffix:semicolon
r_for
c_loop
(paren
id|ix
op_assign
l_int|0
suffix:semicolon
id|ix
OL
id|MAX_HWIFS
suffix:semicolon
op_increment
id|ix
)paren
r_if
c_cond
(paren
id|base
op_eq
id|pmac_ide
(braket
id|ix
)braket
dot
id|regbase
)paren
r_return
id|ix
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_int
id|__pmac
DECL|function|pmac_ide_get_irq
id|pmac_ide_get_irq
c_func
(paren
id|ide_ioreg_t
id|base
)paren
(brace
r_int
id|ix
suffix:semicolon
r_for
c_loop
(paren
id|ix
op_assign
l_int|0
suffix:semicolon
id|ix
OL
id|MAX_HWIFS
suffix:semicolon
op_increment
id|ix
)paren
r_if
c_cond
(paren
id|base
op_eq
id|pmac_ide
(braket
id|ix
)braket
dot
id|regbase
)paren
r_return
id|pmac_ide
(braket
id|ix
)braket
dot
id|irq
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|__pmacdata
r_static
r_int
id|ide_majors
(braket
)braket
id|__pmacdata
op_assign
(brace
l_int|3
comma
l_int|22
comma
l_int|33
comma
l_int|34
comma
l_int|56
comma
l_int|57
)brace
suffix:semicolon
id|kdev_t
id|__init
DECL|function|pmac_find_ide_boot
id|pmac_find_ide_boot
c_func
(paren
r_char
op_star
id|bootdevice
comma
r_int
id|n
)paren
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;&t; * Look through the list of IDE interfaces for this one.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|pmac_ide_count
suffix:semicolon
op_increment
id|i
)paren
(brace
r_char
op_star
id|name
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pmac_ide
(braket
id|i
)braket
dot
id|node
op_logical_or
op_logical_neg
id|pmac_ide
(braket
id|i
)braket
dot
id|node-&gt;full_name
)paren
r_continue
suffix:semicolon
id|name
op_assign
id|pmac_ide
(braket
id|i
)braket
dot
id|node-&gt;full_name
suffix:semicolon
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|name
comma
id|bootdevice
comma
id|n
)paren
op_eq
l_int|0
op_logical_and
id|name
(braket
id|n
)braket
op_eq
l_int|0
)paren
(brace
multiline_comment|/* XXX should cope with the 2nd drive as well... */
r_return
id|mk_kdev
c_func
(paren
id|ide_majors
(braket
id|i
)braket
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
r_return
id|NODEV
suffix:semicolon
)brace
r_void
id|__init
DECL|function|pmac_ide_probe
id|pmac_ide_probe
c_func
(paren
r_void
)paren
(brace
r_struct
id|device_node
op_star
id|np
suffix:semicolon
r_int
id|i
suffix:semicolon
r_struct
id|device_node
op_star
id|atas
suffix:semicolon
r_struct
id|device_node
op_star
id|p
comma
op_star
op_star
id|pp
comma
op_star
id|removables
comma
op_star
op_star
id|rp
suffix:semicolon
r_int
r_int
id|base
suffix:semicolon
r_int
id|irq
comma
id|big_delay
suffix:semicolon
r_struct
id|ata_channel
op_star
id|hwif
suffix:semicolon
r_if
c_cond
(paren
id|_machine
op_ne
id|_MACH_Pmac
)paren
r_return
suffix:semicolon
id|pp
op_assign
op_amp
id|atas
suffix:semicolon
id|rp
op_assign
op_amp
id|removables
suffix:semicolon
id|p
op_assign
id|find_devices
c_func
(paren
l_string|&quot;ATA&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
op_eq
l_int|NULL
)paren
id|p
op_assign
id|find_devices
c_func
(paren
l_string|&quot;IDE&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
op_eq
l_int|NULL
)paren
id|p
op_assign
id|find_type_devices
c_func
(paren
l_string|&quot;ide&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
op_eq
l_int|NULL
)paren
id|p
op_assign
id|find_type_devices
c_func
(paren
l_string|&quot;ata&quot;
)paren
suffix:semicolon
multiline_comment|/* Move removable devices such as the media-bay CDROM&n;&t;   on the PB3400 to the end of the list. */
r_for
c_loop
(paren
suffix:semicolon
id|p
op_ne
l_int|NULL
suffix:semicolon
id|p
op_assign
id|p-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;parent
op_logical_and
id|p-&gt;parent-&gt;type
op_logical_and
id|strcasecmp
c_func
(paren
id|p-&gt;parent-&gt;type
comma
l_string|&quot;media-bay&quot;
)paren
op_eq
l_int|0
)paren
(brace
op_star
id|rp
op_assign
id|p
suffix:semicolon
id|rp
op_assign
op_amp
id|p-&gt;next
suffix:semicolon
)brace
r_else
(brace
op_star
id|pp
op_assign
id|p
suffix:semicolon
id|pp
op_assign
op_amp
id|p-&gt;next
suffix:semicolon
)brace
)brace
op_star
id|rp
op_assign
l_int|NULL
suffix:semicolon
op_star
id|pp
op_assign
id|removables
suffix:semicolon
id|big_delay
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|np
op_assign
id|atas
suffix:semicolon
id|i
OL
id|MAX_HWIFS
op_logical_and
id|np
op_ne
l_int|NULL
suffix:semicolon
id|np
op_assign
id|np-&gt;next
)paren
(brace
r_struct
id|device_node
op_star
id|tp
suffix:semicolon
r_struct
id|pmac_ide_hwif
op_star
id|pmif
suffix:semicolon
r_int
op_star
id|bidp
suffix:semicolon
r_int
id|in_bay
op_assign
l_int|0
suffix:semicolon
id|u8
id|pbus
comma
id|pid
suffix:semicolon
r_struct
id|pci_dev
op_star
id|pdev
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If this node is not under a mac-io or dbdma node,&n;&t;&t; * leave it to the generic PCI driver.&n;&t;&t; */
r_for
c_loop
(paren
id|tp
op_assign
id|np-&gt;parent
suffix:semicolon
id|tp
op_ne
l_int|0
suffix:semicolon
id|tp
op_assign
id|tp-&gt;parent
)paren
r_if
c_cond
(paren
id|tp-&gt;type
op_logical_and
(paren
id|strcmp
c_func
(paren
id|tp-&gt;type
comma
l_string|&quot;mac-io&quot;
)paren
op_eq
l_int|0
op_logical_or
id|strcmp
c_func
(paren
id|tp-&gt;type
comma
l_string|&quot;dbdma&quot;
)paren
op_eq
l_int|0
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|tp
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|np-&gt;n_addrs
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;ide: no address for device %s&bslash;n&quot;
comma
id|np-&gt;full_name
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* We need to find the pci_dev of the mac-io holding the&n;&t;&t; * IDE interface&n;&t;&t; */
r_if
c_cond
(paren
id|pci_device_from_OF_node
c_func
(paren
id|tp
comma
op_amp
id|pbus
comma
op_amp
id|pid
)paren
op_eq
l_int|0
)paren
id|pdev
op_assign
id|pci_find_slot
c_func
(paren
id|pbus
comma
id|pid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pdev
op_eq
l_int|NULL
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;ide: no PCI host for device %s, DMA disabled&bslash;n&quot;
comma
id|np-&gt;full_name
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If this slot is taken (e.g. by ide-pci.c) try the next one.&n;&t;&t; */
r_while
c_loop
(paren
id|i
OL
id|MAX_HWIFS
op_logical_and
id|ide_hwifs
(braket
id|i
)braket
dot
id|io_ports
(braket
id|IDE_DATA_OFFSET
)braket
op_ne
l_int|0
)paren
op_increment
id|i
suffix:semicolon
r_if
c_cond
(paren
id|i
op_ge
id|MAX_HWIFS
)paren
r_break
suffix:semicolon
id|pmif
op_assign
op_amp
id|pmac_ide
(braket
id|i
)braket
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Some older OFs have bogus sizes, causing request_OF_resource&n;&t;&t; * to fail. We fix them up here&n;&t;&t; */
r_if
c_cond
(paren
id|np-&gt;addrs
(braket
l_int|0
)braket
dot
id|size
OG
l_int|0x1000
)paren
id|np-&gt;addrs
(braket
l_int|0
)braket
dot
id|size
op_assign
l_int|0x1000
suffix:semicolon
r_if
c_cond
(paren
id|np-&gt;n_addrs
OG
l_int|1
op_logical_and
id|np-&gt;addrs
(braket
l_int|1
)braket
dot
id|size
OG
l_int|0x100
)paren
id|np-&gt;addrs
(braket
l_int|1
)braket
dot
id|size
op_assign
l_int|0x100
suffix:semicolon
r_if
c_cond
(paren
id|request_OF_resource
c_func
(paren
id|np
comma
l_int|0
comma
l_string|&quot;  (mac-io IDE IO)&quot;
)paren
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ide-pmac(%s): can&squot;t request IO resource !&bslash;n&quot;
comma
id|np-&gt;name
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|base
op_assign
(paren
r_int
r_int
)paren
id|ioremap
c_func
(paren
id|np-&gt;addrs
(braket
l_int|0
)braket
dot
id|address
comma
l_int|0x400
)paren
op_minus
id|_IO_BASE
suffix:semicolon
multiline_comment|/* XXX This is bogus. Should be fixed in the registry by checking&n;&t;&t;   the kind of host interrupt controller, a bit like gatwick&n;&t;&t;   fixes in irq.c&n;&t;&t; */
r_if
c_cond
(paren
id|np-&gt;n_intrs
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;ide: no intrs for device %s, using 13&bslash;n&quot;
comma
id|np-&gt;full_name
)paren
suffix:semicolon
id|irq
op_assign
l_int|13
suffix:semicolon
)brace
r_else
(brace
id|irq
op_assign
id|np-&gt;intrs
(braket
l_int|0
)braket
dot
id|line
suffix:semicolon
)brace
id|pmif-&gt;regbase
op_assign
id|base
suffix:semicolon
id|pmif-&gt;irq
op_assign
id|irq
suffix:semicolon
id|pmif-&gt;node
op_assign
id|np
suffix:semicolon
r_if
c_cond
(paren
id|device_is_compatible
c_func
(paren
id|np
comma
l_string|&quot;keylargo-ata&quot;
)paren
)paren
(brace
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|np-&gt;name
comma
l_string|&quot;ata-4&quot;
)paren
op_eq
l_int|0
)paren
id|pmif-&gt;kind
op_assign
id|controller_kl_ata4
suffix:semicolon
r_else
id|pmif-&gt;kind
op_assign
id|controller_kl_ata3
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|device_is_compatible
c_func
(paren
id|np
comma
l_string|&quot;heathrow-ata&quot;
)paren
)paren
id|pmif-&gt;kind
op_assign
id|controller_heathrow
suffix:semicolon
r_else
id|pmif-&gt;kind
op_assign
id|controller_ohare
suffix:semicolon
id|bidp
op_assign
(paren
r_int
op_star
)paren
id|get_property
c_func
(paren
id|np
comma
l_string|&quot;AAPL,bus-id&quot;
comma
l_int|NULL
)paren
suffix:semicolon
id|pmif-&gt;aapl_bus_id
op_assign
id|bidp
ques
c_cond
op_star
id|bidp
suffix:colon
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|pmif-&gt;kind
op_eq
id|controller_kl_ata4
)paren
(brace
r_char
op_star
id|cable
op_assign
id|get_property
c_func
(paren
id|np
comma
l_string|&quot;cable-type&quot;
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cable
op_logical_and
op_logical_neg
id|strncmp
c_func
(paren
id|cable
comma
l_string|&quot;80-&quot;
comma
l_int|3
)paren
)paren
id|pmif-&gt;kind
op_assign
id|controller_kl_ata4_80
suffix:semicolon
)brace
multiline_comment|/* Make sure we have sane timings */
id|sanitize_timings
c_func
(paren
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|np-&gt;parent
op_logical_and
id|np-&gt;parent-&gt;name
op_logical_and
id|strcasecmp
c_func
(paren
id|np-&gt;parent-&gt;name
comma
l_string|&quot;media-bay&quot;
)paren
op_eq
l_int|0
)paren
(brace
macro_line|#ifdef CONFIG_PMAC_PBOOK
id|media_bay_set_ide_infos
c_func
(paren
id|np-&gt;parent
comma
id|base
comma
id|irq
comma
id|i
)paren
suffix:semicolon
macro_line|#endif
id|in_bay
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bidp
)paren
id|pmif-&gt;aapl_bus_id
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|pmif-&gt;kind
op_eq
id|controller_ohare
)paren
(brace
multiline_comment|/* The code below is having trouble on some ohare machines&n;&t;&t;&t; * (timing related ?). Until I can put my hand on one of these&n;&t;&t;&t; * units, I keep the old way&n;&t;&t;&t; */
id|ppc_md
dot
id|feature_call
c_func
(paren
id|PMAC_FTR_IDE_ENABLE
comma
id|np
comma
l_int|0
comma
l_int|1
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* This is necessary to enable IDE when net-booting */
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;pmac_ide: enabling IDE bus ID %d&bslash;n&quot;
comma
id|pmif-&gt;aapl_bus_id
)paren
suffix:semicolon
id|ppc_md
dot
id|feature_call
c_func
(paren
id|PMAC_FTR_IDE_RESET
comma
id|np
comma
id|pmif-&gt;aapl_bus_id
comma
l_int|1
)paren
suffix:semicolon
id|ppc_md
dot
id|feature_call
c_func
(paren
id|PMAC_FTR_IDE_ENABLE
comma
id|np
comma
id|pmif-&gt;aapl_bus_id
comma
l_int|1
)paren
suffix:semicolon
id|mdelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
id|ppc_md
dot
id|feature_call
c_func
(paren
id|PMAC_FTR_IDE_RESET
comma
id|np
comma
id|pmif-&gt;aapl_bus_id
comma
l_int|0
)paren
suffix:semicolon
id|big_delay
op_assign
l_int|1
suffix:semicolon
)brace
id|hwif
op_assign
op_amp
id|ide_hwifs
(braket
id|i
)braket
suffix:semicolon
id|pmac_ide_init_hwif_ports
c_func
(paren
op_amp
id|hwif-&gt;hw
comma
id|base
comma
l_int|0
comma
op_amp
id|hwif-&gt;irq
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|hwif-&gt;io_ports
comma
id|hwif-&gt;hw.io_ports
comma
r_sizeof
(paren
id|hwif-&gt;io_ports
)paren
)paren
suffix:semicolon
id|hwif-&gt;chipset
op_assign
id|ide_pmac
suffix:semicolon
id|hwif-&gt;noprobe
op_assign
op_logical_neg
id|hwif-&gt;io_ports
(braket
id|IDE_DATA_OFFSET
)braket
op_logical_or
id|in_bay
suffix:semicolon
id|hwif-&gt;udma_four
op_assign
(paren
id|pmif-&gt;kind
op_eq
id|controller_kl_ata4_80
)paren
suffix:semicolon
id|hwif-&gt;pci_dev
op_assign
id|pdev
suffix:semicolon
macro_line|#ifdef CONFIG_PMAC_PBOOK
r_if
c_cond
(paren
id|in_bay
op_logical_and
id|check_media_bay_by_base
c_func
(paren
id|base
comma
id|MB_CD
)paren
op_eq
l_int|0
)paren
id|hwif-&gt;noprobe
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_BLK_DEV_IDEDMA_PMAC
r_if
c_cond
(paren
id|pdev
op_logical_and
id|np-&gt;n_addrs
op_ge
l_int|2
)paren
(brace
multiline_comment|/* has a DBDMA controller channel */
id|pmac_ide_setup_dma
c_func
(paren
id|np
comma
id|i
)paren
suffix:semicolon
)brace
macro_line|#endif
op_increment
id|i
suffix:semicolon
)brace
id|pmac_ide_count
op_assign
id|i
suffix:semicolon
r_if
c_cond
(paren
id|big_delay
)paren
id|mdelay
c_func
(paren
id|IDE_WAKEUP_DELAY_MS
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_PMAC_PBOOK
id|pmu_register_sleep_notifier
c_func
(paren
op_amp
id|idepmac_sleep_notifier
)paren
suffix:semicolon
macro_line|#endif
)brace
macro_line|#ifdef CONFIG_BLK_DEV_IDEDMA_PMAC
r_static
r_void
id|__init
DECL|function|pmac_ide_setup_dma
id|pmac_ide_setup_dma
c_func
(paren
r_struct
id|device_node
op_star
id|np
comma
r_int
id|ix
)paren
(brace
r_struct
id|pmac_ide_hwif
op_star
id|pmif
op_assign
op_amp
id|pmac_ide
(braket
id|ix
)braket
suffix:semicolon
r_if
c_cond
(paren
id|request_OF_resource
c_func
(paren
id|np
comma
l_int|1
comma
l_string|&quot; (mac-io IDE DMA)&quot;
)paren
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ide-pmac(%s): can&squot;t request DMA resource !&bslash;n&quot;
comma
id|np-&gt;name
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|pmif-&gt;dma_regs
op_assign
(paren
r_volatile
r_struct
id|dbdma_regs
op_star
)paren
id|ioremap
c_func
(paren
id|np-&gt;addrs
(braket
l_int|1
)braket
dot
id|address
comma
l_int|0x200
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Allocate space for the DBDMA commands.&n;&t; * The +2 is +1 for the stop command and +1 to allow for&n;&t; * aligning the start address to a multiple of 16 bytes.&n;&t; */
id|pmif-&gt;dma_table_cpu
op_assign
(paren
r_struct
id|dbdma_cmd
op_star
)paren
id|pci_alloc_consistent
c_func
(paren
id|ide_hwifs
(braket
id|ix
)braket
dot
id|pci_dev
comma
(paren
id|MAX_DCMDS
op_plus
l_int|2
)paren
op_star
r_sizeof
(paren
r_struct
id|dbdma_cmd
)paren
comma
op_amp
id|pmif-&gt;dma_table_dma
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pmif-&gt;dma_table_cpu
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: unable to allocate DMA command list&bslash;n&quot;
comma
id|ide_hwifs
(braket
id|ix
)braket
dot
id|name
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|pmif-&gt;sg_table
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|scatterlist
)paren
op_star
id|MAX_DCMDS
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pmif-&gt;sg_table
op_eq
l_int|NULL
)paren
(brace
id|pci_free_consistent
c_func
(paren
id|ide_hwifs
(braket
id|ix
)braket
dot
id|pci_dev
comma
(paren
id|MAX_DCMDS
op_plus
l_int|2
)paren
op_star
r_sizeof
(paren
r_struct
id|dbdma_cmd
)paren
comma
id|pmif-&gt;dma_table_cpu
comma
id|pmif-&gt;dma_table_dma
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|ide_hwifs
(braket
id|ix
)braket
dot
id|udma_enable
op_assign
id|pmac_udma_enable
suffix:semicolon
id|ide_hwifs
(braket
id|ix
)braket
dot
id|udma_start
op_assign
id|pmac_udma_start
suffix:semicolon
id|ide_hwifs
(braket
id|ix
)braket
dot
id|udma_stop
op_assign
id|pmac_udma_stop
suffix:semicolon
id|ide_hwifs
(braket
id|ix
)braket
dot
id|udma_init
op_assign
id|pmac_udma_init
suffix:semicolon
id|ide_hwifs
(braket
id|ix
)braket
dot
id|udma_irq_status
op_assign
id|pmac_udma_irq_status
suffix:semicolon
id|ide_hwifs
(braket
id|ix
)braket
dot
id|udma_setup
op_assign
id|pmac_udma_setup
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_IDEDMA_PMAC_AUTO
r_if
c_cond
(paren
op_logical_neg
id|noautodma
)paren
id|ide_hwifs
(braket
id|ix
)braket
dot
id|autodma
op_assign
l_int|1
suffix:semicolon
macro_line|#endif
)brace
r_static
r_int
DECL|function|pmac_ide_build_sglist
id|pmac_ide_build_sglist
(paren
r_int
id|ix
comma
r_struct
id|request
op_star
id|rq
)paren
(brace
r_struct
id|ata_channel
op_star
id|hwif
op_assign
op_amp
id|ide_hwifs
(braket
id|ix
)braket
suffix:semicolon
r_struct
id|pmac_ide_hwif
op_star
id|pmif
op_assign
op_amp
id|pmac_ide
(braket
id|ix
)braket
suffix:semicolon
id|request_queue_t
op_star
id|q
op_assign
op_amp
id|hwif-&gt;drives
(braket
id|DEVICE_NR
c_func
(paren
id|rq-&gt;rq_dev
)paren
op_amp
l_int|1
)braket
dot
id|queue
suffix:semicolon
r_struct
id|scatterlist
op_star
id|sg
op_assign
id|pmif-&gt;sg_table
suffix:semicolon
r_int
id|nents
suffix:semicolon
id|nents
op_assign
id|blk_rq_map_sg
c_func
(paren
id|q
comma
id|rq
comma
id|pmif-&gt;sg_table
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rq-&gt;q
op_logical_and
id|nents
OG
id|rq-&gt;nr_phys_segments
)paren
id|printk
c_func
(paren
l_string|&quot;ide-pmac: received %d phys segments, build %d&bslash;n&quot;
comma
id|rq-&gt;nr_phys_segments
comma
id|nents
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rq_data_dir
c_func
(paren
id|rq
)paren
op_eq
id|READ
)paren
id|pmif-&gt;sg_dma_direction
op_assign
id|PCI_DMA_FROMDEVICE
suffix:semicolon
r_else
id|pmif-&gt;sg_dma_direction
op_assign
id|PCI_DMA_TODEVICE
suffix:semicolon
r_return
id|pci_map_sg
c_func
(paren
id|hwif-&gt;pci_dev
comma
id|sg
comma
id|nents
comma
id|pmif-&gt;sg_dma_direction
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|pmac_raw_build_sglist
id|pmac_raw_build_sglist
(paren
r_int
id|ix
comma
r_struct
id|request
op_star
id|rq
)paren
(brace
r_struct
id|ata_channel
op_star
id|hwif
op_assign
op_amp
id|ide_hwifs
(braket
id|ix
)braket
suffix:semicolon
r_struct
id|pmac_ide_hwif
op_star
id|pmif
op_assign
op_amp
id|pmac_ide
(braket
id|ix
)braket
suffix:semicolon
r_struct
id|scatterlist
op_star
id|sg
op_assign
id|pmif-&gt;sg_table
suffix:semicolon
r_int
id|nents
op_assign
l_int|0
suffix:semicolon
r_struct
id|ata_taskfile
op_star
id|args
op_assign
id|rq-&gt;special
suffix:semicolon
r_int
r_char
op_star
id|virt_addr
op_assign
id|rq-&gt;buffer
suffix:semicolon
r_int
id|sector_count
op_assign
id|rq-&gt;nr_sectors
suffix:semicolon
r_if
c_cond
(paren
id|args-&gt;command_type
op_eq
id|IDE_DRIVE_TASK_RAW_WRITE
)paren
id|pmif-&gt;sg_dma_direction
op_assign
id|PCI_DMA_TODEVICE
suffix:semicolon
r_else
id|pmif-&gt;sg_dma_direction
op_assign
id|PCI_DMA_FROMDEVICE
suffix:semicolon
r_if
c_cond
(paren
id|sector_count
OG
l_int|128
)paren
(brace
id|memset
c_func
(paren
op_amp
id|sg
(braket
id|nents
)braket
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|sg
)paren
)paren
suffix:semicolon
id|sg
(braket
id|nents
)braket
dot
id|page
op_assign
id|virt_to_page
c_func
(paren
id|virt_addr
)paren
suffix:semicolon
id|sg
(braket
id|nents
)braket
dot
id|offset
op_assign
(paren
r_int
r_int
)paren
id|virt_addr
op_amp
op_complement
id|PAGE_MASK
suffix:semicolon
id|sg
(braket
id|nents
)braket
dot
id|length
op_assign
l_int|128
op_star
id|SECTOR_SIZE
suffix:semicolon
id|nents
op_increment
suffix:semicolon
id|virt_addr
op_assign
id|virt_addr
op_plus
(paren
l_int|128
op_star
id|SECTOR_SIZE
)paren
suffix:semicolon
id|sector_count
op_sub_assign
l_int|128
suffix:semicolon
)brace
id|memset
c_func
(paren
op_amp
id|sg
(braket
id|nents
)braket
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|sg
)paren
)paren
suffix:semicolon
id|sg
(braket
id|nents
)braket
dot
id|page
op_assign
id|virt_to_page
c_func
(paren
id|virt_addr
)paren
suffix:semicolon
id|sg
(braket
id|nents
)braket
dot
id|offset
op_assign
(paren
r_int
r_int
)paren
id|virt_addr
op_amp
op_complement
id|PAGE_MASK
suffix:semicolon
id|sg
(braket
id|nents
)braket
dot
id|length
op_assign
id|sector_count
op_star
id|SECTOR_SIZE
suffix:semicolon
id|nents
op_increment
suffix:semicolon
r_return
id|pci_map_sg
c_func
(paren
id|hwif-&gt;pci_dev
comma
id|sg
comma
id|nents
comma
id|pmif-&gt;sg_dma_direction
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * pmac_ide_build_dmatable builds the DBDMA command list&n; * for a transfer and sets the DBDMA channel to point to it.&n; */
r_static
r_int
DECL|function|pmac_ide_build_dmatable
id|pmac_ide_build_dmatable
c_func
(paren
r_struct
id|ata_device
op_star
id|drive
comma
r_struct
id|request
op_star
id|rq
comma
r_int
id|ix
comma
r_int
id|wr
)paren
(brace
r_struct
id|dbdma_cmd
op_star
id|table
suffix:semicolon
r_int
id|i
comma
id|count
op_assign
l_int|0
suffix:semicolon
r_volatile
r_struct
id|dbdma_regs
op_star
id|dma
op_assign
id|pmac_ide
(braket
id|ix
)braket
dot
id|dma_regs
suffix:semicolon
r_struct
id|scatterlist
op_star
id|sg
suffix:semicolon
multiline_comment|/* DMA table is already aligned */
id|table
op_assign
(paren
r_struct
id|dbdma_cmd
op_star
)paren
id|pmac_ide
(braket
id|ix
)braket
dot
id|dma_table_cpu
suffix:semicolon
multiline_comment|/* Make sure DMA controller is stopped (necessary ?) */
id|out_le32
c_func
(paren
op_amp
id|dma-&gt;control
comma
(paren
id|RUN
op_or
id|PAUSE
op_or
id|FLUSH
op_or
id|WAKE
op_or
id|DEAD
)paren
op_lshift
l_int|16
)paren
suffix:semicolon
r_while
c_loop
(paren
id|in_le32
c_func
(paren
op_amp
id|dma-&gt;status
)paren
op_amp
id|RUN
)paren
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Build sglist */
r_if
c_cond
(paren
id|rq-&gt;flags
op_amp
id|REQ_SPECIAL
)paren
(brace
id|pmac_ide
(braket
id|ix
)braket
dot
id|sg_nents
op_assign
id|i
op_assign
id|pmac_raw_build_sglist
c_func
(paren
id|ix
comma
id|rq
)paren
suffix:semicolon
)brace
r_else
(brace
id|pmac_ide
(braket
id|ix
)braket
dot
id|sg_nents
op_assign
id|i
op_assign
id|pmac_ide_build_sglist
c_func
(paren
id|ix
comma
id|rq
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|i
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Build DBDMA commands list */
id|sg
op_assign
id|pmac_ide
(braket
id|ix
)braket
dot
id|sg_table
suffix:semicolon
r_while
c_loop
(paren
id|i
)paren
(brace
id|u32
id|cur_addr
suffix:semicolon
id|u32
id|cur_len
suffix:semicolon
id|cur_addr
op_assign
id|sg_dma_address
c_func
(paren
id|sg
)paren
suffix:semicolon
id|cur_len
op_assign
id|sg_dma_len
c_func
(paren
id|sg
)paren
suffix:semicolon
r_while
c_loop
(paren
id|cur_len
)paren
(brace
r_int
r_int
id|tc
op_assign
(paren
id|cur_len
OL
l_int|0xfe00
)paren
ques
c_cond
id|cur_len
suffix:colon
l_int|0xfe00
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|count
op_ge
id|MAX_DCMDS
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: DMA table too small&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/* revert to PIO for this request */
)brace
id|st_le16
c_func
(paren
op_amp
id|table-&gt;command
comma
id|wr
ques
c_cond
id|OUTPUT_MORE
suffix:colon
id|INPUT_MORE
)paren
suffix:semicolon
id|st_le16
c_func
(paren
op_amp
id|table-&gt;req_count
comma
id|tc
)paren
suffix:semicolon
id|st_le32
c_func
(paren
op_amp
id|table-&gt;phy_addr
comma
id|cur_addr
)paren
suffix:semicolon
id|table-&gt;cmd_dep
op_assign
l_int|0
suffix:semicolon
id|table-&gt;xfer_status
op_assign
l_int|0
suffix:semicolon
id|table-&gt;res_count
op_assign
l_int|0
suffix:semicolon
id|cur_addr
op_add_assign
id|tc
suffix:semicolon
id|cur_len
op_sub_assign
id|tc
suffix:semicolon
op_increment
id|table
suffix:semicolon
)brace
id|sg
op_increment
suffix:semicolon
id|i
op_decrement
suffix:semicolon
)brace
multiline_comment|/* convert the last command to an input/output last command */
r_if
c_cond
(paren
id|count
)paren
id|st_le16
c_func
(paren
op_amp
id|table
(braket
op_minus
l_int|1
)braket
dot
id|command
comma
id|wr
ques
c_cond
id|OUTPUT_LAST
suffix:colon
id|INPUT_LAST
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: empty DMA table?&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
multiline_comment|/* add the stop command to the end of the list */
id|memset
c_func
(paren
id|table
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|dbdma_cmd
)paren
)paren
suffix:semicolon
id|out_le16
c_func
(paren
op_amp
id|table-&gt;command
comma
id|DBDMA_STOP
)paren
suffix:semicolon
id|out_le32
c_func
(paren
op_amp
id|dma-&gt;cmdptr
comma
id|pmac_ide
(braket
id|ix
)braket
dot
id|dma_table_dma
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Teardown mappings after DMA has completed.  */
r_static
r_void
DECL|function|pmac_ide_destroy_dmatable
id|pmac_ide_destroy_dmatable
c_func
(paren
r_struct
id|ata_channel
op_star
id|ch
comma
r_int
id|ix
)paren
(brace
r_struct
id|pci_dev
op_star
id|dev
op_assign
id|ch-&gt;pci_dev
suffix:semicolon
r_struct
id|scatterlist
op_star
id|sg
op_assign
id|pmac_ide
(braket
id|ix
)braket
dot
id|sg_table
suffix:semicolon
r_int
id|nents
op_assign
id|pmac_ide
(braket
id|ix
)braket
dot
id|sg_nents
suffix:semicolon
r_if
c_cond
(paren
id|nents
)paren
(brace
id|pci_unmap_sg
c_func
(paren
id|dev
comma
id|sg
comma
id|nents
comma
id|pmac_ide
(braket
id|ix
)braket
dot
id|sg_dma_direction
)paren
suffix:semicolon
id|pmac_ide
(braket
id|ix
)braket
dot
id|sg_nents
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_static
id|__inline__
r_int
r_char
DECL|function|dma_bits_to_command
id|dma_bits_to_command
c_func
(paren
r_int
r_char
id|bits
)paren
(brace
r_if
c_cond
(paren
id|bits
op_amp
l_int|0x04
)paren
(brace
r_return
id|XFER_MW_DMA_2
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bits
op_amp
l_int|0x02
)paren
(brace
r_return
id|XFER_MW_DMA_1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bits
op_amp
l_int|0x01
)paren
(brace
r_return
id|XFER_MW_DMA_0
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_static
id|__inline__
r_int
r_char
DECL|function|udma_bits_to_command
id|udma_bits_to_command
c_func
(paren
r_int
r_char
id|bits
comma
r_int
id|high_speed
)paren
(brace
r_if
c_cond
(paren
id|high_speed
)paren
(brace
r_if
c_cond
(paren
id|bits
op_amp
l_int|0x10
)paren
(brace
r_return
id|XFER_UDMA_4
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bits
op_amp
l_int|0x08
)paren
(brace
r_return
id|XFER_UDMA_3
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|bits
op_amp
l_int|0x04
)paren
(brace
r_return
id|XFER_UDMA_2
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bits
op_amp
l_int|0x02
)paren
(brace
r_return
id|XFER_UDMA_1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bits
op_amp
l_int|0x01
)paren
(brace
r_return
id|XFER_UDMA_0
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Calculate MultiWord DMA timings */
r_static
r_int
id|__pmac
DECL|function|pmac_ide_mdma_enable
id|pmac_ide_mdma_enable
c_func
(paren
r_struct
id|ata_device
op_star
id|drive
comma
r_int
id|idx
)paren
(brace
id|byte
id|bits
op_assign
id|drive-&gt;id-&gt;dma_mword
op_amp
l_int|0x07
suffix:semicolon
id|byte
id|feature
op_assign
id|dma_bits_to_command
c_func
(paren
id|bits
)paren
suffix:semicolon
id|u32
op_star
id|timings
suffix:semicolon
r_int
id|drive_cycle_time
suffix:semicolon
r_struct
id|hd_driveid
op_star
id|id
op_assign
id|drive-&gt;id
suffix:semicolon
r_int
id|ret
suffix:semicolon
multiline_comment|/* Set feature on drive */
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Enabling MultiWord DMA %d&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|feature
op_amp
l_int|0xf
)paren
suffix:semicolon
id|ret
op_assign
id|pmac_ide_do_setfeature
c_func
(paren
id|drive
comma
id|feature
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: Failed !&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* which drive is it ? */
r_if
c_cond
(paren
id|drive-&gt;select.b.unit
op_amp
l_int|0x01
)paren
id|timings
op_assign
op_amp
id|pmac_ide
(braket
id|idx
)braket
dot
id|timings
(braket
l_int|1
)braket
suffix:semicolon
r_else
id|timings
op_assign
op_amp
id|pmac_ide
(braket
id|idx
)braket
dot
id|timings
(braket
l_int|0
)braket
suffix:semicolon
multiline_comment|/* Check if drive provide explicit cycle time */
r_if
c_cond
(paren
(paren
id|id-&gt;field_valid
op_amp
l_int|2
)paren
op_logical_and
(paren
id|id-&gt;eide_dma_time
)paren
)paren
id|drive_cycle_time
op_assign
id|id-&gt;eide_dma_time
suffix:semicolon
r_else
id|drive_cycle_time
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Calculate controller timings */
id|set_timings_mdma
c_func
(paren
id|pmac_ide
(braket
id|idx
)braket
dot
id|kind
comma
id|timings
comma
id|feature
comma
id|drive_cycle_time
)paren
suffix:semicolon
id|drive-&gt;current_speed
op_assign
id|feature
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Calculate Ultra DMA timings */
r_static
r_int
id|__pmac
DECL|function|pmac_ide_udma_enable
id|pmac_ide_udma_enable
c_func
(paren
r_struct
id|ata_device
op_star
id|drive
comma
r_int
id|idx
comma
r_int
id|high_speed
)paren
(brace
id|byte
id|bits
op_assign
id|drive-&gt;id-&gt;dma_ultra
op_amp
l_int|0x1f
suffix:semicolon
id|byte
id|feature
op_assign
id|udma_bits_to_command
c_func
(paren
id|bits
comma
id|high_speed
)paren
suffix:semicolon
id|u32
op_star
id|timings
suffix:semicolon
r_int
id|ret
suffix:semicolon
multiline_comment|/* Set feature on drive */
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Enabling Ultra DMA %d&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|feature
op_amp
l_int|0xf
)paren
suffix:semicolon
id|ret
op_assign
id|pmac_ide_do_setfeature
c_func
(paren
id|drive
comma
id|feature
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: Failed !&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* which drive is it ? */
r_if
c_cond
(paren
id|drive-&gt;select.b.unit
op_amp
l_int|0x01
)paren
id|timings
op_assign
op_amp
id|pmac_ide
(braket
id|idx
)braket
dot
id|timings
(braket
l_int|1
)braket
suffix:semicolon
r_else
id|timings
op_assign
op_amp
id|pmac_ide
(braket
id|idx
)braket
dot
id|timings
(braket
l_int|0
)braket
suffix:semicolon
id|set_timings_udma
c_func
(paren
id|timings
comma
id|feature
)paren
suffix:semicolon
id|drive-&gt;current_speed
op_assign
id|feature
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_static
r_int
id|__pmac
DECL|function|pmac_ide_check_dma
id|pmac_ide_check_dma
c_func
(paren
r_struct
id|ata_device
op_star
id|drive
)paren
(brace
r_int
id|ata4
comma
id|udma
comma
id|idx
suffix:semicolon
r_struct
id|hd_driveid
op_star
id|id
op_assign
id|drive-&gt;id
suffix:semicolon
r_int
id|enable
op_assign
l_int|1
suffix:semicolon
id|drive-&gt;using_dma
op_assign
l_int|0
suffix:semicolon
id|idx
op_assign
id|pmac_ide_find
c_func
(paren
id|drive
)paren
suffix:semicolon
r_if
c_cond
(paren
id|idx
OL
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;type
op_eq
id|ATA_FLOPPY
)paren
id|enable
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|id-&gt;capability
op_amp
l_int|1
)paren
op_eq
l_int|0
)paren
op_logical_and
op_logical_neg
id|check_drive_lists
c_func
(paren
id|drive
comma
id|GOOD_DMA_DRIVE
)paren
)paren
id|enable
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|check_drive_lists
c_func
(paren
id|drive
comma
id|BAD_DMA_DRIVE
)paren
)paren
id|enable
op_assign
l_int|0
suffix:semicolon
id|udma
op_assign
l_int|0
suffix:semicolon
id|ata4
op_assign
(paren
id|pmac_ide
(braket
id|idx
)braket
dot
id|kind
op_eq
id|controller_kl_ata4
op_logical_or
id|pmac_ide
(braket
id|idx
)braket
dot
id|kind
op_eq
id|controller_kl_ata4_80
)paren
suffix:semicolon
r_if
c_cond
(paren
id|enable
)paren
(brace
r_if
c_cond
(paren
id|ata4
op_logical_and
(paren
id|drive-&gt;type
op_eq
id|ATA_DISK
)paren
op_logical_and
(paren
id|id-&gt;field_valid
op_amp
l_int|0x0004
)paren
op_logical_and
(paren
id|id-&gt;dma_ultra
op_amp
l_int|0x1f
)paren
)paren
(brace
multiline_comment|/* UltraDMA modes. */
id|drive-&gt;using_dma
op_assign
id|pmac_ide_udma_enable
c_func
(paren
id|drive
comma
id|idx
comma
id|pmac_ide
(braket
id|idx
)braket
dot
id|kind
op_eq
id|controller_kl_ata4_80
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|drive-&gt;using_dma
op_logical_and
(paren
id|id-&gt;dma_mword
op_amp
l_int|0x0007
)paren
)paren
(brace
multiline_comment|/* Normal MultiWord DMA modes. */
id|drive-&gt;using_dma
op_assign
id|pmac_ide_mdma_enable
c_func
(paren
id|drive
comma
id|idx
)paren
suffix:semicolon
)brace
id|ata_irq_enable
c_func
(paren
id|drive
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Apply settings to controller */
id|pmac_ide_selectproc
c_func
(paren
id|drive
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ide_toggle_bounce
r_static
r_void
id|ide_toggle_bounce
c_func
(paren
r_struct
id|ata_device
op_star
id|drive
comma
r_int
id|on
)paren
(brace
id|dma64_addr_t
id|addr
op_assign
id|BLK_BOUNCE_HIGH
suffix:semicolon
r_if
c_cond
(paren
id|on
op_logical_and
id|drive-&gt;type
op_eq
id|ATA_DISK
op_logical_and
id|drive-&gt;channel-&gt;highmem
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|PCI_DMA_BUS_IS_PHYS
)paren
id|addr
op_assign
id|BLK_BOUNCE_ANY
suffix:semicolon
r_else
id|addr
op_assign
id|drive-&gt;channel-&gt;pci_dev-&gt;dma_mask
suffix:semicolon
)brace
id|blk_queue_bounce_limit
c_func
(paren
op_amp
id|drive-&gt;queue
comma
id|addr
)paren
suffix:semicolon
)brace
DECL|function|pmac_udma_enable
r_static
r_void
id|pmac_udma_enable
c_func
(paren
r_struct
id|ata_device
op_star
id|drive
comma
r_int
id|on
comma
r_int
id|verbose
)paren
(brace
r_if
c_cond
(paren
id|verbose
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: DMA disabled&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
)brace
id|drive-&gt;using_dma
op_assign
l_int|0
suffix:semicolon
id|ide_toggle_bounce
c_func
(paren
id|drive
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|pmac_udma_start
r_static
r_int
id|pmac_udma_start
c_func
(paren
r_struct
id|ata_device
op_star
id|drive
comma
r_struct
id|request
op_star
id|rq
)paren
(brace
r_int
id|ix
comma
id|ata4
suffix:semicolon
r_volatile
r_struct
id|dbdma_regs
op_star
id|dma
suffix:semicolon
multiline_comment|/* Can we stuff a pointer to our intf structure in config_data&n;&t; * or select_data in hwif ?&n;&t; */
id|ix
op_assign
id|pmac_ide_find
c_func
(paren
id|drive
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ix
OL
l_int|0
)paren
r_return
id|ide_stopped
suffix:semicolon
id|dma
op_assign
id|pmac_ide
(braket
id|ix
)braket
dot
id|dma_regs
suffix:semicolon
id|ata4
op_assign
(paren
id|pmac_ide
(braket
id|ix
)braket
dot
id|kind
op_eq
id|controller_kl_ata4
op_logical_or
id|pmac_ide
(braket
id|ix
)braket
dot
id|kind
op_eq
id|controller_kl_ata4_80
)paren
suffix:semicolon
id|out_le32
c_func
(paren
op_amp
id|dma-&gt;control
comma
(paren
id|RUN
op_lshift
l_int|16
)paren
op_or
id|RUN
)paren
suffix:semicolon
multiline_comment|/* Make sure it gets to the controller right now */
(paren
r_void
)paren
id|in_le32
c_func
(paren
op_amp
id|dma-&gt;control
)paren
suffix:semicolon
r_return
id|ide_started
suffix:semicolon
)brace
DECL|function|pmac_udma_stop
r_static
r_int
id|pmac_udma_stop
c_func
(paren
r_struct
id|ata_device
op_star
id|drive
)paren
(brace
r_int
id|ix
comma
id|dstat
comma
id|ata4
suffix:semicolon
r_volatile
r_struct
id|dbdma_regs
op_star
id|dma
suffix:semicolon
multiline_comment|/* Can we stuff a pointer to our intf structure in config_data&n;&t; * or select_data in hwif ?&n;&t; */
id|ix
op_assign
id|pmac_ide_find
c_func
(paren
id|drive
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ix
OL
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
id|dma
op_assign
id|pmac_ide
(braket
id|ix
)braket
dot
id|dma_regs
suffix:semicolon
id|ata4
op_assign
(paren
id|pmac_ide
(braket
id|ix
)braket
dot
id|kind
op_eq
id|controller_kl_ata4
op_logical_or
id|pmac_ide
(braket
id|ix
)braket
dot
id|kind
op_eq
id|controller_kl_ata4_80
)paren
suffix:semicolon
id|dstat
op_assign
id|in_le32
c_func
(paren
op_amp
id|dma-&gt;status
)paren
suffix:semicolon
id|out_le32
c_func
(paren
op_amp
id|dma-&gt;control
comma
(paren
(paren
id|RUN
op_or
id|WAKE
op_or
id|DEAD
)paren
op_lshift
l_int|16
)paren
)paren
suffix:semicolon
id|pmac_ide_destroy_dmatable
c_func
(paren
id|drive-&gt;channel
comma
id|ix
)paren
suffix:semicolon
multiline_comment|/* verify good dma status */
r_return
(paren
id|dstat
op_amp
(paren
id|RUN
op_or
id|DEAD
op_or
id|ACTIVE
)paren
)paren
op_ne
id|RUN
suffix:semicolon
)brace
DECL|function|pmac_udma_init
r_static
r_int
id|pmac_udma_init
c_func
(paren
r_struct
id|ata_device
op_star
id|drive
comma
r_struct
id|request
op_star
id|rq
)paren
(brace
r_int
id|ix
comma
id|ata4
suffix:semicolon
r_volatile
r_struct
id|dbdma_regs
op_star
id|dma
suffix:semicolon
id|u8
id|unit
op_assign
(paren
id|drive-&gt;select.b.unit
op_amp
l_int|0x01
)paren
suffix:semicolon
r_int
id|reading
suffix:semicolon
multiline_comment|/* Can we stuff a pointer to our intf structure in config_data&n;&t; * or select_data in hwif ?&n;&t; */
id|ix
op_assign
id|pmac_ide_find
c_func
(paren
id|drive
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ix
OL
l_int|0
)paren
r_return
id|ide_stopped
suffix:semicolon
r_if
c_cond
(paren
id|rq_data_dir
c_func
(paren
id|rq
)paren
op_eq
id|READ
)paren
id|reading
op_assign
l_int|1
suffix:semicolon
r_else
id|reading
op_assign
l_int|0
suffix:semicolon
id|dma
op_assign
id|pmac_ide
(braket
id|ix
)braket
dot
id|dma_regs
suffix:semicolon
id|ata4
op_assign
(paren
id|pmac_ide
(braket
id|ix
)braket
dot
id|kind
op_eq
id|controller_kl_ata4
op_logical_or
id|pmac_ide
(braket
id|ix
)braket
dot
id|kind
op_eq
id|controller_kl_ata4_80
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pmac_ide_build_dmatable
c_func
(paren
id|drive
comma
id|rq
comma
id|ix
comma
op_logical_neg
id|reading
)paren
)paren
r_return
id|ide_stopped
suffix:semicolon
multiline_comment|/* Apple adds 60ns to wrDataSetup on reads */
r_if
c_cond
(paren
id|ata4
op_logical_and
(paren
id|pmac_ide
(braket
id|ix
)braket
dot
id|timings
(braket
id|unit
)braket
op_amp
id|TR_66_UDMA_EN
)paren
)paren
(brace
id|out_le32
c_func
(paren
(paren
r_int
op_star
)paren
(paren
id|IDE_DATA_REG
op_plus
id|IDE_TIMING_CONFIG
op_plus
id|_IO_BASE
)paren
comma
id|pmac_ide
(braket
id|ix
)braket
dot
id|timings
(braket
id|unit
)braket
op_plus
(paren
(paren
id|reading
)paren
ques
c_cond
l_int|0x00800000UL
suffix:colon
l_int|0
)paren
)paren
suffix:semicolon
(paren
r_void
)paren
id|in_le32
c_func
(paren
(paren
r_int
op_star
)paren
(paren
id|IDE_DATA_REG
op_plus
id|IDE_TIMING_CONFIG
op_plus
id|_IO_BASE
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|drive-&gt;type
op_ne
id|ATA_DISK
)paren
r_return
id|ide_started
suffix:semicolon
id|ata_set_handler
c_func
(paren
id|drive
comma
id|ide_dma_intr
comma
id|WAIT_CMD
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rq-&gt;flags
op_amp
id|REQ_SPECIAL
)paren
op_logical_and
(paren
id|drive-&gt;addressing
op_eq
l_int|1
)paren
)paren
(brace
r_struct
id|ata_taskfile
op_star
id|args
op_assign
id|rq-&gt;special
suffix:semicolon
multiline_comment|/* FIXME: this is never reached */
id|OUT_BYTE
c_func
(paren
id|args-&gt;cmd
comma
id|IDE_COMMAND_REG
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|drive-&gt;addressing
)paren
(brace
id|OUT_BYTE
c_func
(paren
id|reading
ques
c_cond
id|WIN_READDMA_EXT
suffix:colon
id|WIN_WRITEDMA_EXT
comma
id|IDE_COMMAND_REG
)paren
suffix:semicolon
)brace
r_else
(brace
id|OUT_BYTE
c_func
(paren
id|reading
ques
c_cond
id|WIN_READDMA
suffix:colon
id|WIN_WRITEDMA
comma
id|IDE_COMMAND_REG
)paren
suffix:semicolon
)brace
id|udma_start
c_func
(paren
id|drive
comma
id|rq
)paren
suffix:semicolon
r_return
id|ide_started
suffix:semicolon
)brace
multiline_comment|/*&n; * FIXME: This should be attached to a channel as we can see now!&n; */
DECL|function|pmac_udma_irq_status
r_static
r_int
id|pmac_udma_irq_status
c_func
(paren
r_struct
id|ata_device
op_star
id|drive
)paren
(brace
r_int
id|ix
comma
id|ata4
suffix:semicolon
r_volatile
r_struct
id|dbdma_regs
op_star
id|dma
suffix:semicolon
multiline_comment|/* Can we stuff a pointer to our intf structure in config_data&n;&t; * or select_data in hwif ?&n;&t; */
id|ix
op_assign
id|pmac_ide_find
c_func
(paren
id|drive
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ix
OL
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
id|dma
op_assign
id|pmac_ide
(braket
id|ix
)braket
dot
id|dma_regs
suffix:semicolon
id|ata4
op_assign
(paren
id|pmac_ide
(braket
id|ix
)braket
dot
id|kind
op_eq
id|controller_kl_ata4
op_logical_or
id|pmac_ide
(braket
id|ix
)braket
dot
id|kind
op_eq
id|controller_kl_ata4_80
)paren
suffix:semicolon
multiline_comment|/* We have to things to deal with here:&n;&t; *&n;&t; * - The dbdma won&squot;t stop if the command was started but completed with&n;&t; * an error without transfering all datas. This happens when bad blocks&n;&t; * are met during a multi-block transfer.&n;&t; *&n;&t; * - The dbdma fifo hasn&squot;t yet finished flushing to to system memory&n;&t; * when the disk interrupt occurs.&n;&t; *&n;&t; * FIXME: The following *trick* is broken:&n;&t; *&n;&t; * The trick here is to increment drive-&gt;waiting_for_dma, and return as&n;&t; * if no interrupt occured. If the counter reach a certain timeout&n;&t; * value, we then return 1. If we really got the interrupt, it will&n;&t; * happen right away again.  Apple&squot;s solution here may be more elegant.&n;&t; * They issue a DMA channel interrupt (a separate irq line) via a DBDMA&n;&t; * NOP command just before the STOP, and wait for both the disk and&n;&t; * DBDMA interrupts to have completed.&n;&t; */
multiline_comment|/* If ACTIVE is cleared, the STOP command have passed and&n;&t; * transfer is complete.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|in_le32
c_func
(paren
op_amp
id|dma-&gt;status
)paren
op_amp
id|ACTIVE
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|test_bit
c_func
(paren
id|IDE_DMA
comma
id|drive-&gt;channel-&gt;active
)paren
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;ide%d, ide_dma_test_irq &bslash;&n;&t;&t;&t;&t;called while not waiting&bslash;n&quot;
comma
id|ix
)paren
suffix:semicolon
multiline_comment|/* If dbdma didn&squot;t execute the STOP command yet, the&n;&t; * active bit is still set */
id|set_bit
c_func
(paren
id|IDE_DMA
comma
id|drive-&gt;channel-&gt;active
)paren
suffix:semicolon
singleline_comment|//&t;if (drive-&gt;waiting_for_dma &gt;= DMA_WAIT_TIMEOUT) {
singleline_comment|//&t;&t;printk(KERN_WARNING &quot;ide%d, timeout waiting &bslash;
r_for
c_loop
id|dbdma
id|command
id|stop
"&bslash;"
id|n
"&quot;"
comma
id|ix
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
id|pmac_udma_setup
c_func
(paren
r_struct
id|ata_device
op_star
id|drive
)paren
(brace
multiline_comment|/* Change this to better match ide-dma.c */
id|pmac_ide_check_dma
c_func
(paren
id|drive
)paren
suffix:semicolon
id|ide_toggle_bounce
c_func
(paren
id|drive
comma
id|drive-&gt;using_dma
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif
r_static
r_void
id|idepmac_sleep_device
c_func
(paren
r_struct
id|ata_device
op_star
id|drive
comma
r_int
id|i
comma
r_int
id|base
)paren
(brace
r_int
id|j
suffix:semicolon
multiline_comment|/* FIXME: We only handle the master IDE disk, we shoud&n;&t; *        try to fix CD-ROMs here&n;&t; */
r_switch
c_cond
(paren
id|drive-&gt;type
)paren
(brace
r_case
id|ATA_DISK
suffix:colon
multiline_comment|/* Spin down the drive */
id|outb
c_func
(paren
id|drive-&gt;select.all
comma
id|base
op_plus
l_int|0x60
)paren
suffix:semicolon
(paren
r_void
)paren
id|inb
c_func
(paren
id|base
op_plus
l_int|0x60
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|100
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x0
comma
id|base
op_plus
l_int|0x30
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x0
comma
id|base
op_plus
l_int|0x20
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x0
comma
id|base
op_plus
l_int|0x40
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x0
comma
id|base
op_plus
l_int|0x50
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0xe0
comma
id|base
op_plus
l_int|0x70
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x2
comma
id|base
op_plus
l_int|0x160
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
l_int|10
suffix:semicolon
id|j
op_increment
)paren
(brace
r_int
id|status
suffix:semicolon
id|mdelay
c_func
(paren
l_int|100
)paren
suffix:semicolon
id|status
op_assign
id|inb
c_func
(paren
id|base
op_plus
l_int|0x70
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|status
op_amp
id|BUSY_STAT
)paren
op_logical_and
(paren
id|status
op_amp
id|DRQ_STAT
)paren
)paren
r_break
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|ATA_ROM
suffix:colon
singleline_comment|// todo
r_break
suffix:semicolon
r_case
id|ATA_FLOPPY
suffix:colon
singleline_comment|// todo
r_break
suffix:semicolon
)brace
)brace
macro_line|#ifdef CONFIG_PMAC_PBOOK
r_static
r_void
id|__pmac
id|idepmac_wake_device
c_func
(paren
r_struct
id|ata_device
op_star
id|drive
comma
r_int
id|used_dma
)paren
(brace
multiline_comment|/* We force the IDE subdriver to check for a media change&n;&t; * This must be done first or we may lost the condition&n;&t; *&n;&t; * Problem: This can schedule. I moved the block device&n;&t; * wakeup almost late by priority because of that.&n;&t; */
r_if
c_cond
(paren
id|drive-&gt;driver
op_ne
l_int|NULL
op_logical_and
id|ata_ops
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|check_media_change
)paren
id|ata_ops
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|check_media_change
c_func
(paren
id|drive
)paren
suffix:semicolon
multiline_comment|/* We kick the VFS too (see fix in ide.c revalidate) */
id|check_disk_change
c_func
(paren
id|mk_kdev
c_func
(paren
id|drive-&gt;channel-&gt;major
comma
(paren
id|drive-&gt;select.b.unit
)paren
op_lshift
id|PARTN_BITS
)paren
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_IDEDMA_PMAC
multiline_comment|/* We re-enable DMA on the drive if it was active. */
multiline_comment|/* This doesn&squot;t work with the CD-ROM in the media-bay, probably&n;&t; * because of a pending unit attention. The problem if that if I&n;&t; * clear the error, the filesystem dies.&n;&t; */
r_if
c_cond
(paren
id|used_dma
op_logical_and
op_logical_neg
id|ide_spin_wait_hwgroup
c_func
(paren
id|drive
)paren
)paren
(brace
multiline_comment|/* Lock HW group */
id|set_bit
c_func
(paren
id|IDE_BUSY
comma
id|drive-&gt;channel-&gt;active
)paren
suffix:semicolon
id|pmac_ide_check_dma
c_func
(paren
id|drive
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|IDE_BUSY
comma
id|drive-&gt;channel-&gt;active
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
id|drive-&gt;channel-&gt;lock
)paren
suffix:semicolon
)brace
macro_line|#endif
)brace
r_static
r_void
id|__pmac
id|idepmac_sleep_interface
c_func
(paren
r_int
id|i
comma
r_int
id|base
comma
r_int
id|mediabay
)paren
(brace
r_struct
id|device_node
op_star
id|np
op_assign
id|pmac_ide
(braket
id|i
)braket
dot
id|node
suffix:semicolon
multiline_comment|/* We clear the timings */
id|pmac_ide
(braket
id|i
)braket
dot
id|timings
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|pmac_ide
(braket
id|i
)braket
dot
id|timings
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* The media bay will handle itself just fine */
r_if
c_cond
(paren
id|mediabay
)paren
r_return
suffix:semicolon
multiline_comment|/* Disable the bus */
id|ppc_md
dot
id|feature_call
c_func
(paren
id|PMAC_FTR_IDE_ENABLE
comma
id|np
comma
id|pmac_ide
(braket
id|i
)braket
dot
id|aapl_bus_id
comma
l_int|0
)paren
suffix:semicolon
)brace
r_static
r_void
id|__pmac
id|idepmac_wake_interface
c_func
(paren
r_int
id|i
comma
r_int
r_int
id|base
comma
r_int
id|mediabay
)paren
(brace
r_struct
id|device_node
op_star
id|np
op_assign
id|pmac_ide
(braket
id|i
)braket
dot
id|node
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mediabay
)paren
(brace
multiline_comment|/* Revive IDE disk and controller */
id|ppc_md
dot
id|feature_call
c_func
(paren
id|PMAC_FTR_IDE_RESET
comma
id|np
comma
id|pmac_ide
(braket
id|i
)braket
dot
id|aapl_bus_id
comma
l_int|1
)paren
suffix:semicolon
id|ppc_md
dot
id|feature_call
c_func
(paren
id|PMAC_FTR_IDE_ENABLE
comma
id|np
comma
id|pmac_ide
(braket
id|i
)braket
dot
id|aapl_bus_id
comma
l_int|1
)paren
suffix:semicolon
id|mdelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
id|ppc_md
dot
id|feature_call
c_func
(paren
id|PMAC_FTR_IDE_RESET
comma
id|np
comma
id|pmac_ide
(braket
id|i
)braket
dot
id|aapl_bus_id
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
r_static
r_void
id|idepmac_sleep_drive
c_func
(paren
r_struct
id|ata_device
op_star
id|drive
comma
r_int
id|idx
comma
r_int
r_int
id|base
)paren
(brace
multiline_comment|/* Wait for HW group to complete operations */
r_if
c_cond
(paren
id|ide_spin_wait_hwgroup
c_func
(paren
id|drive
)paren
)paren
singleline_comment|// What can we do here ? Wake drive we had already
singleline_comment|// put to sleep and return an error ?
r_return
suffix:semicolon
r_else
(brace
multiline_comment|/* Lock HW group */
id|set_bit
c_func
(paren
id|IDE_BUSY
comma
id|drive-&gt;channel-&gt;active
)paren
suffix:semicolon
multiline_comment|/* Stop the device */
id|idepmac_sleep_device
c_func
(paren
id|drive
comma
id|idx
comma
id|base
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
id|drive-&gt;channel-&gt;lock
)paren
suffix:semicolon
)brace
)brace
r_static
r_void
id|idepmac_wake_drive
c_func
(paren
r_struct
id|ata_device
op_star
id|drive
comma
r_int
r_int
id|base
)paren
(brace
r_int
id|j
suffix:semicolon
multiline_comment|/* Reset timings */
id|pmac_ide_selectproc
c_func
(paren
id|drive
)paren
suffix:semicolon
id|mdelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
multiline_comment|/* Wait up to 20 seconds for the drive to be ready */
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
l_int|200
suffix:semicolon
id|j
op_increment
)paren
(brace
r_int
id|status
suffix:semicolon
id|mdelay
c_func
(paren
l_int|100
)paren
suffix:semicolon
id|outb
c_func
(paren
id|drive-&gt;select.all
comma
id|base
op_plus
l_int|0x60
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inb
c_func
(paren
id|base
op_plus
l_int|0x60
)paren
op_ne
id|drive-&gt;select.all
)paren
r_continue
suffix:semicolon
id|status
op_assign
id|inb
c_func
(paren
id|base
op_plus
l_int|0x70
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|status
op_amp
id|BUSY_STAT
)paren
)paren
r_break
suffix:semicolon
)brace
multiline_comment|/* We resume processing on the lock group */
id|spin_lock_irq
c_func
(paren
id|drive-&gt;channel-&gt;lock
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|IDE_BUSY
comma
id|drive-&gt;channel-&gt;active
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|drive-&gt;queue.queue_head
)paren
)paren
id|do_ide_request
c_func
(paren
op_amp
id|drive-&gt;queue
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
id|drive-&gt;channel-&gt;lock
)paren
suffix:semicolon
)brace
multiline_comment|/* Note: We support only master drives for now. This will have to be&n; * improved if we want to handle sleep on the iMacDV where the CD-ROM&n; * is a slave&n; */
r_static
r_int
id|__pmac
id|idepmac_notify_sleep
c_func
(paren
r_struct
id|pmu_sleep_notifier
op_star
id|self
comma
r_int
id|when
)paren
(brace
r_int
id|i
comma
id|ret
suffix:semicolon
r_int
r_int
id|base
suffix:semicolon
r_int
id|big_delay
suffix:semicolon
r_switch
c_cond
(paren
id|when
)paren
(brace
r_case
id|PBOOK_SLEEP_REQUEST
suffix:colon
r_break
suffix:semicolon
r_case
id|PBOOK_SLEEP_REJECT
suffix:colon
r_break
suffix:semicolon
r_case
id|PBOOK_SLEEP_NOW
suffix:colon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|pmac_ide_count
suffix:semicolon
op_increment
id|i
)paren
(brace
r_struct
id|ata_channel
op_star
id|hwif
suffix:semicolon
r_int
id|dn
suffix:semicolon
r_if
c_cond
(paren
(paren
id|base
op_assign
id|pmac_ide
(braket
id|i
)braket
dot
id|regbase
)paren
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
id|hwif
op_assign
op_amp
id|ide_hwifs
(braket
id|i
)braket
suffix:semicolon
r_for
c_loop
(paren
id|dn
op_assign
l_int|0
suffix:semicolon
id|dn
OL
id|MAX_DRIVES
suffix:semicolon
id|dn
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|hwif-&gt;drives
(braket
id|dn
)braket
dot
id|present
)paren
r_continue
suffix:semicolon
id|idepmac_sleep_drive
c_func
(paren
op_amp
id|hwif-&gt;drives
(braket
id|dn
)braket
comma
id|i
comma
id|base
)paren
suffix:semicolon
)brace
multiline_comment|/* Disable irq during sleep */
id|disable_irq
c_func
(paren
id|pmac_ide
(braket
id|i
)braket
dot
id|irq
)paren
suffix:semicolon
multiline_comment|/* Check if this is a media bay with an IDE device or not&n;&t;&t;&t; * a media bay.&n;&t;&t;&t; */
id|ret
op_assign
id|check_media_bay_by_base
c_func
(paren
id|base
comma
id|MB_CD
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_eq
l_int|0
)paren
op_logical_or
(paren
id|ret
op_eq
op_minus
id|ENODEV
)paren
)paren
id|idepmac_sleep_interface
c_func
(paren
id|i
comma
id|base
comma
(paren
id|ret
op_eq
l_int|0
)paren
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|PBOOK_WAKE
suffix:colon
id|big_delay
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|pmac_ide_count
suffix:semicolon
op_increment
id|i
)paren
(brace
r_if
c_cond
(paren
(paren
id|base
op_assign
id|pmac_ide
(braket
id|i
)braket
dot
id|regbase
)paren
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
multiline_comment|/* Make sure we have sane timings */
id|sanitize_timings
c_func
(paren
id|i
)paren
suffix:semicolon
multiline_comment|/* Check if this is a media bay with an IDE device or not&n;&t;&t;&t; * a media bay&n;&t;&t;&t; */
id|ret
op_assign
id|check_media_bay_by_base
c_func
(paren
id|base
comma
id|MB_CD
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_eq
l_int|0
)paren
op_logical_or
(paren
id|ret
op_eq
op_minus
id|ENODEV
)paren
)paren
(brace
id|idepmac_wake_interface
c_func
(paren
id|i
comma
id|base
comma
(paren
id|ret
op_eq
l_int|0
)paren
)paren
suffix:semicolon
id|big_delay
op_assign
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/* Let hardware get up to speed */
r_if
c_cond
(paren
id|big_delay
)paren
id|mdelay
c_func
(paren
id|IDE_WAKEUP_DELAY_MS
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|pmac_ide_count
suffix:semicolon
op_increment
id|i
)paren
(brace
r_struct
id|ata_channel
op_star
id|hwif
suffix:semicolon
r_int
id|used_dma
comma
id|dn
suffix:semicolon
r_int
id|irq_on
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|base
op_assign
id|pmac_ide
(braket
id|i
)braket
dot
id|regbase
)paren
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
id|hwif
op_assign
op_amp
id|ide_hwifs
(braket
id|i
)braket
suffix:semicolon
r_for
c_loop
(paren
id|dn
op_assign
l_int|0
suffix:semicolon
id|dn
OL
id|MAX_DRIVES
suffix:semicolon
id|dn
op_increment
)paren
(brace
r_struct
id|ata_device
op_star
id|drive
op_assign
op_amp
id|hwif-&gt;drives
(braket
id|dn
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|drive-&gt;present
)paren
r_continue
suffix:semicolon
multiline_comment|/* We don&squot;t have re-configured DMA yet */
id|used_dma
op_assign
id|drive-&gt;using_dma
suffix:semicolon
id|drive-&gt;using_dma
op_assign
l_int|0
suffix:semicolon
id|idepmac_wake_drive
c_func
(paren
id|drive
comma
id|base
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|irq_on
)paren
(brace
id|enable_irq
c_func
(paren
id|pmac_ide
(braket
id|i
)braket
dot
id|irq
)paren
suffix:semicolon
id|irq_on
op_assign
l_int|1
suffix:semicolon
)brace
id|idepmac_wake_device
c_func
(paren
id|drive
comma
id|used_dma
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|irq_on
)paren
id|enable_irq
c_func
(paren
id|pmac_ide
(braket
id|i
)braket
dot
id|irq
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
r_return
id|PBOOK_SLEEP_OK
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_PMAC_PBOOK */
eof
