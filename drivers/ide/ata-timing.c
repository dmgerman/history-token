multiline_comment|/*&n; * $Id: ata-timing.c,v 2.0 2002/03/12 15:48:43 vojtech Exp $&n; *&n; *  Copyright (c) 1999-2001 Vojtech Pavlik&n; *&n; * This program is free software; you can redistribute it and/or modify it&n; * under the terms of the GNU General Public License as published by the Free&n; * Software Foundation; either version 2 of the License, or (at your option)&n; * any later version.&n; *&n; * This program is distributed in the hope that it will be useful, but WITHOUT&n; * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or&n; * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for&n; * more details.&n; *&n; * You should have received a copy of the GNU General Public License along with&n; * this program; if not, write to the Free Software Foundation, Inc., 59 Temple&n; * Place, Suite 330, Boston, MA 02111-1307 USA&n; *&n; * Should you need to contact me, the author, you can do so either by e-mail -&n; * mail your message to &lt;vojtech@ucw.cz&gt;, or by paper mail: Vojtech Pavlik,&n; * Simunkova 1594, Prague 8, 182 00 Czech Republic&n; */
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &quot;ata-timing.h&quot;
multiline_comment|/*&n; * PIO 0-5, MWDMA 0-2 and UDMA 0-6 timings (in nanoseconds).  These were taken&n; * from ATA/ATAPI-6 standard, rev 0a, except for PIO 5, which is a nonstandard&n; * extension and UDMA6, which is currently supported only by Maxtor drives.&n; */
DECL|variable|ata_timing
r_struct
id|ata_timing
id|ata_timing
(braket
)braket
op_assign
(brace
(brace
id|XFER_UDMA_6
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|15
)brace
comma
(brace
id|XFER_UDMA_5
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|20
)brace
comma
(brace
id|XFER_UDMA_4
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|30
)brace
comma
(brace
id|XFER_UDMA_3
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|45
)brace
comma
(brace
id|XFER_UDMA_2
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|60
)brace
comma
(brace
id|XFER_UDMA_1
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|80
)brace
comma
(brace
id|XFER_UDMA_0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|120
)brace
comma
(brace
id|XFER_UDMA_SLOW
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|150
)brace
comma
(brace
id|XFER_MW_DMA_2
comma
l_int|25
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|70
comma
l_int|25
comma
l_int|120
comma
l_int|0
)brace
comma
(brace
id|XFER_MW_DMA_1
comma
l_int|45
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|80
comma
l_int|50
comma
l_int|150
comma
l_int|0
)brace
comma
(brace
id|XFER_MW_DMA_0
comma
l_int|60
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|215
comma
l_int|215
comma
l_int|480
comma
l_int|0
)brace
comma
(brace
id|XFER_SW_DMA_2
comma
l_int|60
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|120
comma
l_int|120
comma
l_int|240
comma
l_int|0
)brace
comma
(brace
id|XFER_SW_DMA_1
comma
l_int|90
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|240
comma
l_int|240
comma
l_int|480
comma
l_int|0
)brace
comma
(brace
id|XFER_SW_DMA_0
comma
l_int|120
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|480
comma
l_int|480
comma
l_int|960
comma
l_int|0
)brace
comma
(brace
id|XFER_PIO_5
comma
l_int|20
comma
l_int|50
comma
l_int|30
comma
l_int|100
comma
l_int|50
comma
l_int|30
comma
l_int|100
comma
l_int|0
)brace
comma
(brace
id|XFER_PIO_4
comma
l_int|25
comma
l_int|70
comma
l_int|25
comma
l_int|120
comma
l_int|70
comma
l_int|25
comma
l_int|120
comma
l_int|0
)brace
comma
(brace
id|XFER_PIO_3
comma
l_int|30
comma
l_int|80
comma
l_int|70
comma
l_int|180
comma
l_int|80
comma
l_int|70
comma
l_int|180
comma
l_int|0
)brace
comma
(brace
id|XFER_PIO_2
comma
l_int|30
comma
l_int|290
comma
l_int|40
comma
l_int|330
comma
l_int|100
comma
l_int|90
comma
l_int|240
comma
l_int|0
)brace
comma
(brace
id|XFER_PIO_1
comma
l_int|50
comma
l_int|290
comma
l_int|93
comma
l_int|383
comma
l_int|125
comma
l_int|100
comma
l_int|383
comma
l_int|0
)brace
comma
(brace
id|XFER_PIO_0
comma
l_int|70
comma
l_int|290
comma
l_int|240
comma
l_int|600
comma
l_int|165
comma
l_int|150
comma
l_int|600
comma
l_int|0
)brace
comma
(brace
id|XFER_PIO_SLOW
comma
l_int|120
comma
l_int|290
comma
l_int|240
comma
l_int|960
comma
l_int|290
comma
l_int|240
comma
l_int|960
comma
l_int|0
)brace
comma
(brace
op_minus
l_int|1
)brace
)brace
suffix:semicolon
multiline_comment|/*&n; * Determine the best transfer mode appilcable to a particular drive.  This has&n; * then to be matched agains in esp. other drives no the same channel or even&n; * the whole particular host chip.&n; */
DECL|function|ata_timing_mode
r_int
id|ata_timing_mode
c_func
(paren
r_struct
id|ata_device
op_star
id|drive
comma
r_int
id|map
)paren
(brace
r_struct
id|hd_driveid
op_star
id|id
op_assign
id|drive-&gt;id
suffix:semicolon
r_int
id|best
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|id
)paren
r_return
id|XFER_PIO_SLOW
suffix:semicolon
multiline_comment|/* Want UDMA and UDMA bitmap valid */
r_if
c_cond
(paren
(paren
id|map
op_amp
id|XFER_UDMA
)paren
op_logical_and
(paren
id|id-&gt;field_valid
op_amp
l_int|4
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|map
op_amp
id|XFER_UDMA_133
)paren
op_eq
id|XFER_UDMA_133
)paren
r_if
c_cond
(paren
(paren
id|best
op_assign
(paren
id|id-&gt;dma_ultra
op_amp
l_int|0x0040
)paren
ques
c_cond
id|XFER_UDMA_6
suffix:colon
l_int|0
)paren
)paren
r_return
id|best
suffix:semicolon
r_if
c_cond
(paren
(paren
id|map
op_amp
id|XFER_UDMA_100
)paren
op_eq
id|XFER_UDMA_100
)paren
r_if
c_cond
(paren
(paren
id|best
op_assign
(paren
id|id-&gt;dma_ultra
op_amp
l_int|0x0020
)paren
ques
c_cond
id|XFER_UDMA_5
suffix:colon
l_int|0
)paren
)paren
r_return
id|best
suffix:semicolon
r_if
c_cond
(paren
(paren
id|map
op_amp
id|XFER_UDMA_66
)paren
op_eq
id|XFER_UDMA_66
)paren
r_if
c_cond
(paren
(paren
id|best
op_assign
(paren
id|id-&gt;dma_ultra
op_amp
l_int|0x0010
)paren
ques
c_cond
id|XFER_UDMA_4
suffix:colon
(paren
id|id-&gt;dma_ultra
op_amp
l_int|0x0008
)paren
ques
c_cond
id|XFER_UDMA_3
suffix:colon
l_int|0
)paren
)paren
r_return
id|best
suffix:semicolon
r_if
c_cond
(paren
(paren
id|best
op_assign
(paren
id|id-&gt;dma_ultra
op_amp
l_int|0x0004
)paren
ques
c_cond
id|XFER_UDMA_2
suffix:colon
(paren
id|id-&gt;dma_ultra
op_amp
l_int|0x0002
)paren
ques
c_cond
id|XFER_UDMA_1
suffix:colon
(paren
id|id-&gt;dma_ultra
op_amp
l_int|0x0001
)paren
ques
c_cond
id|XFER_UDMA_0
suffix:colon
l_int|0
)paren
)paren
r_return
id|best
suffix:semicolon
)brace
multiline_comment|/* Want MWDMA and drive has EIDE fields */
r_if
c_cond
(paren
(paren
id|map
op_amp
id|XFER_MWDMA
)paren
op_logical_and
(paren
id|id-&gt;field_valid
op_amp
l_int|2
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|best
op_assign
(paren
id|id-&gt;dma_mword
op_amp
l_int|0x0004
)paren
ques
c_cond
id|XFER_MW_DMA_2
suffix:colon
(paren
id|id-&gt;dma_mword
op_amp
l_int|0x0002
)paren
ques
c_cond
id|XFER_MW_DMA_1
suffix:colon
(paren
id|id-&gt;dma_mword
op_amp
l_int|0x0001
)paren
ques
c_cond
id|XFER_MW_DMA_0
suffix:colon
l_int|0
)paren
)paren
r_return
id|best
suffix:semicolon
)brace
multiline_comment|/* Want SWDMA */
r_if
c_cond
(paren
id|map
op_amp
id|XFER_SWDMA
)paren
(brace
multiline_comment|/* EIDE SWDMA */
r_if
c_cond
(paren
id|id-&gt;field_valid
op_amp
l_int|2
)paren
(brace
r_if
c_cond
(paren
(paren
id|best
op_assign
(paren
id|id-&gt;dma_1word
op_amp
l_int|0x0004
)paren
ques
c_cond
id|XFER_SW_DMA_2
suffix:colon
(paren
id|id-&gt;dma_1word
op_amp
l_int|0x0002
)paren
ques
c_cond
id|XFER_SW_DMA_1
suffix:colon
(paren
id|id-&gt;dma_1word
op_amp
l_int|0x0001
)paren
ques
c_cond
id|XFER_SW_DMA_0
suffix:colon
l_int|0
)paren
)paren
r_return
id|best
suffix:semicolon
)brace
multiline_comment|/* Pre-EIDE style SWDMA */
r_if
c_cond
(paren
id|id-&gt;capability
op_amp
l_int|1
)paren
(brace
r_if
c_cond
(paren
(paren
id|best
op_assign
(paren
id|id-&gt;tDMA
op_eq
l_int|2
)paren
ques
c_cond
id|XFER_SW_DMA_2
suffix:colon
(paren
id|id-&gt;tDMA
op_eq
l_int|1
)paren
ques
c_cond
id|XFER_SW_DMA_1
suffix:colon
(paren
id|id-&gt;tDMA
op_eq
l_int|0
)paren
ques
c_cond
id|XFER_SW_DMA_0
suffix:colon
l_int|0
)paren
)paren
r_return
id|best
suffix:semicolon
)brace
)brace
multiline_comment|/* EIDE PIO modes */
r_if
c_cond
(paren
(paren
id|map
op_amp
id|XFER_EPIO
)paren
op_logical_and
(paren
id|id-&gt;field_valid
op_amp
l_int|2
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|best
op_assign
(paren
id|drive-&gt;id-&gt;eide_pio_modes
op_amp
l_int|4
)paren
ques
c_cond
id|XFER_PIO_5
suffix:colon
(paren
id|drive-&gt;id-&gt;eide_pio_modes
op_amp
l_int|2
)paren
ques
c_cond
id|XFER_PIO_4
suffix:colon
(paren
id|drive-&gt;id-&gt;eide_pio_modes
op_amp
l_int|1
)paren
ques
c_cond
id|XFER_PIO_3
suffix:colon
l_int|0
)paren
)paren
r_return
id|best
suffix:semicolon
)brace
r_return
(paren
id|drive-&gt;id-&gt;tPIO
op_eq
l_int|2
)paren
ques
c_cond
id|XFER_PIO_2
suffix:colon
(paren
id|drive-&gt;id-&gt;tPIO
op_eq
l_int|1
)paren
ques
c_cond
id|XFER_PIO_1
suffix:colon
(paren
id|drive-&gt;id-&gt;tPIO
op_eq
l_int|0
)paren
ques
c_cond
id|XFER_PIO_0
suffix:colon
id|XFER_PIO_SLOW
suffix:semicolon
)brace
multiline_comment|/*&n; * This is just unit conversion.&n; */
DECL|function|ata_timing_quantize
r_void
id|ata_timing_quantize
c_func
(paren
r_struct
id|ata_timing
op_star
id|t
comma
r_struct
id|ata_timing
op_star
id|q
comma
r_int
id|T
comma
r_int
id|UT
)paren
(brace
id|q-&gt;setup
op_assign
id|EZ
c_func
(paren
id|t-&gt;setup
op_star
l_int|1000
comma
id|T
)paren
suffix:semicolon
id|q-&gt;act8b
op_assign
id|EZ
c_func
(paren
id|t-&gt;act8b
op_star
l_int|1000
comma
id|T
)paren
suffix:semicolon
id|q-&gt;rec8b
op_assign
id|EZ
c_func
(paren
id|t-&gt;rec8b
op_star
l_int|1000
comma
id|T
)paren
suffix:semicolon
id|q-&gt;cyc8b
op_assign
id|EZ
c_func
(paren
id|t-&gt;cyc8b
op_star
l_int|1000
comma
id|T
)paren
suffix:semicolon
id|q-&gt;active
op_assign
id|EZ
c_func
(paren
id|t-&gt;active
op_star
l_int|1000
comma
id|T
)paren
suffix:semicolon
id|q-&gt;recover
op_assign
id|EZ
c_func
(paren
id|t-&gt;recover
op_star
l_int|1000
comma
id|T
)paren
suffix:semicolon
id|q-&gt;cycle
op_assign
id|EZ
c_func
(paren
id|t-&gt;cycle
op_star
l_int|1000
comma
id|T
)paren
suffix:semicolon
id|q-&gt;udma
op_assign
id|EZ
c_func
(paren
id|t-&gt;udma
op_star
l_int|1000
comma
id|UT
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Match against each other the timing setup for two devices on one channel.&n; * Becouse they share the electrical interface we can unsually only use the&n; * lowest common denominator between them.&n; */
DECL|function|ata_timing_merge
r_void
id|ata_timing_merge
c_func
(paren
r_struct
id|ata_timing
op_star
id|a
comma
r_struct
id|ata_timing
op_star
id|b
comma
r_struct
id|ata_timing
op_star
id|m
comma
r_int
r_int
id|what
)paren
(brace
r_if
c_cond
(paren
id|what
op_amp
id|IDE_TIMING_SETUP
)paren
id|m-&gt;setup
op_assign
id|max
c_func
(paren
id|a-&gt;setup
comma
id|b-&gt;setup
)paren
suffix:semicolon
r_if
c_cond
(paren
id|what
op_amp
id|IDE_TIMING_ACT8B
)paren
id|m-&gt;act8b
op_assign
id|max
c_func
(paren
id|a-&gt;act8b
comma
id|b-&gt;act8b
)paren
suffix:semicolon
r_if
c_cond
(paren
id|what
op_amp
id|IDE_TIMING_REC8B
)paren
id|m-&gt;rec8b
op_assign
id|max
c_func
(paren
id|a-&gt;rec8b
comma
id|b-&gt;rec8b
)paren
suffix:semicolon
r_if
c_cond
(paren
id|what
op_amp
id|IDE_TIMING_CYC8B
)paren
id|m-&gt;cyc8b
op_assign
id|max
c_func
(paren
id|a-&gt;cyc8b
comma
id|b-&gt;cyc8b
)paren
suffix:semicolon
r_if
c_cond
(paren
id|what
op_amp
id|IDE_TIMING_ACTIVE
)paren
id|m-&gt;active
op_assign
id|max
c_func
(paren
id|a-&gt;active
comma
id|b-&gt;active
)paren
suffix:semicolon
r_if
c_cond
(paren
id|what
op_amp
id|IDE_TIMING_RECOVER
)paren
id|m-&gt;recover
op_assign
id|max
c_func
(paren
id|a-&gt;recover
comma
id|b-&gt;recover
)paren
suffix:semicolon
r_if
c_cond
(paren
id|what
op_amp
id|IDE_TIMING_CYCLE
)paren
id|m-&gt;cycle
op_assign
id|max
c_func
(paren
id|a-&gt;cycle
comma
id|b-&gt;cycle
)paren
suffix:semicolon
r_if
c_cond
(paren
id|what
op_amp
id|IDE_TIMING_UDMA
)paren
id|m-&gt;udma
op_assign
id|max
c_func
(paren
id|a-&gt;udma
comma
id|b-&gt;udma
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Just get a pointer to the struct describing the timing values used commonly&n; * for a particular mode.&n; */
DECL|function|ata_timing_data
r_struct
id|ata_timing
op_star
id|ata_timing_data
c_func
(paren
r_int
id|speed
)paren
(brace
r_struct
id|ata_timing
op_star
id|t
suffix:semicolon
r_for
c_loop
(paren
id|t
op_assign
id|ata_timing
suffix:semicolon
id|t-&gt;mode
op_ne
id|speed
suffix:semicolon
id|t
op_increment
)paren
r_if
c_cond
(paren
id|t-&gt;mode
OL
l_int|0
)paren
r_return
l_int|NULL
suffix:semicolon
r_return
id|t
suffix:semicolon
)brace
DECL|function|ata_timing_compute
r_int
id|ata_timing_compute
c_func
(paren
r_struct
id|ata_device
op_star
id|drive
comma
r_int
id|speed
comma
r_struct
id|ata_timing
op_star
id|t
comma
r_int
id|T
comma
r_int
id|UT
)paren
(brace
r_struct
id|hd_driveid
op_star
id|id
op_assign
id|drive-&gt;id
suffix:semicolon
r_struct
id|ata_timing
op_star
id|s
comma
id|p
suffix:semicolon
multiline_comment|/* Find the mode.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|s
op_assign
id|ata_timing_data
c_func
(paren
id|speed
)paren
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* If the drive is an EIDE drive, it can tell us it needs extended&n;&t; * PIO/MWDMA cycle timing.&n;&t; */
multiline_comment|/* EIDE drive */
r_if
c_cond
(paren
id|id
op_logical_and
id|id-&gt;field_valid
op_amp
l_int|2
)paren
(brace
id|memset
c_func
(paren
op_amp
id|p
comma
l_int|0
comma
r_sizeof
(paren
id|p
)paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|speed
op_amp
id|XFER_MODE
)paren
(brace
r_case
id|XFER_PIO
suffix:colon
r_if
c_cond
(paren
id|speed
op_le
id|XFER_PIO_2
)paren
id|p.cycle
op_assign
id|p.cyc8b
op_assign
id|id-&gt;eide_pio
suffix:semicolon
r_else
id|p.cycle
op_assign
id|p.cyc8b
op_assign
id|id-&gt;eide_pio_iordy
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XFER_MWDMA
suffix:colon
id|p.cycle
op_assign
id|id-&gt;eide_dma_min
suffix:semicolon
r_break
suffix:semicolon
)brace
id|ata_timing_merge
c_func
(paren
op_amp
id|p
comma
id|t
comma
id|t
comma
id|IDE_TIMING_CYCLE
op_or
id|IDE_TIMING_CYC8B
)paren
suffix:semicolon
)brace
multiline_comment|/* Convert the timing to bus clock counts.&n;&t; */
id|ata_timing_quantize
c_func
(paren
id|s
comma
id|t
comma
id|T
comma
id|UT
)paren
suffix:semicolon
multiline_comment|/* Even in DMA/UDMA modes we still use PIO access for IDENTIFY,&n;&t; * S.M.A.R.T and some other commands. We have to ensure that the DMA&n;&t; * cycle timing is slower/equal than the fastest PIO timing.&n;&t; */
r_if
c_cond
(paren
(paren
id|speed
op_amp
id|XFER_MODE
)paren
op_ne
id|XFER_PIO
)paren
(brace
id|ata_timing_compute
c_func
(paren
id|drive
comma
id|ata_timing_mode
c_func
(paren
id|drive
comma
id|XFER_PIO
op_or
id|XFER_EPIO
)paren
comma
op_amp
id|p
comma
id|T
comma
id|UT
)paren
suffix:semicolon
id|ata_timing_merge
c_func
(paren
op_amp
id|p
comma
id|t
comma
id|t
comma
id|IDE_TIMING_ALL
)paren
suffix:semicolon
)brace
multiline_comment|/* Lenghten active &amp; recovery time so that cycle time is correct.&n;&t; */
r_if
c_cond
(paren
id|t-&gt;act8b
op_plus
id|t-&gt;rec8b
OL
id|t-&gt;cyc8b
)paren
(brace
id|t-&gt;act8b
op_add_assign
(paren
id|t-&gt;cyc8b
op_minus
(paren
id|t-&gt;act8b
op_plus
id|t-&gt;rec8b
)paren
)paren
op_div
l_int|2
suffix:semicolon
id|t-&gt;rec8b
op_assign
id|t-&gt;cyc8b
op_minus
id|t-&gt;act8b
suffix:semicolon
)brace
r_if
c_cond
(paren
id|t-&gt;active
op_plus
id|t-&gt;recover
OL
id|t-&gt;cycle
)paren
(brace
id|t-&gt;active
op_add_assign
(paren
id|t-&gt;cycle
op_minus
(paren
id|t-&gt;active
op_plus
id|t-&gt;recover
)paren
)paren
op_div
l_int|2
suffix:semicolon
id|t-&gt;recover
op_assign
id|t-&gt;cycle
op_minus
id|t-&gt;active
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
eof
