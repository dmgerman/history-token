multiline_comment|/*&n;   pdcraid.c  Copyright (C) 2001 Red Hat, Inc. All rights reserved.&n;&n;   This program is free software; you can redistribute it and/or modify&n;   it under the terms of the GNU General Public License as published by&n;   the Free Software Foundation; either version 2, or (at your option)&n;   any later version.&n;   &n;   You should have received a copy of the GNU General Public License&n;   (for example /usr/src/linux/COPYING); if not, write to the Free&n;   Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  &n;   &n;   Authors: &t;Arjan van de Ven &lt;arjanv@redhat.com&gt;&n;   &t;&t;&n;   &n;&n;&n;&n;*/
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/blkdev.h&gt;
macro_line|#include &lt;linux/blkpg.h&gt;
macro_line|#include &lt;linux/genhd.h&gt;
macro_line|#include &lt;linux/ioctl.h&gt;
macro_line|#include &lt;linux/ide.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &quot;ataraid.h&quot;
r_static
r_int
id|pdcraid_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
)paren
suffix:semicolon
r_static
r_int
id|pdcraid_release
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
)paren
suffix:semicolon
r_static
r_int
id|pdcraid_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
suffix:semicolon
r_static
r_int
id|pdcraid_make_request
(paren
id|request_queue_t
op_star
id|q
comma
r_int
id|rw
comma
r_struct
id|buffer_head
op_star
id|bh
)paren
suffix:semicolon
DECL|struct|pdcdisk
r_struct
id|pdcdisk
(brace
DECL|member|device
id|kdev_t
id|device
suffix:semicolon
DECL|member|sectors
r_int
r_int
id|sectors
suffix:semicolon
DECL|member|bdev
r_struct
id|block_device
op_star
id|bdev
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|pdcraid
r_struct
id|pdcraid
(brace
DECL|member|stride
r_int
r_int
id|stride
suffix:semicolon
DECL|member|disks
r_int
r_int
id|disks
suffix:semicolon
DECL|member|sectors
r_int
r_int
id|sectors
suffix:semicolon
DECL|member|geom
r_struct
id|geom
id|geom
suffix:semicolon
DECL|member|disk
r_struct
id|pdcdisk
id|disk
(braket
l_int|8
)braket
suffix:semicolon
DECL|member|cutoff
r_int
r_int
id|cutoff
(braket
l_int|8
)braket
suffix:semicolon
DECL|member|cutoff_disks
r_int
r_int
id|cutoff_disks
(braket
l_int|8
)braket
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|pdcraid_ops
r_static
r_struct
id|raid_device_operations
id|pdcraid_ops
op_assign
(brace
id|open
suffix:colon
id|pdcraid_open
comma
id|release
suffix:colon
id|pdcraid_release
comma
id|ioctl
suffix:colon
id|pdcraid_ioctl
comma
id|make_request
suffix:colon
id|pdcraid_make_request
)brace
suffix:semicolon
DECL|variable|raid
r_static
r_struct
id|pdcraid
id|raid
(braket
l_int|16
)braket
suffix:semicolon
DECL|function|pdcraid_ioctl
r_static
r_int
id|pdcraid_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_int
r_int
id|minor
suffix:semicolon
r_int
r_int
id|sectors
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inode
op_logical_or
op_logical_neg
id|inode-&gt;i_rdev
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|minor
op_assign
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
op_rshift
id|SHIFT
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|BLKGETSIZE
suffix:colon
multiline_comment|/* Return device size */
r_if
c_cond
(paren
op_logical_neg
id|arg
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|sectors
op_assign
id|ataraid_gendisk.part
(braket
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
)braket
dot
id|nr_sects
suffix:semicolon
r_if
c_cond
(paren
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
op_amp
l_int|15
)paren
r_return
id|put_user
c_func
(paren
id|sectors
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_return
id|put_user
c_func
(paren
id|raid
(braket
id|minor
)braket
dot
id|sectors
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|HDIO_GETGEO
suffix:colon
(brace
r_struct
id|hd_geometry
op_star
id|loc
op_assign
(paren
r_struct
id|hd_geometry
op_star
)paren
id|arg
suffix:semicolon
r_int
r_int
id|bios_cyl
op_assign
id|raid
(braket
id|minor
)braket
dot
id|geom.cylinders
suffix:semicolon
multiline_comment|/* truncate */
r_if
c_cond
(paren
op_logical_neg
id|loc
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|raid
(braket
id|minor
)braket
dot
id|geom.heads
comma
(paren
id|byte
op_star
)paren
op_amp
id|loc-&gt;heads
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|raid
(braket
id|minor
)braket
dot
id|geom.sectors
comma
(paren
id|byte
op_star
)paren
op_amp
id|loc-&gt;sectors
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|bios_cyl
comma
(paren
r_int
r_int
op_star
)paren
op_amp
id|loc-&gt;cylinders
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|put_user
c_func
(paren
(paren
r_int
)paren
id|ataraid_gendisk.part
(braket
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
)braket
dot
id|start_sect
comma
(paren
r_int
r_int
op_star
)paren
op_amp
id|loc-&gt;start
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|HDIO_GETGEO_BIG
suffix:colon
(brace
r_struct
id|hd_big_geometry
op_star
id|loc
op_assign
(paren
r_struct
id|hd_big_geometry
op_star
)paren
id|arg
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|loc
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|raid
(braket
id|minor
)braket
dot
id|geom.heads
comma
(paren
id|byte
op_star
)paren
op_amp
id|loc-&gt;heads
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|raid
(braket
id|minor
)braket
dot
id|geom.sectors
comma
(paren
id|byte
op_star
)paren
op_amp
id|loc-&gt;sectors
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|raid
(braket
id|minor
)braket
dot
id|geom.cylinders
comma
(paren
r_int
r_int
op_star
)paren
op_amp
id|loc-&gt;cylinders
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|put_user
c_func
(paren
(paren
r_int
)paren
id|ataraid_gendisk.part
(braket
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
)braket
dot
id|start_sect
comma
(paren
r_int
r_int
op_star
)paren
op_amp
id|loc-&gt;start
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|BLKROSET
suffix:colon
r_case
id|BLKROGET
suffix:colon
r_case
id|BLKSSZGET
suffix:colon
r_return
id|blk_ioctl
c_func
(paren
id|inode-&gt;i_rdev
comma
id|cmd
comma
id|arg
)paren
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|pdcraid_make_request
r_static
r_int
id|pdcraid_make_request
(paren
id|request_queue_t
op_star
id|q
comma
r_int
id|rw
comma
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
r_int
r_int
id|rsect
suffix:semicolon
r_int
r_int
id|rsect_left
comma
id|rsect_accum
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|block
suffix:semicolon
r_int
r_int
id|disk
op_assign
l_int|0
comma
id|real_disk
op_assign
l_int|0
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|device
suffix:semicolon
r_struct
id|pdcraid
op_star
id|thisraid
suffix:semicolon
id|rsect
op_assign
id|bh-&gt;b_rsector
suffix:semicolon
multiline_comment|/* Ok. We need to modify this sector number to a new disk + new sector number. &n;&t; * If there are disks of different sizes, this gets tricky. &n;&t; * Example with 3 disks (1Gb, 4Gb and 5 GB):&n;&t; * The first 3 Gb of the &quot;RAID&quot; are evenly spread over the 3 disks.&n;&t; * Then things get interesting. The next 2Gb (RAID view) are spread across disk 2 and 3&n;&t; * and the last 1Gb is disk 3 only.&n;&t; *&n;&t; * the way this is solved is like this: We have a list of &quot;cutoff&quot; points where everytime&n;&t; * a disk falls out of the &quot;higher&quot; count, we mark the max sector. So once we pass a cutoff&n;&t; * point, we have to divide by one less.&n;&t; */
id|device
op_assign
(paren
id|bh-&gt;b_rdev
op_rshift
id|SHIFT
)paren
op_amp
id|MAJOR_MASK
suffix:semicolon
id|thisraid
op_assign
op_amp
id|raid
(braket
id|device
)braket
suffix:semicolon
r_if
c_cond
(paren
id|thisraid-&gt;stride
op_eq
l_int|0
)paren
id|thisraid-&gt;stride
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Partitions need adding of the start sector of the partition to the requested sector */
id|rsect
op_add_assign
id|ataraid_gendisk.part
(braket
id|MINOR
c_func
(paren
id|bh-&gt;b_rdev
)paren
)braket
dot
id|start_sect
suffix:semicolon
multiline_comment|/* Woops we need to split the request to avoid crossing a stride barrier */
r_if
c_cond
(paren
(paren
id|rsect
op_div
id|thisraid-&gt;stride
)paren
op_ne
(paren
(paren
id|rsect
op_plus
(paren
id|bh-&gt;b_size
op_div
l_int|512
)paren
op_minus
l_int|1
)paren
op_div
id|thisraid-&gt;stride
)paren
)paren
(brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|rsect_left
op_assign
id|rsect
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|thisraid-&gt;cutoff_disks
(braket
id|i
)braket
op_eq
l_int|0
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|rsect
OG
id|thisraid-&gt;cutoff
(braket
id|i
)braket
)paren
(brace
multiline_comment|/* we&squot;re in the wrong area so far */
id|rsect_left
op_sub_assign
id|thisraid-&gt;cutoff
(braket
id|i
)braket
suffix:semicolon
id|rsect_accum
op_add_assign
id|thisraid-&gt;cutoff
(braket
id|i
)braket
op_div
id|thisraid-&gt;cutoff_disks
(braket
id|i
)braket
suffix:semicolon
)brace
r_else
(brace
id|block
op_assign
id|rsect_left
op_div
id|thisraid-&gt;stride
suffix:semicolon
id|disk
op_assign
id|block
op_mod
id|thisraid-&gt;cutoff_disks
(braket
id|i
)braket
suffix:semicolon
id|block
op_assign
(paren
id|block
op_div
id|thisraid-&gt;cutoff_disks
(braket
id|i
)braket
)paren
op_star
id|thisraid-&gt;stride
suffix:semicolon
id|rsect
op_assign
id|rsect_accum
op_plus
(paren
id|rsect_left
op_mod
id|thisraid-&gt;stride
)paren
op_plus
id|block
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|disk
op_eq
l_int|0
)paren
op_logical_and
(paren
id|thisraid-&gt;disk
(braket
id|i
)braket
dot
id|sectors
OG
id|rsect_accum
)paren
)paren
(brace
id|real_disk
op_assign
id|i
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|disk
OG
l_int|0
)paren
op_logical_and
(paren
id|thisraid-&gt;disk
(braket
id|i
)braket
dot
id|sectors
op_ge
id|rsect_accum
)paren
)paren
(brace
id|disk
op_decrement
suffix:semicolon
)brace
)brace
id|disk
op_assign
id|real_disk
suffix:semicolon
multiline_comment|/*&n;&t; * The new BH_Lock semantics in ll_rw_blk.c guarantee that this&n;&t; * is the only IO operation happening on this bh.&n;&t; */
id|bh-&gt;b_rdev
op_assign
id|thisraid-&gt;disk
(braket
id|disk
)braket
dot
id|device
suffix:semicolon
id|bh-&gt;b_rsector
op_assign
id|rsect
suffix:semicolon
multiline_comment|/*&n;&t; * Let the main block layer submit the IO and resolve recursion:&n;&t; */
r_return
l_int|1
suffix:semicolon
)brace
macro_line|#include &quot;pdcraid.h&quot;
DECL|function|calc_pdcblock_offset
r_static
r_int
r_int
id|calc_pdcblock_offset
(paren
r_int
id|major
comma
r_int
id|minor
)paren
(brace
r_int
r_int
id|lba
op_assign
l_int|0
suffix:semicolon
id|kdev_t
id|dev
suffix:semicolon
id|ide_drive_t
op_star
id|ideinfo
suffix:semicolon
id|dev
op_assign
id|MKDEV
c_func
(paren
id|major
comma
id|minor
)paren
suffix:semicolon
id|ideinfo
op_assign
id|get_info_ptr
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ideinfo
op_eq
l_int|NULL
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* first sector of the last cluster */
r_if
c_cond
(paren
id|ideinfo-&gt;head
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ideinfo-&gt;sect
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
id|lba
op_assign
(paren
id|ideinfo-&gt;capacity
op_div
(paren
id|ideinfo-&gt;head
op_star
id|ideinfo-&gt;sect
)paren
)paren
suffix:semicolon
id|lba
op_assign
id|lba
op_star
(paren
id|ideinfo-&gt;head
op_star
id|ideinfo-&gt;sect
)paren
suffix:semicolon
id|lba
op_assign
id|lba
op_minus
id|ideinfo-&gt;sect
suffix:semicolon
r_return
id|lba
suffix:semicolon
)brace
DECL|function|read_disk_sb
r_static
r_int
id|read_disk_sb
(paren
r_int
id|major
comma
r_int
id|minor
comma
r_int
r_char
op_star
id|buffer
comma
r_int
id|bufsize
)paren
(brace
r_int
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
op_assign
l_int|NULL
suffix:semicolon
id|kdev_t
id|dev
op_assign
id|MKDEV
c_func
(paren
id|major
comma
id|minor
)paren
suffix:semicolon
r_int
r_int
id|sb_offset
suffix:semicolon
r_if
c_cond
(paren
id|blksize_size
(braket
id|major
)braket
op_eq
l_int|NULL
)paren
multiline_comment|/* device doesn&squot;t exist */
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/*&n;&t; * Calculate the position of the superblock,&n;&t; * it&squot;s at first sector of the last cylinder&n;&t; */
id|sb_offset
op_assign
id|calc_pdcblock_offset
c_func
(paren
id|major
comma
id|minor
)paren
op_div
l_int|8
suffix:semicolon
multiline_comment|/* The /8 transforms sectors into 4Kb blocks */
r_if
c_cond
(paren
id|sb_offset
op_eq
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|set_blocksize
(paren
id|dev
comma
l_int|4096
)paren
suffix:semicolon
id|bh
op_assign
id|bread
(paren
id|dev
comma
id|sb_offset
comma
l_int|4096
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bh
)paren
(brace
id|memcpy
(paren
id|buffer
comma
id|bh-&gt;b_data
comma
id|bufsize
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;pdcraid: Error reading superblock.&bslash;n&quot;
)paren
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
id|ret
op_assign
l_int|0
suffix:semicolon
m_abort
suffix:colon
r_if
c_cond
(paren
id|bh
)paren
id|brelse
(paren
id|bh
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|calc_sb_csum
r_static
r_int
r_int
id|calc_sb_csum
(paren
r_int
r_int
op_star
id|ptr
)paren
(brace
r_int
r_int
id|sum
suffix:semicolon
r_int
id|count
suffix:semicolon
id|sum
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|count
op_assign
l_int|0
suffix:semicolon
id|count
OL
l_int|511
suffix:semicolon
id|count
op_increment
)paren
id|sum
op_add_assign
op_star
id|ptr
op_increment
suffix:semicolon
r_return
id|sum
suffix:semicolon
)brace
DECL|function|probedisk
r_static
r_void
id|__init
id|probedisk
c_func
(paren
r_int
id|major
comma
r_int
id|minor
comma
r_int
id|device
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|promise_raid_conf
op_star
id|prom
suffix:semicolon
r_static
r_int
r_char
id|block
(braket
l_int|4096
)braket
suffix:semicolon
r_if
c_cond
(paren
id|read_disk_sb
c_func
(paren
id|major
comma
id|minor
comma
(paren
r_int
r_char
op_star
)paren
op_amp
id|block
comma
r_sizeof
(paren
id|block
)paren
)paren
)paren
r_return
suffix:semicolon
id|prom
op_assign
(paren
r_struct
id|promise_raid_conf
op_star
)paren
op_amp
id|block
(braket
l_int|512
)braket
suffix:semicolon
multiline_comment|/* the checksums must match */
r_if
c_cond
(paren
id|prom-&gt;checksum
op_ne
id|calc_sb_csum
c_func
(paren
(paren
r_int
r_int
op_star
)paren
id|prom
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|prom-&gt;raid.type
op_ne
l_int|0x00
)paren
multiline_comment|/* Only raid 0 is supported right now */
r_return
suffix:semicolon
multiline_comment|/* This looks evil. But basically, we have to search for our adapternumber&n;&t;   in the arraydefinition, both of which are in the superblock */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
(paren
id|i
OL
id|prom-&gt;raid.total_disks
)paren
op_logical_and
(paren
id|i
OL
l_int|8
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|prom-&gt;raid.disk
(braket
id|i
)braket
dot
id|channel
op_eq
id|prom-&gt;raid.channel
)paren
op_logical_and
(paren
id|prom-&gt;raid.disk
(braket
id|i
)braket
dot
id|device
op_eq
id|prom-&gt;raid.device
)paren
)paren
(brace
id|raid
(braket
id|device
)braket
dot
id|disk
(braket
id|i
)braket
dot
id|bdev
op_assign
id|bdget
c_func
(paren
id|MKDEV
c_func
(paren
id|major
comma
id|minor
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|raid
(braket
id|device
)braket
dot
id|disk
(braket
id|i
)braket
dot
id|bdev
op_ne
l_int|NULL
)paren
(brace
r_struct
id|gendisk
op_star
id|gd
suffix:semicolon
r_int
id|j
suffix:semicolon
multiline_comment|/* This is supposed to prevent others from stealing our underlying disks */
id|blkdev_get
c_func
(paren
id|raid
(braket
id|device
)braket
dot
id|disk
(braket
id|i
)braket
dot
id|bdev
comma
id|FMODE_READ
op_or
id|FMODE_WRITE
comma
l_int|0
comma
id|BDEV_RAW
)paren
suffix:semicolon
id|gd
op_assign
id|get_gendisk
c_func
(paren
id|major
)paren
suffix:semicolon
r_if
c_cond
(paren
id|gd
op_ne
l_int|NULL
)paren
(brace
r_for
c_loop
(paren
id|j
op_assign
l_int|1
op_plus
(paren
id|minor
op_lshift
id|gd-&gt;minor_shift
)paren
suffix:semicolon
id|j
OL
(paren
(paren
id|minor
op_plus
l_int|1
)paren
op_lshift
id|gd-&gt;minor_shift
)paren
suffix:semicolon
id|j
op_increment
)paren
id|gd-&gt;part
(braket
id|j
)braket
dot
id|nr_sects
op_assign
l_int|0
suffix:semicolon
id|put_gendisk
c_func
(paren
id|gd
)paren
suffix:semicolon
)brace
)brace
id|raid
(braket
id|device
)braket
dot
id|disk
(braket
id|i
)braket
dot
id|device
op_assign
id|MKDEV
c_func
(paren
id|major
comma
id|minor
)paren
suffix:semicolon
id|raid
(braket
id|device
)braket
dot
id|disk
(braket
id|i
)braket
dot
id|sectors
op_assign
id|prom-&gt;raid.disk_secs
suffix:semicolon
id|raid
(braket
id|device
)braket
dot
id|stride
op_assign
(paren
l_int|1
op_lshift
id|prom-&gt;raid.raid0_shift
)paren
suffix:semicolon
id|raid
(braket
id|device
)braket
dot
id|disks
op_assign
id|prom-&gt;raid.total_disks
suffix:semicolon
id|raid
(braket
id|device
)braket
dot
id|sectors
op_assign
id|prom-&gt;raid.total_secs
suffix:semicolon
id|raid
(braket
id|device
)braket
dot
id|geom.heads
op_assign
id|prom-&gt;raid.heads
op_plus
l_int|1
suffix:semicolon
id|raid
(braket
id|device
)braket
dot
id|geom.sectors
op_assign
id|prom-&gt;raid.sectors
suffix:semicolon
id|raid
(braket
id|device
)braket
dot
id|geom.cylinders
op_assign
id|prom-&gt;raid.cylinders
op_plus
l_int|1
suffix:semicolon
)brace
)brace
)brace
DECL|function|fill_cutoff
r_static
r_void
id|__init
id|fill_cutoff
c_func
(paren
r_int
id|device
)paren
(brace
r_int
id|i
comma
id|j
suffix:semicolon
r_int
r_int
id|smallest
suffix:semicolon
r_int
r_int
id|bar
suffix:semicolon
r_int
id|count
suffix:semicolon
id|bar
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
(brace
id|smallest
op_assign
op_complement
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
l_int|8
suffix:semicolon
id|j
op_increment
)paren
r_if
c_cond
(paren
(paren
id|raid
(braket
id|device
)braket
dot
id|disk
(braket
id|j
)braket
dot
id|sectors
OL
id|smallest
)paren
op_logical_and
(paren
id|raid
(braket
id|device
)braket
dot
id|disk
(braket
id|j
)braket
dot
id|sectors
OG
id|bar
)paren
)paren
id|smallest
op_assign
id|raid
(braket
id|device
)braket
dot
id|disk
(braket
id|j
)braket
dot
id|sectors
suffix:semicolon
id|count
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
l_int|8
suffix:semicolon
id|j
op_increment
)paren
r_if
c_cond
(paren
id|raid
(braket
id|device
)braket
dot
id|disk
(braket
id|j
)braket
dot
id|sectors
op_ge
id|smallest
)paren
id|count
op_increment
suffix:semicolon
id|smallest
op_assign
id|smallest
op_star
id|count
suffix:semicolon
id|bar
op_assign
id|smallest
suffix:semicolon
id|raid
(braket
id|device
)braket
dot
id|cutoff
(braket
id|i
)braket
op_assign
id|smallest
suffix:semicolon
id|raid
(braket
id|device
)braket
dot
id|cutoff_disks
(braket
id|i
)braket
op_assign
id|count
suffix:semicolon
)brace
)brace
DECL|function|pdcraid_init_one
r_static
id|__init
r_int
id|pdcraid_init_one
c_func
(paren
r_int
id|device
)paren
(brace
r_int
id|i
comma
id|count
suffix:semicolon
id|probedisk
c_func
(paren
id|IDE0_MAJOR
comma
l_int|0
comma
id|device
)paren
suffix:semicolon
id|probedisk
c_func
(paren
id|IDE0_MAJOR
comma
l_int|64
comma
id|device
)paren
suffix:semicolon
id|probedisk
c_func
(paren
id|IDE1_MAJOR
comma
l_int|0
comma
id|device
)paren
suffix:semicolon
id|probedisk
c_func
(paren
id|IDE1_MAJOR
comma
l_int|64
comma
id|device
)paren
suffix:semicolon
id|probedisk
c_func
(paren
id|IDE2_MAJOR
comma
l_int|0
comma
id|device
)paren
suffix:semicolon
id|probedisk
c_func
(paren
id|IDE2_MAJOR
comma
l_int|64
comma
id|device
)paren
suffix:semicolon
id|probedisk
c_func
(paren
id|IDE3_MAJOR
comma
l_int|0
comma
id|device
)paren
suffix:semicolon
id|probedisk
c_func
(paren
id|IDE3_MAJOR
comma
l_int|64
comma
id|device
)paren
suffix:semicolon
id|fill_cutoff
c_func
(paren
id|device
)paren
suffix:semicolon
multiline_comment|/* Initialize the gendisk structure */
id|ataraid_register_disk
c_func
(paren
id|device
comma
id|raid
(braket
id|device
)braket
dot
id|sectors
)paren
suffix:semicolon
id|count
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Promise Fasttrak(tm) Softwareraid driver for linux version 0.02&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|raid
(braket
id|device
)braket
dot
id|disk
(braket
id|i
)braket
dot
id|device
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Drive %i is %li Mb &bslash;n&quot;
comma
id|i
comma
id|raid
(braket
id|device
)braket
dot
id|disk
(braket
id|i
)braket
dot
id|sectors
op_div
l_int|2048
)paren
suffix:semicolon
id|count
op_increment
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|count
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Raid array consists of %i drives. &bslash;n&quot;
comma
id|count
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;No raid array found&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
)brace
DECL|function|pdcraid_init
r_static
id|__init
r_int
id|pdcraid_init
c_func
(paren
r_void
)paren
(brace
r_int
id|retval
comma
id|device
suffix:semicolon
id|device
op_assign
id|ataraid_get_device
c_func
(paren
op_amp
id|pdcraid_ops
)paren
suffix:semicolon
r_if
c_cond
(paren
id|device
OL
l_int|0
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|retval
op_assign
id|pdcraid_init_one
c_func
(paren
id|device
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
id|ataraid_release_device
c_func
(paren
id|device
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
DECL|function|pdcraid_exit
r_static
r_void
id|__exit
id|pdcraid_exit
(paren
r_void
)paren
(brace
r_int
id|i
comma
id|device
suffix:semicolon
r_for
c_loop
(paren
id|device
op_assign
l_int|0
suffix:semicolon
id|device
OL
l_int|16
suffix:semicolon
id|device
op_increment
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|raid
(braket
id|device
)braket
dot
id|disk
(braket
id|i
)braket
dot
id|bdev
)paren
(brace
id|blkdev_put
c_func
(paren
id|raid
(braket
id|device
)braket
dot
id|disk
(braket
id|i
)braket
dot
id|bdev
comma
id|BDEV_RAW
)paren
suffix:semicolon
id|bdput
c_func
(paren
id|raid
(braket
id|device
)braket
dot
id|disk
(braket
id|i
)braket
dot
id|bdev
)paren
suffix:semicolon
id|raid
(braket
id|device
)braket
dot
id|disk
(braket
id|i
)braket
dot
id|bdev
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|raid
(braket
id|device
)braket
dot
id|sectors
)paren
id|ataraid_release_device
c_func
(paren
id|device
)paren
suffix:semicolon
)brace
)brace
DECL|function|pdcraid_open
r_static
r_int
id|pdcraid_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
id|MOD_INC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|pdcraid_release
r_static
r_int
id|pdcraid_release
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|pdcraid_init
id|module_init
c_func
(paren
id|pdcraid_init
)paren
suffix:semicolon
DECL|variable|pdcraid_exit
id|module_exit
c_func
(paren
id|pdcraid_exit
)paren
suffix:semicolon
eof
