multiline_comment|/*&n; *  linux/drivers/ide/ide-disk.c&t;Version 1.18&t;Mar 05, 2003&n; *&n; *  Copyright (C) 1994-1998  Linus Torvalds &amp; authors (see below)&n; *  Copyright (C) 1998-2002  Linux ATA Development&n; *&t;&t;&t;&t;Andre Hedrick &lt;andre@linux-ide.org&gt;&n; *  Copyright (C) 2003&t;     Red Hat &lt;alan@redhat.com&gt;&n; */
multiline_comment|/*&n; *  Mostly written by Mark Lord &lt;mlord@pobox.com&gt;&n; *                and Gadi Oxman &lt;gadio@netvision.net.il&gt;&n; *                and Andre Hedrick &lt;andre@linux-ide.org&gt;&n; *&n; * This is the IDE/ATA disk driver, as evolved from hd.c and ide.c.&n; *&n; * Version 1.00&t;&t;move disk only code from ide.c to ide-disk.c&n; *&t;&t;&t;support optional byte-swapping of all data&n; * Version 1.01&t;&t;fix previous byte-swapping code&n; * Version 1.02&t;&t;remove &quot;, LBA&quot; from drive identification msgs&n; * Version 1.03&t;&t;fix display of id-&gt;buf_size for big-endian&n; * Version 1.04&t;&t;add /proc configurable settings and S.M.A.R.T support&n; * Version 1.05&t;&t;add capacity support for ATA3 &gt;= 8GB&n; * Version 1.06&t;&t;get boot-up messages to show full cyl count&n; * Version 1.07&t;&t;disable door-locking if it fails&n; * Version 1.08&t;&t;fixed CHS/LBA translations for ATA4 &gt; 8GB,&n; *&t;&t;&t;process of adding new ATA4 compliance.&n; *&t;&t;&t;fixed problems in allowing fdisk to see&n; *&t;&t;&t;the entire disk.&n; * Version 1.09&t;&t;added increment of rq-&gt;sector in ide_multwrite&n; *&t;&t;&t;added UDMA 3/4 reporting&n; * Version 1.10&t;&t;request queue changes, Ultra DMA 100&n; * Version 1.11&t;&t;added 48-bit lba&n; * Version 1.12&t;&t;adding taskfile io access method&n; * Version 1.13&t;&t;added standby and flush-cache for notifier&n; * Version 1.14&t;&t;added acoustic-wcache&n; * Version 1.15&t;&t;convert all calls to ide_raw_taskfile&n; *&t;&t;&t;&t;since args will return register content.&n; * Version 1.16&t;&t;added suspend-resume-checkpower&n; * Version 1.17&t;&t;do flush on standy, do flush on ATA &lt; ATA6&n; *&t;&t;&t;fix wcache setup.&n; */
DECL|macro|IDEDISK_VERSION
mdefine_line|#define IDEDISK_VERSION&t;&quot;1.18&quot;
DECL|macro|REALLY_SLOW_IO
macro_line|#undef REALLY_SLOW_IO&t;&t;/* most systems can safely undef this */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/major.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/genhd.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
DECL|macro|_IDE_DISK
mdefine_line|#define _IDE_DISK
macro_line|#include &lt;linux/ide.h&gt;
macro_line|#include &lt;asm/byteorder.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/div64.h&gt;
multiline_comment|/* FIXME: some day we shouldn&squot;t need to look in here! */
macro_line|#include &quot;legacy/pdc4030.h&quot;
multiline_comment|/*&n; * lba_capacity_is_ok() performs a sanity check on the claimed &quot;lba_capacity&quot;&n; * value for this drive (from its reported identification information).&n; *&n; * Returns:&t;1 if lba_capacity looks sensible&n; *&t;&t;0 otherwise&n; *&n; * It is called only once for each drive.&n; */
DECL|function|lba_capacity_is_ok
r_static
r_int
id|lba_capacity_is_ok
(paren
r_struct
id|hd_driveid
op_star
id|id
)paren
(brace
r_int
r_int
id|lba_sects
comma
id|chs_sects
comma
id|head
comma
id|tail
suffix:semicolon
multiline_comment|/*&n;&t; * The ATA spec tells large drives to return&n;&t; * C/H/S = 16383/16/63 independent of their size.&n;&t; * Some drives can be jumpered to use 15 heads instead of 16.&n;&t; * Some drives can be jumpered to use 4092 cyls instead of 16383.&n;&t; */
r_if
c_cond
(paren
(paren
id|id-&gt;cyls
op_eq
l_int|16383
op_logical_or
(paren
id|id-&gt;cyls
op_eq
l_int|4092
op_logical_and
id|id-&gt;cur_cyls
op_eq
l_int|16383
)paren
)paren
op_logical_and
id|id-&gt;sectors
op_eq
l_int|63
op_logical_and
(paren
id|id-&gt;heads
op_eq
l_int|15
op_logical_or
id|id-&gt;heads
op_eq
l_int|16
)paren
op_logical_and
(paren
id|id-&gt;lba_capacity
op_ge
l_int|16383
op_star
l_int|63
op_star
id|id-&gt;heads
)paren
)paren
r_return
l_int|1
suffix:semicolon
id|lba_sects
op_assign
id|id-&gt;lba_capacity
suffix:semicolon
id|chs_sects
op_assign
id|id-&gt;cyls
op_star
id|id-&gt;heads
op_star
id|id-&gt;sectors
suffix:semicolon
multiline_comment|/* perform a rough sanity check on lba_sects:  within 10% is OK */
r_if
c_cond
(paren
(paren
id|lba_sects
op_minus
id|chs_sects
)paren
OL
id|chs_sects
op_div
l_int|10
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* some drives have the word order reversed */
id|head
op_assign
(paren
(paren
id|lba_sects
op_rshift
l_int|16
)paren
op_amp
l_int|0xffff
)paren
suffix:semicolon
id|tail
op_assign
(paren
id|lba_sects
op_amp
l_int|0xffff
)paren
suffix:semicolon
id|lba_sects
op_assign
(paren
id|head
op_or
(paren
id|tail
op_lshift
l_int|16
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|lba_sects
op_minus
id|chs_sects
)paren
OL
id|chs_sects
op_div
l_int|10
)paren
(brace
id|id-&gt;lba_capacity
op_assign
id|lba_sects
suffix:semicolon
r_return
l_int|1
suffix:semicolon
multiline_comment|/* lba_capacity is (now) good */
)brace
r_return
l_int|0
suffix:semicolon
multiline_comment|/* lba_capacity value may be bad */
)brace
DECL|function|idedisk_start_tag
r_static
r_int
id|idedisk_start_tag
c_func
(paren
id|ide_drive_t
op_star
id|drive
comma
r_struct
id|request
op_star
id|rq
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|ret
op_assign
l_int|1
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ide_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ata_pending_commands
c_func
(paren
id|drive
)paren
OL
id|drive-&gt;queue_depth
)paren
id|ret
op_assign
id|blk_queue_start_tag
c_func
(paren
id|drive-&gt;queue
comma
id|rq
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ide_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
macro_line|#ifndef CONFIG_IDE_TASKFILE_IO
multiline_comment|/*&n; * read_intr() is the handler for disk read/multread interrupts&n; */
DECL|function|read_intr
r_static
id|ide_startstop_t
id|read_intr
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|ide_hwif_t
op_star
id|hwif
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
suffix:semicolon
id|u32
id|i
op_assign
l_int|0
comma
id|nsect
op_assign
l_int|0
comma
id|msect
op_assign
id|drive-&gt;mult_count
suffix:semicolon
r_struct
id|request
op_star
id|rq
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|u8
id|stat
suffix:semicolon
r_char
op_star
id|to
suffix:semicolon
multiline_comment|/* new way for dealing with premature shared PCI interrupts */
r_if
c_cond
(paren
op_logical_neg
id|OK_STAT
c_func
(paren
id|stat
op_assign
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_STATUS_REG
)paren
comma
id|DATA_READY
comma
id|BAD_R_STAT
)paren
)paren
(brace
r_if
c_cond
(paren
id|stat
op_amp
(paren
id|ERR_STAT
op_or
id|DRQ_STAT
)paren
)paren
(brace
r_return
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|error
c_func
(paren
id|drive
comma
l_string|&quot;read_intr&quot;
comma
id|stat
)paren
suffix:semicolon
)brace
multiline_comment|/* no data yet, so wait for another interrupt */
id|ide_set_handler
c_func
(paren
id|drive
comma
op_amp
id|read_intr
comma
id|WAIT_CMD
comma
l_int|NULL
)paren
suffix:semicolon
r_return
id|ide_started
suffix:semicolon
)brace
id|read_next
suffix:colon
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
r_if
c_cond
(paren
id|msect
)paren
(brace
r_if
c_cond
(paren
(paren
id|nsect
op_assign
id|rq-&gt;current_nr_sectors
)paren
OG
id|msect
)paren
id|nsect
op_assign
id|msect
suffix:semicolon
id|msect
op_sub_assign
id|nsect
suffix:semicolon
)brace
r_else
id|nsect
op_assign
l_int|1
suffix:semicolon
id|to
op_assign
id|ide_map_buffer
c_func
(paren
id|rq
comma
op_amp
id|flags
)paren
suffix:semicolon
id|taskfile_input_data
c_func
(paren
id|drive
comma
id|to
comma
id|nsect
op_star
id|SECTOR_WORDS
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;%s:  read: sectors(%ld-%ld), buffer=0x%08lx, remaining=%ld&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|rq-&gt;sector
comma
id|rq-&gt;sector
op_plus
id|nsect
op_minus
l_int|1
comma
(paren
r_int
r_int
)paren
id|rq-&gt;buffer
op_plus
(paren
id|nsect
op_lshift
l_int|9
)paren
comma
id|rq-&gt;nr_sectors
op_minus
id|nsect
)paren
suffix:semicolon
macro_line|#endif
id|ide_unmap_buffer
c_func
(paren
id|rq
comma
id|to
comma
op_amp
id|flags
)paren
suffix:semicolon
id|rq-&gt;sector
op_add_assign
id|nsect
suffix:semicolon
id|rq-&gt;errors
op_assign
l_int|0
suffix:semicolon
id|i
op_assign
(paren
id|rq-&gt;nr_sectors
op_sub_assign
id|nsect
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
r_int
)paren
(paren
id|rq-&gt;current_nr_sectors
op_sub_assign
id|nsect
)paren
)paren
op_le
l_int|0
)paren
id|ide_end_request
c_func
(paren
id|drive
comma
l_int|1
comma
id|rq-&gt;hard_cur_sectors
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Another BH Page walker and DATA INTEGRITY Questioned on ERROR.&n;&t; * If passed back up on multimode read, BAD DATA could be ACKED&n;&t; * to FILE SYSTEMS above ...&n;&t; */
r_if
c_cond
(paren
id|i
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|msect
)paren
r_goto
id|read_next
suffix:semicolon
id|ide_set_handler
c_func
(paren
id|drive
comma
op_amp
id|read_intr
comma
id|WAIT_CMD
comma
l_int|NULL
)paren
suffix:semicolon
r_return
id|ide_started
suffix:semicolon
)brace
r_return
id|ide_stopped
suffix:semicolon
)brace
multiline_comment|/*&n; * write_intr() is the handler for disk write interrupts&n; */
DECL|function|write_intr
r_static
id|ide_startstop_t
id|write_intr
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|ide_hwgroup_t
op_star
id|hwgroup
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
suffix:semicolon
id|ide_hwif_t
op_star
id|hwif
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
suffix:semicolon
r_struct
id|request
op_star
id|rq
op_assign
id|hwgroup-&gt;rq
suffix:semicolon
id|u32
id|i
op_assign
l_int|0
suffix:semicolon
id|u8
id|stat
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|OK_STAT
c_func
(paren
id|stat
op_assign
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_STATUS_REG
)paren
comma
id|DRIVE_READY
comma
id|drive-&gt;bad_wstat
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: write_intr error1: nr_sectors=%ld, stat=0x%02x&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|rq-&gt;nr_sectors
comma
id|stat
)paren
suffix:semicolon
)brace
r_else
(brace
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;%s: write: sector %ld, buffer=0x%08lx, remaining=%ld&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|rq-&gt;sector
comma
(paren
r_int
r_int
)paren
id|rq-&gt;buffer
comma
id|rq-&gt;nr_sectors
op_minus
l_int|1
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
(paren
id|rq-&gt;nr_sectors
op_eq
l_int|1
)paren
op_xor
(paren
(paren
id|stat
op_amp
id|DRQ_STAT
)paren
op_ne
l_int|0
)paren
)paren
(brace
id|rq-&gt;sector
op_increment
suffix:semicolon
id|rq-&gt;errors
op_assign
l_int|0
suffix:semicolon
id|i
op_assign
op_decrement
id|rq-&gt;nr_sectors
suffix:semicolon
op_decrement
id|rq-&gt;current_nr_sectors
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
r_int
)paren
id|rq-&gt;current_nr_sectors
)paren
op_le
l_int|0
)paren
id|ide_end_request
c_func
(paren
id|drive
comma
l_int|1
comma
id|rq-&gt;hard_cur_sectors
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
OG
l_int|0
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_char
op_star
id|to
op_assign
id|ide_map_buffer
c_func
(paren
id|rq
comma
op_amp
id|flags
)paren
suffix:semicolon
id|taskfile_output_data
c_func
(paren
id|drive
comma
id|to
comma
id|SECTOR_WORDS
)paren
suffix:semicolon
id|ide_unmap_buffer
c_func
(paren
id|rq
comma
id|to
comma
op_amp
id|flags
)paren
suffix:semicolon
id|ide_set_handler
c_func
(paren
id|drive
comma
op_amp
id|write_intr
comma
id|WAIT_CMD
comma
l_int|NULL
)paren
suffix:semicolon
r_return
id|ide_started
suffix:semicolon
)brace
r_return
id|ide_stopped
suffix:semicolon
)brace
multiline_comment|/* the original code did this here (?) */
r_return
id|ide_stopped
suffix:semicolon
)brace
r_return
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|error
c_func
(paren
id|drive
comma
l_string|&quot;write_intr&quot;
comma
id|stat
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * ide_multwrite() transfers a block of up to mcount sectors of data&n; * to a drive as part of a disk multiple-sector write operation.&n; *&n; * Returns 0 on success.&n; *&n; * Note that we may be called from two contexts - __ide_do_rw_disk() context&n; * and IRQ context. The IRQ can happen any time after we&squot;ve output the&n; * full &quot;mcount&quot; number of sectors, so we must make sure we update the&n; * state _before_ we output the final part of the data!&n; *&n; * The update and return to BH is a BLOCK Layer Fakey to get more data&n; * to satisfy the hardware atomic segment.  If the hardware atomic segment&n; * is shorter or smaller than the BH segment then we should be OKAY.&n; * This is only valid if we can rewind the rq-&gt;current_nr_sectors counter.&n; */
DECL|function|ide_multwrite
r_int
id|ide_multwrite
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
r_int
id|mcount
)paren
(brace
id|ide_hwgroup_t
op_star
id|hwgroup
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
suffix:semicolon
r_struct
id|request
op_star
id|rq
op_assign
op_amp
id|hwgroup-&gt;wrq
suffix:semicolon
r_do
(brace
r_char
op_star
id|buffer
suffix:semicolon
r_int
id|nsect
op_assign
id|rq-&gt;current_nr_sectors
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|nsect
OG
id|mcount
)paren
id|nsect
op_assign
id|mcount
suffix:semicolon
id|mcount
op_sub_assign
id|nsect
suffix:semicolon
id|buffer
op_assign
id|ide_map_buffer
c_func
(paren
id|rq
comma
op_amp
id|flags
)paren
suffix:semicolon
id|rq-&gt;sector
op_add_assign
id|nsect
suffix:semicolon
id|rq-&gt;nr_sectors
op_sub_assign
id|nsect
suffix:semicolon
id|rq-&gt;current_nr_sectors
op_sub_assign
id|nsect
suffix:semicolon
multiline_comment|/* Do we move to the next bh after this? */
r_if
c_cond
(paren
op_logical_neg
id|rq-&gt;current_nr_sectors
)paren
(brace
r_struct
id|bio
op_star
id|bio
op_assign
id|rq-&gt;bio
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * only move to next bio, when we have processed&n;&t;&t;&t; * all bvecs in this one.&n;&t;&t;&t; */
r_if
c_cond
(paren
op_increment
id|bio-&gt;bi_idx
op_ge
id|bio-&gt;bi_vcnt
)paren
(brace
id|bio-&gt;bi_idx
op_assign
l_int|0
suffix:semicolon
id|bio
op_assign
id|bio-&gt;bi_next
suffix:semicolon
)brace
multiline_comment|/* end early early we ran out of requests */
r_if
c_cond
(paren
op_logical_neg
id|bio
)paren
(brace
id|mcount
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|rq-&gt;bio
op_assign
id|bio
suffix:semicolon
id|rq-&gt;current_nr_sectors
op_assign
id|bio_iovec
c_func
(paren
id|bio
)paren
op_member_access_from_pointer
id|bv_len
op_rshift
l_int|9
suffix:semicolon
id|rq-&gt;hard_cur_sectors
op_assign
id|rq-&gt;current_nr_sectors
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t; * Ok, we&squot;re all setup for the interrupt&n;&t;&t; * re-entering us on the last transfer.&n;&t;&t; */
id|taskfile_output_data
c_func
(paren
id|drive
comma
id|buffer
comma
id|nsect
op_lshift
l_int|7
)paren
suffix:semicolon
id|ide_unmap_buffer
c_func
(paren
id|rq
comma
id|buffer
comma
op_amp
id|flags
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|mcount
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * multwrite_intr() is the handler for disk multwrite interrupts&n; */
DECL|function|multwrite_intr
r_static
id|ide_startstop_t
id|multwrite_intr
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|ide_hwgroup_t
op_star
id|hwgroup
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
suffix:semicolon
id|ide_hwif_t
op_star
id|hwif
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
suffix:semicolon
r_struct
id|request
op_star
id|rq
op_assign
op_amp
id|hwgroup-&gt;wrq
suffix:semicolon
id|u8
id|stat
suffix:semicolon
id|stat
op_assign
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_STATUS_REG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|OK_STAT
c_func
(paren
id|stat
comma
id|DRIVE_READY
comma
id|drive-&gt;bad_wstat
)paren
)paren
(brace
r_if
c_cond
(paren
id|stat
op_amp
id|DRQ_STAT
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; *&t;The drive wants data. Remember rq is the copy&n;&t;&t;&t; *&t;of the request&n;&t;&t;&t; */
r_if
c_cond
(paren
id|rq-&gt;nr_sectors
)paren
(brace
r_if
c_cond
(paren
id|ide_multwrite
c_func
(paren
id|drive
comma
id|drive-&gt;mult_count
)paren
)paren
r_return
id|ide_stopped
suffix:semicolon
id|ide_set_handler
c_func
(paren
id|drive
comma
op_amp
id|multwrite_intr
comma
id|WAIT_CMD
comma
l_int|NULL
)paren
suffix:semicolon
r_return
id|ide_started
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; *&t;If the copy has all the blocks completed then&n;&t;&t;&t; *&t;we can end the original request.&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|rq-&gt;nr_sectors
)paren
(brace
multiline_comment|/* all done? */
id|rq
op_assign
id|hwgroup-&gt;rq
suffix:semicolon
id|ide_end_request
c_func
(paren
id|drive
comma
l_int|1
comma
id|rq-&gt;nr_sectors
)paren
suffix:semicolon
r_return
id|ide_stopped
suffix:semicolon
)brace
)brace
multiline_comment|/* the original code did this here (?) */
r_return
id|ide_stopped
suffix:semicolon
)brace
r_return
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|error
c_func
(paren
id|drive
comma
l_string|&quot;multwrite_intr&quot;
comma
id|stat
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * __ide_do_rw_disk() issues READ and WRITE commands to a disk,&n; * using LBA if supported, or CHS otherwise, to address sectors.&n; * It also takes care of issuing special DRIVE_CMDs.&n; */
DECL|function|__ide_do_rw_disk
id|ide_startstop_t
id|__ide_do_rw_disk
(paren
id|ide_drive_t
op_star
id|drive
comma
r_struct
id|request
op_star
id|rq
comma
id|sector_t
id|block
)paren
(brace
id|ide_hwif_t
op_star
id|hwif
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
suffix:semicolon
id|u8
id|lba48
op_assign
(paren
id|drive-&gt;addressing
op_eq
l_int|1
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
id|task_ioreg_t
id|command
op_assign
id|WIN_NOP
suffix:semicolon
id|ata_nsector_t
id|nsectors
suffix:semicolon
id|nsectors.all
op_assign
(paren
id|u16
)paren
id|rq-&gt;nr_sectors
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;using_tcq
op_logical_and
id|idedisk_start_tag
c_func
(paren
id|drive
comma
id|rq
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ata_pending_commands
c_func
(paren
id|drive
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_return
id|ide_started
suffix:semicolon
)brace
r_if
c_cond
(paren
id|IDE_CONTROL_REG
)paren
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|drive-&gt;ctl
comma
id|IDE_CONTROL_REG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;select.b.lba
)paren
(brace
r_if
c_cond
(paren
id|drive-&gt;addressing
op_eq
l_int|1
)paren
(brace
id|task_ioreg_t
id|tasklets
(braket
l_int|10
)braket
suffix:semicolon
r_if
c_cond
(paren
id|blk_rq_tagged
c_func
(paren
id|rq
)paren
)paren
(brace
id|tasklets
(braket
l_int|0
)braket
op_assign
id|nsectors.b.low
suffix:semicolon
id|tasklets
(braket
l_int|1
)braket
op_assign
id|nsectors.b.high
suffix:semicolon
id|tasklets
(braket
l_int|2
)braket
op_assign
id|rq-&gt;tag
op_lshift
l_int|3
suffix:semicolon
id|tasklets
(braket
l_int|3
)braket
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|tasklets
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|tasklets
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
id|tasklets
(braket
l_int|2
)braket
op_assign
id|nsectors.b.low
suffix:semicolon
id|tasklets
(braket
l_int|3
)braket
op_assign
id|nsectors.b.high
suffix:semicolon
)brace
id|tasklets
(braket
l_int|4
)braket
op_assign
(paren
id|task_ioreg_t
)paren
id|block
suffix:semicolon
id|tasklets
(braket
l_int|5
)braket
op_assign
(paren
id|task_ioreg_t
)paren
(paren
id|block
op_rshift
l_int|8
)paren
suffix:semicolon
id|tasklets
(braket
l_int|6
)braket
op_assign
(paren
id|task_ioreg_t
)paren
(paren
id|block
op_rshift
l_int|16
)paren
suffix:semicolon
id|tasklets
(braket
l_int|7
)braket
op_assign
(paren
id|task_ioreg_t
)paren
(paren
id|block
op_rshift
l_int|24
)paren
suffix:semicolon
r_if
c_cond
(paren
r_sizeof
(paren
id|block
)paren
op_eq
l_int|4
)paren
(brace
id|tasklets
(braket
l_int|8
)braket
op_assign
(paren
id|task_ioreg_t
)paren
l_int|0
suffix:semicolon
id|tasklets
(braket
l_int|9
)braket
op_assign
(paren
id|task_ioreg_t
)paren
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|tasklets
(braket
l_int|8
)braket
op_assign
(paren
id|task_ioreg_t
)paren
(paren
(paren
id|u64
)paren
id|block
op_rshift
l_int|32
)paren
suffix:semicolon
id|tasklets
(braket
l_int|9
)braket
op_assign
(paren
id|task_ioreg_t
)paren
(paren
(paren
id|u64
)paren
id|block
op_rshift
l_int|40
)paren
suffix:semicolon
)brace
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;%s: %sing: LBAsect=%lu, sectors=%ld, &quot;
l_string|&quot;buffer=0x%08lx, LBAsect=0x%012lx&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|rq_data_dir
c_func
(paren
id|rq
)paren
op_eq
id|READ
ques
c_cond
l_string|&quot;read&quot;
suffix:colon
l_string|&quot;writ&quot;
comma
id|block
comma
id|rq-&gt;nr_sectors
comma
(paren
r_int
r_int
)paren
id|rq-&gt;buffer
comma
id|block
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: 0x%02x%02x 0x%02x%02x%02x%02x%02x%02x&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|tasklets
(braket
l_int|3
)braket
comma
id|tasklets
(braket
l_int|2
)braket
comma
id|tasklets
(braket
l_int|9
)braket
comma
id|tasklets
(braket
l_int|8
)braket
comma
id|tasklets
(braket
l_int|7
)braket
comma
id|tasklets
(braket
l_int|6
)braket
comma
id|tasklets
(braket
l_int|5
)braket
comma
id|tasklets
(braket
l_int|4
)braket
)paren
suffix:semicolon
macro_line|#endif
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|tasklets
(braket
l_int|1
)braket
comma
id|IDE_FEATURE_REG
)paren
suffix:semicolon
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|tasklets
(braket
l_int|3
)braket
comma
id|IDE_NSECTOR_REG
)paren
suffix:semicolon
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|tasklets
(braket
l_int|7
)braket
comma
id|IDE_SECTOR_REG
)paren
suffix:semicolon
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|tasklets
(braket
l_int|8
)braket
comma
id|IDE_LCYL_REG
)paren
suffix:semicolon
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|tasklets
(braket
l_int|9
)braket
comma
id|IDE_HCYL_REG
)paren
suffix:semicolon
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|tasklets
(braket
l_int|0
)braket
comma
id|IDE_FEATURE_REG
)paren
suffix:semicolon
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|tasklets
(braket
l_int|2
)braket
comma
id|IDE_NSECTOR_REG
)paren
suffix:semicolon
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|tasklets
(braket
l_int|4
)braket
comma
id|IDE_SECTOR_REG
)paren
suffix:semicolon
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|tasklets
(braket
l_int|5
)braket
comma
id|IDE_LCYL_REG
)paren
suffix:semicolon
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|tasklets
(braket
l_int|6
)braket
comma
id|IDE_HCYL_REG
)paren
suffix:semicolon
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
l_int|0x00
op_or
id|drive-&gt;select.all
comma
id|IDE_SELECT_REG
)paren
suffix:semicolon
)brace
r_else
(brace
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;%s: %sing: LBAsect=%llu, sectors=%ld, &quot;
l_string|&quot;buffer=0x%08lx&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|rq_data_dir
c_func
(paren
id|rq
)paren
op_eq
id|READ
ques
c_cond
l_string|&quot;read&quot;
suffix:colon
l_string|&quot;writ&quot;
comma
(paren
r_int
r_int
r_int
)paren
id|block
comma
id|rq-&gt;nr_sectors
comma
(paren
r_int
r_int
)paren
id|rq-&gt;buffer
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|blk_rq_tagged
c_func
(paren
id|rq
)paren
)paren
(brace
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|nsectors.b.low
comma
id|IDE_FEATURE_REG
)paren
suffix:semicolon
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|rq-&gt;tag
op_lshift
l_int|3
comma
id|IDE_NSECTOR_REG
)paren
suffix:semicolon
)brace
r_else
(brace
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
l_int|0x00
comma
id|IDE_FEATURE_REG
)paren
suffix:semicolon
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|nsectors.b.low
comma
id|IDE_NSECTOR_REG
)paren
suffix:semicolon
)brace
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|block
comma
id|IDE_SECTOR_REG
)paren
suffix:semicolon
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|block
op_rshift_assign
l_int|8
comma
id|IDE_LCYL_REG
)paren
suffix:semicolon
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|block
op_rshift_assign
l_int|8
comma
id|IDE_HCYL_REG
)paren
suffix:semicolon
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
(paren
(paren
id|block
op_rshift
l_int|8
)paren
op_amp
l_int|0x0f
)paren
op_or
id|drive-&gt;select.all
comma
id|IDE_SELECT_REG
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
r_int
r_int
id|sect
comma
id|head
comma
id|cyl
comma
id|track
suffix:semicolon
id|track
op_assign
(paren
r_int
)paren
id|block
op_div
id|drive-&gt;sect
suffix:semicolon
id|sect
op_assign
(paren
r_int
)paren
id|block
op_mod
id|drive-&gt;sect
op_plus
l_int|1
suffix:semicolon
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|sect
comma
id|IDE_SECTOR_REG
)paren
suffix:semicolon
id|head
op_assign
id|track
op_mod
id|drive-&gt;head
suffix:semicolon
id|cyl
op_assign
id|track
op_div
id|drive-&gt;head
suffix:semicolon
r_if
c_cond
(paren
id|blk_rq_tagged
c_func
(paren
id|rq
)paren
)paren
(brace
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|nsectors.b.low
comma
id|IDE_FEATURE_REG
)paren
suffix:semicolon
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|rq-&gt;tag
op_lshift
l_int|3
comma
id|IDE_NSECTOR_REG
)paren
suffix:semicolon
)brace
r_else
(brace
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
l_int|0x00
comma
id|IDE_FEATURE_REG
)paren
suffix:semicolon
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|nsectors.b.low
comma
id|IDE_NSECTOR_REG
)paren
suffix:semicolon
)brace
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|cyl
comma
id|IDE_LCYL_REG
)paren
suffix:semicolon
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|cyl
op_rshift
l_int|8
comma
id|IDE_HCYL_REG
)paren
suffix:semicolon
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|head
op_or
id|drive-&gt;select.all
comma
id|IDE_SELECT_REG
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;%s: %sing: CHS=%d/%d/%d, sectors=%ld, buffer=0x%08lx&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|rq_data_dir
c_func
(paren
id|rq
)paren
op_eq
id|READ
ques
c_cond
l_string|&quot;read&quot;
suffix:colon
l_string|&quot;writ&quot;
comma
id|cyl
comma
id|head
comma
id|sect
comma
id|rq-&gt;nr_sectors
comma
(paren
r_int
r_int
)paren
id|rq-&gt;buffer
)paren
suffix:semicolon
macro_line|#endif
)brace
r_if
c_cond
(paren
id|rq_data_dir
c_func
(paren
id|rq
)paren
op_eq
id|READ
)paren
(brace
r_if
c_cond
(paren
id|blk_rq_tagged
c_func
(paren
id|rq
)paren
)paren
r_return
id|hwif
op_member_access_from_pointer
id|ide_dma_queued_read
c_func
(paren
id|drive
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;using_dma
op_logical_and
op_logical_neg
id|hwif
op_member_access_from_pointer
id|ide_dma_read
c_func
(paren
id|drive
)paren
)paren
r_return
id|ide_started
suffix:semicolon
id|command
op_assign
(paren
(paren
id|drive-&gt;mult_count
)paren
ques
c_cond
(paren
(paren
id|lba48
)paren
ques
c_cond
id|WIN_MULTREAD_EXT
suffix:colon
id|WIN_MULTREAD
)paren
suffix:colon
(paren
(paren
id|lba48
)paren
ques
c_cond
id|WIN_READ_EXT
suffix:colon
id|WIN_READ
)paren
)paren
suffix:semicolon
id|ide_execute_command
c_func
(paren
id|drive
comma
id|command
comma
op_amp
id|read_intr
comma
id|WAIT_CMD
comma
l_int|NULL
)paren
suffix:semicolon
r_return
id|ide_started
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|rq_data_dir
c_func
(paren
id|rq
)paren
op_eq
id|WRITE
)paren
(brace
id|ide_startstop_t
id|startstop
suffix:semicolon
r_if
c_cond
(paren
id|blk_rq_tagged
c_func
(paren
id|rq
)paren
)paren
r_return
id|hwif
op_member_access_from_pointer
id|ide_dma_queued_write
c_func
(paren
id|drive
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;using_dma
op_logical_and
op_logical_neg
(paren
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|ide_dma_write
c_func
(paren
id|drive
)paren
)paren
)paren
r_return
id|ide_started
suffix:semicolon
id|command
op_assign
(paren
(paren
id|drive-&gt;mult_count
)paren
ques
c_cond
(paren
(paren
id|lba48
)paren
ques
c_cond
id|WIN_MULTWRITE_EXT
suffix:colon
id|WIN_MULTWRITE
)paren
suffix:colon
(paren
(paren
id|lba48
)paren
ques
c_cond
id|WIN_WRITE_EXT
suffix:colon
id|WIN_WRITE
)paren
)paren
suffix:semicolon
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|command
comma
id|IDE_COMMAND_REG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ide_wait_stat
c_func
(paren
op_amp
id|startstop
comma
id|drive
comma
id|DATA_READY
comma
id|drive-&gt;bad_wstat
comma
id|WAIT_DRQ
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: no DRQ after issuing %s&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|drive-&gt;mult_count
ques
c_cond
l_string|&quot;MULTWRITE&quot;
suffix:colon
l_string|&quot;WRITE&quot;
)paren
suffix:semicolon
r_return
id|startstop
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|drive-&gt;unmask
)paren
id|local_irq_disable
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;mult_count
)paren
(brace
id|ide_hwgroup_t
op_star
id|hwgroup
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Ugh.. this part looks ugly because we MUST set up&n;&t; * the interrupt handler before outputting the first block&n;&t; * of data to be written.  If we hit an error (corrupted buffer list)&n;&t; * in ide_multwrite(), then we need to remove the handler/timer&n;&t; * before returning.  Fortunately, this NEVER happens (right?).&n;&t; *&n;&t; * Except when you get an error it seems...&n;&t; *&n;&t; * MAJOR DATA INTEGRITY BUG !!! only if we error &n;&t; */
id|hwgroup-&gt;wrq
op_assign
op_star
id|rq
suffix:semicolon
multiline_comment|/* scratchpad */
id|ide_set_handler
c_func
(paren
id|drive
comma
op_amp
id|multwrite_intr
comma
id|WAIT_CMD
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ide_multwrite
c_func
(paren
id|drive
comma
id|drive-&gt;mult_count
)paren
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ide_lock
comma
id|flags
)paren
suffix:semicolon
id|hwgroup-&gt;handler
op_assign
l_int|NULL
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|hwgroup-&gt;timer
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ide_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|ide_stopped
suffix:semicolon
)brace
)brace
r_else
(brace
r_int
r_int
id|flags
suffix:semicolon
r_char
op_star
id|to
op_assign
id|ide_map_buffer
c_func
(paren
id|rq
comma
op_amp
id|flags
)paren
suffix:semicolon
id|ide_set_handler
c_func
(paren
id|drive
comma
op_amp
id|write_intr
comma
id|WAIT_CMD
comma
l_int|NULL
)paren
suffix:semicolon
id|taskfile_output_data
c_func
(paren
id|drive
comma
id|to
comma
id|SECTOR_WORDS
)paren
suffix:semicolon
id|ide_unmap_buffer
c_func
(paren
id|rq
comma
id|to
comma
op_amp
id|flags
)paren
suffix:semicolon
)brace
r_return
id|ide_started
suffix:semicolon
)brace
id|blk_dump_rq_flags
c_func
(paren
id|rq
comma
l_string|&quot;__ide_do_rw_disk - bad command&quot;
)paren
suffix:semicolon
id|ide_end_request
c_func
(paren
id|drive
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_return
id|ide_stopped
suffix:semicolon
)brace
DECL|variable|__ide_do_rw_disk
id|EXPORT_SYMBOL_GPL
c_func
(paren
id|__ide_do_rw_disk
)paren
suffix:semicolon
macro_line|#else /* CONFIG_IDE_TASKFILE_IO */
r_static
id|ide_startstop_t
id|chs_rw_disk
c_func
(paren
id|ide_drive_t
op_star
comma
r_struct
id|request
op_star
comma
r_int
r_int
)paren
suffix:semicolon
r_static
id|ide_startstop_t
id|lba_28_rw_disk
c_func
(paren
id|ide_drive_t
op_star
comma
r_struct
id|request
op_star
comma
r_int
r_int
)paren
suffix:semicolon
r_static
id|ide_startstop_t
id|lba_48_rw_disk
c_func
(paren
id|ide_drive_t
op_star
comma
r_struct
id|request
op_star
comma
r_int
r_int
r_int
)paren
suffix:semicolon
multiline_comment|/*&n; * __ide_do_rw_disk() issues READ and WRITE commands to a disk,&n; * using LBA if supported, or CHS otherwise, to address sectors.&n; * It also takes care of issuing special DRIVE_CMDs.&n; */
DECL|function|__ide_do_rw_disk
id|ide_startstop_t
id|__ide_do_rw_disk
(paren
id|ide_drive_t
op_star
id|drive
comma
r_struct
id|request
op_star
id|rq
comma
id|sector_t
id|block
)paren
(brace
id|BUG_ON
c_func
(paren
id|drive-&gt;blocked
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|blk_fs_request
c_func
(paren
id|rq
)paren
)paren
(brace
id|blk_dump_rq_flags
c_func
(paren
id|rq
comma
l_string|&quot;__ide_do_rw_disk - bad command&quot;
)paren
suffix:semicolon
id|ide_end_request
c_func
(paren
id|drive
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_return
id|ide_stopped
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * 268435455  == 137439 MB or 28bit limit&n;&t; *&n;&t; * need to add split taskfile operations based on 28bit threshold.&n;&t; */
r_if
c_cond
(paren
id|drive-&gt;using_tcq
op_logical_and
id|idedisk_start_tag
c_func
(paren
id|drive
comma
id|rq
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ata_pending_commands
c_func
(paren
id|drive
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_return
id|ide_started
suffix:semicolon
)brace
r_if
c_cond
(paren
id|drive-&gt;addressing
op_eq
l_int|1
)paren
multiline_comment|/* 48-bit LBA */
r_return
id|lba_48_rw_disk
c_func
(paren
id|drive
comma
id|rq
comma
(paren
r_int
r_int
r_int
)paren
id|block
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;select.b.lba
)paren
multiline_comment|/* 28-bit LBA */
r_return
id|lba_28_rw_disk
c_func
(paren
id|drive
comma
id|rq
comma
(paren
r_int
r_int
)paren
id|block
)paren
suffix:semicolon
multiline_comment|/* 28-bit CHS : DIE DIE DIE piece of legacy crap!!! */
r_return
id|chs_rw_disk
c_func
(paren
id|drive
comma
id|rq
comma
(paren
r_int
r_int
)paren
id|block
)paren
suffix:semicolon
)brace
DECL|variable|__ide_do_rw_disk
id|EXPORT_SYMBOL_GPL
c_func
(paren
id|__ide_do_rw_disk
)paren
suffix:semicolon
DECL|function|get_command
r_static
id|task_ioreg_t
id|get_command
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|cmd
)paren
(brace
r_int
id|lba48bit
op_assign
(paren
id|drive-&gt;addressing
op_eq
l_int|1
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|cmd
op_eq
id|READ
)paren
op_logical_and
id|drive-&gt;using_tcq
)paren
r_return
id|lba48bit
ques
c_cond
id|WIN_READDMA_QUEUED_EXT
suffix:colon
id|WIN_READDMA_QUEUED
suffix:semicolon
r_if
c_cond
(paren
(paren
id|cmd
op_eq
id|READ
)paren
op_logical_and
(paren
id|drive-&gt;using_dma
)paren
)paren
r_return
(paren
id|lba48bit
)paren
ques
c_cond
id|WIN_READDMA_EXT
suffix:colon
id|WIN_READDMA
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|cmd
op_eq
id|READ
)paren
op_logical_and
(paren
id|drive-&gt;mult_count
)paren
)paren
r_return
(paren
id|lba48bit
)paren
ques
c_cond
id|WIN_MULTREAD_EXT
suffix:colon
id|WIN_MULTREAD
suffix:semicolon
r_else
r_if
c_cond
(paren
id|cmd
op_eq
id|READ
)paren
r_return
(paren
id|lba48bit
)paren
ques
c_cond
id|WIN_READ_EXT
suffix:colon
id|WIN_READ
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|cmd
op_eq
id|WRITE
)paren
op_logical_and
id|drive-&gt;using_tcq
)paren
r_return
id|lba48bit
ques
c_cond
id|WIN_WRITEDMA_QUEUED_EXT
suffix:colon
id|WIN_WRITEDMA_QUEUED
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|cmd
op_eq
id|WRITE
)paren
op_logical_and
(paren
id|drive-&gt;using_dma
)paren
)paren
r_return
(paren
id|lba48bit
)paren
ques
c_cond
id|WIN_WRITEDMA_EXT
suffix:colon
id|WIN_WRITEDMA
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|cmd
op_eq
id|WRITE
)paren
op_logical_and
(paren
id|drive-&gt;mult_count
)paren
)paren
r_return
(paren
id|lba48bit
)paren
ques
c_cond
id|WIN_MULTWRITE_EXT
suffix:colon
id|WIN_MULTWRITE
suffix:semicolon
r_else
r_if
c_cond
(paren
id|cmd
op_eq
id|WRITE
)paren
r_return
(paren
id|lba48bit
)paren
ques
c_cond
id|WIN_WRITE_EXT
suffix:colon
id|WIN_WRITE
suffix:semicolon
r_else
r_return
id|WIN_NOP
suffix:semicolon
)brace
DECL|function|chs_rw_disk
r_static
id|ide_startstop_t
id|chs_rw_disk
(paren
id|ide_drive_t
op_star
id|drive
comma
r_struct
id|request
op_star
id|rq
comma
r_int
r_int
id|block
)paren
(brace
id|ide_task_t
id|args
suffix:semicolon
r_int
id|sectors
suffix:semicolon
id|ata_nsector_t
id|nsectors
suffix:semicolon
id|task_ioreg_t
id|command
op_assign
id|get_command
c_func
(paren
id|drive
comma
id|rq_data_dir
c_func
(paren
id|rq
)paren
)paren
suffix:semicolon
r_int
r_int
id|track
op_assign
(paren
id|block
op_div
id|drive-&gt;sect
)paren
suffix:semicolon
r_int
r_int
id|sect
op_assign
(paren
id|block
op_mod
id|drive-&gt;sect
)paren
op_plus
l_int|1
suffix:semicolon
r_int
r_int
id|head
op_assign
(paren
id|track
op_mod
id|drive-&gt;head
)paren
suffix:semicolon
r_int
r_int
id|cyl
op_assign
(paren
id|track
op_div
id|drive-&gt;head
)paren
suffix:semicolon
id|nsectors.all
op_assign
(paren
id|u16
)paren
id|rq-&gt;nr_sectors
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;%s: %sing: &quot;
comma
id|drive-&gt;name
comma
(paren
id|rq_data_dir
c_func
(paren
id|rq
)paren
op_eq
id|READ
)paren
ques
c_cond
l_string|&quot;read&quot;
suffix:colon
l_string|&quot;writ&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;CHS=%d/%d/%d, &quot;
comma
id|cyl
comma
id|head
comma
id|sect
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;sectors=%ld, &quot;
comma
id|rq-&gt;nr_sectors
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;buffer=0x%08lx&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|rq-&gt;buffer
)paren
suffix:semicolon
macro_line|#endif
id|memset
c_func
(paren
op_amp
id|args
comma
l_int|0
comma
r_sizeof
(paren
id|ide_task_t
)paren
)paren
suffix:semicolon
id|sectors
op_assign
(paren
id|rq-&gt;nr_sectors
op_eq
l_int|256
)paren
ques
c_cond
l_int|0x00
suffix:colon
id|rq-&gt;nr_sectors
suffix:semicolon
r_if
c_cond
(paren
id|blk_rq_tagged
c_func
(paren
id|rq
)paren
)paren
(brace
id|args.tfRegister
(braket
id|IDE_FEATURE_OFFSET
)braket
op_assign
id|sectors
suffix:semicolon
id|args.tfRegister
(braket
id|IDE_NSECTOR_OFFSET
)braket
op_assign
id|rq-&gt;tag
op_lshift
l_int|3
suffix:semicolon
)brace
r_else
id|args.tfRegister
(braket
id|IDE_NSECTOR_OFFSET
)braket
op_assign
id|sectors
suffix:semicolon
id|args.tfRegister
(braket
id|IDE_SECTOR_OFFSET
)braket
op_assign
id|sect
suffix:semicolon
id|args.tfRegister
(braket
id|IDE_LCYL_OFFSET
)braket
op_assign
id|cyl
suffix:semicolon
id|args.tfRegister
(braket
id|IDE_HCYL_OFFSET
)braket
op_assign
(paren
id|cyl
op_rshift
l_int|8
)paren
suffix:semicolon
id|args.tfRegister
(braket
id|IDE_SELECT_OFFSET
)braket
op_assign
id|head
suffix:semicolon
id|args.tfRegister
(braket
id|IDE_SELECT_OFFSET
)braket
op_or_assign
id|drive-&gt;select.all
suffix:semicolon
id|args.tfRegister
(braket
id|IDE_COMMAND_OFFSET
)braket
op_assign
id|command
suffix:semicolon
id|args.command_type
op_assign
id|ide_cmd_type_parser
c_func
(paren
op_amp
id|args
)paren
suffix:semicolon
id|args.rq
op_assign
(paren
r_struct
id|request
op_star
)paren
id|rq
suffix:semicolon
id|rq-&gt;special
op_assign
(paren
id|ide_task_t
op_star
)paren
op_amp
id|args
suffix:semicolon
r_return
id|do_rw_taskfile
c_func
(paren
id|drive
comma
op_amp
id|args
)paren
suffix:semicolon
)brace
DECL|function|lba_28_rw_disk
r_static
id|ide_startstop_t
id|lba_28_rw_disk
(paren
id|ide_drive_t
op_star
id|drive
comma
r_struct
id|request
op_star
id|rq
comma
r_int
r_int
id|block
)paren
(brace
id|ide_task_t
id|args
suffix:semicolon
r_int
id|sectors
suffix:semicolon
id|ata_nsector_t
id|nsectors
suffix:semicolon
id|task_ioreg_t
id|command
op_assign
id|get_command
c_func
(paren
id|drive
comma
id|rq_data_dir
c_func
(paren
id|rq
)paren
)paren
suffix:semicolon
id|nsectors.all
op_assign
(paren
id|u16
)paren
id|rq-&gt;nr_sectors
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;%s: %sing: &quot;
comma
id|drive-&gt;name
comma
(paren
id|rq_data_dir
c_func
(paren
id|rq
)paren
op_eq
id|READ
)paren
ques
c_cond
l_string|&quot;read&quot;
suffix:colon
l_string|&quot;writ&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;LBAsect=%lld, &quot;
comma
id|block
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;sectors=%ld, &quot;
comma
id|rq-&gt;nr_sectors
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;buffer=0x%08lx&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|rq-&gt;buffer
)paren
suffix:semicolon
macro_line|#endif
id|memset
c_func
(paren
op_amp
id|args
comma
l_int|0
comma
r_sizeof
(paren
id|ide_task_t
)paren
)paren
suffix:semicolon
id|sectors
op_assign
(paren
id|rq-&gt;nr_sectors
op_eq
l_int|256
)paren
ques
c_cond
l_int|0x00
suffix:colon
id|rq-&gt;nr_sectors
suffix:semicolon
r_if
c_cond
(paren
id|blk_rq_tagged
c_func
(paren
id|rq
)paren
)paren
(brace
id|args.tfRegister
(braket
id|IDE_FEATURE_OFFSET
)braket
op_assign
id|sectors
suffix:semicolon
id|args.tfRegister
(braket
id|IDE_NSECTOR_OFFSET
)braket
op_assign
id|rq-&gt;tag
op_lshift
l_int|3
suffix:semicolon
)brace
r_else
id|args.tfRegister
(braket
id|IDE_NSECTOR_OFFSET
)braket
op_assign
id|sectors
suffix:semicolon
id|args.tfRegister
(braket
id|IDE_SECTOR_OFFSET
)braket
op_assign
id|block
suffix:semicolon
id|args.tfRegister
(braket
id|IDE_LCYL_OFFSET
)braket
op_assign
(paren
id|block
op_rshift_assign
l_int|8
)paren
suffix:semicolon
id|args.tfRegister
(braket
id|IDE_HCYL_OFFSET
)braket
op_assign
(paren
id|block
op_rshift_assign
l_int|8
)paren
suffix:semicolon
id|args.tfRegister
(braket
id|IDE_SELECT_OFFSET
)braket
op_assign
(paren
(paren
id|block
op_rshift
l_int|8
)paren
op_amp
l_int|0x0f
)paren
suffix:semicolon
id|args.tfRegister
(braket
id|IDE_SELECT_OFFSET
)braket
op_or_assign
id|drive-&gt;select.all
suffix:semicolon
id|args.tfRegister
(braket
id|IDE_COMMAND_OFFSET
)braket
op_assign
id|command
suffix:semicolon
id|args.command_type
op_assign
id|ide_cmd_type_parser
c_func
(paren
op_amp
id|args
)paren
suffix:semicolon
id|args.rq
op_assign
(paren
r_struct
id|request
op_star
)paren
id|rq
suffix:semicolon
id|rq-&gt;special
op_assign
(paren
id|ide_task_t
op_star
)paren
op_amp
id|args
suffix:semicolon
r_return
id|do_rw_taskfile
c_func
(paren
id|drive
comma
op_amp
id|args
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * 268435455  == 137439 MB or 28bit limit&n; * 320173056  == 163929 MB or 48bit addressing&n; * 1073741822 == 549756 MB or 48bit addressing fake drive&n; */
DECL|function|lba_48_rw_disk
r_static
id|ide_startstop_t
id|lba_48_rw_disk
(paren
id|ide_drive_t
op_star
id|drive
comma
r_struct
id|request
op_star
id|rq
comma
r_int
r_int
r_int
id|block
)paren
(brace
id|ide_task_t
id|args
suffix:semicolon
r_int
id|sectors
suffix:semicolon
id|ata_nsector_t
id|nsectors
suffix:semicolon
id|task_ioreg_t
id|command
op_assign
id|get_command
c_func
(paren
id|drive
comma
id|rq_data_dir
c_func
(paren
id|rq
)paren
)paren
suffix:semicolon
id|nsectors.all
op_assign
(paren
id|u16
)paren
id|rq-&gt;nr_sectors
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;%s: %sing: &quot;
comma
id|drive-&gt;name
comma
(paren
id|rq_data_dir
c_func
(paren
id|rq
)paren
op_eq
id|READ
)paren
ques
c_cond
l_string|&quot;read&quot;
suffix:colon
l_string|&quot;writ&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;LBAsect=%lld, &quot;
comma
id|block
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;sectors=%ld, &quot;
comma
id|rq-&gt;nr_sectors
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;buffer=0x%08lx&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|rq-&gt;buffer
)paren
suffix:semicolon
macro_line|#endif
id|memset
c_func
(paren
op_amp
id|args
comma
l_int|0
comma
r_sizeof
(paren
id|ide_task_t
)paren
)paren
suffix:semicolon
id|sectors
op_assign
(paren
id|rq-&gt;nr_sectors
op_eq
l_int|65536
)paren
ques
c_cond
l_int|0
suffix:colon
id|rq-&gt;nr_sectors
suffix:semicolon
r_if
c_cond
(paren
id|blk_rq_tagged
c_func
(paren
id|rq
)paren
)paren
(brace
id|args.tfRegister
(braket
id|IDE_FEATURE_OFFSET
)braket
op_assign
id|sectors
suffix:semicolon
id|args.tfRegister
(braket
id|IDE_NSECTOR_OFFSET
)braket
op_assign
id|rq-&gt;tag
op_lshift
l_int|3
suffix:semicolon
id|args.hobRegister
(braket
id|IDE_FEATURE_OFFSET_HOB
)braket
op_assign
id|sectors
op_rshift
l_int|8
suffix:semicolon
id|args.hobRegister
(braket
id|IDE_NSECTOR_OFFSET_HOB
)braket
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|args.tfRegister
(braket
id|IDE_NSECTOR_OFFSET
)braket
op_assign
id|sectors
suffix:semicolon
id|args.hobRegister
(braket
id|IDE_NSECTOR_OFFSET_HOB
)braket
op_assign
id|sectors
op_rshift
l_int|8
suffix:semicolon
)brace
id|args.tfRegister
(braket
id|IDE_SECTOR_OFFSET
)braket
op_assign
id|block
suffix:semicolon
multiline_comment|/* low lba */
id|args.tfRegister
(braket
id|IDE_LCYL_OFFSET
)braket
op_assign
(paren
id|block
op_rshift_assign
l_int|8
)paren
suffix:semicolon
multiline_comment|/* mid lba */
id|args.tfRegister
(braket
id|IDE_HCYL_OFFSET
)braket
op_assign
(paren
id|block
op_rshift_assign
l_int|8
)paren
suffix:semicolon
multiline_comment|/* hi  lba */
id|args.tfRegister
(braket
id|IDE_SELECT_OFFSET
)braket
op_assign
id|drive-&gt;select.all
suffix:semicolon
id|args.tfRegister
(braket
id|IDE_COMMAND_OFFSET
)braket
op_assign
id|command
suffix:semicolon
id|args.hobRegister
(braket
id|IDE_SECTOR_OFFSET_HOB
)braket
op_assign
(paren
id|block
op_rshift_assign
l_int|8
)paren
suffix:semicolon
multiline_comment|/* low lba */
id|args.hobRegister
(braket
id|IDE_LCYL_OFFSET_HOB
)braket
op_assign
(paren
id|block
op_rshift_assign
l_int|8
)paren
suffix:semicolon
multiline_comment|/* mid lba */
id|args.hobRegister
(braket
id|IDE_HCYL_OFFSET_HOB
)braket
op_assign
(paren
id|block
op_rshift_assign
l_int|8
)paren
suffix:semicolon
multiline_comment|/* hi  lba */
id|args.hobRegister
(braket
id|IDE_SELECT_OFFSET_HOB
)braket
op_assign
id|drive-&gt;select.all
suffix:semicolon
id|args.hobRegister
(braket
id|IDE_CONTROL_OFFSET_HOB
)braket
op_assign
(paren
id|drive-&gt;ctl
op_or
l_int|0x80
)paren
suffix:semicolon
id|args.command_type
op_assign
id|ide_cmd_type_parser
c_func
(paren
op_amp
id|args
)paren
suffix:semicolon
id|args.rq
op_assign
(paren
r_struct
id|request
op_star
)paren
id|rq
suffix:semicolon
id|rq-&gt;special
op_assign
(paren
id|ide_task_t
op_star
)paren
op_amp
id|args
suffix:semicolon
r_return
id|do_rw_taskfile
c_func
(paren
id|drive
comma
op_amp
id|args
)paren
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_IDE_TASKFILE_IO */
DECL|function|ide_do_rw_disk
r_static
id|ide_startstop_t
id|ide_do_rw_disk
(paren
id|ide_drive_t
op_star
id|drive
comma
r_struct
id|request
op_star
id|rq
comma
id|sector_t
id|block
)paren
(brace
id|ide_hwif_t
op_star
id|hwif
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hwif-&gt;rw_disk
)paren
r_return
id|hwif
op_member_access_from_pointer
id|rw_disk
c_func
(paren
id|drive
comma
id|rq
comma
id|block
)paren
suffix:semicolon
r_else
r_return
id|__ide_do_rw_disk
c_func
(paren
id|drive
comma
id|rq
comma
id|block
)paren
suffix:semicolon
)brace
r_static
r_int
id|do_idedisk_flushcache
c_func
(paren
id|ide_drive_t
op_star
id|drive
)paren
suffix:semicolon
DECL|function|idedisk_dump_status
r_static
id|u8
id|idedisk_dump_status
(paren
id|ide_drive_t
op_star
id|drive
comma
r_const
r_char
op_star
id|msg
comma
id|u8
id|stat
)paren
(brace
id|ide_hwif_t
op_star
id|hwif
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|u8
id|err
op_assign
l_int|0
suffix:semicolon
id|local_irq_set
c_func
(paren
id|flags
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: %s: status=0x%02x&quot;
comma
id|drive-&gt;name
comma
id|msg
comma
id|stat
)paren
suffix:semicolon
macro_line|#if FANCY_STATUS_DUMPS
id|printk
c_func
(paren
l_string|&quot; { &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_amp
id|BUSY_STAT
)paren
id|printk
c_func
(paren
l_string|&quot;Busy &quot;
)paren
suffix:semicolon
r_else
(brace
r_if
c_cond
(paren
id|stat
op_amp
id|READY_STAT
)paren
id|printk
c_func
(paren
l_string|&quot;DriveReady &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_amp
id|WRERR_STAT
)paren
id|printk
c_func
(paren
l_string|&quot;DeviceFault &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_amp
id|SEEK_STAT
)paren
id|printk
c_func
(paren
l_string|&quot;SeekComplete &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_amp
id|DRQ_STAT
)paren
id|printk
c_func
(paren
l_string|&quot;DataRequest &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_amp
id|ECC_STAT
)paren
id|printk
c_func
(paren
l_string|&quot;CorrectedError &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_amp
id|INDEX_STAT
)paren
id|printk
c_func
(paren
l_string|&quot;Index &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_amp
id|ERR_STAT
)paren
id|printk
c_func
(paren
l_string|&quot;Error &quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;}&quot;
)paren
suffix:semicolon
macro_line|#endif&t;/* FANCY_STATUS_DUMPS */
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|stat
op_amp
(paren
id|BUSY_STAT
op_or
id|ERR_STAT
)paren
)paren
op_eq
id|ERR_STAT
)paren
(brace
id|err
op_assign
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_ERROR_REG
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: %s: error=0x%02x&quot;
comma
id|drive-&gt;name
comma
id|msg
comma
id|err
)paren
suffix:semicolon
macro_line|#if FANCY_STATUS_DUMPS
id|printk
c_func
(paren
l_string|&quot; { &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_amp
id|ABRT_ERR
)paren
id|printk
c_func
(paren
l_string|&quot;DriveStatusError &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_amp
id|ICRC_ERR
)paren
id|printk
c_func
(paren
l_string|&quot;Bad%s &quot;
comma
(paren
id|err
op_amp
id|ABRT_ERR
)paren
ques
c_cond
l_string|&quot;CRC&quot;
suffix:colon
l_string|&quot;Sector&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_amp
id|ECC_ERR
)paren
id|printk
c_func
(paren
l_string|&quot;UncorrectableError &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_amp
id|ID_ERR
)paren
id|printk
c_func
(paren
l_string|&quot;SectorIdNotFound &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_amp
id|TRK0_ERR
)paren
id|printk
c_func
(paren
l_string|&quot;TrackZeroNotFound &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_amp
id|MARK_ERR
)paren
id|printk
c_func
(paren
l_string|&quot;AddrMarkNotFound &quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;}&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_amp
(paren
id|BBD_ERR
op_or
id|ABRT_ERR
)paren
)paren
op_eq
id|BBD_ERR
op_logical_or
(paren
id|err
op_amp
(paren
id|ECC_ERR
op_or
id|ID_ERR
op_or
id|MARK_ERR
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|drive-&gt;addressing
op_eq
l_int|1
)paren
(brace
id|__u64
id|sectors
op_assign
l_int|0
suffix:semicolon
id|u32
id|low
op_assign
l_int|0
comma
id|high
op_assign
l_int|0
suffix:semicolon
id|low
op_assign
id|ide_read_24
c_func
(paren
id|drive
)paren
suffix:semicolon
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|drive-&gt;ctl
op_or
l_int|0x80
comma
id|IDE_CONTROL_REG
)paren
suffix:semicolon
id|high
op_assign
id|ide_read_24
c_func
(paren
id|drive
)paren
suffix:semicolon
id|sectors
op_assign
(paren
(paren
id|__u64
)paren
id|high
op_lshift
l_int|24
)paren
op_or
id|low
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;, LBAsect=%llu, high=%d, low=%d&quot;
comma
(paren
r_int
r_int
r_int
)paren
id|sectors
comma
id|high
comma
id|low
)paren
suffix:semicolon
)brace
r_else
(brace
id|u8
id|cur
op_assign
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_SELECT_REG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cur
op_amp
l_int|0x40
)paren
(brace
multiline_comment|/* using LBA? */
id|printk
c_func
(paren
l_string|&quot;, LBAsect=%ld&quot;
comma
(paren
r_int
r_int
)paren
(paren
(paren
id|cur
op_amp
l_int|0xf
)paren
op_lshift
l_int|24
)paren
op_or
(paren
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_HCYL_REG
)paren
op_lshift
l_int|16
)paren
op_or
(paren
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_LCYL_REG
)paren
op_lshift
l_int|8
)paren
op_or
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_SECTOR_REG
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;, CHS=%d/%d/%d&quot;
comma
(paren
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_HCYL_REG
)paren
op_lshift
l_int|8
)paren
op_plus
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_LCYL_REG
)paren
comma
id|cur
op_amp
l_int|0xf
comma
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_SECTOR_REG
)paren
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|HWGROUP
c_func
(paren
id|drive
)paren
op_logical_and
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
)paren
id|printk
c_func
(paren
l_string|&quot;, sector=%llu&quot;
comma
(paren
r_int
r_int
r_int
)paren
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq-&gt;sector
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif&t;/* FANCY_STATUS_DUMPS */
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|local_irq_restore
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|function|idedisk_error
id|ide_startstop_t
id|idedisk_error
(paren
id|ide_drive_t
op_star
id|drive
comma
r_const
r_char
op_star
id|msg
comma
id|u8
id|stat
)paren
(brace
id|ide_hwif_t
op_star
id|hwif
suffix:semicolon
r_struct
id|request
op_star
id|rq
suffix:semicolon
id|u8
id|err
suffix:semicolon
r_int
id|i
op_assign
(paren
id|drive-&gt;mult_count
ques
c_cond
id|drive-&gt;mult_count
suffix:colon
l_int|1
)paren
op_star
id|SECTOR_WORDS
suffix:semicolon
id|err
op_assign
id|idedisk_dump_status
c_func
(paren
id|drive
comma
id|msg
comma
id|stat
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drive
op_eq
l_int|NULL
op_logical_or
(paren
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
)paren
op_eq
l_int|NULL
)paren
r_return
id|ide_stopped
suffix:semicolon
id|hwif
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
suffix:semicolon
multiline_comment|/* retry only &quot;normal&quot; I/O: */
r_if
c_cond
(paren
id|rq-&gt;flags
op_amp
(paren
id|REQ_DRIVE_CMD
op_or
id|REQ_DRIVE_TASK
op_or
id|REQ_DRIVE_TASKFILE
)paren
)paren
(brace
id|rq-&gt;errors
op_assign
l_int|1
suffix:semicolon
id|ide_end_drive_cmd
c_func
(paren
id|drive
comma
id|stat
comma
id|err
)paren
suffix:semicolon
r_return
id|ide_stopped
suffix:semicolon
)brace
macro_line|#if 0
r_else
r_if
c_cond
(paren
id|rq-&gt;flags
op_amp
id|REQ_DRIVE_TASKFILE
)paren
(brace
id|rq-&gt;errors
op_assign
l_int|1
suffix:semicolon
id|ide_end_taskfile
c_func
(paren
id|drive
comma
id|stat
comma
id|err
)paren
suffix:semicolon
r_return
id|ide_stopped
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifdef CONFIG_IDE_TASKFILE_IO
multiline_comment|/* make rq completion pointers new submission pointers */
id|blk_rq_prep_restart
c_func
(paren
id|rq
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|stat
op_amp
id|BUSY_STAT
op_logical_or
(paren
(paren
id|stat
op_amp
id|WRERR_STAT
)paren
op_logical_and
op_logical_neg
id|drive-&gt;nowerr
)paren
)paren
(brace
multiline_comment|/* other bits are useless when BUSY */
id|rq-&gt;errors
op_or_assign
id|ERROR_RESET
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|stat
op_amp
id|ERR_STAT
)paren
(brace
multiline_comment|/* err has different meaning on cdrom and tape */
r_if
c_cond
(paren
id|err
op_eq
id|ABRT_ERR
)paren
(brace
r_if
c_cond
(paren
id|drive-&gt;select.b.lba
op_logical_and
multiline_comment|/* some newer drives don&squot;t support WIN_SPECIFY */
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_COMMAND_REG
)paren
op_eq
id|WIN_SPECIFY
)paren
r_return
id|ide_stopped
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|err
op_amp
id|BAD_CRC
)paren
op_eq
id|BAD_CRC
)paren
(brace
multiline_comment|/* UDMA crc error, just retry the operation */
id|drive-&gt;crc_count
op_increment
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|err
op_amp
(paren
id|BBD_ERR
op_or
id|ECC_ERR
)paren
)paren
(brace
multiline_comment|/* retries won&squot;t help these */
id|rq-&gt;errors
op_assign
id|ERROR_MAX
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|err
op_amp
id|TRK0_ERR
)paren
(brace
multiline_comment|/* help it find track zero */
id|rq-&gt;errors
op_or_assign
id|ERROR_RECAL
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
(paren
id|stat
op_amp
id|DRQ_STAT
)paren
op_logical_and
id|rq_data_dir
c_func
(paren
id|rq
)paren
op_eq
id|READ
)paren
(brace
multiline_comment|/*&n;&t;&t; * try_to_flush_leftover_data() is invoked in response to&n;&t;&t; * a drive unexpectedly having its DRQ_STAT bit set.  As&n;&t;&t; * an alternative to resetting the drive, this routine&n;&t;&t; * tries to clear the condition by read a sector&squot;s worth&n;&t;&t; * of data from the drive.  Of course, this may not help&n;&t;&t; * if the drive is *waiting* for data from *us*.&n;&t;&t; */
r_while
c_loop
(paren
id|i
OG
l_int|0
)paren
(brace
id|u32
id|buffer
(braket
l_int|16
)braket
suffix:semicolon
r_int
r_int
id|wcount
op_assign
(paren
id|i
OG
l_int|16
)paren
ques
c_cond
l_int|16
suffix:colon
id|i
suffix:semicolon
id|i
op_sub_assign
id|wcount
suffix:semicolon
id|taskfile_input_data
c_func
(paren
id|drive
comma
id|buffer
comma
id|wcount
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_STATUS_REG
)paren
op_amp
(paren
id|BUSY_STAT
op_or
id|DRQ_STAT
)paren
)paren
(brace
multiline_comment|/* force an abort */
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|WIN_IDLEIMMEDIATE
comma
id|IDE_COMMAND_REG
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rq-&gt;errors
op_ge
id|ERROR_MAX
op_logical_or
id|blk_noretry_request
c_func
(paren
id|rq
)paren
)paren
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|end_request
c_func
(paren
id|drive
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_else
(brace
r_if
c_cond
(paren
(paren
id|rq-&gt;errors
op_amp
id|ERROR_RESET
)paren
op_eq
id|ERROR_RESET
)paren
(brace
op_increment
id|rq-&gt;errors
suffix:semicolon
r_return
id|ide_do_reset
c_func
(paren
id|drive
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|rq-&gt;errors
op_amp
id|ERROR_RECAL
)paren
op_eq
id|ERROR_RECAL
)paren
id|drive-&gt;special.b.recalibrate
op_assign
l_int|1
suffix:semicolon
op_increment
id|rq-&gt;errors
suffix:semicolon
)brace
r_return
id|ide_stopped
suffix:semicolon
)brace
DECL|function|idedisk_abort
id|ide_startstop_t
id|idedisk_abort
c_func
(paren
id|ide_drive_t
op_star
id|drive
comma
r_const
r_char
op_star
id|msg
)paren
(brace
id|ide_hwif_t
op_star
id|hwif
suffix:semicolon
r_struct
id|request
op_star
id|rq
suffix:semicolon
r_if
c_cond
(paren
id|drive
op_eq
l_int|NULL
op_logical_or
(paren
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
)paren
op_eq
l_int|NULL
)paren
r_return
id|ide_stopped
suffix:semicolon
id|hwif
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rq-&gt;flags
op_amp
(paren
id|REQ_DRIVE_CMD
op_or
id|REQ_DRIVE_TASK
op_or
id|REQ_DRIVE_TASKFILE
)paren
)paren
(brace
id|rq-&gt;errors
op_assign
l_int|1
suffix:semicolon
id|ide_end_drive_cmd
c_func
(paren
id|drive
comma
id|BUSY_STAT
comma
l_int|0
)paren
suffix:semicolon
r_return
id|ide_stopped
suffix:semicolon
)brace
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|end_request
c_func
(paren
id|drive
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_return
id|ide_stopped
suffix:semicolon
)brace
multiline_comment|/*&n; * Queries for true maximum capacity of the drive.&n; * Returns maximum LBA address (&gt; 0) of the drive, 0 if failed.&n; */
DECL|function|idedisk_read_native_max_address
r_static
r_int
r_int
id|idedisk_read_native_max_address
c_func
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|ide_task_t
id|args
suffix:semicolon
r_int
r_int
id|addr
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Create IDE/ATA command request structure */
id|memset
c_func
(paren
op_amp
id|args
comma
l_int|0
comma
r_sizeof
(paren
id|ide_task_t
)paren
)paren
suffix:semicolon
id|args.tfRegister
(braket
id|IDE_SELECT_OFFSET
)braket
op_assign
l_int|0x40
suffix:semicolon
id|args.tfRegister
(braket
id|IDE_COMMAND_OFFSET
)braket
op_assign
id|WIN_READ_NATIVE_MAX
suffix:semicolon
id|args.command_type
op_assign
id|ide_cmd_type_parser
c_func
(paren
op_amp
id|args
)paren
suffix:semicolon
multiline_comment|/* submit command request */
id|ide_raw_taskfile
c_func
(paren
id|drive
comma
op_amp
id|args
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* if OK, compute maximum address value */
r_if
c_cond
(paren
(paren
id|args.tfRegister
(braket
id|IDE_STATUS_OFFSET
)braket
op_amp
l_int|0x01
)paren
op_eq
l_int|0
)paren
(brace
id|addr
op_assign
(paren
(paren
id|args.tfRegister
(braket
id|IDE_SELECT_OFFSET
)braket
op_amp
l_int|0x0f
)paren
op_lshift
l_int|24
)paren
op_or
(paren
(paren
id|args.tfRegister
(braket
id|IDE_HCYL_OFFSET
)braket
)paren
op_lshift
l_int|16
)paren
op_or
(paren
(paren
id|args.tfRegister
(braket
id|IDE_LCYL_OFFSET
)braket
)paren
op_lshift
l_int|8
)paren
op_or
(paren
(paren
id|args.tfRegister
(braket
id|IDE_SECTOR_OFFSET
)braket
)paren
)paren
suffix:semicolon
id|addr
op_increment
suffix:semicolon
multiline_comment|/* since the return value is (maxlba - 1), we add 1 */
)brace
r_return
id|addr
suffix:semicolon
)brace
DECL|function|idedisk_read_native_max_address_ext
r_static
r_int
r_int
r_int
id|idedisk_read_native_max_address_ext
c_func
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|ide_task_t
id|args
suffix:semicolon
r_int
r_int
r_int
id|addr
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Create IDE/ATA command request structure */
id|memset
c_func
(paren
op_amp
id|args
comma
l_int|0
comma
r_sizeof
(paren
id|ide_task_t
)paren
)paren
suffix:semicolon
id|args.tfRegister
(braket
id|IDE_SELECT_OFFSET
)braket
op_assign
l_int|0x40
suffix:semicolon
id|args.tfRegister
(braket
id|IDE_COMMAND_OFFSET
)braket
op_assign
id|WIN_READ_NATIVE_MAX_EXT
suffix:semicolon
id|args.command_type
op_assign
id|ide_cmd_type_parser
c_func
(paren
op_amp
id|args
)paren
suffix:semicolon
multiline_comment|/* submit command request */
id|ide_raw_taskfile
c_func
(paren
id|drive
comma
op_amp
id|args
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* if OK, compute maximum address value */
r_if
c_cond
(paren
(paren
id|args.tfRegister
(braket
id|IDE_STATUS_OFFSET
)braket
op_amp
l_int|0x01
)paren
op_eq
l_int|0
)paren
(brace
id|u32
id|high
op_assign
(paren
(paren
id|args.hobRegister
(braket
id|IDE_HCYL_OFFSET_HOB
)braket
)paren
op_lshift
l_int|16
)paren
op_or
(paren
(paren
id|args.hobRegister
(braket
id|IDE_LCYL_OFFSET_HOB
)braket
)paren
op_lshift
l_int|8
)paren
op_or
(paren
id|args.hobRegister
(braket
id|IDE_SECTOR_OFFSET_HOB
)braket
)paren
suffix:semicolon
id|u32
id|low
op_assign
(paren
(paren
id|args.tfRegister
(braket
id|IDE_HCYL_OFFSET
)braket
)paren
op_lshift
l_int|16
)paren
op_or
(paren
(paren
id|args.tfRegister
(braket
id|IDE_LCYL_OFFSET
)braket
)paren
op_lshift
l_int|8
)paren
op_or
(paren
id|args.tfRegister
(braket
id|IDE_SECTOR_OFFSET
)braket
)paren
suffix:semicolon
id|addr
op_assign
(paren
(paren
id|__u64
)paren
id|high
op_lshift
l_int|24
)paren
op_or
id|low
suffix:semicolon
id|addr
op_increment
suffix:semicolon
multiline_comment|/* since the return value is (maxlba - 1), we add 1 */
)brace
r_return
id|addr
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_IDEDISK_STROKE
multiline_comment|/*&n; * Sets maximum virtual LBA address of the drive.&n; * Returns new maximum virtual LBA address (&gt; 0) or 0 on failure.&n; */
DECL|function|idedisk_set_max_address
r_static
r_int
r_int
id|idedisk_set_max_address
c_func
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
r_int
id|addr_req
)paren
(brace
id|ide_task_t
id|args
suffix:semicolon
r_int
r_int
id|addr_set
op_assign
l_int|0
suffix:semicolon
id|addr_req
op_decrement
suffix:semicolon
multiline_comment|/* Create IDE/ATA command request structure */
id|memset
c_func
(paren
op_amp
id|args
comma
l_int|0
comma
r_sizeof
(paren
id|ide_task_t
)paren
)paren
suffix:semicolon
id|args.tfRegister
(braket
id|IDE_SECTOR_OFFSET
)braket
op_assign
(paren
(paren
id|addr_req
op_rshift
l_int|0
)paren
op_amp
l_int|0xff
)paren
suffix:semicolon
id|args.tfRegister
(braket
id|IDE_LCYL_OFFSET
)braket
op_assign
(paren
(paren
id|addr_req
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
)paren
suffix:semicolon
id|args.tfRegister
(braket
id|IDE_HCYL_OFFSET
)braket
op_assign
(paren
(paren
id|addr_req
op_rshift
l_int|16
)paren
op_amp
l_int|0xff
)paren
suffix:semicolon
id|args.tfRegister
(braket
id|IDE_SELECT_OFFSET
)braket
op_assign
(paren
(paren
id|addr_req
op_rshift
l_int|24
)paren
op_amp
l_int|0x0f
)paren
op_or
l_int|0x40
suffix:semicolon
id|args.tfRegister
(braket
id|IDE_COMMAND_OFFSET
)braket
op_assign
id|WIN_SET_MAX
suffix:semicolon
id|args.command_type
op_assign
id|ide_cmd_type_parser
c_func
(paren
op_amp
id|args
)paren
suffix:semicolon
multiline_comment|/* submit command request */
id|ide_raw_taskfile
c_func
(paren
id|drive
comma
op_amp
id|args
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* if OK, read new maximum address value */
r_if
c_cond
(paren
(paren
id|args.tfRegister
(braket
id|IDE_STATUS_OFFSET
)braket
op_amp
l_int|0x01
)paren
op_eq
l_int|0
)paren
(brace
id|addr_set
op_assign
(paren
(paren
id|args.tfRegister
(braket
id|IDE_SELECT_OFFSET
)braket
op_amp
l_int|0x0f
)paren
op_lshift
l_int|24
)paren
op_or
(paren
(paren
id|args.tfRegister
(braket
id|IDE_HCYL_OFFSET
)braket
)paren
op_lshift
l_int|16
)paren
op_or
(paren
(paren
id|args.tfRegister
(braket
id|IDE_LCYL_OFFSET
)braket
)paren
op_lshift
l_int|8
)paren
op_or
(paren
(paren
id|args.tfRegister
(braket
id|IDE_SECTOR_OFFSET
)braket
)paren
)paren
suffix:semicolon
id|addr_set
op_increment
suffix:semicolon
)brace
r_return
id|addr_set
suffix:semicolon
)brace
DECL|function|idedisk_set_max_address_ext
r_static
r_int
r_int
r_int
id|idedisk_set_max_address_ext
c_func
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
r_int
r_int
id|addr_req
)paren
(brace
id|ide_task_t
id|args
suffix:semicolon
r_int
r_int
r_int
id|addr_set
op_assign
l_int|0
suffix:semicolon
id|addr_req
op_decrement
suffix:semicolon
multiline_comment|/* Create IDE/ATA command request structure */
id|memset
c_func
(paren
op_amp
id|args
comma
l_int|0
comma
r_sizeof
(paren
id|ide_task_t
)paren
)paren
suffix:semicolon
id|args.tfRegister
(braket
id|IDE_SECTOR_OFFSET
)braket
op_assign
(paren
(paren
id|addr_req
op_rshift
l_int|0
)paren
op_amp
l_int|0xff
)paren
suffix:semicolon
id|args.tfRegister
(braket
id|IDE_LCYL_OFFSET
)braket
op_assign
(paren
(paren
id|addr_req
op_rshift_assign
l_int|8
)paren
op_amp
l_int|0xff
)paren
suffix:semicolon
id|args.tfRegister
(braket
id|IDE_HCYL_OFFSET
)braket
op_assign
(paren
(paren
id|addr_req
op_rshift_assign
l_int|8
)paren
op_amp
l_int|0xff
)paren
suffix:semicolon
id|args.tfRegister
(braket
id|IDE_SELECT_OFFSET
)braket
op_assign
l_int|0x40
suffix:semicolon
id|args.tfRegister
(braket
id|IDE_COMMAND_OFFSET
)braket
op_assign
id|WIN_SET_MAX_EXT
suffix:semicolon
id|args.hobRegister
(braket
id|IDE_SECTOR_OFFSET_HOB
)braket
op_assign
(paren
(paren
id|addr_req
op_rshift_assign
l_int|8
)paren
op_amp
l_int|0xff
)paren
suffix:semicolon
id|args.hobRegister
(braket
id|IDE_LCYL_OFFSET_HOB
)braket
op_assign
(paren
(paren
id|addr_req
op_rshift_assign
l_int|8
)paren
op_amp
l_int|0xff
)paren
suffix:semicolon
id|args.hobRegister
(braket
id|IDE_HCYL_OFFSET_HOB
)braket
op_assign
(paren
(paren
id|addr_req
op_rshift_assign
l_int|8
)paren
op_amp
l_int|0xff
)paren
suffix:semicolon
id|args.hobRegister
(braket
id|IDE_SELECT_OFFSET_HOB
)braket
op_assign
l_int|0x40
suffix:semicolon
id|args.hobRegister
(braket
id|IDE_CONTROL_OFFSET_HOB
)braket
op_assign
(paren
id|drive-&gt;ctl
op_or
l_int|0x80
)paren
suffix:semicolon
id|args.command_type
op_assign
id|ide_cmd_type_parser
c_func
(paren
op_amp
id|args
)paren
suffix:semicolon
multiline_comment|/* submit command request */
id|ide_raw_taskfile
c_func
(paren
id|drive
comma
op_amp
id|args
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* if OK, compute maximum address value */
r_if
c_cond
(paren
(paren
id|args.tfRegister
(braket
id|IDE_STATUS_OFFSET
)braket
op_amp
l_int|0x01
)paren
op_eq
l_int|0
)paren
(brace
id|u32
id|high
op_assign
(paren
(paren
id|args.hobRegister
(braket
id|IDE_HCYL_OFFSET_HOB
)braket
)paren
op_lshift
l_int|16
)paren
op_or
(paren
(paren
id|args.hobRegister
(braket
id|IDE_LCYL_OFFSET_HOB
)braket
)paren
op_lshift
l_int|8
)paren
op_or
(paren
id|args.hobRegister
(braket
id|IDE_SECTOR_OFFSET_HOB
)braket
)paren
suffix:semicolon
id|u32
id|low
op_assign
(paren
(paren
id|args.tfRegister
(braket
id|IDE_HCYL_OFFSET
)braket
)paren
op_lshift
l_int|16
)paren
op_or
(paren
(paren
id|args.tfRegister
(braket
id|IDE_LCYL_OFFSET
)braket
)paren
op_lshift
l_int|8
)paren
op_or
(paren
id|args.tfRegister
(braket
id|IDE_SECTOR_OFFSET
)braket
)paren
suffix:semicolon
id|addr_set
op_assign
(paren
(paren
id|__u64
)paren
id|high
op_lshift
l_int|24
)paren
op_or
id|low
suffix:semicolon
id|addr_set
op_increment
suffix:semicolon
)brace
r_return
id|addr_set
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_IDEDISK_STROKE */
DECL|function|sectors_to_MB
r_static
r_int
r_int
r_int
id|sectors_to_MB
c_func
(paren
r_int
r_int
r_int
id|n
)paren
(brace
id|n
op_lshift_assign
l_int|9
suffix:semicolon
multiline_comment|/* make it bytes */
id|do_div
c_func
(paren
id|n
comma
l_int|1000000
)paren
suffix:semicolon
multiline_comment|/* make it MB */
r_return
id|n
suffix:semicolon
)brace
multiline_comment|/*&n; * Bits 10 of command_set_1 and cfs_enable_1 must be equal,&n; * so on non-buggy drives we need test only one.&n; * However, we should also check whether these fields are valid.&n; */
DECL|function|idedisk_supports_hpa
r_static
r_inline
r_int
id|idedisk_supports_hpa
c_func
(paren
r_const
r_struct
id|hd_driveid
op_star
id|id
)paren
(brace
r_return
(paren
id|id-&gt;command_set_1
op_amp
l_int|0x0400
)paren
op_logical_and
(paren
id|id-&gt;cfs_enable_1
op_amp
l_int|0x0400
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * The same here.&n; */
DECL|function|idedisk_supports_lba48
r_static
r_inline
r_int
id|idedisk_supports_lba48
c_func
(paren
r_const
r_struct
id|hd_driveid
op_star
id|id
)paren
(brace
r_return
(paren
id|id-&gt;command_set_2
op_amp
l_int|0x0400
)paren
op_logical_and
(paren
id|id-&gt;cfs_enable_2
op_amp
l_int|0x0400
)paren
suffix:semicolon
)brace
DECL|function|idedisk_check_hpa_lba28
r_static
r_inline
r_void
id|idedisk_check_hpa_lba28
c_func
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_int
r_int
id|capacity
comma
id|set_max
suffix:semicolon
id|capacity
op_assign
id|drive-&gt;capacity
suffix:semicolon
id|set_max
op_assign
id|idedisk_read_native_max_address
c_func
(paren
id|drive
)paren
suffix:semicolon
r_if
c_cond
(paren
id|set_max
op_le
id|capacity
)paren
r_return
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Host Protected Area detected.&bslash;n&quot;
l_string|&quot;&bslash;tcurrent capacity is %ld sectors (%ld MB)&bslash;n&quot;
l_string|&quot;&bslash;tnative  capacity is %ld sectors (%ld MB)&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|capacity
comma
(paren
id|capacity
op_minus
id|capacity
op_div
l_int|625
op_plus
l_int|974
)paren
op_div
l_int|1950
comma
id|set_max
comma
(paren
id|set_max
op_minus
id|set_max
op_div
l_int|625
op_plus
l_int|974
)paren
op_div
l_int|1950
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_IDEDISK_STROKE
id|set_max
op_assign
id|idedisk_set_max_address
c_func
(paren
id|drive
comma
id|set_max
)paren
suffix:semicolon
r_if
c_cond
(paren
id|set_max
)paren
(brace
id|drive-&gt;capacity
op_assign
id|set_max
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Host Protected Area disabled.&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
)brace
macro_line|#endif
)brace
DECL|function|idedisk_check_hpa_lba48
r_static
r_inline
r_void
id|idedisk_check_hpa_lba48
c_func
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_int
r_int
r_int
id|capacity_2
comma
id|set_max_ext
suffix:semicolon
id|capacity_2
op_assign
id|drive-&gt;capacity48
suffix:semicolon
id|set_max_ext
op_assign
id|idedisk_read_native_max_address_ext
c_func
(paren
id|drive
)paren
suffix:semicolon
r_if
c_cond
(paren
id|set_max_ext
op_le
id|capacity_2
)paren
r_return
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Host Protected Area detected.&bslash;n&quot;
l_string|&quot;&bslash;tcurrent capacity is %lld sectors (%lld MB)&bslash;n&quot;
l_string|&quot;&bslash;tnative  capacity is %lld sectors (%lld MB)&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|capacity_2
comma
id|sectors_to_MB
c_func
(paren
id|capacity_2
)paren
comma
id|set_max_ext
comma
id|sectors_to_MB
c_func
(paren
id|set_max_ext
)paren
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_IDEDISK_STROKE
id|set_max_ext
op_assign
id|idedisk_set_max_address_ext
c_func
(paren
id|drive
comma
id|set_max_ext
)paren
suffix:semicolon
r_if
c_cond
(paren
id|set_max_ext
)paren
(brace
id|drive-&gt;capacity48
op_assign
id|set_max_ext
suffix:semicolon
id|drive-&gt;capacity
op_assign
(paren
r_int
r_int
)paren
id|set_max_ext
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Host Protected Area disabled.&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
)brace
macro_line|#endif
)brace
multiline_comment|/*&n; * Compute drive-&gt;capacity, the full capacity of the drive&n; * Called with drive-&gt;id != NULL.&n; *&n; * To compute capacity, this uses either of&n; *&n; *    1. CHS value set by user       (whatever user sets will be trusted)&n; *    2. LBA value from target drive (require new ATA feature)&n; *    3. LBA value from system BIOS  (new one is OK, old one may break)&n; *    4. CHS value from system BIOS  (traditional style)&n; *&n; * in above order (i.e., if value of higher priority is available,&n; * reset will be ignored).&n; */
DECL|function|init_idedisk_capacity
r_static
r_void
id|init_idedisk_capacity
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_struct
id|hd_driveid
op_star
id|id
op_assign
id|drive-&gt;id
suffix:semicolon
multiline_comment|/*&n;&t; * If this drive supports the Host Protected Area feature set,&n;&t; * then we may need to change our opinion about the drive&squot;s capacity.&n;&t; */
r_int
id|hpa
op_assign
id|idedisk_supports_hpa
c_func
(paren
id|id
)paren
suffix:semicolon
r_if
c_cond
(paren
id|idedisk_supports_lba48
c_func
(paren
id|id
)paren
)paren
(brace
multiline_comment|/* drive speaks 48-bit LBA */
id|drive-&gt;select.b.lba
op_assign
l_int|1
suffix:semicolon
id|drive-&gt;capacity48
op_assign
id|id-&gt;lba_capacity_2
suffix:semicolon
id|drive-&gt;capacity
op_assign
(paren
r_int
r_int
)paren
id|drive-&gt;capacity48
suffix:semicolon
r_if
c_cond
(paren
id|hpa
)paren
id|idedisk_check_hpa_lba48
c_func
(paren
id|drive
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|id-&gt;capability
op_amp
l_int|2
)paren
op_logical_and
id|lba_capacity_is_ok
c_func
(paren
id|id
)paren
)paren
(brace
multiline_comment|/* drive speaks 28-bit LBA */
id|drive-&gt;select.b.lba
op_assign
l_int|1
suffix:semicolon
id|drive-&gt;capacity
op_assign
id|id-&gt;lba_capacity
suffix:semicolon
r_if
c_cond
(paren
id|hpa
)paren
id|idedisk_check_hpa_lba28
c_func
(paren
id|drive
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* drive speaks boring old 28-bit CHS */
id|drive-&gt;capacity
op_assign
id|drive-&gt;cyl
op_star
id|drive-&gt;head
op_star
id|drive-&gt;sect
suffix:semicolon
)brace
)brace
DECL|function|idedisk_capacity
r_static
id|sector_t
id|idedisk_capacity
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_if
c_cond
(paren
id|idedisk_supports_lba48
c_func
(paren
id|drive-&gt;id
)paren
)paren
r_return
(paren
id|drive-&gt;capacity48
op_minus
id|drive-&gt;sect0
)paren
suffix:semicolon
r_return
(paren
id|drive-&gt;capacity
op_minus
id|drive-&gt;sect0
)paren
suffix:semicolon
)brace
DECL|function|idedisk_special
r_static
id|ide_startstop_t
id|idedisk_special
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|special_t
op_star
id|s
op_assign
op_amp
id|drive-&gt;special
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;b.set_geometry
)paren
(brace
id|s-&gt;b.set_geometry
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|IS_PDC4030_DRIVE
)paren
(brace
id|ide_task_t
id|args
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|args
comma
l_int|0
comma
r_sizeof
(paren
id|ide_task_t
)paren
)paren
suffix:semicolon
id|args.tfRegister
(braket
id|IDE_NSECTOR_OFFSET
)braket
op_assign
id|drive-&gt;sect
suffix:semicolon
id|args.tfRegister
(braket
id|IDE_SECTOR_OFFSET
)braket
op_assign
id|drive-&gt;sect
suffix:semicolon
id|args.tfRegister
(braket
id|IDE_LCYL_OFFSET
)braket
op_assign
id|drive-&gt;cyl
suffix:semicolon
id|args.tfRegister
(braket
id|IDE_HCYL_OFFSET
)braket
op_assign
id|drive-&gt;cyl
op_rshift
l_int|8
suffix:semicolon
id|args.tfRegister
(braket
id|IDE_SELECT_OFFSET
)braket
op_assign
(paren
(paren
id|drive-&gt;head
op_minus
l_int|1
)paren
op_or
id|drive-&gt;select.all
)paren
op_amp
l_int|0xBF
suffix:semicolon
id|args.tfRegister
(braket
id|IDE_COMMAND_OFFSET
)braket
op_assign
id|WIN_SPECIFY
suffix:semicolon
id|args.command_type
op_assign
id|ide_cmd_type_parser
c_func
(paren
op_amp
id|args
)paren
suffix:semicolon
id|do_rw_taskfile
c_func
(paren
id|drive
comma
op_amp
id|args
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|s-&gt;b.recalibrate
)paren
(brace
id|s-&gt;b.recalibrate
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|IS_PDC4030_DRIVE
)paren
(brace
id|ide_task_t
id|args
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|args
comma
l_int|0
comma
r_sizeof
(paren
id|ide_task_t
)paren
)paren
suffix:semicolon
id|args.tfRegister
(braket
id|IDE_NSECTOR_OFFSET
)braket
op_assign
id|drive-&gt;sect
suffix:semicolon
id|args.tfRegister
(braket
id|IDE_COMMAND_OFFSET
)braket
op_assign
id|WIN_RESTORE
suffix:semicolon
id|args.command_type
op_assign
id|ide_cmd_type_parser
c_func
(paren
op_amp
id|args
)paren
suffix:semicolon
id|do_rw_taskfile
c_func
(paren
id|drive
comma
op_amp
id|args
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|s-&gt;b.set_multmode
)paren
(brace
id|s-&gt;b.set_multmode
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;mult_req
OG
id|drive-&gt;id-&gt;max_multsect
)paren
id|drive-&gt;mult_req
op_assign
id|drive-&gt;id-&gt;max_multsect
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|IS_PDC4030_DRIVE
)paren
(brace
id|ide_task_t
id|args
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|args
comma
l_int|0
comma
r_sizeof
(paren
id|ide_task_t
)paren
)paren
suffix:semicolon
id|args.tfRegister
(braket
id|IDE_NSECTOR_OFFSET
)braket
op_assign
id|drive-&gt;mult_req
suffix:semicolon
id|args.tfRegister
(braket
id|IDE_COMMAND_OFFSET
)braket
op_assign
id|WIN_SETMULT
suffix:semicolon
id|args.command_type
op_assign
id|ide_cmd_type_parser
c_func
(paren
op_amp
id|args
)paren
suffix:semicolon
id|do_rw_taskfile
c_func
(paren
id|drive
comma
op_amp
id|args
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|s-&gt;all
)paren
(brace
r_int
id|special
op_assign
id|s-&gt;all
suffix:semicolon
id|s-&gt;all
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: bad special flag: 0x%02x&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|special
)paren
suffix:semicolon
r_return
id|ide_stopped
suffix:semicolon
)brace
r_return
id|IS_PDC4030_DRIVE
ques
c_cond
id|ide_stopped
suffix:colon
id|ide_started
suffix:semicolon
)brace
DECL|function|idedisk_pre_reset
r_static
r_void
id|idedisk_pre_reset
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_int
id|legacy
op_assign
(paren
id|drive-&gt;id-&gt;cfs_enable_2
op_amp
l_int|0x0400
)paren
ques
c_cond
l_int|0
suffix:colon
l_int|1
suffix:semicolon
id|drive-&gt;special.all
op_assign
l_int|0
suffix:semicolon
id|drive-&gt;special.b.set_geometry
op_assign
id|legacy
suffix:semicolon
id|drive-&gt;special.b.recalibrate
op_assign
id|legacy
suffix:semicolon
r_if
c_cond
(paren
id|OK_TO_RESET_CONTROLLER
)paren
id|drive-&gt;mult_count
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|drive-&gt;keep_settings
op_logical_and
op_logical_neg
id|drive-&gt;using_dma
)paren
id|drive-&gt;mult_req
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;mult_req
op_ne
id|drive-&gt;mult_count
)paren
id|drive-&gt;special.b.set_multmode
op_assign
l_int|1
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_PROC_FS
DECL|function|smart_enable
r_static
r_int
id|smart_enable
c_func
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|ide_task_t
id|args
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|args
comma
l_int|0
comma
r_sizeof
(paren
id|ide_task_t
)paren
)paren
suffix:semicolon
id|args.tfRegister
(braket
id|IDE_FEATURE_OFFSET
)braket
op_assign
id|SMART_ENABLE
suffix:semicolon
id|args.tfRegister
(braket
id|IDE_LCYL_OFFSET
)braket
op_assign
id|SMART_LCYL_PASS
suffix:semicolon
id|args.tfRegister
(braket
id|IDE_HCYL_OFFSET
)braket
op_assign
id|SMART_HCYL_PASS
suffix:semicolon
id|args.tfRegister
(braket
id|IDE_COMMAND_OFFSET
)braket
op_assign
id|WIN_SMART
suffix:semicolon
id|args.command_type
op_assign
id|ide_cmd_type_parser
c_func
(paren
op_amp
id|args
)paren
suffix:semicolon
r_return
id|ide_raw_taskfile
c_func
(paren
id|drive
comma
op_amp
id|args
comma
l_int|NULL
)paren
suffix:semicolon
)brace
DECL|function|get_smart_values
r_static
r_int
id|get_smart_values
c_func
(paren
id|ide_drive_t
op_star
id|drive
comma
id|u8
op_star
id|buf
)paren
(brace
id|ide_task_t
id|args
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|args
comma
l_int|0
comma
r_sizeof
(paren
id|ide_task_t
)paren
)paren
suffix:semicolon
id|args.tfRegister
(braket
id|IDE_FEATURE_OFFSET
)braket
op_assign
id|SMART_READ_VALUES
suffix:semicolon
id|args.tfRegister
(braket
id|IDE_NSECTOR_OFFSET
)braket
op_assign
l_int|0x01
suffix:semicolon
id|args.tfRegister
(braket
id|IDE_LCYL_OFFSET
)braket
op_assign
id|SMART_LCYL_PASS
suffix:semicolon
id|args.tfRegister
(braket
id|IDE_HCYL_OFFSET
)braket
op_assign
id|SMART_HCYL_PASS
suffix:semicolon
id|args.tfRegister
(braket
id|IDE_COMMAND_OFFSET
)braket
op_assign
id|WIN_SMART
suffix:semicolon
id|args.command_type
op_assign
id|ide_cmd_type_parser
c_func
(paren
op_amp
id|args
)paren
suffix:semicolon
(paren
r_void
)paren
id|smart_enable
c_func
(paren
id|drive
)paren
suffix:semicolon
r_return
id|ide_raw_taskfile
c_func
(paren
id|drive
comma
op_amp
id|args
comma
id|buf
)paren
suffix:semicolon
)brace
DECL|function|get_smart_thresholds
r_static
r_int
id|get_smart_thresholds
c_func
(paren
id|ide_drive_t
op_star
id|drive
comma
id|u8
op_star
id|buf
)paren
(brace
id|ide_task_t
id|args
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|args
comma
l_int|0
comma
r_sizeof
(paren
id|ide_task_t
)paren
)paren
suffix:semicolon
id|args.tfRegister
(braket
id|IDE_FEATURE_OFFSET
)braket
op_assign
id|SMART_READ_THRESHOLDS
suffix:semicolon
id|args.tfRegister
(braket
id|IDE_NSECTOR_OFFSET
)braket
op_assign
l_int|0x01
suffix:semicolon
id|args.tfRegister
(braket
id|IDE_LCYL_OFFSET
)braket
op_assign
id|SMART_LCYL_PASS
suffix:semicolon
id|args.tfRegister
(braket
id|IDE_HCYL_OFFSET
)braket
op_assign
id|SMART_HCYL_PASS
suffix:semicolon
id|args.tfRegister
(braket
id|IDE_COMMAND_OFFSET
)braket
op_assign
id|WIN_SMART
suffix:semicolon
id|args.command_type
op_assign
id|ide_cmd_type_parser
c_func
(paren
op_amp
id|args
)paren
suffix:semicolon
(paren
r_void
)paren
id|smart_enable
c_func
(paren
id|drive
)paren
suffix:semicolon
r_return
id|ide_raw_taskfile
c_func
(paren
id|drive
comma
op_amp
id|args
comma
id|buf
)paren
suffix:semicolon
)brace
DECL|function|proc_idedisk_read_cache
r_static
r_int
id|proc_idedisk_read_cache
(paren
r_char
op_star
id|page
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|off
comma
r_int
id|count
comma
r_int
op_star
id|eof
comma
r_void
op_star
id|data
)paren
(brace
id|ide_drive_t
op_star
id|drive
op_assign
(paren
id|ide_drive_t
op_star
)paren
id|data
suffix:semicolon
r_char
op_star
id|out
op_assign
id|page
suffix:semicolon
r_int
id|len
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;id_read
)paren
id|len
op_assign
id|sprintf
c_func
(paren
id|out
comma
l_string|&quot;%i&bslash;n&quot;
comma
id|drive-&gt;id-&gt;buf_size
op_div
l_int|2
)paren
suffix:semicolon
r_else
id|len
op_assign
id|sprintf
c_func
(paren
id|out
comma
l_string|&quot;(none)&bslash;n&quot;
)paren
suffix:semicolon
id|PROC_IDE_READ_RETURN
c_func
(paren
id|page
comma
id|start
comma
id|off
comma
id|count
comma
id|eof
comma
id|len
)paren
suffix:semicolon
)brace
DECL|function|proc_idedisk_read_smart_thresholds
r_static
r_int
id|proc_idedisk_read_smart_thresholds
(paren
r_char
op_star
id|page
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|off
comma
r_int
id|count
comma
r_int
op_star
id|eof
comma
r_void
op_star
id|data
)paren
(brace
id|ide_drive_t
op_star
id|drive
op_assign
(paren
id|ide_drive_t
op_star
)paren
id|data
suffix:semicolon
r_int
id|len
op_assign
l_int|0
comma
id|i
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|get_smart_thresholds
c_func
(paren
id|drive
comma
id|page
)paren
)paren
(brace
r_int
r_int
op_star
id|val
op_assign
(paren
r_int
r_int
op_star
)paren
id|page
suffix:semicolon
r_char
op_star
id|out
op_assign
(paren
(paren
r_char
op_star
)paren
id|val
)paren
op_plus
(paren
id|SECTOR_WORDS
op_star
l_int|4
)paren
suffix:semicolon
id|page
op_assign
id|out
suffix:semicolon
r_do
(brace
id|out
op_add_assign
id|sprintf
c_func
(paren
id|out
comma
l_string|&quot;%04x%c&quot;
comma
id|le16_to_cpu
c_func
(paren
op_star
id|val
)paren
comma
(paren
op_increment
id|i
op_amp
l_int|7
)paren
ques
c_cond
l_char|&squot; &squot;
suffix:colon
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
id|val
op_add_assign
l_int|1
suffix:semicolon
)brace
r_while
c_loop
(paren
id|i
OL
(paren
id|SECTOR_WORDS
op_star
l_int|2
)paren
)paren
suffix:semicolon
id|len
op_assign
id|out
op_minus
id|page
suffix:semicolon
)brace
id|PROC_IDE_READ_RETURN
c_func
(paren
id|page
comma
id|start
comma
id|off
comma
id|count
comma
id|eof
comma
id|len
)paren
suffix:semicolon
)brace
DECL|function|proc_idedisk_read_smart_values
r_static
r_int
id|proc_idedisk_read_smart_values
(paren
r_char
op_star
id|page
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|off
comma
r_int
id|count
comma
r_int
op_star
id|eof
comma
r_void
op_star
id|data
)paren
(brace
id|ide_drive_t
op_star
id|drive
op_assign
(paren
id|ide_drive_t
op_star
)paren
id|data
suffix:semicolon
r_int
id|len
op_assign
l_int|0
comma
id|i
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|get_smart_values
c_func
(paren
id|drive
comma
id|page
)paren
)paren
(brace
r_int
r_int
op_star
id|val
op_assign
(paren
r_int
r_int
op_star
)paren
id|page
suffix:semicolon
r_char
op_star
id|out
op_assign
(paren
(paren
r_char
op_star
)paren
id|val
)paren
op_plus
(paren
id|SECTOR_WORDS
op_star
l_int|4
)paren
suffix:semicolon
id|page
op_assign
id|out
suffix:semicolon
r_do
(brace
id|out
op_add_assign
id|sprintf
c_func
(paren
id|out
comma
l_string|&quot;%04x%c&quot;
comma
id|le16_to_cpu
c_func
(paren
op_star
id|val
)paren
comma
(paren
op_increment
id|i
op_amp
l_int|7
)paren
ques
c_cond
l_char|&squot; &squot;
suffix:colon
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
id|val
op_add_assign
l_int|1
suffix:semicolon
)brace
r_while
c_loop
(paren
id|i
OL
(paren
id|SECTOR_WORDS
op_star
l_int|2
)paren
)paren
suffix:semicolon
id|len
op_assign
id|out
op_minus
id|page
suffix:semicolon
)brace
id|PROC_IDE_READ_RETURN
c_func
(paren
id|page
comma
id|start
comma
id|off
comma
id|count
comma
id|eof
comma
id|len
)paren
suffix:semicolon
)brace
DECL|variable|idedisk_proc
r_static
id|ide_proc_entry_t
id|idedisk_proc
(braket
)braket
op_assign
(brace
(brace
l_string|&quot;cache&quot;
comma
id|S_IFREG
op_or
id|S_IRUGO
comma
id|proc_idedisk_read_cache
comma
l_int|NULL
)brace
comma
(brace
l_string|&quot;geometry&quot;
comma
id|S_IFREG
op_or
id|S_IRUGO
comma
id|proc_ide_read_geometry
comma
l_int|NULL
)brace
comma
(brace
l_string|&quot;smart_values&quot;
comma
id|S_IFREG
op_or
id|S_IRUSR
comma
id|proc_idedisk_read_smart_values
comma
l_int|NULL
)brace
comma
(brace
l_string|&quot;smart_thresholds&quot;
comma
id|S_IFREG
op_or
id|S_IRUSR
comma
id|proc_idedisk_read_smart_thresholds
comma
l_int|NULL
)brace
comma
(brace
l_int|NULL
comma
l_int|0
comma
l_int|NULL
comma
l_int|NULL
)brace
)brace
suffix:semicolon
macro_line|#else
DECL|macro|idedisk_proc
mdefine_line|#define&t;idedisk_proc&t;NULL
macro_line|#endif&t;/* CONFIG_PROC_FS */
multiline_comment|/*&n; * This is tightly woven into the driver-&gt;do_special can not touch.&n; * DON&squot;T do it again until a total personality rewrite is committed.&n; */
DECL|function|set_multcount
r_static
r_int
id|set_multcount
c_func
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|arg
)paren
(brace
r_struct
id|request
id|rq
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;special.b.set_multmode
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
id|ide_init_drive_cmd
(paren
op_amp
id|rq
)paren
suffix:semicolon
id|rq.flags
op_assign
id|REQ_DRIVE_CMD
suffix:semicolon
id|drive-&gt;mult_req
op_assign
id|arg
suffix:semicolon
id|drive-&gt;special.b.set_multmode
op_assign
l_int|1
suffix:semicolon
(paren
r_void
)paren
id|ide_do_drive_cmd
(paren
id|drive
comma
op_amp
id|rq
comma
id|ide_wait
)paren
suffix:semicolon
r_return
(paren
id|drive-&gt;mult_count
op_eq
id|arg
)paren
ques
c_cond
l_int|0
suffix:colon
op_minus
id|EIO
suffix:semicolon
)brace
DECL|function|set_nowerr
r_static
r_int
id|set_nowerr
c_func
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|arg
)paren
(brace
r_if
c_cond
(paren
id|ide_spin_wait_hwgroup
c_func
(paren
id|drive
)paren
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
id|drive-&gt;nowerr
op_assign
id|arg
suffix:semicolon
id|drive-&gt;bad_wstat
op_assign
id|arg
ques
c_cond
id|BAD_R_STAT
suffix:colon
id|BAD_W_STAT
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|ide_lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|write_cache
r_static
r_int
id|write_cache
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|arg
)paren
(brace
id|ide_task_t
id|args
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|drive-&gt;id-&gt;cfs_enable_2
op_amp
l_int|0x3000
)paren
)paren
r_return
l_int|1
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|args
comma
l_int|0
comma
r_sizeof
(paren
id|ide_task_t
)paren
)paren
suffix:semicolon
id|args.tfRegister
(braket
id|IDE_FEATURE_OFFSET
)braket
op_assign
(paren
id|arg
)paren
ques
c_cond
id|SETFEATURES_EN_WCACHE
suffix:colon
id|SETFEATURES_DIS_WCACHE
suffix:semicolon
id|args.tfRegister
(braket
id|IDE_COMMAND_OFFSET
)braket
op_assign
id|WIN_SETFEATURES
suffix:semicolon
id|args.command_type
op_assign
id|ide_cmd_type_parser
c_func
(paren
op_amp
id|args
)paren
suffix:semicolon
(paren
r_void
)paren
id|ide_raw_taskfile
c_func
(paren
id|drive
comma
op_amp
id|args
comma
l_int|NULL
)paren
suffix:semicolon
id|drive-&gt;wcache
op_assign
id|arg
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|do_idedisk_flushcache
r_static
r_int
id|do_idedisk_flushcache
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|ide_task_t
id|args
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|args
comma
l_int|0
comma
r_sizeof
(paren
id|ide_task_t
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;id-&gt;cfs_enable_2
op_amp
l_int|0x2400
)paren
id|args.tfRegister
(braket
id|IDE_COMMAND_OFFSET
)braket
op_assign
id|WIN_FLUSH_CACHE_EXT
suffix:semicolon
r_else
id|args.tfRegister
(braket
id|IDE_COMMAND_OFFSET
)braket
op_assign
id|WIN_FLUSH_CACHE
suffix:semicolon
id|args.command_type
op_assign
id|ide_cmd_type_parser
c_func
(paren
op_amp
id|args
)paren
suffix:semicolon
r_return
id|ide_raw_taskfile
c_func
(paren
id|drive
comma
op_amp
id|args
comma
l_int|NULL
)paren
suffix:semicolon
)brace
DECL|function|set_acoustic
r_static
r_int
id|set_acoustic
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|arg
)paren
(brace
id|ide_task_t
id|args
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|args
comma
l_int|0
comma
r_sizeof
(paren
id|ide_task_t
)paren
)paren
suffix:semicolon
id|args.tfRegister
(braket
id|IDE_FEATURE_OFFSET
)braket
op_assign
(paren
id|arg
)paren
ques
c_cond
id|SETFEATURES_EN_AAM
suffix:colon
id|SETFEATURES_DIS_AAM
suffix:semicolon
id|args.tfRegister
(braket
id|IDE_NSECTOR_OFFSET
)braket
op_assign
id|arg
suffix:semicolon
id|args.tfRegister
(braket
id|IDE_COMMAND_OFFSET
)braket
op_assign
id|WIN_SETFEATURES
suffix:semicolon
id|args.command_type
op_assign
id|ide_cmd_type_parser
c_func
(paren
op_amp
id|args
)paren
suffix:semicolon
id|ide_raw_taskfile
c_func
(paren
id|drive
comma
op_amp
id|args
comma
l_int|NULL
)paren
suffix:semicolon
id|drive-&gt;acoustic
op_assign
id|arg
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_BLK_DEV_IDE_TCQ
DECL|function|set_using_tcq
r_static
r_int
id|set_using_tcq
c_func
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|arg
)paren
(brace
id|ide_hwif_t
op_star
id|hwif
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|drive-&gt;driver
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hwif-&gt;ide_dma_queued_on
op_logical_or
op_logical_neg
id|hwif-&gt;ide_dma_queued_off
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
r_if
c_cond
(paren
id|arg
op_eq
id|drive-&gt;queue_depth
op_logical_and
id|drive-&gt;using_tcq
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * set depth, but check also id for max supported depth&n;&t; */
id|drive-&gt;queue_depth
op_assign
id|arg
ques
c_cond
id|arg
suffix:colon
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;id
)paren
(brace
r_if
c_cond
(paren
id|drive-&gt;queue_depth
OG
id|drive-&gt;id-&gt;queue_depth
op_plus
l_int|1
)paren
id|drive-&gt;queue_depth
op_assign
id|drive-&gt;id-&gt;queue_depth
op_plus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|arg
)paren
id|ret
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|ide_dma_queued_on
c_func
(paren
id|drive
)paren
suffix:semicolon
r_else
id|ret
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|ide_dma_queued_off
c_func
(paren
id|drive
)paren
suffix:semicolon
r_return
id|ret
ques
c_cond
op_minus
id|EIO
suffix:colon
l_int|0
suffix:semicolon
)brace
macro_line|#endif
DECL|function|probe_lba_addressing
r_static
r_int
id|probe_lba_addressing
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|arg
)paren
(brace
id|drive-&gt;addressing
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|addressing
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|idedisk_supports_lba48
c_func
(paren
id|drive-&gt;id
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
id|drive-&gt;addressing
op_assign
id|arg
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|set_lba_addressing
r_static
r_int
id|set_lba_addressing
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|arg
)paren
(brace
r_return
id|probe_lba_addressing
c_func
(paren
id|drive
comma
id|arg
)paren
suffix:semicolon
)brace
DECL|function|idedisk_add_settings
r_static
r_void
id|idedisk_add_settings
c_func
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_struct
id|hd_driveid
op_star
id|id
op_assign
id|drive-&gt;id
suffix:semicolon
id|ide_add_setting
c_func
(paren
id|drive
comma
l_string|&quot;bios_cyl&quot;
comma
id|SETTING_RW
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
id|TYPE_INT
comma
l_int|0
comma
l_int|65535
comma
l_int|1
comma
l_int|1
comma
op_amp
id|drive-&gt;bios_cyl
comma
l_int|NULL
)paren
suffix:semicolon
id|ide_add_setting
c_func
(paren
id|drive
comma
l_string|&quot;bios_head&quot;
comma
id|SETTING_RW
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
id|TYPE_BYTE
comma
l_int|0
comma
l_int|255
comma
l_int|1
comma
l_int|1
comma
op_amp
id|drive-&gt;bios_head
comma
l_int|NULL
)paren
suffix:semicolon
id|ide_add_setting
c_func
(paren
id|drive
comma
l_string|&quot;bios_sect&quot;
comma
id|SETTING_RW
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
id|TYPE_BYTE
comma
l_int|0
comma
l_int|63
comma
l_int|1
comma
l_int|1
comma
op_amp
id|drive-&gt;bios_sect
comma
l_int|NULL
)paren
suffix:semicolon
id|ide_add_setting
c_func
(paren
id|drive
comma
l_string|&quot;address&quot;
comma
id|SETTING_RW
comma
id|HDIO_GET_ADDRESS
comma
id|HDIO_SET_ADDRESS
comma
id|TYPE_INTA
comma
l_int|0
comma
l_int|2
comma
l_int|1
comma
l_int|1
comma
op_amp
id|drive-&gt;addressing
comma
id|set_lba_addressing
)paren
suffix:semicolon
id|ide_add_setting
c_func
(paren
id|drive
comma
l_string|&quot;bswap&quot;
comma
id|SETTING_READ
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
id|TYPE_BYTE
comma
l_int|0
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
op_amp
id|drive-&gt;bswap
comma
l_int|NULL
)paren
suffix:semicolon
id|ide_add_setting
c_func
(paren
id|drive
comma
l_string|&quot;multcount&quot;
comma
id|id
ques
c_cond
id|SETTING_RW
suffix:colon
id|SETTING_READ
comma
id|HDIO_GET_MULTCOUNT
comma
id|HDIO_SET_MULTCOUNT
comma
id|TYPE_BYTE
comma
l_int|0
comma
id|id
ques
c_cond
id|id-&gt;max_multsect
suffix:colon
l_int|0
comma
l_int|1
comma
l_int|1
comma
op_amp
id|drive-&gt;mult_count
comma
id|set_multcount
)paren
suffix:semicolon
id|ide_add_setting
c_func
(paren
id|drive
comma
l_string|&quot;nowerr&quot;
comma
id|SETTING_RW
comma
id|HDIO_GET_NOWERR
comma
id|HDIO_SET_NOWERR
comma
id|TYPE_BYTE
comma
l_int|0
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
op_amp
id|drive-&gt;nowerr
comma
id|set_nowerr
)paren
suffix:semicolon
id|ide_add_setting
c_func
(paren
id|drive
comma
l_string|&quot;lun&quot;
comma
id|SETTING_RW
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
id|TYPE_INT
comma
l_int|0
comma
l_int|7
comma
l_int|1
comma
l_int|1
comma
op_amp
id|drive-&gt;lun
comma
l_int|NULL
)paren
suffix:semicolon
id|ide_add_setting
c_func
(paren
id|drive
comma
l_string|&quot;wcache&quot;
comma
id|SETTING_RW
comma
id|HDIO_GET_WCACHE
comma
id|HDIO_SET_WCACHE
comma
id|TYPE_BYTE
comma
l_int|0
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
op_amp
id|drive-&gt;wcache
comma
id|write_cache
)paren
suffix:semicolon
id|ide_add_setting
c_func
(paren
id|drive
comma
l_string|&quot;acoustic&quot;
comma
id|SETTING_RW
comma
id|HDIO_GET_ACOUSTIC
comma
id|HDIO_SET_ACOUSTIC
comma
id|TYPE_BYTE
comma
l_int|0
comma
l_int|254
comma
l_int|1
comma
l_int|1
comma
op_amp
id|drive-&gt;acoustic
comma
id|set_acoustic
)paren
suffix:semicolon
id|ide_add_setting
c_func
(paren
id|drive
comma
l_string|&quot;failures&quot;
comma
id|SETTING_RW
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
id|TYPE_INT
comma
l_int|0
comma
l_int|65535
comma
l_int|1
comma
l_int|1
comma
op_amp
id|drive-&gt;failures
comma
l_int|NULL
)paren
suffix:semicolon
id|ide_add_setting
c_func
(paren
id|drive
comma
l_string|&quot;max_failures&quot;
comma
id|SETTING_RW
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
id|TYPE_INT
comma
l_int|0
comma
l_int|65535
comma
l_int|1
comma
l_int|1
comma
op_amp
id|drive-&gt;max_failures
comma
l_int|NULL
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_IDE_TCQ
id|ide_add_setting
c_func
(paren
id|drive
comma
l_string|&quot;using_tcq&quot;
comma
id|SETTING_RW
comma
id|HDIO_GET_QDMA
comma
id|HDIO_SET_QDMA
comma
id|TYPE_BYTE
comma
l_int|0
comma
id|IDE_MAX_TAG
comma
l_int|1
comma
l_int|1
comma
op_amp
id|drive-&gt;using_tcq
comma
id|set_using_tcq
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n; * Power Management state machine. This one is rather trivial for now,&n; * we should probably add more, like switching back to PIO on suspend&n; * to help some BIOSes, re-do the door locking on resume, etc...&n; */
r_enum
(brace
DECL|enumerator|idedisk_pm_flush_cache
id|idedisk_pm_flush_cache
op_assign
id|ide_pm_state_start_suspend
comma
DECL|enumerator|idedisk_pm_standby
id|idedisk_pm_standby
comma
DECL|enumerator|idedisk_pm_restore_dma
id|idedisk_pm_restore_dma
op_assign
id|ide_pm_state_start_resume
comma
)brace
suffix:semicolon
DECL|function|idedisk_complete_power_step
r_static
r_void
id|idedisk_complete_power_step
(paren
id|ide_drive_t
op_star
id|drive
comma
r_struct
id|request
op_star
id|rq
comma
id|u8
id|stat
comma
id|u8
id|error
)paren
(brace
r_switch
c_cond
(paren
id|rq-&gt;pm-&gt;pm_step
)paren
(brace
r_case
id|idedisk_pm_flush_cache
suffix:colon
multiline_comment|/* Suspend step 1 (flush cache) complete */
r_if
c_cond
(paren
id|rq-&gt;pm-&gt;pm_state
op_eq
l_int|4
)paren
id|rq-&gt;pm-&gt;pm_step
op_assign
id|ide_pm_state_completed
suffix:semicolon
r_else
id|rq-&gt;pm-&gt;pm_step
op_assign
id|idedisk_pm_standby
suffix:semicolon
r_break
suffix:semicolon
r_case
id|idedisk_pm_standby
suffix:colon
multiline_comment|/* Suspend step 2 (standby) complete */
id|rq-&gt;pm-&gt;pm_step
op_assign
id|ide_pm_state_completed
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
DECL|function|idedisk_start_power_step
r_static
id|ide_startstop_t
id|idedisk_start_power_step
(paren
id|ide_drive_t
op_star
id|drive
comma
r_struct
id|request
op_star
id|rq
)paren
(brace
id|ide_task_t
op_star
id|args
op_assign
id|rq-&gt;special
suffix:semicolon
id|memset
c_func
(paren
id|args
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|args
)paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|rq-&gt;pm-&gt;pm_step
)paren
(brace
r_case
id|idedisk_pm_flush_cache
suffix:colon
multiline_comment|/* Suspend step 1 (flush cache) */
multiline_comment|/* Not supported? Switch to next step now. */
r_if
c_cond
(paren
op_logical_neg
id|drive-&gt;wcache
)paren
(brace
id|idedisk_complete_power_step
c_func
(paren
id|drive
comma
id|rq
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_return
id|ide_stopped
suffix:semicolon
)brace
r_if
c_cond
(paren
id|drive-&gt;id-&gt;cfs_enable_2
op_amp
l_int|0x2400
)paren
id|args-&gt;tfRegister
(braket
id|IDE_COMMAND_OFFSET
)braket
op_assign
id|WIN_FLUSH_CACHE_EXT
suffix:semicolon
r_else
id|args-&gt;tfRegister
(braket
id|IDE_COMMAND_OFFSET
)braket
op_assign
id|WIN_FLUSH_CACHE
suffix:semicolon
id|args-&gt;command_type
op_assign
id|ide_cmd_type_parser
c_func
(paren
id|args
)paren
suffix:semicolon
r_return
id|do_rw_taskfile
c_func
(paren
id|drive
comma
id|args
)paren
suffix:semicolon
r_case
id|idedisk_pm_standby
suffix:colon
multiline_comment|/* Suspend step 2 (standby) */
id|args-&gt;tfRegister
(braket
id|IDE_COMMAND_OFFSET
)braket
op_assign
id|WIN_STANDBYNOW1
suffix:semicolon
id|args-&gt;command_type
op_assign
id|ide_cmd_type_parser
c_func
(paren
id|args
)paren
suffix:semicolon
r_return
id|do_rw_taskfile
c_func
(paren
id|drive
comma
id|args
)paren
suffix:semicolon
r_case
id|idedisk_pm_restore_dma
suffix:colon
multiline_comment|/* Resume step 1 (restore DMA) */
multiline_comment|/*&n;&t;&t; * Right now, all we do is call hwif-&gt;ide_dma_check(drive),&n;&t;&t; * we could be smarter and check for current xfer_speed&n;&t;&t; * in struct drive etc...&n;&t;&t; * Also, this step could be implemented as a generic helper&n;&t;&t; * as most subdrivers will use it&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|drive-&gt;id-&gt;capability
op_amp
l_int|1
)paren
op_eq
l_int|0
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|ide_dma_check
op_eq
l_int|NULL
)paren
r_break
suffix:semicolon
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|ide_dma_check
c_func
(paren
id|drive
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|rq-&gt;pm-&gt;pm_step
op_assign
id|ide_pm_state_completed
suffix:semicolon
r_return
id|ide_stopped
suffix:semicolon
)brace
DECL|function|idedisk_setup
r_static
r_void
id|idedisk_setup
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_struct
id|hd_driveid
op_star
id|id
op_assign
id|drive-&gt;id
suffix:semicolon
r_int
r_int
r_int
id|capacity
suffix:semicolon
id|idedisk_add_settings
c_func
(paren
id|drive
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;id_read
op_eq
l_int|0
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t; * CompactFlash cards and their brethern look just like hard drives&n;&t; * to us, but they are removable and don&squot;t have a doorlock mechanism.&n;&t; */
r_if
c_cond
(paren
id|drive-&gt;removable
op_logical_and
op_logical_neg
(paren
id|drive-&gt;is_flash
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * Removable disks (eg. SYQUEST); ignore &squot;WD&squot; drives &n;&t;&t; */
r_if
c_cond
(paren
id|id-&gt;model
(braket
l_int|0
)braket
op_ne
l_char|&squot;W&squot;
op_logical_or
id|id-&gt;model
(braket
l_int|1
)braket
op_ne
l_char|&squot;D&squot;
)paren
(brace
id|drive-&gt;doorlocking
op_assign
l_int|1
suffix:semicolon
)brace
)brace
(paren
r_void
)paren
id|probe_lba_addressing
c_func
(paren
id|drive
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;addressing
op_eq
l_int|1
)paren
(brace
id|ide_hwif_t
op_star
id|hwif
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
suffix:semicolon
r_int
id|max_s
op_assign
l_int|2048
suffix:semicolon
r_if
c_cond
(paren
id|max_s
OG
id|hwif-&gt;rqsize
)paren
id|max_s
op_assign
id|hwif-&gt;rqsize
suffix:semicolon
id|blk_queue_max_sectors
c_func
(paren
id|drive-&gt;queue
comma
id|max_s
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;%s: max request size: %dKiB&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|drive-&gt;queue-&gt;max_sectors
op_div
l_int|2
)paren
suffix:semicolon
multiline_comment|/* Extract geometry if we did not already have one for the drive */
r_if
c_cond
(paren
op_logical_neg
id|drive-&gt;cyl
op_logical_or
op_logical_neg
id|drive-&gt;head
op_logical_or
op_logical_neg
id|drive-&gt;sect
)paren
(brace
id|drive-&gt;cyl
op_assign
id|drive-&gt;bios_cyl
op_assign
id|id-&gt;cyls
suffix:semicolon
id|drive-&gt;head
op_assign
id|drive-&gt;bios_head
op_assign
id|id-&gt;heads
suffix:semicolon
id|drive-&gt;sect
op_assign
id|drive-&gt;bios_sect
op_assign
id|id-&gt;sectors
suffix:semicolon
)brace
multiline_comment|/* Handle logical geometry translation by the drive */
r_if
c_cond
(paren
(paren
id|id-&gt;field_valid
op_amp
l_int|1
)paren
op_logical_and
id|id-&gt;cur_cyls
op_logical_and
id|id-&gt;cur_heads
op_logical_and
(paren
id|id-&gt;cur_heads
op_le
l_int|16
)paren
op_logical_and
id|id-&gt;cur_sectors
)paren
(brace
id|drive-&gt;cyl
op_assign
id|id-&gt;cur_cyls
suffix:semicolon
id|drive-&gt;head
op_assign
id|id-&gt;cur_heads
suffix:semicolon
id|drive-&gt;sect
op_assign
id|id-&gt;cur_sectors
suffix:semicolon
)brace
multiline_comment|/* Use physical geometry if what we have still makes no sense */
r_if
c_cond
(paren
id|drive-&gt;head
OG
l_int|16
op_logical_and
id|id-&gt;heads
op_logical_and
id|id-&gt;heads
op_le
l_int|16
)paren
(brace
id|drive-&gt;cyl
op_assign
id|id-&gt;cyls
suffix:semicolon
id|drive-&gt;head
op_assign
id|id-&gt;heads
suffix:semicolon
id|drive-&gt;sect
op_assign
id|id-&gt;sectors
suffix:semicolon
)brace
multiline_comment|/* calculate drive capacity, and select LBA if possible */
id|init_idedisk_capacity
(paren
id|drive
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * if possible, give fdisk access to more of the drive,&n;&t; * by correcting bios_cyls:&n;&t; */
id|capacity
op_assign
id|idedisk_capacity
(paren
id|drive
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|drive-&gt;forced_geom
)paren
(brace
r_if
c_cond
(paren
id|idedisk_supports_lba48
c_func
(paren
id|drive-&gt;id
)paren
)paren
(brace
multiline_comment|/* compatibility */
id|drive-&gt;bios_sect
op_assign
l_int|63
suffix:semicolon
id|drive-&gt;bios_head
op_assign
l_int|255
suffix:semicolon
)brace
r_if
c_cond
(paren
id|drive-&gt;bios_sect
op_logical_and
id|drive-&gt;bios_head
)paren
(brace
r_int
r_int
id|cap0
op_assign
id|capacity
suffix:semicolon
multiline_comment|/* truncate to 32 bits */
r_int
r_int
id|cylsz
comma
id|cyl
suffix:semicolon
r_if
c_cond
(paren
id|cap0
op_ne
id|capacity
)paren
id|drive-&gt;bios_cyl
op_assign
l_int|65535
suffix:semicolon
r_else
(brace
id|cylsz
op_assign
id|drive-&gt;bios_sect
op_star
id|drive-&gt;bios_head
suffix:semicolon
id|cyl
op_assign
id|cap0
op_div
id|cylsz
suffix:semicolon
r_if
c_cond
(paren
id|cyl
OG
l_int|65535
)paren
id|cyl
op_assign
l_int|65535
suffix:semicolon
r_if
c_cond
(paren
id|cyl
OG
id|drive-&gt;bios_cyl
)paren
id|drive-&gt;bios_cyl
op_assign
id|cyl
suffix:semicolon
)brace
)brace
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: %llu sectors (%llu MB)&quot;
comma
id|drive-&gt;name
comma
id|capacity
comma
id|sectors_to_MB
c_func
(paren
id|capacity
)paren
)paren
suffix:semicolon
multiline_comment|/* Only print cache size when it was specified */
r_if
c_cond
(paren
id|id-&gt;buf_size
)paren
id|printk
(paren
l_string|&quot; w/%dKiB Cache&quot;
comma
id|id-&gt;buf_size
op_div
l_int|2
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;, CHS=%d/%d/%d&quot;
comma
id|drive-&gt;bios_cyl
comma
id|drive-&gt;bios_head
comma
id|drive-&gt;bios_sect
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;using_dma
)paren
(paren
r_void
)paren
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|ide_dma_verbose
c_func
(paren
id|drive
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|drive-&gt;mult_count
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|id-&gt;max_multsect
)paren
(brace
macro_line|#ifdef CONFIG_IDEDISK_MULTI_MODE
id|id-&gt;multsect
op_assign
(paren
(paren
id|id-&gt;max_multsect
op_div
l_int|2
)paren
OG
l_int|1
)paren
ques
c_cond
id|id-&gt;max_multsect
suffix:colon
l_int|0
suffix:semicolon
id|id-&gt;multsect_valid
op_assign
id|id-&gt;multsect
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
id|drive-&gt;mult_req
op_assign
id|id-&gt;multsect_valid
ques
c_cond
id|id-&gt;max_multsect
suffix:colon
id|INITIAL_MULT_COUNT
suffix:semicolon
id|drive-&gt;special.b.set_multmode
op_assign
id|drive-&gt;mult_req
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
macro_line|#else&t;/* original, pre IDE-NFG, per request of AC */
id|drive-&gt;mult_req
op_assign
id|INITIAL_MULT_COUNT
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;mult_req
OG
id|id-&gt;max_multsect
)paren
id|drive-&gt;mult_req
op_assign
id|id-&gt;max_multsect
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;mult_req
op_logical_or
(paren
(paren
id|id-&gt;multsect_valid
op_amp
l_int|1
)paren
op_logical_and
id|id-&gt;multsect
)paren
)paren
id|drive-&gt;special.b.set_multmode
op_assign
l_int|1
suffix:semicolon
macro_line|#endif&t;/* CONFIG_IDEDISK_MULTI_MODE */
)brace
id|drive-&gt;no_io_32bit
op_assign
id|id-&gt;dword_io
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;id-&gt;cfs_enable_2
op_amp
l_int|0x3000
)paren
id|write_cache
c_func
(paren
id|drive
comma
(paren
id|id-&gt;cfs_enable_2
op_amp
l_int|0x3000
)paren
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_IDE_TCQ_DEFAULT
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|ide_dma_queued_on
c_func
(paren
id|drive
)paren
suffix:semicolon
macro_line|#endif
)brace
DECL|function|idedisk_cleanup
r_static
r_int
id|idedisk_cleanup
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_static
r_int
id|ide_cacheflush_p
c_func
(paren
id|ide_drive_t
op_star
id|drive
)paren
suffix:semicolon
r_struct
id|gendisk
op_star
id|g
op_assign
id|drive-&gt;disk
suffix:semicolon
id|ide_cacheflush_p
c_func
(paren
id|drive
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ide_unregister_subdriver
c_func
(paren
id|drive
)paren
)paren
r_return
l_int|1
suffix:semicolon
id|del_gendisk
c_func
(paren
id|g
)paren
suffix:semicolon
id|g-&gt;fops
op_assign
id|ide_fops
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
id|idedisk_attach
c_func
(paren
id|ide_drive_t
op_star
id|drive
)paren
suffix:semicolon
multiline_comment|/*&n; *      IDE subdriver functions, registered with ide.c&n; */
DECL|variable|idedisk_driver
r_static
id|ide_driver_t
id|idedisk_driver
op_assign
(brace
dot
id|owner
op_assign
id|THIS_MODULE
comma
dot
id|name
op_assign
l_string|&quot;ide-disk&quot;
comma
dot
id|version
op_assign
id|IDEDISK_VERSION
comma
dot
id|media
op_assign
id|ide_disk
comma
dot
id|busy
op_assign
l_int|0
comma
dot
id|supports_dma
op_assign
l_int|1
comma
dot
id|supports_dsc_overlap
op_assign
l_int|0
comma
dot
id|cleanup
op_assign
id|idedisk_cleanup
comma
dot
id|flushcache
op_assign
id|do_idedisk_flushcache
comma
dot
id|do_request
op_assign
id|ide_do_rw_disk
comma
dot
id|sense
op_assign
id|idedisk_dump_status
comma
dot
id|error
op_assign
id|idedisk_error
comma
dot
m_abort
op_assign
id|idedisk_abort
comma
dot
id|pre_reset
op_assign
id|idedisk_pre_reset
comma
dot
id|capacity
op_assign
id|idedisk_capacity
comma
dot
id|special
op_assign
id|idedisk_special
comma
dot
id|proc
op_assign
id|idedisk_proc
comma
dot
id|attach
op_assign
id|idedisk_attach
comma
dot
id|drives
op_assign
id|LIST_HEAD_INIT
c_func
(paren
id|idedisk_driver.drives
)paren
comma
dot
id|start_power_step
op_assign
id|idedisk_start_power_step
comma
dot
id|complete_power_step
op_assign
id|idedisk_complete_power_step
comma
dot
id|gen_driver
op_assign
(brace
dot
id|suspend
op_assign
id|generic_ide_suspend
comma
dot
id|resume
op_assign
id|generic_ide_resume
comma
)brace
)brace
suffix:semicolon
DECL|function|idedisk_open
r_static
r_int
id|idedisk_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
id|ide_drive_t
op_star
id|drive
op_assign
id|inode-&gt;i_bdev-&gt;bd_disk-&gt;private_data
suffix:semicolon
id|drive-&gt;usage
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;removable
op_logical_and
id|drive-&gt;usage
op_eq
l_int|1
)paren
(brace
id|ide_task_t
id|args
suffix:semicolon
id|u8
id|cf
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|args
comma
l_int|0
comma
r_sizeof
(paren
id|ide_task_t
)paren
)paren
suffix:semicolon
id|args.tfRegister
(braket
id|IDE_COMMAND_OFFSET
)braket
op_assign
id|WIN_DOORLOCK
suffix:semicolon
id|args.command_type
op_assign
id|ide_cmd_type_parser
c_func
(paren
op_amp
id|args
)paren
suffix:semicolon
id|check_disk_change
c_func
(paren
id|inode-&gt;i_bdev
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Ignore the return code from door_lock,&n;&t;&t; * since the open() has already succeeded,&n;&t;&t; * and the door_lock is irrelevant at this point.&n;&t;&t; */
r_if
c_cond
(paren
id|drive-&gt;doorlocking
op_logical_and
id|ide_raw_taskfile
c_func
(paren
id|drive
comma
op_amp
id|args
comma
l_int|NULL
)paren
)paren
id|drive-&gt;doorlocking
op_assign
l_int|0
suffix:semicolon
id|drive-&gt;wcache
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Cache enabled ? */
r_if
c_cond
(paren
id|drive-&gt;id-&gt;csfo
op_amp
l_int|1
)paren
id|drive-&gt;wcache
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Cache command set available ? */
r_if
c_cond
(paren
id|drive-&gt;id-&gt;cfs_enable_1
op_amp
(paren
l_int|1
op_lshift
l_int|5
)paren
)paren
id|drive-&gt;wcache
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* ATA6 cache extended commands */
id|cf
op_assign
id|drive-&gt;id-&gt;command_set_2
op_rshift
l_int|24
suffix:semicolon
r_if
c_cond
(paren
(paren
id|cf
op_amp
l_int|0xC0
)paren
op_eq
l_int|0x40
op_logical_and
(paren
id|cf
op_amp
l_int|0x30
)paren
op_ne
l_int|0
)paren
(brace
id|drive-&gt;wcache
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ide_cacheflush_p
r_static
r_int
id|ide_cacheflush_p
c_func
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_if
c_cond
(paren
id|drive-&gt;wcache
)paren
(brace
r_if
c_cond
(paren
id|do_idedisk_flushcache
c_func
(paren
id|drive
)paren
)paren
(brace
id|printk
(paren
id|KERN_INFO
l_string|&quot;%s: Write Cache FAILED Flushing!&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|idedisk_release
r_static
r_int
id|idedisk_release
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
id|ide_drive_t
op_star
id|drive
op_assign
id|inode-&gt;i_bdev-&gt;bd_disk-&gt;private_data
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;removable
op_logical_and
id|drive-&gt;usage
op_eq
l_int|1
)paren
(brace
id|ide_task_t
id|args
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|args
comma
l_int|0
comma
r_sizeof
(paren
id|ide_task_t
)paren
)paren
suffix:semicolon
id|args.tfRegister
(braket
id|IDE_COMMAND_OFFSET
)braket
op_assign
id|WIN_DOORUNLOCK
suffix:semicolon
id|args.command_type
op_assign
id|ide_cmd_type_parser
c_func
(paren
op_amp
id|args
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;doorlocking
op_logical_and
id|ide_raw_taskfile
c_func
(paren
id|drive
comma
op_amp
id|args
comma
l_int|NULL
)paren
)paren
id|drive-&gt;doorlocking
op_assign
l_int|0
suffix:semicolon
)brace
id|ide_cacheflush_p
c_func
(paren
id|drive
)paren
suffix:semicolon
id|drive-&gt;usage
op_decrement
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|idedisk_ioctl
r_static
r_int
id|idedisk_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_struct
id|block_device
op_star
id|bdev
op_assign
id|inode-&gt;i_bdev
suffix:semicolon
r_return
id|generic_ide_ioctl
c_func
(paren
id|bdev
comma
id|cmd
comma
id|arg
)paren
suffix:semicolon
)brace
DECL|function|idedisk_media_changed
r_static
r_int
id|idedisk_media_changed
c_func
(paren
r_struct
id|gendisk
op_star
id|disk
)paren
(brace
id|ide_drive_t
op_star
id|drive
op_assign
id|disk-&gt;private_data
suffix:semicolon
multiline_comment|/* do not scan partitions twice if this is a removable device */
r_if
c_cond
(paren
id|drive-&gt;attach
)paren
(brace
id|drive-&gt;attach
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* if removable, always assume it was changed */
r_return
id|drive-&gt;removable
suffix:semicolon
)brace
DECL|function|idedisk_revalidate_disk
r_static
r_int
id|idedisk_revalidate_disk
c_func
(paren
r_struct
id|gendisk
op_star
id|disk
)paren
(brace
id|ide_drive_t
op_star
id|drive
op_assign
id|disk-&gt;private_data
suffix:semicolon
id|set_capacity
c_func
(paren
id|disk
comma
id|current_capacity
c_func
(paren
id|drive
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|idedisk_ops
r_static
r_struct
id|block_device_operations
id|idedisk_ops
op_assign
(brace
dot
id|owner
op_assign
id|THIS_MODULE
comma
dot
id|open
op_assign
id|idedisk_open
comma
dot
id|release
op_assign
id|idedisk_release
comma
dot
id|ioctl
op_assign
id|idedisk_ioctl
comma
dot
id|media_changed
op_assign
id|idedisk_media_changed
comma
dot
id|revalidate_disk
op_assign
id|idedisk_revalidate_disk
)brace
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;ATA DISK Driver&quot;
)paren
suffix:semicolon
DECL|function|idedisk_attach
r_static
r_int
id|idedisk_attach
c_func
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_struct
id|gendisk
op_star
id|g
op_assign
id|drive-&gt;disk
suffix:semicolon
multiline_comment|/* strstr(&quot;foo&quot;, &quot;&quot;) is non-NULL */
r_if
c_cond
(paren
op_logical_neg
id|strstr
c_func
(paren
l_string|&quot;ide-disk&quot;
comma
id|drive-&gt;driver_req
)paren
)paren
r_goto
id|failed
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|drive-&gt;present
)paren
r_goto
id|failed
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;media
op_ne
id|ide_disk
)paren
r_goto
id|failed
suffix:semicolon
r_if
c_cond
(paren
id|ide_register_subdriver
(paren
id|drive
comma
op_amp
id|idedisk_driver
comma
id|IDE_SUBDRIVER_VERSION
)paren
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;ide-disk: %s: Failed to register the driver with ide.c&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
r_goto
id|failed
suffix:semicolon
)brace
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|busy
op_increment
suffix:semicolon
id|idedisk_setup
c_func
(paren
id|drive
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
op_logical_neg
id|drive-&gt;head
op_logical_or
id|drive-&gt;head
OG
l_int|16
)paren
op_logical_and
op_logical_neg
id|drive-&gt;select.b.lba
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: INVALID GEOMETRY: %d PHYSICAL HEADS?&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|drive-&gt;head
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|drive-&gt;id-&gt;cfs_enable_2
op_amp
l_int|0x3000
)paren
op_logical_and
id|drive-&gt;wcache
)paren
r_if
c_cond
(paren
id|do_idedisk_flushcache
c_func
(paren
id|drive
)paren
)paren
id|printk
(paren
id|KERN_INFO
l_string|&quot;%s: Write Cache FAILED Flushing!&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
id|ide_unregister_subdriver
c_func
(paren
id|drive
)paren
suffix:semicolon
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|busy
op_decrement
suffix:semicolon
r_goto
id|failed
suffix:semicolon
)brace
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|busy
op_decrement
suffix:semicolon
id|g-&gt;minors
op_assign
l_int|1
op_lshift
id|PARTN_BITS
suffix:semicolon
id|strcpy
c_func
(paren
id|g-&gt;devfs_name
comma
id|drive-&gt;devfs_name
)paren
suffix:semicolon
id|g-&gt;driverfs_dev
op_assign
op_amp
id|drive-&gt;gendev
suffix:semicolon
id|g-&gt;flags
op_assign
id|drive-&gt;removable
ques
c_cond
id|GENHD_FL_REMOVABLE
suffix:colon
l_int|0
suffix:semicolon
id|set_capacity
c_func
(paren
id|g
comma
id|current_capacity
c_func
(paren
id|drive
)paren
)paren
suffix:semicolon
id|g-&gt;fops
op_assign
op_amp
id|idedisk_ops
suffix:semicolon
id|drive-&gt;attach
op_assign
l_int|1
suffix:semicolon
id|add_disk
c_func
(paren
id|g
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|failed
suffix:colon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|idedisk_exit
r_static
r_void
id|__exit
id|idedisk_exit
(paren
r_void
)paren
(brace
id|ide_unregister_driver
c_func
(paren
op_amp
id|idedisk_driver
)paren
suffix:semicolon
)brace
DECL|function|idedisk_init
r_static
r_int
id|idedisk_init
(paren
r_void
)paren
(brace
r_return
id|ide_register_driver
c_func
(paren
op_amp
id|idedisk_driver
)paren
suffix:semicolon
)brace
DECL|variable|idedisk_init
id|module_init
c_func
(paren
id|idedisk_init
)paren
suffix:semicolon
DECL|variable|idedisk_exit
id|module_exit
c_func
(paren
id|idedisk_exit
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
eof
