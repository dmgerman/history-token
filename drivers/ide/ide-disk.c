multiline_comment|/**** vi:set ts=8 sts=8 sw=8:************************************************&n; *&n; *  Copyright (C) 1994-1998,2002  Linus Torvalds and authors:&n; *&n; *&t;Mark Lord&t;&lt;mlord@pobox.com&gt;&n; *&t;Gadi Oxman&t;&lt;gadio@netvision.net.il&gt;&n; *&t;Andre Hedrick&t;&lt;andre@linux-ide.org&gt;&n; *&t;Jens Axboe&t;&lt;axboe@suse.de&gt;&n; *&t;Marcin Dalecki&t;&lt;martin@dalecki.de&gt;&n; *&n; * This is the ATA disk device driver, as evolved from hd.c and ide.c.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/major.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/genhd.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/buffer_head.h&gt;&t;&t;/* for invalidate_bdev() */
macro_line|#include &lt;linux/hdreg.h&gt;
macro_line|#include &lt;linux/ide.h&gt;
macro_line|#include &lt;asm/byteorder.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#ifdef CONFIG_BLK_DEV_PDC4030
DECL|macro|IS_PDC4030_DRIVE
macro_line|# define IS_PDC4030_DRIVE (drive-&gt;channel-&gt;chipset == ide_pdc4030)
macro_line|#else
DECL|macro|IS_PDC4030_DRIVE
macro_line|# define IS_PDC4030_DRIVE (0)&t;/* auto-NULLs out pdc4030 code */
macro_line|#endif
multiline_comment|/*&n; * for now, taskfile requests are special :/&n; */
DECL|function|ide_map_rq
r_static
r_inline
r_char
op_star
id|ide_map_rq
c_func
(paren
r_struct
id|request
op_star
id|rq
comma
r_int
r_int
op_star
id|flags
)paren
(brace
r_if
c_cond
(paren
id|rq-&gt;bio
)paren
r_return
id|bio_kmap_irq
c_func
(paren
id|rq-&gt;bio
comma
id|flags
)paren
op_plus
id|ide_rq_offset
c_func
(paren
id|rq
)paren
suffix:semicolon
r_else
r_return
id|rq-&gt;buffer
op_plus
(paren
(paren
id|rq
)paren
op_member_access_from_pointer
id|nr_sectors
op_minus
(paren
id|rq
)paren
op_member_access_from_pointer
id|current_nr_sectors
)paren
op_star
id|SECTOR_SIZE
suffix:semicolon
)brace
DECL|function|ide_unmap_rq
r_static
r_inline
r_void
id|ide_unmap_rq
c_func
(paren
r_struct
id|request
op_star
id|rq
comma
r_char
op_star
id|to
comma
r_int
r_int
op_star
id|flags
)paren
(brace
r_if
c_cond
(paren
id|rq-&gt;bio
)paren
id|bio_kunmap_irq
c_func
(paren
id|to
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Perform a sanity check on the claimed &quot;lba_capacity&quot;&n; * value for this drive (from its reported identification information).&n; *&n; * Returns:&t;1 if lba_capacity looks sensible&n; *&t;&t;0 otherwise&n; *&n; * It is called only once for each drive.&n; */
DECL|function|lba_capacity_is_ok
r_static
r_int
id|lba_capacity_is_ok
c_func
(paren
r_struct
id|hd_driveid
op_star
id|id
)paren
(brace
r_int
r_int
id|lba_sects
comma
id|chs_sects
comma
id|head
comma
id|tail
suffix:semicolon
r_if
c_cond
(paren
(paren
id|id-&gt;command_set_2
op_amp
l_int|0x0400
)paren
op_logical_and
(paren
id|id-&gt;cfs_enable_2
op_amp
l_int|0x0400
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;48-bit Drive: %llu &bslash;n&quot;
comma
id|id-&gt;lba_capacity_2
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * The ATA spec tells large drives to return&n;&t; * C/H/S = 16383/16/63 independent of their size.&n;&t; * Some drives can be jumpered to use 15 heads instead of 16.&n;&t; * Some drives can be jumpered to use 4092 cyls instead of 16383.&n;&t; */
r_if
c_cond
(paren
(paren
id|id-&gt;cyls
op_eq
l_int|16383
op_logical_or
(paren
id|id-&gt;cyls
op_eq
l_int|4092
op_logical_and
id|id-&gt;cur_cyls
op_eq
l_int|16383
)paren
)paren
op_logical_and
id|id-&gt;sectors
op_eq
l_int|63
op_logical_and
(paren
id|id-&gt;heads
op_eq
l_int|15
op_logical_or
id|id-&gt;heads
op_eq
l_int|16
)paren
op_logical_and
id|id-&gt;lba_capacity
op_ge
l_int|16383
op_star
l_int|63
op_star
id|id-&gt;heads
)paren
r_return
l_int|1
suffix:semicolon
id|lba_sects
op_assign
id|id-&gt;lba_capacity
suffix:semicolon
id|chs_sects
op_assign
id|id-&gt;cyls
op_star
id|id-&gt;heads
op_star
id|id-&gt;sectors
suffix:semicolon
multiline_comment|/* perform a rough sanity check on lba_sects:  within 10% is OK */
r_if
c_cond
(paren
(paren
id|lba_sects
op_minus
id|chs_sects
)paren
OL
id|chs_sects
op_div
l_int|10
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* some drives have the word order reversed */
id|head
op_assign
(paren
(paren
id|lba_sects
op_rshift
l_int|16
)paren
op_amp
l_int|0xffff
)paren
suffix:semicolon
id|tail
op_assign
(paren
id|lba_sects
op_amp
l_int|0xffff
)paren
suffix:semicolon
id|lba_sects
op_assign
(paren
id|head
op_or
(paren
id|tail
op_lshift
l_int|16
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|lba_sects
op_minus
id|chs_sects
)paren
OL
id|chs_sects
op_div
l_int|10
)paren
(brace
id|id-&gt;lba_capacity
op_assign
id|lba_sects
suffix:semicolon
r_return
l_int|1
suffix:semicolon
multiline_comment|/* lba_capacity is (now) good */
)brace
r_return
l_int|0
suffix:semicolon
multiline_comment|/* lba_capacity value may be bad */
)brace
multiline_comment|/*&n; * Handler for command with PIO data-in phase.&n; */
DECL|function|task_in_intr
r_static
id|ide_startstop_t
id|task_in_intr
c_func
(paren
r_struct
id|ata_device
op_star
id|drive
comma
r_struct
id|request
op_star
id|rq
)paren
(brace
r_int
id|ret
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ata_status
c_func
(paren
id|drive
comma
id|DATA_READY
comma
id|BAD_R_STAT
)paren
)paren
(brace
r_if
c_cond
(paren
id|drive-&gt;status
op_amp
(paren
id|ERR_STAT
op_or
id|DRQ_STAT
)paren
)paren
r_return
id|ata_error
c_func
(paren
id|drive
comma
id|rq
comma
id|__FUNCTION__
)paren
suffix:semicolon
multiline_comment|/* no data yet, so wait for another interrupt */
id|ata_set_handler
c_func
(paren
id|drive
comma
id|task_in_intr
comma
id|WAIT_CMD
comma
l_int|NULL
)paren
suffix:semicolon
id|ret
op_assign
id|ATA_OP_CONTINUES
suffix:semicolon
)brace
r_else
(brace
singleline_comment|//&t;printk(&quot;Read: %p, rq-&gt;current_nr_sectors: %d&bslash;n&quot;, buf, (int) rq-&gt;current_nr_sectors);
(brace
r_int
r_int
id|flags
suffix:semicolon
r_char
op_star
id|buf
suffix:semicolon
id|buf
op_assign
id|ide_map_rq
c_func
(paren
id|rq
comma
op_amp
id|flags
)paren
suffix:semicolon
id|ata_read
c_func
(paren
id|drive
comma
id|buf
comma
id|SECTOR_WORDS
)paren
suffix:semicolon
id|ide_unmap_rq
c_func
(paren
id|rq
comma
id|buf
comma
op_amp
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* First segment of the request is complete. note that this does not&n;&t;&t; * necessarily mean that the entire request is done!! this is only true&n;&t;&t; * if ata_end_request() returns 0.&n;&t;&t; */
id|rq-&gt;errors
op_assign
l_int|0
suffix:semicolon
op_decrement
id|rq-&gt;current_nr_sectors
suffix:semicolon
r_if
c_cond
(paren
id|rq-&gt;current_nr_sectors
op_le
l_int|0
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ata_end_request
c_func
(paren
id|drive
comma
id|rq
comma
l_int|1
comma
l_int|0
)paren
)paren
(brace
singleline_comment|//&t;&t;printk(&quot;Request Ended stat: %02x&bslash;n&quot;, drive-&gt;status);
r_return
id|ATA_OP_FINISHED
suffix:semicolon
)brace
)brace
multiline_comment|/* still data left to transfer */
id|ata_set_handler
c_func
(paren
id|drive
comma
id|task_in_intr
comma
id|WAIT_CMD
comma
l_int|NULL
)paren
suffix:semicolon
id|ret
op_assign
id|ATA_OP_CONTINUES
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Handler for command with PIO data-out phase.&n; */
DECL|function|task_out_intr
r_static
id|ide_startstop_t
id|task_out_intr
c_func
(paren
r_struct
id|ata_device
op_star
id|drive
comma
r_struct
id|request
op_star
id|rq
)paren
(brace
r_int
id|ret
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ata_status
c_func
(paren
id|drive
comma
id|DRIVE_READY
comma
id|drive-&gt;bad_wstat
)paren
)paren
r_return
id|ata_error
c_func
(paren
id|drive
comma
id|rq
comma
id|__FUNCTION__
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rq-&gt;current_nr_sectors
op_logical_and
op_logical_neg
id|ata_end_request
c_func
(paren
id|drive
comma
id|rq
comma
l_int|1
comma
l_int|0
)paren
)paren
(brace
id|ret
op_assign
id|ATA_OP_FINISHED
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
(paren
id|rq-&gt;nr_sectors
op_eq
l_int|1
)paren
op_ne
(paren
id|drive-&gt;status
op_amp
id|DRQ_STAT
)paren
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_char
op_star
id|buf
suffix:semicolon
singleline_comment|//&t;&t;&t;printk(&quot;write: %p, rq-&gt;current_nr_sectors: %d&bslash;n&quot;, buf, (int) rq-&gt;current_nr_sectors);
id|buf
op_assign
id|ide_map_rq
c_func
(paren
id|rq
comma
op_amp
id|flags
)paren
suffix:semicolon
id|ata_write
c_func
(paren
id|drive
comma
id|buf
comma
id|SECTOR_WORDS
)paren
suffix:semicolon
id|ide_unmap_rq
c_func
(paren
id|rq
comma
id|buf
comma
op_amp
id|flags
)paren
suffix:semicolon
id|rq-&gt;errors
op_assign
l_int|0
suffix:semicolon
op_decrement
id|rq-&gt;current_nr_sectors
suffix:semicolon
)brace
id|ata_set_handler
c_func
(paren
id|drive
comma
id|task_out_intr
comma
id|WAIT_CMD
comma
l_int|NULL
)paren
suffix:semicolon
id|ret
op_assign
id|ATA_OP_CONTINUES
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Handler for command with Read Multiple&n; */
DECL|function|task_mulin_intr
r_static
id|ide_startstop_t
id|task_mulin_intr
c_func
(paren
r_struct
id|ata_device
op_star
id|drive
comma
r_struct
id|request
op_star
id|rq
)paren
(brace
r_int
id|ret
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ata_status
c_func
(paren
id|drive
comma
id|DATA_READY
comma
id|BAD_R_STAT
)paren
)paren
(brace
r_if
c_cond
(paren
id|drive-&gt;status
op_amp
(paren
id|ERR_STAT
op_or
id|DRQ_STAT
)paren
)paren
r_return
id|ata_error
c_func
(paren
id|drive
comma
id|rq
comma
id|__FUNCTION__
)paren
suffix:semicolon
multiline_comment|/* no data yet, so wait for another interrupt */
id|ata_set_handler
c_func
(paren
id|drive
comma
id|task_mulin_intr
comma
id|WAIT_CMD
comma
l_int|NULL
)paren
suffix:semicolon
id|ret
op_assign
id|ATA_OP_CONTINUES
suffix:semicolon
)brace
r_else
(brace
r_int
r_int
id|msect
suffix:semicolon
multiline_comment|/* (ks/hs): Fixed Multi-Sector transfer */
id|msect
op_assign
id|drive-&gt;mult_count
suffix:semicolon
r_do
(brace
r_int
r_int
id|nsect
suffix:semicolon
id|nsect
op_assign
id|rq-&gt;current_nr_sectors
suffix:semicolon
r_if
c_cond
(paren
id|nsect
OG
id|msect
)paren
id|nsect
op_assign
id|msect
suffix:semicolon
macro_line|#if 0
id|printk
c_func
(paren
l_string|&quot;Multiread: %p, nsect: %d , rq-&gt;current_nr_sectors: %d&bslash;n&quot;
comma
id|buf
comma
id|nsect
comma
id|rq-&gt;current_nr_sectors
)paren
suffix:semicolon
macro_line|#endif
(brace
r_int
r_int
id|flags
suffix:semicolon
r_char
op_star
id|buf
suffix:semicolon
id|buf
op_assign
id|ide_map_rq
c_func
(paren
id|rq
comma
op_amp
id|flags
)paren
suffix:semicolon
id|ata_read
c_func
(paren
id|drive
comma
id|buf
comma
id|nsect
op_star
id|SECTOR_WORDS
)paren
suffix:semicolon
id|ide_unmap_rq
c_func
(paren
id|rq
comma
id|buf
comma
op_amp
id|flags
)paren
suffix:semicolon
)brace
id|rq-&gt;errors
op_assign
l_int|0
suffix:semicolon
id|rq-&gt;current_nr_sectors
op_sub_assign
id|nsect
suffix:semicolon
multiline_comment|/* FIXME: this seems buggy */
r_if
c_cond
(paren
id|rq-&gt;current_nr_sectors
op_le
l_int|0
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ata_end_request
c_func
(paren
id|drive
comma
id|rq
comma
l_int|1
comma
l_int|0
)paren
)paren
r_return
id|ATA_OP_FINISHED
suffix:semicolon
)brace
id|msect
op_sub_assign
id|nsect
suffix:semicolon
)brace
r_while
c_loop
(paren
id|msect
)paren
suffix:semicolon
multiline_comment|/* more data left */
id|ata_set_handler
c_func
(paren
id|drive
comma
id|task_mulin_intr
comma
id|WAIT_CMD
comma
l_int|NULL
)paren
suffix:semicolon
id|ret
op_assign
id|ATA_OP_CONTINUES
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|function|task_mulout_intr
r_static
id|ide_startstop_t
id|task_mulout_intr
c_func
(paren
r_struct
id|ata_device
op_star
id|drive
comma
r_struct
id|request
op_star
id|rq
)paren
(brace
r_int
id|ok
suffix:semicolon
r_int
id|ret
suffix:semicolon
multiline_comment|/*&n;&t; * FIXME: the drive-&gt;status checks here seem to be messy.&n;&t; *&n;&t; * (ks/hs): Handle last IRQ on multi-sector transfer,&n;&t; * occurs after all data was sent in this chunk&n;&t; */
id|ok
op_assign
id|ata_status
c_func
(paren
id|drive
comma
id|DATA_READY
comma
id|BAD_R_STAT
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ok
op_logical_or
op_logical_neg
id|rq-&gt;nr_sectors
)paren
(brace
r_if
c_cond
(paren
id|drive-&gt;status
op_amp
(paren
id|ERR_STAT
op_or
id|DRQ_STAT
)paren
)paren
r_return
id|ata_error
c_func
(paren
id|drive
comma
id|rq
comma
id|__FUNCTION__
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|rq-&gt;nr_sectors
)paren
(brace
id|ata_end_request
c_func
(paren
id|drive
comma
id|rq
comma
l_int|1
comma
id|rq-&gt;hard_nr_sectors
)paren
suffix:semicolon
id|rq-&gt;bio
op_assign
l_int|NULL
suffix:semicolon
id|ret
op_assign
id|ATA_OP_FINISHED
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|ok
)paren
(brace
multiline_comment|/* not ready yet, so wait for next IRQ */
id|ata_set_handler
c_func
(paren
id|drive
comma
id|task_mulout_intr
comma
id|WAIT_CMD
comma
l_int|NULL
)paren
suffix:semicolon
id|ret
op_assign
id|ATA_OP_CONTINUES
suffix:semicolon
)brace
r_else
(brace
r_int
id|mcount
op_assign
id|drive-&gt;mult_count
suffix:semicolon
multiline_comment|/* prepare for next IRQ */
id|ata_set_handler
c_func
(paren
id|drive
comma
id|task_mulout_intr
comma
id|WAIT_CMD
comma
l_int|NULL
)paren
suffix:semicolon
r_do
(brace
r_char
op_star
id|buf
suffix:semicolon
r_int
id|nsect
op_assign
id|rq-&gt;current_nr_sectors
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|nsect
OG
id|mcount
)paren
id|nsect
op_assign
id|mcount
suffix:semicolon
id|mcount
op_sub_assign
id|nsect
suffix:semicolon
id|buf
op_assign
id|bio_kmap_irq
c_func
(paren
id|rq-&gt;bio
comma
op_amp
id|flags
)paren
op_plus
id|ide_rq_offset
c_func
(paren
id|rq
)paren
suffix:semicolon
id|rq-&gt;sector
op_add_assign
id|nsect
suffix:semicolon
id|rq-&gt;nr_sectors
op_sub_assign
id|nsect
suffix:semicolon
id|rq-&gt;current_nr_sectors
op_sub_assign
id|nsect
suffix:semicolon
multiline_comment|/* Do we move to the next bio after this? */
r_if
c_cond
(paren
op_logical_neg
id|rq-&gt;current_nr_sectors
)paren
(brace
multiline_comment|/* remember to fix this up /jens */
r_struct
id|bio
op_star
id|bio
op_assign
id|rq-&gt;bio-&gt;bi_next
suffix:semicolon
multiline_comment|/* end early if we ran out of requests */
r_if
c_cond
(paren
op_logical_neg
id|bio
)paren
(brace
id|mcount
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|rq-&gt;bio
op_assign
id|bio
suffix:semicolon
id|rq-&gt;current_nr_sectors
op_assign
id|bio_iovec
c_func
(paren
id|bio
)paren
op_member_access_from_pointer
id|bv_len
op_rshift
l_int|9
suffix:semicolon
)brace
)brace
id|rq-&gt;errors
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* FIXME: why?  --bzolnier */
multiline_comment|/*&n;&t;&t;&t; * Ok, we&squot;re all setup for the interrupt re-entering us on the&n;&t;&t;&t; * last transfer.&n;&t;&t;&t; */
id|ata_write
c_func
(paren
id|drive
comma
id|buf
comma
id|nsect
op_star
id|SECTOR_WORDS
)paren
suffix:semicolon
id|bio_kunmap_irq
c_func
(paren
id|buf
comma
op_amp
id|flags
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|mcount
)paren
suffix:semicolon
id|ret
op_assign
id|ATA_OP_CONTINUES
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Issue a READ or WRITE command to a disk, using LBA if supported, or CHS&n; * otherwise, to address sectors.  It also takes care of issuing special&n; * DRIVE_CMDs.&n; */
DECL|function|idedisk_do_request
r_static
id|ide_startstop_t
id|idedisk_do_request
c_func
(paren
r_struct
id|ata_device
op_star
id|drive
comma
r_struct
id|request
op_star
id|rq
comma
id|sector_t
id|block
)paren
(brace
r_struct
id|ata_taskfile
id|args
suffix:semicolon
r_struct
id|ata_taskfile
op_star
id|ar
suffix:semicolon
r_struct
id|hd_driveid
op_star
id|id
op_assign
id|drive-&gt;id
suffix:semicolon
id|u8
id|cmd
suffix:semicolon
multiline_comment|/* Special drive commands don&squot;t need any kind of setup.&n;&t; */
r_if
c_cond
(paren
id|rq-&gt;flags
op_amp
id|REQ_SPECIAL
)paren
(brace
id|ar
op_assign
id|rq-&gt;special
suffix:semicolon
id|cmd
op_assign
id|ar-&gt;cmd
suffix:semicolon
)brace
r_else
(brace
r_int
r_int
id|sectors
suffix:semicolon
multiline_comment|/* FIXME: this check doesn&squot;t make sense */
r_if
c_cond
(paren
op_logical_neg
(paren
id|rq-&gt;flags
op_amp
id|REQ_CMD
)paren
)paren
(brace
id|blk_dump_rq_flags
c_func
(paren
id|rq
comma
l_string|&quot;idedisk_do_request - bad command&quot;
)paren
suffix:semicolon
id|ata_end_request
c_func
(paren
id|drive
comma
id|rq
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_return
id|ATA_OP_FINISHED
suffix:semicolon
)brace
r_if
c_cond
(paren
id|IS_PDC4030_DRIVE
)paren
(brace
r_extern
id|ide_startstop_t
id|promise_do_request
c_func
(paren
r_struct
id|ata_device
op_star
comma
r_struct
id|request
op_star
comma
id|sector_t
)paren
suffix:semicolon
r_return
id|promise_do_request
c_func
(paren
id|drive
comma
id|rq
comma
id|block
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * start a tagged operation&n;&t;&t; */
r_if
c_cond
(paren
id|drive-&gt;using_tcq
)paren
(brace
r_int
id|st
op_assign
id|blk_queue_start_tag
c_func
(paren
op_amp
id|drive-&gt;queue
comma
id|rq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ata_pending_commands
c_func
(paren
id|drive
)paren
OG
id|drive-&gt;max_depth
)paren
id|drive-&gt;max_depth
op_assign
id|ata_pending_commands
c_func
(paren
id|drive
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ata_pending_commands
c_func
(paren
id|drive
)paren
OG
id|drive-&gt;max_last_depth
)paren
id|drive-&gt;max_last_depth
op_assign
id|ata_pending_commands
c_func
(paren
id|drive
)paren
suffix:semicolon
r_if
c_cond
(paren
id|st
)paren
(brace
id|BUG_ON
c_func
(paren
op_logical_neg
id|ata_pending_commands
c_func
(paren
id|drive
)paren
)paren
suffix:semicolon
r_return
id|ATA_OP_CONTINUES
suffix:semicolon
)brace
)brace
id|ar
op_assign
op_amp
id|args
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|args
comma
l_int|0
comma
r_sizeof
(paren
id|args
)paren
)paren
suffix:semicolon
id|sectors
op_assign
id|rq-&gt;nr_sectors
suffix:semicolon
multiline_comment|/* Dispatch depending up on the drive access method. */
r_if
c_cond
(paren
(paren
id|drive-&gt;id-&gt;cfs_enable_2
op_amp
l_int|0x0400
)paren
op_logical_and
(paren
id|drive-&gt;addressing
)paren
)paren
(brace
multiline_comment|/* LBA 48 bit */
multiline_comment|/*&n;&t;&t;&t; * 268435455  == 137439 MB or 28bit limit&n;&t;&t;&t; * 320173056  == 163929 MB or 48bit addressing&n;&t;&t;&t; * 1073741822 == 549756 MB or 48bit addressing fake drive&n;&t;&t;&t; */
r_if
c_cond
(paren
id|sectors
op_eq
l_int|65536
)paren
id|sectors
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|blk_rq_tagged
c_func
(paren
id|rq
)paren
)paren
(brace
id|args.taskfile.feature
op_assign
id|sectors
suffix:semicolon
id|args.hobfile.feature
op_assign
id|sectors
op_rshift
l_int|8
suffix:semicolon
id|args.taskfile.sector_count
op_assign
id|rq-&gt;tag
op_lshift
l_int|3
suffix:semicolon
)brace
r_else
(brace
id|args.taskfile.sector_count
op_assign
id|sectors
suffix:semicolon
id|args.hobfile.sector_count
op_assign
id|sectors
op_rshift
l_int|8
suffix:semicolon
)brace
id|args.taskfile.sector_number
op_assign
id|block
suffix:semicolon
multiline_comment|/* low lba */
id|args.taskfile.low_cylinder
op_assign
(paren
id|block
op_rshift_assign
l_int|8
)paren
suffix:semicolon
multiline_comment|/* mid lba */
id|args.taskfile.high_cylinder
op_assign
(paren
id|block
op_rshift_assign
l_int|8
)paren
suffix:semicolon
multiline_comment|/* hi  lba */
id|args.taskfile.device_head
op_assign
id|drive-&gt;select.all
suffix:semicolon
id|args.hobfile.sector_number
op_assign
(paren
id|block
op_rshift_assign
l_int|8
)paren
suffix:semicolon
multiline_comment|/* low lba */
id|args.hobfile.low_cylinder
op_assign
(paren
id|block
op_rshift_assign
l_int|8
)paren
suffix:semicolon
multiline_comment|/* mid lba */
id|args.hobfile.high_cylinder
op_assign
(paren
id|block
op_rshift_assign
l_int|8
)paren
suffix:semicolon
multiline_comment|/* hi  lba */
)brace
r_else
r_if
c_cond
(paren
id|drive-&gt;select.b.lba
)paren
(brace
multiline_comment|/* LBA 28 bit  */
r_if
c_cond
(paren
id|sectors
op_eq
l_int|256
)paren
id|sectors
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|blk_rq_tagged
c_func
(paren
id|rq
)paren
)paren
(brace
id|args.taskfile.feature
op_assign
id|sectors
suffix:semicolon
id|args.taskfile.sector_count
op_assign
id|rq-&gt;tag
op_lshift
l_int|3
suffix:semicolon
)brace
r_else
id|args.taskfile.sector_count
op_assign
id|sectors
suffix:semicolon
id|args.taskfile.sector_number
op_assign
id|block
suffix:semicolon
id|args.taskfile.low_cylinder
op_assign
(paren
id|block
op_rshift_assign
l_int|8
)paren
suffix:semicolon
id|args.taskfile.high_cylinder
op_assign
(paren
id|block
op_rshift_assign
l_int|8
)paren
suffix:semicolon
id|args.taskfile.device_head
op_assign
(paren
(paren
id|block
op_rshift
l_int|8
)paren
op_amp
l_int|0x0f
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* CHS */
r_int
r_int
id|track
op_assign
(paren
id|block
op_div
id|drive-&gt;sect
)paren
suffix:semicolon
r_int
r_int
id|sect
op_assign
(paren
id|block
op_mod
id|drive-&gt;sect
)paren
op_plus
l_int|1
suffix:semicolon
r_int
r_int
id|head
op_assign
(paren
id|track
op_mod
id|drive-&gt;head
)paren
suffix:semicolon
r_int
r_int
id|cyl
op_assign
(paren
id|track
op_div
id|drive-&gt;head
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sectors
op_eq
l_int|256
)paren
id|sectors
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|blk_rq_tagged
c_func
(paren
id|rq
)paren
)paren
(brace
id|args.taskfile.feature
op_assign
id|sectors
suffix:semicolon
id|args.taskfile.sector_count
op_assign
id|rq-&gt;tag
op_lshift
l_int|3
suffix:semicolon
)brace
r_else
id|args.taskfile.sector_count
op_assign
id|sectors
suffix:semicolon
id|args.taskfile.sector_number
op_assign
id|sect
suffix:semicolon
id|args.taskfile.low_cylinder
op_assign
id|cyl
suffix:semicolon
id|args.taskfile.high_cylinder
op_assign
(paren
id|cyl
op_rshift
l_int|8
)paren
suffix:semicolon
id|args.taskfile.device_head
op_assign
id|head
suffix:semicolon
)brace
id|args.taskfile.device_head
op_or_assign
id|drive-&gt;select.all
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Decode with physical ATA command to use and setup associated data.&n;&t;&t; */
r_if
c_cond
(paren
id|rq_data_dir
c_func
(paren
id|rq
)paren
op_eq
id|READ
)paren
(brace
id|args.command_type
op_assign
id|IDE_DRIVE_TASK_IN
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;addressing
)paren
(brace
r_if
c_cond
(paren
id|drive-&gt;using_tcq
)paren
(brace
id|cmd
op_assign
id|WIN_READDMA_QUEUED_EXT
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|drive-&gt;using_dma
)paren
(brace
id|cmd
op_assign
id|WIN_READDMA_EXT
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|drive-&gt;mult_count
)paren
(brace
id|args.XXX_handler
op_assign
id|task_mulin_intr
suffix:semicolon
id|cmd
op_assign
id|WIN_MULTREAD_EXT
suffix:semicolon
)brace
r_else
(brace
id|args.XXX_handler
op_assign
id|task_in_intr
suffix:semicolon
id|cmd
op_assign
id|WIN_READ_EXT
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|drive-&gt;using_tcq
)paren
(brace
id|cmd
op_assign
id|WIN_READDMA_QUEUED
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|drive-&gt;using_dma
)paren
(brace
id|cmd
op_assign
id|WIN_READDMA
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|drive-&gt;mult_count
)paren
(brace
id|args.XXX_handler
op_assign
id|task_mulin_intr
suffix:semicolon
id|cmd
op_assign
id|WIN_MULTREAD
suffix:semicolon
)brace
r_else
(brace
id|args.XXX_handler
op_assign
id|task_in_intr
suffix:semicolon
id|cmd
op_assign
id|WIN_READ
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
id|args.command_type
op_assign
id|IDE_DRIVE_TASK_RAW_WRITE
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;addressing
)paren
(brace
r_if
c_cond
(paren
id|drive-&gt;using_tcq
)paren
(brace
id|cmd
op_assign
id|WIN_WRITEDMA_QUEUED_EXT
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|drive-&gt;using_dma
)paren
(brace
id|cmd
op_assign
id|WIN_WRITEDMA_EXT
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|drive-&gt;mult_count
)paren
(brace
id|args.XXX_handler
op_assign
id|task_mulout_intr
suffix:semicolon
id|cmd
op_assign
id|WIN_MULTWRITE_EXT
suffix:semicolon
)brace
r_else
(brace
id|args.XXX_handler
op_assign
id|task_out_intr
suffix:semicolon
id|cmd
op_assign
id|WIN_WRITE_EXT
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|drive-&gt;using_tcq
)paren
(brace
id|cmd
op_assign
id|WIN_WRITEDMA_QUEUED
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|drive-&gt;using_dma
)paren
(brace
id|cmd
op_assign
id|WIN_WRITEDMA
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|drive-&gt;mult_count
)paren
(brace
id|args.XXX_handler
op_assign
id|task_mulout_intr
suffix:semicolon
id|cmd
op_assign
id|WIN_MULTWRITE
suffix:semicolon
)brace
r_else
(brace
id|args.XXX_handler
op_assign
id|task_out_intr
suffix:semicolon
id|cmd
op_assign
id|WIN_WRITE
suffix:semicolon
)brace
)brace
)brace
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;%s: %sing: &quot;
comma
id|drive-&gt;name
comma
(paren
id|rq_data_dir
c_func
(paren
id|rq
)paren
op_eq
id|READ
)paren
ques
c_cond
l_string|&quot;read&quot;
suffix:colon
l_string|&quot;writ&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lba
)paren
id|printk
c_func
(paren
l_string|&quot;LBAsect=%lld, &quot;
comma
id|block
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;CHS=%d/%d/%d, &quot;
comma
id|cyl
comma
id|head
comma
id|sect
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;sectors=%ld, &quot;
comma
id|rq-&gt;nr_sectors
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;buffer=%p&bslash;n&quot;
comma
id|rq-&gt;buffer
)paren
suffix:semicolon
macro_line|#endif
id|ar-&gt;cmd
op_assign
id|cmd
suffix:semicolon
id|rq-&gt;special
op_assign
id|ar
suffix:semicolon
)brace
multiline_comment|/* (ks/hs): Moved to start, do not use for multiple out commands.&n;&t; * FIXME: why not?! */
r_if
c_cond
(paren
op_logical_neg
(paren
id|cmd
op_eq
id|CFA_WRITE_MULTI_WO_ERASE
op_logical_or
id|cmd
op_eq
id|WIN_MULTWRITE
op_logical_or
id|cmd
op_eq
id|WIN_MULTWRITE_EXT
)paren
)paren
(brace
id|ata_irq_enable
c_func
(paren
id|drive
comma
l_int|1
)paren
suffix:semicolon
id|ata_mask
c_func
(paren
id|drive
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|id-&gt;command_set_2
op_amp
l_int|0x0400
)paren
op_logical_and
(paren
id|id-&gt;cfs_enable_2
op_amp
l_int|0x0400
)paren
op_logical_and
(paren
id|drive-&gt;addressing
op_eq
l_int|1
)paren
)paren
id|ata_out_regfile
c_func
(paren
id|drive
comma
op_amp
id|ar-&gt;hobfile
)paren
suffix:semicolon
id|ata_out_regfile
c_func
(paren
id|drive
comma
op_amp
id|ar-&gt;taskfile
)paren
suffix:semicolon
id|OUT_BYTE
c_func
(paren
(paren
id|ar-&gt;taskfile.device_head
op_amp
(paren
id|drive-&gt;addressing
ques
c_cond
l_int|0xE0
suffix:colon
l_int|0xEF
)paren
)paren
op_or
id|drive-&gt;select.all
comma
id|IDE_SELECT_REG
)paren
suffix:semicolon
multiline_comment|/* FIXME: this is actually distingushing between PIO and DMA requests.&n;&t; */
r_if
c_cond
(paren
id|ar-&gt;XXX_handler
)paren
(brace
r_if
c_cond
(paren
id|ar-&gt;command_type
op_eq
id|IDE_DRIVE_TASK_IN
op_logical_or
id|ar-&gt;command_type
op_eq
id|IDE_DRIVE_TASK_NO_DATA
)paren
(brace
id|ata_set_handler
c_func
(paren
id|drive
comma
id|ar-&gt;XXX_handler
comma
id|WAIT_CMD
comma
l_int|NULL
)paren
suffix:semicolon
id|OUT_BYTE
c_func
(paren
id|cmd
comma
id|IDE_COMMAND_REG
)paren
suffix:semicolon
r_return
id|ATA_OP_CONTINUES
suffix:semicolon
)brace
multiline_comment|/* FIXME: Warning check for race between handlers for writing&n;&t;&t; * first block of data.  However since we are well inside the&n;&t;&t; * boundaries of the seek, we should be okay.&n;&t;&t; */
r_if
c_cond
(paren
id|ar-&gt;command_type
op_eq
id|IDE_DRIVE_TASK_RAW_WRITE
)paren
(brace
id|ide_startstop_t
id|ret
suffix:semicolon
id|OUT_BYTE
c_func
(paren
id|cmd
comma
id|IDE_COMMAND_REG
)paren
suffix:semicolon
id|ret
op_assign
id|ata_status_poll
c_func
(paren
id|drive
comma
id|DATA_READY
comma
id|drive-&gt;bad_wstat
comma
id|WAIT_DRQ
comma
id|rq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
id|ATA_OP_READY
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: no DRQ after issuing %s&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|drive-&gt;mult_count
ques
c_cond
l_string|&quot;MULTWRITE&quot;
suffix:colon
l_string|&quot;WRITE&quot;
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* FIXME: This doesn&squot;t make the slightest sense.&n;&t;&t;&t; * (ks/hs): Fixed Multi Write&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|cmd
op_eq
id|CFA_WRITE_MULTI_WO_ERASE
op_logical_or
id|cmd
op_eq
id|WIN_MULTWRITE
op_logical_or
id|cmd
op_eq
id|WIN_MULTWRITE_EXT
)paren
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_char
op_star
id|buf
op_assign
id|ide_map_rq
c_func
(paren
id|rq
comma
op_amp
id|flags
)paren
suffix:semicolon
id|ata_set_handler
c_func
(paren
id|drive
comma
id|ar-&gt;XXX_handler
comma
id|WAIT_CMD
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* For Write_sectors we need to stuff the first sector */
multiline_comment|/* FIXME: what if !rq-&gt;current_nr_sectors  --bzolnier */
id|ata_write
c_func
(paren
id|drive
comma
id|buf
comma
id|SECTOR_WORDS
)paren
suffix:semicolon
id|rq-&gt;current_nr_sectors
op_decrement
suffix:semicolon
id|ide_unmap_rq
c_func
(paren
id|rq
comma
id|buf
comma
op_amp
id|flags
)paren
suffix:semicolon
r_return
id|ATA_OP_CONTINUES
suffix:semicolon
)brace
r_else
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/* Polling wait until the drive is ready.&n;&t;&t;&t;&t; *&n;&t;&t;&t;&t; * Stuff the first sector(s) by calling the&n;&t;&t;&t;&t; * handler driectly therafter.&n;&t;&t;&t;&t; *&n;&t;&t;&t;&t; * FIXME: Replace hard-coded 100, what about&n;&t;&t;&t;&t; * error handling?&n;&t;&t;&t;&t; *&n;&t;&t;&t;&t; * FIXME: Whatabout the IRE clearing and not clearing case?!&n;&t;&t;&t;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|100
suffix:semicolon
op_increment
id|i
)paren
(brace
r_if
c_cond
(paren
id|ata_status_irq
c_func
(paren
id|drive
)paren
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|ata_status_irq
c_func
(paren
id|drive
)paren
)paren
(brace
multiline_comment|/* We are compleatly missing an error&n;&t;&t;&t;&t;&t; * return path here.&n;&t;&t;&t;&t;&t; * FIXME: We have only one? -alat&n;&t;&t;&t;&t;&t; */
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;DISASTER WAITING TO HAPPEN! Try to Stop it!&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|ata_error
c_func
(paren
id|drive
comma
id|rq
comma
id|__FUNCTION__
)paren
suffix:semicolon
)brace
multiline_comment|/* will set handler for us */
r_return
id|ar
op_member_access_from_pointer
id|XXX_handler
c_func
(paren
id|drive
comma
id|rq
)paren
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * FIXME: This is a gross hack, need to unify tcq dma proc and&n;&t;&t; * regular dma proc. It should now be easier.&n;&t;&t; *&n;&t;&t; * FIXME: Handle the alternateives by a command type.&n;&t;&t; */
multiline_comment|/* FIXME: ATA_OP_CONTINUES?  --bzolnier */
multiline_comment|/* Not started a request - BUG() ot ATA_OP_FINISHED to avoid lockup ? - alat*/
r_if
c_cond
(paren
op_logical_neg
id|drive-&gt;using_dma
)paren
r_return
id|ATA_OP_CONTINUES
suffix:semicolon
multiline_comment|/* for dma commands we don&squot;t set the handler */
r_if
c_cond
(paren
id|cmd
op_eq
id|WIN_WRITEDMA
op_logical_or
id|cmd
op_eq
id|WIN_WRITEDMA_EXT
op_logical_or
id|cmd
op_eq
id|WIN_READDMA
op_logical_or
id|cmd
op_eq
id|WIN_READDMA_EXT
)paren
r_return
id|udma_init
c_func
(paren
id|drive
comma
id|rq
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_IDE_TCQ
r_else
r_if
c_cond
(paren
id|cmd
op_eq
id|WIN_WRITEDMA_QUEUED
op_logical_or
id|cmd
op_eq
id|WIN_WRITEDMA_QUEUED_EXT
op_logical_or
id|cmd
op_eq
id|WIN_READDMA_QUEUED
op_logical_or
id|cmd
op_eq
id|WIN_READDMA_QUEUED_EXT
)paren
r_return
id|udma_tcq_init
c_func
(paren
id|drive
comma
id|rq
)paren
suffix:semicolon
macro_line|#endif
r_else
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: unknown command %x&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|cmd
)paren
suffix:semicolon
r_return
id|ATA_OP_FINISHED
suffix:semicolon
)brace
)brace
multiline_comment|/* not reached */
r_return
id|ATA_OP_CONTINUES
suffix:semicolon
)brace
DECL|function|idedisk_open
r_static
r_int
id|idedisk_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|__fp
comma
r_struct
id|ata_device
op_star
id|drive
)paren
(brace
id|MOD_INC_USE_COUNT
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;removable
op_logical_and
id|drive-&gt;usage
op_eq
l_int|1
)paren
(brace
id|check_disk_change
c_func
(paren
id|inode-&gt;i_bdev
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Ignore the return code from door_lock, since the open() has&n;&t;&t; * already succeeded once, and the door_lock is irrelevant at this&n;&t;&t; * time.&n;&t;&t; */
r_if
c_cond
(paren
id|drive-&gt;doorlocking
)paren
(brace
r_struct
id|ata_taskfile
id|args
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|args
comma
l_int|0
comma
r_sizeof
(paren
id|args
)paren
)paren
suffix:semicolon
id|args.cmd
op_assign
id|WIN_DOORLOCK
suffix:semicolon
r_if
c_cond
(paren
id|ide_raw_taskfile
c_func
(paren
id|drive
comma
op_amp
id|args
comma
l_int|NULL
)paren
)paren
id|drive-&gt;doorlocking
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|flush_cache
r_static
r_int
id|flush_cache
c_func
(paren
r_struct
id|ata_device
op_star
id|drive
)paren
(brace
r_struct
id|ata_taskfile
id|args
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|args
comma
l_int|0
comma
r_sizeof
(paren
id|args
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;id-&gt;cfs_enable_2
op_amp
l_int|0x2400
)paren
id|args.cmd
op_assign
id|WIN_FLUSH_CACHE_EXT
suffix:semicolon
r_else
id|args.cmd
op_assign
id|WIN_FLUSH_CACHE
suffix:semicolon
r_return
id|ide_raw_taskfile
c_func
(paren
id|drive
comma
op_amp
id|args
comma
l_int|NULL
)paren
suffix:semicolon
)brace
DECL|function|idedisk_release
r_static
r_void
id|idedisk_release
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
comma
r_struct
id|ata_device
op_star
id|drive
)paren
(brace
r_if
c_cond
(paren
id|drive-&gt;removable
op_logical_and
op_logical_neg
id|drive-&gt;usage
)paren
(brace
multiline_comment|/* XXX I don&squot;t think this is up to the lowlevel drivers..  --hch */
id|invalidate_bdev
c_func
(paren
id|inode-&gt;i_bdev
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;doorlocking
)paren
(brace
r_struct
id|ata_taskfile
id|args
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|args
comma
l_int|0
comma
r_sizeof
(paren
id|args
)paren
)paren
suffix:semicolon
id|args.cmd
op_assign
id|WIN_DOORUNLOCK
suffix:semicolon
r_if
c_cond
(paren
id|ide_raw_taskfile
c_func
(paren
id|drive
comma
op_amp
id|args
comma
l_int|NULL
)paren
)paren
id|drive-&gt;doorlocking
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
(paren
id|drive-&gt;id-&gt;cfs_enable_2
op_amp
l_int|0x3000
)paren
op_logical_and
id|drive-&gt;wcache
)paren
r_if
c_cond
(paren
id|flush_cache
c_func
(paren
id|drive
)paren
)paren
id|printk
(paren
id|KERN_INFO
l_string|&quot;%s: Write Cache FAILED Flushing!&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
)brace
DECL|function|idedisk_check_media_change
r_static
r_int
id|idedisk_check_media_change
c_func
(paren
r_struct
id|ata_device
op_star
id|drive
)paren
(brace
multiline_comment|/* if removable, always assume it was changed */
r_return
id|drive-&gt;removable
suffix:semicolon
)brace
DECL|function|idedisk_capacity
r_static
id|sector_t
id|idedisk_capacity
c_func
(paren
r_struct
id|ata_device
op_star
id|drive
)paren
(brace
r_return
id|drive-&gt;capacity
suffix:semicolon
)brace
multiline_comment|/*&n; * This is tightly woven into the driver-&gt;special can not touch.&n; * DON&squot;T do it again until a total personality rewrite is committed.&n; */
DECL|function|set_multcount
r_static
r_int
id|set_multcount
c_func
(paren
r_struct
id|ata_device
op_star
id|drive
comma
r_int
id|arg
)paren
(brace
r_struct
id|ata_taskfile
id|args
suffix:semicolon
multiline_comment|/* Setting multi mode count on this channel type is not supported/not&n;&t; * handled.&n;&t; */
r_if
c_cond
(paren
id|IS_PDC4030_DRIVE
)paren
r_return
op_minus
id|EIO
suffix:semicolon
multiline_comment|/* Hugh, we still didn&squot;t detect the devices capabilities.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|drive-&gt;id
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_if
c_cond
(paren
id|arg
OG
id|drive-&gt;id-&gt;max_multsect
)paren
id|arg
op_assign
id|drive-&gt;id-&gt;max_multsect
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|args
comma
l_int|0
comma
r_sizeof
(paren
id|args
)paren
)paren
suffix:semicolon
id|args.taskfile.sector_count
op_assign
id|arg
suffix:semicolon
id|args.cmd
op_assign
id|WIN_SETMULT
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ide_raw_taskfile
c_func
(paren
id|drive
comma
op_amp
id|args
comma
l_int|NULL
)paren
)paren
(brace
multiline_comment|/* all went well track this setting as valid */
id|drive-&gt;mult_count
op_assign
id|arg
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
id|drive-&gt;mult_count
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* reset */
r_return
op_minus
id|EIO
suffix:semicolon
)brace
DECL|function|set_nowerr
r_static
r_int
id|set_nowerr
c_func
(paren
r_struct
id|ata_device
op_star
id|drive
comma
r_int
id|arg
)paren
(brace
id|drive-&gt;nowerr
op_assign
id|arg
suffix:semicolon
id|drive-&gt;bad_wstat
op_assign
id|arg
ques
c_cond
id|BAD_R_STAT
suffix:colon
id|BAD_W_STAT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|write_cache
r_static
r_int
id|write_cache
c_func
(paren
r_struct
id|ata_device
op_star
id|drive
comma
r_int
id|arg
)paren
(brace
r_struct
id|ata_taskfile
id|args
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|drive-&gt;id-&gt;cfs_enable_2
op_amp
l_int|0x3000
)paren
)paren
r_return
l_int|1
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|args
comma
l_int|0
comma
r_sizeof
(paren
id|args
)paren
)paren
suffix:semicolon
id|args.taskfile.feature
op_assign
(paren
id|arg
)paren
ques
c_cond
id|SETFEATURES_EN_WCACHE
suffix:colon
id|SETFEATURES_DIS_WCACHE
suffix:semicolon
id|args.cmd
op_assign
id|WIN_SETFEATURES
suffix:semicolon
id|ide_raw_taskfile
c_func
(paren
id|drive
comma
op_amp
id|args
comma
l_int|NULL
)paren
suffix:semicolon
id|drive-&gt;wcache
op_assign
id|arg
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|idedisk_standby
r_static
r_int
id|idedisk_standby
c_func
(paren
r_struct
id|ata_device
op_star
id|drive
)paren
(brace
r_struct
id|ata_taskfile
id|args
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|args
comma
l_int|0
comma
r_sizeof
(paren
id|args
)paren
)paren
suffix:semicolon
id|args.cmd
op_assign
id|WIN_STANDBYNOW1
suffix:semicolon
r_return
id|ide_raw_taskfile
c_func
(paren
id|drive
comma
op_amp
id|args
comma
l_int|NULL
)paren
suffix:semicolon
)brace
DECL|function|set_acoustic
r_static
r_int
id|set_acoustic
c_func
(paren
r_struct
id|ata_device
op_star
id|drive
comma
r_int
id|arg
)paren
(brace
r_struct
id|ata_taskfile
id|args
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|args
comma
l_int|0
comma
r_sizeof
(paren
id|args
)paren
)paren
suffix:semicolon
id|args.taskfile.feature
op_assign
(paren
id|arg
)paren
ques
c_cond
id|SETFEATURES_EN_AAM
suffix:colon
id|SETFEATURES_DIS_AAM
suffix:semicolon
id|args.taskfile.sector_count
op_assign
id|arg
suffix:semicolon
id|args.cmd
op_assign
id|WIN_SETFEATURES
suffix:semicolon
id|ide_raw_taskfile
c_func
(paren
id|drive
comma
op_amp
id|args
comma
l_int|NULL
)paren
suffix:semicolon
id|drive-&gt;acoustic
op_assign
id|arg
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_BLK_DEV_IDE_TCQ
DECL|function|set_using_tcq
r_static
r_int
id|set_using_tcq
c_func
(paren
r_struct
id|ata_device
op_star
id|drive
comma
r_int
id|arg
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|drive-&gt;driver
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|drive-&gt;channel-&gt;udma_setup
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|arg
op_eq
id|drive-&gt;queue_depth
op_logical_and
id|drive-&gt;using_tcq
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * set depth, but check also id for max supported depth&n;&t; */
id|drive-&gt;queue_depth
op_assign
id|arg
ques
c_cond
id|arg
suffix:colon
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;id
)paren
(brace
r_if
c_cond
(paren
id|drive-&gt;queue_depth
OG
id|drive-&gt;id-&gt;queue_depth
op_plus
l_int|1
)paren
id|drive-&gt;queue_depth
op_assign
id|drive-&gt;id-&gt;queue_depth
op_plus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|udma_tcq_enable
c_func
(paren
id|drive
comma
id|arg
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif
DECL|function|probe_lba_addressing
r_static
r_int
id|probe_lba_addressing
c_func
(paren
r_struct
id|ata_device
op_star
id|drive
comma
r_int
id|arg
)paren
(brace
id|drive-&gt;addressing
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|drive-&gt;id-&gt;cfs_enable_2
op_amp
l_int|0x0400
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
id|drive-&gt;addressing
op_assign
id|arg
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|set_lba_addressing
r_static
r_int
id|set_lba_addressing
c_func
(paren
r_struct
id|ata_device
op_star
id|drive
comma
r_int
id|arg
)paren
(brace
r_return
(paren
id|probe_lba_addressing
c_func
(paren
id|drive
comma
id|arg
)paren
)paren
suffix:semicolon
)brace
DECL|function|idedisk_suspend
r_static
r_int
id|idedisk_suspend
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
id|u32
id|state
comma
id|u32
id|level
)paren
(brace
r_struct
id|ata_device
op_star
id|drive
op_assign
id|dev-&gt;driver_data
suffix:semicolon
multiline_comment|/* I hope that every freeze operations from the upper levels have&n;&t; * already been done...&n;&t; */
id|BUG_ON
c_func
(paren
id|in_interrupt
c_func
(paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|level
op_ne
id|SUSPEND_SAVE_STATE
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* wait until all commands are finished */
multiline_comment|/* FIXME: waiting for spinlocks should be done instead. */
r_while
c_loop
(paren
id|drive-&gt;channel-&gt;handler
)paren
id|yield
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* set the drive to standby */
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;suspending: %s &quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ata_ops
c_func
(paren
id|drive
)paren
)paren
(brace
r_if
c_cond
(paren
id|ata_ops
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|standby
)paren
id|ata_ops
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|standby
c_func
(paren
id|drive
)paren
suffix:semicolon
)brace
id|drive-&gt;blocked
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|idedisk_resume
r_static
r_int
id|idedisk_resume
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
id|u32
id|level
)paren
(brace
r_struct
id|ata_device
op_star
id|drive
op_assign
id|dev-&gt;driver_data
suffix:semicolon
r_if
c_cond
(paren
id|level
op_ne
id|RESUME_RESTORE_STATE
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|drive-&gt;blocked
)paren
id|panic
c_func
(paren
l_string|&quot;ide: Resume but not suspended?&bslash;n&quot;
)paren
suffix:semicolon
id|drive-&gt;blocked
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* This is just a hook for the overall driver tree.&n; */
DECL|variable|disk_devdrv
r_static
r_struct
id|device_driver
id|disk_devdrv
op_assign
(brace
dot
id|lock
op_assign
id|RW_LOCK_UNLOCKED
comma
dot
id|suspend
op_assign
id|idedisk_suspend
comma
dot
id|resume
op_assign
id|idedisk_resume
comma
)brace
suffix:semicolon
multiline_comment|/*&n; * Queries for true maximum capacity of the drive.&n; * Returns maximum LBA address (&gt; 0) of the drive, 0 if failed.&n; */
DECL|function|native_max_address
r_static
r_int
r_int
id|native_max_address
c_func
(paren
r_struct
id|ata_device
op_star
id|drive
)paren
(brace
r_struct
id|ata_taskfile
id|args
suffix:semicolon
r_int
r_int
id|addr
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|drive-&gt;id-&gt;command_set_1
op_amp
l_int|0x0400
)paren
op_logical_and
op_logical_neg
(paren
id|drive-&gt;id-&gt;cfs_enable_2
op_amp
l_int|0x0100
)paren
)paren
r_return
id|addr
suffix:semicolon
multiline_comment|/* Create IDE/ATA command request structure */
id|memset
c_func
(paren
op_amp
id|args
comma
l_int|0
comma
r_sizeof
(paren
id|args
)paren
)paren
suffix:semicolon
id|args.taskfile.device_head
op_assign
l_int|0x40
suffix:semicolon
id|args.cmd
op_assign
id|WIN_READ_NATIVE_MAX
suffix:semicolon
id|ide_raw_taskfile
c_func
(paren
id|drive
comma
op_amp
id|args
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* if OK, compute maximum address value */
r_if
c_cond
(paren
op_logical_neg
(paren
id|drive-&gt;status
op_amp
id|ERR_STAT
)paren
)paren
(brace
id|addr
op_assign
(paren
(paren
id|args.taskfile.device_head
op_amp
l_int|0x0f
)paren
op_lshift
l_int|24
)paren
op_or
(paren
id|args.taskfile.high_cylinder
op_lshift
l_int|16
)paren
op_or
(paren
id|args.taskfile.low_cylinder
op_lshift
l_int|8
)paren
op_or
id|args.taskfile.sector_number
suffix:semicolon
)brace
id|addr
op_increment
suffix:semicolon
multiline_comment|/* since the return value is (maxlba - 1), we add 1 */
r_return
id|addr
suffix:semicolon
)brace
DECL|function|native_max_address_ext
r_static
id|u64
id|native_max_address_ext
c_func
(paren
r_struct
id|ata_device
op_star
id|drive
)paren
(brace
r_struct
id|ata_taskfile
id|args
suffix:semicolon
id|u64
id|addr
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Create IDE/ATA command request structure */
id|memset
c_func
(paren
op_amp
id|args
comma
l_int|0
comma
r_sizeof
(paren
id|args
)paren
)paren
suffix:semicolon
id|args.taskfile.device_head
op_assign
l_int|0x40
suffix:semicolon
id|args.cmd
op_assign
id|WIN_READ_NATIVE_MAX_EXT
suffix:semicolon
id|ide_raw_taskfile
c_func
(paren
id|drive
comma
op_amp
id|args
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* if OK, compute maximum address value */
r_if
c_cond
(paren
op_logical_neg
(paren
id|drive-&gt;status
op_amp
id|ERR_STAT
)paren
)paren
(brace
id|u32
id|high
op_assign
(paren
id|args.hobfile.high_cylinder
op_lshift
l_int|16
)paren
op_or
(paren
id|args.hobfile.low_cylinder
op_lshift
l_int|8
)paren
op_or
id|args.hobfile.sector_number
suffix:semicolon
id|u32
id|low
op_assign
(paren
id|args.taskfile.high_cylinder
op_lshift
l_int|16
)paren
op_or
(paren
id|args.taskfile.low_cylinder
op_lshift
l_int|8
)paren
op_or
id|args.taskfile.sector_number
suffix:semicolon
id|addr
op_assign
(paren
(paren
id|u64
)paren
id|high
op_lshift
l_int|24
)paren
op_or
id|low
suffix:semicolon
)brace
id|addr
op_increment
suffix:semicolon
multiline_comment|/* since the return value is (maxlba - 1), we add 1 */
r_return
id|addr
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_IDEDISK_STROKE
multiline_comment|/*&n; * Sets maximum virtual LBA address of the drive.&n; * Returns new maximum virtual LBA address (&gt; 0) or 0 on failure.&n; */
DECL|function|set_max_address
r_static
id|sector_t
id|set_max_address
c_func
(paren
r_struct
id|ata_device
op_star
id|drive
comma
id|sector_t
id|addr_req
)paren
(brace
r_struct
id|ata_taskfile
id|args
suffix:semicolon
id|sector_t
id|addr_set
op_assign
l_int|0
suffix:semicolon
id|addr_req
op_decrement
suffix:semicolon
multiline_comment|/* Create IDE/ATA command request structure */
id|memset
c_func
(paren
op_amp
id|args
comma
l_int|0
comma
r_sizeof
(paren
id|args
)paren
)paren
suffix:semicolon
id|args.taskfile.sector_number
op_assign
(paren
id|addr_req
op_rshift
l_int|0
)paren
suffix:semicolon
id|args.taskfile.low_cylinder
op_assign
(paren
id|addr_req
op_rshift
l_int|8
)paren
suffix:semicolon
id|args.taskfile.high_cylinder
op_assign
(paren
id|addr_req
op_rshift
l_int|16
)paren
suffix:semicolon
id|args.taskfile.device_head
op_assign
(paren
(paren
id|addr_req
op_rshift
l_int|24
)paren
op_amp
l_int|0x0f
)paren
op_or
l_int|0x40
suffix:semicolon
id|args.cmd
op_assign
id|WIN_SET_MAX
suffix:semicolon
id|ide_raw_taskfile
c_func
(paren
id|drive
comma
op_amp
id|args
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* if OK, read new maximum address value */
r_if
c_cond
(paren
op_logical_neg
(paren
id|drive-&gt;status
op_amp
id|ERR_STAT
)paren
)paren
(brace
id|addr_set
op_assign
(paren
(paren
id|args.taskfile.device_head
op_amp
l_int|0x0f
)paren
op_lshift
l_int|24
)paren
op_or
(paren
id|args.taskfile.high_cylinder
op_lshift
l_int|16
)paren
op_or
(paren
id|args.taskfile.low_cylinder
op_lshift
l_int|8
)paren
op_or
id|args.taskfile.sector_number
suffix:semicolon
)brace
id|addr_set
op_increment
suffix:semicolon
r_return
id|addr_set
suffix:semicolon
)brace
DECL|function|set_max_address_ext
r_static
id|u64
id|set_max_address_ext
c_func
(paren
r_struct
id|ata_device
op_star
id|drive
comma
id|u64
id|addr_req
)paren
(brace
r_struct
id|ata_taskfile
id|args
suffix:semicolon
id|u64
id|addr_set
op_assign
l_int|0
suffix:semicolon
id|addr_req
op_decrement
suffix:semicolon
multiline_comment|/* Create IDE/ATA command request structure */
id|memset
c_func
(paren
op_amp
id|args
comma
l_int|0
comma
r_sizeof
(paren
id|args
)paren
)paren
suffix:semicolon
id|args.taskfile.sector_number
op_assign
(paren
id|addr_req
op_rshift
l_int|0
)paren
suffix:semicolon
id|args.taskfile.low_cylinder
op_assign
(paren
id|addr_req
op_rshift_assign
l_int|8
)paren
suffix:semicolon
id|args.taskfile.high_cylinder
op_assign
(paren
id|addr_req
op_rshift_assign
l_int|8
)paren
suffix:semicolon
id|args.taskfile.device_head
op_assign
l_int|0x40
suffix:semicolon
id|args.cmd
op_assign
id|WIN_SET_MAX_EXT
suffix:semicolon
id|args.hobfile.sector_number
op_assign
(paren
id|addr_req
op_rshift_assign
l_int|8
)paren
suffix:semicolon
id|args.hobfile.low_cylinder
op_assign
(paren
id|addr_req
op_rshift_assign
l_int|8
)paren
suffix:semicolon
id|args.hobfile.high_cylinder
op_assign
(paren
id|addr_req
op_rshift_assign
l_int|8
)paren
suffix:semicolon
id|args.hobfile.device_head
op_assign
l_int|0x40
suffix:semicolon
id|ide_raw_taskfile
c_func
(paren
id|drive
comma
op_amp
id|args
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* if OK, compute maximum address value */
r_if
c_cond
(paren
op_logical_neg
(paren
id|drive-&gt;status
op_amp
id|ERR_STAT
)paren
)paren
(brace
id|u32
id|high
op_assign
(paren
id|args.hobfile.high_cylinder
op_lshift
l_int|16
)paren
op_or
(paren
id|args.hobfile.low_cylinder
op_lshift
l_int|8
)paren
op_or
id|args.hobfile.sector_number
suffix:semicolon
id|u32
id|low
op_assign
(paren
id|args.taskfile.high_cylinder
op_lshift
l_int|16
)paren
op_or
(paren
id|args.taskfile.low_cylinder
op_lshift
l_int|8
)paren
op_or
id|args.taskfile.sector_number
suffix:semicolon
id|addr_set
op_assign
(paren
(paren
id|u64
)paren
id|high
op_lshift
l_int|24
)paren
op_or
id|low
suffix:semicolon
)brace
r_return
id|addr_set
suffix:semicolon
)brace
macro_line|#endif
DECL|function|idedisk_setup
r_static
r_void
id|idedisk_setup
c_func
(paren
r_struct
id|ata_device
op_star
id|drive
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|hd_driveid
op_star
id|id
op_assign
id|drive-&gt;id
suffix:semicolon
id|sector_t
id|capacity
suffix:semicolon
id|sector_t
id|set_max
suffix:semicolon
r_int
id|drvid
op_assign
op_minus
l_int|1
suffix:semicolon
r_struct
id|ata_channel
op_star
id|ch
op_assign
id|drive-&gt;channel
suffix:semicolon
r_if
c_cond
(paren
id|id
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t; * CompactFlash cards and their brethern look just like hard drives&n;&t; * to us, but they are removable and don&squot;t have a doorlock mechanism.&n;&t; */
r_if
c_cond
(paren
id|drive-&gt;removable
op_logical_and
op_logical_neg
id|drive_is_flashcard
c_func
(paren
id|drive
)paren
)paren
(brace
multiline_comment|/* Removable disks (eg. SYQUEST); ignore &squot;WD&squot; drives.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|id-&gt;model
comma
l_string|&quot;WD&quot;
comma
l_int|2
)paren
)paren
id|drive-&gt;doorlocking
op_assign
l_int|1
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_DRIVES
suffix:semicolon
op_increment
id|i
)paren
(brace
r_if
c_cond
(paren
id|drive
op_ne
op_amp
id|ch-&gt;drives
(braket
id|i
)braket
)paren
r_continue
suffix:semicolon
id|drvid
op_assign
id|i
suffix:semicolon
id|ch-&gt;gd
(braket
id|i
)braket
op_member_access_from_pointer
id|de_arr
(braket
l_int|0
)braket
op_assign
id|drive-&gt;de
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;removable
)paren
id|ch-&gt;gd
(braket
id|i
)braket
op_member_access_from_pointer
id|flags
(braket
l_int|0
)braket
op_or_assign
id|GENHD_FL_REMOVABLE
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Register us within the device tree.&n;&t; */
r_if
c_cond
(paren
id|drvid
op_ne
op_minus
l_int|1
)paren
(brace
id|sprintf
c_func
(paren
id|drive-&gt;dev.bus_id
comma
l_string|&quot;sd@%x,%x&quot;
comma
id|ch-&gt;unit
comma
id|drvid
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|drive-&gt;dev.name
comma
l_string|&quot;ATA-Disk&quot;
)paren
suffix:semicolon
id|drive-&gt;dev.driver
op_assign
op_amp
id|disk_devdrv
suffix:semicolon
id|drive-&gt;dev.parent
op_assign
op_amp
id|ch-&gt;dev
suffix:semicolon
id|drive-&gt;dev.driver_data
op_assign
id|drive
suffix:semicolon
id|device_register
c_func
(paren
op_amp
id|drive-&gt;dev
)paren
suffix:semicolon
)brace
multiline_comment|/* Extract geometry if we did not already have one for the drive */
r_if
c_cond
(paren
op_logical_neg
id|drive-&gt;cyl
op_logical_or
op_logical_neg
id|drive-&gt;head
op_logical_or
op_logical_neg
id|drive-&gt;sect
)paren
(brace
id|drive-&gt;cyl
op_assign
id|drive-&gt;bios_cyl
op_assign
id|id-&gt;cyls
suffix:semicolon
id|drive-&gt;head
op_assign
id|drive-&gt;bios_head
op_assign
id|id-&gt;heads
suffix:semicolon
id|drive-&gt;sect
op_assign
id|drive-&gt;bios_sect
op_assign
id|id-&gt;sectors
suffix:semicolon
)brace
multiline_comment|/* Handle logical geometry translation by the drive. */
r_if
c_cond
(paren
(paren
id|id-&gt;field_valid
op_amp
l_int|1
)paren
op_logical_and
id|id-&gt;cur_cyls
op_logical_and
id|id-&gt;cur_heads
op_logical_and
(paren
id|id-&gt;cur_heads
op_le
l_int|16
)paren
op_logical_and
id|id-&gt;cur_sectors
)paren
(brace
id|drive-&gt;cyl
op_assign
id|id-&gt;cur_cyls
suffix:semicolon
id|drive-&gt;head
op_assign
id|id-&gt;cur_heads
suffix:semicolon
id|drive-&gt;sect
op_assign
id|id-&gt;cur_sectors
suffix:semicolon
)brace
multiline_comment|/* Use physical geometry if what we have still makes no sense. */
r_if
c_cond
(paren
id|drive-&gt;head
OG
l_int|16
op_logical_and
id|id-&gt;heads
op_logical_and
id|id-&gt;heads
op_le
l_int|16
)paren
(brace
id|drive-&gt;cyl
op_assign
id|id-&gt;cyls
suffix:semicolon
id|drive-&gt;head
op_assign
id|id-&gt;heads
suffix:semicolon
id|drive-&gt;sect
op_assign
id|id-&gt;sectors
suffix:semicolon
)brace
multiline_comment|/* Calculate drive capacity, and select LBA if possible.&n;&t; * drive-&gt;id != NULL is spected&n;&t; *&n;&t; * To compute capacity, this uses either of&n;&t; *&n;&t; *    1. CHS value set by user       (whatever user sets will be trusted)&n;&t; *    2. LBA value from target drive (require new ATA feature)&n;&t; *    3. LBA value from system BIOS  (new one is OK, old one may break)&n;&t; *    4. CHS value from system BIOS  (traditional style)&n;&t; *&n;&t; * in above order (i.e., if value of higher priority is available,&n;&t; * reset will be ignored).&n;&t; */
id|capacity
op_assign
id|drive-&gt;cyl
op_star
id|drive-&gt;head
op_star
id|drive-&gt;sect
suffix:semicolon
id|set_max
op_assign
id|native_max_address
c_func
(paren
id|drive
)paren
suffix:semicolon
id|drive-&gt;capacity
op_assign
l_int|0
suffix:semicolon
id|drive-&gt;select.b.lba
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|id-&gt;cfs_enable_2
op_amp
l_int|0x0400
)paren
(brace
id|u64
id|set_max_ext
suffix:semicolon
id|u64
id|capacity_2
suffix:semicolon
id|capacity_2
op_assign
id|capacity
suffix:semicolon
id|capacity_2
op_assign
id|id-&gt;lba_capacity_2
suffix:semicolon
id|drive-&gt;cyl
op_assign
(paren
r_int
r_int
)paren
id|capacity_2
op_div
(paren
id|drive-&gt;head
op_star
id|drive-&gt;sect
)paren
suffix:semicolon
id|drive-&gt;head
op_assign
id|drive-&gt;bios_head
op_assign
l_int|255
suffix:semicolon
id|drive-&gt;sect
op_assign
id|drive-&gt;bios_sect
op_assign
l_int|63
suffix:semicolon
id|drive-&gt;select.b.lba
op_assign
l_int|1
suffix:semicolon
id|set_max_ext
op_assign
id|native_max_address_ext
c_func
(paren
id|drive
)paren
suffix:semicolon
r_if
c_cond
(paren
id|set_max_ext
OG
id|capacity_2
)paren
(brace
macro_line|#ifdef CONFIG_IDEDISK_STROKE
id|set_max_ext
op_assign
id|native_max_address_ext
c_func
(paren
id|drive
)paren
suffix:semicolon
id|set_max_ext
op_assign
id|set_max_address_ext
c_func
(paren
id|drive
comma
id|set_max_ext
)paren
suffix:semicolon
r_if
c_cond
(paren
id|set_max_ext
)paren
(brace
id|drive-&gt;capacity
op_assign
id|capacity_2
op_assign
id|set_max_ext
suffix:semicolon
id|drive-&gt;cyl
op_assign
(paren
r_int
r_int
)paren
id|set_max_ext
op_div
(paren
id|drive-&gt;head
op_star
id|drive-&gt;sect
)paren
suffix:semicolon
id|drive-&gt;select.b.lba
op_assign
l_int|1
suffix:semicolon
id|drive-&gt;id-&gt;lba_capacity_2
op_assign
id|capacity_2
suffix:semicolon
)brace
macro_line|#else
id|printk
c_func
(paren
l_string|&quot;%s: setmax_ext LBA %llu, native  %llu&bslash;n&quot;
comma
id|drive-&gt;name
comma
(paren
r_int
r_int
)paren
id|set_max_ext
comma
(paren
r_int
r_int
)paren
id|capacity_2
)paren
suffix:semicolon
macro_line|#endif
)brace
id|drive-&gt;bios_cyl
op_assign
id|drive-&gt;cyl
suffix:semicolon
id|drive-&gt;capacity
op_assign
id|capacity_2
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * Determine capacity, and use LBA if the drive properly&n;&t;&t; * supports it.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|id-&gt;capability
op_amp
l_int|2
)paren
op_logical_and
id|lba_capacity_is_ok
c_func
(paren
id|id
)paren
)paren
(brace
id|capacity
op_assign
id|id-&gt;lba_capacity
suffix:semicolon
id|drive-&gt;cyl
op_assign
id|capacity
op_div
(paren
id|drive-&gt;head
op_star
id|drive-&gt;sect
)paren
suffix:semicolon
id|drive-&gt;select.b.lba
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|set_max
OG
id|capacity
)paren
(brace
macro_line|#ifdef CONFIG_IDEDISK_STROKE
id|set_max
op_assign
id|native_max_address
c_func
(paren
id|drive
)paren
suffix:semicolon
id|set_max
op_assign
id|set_max_address
c_func
(paren
id|drive
comma
id|set_max
)paren
suffix:semicolon
r_if
c_cond
(paren
id|set_max
)paren
(brace
id|drive-&gt;capacity
op_assign
id|capacity
op_assign
id|set_max
suffix:semicolon
id|drive-&gt;cyl
op_assign
id|set_max
op_div
(paren
id|drive-&gt;head
op_star
id|drive-&gt;sect
)paren
suffix:semicolon
id|drive-&gt;select.b.lba
op_assign
l_int|1
suffix:semicolon
id|drive-&gt;id-&gt;lba_capacity
op_assign
id|capacity
suffix:semicolon
)brace
macro_line|#else
id|printk
c_func
(paren
l_string|&quot;%s: setmax LBA %lu, native  %lu&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|set_max
comma
id|capacity
)paren
suffix:semicolon
macro_line|#endif
)brace
id|drive-&gt;capacity
op_assign
id|capacity
suffix:semicolon
r_if
c_cond
(paren
(paren
id|id-&gt;command_set_2
op_amp
l_int|0x0400
)paren
op_logical_and
(paren
id|id-&gt;cfs_enable_2
op_amp
l_int|0x0400
)paren
)paren
(brace
id|drive-&gt;capacity
op_assign
id|id-&gt;lba_capacity_2
suffix:semicolon
id|drive-&gt;head
op_assign
l_int|255
suffix:semicolon
id|drive-&gt;sect
op_assign
l_int|63
suffix:semicolon
id|drive-&gt;cyl
op_assign
(paren
r_int
r_int
)paren
(paren
id|drive-&gt;capacity
)paren
op_div
(paren
id|drive-&gt;head
op_star
id|drive-&gt;sect
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * If possible, give fdisk access to more of the drive,&n;&t; * by correcting bios_cyls:&n;&t; */
id|capacity
op_assign
id|idedisk_capacity
c_func
(paren
id|drive
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|capacity
op_ge
(paren
id|drive-&gt;bios_cyl
op_star
id|drive-&gt;bios_sect
op_star
id|drive-&gt;bios_head
)paren
)paren
op_logical_and
(paren
op_logical_neg
id|drive-&gt;forced_geom
)paren
op_logical_and
id|drive-&gt;bios_sect
op_logical_and
id|drive-&gt;bios_head
)paren
id|drive-&gt;bios_cyl
op_assign
(paren
id|capacity
op_div
id|drive-&gt;bios_sect
)paren
op_div
id|drive-&gt;bios_head
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot; %s: %ld sectors&quot;
comma
id|drive-&gt;name
comma
id|capacity
)paren
suffix:semicolon
macro_line|#if 0
multiline_comment|/* Right now we avoid this calculation, since it can result in the&n;&t; * usage of not supported compiler internal functions on 32 bit hosts.&n;&t; * However since the calculation appears to be an interesting piece of&n;&t; * number theory let&squot;s preserve the formula here.&n;&t; */
multiline_comment|/* Give size in megabytes (MB), not mebibytes (MiB).&n;&t; * We compute the exact rounded value, avoiding overflow.&n;&t; */
id|printk
c_func
(paren
l_string|&quot; (%ld MB)&quot;
comma
(paren
id|capacity
op_minus
id|capacity
op_div
l_int|625
op_plus
l_int|974
)paren
op_div
l_int|1950
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Only print cache size when it was specified.&n;&t; */
r_if
c_cond
(paren
id|id-&gt;buf_size
)paren
id|printk
(paren
l_string|&quot; w/%dKiB Cache&quot;
comma
id|id-&gt;buf_size
op_div
l_int|2
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;, CHS=%d/%d/%d&quot;
comma
id|drive-&gt;bios_cyl
comma
id|drive-&gt;bios_head
comma
id|drive-&gt;bios_sect
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_IDEDMA
r_if
c_cond
(paren
id|drive-&gt;using_dma
)paren
id|udma_print
c_func
(paren
id|drive
)paren
suffix:semicolon
macro_line|#endif
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|drive-&gt;mult_count
op_assign
l_int|0
suffix:semicolon
macro_line|#if 0
r_if
c_cond
(paren
id|id-&gt;max_multsect
)paren
(brace
multiline_comment|/* FIXME: reenable this again after making it to use&n;&t;&t; * the same code path as the ioctl stuff.&n;&t;&t; */
macro_line|#ifdef CONFIG_IDEDISK_MULTI_MODE
id|id-&gt;multsect
op_assign
(paren
(paren
id|id-&gt;max_multsect
op_div
l_int|2
)paren
OG
l_int|1
)paren
ques
c_cond
id|id-&gt;max_multsect
suffix:colon
l_int|0
suffix:semicolon
id|id-&gt;multsect_valid
op_assign
id|id-&gt;multsect
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
id|drive-&gt;mult_req
op_assign
id|id-&gt;multsect_valid
ques
c_cond
id|id-&gt;max_multsect
suffix:colon
id|INITIAL_MULT_COUNT
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;mult_req
)paren
id|drive-&gt;special_cmd
op_or_assign
id|ATA_SPECIAL_MMODE
suffix:semicolon
macro_line|#else
multiline_comment|/* original, pre IDE-NFG, per request of AC */
id|drive-&gt;mult_req
op_assign
id|INITIAL_MULT_COUNT
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;mult_req
OG
id|id-&gt;max_multsect
)paren
id|drive-&gt;mult_req
op_assign
id|id-&gt;max_multsect
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;mult_req
op_logical_or
(paren
(paren
id|id-&gt;multsect_valid
op_amp
l_int|1
)paren
op_logical_and
id|id-&gt;multsect
)paren
)paren
id|drive-&gt;special_cmd
op_or_assign
id|ATA_SPECIAL_MMODE
suffix:semicolon
macro_line|#endif
)brace
macro_line|#endif
multiline_comment|/* FIXME: Nowadays there are many chipsets out there which *require* 32&n;&t; * bit IO. Those will most propably not work properly with drives not&n;&t; * supporting this. But right now we don&squot;t do anything about this. We&n;&t; * dont&squot; even *warn* the user!&n;&t; */
id|drive-&gt;channel-&gt;no_io_32bit
op_assign
id|id-&gt;dword_io
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;id-&gt;cfs_enable_2
op_amp
l_int|0x3000
)paren
id|write_cache
c_func
(paren
id|drive
comma
(paren
id|id-&gt;cfs_enable_2
op_amp
l_int|0x3000
)paren
)paren
suffix:semicolon
id|probe_lba_addressing
c_func
(paren
id|drive
comma
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|idedisk_cleanup
r_static
r_int
id|idedisk_cleanup
c_func
(paren
r_struct
id|ata_device
op_star
id|drive
)paren
(brace
r_int
id|ret
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|drive
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|drive-&gt;id-&gt;cfs_enable_2
op_amp
l_int|0x3000
)paren
op_logical_and
id|drive-&gt;wcache
)paren
(brace
r_if
c_cond
(paren
id|flush_cache
c_func
(paren
id|drive
)paren
)paren
id|printk
(paren
id|KERN_INFO
l_string|&quot;%s: Write Cache FAILED Flushing!&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
)brace
id|ret
op_assign
id|ata_unregister_device
c_func
(paren
id|drive
)paren
suffix:semicolon
multiline_comment|/* FIXME: This is killing the kernel with BUG 185 at asm/spinlocks.h&n;&t; * horribly.  Check whatever we did REGISTER the device properly&n;&t; * in front?&n;&t; */
macro_line|#if 0
id|put_device
c_func
(paren
op_amp
id|drive-&gt;device
)paren
suffix:semicolon
macro_line|#endif
r_return
id|ret
suffix:semicolon
)brace
DECL|function|idedisk_ioctl
r_static
r_int
id|idedisk_ioctl
c_func
(paren
r_struct
id|ata_device
op_star
id|drive
comma
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|__fp
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_struct
id|hd_driveid
op_star
id|id
op_assign
id|drive-&gt;id
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|HDIO_GET_ADDRESS
suffix:colon
(brace
r_int
r_int
id|val
op_assign
id|drive-&gt;addressing
suffix:semicolon
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|val
comma
(paren
r_int
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|HDIO_SET_ADDRESS
suffix:colon
(brace
r_int
id|val
suffix:semicolon
r_if
c_cond
(paren
id|arg
template_param
l_int|2
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|ide_spin_wait_hwgroup
c_func
(paren
id|drive
)paren
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
id|val
op_assign
id|set_lba_addressing
c_func
(paren
id|drive
comma
id|arg
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
id|drive-&gt;channel-&gt;lock
)paren
suffix:semicolon
r_return
id|val
suffix:semicolon
)brace
r_case
id|HDIO_GET_MULTCOUNT
suffix:colon
(brace
r_int
r_int
id|val
op_assign
id|drive-&gt;mult_count
op_amp
l_int|0xFF
suffix:semicolon
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|val
comma
(paren
r_int
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|HDIO_SET_MULTCOUNT
suffix:colon
(brace
r_int
id|val
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|id
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
r_if
c_cond
(paren
id|arg
template_param
(paren
id|id
ques
c_cond
id|id-&gt;max_multsect
suffix:colon
l_int|0
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|val
op_assign
id|set_multcount
c_func
(paren
id|drive
comma
id|arg
)paren
suffix:semicolon
r_return
id|val
suffix:semicolon
)brace
r_case
id|HDIO_GET_NOWERR
suffix:colon
(brace
r_int
r_int
id|val
op_assign
id|drive-&gt;nowerr
suffix:semicolon
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|val
comma
(paren
r_int
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|HDIO_SET_NOWERR
suffix:colon
(brace
r_int
id|val
suffix:semicolon
r_if
c_cond
(paren
id|arg
template_param
l_int|1
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|val
op_assign
id|set_nowerr
c_func
(paren
id|drive
comma
id|arg
)paren
suffix:semicolon
r_return
id|val
suffix:semicolon
)brace
r_case
id|HDIO_GET_WCACHE
suffix:colon
(brace
r_int
r_int
id|val
op_assign
id|drive-&gt;wcache
suffix:semicolon
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|val
comma
(paren
r_int
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|HDIO_SET_WCACHE
suffix:colon
(brace
r_int
id|val
suffix:semicolon
r_if
c_cond
(paren
id|arg
template_param
l_int|1
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|val
op_assign
id|write_cache
c_func
(paren
id|drive
comma
id|arg
)paren
suffix:semicolon
r_return
id|val
suffix:semicolon
)brace
r_case
id|HDIO_GET_ACOUSTIC
suffix:colon
(brace
r_int
r_int
id|val
op_assign
id|drive-&gt;acoustic
suffix:semicolon
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|val
comma
(paren
id|u8
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|HDIO_SET_ACOUSTIC
suffix:colon
(brace
r_int
id|val
suffix:semicolon
r_if
c_cond
(paren
id|arg
template_param
l_int|254
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|val
op_assign
id|set_acoustic
c_func
(paren
id|drive
comma
id|arg
)paren
suffix:semicolon
r_return
id|val
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_BLK_DEV_IDE_TCQ
r_case
id|HDIO_GET_QDMA
suffix:colon
(brace
multiline_comment|/* Foolup hdparm 0 means off 1 on -alat */
multiline_comment|/* FIXME: hdparm have only -Q do we need something like:&n;&t;&t;&t; * hdparm -q 1/0 - TCQ on/off&n;&t;&t;&t; * hdparm -Q 1-MAX - TCQ queue_depth ?&n;&t;&t;&t; */
id|u8
id|val
op_assign
(paren
id|drive-&gt;using_tcq
ques
c_cond
id|drive-&gt;queue_depth
suffix:colon
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|val
comma
(paren
id|u8
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|HDIO_SET_QDMA
suffix:colon
(brace
r_int
id|val
suffix:semicolon
r_if
c_cond
(paren
id|arg
template_param
id|IDE_MAX_TAG
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|ide_spin_wait_hwgroup
c_func
(paren
id|drive
)paren
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
id|val
op_assign
id|set_using_tcq
c_func
(paren
id|drive
comma
id|arg
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
id|drive-&gt;channel-&gt;lock
)paren
suffix:semicolon
r_return
id|val
suffix:semicolon
)brace
macro_line|#endif
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
r_static
r_void
id|idedisk_attach
c_func
(paren
r_struct
id|ata_device
op_star
id|drive
)paren
suffix:semicolon
multiline_comment|/*&n; * Subdriver functions.&n; */
DECL|variable|idedisk_driver
r_static
r_struct
id|ata_operations
id|idedisk_driver
op_assign
(brace
dot
id|owner
op_assign
id|THIS_MODULE
comma
dot
id|attach
op_assign
id|idedisk_attach
comma
dot
id|cleanup
op_assign
id|idedisk_cleanup
comma
dot
id|standby
op_assign
id|idedisk_standby
comma
dot
id|do_request
op_assign
id|idedisk_do_request
comma
dot
id|end_request
op_assign
l_int|NULL
comma
dot
id|ioctl
op_assign
id|idedisk_ioctl
comma
dot
id|open
op_assign
id|idedisk_open
comma
dot
id|release
op_assign
id|idedisk_release
comma
dot
id|check_media_change
op_assign
id|idedisk_check_media_change
comma
dot
id|revalidate
op_assign
l_int|NULL
comma
multiline_comment|/* use default method */
dot
id|capacity
op_assign
id|idedisk_capacity
comma
)brace
suffix:semicolon
DECL|function|idedisk_attach
r_static
r_void
id|idedisk_attach
c_func
(paren
r_struct
id|ata_device
op_star
id|drive
)paren
(brace
r_char
op_star
id|req
suffix:semicolon
r_struct
id|ata_channel
op_star
id|channel
suffix:semicolon
r_struct
id|gendisk
op_star
id|disk
suffix:semicolon
r_int
id|unit
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;type
op_ne
id|ATA_DISK
)paren
r_return
suffix:semicolon
id|req
op_assign
id|drive-&gt;driver_req
suffix:semicolon
r_if
c_cond
(paren
id|req
(braket
l_int|0
)braket
op_ne
l_char|&squot;&bslash;0&squot;
op_logical_and
id|strcmp
c_func
(paren
id|req
comma
l_string|&quot;ide-disk&quot;
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|ata_register_device
c_func
(paren
id|drive
comma
op_amp
id|idedisk_driver
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: Failed to register the driver with ide.c&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|idedisk_setup
c_func
(paren
id|drive
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
op_logical_neg
id|drive-&gt;head
op_logical_or
id|drive-&gt;head
OG
l_int|16
)paren
op_logical_and
op_logical_neg
id|drive-&gt;select.b.lba
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: INVALID GEOMETRY: %d PHYSICAL HEADS?&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|drive-&gt;head
)paren
suffix:semicolon
id|idedisk_cleanup
c_func
(paren
id|drive
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|channel
op_assign
id|drive-&gt;channel
suffix:semicolon
id|unit
op_assign
id|drive
op_minus
id|channel-&gt;drives
suffix:semicolon
id|disk
op_assign
id|channel-&gt;gd
(braket
id|unit
)braket
suffix:semicolon
id|disk-&gt;minor_shift
op_assign
id|PARTN_BITS
suffix:semicolon
id|register_disk
c_func
(paren
id|disk
comma
id|mk_kdev
c_func
(paren
id|disk-&gt;major
comma
id|disk-&gt;first_minor
)paren
comma
l_int|1
op_lshift
id|disk-&gt;minor_shift
comma
id|disk-&gt;fops
comma
id|drive-&gt;capacity
)paren
suffix:semicolon
)brace
DECL|function|idedisk_exit
r_static
r_void
id|__exit
id|idedisk_exit
c_func
(paren
r_void
)paren
(brace
id|unregister_ata_driver
c_func
(paren
op_amp
id|idedisk_driver
)paren
suffix:semicolon
)brace
DECL|function|idedisk_init
r_int
id|__init
id|idedisk_init
c_func
(paren
r_void
)paren
(brace
r_return
id|ata_driver_module
c_func
(paren
op_amp
id|idedisk_driver
)paren
suffix:semicolon
)brace
DECL|variable|idedisk_init
id|module_init
c_func
(paren
id|idedisk_init
)paren
suffix:semicolon
DECL|variable|idedisk_exit
id|module_exit
c_func
(paren
id|idedisk_exit
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;ATA DISK Driver&quot;
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
eof
