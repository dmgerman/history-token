multiline_comment|/*&n; *  linux/drivers/ide/setup-pci.c&t;&t;Version 1.10&t;2002/08/19&n; *&n; *  Copyright (c) 1998-2000  Andre Hedrick &lt;andre@linux-ide.org&gt;&n; *&n; *  Copyright (c) 1995-1998  Mark Lord&n; *  May be copied or modified under the terms of the GNU General Public License&n; *&n; *  Recent Changes&n; *&t;Split the set up function into multiple functions&n; *&t;Use pci_set_master&n; *&t;Fix misreporting of I/O v MMIO problems&n; *&t;Initial fixups for simplex devices&n; */
multiline_comment|/*&n; *  This module provides support for automatic detection and&n; *  configuration of all PCI IDE interfaces present in a system.  &n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/ide.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
multiline_comment|/**&n; *&t;ide_match_hwif&t;-&t;match a PCI IDE against an ide_hwif&n; *&t;@io_base: I/O base of device&n; *&t;@bootable: set if its bootable&n; *&t;@name: name of device&n; *&n; *&t;Match a PCI IDE port against an entry in ide_hwifs[],&n; *&t;based on io_base port if possible. Return the matching hwif,&n; *&t;or a new hwif. If we find an error (clashing, out of devices, etc)&n; *&t;return NULL&n; *&n; *&t;FIXME: we need to handle mmio matches here too&n; */
DECL|function|ide_match_hwif
r_static
id|ide_hwif_t
op_star
id|ide_match_hwif
c_func
(paren
r_int
r_int
id|io_base
comma
id|u8
id|bootable
comma
r_const
r_char
op_star
id|name
)paren
(brace
r_int
id|h
suffix:semicolon
id|ide_hwif_t
op_star
id|hwif
suffix:semicolon
multiline_comment|/*&n;&t; * Look for a hwif with matching io_base specified using&n;&t; * parameters to ide_setup().&n;&t; */
r_for
c_loop
(paren
id|h
op_assign
l_int|0
suffix:semicolon
id|h
OL
id|MAX_HWIFS
suffix:semicolon
op_increment
id|h
)paren
(brace
id|hwif
op_assign
op_amp
id|ide_hwifs
(braket
id|h
)braket
suffix:semicolon
r_if
c_cond
(paren
id|hwif-&gt;io_ports
(braket
id|IDE_DATA_OFFSET
)braket
op_eq
id|io_base
)paren
(brace
r_if
c_cond
(paren
id|hwif-&gt;chipset
op_eq
id|ide_forced
)paren
r_return
id|hwif
suffix:semicolon
multiline_comment|/* a perfect match */
)brace
)brace
multiline_comment|/*&n;&t; * Look for a hwif with matching io_base default value.&n;&t; * If chipset is &quot;ide_unknown&quot;, then claim that hwif slot.&n;&t; * Otherwise, some other chipset has already claimed it..  :(&n;&t; */
r_for
c_loop
(paren
id|h
op_assign
l_int|0
suffix:semicolon
id|h
OL
id|MAX_HWIFS
suffix:semicolon
op_increment
id|h
)paren
(brace
id|hwif
op_assign
op_amp
id|ide_hwifs
(braket
id|h
)braket
suffix:semicolon
r_if
c_cond
(paren
id|hwif-&gt;io_ports
(braket
id|IDE_DATA_OFFSET
)braket
op_eq
id|io_base
)paren
(brace
r_if
c_cond
(paren
id|hwif-&gt;chipset
op_eq
id|ide_unknown
)paren
r_return
id|hwif
suffix:semicolon
multiline_comment|/* match */
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: port 0x%04lx already claimed by %s&bslash;n&quot;
comma
id|name
comma
id|io_base
comma
id|hwif-&gt;name
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/* already claimed */
)brace
)brace
multiline_comment|/*&n;&t; * Okay, there is no hwif matching our io_base,&n;&t; * so we&squot;ll just claim an unassigned slot.&n;&t; * Give preference to claiming other slots before claiming ide0/ide1,&n;&t; * just in case there&squot;s another interface yet-to-be-scanned&n;&t; * which uses ports 1f0/170 (the ide0/ide1 defaults).&n;&t; *&n;&t; * Unless there is a bootable card that does not use the standard&n;&t; * ports 1f0/170 (the ide0/ide1 defaults). The (bootable) flag.&n;&t; */
r_if
c_cond
(paren
id|bootable
)paren
(brace
r_for
c_loop
(paren
id|h
op_assign
l_int|0
suffix:semicolon
id|h
OL
id|MAX_HWIFS
suffix:semicolon
op_increment
id|h
)paren
(brace
id|hwif
op_assign
op_amp
id|ide_hwifs
(braket
id|h
)braket
suffix:semicolon
r_if
c_cond
(paren
id|hwif-&gt;chipset
op_eq
id|ide_unknown
)paren
r_return
id|hwif
suffix:semicolon
multiline_comment|/* pick an unused entry */
)brace
)brace
r_else
(brace
r_for
c_loop
(paren
id|h
op_assign
l_int|2
suffix:semicolon
id|h
OL
id|MAX_HWIFS
suffix:semicolon
op_increment
id|h
)paren
(brace
id|hwif
op_assign
id|ide_hwifs
op_plus
id|h
suffix:semicolon
r_if
c_cond
(paren
id|hwif-&gt;chipset
op_eq
id|ide_unknown
)paren
r_return
id|hwif
suffix:semicolon
multiline_comment|/* pick an unused entry */
)brace
)brace
r_for
c_loop
(paren
id|h
op_assign
l_int|0
suffix:semicolon
id|h
OL
l_int|2
suffix:semicolon
op_increment
id|h
)paren
(brace
id|hwif
op_assign
id|ide_hwifs
op_plus
id|h
suffix:semicolon
r_if
c_cond
(paren
id|hwif-&gt;chipset
op_eq
id|ide_unknown
)paren
r_return
id|hwif
suffix:semicolon
multiline_comment|/* pick an unused entry */
)brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: too many IDE interfaces, no room in table&bslash;n&quot;
comma
id|name
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;ide_setup_pci_baseregs&t;-&t;place a PCI IDE controller native&n; *&t;@dev: PCI device of interface to switch native&n; *&t;@name: Name of interface&n; *&n; *&t;We attempt to place the PCI interface into PCI native mode. If&n; *&t;we succeed the BARs are ok and the controller is in PCI mode.&n; *&t;Returns 0 on success or an errno code. &n; *&n; *&t;FIXME: if we program the interface and then fail to set the BARS&n; *&t;we don&squot;t switch it back to legacy mode. Do we actually care ??&n; */
DECL|function|ide_setup_pci_baseregs
r_static
r_int
id|ide_setup_pci_baseregs
(paren
r_struct
id|pci_dev
op_star
id|dev
comma
r_const
r_char
op_star
id|name
)paren
(brace
id|u8
id|progif
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Place both IDE interfaces into PCI &quot;native&quot; mode:&n;&t; */
r_if
c_cond
(paren
id|pci_read_config_byte
c_func
(paren
id|dev
comma
id|PCI_CLASS_PROG
comma
op_amp
id|progif
)paren
op_logical_or
(paren
id|progif
op_amp
l_int|5
)paren
op_ne
l_int|5
)paren
(brace
r_if
c_cond
(paren
(paren
id|progif
op_amp
l_int|0xa
)paren
op_ne
l_int|0xa
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: device not capable of full &quot;
l_string|&quot;native PCI mode&bslash;n&quot;
comma
id|name
)paren
suffix:semicolon
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;%s: placing both ports into native PCI mode&bslash;n&quot;
comma
id|name
)paren
suffix:semicolon
(paren
r_void
)paren
id|pci_write_config_byte
c_func
(paren
id|dev
comma
id|PCI_CLASS_PROG
comma
id|progif
op_or
l_int|5
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pci_read_config_byte
c_func
(paren
id|dev
comma
id|PCI_CLASS_PROG
comma
op_amp
id|progif
)paren
op_logical_or
(paren
id|progif
op_amp
l_int|5
)paren
op_ne
l_int|5
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: rewrite of PROGIF failed, wanted &quot;
l_string|&quot;0x%04x, got 0x%04x&bslash;n&quot;
comma
id|name
comma
id|progif
op_or
l_int|5
comma
id|progif
)paren
suffix:semicolon
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_BLK_DEV_IDEDMA_PCI
macro_line|#ifdef CONFIG_BLK_DEV_IDEDMA_FORCED
multiline_comment|/*&n; * Long lost data from 2.0.34 that is now in 2.0.39&n; *&n; * This was used in ./drivers/block/triton.c to do DMA Base address setup&n; * when PnP failed.  Oh the things we forget.  I believe this was part&n; * of SFF-8038i that has been withdrawn from public access... :-((&n; */
DECL|macro|DEFAULT_BMIBA
mdefine_line|#define DEFAULT_BMIBA&t;0xe800&t;/* in case BIOS did not init it */
DECL|macro|DEFAULT_BMCRBA
mdefine_line|#define DEFAULT_BMCRBA&t;0xcc00&t;/* VIA&squot;s default value */
DECL|macro|DEFAULT_BMALIBA
mdefine_line|#define DEFAULT_BMALIBA&t;0xd400&t;/* ALI&squot;s default value */
macro_line|#endif /* CONFIG_BLK_DEV_IDEDMA_FORCED */
multiline_comment|/**&n; *&t;ide_get_or_set_dma_base&t;&t;-&t;setup BMIBA&n; *&t;@hwif: Interface&n; *&n; *&t;Fetch the DMA Bus-Master-I/O-Base-Address (BMIBA) from PCI space:&n; *&t;If need be we set up the DMA base. Where a device has a partner that&n; *&t;is already in DMA mode we check and enforce IDE simplex rules.&n; */
DECL|function|ide_get_or_set_dma_base
r_static
r_int
r_int
id|ide_get_or_set_dma_base
(paren
id|ide_hwif_t
op_star
id|hwif
)paren
(brace
r_int
r_int
id|dma_base
op_assign
l_int|0
suffix:semicolon
r_struct
id|pci_dev
op_star
id|dev
op_assign
id|hwif-&gt;pci_dev
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_IDEDMA_FORCED
r_int
id|second_chance
op_assign
l_int|0
suffix:semicolon
id|second_chance_to_dma
suffix:colon
macro_line|#endif /* CONFIG_BLK_DEV_IDEDMA_FORCED */
r_if
c_cond
(paren
id|hwif-&gt;mmio
)paren
r_return
id|hwif-&gt;dma_base
suffix:semicolon
r_if
c_cond
(paren
id|hwif-&gt;mate
op_logical_and
id|hwif-&gt;mate-&gt;dma_base
)paren
(brace
id|dma_base
op_assign
id|hwif-&gt;mate-&gt;dma_base
op_minus
(paren
id|hwif-&gt;channel
ques
c_cond
l_int|0
suffix:colon
l_int|8
)paren
suffix:semicolon
)brace
r_else
(brace
id|dma_base
op_assign
id|pci_resource_start
c_func
(paren
id|dev
comma
l_int|4
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dma_base
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: dma_base is invalid&bslash;n&quot;
comma
id|hwif-&gt;cds-&gt;name
)paren
suffix:semicolon
)brace
)brace
macro_line|#ifdef CONFIG_BLK_DEV_IDEDMA_FORCED
multiline_comment|/* FIXME - should use pci_assign_resource surely */
r_if
c_cond
(paren
(paren
op_logical_neg
id|dma_base
)paren
op_logical_and
(paren
op_logical_neg
id|second_chance
)paren
)paren
(brace
r_int
r_int
id|set_bmiba
op_assign
l_int|0
suffix:semicolon
id|second_chance
op_increment
suffix:semicolon
r_switch
c_cond
(paren
id|dev-&gt;vendor
)paren
(brace
r_case
id|PCI_VENDOR_ID_AL
suffix:colon
id|set_bmiba
op_assign
id|DEFAULT_BMALIBA
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PCI_VENDOR_ID_VIA
suffix:colon
id|set_bmiba
op_assign
id|DEFAULT_BMCRBA
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PCI_VENDOR_ID_INTEL
suffix:colon
id|set_bmiba
op_assign
id|DEFAULT_BMIBA
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
id|dma_base
suffix:semicolon
)brace
id|pci_write_config_dword
c_func
(paren
id|dev
comma
l_int|0x20
comma
id|set_bmiba
op_or
l_int|1
)paren
suffix:semicolon
r_goto
id|second_chance_to_dma
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_BLK_DEV_IDEDMA_FORCED */
r_if
c_cond
(paren
id|dma_base
)paren
(brace
id|u8
id|simplex_stat
op_assign
l_int|0
suffix:semicolon
id|dma_base
op_add_assign
id|hwif-&gt;channel
ques
c_cond
l_int|8
suffix:colon
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|dev-&gt;device
)paren
(brace
r_case
id|PCI_DEVICE_ID_AL_M5219
suffix:colon
r_case
id|PCI_DEVICE_ID_AL_M5229
suffix:colon
r_case
id|PCI_DEVICE_ID_AMD_VIPER_7409
suffix:colon
r_case
id|PCI_DEVICE_ID_CMD_643
suffix:colon
r_case
id|PCI_DEVICE_ID_SERVERWORKS_CSB5IDE
suffix:colon
id|simplex_stat
op_assign
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|dma_base
op_plus
l_int|2
)paren
suffix:semicolon
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
(paren
id|simplex_stat
op_amp
l_int|0x60
)paren
comma
(paren
id|dma_base
op_plus
l_int|2
)paren
)paren
suffix:semicolon
id|simplex_stat
op_assign
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|dma_base
op_plus
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|simplex_stat
op_amp
l_int|0x80
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: simplex device: &quot;
l_string|&quot;DMA forced&bslash;n&quot;
comma
id|hwif-&gt;cds-&gt;name
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/*&n;&t;&t;&t;&t; * If the device claims &quot;simplex&quot; DMA,&n;&t;&t;&t;&t; * this means only one of the two interfaces&n;&t;&t;&t;&t; * can be trusted with DMA at any point in time.&n;&t;&t;&t;&t; * So we should enable DMA only on one of the&n;&t;&t;&t;&t; * two interfaces.&n;&t;&t;&t;&t; */
id|simplex_stat
op_assign
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|dma_base
op_plus
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|simplex_stat
op_amp
l_int|0x80
)paren
(brace
multiline_comment|/* simplex device? */
multiline_comment|/*&n; *&t;At this point we haven&squot;t probed the drives so we can&squot;t make the&n; *&t;appropriate decision. Really we should defer this problem&n; *&t;until we tune the drive then try to grab DMA ownership if we want&n; *&t;to be the DMA end. This has to be become dynamic to handle hot&n; *&t;plug.&n; */
r_if
c_cond
(paren
id|hwif-&gt;mate
op_logical_and
id|hwif-&gt;mate-&gt;dma_base
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: simplex device: &quot;
l_string|&quot;DMA disabled&bslash;n&quot;
comma
id|hwif-&gt;cds-&gt;name
)paren
suffix:semicolon
id|dma_base
op_assign
l_int|0
suffix:semicolon
)brace
)brace
)brace
)brace
r_return
id|dma_base
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_BLK_DEV_IDEDMA_PCI */
DECL|function|ide_setup_pci_noise
r_void
id|ide_setup_pci_noise
(paren
r_struct
id|pci_dev
op_star
id|dev
comma
id|ide_pci_device_t
op_star
id|d
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: IDE controller at PCI slot %s&bslash;n&quot;
comma
id|d-&gt;name
comma
id|pci_name
c_func
(paren
id|dev
)paren
)paren
suffix:semicolon
)brace
DECL|variable|ide_setup_pci_noise
id|EXPORT_SYMBOL_GPL
c_func
(paren
id|ide_setup_pci_noise
)paren
suffix:semicolon
multiline_comment|/**&n; *&t;ide_pci_enable&t;-&t;do PCI enables&n; *&t;@dev: PCI device&n; *&t;@d: IDE pci device data&n; *&n; *&t;Enable the IDE PCI device. We attempt to enable the device in full&n; *&t;but if that fails then we only need BAR4 so we will enable that.&n; *&t;&n; *&t;Returns zero on success or an error code&n; */
DECL|function|ide_pci_enable
r_static
r_int
id|ide_pci_enable
c_func
(paren
r_struct
id|pci_dev
op_star
id|dev
comma
id|ide_pci_device_t
op_star
id|d
)paren
(brace
r_if
c_cond
(paren
id|pci_enable_device
c_func
(paren
id|dev
)paren
)paren
(brace
r_if
c_cond
(paren
id|pci_enable_device_bars
c_func
(paren
id|dev
comma
l_int|1
op_lshift
l_int|4
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: (ide_setup_pci_device:) &quot;
l_string|&quot;Could not enable device.&bslash;n&quot;
comma
id|d-&gt;name
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: BIOS configuration fixed.&bslash;n&quot;
comma
id|d-&gt;name
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * assume all devices can do 32-bit dma for now. we can add a&n;&t; * dma mask field to the ide_pci_device_t if we need it (or let&n;&t; * lower level driver set the dma mask)&n;&t; */
r_if
c_cond
(paren
id|pci_set_dma_mask
c_func
(paren
id|dev
comma
l_int|0xffffffff
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: can&squot;t set dma mask&bslash;n&quot;
comma
id|d-&gt;name
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
multiline_comment|/* FIXME: Temporary - until we put in the hotplug interface logic&n;&t;   Check that the bits we want are not in use by someone else */
r_if
c_cond
(paren
id|pci_request_region
c_func
(paren
id|dev
comma
l_int|4
comma
l_string|&quot;ide_tmp&quot;
)paren
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
id|pci_release_region
c_func
(paren
id|dev
comma
l_int|4
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;ide_pci_configure&t;-&t;configure an unconfigured device&n; *&t;@dev: PCI device&n; *&t;@d: IDE pci device data&n; *&n; *&t;Enable and configure the PCI device we have been passed.&n; *&t;Returns zero on success or an error code.&n; */
DECL|function|ide_pci_configure
r_static
r_int
id|ide_pci_configure
c_func
(paren
r_struct
id|pci_dev
op_star
id|dev
comma
id|ide_pci_device_t
op_star
id|d
)paren
(brace
id|u16
id|pcicmd
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * PnP BIOS was *supposed* to have setup this device, but we&n;&t; * can do it ourselves, so long as the BIOS has assigned an IRQ&n;&t; * (or possibly the device is using a &quot;legacy header&quot; for IRQs).&n;&t; * Maybe the user deliberately *disabled* the device,&n;&t; * but we&squot;ll eventually ignore it again if no drives respond.&n;&t; */
r_if
c_cond
(paren
id|ide_setup_pci_baseregs
c_func
(paren
id|dev
comma
id|d-&gt;name
)paren
op_logical_or
id|pci_write_config_word
c_func
(paren
id|dev
comma
id|PCI_COMMAND
comma
id|pcicmd
op_or
id|PCI_COMMAND_IO
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: device disabled (BIOS)&bslash;n&quot;
comma
id|d-&gt;name
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pci_read_config_word
c_func
(paren
id|dev
comma
id|PCI_COMMAND
comma
op_amp
id|pcicmd
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: error accessing PCI regs&bslash;n&quot;
comma
id|d-&gt;name
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|pcicmd
op_amp
id|PCI_COMMAND_IO
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: unable to enable IDE controller&bslash;n&quot;
comma
id|d-&gt;name
)paren
suffix:semicolon
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;ide_pci_check_iomem&t;-&t;check a register is I/O&n; *&t;@dev: pci device&n; *&t;@d: ide_pci_device&n; *&t;@bar: bar number&n; *&n; *&t;Checks if a BAR is configured and points to MMIO space. If so&n; *&t;print an error and return an error code. Otherwise return 0&n; */
DECL|function|ide_pci_check_iomem
r_static
r_int
id|ide_pci_check_iomem
c_func
(paren
r_struct
id|pci_dev
op_star
id|dev
comma
id|ide_pci_device_t
op_star
id|d
comma
r_int
id|bar
)paren
(brace
id|ulong
id|flags
op_assign
id|pci_resource_flags
c_func
(paren
id|dev
comma
id|bar
)paren
suffix:semicolon
multiline_comment|/* Unconfigured ? */
r_if
c_cond
(paren
op_logical_neg
id|flags
op_logical_or
id|pci_resource_len
c_func
(paren
id|dev
comma
id|bar
)paren
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* I/O space */
r_if
c_cond
(paren
id|flags
op_amp
id|PCI_BASE_ADDRESS_IO_MASK
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Bad */
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: IO baseregs (BIOS) are reported &quot;
l_string|&quot;as MEM, report to &quot;
l_string|&quot;&lt;andre@linux-ide.org&gt;.&bslash;n&quot;
comma
id|d-&gt;name
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;ide_hwif_configure&t;-&t;configure an IDE interface&n; *&t;@dev: PCI device holding interface&n; *&t;@d: IDE pci data&n; *&t;@mate: Paired interface if any&n; *&n; *&t;Perform the initial set up for the hardware interface structure. This&n; *&t;is done per interface port rather than per PCI device. There may be&n; *&t;more than one port per device.&n; *&n; *&t;Returns the new hardware interface structure, or NULL on a failure&n; */
DECL|function|ide_hwif_configure
r_static
id|ide_hwif_t
op_star
id|ide_hwif_configure
c_func
(paren
r_struct
id|pci_dev
op_star
id|dev
comma
id|ide_pci_device_t
op_star
id|d
comma
id|ide_hwif_t
op_star
id|mate
comma
r_int
id|port
comma
r_int
id|irq
)paren
(brace
r_int
r_int
id|ctl
op_assign
l_int|0
comma
id|base
op_assign
l_int|0
suffix:semicolon
id|ide_hwif_t
op_star
id|hwif
suffix:semicolon
r_if
c_cond
(paren
(paren
id|d-&gt;flags
op_amp
id|IDEPCI_FLAG_ISA_PORTS
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/*  Possibly we should fail if these checks report true */
id|ide_pci_check_iomem
c_func
(paren
id|dev
comma
id|d
comma
l_int|2
op_star
id|port
)paren
suffix:semicolon
id|ide_pci_check_iomem
c_func
(paren
id|dev
comma
id|d
comma
l_int|2
op_star
id|port
op_plus
l_int|1
)paren
suffix:semicolon
id|ctl
op_assign
id|pci_resource_start
c_func
(paren
id|dev
comma
l_int|2
op_star
id|port
op_plus
l_int|1
)paren
suffix:semicolon
id|base
op_assign
id|pci_resource_start
c_func
(paren
id|dev
comma
l_int|2
op_star
id|port
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ctl
op_logical_and
op_logical_neg
id|base
)paren
op_logical_or
(paren
id|base
op_logical_and
op_logical_neg
id|ctl
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: inconsistent baseregs (BIOS) &quot;
l_string|&quot;for port %d, skipping&bslash;n&quot;
comma
id|d-&gt;name
comma
id|port
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|ctl
)paren
(brace
multiline_comment|/* Use default values */
id|ctl
op_assign
id|port
ques
c_cond
l_int|0x374
suffix:colon
l_int|0x3f4
suffix:semicolon
id|base
op_assign
id|port
ques
c_cond
l_int|0x170
suffix:colon
l_int|0x1f0
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|hwif
op_assign
id|ide_match_hwif
c_func
(paren
id|base
comma
id|d-&gt;bootable
comma
id|d-&gt;name
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/* no room in ide_hwifs[] */
r_if
c_cond
(paren
id|hwif-&gt;io_ports
(braket
id|IDE_DATA_OFFSET
)braket
op_ne
id|base
op_logical_or
id|hwif-&gt;io_ports
(braket
id|IDE_CONTROL_OFFSET
)braket
op_ne
(paren
id|ctl
op_or
l_int|2
)paren
)paren
(brace
id|memset
c_func
(paren
op_amp
id|hwif-&gt;hw
comma
l_int|0
comma
r_sizeof
(paren
id|hwif-&gt;hw
)paren
)paren
suffix:semicolon
id|ide_init_hwif_ports
c_func
(paren
op_amp
id|hwif-&gt;hw
comma
id|base
comma
(paren
id|ctl
op_or
l_int|2
)paren
comma
l_int|NULL
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|hwif-&gt;io_ports
comma
id|hwif-&gt;hw.io_ports
comma
r_sizeof
(paren
id|hwif-&gt;io_ports
)paren
)paren
suffix:semicolon
id|hwif-&gt;noprobe
op_assign
op_logical_neg
id|hwif-&gt;io_ports
(braket
id|IDE_DATA_OFFSET
)braket
suffix:semicolon
)brace
id|hwif-&gt;chipset
op_assign
id|ide_pci
suffix:semicolon
id|hwif-&gt;pci_dev
op_assign
id|dev
suffix:semicolon
id|hwif-&gt;cds
op_assign
(paren
r_struct
id|ide_pci_device_s
op_star
)paren
id|d
suffix:semicolon
id|hwif-&gt;channel
op_assign
id|port
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hwif-&gt;irq
)paren
id|hwif-&gt;irq
op_assign
id|irq
suffix:semicolon
r_if
c_cond
(paren
id|mate
)paren
(brace
id|hwif-&gt;mate
op_assign
id|mate
suffix:semicolon
id|mate-&gt;mate
op_assign
id|hwif
suffix:semicolon
)brace
r_return
id|hwif
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;ide_hwif_setup_dma&t;-&t;configure DMA interface&n; *&t;@dev: PCI device&n; *&t;@d: IDE pci data&n; *&t;@hwif: Hardware interface we are configuring&n; *&n; *&t;Set up the DMA base for the interface. Enable the master bits as&n; *&t;necessary and attempt to bring the device DMA into a ready to use&n; *&t;state&n; */
macro_line|#ifndef CONFIG_BLK_DEV_IDEDMA_PCI
DECL|function|ide_hwif_setup_dma
r_static
r_void
id|ide_hwif_setup_dma
c_func
(paren
r_struct
id|pci_dev
op_star
id|dev
comma
id|ide_pci_device_t
op_star
id|d
comma
id|ide_hwif_t
op_star
id|hwif
)paren
(brace
)brace
macro_line|#else
DECL|function|ide_hwif_setup_dma
r_static
r_void
id|ide_hwif_setup_dma
c_func
(paren
r_struct
id|pci_dev
op_star
id|dev
comma
id|ide_pci_device_t
op_star
id|d
comma
id|ide_hwif_t
op_star
id|hwif
)paren
(brace
id|u16
id|pcicmd
suffix:semicolon
id|pci_read_config_word
c_func
(paren
id|dev
comma
id|PCI_COMMAND
comma
op_amp
id|pcicmd
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|d-&gt;autodma
op_eq
id|AUTODMA
)paren
op_logical_or
(paren
(paren
id|dev
op_member_access_from_pointer
r_class
op_rshift
l_int|8
)paren
op_eq
id|PCI_CLASS_STORAGE_IDE
op_logical_and
(paren
id|dev
op_member_access_from_pointer
r_class
op_amp
l_int|0x80
)paren
)paren
)paren
(brace
r_int
r_int
id|dma_base
op_assign
id|ide_get_or_set_dma_base
c_func
(paren
id|hwif
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dma_base
op_logical_and
op_logical_neg
(paren
id|pcicmd
op_amp
id|PCI_COMMAND_MASTER
)paren
)paren
(brace
multiline_comment|/*&n; &t;&t;&t; * Set up BM-DMA capability&n;&t;&t;&t; * (PnP BIOS should have done this)&n; &t;&t;&t; */
multiline_comment|/* default DMA off if we had to configure it here */
id|hwif-&gt;autodma
op_assign
l_int|0
suffix:semicolon
id|pci_set_master
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pci_read_config_word
c_func
(paren
id|dev
comma
id|PCI_COMMAND
comma
op_amp
id|pcicmd
)paren
op_logical_or
op_logical_neg
(paren
id|pcicmd
op_amp
id|PCI_COMMAND_MASTER
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: %s error updating PCICMD&bslash;n&quot;
comma
id|hwif-&gt;name
comma
id|d-&gt;name
)paren
suffix:semicolon
id|dma_base
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|dma_base
)paren
(brace
r_if
c_cond
(paren
id|d-&gt;init_dma
)paren
(brace
id|d
op_member_access_from_pointer
id|init_dma
c_func
(paren
id|hwif
comma
id|dma_base
)paren
suffix:semicolon
)brace
r_else
(brace
id|ide_setup_dma
c_func
(paren
id|hwif
comma
id|dma_base
comma
l_int|8
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: %s Bus-Master DMA disabled &quot;
l_string|&quot;(BIOS)&bslash;n&quot;
comma
id|hwif-&gt;name
comma
id|d-&gt;name
)paren
suffix:semicolon
)brace
)brace
)brace
macro_line|#ifndef CONFIG_IDEDMA_PCI_AUTO
macro_line|#warning CONFIG_IDEDMA_PCI_AUTO=n support is obsolete, and will be removed soon.
macro_line|#endif
macro_line|#endif /* CONFIG_BLK_DEV_IDEDMA_PCI*/
multiline_comment|/**&n; *&t;ide_setup_pci_controller&t;-&t;set up IDE PCI&n; *&t;@dev: PCI device&n; *&t;@d: IDE PCI data&n; *&t;@noisy: verbose flag&n; *&t;@config: returned as 1 if we configured the hardware&n; *&n; *&t;Set up the PCI and controller side of the IDE interface. This brings&n; *&t;up the PCI side of the device, checks that the device is enabled&n; *&t;and enables it if need be&n; */
DECL|function|ide_setup_pci_controller
r_static
r_int
id|ide_setup_pci_controller
c_func
(paren
r_struct
id|pci_dev
op_star
id|dev
comma
id|ide_pci_device_t
op_star
id|d
comma
r_int
id|noisy
comma
r_int
op_star
id|config
)paren
(brace
id|u32
id|class_rev
suffix:semicolon
id|u16
id|pcicmd
suffix:semicolon
r_if
c_cond
(paren
id|noisy
)paren
id|ide_setup_pci_noise
c_func
(paren
id|dev
comma
id|d
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ide_pci_enable
c_func
(paren
id|dev
comma
id|d
)paren
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
r_if
c_cond
(paren
id|pci_read_config_word
c_func
(paren
id|dev
comma
id|PCI_COMMAND
comma
op_amp
id|pcicmd
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: error accessing PCI regs&bslash;n&quot;
comma
id|d-&gt;name
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|pcicmd
op_amp
id|PCI_COMMAND_IO
)paren
)paren
(brace
multiline_comment|/* is device disabled? */
r_if
c_cond
(paren
id|ide_pci_configure
c_func
(paren
id|dev
comma
id|d
)paren
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
op_star
id|config
op_assign
l_int|1
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: device enabled (Linux)&bslash;n&quot;
comma
id|d-&gt;name
)paren
suffix:semicolon
)brace
id|pci_read_config_dword
c_func
(paren
id|dev
comma
id|PCI_CLASS_REVISION
comma
op_amp
id|class_rev
)paren
suffix:semicolon
id|class_rev
op_and_assign
l_int|0xff
suffix:semicolon
r_if
c_cond
(paren
id|noisy
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: chipset revision %d&bslash;n&quot;
comma
id|d-&gt;name
comma
id|class_rev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ide_release_pci_controller
r_static
r_void
id|ide_release_pci_controller
c_func
(paren
r_struct
id|pci_dev
op_star
id|dev
comma
id|ide_pci_device_t
op_star
id|d
comma
r_int
id|noisy
)paren
(brace
multiline_comment|/* Balance ide_pci_enable() */
id|pci_disable_device
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;ide_pci_setup_ports&t;-&t;configure ports/devices on PCI IDE&n; *&t;@dev: PCI device&n; *&t;@d: IDE pci device info&n; *&t;@pciirq: IRQ line&n; *&t;@index: ata index to update&n; *&n; *&t;Scan the interfaces attached to this device and do any&n; *&t;necessary per port setup. Attach the devices and ask the&n; *&t;generic DMA layer to do its work for us.&n; *&n; *&t;Normally called automaticall from do_ide_pci_setup_device,&n; *&t;but is also used directly as a helper function by some controllers&n; *&t;where the chipset setup is not the default PCI IDE one.&n; */
DECL|function|ide_pci_setup_ports
r_void
id|ide_pci_setup_ports
c_func
(paren
r_struct
id|pci_dev
op_star
id|dev
comma
id|ide_pci_device_t
op_star
id|d
comma
r_int
id|pciirq
comma
id|ata_index_t
op_star
id|index
)paren
(brace
r_int
id|port
suffix:semicolon
r_int
id|at_least_one_hwif_enabled
op_assign
l_int|0
suffix:semicolon
id|ide_hwif_t
op_star
id|hwif
comma
op_star
id|mate
op_assign
l_int|NULL
suffix:semicolon
r_static
r_int
id|secondpdc
op_assign
l_int|0
suffix:semicolon
id|u8
id|tmp
suffix:semicolon
id|index-&gt;all
op_assign
l_int|0xf0f0
suffix:semicolon
multiline_comment|/*&n;&t; * Set up the IDE ports&n;&t; */
r_for
c_loop
(paren
id|port
op_assign
l_int|0
suffix:semicolon
id|port
op_le
l_int|1
suffix:semicolon
op_increment
id|port
)paren
(brace
id|ide_pci_enablebit_t
op_star
id|e
op_assign
op_amp
(paren
id|d-&gt;enablebits
(braket
id|port
)braket
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t; * If this is a Promise FakeRaid controller,&n;&t;&t; * the 2nd controller will be marked as &n;&t;&t; * disabled while it is actually there and enabled&n;&t;&t; * by the bios for raid purposes. &n;&t;&t; * Skip the normal &quot;is it enabled&quot; test for those.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|d-&gt;flags
op_amp
id|IDEPCI_FLAG_FORCE_PDC
)paren
op_logical_and
(paren
id|secondpdc
op_increment
op_eq
l_int|1
)paren
op_logical_and
(paren
id|port
op_eq
l_int|1
)paren
)paren
r_goto
id|controller_ok
suffix:semicolon
r_if
c_cond
(paren
id|e-&gt;reg
op_logical_and
(paren
id|pci_read_config_byte
c_func
(paren
id|dev
comma
id|e-&gt;reg
comma
op_amp
id|tmp
)paren
op_logical_or
(paren
id|tmp
op_amp
id|e-&gt;mask
)paren
op_ne
id|e-&gt;val
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/* port not enabled */
id|controller_ok
suffix:colon
r_if
c_cond
(paren
id|d-&gt;channels
op_le
id|port
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
(paren
id|hwif
op_assign
id|ide_hwif_configure
c_func
(paren
id|dev
comma
id|d
comma
id|mate
comma
id|port
comma
id|pciirq
)paren
)paren
op_eq
l_int|NULL
)paren
r_continue
suffix:semicolon
multiline_comment|/* setup proper ancestral information */
id|hwif-&gt;gendev.parent
op_assign
op_amp
id|dev-&gt;dev
suffix:semicolon
r_if
c_cond
(paren
id|hwif-&gt;channel
)paren
(brace
id|index-&gt;b.high
op_assign
id|hwif-&gt;index
suffix:semicolon
)brace
r_else
(brace
id|index-&gt;b.low
op_assign
id|hwif-&gt;index
suffix:semicolon
)brace
r_if
c_cond
(paren
id|d-&gt;init_iops
)paren
id|d
op_member_access_from_pointer
id|init_iops
c_func
(paren
id|hwif
)paren
suffix:semicolon
r_if
c_cond
(paren
id|d-&gt;autodma
op_eq
id|NODMA
)paren
r_goto
id|bypass_legacy_dma
suffix:semicolon
r_if
c_cond
(paren
id|d-&gt;init_setup_dma
)paren
(brace
id|d
op_member_access_from_pointer
id|init_setup_dma
c_func
(paren
id|dev
comma
id|d
comma
id|hwif
)paren
suffix:semicolon
)brace
r_else
id|ide_hwif_setup_dma
c_func
(paren
id|dev
comma
id|d
comma
id|hwif
)paren
suffix:semicolon
id|bypass_legacy_dma
suffix:colon
r_if
c_cond
(paren
id|d-&gt;init_hwif
)paren
multiline_comment|/* Call chipset-specific routine&n;&t;&t;&t; * for each enabled hwif&n;&t;&t;&t; */
id|d
op_member_access_from_pointer
id|init_hwif
c_func
(paren
id|hwif
)paren
suffix:semicolon
id|mate
op_assign
id|hwif
suffix:semicolon
id|at_least_one_hwif_enabled
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|at_least_one_hwif_enabled
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: neither IDE port enabled (BIOS)&bslash;n&quot;
comma
id|d-&gt;name
)paren
suffix:semicolon
)brace
DECL|variable|ide_pci_setup_ports
id|EXPORT_SYMBOL_GPL
c_func
(paren
id|ide_pci_setup_ports
)paren
suffix:semicolon
multiline_comment|/*&n; * ide_setup_pci_device() looks at the primary/secondary interfaces&n; * on a PCI IDE device and, if they are enabled, prepares the IDE driver&n; * for use with them.  This generic code works for most PCI chipsets.&n; *&n; * One thing that is not standardized is the location of the&n; * primary/secondary interface &quot;enable/disable&quot; bits.  For chipsets that&n; * we &quot;know&quot; about, this information is in the ide_pci_device_t struct;&n; * for all other chipsets, we just assume both interfaces are enabled.&n; */
DECL|function|do_ide_setup_pci_device
r_static
r_int
id|do_ide_setup_pci_device
c_func
(paren
r_struct
id|pci_dev
op_star
id|dev
comma
id|ide_pci_device_t
op_star
id|d
comma
id|ata_index_t
op_star
id|index
comma
id|u8
id|noisy
)paren
(brace
r_static
id|ata_index_t
id|ata_index
op_assign
(brace
dot
id|b
op_assign
(brace
dot
id|low
op_assign
l_int|0xff
comma
dot
id|high
op_assign
l_int|0xff
)brace
)brace
suffix:semicolon
r_int
id|tried_config
op_assign
l_int|0
suffix:semicolon
r_int
id|pciirq
comma
id|ret
suffix:semicolon
id|ret
op_assign
id|ide_setup_pci_controller
c_func
(paren
id|dev
comma
id|d
comma
id|noisy
comma
op_amp
id|tried_config
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/*&n;&t; * Can we trust the reported IRQ?&n;&t; */
id|pciirq
op_assign
id|dev-&gt;irq
suffix:semicolon
multiline_comment|/* Is it an &quot;IDE storage&quot; device in non-PCI mode? */
r_if
c_cond
(paren
(paren
id|dev
op_member_access_from_pointer
r_class
op_rshift
l_int|8
)paren
op_eq
id|PCI_CLASS_STORAGE_IDE
op_logical_and
(paren
id|dev
op_member_access_from_pointer
r_class
op_amp
l_int|5
)paren
op_ne
l_int|5
)paren
(brace
r_if
c_cond
(paren
id|noisy
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: not 100%% native mode: &quot;
l_string|&quot;will probe irqs later&bslash;n&quot;
comma
id|d-&gt;name
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * This allows offboard ide-pci cards the enable a BIOS,&n;&t;&t; * verify interrupt settings of split-mirror pci-config&n;&t;&t; * space, place chipset into init-mode, and/or preserve&n;&t;&t; * an interrupt if the card is not native ide support.&n;&t;&t; */
id|ret
op_assign
id|d-&gt;init_chipset
ques
c_cond
id|d
op_member_access_from_pointer
id|init_chipset
c_func
(paren
id|dev
comma
id|d-&gt;name
)paren
suffix:colon
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
r_goto
id|err_release_pci_controller
suffix:semicolon
id|pciirq
op_assign
id|ret
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|tried_config
)paren
(brace
r_if
c_cond
(paren
id|noisy
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: will probe irqs later&bslash;n&quot;
comma
id|d-&gt;name
)paren
suffix:semicolon
id|pciirq
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|pciirq
)paren
(brace
r_if
c_cond
(paren
id|noisy
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: bad irq (%d): will probe later&bslash;n&quot;
comma
id|d-&gt;name
comma
id|pciirq
)paren
suffix:semicolon
id|pciirq
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|d-&gt;init_chipset
)paren
(brace
id|ret
op_assign
id|d
op_member_access_from_pointer
id|init_chipset
c_func
(paren
id|dev
comma
id|d-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
r_goto
id|err_release_pci_controller
suffix:semicolon
)brace
r_if
c_cond
(paren
id|noisy
)paren
macro_line|#ifdef __sparc__
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: 100%% native mode on irq %s&bslash;n&quot;
comma
id|d-&gt;name
comma
id|__irq_itoa
c_func
(paren
id|pciirq
)paren
)paren
suffix:semicolon
macro_line|#else
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: 100%% native mode on irq %d&bslash;n&quot;
comma
id|d-&gt;name
comma
id|pciirq
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/* FIXME: silent failure can happen */
op_star
id|index
op_assign
id|ata_index
suffix:semicolon
id|ide_pci_setup_ports
c_func
(paren
id|dev
comma
id|d
comma
id|pciirq
comma
id|index
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|ret
suffix:semicolon
id|err_release_pci_controller
suffix:colon
id|ide_release_pci_controller
c_func
(paren
id|dev
comma
id|d
comma
id|noisy
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
DECL|function|ide_setup_pci_device
r_int
id|ide_setup_pci_device
c_func
(paren
r_struct
id|pci_dev
op_star
id|dev
comma
id|ide_pci_device_t
op_star
id|d
)paren
(brace
id|ata_index_t
id|index_list
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|ret
op_assign
id|do_ide_setup_pci_device
c_func
(paren
id|dev
comma
id|d
comma
op_amp
id|index_list
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
(paren
id|index_list.b.low
op_amp
l_int|0xf0
)paren
op_ne
l_int|0xf0
)paren
id|probe_hwif_init_with_fixup
c_func
(paren
op_amp
id|ide_hwifs
(braket
id|index_list.b.low
)braket
comma
id|d-&gt;fixup
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|index_list.b.high
op_amp
l_int|0xf0
)paren
op_ne
l_int|0xf0
)paren
id|probe_hwif_init_with_fixup
c_func
(paren
op_amp
id|ide_hwifs
(braket
id|index_list.b.high
)braket
comma
id|d-&gt;fixup
)paren
suffix:semicolon
id|create_proc_ide_interfaces
c_func
(paren
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|ret
suffix:semicolon
)brace
DECL|variable|ide_setup_pci_device
id|EXPORT_SYMBOL_GPL
c_func
(paren
id|ide_setup_pci_device
)paren
suffix:semicolon
DECL|function|ide_setup_pci_devices
r_int
id|ide_setup_pci_devices
c_func
(paren
r_struct
id|pci_dev
op_star
id|dev1
comma
r_struct
id|pci_dev
op_star
id|dev2
comma
id|ide_pci_device_t
op_star
id|d
)paren
(brace
r_struct
id|pci_dev
op_star
id|pdev
(braket
)braket
op_assign
(brace
id|dev1
comma
id|dev2
)brace
suffix:semicolon
id|ata_index_t
id|index_list
(braket
l_int|2
)braket
suffix:semicolon
r_int
id|ret
comma
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|2
suffix:semicolon
id|i
op_increment
)paren
(brace
id|ret
op_assign
id|do_ide_setup_pci_device
c_func
(paren
id|pdev
(braket
id|i
)braket
comma
id|d
comma
id|index_list
op_plus
id|i
comma
op_logical_neg
id|i
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * FIXME: Mom, mom, they stole me the helper function to undo&n;&t;&t; * do_ide_setup_pci_device() on the first device!&n;&t;&t; */
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
r_goto
id|out
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|2
suffix:semicolon
id|i
op_increment
)paren
(brace
id|u8
id|idx
(braket
l_int|2
)braket
op_assign
(brace
id|index_list
(braket
id|i
)braket
dot
id|b.low
comma
id|index_list
(braket
id|i
)braket
dot
id|b.high
)brace
suffix:semicolon
r_int
id|j
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
l_int|2
suffix:semicolon
id|j
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|idx
(braket
id|j
)braket
op_amp
l_int|0xf0
)paren
op_ne
l_int|0xf0
)paren
id|probe_hwif_init
c_func
(paren
id|ide_hwifs
op_plus
id|idx
(braket
id|j
)braket
)paren
suffix:semicolon
)brace
)brace
id|create_proc_ide_interfaces
c_func
(paren
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|ret
suffix:semicolon
)brace
DECL|variable|ide_setup_pci_devices
id|EXPORT_SYMBOL_GPL
c_func
(paren
id|ide_setup_pci_devices
)paren
suffix:semicolon
multiline_comment|/*&n; *&t;Module interfaces&n; */
DECL|variable|pre_init
r_static
r_int
id|pre_init
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Before first ordered IDE scan */
r_static
id|LIST_HEAD
c_func
(paren
id|ide_pci_drivers
)paren
suffix:semicolon
multiline_comment|/*&n; *&t;ide_register_pci_driver&t;&t;-&t;attach IDE driver&n; *&t;@driver: pci driver&n; *&n; *&t;Registers a driver with the IDE layer. The IDE layer arranges that&n; *&t;boot time setup is done in the expected device order and then &n; *&t;hands the controllers off to the core PCI code to do the rest of&n; *&t;the work.&n; *&n; *&t;The driver_data of the driver table must point to an ide_pci_device_t&n; *&t;describing the interface.&n; *&n; *&t;Returns are the same as for pci_register_driver&n; */
DECL|function|ide_pci_register_driver
r_int
id|ide_pci_register_driver
c_func
(paren
r_struct
id|pci_driver
op_star
id|driver
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|pre_init
)paren
(brace
r_return
id|pci_module_init
c_func
(paren
id|driver
)paren
suffix:semicolon
)brace
id|list_add_tail
c_func
(paren
op_amp
id|driver-&gt;node
comma
op_amp
id|ide_pci_drivers
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|ide_pci_register_driver
id|EXPORT_SYMBOL_GPL
c_func
(paren
id|ide_pci_register_driver
)paren
suffix:semicolon
multiline_comment|/**&n; *&t;ide_unregister_pci_driver&t;-&t;unregister an IDE driver&n; *&t;@driver: driver to remove&n; *&n; *&t;Unregister a currently installed IDE driver. Returns are the same&n; *&t;as for pci_unregister_driver&n; */
DECL|function|ide_pci_unregister_driver
r_void
id|ide_pci_unregister_driver
c_func
(paren
r_struct
id|pci_driver
op_star
id|driver
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|pre_init
)paren
(brace
id|pci_unregister_driver
c_func
(paren
id|driver
)paren
suffix:semicolon
)brace
r_else
id|list_del
c_func
(paren
op_amp
id|driver-&gt;node
)paren
suffix:semicolon
)brace
DECL|variable|ide_pci_unregister_driver
id|EXPORT_SYMBOL_GPL
c_func
(paren
id|ide_pci_unregister_driver
)paren
suffix:semicolon
multiline_comment|/**&n; *&t;ide_scan_pcidev&t;&t;-&t;find an IDE driver for a device&n; *&t;@dev: PCI device to check&n; *&n; *&t;Look for an IDE driver to handle the device we are considering.&n; *&t;This is only used during boot up to get the ordering correct. After&n; *&t;boot up the pci layer takes over the job.&n; */
DECL|function|ide_scan_pcidev
r_static
r_int
id|__init
id|ide_scan_pcidev
c_func
(paren
r_struct
id|pci_dev
op_star
id|dev
)paren
(brace
r_struct
id|list_head
op_star
id|l
suffix:semicolon
r_struct
id|pci_driver
op_star
id|d
suffix:semicolon
id|list_for_each
c_func
(paren
id|l
comma
op_amp
id|ide_pci_drivers
)paren
(brace
id|d
op_assign
id|list_entry
c_func
(paren
id|l
comma
r_struct
id|pci_driver
comma
id|node
)paren
suffix:semicolon
r_if
c_cond
(paren
id|d-&gt;id_table
)paren
(brace
r_const
r_struct
id|pci_device_id
op_star
id|id
op_assign
id|pci_match_device
c_func
(paren
id|d-&gt;id_table
comma
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|id
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|d
op_member_access_from_pointer
id|probe
c_func
(paren
id|dev
comma
id|id
)paren
op_ge
l_int|0
)paren
(brace
id|dev-&gt;driver
op_assign
id|d
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;ide_scan_pcibus&t;&t;-&t;perform the initial IDE driver scan&n; *&t;@scan_direction: set for reverse order scanning&n; *&n; *&t;Perform the initial bus rather than driver ordered scan of the&n; *&t;PCI drivers. After this all IDE pci handling becomes standard&n; *&t;module ordering not traditionally ordered.&n; */
DECL|function|ide_scan_pcibus
r_void
id|__init
id|ide_scan_pcibus
(paren
r_int
id|scan_direction
)paren
(brace
r_struct
id|pci_dev
op_star
id|dev
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|pci_driver
op_star
id|d
suffix:semicolon
r_struct
id|list_head
op_star
id|l
comma
op_star
id|n
suffix:semicolon
id|pre_init
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|scan_direction
)paren
(brace
r_while
c_loop
(paren
(paren
id|dev
op_assign
id|pci_find_device
c_func
(paren
id|PCI_ANY_ID
comma
id|PCI_ANY_ID
comma
id|dev
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|ide_scan_pcidev
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
r_while
c_loop
(paren
(paren
id|dev
op_assign
id|pci_find_device_reverse
c_func
(paren
id|PCI_ANY_ID
comma
id|PCI_ANY_ID
comma
id|dev
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|ide_scan_pcidev
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; *&t;Hand the drivers over to the PCI layer now we&n;&t; *&t;are post init.&n;&t; */
id|list_for_each_safe
c_func
(paren
id|l
comma
id|n
comma
op_amp
id|ide_pci_drivers
)paren
(brace
id|list_del
c_func
(paren
id|l
)paren
suffix:semicolon
id|d
op_assign
id|list_entry
c_func
(paren
id|l
comma
r_struct
id|pci_driver
comma
id|node
)paren
suffix:semicolon
id|pci_register_driver
c_func
(paren
id|d
)paren
suffix:semicolon
)brace
)brace
eof
